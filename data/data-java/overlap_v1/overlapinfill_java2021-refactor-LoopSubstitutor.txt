--- 0 --
Question ID: 36387dd02e802b9e3c3f2cd575b8ec1e1c862fe8
Original Code:
```
public class ReorderNoCross {

    private final ArrayList<String> joinSchema;

    private final ArrayList<String> lastJoinVars;

    private BasicPattern inputPattern;

    private final BasicPattern outputPattern;

    public ReorderNoCross() {
        joinSchema = new ArrayList<String>();
        lastJoinVars = new ArrayList<String>();
        outputPattern = new BasicPattern();
    }

    public BasicPattern reorder(BasicPattern pattern) {
        inputPattern = pattern;
        List<Triple> triples = inputPattern.getList();
        int idx = chooseFirst();
        Triple triple = triples.get(idx);
        outputPattern.add(triple);
        joinSchema.addAll(getVarsOfTriple(triple));
        triples.remove(idx);
        for (; !triples.isEmpty(); ) {
            idx = chooseNext();
            triple = triples.get(idx);
            outputPattern.add(triple);
            joinSchema.addAll(getVarsOfTriple(triple));
            triples.remove(idx);
        }
        return outputPattern;
    }

    private int chooseNext() {
        ArrayList<String> tripleVars;
        ArrayList<String> sharedVars;
        for (int i = 0; i < inputPattern.size(); i++) {
            tripleVars = getVarsOfTriple(inputPattern.get(i));
            sharedVars = getSharedVars(joinSchema, tripleVars);
            if (lastJoinVars.size() > 0 && lastJoinVars.size() == sharedVars.size() && lastJoinVars.containsAll(sharedVars)) {
                // lastJoinVars remain unchanged
                return i;
            }
        }
        for (int i = 0; i < inputPattern.size(); i++) {
            tripleVars = getVarsOfTriple(inputPattern.get(i));
            sharedVars = getSharedVars(joinSchema, tripleVars);
            if (sharedVars.size() > 0) {
                lastJoinVars.clear();
                lastJoinVars.addAll(sharedVars);
                return i;
            }
        }
        lastJoinVars.clear();
        return 0;
    }

    private int chooseFirst() {
        for (int i = 0; i < inputPattern.size(); i++) {
            if (hasSharedVars(i)) {
                return i;
            }
        }
        return 0;
    }

    private boolean hasSharedVars(int triplePos) {
        Triple triple = inputPattern.get(triplePos);
        ArrayList<String> tripleVars = getVarsOfTriple(triple);
        for (int i = 0; i < inputPattern.size(); i++) {
            if (i != triplePos && getSharedVars(getVarsOfTriple(inputPattern.get(i)), tripleVars).size() > 0) {
                return true;
            }
        }
        return false;
    }

    private ArrayList<String> getVarsOfTriple(Triple t) {
        ArrayList<String> vars = new ArrayList<String>();
        Node subject = t.getSubject();
        Node predicate = t.getPredicate();
        Node object = t.getObject();
        if (subject.isVariable())
            vars.add(subject.getName());
        if (predicate.isVariable())
            vars.add(predicate.getName());
        if (object.isVariable())
            vars.add(object.getName());
        return vars;
    }

    private ArrayList<String> getSharedVars(ArrayList<String> leftSchema, ArrayList<String> rightSchema) {
        ArrayList<String> sharedVars = new ArrayList<String>();
        for (int i = 0; i < rightSchema.size(); i++) {
            if (leftSchema.contains(rightSchema.get(i)))
                sharedVars.add(rightSchema.get(i));
        }
        return sharedVars;
    }
}

```


Overlapping Code:
```
yList<String> joinSchema;
private final ArrayList<String> lastJoinVars;
private BasicPattern inputPattern;
private final BasicPattern outputPattern;
public ReorderNoCross() {
joinSchema = new ArrayList<String>();
lastJoinVars = new ArrayList<String>();
outputPattern = new BasicPattern();
}
public BasicPattern reorder(BasicPattern pattern) {
inputPattern = pattern;
List<Triple> triples = inputPattern.getList();
int idx = chooseFirst();
Triple triple = triples.get(idx);
outputPattern.add(triple);
joinSchema.addAll(getVarsOfTriple(triple));
triplechooseNext();
triple = triples.get(idx);
outputPattern.add(triple);
joinSchema.addAll(getVarsOfTriple(triple));
triples.remove(idx);
}
return outputPattern;
}
private int chooseNext() {
ArrayList<String> tripleVars;
ArrayList<String> sharedVars;
for ripleVars = getVarsOfTriple(inputPattern.get(i));
sharedVars = getSharedVars(joinSchema, tripleVars);
if (lastJoinVars.size() > 0 && lastJoinVars.size() == sharedVars.size() && lastJoinVars.containsAll(sharedVars)) {
// lastJoinVars remain unchanged
return i;ripleVars = getVarsOfTriple(inputPattern.get(i));
sharedVars = getSharedVars(joinSchema, tripleVars);
if (sharedVars.size() > 0) {
lastJoinVars.clear();
lastJoinVars.addAll(sharedVars);
return i;
}
}
lastJoinVars.clear();
return 0;
}
private int choo++) {
if (hasSharedVars(i)) {
return i;
}
}
return 0;
}
private boolean hasSharedVars(int triplePos) {
Triple triple = inputPattern.get(triplePos);
ArrayList<String> tripleVars = getVarsOfTriple(tripl (i != triplePos && getSharedVars(getVarsOfTriple(inputPattern.get(i)), tripleVars).size() > 0) {
re
```
<Overlap Ratio: 0.8388946819603754>

---

--- 1 --
Question ID: fd52101a33b5d14359ea4a2449bf8b531284b2c9
Original Code:
```
public class NonStartTest {

    private NonStart fixture;

    @BeforeEach
    public void setUp() {
        fixture = new NonStart();
    }

    @Test
    public void testcase1() {
        final String strA = "Hello";
        final String strB = "There";
        final String expected = "ellohere";
        final String actual = fixture.nonStart(strA, strB);
        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void testcase2() {
        final String strA = "java";
        final String strB = "code";
        final String expected = "avaode";
        final String actual = fixture.nonStart(strA, strB);
        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void testcase3() {
        final String strA = "shotl";
        final String strB = "java";
        final String expected = "hotlava";
        final String actual = fixture.nonStart(strA, strB);
        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void shouldReturnEmptyWhenBothAreNull() {
        final String strA = null;
        final String strB = null;
        final String expected = "";
        final String actual = fixture.nonStart(strA, strB);
        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void shouldReturnEmptyWhenBothAreEmpty() {
        final String strA = "";
        final String strB = "";
        final String expected = "";
        final String actual = fixture.nonStart(strA, strB);
        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void shouldReturnEmptyWhenOneIsEmptyAndOtherIsNull() {
        final String strA1 = null;
        final String strA2 = "";
        final String strB1 = "";
        final String strB2 = null;
        final String expected = "";
        final String actual1 = fixture.nonStart(strA1, strB1);
        final String actual2 = fixture.nonStart(strA2, strB2);
        assertThat(actual1).isEqualTo(expected);
        assertThat(actual2).isEqualTo(expected);
    }
}

```


Overlapping Code:
```
t {
private NonStart fixture;
@BeforeEach
public void setUp() {
fixture = new NonStart();
}
@Test
public void testcase1() {
final String strA = "Hello";
final String strB = "There";
final String expected = "ellohere";
final String actual = fixture.nonStart(strA, strB);
assertThat(actual).isEqualTo(expected);
}
@Test
public void testcase2() {
final String strA = "java";
final String strB = "code";
final String expected = "avaode";
final String actual = fixture.nonStart(strA, strB);
assertThat(actual).isEqualTo(expected);
}
@Test
public void testcase3() {
final String strA = "shotl";
final String strB = "java";
final String expected = "hotlava";
final String actual = fixture.nonStart(strA, strB);
assertThat(actual).isEqualTo(expected);
}
@Test
public void shouldReturnEmptyWhenBothAreNull() {
final String strA = null;
final String strB = null;
final String expected = "";
final String actual = fixture.nonStart(strA, strB);
assertThat(actual).isEqualTo(expected);
}
@Test
public void shouldReturnEmptyWhenBothAreEmpty() {
final String strA = "";
final String strB = "";
final String expected = "";
final String actual = fixture.nonStart(strA, strB);
assertThat(actual).isEqualTo(expected);
}
@Test
public void shouldReturnEmptyWhenOneIsEmptyAndOtherIsNull() {
final String strA1 = null;
final String strA2 = "";
final String strB1 = "";
final String strB2 = null;
final String expected = "";
final String actual1 = fixture.nonStart(strA1, strB1);
final String actual2 = fixture.nonStart(strA2, strB2);
assertThat(actual1).isEqualTo(expected);
assertThat(actual2).isEqualTo(expected);
}

```
<Overlap Ratio: 0.9845679012345679>

---

--- 2 --
Question ID: 3c9b0668c602f3425aef938ddbcd842b6fc11a32
Original Code:
```
@Component
@ConditionalOnProperty(value = "datasource-observer.sentinelhub.enabled", havingValue = "true")
public class SentinelJobFactory implements JobFactory {

    private static final Logger LOG = LoggerFactory.getLogger(SentinelJobFactory.class);

    @Autowired
    private ExecutionIntervalConfig intervalConfig;

    @Override
    public boolean supportsJobDefinition(WacodisJobDefinition job) {
        long count = job.getInputs().stream().filter(i -> i instanceof CopernicusSubsetDefinition).count();
        return count > 0;
    }

    @Override
    public JobBuilder initializeJobBuilder(WacodisJobDefinition job, JobDataMap data, AbstractSubsetDefinition subsetDefinition) {
        // this should always be the case
        if (subsetDefinition instanceof CopernicusSubsetDefinition) {
            LOG.info("Preparing SentinelJob JobDetail");
            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;
            if (copDef.getMaximumCloudCoverage() > 0) {
                data.put(SentinelJob.MAX_CLOUD_COVERAGE_KEY, copDef.getMaximumCloudCoverage());
            }
            switch(copDef.getSatellite()) {
                case _1:
                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel1);
                    break;
                case _2:
                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel2);
                    break;
                case _3:
                    data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel3);
                    break;
            }
            if (job.getTemporalCoverage() != null && !StringUtils.isEmpty(job.getTemporalCoverage().getDuration())) {
                Period period = ISOPeriodFormat.standard().parsePeriod(job.getTemporalCoverage().getDuration());
                int baseDays = period.getDays();
                if (period.getHours() > 11) {
                    // round to full days
                    baseDays++;
                }
                data.put(SentinelJob.PREVIOUS_DAYS_KEY, baseDays);
            }
            data.put("executionInterval", intervalConfig.getSentinel());
        }
        // create the quartz object
        return JobBuilder.newJob(SentinelJob.class).usingJobData(data);
    }

    @Override
    public Stream<AbstractSubsetDefinition> filterJobInputs(WacodisJobDefinition job) {
        return job.getInputs().stream().filter((i -> i instanceof CopernicusSubsetDefinition));
    }

    @Override
    public String generateSubsetSpecificIdentifier(AbstractSubsetDefinition subsetDefinition) {
        StringBuilder builder = new StringBuilder("");
        if (subsetDefinition instanceof CopernicusSubsetDefinition) {
            CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;
            builder.append(copDef.getSourceType());
            if (copDef.getSatellite() != null) {
                builder.append("_" + copDef.getSatellite());
            }
        }
        return builder.toString();
    }

    @Override
    public Class getQuartzJobClass() {
        // TODO Auto-generated method stub
        return SentinelJob.class;
    }

    @Override
    public JobDetail modifyBboxParameter(JobDetail jobDetail, String expandedBbox) {
        // here we must do nothing as this Job dies not specify BBOX parameter
        return jobDetail;
    }
}

```


Overlapping Code:
```
nditionalOnProperty(value = "datasource-observer.sentinelhub.enabled", havingValue = "true")
public class SentinelJobFactory implements JobFactory {
private static final Logger LOG = LoggerFactory.getLogger(SentinelJobFactory.class);
@Autowired
private ExecutionIntervalConfig intervalConfig;
@Override
public boolean supportsJobDefinition(WacodisJobDefinition job) {
long count = job.getInputs().stream().filter(i -> i instanceof CopernicusSubsetDefinition).count();
return count > 0;
}
@Override
public JobBuilder initializeJobBuilder(WacodisJobDefinition job, JobDataMap data, AbstractSubsetDefinition subsetDefinition) {
// this should always be the case
if (subsetDefinition instanceof CopernicusSubsetDefinition) {
LOG.info("Preparing SentinelJob JobDetail");
CopernicusSubsetDefinition copDef = (CopernicusSubsetDefinition) subsetDefinition;
if (copDef.getMaximumCloudCoverage() > 0) {
data.put(SentinelJob.MAX_CLOUD_COVERAGE_KEY, copDef.getMaximumClocase _1:
data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel1);
break;
case _2:
data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel2);
break;
case _3:
data.put(SentinelJob.PLATFORM_KEY, QueryBuilder.PlatformName.Sentinel3);
break;
}
if (job.getTemporalCoverage() != null && !StringUtils.isEmpty(job.getTemporalCoverage().getDuration())) {
Period period = ISOPeriodFormat.standard().parsePeriod(job.getTemporalCoverage().getDuration());
int baseDays = period.getDays();
if (period.getHours() > 11) {
// round to full days
baseDays++;
}
data.put(SentinelJob.PREVIOUS_DAYS_KEY, baseDays);
}
data.put("executionInterval", intervalConfig.getSentinel());
}
// create the quartz object
return JobBuilder.newJob(SentinelJo.class).usingJobData(data);
}
@Override
public Stream<AbstractSubsetDefinition> filterJobInputs(WacodisJobDefinition job) {
return job.getInputs().stream().filter((i -> i instanceof CopernicusSubsetDe
```
<Overlap Ratio: 0.9665653495440729>

---

--- 3 --
Question ID: cd0f2db9b8d8fdb1a2153a795392c8830796df8a
Original Code:
```
public class UserStory9 {

    private String taskId;

    private String title;

    private String firstUpdate;

    private String secondUpdate;

    @When("I adjust the priority of a task to a new priority")
    public void i_adjust_the_priority_of_a_task_to_a_new_priority() {
        taskId = "1";
        title = "scan paperwork";
        firstUpdate = "HIGH";
        secondUpdate = "LOW";
        try {
            String request = "http://localhost:4567/todos/" + taskId;
            URL url = new URL(request);
            HttpURLConnection con = (HttpURLConnection) url.openConnection();
            con.setRequestMethod("PUT");
            con.setRequestProperty("Content-Type", "application/json; utf-8");
            con.setRequestProperty("Accept", "application/json");
            con.setDoOutput(true);
            String jsonInputString = " {\"title\":\"" + title + "\", \"description\":" + firstUpdate + "}";
            try (OutputStream os = con.getOutputStream()) {
                byte[] input = jsonInputString.getBytes("utf-8");
                os.write(input, 0, input.length);
            }
            int code = con.getResponseCode();
            assertEquals(code, 200);
        } catch (Exception e) {
            e.printStackTrace();
        }
        try {
            String request = "http://localhost:4567/todos/" + taskId;
            URL url = new URL(request);
            HttpURLConnection con = (HttpURLConnection) url.openConnection();
            con.setRequestMethod("PUT");
            con.setRequestProperty("Content-Type", "application/json; utf-8");
            con.setRequestProperty("Accept", "application/json");
            con.setDoOutput(true);
            String jsonInputString = " {\"title\":\"" + title + "\", \"description\":" + secondUpdate + "}";
            try (OutputStream os = con.getOutputStream()) {
                byte[] input = jsonInputString.getBytes("utf-8");
                os.write(input, 0, input.length);
            }
            int code = con.getResponseCode();
            assertEquals(code, 200);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Then("I can view the task and its updated priority")
    public void i_can_view_the_task_and_its_updated_priority() {
        taskId = "1";
        try {
            String request = "http://localhost:4567/todos/" + taskId;
            URL url = new URL(request);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            conn.connect();
            int code = conn.getResponseCode();
            assertEquals(code, 200);
            String inline = "";
            Scanner scanner = new Scanner(url.openStream());
            for (; scanner.hasNext(); ) {
                inline += scanner.nextLine();
            }
            System.out.println(inline);
            //Close the scanner
            scanner.close();
        } catch (Exception e) {
        }
    }

    @When("I adjust the priority of a task to the same priority")
    public void i_adjust_the_priority_of_a_task_to_the_same_priority() {
        taskId = "1";
        title = "scan paperwork";
        firstUpdate = "MEDIUM";
        secondUpdate = "MEDIUM";
        try {
            String request = "http://localhost:4567/todos/" + taskId;
            URL url = new URL(request);
            HttpURLConnection con = (HttpURLConnection) url.openConnection();
            con.setRequestMethod("PUT");
            con.setRequestProperty("Content-Type", "application/json; utf-8");
            con.setRequestProperty("Accept", "application/json");
            con.setDoOutput(true);
            String jsonInputString = " {\"title\":\"" + title + "\", \"description\":" + firstUpdate + "}";
            try (OutputStream os = con.getOutputStream()) {
                byte[] input = jsonInputString.getBytes("utf-8");
                os.write(input, 0, input.length);
            }
            int code = con.getResponseCode();
            assertEquals(code, 200);
        } catch (Exception e) {
            e.printStackTrace();
        }
        try {
            String request = "http://localhost:4567/todos/" + taskId;
            URL url = new URL(request);
            HttpURLConnection con = (HttpURLConnection) url.openConnection();
            con.setRequestMethod("PUT");
            con.setRequestProperty("Content-Type", "application/json; utf-8");
            con.setRequestProperty("Accept", "application/json");
            con.setDoOutput(true);
            String jsonInputString = " {\"title\":\"" + title + "\", \"description\":" + secondUpdate + "}";
            try (OutputStream os = con.getOutputStream()) {
                byte[] input = jsonInputString.getBytes("utf-8");
                os.write(input, 0, input.length);
            }
            int code = con.getResponseCode();
            assertEquals(code, 200);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Then("I can view the task and its unchanged priority")
    public void i_can_view_the_task_and_its_unchanged_priority() {
        taskId = "1";
        try {
            String request = "http://localhost:4567/todos/" + taskId;
            URL url = new URL(request);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            conn.connect();
            int code = conn.getResponseCode();
            assertEquals(code, 200);
            String inline = "";
            Scanner scanner = new Scanner(url.openStream());
            for (; scanner.hasNext(); ) {
                inline += scanner.nextLine();
            }
            System.out.println(inline);
            //Close the scanner
            scanner.close();
        } catch (Exception e) {
        }
    }

    @When("I adjust the priority of a non-existent task")
    public void i_adjust_the_priority_of_a_non_existent_task() {
        taskId = "92";
        title = "scan paperwork";
        firstUpdate = "MEDIUM";
        secondUpdate = "MEDIUM";
        try {
            String request = "http://localhost:4567/todos/" + taskId;
            URL url = new URL(request);
            HttpURLConnection con = (HttpURLConnection) url.openConnection();
            con.setRequestMethod("PUT");
            con.setRequestProperty("Content-Type", "application/json; utf-8");
            con.setRequestProperty("Accept", "application/json");
            con.setDoOutput(true);
            String jsonInputString = " {\"title\":\"" + title + "\", \"description\":" + firstUpdate + "}";
            try (OutputStream os = con.getOutputStream()) {
                byte[] input = jsonInputString.getBytes("utf-8");
                os.write(input, 0, input.length);
            }
            int code = con.getResponseCode();
            assertEquals(code, 404);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Then("I get a Not Found error")
    public void i_get_a_not_found_error() {
        taskId = "92";
        title = "scan paperwork";
        firstUpdate = "MEDIUM";
        secondUpdate = "MEDIUM";
        try {
            String request = "http://localhost:4567/todos/" + taskId;
            URL url = new URL(request);
            HttpURLConnection con = (HttpURLConnection) url.openConnection();
            con.setRequestMethod("PUT");
            con.setRequestProperty("Content-Type", "application/json; utf-8");
            con.setRequestProperty("Accept", "application/json");
            con.setDoOutput(true);
            String jsonInputString = " {\"title\":\"" + title + "\", \"description\":" + firstUpdate + "}";
            try (OutputStream os = con.getOutputStream()) {
                byte[] input = jsonInputString.getBytes("utf-8");
                os.write(input, 0, input.length);
            }
            int code = con.getResponseCode();
            assertEquals(code, 404);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @When("I adjust the priority of a {string} {string} to {string}")
    public void i_adjust_the_priority_of_a_to(String taskId, String title, String priority) {
        try {
            String request = "http://localhost:4567/todos/" + taskId;
            URL url = new URL(request);
            HttpURLConnection con = (HttpURLConnection) url.openConnection();
            con.setRequestMethod("PUT");
            con.setRequestProperty("Content-Type", "application/json; utf-8");
            con.setRequestProperty("Accept", "application/json");
            con.setDoOutput(true);
            String jsonInputString = " {\"title\":\"" + title + "\", \"description\":" + priority + "}";
            try (OutputStream os = con.getOutputStream()) {
                byte[] input = jsonInputString.getBytes("utf-8");
                os.write(input, 0, input.length);
            }
            int code = con.getResponseCode();
            assertEquals(code, 200);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Then("I can view the {string} {string} and its updated {string}")
    public void i_can_view_the_and_its_updated(String taskId, String title, String priority) {
        try {
            String request = "http://localhost:4567/todos/" + taskId;
            URL url = new URL(request);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            conn.connect();
            int code = conn.getResponseCode();
            assertEquals(code, 200);
            String inline = "";
            Scanner scanner = new Scanner(url.openStream());
            for (; scanner.hasNext(); ) {
                inline += scanner.nextLine();
            }
            System.out.println(inline);
            //Close the scanner
            scanner.close();
        } catch (Exception e) {
        }
    }
}

```


Overlapping Code:
```
te String title;
private String firstUpdate;
privaity of a task to a new priority")
public void i_adjust_the_priority_of_a_task_to_a_new_priority() {
taskId = "1";
title = "scan paperwork";
firstUpda";
try {
String request = "http://localhost:4567/todos/" + taskId;
URL url = new URL(request);
HttpURLConnection con = (HttpURLConnection) url.openConnection();
con.setRequestMethod("PUT");
con.setRequestProperty("Content-Type", "application/json; utf-8");
con.setRequestProperty("Accept", "application/json");
con.setDoOutput(true);
String jsonInputString = ""}";
try (OutputStream os = con.getOutputStream()) {
byte[] input = jsonInputString.getBytes("utf-8");
os.write(input, 0, input.length);
}
int code = con.getResponseCode();
assertEquals(code, 200);
} catch (Exception e) {
e.printStackTrace();
}
try {
String request = "http://localhost:4567/todos/" + taskId;
URL url = new URL(request);
HttpURLConnection con = (HttpURLConnection) url.openConnection();
con.setRequestMethod("PUT");
con.setRequestProperty("Content-Type", "application/json; utf-8");
con.setRequestProperty("Accept", "application/json");
con.setDoOutput(true);
String jsonInputString = ""}";
try (OutputStream os = con.getOutputStream()) {
byte[] input = jsonInputString.getBytes("utf-8");
os.write(input, 0, input.length);
}
int code = con.getResponseCode();
assertEquals(code, 200);
} catch (Exception e) {
e.printStackTrace();
}
}
@Tthe task and its updated priority")
public void i_taskId = "1";
try {
String request = "http://localhost:4567/todos/" + taskId;
URL url = new URL(request);
HttpURLConnection conn = (HttpURLConnection) url.openC
```
<Overlap Ratio: 0.8311954848640328>

---

--- 4 --
Question ID: 7d552efcea6c5f5cdd42841cc34ad20e76f615e1
Original Code:
```
public final class MatrixAppendCPInstruction extends AppendCPInstruction {

    protected MatrixAppendCPInstruction(Operator op, CPOperand in1, CPOperand in2, CPOperand out, AppendType type, String opcode, String istr) {
        super(op, in1, in2, out, type, opcode, istr);
    }

    @Override
    public void processInstruction(ExecutionContext ec) {
        // get inputs
        MatrixBlock matBlock1 = ec.getMatrixInput(input1.getName());
        MatrixBlock matBlock2 = ec.getMatrixInput(input2.getName());
        validateInput(matBlock1, matBlock2);
        MatrixBlock ret;
        if (matBlock1 instanceof CompressedMatrixBlock || matBlock2 instanceof CompressedMatrixBlock)
            ret = CLALibAppend.append(matBlock1, matBlock2);
        else
            ret = matBlock1.append(matBlock2, new MatrixBlock(), _type == AppendType.CBIND);
        ec.setMatrixOutput(output.getName(), ret);
        ec.releaseMatrixInput(input1.getName(), input2.getName());
    }

    private void validateInput(MatrixBlock m1, MatrixBlock m2) {
        if (_type == AppendType.CBIND && m1.getNumRows() != m2.getNumRows()) {
            throw new DMLRuntimeException("Append-cbind is not possible for input matrices " + input1.getName() + " and " + input2.getName() + " with different number of rows: " + m1.getNumRows() + " vs " + m2.getNumRows());
        } else if (_type == AppendType.RBIND && m1.getNumColumns() != m2.getNumColumns()) {
            throw new DMLRuntimeException("Append-rbind is not possible for input matrices " + input1.getName() + " and " + input2.getName() + " with different number of columns: " + m1.getNumColumns() + " vs " + m2.getNumColumns());
        }
    }

    @Override
    public Pair<String, LineageItem> getLineageItem(ExecutionContext ec) {
        // TODO: break append to cbind and rbind for full compilation chain
        String opcode = _type.toString().toLowerCase();
        return Pair.of(output.getName(), new LineageItem(opcode, LineageItemUtils.getLineage(ec, input1, input2)));
    }
}

```


Overlapping Code:
```
CPInstruction extends AppendCPInstruction {
protected MatrixAppendCPInstruction(Operator op, CPOperand in1, CPOperand in2, CPOperand out, AppendType type, String opcode, String istr) {
super(op, in1, in2, out, type, opcode, istr);
}
@Override
public void processInstruction(ExecutionContext ec) {
// get inputs
MatrixBlock matBlock1 = ec.getMatrixInput(input1.getName());
MatrixBlock matBlock2 = ec.getMatrixInput(input2.getName());
validateInput(matinstanceof CompressedMatrixBlock || matBlock2 instanceof CompressedMatrixBlock)
ret = CLALibAppend.append(matBlock1, matBlock2);
else
ret = matBlock1.append(matBlock2, new MatrixBlock(), _type == AppendType.CBIND);
ec.setMatrixOutput(output.getName(), ret);
ec.releaseMatrixInput(input1.getName(), input2.getName());
}
private void validateInput(Matrpe.CBIND && m1.getNumRows() != m2.getNumRows()) {
throw new DMLRuntimeException("Append-cbind is not possible for input matrices " + input1.getName() + nput2.getName() + " with different number of rows: " + m1.getNumRows() + " vs " + m2.g&& m1.getNumColumns() != m2.getNumColumns()) {
throw new DMLRuntimeException("Append-rbind is not possible for input matrices " + input1.getName() + getName() + " with different number of columns: " + m1.getNumColumns() + " vs " + m2.getNumColumns());
}
}
@Override
public Pair<String, LineageItem> getLineageItem(ExecutionContext ec) {
// TODO: break append to cbind and rbind for full compilation chain
String opcode = _type.toString().toLowerCase();
return Pair.of(output.getName(), new LineageItem(opcode, LineageItemUtils.getLi
```
<Overlap Ratio: 0.8654906284454245>

---

--- 5 --
Question ID: 1734f11ef39ffc15b610a3bd91177494d7572518
Original Code:
```
public class DocumentIdNode extends DOMFragmentReader<DocumentId> {

    private static final Logger LOGGER = LoggerFactory.getLogger(DocumentIdNode.class);

    private static final XPath PATXP = DocumentHelper.createXPath("/DOCUMENT/PATN");

    private static final XPath NUMXP = DocumentHelper.createXPath("WKU");

    private static final XPath ISSUEDATEXP = DocumentHelper.createXPath("ISD");

    private static final CountryCode DEFAULT_COUNTRYCODE = CountryCode.US;

    private CountryCode fallbackCountryCode;

    public DocumentIdNode(Document document) {
        this(document, DEFAULT_COUNTRYCODE);
    }

    public DocumentIdNode(Document document, CountryCode fallbackCountryCode) {
        super(document);
        this.fallbackCountryCode = fallbackCountryCode;
    }

    @Override
    public DocumentId read() {
        Node parentNode = PATXP.selectSingleNode(document);
        Node docNumN = NUMXP.selectSingleNode(parentNode);
        if (docNumN == null) {
            LOGGER.warn("Invalid document-id, field 'WKU' not found: {}", document.asXML());
            return null;
        }
        String patNum = docNumN.getText().substring(1, 8);
        DocumentId documentId = new DocumentId(fallbackCountryCode, patNum);
        Node dateN = ISSUEDATEXP.selectSingleNode(parentNode);
        if (dateN != null) {
            String dateTxt = dateN.getText();
            try {
                documentId.setDate(new DocumentDate(dateTxt));
            } catch (InvalidDataException e) {
                LOGGER.warn("{} : {}", e.getMessage(), dateN.getParent().asXML());
            }
        }
        return documentId;
    }
}

```


Overlapping Code:
```
 DocumentIdNode extends DOMFragmentReader<DocumentId> {
private static final Logger LOGGER = LoggerFactory.getLogger(DocumentIdNode.class);
private static final XPath PATXP = DocumentHelper.createXPath("/DOCUMENT/PATN");
private static final XPath NUMXP = DocumentHelper.createXPath("WKU");
private static final XPath ISSUEDATEXP = DocumentHelper.createXPath("ISD");
private static final CountryCode DEFAULT_COUNTRYCODE = CountryCode.US;
private CountryCode fallbackCountryCode;
public DocumentIdNode(Document document) {
this(document, DEFAULT_COUNTRYCODE);
}
public DocumentIdNode(Document document, CountryCode fallbackCountryCode) {
super(document);
this.fallbackCountryCode = fallbackCountryCode;
}
@Override
public DocumentId read() {
Node parentNode = PATXP.selectSingleNode(document);
Node docNumN = NUMXP.selectSingleNode(parentNode);
if (docNumN == null) {
LOGGER.warn("Invalid document-id, field 'WKU' not found: {}", document.asXML());
return null;
}
String patNum = docNumN.getText().substring(1, 8);
DocumentId documentId = new DocumentId(fallbackCountryCode, patNum);
Node dateN = ISSUEDATEXP.selectSingleNode(parentNode);
if (dateN != null) {
String dateTxt = dateN.getText();
try {
documentId.setDate(new DocumentDate(dateTxt));
} catch (InvalidDataException e) {
LOGGER.warn("{} : {}", e.getMessage(), dateN.getParent().asXML());
}

```
<Overlap Ratio: 0.974025974025974>

---

--- 6 --
Question ID: 4c2bc8c459162886daf755bef05a05afec9240d5
Original Code:
```
public class LinkCommand extends RemoteControlCommandBase implements Cloneable {

    @Getter
    private String repeaterCallsign;

    @Getter
    private ReconnectType reconnectType;

    @Getter
    private String reflectorCallsign;

    public LinkCommand() {
        super(RemoteControlCommandType.LINK);
    }

    @Override
    public LinkCommand clone() {
        LinkCommand copy = null;
        copy = (LinkCommand) super.clone();
        copy.repeaterCallsign = repeaterCallsign;
        copy.reconnectType = reconnectType;
        copy.reflectorCallsign = reflectorCallsign;
        return copy;
    }

    @Override
    protected String getHeader() {
        return "LNK";
    }

    @Override
    protected boolean parseCommand(ByteBuffer srcBuffer) {
        int dataLength = DSTARDefines.CallsignFullLength + 4 + DSTARDefines.CallsignFullLength;
        if (srcBuffer == null || srcBuffer.remaining() < dataLength)
            return false;
        char[] call = new char[DSTARDefines.CallsignFullLength];
        int i = 0;
        while (i < DSTARDefines.CallsignFullLength) try {
            call[i] = (char) srcBuffer.get();
        } finally {
            i++;
        }
        repeaterCallsign = String.valueOf(call);
        int reconnectTypeValue = 0;
        int i = 0;
        while (i < 4) try {
            reconnectTypeValue <<= 8;
            reconnectTypeValue = (reconnectTypeValue & ~0xFF) | srcBuffer.get();
        } finally {
            i++;
        }
        this.reconnectType = ReconnectType.getReconnectTypeByVallue(reconnectTypeValue);
        int i = 0;
        while (i < DSTARDefines.CallsignFullLength) try {
            call[i] = (char) srcBuffer.get();
        } finally {
            i++;
        }
        reflectorCallsign = String.valueOf(call);
        return true;
    }

    @Override
    protected Optional<byte[]> assembleCommandInt() {
        return Optional.empty();
    }
}

```


Overlapping Code:
```
xtends RemoteControlCommandBase implements Cloneable {
@Getter
private String repeaterCallsign;
@Getter
private ReconnectType reconnectType;
@Getter
private String reflectorCallsign;
public LinkCommand() {
super(RemoteControlCommandType.LINK);
}
@Override
public LinkCommand clone() {
LinkCommand copy = super.clone();
copy.repeaterCallsign = repeaterCallsign;
copy.reconnectType = reconnectType;
copy.reflectorCallsign = reflectorCallsign;
return copy;
}
@Override
protected String getHeader() {
return "LNK";
}
@Override
protected boolean parseCommand(ByteBuffer srcBuffer) {
gnFullLength + 4 + DSTARDefines.CallsignFullLength == null || srcBuffer.remaining() < dataLength)
return false;
char[] call = new char[DSTARDefines.Cae = (reconnectTypeValue & ~0xFF) | srcBuffer.get();
}
this.reconnectType = ReconnectType.getReconnecing.valueOf(call);
return true;
}
@Override
protected Optional<byte[]> assembleCommandInt() {
return Optional.emp
```
<Overlap Ratio: 0.619486504279131>

---

--- 7 --
Question ID: 0e0da15f7cbb858c23517f700b77e09fcb2e8e1f
Original Code:
```
@WebServlet(name = "smarthomeUpdate", urlPatterns = "/smarthome/update")
public class SmartHomeUpdateServlet extends HttpServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(MySmartHomeApp.class);

    private static MyDataStore database = MyDataStore.getInstance();

    private final SmartHomeApp actionsApp = new MySmartHomeApp();

    //private String msg;
    private static final List<String> UPDATE_DEVICE_PARAMS_KEYS = Arrays.asList(new String[] { "name", "nickname", "localDeviceId", "errorCode", "tfa" });

    {
        try {
            GoogleCredentials credentials = GoogleCredentials.fromStream(getClass().getResourceAsStream("/smart-home-key.json"));
            actionsApp.setCredentials(credentials);
        } catch (Exception e) {
            LOGGER.error("couldn't load credentials");
        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {
        String body = req.getReader().lines().collect(Collectors.joining());
        LOGGER.info("doPost, body = {}", body);
        JsonObject bodyJson = new JsonParser().parse(body).getAsJsonObject();
        String userId = bodyJson.get("userId").getAsString();
        String deviceId = bodyJson.get("deviceId").getAsString();
        JsonObject states = bodyJson.getAsJsonObject("states");
        Map<String, Object> deviceStates = states != null ? new Gson().fromJson(states, HashMap.class) : null;
        Map<String, String> deviceParams = new HashMap<>();
        Set<String> deviceParamsKeys = bodyJson.keySet();
        deviceParamsKeys.retainAll(UPDATE_DEVICE_PARAMS_KEYS);
        for (String k : deviceParamsKeys) {
            deviceParams.put(k, bodyJson.get(k).getAsString());
        }
        try {
            database.updateDevice(userId, deviceId, deviceStates, deviceParams);
            if (deviceParams.containsKey("localDeviceId")) {
                actionsApp.requestSync(userId);
            }
            if (states != null) {
                ReportState.makeRequest(actionsApp, userId, deviceId, states);
            }
        } catch (Exception e) {
            LOGGER.error("failed to update device: {}", e);
            res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            res.setHeader("Access-Control-Allow-Origin", "*");
            res.setContentType("text/plain");
            res.getWriter().println("ERROR");
            return;
        }
        res.setStatus(HttpServletResponse.SC_OK);
        res.setHeader("Access-Control-Allow-Origin", "*");
        res.setContentType("text/plain");
        res.getWriter().println("OK");
    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        response.setContentType("text/plain");
        response.getWriter().println("/smarthome/update is a POST call");
    }

    @Override
    protected void doOptions(HttpServletRequest req, HttpServletResponse res) {
        // pre-flight request processing
        res.setHeader("Access-Control-Allow-Origin", "*");
        res.setHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
        res.setHeader("Access-Control-Allow-Headers", "X-Requested-With,Content-Type,Accept,Origin");
    }
}

```


Overlapping Code:
```
vlet(name = "smarthomeUpdate", urlPatterns = "/smarthome/update")
public class SmartHomeUpdateServlet extends HttpServlet {
private static final Logger LOGGER = LoggerFactory.getLogger(MySmartHomeApp.class);
private static MyDataStore database = MyDataStore.getInstance();
private final SmartHomeApp actionsApp = new MySmartHomeApp();
//private String msg;
private static final Listtry {
GoogleCredentials credentials = GoogleCredentials.fromStream(getClass().getResourceAsStream("/smart-home-key.json"));
actionsApp.setCredentials(credentials);
} catch (Exception e) {
LOGGER.error("couldn't load credentials");
}
}
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {
String body = req.getReader().lines().collect(Collectors.joining());
LOGGER.info("doPost, body = {}", body);
JsonObject bodyJson = new JsonParser().parse(body).getAsJsonObject();
String userId = bodyJson.get("userId").getAsString();
String deviceId = bodyJson.get("deviceId").getAsString();
JsonObject states = bodyJson.getAsJsonObject("s != null ? new Gson().fromJson(states, HashMap.class) : null;
Map<String, String> deviceParams = new HashMap<>();
Set<String> deviceParamsKeys = bodyJson.keySet();
deviceParamsKeys.retainAll(UPDATE_DEVICE_PARAMS_KEYS);
for (String k : deviceParamsKeys) {
deviceParams.put(k, bodyJson.get(k).getAsString());
}
try {
database.updateDevice(userId, deviceId, deviceStates, deviceParams);
if (deviceParams.containsKey("localDeviceId")) {
actionsApp.requestSync(userId);
}
if (states != null) {
ReportState.makeRequest(actionsApp, userId, deviceId, states);
}
} catch (Exception e) {
LOGGER.error("failed to update device: {}", e);
res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
res.setHeader("Access-Control-Allow-Origin", "*");
res.setContentType("text/plain");
res.getWriter().println("ERROR");
return;
}
res.setStatus(HttpServletResponse
```
<Overlap Ratio: 0.9106545628284759>

---

--- 8 --
Question ID: 23db7ae693e11efffaedcecc41a12084a78574f9
Original Code:
```
public class Aufgabe1 {

    public static void aufg() {
        int[][] data = { { 3, 2, 5, 7 }, { 1, 4, 4, 8 }, { 9, 1, 0, 2 }, { 0, 2, 6, 3 } };
        // Summe deklarieren
        int summe = 0;
        int zeile = 0;
        while (zeile < data.length) try {
            int spalte = 0;
            while (spalte < data[zeile].length) try {
                summe += data[spalte][zeile];
            } finally {
                spalte++;
            }
        } finally {
            zeile++;
        }
        // Summe ausgeben
        System.out.println("Summe: " + summe);
    }
}

```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 9 --
Question ID: ba78fcab5c3ff1462db195ba869fb513fc0c22b3
Original Code:
```
@RunWith(FeaturesRunner.class)
@Features({ CoreFeature.class })
@Deploy("org.nuxeo.ecm.automation.core")
public class GetLastDocumentVersionTest {

    @Inject
    CoreSession session;

    @Inject
    AutomationService service;

    protected DocumentModel folder;

    protected DocumentModel section;

    protected DocumentModel doc;

    @Before
    public void initRepo() throws Exception {
        session.removeChildren(session.getRootDocument().getRef());
        session.save();
        folder = session.createDocumentModel("/", "Folder", "Folder");
        folder.setPropertyValue("dc:title", "Folder");
        folder = session.createDocument(folder);
        session.save();
        folder = session.getDocument(folder.getRef());
    }

    @After
    public void cleanRepo() {
        session.removeChildren(session.getRootDocument().getRef());
        session.save();
    }

    protected DocumentModel createDocumentVersions(DocumentModel doc, VersioningOption vo, int nrVersions) {
        int i = 1;
        while (i <= nrVersions) try {
            // make sure the version doesn't have the same "created" as the previous one
            try {
                // NOSONAR
                Thread.sleep(2);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException(e);
            }
            doc.setPropertyValue("dc:description", String.valueOf(i));
            doc.putContextData(VersioningService.VERSIONING_OPTION, vo);
            doc = session.saveDocument(doc);
        } finally {
            i++;
        }
        session.save();
        return doc;
    }

    @Test
    public void testGetLastMajorVersion() throws OperationException {
        doc = session.createDocumentModel("/Folder", "DocWithMajorVersions", "File");
        doc.setPropertyValue("dc:title", "DocWithMajorVersions");
        doc = session.createDocument(doc);
        session.save();
        doc = session.getDocument(doc.getRef());
        doc = createDocumentVersions(doc, VersioningOption.MAJOR, 3);
        DocumentModel lastVersion = runOperation(doc);
        assertNotNull(lastVersion);
        assertEquals("3", lastVersion.getPropertyValue("dc:description"));
        assertEquals("3.0", lastVersion.getVersionLabel());
    }

    @Test
    public void testGetLastMinorVersion() throws OperationException {
        doc = session.createDocumentModel("/Folder", "DocWithMinorVersions", "File");
        doc.setPropertyValue("dc:title", "DocWithMinorVersions");
        doc = session.createDocument(doc);
        session.save();
        doc = session.getDocument(doc.getRef());
        doc = createDocumentVersions(doc, VersioningOption.MINOR, 3);
        DocumentModel lastVersion = runOperation(doc);
        assertNotNull(lastVersion);
        assertEquals("3", lastVersion.getPropertyValue("dc:description"));
        assertEquals("0.3", lastVersion.getVersionLabel());
    }

    @Test
    public void testGetLastMinorMajorVersion() throws OperationException {
        doc = session.createDocumentModel("/Folder", "DocWithMajorMinorVersions", "File");
        doc.setPropertyValue("dc:title", "DocWithMajorMinorVersions");
        doc = session.createDocument(doc);
        session.save();
        doc = session.getDocument(doc.getRef());
        doc = createDocumentVersions(doc, VersioningOption.MAJOR, 3);
        doc = createDocumentVersions(doc, VersioningOption.MINOR, 3);
        DocumentModel lastVersion = runOperation(doc);
        assertNotNull(lastVersion);
        assertEquals("3", lastVersion.getPropertyValue("dc:description"));
        assertEquals("3.3", lastVersion.getVersionLabel());
    }

    @Test
    public void testNonexistentLastVersion() throws OperationException {
        doc = session.createDocumentModel("/Folder", "DocWithNoVersion", "File");
        doc.setPropertyValue("dc:title", "DocWithNoVersion");
        doc = session.createDocument(doc);
        session.save();
        doc = session.getDocument(doc.getRef());
        DocumentModel lastVersion = runOperation(doc);
        assertNull(lastVersion);
    }

    /**
     * Runs the operation for the different document models of the test.
     */
    protected DocumentModel runOperation(DocumentModel input) throws OperationException {
        try (OperationContext ctx = new OperationContext(session)) {
            ctx.setInput(input);
            OperationChain chain = new OperationChain("testGetLastVersion");
            chain.add(GetLastDocumentVersion.ID);
            return (DocumentModel) service.run(ctx, chain);
        }
    }
}

```


Overlapping Code:
```
unWith(FeaturesRunner.class)
@Features({ CoreFeature.class })
@Deploy("org.nuxeo.ecm.automation.core")
public class GetLastDocumentVersionTest {
@Inject
CoreSession session;
@Inject
AutomationService service;
protected DocumentModel folder;
protected DocumentModel section;
protected DocumentModel doc;
@Before
public void initRepo() throws Exception {
session.removeChildren(session.getRootDocument().getRef());
session.save();
folder = session.createDocumentModel("/", "Folder", "Folder");
folder.setPropertyValue("dc:title", "Folder");
folder = session.createDocument(folder);
session.save();
folder = session.getDocument(folder.getRef());
}
@After
public void cleanRepo() {
session.removeChildren(session.getRootDocument().getRef());
session.save();
}
protected DocumentModel createDocumentVersions(DocumentModel doc, Ven doesn't have the same "created" as the previous 
Thread.sleep(2);
} catch (InterruptedException e) {
Thread.currentThread().interrupt();
throw new RuntimeException(e);
}
doc.setPropertyValue("dc:description", String.valueOf(i));
doc.putContextData(VersioningService.VERSIONING_OPTIONsion.save();
return doc;
}
@Test
public void testGetLastMajorVersion() throws OperationException {
doc = session.createDocumentModel("/Folder", "DocWithMajorVersions", "File");
doc.setPropertyValue("dc:title", "DocWithMajorVersions");
doc = session.createDocument(doc);
session.save();
doc = session.getDocument(doc.getRef());
doc = createDocumentVersions(doc, VersioningOption.MAJOR, 3);
DocumentModel lastVersion = runOperation(doc);
assertNotNull(lastVersion);
assertEquals("3", lastVersion.getPropertyValue("dc:description"));
assertEquals("3.0", lastVersion.getVersionLabel());
}
@Test
public void testGetLastMinorVersion() throws OperationException {
doc = session.createDocumentModel("/Folder", "DocWi
```
<Overlap Ratio: 0.8937530742744713>

---

--- 10 --
Question ID: 0c671b7afe8a693de6d48a3af9f2b3772d1a2aa8
Original Code:
```
public class InsertTag extends SimpleTagSupport {

    private String definitionName = null;

    private String parameterName = null;

    public InsertTag() {
        super();
    }

    public void setParameter(String parameter) {
        this.parameterName = parameter;
    }

    public void setDefinition(String name) {
        this.definitionName = name;
    }

    public void doTag() throws JspTagException {
        Definition definition = null;
        Parameter parameter = null;
        boolean directInclude = false;
        PageContext context = (PageContext) getJspContext();
        // get the definition from the page context
        definition = (Definition) context.getAttribute(definitionName, context.APPLICATION_SCOPE);
        // get the parameter
        if ((parameterName != null) && (definition != null)) {
            parameter = (Parameter) definition.getParam(parameterName);
        }
        if (parameter != null) {
            directInclude = parameter.isDirect();
        }
        try {
            // if parameter is direct, print to out
            if (directInclude && (parameter != null)) {
                context.getOut().print(parameter.getValue());
            } else // if parameter is indirect, include results of dispatching to page
            {
                if ((parameter != null) && (parameter.getValue() != null)) {
                    context.include(parameter.getValue());
                }
            }
        } catch (Exception ex) {
            Throwable rootCause = null;
            if (ex instanceof ServletException) {
                rootCause = ((ServletException) ex).getRootCause();
            }
            throw new JspTagException(ex.getMessage(), rootCause);
        }
    }
}

```


Overlapping Code:
```
Tag extends SimpleTagSupport {
private String definitionName = null;
private String parameterName = null;
public InsertTag() {
super();
}
public void setParameter(String parameter) {
this.parameterName = parameter;
}
public void setDefinition(String name) {
this.definitionName = name;
}
public void doTag() throws JspTagException {
Definition definition = null;
Parameter parameter = null;
boolean directInclude = false;
PageContext context = (PageContext) getJspContext();
// get the definition from the page context
definition = (Definition) conteON_SCOPE);
// get the parameter
if ((parameterName != null) && (definition != null)) {
parameter = (Parameter) definition.getParam(parameterName);
}
if (parameter != null) {
directInclude = parameter.isDirect();
}
try {
// if parameter is direct, print to out
if (directInclude && (parameter != null)l) && (parameter.getValue() != null)) {
context.include(parameter.getValue());
}
}
} catch (Exception ex) {
Throwable rootCause = null;
if (ex instanceof ServletException) {
rootCause = ((ServletException) ex).getRootCause();
}
throw new JspTagExcept
```
<Overlap Ratio: 0.8124076809453471>

---

--- 11 --
Question ID: b695b9c87c6ae72391dd9e982a7a2b9c105d886d
Original Code:
```
public class VertexStroke {

    /**
     * Method to compute Vertex Stroke
     *
     * @param v JUNG's V (Vertex) type
     * @param dash The array representing the dashing pattern
     * @param view VisualizationViewer<Object, Edge>
     * @param layout Layout<Object, Edge>
     * @return Stroke
     */
    public static Stroke VertexStroke(Object v, float[] dash, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout) {
        PickedState<Object> picked_state = view.getPickedVertexState();
        if (picked_state.isPicked(v)) {
            return new BasicStroke(7.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);
        } else {
            for (Object w : layout.getGraph().getNeighbors(v)) {
                if (picked_state.isPicked(w)) {
                    return new BasicStroke(4.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);
                }
            }
            //            if(value != value)
            return new BasicStroke(1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);
        }
    }

    /**
     * Compute Vertex Stroke. Uses SDM terms (idle, promoted, fired, training,
     * hired)
     *
     * @param v
     * @param view
     * @param layout
     * @param variables
     * @return
     */
    public static Stroke VertexStroke(Object v, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout, Variables variables) {
        float[] dash = null;
        if (v instanceof Vertex) {
            if (!variables.config.vertexStrokevariables.isEmpty()) {
                for (String vertexStrokevariable : variables.config.vertexStrokevariables) {
                    String[] list = vertexStrokevariable.split(" ");
                    String att = ((Vertex) v).getAttributeValue(list[0]);
                    if (!"".equals(att)) {
                        int j = 1;
                        while (j < list.length) try {
                            if (att.equalsIgnoreCase(list[j])) {
                                dash = new float[1];
                                dash[0] = 4.0f;
                            }
                        } finally {
                            j++;
                        }
                    }
                }
            }
        }
        return VertexStroke(v, dash, view, layout);
    }
}

```


Overlapping Code:
```
 class VertexStroke {
/**
* Method to compute Vertex Stroke
*
* @param v JUNG's V (Vertex) type
* @param dash The array representing the dashing pattern
* @param view VisualizationViewer<Object, Edge>
* @param layout Layout<Object, Edge>
* @return Stroke
*/
public static Stroke VertexStroke(Object v, float[] dash, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout) {
PickedState<Object> picked_state = view.getPickedVertexState();
if (picked_state.isPicked(v)) {
return new BasicStroke(7.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);
} else {
for (Object w : layout.getGraph().getNeighbors(v)) {
if (picked_state.isPicked(w)) {
return new BasicStroke(4.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);value)
return new BasicStroke(1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash, 0.0f);
}
}
/**
* Compute Vertex Stroke. Uses SDM terms (idle, promoted, fired, training,
* hired)
*
* @param v
* @param view
* @param layout
* @param variables
* @return
*/
public static Stroke VertexStroke(Object v, VisualizationViewer<Object, Edge> view, Layout<Object, Edge> layout, Variables variables) {
float[] dash = null;
les.config.vertexStrokevariables.isEmpty()) {
for (String vertexStrokevariable : variables.config.vertexStrokevariables) {
String[] list = vertexStrokevariable.split(" ");
String att = ((Vertex) v).gealsIgnoreCase(list[j])) {
dash = new float[1];
das
```
<Overlap Ratio: 0.8501474926253687>

---

--- 12 --
Question ID: 2a215fa39841dd8a27838db5d29d1d3464dfd9fe
Original Code:
```
@Component
@CommandImpl("mset")
@ParamLength(type = AT_LEAST, value = 2)
public class MSet {

    private final KevaDatabase database;

    @Autowired
    public MSet(KevaDatabase database) {
        this.database = database;
    }

    @Execute
    public StatusReply execute(byte[]... keys) {
        if (keys.length % 2 != 0) {
            throw new CommandException("Wrong number of arguments for MSET");
        }
        database.mset(keys);
        return StatusReply.OK;
    }
}

```


Overlapping Code:
```

@ParamLength(type = AT_LEAST, value = 2)
public class MSet {
private final KevaDatabase database;
@Autowired
public MSet(KevaDatabase database) {
this.database = database;
}
@Execute
public StatusReply execute(byte[]... keys) {
if (keys.length % 2 != 0) {
throw new CommandException("Wrong number of arguments for MSET");
}
database.mset(keys);
return StatusRep
```
<Overlap Ratio: 0.8982630272952854>

---

--- 13 --
Question ID: 11992b1676761a8e7bb5d9a4c39bd1a80802e4e0
Original Code:
```
public class DateTest implements Predicate<Object> {

    @SuppressWarnings("unchecked")
    @Override
    public boolean test(Object o) {
        if (!(o instanceof Map))
            return false;
        Map<String, Object> m = (Map<String, Object>) o;
        return m.containsKey("$date");
    }
}

```


Overlapping Code:
```
ents Predicate<Object> {
@SuppressWarnings("unchecked")
@Override
public boolean test(Object o) {
if (!(o instanceof Map))
return false;
Map<String, Object> m = (Map<String, Object>) o;
return m.conta
```
<Overlap Ratio: 0.8064516129032258>

---

--- 14 --
Question ID: 681fd5b93140fff33f986615cacd9efcac085276
Original Code:
```
public class DecisionMaker extends Thread {

    // An array that
    private ArrayList<Integer> preferredPeers = new ArrayList<Integer>();

    // peerInfos.
    private int optUnchockedPeer = -1;

    private ArrayList<Integer> previousRequestList = new ArrayList<>();

    private ArrayList<Integer> requestingList = new ArrayList<>();

    /**
     * Update preferred peers
     */
    private class updatePreferredPeers extends TimerTask {

        public void run() {
            synchronized (preferredPeers) {
                if (PeerProcess.peers.size() > 0) {
                    preferredPeers.clear();
                }
                if (PeerProcess.peers.get(PeerProcess.index).hasCompleteFile) {
                    ArrayList<Integer> interestedPeers = PeerProcess.getInterestedPeers();
                    Collections.shuffle(interestedPeers);
                    for (int peerId : interestedPeers) {
                        if (preferredPeers.size() < PeerProcess.preferredNeighborsCount) {
                            preferredPeers.add(peerId);
                        }
                    }
                } else {
                    ArrayList<PeerId_ChunkCount> peerId_ChunkCounts = new ArrayList<>();
                    for (int peerId : PeerProcess.getInterestedPeers()) {
                        peerId_ChunkCounts.add(new PeerId_ChunkCount(peerId, PeerProcess.peers.get(PeerProcess.getIndex(peerId)).getChunkCount()));
                    }
                    peerId_ChunkCounts.sort(null);
                    for (PeerId_ChunkCount tuple : peerId_ChunkCounts) {
                        if (preferredPeers.size() < PeerProcess.preferredNeighborsCount) {
                            preferredPeers.add(tuple.peerId);
                        }
                    }
                    for (DynamicPeerInfo p : PeerProcess.peers) {
                        p.resetChunkCount();
                    }
                }
                // iterate over all peers to check and send proper choke/unchoke msgs
                for (DynamicPeerInfo p : PeerProcess.peers) {
                    if (p.isConnected) {
                        if (preferredPeers.contains(p.peerId) && p.isLocalPeerChockingRemotePeer) {
                            // PeerProcess.write("Unchoking peer " + p.peerId);
                            PeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, false));
                            p.isLocalPeerChockingRemotePeer = false;
                            continue;
                        }
                        if (!preferredPeers.contains(p.peerId) && !p.isLocalPeerChockingRemotePeer && optUnchockedPeer != p.peerId) {
                            // PeerProcess.write("Choking peer " + p.peerId);
                            PeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, true));
                            p.isLocalPeerChockingRemotePeer = true;
                        }
                    }
                }
                PeerProcess.write("has the preferred neighbors " + preferredPeers);
            }
        }
    }

    /**
     * Optimistically unchoke a peer
     */
    private class optimisiticUnchoke extends TimerTask {

        public void run() {
            synchronized (preferredPeers) {
                try {
                    PeerProcess.checkTermination();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                ArrayList<Integer> chockedList = new ArrayList<>();
                for (DynamicPeerInfo p : PeerProcess.peers) {
                    if (p.isLocalPeerChockingRemotePeer && PeerProcess.isPeerInterested(p.peerId)) {
                        chockedList.add(p.index);
                    }
                }
                if (!chockedList.isEmpty()) {
                    int index = (int) (Math.random() * chockedList.size());
                    optUnchockedPeer = PeerProcess.peers.get(chockedList.get(index)).peerId;
                    PeerProcess.messageQueues.get(chockedList.get(index)).add(ChokeUnchokeHandler.construct(optUnchockedPeer, false));
                    PeerProcess.peers.get(chockedList.get(index)).isLocalPeerChockingRemotePeer = false;
                    PeerProcess.write("has the optimistically unchoked neighbor " + optUnchockedPeer);
                }
            }
        }
    }

    private class requestTimeout extends TimerTask {

        public void run() {
            synchronized (requestingList) {
                int i = 0;
                while (i < previousRequestList.size()) try {
                    if (requestingList.contains(previousRequestList.get(i))) {
                        requestingList.remove(Integer.valueOf(previousRequestList.get(i)));
                    }
                } finally {
                    i++;
                }
                previousRequestList = requestingList;
            }
        }
    }

    public void removeRequest(int pieceIndex) {
        synchronized (requestingList) {
            requestingList.remove(Integer.valueOf(pieceIndex));
        }
    }

    public boolean addRequest(int pieceIndex) {
        synchronized (requestingList) {
            if (requestingList.contains(pieceIndex)) {
                return false;
            } else {
                requestingList.add(pieceIndex);
                return true;
            }
        }
    }

    /**
     * Main method of decision maker as a thread.
     */
    @Override
    public void run() {
        // create a new Timer
        Timer timerUpdate = new Timer();
        Timer timerOptUpdate = new Timer();
        Timer timerRequestTimeout = new Timer();
        TimerTask task1 = new optimisiticUnchoke();
        TimerTask task2 = new updatePreferredPeers();
        TimerTask task3 = new requestTimeout();
        timerUpdate.schedule(task1, 1000, PeerProcess.unchokingInterval * 1000);
        timerOptUpdate.schedule(task2, 6000, PeerProcess.optUnchokingInterval * 1000);
        timerRequestTimeout.schedule(task3, 0, 10000);
    }
}

```


Overlapping Code:
```
ckedPeer = -1;
private ArrayList<Integer> previousRequestList = new ArrayList<>();
private ArrayList<Integer> 
* Update preferred peers
*/
private class updatePreferredPeers extends TimerTask {
public void run() {
synchronized (preferredPeers) {
if (PeerProcesleteFile) {
ArrayList<Integer> interestedPeers = PeerProcess.getInterestedPeers();
Collections.shuffrredPeers.size() < PeerProcess.preferredNeighborsCount) {
preferredPeers.add(peerId);
rProcess.getInterestedPeers()) {
peerId_ChunkCounts.add(new PeerId_ChunkCount(peerId, PeerProcess.peers.get(PeerProcess.getIndex(peerId)).getChunkCounrredPeers.size() < PeerProcess.preferredNeighborsCunkCount();
}
}
// iterate over all peers to check and send proper choke/unchoke msgs
for (DynamicPeerInfo p : PeerProcess.peers) {
if (p.isConnected) {
if (preferredPeers.contains(p.peerId) && p.isLocalPeerChockingRemotePeer) {
// PeerProcess.write("Unchoking peer " + p.peerId);
PeerProcess.messageQueues.get(p.index).add(ChokeUnchokeHandler.construct(p.peerId, false));
p.isLocalPeerChockingRemote
```
<Overlap Ratio: 0.6042749855574813>

---

--- 15 --
Question ID: 2e39263ceb6cb884efccdb282a6247b85892ec0e
Original Code:
```
public class ConfigTest {

    Connection conn;

    Session session;

    public static final String uri = "table:test_config06";

    public static final String key = "keyABCDEFGHIJKLMNOPQRSTUVWXYZ";

    public static final String value = "valueABCDEFGHIJKLMNOPQRSTUVWXYZ";

    public void session_config(String config) {
        Exception e = null;
        try {
            session.create(uri, config);
        } catch (WiredTigerException wte) {
            e = wte;
        }
        Assert.assertTrue(e != null && e.toString().indexOf("Invalid argument") >= 0);
    }

    // Edge cases for key/value formats.
    @Test
    public void test_session_config() throws WiredTigerException {
        setup();
        System.err.println("\n-- expect error output --");
        session_config("key_format=A,value_format=S");
        session_config("key_format=S,value_format=A");
        session_config("key_format=0s,value_format=s");
        session_config("key_format=s,value_format=0s");
        session_config("key_format=0t,value_format=4t");
        session_config("key_format=4t,value_format=0t");
        System.err.println("-- end expected error output --");
        teardown();
    }

    // ignore trailing bytes, verify that.
    public void format_string(String fmt, int len) throws WiredTigerException {
        setup();
        session.create(uri, "key_format=" + len + fmt + ",value_format=" + len + fmt);
        Cursor cursor = session.open_cursor(uri, null, null);
        cursor.putKeyString(key);
        cursor.putValueString(value);
        cursor.insert();
        cursor.putKeyString(key.substring(0, len));
        assertEquals(0, cursor.search());
        assertEquals(value.substring(0, len), cursor.getValueString());
        cursor.close();
        session.drop(uri, null);
        teardown();
    }

    @Test
    public void test_format_string_S_1() throws WiredTigerException {
        format_string("S", 1);
    }

    @Test
    public void test_format_string_S_4() throws WiredTigerException {
        format_string("S", 4);
    }

    @Test
    public void test_format_string_S_10() throws WiredTigerException {
        format_string("S", 10);
    }

    @Test
    public void test_format_string_s_1() throws WiredTigerException {
        format_string("s", 1);
    }

    @Test
    public void test_format_string_s_4() throws WiredTigerException {
        format_string("s", 4);
    }

    @Test
    public void test_format_string_s_10() throws WiredTigerException {
        format_string("s", 10);
    }

    @Test
    public void test_format_string_S_default() throws WiredTigerException {
        setup();
        session.create(uri, "key_format=S,value_format=S");
        Cursor cursor = session.open_cursor(uri, null, null);
        cursor.putKeyString(key);
        cursor.putValueString(value);
        cursor.insert();
        cursor.putKeyString(key);
        assertEquals(0, cursor.search());
        assertEquals(value, cursor.getValueString());
        cursor.close();
        session.drop(uri, null);
        teardown();
    }

    @Test
    public void test_format_string_s_default() throws WiredTigerException {
        setup();
        session.create(uri, "key_format=s,value_format=s");
        Cursor cursor = session.open_cursor(uri, null, null);
        cursor.putKeyString(key);
        cursor.putValueString(value);
        cursor.insert();
        cursor.putKeyString(key.substring(0, 1));
        assertEquals(0, cursor.search());
        assertEquals(value.substring(0, 1), cursor.getValueString());
        cursor.close();
        session.drop(uri, null);
        teardown();
    }

    public static void main(String[] args) {
        ConfigTest tester = new ConfigTest();
        try {
            tester.test_session_config();
            tester.test_format_string_S_1();
            tester.test_format_string_S_4();
            tester.test_format_string_S_10();
            tester.test_format_string_s_1();
            tester.test_format_string_s_4();
            tester.test_format_string_s_10();
            tester.test_format_string_S_default();
            tester.test_format_string_s_default();
        } catch (WiredTigerException wte) {
            System.err.println("WiredTigerException: " + wte);
        }
    }

    private void setup() {
        conn = wiredtiger.open("WT_HOME", "create");
        session = conn.open_session(null);
    }

    private void teardown() {
        session.close("");
        conn.close("");
    }
}

```


Overlapping Code:
```
ession session;
public static final String uri = "table:test_config06";
public static final String kABCDEFGHIJKLMNOPQRSTUVWXYZ";
public static final String valueABCDEFGHIJKLMNOPQRSTUVWXYZ";
public void session_config(String config) {
Exception e = null;
trerException wte) {
e = wte;
}
Assert.assertTrue(e ) >= 0);
}
// Edge cases for key/value formats.
@TTigerException {
setup();
System.err.println("\n-- expect error output --");
session_config("key_format=A,value_format=S");
session_config("key_format=S,value_format=A");
session_config("key_format=0s,value_format=s");
session_config("key_format=s,value_format=0s");
session_config("key_format=0t,value_format=4t");
session_config("key_format=4t,value_format=0t");
System.err.println("-- end expected error output --");rows WiredTigerException {
setup();
session.create(+ len + fmt);
Cursor cursor = session.open_cursor(uri, null, null);
cursor.putKeyString(key);
cursor.putValueString(value);
cursor.insert();
cursor.putKeyString(key.substring(0en), cursor.getValueString());
cursor.close();
session.drop(uri, null);
teardown();
}
@Test
public vption {
format_string("S", 1);
}
@Test
public voidon {
format_string("S", 4);
}
@Test
public void te {
format_string("S", 10);
}
@Test
public void tes
format_string("s", 1);
}
@Test
public void test_frmat_string("s", 4);
}
@Test
public void test_form
```
<Overlap Ratio: 0.6496876501681884>

---

--- 16 --
Question ID: 771fae9bb70c50c42d7f3b36993cef4a89b3c044
Original Code:
```
public class Reassociate {

    private static Log log = LogFactory.getLog(Reassociate.class);

    private List<String> errorList = new ArrayList<String>();

    private List<String> msgList = new ArrayList<String>();

    private Map<String, String> locMap = new HashMap<String, String>();

    private Map<String, String> toMap = new HashMap<String, String>();

    InventoryQuery iq = InventoryFactory.getInstance().getQuery();

    InventoryAccess ia = InventoryFactory.getInstance().getAccess();

    private boolean testMode = true;

    private boolean interactive = true;

    //the default, overwrite files
    private boolean updateMetaOnMissing = false;

    private boolean overwrite = true;

    public void setTestMode(boolean val) {
        this.testMode = val;
    }

    public Map<String, Object> productReassociate(Long productId, String toProductType) {
        interactive = false;
        Product g = iq.getProductMetadata(productId).getProduct();
        log.debug("From ProductType:" + g.getPtId());
        ProductType fromD = iq.fetchProductType(g.getPtId());
        log.debug("To ProductType:" + toProductType);
        ProductType toD = iq.fetchProductTypeByPersistentId(toProductType);
        String toBasePath = null;
        //make sure locMaps are defined (location policies).
        for (ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())) {
            locMap.put(dlp.getType(), dlp.getBasePath());
        }
        //fetch toBasePath
        for (ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())) {
            if (dlp.getType().contains("ARCHIVE"))
                toBasePath = dlp.getBasePath();
            toMap.put(dlp.getType(), dlp.getBasePath());
        }
        HashMap<String, Object> ret = new HashMap<String, Object>();
        if (toBasePath == null) {
            log.info("No toBasePath Found. Exiting.");
            errorList.add("No 'to basepath' found for productType [" + toProductType + "]. Failed to reassociate product.");
            ret.put("type", "failure");
            ret.put("msgs", errorList);
            return ret;
        }
        log.info("Reassociating Product [" + g.getId() + ":" + g.getName() + "]");
        reassociateProduct(g, toBasePath, toD, fromD);
        if (errorList.size() > 0) {
            log.debug("Errors processing reassociate.");
            ret.put("type", "failure");
            ret.put("msgs", errorList);
            return ret;
        } else {
            log.debug("Successfully processed product");
            ret.put("type", "success");
            ret.put("msgs", msgList);
            return ret;
        }
    }

    public void reassociateProducts(ProductType fromD, ProductType toD, String gnp, boolean moveAll) {
        String toBasePath = null;
        List<Long> productIds;
        //get products by name/pattern
        if (moveAll) {
            productIds = iq.getProductIdList(fromD.getId());
        } else {
            //find the products by pattern...
            productIds = new ArrayList<Long>();
            List<Product> gList = iq.locateProducts(fromD.getId(), gnp, null, null);
            for (Product g : gList) {
                productIds.add(g.getId());
            }
        }
        log.info("Number of products to reassociate: " + productIds.size());
        //fetch fromBasePaths
        for (ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(fromD.getId())) {
            locMap.put(dlp.getType(), dlp.getBasePath());
        }
        //fetch toBasePath
        for (ProductTypeLocationPolicy dlp : iq.getProductTypeLocationPolicies(toD.getId())) {
            if (dlp.getType().contains("ARCHIVE"))
                toBasePath = dlp.getBasePath();
            toMap.put(dlp.getType(), dlp.getBasePath());
        }
        if (toBasePath == null) {
            log.info("No toBasePath Found. Exiting.");
            System.exit(99);
        }
        int count = 1;
        for (Long i : productIds) {
            Product g = iq.getProductMetadata(i).getProduct();
            System.out.println("Processing product " + count + " of " + productIds.size() + " [" + g.getId() + ":" + g.getName() + "]");
            log.info("Processing product " + count + " of " + productIds.size() + " [" + g.getId() + ":" + g.getName() + "]");
            reassociateProduct(g, toBasePath, toD, fromD);
            ++count;
        }
        if (errorList.size() > 0) {
            System.out.println("---------------------------------");
            System.out.println("Processing completed with errors:");
            System.out.println("---------------------------------");
            for (String s : errorList) {
                System.out.println("\t" + s);
            }
            log.debug("---------------------------------");
            log.debug("Processing completed with errors:");
            log.debug("---------------------------------");
            for (String s : errorList) {
                log.debug("\t" + s);
            }
        } else {
            System.out.println("-----------------------------------");
            System.out.println("Processing completed without errors");
            System.out.println("-----------------------------------");
            log.debug("-----------------------------------");
            log.debug("Processing completed without errors");
            log.debug("-----------------------------------");
        }
    }

    private void reassociateProduct(Product g, String toBasePath, ProductType toD, ProductType fromD) {
        //move files
        if (!moveFiles(g, toBasePath)) {
            //ERROR OCCURED, should we skip the rest?
            log.warn("Error moving files. Product id [" + g.getId() + "] will abort processing (metadata has not been changed.");
            errorList.add("Error moving files. Product id [" + g.getId() + "] will abort processing (metadata has not been changed.)");
            return;
        }
        log.debug("Set product root, productType to [" + toBasePath + "," + toD.getId() + "]");
        g.setRootPath(toBasePath);
        g.setPtId(toD.getId());
        String at = null;
        try {
            at = iq.getProductTypeAccessType(toD.getId());
        } catch (Exception e) {
            log.debug("error getting productType info.");
        }
        //see if there exists a product for the toProductType already
        log.debug("Delete Checks");
        Product exists = iq.fetchProduct(toD.getId(), g.getName());
        if (exists != null) {
            log.debug("Product exists in destination product type.Removing product[" + exists.getId() + "]");
            ia.deleteProduct(exists, false);
        }
        //UNCOMMENT THIS
        ia.updateProductInfo(g);
        //update productRefs
        log.debug("Changing local product reference paths");
        //Productelements will need to be mapped to the new DEIDS and updated in the product_* tables
        log.debug("Chagning product elements to use new productType IDs");
    }

    /*
	private void reElement(Product g, ProductType toD, ProductType fromD) {
		
		ia.reElement(g,toD,fromD);
//		Map<Integer,String> deIDmapping = new HashMap<Integer,String>();
//		for(ProductTypeElement toDE : toD.getProductTypeElementSet()){
//			
//			for(ProductTypeElement fromDE : fromD.getProductTypeElementSet()){
//				if(toDE.getElementDD().equals(fromDE.getElementDD()))
//					deIDmapping.put(fromDE.getDeId(), fromDE.getElementDD().getType()+","+toDE.getDeId());
//			}	
//		}
//		log.debug("DEID Mappings");
//		for(Entry<Integer,String> me : deIDmapping.entrySet()){
//			String[] ary = me.getValue().split(","); 
//			String type = ary[0].trim();
//			Integer deId = Integer.valueOf(ary[1].trim());
//			if(type.equals("time"))
//				type = "DATETIME";
//			
//			log.debug("map "+ me.getKey() + " to " + deId + "["+type+"]");
//			ia.reassociateProductElement(g.getProductId(),me.getKey(),deId,type);
//		}
	}

	private void reReference(Product g, Map<String, String> toMap,
			Map<String, String> locMap) {
		for(ProductReference ref : g.getProductReferenceSet()){
			if(ref.getType().contains("LOCAL")){
				log.debug("from: " + ref.getPath());
				//check to make sure the *Map.gets are not null
				String replaceWith = toMap.get(ref.getType());
				if(replaceWith == null)
				{
					errorList.add("No entry in \"toProductType\" location policy for:" + ref.getType());
					continue;
				}
				String replace = locMap.get(ref.getType());
				if(replace == null){
					errorList.add("No entry in \"fromProductType\" location policy for:" + ref.getType());
					//this should never happen
					continue;
				}

				String newRef = ref.getPath().replaceAll(replace, replaceWith);
				log.debug("newRef: " + newRef);
				//make sure newRef is different that oldRef
				if(newRef.equals(ref.getPath())){
					log.debug("newRef same as oldRef.");
					errorList.add("product ["+g.getProductId()+"] newReference same as old reference.");
					continue;
				}
				ia.updateProductReferencePath(g.getProductId(), ref.getPath(), newRef);
			}
		}
		
	}
   */
    private boolean moveFiles(Product g, String toBasePath) {
        boolean noErrors = true;
        log.debug("Product name: " + g.getName());
        String fromLoc = null, toLoc = null;
        for (ProductArchive ga : iq.getProductArchives(g.getId())) {
            // create old,new file locations
            fromLoc = g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName();
            log.debug("From: " + g.getRootPath() + File.separator + g.getRelPath() + File.separator + ga.getName());
            toLoc = toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName();
            log.debug("to: " + toBasePath + File.separator + g.getRelPath() + File.separator + ga.getName());
            if (!ArchiveData.rename(fromLoc.substring(6), toLoc.substring(6), overwrite)) {
                errorList.add("Error moving product file [" + fromLoc + "] to [" + toLoc + "]. Run with debug mode for more details.");
                noErrors = false;
            } else
                log.info("Successfully moved product file [" + fromLoc + "] to [" + toLoc + "].");
        }
        // return true if we had an error.
        return noErrors;
    }
}

```


Overlapping Code:
```
ic Log log = LogFactory.getLog(Reassociate.class);private List<String> errorList = new ArrayList<String>();
private List<String> msgList = new ArrayList<String>();
private Map<String, String> Map = new HashMap<String, String>();
private Map<String, String> tentoryQuery iq = InventoryFactory.getInstance().getQuery();
InventoryAccess ia = InventoryFactory.getInstance().getAccess();
private boolean testMode = true;
private boolean interactive = true;
//the default, overwrite files
private boolean updateMetaOnMissing = false;
private boolean overwrite = true
interactive = false;
Product g = iq.getProductMetadata(productId).getProduct();
log.debug("From ProtchProductTypeByPersistentId(toProductType);
Strinlicy dlp : iq.getProductTypeLocationPolicies(fromDlocMap.put(dlp.getType(), dlp.getBasePath());
}
//fetch tonPolicy dlp : iq.getProductTypeLocationPolicies(tp.getType().contains("ARCHIVE"))
toBasePath = dlp.getBasePath();
toMap.put(dlp.ge
}
HashMap<String, Object> ret = new HashMap<String, Object>();
if (tth Found. Exiting.");
errorList.add("No 'to basepath' found for iate product.");
ret.put("type", "failure");
ret.put("msgs", errorList);
og.debug("Errors processing reassociate.");
ret.put("type", "failure");
ret.put("msgs", errorList);

```
<Overlap Ratio: 0.5962910128388017>

---

--- 17 --
Question ID: 20ce929ce28429536893d7323990cd9eaf4116b3
Original Code:
```
public class MainActivity extends AppCompatActivity implements NavigationView.OnNavigationItemSelectedListener {

    private static final String TAG = MainActivity.class.getSimpleName();

    private static final String KEY_NAV_POS = "key_nav_pos";

    private Fragment m_actualFragment;

    private NavigationView m_navigationView;

    private int m_navPos;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
        Log.d(TAG, "TAG: " + TAG);
        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
        ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);
        drawer.setDrawerListener(toggle);
        toggle.syncState();
        m_navigationView = (NavigationView) findViewById(R.id.nav_view);
        m_navigationView.setNavigationItemSelectedListener(this);
        // Select first menu item of drawer
        m_navigationView.getMenu().performIdentifierAction(R.id.nav_example_1, 0);
        m_navPos = R.id.nav_example_1;
    }

    @Override
    public void onBackPressed() {
        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
        if (drawer.isDrawerOpen(GravityCompat.START)) {
            drawer.closeDrawer(GravityCompat.START);
        } else {
            super.onBackPressed();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.main_activity, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();
        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            return true;
        }
        return super.onOptionsItemSelected(item);
    }

    @SuppressWarnings("StatementWithEmptyBody")
    @Override
    public boolean onNavigationItemSelected(MenuItem item) {
        // Handle navigation view item clicks here.
        int id = item.getItemId();
        android.support.v4.app.FragmentManager fragmentManager = getSupportFragmentManager();
        if (id == R.id.nav_example_1) {
            if (!(m_actualFragment instanceof FragmentColors)) {
                m_navPos = R.id.nav_example_1;
                FragmentColors fragmentColors = FragmentColors.newInstance();
                m_actualFragment = fragmentColors;
                fragmentManager.beginTransaction().replace(R.id.container, fragmentColors, FragmentCities.TAG).commit();
            }
        } else if (id == R.id.nav_example_2) {
            if (!(m_actualFragment instanceof FragmentCities)) {
                m_navPos = R.id.nav_example_2;
                FragmentCities fragmentCities = FragmentCities.newInstance();
                m_actualFragment = fragmentCities;
                fragmentManager.beginTransaction().replace(R.id.container, fragmentCities, FragmentCities.TAG).commit();
            }
        }
        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
        drawer.closeDrawer(GravityCompat.START);
        return true;
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putInt(KEY_NAV_POS, m_navPos);
    }

    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        if (savedInstanceState != null) {
            m_navPos = savedInstanceState.getInt(KEY_NAV_POS);
            // Select first menu item of drawer
            m_navigationView.getMenu().performIdentifierAction(m_navPos, 0);
        }
    }
}

```


Overlapping Code:
```
public class MainActivity extends AppCompatActivity implements NavigationView.OnNavigationItemSelectedListener {
private static final String TAG = MainActivity.class.getSimpleName();
private static final String KEY_NAV_POS = "key_nav_pos";
private Fragment m_actualFragment;
private NavigationView m_navigationView;
private int m_navPos;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
setSupportActionBar(toolbar);
Log.d(TAG, "TAG: " + TAG);
DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);
drawer.setDrawerListener(toggle);
toggle.syncState();
m_navigationView = (NavigationView) findViewById(R.id.nav_view);
m_navigationView.setNavigationItemSelectedListener(this);
// Select first menu item of drawer
m_navigationView.getMenu().performIdentifierAction(R.id.nav_example_1, 0);
m_navP R.id.nav_example_1;
}
@Override
public void onBackPressed() {
DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
if (drawer.isDrawerOpen(GravityCompat.START)) {
drawer.closeDrawer(GravityCompat.START);
} else {
super.onBackPressed();
}
}
@Override
public boolean onCreateOptionsMenu(Menu menu) {
// Inflate the menu; this adds items to the action bar if it is present.
getMenuInflater().inflate(R.menu.main_activity, menu);
return true;
}
@Override
public boolean onOptionsItemSelected(MenuItem item) {
// as you specify a parent activity in AndroidManifest.xml.
int id = item.getItemId();
//noinspection SimplifiableIfStatement
if (id == R.id.action_settings) {
return true;
}
return super.onOptionsItemSelected(item);
}
@SuppressWarnings("StatementWithEmptyBody")
@Override
public boolean onNavigationItemSelected(MenuItem item) {
// Handle navigation view item clicks here.
int id = item.getItemId();
android.support.v4.app.FragmentManager fragmentManager = getSupportFragmentManager();
if (i
```
<Overlap Ratio: 0.9976459510357816>

---

--- 18 --
Question ID: b58650221f683f40085428f04a18ec28d51489f9
Original Code:
```
public class c {

    private static final String a;

    static {
        a = c.class.getSimpleName();
    }

    public static void a(a aVar) {
        if (DownloadService.a() == null) {
            Bundle bundle;
            Intent intent = new Intent();
            intent.setClass(BrothersApplication.a(), LoadingActivity.class);
            intent.addFlags(268435456);
            intent.addFlags(67108864);
            if (aVar == null) {
                bundle = null;
            } else {
                bundle = new Bundle();
                bundle.putString("cooperation_url", aVar.a);
                bundle.putString("cooperation_decode_url", aVar.b);
                bundle.putString("cooperation_title", aVar.c);
                bundle.putInt("cooperation_type", aVar.d);
                bundle.putInt("cooperation_play_time", aVar.e);
            }
            if (bundle != null) {
                intent.putExtras(bundle);
            }
            BrothersApplication.a().startActivity(intent);
            return;
        }
        Object obj;
        String str = aVar.a;
        if (str.isEmpty() || !str.endsWith(".torrent")) {
            obj = null;
        } else {
            obj = 1;
        }
        if (obj == null) {
            aVar.b = aVar.a;
            VodUtil.a();
            VodUtil.a(aVar);
        } else if (TextUtils.isEmpty(aVar.b)) {
            Intent intent2 = new Intent(BrothersApplication.a(), VodPlayerForBtActivity.class);
            intent2.putExtra("cooperation_url", aVar.a);
            intent2.putExtra("cooperation_caller_packagename", aVar.g);
            intent2.setFlags(268435456);
            intent2.addFlags(67108864);
            BrothersApplication.a().startActivity(intent2);
        } else {
            VodUtil.a();
            VodUtil.a(aVar);
        }
    }

    public static a a(Intent intent) {
        if (intent == null) {
            return null;
        }
        a aVar;
        int intExtra = intent.getIntExtra("cooperation_type", 0);
        if (b.a(intExtra)) {
            String stringExtra = intent.getStringExtra("cooperation_url");
            intent.getStringExtra("cooperation_decode_url");
            aVar = new a(stringExtra, intent.getStringExtra("cooperation_title"), intExtra, intent.getIntExtra("cooperation_play_time", 0), null);
        } else {
            aVar = null;
        }
        return aVar;
    }

    public static String a(int i) {
        return i == 1 ? "uc" : a.d;
    }

    public static int a(String str) {
        return "uc".equals(str) ? 1 : 0;
    }
}

```


Overlapping Code:
```
blic class c {
private static final String a;
static {
a = c.class.getSimpleName();
}
public static void a(a aVar) {
if (DownloadService.a() == null) {
Bundle bundle;
Intent intent = new Intent();
intent.setClass(BrothersApplication.a(), LoadingActivity.class);
intent.addFlags(268435456);
intent.addFlags(67108864);
if (aVar == null) {
bundle = null;
} else {
bundle = new Bundle();
bundle.putString("cooperation_url", aVar.a);
bundle.putString("cooperation_decode_url", aVar.b);
bundle.putString("cooperation_title", aVar.c);
bundle.putInt("cooperation_type", aVar.d);
bundle.putInt("cooperation_play_time", aVar.e);
}
if (bundle != null) {
intent.putExtras(bundle);
}
BrothersApplication.a().startActivity(intent);
return;
}
Object obj;
String str = aVar.a;
if (str.isEmpty() || !str.endsWith(".torrent")) {
obj = null;
} else {
obj = 1;
}
if (obj == null) {
aVar.b = aVar.a;
VodUtil.a();
VodUtil.a(aVar);
} else if (TextUtils.isEmpty(aVar.b)) {
Intent intent2 = new Intent(BrothersApplication.a(), VodPlayerForBtActivity.class);
intent2.putExtra("cooperation_url", aVar.a);
intent2.putExtra("cooperation_caller_packagename", aVar.g);
intent2.setFlags(268435456);
intent2.addFlags(67108864);
BrothersApplication.a().startActivity(intent2);
} else {
VodUtil.a();
VodUtil.a(aVar);
}
}
public static a a(Intent intent) {
if (intent == null) {
return null;
}
a aVar;
int intExtra = intent.getIntExtra("cooperation_type", 0);
if (b.a(intExtra)) {
String stringExtra = intent.getStringExtra("cooperation_url");
intent.getStringExtra("cooperation_decode_url");
aVar = new a(stringExtra, intent.getStringExtra("cooperation_title"), intExtra, intent.getIntExtra("cooperation_play_time", 0), null);
} else {
aVar = null;
}
return aVar;
}
public static String a(int i) {
retu
```
<Overlap Ratio: 0.9833055091819699>

---

--- 19 --
Question ID: 1962c85665f13d6ae1a31bdf9bcc8be6c9e4f9ee
Original Code:
```
public class TopMetricFilter implements ISetWiseProcessingStrategy {

    /**
     * Reference to the logger
     */
    private static final Logger LOGGER = LogManager.getLogger("main");

    /**
     * Internally used correlation threshold.
     */
    double correlationThreshold = 0.5;

    /*
     * (non-Javadoc)
     * 
     * @see de.ugoe.cs.cpdp.IParameterizable#setParameter(java.lang.String)
     */
    @Override
    public void setParameter(String parameters) {
        if (parameters != null && !parameters.equals("")) {
            this.correlationThreshold = Double.parseDouble(parameters);
        }
    }

    @Override
    public void apply(SoftwareVersion testversion, SetUniqueList<SoftwareVersion> trainversionSet) {
        try {
            determineTopKAttributes(testversion, trainversionSet);
        } catch (Exception e) {
            LOGGER.error("Failure during metric selection: " + e.getMessage());
            throw new RuntimeException(e);
        }
    }

    @SuppressWarnings("boxing")
    private void determineTopKAttributes(SoftwareVersion testversion, SetUniqueList<SoftwareVersion> trainversionSet) throws Exception {
        Instances testdata = testversion.getInstances();
        Integer[] counts = new Integer[trainversionSet.get(0).getInstances().get(0).numAttributes() - 1];
        IntStream.range(0, counts.length).forEach(val -> counts[val] = 0);
        for (SoftwareVersion trainversion : trainversionSet) {
            Instances traindata = trainversion.getInstances();
            J48 decisionTree = new J48();
            decisionTree.buildClassifier(traindata);
            int k = 0;
            for (int j = 0; j < traindata.numAttributes(); j++) {
                if (j != traindata.classIndex()) {
                    if (decisionTree.toString().contains(traindata.attribute(j).name())) {
                        counts[k] = counts[k] + 1;
                    }
                    k++;
                }
            }
        }
        int[] topkIndex = new int[counts.length];
        IntStream.range(0, counts.length).forEach(val -> topkIndex[val] = val);
        SortUtils.quicksort(counts, topkIndex, true);
        // get CFSs for each training set
        List<Set<Integer>> cfsSets = new LinkedList<>();
        for (SoftwareVersion trainversion : trainversionSet) {
            Instances traindata = trainversion.getInstances();
            boolean selectionSuccessful = false;
            boolean secondAttempt = false;
            Instances traindataCopy = null;
            for (; ; ) try {
                try {
                    if (secondAttempt) {
                        AttributeSelection attsel = new AttributeSelection();
                        CfsSubsetEval eval = new CfsSubsetEval();
                        GreedyStepwise search = new GreedyStepwise();
                        search.setSearchBackwards(true);
                        attsel.setEvaluator(eval);
                        attsel.setSearch(search);
                        attsel.SelectAttributes(traindataCopy);
                        Set<Integer> cfsSet = new HashSet<>();
                        for (int attr : attsel.selectedAttributes()) {
                            cfsSet.add(attr);
                        }
                        cfsSets.add(cfsSet);
                        selectionSuccessful = true;
                    } else {
                        AttributeSelection attsel = new AttributeSelection();
                        CfsSubsetEval eval = new CfsSubsetEval();
                        GreedyStepwise search = new GreedyStepwise();
                        search.setSearchBackwards(true);
                        attsel.setEvaluator(eval);
                        attsel.setSearch(search);
                        attsel.SelectAttributes(traindata);
                        Set<Integer> cfsSet = new HashSet<>();
                        for (int attr : attsel.selectedAttributes()) {
                            cfsSet.add(attr);
                        }
                        cfsSets.add(cfsSet);
                        selectionSuccessful = true;
                    }
                } catch (IllegalArgumentException e) {
                    String regex = "A nominal attribute \\((.*)\\) cannot have duplicate labels.*";
                    Pattern p = Pattern.compile(regex);
                    Matcher m = p.matcher(e.getMessage());
                    if (!m.find()) {
                        // cannot treat problem, rethrow exception
                        throw e;
                    }
                    String attributeName = m.group(1);
                    int attrIndex = traindata.attribute(attributeName).index();
                    if (secondAttempt) {
                        traindataCopy = WekaUtils.upscaleAttribute(traindataCopy, attrIndex);
                    } else {
                        traindataCopy = WekaUtils.upscaleAttribute(traindata, attrIndex);
                    }
                    LOGGER.info("upscaled attribute " + attributeName + "; restarting training");
                    secondAttempt = true;
                    continue;
                }
            } finally {
                if (!// dummy loop for internal continue
                !selectionSuccessful) {
                    break;
                }
            }
        }
        double[] coverages = new double[topkIndex.length];
        for (Set<Integer> cfsSet : cfsSets) {
            Set<Integer> topkSet = new HashSet<>();
            for (int k = 0; k < topkIndex.length; k++) {
                topkSet.add(topkIndex[k]);
                coverages[k] += (coverage(topkSet, cfsSet) / trainversionSet.size());
            }
        }
        double bestCoverageValue = Double.MIN_VALUE;
        int bestCoverageIndex = 0;
        for (int i = 0; i < coverages.length; i++) {
            if (coverages[i] > bestCoverageValue) {
                bestCoverageValue = coverages[i];
                bestCoverageIndex = i;
            }
        }
        // build correlation matrix
        SpearmansCorrelation corr = new SpearmansCorrelation();
        double[][] correlationMatrix = new double[bestCoverageIndex][bestCoverageIndex];
        for (SoftwareVersion trainversion : trainversionSet) {
            Instances traindata = trainversion.getInstances();
            double[][] vectors = new double[bestCoverageIndex][traindata.size()];
            for (int i = 0; i < traindata.size(); i++) {
                for (int j = 0; j < bestCoverageIndex; j++) {
                    vectors[j][i] = traindata.get(i).value(topkIndex[j]);
                }
            }
            for (int j = 0; j < bestCoverageIndex; j++) {
                for (int k = j + 1; k < bestCoverageIndex; k++) {
                    correlationMatrix[j][k] = Math.abs(corr.correlation(vectors[j], vectors[k]));
                }
            }
        }
        Set<Integer> topkSetIndexSet = new TreeSet<>();
        // complexity
        for (int j = 0; j < bestCoverageIndex && j < 30; j++) {
            topkSetIndexSet.add(j);
        }
        Set<Set<Integer>> allCombinations = Sets.powerSet(topkSetIndexSet);
        double bestOptCoverage = Double.MIN_VALUE;
        Set<Integer> opttopkSetIndexSet = null;
        for (Set<Integer> combination : allCombinations) {
            if (isUncorrelated(correlationMatrix, combination)) {
                double currentCoverage = 0.0;
                Set<Integer> topkCombination = new TreeSet<>();
                for (Integer index : combination) {
                    topkCombination.add(topkIndex[index]);
                }
                for (Set<Integer> cfsSet : cfsSets) {
                    currentCoverage += (coverage(topkCombination, cfsSet) / trainversionSet.size());
                }
                if (currentCoverage > bestOptCoverage) {
                    bestOptCoverage = currentCoverage;
                    opttopkSetIndexSet = combination;
                }
            }
        }
        if (opttopkSetIndexSet == null) {
            throw new RuntimeException("Could not determine a best top-k set with optimal coverage. This means that the top-k set and the subset determined by CFS are disjunctive.");
        }
        Set<Integer> opttopkIndex = new TreeSet<>();
        for (Integer index : opttopkSetIndexSet) {
            opttopkIndex.add(topkIndex[index]);
        }
        LOGGER.debug("selected the following metrics:");
        for (Integer index : opttopkIndex) {
            LOGGER.debug(trainversionSet.get(0).getInstances().get(0).attribute(index).name());
        }
        // finally remove attributes
        for (int j = testdata.numAttributes() - 1; j >= 0; j--) {
            if (j != testdata.classIndex() && !opttopkIndex.contains(j)) {
                testdata.deleteAttributeAt(j);
                for (SoftwareVersion trainversion : trainversionSet) {
                    Instances traindata = trainversion.getInstances();
                    traindata.deleteAttributeAt(j);
                }
            }
        }
    }

    @SuppressWarnings("boxing")
    private boolean isUncorrelated(double[][] correlationMatrix, Set<Integer> combination) {
        Integer[] intCombination = combination.toArray(new Integer[0]);
        boolean areUncorrelated = true;
        for (int i = 0; areUncorrelated && i < intCombination.length; i++) {
            for (int j = i + 1; areUncorrelated && j < intCombination.length; j++) {
                areUncorrelated &= correlationMatrix[intCombination[i]][intCombination[j]] > this.correlationThreshold;
            }
        }
        return areUncorrelated;
    }

    private static double coverage(Set<Integer> topkSet, Set<Integer> cfsSet) {
        Set<Integer> topkSetCopy1 = new HashSet<>(topkSet);
        topkSetCopy1.retainAll(cfsSet);
        Set<Integer> topkSetCopy2 = new HashSet<>(topkSet);
        topkSetCopy2.addAll(cfsSet);
        return ((double) topkSetCopy1.size()) / topkSetCopy2.size();
    }
}

```


Overlapping Code:
```
lements ISetWiseProcessingStrategy {
/**
* Reference to the logger
*/
private static final Logger LOGGER = LogManager.getLogger("main");
ally used correlation threshold.
*/
double correlationThreshold = 0.5;
/*
* (non-Javadoc)
* 
* @see de.ugoe.cs.cpdp.IParameterizable#setParameter(java.lang.String)
*/
@Override
public void setParameter(String parameters) {
if (parameters != null && !parameters.equals("")) {
this.correlationThreshold = Double.parseDouble(parameters);
}
}
@Override
public void apply(SoftwareVersion testversion, SetUniqueList<SoftwareVersion> trainversionSet) {
try {
determineTopKAttributes(testversion, trainversio"Failure during metric selection: " + e.getMessage());
throw new RuntimeException(e);
}
}
@SuppressWarnings("boxing")
private void determineTopKAttributes(SoftwareVersion testversion, SetUniqueList<SoftwareVersion> trainversionSet) throws Excnstances testdata = testversion.getInstances();
Integer[] counts = new Integer[trainversionSet.get(0).getInstances().get(0).numAttributes() - 1];
IntStream.range(0, counts.length).forEach(val -> counts[val] = 0);
for (SoftwareVersion trainversion : trainversionSet) {
Instances traindata = trainversion.getInstances();
J48 decisionTree = new J48();
decisionTree.buildClassifier(traindata);
int k = 0;
for (int j = 0; j < traindata.numAttributes(); j++) {
if (j != traindata.classIndex()) {
if (decisionTree.toString().contains(traindata.attribute(j).name())) {
counts[k] = counts[k] + 1;
}
k++;
}
}
}
int[] topkIndex = new int[counts.length];
IntStream.range(0, counts.length).forEach(val -> topkIndex[val] = val);
SortUtils.quicksort(counts, topkIndex, true);
// get CFSs for each training set
List<Set<Integer>> cfsSets = new LinkedList<>();
for (SoftwareVersion trainversion : trainversionSet) {
Instances traindata = trainversion.getInstances();
boo
```
<Overlap Ratio: 0.9375639713408394>

---

--- 20 --
Question ID: fd5d92b41d2bda214eab3d1eddcc520c7b44e553
Original Code:
```
public class UrlPart {

    private final Object url;

    private final boolean isRegex;

    public UrlPart(String url, boolean isRegex) {
        this.url = url;
        this.isRegex = isRegex;
    }

    public UrlPart(HttpMethod method) {
        this.url = method;
        this.isRegex = false;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + (isRegex ? 1231 : 1237);
        result = prime * result + ((url == null) ? 0 : url.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        UrlPart other = (UrlPart) obj;
        if (url == null && other.url != null) {
            return false;
        }
        if (isRegex) {
            /*Matcher m = Pattern.compile(String.format("(%s)", url)).matcher(url);	
			return m.find();*/
            return true;
        }
        return url.equals(other.url);
    }

    @Override
    public String toString() {
        //	return "UrlPart [url=" + url + ", isRegex=" + isRegex + "]";
        return url.toString();
    }
}

```


Overlapping Code:
```
ivate final Object url;
private final boolean isRec UrlPart(HttpMethod method) {
this.url = method;
this.isRegex = false;
}
@Override
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + (isRegex ? 1231 : 1237);
result = prime * result + ((url == null) ? 0 : url.hashCode());
return result;
}
@Override
public boolean equals(Object obj) {
if (this == obj) {
return true;
}
if (obj == null) {
return false;
}
if (getClass() != obj.getClass()) {
return false;
}
UrlPart other = (UrlPart) obj;
if (url == null && other.url != null) {
return false;
}
if (isRegex) {
/*Matcher m = Pattern.compile(String.format("(%s)", url)).matcher(url); 
return m.find();*/
return true;
}
return url.equals(other.url);
}
@Override
public String toString() {
// return "UrlPart [url=" + url + ", isRegex=" + isRegex + "]";
return url.
```
<Overlap Ratio: 0.8600405679513184>

---

--- 21 --
Question ID: 7740a522f9d31a442361aea9f7bbad55c45087be
Original Code:
```
@Ignore
public class PhishingDetectionApiTest {

    private final PhishingDetectionApi api = new PhishingDetectionApi();

    /**
     * Detects phishing attempts
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void detectAndReportTest() throws ApiException {
        List<String> attachments = null;
        String body = null;
        String from = null;
        String subject = null;
        Integer response = api.detectAndReport(attachments, body, from, subject);
    }
}

```


Overlapping Code:
```
public class PhishingDetectionApiTest {
private final PhishingDetectionApi api = new PhishingDetectits
*
* @throws ApiException
* if the Api call fails
*/
@Test
public void detectAndReportTest() throws ApiException {
List<String> attachments = null;
String body = null;
String from = null;
String subject = null;
Integer response = api.detectAndReport(atta
```
<Overlap Ratio: 0.8165137614678899>

---

--- 22 --
Question ID: 65080318e0435ec7c0c7d4789c2b76ffc5799d38
Original Code:
```
public class CSSRule {

    private Set<String> selectors;

    private Map<String, String> properties;

    public CSSRule() {
        this.selectors = new HashSet<>();
        this.properties = new HashMap<>();
    }

    public CSSRule(Set<String> selectors, Map<String, String> properties) {
        this.selectors = selectors;
        this.properties = properties;
    }

    public static List<CSSRule> fromString(String text) {
        List<CSSRule> rep = new ArrayList<>();
        text = text.replaceAll("\\s+", "");
        String[] declarations = text.split("}");
        for (String declaration : declarations) {
            Set<String> selectors = new HashSet<>();
            Map<String, String> properties = new HashMap<>();
            CSSRule current = new CSSRule(selectors, properties);
            String[] strings = declaration.split("\\{");
            if (strings.length < 2) {
                continue;
            }
            String[] selectorsStr = strings[0].split(",");
            String[] propertiesStr = strings[1].split(";");
            selectors.addAll(Arrays.asList(selectorsStr));
            for (String property : propertiesStr) {
                String[] parts = property.split(":");
                properties.put(parts[0], parts[1]);
            }
            rep.add(current);
        }
        return rep;
    }

    public Map<String, String> getProperties() {
        return properties;
    }

    public boolean hasProperty(String name) {
        return properties.containsKey(name);
    }

    public boolean hasStyle(String style) {
        return hasProperty(style);
    }

    public String getPropertyValue(String name) {
        return properties.get(name);
    }

    public void setProperty(String name, String value) {
        properties.put(name, value);
    }

    public Set<String> getSelectors() {
        return selectors;
    }

    public void addSelector(String selector) {
        this.selectors.add(selector);
    }

    public boolean hasSelector(String selector) {
        return selectors.contains(selector);
    }

    public boolean hasClass(String clazz) {
        return selectors.contains("." + clazz);
    }

    public String toString(int indent) {
        StringBuilder rep = new StringBuilder();
        rep.append(spaces(indent)).append(String.join(", ", selectors)).append(" {").append("\n");
        for (Map.Entry<String, String> entry : properties.entrySet()) {
            rep.append(spaces(indent + 2)).append(entry.getKey()).append(": ").append(entry.getValue()).append(";\n");
        }
        rep.append(spaces(indent)).append("}\n");
        return rep.toString();
    }

    @Override
    public String toString() {
        return toString(0);
    }

    @Override
    public CSSRule clone() {
        return new CSSRule(new HashSet<>(this.selectors), new HashMap<>(this.properties));
    }
}

```


Overlapping Code:
```
 CSSRule {
private Set<String> selectors;
private Map<String, String> properties;
public CSSRule() {
this.selectors = new HashSet<>();
this.properties = new HashMap<>();
}
public CSSRule(Set<String> selectors, Map<String, String> properties) {
this.selectors = selectors;
this.properties = properties;
}
public static List<CSSRule> fromString(String text) {
List<CSSRule> rep = new ArrayList<>();
text = text.replaceAll("\\s+", "");
String[] declarations = text.split("}");
for (String declaration : declarations) {
Set<String> selectors = new HashSet<>();
Map<String, String> properties = new HashMap<>();
CSSRule current = new CSSRule(selectors, properties);
String[] strings = declaration.split("\[] selectorsStr = strings[0].split(",");
String[] propertiesStr = strings[1].split(";");
selectors.addAll(Arrays.asList(selectorsStr));
for (String property : propertiesStr) {
String[] parts = property.split(":");
properties.put(parts[0], parts[1]);
}
rep.add(current);
}
return rep;
}
public Map<String, String> getProperties() {
return properties;
}
public boolean hasProperty(String name) {
return properties.containsKey(name);
}
public boolean hasStyle(String style) {
return hasProperty(style);
}
public String getPropertyValue(String name) {
return properties.get(name);
}
public void setProperty(String name, String value) {
properties.put(name, value);
}
public Set<String> getSelectors() {
return selectors;
}
public void addSelector(String selector) {
this.selectors.add(selector);
}
public boolean hasSelector(String selector) {
return selectors.contains(selector);
}
public boolean hasClass(String clazz) {
return selectors.contains("." + clazz);
}
public String toString(int indent) {
StringBuilder rep = new StringBuilder();
rep.append(spaces(indent)).append(String.join(", ", selectors)).append(" {").append("\n");
for (Map.Entry<String, String> entry : properties.entrySet()) {
rep.ap
```
<Overlap Ratio: 0.9519038076152304>

---

--- 23 --
Question ID: 2b5d7a6df824e402ae1c26cbf10970eb75941eb6
Original Code:
```
public class PlaceLocation {

    public String name;

    public String address;

    public boolean isNotInUsa() {
        return address != null && !address.endsWith("USA") && !address.endsWith("United States");
    }

    public String country() {
        if (address == null) {
            return null;
        }
        String countryMatch = address.substring(address.lastIndexOf("\n") + 1);
        String trimmedCountry;
        if (!countryMatch.contains(",")) {
            trimmedCountry = countryMatch.trim();
        } else {
            trimmedCountry = countryMatch.substring(countryMatch.lastIndexOf(",") + 1).trim();
        }
        switch(trimmedCountry) {
            case "United States":
                return "USA";
            case "Italia":
                return "Italy";
            case "Tanz?nie":
                return "Tanzania";
            case "?ire":
                return "Ireland";
            case "United Kingdom":
                return "UK";
            default:
                return trimmedCountry;
        }
    }
}

```


Overlapping Code:
```
public class PlaceLocation {
public String name;
public String address;
public boolean isNotInUsa() {
return address != null && !address.endsWith("USA") && !address.endsWith("United States");
}
public String country() {
if (address == null) {
return null;
}
String countryMatch = address.substring(address.lastIndexOf("\n") + 1);
String trimmedCountry;
if (!countryMatch.contains(",")) {
trimmedCountry = countryMatch.trim();
} else {
trimmedCountry = countryMatch.substring(countryMatch.lastIndexOf( "United States":
return "USA";
case "Italia":
return "Italy";
case "Tancase "United Kingdom":
return "UK";
default:
return trimmedCountry;
}

```
<Overlap Ratio: 0.8537234042553191>

---

--- 24 --
Question ID: 0556eb05af9e2291d3785cc5ac51b749d932d51e
Original Code:
```
public class HandleResponseImpl implements ResponseHandler<ResponseDto> {

    @Override
    public ResponseDto handleResponse(HttpResponse httpResponse) throws IOException {
        ResponseDto response = new ResponseDto();
        if (null != httpResponse) {
            response.setResponse(httpResponse);
            response.setStatusCode(httpResponse.getStatusLine().getStatusCode());
            for (Header header : httpResponse.getAllHeaders()) {
                response.setHeader(header.getName(), MessageDigestUtil.iso88591ToUtf8(header.getValue()));
            }
            response.setContentType(response.getHeader("Content-Type"));
            response.setRequestId(response.getHeader("X-Ca-Request-Id"));
            response.setErrorMessage(response.getHeader("X-Ca-Error-Message"));
            if (httpResponse.getEntity() == null) {
                response.setBody(null);
            } else {
                String s = readStreamAsStr(httpResponse.getEntity().getContent());
                response.setBody(s);
                response.setErrorMessage(s);
            }
        } else {
            response.setStatusCode(500);
            response.setErrorMessage("No Response");
        }
        return response;
    }

    public static String readStreamAsStr(InputStream is) throws IOException {
        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
            WritableByteChannel dest = Channels.newChannel(bos);
            ReadableByteChannel src = Channels.newChannel(is)) {
            ByteBuffer bb = ByteBuffer.allocate(4096);
            for (; src.read(bb) != -1; ) {
                bb.flip();
                dest.write(bb);
                bb.clear();
            }
            return new String(bos.toByteArray(), StandardCharsets.UTF_8);
        }
    }
}

```


Overlapping Code:
```
l implements ResponseHandler<ResponseDto> {
@Override
public ResponseDto handleResponse(HttpResponse httpResponse) throws IOException {
ResponseDto response = new ResponseDto();
if (null != httpResponse) {
response.setResponse(httpResponse);
response.setStatusCode(httpResponse.getStatusLine().getStatusCode());
for (Header header : httpResponse.getAllHeaders()) {
response.setHeader(header.getName(), MessageDigestUtil.iso88591ToUtf8(header.getValue()));
}
response.setContentType(response.getHeader("Content-Type"));
response.setRequestId(response.getHeader("X-Ca-Request-Id"));
response.setErrorMessage(response.getHeader("X-Ca-Error-Message"));
if (httpResponse.getEntity() == null) {
response.setBody(null);
} else {
String s = readStreamAsStr(httpResponse.getEntity().getContent());
response.setBody(s);
response.setErrorMessage(s);
}
} else {
response.setStatusCode(500);
response.setErrorMessage("No Response");
}
return response;
}
public static String readStreamAsStr(InputStream is) throws IOException {
try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
WritableByteChannel dest = Channels.newChannel(bos);
ReadableByteChannel src = Channels.newC
}
return new String(bos.toByteArray(), StandardCharsets.UTF_8);

```
<Overlap Ratio: 0.8845878136200717>

---

--- 25 --
Question ID: e32741ad1544b9465ebc4976051bd0b87f903644
Original Code:
```
public class SupplierCompileCompletionTest extends OfficeFrameTestCase {

    /**
     * Ensure capture {@link OfficeFloor} scope for {@link SupplierSource}.
     */
    public void testOfficeFloorCompileScope() {
        // Capture the sources
        CompleteSupplierSource completeSupplier = new CompleteSupplierSource();
        // Provide sources to capture the profiles
        MockManagedObjectSource officeFloorMos = new MockManagedObjectSource();
        MockManagedObjectPoolSource officeFloorPool = new MockManagedObjectPoolSource();
        MockTeamSource team = new MockTeamSource();
        MockExecutiveSource executive = new MockExecutiveSource();
        MockManagedObjectSource officeMos = new MockManagedObjectSource();
        MockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();
        MockSupplierSource officeSupplier = new MockSupplierSource();
        MockAdministrationSource admin = new MockAdministrationSource();
        MockGovernanceSource govern = new MockGovernanceSource();
        MockManagedObjectSource sectionMos = new MockManagedObjectSource();
        MockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();
        MockManagedFunctionSource function = new MockManagedFunctionSource();
        // Compile
        CompileOfficeFloor compiler = new CompileOfficeFloor();
        compiler.officeFloor((context) -> {
            OfficeFloorDeployer deployer = context.getOfficeFloorDeployer();
            DeployedOffice office = context.getDeployedOffice();
            // Managed Object
            OfficeFloorManagedObjectSource mos = deployer.addManagedObjectSource("MOS", officeFloorMos);
            deployer.link(mos.getManagingOffice(), office);
            mos.addOfficeFloorManagedObject("MO", ManagedObjectScope.THREAD);
            // Managed Object Pool
            OfficeFloorManagedObjectPool pool = deployer.addManagedObjectPool("POOL", officeFloorPool);
            deployer.link(mos, pool);
            // Team
            deployer.addTeam("TEAM", team);
            // Executive
            deployer.setExecutive(executive);
            // Supplier
            deployer.addSupplier("SUPPLIER", completeSupplier);
            // (Note compiling of added items happens after OfficeFloor sourcing)
            assertNull("Supplier should yet be created", compileScopedSources.get());
        });
        compiler.office((context) -> {
            OfficeArchitect office = context.getOfficeArchitect();
            // Ensure the supplier is now available
            assertNotNull("Supplier should have setup context", compileScopedSources.get());
            // Managed Object
            OfficeManagedObjectSource mos = office.addOfficeManagedObjectSource("MOS", officeMos);
            mos.addOfficeManagedObject("MO", ManagedObjectScope.THREAD);
            // Managed Object Pool
            OfficeManagedObjectPool pool = office.addManagedObjectPool("POOL", officePool);
            office.link(mos, pool);
            // Supplier
            office.addSupplier("SUPPLIER", officeSupplier);
            // Administration
            OfficeAdministration administration = office.addOfficeAdministration("ADMIN", admin);
            OfficeSection section = office.getOfficeSection("SECTION");
            section.getOfficeSectionFunction("function").addPreAdministration(administration);
            // Governance
            office.addOfficeGovernance("GOVERNANCE", govern);
        });
        compiler.section((context) -> {
            SectionDesigner designer = context.getSectionDesigner();
            // Managed Object
            SectionManagedObjectSource mos = designer.addSectionManagedObjectSource("MOS", sectionMos);
            mos.addSectionManagedObject("MO", ManagedObjectScope.THREAD);
            // Managed Object Pool
            SectionManagedObjectPool pool = designer.addManagedObjectPool("POOL", sectionPool);
            designer.link(mos, pool);
            // Function
            designer.addSectionFunctionNamespace("FUNCTION", function).addSectionFunction("function", "function");
        });
        // Undertake compiling with clean state
        compileScopedSources.remove();
        try (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {
            // Ensure complete supplier source context
            assertCompletedSupplierCompileContext(completeSupplier.initialContext);
            assertCompletedSupplierCompileContext(completeSupplier.completeContext);
            // Ensure all functionality are added
            assertTrue("Missing (OfficeFloor) supplier", completeSupplier.completed.contains(completeSupplier));
            assertTrue("Missing (OfficeFloor) managed object", completeSupplier.completed.contains(officeFloorMos));
            assertTrue("Missing (OfficeFloor) managed object pool", completeSupplier.completed.contains(officeFloorPool));
            assertTrue("Missing team", completeSupplier.completed.contains(team));
            assertTrue("Missing executive", completeSupplier.completed.contains(executive));
            assertTrue("Missing (office) managed object", completeSupplier.completed.contains(officeMos));
            assertTrue("Missing (office) managed object pool", completeSupplier.completed.contains(officePool));
            assertTrue("Missing (office) supplier", completeSupplier.completed.contains(officeSupplier));
            assertTrue("Missing administration", completeSupplier.completed.contains(admin));
            assertTrue("Missing governance", completeSupplier.completed.contains(govern));
            assertTrue("Missing (section) managed object", completeSupplier.completed.contains(sectionMos));
            assertTrue("Missing (section) managed object pool", completeSupplier.completed.contains(sectionPool));
            assertTrue("Missing function", completeSupplier.completed.contains(function));
            assertEquals("Incorrect number of sources in scope: " + completeSupplier.completed, 13, completeSupplier.completed.size());
        } catch (Exception ex) {
            throw fail(ex);
        }
    }

    /**
     * Ensure capture {@link Office} scope for {@link SupplierSource}.
     */
    public void testOfficeCompileScope() {
        // Capture the sources
        CompleteSupplierSource completeSupplier = new CompleteSupplierSource();
        // Provide sources to capture the profiles
        MockManagedObjectSource officeMos = new MockManagedObjectSource();
        MockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();
        MockAdministrationSource admin = new MockAdministrationSource();
        MockGovernanceSource govern = new MockGovernanceSource();
        MockManagedObjectSource sectionMos = new MockManagedObjectSource();
        MockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();
        MockManagedFunctionSource function = new MockManagedFunctionSource();
        // Compile
        CompileOfficeFloor compiler = new CompileOfficeFloor();
        compiler.office((context) -> {
            OfficeArchitect office = context.getOfficeArchitect();
            // Managed Object
            OfficeManagedObjectSource mos = office.addOfficeManagedObjectSource("MOS", officeMos);
            mos.addOfficeManagedObject("MO", ManagedObjectScope.THREAD);
            // Managed Object Pool
            OfficeManagedObjectPool pool = office.addManagedObjectPool("POOL", officePool);
            office.link(mos, pool);
            // Administration
            OfficeAdministration administration = office.addOfficeAdministration("ADMIN", admin);
            OfficeSection section = office.getOfficeSection("SECTION");
            section.getOfficeSectionFunction("function").addPreAdministration(administration);
            // Governance
            office.addOfficeGovernance("GOVERNANCE", govern);
            // Supplier
            office.addSupplier("SUPPLIER", completeSupplier);
            // (Note compiling of added items happens after Office sourcing)
            assertNull("Supplier should yet be created", compileScopedSources.get());
        });
        compiler.section((context) -> {
            SectionDesigner designer = context.getSectionDesigner();
            // Managed Object
            SectionManagedObjectSource mos = designer.addSectionManagedObjectSource("MOS", sectionMos);
            mos.addSectionManagedObject("MO", ManagedObjectScope.THREAD);
            // Managed Object Pool
            SectionManagedObjectPool pool = designer.addManagedObjectPool("POOL", sectionPool);
            designer.link(mos, pool);
            // Function
            designer.addSectionFunctionNamespace("FUNCTION", function).addSectionFunction("function", "function");
        });
        // Undertake compiling with clean state
        compileScopedSources.remove();
        try (OfficeFloor officeFloor = compiler.compileOfficeFloor()) {
            // Ensure complete supplier source context
            assertCompletedSupplierCompileContext(completeSupplier.initialContext);
            assertCompletedSupplierCompileContext(completeSupplier.completeContext);
            // Ensure all functionality are added
            assertTrue("Missing supplier", completeSupplier.completed.contains(completeSupplier));
            assertTrue("Missing (office) managed object", completeSupplier.completed.contains(officeMos));
            assertTrue("Missing (office) managed object pool", completeSupplier.completed.contains(officePool));
            assertTrue("Missing administration", completeSupplier.completed.contains(admin));
            assertTrue("Missing governance", completeSupplier.completed.contains(govern));
            assertTrue("Missing (section) managed object", completeSupplier.completed.contains(sectionMos));
            assertTrue("Missing (section) managed object pool", completeSupplier.completed.contains(sectionPool));
            assertTrue("Missing function", completeSupplier.completed.contains(function));
            assertEquals("Incorrect number of sources in scope: " + completeSupplier.completed, 8, completeSupplier.completed.size());
        } catch (Exception ex) {
            throw fail(ex);
        }
    }

    private static void assertCompletedSupplierCompileContext(SupplierCompileContext context) {
        assertIllegalStateException(() -> context.addManagedObjectSource(null, null, null), "Unable to add further ManagedObject as SupplierSource loaded");
        assertIllegalStateException(() -> context.addSupplierThreadLocal(null, null), "Unable to add further SupplierThreadLocal as SupplierSource loaded");
        assertIllegalStateException(() -> context.addThreadSynchroniser(null), "Unable to add further ThreadSynchroniser as SupplierSource loaded");
        assertIllegalStateException(() -> context.addInternalSupplier(null), "Unable to add further InternalSupplier as SupplierSource loaded");
        assertIllegalStateException(() -> ((SupplierSourceContext) context).addCompileCompletion(null), "Unable to add further SupplierCompileCompletion as SupplierSource completing");
    }

    private static void assertIllegalStateException(Runnable logic, String message) {
        try {
            logic.run();
            fail("Should not be successful. " + message);
        } catch (IllegalStateException ex) {
            assertEquals("Incorrect cause", message, ex.getMessage());
        }
    }

    private static final ThreadLocal<List<Object>> compileScopedSources = new ThreadLocal<List<Object>>();

    @TestSource
    private static class CompleteSupplierSource extends AbstractSupplierSource {

        private final List<Object> completed = new ArrayList<>();

        /**
         * Initial {@link SupplierSourceContext}.
         */
        private SupplierSourceContext initialContext;

        /**
         * Completion {@link SupplierCompileContext}.
         */
        private SupplierCompileContext completeContext;

        @Override
        protected void loadSpecification(SpecificationContext context) {
        }

        @Override
        public void supply(SupplierSourceContext context) throws Exception {
            this.initialContext = context;
            // Clear scoped objects
            LinkedList<Object> sources = new LinkedList<>();
            sources.add(this);
            compileScopedSources.set(sources);
            // Capture sources on completion
            context.addCompileCompletion((completion) -> {
                this.completeContext = completion;
                this.completed.addAll(compileScopedSources.get());
            });
        }

        @Override
        public void terminate() {
        }
    }

    @TestSource
    private static class MockSupplierSource extends AbstractSupplierSource {

        @Override
        protected void loadSpecification(SpecificationContext context) {
        }

        @Override
        public void supply(SupplierSourceContext context) throws Exception {
            compileScopedSources.get().add(this);
        }

        @Override
        public void terminate() {
        }
    }

    @TestSource
    private static class MockManagedObjectSource extends AbstractManagedObjectSource<None, None> {

        @Override
        protected void loadSpecification(SpecificationContext context) {
        }

        @Override
        protected void loadMetaData(MetaDataContext<None, None> context) throws Exception {
            context.setObjectClass(Object.class);
            compileScopedSources.get().add(this);
        }

        @Override
        protected ManagedObject getManagedObject() throws Throwable {
            fail("Should not be run");
            return null;
        }
    }

    @TestSource
    private static class MockManagedObjectPoolSource extends AbstractManagedObjectPoolSource implements ManagedObjectPoolFactory {

        @Override
        protected void loadSpecification(SpecificationContext context) {
        }

        @Override
        protected void loadMetaData(MetaDataContext context) throws Exception {
            context.setPooledObjectType(Object.class);
            context.setManagedObjectPoolFactory(this);
            compileScopedSources.get().add(this);
        }

        @Override
        public ManagedObjectPool createManagedObjectPool(ManagedObjectPoolContext managedObjectPoolContext) throws Throwable {
            return null;
        }
    }

    @TestSource
    private static class MockTeamSource extends AbstractTeamSource implements Team {

        @Override
        protected void loadSpecification(SpecificationContext context) {
        }

        @Override
        public Team createTeam(TeamSourceContext context) throws Exception {
            compileScopedSources.get().add(this);
            return this;
        }

        @Override
        public void startWorking() {
        }

        @Override
        public void assignJob(Job job) throws TeamOverloadException, Exception {
            fail("Should not run");
        }

        @Override
        public void stopWorking() {
        }
    }

    @TestSource
    private static class MockExecutiveSource extends DefaultExecutive {

        @Override
        public Executive createExecutive(ExecutiveSourceContext context) throws Exception {
            compileScopedSources.get().add(this);
            return super.createExecutive(context);
        }
    }

    @TestSource
    private static class MockAdministrationSource extends AbstractAdministrationSource<Object, None, None> {

        @Override
        protected void loadSpecification(SpecificationContext context) {
        }

        @Override
        protected void loadMetaData(MetaDataContext<Object, None, None> context) throws Exception {
            context.setExtensionInterface(Object.class);
            context.setAdministrationFactory(() -> (adminContext) -> {
            });
            compileScopedSources.get().add(this);
        }
    }

    @TestSource
    private static class MockGovernanceSource extends AbstractGovernanceSource<Object, None> {

        @Override
        protected void loadSpecification(SpecificationContext context) {
        }

        @Override
        protected void loadMetaData(MetaDataContext<Object, None> context) throws Exception {
            context.setExtensionInterface(Object.class);
            context.setGovernanceFactory(() -> null);
            compileScopedSources.get().add(this);
        }
    }

    @TestSource
    private static class MockManagedFunctionSource extends AbstractManagedFunctionSource {

        @Override
        protected void loadSpecification(SpecificationContext context) {
        }

        @Override
        public void sourceManagedFunctions(FunctionNamespaceBuilder functionNamespaceTypeBuilder, ManagedFunctionSourceContext context) throws Exception {
            functionNamespaceTypeBuilder.addManagedFunctionType("function", None.class, None.class).setFunctionFactory(() -> (mfContext) -> {
            });
            compileScopedSources.get().add(this);
        }
    }
}

```


Overlapping Code:
```
ds OfficeFrameTestCase {
/**
* Ensure capture {@link OfficeFloor} scope for {@link SupplierSource}.
*/
public void testOfficeFloorCompileScope() {
// Capture the sources
CompleteSupplierSource completeSupplier = new CompleteSupplierSource();
// Provide sources to capture the profiles
MockManagedObjectSource officeFloorMos = new MockManagedObjectSource();
MockManagedObjectPoolSource officeFloorPool = new MockManagedObjectPoolSource();
MockTeamSource team = new MockTeamSource();
MockExecutiveSource executive = new MockExecutiveSource();
MockManagedObjectSource officeMos = new MockManagedObjectSource();
MockManagedObjectPoolSource officePool = new MockManagedObjectPoolSource();
MockSupplierSource officeSupplier = new MockSupplierSource();
MockAdministrationSource admin = new MockAdministrationSource();
MockGovernanceSource govern = new MockGovernanceSource();
MockManagedObjectSource sectionMos = new MockManagedObjectSource();
MockManagedObjectPoolSource sectionPool = new MockManagedObjectPoolSource();
MockManagedFunctionSource function = new MockManagedFunctionSource();
// Compile
CompileOfficeFloor compiler = new CompileOfficeFloor();
compiler.officeFloor((context) -> {
OfficeFloorDeployer deployer = context.getOfficeFloorDeployer();
DeployedOffice office = context.getDeployedOffice();
// Managed Object
OfficeFloorManagedObjectSource mos = deployer.addManagedObjectSource("MOS", officeFloorMos);
deployer.link(mos.getManagingOffice(), office);
mos.addOfficeFloorManagedObject("MO", ManagedObjectScope.THREAD);
// Managed Object Pool
OfficeFloorManagedObjectPool pool = deployer.addManagedObjectPool("POOL", officeFloorPool);
deployer.link(mos, pool);
// Team
deployer.addTeam("TEAM", team);
// Executive
deployer.setExecutive(executive);
// Supplier
deployer.addSupplier("SUPPLIERappens after OfficeFloor sourcing)
assertNull("Supplier should yet be created", compileScopedSources.get());
});
compiler.office((context) -> {
OfficeArchitect office = context.getOfficeArchitect();
```
<Overlap Ratio: 0.9500713266761769>

---

--- 26 --
Question ID: 1bfe81dec8dca4cb4bef7c48cad2b36862d7d8fe
Original Code:
```
@ApiModel(description = "A single Excel XLSX file corresponding to one worksheet (tab) in the original spreadsheet")
@JsonPropertyOrder({ PresentationResult.JSON_PROPERTY_SLIDE_NUMBER, PresentationResult.JSON_PROPERTY_U_R_L, PresentationResult.JSON_PROPERTY_PRESENTATION_CONTENTS })
@JsonTypeName("PresentationResult")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2020-11-14T13:47:19.979-08:00[America/Los_Angeles]")
public class PresentationResult {

    public static final String JSON_PROPERTY_SLIDE_NUMBER = "SlideNumber";

    private Integer slideNumber;

    public static final String JSON_PROPERTY_U_R_L = "URL";

    private String URL;

    public static final String JSON_PROPERTY_PRESENTATION_CONTENTS = "PresentationContents";

    private byte[] presentationContents;

    public PresentationResult slideNumber(Integer slideNumber) {
        this.slideNumber = slideNumber;
        return this;
    }

    /**
     * Worksheet number of the converted page, starting with 1 for the left-most worksheet
     * @return slideNumber
     */
    @javax.annotation.Nullable
    @ApiModelProperty(value = "Worksheet number of the converted page, starting with 1 for the left-most worksheet")
    @JsonProperty(JSON_PROPERTY_SLIDE_NUMBER)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public Integer getSlideNumber() {
        return slideNumber;
    }

    public void setSlideNumber(Integer slideNumber) {
        this.slideNumber = slideNumber;
    }

    public PresentationResult URL(String URL) {
        this.URL = URL;
        return this;
    }

    /**
     * URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted
     * @return URL
     */
    @javax.annotation.Nullable
    @ApiModelProperty(value = "URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted")
    @JsonProperty(JSON_PROPERTY_U_R_L)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public String getURL() {
        return URL;
    }

    public void setURL(String URL) {
        this.URL = URL;
    }

    public PresentationResult presentationContents(byte[] presentationContents) {
        this.presentationContents = presentationContents;
        return this;
    }

    /**
     * Contents of the presentation in bytes
     * @return presentationContents
     */
    @javax.annotation.Nullable
    @ApiModelProperty(value = "Contents of the presentation in bytes")
    @JsonProperty(JSON_PROPERTY_PRESENTATION_CONTENTS)
    @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
    public byte[] getPresentationContents() {
        return presentationContents;
    }

    public void setPresentationContents(byte[] presentationContents) {
        this.presentationContents = presentationContents;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        PresentationResult presentationResult = (PresentationResult) o;
        return Objects.equals(this.slideNumber, presentationResult.slideNumber) && Objects.equals(this.URL, presentationResult.URL) && Arrays.equals(this.presentationContents, presentationResult.presentationContents);
    }

    @Override
    public int hashCode() {
        return Objects.hash(slideNumber, URL, Arrays.hashCode(presentationContents));
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class PresentationResult {\n");
        sb.append("    slideNumber: ").append(toIndentedString(slideNumber)).append("\n");
        sb.append("    URL: ").append(toIndentedString(URL)).append("\n");
        sb.append("    presentationContents: ").append(toIndentedString(presentationContents)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }
}

```


Overlapping Code:
```
(description = "A single Excel XLSX file corresponding to one worksheet (tab) in the original spreadsheet")
@JsonPropertyOrder({nTypeName("PresentationResult")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2020-11-14T13:47:19.979-08:00[America/Los_Angeles]")
public class PresentationResult {
public static final String JSON_PROPERTY_SLIDE_NUMBER = "SlideNumber";
private Integer slideNumber;
public static final String JSON_PROPERTY_U_R_L = "URL";
private String URL;
public static final String JSON_PROPERTY_PRESENTATION_CONTENTS = "PresentationContents";
private byte[] presentationContents;
public PresentationResult slir(Integer slideNumber) {
this.slideNumber = slideNumber;
return this;
}
/**
* Worksheet number of the converted page, starting with 1 for the left-most worksheetNumber
*/
@javax.annotation.Nullable
@ApiModelProperty(value = "Worksheet number of the converted page, starting with 1 for the left-most worksheet")
@JsonProperty(JSON_PROPERTY_SLIDE_NUMBER)
@JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
public Integer getSlideNumber() {
return slideNumber;
}
public void setSlideNumber(Integer slideNumber) {
this.slideNumber = slideNumber;
}
public PresentationResult URL(String URL) {
this.URL = URL;
return this;
}
/**
* URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted
* 
*/
@javax.annotation.Nullable
@ApiModelProperty(value = "URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted")
@JsonProperty(JSON_PROPERTY_U_R_L)
@JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
public String getURL() {
return URL;
}
public void setURL(String URL) {
this.URL = URL;
}
public PresentationResult presentationContents(byte[] presentationContents) {
this.presentationContents = presentationContents;
return this;
}
/**
* Contents of the presentation in bytes
* @return presentats
*/
@javax.annotation.Nullable
@ApiModelProperty(value = "Contents of the 
```
<Overlap Ratio: 0.9048473967684022>

---

--- 27 --
Question ID: 0db6462f307cd534cb695bcb86ae0f3fbd5626e1
Original Code:
```
public class BlazeLimbEntity extends Entity {

    public static final Identifier SPAWN_PACKET = FrostburnOrigins.id("blaze_limb");

    public BlazeLimbEntity(EntityType<? extends BlazeLimbEntity> entityType, World world) {
        super(entityType, world);
    }

    public BlazeLimbEntity(World world, double x, double y, double z, int id, UUID uuid) {
        this(FrostburnOrigins.BLAZE_LIMB, world);
        this.updatePosition(x, y, z);
        this.setVelocity(Vec3d.ZERO);
        this.prevX = x;
        this.prevY = y;
        this.prevZ = z;
        updateTrackedPosition(x, y, z);
        setEntityId(id);
        setUuid(uuid);
    }

    private UUID ownerUuid = null;

    public void setOwnerUuid(UUID uuid) {
        ownerUuid = uuid;
    }

    public UUID getOwnerUuid() {
        return ownerUuid;
    }

    @Override
    protected void initDataTracker() {
    }

    @Override
    public void tick() {
        this.updatePosition(x, y, z);
        this.setVelocity(Vec3d.ZERO);
        this.prevX = x;
        this.prevY = y;
        this.prevZ = z;
        updateTrackedPosition(x, y, z);
    }

    @Override
    protected void readCustomDataFromTag(CompoundTag tag) {
    }

    @Override
    protected void writeCustomDataToTag(CompoundTag tag) {
    }

    @Override
    public Packet<?> createSpawnPacket() {
        PacketByteBuf packet = new PacketByteBuf(Unpooled.buffer());
        // entity position
        packet.writeDouble(getX());
        packet.writeDouble(getY());
        packet.writeDouble(getZ());
        // entity id & uuid
        packet.writeInt(getEntityId());
        packet.writeUuid(getUuid());
        return ServerSidePacketRegistry.INSTANCE.toPacket(SPAWN_PACKET, packet);
    }
}

```


Overlapping Code:
```
mbEntity extends Entity {
public static final Identifier SPAWN_PACKET = FrostburnOrigins.id("blaze_limb");
public BlazeLimbEntity(EntityType<? extends BlazeLimbEntity> entityType, World world) {
super(entityType, world);
}
public BlazeLimbEntity(World world, double x, double y, double z, int id, UUID uuid) {
this(FrostburnOrigins.BLAZE_LIMB, world);
this.updatePosition(x, y, z);
this.setVelocity(Vec3d.ZERO);
this.prevX = x;
this.prevY = y;
this.prevZ = z;
updateTrackedPosition(x, y, z);
setEntityId(id);
setUuid(uuid);
}
private UUID ownerUuid = null;
public void setOwnerUuid(UUID uuid) {
ownerUuid = uuid;
}
public UUID getOwnerUuid() {
return ownerUuid;
}
@Override
protected void initDataTracker() {
}
@Override
public void tick() {
this.updatePosition(x, y, z);
this.setVelocity(Vec3d.ZERO);
this.prevX = x;
this.prevY = y;
this.prevZ = z;
updateTrackedPosition(x, y, z);
}
@Override
protected void readCustomDataFromTag(CompoundTag tag) {
}
@Override
protected void writeCustomDataToTag(CompoundTag tag) {
}
@Override
public Packet<?> createSpawnPacket() {
PacketByteBuf packet = new PacketByteBuf(Unpooled.buffer());
// entity position
packet.writeDouble(getX());
packet.writeDouble(getY());
packet.writeDouble(getZ());
// entity id & uuid
packet.writeInt(getEntityId());
packet.writeUuid(getUuid());
return ServerSidePacketRegistry.INSTANCE.toPacket(SPAWN_PACKET, packet);
}

```
<Overlap Ratio: 0.9850958126330731>

---

--- 28 --
Question ID: aec0215d4dc6b60e41e0cce06ce6ef28c82d7239
Original Code:
```
public class Julius {

    public static void test() throws FileNotFoundException {
        if (!Settings.julius_bin.exists())
            throw new FileNotFoundException(Settings.julius_bin.getAbsolutePath());
        if (!Settings.julius_mklm_bin.exists())
            throw new FileNotFoundException(Settings.julius_mklm_bin.getAbsolutePath());
    }

    public static void julius(File conf, File filelist, File dic, File binlm) throws RuntimeException {
        String[] cmd = new String[] { Settings.julius_bin.getAbsolutePath(), "-C", conf.getAbsolutePath(), "-filelist", filelist.getAbsolutePath(), "-v", dic.getAbsolutePath(), "-d", binlm.getAbsolutePath() };
        ProgramLauncher launcher = new ProgramLauncher(cmd);
        launcher.setStdoutStream(new Log.Stream());
        launcher.setStderrStream(new Log.Stream("ERR>>"));
        Log.verbose("julius: " + filelist.getName());
        launcher.run();
        Log.verbose("Done.");
        if (launcher.getReturnValue() != 0)
            throw new RuntimeException("Retval: " + launcher.getReturnValue());
    }

    public static void mkbingram(File model_bkwd, File binlm) throws RuntimeException {
        String[] cmd = new String[] { Settings.julius_mklm_bin.getAbsolutePath(), "-nrl", model_bkwd.getAbsolutePath(), binlm.getAbsolutePath() };
        ProgramLauncher launcher = new ProgramLauncher(cmd);
        launcher.setStdoutStream(new Log.Stream());
        launcher.setStderrStream(new Log.Stream("ERR>>"));
        Log.verbose("mkbingram: " + model_bkwd.getName() + " -> " + binlm.getName());
        launcher.run();
        Log.verbose("Done.");
        if (launcher.getReturnValue() != 0)
            throw new RuntimeException("Retval: " + launcher.getReturnValue());
    }

    public static Segmentation align(File sound, File text) throws IOException, RuntimeException {
        File[] files = new File[] { sound };
        File conf = new File("julius_model/julius.jconf");
        File scp = new File(Settings.temp_dir, "julius.scp");
        File vocab = new File(Settings.temp_dir, "julius.voc");
        File dict = new File(Settings.temp_dir, "julius.dic");
        File model = new File(Settings.temp_dir, "julius.lm");
        File text_b = new File(Settings.temp_dir, "julius_rev.txt");
        File binlm = new File(Settings.temp_dir, "julius.jlm");
        FileUtils.reverse(text, text_b);
        NGram.srilm_estimate(text_b, vocab, model, 3);
        mkbingram(model, binlm);
        Transcriber.transcribe(vocab, Settings.default_encoding, dict, Settings.default_encoding, true);
        FileUtils.makeSCPFile(scp, files, false);
        Log.verbose("Running julius...");
        julius(conf, scp, dict, binlm);
        Log.verbose("Parsing julius output...");
        String soundname = sound.getAbsolutePath();
        soundname = soundname.substring(0, soundname.lastIndexOf('.'));
        File outfile = new File(soundname + ".out");
        Vector<JuliusOutput> julouts = null;
        julouts = JuliusOutput.loadFromJulius(outfile);
        if (julouts.isEmpty())
            throw new RuntimeException("Julius didn't provide any outputs!");
        Segmentation ret = julouts.get(0).aligned.toSegmentation(Settings.julius_win_offset);
        int i = 1;
        while (i < julouts.size()) try {
            double offset = ret.tiers.get(0).max();
            ret.appendSegmenation(julouts.get(i).aligned.toSegmentation(Settings.julius_win_offset), offset);
        } finally {
            i++;
        }
        return ret;
    }

    /**
     * Unit tests.
     *
     * @param args
     */
    public static void main(String[] args) {
        try {
            Locale.setDefault(Locale.ENGLISH);
            Log.init("JuliusUnitTest", false);
            Transcriber.init();
            Transcriber.test();
            Segmentation seg = align(new File("/home/guest/Desktop/Respeaking/test/kopacz.wav"), new File("/home/guest/Desktop/Respeaking/test/kopacz.txt"));
            TextGrid grid = new TextGrid(seg);
            grid.write(new File("/home/guest/Desktop/Respeaking/test/out.TextGrid"));
            Log.info("Julius Test complete!");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```


Overlapping Code:
```
Julius {
public static void test() throws FileNotFoundException {
if (!Settings.julius_bin.exists())
throw new FileNotFoundException(Settings.julius_bin.getAbsolutePath());
if (!Settings.julius_mklm_bin.exists())
throw new FileNotFoundException(Settiius(File conf, File filelist, File dic, File binlm) throws RuntimeException {
String[] cmd = new String[] { Settings.julius_bin.getAbsolutePath(), "-CetAbsolutePath(), "-v", dic.getAbsolutePath(), "-d", binlm.getAbsolutePath() };
ProgramLauncher launcher = new ProgramLauncher(cmd);
launcher.setStdoutStream(new Log.Stream());
launcher.setStderrStream(new Log.Stream("ERR>>"));
Log.verbose("julius: " + filelist.getName());
launcher.run();
Log.verbose("Done.");
if (launcher.getReturnValue() != 0)
throw new RuntimeException("Retval: " + launcher.getReturnValue());
}
public static void mkbingram(File model_bkwd, File binlm) throws RuntimeException {
String[] cmd = new String[] { Settings.julius_mklm_bin.getAbsolutePath(), "-nrl", model_bkwd.getAbtAbsolutePath() };
ProgramLauncher launcher = new ProgramLauncher(cmd);
launcher.setStdoutStream(new Log.Stream());
launcher.setStderrStream(new Log.Stream("ERR>>"));
Log.verbose("mkbingram: " + model_bkwd.getName() + " -> " + binlm.getName());
launcher.run();
Log.verbose("Done.");
if (launcher.getReturnValue() != 0)
throw new RuntimeException("Retval: " + launcher.getReturnValue());
}
public static Segmentation align(File sound, File text) throws IOException, RuntimeExceptnf = new File("julius_model/julius.jconf");
File scp = new File(Settings.temp_dir, "julius.scp");
File vocab = new File(Settings.temp_dir, "julius.voc");
File dict = new File(Settings.temp_dir, "julius.dic");
File model = new File(Settings.temp_dir, "julius.lm");
File text_b = new File(Settings.temp_dir, "julius_rev.txt");
File binlm = new File(Set
NGram.srilm_estimate(text_b, vocab, model, 3);
mk
```
<Overlap Ratio: 0.861863240018357>

---

--- 29 --
Question ID: 1b569ade89bcace5a09d197649bb5d25efd82337
Original Code:
```
public class StatePatternTest {

    /**
     * Main driver.
     * @param args arguments from command line
     */
    public static void main(String[] args) {
        Card pncCard = new Card(1005, 10000);
        AtmMachine atm = new AtmMachine();
        atm.insertCard(pncCard);
        atm.enterPin(1005);
        atm.checkBalance();
        atm.requestCash(1500);
        atm.ejectCard();
        System.out.println();
        atm.insertCard(pncCard);
        atm.enterPin(1005);
        atm.checkBalance();
        atm.requestCash(1500);
        atm.ejectCard();
    }
}

```


Overlapping Code:
```
ic class StatePatternTest {
/**
* Main driver.
* @param args arguments from command line
*/
public static void main(String[] args) {
Card pncCard = new Card(1005, 10000);
AtmMachine atm = new AtmMachine();
atm.insertCard(pncCard);
atm.enterPin(1005);
atm.checkBalance();
atm.requestCash(1500);
atm.ejectCard();
System.out.println();
atm.insertCard(pncCard);
atm.enterPin(1005);
atm.checkBalance();
atm.requestCash(1500);
atm.ejectCar
```
<Overlap Ratio: 0.9730337078651685>

---

--- 30 --
Question ID: 93ee8390b37253340129ea65b53a309a0aac8927
Original Code:
```
public class SequenceTest {

    public static void main(String[] args) {
        ExecutorService exec = Executors.newFixedThreadPool(100);
        ExecutorService exec1 = Executors.newFixedThreadPool(100);
        long startTime = System.currentTimeMillis();
        System.out.println("????:" + System.currentTimeMillis());
        Runnable runnable = new SequenceRunnable();
        int i = 0;
        while (i < 100) try {
            exec.submit(runnable);
            exec1.submit(runnable);
        } finally {
            i++;
        }
        System.out.println("???:" + (System.currentTimeMillis() - startTime));
        //?????
        exec.shutdown();
        exec1.shutdown();
    }
}

```


Overlapping Code:
```
blic class SequenceTest {
public static void main(String[] args) {
ExecutorService exec = Executors.newFixedThreadPool(100);
ExecutorService exec1 = Executors.newFixedThreadPool(100);
long startTime = System.currentTimeMillis();
System.out.println("
```
<Overlap Ratio: 0.453551912568306>

---

--- 31 --
Question ID: 1168d4b7c2a618ee1fa85e5a4e7400a4dc63922f
Original Code:
```
public class DialogShopCarAdapter extends BaseAdapter {

    private static final int FIRST = 0;

    private static final int SECOND = 1;

    private static final int COUNT = 2;

    private FunctionListActivity activity;

    private List<Quotation> data;

    private LayoutInflater mInflater;

    private DelOnClickListener delOnClickListener;

    private AddDelOnClickListener addDelOnClickListener;

    private ShopCarDialog dialog;

    public DialogShopCarAdapter(FunctionListActivity activity, ShopCarDialog dialog) {
        this.activity = activity;
        mInflater = LayoutInflater.from(activity);
        this.dialog = dialog;
        this.delOnClickListener = new DelOnClickListener();
        this.addDelOnClickListener = new AddDelOnClickListener();
    }

    public void setData(List<Quotation> data) {
        this.data = data;
    }

    public List<Quotation> getData() {
        return data;
    }

    @Override
    public int getCount() {
        return data == null ? 0 : data.size();
    }

    @Override
    public Object getItem(int position) {
        return null;
    }

    @Override
    public long getItemId(int position) {
        return 0;
    }

    @Override
    public int getItemViewType(int position) {
        if (data.get(position).type == 1) {
            return FIRST;
        } else {
            return SECOND;
        }
    }

    @Override
    public int getViewTypeCount() {
        return COUNT;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder holder;
        int type = getItemViewType(position);
        if (convertView == null) {
            holder = new ViewHolder();
            switch(type) {
                case FIRST:
                    convertView = mInflater.inflate(R.layout.list_shop_car_head_item, null);
                    holder.tv_head = (TextView) convertView.findViewById(R.id.tv_head);
                    holder.clearAll = convertView.findViewById(R.id.tv_clear);
                    holder.reset = convertView.findViewById(R.id.tv_reset);
                    holder.clearAll.setOnClickListener(clickClear);
                    holder.reset.setOnClickListener(clickReset);
                    break;
                case SECOND:
                    convertView = mInflater.inflate(R.layout.list_shop_car_item, null);
                    holder.tv_name = (TextView) convertView.findViewById(R.id.tv_name);
                    holder.ivAddCar = (ImageView) convertView.findViewById(R.id.iv_add_car);
                    holder.ivDelCar = (ImageView) convertView.findViewById(R.id.iv_del_car);
                    holder.tvNum = (TextView) convertView.findViewById(R.id.tv_num);
                    break;
            }
            convertView.setTag(holder);
        } else {
            holder = (ViewHolder) convertView.getTag();
        }
        Quotation quotation = data.get(position);
        switch(type) {
            case FIRST:
                String sectionTitle = String.format("%s . %d", quotation.title, quotation.getExtra().size());
                holder.tv_head.setText(sectionTitle);
                holder.clearAll.setTag(quotation);
                holder.reset.setTag(quotation);
                break;
            case SECOND:
                holder.tv_name.setText(quotation.title);
                if (quotation.title.equals("????")) {
                    holder.ivDelCar.setVisibility(View.VISIBLE);
                    holder.tvNum.setVisibility(View.VISIBLE);
                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_add);
                    holder.ivDelCar.setImageResource(R.mipmap.developer_car_cancle);
                    holder.tvNum.setText(activity.getNum() + "");
                    //???
                    holder.ivAddCar.setTag(R.id.action_type, 0);
                    holder.ivAddCar.setOnClickListener(addDelOnClickListener);
                    //???
                    holder.ivDelCar.setTag(R.id.action_type, 1);
                    holder.ivDelCar.setOnClickListener(addDelOnClickListener);
                } else {
                    holder.ivDelCar.setVisibility(View.GONE);
                    holder.tvNum.setVisibility(View.GONE);
                    holder.ivAddCar.setImageResource(R.mipmap.developer_car_picked);
                    holder.ivAddCar.setTag(quotation);
                    holder.ivAddCar.setOnClickListener(delOnClickListener);
                }
                break;
        }
        return convertView;
    }

    private class ViewHolder {

        TextView tv_head;

        View reset;

        View clearAll;

        TextView tv_name;

        ImageView ivAddCar;

        ImageView ivDelCar;

        TextView tvNum;
    }

    private View.OnClickListener clickClear = v -> {
        Quotation tag = (Quotation) v.getTag();
        activity.clearPickedFunction(tag);
        dialog.updateNum();
        notifyDataSetChanged();
    };

    private View.OnClickListener clickReset = v -> {
        Quotation tag = (Quotation) v.getTag();
        activity.resetPickedFunction(tag);
        dialog.updateNum();
        notifyDataSetChanged();
    };

    private class DelOnClickListener implements View.OnClickListener {

        @Override
        public void onClick(View v) {
            Quotation quotation = (Quotation) v.getTag();
            if (quotation.isRadioItem()) {
                return;
            }
            int pos = data.indexOf(quotation);
            if (pos != -1) {
                data.remove(quotation);
                Quotation platform = null;
                int i = pos - 1;
                while (i >= 0) try {
                    Quotation quotation1 = data.get(i);
                    if (quotation1.isPlatform()) {
                        platform = quotation1;
                        break;
                    }
                } finally {
                    --i;
                }
                if (platform != null) {
                    platform.getExtra().remove(quotation);
                }
                dialog.updateNum();
                notifyDataSetChanged();
            }
        }
    }

    private class AddDelOnClickListener implements View.OnClickListener {

        @Override
        public void onClick(View v) {
            int type = (int) v.getTag(R.id.action_type);
            switch(type) {
                case 0:
                    {
                        int num = activity.getNum();
                        num++;
                        activity.setNum(num);
                        dialog.updateNum();
                        notifyDataSetChanged();
                    }
                    break;
                case 1:
                    {
                        int num = activity.getNum();
                        if (num < 1) {
                            return;
                        }
                        num--;
                        activity.setNum(num);
                        dialog.updateNum();
                        notifyDataSetChanged();
                    }
                    break;
            }
        }
    }
}

```


Overlapping Code:
```
rAdapter extends BaseAdapter {
private static final int FIRST = 0;
private static final int SECOND = 1;
private static final int COUNT = 2;
private FunctionListActivity activity;
private List<Quotation> data;
private LayoutInflater mInflater;
private DelOnClickListener delOnClickListener;
private AddDelOnClickListener addDelOnClickListener;
private ShopCarDialog dialog;
public DialogShopCarAdapter(FunctionListActivity activity, ShopCarDialog dialog) {
this.activity = activity;
mInflater = LayoutInflater.from(activity);
this.dialog = dialog;
this.delOnClickListener = new DelOnClickListener();
this.addDelOnClickListener = new AddDelOnClickListener();
}
public void setData(List<Quotation> data) {
this.data = data;
}
public List<Quotation> getData() {
return data;
}
@Override
public int getCount() {
return data == null ? 0 : data.size();
}
@Override
public Object getItem(int position) {
return null;
}
@Override
public long getItemId(int position) {
return 0;
}
@Override
public int getItemViewType(int position) {
if (data.get(position).type == 1) {
return FIRST;
} else {
return SECOND;
}
}
@Override
public int getViewTypeCount() {
return COUNT;
}
@Override
public View getView(int position, View convertView, ViewGroup parent) {
ViewHolder holder;
int type = getItemViewType(position);
if (convertView == null) {
holder = new ViewHolder();
switchtype) {
case FIRST:
convertView = mInflater.inflate(R.layout.list_shop_car_head_item, null);
holder.tv_head = (TextView) convertView.findViewById(R.id.tv_head);
holder.clearAll = convertView.findViewById(R.id.tv_clear);
holder.reset = convertView.findViewById(R.id.tv_reset);
holder.clearAll.setOnClickListener(clickClear);
holder.reset.setOnClickListener(clickReset);
break;
case SECOND:
convertView = mInflater.inflate(R.layout.list_shop_car_item, null);
holder.tv_name = (TextView) convertView.findViewById(R.id.tv_name);
holder.ivAddCar = (ImageV
```
<Overlap Ratio: 0.9855446566855963>

---

--- 32 --
Question ID: 2b46d2e3610792acb1ccf25a6d577dfc0881f980
Original Code:
```
public class URLClassLoader extends SecureClassLoader {

    URL[] urls;

    ClassLoaderURLHandler[] handlers;

    private static boolean verbose = false;

    private static void debug(String s) {
        if (verbose) {
            System.err.println(s);
        }
    }

    private static final Manifest emptyMan = new Manifest();

    private static void permissionCheck() {
        // Note: we assume that java.net is a restricted package.
        if (wonka.vm.SecurityConfiguration.ENABLE_SECURITY_CHECKS) {
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkPackageAccess("java.net");
            }
        }
    }

    public URLClassLoader(URL[] urls) throws SecurityException {
        debug("Loading: create URL handlers for " + this);
        handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);
        this.urls = urls;
    }

    public URLClassLoader(URL[] urls, ClassLoader parent) throws SecurityException {
        super(parent);
        debug("Loading: create URL handlers for " + this);
        handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);
        this.urls = urls;
    }

    public URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) throws SecurityException {
        super(parent);
        debug("Loading: create URL handlers for " + this);
        handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);
        this.urls = urls;
    }

    public static URLClassLoader newInstance(final URL[] urls) throws SecurityException {
        permissionCheck();
        //TODO: do as a privileged action
        return new URLClassLoader(urls);
    }

    public static URLClassLoader newInstance(final URL[] urls, ClassLoader parent) throws SecurityException {
        permissionCheck();
        //TODO: do as a privileged action
        return new URLClassLoader(urls, parent);
    }

    protected void addURL(URL url) {
        debug("Loading: add URL handler to " + this);
        ClassLoaderURLHandler handler = ClassLoaderURLHandler.createClassLoaderURLHandler(url);
        debug("Loading: new URL handler = " + handler);
        int length = handlers.length;
        ClassLoaderURLHandler[] newhandlers = new ClassLoaderURLHandler[length + 1];
        System.arraycopy(handlers, 0, newhandlers, 0, length);
        newhandlers[length] = handler;
        handlers = newhandlers;
        URL[] newurls = new URL[urls.length + 1];
        System.arraycopy(urls, 0, newurls, 0, urls.length);
        newurls[urls.length] = url;
        urls = newurls;
    }

    protected Package definePackage(String pname, Manifest man, URL url) throws IllegalArgumentException {
        Attributes attr = man.getMainAttributes();
        String specTitle = attr.getValue("Specification-Title");
        String specVersion = attr.getValue("Specification-Version");
        String specVendor = attr.getValue("Specification-Vendor");
        String implTitle = attr.getValue("Implementation-Title");
        String implVersion = attr.getValue("Implementation-Version");
        String implVendor = attr.getValue("Implementation-Vendor");
        return definePackage(pname, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor, url);
    }

    protected Class findClass(String name) throws ClassNotFoundException {
        String filename = name.replace('.', '/') + ".class";
        int l = handlers.length;
        int i = 0;
        while (i < l) try {
            ClassLoaderURLHandler handler = handlers[i];
            byte[] bytes = handler.getByteArray(filename);
            if (bytes != null) {
                URL url = urls[i];
                int idx = name.lastIndexOf('.');
                String pname = name.substring(0, idx == -1 ? 0 : idx);
                // TODO: get manifest right
                if (getPackage(pname) == null) {
                    definePackage(pname, handler.getManifest(), url);
                }
                if (url.getProtocol().equals("jar")) {
                    String u = ("" + url).substring(4);
                    u = u.substring(0, u.indexOf('!'));
                    try {
                        url = new URL(u);
                    } catch (Exception e) {
                    }
                }
                return defineClass(name, bytes, 0, bytes.length, new CodeSource(url, (java.security.cert.Certificate[]) null));
            }
        } finally {
            i++;
        }
        throw new ClassNotFoundException(name);
    }

    public URL findResource(String name) {
        int l = handlers.length;
        int i = 0;
        while (i < l) try {
            ClassLoaderURLHandler handler = handlers[i];
            URL url = handler.getURL(name);
            if (url != null) {
                return url;
            }
        } finally {
            i++;
        }
        return null;
    }

    public Enumeration findResources(String name) throws IOException {
        // TODO; wasn't there something about leading slash?
        int l = handlers.length;
        Vector v = new Vector(l);
        int i = 0;
        while (i < l) try {
            ClassLoaderURLHandler handler = handlers[i];
            URL url = handler.getURL(name);
            if (url != null) {
                v.add(url);
            }
        } finally {
            i++;
        }
        return v.elements();
    }

    protected PermissionCollection getPermissions(CodeSource codes) {
        PermissionCollection pc = super.getPermissions(codes);
        //ToDo add extra permissions to allow usage of the URL's
        return pc;
    }

    /**
     * * returns a clone of the original URL array (for securiry reasons).
     */
    public URL[] getURLs() {
        return (URL[]) urls.clone();
    }
}

```


Overlapping Code:
```
lic class URLClassLoader extends SecureClassLoaderRLHandler[] handlers;
private static boolean verbose = false;
private static void debug(String s) {
if (verbose) {
System.err.println(s);
}
}
private static final Manifest emptyMan = new Manifest();
private static void permissionCheck() {
// Note: we assume that java.net is a restricted package.
if (wonka.vm.SecurityConfiguration.ENABLE_SECURITY_CHECKS) {
SecurityManager sm = System.getSecurityManager();
if (sm != null) {
sm.checkPackageAccess("java.net");
}
}
}
public URLClassLoader(URL[] urls) throws SecurityException {
debug("Loading: create URL handlers for " + this);
handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);
this.urls = urls;
}
public URLClassLoader(URL[] urls, ClassLoader parent) throws SecurityException {
super(parent);
debug("Loading: create URL handlers for " + this);
handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);
this.urls = urls;
}
public URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) throws SecurityException {
super(parent);
debug("Loading: create URL handlers for " + this);
handlers = ClassLoaderURLHandler.createClassLoaderURLHandlers(urls);
this.urls = urls;
}
public static URLClassLoader newInstance(final URL[] urls) throws SecurityExc
permissionCheck();
//TODO: do as a privileged action
return new URLClassLoader(urls);
}
public static URLClassLoader newInstance(final URL[] urls,
permissionCheck();
//TODO: do as a privileged action
return new URLClassLoader(urls, parent);
}
proRL handler to " + this);
ClassLoaderURLHandler handler = ClassLoaderURLHandler.createClassLoaderURLHandler(url);
debug("Loading: new URL handler = " + handler);
int length = handlers.length;
ClassLoaderURLHandler[] newhandlers = new ClassLoaderURLHanandlers, 0, length);
newhandlers[length] = handler;
handlers = newhandlers;
URL[] newurls = new URL[
```
<Overlap Ratio: 0.9041944709246902>

---

--- 33 --
Question ID: 0258fec1fbbbd04e532d61c0a501cd3898fe0f43
Original Code:
```
public class MockXDSBridge extends XDSBridge {

    /**
     * Constructs ...
     *
     * @param config
     */
    public MockXDSBridge(XDSBridgeServiceContext config) {
        super();
        XDSBridge.serviceContext = config;
    }

    /**
     * Method description
     *
     * @param service_name
     * @param request
     *
     * @return
     *
     * @throws AxisFault
     */
    @Override
    protected void beginTransaction(String service_name, OMElement request) throws SOAPFaultException {
        String remoteIP = "127.0.0.2";
        XLogger xlogger = XLogger.getInstance();
        log_message = xlogger.getNewMessage(remoteIP);
        log_message.setTestMessage("TEST");
    }

    /**
     * Method description
     *
     * @return
     */
    @Override
    protected MessageContext getCurrentMessageContext() {
        return new MockMessageContext();
    }
}

```


Overlapping Code:
```
blic class MockXDSBridge extends XDSBridge {
/**
*XDSBridge(XDSBridgeServiceContext config) {
super();
XDSBridge.serviceContext = config;
}
/**
* Methrequest
*
* @return
*
* @throws AxisFault
*/
@Override
protected void beginTransaction(String servicon {
String remoteIP = "127.0.0.2";
XLogger xlogger = XLogger.getInstance();
log_message = xlogger.getNewMessage(remoteIP);
log_message.setTestMessage
*/
@Override
protected MessageContext getCurrentMessageContext() {
return new MockMessageContext();
```
<Overlap Ratio: 0.7142857142857143>

---

--- 34 --
Question ID: 12c6b162778cfc33f04b38dd1d9c10eacd9db16e
Original Code:
```
public class LocalBoundary {

    private static final int MAX_LOCAL_SEGS = 8;

    private static class Segment {

        /**
         * Segment start/end
         */
        float[] s = new float[6];

        /**
         * Distance for pruning.
         */
        float d;
    }

    float[] m_center = new float[3];

    List<Segment> m_segs = new ArrayList<>();

    List<Long> m_polys = new ArrayList<>();

    protected LocalBoundary() {
        m_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;
    }

    protected void reset() {
        m_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;
        m_polys.clear();
        m_segs.clear();
    }

    protected void addSegment(float dist, float[] s) {
        // Insert neighbour based on the distance.
        Segment seg = new Segment();
        System.arraycopy(s, 0, seg.s, 0, 6);
        seg.d = dist;
        if (m_segs.isEmpty()) {
            m_segs.add(seg);
        } else if (dist >= m_segs.get(m_segs.size() - 1).d) {
            if (m_segs.size() >= MAX_LOCAL_SEGS) {
                return;
            }
            m_segs.add(seg);
        } else {
            // Insert inbetween.
            int i;
            for (i = 0; i < m_segs.size(); ++i) if (dist <= m_segs.get(i).d)
                break;
            m_segs.add(i, seg);
        }
        for (; m_segs.size() > MAX_LOCAL_SEGS; ) {
            m_segs.remove(m_segs.size() - 1);
        }
    }

    public void update(long ref, float[] pos, float collisionQueryRange, NavMeshQuery navquery, QueryFilter filter) {
        if (ref == 0) {
            reset();
            return;
        }
        vCopy(m_center, pos);
        // First query non-overlapping polygons.
        FindLocalNeighbourhoodResult res = navquery.findLocalNeighbourhood(ref, pos, collisionQueryRange, filter);
        this.m_polys = res.getRefs();
        m_segs.clear();
        // Secondly, store all polygon edges.
        for (int j = 0; j < m_polys.size(); ++j) {
            GetPolyWallSegmentsResult gpws = navquery.getPolyWallSegments(m_polys.get(j), false, filter);
            for (int k = 0; k < gpws.getSegmentRefs().size(); ++k) {
                float[] s = gpws.getSegmentVerts().get(k);
                // Skip too distant segments.
                Tupple2<Float, Float> distseg = distancePtSegSqr2D(pos, s, 0, 3);
                if (distseg.first > sqr(collisionQueryRange))
                    continue;
                addSegment(distseg.first, s);
            }
        }
    }

    public boolean isValid(NavMeshQuery navquery, QueryFilter filter) {
        if (m_polys.isEmpty())
            return false;
        // Check that all polygons still pass query filter.
        for (long ref : m_polys) {
            if (!navquery.isValidPolyRef(ref, filter))
                return false;
        }
        return true;
    }

    public float[] getCenter() {
        return m_center;
    }

    public float[] getSegment(int j) {
        return m_segs.get(j).s;
    }

    public int getSegmentCount() {
        return m_segs.size();
    }
}

```


Overlapping Code:
```
ndary {
private static final int MAX_LOCAL_SEGS = oat[3];
List<Segment> m_segs = new ArrayList<>();
List<Long> m_polys = new ArrayList<>();
protected LocalBoundary() {
m_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;
}
protected void reset() {
m_center[0] = m_center[1] = m_center[2] = Float.MAX_VALUE;
m_polys.clear();
m_segs.clear();
}
protected void addSegment(float dist, float[] s) {
// Insert neighbour based on the distance.
Segment seg = new Segment();
System.arraycopy(s, 0, seg.s, 0, 6);
seg.d = dist;
if (m_segs.isEmpty()) {
m_segs.add(seg);
} else if (dist >= m_segs.get(m_segs.size() - 1).d) {
if (m_segs.size() >= MAX_LOCAL_SEGS) {
return;
}
m_segs.add(seg);
} else {
// Insert inbetween.
int i;
for (i = 0; i < m_segs.size();void update(long ref, float[] pos, float collisionQueryRange, NavMeshQuery navquery, QueryFilter filter) {
if (ref == 0) {
reset();
return;
}
vCopy(m_center, pos);
// First query non-overlapping polygons.
FindLocalNeighbourhoodResult res = navquery.findLocalNeighbourhood(ref, pos, collisionQueryRange, filter);
this.m_polys = res.getRefs();
m_segs.clear();
// Secondly, store all polygon edges.
for (int j = 0; j < m_polys.size(); ++j) {
GetPolyWallSegmentsResult gpws = navquery.getPolyWallSegments(m_polys.get(j), false, filter);
for (int k = 0; k < gpws.getSegmentRefs().size(); ++k) {
float[] s = gpws.getSegmentVerts().get(k);
// Skip too distant segments.
Tupple2<Float, Float> distseg = distancePtSegSqr2D(pos, s, 0, 3);
if (distseg.first > sqr(collisionQueryRange))
continue;
addSegment(dist
```
<Overlap Ratio: 0.819672131147541>

---

--- 35 --
Question ID: f416cf9485d12f7d7cc768a7e123b492cfdebc32
Original Code:
```
public class S3AReadOpContext extends S3AOpContext {

    /**
     * Path of read.
     */
    private final Path path;

    /**
     * Initial input policy of the stream.
     */
    private S3AInputPolicy inputPolicy;

    /**
     * How to detect and deal with the object being updated during read.
     */
    private ChangeDetectionPolicy changeDetectionPolicy;

    /**
     * Readahead for GET operations/skip, etc.
     */
    private long readahead;

    private AuditSpan auditSpan;

    /**
     * Threshold for stream reads to switch to
     * asynchronous draining.
     */
    private long asyncDrainThreshold;

    /**
     * Instantiate.
     * @param path path of read
     * @param invoker invoker for normal retries.
     * @param stats Fileystem statistics (may be null)
     * @param instrumentation statistics context
     * @param dstFileStatus target file status
     */
    public S3AReadOpContext(final Path path, Invoker invoker, @Nullable FileSystem.Statistics stats, S3AStatisticsContext instrumentation, FileStatus dstFileStatus) {
        super(invoker, stats, instrumentation, dstFileStatus);
        this.path = requireNonNull(path);
    }

    /**
     * validate the context.
     * @return a read operation context ready for use.
     */
    public S3AReadOpContext build() {
        requireNonNull(inputPolicy, "inputPolicy");
        requireNonNull(changeDetectionPolicy, "changeDetectionPolicy");
        requireNonNull(auditSpan, "auditSpan");
        requireNonNull(inputPolicy, "inputPolicy");
        Preconditions.checkArgument(readahead >= 0, "invalid readahead %d", readahead);
        Preconditions.checkArgument(asyncDrainThreshold >= 0, "invalid drainThreshold %d", asyncDrainThreshold);
        return this;
    }

    /**
     * Get invoker to use for read operations.
     * @return invoker to use for read codepaths
     */
    public Invoker getReadInvoker() {
        return invoker;
    }

    /**
     * Get the path of this read.
     * @return path.
     */
    public Path getPath() {
        return path;
    }

    /**
     * Get the IO policy.
     * @return the initial input policy.
     */
    public S3AInputPolicy getInputPolicy() {
        return inputPolicy;
    }

    public ChangeDetectionPolicy getChangeDetectionPolicy() {
        return changeDetectionPolicy;
    }

    /**
     * Get the readahead for this operation.
     * @return a value {@literal >=} 0
     */
    public long getReadahead() {
        return readahead;
    }

    /**
     * Get the audit which was active when the file was opened.
     * @return active span
     */
    public AuditSpan getAuditSpan() {
        return auditSpan;
    }

    /**
     * Set builder value.
     * @param value new value
     * @return the builder
     */
    public S3AReadOpContext withInputPolicy(final S3AInputPolicy value) {
        inputPolicy = value;
        return this;
    }

    /**
     * Set builder value.
     * @param value new value
     * @return the builder
     */
    public S3AReadOpContext withChangeDetectionPolicy(final ChangeDetectionPolicy value) {
        changeDetectionPolicy = value;
        return this;
    }

    /**
     * Set builder value.
     * @param value new value
     * @return the builder
     */
    public S3AReadOpContext withReadahead(final long value) {
        readahead = value;
        return this;
    }

    /**
     * Set builder value.
     * @param value new value
     * @return the builder
     */
    public S3AReadOpContext withAuditSpan(final AuditSpan value) {
        auditSpan = value;
        return this;
    }

    /**
     * Set builder value.
     * @param value new value
     * @return the builder
     */
    public S3AReadOpContext withAsyncDrainThreshold(final long value) {
        asyncDrainThreshold = value;
        return this;
    }

    public long getAsyncDrainThreshold() {
        return asyncDrainThreshold;
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("S3AReadOpContext{");
        sb.append("path=").append(path);
        sb.append(", inputPolicy=").append(inputPolicy);
        sb.append(", readahead=").append(readahead);
        sb.append(", changeDetectionPolicy=").append(changeDetectionPolicy);
        sb.append('}');
        return sb.toString();
    }
}

```


Overlapping Code:
```
c class S3AReadOpContext extends S3AOpContext {
/**
* Path of read.
*/
private final Path path;
/**
* Initial input policy of the stream.
*/
private S3AInputPolicy inputPolicy;
/**
* How to detect and deal with the object being updated during read.
*/
private ChangeDetectionPolicy changeDetectionPolicy;
/**
* Readahead for GET operations/skip, etc.
*/
private long readahead;
private AuditSpan auditSpan;
/**
* Threshold for stream reads to switch to
* asynchronous draining.
*/
private long asyncDrainThreshold;
/**
* Instantiate.
* @param path path of read
* @param invoker invoker for normal retries.
* @param stats Fileystem statistics (may be null)
* @param instrumentation statistics context
* @param dstFileStatus target file status
*/
public S3AReadOpC;
this.path = requireNonNull(path);
}
/**
* validate the context.
* @return a read operation context ready for use.
*/
public S3AReadOpContext build() {
requireNonNull(inputPolicy, "inputPolicy");
requireNonNull(changeDetectionPolicy, "changeDetectionPolicy");
requireNonNull(auditSpan, "auditSpan");
requireNonNull(inputPolicy, "inputPolicy");
Precoadahead %d", readahead);
Preconditions.checkArgumeld %d", asyncDrainThreshold);
return this;
}
/**
* Get invoker to use for read operations.
* @return invoker to use for read codepaths
*/
public Invoker getReadInvoker() {
return invoker;
}
/**
* Get the path of this read.
* @return path.
*/
public Path getPath() {
return path;
}
/**
* Get the IO policy.
* @return the initial input policy.
*/
public S3AInputPolicy getInputPolicy() {
return inputPolicy;
}
public ChangeDetectionPolicy getChangeDetectionPolicy() {
return changeDetectionPolicy;
}
/**
* Get the readahead for this operation.
* @return a value {@literal >=} 0
*/
public long getReadah
```
<Overlap Ratio: 0.8434657730971756>

---

--- 36 --
Question ID: b08f107779d239c4b7d57ae1d699871248d132d2
Original Code:
```
public class OpenJPAJpaEntityLifecycleInjector implements JpaEntityLifecycleInjector {

    private class OpenJPAEventListener extends AbstractDeviceJpaEntityListener implements DeleteListener, PersistListener, StoreListener {

        private JpaGpsDevice device;

        public OpenJPAEventListener(JpaGpsDevice device) {
            this.device = device;
        }

        @Override
        protected JpaGpsDevice getDevice() {
            return this.device;
        }

        public void beforeDelete(LifecycleEvent lifecycleEvent) {
        }

        public void afterDelete(LifecycleEvent lifecycleEvent) {
            postRemove(lifecycleEvent.getSource());
        }

        public void beforePersist(LifecycleEvent lifecycleEvent) {
        }

        public void afterPersist(LifecycleEvent lifecycleEvent) {
            postPersist(lifecycleEvent.getSource());
        }

        public void beforeStore(LifecycleEvent lifecycleEvent) {
        }

        public void afterStore(LifecycleEvent lifecycleEvent) {
            postUpdate(lifecycleEvent.getSource());
        }
    }

    private boolean useSpecificClassEvents = true;

    private ClassLoader classLoader;

    private Object eventListener;

    public void setUseSpecificClassEvents(boolean useSpecificClassEvents) {
        this.useSpecificClassEvents = useSpecificClassEvents;
    }

    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
    }

    /**
     * Allows to directly inject the event listener that will be used with Open JPA. Will
     * not use Compass default one ({@link org.compass.gps.device.jpa.lifecycle.OpenJPAJpaEntityLifecycleInjector.OpenJPAEventListener}.
     */
    public void setEventListener(Object eventListener) {
        this.eventListener = eventListener;
    }

    public boolean requireRefresh() {
        return true;
    }

    public void injectLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {
        CompassGpsInterfaceDevice gps = (CompassGpsInterfaceDevice) device.getGps();
        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0
        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);
        if (eventListener == null) {
            eventListener = new OpenJPAEventListener(device);
        }
        if (useSpecificClassEvents) {
            ArrayList<Class> matchedClasses = new ArrayList<Class>();
            Collection<Class> classes = emf.getConfiguration().getMetaDataRepositoryInstance().loadPersistentTypes(true, classLoader);
            for (Class clazz : classes) {
                ClassMetaData classMetaData = emf.getConfiguration().getMetaDataRepositoryInstance().getMetaData(clazz, classLoader, true);
                Class mappedClass = classMetaData.getDescribedType();
                if (gps.hasMappingForEntityForMirror(mappedClass, Cascade.ALL)) {
                    matchedClasses.add(mappedClass);
                }
            }
            if (matchedClasses.size() > 0) {
                emf.addLifecycleListener(eventListener, matchedClasses.toArray(new Class[0]));
            }
        } else {
            emf.addLifecycleListener(eventListener);
        }
    }

    public void removeLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {
        // TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0
        EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);
        eventListener = new OpenJPAEventListener(device);
        emf.removeLifecycleListener(eventListener);
    }
}

```


Overlapping Code:
```
JPAJpaEntityLifecycleInjector implements JpaEntityLifecycleInjector {
private class OpenJPAEventListener extends AbstractDeviceJpaEntityListener implements DeleteListener, PersistListener, StoreListener {
private JpaGpsDevice device;
public OpenJPAEventListener(JpaGpsDevice device) {
this.device = device;
}
@Override
protected JpaGpsDevice getDevice() {
return this.device;
}
public void beforeDelete(LifecycleEvent lifecycleEvent) {
}
public void afterDelete(LifecycleEvent lifecycleEvent) {
postRemove(lifecycleEvent.getSource());
}
public void beforePersist(LifecycleEvent lifecycleEvent) {
}
public void afterPersist(LifecycleEvent lifecycleEvent) {
postPersist(lifecycleEvent.getSource());
}
public void beforeStore(LifecycleEvent lifecycleEvent) {
}
public void afterStore(LifecycleEvent lifecycleEvent) {
postUpdate(lifecycleEvent.getSource());
}
}
private boolean useSpecificClassEvents = true;
private ClassLoader classLoader;
private Object eventListener;
public void setUseSpecificClassEvents(boolean useSpecificClassEvents) {
this.useSpecificClassEvents = useSpecificClassEvents;
}
public void setClassLoader(ClassLoader classLoader) {
this.classLoader = classLoader;
}
/**
* Allows to directly inject the event listener that will be used with Open JPA. Will
* not use Compass default one ({@link org.compass.gps.device.jpa.lifecycle.OpenJPAJpaEntityLifecycleInjector.OpenJPAEventListener}.
*/
public void setEventListener(Object eventListener) {
this.eventListener = eventListener;
}
public boolean requireRefresh() {
return true;
}
public void injectLifecycle(EntityManagerFactory entityManagerFactory, JpaGpsDevice device) throws JpaGpsDeviceException {
CompassGpsInterfaceDevice gps = (CompassGpsInterfaceDevice) device.getGps();
// TODO this should use OpenJPAEnitiyManagerFactorySPI, here for backward compatability with pre 1.0
EntityManagerFactoryImpl emf = (EntityManagerFactoryImpl) OpenJPAPersistence.cast(entityManagerFactory);
if (eventListener == null) {
eventListener = new OpenJPAEventListener(device);
}
if (useSpecific
```
<Overlap Ratio: 0.9771210676835081>

---

--- 37 --
Question ID: 8c883a23ce2238926cc5819852b763dc95f1d839
Original Code:
```
public class NumFilter implements Filter {

    @Override
    public boolean doFilter(Msg msg) {
        String msg1 = msg.getMsg();
        String num = msg1.replace("123", "num");
        msg.setMsg(num);
        return true;
    }
}

```


Overlapping Code:
```
ublic class NumFilter implements Filter {
@Override
public boolean doFilter(Msg msg) {
String msg1 = msg.getMsg();
String num = msg1.replace("123", "n
```
<Overlap Ratio: 0.7894736842105263>

---

--- 38 --
Question ID: ff542139117e2ec97abdccaa834b9817bd33a05d
Original Code:
```
public class DBController {

    private static final String DB_NAME = "fruits_db.db";

    private DaoMaster.DevOpenHelper mHelpler;

    private SQLiteDatabase mDb;

    private DaoMaster mDaoMaster;

    private DaoSession mDaoSession;

    private Context mContext;

    private UserDao mUserDao;

    private HistoryDao mHistoryDao;

    private CollectionDao mCollectionDao;

    private QuickDao mQuickDao;

    private static DBController sDbController;

    public static DBController getInstance(Context context) {
        if (sDbController == null) {
            synchronized (DBController.class) {
                if (sDbController == null) {
                    sDbController = new DBController(context);
                }
            }
        }
        return sDbController;
    }

    public DBController(Context context) {
        mContext = context;
        mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);
        mDaoMaster = new DaoMaster(getWrittableDatabase());
        mDaoSession = mDaoMaster.newSession();
        mUserDao = mDaoSession.getUserDao();
        mHistoryDao = mDaoSession.getHistoryDao();
        mCollectionDao = mDaoSession.getCollectionDao();
        mQuickDao = mDaoSession.getQuickDao();
    }

    private SQLiteDatabase getWrittableDatabase() {
        if (mHelpler == null) {
            mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);
        }
        mDb = mHelpler.getWritableDatabase();
        return mDb;
    }

    public long insertUser(User user) {
        return mUserDao.insert(user);
    }

    public User checkUserAndPassword(String whereUser, String wherePassword) {
        User user = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(whereUser), UserDao.Properties.Password.eq(wherePassword)).build().unique();
        return user;
    }

    public boolean checkUserExist(String whereUser) {
        List<User> users = (List<User>) mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(whereUser)).build().list();
        return !users.isEmpty();
    }

    public void insertHistory(List<History> histories) {
        int i = 0;
        while (i < histories.size()) try {
            List<History> res = mHistoryDao.queryBuilder().where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()), HistoryDao.Properties.Time.eq(histories.get(i).getTime())).build().list();
            if (res == null || res.isEmpty()) {
                mHistoryDao.insert(histories.get(i));
            } else {
                mHistoryDao.queryBuilder().where(HistoryDao.Properties.Url.eq(histories.get(i).getUrl()), HistoryDao.Properties.Time.eq(histories.get(i).getTime())).buildDelete().executeDeleteWithoutDetachingEntities();
                mHistoryDao.insert(histories.get(i));
            }
        } finally {
            i++;
        }
    }

    public void deleteAllHistory() {
        mHistoryDao.deleteAll();
    }

    public void deleteSelectedHistory(List<History> historiesToBeDeleted) {
        if (mDb.isOpen()) {
            try {
                mDb.beginTransaction();
                int i = 0;
                while (i < historiesToBeDeleted.size()) try {
                    mHistoryDao.queryBuilder().where(HistoryDao.Properties.Url.eq(historiesToBeDeleted.get(i).getUrl()), HistoryDao.Properties.Time.eq(historiesToBeDeleted.get(i).getTime())).buildDelete().executeDeleteWithoutDetachingEntities();
                } finally {
                    i++;
                }
                mDb.setTransactionSuccessful();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                mDb.endTransaction();
            }
        }
    }

    public List<History> getAll() {
        List<History> all = (List<History>) mHistoryDao.queryBuilder().build().list();
        return all;
    }

    public List<Collection> getUserCollection(String username) {
        List<Collection> res = mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(username)).build().list();
        return res;
    }

    public void addCollection(String username, String url, String title) {
        List<Collection> exist = mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(username), CollectionDao.Properties.Url.eq(url), CollectionDao.Properties.Title.eq(title)).build().list();
        if (exist == null || exist.isEmpty()) {
            mCollectionDao.insert(new Collection(username, url, title));
        } else {
            return;
        }
    }

    public void deleteAllCollection(String username) {
        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(username)).buildDelete().executeDeleteWithoutDetachingEntities();
    }

    public void deleteSelectedCollection(List<Collection> toBeDeleted) {
        if (mDb.isOpen()) {
            try {
                mDb.beginTransaction();
                int i = 0;
                while (i < toBeDeleted.size()) try {
                    mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(toBeDeleted.get(i).getName()), CollectionDao.Properties.Url.eq(toBeDeleted.get(i).getUrl()), CollectionDao.Properties.Title.eq(toBeDeleted.get(i).getTitle())).buildDelete().executeDeleteWithoutDetachingEntities();
                } finally {
                    i++;
                }
                mDb.setTransactionSuccessful();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                mDb.endTransaction();
            }
        }
    }

    public void changeUsername(String name, String newName) {
        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();
        if (findUser != null) {
            findUser.setCustomizeName(newName);
            mUserDao.update(findUser);
        }
    }

    public String getProfile(String name) {
        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();
        return findUser.getProfile();
    }

    public void setProfile(String name, String profile) {
        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();
        if (findUser != null) {
            findUser.setProfile(profile);
            mUserDao.update(findUser);
        }
    }

    public void changePassword(String name, String newPassword) {
        User findUser = mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).build().unique();
        if (findUser != null) {
            findUser.setPassword(newPassword);
            mUserDao.update(findUser);
        }
    }

    public void deleteUser(String name) {
        mCollectionDao.queryBuilder().where(CollectionDao.Properties.Name.eq(name)).buildDelete().executeDeleteWithoutDetachingEntities();
        mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(name)).buildDelete().executeDeleteWithoutDetachingEntities();
    }

    public boolean insertQuick(String title, String url) {
        Quick quick = new Quick(null, title, url);
        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title), QuickDao.Properties.Url.eq(url)).build().unique();
        if (res != null) {
            return false;
        } else {
            mQuickDao.insert(quick);
            return true;
        }
    }

    public List<Quick> getQuick() {
        return mQuickDao.loadAll();
    }

    public void deleteQuick(String title, String url) {
        mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title), QuickDao.Properties.Url.eq(url)).buildDelete().executeDeleteWithoutDetachingEntities();
    }

    public void changeQuick(String title, String url, String newTitle, String newUrl) {
        Quick res = mQuickDao.queryBuilder().where(QuickDao.Properties.Title.eq(title), QuickDao.Properties.Url.eq(url)).build().unique();
        res.setTitle(newTitle);
        res.setUrl(newUrl);
        mQuickDao.update(res);
    }
}

```


Overlapping Code:
```
 class DBController {
private static final String DB_NAME = "fruits_db.db";
private DaoMaster.DevOpenHelper mHelpler;
private SQLiteDatabase mDb;
private DaoMaster mDaoMaster;
private DaoSession mDaoSession;
private Context mContext;
private UserDao mUserDao;
private HistoryDao mHistoryDao;
private CollectionDao mCollectionDao;
private QuickDao mQuickDao;
private static DBController sDbController;
public static DBController getInstance(Context context) {
if (sDbController(sDbController == null) {
sDbController = new DBController(context);
}
}
}
return sDbController;
}
public DBController(Context context) {
mContext = context;
mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);
mDaoMaster = new DaoMaster(getWrittableDatabase());
mDaoSession = mDaoMaster.newSession();
mUserDao = mDaoSession.getUserDao();
mHistoryDao = mDaoSession.getHistoryDao();
mCollectionDao = mDaoSession.getCollectionDao();
mQuickDao = mDaoSession.getQuickDao();
}
private SQLiteDatabase getWrittableDatabase() {
if (mHelpler == null) {
mHelpler = new DaoMaster.DevOpenHelper(mContext, DB_NAME, null);
}
mDb = mHelpler.getWritableDatabase();
return mDb;
}
public long insertUser(User user) {
return mUserDao.insert(user);
}
public User checkUserAndPassword(String whereUser, String wherePassword) {
User user = mUserDao.queryBuilder().where(UserDao.Properties.Name.eqUserDao.Properties.Password.eq(wherePassword)).build().unique();
return user;
}
public boolean check mUserDao.queryBuilder().where(UserDao.Properties.Name.eq(whereUser)).build().list();
return !users.isEmpty();
}
public void insertHistory(Lo.queryBuilder().where(HistoryDao.Properties.Url.eist();
if (res == null || res.isEmpty()) {
mHistor
```
<Overlap Ratio: 0.8226196230062832>

---

--- 39 --
Question ID: f56c1a6cd5b055c9b2e29a48257b31e8faab04f5
Original Code:
```
class Main {

    public static void main(String[] args) {
        ArrayList<String> input = new ArrayList<String>();
        input.add("Hello");
        input.add("World!");
        Executor<String> executor = new Executor<String>(new Day0Solution(), input);
        executor.run(args);
    }
}

```


Overlapping Code:
```
class Main {
public static void main(String[] args) {
ArrayList<String> input = new ArrayList<String>();
input.add("Hello");
input.add("World!");
Executor<String> executor = new Executor<String>(new Day
```
<Overlap Ratio: 0.8211382113821138>

---

--- 40 --
Question ID: be1bff23924fd033faba7e753f5dc995c667f3c0
Original Code:
```
class ThreadLocalVersionHolderTest {

    private final Version version = Version.of(1324, 5);

    private final Version localVersion = Version.of(345465, 435);

    @Test
    void testGetVersionInSameThread() {
        ThreadLocalVersionHolder.initialize(version);
        assertEquals(version, ThreadLocalVersionHolder.get().getVersion());
    }

    @Test
    void testGetVersionInSameThreadWhenNotInitialized() {
        assertEquals(Version.empty(), ThreadLocalVersionHolder.get().getVersion());
    }

    @Test
    void testGetVersionInAnotherThreadWhenInitializedInsideThread() {
        ThreadLocalVersionHolder.initialize(version);
        CompletableFuture.runAsync(() -> {
            ThreadLocalVersionHolder.initialize(localVersion);
            assertEquals(localVersion, ThreadLocalVersionHolder.get().getVersion());
        }).join();
    }

    @Test
    void testGetVersionWhenSwitched() {
        Version first = Version.of(123, 123);
        Version second = Version.of(546546, 1);
        VersionHolder versionHolder = ThreadLocalVersionHolder.get();
        ThreadLocalVersionHolder.initialize(first);
        assertEquals(first, versionHolder.getVersion());
        ThreadLocalVersionHolder.initialize(second);
        assertEquals(second, versionHolder.getVersion());
    }
}

```


Overlapping Code:
```
onHolderTest {
private final Version version = Version.of(1324, 5);
private final Version localVersion = Version.of(345465, 435);
@Test
void testGetVersionInSameThread() {
ThreadLocalVersionHolder.initialize(version);
assertEquals(version, ThreadLocalVersionHolder.get().getVersion());
}
@Test
void testGetVersionInSameThreadWhenNotInitialized() {
assertEquals(Version.empty(), ThreadLocalVersionHolder.get().getVersion());
}
@Test
void testGetVersionInAnotherThreadWhenInitializedInsideThread() {
ThreadLocalVersionHolder.initialize(version);
CompletableFuture.runAsync(() -> {
ThreadLocalVersionHolder.initialize(localVersion);
assertEquals(localVersion, ThreadLocalVersionHolder.get().getVersion());
}).join();
}
@Test
void testGetVersionWhenSwitched() {
Version first = Version.of(123, 123);
Version second = Version.of(546546, 1);
VersionHolder versionHolder = ThreadLocalVersionHolder.get();
ThreadLocalVersionHolder.initialize(first);
assertEquals(first, versionHolder.getVersion());
ThreadLocalVersionHolder.initialize(second);
assertEquals(s
```
<Overlap Ratio: 0.9450945094509451>

---

--- 41 --
Question ID: 0a2f28df151b3621ae7f64d2d75f3eace8e03e16
Original Code:
```
public class WebglInteractiveCubes extends Attachable {

    public final static String name = "interactive / cubes";

    private Random rand = new Random();

    private Raycaster raycaster;

    private Vector2 mouse = new Vector2();

    private float radius = 100, theta = 0;

    private Mesh INTERSECTED;

    public WebglInteractiveCubes() {
        camera = new PerspectiveCamera(70, aspect, 1, 10000);
        scene = new Scene();
        scene.background = new Color(0xf0f0f0);
        DirectionalLight light = new DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);
        BoxBufferGeometry geometry = new BoxBufferGeometry(20, 20, 20);
        int i = 0;
        while (i < 2000) try {
            MeshLambertMaterialParameters parameters = new MeshLambertMaterialParameters();
            parameters.color = new Color(rand.nextInt() * 0xffffff);
            Mesh object = new Mesh(geometry, new MeshLambertMaterial(parameters));
            object.position.x = rand.nextFloat() * 800 - 400;
            object.position.y = rand.nextFloat() * 800 - 400;
            object.position.z = rand.nextFloat() * 800 - 400;
            object.rotation.x = (float) (rand.nextFloat() * 2 * Math.PI);
            object.rotation.y = (float) (rand.nextFloat() * 2 * Math.PI);
            object.rotation.z = (float) (rand.nextFloat() * 2 * Math.PI);
            object.scale.x = rand.nextFloat() + 0.5f;
            object.scale.y = rand.nextFloat() + 0.5f;
            object.scale.z = rand.nextFloat() + 0.5f;
            scene.add(object);
        } finally {
            i++;
        }
        raycaster = new Raycaster();
        // RENDERER
        WebGLRendererParameters parameters = new WebGLRendererParameters();
        parameters.antialias = true;
        renderer = new WebGLRenderer(parameters);
        setupWebGLRenderer(renderer);
        container.appendChild(renderer.domElement);
        renderer.domElement.onmousemove = p0 -> {
            MouseEvent event = Js.uncheckedCast(p0);
            onDocumentMouseMove(event);
            return null;
        };
    }

    private void animate() {
        AnimationScheduler.get().requestAnimationFrame(timestamp -> {
            if (root.parentNode != null) {
                StatsProducer.getStats().update();
                render();
                animate();
            }
        });
    }

    private void onDocumentMouseMove(MouseEvent event) {
        event.preventDefault();
        mouse.x = (float) (((event.clientX - panel.offsetWidth) / (window.innerWidth - panel.offsetWidth)) * 2 - 1);
        mouse.y = (float) (-(event.clientY / window.innerHeight) * 2 + 1);
    }

    @Override
    protected void doAttachScene() {
        root.appendChild(container);
        renderer.setSize(getWidth(), getHeight());
        animate();
    }

    @Override
    protected void doAttachInfo() {
        AppSetup.infoDiv.show().setHrefToInfo("http://threejs.org").setTextContentToInfo("three.js").setInnetHtml("  -  webgl - interactive cubes");
    }

    private void render() {
        theta += 0.1;
        camera.position.x = radius * (float) Math.sin(org.treblereel.gwt.three4g.math.Math.degToRad(theta));
        camera.position.y = radius * (float) Math.sin(org.treblereel.gwt.three4g.math.Math.degToRad(theta));
        camera.position.z = radius * (float) Math.cos(org.treblereel.gwt.three4g.math.Math.degToRad(theta));
        camera.lookAt(scene.position);
        camera.updateMatrixWorld();
        // find intersections
        raycaster.setFromCamera(mouse, camera);
        Intersect[] intersects = raycaster.intersectObjects(scene.children);
        if (intersects.length > 0) {
            Intersect intersect = intersects[0];
            Mesh intersected = intersect.object;
            if (INTERSECTED != intersected) {
                int currentHex = ((MeshLambertMaterial) intersected.material).emissive.getHex();
                intersected.userData.setProperty("currentHex", currentHex);
                ((MeshLambertMaterial) intersected.material).emissive.setHex(0xff0000);
                INTERSECTED = intersected;
            }
        } else {
            if (INTERSECTED != null) {
                ((MeshLambertMaterial) INTERSECTED.material).emissive.setHex(INTERSECTED.userData.getProperty("currentHex"));
                INTERSECTED = null;
            }
        }
        renderer.render(scene, camera);
    }
}

```


Overlapping Code:
```
 Attachable {
public final static String name = "interactive / cubes";
private Random rand = new Random();
private Raycaster raycaster;
private Vector2 mouse = new Vector2();
private float radius = 100, theta = 0;
private Mesh INTERSECTED;
public WebglInteractiveCubes() {
camera = new PerspectiveCamera(70, aspect, 1, 10000);
scene = new Scene();
scene.background = new Color(0xf0f0f0);
DirectionalLight light = new DirectionalLight(0xffffff, 1);
light.position.set(1, 1, 1).normalize();
scene.add(light);
BoxBufferGeometry geometry = new BoxBufferGeometrybertMaterialParameters parameters = new MeshLambertMaterialParameters();
parameters.color = new Color(rand.nextInt() * 0xffffff);
Mesh object = new Mesh(geometry, new MeshLambertMaterial(parameters));
object.position.x = rand.nextFloat() * 800 - 400;
object.position.y = rand.nextFloat() * 800 - 400;
object.position.z = rand.nextFloat() * 800 - 400;
object.rotation.x = (float) (rand.nextFloat() * 2 * Math.PI);
object.rotation.y = (float) (rand.nextFloat() * 2 * Math.PI);
object.rotation.z = (float) (rand.nextFloat() * 2 * Math.PI);
object.scale.x = rand.nextFloat() + 0.5f;
object.scale.y = rand.nextFloat() + 0.5f;
object.scale.z = rand.nextFloat() + ster = new Raycaster();
// RENDERER
WebGLRendererParameters parameters = new WebGLRendererParameters();
parameters.antialias = true;
renderer = new WebGLRenderer(parameters);
setupWebGLRenderer(renderer);
container.appendChild(renderer.domElement);
renderer.domElement.onmousemove = p0 -> {
MouseEvent event = Js.uncheckedCast(p0);
onDocumentMouseMove(event);
return null;
};
}
private void animate() {
AnimationScheduler.get().requestAnimationFrame(timestamp -> {
if (root.parentNode != null) {
StatsProducer.getStats().update();
render();
animate();
}
});
}
private void onDocumentMouseMove(MouseEvent event) {
event.p
```
<Overlap Ratio: 0.9234642497482377>

---

--- 42 --
Question ID: 22f1d27c88a69020fcf20563969e6c9de6ef532c
Original Code:
```
@ChannelHandler.Sharable
public class AsyncRpcClientHandler extends AbstractRpcClientHandler<RpcFuture> {

    public static final String POOL_KEY = "AsyncRpcClientHandler";

    private static final SwiftLogger LOGGER = SwiftLoggers.getLogger(AsyncRpcClientHandler.class);

    private Map<String, RpcFuture> pendingRPC = new ConcurrentHashMap<>();

    public AsyncRpcClientHandler(String address) {
        super(address);
    }

    @Override
    protected void channelRead0(ChannelHandlerContext channelHandlerContext, Response response) {
        String requestId = response.getRequestId();
        LOGGER.info("Receive response : " + requestId);
        RpcFuture rpcFuture = pendingRPC.get(requestId);
        if (rpcFuture != null) {
            pendingRPC.remove(requestId);
            rpcFuture.done(response);
        }
        AsyncRpcPool.getInstance().returnObject(address, this);
    }

    public void close() {
        channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
    }

    public RpcFuture send(final Request request) throws Exception {
        RpcFuture rpcFuture = new SwiftFuture(request);
        pendingRPC.put(request.getRequestId(), rpcFuture);
        final CountDownLatch latch = new CountDownLatch(1);
        channel.writeAndFlush(request).sync().addListener((ChannelFutureListener) future -> {
            LOGGER.info("Send request : " + request.getRequestId());
            latch.countDown();
        });
        return rpcFuture;
    }
}

```


Overlapping Code:
```
annelHandler.Sharable
public class AsyncRpcClientHandler extends AbstractRpcClientHandler<RpcFuture> {
public static final String POOL_KEY = "AsyncRpcClientHandler";
private static final SwiftLogger LOGGER = SwiftLoggers.getLogger(AsyncRpcClientHandler.class);
private Map<String, RpcFuture> pendingRPC = new ConcurrentHashMap<>();
public AsyncRpcClientHandler(String address) {
super(address);
}
@Override
protected void channelRead0(ChannelHandlerContext channelHandlerContext, Response response) {
String requestId = response.getRequestId();
LOGGER.info("Receive response : " + requestId);
RpcFuture rpcFuture = pendingRPC.get(requestId);
if (rpcFuture != null) {
pendingRPC.remove(requestId);
rpcFuture.done(response);
}
AsyncRpcPool.getInstance().returnObject(address, this);
}
public void close() {
channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
}
public RpcFuture send(final Request request) throws Exception {
RpcFuture rpcFuture = new SwiftFuture(request);
pendingRPC.put(request.getRequestId(), rpcFuture);
final CountDownLatch latch = new CountDownLatch(1);
channel.writeAndFlush(request).sync().addListener((ChannelFutureListener) future -> {
LOGGER.info("Send request : " + request.getRequestId())
```
<Overlap Ratio: 0.962278675904542>

---

--- 43 --
Question ID: 5d472b5f1430329360203403faee99d7d06a9a9e
Original Code:
```
public class SupportedPointFormatsExtension extends HelloExtension {

    private static final int LIST_LENGTH_BITS = 8;

    private static final int POINT_FORMAT_BITS = 8;

    /**
     * Items in here are ordered according to the client's preferences (favorite
     * choice first).
     */
    List<ECPointFormat> ecPointFormatList;

    public SupportedPointFormatsExtension(List<ECPointFormat> ecPointFormatList) {
        super(ExtensionType.EC_POINT_FORMATS);
        this.ecPointFormatList = ecPointFormatList;
    }

    public void addECPointFormat(ECPointFormat format) {
        ecPointFormatList.add(format);
    }

    @Override
    public int getLength() {
        // variable: number of point formats
        return 5 + ecPointFormatList.size();
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder(super.toString());
        sb.append("\t\t\t\tLength: " + (getLength() - 4) + "\n");
        sb.append("\t\t\t\tEC point formats length: " + (getLength() - 5) + "\n");
        sb.append("\t\t\t\tElliptic Curves Point Formats (" + ecPointFormatList.size() + "):\n");
        for (ECPointFormat format : ecPointFormatList) {
            sb.append("\t\t\t\t\tEC point format: " + format.toString() + "\n");
        }
        return sb.toString();
    }

    @Override
    public byte[] toByteArray() {
        DatagramWriter writer = new DatagramWriter();
        writer.writeBytes(super.toByteArray());
        int listLength = ecPointFormatList.size();
        // list length + list length field (1 byte)
        writer.write(listLength + 1, LENGTH_BITS);
        writer.write(listLength, LIST_LENGTH_BITS);
        for (ECPointFormat format : ecPointFormatList) {
            writer.write(format.getId(), POINT_FORMAT_BITS);
        }
        return writer.toByteArray();
    }

    public static HelloExtension fromByteArray(byte[] byteArray) {
        DatagramReader reader = new DatagramReader(byteArray);
        int listLength = reader.read(LIST_LENGTH_BITS);
        List<ECPointFormat> ecPointFormatList = new ArrayList<ECPointFormat>();
        for (; listLength > 0; ) {
            ECPointFormat format = ECPointFormat.getECPointFormatById(reader.read(POINT_FORMAT_BITS));
            ecPointFormatList.add(format);
            // one point format uses 1 byte
            listLength -= 1;
        }
        return new SupportedPointFormatsExtension(ecPointFormatList);
    }

    /**
     * See <a href="http://tools.ietf.org/html/rfc4492#section-5.1.2">RFC 4492,
     * 5.1.2. Supported Point Formats Extension</a>.
     *
     * @author Stefan Jucker
     */
    public enum ECPointFormat {

        UNCOMPRESSED(0), ANSIX962_COMPRESSED_PRIME(1), ANSIX962_COMPRESSED_CHAR2(2);

        private int id;

        private ECPointFormat(int id) {
            this.id = id;
        }

        public int getId() {
            return id;
        }

        @Override
        public String toString() {
            switch(id) {
                case 0:
                    return "uncompressed (" + id + ")";
                case 1:
                    return "ansiX962_compressed_prime (" + id + ")";
                case 2:
                    return "ansiX962_compressed_char2 (" + id + ")";
                default:
                    return "";
            }
        }

        public static ECPointFormat getECPointFormatById(int id) {
            switch(id) {
                case 0:
                    return ECPointFormat.UNCOMPRESSED;
                case 1:
                    return ECPointFormat.ANSIX962_COMPRESSED_PRIME;
                case 2:
                    return ECPointFormat.ANSIX962_COMPRESSED_CHAR2;
                default:
                    return null;
            }
        }
    }
}

```


Overlapping Code:
```
ss SupportedPointFormatsExtension extends HelloExtension {
private static fl int LIST_LENGTH_BITS = 8;
private static final int ms in here are ordered according to the client's preferences (favorite
* choice first).
*/
List<ECPoblic SupportedPointFormatsExtension(List<ECPointFormat> ecPointFormatList) {
super(ExtensionType.EC_POINT_FORMATS);
this.ecPointFormatList = ecPointFoointFormat(ECPointFormat format) {
ecPointFormatList.add(format);
}
@Override
public int getLength()ist.size();
}
@Override
public String toString() {
StringBuilder sb = new StringBuilder(super.toString());
sb.append("\t\t\t\tLength: " + (getLength() - 4) + "\n");
sb.append("\t\t\t\tEC point formats length: " + (getLength() - 5) + "\n");
sb.append("\t\t\t\tElliptic Curves Point Formats (" + ecPointFormatList.size() + "):\n");
for (ECPointFormat format : ecPointFormatList) {
sb.append("\t\t\t\t\tEC point format: " + format.toString() + "\n");
}
return sb.toString();
}
@Override
public byte[] toByteArray() {
DatagramWriter writer = new DatagramWriter();
writer.writeBytes(super.toByteArray());
int listLength = ecPointFormatList.size();
// list length + list length field (1 byte)
writer.write(listLength + 1, LENGTH_BITS);
writer.write(listLength, LIST_LENGTH_BITS);
for (ECPointFormat format : ecPointFormatList) {
writer.write(format.getId(), POINT_FORMAT_BITS);
}
return writer.toByteArray();
}
public static HelloExtension fromByteArray(byte[] byteArray) {
DatagramReader reader = new DatagramReader(byteArray);
int listLength = reader.read(LIST_LENGTH_BITS);
List<ECPointFormat> ecPointFormat.getECPointFormatById(reader.read(POINT_FORMAoint format uses 1 byte
listLength -= 1;
}
return new SupportedPointFormatsExtension(ecPointFormatLi
```
<Overlap Ratio: 0.8219895287958116>

---

--- 44 --
Question ID: 472700bf6fa9122b546087fd965781da595983d5
Original Code:
```
@RestController
public class LoginController {

    @Autowired
    LoginService loginService;

    @Autowired
    StudentService studentService;

    @Autowired
    TeacherService teacherService;

    @GetMapping("/")
    public ModelAndView Index() {
        ModelAndView mv = new ModelAndView();
        mv.setViewName("index");
        return mv;
    }

    @GetMapping("/createS")
    public ModelAndView CreateS() {
        ModelAndView mv = new ModelAndView();
        mv.setViewName("Student_form");
        return mv;
    }

    @GetMapping("/forgot.html")
    public ModelAndView forgot() {
        ModelAndView mv = new ModelAndView();
        mv.setViewName("forgot");
        return mv;
    }

    @PostMapping("/login")
    public ModelAndView login(Login user, HttpServletRequest request) {
        ModelAndView mv = new ModelAndView();
        try {
            System.out.println(user.getEmail() + " - " + user.getPassword());
            if (user.getEmail().equals("admin@admin.com") && (user.getPassword().equals("admin"))) {
                mv.setViewName("admin");
                return mv;
            }
            long id = this.loginService.findPassword(user.getEmail(), user.getPassword());
            int role = this.loginService.findRole(id);
            int otl = this.loginService.findOtl(id);
            if (role == 1) {
                String name = this.studentService.findName(id);
                HttpSession session = request.getSession();
                if (otl == 1) {
                    session.setAttribute("id", id);
                    mv.setViewName("NewPassword");
                    return mv;
                } else {
                    session.setAttribute("name", name);
                    mv.setViewName("student");
                    mv.addObject("name", name);
                }
                return mv;
            } else {
                String name = this.teacherService.findName(id);
                HttpSession session = request.getSession();
                session.setAttribute("name", name);
                mv.setViewName("teacher");
                mv.addObject("name", name);
                return mv;
            }
        } catch (Exception e) {
            mv.setViewName("index");
            return mv;
        }
    }

    @SuppressWarnings("unused")
    @PostMapping("/forgotpassword")
    public ModelAndView forgotPassword(@RequestParam("email") String email, HttpServletRequest request) {
        ModelAndView mv = new ModelAndView();
        try {
            String name;
            System.out.println(email);
            long id = this.loginService.findUserEmail(email);
            Long user_id = id;
            if (user_id != null) {
                int role = this.loginService.findRole(id);
                if (role == 1) {
                    name = this.studentService.findName(id);
                } else {
                    name = this.teacherService.findName(id);
                }
                Random rnd = new Random();
                int number = rnd.nextInt(999999);
                String vcode = String.format("%06d", number);
                System.out.println(vcode);
                HttpSession session = request.getSession();
                MailSender.send(email, "Verfication code for your password recovery", "Dear " + name + ",<br>Provided below is the verification " + "code for recovering your password.<br><h1>" + vcode + "</h1><br>Enter this to set a new password.<br>Thank you.");
                session.setAttribute("id", id);
                session.setAttribute("vcode", vcode);
                mv.setViewName("recover");
                return mv;
            } else {
                mv.setViewName("forgot");
                return mv;
            }
        } catch (Exception e) {
            mv.setViewName("forgot");
            return mv;
        }
    }

    @PostMapping("/recoverpassword")
    public ModelAndView recoverPassword(@RequestParam("code") String code, HttpServletRequest request) {
        ModelAndView mv = new ModelAndView();
        try {
            System.out.println("user entered:" + code);
            HttpSession session = request.getSession(false);
            if (session != null) {
                String vcode = (String) session.getAttribute("vcode");
                if (vcode.equals("")) {
                    mv.setViewName("forgot");
                    return mv;
                }
                System.out.println("in session:" + vcode);
                if (code.equals(vcode)) {
                    session.setAttribute("vcode", "");
                    mv.setViewName("NewPassword");
                    return mv;
                } else {
                    mv.setViewName("recover");
                    return mv;
                }
            } else {
                mv.setViewName("forgot");
                return mv;
            }
        } catch (Exception e) {
            mv.setViewName("forgot");
            return mv;
        }
    }

    @PostMapping("/setpassword")
    public ModelAndView setPassword(@RequestParam("newpassword") String npassword, @RequestParam("confirmpassword") String cpassword, HttpServletRequest request) {
        ModelAndView mv = new ModelAndView();
        try {
            HttpSession session = request.getSession(false);
            if (npassword.equals(cpassword)) {
                long id = (long) session.getAttribute("id");
                loginService.updatePassword(npassword, id);
                mv.setViewName("index");
                return mv;
            } else {
                mv.setViewName("NewPassword");
                return mv;
            }
        } catch (Exception e) {
            mv.setViewName("NewPassword");
            return mv;
        }
    }
}

```


Overlapping Code:
```
@RestController
public class LoginController {
@Autowired
LoginService loginService;
@Autowired
StudentService studentService;
@Autowired
TeacherService teacherService;
@GetMapping(")
public ModelAndView Index() {
ModelAndView mv = new ModelAndView();
mv.setViewName("index");
return mv;
}
@GetMapping("/createS")
public ModelAndVie() {
ModelAndView mv = new ModelAndView();
mv.setViewName("Student_form");
return mv;
}
@GetMapping("/forgot.html")
public ModelAndView forgot() {
ModelAndView mv = new ModelAndView();
mv.setViewName("forgot");
return mv;
}
@PostMapping("/login")
public ModelAndView login(HttpServletRequest request) {
ModelAndView mv = new ModelAndView();
(id);
HttpSession session = request.getSession();
if ((id);
HttpSession session = request.getSession();
session.setAttribute("name", nameostMapping("/forgotpassword")
public ModelAndView forgotPassword(@RequestParam("email") String email, HttpServletRequest request) {
ModelAndView m
```
<Overlap Ratio: 0.5258525852585259>

---

--- 45 --
Question ID: a8ba7f5b0c8ef7e57b8db2d114463f4396c0eae6
Original Code:
```
public class HomeControllerTest extends WithApplication {

    private HomeController homeController;

    @Before
    public void provideHomeController() {
        this.homeController = new HomeController(Mockito.mock(AssetsFinder.class));
    }

    @Test
    public void testIndex() {
        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session("email", "test");
        Result result = homeController.index(requestBuilder.build());
        assertEquals(OK, result.status());
        assertEquals("text/html", result.contentType().get());
    }

    @Test
    public void testHighscore() {
        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session("email", "test");
        Result result = homeController.highscore(requestBuilder.build());
        assertEquals(OK, result.status());
        assertEquals("text/html", result.contentType().get());
    }

    @Test
    public void testProfile() {
        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session("email", "test");
        Result result = homeController.profile(requestBuilder.build());
        assertEquals(OK, result.status());
        assertEquals("text/html", result.contentType().get());
    }

    @Test
    public void testMenu() {
        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session("email", "test");
        Result result = homeController.menu(requestBuilder.build());
        assertEquals(OK, result.status());
        assertEquals("text/html", result.contentType().get());
    }

    @Test
    public void testPizzaRush() {
        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session("email", "test");
        Result result = homeController.pizzaRush(requestBuilder.build());
        assertEquals(OK, result.status());
        assertEquals("text/html", result.contentType().get());
    }

    @Test
    public void testMemory() {
        Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session("email", "test");
        Result result = homeController.memory(requestBuilder.build());
        assertEquals(OK, result.status());
        assertEquals("text/html", result.contentType().get());
    }
}

```


Overlapping Code:
```
ublic class HomeControllerTest extends WithApplication {
private HomeController homeController;
@Before
public void provideHomeController() {
this.homeController = new HomeController(Mockito.mock(AssetsFinder.class));
}
@Test
public void testIndex() {
Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session("email", "test");
Result result = homeController.index(requestBuilder.build());
assertEquals(OK, result.status());
assertEquals("text/html", result.contentType().get());
}
@Test
public void testHighscore() {
Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session("email", "test");
Result result = homeController.highscore(requestBuilder.build());
assertEquals(OK, result.status());
assertEquals("text/html", result.contentType().get());
}
@Test
public void testProfile() {
Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session("email", "test");
Result result = homeController.profile(requestBuilder.build());
assertEquals(OK, result.status());
assertEquals("text/html", result.contentType().get());
}
@Test
public void testMenu() {
Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session("email", "test");
Result result = homeController.menu(requestBuilder.build());
assertEquals(OK, result.status());
assertEquals("text/html", result.contentType().get());
}
@Test
public void testPizzaRush() {
Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session("email", "test");
Result result = homeController.pizzaRush(requestBuilder.build());
assertEquals(OK, result.status());
assertEquals("text/html", result.contentType().get());
}
@Test
public void testMemory() {
Http.RequestBuilder requestBuilder = Helpers.fakeRequest().session("email", "test");
Result result = homeController.memory(requestBuilder.build());
assertEquals(OK, result.status());
assertEquals("text/html", result.contentType().get());

```
<Overlap Ratio: 0.9978586723768736>

---

--- 46 --
Question ID: 8430996939d31d00feb517b1c2345762d39cc91e
Original Code:
```
public class PullRequestRescopedActivity extends PullRequestActivity {

    private String fromHash;

    private String previousFromHash;

    private String previousToHash;

    private String toHash;

    private List<Commit> added;

    private List<Commit> removed;

    protected PullRequestRescopedActivity() {
    }

    public PullRequestRescopedActivity(Long id, Date createdDate, User user, Long pullRequestId, String fromHash, String previousFromHash, String previousToHash, String toHash, List<Commit> added, List<Commit> removed) {
        this.id = id;
        this.createdDate = createdDate;
        this.user = user;
        this.pullRequestId = pullRequestId;
        this.fromHash = fromHash;
        this.previousFromHash = previousFromHash;
        this.previousToHash = previousToHash;
        this.toHash = toHash;
        this.added = ImmutableList.copyOf(added);
        this.removed = ImmutableList.copyOf(removed);
        this.actionType = PullRequestActivityActionType.RESCOPED;
    }

    public String getFromHash() {
        return fromHash;
    }

    public String getPreviousFromHash() {
        return previousFromHash;
    }

    public String getPreviousToHash() {
        return previousToHash;
    }

    public String getToHash() {
        return toHash;
    }

    public List<Commit> getAdded() {
        return added;
    }

    public List<Commit> getRemoved() {
        return removed;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        PullRequestRescopedActivity that = (PullRequestRescopedActivity) o;
        if (pullRequestId != that.pullRequestId)
            return false;
        if (fromHash != null ? !fromHash.equals(that.fromHash) : that.fromHash != null)
            return false;
        if (previousFromHash != null ? !previousFromHash.equals(that.previousFromHash) : that.previousFromHash != null)
            return false;
        if (previousToHash != null ? !previousToHash.equals(that.previousToHash) : that.previousToHash != null)
            return false;
        if (toHash != null ? !toHash.equals(that.toHash) : that.toHash != null)
            return false;
        if (added != null ? !added.equals(that.added) : that.added != null)
            return false;
        if (removed != null ? !removed.equals(that.removed) : that.removed != null)
            return false;
        if (id != null ? !id.equals(that.id) : that.id != null)
            return false;
        if (createdDate != null ? !createdDate.equals(that.createdDate) : that.createdDate != null)
            return false;
        if (user != null ? !user.equals(that.user) : that.user != null)
            return false;
        return actionType == that.actionType;
    }

    @Override
    public int hashCode() {
        int result = fromHash != null ? fromHash.hashCode() : 0;
        result = 31 * result + (previousFromHash != null ? previousFromHash.hashCode() : 0);
        result = 31 * result + (previousToHash != null ? previousToHash.hashCode() : 0);
        result = 31 * result + (toHash != null ? toHash.hashCode() : 0);
        result = 31 * result + (added != null ? added.hashCode() : 0);
        result = 31 * result + (removed != null ? removed.hashCode() : 0);
        result = 31 * result + (id != null ? id.hashCode() : 0);
        result = 31 * result + (createdDate != null ? createdDate.hashCode() : 0);
        result = 31 * result + (user != null ? user.hashCode() : 0);
        result = 31 * result + (int) (pullRequestId ^ (pullRequestId >>> 32));
        result = 31 * result + (actionType != null ? actionType.hashCode() : 0);
        return result;
    }

    @Override
    public String toString() {
        return "PullRequestRescopedActivity{" + "fromHash='" + fromHash + '\'' + ", previousFromHash='" + previousFromHash + '\'' + ", previousToHash='" + previousToHash + '\'' + ", toHash='" + toHash + '\'' + ", added=" + added + ", removed=" + removed + ", id=" + id + ", createdDate=" + createdDate + ", user=" + user + ", pullRequestId=" + pullRequestId + ", actionType=" + actionType + '}';
    }
}

```


Overlapping Code:
```
 class PullRequestRescopedActivity extends PullReqing previousFromHash;
private String previousToHash;
private String toHash;
private List<Commit> added;
private List<Commit> removed;
protected PullRequestRescopedActivity() {
}
public PullRequestRescopedActivity(Long id, Date createdDate, User user, Long pullRequestId, String fromHash, String previousFromHash, String previousToHash, String toHash, List<Commit> added, List<Commit> removed) {
this.id = id;
this.createdDate = createdDate;
this.user = user;
this.pullRequestId = pullRequestId;
this.fromHash = fromHash;
this.previousFromHash = previousFromHash;
this.previousToHash = previousToHash;
this.toHash = toHash;
this.added = ImmutableList.copyOf(added);
this.removed = ImmutableList.copyOf(removed);
this.actionType = PullRequestActivityActionType.RESCOPED;
}
public String getFromHash() {
return fromHash;
}
public String getPreviousFromHash() {
return previousFromHash;
}
public String getPreviousToHash() {
return previousToHash;
}
public String getToHash() {
return toHash;
}
public List<Commit> getAdded() {
return added;
}
public List<Commit> getRemoved() {
return removed;
}
@Override
public boolean equals(Object o) {
if (this == o)
return true;
if (o == null || getClass() != o.getClass())
return false;
Py that = (PullRequestRescopedActivity) o;
if (pull(fromHash != null ? !fromHash.equals(that.fromHashousFromHash != null ? !previousFromHash.equals(that.previousFromHash) : that.previousFromHash != null)
return false;
if (previousToHash != null ? !previousToHash.equals(that.previousToHash) : that.previousToHash != null)
return false;
if (toHash != null ? !toHash.equals(that.toHash) : that.toHash != null)
return false;
if (added != null ? !added.equals(that.added) : that.added !=e;
if (removed != null ? !removed.equals(that.removed) : that.removed
```
<Overlap Ratio: 0.8881322957198443>

---

--- 47 --
Question ID: d9ecb15e843577b711bc488b0ff3800761dceffb
Original Code:
```
@Controller
public class ModelController {

    @ModelAttribute("girl")
    public Girl init(Model model) {
        Girl g = new Girl();
        g.setAge(28);
        g.setName("??");
        return g;
    }

    @RequestMapping("/m1")
    public String m1(Model model) {
        System.out.println(model.containsAttribute("girl"));
        return "msg";
    }

    @RequestMapping("/m2/{name}/{age}")
    public String m1(@ModelAttribute Girl girl) {
        System.out.println(girl.getName() + girl.getAge());
        return "msg";
    }

    @RequestMapping(value = "m3", method = RequestMethod.POST)
    public String m3(@ModelAttribute Girl girl) {
        System.out.println(girl.getName() + girl.getAge());
        return "msg";
    }
}

```


Overlapping Code:
```
tMapping("/m1")
public String m1(Model model) {
System.out.println(model.containsAttribute("girl"));}")
public String m1(@ModelAttribute Girl girl) {
System.out.println(girl.getName()ute Girl girl) {
System.out.println(girl.getName()
```
<Overlap Ratio: 0.381342062193126>

---

--- 48 --
Question ID: 04baabdf7c25ae7771d5baa86ba14663503d9f40
Original Code:
```
@ConstantFieldsFirstExcept({})
@ConstantFieldsSecondExcept({})
public class StratosphereSqlCrossOperator extends CrossFunction {

    private static final long serialVersionUID = 1L;

    private Filter filter;

    public StratosphereSqlCrossOperator(Filter f) {
        this.filter = f;
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        // TODO Auto-generated method stub
        super.open(parameters);
        filter.prepareEvaluation();
    }

    @Override
    public void cross(Record record1, Record record2, Collector<Record> out) throws Exception {
        if (filter.evaluateTwo(record1, record2)) {
            System.err.println("Cross got rec1=" + record1 + " rec2=" + record2);
            record1.concatenate(record2);
            System.err.println("Cross is outputting " + record1);
            out.collect(record1);
        }
    }
}

```


Overlapping Code:
```
tratosphereSqlCrossOperator extends CrossFunction {
private static final long serialVersionUID = 1L;
private Filter ssOperator(Filter f) {
this.filter = f;
}
@Override
public void open(Configuration parameters) throws Exception {
// TODO Auto-generated method stub
super.open(parameters);
filter.prepareEvaluation();
}
@Override
public void cross(Record record1, Record record2, Collector<Record> out) throws Exception {
i
```
<Overlap Ratio: 0.5582010582010583>

---

--- 49 --
Question ID: 013ae4b5c9166755961902e1d4e8a6e2bb028d77
Original Code:
```
@Test(singleThreaded = true)
public class TestClusterManager {

    private Log log = LogFactory.getLog(TestClusterManager.class);

    @Test
    public /*
   * Tests that the worker nodes returned are correctly handled by PrestoClusterManager and sorted list of hosts is returned
   */
    void testGetNodes() throws IOException {
        HttpServer server = createServer("/v1/node", new MultipleWorkers(), "/v1/node/failed", new NoFailedNode());
        log.info("STARTED SERVER");
        ClusterManager clusterManager = getPrestoClusterManager();
        List<String> nodes = clusterManager.getNodes();
        log.info("Got nodes: " + nodes);
        assertTrue(nodes.size() == 2, "Should only have two nodes");
        assertTrue(nodes.get(0).equals("192.168.1.3") && nodes.get(1).equals("192.168.2.252"), "Wrong nodes data");
        server.stop(0);
    }

    @Test
    public /*
   * Tests that in a single node cluster, master node is returned as worker
   */
    void testMasterOnlyCluster() throws IOException {
        HttpServer server = createServer("/v1/node", new NoWorker(), "/v1/node/failed", new NoFailedNode());
        log.info("STARTED SERVER");
        ClusterManager clusterManager = getPrestoClusterManager();
        List<String> nodes = clusterManager.getNodes();
        log.info("Got nodes: " + nodes);
        assertTrue(nodes.size() == 1, "Should have added localhost in list");
        assertTrue(nodes.get(0).equals(InetAddress.getLocalHost().getHostAddress()), "Not added right hostname");
        server.stop(0);
    }

    @Test
    public /*
   * Tests that in a cluster with failed node, failed node is not returned
   */
    void testFailedNodeCluster() throws IOException {
        HttpServer server = createServer("/v1/node", new MultipleWorkers(), "/v1/node/failed", new OneFailedNode());
        log.info("STARTED SERVER");
        ClusterManager clusterManager = getPrestoClusterManager();
        List<String> nodes = clusterManager.getNodes();
        log.info("Got nodes: " + nodes);
        assertTrue(nodes.size() == 1, "Should only have two nodes");
        assertTrue(nodes.get(0).equals("192.168.2.252"), "Wrong nodes data");
        server.stop(0);
    }

    private HttpServer createServer(String endpoint1, HttpHandler handler1, String endpoint2, HttpHandler handler2) throws IOException {
        HttpServer server = HttpServer.create(new InetSocketAddress(45326), 0);
        server.createContext(endpoint1, handler1);
        server.createContext(endpoint2, handler2);
        // creates a default executor
        server.setExecutor(null);
        server.start();
        return server;
    }

    private ClusterManager getPrestoClusterManager() throws UnknownHostException {
        ClusterManager clusterManager = new PrestoClusterManager();
        Configuration conf = new Configuration();
        conf.setInt(PrestoClusterManager.serverPortConf, 45326);
        clusterManager.initialize(conf);
        return clusterManager;
    }

    class MultipleWorkers implements HttpHandler {

        public void handle(HttpExchange exchange) throws IOException {
            String nodes = "[{\"uri\":\"http://192.168.2.252:8083\",\"recentRequests\":119.0027780896941,\"recentFailures\":119.00267353393015,\"recentSuccesses\":1.0845754237194612E-4,\"lastRequestTime\":\"2016-01-14T13:26:29.948Z\",\"lastResponseTime\":\"2016-01-14T13:26:29.948Z\",\"recentFailureRatio\":0.999999121400646,\"age\":\"6.68h\",\"recentFailuresByType\":{\"java.util.concurrent.TimeoutException\":2.4567611856996272E-6,\"java.net.SocketTimeoutException\":119.00237271323728,\"java.net.SocketException\":2.98363931759331E-4}},{\"uri\":\"http://192.168.1.3:8082\",\"recentRequests\":119.00277802527565,\"recentFailures\":119.00282273097419,\"recentSuccesses\":0.0,\"lastRequestTime\":\"2016-01-14T13:26:29.701Z\",\"lastResponseTime\":\"2016-01-14T13:26:29.701Z\",\"recentFailureRatio\":1.0000003756693692,\"age\":\"21.81h\",\"recentFailuresByType\":{\"java.util.concurrent.TimeoutException\":0.0,\"java.net.SocketTimeoutException\":119.00258110193407,\"java.net.ConnectException\":0.0,\"java.net.SocketException\":2.416290401318479E-4,\"java.net.NoRouteToHostException\":1.3332509542453224E-21}}]\n";
            exchange.getResponseHeaders().add("Content-Type", "application/json");
            exchange.sendResponseHeaders(200, nodes.length());
            OutputStream os = exchange.getResponseBody();
            os.write(nodes.getBytes());
            os.close();
        }
    }

    class NoWorker implements HttpHandler {

        public void handle(HttpExchange exchange) throws IOException {
            String nodes = "[]\n";
            exchange.getResponseHeaders().add("Content-Type", "application/json");
            exchange.sendResponseHeaders(200, nodes.length());
            OutputStream os = exchange.getResponseBody();
            os.write(nodes.getBytes());
            os.close();
        }
    }

    class NoFailedNode implements HttpHandler {

        public void handle(HttpExchange exchange) throws IOException {
            String nodes = "[]\n";
            exchange.getResponseHeaders().add("Content-Type", "application/json");
            exchange.sendResponseHeaders(200, nodes.length());
            OutputStream os = exchange.getResponseBody();
            os.write(nodes.getBytes());
            os.close();
        }
    }

    class OneFailedNode implements HttpHandler {

        public void handle(HttpExchange exchange) throws IOException {
            String nodes = "[{\"uri\":\"http://192.168.1.3:8082\",\"recentRequests\":119.00277802527565,\"recentFailures\":119.00282273097419,\"recentSuccesses\":0.0,\"lastRequestTime\":\"2016-01-14T13:26:29.701Z\",\"lastResponseTime\":\"2016-01-14T13:26:29.701Z\",\"recentFailureRatio\":1.0000003756693692,\"age\":\"21.81h\",\"recentFailuresByType\":{\"java.util.concurrent.TimeoutException\":0.0,\"java.net.SocketTimeoutException\":119.00258110193407,\"java.net.ConnectException\":0.0,\"java.net.SocketException\":2.416290401318479E-4,\"java.net.NoRouteToHostException\":1.3332509542453224E-21}}]\n";
            exchange.getResponseHeaders().add("Content-Type", "application/json");
            exchange.sendResponseHeaders(200, nodes.length());
            OutputStream os = exchange.getResponseBody();
            os.write(nodes.getBytes());
            os.close();
        }
    }
}

```


Overlapping Code:
```
@Test(singleThreaded = true)
public class TestClusrManager.getNodes();
log.info("Got nodes: " + noderManager.getNodes();
log.info("Got nodes: " + nodees.size() == 1, "Should have added localhost in li.equals(InetAddress.getLocalHost().getHostAddress()), "rManager.getNodes();
log.info("Got nodes: " + node) throws IOException {
HttpServer server = HttpServer.create(new InetSocketAddress(453
```
<Overlap Ratio: 0.17740471869328495>

---

--- 50 --
Question ID: 673ab9412635a6e9d321e08447e1e08c0938e832
Original Code:
```
public class DistributorModule extends SenderModule2 {

    private static final TintColor TINT_COLOR = new TintColor(240, 240, 60);

    public DistributorModule() {
        super(CompiledDistributorModule::new);
    }

    @Override
    public void addSettingsInformation(ItemStack itemstack, List<ITextComponent> list) {
        super.addSettingsInformation(itemstack, list);
        CompiledDistributorModule cdm = new CompiledDistributorModule(null, itemstack);
        list.add(ClientUtil.xlate("modularrouters.guiText.tooltip.distributor.strategy").append(": ").withStyle(TextFormatting.YELLOW).append(ClientUtil.xlate(cdm.getDistributionStrategy().getTranslationKey())).withStyle(TextFormatting.AQUA));
        list.add(ClientUtil.xlate("modularrouters.itemText.fluid.direction." + (cdm.isPulling() ? "IN" : "OUT")).withStyle(TextFormatting.YELLOW));
    }

    @Override
    public ContainerType<? extends ContainerModule> getContainerType() {
        return ModContainerTypes.CONTAINER_MODULE_DISTRIBUTOR.get();
    }

    @Override
    public List<ModuleTarget> getStoredPositions(@Nonnull ItemStack stack) {
        return ImmutableList.copyOf(TargetedModule.getTargets(stack, false));
    }

    @Override
    public TintColor getItemTint() {
        return TINT_COLOR;
    }

    @Override
    protected int getMaxTargets() {
        return 8;
    }

    @Override
    public int getRenderColor(int index) {
        return 0x80B0FF90;
    }

    @Override
    public int getEnergyCost(ItemStack stack) {
        return MRConfig.Common.EnergyCosts.distributorModuleEnergyCost;
    }
}

```


Overlapping Code:
```
utorModule extends SenderModule2 {
private static final TintColor TINT_COLOR = new TintColor(240, 240, 60);
public DistributorModule() {
super(CompiledDistributorModule::new);
}
@Override
public void addSettingsInformation(ItemStack itemstack, List<ITextComponent> list) {
super.addSettingsInformation(itemstack, list);
CompiledDistributorModule cdm = new CompiledDistributorModule(null, itemstack);
list.add(ClientUtil.xlate("modularrouters.guiText.tooltip.distributor.strategy").append(": ").withStatting.YELLOW).append(ClientUtil.xlate(cdm.getDistributionStrategy().getTranslationKey())).withStyle(TextFormatting.AQUA));
list.add(ClientUtil.xlate("modularrouters.itemText.fluid.direction." + (cdm.isPulling() ? "IN" : "OUT")).withStyle(TextFormatting.YELLOW));
}
@Override
public ContainerType<? extends ContainerModule> getContainerType() {
return ModContainerTypes.CONTAINER_MODULE_DISTRIBUTOR.get();
}
@Override
public List<ModuleTarget> getStoredPositions(@Nonnull ItemStack stack) {
return ImmutableList.copyOf(TargetedModule.getTargets(stack, false));
}
@Override
public TintColor getItemTint() {
return TINT_COLOR;
}
@Override
protected int getMaxTargets() {
return 8;
}
@Override
public int getRenderColor(int index) {
return 0x80B0FF90;
}
@Override
public int getEnergyCost(ItemStack stack) {
return MRConfig.Common.EnergyCosts.distributorModuleEnergy
```
<Overlap Ratio: 0.9707977207977208>

---

--- 51 --
Question ID: 2ebc1707a010e070eba98804a31f5ec0cac11d57
Original Code:
```
public class ProxyIT {

    private static final int MOCK_SERVER_PORT = 8088;

    public static final String MOCK_SERVER_BASE_URL = "http://localhost:" + MOCK_SERVER_PORT + "/";

    private static final int PROXY_SERVER_PORT = 8080;

    public static final String PROXY_SERVER_BASE_URL = "http://localhost:" + PROXY_SERVER_PORT + "/";

    private final HttpClient client = new HttpClient();

    {
        try {
            client.setUserAgentField(new HttpField(HttpHeader.USER_AGENT, "integration test client"));
            client.start();
        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }

    @ClassRule
    public static WireMockRule wireMockRule = new WireMockRule(MOCK_SERVER_PORT);

    @Test
    public void forwardsSimplePost() throws Exception {
        final String body = "\"El veloz murci?lago hind? com?a feliz cardillo y kiwi. La cig?e?a tocaba el saxof?n detr?s del palenque de paja.\"";
        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param("url", MOCK_SERVER_BASE_URL + "boo").content(new StringContentProvider(body)).header("Content-Type", "application/json; charset=UTF-8").header("Foo-Header", "foo").send();
        assertEquals(202, response.getStatus());
        Thread.sleep(500);
        verify(postRequestedFor(urlMatching("/boo")).withHeader("Foo-Header", equalTo("foo")).withRequestBody(equalTo(body)));
    }

    @Test
    public void retriesSimplePost() throws Exception {
        final String body = "\"El veloz murci?lago hind? com?a feliz cardillo y kiwi. La cig?e?a tocaba el saxof?n detr?s del palenque de paja.\"";
        stubFor(post(urlMatching("/")).inScenario("retry").whenScenarioStateIs(Scenario.STARTED).willReturn(aResponse().withStatus(503)).willSetStateTo("retry1"));
        stubFor(post(urlMatching("/")).inScenario("retry").whenScenarioStateIs("retry1").willReturn(aResponse().withStatus(202)).willSetStateTo("retryN"));
        stubFor(post(urlMatching("/")).inScenario("retry").whenScenarioStateIs("retryN").willReturn(aResponse().withStatus(208)));
        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param("url", MOCK_SERVER_BASE_URL).content(new StringContentProvider(body)).header("Content-Type", "application/json; charset=UTF-8").header("Foo-Header", "foo").send();
        assertEquals(202, response.getStatus());
        Thread.sleep(5000);
        verify(2, postRequestedFor(urlMatching("/")).withHeader("Foo-Header", equalTo("foo")).withRequestBody(equalTo(body)));
        // there seems to be no way to ask WireMock directly for the current state of a scenario, so do this:
        assertEquals(208, client.POST(MOCK_SERVER_BASE_URL).send().getStatus());
    }

    @Test
    public void rejectsMalformedUri() throws Exception {
        final String body = "\"El veloz murci?lago hind? com?a feliz cardillo y kiwi.\"";
        ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param("url", MOCK_SERVER_BASE_URL.replace('/', '\\')).content(new StringContentProvider(body)).send();
        assertEquals(400, response.getStatus());
    }

    @Test
    public void rejectsMissingUri() throws Exception {
        final String body = "\"boo\"";
        ContentResponse response = client.POST("http://localhost:" + PROXY_SERVER_PORT + "/").content(new StringContentProvider(body)).send();
        assertEquals(400, response.getStatus());
    }
}

```


Overlapping Code:
```
e static final int MOCK_SERVER_PORT = 8088;
public static final String MOCK_SERVER_BASE_URL = "http://localhost:" + MOCK_SERVER_PORT + "/";
private static final int PROXY_SERVER_PORT = 8080;
public static final String PROXY_SERVER_BASE_URL = "http://localhost:" + PROXY_SERVER_PORT + "/";
private final HttpClient client = new HttpClient();
{
try {
client.setUserAgentField(new HttpField(HttpHeader.USER_AGENT, "integration test client"));
client.start();
} catch (Exception e) {
throw new IllegalStateException(e);
}
}
@ClassRule
public static WireMockRule wireMockRule = new WireMockRule(MOCK_SERVER_PORT);
@Test
public void forwardsSimplePost() throws Exception {
final String body = "\"El veloz ma.\"";
ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param("url", MOCK_SERVER_BASE_U).header("Content-Type", "application/json; charset=UTF-8")., "foo").send();
assertEquals(202, response.getStatus());
Thread.sleep(500);
verify(postRequestedFor(urlMatching("/boo")).withHeader("Foo-Header", equalTo("foo")).withRequestBody(equalTo(body)));
}
@Test
public void retriesSimplePost() throws Exception {
final String body = "\"El veloz mthStatus(208)));
ContentResponse response = client.POST(PROXY_SERVER_BASE_URL).param("url", MOCK_SERVER_BASE_U).header("Content-Type", "application/json; charset=UTF-8")., "foo").send();
assertEquals(202, response.getStatus());
Thread.sleep(5000);
verify(2, postRequestedFor(urlMatching("/")).withHeader("Foo-Header", equalTo("foo"))
```
<Overlap Ratio: 0.6524229074889868>

---

--- 52 --
Question ID: 6ba2c65ef09c9dce214c0d5ad690323d7dcafe61
Original Code:
```
public class SpringXMLBeanDefinitionLoaderImpl implements SpringXMLBeanDefinitionLoader {

    private static SCAGenericApplicationContext createApplicationContext(Object scaParentContext, ClassLoader classLoader, List<URL> resources) {
        if (classLoader == null) {
            classLoader = Thread.currentThread().getContextClassLoader();
        }
        SCAGenericApplicationContext appCtx = new SCAGenericApplicationContext((ApplicationContext) scaParentContext, classLoader);
        XmlBeanDefinitionReader xmlReader = new XmlBeanDefinitionReader(appCtx);
        // REVIEW: [rfeng] How do we control the schema validation
        xmlReader.setValidating(false);
        for (URL resource : resources) {
            xmlReader.loadBeanDefinitions(new UrlResource(resource));
        }
        return appCtx;
    }

    @Override
    public Object load(List<URL> resources, List<SpringSCAServiceElement> serviceElements, List<SpringSCAReferenceElement> referenceElements, List<SpringSCAPropertyElement> propertyElements, List<SpringBeanElement> beanElements, ProcessorContext context) {
        // FIXME: [rfeng] We should try to avoid parsing the Spring xml twice for the deployment and runtime
        SCAGenericApplicationContext applicationContext = createApplicationContext(null, null, resources);
        serviceElements.addAll(applicationContext.getServiceElements());
        referenceElements.addAll(applicationContext.getReferenceElements());
        propertyElements.addAll(applicationContext.getPropertyElements());
        beanElements.addAll(applicationContext.getBeanElements());
        return applicationContext;
    }
}

```


Overlapping Code:
```
c class SpringXMLBeanDefinitionLoaderImpl implements SpringXMLBeanDefinitionLoader {
private static SCAGenericApplicationContext createApplicationContt scaParentContext, ClassLoader classLoader, List<URL> resources) {
if (classLoader == null) {
classLoader = Thread.currentThread().getContextClassLoader();
}
SCAGenericApplicationContext appCtx =ader);
XmlBeanDefinitionReader xmlReader = new XmlBeanDefinitionReader(appCtx);
// REVIEW: [rfeng] How do we control the lse);
for (URL resource : resources) {
xmlReader.loadBeanDefinitions(new UrlResource(resource));
}
return appCtx;
}
@Override
public Object load(List<should try to avoid parsing the Spring xml twice for the deployment and runtime
SCAGenericApplicationContext applicationContext = createApplicationContext(null, null, resources);
serviceElements.addAll(applicationContext.getServiceElements());
referenceElements.addAll(applicationContext.getReferenceElements());
propertyElements.addAll(applicationContext.getPropertyElements());
beanElements.addAll(applicationContext.getBeanElements());
return appl
```
<Overlap Ratio: 0.7238805970149254>

---

--- 53 --
Question ID: 73f3690e36701a98e4dd08553207601b0f576d1b
Original Code:
```
public class EnvLoadFileTest {

    @Test
    public void envTest0() throws IOException {
        System.setProperty("CONFLICTS_VAR", "with app");
        StandardEnvironment env = null;
        //
        env = new StandardEnvironment(null, "/net_hasor_core_environment/simple-config.xml");
        assert "my my my".equals(env.evalString("%MY_ENV%"));
        assert "with app".equals(env.evalString("%CONFLICTS_VAR%"));
        //
        Map<String, String> envMap = new HashMap<String, String>();
        envMap.put("CONFLICTS_VAR", "with env");
        env = new StandardEnvironment(null, "/net_hasor_core_environment/simple-config.xml", envMap, Thread.currentThread().getContextClassLoader());
        assert "with env".equals(env.evalString("%CONFLICTS_VAR%"));
    }
}

```


Overlapping Code:
```
EnvLoadFileTest {
@Test
public void envTest0() throws IOException {
System.setProperty("CONFLICTS_VAR", "with app");
StandardEnvironment env = null;
//
env = new StandardEnvironment(null, "/net_hasor_core_environment/simple-config.xml");
assert "my my my".equals(env.evalString("%MY_ENV%"));
assert "with app".equals(env.evalString("%CONFLICTS_VAR%")
Map<String, String> envMap = new HashMap<String, String>();
envMap.put("CONFLICTS_VAR", "with env");
env = new StandardEnvironment(null, "/net_hasor_core_environment/simple-config.xml", envMap, Thread.currentThread().getContextClassLoader());
assert "with env".equals(env.evalString("%CONFLI
```
<Overlap Ratio: 0.9497041420118343>

---

--- 54 --
Question ID: 89aaa2b36a7cb677b7e7a1d9c911382031ef7316
Original Code:
```
public class ExtensionUtility {

    public static PsiDirectory getExtensionDirectory(@NotNull AnActionEvent event) {
        Project project = event.getData(PlatformDataKeys.PROJECT);
        if (project == null) {
            return null;
        }
        DataContext dataContext = event.getDataContext();
        IdeView view = LangDataKeys.IDE_VIEW.getData(dataContext);
        if (view == null) {
            return null;
        }
        PsiDirectory[] directories = view.getDirectories();
        if (directories.length == 0) {
            return null;
        }
        return FilesystemUtil.findParentExtensionDirectory(directories[0]);
    }

    @Nullable
    public static String findDefaultNamespace(@NotNull PsiDirectory extensionRootDirectory) {
        PsiDirectory classesDirectory = extensionRootDirectory.findSubdirectory("Classes");
        if (classesDirectory == null) {
            return null;
        }
        VirtualFile composerManifest = ExtensionUtility.findComposerManifest(extensionRootDirectory);
        if (composerManifest != null) {
            String[] namespaces = ComposerUtil.findNamespaces(composerManifest);
            if (namespaces.length != 0) {
                return namespaces[0];
            }
        }
        PsiFile extEmConf = findExtEmConfPsiFile(extensionRootDirectory);
        if (extEmConf != null) {
            String[] namespaces = ExtensionUtility.extractPsr4NamespacesFromExtEmconf(extEmConf);
            if (namespaces.length != 0) {
                return namespaces[0];
            }
        }
        List<String> strings = PhpNamespaceCompositeProvider.INSTANCE.suggestNamespaces(classesDirectory);
        if (strings.size() == 0 || strings.get(0).isEmpty()) {
            return null;
        }
        return strings.get(0);
    }

    private static String[] extractPsr4Namespaces(@NotNull VirtualFile extEmConf) {
        return new String[0];
    }

    private static String[] extractPsr4NamespacesFromExtEmconf(@NotNull PsiFile extEmConf) {
        ExtEmconfNamespacesVisitor phpElementVisitor = new ExtEmconfNamespacesVisitor();
        phpElementVisitor.visitFile(extEmConf);
        return phpElementVisitor.getNamespaces();
    }

    private static VirtualFile findExtEmConf(@NotNull PsiDirectory extensionRootDirectory) {
        PsiFile file = extensionRootDirectory.findFile("ext_emconf.php");
        if (file == null) {
            return null;
        }
        return file.getVirtualFile();
    }

    private static PsiFile findExtEmConfPsiFile(@NotNull PsiDirectory extensionRootDirectory) {
        return extensionRootDirectory.findFile("ext_emconf.php");
    }

    private static VirtualFile findComposerManifest(@NotNull PsiDirectory extensionRootDirectory) {
        PsiFile file = extensionRootDirectory.findFile("composer.json");
        if (file == null) {
            return null;
        }
        return file.getVirtualFile();
    }

    private static class ExtEmconfNamespacesVisitor extends PsiRecursiveElementVisitor {

        private List<String> ns;

        @Override
        public void visitElement(@NotNull PsiElement element) {
            if (PlatformPatterns.psiElement(StringLiteralExpression.class).withParent(PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withParent(PlatformPatterns.psiElement(ArrayHashElement.class).withParent(PlatformPatterns.psiElement(ArrayCreationExpression.class).withParent(PlatformPatterns.psiElement(PhpElementTypes.ARRAY_VALUE).withParent(PlatformPatterns.psiElement(ArrayHashElement.class).withFirstChild(PlatformPatterns.or(PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText("'psr-4'"), PlatformPatterns.psiElement(PhpElementTypes.ARRAY_KEY).withText("\"psr-4\"")))))))).accepts(element)) {
                if (ns == null) {
                    ns = new ArrayList<>();
                }
                String contents = ((StringLiteralExpression) element).getContents();
                if (contents.contains("\\")) {
                    contents = contents.replace("\\\\", "\\");
                }
                if (contents.endsWith("\\")) {
                    ns.add(contents);
                }
                ns.add((contents + "\\"));
            }
            super.visitElement(element);
        }

        public String[] getNamespaces() {
            if (ns == null) {
                return new String[0];
            }
            return ns.toArray(new String[0]);
        }
    }

    @Nullable
    public static String findExtensionKeyFromFile(@NotNull PsiFile file) {
        return findExtensionKeyFromFile(file.getVirtualFile());
    }

    @Nullable
    public static String findExtensionKeyFromFile(@NotNull VirtualFile file) {
        VirtualFile extensionRootFolder = FilesystemUtil.findExtensionRootFolder(file);
        if (extensionRootFolder == null) {
            return null;
        }
        String extensionKey;
        VirtualFile composerJsonFile = extensionRootFolder.findChild("composer.json");
        if (composerJsonFile != null) {
            String extensionKeyFromComposerJson = ComposerUtil.findExtensionKey(composerJsonFile);
            extensionKey = Objects.requireNonNullElseGet(extensionKeyFromComposerJson, extensionRootFolder::getName);
        } else {
            extensionKey = extensionRootFolder.getName();
        }
        return extensionKey;
    }
}

```


Overlapping Code:
```
static PsiDirectory getExtensionDirectory(@NotNull AnActionEvent event) {
Project project = event.getData(PlatformDataKeys.PROJECT);
if (project == null) {
return null;
}
DataContext dataContext = event.getDataContext();
IdeView view = LangDataKeys.IDE_VIEW.getData(dataContext);
if (view == null) {
return null;
}
PsiDirectory[] directories = view.getDirectories();
if (directories.length == 0) {
return null;
}
return FilesystemUtil.findParentExtensionDirectory(directories[0]);
}
@Nullable
public static String findDefaultNamespace(@NotNull PsiDirectory extensionRootDirectory) {
PsiDirectory classesDirectory = extensionRootDirectory.findSubdirectory("Classes");
if (classesDirectory == null) {
return null;
}
VirtualFile composerManifest = ExtensionUtility.findComposerManifest(extensionRootDirectory);
if (composerManifest != null) {
String[] namespaces = ComposerUtil.findNamespaces(composerManifest);
if (namespaces.length != 0) {
return namespaces[0];
}
}
PsiFile extEmConf = findExtEmConfPsiFile(extensionRootDirectory);
if (extEmConf != null) {
String[] namespaces = ExtensionUtility.extractPsr4NamespacesFromExtEmconf(extEmConf);
if (namespaces.length != 0) {
return namespaces[0];
}
}
List<String> strings = PhpNamespaceCompositeProvider.INSTANCE.suggestNamespaces(classesDirectory);
if (strings.size() == 0 || strings.get(0).isEmpty()) {
return null;
}
return strings.get(0);
}
private static String[] extractPsr4Namespaces(@NotNull VirtualFile extEmConf) {
return new String[0];
}
private static String[] extractPsr4NamespacesFromExtEmconf(@NotNull PsiFile extEmConf) {
ExtEmconfNamespacesVisitor phpElementVisitor = new ExtEmconfNamespacesVisitor();
phpElementVisitor.visitFile(extEmConf);
return phpElementVisitor.getNamespaces();
}
private static VirtualFile findExtEmConf(@NotNull PsiDirectory extensionRootDirectory) {
PsiFile file = extensionRootDirectory.findFile("ext_emconf.php");
if (file == null) {
return null;
}
return file.getVirtualFile();

```
<Overlap Ratio: 0.9786388474913065>

---

--- 55 --
Question ID: 58a1281ad64f50e807c784278332fa731843ae46
Original Code:
```
public class FCBlockTorchBaseBurning extends FCBlockTorchBase {

    protected FCBlockTorchBaseBurning(int iBlockID) {
        super(iBlockID);
    }

    @Override
    public boolean GetCanBlockLightItemOnFire(IBlockAccess blockAccess, int i, int j, int k) {
        return true;
    }

    @Override
    public void OnFluidFlowIntoBlock(World world, int i, int j, int k, BlockFluid newBlock) {
        if (newBlock.blockMaterial == Material.water) {
            world.playAuxSFX(FCBetterThanWolves.m_iFireFizzSoundAuxFXID, i, j, k, 0);
            dropBlockAsItem_do(world, i, j, k, new ItemStack(FCBetterThanWolves.fcBlockTorchNetherUnlit.blockID, 1, 0));
        } else {
            super.OnFluidFlowIntoBlock(world, i, j, k, newBlock);
        }
    }

    @Override
    public void randomDisplayTick(World world, int i, int j, int k, Random rand) {
        Vec3 pos = GetParticalPos(world, i, j, k);
        world.spawnParticle("smoke", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D);
        world.spawnParticle("flame", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D, 0D);
    }

    protected Vec3 GetParticalPos(World world, int i, int j, int k) {
        Vec3 pos = Vec3.createVectorHelper(i + 0.5D, j + 0.92D, k + 0.5D);
        int iOrientation = GetOrientation(world, i, j, k);
        double dHorizontalOffset = 0.27D;
        if (iOrientation == 1) {
            pos.xCoord -= dHorizontalOffset;
        } else if (iOrientation == 2) {
            pos.xCoord += dHorizontalOffset;
        } else if (iOrientation == 3) {
            pos.zCoord -= dHorizontalOffset;
        } else if (iOrientation == 4) {
            pos.zCoord += dHorizontalOffset;
        } else {
            pos.yCoord -= 0.22D;
        }
        return pos;
    }
}

```


Overlapping Code:
```
ic class FCBlockTorchBaseBurning extends FCBlockTo}
@Override
public boolean GetCanBlockLightItemOnF(IBlockAccess blockAccess, int i, int j, int k) {
returrld world, int i, int j, int k, BlockFluid newBlocFCBetterThanWolves.m_iFireFizzSoundAuxFXID, i, j, k, 0);
dropBlockAsItem_do(world, i, j, k, new ;
}
}
@Override
public void randomDisplayTick(World world, int i, int j, int k, Random rand) moke", pos.xCoord, pos.yCoord, pos.zCoord, 0D, 0D,
```
<Overlap Ratio: 0.30515463917525776>

---

--- 56 --
Question ID: 0faf5feafc496ca15627b4ccf3b1a7b044eb1614
Original Code:
```
@WebService(serviceName = "vnfAdapterNotify", targetNamespace = "http://org.openecomp.mso/vnfNotify")
public class VnfAdapterNotifyServiceImpl extends AbstractCallbackService implements VnfAdapterNotify {

    private static MsoLogger msoLogger = MsoLogger.getMsoLogger(MsoLogger.Catalog.BPEL);

    private final String logMarker = "[VNF-NOTIFY]";

    @Context
    WebServiceContext wsContext;

    @WebMethod(operationName = "rollbackVnfNotification")
    @Oneway
    @RequestWrapper(localName = "rollbackVnfNotification", targetNamespace = "http://org.openecomp.mso/vnfNotify", className = "org.openecomp.mso.adapters.vnf.async.client.RollbackVnfNotification")
    @Action(input = "http://org.openecomp.mso/notify/adapterNotify/rollbackVnfNotificationRequest")
    public void rollbackVnfNotification(@WebParam(name = "messageId", targetNamespace = "") String messageId, @WebParam(name = "completed", targetNamespace = "") boolean completed, @WebParam(name = "exception", targetNamespace = "") MsoExceptionCategory exception, @WebParam(name = "errorMessage", targetNamespace = "") String errorMessage) {
        RollbackVnfNotification rollbackVnfNotification = new RollbackVnfNotification();
        rollbackVnfNotification.setMessageId(messageId);
        rollbackVnfNotification.setCompleted(completed);
        rollbackVnfNotification.setException(exception);
        rollbackVnfNotification.setErrorMessage(errorMessage);
        String method = "rollbackVnfNotification";
        Object message = rollbackVnfNotification;
        String messageEventName = "rollbackVnfNotificationCallback";
        String messageVariable = "rollbackVnfNotificationCallback";
        String correlationVariable = "VNFRB_messageId";
        String correlationValue = messageId;
        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);
    }

    @WebMethod(operationName = "queryVnfNotification")
    @Oneway
    @RequestWrapper(localName = "queryVnfNotification", targetNamespace = "http://org.openecomp.mso/vnfNotify", className = "org.openecomp.mso.adapters.vnf.async.client.QueryVnfNotification")
    @Action(input = "http://org.openecomp.mso/notify/adapterNotify/queryVnfNotificationRequest")
    public void queryVnfNotification(@WebParam(name = "messageId", targetNamespace = "") String messageId, @WebParam(name = "completed", targetNamespace = "") boolean completed, @WebParam(name = "exception", targetNamespace = "") MsoExceptionCategory exception, @WebParam(name = "errorMessage", targetNamespace = "") String errorMessage, @WebParam(name = "vnfExists", targetNamespace = "") Boolean vnfExists, @WebParam(name = "vnfId", targetNamespace = "") String vnfId, @WebParam(name = "status", targetNamespace = "") VnfStatus status, @WebParam(name = "outputs", targetNamespace = "") QueryVnfNotification.Outputs outputs) {
        String method = "queryVnfNotification";
        String messageEventName = "queryVnfNotificationCallback";
        String messageVariable = "queryVnfNotificationCallback";
        String correlationVariable = "VNFQ_messageId";
        String correlationValue = messageId;
        MsoLogger.setServiceName("MSO." + method);
        MsoLogger.setLogContext(correlationValue, "N/A");
        QueryVnfNotification message = new QueryVnfNotification();
        message.setMessageId(messageId);
        message.setCompleted(completed);
        message.setException(exception);
        message.setErrorMessage(errorMessage);
        message.setVnfExists(vnfExists);
        message.setVnfId(vnfId);
        message.setStatus(status);
        message.setOutputs(outputs);
        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);
    }

    @WebMethod(operationName = "createVnfNotification")
    @Oneway
    @RequestWrapper(localName = "createVnfNotification", targetNamespace = "http://org.openecomp.mso/vnfNotify", className = "org.openecomp.mso.adapters.vnf.async.client.CreateVnfNotification")
    @Action(input = "http://org.openecomp.mso/notify/adapterNotify/createVnfNotificationRequest")
    public void createVnfNotification(@WebParam(name = "messageId", targetNamespace = "") String messageId, @WebParam(name = "completed", targetNamespace = "") boolean completed, @WebParam(name = "exception", targetNamespace = "") MsoExceptionCategory exception, @WebParam(name = "errorMessage", targetNamespace = "") String errorMessage, @WebParam(name = "vnfId", targetNamespace = "") String vnfId, @WebParam(name = "outputs", targetNamespace = "") CreateVnfNotification.Outputs outputs, @WebParam(name = "rollback", targetNamespace = "") VnfRollback rollback) {
        String method = "createVnfNotification";
        String messageEventName = "createVnfNotificationCallback";
        String messageVariable = "createVnfNotificationCallback";
        String correlationVariable = "VNFC_messageId";
        String correlationValue = messageId;
        MsoLogger.setServiceName("MSO." + method);
        MsoLogger.setLogContext(correlationValue, "N/A");
        CreateVnfNotification message = new CreateVnfNotification();
        message.setMessageId(messageId);
        message.setCompleted(completed);
        message.setException(exception);
        message.setErrorMessage(errorMessage);
        message.setVnfId(vnfId);
        message.setOutputs(outputs);
        message.setRollback(rollback);
        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);
    }

    @WebMethod(operationName = "updateVnfNotification")
    @Oneway
    @RequestWrapper(localName = "updateVnfNotification", targetNamespace = "http://org.openecomp.mso/vnfNotify", className = "org.openecomp.mso.adapters.vnf.async.client.UpdateVnfNotification")
    @Action(input = "http://org.openecomp.mso/notify/adapterNotify/updateVnfNotificationRequest")
    public void updateVnfNotification(@WebParam(name = "messageId", targetNamespace = "") String messageId, @WebParam(name = "completed", targetNamespace = "") boolean completed, @WebParam(name = "exception", targetNamespace = "") MsoExceptionCategory exception, @WebParam(name = "errorMessage", targetNamespace = "") String errorMessage, @WebParam(name = "outputs", targetNamespace = "") UpdateVnfNotification.Outputs outputs, @WebParam(name = "rollback", targetNamespace = "") VnfRollback rollback) {
        String method = "updateVnfNotification";
        String messageEventName = "updateVnfNotificationCallback";
        String messageVariable = "updateVnfNotificationCallback";
        String correlationVariable = "VNFU_messageId";
        String correlationValue = messageId;
        MsoLogger.setServiceName("MSO." + method);
        MsoLogger.setLogContext(correlationValue, "N/A");
        UpdateVnfNotification message = new UpdateVnfNotification();
        message.setMessageId(messageId);
        message.setCompleted(completed);
        message.setException(exception);
        message.setErrorMessage(errorMessage);
        message.setOutputs(outputs);
        message.setRollback(rollback);
        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);
    }

    @WebMethod(operationName = "deleteVnfNotification")
    @Oneway
    @RequestWrapper(localName = "deleteVnfNotification", targetNamespace = "http://org.openecomp.mso/vnfNotify", className = "org.openecomp.mso.adapters.vnf.async.client.DeleteVnfNotification")
    @Action(input = "http://org.openecomp.mso/notify/adapterNotify/deleteVnfNotificationRequest")
    public void deleteVnfNotification(@WebParam(name = "messageId", targetNamespace = "") String messageId, @WebParam(name = "completed", targetNamespace = "") boolean completed, @WebParam(name = "exception", targetNamespace = "") MsoExceptionCategory exception, @WebParam(name = "errorMessage", targetNamespace = "") String errorMessage) {
        String method = "deleteVnfNotification";
        String messageEventName = "deleteVnfACallback";
        String messageVariable = "deleteVnfACallback";
        String correlationVariable = "VNFDEL_uuid";
        String correlationValue = messageId;
        MsoLogger.setServiceName("MSO." + method);
        MsoLogger.setLogContext(correlationValue, "N/A");
        DeleteVnfNotification message = new DeleteVnfNotification();
        message.setMessageId(messageId);
        message.setCompleted(completed);
        message.setException(exception);
        message.setErrorMessage(errorMessage);
        handleCallback(method, message, messageEventName, messageVariable, correlationVariable, correlationValue, logMarker);
    }
}

```


Overlapping Code:
```
ce(serviceName = "vnfAdapterNotify", targetNamespace = "http://org.openecomp.mso/vnfNotify")
public class VnfAdapterNotifyServiceImpl extends AbstractCallbackService impleme{
private static MsoLogger msoLogger = MsoLogger.getMsoLogger(MsoLogger.Catalog.BPEL);
private final Stringontext
WebServiceContext wsContext;
@WebMethod(operationName = "rollbackVnfNotification")
@Oneway
@RequestWrapper(localName = "rollbackVnfNotification", targetNamespace = "http://org.openecomp.mso/vnfNotify", className = "org.openecomp.mso.adapters.vnf.async.client.RollbackVnfNotification")
@Action(input = "http://org.openecomp.mso/notify/adapterNotify/rollbackVnfNotificationRequest")
public void rollbackVnfNotifica@WebParam(name = "messageId", targetNamespace = ""@WebParam(name = "exception", targetNamespace = ""ssage) {
RollbackVnfNotification rollbackVnfNotification = new RollbackVnfNotification();
rollbackVnfNotification.setMessageId(messageId);
rollbackVnfNotification.setCompleted(completed);
rollbackVnfNotification.setException(exception);
rollbackVnfNotification.setErrorMessage(errorMessage);
String method = "rollbackVnfNotification";
Object message = rollbackVnfNotification;
String messageEventName = "rollbackVnfNotificationCallback";
String messageVariable = "rollbackVnfNotificationCallback";
String correlationVariable = "VNFRB_messageId";
String correlationValue = messageId;
handleCallback(mesageVariable, correlationVariable, correlationValue, logMarker);
}
@WebMethod(operationName = "queryVnfNotification")
@Oneway
@RequestWrapper(localName = "queryVnfNotification", targetNamespace = "http://org.openecomp.mso/vnfNotify", className = "org.openecomp.mso.adapters.vnf.async.client.QueryVnfNotification")
@Action(input = "http://org.openecomp.mso/notify/adapterNotify/queryVnfNotificationRequest")
public void queryVnfNotificat@WebParam(name = "messageId", targetNamespace = ""@WebParam(name = "exception", targetNamespace = ""
```
<Overlap Ratio: 0.8276304533789564>

---

--- 57 --
Question ID: c59136849f7b5690912dca34634682593abcced3
Original Code:
```
@Data
@AllArgsConstructor
//@EqualsAndHashCode
@NoArgsConstructor
public class MethodEntity implements Serializable {

    private String fullName;

    private String methodName;

    private String className;

    private String packageName;

    private List<String> parameters;

    //    private List<String> callingLists;
    private HashSet<String> callingSets;

    //    private List<String> throwsName;
    private Set<String> throwsName;

    //    private List<String> catchName;
    private Set<String> catchName;

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("fullName: ").append(fullName);
        if (parameters != null) {
            builder.append("\nparameters: \n");
            if (parameters.isEmpty()) {
                builder.append("\tEmpty.");
            } else
                for (Object para : parameters) {
                    //                System.out.println(para);
                    builder.append("\t").append((String) para).append("\n");
                }
        }
        //
        builder.append("\ncallingSets: \n");
        if (callingSets == null || callingSets.isEmpty()) {
            builder.append("\tEmpty.");
        } else
            for (Object m : callingSets) {
                builder.append("\t").append(m).append("\n");
            }
        //        }
        if (throwsName != null) {
            builder.append("\nthrowsName:\n");
            if (throwsName.isEmpty()) {
                builder.append("\tEmpty.");
            } else
                for (Object s : throwsName) {
                    //                builder.append("\t").append(((SimpleType) s).getName().getFullyQualifiedName()).append("\n");
                    builder.append("\t").append((String) s).append("\n");
                }
        }
        if (catchName != null) {
            builder.append("\ncatchName:\n");
            if (catchName.isEmpty()) {
                builder.append("\tEmpty.");
            } else
                for (String s : catchName) {
                    if (!s.equals(""))
                        builder.append("\t").append(s).append("\n");
                }
        }
        return builder.toString();
    }

    @Override
    public int hashCode() {
        return fullName.hashCode() + parameters.hashCode();
    }
}

```


Overlapping Code:
```
@EqualsAndHashCode
@NoArgsConstructor
public class MethodEntity implements Serializable {
private String fullName;
private String methodName;
private String className;
private String packageName;
private List<String> parameters;
// private List<String> callingLists;
private HashSet<String> callingSets;
// private List<String> throwsName;
private Set<String> throwsName;
// private List<String> catchName;
private Set<String> catchName;
@Override
public String toString() {
StringBuilder builder = new StringBuilder();
builder.append("fullName: ").append(fullName);
if (parameters != null) {
builder.append("\nparameters: \n");
if (parameters.isEmpty()) {
ilder.append("\t").append((String) para).append("\(callingSets == null || callingSets.isEmpty()) {
bcallingSets) {
builder.append("\t").append(m).appeder.append("\nthrowsName:\n");
if (throwsName.isEmbject s : throwsName) {
// builder.append("\t").append(((SimpleType) s).getName().getFullyQualifiedName()).append("\n");
builder.append("\t").append((String) s).append("\n");
}
}
if (catchName != null) {
builder.append("\ncatchName:\n");
if (catchNamilder.append("\t").append(s).append("\n");
}
}
return builder.toString();
}
@Override
public int hashCode() {
return fullName.hashCode() + par
```
<Overlap Ratio: 0.7355712603062426>

---

--- 58 --
Question ID: f0df889c9a924965d5986a36b2a0cbf9e81b51b7
Original Code:
```
public class Saml2IdentityProviderResponse {

    @JsonProperty("issuer")
    private String issuer = null;

    @JsonProperty("settings")
    private java.util.List<SettingResponse> settings = null;

    @JsonProperty("certificates")
    private java.util.List<CertificateResponse> certificates = null;

    @JsonProperty("attribute_mappings")
    private java.util.List<RequiredAttributeMappingResponse> attributeMappings = null;

    /**
     * issuer.
     *
     * @return Saml2IdentityProviderResponse
     */
    public Saml2IdentityProviderResponse issuer(String issuer) {
        this.issuer = issuer;
        return this;
    }

    /**
     * Get issuer.
     *
     * @return issuer
     */
    @ApiModelProperty(value = "")
    public String getIssuer() {
        return issuer;
    }

    /**
     * setIssuer.
     */
    public void setIssuer(String issuer) {
        this.issuer = issuer;
    }

    /**
     * settings.
     *
     * @return Saml2IdentityProviderResponse
     */
    public Saml2IdentityProviderResponse settings(java.util.List<SettingResponse> settings) {
        this.settings = settings;
        return this;
    }

    /**
     * addSettingsItem.
     *
     * @return Saml2IdentityProviderResponse
     */
    public Saml2IdentityProviderResponse addSettingsItem(SettingResponse settingsItem) {
        if (this.settings == null) {
            this.settings = new java.util.ArrayList<>();
        }
        this.settings.add(settingsItem);
        return this;
    }

    /**
     * Get settings.
     *
     * @return settings
     */
    @ApiModelProperty(value = "")
    public java.util.List<SettingResponse> getSettings() {
        return settings;
    }

    /**
     * setSettings.
     */
    public void setSettings(java.util.List<SettingResponse> settings) {
        this.settings = settings;
    }

    /**
     * certificates.
     *
     * @return Saml2IdentityProviderResponse
     */
    public Saml2IdentityProviderResponse certificates(java.util.List<CertificateResponse> certificates) {
        this.certificates = certificates;
        return this;
    }

    /**
     * addCertificatesItem.
     *
     * @return Saml2IdentityProviderResponse
     */
    public Saml2IdentityProviderResponse addCertificatesItem(CertificateResponse certificatesItem) {
        if (this.certificates == null) {
            this.certificates = new java.util.ArrayList<>();
        }
        this.certificates.add(certificatesItem);
        return this;
    }

    /**
     * Get certificates.
     *
     * @return certificates
     */
    @ApiModelProperty(value = "")
    public java.util.List<CertificateResponse> getCertificates() {
        return certificates;
    }

    /**
     * setCertificates.
     */
    public void setCertificates(java.util.List<CertificateResponse> certificates) {
        this.certificates = certificates;
    }

    /**
     * attributeMappings.
     *
     * @return Saml2IdentityProviderResponse
     */
    public Saml2IdentityProviderResponse attributeMappings(java.util.List<RequiredAttributeMappingResponse> attributeMappings) {
        this.attributeMappings = attributeMappings;
        return this;
    }

    /**
     * addAttributeMappingsItem.
     *
     * @return Saml2IdentityProviderResponse
     */
    public Saml2IdentityProviderResponse addAttributeMappingsItem(RequiredAttributeMappingResponse attributeMappingsItem) {
        if (this.attributeMappings == null) {
            this.attributeMappings = new java.util.ArrayList<>();
        }
        this.attributeMappings.add(attributeMappingsItem);
        return this;
    }

    /**
     * Get attributeMappings.
     *
     * @return attributeMappings
     */
    @ApiModelProperty(value = "")
    public java.util.List<RequiredAttributeMappingResponse> getAttributeMappings() {
        return attributeMappings;
    }

    /**
     * setAttributeMappings.
     */
    public void setAttributeMappings(java.util.List<RequiredAttributeMappingResponse> attributeMappings) {
        this.attributeMappings = attributeMappings;
    }

    /**
     * Compares objects.
     *
     * @return true or false depending on comparison result.
     */
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Saml2IdentityProviderResponse saml2IdentityProviderResponse = (Saml2IdentityProviderResponse) o;
        return Objects.equals(this.issuer, saml2IdentityProviderResponse.issuer) && Objects.equals(this.settings, saml2IdentityProviderResponse.settings) && Objects.equals(this.certificates, saml2IdentityProviderResponse.certificates) && Objects.equals(this.attributeMappings, saml2IdentityProviderResponse.attributeMappings);
    }

    /**
     * Returns the HashCode.
     */
    @Override
    public int hashCode() {
        return Objects.hash(issuer, settings, certificates, attributeMappings);
    }

    /**
     * Converts the given object to string.
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class Saml2IdentityProviderResponse {\n");
        sb.append("    issuer: ").append(toIndentedString(issuer)).append("\n");
        sb.append("    settings: ").append(toIndentedString(settings)).append("\n");
        sb.append("    certificates: ").append(toIndentedString(certificates)).append("\n");
        sb.append("    attributeMappings: ").append(toIndentedString(attributeMappings)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces (except the first line).
     */
    private String toIndentedString(java.lang.Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }
}

```


Overlapping Code:
```
public class Saml2IdentityProviderResponse {
@JsonProperty("issuer")
private String issuer = null;
@JsonProperty("settings")
private java.util.List<SettingResponse> settings = null;
@JsonProperty("certificates")
private java.util.List<CertificateResponse> certificates = null;
@JsonProperty("attribute_mappings")
private java.util.List<RequiredAttributeMappingResponse> attributeMappings = null;
/**
* issuer.
*
* @return Saml2IdentityProviderResponse
*/
public Saml2IdentityProviderResponse issuer(String issuer) {
this.issuer = issuer;
return this;
}
/**
* Get issuer.
*
* @return issuer
*/
@ApiModelProperty(value = "")
public String getIssuer() {
return issuer;
}
/**
* setIssu
*/
public void setIssuer(String issuer) {
this.issuer = issuer;
}
/**
* settings.
*
* @return Saml2IdentityProviderResponse
*/
public Saml2IdentityProviderResponse settings(java.util.List<SettingResponse> settings) {
this.settings = settings;
return this;
}
/**
* addSettingsItem.
*
* @return Saml2IdentityProviderResponse
*/
public Saml2IdentityProviderResponse addSettingsItem(SettingResponse settingsItem) {
if (this.settings == null) {
this.settings = new java.util.ArrayList<>();
}
this.settings.add(settingsItem);
return this;
}
/**
* Get settings.
*
* @return settings
*/
@ApiModelProperty(value = "")
public java.util.List<SettingResponse> getSettings() {
return settings;
}
/**
* setSettings void setSettings(java.util.List<SettingResponse> settings) {
this.settings = settings;
}
/**
* certificates.
*
* @return Saml2IdentityProviderResponse
*/
public Saml2IdentityProviderRva.util.List<CertificateResponse> certificates) {
this.certificates = certificates;
return this;
}
/**
* addCertificatesItem.
*
* @return Saml2IdentityProviderResponse
*/
public Saml2IdentityProviderResponse addCertificatesItem(CertificateResponse certificatesItem) {
if (this.certificates == null) {
this.certificates = new java.util.ArrayList<>();
}
this.certificates.add(certificatesItem);
return 
```
<Overlap Ratio: 0.9781094527363184>

---

--- 59 --
Question ID: 04487734330501eece391abc11eeabec9bbaa619
Original Code:
```
class LayerRulesTest {

    @Test
    void layerControllerMayNotBeAccessed() {
        getLayeredArchitectur().whereLayer("Controller").mayNotBeAccessedByAnyLayer().check(SHOWCASECLASSES);
    }

    @Test
    void layerBoundaryMayOnlyBeAccessedFromController() {
        getLayeredArchitectur().whereLayer("Boundary").mayOnlyBeAccessedByLayers("Controller").check(SHOWCASECLASSES);
    }

    @Test
    void layerRepositoryMayOnlyBeAccessedFromBoundary() {
        getLayeredArchitectur().whereLayer("Repository").mayOnlyBeAccessedByLayers("Boundary").check(SHOWCASECLASSES);
    }

    @Test
    void layerEntityMayNotAccessOtherLayers() {
        noClasses().that().resideInAnyPackage("..entity..").should().accessClassesThat().resideInAnyPackage("..controller..", "..services..", "respository..").check(SHOWCASECLASSES);
    }

    @Test
    void noUnwantedNewPackages() {
        noClasses().that().areNotAnnotatedWith(SpringBootApplication.class).should().resideOutsideOfPackages("..controller", "..boundary", "..repository", "..entity", "..dto", "..common", "..architecture").check(SHOWCASECLASSES);
    }

    @Test
    void freeOfCycles() {
        // then check those slices for cyclic dependencies
        SlicesRuleDefinition.slices().matching("..benjamineckstein.(*)..").should().beFreeOfCycles().check(SHOWCASECLASSES);
    }

    @Test
    @Disabled
    void testThatTopTierPackagesAreIndependend() {
        // checks all subpackages of 'myapp' for cycles
        SlicesRuleDefinition.slices().matching("..benjamineckstein.(**)").should().notDependOnEachOther().check(SHOWCASECLASSES);
    }

    @Test
    void freeOfCycles3() {
        // then check those slices for not having any dependencies on each other
        SlicesRuleDefinition.slices().matching("..benjamineckstein.(**).service..").should().notDependOnEachOther().check(SHOWCASECLASSES);
    }

    private Architectures.LayeredArchitecture getLayeredArchitectur() {
        return layeredArchitecture().layer("Controller").definedBy("..controller..").layer("Boundary").definedBy("..boundary..").layer("Entity").definedBy("..entity..").layer("Repository").definedBy("..repository..");
    }
}

```


Overlapping Code:
```
d layerControllerMayNotBeAccessed() {
getLayeredAr.whereLayer("Controller").mayNotBeAccessedByAnyLayer(
void layerBoundaryMayOnlyBeAccessedFromController(SHOWCASECLASSES);
}
@Test
void layerRepositoryMayOnlyBeAccessedFromBoundary() {
getLayeredArchitecthereLayer("Repository").mayOnlyBeAccessedByLayers(st
void layerEntityMayNotAccessOtherLayers() {
noC.should().accessClassesThat().resideInAnyPackage("..controller..", "..services..", "respository..then check those slices for cyclic dependencies
SlicesRuleDefinition.sli@Test
@Disabled
void testThatTopTierPackagesAreIndependend() {
// checks all subpackages of 'myapp' for cycles
SlicesRuleDefinition.slices().ma
// then check those slices for not having any dependencies on each other
SlicesRuleDefinition.slicetectures.LayeredArchitecture getLayeredArchitectur
```
<Overlap Ratio: 0.416241062308478>

---

--- 60 --
Question ID: 21acef61c95ebaa70ee8aa8170419592df0fc1f2
Original Code:
```
public class MessageBodyHeadersWriter implements MessageBodyWriter<Object> {

    private HttpServletResponse response;

    private MessageBodyWriter<Object> wrapped;

    //
    @SuppressWarnings("unchecked")
    public MessageBodyHeadersWriter(HttpServletResponse response, MessageBodyWriter<?> writer) {
        this.response = response;
        this.wrapped = (MessageBodyWriter<Object>) writer;
    }

    //
    @Override
    public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {
        return wrapped.isWriteable(type, genericType, annotations, mediaType);
    }

    //
    @Override
    public long getSize(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {
        return wrapped.getSize(entity, type, genericType, annotations, mediaType);
    }

    //
    @Override
    public void writeTo(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {
        wrapped.writeTo(entity, type, genericType, annotations, mediaType, httpHeaders, new HeadersWriterOutputStream(entityStream, response, httpHeaders));
    }

    public void writeTo(ReturnObjectInfo info, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {
        wrapped.writeTo(info.entity(), info.type(), info.genericType(), info.annotations(), mediaType, httpHeaders, new HeadersWriterOutputStream(entityStream, response, httpHeaders));
    }

    private static class HeadersWriterOutputStream extends FilterOutputStream {

        private static final Http HTTP = new Http();

        private boolean done;

        private HttpServletResponse response;

        private MultivaluedMap<String, Object> httpHeaders;

        HeadersWriterOutputStream(OutputStream out, HttpServletResponse response, MultivaluedMap<String, Object> httpHeaders) {
            super(out);
            this.response = response;
            this.httpHeaders = httpHeaders;
        }

        private void writeHeaders() {
            if (done) {
                return;
            }
            done = true;
            if (httpHeaders == null) {
                return;
            }
            HTTP.writeHeaders(response, httpHeaders);
        }

        //
        @Override
        public void write(int b) throws IOException {
            writeHeaders();
            super.write(b);
        }

        //
        @Override
        public void write(byte[] b) throws IOException {
            writeHeaders();
            super.write(b);
        }

        //
        @Override
        public void write(byte[] b, int off, int len) throws IOException {
            writeHeaders();
            super.write(b, off, len);
        }

        //
        @Override
        public void flush() throws IOException {
            writeHeaders();
            super.flush();
        }

        //
        @Override
        public void close() throws IOException {
            writeHeaders();
            super.close();
        }
    }
}

```


Overlapping Code:
```
dyHeadersWriter implements MessageBodyWriter<Object> {
private HttpServletResponse response;
privater(HttpServletResponse response, MessageBodyWriter<?> writer) {
this.response = response;
this.wrappe
@Override
public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {
return wrapped.isWriteable(type, genericType, annotations, mediaType);
}
erride
public long getSize(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {
return wrapped.getSize(entity, ty
@Override
public void writeTo(Object entity, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {
wrapped.writeTo(entity, type, genericType, annotations, mediaType, httpHeaders, utStream(entityStream, response, httpHeaders));
}
public void writeTo(ReturnObjectInfo info, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {
wrapped.writeTo(info.entity(), info.type(), info.genericType(), info.annotationutStream(entityStream, response, httpHeaders));
}
private static class HeadersWriterOutputStream extends FilterOutputStream {
private static final Http HTTP = new Http();
private boolean done;
private HttpServletResponse response;
private MultivaluedMap<String, Object> httpHeaders;
HeadersWriterOutputStream(OutputStream out, HttpServletResponse response, MultivaluedMap<String, Object> httpHeaders) {
super(out);
this.response = response;
this.httpHeaders = httpHeaders;
}
private void writeHeaders() {
if (done) {
return;
}
done = true;
if (httpHeaders == null) {
return;
}
HTTP.writeHeaders(respo
```
<Overlap Ratio: 0.8394538606403014>

---

--- 61 --
Question ID: 94049e169d9faa662dadee598b08f54cfa434623
Original Code:
```
public class FilesTest {

    public static void main(String[] args) throws Exception {
        // ??????
        String workDir = System.getProperty("user.dir");
        // ????
        String className = Thread.currentThread().getStackTrace()[1].getClassName();
        // ????
        String classPath = workDir + "\\src\\main\\java\\" + className;
        // ??????"."
        String currentClass = classPath.replace(".", "\\") + ".java";
        // ??????currentClass?????files.txt
        Files.copy(Paths.get(currentClass), new FileOutputStream("testFile\\files.txt"));
        // ??FilesTest.java???????
        System.out.println(Files.isHidden(Paths.get(currentClass)));
        // ?????FilesTest.java??????
        List<String> lines = Files.readAllLines(Paths.get(currentClass), Charset.forName("UTF-8"));
        System.out.println(lines);
        // ?????????
        System.out.println("FilesTest.java?????" + Files.size(Paths.get(currentClass)));
        List<String> poem = new ArrayList<String>();
        poem.add("?????");
        poem.add("?????");
        // ??????????????files.txt?
        Files.write(Paths.get("testFile\\files.txt"), poem, Charset.forName("UTF-8"));
        // ??C??????????
        FileStore cStore = Files.getFileStore(Paths.get(currentClass));
        System.out.println("C??????" + cStore.getTotalSpace());
        System.out.println("C???????" + cStore.getUsableSpace());
    }
}

```


Overlapping Code:
```
public class FilesTest {
public static void main(String[] args) throws Exception {
// 
String className = Thread.currentThread().getStackTrace()[1].getClassName();
/th = workDir + "\\src\\main\\java\\" + className;
String currentClass = classPath.replace(".", "\\") + ".java
System.out.println(Files.isHidden(Paths.get(curre
List<String> lines = Files.readAllLines(Paths.get(currentCl));
List<String> poem = new ArrayList<String>();
p
```
<Overlap Ratio: 0.3586776859504132>

---

--- 62 --
Question ID: 3b3405f0a50720b0ea3fa6ab7ba19be695a6240c
Original Code:
```
public class NullabilityTest {

    @Test
    public void test() {
        final Settings settings = TestUtils.settings();
        settings.nullableAnnotations.add(Nullable.class);
        settings.nullabilityDefinition = NullabilityDefinition.undefinedInlineUnion;
        settings.sortDeclarations = true;
        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));
        final String expected = "" + "interface A<T> {\n" + "    data?: T;\n" + "    isNonNullableFlag: boolean;\n" + "    isNullableFlag?: boolean;\n" + "    nonNullableBoolean: boolean;\n" + "    nonNullableString: string;\n" + "    nullableArray?: (string | undefined)[];\n" + "    nullableBoolean?: boolean;\n" + "    nullableGenericArray?: (T | undefined)[];\n" + "    nullableGenericType?: T;\n" + "    nullableList?: (string | undefined)[];\n" + "    nullableString?: string;\n" + "    test: string;\n" + "    testNullable?: string;\n" + "}";
        Assert.assertEquals(expected.trim(), output.trim());
    }

    private static class A<T> {

        @Nullable
        public String nullableString;

        public String nonNullableString;

        @Nullable
        public List<@Nullable String> nullableList;

        @Nullable
        public String @Nullable [] nullableArray;

        @Nullable
        public T @Nullable [] nullableGenericArray;

        @Nullable
        public T nullableGenericType;

        @Nullable
        public Boolean nullableBoolean;

        public Boolean nonNullableBoolean;

        @Nullable
        public Boolean isNullableFlag;

        public Boolean isNonNullableFlag;

        @Nullable
        public <B extends T> B getData() {
            return null;
        }

        public String getTest() {
            return "";
        }

        @Nullable
        public String getTestNullable() {
            return null;
        }
    }

    @Test
    public void testVariants() {
        testVariant(NullabilityDefinition.nullAndUndefinedUnion, "list?: Nullable<Nullable<string>[]>", "type Nullable<T> = T | null | undefined");
        testVariant(NullabilityDefinition.undefinedUnion, "list?: Nullable<Nullable<string>[]>", "type Nullable<T> = T | undefined");
        testVariant(NullabilityDefinition.nullUnion, "list: Nullable<Nullable<string>[]>", "type Nullable<T> = T | null");
        testVariant(NullabilityDefinition.nullAndUndefinedInlineUnion, "list?: (string | null | undefined)[] | null");
        testVariant(NullabilityDefinition.undefinedInlineUnion, "list?: (string | undefined)[]");
        testVariant(NullabilityDefinition.nullInlineUnion, "list: (string | null)[] | null");
    }

    private static void testVariant(NullabilityDefinition nullabilityDefinition, String... expected) {
        final Settings settings = TestUtils.settings();
        settings.nullableAnnotations.add(Nullable.class);
        settings.nullabilityDefinition = nullabilityDefinition;
        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));
        for (String s : expected) {
            Assert.assertTrue(output.contains(s));
        }
    }

    private static class B {

        @Nullable
        public List<@Nullable String> list;
    }

    @Test
    public void testCombinationsOfOptionalAndNullable() {
        testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration.questionMark, NullabilityDefinition.nullInlineUnion, "list?: (string | null)[] | null;");
        testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration.nullableType, NullabilityDefinition.nullInlineUnion, "list: (string | null)[] | null;");
        testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration.nullableAndUndefinableType, NullabilityDefinition.nullAndUndefinedInlineUnion, "list: (string | null | undefined)[] | null | undefined;");
        testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration.nullableType, NullabilityDefinition.nullAndUndefinedUnion, "list: Nullable<Nullable<string>[]> | null;");
    }

    private static void testCombinationOfOptionalAndNullable(OptionalPropertiesDeclaration optionalPropertiesDeclaration, NullabilityDefinition nullabilityDefinition, String expected) {
        final Settings settings = TestUtils.settings();
        settings.optionalAnnotations.add(Nullable.class);
        settings.nullableAnnotations.add(Nullable.class);
        settings.optionalPropertiesDeclaration = optionalPropertiesDeclaration;
        settings.nullabilityDefinition = nullabilityDefinition;
        final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(B.class));
        Assert.assertTrue("Unexpected actual output: " + output, output.contains(expected));
    }

    @Test(expected = RuntimeException.class)
    public void testNullableAnnotationTarget() {
        final Settings settings = TestUtils.settings();
        settings.nullableAnnotations.add(javax.annotation.Nullable.class);
        new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));
    }
}

```


Overlapping Code:
```
st {
@Test
public void test() {
final Settings settings = TestUtils.settings();
settings.nullableAnnotations.add(Nullable.class);
settings.nullabilityDefinition = NullabilityDefinition.undefinedInlineUnion;
settings.sortDeclarations = true;
final String output = new TypeScriptGenerator(settings).generateTypeScript(Input.from(A.class));
final String esert.assertEquals(expected.trim(), output.trim());
}
privatl;
}
}
@Test
public void testVariants() {
testVariant(NullabilityDefinition.nullAndUndefinedUnion, "list?: Nullable<Nullable<string>[]>", "type Nullable<T> = T | null | undefined");
testVariant(NullabilityDefinition.undefinedUnion, "list?: Nullable<Nullable<string>[]>", "type Nullable<T> = T | undefined");
testVariant(NullabilityDefinition.nullUnion, "list: Nullable<Nullable<string>[]>", "type Nullable<T> = T | null");
testVariant(NullabilityDefinition.nullAndUndefinedInlineUnion, "list?: (string | null | undefined)[] | null");
testVariant(Null
```
<Overlap Ratio: 0.4611324376199616>

---

--- 63 --
Question ID: 48385fa6bc6bfb5933e597d776cf834b02f5dee2
Original Code:
```
public class HandsVisualization extends GenericWindow implements Visualization {

    HandsRenderer renderer;

    @Override
    public void show() {
        renderer.setSize(640, 480);
        viewFrame.add("Center", renderer);
        viewFrame.setSize(renderer.getWidth(), renderer.getHeight());
        viewFrame.setVisible(true);
        new Thread(this).start();
    }

    public HandsVisualization(NiTETracker tracker, String name) {
        super(name);
        renderer = new HandsRenderer(tracker.getHandTracker());
        tracker.addHandsListener(renderer);
    }
}

```


Overlapping Code:
```
blic class HandsVisualization extends GenericWindow implements Visualization {
HandsRenderer renderer;
@Override
public void show() {
renderer.setSize(640, 480);
viewFrame.add("Center", renderer);
viewFrame.setSize(renderer.getWidth(), renderer.getHeight());
viewFrame.setVisible(true);
new Thread(this).start();
}
public HandsVisualization(NiTETracker tracker, String name) {
super(name);
renderer = new HandsRenderer(tracker.getHandTracker());
trac
```
<Overlap Ratio: 0.9240246406570842>

---

--- 64 --
Question ID: 6f4c2c53552e653c27c8464de45584da3459e70a
Original Code:
```
public class FastMarchingMethodMovementStrategy extends DefaultMovementStrategy {

    /**
     * The default radius to respect other people in the neighbourhood in.l
     */
    public static final int DEFAULT_RADIUS = 3;

    /**
     * Name of the strategy.
     */
    public static final String NAME = "Fast marching method";

    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)
    public FastMarchingMethodMovementStrategy(@JsonProperty("mollifierConfiguration") MollifierConfiguration mollifierConfiguration, @JsonProperty("radius") int radius) {
        super(mollifierConfiguration, radius);
    }

    @Override
    public String getName() {
        return FastMarchingMethodMovementStrategy.NAME;
    }

    /**
     * Calculate the utility function using the fast marching method.
     *
     * @param state  to calculate on
     * @param target to calculate from
     * @return the utility function in a discrete matrix form
     */
    @Override
    public double[][] calculateBasePotential(State state, Location target) {
        FastMarchingMethod fmm = new FastMarchingMethod(state.getRows(), state.getColumns(), (location) -> {
            Optional<SimObject> occupant = state.getCellOccupant(location);
            if (occupant.isPresent() && occupant.get().getType() == SimObjectType.OBSTACLE) {
                // Avoid obstacles!
                return Double.MAX_VALUE;
            }
            return null;
        }, (location) -> 1.0);
        fmm.calculate(target);
        return fmm.getResult();
    }
}

```


Overlapping Code:
```
gy extends DefaultMovementStrategy {
/**
* The default radius to respect other people in the neighbourhood in.l
*/
public static final int DEFAULT_RADIUS = 3;
/**
* Name of the strategy.
*/
public static final String NAME = "Fast marching method";
@JsonCreator(mode = JsonCreator.Mode.PROPERTIES)
public rty("mollifierConfiguration") MollifierConfiguration mollifierConfiguer(mollifierConfiguration, radius);
}
@Override
public String getName() {
return FastMarchingMethodMovementStrategy.NAME;
}
/**
* Calculate the utility function using the fast marching method.
*
* @param state to calculate on
* @param target to calculate from
* @return the utility function in a discrete matrix form
*/
@Override
public double[][] calculateBasePotential(State state, Location target) {
FastMarchingMethod fmm = newnt = state.getCellOccupant(location);
if (occupant.isPresent() && occupant.get().getType() == SimObj
```
<Overlap Ratio: 0.698069498069498>

---

--- 65 --
Question ID: 9cedeea0468199cd3b728e960a264b645131c05c
Original Code:
```
final class ExpandedRow {

    private final List<ExpandedPair> pairs;

    private final int rowNumber;

    private final boolean wasReversed;

    ExpandedRow(List<ExpandedPair> list, int i, boolean z) {
        this.pairs = new ArrayList(list);
        this.rowNumber = i;
        this.wasReversed = z;
    }

    /* access modifiers changed from: package-private */
    public List<ExpandedPair> getPairs() {
        return this.pairs;
    }

    /* access modifiers changed from: package-private */
    public int getRowNumber() {
        return this.rowNumber;
    }

    /* access modifiers changed from: package-private */
    public boolean isReversed() {
        return this.wasReversed;
    }

    /* access modifiers changed from: package-private */
    public boolean isEquivalent(List<ExpandedPair> list) {
        return this.pairs.equals(list);
    }

    public String toString() {
        return "{ " + this.pairs + " }";
    }

    public boolean equals(Object obj) {
        if (!(obj instanceof ExpandedRow)) {
            return false;
        }
        ExpandedRow expandedRow = (ExpandedRow) obj;
        if (!this.pairs.equals(expandedRow.getPairs()) || this.wasReversed != expandedRow.wasReversed) {
            return false;
        }
        return true;
    }

    public int hashCode() {
        return this.pairs.hashCode() ^ Boolean.valueOf(this.wasReversed).hashCode();
    }
}

```


Overlapping Code:
```
xpandedRow {
private final List<ExpandedPair> pairs;
private final int rowNumber;
private final boolean wasReversed;
ExpandedRow(List<ExpandedPair> list, int i, boolean z) {
this.pairs = new ArrayList(list);
this.rowNumber = i;
this.wasReversed = z;
}
/* access modifiers changed from: package-private */
public List<ExpandedPair> getPairs() {
return this.pairs;
}
/* access modifiers changed from: package-private */
public int getRowNumber() {
return this.rowNumber;
}
/* access modifiers changed from: package-private */
public boolean isReversed() {
return this.wasReversed;
}
/* access modifiers changed from: package-private */
public boolean isEquivalent(List<ExpandedPair> list) {
return this.pairs.equals(list);
}
public String toString() {
return "{ " + this.pairs + " }";
}
public boolean equals(Object obj) {
if (!(obj instanceof ExpandedRow)) {
return false;
}
ExpandedRow expandedRow = (ExpandedRow) obj;
if (!this.pairs.equals(expandedRow.getPairs()) || this.wasReversed != expandedRow.wasReversed) {
return false;
}
return true;
}
public int hashCode() {
return this.pairs.hashCode() ^ Boolean.valueOf(this.wasReversed).h
```
<Overlap Ratio: 0.9768041237113402>

---

--- 66 --
Question ID: e040e3b45ccd4ca8119c5d2712b3808c26c479df
Original Code:
```
public class UI {

    public static float windowWidth;

    public static float windowHeight;

    private static float newWindowHeight = -1;

    private static float newWindowWidth = -1;

    protected static CopyOnWriteArrayList<Widget> components = new CopyOnWriteArrayList<>();

    private static Queue<Runnable> imguiThread = new ConcurrentLinkedQueue<>();

    private static boolean async;

    private static WindowResizeEvent resizeEvent;

    protected static LongAdder globalCounter = new LongAdder();

    protected static float tabBottomBorderOffset = 7.1f;

    private static Application app;

    protected static JImFontAtlas fonts;

    private static ConcurrentLinkedQueue<String> ids = new ConcurrentLinkedQueue<>();

    private static SerializableConsumer<WindowResizeEvent> resizeEventSerializableConsumer;

    private static boolean readyCalledFlag;

    private static String windowTitle;

    private static void init(Application app, Runnable r) {
        JniLoader.load();
        JImGuiUtil.cacheStringToBytes();
        try (JImGui jimgui = new JImGui(app.getWidth(), app.getHeight(), app.getTitle())) {
            UI.windowHeight = app.getHeight();
            UI.windowWidth = app.getWidth();
            windowTitle = app.getTitle();
            resizeEvent = new WindowResizeEvent(windowWidth, windowHeight, windowWidth, windowHeight);
            app.setupTheme(jimgui);
            Window.globalXPadding = jimgui.getStyle().getWindowPaddingX();
            Window.globalYPadding = jimgui.getStyle().getWindowPaddingY();
            fonts = jimgui.getIO().getFonts();
            fonts.addDefaultFont();
            app.loadFonts(fonts);
            r.run();
            for (; !jimgui.windowShouldClose(); ) {
                if (!app.getTitle().equals(windowTitle)) {
                    jimgui.setWindowTitle(new JImStr(app.getTitle()));
                    windowTitle = app.getTitle();
                }
                float newY = jimgui.getPlatformWindowSizeY();
                float newX = jimgui.getPlatformWindowSizeX();
                //window resize event
                if (newY != windowHeight || newX != windowWidth) {
                    resizeEvent.setOldHeight(windowHeight);
                    resizeEvent.setOldWidth(windowWidth);
                    resizeEvent.setNewHeight(newY);
                    resizeEvent.setNewWidth(newX);
                    UI.windowHeight = jimgui.getPlatformWindowSizeY();
                    UI.windowWidth = jimgui.getPlatformWindowSizeX();
                    Window.reApplyRelativeSize();
                    Popup.reApplyRelativeSize();
                    Notification.reApplyAlignmenToAll();
                    if (resizeEventSerializableConsumer != null) {
                        resizeEventSerializableConsumer.accept(resizeEvent);
                    }
                }
                //window size programatically changed
                if (newWindowHeight > -1 || newWindowWidth > -1) {
                    jimgui.setPlatformWindowSize(newWindowWidth, newWindowHeight);
                    newWindowHeight = -1;
                    newWindowWidth = -1;
                }
                jimgui.initNewFrame();
                process(jimgui);
                jimgui.render();
                if (!readyCalledFlag) {
                    if (app.getReady() != null) {
                        app.getReady().run();
                    }
                    readyCalledFlag = true;
                }
            }
        }
    }

    public static void render(Runnable r) {
        app = new Application("flui", 1200, 700);
        init(app, r);
    }

    public static void render(Application app, Runnable r) {
        init(app, r);
    }

    public static void renderAsync(Runnable r) {
        async = true;
        app = new Application("flui", 1200, 700);
        new Thread(() -> {
            init(app, r);
        }).start();
    }

    public static void renderAsync(Application app, Runnable r) {
        async = true;
        new Thread(() -> {
            init(app, r);
        }).start();
    }

    public static void setWindowSize(float w, float h) {
        if (async) {
            runLater(() -> {
                newWindowHeight = h;
                newWindowWidth = w;
            });
        } else {
            newWindowHeight = h;
            newWindowWidth = w;
        }
    }

    public static void setWindowWidth(float w) {
        if (async) {
            runLater(() -> {
                setWindowSize(w, windowHeight);
            });
        } else {
            setWindowSize(w, windowHeight);
        }
    }

    public static void setWindowHeight(float h) {
        if (async) {
            runLater(() -> {
                setWindowSize(windowWidth, h);
            });
        } else {
            setWindowSize(windowWidth, h);
        }
    }

    public static void onWindowResize(SerializableConsumer<WindowResizeEvent> e) {
        resizeEventSerializableConsumer = e;
    }

    protected static void addID(String id) {
        ids.add(id);
    }

    protected static boolean idExists(String id) {
        return (ids.contains(id));
    }

    protected static void add(Widget w) {
        if (idExists(w.id)) {
            System.err.println("ERROR: '" + w.id + "' has already been used as an identifier, ID's must be unique!");
            throw new RuntimeException("Duplicate ID : " + w.id);
        }
        addID(w.id);
        components.add(w);
    }

    public static void runLater(Runnable r) {
        imguiThread.add(r);
    }

    protected static void process(JImGui imgui) {
        for (int i = 0; i < components.size(); i++) {
            components.get(i).render(imgui);
        }
        Iterator<Runnable> it = imguiThread.iterator();
        for (; it.hasNext(); ) {
            Runnable r = it.next();
            try {
                r.run();
            } catch (Exception e) {
            }
            it.remove();
        }
    }
}

```


Overlapping Code:
```
float windowWidth;
public static float windowHeight;
private static float newWindowHeight = -1;
private static float newWindowWidth = -1;
protected static CopyOnWriteArrayList<Widget> components = new CopyOnWriteArrayList<>();
private static Queue<Runnable> imguiThread = new ConcurrentLinkedQueue<>();
private static boolean async;
private static WindowResizeEvent resizeEvent;
protected static LongAdder globalCounter = new LongAdder();
protected static float tabBottomBorderOffset = 7.1f;
private static Application app;
protected static JImFontAtlas fonts;
private static ConcurrentLinkedQueue<String> ids = new ConcurrentLinkedQueue<>();
private static SerializableConsumer<WindowResizeEvent> resizeEventSerializableConsumer;
private static boolean readyCalledFlag;
private static String windowTitle;
private static void init(Application app, Runnable r) {
JniLoader.load();
JImGuiUtil.cacheStringToBytes();
try (JImGui jimgui = new JImGui(app.getWidth(), app.getHeight(), app.getTitle())) {
UI.windowHeight = app.getHeight();
UI.windowWidth = app.getWidth();
windowTitle = app.getTitle();
resizeEvent = new WindowResizeEvent(windowWidth, windowHeight, windowWidth, windowHeight);
app.setupTheme(jimgui);
Window.globalXPadding = jimgui.getStyle().getWindowPaddingX();
Window.globalYPadding = jimgui.getStyle().getWindowPaddingY();
fonts = jimgui.getIO().getFonts();
fonts.addDefaultFont();
app.loadFonts(fonts);
r.run();
for (; !jimgui.windle)) {
jimgui.setWindowTitle(new JImStr(app.getTitle()));
windowTitle = app.getTitle();
}
float newY = jimgui.getPlatformWindowSizeY();
float newX = jimgui.getPlatformWindowSizeX();
//window resize event
if (newY != windowHeight || newX != windowWidth) {
resizeEvent.setOldHeight(windowHeight);
resizeEvent.setOldWidth(windowWidth);
resizeEvent.setNewHeight(newY);
resizeEvent.setNewWidth(newX);
UI.windowHeight = jimgui.getPlatformWindowSizeY();
UI.
```
<Overlap Ratio: 0.9522613065326633>

---

--- 67 --
Question ID: 88dd300f77e53e19d8f96d18b70087d68f88fb62
Original Code:
```
@RunWith(Parameterized.class)
public class InstantiatedLambdasTestRunner extends TestBase {

    static final Class<?> CLASS = InstantiatedLambdasTest.class;

    static final Class<?>[] CLASSES = InstantiatedLambdasTest.CLASSES;

    static final String EXPECTED = StringUtils.lines("Class implementation", "Lambda implementation");

    private final TestParameters parameters;

    private Path inputJar;

    @Parameters(name = "{0}")
    public static TestParametersCollection data() {
        return getTestParameters().withAllRuntimesAndApiLevels().build();
    }

    public InstantiatedLambdasTestRunner(TestParameters parameters) {
        this.parameters = parameters;
    }

    @Before
    public void writeAndRunInputJar() throws IOException {
        inputJar = temp.getRoot().toPath().resolve("input.jar");
        ArchiveConsumer buildInput = new ArchiveConsumer(inputJar);
        for (Class<?> clazz : CLASSES) {
            buildInput.accept(ByteDataView.of(ToolHelper.getClassAsBytes(clazz)), DescriptorUtils.javaTypeToDescriptor(clazz.getName()), null);
        }
        buildInput.finished(null);
    }

    @Test
    public void testProguard() throws Exception {
        assumeTrue(parameters.isCfRuntime());
        buildAndRunProguard("pg.jar", false);
    }

    @Test
    public void testProguardAggressive() throws Exception {
        assumeTrue(parameters.isCfRuntime());
        buildAndRunProguard("pg-aggressive.jar", true);
    }

    @Test
    public void testR8() throws Exception {
        testR8(false);
    }

    @Test
    public void testR8Aggressive() throws Exception {
        testR8(true);
    }

    private void testR8(boolean aggressive) throws Exception {
        testForR8(parameters.getBackend()).addProgramFiles(inputJar).addKeepMainRule(CLASS).applyIf(aggressive, builder -> builder.addKeepRules("-overloadaggressively")).debug().setMinApi(parameters.getApiLevel()).compile().apply(compileResult -> compileResult.run(parameters.getRuntime(), CLASS).assertSuccessWithOutput(EXPECTED)).applyIf(parameters.isDexRuntime(), compileResult -> compileResult.runDex2Oat(parameters.getRuntime()).assertNoVerificationErrors());
    }

    private void buildAndRunProguard(String outName, boolean aggressive) throws Exception {
        Path pgConfig = writeProguardRules(aggressive);
        Path outPg = temp.getRoot().toPath().resolve(outName);
        ProcessResult proguardResult = ToolHelper.runProguard6Raw(inputJar, outPg, ToolHelper.getJava8RuntimeJar(), pgConfig, null);
        System.out.println(proguardResult.stdout);
        if (proguardResult.exitCode != 0) {
            System.out.println(proguardResult.stderr);
        }
        assertEquals(0, proguardResult.exitCode);
        ProcessResult runPg = ToolHelper.runJava(outPg, CLASS.getCanonicalName());
        assertEquals(0, runPg.exitCode);
    }

    private Path writeProguardRules(boolean aggressive) throws IOException {
        Path pgConfig = temp.getRoot().toPath().resolve("keep.txt");
        FileUtils.writeTextFile(pgConfig, "-keep public class " + CLASS.getCanonicalName() + " {", "  public static void main(...);", "}", aggressive ? "-overloadaggressively" : "# Not overloading aggressively");
        return pgConfig;
    }
}

```


Overlapping Code:
```
s InstantiatedLambdasTestRunner extends TestBase {
static final Class<?> CLASS = InstantiatedLambdasTest.class;
static final Class<?>[] CLASSES = InstantiatedLambdasTest.CLASSES;
static final String EXPECTED = StringUtils.lines("Class implementation", "Lambda implementation");
private final TestParameters parameters;
private Path inputJar;
@Parameters(name = "{0}")
public static TestParametersCollection data() {
return getTestParameters().withAllRuntimesAndApiLevels().build();
}
public InstantiatedLambdasTestRunner(TestParameters parameters) {
this.parameters = parameters;
}
@Before
public void writeAndRunInputJar() throws IOException {
inputJar = temp.getRoot().toPath().resolve("input.jar");
ArchiveConsumer buildInput = new ArchiveConsumer(inputJar);
for (Class<?> clazz : CLASSES) {
build.accept(ByteDataView.of(ToolHelper.getClassAsBytescriptorUtils.javaTypeToDescriptor(clazz.getName())null);
}
@Test
public void testProguard() throws Exception {
assumeTrue(parameters.isCfRuntime());
buildAndRunProguard("pg.jar", false);
}
@Test
public void testProguardAggressive() throws Exception {
assumeTrue(parameters.isCfRuntime());
buildAndRunProguard("pg-aggressive.jar", true);
}
@Test
public void testR8() throws Exception {
testR8(false);
}
@Test
public void testR8Aggressive() throws Exception {
testR8(true);
}
private void testR8(boolean aggressive) throws Exception {
testForR8(parameters.getBackend())rameters.getRuntime(), CLASS).assertSuccessWithOutnDex2Oat(parameters.getRuntime()).assertNoVerificationErrors());
}
private void buildAndRunProguard(String outName, boolean aggressive) throws Exception {
Path pgConfig = writeProguardRules(aggressive);
Path outPg = temp.getRoot().toPath().resolve(outName);
ProcessResult proguardResult 
```
<Overlap Ratio: 0.788314606741573>

---

--- 68 --
Question ID: 028d0eb48fa34b8302e7d54fb8e8862b7ef0b42c
Original Code:
```
public class CustomError {

    private final Logger logger;

    private boolean some_enabled = false;

    // Options
    private boolean escalate_exceptions = false;

    private boolean equal_is_strict_equal = false;

    private boolean enforce_existing_properties = false;

    private boolean boolean_op_only_boolean_operands = false;

    private boolean arith_op_no_undefined = false;

    private boolean arith_op_no_null = false;

    private boolean arith_op_no_nan = false;

    private boolean arith_op_no_infinity = false;

    private boolean division_op_no_zero = false;

    public CustomError(Logger lgr) {
        this.logger = lgr;
    }

    /**
     * Set an option for this instance.
     *
     * @param name Name of the option
     * @param value Option value
     */
    public void setOption(String name, Object value) {
        try {
            switch(name) {
                case "escalate_exceptions":
                    escalate_exceptions = (boolean) value;
                    logSetOption(name, escalate_exceptions);
                    break;
                case "equal_is_strict_equal":
                    equal_is_strict_equal = (boolean) value;
                    logSetOption(name, equal_is_strict_equal);
                    break;
                case "enforce_existing_properties":
                    enforce_existing_properties = (boolean) value;
                    logSetOption(name, enforce_existing_properties);
                    break;
                case "boolean_op_only_boolean_operands":
                    boolean_op_only_boolean_operands = (boolean) value;
                    logSetOption(name, boolean_op_only_boolean_operands);
                    break;
                case "arith_op_no_undefined":
                    arith_op_no_undefined = (boolean) value;
                    logSetOption(name, arith_op_no_undefined);
                    break;
                case "arith_op_no_null":
                    arith_op_no_null = (boolean) value;
                    logSetOption(name, arith_op_no_null);
                    break;
                case "arith_op_no_nan":
                    arith_op_no_nan = (boolean) value;
                    logSetOption(name, arith_op_no_nan);
                    break;
                case "arith_op_no_infinity":
                    arith_op_no_infinity = (boolean) value;
                    logSetOption(name, arith_op_no_infinity);
                    break;
                case "division_op_no_zero":
                    division_op_no_zero = (boolean) value;
                    logSetOption(name, division_op_no_zero);
                    break;
                default:
                    logger.warning("CustomError: Unknown option '" + name + "'");
            }
        } catch (ClassCastException cce) {
            logger.warning("CustomError: Cannot cast value for option '" + name + "'");
        }
        recalculateSomeEnabled();
    }

    private void logSetOption(String name, boolean enabled) {
        if (enabled) {
            logger.info("Custom error class '" + name + "' enabled");
        } else {
            logger.info("Custom error class '" + name + "' disabled");
        }
    }

    /**
     * Get an option value from the instance.
     *
     * @param name Name of the option
     * @return Option value
     */
    public Object getOption(String name) {
        switch(name) {
            case "escalate_exceptions":
                return this.escalate_exceptions;
            case "equal_is_strict_equal":
                return this.equal_is_strict_equal;
            case "enforce_existing_properties":
                return this.enforce_existing_properties;
            case "boolean_op_only_boolean_operands":
                return this.boolean_op_only_boolean_operands;
            case "arith_op_no_undefined":
                return this.arith_op_no_undefined;
            case "arith_op_no_null":
                return this.arith_op_no_null;
            case "arith_op_no_nan":
                return this.arith_op_no_nan;
            case "arith_op_no_infinity":
                return this.arith_op_no_infinity;
            case "division_op_no_zero":
                return this.division_op_no_zero;
            default:
                logger.warning("CustomError: Unknown option '" + name + "'");
                return null;
        }
    }

    /**
     * Check if at least one option is enabled.
     *
     * @return true, if at least one custom error class is enabled
     */
    public boolean someEnabled() {
        return this.some_enabled;
    }

    /**
     * Recalculate if at least one option is enabled.
     */
    private void recalculateSomeEnabled() {
        this.some_enabled = this.escalate_exceptions || this.equal_is_strict_equal || this.enforce_existing_properties || this.boolean_op_only_boolean_operands || this.arith_op_no_undefined || this.arith_op_no_null || this.arith_op_no_nan || this.arith_op_no_infinity || this.division_op_no_zero;
    }

    /**
     * Enable an error class, shorthand for {@link #setOption(String, Object)}.
     *
     * @param type Name of the error class
     */
    public void enable(String type) {
        setOption(type, true);
    }

    /**
     * Disable an error class, shorthand for {@link #setOption(String, Object)}.
     *
     * @param type Name of the error class
     */
    public void disable(String type) {
        setOption(type, false);
    }

    /**
     * Central method for inspecting values and firing an {@link EscalatedException}
     * depending on the return value.
     *
     * @param operation_name Operation name
     * @param value Value of the value...
     * @param line_num Line number for logging
     */
    public void inspectInputValue(String operation_name, Object value, int input_index, int line_num) {
        switch(operation_name) {
            case "JSDivideNodeGen":
                inspectDivisionZero(operation_name, value, input_index, line_num);
            // no break, division is also arithmetic operation
            case "JSAddNodeGen":
            case "JSSubtractNodeGen":
            case "JSMultiplyNodeGen":
            case "JSUnaryMinusNodeGen":
            case "JSUnaryPlusNodeGen":
            case "JSModuloNodeGen":
            case "JSAddSubNumericUnitNodeGen":
            case "SqrtNodeGen":
            case "JSExponentiateNodeGen":
                inspectArithmeticValues(operation_name, value, line_num);
                break;
            case "JSAndNode":
            case "JSOrNode":
            case "JSNotNodeGen":
                if (boolean_op_only_boolean_operands) {
                    if (!JSGuards.isBoolean(value)) {
                        logger.info("Object of type '" + value.toString() + "' for boolean operation detected (boolean_op_only_boolean_operands)");
                        throw new EscalatedException("Object of type '" + value.toString() + "' for boolean operation detected (boolean_op_only_boolean_operands). [" + operation_name + ", line " + line_num + "]");
                    }
                }
                break;
        }
    }

    private void inspectDivisionZero(String operation_name, Object value, int input_index, int line_num) {
        if (division_op_no_zero && input_index == 1) {
            Object num = JSRuntime.toNumeric(value);
            if (num instanceof BigInt) {
                BigInt bigint_num = (BigInt) num;
                if (bigint_num.equals(BigInt.ZERO)) {
                    logger.info("Detected zero value for division operation (division_op_no_zero)");
                    throw new EscalatedException("Detected zero value for division operation (division_op_no_zero). [" + operation_name + ", line " + line_num + "]");
                }
            } else if (num instanceof Integer) {
                Integer int_num = (Integer) num;
                if (int_num.equals(0)) {
                    logger.info("Detected zero value for division operation (division_op_no_zero)");
                    throw new EscalatedException("Detected zero value for division operation (division_op_no_zero). [" + operation_name + ", line " + line_num + "]");
                }
            } else if (num instanceof SafeInteger) {
                SafeInteger safeint_num = (SafeInteger) num;
                if (safeint_num.intValue() == 0) {
                    logger.info("Detected zero value for division operation (division_op_no_zero)");
                    throw new EscalatedException("Detected zero value for division operation (division_op_no_zero). [" + operation_name + ", line " + line_num + "]");
                }
            } else if (num instanceof Double) {
                Double double_num = (Double) num;
                if (double_num.equals(0.0)) {
                    logger.info("Detected zero value for division operation (division_op_no_zero)");
                    throw new EscalatedException("Detected zero value for division operation (division_op_no_zero). [" + operation_name + ", line " + line_num + "]");
                }
            } else {
                logger.warning("CustomError::inspect(): Unexpected value " + num.toString());
            }
        }
    }

    /**
     * Central method for inspecting values and firing an {@link EscalatedException}
     * depending on the return value.
     *
     * @param operation_name Operation name
     * @param value Value of the value...
     * @param line_num Line number for logging
     */
    public void inspectReturnValue(String operation_name, Object value, int line_num) {
        switch(operation_name) {
            case "JSDivideNodeGen":
            case "JSAddNodeGen":
            case "JSSubtractNodeGen":
            case "JSMultiplyNodeGen":
            case "JSUnaryMinusNodeGen":
            case "JSUnaryPlusNodeGen":
            case "JSModuloNodeGen":
            case "JSAddSubNumericUnitNodeGen":
            case "SqrtNodeGen":
            case "JSExponentiateNodeGen":
                inspectArithmeticValues(operation_name, value, line_num);
                break;
        }
    }

    private void inspectArithmeticValues(String operation_name, Object value, int line_num) {
        if (arith_op_no_undefined) {
            if (JSGuards.isUndefined(value)) {
                logger.info("Detected undefined value for arithmetic operation (arith_op_no_undefined)");
                throw new EscalatedException("Detected undefined value for arithmetic operation (arith_op_no_undefined). [" + operation_name + ", line " + line_num + "]");
            }
        }
        if (arith_op_no_null) {
            //if (JSGuards.isJSNull(value)) { //TODO does not work
            if (value.toString().startsWith("DynamicObject<null>")) {
                logger.info("Detected null value for arithmetic operation (arith_op_no_null)");
                throw new EscalatedException("Detected null value for arithmetic operation (arith_op_no_null). [" + operation_name + ", line " + line_num + "]");
            }
        }
        if (arith_op_no_nan) {
            if (JSGuards.isNumberDouble(value) && JSRuntime.isNaN(value)) {
                logger.info("Detected NaN value for arithmetic operation (arith_op_no_nan)");
                throw new EscalatedException("Detected NaN value for arithmetic operation (arith_op_no_nan). [" + operation_name + ", line " + line_num + "]");
            }
        }
        if (arith_op_no_infinity) {
            if (JSGuards.isNumberDouble(value) && (JSRuntime.isPositiveInfinity((double) value) || JSRuntime.isPositiveInfinity(-(double) value))) {
                logger.info("Detected Infinity value for arithmetic operation (arith_op_no_infinity)");
                throw new EscalatedException("Detected Infinity value for arithmetic operation (arith_op_no_infinity). [" + operation_name + ", line " + line_num + "]");
            }
        }
    }

    /**
     * @return Value of option "escalate_exceptions"
     */
    public boolean escalateExceptionsEnabled() {
        return escalate_exceptions;
    }

    /**
     * @return Value of option "equal_is_strict_equal"
     */
    public boolean equalIsStrictEqualEnabled() {
        return equal_is_strict_equal;
    }

    /**
     * @return Value of option "enforce_existing_properties"
     */
    public boolean enforceExistingPropertiesEnabled() {
        return enforce_existing_properties;
    }

    /**
     * Create a new Exception that cannot be caught.
     *
     * @param message Message of the exception
     * @return Exception of type "EscalatedException"
     */
    public static EscalatedException createException(String message) {
        return new EscalatedException(message);
    }

    /**
     * This class should be used whenever an error occurs in the programs execution.
     * All JavaScript exceptions (e.g. com.oracle.truffle.js.runtime.UserScriptException)
     * will be caught by a try-catch-statement in the guest language source code.
     * This exception extends RuntimeException directly and therefore will not be caught
     * by any safety measures in the guest language. It can only be caught by the Fuzzer
     * itself.
     */
    public static class EscalatedException extends RuntimeException {

        public EscalatedException() {
            super();
        }

        public EscalatedException(String message) {
            super(message);
        }

        public EscalatedException(String message, Throwable cause) {
            super(message, cause);
        }

        public EscalatedException(Throwable cause) {
            super(cause);
        }

        protected EscalatedException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
            super(message, cause, enableSuppression, writableStackTrace);
        }
    }
}

```


Overlapping Code:
```
ustomError {
private final Logger logger;
private boolean some_enabled = false;
// Options
private boolean escalate_exceptions = false;
private boolean equal_is_strict_equal = false;
private boolean enforce_existing_properties = false;
private boolean boolean_op_only_boolean_operands = false;
private boolean arith_op_no_undefined = false;
private boolean arith_op_no_null = false;
private boolean arith_op_no_nan = false;
private boolean arith_op_no_infinity = false;
private boolean division_op_no_zero = false;
public CustomError(Logger lgr) {
this.logger = lgr;
}
/**
* Set an option for this instance.
*
* @param name Name of the option
* @param value Option value
*/
public void setOption(String name, Object value) e "escalate_exceptions":
escalate_exceptions = (boolean) value;
logSetOption(name, escalate_exceptions);
break;
case "equal_is_strict_equal":
equal_is_strict_equal = (boolean) value;
logSetOption(name, equal_is_strict_equal);
break;
case "enforce_existing_properties":
enforce_existing_properties = (boolean) value;
logSetOption(name, enforce_existing_properties);
break;
case "boolean_op_only_boolean_operands":
boolean_op_only_boolean_operands = (boolean) value;
logSetOption(name, boolean_op_only_boolean_operands);
break;
case "arith_op_no_undefined":
arith_op_no_undefined = (boolean) value;
logSetOption(name, arith_op_no_undefined);
break;
case "arith_op_no_null":
arith_op_no_null = (boolean) value;
logSetOption(name, arith_op_no_null);
break;
case "arith_op_no_nan":
arith_op_no_nan = (boolean) value;
logSetOption(name, arith_op_no_nan);
break;
case "arith_op_no_infinity":
arith_op_no_infinity = (boolean) value;
logSetOption(name, arith_
```
<Overlap Ratio: 0.9587392550143267>

---

--- 69 --
Question ID: 3657c2a163170b02431c0dbfc628de7c3d0901ee
Original Code:
```
public class PreRegistrationFragment extends FragmentViewController<EmptyArg, PreRegistrationListener> {

    @Override
    public ControllerTypes<EmptyArg, PreRegistrationListener> getTypes() {
        return new ControllerTypes<>(EmptyArg.class, PreRegistrationListener.class);
    }

    @Override
    public View onCreateView(@NonNull final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {
        final View view = BottomDetailAndButtonView.inflateWithMenuButton(inflater, container, getActivity(), R.layout.pre_registration);
        final Button startRegistrationButton = view.findViewById(R.id.start_registration_button);
        startRegistrationButton.setOnClickListener(click -> getListener().startRegistration());
        return view;
    }
}

```


Overlapping Code:
```
ass PreRegistrationFragment extends FragmentViewController<EmptyArg, PreRegistrationListener> {
@Override
public ControllerTypes<EmptyArg, PreRegistrationListener> getTypes() {
return new ControllerTypes<>(EmptyArg.class, PreRegistrationListener.class);
}
@Override
public View onCreateView(@NonNull final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {
final View view = BottomDetailAndButtonView.inflateWithMenuButton(inflater, container, getActivity(), R.layout.pre_registration);
final Button startRegistrationButton = view.findViewById(R.id.start_registration_button);
startRegistrationButton.setOnClickListener(click -> getListener().startRegistration());
```
<Overlap Ratio: 0.9641873278236914>

---

--- 70 --
Question ID: dcd97519c9fc5f4a154226ba966b44b05e8970d2
Original Code:
```
public final class Counters {

    private Counters() {
        throw new IllegalAccessError();
    }

    /**
     * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>
     *
     * @param <T>   the component type of the counter
     * @param items the items to add to the counter
     * @return the counter
     */
    @SafeVarargs
    public static <T> Counter<T> newCounter(T... items) {
        Counter<T> counter = new HashMapCounter<>();
        if (items != null) {
            counter.incrementAll(Arrays.asList(items));
        }
        return counter;
    }

    /**
     * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>
     *
     * @param <T>      the component type of the counter
     * @param iterable the items to add to the counter
     * @return the counter
     */
    public static <T> Counter<T> newCounter(Iterable<? extends T> iterable) {
        Counter<T> counter = new HashMapCounter<>();
        counter.incrementAll(iterable);
        return counter;
    }

    /**
     * <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>
     *
     * @param <T>    the component type of the counter
     * @param stream the items to add to the counter
     * @return the counter
     */
    public static <T> Counter<T> newCounter(Stream<? extends T> stream) {
        Counter<T> counter = new HashMapCounter<>();
        stream.forEach(counter::increment);
        return counter;
    }

    /**
     * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given map</p>
     *
     * @param <T> the component type of the counter
     * @param map the items and counts to merge with counter
     * @return the counter
     */
    public static <T> Counter<T> newCounter(Map<? extends T, ? extends Number> map) {
        Counter<T> counter = new HashMapCounter<>();
        counter.merge(map);
        return counter;
    }

    /**
     * <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given counter</p>
     *
     * @param <T>   the component type of the counter
     * @param other the items and counts to merge with counter
     * @return the counter
     */
    public static <T> Counter<T> newCounter(Counter<? extends T> other) {
        Counter<T> counter = new HashMapCounter<>();
        counter.merge(other);
        return counter;
    }

    /**
     * <p>Reads a counter from a CSV file.</p>
     *
     * @param <TYPE>   the component type of the counter
     * @param resource the resource that the counter values are read from.
     * @param keyClass the class of the item type
     * @return the counter
     * @throws IOException Something went wrong reading in the counter.
     */
    public static <TYPE> Counter<TYPE> readCsv(Resource resource, Class<TYPE> keyClass) throws IOException {
        Counter<TYPE> counter = Counters.newCounter();
        try (CSVReader reader = CSV.builder().reader(resource)) {
            reader.forEach(row -> {
                if (row.size() >= 2) {
                    counter.increment(Converter.convertSilently(row.get(0), keyClass), Double.valueOf(row.get(1)));
                }
            });
        }
        return counter;
    }

    /**
     * <p>Wraps a counter making each method call synchronized.</p>
     *
     * @param <TYPE>  the item type
     * @param counter the counter to wrap
     * @return the wrapped counter
     */
    public static <TYPE> Counter<TYPE> newConcurrentCounter(Counter<TYPE> counter) {
        return new ConcurrentHashMapCounter<TYPE>().merge(counter);
    }

    /**
     * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>
     *
     * @param <T>   the component type of the counter
     * @param items the items to add to the counter
     * @return the counter
     */
    @SafeVarargs
    public static <T> Counter<T> newConcurrentCounter(T... items) {
        Counter<T> counter = new ConcurrentHashMapCounter<>();
        if (items != null) {
            counter.incrementAll(Arrays.asList(items));
        }
        return counter;
    }

    /**
     * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized by merging with the given map</p>
     *
     * @param <T> the component type of the counter
     * @param map the items and counts to merge with counter
     * @return the counter
     */
    public static <T> Counter<T> newConcurrentCounter(Map<? extends T, ? extends Number> map) {
        Counter<T> counter = new ConcurrentHashMapCounter<>();
        counter.merge(map);
        return counter;
    }

    /**
     * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>
     *
     * @param <T>      the component type of the counter
     * @param iterable the items to add to the counter
     * @return the counter
     */
    public static <T> Counter<T> newConcurrentCounter(Iterable<? extends T> iterable) {
        Counter<T> counter = new ConcurrentHashMapCounter<>();
        counter.incrementAll(iterable);
        return counter;
    }

    /**
     * <p>Creates a new {@link ConcurrentHashMapCounter} which is initialized with the given items</p>
     *
     * @param <T>    the component type of the counter
     * @param stream the items to add to the counter
     * @return the counter
     */
    public static <T> Counter<T> newConcurrentCounter(Stream<? extends T> stream) {
        Counter<T> counter = new ConcurrentHashMapCounter<>();
        stream.forEach(counter::increment);
        return counter;
    }
}

```


Overlapping Code:
```
public final class Counters {
private Counters() {
throw new IllegalAccessError();
}
/**
* <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>
*
* @param <T> the component type of the counter
* @param items the items to add to the counter
* @return the counter
*/
@SafeVarargs
public static <T> Counter<T> newCounter(T... items) {
Counter<T> counter = new HashMapCounter<>();
if (items != null) {
counter.incrementAll(Arrays.asList(items));
}
return counter;
}
/**
* <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>
*
* @param <T> the component type of the counter
* @param iterable the items to add to the counter
* @return the counter
*/
public static <T> Counter<T> newCounter(Iterable<? extends T> iterable) {
Counter<T> counter = new HashMapCounter<>();
counter.incrementAll(iterable);
return counter;
}
/**
* <p>Creates a new {@link HashMapMultiCounter} which is initialized with the given items</p>
*
* @param <T> the component type of the counter
* @param stream the items to add to the counter
* @return the counter
*/
public static <T> Counter<T> newCounter(Stream<? extends T> stream) {
Counter<T> counter = new HashMapCounter<>();
stream.forEach(counter::increment);
return counter;
}
/**
* <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given map</p>
*
* @param <T> the component type of the counter
* @param map the items and counts to merge with counter
* @return the counter
*/
public static <T> Counter<T> newCounter(Map<? extends T, ? extends Number> map) {
Counter<T> counter = new HashMapCounter<>();
counter.merge(map);
return counter;
}
/**
* <p>Creates a new {@link HashMapMultiCounter} which is initialized by merging with the given counter</p>
*
* @param <T> the component type of the counter
* @param other the items and counts to merge with counter
* @return the counter
*/
public static <T> Counter<T> newCounter(Counter<? extends T> other) {
Counter<T> counter = new HashMapCounter<>();
counter.merge(other);
return counter;
}
/**
* <p>Reads a counter
```
<Overlap Ratio: 1.0>

---

--- 71 --
Question ID: 979d1de477d5676a88d93695c18feea4c16e195d
Original Code:
```
class Coordinate {

    private final int x;

    private final int y;

    private final int manhattanDistance;

    Coordinate(final int x, final int y) {
        this.x = x;
        this.y = y;
        this.manhattanDistance = Math.abs(x) + Math.abs(y);
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        final Coordinate that = (Coordinate) o;
        return x == that.x && y == that.y;
    }

    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }

    @Override
    public String toString() {
        return "Coordinate{" + "x=" + x + ", y=" + y + '}';
    }

    public boolean horizontallyBetween(final Coordinate start, final Coordinate end) {
        return start.x <= x && x <= end.x || end.x <= x && x <= start.x;
    }

    public boolean verticallyBetween(final Coordinate start, final Coordinate end) {
        return start.y <= y && y <= end.y || end.y <= y && y <= start.y;
    }

    public boolean horizontalWith(final Coordinate other) {
        return y == other.y;
    }

    public boolean verticalWith(final Coordinate other) {
        return x == other.x;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public int manhattanDistance() {
        return manhattanDistance;
    }

    public int lengthTo(final Coordinate other) {
        if (x == other.x) {
            return Math.abs(y - other.y);
        } else {
            return Math.abs(x - other.x);
        }
    }
}

```


Overlapping Code:
```
class Coordinate {
private final int x;
private final int y;
private final int manhattanDistance;
Coordinate(final int x, final int y) {
this.x = x;
this.y = y;
this.manhattanDistance = Math.abs(x) + Math.abs(y);
}
@Override
public boolean equals(final Object o) {
if (this == o)
return true;
if (o == null || getClass() != o.getClass())
return false;
final Coordinate that = (Coordinate) o;
return x == that.x && y == that.y;
}
@Override
public int hashCode() {
return Objects.hash(x, y);
}
@Override
public String toString() {
return "Coordinate{" + "x=" + x + ", y=" + y + '}';
}
public boolean horizontallyBetween(final Coordinate start, final Coordinate end) {
return start.x <= x && x <= end.xverticallyBetween(final Coordinate start, final CoorizontalWith(final Coordinate other) {
return y == other.y;
}
public boolean verticalWith(final Coordinate other) {
return x == other.x;
}
public int getX() {
return x;
}
public int getY() {
return y;
}
public int manhattanDistance() {
return manhattanDistance;
}
public int lengthTo(final Coordinatother.y);
} else {
return Math.abs(x - other.x);
}
```
<Overlap Ratio: 0.8440860215053764>

---

--- 72 --
Question ID: 902dc7a95be7bd3c98d3ff6f7bce99c84d3cd716
Original Code:
```
public class ExpirationTimeScriptPlugin extends MockScriptPlugin {

    @Override
    public String pluginScriptLang() {
        return "painless";
    }

    @Override
    @SuppressWarnings("unchecked")
    protected Map<String, Function<Map<String, Object>, Object>> pluginScripts() {
        final String fieldName = "expiration_time";
        final String script = " if (ctx._source.expiration_time < params.expiration_time) { " + "     ctx._source.expiration_time = params.expiration_time; " + " } else { " + "     ctx.op = \"noop\"; " + " }";
        return Map.of(script, vars -> {
            Map<String, Object> params = (Map<String, Object>) vars.get("params");
            Assert.assertNotNull(params);
            Assert.assertThat(params.keySet(), contains(fieldName));
            long updatingValue = (long) params.get(fieldName);
            Map<String, Object> ctx = (Map<String, Object>) vars.get("ctx");
            Assert.assertNotNull(ctx);
            Map<String, Object> source = (Map<String, Object>) ctx.get("_source");
            long currentValue = (long) source.get(fieldName);
            if (currentValue < updatingValue) {
                source.put(fieldName, updatingValue);
            } else {
                ctx.put("op", "noop");
            }
            return ctx;
        });
    }
}

```


Overlapping Code:
```
 class ExpirationTimeScriptPlugin extends MockScriptPlugin {
@Override
public String pluginScriptLang() {
return "painless";
}
@Override
@SuppressWarnings("unchecked")
protected Map<String, Function<Map<String, Object>, Object>> pluginScripts() {
final String fieldName = "expiration_time";
final Strscript, vars -> {
Map<String, Object> params = (Map<String, Object>) vars.get("params");
Assert.assertNotNull(params);
Assert.assertThat(params.keySet(), contains(fieldName));
long updatingValue = (long) params.get(fieldName);
Map<String, Object> ctx = (Map<String, Object>) vars.get("ctx");
Assert.assertNotNull(ctx);
Map<String, Object> source = (Map<String, Object>) ctx.get("_source");
long currentValue = (long) source.get(fieldName);
if (currentValue < updatingValue) {
source.put(fieldName, updatingValue);
} else {
ctx.put("op", "noop");
}
re
```
<Overlap Ratio: 0.792910447761194>

---

--- 73 --
Question ID: 0bdccbde2f8923091380e6547b9a7dcaa1198eba
Original Code:
```
public class GooOverlayRenderer {

    private static final String[] NUM_SUFFIXES = new String[] { "", "k", "m", "b", "t" };

    private static final int MAX_LENGTH = 4;

    private static final Minecraft CLIENT = Minecraft.getInstance();

    public static void renderStackSize(MatrixStack matrixStack, FontRenderer fr, FluidStack stack, int xPosition, int yPosition) {
        if (!stack.isEmpty() && stack.getAmount() != 1) {
            String s = shortHandNumber(stack.getAmount());
            if (stack.getAmount() < 1)
                s = TextFormatting.RED + String.valueOf(stack.getAmount());
            fr.drawStringWithShadow(matrixStack, s, (float) (xPosition + 19 - 2 - fr.getStringWidth(s)), (float) (yPosition + 6 + 3), 16777215);
        }
    }

    private static String shortHandNumber(Number number) {
        String shorthand = new DecimalFormat("##0E0").format(number);
        shorthand = shorthand.replaceAll("E[0-9]", NUM_SUFFIXES[Character.getNumericValue(shorthand.charAt(shorthand.length() - 1)) / 3]);
        for (; shorthand.length() > MAX_LENGTH || shorthand.matches("[0-9]+\\.[a-z]"); ) shorthand = shorthand.substring(0, shorthand.length() - 2) + shorthand.substring(shorthand.length() - 1);
        return shorthand;
    }

    public static void renderIcon(int x, int y, int sx, int sy, TextureAtlasSprite iconSprite) {
        CLIENT.getTextureManager().bindTexture(AbstractGui.GUI_ICONS_LOCATION);
        if (iconSprite == null)
            return;
        drawTexturedModalRect(x, y, iconSprite.getMinU(), iconSprite.getMinV(), sx, sy, iconSprite.getMaxU(), iconSprite.getMaxV());
    }

    public static void drawTexturedModalRect(int x, int y, float textureX, float textureY, int width, int height, float tw, float th) {
        float f = 0.00390625F;
        float f1 = 0.00390625F;
        float zLevel = 0.0F;
        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();
        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);
        buffer.pos(x, y + height, zLevel).tex(textureX * f, (textureY + th) * f1).endVertex();
        buffer.pos(x + width, y + height, zLevel).tex((textureX + tw) * f, (textureY + th) * f1).endVertex();
        buffer.pos(x + width, y, zLevel).tex((textureX + tw) * f, textureY * f1).endVertex();
        buffer.pos(x, y, zLevel).tex(textureX * f, textureY * f1).endVertex();
        tessellator.draw();
    }
}

```


Overlapping Code:
```
vate static final String[] NUM_SUFFIXES = new Striprivate static final int MAX_LENGTH = 4;
private static final Minecraft CLIENT = Minecraft.getInstance();
public static void renderStackSize(MatrixStack matrixStack, FontRenderer fr, FluidStack stack, int xPosition, int yPosition) {
if (!stack.isEmpty() && stack.getAmount() != 1) {
String s = shortHandNumber(stack.getAmount());
if (stack.getAmount() < 1)
s = TextFormatting.RED + String.valueOf(stack.getAmount());
fr.drawStringWithShadow(matrixStack, s, (float) (xPosition + 19 - 2 - fr.getStringWidth(s)), (float) (yPosition + 6 + 3), 16777215);
}
}
private static String shortHandNumber(Number number) {
String shorthand = new DecimalFormat("##0E0").format(number);
shorthand = shorthand.replaceAll("E[0-9]", NUM_SUFFIXES[Character.getNumericValue(shorthand.charAt(shorthand.lengthhand = shorthand.substring(0, shorthand.length() - 2) + shorthand.substring(shorthand.length() - 1);
return shorthand;
}
public static void renderIcon(int x, int y, int sx, int sy, TextureAtlasSprite iconSprite) {
CLIENT.getTextureManager().bindTexture(AbstractGui.GUI_ICONS_LOCATION);
if (iconSprite == null)
return;
drawTexturedModalRect(x, y, iconSprite.getMinU(), iconSprite.getMinV(), sx, sy, iconSprite.getMaxU(), iconSprite.getMaxV());
}
public static void drawTexturedModalRect(int x, int y, float textureX, float textureY, int width, int height, float tw, float th) {
float f = 0.00390625F;
float f1 = 0.00390625F;
float zLevel = 0.0F;
Tessellator tessellator = Tessellator.getInstance();
BufferBuilder buffer = tessellator.getBuffer();
buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);
buffer.pos(x, y + height, zLevel).tex(textureX * f, (textureY + th) * f1).endVertex();
buffer.pos(x + width, y + height, zLevel).tex((textureX + tw) * f, (textureY + th) * f1).endVertex();
buffer.pos(x + width, y, zLevel).tex((textureX + tw) * f, textureY * f1).endVertex();
buffer.pos(x, y, zLevel).tex(textureX * f, textureY * f1).endVert
```
<Overlap Ratio: 0.9080932784636488>

---

--- 74 --
Question ID: 4d4c08f2c43d46e7c3aa9a89f65e3118d5a52e33
Original Code:
```
@Slf4j
class DiRowStructVisitorTest extends VisitorsTest {

    private void createMetadata(final Dynamic dynamic, final String name, final String type, final Object value) {
        final DynamicMetadata meta = new DynamicMetadata();
        meta.setName(name);
        meta.setType(type);
        dynamic.metadatas.add(meta);
        dynamic.addColumnValue(value);
    }

    @Test
    void visit() {
        final RowStruct rowStruct = new RowStruct();
        rowStruct.id = ":testing:";
        rowStruct.name = NAME;
        rowStruct.shortP = SHORT;
        rowStruct.shortC = SHORT;
        rowStruct.intP = INT;
        rowStruct.intC = INT;
        rowStruct.longP = LONG;
        rowStruct.longC = LONG;
        rowStruct.floatP = FLOAT;
        rowStruct.floatC = FLOAT;
        rowStruct.doubleP = DOUBLE;
        rowStruct.doubleC = DOUBLE;
        rowStruct.bytes0 = BYTES0;
        rowStruct.date0 = DATE;
        rowStruct.date2 = Date.from(ZONED_DATE_TIME.toInstant());
        rowStruct.bigDecimal0 = BIGDEC;
        rowStruct.bool1 = Boolean.TRUE;
        rowStruct.array0 = INTEGERS;
        rowStruct.object0 = new Rcd();
        rowStruct.hAshcOdEdIrtY = Boolean.TRUE;
        rowStruct.h = NAME;
        // dynamic
        final Dynamic dynamic = new Dynamic();
        createMetadata(dynamic, "dynString", "id_String", "stringy");
        createMetadata(dynamic, "dynInteger", "id_Integer", INT);
        createMetadata(dynamic, "dynDouble", "id_Double", DOUBLE);
        createMetadata(dynamic, "dynBytes", "id_byte[]", BYTES0);
        createMetadata(dynamic, "dynBytesArray", "id_byte[]", BYTES0);
        createMetadata(dynamic, "dynBytesBuffer", "id_byte[]", ByteBuffer.allocate(100).wrap(BYTES0));
        createMetadata(dynamic, "dynBytesWString", "id_byte[]", String.valueOf(BYTES0));
        createMetadata(dynamic, "dynBigDecimal", "id_BigDecimal", BIGDEC);
        createMetadata(dynamic, "dynObject", "id_Object", new Rcd());
        createMetadata(dynamic, "STRINGS", "id_List", STRINGS);
        createMetadata(dynamic, "LONGS", "id_List", LONGS);
        createMetadata(dynamic, "FLOATS", "id_List", FLOATS);
        createMetadata(dynamic, "DOUBLES", "id_List", DOUBLES);
        createMetadata(dynamic, "BOOLEANS", "id_List", BOOLEANS);
        createMetadata(dynamic, "BYTES", "id_List", BYTES);
        createMetadata(dynamic, "DATES", "id_List", DATES);
        createMetadata(dynamic, "RECORDS", "id_List", RECORDS);
        rowStruct.dynamic = dynamic;
        //
        final DiRowStructVisitor visitor = new DiRowStructVisitor();
        final Record record = visitor.get(rowStruct, factory);
        final Schema schema = record.getSchema();
        // should have 3 excluded fields
        assertEquals(42, schema.getEntries().size());
        // asserts Record
        log.info("[visit] values: {}", record);
        assertEquals(":testing:", record.getString("id"));
        assertEquals(NAME, record.getString("name"));
        assertEquals(SHORT, record.getInt("shortP"));
        assertEquals(SHORT, record.getInt("shortC"));
        assertEquals(INT, record.getInt("intP"));
        assertEquals(INT, record.getInt("intC"));
        assertEquals(LONG, record.getLong("longP"));
        assertEquals(LONG, record.getLong("longC"));
        assertEquals(FLOAT, record.getFloat("floatP"));
        assertEquals(FLOAT, record.getFloat("floatC"));
        assertEquals(DOUBLE, record.getDouble("doubleP"));
        assertEquals(DOUBLE, record.getDouble("doubleC"));
        assertEquals(DATE.toInstant(), record.getDateTime("date0").toInstant());
        assertNull(record.getDateTime("date1"));
        assertEquals(ZONED_DATE_TIME, record.getDateTime("date2"));
        assertEquals(1946, record.getDateTime("date2").getYear());
        assertEquals(BIGDEC.doubleValue(), new BigDecimal(record.getString("bigDecimal0")).doubleValue());
        assertEquals(BIGDEC.toString(), record.getString("bigDecimal0"));
        assertFalse(record.getBoolean("bool0"));
        assertTrue(record.getBoolean("bool1"));
        assertArrayEquals(BYTES0, record.getBytes("bytes0"));
        assertArrayEquals(BYTES0, record.getBytes("dynBytes"));
        assertArrayEquals(BYTES0, record.getBytes("dynBytesArray"));
        assertArrayEquals(BYTES0, record.getBytes("dynBytesBuffer"));
        assertArrayEquals(String.valueOf(BYTES0).getBytes(), record.getBytes("dynBytesWString"));
        assertEquals(BIGDEC.toString(), record.getString("dynBigDecimal"));
        assertEquals(BIGDEC, new BigDecimal(record.getString("dynBigDecimal")));
        assertEquals(RECORD.toString(), record.getString("object0"));
        assertTrue(record.getBoolean("hAshcOdEdIrtY"));
        assertEquals(NAME, record.getString("h"));
        assertEquals(RECORD.toString(), record.getString("dynObject"));
        assertEquals(INTEGERS, record.getArray(Integer.class, "array0"));
        assertEquals(STRINGS, record.getArray(String.class, "STRINGS"));
        assertEquals(LONGS, record.getArray(Long.class, "LONGS"));
        assertEquals(FLOATS, record.getArray(Float.class, "FLOATS"));
        assertEquals(DOUBLES, record.getArray(Double.class, "DOUBLES"));
        assertEquals(BOOLEANS, record.getArray(Boolean.class, "BOOLEANS"));
        assertEquals(BYTES, record.getArray(byte[].class, "BYTES"));
        assertEquals(DATES, record.getArray(ZonedDateTime.class, "DATES"));
        assertEquals(RECORDS, record.getArray(Record.class, "RECORDS"));
        record.getArray(Record.class, "RECORDS").forEach(r -> {
            assertEquals(1, r.getInt("ntgr"));
            assertEquals("one", r.getString("str"));
        });
        assertEquals(3, schema.getEntries().stream().filter(entry -> entry.getName().matches("hAshcOdEdIrtY|h|id")).count());
        // check we don't have any technical field in our schema/record
        assertEquals(0, schema.getEntries().stream().filter(entry -> entry.getName().matches("hashCodeDirty|loopKey|lookKey")).count());
        assertThrows(NullPointerException.class, () -> record.getBoolean("hashCodeDirty"));
        assertNull(record.getString("loopKey"));
        assertNull(record.getString("lookKey"));
    }

    public static class Rcd {

        public String str = "one";

        public int ntgr = 1;
    }
}

```


Overlapping Code:
```
tVisitorTest extends VisitorsTest {
private void createMetadata(final Dynamic dynamic, final String name, final String type, final Object value) {
final DynamicMetadata meta = new DynamicMetadata();
meta.setName(name);
meta.setType(type);
dynamic.metadatas.add(meta);
dynamic.addColumnValue(value);
}
@Test
void visit() {
final RowStruct rowStruct = new RowStruct();
rowStruct.id = ":testing:";
rowStruct.name = NAME;
rowStruct.shortP = SHORT;
rowStruct.shortC = SHORT;
rowStruct.intP = INT;
rowStruct.intC = INT;
rowStruct.longP = LONG;
rowStruct.longC = LONG;
rowStruct.floatP = FLOAT;
rowStruct.floatC = FLOAT;
rowStruct.doubleP = DOUBLE;
rowStruct.doubleC = DOUBLE;
rowStruct.bytes0 = BYTES0;
rowStruct.date0 = DATE;
rowStruct.date2 = Date.from(ZONED_DATE_TIME.toInstant());
rowStruct.bigDecimal0 = BIGDEC;
rowStruct.bool1 = Boolean.TRUE;
rowStruct.array0 = INTEGERS;
rowStruct.object0 = new Rcd();
rowStruct.hAshcOdEdIrtY = Boolean.TRUE;
rowStruct.h = NAME;
// dynamic
final Dynamic dynamic = new Dynamic();
createMetadata(dynamic, "dynString", "id_String", "stringy");
createMetadata(dynamic, "dynInteger", "id_Integer", INT);
createMetadata(dynamic, "dynDouble", "id_Double", DOUBLE);
createMetadata(dynamic, "dynBytes", "id_byte[]", BYTES0);
createMetadata(dynamic, "dynBytesArray", "id_byte[]", BYTES0);
createMetadata(dynamic, "dynBytesBuffer", "id_byte[]", ByteBuffer.allocate(100).wrap(BYTES0));
createMetadata(dynamic, "dynBytesWString", "id_byte[]", String.valueOf(BYTES0));
createMetadata(dynamic, "dynBigDecimal", "id_BigDecimal", BIGDEC);
createMetadata(dynamic, "dynObject", "id_Object", new Rcd());
createMetadata(dynamic, "STRINGS", "id_List", STRINGS);
createMetadata(dynamic, "LONGS", "id_List", LONGS);
createMetadata(dynamic, "FLOATS", "id_List", FLOATS);
createMetadata(dynamic, "DOUBLES", "id_List", DOUBLES);
createMetadata(dynamic, "BOOLEANS", "id_List", BOOLEANS);
createMetadata(dynamic, "BYTES", "id_List", BYTES);
createMetadata(dynamic, "DATES", "id_List", DATES);
createMetadata(dynamic, "RECORDS", "id_List", RECORDS);
rowStruct.dyna
```
<Overlap Ratio: 0.9824228028503563>

---

--- 75 --
Question ID: 641033c0fb496a6d65e54ca86c4dc0ddb60735ec
Original Code:
```
public class MovieListerTest {

    // mocks in unit test. In a unit test, the target type must be tested in isolation.
    @Test
    public void moviesDirectedByShouldReturnTheMoviesOfAGivenDirector() {
        final MovieFinder finder = Mockito.mock(MovieFinder.class);
        BDDMockito.given(finder.findAll()).willReturn(Collections.emptyList());
        final MovieLister lister = new MovieLister(finder);
        final List<Movie> movies = lister.moviesDirectedBy("rcardin");
        Assertions.assertThat(movies).isEqualTo(Collections.emptyList());
    }
}

```


Overlapping Code:
```
// mocks in unit test. In a unit test, the target type must be tested in isolation.
@Test
public void moviesDirectedByShouldReturnTheMoviesOfAGivenDirector() {
final MovieFinder finder = Mockito.mock(MovieFinder.class);
BDDMockito.given(finder.findAll()).willReturn(Collections.emptyList());
final MovieLister lister = new MovieLister(finder);
final List<Movie> movies = lister.moviesDirectedBy("rcardin");
Assertions.assertThat(movies).isEqualTo(Col
```
<Overlap Ratio: 0.8875739644970414>

---

--- 76 --
Question ID: 5e2fa117bef24890f7d8225ed48450f9a62751c1
Original Code:
```
public class CompletionJavadoc extends Javadoc {

    Expression completionNode;

    public CompletionJavadoc(int sourceStart, int sourceEnd) {
        super(sourceStart, sourceEnd);
    }

    /**
     * @return Returns the completionNode.
     */
    public Expression getCompletionNode() {
        return this.completionNode;
    }

    /**
     * Resolve selected node if not null and throw exception to let clients know
     * that it has been found.
     *
     * @throws CompletionNodeFound
     */
    private void internalResolve(Scope scope) {
        if (this.completionNode != null) {
            if (this.completionNode instanceof CompletionOnJavadocTag) {
                ((CompletionOnJavadocTag) this.completionNode).filterPossibleTags(scope);
            } else {
                boolean resolve = true;
                if (this.completionNode instanceof CompletionOnJavadocParamNameReference) {
                    resolve = ((CompletionOnJavadocParamNameReference) this.completionNode).token != null;
                } else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {
                    resolve = ((CompletionOnJavadocTypeParamReference) this.completionNode).token != null;
                }
                if (resolve) {
                    switch(scope.kind) {
                        case Scope.CLASS_SCOPE:
                            this.completionNode.resolveType((ClassScope) scope);
                            break;
                        case Scope.METHOD_SCOPE:
                            this.completionNode.resolveType((MethodScope) scope);
                            break;
                    }
                }
                if (this.completionNode instanceof CompletionOnJavadocParamNameReference) {
                    CompletionOnJavadocParamNameReference paramNameReference = (CompletionOnJavadocParamNameReference) this.completionNode;
                    if (scope.kind == Scope.METHOD_SCOPE) {
                        paramNameReference.missingParams = missingParamTags(paramNameReference.binding, (MethodScope) scope);
                    }
                    if (paramNameReference.token == null || paramNameReference.token.length == 0) {
                        paramNameReference.missingTypeParams = missingTypeParameterTags(paramNameReference.binding, scope);
                    }
                } else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {
                    CompletionOnJavadocTypeParamReference typeParamReference = (CompletionOnJavadocTypeParamReference) this.completionNode;
                    typeParamReference.missingParams = missingTypeParameterTags(typeParamReference.resolvedType, scope);
                }
            }
            Binding qualifiedBinding = null;
            if (this.completionNode instanceof CompletionOnJavadocQualifiedTypeReference) {
                CompletionOnJavadocQualifiedTypeReference typeRef = (CompletionOnJavadocQualifiedTypeReference) this.completionNode;
                if (typeRef.packageBinding == null) {
                    qualifiedBinding = typeRef.resolvedType;
                } else {
                    qualifiedBinding = typeRef.packageBinding;
                }
            } else if (this.completionNode instanceof CompletionOnJavadocMessageSend) {
                CompletionOnJavadocMessageSend msg = (CompletionOnJavadocMessageSend) this.completionNode;
                if (!msg.receiver.isThis())
                    qualifiedBinding = msg.receiver.resolvedType;
            } else if (this.completionNode instanceof CompletionOnJavadocAllocationExpression) {
                CompletionOnJavadocAllocationExpression alloc = (CompletionOnJavadocAllocationExpression) this.completionNode;
                qualifiedBinding = alloc.type.resolvedType;
            }
            throw new CompletionNodeFound(this.completionNode, qualifiedBinding, scope);
        }
    }

    /*
	 * @see org.eclipse.jdt.internal.compiler.ast.ASTNode#print(int, java.lang.StringBuffer)
	 */
    public StringBuffer print(int indent, StringBuffer output) {
        //$NON-NLS-1$
        printIndent(indent, output).append("/**\n");
        boolean nodePrinted = false;
        if (this.paramReferences != null) {
            int i = 0, length = this.paramReferences.length;
            while (i < length) try {
                //$NON-NLS-1$
                printIndent(indent, output).append(" * @param ");
                this.paramReferences[i].print(indent, output).append('\n');
                if (!nodePrinted && this.completionNode != null) {
                    nodePrinted = this.completionNode == this.paramReferences[i];
                }
            } finally {
                i++;
            }
        }
        if (this.paramTypeParameters != null) {
            int i = 0, length = this.paramTypeParameters.length;
            while (i < length) try {
                //$NON-NLS-1$
                printIndent(indent, output).append(" * @param <");
                //$NON-NLS-1$
                this.paramTypeParameters[i].print(indent, output).append(">\n");
                if (!nodePrinted && this.completionNode != null) {
                    nodePrinted = this.completionNode == this.paramTypeParameters[i];
                }
            } finally {
                i++;
            }
        }
        if (this.returnStatement != null) {
            //$NON-NLS-1$
            printIndent(indent, output).append(" * @");
            this.returnStatement.print(indent, output).append('\n');
        }
        if (this.exceptionReferences != null) {
            int i = 0, length = this.exceptionReferences.length;
            while (i < length) try {
                //$NON-NLS-1$
                printIndent(indent, output).append(" * @throws ");
                this.exceptionReferences[i].print(indent, output).append('\n');
                if (!nodePrinted && this.completionNode != null) {
                    nodePrinted = this.completionNode == this.exceptionReferences[i];
                }
            } finally {
                i++;
            }
        }
        if (this.seeReferences != null) {
            int i = 0, length = this.seeReferences.length;
            while (i < length) try {
                //$NON-NLS-1$
                printIndent(indent, output).append(" * @see ");
                this.seeReferences[i].print(indent, output).append('\n');
                if (!nodePrinted && this.completionNode != null) {
                    nodePrinted = this.completionNode == this.seeReferences[i];
                }
            } finally {
                i++;
            }
        }
        if (!nodePrinted && this.completionNode != null) {
            //$NON-NLS-1$
            printIndent(indent, output).append(" * ");
            this.completionNode.print(indent, output).append('\n');
        }
        //$NON-NLS-1$
        printIndent(indent, output).append(" */\n");
        return output;
    }

    /**
     * Resolve completion node if not null and throw exception to let clients know
     * that it has been found.
     *
     * @throws CompletionNodeFound
     */
    public void resolve(ClassScope scope) {
        super.resolve(scope);
        internalResolve(scope);
    }

    /**
     * Resolve completion node if not null and throw exception to let clients know
     * that it has been found.
     *
     * @throws CompletionNodeFound
     */
    public void resolve(CompilationUnitScope scope) {
        internalResolve(scope);
    }

    /**
     * Resolve completion node if not null and throw exception to let clients know
     * that it has been found.
     *
     * @throws CompletionNodeFound
     */
    public void resolve(MethodScope scope) {
        super.resolve(scope);
        internalResolve(scope);
    }

    /*
	 * Look for missing method @param tags
	 */
    private char[][] missingParamTags(Binding paramNameRefBinding, MethodScope methScope) {
        // Verify if there's some possible param tag
        AbstractMethodDeclaration md = methScope.referenceMethod();
        int paramTagsSize = this.paramReferences == null ? 0 : this.paramReferences.length;
        if (md == null)
            return null;
        int argumentsSize = md.arguments == null ? 0 : md.arguments.length;
        if (argumentsSize == 0)
            return null;
        // Store all method arguments if there's no @param in javadoc
        if (paramTagsSize == 0) {
            char[][] missingParams = new char[argumentsSize][];
            int i = 0;
            while (i < argumentsSize) try {
                missingParams[i] = md.arguments[i].name;
            } finally {
                i++;
            }
            return missingParams;
        }
        // Look for missing arguments
        char[][] missingParams = new char[argumentsSize][];
        int size = 0;
        int i = 0;
        while (i < argumentsSize) try {
            Argument arg = md.arguments[i];
            boolean found = false;
            int paramNameRefCount = 0;
            int j = 0;
            while (j < paramTagsSize && !found) try {
                JavadocSingleNameReference param = this.paramReferences[j];
                if (arg.binding == param.binding) {
                    if (param.binding == paramNameRefBinding) {
                        // do not count first occurence of param name reference
                        paramNameRefCount++;
                        found = paramNameRefCount > 1;
                    } else {
                        found = true;
                    }
                }
            } finally {
                j++;
            }
            if (!found) {
                missingParams[size++] = arg.name;
            }
        } finally {
            i++;
        }
        if (size > 0) {
            if (size != argumentsSize) {
                System.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);
            }
            return missingParams;
        }
        return null;
    }

    /*
	 * Look for missing type parameters @param tags
	 */
    private char[][] missingTypeParameterTags(Binding paramNameRefBinding, Scope scope) {
        int paramTypeParamLength = this.paramTypeParameters == null ? 0 : this.paramTypeParameters.length;
        // Verify if there's any type parameter to tag
        TypeParameter[] parameters = null;
        TypeVariableBinding[] typeVariables = null;
        switch(scope.kind) {
            case Scope.METHOD_SCOPE:
                AbstractMethodDeclaration methodDeclaration = ((MethodScope) scope).referenceMethod();
                if (methodDeclaration == null)
                    return null;
                parameters = methodDeclaration.typeParameters();
                typeVariables = methodDeclaration.binding.typeVariables;
                break;
            case Scope.CLASS_SCOPE:
                TypeDeclaration typeDeclaration = ((ClassScope) scope).referenceContext;
                parameters = typeDeclaration.typeParameters;
                typeVariables = typeDeclaration.binding.typeVariables;
                break;
        }
        if (typeVariables == null || typeVariables.length == 0)
            return null;
        // Store all type parameters if there's no @param in javadoc
        if (parameters != null) {
            int typeParametersLength = parameters.length;
            if (paramTypeParamLength == 0) {
                char[][] missingParams = new char[typeParametersLength][];
                int i = 0;
                while (i < typeParametersLength) try {
                    missingParams[i] = parameters[i].name;
                } finally {
                    i++;
                }
                return missingParams;
            }
            // Look for missing type parameter
            char[][] missingParams = new char[typeParametersLength][];
            int size = 0;
            int i = 0;
            while (i < typeParametersLength) try {
                TypeParameter parameter = parameters[i];
                boolean found = false;
                int paramNameRefCount = 0;
                int j = 0;
                while (j < paramTypeParamLength && !found) try {
                    if (parameter.binding == this.paramTypeParameters[j].resolvedType) {
                        if (parameter.binding == paramNameRefBinding) {
                            // do not count first occurence of param nmae reference
                            paramNameRefCount++;
                            found = paramNameRefCount > 1;
                        } else {
                            found = true;
                        }
                    }
                } finally {
                    j++;
                }
                if (!found) {
                    missingParams[size++] = parameter.name;
                }
            } finally {
                i++;
            }
            if (size > 0) {
                if (size != typeParametersLength) {
                    System.arraycopy(missingParams, 0, missingParams = new char[size][], 0, size);
                }
                return missingParams;
            }
        }
        return null;
    }
}

```


Overlapping Code:
```
doc extends Javadoc {
Expression completionNode;
public CompletionJavadoc(int sourceStart, int sourceEnd) {
super(sourceStart, sourceEnd);
}
/**
* @return Returns the completionNode.
*/
public Expression getCompletionNode() {
return this.completionNode;
}
/**
* Resolve selected node if not null and throw exception to let clients know
* that it has been found.
*
* @throws CompletionNodeFound
*/
private void internalResolve(Scope scope) {
if (this.completionNode != null) {
if (this.completionNode instanceof CompletionOnJavadocTag) {
((CompletionletionNode).filterPossibleTags(scope);
} else {
boolean resolve = true;
if (this.completionNode instanceof CompletionOnJavadocParamNameReference) {
re(CompletionOnJavadocParamNameReference) this.completionNode).token != null;
} else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {
resolve = ((CompletionOnJavadocTypeParamReference) this.completionNodpe.kind) {
case Scope.CLASS_SCOPE:
this.completionNode.resolveType((Ccope.METHOD_SCOPE:
this.completionNode.resolveType((MethodScope) scope);
break;
}
}
if (this.completionNode instanceof CompletionOnJavadocParamNameReference) {
CompletionOnJavadocParamNameReference paramNameReference = (CompletionOnJavadocParamNameReference) this.completionNode;
if (scope.kind == Scope.METHOD_SCOPE) {
paramNameReference.missingParams = missingParamTags(paramNameReference.binding, (Met;
}
if (paramNameReference.token == null || paramNameReference.token.length == 0) {
paramNameReference.missingTypeParams = missingTypeParameterTags(paramNameReference.binding, scope);
}
} else if (this.completionNode instanceof CompletionOnJavadocTypeParamReference) {
Comple
```
<Overlap Ratio: 0.9163019693654267>

---

--- 77 --
Question ID: 3467de5b9dd69d853da9674e47652781da6c0a68
Original Code:
```
public class ExpressionMultiNashProb extends ExpressionQuant {

    protected Expression expr;

    public ExpressionMultiNashProb() {
    }

    public void setExpression(Expression e) {
        this.expr = e;
    }

    public Expression getExpression() {
        return this.expr;
    }

    @Override
    public OpRelOpBound getRelopBoundInfo(Values constantValues) throws PrismException {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public boolean isConstant() {
        // TODO Auto-generated method stub
        return false;
    }

    @Override
    public boolean isProposition() {
        // TODO Auto-generated method stub
        return false;
    }

    @Override
    public Object evaluate(EvaluateContext ec) throws PrismLangException {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public BigRational evaluateExact(EvaluateContext ec) throws PrismLangException {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public boolean returnsSingleValue() {
        // TODO Auto-generated method stub
        return false;
    }

    @Override
    public Expression deepCopy() {
        ExpressionMultiNashProb expr = new ExpressionMultiNashProb();
        expr.setExpression(getExpression() == null ? null : getExpression().deepCopy());
        expr.setType(type);
        expr.setPosition(this);
        return expr;
    }

    @Override
    public Object accept(ASTVisitor v) throws PrismLangException {
        return v.visit(this);
    }

    @Override
    public String toString() {
        // TODO Auto-generated method stub
        String s = "P[" + expr.toString() + "]";
        return s;
    }
}

```


Overlapping Code:
```
e;
}
public Expression getExpression() {
return this.expr;
}
@Override
public OpRelOpBound getRelopBoundInfo(Values constantValues) throws PrismException {
// TODO Auto-generated method stub
return null;
}
@Override
public boolean isConstant() {
// TODO Auto-generated method stub
return false;
}
@Override
public boolean isProposition() {
// TODO Auto-generated method stub
return false;
}
@Override
public Object evaluate(EvaluateContext ec) throws PrismLangException {
// TODO Auto-generated method stub
return null;
}
@Override
public BigRational evaluateExact(EvaluateContext ec) throws PrismLangException {
// TODO Auto-generated method stub
return null;
}
@Override
public boolean returnsSingleValue() {
// TODO Auto-generated method stub
return false;
}
@Override
public Expression deepCopy() {
ExpressionMultiNashProb expr = new ExpressionMultiNashProb();
expr.setExpression(getExpression() == null ? null : getExpression().deepCopy());
expr.setType(type);
expr.setPosition(this);
return expr;
}
@Override
public Object accept(ASTVisitor v) throws PrismLangException {
return v.visit(this);
}
@Override
public String toString() {
// TODO Auto-generated method stub
String s = "P[" + 
```
<Overlap Ratio: 0.8459900638750887>

---

--- 78 --
Question ID: c97f14a7bf5ef3debf95529c86f3c6c29665f8e0
Original Code:
```
public class Main {

    public static void main(String[] args) {
        LinkedList<Integer> linkedList = new LinkedList<Integer>();
        linkedList.add(3);
        linkedList.add(8);
        System.out.println("Integer linked list content: " + linkedList);
        LinkedList<String> linkedList2 = new LinkedList<String>();
        linkedList2.add("foo");
        linkedList2.add("bar");
        linkedList2.add("baz");
        linkedList2.add("qux");
        System.out.println("String linked list content: " + linkedList2);
        try {
            System.out.println("The second String contains " + linkedList2.get(1).length() + " letters.");
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        if (linkedList2.contains("baz")) {
            System.out.println("The String linked list contains the word 'baz'.");
        }
        if (!linkedList2.contains("quux")) {
            System.out.println("The String linked list does not contain the word 'quux'.");
        }
    }
}

```


Overlapping Code:
```
public class Main {
public static void main(String[] args) {
LinkedList<Integer> linkedList = new LinkedList<Integer>();
linkedList.add(3);
linkedList.add(8);
System.out.println("Integer linked list content: " + linkedList);
LinkedList<String> linkedList2 = new LinkedList<String>();
linkedList2.add("foo");
linkedList2.add("bar");
linkedList2.add("baz");
linkedList2.add("qux");
System.out.println("String linked list content: " + linkedList2);
try {
System.out.println("The second String contains " + linkedList2.get(1).length() + " letters.");
} catch (Exception e) {
System.out.println(e.getMessage());
}
if (linkedList2.contains("baz")) {
System.out.println("The String linked list contains the word 'baz'.");
}
if (!linkedList2.contains("quux")) {
System.out.println("The String linked li
```
<Overlap Ratio: 0.9463647199046484>

---

--- 79 --
Question ID: 0194d4049752064a887d1e9fe16575075c992aa7
Original Code:
```
public final class SpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {

    public SpscLinkedAtomicQueue() {
        LinkedQueueNode<E> node = new LinkedQueueNode();
        spProducerNode(node);
        spConsumerNode(node);
        node.soNext(null);
    }

    public boolean offer(E nextValue) {
        if (nextValue == null) {
            throw new NullPointerException("null elements not allowed");
        }
        LinkedQueueNode<E> nextNode = new LinkedQueueNode(nextValue);
        lpProducerNode().soNext(nextNode);
        spProducerNode(nextNode);
        return true;
    }

    public E poll() {
        LinkedQueueNode<E> nextNode = lpConsumerNode().lvNext();
        if (nextNode == null) {
            return null;
        }
        E nextValue = nextNode.getAndNullValue();
        spConsumerNode(nextNode);
        return nextValue;
    }

    public E peek() {
        LinkedQueueNode<E> nextNode = lpConsumerNode().lvNext();
        if (nextNode != null) {
            return nextNode.lpValue();
        }
        return null;
    }
}

```


Overlapping Code:
```
s SpscLinkedAtomicQueue<E> extends BaseLinkedAtomicQueue<E> {
public SpscLinkedAtomicQueue() {
LinkedQueueNode<E> node = new LinkedQueueNode();
spProducerNode(node);
spConsumerNode(node);
node.soNext(null);
}
public boolean offer(E nextValue) {
if (nextValue == null) {
throw new NullPointerException("null elements not allowed");
}
LinkedQueueNode<E> nextNode = new LinkedQueueNode(nextValue);
lpProducerNode().soNext(nextNode);
spProducerNode(nextNode);
return true;
}
public E poll() {
LinkedQueueNode<E> nextNode = lpConsumerNode().lvNext();
if (nextNode == null) {
return null;
}
E nextValue = nextNode.getAndNullValue();
spConsumerNode(nextNode);
return nextValue;
}
public E peek() {
LinkedQueueNode<E> nextNode = lpConsumerNode().lvNext();
if (nextNode != null) {
return nextNode.lpValue();
}
return null;
}
```
<Overlap Ratio: 0.9772182254196643>

---

--- 80 --
Question ID: cda831809d818cc9f3aa657b63679325f432741b
Original Code:
```
public class ObsidianShard extends Item {

    public ObsidianShard() {
        super(new Item.Properties().tab(ObsidimancyItems.TAB_OBSIDIMANCY));
    }

    @Override
    @ParametersAreNonnullByDefault
    public void appendHoverText(ItemStack pStack, @Nullable Level pLevel, List<Component> pTooltipComponents, TooltipFlag pIsAdvanced) {
        super.appendHoverText(pStack, pLevel, pTooltipComponents, pIsAdvanced);
        final double overworldAttuneProgress = Optional.of(pStack.getOrCreateTag()).map(compoundTag -> compoundTag.getDouble(AttunementAltar.OVERWORLD_ATTUNE_PROGRESS)).orElse(0D);
        final double netherAttuneProgress = Optional.of(pStack.getOrCreateTag()).map(compoundTag -> compoundTag.getDouble(AttunementAltar.NETHER_ATTUNE_PROGRESS)).orElse(0D);
        final double endAttuneProgress = Optional.of(pStack.getOrCreateTag()).map(compoundTag -> compoundTag.getDouble(AttunementAltar.END_ATTUNE_PROGRESS)).orElse(0D);
        if (overworldAttuneProgress != 0) {
            pTooltipComponents.add(new TranslatableComponent("obsidimancy.overworld_attunement_message", String.format("%.2f", overworldAttuneProgress / 3 * 100) + "%").withStyle(ChatFormatting.BLUE));
        }
        if (netherAttuneProgress != 0) {
            pTooltipComponents.add(new TranslatableComponent("obsidimancy.nether_attunement_message", String.format("%.2f", netherAttuneProgress / 3 * 100) + "%").withStyle(ChatFormatting.RED));
        }
        if (endAttuneProgress != 0) {
            pTooltipComponents.add(new TranslatableComponent("obsidimancy.end_attunement_message", String.format("%.2f", endAttuneProgress / 3 * 100) + "%").withStyle(ChatFormatting.AQUA));
        }
    }
}

```


Overlapping Code:
```
 ObsidianShard extends Item {
public ObsidianShard() {
super(new Item.Properties().tab(ObsidimancyItems.TAB_OBSIDIMANCY));
}
@Override
@ParametersAreNonnullByDefault
public void appendHoverText(ItemStack pStack, @Nullable Level pLevel, List<Component> pTooltipComponents, TooltipFlag pIsAdvanced) {
super.appendHoverText(pStack, pLevel, pTooltipComponents, pIsAdvanced);
final double overworldAttuneProgress = Optional..map(compoundTag -> compoundTag.getDouble(AttunementAltar.OVERWORLD_ATTU.map(compoundTag -> compoundTag.getDouble(Attunemel double endAttuneProgress = Optional.of(pStack.ge.map(compoundTag -> compoundTag.getDouble(Attunemelse(0D);
if (overworldAttuneProgress != 0) {
pTooltipComponents.add(new TranslatableComponent("obsidimancy.overworld_attunement_message", String.format("%.2f", overworldAttuneProgress / 3 * 100) + "%").withStyle(ChatFormatting.BLUE));
}
if (netherAttuneProgress != 0) {
pTooltipComponents.add(new TranslatableComponent("obsidimancy.nether_attunement_message", String.format("%.2f", netherAttuneProgress / 3 * 100) + "%").withStyle(ChatFormatting.RED));
}
if (endAttuneProgress != 0) {
pTooltipComponents.add(new TranslatableComponent("obsidimancy.end_attunement_message", String.format("%.2f", endAttuneProgress / 3 * 100) + "%").withStyle(ChatFormat
```
<Overlap Ratio: 0.8366817887232664>

---

--- 81 --
Question ID: 200206ad1100a42ddac095ef06efa73f03de0dd3
Original Code:
```
class Example5_ConcatAndAppend {

    /**
     * Main Method. This is where the program begins.
     */
    public static void main(String[] args) {
        String united = "United";
        String states = "States";
        String of = "of";
        String america = "America";
        String usa1;
        //Initializes the usa1 variable by...
        usa1 = united + " " + states + " " + of + " " + america;
        //Prints the value of the usa variable
        System.out.println("Example 1: " + usa1);
        String usa2;
        //Assigns the value of united to usa2
        usa2 = united;
        //Appends a space to usa2
        usa2 = usa2 + " ";
        //Appends the value of states to usa2
        usa2 = usa2 + states;
        //Appends a space to usa2
        usa2 = usa2 + " ";
        //Appends the value of of to usa2
        usa2 += of;
        //Appends a sapce to usa2
        usa2 += " ";
        //Appends the value of america to usa2
        usa2 += america;
        //Prints the value of usa2 variable
        System.out.println("Example 2: " + usa2);
    }
}

```


Overlapping Code:
```
AndAppend {
/**
* Main Method. This is where the program begins.
*/
public static void main(String[] args) {
String united = "United";
String states = "States";
String of = "of";
String america = "Ame
```
<Overlap Ratio: 0.23391812865497075>

---

--- 82 --
Question ID: fa6beaa76b8c1e5865d612bbe2c25921a6e42fb2
Original Code:
```
public class S3ArtifactContentProvider implements ArtifactContentProvider {

    private final static Logger LOG = Logger.getInstance(S3ArtifactContentProvider.class.getName());

    private final ServerPaths myServerPaths;

    public S3ArtifactContentProvider(@NotNull ServerPaths serverPaths) {
        myServerPaths = serverPaths;
    }

    @NotNull
    @Override
    public String getType() {
        return S3Constants.S3_STORAGE_TYPE;
    }

    @NotNull
    @Override
    public InputStream getContent(@NotNull StoredBuildArtifactInfo storedBuildArtifactInfo) throws IOException {
        final Map<String, String> params;
        final ArtifactData artifactData = storedBuildArtifactInfo.getArtifactData();
        if (artifactData == null) {
            throw new IOException("Invalid artifact data: S3 object path property is not set");
        }
        final String artifactPath = artifactData.getPath();
        try {
            params = S3Util.validateParameters(storedBuildArtifactInfo.getStorageSettings());
        } catch (IllegalArgumentException e) {
            throw new IOException("Failed to get artifact " + artifactPath + " content: Invalid storage settings " + e.getMessage(), e);
        }
        final String bucketName = S3Util.getBucketName(params);
        final String key = S3Util.getPathPrefix(storedBuildArtifactInfo.getCommonProperties()) + artifactPath;
        try {
            return S3Util.withS3Client(ParamUtil.putSslValues(myServerPaths, params), client -> client.getObject(bucketName, key).getObjectContent());
        } catch (Throwable t) {
            final AWSException awsException = new AWSException(t);
            final String details = awsException.getDetails();
            if (StringUtil.isNotEmpty(details)) {
                final String message = awsException.getMessage() + details;
                LOG.warn(message);
            }
            throw new IOException(String.format("Failed to get artifact '%s' content in bucket '%s': %s", artifactPath, bucketName, awsException.getMessage()), awsException);
        }
    }
}

```


Overlapping Code:
```
c class S3ArtifactContentProvider implements ArtifactContentProvider {
private final static Logger LOG = Logger.getInstance(S3ArtifactContentProvider.class.getName());
private final ServerPaths myServerPaths;
public S3ArtifactContentProvider(@NotNull ServerPaths serverPaths) {
myServerPaths = serverPaths;
}
@NotNull
@Override
public String getType() {
return S3Constants.S3_STORAGE_TYPE;
}
@NotNull
@Override
public InputStream getContent(@NotNull StoredBuildArtifactInfo storedBuildArtifactInfo) throws IOException {
final Map<String, String> params;
final ArtifactData artifactData = storedBuildArtifactInfo.getArtifactData();
if (artifactData == null) {
throw new IOException("Invalid artifact data: S3 object path property is not set");
}
final String artifactPath = artifactData.getPath();
try {
params = S3Util.validateParameters(storedBuildArtifactInfo.getStorageSettings());
} catch (IllegalArgumentException e) {
throw new IOException("Failed to get artifact " + artifactPath + " content: Invalid storage settings " + e.getMessage(), e);
}
final String bucketName = S3Util.getBucketName(params);
final String key = S3Util.getPathPrefix(storedBuildArtifactInfo.getCommonProperties()) + artifactPath;
try {
return S3Util.withS3ClienamUtil.putSslValues(myServerPaths, params), client -> client.getObject(bucketName, key).getObjectContent());
} catch (Throwable t) {
final AWSException awsException = new AWSException(t);
final String details = awsException.getDetails();
if (StringUtil.isNotEmpty(details)) {
final String message = awsException.getMessage() + details;
LOG.warn(message);
}
throw new IOException(String.format("Failed to get
```
<Overlap Ratio: 0.9279279279279279>

---

--- 83 --
Question ID: ac8564a3b708ca4495959d57dc906f61cac2ece9
Original Code:
```
public class LeftJoinTest {

    @Test
    public void testLeftJoin() {
        HashMap one = new HashMap();
        one.put("kis", "pande");
        one.put("kiss", "pan");
        one.put("kisss", "pnde");
        one.put("kissss", "pae");
        HashMap two = new HashMap();
        two.put("kis", "Sarvin");
        two.put("kiss", "Srvin");
        two.put("kisss", "Savin");
        two.put("kissss", "Sarvn");
        HashMap<String, String[]> test = LeftJoin.leftJoin(one, two);
        assertEquals("", 4, test.size());
        assertTrue("", test.containsKey("kisss"));
        assertEquals("", "pande", test.get("kis")[0]);
    }
}

```


Overlapping Code:
```
ass LeftJoinTest {
@Test
public void testLeftJoin(pae");
HashMap two = new HashMap();
two.put("kis",
```
<Overlap Ratio: 0.19305019305019305>

---

--- 84 --
Question ID: 359cc5c8d7ac575f7adc9a4e147dd319b2dcdb15
Original Code:
```
public class GetFilingPackageSD {

    private final OauthService oauthService;

    private final SubmissionService submissionService;

    private final UUID actualTransactionId;

    private UserIdentity actualUserIdentity;

    private Response actualFilingPackageResponse;

    private final Logger logger = LoggerFactory.getLogger(GetFilingPackageSD.class);

    public GetFilingPackageSD(OauthService oauthService, SubmissionService submissionService) {
        this.oauthService = oauthService;
        this.submissionService = submissionService;
        actualTransactionId = UUID.randomUUID();
    }

    @Given("valid user account is authenticated")
    public void validAdminAccountThatAuthenticated() {
        actualUserIdentity = oauthService.getUserIdentity();
    }

    @When("user submits request to get filing package information")
    public void filingPackageRequest() throws IOException {
        logger.info("Submitting get filing package request");
        File resource = new ClassPathResource(MessageFormat.format("data/{0}", Keys.TEST_DOCUMENT_PDF)).getFile();
        MultiPartSpecification fileSpec = SubmissionHelper.fileSpecBuilder(resource, Keys.TEST_DOCUMENT_PDF, "text/application.pdf");
        Response actualDocumentResponse = submissionService.documentUploadResponse(actualUserIdentity.getAccessToken(), actualTransactionId, actualUserIdentity.getUniversalId(), fileSpec);
        String actualSubmissionId = submissionService.getSubmissionId(actualDocumentResponse);
        // Generate Url Response
        submissionService.generateUrlResponse(actualTransactionId, actualUserIdentity.getUniversalId(), actualUserIdentity.getAccessToken(), actualSubmissionId, Keys.ACTION_STATUS_SUB);
        actualFilingPackageResponse = submissionService.getSubmissionDetailsResponse(actualUserIdentity.getAccessToken(), actualTransactionId, actualSubmissionId, Keys.FILING_PACKAGE_PATH);
        logger.info("Api response status code: {}", Integer.valueOf(actualFilingPackageResponse.getStatusCode()));
        logger.info("Api response: {}", actualFilingPackageResponse.asString());
    }

    @Then("a valid filing package information is returned")
    public void getFilingPackageResults() {
        logger.info("Asserting get filing package response");
        JsonPath filingPackageJsonPath = new JsonPath(actualFilingPackageResponse.asString());
        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get("submissionFeeAmount"));
        Assert.assertEquals("1211", filingPackageJsonPath.get("court.location"));
        Assert.assertEquals("P", filingPackageJsonPath.get("court.level"));
        Assert.assertEquals("F", filingPackageJsonPath.get("court.courtClass"));
        Assert.assertEquals(Integer.valueOf(10), filingPackageJsonPath.get("court.agencyId"));
        Assert.assertEquals("Imma Court", filingPackageJsonPath.get("court.locationDescription"));
        Assert.assertEquals("Imma Level", filingPackageJsonPath.get("court.levelDescription"));
        Assert.assertEquals("Imma Class", filingPackageJsonPath.get("court.classDescription"));
        Assert.assertEquals(Keys.TEST_DOCUMENT_PDF, filingPackageJsonPath.get("documents.documentProperties.name[0]"));
        Assert.assertEquals("AFF", filingPackageJsonPath.get("documents.documentProperties.type[0]"));
        Assert.assertEquals("This is a doc", filingPackageJsonPath.get("documents.description[0]"));
        Assert.assertEquals("application/pdf", filingPackageJsonPath.get("documents.mimeType[0]"));
        Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.get("documents.statutoryFeeAmount[0]"));
        Assert.assertEquals("first", filingPackageJsonPath.get("parties.firstName[0]"));
        Assert.assertEquals("middle", filingPackageJsonPath.get("parties.middleName[0]"));
        Assert.assertEquals("last", filingPackageJsonPath.get("parties.lastName[0]"));
        logger.info("Response matches the requirements");
    }
}

```


Overlapping Code:
```
SD {
private final OauthService oauthService;
private final SubmissionService submissionService;
private final UUID actualTransactionId;
private UserIdentity actualUserIdentity;
private Response actualFilingPackageResponse;
private final Logger logger = LoggerFactory.getLogger(GetFilingPackageSD.class);
public GetFilingPackageSD(OauthService oauthService, SubmissionService submissionService) {
this.oauthService = oauthService;
this.submissionService = submissionService;
actualTransactionId = UUID.randomUUID();
}
@Given("valid user account is authenticated")
public void validAdminAccountThatAuthenticated() {
actualUserIdentity = oauthService.getUserIdentity();
}
@When("user submits request to get filing package information")
public void filingPackageRequest() throws IOException {
logger.info("Submitting get filing package request");
File resource = new ClassPathResoursageFormat.format("data/{0}", Keys.TEST_DOCUMENT_PDF)).getFile();
MultiPartSpecification fileSpec = SubmissionHelper.fileSpecBuilder(resource, Keys.TEST_DOCUMENT_PDF, "text/application.pdf");
Response actualDocumentResponse = submissionService.documentUploadResponse(actualUserIdentity.getAccessToken(), actualTransactionId, actualUserIdentity.getUniversalId(), fileSpec);
String actualSubmissionId = submissionService.getSubmissionId(actualDocumentResponse);
// Generate Url Response
submissionService.generateUrlResponse(actualTransactionId, actualUserIdentity.getUniversalIdrIdentity.getAccessToken(), actualSubmissionId, Keys.ACTION_STATUS_SUB);
actualFilingPackageResponse = submissionService.getSubmissionDetailsResponse(actualUserIdentity.getAccessToken(), actualTransactionIdNG_PACKAGE_PATH);
logger.info("Api response status code: {}", Integer.valueOf(actualFilingPackageResponse.getStatusCode()));
logger.info("Api response: {}", actualFilingPackageResponse.asString());
}
@Then("a valid filing package information is returned")
public void getFilingPackageResults() {
logger.info("Asserting get filing package response");
JsonPath filingPackageJsonPath = new JsonPath(actualFilingPackageResponse.asString());
Assert.assertEquals(Integer.valueOf(7), filingPackageJsonPath.g
```
<Overlap Ratio: 0.947829899167032>

---

--- 85 --
Question ID: 73f66a22b3c991c1a48893c0996622a8d2412519
Original Code:
```
public class MiniMaxSum {

    public static void main(String[] args) {
        Scanner stdin = new Scanner(System.in);
        Object[] numbers = Arrays.stream(stdin.nextLine().split(" ")).map(Long::parseLong).toArray();
        Arrays.sort(numbers);
        long minSum = 0;
        long maxSum = 0;
        int i = 0;
        while (i < numbers.length - 1) try {
            minSum += (long) numbers[i];
            maxSum += (long) numbers[i + 1];
        } finally {
            i++;
        }
        System.out.println(minSum + " " + maxSum);
        stdin.close();
    }
}

```


Overlapping Code:
```
blic class MiniMaxSum {
public static void main(String[] args) {
Scanner stdin = new Scanner(System.in);
Object[] numbers = Arrays.stream(stdin.nextLine().split(" ")).map(+= (long) numbers[i];
maxSum += (long) numbers[i +
```
<Overlap Ratio: 0.49440715883668906>

---

--- 86 --
Question ID: 3e73974b19bd63eef0024f08c1d9d9f3549ef0b5
Original Code:
```
public class RestClientLoadBalancerTest {

    public static ResourceBundle messageBundle = ResourceBundle.getBundle("Messages");

    public static MessageUtils messageUtils = new MessageUtils(messageBundle);

    public static HttpClient httpClient = HttpClient.newHttpClient();

    public static MockWebServer mockServer;

    @BeforeEach
    void setUp() throws IOException {
        mockServer = new MockWebServer();
        mockServer.start();
    }

    @Test
    public void happyMakeRequest() throws Exception {
        Boolean staticServerList = true;
        ArrayList<Server> networkServerList = new ArrayList<>();
        Integer statusCode = 200;
        String body = "someBody";
        mockServer.enqueue(new MockResponse().addHeader("Content-Type", "application/json; charset=utf-8").setBody(body).setResponseCode(statusCode));
        String urlServer1 = String.format("http://%s:%s/", mockServer.getHostName(), mockServer.getPort());
        String urlServer2 = "https://incorrectServer:200";
        networkServerList.add(new Server(urlServer1, 1));
        networkServerList.add(new Server(urlServer2, 2));
        ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);
        RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());
        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();
        String networkID = "identifier1";
        String parameters = "?network_id=" + networkID;
        HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);
        Integer actual = httpResponse.statusCode();
        Integer expected = statusCode;
        assertTrue(actual.equals(expected));
        assertTrue(httpResponse.body().equals(body));
    }

    @Test
    public void happyMakeRequestAfterRetries() throws Exception {
        Boolean staticServerList = true;
        ArrayList<Server> networkServerList = new ArrayList<>();
        Integer statusCode = 400;
        String body = "badBody";
        int i = 0;
        while (i < 5) try {
            mockServer.enqueue(new MockResponse().addHeader("Content-Type", "application/json; charset=utf-8").setBody(body + i).setResponseCode(statusCode));
        } finally {
            i++;
        }
        statusCode = 200;
        body = "goodBody";
        for (int i = 0; i < 5; i++) {
            mockServer.enqueue(new MockResponse().addHeader("Content-Type", "application/json; charset=utf-8").setBody(body + i).setResponseCode(statusCode));
        }
        String urlServer1 = String.format("http://%s:%s/", mockServer.getHostName(), mockServer.getPort());
        String urlServer2 = "https://incorrectServer:200";
        networkServerList.add(new Server(urlServer1, 1));
        networkServerList.add(new Server(urlServer2, 2));
        ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);
        RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());
        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();
        String networkID = "identifier1";
        String parameters = "?network_id=" + networkID;
        HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);
        Integer actual = httpResponse.statusCode();
        Integer expected = statusCode;
        assertTrue(actual.equals(expected));
        assertTrue(httpResponse.body().equals("goodBody0"));
        System.out.println(loadBalancer.getLoadBalancerStats().getServerStats());
    }

    @Test
    public void failedMakeRequestNoValidServer() {
        Boolean staticServerList = true;
        ArrayList<Server> networkServerList = new ArrayList<>();
        String urlServer1 = "https://incorrectServer1:100";
        String urlServer2 = "https://incorrectServer2:200";
        networkServerList.add(new Server(urlServer1, 1));
        networkServerList.add(new Server(urlServer2, 2));
        ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);
        RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());
        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();
        String networkID = "identifier1";
        String parameters = "?network_id=" + networkID;
        ResolutionException exception = assertThrows(ResolutionException.class, () -> {
            HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);
        });
        assertTrue(exception.getMessage().contains("Number of retries on next server exceeded max 10 retries"));
    }

    @Test
    public void failedMakeRequestInvalidServerPlusValidServerWithInvalidResponse() {
        Boolean staticServerList = true;
        ArrayList<Server> networkServerList = new ArrayList<>();
        Integer statusCode = 400;
        String body = "someBody";
        int i = 0;
        while (i < 10) try {
            mockServer.enqueue(new MockResponse().addHeader("Content-Type", "application/json; charset=utf-8").setBody(body + i).setResponseCode(statusCode));
        } finally {
            i++;
        }
        String urlServer1 = String.format("http://%s:%s/", mockServer.getHostName(), mockServer.getPort());
        String urlServer2 = "https://incorrectServer:200";
        networkServerList.add(new Server(urlServer1, 1));
        networkServerList.add(new Server(urlServer2, 2));
        ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);
        RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());
        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();
        String networkID = "identifier1";
        String parameters = "?network_id=" + networkID;
        ResolutionException exception = assertThrows(ResolutionException.class, () -> {
            HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);
        });
        assertTrue(exception.getMessage().contains("Number of retries on next server exceeded max 10 retries"));
    }

    @AfterEach
    void tearDown() throws Exception {
        mockServer.shutdown();
    }
}

```


Overlapping Code:
```
 static ResourceBundle messageBundle = ResourceBundle.getBundle("Messages");
public static MessageUtils messageUtils = new MessageUtils(messageBundle);
public static HttpClient httpClient = HttpClient.newHttpClient();
public static MockWebServer mockServer;
@BeforeEach
void setUp() throws IOException {
mockServer = new MockWebServer();
mockServer.start();
}
@Test
public void happyMakeRequest() throws Exception {
Boolean staticServerList = true;
ArrayList<Server> networkServerList = new ArrayList<>();
Integer statusCode = 200;
String body = "somerver.enqueue(new MockResponse().addHeader("Content-Type", "application/json; charset=utf-8").setBo));
String urlServer1 = String.format("http://%s:%s/", mockServer.getHostName(), mockServer.getPort());
String urlServer2 = "https://incorrectServer:200";
networkServerList.add(new Server(urlServer1, 1));
networkServerList.add(new Server(urlServer2, 2));
ServerEnvironment serverEnvironment = new ServerEnvironment(networkServerList, REGISTRY_METHOD_GET, staticServerList);
RestClientLoadBalancer loadBalancer = new RestClientLoadBalancer(httpClient, messageUtils, serverEnvironment.getUrlList());
HttpRequest.Builder requestBuilder = HttpRequest.newBuilder();
String networkID = "identifier1";
String parameters = "?network_id=" + networkID;
HttpResponse<String> httpResponse = loadBalancer.makeRequestWithRetry(requestBuilder, parameters);
Integer actual = httpResponse.statusCode();
Integer expected = statusCode;
assertTrue(actual.equals(expected));
assertTrue(httpResponse.body().equals(body));
}
@Test
public void happyMakeRequestAfterRetries() throws Exception {
Boolean staticServerList = true;
ArrayList<Server> networkServerList = new ArrayList<>();
Integer statusCode = 400;
String body = erver.enqueue(new MockResponse().addHeader("Content-Type", "application/json; charset=utf-8").setBoode = 200;
body = "goodBody";
for (int i = 0; i < 
```
<Overlap Ratio: 0.8819702602230484>

---

--- 87 --
Question ID: 2fdee659338464d3cee41b3776ec8893a1c5cafb
Original Code:
```
public class HttpClientUtils {

    private static final Logger logger = LoggerFactory.getLogger(HttpClientUtils.class);

    public static CloseableHttpClient getHttpClient(HasProxySettings proxySetting) {
        CloseableHttpClient httpclient = null;
        if (proxySetting != null && proxySetting.isActive()) {
            logger.info("Set the http proxy (" + proxySetting.getHost() + ":" + proxySetting.getPort() + ")");
            CredentialsProvider credsProvider = Preconditions.checkNotNull(proxySetting.getCredentialsProvider());
            HttpHost proxy = new HttpHost(proxySetting.getHost(), proxySetting.getPort());
            DefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);
            httpclient = HttpClients.custom().setRoutePlanner(routePlanner).setDefaultCredentialsProvider(credsProvider).build();
        } else {
            httpclient = HttpClients.createDefault();
        }
        return httpclient;
    }
}

```


Overlapping Code:
```
public class HttpClientUtils {
private static final Logger logger = LoggerFactory.getLogger(HttpClientUtils.class);
public static CloseableHttpClient getHttpClient(etting != null && proxySetting.isActive()) {
logger.info("Set the http proxy (" + proxySetting.getHost() + ":" + pntialsProvider credsProvider = Preconditions.checkNotNull(proxySttpHost proxy = new HttpHost(proxySetting.getHost(), proxySetting.getPort());
DefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);
httpclient = HttpClients.custom().setRoutePlanner(routePlanner).setDefaultCredentialsProvider(credsProvider).build();
} else {
httpclient = HttpClients.createDefault();
}
return httpclient;
}

```
<Overlap Ratio: 0.8182897862232779>

---

--- 88 --
Question ID: 856bafe9197904c12be321e8dde1820862f17070
Original Code:
```
@SuppressWarnings({ "unused" })
public class StaffCoreAPI {

    private static main plugin;

    public StaffCoreAPI(main plugin) {
        StaffCoreAPI.plugin = plugin;
    }

    public static String getIP(String player) {
        if (utils.mysqlEnabled())
            return AltsQuery.getIp(player);
        try {
            return Bukkit.getPlayer(player).getAddress().getAddress().toString();
        } catch (NullPointerException error) {
            return "";
        }
    }

    public static int getPing(String player) {
        try {
            return utils.getPing(Bukkit.getPlayer(player));
        } catch (NullPointerException error) {
            return 0;
        }
    }

    public static ArrayList<String> getSavedPlayerList() {
        return utils.getUsers();
    }

    public static List<String> getPlayerAlts(String player) {
        return CheckAlts.alts(player);
    }

    public static void clearPlayerChat(Player player) {
        utils.ccPlayer(player);
    }

    public static void clearAllPlayersChat() {
        utils.ccAll();
    }

    public static boolean isRegistered(String player) {
        return utils.isRegistered(player);
    }

    public static boolean mysqlEnabled() {
        return utils.mysqlEnabled();
    }

    public static boolean getFrozenStatus(String player) {
        if (mysqlEnabled())
            return FreezeQuery.isFrozen(player).equalsIgnoreCase("true");
        try {
            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, "frozen"), PersistentDataType.STRING);
        } catch (NullPointerException error) {
            return false;
        }
    }

    public static boolean getVanishedStatus(String player) {
        if (mysqlEnabled())
            return VanishQuery.isVanished(player).equalsIgnoreCase("true");
        try {
            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, "vanished"), PersistentDataType.STRING);
        } catch (NullPointerException error) {
            return false;
        }
    }

    public static boolean getStaffStatus(String player) {
        if (mysqlEnabled())
            return StaffQuery.isStaff(player).equalsIgnoreCase("true");
        try {
            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, "staff"), PersistentDataType.STRING);
        } catch (NullPointerException error) {
            return false;
        }
    }

    public static boolean getStaffChatStatus(String player) {
        if (mysqlEnabled())
            return StaffChatQuery.isStaffChat(player).equalsIgnoreCase("true");
        try {
            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, "staffchat"), PersistentDataType.STRING);
        } catch (NullPointerException error) {
            return false;
        }
    }

    public static boolean getFlyingStatus(String player) {
        return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, "flying"), PersistentDataType.STRING);
    }

    public static boolean getTrollStatus(String player) {
        try {
            return Bukkit.getPlayer(player).getPersistentDataContainer().has(new NamespacedKey(plugin, "troll"), PersistentDataType.STRING);
        } catch (NullPointerException error) {
            return false;
        }
    }

    public static boolean isBanned(String player) {
        if (mysqlEnabled())
            return BansQuery.getBannedPlayers().contains(player);
        List<String> bannedPlayers = new ArrayList<>();
        ConfigurationSection bans = plugin.bans.getConfig().getConfigurationSection("bans");
        for (String s : bans.getKeys(false)) bannedPlayers.add(plugin.bans.getConfig().getString("bans." + s + ".name"));
        return bannedPlayers.contains(player);
    }

    public static boolean isWarned(String player) {
        if (mysqlEnabled())
            return WarnsQuery.getWarnedPlayers().contains(player);
        List<String> warnedPlayers = new ArrayList<>();
        ConfigurationSection warns = plugin.warns.getConfig().getConfigurationSection("warns");
        for (String s : warns.getKeys(false)) warnedPlayers.add(plugin.warns.getConfig().getString("warns." + s + ".name"));
        return warnedPlayers.contains(player);
    }

    public static void setFrozenStatus(Player target, String sender, boolean status) {
        FreezePlayer.FreezePlayer(target, sender, status);
    }

    public static void setVanishStatus(Player target, boolean status) {
        SetVanish.setVanish(target, status);
    }

    public static void setStaffStatus(Player target, boolean status) {
        if (status) {
            SetStaffItems.On(target);
        } else {
            SetStaffItems.Off(target);
        }
    }

    public static void setStaffChatStatus(Player target, boolean status) {
        if (mysqlEnabled()) {
            if (status) {
                StaffChatQuery.enable(target.getName());
            } else {
                StaffChatQuery.disable(target.getName());
            }
        } else if (status) {
            target.getPersistentDataContainer().set(new NamespacedKey(plugin, "staffchat"), PersistentDataType.STRING, "staffchat");
        } else {
            target.getPersistentDataContainer().remove(new NamespacedKey(plugin, "staffchat"));
        }
    }

    public static void setFlyingStatus(Player target, boolean status) {
        new SetFly(target, status);
    }

    public static ArrayList<String> getBannedPlayers() {
        ArrayList<String> bannedPlayers = new ArrayList<>();
        if (utils.mysqlEnabled()) {
            bannedPlayers.addAll(BansQuery.getBannedPlayers());
        } else {
            try {
                ConfigurationSection inventorySection = plugin.bans.getConfig().getConfigurationSection("bans");
                for (String key : inventorySection.getKeys(false)) {
                    String name = plugin.bans.getConfig().getString("bans." + key + ".name");
                    if (!bannedPlayers.contains(name))
                        bannedPlayers.add(name);
                }
            } catch (NullPointerException ignored) {
            }
        }
        return bannedPlayers;
    }

    public static ArrayList<String> getReportedPlayers() {
        ArrayList<String> reportedPlayers = new ArrayList<>();
        if (utils.mysqlEnabled()) {
            reportedPlayers.addAll(ReportsQuery.getReportedPlayers());
        } else {
            ConfigurationSection inventorySection = plugin.reports.getConfig().getConfigurationSection("reports");
            for (String key : inventorySection.getKeys(false)) {
                String name = plugin.reports.getConfig().getString("reports." + key + ".name");
                if (!reportedPlayers.contains(name))
                    reportedPlayers.add(name);
            }
        }
        return reportedPlayers;
    }

    public static void setTrollMode(Player p, Boolean bol) {
        PersistentDataContainer PlayerData = p.getPersistentDataContainer();
        if (bol) {
            PlayerData.set(new NamespacedKey(plugin, "troll"), PersistentDataType.STRING, "troll");
        } else {
            PlayerData.remove(new NamespacedKey(plugin, "troll"));
        }
    }

    public static ArrayList<String> getWarnedPlayers() {
        return utils.getWarnedPlayers();
    }

    public static Boolean isStillBanned(int Id) {
        if (utils.mysqlEnabled())
            return BansQuery.isStillBanned(Id);
        try {
            Date now = new Date();
            Date exp_date = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss").parse(plugin.bans.getConfig().getString("bans." + Id + ".expdate"));
            if (now.after(exp_date)) {
                plugin.bans.getConfig().set("bans." + Id + ".status", "closed");
                plugin.bans.saveConfig();
                plugin.bans.reloadConfig();
                return false;
            }
            return true;
        } catch (ParseException | NullPointerException ignored) {
            ignored.printStackTrace();
            plugin.bans.getConfig().set("bans." + Id + ".status", "closed");
            plugin.bans.saveConfig();
            plugin.bans.reloadConfig();
            return false;
        }
    }

    public static Boolean isStillWarned(int Id) {
        if (utils.mysqlEnabled()) {
            return WarnsQuery.isStillWarned(Id);
        }
        try {
            Date now = new Date();
            Date exp_date = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss").parse(plugin.warns.getConfig().getString("warns." + Id + ".expdate"));
            if (now.after(exp_date)) {
                plugin.warns.getConfig().set("warns." + Id + ".status", "closed");
                plugin.warns.saveConfig();
                plugin.warns.reloadConfig();
                return false;
            }
            return true;
        } catch (ParseException | NullPointerException ignored) {
            plugin.warns.getConfig().set("warns." + Id + ".status", "closed");
            plugin.warns.saveConfig();
            plugin.warns.reloadConfig();
            return false;
        }
    }

    public static void banPlayer(CommandSender sender, String banned, String reason, Long amount, String time) {
        BanPlayer.BanCooldown(sender, banned, reason, amount, time);
    }

    public static void banPlayer(CommandSender sender, String banned, String reason) {
        BanPlayer.BanPlayer(sender, banned, reason);
    }

    public static void warnPlayer(Player player, String warned, String reason, Long amount, String time) {
        WarnPlayer.createWarn(player, warned, reason, amount, time);
    }

    public static void warnPlayer(Player player, String warned, String reason) {
        WarnPlayer.createWarn(player, warned, reason, utils.getInt("warns.expire_after", null), utils.getString("warns.expire_after_quantity"));
    }

    public static void muteGlobalChat() {
        main.plugin.chatMuted = true;
    }

    public static void unMuteGlobalChat() {
        main.plugin.chatMuted = false;
    }

    public static void mutePlayerChat(CommandSender sender, Player muted) {
        ToggleChat.MutePlayer(sender, muted);
    }

    public static void unMutePlayerChat(CommandSender sender, Player muted) {
        ToggleChat.unMute(sender, muted);
    }

    public static List<String> getVanishedPlayers() {
        if (mysqlEnabled()) {
            return VanishQuery.getVanishedPlayers();
        } else {
            List<String> vanishedPlayer = new ArrayList<>();
            for (Player p : Bukkit.getOnlinePlayers()) {
                if (p.getPersistentDataContainer().has(new NamespacedKey(plugin, "vanished"), PersistentDataType.STRING)) {
                    vanishedPlayer.add(p.getName());
                }
            }
            return vanishedPlayer;
        }
    }

    public static List<String> getStaffPlayers() {
        if (mysqlEnabled()) {
            return StaffQuery.getStaffPlayers();
        } else {
            List<String> staffPlayer = new ArrayList<>();
            for (Player p : Bukkit.getOnlinePlayers()) {
                if (p.getPersistentDataContainer().has(new NamespacedKey(plugin, "staff"), PersistentDataType.STRING)) {
                    staffPlayer.add(p.getName());
                }
            }
            return staffPlayer;
        }
    }

    public static Boolean isOlderVersion() {
        return utils.isOlderVersion();
    }

    public static double getTPS() {
        return TPS.getTPS();
    }

    public static String getServerVersion() {
        return Bukkit.getServer().getClass().getPackage().getName().substring(23);
    }

    public static int getCurrentBans() {
        return BanPlayer.currentBans();
    }

    public static int getCurrentWarns() {
        if (mysqlEnabled()) {
            return WarnsQuery.getCurrentWarns();
        } else {
            int current = 0;
            try {
                ConfigurationSection inventorySection = main.plugin.warns.getConfig().getConfigurationSection("warns");
                for (String key : inventorySection.getKeys(false)) current++;
            } catch (NullPointerException ignored) {
            }
            return current;
        }
    }

    public static int getCurrentReports() {
        if (mysqlEnabled()) {
            return ReportsQuery.getCurrentReports();
        } else {
            int current = 0;
            try {
                ConfigurationSection inventorySection = main.plugin.reports.getConfig().getConfigurationSection("reports");
                for (String key : inventorySection.getKeys(false)) current++;
            } catch (NullPointerException ignored) {
            }
            return current;
        }
    }

    public static String getIp(Player p) {
        InetAddress address = p.getAddress().getAddress();
        String ip = address.toString();
        ip = ip.replace("/", "");
        return ip;
    }
}

```


Overlapping Code:
```
ddress().toString();
} catch (NullPointerException).getPersistentDataContainer().has(new NamespacedKey(plug).getPersistentDataContainer().has(new NamespacedKey(plug).getPersistentDataContainer().has(new NamespacedKey(plug
```
<Overlap Ratio: 0.11022443890274314>

---

--- 89 --
Question ID: 4dae9c1547b458a35477b0baee243af818ee49fc
Original Code:
```
public class Pair<T, U> {

    /**
     * The first value.
     */
    public final T first;

    /**
     * The second value.
     */
    public final U second;

    /**
     * Create a new pair.
     *
     * @param first The first value.
     * @param second The second value.
     */
    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }
        if (other == null || getClass() != other.getClass()) {
            return false;
        }
        Pair<?, ?> pair = (Pair<?, ?>) other;
        return Objects.equals(first, pair.first) && Objects.equals(second, pair.second);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
        return Objects.hash(first, second);
    }
}

```


Overlapping Code:
```
*
* Create a new pair.
*
* @param first The first value.
* @param second The second value.
*/
public Pair(T first, U second) {
this.first = first;
this.second = second;
}
/**
* {@inheritDoc}
*/
@Override
public boolean equals(Object other) {
if (this == other) {
return true;
}
if (other == null || getClass() != other.getClass()) {
return false;
}
Pair<?, ?> pair = (Pair<?, ?>) other;
return Objects.equals(first, pair.first) && Objects.equals(second, pair.second);
}
/**
* {@inheritDoc}
*/
@Override
public int hashCode() {
return Objects.hash(first, second);
}

```
<Overlap Ratio: 0.8164739884393064>

---

--- 90 --
Question ID: 3bc37aa206b127ec430864edd59b331b4f994f0e
Original Code:
```
public class NobleIntegersInArray {

    public int nobleInteger(int[] arr) {
        Arrays.sort(arr);
        int i = 0;
        while (i < arr.length) try {
            if ((arr.length - 1 - i) == arr[i]) {
                return arr[i];
            }
        } finally {
            i++;
        }
        return -1;
    }
}

```


Overlapping Code:
```
lass NobleIntegersInArray {
public int nobleInteger(int[] arr
```
<Overlap Ratio: 0.2785388127853881>

---

--- 91 --
Question ID: c6ec38e3aa543ebec430a9ccbdb14ad544958a43
Original Code:
```
public class CreateShardMapManagerGlobalOperation extends StoreOperationGlobal {

    private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());

    /**
     * Creation mode.
     */
    private ShardMapManagerCreateMode createMode;

    /**
     * Target version of GSM to deploy, this will be used mainly for upgrade testing purpose.
     */
    private Version targetVersion;

    /**
     * Constructs request for deploying SMM storage objects to target GSM database.
     *
     * @param credentials
     *            Credentials for connection.
     * @param retryPolicy
     *            Retry policy.
     * @param operationName
     *            Operation name, useful for diagnostics.
     * @param createMode
     *            Creation mode.
     * @param targetVersion
     *            target version of store to deploy
     */
    public CreateShardMapManagerGlobalOperation(SqlShardMapManagerCredentials credentials, RetryPolicy retryPolicy, String operationName, ShardMapManagerCreateMode createMode, Version targetVersion) {
        super(credentials, retryPolicy, operationName);
        this.createMode = createMode;
        this.targetVersion = targetVersion;
    }

    /**
     * Whether this is a read-only operation.
     */
    @Override
    public boolean getReadOnly() {
        return false;
    }

    /**
     * Execute the operation against GSM in the current transaction scope.
     *
     * @param ts
     *            Transaction scope.
     * @return Results of the operation.
     */
    @Override
    public StoreResults doGlobalExecute(IStoreTransactionScope ts) {
        log.info("ShardMapManagerFactory {}, Started creating Global Shard Map structures.", this.getOperationName());
        Stopwatch stopwatch = Stopwatch.createStarted();
        StoreResults checkResult = ts.executeCommandSingle(SqlUtils.getCheckIfExistsGlobalScript().get(0));
        // If we did find some store deployed.
        if (checkResult.getStoreVersion() != null) {
            // DevNote: We need to have a way to error out if versions do not match.
            if (createMode == ShardMapManagerCreateMode.KeepExisting) {
                stopwatch.stop();
                throw new ShardManagementException(ShardManagementErrorCategory.ShardMapManagerFactory, ShardManagementErrorCode.ShardMapManagerStoreAlreadyExists, Errors._Store_ShardMapManager_AlreadyExistsGlobal);
            }
            log.info("ShardMapManagerFactory {}, Dropping existing Global Shard Map structures.", this.getOperationName());
            ts.executeCommandBatch(SqlUtils.getDropGlobalScript());
        }
        // Deploy initial version and run upgrade script to bring it to the specified version.
        ts.executeCommandBatch(SqlUtils.getCreateGlobalScript());
        ts.executeCommandBatch(SqlUtils.filterUpgradeCommands(SqlUtils.getUpgradeGlobalScript(), targetVersion));
        stopwatch.stop();
        log.info("ShardMapManagerFactory {}, Finished creating Global Shard Map structures. Duration:{}", this.getOperationName(), stopwatch.elapsed(TimeUnit.MILLISECONDS));
        return new StoreResults();
    }

    /**
     * Handles errors from the GSM operation after the LSM operations.
     *
     * @param result
     *            Operation result.
     */
    @Override
    public void handleDoGlobalExecuteError(StoreResults result) {
        log.debug("Always expect Success or Exception from DoGlobalExecute.");
    }

    /**
     * Error category for store exception.
     */
    @Override
    protected ShardManagementErrorCategory getErrorCategory() {
        return ShardManagementErrorCategory.ShardMapManagerFactory;
    }
}

```


Overlapping Code:
```
agerGlobalOperation extends StoreOperationGlobal {
private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
/**
* Creation mode.
*/
private ShardMapManagerCreateMode createMode;
/**
* Target version of GSM to deploy, this will be used mainly for upgrade testing purpose.
*/
private Version targetVersion;
/**
* Constructs request for deploying SMM storage objects to target GSM database.
*
* @param credentials
* Credentials for connection.
* @param retryPolicy
* Retry policy.
* @param operationName
* Operation name, useful for diagnostics.
* @param createMode
* Creation mode.
* @param targetVersion
* target version of store to deploy
*/
public CreateShardMapManagerGlobalOperation(SqlShardMapManagerCredentials credentials, RetryPolicy retryPolicy, String operationName, ShardMapManagerCreateMode createMode, Version targetVersion) {
super(credentials, retryPolicy, operationName);
this.createMode = createMode;
this.targetVersion = targetVersion;
}
/**
* Whether this is a read-only operation.
*/
@Override
public boolean getReadOnly() {
return false;
}
/**
* Execute the operation against GSM in the current transaction scope.
*
* @param ts
* Transaction scope.
* @return Results of the operation.
*/
@Override
public StoreResults doGlobalExecute(IStoreTransactionScope ts) {
log.info("ShardMapManagerFactory {}, Started creating Global Shard Map structures.", this.getOperationName());
Stopwatch stopwatch = Stopwatch.createStarted();
StoreResults checkResult = ts.executeCommandSingle(SqlUtils.getCheckIfExistsGlobalScript().get(0));
// If we did find some store deployed.
if (checkResult.getStoreVersion() != null) {
// DevNote: We need to have a way to error out if versions do not match.
if (createMode == ShardMapManagerCreateMode.KeepExisting) {
stopwatch.stop();
throw new ShardManagementException(ShardManagementErrorCategory.ShardMapManagerFactory,adyExists, Errors._Store_ShardMapManager_AlreadyExistsGlobal);
}
log.info("ShardMapManagerFactory {}
```
<Overlap Ratio: 0.9593301435406698>

---

--- 92 --
Question ID: d65782fcc75a5c257b78c54d73583aacf09dfa5d
Original Code:
```
@Component
public class SmsRabbitListener {

    @Resource
    private AliyunSmsUtil aliyunSmsUtil;

    /**
     * ??????????
     * <p>map????:</p>
     * <pre>
     * Map<String, Object> map = new LinkedHashMap<>();
     * //??????????
     * map.put("code", 785964);
     * //?????????????,???1000?????
     * map.put("phone", Arrays.asList("13012341234", "13812347894"));
     * //????
     * sendSms(map);
     * </pre>
     *
     * @param map ??map
     */
    @RabbitListener(bindings = @QueueBinding(value = @Queue(value = "LEJING.SMS.QUEUE", durable = "true"), exchange = @Exchange(value = "LEJING.SMS.EXCHANGE", type = ExchangeTypes.TOPIC, ignoreDeclarationExceptions = "true"), key = { "sms.verify.code" }))
    public void sendSms(Map<String, Object> map) {
        boolean flag = CollectionUtils.isEmpty(map) || Objects.isNull(map.get("phone")) || Objects.isNull(map.get("code")) || StringUtils.isBlank(map.get("phone").toString()) || StringUtils.isBlank(map.get("code").toString());
        if (flag) {
            return;
        }
        aliyunSmsUtil.sendSms(map);
    }
}

```


Overlapping Code:
```
ic class SmsRabbitListener {
@Resource
private AliyunSm:</p>
* <pre>
* Map<String, Object> map = new LinkedHashMap<>();
hone", Arrays.asList("13012341234", "13812347894"));
* //
*/
@RabbitListener(bindings = @QueueBinding(value = @Queue(value = "= @Exchange(value = "LEJING.SMS.EXCHANGE", type = ExchangeTypes.TOPIC, ignoreDeclarationExceptions = "trt> map) {
boolean flag = CollectionUtils.isEmpty(mmap.get("code").toString());
if (flag) {
return;
}

```
<Overlap Ratio: 0.4737394957983193>

---

--- 93 --
Question ID: 6830f69e5781fcb99df09fa5dae7e7634139394b
Original Code:
```
public class OffscreenView implements IView, IWindow {

    private static final Log log = Log.create();

    private boolean enabled = true;

    private final Config config;

    private final IController controller;

    private final Viewport viewport;

    private FrameBuffer frameBuffer;

    private String title;

    private IGPUImage colorTexture;

    private Texture depthTexture;

    private IContext context;

    public OffscreenView(IController controller, int w, int h, Config config) {
        this.config = config;
        this.controller = controller;
        this.viewport = new Viewport(0, 0, w, h);
        setSize(new Vec2(w, h));
        runOnSceneThread(t -> controller.viewCreated(this));
    }

    private void runOnSceneThread(IAction action) {
        if (controller.isSceneThread())
            action.run(controller.getScheduler().getTime());
        else
            controller.run(action);
    }

    @Override
    public void dispose() {
        frameBuffer = null;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

    @Override
    public Config getConfig() {
        return config;
    }

    @Override
    public IController getController() {
        return controller;
    }

    @Override
    public Viewport getViewport() {
        return viewport;
    }

    @Override
    public IWindow getWindow() {
        return this;
    }

    @Override
    public boolean isDisposed() {
        return frameBuffer == null;
    }

    class Context implements IContext {

        private final IContext ctx;

        public Context() {
            ctx = GLContextManager.acquireContext();
        }

        @Override
        public void close() throws Exception {
            GL11.glFinish();
            FrameBuffer.unbind();
            try {
                ctx.close();
            } catch (Throwable t) {
                log.severe(t);
            }
            context = null;
        }
    }

    @Override
    public IContext acquireContext() {
        context = new Context();
        if (frameBuffer == null || viewport.w != colorTexture.getWidth() || viewport.h != colorTexture.getHeight()) {
            if (frameBuffer == null)
                frameBuffer = new FrameBuffer();
            frameBuffer.bind();
            int width = (int) viewport.w;
            int height = (int) viewport.h;
            colorTexture = IGPUImage.create(width, height, ComponentType.BYTE, ComponentFormat.RGBA);
            frameBuffer.attach(GL30.GL_COLOR_ATTACHMENT0, colorTexture);
            depthTexture = new Texture(new GLObject(Type.TEXTURE), width, height);
            GL11.glBindTexture(GL11.GL_TEXTURE_2D, (int) depthTexture.getGPUHandle());
            GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_DEPTH_COMPONENT, width, height, 0, GL11.GL_DEPTH_COMPONENT, GL11.GL_UNSIGNED_INT, (ByteBuffer) null);
            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
            frameBuffer.attach(GL30.GL_DEPTH_ATTACHMENT, depthTexture);
            GL11.glBindTexture(GL11.GL_TEXTURE_2D, 0);
            GL20.glDrawBuffers(GL30.GL_COLOR_ATTACHMENT0);
            if (!frameBuffer.isComplete())
                log.severe("Status: " + FrameBuffer.toString(frameBuffer.getStatus()));
        } else
            frameBuffer.bind();
        return context;
    }

    @Override
    public void releaseContext() {
        try {
            context.close();
        } catch (Throwable t) {
            log.severe(t);
        }
        context = null;
    }

    @Override
    public void swapBuffers() {
    }

    @Override
    public String getTitle() {
        return title;
    }

    @Override
    public void setTitle(String title) {
        this.title = title;
    }

    @Override
    public boolean isVisible() {
        return !(isDisposed());
    }

    @Override
    public void setVisible(boolean visible) {
    }

    @Override
    public Vec2 getPosition() {
        return Vec2.ZERO;
    }

    @Override
    public void setPosition(Vec2 position) {
    }

    @Override
    public Vec2 getSize() {
        return new Vec2(colorTexture.getWidth(), colorTexture.getHeight());
    }

    @Override
    public void setSize(Vec2 size) {
        colorTexture = IGPUImage.create((int) size.x, (int) size.y, ComponentType.BYTE, ComponentFormat.RGBA);
    }

    @Override
    public Vec2 getFramebufferSize() {
        return getSize();
    }

    public IHostImage getImage() {
        return colorTexture.createHostImage();
    }

    @Override
    public void setFullscreen(IMonitor monitor) {
    }

    @Override
    public void setPointerMode(PointerMode mode) {
    }

    @Override
    public void setPointerPosition(float x, float y) {
    }

    @Override
    public void setWindowListener(IWindowListener windowListener) {
    }

    @Override
    public void setKeyListener(IKeyListener keyListener) {
    }

    @Override
    public void setPointerListener(IPointerListener pointerListener) {
    }

    @Override
    public void setPointerIcon(File file, int hotX, int hotY) {
    }
}

```


Overlapping Code:
```
blic class OffscreenView implements IView, IWindow {
private static final Log log = Log.create();
private boolean enabled = true;
private final Config config;
private final IController controller;
private final Viewport viewport;
private FrameBuffer frameBuffer;
private String title;
private IGPUImage colorTexture;
private Texture depthTexture;
private IContext context;
public OffscreenView(IController controller, int w, int h, Config config) {
this.config = config;
this.controller = controller;
this.viewport = new Viewport(0, 0, w, h);
setSize(new Vec2(w, h));
runOnSceneThread(t -> controlleread(IAction action) {
if (controller.isSceneThread())
action.run(controller.getScheduler().getTime());
else
controlic void dispose() {
frameBuffer = null;
}
@Override
public boolean isEnabled() {
return enabled;
}
@Override
public void setEnabled(boolean enabled) {
this.enabled = enabled;
}
@Override
public Config getConfig() {
return config;
}
@Override
public IController getController() {
return controller;
}
@Override
public Viewport getViewport() {
return viewport;
}
@Override
public IWindow getWindow() {
return this;
}
@Override
public boolean isDisposed() {
return frameBuffer == null;
}
class Context implements IContext {
private final IContext ctx;
public Context() {
ctx = GLContextManager.acquireCoext();
}
@Override
public void close() throws Exception {
GL11.glFinish();
FrameBuffer.unbind();
ntext acquireContext() {
context = new Context();
if (frameBuffer == null || viewport.w != colorTexture.getWidth() || viewport.h != colorTexture.getHeight()) {
if (frameBuffer == null)
frameBuffer = new FrameBuffer
```
<Overlap Ratio: 0.8530954879328436>

---

--- 94 --
Question ID: 2242cfb0f4039ef1dd1986bcfd3655b2f3ae6feb
Original Code:
```
public class MD {

    /**
     * @param obj the object to create the check sum
     * @return the numeric checksum for an object
     */
    public static BigInteger checksum(Object obj) {
        if (obj == null) {
            return BigInteger.ZERO;
        }
        Class<?> clz = obj.getClass();
        if (!(Serializable.class.isAssignableFrom(clz))) {
            String tostring = obj.toString();
            if (tostring.contains(clz.getName()) && tostring.contains("@")) {
                //use hash code
                return BigInteger.valueOf(obj.hashCode());
            } else {
                //try to use toString
                obj = tostring;
            }
        }
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos)) {
            oos.writeObject(obj);
            MessageDigest m = MessageDigest.getInstance("MD5");
            m.update(baos.toByteArray());
            return new BigInteger(1, m.digest());
        } catch (IOException e) {
            throw new RuntimeException("Unable to write to object output stream ERROR:" + e.getMessage(), e);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Unable to get message digest MD5 ERROR:" + e.getMessage());
        }
    }
}

```


Overlapping Code:
```
he check sum
* @return the numeric checksum for an object
*/
public static BigInteger checksum(Object 
}
try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(baos)) {
oos.writeObject(obj);
MessageDigest m = MessageDigest.getInstance("MD5");
m.update(baos.toByteArray());
return new BigInteger(1, m.digest());
} catch (IOException e) {
throw new RuntimeException("Unable to write to object output str:" + e.getMessage(), e);
} catch (NoSuchAlgorithmException e) {
throw new RuntimeException("Unable to get message digest MD5 ERROR:" + e.getMessage());
}
}
```
<Overlap Ratio: 0.5994123408423114>

---

--- 95 --
Question ID: 117f3d055e06497bc9bf38c477b32879ef1305eb
Original Code:
```
public class MultiAtlasTest {

    private static final Logger logger = LoggerFactory.getLogger(MultiAtlasTest.class);

    private final Atlas base = new PackedAtlasTest().getAtlas();

    private Atlas other;

    private MultiAtlas multi;

    @Test
    public void connectivityTest() {
        this.multi.forEach(atlasItem -> logger.trace(atlasItem.toString()));
        // Out edges of CC2: 987
        Assert.assertEquals(1, this.multi.edge(6).end().outEdges().size());
        Assert.assertEquals(987, this.multi.edge(6).end().outEdges().iterator().next().getIdentifier());
        Assert.assertEquals(2, this.multi.edge(-9).end().outEdges().size());
        Assert.assertEquals(2, this.multi.edge(-9).end().inEdges().size());
        Assert.assertEquals(2, this.multi.edge(987).start().inEdges().size());
    }

    public Atlas getAtlas() {
        if (this.multi == null) {
            setup();
        }
        return this.multi;
    }

    @Before
    public void setup() {
        final PackedAtlasBuilder builder = new PackedAtlasBuilder().withSizeEstimates(new AtlasSize(2, 3, 0, 0, 0, 1));
        final Map<String, String> edge5Tags = new HashMap<>();
        edge5Tags.put("highway", "primary");
        edge5Tags.put("name", "edge5");
        edge5Tags.put("surface", "concrete");
        edge5Tags.put("lanes", "3");
        final Map<String, String> edge6Tags = new HashMap<>();
        edge6Tags.put("highway", "secondary");
        edge6Tags.put("name", "edge98");
        edge6Tags.put("bridge", "cantilever");
        edge6Tags.put("maxspeed", "100");
        final Map<String, String> nodeTags = new HashMap<>();
        nodeTags.put("highway", "traffic_signal");
        // shared
        builder.addNode(123, Location.TEST_6, nodeTags);
        // shared
        builder.addNode(12345, Location.TEST_2, nodeTags);
        // private
        builder.addNode(4, Location.TEST_1, nodeTags);
        builder.addEdge(5, new Segment(Location.TEST_6, Location.TEST_1), edge5Tags);
        builder.addEdge(6, new Segment(Location.TEST_1, Location.TEST_2), edge6Tags);
        // This one is already in the base atlas
        final RelationBean structure1 = new RelationBean();
        // structure1.addItem(null, "out", ItemType.EDGE);
        structure1.addItem(4L, "notThere", ItemType.NODE);
        final RelationBean structure3 = new RelationBean();
        structure3.addItem(5L, "in", ItemType.EDGE);
        structure3.addItem(12345L, "node", ItemType.NODE);
        structure3.addItem(6L, "out", ItemType.EDGE);
        // Add relations
        builder.addRelation(1, 1, structure1, this.base.relation(1L).getTags());
        builder.addRelation(3, 2, structure3, this.base.relation(2L).getTags());
        this.other = builder.get();
        this.multi = new MultiAtlas(this.base, this.other);
    }

    @Test
    public void spatialIndexTest() {
        final Rectangle ac2Box = Location.TEST_1.boxAround(Distance.ONE_METER);
        Assert.assertEquals(1, Iterables.size(this.multi.nodesWithin(ac2Box)));
        Assert.assertEquals(4L, this.multi.nodesWithin(ac2Box).iterator().next().getIdentifier());
        Assert.assertEquals(2, Iterables.size(this.multi.edgesIntersecting(ac2Box)));
        final Iterator<Edge> edgeIterator = this.multi.edgesIntersecting(ac2Box).iterator();
        Assert.assertEquals(6, edgeIterator.next().getIdentifier());
        Assert.assertEquals(5, edgeIterator.next().getIdentifier());
        Assert.assertFalse(edgeIterator.hasNext());
    }

    @Test
    public void testSlicedRelation() {
        final Relation relation1 = this.multi.relation(1L);
        final RelationMemberList members = relation1.members();
        Assert.assertEquals(4, members.size());
        for (int i = 0; i < members.size(); i++) {
            Assert.assertTrue(members.get(i) != null);
        }
        // Members are ordered by entity type and ascending member identifier
        Assert.assertEquals(4, members.get(0).getEntity().getIdentifier());
        Assert.assertEquals(1234, members.get(1).getEntity().getIdentifier());
        Assert.assertEquals(-9, members.get(2).getEntity().getIdentifier());
        Assert.assertEquals(9, members.get(3).getEntity().getIdentifier());
        final Relation relation2 = this.multi.relation(2L);
        final RelationMemberList allMembers2 = relation2.allKnownOsmMembers();
        final Relation relation3 = this.multi.relation(3L);
        final RelationMemberList allMembers3 = relation3.allKnownOsmMembers();
        Assert.assertEquals(8, allMembers2.size());
        Assert.assertEquals(8, allMembers3.size());
    }

    @Test
    public void totalTest() {
        final Iterator<Edge> edges = this.multi.edges().iterator();
        int numberEdges = 0;
        for (; edges.hasNext(); ) {
            numberEdges++;
            edges.next();
        }
        Assert.assertEquals(6, numberEdges);
        // Assert.assertEquals(4, Iterables.size(this.multi.nodes()));
        Assert.assertEquals(6, Iterables.size(this.multi.edges()));
        Assert.assertEquals(4, Iterables.size(this.multi.nodes()));
        Assert.assertEquals(3, Iterables.size(this.multi.relations()));
    }
}

```


Overlapping Code:
```
sTest {
private static final Logger logger = LoggerFactory.getLogger(MultiAtlasTest.class);
private final Atlas base = new PackedAtlasTest().getAtlas();
private Atlas other;
private MultiAtla
this.multi.forEach(atlasItem -> logger.trace(atlasItem.toString()));
// Out edges of CC2: 987
Assert.assertEquals(1, this.multi.edge(6).end().outEdges()dge(6).end().outEdges().iterator().next().getIdentifier());
Assert.assertEquals(2, this.multi.edge(-9).end().outEdges().size());
Assert.assertEquals(2, this.multi.edge(-9).end().inEdges().size());
Assert.assertEquals(2, this.multi.edge(987).start().inEd
final PackedAtlasBuilder builder = new PackedAtlasBuilder().withSizeEstimates(new AtlasSize(2, 3, 0, 0, 0, 1));
final Map<String, String> edge5Tags = new HashMap<>();
edge5Tags.put("highway", "primary");
edge5Tags.put("name", "edge5");
edge5Tags.put("surface", "concrete");
edge5Tags.put("lanes", "3");
final Map<String, String> edge6Tags = new HashMap<>();
edge6Tags.put("highway", "secondary");
edge6Tags.put("name", "edge98");
edge6Tags.put("bridge", "cantilever");
edge6Tags.put("maxspeed", "100");
final Map<String, String> nodeTags = new HashMap<>();
nodeTags.put("highway", "traffic_signal");
// shared
builder.addNode(123, Location.TEST_6, nodeTags);
// shared
builder.addNode(12345, Location.TEST_2, nodeTags);
// private
builder.addNode(4, Location.TEST_1, nodeTags);
builder.addEdge(5, new Segment(Location.TEST_6, Location.TEST_1), edge5Tags);
builder.addEdge(6, new Segment(Location.TEST_1, Location.TEST_This one is already in the base atlas
final RelationBean structure1 = new RelationBean();
// structure1.addItem(null, "out", ItemType.EDGE);
structure1.addItem(4L, "notThere", ItemType.NODE);
final RelationBean structure3 = new RelationBean();
structure3.addItem(5L, "in", ItemType.EDGE);
structure
```
<Overlap Ratio: 0.8540489642184558>

---

--- 96 --
Question ID: aa0633d649b8023aede213d3d74bbd8b265feda2
Original Code:
```
public class Configuration {

    /* private constructor: static class */
    private Configuration() {
    }

    /**
     * Version number of the tool
     */
    public static final String VERSION = "1.0";

    /**
     * General short description text to be encapsulated
     */
    public static final String TOOL_DESCRIPTION = "The PeriCAT - PERICLES Content Aggregation Tool, version " + VERSION + ", was used to encapsulate these information.";

    /**
     * Directory for test data. This is for the unit tests.
     */
    public static final String TEST_DIRECTORY = "src" + File.separator + "test" + File.separator + "resources" + File.separator;

    /**
     * The directory where the projects directory will be created.
     */
    public static String WORKING_DIRECTORY = getCurrentJarFolder() + File.separator + "test_directory" + File.separator;

    /**
     * The result files of encapsulation processes will be stored here
     */
    public static String OUTPUT_DIRECTORY = WORKING_DIRECTORY + "output" + File.separator;

    /**
     * If encapsulated files are restored, they will be stored here
     */
    public static String RESTORED_DIRECTORY = WORKING_DIRECTORY + "restored" + File.separator;

    /**
     * Directory where the scenarios or roles are stored
     */
    public static String SCENARIO_DIRECTORY = WORKING_DIRECTORY + "scenarios" + File.separator;

    /**
     * Directory in which external libraries are stored
     */
    public static String LIBRARY_DIRECTORY = getCurrentJarFolder() + File.separator + "PeriCAT_libs" + File.separator;

    /**
     * Image icon, for add buttons
     */
    public static final Icon ADD_ICON = new ImageIcon(getImage("/images/add.png"));

    /**
     * Image icon for delete buttons
     */
    public static final Icon DELETE_ICON = new ImageIcon(getImage("/images/delete.png"));

    /**
     * Image icon for save buttons
     */
    public static final Icon SAVE_ICON = new ImageIcon(getImage("/images/disk.png"));

    /**
     * Image icon for buttons that start a process
     */
    public static final Icon START_ICON = new ImageIcon(getImage("/images/control_play_blue.png"));

    private static List<AbstractAlgorithm> algorithms = new ArrayList<AbstractAlgorithm>();

    /**
     * Configures the constants of the projects directories.
     */
    public static void createEncapsulationConstants() {
        WORKING_DIRECTORY = getCurrentJarFolder() + File.separator;
        if (OUTPUT_DIRECTORY == null || !new File(OUTPUT_DIRECTORY).isDirectory()) {
            OUTPUT_DIRECTORY = WORKING_DIRECTORY + "PeriCAT_output" + File.separator;
        }
        if (RESTORED_DIRECTORY == null || !new File(RESTORED_DIRECTORY).isDirectory()) {
            RESTORED_DIRECTORY = WORKING_DIRECTORY + "PeriCAT_restored" + File.separator;
        }
        SCENARIO_DIRECTORY = WORKING_DIRECTORY + "PeriCAT_scenarios" + File.separator;
        LIBRARY_DIRECTORY = WORKING_DIRECTORY + "PeriCAT_libs" + File.separator;
        createProjectDirectories();
    }

    /**
     * Load an image icon to be displayed on a button.
     *
     * @param path
     * @return image for a button
     */
    public static Image getImage(String path) {
        URL url = Configuration.class.getResource(path);
        if (url == null) {
            return null;
        }
        return Toolkit.getDefaultToolkit().getImage(url);
    }

    /**
     * Creates the project directories. To be called on tool start.
     */
    public static void createProjectDirectories() {
        try {
            FileUtils.forceMkdir(new File(OUTPUT_DIRECTORY));
            FileUtils.forceMkdir(new File(RESTORED_DIRECTORY));
            FileUtils.forceMkdir(new File(SCENARIO_DIRECTORY));
            FileUtils.forceMkdir(new File(LIBRARY_DIRECTORY));
        } catch (IOException e) {
        }
    }

    /**
     * Gets the location of the .jar, to figure out where to create the project
     * directory.
     *
     * @return File with path to jar directory
     */
    private static File getCurrentJarFolder() {
        try {
            File file = new File(Configuration.class.getProtectionDomain().getCodeSource().getLocation().toURI()).getParentFile();
            if (file.exists() && file.isDirectory()) {
                return file;
            }
        } catch (URISyntaxException e) {
            System.err.println("Exception while getting the locatio of the .jar. for the creation of the projects directory.");
        }
        return new File("./");
    }

    /**
     * Get the list of available algorithms
     *
     * Add here further algorithms, and comment out the "not yet finished"
     * algorithms.
     *
     * @return algorithms for information encapsulation
     */
    public static List<AbstractAlgorithm> getAlgorithms() {
        if (algorithms.size() == 0) {
            algorithms.add(new TextInformationFrame());
            algorithms.add(new OpenStegoRandomLSBSteganography());
            algorithms.add(new F5Steganography());
            algorithms.add(new BagItPackaging());
            algorithms.add(new PNGChunkAdding());
            algorithms.add(new JPEGTextAdding());
            algorithms.add(new PDFFileAttacher());
            algorithms.add(new ZipPackaging());
            algorithms.add(new TarPackaging());
            algorithms.add(new OaiOreSubmissionInformationPackage());
            algorithms.add(new MetsSubmissionInformationPackage());
            algorithms.add(new QRCodeWatermarking());
            algorithms.add(new ImageImageFrameExpanding());
            algorithms.add(new ImageInformationEmbeddingFrame());
        }
        return algorithms;
    }
}

```


Overlapping Code:
```
uration {
/* private constructor: static class */

*/
public static final String VERSION = "1.0";
/*IPTION = "The PeriCAT - PERICLES Content Aggregatiic final String TEST_DIRECTORY = "src" + File.separator + "test" + File.separator + "resources" + File.separator;tory where the projects directory will be created.g WORKING_DIRECTORY = getCurrentJarFolder() + File.separator + "test_directory" + File.separator;
/** The result files of encapsulation processes willECTORY = WORKING_DIRECTORY + "output" + File.separf encapsulated files are restored, they will be stored herRED_DIRECTORY = WORKING_DIRECTORY + "restored" + FO_DIRECTORY = WORKING_DIRECTORY + "scenarios" + FiIRECTORY = getCurrentJarFolder() + File.separator CON = new ImageIcon(getImage("/images/add.png"));
 final Icon DELETE_ICON = new ImageIcon(getImage("atic final Icon START_ICON = new ImageIcon(getImage("/images/control_play_blue.png"));
private static List<AbstractAlgorithm> algorithms = new ArrayList<AbstractAlgorithm>();
/**
* Configures the constants of the projects directories.
*/
public static void createEncapsulationConstants() {
WORKING_DIRECTORY = getCurrentJarFolder() + File.separator;

```
<Overlap Ratio: 0.5279531109107304>

---

--- 97 --
Question ID: 9070530deb7f6fef01876b2859a32446ef3c2a06
Original Code:
```
@NativeTag
@Execution(ExecutionMode.SAME_THREAD)
public class InfNanTests extends BaseNd4jTestWithBackends {

    @BeforeEach
    public void setUp() {
        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForINF(true).checkForNAN(true).build());
    }

    @AfterEach
    public void cleanUp() {
        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());
    }

    @ParameterizedTest
    @MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
    public void testInf1(Nd4jBackend backend) {
        assertThrows(ND4JIllegalStateException.class, () -> {
            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForNAN(true).checkForINF(true).build());
            INDArray x = Nd4j.create(100);
            x.putScalar(2, Float.NEGATIVE_INFINITY);
            OpExecutionerUtil.checkForAny(x);
        });
    }

    @ParameterizedTest
    @MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
    public void testInf2(Nd4jBackend backend) {
        assertThrows(ND4JIllegalStateException.class, () -> {
            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForNAN(true).checkForINF(true).build());
            INDArray x = Nd4j.create(100);
            x.putScalar(2, Float.NEGATIVE_INFINITY);
            OpExecutionerUtil.checkForAny(x);
        });
    }

    @ParameterizedTest
    @MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
    public void testInf3(Nd4jBackend backend) {
        INDArray x = Nd4j.create(100);
        OpExecutionerUtil.checkForAny(x);
    }

    @ParameterizedTest
    @MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
    public void testInf4(Nd4jBackend backend) {
        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());
        INDArray x = Nd4j.create(100);
        OpExecutionerUtil.checkForAny(x);
    }

    @ParameterizedTest
    @MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
    public void testNaN1(Nd4jBackend backend) {
        assertThrows(ND4JIllegalStateException.class, () -> {
            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForNAN(true).build());
            INDArray x = Nd4j.create(100);
            x.putScalar(2, Float.NaN);
            OpExecutionerUtil.checkForAny(x);
        });
    }

    @ParameterizedTest
    @MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
    public void testNaN2(Nd4jBackend backend) {
        assertThrows(ND4JIllegalStateException.class, () -> {
            Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForINF(true).checkForNAN(true).build());
            INDArray x = Nd4j.create(100);
            x.putScalar(2, Float.NaN);
            OpExecutionerUtil.checkForAny(x);
        });
    }

    @ParameterizedTest
    @MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
    public void testNaN3(Nd4jBackend backend) {
        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForINF(true).checkForNAN(true).build());
        INDArray x = Nd4j.create(100);
        OpExecutionerUtil.checkForAny(x);
    }

    @ParameterizedTest
    @MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
    public void testNaN4(Nd4jBackend backend) {
        Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());
        INDArray x = Nd4j.create(100);
        OpExecutionerUtil.checkForAny(x);
    }

    @Override
    public char ordering() {
        return 'c';
    }
}

```


Overlapping Code:
```
eTag
@Execution(ExecutionMode.SAME_THREAD)
public class InfNanTests extends BaseNd4jTestWithBackends {
@BeforeEach
public void setUp() {
Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder()lic void cleanUp() {
Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());
}
@ParameterizedTest
@MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
public void testInf1(Nd4jBackend backend) {
assertThrows(ND4JIllegalStateException.clas{
Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForNAN(true).build());
INDArray x = Nd4j.create(100);
x.putScalar(2, Float.NEGATIVE_INFINITY);
OpExecutionerUtil.checkForAny(x);
});
}
@ParameterizedTest
@MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
public void testInf2(Nd4jBackend backend) {
assertThrows(ND4JIllegalStateException.clas{
Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForNAN(true).build());
INDArray x = Nd4j.create(100);
x.putScalar(2, Float.NEGATIVE_INFINITY);
OpExecutionerUtil.checkForAny(x);
});
}
@ParameterizedTest
@MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
public void testInf3(Nd4jBackend backend) {
INDArray x = Nd4j.create(100);
OpExecutionerUtil.checkForAny(x);
}
@ParameterizedTest
@MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
public void testInf4(Nd4jBackend backend) {
Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().build());
INDArray x = Nd4j.create(100);
OpExecutionerUtil.checkForAny(x);
}
@ParameterizedTest
@MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
public void testNaN1(Nd4jBackend backend) {
assertThrows(ND4JIllegalStateException.clas{
Nd4j.getExecutioner().setProfilingConfig(ProfilerConfig.builder().checkForNAN(true).build());
INDArray x = Nd4j.create(100);
x.putScalar(2, Float.NaN);
OpExecutionerUtil.checkForAny(x);
});
}
@ParameterizedTest
@MethodSource("org.nd4j.linalg.BaseNd4jTestWithBackends#configs")
public void tes
```
<Overlap Ratio: 0.9379407616361072>

---

--- 98 --
Question ID: 9ef0a07c6c93211f564dd0ee9ac62d005881284a
Original Code:
```
public class AuthorizationProviderOidc implements AuthorizationProvider, AuthenticationProvider {

    private static final Logger LOGGER = LoggerFactory.getLogger(AuthorizationProviderOidc.class.getName());

    final static String HTTP_HEADER_NAME = "Authorization";

    final static String HTTP_HEADER_VALUE_PREFIX = "Bearer ";

    final static String OIDC = "oidc";

    public ServiceConfiguration conf;

    public ConfigurationCacheService configCache;

    private PulsarAuthorizationProvider defaultProvider;

    private OidcTenantConfig oidcConfig;

    public AuthorizationProviderOidc() {
    }

    public AuthorizationProviderOidc(ServiceConfiguration conf, ConfigurationCacheService configCache) throws IOException {
        initialize(conf, configCache);
    }

    @Override
    public void initialize(ServiceConfiguration conf, ConfigurationCacheService configCache) throws IOException {
        this.conf = conf;
        this.configCache = configCache;
        defaultProvider = new PulsarAuthorizationProvider(conf, configCache);
        this.oidcConfig = new OidcConfig(conf);
    }

    @Override
    public CompletableFuture<Boolean> canProduceAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {
        if (!role.startsWith("jwt:")) {
            return defaultProvider.canProduceAsync(topicName, role, authenticationData);
        }
        // TODO
        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();
        permissionFuture.complete(true);
        return permissionFuture;
    }

    @Override
    public CompletableFuture<Boolean> canConsumeAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData, String subscription) {
        if (!role.startsWith("jwt:")) {
            return defaultProvider.canConsumeAsync(topicName, role, authenticationData, subscription);
        }
        // TODO
        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();
        permissionFuture.complete(true);
        return permissionFuture;
    }

    @Override
    public CompletableFuture<Boolean> canLookupAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {
        if (!role.startsWith("jwt:")) {
            return defaultProvider.canLookupAsync(topicName, role, authenticationData);
        }
        // TODO
        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();
        permissionFuture.complete(true);
        return permissionFuture;
    }

    @Override
    public CompletableFuture<Boolean> allowFunctionOpsAsync(NamespaceName namespaceName, String role, AuthenticationDataSource authenticationData) {
        if (!role.startsWith("jwt:")) {
            return defaultProvider.allowFunctionOpsAsync(namespaceName, role, authenticationData);
        }
        // TODO
        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();
        permissionFuture.complete(true);
        return permissionFuture;
    }

    @Override
    public CompletableFuture<Boolean> isSuperUser(String role, ServiceConfiguration serviceConfiguration) {
        if (!role.startsWith("jwt:")) {
            return defaultProvider.isSuperUser(role, serviceConfiguration);
        }
        // TODO
        CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();
        permissionFuture.complete(true);
        return permissionFuture;
    }

    @Override
    public CompletableFuture<Void> grantPermissionAsync(NamespaceName namespace, Set<AuthAction> actions, String role, String authDataJson) {
        return defaultProvider.grantPermissionAsync(namespace, actions, role, authDataJson);
    }

    @Override
    public CompletableFuture<Void> grantSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, Set<String> roles, String authDataJson) {
        return defaultProvider.grantSubscriptionPermissionAsync(namespace, subscriptionName, roles, authDataJson);
    }

    @Override
    public CompletableFuture<Void> revokeSubscriptionPermissionAsync(NamespaceName namespace, String subscriptionName, String role, String authDataJson) {
        return defaultProvider.revokeSubscriptionPermissionAsync(namespace, subscriptionName, role, authDataJson);
    }

    @Override
    public CompletableFuture<Void> grantPermissionAsync(TopicName topicName, Set<AuthAction> actions, String role, String authDataJson) {
        return defaultProvider.grantPermissionAsync(topicName, actions, role, authDataJson);
    }

    @Override
    public void close() throws IOException {
    }

    @Override
    public void initialize(ServiceConfiguration config) throws IOException {
        this.oidcConfig = new OidcConfig(config);
    }

    @Override
    public String getAuthMethodName() {
        return OIDC;
    }

    @Override
    public String authenticate(AuthenticationDataSource authData) throws AuthenticationException {
        String biscuit = getJwt(authData);
        return parseBiscuit(biscuit);
    }

    private static String validateJwt(final String jwt) throws AuthenticationException {
        // Key check
        if (StringUtils.isNotBlank(jwt)) {
            return jwt;
        } else {
            throw new AuthenticationException("Blank biscuit found");
        }
    }

    public static String getJwt(AuthenticationDataSource authData) throws AuthenticationException {
        if (authData.hasDataFromCommand()) {
            // Authenticate Pulsar binary connection
            return authData.getCommandData();
        } else if (authData.hasDataFromHttp()) {
            // (https://tools.ietf.org/html/rfc6750#section-2.1). Eg: Authorization: Bearer xxxxxxxxxxxxx
            String httpHeaderValue = authData.getHttpHeader(HTTP_HEADER_NAME);
            if (httpHeaderValue == null || !httpHeaderValue.startsWith(HTTP_HEADER_VALUE_PREFIX)) {
                throw new AuthenticationException("Invalid HTTP Authorization header");
            }
            // Remove prefix
            String jwt = httpHeaderValue.substring(HTTP_HEADER_VALUE_PREFIX.length());
            return validateJwt(jwt);
        } else {
            throw new AuthenticationException("No JWT credentials passed");
        }
    }

    private String parseBiscuit(final String jwt) throws AuthenticationException {
        LOGGER.info("Jwt to parse: {}", jwt);
        // TODO
        return "";
    }
}

```


Overlapping Code:
```
ments AuthorizationProvider, AuthenticationProvider {
private static final Logger LOGGER = LoggerFactory.getLogger(AuthorizationProviderOidc.class.getName());
final static String HTTP_HEADER_NAME = "Authorization";
final static String HTTP_HEADER_VALUE_PREFIX = "Bearer ";
final static String OIDC = "oidc";
public ServiceConfiguration conf;
public ConfigurationCacheService configCache;
private PulsarAuthorizationProvider defaultProvider;
private OidcTenantConfig oidcConfig;
public AuthorizationPrServiceConfiguration conf, ConfigurationCacheService configCache) throws IOException {
initialize(conf, configCache);
}
@Override
public void initialize(ServiceConfiguration conf, ConfigurationCacheService configCache) throws IOException {
this.conf = conf;
this.configCache = configCache;
defaultProvider = new PulsarAuthorizationProvider(conf, configCache);
this.oidcConfig = new OidcConfig(conf);
}
@Override
public CompletableFuture<Boolean> canProduceAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {
if (!role.startsWith("jwt:")) {
return defaultProvider.canProduceAsync(topicName, role, authenticationData);
}
// TODO
CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();
permissionFuture.complete(true);
return permissionFuture;
}
@Override
public CompletableFuture<Boolean> canConsumeAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData, String subscription) {
if (!role.startsWith("jwt:")) {
return defaultProvider.canConsumeAsync(topicName, role, authenticationData, subscription);
}
// TODO
CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();
permissionFuture.complete(true);
return permissionFuture;
}
@Override
public CompletableFuture<Boolean> canLookupAsync(TopicName topicName, String role, AuthenticationDataSource authenticationData) {
if (!role.startsWith("jwt:")) {
return defaultProvider.canLookupAsync(topicName, role, authenticationData);
}
// TODO
CompletableFuture<Boolean> permissionFuture = new CompletableFuture<>();
permissionFuture.complete(true
```
<Overlap Ratio: 0.9559633027522936>

---

--- 99 --
Question ID: e0aa48a7e2cf1b6234970b1b127112d88e948138
Original Code:
```
public class PrivateMessage extends Chat {

    private static Pattern privateMessageRegex = Pattern.compile("\\[([A-Za-z\\-\\+]+) \\u2503 (~?\\!?\\w{1,16}) -> mir\\] (.*)$");

    private static Pattern privateMessageSentRegex = Pattern.compile("\\[mir -> ([A-Za-z\\-\\+]+) \\u2503 (~?\\!?\\w{1,16})\\] (.*)$");

    private long lastAfkMessage = 0;

    @Override
    public String getName() {
        return "privateMessage";
    }

    public boolean doAction(String unformatted) {
        if (unformatted.trim().length() > 0) {
            Matcher privateMessage = privateMessageRegex.matcher(unformatted);
            Matcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);
            return privateMessage.find() || privateMessageSent.find();
        }
        return false;
    }

    @Override
    public boolean doActionHandleChatMessage(String unformatted, String formatted) {
        return getSettings().isPrivateChatRight() && doAction(unformatted);
    }

    @Override
    public boolean doActionModifyChatMessage(IChatComponent msg) {
        String unformatted = msg.getUnformattedText();
        return doAction(unformatted);
    }

    @Override
    public ChatDisplayAction handleChatMessage(String unformatted, String formatted) {
        return ChatDisplayAction.SWAP;
    }

    @Override
    public IChatComponent modifyChatMessage(IChatComponent msg) {
        String unformatted = msg.getUnformattedText();
        Matcher privateMessage = privateMessageRegex.matcher(unformatted);
        Matcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);
        String suggestMsgHoverTxt = LanguageManager.translateOrReturnKey("message_gg_suggestMsgHoverMsg");
        IChatComponent hoverText = new ChatComponentText(ModColor.cl("a") + suggestMsgHoverTxt);
        if (privateMessage.find()) {
            String playerName = privateMessage.group(2);
            if (playerName.startsWith("~"))
                playerName = playerName.replaceFirst("~", "");
            if (getSettings().isPrivateChatSound()) {
                LabyModCore.getMinecraft().playSound(new ResourceLocation(getHelper().getSoundPath(getSettings().getPrivateChatSound())), 1.0F);
            }
            if (getSettings().isMsgDisplayNameClick()) {
                String username = "/msg " + playerName + " ";
                int siblingCnt = 0;
                int nameStart = 0;
                int nameEnd = 0;
                for (IChatComponent msgs : msg.getSiblings()) {
                    if (nameStart == 0 && msgs.getFormattedText().contains("?6[?r")) {
                        nameStart = siblingCnt + 1;
                    }
                    if (nameEnd == 0 && msgs.getFormattedText().equals("?6 -> ?r")) {
                        nameEnd = siblingCnt - 1;
                    }
                    siblingCnt++;
                }
                int i = nameStart;
                while (i <= nameEnd) try {
                    msg.getSiblings().get(i).getChatStyle().setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username)).setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));
                } finally {
                    i++;
                }
            }
            if (getSettings().isAfkMsgAnswer() && getGG().isAfk() && lastAfkMessage + 1000 <= System.currentTimeMillis()) {
                String message = getSettings().getAfkMsgText();
                if (message.length() > 0) {
                    if (message.startsWith("~"))
                        message = message.replaceFirst("~", "");
                    Minecraft.getMinecraft().thePlayer.sendChatMessage("/msg " + playerName + " " + message);
                    lastAfkMessage = System.currentTimeMillis();
                }
            }
        }
        if (privateMessageSent.find() && getSettings().isMsgDisplayNameClick()) {
            String playerName = privateMessageSent.group(2);
            if (playerName.startsWith("~"))
                playerName = playerName.replaceFirst("~", "");
            String username = "/msg " + playerName + " ";
            int siblingCnt = 0;
            int nameStart = 0;
            int nameEnd = 0;
            for (IChatComponent msgs : msg.getSiblings()) {
                if (nameStart == 0 && msgs.getFormattedText().equals("?6 -> ?r")) {
                    nameStart = siblingCnt + 1;
                }
                if (nameEnd == 0 && msgs.getFormattedText().equals("?6] ?r")) {
                    nameEnd = siblingCnt - 1;
                }
                siblingCnt++;
            }
            int i = nameStart;
            while (i <= nameEnd) try {
                msg.getSiblings().get(i).getChatStyle().setChatClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, username)).setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText));
            } finally {
                i++;
            }
        }
        return msg;
    }
}

```


Overlapping Code:
```
lic class PrivateMessage extends Chat {
private static Pattern privateMessageRegex = Pattern.compile("\\[([A-Za-z\\-\\+]+) \\u2503 (~?\\!?\\w{1,16}) -> mir\\] (.*)$");
private static Pattern privateMessageSentRegex = Pattern.compile("\\[mir -> ([A-Za-z\\-\\+]+) \\u2503 (~?\\!?\\w{1,16})\\] (.*)$");
private long lastAfkMessage = 0;
@Override
public String getName() {
return "privateMessage";
}
publring unformatted) {
if (unformatted.trim().length() > 0) {
Matcher privateMessage = privateMessageRegex.matcher(unformatted);
Matcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);
return privateMessage.find() || privateMessageSent.find();
}
return false;
}
@Override
public boolean doActionHandleChatMessage(String unformatted, String formatted) {
return getSettings().isPrivateChatRight() && doAction(unformatted);
}
@Override
public boolean doActionModifyChatMessage(IChatComponent msg) {
String unformatted = msg.getUnformattedText();
return doAction(unformatted);
}
@Override
public ChatDisplayAction handleChatMessage(String unformatted, String formatted) {
return ChatDisplayAction.SWAP;
}
@Override
public IChatComponent modifyChatMessage(IChatComponent msg) {
String unformatted = msg.getUnformattedText();
Matcher privateMessage = privateMessageRegex.matcher(unformatted);
Matcher privateMessageSent = privateMessageSentRegex.matcher(unformatted);
SuggestMsgHoverTxt = LanguageManager.translateOrReturnKey("message_gg_suggestMsgHoverMsg");
IChatComponent hoverText = new ChatComponentText(ModColor.cl("a") + suggestMsgHoverTxt);
if (privateMessage.find()) {
String playerName = privateMessageme = playerName.replaceFirst("~", "");
if (getSettings().isPrivateChatSound()) {
LabyModCore.getMinecraft().playSound(new ResourceLocation(getHelper().getSoundPath(getSettings().getPrivateChatSound())), 1.0F);
}
if (getSettings().isMsgDisplayNameClick()) {
String username = "/msg " + playerName + " ";
int siblingCnt = 0;
int nameStart = 0;
int nameEnd
```
<Overlap Ratio: 0.943170964660936>

---

--- 100 --
Question ID: fbcf75319c426de85274374bae423ac2f8e3f1f1
Original Code:
```
@Controller
public class SaleController {

    @Autowired
    SaleService service;

    @RequestMapping(value = "/sales")
    public String getAllSales(Model model) {
        List<Sale> list = service.getAllSales();
        model.addAttribute("sales", list);
        return "sale-list";
    }
}

```


Overlapping Code:
```
er
public class SaleController {
@Autowired
SaleService service;
@RequestMapping(value = "/sales")
public String getAllSales(Model model) {
List<Sale> list = service.getAllSales();
model.addAttribute("sales", 
```
<Overlap Ratio: 0.842741935483871>

---

--- 101 --
Question ID: f72f58de555633dae38ae5ca07680378374dc88b
Original Code:
```
public class StickyKey {

    public static final StickyKey DEFAULT = new StickyKey(0, 0);

    public final long clusterId;

    public final long stickyId;

    private StickyKey(final long clusterId, final long stickyId) {
        this.clusterId = (clusterId <= 0 ? 0 : clusterId);
        this.stickyId = (stickyId <= 0 ? 0 : stickyId);
    }

    public static StickyKey valueOf(final String clusterName, final String stickyName) {
        final long clusterId = (clusterName == null ? 0 : IOHelper.longIdFromString(clusterName));
        final long stickyId = IOHelper.longIdFromString(stickyName);
        if (clusterName != null) {
            Log.info(StickyKey.class.getSimpleName(), "Mapped clusterName=" + clusterName + " clusterId=" + clusterId);
        }
        if (stickyName != null) {
            Log.info(StickyKey.class.getSimpleName(), "Mapped stickyName=" + stickyName + " stickyId=" + stickyId);
        }
        return valueOf(clusterId, stickyId);
    }

    public static StickyKey valueOf(final long clusterId, final long stickyId) {
        return new StickyKey(clusterId, stickyId);
    }

    @Override
    public boolean equals(final Object obj) {
        if (obj instanceof StickyKey) {
            final StickyKey o = (StickyKey) obj;
            return ((this.clusterId == o.clusterId) && (this.stickyId == o.stickyId));
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (this.clusterId ^ (this.clusterId >>> 32) ^ this.stickyId ^ (this.stickyId >>> 32));
    }

    @Override
    public String toString() {
        return super.toString() + "[clusterId=" + clusterId + " stickyId=" + stickyId + "]";
    }
}

```


Overlapping Code:
```
Key {
public static final StickyKey DEFAULT = new StickyKey(0, 0);
public final long clusterId;
public final long stickyId;
private StickyKey(final long clusterId, final long stickyId) {
this.clusterId = (clusterId <= 0 ? 0 : clusterId);
this.stickyId = (stickyId <= 0 ? 0 : stickyId);
}
public static StickyKey valueOf(final String clusterName, final String stickyName) {
final long clusterId = (clusterName == null ? 0 : IOHelper.longIdFromString(clusterName));
final long stickyId = IOHelper.longIdFromString(stickyName);
if (clusterName != null) {
Log.info(StickyKey.class.getSimpleName(), "Mapped clusterName=" + clusterName + " clusterId=" + clusterId);
}
if (stickyName != null) {
Log.info(StickyKey.class.getSimpleName(), "Mapped stickyName=" + stickyName + " stickyId=" + stickyId);
}
return valueOf(clusterId, stickyId);
}
public static StickyKey valueOf(final long clusterId, final long stickyId) {
return new StickyKey(clusterId, stickyId);
}
@Override
public boolean equals(final Object obj) {
if (obj instanceof StickyKey) {
final StickyKey o = (StickyKey) obj;
return ((this.clusterId == o.clusterId) && (this.stickyId == o.stickyId));
}
return false;
}
@Override
public int hashCode() {
return (int) (this.clusterId ^ (this.clusterId >>> 32) ^ this.stickyId ^ (this.stickyId >>> 32));
}
@Override
public String toString() {
return super.toString() + "[clusterId=" + clusterId + " stic
```
<Overlap Ratio: 0.967519004837595>

---

--- 102 --
Question ID: 9911321d53109bf16da1df0c35f7787910b99c99
Original Code:
```
@RunWith(SpringRunner.class)
@DataJpaTest
@ComponentScan({ "com.song7749.incident.drs" })
public class LogRepositoryTest {

    Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    LogRepository logRepository;

    @Test
    public void testSaveLogLogin() {
        // give
        LogLogin ll = new LogLogin();
        ll.setIp("111.111.111.111");
        ll.setLoginId("song7749");
        ll.setCipher("12314142341231");
        // when
        logRepository.saveAndFlush(ll);
        // then
        assertThat(ll.getId(), notNullValue());
    }

    @Test
    public void testSaveLogQuery() {
        //give
        LogQuery lq = new LogQuery();
        lq.setIp("111.111.111.111");
        lq.setDatabaseId(1L);
        lq.setAccount("song7749");
        lq.setHost("11.11.11.11");
        lq.setHostAlias("??? ??");
        lq.setLoginId("song7749");
        lq.setQuery("select * from dual");
        lq.setSchemaName("song7749");
        //when
        logRepository.saveAndFlush(lq);
        //then
        assertThat(lq.getId(), notNullValue());
    }
}

```


Overlapping Code:
```
@RunWith(SpringRunner.class)
@DataJpaTest
@ComponentsitoryTest {
Logger logger = LoggerFactory.getLogger(getClass());
@Autowired
LogRepository logRepository;
@Test
public void testSaveLogLogin() {
// give
LogLogin ll = new LogLogin();
ll.setIp("111.111.111.111");
ll.setLog7749");
ll.setCipher("12314142341231");
// when
logRepository.saveAndFlush(ll);
// then
assertThat(ll.getId(), notNullValue());
}
@Test
public void testSaveLogQuery() {
//give
LogQuery lq = new LogQue(1L);
lq.setAccount("song7749");
lq.setHost("11.11("song7749");
lq.setQuery("select * from dual");
lq.setSchemaName("song7749");
//when
logRepository.saveAndFlush(lq);
//then
assertThat(lq.getId(), no
```
<Overlap Ratio: 0.7825581395348837>

---

--- 103 --
Question ID: 03d7a5ce83aba3ab84bada38250092fab43c06b1
Original Code:
```
public class RandomTest {

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        int i = 0;
        while (i < 1000000) try {
            int intv = new Double(Math.random() * 10000).intValue();
            long longv = new Double(Math.random() * 1000000).longValue();
            double doublev = Math.random() * 100;
        } finally {
            i++;
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);
        long start1 = System.currentTimeMillis();
        int i = 0;
        while (i < 10000) try {
            int intv = ThreadLocalRandom.current().nextInt(10000);
            long longv = ThreadLocalRandom.current().nextLong(1000000);
            double doublev = ThreadLocalRandom.current().nextDouble(500);
        } finally {
            i++;
        }
        long end1 = System.currentTimeMillis();
        System.out.println(end1 - start1);
    }
}

```


Overlapping Code:
```
public class RandomTest {
public static void main(String[] args) {
long start = System.currentTimeMillis();
int i = 0;
while (i10000).intValue();
long longv = new Double(Math.random() * 1000000).longValue();
double doublev = Mai++;
}
long end = System.currentTimeMillis();
System.out.println(end - start);
long start1 = System.currentTimeMillis();
int i = 0;
while (ient().nextInt(10000);
long longv = ThreadLocalRandom.current().nextLong(1000000);
double doublev = T;
}
long end1 = System.currentTimeMillis();
System.out.println(end1 - start1)
```
<Overlap Ratio: 0.7311827956989247>

---

--- 104 --
Question ID: 05ef2f68dbf7ba92065c8486bd0b45aff254557c
Original Code:
```
public class OrganisationTransformer {

    public static List<Organization> transform(List<OpenHR001Organisation> sources) throws TransformException {
        ArrayList<Organization> organizations = new ArrayList<>();
        for (OpenHR001Organisation source : sources) organizations.add(transform(source));
        return organizations;
    }

    public static Organization transform(OpenHR001Organisation source) throws TransformException {
        OpenHRHelper.ensureDboNotDelete(source);
        Organization target = new Organization();
        target.setId(source.getId());
        target.setMeta(new Meta().addProfile(FhirProfileUri.PROFILE_URI_ORGANIZATION));
        if (StringUtils.isNotBlank(source.getNationalPracticeCode()))
            target.addIdentifier(new Identifier().setSystem(FhirIdentifierUri.IDENTIFIER_SYSTEM_ODS_CODE).setValue(source.getNationalPracticeCode()));
        target.setActive(source.getCloseDate() == null);
        if ((source.getOpenDate() != null) || (source.getCloseDate() != null)) {
            Period period = new Period();
            if (source.getOpenDate() != null)
                period.setStart(DateConverter.toDate(source.getOpenDate()));
            if (source.getCloseDate() != null)
                period.setEnd(DateConverter.toDate(source.getCloseDate()));
            target.getActiveElement().addExtension(new Extension().setUrl(FhirExtensionUri.ACTIVE_PERIOD).setValue(period));
        }
        target.setName(source.getName());
        target.setType(new CodeableConcept().setText(source.getOrganisationType().getDisplayName()));
        if (!StringUtils.isBlank(source.getParentOrganisation()))
            target.setPartOf(ReferenceHelper.createReference(ResourceType.Organization, source.getParentOrganisation()));
        if (!StringUtils.isBlank(source.getMainLocation()))
            target.addExtension(new Extension().setUrl(FhirExtensionUri.ORGANISATION_MAIN_LOCATION).setValue(ReferenceHelper.createReference(ResourceType.Location, source.getMainLocation())));
        return target;
    }
}

```


Overlapping Code:
```
m(List<OpenHR001Organisation> sources) throws TranrrayList<Organization> organizations = new ArrayList<>();
for (OpenHR001Organisatiurce));
return organizations;
}
public static Organization transform(OpenHR001Organisation source) totDelete(source);
Organization target = new Organization();
target.setId(source.getId());
target.setMeta(new Meta().addProfile(FhirProfileUri.PROFILE_URI_ORGANIZATION));
if (StringUtils.isNotBlank(source.getNationalPracticeCode()))
target.addIdentifier(new Identifier().setSystem(FhirIdentifierUri.IDENTIFIER_SYSTEM_ODS_CODE).setValue(source.getNationalPracticeCode()));
target.setActive(source.getCloseDate() == null);
if ((source.getOpenDate() != null) || (source.getCloseDate() != nulperiod = new Period();
if (source.getOpenDate() != null)
period.setStart(DateConverter.toDate(source.getOpenDate()));
if (source.getCloseDate() != null)
period.setEnd(DateConverter.toDate(source.getCloseDate()));
target.getActiveElement().addExtension(new Extension().setUrl(FhirExtensionUri.ACTIVE_PERIOD).setValue(period));
}
target.setName(source.getName());
target.setType(new CodeableConcept().setText(source.getOrganisationType().getDisplayName()));
if (!StringUtils.isBlank(source.getParentOrganisation()))
target.setPartOf(ReferenceHelper.createReference(ResourceType.Organization, source.getParentOrganisation()));
if (!StringUtils.isBlank(source.getMainLocation()))
target.addExtension(new Extension().setUrl(FhirExtensionUri.ORGANISATION_MAIN_LOCATION).setValue(ReferenceHelper.createReference(ResourceType.Location, source.getMainLocation
```
<Overlap Ratio: 0.8687707641196013>

---

--- 105 --
Question ID: 29468b6a959b45f1ec1410e8277b26109e673596
Original Code:
```
public final class SHA1Util {

    private static final ThreadLocal<MessageDigest> SHA1 = ThreadLocal.withInitial(() -> {
        try {
            return MessageDigest.getInstance("SHA1");
        } catch (NoSuchAlgorithmException e) {
            throw new InternalError("SHA-1 not supported on this platform - Outdated?");
        }
    });

    /**
     * Performs a SHA-1 hash on the specified data
     *
     * @param data The data to hash
     * @return The hashed data
     */
    private static byte[] sha1(byte[] data) {
        MessageDigest digest = SHA1.get();
        digest.reset();
        return digest.digest(data);
    }

    public static String sha1(File file) throws IOException {
        return SecretUtil.byteArrayToHexString(Files.readAllBytes(file.toPath()));
    }

    public static String sha1(String source) {
        return sha1(source, StandardCharsets.UTF_8);
    }

    public static String sha1(String source, Charset charset) {
        byte[] bytes = source.getBytes(charset);
        return SecretUtil.byteArrayToHexString(sha1(bytes));
    }
}

```


Overlapping Code:
```
al class SHA1Util {
private static final ThreadLocal<MessageDigest> SHA1 = ThreadLocal.withInitial(() -> {
try {
return MessageDigest.getInstance("SHA1");
} catch (NoSuchAlgorithmException e) {
throw new InternalError("SHA-1 not supported on this platform - Outdated?");
}
});
/**
* Performs a SHA-1 hash on the specified data
*
* @param data The data to hash
* @return The hashed data
*/
private static byte[] sha1(byte[] data) {
MessageDigest digest = SHA1.get();
digest.reset();
return digest.digest(data);
}
public static String sha1(File file) throws IOException {
return SecretUtil.byteArrayToHexString(Files.readAllBytes(file.toPath()));
}
public static String sha1(String source) {
return sha1(source, StandardCharsets.UTF_8);
}
public static String sha1(String source, Charset charset) {
byte[] bytes = source.getBytes(charset);
return Secre
```
<Overlap Ratio: 0.9402654867256637>

---

--- 106 --
Question ID: f62399e89a1c3106290095c2b907f8016f2f0999
Original Code:
```
public class SimilarRatingGraph {

    public double maxLength(int[] date, int[] rating) {
        int n = date.length;
        double ans = 0;
        int[] ps = new int[n - 1];
        int[] qs = new int[n - 1];
        double[] hypot = new double[n - 1];
        int i = 0;
        while (i + 1 < n) try {
            ps[i] = date[i + 1] - date[i];
            qs[i] = rating[i + 1] - rating[i];
            hypot[i] = Math.hypot(ps[i], qs[i]);
        } finally {
            i++;
        }
        int i = 0;
        while (i < n) try {
            int j = i + 1;
            while (j < n) try {
                long p01 = 0, p02 = 0;
                double cur = 0;
                int k = 0;
                while (true) try {
                    if (i + k + 1 == n || j + k + 1 == n) {
                        break;
                    }
                    long p1 = ps[i + k];
                    long q1 = qs[i + k];
                    long p2 = ps[j + k];
                    long q2 = qs[j + k];
                    if (p1 * q2 != p2 * q1) {
                        break;
                    }
                    if (k == 0) {
                        p01 = p1;
                        p02 = p2;
                    } else {
                        if (p1 * p02 != p2 * p01) {
                            break;
                        }
                    }
                    if (p1 > p2) {
                        cur += hypot[i + k];
                    } else {
                        cur += hypot[j + k];
                    }
                    ans = Math.max(ans, cur);
                } finally {
                    k++;
                }
            } finally {
                j++;
            }
        } finally {
            i++;
        }
        return ans;
    }
}

```


Overlapping Code:
```
gGraph {
public double maxLength(int[] date, int[] rating) {
int n = date.length;
double ans = 0;
int[] ps = new int[n - 1];
int[] qs = new int[n - 1]];
qs[i] = rating[i + 1] - rating[i];
hypot[i] = M
}
long p1 = ps[i + k];
long q1 = qs[i + k];
long p2 = ps[j + k];
long q2 = qs[j + k];
if (p1 * q2 != p2 * q1) {
break;
}
if (k == 0) {
p01 = p1;
p02 = p2;
} else {
if (p1 * p02 != p2 * p01) {
break;
}
}
if (p1 > p2) {
cur += hypot[i + k];
} else {
c
```
<Overlap Ratio: 0.48859934853420195>

---

--- 107 --
Question ID: f93ae094e9bce6ccecad58faf15cf654916b969b
Original Code:
```
public class ProjectSaver {

    public static void save(ProjectDef projectDef, String rootDirectory) throws IOException {
        if (projectDef.getFileName() == null)
            throw new IllegalArgumentException("Built-in projects cannot be exported.");
        final Path directory = Paths.get(rootDirectory);
        if (!Files.exists(directory))
            throw new IllegalArgumentException("Directory does not exist.");
        saveProjectFile(projectDef, directory);
        for (NamespaceDef namespaceDef : projectDef.getNamespaces().values()) saveNamespace(namespaceDef, directory);
    }

    private static void saveProjectFile(ProjectDef projectDef, Path directory) throws IOException {
        final ProjectFile projectFile = new ProjectFile();
        projectFile.References = projectDef.getReferences().keySet().toArray(new String[0]);
        projectFile.Sources = new ProjectSource[] { new ProjectSource() };
        final Gson gson = new GsonBuilder().setPrettyPrinting().create();
        try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(directory.resolve(projectDef.getFileName()).toFile()))) {
            gson.toJson(projectFile, writer);
        }
    }

    private static void saveNamespace(NamespaceDef namespaceDef, Path directory) throws IOException {
        Path currentDirectory = directory;
        for (String component : namespaceDef.getNamespace().split("\\.")) {
            currentDirectory = currentDirectory.resolve(component);
            Files.createDirectories(currentDirectory);
        }
        for (FileDef fileDef : namespaceDef.getFiles().values()) {
            final CodeWriter writer = new CodeWriter(4);
            writer.writeLine(String.format("namespace %s;", namespaceDef.getNamespace()));
            if (fileDef.getImports().size() > 0) {
                writer.newLine();
                for (ImportDef importDef : fileDef.getImports()) {
                    switch(importDef.getKind()) {
                        case NAMESPACE:
                            writer.writeLine(String.format("import %s.*;", ((ImportNamespaceDef) importDef).getTarget().getNamespace()));
                            break;
                        case TYPE:
                            ImportTypeDef importTypeDef = (ImportTypeDef) importDef;
                            writer.writeLine(importTypeDef.getAlias() == null ? String.format("import %s.%s;", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName()) : String.format("import %s.%s as %s;", importTypeDef.getTarget().getNamespace().getNamespace(), importTypeDef.getTarget().getName(), importTypeDef.getAlias()));
                            break;
                        default:
                            throw new IllegalArgumentException("Type of import directive is unknown: " + importDef.getKind());
                    }
                }
            }
            if (fileDef.getOptions().size() > 0) {
                writer.newLine();
                for (NameValuePair option : fileDef.getOptions()) writer.writeLine(String.format("option %s = %s;", option.getName(), option.getValue().toString()));
            }
            saveTypeScope(fileDef, writer);
            try (OutputStreamWriter stream = new OutputStreamWriter(new FileOutputStream(currentDirectory.resolve(fileDef.getFileName()).toFile()))) {
                writer.saveTo(stream);
            }
        }
    }

    private static void saveTypeScope(TypeScope scope, CodeWriter writer) {
        for (DecoratorDef decoratorDef : scope.getDefinedDecorators()) {
            writer.newLine();
            saveDecorator(decoratorDef, writer);
        }
        for (EnumerationDef enumerationDef : scope.getDefinedEnumerations()) {
            writer.newLine();
            saveEnumeration(enumerationDef, writer);
        }
        for (InterfaceDef interfaceDef : scope.getDefinedInterfaces()) {
            writer.newLine();
            saveInterface(interfaceDef, writer);
        }
        for (ClassDef classDef : scope.getDefinedClasses()) {
            writer.newLine();
            saveClass(classDef, writer);
        }
    }

    private static void saveDecorator(DecoratorDef decoratorDef, CodeWriter writer) {
        saveComments(decoratorDef, writer);
        saveDecorators(decoratorDef, writer);
        writer.write(String.format("decorator %s {", decoratorDef.getName()));
        writer.indent();
        if (decoratorDef.getDefinedConstants().size() > 0) {
            writer.newLine();
            saveConstants(decoratorDef, writer);
        }
        saveTypeScope(decoratorDef, writer);
        if (decoratorDef.getProperties().size() > 0) {
            writer.newLine();
            int i = 0;
            while (i < decoratorDef.getProperties().size()) try {
                final DecoratorPropertyDef propertyDef = decoratorDef.getProperties().get(i);
                saveComments(propertyDef, writer);
                saveDecorators(propertyDef, writer);
                if (propertyDef.getDefault() == null)
                    writer.writeLine(String.format("%s %s;", propertyDef.getType().toString(), propertyDef.getName()));
                else
                    writer.writeLine(String.format("%s %s = %s;", propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));
                if (i + 1 < decoratorDef.getProperties().size())
                    writer.newLine();
            } finally {
                i += 1;
            }
        }
        writer.dedent();
        writer.writeLine("}");
    }

    private static String luminaryTypeName(IntegralType type) {
        switch(type) {
            case INT8:
                return "Int8";
            case UINT8:
                return "Int8";
            case INT16:
                return "Int8";
            case UINT16:
                return "Int8";
            case INT32:
                return "Int8";
            case UINT32:
                return "Int8";
            case INT64:
                return "Int8";
            case UINT64:
                return "Int8";
            default:
                throw new IllegalArgumentException("Integral type '" + type + "' is unknown.");
        }
    }

    private static void saveEnumeration(EnumerationDef enumerationDef, CodeWriter writer) {
        saveComments(enumerationDef, writer);
        saveDecorators(enumerationDef, writer);
        writer.write(String.format("enum %s : %s {", enumerationDef.getName(), luminaryTypeName(enumerationDef.getUnderlyingType())));
        writer.indent();
        if (enumerationDef.getMembers().size() > 0) {
            writer.newLine();
            int i = 0;
            while (i < enumerationDef.getMembers().size()) try {
                final EnumerationMemberDef memberDef = enumerationDef.getMembers().get(i);
                saveComments(memberDef, writer);
                saveDecorators(memberDef, writer);
                writer.writeLine(String.format("%s = %s;", memberDef.getName(), memberDef.getValue().toString()));
                if (i + 1 < enumerationDef.getMembers().size())
                    writer.newLine();
            } finally {
                i += 1;
            }
        }
        writer.dedent();
        writer.writeLine("}");
    }

    private static void saveInterface(InterfaceDef interfaceDef, CodeWriter writer) {
        saveComments(interfaceDef, writer);
        saveDecorators(interfaceDef, writer);
        writer.write(String.format("interface %s ", interfaceDef.getName()));
        if (interfaceDef.getSuperInterfaces().size() > 0) {
            writer.write(": " + interfaceDef.getSuperInterfaces().get(0).getName());
            int i = 1;
            while (i < interfaceDef.getSuperInterfaces().size()) try {
                writer.write(", " + interfaceDef.getSuperInterfaces().get(i).getName());
            } finally {
                i += 1;
            }
        }
        writer.write(" {");
        writer.indent();
        saveTypeScope(interfaceDef, writer);
        if (interfaceDef.getProperties().size() > 0) {
            writer.newLine();
            int i = 0;
            while (i < interfaceDef.getProperties().size()) try {
                final InterfacePropertyDef propertyDef = interfaceDef.getProperties().get(i);
                saveComments(propertyDef, writer);
                saveDecorators(propertyDef, writer);
                writer.write(String.format("%s %s", propertyDef.getType().toString(), propertyDef.getName()));
                if (propertyDef.isReadable())
                    writer.write(" get");
                if (propertyDef.isWritable())
                    writer.write(" set");
                writer.writeLine(";");
                if (i + 1 < interfaceDef.getProperties().size())
                    writer.newLine();
            } finally {
                i += 1;
            }
        }
        writer.dedent();
        writer.writeLine("}");
    }

    private static void saveClass(ClassDef classDef, CodeWriter writer) {
        saveComments(classDef, writer);
        saveDecorators(classDef, writer);
        writer.write(String.format(classDef.isFinal() ? "final class" : "class %s", classDef.getName()));
        if (classDef.getSuperClass() != null || classDef.getSuperInterfaces().size() > 0) {
            boolean isFirst = true;
            if (classDef.getSuperClass() != null) {
                isFirst = false;
                writer.write(String.format(": %s", classDef.getSuperClass().getName()));
            }
            for (InterfaceDef superInterfaceDef : classDef.getSuperInterfaces()) {
                if (isFirst) {
                    isFirst = false;
                    writer.write(String.format(": %s", superInterfaceDef.getName()));
                } else
                    writer.write(String.format(", %s", superInterfaceDef.getName()));
            }
        }
        writer.write(" {");
        writer.indent();
        if (classDef.getDefinedConstants().size() > 0) {
            writer.newLine();
            saveConstants(classDef, writer);
        }
        saveTypeScope(classDef, writer);
        if (classDef.getProperties().size() > 0) {
            writer.newLine();
            int i = 0;
            while (i < classDef.getProperties().size()) try {
                final ClassPropertyDef propertyDef = classDef.getProperties().get(i);
                saveComments(propertyDef, writer);
                saveDecorators(propertyDef, writer);
                final String prefix = propertyDef.isFinal() ? (propertyDef.isOverride() ? "final override " : "final ") : (propertyDef.isOverride() ? "override " : "");
                if (propertyDef.getDefault() == null)
                    writer.writeLine(String.format("%s%s %s;", prefix, propertyDef.getType().toString(), propertyDef.getName()));
                else
                    writer.writeLine(String.format("%s%s %s = %s;", prefix, propertyDef.getType().toString(), propertyDef.getName(), propertyDef.getDefault().toString()));
                if (i + 1 < classDef.getProperties().size())
                    writer.newLine();
            } finally {
                i += 1;
            }
        }
        writer.dedent();
        writer.writeLine("}");
    }

    private static void saveComments(ItemDef commentable, CodeWriter writer) {
        for (String comment : commentable.getComments()) writer.writeLine("/// " + comment);
    }

    private static void saveDecorators(ItemDef decoratable, CodeWriter writer) {
        for (Decorator decorator : decoratable.getDecorators()) {
            final DecoratorDef decoratorDef = decorator.getDefinition();
            writer.write(String.format("[%s", decoratorDef.getName()));
            if (decorator.getArguments().size() > 0 && decoratorDef.getProperties().size() > 0) {
                writer.write("(");
                boolean isFirst = true;
                int i = 0;
                while (i < decorator.getArguments().size()) try {
                    final DecoratorPropertyDef propertyDef = decorator.getArguments().get(i).getDefinition();
                    if (!decorator.getArguments().get(i).getValue().equals(propertyDef.getDefault())) {
                        if (!isFirst)
                            writer.write(", ");
                        else
                            isFirst = false;
                        writer.write(String.format("%s = %s", propertyDef.getName(), decorator.getArguments().get(i).getValue()));
                    }
                } finally {
                    i += 1;
                }
                writer.write(")");
            }
            writer.writeLine("]");
        }
    }

    private static void saveConstants(ConstantScope constantScope, CodeWriter writer) {
        int i = 0;
        while (i < constantScope.getDefinedConstants().size()) try {
            final ConstantDef constantDef = constantScope.getDefinedConstants().get(i);
            saveComments(constantDef, writer);
            saveDecorators(constantDef, writer);
            writer.writeLine(String.format("const %s %s = %s;", constantDef.getType().toString(), constantDef.getName(), constantDef.getValue().toString()));
            if (i + 1 < constantScope.getDefinedConstants().size())
                writer.newLine();
        } finally {
            i += 1;
        }
    }

    public static void main(String[] args) throws IOException {
        final ProjectLoader loader = new ProjectLoader();
        System.setProperty("luminary.search.path", "C:\\Projects\\MaxiMarkets\\ProtocolGenerators\\luminary");
        final ProjectDef projectDef = loader.load("C:\\Projects\\MaxiMarkets\\TradingServer\\luminary\\External\\External.json");
        ProjectSaver.save(projectDef, "D:\\Temporary\\Luminary");
    }
}

```


Overlapping Code:
```
blic class ProjectSaver {
public static void save(ProjectDef projectDef, String rootDirectory) throws IOException {
if (projectDef.getFileName() == null)
throw new IllegalArgumentException("Built-in projects cannot be exported.");
final Path directory = Paths.get(rootDirectory);
if (!Files.exists(directory))
throw new IllegalArgumentException("Directory does not exist.");
saveProjectFile(projectDef, directory);
for (NamespaceDef namespaceDef : projectDef.getNamespaces().amespaceDef, directory);
}
private static void saveProjectFile(ProjectDef projectDef, Path directory) throws IOException {
final ProjectFile projectFile = new ProjectFile();
projectFile.References = projectDef.getReferences().keySet().toArray(new String[0]);
projectFile.Sources = new ProjectSource[];
final Gson gson = new GsonBuilder().setPrettyPrinting().create();
try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(directory.resolve(projectDef.getFileName()).toFile()))) {
gson.toJson(projectFile, writer);
}
}
private static void saveNamespace(NamespaceDef namespaceDef, Path directory) throws IOException {
Path currentDirectory = directory;
for (String component : namespaceDef.getNamespace().split("\\.")) {
currentDirectory = currentDirectory.resolve(component);
Files.createDirectories(currentDirectory);
}
for (FileDef fileDef : namespaceDef.getFiles().values()) {
final CodeWriter writer = new CodeWriter(4);
writer.writeLine(String.format("namespace %s;", namespaceDef.getNamespace()));
if (fileDef.getImports().size() > 0) {
writer.newLine();
for (ImportDef importDef : fileDef.getImports(:
writer.writeLine(String.format("import %s.*;", ((ImportNamespaceDef) importDef).getTarget().getNamespace()));
break;
case TYPE:
ImportTypeDef importTypeDef = (ImportTypeDef) importDef;
writer.writeLat("import %s.%s;", importTypeDef.getTarget().getNamespace().getNam
```
<Overlap Ratio: 0.91357421875>

---

--- 108 --
Question ID: 3b1f1163c4fbe704f26bdef5c95140affece7ef5
Original Code:
```
public class Annuity<P extends Payment> implements InstrumentDerivative {

    /**
     * The list of the annuity payments.
     */
    private final P[] _payments;

    /**
     * Flag indicating if the annuity is payer (true) or receiver (false). Deduced from the first non-zero amount;
     * if all amounts don't have the same sign, the flag may be incorrect.
     */
    private final boolean _isPayer;

    /**
     * @param payments The payments, not null or empty
     */
    public Annuity(final P[] payments) {
        ArgumentChecker.noNulls(payments, "payments");
        ArgumentChecker.isTrue(payments.length > 0, "Have no payments in annuity");
        final Currency currency0 = payments[0].getCurrency();
        double amount = payments[0].getReferenceAmount();
        int loopcpn = 1;
        while (loopcpn < payments.length) try {
            ArgumentChecker.isTrue(currency0.equals(payments[loopcpn].getCurrency()), "currency not the same for all payments");
            amount = (amount == 0) ? payments[loopcpn].getReferenceAmount() : amount;
        } finally {
            loopcpn++;
        }
        _payments = payments;
        _isPayer = (amount < 0);
    }

    /**
     * @param payments The payments, not null or empty
     * @param pType The type of the payments, not null
     * @param isPayer True if the annuity is to be paid
     */
    public Annuity(final List<? extends P> payments, final Class<P> pType, final boolean isPayer) {
        ArgumentChecker.noNulls(payments, "payments");
        ArgumentChecker.notNull(pType, "type");
        ArgumentChecker.isTrue(payments.size() > 0, "Payments size must be greater than zero");
        _payments = payments.toArray((P[]) Array.newInstance(pType, 0));
        _isPayer = isPayer;
    }

    /**
     * Gets the number of payments in the annuity.
     * @return The number of payments
     */
    public int getNumberOfPayments() {
        return _payments.length;
    }

    /**
     * Gets the nth payment in an annuity. <b>Note that n = 0 will give the first payment</b>.
     * @param n The number of the payment
     * @return The nth payment
     */
    public P getNthPayment(final int n) {
        return _payments[n];
    }

    /**
     * Return the currency of the annuity.
     * @return The currency.
     */
    public Currency getCurrency() {
        return _payments[0].getCurrency();
    }

    /**
     * Check if the payments of an annuity is of the type CouponFixed or CouponIbor. Used to check that payment are of vanilla type.
     * @return  True if IborCoupon or FixedCoupon
     */
    public boolean isIborOrFixed() {
        //TODO: is this method necessary?
        boolean result = true;
        for (final P payment : _payments) {
            result = result && payment.isIborOrFixed();
        }
        return result;
    }

    /**
     * Gets the payments array.
     * @return the payments
     */
    public P[] getPayments() {
        return _payments;
    }

    /**
     * Gets the payer flag: payer (true) or receiver (false)
     * @return The payer flag.
     * @deprecated The payer flag is no longer used; the sign of the notional
     * determines whether a leg is paid or received
     */
    @Deprecated
    public boolean isPayer() {
        return _isPayer;
    }

    /**
     * Return the discounting (or funding) curve name. Deduced from the first payment.
     * @return The name.
     * @deprecated Curve names should not be set in {@link InstrumentDerivative}s
     */
    @Deprecated
    public String getDiscountCurve() {
        return getNthPayment(0).getFundingCurveName();
    }

    /**
     * Create a new annuity with the payments of the original one paying strictly after the given time.
     * @param trimTime The time.
     * @return The trimmed annuity.
     */
    @SuppressWarnings("unchecked")
    public Annuity<P> trimBefore(final double trimTime) {
        final List<P> list = new ArrayList<>();
        list.clear();
        for (final P payment : _payments) {
            if (payment.getPaymentTime() > trimTime) {
                list.add(payment);
            }
        }
        return new Annuity<>(list.toArray((P[]) new Payment[list.size()]));
    }

    /**
     * Create a new annuity with the payments of the original one paying before or on the given time.
     * @param trimTime The time.
     * @return The trimmed annuity.
     */
    @SuppressWarnings("unchecked")
    public Annuity<P> trimAfter(final double trimTime) {
        final List<P> list = new ArrayList<>();
        for (final P payment : _payments) {
            if (payment.getPaymentTime() <= trimTime) {
                list.add(payment);
            }
        }
        return new Annuity<>(list.toArray((P[]) new Payment[list.size()]));
    }

    @Override
    public String toString() {
        final StringBuffer result = new StringBuffer("Annuity:");
        for (final P payment : _payments) {
            result.append(payment.toString());
            result.append("\n");
        }
        return result.toString();
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + Arrays.hashCode(_payments);
        return result;
    }

    @Override
    public boolean equals(final Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final Annuity<?> other = (Annuity<?>) obj;
        if (_payments.length != other._payments.length) {
            return false;
        }
        int i = 0;
        while (i < _payments.length) try {
            if (!ObjectUtils.equals(_payments[i], other._payments[i])) {
                return false;
            }
        } finally {
            i++;
        }
        return true;
    }

    @Override
    public <S, T> T accept(final InstrumentDerivativeVisitor<S, T> visitor, final S data) {
        ArgumentChecker.notNull(visitor, "visitor");
        return visitor.visitGenericAnnuity(this, data);
    }

    @Override
    public <T> T accept(final InstrumentDerivativeVisitor<?, T> visitor) {
        ArgumentChecker.notNull(visitor, "visitor");
        return visitor.visitGenericAnnuity(this);
    }
}

```


Overlapping Code:
```
t> implements InstrumentDerivative {
/**
* The list of the annuity payments.
*/
private final P[] _payments;
/**
* Flag indicating if the annuity is payer (true) or receiver (false). Deduced from the first non-zero amount;
* if all amounts don't have the same sign, the flag may be incorrect.
*/
private final boolean _isPayer;
/**
* @param payments The payments, not null or empty
*/
public Annuity(final P[] payments) {
ArgumentChecker.noNulls(payments, "payments");
ArgumentChecker.isTrue(payments.length > 0, "Have no payments in annuity");
final Currency currency0 = payments[0].getCurrency();
dals(payments[loopcpn].getCurrency()), "currency not the same for all payments");
amount = (amount == 0) ? payments[loopcpn].getReferenceAmount() : amount;
}
_payments = payments;
_isPayer = (amount < 0);
}
/**
* @param payments The payments, not null or empty
* @param pType The type of the payments, not null
* @param isPayer True if the annuity is to be paid
*/
public Annuity(final List<? extends P> payments, final Class<P> pType, final boolean isPayer) {
ArgumentChecker.noNulls(payments, "payments");
ArgumentChecker.notNull(pType, "type");
ArgumentChecker.isTrue(payments.size() > 0, "Payments size must be greater than zero");
_payments = payments.toArray((P[]) Array.newInstance(pType, 0));
_isPayer = isPayer;
}
/**
* Gets the number of payments in the annuity.
* @return The number of payments
*/
public int getNumberOfPayments() {
return _payments.length;
}
/**
* Gets the nth payment in an annuity. <b>Note that n = 0 will give the first payment</b>.
* @param n The number of the payment
* @return The nth payment
*/
public P getNthPayment(final int n) {
return _payments[n];
}
/**
* Return the currency of the annuity.
* @return The currency.
*/
public Currency getCurrency() {
return _payments[0].getCurrency();
}
/**
* Check if the payments of an annuity is of the type CouponFixed or Co
```
<Overlap Ratio: 0.8972182932578973>

---

--- 109 --
Question ID: d5ac6617927f4b4b7426323e7423cf1ef9f5dad1
Original Code:
```
public class ComputationPipeline {

    private static final Logger LOGGER = LoggerFactory.getLogger(ComputationPipeline.class);

    private static final long DEFAULT_WAIT_TIME_IN_SECONDS = 30;

    private final List<PipelineStreamSource> sources = Lists.newArrayList();

    private final List<PipelineStage> stages = Lists.newArrayList();

    private NotificationBus notificationBus;

    private long waitTimeInSeconds;

    private String computationName;

    public static ComputationPipeline builder() {
        return new ComputationPipeline();
    }

    public ComputationPipeline notificationBus(NotificationBus notificationBusArg) {
        this.notificationBus = notificationBusArg;
        return this;
    }

    public ComputationPipeline computationName(String computationNameArg) {
        this.computationName = computationNameArg;
        return this;
    }

    public ComputationPipeline addSource(PipelineStreamSource streamSource) {
        this.sources.add(streamSource);
        return this;
    }

    public ComputationPipeline addPipelineStage(PipelineStage pipelineStage) {
        this.stages.add(pipelineStage);
        return this;
    }

    public ComputationPipeline connect(MessageSource to, PipelineStage... pipelineStages) {
        notificationBus.connect(to, pipelineStages);
        return this;
    }

    public ComputationPipeline initialize(Properties properties) {
        properties.put("computation.name", computationName);
        waitTimeInSeconds = PropertyReader.readLong(properties, properties, "computation.shutdown.wait_time_in_seconds", DEFAULT_WAIT_TIME_IN_SECONDS);
        sources.forEach(streamSource -> {
            try {
                streamSource.initialize(properties);
                ComponentMetadata componentMetadata = streamSource.getSourceMetadata();
                LOGGER.info("Initialized source: {}:{}:{}->{}", componentMetadata.getNamespace(), componentMetadata.getName(), componentMetadata.getVersion(), streamSource.getInstanceId());
            } catch (Exception e) {
                throw new RuntimeException(String.format("Error initializing source: %s", streamSource.getInstanceId()), e);
            }
        });
        stages.forEach(stage -> {
            try {
                stage.initialize(properties);
                ComponentMetadata componentMetadata = stage.getProcessorMetadata();
                LOGGER.info("Initialized processor: {}:{}:{}->{}", componentMetadata.getNamespace(), componentMetadata.getName(), componentMetadata.getVersion(), stage.getInstanceId());
            } catch (InitializationException e) {
                throw new RuntimeException(String.format("Error initializing processor: %s", stage.getInstanceId()), e);
            }
        });
        return this;
    }

    public boolean healthcheck() {
        boolean a = true;
        try {
            for (PipelineStreamSource source : sources) {
                a = a & source.healthcheck();
                if (!a) {
                    return a;
                }
            }
            for (PipelineStage stage : stages) {
                a = a & stage.healthcheck();
                if (!a) {
                    return a;
                }
            }
        } catch (Throwable t) {
            a = false;
            LOGGER.error("Error when calling healthcheck on one of the components: ", t);
        }
        return a;
    }

    public ComputationPipeline start() {
        LOGGER.info("Starting pipeline...");
        notificationBus.start();
        stages.forEach(PipelineStage::start);
        sources.forEach(PipelineStreamSource::start);
        return this;
    }

    public void stop() {
        LOGGER.info("Stopping pipeline...");
        sources.forEach(PipelineStreamSource::stop);
        // adding sufficient sleep time for a graceful stop, allowing enough time for events in transit to be processed
        try {
            Thread.sleep(waitTimeInSeconds * 1000);
        } catch (InterruptedException iEx) {
            LOGGER.warn("Sleep was interrupted: " + iEx.getMessage());
        }
        stages.forEach(PipelineStage::stop);
        notificationBus.stop();
    }
}

```


Overlapping Code:
```
tionPipeline {
private static final Logger LOGGER = LoggerFactory.getLogger(ComputationPipeline.class);
private static final long DEFAULT_WAIT_TIME_IN_SECONDS = 30;
private final List<PipelineStreamSource> sources = Lists.newArrayList();
private final List<PipelineStage> stages = Lists.newArrayList();
private NotificationBus notificationBus;
private long waitTimeInSeconds;
private String computationName;
public static ComputationPipeline builder() {
return new ComputationPipeline();
}
public ComputationPipeline notificationBus(NotificationBus notificationBusArg) {
this.notificationBus = notificationBusArg;
return this;
}
public ComputationPipeline computationName(String computationNameArg) {
this.computationName = computationNameArg;
return this;
}
public ComputationPipeline addSource(PipelineStreamSource streamSource) {
this.sources.add(streamSource);
return this;
}
public ComputationPipeline addPipelineStage(PipelineStage pipelineStage) {
this.stages.add(pipelineStage);
return this;
}
public ComputationPipeline connect(MessageSource to, PipelineStage... pipelineStages) {
notificationBus.connect(to, pipelineStages);
return this;
}
public ComputationPipeline initialize(Properties properties) {
properties.put("computation.name", computationName);
waitTimeInSeconds = PropertyReader.readLong(properties, properties, "computation.shuSECONDS);
sources.forEach(streamSource -> {
try {
streamSource.initialize(properties);
ComponentMetadata componentMetadata = streamSource.getSourceMetadata();
LOGGER.info("Initialized source: {}:{}:{}Metadata.getName(), componentMetadata.getVersion(), streamSource.getInstanceId());
} catch (Exception e) {
throw new RuntimeException(String.format("Error initializing source: %s", streamSource.getInsy {
stage.initialize(properties);
ComponentMetadata componentMetadata = stage.getProcessorMetadata();
LOGGER.info("Initialized processor: {}:{}:{}->{}
```
<Overlap Ratio: 0.8974964572508266>

---

--- 110 --
Question ID: 32afa3a8e9b1807eedffda9e3ea7130a21a31f59
Original Code:
```
public final class SphereShardingSphereProxy {

    private static final Logger log = LoggerFactory.getLogger(SphereShardingSphereProxy.class);

    private EventLoopGroup bossGroup;

    private EventLoopGroup workerGroup;

    /**
     * Start ShardingSphere-Proxy.
     *
     * @param port port
     */
    public void start(final int port) {
        try {
            createEventLoopGroup();
            ServerBootstrap bootstrap = new ServerBootstrap();
            initServerBootstrap(bootstrap, port);
            ChannelFuture future = bootstrap.bind(port).sync();
            log.info("ShardingSphere-Proxy start success.");
            future.channel().closeFuture().sync();
        } catch (InterruptedException e) {
            throw DbException.convert(e);
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
            BackendExecutorContext.getInstance().getExecutorKernel().close();
        }
    }

    private void createEventLoopGroup() {
        bossGroup = Epoll.isAvailable() ? new EpollEventLoopGroup(1) : new NioEventLoopGroup(1);
        workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();
    }

    private void initServerBootstrap(final ServerBootstrap bootstrap, int port) {
        bootstrap.group(bossGroup, workerGroup).channel(Epoll.isAvailable() ? EpollServerSocketChannel.class : NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, 128).option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(8 * 1024 * 1024, 16 * 1024 * 1024)).option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT).childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT).childOption(ChannelOption.TCP_NODELAY, true).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new ServerHandlerInitializer(port));
    }

    public final class ServerHandlerInitializer extends ChannelInitializer<SocketChannel> {

        final int port;

        public ServerHandlerInitializer(int port) {
            this.port = port;
        }

        @Override
        protected void initChannel(final SocketChannel socketChannel) {
            DatabaseProtocolFrontendEngine databaseProtocolFrontendEngine;
            if (port == PgServer.DEFAULT_PORT) {
                // databaseProtocolFrontendEngine = getDatabaseProtocolFrontendEngineFactory("LealonePostgreSQL");
                databaseProtocolFrontendEngine = LealonePostgreSQLFrontendEngine.INSTANCE;
            } else {
                // databaseProtocolFrontendEngine = getDatabaseProtocolFrontendEngineFactory("LealoneMySQL");
                databaseProtocolFrontendEngine = LealoneMySQLFrontendEngine.INSTANCE;
            }
            ChannelPipeline pipeline = socketChannel.pipeline();
            pipeline.addLast(new PacketCodec(databaseProtocolFrontendEngine.getCodecEngine()));
            pipeline.addLast(new FrontendChannelInboundHandler(databaseProtocolFrontendEngine));
        }

        public DatabaseProtocolFrontendEngine getDatabaseProtocolFrontendEngineFactory(final String databaseType) {
            for (DatabaseProtocolFrontendEngine each : ShardingSphereServiceLoader.newServiceInstances(DatabaseProtocolFrontendEngine.class)) {
                if (DatabaseTypeRegistry.getActualDatabaseType(databaseType).getName().equals(databaseType)) {
                    return each;
                }
            }
            throw new UnsupportedOperationException(String.format("Cannot support database type '%s'", databaseType));
        }
    }
}

```


Overlapping Code:
```
l class SphereShardingSphereProxy {
private static final Logger log = LoggerFactory.getLogger(SphereShardingSphereProxy.class);
private EventLoopGroup bossGroup;
private EventLoopGroup workerGroup;
/**
* Start ShardingSphere-Proxy.
*
* @param port port
*/
public void start(final int port) {
try {
createEventLoopGroup();
ServerBootstrap bootstrap = new ServerBootstrap();
initServerBootstrap(bootstrap, port);
ChannelFuture future = bootstrap.bind(port).sync();
log.info("ShardingSphere-Proxy start success.");
future.channel().closeFuture().sync();
} catch (InterruptedException e) {
throw DbException.convert(e);
} finally {
workerGroup.shutdownGracefully();
bossGroup.shutdownGracefully();
BackendExecutorContext.getInstance().getExecutorKernel().close();
}
}
private void createEventLoopGroup() {
bossGroup = Epoll.isAvailable() ? new EpollEventLoopGroup(1) : new NioEventLoopGroup(1);
workerGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();
}
private void initServerBootstrap(final ServerBootstrap bootstrap, int port) {
bootstrap.group(bossGroup, workerGroup).channel(Epoll.isAvailable() ? EpollServerSocketChannel.class : NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, 1.option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(8 * 1024 * 1024, 16 * 1024.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT).childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)tion(ChannelOption.TCP_NODELAY, true).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new Serverializer(port));
}
public final class ServerHandlerInitializer extends ChannelInitializer<SocketChannel> {
final int port;
public ServerHandlerInitializer(int port) {
this.port = port;
}
@Override
protected void initChannel(final SocketChannel socketChannel) {
DatabaseProtocolFrontendEngine databaseProtocolFrontendEngine;
if (port == PgServer.DEFAULT_PORT) {
// databaseProtocolFrontendEngine = getDatabaseProtocolFrontendEngineFactory("LealonePostgreSQL");
databaseProtocolFrontendEngine = LealoneP
```
<Overlap Ratio: 0.9649040711277492>

---

--- 111 --
Question ID: d89d093a9df3cb37c4585f397e20182e3baca772
Original Code:
```
public class Quini6Test {

    @Test
    public void testJugadorAlPasarPorPrimeraVezRecibe50000ASuCapital() {
        Jugador jugador = new Jugador("Dio");
        Quini6 quini6 = new Quini6();
        jugador.caeEn(quini6);
        Assert.assertEquals(jugador.capital(), 150000);
    }

    @Test
    public void testJugadorAlPasarPorSegundaVezRecibe30000ASuCapital() {
        Jugador jugador = new Jugador("Dio");
        Quini6 quini6 = new Quini6();
        jugador.caeEn(quini6);
        jugador.caeEn(quini6);
        Assert.assertEquals(jugador.capital(), 180000);
    }

    @Test
    public void testJugadorAlPasarPorTerceraVezNoRecibeIngresoASuCapital() {
        Jugador jugador = new Jugador("Dio");
        Quini6 quini6 = new Quini6();
        jugador.caeEn(quini6);
        jugador.caeEn(quini6);
        jugador.caeEn(quini6);
        jugador.caeEn(quini6);
        Assert.assertEquals(jugador.capital(), 180000);
    }
}

```


Overlapping Code:
```
blic class Quini6Test {
@Test
public void testJugagador jugador = new Jugador("Dio");
Quini6 quini6 = new Quini6();
jugador.caeEn(quini6);
Assert.assertEquals(jugador.capital(), 150000);
}
@Test
public void testJugadorAlPasarPorSegundaVezRecibe30000Agador jugador = new Jugador("Dio");
Quini6 quini6 = new Quini6();
jugador.caeEn(quini6);
jugador.caeEn(quini6);
Assert.assertEquals(jugador.capital(), 180000);
}
@Test
public void testJugadorAlPasarPorTerceraVezNoRecibeIngresoASuCapitagador jugador = new Jugador("Dio");
Quini6 quini6 = new Quini6();
jugador.caeEn(quini6);
jugador.caeEn(quini6);
jugador.caeEn(quini6);
jugador.caeEn(quini6);
Assert.assertEquals(jugador.capital
```
<Overlap Ratio: 0.8793774319066148>

---

--- 112 --
Question ID: 45059a9352250ed2493baa512f6df38fe9ceaa67
Original Code:
```
public class IO {

    private final PrintStream out;

    private final Scanner scanner;

    private final String consolePrefix;

    enum MessageType {

        INFO, WARNING, ERROR
    }

    public IO(PrintStream out, InputStream in, String consolePrefix) {
        this.out = out;
        this.scanner = new Scanner(in);
        this.consolePrefix = consolePrefix;
    }

    public IO(PrintStream out, InputStream in) {
        this(out, in, ">>> ");
    }

    public IO() {
        this(System.out, System.in);
    }

    public void printString(String string) {
        out.print(string);
    }

    private void printConsolePrefix() {
        printString(consolePrefix);
    }

    public void printMessage(MessageType type, String message) {
        printLine(String.format("%s: %s", type.name(), message));
    }

    public void printError(String errorMessage) {
        printMessage(MessageType.ERROR, errorMessage);
    }

    public void printConditionError(Object value, String condition) {
        printError(String.format("The value (%s) is mismatching next condition: %s", value.toString(), condition));
    }

    public void printLine(String string) {
        printString(String.format("%s\n", string));
    }

    public String readString() {
        printConsolePrefix();
        return scanner.next();
    }

    public String readString(Predicate<String> predicate, String predicateCondition) {
        String string;
        for (; true; ) {
            string = readString();
            if (predicate.test(string)) {
                break;
            } else {
                printConditionError(string, predicateCondition);
            }
        }
        return string;
    }

    public int readInt() throws InputMismatchException {
        printConsolePrefix();
        return scanner.nextInt();
    }

    public int readInt(String errorMessage) {
        Integer number = null;
        for (; number == null; ) {
            try {
                number = readInt();
            } catch (InputMismatchException e) {
                readString();
                printError(errorMessage);
            }
        }
        return number;
    }

    public int readInt(String errorMessage, Predicate<Integer> predicate, String predicateCondition) {
        int number;
        for (; true; ) {
            number = readInt(errorMessage);
            if (predicate.test(number)) {
                break;
            } else {
                printConditionError(number, predicateCondition);
            }
        }
        return number;
    }
}

```


Overlapping Code:
```
ivate final PrintStream out;
private final Scanner scanner;
private final String consolePrefix;
enum Meream out, InputStream in, String consolePrefix) {
this.out = out;
this.scanner = new Scanner(in);
this.consolePrefix = consolePrefix;
}
public IO(PrintStream out, InputStream in) {
this(out, in, ">>> ");
}
public IO() {
this(System.out, System.in);
}
public void printString(String string) {
out.print(string);
}
private void printConsolePrefix() {
printString(consolePrefix);
}
public void printMessage(MessageType type, String message) {
printLine(String.format("%s: %s", type.name(), message));
}
public void printError(String errorMessage) {
printMessage(MessageType.ERROR, errorMessage);
}
public void printConditionError(Object value, String condition) {
printError(String.format("The value (%s) is mismatching next condition: %s", value.toString(), condition));
}
public void printLine(String string) {
printString(String.format("%s\n", string));
}
public String readString() {
printConsolePrefix();
return scanner.next();
}
public String readString(Predicate<String> predicate, String predicag = readString();
if (predicate.test(string)) {
break;
} else {
printConditionError(string, predicateCondition);
}
}
return string;
}
public int readInt() throws InputMismatchException {
printConsolePrefix();
return scanner.nextInt();
}
public int readInt(String errorMessage) {
Integer number = null);
} catch (InputMismatchException e) {
readString();
printError(errorMessage);
}
}
return number;
}
public int readInt(String errorMessage, Predicate<Integer> predicate, String predicateCondition) {
essage);
if (predicate.test(number)) {
break;
} el
```
<Overlap Ratio: 0.8645397489539749>

---

--- 113 --
Question ID: 9359f69e953ce02cd6b1b8e24ffc79b7e97c5c89
Original Code:
```
public class Slag extends Item {

    private static final IDispenseItemBehavior SLAG_DISPENSER_BEHAVIOR = new OptionalDispenseBehavior() {

        @Override
        protected ItemStack execute(IBlockSource source, ItemStack stack) {
            World world = source.getLevel();
            BlockPos blockpos = source.getPos().relative(source.getBlockState().getValue(DispenserBlock.FACING));
            //We currently use the deprecated method because this is what vanilla dispensers currently use
            if (BoneMealItem.growCrop(stack, world, blockpos)) {
                if (!world.isClientSide) {
                    world.levelEvent(2005, blockpos, 0);
                }
                //Success
                setSuccess(true);
            } else {
                //Fail
                setSuccess(false);
            }
            return stack;
        }
    };

    protected Slag() {
        super(new Properties().tab(CRItems.TAB_CROSSROADS));
        String name = "slag";
        setRegistryName(name);
        CRItems.toRegister.add(this);
        DispenserBlock.registerBehavior(this, SLAG_DISPENSER_BEHAVIOR);
    }

    @Override
    public ActionResultType useOn(ItemUseContext context) {
        if (BoneMealItem.applyBonemeal(context.getItemInHand(), context.getLevel(), context.getClickedPos(), context.getPlayer())) {
            if (!context.getLevel().isClientSide) {
                context.getLevel().levelEvent(2005, context.getClickedPos(), 0);
            }
            return ActionResultType.SUCCESS;
        }
        return ActionResultType.FAIL;
    }
}

```


Overlapping Code:
```
xtends Item {
private static final IDispenseItemBehavior SLAG_DISPEispenseBehavior() {
@Override
protected ItemStack execute(IBlockSource source, ItemStack stack) {
World world = source.getLevel();
BlockPos blockpos = source.getPos().relative(source.getBlockState().getValue(DispenserBlock.FACING));
//We currently use the deprecated method because this is what vanilla dispensers currentlyClientSide) {
world.levelEvent(2005, blockpos, 0);{
super(new Properties().tab(CRItems.TAB_CROSSROADS));
String name = "slag";
setRegistryName(name);
CRItems.toRegister.add(this);
DispenserBlock.registerBehavior(this, SLAG_DISPENSER_BEHAVIOR);
}
@Override
public ActionResultType useOn(ItemUseContext context) {
ifnemeal(context.getItemInHand(), context.getLevel(), context.getClickedPos(), conteevel().levelEvent(2005, context.getClickedPos(), 0);
}
return ActionResultType.SUCCESS;
}
return ActionResultType.FAIL;
}

```
<Overlap Ratio: 0.7412244897959184>

---

--- 114 --
Question ID: 4d76de705259e8969c3567afa2dc3811eff12574
Original Code:
```
@Service
public class IssueServiceImpl implements IssueService {

    private final IssueRepository issueRepository;

    private final LabelRepository labelRepository;

    private final UserRepository userRepository;

    private final ModelMapper modelMapper;

    private final FromIssueToIssueDTO fromIssueToIssueDTO;

    private final FromIssueDTOToIssue fromIssueDTOToIssue;

    private final FromLabelToLabelDTO fromLabelToLabelDTO;

    private final FromLabelDTOToLabel fromLabelDTOToLabel;

    private final FromUserToUserDTO fromUserToUserDTO;

    private final FromUserDTOToUser fromUserDTOToUser;

    private final CommentService commentService;

    private final FromCommentDTOToComment fromCommentDTOtoComment;

    private final StateRepository stateRepository;

    private final static String ASCENDING = "asc";

    private final static String DESCENDING = "desc";

    private final static String ORDER_TYPE_ERROR_MESSAGE = " Recieved OrderType is : %s .\nOrder Type must be asc or desc.";

    @Autowired
    public IssueServiceImpl(IssueRepository issueRepository, LabelRepository labelRepository, UserRepository userRepository, ModelMapper modelMapper, FromIssueToIssueDTO fromIssueToIssueDTO, FromIssueDTOToIssue fromIssueDTOToIssue, FromLabelToLabelDTO fromLabelToLabelDTO, FromLabelDTOToLabel fromLabelDTOToLabel, FromUserToUserDTO fromUserToUserDTO, FromUserDTOToUser fromUserDTOToUser, CommentService commentService, FromCommentDTOToComment fromCommentDTOtoComment, StateRepository stateRepository) {
        this.issueRepository = issueRepository;
        this.labelRepository = labelRepository;
        this.userRepository = userRepository;
        this.modelMapper = modelMapper;
        this.fromIssueToIssueDTO = fromIssueToIssueDTO;
        this.fromIssueDTOToIssue = fromIssueDTOToIssue;
        this.fromLabelToLabelDTO = fromLabelToLabelDTO;
        this.fromLabelDTOToLabel = fromLabelDTOToLabel;
        this.fromUserToUserDTO = fromUserToUserDTO;
        this.fromUserDTOToUser = fromUserDTOToUser;
        this.commentService = commentService;
        this.fromCommentDTOtoComment = fromCommentDTOtoComment;
        this.stateRepository = stateRepository;
    }

    @Override
    public IssueDTO createIssue(IssueDTO idt) {
        Issue issue = fromIssueDTOToIssue.convert(idt);
        IssueDTO issueDto = fromIssueToIssueDTO.convert(issueRepository.save(issue));
        return issueDto;
    }

    @Override
    public List<IssueDTO> getAllIssues() {
        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findAll());
        return issueDTOList;
    }

    @Override
    public IssueDTO findById(Long issueId) {
        IssueDTO issueDTO = fromIssueToIssueDTO.convert(issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new));
        return issueDTO;
    }

    @Override
    public List<IssueDTO> findALlByTitleKeyword(String keyword) {
        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByTitleKeyword(keyword));
        return issueDTOList;
    }

    @Override
    public List<IssueDTO> findALlByDescKeyword(String keyword) {
        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlByDescKeyword(keyword));
        return issueDTOList;
    }

    @Override
    public List<IssueDTO> findALlIssuesByLabel(String keyword) {
        List<IssueDTO> issueDTOList = fromIssueToIssueDTO.convertAll(issueRepository.findALlIssuesByLabel(keyword));
        return issueDTOList;
    }

    @Transactional
    @Override
    public IssueDTO addComment(Long issueId, CommentDTO commentDTO) {
        Issue issue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);
        Comment addedComment = commentService.createComment(fromCommentDTOtoComment.convert(commentDTO));
        issue.getComments().add(addedComment);
        return fromIssueToIssueDTO.convert(issueRepository.save(issue));
    }

    @Override
    public void deleteComment(Long issueId, Long commentId) {
        Issue issue = issueRepository.findById(issueId).orElseThrow(() -> new IssueTrackerNotFoundException("Issue", issueId.toString()));
        Optional<Comment> comment = issue.getComments().stream().filter(x -> x.getId() == commentId).findFirst();
        if (comment.isPresent()) {
            issue.getComments().remove(comment.get());
        } else {
            throw new IssueTrackerNotFoundException("Comment", commentId.toString());
        }
        issueRepository.save(issue);
    }

    @Override
    public List<IssueDTO> getAllIssuesOrderByCreateTime(boolean isAscending) {
        if (isAscending) {
            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTime());
        } else {
            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByCreateTimeDesc());
        }
    }

    @Override
    public IssueDTO updateState(Long issueId, Long stateId) {
        Issue issue = issueRepository.findById(issueId).orElseThrow(() -> new IssueTrackerNotFoundException("Issue", issueId.toString()));
        State state = stateRepository.findById(stateId).orElseThrow(() -> new IssueTrackerNotFoundException("State", stateId.toString()));
        issue.setState(state);
        return fromIssueToIssueDTO.convert(issueRepository.save(issue));
    }

    public List<IssueDTO> getAllIssuesOrderByUpdateTime(boolean isAscending) {
        if (isAscending) {
            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTime());
        } else {
            return fromIssueToIssueDTO.convertAll(issueRepository.findAllByOrderByUpdateTimeDesc());
        }
    }

    public List<IssueDTO> getAllIssuesSort(String orderType, String byWhichSort) {
        if (byWhichSort == null) {
            return getAllIssues();
        }
        if (byWhichSort.equalsIgnoreCase("createDate")) {
            if (orderType.equalsIgnoreCase(ASCENDING)) {
                return getAllIssuesOrderByCreateTime(true);
            } else if (orderType.equalsIgnoreCase(DESCENDING)) {
                return getAllIssuesOrderByCreateTime(false);
            } else {
                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));
            }
        } else if (byWhichSort.equalsIgnoreCase("update")) {
            if (orderType.equalsIgnoreCase(ASCENDING)) {
                return getAllIssuesOrderByUpdateTime(true);
            } else if (orderType.equalsIgnoreCase(DESCENDING)) {
                return getAllIssuesOrderByUpdateTime(false);
            } else {
                throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));
            }
        } else {
            throw new InvalidQueryParameterException(String.format(ORDER_TYPE_ERROR_MESSAGE, orderType));
        }
    }

    @Override
    public IssueDTO removeLabelFromIssue(Long labelId, Long issueId) {
        labelRepository.removeLabelFromIssue(labelId, issueId);
        Issue newIssue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);
        return fromIssueToIssueDTO.convert(newIssue);
    }

    @Override
    public IssueDTO addLabel(Long labelId, Long issueId) {
        Issue issue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);
        Label label = labelRepository.findById(labelId).orElseThrow(NoSuchElementException::new);
        issue.getLabels().add(label);
        return fromIssueToIssueDTO.convert(issueRepository.save(issue));
    }

    @Override
    public IssueDTO editIssue(Long issueId, IssueDTO issue) {
        Issue updatedIssue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);
        modelMapper.getConfiguration().setSkipNullEnabled(true);
        modelMapper.map(issue, updatedIssue);
        IssueDTO issueDTO = fromIssueToIssueDTO.convert(issueRepository.save(updatedIssue));
        return issueDTO;
    }

    @Override
    public void deleteIssue(Long issueId) {
        issueRepository.deleteById(issueId);
    }

    @Override
    public void deleteSelectedIssues(List<Long> selectedIssueIds) {
        for (Long id : selectedIssueIds) {
            deleteIssue(id);
        }
    }

    @Override
    public IssueDTO addAssignee(Long userId, Long issueId) {
        Issue issue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);
        User user = userRepository.findById(userId).orElseThrow(NoSuchElementException::new);
        issue.getAssignees().add(user);
        return fromIssueToIssueDTO.convert(issueRepository.save(issue));
    }

    @Override
    public IssueDTO removeAssigneeFromIssue(Long userId, Long issueId) {
        userRepository.removeAssigneeFromIssue(userId, issueId);
        Issue newIssue = issueRepository.findById(issueId).orElseThrow(NoSuchElementException::new);
        return fromIssueToIssueDTO.convert(newIssue);
    }
}

```


Overlapping Code:
```
Service
public class IssueServiceImpl implements IssueService {
private final IssueRepository issueRepository;
private final LabelRepository labelRepository;
private final UserRepository userRepository;
private final ModelMapper modelMapper;
private final FromIssueToIssueDTO fromIssueToIssueDTO;
private final FromIssueDTOToIssue fromIssueDTOToIssue;
private final FromLabelToLabelDTO fromLabelToLabelDTO;
private final FromLabelDTOToLabel fromLabelDTOToLabel;
private final FromUserToUserDTO fromUserToUserDTO;
private final FromUserDTOToUser fromUserDTOToUser;
private final CommentService commentService;
private final FromCommentDTOToComment fromCommentDTOtoComment;
private final StateRepository stateRepository;
private final static String ASCENDING = "asc";
privaerType is : %s .\nOrder Type must be asc or desc.";
@Autowired
public IssueServiceImpl(IssueRepository issueRepository, LabelRepository labelRepository, UserRepository userRepository, ModelMapper modelMapper, IssueDTO fromIssueToIssueDTO, FromIssueDTOToIssue ToLabelDTO, FromLabelDTOToLabel fromLabelDTOToLabel, FromUserToUserDTO fromUserToUserDTO, FromUserDTOToUser fromUserDTOToUser, CommentService commentSmment, StateRepository stateRepository) {
this.issueRepository = issueRepository;
this.labelRepository = labelRepository;
this.userRepository = userRepository;
this.modelMapper = modelMapper;
this.fromIssueToIssueDTO = fromIssueToIssueDTO;
this.fromIssueDTOToIssue = fromIssueDTOToIssue;
this.fromLabelToLabelDTO = fromLabelToLabelDTO;
this.fromLabelDTOToLabel = fromLabelDTOToLabel;
this.fromUserToUserDTO = fromUserToUserDTO;
this.fromUserDTOToUser = fromUserDTOToUser;
this.commentService = commentService;
this.fromCommentDTOtoComment = fromCommentDTOtoComment;
this.stateRepository = stateRepository;
}
@Override
public IssueDTO createIssue(IssueDTO idt) {
Issue issue = fromIssueDTOToIssue.convert(idt);
IssueDTO issueDto = fromIssueToIssueDTO.convert(issueRepository.save(issue));
return issueDto;
}
@Override
public List<IssueDTO> getAllIssue
```
<Overlap Ratio: 0.899822695035461>

---

--- 115 --
Question ID: 39d74258dd6a75d4e31c7f001884daaab0356310
Original Code:
```
public class Do implements Directive {

    Directive _prefix;

    @Override
    public String script() {
        return String.format("%s do", _prefix.script());
    }

    @Override
    public List<Parameter> parameters() {
        return _prefix.parameters();
    }

    public Nothing nothing() {
        Nothing re = new Nothing();
        re._prefix = this;
        return re;
    }

    public Update update() {
        Update re = new Update();
        re._prefix = this;
        return re;
    }

    public class Update implements Directive {

        Directive _prefix;

        @Override
        public String script() {
            return String.format("%s update", _prefix.script());
        }

        @Override
        public List<Parameter> parameters() {
            return _prefix.parameters();
        }

        public jaskell.sql.Update.Set set(String field, Directive value) {
            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);
            re._prefix = this;
            return re;
        }

        public jaskell.sql.Update.Set set(Directive field, Directive value) {
            jaskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);
            re._prefix = this;
            return re;
        }
    }
}

```


Overlapping Code:
```
s Directive {
Directive _prefix;
@Override
public String script() {
return String.format("%s do", _prefix.script());
}
@Override
public List<Parameter> parameters() {
return _prefix.parameters();
}
public Nothing nore._prefix = this;
return re;
}
public Update updare = new Update();
re._prefix = this;
return re;
}
public class Update implements Directive {
Directive _prefix;
@Override
public String script() {
return String.format("%s update", _prefix.script());
}
@Override
public List<Parameter> parameters() {
return _prefix.parameters();
}
public jaskell.sql.Update.Set set(String fielskell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);
re._prefix = this;
return re;
}
public jaskell.sql.Update.Set set(Directive field,skell.sql.Update.Set re = new jaskell.sql.Update.Set(field, value);
re._prefix = this;
return re;
}

```
<Overlap Ratio: 0.8698347107438017>

---

--- 116 --
Question ID: 5241f583035803403a5ac7cfdbb3662fe1b799f8
Original Code:
```
public class MainActivity extends AppCompatActivity implements MessageSignatureResultReceiver.Receiver {

    private static final String TAG_FRAGMENT_MAIN = "TAG_FRAGMENT_MAIN";

    public static final String TAG_FRAGMENT_MESSGAGE_SIGNATURE_HEADLESS = "TAG_FRAGMENT_MESSGAGE_SIGNATURE_HEADLESS";

    private MessageSignatureResultReceiver resultReceiver;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        pullMainFragment();
    }

    @Override
    public void onResume() {
        super.onResume();
        // register the result receiver to get the Message Signature back from the server
        registerResultReceiver();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();
        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            return true;
        }
        return super.onOptionsItemSelected(item);
    }

    private void pullMainFragment() {
        FragmentManager fragmentManager = getSupportFragmentManager();
        MainFragment mainFragment = (MainFragment) fragmentManager.findFragmentByTag(TAG_FRAGMENT_MAIN);
        if (mainFragment == null) {
            mainFragment = new MainFragment();
            fragmentManager.beginTransaction().replace(R.id.web_checkout_fragment_container, mainFragment, TAG_FRAGMENT_MAIN).commit();
        }
    }

    private void registerResultReceiver() {
        if (resultReceiver != null)
            return;
        resultReceiver = new MessageSignatureResultReceiver(new Handler());
        resultReceiver.setReceiver(this);
    }

    @Override
    public void onReceiveResult(int resultCode, Bundle resultData) {
    }

    //send the result to OnActivityResult defined in the fragments attached to the Activity
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        for (Fragment fragment : getSupportFragmentManager().getFragments()) {
            fragment.onActivityResult(requestCode, resultCode, data);
        }
    }
}

```


Overlapping Code:
```
public class MainActivity extends AppCompatActivity implements MessageSignatureResultReceiver.Receiver {
private static final String TAG_FRAGMENT_MAIN = "TAG_FRAGMENT_MAIN";
public static final String TAG_FRAGMENT_MESSGAGE_SIGNATURE_HEADLESS = "TAG_FRAGMENT_MESSGAGE_SIGNATURE_HEADLESS";
private MessageSignatureResultReceiver resultReceiver;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
pullMainFragment();
}
@Override
public void onResume() {
super.onResume();
// register the result receiver to get the Message Signature back from the server
registerResultReceiver();
}
@Override
public boolean onCreateOptionsMenu(Menu menu) {
// Inflate the menu; this adds items to the action bar if it is present.
getMenuInflater().inflate(R.menu.menu_main, menu);
return true;
}
@Override
public boolean onOptionsItemSelected(MenuItem item) {
// as you specify a parent activity in AndroidManifest.xml.
int id = item.getItemId();
//noinspection SimplifiableIfStatement
if (id == R.id.action_settings) {
return true;
}
return super.onOptionsItemSelected(item);
}
private void pFragment() {
FragmentManager fragmentManager = getSupportFragmentManager();
MainFragment mainFragment = (MainFragment) fragmentManager.findFragmentByTag(TAG_FRAGMENT;
if (mainFragment == null) {
mainFragment = new MainFragment();
fragmentManager.beginTransaction().replace(R.id._checkout_fragment_container, mainFragment, TAG_FRceiver != null)
return;
resultReceiver = new MessageSignatureResultReceiver(new Handler());
resultReceiver.setReceiver(this);
}
@Override
public void onReceiveResult(int resultCode, Bundle resultData) {
}
//sult to OnActivityResult defined in the fragments attached to the Activity
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
for (Fragment fragment : getSupportFragmentManager().getFragments()) {
fragment.onActivityResult(requestCode, resultCode, data);
}
}
}
```
<Overlap Ratio: 0.9495478343645883>

---

--- 117 --
Question ID: daa82ec1a1715de64f51cea5d80e4c9ce1e34fa7
Original Code:
```
@RunWith(Parameterized.class)
public class LabelTest {

    @Parameter()
    public String testName;

    @Parameter(1)
    public LabelerFactory labelerFactory;

    @Rule
    public final ExpectedException exception = ExpectedException.none();

    /**
     * @return A collection of parameter arrays for running tests: <ol> <li>arg[0] is the test name;</li> <li>arg[1] is
     * the {@link LabelerFactory} for the {@link Label} class to be tested.</li></ol>
     */
    @Parameterized.Parameters(name = "{0}")
    public static Collection<Object[]> instancesToTest() {
        return List.of(new Object[] { "IntLabel", new IntLabelerFactory() }, new Object[] { "LongLabel", new LongLabelerFactory() }, new Object[] { "BitSetLabel", new BitSetLabelerFactory() });
    }

    // test that equals() and hashCode() work correctly and agree
    @Test
    public void testEquivalence() {
        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);
        Label firstLabel = labeler.fromBits(0b001);
        Label secondLabel = labeler.fromBits(0b001);
        Label thirdLabel = labeler.fromBits(0b101);
        assertLabelEquals(firstLabel, secondLabel);
        assertLabelEquals(firstLabel, firstLabel);
        assertLabelEquals(secondLabel, secondLabel);
        assertLabelNotEquivalent(firstLabel, thirdLabel);
        assertLabelNotEquivalent(secondLabel, thirdLabel);
    }

    private void assertLabelEquals(Label firstLabel, Label secondLabel) {
        assertEquals(firstLabel, secondLabel);
        assertEquals(secondLabel, firstLabel);
        assertEquals(firstLabel.hashCode(), secondLabel.hashCode());
    }

    private void assertLabelNotEquivalent(Label firstLabel, Label secondLabel) {
        assertNotEquals(firstLabel, secondLabel);
        assertNotEquals(secondLabel, firstLabel);
        // technically not always true, but it's a good test on our small set
        assertTrue(firstLabel.hashCode() != secondLabel.hashCode());
    }

    @Test
    public void testGetCardinality() {
        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);
        Label testLabel = labeler.fromBits(0b001);
        assertEquals(testLabel.getCardinality(), 3);
    }

    @Test
    public void testMatches() {
        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);
        Label testLabel = labeler.fromBits(0b001);
        boolean[] matches = new boolean[] { false, true, true };
        for (int i = 0; i < matches.length; i++) assertEquals(testLabel.matches(i), matches[i]);
        matches = new boolean[] { false, true, false };
        testLabel = labeler.fromBits(0b101);
        for (int i = 0; i < matches.length; i++) assertEquals(testLabel.matches(i), matches[i]);
    }

    @Test
    public void testIntersect() {
        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);
        Label label1 = labeler.fromBits(0b001);
        Label label2 = labeler.fromBits(0b100);
        boolean[] matches = new boolean[] { false, true, false };
        Label intersected = label1.intersect(label2);
        for (int i = 0; i < matches.length; i++) assertEquals(intersected.matches(i), matches[i]);
    }

    @Test
    public void testUnion() {
        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);
        Label label1 = labeler.fromBits(0b001);
        Label label2 = labeler.fromBits(0b100);
        Label intersected = label1.union(label2);
        for (int i = 0; i < intersected.getCardinality(); i++) assertTrue(intersected.matches(i));
    }

    @Test
    public void testAllMatching() {
        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);
        assertTrue("Label composed of all 0's", labeler.fromBits(0b000).allMatching());
        for (int bits : List.of(0b100, 0b001, 0b010, 0b111)) {
            assertFalse("Label with a 1 in it", labeler.fromBits(bits).allMatching());
        }
    }

    @Test
    public void testMatchesThrowsExceptionForIndexTooLow() {
        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);
        Label testLabel = labeler.fromBits(0b001);
        exception.expect(IllegalArgumentException.class);
        exception.expectMessage(new StringContains("Illegal index"));
        testLabel.matches(-10);
    }

    @Test
    public void testMatchesThrowsExceptionForIndexTooHigh() {
        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);
        Label testLabel = labeler.fromBits(0b001);
        exception.expect(IllegalArgumentException.class);
        exception.expectMessage(new StringContains("Illegal index"));
        testLabel.matches(3);
    }

    // For now, it's fine.
    @Test
    public void testDescendantIterator() {
        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);
        Label label = labeler.fromBits(0b100);
        Set<Label> expectedLabels = new HashSet<>(Arrays.asList(labeler.fromBits(0b101), labeler.fromBits(0b111), labeler.fromBits(0b110)));
        Set<Label> actualLabels = new HashSet<>();
        Iterator<Label> si = label.descendantIterator();
        for (; si.hasNext(); ) actualLabels.add(si.next());
        assertEquals(expectedLabels, actualLabels);
        // V , U , V , O , 0 , ? , 0 , ? , L , E , A
        labeler = labelerFactory.createLabeler(mockInstance(10), false, VARIABLE);
        label = labeler.fromBits(0b0101001111);
        expectedLabels = new HashSet<>(Arrays.asList(labeler.fromBits(0b0101011111), labeler.fromBits(0b0101111111), labeler.fromBits(0b0101101111), labeler.fromBits(0b0111101111), labeler.fromBits(0b0111111111), labeler.fromBits(0b0111011111), labeler.fromBits(0b0111001111), labeler.fromBits(0b1111001111), labeler.fromBits(0b1111011111), labeler.fromBits(0b1111111111), labeler.fromBits(0b1111101111), labeler.fromBits(0b1101101111), labeler.fromBits(0b1101111111), labeler.fromBits(0b1101011111), labeler.fromBits(0b1101001111)));
        actualLabels = new HashSet<>();
        si = label.descendantIterator();
        for (; si.hasNext(); ) actualLabels.add(si.next());
        assertEquals(expectedLabels, actualLabels);
    }

    @Test
    public void testIsDescendantOf() {
        Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);
        Label parentLabel = labeler.fromBits(0b100);
        Label descendantLabel = labeler.fromBits(0b101);
        assertTrue(descendantLabel.isDescendantOf(parentLabel));
        Label nonDescendantLabel = labeler.fromBits(0b001);
        assertFalse(nonDescendantLabel.isDescendantOf(parentLabel));
    }

    @Test
    public void testToString() {
        int labelBits = 0b1010101000111;
        Labeler labeler = labelerFactory.createLabeler(mockInstance(13), false, MATCH);
        Label label = labeler.fromBits(labelBits);
        assertEquals("toString of label with elements", Integer.toString(labelBits, 2), label.toString());
    }

    @Test
    public void testToStringAllZeroes() {
        Labeler labeler = labelerFactory.createLabeler(mockInstance(13), false, MATCH);
        Label label = labeler.fromBits(0);
        assertEquals("0000000000000", label.toString());
    }

    // It seems like a dumb case to handle, but Weka's classifier test actually exercises this case
    @Test
    public void testToStringNoAttributes() {
        Labeler labeler = labelerFactory.createLabeler(mockInstance(0), false, MATCH);
        Label label = labeler.fromBits(0);
        assertEquals("", label.toString());
    }
}

```


Overlapping Code:
```
ith(Parameterized.class)
public class LabelTest {
@Parameter()
public String testName;
@Parameter(1)
public LabelerFactory labelerFactory;
@Rule
public final ExpectedException exception = ExpectedException.none();
/**
* @return A collection of parameter arrays for running tests: <ol> <li>arg[0] is the test name;</li> <li>arg[1] is
* the {@link LabelerFactory} for the {@link Label} class to be tested.</li></ol>
*/
@Parameterized.Parameters(name = "{0}")
public static Collection<Object[]> instancesToTest() {
return List.of( test that equals() and hashCode() work correctly and agree
@Test
public void testEquivalence() {
Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);
Label firstLabel = labeler.fromBits(0b001);
Label secondLabel = labeler.fromBits(0b001);
Label thirdLabel = labeler.fromBits(0b101);
assertLabelEquals(firstLabel, secondLabel);
assertLabelEquals(firstLabel, firstLabel);
assertLabelEquals(secondLabel, secondLabel);
assertLabelNotEquivalent(firstLabel, thirdLabel);
assertLabelNotEquivalent(secondLabel, thirdLabel);
}
private void assertLabelEquals(Label firstLabel, Label secondLabel) {
assertEquals(firstLabel, secondLabel);
assertEquals(secondLabel, firstLabel);
assertEquals(firstLabel.hashCode(), secondLabel.hashCode());
}
private void assertLabelNotEquivalent(Label firstLabel, Label secondLabel) {
assertNotEquals(firstLabel, secondLabel);
assertNotEquals(secondLabel, firstLabel);
// technically not always true, but it's a good test on our small set
assertTrue(firstLabel.hashCode() != secondLabel.hashCode());
}
@Test
public void testGetCardinality() {
Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);
Label testLabel = labeler.fromBits(0b001);
assertEquals(testLabel.getCardinality(), 3);
}
@Test
public void testMatches() {
Labeler labeler = labelerFactory.createLabeler(mockInstance(3), false, MATCH);
Label testLabel = labeler.from
```
<Overlap Ratio: 0.8812785388127854>

---

--- 118 --
Question ID: 1fedf96a0bc0d600ebdfb70a4efcf6a14a3fed03
Original Code:
```
public class VoteCounter {

    //Parameter: The number of candidates that can win
    static int numberOfWinners;

    //The percentage of votes that is needed to guarantee a win for a candidate
    static double voteThresholdPercent;

    //A counter for the total number of candidates
    static int numberOfCandidates = 0;

    //the total number of votes being counted
    static int numberOfVotes = 0;

    //the number of votes needed to guarantee a win
    static double voteThreshold = 0.0;

    //A list of the candidates which have won
    static ArrayList<String> winningCandidates = new ArrayList<>();

    //A list of the candidates which have been eliminated
    static ArrayList<String> eliminatedCandidates = new ArrayList<>();

    //A list of the original, unaltered Votes. Needed for the tie breaker
    static ArrayList<Vote> originalVotes = new ArrayList<Vote>();

    //A list of the votes that are redistributed
    static ArrayList<Vote> votes = new ArrayList<Vote>();

    //A list of the working vote counts
    static HashMap<String, Double> currentVoteCounts = new HashMap<>();

    static int roundCounter = 1;

    /**
     * The main method. See class docs for description on required arguments
     *
     * @param args - String[]
     */
    public static void main(String[] args) {
        //If there was 1 argument, check if it was help and print how to if it was
        if (args.length == 1 && args[0].equals("help")) {
            //TODO provide how to output
            return;
        }
        //Quit if the three arguments were not supplied
        if (args.length != 3) {
            System.out.println("Please provide all 3 arguments. Run 'VoteCounter help' for more information.");
            return;
        }
        //Parse the input files
        if (!parseCandidates(args[0])) {
            //If parseCandidates returns false, then it failed to work correctly and the program should terminate
            return;
        }
        if (!parseVotes(args[1])) {
            //if parseVotes returns false, then it failed to work correctly and the program should terminate
            return;
        }
        //Try to get the number of voters
        try {
            numberOfWinners = Integer.parseInt(args[2]);
            if (numberOfWinners < 1 || numberOfWinners > currentVoteCounts.keySet().size()) {
                System.out.println("The number of winners must be at least 1 and no more than the number of candidates");
                return;
            }
        } catch (NumberFormatException e) {
            //Not a valid number, so print error to the user and return
            System.out.println("Invalid winner count argument. ");
            return;
        }
        //calculate the vote thresholds
        voteThresholdPercent = 1.0 / (numberOfWinners + 1);
        voteThreshold = numberOfVotes * voteThresholdPercent;
        //perform the initial count of the votes
        countVotes();
        //Analyze the votes, redistributing as needed, until enough winners have been found
        do {
            analyzeVotes();
        } while (winningCandidates.size() < numberOfWinners);
        //Print the final winners
        System.out.println();
        System.out.println("Winners:");
        System.out.println(String.join(", ", winningCandidates));
    }

    /**
     * Parse the candidate file and initialize {@code numberOfCandidates} and {@code currentVoteCounts}
     *
     * @param candidateFileName - String - the name of the candidate file
     * @return boolean - true if successful, false if not successful
     */
    private static boolean parseCandidates(String candidateFileName) {
        BufferedReader candidateReader = null;
        try {
            //try to open the file for reading
            candidateReader = new BufferedReader(new FileReader(candidateFileName));
            String candidate = null;
            //Loop through each line and store the candidate and increase the candidate count
            while ((candidate = candidateReader.readLine()) != null) {
                currentVoteCounts.put(candidate.trim(), 0.0);
                numberOfCandidates += 1;
            }
        } catch (FileNotFoundException e) {
            //The file was not found, so print the error message and quit
            System.out.println("Unable to open the candidate file. Please ensure the provided file path is correct.");
            return false;
        } catch (IOException e) {
            //Something went wrong reading the file, so print the error message and quit
            System.out.println("An error occured while reading the candidate file:" + e.getMessage());
            return false;
        } finally {
            //Close the candidateReader after everything, if it exists
            if (candidateReader != null) {
                try {
                    candidateReader.close();
                } catch (IOException e) {
                    System.out.println("An error occured while closing the candidate file:\n" + e.getMessage());
                }
            }
        }
        return true;
    }

    /**
     * Parse the vote file and construct all {@link Vote} objects
     *
     * @param voteFileName - String - The file name of the vote file
     * @return boolean - true if successful, false if not successful
     */
    private static boolean parseVotes(String voteFileName) {
        BufferedReader voteReader = null;
        try {
            //attempt to open the vote file
            voteReader = new BufferedReader(new FileReader(voteFileName));
            String line = null;
            voteReader.readLine();
            //parse the line of the csv file and use it to create a Vote object
            while ((line = voteReader.readLine()) != null) {
                String[] inputRow = line.split(",");
                //store the vote as needed and count the total number of votes
                votes.add(new Vote(inputRow));
                originalVotes.add(new Vote(inputRow));
                numberOfVotes++;
            }
        } catch (FileNotFoundException e) {
            //File was not found, so return
            System.out.println("Unable to open the vote file. Please ensure the provided file path is correct.");
            return false;
        } catch (IOException e) {
            //Failure to read file correctly, so return
            System.out.println("An error occured while reading the vote file:" + e.getMessage());
            return false;
        } finally {
            //Close the buffered reader when finished
            if (voteReader != null) {
                try {
                    voteReader.close();
                } catch (IOException e) {
                    System.out.println("An error occured while closing the vote file:\n" + e.getMessage());
                }
            }
        }
        return true;
    }

    /**
     * Analyzes the current vote counts, determining a winner or loser for the round, and the redistributes votes as needed
     */
    private static void analyzeVotes() {
        //Print the start of round text and current vote counts
        System.out.println();
        System.out.println("Round " + roundCounter++ + " vote counts:");
        for (Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {
            System.out.print(entry.getKey() + ": " + entry.getValue() + " | ");
        }
        System.out.println();
        //If the number of candidates left equals the number of winners, mark them all winners and end
        if (currentVoteCounts.size() == numberOfWinners) {
            for (Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {
                if (!winningCandidates.contains(entry.getKey())) {
                    winningCandidates.add(entry.getKey());
                    System.out.println(entry.getKey() + " has won in the last round.");
                }
            }
            return;
        }
        boolean noWinnerFound = true;
        //create an arrayList that holds the factions with the least number of votes and track the current minimum vote total
        ArrayList<String> minCandidatess = new ArrayList<>();
        double minCount = Double.MAX_VALUE;
        //The entry key is the candidate name and entry value is the vote count
        for (Map.Entry<String, Double> entry : currentVoteCounts.entrySet()) {
            //If the candidate has already won, do not count their votes
            if (!winningCandidates.contains(entry.getKey())) {
                //Check if the vote count for this candidate has exceeded the winning threshold
                if (entry.getValue().compareTo(voteThreshold) > 0) {
                    //Mark that a winner was found
                    noWinnerFound = false;
                    //a weight for all votes from this winner as they are redistributed.
                    double redistributeAmount = Double.sum(entry.getValue(), voteThreshold * -1.0) / numberOfVotes;
                    //redistribute the votes of the winner using the calculated redistribution amount
                    redistributeVotes(entry.getKey(), redistributeAmount);
                    //Add the winner to the list of winners and print that they have won
                    winningCandidates.add(entry.getKey());
                    System.out.println(entry.getKey() + " has won with " + entry.getValue() + " votes.");
                    //Exit the loop
                    break;
                }
            }
            if (entry.getValue().compareTo(minCount) < 0) {
                //Store this count as the new minimum
                minCount = entry.getValue();
                //remove all current candidates from the minimum count list
                minCandidatess.clear();
                //and add this candidate to the list
                minCandidatess.add(entry.getKey());
            } else if (entry.getValue().compareTo(minCount) == 0) {
                minCandidatess.add(entry.getKey());
            }
        }
        //Since no one won, a loser must be eliminated
        if (noWinnerFound) {
            //If 2 or more are tied for the lowest, run a tie breaker and eliminate the loser
            if (minCandidatess.size() == 1) {
                eliminateCandidate(minCandidatess.get(0));
            } else {
                eliminateCandidate(condorcetTieBreak(minCandidatess));
            }
        }
    }

    /**
     * Perform a condorcet tie break for all factions in the factions list
     * @param candidates - {@code ArrayList<String>} - The list of candidates to check in the tie breaker
     *
     * @return - String - the name of the candidate that lost the tie breaker
     */
    private static String condorcetTieBreak(ArrayList<String> candidates) {
        //Output that a tie braker is occuring between the candidates
        System.out.println("Breaking last place tie between: " + String.join(", ", candidates));
        //create the master matrix that counts the number of times one candidate beats another candidate
        int[][] masterMatrix = new int[candidates.size()][candidates.size()];
        //generate a matrix for each vote and add it to the master
        for (Vote vote : originalVotes) {
            masterMatrix = matrixAddition(masterMatrix, vote.generateMatrix(candidates));
        }
        // Create a win matrix which marks if one candidate beats another candidate more in the master matrix
        int[][] winMatrix = new int[candidates.size()][candidates.size()];
        // Create a matrix that stores the magnitude of victories in the win matrix
        int[][] magnitudeMatrix = new int[candidates.size()][candidates.size()];
        int x = 0;
        while (x < masterMatrix.length) try {
            int y = 0;
            while (y < masterMatrix[0].length) try {
                // Only 1 half of the matrix is cared about, so skip it if x < y
                if (y > x) {
                    if (masterMatrix[x][y] > masterMatrix[y][x]) {
                        //If x beat y more than y beat x, mark that x beats y overall in the win matrix
                        winMatrix[x][y] = 1;
                        //The winner will have a positive value while the lose will have a negative value
                        magnitudeMatrix[x][y] = masterMatrix[x][y] - masterMatrix[y][x];
                        magnitudeMatrix[y][x] = masterMatrix[y][x] - masterMatrix[x][y];
                    } else if (masterMatrix[x][y] < masterMatrix[y][x]) {
                        //The same thing as above but if Y won
                        winMatrix[y][x] = 1;
                        magnitudeMatrix[y][x] = masterMatrix[y][x] - masterMatrix[x][y];
                        magnitudeMatrix[x][y] = masterMatrix[x][y] - masterMatrix[y][x];
                    }
                }
            } finally {
                y++;
            }
        } finally {
            x++;
        }
        //Create a variable to store the currently lowest win count
        int minWins = Integer.MAX_VALUE;
        //and a list to store the people with the lowest win count
        ArrayList<Integer> winIndecies = new ArrayList<>();
        int i = 0;
        while (i < candidates.size()) try {
            //determine that candidates win number by summing their row in the matrix
            int currWins = matrixRowSum(winMatrix, i);
            if (currWins < minWins) {
                //If this candidate has less wins than the current lowest, reset the list and mark this candidate the loser
                minWins = currWins;
                winIndecies.clear();
                winIndecies.add(i);
            } else if (currWins == minWins) {
                //If this candidate has the same number of wins as the lowest, add their index to the list
                winIndecies.add(i);
            }
        } finally {
            i++;
        }
        //If there is someone worse than everyone else, then they lose
        if (winIndecies.size() == 1) {
            return candidates.get(winIndecies.get(0));
        } else {
            //If multiple people share the worst win number, magnitude is taken into account
            int minMagnitude = Integer.MAX_VALUE;
            ArrayList<Integer> worstIndecies = new ArrayList<>();
            //Sum the row of the magnitude matrix for each of the worst candidates
            for (Integer rowNum : winIndecies) {
                int currMag = matrixRowSum(magnitudeMatrix, rowNum);
                //Keep track of those candidate with the worst magnitude of wins against all opponents in the tie breaker
                if (currMag < minMagnitude) {
                    minMagnitude = currMag;
                    worstIndecies.clear();
                    worstIndecies.add(rowNum);
                } else if (currMag == minMagnitude) {
                    worstIndecies.add(rowNum);
                }
            }
            //If one is the worst by magnitue, eliminate them
            if (worstIndecies.size() == 1) {
                return candidates.get(worstIndecies.get(0));
            } else {
                //If win number and magnitude did not break the tie, then we look at the original votes for each candidate
                ArrayList<Integer> lowPointIndecies = new ArrayList<>();
                //Points are given for the ranking of a candidate on a ballot, with a higher ranked choice getting more points
                int lowPoint = Integer.MAX_VALUE;
                //Loop through the candidates that are stilled tied
                for (Integer i : worstIndecies) {
                    int totalPoints = 0;
                    //get the points for that candidate from each vote
                    for (Vote vote : originalVotes) {
                        totalPoints += vote.getPoints(candidates.get(i));
                    }
                    //Keep track of the candidates with the worst votes
                    if (totalPoints < lowPoint) {
                        lowPoint = totalPoints;
                        lowPointIndecies.clear();
                        lowPointIndecies.add(i);
                    } else if (totalPoints == lowPoint) {
                        lowPointIndecies.add(i);
                    }
                }
                //If there is one that is worst, eliminate them
                if (lowPointIndecies.size() == 1) {
                    return candidates.get(lowPointIndecies.get(0));
                } else {
                    //If there is still a tie, it is broken randomly
                    Random rand = new Random();
                    int returnIndex = rand.nextInt(lowPointIndecies.size());
                    return candidates.get(lowPointIndecies.get(returnIndex));
                }
            }
        }
    }

    /**
     * Calculate the sum of a row (1st index) in a matrix
     *
     * @param matrix The matrix to operate on
     * @param row the index of the row to sum
     * @return int the sum of the row
     */
    private static int matrixRowSum(int[][] matrix, int row) {
        int sum = 0;
        int y = 0;
        while (y < matrix[0].length) try {
            sum += matrix[row][y];
        } finally {
            y++;
        }
        return sum;
    }

    /**
     * Add two matrices together
     *
     * @param a the first matrix to add
     * @param b the second matrix to add
     * @return int[][] the matrix creating by adding a and b
     */
    private static int[][] matrixAddition(int[][] a, int[][] b) {
        //get the row and column count for the size of the new matrix
        int rows = a.length;
        int columns = a[0].length;
        //create the matrix
        int[][] c = new int[rows][columns];
        int i = 0;
        while (i < rows) try {
            int j = 0;
            while (j < columns) try {
                c[i][j] = a[i][j] + b[i][j];
            } finally {
                j++;
            }
        } finally {
            i++;
        }
        return c;
    }

    /**
     * Perform the initial count of the votes
     */
    private static void countVotes() {
        for (Vote vote : votes) {
            if (!vote.getChoices().isEmpty()) {
                //ensure that the current choice has been reset
                vote.resetCurrentChoice();
                String currFaction = vote.getChoice();
                double newCount = currentVoteCounts.get(currFaction) + vote.getWeight();
                currentVoteCounts.put(currFaction, newCount);
            }
        }
    }

    /**
     * Eliminates the specified candidate and redistributes every vote that currently is counting for that candidate with a weight of 1.0
     *
     * @param candidate The candidate to eliminate
     */
    private static void eliminateCandidate(String candidate) {
        redistributeVotes(candidate, 1.0);
        //remove the candidate from the vote counts.
        System.out.println(candidate + " has been eliminated with " + currentVoteCounts.get(candidate) + " votes.");
        currentVoteCounts.remove(candidate);
    }

    /**
     * Redistribute votes from a candidate to that vote's next candidate with a specified weight
     *
     * @param candidate The candidate to redistribute votes from
     * @param redistributeAmount The weight of the redistributed votes
     */
    private static void redistributeVotes(String candidate, double redistributeAmount) {
        for (Vote vote : votes) {
            //skip the vote if it has no valid candidate choices remaining
            if (vote.getChoices().isEmpty()) {
                continue;
            }
            //If the vote is currently counting for the candidate to redistribute from
            if (vote.getChoice().compareTo(candidate) == 0) {
                //If the vote has another valid choice
                if (vote.getChoices().size() > vote.getCurrentChoice() + 1) {
                    //Set the vote to the next candidate and count the vote for that candidate
                    vote.alterWeight(redistributeAmount);
                    vote.incrementCurrentChoice();
                    String newCandidate = vote.getChoice();
                    double newCount = Double.sum(currentVoteCounts.get(newCandidate), vote.getWeight());
                    currentVoteCounts.put(newCandidate, newCount);
                }
            }
        }
        for (Vote vote : votes) {
            vote.eliminateRanking(candidate);
        }
    }
}

```


Overlapping Code:
```
umber of candidates that can win
static int numberOfWinners;
//The percentage of votes that is needed to guarantee a win for a candidate
static double voteThresholdPercent;
//A counter for the total number of candidates
static int numberOfCandidates = 0;
//the total number of votes being counted
static int numberOfVotes = 0;
//the number of votes needed to guarantee a win
static double voteThreshold = 0.0;
//A list of the candidates which have won
static ArrayList<String> winningCandidates = new ArrayList<>();
//A list of the candidates which have been eliminated
static ArrayList<String> eliminatedCandidates = new ArrayList<>();
//A list of the original, unaltered Votes. Needed for the tie breaker
static ArrayList<Vote> originalVotes = new ArrayList<Vote>();
//A list of the votes that are redistributed
static ArrayList<Vote> votes = new ArrayList<Vote>();
//A list of the working vote counts
static HashMap<String, Double> currentVoteCounts = new HashMap<>();
static int roundCounter = 1;*
* @param args - String[]
*/
public static void main(String[] args) {
//If there was 1 argument, check if it was help angs[0].equals("help")) {
//TODO provide how to outpf (args.length != 3) {
System.out.println("Please provide all 3 arguments. Run 'VoteCoun{
//If parseCandidates returns false, then it failed to work correctly and the program should termineVotes returns false, then it failed to work correctly and the program should termin/Try to get the number of voters
try {
numberOfWiners < 1 || numberOfWinners > currentVoteCounts.keySet().size()) {
System.out.println("The number of winners must be at least 1 and no more than the nu
```
<Overlap Ratio: 0.7753657385559226>

---

--- 119 --
Question ID: 2e0431d1a4cadc7c4b4e0c230f216ea1e08fe83d
Original Code:
```
public class Library {

    // roll a dice n times and return an array of rolls
    public static int[] roll(int n) {
        int[] rollArray = new int[n];
        int i = 0;
        while (i < rollArray.length) try {
            rollArray[i] = (int) (Math.random() * 6) + 1;
        } finally {
            i++;
        }
        return rollArray;
    }

    public static boolean containsDuplicates(int[] array) {
    }

    // calculate the average of an array
    public static float calculatingAverages(int[] inputArray) {
        int sum = 0;
        int i = 0;
        while (i < inputArray.length) try {
            sum += inputArray[i];
        } finally {
            i++;
        }
        float average = (float) sum / inputArray.length;
        return average;
    }

    // take in a 2d array and return the array with the lowest average
    public static int[] arrayOfArrays(int[][] inputArray) {
        int[] outputArray = new int[inputArray[0].length];
        float[] averagedArray = new float[inputArray.length];
        System.out.println(inputArray.length);
        int i = 0;
        while (i < inputArray.length) try {
            averagedArray[i] = calculatingAverages(inputArray[i]);
        } finally {
            i++;
        }
        float lowest = 9999;
        int i = 0;
        while (i < averagedArray.length) try {
            if (averagedArray[i] < lowest) {
                lowest = averagedArray[i];
                int j = 0;
                while (j < inputArray[0].length) try {
                    outputArray[j] = inputArray[i][j];
                } finally {
                    j++;
                }
            }
        } finally {
            i++;
        }
        return outputArray;
    }
}

```


Overlapping Code:
```
 return an array of rolls
public static int[] roll(int n) {
int[] rollArray =rollArray;
}
public static boolean containsDuplicates(int[] arerage;
}
// take in a 2d array and return the arra
```
<Overlap Ratio: 0.15>

---

--- 120 --
Question ID: 76e896093e16ee748c72b09602331499e4880900
Original Code:
```
public final class ClassTools {

    public static final Class[] ZERO_PARAMETER_TYPES = new Class[0];

    public static final Object[] ZERO_PARAMETERS = new Object[0];

    private static final String CR = StringTools.CR;

    public static final char NESTED_CLASS_NAME_SEPARATOR = '$';

    public static final char ARRAY_INDICATOR = '[';

    public static final char REFERENCE_CLASS_CODE = 'L';

    public static final char REFERENCE_CLASS_NAME_DELIMITER = ';';

    private static PrimitiveClassCode[] primitiveClassCodes;

    public static final char BYTE_CODE = 'B';

    public static final char CHAR_CODE = 'C';

    public static final char DOUBLE_CODE = 'D';

    public static final char FLOAT_CODE = 'F';

    public static final char INT_CODE = 'I';

    public static final char LONG_CODE = 'J';

    public static final char SHORT_CODE = 'S';

    public static final char BOOLEAN_CODE = 'Z';

    public static final char VOID_CODE = 'V';

    /**
     * Return all the fields for the
     * specified class, including inherited fields.
     * Class#allFields()
     */
    public static Field[] allFields(Class javaClass) {
        Stack stack = new Stack();
        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {
            pushDeclaredFields(tempClass, stack);
        }
        Collections.reverse(stack);
        return (Field[]) stack.toArray(new Field[stack.size()]);
    }

    /**
     * Return all the methods for the
     * specified class, including inherited methods.
     * Class#allMethods()
     */
    public static Method[] allMethods(Class javaClass) {
        Stack stack = new Stack();
        for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {
            pushDeclaredMethods(tempClass, stack);
        }
        Collections.reverse(stack);
        return (Method[]) stack.toArray(new Method[stack.size()]);
    }

    /**
     * Convenience method.
     * Return a new instance of the specified class,
     * using the class's default (zero-argument) constructor.
     * Throw an exception if the default constructor is not defined.
     * Class#newInstance() throws NoSuchMethodException
     */
    public static Object attemptNewInstance(Class javaClass) throws NoSuchMethodException {
        return attemptNewInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);
    }

    /**
     * Return a new instance of the specified class,
     * given the constructor parameter types and parameters.
     * Throw an exception if the constructor is not defined.
     * Class#newInstance(Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException
     */
    public static Object attemptNewInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {
        try {
            return constructor(javaClass, parameterTypes).newInstance(parameters);
        } catch (InstantiationException ie) {
            throw new RuntimeException(ie + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), ie);
        } catch (IllegalAccessException iae) {
            throw new RuntimeException(iae + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), iae);
        } catch (InvocationTargetException ite) {
            throw new RuntimeException(fullyQualifiedConstructorSignature(javaClass, parameterTypes) + CR + ite.getTargetException(), ite);
        }
    }

    /**
     * Convenience method.
     * Return a new instance of the specified class,
     * given the constructor parameter type and parameter.
     * Throw an exception if the constructor is not defined.
     * Class#newInstance(Class parameterType, Object parameter) throws NoSuchMethodException
     */
    public static Object attemptNewInstance(Class javaClass, Class parameterType, Object parameter) throws NoSuchMethodException {
        return attemptNewInstance(javaClass, new Class[] { parameterType }, new Object[] { parameter });
    }

    /**
     * Attempt to get a field value, given the containing object and field name.
     * Return its result.
     * Useful for accessing private, package, or protected fields.
     * Throw an exception if the field is not defined.
     * Object#getFieldValue(String fieldName) throws NoSuchFieldException
     */
    public static Object attemptToGetFieldValue(Object object, String fieldName) throws NoSuchFieldException {
        try {
            return field(object, fieldName).get(object);
        } catch (IllegalAccessException iae) {
            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);
        }
    }

    /**
     * Attempt to get a static field value, given the containing object and field name.
     * Return its result.
     * Useful for accessing private, package, or protected fields.
     * Throw an exception if the field is not defined.
     * Class#getStaticFieldValue(String fieldName) throws NoSuchFieldException
     */
    public static Object attemptToGetStaticFieldValue(Class javaClass, String fieldName) throws NoSuchFieldException {
        try {
            return field(javaClass, fieldName).get(null);
        } catch (IllegalAccessException iae) {
            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);
        }
    }

    /**
     * Convenience method.
     * Attempt to invoke a zero-argument method,
     * given the receiver and method name.
     * Return its result.
     * Throw an exception if the method is not found.
     * Useful for invoking private, package, or protected methods.
     * Object#invoke(String methodName) throws NoSuchMethodException
     */
    public static Object attemptToInvokeMethod(Object receiver, String methodName) throws NoSuchMethodException {
        return attemptToInvokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);
    }

    /**
     * Convenience method.
     * Attempt to invoke a method, given the receiver,
     * method name, parameter type, and parameter.
     * Return its result.
     * Throw an exception if the method is not found.
     * Useful for invoking private, package, or protected methods.
     * Object#invoke(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException
     */
    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {
        return attemptToInvokeMethod(receiver, methodName, new Class[] { parameterType }, new Object[] { parameter });
    }

    /**
     * Attempt to invoke a method, given the receiver,
     * method name, parameter types, and parameters.
     * Return its result.
     * Throw an exception if the method is not found.
     * Useful for invoking private, package, or protected methods.
     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException
     */
    public static Object attemptToInvokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {
        return invokeMethod(method(receiver, methodName, parameterTypes), receiver, parameters);
    }

    /**
     * Attempt to invoke a method, given the receiver,
     * method name, parameter types, and parameters.
     * Return its result.
     * Throw an exception if the method is not found.
     * If the invoked method throws an exception, rethrow that exception.
     * Useful for invoking private, package, or protected methods.
     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException
     */
    public static Object attemptToInvokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) throws Throwable, NoSuchMethodException {
        return invokeMethodWithException(method(receiver, methodName, parameterTypes), receiver, parameters);
    }

    /**
     * Convenience method.
     * Attempt to invoke a zero-argument static method,
     * given the class and method name.
     * Return its result.
     * Throw an exception if the method is not found.
     * Useful for invoking private, package, or protected methods.
     * Class#invokeStaticMethod(String methodName) throws NoSuchMethodException
     */
    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName) throws NoSuchMethodException {
        return attemptToInvokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);
    }

    /**
     * Attempt to invoke a static method, given the class,
     * method name, parameter types, and parameters.
     * Return its result.
     * Throw an exception if the method is not found.
     * Useful for invoking private, package, or protected methods.
     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException
     */
    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) throws NoSuchMethodException {
        return invokeStaticMethod(staticMethod(javaClass, methodName, parameterTypes), parameters);
    }

    /**
     * Convenience method.
     * Attempt to invoke a static method, given the class,
     * method name, parameter type, and parameter.
     * Return its result.
     * Throw an exception if the method is not found.
     * Useful for invoking private, package, or protected methods.
     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter) throws NoSuchMethodException
     */
    public static Object attemptToInvokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) throws NoSuchMethodException {
        return attemptToInvokeStaticMethod(javaClass, methodName, new Class[] { parameterType }, new Object[] { parameter });
    }

    /**
     * Attempt to set a field value, given the
     * containing object, field name, and new field value.
     * Useful for accessing private, package, or protected fields.
     * Throw an exception if the field is not defined.
     * Object#setFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException
     */
    public static void attemptToSetFieldValue(Object object, String fieldName, Object fieldValue) throws NoSuchFieldException {
        try {
            field(object, fieldName).set(object, fieldValue);
        } catch (IllegalAccessException iae) {
            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(object, fieldName), iae);
        }
    }

    /**
     * Attempt to set a static field value, given the
     * containing class, field name, and new field value.
     * Useful for accessing private, package, or protected fields.
     * Throw an exception if the field is not defined.
     * Class#setStaticFieldValue(String fieldName, Object fieldValue) throws NoSuchFieldException
     */
    public static void attemptToSetStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) throws NoSuchFieldException {
        try {
            field(javaClass, fieldName).set(null, fieldValue);
        } catch (IllegalAccessException iae) {
            throw new RuntimeException(iae + CR + fullyQualifiedFieldName(javaClass, fieldName), iae);
        }
    }

    /**
     * Convenience method.
     * Return the default (zero-argument) constructor
     * for the specified class.
     * Set accessible to true, so we can access
     * private/package/protected constructors.
     * Class#constructor() throws NoSuchMethodException
     */
    public static Constructor constructor(Class javaClass) throws NoSuchMethodException {
        return constructor(javaClass, ZERO_PARAMETER_TYPES);
    }

    /**
     * Return the constructor for the specified class
     * and formal parameter types.
     * Set accessible to true, so we can access
     * private/package/protected constructors.
     * Class#constructor(Class[] parameterTypes) throws NoSuchMethodException
     */
    public static Constructor constructor(Class javaClass, Class[] parameterTypes) throws NoSuchMethodException {
        Constructor constructor = javaClass.getDeclaredConstructor(parameterTypes);
        constructor.setAccessible(true);
        return constructor;
    }

    /**
     * Convenience method.
     * Return the constructor for the specified class
     * and formal parameter type.
     * Set accessible to true, so we can access
     * private/package/protected constructors.
     * Class#constructor(Class parameterType) throws NoSuchMethodException
     */
    public static Constructor constructor(Class javaClass, Class parameterType) throws NoSuchMethodException {
        return constructor(javaClass, new Class[] { parameterType });
    }

    /**
     * Return the declared fields for the specified class.
     * Set accessible to true, so we can access
     * private/package/protected fields.
     * Class#accessibleDeclaredFields()
     */
    public static Field[] declaredFields(Class javaClass) {
        Field[] fields = javaClass.getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
        return fields;
    }

    /**
     * Return the declared methods for the
     * specified class.
     * Set accessible to true, so we can access
     * private/package/protected methods.
     * Class#accessibleDeclaredMethods()
     */
    public static Method[] declaredMethods(Class javaClass) {
        Method[] methods = javaClass.getDeclaredMethods();
        for (int i = 0; i < methods.length; i++) {
            methods[i].setAccessible(true);
        }
        return methods;
    }

    /**
     * Return the default (zero-argument) constructor
     * for the specified class.
     * Set accessible to true, so we can access
     * private/package/protected constructors.
     * Class#defaultConstructor()
     */
    public static Constructor defaultConstructor(Class javaClass) throws NoSuchMethodException {
        return constructor(javaClass);
    }

    /**
     * Return a field for the specified class and field name.
     * If the class does not directly
     * define the field, look for it in the class's superclasses.
     * Set accessible to true, so we can access
     * private/package/protected fields.
     */
    public static Field field(Class javaClass, String fieldName) throws NoSuchFieldException {
        Field field = null;
        try {
            field = javaClass.getDeclaredField(fieldName);
        } catch (NoSuchFieldException ex) {
            Class superclass = javaClass.getSuperclass();
            if (superclass == null) {
                throw ex;
            }
            // recurse
            return field(superclass, fieldName);
        }
        field.setAccessible(true);
        return field;
    }

    /**
     * Convenience method.
     * Return a field for the specified object and field name.
     * If the object's class does not directly
     * define the field, look for it in the class's superclasses.
     * Set accessible to true, so we can access
     * private/package/protected fields.
     */
    public static Field field(Object object, String fieldName) throws NoSuchFieldException {
        return field(object.getClass(), fieldName);
    }

    /**
     * Return a string representation of the specified constructor.
     */
    private static String fullyQualifiedConstructorSignature(Class javaClass, Class[] parameterTypes) {
        return fullyQualifiedMethodSignature(javaClass, null, parameterTypes);
    }

    /**
     * Return a string representation of the specified field.
     */
    private static String fullyQualifiedFieldName(Class javaClass, String fieldName) {
        StringBuffer sb = new StringBuffer(200);
        sb.append(javaClass.getName());
        sb.append('.');
        sb.append(fieldName);
        return sb.toString();
    }

    /**
     * Return a string representation of the specified field.
     */
    private static String fullyQualifiedFieldName(Object object, String fieldName) {
        return fullyQualifiedFieldName(object.getClass(), fieldName);
    }

    /**
     * Return a string representation of the specified method.
     */
    private static String fullyQualifiedMethodSignature(Class javaClass, String methodName, Class[] parameterTypes) {
        StringBuffer sb = new StringBuffer(200);
        sb.append(javaClass.getName());
        // this check allows us to use this code for constructors, where the methodName is null
        if (methodName != null) {
            sb.append('.');
            sb.append(methodName);
        }
        sb.append('(');
        for (int i = 0; i < parameterTypes.length; i++) {
            sb.append(parameterTypes[i].getName());
            if (i < parameterTypes.length - 1)
                sb.append(", ");
        }
        sb.append(')');
        return sb.toString();
    }

    /**
     * Return a string representation of the specified method.
     */
    private static String fullyQualifiedMethodSignature(Object receiver, String methodName, Class[] parameterTypes) {
        return fullyQualifiedMethodSignature(receiver.getClass(), methodName, parameterTypes);
    }

    /**
     * Get a field value, given the containing object and field name.
     * Return its result.
     * Useful for accessing private, package, or protected fields.
     * Object#getFieldValue(String fieldName)
     */
    public static Object getFieldValue(Object object, String fieldName) {
        try {
            return attemptToGetFieldValue(object, fieldName);
        } catch (NoSuchFieldException nsfe) {
            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);
        }
    }

    /**
     * Get a static field value, given the containing class and field name.
     * Return its result.
     * Useful for accessing private, package, or protected fields.
     * Class#getStaticFieldValue(String fieldName)
     */
    public static Object getStaticFieldValue(Class javaClass, String fieldName) {
        try {
            return attemptToGetStaticFieldValue(javaClass, fieldName);
        } catch (NoSuchFieldException nsfe) {
            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);
        }
    }

    /**
     * Convenience method.
     * Invoke a zero-argument method, given the receiver and method name.
     * Return its result.
     * Useful for invoking private, package, or protected methods.
     * Object#invoke(String methodName)
     */
    public static Object invokeMethod(Object receiver, String methodName) {
        return invokeMethod(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);
    }

    /**
     * Invoke a method, given the receiver,
     * method name, parameter types, and parameters.
     * Return its result.
     * Useful for invoking private, package, or protected methods.
     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)
     */
    public static Object invokeMethod(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) {
        try {
            return attemptToInvokeMethod(receiver, methodName, parameterTypes, parameters);
        } catch (NoSuchMethodException nsme) {
            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);
        }
    }

    /**
     * Convenience method.
     * Invoke a one-argument method, given the receiver,
     * method name, parameter type, and parameter.
     * Return its result.
     * Useful for invoking private, package, or protected methods.
     * Object#invoke(String methodName, Class parameterType, Object parameter)
     */
    public static Object invokeMethod(Object receiver, String methodName, Class parameterType, Object parameter) {
        return invokeMethod(receiver, methodName, new Class[] { parameterType }, new Object[] { parameter });
    }

    /**
     * Convenience method.
     * Invoke a zero-argument method, given the receiver and method name.
     * Return its result.
     * If the method throws an exception, rethrow that exception.
     * Useful for invoking private, package, or protected methods.
     * Object#invoke(String methodName)
     */
    public static Object invokeMethodWithException(Object receiver, String methodName) throws Throwable {
        return invokeMethodWithException(receiver, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);
    }

    /**
     * Convenience method.
     * Invoke a one-argument method, given the receiver,
     * method name, parameter type, and parameter.
     * Return its result.
     * If the method throws an exception, rethrow that exception.
     * Useful for invoking private, package, or protected methods.
     * Object#invoke(String methodName, Class parameterType, Object parameter)
     */
    public static Object invokeMethodWithException(Object receiver, String methodName, Class parameterType, Object parameter) throws Throwable {
        return invokeMethodWithException(receiver, methodName, new Class[] { parameterType }, new Object[] { parameter });
    }

    /**
     * Invoke a method, given the receiver,
     * method name, parameter types, and parameters.
     * Return its result.
     * If the method throws an exception, rethrow that exception.
     * Useful for invoking private, package, or protected methods.
     * Object#invoke(String methodName, Class[] parameterTypes, Object[] parameters)
     */
    public static Object invokeMethodWithException(Object receiver, String methodName, Class[] parameterTypes, Object[] parameters) throws Throwable {
        try {
            return attemptToInvokeMethodWithException(receiver, methodName, parameterTypes, parameters);
        } catch (NoSuchMethodException nsme) {
            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(receiver, methodName, parameterTypes), nsme);
        }
    }

    /**
     * Invoke the specified method with the specified parameters.
     * Return its result.
     * Convert exceptions to RuntimeExceptions.
     */
    public static Object invokeMethod(Method method, Object receiver, Object[] parameters) {
        try {
            return method.invoke(receiver, parameters);
        } catch (IllegalAccessException iae) {
            throw new RuntimeException(iae + CR + method, iae);
        } catch (InvocationTargetException ite) {
            throw new RuntimeException(method + CR + ite.getTargetException(), ite);
        }
    }

    /**
     * Invoke the specified method with the specified parameters.
     * Return its result.
     * If the method throws an exception, rethrow that exception.
     * Convert all other exceptions to RuntimeExceptions.
     */
    public static Object invokeMethodWithException(Method method, Object receiver, Object[] parameters) throws Throwable {
        try {
            return method.invoke(receiver, parameters);
        } catch (IllegalAccessException iae) {
            throw new RuntimeException(iae + CR + method, iae);
        } catch (InvocationTargetException ite) {
            Throwable cause = ite.getCause();
            if (cause == null) {
                throw new RuntimeException(method.toString(), ite);
            }
            throw cause;
        }
    }

    /**
     * Convenience method.
     * Invoke a zero-argument static method,
     * given the class and method name.
     * Return its result.
     * Useful for invoking private, package, or protected methods.
     * Class#invokeStaticMethod(String methodName)
     */
    public static Object invokeStaticMethod(Class javaClass, String methodName) {
        return invokeStaticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);
    }

    /**
     * Invoke a static method, given the class,
     * method name, parameter types, and parameters.
     * Return its result.
     * Useful for invoking private, package, or protected methods.
     * Class#invokeStaticMethod(String methodName, Class[] parameterTypes, Object[] parameters)
     */
    public static Object invokeStaticMethod(Class javaClass, String methodName, Class[] parameterTypes, Object[] parameters) {
        try {
            return attemptToInvokeStaticMethod(javaClass, methodName, parameterTypes, parameters);
        } catch (NoSuchMethodException nsme) {
            throw new RuntimeException(nsme + CR + fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes), nsme);
        }
    }

    /**
     * Convenience method.
     * Invoke a static method, given the class,
     * method name, parameter type, and parameter.
     * Return its result.
     * Useful for invoking private, package, or protected methods.
     * Class#invokeStaticMethod(String methodName, Class parameterType, Object parameter)
     */
    public static Object invokeStaticMethod(Class javaClass, String methodName, Class parameterType, Object parameter) {
        return invokeStaticMethod(javaClass, methodName, new Class[] { parameterType }, new Object[] { parameter });
    }

    /**
     * Invoke the specified static method with the specified parameters.
     * Return its result.
     * Convert exceptions to RuntimeExceptions.
     */
    public static Object invokeStaticMethod(Method method, Object[] parameters) {
        return invokeMethod(method, null, parameters);
    }

    /**
     * Convenience method.
     * Return a zero-argument method for the specified class
     * and method name. If the class does not directly
     * implement the method, look for it in the class's superclasses.
     * Set accessible to true, so we can access
     * private/package/protected methods.
     */
    public static Method method(Class javaClass, String methodName) throws NoSuchMethodException {
        return method(javaClass, methodName, ZERO_PARAMETER_TYPES);
    }

    /**
     * Return a method for the specified class, method name,
     * and formal parameter types. If the class does not directly
     * implement the method, look for it in the class's superclasses.
     * Set accessible to true, so we can access
     * private/package/protected methods.
     */
    public static Method method(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {
        Method method = null;
        try {
            method = javaClass.getDeclaredMethod(methodName, parameterTypes);
        } catch (NoSuchMethodException ex) {
            Class superclass = javaClass.getSuperclass();
            if (superclass == null) {
                throw ex;
            }
            // recurse
            return method(superclass, methodName, parameterTypes);
        }
        method.setAccessible(true);
        return method;
    }

    /**
     * Convenience method.
     * Return a method for the specified class, method name,
     * and formal parameter type. If the class does not directly
     * implement the method, look for it in the class's superclasses.
     * Set accessible to true, so we can access
     * private/package/protected methods.
     */
    public static Method method(Class javaClass, String methodName, Class parameterType) throws NoSuchMethodException {
        return method(javaClass, methodName, new Class[] { parameterType });
    }

    /**
     * Convenience method.
     * Return a zero-argument method for the specified object
     * and method name. If the object's class does not directly
     * implement the method, look for it in the class's superclasses.
     * Set accessible to true, so we can access
     * private/package/protected methods.
     */
    public static Method method(Object object, String methodName) throws NoSuchMethodException {
        return method(object.getClass(), methodName);
    }

    /**
     * Convenience method.
     * Return a method for the specified object, method name,
     * and formal parameter types. If the object's class does not directly
     * implement the method, look for it in the class's superclasses.
     * Set accessible to true, so we can access
     * private/package/protected methods.
     */
    public static Method method(Object object, String methodName, Class[] parameterTypes) throws NoSuchMethodException {
        return method(object.getClass(), methodName, parameterTypes);
    }

    /**
     * Convenience method.
     * Return a method for the specified object, method name,
     * and formal parameter type. If the object's class does not directly
     * implement the method, look for it in the class's superclasses.
     * Set accessible to true, so we can access
     * private/package/protected methods.
     */
    public static Method method(Object object, String methodName, Class parameterType) throws NoSuchMethodException {
        return method(object.getClass(), methodName, parameterType);
    }

    /**
     * Convenience method.
     * Return the specified class (w/o the checked exception).
     */
    public static Class classForName(String className) {
        try {
            return Class.forName(className);
        } catch (ClassNotFoundException ex) {
            throw new RuntimeException(className, ex);
        }
    }

    /**
     * Convenience method.
     * Return a new instance of the specified class,
     * using the class's default (zero-argument) constructor.
     * Class#newInstance()
     */
    public static Object newInstance(Class javaClass) {
        return newInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);
    }

    /**
     * Convenience method.
     * Return a new instance of the specified class,
     * using the class's default (zero-argument) constructor.
     * Class#newInstance()
     */
    public static Object newInstance(String className) throws ClassNotFoundException {
        return newInstance(className, null);
    }

    /**
     * Convenience method.
     * Return a new instance of the specified class,
     * using the class's default (zero-argument) constructor.
     * Class#newInstance()
     */
    public static Object newInstance(String className, ClassLoader classLoader) throws ClassNotFoundException {
        return newInstance(Class.forName(className, true, classLoader));
    }

    /**
     * Return a new instance of the specified class,
     * given the constructor parameter types and parameters.
     * Class#newInstance(Class[] parameterTypes, Object[] parameters)
     */
    public static Object newInstance(Class javaClass, Class[] parameterTypes, Object[] parameters) {
        try {
            return attemptNewInstance(javaClass, parameterTypes, parameters);
        } catch (NoSuchMethodException nsme) {
            throw new RuntimeException(nsme + CR + fullyQualifiedConstructorSignature(javaClass, parameterTypes), nsme);
        }
    }

    /**
     * Return a new instance of the specified class,
     * given the constructor parameter types and parameters.
     * Class#newInstance(Class[] parameterTypes, Object[] parameters)
     */
    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters) throws ClassNotFoundException {
        return newInstance(className, parameterTypes, parameters, null);
    }

    /**
     * Return a new instance of the specified class,
     * given the constructor parameter types and parameters.
     * Class#newInstance(Class[] parameterTypes, Object[] parameters)
     */
    public static Object newInstance(String className, Class[] parameterTypes, Object[] parameters, ClassLoader classLoader) throws ClassNotFoundException {
        return newInstance(Class.forName(className, true, classLoader), parameterTypes, parameters);
    }

    /**
     * Convenience method.
     * Return a new instance of the specified class,
     * given the constructor parameter type and parameter.
     * Class#newInstance(Class parameterType, Object parameter)
     */
    public static Object newInstance(Class javaClass, Class parameterType, Object parameter) {
        return newInstance(javaClass, new Class[] { parameterType }, new Object[] { parameter });
    }

    /**
     * Return a new instance of the specified class,
     * given the constructor parameter type and parameter.
     * Class#newInstance(Class parameterType, Object parameter)
     */
    public static Object newInstance(String className, Class parameterType, Object parameter) throws ClassNotFoundException {
        return newInstance(className, parameterType, parameter, null);
    }

    /**
     * Return a new instance of the specified class,
     * given the constructor parameter type and parameter.
     * Class#newInstance(Class parameterType, Object parameter)
     */
    public static Object newInstance(String className, Class parameterType, Object parameter, ClassLoader classLoader) throws ClassNotFoundException {
        return newInstance(Class.forName(className, false, classLoader), parameterType, parameter);
    }

    /**
     * Push the declared fields for the specified class
     * onto the top of the stack.
     */
    private static void pushDeclaredFields(Class javaClass, Stack stack) {
        Field[] fields = declaredFields(javaClass);
        for (int i = fields.length - 1; i >= 0; i--) {
            stack.push(fields[i]);
        }
    }

    /**
     * Push the declared methods for the specified class
     * onto the top of the stack.
     */
    private static void pushDeclaredMethods(Class javaClass, Stack stack) {
        Method[] methods = declaredMethods(javaClass);
        for (int i = methods.length - 1; i >= 0; i--) {
            stack.push(methods[i]);
        }
    }

    /**
     * Set a field value, given the containing object, field name, and new field value.
     * Useful for accessing private, package, or protected fields.
     * Object#setFieldValue(String fieldName, Object fieldValue)
     */
    public static void setFieldValue(Object object, String fieldName, Object fieldValue) {
        try {
            attemptToSetFieldValue(object, fieldName, fieldValue);
        } catch (NoSuchFieldException nsfe) {
            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(object, fieldName), nsfe);
        }
    }

    /**
     * Set a static field value, given the containing class, field name, and new field value.
     * Useful for accessing private, package, or protected fields.
     * Class#setStaticFieldValue(String fieldName, Object fieldValue)
     */
    public static void setStaticFieldValue(Class javaClass, String fieldName, Object fieldValue) {
        try {
            attemptToSetStaticFieldValue(javaClass, fieldName, fieldValue);
        } catch (NoSuchFieldException nsfe) {
            throw new RuntimeException(nsfe + CR + fullyQualifiedFieldName(javaClass, fieldName), nsfe);
        }
    }

    /**
     * Return the short name of the object's class.
     * Class#getShortName()
     */
    public static String shortClassNameForObject(Object object) {
        return shortNameFor(object.getClass());
    }

    /**
     * Return the short name of the class (e.g. "Object").
     * Class#getShortName()
     */
    public static String shortNameForClassNamed(String className) {
        return className.substring(className.lastIndexOf('.') + 1);
    }

    /**
     * Return the short name of the class (e.g. "Object").
     * Class#getShortName()
     */
    public static String shortNameFor(Class javaClass) {
        return shortNameForClassNamed(javaClass.getName());
    }

    /**
     * Return the nested name of the object's class.
     * Class#getNestedName()
     */
    public static String nestedClassNameForObject(Object object) {
        return nestedNameFor(object.getClass());
    }

    /**
     * Return the nested name of the class (e.g. "Entry").
     * Class#getNestedName()
     */
    public static String nestedNameForClassNamed(String className) {
        return className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1);
    }

    /**
     * Return the nested name of the class (e.g. "Entry").
     * Class#getNestedName()
     */
    public static String nestedNameFor(Class javaClass) {
        return nestedNameForClassNamed(javaClass.getName());
    }

    /**
     * Return the "toString()" name of the object's class.
     */
    public static String toStringClassNameForObject(Object object) {
        return toStringNameFor(object.getClass());
    }

    /**
     * Return the "toString()" name of the class.
     * "Member" classes will return only the final name:
     *     "com.foo.bar.TopLevelClass$MemberClass$NestedMemberClass"
     *         => "NestedMemberClass"
     * "Local" and "anonymous" classes will still return the embedded '$'s:
     *     "com.foo.bar.TopLevelClass$1LocalClass"
     *         => "TopLevelClass$1LocalClass"
     *     "com.foo.bar.TopLevelClass$1"
     *         => "TopLevelClass$1"
     */
    public static String toStringNameForClassNamed(String className) {
        return classNamedIsMember(className) ? className.substring(className.lastIndexOf(NESTED_CLASS_NAME_SEPARATOR) + 1) : className.substring(className.lastIndexOf('.') + 1);
    }

    /**
     * Return the "toString()" name of the class.
     */
    public static String toStringNameFor(Class javaClass) {
        return toStringNameForClassNamed(javaClass.getName());
    }

    /**
     * Return the package name of the class (e.g. "java.lang").
     * Class#getPackageName()
     */
    public static String packageNameFor(Class javaClass) {
        return packageNameForClassNamed(javaClass.getName());
    }

    /**
     * Return the package name of the class (e.g. "java.lang").
     * Class#getPackageName()
     */
    public static String packageNameForClassNamed(String className) {
        int lastPeriod = className.lastIndexOf('.');
        if (lastPeriod == -1) {
            return "";
        }
        return className.substring(0, lastPeriod);
    }

    /**
     * Return the short name of the class,
     * followed by its package name (e.g. "Object (java.lang)").
     * Class#getShortNameWithPackage()
     */
    public static String shortNameWithPackage(Class javaClass) {
        StringBuffer sb = new StringBuffer(200);
        sb.append(shortNameFor(javaClass));
        if (!javaClass.isPrimitive()) {
            sb.append(" (");
            sb.append(packageNameFor(javaClass));
            sb.append(')');
        }
        return sb.toString();
    }

    /**
     * Convenience method.
     * Return a zero-argument, static method for the specified class
     * and method name. If the class does not directly
     * implement the method, look for it in the class's superclasses.
     * Set accessible to true, so we can access
     * private/package/protected methods.
     */
    public static Method staticMethod(Class javaClass, String methodName) throws NoSuchMethodException {
        return staticMethod(javaClass, methodName, ZERO_PARAMETER_TYPES);
    }

    /**
     * Return a static method for the specified class, method name,
     * and formal parameter types. If the class does not directly
     * implement the method, look for it in the class's superclasses.
     * Set accessible to true, so we can access
     * private/package/protected methods.
     */
    public static Method staticMethod(Class javaClass, String methodName, Class[] parameterTypes) throws NoSuchMethodException {
        Method method = method(javaClass, methodName, parameterTypes);
        if (Modifier.isStatic(method.getModifiers())) {
            return method;
        }
        throw new NoSuchMethodException(fullyQualifiedMethodSignature(javaClass, methodName, parameterTypes));
    }

    /**
     * Convenience method.
     * Return a static method for the specified class, method name,
     * and formal parameter type. If the class does not directly
     * implement the method, look for it in the class's superclasses.
     * Set accessible to true, so we can access
     * private/package/protected methods.
     */
    public static Method staticMethod(Class javaClass, String methodName, Class parameterTypes) throws NoSuchMethodException {
        return staticMethod(javaClass, methodName, new Class[] { parameterTypes });
    }

    /**
     * Return whether the specified class can be "declared" in code;
     * i.e. it is either a "top-level" class or a "member" class, but it
     * is not an "array" class. This method rolls together all the checks
     * from the other methods for a bit of a performance tweak.
     * Class#isDeclarable()
     */
    public static boolean classNamedIsDeclarable(String className) {
        if (className.charAt(0) == ARRAY_INDICATOR) {
            // it is an "array" class
            return false;
        }
        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);
        if (index == -1) {
            // it is a "top-level" class
            return true;
        }
        for (; ; ) try {
            // the character immediately after each dollar sign cannot be a digit
            index++;
            if (Character.isDigit(className.charAt(index))) {
                return false;
            }
            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);
        } finally {
            if (!index != -1) {
                break;
            }
        }
        return true;
    }

    /**
     * Return whether the specified class is a "top-level" class,
     * as opposed to a "member", "local", or "anonymous" class,
     * using the standard jdk naming conventions (i.e. the class
     * name does NOT contain a '$': "TopLevelClass").
     * Class#isTopLevel()
     */
    public static boolean classNamedIsTopLevel(String className) {
        if (classNamedIsArray(className)) {
            return false;
        }
        return className.indexOf(NESTED_CLASS_NAME_SEPARATOR) == -1;
    }

    /**
     * Return whether the specified class is a "member" class,
     * as opposed to a "top-level", "local", or "anonymous" class,
     * using the standard jdk naming conventions (i.e. the class
     * name contains at least one '$' and all the names between
     * each '$' are legal class names:
     * "TopLevelClass$MemberClass$NestedMemberClass").
     * Class#isMember()
     */
    public static boolean classNamedIsMember(String className) {
        if (classNamedIsArray(className)) {
            return false;
        }
        int index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);
        if (index == -1) {
            // it is a "top-level" class
            return false;
        }
        for (; ; ) try {
            // the character immediately after each dollar sign cannot be a digit
            index++;
            if (Character.isDigit(className.charAt(index))) {
                return false;
            }
            index = className.indexOf(NESTED_CLASS_NAME_SEPARATOR, index);
        } finally {
            if (!index != -1) {
                break;
            }
        }
        return true;
    }

    /**
     * Return whether the specified class is a "local" class,
     * as opposed to a "top-level", "member", or "anonymous" class,
     * using the standard jdk (or Eclipse) naming conventions.
     * In the jdk, the class name ends with '$nnnXXX' where the '$' is
     * followed by a series of numeric digits which are followed by the
     * local class name: "TopLevelClass$1LocalClass".
     * In Eclipse, the class name ends with '$nnn$XXX' where the '$' is
     * followed by a series of numeric digits which are separated from
     * the local class name by another '$': "TopLevelClass$1$LocalClass".
     * Class#isLocal()
     */
    public static boolean classNamedIsLocal(String className) {
        if (classNamedIsArray(className)) {
            return false;
        }
        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);
        if (dollar == -1) {
            return false;
        }
        if (!Character.isDigit(className.charAt(dollar + 1))) {
            return false;
        }
        for (int i = dollar + 2; i < className.length(); i++) {
            if (Character.isJavaIdentifierStart(className.charAt(i))) {
                return true;
            }
        }
        // all the characters past the $ are digits (anonymous)
        return false;
    }

    /**
     * Return whether the specified class is an "anonymous" class,
     * as opposed to a "top-level", "member", or "local" class,
     * using the standard jdk naming conventions (i.e. the class
     * name ends with '$nnn' where all the characters past the
     * last '$' are numeric digits: "TopLevelClass$1").
     * Class#isAnonymous()
     */
    public static boolean classNamedIsAnonymous(String className) {
        if (classNamedIsArray(className)) {
            return false;
        }
        int dollar = className.indexOf(NESTED_CLASS_NAME_SEPARATOR);
        if (dollar == -1) {
            return false;
        }
        int start = dollar + 1;
        for (int i = className.length(); i-- > start; ) {
            if (!Character.isDigit(className.charAt(i))) {
                return false;
            }
        }
        // all the characters past the $ are digits
        return true;
    }

    /**
     * Return the "array depth" of the specified class.
     * The depth is the number of dimensions for an array type.
     * Non-array types have a depth of zero.
     * Class#getArrayDepth()
     */
    public static int arrayDepthFor(Class javaClass) {
        int depth = 0;
        for (; javaClass.isArray(); ) {
            depth++;
            javaClass = javaClass.getComponentType();
        }
        return depth;
    }

    /**
     * Return the "array depth" of the specified object.
     * The depth is the number of dimensions for an array.
     * Non-arrays have a depth of zero.
     */
    public static int arrayDepthForObject(Object object) {
        return arrayDepthFor(object.getClass());
    }

    /**
     * Return the "array depth" of the specified class.
     * The depth is the number of dimensions for an array type.
     * Non-array types have a depth of zero.
     * @see java.lang.Class#getName()
     * Class#getArrayDepth()
     */
    public static int arrayDepthForClassNamed(String className) {
        int depth = 0;
        for (; className.charAt(depth) == ARRAY_INDICATOR; ) {
            depth++;
        }
        return depth;
    }

    /**
     * Return whether the specified class is an array type.
     * @see java.lang.Class#getName()
     */
    public static boolean classNamedIsArray(String className) {
        return className.charAt(0) == ARRAY_INDICATOR;
    }

    /**
     * Return the "element type" of the specified class.
     * The element type is the base type held by an array type.
     * A non-array type simply returns itself.
     * Class#getElementType()
     */
    public static Class elementTypeFor(Class javaClass) {
        for (; javaClass.isArray(); ) {
            javaClass = javaClass.getComponentType();
        }
        return javaClass;
    }

    /**
     * Return the "element type" of the specified object.
     * The element type is the base type held by an array.
     * A non-array simply returns its class.
     */
    public static Class elementTypeForObject(Object object) {
        return elementTypeFor(object.getClass());
    }

    /**
     * Return the "element type" of the specified class.
     * The element type is the base type held by an array type.
     * Non-array types simply return themselves.
     * Class#getElementType()
     */
    public static String elementTypeNameFor(Class javaClass) {
        return elementTypeFor(javaClass).getName();
    }

    /**
     * Return the "element type" of the specified class.
     * The element type is the base type held by an array type.
     * Non-array types simply return themselves.
     * @see java.lang.Class#getName()
     * Class#getElementType()
     */
    public static String elementTypeNameForClassNamed(String className) {
        int depth = arrayDepthForClassNamed(className);
        if (depth == 0) {
            // the name is in the form: "java.lang.Object" or "int"
            return className;
        }
        int last = className.length() - 1;
        if (className.charAt(depth) == REFERENCE_CLASS_CODE) {
            // drop the trailing ';'
            return className.substring(depth + 1, last);
        }
        // the name is in the form: "[[[I"
        return classNameForCode(className.charAt(last));
    }

    /**
     * Return whether the specified class is a "reference"
     * class (i.e. not void or one of the primitives).
     */
    public static boolean classNamedIsReference(String className) {
        return !classNamedIsNonReference(className);
    }

    /**
     * Return whether the specified class is a "non-reference"
     * class (i.e. void or one of the primitives).
     */
    public static boolean classNamedIsNonReference(String className) {
        PrimitiveClassCode[] codes = getPrimitiveClassCodes();
        for (int i = codes.length; i-- > 0; ) {
            if (codes[i].javaClass.getName().equals(className)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Return the class name for the specified class code.
     * @see java.lang.Class#getName()
     */
    public static String classNameForCode(char classCode) {
        return classForCode(classCode).getName();
    }

    /**
     * Return the class name for the specified class code.
     * @see java.lang.Class#getName()
     */
    public static String classNameForCode(int classCode) {
        return classNameForCode((char) classCode);
    }

    /**
     * Return the class for the specified class code.
     * @see java.lang.Class#getName()
     */
    public static Class classForCode(char classCode) {
        PrimitiveClassCode[] codes = getPrimitiveClassCodes();
        for (int i = codes.length; i-- > 0; ) {
            if (codes[i].code == classCode) {
                return codes[i].javaClass;
            }
        }
        throw new IllegalArgumentException(String.valueOf(classCode));
    }

    /**
     * Return the class for the specified class code.
     * @see java.lang.Class#getName()
     */
    public static Class classForCode(int classCode) {
        return classForCode((char) classCode);
    }

    /**
     * Return the class code for the specified class.
     * @see java.lang.Class.getName()
     */
    public static char codeForClass(Class javaClass) {
        PrimitiveClassCode[] codes = getPrimitiveClassCodes();
        for (int i = codes.length; i-- > 0; ) {
            if (codes[i].javaClass == javaClass) {
                return codes[i].code;
            }
        }
        throw new IllegalArgumentException(javaClass.getName());
    }

    /**
     * Return the class code for the specified class.
     * @see java.lang.Class.getName()
     */
    public static char codeForClassNamed(String className) {
        PrimitiveClassCode[] codes = getPrimitiveClassCodes();
        for (int i = codes.length; i-- > 0; ) {
            if (codes[i].javaClass.getName().equals(className)) {
                return codes[i].code;
            }
        }
        throw new IllegalArgumentException(className);
    }

    /**
     * Return the class for specified "type declaration".
     */
    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth) throws ClassNotFoundException {
        return classForTypeDeclaration(elementTypeName, arrayDepth, null);
    }

    // see the "Evaluation" of jdk bug 6446627 for a discussion of loading classes
    public static Class classForTypeDeclaration(String elementTypeName, int arrayDepth, ClassLoader classLoader) throws ClassNotFoundException {
        // so check for a primitive class name first
        PrimitiveClassCode[] codes = getPrimitiveClassCodes();
        PrimitiveClassCode pcc = null;
        for (int i = codes.length; i-- > 0; ) {
            if (codes[i].javaClass.getName().equals(elementTypeName)) {
                pcc = codes[i];
                break;
            }
        }
        // non-array
        if (arrayDepth == 0) {
            return (pcc == null) ? Class.forName(elementTypeName, false, classLoader) : pcc.javaClass;
        }
        // array
        StringBuffer sb = new StringBuffer(100);
        for (int i = arrayDepth; i-- > 0; ) {
            sb.append(ARRAY_INDICATOR);
        }
        if (pcc == null) {
            sb.append(REFERENCE_CLASS_CODE);
            sb.append(elementTypeName);
            sb.append(REFERENCE_CLASS_NAME_DELIMITER);
        } else {
            sb.append(pcc.code);
        }
        return Class.forName(sb.toString(), false, classLoader);
    }

    /**
     * Return the class name for specified "type declaration".
     */
    public static String classNameForTypeDeclaration(String elementTypeName, int arrayDepth) {
        // non-array
        if (arrayDepth == 0) {
            return elementTypeName;
        }
        if (elementTypeName.equals(void.class.getName())) {
            throw new IllegalArgumentException("'void' must have an array depth of zero: " + arrayDepth + '.');
        }
        // array
        StringBuffer sb = new StringBuffer(100);
        for (int i = arrayDepth; i-- > 0; ) {
            sb.append(ARRAY_INDICATOR);
        }
        // look for a primitive first
        PrimitiveClassCode[] codes = getPrimitiveClassCodes();
        PrimitiveClassCode pcc = null;
        for (int i = codes.length; i-- > 0; ) {
            if (codes[i].javaClass.getName().equals(elementTypeName)) {
                pcc = codes[i];
                break;
            }
        }
        if (pcc == null) {
            sb.append(REFERENCE_CLASS_CODE);
            sb.append(elementTypeName);
            sb.append(REFERENCE_CLASS_NAME_DELIMITER);
        } else {
            sb.append(pcc.code);
        }
        return sb.toString();
    }

    private static PrimitiveClassCode[] getPrimitiveClassCodes() {
        if (primitiveClassCodes == null) {
            primitiveClassCodes = buildPrimitiveClassCodes();
        }
        return primitiveClassCodes;
    }

    private static PrimitiveClassCode[] buildPrimitiveClassCodes() {
        PrimitiveClassCode[] result = new PrimitiveClassCode[9];
        result[0] = new PrimitiveClassCode(BYTE_CODE, byte.class);
        result[1] = new PrimitiveClassCode(CHAR_CODE, char.class);
        result[2] = new PrimitiveClassCode(DOUBLE_CODE, double.class);
        result[3] = new PrimitiveClassCode(FLOAT_CODE, float.class);
        result[4] = new PrimitiveClassCode(INT_CODE, int.class);
        result[5] = new PrimitiveClassCode(LONG_CODE, long.class);
        result[6] = new PrimitiveClassCode(SHORT_CODE, short.class);
        result[7] = new PrimitiveClassCode(BOOLEAN_CODE, boolean.class);
        result[8] = new PrimitiveClassCode(VOID_CODE, void.class);
        return result;
    }

    /**
     * Suppress default constructor, ensuring non-instantiability.
     */
    private ClassTools() {
        super();
        throw new UnsupportedOperationException();
    }

    private static class PrimitiveClassCode {

        char code;

        Class javaClass;

        PrimitiveClassCode(char code, Class javaClass) {
            this.code = code;
            this.javaClass = javaClass;
        }
    }
}

```


Overlapping Code:
```
final class ClassTools {
public static final Class[] ZERO_PARAMETER_TYPES = new Class[0];
public static final Object[] ZERO_PARAMETERS = new Object[0];
private static final String CR = StringTools.CR;
public static final char NESTED_CLASS_NAME_SEPARATOR = '$';
public static final char ARRAY_INDICATOR = '[';
public static final char REFERENCE_CLASS_CODE = 'L';
public static final char REFERENCE_CLASS_NAME_DELIMITER = ';';
private static PrimitiveClassCode[] primitiveClassCodes;
public static final char BYTE_CODE = 'B';
public static final char CHAR_CODE = 'C';
public static final char DOUBLE_CODE = 'D';
public static final char FLOAT_CODE = 'F';
public static final char INT_CODE = 'I';
public static final char LONG_CODE = 'J';
public static final char SHORT_CODE = 'S';
public static final char BOOLEAN_CODE = 'Z';
public static final char VOID_CODE = 'V';
/**
* Return all the fields for the
* specified class, including inherited fields.
* Class#allFields()
*/
public static Field[] allFields(Class javaClass) {
Stack stack = new Stack();
for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {
pushDeclaredFields(tempClass, stack);
}
Collections.reverse(stack);
return (Field[]) stack.toArray(new Field[stack.size()]);
}
/**
* Return all the methods for the
* specified class, including inherited methods.
* Class#allMethods()
*/
public static Method[] allMethods(Class javaClass) {
Stack stack = new Stack();
for (Class tempClass = javaClass; tempClass != null; tempClass = tempClass.getSuperclass()) {
pushDeclaredMethods(tempClass, stack);
}
Collections.reverse(stack);
return (Method[]) stack.toArray(new Method[stack.size()]);
}
/**
* Convenience method.
* Return a new instance of the specified class,
* using the class's default (zero-argument) constructor.
* Throw an exception if the default constructor is not defined.
* Class#newInstance() throws NoSuchMethodException
*/
public static Object attemptNewInstance(Class javaClass) throws NoSuchMethodException {
return attemptNewInstance(javaClass, ZERO_PARAMETER_TYPES, ZERO_PARAMETERS);
}
/**
* Return a new instance of the specified class
```
<Overlap Ratio: 0.9871441689623508>

---

--- 121 --
Question ID: 66221d0b3719371c37d84e20dc260cfa0cb7971a
Original Code:
```
public class ClientServiceImplTest extends AbstractSpringTests {

    @Autowired
    private ClientService clientService;

    public ClientServiceImplTest() {
        super(true);
    }

    @Test
    public void testCreate_notAdmin_FAIL() {
        List<?> initialClients = trimClient(clientDao.findAll(Sort.by("shortName")));
        //
        CreateOrUpdateClientForm //
        //
        form = //
        new CreateOrUpdateClientForm().//
        setName(//
        "ABC").setShortName(//
        "abc").//
        setContactName(//
        "Abc Def").setEmail(//
        "abc@example.com").//
        setAddress(//
        "555 Betancour").//
        setTel(//
        "555-202-0101").//
        setMainSite(//
        "http://abc.here.com").setLang("EN").setTechnicalSupportSid("S2");
        expectNotAdmin(() -> {
            clientService.create(FakeDataServiceImpl.USER_ID_USER, form);
        });
        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by("shortName"))));
    }

    @Test
    public void testCreate_OK() {
        List<?> initialClients = trimClient(clientDao.findAll(Sort.by("shortName")));
        //
        CreateOrUpdateClientForm //
        //
        form = //
        new CreateOrUpdateClientForm().//
        setName(//
        "ABC").setShortName(//
        "abc").//
        setContactName(//
        "Abc Def").setEmail(//
        "abc@example.com").//
        setAddress(//
        "555 Betancour").//
        setTel(//
        "555-202-0101").//
        setMainSite(//
        "http://abc.here.com").setLang("EN").setTechnicalSupportSid("S2");
        FormResult result = clientService.create(FakeDataServiceImpl.USER_ID_ADMIN, form);
        AssertTools.assertJsonComparisonWithoutNulls("FormResult-success.json", getClass(), result);
        AssertTools.assertDiffJsonComparison("ClientServiceImplTest-testCreate_OK-clients.json", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by("shortName"))));
    }

    @Test
    public void testCreate_shortName_exists_FAIL() {
        List<?> initialClients = trimClient(clientDao.findAll(Sort.by("shortName")));
        //
        CreateOrUpdateClientForm //
        //
        form = //
        new CreateOrUpdateClientForm().//
        setName(//
        "ABC").setShortName(//
        FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA).//
        setContactName(//
        "Abc Def").setEmail(//
        "abc@example.com").//
        setAddress(//
        "555 Betancour").//
        setTel(//
        "555-202-0101").//
        setMainSite(//
        "http://abc.here.com").setLang("EN").setTechnicalSupportSid("S2");
        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);
        AssertTools.assertJsonComparisonWithoutNulls("ClientServiceImplTest-shortName_exists_FAIL-FormResult.json", getClass(), result);
        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by("shortName"))));
    }

    @Test
    public void testDelete_notAdmin_FAIL() {
        List<?> initialClients = trimClient(clientDao.findAll(Sort.by("shortName")));
        expectNotAdmin(() -> {
            clientService.delete(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);
        });
        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by("shortName"))));
    }

    @Test
    public void testDelete_OK() {
        List<?> initialClients = trimClient(clientDao.findAll(Sort.by("shortName")));
        FormResult result = clientService.delete(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR);
        AssertTools.assertJsonComparisonWithoutNulls("FormResult-success.json", getClass(), result);
        AssertTools.assertDiffJsonComparison("ClientServiceImplTest-testDelete_OK-clients.json", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by("shortName"))));
    }

    @Test
    public void testListAll_notAdmin_FAIL() {
        expectNotAdmin(() -> {
            clientService.listAll(FakeDataServiceImpl.USER_ID_USER, 1, null);
        });
    }

    @Test
    public void testListAll_OK() {
        AssertTools.assertJsonComparisonWithoutNulls("ClientServiceImplTest-testListAll_OK.json", getClass(), clientService.listAll(FakeDataServiceImpl.USER_ID_ADMIN, 1, null));
    }

    @Test
    public void testUpdate_noChange_OK() {
        List<?> initialClients = trimClient(clientDao.findAll(Sort.by("shortName")));
        //
        CreateOrUpdateClientForm //
        //
        form = //
        new CreateOrUpdateClientForm().//
        setName(//
        "Bazar").setShortName(//
        FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR).//
        setContactName(//
        "Benoit Bezos").setEmail(//
        "benoit@example.com").//
        setAddress(//
        "1010 Betancour").//
        setTel(//
        "555-101-0101").//
        setMainSite(//
        "http://bazar.example.com").setLang("FR").setTechnicalSupportSid("S1");
        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);
        AssertTools.assertJsonComparisonWithoutNulls("FormResult-success.json", getClass(), result);
        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by("shortName"))));
    }

    @Test
    public void testUpdate_notAdmin_FAIL() {
        List<?> initialClients = trimClient(clientDao.findAll(Sort.by("shortName")));
        //
        CreateOrUpdateClientForm //
        //
        form = //
        new CreateOrUpdateClientForm().//
        setName(//
        "Bazar Yay").setShortName(//
        FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR).//
        setContactName(//
        "Benoit Banana").setEmail(//
        "benoit@example2.com").//
        setAddress(//
        "1020 Betancour").//
        setTel(//
        "555-202-0101").//
        setMainSite(//
        "http://bazar.here.com").setLang("EN").setTechnicalSupportSid("S2");
        expectNotAdmin(() -> {
            clientService.update(FakeDataServiceImpl.USER_ID_USER, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);
        });
        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by("shortName"))));
    }

    @Test
    public void testUpdate_OK() {
        List<?> initialClients = trimClient(clientDao.findAll(Sort.by("shortName")));
        //
        CreateOrUpdateClientForm //
        //
        form = //
        new CreateOrUpdateClientForm().//
        setName(//
        "Bazar Yay").setShortName(//
        FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR).//
        setContactName(//
        "Benoit Banana").setEmail(//
        "benoit@example2.com").//
        setAddress(//
        "1020 Betancour").//
        setTel(//
        "555-202-0101").//
        setMainSite(//
        "http://bazar.here.com").setLang("EN").setTechnicalSupportSid("S2");
        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);
        AssertTools.assertJsonComparisonWithoutNulls("FormResult-success.json", getClass(), result);
        AssertTools.assertDiffJsonComparison("ClientServiceImplTest-testUpdate_OK-clients.json", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by("shortName"))));
    }

    @Test
    public void testUpdate_shortName_exists_FAIL() {
        List<?> initialClients = trimClient(clientDao.findAll(Sort.by("shortName")));
        //
        CreateOrUpdateClientForm //
        //
        form = //
        new CreateOrUpdateClientForm().//
        setName(//
        "Bazar").setShortName(//
        FakeDataServiceImpl.CLIENT_SHORTNAME_EXTRA).//
        setContactName(//
        "Benoit Bezos").setEmail(//
        "benoit@example.com").//
        setAddress(//
        "1010 Betancour").//
        setTel(//
        "555-101-0101").//
        setMainSite(//
        "http://bazar.example.com").setLang("FR").setTechnicalSupportSid("S1");
        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);
        AssertTools.assertJsonComparisonWithoutNulls("ClientServiceImplTest-shortName_exists_FAIL-FormResult.json", getClass(), result);
        AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by("shortName"))));
    }

    @Test
    public void testUpdate_shortName_OK() {
        List<?> initialClients = trimClient(clientDao.findAll(Sort.by("shortName")));
        //
        CreateOrUpdateClientForm //
        //
        form = //
        new CreateOrUpdateClientForm().//
        setName(//
        "Bazar").setShortName(//
        "bbb").//
        setContactName(//
        "Benoit Bezos").setEmail(//
        "benoit@example.com").//
        setAddress(//
        "1010 Betancour").//
        setTel(//
        "555-101-0101").//
        setMainSite(//
        "http://bazar.example.com").setLang("FR").setTechnicalSupportSid("S1");
        FormResult result = clientService.update(FakeDataServiceImpl.USER_ID_ADMIN, FakeDataServiceImpl.CLIENT_SHORTNAME_BAZAR, form);
        AssertTools.assertJsonComparisonWithoutNulls("FormResult-success.json", getClass(), result);
        AssertTools.assertDiffJsonComparison("ClientServiceImplTest-testUpdate_shortName_OK-clients.json", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by("shortName"))));
    }
}

```


Overlapping Code:
```
erviceImplTest extends AbstractSpringTests {
@Autowired
private ClientService clientService;
public ClientServiceImplTest() {
super(true);
}
@Test
public void testCreate_notAdmin_FAIL() {
List<?> initialClients = trimClient(clientDao.findAll(Sort.by("shortName")));
expectNotAdmin(() -> {
clientService.create(FakeDataServiceImpl.USER_ID_USER, form);
});
AssertTools.assertDiffJsonComparison(new AssertDiff(), initialClients, trimClient(clientDao.findAll(Sort.by("shortName"))));
}
@Test
public void testCreate_OK() {
List<?> initialClients = trimClient(clientDao.findAll(Sort.by("shortName"))upportSid("S2");
FormResult result = clientService.create(FakeDataServiceImpl.USER_ID_ADMIN, form);
AssertTools.assertJsonComparisonWithoutNulls("FormResult-success.json", getClass(), result);
AssertTools.assertDiffJsonComparison("ClientServiceImplTest-testCreate_OK-clients.json", getClass(), initialClients, trimClient(clientDao.findAll(Sort.by("shortName"))));
}
@Test
public void testCreate_shortName_exists_FAIL() {
List<?> initialClients = trimClient(clientDao.findAll(Sort.by("shortName"))
```
<Overlap Ratio: 0.5483383685800605>

---

--- 122 --
Question ID: cd257f0dce4bba1a21fbdb15fd284702dd48600f
Original Code:
```
public class SimpleBlockingQueueTest {

    @Test
    public void whenUseBlockingQueue() {
    }
}

```


Overlapping Code:
```
blic class SimpleBlockingQueueTest {
@Test
public void whenUseBlockingQu
```
<Overlap Ratio: 0.8470588235294118>

---

--- 123 --
Question ID: d0aa6b0a1e5c6f19bbc40686624f1ab36563df62
Original Code:
```
public class Dispatcher {

    /**
     * DispatcherRunnable is the runnable class in which a group of dispatch
     *   messages (sharing the same url) get dispatched to corresponding worker
     *   service
     */
    private class DispatcherRunnable implements Runnable {

        private static final String kWorkerEntryPoint = "/Worker";

        private String dispatchMessages;

        private ArrayList<String> workersTopology;

        /**
         * Constructor DispatcherRunnable
         * @param url: worker service's url
         * @param dispatchMessages: messages to be dispatched
         * @return new DispatcherRunnable Object
         */
        public DispatcherRunnable(String dispatchMessages) {
            this.dispatchMessages = dispatchMessages;
            this.workersTopology = new ArrayList<String>();
            try {
                String propertiesWorkersTopology = DispatcherProperties.i().getStringPropterty(DispatcherProperties.kWorkersTopology);
                String[] topologyArr = propertiesWorkersTopology.split(",");
                for (String topologyEntry : topologyArr) {
                    this.workersTopology.add(topologyEntry + kWorkerEntryPoint);
                }
            } catch (Exception e) {
                throw new CodeException(32, 1, "propterty [" + DispatcherProperties.kWorkersTopology + "] isn't defined in properties file [" + DispatcherProperties.i().getName() + "]", ExceptionClass.PROPERTIES);
            }
        }

        /**
         * send the messages to be despatched in a POST http request to the
         *   worker service
         * NOTE: silent in case of failure, change as needed?
         */
        @Override
        public void run() {
            for (String workerTopologyPoint : this.workersTopology) {
                try {
                    URLConnection urlConnection = RestSyncInl.restCall(workerTopologyPoint, RestCallType.POST, this.dispatchMessages);
                    if (RestSyncInl.isResponseStatusSuccess(urlConnection) == true) {
                        break;
                    }
                } catch (Exception e) {
                }
            }
        }

        @Override
        public String toString() {
            return "DispatcherRunnable:  dispatchMessages(" + this.dispatchMessages + ")";
        }
    }

    // url -> list of dispatch messages
    private ArrayList<DispatchMessage> dispatchMessages;

    /**
     * Constructor Dispatcher
     * @return new Dispatcher Object
     */
    public Dispatcher() {
        this.dispatchMessages = new ArrayList<DispatchMessage>();
    }

    /**
     * addDispatchMessage
     * adds a new dispatch message to the dispatcher's buffer
     * @param url: url of the worker service that handles this type of
     *               dispatch message
     * @param dispatchMessage: the message to be dispatched
     * @throws Exception
     */
    public void addDispatchMessage(DispatchMessage dispatchMessage) throws Exception {
        this.dispatchMessages.add(dispatchMessage);
    }

    /**
     * dispatchMessages
     * dispatches all the dispatch messages in the dispatcher buffer to their
     *   corresponding worker services then clears the dispatcher buffer
     * @throws Exception
     */
    public void dispatchMessages() throws Exception {
        if (this.dispatchMessages.isEmpty() == true) {
            return;
        }
        ThreadPool.i().executeInDispatcherPool(new DispatcherRunnable(new DispatchMessages(this.dispatchMessages).toJsonString()));
        this.dispatchMessages.clear();
    }

    @Override
    public String toString() {
        return this.dispatchMessages.toString();
    }
}

```


Overlapping Code:
```
s in which a group of dispatch
* messages (sharing the same url) get dispatched to corresponding worker
* service
*/
private class DispatcherRunnable implements Runnable {
private static final String kWorkerEntryPoint = "/Worker";
private String dispatchMessages;
private ArrayList<String> workersToaram url: worker service's url
* @param dispatchMessages: messages to be dispatched
* @return new DispatcherRunnable Object
*/
public DispatcherRunnabWorkerEntryPoint);
}
} catch (Exception e) {
throw**
* send the messages to be despatched in a POST http request to the
* worker service
* NOTE: silenException e) {
}
}
}
@Override
public String toString() {
return "Dispatchelist of dispatch messages
private ArrayList<DispatchMessage> dispatchMessages;
/**
* Constructor Dis
```
<Overlap Ratio: 0.404177545691906>

---

--- 124 --
Question ID: 67e1a9532bb4ba1630a30e9b874e7bee7caead7c
Original Code:
```
class PersonNameField extends ValueFieldTest {

    public void clearAssociation(final NakedObject inObject) {
        getPerson(inObject).setName("");
    }

    public String debugData() {
        return "";
    }

    public NakedObject get(final NakedObject fromObject) {
        final TestProxyNakedObject nakedObject = new TestProxyNakedObject();
        nakedObject.setupObject(getPerson(fromObject).getName());
        return nakedObject;
    }

    public String getId() {
        return "name";
    }

    public String getName() {
        return "Name";
    }

    private Person getPerson(final NakedObject inObject) {
        return (Person) inObject.getObject();
    }

    public NakedObjectSpecification getSpecification() {
        return new TestSpecification("java.lang.String");
    }

    public void initAssociation(final NakedObject inObject, final NakedObject association) {
        getPerson(inObject).setName((String) association.getObject());
    }

    public Consent isAssociationValid(final NakedObject inObject, final NakedObject association) {
        return Allow.DEFAULT;
    }

    public void setAssociation(final NakedObject inObject, final NakedObject association) {
        getPerson(inObject).setName((String) association.getObject());
    }

    public void set(NakedObject owner, NakedObject newValue) {
        setAssociation(owner, newValue);
    }
}

```


Overlapping Code:
```
ldTest {
public void clearAssociation(final NakedObject inObject) {
getPerson(inObject).setName("");
}
public String debugData() {
return "";
}
public NakedObject get(final NakedObject fromObject) {
final TestProxyNakedObject nakedObject = new TestProxyNakedObject();
nakedObject.setupObject(getPerson(fromObject).getName());
return nakedObject;
}
public String getId() {
return "name";
}
public String getName() {
return "Name";
}
private Person getPerson(final NakedObject inObject) {
return (Person) inObject.getObject();
}
public NakedObjectSpecification getSpecification() {
return new TestSpecification("java.lang.String");
}
public void initAssociation(final NakedObject inObject, final NakedObject association) {
getPerson(inObject).setName((String) association.getObject());
}
public Consent isAssociationValid(final NakedObject inObject, final NakedObject association) {
return Allow.DEFAULT;
}
public void setAssociation(final NakedObject inObject, final NakedObject association) {
getPerson(inObject).setName((String) association.getObject());
}
public void set(NakedObject owner, NakedObject newValue) {
setAssociation(owner, newValue);

```
<Overlap Ratio: 0.9655751469353484>

---

--- 125 --
Question ID: b64d18704447220e35b2d2254fdb3118096bcb32
Original Code:
```
@Dependent
public class DefaultPaletteFactory<H extends AbstractCanvasHandler> implements PaletteFactory<DefaultPaletteWidget, H> {

    private final DefinitionUtils definitionUtils;

    private final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> paletteDefinitionBuilders;

    private final ManagedInstance<DefaultPaletteWidget> palettes;

    private final Event<BuildCanvasShapeEvent> buildCanvasShapeEvent;

    private final Event<CanvasShapeDragStartEvent> canvasShapeDragStartEvent;

    private final Event<CanvasShapeDragUpdateEvent> canvasShapeDragUpdateEvent;

    @Inject
    public DefaultPaletteFactory(final DefinitionUtils definitionUtils, @Any final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> paletteDefinitionBuilders, @Any final ManagedInstance<DefaultPaletteWidget> palettes, final Event<BuildCanvasShapeEvent> buildCanvasShapeEvent, final Event<CanvasShapeDragStartEvent> canvasShapeDragStartEvent, final Event<CanvasShapeDragUpdateEvent> canvasShapeDragUpdateEvent) {
        this.definitionUtils = definitionUtils;
        this.paletteDefinitionBuilders = paletteDefinitionBuilders;
        this.palettes = palettes;
        this.buildCanvasShapeEvent = buildCanvasShapeEvent;
        this.canvasShapeDragStartEvent = canvasShapeDragStartEvent;
        this.canvasShapeDragUpdateEvent = canvasShapeDragUpdateEvent;
    }

    @Override
    public DefaultPaletteWidget newPalette(final H canvasHandler) {
        final DefaultPaletteWidget palette = getPaletteWidget(canvasHandler);
        getPaletteDefinitionBuilder(canvasHandler).build(canvasHandler, palette::bind);
        return palette;
    }

    @PreDestroy
    public void destroy() {
        paletteDefinitionBuilders.destroyAll();
        palettes.destroyAll();
    }

    private PaletteDefinitionBuilder<H, DefaultPaletteDefinition> getPaletteDefinitionBuilder(final H canvasHandler) {
        final String definitionSetId = canvasHandler.getDiagram().getMetadata().getDefinitionSetId();
        final Annotation qualifier = definitionUtils.getQualifier(definitionSetId);
        final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> custom = paletteDefinitionBuilders.select(qualifier);
        if (custom.isUnsatisfied()) {
            return paletteDefinitionBuilders.select(DefinitionManager.DEFAULT_QUALIFIER).get();
        }
        return custom.get();
    }

    private DefaultPaletteWidget getPaletteWidget(final H canvasHandler) {
        final DefaultPaletteWidget palette = palettes.get();
        palette.onItemDrop(event -> buildCanvasShapeEvent.fire(new BuildCanvasShapeEvent(canvasHandler, event.getDefinition(), event.getFactory(), event.getX(), event.getY())));
        palette.onItemDragStart(event -> canvasShapeDragStartEvent.fire(new CanvasShapeDragStartEvent(canvasHandler, event.getDefinition(), event.getFactory(), event.getX(), event.getY())));
        palette.onItemDragUpdate(event -> canvasShapeDragUpdateEvent.fire(new CanvasShapeDragUpdateEvent(canvasHandler, event.getDefinition(), event.getFactory(), event.getX(), event.getY())));
        return palette;
    }
}

```


Overlapping Code:
```

public class DefaultPaletteFactory<H extends AbstactCanvasHandler> implements PaletteFactory<DefaultPaletteWidget, H> {
private final DefinitionUtils definitionUtils;
private final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinition>> paletteDefinitionBuilders;
private final ManagedInstance<DefaultPaletteWidget> palettes;
private final Event<BuildCanvasShapeEvent> buildCanvasShapeEvent;
private final Event<CanvasShapeDragStartEvent> canvasShapeDragStartEvent;
private final Event<CanvasShapeDragUpdateEvent> canvasShapeDragUpdateEvent;
@Inject
public DefaultPaletteFactory(finagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinitio final Event<BuildCanvasShapeEvent> buildCanvasShapvent<CanvasShapeDragStartEvent> canvasShapeDragStant<CanvasShapeDragUpdateEvent> canvasShapeDragUpdateEvent) {
this.definitionUtils = definitionUtils;
this.paletteDefinitionBuilders = paletteDefinitionBuilders;
this.palettes = palettes;
this.buildCanvasShapeEvent = buildCanvasShapeEvent;
this.canvasShapeDragStartEvent = canvasShapeDragStartEvent;
this.canvasShapeDragUpdateEvent = canvasShapeDragUpdateEvent;
}
@Override
public DefaultPaletteWidget newPalette(final H canvasHandler) {
final DefaultPaletteWidget palette = getPaletteWidget(canvasHandler);
getPaleroy
public void destroy() {
paletteDefinitionBuilders.destroyAll();
palettes.destroyAll();
}
private PaletteDefinitionBuilder<H, DefaultPaletteDefinition> getPaletteDefinitionBuilder(final H canvasHandler) {
final String definitionSetId = canvasHandler.getDiagram().getMetadata().getDefinitionSetId();
final Annotation qualifier = definitionUtils.getQualifier(definitionSetId);
final ManagedInstance<PaletteDefinitionBuilder<H, DefaultPaletteDefinitiolifier);
if (custom.isUnsatisfied()) {
return paletteDefinitionBuilders.select(DefinitionManager.DEFAULT_QUALIFIER).get();
}
return custom.get();
}
private DefaultPaletteWidget getPaletteWidget(final 
```
<Overlap Ratio: 0.8500881834215167>

---

--- 126 --
Question ID: a9493bf8c49764bbd03c7dd221f326510d0d8afa
Original Code:
```
@RunWith(MockitoJUnitRunner.class)
public class CooldownsTest {

    private static final String ENCHANT_NAME = "enchantName";

    private static final UUID USER_ID = UUID.randomUUID();

    @Mock
    private Clock clock;

    @Mock
    private CustomEnchantment enchantment;

    @Mock
    private LivingEntity user;

    @Mock
    private Settings settings;

    @Before
    public void setUp() throws Exception {
        TestUtils.set(Cooldowns.class, "clock", clock);
        when(enchantment.getName()).thenReturn(ENCHANT_NAME);
        when(user.getUniqueId()).thenReturn(USER_ID);
    }

    @After
    public void tearDown() throws Exception {
    }

    @Test
    public void configure() throws Exception {
        Cooldowns.configure(settings, 12, 23);
        verify(settings).set("cooldown", 12, 23);
    }

    @Test
    public void secondsLeft() throws Exception {
        when(clock.millis()).thenReturn(100L, 1100L);
        when(settings.get("cooldown", 2)).thenReturn(15.0);
        Cooldowns.start(enchantment, user);
        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);
        assertEquals(result, 14);
    }

    @Test
    public void secondsLeft_roundedUp() throws Exception {
        when(clock.millis()).thenReturn(100L, 1000L);
        when(settings.get("cooldown", 2)).thenReturn(1.0);
        Cooldowns.start(enchantment, user);
        final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);
        assertEquals(result, 1);
    }

    @Test
    public void onCooldown() throws Exception {
        when(clock.millis()).thenReturn(100L, 1100L);
        when(settings.get("cooldown", 2)).thenReturn(15.0);
        Cooldowns.start(enchantment, user);
        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);
        assertTrue(result);
    }

    @Test
    public void onCooldown_exact() throws Exception {
        when(clock.millis()).thenReturn(100L, 15100L);
        when(settings.get("cooldown", 2)).thenReturn(15.0);
        Cooldowns.start(enchantment, user);
        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);
        assertFalse(result);
    }

    @Test
    public void onCooldown_offCooldown() throws Exception {
        when(clock.millis()).thenReturn(100L, 20100L);
        when(settings.get("cooldown", 2)).thenReturn(15.0);
        Cooldowns.start(enchantment, user);
        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);
        assertFalse(result);
    }

    @Test
    public void reduce() throws Exception {
        when(clock.millis()).thenReturn(100L, 10100L);
        when(settings.get("cooldown", 2)).thenReturn(15.0);
        Cooldowns.start(enchantment, user);
        Cooldowns.reduce(enchantment, user, 6000);
        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);
        assertFalse(result);
    }

    @Test
    public void reduceNegative() throws Exception {
        when(clock.millis()).thenReturn(100L, 20100L);
        when(settings.get("cooldown", 2)).thenReturn(15.0);
        Cooldowns.start(enchantment, user);
        Cooldowns.reduce(enchantment, user, -6000);
        final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);
        assertTrue(result);
    }
}

```


Overlapping Code:
```
@RunWith(MockitoJUnitRunner.class)
public class CooldownsTest {
private static final String ENCHANT_NAME = "enchantName";
private static final UUID USER_ID = UUID.randomUUID();
@Mock
private Clock clock;
@Mock
private CustomEnchantment enchantment;
@Mock
private LivingEntity user;
@Mock
private Settings settings;
@Before
public void setUp() throws Exception {
TestUtils.set(Cooldowns.class, "clock", clock);
when(enchantment.getName()).thenReturn(ENCHANT_NAME);
when(user.getUniqueId()).thenReturn(USER_ID);
}
@After
public void tearDown() throws Exception {
}
@Test
public void configure() throws Exception {
Cooldowns.configure(settings, 12, 23);
verify(settings).set("cooldown", 12, 23);
}
@Test
public void secondsLeft() throws Exception {
when(clock.millis()).thenReturn(100L, 1100L);
when(settings.get("cooldown", 2)).thenReturn(15.0);
Cooldowns.start(enchantment, user);
final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);
assertEquals(result, 14);
}
@Test
public void secondsLeft_roundedUp() throws Exception {
when(clock.millis()).thenReturn(100L, 1000L);
when(settings.get("cooldown", 2)).thenReturn(1.0);
Cooldowns.start(enchantment, user);
final int result = Cooldowns.secondsLeft(enchantment, user, settings, 2);
assertEquals(result, 1);
}
@Test
public void onCooldown() throws Exception {
when(clock.millis()).thenReturn(100L, 1100L);
when(settings.get("cooldown", 2)).thenReturn(15.0);
Cooldowns.start(enchantment, user);
final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);
assertTrue(result);
}
@Test
public void onCooldown_exact() throws Exception {
when(clock.millis()).thenReturn(100L, 15100L);
when(settings.get("cooldown", 2)).thenReturn(15.0);
Cooldowns.start(enchantment, user);
final boolean result = Cooldowns.onCooldown(enchantment, user, settings, 2);
assertFalse(result);
}
@Test
public void onCooldown_offCooldown() throws Exception {
when(clock.millis()).thenReturn(100L, 20100L);
when(settings.get("cooldown", 2)).thenReturn(15.0);
Cooldowns.start(enchantment, user);
final boolean result = Cooldowns.onCooldown(enchantment, user, setti
```
<Overlap Ratio: 0.9981132075471698>

---

--- 127 --
Question ID: 26dda56691b09a01ad828c280432170a49807b73
Original Code:
```
public class LineSegment {

    private Point start;

    private Point end;

    private double dX;

    private double dY;

    /**
     * Constructor LineSegment
     * @param start point
     * @param end point
     * @return new LineSegment Object
     */
    public LineSegment(Point start, Point end) throws Exception {
        this.start = start;
        this.end = end;
        this.dX = this.start.getX() - this.end.getX();
        this.dY = this.start.getY() - this.end.getY();
    }

    /**
     * getStart
     * @return this line's start point
     * @throws Exception
     */
    public Point getStart() throws Exception {
        return this.start;
    }

    /**
     * getEnd
     * @return this line's end point
     * @throws Exception
     */
    public Point getEnd() throws Exception {
        return this.end;
    }

    /**
     * equal
     * @param line
     * @return true if lines are equivalent and false otherwise
     * @throws Exception
     */
    public boolean equal(LineSegment line) throws Exception {
        if (this.start.equal(line.start) == true && this.end.equal(line.end) == true) {
            return true;
        }
        if (this.start.equal(line.end) == true && this.end.equal(line.start) == true) {
            return true;
        }
        return false;
    }

    /**
     * getLength
     * @return the line segment's length
     * @throws Exception
     */
    public double getLength() throws Exception {
        return this.start.getDistance(this.end);
    }

    /**
     * getSlope
     * @return this line's slope
     * @throws Exception
     */
    public double getSlope() throws Exception {
        return (this.start.getY() - this.end.getY()) / (this.start.getX() - this.end.getX());
    }

    /**
     * getDirection
     * @return this line's direction [-180 ... 180]
     * @throws Exception
     */
    public double getDirection() throws Exception {
        return Math.toDegrees(Math.atan2(this.end.getX() - this.start.getX(), this.end.getY() - this.start.getY()));
    }

    /**
     * getDirectionDelta
     * @param line
     * @return the delta direction between this line and the param line
     * @throws Exception
     */
    public double getDirectionDelta(LineSegment line) throws Exception {
        double deltaDir = Math.abs(this.getDirection() - line.getDirection());
        if (deltaDir > 180) {
            deltaDir = 360 - deltaDir;
        }
        return deltaDir;
    }

    /**
     * isPointOnLine
     * @param point
     * @return true if param point is on this line and false otherwise
     * @throws Exception
     */
    public boolean isPointOnLine(Point point) throws Exception {
        if (this.start.equal(point) == true || this.end.equal(point) == true) {
            return true;
        }
        if (!(point.getX() <= Math.max(this.start.getX(), this.end.getX()) && point.getX() >= Math.min(this.start.getX(), this.end.getX()))) {
            return false;
        }
        if (!(point.getY() <= Math.max(this.start.getY(), this.end.getY()) && point.getY() >= Math.min(this.start.getY(), this.end.getY()))) {
            return false;
        }
        LineSegment testLine = new LineSegment(point, this.start);
        if (this.getSlope() != testLine.getSlope()) {
            return false;
        }
        return true;
    }

    /**
     * getNearestPointOnLine
     * @param point
     * @return nearest point on this line to param point
     * @throws Exception
     */
    public Point getNearestPointOnLine(Point point) throws Exception {
        if (this.isPointOnLine(point) == true) {
            return point;
        }
        double u = ((point.getX() - this.end.getX()) * this.dX + (point.getY() - this.end.getY()) * this.dY) / (this.dX * this.dX + this.dY * this.dY);
        if (u < 0.0) {
            return this.end;
        } else if (u > 1.0) {
            return this.start;
        } else {
            return new Point(this.end.getX() + u * this.dX, this.end.getY() + u * this.dY);
        }
    }

    /**
     * getMinDistance
     * @param point
     * @return minimum distance between param point and this line
     * @throws Exception
     */
    public double getMinDistance(Point point) throws Exception {
        return point.getDistance(this.getNearestPointOnLine(point));
    }

    /**
     * getIntersectionPoint
     * @param line
     * @return returns the point where this line and param line intersects and
     *           null otherwise
     * @throws Exception
     */
    public Point getIntersectionPoint(LineSegment line) throws Exception {
        StraightLine lineOne = new StraightLine(line);
        StraightLine lineTwo = new StraightLine(this);
        Point intersectionPoint = lineOne.getIntersectionPoint(lineTwo);
        if (intersectionPoint == null) {
            return null;
        }
        if (this.isPointOnLine(intersectionPoint) == true) {
            return intersectionPoint;
        }
        return null;
    }

    /**
     * projectionInRange
     * @param point
     * @return true if the point's projection intersects with this line and
     *           false otherwise
     * @throws Exception
     */
    public boolean pointProjectionInRange(Point point) throws Exception {
        double dx = this.end.getX() - this.start.getX();
        double dy = this.end.getY() - this.start.getY();
        double innerProduct = (point.getX() - this.start.getX()) * dx + (point.getY() - this.start.getY()) * dy;
        return 0 <= innerProduct && innerProduct <= dx * dx + dy * dy;
    }

    @Override
    public String toString() {
        return "LineSegment: Start: " + this.start.toString() + " End: " + this.end.toString();
    }
}

```


Overlapping Code:
```
neSegment {
private Point start;
private Point end;
private ineSegment
* @param start point
* @param end point
* @return new LineSegment Object
*/
public LineSeception {
this.start = start;
this.end = end;
this.dX = this.start.getX() - this.end.getX();
this.dY = this.start.getY() - this.end.getY();
}
/**
* getStart
* @return this line's start point
* @throws Exceptioline's end point
* @throws Exception
*/
public Poies are equivalent and false otherwise
* @throws Exception
*/
public boolean ) == true) {
return true;
}
return false;
}
/**
* g@return the line segment's length
* @throws Except*
* getSlope
* @return this line's slope
* @throwsthis.start.getY() - this.end.getY()) / (this.start
/**
* getDirection
* @return this line's direction [-180 ... 180]
* @throws Exception
*/
public douline
* @return the delta direction between this line and the param line
* @throws Exception
*/
publi
```
<Overlap Ratio: 0.44643746885899355>

---

--- 128 --
Question ID: 086569103dfc31b2649c3f12a6338fcfe2ef52d3
Original Code:
```
public class LogModule extends PrivateModule {

    private final File logDirectory;

    private final StateMachine stateMachine;

    private final Executor executor;

    public LogModule(@Nonnull File logDirectory, @Nonnull StateMachine stateMachine, @Nonnull Executor executor) {
        this.logDirectory = checkNotNull(logDirectory);
        this.stateMachine = checkNotNull(stateMachine);
        this.executor = checkNotNull(executor);
    }

    @Override
    protected void configure() {
        bind(StateMachine.class).toInstance(stateMachine);
        bind(StateMachineProxy.class);
        bind(Executor.class).annotatedWith(StateExecutor.class).toInstance(executor);
        bind(RaftLog.class).asEagerSingleton();
        expose(RaftLog.class);
    }

    @Nonnull
    @Provides
    @Singleton
    Journal getJournal() {
        try {
            final Journal journal = JournalBuilder.of(logDirectory).setPhysicalSync(true).open();
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                //noinspection EmptyCatchBlock
                try {
                    journal.close();
                } catch (IOException e) {
                }
            }));
            return journal;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

```


Overlapping Code:
```
lic class LogModule extends PrivateModule {
private final File logDirectory;
private final StateMachine stateMachine;
private final Executor executor;
public LogModule(@Nonnull File logDirectory, @Nonnull StateMachine stateMachine, @Nonnull Executor executor) {
this.logDirectory = checkNotNull(logDirectory);
this.stateMachine = checkNotNull(stateMachine);
this.executor = checkNotNull(executor);
}
@Override
protected void configure() {
bind(StateMachine.class).toInstance(stateMachine);
bind(StateMachineProxy.class);
RaftLog.class).asEagerSingleton();
expose(RaftLog.class);
}
@Nonnull
@Provides
@Singleton
Journal getJournal() {
try {
final Journal journal = JournalBuilder.of(logDirectory).setPhysicalSync(true).open();
Runtime.getRuntime().addShutdownHook(new Thread(() -> {
//noinspection EmptyCatchBlock
try {
journal.close();
} catch (IOException e) {
}
}));
return journal;
} catch (IOException e) {
throw new RuntimeException(e);
}
}
}
```
<Overlap Ratio: 0.9167473378509197>

---

--- 129 --
Question ID: b7cad21f3c37603e9f2c3cc34f0e1a6e357d10f3
Original Code:
```
public class BulletEffectAttractive implements BulletEffect {

    @Override
    public String getID() {
        return "attractive";
    }

    @Override
    public boolean onCollideEntity(@NotNull World world, @NotNull IBulletEntity bullet, @NotNull Entity hitEntity) {
        if (hitEntity instanceof EntityAnimal) {
            ((EntityAnimal) hitEntity).setInLove(bullet.getEntityThrower() instanceof EntityPlayer ? (EntityPlayer) bullet.getEntityThrower() : null);
            return true;
        }
        return false;
    }

    @SideOnly(Side.CLIENT)
    @Override
    public void renderImpact(@NotNull World world, @NotNull IBulletEntity bullet) {
        ParticleBuilder glitter = new ParticleBuilder(10);
        glitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));
        glitter.disableMotionCalculation();
        glitter.setCollision(true);
        ParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 100, 0, (i, build) -> {
            build.setLifetime(RandUtil.nextInt(20, 40));
            build.setColorFunction(new InterpColorHSV(Color.RED, Color.CYAN));
            build.setAlphaFunction(new InterpFadeInOut(0f, 1f));
            build.setScaleFunction(new InterpScale(RandUtil.nextFloat(0.2f, 0.8f), 0));
            build.setDeceleration(new Vec3d(0.7, 0.7, 0.7));
            double radius = 2 * RandUtil.nextFloat();
            double theta = 2.0f * (float) Math.PI * RandUtil.nextFloat();
            double x = radius * MathHelper.cos((float) theta);
            double z = radius * MathHelper.sin((float) theta);
            build.setMotion(new Vec3d(x, RandUtil.nextDouble(-2, 2), z));
        });
    }

    @SideOnly(Side.CLIENT)
    @Override
    public void renderUpdate(@NotNull World world, @NotNull IBulletEntity bullet) {
        ParticleBuilder glitter = new ParticleBuilder(10);
        glitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));
        glitter.setCollision(true);
        glitter.disableMotionCalculation();
        glitter.disableRandom();
        ParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 1, 0, (i, build) -> {
            build.setScaleFunction(new InterpScale(0.5f, 0));
            build.setColorFunction(new InterpColorHSV(Color.GREEN, Color.CYAN));
        });
    }

    @Override
    @Nullable
    public SoundEvent getImpactSound() {
        return RandUtil.nextInt(100000) == 0 ? ModSounds.BONE : ModSounds.HEAL_TWINKLE;
    }
}

```


Overlapping Code:
```
ents BulletEffect {
@Override
public String getID() {
return "attractive";
}
@Override
public boolean onCollideEntity(@NotNull World world, @NotNull IBulletEntity bullet, @NotNull Entity hitEntity) {
if (hitEntity instanceof EntityAnimal) {
((EntityAnimal) hitEntity).setInLove(bullet.getEntityThrower() instanceof EntityPlayer ? (EntityPlayer) bullet.getEntityThrower() : null);
return true;
}
return false;
}
@SideOnly(Side.CLIENT)
@Override
public void renderImpact(@NotNull World world, @NotNull IBulletEntity bullet) {
ParticleBuilder glitter = new ParticleBuilder(10);
glitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));
glitter.disableMotionCalculation();
glitter.setCollision(true);
ParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 100, 0, (i, build) -> {
build.setLifetime(RandUtil.nextInt(20, 40));
build.setColorFunction(new InterpColorHSV(Color.RED, Color.CYAN));
build.setAlphaFunction(new InterpFadeInOut(0f, 1f));
build.setScaleFunction(new InterpScale(RandUtil.nextFloat(0.2f, 0.8f), 0));
build.setDeceleration(new Vec3d(0.7, 0.7, 0.7));
double radius = 2 * RandUtil.nextFloat();
double theta = 2.0f * (float) Math.PI * RandUtil.nextFloat();
double x = radius * MathHelper.cos((float) theta);
double z = radius * MathHelper.sin((float) theta);
build.setMotion(new Vec3d(x, RandUtil.nextDouble(-2, 2), z));
});
}
@SideOnly(Side.CLIENT)
@Override
public void renderUpdate(@NotNull World world, @NotNull IBulletEntity bullet) {
ParticleBuilder glitter = new ParticleBuilder(10);
glitter.setRender(ClientEventHandler.getResource(world, bullet, ClientEventHandler.HEART));
glitter.setCollision(true);
glitter.disableMotionCalculation();
glitter.disableRandom();
ParticleSpawner.spawn(glitter, world, new StaticInterp<>(bullet.getPositionAsVector()), 1, 0, (i, build) -> {
build.setScaleFunction(new InterpScale(0.5f, 0));
build.setColorFunction(new InterpColorHSV(Colo
```
<Overlap Ratio: 0.9262062440870388>

---

--- 130 --
Question ID: d55baea88f5220601a1f7762d2dc42a9e59e67e8
Original Code:
```
public class SendMessageTransaction {

    private IconService iconService;

    private Wallet wallet;

    private SendMessageTransaction() {
        HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
        logging.setLevel(HttpLoggingInterceptor.Level.BODY);
        OkHttpClient httpClient = new OkHttpClient.Builder().addInterceptor(logging).build();
        iconService = new IconService(new HttpProvider(httpClient, Constants.SERVER_URL, 3));
        wallet = KeyWallet.load(Constants.privateKey);
    }

    private void sendTransaction() throws IOException {
        BigInteger networkId = BigInteger.valueOf(3);
        Address fromAddress = wallet.getAddress();
        Address toAddress = Constants.testAddress1;
        BigInteger nonce = BigInteger.valueOf(1);
        String message = "Hello World";
        // make a raw transaction without the stepLimit
        Transaction transaction = TransactionBuilder.newBuilder().nid(networkId).from(fromAddress).to(toAddress).nonce(nonce).message(message).build();
        // get an estimated step value
        BigInteger estimatedStep = iconService.estimateStep(transaction).execute();
        // make a signed transaction with the same raw transaction and the estimated step
        SignedTransaction signedTransaction = new SignedTransaction(transaction, wallet, estimatedStep);
        Bytes hash = iconService.sendTransaction(signedTransaction).execute();
        System.out.println("txHash: " + hash);
        TransactionResult result = Utils.getTransactionResult(iconService, hash);
        System.out.println("status: " + result.getStatus());
    }

    public static void main(String[] args) throws IOException {
        new SendMessageTransaction().sendTransaction();
    }
}

```


Overlapping Code:
```
sageTransaction {
private IconService iconService;
private Wallet wallet;
private SendMessageTransaction() {
HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
logging.setLevel(HttpLoggingInterceptor.Level.BODY);
OkHttpClient httpClient = new OkHttpClient.Builder().addInterceptor(logging).build();
iconService = new IconService(new HttpProvider(httpClient, Constants.SERVER_URL, 3));
wallet = KeyWallet.load(Constants.privateKey);
}
private void sendTransaction() throws IOException {
BigInteger networkId = BigInteger.valueOf(3);
Address fromAddress = wallet.getAddress();
Address toAddress = Constants.testAddress1;
BigInteger nonce = BigInteger.valueOf(1);
String message = "Hello World";
// make a raw transaction without the stepLimit
Transaction transaction = TransactionBuilder.newBuilder()d();
// get an estimated step value
BigInteger estimatedStep = iconService.estimateStep(transaction).execute();
// make a signed transaction with the same raw transaction and the estimated step
SignedTransaction signedTransaction = new SignedTransaction(transaction, wallet, estimatedStep);
Bytes hash = iconService.sendTransaction(signedTransaction).execute();
System.out.println("txHash: " + hash);
TransactionResult result = Utils.getTransactionResult(iconService, hash);
System.out.println("status: " + result.getStatus());
}
public static void main(String[] args) throws IOException {
new SendMe
```
<Overlap Ratio: 0.9079201545396007>

---

--- 131 --
Question ID: 60326de5da5cf57c599ba2b10b06462f073332a3
Original Code:
```
public class APIResponse {

    private String responseMessage;

    private int responseCode;

    private String body;

    APIResponse(int responseCode, String responseMessage, String body) {
        this.responseCode = responseCode;
        this.responseMessage = responseMessage;
        this.body = body;
    }

    public static APIResponse fromConnection(HttpURLConnection conn) throws IOException {
        final int responseCode = conn.getResponseCode();
        final String responseMessage = conn.getResponseMessage();
        String body;
        if (responseCode == HttpURLConnection.HTTP_OK) {
            body = read(conn.getInputStream());
        } else {
            body = read(conn.getErrorStream());
        }
        return new APIResponse(responseCode, responseMessage, body);
    }

    public String getResponseMessage() {
        return responseMessage;
    }

    public int getResponseCode() {
        return responseCode;
    }

    public String getBody() {
        return body;
    }

    public boolean isOK() {
        return responseCode == HttpURLConnection.HTTP_OK;
    }

    public boolean isNotFound() {
        return responseCode == HttpURLConnection.HTTP_NOT_FOUND;
    }

    public boolean isError() {
        return !isOK();
    }

    /**
     * Read an input stream to a String.
     *
     * @param is The input stream.
     * @return The data from the input stream as a String.
     */
    private static String read(InputStream is) {
        if (is == null) {
            return "";
        }
        Scanner scanner = new Scanner(is);
        StringBuilder sb = new StringBuilder();
        for (; scanner.hasNextLine(); ) {
            sb.append(scanner.nextLine());
        }
        return sb.toString();
    }
}

```


Overlapping Code:
```
sponse {
private String responseMessage;
private int responseCode;
private String body;
APIResponse(int responseCode, String responseMessage, String body) {
this.responseCode = responseCode;
this.responseMessage = responseMessage;
this.body = body;
}
public static APIResponse fromConnection(HttpURLConnection conn) throws IOException {
final int responseCode = conn.getResponseCode();
final String responseMessage = conn.getResponseMessage();
String body;
if (responseCode == HttpURLConnection.HTTP_OK) {
body = read(conn.getInputStream());
} else {
body = read(conn.getErrorStream());
}
return new APIResponse(responseCode, responseMessage, body);
}
public String getResponseMessage() {
return responseMessage;
}
public int getResponseCode() {
return responseCode;
}
public String getBody() {
return body;
}
public boolean isOK() {
return responseCode == HttpURLConnection.HTTP_OK;
}
public boolean isNotFound() {
return responseCode == HttpURLConnection.HTTP_NOT_FOUND;
}
public boolean isError() {
return !isOK();
}
/**
* Read an input stream to a String.
*
* @param is The input stream.
* @return The data from the input stream as a String.
*/
private static String read(InputStream is) {
if (is == null) {
return "";
}
Scannew Scanner(is);
StringBuilder sb = new StringBuilb.append(scanner.nextLine());
}
return sb.toString();
}
```
<Overlap Ratio: 0.9460992907801419>

---

--- 132 --
Question ID: 54ecda69bf301ee6df3cd3d351eb78aa768b8338
Original Code:
```
public class InferenceFrame<V extends Value> extends Frame<V> {

    private V lostValue;

    public InferenceFrame(int nLocals, int nStack) {
        super(nLocals, nStack);
    }

    public InferenceFrame(Frame<? extends V> src) {
        super(src);
    }

    public V getLostValue() {
        return lostValue;
    }

    public void setLostValue(V lostValue) {
        this.lostValue = lostValue;
    }

    @SuppressWarnings("unchecked")
    @Override
    public Frame<V> init(Frame<? extends V> src) {
        if (!(src instanceof InferenceFrame)) {
            throw new IllegalArgumentException("InferenceFrame expected");
        }
        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>) src;
        super.init(inferenceFrame);
        this.lostValue = inferenceFrame.lostValue;
        return this;
    }

    @SuppressWarnings("unchecked")
    @Override
    public boolean merge(Frame<? extends V> frame, Interpreter<V> interpreter) throws AnalyzerException {
        if (!(frame instanceof InferenceFrame)) {
            throw new IllegalArgumentException("InferenceFrame expected");
        }
        InferenceFrame<V> inferenceFrame = (InferenceFrame<V>) frame;
        boolean changed = super.merge(frame, interpreter);
        if (lostValue == null) {
            lostValue = inferenceFrame.lostValue;
            changed |= lostValue != null;
        } else if (inferenceFrame.lostValue != null) {
            V newLostValue = interpreter.merge(lostValue, inferenceFrame.lostValue);
            changed |= lostValue != newLostValue;
            lostValue = newLostValue;
        }
        return changed;
    }
}

```


Overlapping Code:
```
s Value> extends Frame<V> {
private V lostValue;
public InferenceFrame(int nLocals, int nStack) {
super(nLocals, nStack);
}
public InferenceFrame(Frame<? extends V> src) {
super(src);
}
public V getLostValue() {
return lostValue;
}
public void setLostValue(V lostValue) {
this.lostValue = lostValue;
}
@SuppressWarnings("unchecked")
@Override
public Frame<V> init(Frame<? extends V> src) {
if (!(src instanceof InferenceFrame)) {
throw new IllegalArgumentException("InferenceFrame expected");
}
InferenceFrc;
super.init(inferenceFrame);
this.lostValue = inferenceFrame.lostValue;
return this;
}
@SuppressWarnings("unchecked")
@Override
public boolean merge(Frame<? extends V> frame, Interpreter<V> interpreter) throws AnalyzerException {
if (!(frame instanceof InferenceFrame)) {
throw new IllegalArgumentException("InferenceFrame expected");
}
InferenceF
boolean changed = super.merge(frame, interpreter);
if (lostValue == null) {
lostValue = inferenceFrame.lostValue;
changed |= lostValue != null;
} else if (inferenceFrame.lostValue != null) {
V newLostValue = interpreter.merge(lostValue, inferenceFrame.lostValue);
changed |= lostValue != newLostValue;
lostValue = newLostValue;
}
return changed;
}
}
```
<Overlap Ratio: 0.9005979073243647>

---

--- 133 --
Question ID: 67b397e218f28a428fff73d04687e53b5722b22e
Original Code:
```
public class RDateTest {

    @Test
    public void testOf1() {
        assertEquals(RMonth.Vendemiaire, RDate.of(1, RMonth.Vendemiaire, 1).getMonth());
        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, null, 1));
        assertThrows(RepublicanCalendarException.class, () -> RDate.of(-5, null, 1));
        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 0, 7));
        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 14, 7));
        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 0));
        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, -1));
        assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 31));
    }

    @Test
    public void testOf2() {
        assertEquals(RMonth.Vendemiaire, RDate.of(1, 1, 1).getMonth());
        assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, 0, 1));
        assertEquals(RDate.of(58, RMonth.Floreal, 1), RDate.of(58, 8, 1));
    }

    @Test
    public void testOf3() {
        assertThrows(RepublicanCalendarException.class, () -> RDate.of(LocalDate.of(1650, 1, 1)));
    }

    @Test
    public void testOfInvalidSpecialDay() {
        assertThrows(RepublicanCalendarException.class, () -> RDate.of(3, RMonth.Sanculottide, 7));
        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6));
        assertThrows(RepublicanCalendarException.class, () -> RDate.of(4, RMonth.Sanculottide, 6));
        assertNotNull(RDate.of(4, RMonth.Sanculottide, 5));
    }

    @Test
    public void testDecade() {
        assertEquals(1, RDate.of(6, RMonth.Floreal, 1).getDecade());
        assertEquals(1, RDate.of(6, RMonth.Floreal, 4).getDecade());
        assertEquals(1, RDate.of(6, RMonth.Floreal, 10).getDecade());
        assertEquals(2, RDate.of(6, RMonth.Floreal, 11).getDecade());
        assertEquals(2, RDate.of(6, RMonth.Floreal, 14).getDecade());
        assertEquals(2, RDate.of(6, RMonth.Floreal, 20).getDecade());
        assertEquals(3, RDate.of(6, RMonth.Floreal, 21).getDecade());
        assertEquals(3, RDate.of(6, RMonth.Floreal, 24).getDecade());
        assertEquals(3, RDate.of(6, RMonth.Floreal, 30).getDecade());
    }

    @Test
    public void testIsBefore() {
        RDate d1 = RDate.of(6, RMonth.Floreal, 4);
        RDate d2 = RDate.of(6, RMonth.Floreal, 5);
        assertTrue(d1.isBefore(d2));
        assertFalse(d2.isBefore(d1));
        assertFalse(d1.isBefore(d1));
        assertTrue(d1.isBefore(RDate.of(7, 1, 1)));
        assertFalse(d1.isBefore(RDate.of(5, 12, 29)));
    }

    @Test
    public void testIsSextile() {
        assertFalse(RDate.of(1, RMonth.Floreal, 4).isSextile());
        assertFalse(RDate.of(2, RMonth.Floreal, 4).isSextile());
        assertTrue(RDate.of(3, RMonth.Floreal, 4).isSextile());
        assertFalse(RDate.of(4, RMonth.Floreal, 4).isSextile());
        assertFalse(RDate.of(5, RMonth.Floreal, 4).isSextile());
        assertTrue(RDate.of(7, RMonth.Floreal, 4).isSextile());
        assertTrue(RDate.of(11, RMonth.Floreal, 4).isSextile());
        assertTrue(RDate.of(15, RMonth.Floreal, 4).isSextile());
        assertTrue(RDate.of(20, RMonth.Floreal, 4).isSextile());
        assertFalse(RDate.of(21, RMonth.Floreal, 4).isSextile());
        assertFalse(RDate.of(22, RMonth.Floreal, 4).isSextile());
        assertFalse(RDate.of(23, RMonth.Floreal, 4).isSextile());
        assertTrue(RDate.of(24, RMonth.Floreal, 4).isSextile());
        assertFalse(RDate.of(100, RMonth.Floreal, 4).isSextile());
        assertFalse(RDate.of(200, RMonth.Floreal, 4).isSextile());
        assertFalse(RDate.of(300, RMonth.Floreal, 4).isSextile());
        assertTrue(RDate.of(400, RMonth.Floreal, 4).isSextile());
    }

    @Test
    public void testIsSpecialDay() {
        assertTrue(RDate.of(3, RMonth.Sanculottide, 6).isSpecialDay());
        assertFalse(RDate.of(3, RMonth.Thermidor, 30).isSpecialDay());
    }

    @Test
    public void testGetSpecialDay() {
        assertNotNull(RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());
        assertEquals(Revolution, RDate.of(3, RMonth.Sanculottide, 6).getSpecialDay());
        assertNull(RDate.of(3, RMonth.Thermidor, 30).getSpecialDay());
    }

    @Test
    public void testPlusDays_success() {
        assertEquals(RDate.of(1, 1, 1), RDate.of(1, 1, 1).plusDays(0));
        assertEquals(RDate.of(1, 1, 2), RDate.of(1, 1, 1).plusDays(1));
        assertEquals(RDate.of(1, 8, 1), RDate.of(1, 1, 1).plusDays(7 * 30));
        assertEquals(RDate.of(2, 1, 1), RDate.of(1, 1, 1).plusDays(365));
    }

    @Test
    public void testPlusDays_invalid() {
        assertThrows(RuntimeException.class, () -> RDate.of(1, 1, 1).plusDays(-1));
    }

    @Test
    public void testCompareTo() {
        RDate rd = RDate.of(12, RMonth.Brumaire, 18);
        assertEquals(-1, rd.compareTo(null));
        assertTrue(rd.compareTo(RDate.of(13, 2, 18)) < 0);
        assertTrue(rd.compareTo(RDate.of(11, 2, 18)) > 0);
        assertTrue(rd.compareTo(RDate.of(12, 3, 18)) < 0);
        assertTrue(rd.compareTo(RDate.of(12, 1, 18)) > 0);
        assertTrue(rd.compareTo(RDate.of(12, 2, 19)) < 0);
        assertTrue(rd.compareTo(RDate.of(12, 2, 17)) > 0);
        assertEquals(0, rd.compareTo(RDate.of(12, 2, 18)));
    }

    @Test
    public void testEquals() {
        RDate rd1 = RDate.of(12, RMonth.Brumaire, 18);
        RDate rd2 = RDate.of(12, 2, 18);
        assertEquals(rd1, rd2);
        assertNotEquals(rd1, new Object());
        assertNotEquals(rd1, null);
        assertEquals(rd2.hashCode(), rd1.hashCode());
    }
}

```


Overlapping Code:
```
teTest {
@Test
public void testOf1() {
assertEquals(RMonth.Vendemiaire, RDate.of(1, RMonth.Vendemiaire, 1).getMonth());
assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, null, 1));
assertThrows(RepublicanCalendarException.class, () -> RDate.of(-5, null, 1));
assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 0, 7));
assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 14, 7));
assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 0));
assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, -1));
assertThrows(RepublicanCalendarException.class, () -> RDate.of(12, 4, 31));
}
@Test
public void testOf2() {
assertEquals(RMonth.Vendemiaire, RDate.of(1, 1, 1).getMonth());
assertThrows(RepublicanCalendarException.class, () -> RDate.of(1, 0, 1));
assertEquals(RDate.of(58, RMonth.Floreal, 1), RDate.of(58, 8, 1));
}
@Test
public void testOf3() {
assertThrows(RepublicanCalendarException.class, () -> RDate.of(LocalDate.of(16cialDay() {
assertThrows(RepublicanCalendarException.class, () -> RDate.of(3, RMonth.Sanculottide, 7));
assertNotNull(RDate.of(3, RMonth.Sanculottide, 6));
assertThrows(RepublicanCalendarException.class, () -> RDate.of(4, RMonth.Sanculottide, 6));
assertNotNull(RDate.of(4, RMonth.Sanculottide, 5));
}
@Test
public void testDecade() {
assertEquals(1, RDate.of(6, RMonth.Floreal, 1).getDecade());
assertEquals(1, RDate.of(6, RMonth.Floreal, 4).getDecade());
assertEquals(1, RDate.of(6, RMonth.Floreal, 10).getDecade());
assertEquals(2, RDate.of(6, RMonth.Floreal, 11).getDecade());
assertEquals(2, RDate.of(6, RMonth.Floreal, 14).getDecade());
assertEquals(2, RDate.of(6, RMonth.Floreal, 20).getDecade());
assertEquals(3, RDate.of(6, RMonth.Floreal, 21).getDecade());
assertEquals(3, RDate.of(6, RMonth.Floreal, 24).getDecade());
assertEquals(3, RDate.of(6, RMonth.Floreal, 30).getDecade());
}
@Test
public void testIsBefore() {
RDate d1 = RDate.of(6, RMonth.Floreal, 4);
RDate d2 = RDate.of(6, RMonth.Floreal, 5);
assertTrue(d1.isBefore(d2));
assertFalse(d2.isBefore(d1));
assertFalse(d1.isBefore(d1)
```
<Overlap Ratio: 0.9646302250803859>

---

--- 134 --
Question ID: 475d786aedd10b146cce1f943e4de0d4c30628a6
Original Code:
```
final public class IpConnectivityMetrics extends SystemService {

    private static final String TAG = IpConnectivityMetrics.class.getSimpleName();

    private static final boolean DBG = false;

    // "version" field of IpConnectivityLog.
    private static final int NYC = 0;

    private static final int NYC_MR1 = 1;

    private static final int NYC_MR2 = 2;

    public static final int VERSION = NYC_MR2;

    private static final String SERVICE_NAME = IpConnectivityLog.SERVICE_NAME;

    // Default size of the event buffer. Once the buffer is full, incoming events are dropped.
    private static final int DEFAULT_BUFFER_SIZE = 2000;

    // Maximum size of the event buffer.
    private static final int MAXIMUM_BUFFER_SIZE = DEFAULT_BUFFER_SIZE * 10;

    private static final int MAXIMUM_CONNECT_LATENCY_RECORDS = 20000;

    private static final int ERROR_RATE_LIMITED = -1;

    //  - flushing the buffer content and replacing it by a new buffer.
    private final Object mLock = new Object();

    @VisibleForTesting
    public final Impl impl = new Impl();

    @VisibleForTesting
    NetdEventListenerService mNetdListener;

    @GuardedBy("mLock")
    private ArrayList<ConnectivityMetricsEvent> mBuffer;

    @GuardedBy("mLock")
    private int mDropped;

    @GuardedBy("mLock")
    private int mCapacity;

    @GuardedBy("mLock")
    private final ArrayMap<Class<?>, TokenBucket> mBuckets = makeRateLimitingBuckets();

    private final ToIntFunction<Context> mCapacityGetter;

    public IpConnectivityMetrics(Context ctx, ToIntFunction<Context> capacityGetter) {
        super(ctx);
        mCapacityGetter = capacityGetter;
        initBuffer();
    }

    public IpConnectivityMetrics(Context ctx) {
        this(ctx, READ_BUFFER_SIZE);
    }

    @Override
    public void onStart() {
        if (DBG)
            Log.d(TAG, "onStart");
    }

    @Override
    public void onBootPhase(int phase) {
        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
            if (DBG)
                Log.d(TAG, "onBootPhase");
            mNetdListener = new NetdEventListenerService(getContext());
            publishBinderService(SERVICE_NAME, impl);
            publishBinderService(mNetdListener.SERVICE_NAME, mNetdListener);
        }
    }

    @VisibleForTesting
    public int bufferCapacity() {
        return mCapacityGetter.applyAsInt(getContext());
    }

    private void initBuffer() {
        synchronized (mLock) {
            mDropped = 0;
            mCapacity = bufferCapacity();
            mBuffer = new ArrayList<>(mCapacity);
        }
    }

    private int append(ConnectivityMetricsEvent event) {
        if (DBG)
            Log.d(TAG, "logEvent: " + event);
        synchronized (mLock) {
            final int left = mCapacity - mBuffer.size();
            if (event == null) {
                return left;
            }
            if (isRateLimited(event)) {
                // Do not count as a dropped event. TODO: consider adding separate counter
                return ERROR_RATE_LIMITED;
            }
            if (left == 0) {
                mDropped++;
                return 0;
            }
            mBuffer.add(event);
            return left - 1;
        }
    }

    private boolean isRateLimited(ConnectivityMetricsEvent event) {
        TokenBucket tb = mBuckets.get(event.data.getClass());
        return (tb != null) && !tb.get();
    }

    private String flushEncodedOutput() {
        final ArrayList<ConnectivityMetricsEvent> events;
        final int dropped;
        synchronized (mLock) {
            events = mBuffer;
            dropped = mDropped;
            initBuffer();
        }
        final List<IpConnectivityEvent> protoEvents = IpConnectivityEventBuilder.toProto(events);
        if (mNetdListener != null) {
            mNetdListener.flushStatistics(protoEvents);
        }
        final byte[] data;
        try {
            data = IpConnectivityEventBuilder.serialize(dropped, protoEvents);
        } catch (IOException e) {
            Log.e(TAG, "could not serialize events", e);
            return "";
        }
        return Base64.encodeToString(data, Base64.DEFAULT);
    }

    /**
     * Clears the event buffer and prints its content as a protobuf serialized byte array
     * inside a base64 encoded string.
     */
    private void cmdFlush(FileDescriptor fd, PrintWriter pw, String[] args) {
        pw.print(flushEncodedOutput());
    }

    /**
     * Prints the content of the event buffer, either using the events ASCII representation
     * or using protobuf text format.
     */
    private void cmdList(FileDescriptor fd, PrintWriter pw, String[] args) {
        final ArrayList<ConnectivityMetricsEvent> events;
        synchronized (mLock) {
            events = new ArrayList(mBuffer);
        }
        if (args.length > 1 && args[1].equals("proto")) {
            for (IpConnectivityEvent ev : IpConnectivityEventBuilder.toProto(events)) {
                pw.print(ev.toString());
            }
            if (mNetdListener != null) {
                mNetdListener.listAsProtos(pw);
            }
            return;
        }
        for (ConnectivityMetricsEvent ev : events) {
            pw.println(ev.toString());
        }
        if (mNetdListener != null) {
            mNetdListener.list(pw);
        }
    }

    private void cmdStats(FileDescriptor fd, PrintWriter pw, String[] args) {
        synchronized (mLock) {
            pw.println("Buffered events: " + mBuffer.size());
            pw.println("Buffer capacity: " + mCapacity);
            pw.println("Dropped events: " + mDropped);
        }
        if (mNetdListener != null) {
            mNetdListener.dump(pw);
        }
    }

    private void cmdDefault(FileDescriptor fd, PrintWriter pw, String[] args) {
        if (args.length == 0) {
            pw.println("No command");
            return;
        }
        pw.println("Unknown command " + TextUtils.join(" ", args));
    }

    public final class Impl extends IIpConnectivityMetrics.Stub {

        static final String CMD_FLUSH = "flush";

        static final String CMD_LIST = "list";

        static final String CMD_STATS = "stats";

        // dumpsys.cpp dumps services with "-a" as arguments
        static final String CMD_DUMPSYS = "-a";

        static final String CMD_DEFAULT = CMD_STATS;

        @Override
        public int logEvent(ConnectivityMetricsEvent event) {
            enforceConnectivityInternalPermission();
            return append(event);
        }

        @Override
        public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            enforceDumpPermission();
            if (DBG)
                Log.d(TAG, "dumpsys " + TextUtils.join(" ", args));
            final String cmd = (args.length > 0) ? args[0] : CMD_DEFAULT;
            switch(cmd) {
                case CMD_FLUSH:
                    cmdFlush(fd, pw, args);
                    return;
                case CMD_DUMPSYS:
                // Fallthrough to CMD_LIST when dumpsys.cpp dumps services states (bug reports)
                case CMD_LIST:
                    cmdList(fd, pw, args);
                    return;
                case CMD_STATS:
                    cmdStats(fd, pw, args);
                    return;
                default:
                    cmdDefault(fd, pw, args);
            }
        }

        private void enforceConnectivityInternalPermission() {
            enforcePermission(android.Manifest.permission.CONNECTIVITY_INTERNAL);
        }

        private void enforceDumpPermission() {
            enforcePermission(android.Manifest.permission.DUMP);
        }

        private void enforcePermission(String what) {
            getContext().enforceCallingOrSelfPermission(what, "IpConnectivityMetrics");
        }

        private void enforceNetdEventListeningPermission() {
            final int uid = Binder.getCallingUid();
            if (uid != Process.SYSTEM_UID) {
                throw new SecurityException(String.format("Uid %d has no permission to listen for" + " netd events.", uid));
            }
        }

        @Override
        public boolean registerNetdEventCallback(INetdEventCallback callback) {
            enforceNetdEventListeningPermission();
            if (mNetdListener == null) {
                return false;
            }
            return mNetdListener.registerNetdEventCallback(callback);
        }

        @Override
        public boolean unregisterNetdEventCallback() {
            enforceNetdEventListeningPermission();
            if (mNetdListener == null) {
                // if the service is null, we aren't registered anyway
                return true;
            }
            return mNetdListener.unregisterNetdEventCallback();
        }
    }

    private static final ToIntFunction<Context> READ_BUFFER_SIZE = (ctx) -> {
        int size = Settings.Global.getInt(ctx.getContentResolver(), Settings.Global.CONNECTIVITY_METRICS_BUFFER_SIZE, DEFAULT_BUFFER_SIZE);
        if (size <= 0) {
            return DEFAULT_BUFFER_SIZE;
        }
        return Math.min(size, MAXIMUM_BUFFER_SIZE);
    };

    private static ArrayMap<Class<?>, TokenBucket> makeRateLimitingBuckets() {
        ArrayMap<Class<?>, TokenBucket> map = new ArrayMap<>();
        // one token every minute, 50 tokens max: burst of ~50 events every hour.
        map.put(ApfProgramEvent.class, new TokenBucket((int) DateUtils.MINUTE_IN_MILLIS, 50));
        return map;
    }
}

```


Overlapping Code:
```
l public class IpConnectivityMetrics extends SystemService {
private static final String TAG = IpConnectivityMetrics.class.getSimpleName();
private static final boolean DBG = false;
// "version" field of IpConnectivityLog.
private static final int NYC = 0;
private static final int NYC_MR1 = 1;
private static final int NYC_MR2 = 2;
public static final int VERSION = NYC_MR2;
private static final String SERVICE_NAME = IpConnectivityLog.SERVICE_NAME;
// Default size of the event buffer. Once the buffer is full, incoming events are dropped.
private static final int DEFAULT_BUFFER_SIZE = 2000;
// Maximum size of the event buffer.
private static final int MAXIMUM_BUFFER_SIZE = DEFAULT_BUFFER_SIZE * 10;
private static final int MAXIMUM_CONNECT_LATENCY_RECORDS = 20000;
private static final int the buffer content and replacing it by a new buffer.
private final Object mLock = new Object();
@VisibleForTesting
public final Impl impl = new Impl();
@VisibleForTesting
NetdEventListenerService mNetdListener;
@GuardedBy("mLock")
private ArrayList<ConnectivityMetricsEvent> mBuffer;
@GuardedBy("mLock")
private int mDropped;
@GuardedBy("mLock")
private int mCapacity;
@GuardedBy("mLock")
private final ArrayMap<Class<?>, TokenBucket> mBuckets = makeRateLimitingBuckets();
private final ToIntFunction<Context> mCapacityGetter;
public IpConnectivityMetrics(Context ctx, ToIntFunction<Context> capacityGetter) {
super(ctx);
mCapacityGetter = capacityGetter;
initBuffer();
}
public IpConnectivityMetrics(Context ctx) {
this(ctx, READ_BUFFER_SIZE);
}
@Override
public void od(TAG, "onStart");
}
@Override
public void onBootPhase(int phase) {
if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
se");
mNetdListener = new NetdEventListenerService(getContext());
publishBinderService(SERVICE_NAME, impl);
publishBinderService(mNetdListener.SERVICE_NAME, mNetdListener);
}
}
@VisibleForTesting
public int bufferCapacity() {
return mCapacityGetter.applyAsInt(getContext());
}
private void initBuffer() {
synchro
```
<Overlap Ratio: 0.9408450704225352>

---

--- 135 --
Question ID: 4731e4fd483b82796b665b993ea78c300897dbb5
Original Code:
```
public class TrackBuilderPlugin extends AbstractElementBuilderPlugin {

    /**
     * the logging facility provided by log4j
     */
    private static final Logger logger = LoggerFactory.getLogger(TrackBuilderPlugin.class);

    /**
     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.opencastproject.mediapackage.MediaPackageElement.Type,
     *      org.opencastproject.mediapackage.MediaPackageElementFlavor)
     */
    @Override
    public boolean accept(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {
        return type.equals(MediaPackageElement.Type.Track);
    }

    /**
     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.w3c.dom.Node)
     */
    @Override
    public boolean accept(Node elementNode) {
        String name = elementNode.getNodeName();
        if (name.contains(":")) {
            name = name.substring(name.indexOf(":") + 1);
        }
        return name.equalsIgnoreCase(MediaPackageElement.Type.Track.toString());
    }

    /**
     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(URI,
     *      org.opencastproject.mediapackage.MediaPackageElement.Type,
     *      org.opencastproject.mediapackage.MediaPackageElementFlavor)
     */
    @Override
    public boolean accept(URI uri, MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {
        return MediaPackageElement.Type.Track.equals(type);
    }

    /**
     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromURI(URI)
     */
    @Override
    public MediaPackageElement elementFromURI(URI uri) throws UnsupportedElementException {
        logger.trace("Creating track from " + uri);
        Track track = TrackImpl.fromURI(uri);
        return track;
    }

    /**
     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#newElement(org.opencastproject.mediapackage.MediaPackageElement.Type
     *      ,org.opencastproject.mediapackage.MediaPackageElementFlavor)
     */
    @Override
    public MediaPackageElement newElement(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {
        Track track = new TrackImpl();
        track.setFlavor(flavor);
        return track;
    }

    /**
     * @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromManifest(org.w3c.dom.Node,
     *      org.opencastproject.mediapackage.MediaPackageSerializer)
     */
    @Override
    public MediaPackageElement elementFromManifest(Node elementNode, MediaPackageSerializer serializer) throws UnsupportedElementException {
        String id = null;
        MimeType mimeType = null;
        MediaPackageElementFlavor flavor = null;
        TrackImpl.StreamingProtocol transport = null;
        String reference = null;
        URI url = null;
        long size = -1;
        Checksum checksum = null;
        try {
            // id
            id = (String) xpath.evaluate("@id", elementNode, XPathConstants.STRING);
            // url
            url = serializer.decodeURI(new URI(xpath.evaluate("url/text()", elementNode).trim()));
            // reference
            reference = (String) xpath.evaluate("@ref", elementNode, XPathConstants.STRING);
            // size
            String trackSize = xpath.evaluate("size/text()", elementNode).trim();
            if (!"".equals(trackSize))
                size = Long.parseLong(trackSize);
            // flavor
            String flavorValue = (String) xpath.evaluate("@type", elementNode, XPathConstants.STRING);
            if (StringUtils.isNotEmpty(flavorValue))
                flavor = MediaPackageElementFlavor.parseFlavor(flavorValue);
            // transport
            String transportValue = (String) xpath.evaluate("@transport", elementNode, XPathConstants.STRING);
            if (StringUtils.isNotEmpty(transportValue))
                transport = TrackImpl.StreamingProtocol.valueOf(transportValue);
            // checksum
            String checksumValue = (String) xpath.evaluate("checksum/text()", elementNode, XPathConstants.STRING);
            String checksumType = (String) xpath.evaluate("checksum/@type", elementNode, XPathConstants.STRING);
            if (StringUtils.isNotEmpty(checksumValue) && checksumType != null)
                checksum = Checksum.create(checksumType.trim(), checksumValue.trim());
            // mimetype
            String mimeTypeValue = (String) xpath.evaluate("mimetype/text()", elementNode, XPathConstants.STRING);
            if (StringUtils.isNotEmpty(mimeTypeValue))
                mimeType = MimeTypes.parseMimeType(mimeTypeValue);
            TrackImpl track = TrackImpl.fromURI(url);
            if (StringUtils.isNotBlank(id))
                track.setIdentifier(id);
            // Add url
            track.setURI(url);
            // Add reference
            if (StringUtils.isNotEmpty(reference))
                track.referTo(MediaPackageReferenceImpl.fromString(reference));
            // Set size
            if (size > 0)
                track.setSize(size);
            // Set checksum
            if (checksum != null)
                track.setChecksum(checksum);
            // Set mimetpye
            if (mimeType != null)
                track.setMimeType(mimeType);
            if (flavor != null)
                track.setFlavor(flavor);
            //set transport
            if (transport != null)
                track.setTransport(transport);
            // description
            String description = (String) xpath.evaluate("description/text()", elementNode, XPathConstants.STRING);
            if (StringUtils.isNotBlank(description))
                track.setElementDescription(description.trim());
            // tags
            NodeList tagNodes = (NodeList) xpath.evaluate("tags/tag", elementNode, XPathConstants.NODESET);
            int i = 0;
            while (i < tagNodes.getLength()) try {
                track.addTag(tagNodes.item(i).getTextContent());
            } finally {
                i++;
            }
            // duration
            try {
                String strDuration = (String) xpath.evaluate("duration/text()", elementNode, XPathConstants.STRING);
                if (StringUtils.isNotEmpty(strDuration)) {
                    long duration = Long.parseLong(strDuration.trim());
                    track.setDuration(duration);
                }
            } catch (NumberFormatException e) {
                throw new UnsupportedElementException("Duration of track " + url + " is malformatted");
            }
            // is live
            String strLive = (String) xpath.evaluate("live/text()", elementNode, XPathConstants.STRING);
            if (StringUtils.isNotEmpty(strLive)) {
                boolean live = Boolean.parseBoolean(strLive.trim());
                track.setLive(live);
            }
            // audio settings
            Node audioSettingsNode = (Node) xpath.evaluate("audio", elementNode, XPathConstants.NODE);
            if (audioSettingsNode != null && audioSettingsNode.hasChildNodes()) {
                try {
                    AudioStreamImpl as = AudioStreamImpl.fromManifest(createStreamID(track), audioSettingsNode, xpath);
                    track.addStream(as);
                } catch (IllegalStateException e) {
                    throw new UnsupportedElementException("Illegal state encountered while reading audio settings from " + url + ": " + e.getMessage());
                } catch (XPathException e) {
                    throw new UnsupportedElementException("Error while parsing audio settings from " + url + ": " + e.getMessage());
                }
            }
            // video settings
            Node videoSettingsNode = (Node) xpath.evaluate("video", elementNode, XPathConstants.NODE);
            if (videoSettingsNode != null && videoSettingsNode.hasChildNodes()) {
                try {
                    VideoStreamImpl vs = VideoStreamImpl.fromManifest(createStreamID(track), videoSettingsNode, xpath);
                    track.addStream(vs);
                } catch (IllegalStateException e) {
                    throw new UnsupportedElementException("Illegal state encountered while reading video settings from " + url + ": " + e.getMessage());
                } catch (XPathException e) {
                    throw new UnsupportedElementException("Error while parsing video settings from " + url + ": " + e.getMessage());
                }
            }
            return track;
        } catch (XPathExpressionException e) {
            throw new UnsupportedElementException("Error while reading track information from manifest: " + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            throw new UnsupportedElementException("Unsupported digest algorithm: " + e.getMessage());
        } catch (URISyntaxException e) {
            throw new UnsupportedElementException("Error while reading presenter track " + url + ": " + e.getMessage());
        }
    }

    private String createStreamID(Track track) {
        return "stream-" + (track.getStreams().length + 1);
    }

    @Override
    public String toString() {
        return "Track Builder Plugin";
    }
}

```


Overlapping Code:
```
lderPlugin extends AbstractElementBuilderPlugin {
/**
* the logging facility provided by log4j
*/
private static final Logger logger = LoggerFactory.getLogger(TrackBuilderPlugin.class);
/**
* @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.opencastproject.mediapackage.MediaPackageElement.Type,
* org.opencastproject.mediapackage.MediaPackageElementFlavor)
*/
@Override
public boolean accept(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {
return type.equals(MediaPackageElement.Type.Track);
}
/**
* @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(org.w3c.dom.Node)
*/
@Override
public boolean accept(Node elementNode) {
String name = elementNode.getNodeName();
if (name.contains(":")) {
name = name.substring(name.indexOf(":") + 1);
}
return name.equalsIgnoreCase(MediaPackageElement.Type.Track.toString());
}
/**
* @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#accept(URI,
* org.opencastproject.mediapackage.MediaPackageElement.Type,
* org.opencastproject.mediapackage.MediaPackageElementFlavor)
*/
@Override
public boolean accept(URI uri, MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {
return MediaPackageElement.Type.Track.equals(type);
}
/**
* @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromURI(URI)
*/
@Override
public MediaPackageElement elementFromURI(URI uri) throws UnsupportedElementException {
logger.trace("Creating track from " + uri);
Track track = TrackImpl.fromURI(uri);
return track;
}
/**
* @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#newElement(org.opencastproject.mediapackage.MediaPackageElement.Type
* ,org.opencastproject.mediapackage.MediaPackageElementFlavor)
*/
@Override
public MediaPackageElement newElement(MediaPackageElement.Type type, MediaPackageElementFlavor flavor) {
Track track = new TrackImpl();
track.setFlavor(flavor);
return track;
}
/**
* @see org.opencastproject.mediapackage.elementbuilder.MediaPackageElementBuilderPlugin#elementFromManifest(
```
<Overlap Ratio: 0.984453589391861>

---

--- 136 --
Question ID: 3aeba7a2e5875d961c7b615ed7f977845a528c34
Original Code:
```
@SpringBootApplication
public class AgendabotApplication {

    private final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();

    private final List<String> SCOPES = Collections.singletonList(CalendarScopes.CALENDAR_READONLY);

    public static void main(String[] args) {
        SpringApplication.run(AgendabotApplication.class, args);
    }

    private Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT) throws IOException {
        String CREDENTIALS_FILE_PATH = "/credentials.json";
        InputStream in = AgendabotApplication.class.getResourceAsStream(CREDENTIALS_FILE_PATH);
        GoogleClientSecrets clientSecrets = GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));
        String TOKENS_DIRECTORY_PATH = "tokens";
        GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder(HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES).setDataStoreFactory(new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH))).setAccessType("offline").build();
        return new AuthorizationCodeInstalledApp(flow, new LocalServerReceiver()).authorize("user");
    }

    @Bean
    Calendar getCalendar() throws GeneralSecurityException, IOException {
        NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
        String APPLICATION_NAME = "MyEvent";
        return new Calendar.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT)).setApplicationName(APPLICATION_NAME).build();
    }
}

```


Overlapping Code:
```
cation
public class AgendabotApplication {
private final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();
private final List<String> SCOPES = Collections.singletonList(CalendarScopes.CALENDAR_READONLY);
public static void main(String[] args) {
SpringApplication.run(AgendabotApplication.class, args);
}
private Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT) throws IOException {
String CREDENTIALS_FILE_PATH = "/credentials.json";
InputStream in = AgendabotApplication.class.getResourceAsStream(CREDENTIALS_FILE_PATH);
GoogleClientSecrets clientSecrets = GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));
String TOKENS_DIRECTORY_PATH = "tokens";
GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder(HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES).setDataStoreFactory(new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH))).setAccessType("offline").build();
return new AuthorizationCodeInstalledApp(flow, new LocalServerReceiver()).authorize("user");
}
@Bean
Calendar getCalendar() throws GeneralSecurityException, IOException {
NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
String APPLICATION_NAME = "MyEvent";
return new Calendar.Builder(HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT)).setApplicationName(APPLICATION_NAME).buil
```
<Overlap Ratio: 0.9827089337175793>

---

--- 137 --
Question ID: 8ed1c75425218a94e5c8b30fb96444eeac5d7691
Original Code:
```
public class PointPlot extends Plot2D {

    protected double m_x;

    protected double m_y;

    protected boolean m_first;

    public PointPlot(double x, double y, ChartX chart, Color color) {
        super(chart, color);
        m_maxX = m_minX = m_x = x;
        m_maxY = m_minY = m_y = y;
    }

    public void draw(Graphics g, int minGX, int maxGX, int minGY, int maxGY) {
        g.setColor(m_color);
        int GX = projectX(m_x, minGX, maxGX);
        int GY = projectY(m_y, minGY, maxGY);
        g.fillOval(GX - 5, GY - 5, 10, 10);
    }
}

```


Overlapping Code:
```
xtends Plot2D {
protected double m_x;
protected double m_y;
protectedintPlot(double x, double y, ChartX chart, Color colorolor);
m_maxX = m_minX = m_x = x;
m_maxY = m_minY Graphics g, int minGX, int maxGX, int minGY, int m
```
<Overlap Ratio: 0.4774193548387097>

---

--- 138 --
Question ID: c56eafd18ce46221d394fe0d46db958c396d688c
Original Code:
```
class LogicalFormatValidator extends AbstractDataValidator {

    private static final Pattern booleanPattern = Pattern.compile("[YNTF ]");

    LogicalFormatValidator(final Field field) {
        super(field);
        assert field.getType() == Type.LOGICAL : "Can only be validator for LOGICAL fields";
    }

    /**
     * {@inheritDoc}
     * <p>
     * For a LOGICAL field a {@link Boolean}, or a {@link String} is acceptable. A
     * <code>String</code> is acceptable only if it contains one of Y, N, T, F. The String must not
     * contain leading or trailing spaces.
     */
    public void validate(final Object typedObject) throws DbfLibException {
        if (typedObject instanceof Boolean) {
            return;
        }
        if (typedObject instanceof String) {
            final String booleanString = (String) typedObject;
            if (!booleanPattern.matcher(booleanString).matches()) {
                throw new DataMismatchException("Boolean must be one of Y, N, T, F or a space");
            }
            return;
        }
        throw new DataMismatchException("Cannot write objects of type '" + typedObject.getClass().getName() + "' to a LOGICAL field");
    }
}

```


Overlapping Code:
```
atic final Pattern booleanPattern = Pattern.compile("[YNT
super(field);
assert field.getType() == Type.LOGICAL : "Can only be validator for LOGICAL fields";
}
/**
* {@inheritDoc}
* <p>
* For a LOGICAL field a {@link Boolean}, or a {@link String} is acceptable. A
* <code>String</code> is acceptable only if it contains one of Y, N, T, F. The String must not
* contain leading or trailing spaces.
*/
public vinal String booleanString = (String) typedObject;
st be one of Y, N, T, F or a space");
}
return;
}
throw new DataMismatchException("Cannot write objects of typ
```
<Overlap Ratio: 0.5630585898709036>

---

--- 139 --
Question ID: d4b842cf649bd0cd1ede7fa0da8285f1b5d69bd0
Original Code:
```
public final class SeaSlater64RNG implements RandomnessSource, Serializable {

    private static final long serialVersionUID = 1L;

    private long stateA, stateB;

    /**
     * Creates a new generator seeded using two calls to Math.random().
     */
    public SeaSlater64RNG() {
        setState((long) ((Math.random() - 0.5) * 0x10000000000000L) ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L), (long) ((Math.random() - 0.5) * 0x10000000000000L) ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L));
    }

    /**
     * Constructs this SeaSlater64RNG by using LightRNG's algorithm (SplitMix64) to generate two different values for
     * the two parts of state this has with {@link #setSeed(long)}.
     * @param seed a long that will be used to generate both components of state
     */
    public SeaSlater64RNG(final long seed) {
        setSeed(seed);
    }

    /**
     * Constructs this SeaSlater64RNG by calling {@link #setState(long, long)} on stateA and stateB as given; see that
     * method for the specific details (stateA and stateB are kept as-is unless they are both 0).
     * @param stateA the number to use as the first part of the state; this will be 1 instead if both seeds are 0
     * @param stateB the number to use as the second part of the state
     */
    public SeaSlater64RNG(final long stateA, final long stateB) {
        setState(stateA, stateB);
    }

    @Override
    public final int next(int bits) {
        final long s0 = stateA;
        final long s1 = stateB ^ s0;
        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);
        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);
        stateB = (s1 << 37 | s1 >>> 27);
        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> (64 - bits));
    }

    /**
     * Can return any int, positive or negative, of any size permissible in a 32-bit signed integer.
     * @return any int, all 32 bits are random
     */
    public final int nextInt() {
        final long s0 = stateA;
        final long s1 = stateB ^ s0;
        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);
        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);
        stateB = (s1 << 37 | s1 >>> 27);
        return (int) ((result << 12) - (result << 9 | result >>> 55) >>> 32);
    }

    @Override
    public final long nextLong() {
        final long s0 = stateA;
        final long s1 = stateB ^ s0;
        final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);
        stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);
        stateB = (s1 << 37 | s1 >>> 27);
        return (result << 12) - (result << 9 | result >>> 55);
    }

    /**
     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the
     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just needs to
     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.
     *
     * @return a copy of this RandomnessSource
     */
    @Override
    public SeaSlater64RNG copy() {
        return new SeaSlater64RNG(stateA, stateB);
    }

    /**
     * Sets the state of this generator using one long, running it through LightRNG's algorithm two times to get
     * two longs. If the states would both be 0, state A is assigned 1 instead.
     * @param seed the long to use to produce this generator's state
     */
    public void setSeed(final long seed) {
        long z = seed;
        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;
        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;
        stateA = z ^ (z >>> 31);
        z = (seed + 0x9E3779B97F4A7C15L);
        z = (z ^ (z >>> 30)) * 0xBF58476D1CE4E5B9L;
        z = (z ^ (z >>> 27)) * 0x94D049BB133111EBL;
        stateB = z ^ (z >>> 31);
    }

    public long getStateA() {
        return stateA;
    }

    public void setStateA(long stateA) {
        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;
    }

    public long getStateB() {
        return stateB;
    }

    /**
     * Sets the second part of the state to the given int. As a special case, if the parameter is 0 and stateA is
     * already 0, this will set stateA to 1 and stateB to 0, since both cannot be 0 at the same time. Usually, you
     * should use {@link #setState(long, long)} to set both states at once, but the result will be the same if you call
     * setStateA() and then setStateB() or if you call setStateB() and then setStateA().
     * @param stateB any int
     */
    public void setStateB(long stateB) {
        this.stateB = stateB;
        if ((stateB | stateA) == 0)
            stateA = 1;
    }

    /**
     * Sets the current internal state of this SeaSlater64RNG with three ints, where stateA and stateB can each be any
     * int unless they are both 0 (which will be treated as if stateA is 1 and stateB is 0).
     * @param stateA any int (if stateA and stateB are both 0, this will be treated as 1)
     * @param stateB any int
     */
    public void setState(long stateA, long stateB) {
        this.stateA = (stateA | stateB) == 0 ? 1 : stateA;
        this.stateB = stateB;
    }

    @Override
    public String toString() {
        return "SeaSlater32RNG with stateA 0x" + StringKit.hex(stateA) + "L and stateB 0x" + StringKit.hex(stateB) + 'L';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        SeaSlater64RNG seaSlater64RNG = (SeaSlater64RNG) o;
        if (stateA != seaSlater64RNG.stateA)
            return false;
        return stateB == seaSlater64RNG.stateB;
    }

    @Override
    public int hashCode() {
        final long h = (31L * stateA + stateB);
        return (int) (h ^ h >>> 32);
    }
}

```


Overlapping Code:
```
lic final class SeaSlater64RNG implements RandomnessSource, Serializable {
private static final long serialVersionUID = 1L;
private long stateA, stateB;
/**
* Creates a new generator seeded using two calls to Math.random().
*/
public SeaSlater64RNG() {
setState((long) ((Math.random() - 0.5) * 0x10000000000000L) ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L)(long) ((Math.random() - 0.5) * 0x10000000000000L) ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L));
}
/**
* Constructs this SeaSlater64RNG by using LightRNG's algorithm (SplitMix64) to generate two different values for
* the two parts of state this has with {@link #setSeed(long)}.
* @param seed a long that will be used to generate both components of state
*/
public SeaSlater64RNG(final long seed) {
setSeed(seed);
}
/**
* Constructs this SeaSlater64RNG by calling {@link #setState(long, long)} on stateA and stateB as given; see that
* method for the specific details (stateA and stateB are kept as-is unless they are both 0).
* @param stateA the number to use as the first part of the state; this will be 1 instead if both seeds are 0
* @param stateB the number to use as the second part of the state
*/
public SeaSlater64RNG(final long stateA, final lo
@Override
public final int next(int bits) {
final long s0 = stateA;
final long s1 = stateB ^ s0;
final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);
stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);
stateB = (s1 << 37 | s1 >>> 27);
return (int) ((result << 12) - (result << 9 | result >>> 55) >>> (64 - bits));
}
/**
* Can return any int, positive or negative, of any size permissible in a 32-bit signed integer.
* @return any int, all 32 bits are random
*/
public final int nextInt() {
final long s0 = stateA;
final long s1 = stateB ^ s0;
final long result = (s0 << 7) - (s0 << 5 | s0 >>> 59);
stateA = (s0 << 24 | s0 >>> 40) ^ s1 ^ (s1 << 16);
stateB = (s1 << 37 | s1 >>> 27);
return (int) ((result << 12) - (result << 9 | result >>> 55) >>> 32);
}
@Override
public final long nextLong() {
final long s0 = stateA;
final long s1 = stateB ^ s0;
final long res
```
<Overlap Ratio: 0.9613108784706418>

---

--- 140 --
Question ID: dc2fb05fdd592711ca42fc698fb75e38374df934
Original Code:
```
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2020-05-04T14:59:31.604+02:00")
public class FeatureDistribution {

    @SerializedName("min")
    private BigDecimal min = null;

    @SerializedName("max")
    private BigDecimal max = null;

    @SerializedName("mean")
    private BigDecimal mean = null;

    @SerializedName("stdDev")
    private BigDecimal stdDev = null;

    public FeatureDistribution min(BigDecimal min) {
        this.min = min;
        return this;
    }

    /**
     * Get min
     * @return min
     */
    @ApiModelProperty(value = "")
    public BigDecimal getMin() {
        return min;
    }

    public void setMin(BigDecimal min) {
        this.min = min;
    }

    public FeatureDistribution max(BigDecimal max) {
        this.max = max;
        return this;
    }

    /**
     * Get max
     * @return max
     */
    @ApiModelProperty(value = "")
    public BigDecimal getMax() {
        return max;
    }

    public void setMax(BigDecimal max) {
        this.max = max;
    }

    public FeatureDistribution mean(BigDecimal mean) {
        this.mean = mean;
        return this;
    }

    /**
     * Get mean
     * @return mean
     */
    @ApiModelProperty(value = "")
    public BigDecimal getMean() {
        return mean;
    }

    public void setMean(BigDecimal mean) {
        this.mean = mean;
    }

    public FeatureDistribution stdDev(BigDecimal stdDev) {
        this.stdDev = stdDev;
        return this;
    }

    /**
     * Get stdDev
     * @return stdDev
     */
    @ApiModelProperty(value = "")
    public BigDecimal getStdDev() {
        return stdDev;
    }

    public void setStdDev(BigDecimal stdDev) {
        this.stdDev = stdDev;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        FeatureDistribution featureDistribution = (FeatureDistribution) o;
        return Objects.equals(this.min, featureDistribution.min) && Objects.equals(this.max, featureDistribution.max) && Objects.equals(this.mean, featureDistribution.mean) && Objects.equals(this.stdDev, featureDistribution.stdDev);
    }

    @Override
    public int hashCode() {
        return Objects.hash(min, max, mean, stdDev);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class FeatureDistribution {\n");
        sb.append("    min: ").append(toIndentedString(min)).append("\n");
        sb.append("    max: ").append(toIndentedString(max)).append("\n");
        sb.append("    mean: ").append(toIndentedString(mean)).append("\n");
        sb.append("    stdDev: ").append(toIndentedString(stdDev)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(java.lang.Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }
}

```


Overlapping Code:
```
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2020-05-04T14:59:31.604+02:00")
public class FeatureDistribution {
@SerializedName("min")
private BigDecimal min = null;
@SerializedName("max")
private BigDecimal max = null;
@SerializedName("mean")
private BigDecimal mean = null;
@SerializedName("stdDev")
private BigDecimal stdDev = null;
public FeatureDistribution min(BigDecimal min) {
this.min = min;
return this;
}
/**
* Get min
* @return min
*/
@ApiModelProperty(value = "")
public BigDecimal getMin() {
return min;
}
public void setMin(BigDecimal min) {
this.min = min;
}
public FeatureDistribution max(BigDecimal max) {
this.max = max;
return this;
}
/**
* Get max
* @return max
*/
@ApiModelProperty(value = "")
public BigDecimal getMax() {
return max;
}
public void setMax(BigDecimal max) {
this.max = max;
}
public FeatureDistribution mean(BigDecimal mean) {
this.mean = mean;
re*/
@ApiModelProperty(value = "")
public BigDecimal getMean() {
return mean;
}
public void setMean(BigDecimal mean) {
this.mean = mean;
}
public FeatureDistribution stdDev(BigDecimal stdDev) {
this.stdDev = stdDev;
return this;
}
/**
* Get stdDev
* @return */
@ApiModelProperty(value = "")
public BigDecimal getStdDev() {
return stdDev;
}
public void setStdDev(BigDecimal stdDev) {
this.stdDev = stdDev;
}
@Override
public boolean equals(java.lang.Object o) {
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
FeatureDistribution featureDistribution = (FeatureDistribution) o;
return Objects.equals(this.quals(this.stdDev, featureDistribution.stdDev);
}
@Override
public int hashCode() {
return Objects.hash(min, max, mean, stdDev);
}
@Override
public String toString() {
StringBuilder sb = new StringBuilder();
sb.append("cla
```
<Overlap Ratio: 0.9001996007984032>

---

--- 141 --
Question ID: b7d655e96b2368219f57e0cb9f77e5529aa81369
Original Code:
```
public class FixLengthConf {

    public List<FixLengthMessageIn> getConf() {
        List<FixLengthMessageIn> flconf = new ArrayList<FixLengthMessageIn>();
        Resource resource = new ClassPathResource("classpath:FixLengthConfig.xml");
        try {
            // File fXmlFile = readXml(resource.getInputStream());
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            // Document doc = dBuilder.parse(fXmlFile);
            Document doc = readXml(resource.getInputStream());
            // http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work
            doc.getDocumentElement().normalize();
            System.out.println("Root element :" + doc.getDocumentElement().getNodeName());
            NodeList nList = doc.getElementsByTagName("field");
            System.out.println("----------------------------");
            int temp = 0;
            while (temp < nList.getLength()) try {
                Node nNode = nList.item(temp);
                if (nNode.getNodeType() == Node.ELEMENT_NODE) {
                    Element eElement = (Element) nNode;
                    //					System.out.println("end : " + eElement.getElementsByTagName("end").item(0).getTextContent());
                    flconf.add(new FixLengthMessageIn(eElement.getAttribute("name").toString(), eElement.getElementsByTagName("start").item(0).getTextContent().toString(), eElement.getElementsByTagName("end").item(0).getTextContent().toString(), ""));
                }
            } finally {
                temp++;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return flconf;
    }

    public static Document readXml(InputStream is) throws SAXException, IOException, ParserConfigurationException {
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        dbf.setValidating(false);
        dbf.setIgnoringComments(false);
        dbf.setIgnoringElementContentWhitespace(true);
        dbf.setNamespaceAware(true);
        DocumentBuilder db = null;
        db = dbf.newDocumentBuilder();
        db.setEntityResolver(new NullResolver());
        return db.parse(is);
    }
}

```


Overlapping Code:
```
lass FixLengthConf {
public List<FixLengthMessageIn> getConf() {
List<FixLengthMessageIn> flconf = new ArrayList<FixLengthMessageIn>();
Resource resource = new ClassPathResource("classpath:FixLengthColFile = readXml(resource.getInputStream());
DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
// Document doc = dBuilder.parse(fXmlFile);
Document doc = readXml(resourc
// http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work
doc.getDocumentElement().normalize();
System.out.println("Root element :" + doc.getDocumentElement().getNodeName());
NodeList nList = doc.getElementsByTagName("field");
System.out.println("----------------------------");
int  {
Node nNode = nList.item(temp);
if (nNode.getNodeType() == Node.ELEMENT_NODE) {
Element eElement = (Element) nNode;
// System.out.printlnnd : " + eElement.getElementsByTagName("end").item(0).getTextContent());
flconf.add(new FixLengthMessageIn(eElement.getAttrElement.getElementsByTagName("start").item(0).getTextContent().toString()Name("end").item(0).getTextContent().toString(), "++;
}
} catch (Exception e) {
e.printStackTrace();
}
return flconf;
}
public static Document readXml(InputStream is) throws SAXException, IOException, ParserConfigurationException {
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setValidating(false);
dbf.setIgnoringComments(false);
dbf.setIgnoringElementContentWhitespace(true);
dbf.setNamespaceAware(true);
DocumentBuilder db = null;
db = dbf.newDocumentBuilder();
db.setEntityResolver(new NullResolver()
```
<Overlap Ratio: 0.8867313915857605>

---

--- 142 --
Question ID: e1ad45857a9b1ea21e59ac0936bf389b3c285f6b
Original Code:
```
public class SegmenterTest {

    public static Segmenter.Data dataEmpty;

    static {
        try {
            dataEmpty = new Segmenter.Data(new JSONObject("{}"), Collections.emptyList(), null, 0L);
        } catch (JSONException ex) {
            ex.printStackTrace();
            System.exit(1);
        }
    }

    public static Segmenter.Data dataWithInstallation(Segmenter.Data data, JSONObject installation) {
        return new Segmenter.Data(installation, data.allEvents, data.presenceInfo, data.lastAppOpenDate);
    }

    public static Segmenter.Data dataWithAllEvents(Segmenter.Data data, List<JSONObject> allEvents) {
        return new Segmenter.Data(data.installation, allEvents, data.presenceInfo, data.lastAppOpenDate);
    }

    public static Segmenter.Data dataWithPresenceInfo(Segmenter.Data data, Segmenter.PresenceInfo presenceInfo) {
        return new Segmenter.Data(data.installation, data.allEvents, presenceInfo, data.lastAppOpenDate);
    }

    public static Segmenter.Data dataWithLastAppOpenDate(Segmenter.Data data, long lastAppOpenDate) {
        return new Segmenter.Data(data.installation, data.allEvents, data.presenceInfo, lastAppOpenDate);
    }

    public static Segmenter.Data dataWithInstallationDiff(Segmenter.Data data, JSONObject installationDiff, boolean nullFieldRemoves) {
        try {
            JSONObject installation = new JSONObject(data.installation.toString());
            JSONUtil.merge(installation, installationDiff, nullFieldRemoves);
            return dataWithInstallation(data, installation);
        } catch (JSONException ex) {
            throw new RuntimeException(ex);
        }
    }

    public static Segmenter.Data dataWithNewerEvent(Segmenter.Data data, JSONObject newerEvent) {
        List<JSONObject> allEvents = new ArrayList<>(data.allEvents.size() + 1);
        String newerEventType = JSONUtil.getString(newerEvent, "type");
        if (newerEventType == null)
            throw new RuntimeException("missing event type");
        for (JSONObject event : data.allEvents) {
            String eventType = JSONUtil.getString(event, "type");
            if (!newerEventType.equals(eventType)) {
                allEvents.add(event);
            }
        }
        allEvents.add(newerEvent);
        return dataWithAllEvents(data, allEvents);
    }

    public static Segmenter.Data dataWithTags(Segmenter.Data data, Set<String> tags) {
        try {
            JSONObject installation = new JSONObject(data.installation.toString());
            JSONObject custom = installation.optJSONObject("custom");
            if (custom == null) {
                custom = new JSONObject();
                installation.put("custom", custom);
            }
            custom.put("tags", new JSONArray(tags));
            return new Segmenter.Data(installation, data.allEvents, data.presenceInfo, data.lastAppOpenDate);
        } catch (JSONException ex) {
            throw new RuntimeException(ex);
        }
    }

    @Test
    public void testItShouldMatchMatchAll() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        Segmenter s = new Segmenter(dataEmpty);
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{}"));
        assertThat(s.matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchFieldFooEqNull() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":null}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[null,null]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",null]}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchFieldFooEqFalse() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":false}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":true}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",false]}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchFieldFooEqTrue() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":true}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":true}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",false]}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchFieldFooEq0() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":0}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0.0}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[1,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchFieldFooEq00() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":0.0}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0.0}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[1,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchFieldFooEq1() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":1}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0.0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.0}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[1,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchFieldFooEq10() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":1.0}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0.0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.0}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[1,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchFieldFooEqDecimal() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":1.5}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0.0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.2}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.5}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.7}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":2.0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":2}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[1.5,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchFieldFooEqLong() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":9223372036854775807}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":9223372036854775806}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":9223372036854775807}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":9223372036854775808}"))).matchesInstallation(parsedSegment), is(false));
        // When comparing a long with a double, we loose some precision, it's OK
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":9.223372036854775806e18}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":9.223372036854775807e18}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":9.223372036854775808e18}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":7.000000000000000512e18}}"));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":6999999999999999487}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":6999999999999999488}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":7000000000000000001}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":7000000000000000512}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":7000000000000000513}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchFieldFooEqBigDecimal() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":1e300}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0.0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1e300}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.0e300}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[1e300,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchFieldFooEqBar() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":\"bar\"}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchFieldFooEqEmptystring() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":\"\"}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"bar\",true]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[0,\"\",true]}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchFieldCustomDateFooEqNumber() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        // 1577836800000 is 2020-01-01T00:00:00.000Z
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".custom.date_foo\":{\"eq\":1577836800000}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":null}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":1}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":false}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"foo\"}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":1577836800000}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2029-09-09T09:09:09.009+09:09\"}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01T01:00:00.000+01:00\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01T00:00:00.000Z\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01T00:00:00.000\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01T00:00:00\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01T00:00\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01T00\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020Z\"}}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchFieldCustomDateFooEqDateString() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".custom.date_foo\":{\"eq\":{\"date\":\"2020-01-01T00:00:00.000Z\"}}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":null}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":1}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":false}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"foo\"}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":1577836800000}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2029-09-09T09:09:09.009+09:09\"}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01T01:00:00.000+01:00\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01T00:00:00.000Z\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01T00:00:00.000\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01T00:00:00\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01T00:00\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01T00\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01-01\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020-01\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"custom\":{\"date_foo\":\"2020Z\"}}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchFieldFooComparisonLong() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"gt\":9223372036854775806}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":9223372036854775805}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":9223372036854775806}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":9223372036854775807}"))).matchesInstallation(parsedSegment), is(true));
        // When comparing a long with a double, we loose some precision, it's OK
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":9.223372036854775808e18}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":9.223372036854777000e18}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"lt\":9.223372036854775808e18}}"));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":9223372036854775805}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchFieldFooComparisonIntegers() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment;
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"lt\":0}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":-1}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"lte\":0}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":-1}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"gt\":0}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":-1}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"gte\":0}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":-1}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchFieldFooComparisonFloats() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment;
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"lt\":1.5}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.2}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.5}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.7}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"lte\":1.5}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.2}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.5}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.7}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"gt\":1.5}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.2}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.5}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.7}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"gte\":1.5}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.2}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.5}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1.7}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchFieldFooComparisonStrings() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment;
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"lt\":\"mm\"}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"m\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"ma\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"MM\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"mm\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"mma\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"mz\"}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"lte\":\"mm\"}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"m\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"ma\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"MM\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"mm\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"mma\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"mz\"}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"gt\":\"mm\"}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"m\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"ma\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"MM\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"mm\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"mma\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"mz\"}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"gte\":\"mm\"}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"m\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"ma\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"MM\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"mm\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"mma\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"mz\"}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchFieldFooComparisonMixed() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment;
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"lt\":0}}"));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"lte\":0}}"));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"gt\":0}}"));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"gte\":0}}"));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchFieldFooComparisonBooleans() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment;
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"lt\":true}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":true}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"lte\":true}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":true}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"gt\":true}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":true}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"gte\":true}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":true}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"lt\":false}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":true}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"lte\":false}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":true}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"gt\":false}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":true}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"gte\":false}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":true}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchEventTypeTest() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"event\":{\".type\":{\"eq\":\"test\"}}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithNewerEvent(dataEmpty, new JSONObject("{\"type\":\"@APP_OPEN\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithNewerEvent(dataEmpty, new JSONObject("{\"type\":\"test\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithNewerEvent(dataWithNewerEvent(dataEmpty, new JSONObject("{\"type\":\"@APP_OPEN\"}")), new JSONObject("{\"type\":\"test\"}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchInstallation() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".bar\":{\".sub\":{\"eq\":\"sub\"},\"installation\":{\".foo\":{\"eq\":\"foo\"}}}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"bar\":{\"sub\":\"sub\"}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\",\"bar\":{\"sub\":\"sub\"}}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchEventInstallation() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"event\":{\".type\":{\"eq\":\"test\"},\"installation\":{\".foo\":{\"eq\":\"foo\"}}}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithNewerEvent(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}")), new JSONObject("{\"type\":\"nope\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithNewerEvent(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}")), new JSONObject("{\"type\":\"test\"}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchUser() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"user\":{}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchAnd() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment;
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"eq\":\"foo\"},\".bar\":{\"eq\":\"bar\"}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"bar\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\",\"bar\":\"bar\"}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"and\":[{\".foo\":{\"eq\":\"foo\"}},{\".bar\":{\"eq\":\"bar\"}}]}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"bar\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\",\"bar\":\"bar\"}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchOr() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"or\":[{\".foo\":{\"eq\":\"foo\"}},{\".bar\":{\"eq\":\"bar\"}}]}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"to\":\"to\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"bar\":\"bar\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\",\"bar\":\"bar\"}"))).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchNot() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"not\":{\".foo\":{\"eq\":\"foo\"}}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"bar\":\"bar\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\",\"bar\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldNotMatchUnknownCriterion() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"unknown criterion\":{}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchSubscriptionStatus() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment;
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"subscriptionStatus\":\"optOut\"}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":null}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":null}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":\"FAKE\"}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":\"FAKE\"},\"preferences\":{\"subscriptionStatus\":null}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":\"FAKE\"},\"preferences\":{\"subscriptionStatus\":\"optIn\"}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":\"FAKE\"},\"preferences\":{\"subscriptionStatus\":\"optOut\"}}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"subscriptionStatus\":\"softOptOut\"}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":null}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":\"FAKE\"}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":\"FAKE\"},\"preferences\":{\"subscriptionStatus\":null}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":\"FAKE\"},\"preferences\":{\"subscriptionStatus\":\"optIn\"}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":\"FAKE\"},\"preferences\":{\"subscriptionStatus\":\"optOut\"}}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"subscriptionStatus\":\"optIn\"}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":null}}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":\"FAKE\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":\"FAKE\"},\"preferences\":{\"subscriptionStatus\":null}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":\"FAKE\"},\"preferences\":{\"subscriptionStatus\":\"optIn\"}}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"pushToken\":{\"data\":\"FAKE\"},\"preferences\":{\"subscriptionStatus\":\"optOut\"}}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchLastActivityDate() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment;
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"lastActivityDate\":{\"gt\":1000000000000}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 999999999999L)).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 1000000000000L)).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, 1000000000001L)).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"lastActivityDate\":{\"gt\":{\"date\":\"-PT1M\"}}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithLastAppOpenDate(dataEmpty, TimeSync.getTime())).matchesInstallation(parsedSegment), is(true));
    }

    @Test
    public void testItShouldMatchPresence() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        long now = TimeSync.getTime();
        ASTCriterionNode parsedSegment;
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"presence\":{\"present\":false}}"));
        // no info is considered present since just about now
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(true));
        // not present yet, so not present
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"presence\":{\"present\":true}}"));
        // no info is considered present since just about now
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));
        // not present yet, so not present
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"presence\":{\"present\":false,\"elapsedTime\":{\"gt\":1000}}}"));
        // no info is considered present since just about now
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(true));
        // not present yet, so not present, and it will last 60s, so we pass
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"presence\":{\"present\":true,\"elapsedTime\":{\"gt\":1000}}}"));
        // no info is considered present since just about now
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));
        // not present yet, so not present
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"presence\":{\"present\":false,\"elapsedTime\":{\"lt\":1000}}}"));
        // no info is considered present since just about now
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));
        // not present yet, so not present
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"presence\":{\"present\":true,\"elapsedTime\":{\"lt\":1000}}}"));
        // no info is considered present since just about now
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 60000, 60000))).matchesInstallation(parsedSegment), is(false));
        // not present yet, so not present
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"presence\":{\"present\":false,\"sinceDate\":{\"lte\":{\"date\":\"-PT1M\"}}}}"));
        // no info is considered present since just about now
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));
        // not present yet, but leave date is not lte -PT1M
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"presence\":{\"present\":true,\"sinceDate\":{\"lte\":{\"date\":\"-PT1M\"}}}}"));
        // no info is considered present since just about now
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 30000, now + 60000, 90000))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now + 60000, 180000))).matchesInstallation(parsedSegment), is(true));
        // not present yet, so not present
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"presence\":{\"present\":false,\"sinceDate\":{\"gte\":{\"date\":\"-PT1M\"}}}}"));
        // no info is considered present since just about now
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now + 60000, 120000))).matchesInstallation(parsedSegment), is(false));
        // not present yet, and leave date is gte -PT1M
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 120000, now + 180000, 60000))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\"presence\":{\"present\":true,\"sinceDate\":{\"gte\":{\"date\":\"-PT1M\"}}}}"));
        // no info is considered present since just about now
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now - 100000, 20000))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 60000, now - 30000, 30000))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 30000, now + 60000, 90000))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now - 120000, now + 60000, 180000))).matchesInstallation(parsedSegment), is(false));
        // not present yet, but leave date is gte -PT1M
        assertThat(new Segmenter(dataWithPresenceInfo(dataEmpty, new Segmenter.PresenceInfo(now + 60000, now + 120000, 60000))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchPrefix() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment;
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"prefix\":\"fo\"}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"fo\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"f\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"FOO\"}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"prefix\":\"fo\"}}"));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchAny() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment;
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"any\":[]}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"any\":[1]}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,\"foo\"]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1,\"foo\"]}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"any\":[1,\"foo\"]}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,\"foo\"]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1,\"foo\"]}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"any\":[1,null]}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,null]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1,null]}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"any\":[null]}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,null]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1,null]}"))).matchesInstallation(parsedSegment), is(false));
    }

    @Test
    public void testItShouldMatchAll() throws JSONException, BadInputError, UnknownValueError, UnknownCriterionError {
        ASTCriterionNode parsedSegment;
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"all\":[]}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"all\":[1]}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,\"foo\"]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1,\"foo\"]}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"all\":[1,\"foo\"]}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,\"foo\"]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1,\"foo\"]}"))).matchesInstallation(parsedSegment), is(true));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"all\":[1,null]}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,null]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1,null]}"))).matchesInstallation(parsedSegment), is(false));
        parsedSegment = Segmenter.parseInstallationSegment(new JSONObject("{\".foo\":{\"all\":[null]}}"));
        assertThat(new Segmenter(dataEmpty).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"bar\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":\"foo\"}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":null}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":false}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":0}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":1}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[]}"))).matchesInstallation(parsedSegment), is(true));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,null]}"))).matchesInstallation(parsedSegment), is(false));
        assertThat(new Segmenter(dataWithInstallation(dataEmpty, new JSONObject("{\"foo\":[\"bar\",false,1,null]}"))).matchesInstallation(parsedSegment), is(false));
    }
}

```


Overlapping Code:
```
);
} catch (JSONException ex) {
ex.printStackTrace();
System.exit(1);
}
}
public static Son);
} catch (JSONException ex) {
throw new RuntimeException(ex);
}
}
public static Se
```
<Overlap Ratio: 0.0824693685202639>

---

--- 143 --
Question ID: 95739590f6b06a260225dba9dd818b49155e72a0
Original Code:
```
public class BaseWebSettings {

    /**
     * ?????
     */
    public static void defaultInit(WebSettings webSettings) {
        //??????????Javascript????webview??????Javascript
        webSettings.setJavaScriptEnabled(true);
        //????JS?????
        webSettings.setJavaScriptCanOpenWindowsAutomatically(true);
        //????????webview???,?????????????????????
        webSettings.setUseWideViewPort(true);
        // ????????
        webSettings.setLoadWithOverviewMode(true);
        //?????.NARROW_COLUMNS:??????
        webSettings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN);
        //????????true??????????
        webSettings.setSupportZoom(true);
        //???????false???WebView????
        webSettings.setBuiltInZoomControls(true);
        //?????????
        webSettings.setDisplayZoomControls(false);
        //???????,???????
        webSettings.setBlockNetworkImage(false);
        //????????
        webSettings.setLoadsImagesAutomatically(true);
        //??????,utf-8, GBK
        webSettings.setDefaultTextEncodingName("utf-8");
        //????????, ??, ??????
        webSettings.setTextSize(WebSettings.TextSize.NORMAL);
        //????????????, ??100
        webSettings.setTextZoom(100);
        //????,???????
        webSettings.setDomStorageEnabled(false);
        //??,??,??,css,js...
        webSettings.setAppCacheEnabled(true);
        //??????
        webSettings.setAppCachePath(ConfigUtils.APPLICATION.getCacheDir().getAbsolutePath());
        /*
         * ???????
         * ???cache-control?
         *   cache-control??????????????,???????????????.
         *   ??????public(?????????),
         *   private(???????????),
         *   no-cache(??????????),
         *   max-age=xxx(??????? xxx ????)??
         *
         * WebSettings.LOAD_CACHE_ELSE_NETWORK  ???????????????no-cache??????????
         * WebSettings.LOAD_CACHE_ONLY          ?????
         * WebSettings.LOAD_DEFAULT             ??cache-control???????????
         * WebSettings.LOAD_NO_CACHE            ?????
         * WebSettings.LOAD_NORMAL
         */
        webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);
        /**
         * ???
         */
        webSettings.setDatabaseEnabled(true);
        /**
         * ????
         */
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            /**
             * MIXED_CONTENT_ALWAYS_ALLOW???????????????????????
             * MIXED_CONTENT_NEVER_ALLOW????Https??Http??????????????????????????
             * MIXED_CONTENT_COMPATIBILITY_MODE????????????WebView ????????Web???????
             */
            webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);
        }
        //????????
        webSettings.setAllowFileAccess(true);
        //????
        webSettings.setSavePassword(false);
        //??????????
        webSettings.setGeolocationEnabled(true);
        /*
         * ??WebView????????????(swf?)?? ON_DEMAND ????????????
         * ?????????????????????????????
         * ?????????????. ??OFF.
         */
        webSettings.setPluginState(WebSettings.PluginState.ON_DEMAND);
    }
}

```


Overlapping Code:
```
avascript
webSettings.setJavaScriptEnabled(true);
/
webSettings.setJavaScriptCanOpenWindowsAutomatically(true);
//
webSettings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN);
//
webSettings.setDefaultTextEncodingName("utf-8");

webSettings.setTextSize(WebSettings.TextSize.NORMe);
//??,??,??,css,js...
webSettings.setAppCacheEnppCachePath(ConfigUtils.APPLICATION.getCacheDir().
*/
webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);

*/
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
/**
```
<Overlap Ratio: 0.2669425763062597>

---

--- 144 --
Question ID: 225847a731ab9bc895536af2abea87cf195f916c
Original Code:
```
@DynamicSerialize
public class FFMPBasinData {

    public static final double GUIDANCE_MISSING = -999999.0;

    // defaults
    @DynamicSerializeElement
    private String hucLevel;

    @DynamicSerializeElement
    private Map<Long, FFMPBasin> basins = new HashMap<Long, FFMPBasin>();

    /**
     * Pending load tasks that need to be run to fully populate basins
     */
    private final List<LoadTask> tasks = new ArrayList<LoadTask>();

    /**
     * Cache of basins in order for easy population from Load Tasks.
     */
    private final Map<String, FFMPBasin[]> orderedBasinsCache = new HashMap<String, FFMPBasin[]>();

    /**
     * Shared factory for efficient storage of data in basins.
     */
    private BasinMapFactory<Date> mapFactory = null;

    /**
     * Public one arg constructor
     *
     * @param huc_level
     */
    public FFMPBasinData(String hucLevel) {
        setHucLevel(hucLevel);
    }

    /**
     * No arg hibernate constructor
     */
    public FFMPBasinData() {
    }

    /**
     * get the basin map
     *
     * @return
     */
    public Map<Long, FFMPBasin> getBasins() {
        if (!tasks.isEmpty()) {
            loadNow();
        }
        return basins;
    }

    /**
     * Sets the basin map
     *
     * @param basins
     */
    public void setBasins(Map<Long, FFMPBasin> basins) {
        if (!tasks.isEmpty()) {
            synchronized (tasks) {
                tasks.clear();
                orderedBasinsCache.clear();
            }
        }
        this.basins = basins;
    }

    /**
     * Gets the HUC Level for this map
     *
     * @return
     */
    public String getHucLevel() {
        return hucLevel;
    }

    /**
     * Sets the HUC Level for this map
     */
    public void setHucLevel(String hucLevel) {
        this.hucLevel = hucLevel;
    }

    /**
     * Add to the hash
     *
     * @param key
     * @param basin
     */
    public void put(Long key, FFMPBasin basin) {
        getBasins().put(key, basin);
    }

    /**
     * Gets the FFMPBasin from the hash
     *
     * @param key
     * @return
     */
    public FFMPBasin get(Long key) {
        return getBasins().get(key);
    }

    /**
     * Gets a list of pfaf ids from the keys
     *
     * @return
     */
    public List<Long> getPfafIds() {
        return new ArrayList<Long>(getBasins().keySet());
    }

    /**
     * Extracts the average value for an aggregation of basins
     *
     * @param pfaf_ids
     * @param startDate
     * @param finishDate
     * @return
     */
    public float getAverageValue(ArrayList<Long> pfaf_ids, Date beforeDate, Date afterDate) {
        float tvalue = 0.0f;
        int i = 0;
        Map<Long, FFMPBasin> localBasins = getBasins();
        for (Long pfaf : pfaf_ids) {
            FFMPBasin basin = localBasins.get(pfaf);
            if (basin != null) {
                tvalue += basin.getValue(beforeDate, afterDate);
                i++;
            }
        }
        tvalue = tvalue / i;
        return tvalue;
    }

    /**
     * Extracts the average value for an aggregation of basins
     *
     * @param pfaf_ids
     * @param exact
     *            date
     * @return
     */
    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date) {
        float tvalue = 0.0f;
        int i = 0;
        Map<Long, FFMPBasin> localBasins = getBasins();
        for (long pfaf : pfaf_ids) {
            FFMPBasin basin = localBasins.get(pfaf);
            if (basin != null) {
                tvalue += basin.getValue(date);
                i++;
            }
        }
        tvalue = tvalue / i;
        return tvalue;
    }

    /**
     * Extracts the average value for an aggregation of basins
     *
     * @param pfaf_ids
     * @param date
     * @param expirationTime
     * @return
     */
    public float getAverageValue(ArrayList<Long> pfaf_ids, Date date, long epirationTime) {
        float tvalue = 0.0f;
        int i = 0;
        for (Long pfaf : pfaf_ids) {
            FFMPBasin basin = getBasins().get(pfaf);
            if (basin != null) {
                tvalue += basin.getAverageValue(date, epirationTime);
                i++;
            }
        }
        tvalue = tvalue / i;
        return tvalue;
    }

    /**
     * Extracts the average value for an aggregation of basins with areal
     * weighting
     *
     * @param pfaf_ids
     * @return
     */
    public float getAverageValue(ArrayList<Long> pfaf_ids, ArrayList<Double> areas) {
        float tvalue = 0.0f;
        float tarea = 0.0f;
        int i = 0;
        Map<Long, FFMPBasin> localBasins = getBasins();
        for (Long pfaf : pfaf_ids) {
            FFMPBasin basin = localBasins.get(pfaf);
            if (basin != null) {
                if (basin.getValue() != FFMPUtils.MISSING) {
                    tvalue += (basin.getValue() * areas.get(i));
                    tarea += areas.get(i);
                }
            }
        }
        if (tvalue < 0.0f) {
            tvalue = FFMPUtils.MISSING;
        } else {
            tvalue = tvalue / tarea;
        }
        return tvalue;
    }

    /**
     * Extracts the average value for an aggregation of basins to a given time
     *
     * @param pfaf_ids
     * @return
     */
    public float getAccumAverageValue(List<Long> pfaf_ids, Date beforeDate, Date afterDate, long expirationTime, boolean rate) {
        float tvalue = 0.0f;
        int i = 0;
        Map<Long, FFMPBasin> localBasins = getBasins();
        for (Long pfaf : pfaf_ids) {
            FFMPBasin basin = localBasins.get(pfaf);
            if (basin != null) {
                tvalue += basin.getAccumValue(beforeDate, afterDate, expirationTime, rate);
                i++;
            }
        }
        tvalue = tvalue / i;
        return tvalue;
    }

    /**
     * Extracts the Max value for a range of times in an aggregation of basins
     *
     * @param pfaf_ids
     * @param hour
     * @return
     */
    public float getMaxValue(ArrayList<Long> pfaf_ids, Date beforeDate, Date afterDate) {
        float tvalue = 0.0f;
        Map<Long, FFMPBasin> localBasins = getBasins();
        for (Long pfaf : pfaf_ids) {
            FFMPBasin basin = localBasins.get(pfaf);
            if (basin != null) {
                Float value = basin.getValue(beforeDate, afterDate);
                if (value > tvalue) {
                    tvalue = value;
                }
            }
        }
        return tvalue;
    }

    /**
     * Used for mosaic sources
     *
     * @param pfaf_ids
     * @param date
     * @param expiration
     * @return
     */
    public float getAverageMaxValue(List<Long> pfaf_ids, Date date, long expiration) {
        float tvalue = 0.0f;
        Map<Long, FFMPBasin> localBasins = getBasins();
        for (Long pfaf : pfaf_ids) {
            FFMPBasin basin = localBasins.get(pfaf);
            if (basin != null) {
                Float value = basin.getAverageValue(date, expiration);
                if (value > tvalue) {
                    tvalue = value;
                }
            }
        }
        return tvalue;
    }

    /**
     * Used for mosaic sources
     *
     * @param pfaf_ids
     * @param date
     * @param expiration
     * @return
     */
    public float getAverageMaxValue(ArrayList<Long> pfaf_ids, Date afterDate, Date beforeDate) {
        float tvalue = 0.0f;
        Map<Long, FFMPBasin> localBasins = getBasins();
        for (Long pfaf : pfaf_ids) {
            FFMPBasin basin = localBasins.get(pfaf);
            if (basin != null) {
                Float value = basin.getAverageValue(afterDate, beforeDate);
                if (value > tvalue) {
                    tvalue = value;
                }
            }
        }
        return tvalue;
    }

    /**
     * Extracts the Max value for a specific time in an aggregation of basins
     *
     * @param pfaf_ids
     * @param hour
     * @return
     */
    public float getMaxValue(List<Long> pfaf_ids, Date date) {
        float tvalue = 0.0f;
        Map<Long, FFMPBasin> localBasins = getBasins();
        for (Long pfaf : pfaf_ids) {
            FFMPBasin basin = localBasins.get(pfaf);
            if (basin != null) {
                Float value = basin.getValue(date);
                if (value > tvalue) {
                    tvalue = value;
                }
            }
        }
        return tvalue;
    }

    /**
     * Average Guidance
     *
     * @param pfaf_ids
     * @param sourceName
     * @return
     */
    public float getAverageGuidanceValue(List<Long> pfaf_ids, FFMPGuidanceInterpolation interpolation, float guidance, List<Long> forcedPfafs, long expiration) {
        float tvalue = 0.0f;
        float value;
        int i = 0;
        Map<Long, FFMPBasin> localBasins = getBasins();
        for (Long pfaf : pfaf_ids) {
            FFMPBasin basin = localBasins.get(pfaf);
            if (basin == null) {
                return guidance;
            }
            if (basin != null) {
                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;
                if (forcedPfafs.contains(pfaf)) {
                    if (interpolation.isInterpolate()) {
                        value = fgb.getInterpolatedValue(interpolation, expiration);
                    } else {
                        value = fgb.getValue(interpolation.getStandardSource(), interpolation, expiration);
                    }
                    // ignore missing values
                    if (value < -999) {
                        continue;
                    }
                    tvalue += value;
                    i++;
                } else {
                    if (interpolation.isInterpolate()) {
                        float nvalue;
                        if (new Float(guidance).isNaN()) {
                            nvalue = fgb.getInterpolatedValue(interpolation, expiration);
                        } else {
                            nvalue = guidance;
                        }
                        if (nvalue > 0.0f) {
                            tvalue += nvalue;
                        }
                        i++;
                    } else {
                        if (new Float(guidance).isNaN()) {
                            value = fgb.getValue(interpolation.getStandardSource(), interpolation, expiration);
                        } else {
                            value = guidance;
                        }
                        if (value > 0.0f) {
                            tvalue += value;
                        }
                        i++;
                    }
                }
            }
        }
        if (tvalue == 0.0f) {
            return Float.NaN;
        }
        return tvalue / i;
    }

    /**
     * Extracts the Max value for a guidance aggregation of basins THIS IS
     * BACKWARDS FROM LOGIC THOUGH!!!!, lower GUIDANCE values are actually worse
     *
     * @param pfaf_ids
     * @param sourceName
     * @return
     */
    public float getMaxGuidanceValue(List<Long> pfaf_ids, FFMPGuidanceInterpolation interpolation, long expiration, long parentPfaf) {
        float tvalue = Float.NaN;
        Map<Long, FFMPBasin> localBasins = getBasins();
        for (Long pfaf : pfaf_ids) {
            FFMPBasin basin = localBasins.get(pfaf);
            if (basin != null) {
                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;
                fgb.setCountyFips(parentPfaf);
                if (interpolation.isInterpolate()) {
                    float nvalue = fgb.getInterpolatedValue(interpolation, expiration);
                    // ignore missing values
                    if (nvalue < -999) {
                        continue;
                    }
                    if (((nvalue < tvalue) && (nvalue > 0.0f)) || Float.isNaN(tvalue)) {
                        tvalue = nvalue;
                    }
                } else {
                    float value = fgb.getValue(interpolation.getStandardSource(), interpolation, expiration);
                    // ignore missing values
                    if (value < -999) {
                        continue;
                    }
                    if (((value < tvalue) && (value > 0.0f)) || Float.isNaN(tvalue)) {
                        tvalue = value;
                    }
                }
            }
        }
        if (tvalue == 0.0f) {
            tvalue = Float.NaN;
        }
        return tvalue;
    }

    /**
     * Extracts the Accumulated Max value for an aggregation of basins
     *
     * @param pfaf_ids
     * @param beforeDate
     * @param afterDate
     * @return
     */
    public float getAccumMaxValue(List<Long> pfaf_ids, Date beforeDate, Date afterDate, long expirationTime, boolean rate) {
        float tvalue = 0.0f;
        Map<Long, FFMPBasin> localBasins = getBasins();
        for (Long pfaf : pfaf_ids) {
            FFMPBasin basin = localBasins.get(pfaf);
            if (basin != null) {
                float val = basin.getAccumValue(afterDate, beforeDate, expirationTime, rate);
                if (val > tvalue) {
                    tvalue = val;
                }
            }
        }
        return tvalue;
    }

    /**
     * used for max ratio and diff calcs
     *
     * @param pfaf_ids
     * @param interpolation
     * @return
     */
    public List<Float> getGuidanceValues(List<Long> pfaf_ids, FFMPGuidanceInterpolation interpolation, long expiration) {
        List<Float> values = new ArrayList<Float>();
        Map<Long, FFMPBasin> localBasins = getBasins();
        for (Long pfaf : pfaf_ids) {
            FFMPBasin basin = localBasins.get(pfaf);
            if (basin != null) {
                FFMPGuidanceBasin fgb = (FFMPGuidanceBasin) basin;
                if (interpolation.isInterpolate()) {
                    values.add(fgb.getInterpolatedValue(interpolation, expiration));
                } else {
                    values.add(fgb.getValue(interpolation.getStandardSource(), interpolation, expiration));
                }
            }
        }
        return values;
    }

    /**
     * Gets the average guidance value for an aggregate basin
     *
     * @param pfaf_ids
     * @param interpolation
     * @param expiration
     * @return
     */
    public Float getAverageGuidanceValue(List<Long> pfaf_ids, FFMPGuidanceInterpolation interpolation, long expiration) {
        float tvalue = 0.0f;
        int i = 0;
        List<Float> vals = getGuidanceValues(pfaf_ids, interpolation, expiration);
        if (vals != null) {
            for (Float val : vals) {
                tvalue += val;
                i++;
            }
        } else {
            return null;
        }
        return tvalue / i;
    }

    /**
     * used for max ratio and diff calcs
     *
     * @param pfaf_ids
     * @param beforeDate
     * @param afterDate
     * @param rate
     * @return
     */
    public List<Float> getAccumValues(List<Long> pfaf_ids, Date beforeDate, Date afterDate, long expirationTime, boolean rate) {
        List<Float> values = new ArrayList<Float>();
        Map<Long, FFMPBasin> localBasins = getBasins();
        for (Long pfaf : pfaf_ids) {
            FFMPBasin basin = localBasins.get(pfaf);
            if (basin != null) {
                values.add(basin.getAccumValue(beforeDate, afterDate, expirationTime, rate));
            }
        }
        return values;
    }

    /**
     * Purge out old data
     *
     * @param date
     */
    public void purgeData(Date date) {
        // cause them to run
        if (!tasks.isEmpty()) {
            synchronized (tasks) {
                Iterator<LoadTask> itr = tasks.iterator();
                {
                    for (; itr.hasNext(); ) {
                        LoadTask task = itr.next();
                        if (task instanceof LoadMapTask) {
                            LoadMapTask mtask = (LoadMapTask) task;
                            if (mtask.date.before(date)) {
                                itr.remove();
                            }
                        }
                    }
                }
                if (tasks.isEmpty()) {
                    orderedBasinsCache.clear();
                }
            }
        }
        for (FFMPBasin basin : basins.values()) {
            basin.purgeData(date);
        }
    }

    /**
     * deserialize data from the aggregate record
     *
     * @param times
     */
    public void populate(List<Long> times) {
        if (mapFactory == null) {
            mapFactory = new BasinMapFactory<Date>(Collections.reverseOrder(), getBasins().size());
        }
        long[] timesArr = new long[times.size()];
        for (int i = 0; i < timesArr.length; i += 1) {
            timesArr[i] = times.get(i);
        }
        for (FFMPBasin basin : getBasins().values()) {
            basin.deserialize(timesArr, mapFactory);
        }
    }

    /**
     * populates the serialized array/objects
     */
    public void serialize() {
        for (FFMPBasin basin : getBasins().values()) {
            basin.serialize();
        }
    }

    /**
     * Add basins some basins from a datastoreFile. The basins will not be
     * loaded immediately, they will be loaded when they are needed.
     *
     * @param datastoreFile
     *            - the file containing data.
     * @param uri
     *            - datauri of record to load
     * @param siteKey
     *            - siteKey to load
     * @param cwa
     *            - cwa to load
     * @param huc
     *            - huc to load
     * @param sourceName
     *            - the sourceName for the data.
     * @param date
     *            - the date of the data.
     * @param orderedPfafs
     *            - a collection of Longs which is in the same order as the data
     *            in the dataStore.
     * @param aggregate
     */
    public void addBasins(File datastoreFile, String uri, String siteKey, String cwa, String huc, String sourceName, Date date, Collection<Long> orderedPfafs, boolean aggregate) {
        SourceXML source = FFMPSourceConfigurationManager.getInstance().getSource(sourceName);
        boolean guidance = source.getSourceType().equals(SOURCE_TYPE.GUIDANCE.getSourceType());
        String basinsKey = siteKey + ' ' + cwa + ' ' + huc;
        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa + DataStoreFactory.DEF_SEPARATOR + huc;
        synchronized (tasks) {
            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);
            if (basins == null) {
                basins = new FFMPBasin[orderedPfafs.size()];
                int j = 0;
                for (Long pfaf : orderedPfafs) {
                    FFMPBasin basin = this.basins.get(pfaf);
                    if (basin == null) {
                        if (guidance) {
                            basin = new FFMPGuidanceBasin(pfaf, aggregate);
                        } else {
                            if (mapFactory == null) {
                                mapFactory = new BasinMapFactory<Date>(Collections.reverseOrder(), orderedPfafs.size());
                            }
                            basin = new FFMPBasin(pfaf, aggregate, mapFactory);
                        }
                        this.basins.put(pfaf, basin);
                    }
                    basins[j++] = basin;
                }
                this.orderedBasinsCache.put(basinsKey, basins);
            }
            if (guidance) {
                tasks.add(new LoadGuidanceMapTask(datastoreFile, datasetGroupPath, basins, date, sourceName));
            } else {
                tasks.add(new LoadMapTask(datastoreFile, datasetGroupPath, basins, date));
            }
        }
    }

    /**
     * Add virtual basins from a datastoreFile. The basins will not be loaded
     * immediately, they will be loaded when they are needed.
     *
     * @param datastoreFile
     *            - the file containing data.
     * @param uri
     *            - datauri of record to load
     * @param dataKey
     *            - dataKey to load
     * @param cwa
     *            - cwa to load
     * @param date
     *            - the date of the data.
     * @param orderedMetadata
     *            - a collection of FFMPVirtualGageBasinMetaData which is in the
     *            same order as the data in the dataStore.
     */
    public void addVirtualBasins(File datastoreFile, String uri, String dataKey, String cwa, Date date, Collection<FFMPVirtualGageBasinMetaData> orderedMetadata) {
        String basinsKey = dataKey + ' ' + cwa;
        String datasetGroupPath = uri + DataStoreFactory.DEF_SEPARATOR + cwa + DataStoreFactory.DEF_SEPARATOR + FFMPRecord.ALL;
        synchronized (tasks) {
            FFMPBasin[] basins = this.orderedBasinsCache.get(basinsKey);
            if (basins == null) {
                basins = new FFMPBasin[orderedMetadata.size()];
                int j = 0;
                for (FFMPVirtualGageBasinMetaData fvgbmd : orderedMetadata) {
                    FFMPBasin basin = this.basins.get(fvgbmd.getLookupId());
                    if (basin == null) {
                        basin = new FFMPVirtualGageBasin(fvgbmd.getLid(), fvgbmd.getParentPfaf(), false);
                        this.basins.put(fvgbmd.getLookupId(), basin);
                    }
                    basins[j++] = basin;
                }
                this.orderedBasinsCache.put(basinsKey, basins);
            }
            tasks.add(new LoadVirtualMapTask(datastoreFile, datasetGroupPath, basins, date));
        }
    }

    /**
     * Returns whether or not any basins have been put in the basins map. Faster
     * than calling getBasins().size() or getBasins().isEmpty().
     *
     * @return
     */
    public boolean hasAnyBasins() {
        return !basins.isEmpty();
    }

    /**
     * Load now.
     */
    public void loadNow() {
        synchronized (tasks) {
            if (!tasks.isEmpty()) {
                FFMPDataRecordLoader.loadRecords(tasks);
                tasks.clear();
                orderedBasinsCache.clear();
            }
        }
    }

    /**
     * Base task for loading data from a dataRecord into FFMPBasins
     */
    private class LoadMapTask extends LoadTask {

        protected final FFMPBasin[] basins;

        protected final Date date;

        public LoadMapTask(File datastoreFile, String datasetGroupPath, FFMPBasin[] basins, Date date) {
            super(datastoreFile, datasetGroupPath);
            this.basins = basins;
            this.date = date;
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void process(FloatDataRecord record) {
            float[] values = record.getFloatData();
            for (int j = 0; j < values.length; j += 1) {
                applyValue(basins[j], values[j]);
            }
        }

        /**
         * Apply the value to the basin/
         */
        protected void applyValue(FFMPBasin basin, float value) {
            if (basin.contains(date)) {
                float curval = basin.getValue(date);
                // These are QPF and QPE so, 0.0 is a valid amount
                if (curval >= 0.0f && value >= 0.0f) {
                    basin.setValue(date, (curval + value) / 2);
                } else if (value >= 0.0f) {
                    basin.setValue(date, value);
                }
            } else {
                // no value at time exists, write regardless
                basin.setValue(date, value);
            }
        }
    }

    /**
     * Task for loading data from a dataRecord into FFMPGuidanceBasins
     */
    private class LoadGuidanceMapTask extends LoadMapTask {

        private final String sourceName;

        public LoadGuidanceMapTask(File datastoreFile, String datasetGroupPath, FFMPBasin[] basins, Date date, String sourceName) {
            super(datastoreFile, datasetGroupPath, basins, date);
            this.sourceName = sourceName;
        }

        @Override
        protected void applyValue(FFMPBasin basin, float value) {
            FFMPGuidanceBasin gBasin = (FFMPGuidanceBasin) basin;
            Float curval = gBasin.getValue(date, sourceName);
            if (curval != FFMPUtils.MISSING && !curval.isNaN()) {
                // average of original and new value
                if (curval > 0.0f && value > 0.0f) {
                    gBasin.setValue(sourceName, date, (curval + value) / 2);
                } else {
                    // curval zero, overwrite original value
                    if (curval == 0.0f) {
                        gBasin.setValue(sourceName, date, value);
                    }
                }
            } else {
                // curval NaN or MISSING, Overwrite original value
                gBasin.setValue(sourceName, date, value);
            }
        }
    }

    /**
     * Task for loading data from a dataRecord into FFMPVirtualGageBasins
     */
    private class LoadVirtualMapTask extends LoadMapTask {

        public LoadVirtualMapTask(File datastoreFile, String datasetGroupPath, FFMPBasin[] basins, Date date) {
            super(datastoreFile, datasetGroupPath, basins, date);
        }

        @Override
        protected void applyValue(FFMPBasin basin, float value) {
            basin.setValue(date, value);
        }
    }
}

```


Overlapping Code:
```
lass FFMPBasinData {
public static final double GUIDANCE_MISSING = -999999.0;
// defaults
@DynamicSerializeElement
private String hucLevel;
@DynamicSerializeElement
private Map<Long, FFMPBasin> basins = new HashMap<Long, FFMPBasin>();
/**
* Pending load tasks that need to be run to fully populate basins
*/
private final List<LoadTask> tasks = new ArrayList<LoadTask>();
/**
* Cache of basins in order for easy population from Load Tasks.
*/
private final Map<String, FFMPBasin[]> orderedBasinsCache = new HashMap<String, FFMPBasin[]>();
/**
* Shared factory for efficient storage of data in basins.
*/
private BasinMapFactory<Date> mapFactory = nulc_level
*/
public FFMPBasinData(String hucLevel) {
setHucLevel(hucLevel);
}
/**
* No arg hibernate constructor
*/
public FFMPBasinData() {
}
/**
* getMPBasin> getBasins() {
if (!tasks.isEmpty()) {
loadNow();
}
return basins;
}
/**
* Sets the basin maLong, FFMPBasin> basins) {
if (!tasks.isEmpty()) {
synchronized (tasks) {
tasks.clear();
orderedBasinsCache.clear();
}
}
this.basins = basins;
}
/**
*ublic String getHucLevel() {
return hucLevel;
}
/**
* Sets the HUC Level for this map
*/
public void setHucLevel(String hucLevel) {
this.hucLevel = hu@param basin
*/
public void put(Long key, FFMPBasin basin) {
getBasins().put(key, basin);
}
/**
* Gereturn
*/
public FFMPBasin get(Long key) {
return getBasins().get(key);
}
/**
* Gets a list of pfaf > getPfafIds() {
return new ArrayList<Long>(getBasins().keySet());
}
/**
* Extracts the average value for an aggregation of ba
```
<Overlap Ratio: 0.7874097007223942>

---

--- 145 --
Question ID: e2ac5750c6ffaf6424160a62dbcfd9d31d5d8011
Original Code:
```
public class LOServer {

    /**
     * Entry point from the command line
     *
     * @param args Command line arguments (currently nothing is supported)
     */
    public static void main(String[] args) {
        Game game = new Game();
        QueuedThreadPool queuedThreadPool = new QueuedThreadPool(200, 8, 60000);
        Javalin app = Javalin.create(config -> config.server(() -> new Server(queuedThreadPool))).start(7000);
        app.routes(() -> {
            get("/api/state", ctx -> ctx.json(game.getState()));
            post("/api/update", ctx -> {
                if (Objects.equals(ctx.contentType(), "application/json")) {
                    List<Integer> list = ctx.bodyAsClass(List.class);
                    game.update(list.get(0), list.get(1));
                    ctx.json(game.getState());
                }
            });
            get("/api/reset", ctx -> {
                game.reset();
                ctx.json(game.getState());
            });
            get("/api/status", ctx -> {
                ctx.result("OK");
            });
        });
    }
}

```


Overlapping Code:
```
/**
* Entry point from the command line
*
* @param args Command line arguments (currently nothing is supported)
*/
public static void main(String[] args) {
Game game = new Game();
QueuedThreadPool queuedThreadPool = new QueuedThreadPool(200, 8, 60000);
Javalin app = Javalin.create(confi000);
app.routes(() -> {
get("/api/state", ctx -> ctx.json(game.getState()));
post("/api/update", ctx -> {
if (Objects.equals(ctx.contentType(), "application/json")) {
List<Integer> list = ctx.bodyAsClass(List.class);
game.update(list.get(0), list.get(1));
ctx.json(game.getState());
}
});
get("/api/reset", ctx -> {
game.reset();
ctx.json(game.getState());
});
get("/api/status", ctx -> {
ctx.result
```
<Overlap Ratio: 0.8663303909205549>

---

--- 146 --
Question ID: f5cc2e0b1cbf8f1821a97d425e7f630fd91e4d34
Original Code:
```
public abstract class ObjProperty extends AbstractParseTreeNode {

    private static final long serialVersionUID = 3384973990326624609L;

    public ObjProperty(StringLiteral name, Expression value) {
        this(FilePosition.span(name.getFilePosition(), value.getFilePosition()), name, value);
    }

    public ObjProperty(FilePosition pos, StringLiteral name, Expression value) {
        super(pos, Expression.class);
        this.createMutation().appendChild(name).appendChild(value).execute();
    }

    /**
     * Provided for reflection.
     * @param value unused
     */
    protected ObjProperty(FilePosition pos, Void value, List<? extends Expression> children) {
        this(pos, (StringLiteral) children.get(0), children.get(1));
        assert children.size() == 2;
    }

    @Override
    public final Object getValue() {
        return null;
    }

    @Override
    public List<? extends Expression> children() {
        return childrenAs(Expression.class);
    }

    public final StringLiteral getPropertyNameNode() {
        return (StringLiteral) children().get(0);
    }

    @Override
    public void childrenChanged() {
        super.childrenChanged();
        if (2 != children().size()) {
            throw new IndexOutOfBoundsException();
        }
        getPropertyName();
    }

    public final String getPropertyName() {
        return ((StringLiteral) children().get(0)).getUnquotedValue();
    }

    public boolean isPropertyNameQuoted() {
        StringLiteral name = (StringLiteral) children().get(0);
        String rawName = name.getValue();
        if (rawName.length() == 0) {
            return false;
        }
        char ch0 = rawName.charAt(0);
        return ch0 == '"' || ch0 == '\'';
    }

    public final TokenConsumer makeRenderer(Appendable out, Callback<IOException> handler) {
        return new JsPrettyPrinter(new Concatenator(out, handler));
    }

    protected final void renderPropertyName(RenderContext rc, boolean preferUnquoted) {
        StringLiteral key = (StringLiteral) children().get(0);
        TokenConsumer out = rc.getOut();
        boolean unquoted = preferUnquoted;
        switch(rc.propertyNameQuotingMode()) {
            case NO_QUOTES:
                unquoted = true;
                break;
            case PRESERVE_QUOTES:
                String name = key.getValue();
                if (name.length() == 0) {
                    unquoted = true;
                } else {
                    char ch = name.charAt(0);
                    if (ch != '"' && ch != '\'') {
                        unquoted = true;
                    }
                }
                break;
            default:
                break;
        }
        if (unquoted || preferUnquoted) {
            String uqVal = key.getUnquotedValue();
            if (ParserBase.isJavascriptIdentifier(uqVal) && !("get".equals(uqVal) || "set".equals(uqVal))) {
                out.mark(key.getFilePosition());
                out.consume(uqVal);
                return;
            }
        }
        key.render(rc);
    }
}

```


Overlapping Code:
```
tends AbstractParseTreeNode {
private static final long serialVersionUID = 3384973990326624609L;
public ObjProperty(StringLiteral name, Expression value) {
this(FilePosition.span(name.getFilePosition(c ObjProperty(FilePosition pos, StringLiteral name, Expression value) {
super(pos, Expression.class);
this.createMutation().appendChild(name).appendChild(value).execute();
}
/**
* Provided for reflection.
* @param value unused
*/
protected ObjPropertePosition pos, Void value, List<? extends Expression> children) {
this(pos, (StringLiteral) children.get(0), children.get(1));
assert children.s Object getValue() {
return null;
}
@Override
public List<? extends Expression> children() {
return childrenAs(Expression.class);
}
public final StringLiteral getPropertyNameNode() {
return (StringLiteral) children().get(0);
}
@Override
public void childrenChanged() {
super.childrenChanged();
if (2 != children().size()) {
throw new IndexOutOfBoundsException();
}
getPropertyName();
}
public final String getPropertyName() {
return ((StringLiteral) children().get(0)).getUnquotedValue();
}
public boolean isPropertyNameQuoted() {
StringLiteral name = (StringLiteral) children().get(0);
String rawName = name.getVa}
char ch0 = rawName.charAt(0);
return ch0 == '"' || ch0 == '\'';
}
public final TokenConsumer makeRdler) {
return new JsPrettyPrinter(new Concatenator(out, handler));
}
protected final void renderProd) {
StringLiteral key = (StringLiteral) children().get(0);
TokenConsumer out = rc.getOut();
booleantValue();
if (name.length() == 0) {
unquoted = tru
```
<Overlap Ratio: 0.7758964143426295>

---

--- 147 --
Question ID: fe322982427c837c12bccb9a2b78b51af11bbe10
Original Code:
```
public class DefaultDockerImageMigrationHandlerTest {

    private static final Node TEST_NODE = Node.EMPTY_OBJECT.editNode().put("foo", "bar").saveNode();

    @Test
    public void invalidConstructorInput() {
        assertThatExceptionOfType(NullPointerException.class).isThrownBy(() -> new DefaultDockerImageMigrationHandler(null));
    }

    @Test
    public void noopMigrationScript() {
        URL url = TestURLBuilder.forContent(noopScript()).build();
        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);
        Node result = migrationHandler.performMigration(TEST_NODE);
        assertThat(result).isEqualTo(TEST_NODE);
    }

    @Test
    public void effectiveMigration() {
        URL url = TestURLBuilder.forContent(script("input.foo = 'baz';")).build();
        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);
        Node result = migrationHandler.performMigration(TEST_NODE);
        assertThat(result).isEqualTo(TEST_NODE.editNode().put("foo", "baz"));
    }

    @Test
    public void globalStateMustBeCleared() {
        URL url = TestURLBuilder.forContent("var globalVar = 0;" + script("input.cpt = globalVar; globalVar++;")).build();
        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);
        Node result = migrationHandler.performMigration(TEST_NODE);
        assertThat(result).isEqualTo(TEST_NODE.editNode().put("cpt", 0));
        result = migrationHandler.performMigration(TEST_NODE);
        assertThat(result).isEqualTo(TEST_NODE.editNode().put("cpt", 0));
    }

    @Test
    public void mustHandleJSONEscapeCharacters() {
        URL url = TestURLBuilder.forContent(noopScript()).build();
        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);
        Node testNode = Node.EMPTY_OBJECT.editNode().put("foo", "{\"\':").saveNode();
        Node result = migrationHandler.performMigration(testNode);
        assertThat(result).isEqualTo(testNode);
    }

    @Test
    public void mustHandleMultiByteCharSequences() {
        URL url = TestURLBuilder.forContent(noopScript()).build();
        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);
        Node testNode = Node.EMPTY_OBJECT.editNode().put("foo", "?").saveNode();
        Node result = migrationHandler.performMigration(testNode);
        assertThat(result).isEqualTo(testNode);
    }

    @Test
    public void invalidScriptMustThrowException() {
        URL url = TestURLBuilder.forContent(script("throw 'invalid script';")).build();
        DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);
        assertThatExceptionOfType(IllegalArgumentException.class).isThrownBy(() -> migrationHandler.performMigration(TEST_NODE));
    }

    private String noopScript() {
        return script("");
    }

    private String script(String content) {
        return "module.exports = function(input) { " + content + "};";
    }
}

```


Overlapping Code:
```
ic class DefaultDockerImageMigrationHandlerTest {
private static final Node TEST_NODE = Node.EMPTY_OBJECT.editNode().put("foo", "bar").saveNode();
@Test
public void invalidConstructorInput() {
assertThatExceptionOfType(NullPointerException.class).isThrownBy(() -> new DefaultDockerImageMigrationHandlt() {
URL url = TestURLBuilder.forContent(noopScript()).build();
DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);
Node result = migrationHandler.performMigration(TEST_NODE);
assertThat(result).isEqualTo(TEST_NODE);
}
@Test
public void effectiveMigration() {
URL url = TestURLBuilder.forContent(script("input.foo = 'baz';")).build();
DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);
Node result = migrationHandler.performMigration(TEST_NODE);
assertThat(result).isEqualTo(TEST_NODE.editNode().put("foo", "baz"));
}
@Test
public void globalStateMustBeCleared() {
URL url = TestURLBuilder.forContent("va globalVar++;")).build();
DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);
Node result = migrationHandler.performMigration(TEST_NODE);
assertThat(result).isEqualTo(TEST_NODE.editNode().put("cpt", 0));
result = migrationHandler.performMigration(TEST_NODE);
assertThat(result).isEqualTo(TEST_NODE.editNode().put("cpt", 0));
}
@Test
public void mustHandleJSONEscapeCharacters() {
URL url = TestURLBuilder.forContent(noopScript()).build();
DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);
Node testNode = Node.EMPTY_OBJECT.editNode().put("foo", "{\"\':").saveNode();
Node result = migrationHandler.performMigration(testNode);
assertThat(result).isEqualTo(testNode);
}
@Test
public void mustHandleMultiByteCharSequences() {
URL url = TestURLBuilder.forContent(noopScript()).build();
DefaultDockerImageMigrationHandler migrationHandler = new DefaultDockerImageMigrationHandler(url);
Node testNode = Node.EM.saveNode();
Node result = migrationHandler.performMigration(te
```
<Overlap Ratio: 0.9292792792792792>

---

--- 148 --
Question ID: 21ca9661f3376f46943fd2a0ddc93a92bb03a6a3
Original Code:
```
public class MvnModelFactory {

    public Model createModel(Project project) throws MvnModelInputException {
        return createModel(project.getProjectDirectory());
    }

    public Model createModel(FileObject projectDir) throws MvnModelInputException {
        FileObject pomFile = projectDir.getFileObject("pom.xml");
        MavenXpp3Reader mavenreader = new MavenXpp3Reader();
        try (Reader reader = new InputStreamReader(pomFile.getInputStream())) {
            Model model = mavenreader.read(reader);
            model.setPomFile(new File(pomFile.getPath()));
            return model;
        } catch (XmlPullParserException | IOException ex) {
            throw new MvnModelInputException(ex);
        }
    }
}

```


Overlapping Code:
```
teModel(Project project) throws MvnModelInputExcepectDir) throws MvnModelInputException {
FileObject pomFile = projectDir.getFileObject("pom.xml");
MavenXpp3Reader mavenreader = new MavenXpp3Reader();
try (Reader reader = new InputStreamReader(pomFile.getInputStream())) {
Model model = mavenreader.read(reader);
model.setPomFile(new File(pomFile.getPath()));
return model;
} catch (XmlPullParserException | IOException ex) {
throw new MvnModelInputException(ex);
}
}
```
<Overlap Ratio: 0.7568881685575365>

---

--- 149 --
Question ID: 919def75c26c20661ebc949f53445ab95efa46ca
Original Code:
```
@Service
public class LinkManager implements LinkService {

    private LinkDao linkDao;

    @Autowired
    public LinkManager(LinkDao linkDao) {
        super();
        this.linkDao = linkDao;
    }

    @Override
    public Result add(Link link) {
        var result = this.linkDao.save(link);
        if (result != null) {
            return new SuccessResult("link add ok");
        }
        return new ErrorResult("link add NOT ok");
    }

    @Override
    public DataResult<List<Link>> getAll() {
        var result = this.linkDao.findAll();
        if (result != null) {
            return new SuccessDataResult<List<Link>>(result, "links get ok");
        }
        return new ErrorDataResult<List<Link>>("links get NOT ok");
    }

    @Override
    public DataResult<List<Link>> getByJobSeekerId(int jobSeekerId) {
        var result = this.linkDao.getByJobSeekerId(jobSeekerId);
        if (result != null) {
            return new SuccessDataResult<List<Link>>(result, "links get by jobSeeker Id ok");
        }
        return new ErrorDataResult<List<Link>>("links get by jobSeeker Id NOT ok");
    }
}

```


Overlapping Code:
```
rvice
public class LinkManager implements LinkService {
private LinkDao linkDao;
@Autowired
public LinkManager(LinkDao linkDao) {
super();
this.linkDao = linkDao;
}
@Override
public Result add(Link link) {
var result = this.linkDao.save(link);
if (result != null) {
return new SuccessResult("link add ok");
}
return new ErrorResult("link add NOT ok");
}
@Override
public DataResult<List<Link>> getAll() {
var result = this.linkDao.findAll();
if (result != null) {
return new SuccessDataResult<Lis ok");
}
return new ErrorDataResult<List<Link>>("links get NOT ok");
}
@Override
public DataResult<List<Link>> getByJobSeekerId(int jobSeekerId) {
var result = this.linkDao.getByJobSeekerId(jobSeekerId);
if (result != null) {
return new SuccessDataResult<Lis ok");
}
return new ErrorDataResult<List<Link>>("l
```
<Overlap Ratio: 0.8786885245901639>

---

--- 150 --
Question ID: 2f09050d499d8eb4df2f94048b0b44a79bf11ad5
Original Code:
```
public class MockApnsServer extends BaseHttp2Server {

    private final PushNotificationHandlerFactory handlerFactory;

    private final MockApnsServerListener listener;

    private final int maxConcurrentStreams;

    MockApnsServer(final SslContext sslContext, final EventLoopGroup eventLoopGroup, final PushNotificationHandlerFactory handlerFactory, final MockApnsServerListener listener, final int maxConcurrentStreams) {
        super(sslContext, eventLoopGroup);
        this.handlerFactory = handlerFactory;
        this.listener = listener;
        this.maxConcurrentStreams = maxConcurrentStreams;
    }

    @Override
    protected void addHandlersToPipeline(final SSLSession sslSession, final ChannelPipeline pipeline) throws Exception {
        final PushNotificationHandler pushNotificationHandler = this.handlerFactory.buildHandler(sslSession);
        final MockApnsServerHandler serverHandler = new MockApnsServerHandler.MockApnsServerHandlerBuilder().pushNotificationHandler(pushNotificationHandler).initialSettings(Http2Settings.defaultSettings().maxConcurrentStreams(this.maxConcurrentStreams)).listener(this.listener).build();
        pipeline.addLast(serverHandler);
    }
}

```


Overlapping Code:
```
ockApnsServer extends BaseHttp2Server {
private final PushNotificationHandlerFactory handlerFactory;
private final MockApnsServerListener listener;
private final int maxConcurrentStreams;
MockApnsServer(final SslContext sslContext, final EventLoopGroup eventLoopGrofinal PushNotificationHandlerFactory handlerFactory, final MockApnsServerListener listene(sslContext, eventLoopGroup);
this.handlerFactory = handlerFactory;
this.listener = listener;
this.maxConcurrentStreams = maxConcurrentStreams;
}
@Override
protected void addHandlersToPipeline(final SSLSession sslSession, final ChannelPipeline pipeline) throws Exception {
final PushNotificationHandler pushNotificationHandler = this.handlerFactory.buildHandler(sslSession);
final MockApnsServerHandler serverHandler = new MockApnsServerHandler.MockAitialSettings(Http2Settings.defaultSettings().maxConcurrentStreams(this.maxC
```
<Overlap Ratio: 0.7963800904977375>

---

--- 151 --
Question ID: 19807beaf0c29dd03789fd7847ec074e209b45d0
Original Code:
```
public class Client {

    private static final List<String> data = List.of("some", "data", "for", "test");

    public Client() {
        exp02();
    }

    private void exp01() {
        Dao dao = new XmlDao();
        Service service = new ServiceImpl(dao);
        System.out.println(service.validateAndSave(data));
    }

    private void exp02() {
        Dao dao = new MongoDBDao();
        Service service = new ServiceImplWithLog(dao);
        System.out.println(service.validateAndSave(data));
    }

    public static void main(String[] args) {
        new Client();
    }
}

```


Overlapping Code:
```
ent {
private static final List<String> data = List.of("some", "data", "for", "test");
public Client() {
exp02();
}
private void exp01() {
Dao dao = new XmlDao();
Service service = new ServiceImpl(dao);
System.out.println(service.validateAndSave(data));
}
private void exp02() {
Dao dao = new MongoDBDao();
Service service = new ServiceImplWithLog(dao);
System.out.println(service.validateAndSave(data));
}
public static void main(String[] args) {
new Client();
}

```
<Overlap Ratio: 0.9646569646569647>

---

--- 152 --
Question ID: d0e08467a50a8d3f84bbbe7b3bd74b5a35347772
Original Code:
```
public class ManageProjectFeatures extends SecureScreen {

    @Override
    protected void doBuildTemplate(RunData data, Context context) throws Exception {
        final Object projects = TurbineUtils.GetPassedParameter("projects", data);
        if (projects != null) {
            context.put("project", projects);
        } else {
            context.put("project", TurbineUtils.GetPassedParameter("project", data));
        }
        context.put("features", Features.getAllFeatures());
    }
}

```


Overlapping Code:
```
geProjectFeatures extends SecureScreen {
@Override
protected void doBuildTemplate(RunData data, Context context) throws Exception {
final Object projects = TurbineUtils.GetPassedParameter("projects", data);
if (projects != null) {
context.put("project", projects);
} else {
context.put("project", TurbineUtils.GetPassedParameter("project", data));
}
context.pu
```
<Overlap Ratio: 0.8530805687203792>

---

--- 153 --
Question ID: b340f2fb457ab4721fc8027ede739eb8fda262c5
Original Code:
```
@Service
@Transactional
public class CertificateTypeServiceImpl implements CertificateTypeService {

    private final Logger log = LoggerFactory.getLogger(CertificateTypeServiceImpl.class);

    private final CertificateTypeRepository certificateTypeRepository;

    private final CertificateTypeMapper certificateTypeMapper;

    public CertificateTypeServiceImpl(CertificateTypeRepository certificateTypeRepository, CertificateTypeMapper certificateTypeMapper) {
        this.certificateTypeRepository = certificateTypeRepository;
        this.certificateTypeMapper = certificateTypeMapper;
    }

    /**
     * Save a certificateType.
     *
     * @param certificateTypeDTO the entity to save.
     * @return the persisted entity.
     */
    @Override
    public CertificateTypeDTO save(CertificateTypeDTO certificateTypeDTO) {
        log.debug("Request to save CertificateType : {}", certificateTypeDTO);
        CertificateType certificateType = certificateTypeMapper.toEntity(certificateTypeDTO);
        certificateType = certificateTypeRepository.save(certificateType);
        return certificateTypeMapper.toDto(certificateType);
    }

    /**
     * Get all the certificateTypes.
     *
     * @return the list of entities.
     */
    @Override
    @Transactional(readOnly = true)
    public List<CertificateTypeDTO> findAll() {
        log.debug("Request to get all CertificateTypes");
        return certificateTypeRepository.findAll().stream().map(certificateTypeMapper::toDto).collect(Collectors.toCollection(LinkedList::new));
    }

    /**
     * Get one certificateType by id.
     *
     * @param id the id of the entity.
     * @return the entity.
     */
    @Override
    @Transactional(readOnly = true)
    public Optional<CertificateTypeDTO> findOne(Long id) {
        log.debug("Request to get CertificateType : {}", id);
        return certificateTypeRepository.findById(id).map(certificateTypeMapper::toDto);
    }

    /**
     * Delete the certificateType by id.
     *
     * @param id the id of the entity.
     */
    @Override
    public void delete(Long id) {
        log.debug("Request to delete CertificateType : {}", id);
        certificateTypeRepository.deleteById(id);
    }
}

```


Overlapping Code:
```
ice
@Transactional
public class CertificateTypeServiceImpl implements CertificateTypeService {
private final Logger log = LoggerFactory.getLogger(CertificateTypeServiceImpl.class);
private final CertificateTypeRepository certificateTypeRepository;
private final CertificateTypeMapper certificateTypeMapper;
public CertificateTypeServiceImpl(CertificateTypeRepository certificateTypeRepository, CertificateTypeMapper certificateTypeMapper) {
this.certificateTypeRepository = certificateTypeRepository;
this.certificateTypeMapper = certificateTypeMapper;
}
/**
* Save a certificateType.
*
* @param certificateTypeDTO the entity to save.
* @return the persisted entity.
*/
@Override
public CertificateTypeDTO save(CertificateTypeDTO certificateTypeDTO) {
log.debug("Request to save CertificateType : {}", certificateTypeDTO);
CertificateType certificateType = certificateTypeMapper.toEntity(certificateTypeDTO);
certificateType = certificateTypeRepository.save(certificateType);
return certificateTypeMapper.toDto(certificateType);
}
/**
* Get all the certificateTypes.
*
* @return the list of entities.
*/
@Override
@Transactional(readOnly = true)
public List<CertificateTypeDTO> findAll() {
log.debug("Request to get all CertificateTypes");
return cerMapper::toDto).collect(Collectors.toCollection(LinkedList::new));
}
/**
* Get one certificateType by id.
*
* @param id the id of the entity.
* @return the entity.
*/
@Override
@Transactional(readOnly = true)
public Optional<CertificateTypeDTO> findOne(Long id) {
log.debug("Request to get CertificateType : {}", id);
return certificateTyer::toDto);
}
/**
* Delete the certificateType by id.
*
* @param id the id of the entity.
*/
@Override
public void delete(Long id) {
log.debug("Request to delete CertificateType : {}", id);
certificat
```
<Overlap Ratio: 0.9225606608156943>

---

--- 154 --
Question ID: 3037ceb3997c55c745d234f6205a58fc66497019
Original Code:
```
public class PushNotificationCallback {

    private String email;

    private String url;

    public PushNotificationCallback(Context appContext) {
        Breadcaster caster = new Breadcaster(appContext).action("1", new Execution() {

            @Override
            public void exec(Context context, Intent intent) {
                String email = intent.getStringExtra("email");
                if (email != null) {
                    PushNotificationCallback.this.email = email;
                    String url = intent.getStringExtra("url");
                    PushNotificationCallback.this.url = url;
                }
                System.out.println("****PUSH_NOTIFICATION_CALLBACK_INVOKED*****");
                System.out.println(email + ":" + MyFirebaseMessagingService.pushToken + ":" + url);
                if (PushNotificationCallback.this.email == null || MyFirebaseMessagingService.pushToken == null) {
                    return;
                }
                Thread t = new Thread(() -> {
                    URL urlValue = null;
                    HttpsURLConnection urlConnection = null;
                    String json = null;
                    OutputStreamWriter writer = null;
                    BufferedReader reader = null;
                    try {
                        urlValue = new URL(PushNotificationCallback.this.url);
                        urlConnection = (HttpsURLConnection) urlValue.openConnection();
                        urlConnection.setDoOutput(true);
                        JSONObject jsonObject = new JSONObject();
                        jsonObject.put("email", PushNotificationCallback.this.email);
                        jsonObject.put("pushToken", MyFirebaseMessagingService.pushToken);
                        json = jsonObject.toString();
                        writer = new OutputStreamWriter(urlConnection.getOutputStream());
                        writer.write(json);
                        writer.flush();
                        reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));
                        StringBuilder sb = new StringBuilder();
                        String line = null;
                        for (; (line = reader.readLine()) != null; ) {
                            // Append server response in string
                            sb.append(line + "\n");
                        }
                        System.out.println("TOKEN_REGISTRATION_SUCCESS: " + sb);
                    } catch (Exception e) {
                    } finally {
                        if (urlConnection != null) {
                            urlConnection.disconnect();
                        }
                        try {
                            if (writer != null) {
                                writer.close();
                            }
                            if (reader != null) {
                                reader.close();
                            }
                        } catch (Exception e) {
                        }
                    }
                });
                t.start();
            }
        }).register();
    }
}

```


Overlapping Code:
```

public PushNotificationCallback(Context appContexrride
public void exec(Context context, Intent intent) {
Strinl = intent.getStringExtra("email");
if (email != nmail;
String url = intent.getStringExtra("url");
PushNotificationCallback.this.url = url;
}
System.out.println("****PUSH_NOTIFICATION_CALLBACK_INVOKEDtionCallback.this.email == null || MyFirebaseMessaonnection urlConnection = null;
String json = null;
OutputStreamWriter writer = null;
BufferedReader reader = null;
try {
urlValue = new URL(PushNotificationCallback.this.url);
urlConnection = (HttpsURLConnection) urlValue.openConnection();
urlConnection.setDoOutput(true);
JSONObject jsonObject = new JSONObject();
jsonObject.put("email", ationCallback.this.email);
jsonObject.put("pushTokjsonObject.toString();
writer = new OutputStreamWriter(urlConnection.getOutputStream());
writer.write(json);
writer.flush();
reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));
StringBuilder sb = new StringBuilder();
String line = null;
{
// Append server response in string
sb.append(line + "\n");
}
S
```
<Overlap Ratio: 0.646044021415824>

---

--- 155 --
Question ID: 830dd582a871908ba6897692f86bcd2509046763
Original Code:
```
public class ParentEntry extends ModListEntry {

    private static final String PARENT_MOD_TEXTURE = "/assets/" + ModMenu.MOD_ID + "/textures/gui/parent_mod.png";

    protected List<ModContainer> children;

    protected ModListWidget list;

    protected boolean hoveringIcon = false;

    public ParentEntry(Minecraft mc, ModContainer parent, List<ModContainer> children, ModListWidget list) {
        super(mc, parent, list);
        this.children = children;
        this.list = list;
    }

    @Override
    public void render(int index, int y, int x, int rowWidth, int rowHeight, int mouseX, int mouseY, boolean isSelected, float delta) {
        super.render(index, y, x, rowWidth, rowHeight, mouseX, mouseY, isSelected, delta);
        TextRenderer font = client.textRenderer;
        int childrenBadgeHeight = 9;
        int childrenBadgeWidth = 9;
        int children = ModListSearch.search(list.getParent(), list.getParent().getSearchInput(), getChildren()).size();
        int childrenWidth = font.getTextWidth(Integer.toString(children)) - 1;
        if (childrenBadgeWidth < childrenWidth + 4) {
            childrenBadgeWidth = childrenWidth + 4;
        }
        int childrenBadgeX = x + 32 - childrenBadgeWidth;
        int childrenBadgeY = y + 32 - childrenBadgeHeight;
        int childrenOutlineColor = 0x8810d098;
        int childrenFillColor = 0x88046146;
        fill(childrenBadgeX + 1, childrenBadgeY, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + 1, childrenOutlineColor);
        fill(childrenBadgeX, childrenBadgeY + 1, childrenBadgeX + 1, childrenBadgeY + childrenBadgeHeight - 1, childrenOutlineColor);
        fill(childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + 1, childrenBadgeX + childrenBadgeWidth, childrenBadgeY + childrenBadgeHeight - 1, childrenOutlineColor);
        fill(childrenBadgeX + 1, childrenBadgeY + 1, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + childrenBadgeHeight - 1, childrenFillColor);
        fill(childrenBadgeX + 1, childrenBadgeY + childrenBadgeHeight - 1, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + childrenBadgeHeight, childrenOutlineColor);
        font.drawText(Integer.toString(children), childrenBadgeX + childrenBadgeWidth / 2 - childrenWidth / 2, childrenBadgeY + 1, 0xCACACA);
        this.hoveringIcon = mouseX >= x - 1 && mouseX <= x - 1 + 32 && mouseY >= y - 1 && mouseY <= y - 1 + 32;
        if (isMouseOver(mouseX, mouseY)) {
            fill(x, y, x + 32, y + 32, 0xA0909090);
            this.client.textureManager.bindTexture(this.client.textureManager.getTextureId(PARENT_MOD_TEXTURE));
            int xOffset = list.getParent().showModChildren.contains(getMetadata().getId()) ? 32 : 0;
            int yOffset = hoveringIcon ? 32 : 0;
            GL11.glColor4f(1f, 1f, 1f, 1f);
            Tessellator tess = Tessellator.INSTANCE;
            tess.start();
            tess.vertex(x, y, 0, xOffset / 256f, yOffset / 256f);
            tess.vertex(x, y + 32, 0, xOffset / 256f, (yOffset + 32) / 256f);
            tess.vertex(x + 32, y + 32, 0, (xOffset + 32) / 256f, (yOffset + 32) / 256f);
            tess.vertex(x + 32, y, 0, (xOffset + 32) / 256f, yOffset / 256f);
            tess.draw();
        }
    }

    @Override
    public boolean mouseClicked(double mouseX, double mouseY, int i) {
        if (hoveringIcon) {
            String id = getMetadata().getId();
            if (list.getParent().showModChildren.contains(id)) {
                list.getParent().showModChildren.remove(id);
            } else {
                list.getParent().showModChildren.add(id);
            }
            list.filter(list.getParent().getSearchInput(), false);
        }
        return super.mouseClicked(mouseX, mouseY, i);
    }

    @Override
    public boolean keyPressed(int int_1, int int_2, int int_3) {
        if (int_1 == Keyboard.KEY_RETURN) {
            String id = getMetadata().getId();
            if (list.getParent().showModChildren.contains(id)) {
                list.getParent().showModChildren.remove(id);
            } else {
                list.getParent().showModChildren.add(id);
            }
            list.filter(list.getParent().getSearchInput(), false);
            return true;
        }
        return super.keyPressed(int_1, int_2, int_3);
    }

    public void setChildren(List<ModContainer> children) {
        this.children = children;
    }

    public void addChildren(List<ModContainer> children) {
        this.children.addAll(children);
    }

    public void addChildren(ModContainer... children) {
        this.children.addAll(Arrays.asList(children));
    }

    public List<ModContainer> getChildren() {
        return children;
    }

    public boolean isMouseOver(double double_1, double double_2) {
        return Objects.equals(this.list.getEntryAtPos(double_1, double_2), this);
    }
}

```


Overlapping Code:
```
stEntry {
private static final String PARENT_MOD_TEXTURE = "/assets/" + ModMenu.MOD_ID + "/textures/gui/parent_mod.png";
protected List<ModContainer> children;
protected ModListWidget list;
protected boolean hoveringIcon = false;
public ParentEntry(Minecraft mc, ModContainer parent, List<ModContainer> children, ModListWidget list) {
super(mc, parent, list);
this.children = children;
this.list = list;
}
@Override
public void render(int index, int y, int x, int rowWidth, int rowHeight, int mouseX, int mouseY, boolean isSelected, float delta) {
super.render(index, y, x, rowWidth, rowHeight, mouseX, mouseY, isSelected, delta);
TextRenderer font = client.textRenderer;
int childrenBadgeHeight = 9;
int childrenBadgeWidth = 9;
int children = ModListSearch.search(list.getParent(), list.getParent().getSearchInput(), getChildren()).size();
int childrenWidth = font.getTextWidth(Integer.toString(children)) - 1;
if (childrenBadgeWidth < childrenWidth + 4) {
childrenBadgeWidth = childrenWidth + 4;
}
int childrenBadgeX = x + 32 - childrenBadgeWidth;
int childrenBadgeY = y + 32 - childrenBadgeHeight;
int childrenOutlineColor = 0x8810d098;
int childrenFillColor = 0x88046146;
fill(childrenBadgeX + 1, childrenBadgeY, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + 1, childrenOutlineColor);
fill(childrenBadgeX, childrenBadgeY + 1, childrenBadgeX + 1, childrenBadgeY + childrenBadgeHeight - 1, childrenOutlineColor);
fill(childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + 1, childrenBadgeX + childrenBadgeWidth, childrenBadgeY + childrenBadgeHeight - 1, childrenOutlineColor);
fill(childrenBadgeX + 1, childrenBadgeY + 1, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + childrenBadgeHeight - 1, childrenFillColor);
fill(childrenBadgeX + 1, childrenBadgeY + childrenBadgeHeight - 1, childrenBadgeX + childrenBadgeWidth - 1, childrenBadgeY + childrenBadgeHeight, childrenOutlineColor);
font.drawText(Integer.toString(children), childrenBadgeX + childrenBadgeWidth / 2 - childrenWidth / 2, childrenBadgeY + 1, 0xCACACA);
this.hoveringIcon = mouseX >= x - 1 && mouseX <= x - 1 + 32 && mouseY >= y - 1 && mouseY <= y - 1 + 32;
if (isMouseOver(mouseX, mouseY)) {
fill(x, y, x + 
```
<Overlap Ratio: 0.9764758100310696>

---

--- 156 --
Question ID: 1ee98f729518a3ab59cc092fb753ccaf548f8923
Original Code:
```
public class SqlPagingStrategy {

    public static SqlPaging buildPaging(String databaseProduct) {
        SqlPaging paging = new SqlPaging();
        if (databaseProduct.equals(DatabaseProduct.MYSQL)) {
            //$NON-NLS-1$
            MySqlPagingDialect dialect = new MySqlPagingDialect();
            paging.setDialect(dialect);
        } else if (databaseProduct.equals(DatabaseProduct.PGSQL)) {
            //$NON-NLS-1$
            PostgreSqlPagingDialect dialect = new PostgreSqlPagingDialect();
            paging.setDialect(dialect);
        } else if (databaseProduct.equals(DatabaseProduct.H2)) {
            //$NON-NLS-1$
            H2PagingDialect dialect = new H2PagingDialect();
            paging.setDialect(dialect);
        }
        return paging;
    }
}

```


Overlapping Code:
```
tatic SqlPaging buildPaging(String databaseProductg paging = new SqlPaging();
if (databaseProduct.equals(DatabaseProduct.MYSQLPagingDialect dialect = new MySqlPagingDialect();
$
PostgreSqlPagingDialect dialect = new PostgreSqle if (databaseProduct.equals(DatabaseProduct.H2)) gingDialect();
paging.setDialect(dialect);
}
retur
```
<Overlap Ratio: 0.5292207792207793>

---

--- 157 --
Question ID: 613edc207594fb66f34f7fbd0a1d1f3fc371a4e9
Original Code:
```
public final class LargestRowInTreeTestCase {

    private LargestRowInTree alg;

    /**
     * Init.
     */
    @Before
    public void init() {
        this.alg = new LargestRowInTree();
    }

    @Test
    public void test() {
        final PlainTree tree = new PlainTree(1);
        tree.left = new PlainTree(3);
        tree.left.left = new PlainTree(5);
        tree.left.right = new PlainTree(3);
        tree.right = new PlainTree(2);
        tree.right.right = new PlainTree(9);
        Assert.assertEquals(Arrays.asList(1, 3, 9), this.alg.largestValues(tree));
    }
}

```


Overlapping Code:
```
RowInTreeTestCase {
private LargestRowInTree alg;
/**
* Init.
*/
@Before
public void init() {
this.alg = new LargestRowInTree();
}
@Test
public void test() {
final PlainTree tree = new PlainTree(1);
tree.left = new PlainTree(3);
tree.left.left = new PlainTree(5);
tree.left.right = new PlainTree(3);
tree.right = new PlainTree(2);
tree.right.right = new P
```
<Overlap Ratio: 0.7521186440677966>

---

--- 158 --
Question ID: 44cf8deda1243d30e680509d78d40d7907b51d93
Original Code:
```
@Configuration
public class ShiroConfig {

    @Bean("sessionManager")
    public SessionManager sessionManager() {
        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();
        sessionManager.setSessionValidationSchedulerEnabled(true);
        sessionManager.setSessionIdCookieEnabled(true);
        return sessionManager;
    }

    @Bean("securityManager")
    public SecurityManager securityManager(OAuth2Realm oAuth2Realm, SessionManager sessionManager) {
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        securityManager.setRealm(oAuth2Realm);
        securityManager.setSessionManager(sessionManager);
        return securityManager;
    }

    @Bean("shiroFilter")
    public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();
        shiroFilter.setSecurityManager(securityManager);
        //oauth??
        Map<String, Filter> filters = new HashMap<>();
        filters.put("oauth2", new OAuth2Filter());
        shiroFilter.setFilters(filters);
        Map<String, String> filterMap = new LinkedHashMap<>();
        filterMap.put("/webjars/**", "anon");
        filterMap.put("/druid/**", "anon");
        filterMap.put("/app/**", "anon");
        filterMap.put("/sys/login", "anon");
        filterMap.put("/swagger/**", "anon");
        filterMap.put("/v2/api-docs", "anon");
        filterMap.put("/swagger-ui.html", "anon");
        filterMap.put("/swagger-resources/**", "anon");
        filterMap.put("/captcha.jpg", "anon");
        filterMap.put("/webname", "anon");
        filterMap.put("/licence/**", "anon");
        filterMap.put("/report/**", "anon");
        filterMap.put("/**/*.html", "anon");
        filterMap.put("/fonts/**", "anon");
        filterMap.put("/**/*.js", "anon");
        filterMap.put("/**/*.css", "anon");
        filterMap.put("/plugins/**", "anon");
        filterMap.put("/**/*.jpg", "anon");
        filterMap.put("/**/*.mp4", "anon");
        filterMap.put("/**/*.zip", "anon");
        filterMap.put("/**/*.png", "anon");
        filterMap.put("/", "anon");
        filterMap.put("/**", "oauth2");
        shiroFilter.setFilterChainDefinitionMap(filterMap);
        return shiroFilter;
    }

    @Bean("lifecycleBeanPostProcessor")
    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {
        return new LifecycleBeanPostProcessor();
    }

    @Bean
    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {
        DefaultAdvisorAutoProxyCreator proxyCreator = new DefaultAdvisorAutoProxyCreator();
        proxyCreator.setProxyTargetClass(true);
        return proxyCreator;
    }

    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {
        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();
        advisor.setSecurityManager(securityManager);
        return advisor;
    }
}

```


Overlapping Code:
```
@Configuration
public class ShiroConfig {
@Bean("sessionManager")
public SessionManager sessionManager() {
DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();
sessionManager.setSessionValidationSchedulerEnabled(true);
sessionManager.setSessionIdCookieEnabled(true);
return sessionManager;
}
@Bean("securityManager")
public SecurityManager securityManager(OAuth2Realm oAuth2Realm, SessionManager sessionManager) {
DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
securityManager.setRealm(oAuth2Realm);
securityManager.setSessionManager(sessionManager);
return securityManager;
}
@Bean("shiroFilter")
public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) {
ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();
shiroFilter.setSecurityManager(securityManager);
//o
Map<String, Filter> filters = new HashMap<>();
filters.put("oauth2", new OAuth2Filter());
shiroFilter.setFilters(filters);
Map<String, String> filterMap = new LinkedHashMap<>();
filterMap.put("/webjars/**", "anon");
filterMap.put("/druid/**", "anon");
filterMap.put("/app/**", "anon");
filterMap.put("/sys/login", "anon");
filterMap.put("/swagger/**", "anon");
filterMap.put("/v2/api-docs", "anon");
filterMap.put("/swagger-ui.html", "anon");
filterMap.put("/swagger-resources/**", "anon");
filterMap.put("/captcha.jpg", "anon");
filterMap.put("/webname", "anon");
filterMap.put("/licence/**", "anon");
filterMap.put("/report/**", "anon");
filterMap.put("/**/*.html", "anon");
filterMap.put("/fonts/**", "anon");
filterMap.put("/**/*.js", "anon");
filterMap.put("/**/*.css", "anon");
filterMap.put("/plugins/**", "anon");
filterMap.put("/**/*.jpg", "anon");
filterMap.put("/**/*.mp4", "anon");
filterMap.put("/**/*.zip", "anon");
filterMap.put("/**/*.png", "anon");
filterMap.put("/", "anon");
filterMap.put("/**", "oauth2");
shiroFilter.setFilterChainDefinitionMap(filterMap);
return shiroFilter;
}
@Bean("lifecycleBeanPostProcessor")
public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {
return new Lif
```
<Overlap Ratio: 0.9970958373668926>

---

--- 159 --
Question ID: fffc8b15a202472b064537ba02ca8760174f69e2
Original Code:
```
@RestController
@RequestMapping(value = "/api/admin/discovery", produces = MediaType.APPLICATION_JSON_VALUE)
public class AdminDiscoveryResource extends BaseResource {

    @Inject
    private ProgramItemService programItemService;

    /**
     * Gets discovery programs.
     *
     * @return the discovery programs
     */
    @ApiOperation(value = "Get DiscoveryPrograms.", notes = "<p>Get DiscoveryPrograms.</p>")
    @RequestMapping(value = "/", method = RequestMethod.GET)
    @RolesAllowed(AuthoritiesConstants.ADMIN)
    @Timed
    List<DiscoverProgramDTO> getDiscoveryPrograms() {
        List<DiscoveryProgram> discoveryProgramList = programItemService.getDiscoveryPrograms();
        List<DiscoverProgramDTO> dto = new ArrayList<>();
        for (DiscoveryProgram dp : discoveryProgramList) {
            dto.add(DiscoverProgramDTO.valueOf(dp));
        }
        return dto;
    }

    /**
     * Upsert discovery program discover program dto.
     *
     * @param dto the dto
     * @return the discover program dto
     */
    @ApiOperation(value = "Upsert DiscoveryProgram.", notes = "<p>Upsert DiscoveryProgram.</p>")
    @RequestMapping(value = "/", method = RequestMethod.PUT)
    @RolesAllowed(AuthoritiesConstants.ADMIN)
    @Timed
    DiscoverProgramDTO upsertDiscoveryProgram(@RequestBody DiscoverProgramDTO dto) {
        DiscoveryProgram dp = programItemService.upsertDiscoveryProgram(dto.getId(), dto.getProgramId(), dto.getActive(), dto.getType(), dto.getDiscoveryProgramText());
        return DiscoverProgramDTO.valueOf(dp);
    }

    /**
     * Delete discovery program.
     *
     * @param discoveryProgramId the discovery program id
     */
    @ApiOperation(value = "Delete the given DiscoveryProgram.", notes = "<p>Delete the given DiscoveryProgram.</p>")
    @RequestMapping(value = "/{discoveryProgramId}", method = RequestMethod.DELETE)
    @Timed
    @RolesAllowed(AuthoritiesConstants.ADMIN)
    public void deleteDiscoveryProgram(@PathVariable Long discoveryProgramId) {
        programItemService.deleteDiscoveryProgram(discoveryProgramId);
    }

    /**
     * Gets discover type list.
     *
     * @return the discover type list
     */
    @ApiOperation(value = "Get discover types", notes = "<p>Get list of discover types.</p>")
    @RequestMapping(value = "/types", method = RequestMethod.GET)
    @Timed
    @RolesAllowed(AuthoritiesConstants.ADMIN)
    public List<DiscoveryProgramType> getDiscoverTypeList() {
        return DiscoveryProgramType.getAllTypes();
    }
}

```


Overlapping Code:
```
@RestController
@RequestMapping(value = "/api/admin/discovery", produces = MediaType.APPLICATION_JSON_VALUE)
public class AdminDiscoveryResource extends BaseResource {
@Inject
private ProgramItemService programItemService;
/**
* Gets discovery programs.
*
* @return the discovery programs
*/
@ApiOperation(value = "Get DiscoveryPrograms.", notes = "<p>Get DiscoveryPrograms.</p>")
@RequestMapping(value = "/", method = RequestMethod.GET)
@RolesAllowed(AuthoritiesConstants.ADMIN)
@Timed
List<DiscoverProgramDTO> getDiscoveryPrograms() {
List<DiscoveryProgram> discoveryProgramList = programItemService.getDiscoveryPrograms();
List<DiscoverProgramDTO> dto = new ArrayList<>();
for (DiscoveryProgram dp : discoveryProgramList) {
dto.add(DiscoverProgramDTO.valueOf(dp));
}
return dto;
}
/**
* Upsert discovery program discover program dto.
*
* @param dto the dto
* @return the discover program dto
*/
@ApiOperation(value = "Upsert DiscoveryProgram.", notes = "<p>Upsert DiscoveryProgram.</p>")
@RequestMapping(value = "/", method = RequestMethod.PUT)
@RolesAllowed(AuthoritiesConstants.ADMIN)
@Timed
DiscoverProgramDTO upsertDiscoveryProgram(@RequestBody DiscoverProgramDTO dto) {
DiscoveryProgram dp = programItemService.upsertdto.getActive(), dto.getType(), dto.getDiscoveryProgramText());
return DiscoverProgramDTO.valueOf(dp);
}
/**
* Delete discovery program.
*
* @param discoveryProgramId the discovery program id
*/
@ApiOperation(value = "Delete the given DiscoveryProgram.", notes = "<p>Delete the given DiscoveryProgram.</p>")
@RequestMapping(value = "/{discoveryProgramId}", method = RequestMethod.DELETE)
@Timed
@RolesAllowed(AuthoritiesConstants.ADMIN)
public void deleteDiscoveryProgram(@PathVariable Long discoveryProgramId) {
programItemService.deleteDiscoveryProgram(discoveryProgramId);
}
/**
* Gets discover type list.
*
* @return the discover type list
*/
@ApiOperation(value = "Get discover types", notes = "<p>Get list of discover types.</p>")
@RequestMapping(value = "/types", method = RequestMethod.GET)
@Timed
@RolesAllowed(AuthoritiesConstants.ADMIN)
public List<DiscoveryProgramType> getDiscoverTypeLis
```
<Overlap Ratio: 0.961973743775464>

---

--- 160 --
Question ID: 7a7b8318fe1ee8708edc850e3756a533331a9ffb
Original Code:
```
public class ConsumerAuthInterceptor implements HandlerInterceptor {

    private WeChatUserRepository weChatUserRepository;

    @Autowired
    private void setWeChatUserRepository(final WeChatUserRepository weChatUserRepository) {
        this.weChatUserRepository = weChatUserRepository;
    }

    private JwtTokenUtil jwtTokenUtil;

    @Autowired
    private void setJwtTokenUtil(final JwtTokenUtil jwtTokenUtil) {
        this.jwtTokenUtil = jwtTokenUtil;
    }

    @Override
    public boolean preHandle(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse, final Object object) throws NullTokenException, UserNotExistException {
        // check annotation
        if (!(object instanceof HandlerMethod)) {
            return true;
        }
        final HandlerMethod handlerMethod = (HandlerMethod) object;
        final Method method = handlerMethod.getMethod();
        // request
        if (method.isAnnotationPresent(WeChatUser.class)) {
            final WeChatUser weChatUser = method.getAnnotation(WeChatUser.class);
            if (!weChatUser.required()) {
                return true;
            }
            // get token
            final String token = httpServletRequest.getHeader(CommonConfig.HEADER_TOKEN_NAME);
            if (token == null || token.replace(" ", "").equals("")) {
                throw new NullTokenException("Null token.");
            }
            // verify user exist in database
            final String weChatUserUuid = this.jwtTokenUtil.getPayloadByFrontToken(token);
            final List<WechatUserDo> wechatUserDoList = this.weChatUserRepository.findByWeChatUserUuid(weChatUserUuid);
            if (wechatUserDoList.isEmpty()) {
                throw new UserNotExistException();
            }
        }
        return true;
    }
}

```


Overlapping Code:
```
 ConsumerAuthInterceptor implements HandlerInterceptor {
private WeChatUserRepository weChatUserRepository;
@Autowired
private void setWeChatUserRepository(final WeChatUserRepository weChatUserRepository) {
this.weChatUserRepository = weChatUserRepository;
}
private JwtTokenUtil jwtTokenUtil;
@Autowired
private void setJwtTokenUtil(final JwtTokenUtil jwtTokenUtil) {
this.jwtTokenUtil = jwtTokenUtil;
}
@Override
public boolean preHandle(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse, final Object object)rNotExistException {
// check annotation
if (!(object instanceof HandlerMethod)) {
return true;
}
final HandlerMethod handlerMethod = (HandlerMethod) object;
final Method method = handlerMethod.getMethod();
// request
if (method.isAnnotationPresent(WeChatUser.class)) {
final WeChatUser weChatUser = method.getAnnotation(WeChatUser.class);
if (!weChatUser.required()) {
return true;
}
// get token
final String token = httpServletRequest.getHeader(CommonConfig.HEADER_TOKEN_NAME);
if (token == null || token.replace(" ", "").equals("")) {
throw new NullTokenException("Null token.");
}
// verify user exist in database
final String weChatUserUuid = this.jwtTokenUtil.getPayloadByFrontToken(token);
final List<WechatUserDo> wechatUserDoList = this.weChatUserRepository.findByWeChatUserUuid(weChatUserUuid);
if (wechatUserDoList.isEmpty()) {
throw new UserNotExistExcept
```
<Overlap Ratio: 0.9530201342281879>

---

--- 161 --
Question ID: b194a3017d75dc57bcc64346c80eb6e40c252975
Original Code:
```
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2022-01-08T01:37:46.955Z")
public class RegisterTopicExample {

    @SerializedName("id")
    private String id = null;

    @SerializedName("kind")
    private String kind = null;

    @SerializedName("op")
    private String op = null;

    public RegisterTopicExample id(String id) {
        this.id = id;
        return this;
    }

    /**
     * Get id
     * @return id
     */
    @ApiModelProperty(example = "common:test:123", value = "")
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public RegisterTopicExample kind(String kind) {
        this.kind = kind;
        return this;
    }

    /**
     * Get kind
     * @return kind
     */
    @ApiModelProperty(example = "common:source:type:1.0.0", value = "")
    public String getKind() {
        return kind;
    }

    public void setKind(String kind) {
        this.kind = kind;
    }

    public RegisterTopicExample op(String op) {
        this.op = op;
        return this;
    }

    /**
     * Get op
     * @return op
     */
    @ApiModelProperty(example = "deleted", value = "")
    public String getOp() {
        return op;
    }

    public void setOp(String op) {
        this.op = op;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        RegisterTopicExample registerTopicExample = (RegisterTopicExample) o;
        return Objects.equals(this.id, registerTopicExample.id) && Objects.equals(this.kind, registerTopicExample.kind) && Objects.equals(this.op, registerTopicExample.op);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, kind, op);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class RegisterTopicExample {\n");
        sb.append("    id: ").append(toIndentedString(id)).append("\n");
        sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
        sb.append("    op: ").append(toIndentedString(op)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(java.lang.Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }
}

```


Overlapping Code:
```
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2022-01-08T01:37:46.955Z")
public class RegisterTopicExample {
@SerializedName("id")
private String id = null;
@SerializedName("kind")
private String kind = null;
@SerializedName("op")
private String op = null;
public RegisterTopicExample id(String id) {
this.id = id;
return this;
}
/**
* Get id
* @return id
*/
@ApiModelProperty( = "common:test:123", value = "")
public String getId() {
return id;
}
public void setId(String id) {
this.id = id;
}
public RegisterTopicExample kind(String kind) {
this.kind = kind;
return this;
}
/**
* Get kind
* @return kind
*(example = "common:source:type:1.0.0", value = "")
public String getKind() {
return kind;
}
public void setKind(String kind) {
this.kind = kind;
}
public RegisterTopicExample op(String op) {
this.op = op;
return this;
}
/**
* Get op
* @return op
*@ApiModelProperty(example = "deleted", value = "")
public String getOp() {
return op;
}
public void setOp(String op) {
this.op = op;
}
@Override
public boolean equals(java.lang.Object o) {
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
RegisterTopicExample registerTopicExample = (RegisterTopicExample) o;
return Objects.equals(this.id, registerTopicExrTopicExample.op);
}
@Override
public int hashCode() {
return Objects.hash(id, kind, op);
}
@Override
public String toString() {
StringBuilder sb = new StringBuilder();
sb.append("class RegisterTopicEle {\n");
sb.append(" id: ").append(toIndentedString(id)).append("\n");
sb.append(" kind: ").append(toIndentedString(kind)).append("\n");
sb.append(" op: ").append(toIndentedString(op)).append("\n");
sb.append("}");
return sb.toString();
}
/**
* Convert the given object to string with each line indented by 4 spaces
* (except the first line).
*/
private String toIndentedString(java.
```
<Overlap Ratio: 0.9345887016848364>

---

--- 162 --
Question ID: aaf5418ef49cbe5565f0b3cf9c16a929b43a0ec1
Original Code:
```
public class BaconHistogram {

    public static void main(String[] args) {
        SymbolGraph sg = new SymbolGraph("movies.txt", "/");
        Graph G = sg.G();
        String source = "Bacon, Kevin";
        if (!sg.contains(source)) {
            StdOut.println(source + "not in database.");
            return;
        }
        int s = sg.index(source);
        BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);
        int[] num = new int[G.V()];
        int infinite = 0;
        int v = 0;
        while (v < G.V()) try {
            int distance = bfs.distTo(v);
            if (distance != Integer.MAX_VALUE) {
                num[distance]++;
            } else {
                infinite++;
            }
        } finally {
            v++;
        }
        int i = 0;
        while (i < num.length) try {
            if (num[i] != 0) {
                System.out.println("Kevin Bacon = " + i / 2 + " : " + num[i]);
            } else {
                break;
            }
        } finally {
            i += 2;
        }
        System.out.println("Infinite(actors and movies): " + infinite);
    }
}

```


Overlapping Code:
```
onHistogram {
public static void main(String[] args) {
SymbolGraph sg = new SymbolGraph("movies.txt", "/");
Graph G = sg.G();
String source = "Bacon, Kevin";
if (!sg.contains(source)) {
StdOut.println(source + "not in database.");
return;
}
int s = sg.index(source);
BreadthFirstPaths bfs = new BreadthFirstPaths(G, s);
int[] num = new int[G.V()];
int infistance = bfs.distTo(v);
if (distance != Integer.MAX_VALUE) {
num[distance]++;
} else {
infinite++;
}ut.println("Infinite(actors and movies): " + infin
```
<Overlap Ratio: 0.655440414507772>

---

--- 163 --
Question ID: 00bef6747de51bf67fa009897a672aaff33c027a
Original Code:
```
@Component
public class MediatorImpl<TResponse, TRequest> implements Mediator<TResponse, TRequest> {

    @Override
    public TResponse send(TRequest request, Handler handler) {
        return (TResponse) handler.handle(request);
    }
}

```


Overlapping Code:
```
ublic class MediatorImpl<TResponse, TRequest> implements Mediator<TResponse, TRequest> {
@Override
public TResponse send(TRequest request, Handler handler) {
return (TResponse) handler.handle(request)
```
<Overlap Ratio: 0.9216589861751152>

---

--- 164 --
Question ID: 72ae39170a00e26a90f4a2eecfcf893492a74a15
Original Code:
```
@OnStop
@Messages({ "# {0} - autosave id", "MSG_CleanedUp=Cleaned up autosave {0}" })
public final class AutosaveStop implements Runnable {

    private static final Logger LOGGER = Logger.getLogger(AutosaveStop.class.getName());

    @Override
    public void run() {
        final Map<String, Graph> graphs = GraphNode.getAllGraphs();
        for (final Map.Entry<String, Graph> entry : graphs.entrySet()) {
            final Graph graph = entry.getValue();
            AutosaveUtilities.deleteAutosave(graph.getId());
            LOGGER.info(Bundle.MSG_CleanedUp(graph.getId()));
        }
        AutosaveUtilities.cleanup();
    }
}

```


Overlapping Code:
```
s AutosaveStop implements Runnable {
private static final Logger LOGGER = Logger.getLogger(AutosaveStop.class.getName());
@Override
public void run() {
final Map<String, Graph> graphs = GraphNode.getAllGraphs();
for (final Map.Entry<String, Graph> entry : graphs.entrySet()) {
final Graph graph = entry.getValue();
AutosaveUtilities.deleteAutosave(graph.getId());
LOGGER.info(Bundle.MSG_CleanedUp(gra
```
<Overlap Ratio: 0.7259528130671506>

---

--- 165 --
Question ID: ef4088695a2bdbb3f8b94bb4019081cc3a616e2e
Original Code:
```
public class MatrixCalculator {

    private static ILexicalDatabase db;

    public MatrixCalculator(ILexicalDatabase db) {
        MatrixCalculator.db = db;
    }

    public static double[][] getSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {
        double[][] result = new double[words1.length][words2.length];
        int i = 0;
        while (i < words1.length) try {
            int j = 0;
            while (j < words2.length) try {
                double score = rc.calcRelatednessOfWords(words1[i], words2[j]);
                result[i][j] = score;
            } finally {
                j++;
            }
        } finally {
            i++;
        }
        return result;
    }

    public static double[][] getNormalizedSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {
        double[][] scores = getSimilarityMatrix(words1, words2, rc);
        double bestScore = 1.0D;
        for (double[] score : scores) {
            for (double aScore : score) {
                if (aScore > bestScore && aScore != Double.MAX_VALUE)
                    bestScore = aScore;
            }
        }
        int i = 0;
        while (i < scores.length) try {
            int j = 0;
            while (j < scores[i].length) try {
                if (scores[i][j] == Double.MAX_VALUE)
                    scores[i][j] = 1;
                else
                    scores[i][j] /= bestScore;
            } finally {
                j++;
            }
        } finally {
            i++;
        }
        return scores;
    }

    public static double[][] getSynonymyMatrix(String[] words1, String[] words2) {
        List<Set<String>> synonyms1 = new ArrayList<>(words1.length);
        Arrays.asList(words1).forEach(aWords1 -> {
            Set<String> synonyms = new HashSet<>();
            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords1, pos).forEach(concept -> synonyms.add(concept.getSynsetID())));
            synonyms1.add(synonyms);
        });
        List<Set<String>> synonyms2 = new ArrayList<>(words2.length);
        Arrays.asList(words2).forEach(aWords2 -> {
            Set<String> synonyms = new HashSet<>();
            Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords2, pos).forEach(concept -> synonyms.add(concept.getSynsetID())));
            synonyms2.add(synonyms);
        });
        double[][] result = new double[words1.length][words2.length];
        int i = 0;
        while (i < words1.length) try {
            int j = 0;
            while (j < words2.length) try {
                String w1 = words1[i];
                String w2 = words2[j];
                if (w1.equals(w2)) {
                    result[i][j] = 1.0D;
                    continue;
                }
                Set<String> s1 = synonyms1.get(i);
                Set<String> s2 = synonyms2.get(j);
                result[i][j] = (s1.contains(w2) || s2.contains(w1)) ? 1.0D : 0.0D;
            } finally {
                j++;
            }
        } finally {
            i++;
        }
        return result;
    }
}

```


Overlapping Code:
```
 ILexicalDatabase db;
public MatrixCalculator(ILexicalDatabase db) {
MatrixCalculator.db = db;
}
public static double[][] getSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {
double[][] result = new double[words1.length][words2.lengthdouble score = rc.calcRelatednessOfWords(words1[i]ult;
}
public static double[][] getNormalizedSimilarityMatrix(String[] words1, String[] words2, RelatednessCalculator rc) {
double[][] scores = getSimilarityMatrix(words1, words2, rc);
double bestScore = 1.0D;
for (double[] score : scores) {
for (double aScore : score) {
if (aScore > bestScore && aSic static double[][] getSynonymyMatrix(String[] words1, String[] words2) {
List<Set<String>> synonyms1 = new ArrayList<>(words1.length);
Arrays.asList(words1).forEach(aWords1 -> {
Set<String> synonyms = new HashSet<>();
Arrays.asList(POS.values()).foach(concept -> synonyms.add(concept.getSynsetID())));
synonyms1.add(synonyms);
});
List<Set<String>> synonyms2 = new ArrayList<>(words2.length);
Arrays.asList(words2).forEach(aWords2 -> {
Set<String> synonyms = new HashSet<>();
Arrays.asList(POS.values()).forEach(pos -> db.getAllConcepts(aWords2, poach(concept -> synonyms.add(concept.getSynsetID())));
synonyms2.add(synonyms);
});
double[][] result = new double[words1.length][words2.length
```
<Overlap Ratio: 0.6945183608302289>

---

--- 166 --
Question ID: 7c2ea552d6b33724625ffb28255f80ebf777d7a2
Original Code:
```
public abstract class LogicProgramArtifact {

    private List<String> comments = null;

    public void addComment(String comment) {
        if (comments == null)
            comments = new ArrayList<String>();
        comments.add(comment);
    }

    public void writeTo(BufferedWriter out) throws IOException {
        if (comments == null)
            return;
        for (String comment : comments) out.write("% " + comment + "\n");
    }

    public void copyComments(LogicProgramArtifact other) {
        if (other.comments == null)
            return;
        if (this.comments == null)
            comments = new ArrayList<String>();
        this.comments.addAll(other.comments);
    }
}

```


Overlapping Code:
```
d addComment(String comment) {
if (comments == null)
comments = new ArrayList<String>();
comments.add(comment
}
public void writeTo(BufferedWriter out) throws IOException {
if "\n");
}
public void copyComments(LogicProgramArtmments == null)
comments = new ArrayList<String>();
this.comments.addAll(other.comments);
}
```
<Overlap Ratio: 0.5632798573975044>

---

--- 167 --
Question ID: f4faaf5638a49c5121563ade6dd4b7fbef7d664d
Original Code:
```
public class BungeeModule extends AbstractModule {

    @Override
    public void configure() {
        bindFactory(CommandSender.class, new CommandSenderPartFactory());
        bindFactory(ProxiedPlayer.class, new ProxiedPlayerPartFactory());
        bindFactory(new Key(ProxiedPlayer.class, Sender.class), new ProxiedPlayerSenderPartFactory());
    }
}

```


Overlapping Code:
```
 BungeeModule extends AbstractModule {
@Override
public void configure() {
bindFactory(CommandSender.class, new CommandSenderPartFactory());
bindFactory(ProxiedPlayer.class, new ProxiedPlayerPartFactory());
bindFactory(new Key(ProxiedPlayer.class, Sender.class), new ProxiedP
```
<Overlap Ratio: 0.8675078864353313>

---

--- 168 --
Question ID: 720da52387d7399deb3c25aef1d5a296b400d45c
Original Code:
```
public class BulkOperation extends ExtensibleObject {

    /**
     *  Status ACTIVE: when bulk operation is created.
     */
    public static final String STATUS_ACTIVE = "ACTIVE";

    /**
     *  Status IN_PROGRESS: when bulk operation is performing on all devices.
     */
    public static final String STATUS_IN_PROGRESS = "IN_PROGRESS";

    /**
     * Status COMPLETED: when the operation was performed on all devices.
     */
    public static final String STATUS_COMPLETED = "COMPLETED";

    /**
     * Status DELETED: when already created operation was cancelled by deleting the bulk operation
     */
    public static final String STATUS_DELETED = "DELETED";

    /**
     * Constructor to create a bulk operation.
     */
    public BulkOperation() {
        super();
    }

    /**
     * Internal constructor to create a bulk operation object.
     *
     * @param extensibleObject existing base class object.
     */
    BulkOperation(ExtensibleObject extensibleObject) {
        super(extensibleObject);
    }

    /**
     * Set the unique identifier of the bulk operation.
     * Just used internally.
     *
     * @param id the new identifier created by storing the entity.
     */
    void setId(String id) {
        anyObject.put("id", id);
    }

    /**
     * Get the unique identifier for the bulk operation.
     *
     * @return String with the unique identifier of the bulk operation or null if not
     * available.
     */
    public String getId() {
        Object id = anyObject.get("id");
        if (id == null) {
            return null;
        }
        return id.toString();
    }

    /**
     * Set the groupId of the target group on which the bulk operation should be performed.
     * Group of devices is a managed object from type 'c8y_DeviceGroup' and flagged as 'c8y_IsDeviceGroup'
     *
     * @param groupId the unique identifier of the target group.
     */
    public void setGroupId(String groupId) {
        anyObject.put("groupId", groupId);
    }

    /**
     * Get the groupId of the target group of the bulk operation.
     *
     * @return String with the unique identifier of the target group or null if not
     * available.
     */
    public String getGroupId() {
        return (String) anyObject.get("groupId");
    }

    /**
     * Set the bulk operation id to reschedule this operation on devices where it failed.
     *
     * @param failedBulkOperationId the unique identifier of the bulk operation.
     */
    public void setFailedBulkOperationId(String failedBulkOperationId) {
        anyObject.put("failedBulkOperationId", failedBulkOperationId);
    }

    /**
     * Get the bulk operation id from which failed operation should be rescheduled.
     *
     * @return String with the unique identifier of the failed bulk operation id
     * or null if not available.
     */
    public String getFailedBulkOperationId() {
        return (String) anyObject.get("failedBulkOperationId");
    }

    /**
     * Get the status of the bulk operation.
     * <p>
     * Valid values: ACTIVE, COMPLETED, DELETED
     *
     * @return a String with the status
     */
    public String getStatus() {
        return (String) anyObject.get("status");
    }

    /**
     * Set the status of the bulk operation.
     * <p>
     * Valid values: ACTIVE, COMPLETED, DELETED
     *
     * @param status String which represents the status of the bulk operation.
     */
    public void setStatus(String status) {
        anyObject.put("status", status);
    }

    /**
     * Set the ramp up time, specifying the delay between every operation.
     *
     * @param creationRamp number in seconds.
     */
    public void setCreationRamp(Number creationRamp) {
        anyObject.put("creationRamp", creationRamp);
    }

    /**
     * Get the ramp up time, specifying the delay between every operation.
     *
     * @return the number in seconds.
     */
    public Number getCreationRamp() {
        return (Number) anyObject.get("creationRamp");
    }

    /**
     * Get the time when operation should be started.
     *
     * @return Date object representing the timestamp when bulk operation should be performed.
     */
    public Date getStartDate() {
        return (Date) anyObject.get("startDate");
    }

    /**
     * Set the schedule time.
     *
     * @param startDate Date object with the time when bulk operation should be performed.
     */
    public void setStartDate(Date startDate) {
        anyObject.put("startDate", startDate);
    }

    /**
     * Get the operation which will be executed for every device in the target group.
     *
     * @return Operation object representing the operation which will be executed for every device in the target group.
     */
    public Operation getOperation() {
        Object operationPrototype = anyObject.get("operationPrototype");
        // At first we need to check the type to avoid an unnecessary wrap into Operation Object
        if (operationPrototype instanceof Operation) {
            return (Operation) operationPrototype;
        }
        return new Operation((ExtensibleObject) operationPrototype);
    }

    /**
     * Set the operation which should be executed for every device in the target group.
     *
     * @param operation Operation object representing the operation which need to be executed for every device in the target group.
     */
    public void setOperation(Operation operation) {
        anyObject.put("operationPrototype", operation);
    }

    /**
     * Get the progress of the bulk operation.
     *
     * @return Progress object containing the number of processed bulk operations.
     */
    public Progress getProgress() {
        Object progress = anyObject.get("progress");
        // At first we need to check the type to avoid an unnecessary wrap into Progress Object
        if (progress instanceof Progress) {
            return (Progress) progress;
        }
        return new Progress((ExtensibleObject) progress);
    }

    /**
     * Set the progress of the bulk operation.
     *
     * @param progress Progress object containing the number of processed bulk operations.
     */
    public void setProgress(Progress progress) {
        anyObject.put("progress", progress);
    }
}

```


Overlapping Code:
```
ject {
/**
* Status ACTIVE: when bulk operation is created.
*/
public static final String STATUS_ACTIVE = "ACTIVE";
/**
* Status IN_PROGRESS: when bulk operation is performing on all devices.
*/
public static final String STATUS_IN_PROGRESS = "IN_PROGRESS";
/**
* Status COMPLETED: when the operation was performed on all devices.
*/
public static final String STATUS_COMPLETED = "COMPLETED";
/**
* Status DELETED: when already created operation was cancelled by deleting the bulk operation
*/
public static final String STATUS_DELETED = "DELETED";
/**
* Constructor to create a bulk operation.
*/
public BulkOperation() {
super();
}
/**
* Internal constructor to create a bulk operation object.
*
* @param extensibleObject existing base class object.
*/
BulkOperation(ExtensibleObject extensibleObject) {
super(extensibleObject);
}
/**
* Set the unique identifier of the bulk operation.
* Just used internally.
*
* @param id the new identifier created by storing the entity.
*/
void setId(String id) {
anyObject.put("id", id);
}
/**
* Get the unique identifier for the bulk operation.
*
* @return String with the unique identifier of the bulk operation or null if not
* available.
*/
public String getId() {
Object id = anyObject.get("id");
if (id == null) {
return null;
}
return id.toString();
}
/**
* Set the groupId of the target group on which the bulk operation should be performed.
* Group of devices is a managed object from type 'c8y_DeviceGroup' and flagged as 'c8y_IsDeviceGroup'
*
* @param groupId the unique identifier of the target group.
*/
public void setGroupId(String groupId) {
anyObject.put("groupId", groupId);
}
/**
* Get the groupId of the target group of the bulk operation.
*
* @return String with the unique identifier of the target group or null if not
* available.
*/
public String getGroupId() {
return (String) anyObject.get("groupId");
}
/**
* Set the bulk operation id to reschedule this operation on devices where it failed.
*
* @param failedBulkOperationId the unique identifier of the bulk operation.
*/
public voi
```
<Overlap Ratio: 0.9761904761904762>

---

--- 169 --
Question ID: 3821c2ca9d58dbb74b7f64e42156ebd845507391
Original Code:
```
@Data
public class RouteClientInit {

    private final String url;

    private final int maxContentLength;

    private final String headerRouteValue;

    private Channel channel;

    private CompletableFuture<DefaultFullHttpResponse> response;

    public RouteClientInit(String url, int maxContentLength, String headerRouteValue) {
        this.url = url;
        this.maxContentLength = maxContentLength;
        this.headerRouteValue = headerRouteValue;
    }

    public DefaultFullHttpResponse request(DefaultFullHttpRequest defaultFullHttpRequest) throws InterruptedException, ExecutionException, TimeoutException {
        init().writeAndFlush(defaultFullHttpRequest);
        return response.get(RouteClientInitConstant.REQUEST_TIME_OUT, TimeUnit.MILLISECONDS);
    }

    public void call(DefaultFullHttpResponse defaultFullHttpResponse) {
        response.complete(defaultFullHttpResponse);
    }

    private Channel init() throws InterruptedException {
        response = new CompletableFuture<>();
        if (ChannelUtils.channelIsActive(channel)) {
            return channel;
        }
        channel = new Bootstrap().group(RouteClientEventLoopGroupContainer.getEventLoopGroup(headerRouteValue)).channel(NioSocketChannel.class).handler(new RouteClientInitializer(this)).connect(SocketAddressUtils.getInetSocketAddress(url)).sync().channel();
        return channel;
    }
}

```


Overlapping Code:
```
e final String url;
private final int maxContentLength;
private final String headerRouteValue;
private Channel channel;
private CompletableFuture<DefaultFullHttpResponse> response;
public RouteClientInit(String url, int maxContentLength, String headerRouteValue) {
this.url = url;
this.maxContentLength = maxContentLength;
this.headerRouteValue = headerRouteValue;
}
public DefaultFullHttpResponse request(DefaultFullHttpRequest defaultFullHttpRequest) throws InterruptedException, ExecutionException, TimeoutException {
init().writeAndFlush(defaultFullHttpRequest);
return response.get(RouteClientInitConstant.REQUEST_TIME_OUT, TimeUnit.MILLISECONDS);
}
public void call(DefaultFullHttpResponse defaultFullHttpResponse) {
response.complete(defaultFullHttpResponse);
}
private Channel init() throws InterruptedException {
response = new CompletableFuture<>();
if (ChannelUtils.channelIsActive(channel)) {
return channel;
}
channel = new Bootstrap().group(RouteClientEventLoopGroupContainer.getEventLo
```
<Overlap Ratio: 0.8097165991902834>

---

--- 170 --
Question ID: ac822e94033f3255263e66325468841e95569ce2
Original Code:
```
public class ForLab2 {

    public static void main(String[] args) {
        int[][] x = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
        int sum = 0;
        int i = 0;
        while (i < x.length) try {
            int j = 0;
            while (j < x[i].length) try {
                sum = sum + x[i][j];
            } finally {
                j++;
            }
        } finally {
            i++;
        }
        for (int[] y : x) {
            for (int a : y) {
                System.out.println(a);
            }
        }
    }
}

```


Overlapping Code:
```
2 {
public static void main(String[] args) {
int[][] x = { 
```
<Overlap Ratio: 0.17455621301775148>

---

--- 171 --
Question ID: 8cf6191413c62269aaba8dbcb415341dd329a51a
Original Code:
```
public class UploadServlet extends HttpServlet {

    private static final Logger LOG = LogManager.getLogger(UploadServlet.class);

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        List<String> images = Optional.ofNullable(new File(getServletContext().getRealPath("/images/")).listFiles()).map(files -> Arrays.stream(files).map(File::getName).collect(Collectors.toList())).orElse(Collections.emptyList());
        req.setAttribute("images", images);
        RequestDispatcher dispatcher = req.getRequestDispatcher("/upload-file-view.jsp");
        dispatcher.forward(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        DiskFileItemFactory fileItemFactory = new DiskFileItemFactory();
        ServletContext servletContext = this.getServletConfig().getServletContext();
        File repository = (File) servletContext.getAttribute("javax.servlet.context.tempdir");
        fileItemFactory.setRepository(repository);
        ServletFileUpload upload = new ServletFileUpload(fileItemFactory);
        try {
            List<FileItem> items = upload.parseRequest(req);
            File folder = new File(getServletContext().getRealPath("/images/"));
            if (!folder.exists()) {
                folder.mkdir();
            }
            for (FileItem item : items) {
                if (!item.isFormField()) {
                    File file = new File(folder + File.separator + item.getName());
                    try (FileOutputStream out = new FileOutputStream(file)) {
                        out.write(item.getInputStream().readAllBytes());
                    }
                }
            }
        } catch (FileUploadException e) {
            LOG.error(e.getMessage(), e);
        }
    }
}

```


Overlapping Code:
```
public class UploadServlet extends HttpServlet {
private static final Logger LOG = LogManager.getLogger(UploadServlet.class);
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
List<String> images = Optional.ofNullable(new File(getServletContext().getRealys.stream(files).map(File::getName).collect(Collectors.toList())).orElse(Collections.emptyList());
req.setAttribute("images", images);
RequestDispatcher dispatcher = req.getRequestDispatcher("/upload-file-view.jsp");
dispatcher.forward(req, resp);
}
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
DiskFileItemFactory fileItemFactory = new DiskFileItemFactory();
ServletContext servletContext = this.getServletConfig().getServletContext();
File repository = (File) servletContext.getAttribute("javax.servlet.context.tempdir");
fileItemFactory.setRepository(repository);
ServletFileUpload upload = new ServletFileUpload(fileItemFactory);
try {
List<FileItem> items = upload.parseRequest(req);
File folder = new File(getServletContext().getRealPath("/images/"));
if (!folder.exists()) {
folder.mkdir();
}
for (FileItem item : items) {
if (!item.isFormField()) {
File file = new File(folder + File.separator + item.getName());
try (FileOutputStream out = new FileOutputStream(file)) {
out.write(item.getInputStream().readAllBytes());
}
}
}
} catch (FileUploadException e) {
LOG.error(e.getMessage(), e);
}
}
}
```
<Overlap Ratio: 0.9690522243713733>

---

--- 172 --
Question ID: 6dcf5fe7919988d61c0342c48991b47067c19326
Original Code:
```
public class PointToPointIntentCompiler extends AbstractFlowGeneratingIntentCompiler<PointToPointIntent> {

    private final ITopologyService topologyService;

    /**
     * Constructs an intent compiler for {@link PointToPointIntent} with the specified
     * ID generator and topology service.
     *
     * @param intentIdGenerator intent ID generator
     * @param topologyService topology service
     */
    public PointToPointIntentCompiler(IdGenerator<IntentId> intentIdGenerator, IdGenerator<FlowId> flowIdGenerator, ITopologyService topologyService) {
        super(intentIdGenerator, flowIdGenerator);
        this.topologyService = checkNotNull(topologyService);
    }

    @Override
    public List<Intent> compile(PointToPointIntent intent) {
        Match match = intent.getMatch();
        if (!(match instanceof PacketMatch)) {
            throw new IntentCompilationException("intent has unsupported type of match object: " + match);
        }
        SwitchPort ingress = intent.getIngressPort();
        SwitchPort egress = intent.getEgressPort();
        FlowId flowId = getNextFlowId();
        Path path = calculatePath(ingress, egress);
        List<Action> actions = packActions(intent, intent.getEgressPort());
        PacketPathFlow flow = new PacketPathFlow(flowId, (PacketMatch) match, ingress.getPortNumber(), path, actions, 0, 0);
        return Arrays.asList((Intent) new PathFlowIntent(getNextId(), flow));
    }

    /**
     * Calculates a path between the specified ingress port and the specified egress port.
     * @param ingress ingress port
     * @param egress egress port
     * @return path
     */
    private Path calculatePath(SwitchPort ingress, SwitchPort egress) {
        BaseTopology topology = topologyService.getTopology();
        Switch source = topology.getSwitch(ingress.getDpid());
        Switch destination = topology.getSwitch(egress.getDpid());
        if (source == null) {
            throw new PathNotFoundException("source switch not found: " + ingress.getDpid());
        }
        if (destination == null) {
            throw new PathNotFoundException("destination switch not found: " + egress.getDpid());
        }
        ConstrainedBFSTree tree = new ConstrainedBFSTree(source);
        net.onrc.onos.core.intent.Path path = tree.getPath(destination);
        return convertPath(path);
    }

    /**
     * Converts a {@link net.onrc.onos.core.intent.Path} to {@link Path}.
     *
     * @param path original {@link net.onrc.onos.core.intent.Path}
     * @return converted {@link Path}
     */
    static Path convertPath(net.onrc.onos.core.intent.Path path) {
        // TODO: replace with transform when the above issue is resolved
        ImmutableList<LinkData> dataEntries = FluentIterable.from(path).filter(Predicates.notNull()).toList();
        Path converted = new Path();
        for (LinkData data : dataEntries) {
            converted.add(new FlowLink(data.getSrc(), data.getDst()));
        }
        return converted;
    }
}

```


Overlapping Code:
```
nds AbstractFlowGeneratingIntentCompiler<PointToPointIntent> {
private final ITopologyService topologyService;
/**
* Constructs an intent compiler for {@link PointToPointIntent} with the specified
* ID generator and topology service.
*
* @param intentIdGenerator intent ID generator
* @param topologyService topology service
*/
public PointToPointIntentCompiler(IdGenerator<IntentId> intentIdGeneratoervice topologyService) {
super(intentIdGenerator, flowIdGenerator);
this.topologyService = checkNotNull(topologyService);
}
@Override
public List<Intent> compile(PointToPointIntent intent) {
Match match = intent.getMatch();
if (!(match instanceof PacketMatch)) {
throw new IntentCompilationExceptionent has unsupported type of match object: " + matcsPort();
SwitchPort egress = intent.getEgressPort();
FlowId flowId = getNextFlowId();
Path path = calculatePath(ingress, egress);
List<Action> actions = packActions(intent, intent.getEgressPort());
PacketPathFlow flow = new PacketPathFlow(flowId, (Pactions, 0, 0);
return Arrays.asList((Intent) new PathFlowIntent(getNextId(), flow));
}
/**
* Calculates a path between the specified ingress port and the specified egress port.
* @param ingress ingress port
* @param egress egress port
* @return path
*/
private Path calculatePath(SwitchPort ingress, SwitchPort egress) {
BaseTopology topology = topologyService.getTopology();
Switch source = topology.getSwitch(ingress.getDpid());
Switch destination = topology.getSwitch(egress.getDpid());
if (source == null) {
throw new PathNotFoundException("source switch not found: " + ingress.getDpid());
}
if (destination == null) {
throw new PathNotFoundException("destination switch not found: " + egress.getDpid());
}
ConstrainedBFSTree tree = new ConstrainedBFSTree(source);
net.onrc.onos.core.intent.Path path = tree.getPath(destination);
return convertPath(path);
}
/**
* Converts a {@link net.onrc.onos.core.intent.Path} to {@link Path}.
*
* @param path
```
<Overlap Ratio: 0.8994464944649446>

---

--- 173 --
Question ID: 763fc82862a43e0b16eb8f74bb7a4c58704f0059
Original Code:
```
public class MessageBindingsReader {

    public MessageBindingsReader() {
    }

    public static MessageBindings readMessageBindings(final AnnotationScannerContext context, final AnnotationValue annotationValue) {
        if (annotationValue == null) {
            return null;
        }
        IoLogging.logger.annotationsArray("@MessageBindings");
        AnnotationInstance nested = annotationValue.asNested();
        MessageBindings bindings = new MessageBindingsImpl();
        bindings.setAMQPBinding(AMQPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_AMQP_BINDING)));
        bindings.setHTTPBinding(HTTPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_HTTP_BINDING)));
        bindings.setKafkaBinding(KafkaMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_KAFKA_BINDING)));
        bindings.setMQTTBinding(MQTTMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_MQTT_BINDING)));
        return bindings;
    }

    public static MessageBindings readMessageBindings(final JsonNode node) {
        if (node == null) {
            return null;
        }
        IoLogging.logger.singleJsonNode("ChannelBindings");
        MessageBindings bindings = new MessageBindingsImpl();
        bindings.setAMQPBinding(AMQPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_AMQP_BINDING)));
        bindings.setHTTPBinding(HTTPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_HTTP_BINDING)));
        bindings.setKafkaBinding(KafkaMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_KAFKA_BINDING)));
        bindings.setMQTTBinding(MQTTMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_MQTT_BINDING)));
        return bindings;
    }
}

```


Overlapping Code:
```
c MessageBindingsReader() {
}
public static MessageBindings readMessageBindings(final AnnotationScannerContext context, final AnnotationValue annotationValue) {
if (annotationValue == null) {
return null;
}
IoLogging.logger.annotationsArray("@MessageBindings");
AnnotationInstance nested = annotationValue.asNested();
MessageBindings bindings = new MPMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_AMQP_BINDING)));PMessageBindingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_HTTP_BINDING)));
bindings.setKafkaBinndingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_KAFKA_ndingReader.readMessageBinding(nested.value(MessageBindingsConstants.PROP_MQTT_BINDING)));
return bindings;
}
public static MessageBindings readMessageBindings(final JsonNode node) {
if (node == null) {
return null;
}
IoLogging.logger.singleJsonNode("ChannelBindings");
MessageBindings bindings = newMQPMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_AMQP_BINDING)));
br.readMessageBinding(node.get(MessageBindingsConstants.PROP_HTTP_BINDING)));
bindings.setKafkaBinKafkaMessageBindingReader.readMessageBinding(node.get(MessageBindingsConstants.PROP_KAFKA_BINDING)))r.readMessageBinding(node.get(MessageBindingsConstants.PROP_MQTT_BINDING)));
return bi
```
<Overlap Ratio: 0.793575252825699>

---

--- 174 --
Question ID: 969a8d791f5bc2edfa349e8c2e0c99f9951846c6
Original Code:
```
@Component
public class StartCommandHandler implements ICommandHandler {

    private final UserService userService;

    public StartCommandHandler(UserService userService) {
        this.userService = userService;
    }

    @Override
    public boolean accept(String command) {
        return Objects.equals(command, "/start");
    }

    @Override
    public SendMessage handle(User user, String[] args) {
        String chatId = user.getId().toString();
        if (args == null || args.length == 0) {
            userService.resetUser(user);
            return new SendMessage(chatId, getHelpMessage());
        }
        String botAnswer;
        if (args[0].equals("leaveFeedback")) {
            Long eventId = Long.parseLong(args[1]);
            Long feedbackId = args.length == 3 ? Long.parseLong(args[2]) : null;
            user.setConversationStatus(ConversationStatus.LeaveFeedback);
            user.setSelectedEventId(eventId);
            user.setSelectedFeedbackId(feedbackId);
            userService.insertOrUpdate(user);
            botAnswer = "Write your message";
        } else {
            botAnswer = "Something went wrong!";
        }
        return new SendMessage(chatId, botAnswer);
    }
}

```


Overlapping Code:
```
mponent
public class StartCommandHandler implements ICommandHandler {
private final UserService userService;
public StartCommandHandler(UserService userService) {
this.userService = userService;
}
@Override
public boolean accept(String command) {
return Objects.equals(command, "/start");
}
@Override
public SendMessage handle(User user, String[] args) {
String chatId = user.getId().toString();
if (args == null || args.length == 0) {
userService.resetUser(user);
return new SendMessage(chatId, getHelpMessage());
}
String botAnswer;
if (args[0].equals("leaveFeedback")) {
Long eventId = Long.parseLong(args[1]);
Long feedbackId = args.length == 3 ? Long.parseLong(args[2]) : null;
user.setConversationStatus(ConversationStatus.LeaveFeedback);
user.setSelectedEventId(eventId);
user.setSelectedFeedbackId(feedbackId);
userService.insertOrUpdate(usernswer = "Something went wrong!";
}
return new Send
```
<Overlap Ratio: 0.9146341463414634>

---

--- 175 --
Question ID: 148008a50c8bbbb2285f3a440bc17c14279086c3
Original Code:
```
@RunWith(JUnit4.class)
public class InheritanceHelperTest {

    @Test
    public void testEmptyChildList() {
        // be copied to the child.
        List<Resource> parentList = Arrays.asList(Resource.createResource(null, DungeonGen.class, 4, 100, 10, 30), Resource.createResource(null, DungeonGen.class, 1, 50, 30, 60));
        List<Resource> childList = Collections.emptyList();
        List<Resource> result = InheritanceHelper.mergeLists(childList, parentList);
        assertEquals(parentList, result);
    }

    @Test
    public void testOverrides() {
        List<Resource> parentList = Arrays.asList(Resource.createResource(null, DungeonGen.class, 4, 100, 10, 30));
        List<Resource> childList = Arrays.asList(Resource.createResource(null, DungeonGen.class, 1, 50, 30, 60));
        List<Resource> result = InheritanceHelper.mergeLists(childList, parentList);
        assertEquals(childList, result);
    }
}

```


Overlapping Code:
```
ateResource(null, DungeonGen.class, 1, 50, 30, 60));
List<ResoList = Collections.emptyList();
List<Resource> result = InheritanceHelper.mergeLists(childList, parentList);
assertEquals(parentList, result);
}
@Test
public void testOverridesngeonGen.class, 4, 100, 10, 30));
List<Resource> cateResource(null, DungeonGen.class, 1, 50, 30, 60));
List<Resource> result = InheritanceHelper.mergeLists(childList, parentList);
assertEquals(childList, result);
```
<Overlap Ratio: 0.5434782608695652>

---

--- 176 --
Question ID: 11bd2a32cfcc0fc4457dad773f0af7c018a9725c
Original Code:
```
public class h_svRenderer implements GLSurfaceView.Renderer {

    private boolean circleShowing = false;

    private int circleXstart = 0;

    private int circleYstart = 0;

    private int circleX = 0;

    private int circleY = 0;

    private float circleSize = 0;

    private int width;

    private int height;

    private float onePixelWidth = 0f;

    private float onePixelHeight = 0f;

    private sv_2d_gradient sv_2d_gradient;

    private hueBar hueBar;

    private circle circle;

    private circle selected_sv_circle;

    private rect hueRect;

    private float hueRectWidth;

    private int dpi;

    private float hue;

    public float getHue() {
        return hue;
    }

    private float _saturation;

    public float getSaturation() {
        return _saturation;
    }

    private float _value;

    public float getValue() {
        return _value;
    }

    // color change task that gets ran in onSurfaceChanged
    private boolean doSetColorJob = false;

    private float colorJobHue;

    private float colorJobSaturation;

    private float colorJobValue;

    public void onSurfaceCreated(GL10 gl, EGLConfig config) {
        // enable vertex arrays
        gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
        // enable color arrays
        gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
        gl.glShadeModel(GL10.GL_SMOOTH);
        gl.glClearColor(0, 0, 0, 0);
    }

    public void setColor(float[] color) {
        colorJobHue = color[0];
        colorJobSaturation = color[1];
        colorJobValue = color[2];
        doSetColorJob = true;
    }

    public void showCircle() {
        circleShowing = true;
    }

    public void hideCircle() {
        circleShowing = false;
    }

    private boolean pointInsideMainGradient(int x, int y) {
        if (sv_2d_gradient == null) {
            return false;
        }
        // left
        float left = (sv_2d_gradient.getLeft()) / onePixelWidth;
        int leftmargin = (int) (left + (width / 2)) + 1;
        boolean result = true;
        if ((x < leftmargin)) {
            result = false;
        }
        // right
        float right = (sv_2d_gradient.getRight()) / onePixelWidth;
        int rightmargin = (int) (right + (width / 2));
        if ((x > rightmargin)) {
            result = false;
        }
        // top
        float top = (sv_2d_gradient.getTop()) / onePixelHeight;
        int topmargin = (int) Math.abs((top - (height / 2)));
        if ((y < topmargin)) {
            result = false;
        }
        // bottom
        float bottom = (sv_2d_gradient.getBottom()) / onePixelHeight;
        int bottommargin = (int) Math.abs((bottom - (height / 2)));
        if ((y > bottommargin)) {
            result = false;
        }
        return result;
    }

    public boolean pointInsideHueSlider(int x, int y) {
        if (hueRect == null) {
            return false;
        }
        // left
        float left = (hueBar.getLeft()) / onePixelWidth;
        int leftmargin = (int) (left + (width / 2)) + 1;
        boolean result = true;
        if ((x < leftmargin)) {
            result = false;
        }
        // right
        float right = (hueBar.getRight()) / onePixelWidth;
        int rightmargin = (int) (right + (width / 2));
        if ((x > rightmargin)) {
            result = false;
        }
        // top
        float top = (hueBar.getTop()) / onePixelHeight;
        int topmargin = (int) (top - (height / 2));
        if ((y < topmargin)) {
            result = false;
        }
        return result;
    }

    public void startMoveCircle(float x, float y) {
        circleXstart = (int) x;
        circleYstart = (int) y;
    }

    public void moveCircle(float x, float y, float size) {
        if (pointInsideMainGradient(circleXstart, circleYstart)) {
            circleX = (int) x;
            circleY = (int) y;
            circleSize = size;
            if (sv_2d_gradient != null) {
                // left
                float left = (sv_2d_gradient.getLeft()) / onePixelWidth;
                int leftmargin = (int) (left + (width / 2)) + 1;
                if (circleX < leftmargin) {
                    circleX = (int) leftmargin;
                }
                // right
                float right = (sv_2d_gradient.getRight()) / onePixelWidth;
                int rightmargin = (int) (right + (width / 2));
                if (circleX > rightmargin) {
                    circleX = (int) rightmargin;
                }
                // top
                float top = (sv_2d_gradient.getTop()) / onePixelHeight;
                int topmargin = (int) Math.abs((top - (height / 2)));
                if (circleY < topmargin) {
                    circleY = (int) topmargin;
                }
                // bottom
                float bottom = (sv_2d_gradient.getBottom()) / onePixelHeight;
                int bottommargin = (int) Math.abs((bottom - (height / 2)));
                if (circleY > bottommargin) {
                    circleY = (int) bottommargin;
                }
                float value = (sv_2d_gradient.getValues()[circleX - leftmargin]);
                float saturation = (sv_2d_gradient.getSaturations()[circleY - topmargin]);
                value = reverseFloatWithRange(value, 0f, 1f);
                if (value > 1f) {
                    value = 1f;
                }
                if (value < 0.0000001f) {
                    value = 0f;
                }
                _value = value;
                _saturation = saturation;
            }
        } else if (pointInsideHueSlider(circleXstart, circleYstart)) {
            // calculate new location
            float left = (hueBar.getLeft()) / onePixelWidth;
            int leftmargin = (int) (left + (width / 2)) + 1;
            float right = (hueBar.getRight()) / onePixelWidth;
            int rightmargin = (int) (right + (width / 2)) + 1;
            int bottom_margin_dp = 20;
            int b_px = bottom_margin_dp * (dpi / 160);
            float bottom_margin = heightPxToFloat(b_px);
            int screen_height_dp = height / (dpi / 160);
            int top_margin_dp = (screen_height_dp) - 90;
            int px = (top_margin_dp * (dpi / 160));
            float top_margin = heightPxToFloat(px);
            float screen_width_f = floatFromPx(width, 0);
            float x2;
            if (x <= leftmargin + 1) {
                x = leftmargin + 1;
                x2 = floatFromPx((int) x, 0);
            } else {
                x2 = floatFromPx((int) x, 0);
            }
            if (x >= rightmargin - 1) {
                x = rightmargin - 1;
                x2 = floatFromPx((int) x, 0);
            } else {
                x2 = floatFromPx((int) x, 0);
            }
            float new_left = ((-(hueRectWidth)) + x2) - screen_width_f / 2;
            float new_top = -1f + bottom_margin;
            float new_right = (((hueRectWidth)) + x2) - screen_width_f / 2;
            float new_bottom = 1f - top_margin;
            hueRect.setLocation(new_left, new_top, new_right, new_bottom);
            // set hue for main gradient
            float hue1 = floatFromPx((int) (x - leftmargin), 0);
            hue1 = ((hue1 / floatFromPx(hueBar.getWidth(), 0)));
            float hueReal = hue1 * 360f;
            hueReal = reverseFloatWithRange(hueReal, 0f, 360f);
            sv_2d_gradient.updateHue(hueReal);
            // Log.i("DEFCOL","current hue: "+hueReal);
            hue = hueReal;
        }
    }

    private float reverseFloatWithRange(float f, float min, float max) {
        float middle;
        if (min == 0f) {
            middle = max / 2;
        } else {
            // (max-min)/2?
            middle = max / min;
        }
        if (f > middle) {
            f = f - ((f - middle) * 2);
        } else if (f < middle) {
            f = f + ((middle - f) * 2);
        }
        return f;
    }

    // DRAW-DRAW-DRAW-DRAW-DRAW!! *spins in chair with pencil on head*
    public void onDrawFrame(GL10 gl) {
        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
        // draw main box \\
        sv_2d_gradient.draw();
        selected_sv_circle.updateLocation(circleX, circleY, 0.1f);
        selected_sv_circle.draw();
        hueBar.draw();
        hueRect.draw();
    }

    public void setDpi(int DPI) {
        dpi = DPI;
    }

    public void onSurfaceChanged(GL10 gl, int _width, int _height) {
        // send to gl
        gl.glViewport(0, 0, _width, _height);
        // save data in memory
        width = _width;
        height = _height;
        onePixelWidth = (new Float(1) / new Float(width)) * 2;
        onePixelHeight = (new Float(1) / new Float(height)) * 2;
        // calculate top margin
        int top_margin_dp = 20;
        int px = top_margin_dp * (dpi / 160);
        float top_margin = heightPxToFloat(px);
        // calculate bottom margin
        int bottom_margin_dp = 100;
        int b_px = bottom_margin_dp * (dpi / 160);
        float bottom_margin = heightPxToFloat(b_px);
        // create gradient
        sv_2d_gradient = new sv_2d_gradient(gl, -0.9f, 0.9f, -1f + bottom_margin, 1f - top_margin, 250f, onePixelWidth, onePixelHeight);
        // calculate bottom margin
        bottom_margin_dp = 20;
        b_px = bottom_margin_dp * (dpi / 160);
        bottom_margin = heightPxToFloat(b_px);
        int screen_height_dp = height / (dpi / 160);
        top_margin_dp = (screen_height_dp) - 90;
        px = (top_margin_dp * (dpi / 160));
        top_margin = heightPxToFloat(px);
        hueRectWidth = (5 * onePixelWidth) / 2;
        // create hue bar
        hueBar = new hueBar(gl, -0.9f, 0.9f, -1f + bottom_margin, 1f - top_margin, onePixelWidth, onePixelHeight);
        // create circle
        circle = new circle(gl, 0.5f, 0.5f, 0.5f, 2.0f, onePixelWidth, onePixelHeight, width, height);
        selected_sv_circle = new circle(gl, 0.5f, 0.5f, 0.1f, 2.0f, onePixelWidth, onePixelHeight, width, height);
        // create hueRect
        hueRect = new rect(gl, -0.9f - (hueRectWidth), -1f + bottom_margin, -0.9f + (hueRectWidth), 1f - top_margin, 2f, onePixelWidth, onePixelHeight, width, height);
        if (doSetColorJob == true) {
            float screen_width_f = floatFromPx(width, 0);
            // hue
            float scaledToOne = colorJobHue / 360f;
            float x3 = (scaledToOne * (hueBar.getWidth())) + ((((1f - Math.abs(hueBar.getLeft()))) / onePixelWidth));
            x3 = reverseFloatWithRange(x3, 0f, width);
            circleXstart = (int) (width / 2);
            circleYstart = (int) (height - bottom_margin);
            moveCircle(x3, (height - bottom_margin), 0.5f);
            // saturation and value
            if (colorJobValue == 0f && colorJobSaturation == 0f) {
                int left_margin = (int) (((1f - Math.abs(hueBar.getLeft()))) / onePixelWidth);
                top_margin_dp = 20;
                px = top_margin_dp * (dpi / 160);
                top_margin = px;
                x3 = left_margin;
                ;
                float y3 = top_margin + sv_2d_gradient.getHeight();
                circleXstart = (int) x3 + 1;
                circleYstart = (int) y3;
                moveCircle(x3 + 1, y3, 0.5f);
            } else {
                top_margin_dp = 20;
                px = top_margin_dp * (dpi / 160);
                top_margin = px;
                scaledToOne = colorJobSaturation;
                int left_margin = (int) (((1f - Math.abs(hueBar.getLeft()))) / onePixelWidth);
                x3 = (scaledToOne * (hueBar.getWidth()));
                x3 = reverseFloatWithRange(x3, 0f, hueBar.getWidth());
                x3 += left_margin;
                scaledToOne = colorJobValue;
                float y3 = (scaledToOne * (sv_2d_gradient.getHeight()));
                y3 = reverseFloatWithRange(y3, 0f, sv_2d_gradient.getHeight());
                y3 += top_margin;
                circleXstart = (int) x3 + 1;
                circleYstart = (int) y3;
                moveCircle(x3 + 1, y3, 0.5f);
            }
        }
    }

    public float heightPxToFloat(int px) {
        // deprecated
        float f = 0.0f;
        if (px != 0) {
            int i = 0;
            while (i < px) try {
                f += onePixelHeight;
            } finally {
                i++;
            }
        }
        return f;
    }

    public float floatFromPx(int px, int axis) {
        float result = 0f;
        if (px != 0) {
            int i = 0;
            while (i < px) try {
                if (axis == 0) {
                    result += onePixelWidth;
                } else {
                    result += onePixelHeight;
                }
            } finally {
                i++;
            }
        }
        return result;
    }
}

```


Overlapping Code:
```
Renderer implements GLSurfaceView.Renderer {
private boolean circleShowing = false;
private int circleXstart = 0;
private int circleYstart = 0;
private int circleX = 0;
private int circleY = 0;
private float circleSize = 0;
private int width;
private int height;
private float onePixelWidth = 0f;
private float onePixelHeight = 0f;
private sv_2d_gradient sv_2d_gradient;
private hueBar hueBar;
private circle circle;
private circle selected_sv_circle;
private rect hueRect;
private float hueRectWidth;
SurfaceChanged
private boolean doSetColorJob = false;
private float colorJobHue;
private float colorJobSaturation;
private float colorJobValue;
public void onSurfaceCreated(GL10 gl, EGLConfig config) {
// enable vertex arrays
gl.glEnableClientState(GL10.GL_VERTEX_ARRAY
gl.glEnableClientState(GL10.GL_COLOR_ARRAY);
gl.glShadeModel(GL10.GL_SMOOTH);
gl.glClearColor(
public void setColor(float[] color) {
colorJobHue = color[0];
colorJobSaturation = color[1];
colorJc void showCircle() {
circleShowing = true;
}
public void hideCircle() {
circleShowing = false;
}
prin)) {
result = false;
}
// top
float top = (sv_2dgin = (int) Math.abs((top - (height / 2)));
if ((y
```
<Overlap Ratio: 0.5812562313060817>

---

--- 177 --
Question ID: be33f2724e1da203f9adeebe11e277cb5a219833
Original Code:
```
@Structure(name = "QSD", structureType = StructureType.DATATYPE)
public class QSD<T extends IAny> extends QSET<T> implements Iterable<ISetComponent<T>> {

    // The minuend of this difference
    private ISetComponent<T> m_minuend;

    // The subtrahend of this difference
    private ISetComponent<T> m_subtrahend;

    /**
     * Creates a new instance of the QSD{T} class
     */
    public QSD() {
        super();
    }

    /**
     * Creates a new instance of the QSD class with the specified minuend and subtrahend
     * @param minuend The initial value of the minuend
     * @param subtrahend The initial value of the subtrahend
     */
    public QSD(ISetComponent<T> minuend, ISetComponent<T> subtrahend) {
        this.m_minuend = minuend;
        this.m_subtrahend = subtrahend;
    }

    /**
     * Gets the value representing the minuend of the difference expression
     */
    @Property(name = "minuend", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)
    public ISetComponent<T> getMinuend() {
        return this.m_minuend;
    }

    /**
     * Sets the value representing the minuend of the difference expression
     */
    public void setMinuend(ISetComponent<T> value) {
        this.m_minuend = value;
    }

    /**
     * Gets the value representing the subtrahend
     */
    @Property(name = "subtrahend", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)
    public ISetComponent<T> getSubtrahend() {
        return this.m_subtrahend;
    }

    /**
     * Sets a value representing the subtrahend
     */
    public void setSubtrahend(ISetComponent<T> value) {
        this.m_subtrahend = value;
    }

    /**
     * Normalize the expression
     */
    @SuppressWarnings("unchecked")
    @Override
    public IGraphable normalize() {
        QSD<T> retVal = (QSD<T>) this.shallowCopy();
        if (retVal.m_minuend instanceof SXPR<?>)
            retVal.m_minuend = ((SXPR<T>) retVal.m_minuend).translateToQSET();
        if (retVal.m_subtrahend instanceof SXPR<?>)
            retVal.m_subtrahend = ((SXPR<T>) retVal.m_subtrahend).translateToQSET();
        return retVal;
    }

    /**
     * Get the iterator
     */
    @Override
    public Iterator<ISetComponent<T>> iterator() {
        ArrayList<ISetComponent<T>> iterable = new ArrayList<ISetComponent<T>>();
        iterable.add(this.m_minuend);
        iterable.add(this.m_subtrahend);
        return iterable.iterator();
    }

    /**
     * Get the equivalent set operator
     */
    @Override
    protected SetOperator getEquivalentSetOperator() {
        return SetOperator.Exclusive;
    }

    /**
     * (non-Javadoc)
     * @see org.marc.everest.datatypes.ANY#validateEx()
     */
    @Override
    public Collection<IResultDetail> validateEx() {
        List<IResultDetail> retVal = new ArrayList<IResultDetail>();
        if (!(this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull())))
            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, "QSD", EverestValidationMessages.MSG_NULLFLAVOR_WITH_VALUE, null));
        if (this.m_minuend == null || this.m_minuend.isNull())
            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, "QSD", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, "Minuend", String.format("ISetComponent<{0}>", "?")), null));
        if (this.m_subtrahend == null || this.m_subtrahend.isNull())
            retVal.add(new DatatypeValidationResultDetail(ResultDetailType.ERROR, "QSD", String.format(EverestValidationMessages.MSG_DEPENDENT_VALUE_MISSING, "Subtrahend", String.format("ISetComponent<{0}>", "?")), null));
        return retVal;
    }

    /**
     * (non-Javadoc)
     * @see org.marc.everest.datatypes.HXIT#validate()
     */
    @Override
    public boolean validate() {
        boolean isValid = this.isNull() ^ (this.m_minuend != null && !this.m_minuend.isNull() && this.m_subtrahend != null && !this.m_subtrahend.isNull());
        return isValid;
    }

    /**
     * (non-Javadoc)
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = super.hashCode();
        result = prime * result + ((m_minuend == null) ? 0 : m_minuend.hashCode());
        result = prime * result + ((m_subtrahend == null) ? 0 : m_subtrahend.hashCode());
        return result;
    }

    /**
     * (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @SuppressWarnings("unchecked")
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (!super.equals(obj))
            return false;
        if (getClass() != obj.getClass())
            return false;
        QSD<T> other = (QSD<T>) obj;
        if (m_minuend == null) {
            if (other.m_minuend != null)
                return false;
        } else if (!m_minuend.equals(other.m_minuend))
            return false;
        if (m_subtrahend == null) {
            if (other.m_subtrahend != null)
                return false;
        } else if (!m_subtrahend.equals(other.m_subtrahend))
            return false;
        return true;
    }
}

```


Overlapping Code:
```
"QSD", structureType = StructureType.DATATYPE)
public class QSD<T extends IAny> extends QSET<T> implements Iterable<ISetComponent<T>> {
// The minuend of this difference
private ISetComponent<T> m_minuend;
// The subtrahend of this difference
private ISetCompone() {
super();
}
/**
* Creates a new instance of the  class with the specified minuend and subtrahend
* @param minuend The initial value of the minuend
* @param subtrahend The initial value of the subtrahend
*/
public QSD(ISetComponent<T> minuend, ISetCs the value representing the minuend of the difference expression
*/
@Property(name = "minuend", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)
public ISetComponent<T> getMinuend() {
return this.m_minuend;
}
/**
* Sets the value representing the minuend of the difference expression
*/
public void setMinuend(ISetComponent<T> value) {
this.m_minuend = value;
}
/**
* Gets the value representing the subtrahend
*/
@Property(name = "subtrahend", propertyType = PropertyType.NONSTRUCTURAL, conformance = ConformanceType.MANDATORY)
public ISetComponent<T> getSubtrahend() {
return this.m_subtrahend;
}
/**
* Sets a value representing the subtrahend
*/
public void setSubtrahend(ISetComponent<T> value) {
this.m_subtrahend = value;
}
/**
* Normalize the expression
*/
@SuppressWarnings("unchecked")
@Override
public IGraphable normalize() {allowCopy();
if (retVal.m_minuend instanceof SXPR<.translateToQSET();
if (retVal.m_subtrahend instanal.m_subtrahend).translateToQSET();
return retVal;
}
/**
* Get the iterator
*/
@Override
public Iterator<ISetComponent<T>> iterator() {
ArrayList<ISetComponent<T>> iterable = new ArrayList<ISetComponent<T>>();
iterable.add(this.m_minuend);
iterable.add(this.m_subtrahend);
return iterable.iterator();
```
<Overlap Ratio: 0.8420556341348421>

---

--- 178 --
Question ID: c7f36a8c5229e6ee24a8be25281e4e42828dbf4e
Original Code:
```
@IntentBuilder
public class DetailActivity extends AppCompatActivity {

    @Extra
    String one;

    @Extra
    String two;

    @Extra
    @Nullable
    String three;

    @Extra
    @Nullable
    String four;

    @Extra("five")
    @Nullable
    String mFive;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        DetailActivityIntentBuilder.inject(getIntent(), this);
        setContentView(R.layout.activity_detail);
        ((TextView) findViewById(R.id.one)).setText(one);
        ((TextView) findViewById(R.id.two)).setText(two);
        ((TextView) findViewById(R.id.three)).setText(three);
        ((TextView) findViewById(R.id.four)).setText(four);
        ((TextView) findViewById(R.id.five)).setText(mFive);
    }
}

```


Overlapping Code:
```

public class DetailActivity extends AppCompatActivity {
@Extra
String one;
@Extra
ring mFive;
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
DetailActivityIntentBuilder.inject(getIntent(), this);
setContentView(R.layout.activity_detail);
((TextView) f
```
<Overlap Ratio: 0.45331325301204817>

---

--- 179 --
Question ID: 5e28482a90909ff8a582c684e353d5dcc0a58b48
Original Code:
```
@EqualsAndHashCode(of = { "annotatedObject", "descriptor", "clientId" })
class /* package */
AnnotatedModelInterceptor implements IModelInterceptor {

    private static final transient Logger logger = LogManager.getLogger(AnnotatedModelInterceptor.class);

    private final AnnotatedModelInterceptorDescriptor descriptor;

    private final transient Object annotatedObject;

    private ClientId clientId;

    /**
     * @param annotatedObject
     */
    AnnotatedModelInterceptor(@NonNull final Object annotatedObject) {
        this.annotatedObject = annotatedObject;
        this.descriptor = new AnnotatedModelInterceptorDescriptorBuilder(annotatedObject.getClass()).build();
    }

    @Override
    public String toString() {
        return "annotated[" + annotatedObject.getClass().getName() + "]";
    }

    /**
     * @return true if it has no initializers, no pointcuts, no nothing
     */
    public boolean isEmpty() {
        return descriptor.isEmpty();
    }

    @Override
    public void initialize(final IModelValidationEngine engine, final I_AD_Client client) {
        if (client != null) {
            this.clientId = ClientId.ofRepoId(client.getAD_Client_ID());
        }
        bindPointcuts(engine);
        // Execute initializers
        for (final InterceptorInit init : descriptor.getInitializers()) {
            Object[] params = new Object[] {};
            if (init.isMethodRequiresEngine()) {
                params = new Object[] { engine };
            }
            final Method method = init.getMethod();
            try {
                // Make sure the method is accessible
                if (!method.isAccessible()) {
                    method.setAccessible(true);
                }
                // Execute
                method.invoke(annotatedObject, params);
            } catch (Exception e) {
                throw new AdempiereException("Cannot initialize " + annotatedObject + ". Initializer " + init + " failed." + "\n Method: " + method + "\n Params:" + Arrays.toString(params) + "\n Method Descriptor: " + init, Throwables.getRootCause(e));
            }
            logger.debug("Initializer {} executed successfully.", init);
        }
    }

    private void bindPointcuts(@NonNull final IModelValidationEngine engine) {
        logger.debug("Binding pointcuts for {}", annotatedObject);
        for (final PointcutKey key : descriptor.getPointcutKeys()) {
            final Set<Pointcut> list = descriptor.getPointcuts(key);
            if (list.isEmpty()) {
                continue;
            }
            logger.debug("Binding pointcuts for {} on {}", annotatedObject, key);
            switch(key.getType()) {
                case ModelChange:
                    engine.addModelChange(key.getTableName(), this);
                    break;
                case DocValidate:
                    engine.addDocValidate(key.getTableName(), this);
                    break;
                default:
                    throw new AdempiereException("Unknown PointcutType " + key.getType());
            }
        }
        logger.debug("Binding pointcuts for {} done.", annotatedObject);
    }

    @Override
    public int getAD_Client_ID() {
        return ClientId.toRepoId(clientId);
    }

    @Override
    public void onUserLogin(final int AD_Org_ID, final int AD_Role_ID, final int AD_User_ID) {
    }

    @Override
    public final void onModelChange(final Object model, final ModelChangeType changeType) {
        execute(PointcutType.ModelChange, model, changeType.toInt());
    }

    @Override
    public final void onDocValidate(final Object model, final DocTimingType timing) {
        execute(PointcutType.DocValidate, model, timing.toInt());
    }

    private void execute(final PointcutType type, final Object po, final int timing) {
        final String tableName = InterfaceWrapperHelper.getModelTableName(po);
        final PointcutKey key = PointcutKey.of(tableName, type);
        final ImmutableSet<Pointcut> pointcuts = descriptor.getPointcuts(key);
        if (pointcuts.isEmpty()) {
            return;
        }
        for (final Pointcut pointcut : pointcuts) {
            execute(pointcut, po, timing);
        }
    }

    private void execute(final Pointcut pointcut, final Object po, final int timing) {
        // Check timings
        final Set<Integer> timings = pointcut.getTimings();
        if (!timings.contains(timing)) {
            return;
        }
        // Check if UserAction required (i.e. user manually changed this record from a window)
        if (pointcut.isOnlyIfUIAction()) {
            final boolean isUIAction = InterfaceWrapperHelper.isUIAction(po);
            if (!isUIAction) {
                return;
            }
        }
        // Check if we shall skip when copying
        if (pointcut.isSkipIfCopying()) {
            final boolean isCopying = InterfaceWrapperHelper.isCopy(po);
            if (isCopying) {
                return;
            }
        }
        // Else, does not make sense.
        if (isTimingChange(timing)) {
            final Set<String> columnsToCheckForChanges = pointcut.getColumnNamesToCheckForChanges();
            if (!columnsToCheckForChanges.isEmpty()) {
                // none of our columns had changed; skip
                if (!InterfaceWrapperHelper.isValueChanged(po, columnsToCheckForChanges)) {
                    return;
                }
            }
        }
        // Execute the method now
        if (!pointcut.isAfterCommit()) {
            executeNow(po, pointcut, timing);
        } else {
            logger.trace("Scheduling to be executed after commit: {}", pointcut);
            final String trxName = InterfaceWrapperHelper.getTrxName(po);
            Services.get(ITrxManager.class).getTrxListenerManagerOrAutoCommit(trxName).newEventListener(TrxEventTiming.AFTER_COMMIT).additionalToStringInfo(() -> MoreObjects.toStringHelper(this).add("pointcut", pointcut).add("po", po).add("timing", timing).toString()).invokeMethodJustOnce(true).registerHandlingMethod(transaction -> {
                executeNow(po, pointcut, timing);
                InterfaceWrapperHelper.setTrxName(po, ITrx.TRXNAME_ThreadInherited);
            });
        }
    }

    @VisibleForTesting
    private final void executeNow(@NonNull final Object po, @NonNull final Pointcut pointcut, final int timing) {
        if (AnnotatedModelInterceptorDisabler.get().isDisabled(pointcut)) {
            logger.info("Not executing pointCut because it is disabled via sysconfig (name-prefix={}); pointcut={}", AnnotatedModelInterceptorDisabler.SYS_CONFIG_NAME_PREFIX, pointcut);
            return;
        }
        final Object model = InterfaceWrapperHelper.create(po, pointcut.getModelClass());
        try {
            executeNow0(model, pointcut, timing);
        } catch (final Exception e) {
            final AdempiereException adempiereException = appendAndLogHowtoDisableMessage(e, pointcut);
            throw adempiereException;
        }
    }

    private static AdempiereException appendAndLogHowtoDisableMessage(@NonNull final Exception e, @NonNull final Pointcut pointcut) {
        final String parameterName = "HowtoDisableModelInterceptor";
        final AdempiereException ae = AdempiereException.wrapIfNeeded(e);
        if (!ae.hasParameter(parameterName)) {
            final String howtoDisableMsg = AnnotatedModelInterceptorDisabler.createHowtoDisableMessage(pointcut);
            logger.error(howtoDisableMsg);
            ae.setParameter(parameterName, howtoDisableMsg);
        }
        return ae;
    }

    private void executeNow0(@NonNull final Object model, @NonNull final Pointcut pointcut, final int timing) throws IllegalAccessException, InvocationTargetException {
        final Method method = pointcut.getMethod();
        // Make sure the method is accessible
        if (!method.isAccessible()) {
            method.setAccessible(true);
        }
        final Stopwatch stopwatch = Stopwatch.createStarted();
        if (pointcut.isMethodRequiresTiming()) {
            final Object timingParam = pointcut.convertToMethodTimingParameterType(timing);
            method.invoke(annotatedObject, model, timingParam);
        } else {
            method.invoke(annotatedObject, model);
        }
        logger.trace("Executed in {}: {} (timing={}) on {}", stopwatch, pointcut, timing, model);
    }

    /**
     * @param timing
     * @return true if timing is change (before, after)
     */
    private static final boolean isTimingChange(final int timing) {
        return ModelValidator.TYPE_BEFORE_CHANGE == timing || ModelValidator.TYPE_AFTER_CHANGE == timing || ModelValidator.TYPE_AFTER_CHANGE_REPLICATION == timing;
    }
}

```


Overlapping Code:
```
of = { "annotatedObject", "descriptor", "clientId"nterceptor {
private static final transient Logger logger = LogManager.getLogger(AnnotatedModelInterceptor.class);
private final AnnotatedModelInterceptorDescriptor descriptor;
private final transient Object annotatedObject;
private ClientId clientId;
/**
* @param annotatedObject
*/
AnnotatedModelInterceptor(@NonNull final Object aObject;
this.descriptor = new AnnotatedModelInterceptorDescriptorBuilder(annotatedObject.getClass()).build();
}
@Override
public String toString() {
return "annotated[" + annotatedObject.getClass().go initializers, no pointcuts, no nothing
*/
publicEmpty() {
return descriptor.isEmpty();
}
@Override
public void initialize(final IModelValidationEngine engine, final I_AD_Client clienId = ClientId.ofRepoId(client.getAD_Client_ID());
}
bindPointcuts(e
Object[] params = new Object[] {};
if (init.isMetine };
}
final Method method = init.getMethod();
t
if (!method.isAccessible()) {
method.setAccessible(true);
}
// Execute
method.invoke(annotatedObject, param;
} catch (Exception e) {
throw new AdempiereException("Cannot initialize " + annotatedObject + ".RootCause(e));
}
logger.debug("Initializer {} executed successfully.", init);
}
}
private void bindPointcuts(@NonNull final IModelValidationEngine engnotatedObject);
for (final PointcutKey key : descr
```
<Overlap Ratio: 0.6541279921836834>

---

--- 180 --
Question ID: 9118fce3ef781ce323072a537ba766e7bc58d1c4
Original Code:
```
public class EinfacheGui implements ActionListener, KeyListener {

    private JFrame myFrame;

    private Container myContentPane;

    private JButton myButtonClickMich;

    private int height = 350;

    private int width = 350;

    private double factor = 0.3;

    public EinfacheGui() {
        myFrame = new JFrame("Einfache Gui");
        myFrame.setSize(width, height);
        myFrame.setLocationRelativeTo(null);
        myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        myButtonClickMich = new JButton("Button");
        myButtonClickMich.addActionListener(this);
        myButtonClickMich.addKeyListener(this);
        myFrame.add(myButtonClickMich);
        myFrame.setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        double w = myFrame.getWidth() - myFrame.getWidth() * factor;
        double h = myFrame.getHeight() - myFrame.getHeight() * factor;
        if ((w + h) < 150)
            myFrame.setSize(width, height);
        else
            myFrame.setSize((int) w, (int) h);
        myFrame.setLocationRelativeTo(null);
    }

    @Override
    public void keyTyped(KeyEvent e) {
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getExtendedKeyCode() == KeyEvent.VK_ENTER) {
            JOptionPane.showMessageDialog(myFrame, "Geschafft");
        }
        System.out.println(e.getExtendedKeyCode() + " pressed");
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }
}

```


Overlapping Code:
```
 implements ActionListener, KeyListener {
private JFrame myFrame;
private Container myContentPane;
private JButton myButtonClickMich;
private int height = 350;
private int width = 350;
private double factor = 0.3;
public EinfacheGui() {
myFrame = new JFrame("Einfache Gui");
myFrame.setSize(width, height);
myFrame.setLocationRelativeTo(null);
myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
myButtonClickMich = new JButton("Button");
myButtonClickMich.addActionListener(this);
myButtonClickMich.addKeyListener(this);
myFrame.add(myButtonClickMich);
myFrame.setVisible(true);
}
@Override
public void actionPerformed(ActionEvent e) {
double w = myFrame.getWidth() - myFrame.getWidth() * factor;
double h = myFrame.getHeight() - myFrame.getHeight() * factor;
if ((w + h) < 150)
myFrame.setSize(width, height);
else
myFrame.setSize((int) w, (int) h);
myFrame.setLocationRelativeTo(null);
}
@Override
public void keyTyped(KeyEvent e) {
}
@Override
public void keyPressed(KeyEvent e) {
if (e.getExtendedKeyCode() == KeyEvent.VK_ENTER) {
JOptionPane.showMessageDialog(myFrame, "Geschafft");
}
System.out.println(e.getExtendedKeyCode() + " pressed");
}
@Override
public void keyReleased(KeyEvent e) {
}
}
```
<Overlap Ratio: 0.9804719283970708>

---

--- 181 --
Question ID: 7142d9c06098c05b438ce4e3aee241b816729134
Original Code:
```
public class SPacketScoreboardObjective implements Packet<INetHandlerPlayClient> {

    private String objectiveName;

    private String objectiveValue;

    private IScoreCriteria.EnumRenderType type;

    private int action;

    public SPacketScoreboardObjective() {
    }

    public SPacketScoreboardObjective(ScoreObjective objective, int actionIn) {
        this.objectiveName = objective.getName();
        this.objectiveValue = objective.getDisplayName();
        this.type = objective.getCriteria().getRenderType();
        this.action = actionIn;
    }

    /**
     * Reads the raw packet data from the data stream.
     */
    public void readPacketData(PacketBuffer buf) throws IOException {
        this.objectiveName = buf.readString(16);
        this.action = buf.readByte();
        if (this.action == 0 || this.action == 2) {
            this.objectiveValue = buf.readString(32);
            this.type = IScoreCriteria.EnumRenderType.getByName(buf.readString(16));
        }
    }

    /**
     * Writes the raw packet data to the data stream.
     */
    public void writePacketData(PacketBuffer buf) throws IOException {
        buf.writeString(this.objectiveName);
        buf.writeByte(this.action);
        if (this.action == 0 || this.action == 2) {
            buf.writeString(this.objectiveValue);
            buf.writeString(this.type.getRenderType());
        }
    }

    /**
     * Passes this Packet on to the NetHandler for processing.
     */
    public void processPacket(INetHandlerPlayClient handler) {
        handler.handleScoreboardObjective(this);
    }

    @SideOnly(Side.CLIENT)
    public String getObjectiveName() {
        return this.objectiveName;
    }

    @SideOnly(Side.CLIENT)
    public String getObjectiveValue() {
        return this.objectiveValue;
    }

    @SideOnly(Side.CLIENT)
    public int getAction() {
        return this.action;
    }

    @SideOnly(Side.CLIENT)
    public IScoreCriteria.EnumRenderType getRenderType() {
        return this.type;
    }
}

```


Overlapping Code:
```
jective implements Packet<INetHandlerPlayClient> {
private String objectiveName;
private String objectiveValue;
private IScoreCriteria.EnumRenderType type;
private inpublic SPacketScoreboardObjective(ScoreObjective oective.getName();
this.objectiveValue = objective.getDisplayName();
this.type = objective.getCriteria().getRenderType();
this.action = actionIn;
}
/**
* Reads the raw packet data from the data stream.
*/
public void readPacketData(PacketBuffer buf) throws IOException {
this.objectiveName = bufdString(16);
this.action = buf.readByte();
if (this.action == 0 || this.action ==alue = buf.readString(32);
this.type = IScoreCriteria.EnumRenderType.getByName(buf.readString(16));
}
}
/**
* Writes the raw packet data to the data stream.
*/
public void writePacketData(PacketBuffer buf) throws IOException {
buf.writeString(this.objectiveName);
buf.writeByte(this.action);
if (thisg(this.objectiveValue);
buf.writeString(this.type.getRenderType());
}
}
/**
* Passes this Packet on to the NetHandler for processing.
*/
public void processPacket(INetHandlerPlayClient handler) {
handler.handleScoreboardObjective(this);
}
@SideOnly(Slic String getObjectiveName() {
return this.objectiveName;
}
@SideOnly(Side.CLIENT)
pectiveValue;
}
@SideOnly(Side.CLIENT)
public int gCLIENT)
public IScoreCriteria.EnumRenderType getRenderType() {
return
```
<Overlap Ratio: 0.7996432818073722>

---

--- 182 --
Question ID: d9151f6e311531a33967c956253a7916f0cc14ba
Original Code:
```
public class CondensedViterbiIntersectionAutomaton<LeftState, RightState> extends GenericCondensedIntersectionAutomaton<LeftState, RightState> {

    ///< Maps a state from this automaton to a probability
    private final Int2DoubleMap viterbiStateMap;

    ///< Maps a state to its best rule
    private final Int2ObjectMap<Rule> viterbiRuleMap;

    public CondensedViterbiIntersectionAutomaton(TreeAutomaton<LeftState> left, CondensedTreeAutomaton<RightState> right, SignatureMapper sigMapper) {
        super(left, right, sigMapper);
        viterbiStateMap = new ArrayInt2DoubleMap();
        // if a state is not in this map, return 0
        viterbiStateMap.defaultReturnValue(0.0);
        viterbiRuleMap = new ArrayMap<>();
    }

    @Override
    protected // to enter only the best rules.
    void collectOutputRule(Rule outputRule) {
        int newState = outputRule.getParent();
        int[] children = outputRule.getChildren();
        double childWeight = outputRule.getWeight();
        int i = 0;
        while (i < children.length) try {
            childWeight *= viterbiStateMap.get(children[i]);
        } finally {
            i++;
        }
        if (viterbiStateMap.get(newState) < childWeight) {
            // current rule is new, or better than old rule
            viterbiRuleMap.put(newState, outputRule);
            viterbiStateMap.put(newState, childWeight);
        }
    }

    @Override
    protected void addAllOutputRules() {
        viterbiRuleMap.values().forEach(this::storeRuleBoth);
    }

    public static void main(String[] args) throws Exception {
        GenericCondensedIntersectionAutomaton.main(args, false, (left, right) -> left.intersectViterbi(right));
    }
}

```


Overlapping Code:
```
 class CondensedViterbiIntersectionAutomaton<LeftState, RightState> extends GenericCondensedIntersece from this automaton to a probability
private finersectionAutomaton(TreeAutomaton<LeftState> left, CondensedTreeAutomaton<RightState> right, SignatureMapper sigMapper) {
super(left, right, sigMapper)tOutputRule(Rule outputRule) {
int newState = outputRule.getParent();
int[] children = outputRule.getChildren();
double childWeight = outputRule.getWe
childWeight *= viterbiStateMap.get(children[i]);
}
if (viterbiStateMap.get(newState) < childWeight) {
// current rule is new, or better than old rule
viterbiRuleMap.put(newState, outputRule);
viterbiStateMap.put(newState, childWeight);
}
}
@Override
protected void addAllOutputRules() {
viterbiRuleMth);
}
public static void main(String[] args) throws Exception {
GenericCondensedIntersectionAutomaton.main(args, false, (left, right) -> left.intersectViterbi(ri
```
<Overlap Ratio: 0.6225255972696245>

---

--- 183 --
Question ID: 0d702eb90f1c4fb17696cc6f6afccd963790a157
Original Code:
```
@ExtendWith(SiriusExtension.class)
class XMLReaderTest {

    @Test
    @DisplayName("XMLReader extracts XPATH expression")
    void readXpath() throws Exception {
        ValueHolder<String> readString = ValueHolder.of(null);
        Counter nodeCount = new Counter();
        XMLReader reader = new XMLReader();
        reader.addHandler("test", node -> {
            nodeCount.inc();
            readString.set(node.queryString("value"));
        });
        reader.parse(new ByteArrayInputStream("<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>".getBytes()));
        assertEquals("5", readString.get());
        assertEquals(3, nodeCount.getCount(), "parsed invalid count of nodes");
    }

    @Test
    @DisplayName("XMLReader supports compound XPATH paths")
    void readXpathCompound() throws Exception {
        ValueHolder<Boolean> shouldToggle = ValueHolder.of(false);
        ValueHolder<Boolean> shouldNotToggle = ValueHolder.of(false);
        XMLReader reader = new XMLReader();
        reader.addHandler("doc/test/value", node -> shouldToggle.set(true));
        reader.addHandler("value", node -> shouldNotToggle.set(true));
        reader.parse(new ByteArrayInputStream("<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>".getBytes()));
        assertTrue(shouldToggle.get());
        assertFalse(shouldNotToggle.get());
    }

    @Test
    @DisplayName("XMLReader reads attributes")
    void readXpathAttributes() throws Exception {
        Map<String, String> attributes = new HashMap<>();
        ValueHolder<String> attribute = ValueHolder.of("");
        XMLReader reader = new XMLReader();
        reader.addHandler("test", node -> {
            attributes.putAll(node.getAttributes());
            attribute.set(node.getAttribute("namedAttribute").asString());
        });
        reader.parse(new ByteArrayInputStream("<doc><test namedAttribute=\"abc\" namedAttribute2=\"xyz\">1</test></doc>".getBytes()));
        assertEquals(2, attributes.size());
        assertEquals("abc", attribute.get());
    }

    @Test
    @DisplayName("reading non existing attributes does not throw errors")
    void readXpathMissingAttributes() throws Exception {
        Map<String, String> attributes = new HashMap<>();
        ValueHolder<String> attribute = ValueHolder.of("wrongValue");
        XMLReader reader = new XMLReader();
        reader.addHandler("test", node -> {
            attributes.putAll(node.getAttributes());
            attribute.set(node.getAttribute("namedAttribute").asString());
        });
        reader.parse(new ByteArrayInputStream("<doc><test>1</test></doc>".getBytes()));
        assertEquals(0, attributes.size());
        assertEquals("", attribute.get());
    }
}

```


Overlapping Code:
```
sExtension.class)
class XMLReaderTest {
@Test
@DisplayName("XMLReader extracts XPATH expression")
void readXpath() throws Exception {
ValueHolder<String> readString = ValueHolder.of(null);
Counter nodeCount = new Counter();
XMLReader reader = new XMLReader();
reader.addHandler("test", node -> {
nodeCount.inc();
readString.set(node.queryString("valu<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>".getBytes()));
assertEquals("5", readString.get());
assertEquals(3, nodeCount.getCount(), "parsed invalid count of nodes");
}
@Test
@DisplayName("XMLReader supports compound XPATH paths")
void readXpathCompound() throws Exception {
ValueHolder<Boolean> shouldToggle = ValueHolder.of(false);
ValueHolder<Boolean> shouldNotToggle = ValueHolder.of(false);
XMLReader reader = new XMLReader();
reader.addHandler("doc/test/value", node -> shouldToggle.set(true));
reader.addHandler("value", node -> shouldNotToggle.set(true));
reader.parse(new ByteArrayInpu<doc><test><value>1</value></test><test><value>2</value></test><test><value>5</value></test></doc>".getBytes()));
assertTrue(shouldToggle.get());
assertFalse(shouldNotToggle.get());
}
@Test
@DisplayName("XMLReader reads attributes")
void readXpathAttributes() throws Exception {
Map<String, String> attributes = new HashMap<>();
ValueHolder<String> attribute = ValueHolder.of("");
XMLReader reader = new XMLReader();
reader.addHandler("test", node -> {
attributes.putAll(node.getAttributes());
attribute.set(node.getAttribute("namedAttribute").asString());
});
reader.parse(new ByteArrayInputStream("<doc><test namedAttribute=\"abc\" namedAttribute2=\"xyz\">1</test></doc>".getBytes()));
assertEquals(2, attributes.size());
assertEquals("abc", attribute.get());
}
@Test
@DisplayName("reading non existing attributes does not throw errors")
void readXpathMissingAttributes() throws Exception {
Map<String, String> attributes = new HashMap<>();
ValueHolder<String> attribute = ValueHolder.of("wrongValue");
XMLReader reader = new XMLReader();
reader.addHandler("test
```
<Overlap Ratio: 0.9595536959553695>

---

--- 184 --
Question ID: 2dc0bd87eab86338ed959af6cf2291c34c7fcd29
Original Code:
```
@Getter
public class OrientedBox {

    protected Vector center;

    protected Vector axisX;

    protected Vector axisY;

    protected Vector axisZ;

    protected float extentX;

    protected float extentY;

    protected float extentZ;

    public OrientedBox(final Vector center, final Vector axisX, final Vector axisY, final Vector axisZ, final float extentX, final float extentY, final float extentZ) {
        this.center = center;
        this.axisX = axisX;
        this.axisY = axisY;
        this.axisZ = axisZ;
        this.extentX = extentX;
        this.extentY = extentY;
        this.extentZ = extentZ;
    }

    public OrientedBox(final AxialBox box, final Transform transform) {
        this.center = transform.rotateTranslateLocalToParent(box.getCenter());
        this.axisX = transform.rotateLocalToParent(box.getAxisX());
        this.axisY = transform.rotateLocalToParent(box.getAxisY());
        this.axisZ = transform.rotateLocalToParent(box.getAxisZ());
        this.extentX = box.getExtentX();
        this.extentY = box.getExtentY();
        this.extentZ = box.getExtentZ();
    }

    public OrientedBox(final AxialBox box) {
        this.center = box.getCenter();
        this.axisX = box.getAxisX();
        this.axisY = box.getAxisY();
        this.axisZ = box.getAxisZ();
        this.extentX = box.getExtentX();
        this.extentY = box.getExtentY();
        this.extentZ = box.getExtentZ();
    }

    public OrientedBox(final YawedBox box) {
        this.center = box.getCenter();
        this.axisX = box.getAxisX();
        this.axisY = box.getAxisY();
        this.axisZ = box.getAxisZ();
        this.extentX = box.getExtentX();
        this.extentY = box.getExtentY();
        this.extentZ = box.getExtentZ();
    }

    public Vector[] getAxes() {
        return new Vector[] { axisX, axisY, axisZ };
    }

    public float[] getExtents() {
        return new float[] { extentX, extentY, extentZ };
    }

    public Vector getBase() {
        return getCenter().subtract(getAxisY().multiply(getExtentY()));
    }

    public Plane3d getFacePlane(final int whichPlane) {
        switch(whichPlane) {
            case 0:
                return new Plane3d(center.add(axisX.multiply(extentX)), axisX);
            case 1:
                return new Plane3d(center.add(axisY.multiply(extentY)), axisY);
            case 2:
                return new Plane3d(center.add(axisZ.multiply(extentZ)), axisZ);
            case 3:
                return new Plane3d(center.subtract(axisX.multiply(extentX)), axisX.inverse());
            case 4:
                return new Plane3d(center.subtract(axisY.multiply(extentY)), axisY.inverse());
            case 5:
                return new Plane3d(center.subtract(axisZ.multiply(extentZ)), axisZ.inverse());
            default:
                return new Plane3d(Vector.ZERO, Vector.ZERO);
        }
    }

    public Vector getCorner(final int whichCorner) {
        final Vector x = axisX.multiply(extentX);
        final Vector y = axisY.multiply(extentY);
        final Vector z = axisZ.multiply(extentZ);
        switch(whichCorner) {
            case 0:
                return center.subtract(x).subtract(y).subtract(z);
            case 1:
                return center.add(x).subtract(y).subtract(z);
            case 2:
                return center.subtract(x).subtract(y).add(z);
            case 3:
                return center.add(x).subtract(y).add(z);
            case 4:
                return center.subtract(x).add(y).subtract(z);
            case 5:
                return center.add(x).add(y).subtract(z);
            case 6:
                return center.subtract(x).add(y).add(z);
            case 7:
                return center.add(x).add(y).add(z);
            default:
                return Vector.ZERO;
        }
    }

    public AxialBox getLocalShape() {
        return new AxialBox(new Vector(-extentX, -extentY, -extentZ), new Vector(extentX, extentY, extentZ));
    }

    public Transform getTransformLocalToParent() {
        final Transform temp = new Transform();
        temp.setLocalFrameIJKInParentSpace(getAxisX(), getAxisY(), getAxisZ());
        temp.moveInParentSpace(center);
        return temp;
    }

    public Transform getTransformParentToLocal() {
        final Transform temp = new Transform();
        temp.invert(getTransformLocalToParent());
        return temp;
    }

    public Vector transformToLocal(final Vector vector) {
        return rotateToLocal(vector.subtract(center));
    }

    public Vector transformToWorld(final Vector vector) {
        return rotateToWorld(vector).add(center);
    }

    public Vector rotateToLocal(final Vector vector) {
        return new Vector(vector.dot(getAxisX()), vector.dot(getAxisY()), vector.dot(getAxisZ()));
    }

    public Vector rotateToWorld(final Vector vector) {
        return Vector.ZERO.add(getAxisX().multiply(vector.x)).add(getAxisY().multiply(vector.y)).add(getAxisZ().multiply(vector.z));
    }
}

```


Overlapping Code:
```
Vector center;
protected Vector axisX;
protected Vector axisY;
protected Vector axisZ;
protected float extentX;
protected float extentY;
protected float extentZ;
public OrientedBox(final Vector centernter = center;
this.axisX = axisX;
this.axisY = axisY;
this.axisZ = axisZ;
this.extentX = extentX;
this.extentY = extentY;
this.extentZ = extentZ;
}
public OrientedBox(final AxialBox box, final Transform transform) {
this.center = transform.rotateTranslateLocalToParent(box.getCenter());
this.axisX = transform.rotateLocalToParent(box.getAxisX());
this.axisY = transform.rotateLocalToParent(box.getAxisY());
this.axisZ = transform.rotateLocalToParent(box.getAxisZ());
this.extentX = box.getExtentX();
this.extentY = box.getExtentY();
this.extentZ = box.getExtentZ();
}
public OrientedBox(final AxialBox box) {
this.center = box.getCenter();
this.axisX = box.getAxisX();
this.axisY = box.getAxisY();
this.axisZ = box.getAxisZ();
this.extentX = box.getExtentX();
this.extentY = box.getExtentY();
this.extentZ = box.getExtentZ();
}
public OrientedBox(final YawedBox box) {
this.center = box.getCenter();
this.axisX = box.getAxisX();
this.axisY = box.getAxisY();
this.axisZ = box.getAxisZ();
this.extentX = box.getExtentX();
this.extentY = box.getExtentY();
this.extentZ = box.getExtentZ();
}
public Vector[] getAxes() {return getCenter().subtract(getAxisY().multiply(getExtentY()));
}
public Plane3d getFacePlane(final turn new Plane3d(center.add(axisX.multiply(extentX)), axisX);
case 1:
return new Plane3d(center.add(axisY.multiply(extentY)), axisY);
case 2:
return new Plane3d(center.add(axisZ.multiply(extentZ)), ax
```
<Overlap Ratio: 0.796844181459566>

---

--- 185 --
Question ID: 07f14f69f8dacb6b9a0eeb603908e41613cd4a6a
Original Code:
```
public class RegistrationFactory implements FactoryBean<Registration> {

    @Override
    public Registration getObject() throws Exception {
        User user = new UserFactory().getObject();
        Activity activity = new ActivityFactory().getObject();
        assert user != null;
        assert activity != null;
        return Registration.builder().registrationId(new RegistrationId(user.getId(), activity.getId())).user(user).activity(activity).build();
    }

    @Override
    public Class<?> getObjectType() {
        return null;
    }

    @Override
    public boolean isSingleton() {
        return false;
    }
}

```


Overlapping Code:
```
strationFactory implements FactoryBean<Registration> {
@Override
public Registration getObject() throws Exception {
User user = new UserFactory().getObject();
Activity activity = new ActivityFactory().getObject();
assert user != null;
assert activityon.builder().registrationId(new RegistrationId(user.getId(), activity.ge.build();
}
@Override
public Class<?> getObjectType() {
return null;
}
@Override
public boolean isSingleton() {
return false;
}
}
```
<Overlap Ratio: 0.8477443609022557>

---

--- 186 --
Question ID: cf298733351b7e35725e78d8f67a8e27f7e35c3e
Original Code:
```
public class demo06ArrayListStudent {

    public static void main(String[] args) {
        ArrayList<Student> list = new ArrayList<>();
        list.add(new Student(22, "???"));
        list.add(new Student(23, "???"));
        list.add(new Student(53, "???"));
        list.add(new Student(33, "???"));
        int i = 0;
        while (i < list.size()) try {
            Student stu = list.get(i);
            System.out.println("???" + stu.getName() + " ???" + stu.getAge());
        } finally {
            i++;
        }
    }
}

```


Overlapping Code:
```
stStudent {
public static void main(String[] args) {
ArrayList<Student> list = new ArrayList<>();
list.add(new Student
```
<Overlap Ratio: 0.2829736211031175>

---

--- 187 --
Question ID: 5d1826baaf2a8d3a3ee04fea5ba7cdaf784abf75
Original Code:
```
public class PaymentPlansApi {

    private ApiClient apiClient;

    public PaymentPlansApi() {
        this(Environment.getGlobalEnv().getApiClient());
    }

    public PaymentPlansApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for paymentPlansGet
     * @param count The maximum number of items to return
     * @param offset The position within the whole result set to start returning items (zero-based)
     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.
     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;
     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call paymentPlansGetCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {
        Object localVarPostBody = null;
        // create path and map variables
        String localVarPath = "/Payment/Plans";
        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (count != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("count", count));
        if (offset != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("offset", offset));
        if (fields != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("fields", fields));
        if (q != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("q", q));
        if (sort != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("sort", sort));
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = { "application/json" };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null)
            localVarHeaderParams.put("Accept", localVarAccept);
        final String[] localVarContentTypes = {};
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        String[] localVarAuthNames = new String[] { "oauth_token" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private Call paymentPlansGetValidateBeforeCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {
        return paymentPlansGetCall(count, offset, fields, q, sort);
    }

    /**
     * GET Payment/Plans
     * Get a list of payment plans
     * @param count The maximum number of items to return
     * @param offset The position within the whole result set to start returning items (zero-based)
     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.
     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;
     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.
     * @return PaymentPlansList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PaymentPlansList paymentPlansGet(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {
        ApiResponse<PaymentPlansList> resp = paymentPlansGetWithHttpInfo(count, offset, fields, q, sort);
        return resp.getData();
    }

    /**
     * GET Payment/Plans
     * Get a list of payment plans
     * @param count The maximum number of items to return
     * @param offset The position within the whole result set to start returning items (zero-based)
     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.
     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;
     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.
     * @return ApiResponse&lt;PaymentPlansList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PaymentPlansList> paymentPlansGetWithHttpInfo(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {
        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);
        Type localVarReturnType = new TypeToken<PaymentPlansList>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * GET Payment/Plans (asynchronously)
     * Get a list of payment plans
     * @param count The maximum number of items to return
     * @param offset The position within the whole result set to start returning items (zero-based)
     * @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.
     * @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;.  Example: &#x60;customer.name:Meier&#x60;  A condition may contain:  * &#x60;?&#x60; as wildcard for one character;  * &#x60;*&#x60; as wildcard for any number of characters.  You can also use value ranges in the form &#x60;[min TO max]&#x60;.  Example: &#x60;customer.age:[30 TO 40]&#x60;  You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence.  Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;
     * @param sort String with comma separated pairs of &#x60;field:order&#x60;.  Options for order:  * &#x60;asc&#x60; ascending;  * &#x60;dsc&#x60; descending.
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call paymentPlansGetAsync(Integer count, Integer offset, String fields, String q, String sort, final ApiCallback<PaymentPlansList> callback) throws ApiException {
        Call call = paymentPlansGetValidateBeforeCall(count, offset, fields, q, sort);
        Type localVarReturnType = new TypeToken<PaymentPlansList>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for paymentPlansGetById
     * @param paymentPlanId Payment plan id (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call paymentPlansGetByIdCall(String paymentPlanId) throws ApiException {
        Object localVarPostBody = null;
        // create path and map variables
        String localVarPath = "/Payment/Plans/{paymentPlanId}".replaceAll("\\{" + "paymentPlanId" + "\\}", apiClient.escapeString(paymentPlanId.toString()));
        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = { "application/json" };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null)
            localVarHeaderParams.put("Accept", localVarAccept);
        final String[] localVarContentTypes = {};
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        String[] localVarAuthNames = new String[] { "oauth_token" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private Call paymentPlansGetByIdValidateBeforeCall(String paymentPlanId) throws ApiException {
        // verify the required parameter 'paymentPlanId' is set
        if (paymentPlanId == null) {
            throw new ApiException("Missing the required parameter 'paymentPlanId' when calling paymentPlansGetById(Async)");
        }
        return paymentPlansGetByIdCall(paymentPlanId);
    }

    /**
     * GET Payment/Plans/{paymentPlanId}
     * Get payment plan by id
     * @param paymentPlanId Payment plan id (required)
     * @return PaymentPlansProductModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PaymentPlansProductModel paymentPlansGetById(String paymentPlanId) throws ApiException {
        ApiResponse<PaymentPlansProductModel> resp = paymentPlansGetByIdWithHttpInfo(paymentPlanId);
        return resp.getData();
    }

    /**
     * GET Payment/Plans/{paymentPlanId}
     * Get payment plan by id
     * @param paymentPlanId Payment plan id (required)
     * @return ApiResponse&lt;PaymentPlansProductModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PaymentPlansProductModel> paymentPlansGetByIdWithHttpInfo(String paymentPlanId) throws ApiException {
        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);
        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * GET Payment/Plans/{paymentPlanId} (asynchronously)
     * Get payment plan by id
     * @param paymentPlanId Payment plan id (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call paymentPlansGetByIdAsync(String paymentPlanId, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {
        Call call = paymentPlansGetByIdValidateBeforeCall(paymentPlanId);
        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for paymentPlansPatch
     * @param paymentPlanId Payment plan id (required)
     * @param body Payment plans properties
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call paymentPlansPatchCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {
        Object localVarPostBody = body;
        // create path and map variables
        String localVarPath = "/Payment/Plans/{paymentPlanId}".replaceAll("\\{" + "paymentPlanId" + "\\}", apiClient.escapeString(paymentPlanId.toString()));
        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = { "application/json" };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null)
            localVarHeaderParams.put("Accept", localVarAccept);
        final String[] localVarContentTypes = { "application/json" };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        String[] localVarAuthNames = new String[] { "oauth_token" };
        return apiClient.buildCall(localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private Call paymentPlansPatchValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {
        // verify the required parameter 'paymentPlanId' is set
        if (paymentPlanId == null) {
            throw new ApiException("Missing the required parameter 'paymentPlanId' when calling paymentPlansPatch(Async)");
        }
        return paymentPlansPatchCall(paymentPlanId, body);
    }

    /**
     * PATCH Payment/Plans/{paymentPlanId}
     * Updates an existing plan (partial)
     * @param paymentPlanId Payment plan id (required)
     * @param body Payment plans properties
     * @return PaymentPlansProductModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PaymentPlansProductModel paymentPlansPatch(String paymentPlanId, PaymentPlansDTO body) throws ApiException {
        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPatchWithHttpInfo(paymentPlanId, body);
        return resp.getData();
    }

    /**
     * PATCH Payment/Plans/{paymentPlanId}
     * Updates an existing plan (partial)
     * @param paymentPlanId Payment plan id (required)
     * @param body Payment plans properties
     * @return ApiResponse&lt;PaymentPlansProductModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PaymentPlansProductModel> paymentPlansPatchWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {
        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);
        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * PATCH Payment/Plans/{paymentPlanId} (asynchronously)
     * Updates an existing plan (partial)
     * @param paymentPlanId Payment plan id (required)
     * @param body Payment plans properties
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call paymentPlansPatchAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {
        Call call = paymentPlansPatchValidateBeforeCall(paymentPlanId, body);
        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for paymentPlansPost
     * @param body Payment plan properties
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call paymentPlansPostCall(PaymentPlansDTO body) throws ApiException {
        Object localVarPostBody = body;
        // create path and map variables
        String localVarPath = "/Payment/Plans";
        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = { "application/json" };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null)
            localVarHeaderParams.put("Accept", localVarAccept);
        final String[] localVarContentTypes = { "application/json" };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        String[] localVarAuthNames = new String[] { "oauth_token" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private Call paymentPlansPostValidateBeforeCall(PaymentPlansDTO body) throws ApiException {
        return paymentPlansPostCall(body);
    }

    /**
     * POST Payment/Plans
     * Add new plan
     * @param body Payment plan properties
     * @return PaymentPlansProductModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PaymentPlansProductModel paymentPlansPost(PaymentPlansDTO body) throws ApiException {
        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPostWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * POST Payment/Plans
     * Add new plan
     * @param body Payment plan properties
     * @return ApiResponse&lt;PaymentPlansProductModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PaymentPlansProductModel> paymentPlansPostWithHttpInfo(PaymentPlansDTO body) throws ApiException {
        Call call = paymentPlansPostValidateBeforeCall(body);
        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * POST Payment/Plans (asynchronously)
     * Add new plan
     * @param body Payment plan properties
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call paymentPlansPostAsync(PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {
        Call call = paymentPlansPostValidateBeforeCall(body);
        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     * Build call for paymentPlansPut
     * @param paymentPlanId Payment plan id (required)
     * @param body Payment plans properties
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call paymentPlansPutCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {
        Object localVarPostBody = body;
        // create path and map variables
        String localVarPath = "/Payment/Plans/{paymentPlanId}".replaceAll("\\{" + "paymentPlanId" + "\\}", apiClient.escapeString(paymentPlanId.toString()));
        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        final String[] localVarAccepts = { "application/json" };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null)
            localVarHeaderParams.put("Accept", localVarAccept);
        final String[] localVarContentTypes = { "application/json" };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);
        String[] localVarAuthNames = new String[] { "oauth_token" };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private Call paymentPlansPutValidateBeforeCall(String paymentPlanId, PaymentPlansDTO body) throws ApiException {
        // verify the required parameter 'paymentPlanId' is set
        if (paymentPlanId == null) {
            throw new ApiException("Missing the required parameter 'paymentPlanId' when calling paymentPlansPut(Async)");
        }
        return paymentPlansPutCall(paymentPlanId, body);
    }

    /**
     * PUT Payment/Plans/{paymentPlanId}
     * Updates an existing plan
     * @param paymentPlanId Payment plan id (required)
     * @param body Payment plans properties
     * @return PaymentPlansProductModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public PaymentPlansProductModel paymentPlansPut(String paymentPlanId, PaymentPlansDTO body) throws ApiException {
        ApiResponse<PaymentPlansProductModel> resp = paymentPlansPutWithHttpInfo(paymentPlanId, body);
        return resp.getData();
    }

    /**
     * PUT Payment/Plans/{paymentPlanId}
     * Updates an existing plan
     * @param paymentPlanId Payment plan id (required)
     * @param body Payment plans properties
     * @return ApiResponse&lt;PaymentPlansProductModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<PaymentPlansProductModel> paymentPlansPutWithHttpInfo(String paymentPlanId, PaymentPlansDTO body) throws ApiException {
        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);
        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * PUT Payment/Plans/{paymentPlanId} (asynchronously)
     * Updates an existing plan
     * @param paymentPlanId Payment plan id (required)
     * @param body Payment plans properties
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call paymentPlansPutAsync(String paymentPlanId, PaymentPlansDTO body, final ApiCallback<PaymentPlansProductModel> callback) throws ApiException {
        Call call = paymentPlansPutValidateBeforeCall(paymentPlanId, body);
        Type localVarReturnType = new TypeToken<PaymentPlansProductModel>() {
        }.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}

```


Overlapping Code:
```
ic class PaymentPlansApi {
private ApiClient apiClient;
public PaymentPlansApi() {
this(Environment.getGlobalEnv().getApiClient());
}
public PaymentPlansApi(ApiClient apiClient) {
this.apiClient = apiClient;
}
public ApiClient getApiClient() {
return apiClient;
}
public void setApiClient(ApiClient apiClient) {
this.apiClient = apiClient;
}
/**
* Build call for paymentPlansGet
* @param count The maximum number of items to return
* @param offset The position within the whole result set to start returning items (zero-based)
* @param fields List of fields to include in the result. Nested properties can be accessed with this notation: &#x60;prop1.prop2&#x60;.
* @param q A query string to restrict the returned items to given conditions. The query string must consist of any combination of single expressions in the form &#x60;property:condition&#x60;. Property names can be nested like &#x60;property.property&#x60;. Example: &#x60;customer.name:Meier&#x60; A condition may contain: * &#x60;?&#x60; as wildcard for one character; * &#x60;*&#x60; as wildcard for any number of characters. You can also use value ranges in the form &#x60;[min TO max]&#x60;. Example: &#x60;customer.age:[30 TO 40]&#x60; You can combine expressions logically by &#x60;expr AND expr&#x60; and &#x60;{expr} OR {expr}&#x60;. You can also negate an expression using &#x60;NOT {expr}&#x60;. Parenthesis &#x60;(...)&#x60; can be used to control precedence. Example: &#x60;(NOT customer.name:meier*) AND (customer.age:[30 TO 40] OR customer.age:[50 TO 60])&#x60;
* @param sort String with comma separated pairs of &#x60;field:order&#x60;. Options for order: * &#x60;asc&#x60; ascending; * &#x60;dsc&#x60; descending.
* @return Call to execute
* @throws ApiException If fail to serialize the request body object
*/
public Call paymentPlansGetCall(Integer count, Integer offset, String fields, String q, String sort) throws ApiException {
Object localVarPostBody = null;
// create path and map variables
String localVarPath = "/Payment/Plans";
List<Pair> localVarQueryParams = new ArrayList<Pair>();
List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
if (count != null)
localVarQueryParams.addAll(apiClient.parameterToPair("count", count));
if (offset != null)
localVarQueryParams.addAll
```
<Overlap Ratio: 0.9982463831652784>

---

--- 188 --
Question ID: 382e9cd082afd4101e37c36d08eb9143aed3b34e
Original Code:
```
public class Resources {

    public static Path getResourcePath(String path) throws URISyntaxException {
        ClassLoader classLoader = Stream.of(Thread.currentThread().getContextClassLoader(), Resources.class.getClassLoader()).filter(cl -> cl != null).findFirst().get();
        return Paths.get(classLoader.getResource(path).toURI());
    }

    public static String getResource(String file) throws IOException, URISyntaxException {
        Path path = getResourcePath(file);
        return new String(Files.readAllBytes(path));
    }

    public static List<String> listResources(String dir) throws IOException, URISyntaxException {
        Path dirpath = getResourcePath(dir);
        List<String> filenames = null;
        try (Stream<Path> walk = Files.walk(dirpath)) {
            filenames = walk.filter(Files::isRegularFile).map(filepath -> dir + dirpath.relativize(filepath).toString()).collect(Collectors.toList());
        } catch (IOException e) {
            throw e;
        }
        return filenames;
    }
}

```


Overlapping Code:
```
blic class Resources {
public static Path getResourcePath(String path) throws URISyntaxException {
ClassLoader classLoader =am.of(Thread.currentThread().getContextClassLoader(), Resources.class.getClassLoaderrst().get();
return Paths.get(classLoader.getResource(path).toURI());
}
public static String getResource(String file) throws IOException, URISyntaxException {
Path path = getResourcePath(file);
return new String(Files.readAllBytes(path));
}
public static List<String> listResources(String dir) throws IOException, URISyntaxException {
Path dirpath = getResourcePath(dir);
List<String> filenames = null;
try (Stream<Path> walk = Files.walk(dirpath)) {
filenames = walk.filter(Files::isRegularFile).map(filepath -> dir + dirpath.relativize(filepath).toString()).collect(Collectors.toList());
} catch (IOException e) {
throw e;

```
<Overlap Ratio: 0.9276169265033407>

---

--- 189 --
Question ID: daf88f1a21c8768696553c46d83f94aec56a5ffe
Original Code:
```
public class HttpClientHelper {

    public static final String DEFAULT_URL = "http://localhost:7493/go/";

    private String baseUrl = DEFAULT_URL;

    public HttpClientHelper() {
    }

    public HttpClientHelper(String baseUrl) {
        this.baseUrl = baseUrl;
    }

    public String httpRequest(final String path, RequestMethod methodRequired) throws Exception {
        return httpRequest(path, methodRequired, null);
    }

    public String httpRequest(final String path, RequestMethod methodRequired, String params) throws Exception {
        HttpMethod method = doRequest(path, methodRequired, params);
        return method.getResponseBodyAsString();
    }

    public int httpRequestForHeaders(final String path, RequestMethod methodRequired) throws Exception {
        HttpMethod method = doRequest(path, methodRequired, "");
        return method.getStatusCode();
    }

    private HttpMethod doRequest(String path, RequestMethod methodRequired, String params) throws IOException {
        HttpMethod method = null;
        String url = baseUrl + path;
        switch(methodRequired) {
            case PUT:
                method = new PutMethod(url);
                break;
            case POST:
                method = new PostMethod(url);
                break;
            case GET:
                method = new GetMethod(url);
                break;
        }
        method.setQueryString(params);
        HttpClient client = new HttpClient();
        client.executeMethod(method);
        return method;
    }

    public static boolean isRedirect(int statusCode) {
        return statusCode >= 300 && statusCode < 400;
    }
}

```


Overlapping Code:
```
 class HttpClientHelper {
public static final String DEFAULT_URL = "http://localhost:7493/go/";
private String baseUrl = DEFAULT_URL;
public HttpClientHelper() {
}
public HttpClientHelper(String baseUrl) {
this.baseUrl = baseUrl;
}
public String httpRequest(final String path, RequestMethod methodRequired) throws Exception {
return httpRequest(path, methodRequired, null);
}
public String httpRequest(final String path, RequestMethod methodRequired, String params) throws Exception {
HttpMethod method = doRequest(path, methodRequired, params);
return method.getResponseBodyAsString();
}
public int httpRequestForHeaders(final Stription {
HttpMethod method = doRequest(path, methodRequired, "");
return method.getStatusCode();
}
private HttpMethod doRequest(String path, RequestMethod methodRequired, String params) throws IOException {
HttpMethod method = null;
String url = baseUhod = new PutMethod(url);
break;
case POST:
method = new PostMethod(url);
break;
case GET:
method = new GetMethod(url);
break;
}
method.setQueryString(params);
HttpClient client = new HttpClient();
client.executeMethod(method);
return method;
}
public static boolean isRedirect(int statusCode) {
return statusCode >= 300 && statusCode 
```
<Overlap Ratio: 0.9136636636636637>

---

--- 190 --
Question ID: 2861105d837d7c45ed2e603975d65a33155fbc51
Original Code:
```
@ObjectHolder(Reference.MOD_ID)
public class ModSoundEvents {

    private static final Map<String, SoundEvent> SOUNDS = new HashMap<>();

    static {
        for (ItemInstrument handHeld : ModInstruments.INSTRUMENTS) {
            Instrument instrument = handHeld.getInstrument();
            if (!SOUNDS.containsKey(instrument.sounds.timbre)) {
                SOUNDS.put(instrument.sounds.timbre, registerSound(instrument.sounds.timbre));
            }
        }
    }

    /**
     * Register a {@link SoundEvent}.
     *
     * @param soundName The SoundEvent's name with or without the [MOD_ID] prefix. With prefix uses this mods sound
     *                  resources. Without the prefix it will reference vanilla sound resources.
     * @return The SoundEvent
     */
    @Nullable
    private static SoundEvent registerSound(String soundName) {
        final ResourceLocation soundID = new ResourceLocation(soundName);
        SoundEvent soundEvent;
        if (soundName.contains(Reference.MOD_DOMAIN))
            soundEvent = new SoundEvent(soundID).setRegistryName(soundID);
        else
            soundEvent = SoundEvent.REGISTRY.getObject(soundID);
        return soundEvent;
    }

    @Mod.EventBusSubscriber(modid = Reference.MOD_ID)
    public static class RegistrationHandler {

        @SubscribeEvent
        public static void registerSoundEvents(final RegistryEvent.Register<SoundEvent> event) {
            SOUNDS.keySet().stream().filter(soundName -> soundName.contains(Reference.MOD_DOMAIN)).forEach(soundName -> event.getRegistry().register(SOUNDS.get(soundName)));
        }
    }

    /**
     * Get a {@link SoundEvent} by name
     *
     * @param soundName The name of the event with or without the [MOD_ID] prefix. Only names referenced in the
     *                  instruments.json file can be returned. However, in the event a key is not found the default
     *                  will be the vanilla note block 'pling' sound.
     * @return The SoundEvent
     */
    public static SoundEvent getSound(String soundName) {
        return SOUNDS.getOrDefault(soundName, SoundEvents.BLOCK_NOTE_PLING);
    }
}

```


Overlapping Code:
```
lder(Reference.MOD_ID)
public class ModSoundEventsment instrument = handHeld.getInstrument();
if (!SNDS.put(instrument.sounds.timbre, registerSound(instrument.sounds.timbre));
}
}
}
/**
* Register a {@link SoundEvent}.
*
* @param soundName The SoundEvent's name with or without the [MOD_ID] prefix. With prefix uses this mods sound
* resources. Without the prefix it will reference vanilla sound resources.
* @return The SoundEvent
*/
@Nullable
private static SoundEvent registerSound(String soundName) {
final ResourceLocation soundID = new ResourceLocation(soundName);
SoundEvent soundEvent;
if (soundName.contains(Reference.MOD_DOMAIN))
soundEvent = new SoundEvent(soundID).setRegistryName(soundID);
else
soundEvent = SoundEvent.REGISTRY.getObject(soundID);
return soundEvent;
}
@Mod.EventBusSubscriber(modid = Reference.MOD_ID)
public static class RegistrationHandler {
@SubscribeEvent
public static void registerSoundEvents(final RegistryEvent.Register<SoundEvent> event) {
m().filter(soundName -> soundName.contains(Reference.MOD_DOMAIN)).forEach(soundName -> event.getRegistry().register(SOUNDS.get(soundName)));
}
}
/**
* Get a {@link SoundEvent} by name
*
* @param soundName The name of the event with or without the [MOD_ID] prefix. Only names referenced in the
* instruments.json file can be returned. However, in the event a key is not found the default
* will be the vanilla note block 'pling' sound.
* @return The SoundEvent
*/
public static SoundEvent getSound(Str
```
<Overlap Ratio: 0.8225806451612904>

---

--- 191 --
Question ID: d11a112c80b51a47725f96971f69f14f8a4af6d6
Original Code:
```
@Entity
@Table(name = "service_info")
public class ServiceInfo implements Serializable {

    private static final long serialVersionUID = 768026109321305392L;

    @Id
    @BusinessKey
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "ID")
    private Integer id;

    @Column(name = "SERVICE_INPUT")
    private String serviceInput;

    @Column(name = "SERVICE_PROPERTIES")
    private String serviceProperties;

    @ManyToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "SERVICE_MODEL_UUID")
    private Service service;

    public Integer getId() {
        return id;
    }

    public void setId(Integer serviceInfoId) {
        this.id = serviceInfoId;
    }

    public String getServiceInput() {
        return serviceInput;
    }

    public void setServiceInput(String serviceInput) {
        this.serviceInput = serviceInput;
    }

    public String getServiceProperties() {
        return serviceProperties;
    }

    public void setServiceProperties(String serviceProperties) {
        this.serviceProperties = serviceProperties;
    }

    @LinkedResource
    public Service getService() {
        return service;
    }

    public void setService(Service service) {
        this.service = service;
    }

    @Override
    public String toString() {
        return new ToStringBuilder(this).append("id", id).append("serviceProperties", serviceProperties).append("serviceInput", serviceInput).toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        ServiceInfo that = (ServiceInfo) o;
        return id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

```


Overlapping Code:
```
 = "service_info")
public class ServiceInfo implements Serializable {
private static final long serialVersionUID = 768026109321305392L;
@Id
@BusinessKey
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "ID")
private Integer id;
@Column(name = "SERVICE_INPUT")
private String serviceInput;
@Column(name = "SERVICE_PROPERTIES")
private String serviceProperties;
@ManyToOne(cascade = CascadeType.ALL)
@JoinColumn(name = "SERVICE_MODEL_UUID")
private Service service;
public Integer getId() {
return id;
}
public void setId(Integer serviceInfoId) {
this.id = serviceInfoId;
}
public String getServiceInput() {
return serviceInput;
}
public void setServiceInput(String serviceInput) {
this.serviceInput = serviceInput;
}
public String getServiceProperties() {
return serviceProperties;
}
public void setServiceProperties(String serviceProperties) {
this.serviceProperties = serviceProperties;
}
@LinkedResource
public Service getService() {
return service;
}
public void setService(Service service) {
this.service = service;
}
@Override
public String toString() {
return new ToStringBuilder(this).append("id", id).append("servicePropertirviceInput).toString();
}
@Override
public boolean equals(Object o) {
if (this == o)
return true;
if (o == null || getClass() != o.getClass())
return false;
ServiceInfo that = (ServiceInfo) o;
return id.equals(that.id);
}
@Override
public int hashCode() {
return Objects.hash(id);
}
}
```
<Overlap Ratio: 0.9547270306258322>

---

--- 192 --
Question ID: 90d3f4bd6f2d6ccb83b96ee0b6950067be328447
Original Code:
```
public class ForcedRevival extends AbstractNormaAttentiveCard {

    public static final String ID = OrangeJuiceMod.makeID(ForcedRevival.class.getSimpleName());

    public static final String IMG = makeCardPath("ForcedRevival.png");

    private static final CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);

    public static final String UPGRADE_DESCRIPTION = cardStrings.UPGRADE_DESCRIPTION;

    private static final CardRarity RARITY = CardRarity.UNCOMMON;

    private static final CardTarget TARGET = CardTarget.SELF;

    private static final CardType TYPE = CardType.SKILL;

    public static final CardColor COLOR = TheStarBreaker.Enums.COLOR_WHITE_ICE;

    private static final int COST = 0;

    private static final int HEAL = 4;

    private static final int UPGRADE_PLUS_HEAL = 2;

    private static final int ENERGY = 1;

    private static final int UPGRADE_PLUS_ENERGY = 1;

    private static final int DEBUFF = 2;

    private static final Integer[] NORMA_LEVELS = { 3 };

    public ForcedRevival() {
        super(ID, IMG, COST, TYPE, COLOR, RARITY, TARGET, NORMA_LEVELS);
        magicNumber = baseMagicNumber = HEAL;
        secondMagicNumber = baseSecondMagicNumber = ENERGY;
        invertedNumber = baseInvertedNumber = DEBUFF;
        exhaust = true;
        this.tags.add(CardTags.HEALING);
        CardModifierManager.addModifier(this, new NormaDynvarModifier(NormaDynvarModifier.DYNVARMODS.INVERTEDMOD, -1, NORMA_LEVELS[0], EXTENDED_DESCRIPTION[0]));
    }

    // Actions the card should do.
    @Override
    public void use(AbstractPlayer p, AbstractMonster m) {
        this.addToBot(new HealAction(p, p, this.magicNumber));
        this.addToBot(new GainEnergyAction(this.secondMagicNumber));
        if (invertedNumber > 0) {
            this.addToBot(new ApplyPowerAction(p, p, new WeakPower(p, this.invertedNumber, false)));
        }
    }

    // Upgraded stats.
    @Override
    public void upgrade() {
        if (!this.upgraded) {
            this.upgradeName();
            rawDescription = UPGRADE_DESCRIPTION;
            this.upgradeMagicNumber(UPGRADE_PLUS_HEAL);
            this.upgradeSecondMagicNumber(UPGRADE_PLUS_ENERGY);
            this.initializeDescription();
        }
    }
}

```


Overlapping Code:
```

public static final String ID = OrangeJuiceMod.makeID(ForcedRevival.class.getSimpleName());
public static final String IMG = makeCardPath("ForcedRevival.png");
private static final CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);
public static final String UPGRADE_DESCRIPTION = cardStrings.UPGRADE_DESCRIPTION;
private static final CardRarity RARITY = CardRarity.UNCOMMON;
private static final CardTarget TARGET = CardTarget.SELF;
private static final CardType TYPE = CardType.SKILL;
public static final CardColor COLOR = TheStarBreaker.Enums.COLOR_WHITE_ICE;
private static final int COST = 0;
private static final int HEAL = 4;
private static final int UPGRADE_PLUS_HEAL = 2;
private static final int ENERGY = 1;
private static final int UPGRADE_PLUS_ENERGY = 1;
private static final int DEBUFF = 2;
private static final Integer[] NrcedRevival() {
super(ID, IMG, COST, TYPE, COLOR, RARITY, TARGET, NORMA_LEVELS);
magicNumber = baseMagicNumber = HEAL;
secondMagicNumber = baseSecondMagicNumber = ENERGY;
invertedNumber = baseInvertedNumber = DEBUFF;
exhaust = true;
this.tags.add(CardTags.HEALING);
CardModifierManager.addModifier(this, new NormaDynvarModifier(NormaDynvarModifier.DYNVARMODS.INVERTEDMOD, -1, NORMA_LEVELS[0], EXTENDED_DESCRIPTION[0]));
}
// Actions the card should do.
@Override
public void use(AbstractPlayer p, AbstractMonster m) {
this.addToBot(new HealAction(p, p, this.magicNumber));
this.addToBot(new GainEnergyAction(this.secondMagicNumber));
if (invertedNumber > 0) {
this.addToBot(new ApplyPowerAction(p, p, new WeakPower(p, this.invertedNumber, false)));
}
}
// Upgraded stats.
@Override
public void upgrade() {
if (!this.upgraded) {
this.upgradeName();
rawDescription = UPGRADE_DESCRIPTION;
this.upgradeMagicNumber(UPGRADE_PLUS_HEAL);
this.upgradeSecondMagicNumber(UPGRADE_PLUS_ENERGY);
this.initializeDes
```
<Overlap Ratio: 0.9441624365482234>

---

--- 193 --
Question ID: e6daad92b85ef23f3921081ecaf6d618b18c2f1b
Original Code:
```
public class OrmBenchmarksTask extends Task {

    public static final String TAG = "OrmBenchmarksTask";

    private static final boolean USE_IN_MEMORY_DB = false;

    private static final int NUM_ITERATIONS = 5;

    private BenchmarkExecutable[] mOrms = new BenchmarkExecutable[] { new SquidbExecutor(), new SugarOrmExecutor(), new SQLiteExecutor(), new DBFlowExecutor(), new SqueakyExecutor(), new CupboardExecutor(), new com.littleinc.orm_benchmark.squeakyfinal.SqueakyExecutor(), new RealmExecutor(), new RequeryExecutor(), new OptimizedSQLiteExecutor(), new ORMLiteExecutor(), new GreenDaoExecutor() };

    public String resultString;

    Map<String, Map<String, Long>> benchmarkResults = new TreeMap<>();

    enum BenchmarkTask {

        CREATE_DB, WRITE_DATA, READ_DATA, DROP_DB
    }

    @Override
    protected void run(Context context) throws Throwable {
        for (BenchmarkExecutable orm : mOrms) {
            orm.init(context, USE_IN_MEMORY_DB);
            Log.w(TAG, orm.getOrmName() + " init");
        }
        List<BenchmarkExecutable> failed = new ArrayList<>();
        int i = 0;
        while (i < NUM_ITERATIONS) try {
            for (BenchmarkExecutable item : mOrms) {
                for (BenchmarkTask task : BenchmarkTask.values()) {
                    long result = 0;
                    Log.w(TAG, item.getOrmName() + "-" + task.name() + " start");
                    try {
                        switch(task) {
                            case CREATE_DB:
                                result = item.createDbStructure();
                                break;
                            case DROP_DB:
                                result = item.dropDb();
                                break;
                            case READ_DATA:
                                result = item.readWholeData();
                                break;
                            case WRITE_DATA:
                                result = item.writeWholeData();
                                break;
                        }
                    } catch (Exception e) {
                        result = Long.MIN_VALUE;
                        failed.add(item);
                    }
                    Log.w(TAG, item.getOrmName() + "-" + task.name() + " end");
                    addProfilerResult(item.getOrmName(), task, result);
                }
            }
        } finally {
            i++;
        }
        buildResultString();
    }

    private void buildResultString() {
        StringBuilder sb = new StringBuilder();
        BenchmarkTask[] bTasks = new BenchmarkTask[] { BenchmarkTask.WRITE_DATA, BenchmarkTask.READ_DATA };
        for (BenchmarkTask bTask : bTasks) {
            sb.append("<b>").append(bTask.name()).append("</b>").append("<br/>");
            Map<String, Long> stringLongMap = benchmarkResults.get(bTask.name());
            if (stringLongMap != null) {
                for (String ormName : stringLongMap.keySet()) {
                    long result = stringLongMap.get(ormName);
                    double printResult = ((double) result / (double) NUM_ITERATIONS) / ((double) 1000000);
                    sb.append(ormName).append(" - ");
                    if (printResult < 0) {
                        sb.append("(crashed)");
                    } else {
                        sb.append(Math.round(printResult)).append("ms");
                    }
                    sb.append("<br/>");
                    Log.w("FOR_SPREADSHEET", ormName + "," + Math.round(printResult));
                }
            }
        }
        resultString = sb.toString();
    }

    private void addProfilerResult(String ormName, BenchmarkTask task, long result) {
        Map<String, Long> taskMap = benchmarkResults.get(task.name());
        if (taskMap == null) {
            taskMap = new TreeMap<>();
            benchmarkResults.put(task.name(), taskMap);
        }
        Long storedResult = taskMap.get(ormName);
        if (storedResult == null) {
            storedResult = 0l;
        }
        long value = result + storedResult;
        taskMap.put(ormName, value);
        Log.w(TAG, "adding " + task.name() + "-" + ormName + "-" + value);
    }

    @Override
    protected boolean handleError(Context context, Throwable e) {
        return false;
    }

    @Override
    protected void onComplete(Context context) {
        EventBusExt.getDefault().post(this);
    }
}

```


Overlapping Code:
```
= "OrmBenchmarksTask";
private static final boolean USE_IN_MEMORY_DB = false;
private static final int NUM_ITERATIONS = 5;
private BenchmarkExecutableng, Map<String, Long>> benchmarkResults = new Tree}
@Override
protected void run(Context context) throws Throwable {
_IN_MEMORY_DB);
Log.w(TAG, orm.getOrmName() + " init");
}
List<BenchmarkExecutable> failed = new Arrresult = 0;
Log.w(TAG, item.getOrmName() + "-" + tCREATE_DB:
result = item.createDbStructure();
break;
case DROP_DB:
result = item.dropDb();
break;
case READ_DATA:
result = item.readWholeData();
break;
case WRITE_DATA:
result = item.writeWholeData();_VALUE;
failed.add(item);
}
Log.w(TAG, item.getOrm
```
<Overlap Ratio: 0.39868499701135685>

---

--- 194 --
Question ID: 0a1e9bd38adebe2351975cd89a116d8cc06a6a3a
Original Code:
```
public class BlockRail extends BlockRailBase {

    public static final PropertyEnum<BlockRailBase.EnumRailDirection> SHAPE = PropertyEnum.<BlockRailBase.EnumRailDirection>create("shape", BlockRailBase.EnumRailDirection.class);

    protected BlockRail() {
        super(false);
        this.setDefaultState(this.blockState.getBaseState().withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH));
    }

    protected void updateState(IBlockState state, World worldIn, BlockPos pos, Block blockIn) {
        if (blockIn.getDefaultState().canProvidePower() && (new BlockRailBase.Rail(worldIn, pos, state)).countAdjacentRails() == 3) {
            this.updateDir(worldIn, pos, state, false);
        }
    }

    public IProperty<BlockRailBase.EnumRailDirection> getShapeProperty() {
        return SHAPE;
    }

    /**
     * Convert the given metadata into a BlockState for this Block
     */
    public IBlockState getStateFromMeta(int meta) {
        return this.getDefaultState().withProperty(SHAPE, BlockRailBase.EnumRailDirection.byMetadata(meta));
    }

    /**
     * Convert the BlockState into the correct metadata value
     */
    public int getMetaFromState(IBlockState state) {
        return ((BlockRailBase.EnumRailDirection) state.getValue(SHAPE)).getMetadata();
    }

    /**
     * Returns the blockstate with the given rotation from the passed blockstate. If inapplicable, returns the passed
     * blockstate.
     * @deprecated call via {@link IBlockState#withRotation(Rotation)} whenever possible. Implementing/overriding is
     * fine.
     */
    @SuppressWarnings("incomplete-switch")
    public IBlockState withRotation(IBlockState state, Rotation rot) {
        switch(rot) {
            case CLOCKWISE_180:
                switch((BlockRailBase.EnumRailDirection) state.getValue(SHAPE)) {
                    case ASCENDING_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);
                    case ASCENDING_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);
                    case ASCENDING_NORTH:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);
                    case ASCENDING_SOUTH:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);
                    case SOUTH_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);
                    case SOUTH_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);
                    case NORTH_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);
                    case NORTH_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);
                }
            case COUNTERCLOCKWISE_90:
                switch((BlockRailBase.EnumRailDirection) state.getValue(SHAPE)) {
                    case ASCENDING_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);
                    case ASCENDING_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);
                    case ASCENDING_NORTH:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);
                    case ASCENDING_SOUTH:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);
                    case SOUTH_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);
                    case SOUTH_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);
                    case NORTH_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);
                    case NORTH_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);
                    case NORTH_SOUTH:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.EAST_WEST);
                    case EAST_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH);
                }
            case CLOCKWISE_90:
                switch((BlockRailBase.EnumRailDirection) state.getValue(SHAPE)) {
                    case ASCENDING_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);
                    case ASCENDING_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);
                    case ASCENDING_NORTH:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);
                    case ASCENDING_SOUTH:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);
                    case SOUTH_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);
                    case SOUTH_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);
                    case NORTH_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);
                    case NORTH_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);
                    case NORTH_SOUTH:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.EAST_WEST);
                    case EAST_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH);
                }
            default:
                return state;
        }
    }

    /**
     * Returns the blockstate with the given mirror of the passed blockstate. If inapplicable, returns the passed
     * blockstate.
     * @deprecated call via {@link IBlockState#withMirror(Mirror)} whenever possible. Implementing/overriding is fine.
     */
    @SuppressWarnings("incomplete-switch")
    public IBlockState withMirror(IBlockState state, Mirror mirrorIn) {
        BlockRailBase.EnumRailDirection blockrailbase$enumraildirection = (BlockRailBase.EnumRailDirection) state.getValue(SHAPE);
        switch(mirrorIn) {
            case LEFT_RIGHT:
                switch(blockrailbase$enumraildirection) {
                    case ASCENDING_NORTH:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);
                    case ASCENDING_SOUTH:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);
                    case SOUTH_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);
                    case SOUTH_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);
                    case NORTH_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);
                    case NORTH_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);
                    default:
                        return super.withMirror(state, mirrorIn);
                }
            case FRONT_BACK:
                switch(blockrailbase$enumraildirection) {
                    case ASCENDING_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);
                    case ASCENDING_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);
                    case ASCENDING_NORTH:
                    case ASCENDING_SOUTH:
                    default:
                        break;
                    case SOUTH_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_WEST);
                    case SOUTH_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.SOUTH_EAST);
                    case NORTH_WEST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_EAST);
                    case NORTH_EAST:
                        return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_WEST);
                }
        }
        return super.withMirror(state, mirrorIn);
    }

    protected BlockStateContainer createBlockState() {
        return new BlockStateContainer(this, new IProperty[] { SHAPE });
    }
}

```


Overlapping Code:
```
ass BlockRail extends BlockRailBase {
public static final PropertyEnum<BlockRailBase.EnumRailDirection> SHAPE = PropertyEnum.<BlockRailBase.EnumRailDirection>create("shape", BlockRailBase.EnumRailDirection.class);
protected BlockRail() {
super(false);
this.setDefaultState(this.blockState.getBaseState().withProperty(SHAPE, BlockRailBase.EnumRailDirection.NORTH_SOUTH));
}
protected void updateState(IBlockState state, World worldIn, BlockPos pos, Block blockIn) {
if (blockIn.getDefaultState().canProvidePower() && (new BlockRailBase.Rail(worldIn, pos, state)).countAdjacentRails() == 3) {
th(worldIn, pos, state, false);
}
}
public IProperty<BlockRailBase.EnumRailDirection> getShapeProperty() {
return SHAPE;
}
/**
* Convert the given metadata into a BlockState for this Block
*/
public IBlockState getStateFromMeta(int meta) {
return this.getDefaultState().withProperty(SHAPE, BlockRailBase.EnumRailDirection.byMetadata(meta));
}
/**
* Convert the BlockState into the correct metadata value
*/
public int getMetaFromState(IBlockState state) {
return ((BlockRailBase.EnumRailDirection) state.getValue(SHAPE)).getMetadata();
}
/**
* Returns the blockstate with the given rotation from the passed blockstate. If inapplicable, returns the passed
* blockstate.
* @deprecated call via {@link IBlockState#withRotation(Rotation)} whenever possible. Implementing/overriding is
* fine.
*/
@SuppressWarnings("incomplete-switch")
public IBlockState withRotation(IBlockState state, Rotation rot) {
switch(rot) {
case CLOCKWISE_180:
swittate.getValue(SHAPE)) {
case ASCENDING_EAST:
return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_WEST);
case ASCENDING_WEST:
return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_EAST);
case ASCENDING_NORTH:
return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_SOUTH);
case ASCENDING_SOUTH:
return state.withProperty(SHAPE, BlockRailBase.EnumRailDirection.ASCENDING_NORTH);
case SOUTH_EAST:
return state.wi
```
<Overlap Ratio: 0.9708596406022341>

---

--- 195 --
Question ID: 6571a406fc36a6fca11c11117b7c8d3178aa31e8
Original Code:
```
@Service
public class DocumentoService {

    @Autowired
    private DocumentoRepository documentoRepository;

    @Autowired
    private MilitarRepository militarRepository;

    @Autowired
    private MilitarService militarService;

    /**
     * Cria um novo documento
     *
     * @param documento DTO do documento a ser salvo
     * @return retorna um response file do documento salvo
     * @throws IOException
     * @throws HttpException
     */
    public RFDocumento criar(DocumentoDTO documentodto) throws IOException, HttpException {
        if (!documentodto.isValidationOk())
            throw new HttpException("validation failed");
        RFDocumento rfdoc;
        Documento doc = DocumentoMapper.toModel(documentodto);
        doc.setMilitares(null);
        List<Militar> militares = new ArrayList<Militar>();
        if (documentodto.getMilitares() != null) {
            documentodto.getMilitares().forEach(element -> {
                if (!militarRepository.existsByMatricula(element.getMatricula())) {
                    try {
                        if (militarService.getListByMatricula(element.getMatricula()) != null) {
                            Militar mil = new Militar(element.getMatricula(), new ArrayList<Documento>());
                            mil = militarRepository.save(mil);
                            militares.add(mil);
                        } else {
                            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Envie um militar valido");
                        }
                    } catch (IOException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                } else {
                    Militar mil = militarRepository.findByMatricula(element.getMatricula()).get();
                    militares.add(mil);
                }
            });
        }
        doc.setMilitares(militares);
        rfdoc = new RFDocumento(documentoRepository.save(doc));
        return rfdoc;
    }

    /**
     * Edita um documento e salva no banco
     *
     * @param id           id do documento a ser editado
     * @param documentodto dto com documento atualizado
     * @return
     * @throws IOException
     * @throws HttpException
     */
    public RFEditarDocumento editar(long id, DocumentoDTO documentodto) throws IOException, ValidationException, HttpException {
        if (!documentodto.isValidationOk())
            throw new HttpException("erro");
        Documento doc = documentoRepository.findById(id).get();
        doc.setTipo(documentodto.getTipo());
        doc.setNumeracao(documentodto.getNumeracao());
        doc.setNome(documentodto.getNome());
        doc.setDescricao(documentodto.getDescricao());
        doc.setData(documentodto.getData());
        doc.setPublico(documentodto.getPublico());
        List<Militar> militares = new ArrayList<Militar>();
        if (documentodto.getMilitares() != null) {
            documentodto.getMilitares().forEach(element -> {
                if (!militarRepository.existsByMatricula(element.getMatricula())) {
                    try {
                        if (militarService.getListByMatricula(element.getMatricula()) != null) {
                            Militar mil = new Militar(element.getMatricula(), new ArrayList<Documento>());
                            mil = militarRepository.save(mil);
                            militares.add(mil);
                        } else {
                            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Envie um militar valido");
                        }
                    } catch (IOException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                } else {
                    Militar mil = militarRepository.findByMatricula(element.getMatricula()).get();
                    militares.add(mil);
                }
            });
        }
        doc.setMilitares(militares);
        documentoRepository.save(doc);
        return new RFEditarDocumento(doc);
    }

    /**
     * Busca um documento pelo id
     *
     * @param id id do documento a ser procurado
     * @return retorna um response file do documento
     * @throws IOException
     */
    public RFDocumento getDocumento(Long id) throws IOException {
        Documento doc = documentoRepository.findById(id).get();
        RFDocumento rfdoc = new RFDocumento(doc);
        return rfdoc;
    }

    /**
     * Busca um documento utilizando multiplos campos e uma specification
     *
     * @param docJson jsonNode gerada com os campos de busca
     * @return uma lista de responsefiles de documentos
     * @throws IOException
     */
    public List<RFBuscaDocumentos> getDocumento(Map<String, Object> map) throws IOException {
        DocumentoSpecification ds = new DocumentoSpecification(map);
        List<RFBuscaDocumentos> rfDocList = documentoRepository.findAll(ds).stream().map(documento -> {
            RFBuscaDocumentos newRFDoc = new RFBuscaDocumentos(documento);
            return newRFDoc;
        }).collect(Collectors.toList());
        /*
         * List<RFBuscaDocumentos> rfDocList =
         * documentoRepository.findAll().stream().map(documento -> { RFBuscaDocumentos
         * newRFDoc = new RFBuscaDocumentos(documento); return newRFDoc;
         * }).collect(Collectors.toList());
         */
        return rfDocList;
    }
}

```


Overlapping Code:
```
ice {
@Autowired
private DocumentoRepository documentoRepository;
@Autowired
private MilitarRepository militarRepository;
@Autowired
private MilitarService militarService;
/**
* Cria um novo documentoo
* @return retorna um response file do documento salvo
* @throws IOException
* @throws HttpException
*/
public RFDocumento criar(DocumentoDTO documentodto) throws IOException, HttpException {
if (!documentodto.isValidationOk())
throw new HttpException("validation failed");
RFDocumento rfdoc;
Documento doc = DocumentoMapper.toModel(documentodto);
doc.setMilitares(null);
List<Militar> militares = new ArrayList<Militar>();
if (documentodto.getMilitares() != null) {
documentodto.getMilitares().forEach(element -> {
if (!militarRepository.existsByMatricula(element.getMatricula())) {
try {
if (militarService.getListByMatricula(element.getMatricula()) != null) {
Militar mil = new Militar(element.getMatricula(), new ArrayList<Documento>());
mil = militarRepository.save(mil);
militares.add(mil);
} else {
throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Envie um militar valido");
}
} catch (IOException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
} else {
Militar mil = militarRepository.findByMatricula(element.getMatricula()).get();
militares.add(mil);
}
});
}
doc.setMilitares(militares);
rfdoc = new RFDocumento(documentoRepository.save(doc));
return rfdoc;
}
/**
id id do documento a ser editado
* @param documentodto dto com documento atualizado
* @return
* @throws IOException
* @throws HttpException
*/
public RFEditarDocumento editar(long id, DocumentoDTO doc, HttpException {
if (!documentodto.isValidationOk
```
<Overlap Ratio: 0.8923742563547864>

---

--- 196 --
Question ID: fe59e73e25558d873a94e9fc5c1225b2bb48a8de
Original Code:
```
public class WheelOfFortune extends SubsystemBase {

    //Create necessary objects
    private static ColorSensorV3 m_colorSensor;

    private static WPI_VictorSPX m_spinWheel;

    private static Solenoid m_wheelArm;

    private Map<String, String> fieldToTargetColorMap = new HashMap<String, String>();

    private double lastTimestamp;

    private boolean isChanged;

    private boolean isCounted;

    private String actualColor;

    private float deg = 0;

    private float sat = 0;

    private float brightness = 0;

    private Thread interrogator;

    private int cachedR = 0;

    private int cachedG = 0;

    private int cachedB = 0;

    private class InterrogationLoop implements Runnable {

        public void run() {
            try {
                // These three operations can run away waiting for i2c synchronization
                int r = m_colorSensor.getRed();
                int g = m_colorSensor.getGreen();
                int b = m_colorSensor.getBlue();
                // Now as we are back we can update the cache at once
                cachedR = r;
                cachedG = g;
                cachedB = b;
                Thread.sleep(20);
            } catch (InterruptedException e) {
                DriverStation.reportError("Thread " + Thread.currentThread().getName() + " got interrupted", true);
                return;
            }
        }
    }

    private static final WheelOfFortune instance = new WheelOfFortune();

    public static WheelOfFortune getInstance() {
        return instance;
    }

    private WheelOfFortune() {
        m_colorSensor = new ColorSensorV3(I2C.Port.kOnboard);
        m_spinWheel = new WPI_VictorSPX(RobotMap.CAN_WHEELOFFORTUNE);
        m_spinWheel.configFactoryDefault();
        m_spinWheel.setNeutralMode(NeutralMode.Brake);
        isChanged = false;
        m_wheelArm = new Solenoid(RobotMap.CAN_PNMMODULE, RobotMap.PNM_WHEELARM);
        m_wheelArm.set(false);
        //This is the Map for converting the fieldColor into targetColor, which can be used to clear a lot of confusion while making the algorithm
        fieldToTargetColorMap.put("Blue", "Red");
        fieldToTargetColorMap.put("Green", "Yellow");
        fieldToTargetColorMap.put("Red", "Blue");
        fieldToTargetColorMap.put("Yellow", "Green");
        // Initialize color tracker to black
        actualColor = "Black";
        interrogator = new Thread(new InterrogationLoop(), "WOF interrogator");
        interrogator.start();
        DriverStation.reportWarning("WOF color sensor Init complete", false);
    }

    public String getTargetColor(String sourceColor, WheelOfFortune subsystem) {
        return subsystem.fieldToTargetColorMap.get(sourceColor);
    }

    public String determineColor() {
        String possibleColor = this.detectHSB();
        if (!possibleColor.equals(actualColor)) {
            if (!isChanged) {
                lastTimestamp = Timer.getFPGATimestamp();
                isChanged = true;
                isCounted = false;
            } else {
                if (Timer.getFPGATimestamp() - lastTimestamp > .1 && !isCounted) {
                    isCounted = true;
                    isChanged = false;
                    actualColor = possibleColor;
                }
            }
        } else {
            isChanged = false;
        }
        return actualColor;
    }

    /**
     * Run the color match algorithm on our detected color
     *
     * @return String name of the most likely color
     */
    public String detectHSB() {
        float[] hsb = java.awt.Color.RGBtoHSB(cachedR, cachedG, cachedB, null);
        deg = hsb[0] * 360;
        sat = hsb[1];
        brightness = hsb[2];
        //Potential algorithm for rgb to hsb
        if (sat < 0.3 && brightness > 0.9) {
            return "White";
        } else if (brightness < 40.0) {
            return "Black";
        } else {
            if (deg < 60 || deg > 310) {
                return "Red";
            } else if (deg < 100) {
                return "Yellow";
            } else if (deg < 130) {
                return "Green";
            } else if (deg < 250) {
                return "Blue";
            } else {
                return "Bruh";
            }
        }
    }

    /**
     * Method for toggling wheel of fortune manipulator
     */
    public void toggleWheel() {
        //        System.out.println("Wheel has toggled");
        m_wheelArm.set(!m_wheelArm.get());
    }

    /**
     * method for retracting wheel to be called in a command
     */
    public void retractWheel() {
        //        System.out.println("Wheel has retracted");
        m_wheelArm.set(false);
    }

    public void motorSpin(double spin) {
        m_spinWheel.set(ControlMode.PercentOutput, spin);
    }

    public void outputToShuffleboard(WheelOfFortune subsystem) {
        SmartDashboard.putString("HSB Detected color", subsystem.detectHSB());
        //TODO: remove these
        SmartDashboard.putNumber("Hue Degree", subsystem.deg);
        SmartDashboard.putNumber("Saturation", subsystem.sat);
        SmartDashboard.putNumber("Brightness", subsystem.brightness);
    }

    @Override
    public void periodic() {
    }
}

```


Overlapping Code:
```
une extends SubsystemBase {
//Create necessary objects
private static ColorSensorV3 m_colorSensor;
private static WPI_VictorSPX m_spinWheel;
private se Map<String, String> fieldToTargetColorMap = new HashMap<String, String>();
private double lastTimestamp;
private boolean isChanged;
private boolean isCounted;
private String actualColor;
private float deg = 0;
private float sat = 0;
private float brightness = 0;
private Thread interrogator;
private int cachedR = 0;
private int cachedG = 0;
private int cachedB = 0;
private class InterrogationLoop implements Runnable {
public void run() {
try {
// These three operations can run away waiting for i2c synchronization
int r = m_colorSensor.getRed();
int g = m_colorSensor.getGreen();
int b = m_colorSensor.getBlue();
// Now as we are back we can update the cache at once
cachedR = r;
cachedG = g;
cachedB = b;
Thread.sleep(20);
} catch (InterruptedException e) {
DriverStation.reporrror("Thread " + Thread.currentThread().getName() + " elOfFortune instance = new WheelOfFortune();
public static WheelOfFortune getInstance() {
return instance;
}
private WheelOfFortune() {
m_colorSensor = new ColorSensorV3(I2C.Port.kOnboard);
m_spinWheel = new WPI_VictorSPX(RobotMap.CAN_WHEELOFFORTUNE);
m_spinWheel.configFactoryDefault();
m_spinWheel.setNeutralMode(NeutralMode.Brake);
isChanged = false;
m_wheelArm = new Solenoid(RobotMap.CAN_PNMMODULE, RobotMap.PNM_WHEELARM);
m_wheelArm.set(false);
//This is the Map for converting the fieldColor into targetColor, which can be used to clear a lot of confusion while making the algorithm
fieldToTargetColorMap.put("Blue", "Red");
fieldToTargetColorMap.put("Green", "Yellow");
fieldToTargetColorMap.put("Red", "Blue");
fieldToTargetColorMap.put("Yeld(new InterrogationLoop(), "WOF interrogator");
in
```
<Overlap Ratio: 0.882091761223483>

---

--- 197 --
Question ID: 1933efc9aa1b1d5e9b432865d575e9d6ff573c10
Original Code:
```
@RestController
@RequestMapping("api/v1")
public class CollaboratorController {

    @Autowired
    CollaboratorService collaboratorServ;

    @ApiOperation(value = "Get All the Collaborators")
    @GetMapping("/collaborators")
    public ResponseEntity<List<CollaboratorResponse>> getCoolCollaborators() {
        List<Collaborator> collaborators = collaboratorServ.getCollaborators();
        List<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);
        return ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);
    }

    @ApiOperation(value = "Get Collaborators by Organization")
    @GetMapping("/collaborators/organization_id/{org_id}")
    public ResponseEntity<List<CollaboratorResponse>> getCollaboratorsByOrganization(@PathVariable("org_id") Long org_id) {
        List<Collaborator> collaborators = collaboratorServ.getCollaboratorsByOrganization(org_id);
        List<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);
        return ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);
    }

    @ApiOperation(value = "Get All the Collaborator Types")
    @GetMapping("/collaborators/type")
    public ResponseEntity<List<CollaboratorType>> getCollaboratorTypes() {
        List<CollaboratorType> types = collaboratorServ.getCollaboratorTypes();
        return ResponseEntity.status(HttpStatus.OK).body(types);
    }

    @ApiOperation(value = "Get one Collaborator")
    @GetMapping("/collaborator/{id}")
    public ResponseEntity<CollaboratorResponse> getCollaboratorId(@PathVariable("id") Long id) {
        CollaboratorResponse collaborator = new CollaboratorResponse(collaboratorServ.findCollaboratorById(id));
        return ResponseEntity.status(HttpStatus.OK).body(collaborator);
    }

    @ApiOperation(value = "Get one Main Contact")
    @GetMapping("/main_contact/{id}")
    public ResponseEntity<MainContactResponse> getMainContactId(@PathVariable("id") Long id) {
        MainContactResponse collaborator = new MainContactResponse(collaboratorServ.findCollaboratorById(id));
        return ResponseEntity.status(HttpStatus.OK).body(collaborator);
    }

    @ApiOperation(value = "Create a Collaborator")
    @PostMapping("/collaborator")
    public ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody CollaboratorPayload collaborator) {
        Collaborator new_collaborator = collaboratorServ.createCollaborator(collaborator);
        return ResponseEntity.status(HttpStatus.CREATED).body(new_collaborator);
    }

    @ApiOperation(value = "Create a Main Contact")
    @PostMapping("/main_contact")
    public ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody MainContactPayload main_contact) {
        Collaborator new_main_contact = collaboratorServ.createMainContact(main_contact);
        return ResponseEntity.status(HttpStatus.CREATED).body(new_main_contact);
    }

    @ApiOperation(value = "Update a Collaborator")
    @PatchMapping("/collaborator/{id}")
    public ResponseEntity<Collaborator> updateCollaborator(@PathVariable("id") Long id, @RequestBody Collaborator collaborator) {
        Collaborator updated_collaborator = collaboratorServ.updateCollaborator(collaborator, id);
        return ResponseEntity.status(HttpStatus.OK).body(updated_collaborator);
    }

    @ApiOperation(value = "Delete a Collaborator")
    @DeleteMapping("/collaborator/{id}")
    public ResponseEntity<?> deleteCollaborator(@PathVariable("id") Long id) {
        collaboratorServ.deleteCollaborator(id);
        return ResponseEntity.status(HttpStatus.NO_CONTENT).body("Delete Collaborator with ID: " + id);
    }

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        return errors;
    }
}

```


Overlapping Code:
```
@RestController
@RequestMapping("api/v1")
public class CollaboratorController {
@Autowired
CollaboratorServill the Collaborators")
@GetMapping("/collaborators")
public ResponseEntity<List<CollaboratorResponse>> gaborators = collaboratorServ.getCollaborators();
List<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);
return ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);
}
@ApiOperation(value = "Get Collaborators by Organization")
@GetMapping("/collaborators/organization_id/{org_id}")
public ResponseEntity<List<CollaboratorResponse>> getCollaboratorsByOrganization(@PathVariable("org_i = collaboratorServ.getCollaboratorsByOrganization(org_id);
List<CollaboratorResponse> collaborators_resp = collaboratorServ.generateListCollaboratorResponse(collaborators);
return ResponseEntity.status(HttpStatus.OK).body(collaborators_resp);
}
@ApiOperation(value = "Get All the Collaborator Types")
@GetMapping("/collaborators/type")
public ResponseEntity<List<CollaboratorType>> getCollaboratorTyServ.getCollaboratorTypes();
return ResponseEntity.status(HttpStatus.OK).body(typeon(value = "Get one Collaborator")
@GetMapping("/collaborator/{id}")
public ResponseEntity<CollaboratorResponse> getCollaboratorId(@PathVariable("id") CollaboratorResponse(collaboratorServ.findCollaboratorById(id));
return ResponseEntity.status(HttpStatus.OK).body(collaborator);
}
@ApiOperation(value = "Get one Main Contact")
@GetMapping("/main_contact/{id}")
public ResponseEntity<MainContactResponse> getMainContactId(@PathVariable("id") Long id){
MainContactResponse collaborator = new MainContactResponse(collaboratorServ.findCollaboratorById(id));
return ResponseEntity.status(HttpStatus.OK).body(collaborator);
}
@ApiOperation(value a Collaborator")
@PostMapping("/collaborator")
public ResponseEntity<Collaborator> createCollaborator(@Valid @RequestBody CollaboratorPayload collab
```
<Overlap Ratio: 0.8448426573426573>

---

--- 198 --
Question ID: 1818ef99173a05fb9a278b65c8a3ba47949352bd
Original Code:
```
public class Timetable {

    private final String group;

    private final String semiGroup;

    private final int semester;

    private List<Activity> allActivities;

    /**
     * Constructor for the timetable. It parses all the lines, storing the necessary information for the given group.
     *
     * @param website - a ParseURL object containing the HTML source code lines
     * @param group   - the group number
     * @throws IOException
     */
    public Timetable(ParseURL website, final String group, final String semiGroup) throws IOException {
        this.group = group;
        this.semiGroup = semiGroup;
        allActivities = new ArrayList<>();
        semester = website.getSemester();
        List<String> htmlCode = website.getLines();
        if (!tableExists(htmlCode, group)) {
            throw new InvalidParameterException("The given URL does not contain the timetable for group " + group);
        }
        List<String> tableOfGroup = getTableOfGroup(htmlCode, group);
        List<List<String>> rows = divideIntoRows(tableOfGroup);
        rows.forEach(row -> allActivities.add(processRow(row)));
        filterActivities();
    }

    public Timetable(ParseURL website, final String group, final String semiGroup, List<String> filteredActivities) throws IOException {
        this(website, group, semiGroup);
        allActivities = allActivities.stream().filter(activity -> filteredActivities.contains(activity.getNameOfActivity())).collect(Collectors.toList());
    }

    private List<String> getTableOfGroup(List<String> htmlCode, final String group) {
        Pattern beginningOfTable = Pattern.compile("<table .*>");
        Pattern endOfTable = Pattern.compile("</table>");
        int wantedTable = group.charAt(group.length() - 1) - '0';
        int indexOfBeginning = -1, indexOfEnd = -1;
        int i = 0, foundTable = 0;
        while (i < htmlCode.size()) try {
            if (foundTable < wantedTable) {
                Matcher matcherTable = beginningOfTable.matcher(htmlCode.get(i));
                if (matcherTable.matches()) {
                    foundTable++;
                    if (wantedTable == foundTable) {
                        indexOfBeginning = i + 1;
                    }
                }
            }
            if (foundTable == wantedTable) {
                Matcher matcherEndTable = endOfTable.matcher(htmlCode.get(i));
                if (matcherEndTable.matches()) {
                    indexOfEnd = i;
                    break;
                }
            }
        } finally {
            i++;
        }
        return htmlCode.subList(indexOfBeginning, indexOfEnd);
    }

    private List<List<String>> divideIntoRows(List<String> table) {
        Pattern beginningOfRow = Pattern.compile("<tr .*>");
        Pattern endOfRow = Pattern.compile("</tr>");
        List<List<String>> rows = new ArrayList<>();
        List<String> currentRow = new ArrayList<>();
        boolean inRow = false;
        for (String line : table) {
            Matcher endOfRowMatcher = endOfRow.matcher(line);
            if (endOfRowMatcher.matches()) {
                rows.add(currentRow);
                currentRow = new ArrayList<>();
                inRow = false;
            }
            if (inRow) {
                currentRow.add(line);
            } else {
                Matcher beginningOfRowMatcher = beginningOfRow.matcher(line);
                if (beginningOfRowMatcher.matches()) {
                    inRow = true;
                }
            }
        }
        //information, it should be ignored
        return rows.subList(1, rows.size());
    }

    private boolean tableExists(List<String> htmlCode, String group) {
        Pattern groupPattern = Pattern.compile(".*Grupa " + group + ".*");
        return htmlCode.stream().anyMatch(line -> groupPattern.matcher(line).matches());
    }

    private Activity processRow(List<String> row) {
        Activity activity = new Activity();
        int currentColumn = 0;
        for (String column : row) {
            Pattern informationPattern = Pattern.compile(".*>([^<]+)<.*");
            Matcher matcher = informationPattern.matcher(column);
            if (matcher.find()) {
                String information = matcher.group(1);
                activity.setInformation(currentColumn, information);
            }
            currentColumn++;
        }
        return activity;
    }

    private void filterActivities() {
        allActivities = allActivities.stream().filter(activity -> activity.isForSemiGroup(semiGroup)).collect(Collectors.toList());
    }

    public List<Activity> getAllActivities() {
        return allActivities;
    }

    public String getGroup() {
        return group;
    }

    public String getSemiGroup() {
        return semiGroup;
    }

    public int getSemester() {
        return semester;
    }

    @Override
    public String toString() {
        StringBuilder output = new StringBuilder();
        for (Activity activity : allActivities) {
            output.append(activity);
        }
        return output.toString();
    }
}

```


Overlapping Code:
```
le {
private final String group;
private final String semiGroup;
private final int semester;
private List<Activity> allActivities;
/**
* Constructor for the timetable. It parses all the lines, storing the necessary information for the given group.
*
* @param website - a ParseURL object containing the HTML source code lines
* @param group - the group number
* @throws IOException
*/
public Timetable(ParseURL website, final String group, final String semiGroup) throws IOException {
this.group = group;
this.semiGroup = semiGroup;
allActivities = new ArrayList<>();
semester = website.getSemester();
List<String> htmlCode = website.getLines();
if (!tableExists(htmlCode, group)) {
throw new InvalidParameterException("The given URL does not contain the timetable for group " + group);
}
List<String> tableOfGroup = getTableOfGroup(htmlCode, group);
List<List<String>> rows = divideIntoRows(tableOfGroup);
rows.forEach(row -> allActivities.add(processRow(row)));
filterActivities();
}
public Timetable(ParseURL website, final String group, final String semiGroup, List<String> ite, group, semiGroup);
allActivities = allActivit())).collect(Collectors.toList());
}
private List<String> getTableOfGroup(List<String> htmlCode, final String group) {
Pattern beginningOfTable = Pattern.compile("<table .*>");
Pattern endOfTable = Pattern.compile("</table>");
int wantedTable = group.charAt(group.length() - 1) - '0';
int indexOfBeginning = -1,  {
if (foundTable < wantedTable) {
Matcher matcherTable = beginningOfTable.matcher(htmlCode.get(i));
if (matcherTable.matches()) {
foundTable++;
if (wantedTable == foundTable) {
indexOfBeginning = i + 1;
}
}
}
if (foundTable == wantedTable) {
Matcher matcherEndTable = endOfTable.matcher(htmlCode.get(i));
if (matcherEndTable.matches()) {
indexOfEnd 
```
<Overlap Ratio: 0.883893280632411>

---

--- 199 --
Question ID: d435c5d4df7f64a11710b7026aabff7141738bd6
Original Code:
```
public class Check implements Report {

    public static Boolean check() {
        File epubFile = new File("D:\\play\\epub\\public\\epub\\epub3.0\\q.epub");
        // simple constructor; errors are printed on stderr stream
        EpubCheck epubcheck = new EpubCheck(epubFile);
        // validate() returns true if no errors or warnings are found
        Boolean result = epubcheck.validate();
        return result;
    }

    @Override
    public void message(MessageId messageId, EPUBLocation epubLocation, Object... objects) {
    }

    @Override
    public void message(Message message, EPUBLocation epubLocation, Object... objects) {
    }

    @Override
    public void info(String s, FeatureEnum featureEnum, String s2) {
    }

    @Override
    public int getErrorCount() {
        return 0;
    }

    @Override
    public int getWarningCount() {
        return 0;
    }

    @Override
    public int getFatalErrorCount() {
        return 0;
    }

    @Override
    public int generate() {
        return 0;
    }

    @Override
    public void initialize() {
    }

    @Override
    public void setEpubFileName(String s) {
    }

    @Override
    public String getEpubFileName() {
        return null;
    }

    @Override
    public void setCustomMessageFile(String s) {
    }

    @Override
    public String getCustomMessageFile() {
        return null;
    }

    @Override
    public int getReportingLevel() {
        return 0;
    }

    @Override
    public void setReportingLevel(int i) {
    }

    @Override
    public void close() {
    }

    @Override
    public void setOverrideFile(File file) {
    }

    @Override
    public MessageDictionary getDictionary() {
        return null;
    }
}

```


Overlapping Code:
```
atic Boolean check() {
File epubFile = new File("D:\\play\\epub\\public\\epub\\epub3.0\\q.epub");
// simple constructor; errors are printed on stderr stream
EpubCheck epubcheck = new EpubCheck(epubFile);
// validate() returns true if no errors or warnings are found
Boolean result = epubcheck.validate();
return result;
}
@Override
public void message(MessageId messageId, EPUBLocation epubLocation, Object... objects) {
}
@Override
public void message(Message message, EPUBLocation epubLocation, Object... objects) {
}
@Override
public void info(String s, FeatureEnum featureEnum, String s2) {
}
@Override
public int getErrorCount() {
return 0;
}
@Override
public int getWarningCount() {
return 0;
}
@Override
public int getFatalErrorCount() {
return 0;
}
@Override
public int generate() {
return 0;
}
@Override
public void initialize() {
}
@Override
public void setEpubFileName(String s) {
}
@Override
public String getEpubFileName() {
return null;
}
@Override
public void setCustomMessageFile(String s) {
}
@Override
public String getCustomMessageFile() {
return null;
}
@Override
public int getReportingLevel() {
return 0;
}
@Override
public void setReportingLevel(int i) {
}
@Override
public void close() {
}
@Override
public void setOverrideFile(File file) {
}
@Override
public MessageDictionar
```
<Overlap Ratio: 0.9393063583815029>

---

--- 200 --
Question ID: f03acb955ac4cb27321bca392b2d1acefa0e597e
Original Code:
```
public class PrivateUrlTest {

    @Test
    public void testProcessLine() throws Exception {
        PropertiesFile propertiesFile = new PropertiesFile("resources/.application.properties");
        String accessKeyId = propertiesFile.getValue("ten-id");
        String accessKeySecret = propertiesFile.getValue("ten-secret");
        String bucket = propertiesFile.getValue("bucket");
        String region = "ap-shanghai";
        PrivateUrl privateUrl = new PrivateUrl(accessKeyId, accessKeySecret, bucket, region, false, 3600, null, "~/Downloads");
        String result = privateUrl.singleResult(new HashMap<String, String>() {

            {
                put("key", "24790f63-0936-44c4-8695-a6d6b1dd8d91.jpg");
            }
        });
        System.out.println(result);
        List<Map<String, String>> mapList = new ArrayList<>();
        mapList.add(new HashMap<String, String>() {

            {
                put("key", "1");
            }
        });
        mapList.add(new HashMap<String, String>() {

            {
                put("key", "2");
            }
        });
        mapList.add(new HashMap<String, String>() {

            {
                put("key", "3");
            }
        });
        privateUrl.processLine(mapList);
        privateUrl.closeResource();
    }
}

```


Overlapping Code:
```
class PrivateUrlTest {
@Test
public void testProcessLine() throws Exception {
PropertiesFile propertiesFile = new PropertiesFile("resources/.application.properties");
String accessKeyId = propertiesFile.getValue("ten-id");
String accessKeySecret = propertiesFile.getValue("ten-secret");
String bucket = propertiesFile.getValue("bucket");
String region = "ap-shanghai";
PrivateUrl privateUrl = new PrivateUrl(accessKeyId, accessKeySecret, bucket, region, false, 3600, null, "~/Downloads");
String result = privateUrl.singleResult(new HashMap<String, Stntln(result);
List<Map<String, String>> mapList = new ArrayList<>();
mapList.add(new HashMap<String, String>()rl.processLine(mapList);
privateUrl.closeResource(
```
<Overlap Ratio: 0.7210953346855984>

---

--- 201 --
Question ID: b73d67eeb7296ad974a93d8acc1f52b681a08a15
Original Code:
```
public class AnnotationTest extends RecognationExtended {

    @Test
    public void testSamePackage() {
        boolean annotationFound = false;
        //		DependencyDTO[] dependencies = service.getDependenciesFrom("annotation.a.SamePackage");
        DependencyDTO[] dependencies = super.getDependenciesFrom("annotation.a.SamePackage");
        for (DependencyDTO dependency : dependencies) {
            if (dependency.type.equals("Annotation")) {
                annotationFound = true;
                assertEquals(5, dependency.lineNumber);
                assertEquals("annotation.a.AnnotationInterface", dependency.to);
            }
        }
        assertEquals(true, annotationFound);
    }

    @Test
    public void testOtherPackageA() {
        boolean annotationFound = false;
        boolean importFound = false;
        //		DependencyDTO[] dependencies = service.getDependenciesFrom("annotation.b.OtherPackageA");
        DependencyDTO[] dependencies = super.getDependenciesFrom("annotation.b.OtherPackageA");
        for (DependencyDTO dependency : dependencies) {
            if (dependency.type.equals("Annotation")) {
                annotationFound = true;
                assertEquals(7, dependency.lineNumber);
                assertEquals("annotation.a.AnnotationInterface", dependency.to);
            } else if (dependency.type.equals("Import")) {
                importFound = true;
                assertEquals(3, dependency.lineNumber);
                assertEquals("annotation.a.AnnotationInterface", dependency.to);
            }
        }
        assertEquals(true, annotationFound);
        assertEquals(true, importFound);
    }

    @Test
    public void testOtherPackageB() {
        boolean annotationFound = false;
        boolean importFound = false;
        //		DependencyDTO[] dependencies = service.getDependenciesFrom("annotation.b.OtherPackageB");
        DependencyDTO[] dependencies = super.getDependenciesFrom("annotation.b.OtherPackageB");
        for (DependencyDTO dependency : dependencies) {
            if (dependency.type.equals("Annotation")) {
                annotationFound = true;
                assertEquals(7, dependency.lineNumber);
                assertEquals("annotation.a.AnnotationInterface", dependency.to);
            } else if (dependency.type.equals("Import")) {
                importFound = true;
                assertEquals(3, dependency.lineNumber);
                assertEquals("annotation.a", dependency.to);
            }
        }
        assertEquals(true, annotationFound);
        assertEquals(true, importFound);
    }

    @Test
    public void testOtherPackageC() {
        boolean annotationFound = false;
        boolean importFound = false;
        //		DependencyDTO[] dependencies = service.getDependenciesFrom("annotation.b.OtherPackageC");
        DependencyDTO[] dependencies = super.getDependenciesFrom("annotation.b.OtherPackageC");
        for (DependencyDTO dependency : dependencies) {
            if (dependency.type.equals("Annotation")) {
                annotationFound = true;
                assertEquals(7, dependency.lineNumber);
                assertEquals("annotation.a.AnnotationInterface", dependency.to);
            } else if (dependency.type.equals("Import")) {
                importFound = true;
                assertEquals(3, dependency.lineNumber);
                assertEquals("annotation.a.AnnotationInterface", dependency.to);
            }
        }
        assertEquals(true, annotationFound);
        assertEquals(true, importFound);
    }
}

```


Overlapping Code:
```
Found = false;
// DependencyDTO[] dependencies = service.getDependenciesFrom("annotation.a.SamePackage");
DependencyDTO[] dependencies = super.getDependenciesFrom("annotation.a.SamePackage");
for (DependencyDTO dependency : dependencies) {
if (dependency.und = true;
assertEquals(5, dependency.lineNumber);
assertEquals("annotation.a.AnnotationInterface", dependency.to);
}
}
assertEquals(true, annotationFounound = false;
boolean importFound = false;
// DependencyDTO[] dependencies = service.getDependenciesFrom("annotation.b.OtherPackageA");
DependencyDTO[] dependencies = super.getDependenciesFrom("annotati;
for (DependencyDTO dependency : dependencies) {
if (dependency.Found = true;
assertEquals(7, dependency.lineNumber);
assertEquals("annotation.a.AnnotationInterface", depmportFound = true;
assertEquals(3, dependency.lineNumber);
assertEquals("annotation.a.AnnotationInterface", dependency.to);
}
}
assertEquals(true, annotationFound);
assertEquals(true, importFound);
}
@Test
public void testOtherPackagound = false;
boolean importFound = false;
// DependencyDTO[] dependencies = service.getDependenciesFrom("annotation.b.OtherPackageB");
DependencyDTO[] dependencies = super.getDependenciesFrom("annotati.OtherPackageB");
for (DependencyDTO dependency : dependencies) {
if (dependency.Found = true;
assertEquals(7, dependency.lineNumber);
assertEquals("annotation.a.AnnotationInterface", depmportFound = true;
assertEquals(3, dependency.lineNumber);
assertEquals("annotation.a
```
<Overlap Ratio: 0.7531613555892767>

---

--- 202 --
Question ID: 9e4f9fdccbf6abd563c47d91d05b945d05d65846
Original Code:
```
class Solution {

    public int fib(int n) {
        int i = 0, j = 1;
        int ans = 1;
        if (n <= 1)
            return n;
        int p = 2;
        while (p <= n) try {
            ans = i + j;
            i = j;
            j = ans;
        } finally {
            p++;
        }
        return ans;
    }
}

```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 203 --
Question ID: cebbdc7523d968d8f24072abc5e1ab3f921ba715
Original Code:
```
public class BinaryInput extends AbstractInput {

    private static final long serialVersionUID = -1467422051075776185L;

    private final HexEdit hexEdit = new HexEdit(new byte[0]);

    // model - byte array
    private byte[] buffer;

    /**
     * Constructor
     */
    public BinaryInput() {
        super();
        setLayout(new GridLayout(1, 1));
        // set focus
        hexEdit.addAncestorListener(new RequestFocusListener());
        add(hexEdit);
    }

    /**
     * Sets value to be edited
     *
     * @param buffer
     */
    public void setValue(byte[] buffer) {
        hexEdit.requestFocusInWindow();
        this.buffer = buffer;
        hexEdit.reset(buffer);
    }

    /**
     * Get edited data
     *
     * @return
     */
    public byte[] getValue() {
        return (buffer);
    }
}

```


Overlapping Code:
```
Input extends AbstractInput {
private static final long serialVersionUID = -146ate final HexEdit hexEdit = new HexEdit(new byte[0yte[] buffer) {
hexEdit.requestFocusInWindow();
th
```
<Overlap Ratio: 0.2779503105590062>

---

--- 204 --
Question ID: 60102b23cb71fa0a9064c2d93835462b9f29e26f
Original Code:
```
public class ZipHelper {

    /**
     * To zip a set of files or directories to an archive:
     */
    public static void zipit(String sourcePath, String targetPath) throws IOException {
        FileOutputStream fos = new FileOutputStream(targetPath);
        ZipOutputStream zipOut = new ZipOutputStream(fos);
        File fileToZip = new File(sourcePath);
        zip(fileToZip, fileToZip.getName(), zipOut);
        zipOut.close();
        fos.close();
    }

    /**
     * To unzip an archive to a target directory
     */
    public static void unzipit(String sourcePath, String targetPath) throws IOException {
        File dir = new File(targetPath);
        if (!dir.exists())
            dir.mkdirs();
        FileInputStream fis = new FileInputStream(sourcePath);
        ZipInputStream zipIn = new ZipInputStream(fis);
        unzip(targetPath, zipIn);
        zipIn.close();
        fis.close();
    }

    private static void zip(File fileToZip, String fileName, ZipOutputStream zipOut) throws IOException {
        if (fileToZip.isHidden()) {
            return;
        }
        if (fileToZip.isDirectory()) {
            File[] files = fileToZip.listFiles();
            for (File file : files) {
                zip(file, fileName + "/" + file.getName(), zipOut);
            }
            return;
        }
        FileInputStream fis = new FileInputStream(fileToZip);
        ZipEntry zipEntry = new ZipEntry(fileName);
        zipOut.putNextEntry(zipEntry);
        byte[] bytes = new byte[1024];
        int length;
        for (; (length = fis.read(bytes)) >= 0; ) {
            zipOut.write(bytes, 0, length);
        }
        fis.close();
    }

    private static void unzip(String targetPath, ZipInputStream zipIn) {
        //buffer for read and write data to file
        byte[] buffer = new byte[1024];
        try {
            ZipEntry ze = zipIn.getNextEntry();
            for (; ze != null; ) {
                String fileName = ze.getName();
                File newFile = new File(targetPath + File.separator + fileName);
                new File(newFile.getParent()).mkdirs();
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                for (; (len = zipIn.read(buffer)) > 0; ) {
                    fos.write(buffer, 0, len);
                }
                fos.close();
                //close this ZipEntry
                zipIn.closeEntry();
                ze = zipIn.getNextEntry();
            }
            //close last ZipEntry
            zipIn.closeEntry();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```


Overlapping Code:
```
 To zip a set of files or directories to an archive:
*/
public static void zipit(String sourcePath, String targetPath) throws IOException {
FileOutputStream fos = new FileOutputStream(targetPath);
ZipOutputStream zipOut = new ZipOutputStream(fos);
File fileToZip = new File(sourcePath);
zip(fileToZip, fileToZip.getName(), zipOut);
zipOut.close();
fos.close();
}
/**
* To unzip an archive to a target directory
*/
public static void unzipit(String sourcePath, String targetPath) throws IOException {
File dir = new File(targetPath);
if (!dir.exists())
dir.mkdirs();
FileInputStream fis = new FileInputStream(sourcePath);
ZipInputStream zipIn = new ZipInputStream(fis);
unzip(targetPath, zipIn);
zipIn.close();
fis.close();
}
private static void zip(File fileToZip, String fileName, ZipOutputStream zipOut) throws IOException {
if (fileToZip.isHidden()) {
return;
}
if (fileToZip.isDirectory()) {
File[] files = fileToZip.listFiles();
for (File file : files) {
zip(file, fileName + "/" + file.getName(), zipOut);
}
return;
}
FileInputStream fis = new FileInputStream(fileToZip);
ZipEntry zipEntry = new ZipEntry(fileName);
zipOut.putNextEntry(zipEntry);
byte[] bytes = new byte[1024];
int length;
) {
zipOut.write(bytes, 0, length);
}
fis.close();
}
private static void unzip(String targetPath, ZipInputStream zipIn) {
//buffer for read and write data to file
byte[] buffer = new byte[1024];
try {
ZipEntry ze = z) {
String fileName = ze.getName();
File newFile = new File(targetPath + File.separator + fileName);
new File(newFile.getParent()).mkdirs();
FileOutputStream fos = new FileOutputStream(newFile);
int len;
.read(buffer)) > 0; ) {
fos.write(buffer, 0, len);
}
fos.close();
//close this ZipEntry
zip
```
<Overlap Ratio: 0.9252032520325203>

---

--- 205 --
Question ID: 51c610d263d838050ce965c17b85338e36da3e55
Original Code:
```
public class MongoLockService implements LockService {

    public static final String MIGRAMONGO_LOCK_COLLECTION = "_migramongo_lock";

    private final MongoDatabase database;

    public MongoLockService(MongoDatabase database) {
        this.database = database;
        initLockCollection();
    }

    private void initLockCollection() {
        //if the table already exists, we do not need to create it anymore
        if (getLockCollection().countDocuments() > 0) {
            return;
        }
        // assuring that the index exists
        getLockCollection().createIndex(new BasicDBObject(LockEntryDocBuilder.LOCK_ENTRY, 1));
        // one already exists, but it's ok
        final Document basicLockEntry = new LockEntryDocBuilder().build();
        getLockCollection().insertOne(basicLockEntry);
    }

    private MongoCollection<Document> getLockCollection() {
        return this.database.getCollection(MIGRAMONGO_LOCK_COLLECTION);
    }

    @Override
    public boolean acquireLock() {
        if (getLockCollection().countDocuments() == 0) {
            throw new IllegalStateException("Cannot acquire lock because lock table has not been initialized. Initialize MongoLockService properly, or call destroyLock");
        }
        final Document lockDocument = new LockEntryDocBuilder().lock().build();
        final Document result = getLockCollection().findOneAndUpdate(new Document(LockEntryDocBuilder.LOCK_ENTRY, true), new Document("$set", lockDocument));
        return result != null && result.getBoolean(LockEntryDocBuilder.LOCKED, true) == false;
    }

    @Override
    public boolean releaseLock() {
        final Document releaseDocument = new LockEntryDocBuilder().release().build();
        final Document result = getLockCollection().findOneAndUpdate(new Document(LockEntryDocBuilder.LOCK_ENTRY, true), new Document("$set", releaseDocument));
        return result != null && result.getBoolean(LockEntryDocBuilder.LOCKED, false) == true;
    }

    static class LockEntryDocBuilder {

        static String LOCK_ENTRY = "lockEntry";

        static String LOCKED = "locked";

        static String LAST_LOCK_DATE = "lastLockDate";

        static String LAST_RELEASE_DATE = "lastReleaseDate";

        private Document doc;

        LockEntryDocBuilder() {
            doc = new Document();
            doc.put(LOCK_ENTRY, true);
            doc.put(LOCKED, false);
        }

        LockEntryDocBuilder lock() {
            doc.put(LOCKED, true);
            doc.put(LAST_LOCK_DATE, new Date());
            return this;
        }

        LockEntryDocBuilder release() {
            doc.put(LOCKED, false);
            doc.put(LAST_RELEASE_DATE, new Date());
            return this;
        }

        Document build() {
            return doc;
        }
    }

    @Override
    public LockEntry getLockInformation() {
        final Document lockDocument = getLockCollection().find(new Document(LockEntryDocBuilder.LOCK_ENTRY, true)).first();
        return new LockEntry(lockDocument.getBoolean(LockEntryDocBuilder.LOCKED), lockDocument.getDate(LockEntryDocBuilder.LAST_LOCK_DATE), lockDocument.getDate(LockEntryDocBuilder.LAST_RELEASE_DATE));
    }

    @Override
    public void destroyLock() {
        getLockCollection().deleteMany(new Document(LockEntryDocBuilder.LOCK_ENTRY, true));
        initLockCollection();
    }
}

```


Overlapping Code:
```
ngoLockService implements LockService {
public static final String MIGRAMONGO_LOCK_COLLECTION = "_migramongo_lock";
private final MongoDatabase database;
public MongoLockService(MongoDatabase database) {
this.database = database;
initLockCollection();
}
private void initLockCollection() {
//if the table already exists, we do not need to create it anymore
if (getLockCollection().countDocuments() > 0) {
return;
}
// assuring that the index exists
getLockCollection().createIndex(new BasicDBObject(Locument basicLockEntry = new LockEntryDocBuilder().build();
getLockCollection().insertOne(basicLockEntry);
}
private MongoCollection<Document> getLockCollection() {
return this.database.getCollection(MIGRAMONGO_LOCK_COLLECTION);
}
@Override
public boolean acquireLock() {
if (getLockCollection().countDocuments() == 0) {
throw new IllegalStateException("Cannot acquire t been initialized. Initialize MongoLockService properly, or call destroyLock");
}
final Document lockDocument = new LockEntryDocBuilder().lock().builfindOneAndUpdate(new Document(LockEntryDocBuilder.LOCK_ENTRY, true), new Document("$set", lockDocument));
return result != null && result.getBoolean(LockEntryDocBuilder.LOCKED, true) == false;
}
@Override
public boolean releaseLock() {
final Document releaseDocument = new LockEntryDocBuilder().release().build();
final Document result = getLockCollefindOneAndUpdate(new Document(LockEntryDocBuilder.eleaseDocument));
return result != null && result.getBoolean(LockEntryDocBuilder.LOCKED, false) == true;
}
static class LockEntryDocBuilder {
static String LOCK_ENTRY = "lockEntry";
static String LOCKED = "locked";
static String LAST_LOCK_DATE = "lastLockDate";
static String LAST_RELEASE_DATE = "lastReleaseDate";
private Document doc;
LockEntryDocBuilder() {
doc = new Document();
doc.put(LOCK_ENTRY, true);
doc.put(LOCKED, false);
}
LockEntryDocBu
```
<Overlap Ratio: 0.8787023977433004>

---

--- 206 --
Question ID: ffa598d57403bf725a49c67af6e7b5b8fddbdb6f
Original Code:
```
public final class BoruvkaMST {

    public static <T, E extends DirectedEdge<T, E> & Comparable<? super E>> EdgeList<E> compute(int vertices, Iterable<E> edges) {
        ArrayList<ContractedEdge<T, E>> wrapper = new ArrayList<>();
        for (E e : edges) wrapper.add(new ContractedEdge<>(e));
        return recurse(vertices, wrapper);
    }

    private static <T, E extends DirectedEdge<T, E> & Comparable<? super E>> EdgeList<E> recurse(int vertices, Iterable<ContractedEdge<T, E>> edges) {
        if (vertices < 2)
            return new EdgeList<>();
        Set<ContractedEdge<T, E>> forestEdges = Graphs.lightestEdgePerVertex(vertices, edges);
        Graph<ContractedEdge<T, ContractedEdge<T, E>>> contracted = Graphs.contract(vertices, forestEdges, edges);
        EdgeList<ContractedEdge<T, E>> contractedEdges = Graphs.flatten(contracted.edges);
        // extract original edges
        EdgeList<E> markedEdges = new EdgeList<>();
        forestEdges.stream().map(e -> e.original).forEach(markedEdges::append);
        markedEdges.meld(recurse(contracted.vertices, contractedEdges));
        return markedEdges;
    }
}

```


Overlapping Code:
```
s BoruvkaMST {
public static <T, E extends DirectedEdge<T, E> & Comparable<? super E>> EdgeList<E> compute(int vertices, Iterable<E> edges) {
ArrayList<ContractedEdge<T, E>> wrapper = new ArrayList<>(e<>(e));
return recurse(vertices, wrapper);
}
private static <T, E extends DirectedEdge<T, E> & Comparable<? supers, Iterable<ContractedEdge<T, E>> edges) {
if (vertices < 2)
return new EdgeList<>();
Set<ContractedEdge<T, E>> forestEdges = Graphs.lightestEdgePerVertex(vertices, edges);
Graph<ContractedEdge<T, ContractedEdge<T, E>>> contracted = Graphs.contract(vertices, forestEdges, edges);
EdgeList<ContractedEdge<T, E>> contractedEdges = Graphs.flatten(contracted.edges);
// extract original edges
EdgeList<E> markedEdges = new EdgeList<>();
forestEdges.stream().map(e -> e.original).forEach(markedEdges::append);
markedEdges.meld(recurse(contracted.vertices, contractedEdges));
return markedEdges;
```
<Overlap Ratio: 0.8940594059405941>

---

--- 207 --
Question ID: 13ff8592e8c99706938dc8f4175004a0e584dad8
Original Code:
```
@Controller
public class IndexEditController {

    /**
     * Helper class used as form backing object
     */
    public static final class FormBackingObject {

        private String catalog;

        private String schema;

        private String object;

        private String name;

        private boolean unique;

        private final Map<Integer, String> columns;

        /**
         * Constructor
         */
        public FormBackingObject() {
            this.columns = new TreeMap<Integer, String>();
        }

        /**
         * Get the column names
         * @return column names
         */
        public List<String> getColumnNames() {
            final List<String> ret = new ArrayList<String>(columns.size());
            int i = 0;
            while (true) try {
                final String s = columns.get(i);
                if (StringUtils.empty(s))
                    break;
                ret.add(s);
            } finally {
                i++;
            }
            return (ret);
        }

        /**
         * @return the catalog
         */
        public String getCatalog() {
            return catalog;
        }

        /**
         * @param catalog the catalog to set
         */
        public void setCatalog(String catalog) {
            this.catalog = catalog;
        }

        /**
         * @return the schema
         */
        public String getSchema() {
            return schema;
        }

        /**
         * @param schema the schema to set
         */
        public void setSchema(String schema) {
            this.schema = schema;
        }

        /**
         * @return the object
         */
        public String getObject() {
            return object;
        }

        /**
         * @param object the object to set
         */
        public void setObject(String object) {
            this.object = object;
        }

        /**
         * @return the name
         */
        public String getName() {
            return name;
        }

        /**
         * @param name the name to set
         */
        public void setName(String name) {
            this.name = name;
        }

        /**
         * @return the unique
         */
        public boolean isUnique() {
            return unique;
        }

        /**
         * @param unique the unique to set
         */
        public void setUnique(boolean unique) {
            this.unique = unique;
        }

        /**
         * @return the columns
         */
        public Map<Integer, String> getColumns() {
            return columns;
        }
    }

    private final MetadataService metadataService;

    private final QuerySettingsManager querySettingsManager;

    private final QueryPerformerService runner;

    private final QueryGeneratorService queryGeneratorService;

    private final ConnectionSettings connectionSettings;

    private final FrontendHelperService frontendHelperService;

    /**
     * Constructor
     * @param metadataService MetadataService
     * @param querySettingsManager QuerySettingsManager
     * @param runner QueryPerformerService
     * @param queryGeneratorService QueryGeneratorService
     * @param connectionSettings ConnectionSettings
     * @param frontendHelperService FrontendHelperService
     */
    @Autowired
    public IndexEditController(MetadataService metadataService, QuerySettingsManager querySettingsManager, QueryPerformerService runner, QueryGeneratorService queryGeneratorService, ConnectionSettings connectionSettings, FrontendHelperService frontendHelperService) {
        this.metadataService = metadataService;
        this.querySettingsManager = querySettingsManager;
        this.runner = runner;
        this.queryGeneratorService = queryGeneratorService;
        this.connectionSettings = connectionSettings;
        this.frontendHelperService = frontendHelperService;
    }

    /**
     * Get the FormBackingObject
     * @param obj DB object name
     * @return FormBackingObject
     */
    @ModelAttribute("model")
    public FormBackingObject getFormBackingObject(@RequestParam(value = "q", required = false) String obj) {
        final FormBackingObject fbo = new FormBackingObject();
        // Hack to recognize object name in "q" as well as "object" parameter
        fbo.setObject(obj);
        int i = 0;
        while (i < 10) try {
            fbo.getColumns().put(i, "");
        } finally {
            i++;
        }
        return (fbo);
    }

    /**
     * Show a parameter input form
     * @param fbo FormBackingObject
     * @return Model
     */
    @RequestMapping(value = "/db/*/ajax/ddl-add-index.html", method = RequestMethod.GET)
    public Map<String, Object> showInsertDialog(@ModelAttribute("model") FormBackingObject fbo) {
        if (!connectionSettings.isBrowserEnabled())
            throw new AccessDeniedException();
        if (!connectionSettings.isWritable())
            throw new AccessDeniedException();
        final Map<String, Object> model = new HashMap<String, Object>();
        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());
        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);
        model.put("columns", info.getColumns());
        return (model);
    }

    /**
     * Show a parameter input form
     * @param fbo FormBackingObject
     * @return Model
     */
    @RequestMapping(value = "/db/*/ddl-add-index.html", method = RequestMethod.POST)
    public Map<String, Object> performInsertQuery(@ModelAttribute("model") FormBackingObject fbo) {
        if (!connectionSettings.isBrowserEnabled())
            throw new AccessDeniedException();
        if (!connectionSettings.isWritable())
            throw new AccessDeniedException();
        final Map<String, Object> model = new HashMap<String, Object>();
        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());
        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);
        final IndexDescription id = new IndexDescription(fbo.getName(), fbo.isUnique(), fbo.getColumnNames());
        final Query q = queryGeneratorService.createAddIndexQuery(info, getSQLDialect(), id);
        final QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());
        try {
            final Result r = runner.performQuery(connectionSettings.getLinkName(), query);
            metadataService.flushCache(connectionSettings.getLinkName());
            model.put("result", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));
            model.put("exceptionText", null);
        } catch (PerformQueryException e) {
            model.put("exceptionText", frontendHelperService.toJSONString(e.getMessage()));
        }
        return (model);
    }

    /**
     * Show a parameter input form
     * @param fbo FormBackingObject
     * @return Model
     */
    @RequestMapping(value = "/db/*/ajax/ddl-drop-index.html", method = RequestMethod.GET)
    public Map<String, Object> showDeleteDialog(@ModelAttribute("model") FormBackingObject fbo) {
        if (!connectionSettings.isBrowserEnabled())
            throw new AccessDeniedException();
        if (!connectionSettings.isWritable())
            throw new AccessDeniedException();
        final Map<String, Object> model = new HashMap<String, Object>();
        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());
        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);
        final IndexDescription id = info.getIndex(fbo.getName());
        fbo.setUnique(id.isUnique());
        int i = 0;
        for (String c : id.getColumns()) fbo.getColumns().put(i++, c);
        return (model);
    }

    /**
     * Show a parameter input form
     * @param fbo FormBackingObject
     * @return Model
     */
    @RequestMapping(value = "/db/*/ddl-drop-index.html", method = RequestMethod.POST)
    public Map<String, Object> performDeleteQuery(@ModelAttribute("model") FormBackingObject fbo) {
        if (!connectionSettings.isBrowserEnabled())
            throw new AccessDeniedException();
        if (!connectionSettings.isWritable())
            throw new AccessDeniedException();
        final Map<String, Object> model = new HashMap<String, Object>();
        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());
        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);
        final IndexDescription id = info.getIndex(fbo.getName());
        final Query q = queryGeneratorService.createDropIndexQuery(info, getSQLDialect(), id);
        final QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());
        try {
            final Result r = runner.performQuery(connectionSettings.getLinkName(), query);
            metadataService.flushCache(connectionSettings.getLinkName());
            model.put("result", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));
            model.put("exceptionText", null);
        } catch (PerformQueryException e) {
            model.put("exceptionText", frontendHelperService.toJSONString(e.getMessage()));
        }
        return (model);
    }

    /**
     * Show a parameter input form
     * @param fbo FormBackingObject
     * @return Model
     */
    @RequestMapping(value = "/db/*/ajax/ddl-add-primarykey.html", method = RequestMethod.GET)
    public Map<String, Object> showPKInsertDialog(@ModelAttribute("model") FormBackingObject fbo) {
        if (!connectionSettings.isBrowserEnabled())
            throw new AccessDeniedException();
        if (!connectionSettings.isWritable())
            throw new AccessDeniedException();
        final Map<String, Object> model = new HashMap<String, Object>();
        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());
        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);
        model.put("columns", info.getColumns());
        return (model);
    }

    /**
     * Show a parameter input form
     * @param fbo FormBackingObject
     * @return Model
     */
    @RequestMapping(value = "/db/*/ddl-add-primarykey.html", method = RequestMethod.POST)
    public Map<String, Object> performPKInsertQuery(@ModelAttribute("model") FormBackingObject fbo) {
        if (!connectionSettings.isBrowserEnabled())
            throw new AccessDeniedException();
        if (!connectionSettings.isWritable())
            throw new AccessDeniedException();
        final Map<String, Object> model = new HashMap<String, Object>();
        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());
        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);
        final PrimaryKeyDescription pk = new PrimaryKeyDescription(fbo.getName(), fbo.getColumnNames());
        final Query q = queryGeneratorService.createAddPrimaryKeyQuery(info, getSQLDialect(), pk);
        final QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());
        try {
            final Result r = runner.performQuery(connectionSettings.getLinkName(), query);
            metadataService.flushCache(connectionSettings.getLinkName());
            model.put("result", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));
            model.put("exceptionText", null);
        } catch (PerformQueryException e) {
            model.put("exceptionText", frontendHelperService.toJSONString(e.getMessage()));
        }
        return (model);
    }

    /**
     * Show a parameter input form
     * @param fbo FormBackingObject
     * @return Model
     */
    @RequestMapping(value = "/db/*/ajax/ddl-drop-primarykey.html", method = RequestMethod.GET)
    public Map<String, Object> showPKDeleteDialog(@ModelAttribute("model") FormBackingObject fbo) {
        if (!connectionSettings.isBrowserEnabled())
            throw new AccessDeniedException();
        if (!connectionSettings.isWritable())
            throw new AccessDeniedException();
        final Map<String, Object> model = new HashMap<String, Object>();
        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());
        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);
        final PrimaryKeyDescription pk = info.getPrimaryKey();
        fbo.setUnique(pk.isUnique());
        int i = 0;
        for (String c : pk.getColumns()) fbo.getColumns().put(i++, c);
        return (model);
    }

    /**
     * Show a parameter input form
     * @param fbo FormBackingObject
     * @return Model
     */
    @RequestMapping(value = "/db/*/ddl-drop-primarykey.html", method = RequestMethod.POST)
    public Map<String, Object> performPKDeleteQuery(@ModelAttribute("model") FormBackingObject fbo) {
        if (!connectionSettings.isBrowserEnabled())
            throw new AccessDeniedException();
        if (!connectionSettings.isWritable())
            throw new AccessDeniedException();
        final Map<String, Object> model = new HashMap<String, Object>();
        final QualifiedName qname = new QualifiedName(fbo.getCatalog(), fbo.getSchema(), fbo.getObject());
        final TableDescription info = metadataService.getTableInfo(connectionSettings.getLinkName(), qname, ColumnMode.ALL);
        final PrimaryKeyDescription pk = info.getPrimaryKey();
        final Query q = queryGeneratorService.createDropPrimaryKeyQuery(info, getSQLDialect(), pk);
        final QueryParameters query = querySettingsManager.prepareParameters(q, Collections.<Integer, String>emptyMap());
        try {
            final Result r = runner.performQuery(connectionSettings.getLinkName(), query);
            metadataService.flushCache(connectionSettings.getLinkName());
            model.put("result", frontendHelperService.toJSONString(String.valueOf(r.getFirstRowSet().getFirstValue())));
            model.put("exceptionText", null);
        } catch (PerformQueryException e) {
            model.put("exceptionText", frontendHelperService.toJSONString(e.getMessage()));
        }
        return (model);
    }

    private SQLDialect getSQLDialect() {
        return (SQLDialectFactory.getSQLDialect(connectionSettings.getDialectName()));
    }
}

```


Overlapping Code:
```

/**
* Helper class used as form backing object
*/
public static final class FormBackingObje {
private String catalog;
private String schema;
private String object;
private String name;
private boolean unique;
private final Map<Integer, String> column names
* @return column names
*/
public List<String> getColumnNames() {
final List<String> ret = new ArrayList<String>(;
}
/**
* @return the catalog
*/
public String getCatalog() {
return catalog;
}
/**
* @param catalog the catalog to set
*/
public void setCatalog(String catalog) {
this.catalog = catalog;
}
/**
* @return the schema
*/
public String getSchema() {
return schema;
}
/**
* @param schema the schema to set
*/
public void setSchema(String schema) {
this.schema = schema;
}
/**
* @return the object
*/
public String getObject() {
return object;
}
/**
* @param object the object to set
*/
public void setObject(String object) {
this.object = object;
}
/**
* @return the name
*/
public String getName() {
return name;
}
/**
* @param name the name to set
*/
public void setName(String name) {
this.name = name;
}
/**
* @return the unique
*/
public boolean isUnique() {
return unique;
}
/**
* @param unique the unique to set
*/
public void setUnique(boolean unique) {
this.unique = unique;
}
/**
* @return the
```
<Overlap Ratio: 0.795483061480552>

---

--- 208 --
Question ID: d337b228a1e219df9c9fd234cc3062ebe9e0e205
Original Code:
```
public class InMemoryBulkDataSorterTest {

    @Rule
    public TemporaryFolder tempFolder = new TemporaryFolder();

    /* A counter of tuple files */
    private int counter = 0;

    private Comparator<Tuple<Integer, Integer>> tupleComp = new Comparator<Tuple<Integer, Integer>>() {

        @Override
        public int compare(Tuple<Integer, Integer> o1, Tuple<Integer, Integer> o2) {
            return o1.getKey().compareTo(o2.getKey());
        }
    };

    @Test
    public void testSortedFileCount() throws IOException {
        int count = 7;
        IntTupleReaderWriter itrw = new IntTupleReaderWriter();
        Random random = new Random();
        File dataFile = tempFolder.newFile("tuple.data");
        dataFile.deleteOnExit();
        DataOutputStream out = new DataOutputStream(new FileOutputStream(dataFile));
        Tuple<Integer, Integer>[] arr = (Tuple<Integer, Integer>[]) Array.newInstance(Tuple.class, count);
        int i = 0;
        while (i < count) try {
            int x = random.nextInt(100);
            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>(x, x);
            arr[i] = t;
            itrw.storeSortedTuple(t, out);
        } finally {
            i++;
        }
        out.close();
        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>(itrw, tupleComp, 4);
        bds.sort(dataFile);
        assertEquals(2, bds.getWorkDir().list().length);
        deleteDir(bds.getWorkDir());
    }

    @Test
    public void testSortedFileMerge() throws IOException {
        testSortedFileMerge(10, 2);
        testSortedFileMerge(100, 7);
        testSortedFileMerge(1000, 25);
        testSortedFileMerge(10000, 100);
        testSortedFileMerge(10000, 101);
        testSortedFileMerge(100000, 501);
    }

    private void testSortedFileMerge(int count, int splitAfter) throws IOException {
        IntTupleReaderWriter itrw = new IntTupleReaderWriter();
        Random random = new Random();
        File dataFile = tempFolder.newFile("tuple.data" + counter);
        counter++;
        dataFile.deleteOnExit();
        DataOutputStream out = new DataOutputStream(new FileOutputStream(dataFile));
        Tuple<Integer, Integer>[] arr = (Tuple<Integer, Integer>[]) Array.newInstance(Tuple.class, count);
        int randUpper = count;
        if (count < 100) {
            randUpper = 100;
        }
        int i = 0;
        while (i < count) try {
            int x = random.nextInt(randUpper);
            Tuple<Integer, Integer> t = new Tuple<Integer, Integer>(x, x);
            arr[i] = t;
            itrw.storeSortedTuple(t, out);
        } finally {
            i++;
        }
        out.close();
        BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>(itrw, tupleComp, splitAfter);
        bds.sort(dataFile);
        Iterator<Tuple<Integer, Integer>> itr = bds.getMergeSortedTuples();
        Integer prev = null;
        while (itr.hasNext()) {
            Tuple<Integer, Integer> t = itr.next();
            if (prev == null) {
                prev = t.getKey();
            } else {
                assertTrue(prev <= t.getKey());
            }
        }
        deleteDir(bds.getWorkDir());
    }

    private void deleteDir(File dir) {
        if (dir.isFile()) {
            dir.delete();
        }
        File[] files = dir.listFiles();
        for (File f : files) {
            f.delete();
        }
        dir.delete();
    }
}

```


Overlapping Code:
```
erTest {
@Rule
public TemporaryFolder tempFolder = new TemporaryFolder();
/*te int counter = 0;
private Comparator<Tuple<Integer, Integer>> tupleComp = new Comparator<Tuple<Integer, Integer>>() {
@Override
public int compare(Tuple<Integer, Integer> o1, Tuple<Integer, Integer> o2) {
return o1.getKey().compareTo(o2.getKey());
}
};riter itrw = new IntTupleReaderWriter();
Random random = new Random();
File dataFile = tempFolder.nenExit();
DataOutputStream out = new DataOutputStream(new FileOutputStream(uple<Integer, Integer> t = new Tuple<Integer, Integer>();
BulkDataSorter<Integer, Integer> bds = new BulkDataSorter<Integer, Integer>(riter itrw = new IntTupleReaderWriter();
Random random = new Random();
File dataFile = tempFolder.nenExit();
DataOutputStream out = new DataOutputStream(new FileOutputStream(
```
<Overlap Ratio: 0.3988212180746562>

---

--- 209 --
Question ID: e8e3c4b4e355e51e7e75ddb9456fe63248f39294
Original Code:
```
public class ModifiableHToolbar extends BasicHToolbar {

    protected final HBox modifyMLeftSection = new HBox();

    protected final HBox modifyMCenterSection = new HBox();

    protected final HBox modifyMRightSection = new HBox();

    protected final HBox modifyingActionsWrapper = new HBox();

    protected final Button modifyButton = new Button();

    protected final Button doneButton = new Button();

    /**
     * Constructor
     */
    public ModifiableHToolbar() {
        super();
        NodeHelper.setHgrow(allOverWrapper);
        modifyingActionsWrapper.getStyleClass().add("ep-modifying-toolbar");
        rootContainer.getStyleClass().add("ep-modifiable-toolbar");
        modifyMLeftSection.getStyleClass().add("ep-modifying-toolbar-left");
        modifyMCenterSection.getStyleClass().add("ep-modifying-toolbar-center");
        modifyMRightSection.getStyleClass().add("ep-modifying-toolbar-right");
    }

    /**
     * @{inheritedDoc}
     */
    @Override
    public void buildFrom(AbstractViewController controller, IToolbarHolder toolbarHolder) {
        super.buildFrom(controller, toolbarHolder);
        buildModifyActions();
        final String styleClass = configuration.getPropertyValue("modifyingActionsStyleClass");
        if (io.github.jsoagger.core.utils.StringUtils.isNotBlank(styleClass)) {
            modifyingActionsWrapper.getStyleClass().addAll(styleClass.split(","));
        }
    }

    /**
     * Modify menu configuration is menu displayed when the user clicked on modify button on the
     * displayed toolbar.
     * <p>
     * If no modify menu is provided, the modify button is not displayed.
     * <p>
     */
    private void buildModifyActions() {
        if (modifyMenuConfiguration != null) {
            // build left side actions
            final VLViewComponentXML leftActions = modifyMenuConfiguration.getComponentById("LeftActions").orElse(null);
            if (leftActions != null) {
                final List<IBuildable> buildables = buildActionGroup(leftActions);
                for (IBuildable node : buildables) {
                    modifyMLeftSection.getChildren().add(node.getDisplay());
                }
                modifyingActionsWrapper.getChildren().addAll(modifyMLeftSection);
            }
            // build center actions
            final VLViewComponentXML centerActions = modifyMenuConfiguration.getComponentById("CenterActions").orElse(null);
            if (centerActions != null) {
                final List<IBuildable> buildables = buildActionGroup(centerActions);
                for (IBuildable node : buildables) {
                    modifyMCenterSection.getChildren().add(node.getDisplay());
                }
                if (modifyingActionsWrapper.getChildren().size() > 0) {
                    modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer());
                }
                modifyingActionsWrapper.getChildren().addAll(modifyMCenterSection);
            }
            final VLViewComponentXML rightActions = modifyMenuConfiguration.getComponentById("RightActions").orElse(null);
            if (rightActions != null) {
                final List<IBuildable> buildables = buildActionGroup(rightActions);
                for (IBuildable node : buildables) {
                    modifyMRightSection.getChildren().add(node.getDisplay());
                }
                if (modifyingActionsWrapper.getChildren().size() > 0) {
                    modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer());
                }
                modifyingActionsWrapper.getChildren().addAll(modifyMRightSection);
            }
        }
        allOverWrapper.visibleProperty().bind(Bindings.not(((IModifiableToolbarHolder) toolbarHolder).modifyingProperty()));
        allOverWrapper.managedProperty().bind(allOverWrapper.visibleProperty());
        buildModifyButton();
        buildDoneButton();
    }

    /**
     * Build the modify button.
     */
    private void buildModifyButton() {
        modifyButton.getStyleClass().addAll("table-toolbar-action", "ep-button");
        modifyButton.setOnAction(e -> modifyClicked(controller));
        modifyButton.setText(controller.getGLocalised("EDIT_LABEL").toUpperCase());
        IconUtils.setFontIcon("gmi-more-horiz:18", modifyButton);
        allOverWrapper.getChildren().add(modifyButton);
        if (selectable.get()) {
        }
        NodeHelper.setHgrow(modifyingActionsWrapper);
        modifyingActionsWrapper.visibleProperty().bind(((IModifiableToolbarHolder) toolbarHolder).modifyingProperty());
        modifyingActionsWrapper.managedProperty().bind(modifyingActionsWrapper.visibleProperty());
        rootContainer.getChildren().add(modifyingActionsWrapper);
    }

    /**
     * Build done button
     */
    private void buildDoneButton() {
        doneButton.getStyleClass().addAll("button-small", "table-toolbar-action", "ep-button");
        doneButton.setOnAction(e -> modifyClicked(controller));
        doneButton.setText(controller.getGLocalised("DONE_LABEL").toUpperCase());
        IconUtils.setFontIcon("fa-check:16", doneButton);
        modifyingActionsWrapper.getChildren().addAll(NodeHelper.horizontalSpacer(), doneButton);
    }

    /**
     * @param controller
     */
    protected void modifyClicked(AbstractViewController controller) {
        if (!((IModifiableToolbarHolder) toolbarHolder).isModifying()) {
            thickButton.setSelected(false);
            ((IModifiableToolbarHolder) toolbarHolder).setModifying(true);
            // show all selectors
            ((IModifiableToolbarHolder) toolbarHolder).modify();
            // reinit thick button
            isThicked = true;
            thickClicked();
        } else {
            ((IModifiableToolbarHolder) toolbarHolder).setModifying(false);
            // hide all selectors
            ((IModifiableToolbarHolder) toolbarHolder).cancelModify();
        }
    }

    /**
     * Called when a checkbox or a listcell is clicked.
     */
    public void listCellSelected() {
        isThicked = false;
        thickButton.setSelected(false);
    }
}

```


Overlapping Code:
```
ic class ModifiableHToolbar extends BasicHToolbar {
protected final HBox modifyMLeftSection = new HBox();
protected final HBox modifyMCenterSection = new HBox();
protected final HBox modifyMRightSection = new HBox();
protected final HBox modifyingActionsWrapper = new HBox();
protected final Button modifyButton = new Button();
protected final Button doneButton = new Button();
/**
* Constructor
*/
public ModifiableHToolbar() {
super();
NodeHelper.setHgrow(allOverWrapper);
modifyingActionsWrapper.getStyleClass().add("ep-modifying-toolbar");
rootContainer.getStyleClass().add("ep-modifiable-toolbar");
modifyMLeftSection.getStyleClass().add("ep-modifying-toolbar-left");
modifyMCenterSection.getStyleClass().add("ep-modifying-toolbar-center");
modifyMRightSection.getStyleClass().add("ep-modifying-toolbar-right");
}
/**
* @{inheritedDoc}
*/
@Override
public void buildFrom(AbstractViewController controller, IToolbarHolder toolbarHolder) {
super.buildFrom(controller, toolbarHolder);
buildModifyActions();
final String styleClass = configuration.getPropertyValue("modifyingActionsStyleClass");
if (io.github.jsoagger.core.utils.StringUtils.isNotBlank(styleClass)) {
modifyingActionsWrapper.getStyleClass().addAll(styleClass.split(","));
}
}
/**
* Modify menu configuration is menu displayed when the user clicked on modify button on the
* displayed toolbar.
* <p>
* If no modify menu is provided, the modify button is not displayed.
* <p>
*/
private void buildModifyActions() {
if (modifyMenuConfiguration != null) {
// build left side actions
final VLViewComponentXML leftActions = modifyMenuConfiguration.getComponentById("LeftActions").orElse(null);
if (leftActions != null) {
final List<IBuildable> buildables = buildActionGroup(leftActions);
for (IBuildable ion.getChildren().add(node.getDisplay());
}
modifyingActionsWrapper.getChildren().addAll(modifyMLeftSection);
}
// build center actions
final VLViewComponentXML centerActions = modifyMenuConfiguration.getComponentById("CenterActions").orElse(null);
i
```
<Overlap Ratio: 0.9678348535765723>

---

--- 210 --
Question ID: 411be56df51eee3c16dfe6b0f35455330e5f8f63
Original Code:
```
public final class DnsUtil {

    private static final Logger logger = LoggerFactory.getLogger(DnsUtil.class);

    /**
     * Returns {@code true} if any {@link NetworkInterface} supports {@code IPv6}, {@code false} otherwise.
     */
    public static boolean anyInterfaceSupportsIpV6() {
        try {
            final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
            for (; interfaces.hasMoreElements(); ) {
                final NetworkInterface iface = interfaces.nextElement();
                final Enumeration<InetAddress> addresses = iface.getInetAddresses();
                for (; addresses.hasMoreElements(); ) {
                    final InetAddress inetAddress = addresses.nextElement();
                    if (inetAddress instanceof Inet6Address && !inetAddress.isAnyLocalAddress() && !inetAddress.isLoopbackAddress() && !inetAddress.isLinkLocalAddress()) {
                        return true;
                    }
                }
            }
        } catch (SocketException e) {
            logger.debug("Unable to detect if any interface supports IPv6, assuming IPv4-only", e);
        }
        return false;
    }

    @Nullable
    public static byte[] extractAddressBytes(DnsRecord record, Logger logger, String logPrefix) {
        final DnsRecordType type = record.type();
        final ByteBuf content = ((ByteBufHolder) record).content();
        final int contentLen = content.readableBytes();
        // Skip invalid records.
        if (type == DnsRecordType.A) {
            if (contentLen != 4) {
                warnInvalidRecord(logger, logPrefix, type, content);
                return null;
            }
        } else if (type == DnsRecordType.AAAA) {
            if (contentLen != 16) {
                warnInvalidRecord(logger, logPrefix, type, content);
                return null;
            }
        } else {
            return null;
        }
        final byte[] addrBytes = new byte[contentLen];
        content.getBytes(content.readerIndex(), addrBytes);
        return addrBytes;
    }

    /**
     * Logs a warning message about an invalid record.
     */
    public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordType type, ByteBuf content) {
        if (logger.isWarnEnabled()) {
            final String dump = ByteBufUtil.hexDump(content);
            logger.warn("{} Skipping invalid {} record: {}", logPrefix, type.name(), dump.isEmpty() ? "<empty>" : dump);
        }
    }

    private DnsUtil() {
    }
}

```


Overlapping Code:
```
sUtil {
private static final Logger logger = LoggerFactory.getLogger(DnsUtil.class);
/**
* Returns {@code true} if any {@link NetworkInterface} supports {@code IPv6}, {@code false} otherwise.
*/
public static boolean anyInterfaceSupportsIpV6() {
try {
final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
for (;erfaces.hasMoreElements(); ) {
final NetworkInterface iface = interfaces.nextElement();
final Enumeration<InetAddress> addresses = iface.getInetAddresses();
addresses.hasMoreElements(); ) {
final InetAddress inetAddress = addresses.nextElement();
if (inetAddress instanceof Inet6Address && !inetAddress.isAnyLocalAddress() && !inetAddress.isLoopbackAddress() && !inetAddress.isLinkLocalAddress()) {
return true;
}
}
}
} catch (SocketException e) {
logger.debug("Unable to detect if any interface supports IPv6, assuming IPv4-only", e);
}
return false;
}
@Nullable
public static byte[] extractAddressBytes(DnsRecord record, Logger logger, String logPrefix) {
final DnsRecordType type = record.type();
final ByteBuf content = ((ByteBufHolder) record).content();
final int contentLen = content.readableBytes();
// Skip invalid records.
if (type == DnsRecordType.A) {
if (contentLen != 4) {
warnInvalidRecord(logger, logPrefix, type, content);
return null;
}
} else if (type == DnsRecordType.AAAA) {
if (contentLen != 16) {
warnInvalidRecord(logger, logPrefix, type, content);
return null;
}
} else {
return null;
}
final byte[] addrBytes = new byte[contentLen];
content.getBytes(content.readerIndex(), addrBytes);
return addrBytes;
}
/**
* Logs a warning message about an invalid record.
*/
public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordType type, ByteBuf content) {
if (logger.isWarnEnabled()) {
final String dump = ByteBufUtil.hexDump(content);
logger.warn("{} Skipping invalid {} r
```
<Overlap Ratio: 0.9475826972010178>

---

--- 211 --
Question ID: 2d088d08cd730611273367ea147d60a48850ecf1
Original Code:
```
public final class ResourceLoader {

    static ObjectMapper om;

    static {
        om = new ObjectMapper();
        om = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false).enable(SerializationFeature.INDENT_OUTPUT);
        om.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        om.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);
        om.registerModule(new JavaTimeModule());
        om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    }

    public static String load(String resourceName) {
        try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName)) {
            return IOUtils.toString(is, StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static String loadGitlabFile(String resourceName) {
        String loaded = load(resourceName);
        GitlabFile file = GitlabFile.builder().content(loaded).filePath("engagement.json").build();
        file.encodeFileAttributes();
        try {
            return om.writeValueAsString(file);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        return null;
    }
}

```


Overlapping Code:
```
esourceLoader {
static ObjectMapper om;
static {
om = new ObjectMapper();
om = new ObjectMapper().configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false).alizationFeature.INDENT_OUTPUT);
om.setSerializationInclusion(JsonInclude.Include.NON_NULL);
om.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);
om.registerModule(new JavaTimeModule());
om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
}
public static String load(String resourceName) {
try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourceName)) {
return IOUtils.toString(is, StandardCharsets.UTF_8);
} catch (IOException e) {
throw new RuntimeException(e);
}
}
public static String loadGitlabFile(String resourceName) {
String loaded = load(resourceName);
GitlabFile file = GitlabFile.builder().content(loaded).filePath("engagement.json").build();
file.encodeFileAttributes();
try {
return om.writeValueAsString(file);
} catch (JsonProcessingException e) {
e.printStackTrace();
}
return null;
}
}
```
<Overlap Ratio: 0.9708646616541353>

---

--- 212 --
Question ID: f7522f424ae92b2a0db7550cedd1e41327b08448
Original Code:
```
public class Pokemon {

    //atributos
    private String nome;

    private String tipo;

    //n?o esquecer de colocar o f (0.5f, 14.6f)
    private float peso;

    private float altura;

    private int felicidade;

    private int chanceDeCaptura;

    private boolean capturado;

    //metodo status atual
    public void statusAtual() {
        System.out.println("------------------------");
        System.out.println("Nome: " + this.getNome());
        System.out.println("Tipo: " + this.getTipo());
        System.out.println("Peso " + this.getPeso());
        System.out.println("Altura: " + this.getAltura());
        System.out.println("Felicidade: " + this.getFelicidade());
        System.out.println("Chance de captura: " + this.getChanceDeCaptura());
        System.out.println("Foi capturado? " + this.isCapturado());
        System.out.println();
    }

    //contruct
    public Pokemon() {
        this.setCapturado(false);
        this.setFelicidade(0);
    }

    //metodos personalizados
    public void capturar() {
        Random random = new Random();
        int aleatorio = random.nextInt(100);
        if (this.isCapturado()) {
            System.out.println(this.nome + " j? foi capturado");
        } else {
            if (this.chanceDeCaptura <= aleatorio) {
                System.out.println("Foi capturado");
                System.out.println(aleatorio);
                this.setCapturado(true);
            } else {
                System.out.println("N?o foi capturado");
                System.out.println(aleatorio);
            }
        }
    }

    public void libertar() {
        if (this.isCapturado()) {
            this.setCapturado(false);
            System.out.println(this.getNome() + " foi libertado");
        } else {
            System.out.println("N?o h? como libertar, pois n foi capturado");
        }
    }

    public void brincar() {
        this.setFelicidade(getFelicidade() + 20);
    }

    public void alimentar() {
        this.setFelicidade(getFelicidade() + 35);
    }

    public void falar() {
        System.out.println("Ol?, sou o " + this.getNome());
    }

    public void evoluir(String nome, String tipo, int captura) {
        if (this.getFelicidade() > 100) {
            System.out.println("Pokemon evolu?do com sucesso");
            this.setFelicidade(getFelicidade() - 100);
            this.setNome(nome);
            this.setTipo(tipo);
            this.setChanceDeCaptura(captura);
        } else {
            System.out.printf("Sua felicidade ? de %d, espere chegar at? 100\n", this.getFelicidade());
        }
    }

    //metodos especiais
    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getTipo() {
        return tipo;
    }

    public void setTipo(String tipo) {
        this.tipo = tipo;
    }

    public float getPeso() {
        return peso;
    }

    public void setPeso(float peso) {
        this.peso = peso;
    }

    public float getAltura() {
        return altura;
    }

    public void setAltura(float altura) {
        this.altura = altura;
    }

    public int getFelicidade() {
        return felicidade;
    }

    public void setFelicidade(int felicidade) {
        this.felicidade = felicidade;
    }

    public float getChanceDeCaptura() {
        return chanceDeCaptura;
    }

    public void setChanceDeCaptura(int chanceDeCaptura) {
        this.chanceDeCaptura = chanceDeCaptura;
    }

    public boolean isCapturado() {
        return capturado;
    }

    public void setCapturado(boolean capturado) {
        this.capturado = capturado;
    }
}

```


Overlapping Code:
```
c class Pokemon {
//atributos
private String nome;quecer de colocar o f (0.5f, 14.6f)
private float peso;
private float altura;
private int felicidade;
private int chanceDeCaptura;
private boolean capturado;
//metodo status atual
public void statusAtual() {
System.out.println("------------------------");
System.out.println("Nome: " + this.getNome());
System.out.println("Tipo: " + this.getTipo());
System.out.println("Peso " + this.getPeso());
System.out.println("Altura: " + this.getAltura());
System.out.println("Felicidade: " + this.getFelicidade());
System.out.println("Chance de captura: " + this.getChanceDeCaptura());
System.out.println("Foi capturado? " + this.isCapturado());
System.out.println();
}
//contruct
public Pokemon() {
this.setCapturado(false);
this.setFelicidade(0);
}
//metodos personalizados
public void capturar() {
Random random = new Random();
int aleatorio = random.nextInt(100);
if (this.isa <= aleatorio) {
System.out.println("Foi capturado");
System.out.println(aleatorio);
this.setCapturpturado");
System.out.println(aleatorio);
}
}
}
public void libertar() {
if (this.isCapturado()) {
this.setCapturado(false);
System.out.println(this.go");
}
}
public void brincar() {
this.setFelicidade(getFelicidade() + 20);
}
public void alimentar() {
this.setFelicidade(getFelicidade() + 35);
}
pub" + this.getNome());
}
public void evoluir(String icidade() > 100) {
System.out.println("Pokemon evoade() - 100);
this.setNome(nome);
this.setTipo(tip
```
<Overlap Ratio: 0.7538461538461538>

---

--- 213 --
Question ID: 3e54953c33cebf7c63898e13b7923b8e6bea2173
Original Code:
```
class DefinitionYamlParser<T> implements DefinitionParser<Map<String, Map<String, T>>> {

    private final Yaml yaml;

    private DefinitionYamlParser() {
        yaml = new Yaml();
    }

    public static <T> DefinitionParser<Map<String, Map<String, T>>> of() {
        return new DefinitionYamlParser<>();
    }

    @Override
    public Map<String, Map<String, T>> parse(InputStream in) {
        Iterable<Object> iterableYaml = yaml.loadAll(in);
        Iterator<Object> iterator = iterableYaml.iterator();
        return (Map<String, Map<String, T>>) iterator.next();
    }
}

```


Overlapping Code:
```
ts DefinitionParser<Map<String, Map<String, T>>> {
private final Yaml yaml;
private DefinitionYamlParser() {
yaml = new Yaml();
}
public static <T> DefinitionParser<Map<String, Map<String, T>>> of() {
return new DefinitionYamlParser<>();
}
@Override
public Map<String, Map<String, T>> parse(InputStream in) {
Iterable<Object> iterableYaml = yaml.loadAll(in);
Iterator<Object> iterator = iterableYaml.iterator();
return (Map<String, Map<String, T>>) i
```
<Overlap Ratio: 0.8875739644970414>

---

--- 214 --
Question ID: c7ffc9b5dcc827825419f89bb5fd3694937e4516
Original Code:
```
public class PlainSpringJSONDocScannerTest {

    private JSONDocScanner jsondocScanner = new Spring3JSONDocScanner();

    @Controller
    @RequestMapping(value = "/api", produces = { MediaType.APPLICATION_JSON_VALUE })
    private class SpringController {

        @RequestMapping(value = "/string/{name}", headers = "header=test", params = "delete", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE)
        @ResponseStatus(value = HttpStatus.CREATED)
        @ResponseBody
        public String string(@PathVariable(value = "test") String name, @RequestParam("id") Integer id, @RequestParam Long query, @RequestParam(name = "user", required = false, defaultValue = "admin") String user, @RequestHeader(value = "header-two", defaultValue = "header-test") String header, @RequestBody String requestBody) {
            return "ok";
        }
    }

    @Test
    public void testMergeApiDoc() {
        Set<Class<?>> controllers = new LinkedHashSet<Class<?>>();
        controllers.add(SpringController.class);
        Set<ApiDoc> apiDocs = jsondocScanner.getApiDocs(controllers, MethodDisplay.URI);
        ApiDoc apiDoc = apiDocs.iterator().next();
        Assert.assertEquals("SpringController", apiDoc.getDescription());
        Assert.assertEquals("SpringController", apiDoc.getName());
        Assert.assertNotNull(apiDoc.getGroup());
        for (ApiMethodDoc apiMethodDoc : apiDoc.getMethods()) {
            Assert.assertEquals(MethodDisplay.URI, apiMethodDoc.getDisplayMethodAs());
            Assert.assertNull(apiMethodDoc.getAuth());
            Assert.assertNull(apiMethodDoc.getSupportedversions());
            Assert.assertTrue(apiMethodDoc.getApierrors().isEmpty());
            Assert.assertNull(apiMethodDoc.getId());
            Assert.assertEquals("", apiMethodDoc.getSummary());
            Assert.assertEquals("", apiMethodDoc.getDescription());
            if (apiMethodDoc.getPath().contains("/api/string/{name}")) {
                Assert.assertEquals(2, apiMethodDoc.getHeaders().size());
                Set<ApiHeaderDoc> headers = apiMethodDoc.getHeaders();
                Iterator<ApiHeaderDoc> headersIterator = headers.iterator();
                ApiHeaderDoc headerTest = headersIterator.next();
                Assert.assertEquals("header", headerTest.getName());
                Assert.assertEquals("test", headerTest.getAllowedvalues()[0]);
                ApiHeaderDoc headerTwo = headersIterator.next();
                Assert.assertEquals("header-two", headerTwo.getName());
                Assert.assertEquals("header-test", headerTwo.getAllowedvalues()[0]);
                Assert.assertEquals("string", apiMethodDoc.getBodyobject().getJsondocType().getOneLineText());
                Assert.assertEquals("string", apiMethodDoc.getResponse().getJsondocType().getOneLineText());
                Assert.assertEquals("POST", apiMethodDoc.getVerb().iterator().next().name());
                Assert.assertEquals("application/json", apiMethodDoc.getProduces().iterator().next());
                Assert.assertEquals("application/json", apiMethodDoc.getConsumes().iterator().next());
                Assert.assertEquals("201 - Created", apiMethodDoc.getResponsestatuscode());
                Set<ApiParamDoc> queryparameters = apiMethodDoc.getQueryparameters();
                Assert.assertEquals(4, queryparameters.size());
                Iterator<ApiParamDoc> qpIterator = queryparameters.iterator();
                ApiParamDoc apiParamDoc = qpIterator.next();
                Assert.assertEquals("delete", apiParamDoc.getName());
                Assert.assertEquals("true", apiParamDoc.getRequired());
                Assert.assertEquals(null, apiParamDoc.getDefaultvalue());
                Assert.assertEquals(0, apiParamDoc.getAllowedvalues().length);
                apiParamDoc = qpIterator.next();
                Assert.assertEquals("id", apiParamDoc.getName());
                Assert.assertEquals("true", apiParamDoc.getRequired());
                Assert.assertTrue(apiParamDoc.getDefaultvalue().isEmpty());
                apiParamDoc = qpIterator.next();
                Assert.assertEquals("", apiParamDoc.getName());
                Assert.assertEquals("true", apiParamDoc.getRequired());
                Assert.assertEquals("", apiParamDoc.getDefaultvalue());
                apiParamDoc = qpIterator.next();
                Assert.assertEquals("user", apiParamDoc.getName());
                Assert.assertEquals("false", apiParamDoc.getRequired());
                Assert.assertEquals("admin", apiParamDoc.getDefaultvalue());
                Set<ApiParamDoc> pathparameters = apiMethodDoc.getPathparameters();
                Iterator<ApiParamDoc> ppIterator = pathparameters.iterator();
                apiParamDoc = ppIterator.next();
                apiParamDoc = apiMethodDoc.getPathparameters().iterator().next();
                Assert.assertEquals("test", apiParamDoc.getName());
            }
        }
    }
}

```


Overlapping Code:
```
 PlainSpringJSONDocScannerTest {
private JSONDocScanner jsondocScanner = new Spring3JSONDocScanner();
@Controller
@RequestMapping(value = "/api", produces = { MediaType.APPLICATION_JSON_VALUE })
private class SpringController {
@RequestMapping(value = "/string/{name}", headers = "header=test", params = "delete", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE)
@ResponseStatus(value = HttpStatus.CREATED)
@ResponseBody
public  string(@PathVariable(value = "test") String name, @RequestParam("id") Integer id, @RequestParam Long query, @RequestParam(name = "user", required = false, defaultValue = "admin") String user, @RequestHeader(value = "header-two", defaultValue = "header-test") String header, @RequestBody String requestBody) {
return "ok";
}
}
@Test
public void testMergeApiDoc() {
Set<Class<?>> controllers = new LinkedHashSet<Class<?>>();
controllers.add(SpringController.class);
Set<ApiDoc> apiDocs = jsondocScanner.getApiDocs(controllers, MethodDisplay.URI);
ApiDoc apiDoc = apiDocs.iterator().next();
Assert.assertEquals("SpringController", apiDoc.getDescription());
Assert.assertEquals("SpringController", apiDoc.getName());
Assert.assertNotNull(apiDoc.getGroup());
for (ApiMethodDoc apiMethodDoc : apiDoc.getMethods()) {
Assert.assertEquals(MethodDisplay.URI, apiMethodDoc.getDisplayMethodAs());
Assert.assertNull(apiMethodDoc.getAuth());
Assert.assertNull(apiMethodDoc.getSupportedversions());
Assert.assertTrue(apiMethodDoc.getApierrors().isEmpty());
Assert.assertNull(apiMethodDoc.getId());
Assert.assertEquals("", apiMethodDoc.getSummary());
Assert.assertEquals("", apiMethodDoc.getDescription());Doc.getPath().contains("/api/string/{name}")) {
Assert.assertEquals(2, apiMethodDoc.getHeaders().size());
Set<ApiHeaderDoc> headers = apiMethodDoc.getHeaders();
Iterator<ApiHeaderDoc> headersIterator = headers.iterator();
ApiHeaderDoc headerTest = headersIterator.next();
Assert.assertEquals("header", headerTest.getName());
Assert.assertEquals("test", headerTest.getAllowedvalues()[0]);
ApiHeaderDoc headerTwo = headersIterator.next()
```
<Overlap Ratio: 0.9774330042313117>

---

--- 215 --
Question ID: 46ddefab41709a6be84d5741ef31973bc48ae11a
Original Code:
```
public class MinimumSwaps {

    // Complete the minimumSwaps function below.
    static int minimumSwaps(int[] arr) {
        int swaps = 0;
        for (int i = 0; i < arr.length - 1; i++) {
            for (; arr[i] != i + 1; ) {
                int tmp = arr[arr[i] - 1];
                arr[arr[i] - 1] = arr[i];
                arr[i] = tmp;
                swaps++;
            }
        }
        return swaps;
    }

    public static void main(String[] args) throws IOException {
        int[] arr = { 1, 2, 4, 3 };
        int res = minimumSwaps(arr);
        System.out.println("Minimum Number of Swaps is: " + res);
    }
}

```


Overlapping Code:
```
 {
// Complete the minimumSwaps function below.
static int minimumSwaps(int[] arr) {
int swaps = 0;
for (int i = 0; i < arr.length - 1; i++) {
for (int tmp = arr[arr[i] - 1];
arr[arr[i] - 1] = arr[i];
arr[i] = tmp;
swaps++;
}
}
return swaps;
}
public static void main(String[] args) throws IOException {
int[] arr  = minimumSwaps(arr);
System.out.println("Minimum 
```
<Overlap Ratio: 0.774468085106383>

---

--- 216 --
Question ID: 64bb9c2ab498522d17c515ad45125a5faeadbb58
Original Code:
```
public class SaleRepository extends AbstractBaseRepository<Sale> {

    /**
     * {@inheritDoc}
     */
    @Override
    public Sale get(Long id) {
        Session session = getSession();
        session.beginTransaction();
        TypedQuery<Sale> query = session.createQuery("FROM Sale WHERE id = :id", Sale.class);
        query.setParameter("id", id);
        Sale result = query.getSingleResult();
        session.getTransaction().commit();
        return result;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<Sale> getAll() {
        Session session = getSession();
        session.beginTransaction();
        TypedQuery<Sale> query = session.createQuery("FROM Sale", Sale.class);
        List<Sale> result = query.getResultList();
        session.getTransaction().commit();
        return result;
    }
}

```


Overlapping Code:
```
BaseRepository<Sale> {
/**
* {@inheritDoc}
*/
@Override
public Sale get(Long id) {
Session session = getSession();
session.beginTransaction();
TypedQuery<Sale> query = session.createQuery("FROM Sale WHERE id = :id", Sale.class);
query.setParameter("id", id);
Sale result = query.getSingleResult();
session.getTransaction().commit();
return result;
}
/**
* {@inheritDoc}
*/
@Override
public List<Sale> getAll() {
Session session = getSession();
session.beginTransaction();
TypedQuery<Sale> query = session.createQuery("FROM Sale", Sale.class);
List<Sale> result = query.getResultList();
session.getTransaction().commit();
return result;
}

```
<Overlap Ratio: 0.9341142020497804>

---

--- 217 --
Question ID: 99d08e11b8fd9b4837646757477e56f3f5aea269
Original Code:
```
public class ForLoopCalculator implements Calculator {

    public long sumUp(long[] numbers) {
        long total = 0;
        for (long i : numbers) {
            total += i;
        }
        return total;
    }
}

```


Overlapping Code:
```
alculator implements Calculator {
public long sumUp(long[] numbers) {
long total = 0;
for (long i : numbers) {
total 
```
<Overlap Ratio: 0.7177914110429447>

---

--- 218 --
Question ID: c841148268d578f4c981485c7835479bf60d2d61
Original Code:
```
public class CertificateExtensionAppAuthenticator implements ExtensionAppAuthenticator {

    private final TokensRepository tokensRepository;

    private final SymExtensionAppAuth symExtensionAppAuth;

    public CertificateExtensionAppAuthenticator(SymConfig symConfig, TokensRepository tokensRepository) {
        symExtensionAppAuth = new SymExtensionAppAuth(symConfig);
        this.tokensRepository = tokensRepository;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AppAuthResponse appAuthenticate() {
        AppAuthResponse appAuthResponse = symExtensionAppAuth.sessionAppAuthenticate(generateAppToken());
        if (appAuthResponse != null) {
            tokensRepository.save(appAuthResponse);
        }
        return appAuthResponse;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean validateTokens(String appToken, String symphonyToken) {
        return tokensRepository.get(appToken).filter(token -> token.getSymphonyToken().equals(symphonyToken)).isPresent();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public UserInfo verifyJWT(String jwt) {
        return symExtensionAppAuth.verifyJWT(jwt, new String[0]);
    }

    private String generateAppToken() {
        byte[] randBytes = new byte[64];
        new SecureRandom().nextBytes(randBytes);
        return Hex.encodeHexString(randBytes);
    }
}

```


Overlapping Code:
```
xtensionAppAuthenticator implements ExtensionAppAuthenticator {
private final TokensRepository tokensRepository;
private final SymExtensionAppAuth symExtensionAppAuth;
public CertificateExtensionAppAuthenticator(SymConfig symConfig, TokensRepository tokensRepository) {
symExtensionAppAuth = new SymExtensionAppAuth(symConfig);
this.tokensRepository = tokensRepository;
}
/**
* {@inheritDoc}
*/
@Override
public AppAuthResponse appAuthenticate() {
AppAuthResponse appAuthResponse = symExtensionAppAuth.sessionAppAuthenticate(generateAppToken());
if (appAuthResponse != null) {
tokensRepository.save(appAuthResponse);
}
return appAuthResponse;
}
/**
* {@inheritDoc}
*/
@Override
public boolean validateTokens(String appToken, String symphonyToken) {
return tokensRepository.get(appToken -> token.getSymphonyToken().equals(symphonyTokisPresent();
}
/**
* {@inheritDoc}
*/
@Override
public UserInfo verifyJWT(String jwt) {
return symExtensionAppAuth.verifyJWT(jwt, new String[0]);
}
private String generateAppToken() {
byte[] randBytes = new byte[64];
new SecureRandom().nextBytes(randBytes);
return Hex.encodeHexString(randBy
```
<Overlap Ratio: 0.9549319727891157>

---

--- 219 --
Question ID: 343375c62eaba4f174329b4d7593ae534bc80666
Original Code:
```
public class IOHelper {

    public static void copy(Reader in, Writer out) throws IOException {
        int c = -1;
        for (; (c = in.read()) != -1; ) {
            out.write(c);
        }
    }

    public static String readFile(File file) throws IOException {
        Reader in = new FileReader(file);
        StringWriter out = new StringWriter();
        copy(in, out);
        return out.toString();
    }

    public static void saveFile(File file, String content) throws IOException {
        Writer writer = new FileWriter(file);
        writer.write(content);
        writer.close();
    }
}

```


Overlapping Code:
```
r {
public static void copy(Reader in, Writer out) throws IOException {
int);
}
}
public static String readFile(File file) throws IOException {
Reader in = new FileReader(file);
StringWriter out = new StringWriter();
copy(in, out);
return out.toString();
}
public static void saveFile(File file, String content) throws IOException {
Writer writer = new FileWriter(file);
writer.write(content);
writer.close();
```
<Overlap Ratio: 0.839835728952772>

---

--- 220 --
Question ID: be19510bbe554bc909260040d46c21ac6908f660
Original Code:
```
@SuppressWarnings({ "all", "warnings", "unchecked", "unused", "cast" })
public class LRExprParenParser extends Parser {

    static {
        RuntimeMetaData.checkVersion("4.9.2", RuntimeMetaData.VERSION);
    }

    protected static final DFA[] _decisionToDFA;

    protected static final PredictionContextCache _sharedContextCache = new PredictionContextCache();

    public static final int T__0 = 1, T__1 = 2, T__2 = 3, T__3 = 4, T__4 = 5, ID = 6, INT = 7, WS = 8;

    public static final int RULE_stat = 0, RULE_expr = 1;

    private static String[] makeRuleNames() {
        return new String[] { "stat", "expr" };
    }

    public static final String[] ruleNames = makeRuleNames();

    private static String[] makeLiteralNames() {
        return new String[] { null, "';'", "'*'", "'+'", "'('", "')'" };
    }

    private static final String[] _LITERAL_NAMES = makeLiteralNames();

    private static String[] makeSymbolicNames() {
        return new String[] { null, null, null, null, null, null, "ID", "INT", "WS" };
    }

    private static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();

    public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);

    /**
     * @deprecated Use {@link #VOCABULARY} instead.
     */
    @Deprecated
    public static final String[] tokenNames;

    static {
        tokenNames = new String[_SYMBOLIC_NAMES.length];
        for (int i = 0; i < tokenNames.length; i++) {
            tokenNames[i] = VOCABULARY.getLiteralName(i);
            if (tokenNames[i] == null) {
                tokenNames[i] = VOCABULARY.getSymbolicName(i);
            }
            if (tokenNames[i] == null) {
                tokenNames[i] = "<INVALID>";
            }
        }
    }

    @Override
    @Deprecated
    public String[] getTokenNames() {
        return tokenNames;
    }

    @Override
    public Vocabulary getVocabulary() {
        return VOCABULARY;
    }

    @Override
    public String getGrammarFileName() {
        return "LRExprParen.g4";
    }

    @Override
    public String[] getRuleNames() {
        return ruleNames;
    }

    @Override
    public String getSerializedATN() {
        return _serializedATN;
    }

    @Override
    public ATN getATN() {
        return _ATN;
    }

    public LRExprParenParser(TokenStream input) {
        super(input);
        _interp = new ParserATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);
    }

    public static class StatContext extends ParserRuleContext {

        public ExprContext expr() {
            return getRuleContext(ExprContext.class, 0);
        }

        public TerminalNode EOF() {
            return getToken(LRExprParenParser.EOF, 0);
        }

        public StatContext(ParserRuleContext parent, int invokingState) {
            super(parent, invokingState);
        }

        @Override
        public int getRuleIndex() {
            return RULE_stat;
        }

        @Override
        public void enterRule(ParseTreeListener listener) {
            if (listener instanceof LRExprParenListener)
                ((LRExprParenListener) listener).enterStat(this);
        }

        @Override
        public void exitRule(ParseTreeListener listener) {
            if (listener instanceof LRExprParenListener)
                ((LRExprParenListener) listener).exitStat(this);
        }

        @Override
        public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
            if (visitor instanceof LRExprParenVisitor)
                return ((LRExprParenVisitor<? extends T>) visitor).visitStat(this);
            else
                return visitor.visitChildren(this);
        }
    }

    public final StatContext stat() throws RecognitionException {
        StatContext _localctx = new StatContext(_ctx, getState());
        enterRule(_localctx, 0, RULE_stat);
        try {
            enterOuterAlt(_localctx, 1);
            {
                setState(4);
                expr(0);
                setState(5);
                match(T__0);
                setState(6);
                match(EOF);
            }
        } catch (RecognitionException re) {
            _localctx.exception = re;
            _errHandler.reportError(this, re);
            _errHandler.recover(this, re);
        } finally {
            exitRule();
        }
        return _localctx;
    }

    public static class ExprContext extends ParserRuleContext {

        public List<ExprContext> expr() {
            return getRuleContexts(ExprContext.class);
        }

        public ExprContext expr(int i) {
            return getRuleContext(ExprContext.class, i);
        }

        public TerminalNode INT() {
            return getToken(LRExprParenParser.INT, 0);
        }

        public TerminalNode ID() {
            return getToken(LRExprParenParser.ID, 0);
        }

        public ExprContext(ParserRuleContext parent, int invokingState) {
            super(parent, invokingState);
        }

        @Override
        public int getRuleIndex() {
            return RULE_expr;
        }

        @Override
        public void enterRule(ParseTreeListener listener) {
            if (listener instanceof LRExprParenListener)
                ((LRExprParenListener) listener).enterExpr(this);
        }

        @Override
        public void exitRule(ParseTreeListener listener) {
            if (listener instanceof LRExprParenListener)
                ((LRExprParenListener) listener).exitExpr(this);
        }

        @Override
        public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
            if (visitor instanceof LRExprParenVisitor)
                return ((LRExprParenVisitor<? extends T>) visitor).visitExpr(this);
            else
                return visitor.visitChildren(this);
        }
    }

    public final ExprContext expr() throws RecognitionException {
        return expr(0);
    }

    private ExprContext expr(int _p) throws RecognitionException {
        ParserRuleContext _parentctx = _ctx;
        int _parentState = getState();
        ExprContext _localctx = new ExprContext(_ctx, _parentState);
        ExprContext _prevctx = _localctx;
        int _startState = 2;
        enterRecursionRule(_localctx, 2, RULE_expr, _p);
        try {
            int _alt;
            enterOuterAlt(_localctx, 1);
            {
                setState(15);
                _errHandler.sync(this);
                switch(_input.LA(1)) {
                    case T__3:
                        {
                            setState(9);
                            match(T__3);
                            setState(10);
                            expr(0);
                            setState(11);
                            match(T__4);
                        }
                        break;
                    case INT:
                        {
                            setState(13);
                            match(INT);
                        }
                        break;
                    case ID:
                        {
                            setState(14);
                            match(ID);
                        }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
                _ctx.stop = _input.LT(-1);
                setState(25);
                _errHandler.sync(this);
                _alt = getInterpreter().adaptivePredict(_input, 2, _ctx);
                for (; _alt != 2 && _alt != org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER; ) {
                    if (_alt == 1) {
                        if (_parseListeners != null)
                            triggerExitRuleEvent();
                        _prevctx = _localctx;
                        {
                            setState(23);
                            _errHandler.sync(this);
                            switch(getInterpreter().adaptivePredict(_input, 1, _ctx)) {
                                case 1:
                                    {
                                        _localctx = new ExprContext(_parentctx, _parentState);
                                        pushNewRecursionContext(_localctx, _startState, RULE_expr);
                                        setState(17);
                                        if (!(precpred(_ctx, 5)))
                                            throw new FailedPredicateException(this, "precpred(_ctx, 5)");
                                        setState(18);
                                        match(T__1);
                                        setState(19);
                                        expr(6);
                                    }
                                    break;
                                case 2:
                                    {
                                        _localctx = new ExprContext(_parentctx, _parentState);
                                        pushNewRecursionContext(_localctx, _startState, RULE_expr);
                                        setState(20);
                                        if (!(precpred(_ctx, 4)))
                                            throw new FailedPredicateException(this, "precpred(_ctx, 4)");
                                        setState(21);
                                        match(T__2);
                                        setState(22);
                                        expr(5);
                                    }
                                    break;
                            }
                        }
                    }
                    setState(27);
                    _errHandler.sync(this);
                    _alt = getInterpreter().adaptivePredict(_input, 2, _ctx);
                }
            }
        } catch (RecognitionException re) {
            _localctx.exception = re;
            _errHandler.reportError(this, re);
            _errHandler.recover(this, re);
        } finally {
            unrollRecursionContexts(_parentctx);
        }
        return _localctx;
    }

    public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
        switch(ruleIndex) {
            case 1:
                return expr_sempred((ExprContext) _localctx, predIndex);
        }
        return true;
    }

    private boolean expr_sempred(ExprContext _localctx, int predIndex) {
        switch(predIndex) {
            case 0:
                return precpred(_ctx, 5);
            case 1:
                return precpred(_ctx, 4);
        }
        return true;
    }

    public static final String _serializedATN = "\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\n\37\4\2\t\2\4\3" + "\t\3\3\2\3\2\3\2\3\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3\22\n\3\3\3\3\3\3" + "\3\3\3\3\3\3\3\7\3\32\n\3\f\3\16\3\35\13\3\3\3\2\3\4\4\2\4\2\2\2 \2\6" + "\3\2\2\2\4\21\3\2\2\2\6\7\5\4\3\2\7\b\7\3\2\2\b\t\7\2\2\3\t\3\3\2\2\2" + "\n\13\b\3\1\2\13\f\7\6\2\2\f\r\5\4\3\2\r\16\7\7\2\2\16\22\3\2\2\2\17\22" + "\7\t\2\2\20\22\7\b\2\2\21\n\3\2\2\2\21\17\3\2\2\2\21\20\3\2\2\2\22\33" + "\3\2\2\2\23\24\f\7\2\2\24\25\7\4\2\2\25\32\5\4\3\b\26\27\f\6\2\2\27\30" + "\7\5\2\2\30\32\5\4\3\7\31\23\3\2\2\2\31\26\3\2\2\2\32\35\3\2\2\2\33\31" + "\3\2\2\2\33\34\3\2\2\2\34\5\3\2\2\2\35\33\3\2\2\2\5\21\31\33";

    public static final ATN _ATN = new ATNDeserializer().deserialize(_serializedATN.toCharArray());

    static {
        _decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];
        for (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {
            _decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);
        }
    }
}

```


Overlapping Code:
```
SuppressWarnings({ "all", "warnings", "unchecked", "unused", "cast" })
public clasParser extends Parser {
static {
RuntimeMetaData.checkVersion("4.9.2", RuntimeMetaData.VERSION);
}
protected static final DFA[] _decisionToDFA;
protected static final PredictionContextCache _sharedContextCache = new PredictionContextCache();
public static final int T__0 = 1, T__1 = 2, T__2 = 3, T__3 = 4, T__4 = 5, tat = 0, RULE_expr = 1;
private static String[] makeRuleNames() {
return new String[] {" };
}
public static final String[] ruleNames = makeRuleNames();
private static String[] makeLiteralNames() {
return new String[] { nu };
}
private static final String[] _LITERAL_NAMES = makeLiteralNames();
private static String[] makeSymbolicNames() {
return new String[] { null, null, null, null, null, null, "ID", "INT", " };
}
private static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();
public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);
/**
* @deprecated Use {@link #VOCABULARY} instead.
*/
@Deprecated
public static final String[] tokenNames;
static {
tokenNames = new String[_SYMBOLIC_NAMES.length];
for (int i = 0; i < tokenNames.length; i++) {
tokenNames[i] = VOCABULARY.getLiteralName(i);
if (tokenNames[i] == null) {
tokenNames[i] = VOCABULARY.getSymbolicName(i);
}
if (tokenNames[i] == null) {
tokenNames[i] = "<INVALID>";
}
}
}
@Override
@Deprecated
public String[] getTokenNames() {
return tokenNames;
}
@Override
public Vocabulary getVocabulary() {
return VOCABULARY;
}
@Override
public String getGrammarFileName() {
return ".g4";
}
@Override
public String[] getRuleNames() {
return ruleNames;
}
@Override
public String getSerializedATN() {
return _serializedATN;
}
@Override
public ATN getATN() {
return _ATN;
}
public nParser(TokenStream input) {
super(input);
_interp = new ParserATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);
}
public static class StatContext exte
```
<Overlap Ratio: 0.9308689390302448>

---

--- 221 --
Question ID: 95fc3562a6d884a48bc6d5bc1a1773c7aed9a8a8
Original Code:
```
@Vetoed
public class Linker {

    private final Router router;

    private final ServletContext context;

    private final List<Object> args;

    private final String methodName;

    private final Class<?> controller;

    private final ReflectionProvider reflectionProvider;

    public Linker(ServletContext context, Router router, Class<?> controller, String methodName, List<Object> args, ReflectionProvider reflectionProvider) {
        this.router = router;
        this.context = context;
        this.controller = controller;
        this.methodName = methodName;
        this.args = args;
        this.reflectionProvider = reflectionProvider;
    }

    protected String getLink() {
        Method method = getMethod();
        return getPrefix() + router.urlFor(controller, method, getArgs(method));
    }

    protected String getPrefix() {
        return context.getContextPath();
    }

    protected Method getMethod() {
        Method method = null;
        if (countMethodsWithSameName() > 1) {
            method = reflectionProvider.getMethod(controller, methodName, getClasses(args));
            if (method == null && args.isEmpty()) {
                throw new IllegalArgumentException("Ambiguous method '" + methodName + "' on " + controller + ". Try to add some parameters to resolve ambiguity, or use different method names.");
            }
        } else {
            method = findMethodWithName(controller, methodName);
        }
        if (method == null) {
            throw new IllegalArgumentException(String.format("There are no methods on %s named '%s' that receives args of types %s", controller, methodName, Arrays.toString(getClasses(args))));
        }
        return method;
    }

    protected Object[] getArgs(Method method) {
        int methodArity = method.getParameterTypes().length;
        if (args.size() == methodArity) {
            return args.toArray();
        }
        if (args.size() > methodArity) {
            throw new IllegalArgumentException(String.format("linkTo param args must have the same or lower length as method param args. linkTo args: %d | method args: %d", args.size(), methodArity));
        }
        Object[] noMissingParamsArgs = new Object[methodArity];
        System.arraycopy(args.toArray(), 0, noMissingParamsArgs, 0, args.size());
        return noMissingParamsArgs;
    }

    protected Method findMethodWithName(Class<?> type, String name) {
        for (Method method : type.getDeclaredMethods()) {
            if (!method.isBridge() && method.getName().equals(name)) {
                return method;
            }
        }
        if (type.getSuperclass().equals(Object.class)) {
            return null;
        }
        return findMethodWithName(type.getSuperclass(), name);
    }

    protected int countMethodsWithSameName() {
        int amount = 0;
        for (Method method : controller.getDeclaredMethods()) {
            if (!method.isBridge() && method.getName().equals(methodName)) {
                amount++;
            }
        }
        return amount;
    }

    protected Class<?>[] getClasses(List<Object> params) {
        Class<?>[] classes = new Class<?>[params.size()];
        int i = 0;
        while (i < params.size()) try {
            classes[i] = params.get(i).getClass();
        } finally {
            i++;
        }
        return classes;
    }
}

```


Overlapping Code:
```
ed
public class Linker {
private final Router router;
private final ServletContext context;
private final List<Object> args;
private final String methodName;
private final Class<?> controller;
private final ReflectionProvider reflectionProvider;
public Linker(ServletContext context, Router router, Class<?> controller, String methodName, List<Object> argectionProvider reflectionProvider) {
this.router = router;
this.context = context;
this.controller = controller;
this.methodName = methodName;
this.args = args;
this.reflectionProvider = reflectionProvider;
}
protected String getLink() {
Method method = getMethod();
return getPrefix() + router.urlFor(controller, method, getArgs(method));
}
protected String getPrefied Method getMethod() {
Method method = null;
if (countMethodsWithSameName() > 1) {
method = reflectionProvider.getMethod(controller, methodName, getClasses(args));
if (method == null && args.isEmpty()) {
throw new IllegalArgumentException("Ambiguous method '" + methodName + "' on " + controller + ". Try to add some parameters to resolve ambiguity, or use different method names.");
}
} else {
method = findMethodWithName(controller, methodName);
}
if (method == null) {
throw new IllegalArgumentException(String.format("There are no methods on %s named '%s' that receives args of types ler, methodName, Arrays.toString(getClasses(args))));
}
return method;
}
protected Object[] getArgs(Method method) {
int methodArity = method.getParameterTypes().length;
if (args.size() == methodArity) {
return args.toArray();
}
if (args.size() > methodArity) {
throw new IllegalArgumentException(String.format("linkTo param args must have the same or lower length as method param args. linkTo args: %d | method args: %d", args.size(), methodArity));
}
Object[] noMissingParamsArgs = new Object[methodArity];
System.arraycopy(args.toArray(), 0, noMissingParamsArgs, 0, args.size());
return noMissingParamsArgs;
}
protected Method findMethodWithName(Class<?> type, String name) {
for (Method method : type.getDeclaredMethods()) {
```
<Overlap Ratio: 0.9658929417337755>

---

--- 222 --
Question ID: 9956ea19059eb59ded74335da5da93cfd5fb1e69
Original Code:
```
@Slf4j
public class FillStyleCellWriteHandler implements CellWriteHandler {

    @Override
    public int order() {
        return OrderConstant.FILL_STYLE;
    }

    @Override
    public void afterCellDispose(CellWriteHandlerContext context) {
        List<WriteCellData<?>> cellDataList = context.getCellDataList();
        if (CollectionUtils.isEmpty(cellDataList) || cellDataList.size() > 1) {
            return;
        }
        WriteCellData<?> cellData = cellDataList.get(0);
        WriteCellStyle writeCellStyle = cellData.getWriteCellStyle();
        if (writeCellStyle == null) {
            return;
        }
        WriteWorkbookHolder writeWorkbookHolder = context.getWriteWorkbookHolder();
        context.getCell().setCellStyle(writeWorkbookHolder.createCellStyle(writeCellStyle));
    }
}

```


Overlapping Code:
```
llWriteHandler implements CellWriteHandler {
@Override
public int order() {
return OrderConstant.FILL_STYLE;
}
@Override
public void afterCellDispose(CellWriteHandlerContext context) {
List<WriteCellData<?>> cellDataList = context.getCellDataList();
if (CollectionUtils.isEmpty(cellDataList) || cellDataList.size() > 1) {
return;
}
WriteCellData<?> cellData = cellDataList.get(0);
WriteCellStyle writeCellStyle = cellData.getWriteCellStyle();
if (writeCellStyle == null) {
return;
}
WriteWorkbookHolder writeWorkbookHolder = context.getWriteWorkbookHolder();
context.getCell().setCellStyle(writeWorkbookHolder.crea
```
<Overlap Ratio: 0.9056047197640118>

---

--- 223 --
Question ID: f897b790e84ce679266078228c42440591f1ba9b
Original Code:
```
public class IsDAG_DontHave_Cycles {

    Map<Integer, Set<Integer>> map = new HashMap<>();

    Set<Integer> vis = new HashSet<>();

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if (prerequisites == null) {
            return false;
        }
        if (prerequisites.length <= 0) {
            return true;
        }
        Set<Integer> prevS = new HashSet<>();
        Set<Integer> nextS = new HashSet<>();
        int n = prerequisites.length;
        int i = 0;
        while (i < n) try {
            int prevCour = prerequisites[i][1];
            int nextCour = prerequisites[i][0];
            prevS.add(prevCour);
            nextS.add(nextCour);
            Set<Integer> courses = map.get(prevCour);
            if (courses == null) {
                courses = new HashSet<>();
                map.put(prevCour, courses);
            }
            courses.add(nextCour);
        } finally {
            i++;
        }
        prevS.removeAll(nextS);
        for (Integer item : prevS) {
            if (!dfs(item)) {
                return false;
            }
        }
        return true;
    }

    private boolean dfs(Integer node) {
        if (node == null) {
            return true;
        }
        if (vis.contains(node)) {
            return false;
        }
        vis.add(node);
        Set<Integer> courses = map.get(node);
        if (courses != null) {
            for (Integer n : courses) {
                if (!dfs(n)) {
                    return false;
                }
            }
        }
        vis.remove(node);
        return true;
    }
}

```


Overlapping Code:
```
_DontHave_Cycles {
Map<Integer, Set<Integer>> map = new HashMap<>();
Set<Integer> vis = new HashSet<>();
public boolean canFinish(int numCourses, int[][] prerequisites) {
if (prerequisites == null) {
return false;
}
if (prerequisites.lengevCour = prerequisites[i][1];
int nextCour = prere(item)) {
return false;
}
}
return true;
}
private boolean df
```
<Overlap Ratio: 0.32106715731370744>

---

--- 224 --
Question ID: e4b942f15ea71c6bd3c05404bc0adeed6fb51639
Original Code:
```
public final class JobConfGenDriver {

    private static final Log logger = LogFactory.getLog(JobConfGenDriver.class.getName());

    private static final String METHOD_DECLARATION = "(/\\*(.+?)\\*/)([^;]+;)";

    private static final String COMMENT_PATTERN = "(\\w+\\s*)(:)([^\\r\\n]+)";

    private static final String MEMBER_PATTERN = "([^=]=\\s*)(\"[^\"]+\")";

    public enum PluginType {

        Reader, Writer
    }

    // Suppress default constructor for non-instantiability
    private JobConfGenDriver() {
        throw new AssertionError();
    }

    public static void showCopyRight() {
        System.out.println("Welcome to using DianPing WormHole Version 0.1");
    }

    public static List<String> getPluginDirAsList(String pluginsDirName) {
        List<String> pluginsList = new ArrayList<String>();
        String lastNameOfPluginsDirName = pluginsDirName.substring(pluginsDirName.lastIndexOf(File.separator) + 1);
        for (File file : new File(pluginsDirName).listFiles()) {
            if (file.isDirectory() && file.getName().endsWith(lastNameOfPluginsDirName)) {
                pluginsList.add(file.getName());
            }
        }
        Collections.sort(pluginsList);
        return pluginsList;
    }

    public static int showPluginsInfo(String prefixInfo, List<String> pluginsList) {
        int pluginsSize = pluginsList.size();
        int choice = -1;
        for (; choice < 0 || choice > pluginsSize - 1; ) {
            System.out.println(prefixInfo);
            for (int idx = 0; idx < pluginsSize; idx++) {
                System.out.println(String.format("%d\t%s", idx, pluginsList.get(idx).toLowerCase().replace("reader", "").replace("writer", "")));
            }
            System.out.print(String.format("Please choose [%d-%d]: ", 0, pluginsSize - 1));
            try {
                choice = Integer.parseInt(new Scanner(System.in).nextLine());
            } catch (NumberFormatException e) {
                System.out.println("Your chosen number is not correct. Please choose it again.");
                choice = -1;
            }
        }
        return choice;
    }

    public static void generateJobConfXml() throws IOException {
        showCopyRight();
        Map<PluginType, List<String>> pluginMap = new HashMap<PluginType, List<String>>();
        pluginMap.put(PluginType.Reader, getPluginDirAsList(Environment.READER_PLUGINS_DIR));
        pluginMap.put(PluginType.Writer, getPluginDirAsList(Environment.WRITER_PLUGINS_DIR));
        int readerPluginIndex = showPluginsInfo("WormHole Data Source: ", pluginMap.get(PluginType.Reader));
        int writerPluginIndex = showPluginsInfo("WormHole Data Destination: ", pluginMap.get(PluginType.Writer));
        String readerPluginName = pluginMap.get(PluginType.Reader).get(readerPluginIndex);
        String writerPluginName = pluginMap.get(PluginType.Writer).get(writerPluginIndex);
        String readerPluginPath = String.format("%s/%s/ParamKey.java", Environment.READER_PLUGINS_DIR, readerPluginName);
        String writerPluginPath = String.format("%s/%s/ParamKey.java", Environment.WRITER_PLUGINS_DIR, writerPluginName);
        ClassNode readerClassNode = parse(readerPluginName, readerPluginPath);
        ClassNode writerClassNode = parse(writerPluginName, writerPluginPath);
        String jobFileName = MessageFormat.format("wormhole_{0}_to_{1}_{2}.xml", readerClassNode.getName(), writerClassNode.getName(), System.currentTimeMillis());
        int retStatus = generateXmlFile(readerClassNode, writerClassNode, jobFileName);
        if (0 == retStatus) {
            System.out.println(String.format("Create jobfile %s completed.", jobFileName));
        }
    }

    public static int generateXmlFile(ClassNode readerClassNode, ClassNode writerClassNode, String fileName) throws IOException {
        Document doc = DocumentHelper.createDocument();
        Element jobE = doc.addElement("job");
        String jobId = readerClassNode.getName() + "_to_" + writerClassNode.getName() + "_job";
        jobE.addAttribute("id", jobId);
        /* add reader part */
        Element readerE = jobE.addElement("reader");
        Element pluginE = readerE.addElement("plugin");
        pluginE.setText(readerClassNode.getName());
        Element tempElement = null;
        List<ClassMember> members = readerClassNode.getAllMembers();
        for (ClassMember member : members) {
            StringBuilder command = new StringBuilder("\n");
            Set<String> set = member.getAllKeys();
            String value = "";
            for (String key : set) {
                value = member.getAttr("default");
                command.append(key).append(":").append(member.getAttr(key)).append("\n");
            }
            readerE.addComment(command.toString());
            String keyName = member.getName();
            keyName = keyName.substring(1, keyName.length() - 1);
            tempElement = readerE.addElement(keyName);
            if (StringUtils.isEmpty(value)) {
                value = "";
            }
            tempElement.setText(value);
        }
        /* add writer part */
        Element writerE = jobE.addElement("writer");
        pluginE = writerE.addElement("plugin");
        pluginE.setText(writerClassNode.getName());
        members = writerClassNode.getAllMembers();
        for (ClassMember member : members) {
            StringBuilder command = new StringBuilder("\n");
            Set<String> set = member.getAllKeys();
            String value = "";
            for (String key : set) {
                value = member.getAttr("default");
                command.append(key).append(":").append(member.getAttr(key)).append("\n");
            }
            writerE.addComment(command.toString());
            String keyName = member.getName();
            keyName = keyName.substring(1, keyName.length() - 1);
            tempElement = writerE.addElement(keyName);
            if (!StringUtils.isBlank(value)) {
                tempElement.addText(value);
            } else {
                tempElement.addText("");
            }
        }
        XMLWriter output;
        OutputFormat format = OutputFormat.createPrettyPrint();
        format.setEncoding("UTF-8");
        output = new XMLWriter(new FileWriter(fileName), format);
        output.write(doc);
        output.close();
        return 0;
    }

    public static ClassNode parse(String name, String path) {
        String source = "";
        try {
            source = FileUtils.readFileToString(new File(path));
        } catch (IOException e) {
            logger.error(org.apache.hadoop.util.StringUtils.stringifyException(e));
            return null;
        }
        source = source.substring(source.indexOf('{') + 1);
        source = source.substring(0, source.lastIndexOf('}'));
        ClassNode node = ClassNode.newInstance();
        node.setName(name);
        Pattern pattern = Pattern.compile(METHOD_DECLARATION, Pattern.DOTALL);
        Matcher matcher = pattern.matcher(source);
        for (; matcher.find(); ) {
            /* parse comment */
            Pattern commentPattern = Pattern.compile(COMMENT_PATTERN);
            Matcher commentMatcher = commentPattern.matcher(matcher.group(1));
            if (!commentMatcher.find()) {
                throw new IllegalArgumentException("File format error: class declaration without comment @" + matcher.group(1));
            }
            Map<String, String> attributes = new HashMap<String, String>();
            for (; ; ) try {
                attributes.put(commentMatcher.group(1), commentMatcher.group(3).trim());
            } finally {
                if (!commentMatcher.find()) {
                    break;
                }
            }
            /* add key */
            Pattern memberPattern = Pattern.compile(MEMBER_PATTERN);
            Matcher memberMatcher = memberPattern.matcher(matcher.group(3));
            if (!memberMatcher.find()) {
                throw new IllegalArgumentException("File format error: comment without member declaration @" + matcher.group(3));
            }
            node.addMember(ClassNode.createMember(memberMatcher.group(2), attributes));
        }
        return node;
    }
}

```


Overlapping Code:
```
ver {
private static final Log logger = LogFactory.getLog(Jover.class.getName());
private static final String METHOD_DECLARATION = "(/\\*(.+?)\\*/)([^;]+;)";
private static final String COMMENT_PATTERN = "(\\w+\\s*)(:)([^\\r\\n]+)";
private static final String MEMBER_PATTERN = "([^=]=\\s*)(\/ Suppress default constructor for non-instantiability
private er() {
throw new AssertionError();
}
public static void Right() {
System.out.println("Welcome to using Diat<String> getPluginDirAsList(String pluginsDirName) {
List<String> pluginsList = new ArrayList<String>();
String lastNameOfPluginsDirName = pluginsDirName.substring(pluginsDirName.lastIndexOf(File.separator) + 1);
for (File file : new File(pluginsDirName).listFiles()) {
if (file.isDirectory() && file.getName().endsWith(lastNameOfPluginsDirName)) {
pluginsList.add(file.getName());
}
}
Collections.satic int showPluginsInfo(String prefixInfo, List<String> pluginsList) {
int pluginsSize = pluginsLispluginsSize - 1));
try {
choice = Integer.parseInt(new Scanner(System.in).nextLine());
} catch (NumberFormatException e) {
System.out.println("Your chosen number is not correct. Please choose it again.ic void generateJobConfXml() throws IOException {
uginMap = new HashMap<PluginType, List<String>>();ist(Environment.READER_PLUGINS_DIR));
pluginMap.pu
```
<Overlap Ratio: 0.6453516969995081>

---

--- 225 --
Question ID: df24fff179af2f6b34da1640e8cdc9a0ebf2b74e
Original Code:
```
public class GenericFontMapper implements org.jpedal.render.output.FontMapper {

    private static final String DEFAULT_FONT = "DEFAULT_FONT";

    //weight
    String style = "normal";

    String weight = "normal";

    String family;

    private String fontID;

    private int fontMode = DEFAULT_ON_UNMAPPED;

    private boolean isFontEmbedded;

    private boolean isFontSubstituted;

    //list of font mappings to substitute fonts
    public static final Map<String, String> fontMappings = new HashMap<String, String>();

    public static final Map<String, Integer> fontSizeAdjustments = new HashMap<String, Integer>();

    private static final Map<String, String> fontStyle = new HashMap<String, String>();

    private static final Map<String, String> fontWeight = new HashMap<String, String>();

    //original name in PDF
    private String rawFont;

    //setup font substitutions once
    static {
        //Mappings reference: http://www.ampsoft.net/webdesign-l/WindowsMacFonts.html
        final String arialType = "Arial, Helvetica, sans-serif";
        final String arialBlackType = "'Arial Black', Gadget, sans-serif";
        final String comicSansType = "'Comic Sans MS', Textile, cursive";
        final String courierNewType = "'Courier New', Courier, monospace";
        final String georgiaType = "Georgia, 'Times New Roman', Times, serif";
        final String impactType = "Impact, Charcoal, sans-serif";
        final String lucidaConsoleType = "'Lucida Console', Monaco, monospace";
        final String lucidaSansType = "'Lucida Sans Unicode', 'Lucida Grande', sans-serif";
        final String palatinoType = "'Palatino Linotype', 'Book Antiqua', Palatino, serif";
        final String tahomaType = "Tahoma, Geneva, sans-serif";
        final String romanType = "'Times New Roman', Times, serif";
        final String trebuchetType = "'Trebuchet MS', Helvetica, sans-serif";
        final String verdanaType = "Verdana, Geneva, sans-serif";
        final String symbolType = "Symbol";
        final String webdingsType = "Webdings";
        final String wingdingsType = "Wingdings, 'Zapf Dingbats'";
        final String msSansSerifType = "'MS Sans Serif', Geneva, sans-serif";
        final String msSerifType = "'MS Serif', 'New York', serif";
        final String helveticaType = "Helvetica, Arial, sans-serif";
        if (fontMappings.keySet().isEmpty()) {
            //Default fonts
            fontMappings.put("Arial", arialType);
            fontMappings.put("ArialMT", arialType);
            fontMappings.put("ArialBlack", arialBlackType);
            fontMappings.put("ComicSansMS", comicSansType);
            fontMappings.put("CourierNew", courierNewType);
            fontMappings.put("Georgia", georgiaType);
            fontMappings.put("Impact", impactType);
            fontMappings.put("LucidaConsole", lucidaConsoleType);
            fontMappings.put("LucidaSansUnicode", lucidaSansType);
            fontMappings.put("PalatinoLinotype", palatinoType);
            fontMappings.put("Tahoma", tahomaType);
            fontMappings.put("TimesNewRoman", romanType);
            fontMappings.put("Times", romanType);
            fontMappings.put("Trebuchet", trebuchetType);
            fontMappings.put("Verdana", verdanaType);
            fontMappings.put("Symbol", symbolType);
            fontMappings.put("Webdings", webdingsType);
            fontMappings.put("Wingdings", wingdingsType);
            fontMappings.put("MSSansSerif", msSansSerifType);
            fontMappings.put("MSSerif", msSerifType);
            fontMappings.put("Helvetica", helveticaType);
            fontMappings.put("ZapfDingbats", wingdingsType);
            fontMappings.put(DEFAULT_FONT, romanType);
            //Err on the side of caution for default fonts.
            fontSizeAdjustments.put(DEFAULT_FONT, -1);
        }
    }

    public GenericFontMapper(final String rawFont) {
        init(rawFont);
        this.rawFont = rawFont;
    }

    public GenericFontMapper(final String rawFont, final int fontMode, final boolean isFontEmbedded, final boolean isFontSubstituted) {
        this.fontMode = fontMode;
        this.isFontEmbedded = isFontEmbedded;
        this.isFontSubstituted = isFontSubstituted;
        this.rawFont = rawFont;
        init(rawFont);
    }

    private void init(final String rawFont) {
        if (fontMode == EMBED_ALL || fontMode == EMBED_ALL_EXCEPT_BASE_FAMILIES) {
            fontID = rawFont;
            //limit to nonn-emebedded of Standard (ie TNR, Arial)
            if (!isFontEmbedded || StandardFonts.isStandardFont(rawFont, true)) {
                int ptr = rawFont.indexOf(',');
                if (ptr == -1) {
                    ptr = rawFont.indexOf('-');
                }
                if (ptr == -1) {
                    int i = (rawFont.length() - 1);
                    while (i >= 0) try {
                        final int pt = rawFont.codePointAt(i);
                        if (pt >= 0x30 && pt <= 0x39) {
                            if (i < (rawFont.length() - 1)) {
                                ptr = i - 1;
                            }
                            break;
                        }
                    } finally {
                        i--;
                    }
                }
                if (ptr > 0) {
                    findAttributes(rawFont);
                }
            }
        } else if (!directMapFont(rawFont)) {
            final String fontLessAttributes = findAttributes(rawFont);
            //Does the font name minus attributes exist in mappings?
            if (!mapFont(fontLessAttributes)) {
                //If there isnt a similiar one use the default.
                if (!hasSimiliarMapping(fontLessAttributes)) {
                    switch(this.fontMode) {
                        case DEFAULT_ON_UNMAPPED:
                            fontID = DEFAULT_FONT;
                            break;
                        case FontMapper.FAIL_ON_UNMAPPED:
                            throw new RuntimeException("Font " + rawFont + " not mapped");
                    }
                }
            }
        }
    }

    /**
     * Strip out and set font attributes returning the font name
     * @param rawFont
     * @return String contains the name of the font
     */
    private String findAttributes(final String rawFont) {
        String result = rawFont;
        int ptr = rawFont.indexOf(',');
        if (ptr == -1) {
            ptr = rawFont.indexOf('-');
        }
        if (ptr == -1) {
            ptr = rawFont.lastIndexOf(' ');
        }
        if (ptr == -1) {
            int i = (rawFont.length() - 1);
            while (i >= 0) try {
                final int pt = rawFont.codePointAt(i);
                if (pt >= 0x30 && pt <= 0x39) {
                    if (i < (rawFont.length() - 1)) {
                        ptr = i - 1;
                    }
                    break;
                }
            } finally {
                i--;
            }
        }
        if (ptr != -1) {
            final String fontAttributes = rawFont.substring(ptr + 1, rawFont.length()).toLowerCase();
            result = rawFont.substring(0, ptr);
            //font less any -, or number
            family = result;
            boolean isFontExists = false;
            for (final String k : fontMappings.keySet()) {
                if (k.startsWith(family)) {
                    isFontExists = true;
                }
            }
            if (isFontExists || !isFontEmbedded) {
                if (fontAttributes.contains("heavy")) {
                    weight = "900";
                } else if (fontAttributes.endsWith("black")) {
                    weight = "bolder";
                } else if (fontAttributes.contains("light")) {
                    weight = "lighter";
                } else if (fontAttributes.contains("condensed")) {
                    weight = "100";
                } else if (fontAttributes.contains("bold")) {
                    weight = "bold";
                }
                /**
                 * and style
                 */
                if (fontAttributes.equals("it") || fontAttributes.contains("italic") || fontAttributes.contains("kursiv") || fontAttributes.contains("oblique")) {
                    style = "italic";
                }
            }
        }
        return result;
    }

    /**
     * See if font is in mappings and set the font ID.  Return false if its not.
     * @param s String to check
     * @return true if it maps
     */
    private boolean mapFont(final String s) {
        if (fontMappings.get(s) != null) {
            fontID = s;
            return true;
        }
        return false;
    }

    /**
     * Find out if there is a direct mapping to the given font
     */
    private boolean directMapFont(final String s) {
        final boolean result = mapFont(s);
        if (!result) {
            return false;
        }
        if (fontStyle.containsKey(s)) {
            style = fontStyle.get(s);
        }
        if (fontWeight.containsKey(s)) {
            weight = fontWeight.get(s);
        }
        return true;
    }

    /**
     * Search mappings for a one that sounds close.
     * @param fontName
     * @return
     */
    private boolean hasSimiliarMapping(final String fontName) {
        final Set<String> keySet = fontMappings.keySet();
        final Set<String> candidates = new HashSet<String>();
        for (final String key : keySet) {
            final String lcKey = key.toLowerCase();
            final String lcFont = fontName.toLowerCase();
            if (lcKey.equals(lcFont)) {
                fontID = key;
                return true;
            }
            if (lcKey.contains(lcFont) || lcFont.contains(lcKey)) {
                candidates.add(key);
            }
        }
        if (!candidates.isEmpty()) {
            String[] result = new String[candidates.size()];
            result = candidates.toArray(result);
            fontID = result[0];
            //@TODO Just get the shortest one for the time being.
            if (candidates.size() > 1) {
                int i = 1;
                while (i < result.length) try {
                    if (result[i].length() < fontID.length()) {
                        fontID = result[i];
                    }
                } finally {
                    i++;
                }
            }
            return true;
        }
        return false;
    }

    @Override
    public String getFont() {
        String result = fontMappings.get(fontID);
        if (result == null && family != null && !isFontEmbedded) {
            result = fontMappings.get(family);
        }
        if (result == null && (fontMode == EMBED_ALL || fontMode == EMBED_ALL_EXCEPT_BASE_FAMILIES)) {
            //just pass through
            rawFont = rawFont.replaceAll("[.,@*#]", "-");
            result = rawFont;
        } else if (result != null && isFontEmbedded && fontMode == EMBED_ALL) {
            //  System.out.println(fontID+" "+result);
            result = fontID;
        }
        return (result == null) ? "" : result;
    }

    @Override
    public String getStyle() {
        if (isFontEmbedded) {
            style = "normal";
        }
        return style;
    }

    @Override
    public String getWeight() {
        if (isFontEmbedded) {
            weight = "normal";
        }
        return weight;
    }

    @Override
    public boolean isFontEmbedded() {
        return isFontEmbedded;
    }

    @Override
    public boolean isFontSubstituted() {
        return isFontSubstituted;
    }

    @Override
    public boolean equals(FontMapper fontMapper) {
        return this.getStyle().equals(fontMapper.getStyle()) && this.getFont().equals(fontMapper.getFont()) && this.getWeight().equals(fontMapper.getWeight()) && this.isFontEmbedded() == fontMapper.isFontEmbedded();
    }
}

```


Overlapping Code:
```
GenericFontMapper implements org.jpedal.render.output.FontMapper {
private static final String DEFAUN_UNMAPPED;
private boolean isFontEmbedded;
private boolean isFontSubstituted;
//list of font mappings to substitute fonts
public static final Map<String> fontMappings = new HashMap<String, String>();
public static final Map<String, Integer> fontSizeAdjustments = new HashMap<String, Integer>();
private static final Map<String, String> fontStle = new HashMap<String, String>();
private static final Map<String, String> fontWeight = new HashMaence: http://www.ampsoft.net/webdesign-l/WindowsMacFonts.html
final String arialType = "Arial, Helvetica, sans-serif";
final String arialBlackType = "'Arial Black', Gadget, sans-serif";
final String comicSansType = "'Comic Sans MS', Textile, cursive";
final String courierNewType = "'Courier New', Courier, monospace";
final String georgiaType = "Georgia, 'Times New Roman', Times, serif";
final String impactType = "Impact, Charcoal, sans-serif";
final String lucidaConsoleType = "'Lucida Console', Monaco, monospace";
final String lucidaSansType = "'Lucida Sans Unicode', 'Lucida Grande', sans-serif";
final String palatinoType = "'Palatino Linotype', 'Book Antiqua', Palatino, serif";
final String tahomaType = "Tahoma, Geneva, sans-serif";
final String romanType = "'Times New Roman', Times, serif";
final String trebuchetType = "'Trebuchet MS', Helvetica, sans-serif";
final String verdanaType = "Verdana, Geneva, sans-serif";
final String symbolType = "Symbol";
final String webdingsType = "Webdings";
final String wingdingsType = "Wingdings, 'Zapf Dingbats'";
final String msSansSerifType = "'MS Sans Serif', Geneva, sans-serif";
final String msSerifType = "'MS Serif', 'New York', serif";
final String helveticaType = "Helvetica, Arial, sans-ault fonts
fontMappings.put("Arial", arialType);
f
```
<Overlap Ratio: 0.8343141693073789>

---

--- 226 --
Question ID: c85862bd68af35280ddc23c32cb83bc91c2feb4e
Original Code:
```
public class PreconditionsTest {

    @Test
    public void test() {
        int i = new Random().nextInt();
        int j = new Random().nextInt();
        checkArgument(i >= 0, "Argument was %s but expected nonnegative", i);
        checkArgument(i < j, "Expected i < j, but %s > %s", i, j);
    }
}

```


Overlapping Code:
```
ublic class PreconditionsTest {
@Test
public void test() {
int i = new Random().nextInt();
int j = new Random().nextInt();
checkArgument(i >= 0, "Argument was %s but expected nonnegative", i);
checkArgument(i < j, "Expected i < j, but %s > %s", i, j);
}
```
<Overlap Ratio: 0.98828125>

---

--- 227 --
Question ID: 855941c331899e68cc0842119277b6bc04059a56
Original Code:
```
class TrueFalseQuestionTest {

    private static TrueFalseQuestion validTfQuestion = null;

    @BeforeEach
    void setUp() {
        Set<Choice> validTfqChoices = new HashSet<>();
        validTfqChoices.add(new Choice(TRUE_CHOICE_TITLE, false));
        validTfqChoices.add(new Choice(FALSE_CHOICE_TITLE, true));
        validTfQuestion = new TrueFalseQuestion(new Name(VALID_QUESTION_1), new Importance(VALID_IMPORTANCE_1), new HashSet<>(), validTfqChoices);
    }

    @Test
    void isValidQuestion_validAnswers_true() {
        assertTrue(validTfQuestion.isValidQuestion());
    }

    @Test
    void isValidTrueFalseChoice_validChoice_true() {
        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(TRUE_CHOICE_TITLE, false));
        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(FALSE_CHOICE_TITLE, true));
    }

    @Test
    void isValidTrueFalseChoice_invalidChoice_false() {
        TrueFalseQuestion.isValidTrueFalseChoice(new Choice(VALID_ANSWER_1, false));
    }
}

```


Overlapping Code:
```
eQuestionTest {
private static TrueFalseQuestion validTfQuestion = null;
@BeforeEach
void setUp() {
Set<Choice> validTfqChoices = new HashSet<>();
validTfqChoices.add(new Choice(TRUE_CHOICE_TITLE, false));
validTfqChoices.add(new Choice(FALSE_CHOICE_TITLE, true));
validTfQuestion = new TrueFalseQuestion(new Name(VALID_QUESTION_1), new Importance(VALID_IMPORTANCE_1), new HashSet<>(), validTfqChoices);
}
@Test
void isValidQuestion_validAnswers_true() {
assertTrue(validTfQuestion.isValidQuestion());
}
@Test
void isValidTrueFalseChoice_validChoice_true() {
TrueFalseQuestion.isValidTrueFalseChoice(new Choice(TRUE_CHOICE_TITLE, false));
TrueFalseQuestion.isValidTrueFalseChoice(new Choice(FALSE_CHOICE_TITLE, true));
}
@Test
void isValidTrueFalseChoice_invalidChoice_false() {
TrueFalseQuestion.isValidTrueFalseChoice(new Choice(VALID_ANSWER_1, fal
```
<Overlap Ratio: 0.9736540664375716>

---

--- 228 --
Question ID: 2f37e0e31a286e088d15fb05e86f8bfa506763a6
Original Code:
```
public class NettyTransportServer implements NettyChannelRegistry, MessageReceiver, TransportServerComponent {

    private static final Logger LOG = Logger.getLogger(NettyTransportServer.class.getName());

    private ServerBootstrap serverBootstrap;

    private Channel serverChannel;

    private EndpointService endpointService;

    private AtomicBoolean started = new AtomicBoolean(false);

    private PeerGroup group;

    private PeerGroupID homeGroupID;

    private PeerID localPeerID;

    private MessengerEventListener listener;

    private List<EndpointAddress> publicAddresses;

    private AddressTranslator addrTranslator;

    private ChannelGroup channels;

    private HashedWheelTimer timeoutTimer;

    private ChannelGroupFuture closeChannelsFuture;

    private List<EndpointAddress> boundAddresses;

    public NettyTransportServer(ServerChannelFactory factory, AddressTranslator addrTranslator, final PeerGroup group) {
        this.channels = new DefaultChannelGroup();
        this.group = group;
        this.homeGroupID = group.getPeerGroupID();
        this.localPeerID = group.getPeerID();
        this.addrTranslator = addrTranslator;
        serverBootstrap = new ServerBootstrap(factory);
        serverBootstrap.setParentHandler(new ConnectionGroupAddHandler());
        timeoutTimer = new HashedWheelTimer();
    }

    public void init(List<? extends SocketAddress> potentialBindpoints, EndpointAddress publicAddress, boolean usePublicOnly) throws PeerGroupException {
        serverBootstrap.setPipelineFactory(new NettyTransportChannelPipelineFactory(group, localPeerID, timeoutTimer, this, addrTranslator, started, null, publicAddress));
        SocketAddress chosenAddress = bindServerChannel(potentialBindpoints);
        boundAddresses = Collections.unmodifiableList(addrTranslator.translateToExternalAddresses(chosenAddress));
        if (serverChannel == null) {
            Logging.logCheckedWarning(LOG, "Failed to bind to any of the addresses in the configured range");
            throw new PeerGroupException("Failed to bind to any address in the configured range");
        }
        if (usePublicOnly) {
            if (publicAddress == null) {
                Logging.logCheckedWarning(LOG, "Instructed to use public address only, but no public address specified! Using all bound addresses instead");
                publicAddresses = new ArrayList<EndpointAddress>(boundAddresses);
            } else {
                publicAddresses = new ArrayList<EndpointAddress>(1);
                publicAddresses.add(publicAddress);
            }
        } else {
            int size = boundAddresses.size() + ((publicAddress != null) ? 1 : 0);
            publicAddresses = new ArrayList<EndpointAddress>(size);
            if (publicAddress != null) {
                publicAddresses.add(publicAddress);
            }
            publicAddresses.addAll(boundAddresses);
        }
    }

    private SocketAddress bindServerChannel(List<? extends SocketAddress> potentialBindpoints) {
        for (SocketAddress nextBP : potentialBindpoints) {
            try {
                serverChannel = serverBootstrap.bind(nextBP);
                channels.add(serverChannel);
                return nextBP;
            } catch (ChannelException e) {
                String failReason = (e.getCause() != null) ? e.getCause().getMessage() : e.getMessage();
                Logging.logCheckedInfo(LOG, "Attempt to bind to ", nextBP, " failed (", failReason, "), trying another address");
            }
        }
        return null;
    }

    public boolean start(EndpointService endpointService) throws IllegalStateException {
        if (started.get()) {
            throw new IllegalStateException("already started");
        }
        this.endpointService = endpointService;
        listener = endpointService.addMessageTransport(this);
        if (listener == null) {
            Logging.logCheckedSevere(LOG, "Transport registration failed for netty transport server, protocol=", addrTranslator.getProtocolName());
            return false;
        }
        started.set(true);
        return true;
    }

    public void beginStop() {
        if (!started.compareAndSet(true, false)) {
            Logging.logCheckedWarning(LOG, "Netty transport server for protocol ", addrTranslator.getProtocolName(), " already stopped or never started!");
            return;
        }
        closeChannelsFuture = channels.close();
    }

    public void stop() throws IllegalStateException {
        if (closeChannelsFuture != null) {
            closeChannelsFuture.awaitUninterruptibly();
        }
        serverChannel = null;
        serverBootstrap.releaseExternalResources();
        timeoutTimer.stop();
    }

    public void newConnection(Channel channel, EndpointAddress directedAt, EndpointAddress logicalEndpointAddress) {
        // NettyMessenger messenger = new NettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);
        AsynchronousNettyMessenger messenger = new AsynchronousNettyMessenger(channel, homeGroupID, localPeerID, directedAt, logicalEndpointAddress, endpointService);
        listener.messengerReady(new MessengerEvent(this, messenger, messenger.getDestinationAddress()));
    }

    public Iterator<EndpointAddress> getPublicAddresses() {
        return publicAddresses.iterator();
    }

    public EndpointService getEndpointService() {
        return endpointService;
    }

    public String getProtocolName() {
        return addrTranslator.getProtocolName();
    }

    @Sharable
    private final class ConnectionGroupAddHandler extends SimpleChannelUpstreamHandler {

        @Override
        public void childChannelOpen(ChannelHandlerContext ctx, ChildChannelStateEvent e) throws Exception {
            Logging.logCheckedFine(LOG, String.format("Incoming connection for transport %s from %s to %s (handled by %s)", getProtocolName(), e.getChildChannel().getRemoteAddress(), e.getChildChannel().getLocalAddress(), ctx.getChannel().getLocalAddress()));
            channels.add(e.getChildChannel());
            super.childChannelOpen(ctx, e);
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
            // ServerBootstrap, and handled in in bindServerChannel()
            if (!(e.getCause() instanceof BindException)) {
                LOG.log(Level.WARNING, "Unexpected exception on server channel for {0} protocol:\n{1}", new Object[] { getProtocolName(), e.getCause() });
            }
        }
    }

    public boolean isStarted() {
        return started.get();
    }

    /**
     * @return the physically bound addresses for this transport, as opposed to those which are
     * broadcasted to external peers.
     */
    public List<EndpointAddress> getBoundAddresses() {
        return boundAddresses;
    }
}

```


Overlapping Code:
```
rver implements NettyChannelRegistry, MessageReceiver, TransportServerComponent {
private static final Logger LOG = Logger.getLogger(NettyTransportSer);
private ServerBootstrap serverBootstrap;
private Channel serverChannel;
privae;
private AtomicBoolean started = new AtomicBoolean(false);
private PeerGroup group;
private PeerGroupID homeGroupID;
private PeerID localPeerIventListener listener;
private List<EndpointAddress> publicAddresses;
private AddressTranslator addrannelGroup channels;
private HashedWheelTimer timeoutTimer;
private ChannelGroupFuture closeChannelsFuture;
private List<Endpoierver(ServerChannelFactory factory, AddressTranslator addrTranslator, final PeerGroup group) {
this.channels = new DefaultChannelGroup();
this.group = group;
this.homeGroupID = group.getPeerGroupID();
this.localPeerID = group.getPeerID();
this.addrTranslator = addrTranslator;
serverBootstrap = new ServerBootstrap(factory);
serverBootstrap.setParentHandler(new ConnectionGroupAddHandler());
timeoutT(List<? extends SocketAddress> potentialBindpoints, EndpointAddress publicAddress, boolean usePublicOnly) throws PeerGroupException {
serverBootstrap.setPipelineFactory(new NettyTransportChannelPipelineFactory(group, localPeerID, timeoutTimer, this, addrTranslator, started, null, publicAddress));
SocketAddress chosenAddress = bindServerChannel(potentialBindpoints);
boundAddresses = Collections.unmodifiableList(addrTranslator.translateToExternalAd) {
Logging.logCheckedWarning(LOG, "Failed to bind to any of the addresses in the configured range");
throw new PeerGroupException("Failed to bind to gCheckedWarning(LOG, "Instructed to use public address only, but no public address specified! Using all bound addresses instead");
publicAddresses = new ArrayList<EndpointAddress>(boundAddresses);
} e
```
<Overlap Ratio: 0.8182644252612449>

---

--- 229 --
Question ID: 8443c954494c6c6baca7fbd14f3c738d5cd75922
Original Code:
```
public class DesktopRuntimeEnginePluginRoot extends AbstractPlugin implements DesktopRuntimeManager {

    @NeededAddonReference(platform = Platforms.PLUG_INS_PLATFORM, layer = Layers.PLATFORM_SERVICE, addon = Addons.EVENT_MANAGER)
    private EventManager eventManager;

    /**
     * SubAppRuntimeManager Interface member variables.
     */
    List<FermatEventListener> listenersAdded = new ArrayList<>();

    List<DesktopObject> lstDesktops = new ArrayList<DesktopObject>();

    /**
     * Last desktop-object
     */
    String lastDesktopObject;

    public DesktopRuntimeEnginePluginRoot() {
        super(new PluginVersionReference(new Version()));
    }

    @Override
    public void start() throws CantStartPluginException {
        try {
            /**
             * At this time the only thing I can do is a factory reset. Once there should be a possibility to add
             * functionality based on wallets downloaded by users this wont be an option.
             * * *
             */
            factoryReset();
            this.serviceStatus = ServiceStatus.STARTED;
        } catch (CantFactoryResetException ex) {
            String message = CantStartPluginException.DEFAULT_MESSAGE;
            FermatException cause = ex;
            String context = "App Runtime Start";
            String possibleReason = "Some null definition";
            throw new CantStartPluginException(message, cause, context, possibleReason);
        } catch (Exception exception) {
            throw new CantStartPluginException(CantStartPluginException.DEFAULT_MESSAGE, FermatException.wrapException(exception), null, "Unchecked Exception occurred, check the cause");
        }
    }

    @Override
    public void stop() {
        /**
         * I will remove all the listeners registered with the event manager.
         */
        for (FermatEventListener eventListener : listenersAdded) {
            eventManager.removeListener(eventListener);
        }
        listenersAdded.clear();
        this.serviceStatus = ServiceStatus.STOPPED;
    }

    /**
     * AppRuntime Interface implementation.
     */
    @Override
    public DesktopObject getLastDesktopObject() {
        if (lastDesktopObject != null) {
            return lstDesktops.get(0);
        }
        return null;
    }

    @Override
    public DesktopObject getDesktopObject(String desktopObjectType) {
        //TODO METODO CON RETURN NULL - OJO: solo INFORMATIVO de ayuda VISUAL para DEBUG - Eliminar si molesta
        return null;
    }

    @Override
    public List<DesktopObject> listDesktops() {
        return lstDesktops;
    }

    /**
     * Here is where I actually generate the factory structure of the APP. This method is also useful to reset to the
     * factory structure.
     */
    private void factoryReset() throws CantFactoryResetException {
        try {
            // = new RuntimeDesktopObject();
            RuntimeDesktopObject runtimeDesktopObject;
            //= new Activity();
            Activity runtimeActivity;
            //= new Fragment();
            Fragment runtimeFragment;
            TitleBar runtimeTitleBar;
            SideMenu runtimeSideMenu;
            MainMenu runtimeMainMenu;
            MenuItem runtimeMenuItem;
            TabStrip runtimeTabStrip;
            StatusBar statusBar;
            Tab runtimeTab;
            runtimeDesktopObject = new RuntimeDesktopObject();
            runtimeDesktopObject.setType("DCCP");
            lastDesktopObject = runtimeDesktopObject.getType();
            runtimeDesktopObject.setStartActivity(Activities.CCP_DESKTOP);
            Activity activity = new Activity();
            //activity.setType(Activities.dmp_DESKTOP_HOME);
            activity.setActivityType("CCPDHA");
            Fragment fragment = new Fragment();
            runtimeDesktopObject.addActivity(activity);
            // dmp_WALLET_MANAGER_FRAGMENT
            fragment.setType("CCPWMF");
            activity.addFragment("CCPWMF", fragment);
            runtimeDesktopObject.setStartActivity(activity.getType());
            fragment = new Fragment();
            // dmp_SUB_APP_MANAGER_FRAGMENT
            fragment.setType("CCPSAMF");
            activity.addFragment("CCPSAMF", fragment);
            lstDesktops.add(runtimeDesktopObject);
            runtimeDesktopObject = new RuntimeDesktopObject();
            runtimeDesktopObject.setType("WPD");
            lstDesktops.add(runtimeDesktopObject);
            runtimeDesktopObject.setStartActivity(Activities.WPD_DESKTOP);
            activity = new Activity();
            //activity.setType(Activities.dmp_DESKTOP_HOME);
            activity.setActivityType("WPD");
            fragment = new Fragment();
            // dmp_SUB_APP_MANAGER_FRAGMENT
            fragment.setType("CCPSAMF");
            activity.addFragment("CCPSAMF", fragment);
            runtimeDesktopObject.addActivity(activity);
            runtimeDesktopObject = new RuntimeDesktopObject();
            runtimeDesktopObject.setType("DDAP");
            lstDesktops.add(runtimeDesktopObject);
            runtimeDesktopObject.setStartActivity(Activities.DAP_DESKTOP);
            activity = new Activity();
            //activity.setType(Activities.dmp_DESKTOP_HOME);
            activity.setActivityType("DAPDHA");
            fragment = new Fragment();
            // dmp_WALLET_MANAGER_FRAGMENT
            fragment.setType("DAPWMF");
            activity.addFragment("DAPWMF", fragment);
            runtimeDesktopObject.addActivity(activity);
            fragment = new Fragment();
            // dmp_SUB_APP_MANAGER_FRAGMENT
            fragment.setType("DAPSAMF");
            activity.addFragment("DAPSAMF", fragment);
            runtimeDesktopObject.addActivity(activity);
            runtimeDesktopObject = new RuntimeDesktopObject();
            runtimeDesktopObject.setType("DCBP");
            lstDesktops.add(runtimeDesktopObject);
            runtimeDesktopObject.setStartActivity(Activities.CBP_DESKTOP);
            activity = new Activity();
            //activity.setType(Activities.dmp_DESKTOP_HOME);
            activity.setActivityType("CBPDHA");
            fragment = new Fragment();
            runtimeDesktopObject.addActivity(activity);
            // dmp_WALLET_MANAGER_FRAGMENT
            fragment.setType("CBPWMF");
            activity.addFragment("CBPWMF", fragment);
            runtimeDesktopObject.addActivity(activity);
            fragment = new Fragment();
            // dmp_SUB_APP_MANAGER_FRAGMENT
            fragment.setType("CBPSAMF");
            activity.addFragment("CBPSAMF", fragment);
            runtimeDesktopObject.addActivity(activity);
        } catch (Exception e) {
            String message = CantFactoryResetException.DEFAULT_MESSAGE;
            FermatException cause = FermatException.wrapException(e);
            String context = "Error on method Factory Reset, setting the structure of the apps";
            String possibleReason = "some null definition";
            throw new CantFactoryResetException(message, cause, context, possibleReason);
        }
    }
}

```


Overlapping Code:
```
 extends AbstractPlugin implements DesktopRuntimeManager {
@NeededAddonReference(platform = Platforms.PLUG_INS_PLATFORM, layer = Layers.PLATFORM_SERVICE, addon = Addons.EVENT_MANAGER)
private EventManager eventManager;
/**
* SubAppRuntimeManager Interface member variables.
*/
List<FermatEventListener> listenersAdded = new ArrayList<>();
t<DesktopObject> lstDesktops = new ArrayList<DesktopObject>();
/**
* Last desktop-object
*/
String lastDesktopObject;
public DesktopRuntimeEnginePluginRoot() {
super(new PluginVersionReference(new Version()));
}
@Override
public void start() throws CantStartPluginException {
try {
/**
* At this time the only thing I can do is a factory reset. Once there should be a possibility to add
* functionality based on wallets downloaded by users this wont be an option.
* * *
*/
factoryReset();
this.serviceStatus = ServiceStatus.STARTED;
} catch (CantFactoryResetException ex) {
String message = CantStartPluginException.DEFAULT_MESSAGE;
FermatException cause = ex;
String context = "App Runtime Start";
String possibleReason = "Some null definition";
throw new CantStartPluginException(message, cause, context, possibleReason);
} catch (Exception exception) {
throw new CantStartPluginException(CantStartPluginException.DEFAULT_MESSAGE, FermatException.wrapException(exception), null, "Unchecked Exception occurred, check the cause");
}
}
@Override
public void stop() {
/**
* I will remove all the listeners registered with the event manager.
*/
for (FermatEventListener eventListener : listenersAdded) {
eventManager.removeListener(eventListener);
}
listenersAdded.clear();
this.serviceStatus = ServiceStatus.STOPPED;
}
/**
* AppRuntime Interface implementation.
*/
@Override
public DesktopObject getLastDesktopObject() {
if (lastDesktopObject != null) {
return lstDesktops.get(0tType) {
//TODO METODO CON RETURN NULL - OJO: solo INFORMATIVO de ayuda VISUAL para DEBUG - Eliminar si molest
```
<Overlap Ratio: 0.9349198640116562>

---

--- 230 --
Question ID: 883288933fee1f2b5717071cb2d9eba2723d9d39
Original Code:
```
public class TCRMPhoneNumberBObjType extends CommonBObjType implements java.io.Serializable {

    private java.lang.String objectReferenceId;

    private java.lang.String phoneNumberId;

    private java.lang.String contactMethodId;

    private java.lang.String phoneCountryCode;

    private java.lang.String phoneAreaCode;

    private java.lang.String phoneExchange;

    private java.lang.String phoneNumber;

    private java.lang.String phoneExtension;

    private java.lang.String phoneLastUpdateDate;

    private java.lang.String phoneLastUpdateUser;

    private java.lang.String phoneLastUpdateTxId;

    private TCRMExtension TCRMExtension;

    private PrimaryKeyBObj primaryKeyBObj;

    private java.lang.String phoneHistActionCode;

    private java.lang.String phoneHistCreateDate;

    private java.lang.String phoneHistCreatedBy;

    private java.lang.String phoneHistEndDate;

    private java.lang.String phoneHistoryIdPK;

    private DWLStatus DWLStatus;

    public TCRMPhoneNumberBObjType() {
    }

    public TCRMPhoneNumberBObjType(java.lang.String objectReferenceId, java.lang.String phoneNumberId, java.lang.String contactMethodId, java.lang.String phoneCountryCode, java.lang.String phoneAreaCode, java.lang.String phoneExchange, java.lang.String phoneNumber, java.lang.String phoneExtension, java.lang.String phoneLastUpdateDate, java.lang.String phoneLastUpdateUser, java.lang.String phoneLastUpdateTxId, TCRMExtension TCRMExtension, PrimaryKeyBObj primaryKeyBObj, java.lang.String phoneHistActionCode, java.lang.String phoneHistCreateDate, java.lang.String phoneHistCreatedBy, java.lang.String phoneHistEndDate, java.lang.String phoneHistoryIdPK, DWLStatus DWLStatus) {
        this.objectReferenceId = objectReferenceId;
        this.phoneNumberId = phoneNumberId;
        this.contactMethodId = contactMethodId;
        this.phoneCountryCode = phoneCountryCode;
        this.phoneAreaCode = phoneAreaCode;
        this.phoneExchange = phoneExchange;
        this.phoneNumber = phoneNumber;
        this.phoneExtension = phoneExtension;
        this.phoneLastUpdateDate = phoneLastUpdateDate;
        this.phoneLastUpdateUser = phoneLastUpdateUser;
        this.phoneLastUpdateTxId = phoneLastUpdateTxId;
        this.TCRMExtension = TCRMExtension;
        this.primaryKeyBObj = primaryKeyBObj;
        this.phoneHistActionCode = phoneHistActionCode;
        this.phoneHistCreateDate = phoneHistCreateDate;
        this.phoneHistCreatedBy = phoneHistCreatedBy;
        this.phoneHistEndDate = phoneHistEndDate;
        this.phoneHistoryIdPK = phoneHistoryIdPK;
        this.DWLStatus = DWLStatus;
    }

    /**
     * Gets the objectReferenceId value for this TCRMPhoneNumberBObjType.
     *
     * @return objectReferenceId
     */
    public java.lang.String getObjectReferenceId() {
        return objectReferenceId;
    }

    /**
     * Sets the objectReferenceId value for this TCRMPhoneNumberBObjType.
     *
     * @param objectReferenceId
     */
    public void setObjectReferenceId(java.lang.String objectReferenceId) {
        this.objectReferenceId = objectReferenceId;
    }

    /**
     * Gets the phoneNumberId value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneNumberId
     */
    public java.lang.String getPhoneNumberId() {
        return phoneNumberId;
    }

    /**
     * Sets the phoneNumberId value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneNumberId
     */
    public void setPhoneNumberId(java.lang.String phoneNumberId) {
        this.phoneNumberId = phoneNumberId;
    }

    /**
     * Gets the contactMethodId value for this TCRMPhoneNumberBObjType.
     *
     * @return contactMethodId
     */
    public java.lang.String getContactMethodId() {
        return contactMethodId;
    }

    /**
     * Sets the contactMethodId value for this TCRMPhoneNumberBObjType.
     *
     * @param contactMethodId
     */
    public void setContactMethodId(java.lang.String contactMethodId) {
        this.contactMethodId = contactMethodId;
    }

    /**
     * Gets the phoneCountryCode value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneCountryCode
     */
    public java.lang.String getPhoneCountryCode() {
        return phoneCountryCode;
    }

    /**
     * Sets the phoneCountryCode value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneCountryCode
     */
    public void setPhoneCountryCode(java.lang.String phoneCountryCode) {
        this.phoneCountryCode = phoneCountryCode;
    }

    /**
     * Gets the phoneAreaCode value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneAreaCode
     */
    public java.lang.String getPhoneAreaCode() {
        return phoneAreaCode;
    }

    /**
     * Sets the phoneAreaCode value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneAreaCode
     */
    public void setPhoneAreaCode(java.lang.String phoneAreaCode) {
        this.phoneAreaCode = phoneAreaCode;
    }

    /**
     * Gets the phoneExchange value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneExchange
     */
    public java.lang.String getPhoneExchange() {
        return phoneExchange;
    }

    /**
     * Sets the phoneExchange value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneExchange
     */
    public void setPhoneExchange(java.lang.String phoneExchange) {
        this.phoneExchange = phoneExchange;
    }

    /**
     * Gets the phoneNumber value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneNumber
     */
    public java.lang.String getPhoneNumber() {
        return phoneNumber;
    }

    /**
     * Sets the phoneNumber value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneNumber
     */
    public void setPhoneNumber(java.lang.String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    /**
     * Gets the phoneExtension value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneExtension
     */
    public java.lang.String getPhoneExtension() {
        return phoneExtension;
    }

    /**
     * Sets the phoneExtension value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneExtension
     */
    public void setPhoneExtension(java.lang.String phoneExtension) {
        this.phoneExtension = phoneExtension;
    }

    /**
     * Gets the phoneLastUpdateDate value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneLastUpdateDate
     */
    public java.lang.String getPhoneLastUpdateDate() {
        return phoneLastUpdateDate;
    }

    /**
     * Sets the phoneLastUpdateDate value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneLastUpdateDate
     */
    public void setPhoneLastUpdateDate(java.lang.String phoneLastUpdateDate) {
        this.phoneLastUpdateDate = phoneLastUpdateDate;
    }

    /**
     * Gets the phoneLastUpdateUser value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneLastUpdateUser
     */
    public java.lang.String getPhoneLastUpdateUser() {
        return phoneLastUpdateUser;
    }

    /**
     * Sets the phoneLastUpdateUser value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneLastUpdateUser
     */
    public void setPhoneLastUpdateUser(java.lang.String phoneLastUpdateUser) {
        this.phoneLastUpdateUser = phoneLastUpdateUser;
    }

    /**
     * Gets the phoneLastUpdateTxId value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneLastUpdateTxId
     */
    public java.lang.String getPhoneLastUpdateTxId() {
        return phoneLastUpdateTxId;
    }

    /**
     * Sets the phoneLastUpdateTxId value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneLastUpdateTxId
     */
    public void setPhoneLastUpdateTxId(java.lang.String phoneLastUpdateTxId) {
        this.phoneLastUpdateTxId = phoneLastUpdateTxId;
    }

    /**
     * Gets the TCRMExtension value for this TCRMPhoneNumberBObjType.
     *
     * @return TCRMExtension
     */
    public TCRMExtension getTCRMExtension() {
        return TCRMExtension;
    }

    /**
     * Sets the TCRMExtension value for this TCRMPhoneNumberBObjType.
     *
     * @param TCRMExtension
     */
    public void setTCRMExtension(TCRMExtension TCRMExtension) {
        this.TCRMExtension = TCRMExtension;
    }

    /**
     * Gets the primaryKeyBObj value for this TCRMPhoneNumberBObjType.
     *
     * @return primaryKeyBObj
     */
    public PrimaryKeyBObj getPrimaryKeyBObj() {
        return primaryKeyBObj;
    }

    /**
     * Sets the primaryKeyBObj value for this TCRMPhoneNumberBObjType.
     *
     * @param primaryKeyBObj
     */
    public void setPrimaryKeyBObj(PrimaryKeyBObj primaryKeyBObj) {
        this.primaryKeyBObj = primaryKeyBObj;
    }

    /**
     * Gets the phoneHistActionCode value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneHistActionCode
     */
    public java.lang.String getPhoneHistActionCode() {
        return phoneHistActionCode;
    }

    /**
     * Sets the phoneHistActionCode value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneHistActionCode
     */
    public void setPhoneHistActionCode(java.lang.String phoneHistActionCode) {
        this.phoneHistActionCode = phoneHistActionCode;
    }

    /**
     * Gets the phoneHistCreateDate value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneHistCreateDate
     */
    public java.lang.String getPhoneHistCreateDate() {
        return phoneHistCreateDate;
    }

    /**
     * Sets the phoneHistCreateDate value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneHistCreateDate
     */
    public void setPhoneHistCreateDate(java.lang.String phoneHistCreateDate) {
        this.phoneHistCreateDate = phoneHistCreateDate;
    }

    /**
     * Gets the phoneHistCreatedBy value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneHistCreatedBy
     */
    public java.lang.String getPhoneHistCreatedBy() {
        return phoneHistCreatedBy;
    }

    /**
     * Sets the phoneHistCreatedBy value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneHistCreatedBy
     */
    public void setPhoneHistCreatedBy(java.lang.String phoneHistCreatedBy) {
        this.phoneHistCreatedBy = phoneHistCreatedBy;
    }

    /**
     * Gets the phoneHistEndDate value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneHistEndDate
     */
    public java.lang.String getPhoneHistEndDate() {
        return phoneHistEndDate;
    }

    /**
     * Sets the phoneHistEndDate value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneHistEndDate
     */
    public void setPhoneHistEndDate(java.lang.String phoneHistEndDate) {
        this.phoneHistEndDate = phoneHistEndDate;
    }

    /**
     * Gets the phoneHistoryIdPK value for this TCRMPhoneNumberBObjType.
     *
     * @return phoneHistoryIdPK
     */
    public java.lang.String getPhoneHistoryIdPK() {
        return phoneHistoryIdPK;
    }

    /**
     * Sets the phoneHistoryIdPK value for this TCRMPhoneNumberBObjType.
     *
     * @param phoneHistoryIdPK
     */
    public void setPhoneHistoryIdPK(java.lang.String phoneHistoryIdPK) {
        this.phoneHistoryIdPK = phoneHistoryIdPK;
    }

    /**
     * Gets the DWLStatus value for this TCRMPhoneNumberBObjType.
     *
     * @return DWLStatus
     */
    public DWLStatus getDWLStatus() {
        return DWLStatus;
    }

    /**
     * Sets the DWLStatus value for this TCRMPhoneNumberBObjType.
     *
     * @param DWLStatus
     */
    public void setDWLStatus(DWLStatus DWLStatus) {
        this.DWLStatus = DWLStatus;
    }

    private java.lang.Object __equalsCalc = null;

    public synchronized boolean equals(java.lang.Object obj) {
        if (!(obj instanceof TCRMPhoneNumberBObjType))
            return false;
        TCRMPhoneNumberBObjType other = (TCRMPhoneNumberBObjType) obj;
        if (obj == null)
            return false;
        if (this == obj)
            return true;
        if (__equalsCalc != null) {
            return (__equalsCalc == obj);
        }
        __equalsCalc = obj;
        boolean _equals;
        _equals = super.equals(obj) && ((this.objectReferenceId == null && other.getObjectReferenceId() == null) || (this.objectReferenceId != null && this.objectReferenceId.equals(other.getObjectReferenceId()))) && ((this.phoneNumberId == null && other.getPhoneNumberId() == null) || (this.phoneNumberId != null && this.phoneNumberId.equals(other.getPhoneNumberId()))) && ((this.contactMethodId == null && other.getContactMethodId() == null) || (this.contactMethodId != null && this.contactMethodId.equals(other.getContactMethodId()))) && ((this.phoneCountryCode == null && other.getPhoneCountryCode() == null) || (this.phoneCountryCode != null && this.phoneCountryCode.equals(other.getPhoneCountryCode()))) && ((this.phoneAreaCode == null && other.getPhoneAreaCode() == null) || (this.phoneAreaCode != null && this.phoneAreaCode.equals(other.getPhoneAreaCode()))) && ((this.phoneExchange == null && other.getPhoneExchange() == null) || (this.phoneExchange != null && this.phoneExchange.equals(other.getPhoneExchange()))) && ((this.phoneNumber == null && other.getPhoneNumber() == null) || (this.phoneNumber != null && this.phoneNumber.equals(other.getPhoneNumber()))) && ((this.phoneExtension == null && other.getPhoneExtension() == null) || (this.phoneExtension != null && this.phoneExtension.equals(other.getPhoneExtension()))) && ((this.phoneLastUpdateDate == null && other.getPhoneLastUpdateDate() == null) || (this.phoneLastUpdateDate != null && this.phoneLastUpdateDate.equals(other.getPhoneLastUpdateDate()))) && ((this.phoneLastUpdateUser == null && other.getPhoneLastUpdateUser() == null) || (this.phoneLastUpdateUser != null && this.phoneLastUpdateUser.equals(other.getPhoneLastUpdateUser()))) && ((this.phoneLastUpdateTxId == null && other.getPhoneLastUpdateTxId() == null) || (this.phoneLastUpdateTxId != null && this.phoneLastUpdateTxId.equals(other.getPhoneLastUpdateTxId()))) && ((this.TCRMExtension == null && other.getTCRMExtension() == null) || (this.TCRMExtension != null && this.TCRMExtension.equals(other.getTCRMExtension()))) && ((this.primaryKeyBObj == null && other.getPrimaryKeyBObj() == null) || (this.primaryKeyBObj != null && this.primaryKeyBObj.equals(other.getPrimaryKeyBObj()))) && ((this.phoneHistActionCode == null && other.getPhoneHistActionCode() == null) || (this.phoneHistActionCode != null && this.phoneHistActionCode.equals(other.getPhoneHistActionCode()))) && ((this.phoneHistCreateDate == null && other.getPhoneHistCreateDate() == null) || (this.phoneHistCreateDate != null && this.phoneHistCreateDate.equals(other.getPhoneHistCreateDate()))) && ((this.phoneHistCreatedBy == null && other.getPhoneHistCreatedBy() == null) || (this.phoneHistCreatedBy != null && this.phoneHistCreatedBy.equals(other.getPhoneHistCreatedBy()))) && ((this.phoneHistEndDate == null && other.getPhoneHistEndDate() == null) || (this.phoneHistEndDate != null && this.phoneHistEndDate.equals(other.getPhoneHistEndDate()))) && ((this.phoneHistoryIdPK == null && other.getPhoneHistoryIdPK() == null) || (this.phoneHistoryIdPK != null && this.phoneHistoryIdPK.equals(other.getPhoneHistoryIdPK()))) && ((this.DWLStatus == null && other.getDWLStatus() == null) || (this.DWLStatus != null && this.DWLStatus.equals(other.getDWLStatus())));
        __equalsCalc = null;
        return _equals;
    }

    private boolean __hashCodeCalc = false;

    public synchronized int hashCode() {
        if (__hashCodeCalc) {
            return 0;
        }
        __hashCodeCalc = true;
        int _hashCode = super.hashCode();
        if (getObjectReferenceId() != null) {
            _hashCode += getObjectReferenceId().hashCode();
        }
        if (getPhoneNumberId() != null) {
            _hashCode += getPhoneNumberId().hashCode();
        }
        if (getContactMethodId() != null) {
            _hashCode += getContactMethodId().hashCode();
        }
        if (getPhoneCountryCode() != null) {
            _hashCode += getPhoneCountryCode().hashCode();
        }
        if (getPhoneAreaCode() != null) {
            _hashCode += getPhoneAreaCode().hashCode();
        }
        if (getPhoneExchange() != null) {
            _hashCode += getPhoneExchange().hashCode();
        }
        if (getPhoneNumber() != null) {
            _hashCode += getPhoneNumber().hashCode();
        }
        if (getPhoneExtension() != null) {
            _hashCode += getPhoneExtension().hashCode();
        }
        if (getPhoneLastUpdateDate() != null) {
            _hashCode += getPhoneLastUpdateDate().hashCode();
        }
        if (getPhoneLastUpdateUser() != null) {
            _hashCode += getPhoneLastUpdateUser().hashCode();
        }
        if (getPhoneLastUpdateTxId() != null) {
            _hashCode += getPhoneLastUpdateTxId().hashCode();
        }
        if (getTCRMExtension() != null) {
            _hashCode += getTCRMExtension().hashCode();
        }
        if (getPrimaryKeyBObj() != null) {
            _hashCode += getPrimaryKeyBObj().hashCode();
        }
        if (getPhoneHistActionCode() != null) {
            _hashCode += getPhoneHistActionCode().hashCode();
        }
        if (getPhoneHistCreateDate() != null) {
            _hashCode += getPhoneHistCreateDate().hashCode();
        }
        if (getPhoneHistCreatedBy() != null) {
            _hashCode += getPhoneHistCreatedBy().hashCode();
        }
        if (getPhoneHistEndDate() != null) {
            _hashCode += getPhoneHistEndDate().hashCode();
        }
        if (getPhoneHistoryIdPK() != null) {
            _hashCode += getPhoneHistoryIdPK().hashCode();
        }
        if (getDWLStatus() != null) {
            _hashCode += getDWLStatus().hashCode();
        }
        __hashCodeCalc = false;
        return _hashCode;
    }

    // Type metadata
    private static org.apache.axis.description.TypeDesc typeDesc = new org.apache.axis.description.TypeDesc(TCRMPhoneNumberBObjType.class, true);

    static {
        typeDesc.setXmlType(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "TCRMPhoneNumberBObjType"));
        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("objectReferenceId");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "ObjectReferenceId"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneNumberId");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneNumberId"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("contactMethodId");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "ContactMethodId"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneCountryCode");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneCountryCode"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneAreaCode");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneAreaCode"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneExchange");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneExchange"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneNumber");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneNumber"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneExtension");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneExtension"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneLastUpdateDate");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneLastUpdateDate"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneLastUpdateUser");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneLastUpdateUser"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneLastUpdateTxId");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneLastUpdateTxId"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("TCRMExtension");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "TCRMExtension"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", ">TCRMExtension"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("primaryKeyBObj");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PrimaryKeyBObj"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", ">PrimaryKeyBObj"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneHistActionCode");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneHistActionCode"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneHistCreateDate");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneHistCreateDate"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneHistCreatedBy");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneHistCreatedBy"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneHistEndDate");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneHistEndDate"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("phoneHistoryIdPK");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "PhoneHistoryIdPK"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.w3.org/2001/XMLSchema", "string"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
        elemField = new org.apache.axis.description.ElementDesc();
        elemField.setFieldName("DWLStatus");
        elemField.setXmlName(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", "DWLStatus"));
        elemField.setXmlType(new javax.xml.namespace.QName("http://www.ibm.com/mdm/schema", ">DWLStatus"));
        elemField.setMinOccurs(0);
        elemField.setNillable(false);
        typeDesc.addFieldDesc(elemField);
    }

    /**
     * Return type metadata object
     */
    public static org.apache.axis.description.TypeDesc getTypeDesc() {
        return typeDesc;
    }

    /**
     * Get Custom Serializer
     */
    public static org.apache.axis.encoding.Serializer getSerializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {
        return new org.apache.axis.encoding.ser.BeanSerializer(_javaType, _xmlType, typeDesc);
    }

    /**
     * Get Custom Deserializer
     */
    public static org.apache.axis.encoding.Deserializer getDeserializer(java.lang.String mechType, java.lang.Class _javaType, javax.xml.namespace.QName _xmlType) {
        return new org.apache.axis.encoding.ser.BeanDeserializer(_javaType, _xmlType, typeDesc);
    }
}

```


Overlapping Code:
```
PhoneNumberBObjType extends CommonBObjType implements java.io.Serializable {
private java.lang.String objectReferenceId;
private java.lang.String phoneNumberId;
private java.lang.String contactMethodId;
private java.lang.String phoneCountryCode;
private java.lang.String phoneAreaCode;
private java.lang.String phoneExchange;
private java.lang.String phoneNumber;
private java.lang.String phoneExtension;
private java.lang.String phoneLastUpdateDate;
private java.lang.String phoneLastUpdateUser;
private java.lang.String phoneLastUpdateTxId;
private TCRMExtension TCRMExtension;
private PrimaryKeyBObj primaryKeyBObj;
private java.lang.String phoneHistActionCode;
private java.lang.String phoneHistCreateDate;
private java.lang.String phoneHistCreatedBy;
private java.lang.String phoneHistEndDate;
private java.lang.String phoneHistoryIdPK;
private DWLStatus DWLStatus;
public TCRMPhoneNumberBObjTypWLStatus DWLStatus) {
this.objectReferenceId = objectReferenceId;
this.phoneNumberId = phoneNumberId;
this.contactMethodId = contactMethodId;
this.phoneCountryCode = phoneCountryCode;
this.phoneAreaCode = phoneAreaCode;
this.phoneExchange = phoneExchange;
this.phoneNumber = phoneNumber;
this.phoneExtension = phoneExtension;
this.phoneLastUpdateDate = phoneLastUpdateDate;
this.phoneLastUpdateUser = phoneLastUpdateUser;
this.phoneLastUpdateTxId = phoneLastUpdateTxId;
this.TCRMExtension = TCRMExtension;
this.primaryKeyBObj = primaryKeyBObj;
this.phoneHistActionCode = phoneHistActionCode;
this.phoneHistCreateDate = phoneHistCreateDate
```
<Overlap Ratio: 0.6799292661361627>

---

--- 231 --
Question ID: b5f71a5a6d3aac676e17055cfabf54d3d8029f71
Original Code:
```
public class CylonGpioExample {

    public static void main(String[] args) throws InterruptedException {
        System.out.println("<--Pi4J--> GPIO Cylon Example ... started.");
        // create gpio controller
        final GpioController gpio = GpioFactory.getInstance();
        // provision gpio pin #01 as an output pin and turn on
        final GpioPinDigitalOutput[] pins = { gpio.provisionDigitalOutputPin(RaspiPin.GPIO_00, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_01, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_02, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_03, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_04, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_05, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_06, PinState.LOW), gpio.provisionDigitalOutputPin(RaspiPin.GPIO_07, PinState.LOW) };
        System.out.println("--> GPIO state should be: ON");
        // set shutdown options on all pins
        gpio.setShutdownOptions(true, PinState.LOW, pins);
        // infinite loop
        while (true) {
            int index = 0;
            while (index <= 6) try {
                pins[index].pulse(50);
                Thread.sleep(50);
            } finally {
                index++;
            }
            int index = 6;
            while (index >= 0) try {
                pins[index].pulse(50);
                Thread.sleep(50);
            } finally {
                index--;
            }
        }
    }
}

```


Overlapping Code:
```
oExample {
public static void main(String[] args) throws InterruptedException {
System.out.println("<--Pi4J--> GPIO Cylon Example ... started.");
// create gpio controller
final GpioController gpio = GpioFactory.getInstance();
// provision gpio pin #01 as an output pin and turn on
final GpioPinDigitalOutput[] p.provisionDigitalOutputPin(RaspiPin.GPIO_00, PinState. gpio.provisionDigitalOutputPin(RaspiPin.GPIO_01, PinState.LOW).provisionDigitalOutputPin(RaspiPin.GPIO_02, PinState. gpio.provisionDigitalOutputPin(RaspiPin.GPIO_03, PinState gpio.provisionDigitalOutputPin(RaspiPin.GPIO_04, P gpio.provisionDigitalOutputPin(RaspiPin.GPIO_05, PinSta gpio.provisionDigitalOutputPin(RaspiPin.GPIO_06, PinState. gpio.provisionDigitalOutputPin(RaspiPin.GPIO_07, PinState.stem.out.println("--> GPIO state should be: ON");
// set shutdown options on all pins
gpio.setShutdownOptions(true, PinState.LO
```
<Overlap Ratio: 0.7207425343018563>

---

--- 232 --
Question ID: 471abfbcd5ea2120b3ab3a2bcc2caedb5f103606
Original Code:
```
public class CustomInlineFunctions {

    // declare log services
    private LogServices log = LogServices.getInstance("wbtServices");

    public String doSample(String value) {
        log.debug("wbtServices", "WebertiseInlineFunctions - doSample: got value '" + value + "'");
        return value;
    }
}

```


Overlapping Code:
```
declare log services
private LogServices log = LogServices.getInstance("wbtServic
```
<Overlap Ratio: 0.29454545454545455>

---

--- 233 --
Question ID: 24e81dc3f9999e7393ee6e867168fcebaedb04ae
Original Code:
```
public class RefeedActionsTest {

    private String toString(RefeedActions.Entry entry) {
        StringBuilder builder = new StringBuilder();
        builder.append(entry.getDocumentType() + "." + entry.getClusterName() + ":");
        builder.append(entry.getServices().stream().map(ServiceInfo::getServiceName).sorted().collect(Collectors.joining(",", "[", "]")));
        builder.append(entry.getMessages().stream().collect(Collectors.joining(",", "[", "]")));
        return builder.toString();
    }

    @Test
    public void action_with_multiple_reasons() {
        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).refeed(ValidationId.indexModeChange, CHANGE_MSG_2, DOC_TYPE, CLUSTER, SERVICE_NAME).build().getRefeedActions().getEntries();
        assertThat(entries.size(), is(1));
        assertThat(toString(entries.get(0)), equalTo("music.foo:[baz][change,other change]"));
    }

    @Test
    public void actions_with_multiple_services() {
        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME_2).build().getRefeedActions().getEntries();
        assertThat(entries.size(), is(1));
        assertThat(toString(entries.get(0)), equalTo("music.foo:[baz,qux][change]"));
    }

    @Test
    public void actions_with_multiple_document_types() {
        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE_2, CLUSTER, SERVICE_NAME).build().getRefeedActions().getEntries();
        assertThat(entries.size(), is(2));
        assertThat(toString(entries.get(0)), equalTo("book.foo:[baz][change]"));
        assertThat(toString(entries.get(1)), equalTo("music.foo:[baz][change]"));
    }

    @Test
    public void actions_with_multiple_clusters() {
        List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder().refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).refeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER_2, SERVICE_NAME).build().getRefeedActions().getEntries();
        assertThat(entries.size(), is(2));
        assertThat(toString(entries.get(0)), equalTo("music.bar:[baz][change]"));
        assertThat(toString(entries.get(1)), equalTo("music.foo:[baz][change]"));
    }
}

```


Overlapping Code:
```
 String toString(RefeedActions.Entry entry) {
StringBuilder builder = new StringBuilder();
builder.append(entry.getDocumentType() + "." + entry.getClusterName() + ":");
builder.append(entry.getServicesorted().collect(Collectors.joining(",", "[", "]")r.append(entry.getMessages().stream().collect(Collectors.joining(",", "[", "]")));
return builder.toString();
}
@Test
public void action_with_multiple_reasons() {
List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder()efeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).xModeChange, CHANGE_MSG_2, DOC_TYPE, CLUSTER, SERVeedActions().getEntries();
assertThat(entries.size(), is(1));
assertThat(toString(entries.get(0)), equalTo("music.foo:[baz][change,other change]"));
}
@Test
public void actions_with_multiple_services() {
List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder()efeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).efeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, eedActions().getEntries();
assertThat(entries.size(), is(1));
assertThat(toString(entries.get(0)), equalTo("music.foo:[baz,qux][change]"));
}
@Test
public void actions_with_multiple_document_types() {
List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder()efeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).efeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE_2, CLUSeedActions().getEntries();
assertThat(entries.size(), is(2));
assertThat(toString(entries.get(0)), equalTo("book.foo:[baz][change]"));
assertThat(toString(entries.get(1)), equalTo("music.foo:[baz][change]"));
}
@Test
public void actions_with_multiple_clusters() {
List<RefeedActions.Entry> entries = new ConfigChangeActionsBuilder()efeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPE, CLUSTER, SERVICE_NAME).efeed(ValidationId.indexModeChange, CHANGE_MSG, DOC_TYPEeedActions().getEntries();
assertThat(entries.size(), is(2));
assertThat(toString(entries.get(0)), e
```
<Overlap Ratio: 0.8768494342906875>

---

--- 234 --
Question ID: 6e26950490701ecf5a24f45ce57289a210764de4
Original Code:
```
@SuppressWarnings("unused")
public class RawFilesCopier extends BasePagesGenerator {

    public RawFilesCopier(FoldersConfig foldersConfig) {
        super(foldersConfig);
    }

    @Override
    protected void generateData() throws IOException {
        var rawFolder = foldersConfig.getTemplateFolder() + "RAW";
        //?????? ?????
        var rootFiles = FileHelper.getFilesList(rawFolder);
        for (var file : rootFiles) {
            var outputFolder = foldersConfig.getOutputFolder();
            FileHelper.createFolder(outputFolder);
            FileHelper.copyFile(rawFolder + "/" + file, outputFolder + file);
        }
        String[] gameDirs = FileHelper.getDirsList(rawFolder);
        for (var dir : gameDirs) {
            var filePath = rawFolder + "/" + dir;
            var files = FileHelper.getFilesList(filePath);
            for (var file : files) {
                var outputFolder = foldersConfig.getOutputFolder();
                FileHelper.createFolder(outputFolder + dir);
                FileHelper.copyFile(filePath + "/" + file, outputFolder + dir + "/" + file);
            }
        }
    }
}

```


Overlapping Code:
```
("unused")
public class RawFilesCopier extends BasePagesGenerator {
public RawFilesCopier(FoldersConfig foldersConfig) {
super(foldersConfig);
}
@Override
protected void generateData() throws IOException {
var rawFolder = foldersConfig.getTemplateFolHelper.getFilesList(rawFolder);
for (var file : rootFiles) {
var outputFolder = foldersConfig.getOutputFolder();
FileHelper.createFolder(outputFolder)] gameDirs = FileHelper.getDirsList(rawFolder);
for (var dir : gameDirs) {
var filePath = rawFolder + "/" + dir;
var files = FileHelper.getFilesList(filePath);
for (var file : files) {
var outputFolder = foldersConfig.getOutputFolder();
FileHelper.createFolder(outputFolder + dir);
FileHelper.copyFil
```
<Overlap Ratio: 0.7692307692307693>

---

--- 235 --
Question ID: b5ba2355ae572f4a5409e77434046a0882844699
Original Code:
```
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class HttpProviderTest {

    /**
     * Initial configuration.
     */
    private static final Config INITIAL_CONFIGURATION = ConfigFactory.parseString("application.hello = \"Bad value\"\n" + "http.url = \"https://pastebin.com/raw/x28wW7J8\"\n");

    /**
     * Initial configuration. Requested remote configuration file does not exists.
     */
    private static final Config INITIAL_CONFIGURATION_ERROR_NOT_FOUND = ConfigFactory.parseString("application.hello = \"Bad value\"\n" + "http.url = \"https://pastebin.com/raw/KaDmFAYn87\"\n");

    /**
     * Initial configuration. Remote server can't be resolved.
     */
    private static final Config INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST = ConfigFactory.parseString("application.hello = \"Bad value\"\n" + "http.url = \"https://doma1n-do3s-not-3x15t5-2832893729387.com/config\"\n");

    /**
     * Initial configuration. Requested remote configuration file is not valid.
     */
    private static final Config INITIAL_CONFIGURATION_ERROR_INVALID_FILE = ConfigFactory.parseString("application.hello = \"Bad value\"\n" + "http.url = \"https://pastebin.com/raw/KaDmFAYn\"\n");

    @Test
    public void httpTest_001() {
        // Load remote configuration
        final StringBuilder stringBuilder = new StringBuilder(512);
        final Provider provider = new HttpProvider();
        provider.loadData(INITIAL_CONFIGURATION.getConfig(provider.getConfigurationObjectName()), keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder), FileCfgObject::apply);
        final Config remoteConfig = ConfigFactory.parseString(stringBuilder.toString()).withFallback(INITIAL_CONFIGURATION);
        // Test version
        final Properties properties = new Properties();
        final InputStream is = HttpProvider.class.getClassLoader().getResourceAsStream("playrconf-http.properties");
        try {
            properties.load(is);
            Assert.assertEquals(provider.getVersion(), properties.getProperty("playrconf.http.version", "unknown"));
            properties.clear();
            is.close();
        } catch (final IOException ignore) {
        }
        // Standard values
        Assert.assertEquals(5, remoteConfig.getInt("application.five"));
        Assert.assertEquals("world", remoteConfig.getString("application.hello"));
        Assert.assertTrue(remoteConfig.getBoolean("application.is-enabled"));
        Assert.assertEquals(4, remoteConfig.getIntList("application.list").size());
        // File
        final File file = new File("./test");
        try {
            final InputStream initialStream = new FileInputStream(file);
            final byte[] buffer = new byte[128];
            final int nbRead = initialStream.read(buffer);
            buffer[nbRead] = '\0';
            Assert.assertTrue(nbRead > 0);
            Assert.assertEquals("Hello World!", new String(buffer, 0, nbRead));
        } catch (final IOException ex) {
            ex.printStackTrace();
            Assert.fail();
        }
    }

    @Test(expected = ConfigException.ValidationFailed.class)
    public void httpTest_002() {
        // Load remote configuration
        final StringBuilder stringBuilder = new StringBuilder(512);
        final Provider provider = new HttpProvider();
        provider.loadData(INITIAL_CONFIGURATION_ERROR_NOT_FOUND.getConfig(provider.getConfigurationObjectName()), keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder), FileCfgObject::apply);
        ConfigFactory.parseString(stringBuilder.toString()).withFallback(INITIAL_CONFIGURATION_ERROR_NOT_FOUND);
    }

    @Test(expected = ConfigException.BadValue.class)
    public void httpTest_003() {
        // Load remote configuration
        final StringBuilder stringBuilder = new StringBuilder(512);
        final Provider provider = new HttpProvider();
        provider.loadData(INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST.getConfig(provider.getConfigurationObjectName()), keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder), FileCfgObject::apply);
        ConfigFactory.parseString(stringBuilder.toString()).withFallback(INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST);
    }

    @Test(expected = ConfigException.ValidationFailed.class)
    public void httpTest_004() {
        // Load remote configuration
        final StringBuilder stringBuilder = new StringBuilder(512);
        final Provider provider = new HttpProvider();
        provider.loadData(INITIAL_CONFIGURATION_ERROR_INVALID_FILE.getConfig(provider.getConfigurationObjectName()), keyValueCfgObject -> keyValueCfgObject.apply(stringBuilder), FileCfgObject::apply);
        ConfigFactory.parseString(stringBuilder.toString()).withFallback(INITIAL_CONFIGURATION_ERROR_INVALID_FILE);
    }
}

```


Overlapping Code:
```
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class HttpProviderTest {
/**
* Initial configuration.
*/
private static final Config INITIAL_CONFIGURial configuration. Requested remote configuration file does not exists.
*/
private static final Config INITIAL_CONFIGURATION_ERROR_NOT_FOUND = ConfigFactory.pa "http.url = \"https://pastebin.com/raw/KaDmFAYn87r can't be resolved.
*/
private static final Config INITIAL_CONFIGURATION_ERROR_UNKNOWN_HOST = Confiial configuration. Requested remote configuration file is not valid.
*/
private static final Config INITIAL_CONFIGURATION_ERROR_INVALID_FILE = ConfigF
// Load remote configuration
final StringBuilder stringBuilder = new StringBuilder(512);
final Provider provider = new HttpProvider();
provider.loadDllback(INITIAL_CONFIGURATION);
// Test version
final Properties properties = new Properties();
final InputStream is = HttpProvider.class.getClassLoader().getResourceAsStream("playrconf-http.properties");
try {
properties.load(is);
Assert.assertEqual
properties.clear();
is.close();
} catch (final IOException ignore) {
}
// Standard values
Assert.assertEquals(5, remoteConfig.getInt("application.five"));
Assert.assertEquals("world", remoteConfig.getString("application.hello"));
Assert.assertTrue(remoteConfig.getBoolean("application.is-enabled"));
Assert.asse
```
<Overlap Ratio: 0.5915996425379804>

---

--- 236 --
Question ID: 2bb34c545567de1b63d21140f0cf44c5afcf6090
Original Code:
```
public class WikiParserTest {

    private WikiParser toTest = new CustomWikiParser(Mockito.mock(WikiImageRepository.class));

    @Test
    public void parse() throws Exception {
        final String sample = Resources.toString(getClass().getResource("/markdown/sample.md"), StandardCharsets.UTF_8);
        final WikiPageSource src = new WikiPageSource();
        src.setMarkdownSource(sample);
        final ParsedWikiPage page = toTest.parse(src);
        System.out.println(page.getHtml());
    }
}

```


Overlapping Code:
```
ikiParser toTest = new CustomWikiParser(Mockito.mock(WikiImageRepository.class));
@Test
public void parse() throws Exception {
final String sample = Resources.toString(getClass().getResource("/markdown/sample.md"), StandardCharsets.UTF_8);
final WikiPageSource src = new WikiPageSource();
src.setMarkdownSource(sample);
final ParsedWikiPage page = toTest.parse(src);
System.out.println(page.getHtml()
```
<Overlap Ratio: 0.898876404494382>

---

--- 237 --
Question ID: f7178660a3d266187dc4287ef23abc8f0a527d87
Original Code:
```
public class AbstractDRResourceProviderTest {

    @Test
    public void testGetResourceProvider() throws Exception {
        Set<String> propertyIds = new HashSet<String>();
        propertyIds.add("foo");
        propertyIds.add("cat1/foo");
        propertyIds.add("cat2/bar");
        propertyIds.add("cat2/baz");
        propertyIds.add("cat3/sub1/bam");
        propertyIds.add("cat4/sub2/sub3/bat");
        propertyIds.add("cat5/subcat5/map");
        Map<Resource.Type, String> keyPropertyIds = new HashMap<Resource.Type, String>();
        IvoryService ivoryService = createMock(IvoryService.class);
        AbstractResourceProvider provider = (AbstractResourceProvider) AbstractDRResourceProvider.getResourceProvider(Resource.Type.DRFeed, propertyIds, keyPropertyIds, ivoryService);
        Assert.assertTrue(provider instanceof FeedResourceProvider);
    }
}

```


Overlapping Code:
```
ResourceProviderTest {
@Test
public void testGetResourceProvider() throws Exception {
Set<String> propertyIds = new HashSet<String>();
propertyIds.add("foo");
propertyIds.add("cat1/foo");
propertyIds.add("cat2/bar");
propertyIds.add("cat2/baz");
propertyIds.add("cat3/sub1/bam");
propertyIds.add("cat4/sub2/sub3/bat");
propertyIds.add("cat5/subcat5/map");
Map<Resource.Type, String> keyPropertyIds = new HashMap<Resource.Type, String>();
IvoryService ivoryService = createMock(IvoryService.class);
AbstractResourceProvider p
Assert.assertTrue(provider instanceof FeedResourc
```
<Overlap Ratio: 0.7542706964520368>

---

--- 238 --
Question ID: 2015410f2622e7d62890cc961ff627e53cdbb9db
Original Code:
```
public class AlertRuleRequest {

    @JsonProperty("aggregationPeriod")
    private String aggregationPeriod = null;

    /**
     * Gets or Sets aggregationType
     */
    public enum AggregationTypeEnum {

        COUNT("COUNT"), AVG("AVG"), SUM("SUM"), MAX("MAX"), MIN("MIN");

        private String value;

        AggregationTypeEnum(String value) {
            this.value = value;
        }

        @JsonValue
        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        @JsonCreator
        public static AggregationTypeEnum fromValue(String text) {
            for (AggregationTypeEnum b : AggregationTypeEnum.values()) {
                if (String.valueOf(b.value).equals(text)) {
                    return b;
                }
            }
            return null;
        }
    }

    @JsonProperty("aggregationType")
    private AggregationTypeEnum aggregationType = null;

    @JsonProperty("alertDestinationIds")
    private List<UUID> alertDestinationIds = null;

    @JsonProperty("applicationIds")
    private List<UUID> applicationIds = null;

    @JsonProperty("enabled")
    private Boolean enabled = null;

    @JsonProperty("filterBy")
    private String filterBy = null;

    @JsonProperty("groupByField")
    private String groupByField = null;

    @JsonProperty("name")
    private String name = null;

    @JsonProperty("riskLevel")
    private Integer riskLevel = null;

    @JsonProperty("searchPeriod")
    private String searchPeriod = null;

    @JsonProperty("tags")
    private List<String> tags = null;

    /**
     * Gets or Sets thresholdType
     */
    public enum ThresholdTypeEnum {

        ABOVE("ABOVE"), BELOW("BELOW"), BOTH("BOTH");

        private String value;

        ThresholdTypeEnum(String value) {
            this.value = value;
        }

        @JsonValue
        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        @JsonCreator
        public static ThresholdTypeEnum fromValue(String text) {
            for (ThresholdTypeEnum b : ThresholdTypeEnum.values()) {
                if (String.valueOf(b.value).equals(text)) {
                    return b;
                }
            }
            return null;
        }
    }

    @JsonProperty("thresholdType")
    private ThresholdTypeEnum thresholdType = null;

    @JsonProperty("thresholdValue")
    private Double thresholdValue = null;

    /**
     * Gets or Sets type
     */
    public enum TypeEnum {

        ST_DEV("ST_DEV"), MEAN("MEAN"), FIXED("FIXED");

        private String value;

        TypeEnum(String value) {
            this.value = value;
        }

        @JsonValue
        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        @JsonCreator
        public static TypeEnum fromValue(String text) {
            for (TypeEnum b : TypeEnum.values()) {
                if (String.valueOf(b.value).equals(text)) {
                    return b;
                }
            }
            return null;
        }
    }

    @JsonProperty("type")
    private TypeEnum type = null;

    public AlertRuleRequest aggregationPeriod(String aggregationPeriod) {
        this.aggregationPeriod = aggregationPeriod;
        return this;
    }

    /**
     * Get aggregationPeriod
     * @return aggregationPeriod
     */
    @ApiModelProperty(value = "")
    public String getAggregationPeriod() {
        return aggregationPeriod;
    }

    public void setAggregationPeriod(String aggregationPeriod) {
        this.aggregationPeriod = aggregationPeriod;
    }

    public AlertRuleRequest aggregationType(AggregationTypeEnum aggregationType) {
        this.aggregationType = aggregationType;
        return this;
    }

    /**
     * Get aggregationType
     * @return aggregationType
     */
    @ApiModelProperty(value = "")
    public AggregationTypeEnum getAggregationType() {
        return aggregationType;
    }

    public void setAggregationType(AggregationTypeEnum aggregationType) {
        this.aggregationType = aggregationType;
    }

    public AlertRuleRequest alertDestinationIds(List<UUID> alertDestinationIds) {
        this.alertDestinationIds = alertDestinationIds;
        return this;
    }

    public AlertRuleRequest addAlertDestinationIdsItem(UUID alertDestinationIdsItem) {
        if (this.alertDestinationIds == null) {
            this.alertDestinationIds = new ArrayList<>();
        }
        this.alertDestinationIds.add(alertDestinationIdsItem);
        return this;
    }

    /**
     * Get alertDestinationIds
     * @return alertDestinationIds
     */
    @ApiModelProperty(value = "")
    public List<UUID> getAlertDestinationIds() {
        return alertDestinationIds;
    }

    public void setAlertDestinationIds(List<UUID> alertDestinationIds) {
        this.alertDestinationIds = alertDestinationIds;
    }

    public AlertRuleRequest applicationIds(List<UUID> applicationIds) {
        this.applicationIds = applicationIds;
        return this;
    }

    public AlertRuleRequest addApplicationIdsItem(UUID applicationIdsItem) {
        if (this.applicationIds == null) {
            this.applicationIds = new ArrayList<>();
        }
        this.applicationIds.add(applicationIdsItem);
        return this;
    }

    /**
     * Get applicationIds
     * @return applicationIds
     */
    @ApiModelProperty(value = "")
    public List<UUID> getApplicationIds() {
        return applicationIds;
    }

    public void setApplicationIds(List<UUID> applicationIds) {
        this.applicationIds = applicationIds;
    }

    public AlertRuleRequest enabled(Boolean enabled) {
        this.enabled = enabled;
        return this;
    }

    /**
     * Get enabled
     * @return enabled
     */
    @ApiModelProperty(value = "")
    public Boolean isEnabled() {
        return enabled;
    }

    public void setEnabled(Boolean enabled) {
        this.enabled = enabled;
    }

    public AlertRuleRequest filterBy(String filterBy) {
        this.filterBy = filterBy;
        return this;
    }

    /**
     * Get filterBy
     * @return filterBy
     */
    @ApiModelProperty(value = "")
    public String getFilterBy() {
        return filterBy;
    }

    public void setFilterBy(String filterBy) {
        this.filterBy = filterBy;
    }

    public AlertRuleRequest groupByField(String groupByField) {
        this.groupByField = groupByField;
        return this;
    }

    /**
     * Get groupByField
     * @return groupByField
     */
    @ApiModelProperty(value = "")
    public String getGroupByField() {
        return groupByField;
    }

    public void setGroupByField(String groupByField) {
        this.groupByField = groupByField;
    }

    public AlertRuleRequest name(String name) {
        this.name = name;
        return this;
    }

    /**
     * Get name
     * @return name
     */
    @ApiModelProperty(value = "")
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public AlertRuleRequest riskLevel(Integer riskLevel) {
        this.riskLevel = riskLevel;
        return this;
    }

    /**
     * Get riskLevel
     * @return riskLevel
     */
    @ApiModelProperty(value = "")
    public Integer getRiskLevel() {
        return riskLevel;
    }

    public void setRiskLevel(Integer riskLevel) {
        this.riskLevel = riskLevel;
    }

    public AlertRuleRequest searchPeriod(String searchPeriod) {
        this.searchPeriod = searchPeriod;
        return this;
    }

    /**
     * Get searchPeriod
     * @return searchPeriod
     */
    @ApiModelProperty(value = "")
    public String getSearchPeriod() {
        return searchPeriod;
    }

    public void setSearchPeriod(String searchPeriod) {
        this.searchPeriod = searchPeriod;
    }

    public AlertRuleRequest tags(List<String> tags) {
        this.tags = tags;
        return this;
    }

    public AlertRuleRequest addTagsItem(String tagsItem) {
        if (this.tags == null) {
            this.tags = new ArrayList<>();
        }
        this.tags.add(tagsItem);
        return this;
    }

    /**
     * Get tags
     * @return tags
     */
    @ApiModelProperty(value = "")
    public List<String> getTags() {
        return tags;
    }

    public void setTags(List<String> tags) {
        this.tags = tags;
    }

    public AlertRuleRequest thresholdType(ThresholdTypeEnum thresholdType) {
        this.thresholdType = thresholdType;
        return this;
    }

    /**
     * Get thresholdType
     * @return thresholdType
     */
    @ApiModelProperty(value = "")
    public ThresholdTypeEnum getThresholdType() {
        return thresholdType;
    }

    public void setThresholdType(ThresholdTypeEnum thresholdType) {
        this.thresholdType = thresholdType;
    }

    public AlertRuleRequest thresholdValue(Double thresholdValue) {
        this.thresholdValue = thresholdValue;
        return this;
    }

    /**
     * Get thresholdValue
     * @return thresholdValue
     */
    @ApiModelProperty(value = "")
    public Double getThresholdValue() {
        return thresholdValue;
    }

    public void setThresholdValue(Double thresholdValue) {
        this.thresholdValue = thresholdValue;
    }

    public AlertRuleRequest type(TypeEnum type) {
        this.type = type;
        return this;
    }

    /**
     * Get type
     * @return type
     */
    @ApiModelProperty(value = "")
    public TypeEnum getType() {
        return type;
    }

    public void setType(TypeEnum type) {
        this.type = type;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AlertRuleRequest alertRuleRequest = (AlertRuleRequest) o;
        return Objects.equals(this.aggregationPeriod, alertRuleRequest.aggregationPeriod) && Objects.equals(this.aggregationType, alertRuleRequest.aggregationType) && Objects.equals(this.alertDestinationIds, alertRuleRequest.alertDestinationIds) && Objects.equals(this.applicationIds, alertRuleRequest.applicationIds) && Objects.equals(this.enabled, alertRuleRequest.enabled) && Objects.equals(this.filterBy, alertRuleRequest.filterBy) && Objects.equals(this.groupByField, alertRuleRequest.groupByField) && Objects.equals(this.name, alertRuleRequest.name) && Objects.equals(this.riskLevel, alertRuleRequest.riskLevel) && Objects.equals(this.searchPeriod, alertRuleRequest.searchPeriod) && Objects.equals(this.tags, alertRuleRequest.tags) && Objects.equals(this.thresholdType, alertRuleRequest.thresholdType) && Objects.equals(this.thresholdValue, alertRuleRequest.thresholdValue) && Objects.equals(this.type, alertRuleRequest.type);
    }

    @Override
    public int hashCode() {
        return Objects.hash(aggregationPeriod, aggregationType, alertDestinationIds, applicationIds, enabled, filterBy, groupByField, name, riskLevel, searchPeriod, tags, thresholdType, thresholdValue, type);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class AlertRuleRequest {\n");
        sb.append("    aggregationPeriod: ").append(toIndentedString(aggregationPeriod)).append("\n");
        sb.append("    aggregationType: ").append(toIndentedString(aggregationType)).append("\n");
        sb.append("    alertDestinationIds: ").append(toIndentedString(alertDestinationIds)).append("\n");
        sb.append("    applicationIds: ").append(toIndentedString(applicationIds)).append("\n");
        sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
        sb.append("    filterBy: ").append(toIndentedString(filterBy)).append("\n");
        sb.append("    groupByField: ").append(toIndentedString(groupByField)).append("\n");
        sb.append("    name: ").append(toIndentedString(name)).append("\n");
        sb.append("    riskLevel: ").append(toIndentedString(riskLevel)).append("\n");
        sb.append("    searchPeriod: ").append(toIndentedString(searchPeriod)).append("\n");
        sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
        sb.append("    thresholdType: ").append(toIndentedString(thresholdType)).append("\n");
        sb.append("    thresholdValue: ").append(toIndentedString(thresholdValue)).append("\n");
        sb.append("    type: ").append(toIndentedString(type)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(java.lang.Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }
}

```


Overlapping Code:
```
blic class AlertRuleRequest {
@JsonProperty("aggregationPeriod")
private String aggregationPeriod = null;
/**
* Gets or Sets aggregationType
*/
public enum AggregationTypate String value;
AggregationTypeEnum(String value) {
this.value = value;
}
@JsonValue
public String getValue() {
return value;
}
@Override
public String toString() {
return String.valueOf(value);
}
@JsonCreator
public static AggregationTypeEnum fromValue(String text) {
for (AggregationTypeEnum b : AggregationTypeEnum.values()) {
if (String.valueOf(b.value).equals(text)) {
return b;
}
}
return null;
}
}
@JsonProperty("aggregationType")
private AggregationTypeEnum aggregationType = null;
@JsonProperty("alertDestinationIds")
private List<UUID> alertDestinationIds = null;
@JsonProperty("applicationIds")
private List<UUID> applicationIds = null;
@JsonProperty("enabled")
private Boolean enabled = null;
@JsonProperty("filterBy")
private String filterBy = null;
@JsonProperty("groupByField")
private String groupByField = null;
@JsonProperty("name")
private String name = null;
@JsonProperty("riskLevel")
private Integer riskLevel = null;
@JsonProperty("searchPeriod")
private String searchPeriod = null;
@JsonProperty("tags")
private List<String> tags = null;
/**
* Gets or Sets thresholdType
*/
public enum ThresholdTypeEnum {
ABOVE("ABOVE")alue;
ThresholdTypeEnum(String value) {
this.value = value;
}
@JsonValue
public String getValue() {
return value;
}
@Override
public String toString() {
return String.valueOf(value);
}
@JsonCreator
public static ThresholdTypeEnum fromValue(String text) {
for (ThresholdTypeEnum b : ThresholdTypeEnum.values()) {
if (String.valueOf(b.value).equals(text)) {
return b;
}
}
return null;
}
}
@JsonProperty("thresholdT
```
<Overlap Ratio: 0.9206180074587107>

---

--- 239 --
Question ID: 63f006d75c343e11e3056f238b16a9c53c97186d
Original Code:
```
public class Bounds {

    /**
     * The position of something.
     */
    private final Position position;

    /**
     * The size of something.
     */
    private final Size size;

    public Bounds(Position position, Size size) {
        this.position = position;
        this.size = size;
    }

    /**
     * Get the position.
     *
     * @return position
     */
    public Position getPosition() {
        return position;
    }

    /**
     * Get the size.
     *
     * @return size
     */
    public Size getSize() {
        return size;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Bounds bounds = (Bounds) o;
        if (position != null ? !position.equals(bounds.position) : bounds.position != null)
            return false;
        return size != null ? size.equals(bounds.size) : bounds.size == null;
    }

    @Override
    public int hashCode() {
        int result = position != null ? position.hashCode() : 0;
        result = 31 * result + (size != null ? size.hashCode() : 0);
        return result;
    }

    @Override
    public String toString() {
        return String.format("%s at %s", getSize().toString(), getPosition().toString());
    }
}

```


Overlapping Code:
```
/**
* The position of something.
*/
private final Position position;
/**
* The size of something.
*/
private final Size size;
public Bounds(Position position, Size size) {
this.position = position;
this.size = size;
}
/**
* Get the position.
*
* @return position
*/
public Position getPosition() {
return position;
}
/**
* Get the size.
*
* @return size
*/
public Size getSize() {
return size;
}
@Override
public boolean equals(Object o) {
if (this == o)
return true;
if (o == null || getClass() != o.getClass())
return false;
Boun) o;
if (position != null ? !position.equals(bounde;
return size != null ? size.equals(bounds.size) : bounds.size == null;
}
@Override
public int hashCode() {
int result = position != null ? position.hashCode() : 0;
result = 31 * result + (size != null ? size.hashCode() : 0);
return result;
}
@Override
public String toString() {
return String.format("%s a
```
<Overlap Ratio: 0.8554913294797688>

---

--- 240 --
Question ID: e2b1d74db8b5405d1f9d96ba519d9b6d9d3cd3ab
Original Code:
```
public abstract class Node implements UniversalCodeVisitable {

    /**
     * The parent node.
     */
    private Node parent;

    /**
     * The parser token image backing this node.
     */
    private TokenImage tokenImage;

    private Type type;

    /**
     * Constructs a new AST node instance, with no initial configuration.
     */
    public Node() {
    }

    /**
     * Constructs a new AST node instance.
     *
     * @param tokenImage the parser token image backing this node.
     */
    public Node(TokenImage tokenImage) {
        this(tokenImage, (Class<?>) null);
    }

    /**
     * Constructs the node.
     *
     * @param tokenImage the parser token image backing this node.
     * @param typeDescriptor the type of the node, or null if unknown at this time.
     */
    public Node(TokenImage tokenImage, Class<?> typeDescriptor) {
        this(null, tokenImage, typeDescriptor);
    }

    /**
     * Constructs the node.
     *
     * @param tokenImage the parser token image backing this node.
     * @param type  the type of the node, or null if unknown at this time.
     */
    public Node(TokenImage tokenImage, Type type) {
        this(null, tokenImage, type);
    }

    /**
     * All args constructor.
     *
     * @param parent the parent node, which may be null to indicate none.
     * @param tokenImage the parser token image backing this node.
     * @param typeDescriptor the type of the node, or null if unknown at this time.
     */
    public Node(Node parent, TokenImage tokenImage, Class<?> typeDescriptor) {
        this.parent = parent;
        this.tokenImage = tokenImage;
        //        this.typeDescriptor = typeDescriptor;
        this.type = typeDescriptor == null ? null : new ResolvedTypeReferenceOld(tokenImage, typeDescriptor);
    }

    /**
     * All args constructor.
     *
     * @param parent the parent node, which may be null to indicate none.
     * @param tokenImage the parser token image backing this node.
     * @param type the type of the node, or null if unknown at this time.
     */
    public Node(Node parent, TokenImage tokenImage, Type type) {
        this.parent = parent;
        this.tokenImage = tokenImage;
        //        this.typeDescriptor = null;
        this.type = type;
    }

    public Node accept(UniversalCodeVisitor visitor) {
        return this;
    }

    public Node accept(AstVisitor visitor) {
        return this;
    }

    /**
     * Gets the parent node.
     *
     * @return the parent node, which may be null if this node does not have a parent.
     */
    public Node getParent() {
        return parent;
    }

    /**
     * Sets the parent node.
     *
     * @param parent the parent node, which may be null if this node does not have a parent.
     */
    public void setParent(Node parent) {
        this.parent = parent;
    }

    /**
     * Sets the parent node.
     *
     * @param parent the parent node, which may be null if this node does not have a parent.
     * @return this instance for builder chaining.
     */
    public Node withParent(Node parent) {
        setParent(parent);
        return this;
    }

    /**
     * Gets the parser token image backing this node.
     *
     * @return the parser token image backing this node.
     */
    public TokenImage getTokenImage() {
        return tokenImage;
    }

    /**
     * Sets the parser token image backing this node.
     *
     * @param tokenImage the parser token image backing this node.
     */
    public void setTokenImage(TokenImage tokenImage) {
        this.tokenImage = tokenImage;
    }

    /**
     * Sets the parser token image backing this node.
     *
     * @param tokenImage the parser token image backing this node.
     * @return this instance for builder chaining.
     */
    public Node withTokenImage(TokenImage tokenImage) {
        this.tokenImage = tokenImage;
        return this;
    }

    public Class<?> getTypeDescriptor() {
        //        return typeDescriptor;
        return getType() == null ? null : getType().getTypeClass();
    }

    /**
     * Returns the established static type of the node.
     *
     * @return the node's type, or null if the type cannot be determined at this time.
     */
    public Type getType() {
        return type;
    }

    public void setType(final TypeReference type) {
        this.type = type;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (!(o instanceof Node))
            return false;
        Node node = (Node) o;
        return Objects.equals(parent, node.parent) && Objects.equals(tokenImage, node.tokenImage) && Objects.equals(type, node.type);
    }

    @Override
    public int hashCode() {
        return Objects.hash(parent, tokenImage, type);
    }
}

```


Overlapping Code:
```
 class Node implements UniversalCodeVisitable {
/**
* The parent node.
*/
private Node parent;
/**
* The parser token image backing this node.
*/
priv a new AST node instance, with no initial configuration.
*/
public Node() {
}
/**
* Constructs a new AST node instance.
*
* @param tokenImage the parser token image backing this node.
*/
public Node(TokenImage tokenImage) {
this(tokenImage, (Class<?>cts the node.
*
* @param tokenImage the parser token image backing this node.
* @param typeDescriptor the type of the node, or null if unknown at this time.
*/
public Node(TokenImage tokenImage, Class<?> typeDescriptor) {
this(null, tokenImage, typeDescriptor);
}
/**
* Constructs the node.
*
* @param tokenImage the parser token image backing this node.
* @param type the type of the node, or null if unknown at this time.
*/
public Node(TokenImage tokenImage, Type type) {
this(null, tokenImage, type);
}
/**
* All args constructor.
*
* @param parent the parent node, which may be null to indicate none.
* @param tokenImage the parser token image backing this node.
* @param typeDescriptor the type of the node, or null if unknown at this time.
*/
public Node(Node parent, TokenImage tokenImage, Class<?> typeDescriptor) {
this.parent = parent;
this.tokenImage = tokenImage;
// this.typeDescriptor = typeDescriptor;
this.type = typeDescriptor == null ? null : new ResolvedTypeReferenceOld(tokenImage, typeDescriptor);
}
/**
* All args constructor.
*
* @param parent the parent node, which may be null to indicate none.
* @param tokenImage the parser token image backing this node.
* @param type the type of the node, or null if unknown at this time.
*/
public Node(Node parent, TokenImage tokenImage, Type type) {
this.parent = parent;
this.tokenImage = tokenImage;
// this.typeDescriptor = null;
this.type = type;
}
public Node accept(UniversalCodeVisitor visitor) {
return this;
}
public Node accept(AstVisitor visitor) {
return this;
}
/**
* Gets the parent node.
*
* @ret
```
<Overlap Ratio: 0.9500240269101393>

---

--- 241 --
Question ID: bacc5b1878a17e567c59933789e2258b27f89430
Original Code:
```
public class PublicKeyEncryptor extends AbstractEncryptor<Cipher, PublicKey, byte[]> implements ByteArrayEncryptor {

    /**
     * The Constant serialVersionUID.
     */
    private static final long serialVersionUID = 1L;

    private CryptModel<Cipher, SecretKey, String> symmetricKeyModel;

    /**
     * Instantiates a new {@link PublicKeyEncryptor} with the given {@link CryptModel} for the
     * public key and the given {@link CryptModel} for the symmetric key
     *
     * @param model
     *            The crypt model
     * @param symmetricKeyModel
     *            The symmetric key model
     *
     * @throws InvalidAlgorithmParameterException
     *             is thrown if initialization of the cipher object fails.
     * @throws NoSuchPaddingException
     *             is thrown if instantiation of the SecretKeyFactory object fails.
     * @throws InvalidKeySpecException
     *             is thrown if generation of the SecretKey object fails.
     * @throws NoSuchAlgorithmException
     *             is thrown if instantiation of the SecretKeyFactory object fails.
     * @throws InvalidKeyException
     *             is thrown if initialization of the cipher object fails.
     * @throws NoSuchAlgorithmException
     *             is thrown if instantiation of the SecretKeyFactory object fails.
     * @throws UnsupportedEncodingException
     *             is thrown if the named charset is not supported.
     */
    public PublicKeyEncryptor(final CryptModel<Cipher, PublicKey, byte[]> model, final CryptModel<Cipher, SecretKey, String> symmetricKeyModel) throws InvalidKeyException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException {
        super(model);
        Objects.requireNonNull(symmetricKeyModel);
        this.symmetricKeyModel = symmetricKeyModel;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public byte[] encrypt(final byte[] toEncrypt) throws Exception {
        final SecretKey symmetricKey = symmetricKeyModel.getKey();
        Cipher symmetricKeyCipher = newSymmetricCipher(symmetricKey, symmetricKeyModel.getAlgorithm().getAlgorithm(), symmetricKeyModel.getOperationMode());
        byte[] symmetricKeyEncryptedBytes = symmetricKeyCipher.doFinal(toEncrypt);
        byte[] encryptedKey = getModel().getCipher().doFinal(symmetricKey.getEncoded());
        AesRsaCryptModel cryptData = AesRsaCryptModel.builder().encryptedKey(encryptedKey).symmetricKeyEncryptedObject(symmetricKeyEncryptedBytes).build();
        byte[] encryptedCryptData = SerializationUtils.serialize(cryptData);
        return encryptedCryptData;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected String newAlgorithm() {
        if (getModel().getAlgorithm() == null) {
            getModel().setAlgorithm(KeyPairWithModeAndPaddingAlgorithm.RSA_ECB_OAEPWithSHA1AndMGF1Padding);
        }
        return getModel().getAlgorithm().getAlgorithm();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected Cipher newCipher(final PublicKey key, final String algorithm, final byte[] salt, final int iterationCount, final int operationMode) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, UnsupportedEncodingException {
        final Cipher cipher = CipherFactory.newCipher(algorithm);
        cipher.init(Cipher.PUBLIC_KEY, key);
        return cipher;
    }

    private Cipher newSymmetricCipher(final SecretKey key, final String algorithm, final int operationMode) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException {
        final Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(operationMode, key);
        return cipher;
    }
}

```


Overlapping Code:
```
ublic class PublicKeyEncryptor extends AbstractEnctor {
/**
* The Constant serialVersionUID.
*/
private static final long serialVersionUID = 1L;
private CryptModel<Cipher, SecretKey, String> symmetricKeyModel;
/**
* Instantiates a new {@link PublicKeyEncryptor} with the given {@link CryptModel} for the
* public key and the given {@link CryptModel} for the symmetric key
*
* @param model
* The crypt model
* @param symmetricKeyModel
* The symmetric key model
*
* @throws InvalidAlgorithmParameterException
* is thrown if initialization of the cipher object fails.
* @throws NoSuchPaddingException
* is thrown if instantiation of the SecretKeyFactory object fails.
* @throws InvalidKeySpecException
* is thrown if generation of the SecretKey object fails.
* @throws NoSuchAlgorithmException
* is thrown if instantiation of the SecretKeyFactory object fails.
* @throws InvalidKeyException
* is thrown if initialization of the cipher object fails.
* @throws NoSuchAlgorithmException
* is thrown if instantiation of the SecretKeyFactory object fails.
* @throws UnsupportedEncodingException
* is thrown if the named charset is not supported.
*/
public PublicKeyEncryptor(final CryptModel<Cipher,  CryptModel<Cipher, SecretKey, String> symmetricKeyMod) throws InvalidKeyException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingExceptionetricKeyModel);
this.symmetricKeyModel = symmetricKeyModel;
}
/**
* {@inheritDoc}
*/
@Override
public byte[] encrypt(final byte[] toEncrypt) throws ExKeyModel.getKey();
Cipher symmetricKeyCipher = newtAlgorithm().getAlgorithm(), symmetricKeyModel.getOperationMode());
byte[] symmetricKeyEncryptedBytes = symmetricKeyCipher.doFinal(toEncrypt);
byte[] encryptedKey = getModel().getCipher().doFinal(symmetricKey.getEncoded());
AesRsaCryptModel cryptData = AesRsaCryptModel.builder().encryptedKey(encrypt
```
<Overlap Ratio: 0.8890436397400185>

---

--- 242 --
Question ID: 4145e4ff9250cae0f2320ca43bb45cac1e8eae61
Original Code:
```
public class Log4JRuleHelper extends RuleHelper {

    private static final LogEventTracker tracker = new LogEventTracker();

    public Log4JRuleHelper(Rule rule) {
        super(rule);
    }

    public void appendersCalled(LoggingEvent event) {
        ThrowableInformation throwableInfo = event.getThrowableInformation();
        String throwableName = null;
        ErrorFingerprint fingerprint = null;
        if (throwableInfo != null) {
            Throwable throwable = throwableInfo.getThrowable();
            throwableName = (throwable != null) ? throwable.getClass().getName() : null;
            fingerprint = ErrorFingerprint.fromThrowable(throwableInfo.getThrowable());
        }
        LogEventTracker.LogLevel level = LogEventTracker.LogLevel.valueOf(event.getLevel().toString());
        tracker.track(level, (throwableInfo != null), throwableName, fingerprint);
        if (fingerprint != null && event.getProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME) == null) {
            event.setProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME, fingerprint.getChecksum());
        }
    }

    public String convertMessage(LoggingEvent event, String origMessage) {
        String fingerprint = event.getProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME);
        if (fingerprint == null) {
            return origMessage;
        }
        return "[error:" + fingerprint + "] " + origMessage;
    }
}

```


Overlapping Code:
```
uleHelper extends RuleHelper {
private static final LogEventTracker tracker = new LogEventTracker();
public Log4JRuleHelper(Rule rule) {
super(rule);
}
public void appendersCalled(LoggingEvent event) {
ThrowableInformation throwableInfo = event.getThrowableInformation();
String throwableName = null;
ErrorFingerprint fingerprint = null;
if (throwableInfo != null) {
Throwable throwable = throwableInfo.getThrowable();
throwableName = (throwable != null) ? throwable.getClass().getName() : null;
fingerprint = ErrorFingerprint.fromThrowable(throwableInfo.getThrowable());
}
LogEventTracker.LogLevel level = LogEventTracker.LogLevel.valueOf(event.getLevel().toString());
tracker.track(level, (throwableInfo != null), throwableName, fingerprint);
if (fingerprint != null && event.getProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME) == null) {
event.setProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME, fingerprint.getChecksum());
}
}
public String convertMessage(LoggingEvent event, String origMessage) {
String fingerprint = event.getProperty(LogEventTracker.FINGERPRINT_PROPERTY_NAME);
if (fingerprint == null) {
return origMessage;
}
return "[error:" +
```
<Overlap Ratio: 0.9530864197530864>

---

--- 243 --
Question ID: 3abd49fe01a13f09b3da2e4f76316ccef4ce8fa9
Original Code:
```
@Validated
@RestController
@RequestMapping("/user")
public class UserController extends BaseController {

    @Autowired
    private UserService userService;

    @Autowired
    private AddressService addressService;

    @Autowired
    private UserRepository userRepository;

    @PostMapping("/insertDemoData")
    public void insertDemoData(String name) {
        Address address = new Address();
        address.setCountry("CN");
        address.setProvince("SHAANXI");
        address.setCity("XI'AN");
        address.setHouseNumber(12);
        address = addressService.save(address);
        User user = new User();
        user.setName("Lisa");
        user.setAge(12);
        user.setRole(Role.USER);
        user.setAddressId(address.getId());
        userService.saveAndFlush(user);
    }

    @PostMapping("/insert")
    public void insert(@Valid User user, @Valid Address address) {
        Address address1 = addressService.save(address);
        user.setAddressId(address1.getId());
        User user1 = userService.saveAndFlush(user);
    }

    @PostMapping("/update/{id}")
    public void update(@PathVariable("id") Long id) {
        User user = new User();
        user.setId(id);
        user.setName("Tom");
        userService.update(id, user);
    }

    @GetMapping("/all")
    public List<User> findAll() {
        return userService.findAll();
    }

    @GetMapping("/page")
    public Pager<User> findPage(Pager<User> pager) {
        final Page<User> page = userService.findAll(PagerConverter.toPageable(pager));
        return PagerConverter.toPager(page);
    }

    @GetMapping("/dsl")
    public List<User> findAllByQueryDsl(User user) {
        return userService.findAllByQueryDsl(user);
    }

    @GetMapping("/nativeSql")
    public List<Object> findStudentAddress(String userName, String city) {
        return userService.findStudentAddress(userName, city);
    }

    @GetMapping("/school")
    public List<UserRepository.UserSchoolDTO> findUserSchoolDTO() {
        return userRepository.findUserSchoolDTO();
    }
}

```


Overlapping Code:
```
Validated
@RestController
@RequestMapping("/user")
public class UserController extends BaseController {
@Autowired
private UserService userService;
@Autowired
private AddressService addressService;
@Autowired
private UserRepository userRepository;
@PostMapping("/insertDemoData")
public void insertDemoData(String name) {
Address address = new Address();
address.setCountry("CN");
address.setProvince("SHAANXI");
address.setCity("XI'AN");
address.setHouseNumber(12);
address = addressService.save(address);
User user = new User();
user.setName("Lisa");
user.setAge(12);
user.setRole(Role.USER);
user.setAddressId(address.getId());
userService.saveAndFlush(user);
}
@PostMapping("/insert")
public void insert(@Valid User user, @Valid Address address) {
Address address1 = addressService.save(address);
user.setAddressId(address1.getId());
User user1 = userService.saveAndFlush(user);
}
@PostMapping("/update/{id}")
public void update(@PathVariable("id") Long id) {
User user = new User();
user.setId(id);
user.setName("Tom");
userService.update(id, user);
}
@GetMapping("/all")
public List<User> findAll() {
return userService.findAll();
}
@GetMapping("/page")
public Pager<User> findPage(Pager<User> pager) {
final Page<User> page = userService.findAll(PagerConverter.toPageable(pager));
return PagerConverter.toPager(page);
}
@GetMapping("/dsl")
public List<User> findAllByQueryDsl(User user) {
return userService.findAllByQueryDsl(user);
}
@GetMapping("/nativeSql")
public List<Object> findStudentAddress(String userName, String city) {
return userService.findStudentAddress(userName, city);
}
@GetMapping("/school")
public List<UserRepository.UserSchoolDTO> findUserSchoolDTO() {

```
<Overlap Ratio: 0.9728323699421966>

---

--- 244 --
Question ID: a7adb9c2cd2745f6f8a868174542360456f4045b
Original Code:
```
public class CPGManualTest extends CPGTestBase {

    @Test
    public void testGet() {
        String location = given().post(baseUrlOfSut + "/api/cpg/x").then().statusCode(201).extract().header("location");
        int a = 42;
        int b = 77;
        location = resolveLocation(location, baseUrlOfSut + "/api/cpg/x/{id}/y");
        given().contentType(ContentType.JSON).body("{\"a\":" + a + ", \"b\":" + b + "}").post(location).then().statusCode(201);
        given().accept(ContentType.JSON).get(location).then().statusCode(200).body("a", is(a)).body("b", is(b));
    }
}

```


Overlapping Code:
```
PGTestBase {
@Test
public void testGet() {
String cation");
int a = 42;
int b = 77;
location = resolveLocation(location, baseUrlOfSut + "/api/cpg/x/{i
```
<Overlap Ratio: 0.28957528957528955>

---

--- 245 --
Question ID: 900efec8f77509ae8a2b4b9488dc2c67b487169f
Original Code:
```
public class OpFactory {

    public static ASTLeaf createOperator(Token t) {
        String op = t.getText();
        String[] AssignOperators = { "+=", "-=", "*=", "/=" };
        if (Arrays.asList(AssignOperators).contains(op))
            return new CompoundAssignOperator(t);
        else if (op.equals("="))
            return new AssignOperator(t);
        else if (op.equals("+"))
            return new PlusOperator(t);
        else if (op.equals("-"))
            return new MinusOperator(t);
        else if (op.equals("*"))
            return new ProductOperator(t);
        else if (op.equals("/"))
            return new QuotientOperator(t);
        else if (op.equals("%"))
            return new SurplusOperator(t);
        else if (op.equals("=="))
            return new EqualityOperator(t);
        else if (op.equals("!="))
            return new NonEqualityOperator(t);
        else if (op.equals(">"))
            return new MoreOperator(t);
        else if (op.equals(">="))
            return new MoreOrEqualOperator(t);
        else if (op.equals("<"))
            return new LessOperator(t);
        else if (op.equals("<="))
            return new LessOrEqualOperator(t);
        else if (op.equals("&&"))
            return new AndOperator(t);
        else if (op.equals("||"))
            return new OrOperator(t);
        throw new SheepException("Unsupported operator", t.getLineNumber());
    }
}

```


Overlapping Code:
```
ublic static ASTLeaf createOperator(Token t) {
String op = t.getText();
String[] AssignOperators = {erators).contains(op))
return new CompoundAssignOp new ProductOperator(t);
else if (op.equals("/"))
return new QuotientOperator(t);
else if (op.equals("%"))
return new SurplusOperator(t);
else if (op.equals("=="))
return new EqualityOperator(t);
else if (op.equals("!="))
return new NonEqualityOperator(t);
else if (op.equals(">"))
return new MoreOperator(t);
else if (op.equals(">="))
return new MoreOrEqualOperator(t);
else if (op.equals("<"))
return new LessOperator(t);
else if (op.equals("<="))
return new LessOrEqualOperator(t);
else if (op.equals("&&"))
return new AndOperator(t);
else if (op.equals("||"))
return new OrOperator(t);
throw new SheepException("Unsupported operator", t.getLineNu
```
<Overlap Ratio: 0.730593607305936>

---

--- 246 --
Question ID: 5494e9ba86572e92df36c029d9a6c0fb67dd4722
Original Code:
```
@XmlRootElement
public class IssueUpdates {

    @XmlElement(name = "issueUpdate")
    public final List<IssueUpdate> issueUpdates = new ArrayList<>();

    @Override
    public boolean equals(Object otherObject) {
        return this == otherObject || (otherObject instanceof IssueUpdates && Objects.equals(issueUpdates, ((IssueUpdates) otherObject).issueUpdates));
    }

    @Override
    public int hashCode() {
        return Objects.hash(issueUpdates);
    }

    public static class IssueUpdate {

        @Nullable
        public String issueKey;

        @Nullable
        public Issue issue;

        @Override
        public boolean equals(@Nullable Object otherObject) {
            if (this == otherObject) {
                return true;
            } else if (otherObject == null || getClass() != otherObject.getClass()) {
                return false;
            }
            IssueUpdate other = (IssueUpdate) otherObject;
            return Objects.equals(issueKey, other.issueKey) && Objects.equals(issue, other.issue);
        }

        @Override
        public int hashCode() {
            return Objects.hash(issueKey, issue);
        }
    }
}

```


Overlapping Code:
```
lement(name = "issueUpdate")
public final List<IssueUpdate> issueUpdates = new ArrayList<>();
@Override
public boolean equals(Object otherObject) {
return this == otherObjssueUpdates) otherObject).issueUpdates));
}
@Override
public int hashCode() {
return Objects.hash(issueIssue issue;
@Override
public boolean equals(@Nullable Object otherObject) {
if (this == otherObject) {
return true;
} else if (otherObject == null || getClass() != otherObject.getClass()) {
return false;
}
IssueUpdate other = (IssueUpdate) otherObject;
return Objects.equals(issueKey, other.issueKeyssue);
}
@Override
public int hashCode() {
return Objects.hash(issueKey, issu
```
<Overlap Ratio: 0.7083786724700761>

---

--- 247 --
Question ID: 669e310d22d7a1c8173c0b5886391f9475cf7bc7
Original Code:
```
public class ConColDemoApp {

    private CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();

    public static void main(String[] args) {
        ConColDemoApp obj = new ConColDemoApp();
        obj.list.add(10);
        obj.list.add(20);
        obj.list.add(30);
        System.out.println(obj.list);
    }
}

```


Overlapping Code:
```
rivate CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();
public static void main(String[] args) {
ConColDemoApp obj = new ConColDemoApp();
obj.list.add(10);
obj.list.add(20);
obj.list
```
<Overlap Ratio: 0.7326007326007326>

---

--- 248 --
Question ID: 895b29ca56c1e747cd96f886c95fd5020c83bf5d
Original Code:
```
public class ConnectionOpeningImpl implements IBestPractice {

    @Value("${connections.connectionOpening.title}")
    private String overviewTitle;

    @Value("${connections.connectionOpening.detailedTitle}")
    private String detailTitle;

    @Value("${connections.connectionOpening.desc}")
    private String aboutText;

    @Value("${connections.connectionOpening.url}")
    private String learnMoreUrl;

    @Value("${connections.connectionOpening.selfEvaluation}")
    private String textResult;

    @Override
    public AbstractBestPracticeResult runTest(PacketAnalyzerResult tracedata) {
        ConnectionOpeningResult result = new ConnectionOpeningResult();
        result.setSelfTest(true);
        result.setAboutText(aboutText);
        result.setDetailTitle(detailTitle);
        result.setLearnMoreUrl(learnMoreUrl);
        result.setOverviewTitle(overviewTitle);
        result.setResultText(textResult);
        result.setResultType(BPResultType.SELF_TEST);
        return result;
    }
}

```


Overlapping Code:
```
tionOpeningImpl implements IBestPractice {
@Value("${connections.connectionOpening.title}")
private String overviewTitle;
@Value("${ctionOpening.detailedTitle}")
private String detailTitle;
@Value("${tions.connectionOpening.url}")
private String lear;
@Override
public AbstractBestPracticeResult runTest(PacketAnalyzerResult tracedata) {
ConnectionOpeningResult result = new ConnectionOpeningResult();
result.setSelfTest(true);
result.setAboutText(aboutText);
result.setDetailTitle(detailTitle);
result.setLearnMoreUrl(learnMoreUrl);
result.setOverviewTitle(overviewTitle);
result.setResultText(textResult);
result.setResultType(BPResultType.SELF_TEST);

```
<Overlap Ratio: 0.7423382519863791>

---

--- 249 --
Question ID: 91953d73cb626c9bf2be8918e0b871465e2f55ee
Original Code:
```
public class DummyProviderTraces {

    static DummyProviderTraces instance = new DummyProviderTraces();

    public static DummyProviderTraces getInstance() {
        return instance;
    }

    /**
     * Flag indicates if test is enabled, so we should trace projects and configs
     */
    public volatile boolean enabled;

    private DummyProviderTraces() {
    }

    Map /*<String, List>*/
    id2prjTrace = new HashMap();

    Map /*<String, List>*/
    id2cfgTrace = new HashMap();

    public List getProjectsTrace(Class provider) {
        String key = provider.getName();
        if (!id2prjTrace.containsKey(key)) {
            id2prjTrace.put(key, Collections.synchronizedList(new ArrayList()));
        }
        return (List) id2prjTrace.get(key);
    }

    public List getCfgsTrace(Class provider) {
        String key = provider.getName();
        if (!id2cfgTrace.containsKey(key)) {
            id2cfgTrace.put(key, Collections.synchronizedList(new ArrayList()));
        }
        return (List) id2cfgTrace.get(key);
    }

    public void reset(Class provider) {
        getProjectsTrace(provider).clear();
        getCfgsTrace(provider).clear();
    }
}

```


Overlapping Code:
```
races {
static DummyProviderTraces instance = new g indicates if test is enabled, so we should traceList getProjectsTrace(Class provider) {
String keykey)) {
id2prjTrace.put(key, Collections.synchronizedList(new ArrayList()));
}
return (List) id2prjTcfgTrace.containsKey(key)) {
id2cfgTrace.put(key, Collections.synchronizedList(new ArrayList()));
}
 reset(Class provider) {
getProjectsTrace(provider
```
<Overlap Ratio: 0.40858018386108275>

---

--- 250 --
Question ID: 226b487adf17fcdc413f042460759648247259d6
Original Code:
```
public class PC2LogViewer extends PC2Console {

    public PC2LogViewer(JScrollPane scroll, PC2TextPane pane) {
        super(scroll, pane);
        pane.wrapText = false;
    }

    public void appendLog(String s) throws IllegalArgumentException {
        boolean error = false;
        boolean fatal = false;
        boolean warn = false;
        boolean info = false;
        boolean debug = false;
        boolean trace = false;
        if (s != null) {
            if (s.length() >= 29) {
                String level = s.substring(24, 29);
                if (level.equals("DEBUG"))
                    debug = true;
                else if (level.equals("INFO "))
                    info = true;
                else if (level.equals("WARN "))
                    warn = true;
                else if (level.equals("ERROR"))
                    error = true;
                else if (level.equals("TRACE"))
                    trace = true;
                else if (level.equals("FATAL"))
                    fatal = true;
                if (fatal)
                    textPane.append(s, FATAL, RED);
                else if (error) {
                    if (s.contains("ERROR  VERIFY FAILED"))
                        textPane.append(s, VERIFY, RED);
                    else
                        textPane.append(s, ERROR, RED);
                } else if (info) {
                    if (s.contains(">>>>> RX:")) {
                        textPane.append(s, MSG, GREEN);
                    } else if (s.contains("<<<<< TX:")) {
                        textPane.append(s, MSG, ORANGE);
                    } else if (s.contains("INFO   USER:"))
                        textPane.append(s, PROMPT, BLUE);
                    else if (s.contains("INFO  Test ")) {
                        if (s.contains("Passed."))
                            textPane.append(s, FATAL, GREEN);
                        else if (s.contains("Failed."))
                            appendFailedTestResults(s);
                    } else if (s.contains("INFO  Commencing test")) {
                        textPane.append(s, FATAL, GREEN);
                    } else if (s.contains("INFO  VERIFY PASSED"))
                        textPane.append(s, VERIFY, BLUE);
                    else
                        textPane.append(s, INFO, NORMAL);
                } else if (warn)
                    textPane.append(s, WARN, DK_YELLOW);
                else if (debug)
                    textPane.append(s, DEBUG, DK_GRAY);
                else if (trace)
                    textPane.append(s, TRACE, GRAY);
                else
                    textPane.append(s, INFO, NORMAL);
            } else
                textPane.append(s, INFO, NORMAL);
        } else {
            throw new IllegalArgumentException("LogViewer doesn't allow a null string for an argument.");
        }
    }

    public void appendConsole(String s) throws IllegalArgumentException {
        boolean error = false;
        boolean fatal = false;
        boolean warn = false;
        boolean info = false;
        boolean debug = false;
        boolean trace = false;
        if (s != null) {
            if (s.length() >= 5) {
                String level = s.substring(0, 5);
                if (level.equals("DEBUG"))
                    debug = true;
                else if (level.equals("INFO "))
                    info = true;
                else if (level.equals("WARN "))
                    warn = true;
                else if (level.equals("ERROR"))
                    error = true;
                else if (level.equals("TRACE"))
                    trace = true;
                else if (level.equals("FATAL"))
                    fatal = true;
                if (fatal)
                    textPane.append(s, FATAL, RED);
                else if (error) {
                    if (s.contains("ERROR  VERIFY FAILED"))
                        textPane.append(s, VERIFY, RED);
                    else
                        textPane.append(s, ERROR, RED);
                } else if (info) {
                    if (s.startsWith("INFO  >>>>> RX:")) {
                        textPane.append(s, MSG, GREEN);
                    } else if (s.startsWith("INFO  <<<<< TX:")) {
                        textPane.append(s, MSG, ORANGE);
                    } else if (s.startsWith("INFO   USER:"))
                        textPane.append(s, PROMPT, BLUE);
                    else if (s.startsWith("INFO  Test ")) {
                        if (s.contains("Passed."))
                            textPane.append(s, FATAL, GREEN);
                        else if (s.contains("Failed."))
                            appendFailedTestResults(s);
                    } else if (s.startsWith("INFO  Commencing test")) {
                        textPane.append(s, FATAL, GREEN);
                    } else if (s.startsWith("INFO  \n\tVendor: ")) {
                        textPane.append(s, MSG, BLUE);
                    } else if (s.contains("INFO  VERIFY PASSED"))
                        textPane.append(s, VERIFY, BLUE);
                    else
                        textPane.append(s, INFO, NORMAL);
                } else if (warn)
                    textPane.append(s, WARN, DK_YELLOW);
                else if (debug)
                    textPane.append(s, DEBUG, DK_GRAY);
                else if (trace)
                    textPane.append(s, TRACE, GRAY);
                else
                    textPane.append(s, INFO, NORMAL);
            } else
                textPane.append(s, INFO, NORMAL);
        }
    }

    private void appendFailedTestResults(String s) {
        // passed.
        StringTokenizer st = new StringTokenizer(s, "\n");
        for (; st.hasMoreTokens(); ) {
            String temp = st.nextToken();
            if (temp.contains("Passed"))
                textPane.append((temp + "\n"), FATAL, GREEN);
            else
                textPane.append((temp + "\n"), FATAL, RED);
        }
    }

    public boolean isConsoleLog(String msg) {
        if (msg.startsWith("DEBUG ") || msg.startsWith("INFO ") || msg.startsWith("WARN ") || msg.startsWith("ERROR ") || msg.startsWith("TRACE ") || msg.startsWith("FATAL "))
            return true;
        return false;
    }
}

```


Overlapping Code:
```
ole {
public PC2LogViewer(JScrollPane scroll, PC2TextPane pane) {
super(scroll, pane);
pane.wrapTexts IllegalArgumentException {
boolean error = false;
boolean fatal = false;
boolean warn = false;
boolean info = false;
boolean debug = false;
boolean trace = false;
if (s != null) {
if (s.length() >= .equals("DEBUG"))
debug = true;
else if (level.equtextPane.append(s, FATAL, RED);
else if (error) {
if (s.contains("ERROR VERIFY FAILED"))
textPane.append(s, VERIFY, RED);
else
textPane.append(s, ERRO.contains("INFO USER:"))
textPane.append(s, PROMPT, BLUE);
else if (s.contains("INFO Test ")) {
if (s.contains("Passed."))
textPane.append(s, FATAL, GREEN);
else if (s.contains("Failed."))
appendFailedTestRes
```
<Overlap Ratio: 0.4685638649900728>

---

--- 251 --
Question ID: 02ba5c430b56fa53c25a4d0f7607776b7d2fa8fe
Original Code:
```
@RunWith(ConcurrentJunitRunner.class)
@Concurrent()
public class CheckPasswordPolicyTest {

    private static final int passwordLength = 6;

    private static final int categoryCount = 3;

    private static final int tokenSize = 3;

    private static final CheckPasswordPolicy policy = new CheckPasswordPolicy();

    /**
     * Tests that a good password is valid according to all policy checks.
     */
    @Test
    public void testGoodPassword() {
        String username = "Enrique Rodriguez";
        String password = "d1r3ct0rY";
        assertTrue(policy.isValidPasswordLength(password, passwordLength));
        assertTrue(policy.isValidCategoryCount(password, categoryCount));
        assertTrue(policy.isValidUsernameSubstring(username, password, tokenSize));
        assertTrue(policy.isValid(username, password, passwordLength, categoryCount, tokenSize));
    }

    /**
     * Tests that a bad password fails all validity checks.
     */
    @Test
    public void testBadPassword() {
        String username = "Erin Randall";
        String password = "erin1";
        assertFalse(policy.isValidPasswordLength(password, passwordLength));
        assertFalse(policy.isValidCategoryCount(password, categoryCount));
        assertFalse(policy.isValidUsernameSubstring(username, password, tokenSize));
        assertFalse(policy.isValid(username, password, passwordLength, categoryCount, tokenSize));
    }

    /**
     * Tests variations of a password where the password includes tokens of the username.
     */
    @Test
    public void testPrincipalAsUsername() {
        String username = new KerberosPrincipal("erodriguez@EXAMPLE.COM").getName();
        String password1 = "d1r3ct0rY";
        String password2 = "ERodriguez@d1r3ct0rY";
        String password3 = "Example@d1r3ct0rY";
        assertTrue(policy.isValidUsernameSubstring(username, password1, tokenSize));
        assertFalse(policy.isValidUsernameSubstring(username, password2, tokenSize));
        assertFalse(policy.isValidUsernameSubstring(username, password3, tokenSize));
    }
}

```


Overlapping Code:
```
unWith(ConcurrentJunitRunner.class)
@Concurrent()
public class CheckPasswordPolic6;
private static final int categoryCount = 3;
private static final int tokenSize = 3;
private static final CheckPasswordPolicy policy = new CheckPasswordPolicy();
/**
* Tests that a good password is valid according to all policy checks.
*/
@Test
pubpassword, passwordLength, categoryCount, tokenSizevalidity checks.
*/
@Test
public void testBadPasswasswordLength));
assertFalse(policy.isValidCategorpassword, passwordLength, categoryCount, tokenSize* Tests variations of a password where the password includes tokens of the username.
*/
@Test
public
```
<Overlap Ratio: 0.3470847084708471>

---

--- 252 --
Question ID: 6ae321693fd396814c3cd664d6f460c3b1c7fca7
Original Code:
```
public class ChangePasswordRequestValidator implements Validator {

    static final PasswordValidator PASSWORD_VALIDATOR = new PasswordValidator(Arrays.asList(new LengthRule(8, 30), new CharacterRule(EnglishCharacterData.UpperCase, 1), new CharacterRule(EnglishCharacterData.LowerCase, 1), new CharacterRule(EnglishCharacterData.Digit, 1), new CharacterRule(EnglishCharacterData.Special, 1), new WhitespaceRule()));

    @Override
    public boolean supports(Class<?> clazz) {
        return ChangePasswordRequest.class.equals(clazz);
    }

    @Override
    public void validate(Object target, Errors e) {
        ChangePasswordRequest request = (ChangePasswordRequest) target;
        if (!Objects.equals(request.getNewPassword(), request.getNewPasswordAgain())) {
            e.rejectValue("newPasswordAgain", "password.mismatch");
        }
        RuleResult result = PASSWORD_VALIDATOR.validate(new PasswordData(request.getNewPassword()));
        if (!result.isValid()) {
            List<String> messages = PASSWORD_VALIDATOR.getMessages(result);
            String messageTemplate = messages.stream().collect(Collectors.joining(","));
            e.rejectValue("newPassword", messageTemplate);
        }
    }
}

```


Overlapping Code:
```
ator implements Validator {
static final PasswordValidator PASSWORD_VALIDATOR = new PasswordValidator(Arrays.asList(new LengthRunew CharacterRule(EnglishCharacterData.UpperCase, 1), new CharacterRule(EnglishCharacterData.LowerCase, 1), new CharacterRule(EnglishCharacterData.Digit, 1), new CharacterRule(EnglishCharacterData.Special, 1)new WhitespaceRule()));
@Override
public boolean supports(Class<?> clazz) {
return ChangePasswordRequest.class.equals(clazz);
}
@Override
public void validate(Object target, Errors e) {
ChangePasswordRequest request = (ChangePasswordRequest) target;
if (!Objects.equals(request.getNewPassword(), request.getNewPasswordAgain())) {
e.rejectValue("newPasswordAgain", "password.mismatch");
}
RuleResult result = PASSWORD_VALIDATOR.validate(new PasswordData(request.getNewPassword()));
if (!result.isValid()) {
List<String> messages = PASSWORD_VALIDATOR.getMessages(result);
String messageTemplate = messages.stream().collect(Collectors.joining(","rejectValue("newPassword", messageTemplate);
}
}
}
```
<Overlap Ratio: 0.9466421343146274>

---

--- 253 --
Question ID: 0edf3c02e23be62144e02ee6a86e492b3b1ef462
Original Code:
```
public class DefaultScriptDelegate extends AbstractDynamicObject implements ScriptDelegate {

    private Spin spin;

    public void setSpin(Spin spin) {
        this.spin = spin;
    }

    @Override
    public void apply(String pluginId) {
        Plugin<Spin> plugin = spin.getPluginManager().getPluginById(pluginId);
        plugin.apply(spin);
        spin.getPluginContainer().addPlugin(pluginId, plugin);
    }

    @Override
    public Object invokeMethod(String name, Object[] args) {
        for (Plugin<?> plugin : spin.getPluginContainer().getPlugins().values()) {
            Object result = tryInvokeMethod(plugin, name, args);
            if (result != null) {
                return result;
            }
        }
        throw new NoMethodFoundException(name);
    }
}

```


Overlapping Code:
```
ScriptDelegate extends AbstractDynamicObject implements ScriptDelegate {
private Spin spin;
public void setSpin(Spin spin) {
this.spin = spin;
}
@Override
public void apply(String pluginId) {
Plugin<Spin> plugin = spin.getPluginManager().getPluginById(pluginId);
plugin.apply(spin);
spin.getPluginCon;
}
@Override
public Object invokeMethod(String name, Object[] args) {
for (Plugin<?> plugin : spin.getPluginContainer().getPlugins().values()) {
Object result = tryInvokeMethod(plugin, name, args);
if (result != null) {
return result;
}
}
throw new NoMethodFound
```
<Overlap Ratio: 0.8810641627543035>

---

--- 254 --
Question ID: d1df0edd75da094a11db311dfe81daf5603081fa
Original Code:
```
public class ViewCommand extends Command {

    public static final String COMMAND_WORD = "view";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Displays the applicant details identified by the index number used in the displayed applicant list.\n" + "Parameters: INDEX (must be a positive integer) [T] (case sensitive)\n" + "Example: " + COMMAND_WORD + " 1 T";

    public static final String MESSAGE_VIEW_APPLICANT_SUCCESS = "Displayed Applicant details: %1$s";

    private final Index targetIndex;

    private final Boolean toggle;

    /**
     * User can view applicant details in Intern Watcher.
     */
    public ViewCommand(Index index, Boolean toggle) {
        this.targetIndex = index;
        this.toggle = toggle;
    }

    @Override
    public CommandResult execute(Model model) throws CommandException {
        requireNonNull(model);
        List<Applicant> lastShownList = model.getFilteredApplicantList();
        if (targetIndex != null) {
            if (targetIndex.getZeroBased() >= lastShownList.size()) {
                throw new CommandException(Messages.MESSAGE_INVALID_APPLICANT_DISPLAYED_INDEX);
            }
        }
        if (toggle) {
            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());
            model.displayApplicant(applicantToView, true);
            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS, applicantToView), false, false, true);
        } else {
            Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());
            model.displayApplicant(applicantToView, false);
            return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCESS, applicantToView), false, false, true);
        }
    }

    @Override
    public boolean equals(Object other) {
        return // short circuit if same object
        other == this || (// instanceof handles nulls
        // state check
        other instanceof ViewCommand && targetIndex.equals(((ViewCommand) other).targetIndex));
    }
}

```


Overlapping Code:
```
ublic class ViewCommand extends Command {
public static final String COMMAND_WORD = "view";
public static final String MESSAGE_USAGE = COMMAND_WORD + ": Displays the icant details identified by the index number used in the displayed applicant list.+ "Parameters: INDEX (must be a positive integer) [T] (case sensublic static final String MESSAGE_VIEW_APPLICANT_SUCCESS = "Displayed Applicant details: %1$s";
private final Index targetIndex;
private final Boolean toggle;
/**
* User can view applicant details in Intern Watcher.
*/
public ViewCommand(Index index, Boolean toggle) {
this.targetIndex = index;
this.toggle = toggle;
}
@Override
public CommandResult execute(Model model) throws CommandException {
requireNonNull(model);
List<Applicant> lastShownList = model.getFilteredApplicantList();
if (targetIndex != null) {
if (targetIndex.getZeroBased() >= lastShownList.size()) {
throw new CommandException(Messages.MESSAGE_INVALID_APPLICANT_DISPLAYED_INDEX);
}
}
if (toggle) {
Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());
model.displayApplicant(applicantToView, true);
return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCE
} else {
Applicant applicantToView = lastShownList.get(targetIndex.getZeroBased());
model.displayApplicant(applicantToView, false);
return new CommandResult(String.format(MESSAGE_VIEW_APPLICANT_SUCCE false, true);
}
}
@Override
public boolean equals(Object other) {
return getIndex.equals(((ViewCommand) other).targetIndex)
```
<Overlap Ratio: 0.8503130335799659>

---

--- 255 --
Question ID: 423faf3c08720e4a86a03cf520bae2cb7efce200
Original Code:
```
@RestrictTo({ RestrictTo.Scope.LIBRARY_GROUP_PREFIX })
public class AnimationUtilsCompat {

    private AnimationUtilsCompat() {
    }

    private static Interpolator createInterpolatorFromXml(Context context, Resources resources, Resources.Theme theme, XmlPullParser xmlPullParser) {
        Interpolator pathInterpolatorCompat;
        int depth = xmlPullParser.getDepth();
        Interpolator interpolator = null;
        for (; true; ) {
            int next = xmlPullParser.next();
            if ((next != 3 || xmlPullParser.getDepth() > depth) && next != 1) {
                if (next == 2) {
                    AttributeSet asAttributeSet = Xml.asAttributeSet(xmlPullParser);
                    String name = xmlPullParser.getName();
                    if (name.equals("linearInterpolator")) {
                        interpolator = new LinearInterpolator();
                    } else {
                        if (name.equals("accelerateInterpolator")) {
                            pathInterpolatorCompat = new AccelerateInterpolator(context, asAttributeSet);
                        } else if (name.equals("decelerateInterpolator")) {
                            pathInterpolatorCompat = new DecelerateInterpolator(context, asAttributeSet);
                        } else if (name.equals("accelerateDecelerateInterpolator")) {
                            interpolator = new AccelerateDecelerateInterpolator();
                        } else if (name.equals("cycleInterpolator")) {
                            pathInterpolatorCompat = new CycleInterpolator(context, asAttributeSet);
                        } else if (name.equals("anticipateInterpolator")) {
                            pathInterpolatorCompat = new AnticipateInterpolator(context, asAttributeSet);
                        } else if (name.equals("overshootInterpolator")) {
                            pathInterpolatorCompat = new OvershootInterpolator(context, asAttributeSet);
                        } else if (name.equals("anticipateOvershootInterpolator")) {
                            pathInterpolatorCompat = new AnticipateOvershootInterpolator(context, asAttributeSet);
                        } else if (name.equals("bounceInterpolator")) {
                            interpolator = new BounceInterpolator();
                        } else if (name.equals("pathInterpolator")) {
                            pathInterpolatorCompat = new PathInterpolatorCompat(context, asAttributeSet, xmlPullParser);
                        } else {
                            throw new RuntimeException("Unknown interpolator name: " + xmlPullParser.getName());
                        }
                        interpolator = pathInterpolatorCompat;
                    }
                }
            }
        }
        return interpolator;
    }

    public static Interpolator loadInterpolator(Context context, int i) {
        if (Build.VERSION.SDK_INT >= 21) {
            return AnimationUtils.loadInterpolator(context, i);
        }
        XmlResourceParser xmlResourceParser = null;
        if (i == 17563663) {
            try {
                return new FastOutLinearInInterpolator();
            } catch (XmlPullParserException e) {
                Resources.NotFoundException notFoundException = new Resources.NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(i));
                notFoundException.initCause(e);
                throw notFoundException;
            } catch (IOException e2) {
                Resources.NotFoundException notFoundException2 = new Resources.NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(i));
                notFoundException2.initCause(e2);
                throw notFoundException2;
            } catch (Throwable th) {
                if (xmlResourceParser != null) {
                    xmlResourceParser.close();
                }
                throw th;
            }
        } else if (i == 17563661) {
            return new FastOutSlowInInterpolator();
        } else {
            if (i == 17563662) {
                return new LinearOutSlowInInterpolator();
            }
            XmlResourceParser animation = context.getResources().getAnimation(i);
            Interpolator createInterpolatorFromXml = createInterpolatorFromXml(context, context.getResources(), context.getTheme(), animation);
            if (animation != null) {
                animation.close();
            }
            return createInterpolatorFromXml;
        }
    }
}

```


Overlapping Code:
```
c class AnimationUtilsCompat {
private AnimationUtilsCompat() {
}
private static Interpolator createInterpolatorFromXml(Context context, Resources resources, Resources.Theme theme, XmlPullParser xmlPullParser) {
Interpolator pathInterpolatorCompat;
int depth = xmlPullParser.getDepth();
Interpolator i
int next = xmlPullParser.next();
if ((next != 3 || xmlPullParser.getDepth() > depth) && next != 1) {
if (next == 2) {
AttributeSet asAttributeSet = Xml.asAttributeSet(xmlPullParser);
String name = xmlPullParser.getName();
if (name.equals("linearInterpolator")) {
interpolator = new LinearInterpolator();
} else {
if (name.equals("accelerateInterpolator")) {
pathInterpolatorCompat = new AccelerateInterpolator(context, asAttributeSet);
} else if (name.equals("decelerateInterpolator")) {
pathInterpolatorCompat = new DecelerateInterpolator(context, asAttributeSet);
} else if (name.equals("accelerateDecelerateInterpolator")) {
interpolator = new AccelerateDecelerateInterpolator();
} else if (name.equals("cycleInterpolator")) {
pathInterpolatorCompat = new CycleInterpolator(context, asAttributeSet);
} else if (name.equals("anticipateInterpolator")) {
pathInterpolatorCompat = new AnticipateInterpolator(context, asAttributeSet);
} else if (name.equals("overshootInterpolator")) {
pathInterpolatorCompat = new OvershootInterpolator(context, asAttributeSet);
} else if (name.equals("anticipateOvershootInterpolator")) {
pathInterpolatorCompat = new AnticipateOvershootInterpolator(context, asAttributeSet);
} else if (name.equals("bounceInterpolator")) {
interpolator = new BounceInterpolator();
} else if (name.equals("pathInterpolator")) {
pathInterpolatorCompat = new PathInterpolatorCompat(context, asAttribut
```
<Overlap Ratio: 0.9362050163576882>

---

--- 256 --
Question ID: 6121857566879d003fc4f936c4f45ac6ff2ab499
Original Code:
```
public class GrobidCitationFetcher implements SearchBasedFetcher {

    private static final Logger LOGGER = LoggerFactory.getLogger(GrobidCitationFetcher.class);

    private static final String GROBID_URL = "http://grobid.jabref.org:8070";

    private ImportFormatPreferences importFormatPreferences;

    private GrobidService grobidService;

    public GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences) {
        this(importFormatPreferences, new GrobidService(GROBID_URL));
    }

    GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences, GrobidService grobidService) {
        this.importFormatPreferences = importFormatPreferences;
        this.grobidService = grobidService;
    }

    /**
     * Passes request to grobid server, using consolidateCitations option to improve result. Takes a while, since the
     * server has to look up the entry.
     *
     * @return A BibTeX string if extraction is successful
     */
    private Optional<String> parseUsingGrobid(String plainText) {
        try {
            return Optional.of(grobidService.processCitation(plainText, GrobidService.ConsolidateCitations.WITH_METADATA));
        } catch (SocketTimeoutException e) {
            String msg = "Connection timed out.";
            LOGGER.debug(msg, e);
            throw new RuntimeException(msg, e);
        } catch (IOException e) {
            String msg = "Could not process citation. " + e.getMessage();
            LOGGER.debug(msg, e);
            throw new RuntimeException(msg, e);
        }
    }

    private Optional<BibEntry> parseBibToBibEntry(String bibtexString) {
        try {
            return BibtexParser.singleFromString(bibtexString, importFormatPreferences, new DummyFileUpdateMonitor());
        } catch (ParseException e) {
            return Optional.empty();
        }
    }

    @Override
    public List<BibEntry> performSearch(ComplexSearchQuery complexSearchQuery) throws FetcherException {
        List<BibEntry> bibEntries = null;
        // This just treats the complex query like a normal string query until it it implemented correctly
        String query = complexSearchQuery.toString();
        try {
            bibEntries = Arrays.stream(query.split("\\r\\r+|\\n\\n+|\\r\\n(\\r\\n)+")).map(String::trim).filter(str -> !str.isBlank()).map(this::parseUsingGrobid).flatMap(Optional::stream).map(this::parseBibToBibEntry).flatMap(Optional::stream).collect(Collectors.toList());
        } catch (RuntimeException e) {
            // un-wrap the wrapped exceptions
            throw new FetcherException(e.getMessage(), e.getCause());
        }
        return bibEntries;
    }

    @Override
    public String getName() {
        return "GROBID";
    }
}

```


Overlapping Code:
```
 class GrobidCitationFetcher implements SearchBasedFetcher {
private static final Logger LOGGER = LoggerFactory.getLogger(GrobidCitationFetcher.class);
private static final String GROBID_URL = "http://grobid.jabref.org:8070";
private ImportFormatPreferences importFormatPreferences;
private GrobidService grobidService;
public GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences) {
this(importFormatPreferences, new GrobidService(GROBID_URL));
}
GrobidCitationFetcher(ImportFormatPreferences importFormatPreferences, GrobidService grobidService) {
this.importFormatPreferences = importFormatPreferences;
this.grobidService = grobidService;
}
/**
* Passes request to grobid server, using consolidateCitations option to improve result. Takes a while, since the
* server has to look up the entry.
*
* @return A BibTeX string if extraction is successful
*/
private Optional<String> parseUsingGrobid(String plainText) {
try {
return Optional.of(grobidService.processCitation(plainText, GrobidService.ConsolidateCitations.WITH_METADATA));
} catch (SocketTimeoutException e) {
String msg = "Connection timed out.";
LOGGER.debug(msg, e);
throw new RuntimeException(msg, e);
} catch (IOException e) {
String msg = "Could not process citation. " + e.getMessage();
LOGGER.debug(msg, e);
throw new RuntimeException(msg, e);
}
}
private Optional<BibEntry> parseBibToBibEntry(String bibtexString) {
try {
return BibtexParser.singleFromString(bibtexString, importFormatPreferences, new DummyFileUpdateMonitor());
} catch (ParseException e) {
return Optional.empty();
}
}
@Override
public List<BibEntry> performSearch(ComplexSearchQuery complexSearchQuery) throws FetcherException {
List<BibEntry> bibEntries = null;
// This just treats the complex query like a normal string query until it it implemented correctly
String query = complexSearchQuerflatMap(Optional::stream).collect(Collectors.toList());
} catch (RuntimeException
```
<Overlap Ratio: 0.8923290203327172>

---

--- 257 --
Question ID: ad60ecfd5bb8c4cfd813c68c144210185e671f15
Original Code:
```
@Slf4j
@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private JavaMailSender javaMailSender;

    @Autowired
    private MailProperties mailProperties;

    @Override
    public void registerEmail(String subject, String content, String[] toUserEmailArray) {
        //??????
        MimeMessage mimeMessage = javaMailSender.createMimeMessage();
        // use the true flag to indicate you need a multipart message
        MimeMessageHelper mimeMessageHelper;
        try {
            mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);
            mimeMessageHelper.setSubject(subject);
            //??????
            mimeMessageHelper.setFrom(mailProperties.getUsername());
            //????????
            mimeMessageHelper.setTo(toUserEmailArray);
            //??????
            mimeMessageHelper.setText(content, true);
            //??????
            ClassPathResource classPathResource = new ClassPathResource("/static/images/share-public.png");
            //???? ??ID
            mimeMessageHelper.addInline("logoImage", classPathResource);
            //??????
            FileSystemResource fileSystemResource = new FileSystemResource(new File("C:\\Users\\xingyun\\Pictures\\program.jpg"));
            //????
            mimeMessageHelper.addAttachment("program.jpg", fileSystemResource);
            //????
            javaMailSender.send(mimeMessage);
        } catch (MessagingException e) {
            log.error("Messaging Exception:", e);
        }
    }
}

```


Overlapping Code:
```
@Slf4j
@Service
public class UserServiceImpl implements UserService {
@Autowired
private JavaMailSender javaMailSender;
@Autowired
private MailProperties mailProperties;
@Override
public void registerEmail(Strin
MimeMessage mimeMessage = javaMailSender.createMimeMessage();
// use the true flag to indicate you need a multipart message
MimeMessageHelper mimeMessageHelper;
try {
mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);
mimeMessageHelper.setSubgeHelper.setFrom(mailProperties.getUsername());
//
ClassPathResource classPathResource = new ClassPathResource("/static/images/share-public.png
FileSystemResource fileSystemResource = new FileSystemResource(new File("C:\\Users\\xingyun\\Pictures\\program.jpg"
javaMailSender.send(mimeMessage);
} catch (MessagingException e) {
log.error("Messagin
```
<Overlap Ratio: 0.6685902720527618>

---

--- 258 --
Question ID: e81c1f3aac9022f7c0a476697baebee32efeef68
Original Code:
```
class customers {

    int tableNo;

    String name;

    int phoneNo;

    void customerData() {
        Scanner sc = new Scanner(System.in);
        System.out.print("Entere no.    :");
        tableNo = sc.nextInt();
        System.out.print("Entermer name : ");
        name = sc.next();
        System.out.print("Entere no.    :");
        phoneNo = sc.nextInt();
    }
}

```


Overlapping Code:
```
() {
Scanner sc = new Scanner(System.in);
System.out.print("Entere no. :");
tableNo = sc.nextInt();
System.out.print("Entermer name : ");
name = sc.next();
System.out.print("Entere no. :
```
<Overlap Ratio: 0.6391752577319587>

---

--- 259 --
Question ID: 12958c18f6375a8f2d58b33654f17da5c8df2cff
Original Code:
```
public class DocMetadataServiceImpl extends DefaultComponent implements DocMetadataService {

    public static final String ENRICHMENT_ADDED = "ENRICHMENT_ADDED";

    protected static final TypeReference<List<AutoHistory>> HISTORY_TYPE = new TypeReference<List<AutoHistory>>() {
    };

    private static final Logger log = LogManager.getLogger(DocMetadataServiceImpl.class);

    /**
     * Have one of the supplied properties been modified?
     */
    public static boolean hadBeenModified(DocumentModel doc, Set<String> props) {
        if (props != null) {
            for (String propName : props) {
                try {
                    Property prop = doc.getProperty(propName);
                    if (prop != null && (prop.isDirty() || prop.isForceDirty())) {
                        return true;
                    }
                } catch (PropertyNotFoundException e) {
                }
            }
        }
        return false;
    }

    @Override
    public DocumentModel saveEnrichment(CoreSession session, EnrichmentMetadata metadata) {
        // TODO: Handle versions here?
        DocumentModel doc;
        try {
            doc = session.getDocument(new IdRef(metadata.context.documentRef));
        } catch (DocumentNotFoundException e) {
            log.info("Unable to save enrichment data for missing doc " + metadata.context.documentRef);
            return null;
        }
        Map<String, Object> anItem = metadata.toMap();
        if (anItem != null) {
            if (!doc.hasFacet(ENRICHMENT_FACET)) {
                doc.addFacet(ENRICHMENT_FACET);
            }
            @SuppressWarnings("unchecked")
            List<Map<String, Object>> enrichmentList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);
            if (enrichmentList == null) {
                enrichmentList = new ArrayList<>(1);
            }
            Collection<Map<String, Object>> allEnriched = updateEnrichment(enrichmentList, anItem);
            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, allEnriched);
            doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);
            raiseEvent(doc, ENRICHMENT_MODIFIED, null, metadata.getModelName());
        }
        return doc;
    }

    /**
     * Updates enrichment, ensures we have one enrichment entry per model/version and input
     */
    protected Collection<Map<String, Object>> updateEnrichment(List<Map<String, Object>> original, Map<String, Object> item) {
        Map<String, Map<String, Object>> enrichmentByKey = new HashMap<>();
        original.forEach(o -> enrichmentByKey.put(uniqueKey(o), o));
        enrichmentByKey.put(uniqueKey(item), item);
        return enrichmentByKey.values();
    }

    /**
     * Generate a unique key for a model/version/input combination
     */
    @SuppressWarnings("unchecked")
    protected String uniqueKey(Map<String, Object> suggestion) {
        String input = "";
        Object inputs = suggestion.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);
        // This is a little big strange, but it adapts to the type and calls the correct join method.
        if (inputs instanceof Set) {
            input = String.join(";", (Set<String>) inputs);
        } else if (inputs instanceof String[]) {
            input = String.join(";", (String[]) inputs);
        }
        return suggestion.get(ENRICHMENT_MODEL) + input;
    }

    @Override
    public DocumentModel updateAuto(DocumentModel doc, AUTO autoField, String xPath, String model, Serializable oldValue, String comment) {
        if (!doc.hasFacet(ENRICHMENT_FACET)) {
            doc.addFacet(ENRICHMENT_FACET);
        }
        Set<Map<String, String>> autoProps = getAutoPropAsSet(doc, autoField.lowerName());
        HashMap<String, String> prediction = new HashMap<>();
        prediction.put("xpath", xPath);
        prediction.put("model", model);
        autoProps.add(prediction);
        doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), autoProps);
        doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);
        if (oldValue != null) {
            List<AutoHistory> existingHistory = getAutoHistory(doc);
            // First remove old history if it exists
            List<AutoHistory> history = existingHistory.stream().filter(h -> !xPath.equals(h.getProperty())).collect(Collectors.toList());
            history.add(new AutoHistory(xPath, oldValue));
            setAutoHistory(doc, history);
        }
        raiseEvent(doc, autoField.eventName(), Collections.singleton(xPath), comment);
        storeAudit(doc, autoField, model, 1L, comment);
        return doc;
    }

    @Override
    public DocumentModel resetAuto(DocumentModel doc, AUTO autoField, String xPath, boolean resetValue) {
        List<AutoHistory> history = getAutoHistory(doc);
        Optional<AutoHistory> previous = history.stream().filter(h -> xPath.equals(h.getProperty())).findFirst();
        boolean present = previous.isPresent();
        Set<Map<String, String>> set = getAutoPropAsSet(doc, autoField.lowerName());
        Set<Map<String, String>> toReset = set.stream().filter(val -> val.get("xpath").equals(xPath)).collect(Collectors.toSet());
        @SuppressWarnings("unchecked")
        Collection<Map<String, String>> noOldXpath = CollectionUtils.disjunction(set, toReset);
        Object previousValue = null;
        if (set.size() > noOldXpath.size()) {
            if (present) {
                previousValue = previous.get().getPreviousValue();
                history.remove(previous.get());
                setAutoHistory(doc, history);
            }
            //Set the value
            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoField.lowerName(), noOldXpath);
            String comment = "Resetting " + xPath + " property";
            toReset.forEach(map -> {
                storeAudit(doc, autoField, map.get("model"), -1L, comment);
            });
            if (resetValue) {
                doc.setPropertyValue(xPath, (Serializable) previousValue);
            }
        }
        return doc;
    }

    protected Set<Map<String, String>> getAutoPropAsSet(DocumentModel doc, String autoPropertyName) {
        Set<Map<String, String>> autoProps = new HashSet<>(1);
        @SuppressWarnings("unchecked")
        List<Map<String, String>> filled = (List<Map<String, String>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME, autoPropertyName);
        if (filled != null) {
            autoProps.addAll(filled);
        }
        return autoProps;
    }

    protected void storeAudit(DocumentModel doc, AUTO autoField, String model, long value, String comment) {
        AuditLogger audit = Framework.getService(AuditLogger.class);
        if (audit != null) {
            LogEntry logEntry = audit.newLogEntry();
            logEntry.setCategory("AI");
            logEntry.setEventId(autoField.eventName());
            logEntry.setComment(comment);
            logEntry.setDocUUID(doc.getId());
            logEntry.setDocPath(doc.getPathAsString());
            logEntry.setEventDate(new Date());
            ExtendedInfoImpl.StringInfo modelInfo = new ExtendedInfoImpl.StringInfo(model);
            ExtendedInfoImpl.LongInfo one = new ExtendedInfoImpl.LongInfo(value);
            HashMap<String, ExtendedInfo> infos = new HashMap<>();
            infos.put("model", modelInfo);
            infos.put("value", one);
            logEntry.setExtendedInfos(infos);
            audit.addLogEntries(Collections.singletonList(logEntry));
        } else {
            log.warn("Audit Logger is not available");
        }
    }

    protected void raiseEvent(DocumentModel doc, String eventName, Set<String> xPaths, String comment) {
        DocumentEventContext ctx = new DocumentEventContext(doc.getCoreSession(), doc.getCoreSession().getPrincipal(), doc);
        ctx.setProperty(CoreEventConstants.REPOSITORY_NAME, doc.getRepositoryName());
        ctx.setProperty(CoreEventConstants.SESSION_ID, doc.getSessionId());
        String paths = null;
        if (xPaths != null && !xPaths.isEmpty()) {
            paths = String.join(",", xPaths);
        }
        ctx.setProperty(PATHS, paths);
        if (StringUtils.isEmpty(comment)) {
            ctx.setProperty(COMMENT_PROPERTY_KEY, paths);
        } else {
            ctx.setProperty(COMMENT_PROPERTY_KEY, comment);
        }
        Framework.getService(EventService.class).fireEvent(ctx.newEvent(eventName));
    }

    @Override
    public DocumentModel removeSuggestionsForTargetProperty(DocumentModel doc, String xPath) {
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);
        if (itemsList == null) {
            return doc;
        }
        List<Map<String, Object>> newSuggestList = new ArrayList<>(itemsList.size());
        itemsList.forEach(suggestObj -> {
            @SuppressWarnings("unchecked")
            List<Map<String, Object>> suggestions = (List<Map<String, Object>>) suggestObj.get(SUGGESTION_SUGGESTIONS);
            List<Map<String, Object>> newSuggestions = suggestions.stream().filter(s -> !xPath.equals(s.get(SUGGESTION_PROPERTY))).collect(Collectors.toList());
            if (!newSuggestions.isEmpty()) {
                suggestObj.put(SUGGESTION_SUGGESTIONS, newSuggestions);
                newSuggestList.add(suggestObj);
            }
        });
        doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, newSuggestList);
        raiseEvent(doc, ENRICHMENT_MODIFIED, Collections.singleton(xPath), SUGGESTION_SUGGESTIONS);
        return doc;
    }

    @Override
    public DocumentModel removeItemsForDirtyProperties(DocumentModel doc) {
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> itemsList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);
        if (itemsList == null || itemsList.isEmpty()) {
            return doc;
        }
        List<Map<String, Object>> cleanItemsList = new ArrayList<>(itemsList.size());
        Set<String> removedTargetProperties = new HashSet<>();
        itemsList.forEach(entry -> {
            String[] props = (String[]) entry.get(ENRICHMENT_INPUT_DOCPROP_PROPERTY);
            Set<String> inputProperties = props == null ? Collections.emptySet() : new HashSet<>(Arrays.asList(props));
            if (hadBeenModified(doc, inputProperties)) {
                @SuppressWarnings("unchecked")
                List<Map<String, Object>> suggestions = (List<Map<String, Object>>) entry.get(SUGGESTION_SUGGESTIONS);
                Set<String> targetProps = suggestions.stream().map(s -> (String) s.get(SUGGESTION_PROPERTY)).collect(Collectors.toSet());
                removedTargetProperties.addAll(targetProps);
            } else {
                cleanItemsList.add(entry);
            }
        });
        if (cleanItemsList.size() != itemsList.size()) {
            //We made some changes lets update
            doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, cleanItemsList);
            raiseEvent(doc, ENRICHMENT_MODIFIED, removedTargetProperties, "Dirty inputs");
        }
        return doc;
    }

    @Override
    public List<AutoHistory> getAutoHistory(DocumentModel doc) {
        try {
            Blob autoBlob = (Blob) doc.getProperty(ENRICHMENT_SCHEMA_NAME, AUTO.HISTORY.lowerName());
            if (autoBlob != null) {
                return MAPPER.readValue(autoBlob.getByteArray(), HISTORY_TYPE);
            }
        } catch (IOException e) {
            log.warn("Failed to read auto history blob", e);
        }
        return Collections.emptyList();
    }

    @Override
    public void setAutoHistory(DocumentModel doc, List<AutoHistory> history) {
        try {
            Blob autoBlob = Blobs.createJSONBlob(MAPPER.writeValueAsString(history));
            if (!doc.hasFacet(ENRICHMENT_FACET)) {
                doc.addFacet(ENRICHMENT_FACET);
            }
            String autoHistory = AUTO.HISTORY.lowerName();
            autoBlob.setFilename(autoHistory + "_" + doc.getName() + ".json");
            doc.setProperty(ENRICHMENT_SCHEMA_NAME, autoHistory, autoBlob);
        } catch (IOException e) {
            log.warn("Failed to set auto history blob", e);
        }
    }
}

```


Overlapping Code:
```
lic class DocMetadataServiceImpl extends DefaultComponent implements DocMetadataService {
public static final String ENRICHMENT_ADDED = "ENRICHMENT_ADDED";
protected static final TypeReference<List<AutoHistory>> HISTORY_TYPE = new TypeReference<List<AutoHistory>>() {
};
private static final Logger log = LogManager.getLogger(DocMetadataServiceImpl.class);
/**
* Have one of the supplied properties been modified?
*/
public static boolean hadBeenModified(DocumentModel doc, Set<String> props) {
if (props != null) {
for (String propName : props) {
try {
Property prop = doc.getProperty(propName);
if (prop != null && (prop.isDirty() || prop.isForceDirty())) {
return treption e) {
}
}
}
return false;
}
@Override
public DocumentModel saveEnrichment(CoreSession session, EnrichmentMetadata metadata) {
// TODO: Handle versions here?
DocumentModel doc;
try {
doc = session.getDocument(new IdRef(metadata.context.documentRef));
} catch (DocumentNotFoundException e) {
log.info("Unable to save enrichment data for missing doc " + metadata.context.documentRef);
return null;
}
Map<String, Object> anItem = metadata.toMap();
if (anItem != null) {
if (!doc.hasFacet(ENRICHMENT_FACET)) {
doc.addFacet(ENRICHMENT_FACET);
}
@SuppressWarnings("unchecked")
List<Map<String, Object>> enrichmentList = (List<Map<String, Object>>) doc.getProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS);
if (enrichmentList == null) {
enrichmentList = new ArrayList<>(1);
}
Collection<Map<String, Object>> allEnriched = updateEnrichment(enrichmentList, anItem);
doc.setProperty(ENRICHMENT_SCHEMA_NAME, ENRICHMENT_ITEMS, allEnriched);
doc.putContextData(ENRICHMENT_ADDED, Boolean.TRUE);
raiseEvent(doc, ENRICHMENT_MODIFIED, null, metadata.getModelName());
}
return doc;
}
/**
* Updates enrichment, ensures we have one enrichment entry per model/version and input
*/
protected Collection<Map<String, Object>> updateEnrichment(List<Map<String, Object>> original, Map<
```
<Overlap Ratio: 0.9743073047858942>

---

--- 260 --
Question ID: a95d8fe653bfdab75d936ec05cd4ea7fa852d3e6
Original Code:
```
public class d {

    /* renamed from: a  reason: collision with root package name */
    private String f691a;

    private String b;

    private Map<String, String> c;

    public String a() {
        return this.f691a;
    }

    public void a(String str) {
        this.f691a = str;
    }

    public String b() {
        return this.b;
    }

    public void b(String str) {
        this.b = str;
    }

    public Map<String, String> c() {
        return this.c;
    }

    public void a(Map<String, String> map) {
        this.c = map;
    }

    public boolean equals(Object obj) {
        if (!(obj instanceof d)) {
            return false;
        }
        d dVar = (d) obj;
        if (!TextUtils.equals(this.f691a, dVar.f691a) || !TextUtils.equals(this.b, dVar.b)) {
            return false;
        }
        Map<String, String> map = this.c;
        Map<String, String> map2 = dVar.c;
        if (map == map2 || map == null || map.equals(map2)) {
            return true;
        }
        return false;
    }

    public int hashCode() {
        String str = this.f691a;
        int i = 0;
        int hashCode = (str != null ? str.hashCode() : 0) * 31;
        String str2 = this.b;
        int hashCode2 = (hashCode + (str2 != null ? str2.hashCode() : 0)) * 31;
        Map<String, String> map = this.c;
        if (map != null) {
            i = map.hashCode();
        }
        return hashCode2 + i;
    }
}

```


Overlapping Code:
```
 class d {
/* renamed from: a reason: collision with root package name */
private String f691a;
private String b;
private Map<String, String> c;
public String a() {
return this.f691a;
}
public void a(String str) {
this.f691a = str;
}
public String b() {
return this.b;
}
public void b(String str) {
this.b = str;
}
public Map<String, String> c() {
return this.c;
}
public void a(Map<String, String> map) {
this.c = map;
}
public boolean equals(Object obj) {
if (!(obj instanceof d)) {
return false;
}
d dVar = (d) obj;
if (!TextUtils.equals(this.f691a, dVar.f691a) || !TextUtils.equals(this.b, dVar.b)) {
return false;
}
Map<String, String> map = this.c;
Map<String, String> map2 = dVar.c;
if (map == map2 || map == null || map.equals(map2)) {
return true;
}
return false;
}
public int hashCode() {
String str = this.f691a;
int i = 0;
int hashCode = (str != null ? str.hashCode() : 0) * 31;
String str2 = this.b;
int hashCode2 = (hashCode + (str2 != null ? str2.hashCode() : 0)) * 31;
Map<String, String> map = this.c;
if (map != null) {
i = map.hashCode(
```
<Overlap Ratio: 0.9670027497708524>

---

--- 261 --
Question ID: 6bfcbd87be2fa0596ebe5830cc52201b86851996
Original Code:
```
public class FeedJournalStorage implements JournalStorage {

    private FeedJournalBridge mFeedJournalBridge;

    /**
     * Creates a {@link FeedJournalStorage} for storing journals for the current user.
     *
     * @param profile {@link Profile} of the user we are rendering the Feed for.
     */
    public FeedJournalStorage(Profile profile) {
        mFeedJournalBridge = new FeedJournalBridge(profile);
    }

    /**
     * Creates a {@link FeedJournalStorage} for testing.
     *
     * @param bridge {@link FeedJournalBridge} implementation can handle journal storage request.
     */
    @VisibleForTesting
    public FeedJournalStorage(FeedJournalBridge bridge) {
        mFeedJournalBridge = bridge;
    }

    /**
     * Cleans up {@link FeedJournalStorage}.
     */
    public void destroy() {
        assert mFeedJournalBridge != null;
        mFeedJournalBridge.destroy();
        mFeedJournalBridge = null;
    }

    @Override
    public void read(String journalName, Consumer<Result<List<byte[]>>> consumer) {
        if (mFeedJournalBridge == null) {
            consumer.accept(Result.failure());
        } else {
            mFeedJournalBridge.loadJournal(journalName, (byte[][] entries) -> {
                List<byte[]> journal = Arrays.asList(entries);
                consumer.accept(Result.success(journal));
            }, (Void ignored) -> consumer.accept(Result.failure()));
        }
    }

    @Override
    public void commit(JournalMutation mutation, Consumer<CommitResult> consumer) {
        if (mFeedJournalBridge == null) {
            consumer.accept(CommitResult.FAILURE);
        } else {
            mFeedJournalBridge.commitJournalMutation(mutation, (Boolean result) -> consumer.accept(result ? CommitResult.SUCCESS : CommitResult.FAILURE));
        }
    }

    @Override
    public void exists(String journalName, Consumer<Result<Boolean>> consumer) {
        if (mFeedJournalBridge == null) {
            consumer.accept(Result.failure());
        } else {
            mFeedJournalBridge.doesJournalExist(journalName, (Boolean exist) -> consumer.accept(Result.success(exist)), (Void ignored) -> consumer.accept(Result.failure()));
        }
    }

    @Override
    public void getAllJournals(Consumer<Result<List<String>>> consumer) {
        if (mFeedJournalBridge == null) {
            consumer.accept(Result.failure());
        } else {
            mFeedJournalBridge.loadAllJournalKeys((String[] data) -> consumer.accept(Result.success(Arrays.asList(data))), (Void ignored) -> consumer.accept(Result.failure()));
        }
    }

    @Override
    public void deleteAll(Consumer<CommitResult> consumer) {
        if (mFeedJournalBridge == null) {
            consumer.accept(CommitResult.FAILURE);
        } else {
            mFeedJournalBridge.deleteAllJournals((Boolean result) -> consumer.accept(result ? CommitResult.SUCCESS : CommitResult.FAILURE));
        }
    }
}

```


Overlapping Code:
```
FeedJournalStorage implements JournalStorage {
private FeedJournalBridge mFeedJournalBridge;
/**
* Creates a {@link FeedJournalStorage} for storing journals for the current user.
*
* @param profile {@link Profile} of the user we are rendering the Feed for.
*/
public FeedJournalStorage(Profile profile) {
mFeedJournalBridge = new FeedJournalBridge(profile);
}
/**
* Creates a {@link FeedJournalStorage} for testing.
*
* @param bridge {@link FeedJournalBridge} implementation can handle journal storage request.
*/
@VisibleForTesting
public FeedJournalStorage(FeedJournalBridge bridge) {
mFeedJournalBournalBridge != null;
mFeedJournalBridge.destroy();
mFeedJournalBridge = null;
}
@Override
public void read(String journalName, Consumer<Result<List<byte[]>>> consumer) {
if (mFeedJournalBridge == null) {
consumer.accept(Result.failure());
} else {
mFeedJournalBridge.loadJournal(journalName, (byte[][] entries) -> {
List<byte[]> journal = Arrays.asList(entries);
consumer.accept(Result.success(journal));
}, (Void ignored) -> consumer.accept(Result.failure()));
}
}
@Override
public void commit(JournalMutation mutation, Consumer<CommitResult> consumer) {
if (mFeedJournalBridge == null) {
consumer.accept(CommitResult.FAILURE);
} else {
mFeedJolt.SUCCESS : CommitResult.FAILURE));
}
}
@Override
public void exists(String journalName, Consumer<Result<Boolean>> consumer) {
if (mFeedJournalBridge == null) {
consumer.accept(Result.failure());
} else {
mFeedJournalBridge.doesJournalExist(journalNd ignored) -> consumer.accept(Result.failure()));
}
}
@Override
public void getAllJournals(Consumer<Result<List<String>>> consumer) {
if (mFeedJournalBridge == null) {
consumer.accept(Result.failure());
} else {
mFeedJournalBrid
```
<Overlap Ratio: 0.8268585131894485>

---

--- 262 --
Question ID: f32ebfdbffc4b4b0bf2bdc7964404d3ed28b32b8
Original Code:
```
public final class EventSms extends Event {

    public static final String TYPE = "type_sms";

    public static final String EXTRA_TIME = "extra_time";

    public static final String EXTRA_DIRECTION = "extra_direction";

    public static final String EXTRA_PHONE_NUMBER = "extra_phone_number";

    public static final String EXTRA_DATA = "extra_message_body";

    public static final String EXTRA_CONTACT_NAME = "extra_contact_name";

    private long _id;

    private long time;

    private short direction;

    private String phonenumber;

    private String data;

    private String contactName;

    public EventSms() {
    }

    /**
     * This constructor is suitable for create a new object
     */
    public EventSms(long time, short direction, String phonenumber, String data, String remoteparty) {
        this.type = Event.TYPE_SMS;
        this.rowId = Event.ROWID_UNKNOWN;
        this.identifier = generateIdentifier();
        this.sendAttempts = 0;
        this.time = time;
        this.direction = direction;
        this.phonenumber = phonenumber;
        this.data = data;
        this.contactName = remoteparty;
    }

    /**
     * This constructor is suitable for instantiate from database,
     * where you already got all important information
     */
    public EventSms(int rowId, int identifier, int sendAttempts, long time, short direction, String phonenumber, String data, String remoteparty) {
        this.type = Event.TYPE_SMS;
        this.rowId = rowId;
        this.identifier = identifier;
        this.sendAttempts = sendAttempts;
        this.time = time;
        this.direction = direction;
        this.phonenumber = phonenumber;
        this.data = data;
        this.contactName = remoteparty;
    }

    public String toString() {
        String singleLineFormat = String.format("EventSMS = { " + "Error = %1$b; ErrorMessage = %2$s; " + "Type = %3$d; RowId = %4$d; " + "Indentifier = %5$d; SendAttempts = %6$d; " + "Time = %7$s; Direction = %8$d; " + "Phonenumber = %9$s; Data = %10$s; " + "Remoteparty = %11$s }", this.error, this.errorMessage, this.type, this.rowId, this.identifier, this.sendAttempts, GeneralUtil.getDateFormatter().format(new Date(time)), this.direction, this.phonenumber, this.data.replace("\n", ""), this.contactName);
        return singleLineFormat;
    }

    public ContentValues getContentValues() {
        ContentValues contentValues = new ContentValues();
        contentValues.put(EventDatabaseMetadata.IDENTIFIER, getIdentifier());
        contentValues.put(EventDatabaseMetadata.SENDATTEMPTS, getSendAttempts());
        contentValues.put(EventDatabaseMetadata.Sms.TIME, getTime());
        contentValues.put(EventDatabaseMetadata.Sms.DIRECTION, getDirection());
        contentValues.put(EventDatabaseMetadata.Sms.PHONENUMBER, getPhonenumber());
        contentValues.put(EventDatabaseMetadata.Sms.DATA, getData());
        contentValues.put(EventDatabaseMetadata.Sms.CONTACT_NAME, getContactName());
        return contentValues;
    }

    public long getTime() {
        return time;
    }

    public short getDirection() {
        return direction;
    }

    public void setPhoneNumber(String number) {
        this.phonenumber = number;
    }

    public String getPhonenumber() {
        return phonenumber;
    }

    public void setDate(String data) {
        this.data = data;
    }

    public String getData() {
        return data;
    }

    public String getContactName() {
        return contactName;
    }

    public void setId(long id) {
        _id = id;
    }

    public long getId() {
        return _id;
    }

    @Override
    public String getShortDescription() {
        return String.format("SMS number: %s, contactName: %s, msg: %s, time: %s", phonenumber, contactName, data, time);
    }
}

```


Overlapping Code:
```
xtends Event {
public static final String TYPE = "
public static final String EXTRA_TIME = "extra_time";
public static final String EXTRA_DIRECTION = "extra_direction";
public static final String EXTRA_PHONE_NUMBER = "extra_phone_number";
public static final String EXTRA_DATA = "extra_message_body";
public static final String EXTRA_CONTACT_NAME = "extra_contact_name";
private long _id;
private long time;
private short direction;
private String phonenumber;
private String data;
private String conconstructor is suitable for create a new object
*/
public EventSms(long time, short direction, String phonenumber, String data, Stis.type = Event.TYPE_SMS;
this.rowId = Event.ROWID_UNKNOWN;
this.identifier = generateIdentifier();
this.sendAttemp;
this.time = time;
this.direction = direction;
this.phonenumber = phonenumber;
this.data = data;
this.contactName = remoteparty/**
* This constructor is suitable for instantiate from database,where you already got all important information
*/
public EventSms(int rowIdort direction, String phonenumber, String data, Stthis.rowId = rowId;
this.identifier = identifier;
this.sendAttempts = send;
this.time = time;
this.direction = direction;
this.phonenumber = phonenumber;
this.data = data;
this.contactName = remotepartyublic String toString() {
String singleLineFormat = String.format("EventSMS = { " +t;
}
public ContentValues getContentValues() {
ContentValues contentValues = new ContentValues();
contentValues.put(EventDatabaseMetadata.
```
<Overlap Ratio: 0.6793056190041115>

---

--- 263 --
Question ID: ffa7aaacd75d5ecdbf2cb0c38e1b729e373cae89
Original Code:
```
public class FragmentationSiteIntensityIonSpecific extends AbstractStatistic {

    private HashMap<String, HashMap<String, int[]>> m_FragmentationSiteOccurence = new HashMap<String, HashMap<String, int[]>>();

    private int m_countSpectra = 0;

    private int m_groups = 10;

    private String[] convertFragmentationSite(MatchedXlinkedPeptide match, Fragment f) {
        FragmentationSite fs = f.getFragmentationSites()[0];
        String[] siteNames = new String[] { fs.NTerm.SequenceID, fs.CTerm.SequenceID };
        if (fs.site == 0) {
            siteNames[0] += "nt";
        }
        if (fs.site == fs.peptide.length() - 1) {
            siteNames[1] += "ct";
        }
        if (fs.site == match.getLinkingSite(fs.peptide)) {
            siteNames[0] += "xl";
        }
        if (fs.site + 1 == match.getLinkingSite(fs.peptide)) {
            siteNames[1] += "xl";
        }
        return siteNames;
    }

    protected boolean checkCrosslinked(Fragment f, int linkSide) {
        if (f.getStart() <= linkSide && linkSide <= f.getEnd() && f.isClass(CrosslinkedFragment.class)) {
            return true;
        } else if ((f.getStart() > linkSide || linkSide > f.getEnd()) && !f.isClass(CrosslinkedFragment.class)) {
            return true;
        }
        return false;
    }

    /**
     * @return the m_countSpectra
     */
    public int getSeenSpectra() {
        return m_countSpectra;
    }

    public FragmentationSiteIntensityIonSpecific() {
    }

    public boolean validFragment(Fragment f) {
        // no loss and no double fragmentation
        return (!(f instanceof Loss)) && f.getFragmentationSites().length == 1;
    }

    public boolean canCountFragment(Fragment f, int charge, MatchedFragmentCollection mfc) {
        if (f.getFragmentationSites().length != 1) {
            return false;
        }
        if (f instanceof Loss) {
            MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f, charge);
            return mbf.isBaseFragmentFound();
        } else
            return true;
    }

    private void incrementSite(String n, String c, int group) {
        HashMap<String, int[]> nGroup = m_FragmentationSiteOccurence.get(n);
        if (nGroup == null) {
            nGroup = new HashMap<String, int[]>();
            int[] cGroup = new int[m_groups + 1];
            java.util.Arrays.fill(cGroup, 0);
            cGroup[group] = 1;
            nGroup.put(c, cGroup);
            m_FragmentationSiteOccurence.put(n, nGroup);
        } else {
            int[] cGroup = nGroup.get(c);
            if (cGroup == null) {
                cGroup = new int[m_groups + 1];
                java.util.Arrays.fill(cGroup, 0);
                cGroup[group] = 1;
                nGroup.put(c, cGroup);
            } else
                cGroup[group]++;
        }
    }

    public void countSpectraMatch(MatchedXlinkedPeptide match) {
        MatchedFragmentCollection mfc = match.getMatchedFragments();
        Spectra deisotoped = match.getSpectrum().deIsotop();
        HashMap<String, HashMap<String, Boolean>> foundSites = new HashMap<String, HashMap<String, Boolean>>();
        HashMap<Fragment, Boolean> foundFragments = new HashMap<Fragment, Boolean>();
        // read out all possible fragmentation sites
        for (Fragment f : match.getPossibleFragments()) {
            if (validFragment(f)) {
                foundFragments.put(f, Boolean.FALSE);
            }
        }
        // among all peaks sorted by intensity
        Collection<SpectraPeak> peaks = deisotoped.getTopPeaks(-1);
        int group = 0;
        int peakCount = peaks.size();
        double groupSize = peakCount / (double) m_groups;
        int currentPeak = -1;
        int counted = 0;
        for (SpectraPeak sp : peaks) {
            currentPeak++;
            group = (int) (currentPeak / groupSize);
            for (SpectraPeakMatchedFragment mf : sp.getMatchedAnnotation()) {
                Fragment f = mf.getFragment();
                MatchedBaseFragment mbf = mfc.getMatchedFragmentGroup(f, mf.getCharge());
                // only if the fragment matches the conditions and was not found yet
                if (canCountFragment(f, mf.getCharge(), mfc) && !foundFragments.get(mbf.getBaseFragment())) {
                    String[] siteNames = convertFragmentationSite(match, f);
                    String n = siteNames[0];
                    String c = siteNames[1];
                    // only if we didn't count that site combination already
                    foundFragments.put(mbf.getBaseFragment(), Boolean.TRUE);
                    incrementSite(n, c, group);
                    counted++;
                }
            }
        }
        int found = 0;
        int missed = 0;
        // now look at all non matched fragmentation sites
        for (Fragment f : foundFragments.keySet()) {
            if (!foundFragments.get(f)) {
                missed++;
                String[] siteNames = convertFragmentationSite(match, f);
                String n = siteNames[0];
                String c = siteNames[1];
                incrementSite(n, c, m_groups);
            } else {
                found++;
            }
        }
        System.err.println("counted : " + counted + ",  found : " + found + ",  missed : " + missed);
        m_countSpectra++;
    }

    @Override
    public void writeFile(OutputStream output) {
        PrintStream out = new PrintStream(output);
        out.print("C,N");
        int i = 1;
        while (i <= m_groups) try {
            out.print("," + (100.0 * i / (double) m_groups));
        } finally {
            i++;
        }
        out.print(", notFound");
        out.println(getTable());
        out.flush();
    }

    public String getTable() {
        //StringBuffer ret = new StringBuffer("#intesity based fragmentation events of aminoacid pairs\n");
        StringBuffer ret = new StringBuffer();
        String[] nList = m_FragmentationSiteOccurence.keySet().toArray(new String[0]);
        java.util.Arrays.sort(nList);
        for (String n : nList) {
            HashMap<String, int[]> cGroups = m_FragmentationSiteOccurence.get(n);
            String[] cList = cGroups.keySet().toArray(new String[0]);
            java.util.Arrays.sort(cList);
            for (String c : cList) {
                int[] groups = cGroups.get(c);
                ret.append(n + "," + c);
                for (int count : groups) {
                    ret.append("," + count);
                }
                ret.append("\n");
            }
        }
        return ret.toString();
    }
}

```


Overlapping Code:
```
tyIonSpecific extends AbstractStatistic {
private ionSiteOccurence = new HashMap<String, HashMap<String, int[]>>();
private int m_countSpectra = 0;
private int m_groups = 10;
private String[] convertFragmentationSite(MatchedXlinkedPeptide match, Fragment f) {
FragmentationSite fs = f.getFragmentationSites()[0];
String[] siteNames = new Stringeptide.length() - 1) {
siteNames[1] += "ct";
}
if (fs.site == match.getLinkingSite(fs.peptide)) {
siteNames[0] += "xl";
}
if (fs.site + 1 == match.getLinkingSite(fs.peptide)) {
siteNames[1] += "xl";
}
return siteNames;
}
protected boolean checkCrosslinked(Fragment f, int linkSide) {
if (f.getStart() <= linkSide && linkSide <= f.getEnd() && f.isClass(CrosslinkedFragment.class)) {
return true;
} else if ((f.getStart() > linkSide || linkSide > f.getEnd()) && !f.isClass(CrosslinkedFragment.class)) {
return true;
}
return false;
}
/**
* @return the m_countSpectra
*/
public int getSeenSpectra() {
re validFragment(Fragment f) {
// no loss and no double fra& f.getFragmentationSites().length == 1;
}
public boolean canCountFragment(Fragment f, int charge, MatchedFragmentCollection mfc) {
if (f.getFragmentationSites().length != 1) {
return false;
}
if (f instanceof Loss) {
MatchedBaseFragment mbf = mfc.getMatchedFragmentGrouFragmentFound();
} else
return true;
}
private void incrementSite(String n, String c, int group) {
HashMap<e.get(n);
if (nGroup == null) {
nGroup = new HashMap<String, int[]>();
int[] cGroup = new int[m_groups + 1];
java.util.Arrays.fill(cGroup, 0);
cGroup[group] = 1;
nGroup.put(c, cGroup);
m_Fragmentation
```
<Overlap Ratio: 0.7811881188118812>

---

--- 264 --
Question ID: 0a90942c9de76f337b39b5c7475c993ad265d6d6
Original Code:
```
public class QueryRunner {

    private Tokenizer tokenizer;

    private Parser parser;

    private Interpreter interpreter;

    public QueryRunner() {
        tokenizer = new SimpleTokenizer();
        parser = new Parser();
        interpreter = new Interpreter();
    }

    public QueryRunner(Tokenizer tokenizer, Parser parser, Interpreter interpreter) {
        this.tokenizer = tokenizer;
        this.parser = parser;
        this.interpreter = interpreter;
    }

    public Boolean runQuery(String query, Map<String, Object> valueMap) throws MissingValueException, WrongDataTypeException {
        List<Token> tokens = tokenizer.tokenize(query);
        AbstractSyntaxTree ast = parser.generateAst(tokens);
        return interpreter.interpretAst(ast, valueMap);
    }

    public Boolean runQuery(AbstractSyntaxTree ast, Map<String, Object> valueMap) throws MissingValueException, WrongDataTypeException {
        return interpreter.interpretAst(ast, valueMap);
    }

    public AbstractSyntaxTree generateAst(String query) {
        List<Token> tokens = tokenizer.tokenize(query);
        return parser.generateAst(tokens);
    }
}

```


Overlapping Code:
```
private Tokenizer tokenizer;
private Parser parser;
private Interpreter interpreter;
public QueryRunner() {
tokenizer = new SimpleTokenizer();
parser = newlic QueryRunner(Tokenizer tokenizer, Parser parser, Interpreter interpreter) {
this.tokenizer = tokenizer;
this.parser = parser;
this.interpreter = interpreter;
}
public Boolean runQuery(String query, Map<String, Object> valueMap) throws MissingValueException, WrongDataTypeException {
List<Token> tokens = tokenizer.tokenize(query);
AbstractSyntaxTree ast = parser.generateAst(tokens);
return interpan runQuery(AbstractSyntaxTree ast, Map<String, Object> valueMap) throws MissingValueException, WrongDataTypeException {
return interpreter.interpretAst(ast, valueMap);
}
public AbstractSyntaxTree generateAst(String query) {
List<Token> tokens = tokenizer.tokenize(query);
return parser.generateAst(t
```
<Overlap Ratio: 0.8627648839556004>

---

--- 265 --
Question ID: 71f70801a9b50116a217f6493cec5ea7f30a0487
Original Code:
```
@ServiceComponentRenderer
public class CryptoAdapterRegistrationRenderer implements Renderer {

    private final String INLINE_JS = "function setCryptoKey(key) {\n" + "    var buffer, view;\n" + "    if (Array.isArray(key) && (key.length === 32 || key.length === 16)) {\n" + "        try {\n" + "            buffer = new ArrayBuffer(key.length);\n" + "            view = new Uint8Array(buffer);\n" + "            view.set(key);\n" + "        } catch (ignored) {}\n" + "    }\n" + "    CryptoAdapter.setKey(buffer);\n" + "}\n" + "debug && $A.log('CryptoAdapter registering');\n" + "var CryptoAdapter = $A.storageService.CryptoAdapter;\n" + "CryptoAdapter.register();\n" + "if (!$A.storageService.isRegisteredAdapter(CryptoAdapter.NAME)) {\n" + "    $A.log('CryptoAdapter was not registered');\n" + "    return;\n" + "}\n" + "setCryptoKey(key);\n";

    private ConfigAdapter configAdapter;

    @Override
    public void render(BaseComponent<?, ?> component, RenderContext renderContext) throws IOException, QuickFixException {
        Boolean debug = (Boolean) component.getAttributes().getValue("debugLoggingEnabled");
        String key = configAdapter.getEncryptionKey();
        renderContext.pushScript();
        renderContext.getCurrent().append("(function(debug, key){\n").append(INLINE_JS).append("\n}(").append(String.valueOf(debug)).append(",").append(String.valueOf(key)).append("));");
        renderContext.popScript();
    }

    @Inject
    public void setConfigAdapter(ConfigAdapter configAdapter) {
        this.configAdapter = configAdapter;
    }
}

```


Overlapping Code:
```
onentRenderer
public class CryptoAdapterRegistrationRenderer implements Renderer {
private final String INLIif (Array.isArray(key) && (key.length === 32 || key.length === 16)) orageService.isRegisteredAdapter(CryptoAdapter.NAME)) {\rivate ConfigAdapter configAdapter;
@Override
public void render(BaseComponent<?, ?> component, RenderContext renderContext) throws IOException, QuickFixException {
Boolean debug = (Boolean) component.getAttributes().getValue("debugLoggingEnabled");
String keyderContext.pushScript();
renderContext.getCurrent(ppend("\n}(").append(String.valueOf(debug)).append(",").append(String.valueOf(key)).append("));");
renderContext.popScript();
}
@Inject
public void setConfigAdapter(ConfigAdapter configAdapter) {
this.configAdapter = configAdapter;
}

```
<Overlap Ratio: 0.5464788732394367>

---

--- 266 --
Question ID: 236dd9c3e3386bd6a06a244e8ea1516692f3c35d
Original Code:
```
public class PluginXMLTextHover extends PDETextHover {

    private PDESourcePage fSourcePage;

    public PluginXMLTextHover(PDESourcePage sourcePage) {
        fSourcePage = sourcePage;
    }

    @Override
    public String getHoverInfo(ITextViewer textViewer, IRegion hoverRegion) {
        int offset = hoverRegion.getOffset();
        IDocumentRange range = fSourcePage.getRangeElement(offset, true);
        if (range instanceof IDocumentTextNode)
            return checkTranslatedValue((IDocumentTextNode) range);
        if (!(range instanceof IPluginObject))
            return null;
        ISchema schema = getExtensionSchema((IPluginObject) range);
        if (schema != null) {
            ISchemaObject sObj = getSchemaObject(schema, (IPluginObject) range);
            if (sObj == null) {
                return null;
            } else if (range instanceof IPluginAttribute && sObj instanceof ISchemaElement) {
                IDocumentAttributeNode da = (IDocumentAttributeNode) range;
                if (da.getNameOffset() <= offset && offset <= da.getNameOffset() + da.getNameLength() - 1)
                    // inside name
                    return getAttributeText((IPluginAttribute) range, (ISchemaElement) sObj);
                else if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1)
                    // inside value
                    return getAttributeValueText((IPluginAttribute) range, (ISchemaElement) sObj);
            } else if (range instanceof IPluginElement) {
                IDocumentElementNode dn = (IDocumentElementNode) range;
                int dnOff = dn.getOffset();
                int dnLen = dn.getLength();
                String dnName = dn.getXMLTagName();
                if (dnOff + 1 <= offset && offset <= dnOff + dnName.length())
                    // inside opening tag
                    return getElementText((ISchemaElement) sObj);
                try {
                    String nt = textViewer.getDocument().get(dnOff, dnLen);
                    if (//$NON-NLS-1$
                    //$NON-NLS-1$
                    nt.//$NON-NLS-1$
                    endsWith("</" + dnName + '>')) {
                        offset = offset - dnOff;
                        if (nt.length() - dnName.length() - 1 <= offset && offset <= nt.length() - 2)
                            // inside closing tag
                            return getElementText((ISchemaElement) sObj);
                    }
                } catch (BadLocationException e) {
                }
            }
        } else if (range instanceof IDocumentAttributeNode && ((IDocumentAttributeNode) range).getEnclosingElement() instanceof IPluginExtensionPoint)
            return getExtensionPointHoverInfo((IPluginObject) range, offset);
        return null;
    }

    private String getExtensionPointHoverInfo(IPluginObject object, int offset) {
        IDocumentAttributeNode da = (IDocumentAttributeNode) object;
        if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1) {
            String value = da.getAttributeValue();
            if (//$NON-NLS-1$
            da.getAttributeName().equals(IPluginObject.P_NAME) && value.startsWith("%"))
                return object.getResourceString(value);
        }
        return null;
    }

    private ISchema getExtensionSchema(IPluginObject object) {
        IPluginObject extension = object;
        if (object instanceof IDocumentAttributeNode)
            extension = (IPluginObject) ((IDocumentAttributeNode) object).getEnclosingElement();
        for (; extension != null && !(extension instanceof IPluginExtension); ) extension = extension.getParent();
        if (extension == null)
            // started off outside of an extension element
            return null;
        String point = ((IPluginExtension) extension).getPoint();
        return PDECore.getDefault().getSchemaRegistry().getSchema(point);
    }

    private ISchemaObject getSchemaObject(ISchema schema, IPluginObject object) {
        if (object instanceof IPluginElement)
            return schema.findElement(((IPluginElement) object).getName());
        if (object instanceof IPluginExtension)
            //$NON-NLS-1$
            return schema.findElement("extension");
        if (object instanceof IDocumentAttributeNode)
            return schema.findElement(((IDocumentAttributeNode) object).getEnclosingElement().getXMLTagName());
        return null;
    }

    private String getAttributeText(IPluginAttribute attrib, ISchemaElement sEle) {
        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());
        if (sAtt == null)
            return null;
        return sAtt.getDescription();
    }

    private String getAttributeValueText(IPluginAttribute attrib, ISchemaElement sEle) {
        if (//$NON-NLS-1$
        sEle.getName().equals("extension") && attrib.getName().equals(IPluginExtension.P_POINT))
            return getSchemaDescription(attrib, sEle);
        ISchemaAttribute sAtt = sEle.getAttribute(attrib.getName());
        if (sAtt == null)
            return null;
        String value = attrib.getValue();
        if (//$NON-NLS-1$
        sAtt.isTranslatable() && value.startsWith("%"))
            return attrib.getResourceString(value);
        return null;
    }

    private String getSchemaDescription(IPluginAttribute attr, ISchemaElement sEle) {
        String description = XMLComponentRegistry.Instance().getDescription(attr.getValue(), XMLComponentRegistry.F_SCHEMA_COMPONENT);
        if (description == null) {
            URL url = sEle.getSchema().getURL();
            SchemaAnnotationHandler handler = new SchemaAnnotationHandler();
            SchemaUtil.parseURL(url, handler);
            description = handler.getDescription();
            XMLComponentRegistry.Instance().putDescription(attr.getValue(), description, XMLComponentRegistry.F_SCHEMA_COMPONENT);
        }
        return description;
    }

    private String getElementText(ISchemaElement sEle) {
        if (sEle == null) {
            return null;
        }
        return sEle.getDescription();
    }

    private String checkTranslatedValue(IDocumentTextNode node) {
        String value = node.getText();
        if (//$NON-NLS-1$
        value.startsWith("%"))
            return ((IPluginObject) node.getEnclosingElement()).getResourceString(value);
        return null;
    }
}

```


Overlapping Code:
```
public class PluginXMLTextHover extends PDETextHover {
private PDESourcePage fSourcePage;
public PluginXMLTextHover(PDESourcePage sourcePage) {
fSourcePage = sourcePage;
}
@Override
public String getHoverInfo(ITextViewer textViewer, IRegion hoverRegion) {
int offset = hoverRegion.getOffset();
IDocumentRange range = fSourcePage.getRangeElement(offset, true);
if (range instanceof IDocumentTextNode)
return checkTranslatedValue((IDocumentTextNode) range);
if (!(range instanceof IPluginObject))
return null;
ISchema schema = getExtensionSchema((IPluginObject) range);
if (schema != null) {
ISchemaObject sObj = getSchemaObject(schema, (IPluginObject) range);
if (sObj == null) {
return null;
} else if (range instanceof IPluginAttribute && sObj instanceof ISchemaElement) {
IDocumentAttributeNode da = (IDocumentAttributeNode) range;
if (da.getNameOffset() <= offset && offset <= da.getNameOffset() + da.getNameLength() - 1)
// inside name
return getAttributeText((IPluginAttribute) range, (ISchemaElement) sObj);
else if (da.getValueOffset() <= offset && offset <= da.getValueOffset() + da.getValueLength() - 1)
// inside value
return getAttributeValueText((IPluginAttribute) range, (ISchemaElement) sObj);
} else if (range instanceof IPluginElement) {
IDocumentElementNode dn = (IDocumentElementNode) range;
int dnOff = dn.getOffset();
int dnLen = dn.getLength();
String dnName = dn.getXMLTagName();
if (dnOff + 1 <= offset && offset <= dnOff + dnName.length())
// inside opening tag
return getElementText((ISchemaElement) sObj);
try {
String nt = () - dnName.length() - 1 <= offset && offset <= nt.length() - 2)
// inside closing tag
return getEle
```
<Overlap Ratio: 0.8938244853737811>

---

--- 267 --
Question ID: 897fdb49750e90c9a13f17c981ee07272d6899b3
Original Code:
```
public abstract class TemplateMatchingAlg extends SentenceAlgorithm {

    // separates the template from the rest of the algorithm in its init string.
    private static String TEMPLATE_DELINEATOR = "\n=\n";

    private FeatureTemplate template;

    private String signature;

    protected FeatureTemplate getTemplate() {
        return template;
    }

    protected void setTemplate(FeatureTemplate t) {
        template = t;
    }

    /**
     * Tests if ConstituentNode is a superset of template
     *
     * @param node
     * @return map of matching nodes
     */
    protected Map<String, FeatureNode> canApplyTo(FeatureNode node) {
        return template.match(node);
    }

    protected String getSignature() {
        return signature;
    }

    public int init(String str) {
        if (!Character.isLetter(str.charAt(0)))
            throw new RuntimeException("TemplateMatchingAlg string must start with a letter.\n" + str);
        // get signature
        int sigEnd = str.indexOf("\n");
        signature = str.substring(0, sigEnd);
        // get template
        int templateEnd = str.indexOf(TEMPLATE_DELINEATOR);
        if (templateEnd < 0)
            throw new RuntimeException("TemplateMAtchingAlg must have:" + TEMPLATE_DELINEATOR + "separating the template from the actions.\n" + str);
        setTemplate(new FeatureTemplate(str.substring(sigEnd + 1, templateEnd)));
        return templateEnd + TEMPLATE_DELINEATOR.length();
    }

    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append(getSignature()).append("\n").append(getTemplate()).append(TEMPLATE_DELINEATOR);
        return sb.toString();
    }
}

```


Overlapping Code:
```
blic abstract class TemplateMatchingAlg extends SentenceAlgorithm {
// separates the template from the rest of the algorithm in its init string.
private static String TEMPLATE_DELINEATOR = "\n=\n";
private FeatureTemplate template;
private String sigmplate getTemplate() {
return template;
}
protected void setTemplate(FeatnstituentNode is a superset of template
*
* @param node
* @return map of matching nodes
*/
protected String getSignature() {
return signature;
}
public inharAt(0)))
throw new RuntimeException("TemplateMatchingAlg string must start with a letter.\n" + str);
// get signature
int sigEnd = str.indexOf("\n");
signature = str.substring(0, sigEnd);
// get template
int templateEnd = str.indexOf(TEMPLATE_DELINEATOR);
if (templateEnd < 0)
throw new RuntimeException("TemplateMAtchingAlg must have:" + TEMPLATE_ions.\n" + str);
setTemplate(new FeatureTemplate(str.substring(sigEnd + 1, templateEnd)));
return templateEnd + TEMPLATE_DELINEATOR.length();
}
public String toString() {
StringBuffer sb = new StringBuffer();
sb.append(getSignature()).append("\n").append(getTemplate()).append(TEMPLATE_DELINEATOR);
r
```
<Overlap Ratio: 0.7897687456201822>

---

--- 268 --
Question ID: 770ba336660ddb6d1684c88a6ffd4027a484b65d
Original Code:
```
@Deprecated
@Plugin(type = ConsoleArgument.class)
public class RunArgument extends AbstractConsoleArgument {

    @Parameter
    private CommandService commandService;

    @Parameter
    private LogService log;

    public RunArgument() {
        super(2, "--class");
    }

    @Override
    public void handle(final LinkedList<String> args) {
        if (!supports(args))
            return;
        log.warn("The --class flag is deprecated, and will\n" + "be removed in a future release. Use --run instead.");
        // --class
        args.removeFirst();
        final String commandToRun = args.removeFirst();
        final String paramString = ConsoleUtils.hasParam(args) ? args.removeFirst() : "";
        run(commandToRun, paramString);
    }

    @Override
    public boolean supports(final LinkedList<String> args) {
        if (!super.supports(args))
            return false;
        return getInfo(args.get(1)) != null;
    }

    /**
     * Implements the {@code --run} command line argument.
     */
    private void run(final String commandToRun, final String optionString) {
        // get the command info
        final CommandInfo info = getInfo(commandToRun);
        // couldn't find anything to run
        if (info == null)
            return;
        // TODO: parse the optionString a la ImageJ1
        final Map<String, Object> inputMap = ConsoleUtils.parseParameterString(optionString, info, log);
        try {
            commandService.run(info, true, inputMap).get();
        } catch (final Exception exc) {
            log.error(exc);
        }
    }

    /**
     * Try to convert the given string to a {@link CommandInfo}
     */
    private CommandInfo getInfo(final String commandToRun) {
        CommandInfo info = commandService.getCommand(commandToRun);
        if (info == null) {
            // command was not a class name; search for command by title instead
            final String label = commandToRun.replace('_', ' ');
            for (final CommandInfo ci : commandService.getCommands()) {
                if (label.equals(ci.getTitle())) {
                    info = ci;
                    break;
                }
            }
        }
        return info;
    }
}

```


Overlapping Code:
```
eprecated
@Plugin(type = ConsoleArgument.class)
public class RunArgument extends AbstractConsoleArgument {
@Parameter
private CommandService commandService;
@Parameter
private LogService log;
public
}
@Override
public void handle(final LinkedList<String> args) {
if (!supports(args))
return;
log.warn("The --c removed in a future release. Use --run instead.") = args.removeFirst();
final String paramString = ConsoleUtils.hasParam(args) ? args.removeFirst() :
@Override
public boolean supports(final LinkedList<String> args) {
if (!super.supports(args))
return false;
return getInfo(args.get(1)) !=void run(final String commandToRun, final String optionString) {
// get the command info
final CommandInfo info = getInfo(commandToRun);
// couldn't find anything to run
if (info == null)
return;
// TODO: parse the optionString a la ImageJ1
final Map<String, Object> inputMap = ConsoleUtils.parseParameterString(optionString, info, log);
try {
commandService.run(info, true, inputMap).get();
} catch (final Exception exc) {
log.error(exc);
}
}
/**
* Try to convert the given string to a {@link CommandInfo}
*/
private CommandInfo getInfo(final String commandToRun) {
CommandInfo info = commandService.getCommand(commandToRun);
if (info == null) {
// command was not a class name; search for command by title instead
final String label = commandToRun.replace('_', ' ');
for (final CommandInfo ci : commandService.getCommands()) {
if (label.equals(ci.getTitle())) {
info = ci;
break;
}
}
}
return info;
```
<Overlap Ratio: 0.852589641434263>

---

--- 269 --
Question ID: f162c0c0620935df0e24658be449595dcc99b9e7
Original Code:
```
@RunWith(SpringRunner.class)
// ?????
@SpringBootTest(classes = { ShiroAdminApplication.class })
public class MonsterlanApplicationTests {

    @Autowired
    DataSourceProperties dataSourceProperties;

    @Autowired
    ApplicationContext applicationContext;

    @Test
    public void contextLoads() {
        // ????????
        DataSource dataSource = applicationContext.getBean(DataSource.class);
        //System.out.println(data/Source.getClass().getName());
        System.out.println(dataSourceProperties.getUrl());
    }
}

```


Overlapping Code:
```
s MonsterlanApplicationTests {
@Autowired
DataSourceProperties dataSourceProperties;
@Autowired
ApplicationContext applicationContext;
@Test
public void contextLoads() {DataSource dataSource = applicationContext.getBean(DataSource.class);
/System.out.println(data/Source.getClass().getName());
System.out.println(dataSourceProperties.getUr
```
<Overlap Ratio: 0.7212765957446808>

---

--- 270 --
Question ID: 39f6b8b791c2a8605663251577fe1f85e00a7a2a
Original Code:
```
public class ExprTimeRemainingUntilBorderStabilize extends SimpleExpression<Timespan> {

    private Expression<World> worldExpression;

    @Override
    public Class<? extends Timespan> getReturnType() {
        return Timespan.class;
    }

    @Override
    public boolean isSingle() {
        return true;
    }

    @Override
    public boolean init(Expression<?>[] expr, int matchedPattern, Kleenean arg2, ParseResult arg3) {
        worldExpression = (Expression<World>) expr[0];
        return true;
    }

    @Override
    public String toString(Event event, boolean arg1) {
        return "remaining time until border stabilize in " + worldExpression;
    }

    @Override
    protected Timespan[] get(Event event) {
        World world = worldExpression.getSingle(event);
        if (world.getWorldBorder() instanceof WorldBorderImpl) {
            WorldBorderImpl border = (WorldBorderImpl) world.getWorldBorder();
            Double timeInSeconds = border.remainingTimeInSeconds();
            Timespan result = new Timespan((long) (timeInSeconds * 1000));
            return new Timespan[] { result };
        }
        return new Timespan[0];
    }
}

```


Overlapping Code:
```
 Expression<World> worldExpression;
@Override
public Class<? extends Timespan> getReturnType() {
return Timespan.class;
}
@Override
public boolean isSingle() {
return true;
}
@Override
public boolean init(Expression<?>[] expr, int matchedPattern, Kleenean arg2, ParseResult arg3) {
worldExpression = (Expression<World>) expr[0];
return true;
}
@Override
public String toString(Event event, boolean arg1) {
return "remaining time until border stabilize in " + worldExpression;
}
@Override
protected Timespan[] get(Event event) {
World world = worldExpression.getSingle(event);
if (world.getWorldBorder() instanceof WorldBorderImpl) {
WorldBorderImpl border = (WorldBorderImpl) world.getWorldBorder();
Double timeInSeconds = border.remainingTimeInSeconds();
Timespan result = new Timespan((long) (timeI
```
<Overlap Ratio: 0.8188331627430911>

---

--- 271 --
Question ID: 004f0b95f9d31afac73fdba3b9f2530353bc2072
Original Code:
```
public class MessagesManager {

    private Configuration freemarkerCfg = null;

    @Inject
    private ServletContext context;

    @Inject
    private AssetsManager assetsManager;

    @Inject
    private SherlockConfig config;

    @PostConstruct
    public void init() {
        WebappTemplateLoader templateLoader = new WebappTemplateLoader(context, "WEB-INF/messages/");
        freemarkerCfg = new Configuration(Configuration.VERSION_2_3_26);
        freemarkerCfg.setTemplateLoader(templateLoader);
        freemarkerCfg.setDefaultEncoding("UTF-8");
        freemarkerCfg.setLocale(Locale.US);
        freemarkerCfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
    }

    public String message(String id) throws IOException, MessageException {
        return message(id, ImmutableMap.of());
    }

    public String message(String id, Map<String, Object> context) throws IOException, MessageException {
        if (!context.containsKey("random")) {
            ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();
            builder.putAll(context);
            builder.put("tool", new MessagesTool(assetsManager, config));
            context = builder.build();
        }
        Template template = freemarkerCfg.getTemplate(id + ".ftl");
        StringWriter output = new StringWriter();
        try {
            template.process(context, output);
        } catch (TemplateException e) {
            throw new MessageException("Freemarker error", e);
        }
        return output.toString();
    }
}

```


Overlapping Code:
```
ss MessagesManager {
private Configuration freemarkerCfg = null;
@Inject
private ServletContext context;
@Inject
private AssetsManager assetsManager;
@Inject
private SherlockConfig config;
@PostConstruct
public void init() {
WebappTemplateLoader templateLoader = new WebappTemplateLoader(context, "WEB-INF/messages/");
freemarkerCfg = new Configuration(Configuration.VERSION_2_3_26);
freemarkerCfg.setTemplateLoader(templateLoader);
freemarkerCfg.setDefaultEncoding("UTF-8");
freemarkerCfg.setLocale(Locale.US);
freemarkerCfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
}
public String message(String id) throws IOException, MessageException {
return message(id, ImmutableMap.of());
}
public String message(String id, Map<String, Object> context) throws IOException, MeeException {
if (!context.containsKey("random")) {
ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();
builder.putAll(context);
builder.put("tool", new MessagesTool(assetsManager, config));
context = builder.build();
}
Template template = freemarkerCfg.getTemplate(id + ".ftl");
StringWriter output = new StringWriter();
try {
template.process(context, output);
} catch (TemplateException e) {
throw new MessageException("Freemarke
```
<Overlap Ratio: 0.9547892720306513>

---

--- 272 --
Question ID: a24f84caa66e1f813870bcc8b107c4c0772b2c17
Original Code:
```
public class ComplexStringExampleActivity extends AppCompatActivity {

    ListenerRelay<ScrambleAdapter<?>, RecyclerView.ViewHolder> mListenerRelay = new ListenerRelay<ScrambleAdapter<?>, RecyclerView.ViewHolder>() {

        @Override
        public void onClick(@NonNull RecyclerView recyclerView, @NonNull ScrambleAdapter<?> adapter, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull View view) {
            if (recyclerView.getId() == R.id.recycler) {
                String item = (String) adapter.getItemAt(viewHolder.getAdapterPosition());
                switch(view.getId()) {
                    case R.id.text:
                        {
                            mSnackbarLogic.make(view, item + " is clicked.(Text)", Snackbar.LENGTH_SHORT).show();
                            break;
                        }
                    case R.id.button_a:
                        {
                            mSnackbarLogic.make(view, item + " is clicked.(A)", Snackbar.LENGTH_SHORT).show();
                            break;
                        }
                    case R.id.button_b:
                        {
                            mSnackbarLogic.make(view, item + " is clicked.(B)", Snackbar.LENGTH_SHORT).show();
                            break;
                        }
                }
            }
        }

        @Override
        public boolean onLongClick(@NonNull RecyclerView recyclerView, @NonNull ScrambleAdapter<?> adapter, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull View view) {
            if (recyclerView.getId() == R.id.recycler) {
                String item = (String) adapter.getItemAt(viewHolder.getAdapterPosition());
                switch(view.getId()) {
                    case R.id.text:
                        {
                            mSnackbarLogic.make(view, item + " is long clicked.(Text)", Snackbar.LENGTH_SHORT).show();
                            break;
                        }
                    case R.id.button_a:
                        {
                            mSnackbarLogic.make(view, item + " is long clicked.(A)", Snackbar.LENGTH_SHORT).show();
                            break;
                        }
                    case R.id.button_b:
                        {
                            mSnackbarLogic.make(view, item + " is long clicked.(B)", Snackbar.LENGTH_SHORT).show();
                            break;
                        }
                }
                return true;
            }
            return false;
        }
    };

    RecyclerView mRecyclerView;

    SnackbarLogic mSnackbarLogic = new SnackbarLogic();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_simple_string_example);
        // find views
        mRecyclerView = (RecyclerView) findViewById(R.id.recycler);
        {
            // set adapter
            List<String> items = new ArrayList<>();
            int i = 0;
            while (i < 100) try {
                items.add("item " + i);
            } finally {
                i++;
            }
            ComplexStringAdapter adapter = new ComplexStringAdapter(this, items, mListenerRelay);
            mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));
            mRecyclerView.setAdapter(adapter);
        }
    }
}

```


Overlapping Code:
```
c class ComplexStringExampleActivity extends AppCompatActivity {
ListenerRelay<ScrambleAdapter<?>, RecyclerView.ViewHolder> mListenerRelay = new ListenerRelay<ScrambleAdapter<?>, RecyclerView.ViewHolder>() {
@Override
public void onClick(@NonNull RecyclerView recyclerView, @NonNull ScrambleAdapter<?> adapter, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull View view) {
if (recyclerView.getId() == R.id.recycler) {
String item = (String) adapter.getItemAt(viewHolder.getAdapterPosition());
swogic.make(view, item + " is clicked.(Text)", Snackbar.LENGTH_SHORT).show();
break;
}
case R.id.buttoed.(A)", Snackbar.LENGTH_SHORT).show();
break;
}
case R.id.buttom + " is clicked.(B)", Snackbar.LENGTH_SHORT).show();
break;
}
}
}
}
@Override
public boolean onLongClick(@NonNull RecyclerView recyclerView, @NonNull ScrambleAdapter<?> adapter, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull View view) {
if (recyclerView.getId() == R.id.recycler) {
String item = (String) adapter.getItemAt(viewHolder.getAdapterPosition());
swSnackbarLogic.make(view, item + " is long clicked.(Text)", Snackbar.LENGTH_SHORT).show();
break;
}
case R.id.buttoSnackbarLogic.make(view, item + " is long clicked.(A)", Snackbar.LENGTH_SHORT).show();
break;
}
case R.id.buttoSnackbarLogic.make(view, item + " is long clicked.(B)", Snackbar.LENGTH_SHORT).show();
break;
}
}
return 
```
<Overlap Ratio: 0.8730769230769231>

---

--- 273 --
Question ID: ce0aae2d035d5e83776bce459265e8dafe8ff912
Original Code:
```
public final class MethodHandlerScanner implements EventHandlerScanner {

    private final AnnotatedListenerPredicate annotatedListenerPredicate = new AnnotatedListenerPredicate();

    private final EventFilterScanner<Method> filterScanner = new MethodFilterScanner();

    @Override
    public Map<Class<?>, Set<EventHandler>> locate(final Object listenerContainer) {
        final Map<Class<?>, Set<EventHandler>> eventHandlers = new HashMap<>();
        Stream.of(listenerContainer.getClass().getDeclaredMethods()).filter(annotatedListenerPredicate).forEach(method -> eventHandlers.computeIfAbsent(method.getParameterTypes()[0], obj -> new TreeSet<>()).add(new MethodEventHandler(listenerContainer, method, filterScanner.scan(method))));
        return eventHandlers;
    }
}

```


Overlapping Code:
```
 class MethodHandlerScanner implements EventHandlerScanner {
private final AnnotatedListenerPredicate annotatedListprivate final EventFilterScanner<Method> filterScanner = new MethodFilterScanner();
@Override
public Map<Class<?>, Set<EventHandler>> locate(final Object listenerContainer) {
final Map<Class<?>, Set<EventHandler>> eventHandlers = new HashMap<>();
Stream.of(listenerContainer.getClass().getDeclaredMetntHandlers.computeIfAbsent(method.getParameterTypedd(new MethodEventHandler(listenerContainer, metho
```
<Overlap Ratio: 0.7025920873124147>

---

--- 274 --
Question ID: 538720e56e824c6567f939adc18ccbf7ee54aa80
Original Code:
```
public class LevelSelectFragment extends Fragment implements View.OnClickListener {

    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_level_select, container, false);
        view.findViewById(R.id.button_one).setOnClickListener(this);
        view.findViewById(R.id.button_two).setOnClickListener(this);
        view.findViewById(R.id.button_three).setOnClickListener(this);
        view.findViewById(R.id.button_four).setOnClickListener(this);
        view.findViewById(R.id.button_five).setOnClickListener(this);
        view.findViewById(R.id.button_six).setOnClickListener(this);
        view.findViewById(R.id.button_seven).setOnClickListener(this);
        view.findViewById(R.id.button_eight).setOnClickListener(this);
        view.findViewById(R.id.button_nine).setOnClickListener(this);
        view.findViewById(R.id.button_ten).setOnClickListener(this);
        view.findViewById(R.id.button_eleven).setOnClickListener(this);
        view.findViewById(R.id.button_twelve).setOnClickListener(this);
        view.findViewById(R.id.button_thirteen).setOnClickListener(this);
        view.findViewById(R.id.button_fourteen).setOnClickListener(this);
        view.findViewById(R.id.button_fifteen).setOnClickListener(this);
        return view;
    }

    @Override
    public void onClick(View v) {
        int level = Integer.parseInt(v.getTag().toString());
        int sizeColumns = level + 3;
        int sizeRows = (int) (sizeColumns * 4 / 3);
        System.out.println("v.getTag='" + v.getTag() + "', level = " + level);
        MazeFragment maze = MazeFragment.newInstance(level, sizeRows, sizeColumns);
        FragmentTransaction ft = getFragmentManager().beginTransaction();
        ft.addToBackStack(MazeFragment.class.getSimpleName());
        ft.replace(R.id.fragment_container, maze).commit();
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
    }
}

```


Overlapping Code:
```
tFragment extends Fragment implements View.OnClickListener {
@Nullable
@Override
public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
View view = inflater.inflate(R.layout.fragment_level_select, container, false);
view.findViewById(R.id.button_one).setOnClickListener(this);
view.findViewById(R.id.button_two).setOnClickListener(this);
view.findViewById(R.id.button_three).setOnClickListener(this);
view.findViewById(R.id.button_four).setOnClickListener(this);
view.findViewById(R.id.button_five).setOnClickListener(this);
view.findViewById(R.id.button_six).setOnClickListener(this);
view.findViewById(R.id.button_seven).setOnClickListener(this);
view.findViewById(R.id.button_eight).setOnClickListener(this);
view.findViewById(R.id.button_nine).setOnClickListener(this);
view.findViewById(R.id.button_ten).setOnClickListener(this);
view.findViewById(R.id.button_eleven).setOnClickListener(this);
view.findViewById(R.id.button_twelve).setOnClickListener(this);
view.findViewById(R.id.button_thirteen).setOnClickListener(this);
view.findViewById(R.id.button_fourteen).setOnClickListener(this);
view.findViewById(R.id.button_fifteen).setOnClickListener(this);
return view;
}
@Override
public void onClick(View v) {
int level = Integer.parseInt(v.getTag().toString());
int sizeColumns ', level = " + level);
MazeFragment maze = MazeFragment.newInstance(level, sizeRows, sizeColumns);
FragmentTransaction ft = getFragmentManager().beginTransaction();
ft.addToBackStack(MazeFragment.class.getSimpleName());
ft.replace(R.id.fragment_container, maze).commit();
}
@Override
public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
super.onViewCreated(view, savedInstanceState);
}
}
```
<Overlap Ratio: 0.9328083989501312>

---

--- 275 --
Question ID: dc9e7da59510f1ed559c7ecc60156b3e286bb598
Original Code:
```
public class Auth {

    private final FirebaseAuth mAuth = FirebaseAuth.getInstance();

    private final UsersDatabaseCrud userCrud = new UsersDatabaseCrud();

    private FirebaseUser mFirebaseUser;

    private Activity activity = null;

    /**
     * Constructor Default
     */
    public Auth() {
    }

    /**
     * Constructor
     *
     * @param activity Activity from where it has been called
     */
    public Auth(Activity activity) {
        this.activity = activity;
    }

    /**
     * Check if the current user is logged in or not
     *
     * @return boolean False [not logged in], True [logged in]
     */
    public boolean isLogged() {
        return (mAuth.getCurrentUser() != null);
    }

    /**
     * Return current user logged
     *
     * @return FirebaseUser
     */
    public FirebaseUser getCurrentUser() {
        return mAuth.getCurrentUser();
    }

    /**
     * Try to log in with the email and password passed as parameters
     *
     * @param email    User validated email
     * @param password User's validated password
     */
    public void signInWithEmailAndPassword(String email, String password) {
        mAuth.signInWithEmailAndPassword(email, password).addOnCompleteListener(task -> {
            if (task.isSuccessful()) {
                if (isLogged()) {
                    mFirebaseUser = mAuth.getCurrentUser();
                    userCrud.read(mFirebaseUser.getUid(), user -> {
                        //                        Log.d(App.DEFAULT_TAG, mFirebaseUser.getUid());
                        App.getInstance().setCurrentUser(user);
                        // Update lastAccess field
                        user.setLastAccess(new Date(System.currentTimeMillis()));
                        userCrud.update(user.getUid(), user.parseToMap(), response -> {
                            if (response) {
                                checkRole(App.getInstance().getCurrentUser().getRole());
                            } else {
                                Intent intent = new Intent(App.getContext(), GeneralMainActivity.class);
                                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
                                intent.putExtra("message", "No se ha podido verificar tu identidad correctamente.");
                                App.getContext().startActivity(intent);
                            }
                        });
                    });
                }
            } else {
                App.getInstance().snackMessage(activity.findViewById(R.id.auth_email_activity_container), R.color.black, "Datos de acceso incorrectos.", App.getContext());
            }
        });
    }

    /**
     * Send a password reset email
     *
     * @param email User validated email
     */
    public void sendPasswordResetEmail(String email) {
        mAuth.sendPasswordResetEmail(email).addOnCompleteListener(task -> {
            Intent intent = new Intent(App.getContext(), AuthEmailActivity.class);
            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
            intent.putExtra("message", "S? el email esta registrado recibir?s un correo para restablecer la contrase?a.");
            App.getContext().startActivity(intent);
        });
    }

    /**
     * Disconnect the user
     */
    public void signOut() {
        mAuth.signOut();
        App.getInstance().setCurrentUser(null);
    }

    /**
     * Check the role and redirect to the corresponding activity when logging in
     *
     * @param role Role of the logged in user
     */
    public void checkRole(String role) {
        switch(role) {
            case "root":
            case "administrator":
                {
                    redirectActivity(AdministratorMainActivity.class);
                    break;
                }
            case "technician":
                {
                    redirectActivity(TechnicianMainActivity.class);
                    break;
                }
            default:
                {
                    redirectActivity(GeneralMainActivity.class);
                    break;
                }
        }
    }

    /**
     * Redirect to corresponding activity
     *
     * @param activity Activity where it will be redirected
     */
    public void redirectActivity(Class<?> activity) {
        Intent intent;
        intent = new Intent(App.getContext(), activity);
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
        App.getContext().startActivity(intent);
    }
}

```


Overlapping Code:
```
ate final FirebaseAuth mAuth = FirebaseAuth.getInstance();
private final UsersDatabaseCrud userCrud = new UsersDatabaseCrud();
private FirebaseUser mFirebaseUser;
private Activity activity = null;
/**
* Constructor Default
*/
public Authity Activity from where it has been called
*/
public Auth(Activity activity) {
this.activity = activity;
}
/**
* Check if the current user is logged in or not
*
* @return boolean False [not logged in], True [logged in]
*/
public boolean isLogged() {
return (mAuth.getCurrentUser() != null);
}
/**
* Return current user logged
*
* @return FirebaseUser
*/
public FirebaseUser getCurrentUser() {
return mAuth.getCurrentUser();
}
/**
* Try to log in with the email and password passed as parameters
*
* @param email User validated email
* @param password User's validated password
*/
public void signInWithEmailAndPassword(String email, String password) {
mAuth.signInWithEmailAndPassword(email, password).addOnCompleteListener(task -> {
if (task.isSuccessful()) {
if (isLogged()) {
mFirebaseUser = mAuth.getCurrentUser();
userCrud.read(mFirebaseUser.getUid(), user -> {
// Log.d(App.DEFAULT_TAG, mFirebaseUser.getUid());
App.getInstance().setCurrentUsertAccess(new Date(System.currentTimeMillis()));
userCrud.update(user.getUid(), user.parseToMap(), response -> {
if (response) {
checkRole(App.getInstance().getCurrentUser().getRole());
} else {
Intent intent = new Intent(App.getContext(), GeneralMainActivity.class);
intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
intent.putExtra("message", "No se ha podido verificar tu identidad correctamente.");
App.getContext().s
```
<Overlap Ratio: 0.9201798763350196>

---

--- 276 --
Question ID: 33fbd2d8697786a75b675ce0f67d67aea1d4dc16
Original Code:
```
public class SequenceValueGenerator extends AbstractSequenceValueProducer {

    public static final int DEFAULT_RESERVE_AMOUNT = 100;

    public static final int DEFAULT_INITIAL_VALUE = 1;

    public static final int DEFAULT_INCREMENT = 1;

    private final Repository mRepository;

    private final Storage<StoredSequence> mStorage;

    private final StoredSequence mStoredSequence;

    private final int mIncrement;

    private final int mReserveAmount;

    private boolean mHasReservedValues;

    private long mNextValue;

    /**
     * Construct a new SequenceValueGenerator which might create persistent
     * sequence data if it does not exist. The initial sequence value is one,
     * and the increment is one.
     *
     * @param repo repository to persist sequence data
     * @param name name of sequence
     */
    public SequenceValueGenerator(Repository repo, String name) throws RepositoryException {
        this(repo, name, DEFAULT_INITIAL_VALUE, DEFAULT_INCREMENT);
    }

    /**
     * Construct a new SequenceValueGenerator which might create persistent
     * sequence data if it does not exist.
     *
     * @param repo repository to persist sequence data
     * @param name name of sequence
     * @param initialValue initial sequence value, if sequence needs to be created
     * @param increment amount to increment sequence by
     */
    public SequenceValueGenerator(Repository repo, String name, long initialValue, int increment) throws RepositoryException {
        this(repo, name, initialValue, increment, DEFAULT_RESERVE_AMOUNT);
    }

    /**
     * Construct a new SequenceValueGenerator which might create persistent
     * sequence data if it does not exist.
     *
     * @param repo repository to persist sequence data
     * @param name name of sequence
     * @param initialValue initial sequence value, if sequence needs to be created
     * @param increment amount to increment sequence by
     * @param reserveAmount amount of sequence values to reserve
     */
    public SequenceValueGenerator(Repository repo, String name, long initialValue, int increment, int reserveAmount) throws RepositoryException {
        if (repo == null || name == null || increment < 1 || reserveAmount < 1) {
            throw new IllegalArgumentException();
        }
        mRepository = repo;
        mIncrement = increment;
        mReserveAmount = reserveAmount;
        mStorage = repo.storageFor(StoredSequence.class);
        mStoredSequence = mStorage.prepare();
        mStoredSequence.setName(name);
        Transaction txn = repo.enterTopTransaction(null);
        txn.setForUpdate(true);
        try {
            if (!mStoredSequence.tryLoad()) {
                mStoredSequence.setInitialValue(initialValue);
                // Start as small as possible to allow signed long comparisons to work.
                mStoredSequence.setNextValue(Long.MIN_VALUE);
                // Try to transfer values from a deprecated sequence.
                com.amazon.carbonado.spi.StoredSequence oldSequence;
                try {
                    oldSequence = repo.storageFor(com.amazon.carbonado.spi.StoredSequence.class).prepare();
                    oldSequence.setName(name);
                    if (oldSequence.tryLoad()) {
                        mStoredSequence.setInitialValue(oldSequence.getInitialValue());
                        mStoredSequence.setNextValue(oldSequence.getNextValue());
                    } else {
                        oldSequence = null;
                    }
                } catch (RepositoryException e) {
                    // Okay, perhaps no old sequence.
                    oldSequence = null;
                }
                if (mStoredSequence.tryInsert()) {
                    if (oldSequence != null) {
                        try {
                            // Get rid of deprecated sequence.
                            oldSequence.tryDelete();
                        } catch (RepositoryException e) {
                        }
                    }
                } else {
                    // A race condition likely. Load again.
                    mStoredSequence.load();
                }
            }
            txn.commit();
        } finally {
            txn.exit();
        }
    }

    /**
     * Reset the sequence.
     *
     * @param initialValue first value produced by sequence
     */
    public void reset(int initialValue) throws FetchException, PersistException {
        synchronized (mStoredSequence) {
            Transaction txn = mRepository.enterTopTransaction(null);
            txn.setForUpdate(true);
            try {
                boolean doUpdate = mStoredSequence.tryLoad();
                mStoredSequence.setInitialValue(initialValue);
                // Start as small as possible to allow signed long comparisons to work.
                mStoredSequence.setNextValue(Long.MIN_VALUE);
                if (doUpdate) {
                    mStoredSequence.update();
                } else {
                    mStoredSequence.insert();
                }
                txn.commit();
                mHasReservedValues = false;
            } finally {
                txn.exit();
            }
        }
    }

    /**
     * Returns the next value from the sequence, which may wrap negative if all
     * positive values are exhausted. When sequence wraps back to initial
     * value, the sequence is fully exhausted, and an exception is thrown to
     * indicate this.
     *
     * <p>Note: this method throws PersistException even for fetch failures
     * since this method is called by insert operations. Insert operations can
     * only throw a PersistException.
     *
     * @throws PersistException for fetch/persist failure or if sequence is exhausted.
     */
    public long nextLongValue() throws PersistException {
        try {
            synchronized (mStoredSequence) {
                return nextUnadjustedValue() + Long.MIN_VALUE + mStoredSequence.getInitialValue();
            }
        } catch (FetchException e) {
            throw e.toPersistException();
        }
    }

    /**
     * Returns the next value from the sequence, which may wrap negative if all
     * positive values are exhausted. When sequence wraps back to initial
     * value, the sequence is fully exhausted, and an exception is thrown to
     * indicate this.
     *
     * <p>Note: this method throws PersistException even for fetch failures
     * since this method is called by insert operations. Insert operations can
     * only throw a PersistException.
     *
     * @throws PersistException for fetch/persist failure or if sequence is
     * exhausted for int values.
     */
    @Override
    public int nextIntValue() throws PersistException {
        try {
            synchronized (mStoredSequence) {
                long initial = mStoredSequence.getInitialValue();
                if (initial >= 0x100000000L) {
                    throw new PersistException("Sequence initial value too large to support 32-bit ints: " + mStoredSequence.getName() + ", initial: " + initial);
                }
                long next = nextUnadjustedValue();
                if (next >= Long.MIN_VALUE + 0x100000000L) {
                    // has been lost. This seems fairly benign.
                    throw new PersistException("Sequence exhausted for 32-bit ints: " + mStoredSequence.getName() + ", next: " + (next + Long.MIN_VALUE + initial));
                }
                return (int) (next + Long.MIN_VALUE + initial);
            }
        } catch (FetchException e) {
            throw e.toPersistException();
        }
    }

    /**
     * Allow any unused reserved values to be returned for re-use. If the
     * repository is shared by other processes, then reserved values might not
     * be returnable.
     *
     * <p>This method should be called during the shutdown process of a
     * repository, although calling it does not invalidate this
     * SequenceValueGenerator. If getNextValue is called again, it will reserve
     * values again.
     *
     * @return true if reserved values were returned
     */
    public boolean returnReservedValues() throws FetchException, PersistException {
        synchronized (mStoredSequence) {
            if (mHasReservedValues) {
                Transaction txn = mRepository.enterTopTransaction(null);
                txn.setForUpdate(true);
                try {
                    // one. If same, then reserved values can be returned.
                    StoredSequence current = mStorage.prepare();
                    current.setName(mStoredSequence.getName());
                    if (current.tryLoad() && current.equals(mStoredSequence)) {
                        mStoredSequence.setNextValue(mNextValue + mIncrement);
                        mStoredSequence.update();
                        txn.commit();
                        mHasReservedValues = false;
                        return true;
                    }
                } finally {
                    txn.exit();
                }
            }
        }
        return false;
    }

    // Assumes caller has synchronized on mStoredSequence
    private long nextUnadjustedValue() throws FetchException, PersistException {
        if (mHasReservedValues) {
            long next = mNextValue + mIncrement;
            mNextValue = next;
            if (next < mStoredSequence.getNextValue()) {
                return next;
            }
            mHasReservedValues = false;
        }
        Transaction txn = mRepository.enterTopTransaction(null);
        txn.setForUpdate(true);
        try {
            // Assume that StoredSequence is stale, so reload.
            mStoredSequence.load();
            long next = mStoredSequence.getNextValue();
            long nextStored = next + mReserveAmount * mIncrement;
            if (next >= 0 && nextStored < 0) {
                // Wrapped around. There might be just a few values left.
                long avail = (Long.MAX_VALUE - next) / mIncrement;
                if (avail > 0) {
                    nextStored = next + avail * mIncrement;
                } else {
                    // insert operations, and inserts can only throw PersistExceptions.
                    throw new PersistException("Sequence exhausted: " + mStoredSequence.getName());
                }
            }
            mStoredSequence.setNextValue(nextStored);
            mStoredSequence.update();
            txn.commit();
            mNextValue = next;
            mHasReservedValues = true;
            return next;
        } finally {
            txn.exit();
        }
    }
}

```


Overlapping Code:
```
bstractSequenceValueProducer {
public static final int DEFAULT_RESERVE_AMOUNT = 100;
public static final int DEFAULT_INITIAL_VALUE = 1;
public static final int DEFAULT_INCREMENT = 1;
private final Repository mRepository;
private final Storage<StoredSequence> mStorage;
private final StoredSequence mStoredSequence;
private final int mIncrement;
private final int mReserveAmount;
private boolean mHasReservedValues;
private long mNextValue;
/**
* Construct a new SequenceValueGenerator which might create persistent
* sequence data if it does not exist. The initial sequence value is one,
* and the increment is one.
*
* @param repo repository to persist sequence data
* @param name name of sequence
*/
public SequenceValueGenerator(Repository repo, S, name, DEFAULT_INITIAL_VALUE, DEFAULT_INCREMENT);
}
/**
* Construct a new SequenceValueGenerator which might create persistent
* sequence data if it does not exist.
*
* @param repo repository to persist sequence data
* @param name name of sequence
* @param initialValue initial sequence value, if sequence needs to be created
* @param increment amount to increment sequence by
*/
public SequenceValueGenerator(Repository repo, String name, long initULT_RESERVE_AMOUNT);
}
/**
* Construct a new SequenceValueGenerator which might create persistent
* sequence data if it does not exist.
*
* @param repo repository to persist sequence data
* @param name name of sequence
* @param initialValue initial sequence value, if sequence needs to be created
* @param increment amount to increment sequence by
* @param reserveAmount amount of sequence values to reserve
*/
public SequenceValueGenerator(Repository repo, String name, long init 1 || reserveAmount < 1) {
throw new IllegalArgumentException();
}
mRepository = repo;
mIncrement = increment;
mReserveAmount = reserveAmount;
mStorag
```
<Overlap Ratio: 0.8495821727019499>

---

--- 277 --
Question ID: 3895af397ca10b213eeedd58eb68713c339171f4
Original Code:
```
public class BinaryTree {

    private String symbol;

    private int start;

    private int end;

    private BinaryTree leftChild;

    private BinaryTree rightChild;

    private boolean isLexical;

    private BinaryTree parent;

    public BinaryTree(String symbol, int start, int end, BinaryTree leftChildNode, BinaryTree rightChildNode, boolean isLexical) {
        this.symbol = symbol;
        this.start = start;
        this.end = end;
        this.leftChild = leftChildNode;
        this.rightChild = rightChildNode;
        this.isLexical = isLexical;
        this.parent = null;
        if (leftChild != null) {
            leftChild.parent = this;
        }
        if (rightChild != null) {
            rightChild.parent = this;
        }
    }

    private static String canonicalizeTreeString(String newTreeStr) {
        return newTreeStr.trim().replaceAll("\\s+\\)", ")").replaceAll("\\s+", " ");
    }

    public String getAsOneLineString() {
        // TODO: speedup.
        return canonicalizeTreeString(getAsPennTreebankString());
    }

    /**
     * Gets a string representation of this parse that looks like the typical
     * Penn Treebank style parse.
     *
     * Example:
     *  ((ROOT (S (NP (NN time))
     *           (VP (VBZ flies)
     *               (PP (IN like)
     *                   (NP (DT an)
     *                       (NN arrow)))))))
     *
     * @return A string representing this parse.
     */
    public String getAsPennTreebankString() {
        StringBuilder sb = new StringBuilder();
        sb.append("(");
        getAsPennTreebankString(1, 1, sb);
        sb.append(")");
        return sb.toString();
    }

    private void getAsPennTreebankString(int indent, int numOnLine, StringBuilder sb) {
        int numSpaces = indent - numOnLine;
        int i = 0;
        while (i < numSpaces) try {
            sb.append(" ");
        } finally {
            i++;
        }
        if (isLexical) {
            sb.append(getSymbol());
        } else {
            sb.append("(");
            sb.append(getSymbol());
            // If this is a constant instead, then we have each depth in one column.
            int numNewChars = 1 + getSymbol().length();
            if (leftChild != null) {
                //sb.append("\n");
                leftChild.getAsPennTreebankString(indent + numNewChars + 1, indent + numNewChars, sb);
            }
            if (rightChild != null) {
                sb.append("\n");
                rightChild.getAsPennTreebankString(indent + numNewChars + 1, 0, sb);
            }
            sb.append(")");
        }
    }

    public void preOrderTraversal(FnO1ToVoid<BinaryTree> function) {
        // Visit this node.
        function.call(this);
        // Pre-order traversal of each child.
        if (leftChild != null) {
            leftChild.preOrderTraversal(function);
        }
        if (rightChild != null) {
            rightChild.preOrderTraversal(function);
        }
    }

    public void inOrderTraversal(FnO1ToVoid<BinaryTree> function) {
        // In-order traversal of left child.
        if (leftChild != null) {
            leftChild.inOrderTraversal(function);
        }
        // Visit this node.
        function.call(this);
        // In-order traversal of right child.
        if (rightChild != null) {
            rightChild.inOrderTraversal(function);
        }
    }

    public void postOrderTraversal(FnO1ToVoid<BinaryTree> function) {
        // Post-order traversal of each child.
        if (leftChild != null) {
            leftChild.postOrderTraversal(function);
        }
        if (rightChild != null) {
            rightChild.postOrderTraversal(function);
        }
        // Visit this node.
        function.call(this);
    }

    public int getStart() {
        return start;
    }

    public int getEnd() {
        return end;
    }

    public boolean isLeaf() {
        return leftChild == null && rightChild == null;
    }

    public boolean isLexical() {
        return isLexical;
    }

    public BinaryTree getLeftChild() {
        return leftChild;
    }

    public BinaryTree getRightChild() {
        return rightChild;
    }

    public String getSymbol() {
        return symbol;
    }

    public void setSymbol(String symbol) {
        this.symbol = symbol;
    }

    public BinaryTree getParent() {
        return parent;
    }

    /**
     * Updates all the start end fields, treating the current node as the root.
     */
    public void updateStartEnd() {
        ArrayList<BinaryTree> leaves = getLeaves();
        int i = 0;
        while (i < leaves.size()) try {
            BinaryTree leaf = leaves.get(i);
            leaf.start = i;
            leaf.end = i + 1;
        } finally {
            i++;
        }
        postOrderTraversal(new UpdateStartEnd());
    }

    /**
     * Gets the leaves of this tree in left-to-right order.
     */
    public ArrayList<BinaryTree> getLeaves() {
        LeafCollector leafCollector = new LeafCollector();
        postOrderTraversal(leafCollector);
        return leafCollector.leaves;
    }

    /**
     * Gets the lexical leaves of this tree in left-to-right order.
     */
    public ArrayList<BinaryTree> getLexicalLeaves() {
        LexicalLeafCollector leafCollector = new LexicalLeafCollector();
        postOrderTraversal(leafCollector);
        return leafCollector.leaves;
    }

    /**
     * Gets the leaf containing the specified token index.
     */
    public BinaryTree getLeafAt(int idx) {
        BinaryTree leaf = null;
        for (BinaryTree l : this.getLeaves()) {
            if (l.start <= idx && idx < l.end) {
                leaf = l;
            }
        }
        return leaf;
    }

    /**
     * Gets the lexical item ids comprising the sentence.
     */
    public int[] getSentenceIds(IntObjectBimap<String> lexAlphabet) {
        ArrayList<BinaryTree> leaves = getLexicalLeaves();
        int[] sent = new int[leaves.size()];
        int i = 0;
        while (i < sent.length) try {
            sent[i] = lexAlphabet.lookupIndex(leaves.get(i).symbol);
        } finally {
            i++;
        }
        return sent;
    }

    public Sentence getSentence(IntObjectBimap<String> lexAlphabet) {
        ArrayList<BinaryTree> leaves = getLexicalLeaves();
        ArrayList<String> labels = new ArrayList<String>(leaves.size());
        int i = 0;
        while (i < leaves.size()) try {
            labels.add(leaves.get(i).symbol);
        } finally {
            i++;
        }
        return new Sentence(lexAlphabet, labels);
    }

    public List<String> getWords() {
        ArrayList<BinaryTree> leaves = getLexicalLeaves();
        ArrayList<String> words = new ArrayList<String>(leaves.size());
        int i = 0;
        while (i < leaves.size()) try {
            words.add(leaves.get(i).symbol);
        } finally {
            i++;
        }
        return words;
    }

    private class LeafCollector implements FnO1ToVoid<BinaryTree> {

        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();

        @Override
        public void call(BinaryTree node) {
            if (node.isLeaf()) {
                leaves.add(node);
            }
        }
    }

    private class LexicalLeafCollector implements FnO1ToVoid<BinaryTree> {

        public ArrayList<BinaryTree> leaves = new ArrayList<BinaryTree>();

        @Override
        public void call(BinaryTree node) {
            if (node.isLeaf() && node.isLexical()) {
                leaves.add(node);
            }
        }
    }

    private class UpdateStartEnd implements FnO1ToVoid<BinaryTree> {

        @Override
        public void call(BinaryTree node) {
            if (!node.isLeaf()) {
                node.start = node.leftChild.start;
                if (node.rightChild == null) {
                    node.end = node.leftChild.end;
                } else {
                    node.end = node.rightChild.end;
                }
            }
        }
    }

    /**
     * Intern all the strings.
     */
    public void intern() {
        symbol = symbol.intern();
        if (leftChild != null) {
            leftChild.intern();
        }
        if (rightChild != null) {
            rightChild.intern();
        }
    }

    public NaryTree collapseToNary() {
        ArrayList<NaryTree> children = null;
        if (!isLeaf()) {
            assert (leftChild != null);
            LinkedList<NaryTree> queue = new LinkedList<NaryTree>();
            addToQueue(queue, leftChild);
            addToQueue(queue, rightChild);
            children = new ArrayList<NaryTree>(queue);
        }
        return new NaryTree(symbol, start, end, children, isLexical);
    }

    private static void addToQueue(LinkedList<NaryTree> queue, BinaryTree child) {
        if (child == null) {
            return;
        }
        String symbolStr = child.getSymbol();
        if (GrammarConstants.isBinarized(symbolStr)) {
            addToQueue(queue, child.leftChild);
            addToQueue(queue, child.rightChild);
        } else {
            queue.add(child.collapseToNary());
        }
    }

    @Override
    public String toString() {
        return "BinaryTreeNode [symbol=" + getSymbol() + "_{" + start + ", " + end + "}, leftChildNode=" + leftChild + ", rightChildNode=" + rightChild + "]";
    }
}

```


Overlapping Code:
```
inaryTree {
private String symbol;
private int start;
private int end;
private BinaryTree leftChild;
private BinaryTree rightChild;
private boolean isTree(String symbol, int start, int end, BinaryTree isLexical) {
this.symbol = symbol;
this.start = start;
this.end = end;
this.leftChild = leftChildNode;
this.rightChild = rightChildNode;
this.isLexical = isLexical;
this.parent = null;
if (leftChild != null) {
leftChild.parent = this;
}
if (rightChild != null) {
rightChild.parent = thi static String canonicalizeTreeString(String newTreeStr) {
return newTreeStr.trim().replaceAll("\\s+\\)", ")").replaceAll("\\s+", " ");
}LineString() {
// TODO: speedup.
return canonicalizeTreeString(getAsPennTreebankString());
}
/**
* Gets a string representation of this parse that looks like the typical
* Penn Treebank style parmple:
* ((ROOT (S (NP (NN time))
* (VP (VBZ flies)
* (PP (IN like)
* (NP (DT an)
* (NN arrow)))))))
*
* @return A string representing this parse.
*/
public String getAsPennTreebankString() {
StringBuilder sb = new StringBuilder();
sb.append("(");
getAsPennTreebankString(1, 1, sb);
sb.append(")");
return sb.toString();
}
private void getAsPennTreebankString(int indent, int numOnLine, StringBuilder sb) {
int numSpaces = indent - numOnLinel) {
sb.append(getSymbol());
} else {
sb.append("(");
sb.append(getSymbol());
// If this is a constant instead, then we have each depth in one column.
int numNewChars = 1 + getSymbol().length();
if (leftChild != null) {
//sb.append("\n");
leftChild.getAsPennTreebankString(imNewChars, sb);
}
if (rightChild != null) {
sb.app
```
<Overlap Ratio: 0.8429179978700746>

---

--- 278 --
Question ID: 3377317aa98200f51a48ce521cfc82e23fc73437
Original Code:
```
public class DeleteObject extends CliCommand<DefaultResult> {

    private final static ImmutableList<Option> requiredArgs = ImmutableList.of(BUCKET, OBJECT_NAME);

    private final static ImmutableList<Option> optionalArgs = ImmutableList.of(VERSION_ID, ALL_VERSIONS);

    private String bucketName;

    private String objectName;

    private String versionId;

    private boolean allVersions;

    public DeleteObject() {
    }

    @Override
    public CliCommand init(final Arguments args) throws Exception {
        processCommandOptions(requiredArgs, optionalArgs, args);
        this.bucketName = args.getBucket();
        this.objectName = args.getObjectName();
        this.versionId = args.getVersionId();
        this.allVersions = args.isAllVersions();
        return this;
    }

    @Override
    public DefaultResult call() throws Exception {
        if (allVersions) {
            final GetObjectsDetailsSpectraS3Request getObjectsDetailsSpectraS3Request = new GetObjectsDetailsSpectraS3Request().withName(objectName).withBucketId(bucketName);
            final GetObjectsDetailsSpectraS3Response spectraS3Response = getClient().getObjectsDetailsSpectraS3(getObjectsDetailsSpectraS3Request);
            for (final S3Object objectVersion : spectraS3Response.getS3ObjectListResult().getS3Objects()) {
                deleteObject(bucketName, objectName, objectVersion.getId());
            }
            return new DefaultResult("Success: Deleted object '" + this.objectName + "' and all of it's versions from bucket '" + this.bucketName + "'.");
        } else {
            final UUID version;
            if (versionId != null) {
                version = UUID.fromString(versionId);
            } else {
                version = null;
            }
            deleteObject(bucketName, objectName, version);
            return new DefaultResult("Success: Deleted object '" + this.objectName + "' from bucket '" + this.bucketName + "'.");
        }
    }

    private void deleteObject(final String bucketName, final String objectName, final UUID version) throws IOException {
        final DeleteObjectRequest deleteObjectRequest = new DeleteObjectRequest(bucketName, objectName);
        if (version != null) {
            deleteObjectRequest.withVersionId(version);
        }
        getClient().deleteObject(deleteObjectRequest);
    }
}

```


Overlapping Code:
```
ublic class DeleteObject extends CliCommand<DefaultResult> {
private final static ImmutableList<Option> requiredArgs = ImmutableList.of(BUCKET, OBJECT_NAME);
private final static ImmutableList<Option> optionalArgs = ImmutableList.of(VERSION_ID, ALL_VERSIONS);
private String bucketName;
private String objectName;
private String versionId;
private boolean allVersions;
public DeleteObject() {
}
@Override
public CliCommand init(final Arguments args) throws Exception {
processCommandOptions(requiredArgs, optionalArgs, args);
this.bucketName = args.getBucket();
this.objectName = args.getObjectName();
this.versionId = args.getVersionId();
this.allVersions = args.isAllVersions();
return this;
}
@Override
public DefaultResult call() throws Exception {
if (allVersions) {
final GetObjectsDetailsSpectraS3Request getObjectsDetailsSpectraS3Request = new GetObjectsDetailsSpectraS3Request().withName(objctsDetailsSpectraS3Response spectraS3Response = getClient().getObjectsDetailsSpectraS3(getObjectsDetailsSpectraS3Request);
for (final S3Object objectVersion : spectraS3Response.getS3ObjectListResult().getS3Objects()) {
deleteObject(bucketName, objectName, objectVersion.getId());
}
return new DefaultResult("Success: Deleted object '" + this.objectName + "' and all of it's versions from bucket '" + this.bucketName + "'.");
} else {
final UUID version;
if (versionId != null) {
version = UUID.fromString(versionId);
} else {
version = null;
}
deleteObject(bucketName, objectName, version);
return new DefaultResult("Success: Deleted object '" + this.objectName + "' from bucket '" + this.bucketName + "'.");
}
}
private void deleteObject(final String bucketName, final String objectName, final UUID version) throws IOException {
final DeleteObjectRequest deleteObjectRequest = new DeleteObjectRequest(bucketName, objectName);
if (version != null) {
deleteObjectRequest.withVersionId(version);
}
getC
```
<Overlap Ratio: 0.9523809523809523>

---

--- 279 --
Question ID: df29abba1282769ae50dd6b261a43891e13c91c9
Original Code:
```
public class SortCapList extends Vector {

    public SortCap getSortCap(int n) {
        return (SortCap) get(n);
    }

    public SortCap getSortCap(String type) {
        if (type == null) {
            return null;
        }
        int nLists = size();
        int n = 0;
        while (n < nLists) try {
            SortCap scap = getSortCap(n);
            if (type.compareTo(scap.getType()) == 0) {
                return scap;
            }
        } finally {
            n++;
        }
        return null;
    }
}

```


Overlapping Code:
```
or {
public SortCap getSortCap(int n) {
return (SortCap) get(n);
}
public SortCap getSortCap(String type) {
if (type == null) {
return null;
}
int nLiortCap scap = getSortCap(n);
if (type.compareTo(sc
```
<Overlap Ratio: 0.5555555555555556>

---

--- 280 --
Question ID: ddca8f972e4ef486dd342e78f4884eef0e4fa00e
Original Code:
```
@lombok.extern.slf4j.Slf4j
public abstract class RegionalClientBuilder<B extends RegionalClientBuilder, C> extends ClientBuilderBase<B, C> {

    public RegionalClientBuilder(Service service) {
        super(service);
    }

    /**
     * Set the region for the client to be created.
     * @param region region
     * @return this builder
     */
    public B region(com.oracle.bmc.Region region) {
        com.google.common.base.Optional<String> endpoint = region.getEndpoint(service);
        if (endpoint.isPresent()) {
            endpoint(endpoint.get());
        } else {
            throw new IllegalArgumentException("Endpoint for " + service + " is not known in region " + region);
        }
        return (B) this;
    }

    /**
     * Set the region for the client to be created.
     * @param regionId region
     * @return this builder
     */
    public B region(String regionId) {
        regionId = regionId.toLowerCase(Locale.ENGLISH);
        try {
            com.oracle.bmc.Region region = com.oracle.bmc.Region.fromRegionId(regionId);
            return region(region);
        } catch (IllegalArgumentException e) {
            LOG.info("Unknown regionId '{}', falling back to default endpoint format", regionId);
            String endpoint = com.oracle.bmc.Region.formatDefaultRegionEndpoint(service, regionId);
            return endpoint(endpoint);
        }
    }
}

```


Overlapping Code:
```
k.extern.slf4j.Slf4j
public abstract class RegionalClientBuilder<B extends RegionalClientBuilder, C>ClientBuilder(Service service) {
super(service);
}
/**
* Set the region for the client to be created.
* @param region region
* @return this builder
*/
public B region(com.oracle.bmc.Region region) {
com.google.common.base.Optional<String> endpoint = region.getEndpoint(service);
if (endpoint.isPresent()) {
endpoint(endpoint.get());
} else {
throw new IllegalArgumentException("Endpoint ice + " is not known in region " + region);
}
return (B) this;
}
/**
* Set the region for the client to be created.
* @param regionId region
* @return this builder
*/
public B region(String regionId) {
regionId = regionId.toLowerCase(Locale.ENGLISH);
try {
com.oracle.bmc.Region region = com.oracle.bmc.Region.fromRegionId(regionId);
return region(region);
} catch (IllegalArgumentException e) {
LOG.info("Unknown regionId '{}', falling back to default endpoint format", regionId);
String endpoint = com.oracle.bmc.Region.formatDefaultRegionEndpoint(service, regionId);
return endpoint(endpoint);
}
}
```
<Overlap Ratio: 0.9394987035436474>

---

--- 281 --
Question ID: dd665ca0160a69141e541d7df9ca35966420c029
Original Code:
```
class FilesystemSource extends AbstractSource implements StreamSource, FileSource {

    private static final Logger LOGGER = LoggerFactory.getLogger(FilesystemSource.class);

    private static final String UNIX_PATH_SEPARATOR = "/";

    private static final String WINDOWS_PATH_SEPARATOR = "\\";

    /**
     * Lazy-loaded by {@link #getPath}.
     */
    private Path path;

    @Override
    public void checkAccess() throws IOException {
        final Path path = getPath();
        if (!Files.exists(path)) {
            throw new NoSuchFileException("Failed to resolve " + identifier + " to " + path);
        } else if (!Files.isReadable(path)) {
            throw new AccessDeniedException("File is not readable: " + path);
        }
    }

    /**
     * @return Path corresponding to the given identifier according to the
     *         current lookup strategy
     *         ({@link Key#FILESYSTEMSOURCE_LOOKUP_STRATEGY}). The result is
     *         cached.
     */
    @Override
    public Path getPath() throws IOException {
        if (path == null) {
            final LookupStrategy strategy = LookupStrategy.from(Key.FILESYSTEMSOURCE_LOOKUP_STRATEGY);
            switch(strategy) {
                case DELEGATE_SCRIPT:
                    try {
                        path = getPathWithScriptStrategy();
                    } catch (ScriptException e) {
                        LOGGER.error(e.getMessage(), e);
                        throw new IOException(e);
                    }
                    break;
                default:
                    path = getPathWithBasicStrategy();
                    break;
            }
            LOGGER.debug("Resolved {} to {}", identifier, path);
        }
        return path;
    }

    private Path getPathWithBasicStrategy() {
        final Configuration config = Configuration.getInstance();
        final String prefix = config.getString(Key.FILESYSTEMSOURCE_PATH_PREFIX, "");
        final String suffix = config.getString(Key.FILESYSTEMSOURCE_PATH_SUFFIX, "");
        final Identifier sanitizedId = sanitizedIdentifier();
        return Paths.get(prefix + sanitizedId.toString() + suffix);
    }

    /**
     * @return Pathname of the file corresponding to the identifier passed to
     *         {@link #setIdentifier(Identifier)}.
     * @throws NoSuchFileException if the delegate method indicated that there
     *                             is no file corresponding to the given
     *                             identifier.
     * @throws ScriptException     if the method invocation failed.
     */
    private Path getPathWithScriptStrategy() throws NoSuchFileException, ScriptException {
        String pathname = getDelegateProxy().getFilesystemSourcePathname();
        if (pathname == null) {
            throw new NoSuchFileException(DelegateMethod.FILESYSTEMSOURCE_PATHMAME + " returned nil for " + identifier);
        }
        return Paths.get(pathname);
    }

    /**
     * <ol>
     *     <li>If the file's filename contains an extension, the format is
     *     inferred from that.</li>
     *     <li>If unsuccessful, and the identifier contains an extension, the
     *     format is inferred from that.</li>
     *     <li>If unsuccessful, the format is inferred from the file's magic
     *     bytes.</li>
     * </ol>
     *
     * @return Best attempt at determining the file format.
     * @throws IOException if the magic byte check fails.
     */
    @Override
    public Format getFormat() throws IOException {
        if (format == null) {
            // Try to infer a format from the filename.
            format = Format.inferFormat(getPath().getFileName().toString());
            if (Format.UNKNOWN.equals(format)) {
                // Try to infer a format from the identifier.
                format = Format.inferFormat(identifier);
            }
            if (Format.UNKNOWN.equals(format)) {
                // Fall back to reading the magic bytes.
                format = detectFormat();
            }
        }
        return format;
    }

    /**
     * Detects the format of a file by reading its header.
     *
     * @return Detected format, or {@link Format#UNKNOWN}.
     */
    private Format detectFormat() throws IOException {
        Format format = Format.UNKNOWN;
        final Path path = getPath();
        List<MediaType> detectedTypes = MediaType.detectMediaTypes(path);
        if (!detectedTypes.isEmpty()) {
            format = detectedTypes.get(0).toFormat();
        }
        return format;
    }

    @Override
    public StreamFactory newStreamFactory() throws IOException {
        return new PathStreamFactory(getPath());
    }

    /**
     * Recursively filters out {@literal fileseparator..} and
     * {@literal ..fileseparator} to prevent moving up a directory tree.
     *
     * @return Sanitized identifier.
     */
    private Identifier sanitizedIdentifier() {
        final String sanitized = StringUtils.sanitize(identifier.toString(), UNIX_PATH_SEPARATOR + "..", ".." + UNIX_PATH_SEPARATOR, WINDOWS_PATH_SEPARATOR + "..", ".." + WINDOWS_PATH_SEPARATOR);
        return new Identifier(sanitized);
    }

    @Override
    public void setIdentifier(Identifier identifier) {
        path = null;
        format = null;
        this.identifier = identifier;
    }
}

```


Overlapping Code:
```
treamSource, FileSource {
private static final Logger LOGGER = LoggerFactory.getLogger(Filesyrce.class);
private static final String UNIX_PATH_SEPARATOR = "/";
private static final String WINDOWS_PATH_SEPARATOR = "\\";
/**
* Lazy-loaded by {@link #getPath}.
*/
private Path path;
@Override
public void checkAccess() throws IOException {
final Path path = getPath();
if (!Files.exists(path)) {
throw new NoSuchFileException("Failed to resolve "isReadable(path)) {
throw new AccessDeniedException("File is not readable: " + path);
}
}
/**
* @return Path corresponding to the given identifier according to the
* current lookup strategy
* ({@link Key#FILESYSTEMSOURCE_LOOKUP_STRATEGY}). The result is
* cached.
*/
@Override
public Path getPath() throws IOException {
if (path == null) {
final Look
case DELEGATE_SCRIPT:
try {
path = getPathWithScriptStrategy();
} catch (ScriptException e) {
LOGGER.error(e.getMessage(), e);
throw new IOException(e);
}
break;
default:
path = getPathWithBasicStrategy();
break;
}
LOGGER.debug("Resolved {} to {}", identifier, path);
}
return path;
}
private Path getPathWithBasicStrategy() {
final Configuration config = Configuration.getInstance();
final String prefix = config.ng(Key.FILESYSTEMSOURCE_PATH_SUFFIX, "");
final Identifier sanitizedId = sanitizedIdentifier();
return Paths.get(prefix + sanitizedId.toString() + suffix);
}
/**
* @return Pathname of the file corresponding to the identifier passed to
* {@link #setIdentifier(Identifier)}.
* @throws NoSuchFileException if the delegate method indicated that there
* i
```
<Overlap Ratio: 0.8221635883905013>

---

--- 282 --
Question ID: 6010ce895b3af2938615bae54d10caa4a458667d
Original Code:
```
public class SegmentHandler {

    public LinkedList<vec> segments;

    public LinkedList<EnumFacing> segmentbottomsides;

    public LinkedList<EnumFacing> segmenttopsides;

    public World world;

    public grappleArrow arrow;

    vec prevhookpos = null;

    vec prevplayerpos = null;

    final double bendoffset = 0.05;

    final double intoblock = 0.05;

    public SegmentHandler(World w, grappleArrow arrow, vec hookpos, vec playerpos) {
        segments = new LinkedList<vec>();
        segments.add(hookpos);
        segments.add(playerpos);
        segmentbottomsides = new LinkedList<EnumFacing>();
        segmentbottomsides.add(null);
        segmentbottomsides.add(null);
        segmenttopsides = new LinkedList<EnumFacing>();
        segmenttopsides.add(null);
        segmenttopsides.add(null);
        this.world = w;
        this.arrow = arrow;
        this.prevhookpos = new vec(hookpos);
        this.prevplayerpos = new vec(playerpos);
    }

    public void forceSetPos(vec hookpos, vec playerpos) {
        this.prevhookpos = new vec(hookpos);
        this.prevplayerpos = new vec(playerpos);
        this.segments.set(0, new vec(hookpos));
        this.segments.set(this.segments.size() - 1, new vec(playerpos));
    }

    double ropelen;

    public void updatepos(vec hookpos, vec playerpos, double ropelen) {
        segments.set(0, hookpos);
        segments.set(segments.size() - 1, playerpos);
        this.ropelen = ropelen;
    }

    public void update(vec hookpos, vec playerpos, double ropelen, boolean movinghook) {
        if (prevhookpos == null) {
            prevhookpos = hookpos;
            prevplayerpos = playerpos;
        }
        segments.set(0, hookpos);
        segments.set(segments.size() - 1, playerpos);
        this.ropelen = ropelen;
        vec closest = segments.get(segments.size() - 2);
        while (true) {
            if (segments.size() == 2) {
                break;
            }
            int index = segments.size() - 2;
            closest = segments.get(index);
            EnumFacing bottomside = segmentbottomsides.get(index);
            EnumFacing topside = segmenttopsides.get(index);
            vec ropevec = playerpos.sub(closest);
            vec beforepoint = segments.get(index - 1);
            vec edgevec = getnormal(bottomside).cross(getnormal(topside));
            vec planenormal = beforepoint.sub(closest).cross(edgevec);
            if (ropevec.dot(planenormal) > 0) {
                this.removesegment(index);
            } else {
                break;
            }
        }
        vec farthest = segments.get(1);
        if (movinghook) {
            while (true) {
                if (segments.size() == 2) {
                    break;
                }
                int index = 1;
                farthest = segments.get(index);
                EnumFacing bottomside = segmentbottomsides.get(index);
                EnumFacing topside = segmenttopsides.get(index);
                vec ropevec = farthest.sub(hookpos);
                vec beforepoint = segments.get(index + 1);
                vec edgevec = getnormal(bottomside).cross(getnormal(topside));
                vec planenormal = beforepoint.sub(farthest).cross(edgevec);
                if (ropevec.dot(planenormal) > 0 || ropevec.length() < 0.1) {
                    //					System.out.println("removed farthest");
                    this.removesegment(index);
                } else {
                    break;
                }
            }
            while (true) {
                if (this.getDistToFarthest() > ropelen) {
                    this.removesegment(1);
                } else {
                    break;
                }
            }
        }
        if (movinghook) {
            farthest = segments.get(1);
            vec prevfarthest = farthest;
            if (segments.size() == 2) {
                prevfarthest = prevplayerpos;
            }
            updatesegment(hookpos, prevhookpos, farthest, prevfarthest, 1, 0);
        }
        vec prevclosest = closest;
        if (segments.size() == 2) {
            prevclosest = prevhookpos;
        }
        updatesegment(closest, prevclosest, playerpos, prevplayerpos, segments.size() - 1, 0);
        prevhookpos = hookpos;
        prevplayerpos = playerpos;
    }

    public void removesegment(int index) {
        segments.remove(index);
        segmentbottomsides.remove(index);
        segmenttopsides.remove(index);
        if (!this.world.isRemote) {
            SegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), false, index, new vec(0, 0, 0), EnumFacing.DOWN, EnumFacing.DOWN);
            vec playerpoint = vec.positionvec(this.arrow.shootingEntity);
            grapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));
        }
    }

    public void updatesegment(vec top, vec prevtop, vec bottom, vec prevbottom, int index, int numberrecursions) {
        RayTraceResult bottomraytraceresult = this.world.rayTraceBlocks(bottom.toVec3d(), top.toVec3d(), false, true, false);
        // if rope hit block
        if (bottomraytraceresult != null) {
            if (this.world.rayTraceBlocks(prevbottom.toVec3d(), prevtop.toVec3d(), false, true, false) != null) {
                //        		System.out.println("Warning: prev collision");
                return;
            }
            //        	System.out.println(bottomraytraceresult.typeOfHit);
            vec bottomhitvec = new vec(bottomraytraceresult.hitVec.x, bottomraytraceresult.hitVec.y, bottomraytraceresult.hitVec.z);
            /*            this.arrow.debugpos = bottomhitvec;
            this.arrow.debugpos2 = bottom;
            this.arrow.debugpos3 = top;*/
            EnumFacing bottomside = bottomraytraceresult.sideHit;
            vec bottomnormal = this.getnormal(bottomside);
            //            double ropelen = top.sub(bottom).length();
            double prevropelen = prevtop.sub(prevbottom).length();
            // and is bounded by the quadrilateral top, prevtop, prevbottom, bottom
            vec cornerbound1 = bottomhitvec.add(bottomnormal.changelen(-intoblock));
            vec bound_option1 = line_plane_intersection(prevtop, prevbottom, cornerbound1, bottomnormal);
            /*            if (cornerbound1.sub(bound_option1).length() < cornerlinedist) {
            	cornerbound2 = bound_option1;
            	cornerlinedist = cornerbound1.sub(bound_option1).length();
            }*/
            vec bound_option2 = line_plane_intersection(top, prevtop, cornerbound1, bottomnormal);
            /*            if (cornerbound1.sub(bound_option2).length() < cornerlinedist) {
            	cornerbound2 = bound_option2;
            	cornerlinedist = cornerbound1.sub(bound_option2).length();
            }*/
            vec bound_option3 = line_plane_intersection(prevbottom, bottom, cornerbound1, bottomnormal);
            //            if (cornerbound2 != null) {
            for (vec cornerbound2 : new vec[] { bound_option1, bound_option2, bound_option3 }) {
                if (cornerbound2 == null) {
                    continue;
                }
                // the corner must be in the line (cornerbound2, cornerbound1)
                RayTraceResult cornerraytraceresult = this.world.rayTraceBlocks(cornerbound2.toVec3d(), cornerbound1.toVec3d(), false, true, false);
                if (cornerraytraceresult != null) {
                    vec cornerhitpos = new vec(cornerraytraceresult.hitVec.x, cornerraytraceresult.hitVec.y, cornerraytraceresult.hitVec.z);
                    EnumFacing cornerside = cornerraytraceresult.sideHit;
                    if (cornerside == bottomside || cornerside.getOpposite() == bottomside) {
                        //                		System.out.println("Warning: corner is same or opposite of bottomside");
                        continue;
                    } else {
                        // add a bend around the corner
                        vec actualcorner = cornerhitpos.add(bottomnormal.changelen(intoblock));
                        vec bend = actualcorner.add(bottomnormal.changelen(bendoffset)).add(getnormal(cornerside).changelen(bendoffset));
                        vec topropevec = bend.sub(top);
                        vec bottomropevec = bend.sub(bottom);
                        // ignore bends that are too close to another bend
                        if (topropevec.length() < 0.05) {
                            if (this.segmentbottomsides.get(index - 1) == bottomside && this.segmenttopsides.get(index - 1) == cornerside) {
                                //                    			System.out.println("Warning: top bend is too close");
                                continue;
                            }
                        }
                        if (bottomropevec.length() < 0.05) {
                            if (this.segmentbottomsides.get(index) == bottomside && this.segmenttopsides.get(index) == cornerside) {
                                //                    			System.out.println("Warning: bottom bend is too close");
                                continue;
                            }
                        }
                        this.actuallyaddsegment(index, bend, bottomside, cornerside);
                        // if not enough rope length left, undo
                        if (this.getDistToAnchor() + .2 > this.ropelen) {
                            //                			System.out.println("Warning: not enough length left, removing");
                            this.removesegment(index);
                            continue;
                        }
                        // now to recurse on top section of rope
                        double newropelen = topropevec.length() + bottomropevec.length();
                        double prevtoptobend = topropevec.length() * prevropelen / newropelen;
                        vec prevbend = prevtop.add(prevbottom.sub(prevtop).changelen(prevtoptobend));
                        if (numberrecursions < 10) {
                            updatesegment(top, prevtop, bend, prevbend, index, numberrecursions + 1);
                        } else {
                            System.out.println("Warning: number recursions exceeded");
                        }
                        break;
                    }
                }
            }
        }
    }

    public vec line_plane_intersection(vec linepoint1, vec linepoint2, vec planepoint, vec planenormal) {
        vec linevec = linepoint2.sub(linepoint1);
        if (linevec.dot(planenormal) == 0) {
            return null;
        }
        double d = planepoint.sub(linepoint1).dot(planenormal) / linevec.dot(planenormal);
        return linepoint1.add(linevec.mult(d));
    }

    public vec getnormal(EnumFacing facing) {
        Vec3i facingvec = facing.getDirectionVec();
        return new vec(facingvec.getX(), facingvec.getY(), facingvec.getZ());
    }

    public boolean hookpastbend(double ropelen) {
        return (this.getDistToFarthest() > ropelen);
    }

    public BlockPos getbendblock(int index) {
        vec bendpos = this.segments.get(index);
        bendpos.add_ip(this.getnormal(this.segmentbottomsides.get(index)).changelen(-this.intoblock * 2));
        bendpos.add_ip(this.getnormal(this.segmenttopsides.get(index)).changelen(-this.intoblock * 2));
        return new BlockPos(bendpos.x, bendpos.y, bendpos.z);
    }

    public void actuallyaddsegment(int index, vec bendpoint, EnumFacing bottomside, EnumFacing topside) {
        segments.add(index, bendpoint);
        segmentbottomsides.add(index, bottomside);
        segmenttopsides.add(index, topside);
        if (!this.world.isRemote) {
            SegmentMessage addmessage = new SegmentMessage(this.arrow.getEntityId(), true, index, bendpoint, topside, bottomside);
            vec playerpoint = vec.positionvec(this.arrow.shootingEntity);
            grapplemod.network.sendToAllAround(addmessage, new TargetPoint(this.world.provider.getDimension(), playerpoint.x, playerpoint.y, playerpoint.z, 100));
        }
    }

    public void print() {
        int i = 1;
        while (i < segments.size() - 1) try {
            System.out.print(i);
            System.out.print(" ");
            System.out.print(segmenttopsides.get(i).toString());
            System.out.print(" ");
            System.out.print(segmentbottomsides.get(i).toString());
            System.out.print(" ");
            segments.get(i).print();
        } finally {
            i++;
        }
    }

    public vec getclosest(vec hookpos) {
        segments.set(0, hookpos);
        return segments.get(segments.size() - 2);
    }

    public double getDistToAnchor() {
        double dist = 0;
        int i = 0;
        while (i < segments.size() - 2) try {
            dist += segments.get(i).sub(segments.get(i + 1)).length();
        } finally {
            i++;
        }
        return dist;
    }

    public vec getfarthest() {
        return segments.get(1);
    }

    public double getDistToFarthest() {
        double dist = 0;
        int i = 1;
        while (i < segments.size() - 1) try {
            dist += segments.get(i).sub(segments.get(i + 1)).length();
        } finally {
            i++;
        }
        return dist;
    }

    public double getDist(vec hookpos, vec playerpos) {
        segments.set(0, hookpos);
        segments.set(segments.size() - 1, playerpos);
        double dist = 0;
        int i = 0;
        while (i < segments.size() - 1) try {
            dist += segments.get(i).sub(segments.get(i + 1)).length();
        } finally {
            i++;
        }
        return dist;
    }

    public AxisAlignedBB getBoundingBox(vec hookpos, vec playerpos) {
        this.updatepos(hookpos, playerpos, this.ropelen);
        vec minvec = new vec(hookpos);
        vec maxvec = new vec(hookpos);
        int i = 1;
        while (i < segments.size()) try {
            vec segpos = segments.get(i);
            if (segpos.x < minvec.x) {
                minvec.x = segpos.x;
            } else if (segpos.x > maxvec.x) {
                maxvec.x = segpos.x;
            }
            if (segpos.y < minvec.y) {
                minvec.y = segpos.y;
            } else if (segpos.y > maxvec.y) {
                maxvec.y = segpos.y;
            }
            if (segpos.z < minvec.z) {
                minvec.z = segpos.z;
            } else if (segpos.z > maxvec.z) {
                maxvec.z = segpos.z;
            }
        } finally {
            i++;
        }
        AxisAlignedBB bb = new AxisAlignedBB(minvec.x, minvec.y, minvec.z, maxvec.x, maxvec.y, maxvec.z);
        //		System.out.println(bb.maxX);
        return bb;
    }
}

```


Overlapping Code:
```
er {
public LinkedList<vec> segments;
public LinkedList<EnumFacing> segmentbottomsides;
public LinkedList<EnumFacing> segmenttopsides;
public World woublic SegmentHandler(World w, grappleArrow arrow, vec hookpos, vec playerpos) {
segments = new LinkedList<vec>();
segments.add(hookpos);
segments.add(playerpos);
segmentbottomsides = new LinkedList<EnumFacing>();
segmentbottomsides.add(null);
segmentbottomsides.add(null);
segmenttopsides = new LinkedList<EnumFacing>();
segmenttopsides.add(null);
segmenttopsides.add(null);
this.world = w;
this.arrow = arrow;
this.prevhookpos = new vec(hookpos);
this.prevplayerpos = new vec(playerposookpos, vec playerpos) {
this.prevhookpos = new vec(hookpos);
this.prevplayerpos = new vec(playerpos);
this.segments.set(0, new vec(hookpos));
this.segments.set(this.segments.size() - 1, new vec(playevec hookpos, vec playerpos, double ropelen) {
segments.set(0, hookpos);
segments.set(segments.size() - 1, playerpos);
this.ropelen = ropc void update(vec hookpos, vec playerpos, double ropelen, boolean movinghook) {
if (prevhookpos == null) {
prevhookpos = hookpos;
prevplayerpos = playgments.set(0, hookpos);
segments.set(segments.size() - 1, playerpos);
this.ropelen = ropsegments.get(index);
EnumFacing bottomside = segmentbottomsides.get(index);
EnumFacing topside = segmenttopsides.get(index);
vec ropevec = playerpos.smal(bottomside).cross(getnormal(topside));
vec planenormal = beforepoint.s
```
<Overlap Ratio: 0.7123695976154992>

---

--- 283 --
Question ID: bec0e15270d0c37da3353799049257d5d218b2d9
Original Code:
```
@Service
public class TableServiceImpl implements TableService {

    @Autowired
    private ClusterService clusterService;

    @Override
    public List<Table> listTableByClusterName(String clusterName, boolean isContainMetrics) {
        Cluster cluster = clusterService.getClusterByName(clusterName);
        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(cluster.getClusterName(), cluster.getZookeeperAddress(), cluster.getZnodeParent());
        List<Table> tableList = hbaseFacade.listTables();
        String hdfsRootpath = cluster.getHdfsRootPath();
        HDFSFacade hdfsFacade = HDFSFacadeFactory.createHDFSFacade(hdfsRootpath);
        String tableDataPath = hdfsRootpath + "/data/";
        // ??????
        if (isContainMetrics) {
            for (Table table : tableList) {
                table.setSpaceSize(hdfsFacade.getPathSpaceSize(tableDataPath + table.getNamespace() + "/" + table.getTableName()));
            }
        }
        return tableList;
    }

    @Override
    public List<String> listTableNameByClusterName(String clusterName) {
        Cluster cluster = clusterService.getClusterByName(clusterName);
        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(cluster.getClusterName(), cluster.getZookeeperAddress(), cluster.getZnodeParent());
        return hbaseFacade.listTableNames();
    }

    @Override
    public Table getTableByName(String clusterName, String tableName) {
        Cluster cluster = clusterService.getClusterByName(clusterName);
        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());
        Table table = hbaseFacade.getTableByName(tableName);
        return table;
    }

    @Override
    public int save(String clusterName, String ddlStr) {
        Table table = JsonUtils.getJsonVal(ddlStr, Constant.TABLE_TYPE);
        if (null != table) {
            Cluster cluster = clusterService.getClusterByName(clusterName);
            HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());
            hbaseFacade.createTable(table);
        }
        return 0;
    }

    @Override
    public int update(String clusterName, String ddlStr) {
        Table table = JsonUtils.getJsonVal(ddlStr, Constant.TABLE_TYPE);
        if (null != table) {
            Cluster cluster = clusterService.getClusterByName(clusterName);
            HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());
            hbaseFacade.alterTable(table);
        }
        return 0;
    }

    @Override
    public void enableTable(String clusterName, String tableName) {
        Cluster cluster = clusterService.getClusterByName(clusterName);
        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());
        hbaseFacade.operateTable(tableName, HTableOpEnum.ENABLE);
    }

    @Override
    public void disableTable(String clusterName, String tableName) {
        Cluster cluster = clusterService.getClusterByName(clusterName);
        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());
        hbaseFacade.operateTable(tableName, HTableOpEnum.DISABLE);
    }

    @Override
    public void deleteTable(String clusterName, String tableName) {
        Cluster cluster = clusterService.getClusterByName(clusterName);
        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());
        hbaseFacade.operateTable(tableName, HTableOpEnum.DELETE);
    }

    @Override
    public void compactTable(String clusterName, String tableName) {
        Cluster cluster = clusterService.getClusterByName(clusterName);
        HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());
        hbaseFacade.operateTable(tableName, HTableOpEnum.COMPACT);
    }

    @Override
    public Long getTableSpaceSize(String clusterName, String namespace, String tableName) {
        Cluster cluster = clusterService.getClusterByName(clusterName);
        String hdfsRootpath = cluster.getHdfsRootPath();
        HDFSFacade hdfsFacade = HDFSFacadeFactory.createHDFSFacade(hdfsRootpath);
        String tableDataPath = new StringBuilder(hdfsRootpath).append("/data/").append(namespace).append("/").append(tableName).toString();
        long spaceSize = hdfsFacade.getPathSpaceSize(tableDataPath);
        return spaceSize;
    }
}

```


Overlapping Code:
```
@Service
public class TableServiceImpl implements TableService {
@Autowired
private ClusterService clusterService;
@Override
public List<Table> listTableByClusterName(String clusterName, boolean isContainMetrics) {
Cluster cluster = clusterService.getClusterByName(clusterName);
HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(cluster.getClusterName(), cluster.getZookeeperAddress(), cluster.getZnodeParent());
List<Table> tableList = hbaseFacade.listTables();
String hdfsRootpath = cluster.getHdfsRootPath();
HDFSFacade hdfsFacade = HDFSFacadeFactory.createHDFSFacade(hdfsRootpath);
String tableDataPatainMetrics) {
for (Table table : tableList) {
tablataPath + table.getNamespace() + "/" + table.getTableName()));
}
}
return tableList;
}
@Override
public List<String> listTableNameByClusterName(String clusterName) {
Cluster cluster = clusterService.getClusterByName(clusterName);
HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(cluster.getClusterName(), cluster.getZookeeperAddress(), cluster.getZnodeParent());
return hbaseFacade.listTableNames();
}
@Override
public Table getTableByName(String clusterName, String tableName) {
Cluster cluster = clusterService.getClusterByName(clusterName);
HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParente table = hbaseFacade.getTableByName(tableName);
return table;
}
@Override
public int save(String clusterName, String ddlStr) {
Table table = JsonUtils.getJsonVal(ddlStr, Constant.TABLE_TYPE);
if (null != table) {
Cluster cluster = clusterService.getClusterByName(clusterName);
HBaseFacade hbaseFacade = HBaseFacadeFactory.createAdministrator(clusterName, cluster.getZookeeperAddress(), cluster.getZnodeParent());
hbaseFacade.createTable(table);
}
return 0;
}
@Override
public int update(String clusterName, String ddlStr) {
Table table = JsonUtils.getJsonVal(ddlStr, Constant.TABLE_TYPE);
if (null != table) {
Cluster cluster = clusterService.getClusterByName(clusterName);
H
```
<Overlap Ratio: 0.9496503496503497>

---

--- 284 --
Question ID: 24ef2e880679f1e3b10ea8823a888c5bb2050a57
Original Code:
```
public class LocalResourceSimpleAdapterTest extends AndroidTestCase {

    public void testEagerAdapter() {
        final Context context = getContext();
        final Resources res = context.getResources();
        final String[] uris = res.getStringArray(R.array.local_uri_test);
        Assert.assertNotNull(uris);
        SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter.getEagerAdapter(context, R.array.local_uri_test);
        checkSimpleAdapterData(simpleAdapter, uris.length);
        Assert.assertFalse(simpleAdapter.isLazy());
    }

    public void testLazyAdapter() {
        final Context context = getContext();
        final Resources res = context.getResources();
        final String[] uris = res.getStringArray(R.array.local_uri_test);
        Assert.assertNotNull(uris);
        SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdapter.getEagerAdapter(context, R.array.local_uri_test);
        checkSimpleAdapterData(simpleAdapter, uris.length);
        Assert.assertTrue(simpleAdapter.isLazy());
    }

    private void checkSimpleAdapterData(SimpleAdapter<Uri> simpleAdapter, int requestedSize) {
        Assert.assertNotNull(simpleAdapter);
        Assert.assertEquals(10, requestedSize);
        Assert.assertEquals(simpleAdapter.getSize(), requestedSize);
        Uri firstUri = simpleAdapter.get(0);
        assertNotNull(firstUri);
        assertEquals(Uri.parse("http://myserver.com/file1"), firstUri);
        Uri lastUri = simpleAdapter.get(simpleAdapter.getSize() - 1);
        assertNotNull(lastUri);
        assertEquals(Uri.parse("http://myserver.com/file10"), lastUri);
    }
}

```


Overlapping Code:
```
dapterTest extends AndroidTestCase {
public void testEagerAdapter() {
final Context context = getContext();
final Resources res = context.getResources();
final String[] uris = res.getStringArray(R.array.local_uri_test);
Assert.assertNotNull(uris);
SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdt, R.array.local_uri_test);
checkSimpleAdapterData(simpleAdapter, uris.length);
Assert.assertFalse(simpleAdapter.isLazy());
}
public void testLazyAdapter() {
final Context context = getContext();
final Resources res = context.getResources();
final String[] uris = res.getStringArray(R.array.local_uri_test);
Assert.assertNotNull(uris);
SimpleAdapter<Uri> simpleAdapter = LocalResourceSimpleAdt, R.array.local_uri_test);
checkSimpleAdapterData(simpleAdapter, uris.length);
Assert.assertTrue(simpleAdapter.isLazy());
}
private void checkSimpleAdapterData(SimpleAdapter<Uri> simpleAdapter, int requestedSize) {
Assert.assertNotNull(simpleAdapter);
Assert.assertEquals(10, requestedSize);
Assert.assertEquals(simpleAdapter.getSize(), requestedSize);
Uri firstUri = simpleAdapter.get(0);
assertNotNull(firstUri);
assertEquals(Uri.parse("http://myserver.com/file1"), firstUri);
Uri lastUri = simpleAdapter.get(simpleAdapter.getSize() - 1);
assertNotNull(lastUri);
assertEquals(Uri.parse("http://mys
```
<Overlap Ratio: 0.9139633286318759>

---

--- 285 --
Question ID: 165be4ad837d4dc31731102269d03b8d9ccf05db
Original Code:
```
public class SimpleSpider {

    //The page number at which the program is trying to start.
    private static final int page = 2376;

    public static void main(String[] args) {
        //HttpClient Comfigurations for time out
        RequestConfig globalConfig = RequestConfig.custom().setCookieSpec(CookieSpecs.STANDARD).setConnectionRequestTimeout(6000).setConnectTimeout(6000).build();
        CloseableHttpClient httpClient = HttpClients.custom().setDefaultRequestConfig(globalConfig).build();
        System.out.println("Begin searching in 5 seconds??");
        int i = page;
        while (i > 0) try {
            //Creating a GET request
            HttpGet httpGet = new HttpGet("http://jandan.net/ooxx/page-" + i);
            httpGet.addHeader("User-Agent", "Chrome/56.0.2924.87");
            httpGet.addHeader("Cookie", "_gat=1; nsfw-click-load=off; gif-click-load=on; _ga=GA1.2.1861846600.1423061484");
            try {
                Thread.sleep(5000);
                //Sending the request
                CloseableHttpResponse response = httpClient.execute(httpGet);
                InputStream in = response.getEntity().getContent();
                String html = Utils.convertStreamToString(in);
                //Analyzing the web contents
                new Thread(new JianDanHtmlParser(html, i)).start();
            } catch (Exception e) {
                e.printStackTrace();
            }
        } finally {
            i--;
        }
    }
}

```


Overlapping Code:
```
 SimpleSpider {
//The page number at which the program is trying to start.
private static final int ) {
//HttpClient Comfigurations for time out
RequestConfig globalConfig = RequestConfig.custom().setCookieSpec(CookieSpecs.STANDARD).setConnectionRequestTimeout(6000).setConnectTimeout(6000).build();
CloseableHttpClient httpClient = HttpClients.custom().setDefaultRequestConfig(globalConfig).build();
System.out.p GET request
HttpGet httpGet = new HttpGet("http://jandan.net/ooxx/page-" + i);
httpGet.addHeader("Ulick-load=off; gif-click-load=on; _ga=GA1.2.1861846600.1423061484");
try  request
CloseableHttpResponse response = httpClient.execute(httpGet);
InputStream in = response.getEntity().getContent();
String html = Utils.convertStreamToString(in);
//Analyzing the web contents
new Thread(new JianDanHtmlParser(html, i)).start();
} catch (Exception e) {
e.printStackTrace();
}
} finally {

```
<Overlap Ratio: 0.7658119658119659>

---

--- 286 --
Question ID: 117d1bfc6a7d95635dd924ba6af65c3abadbb183
Original Code:
```
public class ProvisionFailureEventNode extends RemoteServiceEventNode<ProvisionFailureEvent> {

    private String status;

    public ProvisionFailureEventNode(ProvisionFailureEvent event) {
        super(event);
        status = "Pending";
    }

    @Override
    public Throwable getThrown() {
        return getEvent().getThrowable();
    }

    @Override
    public String getDescription() {
        StringBuilder builder = new StringBuilder();
        for (String reason : getEvent().getFailureReasons()) {
            if (builder.length() > 0)
                builder.append("\n    ");
            builder.append(reason);
        }
        return builder.toString();
    }

    @Override
    public String getOperationalStringName() {
        return getEvent().getServiceElement().getOperationalStringName();
    }

    @Override
    public String getServiceName() {
        return getEvent().getServiceElement().getName();
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return getServiceName();
    }

    @Override
    public int getColumnCount() {
        return 3;
    }

    @Override
    public Object getValueAt(int column) {
        String value;
        if (column == 0) {
            value = "PROVISION_FAILURE";
        } else if (column == 1) {
            value = getDescription();
        } else {
            value = Constants.DATE_FORMAT.format(getDate());
        }
        return value;
    }
}

```


Overlapping Code:
```
ublic class ProvisionFailureEventNode extends RemoteServiceEventNode<ProvisionFailureEvent> {
private String status;
public ProvisionFailureEventNode(ProvisionFailureEvent event) {
super(event);
status = "Pending";
}
@Override
public Throwable getThrown() {
return getEvent().getThrowable();
}
@Override
public String getDescription() {
StringBuilder builder = new StringBuilder();
for (String repend(reason);
}
return builder.toString();
}
@Override
public String getOperationalStringName() {
return getEvent().getServiceElement().getOperationalStringName();
}
@Override
public String getServiceName() {
return getEvent().getServiceElement().getName();
}
public String getStatus() {
return status;
}
public void setStatus(String status) {
this.status = status;
}
@Override
public String toString() {
return getServiceName();
}
@Override
public int getColumnCount() {
return 3;
}
@Override
public Object getValueAt(int column) {
String value;
if (column == 0) {
value = "PROVISION_FAILURE";
} else if (column == 1) {
value = getDescription();
} else {
value = Constants.DATE_FORMAT.format(getDate());
}
return value;
```
<Overlap Ratio: 0.914004914004914>

---

--- 287 --
Question ID: 73c0128eea6de9f738bb18aeb804b5c4154dd8dc
Original Code:
```
@ExtendWith(MockitoExtension.class)
class AuthCodeGenerationServiceTest {

    @Mock
    private AuthorizationCodeRepository repository;

    @InjectMocks
    private AuthCodeGenerationService testee;

    @Test
    void test_create() {
        //given
        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(2));
        when(repository.existsByCode(anyString())).thenReturn(false);
        //when
        AuthorizationCodeResponseDto responseDto = testee.create(createDto);
        //then
        assertNotNull(responseDto.getAuthorizationCode());
        assertTrue(responseDto.getAuthorizationCode().matches("\\d{12}"));
        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));
    }

    @Test
    void test_create_code_already_exists() {
        //given
        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());
        when(repository.existsByCode(anyString())).thenReturn(true).thenReturn(false);
        //when
        AuthorizationCodeResponseDto responseDto = testee.create(createDto);
        //then
        assertNotNull(responseDto.getAuthorizationCode());
        assertTrue(responseDto.getAuthorizationCode().matches("\\d{12}"));
        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));
    }

    @Test
    void test_create_invalid_onset_date_in_future() {
        //given
        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().plusDays(1));
        //then
        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));
    }

    @Test
    void test_create_invalid_onset_date_too_far_back() {
        //given
        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.of(2017, 7, 7));
        //then
        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));
    }

    @Test
    void test_create_invalid_onset_date_4_weeks_plus_one_day_back() {
        //given
        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4).minusDays(1));
        //then
        assertThrows(ResponseStatusException.class, () -> testee.create(createDto));
    }

    @Test
    void test_create_valid_onset_date_exactly_4_weeks_back() {
        //given
        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(4));
        //when
        AuthorizationCodeResponseDto responseDto = testee.create(createDto);
        //then
        assertNotNull(responseDto.getAuthorizationCode());
        assertTrue(responseDto.getAuthorizationCode().matches("\\d{12}"));
        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));
    }

    @Test
    void test_create_valid_onset_date_exactly_now() {
        //given
        AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());
        //when
        AuthorizationCodeResponseDto responseDto = testee.create(createDto);
        //then
        assertNotNull(responseDto.getAuthorizationCode());
        assertTrue(responseDto.getAuthorizationCode().matches("\\d{12}"));
        verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));
    }
}

```


Overlapping Code:
```
endWith(MockitoExtension.class)
class AuthCodeGenerationServiceTest {
@Mock
private AuthorizationCodeRepository repository;
@InjectMocks
private AuthCodeGenerationService testee;
@Test
void test_create() {
//given
AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minusWeeks(2));
when(repository.existsByCode(anyString())).thenReturn(false);
//when
AuthorizationCodeResponseDto responseDto = testee.create(createDto);
//then
assertNotNull(responseDto.getAuthorizationCode());
assertTrue(responseDto.getAuthorizationCode().matches("\\d{12}"));
verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));
}
@Test
void test_create_code_already_exists() {
//given
AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now());
when(repository.existsByCode(anyString())).thenReturn(true).thenReturn(false);
//when
AuthorizationCodeResponseDto responseDto = testee.create(createDto);
//then
assertNotNull(responseDto.getAuthorizationCode());
assertTrue(responseDto.getAuthorizationCode().matches("\\d{12}"));
verify(repository, times(1)).saveAndFlush(ArgumentMatchers.any(AuthorizationCode.class));
}
@Test
void test_create_invalid_onset_date_in_future() {
//given
AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().plusDays(1));
//then
assertThrows(ResponseStatusException.class, () -> testee.create(createDto));
}
@Test
void test_create_invalid_onset_date_too_far_back() {
//given
AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(Local);
//then
assertThrows(ResponseStatusException.class, () -> testee.create(createDto));
}
@Test
void test_create_invalid_onset_date_4_weeks_plus_one_day_back() {
//given
AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minus);
//then
assertThrows(ResponseStatusException.class, () -> testee.create(createDto));
}
@Test
void test_create_valid_onset_date_exactly_4_weeks_back() {
//given
AuthorizationCodeCreateDto createDto = new AuthorizationCodeCreateDto(LocalDate.now().minus
```
<Overlap Ratio: 0.9748251748251748>

---

--- 288 --
Question ID: 8a9bfb3171c29a5cac43a722a02e924726776612
Original Code:
```
@Getter
@Setter
public class NpcShop {

    private int shopId;

    private int selectNpcItemId;

    private int npcTemplateId;

    private int starCoin;

    private int shopVerNo;

    private List<NpcShopItem> items = new ArrayList<>();

    public List<NpcShopItem> getItems() {
        return items;
    }

    public void setItems(List<NpcShopItem> items) {
        this.items = items;
    }

    public void encode(OutPacket out, List<NpcShopItem> repurchaseItems) {
        out.writeZeroBytes(20);
        out.writeInt(DateUtil.getTime());
        out.writeBool(false);
        out.writeShort(items.size() + repurchaseItems.size());
        items.forEach(npcShopItem -> npcShopItem.encode(out));
        ListIterator<NpcShopItem> itemListIterator;
        for (itemListIterator = repurchaseItems.listIterator(); itemListIterator.hasNext(); ) {
            itemListIterator.next();
        }
        for (; itemListIterator.hasPrevious(); ) {
            NpcShopItem shopItem = itemListIterator.previous();
            shopItem.encode(out);
        }
    }

    public NpcShopItem getItemByIndex(int idx) {
        NpcShopItem item = null;
        if (idx >= 0 && idx < getItems().size()) {
            item = getItems().get(idx);
        }
        return item;
    }
}

```


Overlapping Code:
```
 NpcShop {
private int shopId;
private int selectNpcItemId;
private int npcTemplateId;
private int starCoin;
private int shopVerNo;
private List<NpcShopItem> items = new ArrayList<>();
public List<NpcShopItem> getItems() {
return items;
}
public void setItems(List<NpcShopItem> items) {
this.items = items;
}
public void encode(OutPacket out, List<NpcShopItem> repurchaseItems) {
out.writeZeroBytes(20);
out.writeInt(DateUtil.getTime());
out.writeBool(false);
out.writeShort(items.size() + repurchaseItems.size());
items.forEach(npcShopItem -> npcShopItem.encode(out));
ListIterator<NpcShopItem> itemListIterator;
for (itemListIterator = repurchaseItems.listIterator(); itemListIterator.hasNext(); ) tIterator.previous();
shopItem.encode(out);
}
}
public NpcShopItem getItemByIndex(int idx) {
NpcShopItem item = null;
if (idx >= 0 && idx < getItems().size()) {
item = getItems().get(idx);
}
return it
```
<Overlap Ratio: 0.8678881388621023>

---

--- 289 --
Question ID: 95b4f2f41928e6bf7ea2abf2c075fca294df06a9
Original Code:
```
@Component
@Description("Authorization policy assigned by given identity by assigned or default role.")
public class AuthorizationPolicyByIdentityFilterBuilder extends AbstractFilterBuilder<IdmAuthorizationPolicy, IdmAuthorizationPolicyFilter> {

    @Autowired
    @Lazy
    private RoleConfiguration roleConfiguration;

    @Autowired
    @Lazy
    private IdmRoleCompositionService roleCompositionService;

    @Autowired
    public AuthorizationPolicyByIdentityFilterBuilder(IdmAuthorizationPolicyRepository repository) {
        super(repository);
    }

    @Override
    public String getName() {
        return IdmAuthorizationPolicyFilter.PARAMETER_IDENTITY_ID;
    }

    @Override
    public Predicate getPredicate(Root<IdmAuthorizationPolicy> root, AbstractQuery<?> query, CriteriaBuilder builder, IdmAuthorizationPolicyFilter filter) {
        UUID identityId = filter.getIdentityId();
        if (identityId == null) {
            return null;
        }
        // assigned role subquery
        Subquery<IdmIdentityRole> subquery = query.subquery(IdmIdentityRole.class);
        Root<IdmIdentityRole> subRoot = subquery.from(IdmIdentityRole.class);
        subquery.select(subRoot);
        // correlation
        subquery.// correlation
        where(// correlation
        builder.// correlation
        and(builder.equal(subRoot.get(IdmIdentityRole_.identityContract).get(IdmIdentityContract_.identity).get(IdmIdentity_.id), identityId), builder.equal(subRoot.get(IdmIdentityRole_.role), root.get(IdmAuthorizationPolicy_.role))));
        Predicate predicate = builder.exists(subquery);
        // or default role
        UUID defaultRoleId = roleConfiguration.getDefaultRoleId();
        if (defaultRoleId == null) {
            // default role is not defined
            return predicate;
        }
        // find all default role sub roles
        Set<UUID> defaultRoles = Sets.newHashSet(defaultRoleId);
        defaultRoles.addAll(roleCompositionService.findAllSubRoles(defaultRoleId).stream().map(IdmRoleCompositionDto::getSub).collect(Collectors.toSet()));
        return builder.or(predicate, root.get(IdmAuthorizationPolicy_.role).get(IdmRole_.id).in(defaultRoles));
    }
}

```


Overlapping Code:
```
uthorization policy assigned by given identity by assigned or default role.")
public class AuthorizationPolicyByIdentityFilterBuilder extends AbstractFilterBuilder<IdmAuthorizationPolicy, IdmAuthorizationPolicy
private RoleConfiguration roleConfiguration;
@Autowiredivate IdmRoleCompositionService roleCompositionService;
@Autowired
public AuthorizationPolicyByIdentityFilterBuilder(IdmAuthorizationPolicyRepository repository) {
super(repository);
}
@Override
public String getName() {
return IdmAuthorizationPolicyFilter.PARAMETER_IDENTITY_ID;
}
@Override
public Predicate getPredicate(Root<IdmAuthorizationPolicy> root, AbstractQuery<?> query, CriteriaBuilder builder, IdmAuthorizationPolicyFilter filter) {
UUID identityId = filter.getIdentityId();
if (identityId == nu
Subquery<IdmIdentityRole> subquery = query.subquery(IdmIdentityRole.class);
Root<IdmIdentityRole> subRoot = subquery.from(IdmIdentityRole.class);
subquery.select(subRoot);
der.equal(subRoot.get(IdmIdentityRole_.identityContract).get(IdmIdentityContract_.identity).get(IdmIdentity_.Root.get(IdmIdentityRole_.role), root.get(IdmAuthodefault role
UUID defaultRoleId = roleConfiguration.getDefaultRoleId();
if (defaultRoleId == null) {
// default role is not defined
return predicate;
 defaultRoles = Sets.newHashSet(defaultRoleId);
deizationPolicy_.role).get(IdmRole_.id).in(defaultRo
```
<Overlap Ratio: 0.7068335941575378>

---

--- 290 --
Question ID: 6dc842b708c83d823cc7570e2b26a376f97948f7
Original Code:
```
public abstract class VersionableSurveyObject extends IdentifiableSurveyObject<VersionableSurveyObject> {

    private static final long serialVersionUID = 1L;

    private ModelVersion sinceVersion;

    private ModelVersion deprecatedVersion;

    protected VersionableSurveyObject(Survey survey, int id) {
        super(survey, id);
    }

    protected VersionableSurveyObject(Survey survey, VersionableSurveyObject source, int id) {
        super(survey, source, id);
        if (survey == source.getSurvey()) {
            this.sinceVersion = source.sinceVersion;
            this.deprecatedVersion = source.deprecatedVersion;
        }
    }

    public void removeVersioning(ModelVersion version) {
        int versionId = version.getId();
        if (sinceVersion != null && sinceVersion.getId() == versionId) {
            sinceVersion = null;
        }
        if (deprecatedVersion != null && deprecatedVersion.getId() == versionId) {
            deprecatedVersion = null;
        }
    }

    public String getSinceVersionName() {
        return sinceVersion == null ? null : sinceVersion.getName();
    }

    public Integer getSinceVersionId() {
        return sinceVersion == null ? null : sinceVersion.getId();
    }

    public void setSinceVersionByName(String name) {
        this.sinceVersion = name == null ? null : findVersion(name);
    }

    public String getDeprecatedVersionName() {
        return deprecatedVersion == null ? null : deprecatedVersion.getName();
    }

    public Integer getDeprecatedVersionId() {
        return deprecatedVersion == null ? null : deprecatedVersion.getId();
    }

    public void setDeprecatedVersionByName(String name) {
        this.deprecatedVersion = name == null ? null : findVersion(name);
    }

    public ModelVersion getSinceVersion() {
        return this.sinceVersion;
    }

    public void setSinceVersion(ModelVersion since) {
        this.sinceVersion = since;
    }

    public ModelVersion getDeprecatedVersion() {
        return this.deprecatedVersion;
    }

    public void setDeprecatedVersion(ModelVersion deprecated) {
        this.deprecatedVersion = deprecated;
    }

    private ModelVersion findVersion(String name) {
        if (name == null) {
            return null;
        } else {
            Survey survey = getSurvey();
            if (survey == null) {
                throw new IllegalStateException("Survey not set!");
            }
            ModelVersion v = survey.getVersion(name);
            if (v == null) {
                throw new IllegalArgumentException("Undefined version '" + name + "' in " + toString());
            }
            return v;
        }
    }

    @Override
    public boolean deepEquals(Object obj) {
        if (this == obj)
            return true;
        if (!super.deepEquals(obj))
            return false;
        if (getClass() != obj.getClass())
            return false;
        VersionableSurveyObject other = (VersionableSurveyObject) obj;
        if (deprecatedVersion == null) {
            if (other.deprecatedVersion != null)
                return false;
        } else if (!deprecatedVersion.deepEquals(other.deprecatedVersion))
            return false;
        if (sinceVersion == null) {
            if (other.sinceVersion != null)
                return false;
        } else if (!sinceVersion.deepEquals(other.sinceVersion))
            return false;
        return true;
    }
}

```


Overlapping Code:
```
eSurveyObject extends IdentifiableSurveyObject<VersionableSurveyObject> {
private static final long serialVersionUID = 1L;
private ModelVersion sinceVersion;
private ModelVersion deprecatedVersion;
protected VersionableSurveyObject(Survey survey, int id) {
super(survey, id);
}
protected VersionableSurveyObject(Survey survey, VersionableSurveyObject source, int id) {
super(survey, source, id);
if (survey == source.getSurvey()) {
this.sinceVersion = source.sinceVersion;
this.deprecatedVersion = source.deprecatedVersion;
}
}
pubsioning(ModelVersion version) {
int versionId = ve= null;
}
}
public String getSinceVersionName() {
return sinceVersion == null ? null : sinceVersion.ublic Integer getSinceVersionId() {
return sinceVersion == null ? null : sinceVersion.ing name) {
this.sinceVersion = name == null ? null : findVersion(name);
}
public String getDeprecatedVersionName() {
return deprecatedVersion == nullnteger getDeprecatedVersionId() {
return deprecatedVersion == null ? null : deprecatedVersion.getId(g name) {
this.deprecatedVersion = name == null ? null : findVersion(name);
}
public ModelVersion getSinceVersion() {
return this.sinceVersion;
}
public void setSinceVersion(ModelVersion since) {
this.sinceVersion = since;
}
public ModelVersion getDeprecatedVersion() {
return this.deprecatedVersion;
}
public void setDeprecatedVersion(ModelVersion deprecated) {
this.deprecatedVersion = deprecated;
}
private ModelVersion findVersion(String name) {
if (name == null) {
return null;
} else ow new IllegalStateException("Survey not set!");
}
```
<Overlap Ratio: 0.7554585152838428>

---

--- 291 --
Question ID: 27a89c084d6ab746c2199fdd9f7518ada1b9eea9
Original Code:
```
public class ArrayTypeReference extends SingleTypeReference {

    public int dimensions;

    // jsr308 style type annotations on dimensions.
    private Annotation[][] annotationsOnDimensions;

    public int originalSourceEnd;

    public int extendedDimensions;

    /**
     * ArrayTypeReference constructor comment.
     * @param source char[]
     * @param dimensions int
     * @param pos int
     */
    public ArrayTypeReference(char[] source, int dimensions, long pos) {
        super(source, pos);
        this.originalSourceEnd = this.sourceEnd;
        this.dimensions = dimensions;
        this.annotationsOnDimensions = null;
    }

    public ArrayTypeReference(char[] source, int dimensions, Annotation[][] annotationsOnDimensions, long pos) {
        this(source, dimensions, pos);
        if (annotationsOnDimensions != null) {
            this.bits |= ASTNode.HasTypeAnnotations;
        }
        this.annotationsOnDimensions = annotationsOnDimensions;
    }

    public int dimensions() {
        return this.dimensions;
    }

    public int extraDimensions() {
        return this.extendedDimensions;
    }

    /**
     * 	 @see org.eclipse.jdt.internal.compiler.ast.TypeReference#getAnnotationsOnDimensions(boolean)
     */
    public Annotation[][] getAnnotationsOnDimensions(boolean useSourceOrder) {
        if (useSourceOrder || this.annotationsOnDimensions == null || this.annotationsOnDimensions.length == 0 || this.extendedDimensions == 0 || this.extendedDimensions == this.dimensions)
            return this.annotationsOnDimensions;
        Annotation[][] externalAnnotations = new Annotation[this.dimensions][];
        final int baseDimensions = this.dimensions - this.extendedDimensions;
        System.arraycopy(this.annotationsOnDimensions, baseDimensions, externalAnnotations, 0, this.extendedDimensions);
        System.arraycopy(this.annotationsOnDimensions, 0, externalAnnotations, this.extendedDimensions, baseDimensions);
        return externalAnnotations;
    }

    public void setAnnotationsOnDimensions(Annotation[][] annotationsOnDimensions) {
        this.annotationsOnDimensions = annotationsOnDimensions;
    }

    /**
     * @return char[][]
     */
    public char[][] getParameterizedTypeName() {
        int dim = this.dimensions;
        char[] dimChars = new char[dim * 2];
        int i = 0;
        while (i < dim) try {
            int index = i * 2;
            dimChars[index] = '[';
            dimChars[index + 1] = ']';
        } finally {
            i++;
        }
        return new char[][] { CharOperation.concat(this.token, dimChars) };
    }

    protected TypeBinding getTypeBinding(Scope scope) {
        if (this.resolvedType != null) {
            return this.resolvedType;
        }
        if (this.dimensions > 255) {
            scope.problemReporter().tooManyDimensions(this);
        }
        TypeBinding leafComponentType = scope.getType(this.token);
        return scope.createArrayType(leafComponentType, this.dimensions);
    }

    public StringBuffer printExpression(int indent, StringBuffer output) {
        super.printExpression(indent, output);
        if ((this.bits & IsVarArgs) != 0) {
            int i = 0;
            while (i < this.dimensions - 1) try {
                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {
                    output.append(' ');
                    printAnnotations(this.annotationsOnDimensions[i], output);
                    output.append(' ');
                }
                //$NON-NLS-1$
                //$NON-NLS-1$
                //$NON-NLS-1$
                output.append("[]");
            } finally {
                i++;
            }
            if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[this.dimensions - 1] != null) {
                output.append(' ');
                printAnnotations(this.annotationsOnDimensions[this.dimensions - 1], output);
                output.append(' ');
            }
            //$NON-NLS-1$
            output.append("...");
        } else {
            int i = 0;
            while (i < this.dimensions) try {
                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions[i] != null) {
                    //$NON-NLS-1$
                    //$NON-NLS-1$
                    //$NON-NLS-1$
                    output.append(" ");
                    printAnnotations(this.annotationsOnDimensions[i], output);
                    //$NON-NLS-1$
                    //$NON-NLS-1$
                    //$NON-NLS-1$
                    output.append(" ");
                }
                //$NON-NLS-1$
                //$NON-NLS-1$
                //$NON-NLS-1$
                output.append("[]");
            } finally {
                i++;
            }
        }
        return output;
    }

    public void traverse(ASTVisitor visitor, BlockScope scope) {
        if (visitor.visit(this, scope)) {
            if (this.annotations != null) {
                Annotation[] typeAnnotations = this.annotations[0];
                int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length;
                while (i < length) try {
                    typeAnnotations[i].traverse(visitor, scope);
                } finally {
                    i++;
                }
            }
            if (this.annotationsOnDimensions != null) {
                int i = 0, max = this.annotationsOnDimensions.length;
                while (i < max) try {
                    Annotation[] annotations2 = this.annotationsOnDimensions[i];
                    if (annotations2 != null) {
                        int j = 0, max2 = annotations2.length;
                        while (j < max2) try {
                            Annotation annotation = annotations2[j];
                            annotation.traverse(visitor, scope);
                        } finally {
                            j++;
                        }
                    }
                } finally {
                    i++;
                }
            }
        }
        visitor.endVisit(this, scope);
    }

    public void traverse(ASTVisitor visitor, ClassScope scope) {
        if (visitor.visit(this, scope)) {
            if (this.annotations != null) {
                Annotation[] typeAnnotations = this.annotations[0];
                int i = 0, length = typeAnnotations == null ? 0 : typeAnnotations.length;
                while (i < length) try {
                    typeAnnotations[i].traverse(visitor, scope);
                } finally {
                    i++;
                }
            }
            if (this.annotationsOnDimensions != null) {
                int i = 0, max = this.annotationsOnDimensions.length;
                while (i < max) try {
                    Annotation[] annotations2 = this.annotationsOnDimensions[i];
                    if (annotations2 != null) {
                        int j = 0, max2 = annotations2.length;
                        while (j < max2) try {
                            Annotation annotation = annotations2[j];
                            annotation.traverse(visitor, scope);
                        } finally {
                            j++;
                        }
                    }
                } finally {
                    i++;
                }
            }
        }
        visitor.endVisit(this, scope);
    }

    protected TypeBinding internalResolveType(Scope scope, int location) {
        TypeBinding internalResolveType = super.internalResolveType(scope, location);
        return internalResolveType;
    }

    @Override
    public boolean hasNullTypeAnnotation(AnnotationPosition position) {
        switch(position) {
            case LEAF_TYPE:
                // ignore annotationsOnDimensions:
                return super.hasNullTypeAnnotation(position);
            case MAIN_TYPE:
                // outermost dimension only:
                if (this.annotationsOnDimensions != null && this.annotationsOnDimensions.length > 0) {
                    Annotation[] innerAnnotations = this.annotationsOnDimensions[0];
                    return containsNullAnnotation(innerAnnotations);
                }
                break;
            case ANY:
                if (super.hasNullTypeAnnotation(position))
                    return true;
                if (this.resolvedType != null && !this.resolvedType.hasNullTypeAnnotations())
                    // shortcut
                    return false;
                if (this.annotationsOnDimensions != null) {
                    int i = 0;
                    while (i < this.annotationsOnDimensions.length) try {
                        Annotation[] innerAnnotations = this.annotationsOnDimensions[i];
                        if (containsNullAnnotation(innerAnnotations))
                            return true;
                    } finally {
                        i++;
                    }
                }
        }
        return false;
    }
}

```


Overlapping Code:
```
xtends SingleTypeReference {
public int dimensions;
// jsr308 style type annotations on dimensions.
private Annotation[][] annotationsOnDimensions;
public int originalSourceEnd;
public int extendedDimensions;
/**
* ArrayTypeReference constructor comment.
* @param source char[]
* @param dimensions int
* @param pos int
*/
public ArrayTypeReference(char[] source, int dimensions, long pos) {
super(source, pos);
this.originalSourceEnd = this.sourceEnd;
this.dimensions = dimensions;
this.annotationsOnDimensions = null;
}
public ArrayTypeReference(char[] source, int dimensions, Annotation[][] annotationsOnDimensions, long pos) {
this(source, dimensions, pos);
if (annotationsOnDimensions != null) {
this.bits |= ASTNode.HasTypeAnnotations;
}
this.annotationsOnDimensions = annotationsOnDimensions;
}
public int dimensions() {
return this.dimensions;
}
public int extraDimensions() {
return this.extende}
/**
* @see org.eclipse.jdt.internal.compiler.ast.TypeReference#getAnnotationsOnDimensions(boolean)
*/
public Annotation[][] getAnnotationsOnDimensions(boolean useSourceOrder) {
if (useSourceOrder || this.annotationsOnDimensions == null || this.annotationsOnDimensions.length == 0 || this.extendedDimensions == 0 || this.extendedDimensions == this.dimensions)
return this.annotationsOnDimensions;
Annotation[][] externalAnnotations = new Annotation[this.dimensions][];
final int baseDimensions = this.dimensions - this.extendedDimensions;
System.arraycopy(this.annotationsOnDimensions, baseDimensions, externalAnnotations, 0, this.extendedDimensions);
System.arraycopy(this.annotationsOnDimensions, 0, externalAnnotations, this.extendedDimensions, baseDimensions);
return externalAnnotations;
}
public void setAnnotationsOnDimensions(Annotation[][] annotationsOnDimensions) {
this.annotationsOnDimensions = annotationsOnDimensions;
}
/**
* @return char[][]
*/
public char[][] getParameterizedTypeName() {
int dim = this.dimensions;
char[] dimChars = new char[dim * 2]int index = i * 2;
dimChars[index] = '[';
dimChars[index + 1] = ']
```
<Overlap Ratio: 0.9608490566037736>

---

--- 292 --
Question ID: 276f9bf06fd9cdddd7881eec84d2337ed1845efa
Original Code:
```
public abstract class Commands {

    private static final Command ROOT = new RootCommand();

    private static final Command[] SUB = new Command[] { new HelpCommand(), new SplitCommand(), new JoinCommand() };

    public static Command rootCommand() {
        return ROOT;
    }

    public static Command[] subCommands() {
        return SUB;
    }

    public static List<String> names() {
        List<String> n = new ArrayList<String>();
        for (Command c : subCommands()) n.add(c.getName());
        return n;
    }

    public static Command forName(String name) {
        for (Command c : subCommands()) if (name.equals(c.getName()))
            return c;
        return null;
    }

    private Commands() {
    }
}

```


Overlapping Code:
```
c final Command ROOT = new RootCommand();
private  ROOT;
}
public static Command[] subCommands() {
return SUB;
}
public static List<String> names() {
List<String> n;
}
public static Command forName(String name) {
tName()))
return c;
return null;
}
private Command
```
<Overlap Ratio: 0.4332784184514003>

---

--- 293 --
Question ID: 36e36bd6a324cff383b99117320c5b7080ea7be0
Original Code:
```
public class Literals {

    public static void main(String[] args) {
        // int
        var i = 1234;
        // double
        var d1 = 1.;
        var d2 = 1.0;
        var d3 = 1.123456;
        // 5 * 10 ^ 3 == 5000.0
        var d4 = 5e3;
        // boolean
        var b1 = true;
        var b2 = false;
        // char
        var ch1 = 'a';
        var ch2 = '\t';
        var ch3 = '\n';
        // String
        var s1 = "a";
        var s2 = "Hello world";
        //
        int num = 1;
        char ch = '1';
        String s = "1";
    }
}

```


Overlapping Code:
```
public class Literals {
public static void main(String[] args) {
// int
var i = 1234;
// double
var d1 = 1.;
var d2 = 1.0;
vahar
var ch1 = 'a';
var ch2 = '\t';
var ch3 = '\n';
// String
var s1 = "a";
var s2 = "Hello world";
/
```
<Overlap Ratio: 0.6>

---

--- 294 --
Question ID: 80b509f6a9d12338612de5cf8c483f27953d4d54
Original Code:
```
public class PacketClientState implements IMessage, IMessageHandler<PacketClientState, IMessage> {

    private int x;

    private int y;

    private int z;

    private List<IoMode> modes;

    private Channel selectedChannel;

    public PacketClientState() {
    }

    public PacketClientState(TileHyperCube te) {
        x = te.xCoord;
        y = te.yCoord;
        z = te.zCoord;
        modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);
        for (SubChannel sc : SubChannel.values()) {
            modes.add(te.getModeForChannel(sc));
        }
        selectedChannel = te.getChannel();
    }

    @Override
    public void toBytes(ByteBuf buf) {
        buf.writeInt(x);
        buf.writeInt(y);
        buf.writeInt(z);
        if (selectedChannel == null) {
            ByteBufUtils.writeUTF8String(buf, "");
            ByteBufUtils.writeUTF8String(buf, "");
        } else {
            ByteBufUtils.writeUTF8String(buf, selectedChannel.name);
            if (selectedChannel.isPublic()) {
                ByteBufUtils.writeUTF8String(buf, "");
            } else {
                ByteBufUtils.writeUTF8String(buf, selectedChannel.user.toString());
            }
        }
        for (IoMode mode : modes) {
            buf.writeShort(mode.ordinal());
        }
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        x = buf.readInt();
        y = buf.readInt();
        z = buf.readInt();
        String name = ByteBufUtils.readUTF8String(buf);
        String user = ByteBufUtils.readUTF8String(buf);
        selectedChannel = null;
        if (name != null && name.trim().length() > 0) {
            if (user != null && user.trim().length() > 0) {
                selectedChannel = new Channel(name, user);
            } else {
                selectedChannel = new Channel(name, null);
            }
        }
        modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);
        for (SubChannel sc : SubChannel.values()) {
            short ordinal = buf.readShort();
            modes.add(IoMode.values()[ordinal]);
        }
    }

    @Override
    public IMessage onMessage(PacketClientState message, MessageContext ctx) {
        EntityPlayer player = ctx.getServerHandler().playerEntity;
        TileEntity te = player.worldObj.getTileEntity(message.x, message.y, message.z);
        if (te instanceof TileHyperCube) {
            TileHyperCube hc = (TileHyperCube) te;
            SubChannel[] vals = SubChannel.values();
            int i = 0;
            while (i < vals.length) try {
                SubChannel sc = vals[i];
                IoMode mode = message.modes.get(i);
                hc.setModeForChannel(sc, mode);
            } finally {
                i++;
            }
            hc.setChannel(message.selectedChannel);
            player.worldObj.markBlockForUpdate(message.x, message.y, message.z);
        }
        return null;
    }
}

```


Overlapping Code:
```
ublic class PacketClientState implements IMessage, IMessageHandler<PacketClientState, IMessage> {
private int x;
private int y;
private int z;
private List<IoMode> modes;
private Channel selectedChannel;
public PacketClientState() {
}
public PacketClientState(TileHyperCube te) {
x = te.xCoord;
y = te.yCoord;
z = te.zCoord;
modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);
for (SubChannel sc : SubChannel.values()) {
modes.add(te.getModeForChannel(sc));
}
selectedChannel = te.getChannel();
}
@Override
public void toBytes(ByteBuf buf) {
buf.writeInt(x);
buf.writeInt(y);
buf.writeInt(z);
iteUTF8String(buf, "");
ByteBufUtils.writeUTF8String(buf, "");
} else {
ByteBufUtils.writeUTF8String(buf, selectPublic()) {
ByteBufUtils.writeUTF8String(buf, "");
} else {
ByteBufUtils.writeUTF8String(buf, selectedChannel.user.toString());
}
}
for (IoMode mode : modes) {
buf.writeShort(mode.ordinal());
}
}
@Override
public void fromBytes(ByteBuf buf) {
x = buf.readInt();
y = buf.readInt();
z = buf.readInt();
String name = ByteBufUtils.readUTF8String(buf);
String user = ByteBufUtils.readUTF8String(buf);
sele;
if (name != null && name.trim().length() > 0) {
ngth() > 0) {
selectedChannel = new Channel(name, user);
} else {
selectedChannel = new Channel(name, null);
}
}
modes = new ArrayList<TileHyperCube.IoMode>(SubChannel.values().length);
for (SubChannel sc : SubChannel.values()) {
short ordinal = buf.readShort();
modes.add(IoMode.values()[ordinal]);
}
}
@Override
public IMessage onMessage(PacketClientState message, MessageContext ctx) {
EntityPlayer player = ctx.getServerHandler().playerEntity;
TileEntity te = player.worldObj.getTileEntity(message.x, message.y, message.z);
if (te instanceof TileHyperCube) {
TileHyperCube hc = (TileHyperCube) te;
```
<Overlap Ratio: 0.913624678663239>

---

--- 295 --
Question ID: b9f4d52f93a8b27867f96d7d2bf06ba3c97bf302
Original Code:
```
public class ScreenDimmerRack extends ContainerScreen<ContainerDimmerRack> {

    private static final ResourceLocation CRAFTING_TABLE_GUI_TEXTURES = new ResourceLocation(TheatricalMod.MOD_ID, "textures/gui/dimmer_rack.png");

    private final ContainerDimmerRack inventoryPlayer;

    private final TileEntityDimmerRack tileDimmerRack;

    private final List<ISocapexReceiver> receivers;

    private TextFieldWidget dmxStartField;

    private final List<ButtonSocket> sockets;

    private final List<ButtonPlug> plugs;

    private int currentPage = 0;

    private int activePlug = -1;

    public ScreenDimmerRack(ContainerDimmerRack container, PlayerInventory inventory, ITextComponent title) {
        super(container, inventory, title);
        this.inventoryPlayer = container;
        this.tileDimmerRack = container.dimmerRack;
        this.xSize = 250;
        this.ySize = 131;
        sockets = new ArrayList<>();
        plugs = new ArrayList<>();
        receivers = inventoryPlayer.getDevices();
    }

    @Override
    public boolean keyPressed(int p_keyPressed_1_, int p_keyPressed_2_, int p_keyPressed_3_) {
        if (p_keyPressed_1_ == GLFW.GLFW_KEY_E || p_keyPressed_1_ == GLFW.GLFW_KEY_ESCAPE) {
            this.onClose();
            this.getMinecraft().player.closeScreen();
            return true;
        }
        return this.dmxStartField.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_) || this.dmxStartField.canWrite() || super.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_);
    }

    @Override
    public void tick() {
        super.tick();
        generateButtons();
    }

    @Override
    public void resize(Minecraft p_resize_1_, int p_resize_2_, int p_resize_3_) {
        this.init(p_resize_1_, p_resize_2_, p_resize_3_);
    }

    public void generateButtons() {
        this.buttons.removeAll(sockets);
        this.buttons.removeAll(plugs);
        this.children.removeAll(sockets);
        this.children.removeAll(plugs);
        this.plugs.clear();
        this.sockets.clear();
        int width = this.width / 2;
        int height = (this.height - this.ySize) / 2;
        int i = 0;
        while (i < 6) try {
            SocapexPatch[] patch = inventoryPlayer.getPatch(i);
            int x = (width - 95) + 46 * (i < 3 ? i : i - 3);
            int y = height + (i < 3 ? 25 : 70);
            int j = 0;
            while (j < 2) try {
                ButtonSocket buttonSocket;
                if (patch == null || j >= patch.length) {
                    buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, this::handleSocket);
                } else {
                    SocapexPatch patch1 = patch[j];
                    if (patch1 != null && patch1.getReceiver() != null) {
                        String identifier = inventoryPlayer.getIdentifier(patch1.getReceiver()).toUpperCase().substring(0, 1);
                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, patch1, identifier, this::handleSocket);
                    } else {
                        buttonSocket = new ButtonSocket(inventoryPlayer, x, y + (20 * j), i, j == 1, this::handleSocket);
                    }
                }
                this.addButton(buttonSocket);
                sockets.add(buttonSocket);
            } finally {
                j++;
            }
        } finally {
            i++;
        }
        if (receivers.size() > 0) {
            ISocapexReceiver iSocapexReceiver = receivers.get(currentPage);
            inventoryPlayer.getChannelsForReceiver(iSocapexReceiver).ifPresent(channels -> {
                int i = 0;
                while (i < channels.length) try {
                    int x = width + 45 + (20 * (i < 3 ? i : i - 3));
                    int y = height + (i < 3 ? 45 : 65);
                    if (channels[i] != 1) {
                        int finalI = i;
                        ButtonPlug buttonPlug = new ButtonPlug(x, y, i + 1, "", activePlug == i, (button) -> {
                            if (button instanceof ButtonPlug) {
                                ButtonPlug plug = (ButtonPlug) button;
                                if (activePlug == finalI) {
                                    plug.setActive(false);
                                    activePlug = -1;
                                } else {
                                    plug.setActive(true);
                                    activePlug = finalI;
                                }
                            }
                        });
                        this.addButton(buttonPlug);
                        plugs.add(buttonPlug);
                    }
                } finally {
                    i++;
                }
            });
        }
    }

    @Override
    protected void init() {
        super.init();
        int lvt_1_1_ = (this.width - this.xSize) / 2;
        int lvt_2_1_ = (this.height - this.ySize) / 2;
        this.addButton(new Button(lvt_1_1_ + 172, lvt_2_1_ + 5, 15, 20, new StringTextComponent("<"), (button) -> {
            if (currentPage - 1 < 0) {
                currentPage = receivers.size() - 1;
            } else {
                currentPage--;
            }
            activePlug = -1;
            generateButtons();
        }));
        this.addButton(new Button(lvt_1_1_ + 165 + 60, lvt_2_1_ + 5, 15, 20, new StringTextComponent(">"), (button) -> {
            if (currentPage + 1 > receivers.size() - 1) {
                currentPage = 0;
            } else {
                currentPage++;
            }
            activePlug = -1;
            generateButtons();
        }));
        this.dmxStartField = new TextFieldWidget(this.font, lvt_1_1_ + 172, lvt_2_1_ + 100, 50, 10, new StringTextComponent(""));
        if (tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).isPresent()) {
            this.dmxStartField.setText(Integer.toString(tileDimmerRack.getCapability(DMXReceiver.CAP, Direction.SOUTH).orElse(null).getStartPoint()));
        }
        this.dmxStartField.setCanLoseFocus(false);
        this.dmxStartField.changeFocus(true);
        this.dmxStartField.setTextColor(-1);
        this.dmxStartField.setDisabledTextColour(-1);
        this.dmxStartField.setEnableBackgroundDrawing(true);
        this.dmxStartField.setMaxStringLength(35);
        this.dmxStartField.setValidator(s -> {
            if (s.length() == 0) {
                return true;
            }
            try {
                Integer.parseInt(s);
                return true;
            } catch (Exception e) {
                return false;
            }
        });
        this.children.add(this.dmxStartField);
        this.setFocusedDefault(this.dmxStartField);
        generateButtons();
    }

    @Override
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        if (this.dmxStartField.isMouseOver(mouseX, mouseY)) {
            this.dmxStartField.setFocused2(true);
        }
        return super.mouseClicked(mouseX, mouseY, button);
    }

    @Override
    protected void drawGuiContainerBackgroundLayer(MatrixStack matrixStack, float partialTicks, int x, int y) {
        RenderSystem.color4f(1.0F, 1.0F, 1.0F, 1.0F);
        this.getMinecraft().getTextureManager().bindTexture(CRAFTING_TABLE_GUI_TEXTURES);
        int lvt_4_1_ = this.guiLeft;
        int lvt_5_1_ = (this.height - this.ySize) / 2;
        blit(matrixStack, lvt_4_1_, lvt_5_1_, 0, 0, xSize, ySize, 512, 512);
    }

    @Override
    public void render(MatrixStack ms, int p_230430_2_, int p_230430_3_, float p_230430_4_) {
        this.renderBackground(ms);
        super.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);
        RenderSystem.disableBlend();
        this.dmxStartField.render(ms, p_230430_2_, p_230430_3_, p_230430_4_);
        this.renderHoveredTooltip(ms, p_230430_2_, p_230430_3_);
    }

    @Override
    public void onClose() {
        super.onClose();
        TheatricalNetworkHandler.MAIN.sendToServer(new UpdateDMXAddressPacket(this.container.dimmerRack.getPos(), Integer.parseInt(this.dmxStartField.getText())));
    }

    @Override
    protected void drawGuiContainerForegroundLayer(MatrixStack matrixStack, int x, int y) {
        String name = container.dimmerRack.getDisplayName().getString();
        font.drawString(matrixStack, name, 176 / 2 - font.getStringWidth(name) / 2, 6, 0x404040);
        font.drawString(matrixStack, "Plugs", 180 + font.getStringWidth("Plugs") / 2, 6, 0x404040);
        int i = 0;
        while (i < 6) try {
            int x1 = 33 + 46 * (i < 3 ? i : i - 3);
            int y1 = (i < 3 ? 15 : 62);
            font.drawString(matrixStack, "" + (i + 1), x1, y1, 0x000000);
        } finally {
            i++;
        }
        if (receivers.size() > 0) {
            String pageName = "Panel " + inventoryPlayer.getIdentifier(receivers.get(currentPage).getReceiverPos());
            font.drawString(matrixStack, pageName, 150 + font.getStringWidth(pageName) / 2, 30, 0x404040);
        }
        if (activePlug != -1) {
            int width = this.width / 2;
            int height = (this.height - this.ySize) / 2;
            int plugX = width + 45 + (20 * (activePlug < 3 ? activePlug : activePlug - 3));
            int plugY = height + (activePlug < 3 ? 45 : 65);
            int xDist = plugX - x;
            int yDist = plugY - y;
            if (Minecraft.getInstance().currentScreen != null) {
                long distanceSq = xDist * xDist + yDist * yDist;
                int screenDim = Minecraft.getInstance().currentScreen.width * Minecraft.getInstance().currentScreen.height;
                float percentOfDim = Math.min(1, distanceSq / (float) screenDim);
            }
            final int color = 0x13C90A;
            int red = (color >> 16) & 255;
            int green = (color >> 8) & 255;
            int blue = (color) & 255;
            RenderSystem.disableTexture();
            RenderSystem.disableCull();
            RenderSystem.lineWidth(3);
            RenderSystem.color4f(1F, 1F, 1F, 1F);
            Tessellator tessellator = Tessellator.getInstance();
            BufferBuilder bufferBuilder = tessellator.getBuffer();
            bufferBuilder.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);
            bufferBuilder.pos(plugX - guiLeft, plugY - guiTop, 0).color(red, green, blue, 255).endVertex();
            bufferBuilder.pos(x - guiLeft, y - guiTop, 0).color(red, green, blue, 255).endVertex();
            tessellator.draw();
            RenderSystem.enableTexture();
            RenderSystem.enableCull();
        }
    }

    private void handleSocket(Button button) {
        if (button instanceof ButtonSocket) {
            ButtonSocket socket = (ButtonSocket) button;
            int channel = socket.getChannelNumber();
            int socketNumber = socket.isSecondSocket() ? 2 : 1;
            if (activePlug == -1) {
                if (socket.isPatched()) {
                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, new SocapexPatch()));
                    generateButtons();
                }
            } else {
                if (!socket.isPatched()) {
                    SocapexPatch patch1 = new SocapexPatch(receivers.get(currentPage).getReceiverPos(), activePlug);
                    TheatricalNetworkHandler.MAIN.sendToServer(new ChangeDimmerPatchPacket(tileDimmerRack.getPos(), channel, socketNumber, patch1));
                    activePlug = -1;
                    generateButtons();
                }
            }
        }
    }
}

```


Overlapping Code:
```
eenDimmerRack extends ContainerScreen<ContainerDimmerRack> {
private static final ResourceLocation CRAFTING_TABLE_GUI_TEXTURES = new ResourceLocation(TheatricalMod.MOD_ID, "textures/gui/dimmer_rack.png");
private final ContainerDimmerRack inventoryPlayer;
private final TileEntityDimmerRack tileDimmerRack;
private final List<ISocapexReceiver> receivers;
private TextFieldWidget dmxStartField;
private final List<ButtonSocket> sockets;
private final List<ButtonPlug> plugs;
private int currentPage = 0;
private int activePlug = -1;
public ScreenDimmerRack(ContainerDimmerRack container, PlayerInventory inventory, ITextComponent title) {
super(container, inventory, title);
this.inventoryPlayer = container;
this.tileDimmerRack = container.dimmerRack;
this.xSize = 250;
this.ySize = 131;
sockets = new ArrayList<>();
plugs = new ArrayList<>();
receivers = inventoryPlayer.getDevices();
}
@Override
public boolean keyPressed(int p_keyPressed_1_, int p_keyPressed_2_, int p_keyPressed_3_) {
if (p_keyPressed_1_ == GLFW.GLFW_KEY_E || p_keyPressed_1_ == GLFW.GLFW_KEY_ESCAPE) {
this.onClose();
this.getMinecraft().player.closeScreen();
return true;
}
return this.dmxStartField.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_) || this.dmxStartField.canWrite() || super.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_);
}
@Override
public void tick() {
super.tick();
generateButtons();
}
@Override
public void resize(Minecraft p_resize_1_, int p_resize_2_, int p_resize_3_) {
this.init(p_resize_1_, p_resize_2_, p_resize_3_);
}
public void generateButtons() {
this.buttons.removeAll(sockets);
this.buttons.removeAll(plugs);
this.children.removeAll(sockets);
this.children.removeAll(plugs);
this.plugs.clear();
this.sockets.clear();
int width = this.width / 2;
int height = (this.height - this.ySize) / 2;
ch(i);
int x = (width - 95) + 46 * (i < 3 ? i : i 
```
<Overlap Ratio: 0.9010091302258529>

---

--- 296 --
Question ID: 2f69a2cf43dadc045ceb638260afaf3f2210355e
Original Code:
```
public class Recipe_AA_Plating extends ShapelessRecipes implements IRecipe {

    public Recipe_AA_Plating(ItemStack result, List components) {
        super(result, components);
    }

    @Override
    public ItemStack getCraftingResult(InventoryCrafting matrix) {
        ItemStack stack = this.getRecipeOutput().copy();
        ItemStack previousAA = this.getAAFromMatrix(matrix);
        if (// Copying existing properties
        previousAA != null && previousAA.hasTagCompound()) {
            stack.setTagCompound((NBTTagCompound) previousAA.getTagCompound().copy());
        } else // ...or just applying new ones
        {
            stack.setTagCompound(new NBTTagCompound());
        }
        // Apply the new upgrade now
        stack.getTagCompound().setBoolean("hasHeavyPlatingUpgrade", true);
        return stack;
    }

    private ItemStack getAAFromMatrix(InventoryCrafting matrix) {
        int counter = 0;
        for (; counter < matrix.getSizeInventory(); ) {
            if (matrix.getStackInSlot(counter) != null && matrix.getStackInSlot(counter).getItem() instanceof PackedUpAA) {
                // Found it
                return matrix.getStackInSlot(counter);
            }
            counter += 1;
        }
        return null;
    }
}

```


Overlapping Code:
```
r(result, components);
}
@Override
public ItemStack getCraftingResult(InventoryCrafting matrix)emStack stack = this.getRecipeOutput().copy();
ItemStack previousAA = this.getAAFromMatrix(matrix);
tack.setTagCompound((NBTTagCompound) previousAA.getTagCompouing new ones
{
stack.setTagCompound(new NBTTagCompound());
}rix.getStackInSlot(counter) != null && matrix.getStackInSlot(counter).getItem() instanceof PackedUpA
```
<Overlap Ratio: 0.4033041788143829>

---

--- 297 --
Question ID: afdbd11a44ee520634dc2f62fa377a7a4d3f4e36
Original Code:
```
@Entity
@Table(name = "planes")
public class Plane extends Vehicle {

    @Column(name = "passenger_capacity")
    private int passengerCapacity;

    @ManyToOne
    private Company company;

    public Plane() {
    }

    public Plane(String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {
        super(model, price, fuelType);
        this.passengerCapacity = passengerCapacity;
        this.company = company;
    }

    public Plane(Long id, String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {
        super(id, model, price, fuelType);
        this.passengerCapacity = passengerCapacity;
        this.company = company;
    }

    public int getPassengerCapacity() {
        return passengerCapacity;
    }

    public void setPassengerCapacity(int seats) {
        this.passengerCapacity = seats;
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("Plane{");
        sb.append(super.toString());
        sb.append("passengerCapacity=").append(passengerCapacity);
        sb.append('}');
        return sb.toString();
    }
}

```


Overlapping Code:
```
Entity
@Table(name = "planes")
public class Plane extends Vehicle {
@Column(name = "passenger_capacity")
privCapacity;
@ManyToOne
private Company company;
public Plane() {
}
public Plane(String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {
super(model, price, fuelType);
this.passengerCapacity = passengerCapacity;
this.company = company;
}
public Plane(Long id, String model, BigDecimal price, String fuelType, int passengerCapacity, Company company) {
super(id, model, price, fuelType);
this.passengerCapacity = passengerCapacity;
this.company = company;
}
public int getPassengerCapacity() {
return passengerCapacity;
}
public void setPassengerCapacity(int seats) {
this.passengerCapacity = seats;
}
@Override
public String toString() {
final StringBuilder sb = new StringBuilder("Plane{");
sb.append(super.toString());
sb.append("passengerCapacity=").append(passengerCapacity);
sb.append('}');
return sb.toString();
}
}
```
<Overlap Ratio: 0.9816138917262512>

---

--- 298 --
Question ID: e221bba277ec3b7366089248282c8d030b848dd5
Original Code:
```
public class GtidSet {

    private final Map<String, UUIDSet> map = new LinkedHashMap<String, UUIDSet>();

    /**
     * @param gtidSet gtid set comprised of closed intervals (like MySQL's executed_gtid_set).
     */
    public GtidSet(String gtidSet) {
        String[] uuidSets = gtidSet.isEmpty() ? new String[0] : gtidSet.split(",");
        for (String uuidSet : uuidSets) {
            int uuidSeparatorIndex = uuidSet.indexOf(":");
            String sourceId = uuidSet.substring(0, uuidSeparatorIndex);
            List<Interval> intervals = new ArrayList<Interval>();
            String[] rawIntervals = uuidSet.substring(uuidSeparatorIndex + 1).split(":");
            for (String interval : rawIntervals) {
                String[] is = interval.split("-");
                long[] split = new long[is.length];
                for (int i = 0, e = is.length; i < e; i++) {
                    split[i] = Long.parseLong(is[i]);
                }
                if (split.length == 1) {
                    split = new long[] { split[0], split[0] };
                }
                intervals.add(new Interval(split[0], split[1]));
            }
            map.put(sourceId, new UUIDSet(sourceId, intervals));
        }
    }

    public Collection<UUIDSet> getUUIDSets() {
        return map.values();
    }

    /**
     * @param gtid GTID ("source_id:transaction_id")
     * @return whether or not gtid was added to the set (false if it was already there)
     */
    public boolean add(String gtid) {
        String[] split = gtid.split(":");
        String sourceId = split[0];
        long transactionId = Long.parseLong(split[1]);
        UUIDSet uuidSet = map.get(sourceId);
        if (uuidSet == null) {
            map.put(sourceId, uuidSet = new UUIDSet(sourceId, new ArrayList<Interval>()));
        }
        List<Interval> intervals = (List<Interval>) uuidSet.intervals;
        int index = findInterval(intervals, transactionId);
        boolean addedToExisting = false;
        if (index < intervals.size()) {
            Interval interval = intervals.get(index);
            if (interval.start == transactionId + 1) {
                interval.start = transactionId;
                addedToExisting = true;
            } else if (interval.end + 1 == transactionId) {
                interval.end = transactionId;
                addedToExisting = true;
            } else if (interval.start <= transactionId && transactionId <= interval.end) {
                return false;
            }
        }
        if (!addedToExisting) {
            intervals.add(index, new Interval(transactionId, transactionId));
        }
        if (intervals.size() > 1) {
            joinAdjacentIntervals(intervals, index);
        }
        return true;
    }

    /**
     * Collapses intervals like a-(b-1):b-c into a-c (only in index+-1 range).
     */
    private void joinAdjacentIntervals(List<Interval> intervals, int index) {
        for (int i = Math.min(index + 1, intervals.size() - 1), e = Math.max(index - 1, 0); i > e; i--) {
            Interval a = intervals.get(i - 1), b = intervals.get(i);
            if (a.end + 1 == b.start) {
                a.end = b.end;
                intervals.remove(i);
            }
        }
    }

    @Override
    public String toString() {
        List<String> gtids = new ArrayList<String>();
        for (UUIDSet uuidSet : map.values()) {
            gtids.add(uuidSet.getUUID() + ":" + join(uuidSet.intervals, ":"));
        }
        return join(gtids, ",");
    }

    /**
     * @return index which is either a pointer to the interval containing v or a position at which v can be added
     */
    private static int findInterval(List<Interval> ii, long v) {
        int l = 0, p = 0, r = ii.size();
        for (; l < r; ) {
            p = (l + r) / 2;
            Interval i = ii.get(p);
            if (i.end < v) {
                l = p + 1;
            } else if (v < i.start) {
                r = p;
            } else {
                return p;
            }
        }
        if (!ii.isEmpty() && ii.get(p).end < v) {
            p++;
        }
        return p;
    }

    private String join(Collection o, String delimiter) {
        if (o.isEmpty()) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        for (Object o1 : o) {
            sb.append(o1).append(delimiter);
        }
        return sb.substring(0, sb.length() - delimiter.length());
    }

    /**
     * @see GtidSet
     */
    public static final class UUIDSet {

        private String uuid;

        private Collection<Interval> intervals;

        private UUIDSet(String uuid, Collection<Interval> intervals) {
            this.uuid = uuid;
            this.intervals = intervals;
        }

        public String getUUID() {
            return uuid;
        }

        public Collection<Interval> getIntervals() {
            return intervals;
        }
    }

    /**
     * @see GtidSet
     */
    public static final class Interval implements Comparable<Interval> {

        private long start;

        private long end;

        private Interval(long start, long end) {
            this.start = start;
            this.end = end;
        }

        public long getStart() {
            return start;
        }

        public long getEnd() {
            return end;
        }

        @Override
        public String toString() {
            return start + "-" + end;
        }

        @Override
        public int compareTo(Interval o) {
            return saturatedCast(this.start - o.start);
        }

        private static int saturatedCast(long value) {
            if (value > Integer.MAX_VALUE) {
                return Integer.MAX_VALUE;
            }
            if (value < Integer.MIN_VALUE) {
                return Integer.MIN_VALUE;
            }
            return (int) value;
        }
    }
}

```


Overlapping Code:
```
 class GtidSet {
private final Map<String, UUIDSet> map = new LinkedHashMap<String, UUIDSet>();
/**
* @param gtidSet gtid set comprised of closed intervals (like MySQL's executed_gtid_set).
*/
public GtidSet(String gtidSet) {
String[] uuidSets = gtidSet.isEmpty() ? new String[0] : gtidSet.split(",");
for (String uuidSet : uuidSets) {
int uuidSeparatorIndex = uuidSet.indexOf(":");
String sourceId = uuidSet.substring(0, uuidSeparatorIndex);
List<Interval> intervals = new ArrayList<Interval>();
String[] rawIntervals = uuidSet.substring(uuidSeparatorIndex + 1).split(":");
for (String interval : rawIntervals) {
String[] is = interval.split("-");
long[] split = new long[is.length];
for (int i = 0, e = is.length; i < e; i++) {
split[i] = Long.parseLong(is[i]);
}
ilit[0], split[1]));
}
map.put(sourceId, new UUIDSet(sourceId, intervals));
}
}
public Collection<UUIDSet> getUUIDSets() {
return map.values();
}
/**
* @param gtid GTID ("source_id:transaction_id")
* @return whether or not gtid was added to the set (false if it was already there)
*/
public boolean add(String gtid) {
String[] split = gtid.split(":");
String sourceId = split[0];
long transactionId = Long.parseLong(split[1]);
UUIDSet uuidSet = map.get(sourceId);
if (uuidSet == null) {
map.put(sourceId, uuidSet = new UUIDSet(sourceId, new ArrayList<Interval>()));
}
List<Interval> intervals = (List<Interval>) uuidSet.intervals;
int index = findInterval(intervals, transactionId);
boolean addedToExisting = false;
if (index < intervals.size()) {
Interval interval = intervals.get(index);
if (interval.start == transactionId + 1) {
interval.start = tf (interval.end + 1 == transactionId) {
interval.end = transactionId;
addedToExisting = true;
} else(interval.start <= transactionId && transactionId 
```
<Overlap Ratio: 0.9061538461538462>

---

--- 299 --
Question ID: 6b004f72007f03d3e280511f6add5590dab3610a
Original Code:
```
public class Configuration implements Comparable<Configuration> {

    /**
     * Prefix for instructions for the configurator.
     */
    public static final String CONFIGURATOR_PREFIX = ":configurator:";

    /**
     * Prefix for special properties which are not configuration properties.
     */
    public static final String PROP_PREFIX = CONFIGURATOR_PREFIX + "feature-";

    /**
     * This optional configuration property stores the artifact id (mvn id) of the
     * bundle this configuration belongs to.
     */
    public static final String PROP_ARTIFACT_ID = PROP_PREFIX + "service.bundleLocation";

    /**
     * This optional configuration property stores the artifact ids (array) of the
     * features this configuration has been specified.
     * @since 1.6
     */
    public static final String PROP_FEATURE_ORIGINS = PROP_PREFIX + "origins";

    /**
     * The pid or name for factory pids.
     */
    private final String pid;

    /**
     * The ordered properties.
     */
    private final Dictionary<String, Object> properties = Configurations.newConfiguration();

    /**
     * Create a new configuration
     * @param pid The pid
     * @throws IllegalArgumentException If pid is {@code null}
     */
    public Configuration(final String pid) {
        if (pid == null) {
            throw new IllegalArgumentException("pid must not be null");
        }
        this.pid = pid;
    }

    @Override
    public int compareTo(final Configuration o) {
        return this.pid.compareTo(o.pid);
    }

    /**
     * Get the pid.
     *
     * @return The pid
     */
    public String getPid() {
        return this.pid;
    }

    /**
     * Check whether the pid is a factory pid
     *
     * @return {@code true} if it's a factory pid
     * @since 1.3
     */
    public boolean isFactoryConfiguration() {
        return isFactoryConfiguration(this.pid);
    }

    /**
     * Return the factory pid of a pid if it's a factory configuration
     *
     * @return The factory pid or {@code null}.
     * @see #isFactoryConfiguration()
     * @since 1.3
     */
    public String getFactoryPid() {
        return getFactoryPid(this.pid);
    }

    /**
     * Return the name for a factory configuration if it is a factory configuration.
     *
     * @return The name or {@code null}.
     * @see #isFactoryConfiguration()
     * @since 1.3
     */
    public String getName() {
        return getName(this.pid);
    }

    /**
     * Check whether the pid is a factory pid
     *
     * @param pid The pid
     * @return {@code true} if it's a factory pid
     */
    public static boolean isFactoryConfiguration(final String pid) {
        return pid.contains("~");
    }

    /**
     * Return the factory pid of a pid if it's a factory configuration
     *
     * @param pid The pid
     * @return The factory pid or {@code null}.
     * @see #isFactoryConfiguration(String)
     */
    public static String getFactoryPid(final String pid) {
        final int pos = pid.indexOf('~');
        if (pos != -1) {
            return pid.substring(0, pos);
        }
        return null;
    }

    /**
     * Return the name for a factory configuration if it is a factory configuration.
     *
     * @param pid The pid
     * @return The name or {@code null}.
     * @see #isFactoryConfiguration(String)
     */
    public static String getName(final String pid) {
        final int pos = pid.indexOf('~');
        if (pos != -1) {
            return pid.substring(pos + 1);
        }
        return null;
    }

    /**
     * Get all properties of the configuration. This method returns a mutable
     * dictionary which can be mutated to alter the properties for this
     * configuration.
     *
     * @return The properties
     */
    public Dictionary<String, Object> getProperties() {
        return this.properties;
    }

    /**
     * Get the feature origins - if recorded
     *
     * @return A immutable list of feature artifact ids - list might be empty
     * @since 1.6
     * @throws IllegalArgumentException If the stored values are not valid artifact ids
     */
    public List<ArtifactId> getFeatureOrigins() {
        final List<ArtifactId> list = new ArrayList<>();
        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);
        if (origins != null) {
            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);
            for (final String v : values) {
                list.add(ArtifactId.parse(v));
            }
        }
        return Collections.unmodifiableList(list);
    }

    /**
     * Get the feature origins.
     * If no origins are recorded, the provided id is returned.
     *
     * @param self The id of the current feature
     * @return A immutable list of feature artifact ids
     * @since 1.7
     * @throws IllegalArgumentException If the stored values are not valid artifact ids
     */
    public List<ArtifactId> getFeatureOrigins(final ArtifactId self) {
        final List<ArtifactId> list = new ArrayList<>();
        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS);
        if (origins != null) {
            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);
            for (final String v : values) {
                list.add(ArtifactId.parse(v));
            }
        }
        if (list.isEmpty()) {
            list.add(self);
        }
        return Collections.unmodifiableList(list);
    }

    /**
     * Set the feature origins
     * @param featureOrigins the list of artifact ids or null to remove the info from this object
     * @since 1.6
     */
    public void setFeatureOrigins(final List<ArtifactId> featureOrigins) {
        if (featureOrigins == null || featureOrigins.isEmpty()) {
            this.properties.remove(PROP_FEATURE_ORIGINS);
        } else {
            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());
            final String[] values = Converters.standardConverter().convert(list).to(String[].class);
            this.properties.put(PROP_FEATURE_ORIGINS, values);
        }
    }

    /**
     * Get the feature origins for a property - if recorded
     *
     * @param propertyName The name of the property
     * @return A immutable list of feature artifact ids - list might be empty
     * @since 1.8
     * @throws IllegalArgumentException If the stored values are not valid artifact ids
     */
    public List<ArtifactId> getFeatureOrigins(final String propertyName) {
        final List<ArtifactId> list = new ArrayList<>();
        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat("-").concat(propertyName));
        if (origins != null) {
            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);
            for (final String v : values) {
                list.add(ArtifactId.parse(v));
            }
        }
        return Collections.unmodifiableList(list);
    }

    /**
     * Get the feature origins for a property.
     * If no origins are recorded, the provided id is returned.
     *
     * @param propertyName The name of the property
     * @param self The id of the current feature
     * @return A immutable list of feature artifact ids
     * @since 1.8
     * @throws IllegalArgumentException If the stored values are not valid artifact ids
     */
    public List<ArtifactId> getFeatureOrigins(final String propertyName, final ArtifactId self) {
        final List<ArtifactId> list = new ArrayList<>();
        final Object origins = this.properties.get(PROP_FEATURE_ORIGINS.concat("-").concat(propertyName));
        if (origins != null) {
            final String[] values = Converters.standardConverter().convert(origins).to(String[].class);
            for (final String v : values) {
                list.add(ArtifactId.parse(v));
            }
        }
        if (list.isEmpty()) {
            list.add(self);
        }
        return Collections.unmodifiableList(list);
    }

    /**
     * Set the feature origins for a property
     * @param propertyName The name of the property
     * @param featureOrigins the list of artifact ids or null to remove the info from this object
     * @since 1.8
     */
    public void setFeatureOrigins(final String propertyName, final List<ArtifactId> featureOrigins) {
        if (featureOrigins == null || featureOrigins.isEmpty()) {
            this.properties.remove(PROP_FEATURE_ORIGINS.concat("-").concat(propertyName));
        } else {
            final List<String> list = featureOrigins.stream().map(ArtifactId::toMvnId).collect(Collectors.toList());
            final String[] values = Converters.standardConverter().convert(list).to(String[].class);
            this.properties.put(PROP_FEATURE_ORIGINS.concat("-").concat(propertyName), values);
        }
    }

    /**
     * Get the configuration properties of the configuration. This configuration
     * properties are all properties minus properties used to manage the
     * configuration. Managing properties have to start with
     * {@code #CONFIGURATOR_PREFIX}. The returned copy is a mutable dictionary which
     * represents a snapshot of the properties at the time this method is called.
     *
     * @return The configuration properties
     */
    public Dictionary<String, Object> getConfigurationProperties() {
        final Dictionary<String, Object> p = new Hashtable<>();
        final Enumeration<String> keys = this.properties.keys();
        for (; keys.hasMoreElements(); ) {
            final String key = keys.nextElement();
            if (!key.startsWith(CONFIGURATOR_PREFIX)) {
                p.put(key, this.properties.get(key));
            }
        }
        return p;
    }

    /**
     * Create a copy of the configuration with a provided PID.
     *
     * @param aPid The pid of the configuration
     * @return A copy of this configuration with the given PID
     */
    public Configuration copy(final String aPid) {
        final Configuration result = new Configuration(aPid);
        final Enumeration<String> keyEnum = this.getProperties().keys();
        for (; keyEnum.hasMoreElements(); ) {
            final String key = keyEnum.nextElement();
            result.getProperties().put(key, this.getProperties().get(key));
        }
        return result;
    }

    @Override
    public String toString() {
        return "Configuration [pid=" + pid + ", properties=" + properties + "]";
    }
}

```


Overlapping Code:
```
ublic class Configuration implements Comparable<Configuration> {
/**
* Prefix for instructions for the configurator.
*/
public static final String CONFIGURATOR_PREFIX = ":configurator:";
/**
* Prefix for special properties which are not configuration properties.
*/
public static final String PROP_PREFIX = CONFIGURATOR_PREFIX + "feature-";
/**
* This optional configuration property stores the artifact id (mvn id) of the
* bundle this configuration belongs to.
*/
public static final String PROP_ARTIFACT_ID = PROP_PREFIX + "service.bundleLocation";
/**
* This optional configuration property stores the artifact ids (array) of the
* features this configuration has been specified.
* @since 1.6
*/
public static final String PROP_FEATUREprivate final Dictionary<String, Object> properties = Configurations.newConfiguration();
/**
* Create a new configuration
* @param pid The pid
* @throws IllegalArgumentException If pid is {@code null}
*/
public Configur (pid == null) {
throw new IllegalArgumentException("pid must not be null");
}
this.pid = pid;
}
@Override
public int compareTo(final Configuration o) {
return this.pid.compareTo(o.pid);
}
/**
* Get the pid.
*
* @return The pid
*/
public String getPid() {
return this.pid;
}
/**
* Check whether the pid is a factory pid
*
* @return {@code true} if it's a factory pid
* @since 1.3
*/
public boolean isFactoryConfiguration() {
return isFactoryConfiguration(this.pid);
}
/**
* Return the factory pid of a pid if it's a factory configuration
*
* @return The factory pid or {@code null}.
* @see #isFactoryConfiguration()
* @since 1.3
*/
public String getFactoryPid() {
return getFactoryPid(this.pid);
}
/**
* Return the name for a factory configuration if it is a factory configuration.
*
* @return The name or {@code null}.
* @see #isFactoryConfiguration()
* @since 1.3
*/
public String getName() {
return getName(this.pi
```
<Overlap Ratio: 0.9014423076923077>

---

--- 300 --
Question ID: fb95d0d1f84c992bbf15971afd687b13538188f4
Original Code:
```
public abstract class AbstractCrawlerService {

    private static final Logger logger = LoggerFactory.getLogger(AbstractCrawlerService.class);

    private static final String ID_SEPARATOR = ".";

    private static final Charset UTF_8 = Charset.forName("UTF-8");

    protected static final String ID = "id";

    protected static final String SESSION_ID = "sessionId";

    protected static final String URL = "url";

    protected static final String LAST_MODIFIED = "lastModified";

    protected static final String CREATE_TIME = "createTime";

    protected static final String _DOC = "_doc";

    protected static final String[] timestampFields = { LAST_MODIFIED, CREATE_TIME };

    protected static final HashFunction murmur3Hash = Hashing.murmur3_128(0);

    @Resource
    protected volatile FesenClient fesenClient;

    protected String index;

    protected int scrollTimeout = 60000;

    protected int scrollSize = 100;

    protected int bulkBufferSize = 10;

    protected int numberOfShards = 5;

    protected int numberOfReplicas = 1;

    protected int idPrefixLength = 445;

    protected FesenClient getClient() {
        if (!fesenClient.connected()) {
            synchronized (fesenClient) {
                if (!fesenClient.connected()) {
                    fesenClient.connect();
                }
            }
        }
        return fesenClient;
    }

    protected void createMapping(final String mappingName) {
        boolean exists = false;
        try {
            final IndicesExistsResponse response = fesenClient.get(c -> c.admin().indices().prepareExists(index).execute());
            exists = response.isExists();
        } catch (final IndexNotFoundException e) {
        }
        if (!exists) {
            final CreateIndexResponse indexResponse = fesenClient.get(c -> {
                final String source;
                if (numberOfReplicas > 0) {
                    source = "{\"settings\":{\"index\":{\"number_of_shards\":" + numberOfShards + ",\"number_of_replicas\":0,\"auto_expand_replicas\":\"0-" + numberOfReplicas + "\"}}}";
                } else {
                    source = "{\"settings\":{\"index\":{\"number_of_shards\":" + numberOfShards + ",\"number_of_replicas\":" + numberOfReplicas + "}}}";
                }
                return c.admin().indices().prepareCreate(index).setSource(source, XContentType.JSON).execute();
            });
            if (indexResponse.isAcknowledged()) {
                logger.info("Created {} index.", index);
            } else if (logger.isDebugEnabled()) {
                logger.debug("Failed to create {} index.", index);
            }
        }
        final GetMappingsResponse getMappingsResponse = fesenClient.get(c -> c.admin().indices().prepareGetMappings(index).execute());
        final ImmutableOpenMap<String, MappingMetadata> indexMappings = getMappingsResponse.mappings().get(index);
        if (indexMappings == null || !indexMappings.containsKey("properties")) {
            final AcknowledgedResponse putMappingResponse = fesenClient.get(c -> {
                final String source = FileUtil.readText("mapping/" + mappingName + ".json");
                return c.admin().indices().preparePutMapping(index).setSource(source, XContentType.JSON).execute();
            });
            if (putMappingResponse.isAcknowledged()) {
                logger.info("Created {} mapping.", index);
            } else {
                logger.warn("Failed to create {} mapping.", index);
            }
        } else if (logger.isDebugEnabled()) {
            logger.debug("{} mapping exists.", index);
        }
    }

    protected Date getDateFromSource(final Map<String, Object> sourceMap, final String name) {
        final Object obj = sourceMap.get(name);
        if (obj instanceof Date) {
            return (Date) obj;
        }
        if (obj instanceof Number) {
            return new Date(((Number) obj).longValue());
        }
        if (obj instanceof String) {
            final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
            sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
            try {
                return sdf.parse(obj.toString());
            } catch (final ParseException e) {
                if (logger.isDebugEnabled()) {
                    logger.debug("Failed to parse {}", obj, e);
                }
            }
        }
        return null;
    }

    protected XContentBuilder getXContentBuilder(final Object target) {
        try {
            final XContentBuilder builder = jsonBuilder().value(target);
            builder.flush();
            return builder;
        } catch (final IOException e) {
            throw new EsAccessException("Failed to convert " + target + " to JSON.", e);
        }
    }

    protected RefreshResponse refresh() {
        try {
            return getClient().get(c -> c.admin().indices().prepareRefresh(index).execute());
        } catch (final Exception e) {
            throw new EsAccessException("Failed to refresh.", e);
        }
    }

    protected IndexResponse insert(final Object target, final OpType opType) {
        final String url = getUrl(target);
        if (url == null) {
            throw new EsAccessException("url is null.");
        }
        final String id = getId(getSessionId(target), url);
        try (final XContentBuilder source = getXContentBuilder(target)) {
            final IndexResponse response = getClient().get(c -> c.prepareIndex().setIndex(index).setId(id).setSource(source).setOpType(opType).setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute());
            setId(target, id);
            return response;
        } catch (final Exception e) {
            throw new EsAccessException("Failed to insert " + id, e);
        }
    }

    protected <T> void insertAll(final List<T> list, final OpType opType) {
        insertAll(list, opType, false);
    }

    protected <T> void insertAll(final List<T> list, final OpType opType, final boolean ignoreAlreadyExists) {
        final List<T> bufferedList = new ArrayList<>(bulkBufferSize);
        final StringBuilder failureBuf = new StringBuilder(100);
        list.stream().forEach(target -> {
            bufferedList.add(target);
            if (bufferedList.size() >= bulkBufferSize) {
                final BulkResponse response = doInsertAll(bufferedList, opType);
                if (response.hasFailures()) {
                    final String failureMessage = buildFailureMessage(response, ignoreAlreadyExists);
                    if (failureMessage.length() > 0) {
                        failureBuf.append(response.buildFailureMessage()).append('\n');
                    }
                }
                bufferedList.clear();
            }
        });
        if (!bufferedList.isEmpty()) {
            final BulkResponse response = doInsertAll(bufferedList, opType);
            if (response.hasFailures()) {
                final String failureMessage = buildFailureMessage(response, ignoreAlreadyExists);
                if (failureMessage.length() > 0) {
                    failureBuf.append(response.buildFailureMessage()).append('\n');
                }
            }
        }
        if (failureBuf.length() > 0) {
            throw new EsAccessException(failureBuf.toString());
        }
    }

    protected String buildFailureMessage(final BulkResponse bulkResponse, final boolean ignoreAlreadyExists) {
        final StringBuilder sb = new StringBuilder(100);
        final BulkItemResponse[] responses = bulkResponse.getItems();
        int i = 0;
        while (i < responses.length) try {
            final BulkItemResponse response = responses[i];
            if (response.isFailed()) {
                if (ignoreAlreadyExists) {
                    continue;
                }
                sb.append("\n[").append(i).append("]: index [").append(response.getIndex()).append("], type [").append(response.getType()).append("], id [").append(response.getId()).append("], message [").append(response.getFailureMessage()).append("]");
            }
        } finally {
            i++;
        }
        if (sb.length() > 0) {
            return "failure in bulk execution:" + sb.toString();
        }
        return StringUtil.EMPTY;
    }

    protected <T> BulkResponse doInsertAll(final List<T> list, final OpType opType) {
        try {
            return getClient().get(c -> {
                final BulkRequestBuilder bulkRequest = c.prepareBulk();
                for (final T target : list) {
                    final String id = getId(getSessionId(target), getUrl(target));
                    try (final XContentBuilder source = getXContentBuilder(target)) {
                        bulkRequest.add(c.prepareIndex().setIndex(index).setId(id).setSource(source).setOpType(opType));
                    }
                    setId(target, id);
                }
                return bulkRequest.setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute();
            });
        } catch (final Exception e) {
            throw new EsAccessException("Failed to insert " + list, e);
        }
    }

    protected boolean exists(final String sessionId, final String url) {
        final String id = getId(sessionId, url);
        try {
            final GetResponse response = getClient().get(c -> c.prepareGet(index, null, id).execute());
            return response.isExists();
        } catch (final Exception e) {
            throw new EsAccessException("Failed to check if " + sessionId + ":" + url + " exists.", e);
        }
    }

    public int getCount(final Consumer<SearchRequestBuilder> callback) {
        return (int) getClient().get(c -> {
            final SearchRequestBuilder builder = c.prepareSearch(index).setSize(0).setTrackTotalHits(true);
            callback.accept(builder);
            return builder.execute();
        }).getHits().getTotalHits().value;
    }

    protected <T> T get(final Class<T> clazz, final String sessionId, final String url) {
        final String id = getId(sessionId, url);
        final GetResponse response = getClient().get(c -> c.prepareGet().setIndex(index).setId(id).execute());
        if (response.isExists()) {
            final Map<String, Object> source = response.getSource();
            final T bean = BeanUtil.copyMapToNewBean(source, clazz, option -> {
                option.converter(new EsTimestampConverter(), timestampFields).excludeWhitespace();
                option.exclude(EsAccessResult.ACCESS_RESULT_DATA);
            });
            @SuppressWarnings("unchecked")
            final Map<String, Object> data = (Map<String, Object>) source.get(EsAccessResult.ACCESS_RESULT_DATA);
            if (data != null) {
                ((EsAccessResult) bean).setAccessResultData(new EsAccessResultData(data));
            }
            setId(bean, id);
            return bean;
        }
        return null;
    }

    protected <T> List<T> getList(final Class<T> clazz, final String sessionId, final QueryBuilder queryBuilder, final Integer from, final Integer size, final SortBuilder<?> sortBuilder) {
        return getList(clazz, builder -> {
            if (StringUtil.isNotBlank(sessionId)) {
                if (queryBuilder instanceof BoolQueryBuilder) {
                    ((BoolQueryBuilder) queryBuilder).filter(QueryBuilders.termQuery(SESSION_ID, sessionId));
                } else {
                    final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery().filter(QueryBuilders.termQuery(SESSION_ID, sessionId));
                    if (queryBuilder != null) {
                        boolQuery.must(queryBuilder);
                    }
                    builder.setQuery(boolQuery);
                }
            } else if (queryBuilder != null) {
                builder.setQuery(queryBuilder);
            } else {
                builder.setQuery(QueryBuilders.matchAllQuery());
            }
            if (sortBuilder != null) {
                builder.addSort(sortBuilder);
            }
            if (from != null) {
                builder.setFrom(from);
            }
            if (size != null) {
                builder.setSize(size);
            }
        });
    }

    protected <T> List<T> getList(final Class<T> clazz, final Consumer<SearchRequestBuilder> callback) {
        final SearchResponse response = getClient().get(c -> {
            final SearchRequestBuilder builder = c.prepareSearch(index);
            callback.accept(builder);
            return builder.execute();
        });
        final EsResultList<T> targetList = new EsResultList<>();
        final SearchHits hits = response.getHits();
        targetList.setTotalHits(hits.getTotalHits().value);
        targetList.setTookInMillis(response.getTook().getMillis());
        if (hits.getTotalHits().value != 0) {
            try {
                for (final SearchHit searchHit : hits.getHits()) {
                    final Map<String, Object> source = searchHit.getSourceAsMap();
                    final T target = BeanUtil.copyMapToNewBean(source, clazz, option -> {
                        option.converter(new EsTimestampConverter(), timestampFields).excludeWhitespace();
                        option.exclude(EsAccessResult.ACCESS_RESULT_DATA);
                    });
                    @SuppressWarnings("unchecked")
                    final Map<String, Object> data = (Map<String, Object>) source.get(EsAccessResult.ACCESS_RESULT_DATA);
                    if (data != null) {
                        ((EsAccessResult) target).setAccessResultData(new EsAccessResultData(data));
                    }
                    setId(target, searchHit.getId());
                    targetList.add(target);
                }
            } catch (final Exception e) {
                throw new EsAccessException("response: " + response, e);
            }
        }
        return targetList;
    }

    protected boolean delete(final String sessionId, final String url) {
        final String id = getId(sessionId, url);
        try {
            final DeleteResponse response = getClient().get(c -> c.prepareDelete().setIndex(index).setId(id).setRefreshPolicy(RefreshPolicy.IMMEDIATE).execute());
            return response.getResult() == Result.DELETED;
        } catch (final Exception e) {
            throw new EsAccessException("Failed to delete " + sessionId + ":" + url, e);
        }
    }

    protected void deleteBySessionId(final String sessionId) {
        delete(builder -> builder.setQuery(QueryBuilders.termQuery(SESSION_ID, sessionId)));
    }

    public void deleteAll() {
        delete(builder -> builder.setQuery(QueryBuilders.matchAllQuery()));
    }

    public void delete(final Consumer<SearchRequestBuilder> callback) {
        SearchResponse response = getClient().get(c -> {
            final SearchRequestBuilder builder = c.prepareSearch(index).setScroll(new TimeValue(scrollTimeout)).setSize(scrollSize);
            callback.accept(builder);
            return builder.execute();
        });
        String scrollId = response.getScrollId();
        try {
            while (scrollId != null) {
                final SearchHits searchHits = response.getHits();
                if (searchHits.getHits().length == 0) {
                    break;
                }
                final BulkResponse bulkResponse = getClient().get(c -> {
                    final BulkRequestBuilder bulkBuilder = c.prepareBulk();
                    for (final SearchHit searchHit : searchHits) {
                        bulkBuilder.add(c.prepareDelete().setIndex(index).setId(searchHit.getId()));
                    }
                    return bulkBuilder.execute();
                });
                if (bulkResponse.hasFailures()) {
                    throw new EsAccessException(bulkResponse.buildFailureMessage());
                }
                final String sid = scrollId;
                response = getClient().get(c -> c.prepareSearchScroll(sid).setScroll(new TimeValue(scrollTimeout)).execute());
                if (!scrollId.equals(response.getScrollId())) {
                    getClient().clearScroll(scrollId);
                }
                scrollId = response.getScrollId();
            }
        } finally {
            getClient().clearScroll(scrollId);
        }
        refresh();
    }

    private String getId(final String sessionId, final String url) {
        final String id = sessionId + ID_SEPARATOR + new String(Base64.getUrlEncoder().withoutPadding().encode(url.getBytes(UTF_8)), UTF_8);
        if (id.length() <= idPrefixLength) {
            return id;
        }
        return id.substring(0, idPrefixLength) + MessageDigestUtil.digest("SHA-256", id.substring(idPrefixLength));
    }

    private String getUrl(final Object target) {
        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());
        final PropertyDesc sessionIdProp = beanDesc.getPropertyDesc(URL);
        final Object sessionId = sessionIdProp.getValue(target);
        return sessionId == null ? null : sessionId.toString();
    }

    private String getSessionId(final Object target) {
        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());
        final PropertyDesc sessionIdProp = beanDesc.getPropertyDesc(SESSION_ID);
        final Object sessionId = sessionIdProp.getValue(target);
        return sessionId == null ? null : sessionId.toString();
    }

    protected void setId(final Object target, final String id) {
        final BeanDesc beanDesc = BeanDescFactory.getBeanDesc(target.getClass());
        final PropertyDesc idProp = beanDesc.getPropertyDesc(ID);
        idProp.setValue(target, id);
    }

    public String getIndex() {
        return index;
    }

    public void setIndex(final String index) {
        this.index = index;
    }

    public int getScrollTimeout() {
        return scrollTimeout;
    }

    public void setScrollTimeout(final int scrollTimeout) {
        this.scrollTimeout = scrollTimeout;
    }

    public int getScrollSize() {
        return scrollSize;
    }

    public void setScrollSize(final int scrollSize) {
        this.scrollSize = scrollSize;
    }

    protected static class EsTimestampConverter implements Converter {

        public static final DateTimeFormatter DEFAULT_DATE_PRINTER = ISODateTimeFormat.dateTime().withZone(DateTimeZone.UTC);

        @Override
        public String getAsString(final Object value) {
            if (value instanceof Date) {
                return DEFAULT_DATE_PRINTER.print(((Date) value).getTime());
            }
            return null;
        }

        @Override
        public Object getAsObject(final String value) {
            if (StringUtil.isEmpty(value)) {
                return null;
            }
            return new Timestamp(DEFAULT_DATE_PRINTER.parseMillis(value));
        }

        @Override
        public boolean isTarget(@SuppressWarnings("rawtypes") final Class clazz) {
            return clazz == Date.class;
        }
    }

    public int getBulkBufferSize() {
        return bulkBufferSize;
    }

    public void setBulkBufferSize(final int bulkBufferSize) {
        this.bulkBufferSize = bulkBufferSize;
    }

    public void setNumberOfShards(final int numberOfShards) {
        this.numberOfShards = numberOfShards;
    }

    public void setNumberOfReplicas(final int numberOfReplicas) {
        this.numberOfReplicas = numberOfReplicas;
    }

    public void setIdPrefixLength(final int idPrefixLength) {
        this.idPrefixLength = idPrefixLength;
    }
}

```


Overlapping Code:
```
lerService {
private static final Logger logger = LoggerFactory.getLogger(AbstractCrawlerService.class);
private static final String ID_SEPARATOR = ".";
private static final Charset UTF_8 = Charset.forName("UTF-8");
protected static final String ID = "id";
protected static final String SESSION_ID = "sessionId";
protected static final String URL = "url";
protected static final String LAST_MODIFIED = "lastModified";
protected static final String CREATE_TIME = "createTime";
protected static final String _DOC = "_doc";
protected static final String[] timestampFields = { LAST_MODIFIED, CREATE_TIME };
protected static final HashFunction murmur3Hash = Hashing.murmur3_128(0);
@Resource
protected volatile FesenClient fesenClient;
protected String index;
protected int scrollTimeout = 60000;
protected int scrollSize = 100;
protected int bulkBufferSize = 10;
protected int numberOfShards = 5;
protected int numberOfReplicas = 1;
protected int idPrefixLength = 445;
protected FesenClient getClient() {
if (!fesenClient.connected()) {
synchronized (fesenClient) {
if (!fesenClient.connected()) {
fesenClient.connect();
}
}
}
return fesenClient;
}
protected void createMapping(final String mappingName) {
boolean exists = false;
try {
final IndicesExistsResponse response = fesenClient.get(c -> c.admin().indices().prepareExists(index).execute());
exists = response.isExists();
} catch (final IndexNotFoundExteIndexResponse indexResponse = fesenClient.get(c -> {
final String source;
if (numberOfReplicas > 0) {
source = "{\"settings\":{\"index\":{\"number_of_shards\":" + numberOfShicas\":0,\"auto_expand_replicas\":\"0-" + numberOfReplicas + "\"}}}";
} else {
source = "{\"settings\":{\"index\":{\"number_of_shards\":" + numberOfShas + "}}}";
}
return c.admin().indices().prepareCreate(index).setSource(source, XContentType.JSON).execute();
});
if (indexResponse.isAcknowledged()) {
logger.inf
```
<Overlap Ratio: 0.9229268292682927>

---

--- 301 --
Question ID: 3f156fc483ff7ed9a55cefd3b01cbbcdd2d04d3a
Original Code:
```
@RestController
@RequestMapping("/passwordSecurityPolicy")
@Extension
@Tag(name = "passwordSecurityPolicy")
@ProtectedREST
@OperationsInside
public class PasswordSecurityPolicyController implements Plugin {

    @Autowired
    private PasswordSecurityPolicyService passwordSecurityPolicyService;

    @PostMapping("/create")
    @Operation(description = "creates Security Policy", summary = "creates Security Policy")
    public PasswordSecurityPolicy create(@RequestHeader(value = "authenticationKey", required = false) String key, @RequestBody PasswordSecurityPolicyCreate securityPolicyCreate, @RequestAttribute SecurityContextBase securityContext) {
        passwordSecurityPolicyService.validate(securityPolicyCreate, securityContext);
        return passwordSecurityPolicyService.createSecurityPolicy(securityPolicyCreate, securityContext);
    }

    @PostMapping("/getAll")
    @Operation(description = "returns Security Policies", summary = "returns Security Policies")
    public PaginationResponse<PasswordSecurityPolicy> getAll(@RequestHeader(value = "authenticationKey", required = false) String key, @RequestBody PasswordSecurityPolicyFilter securityPolicyFilter, @RequestAttribute SecurityContextBase securityContext) {
        passwordSecurityPolicyService.validate(securityPolicyFilter, securityContext);
        return passwordSecurityPolicyService.getAllSecurityPolicies(securityPolicyFilter, securityContext);
    }

    @PutMapping("/update")
    @Operation(description = "updates Security Policies", summary = "updates Security Policies")
    public PasswordSecurityPolicy update(@RequestHeader(value = "authenticationKey", required = false) String key, @RequestBody PasswordSecurityPolicyUpdate securityPolicyUpdate, @RequestAttribute SecurityContextBase securityContext) {
        String id = securityPolicyUpdate.getId();
        PasswordSecurityPolicy passwordSecurityPolicy = id != null ? passwordSecurityPolicyService.getSecurityPolicyByIdOrNull(id, PasswordSecurityPolicy.class, securityContext) : null;
        if (passwordSecurityPolicy == null) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "no PasswordSecurityPolicy user with id " + id);
        }
        securityPolicyUpdate.setPasswordSecurityPolicy(passwordSecurityPolicy);
        passwordSecurityPolicyService.validate(securityPolicyUpdate, securityContext);
        return passwordSecurityPolicyService.updateSecurityPolicy(securityPolicyUpdate, securityContext);
    }
}

```


Overlapping Code:
```
ontroller
@RequestMapping("/passwordSecurityPolicy")
@Extension
@Tag(name = "passwordSecurityPolicy")
@ProtectedREST
@OperationsInside
public class PasswordSecurityPolicyController implements Plugin {
@Autowired
private PasswordSecurityPolicyService passwordSecurityPolicyService;
@PostMapping("/create")
@Operation(description = "creates Security PoPasswordSecurityPolicy create(@RequestHeader(value, @RequestBody PasswordSecurityPolicyCreate securityPolicyCreate, @RequestAttribute SecurityContextBase securityContextreturn passwordSecurityPolicyService.createSecurit@PostMapping("/getAll")
@Operation(description = "rity Policies")
public PaginationResponse<PasswordSecurityPolicy> getAll(@RequestHeader(value = "authenttBody PasswordSecurityPolicyFilter securityPolicyFilter, @RequestAttribute SecurityContextBase securityContextsswordSecurityPolicyService.getAllSecurityPolicies(securityPolicying("/update")
@Operation(description = "updates Security Policiecies")
public PasswordSecurityPolicy update(@RequeUpdate securityPolicyUpdate, @RequestAttribute SecurityContextBase securityContext) {
StrinityPolicyUpdate.getId();
PasswordSecurityPolicy pa == null) {
throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "date.setPasswordSecurityPolicy(passwordSecurityPolicy);
passwordSecurityPolicyService.validate(securecurityPolicyService.updateSecurityPolicy(securityPolicyUpdate,
```
<Overlap Ratio: 0.5962199312714777>

---

--- 302 --
Question ID: e4df3fd07315c7a35d07ed02243925bb9e0e5835
Original Code:
```
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = TestWebContextLoader.class, locations = { "classpath:test-webmvc-config.xml" })
public class ReportResourceTest {

    @Autowired
    protected WebApplicationContext webApplicationContext;

    private MockMvc mockMvc;

    protected ObjectMapper mapper = new ObjectMapper();

    private final String BASE_URL = "/rest/report/";

    private final String expectedReport = "{\n" + "\t\"reports\": \"[{\\\"baseEntityId\\\":\\\"22\\\",\\\"locationId\\\":\\\"testLocationId\\\",\\\"reportType\\\":\\\"testReportType\\\",\\\"formSubmissionId\\\":\\\"testFormSubmissionId\\\",\\\"providerId\\\":\\\"testProviderId\\\",\\\"status\\\":\\\"test\\\"}]\"\n" + "}";

    private final String INVALID_JSON = "{\n" + "\t\"reports\": {\n" + "\t\t\"baseEntityId\": \"22\",\n" + "\t\t\"locationId\": \"testLocationId\",\n" + "\t\t\"reportType\": \"testReportType\",\n" + "\t\t\"formSubmissionId\": \"testFormSubmissionId\",\n" + "\t\t\"providerId\": \"testProviderId\",\n" + "\t\t\"status\": \"test\"\n" + "\t}\n" + "}";

    @InjectMocks
    private ReportResource reportResource;

    @Mock
    private ReportService reportService;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        mockMvc = org.springframework.test.web.servlet.setup.MockMvcBuilders.standaloneSetup(reportResource).addFilter(new CrossSiteScriptingPreventionFilter(), "/*").build();
    }

    @Test
    public void testSaveWithException() throws Exception {
        MvcResult result = mockMvc.perform(post(BASE_URL + "/add").content("".getBytes())).andExpect(status().isBadRequest()).andReturn();
    }

    @Test
    public void testSave() throws Exception {
        when(reportService.addorUpdateReport(any(Report.class))).thenReturn(createReport());
        MvcResult result = mockMvc.perform(post(BASE_URL + "/add").content(expectedReport.getBytes())).andExpect(status().isCreated()).andReturn();
        String responseString = result.getResponse().getContentAsString();
        assertEquals(responseString, "");
    }

    @Test
    public void testSaveWithInvalidJson() throws Exception {
        MvcResult result = mockMvc.perform(post(BASE_URL + "/add").content(INVALID_JSON.getBytes())).andExpect(status().isInternalServerError()).andReturn();
        String responseString = result.getResponse().getContentAsString();
        assertEquals(responseString, "");
    }

    private Report createReport() {
        Report report = new Report();
        report.setId("Test-ID");
        report.setLocationId("locationId");
        report.setProviderId("providerId");
        report.setStatus("test");
        report.setReportType("reportType");
        report.setFormSubmissionId("formSubmissionId");
        return report;
    }
}

```


Overlapping Code:
```
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = TestWebContextLoader.class, locations = { "classpath:test-webmvc-config.xml"blic class ReportResourceTest {
@Autowired
protected WebApplicationContext webApplicationContext;
private MockMvc mockMvc;
protected ObjectMapper mapper = new ObjectMapper();
private final String BASE_URL = "/rest/report/";
private final String expectityId\\\":\\\"22\\\",\\\"locationId\\\":\\\"testLocationId\\\",\\\"reportType\\\":\\\"testReportType\\\",\\\"formSubmissionId\\\":\\\"testFormSubmissionId\\\",\\\"providerId\\\":\\\"testProviderId\\\ks
private ReportResource reportResource;
@Mock
private ReportService reportService;
@Before
public void setUp() {
MockitoAnnotations.initMocks(this);
mockMvc = org.springframework.test.web.servlet.setup.MockMvcBuilders.standaloneSetup(reportResourceFilter(new CrossSiteScriptingPreventionFilter(), "/*").buildithException() throws Exception {
MvcResult result = mockMvc.perform(post(BASE_URL + "/add").content)).andExpect(status().isBadRequest()).andReturn();
}
@Test
public void testSave() throws Exception {
when(reportService.addorUpdateReport(any(Report.class))).thenReturn(createReport());
MvcResult result = mockMvc.perform(post(BASE_URL + "/add").content).andExpect(status().isCreated()).andReturn();
String responseString = result.getResponse().getContentAsString();
assertEquals(responseString, "");
}
@Test
public void testSaveWithInvalidJson() throws Exception {
MvcResult result = mockMvc.perform(post(BASE_URL + "/add").content(INVALID_JSON.getBytes())).andExpect(status().isInternalServerError()).andReturn();
String responseString = result.getResponse().getContentAsString();
assertEquals(responseStrin
```
<Overlap Ratio: 0.7450043440486533>

---

--- 303 --
Question ID: 2ec0e02382de9a93dd698a861f3d7345f8e857b8
Original Code:
```
public class LeetCode0387FirstUniqueCharacterTest {

    private final static Logger logger = LoggerFactory.getLogger(LeetCode0387FirstUniqueCharacterTest.class);

    /**
     */
    @Test
    public void testMain() {
        logger.debug("BEGIN");
        String data = "lovelycomossez";
        System.out.println(firstUniqChar(data));
        System.out.println(firstUniqCharString(data));
    }

    /**
     * Return the first Uniq Char String index
     *
     * @param data
     * @return
     */
    private int firstUniqChar(String data) {
        // NULL CHECK
        if (data.equals("")) {
            return -1;
        }
        int retVal = -1;
        LinkedHashMap<Character, String> retMap = new LinkedHashMap<Character, String>();
        char[] chStr = data.toCharArray();
        int i = 0;
        while (i < chStr.length) try {
            if (retMap.get(chStr[i]) != null) {
                retMap.put(chStr[i], retMap.get(chStr[i]) + "#" + String.valueOf(i));
            } else {
                retMap.put(chStr[i], String.valueOf(i));
            }
        } finally {
            i++;
        }
        for (Map.Entry me : retMap.entrySet()) {
            String val = "" + me.getValue();
            if (!val.contains("#")) {
                retVal = Integer.valueOf(val);
                break;
            }
        }
        return retVal;
    }

    /**
     * Return the first Uniq Char String without using Map
     * @param data
     * @return
     */
    private String firstUniqCharString(String data) {
        // NULL CHECK
        if (data.equals("")) {
            return "";
        }
        char[] strArray = data.toCharArray();
        String retStr = "";
        if (data.length() == 1) {
            retStr = data;
        }
        int i = 0;
        while (i < strArray.length) try {
            String valStr = Character.toString(strArray[i]);
            String rData = data;
            rData = data.replace(valStr, "");
            rData = rData.replace(valStr.toUpperCase(Locale.ROOT), "");
            rData = rData.replace(valStr.toLowerCase(Locale.ROOT), "");
            if (rData.length() == 0) {
                retStr = "";
            } else if (rData.length() + 1 == data.length()) {
                retStr = valStr;
                break;
            }
        } finally {
            i++;
        }
        return retStr;
    }
}

```


Overlapping Code:
```
haracterTest {
private final static Logger logger = LoggerFactory.getLogger(LeetCode0387FirstUniqueC/
@Test
public void testMain() {
logger.debug("BEGIN");
String data = "lovelycomossez";
System.out.println(firstUniqChar(data));
System.out.println(firstUniqCharString(data));
}
/**
* Return the first Uniq Char String index
*
* @param data
* @return
*/
private int firstUniqChar(String data) {
// NULL CHECK
if (data.equals("")) {
return -1;
}
int retVal = -1;
LinkedHashMap<Character, String> retMap = new LinkedHashMap<Character, String>();
char[] chStr = data.toCharArr(retMap.get(chStr[i]) != null) {
retMap.put(chStr[i], retMap.get(chStr[i]) + "#" + String.valueOf(i));
} else {
retMap.put(chStr[i], String.valueOf(i)ring val = "" + me.getValue();
if (!val.contains("#")) {
retVal = Integer.valueOf(val);
break;
}
}
return retVal;
}
/**
* Return the first Uniq Char String without using Map
* @param data
* @return
*/
private String firstUniqCharString(String data) {
// NULL CHECK
if (data.equals("")) {
return "";
}
char[] strArray = data.toCharArray();
String retStr = "";
if (data.length() == 1) {
retStr = data;
ng valStr = Character.toString(strArray[i]);
String rData = data;
rData = data.replace(valStr, "");
rData = rData.replace(valStr.toUpperCase(Locale.ROOT), "");
rData = rData.replace(valStr.toLowerCase(Locale.ROOT), "");
if (rData.length() == 0) {
retStr = "";
} else if (rData.length() + 1 == data.length()
```
<Overlap Ratio: 0.8268674001158077>

---

--- 304 --
Question ID: 0652ad2af2a6eb0257e3ffcd905f120ac148e447
Original Code:
```
@Component
public class PaymentHandler implements PreSubmitCallbackHandler<AsylumCase> {

    private final boolean isfeePaymentEnabled;

    public PaymentHandler(@Value("${featureFlag.isfeePaymentEnabled}") boolean isfeePaymentEnabled) {
        this.isfeePaymentEnabled = isfeePaymentEnabled;
    }

    @Override
    public DispatchPriority getDispatchPriority() {
        return DispatchPriority.EARLY;
    }

    public boolean canHandle(PreSubmitCallbackStage callbackStage, Callback<AsylumCase> callback) {
        requireNonNull(callbackStage, "callbackStage must not be null");
        requireNonNull(callback, "callback must not be null");
        return callbackStage == PreSubmitCallbackStage.ABOUT_TO_SUBMIT && (callback.getEvent() == Event.PAY_AND_SUBMIT_APPEAL || callback.getEvent() == Event.PAY_FOR_APPEAL || callback.getEvent() == Event.PAYMENT_APPEAL) && isfeePaymentEnabled;
    }

    public PreSubmitCallbackResponse<AsylumCase> handle(PreSubmitCallbackStage callbackStage, Callback<AsylumCase> callback) {
        if (!canHandle(callbackStage, callback)) {
            throw new IllegalStateException("Cannot handle callback");
        }
        final AsylumCase asylumCase = callback.getCaseDetails().getCaseData();
        boolean isRepJourney = asylumCase.read(AsylumCaseFieldDefinition.JOURNEY_TYPE, JourneyType.class).map(j -> j == JourneyType.REP).orElse(true);
        // we have to set payment success first before do the payment because later we don't have possibility to change that
        if (isRepJourney) {
            asylumCase.write(PAYMENT_STATUS, PAID);
        }
        asylumCase.write(AsylumCaseFieldDefinition.IS_FEE_PAYMENT_ENABLED, isfeePaymentEnabled ? YesOrNo.YES : YesOrNo.NO);
        return new PreSubmitCallbackResponse<>(asylumCase);
    }
}

```


Overlapping Code:
```
entHandler implements PreSubmitCallbackHandler<AsylumCase> {
private final boolean isfeePaymentEnabled;
public PaymentHandler(@Value("${featureFlag.isfeePaymentEnabled}") boolean isfeePaymentEnabled) {
this.isfeePaymentEnabled = isfeePaymentEnabled;
}
@Override
public DispatchPriority getDispatchPriority() {
return DispatchPriority.EARLY;
}
public boolean canHandle(PreSubmitCallbackStage callbackStage, Callback<AsylumCase> callback) {
requireNonNull(callbackStage, "callbackStage must not be null");
requireNonNull(callback, "callback must not be null");
return callbackStage == PreSubmitCallbackStage.ABOUT_TO_SUBMITEAL || callback.getEvent() == Event.PAY_FOR_APPEALePaymentEnabled;
}
public PreSubmitCallbackResponse<AsylumCase> handle(PreSubmitCallbackStage callbackStage, Callback<AsylumCase> callback) {
if (!canHandle(callbackStage, callback)) {
throw new IllegalStateException("Cannot handle callback");
}
final AsylumCase asylumCase = callback.getCaseDetails().getCaseData();
boolean isRepJourney = asylumCase.read(AsylumCaseFieldDefinition.JOURNEY_TYPE, Journe have to set payment success first before do the payment because later we don't have possibility to change that
if (isRepJourney) {
asylumCase.write(PAYMENT_STATUS, PAID);
}
asylumCase.write(AsylumCamentEnabled ? YesOrNo.YES : YesOrNo.NO);
return new PreSubmitCallbackResponse<>(asylumCase);
}
}
```
<Overlap Ratio: 0.8460111317254174>

---

--- 305 --
Question ID: 4cd1cd9c2d1e80e72112eab945a3b2e22ef7b82b
Original Code:
```
public class LoginSessionHandler implements MinecraftSessionHandler {

    private final ServerConnection connection;

    private boolean informationForwarded;

    public LoginSessionHandler(ServerConnection connection) {
        this.connection = connection;
    }

    @Override
    public void handle(MinecraftPacket packet) {
        if (packet instanceof EncryptionRequest) {
            throw new IllegalStateException("Backend server is online-mode!");
        } else if (packet instanceof LoginPluginMessage) {
            LoginPluginMessage message = (LoginPluginMessage) packet;
            VelocityConfiguration configuration = VelocityServer.getServer().getConfiguration();
            if (configuration.getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN && message.getChannel().equals(VelocityConstants.VELOCITY_IP_FORWARDING_CHANNEL)) {
                LoginPluginResponse response = new LoginPluginResponse();
                response.setSuccess(true);
                response.setId(message.getId());
                response.setData(createForwardingData(configuration.getForwardingSecret(), connection.getProxyPlayer().getRemoteAddress().getHostString(), connection.getProxyPlayer().getProfile()));
                connection.getMinecraftConnection().write(response);
                informationForwarded = true;
            } else {
                // Don't understand
                LoginPluginResponse response = new LoginPluginResponse();
                response.setSuccess(false);
                response.setId(message.getId());
                response.setData(Unpooled.EMPTY_BUFFER);
                connection.getMinecraftConnection().write(response);
            }
        } else if (packet instanceof Disconnect) {
            Disconnect disconnect = (Disconnect) packet;
            // Do we have an outstanding notification? If so, fulfill it.
            doNotify(ConnectionRequestResults.forDisconnect(disconnect));
            connection.disconnect();
        } else if (packet instanceof SetCompression) {
            SetCompression sc = (SetCompression) packet;
            connection.getMinecraftConnection().setCompressionThreshold(sc.getThreshold());
        } else if (packet instanceof ServerLoginSuccess) {
            if (VelocityServer.getServer().getConfiguration().getPlayerInfoForwardingMode() == PlayerInfoForwarding.MODERN && !informationForwarded) {
                doNotify(ConnectionRequestResults.forDisconnect(TextComponent.of("Your server did not send a forwarding request to the proxy. Is it set up correctly?")));
                connection.disconnect();
                return;
            }
            // The player has been logged on to the backend server.
            connection.getMinecraftConnection().setState(StateRegistry.PLAY);
            ServerConnection existingConnection = connection.getProxyPlayer().getConnectedServer();
            if (existingConnection == null) {
                // Strap on the play session handler
                connection.getProxyPlayer().getConnection().setSessionHandler(new ClientPlaySessionHandler(connection.getProxyPlayer()));
            } else {
                // The previous server connection should become obsolete.
                existingConnection.disconnect();
            }
            doNotify(ConnectionRequestResults.SUCCESSFUL);
            connection.getMinecraftConnection().setSessionHandler(new BackendPlaySessionHandler(connection));
            connection.getProxyPlayer().setConnectedServer(connection);
        }
    }

    @Override
    public void exception(Throwable throwable) {
        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel().attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);
        if (future != null) {
            future.completeExceptionally(throwable);
        }
    }

    private void doNotify(ConnectionRequestBuilder.Result result) {
        CompletableFuture<ConnectionRequestBuilder.Result> future = connection.getMinecraftConnection().getChannel().attr(ServerConnection.CONNECTION_NOTIFIER).getAndSet(null);
        if (future != null) {
            future.complete(result);
        }
    }

    static ByteBuf createForwardingData(byte[] hmacSecret, String address, GameProfile profile) {
        ByteBuf dataToForward = Unpooled.buffer();
        ByteBuf finalData = Unpooled.buffer();
        try {
            ProtocolUtils.writeString(dataToForward, address);
            ProtocolUtils.writeUuid(dataToForward, profile.idAsUuid());
            ProtocolUtils.writeString(dataToForward, profile.getName());
            ProtocolUtils.writeVarInt(dataToForward, profile.getProperties().size());
            for (GameProfile.Property property : profile.getProperties()) {
                ProtocolUtils.writeString(dataToForward, property.getName());
                ProtocolUtils.writeString(dataToForward, property.getValue());
                String signature = property.getSignature();
                if (signature != null) {
                    dataToForward.writeBoolean(true);
                    ProtocolUtils.writeString(dataToForward, signature);
                } else {
                    dataToForward.writeBoolean(false);
                }
            }
            SecretKey key = new SecretKeySpec(hmacSecret, "HmacSHA256");
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(key);
            mac.update(dataToForward.array(), dataToForward.arrayOffset(), dataToForward.readableBytes());
            byte[] sig = mac.doFinal();
            finalData.writeBytes(sig);
            finalData.writeBytes(dataToForward);
            return finalData;
        } catch (InvalidKeyException e) {
            finalData.release();
            throw new RuntimeException("Unable to authenticate data", e);
        } catch (NoSuchAlgorithmException e) {
            // Should never happen
            finalData.release();
            throw new AssertionError(e);
        } finally {
            dataToForward.release();
        }
    }
}

```


Overlapping Code:
```
 class LoginSessionHandler implements MinecraftSessionHandler {
private final ServerConnection connection;
private boolean informationForwarded;
public LoginSessionHandler(ServerConnection connection) {
this.connection = connection;
}
@Override
public void handle(MinecraftPacket packet) {
if (packet instanceof EncryptionRequest) {
throw new IllegalStateException("Backend server is online-mode!");
} else if (packet instanceof LoginPluginMessage) {
LoginPluginMessage message = (LoginPluginMessage) packet;
VelocityConfiguration configuration = VelocityServer.getServer().getConfiguration();
if (configuration.getPlayerInfoForwardingMode() == PlayerInfoForwarding.MOnnel().equals(VelocityConstants.VELOCITY_IP_FORWARDING_CHANNEL)) {
LoginPluginResponse response = new LoginPluginResponse();
response.setSuccess(true);
response.setId(message.getId());
response.setData(createForwardingData(configuration.getForwardingSecregetProxyPlayer().getRemoteAddress().getHostString(nection.getMinecraftConnection().write(response);
informationForwarded = true;
} else {
// Don't understand
LoginPluginResponse response = new LoginPluginResponse();
response.setSuccess(false);
response.setId(message.getId());
response.setData(Unpooled.EMPTY_BUFFER);
connection.getMinecraftConnection().write(response);
}
} else if (packet instanceof Disconnect) {
Disconnect disconnect = (Disconnect) packet;
// Do we have an outstanding notification? If so, fulfill it.
doNotify(ConnectionRequestResults.forDisconnect(disconnect));
connection.disconnect();
} else if (packet instanceof SetCompression) {
SetCompression sc = (SetCompression) packet;
connection.getMinecraftConnection().setCompressionThreshold(sc.getThreshold());
} else if (packet instanceof ServerLoginSuccess) {
if (VelocityServer.getServer().getConfiguration().getPlayerInfoForwardingMode() == PlayerInfoForwarding.MOformationForwarded) {
doNotify(ConnectionRequestRe
```
<Overlap Ratio: 0.9286061194754736>

---

--- 306 --
Question ID: 4df8a27f0598864bd98f434816cd53ecd56f674f
Original Code:
```
public final class EndpointId {

    private static final Log logger = LogFactory.getLog(EndpointId.class);

    private static final Set<String> loggedWarnings = new HashSet<>();

    private static final Pattern VALID_PATTERN = Pattern.compile("[a-zA-Z0-9\\.\\-]+");

    private static final Pattern WARNING_PATTERN = Pattern.compile("[\\.\\-]+");

    private static final String MIGRATE_LEGACY_NAMES_PROPRTY = "management.endpoints.migrate-legacy-ids";

    private final String value;

    private final String lowerCaseValue;

    private final String lowerCaseAlphaNumeric;

    private EndpointId(String value) {
        Assert.hasText(value, "Value must not be empty");
        Assert.isTrue(VALID_PATTERN.matcher(value).matches(), "Value must only contain valid chars");
        Assert.isTrue(!Character.isDigit(value.charAt(0)), "Value must not start with a number");
        Assert.isTrue(!Character.isUpperCase(value.charAt(0)), "Value must not start with an uppercase letter");
        if (WARNING_PATTERN.matcher(value).find()) {
            logWarning(value);
        }
        this.value = value;
        this.lowerCaseValue = value.toLowerCase(Locale.ENGLISH);
        this.lowerCaseAlphaNumeric = getAlphaNumerics(this.lowerCaseValue);
    }

    private String getAlphaNumerics(String value) {
        StringBuilder result = new StringBuilder(value.length());
        int i = 0;
        while (i < value.length()) try {
            char ch = value.charAt(i);
            if (ch >= 'a' && ch <= 'z' || ch >= '0' && ch <= '9') {
                result.append(ch);
            }
        } finally {
            i++;
        }
        return result.toString();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        return this.lowerCaseAlphaNumeric.equals(((EndpointId) obj).lowerCaseAlphaNumeric);
    }

    @Override
    public int hashCode() {
        return this.lowerCaseAlphaNumeric.hashCode();
    }

    /**
     * Return a lower-case version of the endpoint ID.
     * @return the lower-case endpoint ID
     */
    public String toLowerCaseString() {
        return this.lowerCaseValue;
    }

    @Override
    public String toString() {
        return this.value;
    }

    /**
     * Factory method to create a new {@link EndpointId} of the specified value.
     * @param value the endpoint ID value
     * @return an {@link EndpointId} instance
     */
    public static EndpointId of(String value) {
        return new EndpointId(value);
    }

    /**
     * Factory method to create a new {@link EndpointId} of the specified value. This
     * variant will respect the {@code management.endpoints.migrate-legacy-names} property
     * if it has been set in the {@link Environment}.
     * @param environment the Spring environment
     * @param value the endpoint ID value
     * @return an {@link EndpointId} instance
     * @since 2.2.0
     */
    public static EndpointId of(Environment environment, String value) {
        Assert.notNull(environment, "Environment must not be null");
        return new EndpointId(migrateLegacyId(environment, value));
    }

    private static String migrateLegacyId(Environment environment, String value) {
        if (environment.getProperty(MIGRATE_LEGACY_NAMES_PROPRTY, Boolean.class, false)) {
            return value.replace(".", "");
        }
        return value;
    }

    /**
     * Factory method to create a new {@link EndpointId} from a property value. More
     * lenient than {@link #of(String)} to allow for common "relaxed" property variants.
     * @param value the property value to convert
     * @return an {@link EndpointId} instance
     */
    public static EndpointId fromPropertyValue(String value) {
        return new EndpointId(value.replace("-", ""));
    }

    static void resetLoggedWarnings() {
        loggedWarnings.clear();
    }

    private static void logWarning(String value) {
        if (logger.isWarnEnabled() && loggedWarnings.add(value)) {
            logger.warn("Endpoint ID '" + value + "' contains invalid characters, please migrate to a valid format.");
        }
    }
}

```


Overlapping Code:
```
c final class EndpointId {
private static final Log logger = LogFactory.getLog(EndpointId.class);
private static final Set<String> loggedWarnings = new HashSet<>();
private static final Pattern VALID_PATTERN = Pattern.compile("[a-zA-Z0-9\\.\\-]+");
private static final Pattern WARNING_PATTERN = Pattern.compile("[\\.\\-]+");
private static final String MIGRATE_LEGACY_NAMES_PROPRTY = "management.endpoints.migrate-legacy-ids";
private final String value;
private final String lowerCaseValue;
private final String lowerCaseAlphaNumeric;
private EndpointId(String value) {
Assert.hasText(value, "Value must not be empty");
Assert.isTrue(VALID_PATTERN.matcher(value).matches(), "Value must only contain valid chars");
Assert.isTrue(!Character.isDigit(value.charAt(0)), "Value must not start with a number");
Assert.isTrue(!Character.isUpperCase(value.charAt(0)), "Value must not start with an uppercase letter");
if (WARNING_PATTERN.matcher(value).find()) {
logWarning(value);
}
this.value = value;
this.lowerCaseValue = value.toLowerCase(Locale.ENGLISH);
this.lowerCaseAlphaNumeric = getAlphaNumerics(this.lowerCaseValue);
}
private String getAlphaNumerics(String value) {
StringBuilder result = new StringBuilder(value.length());
int i = 0;
while (i if (ch >= 'a' && ch <= 'z' || ch >= '0' && ch <= '9') {
result.app
}
return result.toString();
}
@Override
public boolean equals(Object obj) {
if (this == obj) {
return true;
}
if (obj == null || getClass() != obj.getClass()) {
return false;
}
return this.lowerCaseAlphaNumeric.equals(((EndpointId) obj).lowerCaseAlphaNumeric);
}
@Override
public int hashCode() {
return this.lowerCaseAlphaNumeric.hashCode();
}
/**
* Return a lower-case version of the endpoint ID.
* @return the lower-case endpoint ID
*/
public String toLowerCaseString() {
return this.lowerCaseValue;
}
@Override
public String toString() {
return this.value;
}
/**
* Factory method to create a new {@link EndpointId} of the specified val
```
<Overlap Ratio: 0.9426506024096386>

---

--- 307 --
Question ID: 808dd88a9f7ffc10968ef98a648fd4967d60303d
Original Code:
```
public class assembly_Task_auto {

    @Inject
    private LBR kuka_Iiwa;

    @Inject
    private MediaFlangeIOGroup media_Flange;

    @Inject
    private FlexFellow kuka_Ffellow;

    @Inject
    private Gripper gripper_1;

    @Inject
    private ITaskLogger logger;

    // Very important:
    @Inject
    private IApplicationData //call the frame
    app_Data;

    @Inject
    private IApplicationUI // call the diag
    user_I;

    @Inject
    private Frame frame_Kuka;

    @Inject
    private Robot_application_humza robo;

    public void main_App() {
        //Speed
        robo.getApplicationControl().setApplicationOverride(0.2);
        gripper_1.open_M();
        gripper_1.attachTo(kuka_Iiwa.getFlange());
        auto_Assem_Seq();
    }

    private void auto_Assem_Seq() {
        kuka_Iiwa.move(ptpHome());
        hrc_Pos();
        idle_Rob();
        fh202_Assem();
        hrc_Pos();
        c6_Assem();
        hrc_Pos();
        d6_Assem();
        hrc_Pos();
        d2_Assem();
        hrc_Pos();
        idle_Rob();
        b6_Assem();
        hrc_Pos();
        b10_Assem();
        hrc_Pos();
        e256_Assem();
        hrc_Pos();
        m1174_Assem();
        hrc_Pos();
        e215_Assem();
        hrc_Pos();
        idle_Rob();
    }

    public void fastening(ICondition start_Screw_2) {
        // TODO Auto-generated method stub
        CartesianImpedanceControlMode fastening = new CartesianImpedanceControlMode();
        fastening.parametrize(CartDOF.X).setStiffness(800.0);
        fastening.parametrize(CartDOF.Z).setStiffness(100.0);
        fastening.parametrize(CartDOF.Y).setStiffness(100.0);
        Frame fastening_Pos = app_Data.getFrame("/fastening_Pos").copyWithRedundancy();
        gripper_1.move(ptp(fastening_Pos));
        ForceCondition start_Screw = ForceCondition.createNormalForceCondition(gripper_1.getDefaultMotionFrame(), CoordinateAxis.X, 60);
        IMotionContainer hand_Mani = gripper_1.move(positionHold(fastening, 50, TimeUnit.SECONDS).breakWhen(start_Screw));
        if (hand_Mani.hasFired(start_Screw)) {
            logger.info("its broken");
            media_Flange.setLEDBlue(true);
        }
        CartesianImpedanceControlMode fastening_Op = new CartesianImpedanceControlMode();
        fastening_Op.parametrize(CartDOF.X).setStiffness(5000);
        fastening_Op.parametrize(CartDOF.Z).setStiffness(5000);
        fastening_Op.parametrize(CartDOF.Y).setStiffness(5000);
        fastening_Op.parametrize(CartDOF.C).setDamping(0.7);
        IMotionContainer fast_Screw = gripper_1.move(positionHold(fastening_Op, 50, TimeUnit.SECONDS).breakWhen(start_Screw_2));
        if (fast_Screw.hasFired(start_Screw_2)) {
            logger.info("it is soft again");
            media_Flange.setLEDBlue(false);
        }
        gripper_1.move(positionHold(fastening, 50, TimeUnit.SECONDS).breakWhen(start_Screw));
    }

    private void push_Comp() {
        CartesianImpedanceControlMode softrob_Push = new CartesianImpedanceControlMode();
        softrob_Push.parametrize(CartDOF.X).setStiffness(500.0);
        softrob_Push.parametrize(CartDOF.Y).setStiffness(500.0);
        softrob_Push.parametrize(CartDOF.Z).setStiffness(500.0);
        Frame safelyto_Comp_Orient = app_Data.getFrame("/Assembly_Table/orient_Abbm1174").copyWithRedundancy();
        Frame push_Comp_Orient = app_Data.getFrame("/Assembly_Table/push_Orient").copyWithRedundancy();
        Frame push_Comp = app_Data.getFrame("/Assembly_Table/push_Comp").copyWithRedundancy();
        gripper_1.move(ptp(safelyto_Comp_Orient).setMode(softrob_Push));
        gripper_1.move(ptp(push_Comp_Orient));
        gripper_1.move(lin(push_Comp));
        Frame push_Comp_Child = app_Data.getFrame("/Assembly_Table/push_Comp/push_Lin").copyWithRedundancy();
        gripper_1.move(lin(push_Comp_Child).setCartVelocity(100).setMode(softrob_Push));
        gripper_1.move(lin(push_Comp));
        gripper_1.move(ptp(safelyto_Comp_Orient).setMode(softrob_Push));
    }

    private void zdu_grn_Assem() {
        logger.info("Starting Assembly task for ZDU 2.5/4AN GREEN");
        zdu_grn_Pick();
        zdugrn_rail_Assem();
    }

    private void zdu_grn_Pick() {
        // TODO Auto-generated method stub
        Frame Tray_ZPE_GRN_P = app_Data.getFrame("/Rack/ZPE_GRN_P").copyWithRedundancy();
        gripper_1.move(ptp(Tray_ZPE_GRN_P));
        Frame Tray_ZPE_GRN_P_1 = app_Data.getFrame("/Rack/ZPE_GRN_P/ZPE_GRN_P_1").copyWithRedundancy();
        //Tray_ZPE_GRN_P.setX(Tray_ZPE_GRN_P.getX()+50);
        int stiff_Fh202 = 1000;
        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();
        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);
        gripper_1.move(lin(Tray_ZPE_GRN_P_1).setCartVelocity(100).setMode(softMode));
        gripper_1.close_M();
        gripper_1.move(lin(Tray_ZPE_GRN_P).setCartVelocity(100));
    }

    private void zdugrn_rail_Assem() {
        // TODO Auto-generated method stub
        Frame orient_Assem_Pos = app_Data.getFrame("/Assembly_Table/rail_orient_zdubl").copyWithRedundancy();
        Frame Green = orient_Assem_Pos.setX(orient_Assem_Pos.getX() - 50);
        gripper_1.move(ptp(Green));
        linear_Force();
        int stiff_assembrail = 100;
        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();
        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);
        Frame fix_Assem_Pos = app_Data.getFrame("/Assembly_Table/rail_orient_zdubl/P1").copyWithRedundancy();
        Frame green_Fix = fix_Assem_Pos.setX(fix_Assem_Pos.getX() - 50);
        gripper_1.move(ptp(green_Fix));
        gripper_1.open_M();
        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);
        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));
    }

    private void zdu_bl_Assem() {
        // TODO Auto-generated method stub
        logger.info("Starting Assembly task for ZDU 2.5/4AN Blue");
        zdu_Bl_Pick();
        zdubl_rail_Assem();
    }

    private void zdu_Bl_Pick() {
        // TODO Auto-generated method stub
        Frame Tray_ZDU_BL_P = app_Data.getFrame("/Rack/ZDU_BL_P").copyWithRedundancy();
        gripper_1.move(ptp(Tray_ZDU_BL_P));
        Frame Tray_ZDU_BL_P_1 = app_Data.getFrame("/Rack/ZDU_BL_P/ZDU_BL_P_1").copyWithRedundancy();
        int stiff_Fh202 = 1000;
        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();
        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);
        gripper_1.move(lin(Tray_ZDU_BL_P_1).setCartVelocity(100).setMode(softMode));
        gripper_1.close_M();
        gripper_1.move(lin(Tray_ZDU_BL_P).setCartVelocity(100));
    }

    private void zdubl_rail_Assem() {
        // TODO Auto-generated method stub
        Frame orient_Assem_Pos = app_Data.getFrame("/Assembly_Table/rail_orient_zdubl").copyWithRedundancy();
        gripper_1.move(ptp(orient_Assem_Pos));
        linear_Force();
        int stiff_assembrail = 100;
        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();
        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);
        Frame fix_Assem_Pos = app_Data.getFrame("/Assembly_Table/rail_fix_zdubl").copyWithRedundancy();
        gripper_1.move(ptp(fix_Assem_Pos));
        gripper_1.open_M();
        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);
        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));
    }

    private void d6_Assem() {
        // TODO Auto-generated method stub
        logger.info("Starting Assembly task for D6");
        d6_Pick();
        m1174_rail_Assem();
    }

    private void d6_Pick() {
        // TODO Auto-generated method stub
        Frame Tray_D6_P = app_Data.getFrame("/Rack/D6_P").copyWithRedundancy();
        gripper_1.move(ptp(Tray_D6_P));
        Frame Tray_D6_P_1 = app_Data.getFrame("/Rack/D6_P/D6_P_1").copyWithRedundancy();
        int stiff_Fh202 = 1000;
        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();
        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);
        gripper_1.move(lin(Tray_D6_P_1).setCartVelocity(100).setMode(softMode));
        gripper_1.close_M();
        gripper_1.move(lin(Tray_D6_P).setCartVelocity(100));
    }

    private void b6_Assem() {
        // TODO Auto-generated method stub
        logger.info("Starting Assembly task for B6");
        b6_Pick();
        m1174_rail_Assem_3();
    }

    private void b6_Pick() {
        // TODO Auto-generated method stub
        Frame Tray_B6_P = app_Data.getFrame("/Rack/B6_P").copyWithRedundancy();
        gripper_1.move(ptp(Tray_B6_P));
        Frame Tray_B6_P_1 = app_Data.getFrame("/Rack/B6_P/B6_P_1").copyWithRedundancy();
        int stiff_Fh202 = 1000;
        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();
        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);
        gripper_1.move(lin(Tray_B6_P_1).setCartVelocity(100).setMode(softMode));
        gripper_1.close_M();
        gripper_1.move(lin(Tray_B6_P).setCartVelocity(100));
    }

    private void b10_Assem() {
        // TODO Auto-generated method stub
        logger.info("Starting Assembly task for B10");
        b10_Pick();
        m1174_rail_Assem_3();
    }

    private void b10_Pick() {
        // TODO Auto-generated method stub
        Frame Tray_B10_P = app_Data.getFrame("/Rack/B10_P").copyWithRedundancy();
        gripper_1.move(ptp(Tray_B10_P));
        Frame Tray_B10_P_1 = app_Data.getFrame("/Rack/B10_P/B10_P_1").copyWithRedundancy();
        int stiff_Fh202 = 1000;
        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();
        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);
        gripper_1.move(lin(Tray_B10_P_1).setCartVelocity(100).setMode(softMode));
        gripper_1.close_M();
        gripper_1.move(lin(Tray_B10_P).setCartVelocity(100));
    }

    private void c6_Assem() {
        logger.info("Starting Assembly task for C6");
        c6_Pick();
        m1174_rail_Assem();
    }

    private void c6_Pick() {
        // TODO Auto-generated method stub
        Frame Tray_C6_P = app_Data.getFrame("/Rack/C6_P").copyWithRedundancy();
        gripper_1.move(ptp(Tray_C6_P));
        Frame Tray_C6_P_1 = app_Data.getFrame("/Rack/C6_P/C6_P_1").copyWithRedundancy();
        int stiff_Fh202 = 1000;
        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();
        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);
        gripper_1.move(lin(Tray_C6_P_1).setCartVelocity(100).setMode(softMode));
        gripper_1.close_M();
        gripper_1.move(lin(Tray_C6_P).setCartVelocity(100));
    }

    private void e215_Assem() {
        logger.info("Starting Assembly task for E215");
        e215_Pick();
        m1174_rail_Assem_3();
    }

    private void e215_Pick() {
        // TODO Auto-generated method stub
        Frame Tray_E215_P = app_Data.getFrame("/Rack/E215_P").copyWithRedundancy();
        gripper_1.move(ptp(Tray_E215_P));
        Frame Tray_E215_P_1 = app_Data.getFrame("/Rack/E215_P/E215_P_1").copyWithRedundancy();
        int stiff_Fh202 = 1000;
        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();
        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);
        //softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);
        gripper_1.move(lin(Tray_E215_P_1).setCartVelocity(100).setMode(softMode));
        gripper_1.close_M();
        gripper_1.move(lin(Tray_E215_P).setCartVelocity(100));
    }

    private void e215_rail_Assem() {
        // TODO Auto-generated method stub
        Frame orient_Assem_Pos = app_Data.getFrame("/Assembly_Table/rail_Orient_Large").copyWithRedundancy();
        gripper_1.move(ptp(orient_Assem_Pos));
        linear_Force();
        int stiff_assembrail = 100;
        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();
        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);
        Frame fix_Assem_Pos = app_Data.getFrame("/Assembly_Table/rail_Orient_Large/rail_Orient_Large_1").copyWithRedundancy();
        gripper_1.move(ptp(fix_Assem_Pos));
        gripper_1.open_M();
        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);
        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));
    }

    private void e290_Assem() {
        logger.info("Starting Assembly task for E290");
        e290_Pick();
    }

    private void e290_Pick() {
        // TODO Auto-generated method stub
        Frame Tray_E290_P = app_Data.getFrame("/Rack/E290_P").copyWithRedundancy();
        gripper_1.move(ptp(Tray_E290_P));
        Frame Tray_E290_P_1 = app_Data.getFrame("/Rack/E290_P/E290_P_1").copyWithRedundancy();
        int stiff_Fh202 = 1000;
        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();
        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);
        gripper_1.move(lin(Tray_E290_P_1).setCartVelocity(100).setMode(softMode));
        gripper_1.close_M();
        gripper_1.move(lin(Tray_E290_P).setCartVelocity(100));
    }

    private void e256_Assem() {
        logger.info("Starting Assembly task for E256");
        e256_Pick();
        m1174_rail_Assem_3();
    }

    private void e256_Pick() {
        Frame Tray_E256_P = app_Data.getFrame("/Rack/E256_P").copyWithRedundancy();
        gripper_1.move(ptp(Tray_E256_P));
        Frame Tray_E256_P_1 = app_Data.getFrame("/Rack/E256_P/E256_P_1").copyWithRedundancy();
        int stiff_Fh202 = 1000;
        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();
        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);
        gripper_1.move(lin(Tray_E256_P_1).setCartVelocity(100).setMode(softMode));
        gripper_1.close_M();
        gripper_1.move(lin(Tray_E256_P).setCartVelocity(100));
    }

    private void d2_Assem() {
        logger.info("Starting Assembly task for D2");
        d2_Pick();
        m1174_rail_Assem();
    }

    private void d2_Pick() {
        // TODO Auto-generated method stub
        Frame Tray_d2_P = app_Data.getFrame("/Rack/D2_P").copyWithRedundancy();
        gripper_1.move(ptp(Tray_d2_P));
        Frame Tray_d2_P_1 = app_Data.getFrame("/Rack/D2_P/D2_P_1").copyWithRedundancy();
        int stiff_Fh202 = 1000;
        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();
        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);
        gripper_1.move(lin(Tray_d2_P_1).setCartVelocity(100).setMode(softMode));
        gripper_1.close_M();
        gripper_1.move(lin(Tray_d2_P).setCartVelocity(100));
    }

    private void m1174_Assem() {
        logger.info("Starting Assembly task for M1174");
        m1174_Pick();
        m1174_rail_Assem_3();
    }

    private void m1174_Pick() {
        Frame Tray_M1174_P = app_Data.getFrame("/Rack/M1174_P").copyWithRedundancy();
        gripper_1.move(ptp(Tray_M1174_P));
        Frame Tray_M1174_P_1 = app_Data.getFrame("/Rack/M1174_P/M1174_P_1").copyWithRedundancy();
        int stiff_Fh202 = 1000;
        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();
        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);
        gripper_1.move(lin(Tray_M1174_P_1).setCartVelocity(100).setMode(softMode));
        gripper_1.close_M();
        gripper_1.move(lin(Tray_M1174_P).setCartVelocity(100));
    }

    private void m1174_rail_Assem() {
        // TODO Auto-generated method stub
        Frame orient_Assem_Pos = app_Data.getFrame("/Assembly_Table/rail_Orient_Large2").copyWithRedundancy();
        gripper_1.move(lin(orient_Assem_Pos));
        linear_Force();
        int stiff_assembrail = 100;
        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();
        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);
        Frame fix_Assem_Pos = app_Data.getFrame("/Assembly_Table/rail_Orient_Large2/rail_Orient_Large2_1").copyWithRedundancy();
        gripper_1.move(ptp(fix_Assem_Pos));
        gripper_1.open_M();
        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);
        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));
    }

    private void m1174_rail_Assem_3() {
        // TODO Auto-generated method stub
        Frame orient_Assem_Pos = app_Data.getFrame("/Assembly_Table/rail_Orient_Large").copyWithRedundancy();
        gripper_1.move(lin(orient_Assem_Pos));
        linear_Force_3();
        int stiff_assembrail = 100;
        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();
        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);
        Frame fix_Assem_Pos = app_Data.getFrame("/Assembly_Table/rail_Orient_Large/rail_Orient_Large_1").copyWithRedundancy();
        gripper_1.move(ptp(fix_Assem_Pos));
        gripper_1.open_M();
        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);
        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));
    }

    private void fh202_Assem() {
        logger.info("Starting Assembly task for FH202A");
        fh202_Pick();
        m1174_rail_Assem();
    }

    private void fh202_Pick() {
        Frame Tray_FH202_P = app_Data.getFrame("/Rack/FH202_P").copyWithRedundancy();
        gripper_1.move(ptp(Tray_FH202_P));
        Frame Tray_FH202_P_1 = app_Data.getFrame("/Rack/FH202_P/FH202_P_1").copyWithRedundancy();
        int stiff_Fh202 = 1000;
        CartesianImpedanceControlMode softMode = new CartesianImpedanceControlMode();
        softMode.parametrize(CartDOF.Z).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.Y).setStiffness(stiff_Fh202);
        softMode.parametrize(CartDOF.X).setStiffness(stiff_Fh202);
        gripper_1.move(lin(Tray_FH202_P_1).setCartVelocity(100).setMode(softMode));
        gripper_1.close_M();
        gripper_1.move(lin(Tray_FH202_P).setCartVelocity(100).setMode(softMode));
    }

    public void shelf_position() {
        Frame Shelf_Pos = app_Data.getFrame("/Rack/Shelf_Pos_1").copyWithRedundancy();
        gripper_1.move(ptp(Shelf_Pos));
    }

    public void idle_Rob() {
        logger.info("Tap the robot to start the task");
        ForceCondition contact_Start = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 15);
        while (true) try {
            media_Flange.setLEDBlue(true);
            IMotionContainer contactMotion_1 = gripper_1.move(linRel(0, 0, 10).setCartVelocity(100).breakWhen(contact_Start));
            IMotionContainer contactMotion_2 = gripper_1.move(linRel(0, 0, -10).setCartVelocity(100).breakWhen(contact_Start));
            if (contactMotion_1.hasFired(contact_Start) || contactMotion_2.hasFired(contact_Start)) {
                media_Flange.setLEDBlue(false);
                logger.info("The assembly task starts now");
                break;
            }
        } finally {
        }
    }

    public void hrc_Pos() {
        Frame hrc_Pos = app_Data.getFrame("/hrc_Pos").copyWithRedundancy();
        gripper_1.move(ptp(hrc_Pos));
    }

    public void linear_Force_Shelf() {
        logger.info("linear motion with force control");
        ForceCondition contact_Start_Pick_tr2 = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);
        IMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 300).setCartVelocity(100).breakWhen(contact_Start_Pick_tr2));
        if (contactMotion_Pick.hasFired(contact_Start_Pick_tr2)) {
            logger.info("The contact has occured!");
        }
    }

    public void linear_Force() {
        logger.info("linear motion with force control");
        ForceCondition contact_Start_Pick = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 30);
        IMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 300).setCartVelocity(450).breakWhen(contact_Start_Pick));
        if (contactMotion_Pick.hasFired(contact_Start_Pick)) {
            logger.info("The contact has occured!");
        }
    }

    public void linear_Force_3() {
        logger.info("linear motion with force control");
        ForceCondition contact_Start_Pick = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 30);
        IMotionContainer contactMotion_Pick = gripper_1.move(linRel(0, 0, 800).setCartVelocity(450).breakWhen(contact_Start_Pick));
        if (contactMotion_Pick.hasFired(contact_Start_Pick)) {
            logger.info("The contact has occured!");
        }
    }

    public void assem_Rail_ABB_M1174() {
        Frame orient_Assem_Pos = app_Data.getFrame("/Assembly_Table/orient_Abbm1174").copyWithRedundancy();
        gripper_1.move(ptp(orient_Assem_Pos));
        linear_Force();
        int stiff_assembrail = 100;
        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();
        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);
        Frame fix_Assem_Pos = app_Data.getFrame("/Assembly_Table/fix_Assem_Pos_M1174").copyWithRedundancy();
        gripper_1.move(ptp(fix_Assem_Pos));
        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);
        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));
        gripper_1.open_M();
    }

    public void assem_Rail_Fh202a() {
        Frame orient_Assem_Pos = app_Data.getFrame("/Assembly_Table/orient_Fh202a").copyWithRedundancy();
        gripper_1.move(ptp(orient_Assem_Pos));
        linear_Force();
        int stiff_assembrail = 100;
        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();
        softrob.parametrize(CartDOF.X).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Y).setStiffness(stiff_assembrail);
        softrob.parametrize(CartDOF.Z).setStiffness(stiff_assembrail);
        Frame fix_Assem_Pos = app_Data.getFrame("/Assembly_Table/orient_Fh202a/fix_Pos").copyWithRedundancy();
        gripper_1.move(ptp(fix_Assem_Pos));
        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);
        gripper_1.move(ptp(orient_Assem_Pos).setMode(softrob).breakWhen(contact_Assem_Mag));
        gripper_1.open_M();
    }

    private void assem_Rail_mag() {
        Frame orient_Assem_Pos = app_Data.getFrame("/Assembly_Table/orient_Assem_T").copyWithRedundancy();
        gripper_1.move(ptp(orient_Assem_Pos));
        linear_Force();
        CartesianImpedanceControlMode softrob = new CartesianImpedanceControlMode();
        softrob.parametrize(CartDOF.ALL).setStiffness(100.0);
        Frame fix_Assem_Pos_mag = app_Data.getFrame("/Assembly_Table/fix_Assem_Pos_Mag").copyWithRedundancy();
        gripper_1.move(ptp(fix_Assem_Pos_mag));
        ForceCondition contact_Assem_Mag = ForceCondition.createSpatialForceCondition(gripper_1.getDefaultMotionFrame(), 25);
        gripper_1.move(ptp(fix_Assem_Pos_mag).setMode(softrob).breakWhen(contact_Assem_Mag));
        //gripper_1.move(ptp(orient_Assem_Pos_A7_orient).setMode(softrob).breakWhen(contact_Assem_Mag));
        gripper_1.open_M();
    }

    public void p_grip_h() {
        CartesianSineImpedanceControlMode ctrl = new CartesianSineImpedanceControlMode();
        ctrl.parametrize(CartDOF.X).setStiffness(300).setDamping(0.5);
        ctrl.parametrize(CartDOF.Y).setStiffness(100).setDamping(0.5).setFrequency(2).setAmplitude(2);
        ctrl.parametrize(CartDOF.Z).setStiffness(100).setDamping(0.5).setFrequency(2).setAmplitude(3);
        // X,Y,Z Translations 0-300
        ctrl.parametrize(CartDOF.A).setStiffness(200).setDamping(0.5);
        ctrl.parametrize(CartDOF.B).setStiffness(200).setDamping(0.5);
        ctrl.parametrize(CartDOF.C).setStiffness(20).setDamping(0.5).setFrequency(4).setAmplitude(3);
        IMotionContainer positionHoldMotion = gripper_1.move(positionHold(ctrl, 2, TimeUnit.SECONDS));
    }
}

```


Overlapping Code:
```
ediaFlangeIOGroup media_Flange;
@Inject
private Fl_Data;
@Inject
private IApplicationUI // call the r_1.open_M();
gripper_1.attachTo(kuka_Iiwa.getFlange());
auto_Assem_Seq();
}
prdle_Rob();
fh202_Assem();
hrc_Pos();
c6_Assem();
hrc_Pos();
d6_Assem();
hrc_Pos();
d2_Assem();
hrc_Pos();
idle_Rob();
b6_Assem();
hrc_Pos();
b10_Assem();
hrc_Pos();
e256_Assem();
hrc_Pos();
m1174_Assem();
hrc_Pos();
e215_Assem();
hrc_Pos();
idle_Rob(w_2) {
// TODO Auto-generated method stub
CartesianImpedanceControlMode fastening = new CartesianImpedanceControlMode();
fastening.parametrize(CartDOF.X).setStiffness(800.0);
fastening.parametrize(CartDOF.Z).setStiffness(100.0);
fastening.parametrize(CartDOF.Y).setStiffness(100.0);
Frame fastening_PorceCondition start_Screw = ForceCondition.createNormalForceCondition(gripper_1.getDefaultMotionFramni = gripper_1.move(positionHold(fastening, 50, TimeUnit.SECONDS).breakWhen(stanImpedanceControlMode fastening_Op = new CartesianImpedanceControlMode();
fastening_Op.parametrize(CartDOF.X).setStiffness(5000);
fastening_Op.parametrize(CartDOF.Z).setStiffness(5000);
fastening_Op.parametrize(CartDOF.Y).setStiffness(5000);
fastenin
```
<Overlap Ratio: 0.5769805680119582>

---

--- 308 --
Question ID: 6084f6710f0ac05ebcbffeae131e30719904a1ee
Original Code:
```
public class ResourceCompiler {

    private static final Logger logger = Logger.getLogger(ResourceCompiler.class.getName());

    private final CompilingVisitor compilingVisitor;

    private static class CompileTask implements Callable<Path> {

        private final Path file;

        private final Path compiledResourcesOut;

        private final Path aapt2;

        private final Revision buildToolsVersion;

        public CompileTask(Path file, Path compiledResourcesOut, Path aapt2, Revision buildToolsVersion) {
            this.file = file;
            this.compiledResourcesOut = compiledResourcesOut;
            this.aapt2 = aapt2;
            this.buildToolsVersion = buildToolsVersion;
        }

        @Override
        public Path call() throws Exception {
            logger.fine(new AaptCommandBuilder(aapt2).forBuildToolsVersion(buildToolsVersion).forVariantType(VariantType.LIBRARY).add("compile").add("-v").add("--legacy").add("-o", compiledResourcesOut.toString()).add(file.toString()).execute("Compiling " + file));
            String type = file.getParent().getFileName().toString();
            String filename = file.getFileName().toString();
            if (type.startsWith("values")) {
                filename = (filename.indexOf('.') != -1 ? filename.substring(0, filename.indexOf('.')) : filename) + ".arsc";
            }
            final Path compiledResourcePath = compiledResourcesOut.resolve(type + "_" + filename + ".flat");
            Preconditions.checkArgument(Files.exists(compiledResourcePath), "%s does not exists after aapt2 ran.", compiledResourcePath);
            return compiledResourcePath;
        }

        @Override
        public String toString() {
            return "ResourceCompiler.CompileTask(" + file + ")";
        }
    }

    private static class CompilingVisitor extends SimpleFileVisitor<Path> {

        private final ListeningExecutorService executorService;

        private final Path compiledResources;

        private final List<ListenableFuture<Path>> tasks = new ArrayList<>();

        private final Path aapt2;

        private final Revision buildToolsVersion;

        public CompilingVisitor(ListeningExecutorService executorService, Path compiledResources, Path aapt2, Revision buildToolsVersion) {
            this.executorService = executorService;
            this.compiledResources = compiledResources;
            this.aapt2 = aapt2;
            this.buildToolsVersion = buildToolsVersion;
        }

        @Override
        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
            // Ignore directories and "hidden" files that start with .
            if (!Files.isDirectory(file) && !file.getFileName().toString().startsWith(".")) {
                tasks.add(executorService.submit(new // compiledResources path.
                // compiledResources path.
                CompileTask(file, Files.createDirectories(compiledResources.resolve((file.isAbsolute() ? file.getRoot().relativize(file) : file).getParent().getParent())), aapt2, buildToolsVersion)));
            }
            return super.visitFile(file, attrs);
        }

        List<Path> getCompiledArtifacts() throws InterruptedException, ExecutionException {
            return Futures.allAsList(tasks).get();
        }
    }

    /**
     * Creates a new {@link ResourceCompiler}.
     */
    public static ResourceCompiler create(ListeningExecutorService executorService, Path compiledResources, Path aapt2, Revision buildToolsVersion) {
        return new ResourceCompiler(new CompilingVisitor(executorService, compiledResources, aapt2, buildToolsVersion));
    }

    private ResourceCompiler(CompilingVisitor compilingVisitor) {
        this.compilingVisitor = compilingVisitor;
    }

    /**
     * Adds a task to compile the directory using aapt2.
     */
    public void queueDirectoryForCompilation(Path resource) throws IOException {
        Files.walkFileTree(resource, compilingVisitor);
    }

    /**
     * Returns all paths of the aapt2 compiled resources.
     */
    public List<Path> getCompiledArtifacts() throws InterruptedException, ExecutionException {
        return compilingVisitor.getCompiledArtifacts();
    }
}

```


Overlapping Code:
```
ublic class ResourceCompiler {
private static final Logger logger = Logger.getLogger(ResourceCompiler.class.getName());
private final CompilingVisitor compilingVisitor;
private static class CompileTask implements Callable<Path> {
private final Path file;
private final Path compiledResourcesOut;
private final Path aapt2;
private final Revision buildToolsVcompiledResourcesOut, Path aapt2, Revision buildToolsVersion) {
this.file = file;
this.compiledResourcesOut = compiledResourcesOut;
this.aapt2 = aapt2;
this.buildToolsVersion = buildToolsVersion;
}
@Override
public Path call() throws Exception {
logg file));
String type = file.getParent().getFileName().toString();
String filename = file.getFileName().toString();
if (type.startsWith("values")) {
fiename.indexOf('.') != -1 ? filename.substring(0, filename.indexOf('.')) : filpiledResourcesOut.resolve(type + "_" + filename + ".fesourcePath;
}
@Override
public String toString() {
return "ResourceCompiler.CompileTask(" + file + ")";
}
}
private static class CompilingVisitor extends SimpleFileVisitor<Path> {
private final ListeningExecutorService executorService;
private final Path compiledResources;
private final List<ListenableFuture<Path>> tasks = new ArrayList<>();
private final Path aapt2;
private final Revision buildToolsVn) {
this.executorService = executorService;
this.compiledResources = compiledResources;
this.aapt2 = aapt2;
this.buildToolsVersion = buildToolsVersion
```
<Overlap Ratio: 0.6919385796545106>

---

--- 309 --
Question ID: 56fb1f9c5d91901b20d488ac07ac5c45430043f7
Original Code:
```
public class U3_L6_Activity_One {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        System.out.println("Enter a number in the twenties");
        int num = scan.nextInt();
        if (!((num >= 20) && (num < 30))) {
            System.out.println("That's not in the twenties!");
            num = 25;
        }
        System.out.println("Your number is " + num);
    }
}

```


Overlapping Code:
```
ctivity_One {
public static void main(String[] args) {
Scanner scan = new Scanner(System.in);
System.out.println("Enter a number in the twenties");
iem.out.println("That's not in the twenties!");
num = 25;
}
System.out.println("Your num
```
<Overlap Ratio: 0.6920821114369502>

---

--- 310 --
Question ID: 40075c370335e4894f6de3f58bbf672ce1c03ed7
Original Code:
```
public class JsonArrayDiff implements JsonDiff {

    private final Map<Integer, JsonNode> valuesWithoutMatch = new HashMap<>();

    private final Map<Integer, JsonDiff> valuesWithMatch = new HashMap<>();

    private final Map<Integer, JsonNode> extraValues = new HashMap<>();

    private final Path path;

    public JsonArrayDiff(Path path) {
        this.path = path;
    }

    public void addNoMatch(int index, JsonNode expectedValue) {
        this.valuesWithoutMatch.put(index, expectedValue);
    }

    public void addDiff(int index, JsonDiff jsonDiff) {
        this.valuesWithMatch.put(index, jsonDiff);
    }

    public void addExtraItem(int index, JsonNode extraReceivedValue) {
        this.extraValues.put(index, extraReceivedValue);
    }

    @Override
    public double similarityRate() {
        final var totalArraySize = valuesWithoutMatch.size() + valuesWithMatch.size() + this.extraValues.size();
        final var totalSimilarityRate = valuesWithMatch.values().stream().mapToDouble(JsonDiff::similarityRate).sum();
        return totalSimilarityRate / totalArraySize;
    }

    @Override
    public void display(JsonDiffViewer viewer) {
        for (final var valuesWithMatch : valuesWithMatch.entrySet()) {
            if (valuesWithMatch.getValue().similarityRate() >= 99.9) {
                viewer.matchingProperty(valuesWithMatch.getValue());
            } else {
                viewer.nonMatchingProperty(valuesWithMatch.getValue());
            }
        }
        for (final var valuesWithoutMatch : valuesWithoutMatch.entrySet()) {
            viewer.missingProperty(new Path.ChainedPath(path(), String.valueOf(valuesWithoutMatch.getKey())), valuesWithoutMatch.getValue());
        }
        for (final var extraItem : extraValues.entrySet()) {
            viewer.extraProperty(new Path.ChainedPath(path(), String.valueOf(extraItem.getKey())), extraItem.getValue());
        }
    }

    @Override
    public Path path() {
        return this.path;
    }
}

```


Overlapping Code:
```
 implements JsonDiff {
private final Map<Integer, JsonNode> valuesWithoutMatch = new HashMap<>();
private final Map<Integer, JsonDiff> valuesWithMatch = new HashMap<>();
private final Map<Integer, JsonNode> extraValues = new HashMap<>();
private final Path path;
public JsonArrayDiff(Path path) {
this.path = path;
}
public void addNoMatch(int index, JsonNode expectedValue) {
this.valuesWithoutMatch.put(index, expectedValue);
}
public void addDiff(int index, JsonDiff jsonDiff) {
this.valuesWithMatch.put(index, jsonDiff);
}
public void addExtraItem(int index, JsonNode extraReceivedValue) {
this.extraValues.put(index, extraReceivedValue);
}
@Override
public double similarityRate() {
final var totalArraySize = valuesWithoutMatch.size() + valuesWithMatch.size() + this.extraValues.size();
final var totalSimilarityRate = valuesWithMatch.values().um();
return totalSimilarityRate / totalArraySize;
}
@Override
public void display(JsonDiffViewer viewer) {
for (final var valuesWithMatch : valuesWithMatch.entrySet()) {
if (valuesWithMatch.getValue().similarityRate() >= 99.9) {
viewer.matchingProperty(valuesWithMatch.getValue());
} else {
viewer.nonMatchingProperty(valuesWithMatch.getValue());
}
}
for (final var valuesWithoutMatch : valuesWithoutMatch.entrySet()) {
viewer.missingProperty(new Path.ChainedPath(path(), String.valueOf(valuesWithoutMatch.getKey())), valuesWithoutMatch.getValue());)) {
viewer.extraProperty(new Path.ChainedPath(path(), String.valueOf(extraItem.getKey())), extraItem.getValue());
}
}
@Override
public Path path() {

```
<Overlap Ratio: 0.9139150943396226>

---

--- 311 --
Question ID: 0a1afb5c947f6e859bce2ccb8a05da9ecf9f75e5
Original Code:
```
public class IgnoreExplicitForJoinedFalseValueWithPersistenceXmlTest {

    @RegisterExtension
    static QuarkusUnitTest runner = new QuarkusUnitTest().withApplicationRoot((jar) -> jar.addClass(MyEntity.class).addAsManifestResource("META-INF/persistence-discriminator-ignore-explicit-for-joined-false-value.xml", "persistence.xml").addAsResource("application-datasource-only.properties", "application.properties"));

    @Inject
    EntityManager em;

    @ActivateRequestContext
    @Test
    public void testFalseValue() {
        Map<String, Object> properties = em.getEntityManagerFactory().getProperties();
        // the PU is templatePU from the persistence.xml, not the default entity manager from application.properties
        assertEquals("templatePU", properties.get("hibernate.ejb.persistenceUnitName"));
        assertEquals("false", properties.get("hibernate.discriminator.ignore_explicit_for_joined"));
    }
}

```


Overlapping Code:
```
nedFalseValueWithPersistenceXmlTest {
@RegisterExtension
static QuarkusUnitTest runner = new QuarkusUnitTest().withApplicationRoot((jar) -> jar.addClINF/persistence-discriminator-ignore-explicit-for-Resource("application-datasource-only.properties", "application.properties"));
@Inject
EntityManager em;
@ActivateRequestContext
@Test
public void testFalseValue() {
Map<String, Object> properties = em.getEntityManagerFactory().getProperties();
// the PU is templatePU from the persistence.xml, not the default entity manager from application.properties
assertEquals("templatePU", properties.get("hibernate.ejb.persistenceUnitName"));
assertEquals("false", properties.get("hibernate.discriminator.ignore_explicit_fo
```
<Overlap Ratio: 0.8302325581395349>

---

--- 312 --
Question ID: 201d81bb57bfceee81740093f870c685ab999062
Original Code:
```
class Solution1 {

    private int[][] dx_dy = new int[][] { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };

    private void dfs(int[][] image, int i, int j) {
        if (i < 0 || j < 0 || i >= image.length || j >= image[0].length || image[i][j] != oldColor)
            return;
        image[i][j] = newColor;
        for (int[] offset : dx_dy) {
            dfs(image, i + offset[0], j + offset[1]);
        }
    }

    private int oldColor = 0, newColor = 0;

    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        this.oldColor = image[sr][sc];
        this.newColor = newColor;
        if (this.oldColor == this.newColor)
            return image;
        dfs(image, sr, sc);
        return image;
    }

    private static void test(int[][] image, int sr, int sc, int newColor) {
        Solution1 solution = new Solution1();
        int[][] ans = solution.floodFill(image, sr, sc, newColor);
        for (int[] ints : ans) {
            for (int i : ints) {
                System.out.print(i + " ");
            }
            System.out.println();
        }
        System.out.println();
    }

    public static void main(String[] args) {
        test(new int[][] { { 0, 0, 0 }, { 0, 1, 1 } }, 1, 1, 1);
        test(new int[][] { { 1, 1, 1 }, { 1, 1, 0 }, { 1, 0, 1 } }, 1, 1, 2);
    }
}

```


Overlapping Code:
```
 new int[][] { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };
privnt j) {
if (i < 0 || j < 0 || i >= image.length || j >= image[0return;
image[i][j] = newColor;
for (int[] offset : dx_dy) {
dfs(image, i + offset[0], j + offset[1]);
}
}
private int oldColor = 0, newColor = 0;
public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
this.oldColor = image[sr][sc];
this.newColor = newColor;
if (this.oldColor == thirn image;
}
private static void test(int[][] image, int sr, int sc, int newColor) {
Solution1 solution = new Solution1();
int[][] ans = solution.floodFill(image, sr, sc, newColor);
for (int[] ints : ans) {
for (int i : ints) {
System.out.print(i + " ");
}
System.out.println();
}
System.out.println();
}
public static void main(String[] args) {
test(new int[]] { { 1, 1, 1 }, { 1, 1, 0 }, { 1, 0, 1 } }, 1, 1,
```
<Overlap Ratio: 0.784037558685446>

---

--- 313 --
Question ID: 76a729674dee4fe36c1fccda5f23c96fd9c3eae6
Original Code:
```
public class ECSTaskTemplateTest {

    @Test
    public void shouldMerge() throws Exception {
        ECSTaskTemplate child = new ECSTaskTemplate("child-name", "child-label", null, "child-image", "child-repository-credentials", "EC2", "child-network-mode", "child-remoteFSRoot", 0, 0, 0, null, null, false, false, "child-containerUser", null, null, null, null, null, null, "parent");
        ECSTaskTemplate parent = new ECSTaskTemplate("parent-name", "parent-label", null, "parent-image", "parent-repository-credentials", "FARGATE", "parent-network-mode", "parent-remoteFSRoot", 0, 0, 0, null, null, false, false, "parent-containerUser", null, null, null, null, null, null, null);
        ECSTaskTemplate expected = new ECSTaskTemplate("child-name", "child-label", null, "child-image", "child-repository-credentials", "EC2", "child-network-mode", "child-remoteFSRoot", 0, 0, 0, null, null, false, false, "child-containerUser", null, null, null, null, null, null, null);
        ECSTaskTemplate result = child.merge(parent);
        assertTrue(EqualsBuilder.reflectionEquals(expected, result));
    }

    @Test
    public void shouldReturnSettingsFromParent() throws Exception {
        ECSTaskTemplate child = new // image is set to null
        // image is set to null
        ECSTaskTemplate(// image is set to null
        "child-name", // image is set to null
        "child-label", // image is set to null
        null, // image is set to null
        null, // image is set to null
        "child-repository-credentials", // image is set to null
        "EC2", "child-network-mode", "child-remoteFSRoot", 0, 0, 0, null, null, false, false, "child-containerUser", null, null, null, null, null, null, "parent");
        ECSTaskTemplate parent = new ECSTaskTemplate("parent-name", "parent-label", null, "parent-image", "parent-repository-credentials", "FARGATE", "parent-network-mode", "parent-remoteFSRoot", 0, 0, 0, null, null, false, false, "parent-containerUser", null, null, null, null, null, null, null);
        ECSTaskTemplate expected = new ECSTaskTemplate("child-name", "child-label", null, "parent-image", "child-repository-credentials", "EC2", "child-network-mode", "child-remoteFSRoot", 0, 0, 0, null, null, false, false, "child-containerUser", null, null, null, null, null, null, null);
        ECSTaskTemplate result = child.merge(parent);
        assertTrue(EqualsBuilder.reflectionEquals(expected, result));
    }

    @Test
    public void shouldReturnChildIfNoParent() throws Exception {
        ECSTaskTemplate child = new // inheritFrom is null
        // inheritFrom is null
        ECSTaskTemplate(// inheritFrom is null
        "child-name", // inheritFrom is null
        "child-label", // inheritFrom is null
        null, // inheritFrom is null
        "child-image", // inheritFrom is null
        "child-repository-credentials", // inheritFrom is null
        "EC2", // inheritFrom is null
        "child-network-mode", // inheritFrom is null
        "child-remoteFSRoot", // inheritFrom is null
        0, // inheritFrom is null
        0, // inheritFrom is null
        0, // inheritFrom is null
        null, // inheritFrom is null
        null, // inheritFrom is null
        false, // inheritFrom is null
        false, // inheritFrom is null
        "child-containerUser", // inheritFrom is null
        null, // inheritFrom is null
        null, // inheritFrom is null
        null, // inheritFrom is null
        null, // inheritFrom is null
        null, null, null);
        ECSTaskTemplate expected = new ECSTaskTemplate("child-name", "child-label", null, "child-image", "child-repository-credentials", "EC2", "child-network-mode", "child-remoteFSRoot", 0, 0, 0, null, null, false, false, "child-containerUser", null, null, null, null, null, null, null);
        ECSTaskTemplate result = child.merge(null);
        assertTrue(EqualsBuilder.reflectionEquals(expected, result));
    }
}

```


Overlapping Code:
```
void shouldMerge() throws Exception {
ECSTaskTempll, "child-image", "child-repository-credentials", "EC2", "child-network-mode", "child-remoteFSRoot","child-containerUser", null, null, null, null, null, null, "parent");
ECSTaskTemplate parent = new  null, "parent-image", "parent-repository-credentials", "FARGATE", "parent-network-mode", "parent-remotent-containerUser", null, null, null, null, null, null, null);
ECSTaskTemplate expected = new ECSTaskl, "child-image", "child-repository-credentials", "EC2", "child-network-mode", "child-remoteFSRoot","child-containerUser", null, null, null, null, null, null, null);
ECSTaskTemplate result = child.merge(parent);
assertTrue(EqualsBuilder.reflectionEquals(expected, result));
}
@Test
public void shouldReturnSettingsFromParent() throws Exception {
ECSTaskTemplate child = new"EC2", "child-network-mode", "child-remoteFSRoot","child-containerUser", null, null, null, null, null, null, "parent");
ECSTaskTemplate parent = new  null, "parent-image", "parent-repository-credentials", "FARGATE", "parent-network-mode", "parent-remotent-containerUser", null, null, null, null, null, null, null);
ECSTaskTemplate expected = new ECSTaskent-image", "child-repository-credentials", "EC2", "child-network-mode", "child-remoteFSRoot","child-containerUser", null, null, null, null, null, null, null);
ECSTaskTemplate result = child.merge(parent);
assertTrue(EqualsBuilder.reflectionEquals(expected, result));
}
@Test
public void shouldReturnChildIfNoParen
```
<Overlap Ratio: 0.6435344827586207>

---

--- 314 --
Question ID: 8c59e2cfdbf6b17cb077cdd8149140816c81fd79
Original Code:
```
public class CustomerBoardComponent extends Composite implements HasLogger {

    public static final String FILTER_TF_ID = textfieldID().apply(CustomerBoardComponent.class, "filterTF");

    public static final String FILTER_TF_PLACEHOLDER = FILTER_TF_ID + "." + "placeholder";

    public static final String CLEAR_FILTER_BTN_ID = buttonID().apply(CustomerBoardComponent.class, "clearFilterBTN");

    public static final String CLEAR_FILTER_BTN_DESCRIPTION = CLEAR_FILTER_BTN_ID + "." + "description";

    public static final String NEW_CUSTOMER_BTN_ID = buttonID().apply(CustomerBoardComponent.class, "newCustomerBTN");

    public static final String NEW_CUSTOMER_BTN_CAPTION = NEW_CUSTOMER_BTN_ID + "." + "caption";

    public static final String DATA_GRID_ID = gridID().apply(CustomerBoardComponent.class, "dataGrid");

    public static final String DATA_GRID_COL = DATA_GRID_ID + "." + "col";

    public static final String DATA_GRID_COL_CAPTION_FIRST_NAME = DATA_GRID_COL + "." + "firstName";

    public static final String DATA_GRID_COL_CAPTION_LAST_NAME = DATA_GRID_COL + "." + "lastName";

    public static final String DATA_GRID_COL_CAPTION_EMAIL = DATA_GRID_COL + "." + "email";

    public static final String CUSTOMERFORM_ID = genericID().apply(CustomerForm.class, CustomerBoardComponent.class, "customerForm");

    @Inject
    private CustomerService service;

    @Inject
    private PropertyService propertyService;

    @Inject
    private CustomerForm customerForm;

    private final Grid<Customer> grid = new Grid<>();

    private final TextField filterText = new TextField();

    private final Button clearFilterTextBtn = new Button();

    private final Button addCustomerBtn = new Button();

    private Registration deleteRegistration;

    private Registration saveRegistration;

    private String resolve(String key) {
        return propertyService.resolve(key);
    }

    @PostConstruct
    private void postConstruct() {
        filterText.setId(FILTER_TF_ID);
        filterText.setPlaceholder(resolve(FILTER_TF_PLACEHOLDER));
        filterText.addValueChangeListener(e -> updateGridItems());
        filterText.setValueChangeMode(ValueChangeMode.LAZY);
        clearFilterTextBtn.setId(CLEAR_FILTER_BTN_ID);
        clearFilterTextBtn.setIcon(VaadinIcons.CLOSE_BIG);
        clearFilterTextBtn.setDescription(resolve(CLEAR_FILTER_BTN_DESCRIPTION));
        clearFilterTextBtn.addClickListener(e -> filterText.clear());
        addCustomerBtn.setId(NEW_CUSTOMER_BTN_ID);
        addCustomerBtn.setCaptionAsHtml(true);
        addCustomerBtn.setCaption(VaadinIcons.USER.getHtml());
        addCustomerBtn.setDescription(resolve(NEW_CUSTOMER_BTN_CAPTION));
        addCustomerBtn.setIconAlternateText(resolve(NEW_CUSTOMER_BTN_CAPTION));
        addCustomerBtn.addClickListener(e -> {
            grid.asSingleSelect().clear();
            customerForm.setCustomer(new Customer());
        });
        final Layout filtering = new CssLayout(filterText, clearFilterTextBtn);
        filtering.setStyleName(ValoTheme.LAYOUT_COMPONENT_GROUP);
        ((CssLayout) filtering).setResponsive(true);
        final Layout buttons = new HorizontalLayout(filtering, addCustomerBtn);
        buttons.setHeight(40, Sizeable.Unit.PIXELS);
        ((HorizontalLayout) buttons).setResponsive(true);
        grid.setId(DATA_GRID_ID);
        grid.addColumn(Customer::getFirstName).setCaption(resolve(DATA_GRID_COL_CAPTION_FIRST_NAME)).setId(DATA_GRID_COL_CAPTION_FIRST_NAME);
        grid.addColumn(Customer::getLastName).setCaption(resolve(DATA_GRID_COL_CAPTION_LAST_NAME)).setId(DATA_GRID_COL_CAPTION_LAST_NAME);
        grid.addColumn(Customer::getEmail).setCaption(resolve(DATA_GRID_COL_CAPTION_EMAIL)).setId(DATA_GRID_COL_CAPTION_EMAIL);
        grid.setColumnOrder(DATA_GRID_COL_CAPTION_FIRST_NAME, DATA_GRID_COL_CAPTION_LAST_NAME, DATA_GRID_COL_CAPTION_EMAIL);
        grid.asSingleSelect().addValueChangeListener(event -> {
            if (event.getValue() == null) {
                customerForm.setVisible(false);
            } else {
                customerForm.setCustomer(event.getValue());
            }
        });
        grid.setSizeFull();
        updateGridItems();
        customerForm.setId(CUSTOMERFORM_ID);
        customerForm.setVisible(false);
        final HorizontalLayout main = new HorizontalLayout(grid, customerForm);
        main.setSizeFull();
        main.setExpandRatio(grid, 1);
        final VerticalLayout compositionRoot = new VerticalLayout(buttons, main);
        compositionRoot.setExpandRatio(main, 1);
        compositionRoot.setSizeFull();
        setCompositionRoot(compositionRoot);
        deleteRegistration = customerForm.registerDeleteListener(customer -> {
            service.delete(customer);
            updateGridItems();
        });
        saveRegistration = customerForm.registerSaveListener(customer -> {
            service.save(customer);
            updateGridItems();
        });
    }

    @Override
    public void detach() {
        super.detach();
        ((CheckedExecutor) () -> deleteRegistration.remove()).execute();
        ((CheckedExecutor) () -> saveRegistration.remove()).execute();
    }

    private void updateGridItems() {
        grid.setItems(service.findAll(filterText.getValue()));
    }
}

```


Overlapping Code:
```
stomerBoardComponent extends Composite implements HasLogger {
public static final String FILTER_TF_ID = textfieldID().apply(CustomerBoardComponent.class, "filterTF");
public static final String FILTER_TF_PLACEHOLDER = FILTER_TF_ID + "." + "placeholder";
public static final String CLEAR_FILTER_BTN_ID = buttonID().apply(CustomerBoardComponent.class, "clearFilterBTN");
public static final String CLEAR_FILTER_BTN_DESCRIPTION = CLEAR_FILTER_BTN_ID + "." + "description";
public static final String NEW_CUSTOMER_BTN_ID = buttonID().apply(CustomerBoardComponent.class, "newCustomerBTN");
public static final String NEW_CUSTOMER_BTN_CAPTION = NEW_CUSTOMER_BTN_ID + "." + "caption";
public static final String DATA_GRID_ID = gridID().apply(CustomerBoardComponent.class, "dataGrid");
public static final String DATA_GRID_COL = DATA_GRID_ID + "." + "col";
public static final String DATA_GRID_COL_CAPTION_FIRST_NAME = DATA_GRID_COL + "." + "firstName";
public static final String DATA_GRID_COL_CAPTION_LAST_NAME = DATA_GRID_COL + "." + "lastName";
public static final String DATA_GRID_COL_CAPTION_EMAIL = DATA_GRID_COL + "." + "email";
public static final String CUSTOMERFORM_ID = genericID().apply(CustomerInject
private CustomerService service;
@Inject
private PropertyService propertyService;
@Inject
privatfinal Grid<Customer> grid = new Grid<>();
private final TextField filterText = new TextField();
private final Button clearFilterTextBtn = new Button();
private final Button addCustomerBtn = new Button();
private Registration deleteRegistration;
private Registration saveRegistration;
private String resolve(String key) {
return propertyService.resolve(key);
}
@PostConstruct
private void postConstruct() {
filterText.setId(FILTER_TF_ID);
filterText.setPlaceholder(resolve(FILTER_TF_PLACEHOLDER));
filterText.addValueChangeListener(e -> updateGridItems());
filterText.setValueChangeMode(ValueChangeMode.LAZY);
clearFilterTextBtn.setId(CLEAR_FILTER_BTN_ID);
clearFilterTextBtn.setIcon(VaadinIcons.CLOSE_BIG);
clearFilterTextBtn.setDescription(resolve(CLEAR_FILTER_BTN_DESCRIPTION));
clearFilterTextBtn.addClickListener(e -> filterText.clear());
addCust
```
<Overlap Ratio: 0.9426444833625219>

---

--- 315 --
Question ID: 4f01c8a8bfaf6520ab50b8203cdbd576b2539387
Original Code:
```
@TypeCapability(inputs = { "de.tudarmstadt.ukp.dkpro.core.api.lexmorph.type.pos.POS" })
public class POSTokenRatio extends FeatureExtractorResource_ImplBase implements FeatureExtractor {

    public static final String FN_NounRatio = "NounRatio";

    public static final String FN_VerbRatio = "VerbRatio";

    public static final String FN_AdjectivRatio = "AdjectivRatio";

    @Override
    public Set<Feature> extract(JCas jcas, TextClassificationTarget aTarget) throws TextClassificationException {
        int numberOfTokens = JCasUtil.select(jcas, POS.class).size();
        //Nouns, Verbs
        int numberOfNouns = 0;
        int numberOfVerbs = 0;
        int numberOfAdjectives = 0;
        for (POS pos : JCasUtil.select(jcas, POS.class)) {
            System.out.println(pos.getCoarseValue());
            if (pos.getCoarseValue().startsWith("N")) {
                numberOfNouns++;
            }
            if (pos.getCoarseValue().equals("VERB")) {
                numberOfVerbs++;
            }
            if (pos.getCoarseValue().equals("ADJ")) {
                numberOfAdjectives++;
            }
        }
        double nr = (1.0 * numberOfNouns) / numberOfTokens;
        double vr = (1.0 * numberOfVerbs) / numberOfTokens;
        double ar = (1.0 * numberOfAdjectives) / numberOfTokens;
        Set<Feature> features = new HashSet<Feature>();
        features.add(new Feature(FN_NounRatio, nr, FeatureType.NUMERIC));
        features.add(new Feature(FN_VerbRatio, vr, FeatureType.NUMERIC));
        features.add(new Feature(FN_AdjectivRatio, ar, FeatureType.NUMERIC));
        return features;
    }
}

```


Overlapping Code:
```
@TypeCapability(inputs = { "de.tudarmstadt.ukp.dkpro.core.api.lexmorph.type.pos.POS" })
public class  extends FeatureExtractorResource_ImplBase implements FeatureExtractor {
public static final String "NounRatio";
public static final String FN_VerbRatio = "VerbRatio";
public static final String FN_A
@Override
public Set<Feature> extract(JCas jcas, TextClassificationTarget aTarget) throws TextClassificationException = 0;
int numberOfVerbs = 0;
int numberOfAdjectivesor (POS pos : JCasUtil.select(jcas, POS.class)) {
System.out.println(pos.getCoarseValue());
fNouns++;
}
if (pos.getCoarseValue().equals("VERB"et<Feature> features = new HashSet<Feature>();
features.add(new Feature(FN_NounRatio, nr, FeatureType.NUMERIC));
features.add(new Feature(FN_VerbRatio, vr, FeatureType.NUMERIC));
features.add(new Feature(FN_AdjectivRatio, ar, FeatureType.NUMERIC));
return fe
```
<Overlap Ratio: 0.6446587537091988>

---

--- 316 --
Question ID: 147107bc0784d1e698608f00c42fa859e9ca63b2
Original Code:
```
public class DatabaseWriter {

    ProcessingEnvironment processingEnv;

    Elements elementUtils;

    Element database;

    String className;

    ClassName clazzName;

    String fileName;

    List<VariableElement> tables = new ArrayList<>();

    List<VariableElement> execOnCreate = new ArrayList<>();

    ExecutableElement onCreate;

    ExecutableElement onUpgrade;

    ExecutableElement onConfigure;

    int version;

    String outPackage;

    public DatabaseWriter(ProcessingEnvironment env, Elements elements, Element database) {
        this.processingEnv = env;
        this.elementUtils = env.getElementUtils();
        this.database = database;
        String databaseSchematicName = database.getSimpleName().toString();
        Database db = database.getAnnotation(Database.class);
        this.version = db.version();
        this.className = db.className();
        if (className.trim().isEmpty()) {
            this.className = databaseSchematicName;
        }
        this.outPackage = db.packageName();
        if (outPackage.trim().isEmpty()) {
            this.outPackage = elements.getPackageOf(database).getQualifiedName() + ".generated";
        }
        this.fileName = db.fileName();
        if (fileName.trim().isEmpty()) {
            this.fileName = CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, databaseSchematicName) + ".db";
        }
        clazzName = ClassName.get(outPackage, className);
        findAnnotations(database);
    }

    private void findAnnotations(Element element) {
        List<? extends Element> enclosedElements = element.getEnclosedElements();
        for (Element enclosedElement : enclosedElements) {
            findAnnotations(enclosedElement);
            Table table = enclosedElement.getAnnotation(Table.class);
            if (table != null) {
                tables.add((VariableElement) enclosedElement);
            }
            OnCreate onCreate = enclosedElement.getAnnotation(OnCreate.class);
            if (onCreate != null) {
                if (this.onCreate != null) {
                    error("Multiple OnCreate annotations found in " + database.getSimpleName().toString());
                }
                this.onCreate = (ExecutableElement) enclosedElement;
            }
            OnUpgrade onUpgrade = enclosedElement.getAnnotation(OnUpgrade.class);
            if (onUpgrade != null) {
                if (this.onUpgrade != null) {
                    error("Multiple OnUpgrade annotations found in " + database.getSimpleName().toString());
                }
                this.onUpgrade = (ExecutableElement) enclosedElement;
            }
            OnConfigure onConfigure = enclosedElement.getAnnotation(OnConfigure.class);
            if (onConfigure != null) {
                if (this.onConfigure != null) {
                    error("Multiple OnConfigure annotations found in " + database.getSimpleName().toString());
                }
                this.onConfigure = (ExecutableElement) enclosedElement;
            }
            ExecOnCreate execOnCreate = enclosedElement.getAnnotation(ExecOnCreate.class);
            if (execOnCreate != null) {
                this.execOnCreate.add((VariableElement) enclosedElement);
            }
        }
    }

    public void writeJava(Filer filer) throws IOException {
        JavaFileObject jfo = filer.createSourceFile(getFileName());
        Writer out = jfo.openWriter();
        TypeSpec.Builder databaseBuilder = TypeSpec.classBuilder(className).superclass(Clazz.SQLITE_OPEN_HELPER).addModifiers(Modifier.PUBLIC);
        FieldSpec versionSpec = FieldSpec.builder(int.class, "DATABASE_VERSION", Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL).initializer("$L", version).build();
        databaseBuilder.addField(versionSpec);
        for (VariableElement table : tables) {
            TypeElement tableClass = null;
            Table columns = table.getAnnotation(Table.class);
            try {
                columns.value();
            } catch (MirroredTypeException e) {
                TypeMirror mirror = e.getTypeMirror();
                tableClass = (TypeElement) processingEnv.getTypeUtils().asElement(mirror);
            }
            ClassName tableClassName = ClassName.get(tableClass);
            TableWriter tableWriter = new TableWriter(processingEnv, table, tableClassName);
            tableWriter.createTable(databaseBuilder);
            tableWriter.createValuesBuilder(filer, outPackage);
        }
        WriterUtils.singleton(databaseBuilder, clazzName, Clazz.CONTEXT);
        databaseBuilder.addField(Clazz.CONTEXT, "context", Modifier.PRIVATE);
        MethodSpec constructor = MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).addParameter(Clazz.CONTEXT, "context").addStatement("super(context.getApplicationContext(), $S, null, DATABASE_VERSION)", fileName).addStatement("this.context = context.getApplicationContext()").build();
        databaseBuilder.addMethod(constructor);
        databaseBuilder.addMethod(getOnCreateSpec());
        databaseBuilder.addMethod(getOnUpgradeSpec());
        if (onConfigure != null) {
            databaseBuilder.addMethod(getOnConfigureSpec());
        }
        JavaFile javaFile = JavaFile.builder(outPackage, databaseBuilder.build()).build();
        javaFile.writeTo(out);
        out.flush();
        out.close();
    }

    private MethodSpec getOnCreateSpec() {
        MethodSpec.Builder onCreateBuilder = MethodSpec.methodBuilder("onCreate").returns(void.class).addModifiers(Modifier.PUBLIC).addAnnotation(Override.class).addParameter(Clazz.SQLITE_DATABASE, "db");
        for (VariableElement table : tables) {
            onCreateBuilder.addStatement("db.execSQL($L)", table.getSimpleName().toString());
        }
        for (VariableElement exec : execOnCreate) {
            String variableName = exec.getSimpleName().toString();
            onCreateBuilder.addStatement("db.execSQL($T.$L)", exec.getEnclosingElement(), variableName);
        }
        if (onCreate != null) {
            List<? extends VariableElement> parameters = onCreate.getParameters();
            StringBuilder params = new StringBuilder();
            boolean first = true;
            for (VariableElement param : parameters) {
                if (first) {
                    first = false;
                } else {
                    params.append(", ");
                }
                TypeMirror paramType = param.asType();
                if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {
                    params.append("context");
                }
                if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {
                    params.append("db");
                }
            }
            String methodName = onCreate.getSimpleName().toString();
            onCreateBuilder.addStatement("$T.$L($L)", onCreate.getEnclosingElement(), methodName, params.toString());
        }
        return onCreateBuilder.build();
    }

    private MethodSpec getOnUpgradeSpec() {
        MethodSpec.Builder onUpgradeBuilder = MethodSpec.methodBuilder("onUpgrade").addModifiers(Modifier.PUBLIC).addAnnotation(Override.class).addParameter(Clazz.SQLITE_DATABASE, "db").addParameter(int.class, "oldVersion").addParameter(int.class, "newVersion");
        if (onUpgrade != null) {
            List<? extends VariableElement> parameters = onUpgrade.getParameters();
            StringBuilder params = new StringBuilder();
            boolean first = true;
            for (VariableElement param : parameters) {
                if (first) {
                    first = false;
                } else {
                    params.append(", ");
                }
                TypeMirror paramType = param.asType();
                if (Clazz.CONTEXT.equals(ClassName.get(paramType))) {
                    params.append("context");
                }
                if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {
                    params.append("db");
                }
                if (TypeName.get(int.class).equals(TypeName.get(paramType))) {
                    String name = param.getSimpleName().toString();
                    if ("oldVersion".equals(name)) {
                        params.append("oldVersion");
                    } else if ("newVersion".equals(name)) {
                        params.append("newVersion");
                    } else {
                        error("Unknown int parameter: " + name);
                    }
                }
            }
            String parent = ((TypeElement) onUpgrade.getEnclosingElement()).getQualifiedName().toString();
            String methodName = onUpgrade.getSimpleName().toString();
            onUpgradeBuilder.addStatement("$L.$L($L)", parent, methodName, params.toString());
        }
        return onUpgradeBuilder.build();
    }

    private MethodSpec getOnConfigureSpec() {
        MethodSpec.Builder onConfigureBuilder = MethodSpec.methodBuilder("onConfigure").addModifiers(Modifier.PUBLIC).addAnnotation(Override.class).addParameter(Clazz.SQLITE_DATABASE, "db");
        List<? extends VariableElement> parameters = onConfigure.getParameters();
        StringBuilder params = new StringBuilder();
        boolean first = true;
        for (VariableElement param : parameters) {
            if (first) {
                first = false;
            } else {
                params.append(", ");
            }
            TypeMirror paramType = param.asType();
            if (Clazz.SQLITE_DATABASE.equals(ClassName.get(paramType))) {
                params.append("db");
            } else {
                throw new IllegalArgumentException("OnConfigure does not support parameter " + paramType.toString());
            }
        }
        String parent = ((TypeElement) onConfigure.getEnclosingElement()).getQualifiedName().toString();
        String methodName = onConfigure.getSimpleName().toString();
        onConfigureBuilder.addStatement("$L.$L($L)", parent, methodName, params.toString());
        return onConfigureBuilder.build();
    }

    public void writeValues(Filer filer) throws IOException {
        JavaFileObject jfo = filer.createSourceFile(getValuesFileName());
        Writer out = jfo.openWriter();
        final String valuesPackage = outPackage + ".values";
        TypeSpec.Builder spec = TypeSpec.classBuilder(className + "Values").addModifiers(Modifier.PUBLIC);
        for (VariableElement table : tables) {
            Table tableAnnotation = table.getAnnotation(Table.class);
            String tableName = table.getConstantValue().toString();
            tableName = Character.toUpperCase(tableName.charAt(0)) + tableName.substring(1);
            String methodName = "for" + tableName;
            String valuesName = tableName + "ValuesBuilder";
            ClassName builderClass = ClassName.get(valuesPackage, valuesName);
            MethodSpec builderSpec = MethodSpec.methodBuilder(methodName).addModifiers(Modifier.PUBLIC).returns(builderClass).addStatement("return new $T()", builderClass).build();
            spec.addMethod(builderSpec);
        }
        JavaFile javaFile = JavaFile.builder(valuesPackage, spec.build()).build();
        javaFile.writeTo(out);
        out.flush();
        out.close();
    }

    private String getFileName() {
        return outPackage + "." + className;
    }

    private String getValuesFileName() {
        return outPackage + ".values." + className + "Values";
    }

    private void error(String error) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error);
    }
}

```


Overlapping Code:
```
rocessingEnvironment processingEnv;
Elements elementUtils;
Element database;
String className;
ClassName clazzName;
String fileName;
List<VariableElement> tables = new ArrayList<>();
List<VariableElement> execOnCreate = new ArrayList<>();
ExecutableElement onCreate;
ExecutableElement onUpgrade;
ExecutableElement onConfigure;
int version;
String outPackage;
public DatabaseWriter(ProcessingEnvironment env, Elements elements, Element database) {
this.processingEnv = env;
this.elementUtils = env.getElementUtils();
this.database = database;
String databaseSchematicName = database.getSimpleName().toString();
Database db = database.getAnnotation(Database.class);
this.version = db.version();
this.className = db.className();
if (className.trim().isEmpty()) {
this.className = databaseSchematicName;
}
this.outPackage = db.packageName();
if (outPackage.trim().isEmpty()) {
this.outPackage = elements.getPackageOf(database).getQualifiedName() + ".generated";
}
this.fileName = db.fileName();
if (fileNleName = CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, databaseSchematicName) + ".db";
}
clazzName = ClassName.get(outPackage, className);
findAnnotations(database);
}
private void findAnnotations(Element element) {
List<? extends Element> enclosedElements = element.getEnclosedElements();
for (Element enclosedElement : enclosedElements) {
findAnnotations(enclosedElement);
Table table = enclosedElement.getAnnotation(Table.class);
if (table != null) {
tables.add((VariableElement) enclosedElement);
}
OnCreate onCreate = enclosedElement.getAnnotation(OnCreate.class);
if (onCreate != null) {
if (this.onCreate != null) {
error("Multiple OnCreate annotations found in " + database.getSimpleName().toString());
}
this.onCreate = (ExecutableElement) enclosedElement;
}
OnUpgrade onUpgrade = enclosedElement.getAnnotation(OnUpgrade.class);
if (onUpgrade != null) {
if (this.onUpgrade != null) {
error("Multiple OnUpgr
```
<Overlap Ratio: 0.9575848303393214>

---

--- 317 --
Question ID: 234a5116347665188acce37b81c61d47cf6eb7ba
Original Code:
```
public class PurityAnnotator extends Annotator<PurityAnnotator.Purity> {

    PurityAnnotator() {
        super("purity", Purity.HEAP_MOD);
    }

    public static enum Purity {

        /**
         * Does not modify program state and always produces the same (or practically indistinguishable) result.
         */
        CONST,
        /**
         * Does not modify program state and produces the same (or practically indistinguishable) result
         * if local variables directly involved into expression don't change.
         */
        LOCAL_DEP,
        /**
         * Does not modify program state and produces the same (or practically indistinguishable) result
         * if heap does not change.
         */
        HEAP_DEP,
        /**
         * Does not modify program state.
         */
        SIDE_EFFECT_FREE,
        /**
         * May modify heap.
         */
        HEAP_MOD,
        /**
         * May modify heap and/or local variables.
         */
        LOCAL_MOD;

        Purity merge(Purity other) {
            return this.ordinal() > other.ordinal() ? this : other;
        }

        public boolean atLeast(Purity other) {
            return this.ordinal() <= other.ordinal();
        }
    }

    void annotate(Node node, FrameContext fc) {
        forExpressions(node, expr -> annotatePurity(expr, fc));
    }

    private Purity getOwnPurity(Expression expr, FrameContext fc) {
        switch(expr.getCode()) {
            case Inc:
            case PreIncrement:
            case PostIncrement:
            case Store:
            case CompoundAssignment:
                return Purity.LOCAL_MOD;
            case InvokeDynamic:
            case StoreElement:
            case PutField:
            case PutStatic:
                return Purity.HEAP_MOD;
            case InitObject:
                {
                    MethodReference mr = (MethodReference) expr.getOperand();
                    if (!fc.cf.isSideEffectFree(mr, true))
                        return Purity.HEAP_MOD;
                    if (Types.isImmutable(mr.getDeclaringType()))
                        return Purity.CONST;
                    return Purity.SIDE_EFFECT_FREE;
                }
            case NewArray:
            case InitArray:
                return Purity.SIDE_EFFECT_FREE;
            case GetField:
                if (fc.cf.isKnownEffectivelyFinal(new MemberInfo((MemberReference) expr.getOperand())) && !fc.md.isConstructor()) {
                    return Purity.CONST;
                }
                return Purity.HEAP_DEP;
            case GetStatic:
                if (fc.cf.isKnownEffectivelyFinal(new MemberInfo((MemberReference) expr.getOperand())) && !fc.md.isTypeInitializer()) {
                    return Purity.CONST;
                }
                return Purity.HEAP_DEP;
            case LoadElement:
                return Purity.HEAP_DEP;
            case InvokeSpecial:
            case InvokeStatic:
            case InvokeVirtual:
            case InvokeInterface:
                {
                    MethodReference mr = (MethodReference) expr.getOperand();
                    if (Methods.isPure(mr)) {
                        boolean indistinguishable = mr.getReturnType().isVoid() || mr.getReturnType().isPrimitive() || Types.isImmutable(mr.getReturnType());
                        if (indistinguishable) {
                            return Purity.CONST;
                        }
                        return Purity.SIDE_EFFECT_FREE;
                    }
                    if (fc.cf.isSideEffectFree(mr, expr.getCode() == AstCode.InvokeSpecial)) {
                        return Purity.SIDE_EFFECT_FREE;
                    }
                    return Purity.HEAP_MOD;
                }
            case Load:
                return Purity.LOCAL_DEP;
            default:
                return Purity.CONST;
        }
    }

    private Purity annotatePurity(Expression expr, FrameContext fc) {
        Purity purity = Purity.CONST;
        for (Expression child : expr.getArguments()) {
            purity = purity.merge(annotatePurity(child, fc));
        }
        if (Inf.CONST.getValue(expr) != null) {
            // statically known constant
            purity = Purity.CONST;
        } else {
            purity = purity.merge(getOwnPurity(expr, fc));
        }
        putIfAbsent(expr, purity);
        return purity;
    }

    @Override
    public Purity get(Expression expr) {
        return super.get(expr);
    }

    public boolean isPure(Expression expr) {
        return get(expr).atLeast(Purity.LOCAL_DEP);
    }

    public boolean isSideEffectFree(Expression expr) {
        return get(expr).atLeast(Purity.SIDE_EFFECT_FREE);
    }
}

```


Overlapping Code:
```
r extends Annotator<PurityAnnotator.Purity> {
PurityAnnotator() {
super("purity", Purity.HEAP_MOD);
}
public static enum Purity {
/**
* Does not modify program state and always produces the same (or practically indistinguishable) result.
*/
CONST,
/**
* Does not modify program state and produces the same (or practically indistinguishable) result
* if local variables directly involved into expression don't change.
*/
LOCAL_DEP,
/**
* Does not modify program state and produces the same (or practically indistinguishable) result
* if heap does not m state.
*/
SIDE_EFFECT_FREE,
/**
* May modify heaher) {
return this.ordinal() > other.ordinal() ? this : otr) {
return this.ordinal() <= other.ordinal();
}
}
void annotate(Node node, FrameContext fc) {
forExpressions(node, expr -> annotatePurity(expr, fc));nc:
case PreIncrement:
case PostIncrement:
case Store:
case CompoundAssignment:
return Purity.LOCAL_MOD;
case InvokeDynamic:
case StoreElement:
case PutField:
case PutStatic:
return Purity.HEAP_MOD;
c{
MethodReference mr = (MethodReference) expr.getOperand();
if (!fc.cf.isSideEffectFree(mr, true))
return Purity.HEAP_MOD;
if (Types.isImmutable(mr.getDeclaringType()))
return Purity.CONST;
return Purity.SIDE_EFFECT_FREE;
}
case NewArray:
case InitArray:
return Purity.SIDE_EFFECT_FREc.cf.isKnownEffectivelyFinal(new MemberInfo((MemberReference) expr.getOperand(
```
<Overlap Ratio: 0.7779670641680864>

---

--- 318 --
Question ID: c96c4ecc65c9873bc3aeb3bef98ea74ea5e3c409
Original Code:
```
public class CryptUtilsTest {

    private static final Logger LOG = LoggerFactory.getLogger(CryptUtilsTest.class);

    @Test
    public void testPositive() throws Exception {
        CryptUtils cu = new CryptUtils();
        long encStartTime = System.currentTimeMillis();
        String result1a = cu.encrypt("msg", "pwd");
        String result1b = cu.encrypt("msg", "pwd");
        String result2 = cu.encrypt("msg", "pwd2");
        long encEndTime = System.currentTimeMillis();
        LOG.info(result1a);
        LOG.info(result1b);
        LOG.info(result2);
        assertNotEquals(result1a, result1b);
        assertNotEquals(result1a, result2);
        long decStartTime = System.currentTimeMillis();
        assertEquals("msg", cu.decrypt(result1a, "pwd"));
        assertEquals("msg", cu.decrypt(result1b, "pwd"));
        assertEquals("msg", cu.decrypt(result2, "pwd2"));
        long decEndTime = System.currentTimeMillis();
        LOG.info(String.format("encryption speed: %.2f msgs/second, decryption speed: %.2f msgs/second", 3000.0 / (encEndTime - encStartTime), 3000.0 / (decEndTime - decStartTime)));
    }

    @Test(expected = AEADBadTagException.class)
    public void testWrongPwd() throws Exception {
        CryptUtils cu = new CryptUtils();
        String result1a = cu.encrypt("msg", "pwd");
        cu.decrypt(result1a, "wrongpwd");
    }

    @Test(expected = AEADBadTagException.class)
    public void testWrongParams() throws Exception {
        CryptUtils cu = new CryptUtils();
        String result1a = cu.encrypt("msg", "pwd");
        cu.setGcmTagLength(12);
        cu.decrypt(result1a, "pwd");
    }

    @Test(expected = AEADBadTagException.class)
    public void testWrongParams2() throws Exception {
        CryptUtils cu = new CryptUtils();
        String result1a = cu.encrypt("msg", "pwd");
        cu.setKeySize(192);
        cu.decrypt(result1a, "pwd");
    }
}

```


Overlapping Code:
```
tUtilsTest {
private static final Logger LOG = LoggerFactory.getLogger(CryptUtilsTest.class);
@Test
public void testPositive() throws Exception {
CryptUtils cu = new CryptUtils(tartTime = System.currentTimeMillis();
String result1a = cu.encrypt("msg", "pwd");
String result1b = cu.encrypt("msg", "pwd");
String result2 = cu.encrypt("msg", "pwd2");
long encEndTime = System.currentTimeMillis();
LOG.info(resuertNotEquals(result1a, result1b);
assertNotEquals(artTime = System.currentTimeMillis();
assertEquals("msg", cu.decrypt(result1a, "pwd"));
assertEquals("msg", cu.decrypt(result1b, "pwd"));
assertEquals("msg", cu.decrypt(result2, "pwd2"));
long decEndTime = System.currentTimeMillis();
LOG.info(String.format("encryption speed: %.2f msgs/second, decryption speed: %.2f ms
@Test(expected = AEADBadTagException.class)
public void testWrongPwd() throws Exception {
CryptUtils cu = new CryptUtils();
String result1a = cu.encrypt("msg", "pwd");
cu.
@Test(expected = AEADBadTagException.class)
public void testWrongParams() throws Exception {
CryptUtils cu = new CryptUtils();
String result1a = cu.encrypt("msg", "pwd");
cu.setGcmTagLength(12);
cu.decr
@Test(expected = AEADBadTagException.class)
public void testWrongParams2() throws Exception {
CryptUtils cu = new CryptUtils();
String result1a = cu.encrypt("msg", "pwd");
cu.
```
<Overlap Ratio: 0.8141104294478527>

---

--- 319 --
Question ID: 18b49af96dd5814b6f008015faacfeda2a05682a
Original Code:
```
@Component
@Description("Ends execution of entity event.")
public class EntityEventEndProcessor extends CoreEventProcessor<IdmEntityEventDto> {

    public static final String PROCESSOR_NAME = "entity-event-end-processor";

    //
    @Autowired
    private IdmEntityEventService service;

    public EntityEventEndProcessor() {
        super(EntityEventType.EXECUTE);
    }

    @Override
    public String getName() {
        return PROCESSOR_NAME;
    }

    @Override
    public EventResult<IdmEntityEventDto> process(EntityEvent<IdmEntityEventDto> event) {
        IdmEntityEventDto entityEvent = event.getContent();
        entityEvent.setEventEnded(ZonedDateTime.now());
        entityEvent = service.save(entityEvent);
        event.setContent(entityEvent);
        //
        return new DefaultEventResult<>(event, this);
    }

    /**
     * Asynchronous processing can be disabled
     */
    @Override
    public boolean conditional(EntityEvent<IdmEntityEventDto> event) {
        return event.getContent().getId() != null;
    }

    @Override
    public int getOrder() {
        // after process
        return 1000;
    }
}

```


Overlapping Code:
```
ion of entity event.")
public class EntityEventEndProcessor extends CoreEventProcessor<IdmEntityEventDto> {
public static final String PROCESSOR_NAME = "entity-eventEventEndProcessor() {
super(EntityEventType.EXECUTE);
}
@Override
public String getName() {
return PROCESSOR_NAME;
}
@Override
public EventResult<IdmEntityEventDto> process(EntityEvent<IdmEntityEventDto> event) {
IdmEntityEventDto entityEvent = event.getContent();
entityEvent.setEventEnded(ZonedDateTime.now());
entityEvent = service.save(entityEvent);
event.setContent(entityEvent);
//
return new DefaultEventResult<>(event, this);
}
/**
*ronous processing can be disabled
*/
@Override
public boolean conditional(EntityEvent<IdmEntityEventDto> event) {
return event.getContent().getId() != 
```
<Overlap Ratio: 0.7901878914405011>

---

--- 320 --
Question ID: 16a60673c47ed31ef3e70caf496702cafa6f7bfd
Original Code:
```
public class KeyItem extends Item {

    public static final String ID = "lock_key";

    public static final String TEX_BASE = "lock_key_";

    private static final int ICONS_COUNT = 3;

    private IIcon[] icons = new IIcon[ICONS_COUNT];

    public KeyItem() {
        setUnlocalizedName(ID);
    }

    @Override
    public boolean showDurabilityBar(ItemStack stack) {
        return false;
    }

    @Override
    public boolean onItemUse(ItemStack itemStack, EntityPlayer player, World world, int x, int y, int z, int side, float hitX, float hitY, float hitZ) {
        if (!itemStack.hasTagCompound())
            return false;
        final LockObject lock = LockObject.find(world, x, y, z);
        if (lock == null || lock.getLockType() == LockType.DIGITAL)
            return false;
        final String secret = itemStack.getTagCompound().getString("secret");
        if (lock.canUnlockWith(secret)) {
            lock.toggleLocked();
            if (!world.isRemote) {
                final String msg = lock.isLocked() ? "more.lock.locked" : "more.lock.unlocked";
                player.addChatMessage(new ChatComponentTranslation(msg));
            }
        }
        return true;
    }

    @Override
    public IIcon getIconIndex(ItemStack stack) {
        if (!stack.hasTagCompound() || stack.getTagCompound().getString("secret").isEmpty())
            return icons[0];
        final String secret = stack.getTagCompound().getString("secret");
        // use second char, because first one can be minus
        final int iconId = secret.charAt(1) % ICONS_COUNT;
        return icons[iconId];
    }

    @Override
    public void registerIcons(IIconRegister p_94581_1_) {
        int i = 0;
        while (i < ICONS_COUNT) try {
            icons[i] = p_94581_1_.registerIcon(Bootstrap.MODID + ":" + TEX_BASE + (i + 1));
        } finally {
            ++i;
        }
    }

    public static ItemStack makeKeyItem(String secret) {
        final ItemStack stack = GameRegistry.findItemStack(Bootstrap.MODID, KeyItem.ID, 1);
        final NBTTagCompound compound = new NBTTagCompound();
        compound.setString("secret", secret);
        stack.setTagCompound(compound);
        return stack;
    }
}

```


Overlapping Code:
```
Item extends Item {
public static final String ID = "lock_key";
public static final String TEX_BASE = "lock_key_";
private static final int ICONS_COUNT = 3;
private IIcon[] icons = new IIcon[ICONS_COUNT];
public KeyItem() {
setUnlocalizedName(ID);
}
@Override
public boolean showDurabilityBar(ItemStack stack) {
return false;
}
@Override
public boolean onItemUse(ItemStack itemStack, EntityPlayer player, World world, int x, int y, int z, int side, float hitX, float hitY, float hitZ) {
if (!itemStack.hasTagCompound())
return false;
final LockObject lock = LockObject.find(world, x, y, z);
if (lock == null || lock.getLockType() == LockType.DIGITAL)
return false;
final String secret = itemStack.getTagCompound().getString("secret");
if (lock.canUnlockWith(secret)) {
lock.toggleLocked();
if (!world.isRemote) {
final String msg = lock.isLocked() ? "more.lock.locked" : "more.lock.unlocked";
player.addChatMessage(new ChatComponentTranslation(msg));
}
}
return true;
}
@Override
public IIcon getIconIndex(ItemStack stack) {
if (!stack.hasTagCompound() || stack.getTagCompound().getString("secret").isEmpty())
return icons[0];
final String secret = stack.getTagCompound().getString(;
}
@Override
public void registerIcons(IIconRegister p_94581_1_) {
ip_94581_1_.registerIcon(Bootstrap.MODID + ":" + TEeyItem(String secret) {
final ItemStack stack = GameRegistry.findItemStack(Bootstrap.MODID, KeyItem.ID, 1);
final NBTTagCompound compound = new NBTTagCompound();
compound.setString("secret", secret);

```
<Overlap Ratio: 0.8251786695986806>

---

--- 321 --
Question ID: f9adf1391613a41a2b211c8031b0e6fa8832d4dc
Original Code:
```
public class ApiOvhSslGateway extends ApiOvhBase {

    public ApiOvhSslGateway(ApiOvhCore core) {
        super(core);
    }

    /**
     * Launch a contact change procedure
     *
     * REST: POST /sslGateway/{serviceName}/changeContact
     * @param contactAdmin [required] The contact to set as admin contact
     * @param contactTech [required] The contact to set as tech contact
     * @param contactBilling [required] The contact to set as billing contact
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public ArrayList<Long> serviceName_changeContact_POST(String serviceName, String contactAdmin, String contactBilling, String contactTech) throws IOException {
        String qPath = "/sslGateway/{serviceName}/changeContact";
        StringBuilder sb = path(qPath, serviceName);
        HashMap<String, Object> o = new HashMap<String, Object>();
        addBody(o, "contactAdmin", contactAdmin);
        addBody(o, "contactBilling", contactBilling);
        addBody(o, "contactTech", contactTech);
        String resp = exec(qPath, "POST", sb.toString(), o);
        return convertTo(resp, t1);
    }

    private static TypeReference<ArrayList<Long>> t1 = new TypeReference<ArrayList<Long>>() {
    };

    /**
     * Get this object properties
     *
     * REST: GET /sslGateway/{serviceName}/serviceInfos
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public OvhService serviceName_serviceInfos_GET(String serviceName) throws IOException {
        String qPath = "/sslGateway/{serviceName}/serviceInfos";
        StringBuilder sb = path(qPath, serviceName);
        String resp = exec(qPath, "GET", sb.toString(), null);
        return convertTo(resp, OvhService.class);
    }

    /**
     * Alter this object properties
     *
     * REST: PUT /sslGateway/{serviceName}/serviceInfos
     * @param body [required] New object properties
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public void serviceName_serviceInfos_PUT(String serviceName, OvhService body) throws IOException {
        String qPath = "/sslGateway/{serviceName}/serviceInfos";
        StringBuilder sb = path(qPath, serviceName);
        exec(qPath, "PUT", sb.toString(), body);
    }

    /**
     * Renew your SSL certificates
     *
     * REST: POST /sslGateway/{serviceName}/renewCertificate
     * @param domain [required] Domain on which you want to renew certificate
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public ArrayList<String> serviceName_renewCertificate_POST(String serviceName, String domain) throws IOException {
        String qPath = "/sslGateway/{serviceName}/renewCertificate";
        StringBuilder sb = path(qPath, serviceName);
        HashMap<String, Object> o = new HashMap<String, Object>();
        addBody(o, "domain", domain);
        String resp = exec(qPath, "POST", sb.toString(), o);
        return convertTo(resp, t2);
    }

    private static TypeReference<ArrayList<String>> t2 = new TypeReference<ArrayList<String>>() {
    };

    /**
     * Terminate your service
     *
     * REST: POST /sslGateway/{serviceName}/terminate
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public String serviceName_terminate_POST(String serviceName) throws IOException {
        String qPath = "/sslGateway/{serviceName}/terminate";
        StringBuilder sb = path(qPath, serviceName);
        String resp = exec(qPath, "POST", sb.toString(), null);
        return convertTo(resp, String.class);
    }

    /**
     * Get this object properties
     *
     * REST: GET /sslGateway/{serviceName}/domain/{id}
     * @param serviceName [required] The internal name of your SSL Gateway
     * @param id [required] Id of your domain
     *
     * API beta
     */
    public OvhDomain serviceName_domain_id_GET(String serviceName, Long id) throws IOException {
        String qPath = "/sslGateway/{serviceName}/domain/{id}";
        StringBuilder sb = path(qPath, serviceName, id);
        String resp = exec(qPath, "GET", sb.toString(), null);
        return convertTo(resp, OvhDomain.class);
    }

    /**
     * Detach a domain from your SSL Gateway
     *
     * REST: DELETE /sslGateway/{serviceName}/domain/{id}
     * @param serviceName [required] The internal name of your SSL Gateway
     * @param id [required] Id of your domain
     *
     * API beta
     */
    public void serviceName_domain_id_DELETE(String serviceName, Long id) throws IOException {
        String qPath = "/sslGateway/{serviceName}/domain/{id}";
        StringBuilder sb = path(qPath, serviceName, id);
        exec(qPath, "DELETE", sb.toString(), null);
    }

    /**
     * Domains attached to your SSL Gateway
     *
     * REST: GET /sslGateway/{serviceName}/domain
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public ArrayList<Long> serviceName_domain_GET(String serviceName) throws IOException {
        String qPath = "/sslGateway/{serviceName}/domain";
        StringBuilder sb = path(qPath, serviceName);
        String resp = exec(qPath, "GET", sb.toString(), null);
        return convertTo(resp, t1);
    }

    /**
     * Attach a new domain to your SSL Gateway
     *
     * REST: POST /sslGateway/{serviceName}/domain
     * @param domain [required] Domain to attach
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public OvhDomain serviceName_domain_POST(String serviceName, String domain) throws IOException {
        String qPath = "/sslGateway/{serviceName}/domain";
        StringBuilder sb = path(qPath, serviceName);
        HashMap<String, Object> o = new HashMap<String, Object>();
        addBody(o, "domain", domain);
        String resp = exec(qPath, "POST", sb.toString(), o);
        return convertTo(resp, OvhDomain.class);
    }

    /**
     * Servers attached to your SSL Gateway
     *
     * REST: GET /sslGateway/{serviceName}/server
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public ArrayList<Long> serviceName_server_GET(String serviceName) throws IOException {
        String qPath = "/sslGateway/{serviceName}/server";
        StringBuilder sb = path(qPath, serviceName);
        String resp = exec(qPath, "GET", sb.toString(), null);
        return convertTo(resp, t1);
    }

    /**
     * Add a new server to your SSL Gateway
     *
     * REST: POST /sslGateway/{serviceName}/server
     * @param port [required] Port of your server
     * @param address [required] IPv4 address of your server
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public OvhServer serviceName_server_POST(String serviceName, String address, Long port) throws IOException {
        String qPath = "/sslGateway/{serviceName}/server";
        StringBuilder sb = path(qPath, serviceName);
        HashMap<String, Object> o = new HashMap<String, Object>();
        addBody(o, "address", address);
        addBody(o, "port", port);
        String resp = exec(qPath, "POST", sb.toString(), o);
        return convertTo(resp, OvhServer.class);
    }

    /**
     * Get this object properties
     *
     * REST: GET /sslGateway/{serviceName}/server/{id}
     * @param serviceName [required] The internal name of your SSL Gateway
     * @param id [required] Id of your server
     *
     * API beta
     */
    public OvhServer serviceName_server_id_GET(String serviceName, Long id) throws IOException {
        String qPath = "/sslGateway/{serviceName}/server/{id}";
        StringBuilder sb = path(qPath, serviceName, id);
        String resp = exec(qPath, "GET", sb.toString(), null);
        return convertTo(resp, OvhServer.class);
    }

    /**
     * Alter this object properties
     *
     * REST: PUT /sslGateway/{serviceName}/server/{id}
     * @param body [required] New object properties
     * @param serviceName [required] The internal name of your SSL Gateway
     * @param id [required] Id of your server
     *
     * API beta
     */
    public void serviceName_server_id_PUT(String serviceName, Long id, OvhServer body) throws IOException {
        String qPath = "/sslGateway/{serviceName}/server/{id}";
        StringBuilder sb = path(qPath, serviceName, id);
        exec(qPath, "PUT", sb.toString(), body);
    }

    /**
     * Remove a server
     *
     * REST: DELETE /sslGateway/{serviceName}/server/{id}
     * @param serviceName [required] The internal name of your SSL Gateway
     * @param id [required] Id of your server
     *
     * API beta
     */
    public void serviceName_server_id_DELETE(String serviceName, Long id) throws IOException {
        String qPath = "/sslGateway/{serviceName}/server/{id}";
        StringBuilder sb = path(qPath, serviceName, id);
        exec(qPath, "DELETE", sb.toString(), null);
    }

    /**
     * Task for this SSL Gateway
     *
     * REST: GET /sslGateway/{serviceName}/task
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public ArrayList<Long> serviceName_task_GET(String serviceName) throws IOException {
        String qPath = "/sslGateway/{serviceName}/task";
        StringBuilder sb = path(qPath, serviceName);
        String resp = exec(qPath, "GET", sb.toString(), null);
        return convertTo(resp, t1);
    }

    /**
     * Get this object properties
     *
     * REST: GET /sslGateway/{serviceName}/task/{id}
     * @param serviceName [required] The internal name of your SSL Gateway
     * @param id [required] Id of the task
     *
     * API beta
     */
    public OvhTask serviceName_task_id_GET(String serviceName, Long id) throws IOException {
        String qPath = "/sslGateway/{serviceName}/task/{id}";
        StringBuilder sb = path(qPath, serviceName, id);
        String resp = exec(qPath, "GET", sb.toString(), null);
        return convertTo(resp, OvhTask.class);
    }

    /**
     * Ip subnet used by OVH to nat requests to your SSL Gateway backends.
     *
     * REST: GET /sslGateway/{serviceName}/natIp
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public ArrayList<OvhNatIps> serviceName_natIp_GET(String serviceName) throws IOException {
        String qPath = "/sslGateway/{serviceName}/natIp";
        StringBuilder sb = path(qPath, serviceName);
        String resp = exec(qPath, "GET", sb.toString(), null);
        return convertTo(resp, t3);
    }

    private static TypeReference<ArrayList<OvhNatIps>> t3 = new TypeReference<ArrayList<OvhNatIps>>() {
    };

    /**
     * Get this object properties
     *
     * REST: GET /sslGateway/{serviceName}
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public OvhSslGateway serviceName_GET(String serviceName) throws IOException {
        String qPath = "/sslGateway/{serviceName}";
        StringBuilder sb = path(qPath, serviceName);
        String resp = exec(qPath, "GET", sb.toString(), null);
        return convertTo(resp, OvhSslGateway.class);
    }

    /**
     * Alter this object properties
     *
     * REST: PUT /sslGateway/{serviceName}
     * @param body [required] New object properties
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public void serviceName_PUT(String serviceName, OvhSslGateway body) throws IOException {
        String qPath = "/sslGateway/{serviceName}";
        StringBuilder sb = path(qPath, serviceName);
        exec(qPath, "PUT", sb.toString(), body);
    }

    /**
     * Confirm termination of your service
     *
     * REST: POST /sslGateway/{serviceName}/confirmTermination
     * @param futureUse [required] What next after your termination request
     * @param reason [required] Reason of your termination request
     * @param commentary [required] Commentary about your termination request
     * @param token [required] The termination token sent by mail to the admin contact
     * @param serviceName [required] The internal name of your SSL Gateway
     *
     * API beta
     */
    public String serviceName_confirmTermination_POST(String serviceName, String commentary, OvhTerminationFutureUseEnum futureUse, OvhTerminationReasonEnum reason, String token) throws IOException {
        String qPath = "/sslGateway/{serviceName}/confirmTermination";
        StringBuilder sb = path(qPath, serviceName);
        HashMap<String, Object> o = new HashMap<String, Object>();
        addBody(o, "commentary", commentary);
        addBody(o, "futureUse", futureUse);
        addBody(o, "reason", reason);
        addBody(o, "token", token);
        String resp = exec(qPath, "POST", sb.toString(), o);
        return convertTo(resp, String.class);
    }

    /**
     * Check domain eligibility. Return list of eligible IP(s) for this domain.
     *
     * REST: GET /sslGateway/eligibility
     * @param domain [required] domain to check eligibility for SSL Gateway offer
     *
     * API beta
     */
    public OvhEligibilityStatus eligibility_GET(String domain) throws IOException {
        String qPath = "/sslGateway/eligibility";
        StringBuilder sb = path(qPath);
        query(sb, "domain", domain);
        String resp = execN(qPath, "GET", sb.toString(), null);
        return convertTo(resp, OvhEligibilityStatus.class);
    }

    /**
     * List available services
     *
     * REST: GET /sslGateway
     *
     * API beta
     */
    public ArrayList<String> GET() throws IOException {
        String qPath = "/sslGateway";
        StringBuilder sb = path(qPath);
        String resp = exec(qPath, "GET", sb.toString(), null);
        return convertTo(resp, t2);
    }

    /**
     * List of zone available for an SSL Gateway
     *
     * REST: GET /sslGateway/availableZones
     *
     * API beta
     */
    public ArrayList<String> availableZones_GET() throws IOException {
        String qPath = "/sslGateway/availableZones";
        StringBuilder sb = path(qPath);
        String resp = execN(qPath, "GET", sb.toString(), null);
        return convertTo(resp, t2);
    }
}

```


Overlapping Code:
```
Gateway extends ApiOvhBase {
public ApiOvhSslGateway(ApiOvhCore core) {
super(core);
}
/**
* Launch a contact change procedure
*
* REST: POST /sslGateway/{serviceName}/changeContact
* @param contactAdmin [required] The contact to set as admin contact
* @param contactTech [required] The contact to set as tech contact
* @param contactBilling [required] The contact to set as billing contact
* @param serviceName [required] The internal name of your SSL Gateway
*
* API beta
*/
public ArrayList<Long> serviceName_changeContact_POST(String serviceName, String contactAdmin, String contactBilling, String contactTech) throws IOException {
String qPath = "/sslGateway/{serviceName}/changeContact";
StringBuilder sb = path(qPath, serviceName);
HashMap<String, Object> o = new HashMap<String, Object>();
addBody(o, "contactAdmin", contactAdmin);
addBody(o, "contactBilling", contactBilling);
addBody(o, "contactTech", contactTech);
String resp = exec(qPath, "POST", sb.toString(), o);
return convertTo(resp, t1);
}
private static TypeReference<ArrayList<Long>> t1 = new TypeReference<ArrayList<Long>>() {};
/**
* Get this object properties
*
* REST: GET /sslGateway/{serviceName}/serviceInfos
* @param serviceName [required] The internal name of your SSL Gateway
*
* API beta
*/
public OvhService serviceName_serviceInfos_GET(String serviceName) throws IOException {
String qPath = "/sslGateway/{serviceName}/serviceInfos";
StringBuilder sb = path(qPath, serviceName);
String resp = exec(qPath, "GET", sb.toString(), null);
return convertTo(resp, OvhService.class);
}
/**
* Alter this object properties
*
* REST: PUT /sslGateway/{serviceName}/serviceInfos
* @param body [required] New object properties
* @param serviceName [required] The internal name of your SSL Gateway
*
* API beta
*/
public void serviceName_serviceInfos_PUT(String serviceName, OvhService body) throws IOException {
String qPath = "/sslGateway/{serviceName}/serviceInfos";
StringBuilder sb = path(qPath, serviceName);
exec(qPath, "PUT", sb.toString(), body);
}
/**
* Renew your SSL certificates
*
* REST: POST /sslGateway/{serviceName}
```
<Overlap Ratio: 0.9708872458410351>

---

--- 322 --
Question ID: c69772a5d8aa6e768a714070452503874640f029
Original Code:
```
@Slf4j
public class WxMaServiceHttpClientImpl extends BaseWxMaServiceImpl {

    private CloseableHttpClient httpClient;

    private HttpHost httpProxy;

    @Override
    public void initHttp() {
        WxMaConfig configStorage = this.getWxMaConfig();
        ApacheHttpClientBuilder apacheHttpClientBuilder = configStorage.getApacheHttpClientBuilder();
        if (null == apacheHttpClientBuilder) {
            apacheHttpClientBuilder = DefaultApacheHttpClientBuilder.get();
        }
        apacheHttpClientBuilder.httpProxyHost(configStorage.getHttpProxyHost()).httpProxyPort(configStorage.getHttpProxyPort()).httpProxyUsername(configStorage.getHttpProxyUsername()).httpProxyPassword(configStorage.getHttpProxyPassword());
        if (configStorage.getHttpProxyHost() != null && configStorage.getHttpProxyPort() > 0) {
            this.httpProxy = new HttpHost(configStorage.getHttpProxyHost(), configStorage.getHttpProxyPort());
        }
        this.httpClient = apacheHttpClientBuilder.build();
    }

    @Override
    public CloseableHttpClient getRequestHttpClient() {
        return httpClient;
    }

    @Override
    public HttpHost getRequestHttpProxy() {
        return httpProxy;
    }

    @Override
    public HttpType getRequestType() {
        return HttpType.APACHE_HTTP;
    }

    @Override
    protected String doGetAccessTokenRequest() throws IOException {
        String url = String.format(WxMaService.GET_ACCESS_TOKEN_URL, this.getWxMaConfig().getAppid(), this.getWxMaConfig().getSecret());
        HttpGet httpGet = null;
        CloseableHttpResponse response = null;
        try {
            httpGet = new HttpGet(url);
            if (this.getRequestHttpProxy() != null) {
                RequestConfig config = RequestConfig.custom().setProxy(this.getRequestHttpProxy()).build();
                httpGet.setConfig(config);
            }
            response = getRequestHttpClient().execute(httpGet);
            return new BasicResponseHandler().handleResponse(response);
        } finally {
            if (httpGet != null) {
                httpGet.releaseConnection();
            }
            if (response != null) {
                try {
                    response.close();
                } catch (IOException e) {
                }
            }
        }
    }
}

```


Overlapping Code:
```
j
public class WxMaServiceHttpClientImpl extends BaseWxMaServiceImpl {
private CloseableHttpClient httpClient;
private HttpHost httpProxy;
@Override
public void initHttp() {
WxMaConfig configStorage = this.getWxMaConfig();
ApacheHttpClientBuilder apacheHttpClientBuilder = configStorage.getApacheHttpClientBuilder();
if (null == apacheHttpClientBuilder) {
apacheHttpClientBuilder = DefaultApacheHttpClientBuilder.get();
}
apacheHttpClientBuilder.httpProxyHost(configStorage.getHttpProxyHosttpProxyUsername(configStorage.getHttpProxyUsernam.httpProxyPassword(configStorage.getHttpProxyPassword());
if (configStorage.getHttpProxyHost() != null && configStorage.getHttpProxyPort() > 0) {
this.httpProxy = new HttpHost(configStorage.getHttpProxyHost(), configStorage.getHttpProxyPort());
}
this.httpClient = apacheHttpClientBuilder.build();
}
@Override
public CloseableHttpClient getRequestHttpClient() {
return httpClient;
}
@Override
public HttpHost getRequestHttpProxy() {
return httpProxy;
}
@Override
public HttpType getRequestType() {
return HttpType.APACHE_HTTP;
}
@Override
protected String doGetAccessTokenRequest() throws IOException {
String url = String.format(WxMaService.GET_ACCESS_TOKEN_URL, this.getWxMaConfig().getAppid(), this.getWxMaConfig().getSecret());
HttpGet httpGet = null;
CloseableHttpResponse response = null;
try {
httpGet = new HttpGet(url);
if (this.getRequestHttpProxy() != null) {
RequestConfig config = RequestConfig.custom().setProxy(this.getRequestHttpProxy()).build();
httpGet.setConfig(config);
}
response = getRequestHttpClient().execute(httpGet);
return new BasicResponseHandler().handleResponse(response);
} finally {
if (httpGet != null) {
httpGet.releaseConnection();
}
if (response != null) {
try {
response.close();
} catch (IOException e) {
}
}
}
}

```
<Overlap Ratio: 0.9654986522911051>

---

--- 323 --
Question ID: d01caa778c358af05e7c9ced3072245899fa3392
Original Code:
```
@Mojo(defaultPhase = LifecyclePhase.VALIDATE, name = "check-format", threadSafe = true)
public class CheckFormatMojo extends AbstractXmlMojo {

    private class ViolationCollector implements XmlFormatViolationHandler {

        private final Map<String, List<XmlFormatViolation>> violations = new LinkedHashMap<String, List<XmlFormatViolation>>();

        @Override
        public void handle(XmlFormatViolation violation) {
            List<XmlFormatViolation> list = violations.get(violation.getFile().getAbsolutePath());
            if (list == null) {
                list = new ArrayList<XmlFormatViolation>();
                violations.put(violation.getFile().getAbsolutePath(), list);
            }
            list.add(violation);
            if (failOnFormatViolation) {
                getLog().error(violation.toString());
            } else {
                getLog().warn(violation.toString());
            }
        }

        public boolean hasViolations() {
            return !violations.isEmpty();
        }

        public boolean hasViolations(File file) {
            List<XmlFormatViolation> list = violations.get(file.getAbsolutePath());
            return list != null && !list.isEmpty();
        }
    }

    /**
     * The encoding of files included in {@link #formatFileSets}. Note that the
     * {@code encoding can be set also per FormatFileSet}.
     */
    @Parameter(property = "xml.encoding", defaultValue = "${project.build.sourceEncoding}")
    private String encoding;

    /**
     * Tells the mojo what to do in case XML formatting violations are found. if {@code true}, all violations will be
     * reported on the console as ERRORs and the build will fail. if {@code false}, all violations will be reported on
     * the console as WARNs and the build will proceed further.
     */
    @Parameter(property = "xml.failOnFormatViolation", defaultValue = "true")
    private boolean failOnFormatViolation;

    /**
     * File patterns to include. The patterns are relative to the current project's {@code baseDir}.
     */
    @Parameter
    private List<FormatFileSet> formatFileSets = new ArrayList<FormatFileSet>();

    /**
     * The number of spaces expected for indentation. Note that {@code indentSize} can be configuread also per
     * {@link FormatFileSet}.
     */
    @Parameter(property = "xml.indentSize", defaultValue = "2")
    private int indentSize;

    /**
     * A {@link SAXParserFactory}
     */
    private SAXParserFactory saxParserFactory;

    /**
     * If set to {@code true}, the result of {@link FormatFileSet#getDefault(String, int)} will be appended to
     * {@link #formatFileSets} before the processing.
     */
    @Parameter(property = "xml.useDefaultFormatFileSet", defaultValue = "true")
    private boolean useDefaultFormatFileSet;

    /**
     * Creates a new {@link CheckFormatMojo} instance.
     */
    public CheckFormatMojo() {
        super();
        this.saxParserFactory = SAXParserFactory.newInstance();
        this.saxParserFactory.setValidating(false);
    }

    /**
     * Checks the formatting of the given {@code file}. The file is read using the given {@code encoding} and the
     * violations are reported to the given {@code violationHandler}.
     *
     * @param file the file to check
     * @param encoding the encoding to use for reading the {@code file}
     * @param violationHandler the {@link XmlFormatViolationHandler} to report violations
     * @throws MojoExecutionException if there is any lover level exception reading or parsing the file.
     */
    private void check(File file, String encoding, XmlFormatViolationHandler violationHandler) throws MojoExecutionException {
        Reader in = null;
        try {
            in = new InputStreamReader(new FileInputStream(file), encoding);
            SAXParser saxParser = saxParserFactory.newSAXParser();
            IndentCheckSaxHandler handler = new IndentCheckSaxHandler(file, indentSize, violationHandler);
            saxParser.parse(new InputSource(in), handler);
        } catch (Exception e) {
            throw new MojoExecutionException("Could not process file " + file.getAbsolutePath(), e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    getLog().error("Could not close Reader for " + file.getAbsolutePath(), e);
                }
            }
        }
    }

    /**
     * Called by Maven for executing the Mojo.
     *
     * @throws MojoExecutionException Running the Mojo failed.
     * @throws MojoFailureException A configuration error was detected.
     */
    public void execute() throws MojoExecutionException, MojoFailureException {
        if (isSkipping()) {
            getLog().debug("Skipping execution, as demanded by user.");
            return;
        }
        if (useDefaultFormatFileSet) {
            formatFileSets.add(FormatFileSet.getDefault(getBasedir(), encoding, indentSize));
        }
        if (formatFileSets == null || formatFileSets.isEmpty()) {
            /* nothing to do */
            return;
        }
        ViolationCollector violationCollector = new ViolationCollector();
        int processedFileCount = 0;
        for (FormatFileSet formatFileSet : formatFileSets) {
            String effectiveEncoding = formatFileSet.getEncoding();
            if (effectiveEncoding == null) {
                effectiveEncoding = this.encoding;
            }
            String[] includedFiles = scan(formatFileSet);
            for (String includedPath : includedFiles) {
                processedFileCount++;
                File file = new File(formatFileSet.getDirectory(), includedPath);
                check(file, effectiveEncoding, violationCollector);
                if (getLog().isDebugEnabled() && !violationCollector.hasViolations(file)) {
                    getLog().debug("No XML formatting violations found in file " + file.getAbsolutePath());
                }
            }
        }
        getLog().debug("Checked the formatting of " + processedFileCount + " files");
        if (failOnFormatViolation && violationCollector.hasViolations()) {
            throw new MojoFailureException("There are XML formatting violations. Check the above log for details.");
        }
    }

    /**
     * A {@link DirectoryScanner} boiler plate.
     *
     * @param fileSet {@link FileSet} to scan
     * @return the included paths
     */
    private String[] scan(FileSet fileSet) {
        File basedir = new File(fileSet.getDirectory());
        if (!basedir.exists() || !basedir.isDirectory()) {
            return null;
        }
        DirectoryScanner scanner = new DirectoryScanner();
        List<String> includes = fileSet.getIncludes();
        List<String> excludes = fileSet.getExcludes();
        if (includes != null && includes.size() > 0) {
            scanner.setIncludes(includes.toArray(new String[0]));
        }
        if (excludes != null && excludes.size() > 0) {
            scanner.setExcludes(excludes.toArray(new String[0]));
        }
        scanner.setBasedir(basedir);
        scanner.scan();
        return scanner.getIncludedFiles();
    }

    /**
     * Sets the number of spaces for indentation.
     *
     * @param indentSize the number of spaces
     */
    public void setIndentSize(int indentSize) {
        this.indentSize = indentSize;
    }
}

```


Overlapping Code:
```
jo(defaultPhase = LifecyclePhase.VALIDATE, name = "check-format", thre final Map<String, List<XmlFormatViolation>> violapublic boolean hasViolations() {
return !violations.isEmpty()ist.isEmpty();
}
}
/**
* The encoding of files included in {@link #formatFileSets}. Note that the
* {@code encoding can be set also per FormatFileSet}.encoding", defaultValue = "${project.build.sourceEncoding}")
private String encoding;
/**
* Tells the mojo what to do in case XML formatting violations are found. if {@code true}, all violations will be
* reported on the console as ERRORs and the build will fail. if {@code false}, all violations will be reported on
* the console as WARNs and the build will proceedtion", defaultValue = "true")
private boolean failOnFormatViolation;
/**
* File patterns to include. The patterns are relative to the current project's {@code baseDir}.
*/
@Parameter
private List<FormatFileSet> formatFileSets = new ArrayList<FormatFileSet>();
/**
* The number of spaces expected for indentation. Note that {@code indentSize} can be configuread also per
* {@link FormatFileSeentSize", defaultValue = "2")
private int indentSi
```
<Overlap Ratio: 0.540579022306597>

---

--- 324 --
Question ID: 469ab8b8135d229de2f22682bfe1f823e382cb62
Original Code:
```
public class BaseKnowledgeManagerTest {

    private BaseKnowledgeManager tested;

    @Mock
    private TriggerListener triggerListener;

    @Before
    public void setUp() throws Exception {
        tested = new BaseKnowledgeManager("TEST", null, null);
        tested.update(createKnowledge());
        initMocks(this);
    }

    public static ChangeSet createKnowledge() {
        ChangeSet result = new ChangeSet();
        result.setValue(RuntimeModelHelper.createKnowledgePath("id"), "Test");
        result.setValue(RuntimeModelHelper.createKnowledgePath("number"), 10);
        result.setValue(RuntimeModelHelper.createKnowledgePath("mapKeyInner"), "x");
        result.setValue(RuntimeModelHelper.createKnowledgePath("date"), null);
        List<Integer> list = new LinkedList<>();
        list.add(1);
        list.add(2);
        list.add(3);
        result.setValue(RuntimeModelHelper.createKnowledgePath("list"), list);
        Map<String, Integer> map = new HashMap<String, Integer>();
        map.put("a", 1);
        map.put("b", 2);
        map.put("c", 3);
        result.setValue(RuntimeModelHelper.createKnowledgePath("map"), map);
        result.setValue(RuntimeModelHelper.createKnowledgePath("innerKnowledge"), new InnerKnowledge("innerA", "innerB"));
        Map<String, String> mapNested = new HashMap<>();
        mapNested.put("x", "a");
        result.setValue(RuntimeModelHelper.createKnowledgePath("mapNested"), mapNested);
        return result;
    }

    @Test
    public void testUpdateIntegerField() throws Exception {
        // and as a ChangeSet, the update for the 'number' field is passed
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("number");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        ChangeSet toUpdate = new ChangeSet();
        toUpdate.setValue(kp, 17);
        tested.update(toUpdate, "X");
        // return updated value
        ValueSet result = tested.get(knowledgePaths);
        assertEquals(17, result.getValue(kp));
        assertEquals("X", tested.getAuthor(kp));
    }

    @Test
    public void testInnerKnowledgeUpdate() throws Exception {
        // and as a ChangeSet, the update for some nested inner field is passed
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("innerKnowledge", "a");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        ChangeSet toUpdate = new ChangeSet();
        toUpdate.setValue(kp, "innerAModified");
        tested.update(toUpdate, "X");
        // return updated value
        ValueSet result = tested.get(knowledgePaths);
        assertEquals("innerAModified", result.getValue(kp));
        assertEquals("X", tested.getAuthor(kp));
        assertEquals("TEST", tested.getAuthor(RuntimeModelHelper.createKnowledgePath("innerKnowledge")));
    }

    @Test
    public void testUpdateListField() throws Exception {
        // and as a ChangeSet, the update for one of the 'list' items is passed
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("list", "2");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        ChangeSet toUpdate = new ChangeSet();
        toUpdate.setValue(kp, 4);
        tested.update(toUpdate, "X");
        // updated value
        ValueSet result = tested.get(knowledgePaths);
        assertEquals(4, result.getValue(kp));
        assertEquals("X", tested.getAuthor(kp));
        assertEquals("TEST", tested.getAuthor(RuntimeModelHelper.createKnowledgePath("list")));
    }

    @Test
    public void testUpdateMapField() throws Exception {
        // and as a ChangeSet, the update for one of the 'map' items is passed
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("map", "a");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        ChangeSet toUpdate = new ChangeSet();
        toUpdate.setValue(kp, 16);
        tested.update(toUpdate, "X");
        // updated value
        ValueSet result = tested.get(knowledgePaths);
        assertEquals(16, result.getValue(kp));
        assertEquals("X", tested.getAuthor(kp));
        assertEquals("TEST", tested.getAuthor(RuntimeModelHelper.createKnowledgePath("map")));
    }

    @Test
    public void testRemovalFromList() throws Exception {
        // and as a ChangeSet, the removal of one of the 'list' items is passed
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("list", "2");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        Object nextItemValue = tested.get(knowledgePaths).getValue(kp);
        kp = RuntimeModelHelper.createKnowledgePath("list", "1");
        knowledgePaths.clear();
        knowledgePaths.add(kp);
        ChangeSet toDelete = new ChangeSet();
        toDelete.setDeleted(kp);
        tested.update(toDelete);
        // the value of the next item
        assertEquals(nextItemValue, tested.get(knowledgePaths).getValue(kp));
    }

    @Test(expected = KnowledgeNotFoundException.class)
    public void testDeleteFromMap() throws Exception {
        // passed
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("map", "a");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        ChangeSet toDelete = new ChangeSet();
        toDelete.setDeleted(kp);
        tested.update(toDelete);
        // should throw the KnowledgeNotExistentException
        tested.get(knowledgePaths);
    }

    @Test
    public void testGetIntegerField() throws Exception {
        // WHEN a field is accessed from the ReadOnlyKnowledgeManager
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("number");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        ValueSet result = tested.get(knowledgePaths);
        // THEN the correct value is returned
        assertEquals(10, result.getValue(kp));
    }

    @Test
    public void testInnerKnowledgeGet() throws Exception {
        // WHEN inner knowledge is accessed from the ReadOnlyKnowledgeManager
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("innerKnowledge", "a");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        ValueSet result = tested.get(knowledgePaths);
        // THEN the correct value is returned
        assertEquals("innerA", result.getValue(kp));
    }

    @Test(expected = KnowledgeNotFoundException.class)
    public void testNullBaseKnowledgeAccess() throws Exception {
        tested = new BaseKnowledgeManager("TEST", null, null);
        // null base knowledge
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("number");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        // THEN exception is thrown.
        tested.get(knowledgePaths);
    }

    @Test
    public void testGetListField() throws Exception {
        // WHEN an item of a list is accessed from the ReadOnlyKnowledgeManager
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("list", "2");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        ValueSet result = tested.get(knowledgePaths);
        // THEN the correct value is returned
        assertEquals(3, result.getValue(kp));
    }

    @Test
    public void testGetMapField() throws Exception {
        // ReadOnlyKnowledgeManager
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("map", "a");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        ValueSet result = tested.get(knowledgePaths);
        // THEN the correct value is returned
        assertEquals(1, result.getValue(kp));
    }

    @Test(expected = KnowledgeNotFoundException.class)
    public void testNotExsistentAccess() throws Exception {
        // ReadOnlyKnowledgeManager
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("dummy");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        // KnowledgeNotExistentException
        tested.get(knowledgePaths);
    }

    @Test
    public void testRegisterListener() throws Exception {
        // WHEN a listener is registered at the KnowledgeManager
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("number");
        KnowledgeChangeTrigger trigger = RuntimeModelHelper.createKnowledgeChangeTrigger();
        trigger.setKnowledgePath(kp);
        tested.register(trigger, triggerListener);
        // and WHEN listener's releavant knowledge is updated
        ChangeSet toUpdate = new ChangeSet();
        toUpdate.setValue(kp, 17);
        tested.update(toUpdate);
        // THEN the listener is notify once.
        verify(triggerListener).triggered(trigger);
        verifyNoMoreInteractions(triggerListener);
    }

    @Test
    public void testUnregisterListener() throws Exception {
        // WHEN a previously registered listener
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("number");
        KnowledgeChangeTrigger trigger = RuntimeModelHelper.createKnowledgeChangeTrigger();
        trigger.setKnowledgePath(kp);
        tested.register(trigger, triggerListener);
        // is unregistered from the KnowledgeManager
        tested.register(trigger, triggerListener);
        // THEN it is not notified about knowledge changes any more
        verifyNoMoreInteractions(triggerListener);
    }

    @Test
    public void testGetRootKnowledge() throws Exception {
        // WHEN empty knowledge path is created
        KnowledgePath emptyKP = RuntimeModelHelper.createKnowledgePath();
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(emptyKP);
        // and WHEN it is used to access knowledge manager data
        ValueSet result = tested.get(knowledgePaths);
        // knowledge
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("id");
        assertTrue(result.getKnowledgePaths().contains(kp));
        kp = RuntimeModelHelper.createKnowledgePath("date");
        assertTrue(result.getKnowledgePaths().contains(kp));
    }

    public void testForbiddenUpdate() throws Exception {
        // removal and number field update and incorrect inner knowledge change
        KnowledgePath numberPath = RuntimeModelHelper.createKnowledgePath("number");
        KnowledgePath listElementPath = RuntimeModelHelper.createKnowledgePath("list", "1");
        KnowledgePath innerPath = RuntimeModelHelper.createKnowledgePath("innerKnowledge", "a");
        ChangeSet toChange = new ChangeSet();
        toChange.setValue(numberPath, 100);
        toChange.setValue(innerPath, 66);
        toChange.setDeleted(listElementPath);
        boolean exceptionThrown = false;
        try {
            tested.update(toChange, "update_author");
        } catch (KnowledgeUpdateException e) {
            exceptionThrown = true;
        }
        // THEN the KnowledgeUpdateException is thrown
        assertTrue(exceptionThrown);
        KnowledgePath listPath = RuntimeModelHelper.createKnowledgePath("list");
        List<KnowledgePath> listOfPaths = new LinkedList<>();
        // and THEN list remains unchanged
        listOfPaths.add(listPath);
        assertEquals(3, ((List<?>) tested.get(listOfPaths).getValue(listPath)).size());
        listOfPaths.clear();
        // and THEN inner knowledge has its original value
        listOfPaths.add(innerPath);
        assertEquals("innerA", tested.get(listOfPaths).getValue(innerPath));
        listOfPaths.clear();
        // and THEN number field has its original value
        listOfPaths.add(numberPath);
        assertEquals(10, tested.get(listOfPaths).getValue(numberPath));
        // then authors of knowledge remain the same
        assertEquals("TEST", tested.getAuthor(numberPath));
        assertEquals("TEST", tested.getAuthor(listElementPath));
        assertEquals("TEST", tested.getAuthor(innerPath));
    }

    @Test
    public void securityTagsTest() {
        // given single-noded knowledge path and security tags are prepared
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("field");
        KnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();
        tag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());
        tag.getRequiredRole().setRoleName("role");
        Collection<SecurityTag> expectedTags = Arrays.asList(tag);
        // when setSecurityTags() is called
        tested.setSecurityTags(kp, expectedTags);
        // when security tags are then retrieved
        KnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath("field");
        List<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));
        // then collections are equal
        assertEquals(expectedTags, actualTags);
    }

    @Test
    public void addSecurityTagsTest() {
        // given single-noded knowledge path and security tags are prepared
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("field");
        KnowledgeSecurityTag tag = RuntimeMetadataFactory.eINSTANCE.createKnowledgeSecurityTag();
        tag.setRequiredRole(RuntimeMetadataFactory.eINSTANCE.createSecurityRole());
        tag.getRequiredRole().setRoleName("role");
        Collection<SecurityTag> expectedTags = Arrays.asList(tag);
        // when setSecurityTags() is called
        tested.setSecurityTags(kp, expectedTags);
        tested.addSecurityTag(kp, tag);
        // when security tags are then retrieved
        KnowledgePath kp_same = RuntimeModelHelper.createKnowledgePath("field");
        List<KnowledgeSecurityTag> actualTags = tested.getKnowledgeSecurityTags((PathNodeField) kp_same.getNodes().get(0));
        // then collections are equal
        assertEquals(2, actualTags.size());
        assertEquals(tag, actualTags.get(0));
        assertEquals(tag, actualTags.get(1));
    }

    @Test(expected = IllegalArgumentException.class)
    public void markAsSecured_MultiNodePathTest() {
        // given multi-noded knowledge path and security tags are prepared
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("field", "inner");
        Collection<SecurityTag> expectedTags = Arrays.asList();
        // when setSecurityTags() is called
        tested.setSecurityTags(kp, expectedTags);
    }

    @Test(expected = IllegalArgumentException.class)
    public void markAsSecured_IdPathTest() {
        // given single-noded knowledge path and security tags are prepared
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath();
        kp.getNodes().add(RuntimeMetadataFactory.eINSTANCE.createPathNodeComponentId());
        Collection<SecurityTag> expectedTags = Arrays.asList();
        // when setSecurityTags() is called
        tested.setSecurityTags(kp, expectedTags);
    }

    @Test
    public void getAuthorTest1() {
        // given basic knowledge is created
        KnowledgePath nestedPath = RuntimeModelHelper.createKnowledgePath("innerKnowledge", "a");
        KnowledgePath basicPath = RuntimeModelHelper.createKnowledgePath("innerKnowledge");
        // when nested path is used and getAuthor() called
        String innerAuthor = tested.getAuthor(nestedPath);
        String outerAuthor = tested.getAuthor(basicPath);
        // then author is returned
        assertEquals("TEST", innerAuthor);
        assertEquals("TEST", outerAuthor);
        // then knowledge paths remain intact
        assertEquals(RuntimeModelHelper.createKnowledgePath("innerKnowledge", "a"), nestedPath);
        assertEquals(RuntimeModelHelper.createKnowledgePath("innerKnowledge"), basicPath);
    }

    @Test
    public void getAuthorTest2() {
        // given basic knowledge is created
        KnowledgePath nonExistentPath = RuntimeModelHelper.createKnowledgePath("non", "existent", "path");
        // when getAuthor() is called
        String author = tested.getAuthor(nonExistentPath);
        // then null is returned
        assertNull(author);
    }

    @Test
    public void getAuthorTest3() throws KnowledgeUpdateException, KnowledgeNotFoundException {
        // and as a ChangeSet, the update for one of the 'map' items is passed
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("map", "a");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        ChangeSet toUpdate = new ChangeSet();
        toUpdate.setValue(kp, 16);
        tested.update(toUpdate, "X");
        // WHEN the 'map' itself is then updated by a different author
        KnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath("map");
        List<KnowledgePath> knowledgePaths2 = new LinkedList<>();
        knowledgePaths2.add(kp2);
        ChangeSet toUpdate2 = new ChangeSet();
        toUpdate2.setValue(kp2, new HashMap<>());
        tested.update(toUpdate2, "Y");
        // THEN author of the 'map' and the 'map.a' is set to Y
        assertEquals("Y", tested.getAuthor(kp2));
        assertEquals("Y", tested.getAuthor(kp));
    }

    @Test
    public void getAuthorTest4() throws KnowledgeUpdateException, KnowledgeNotFoundException {
        // and as a ChangeSet, the update for one of the 'map' items is passed
        KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("map", "a");
        List<KnowledgePath> knowledgePaths = new LinkedList<>();
        knowledgePaths.add(kp);
        ChangeSet toUpdate = new ChangeSet();
        toUpdate.setValue(kp, 16);
        tested.update(toUpdate, "X");
        // WHEN the 'map' itself is then deleted
        KnowledgePath kp2 = RuntimeModelHelper.createKnowledgePath("map");
        List<KnowledgePath> knowledgePaths2 = new LinkedList<>();
        knowledgePaths2.add(kp2);
        ChangeSet toUpdate2 = new ChangeSet();
        toUpdate2.setDeleted(kp2);
        tested.update(toUpdate2, "Y");
        // THEN author of the 'map' and the 'map.a' is null
        assertNull(tested.getAuthor(kp2));
        assertNull(tested.getAuthor(kp));
    }

    public static class InnerKnowledge {

        public String a;

        public String b;

        public InnerKnowledge(String a, String b) {
            super();
            this.a = a;
            this.b = b;
        }
    }
}

```


Overlapping Code:
```
st {
private BaseKnowledgeManager tested;
@Mock
private TriggerListener triggerListener;
@Before
public void setUp() throws Exception {
tested = new BaseKnowledgeManager("TEST", null, null);
tested.update(createKnowledge());
initMocks(this);
}
public static ChangeSet createKnowledge() {
ChangeSet result = new ChangeSet();
result.setValue(RuntimeModelHelper.createKnowledgePath("id"), "Test");
result.setValue(RuntimeModelHelper.createKnowledgePath("number"), 10);
result.setValue(RuntimeModelHelper.createKnowledgePath("mapKeyInner"), "x");
result.setValue(RuntimeModelHelper.createKnowledgePath("date"), null);
List<Integer> list = new LinkedList<>();
list.add(1);
list.add(2);
list.add(3);
result.setValue(RuntimeModelHelper.createKnowledgePath("list"), list);
Map<String, Integer> map = new HashMap<String, Integer>();
map.put("a", 1);
map.put("b", 2);
map.put("c", 3);
result.setValue(RuntimeModelHelper.createKnowledgePath("map"), map);
result.setValue(RuntimeModelHelper.createKnowledgePath("nnerB"));
Map<String, String> mapNested = new HashMap<>();
mapNested.put("x", "a");
result.setValue(RuntimeModelHelper.createKnowledgePath("mapNested"), mber' field is passed
KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("number");
List<KnowledgePath> knowledgePaths = new LinkedList<>();
knowledgePaths.add(kp);
ChangeSet toUpdate = new ChangeSet();
toUpdate.setValue(kp, 17);
tested.updated value
ValueSet result = tested.get(knowledgePaths);
assertEquals(17, result.getValue(kp));
assertEquals("X", tested.getAuthor(kp));
}
@Test
public void testInnerKnowledgeUpdate() throws Exception {
me nested inner field is passed
KnowledgePath kp = RuntimeModelHelper.createKnowledgePath("innerKnowledge", "a");
List<KnowledgePath> knowledgePaths = new LinkedList<>();
knowledgePaths.add(kp);
ChangeSet toUpdate = new Cha
```
<Overlap Ratio: 0.8580827067669173>

---

--- 325 --
Question ID: 4998e4e78f75aacee3fa24faf1e1124b33ea528c
Original Code:
```
public class CompletionOnQualifiedAllocationExpression extends QualifiedAllocationExpression {

    public TypeBinding resolveType(BlockScope scope) {
        this.argumentTypes = Binding.NO_PARAMETERS;
        if (this.arguments != null) {
            int argsLength = this.arguments.length;
            int length = this.arguments.length;
            this.argumentTypes = new TypeBinding[length];
            int a = argsLength;
            while (--a >= 0) try {
                this.argumentTypes[a] = this.arguments[a].resolveType(scope);
            } finally {
            }
        }
        final boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;
        if (this.enclosingInstance != null) {
            TypeBinding enclosingType = this.enclosingInstance.resolveType(scope);
            if (enclosingType == null) {
                // Eg.: new Test<>().new Test<>(#cursor#
                if (this.enclosingInstance instanceof AllocationExpression) {
                    TypeReference enclosingInstanceType = ((AllocationExpression) this.enclosingInstance).type;
                    if (enclosingInstanceType != null) {
                        enclosingType = enclosingInstanceType.resolvedType;
                    }
                }
            }
            if (enclosingType == null || !(enclosingType instanceof ReferenceBinding)) {
                throw new CompletionNodeFound();
            }
            this.resolvedType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingType);
            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {
                TypeBinding[] inferredTypes = inferElidedTypes(scope);
                if (inferredTypes != null) {
                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());
                } else {
                    // inference failed. Resolved type will be of the form Test<>
                    this.bits |= ASTNode.IsDiamond;
                }
            }
            if (!(this.resolvedType instanceof ReferenceBinding))
                // no need to continue if its an array or base type
                throw new CompletionNodeFound();
            if (// handle the anonymous class definition case
            this.resolvedType.isInterface())
                this.resolvedType = scope.getJavaLangObject();
        } else {
            this.resolvedType = this.type.resolveType(scope, /* check bounds*/
            true);
            if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {
                TypeBinding[] inferredTypes = inferElidedTypes(scope);
                if (inferredTypes != null) {
                    this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());
                } else {
                    // inference failed. Resolved type will be of the form Test<>
                    this.bits |= ASTNode.IsDiamond;
                }
            }
            if (!(this.resolvedType instanceof ReferenceBinding))
                // no need to continue if its an array or base type
                throw new CompletionNodeFound();
        }
        throw new CompletionNodeFound(this, this.resolvedType, scope);
    }

    public StringBuffer printExpression(int indent, StringBuffer output) {
        if (this.enclosingInstance == null)
            //$NON-NLS-1$
            output.append("<CompleteOnAllocationExpression:");
        else
            //$NON-NLS-1$
            output.append("<CompleteOnQualifiedAllocationExpression:");
        return super.printExpression(indent, output).append('>');
    }
}

```


Overlapping Code:
```
ionOnQualifiedAllocationExpression extends QualifiedAllocationExpression {
public TypeBinding resolveType(BlockScope scope) {
this.argumentTypes = Binding.NO_PARAMETERS;
if (this.arguments != null) {
int argsLength = this.arguments.length;
int length = this.arguments.length;
this.argumentTypes = new TypeBinding[length];
int a = argsLength;
while (--a}
final boolean isDiamond = this.type != null && (this.type.bits & ASTNode.IsDiamond) != 0;
if (this.enclosingInstance != null) {
TypeBinding enclosingType = this.enclosingInstance.resolveType(scope);
if (enclosingType == null) {
// Eg.: new Test<>().new Test<>(#cursor#
if (this.enclosingInstance instanceof AllocationExpression) {
TypeReference enclosingInstanceType = ((AllocationExpression) this.enclosingInstance).type;
if (enclosingInstanceType != null) {
enclosingType = enclosingInstanceType.resolvedType;
}
}
}
if (enclosingType == null || !(enclosingType instanceof ReferenceBinding)) {
throw new CompletionNodeFound();
}
this.resolvedType = ((SingleTypeReference) this.type).resolveTypeEnclosing(scope, (ReferenceBinding) enclosingType);
if (isDiamond && (this.resolvedType instanceof ParameterizedTypeBinding)) {
TypeBinding[] inferredTypes = inferElidedTypes(scope);
if (inferredTypes != null) {
this.resolvedType = this.type.resolvedType = scope.environment().createParameterizedType(((ParameterizedTypeBinding) this.resolvedType).genericType(), inferredTypes, this.resolvedType.enclosingType());
} else {
// inference failed. Resolved type will be of the form Test<>
this.bits |= ASTNode.IsDiamond;
}
}
if (!(this.resolvedType instanceof ReferenceBinding))
// no need to continue if its an array or base type
throw new CompletionNodeFound();
if (// handle the anonymous class definition case
this.resolvedType.
```
<Overlap Ratio: 0.9342797055730809>

---

--- 326 --
Question ID: 3ede65710f688d01a47e728a22d61210d6155313
Original Code:
```
public class UpdateStreamSubscriptionSettingsApiRequest extends ZulipApiRequest implements ExecutableApiRequest<List<StreamSubscriptionSetting>> {

    public static final String COLOR = "color";

    public static final String IS_MUTED = "is_muted";

    public static final String PIN_TO_TOP = "pin_to_top";

    public static final String DESKTOP_NOTIFICATIONS = "desktop_notifications";

    public static final String AUDIBLE_NOTIFICATIONS = "audible_notifications";

    public static final String PUSH_NOTIFICATIONS = "push_notifications";

    public static final String EMAIL_NOTIFICATIONS = "email_notifications";

    public static final String SUBSCRIPTION_DATA = "subscription_data";

    private final Set<StreamSubscriptionSetting> settings = new LinkedHashSet<>();

    /**
     * Constructs a {@link UpdateStreamSubscriptionSettingsApiRequest}.
     *
     * @param client The Zulip HTTP client
     */
    public UpdateStreamSubscriptionSettingsApiRequest(ZulipHttpClient client) {
        super(client);
    }

    /**
     * Sets the hex value of the color to display on the Zulip UI.
     *
     * @param  streamId The id of the stream for which the setting should be updated
     * @param  color    The hex value of the color
     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance
     */
    public UpdateStreamSubscriptionSettingsApiRequest withColor(long streamId, String color) {
        addSetting(streamId, COLOR, color);
        return this;
    }

    /**
     * Sets whether the stream should be muted.
     *
     * @param  streamId The id of the stream for which the setting should be updated
     * @param  muted    {@code true} to mute the stream. {@code false} to unmute the stream
     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance
     */
    public UpdateStreamSubscriptionSettingsApiRequest withIsMuted(long streamId, boolean muted) {
        addSetting(streamId, IS_MUTED, muted);
        return this;
    }

    /**
     * Sets whether the stream should be pinned to the top in the Zulip UI.
     *
     * @param  streamId The id of the stream for which the setting should be updated
     * @param  pinToTop {@code true} to pin the stream to top. {@code false} to unpin the stream
     * @return          This {@link UpdateStreamSubscriptionSettingsApiRequest} instance
     */
    public UpdateStreamSubscriptionSettingsApiRequest withPinToTop(long streamId, boolean pinToTop) {
        addSetting(streamId, PIN_TO_TOP, pinToTop);
        return this;
    }

    /**
     * Sets whether to show desktop notifications for messages sent to the stream.
     *
     * @param  streamId             The id of the stream for which the setting should be updated
     * @param  desktopNotifications {@code true} to enable desktop notifications. {@code false} to disable desktop
     *                              notifications.
     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance
     */
    public UpdateStreamSubscriptionSettingsApiRequest withDesktopNotifications(long streamId, boolean desktopNotifications) {
        addSetting(streamId, DESKTOP_NOTIFICATIONS, desktopNotifications);
        return this;
    }

    /**
     * Sets whether to play a sound for messages sent to the stream.
     *
     * @param  streamId             The id of the stream for which the setting should be updated
     * @param  audibleNotifications {@code true} to enable audible notifications. {@code false} to disable audible
     *                              notifications.
     * @return                      This {@link UpdateStreamSubscriptionSettingsApiRequest} instance
     */
    public UpdateStreamSubscriptionSettingsApiRequest withAudibleNotifications(long streamId, boolean audibleNotifications) {
        addSetting(streamId, AUDIBLE_NOTIFICATIONS, audibleNotifications);
        return this;
    }

    /**
     * Sets whether to enable or disable push notifications a sound for messages sent to the stream.
     *
     * @param  streamId          The id of the stream for which the setting should be updated
     * @param  pushNotifications {@code true} to enable mobile push notifications. {@code false} to disable mobile push
     *                           notifications.
     * @return                   This {@link UpdateStreamSubscriptionSettingsApiRequest} instance
     */
    public UpdateStreamSubscriptionSettingsApiRequest withPushNotifications(long streamId, boolean pushNotifications) {
        addSetting(streamId, PUSH_NOTIFICATIONS, pushNotifications);
        return this;
    }

    /**
     * Sets whether to enable or disable email notifications a sound for messages sent to the stream.
     *
     * @param  streamId           The id of the stream for which the setting should be updated
     * @param  emailNotifications {@code true} to enable email notifications. {@code false} to disable email notifications.
     * @return                    This {@link UpdateStreamSubscriptionSettingsApiRequest} instance
     */
    public UpdateStreamSubscriptionSettingsApiRequest withEmailNotifications(int streamId, boolean emailNotifications) {
        addSetting(streamId, EMAIL_NOTIFICATIONS, emailNotifications);
        return this;
    }

    private void addSetting(long streamId, String property, Object value) {
        StreamSubscriptionSetting setting = new StreamSubscriptionSetting(streamId, property, value);
        settings.remove(setting);
        settings.add(setting);
    }

    /**
     * Executes the Zulip API request for updating stream subscription settings.
     *
     * @return                      List of modified settings encapsulated by {@link StreamSubscriptionSetting}
     * @throws ZulipClientException if the request was not successful
     */
    @Override
    public List<StreamSubscriptionSetting> execute() throws ZulipClientException {
        putParamAsJsonString(SUBSCRIPTION_DATA, settings);
        UpdateStreamSubscriptionSettingsApiResponse response = client().post(SUBSCRIPTIONS_PROPERTIES, getParams(), UpdateStreamSubscriptionSettingsApiResponse.class);
        return response.getSubscriptionData();
    }
}

```


Overlapping Code:
```
 class UpdateStreamSubscriptionSettingsApiRequest extends ZulipApiRequest implements ExecutableApiRequest<List<StreamSubscriptionSetting>> {
public static final String COLOR = "color";
public static final String IS_MUTED = "is_muted";
public static final String PIN_TO_TOP = "pin_to_top";
public static final String DESKTOP_NOTIFICATIONS = "desktop_notifications";
public static final String AUDIBLE_NOTIFICATIONS = "audible_notifications";
public static final String PUSH_NOTIFICATIONS = "push_notifications";
public static final String EMAIL_NOTIFICATIONS = "email_notifications";
public static final String SUBSCRIPTION_DATA = "subscription_data";
private final Set<StreamSubscriptionSetting> settings = new LinkedHashSet<>();
/**
* Constructs a {@link UpdateStreamSubscriptionSettingsApiRequest}.
*
* @param client The Zulip HTTP client
*/
public UpdateStreamSubscriptionSettingsApiRequest(ZulipHttpClient client) {
super(client);
}
/**
* Sets the hex value of the color to display on the Zulip UI.
*
* @param streamId The id of the stream for which the setting should be updated
* @param color The hex value of the color
* @return This {@link UpdateStreamSubscriptionSettingsApiRequest} instance
*/
public UpdateStreamSubscriptionSettingsApiRequest withColor(long streamId, String color) {
addSetting(streamId, COLOR, color);
return this;
}
/**
* Sets whether the stream should be muted.
*
* @param streamId The id of the stream for which the setting should be updated
* @param muted {@code true} to mute the stream. {@code false} to unmute the stream
* @return This {@link UpdateStreamSubscriptionSettingsApiRequest} instance
*/
public UpdateStreamSubscriptionSettingsApiRequest withIsMuted(long streamId, boolean muted) {
addSetting(streamId, IS_MUTED, muted);
return this;
}
/**
* Sets whether the stream should be pinned to the top in the Zulip UI.
*
* @param streamId The id of the stream for which the setting should be updated
* @param pinToTop {@code true} to pin the stream to top. {@code false} to unpin the stream
* @return This {@link UpdateStreamSubscriptionSettingsApiRequest} instance
*/
public UpdateStreamSubscriptionSettingsApiRequest withPinToTop(long streamId, boolean pinToT
```
<Overlap Ratio: 0.9950248756218906>

---

--- 327 --
Question ID: 640175d1e067155b22c70f2b34c608f3002f0f9f
Original Code:
```
public class ByteSizeUnitTests extends ElasticsearchTestCase {

    @Test
    public void testBytes() {
        assertThat(BYTES.toBytes(1), equalTo(1l));
        assertThat(BYTES.toKB(1024), equalTo(1l));
        assertThat(BYTES.toMB(1024 * 1024), equalTo(1l));
        assertThat(BYTES.toGB(1024 * 1024 * 1024), equalTo(1l));
    }

    @Test
    public void testKB() {
        assertThat(KB.toBytes(1), equalTo(1024l));
        assertThat(KB.toKB(1), equalTo(1l));
        assertThat(KB.toMB(1024), equalTo(1l));
        assertThat(KB.toGB(1024 * 1024), equalTo(1l));
    }

    @Test
    public void testMB() {
        assertThat(MB.toBytes(1), equalTo(1024l * 1024));
        assertThat(MB.toKB(1), equalTo(1024l));
        assertThat(MB.toMB(1), equalTo(1l));
        assertThat(MB.toGB(1024), equalTo(1l));
    }

    @Test
    public void testGB() {
        assertThat(GB.toBytes(1), equalTo(1024l * 1024 * 1024));
        assertThat(GB.toKB(1), equalTo(1024l * 1024));
        assertThat(GB.toMB(1), equalTo(1024l));
        assertThat(GB.toGB(1), equalTo(1l));
    }
}

```


Overlapping Code:
```
Tests extends ElasticsearchTestCase {
@Test
public void testBytes() {
assertThat(BYTES.toBytes(1), equalTo(1l));
assertThat(BYTES.toKB(1024), equalTo(1l));
assertThat(BYTES.toMB(1024 * 1024), equalTo(1l));
assertThat(BYTES.toGB(1024 * 1024 * 1024), equalTo(1l));
}
@Test
public void testKB() {
assertThat(KB.toBytes(1), equalTo(1024l));
assertThat(KB.toKB(1), equalTo(1l));
assertThat(KB.toMB(1024), equalTo(1l));
assertThat(KB.toGB(1024 * 1024), equalTo(1l));
}
@Test
public void testMB() {
assertThat(MB.toBytes(1), equalTo(1024l * 1024));
assertThat(MB.toKB(1), equalTo(1024l));
assertThat(MB.toMB(1), equalTo(1l));
assertThat(MB.toGB(1024), equalTo(1l));
}
@Test
public void testGB() {
assertThat(GB.toBytes(1), equalTo(1024l * 1024 * 1024));
assertThat(GB.toKB(1), equalTo(1024l * 1024));
assertThat(GB.toMB(1), equalTo(1024l));
assertThat(GB.toGB(1), equalTo
```
<Overlap Ratio: 0.9610678531701891>

---

--- 328 --
Question ID: 1c582ac1b81910b0f81a82266c59f8c5b94e8164
Original Code:
```
public class ShimBridgingClassloader extends ClassLoader implements BundleReference {

    public static final String HADOOP_SPOON_PLUGIN = "HadoopSpoonPlugin";

    private static PluginClassloaderGetter pluginClassloaderGetter = new PluginClassloaderGetter();

    private final BundleWiring bundleWiring;

    private final PublicLoadResolveClassLoader bundleWiringClassloader;

    public ShimBridgingClassloader(ClassLoader parentClassLoader, BundleContext bundleContext) {
        super(parentClassLoader);
        this.bundleWiring = (BundleWiring) bundleContext.getBundle().adapt(BundleWiring.class);
        this.bundleWiringClassloader = new PublicLoadResolveClassLoader(bundleWiring.getClassLoader());
    }

    public static Object create(BundleContext bundleContext, String className, List<Object> arguments) throws KettlePluginException, ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {
        ShimBridgingClassloader shimBridgingClassloader = new ShimBridgingClassloader(pluginClassloaderGetter.getPluginClassloader(LifecyclePluginType.class.getCanonicalName(), HADOOP_SPOON_PLUGIN), bundleContext);
        Class<?> clazz = Class.forName(className, true, shimBridgingClassloader);
        if (arguments == null || arguments.size() == 0) {
            return clazz.newInstance();
        }
        for (Constructor<?> constructor : clazz.getConstructors()) {
            Class<?>[] parameterTypes = constructor.getParameterTypes();
            if (parameterTypes.length == arguments.size()) {
                boolean match = true;
                int i = 0;
                while (i < parameterTypes.length) try {
                    Object o = arguments.get(i);
                    if (o != null && !parameterTypes[i].isInstance(o)) {
                        match = false;
                        break;
                    }
                } finally {
                    i++;
                }
                if (match) {
                    return constructor.newInstance(arguments.toArray());
                }
            }
        }
        throw new InstantiationException("Unable to find constructor for class " + className + " with arguments " + arguments);
    }

    @VisibleForTesting
    static PluginClassloaderGetter getPluginClassloaderGetter() {
        return pluginClassloaderGetter;
    }

    @VisibleForTesting
    static void setPluginClassloaderGetter(PluginClassloaderGetter pluginClassloaderGetter) {
        ShimBridgingClassloader.pluginClassloaderGetter = pluginClassloaderGetter;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        int lastIndexOfDot = name.lastIndexOf('.');
        final String packageName;
        final String translatedPath;
        final String translatedName;
        if (lastIndexOfDot >= 0) {
            packageName = name.substring(0, lastIndexOfDot);
            if (getPackage(packageName) == null) {
                definePackage(packageName, null, null, null, null, null, null, null);
            }
            translatedPath = "/" + packageName.replace('.', '/');
            translatedName = name.substring(lastIndexOfDot + 1) + ".class";
        } else {
            packageName = "";
            translatedPath = "/";
            translatedName = name;
        }
        if (getPackage(packageName) == null) {
            definePackage(packageName, null, null, null, null, null, null, null);
        }
        List<URL> entries = bundleWiring.findEntries(translatedPath, translatedName, 0);
        if (entries.size() == 1) {
            byte[] bytes;
            try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {
                IOUtils.copy(entries.get(0).openStream(), byteArrayOutputStream);
                bytes = byteArrayOutputStream.toByteArray();
            } catch (IOException e) {
                throw new ClassNotFoundException("Unable to define class", e);
            }
            return defineClass(name, bytes, 0, bytes.length);
        }
        throw new ClassNotFoundException();
    }

    @Override
    public URL getResource(String name) {
        int lastIndexOf = name.lastIndexOf('/');
        List<URL> entries;
        if (lastIndexOf > 0) {
            entries = bundleWiring.findEntries(name.substring(0, lastIndexOf), name.substring(lastIndexOf + 1), 0);
        } else {
            entries = bundleWiring.findEntries("/", name, 0);
        }
        if (entries.size() == 1) {
            return entries.get(0);
        }
        URL resource = bundleWiringClassloader.getResource(name);
        if (resource == null) {
            resource = super.getResource(name);
        }
        return resource;
    }

    @Override
    public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        Class<?> result = null;
        synchronized (this) {
            result = findLoadedClass(name);
        }
        if (result == null) {
            try {
                result = findClass(name);
            } catch (Exception e) {
            }
        }
        if (result == null) {
            try {
                Class<?> osgiProvidedClass = bundleWiringClassloader.loadClass(name, resolve);
                if (osgiProvidedClass.getClassLoader() == PluginRegistry.class.getClassLoader()) {
                    // should have loaded from the parent)
                    try {
                        return super.loadClass(name, resolve);
                    } catch (Exception e) {
                    }
                }
                return osgiProvidedClass;
            } catch (Exception e) {
            }
        }
        if (result == null) {
            return super.loadClass(name, resolve);
        }
        if (resolve) {
            resolveClass(result);
        }
        return result;
    }

    @Override
    public Bundle getBundle() {
        return this.bundleWiring.getBundle();
    }

    /**
     * Trivial classloader subclass that lets us call loadClass with a resolve parameter
     */
    @VisibleForTesting
    static class PublicLoadResolveClassLoader extends ClassLoader {

        public PublicLoadResolveClassLoader(ClassLoader parent) {
            super(parent);
        }

        @Override
        public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
            return super.loadClass(name, resolve);
        }
    }
}

```


Overlapping Code:
```
ShimBridgingClassloader extends ClassLoader implements BundleReference {
public static final String HADOOP_SPOON_PLUGIN = "HadoopSpoonPlugin";
private static PluginClassloaderGetter pluginClassloaderGetter = new PluginClassloaderGetter();
private final BundleWiring bundleWiring;
private final PublicLoadResolveClassLoader bundleWiringClassloader;
pubundleContext.getBundle().adapt(BundleWiring.class)ext bundleContext, String className, List<Object> nException, ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException {
S;
if (arguments == null || arguments.size() == 0) {
return }
for (Constructor<?> constructor : clazz.getConstructors()) {
Class<?>[] parameterTypes = constructor.getParameterTypes();
if (parameterTypes.length == ad constructor for class " + className + " with argc PluginClassloaderGetter getPluginClassloaderGetter() {
return pluginClassloaderGetter;
}
@VisibleF
```
<Overlap Ratio: 0.45396669931439765>

---

--- 329 --
Question ID: d8c97610050943cdf2ccaade422a76ac48e11c71
Original Code:
```
public class B_SuperClass {

    public static void main(String[] args) {
        Class<?> clazz = Example_B_SuperClass.class;
        Class<?> superclass = clazz.getSuperclass();
        System.out.println(superclass);
    }
}

```


Overlapping Code:
```
SuperClass {
public static void main(String[] args) {
Class<?> clazz = Example_B_SuperClass.class;
Class<?> superclass = clazz.getSuperclass();
System.out.println(superclass);
}

```
<Overlap Ratio: 0.9175257731958762>

---

--- 330 --
Question ID: 7bdc9937970a43098edff3a966f21a3d4997caf4
Original Code:
```
public class HomePage extends TestBase {

    @Override
    public void excute() throws Exception {
        WebClient webClient = new WebClient();
        HtmlPage page = webClient.getPage("http://atealxt.appspot.com/guestbook");
        Assert.assertEquals("Guestbook - Hero's Grave", page.getTitleText());
        // ?????????????????????????????
        String pageAsXml = page.asXml();
        Assert.assertTrue(pageAsXml.contains("<script src=\"/javascripts/guestbook.js\" type=\"text/javascript\">"));
        logger.info(pageAsXml);
        String pageAsText = page.asText();
        Assert.assertTrue(pageAsText.contains("Welcome to my personal website, hope you to find out your own territory!"));
        logger.info(pageAsText);
        webClient.closeAllWindows();
    }
}

```


Overlapping Code:
```
age extends TestBase {
@Override
public void excute() throws Exception {
WebClient webClient = new WebClient();
HtmlPage page = webClient.getPage("http://atealxt.appspot.com/guestbook");
Assert.assertEquals("Guestbook - Hero's Grave", page.getTitleTeing pageAsXml = page.asXml();
Assert.assertTrue(pageAsXml.contains("<script src=\"/javascripts/guestbook.js\" type=\"text/javascript\">"));
logger.info(pageAsXml);
String pageAsText = page.asText();
Assert.assertTrue(pageAsText.contains("Welcome to my penal website, hope you to find out your own territory!"));
logger.info(pageAsText);
webClient.closeAl
```
<Overlap Ratio: 0.8843338213762811>

---

--- 331 --
Question ID: 135e2861092daaa6b77ef88ad408f7b6a510cb30
Original Code:
```
public class TestMySQLDialect {

    @Test
    public void testGetLimitString() {
        MySQLDialect mySQLDialect = new MySQLDialect();
        String sql = "select GEN_NAME,GEN_VALUE FROM sys_sequence WHERE GEN_NAME = #{value}";
        System.out.println(mySQLDialect.getLimitString(sql, 1, 5));
        System.out.println(mySQLDialect.getCountString(sql));
        System.out.print(sql);
    }
}

```


Overlapping Code:
```
TestMySQLDialect {
@Test
public void testGetLimitString() {
MySQLDialect mySQLDialect = new MySQLDialect();
String sql = "select GEN_NAME,GEN_VALUE FROM sys_sequence WHERE GEN_NAME = #{value}";
System.out.println(mySQLDialect.getLimitString(sql, 1, 5));
System.out.println(mySQLDialect.getCountString
```
<Overlap Ratio: 0.8645533141210374>

---

--- 332 --
Question ID: 82ffa0c5c43034bbc57a5c1a00a6cd9ed811d54a
Original Code:
```
public class AWSV4AuthParser implements AWSAuthParser {

    private final static Logger LOG = LoggerFactory.getLogger(AWSV4AuthParser.class);

    private MultivaluedMap<String, String> headerMap;

    private MultivaluedMap<String, String> queryMap;

    private String uri;

    private String method;

    private AuthorizationHeaderV4 v4Header;

    private String stringToSign;

    private String amzContentPayload;

    public AWSV4AuthParser(ContainerRequestContext context) throws OS3Exception {
        this.headerMap = context.getHeaders();
        this.queryMap = context.getUriInfo().getQueryParameters();
        try {
            this.uri = new URI(context.getUriInfo().getRequestUri().getPath().replaceAll("\\/+", "/")).normalize().getPath();
        } catch (URISyntaxException e) {
            throw S3_TOKEN_CREATION_ERROR;
        }
        this.method = context.getMethod();
        v4Header = new AuthorizationHeaderV4(headerMap.getFirst(AUTHORIZATION_HEADER));
    }

    public void parse() throws Exception {
        StringBuilder strToSign = new StringBuilder();
        //    HashedCanonicalRequest
        String algorithm, requestDateTime, credentialScope, canonicalRequest;
        algorithm = v4Header.getAlgorithm();
        requestDateTime = headerMap.getFirst(X_AMAZ_DATE);
        Credential credential = v4Header.getCredentialObj();
        credentialScope = String.format("%s/%s/%s/%s", credential.getDate(), credential.getAwsRegion(), credential.getAwsService(), credential.getAwsRequest());
        // If the absolute path is empty, use a forward slash (/)
        uri = (uri.trim().length() > 0) ? uri : "/";
        // Encode URI and preserve forward slashes
        strToSign.append(algorithm + NEWLINE);
        strToSign.append(requestDateTime + NEWLINE);
        strToSign.append(credentialScope + NEWLINE);
        canonicalRequest = buildCanonicalRequest();
        strToSign.append(hash(canonicalRequest));
        if (LOG.isDebugEnabled()) {
            LOG.debug("canonicalRequest:[{}]", canonicalRequest);
        }
        if (LOG.isTraceEnabled()) {
            headerMap.keySet().forEach(k -> LOG.trace("Header:{},value:{}", k, headerMap.get(k)));
        }
        LOG.debug("StringToSign:[{}]", strToSign);
        stringToSign = strToSign.toString();
    }

    private String buildCanonicalRequest() throws OS3Exception {
        Iterable<String> parts = split("/", uri);
        List<String> encParts = new ArrayList<>();
        for (String p : parts) {
            encParts.add(urlEncode(p));
        }
        String canonicalUri = join("/", encParts);
        String canonicalQueryStr = getQueryParamString();
        StringBuilder canonicalHeaders = new StringBuilder();
        for (String header : v4Header.getSignedHeaders()) {
            List<String> headerValue = new ArrayList<>();
            canonicalHeaders.append(header.toLowerCase());
            canonicalHeaders.append(":");
            for (String originalHeader : headerMap.keySet()) {
                if (originalHeader.toLowerCase().equals(header)) {
                    headerValue.add(headerMap.getFirst(originalHeader).trim());
                }
            }
            if (headerValue.size() == 0) {
                throw new RuntimeException("Header " + header + " not present in " + "request");
            }
            if (headerValue.size() > 1) {
                Collections.sort(headerValue);
            }
            // Set for testing purpose only to skip date and host validation.
            validateSignedHeader(header, headerValue.get(0));
            canonicalHeaders.append(join(",", headerValue));
            canonicalHeaders.append(NEWLINE);
        }
        String payloadHash;
        if (UNSIGNED_PAYLOAD.equals(headerMap.get(X_AMZ_CONTENT_SHA256))) {
            payloadHash = UNSIGNED_PAYLOAD;
        } else {
            payloadHash = headerMap.getFirst(X_AMZ_CONTENT_SHA256);
        }
        String signedHeaderStr = v4Header.getSignedHeaderString();
        String canonicalRequest = method + NEWLINE + canonicalUri + NEWLINE + canonicalQueryStr + NEWLINE + canonicalHeaders + NEWLINE + signedHeaderStr + NEWLINE + payloadHash;
        return canonicalRequest;
    }

    @VisibleForTesting
    void validateSignedHeader(String header, String headerValue) throws OS3Exception {
        switch(header) {
            case HOST:
                try {
                    URI hostUri = new URI(headerValue);
                    InetAddress.getByName(hostUri.getHost());
                } catch (UnknownHostException | URISyntaxException e) {
                    LOG.error("Host value mentioned in signed header is not valid. " + "Host:{}", headerValue);
                    throw S3_TOKEN_CREATION_ERROR;
                }
                break;
            case X_AMAZ_DATE:
                LocalDate date = LocalDate.parse(headerValue, TIME_FORMATTER);
                LocalDate now = LocalDate.now();
                if (date.isBefore(now.minus(PRESIGN_URL_MAX_EXPIRATION_SECONDS, SECONDS)) || date.isAfter(now.plus(PRESIGN_URL_MAX_EXPIRATION_SECONDS, SECONDS))) {
                    LOG.error("AWS date not in valid range. Request timestamp:{} should " + "not be older than {} seconds.", headerValue, PRESIGN_URL_MAX_EXPIRATION_SECONDS);
                    throw S3_TOKEN_CREATION_ERROR;
                }
                break;
            case X_AMZ_CONTENT_SHA256:
                // TODO: Construct request payload and match HEX(SHA256(requestPayload))
                break;
            default:
                break;
        }
    }

    /**
     * String join that also works with empty strings.
     *
     * @return joined string
     */
    private static String join(String glue, List<String> parts) {
        StringBuilder result = new StringBuilder();
        boolean addSeparator = false;
        for (String p : parts) {
            if (addSeparator) {
                result.append(glue);
            }
            result.append(p);
            addSeparator = true;
        }
        return result.toString();
    }

    /**
     * Returns matching strings.
     *
     * @param regex Regular expression to split by
     * @param whole The string to split
     * @return pieces
     */
    private static Iterable<String> split(String regex, String whole) {
        Pattern p = Pattern.compile(regex);
        Matcher m = p.matcher(whole);
        List<String> result = new ArrayList<>();
        int pos = 0;
        for (; m.find(); ) {
            result.add(whole.substring(pos, m.start()));
            pos = m.end();
        }
        result.add(whole.substring(pos));
        return result;
    }

    private String urlEncode(String str) {
        try {
            return URLEncoder.encode(str, UTF_8.name()).replaceAll("\\+", "%20").replaceAll("%7E", "~");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    private String getQueryParamString() {
        List<String> params = new ArrayList<>(queryMap.keySet());
        // Sort by name, then by value
        Collections.sort(params, (o1, o2) -> o1.equals(o2) ? queryMap.getFirst(o1).compareTo(queryMap.getFirst(o2)) : o1.compareTo(o2));
        StringBuilder result = new StringBuilder();
        for (String p : params) {
            if (result.length() > 0) {
                result.append("&");
            }
            result.append(urlEncode(p));
            result.append('=');
            result.append(urlEncode(queryMap.getFirst(p)));
        }
        return result.toString();
    }

    public static String hash(String payload) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        md.update(payload.getBytes(UTF_8));
        return Hex.encode(md.digest()).toLowerCase();
    }

    public String getAwsAccessId() {
        return v4Header.getAccessKeyID();
    }

    public String getSignature() {
        return v4Header.getSignature();
    }

    public String getStringToSign() throws Exception {
        return stringToSign;
    }
}

```


Overlapping Code:
```
Parser {
private final static Logger LOG = LoggerFactory.getLogger(AWSV4AuthParser.class);
private MultivaluedMap<String, String> headerMap;
private MultivaluedMap<String, String> queryMap;
private String uri;
private String method;
private AuthorizationHeaderV4 v4Header;
private String stringToSign;
private String amzContentPayload;
public AWSV4AuthException {
this.headerMap = context.getHeaders();
this.queryMap = context.getUriInfo().getQueryParameters();
try {
this.uri = new URI(context.getUriI.normalize().getPath();
} catch (URISyntaxException e) {
throw S3_TOKEN_CREATION_ERROR;
}
this.method = context.getMethod();
v4Header = new AutON_HEADER));
}
public void parse() throws Exception {
StringBuilder strToSign = new StringBuilder();ithm, requestDateTime, credentialScope, canonicalRequest;
algorithm = v4Header.getAlgorithm();
requestDateTime = headerMap.getFirst(X_AMAZ_DATE);
Credential credential = v4Header.getCredentialObj();
credentialScope = String.format("%s/%s/%s/%s", credential.ential.getAwsRequest());
// If the absolute path is empty, use a forward slash (/)
uri = (uri.trim().length() > 0) ? uri : "/";
// Encode URI and preserve forward slashes
strToSign.append(algorithm + NEWLINE);
strToSign.append(requestDateTime + NEWLINE);
strToSign.append(credentialScope + NEWLINE);
canonicalRequest = buildCanonicalRequest();
strToSign.append(hash(canonicalRequest));
if (LOG.isDebugEnabled()) {
LOG.debug("canonicalRequest:[{}]", canonicalRequest);
}
if (LOG.isTraceEnabled()) {
headerMap.keySet().forEach(k -> LOG.trace("Header:{},value:{}", k)));
}
LOG.debug("StringToSign:[{}]", strToSign);
stringToSign = strToSign.toString();
}
private String buildCanonicalRequest() throws OS3Exception {
Iterable<String> parts = split("/", uri);
List<String> encParts = new ArrayList<>()
```
<Overlap Ratio: 0.8413664014974263>

---

--- 333 --
Question ID: e81b5f345b921f4750ec25a2ac2076deb78ae3c4
Original Code:
```
public class HtdfTransferTest {

    @Test
    public void sign() throws Exception {
        String hexPrivateKey = "25E9F2EDAAF9464E9FA0EFDB896835741EBE0F5E34F97CFB88457818B6681C32";
        byte[] privateKey = Hex.decode(hexPrivateKey);
        MessageDigest sh256Digest = MessageDigest.getInstance("SHA-256");
        sh256Digest.update("hello".getBytes(StandardCharsets.UTF_8));
        byte[] sha256Bytes = sh256Digest.digest();
        byte[] sigRS = HtdfTransfer.sign(sha256Bytes, privateKey);
        //s:6e97dba80c7050b2bf2afbaa2a6a5ee93646e36218c9a9bbda56d377df15989a
        final String RIGHT_RS = "5a74e18c921f8a1d0e4086cbb3806942829613fba638c1cb75b5da35324c8ab6" + "6e97dba80c7050b2bf2afbaa2a6a5ee93646e36218c9a9bbda56d377df15989a";
        System.out.println(Hex.toHexString(sigRS));
        assertTrue(RIGHT_RS.compareTo(Hex.toHexString(sigRS)) == 0);
    }

    @Test
    public void htdfToSatoshi1() {
        assertTrue(0 == HtdfToSatoshi(BigDecimal.valueOf(0.1234)).compareTo(BigInteger.valueOf(12340000)));
    }

    @Test
    public void doHttpGet() throws Exception {
        String ret = HtdfTransfer.doHttpGet("http://www.htdfscan.com");
        assertTrue(ret.length() > 0);
    }

    @Test
    public void doHttpPost() {
    }

    @Test
    public void transfer() throws Exception {
        String dstAddress = "htdf1jrh6kxrcr0fd8gfgdwna8yyr9tkt99ggmz9ja2";
        String memo = "htdf transaction demo in java";
        BigInteger amountSatoshi = HtdfToSatoshi(BigDecimal.valueOf(0.12345678));
        HtdfTransfer.transfer(dstAddress, amountSatoshi, memo);
    }
}

```


Overlapping Code:
```
est {
@Test
public void sign() throws Exception {
String hexPrivateKey = "25E9F2EDAAF9464E9FA0EFDB896835741EBE0F5E34F97CFe(hexPrivateKey);
MessageDigest sh256Digest = MessageDigest.getInstance("SHA-256");
sh256Digest.update("hello".getBytes(StandardCharsets.UTF_8));
byte[] sha256Bytes = sh256Digest.digest();
byte[] sigRS = HtdfTransfer.sign(sha256Bytes, privateKey);
//b2bf2afbaa2a6a5ee93646e36218c9a9bbda56d377df15989ab2bf2afbaa2a6a5ee93646e36218c9a9bbda56d377df15989a {
assertTrue(0 == HtdfToSatoshi(BigDecimal.valueOf(0.1234)).compareTo(BigInteger.valueOf(12340000)));
}
@Test
public void doHttpGet() throws Exception {
String ret = HtdfTransfer.doHttpGet("http://www.htdfscan.com");
assertTrue(ret.length() > 0);
}
}
@Test
public void transfer() throws Exception {
String dstAddress = "htdf1jrh6kxrcr0fd8gfgdwna8yyr9tkt99ggmz9ja2";
String memo = "htdf transaction demo in java";
BigInteger amountSatoshi = HtdfToSatoshi(Bi
```
<Overlap Ratio: 0.6652329749103942>

---

--- 334 --
Question ID: f8859217700a688c3b89f361bb816019b9456d26
Original Code:
```
public final class JoinUtils {

    private JoinUtils() {
    }

    public static List<Page> channelsToPages(List<List<Block>> channels) {
        if (channels.isEmpty()) {
            return ImmutableList.of();
        }
        int pagesCount = channels.get(0).size();
        ImmutableList.Builder<Page> pagesBuilder = ImmutableList.builderWithExpectedSize(pagesCount);
        int pageIndex = 0;
        while (pageIndex < pagesCount) try {
            Block[] blocks = new Block[channels.size()];
            int channelIndex = 0;
            while (channelIndex < blocks.length) try {
                blocks[channelIndex] = channels.get(channelIndex).get(pageIndex);
            } finally {
                ++channelIndex;
            }
            pagesBuilder.add(new Page(blocks));
        } finally {
            ++pageIndex;
        }
        return pagesBuilder.build();
    }

    public static boolean isBuildSideReplicated(JoinNode joinNode) {
        return PlanNodeSearcher.searchFrom(joinNode.getRight()).recurseOnlyWhen(MorePredicates.<PlanNode>isInstanceOfAny(ProjectNode.class).or(JoinUtils::isLocalRepartitionExchange)).where(JoinUtils::isRemoteReplicatedExchange).matches();
    }

    private static boolean isRemoteReplicatedExchange(PlanNode node) {
        if (!(node instanceof ExchangeNode)) {
            return false;
        }
        ExchangeNode exchangeNode = (ExchangeNode) node;
        return exchangeNode.getScope() == REMOTE && exchangeNode.getType() == REPLICATE;
    }

    private static boolean isLocalRepartitionExchange(PlanNode node) {
        if (!(node instanceof ExchangeNode)) {
            return false;
        }
        ExchangeNode exchangeNode = (ExchangeNode) node;
        return exchangeNode.getScope() == LOCAL && exchangeNode.getType() == REPARTITION;
    }
}

```


Overlapping Code:
```
JoinUtils {
private JoinUtils() {
}
public static List<Page> channelsToPages(List<List<BEmpty()) {
return ImmutableList.of();
}
int pagesCount = channels.get(0).size();
ImmutableList.Builder<Page> pagesBuilder = ImmutableList.builderWithExpectedSize(pagchannelIndex] = channels.get(channelIndex).get(pageIndex);
} finally {
++channelIndex;
}
pagesBueturn pagesBuilder.build();
}
public static boolean isBuildSideReplicated(JoinNode joivate static boolean isRemoteReplicatedExchange(Plode)) {
return false;
}
ExchangeNode exchangeNode = (ExchangeNode) node;
return exchangeNode.getScope() == REMOTE && exchangeNode.getType() == REPLICATE;
}
private static boolean isLocalRepartitionExchangode)) {
return false;
}
ExchangeNode exchangeNode = (ExchangeNode) node;
return exchangeNode.getScope() == LOCAL && exchangeNode.getType() == REPARTIT
```
<Overlap Ratio: 0.5662162162162162>

---

--- 335 --
Question ID: b08a80f53c729d0b170df6c3806811715adb16ff
Original Code:
```
public class BitstreamReader extends AbstractReader implements Recyclable {

    private static Logger log = Logger.getLogger(BitstreamReader.class);

    /**
     * Messages to be sent when the user is not authorized to view
     * a particular bitstream. They will be redirected to the login
     * where this message will be displayed.
     */
    private static final String AUTH_REQUIRED_HEADER = "xmlui.BitstreamReader.auth_header";

    private static final String AUTH_REQUIRED_MESSAGE = "xmlui.BitstreamReader.auth_message";

    /**
     * How big a buffer should we use when reading from the bitstream before
     * writing to the HTTP response?
     */
    protected static final int BUFFER_SIZE = 8192;

    /**
     * When should a bitstream expire in milliseconds. This should be set to
     * some low value just to prevent someone hiting DSpace repeatedy from
     * killing the server. Note: there are 1000 milliseconds in a second.
     *
     * Format: minutes * seconds * milliseconds
     *  60 * 60 * 1000 == 1 hour
     */
    protected static final int expires = 60 * 60 * 1000;

    /**
     * The Cocoon response
     */
    protected Response response;

    /**
     * The Cocoon request
     */
    protected Request request;

    /**
     * The bitstream file
     */
    protected InputStream bitstreamInputStream;

    /**
     * The bitstream's reported size
     */
    protected long bitstreamSize;

    /**
     * The bitstream's mime-type
     */
    protected String bitstreamMimeType;

    /**
     * The bitstream's name
     */
    protected String bitstreamName;

    /**
     * True if bitstream is readable by anonymous users
     */
    protected boolean isAnonymouslyReadable;

    /**
     * The last modified date of the item containing the bitstream
     */
    private Date itemLastModified = null;

    /**
     * True if user agent making this request was identified as spider.
     */
    private boolean isSpider = false;

    /**
     * TEMP file for citation PDF. We will save here, so we can delete the temp file when done.
     */
    private File tempFile;

    protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();

    protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();

    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();

    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();

    protected CitationDocumentService citationDocumentService = DisseminateServiceFactory.getInstance().getCitationDocumentService();

    /**
     * Set up the bitstream reader.
     *
     * See the class description for information on configuration options.
     * @param resolver source resolver.
     * @param objectModel Cocoon object model.
     * @param src source to read.
     * @param par Reader parameters.
     * @throws org.apache.cocoon.ProcessingException passed through.
     * @throws org.xml.sax.SAXException passed through.
     * @throws java.io.IOException passed through.
     */
    @Override
    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par) throws ProcessingException, SAXException, IOException {
        super.setup(resolver, objectModel, src, par);
        try {
            this.request = ObjectModelHelper.getRequest(objectModel);
            this.response = ObjectModelHelper.getResponse(objectModel);
            Item item = null;
            // normal processes will close it.
            boolean BitstreamReaderOpenedContext = !ContextUtil.isContextAvailable(objectModel);
            Context context = ContextUtil.obtainContext(objectModel);
            // Get our parameters that identify the bitstream
            String itemID = par.getParameter("itemID", null);
            String bitstreamID = par.getParameter("bitstreamID", null);
            String handle = par.getParameter("handle", null);
            int sequence = par.getParameterAsInteger("sequence", -1);
            String name = par.getParameter("name", null);
            this.isSpider = par.getParameter("userAgent", "").equals("spider");
            // Resolve the bitstream
            Bitstream bitstream = null;
            DSpaceObject dso = null;
            if (bitstreamID != null) {
                // Direct reference to the individual bitstream ID.
                bitstream = bitstreamService.findByIdOrLegacyId(context, bitstreamID);
            } else if (itemID != null) {
                // Referenced by internal itemID
                item = itemService.findByIdOrLegacyId(context, itemID);
                if (sequence > -1) {
                    bitstream = findBitstreamBySequence(item, sequence);
                } else if (name != null) {
                    bitstream = findBitstreamByName(item, name);
                }
            } else if (handle != null) {
                // Reference by an item's handle.
                dso = handleService.resolveToObject(context, handle);
                if (dso instanceof Item) {
                    item = (Item) dso;
                    if (sequence > -1) {
                        bitstream = findBitstreamBySequence(item, sequence);
                    } else if (name != null) {
                        bitstream = findBitstreamByName(item, name);
                    }
                }
            }
            if (item != null) {
                itemLastModified = item.getLastModified();
            }
            // then try to find bitstream by name (assuming we have a file name)
            if ((sequence > -1 && bitstream == null) && name != null) {
                bitstream = findBitstreamByName(item, name);
                // if we found bitstream by name, send a redirect to its new sequence number location
                if (bitstream != null) {
                    String redirectURL = "";
                    // build redirect URL based on whether item has a handle assigned yet
                    if (item.getHandle() != null && item.getHandle().length() > 0) {
                        redirectURL = request.getContextPath() + "/bitstream/handle/" + item.getHandle();
                    } else {
                        redirectURL = request.getContextPath() + "/bitstream/item/" + item.getID();
                    }
                    redirectURL += "/" + name + "?sequence=" + bitstream.getSequenceID();
                    HttpServletResponse httpResponse = (HttpServletResponse) objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
                    httpResponse.sendRedirect(redirectURL);
                    return;
                }
            }
            // Was a bitstream found?
            if (bitstream == null) {
                throw new ResourceNotFoundException("Unable to locate bitstream");
            }
            // Is there a User logged in and does the user have access to read it?
            boolean isAuthorized = authorizeService.authorizeActionBoolean(context, bitstream, Constants.READ);
            if (item != null && item.isWithdrawn() && !authorizeService.isAdmin(context)) {
                isAuthorized = false;
                log.info(LogManager.getHeader(context, "view_bitstream", "handle=" + item.getHandle() + ",withdrawn=true"));
            }
            // It item-request is enabled to all request we redirect to restricted-resource immediately without login request
            String requestItemType = DSpaceServicesFactory.getInstance().getConfigurationService().getProperty("request.item.type");
            if (!isAuthorized) {
                if (context.getCurrentUser() != null || StringUtils.equalsIgnoreCase("all", requestItemType)) {
                    // message that tells them the bitstream is restricted.
                    String redictURL = request.getContextPath() + "/handle/";
                    if (item != null) {
                        redictURL += item.getHandle();
                    } else if (dso != null) {
                        redictURL += dso.getHandle();
                    }
                    redictURL += "/restricted-resource?bitstreamId=" + bitstream.getID();
                    HttpServletResponse httpResponse = (HttpServletResponse) objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
                    httpResponse.sendRedirect(redictURL);
                    return;
                } else {
                    if (StringUtils.isBlank(DSpaceServicesFactory.getInstance().getConfigurationService().getProperty("request.item.type")) || DSpaceServicesFactory.getInstance().getConfigurationService().getProperty("request.item.type").equalsIgnoreCase("logged")) {
                        // successful, their request will be resumed.
                        AuthenticationUtil.interruptRequest(objectModel, AUTH_REQUIRED_HEADER, AUTH_REQUIRED_MESSAGE, null);
                        // Redirect
                        String redictURL = request.getContextPath() + "/login";
                        HttpServletResponse httpResponse = (HttpServletResponse) objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);
                        httpResponse.sendRedirect(redictURL);
                        return;
                    }
                }
            }
            // 3) This object is citation-able
            if (citationDocumentService.isCitationEnabledForBitstream(bitstream, context)) {
                // on-the-fly citation generator
                log.info(item.getHandle() + " - " + bitstream.getName() + " is citable.");
                FileInputStream fileInputStream = null;
                try {
                    //Create the cited document
                    tempFile = citationDocumentService.makeCitedDocument(context, bitstream);
                    if (tempFile == null) {
                        log.error("CitedDocument was null");
                    } else {
                        log.info("CitedDocument was ok," + tempFile.getAbsolutePath());
                    }
                    fileInputStream = new FileInputStream(tempFile);
                    if (fileInputStream == null) {
                        log.error("Error opening fileInputStream: ");
                    }
                    this.bitstreamInputStream = fileInputStream;
                    this.bitstreamSize = tempFile.length();
                } catch (Exception e) {
                    log.error("Caught an error with intercepting the citation document:" + e.getMessage());
                }
            } else {
                this.bitstreamInputStream = bitstreamService.retrieve(context, bitstream);
                this.bitstreamSize = bitstream.getSize();
            }
            this.bitstreamMimeType = bitstream.getFormat(context).getMIMEType();
            this.bitstreamName = bitstream.getName();
            if (context.getCurrentUser() == null) {
                this.isAnonymouslyReadable = true;
            } else {
                this.isAnonymouslyReadable = false;
                for (ResourcePolicy rp : authorizeService.getPoliciesActionFilter(context, bitstream, Constants.READ)) {
                    if (rp.getGroup() != null && rp.getGroup().getName().equals(Group.ANONYMOUS)) {
                        this.isAnonymouslyReadable = true;
                    }
                }
            }
            // Trim any path information from the bitstream
            if (bitstreamName != null && bitstreamName.length() > 0) {
                int finalSlashIndex = bitstreamName.lastIndexOf('/');
                if (finalSlashIndex > 0) {
                    bitstreamName = bitstreamName.substring(finalSlashIndex + 1);
                }
            } else {
                // In-case there is no bitstream name...
                if (name != null && name.length() > 0) {
                    bitstreamName = name;
                    if (name.endsWith(".jpg")) {
                        bitstreamMimeType = "image/jpeg";
                    } else if (name.endsWith(".png")) {
                        bitstreamMimeType = "image/png";
                    }
                } else {
                    bitstreamName = "bitstream";
                }
            }
            // of adding it to the sitemap for every possible bitstream uri is not very tractable
            DSpaceServicesFactory.getInstance().getEventService().fireEvent(new UsageEvent(UsageEvent.Action.VIEW, ObjectModelHelper.getRequest(objectModel), ContextUtil.obtainContext(ObjectModelHelper.getRequest(objectModel)), bitstream));
            // If we created the database connection close it, otherwise leave it open.
            if (BitstreamReaderOpenedContext)
                context.complete();
        } catch (SQLException sqle) {
            throw new ProcessingException("Unable to read bitstream.", sqle);
        } catch (AuthorizeException ae) {
            throw new ProcessingException("Unable to read bitstream.", ae);
        }
    }

    /**
     * Find the bitstream identified by a sequence number on this item.
     *
     * @param item A DSpace item
     * @param sequence The sequence of the bitstream
     * @return The bitstream or null if none found.
     */
    private Bitstream findBitstreamBySequence(Item item, int sequence) throws SQLException {
        if (item == null) {
            return null;
        }
        List<Bundle> bundles = item.getBundles();
        for (Bundle bundle : bundles) {
            List<Bitstream> bitstreams = bundle.getBitstreams();
            for (Bitstream bitstream : bitstreams) {
                if (bitstream.getSequenceID() == sequence) {
                    return bitstream;
                }
            }
        }
        return null;
    }

    /**
     * Return the bitstream from the given item that is identified by the
     * given name. If the name has prepended directories they will be removed
     * one at a time until a bitstream is found. Note that if two bitstreams
     * have the same name then the first bitstream will be returned.
     *
     * @param item A DSpace item
     * @param name The name of the bitstream
     * @return The bitstream or null if none found.
     */
    private Bitstream findBitstreamByName(Item item, String name) throws SQLException {
        if (name == null || item == null) {
            return null;
        }
        // Determine our the maximum number of directories that will be removed for a path.
        int maxDepthPathSearch = 3;
        if (DSpaceServicesFactory.getInstance().getConfigurationService().getProperty("xmlui.html.max-depth-guess") != null) {
            maxDepthPathSearch = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty("xmlui.html.max-depth-guess");
        }
        int i = 0;
        while (i < maxDepthPathSearch + 1) try {
            // if the name can be found
            List<Bundle> bundles = item.getBundles();
            for (Bundle bundle : bundles) {
                List<Bitstream> bitstreams = bundle.getBitstreams();
                for (Bitstream bitstream : bitstreams) {
                    if (name.equals(bitstream.getName())) {
                        return bitstream;
                    }
                }
            }
            // off of the name and see if we lost some path information.
            int indexOfSlash = name.indexOf('/');
            if (indexOfSlash < 0) {
                // bitstream found.
                return null;
            }
            name = name.substring(indexOfSlash + 1);
            // trim everything and only use the trailing filename.
            if (i == maxDepthPathSearch - 1) {
                int indexOfLastSlash = name.lastIndexOf('/');
                if (indexOfLastSlash > -1) {
                    name = name.substring(indexOfLastSlash + 1);
                }
            }
        } finally {
            i++;
        }
        // we search.
        return null;
    }

    /**
     * Write the actual data out to the response.
     *
     * Some implementation notes:
     *
     * 1) We set a short expiration time just in the hopes of preventing someone
     * from overloading the server by clicking reload a bunch of times. I
     * Realize that this is nowhere near 100% effective but it may help in some
     * cases and shouldn't hurt anything.
     *
     * 2) We accept partial downloads, thus if you lose a connection halfway
     * through most web browser will enable you to resume downloading the
     * bitstream.
     * @throws java.io.IOException passed through.
     * @throws org.xml.sax.SAXException passed through.
     * @throws org.apache.cocoon.ProcessingException passed through.
     */
    @Override
    public void generate() throws IOException, SAXException, ProcessingException {
        if (this.bitstreamInputStream == null) {
            return;
        }
        // that might change with different authentication.
        if (isSpider) {
            // Check for if-modified-since header -- ONLY if not authenticated
            long modSince = request.getDateHeader("If-Modified-Since");
            if (modSince != -1 && itemLastModified != null && itemLastModified.getTime() < modSince) {
                // hence bitstream has not been, either; return 304
                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                return;
            }
        }
        // users in the cache for a response later to anonymous user.
        try {
            if (itemLastModified != null && (isSpider || ContextUtil.obtainContext(request).getCurrentUser() == null)) {
                // we don't have last-mod dates for Bitstreams
                response.setDateHeader("Last-Modified", itemLastModified.getTime());
            }
        } catch (SQLException e) {
            throw new ProcessingException(e);
        }
        byte[] buffer = new byte[BUFFER_SIZE];
        int length = -1;
        // if it is accessed anonymously or is readable by Anonymous:
        if (isAnonymouslyReadable) {
            response.setDateHeader("Expires", System.currentTimeMillis() + expires);
        }
        // If this is a large bitstream then tell the browser it should treat it as a download.
        int threshold = DSpaceServicesFactory.getInstance().getConfigurationService().getIntProperty("xmlui.content_disposition_threshold");
        if (bitstreamSize > threshold && threshold != 0) {
            String name = bitstreamName;
            // Try and make the download file name formatted for each browser.
            try {
                String agent = request.getHeader("USER-AGENT");
                if (agent != null && agent.contains("MSIE")) {
                    name = URLEncoder.encode(name, "UTF8");
                } else if (agent != null && agent.contains("Mozilla")) {
                    name = MimeUtility.encodeText(name, "UTF8", "B");
                }
            } catch (UnsupportedEncodingException see) {
            }
            response.setHeader("Content-Disposition", "attachment;filename=" + '"' + name + '"');
        }
        ByteRange byteRange = null;
        try {
            if (byteRange != null) {
                String entityLength;
                String entityRange;
                //VT
                ByteRange requestedRange = null;
                if (this.bitstreamSize != -1) {
                    entityLength = "" + this.bitstreamSize;
                    //VT        new ByteRange(0, this.bitstreamSize)).toString();
                    requestedRange = byteRange.intersection(new ByteRange(0, this.bitstreamSize - 1));
                    entityRange = requestedRange.toString();
                } else {
                    entityLength = "*";
                    entityRange = byteRange.toString();
                }
                response.setHeader("Content-Range", entityRange + "/" + entityLength);
                if (response instanceof HttpResponse) {
                    // Response with status 206 (Partial content)
                    response.setStatus(206);
                }
                int pos = 0;
                int posEnd;
                while ((length = this.bitstreamInputStream.read(buffer)) > -1) {
                    posEnd = pos + length - 1;
                    ByteRange intersection = byteRange.intersection(new ByteRange(pos, posEnd));
                    if (intersection != null) {
                        out.write(buffer, (int) intersection.getStart() - pos, (int) intersection.length());
                    }
                    pos += length;
                }
            } else {
                response.setHeader("Content-Length", String.valueOf(this.bitstreamSize));
                while ((length = this.bitstreamInputStream.read(buffer)) > -1) {
                    out.write(buffer, 0, length);
                }
                out.flush();
            }
        } finally {
            try {
                // Close the bitstream input stream so that we don't leak a file descriptor
                this.bitstreamInputStream.close();
                // Close the output stream as per Cocoon docs: http://cocoon.apache.org/2.2/core-modules/core/2.2/681_1_1.html
                out.close();
            } catch (IOException ioe) {
                // No point since the user has already got the bitstream contents.
                log.warn("Caught IO exception when closing a stream: " + ioe.getMessage());
            }
        }
    }

    /**
     * Returns the mime-type of the bitstream.
     * @return the type.
     */
    @Override
    public String getMimeType() {
        return this.bitstreamMimeType;
    }

    /**
     * Recycle
     */
    @Override
    public void recycle() {
        this.response = null;
        this.request = null;
        this.bitstreamInputStream = null;
        this.bitstreamSize = 0;
        this.bitstreamMimeType = null;
        this.bitstreamName = null;
        this.itemLastModified = null;
        this.tempFile = null;
        super.recycle();
    }
}

```


Overlapping Code:
```
eader extends AbstractReader implements Recyclable {
private static Logger log = Logger.getLogger(BitstreamReader.class);
/**
* Messages to be sent when the user is not authorized to view
* a particular bitstream. They will be redirected to the login
* where this message will be displayed.
*/
private static final String AUTH_REQUIRED_HEADER = "xmlui.BitstreamReader.auth_header";
private static final String AUTH_REQUIRED_MESSAGE = "xmlui.BitstreamReader.auth_message";
/**
* How big a buffer should we use when reading from the bitstream before
* writing to the HTTP response?
*/
protected static final int BUFFER_SIZE = 8192;
/**
* When should a bitstream expire in milliseconds. This should be set to
* some low value just to prevent someone hiting DSpace repeatedy from
* killing the server. Note: there are 1000 milliseconds in a second.
*
* Format: minutes * seconds * milliseconds
* 60 * 60 * 1000 == 1 hour
*/
protected static final int expires = 60 * 60 * 1000 True if user agent making this request was identified a citation PDF. We will save here, so we can delete the temp file when d;
protected AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();
protected BitstreamService bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();
protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();
protected ItemService itemService = ContentServiceFactor
```
<Overlap Ratio: 0.6707932141219624>

---

--- 336 --
Question ID: 48a9c953325d8eadddafc395f69d25eaf7e14bb5
Original Code:
```
public class QuadTreePool extends Pool<QuadTree> {

    private QuadTreeContainer container;

    public QuadTreePool(QuadTreeContainer container) {
        super(50);
        this.container = container;
    }

    public void freeSub(QuadTree quadTree) {
        free(quadTree.ne);
        free(quadTree.nw);
        free(quadTree.se);
        free(quadTree.sw);
        quadTree.ne = quadTree.nw = quadTree.se = quadTree.sw = null;
    }

    public void initSubs(QuadTree quadTree) {
        quadTree.ne = container.poolQuads.obtain();
        quadTree.nw = container.poolQuads.obtain();
        quadTree.se = container.poolQuads.obtain();
        quadTree.sw = container.poolQuads.obtain();
    }

    @Override
    protected QuadTree newObject() {
        return new QuadTree(container);
    }
}

```


Overlapping Code:
```
Tree> {
private QuadTreeContainer container;
public QuadTreePool(QuadTreeContainer container) {
super(50);
this.container = container;
}
public void freeSub(QuadTree quadTree) {
free(quadTree.ne);
free(quadTree.nw);
free(quadTree.se);
free(quadTree.sw);
quadTree.ne = quadTree.nw = quadTree.se = quadTree.sw = null;
}
public void initSubs(QuadTree quadTree) {
quadTree.ne = container.poolQuads.obtain();
quadTree.nw = container.poolQuads.obtain();
quadTree.se = container.poolQuads.obtain();
quadTree.sw = container.poolQuads.obtain();
}
@Override
protected QuadTree newObject() {
return new QuadTree
```
<Overlap Ratio: 0.9104704097116844>

---

--- 337 --
Question ID: 763200963b9fac7b80736eb5620170b19b635e7e
Original Code:
```
class TestingComponentD extends Component implements Cloneable {

    @Prop(resType = ResType.NONE, optional = false)
    int prop1;

    private TestingComponentD(ComponentContext context) {
        super("TestingComponentD");
    }

    public static Builder create(ComponentContext context) {
        return create(context, 0, 0);
    }

    public static Builder create(ComponentContext context, int defStyleAttr, int defStyleRes) {
        final Builder builder = new Builder();
        TestingComponentD instance = new TestingComponentD(context);
        builder.init(context, defStyleAttr, defStyleRes, instance);
        return builder;
    }

    public static class Builder extends Component.Builder<Builder> {

        @Nullable
        TestingComponentD mLithoComponent;

        ComponentContext mContext;

        private final String[] REQUIRED_PROPS_NAMES = new String[] { "prop1" };

        private final int REQUIRED_PROPS_COUNT = 1;

        private final BitSet mRequired = new BitSet(REQUIRED_PROPS_COUNT);

        private void init(ComponentContext context, int defStyleAttr, int defStyleRes, TestingComponentD lithoComponentRef) {
            super.init(context, defStyleAttr, defStyleRes, lithoComponentRef);
            mLithoComponent = lithoComponentRef;
            mContext = context;
            mRequired.clear();
        }

        @Override
        protected void setComponent(Component component) {
            mLithoComponent = (TestingComponentD) component;
        }

        public Builder prop1(int prop1) {
            this.mLithoComponent.prop1 = prop1;
            mRequired.set(0);
            return this;
        }

        @Override
        @Nullable
        public TestingComponentD build() {
            checkArgs(REQUIRED_PROPS_COUNT, mRequired, REQUIRED_PROPS_NAMES);
            return mLithoComponent;
        }

        @Override
        public Builder getThis() {
            return this;
        }
    }
}

```


Overlapping Code:
```
mponentD(ComponentContext context) {
super("TestingComponentD");
}
public static Builder create(ComponentContext context) {
return create(context, 0, 0);
}
public static Builder create(ComponentContext context, int defStyleAttr, int defStyleRes) {
final Builder builder = new Builder();
TestingComponentD instance = new TestingComponentD(context);
builder.init(context, defStyleAttr, defStyleRes, instance);
return builder;
}
public static class Builder extends Component.Builder<Builder> {
@Nullable mLithoComponent;
ComponentContext mContext;
private final String[] REQUIRED_PROPS_NAMES = new Strine final int REQUIRED_PROPS_COUNT = 1;
private final BitSet mRequired = new BitSet(REQUIRED_PROPS_COUNT);
private void init(ComponentContext context, int defStyleAttr, int defStyleRes,lithoComponentRef) {
super.init(context, defStyleAttr, defStyleRes, lithoComponentRef);
mLithoComponent = lithoComponentRef;
mContext = context;
mRequired.clear();
}
@Override
protected void setComponent(Component component) {
mLithoComponent = (TestingComponentD) component;
}
public Builder prop1(int prop1) {
this.mLithoComponent.prop1 = prop1;
mRequired.set(0);
return this;
}
@OveTestingComponentD build() {
checkArgs(REQUIRED_PROPS_COUNT, mRequired, REQUIRED_PROPS_NAMES);
return mLithoComponent;
}
@Override
public Builder getThis() {
return this;
}
}
```
<Overlap Ratio: 0.8557753669432036>

---

--- 338 --
Question ID: 2e2144587792d1fd6ca9470159dc937992a00ce0
Original Code:
```
public class LectorLadronesJSON implements LectorLadrones {

    private String ruta = "src/main/java/edu/fiuba/algo3/modelo/archivosJson/modelosladrones.json";

    public ArrayList<Ladron> cargarLadrones() {
        ArrayList<Ladron> ladrones = new ArrayList<Ladron>();
        JSONParser parser = new JSONParser();
        try {
            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));
            for (Object o : JSONLadrones) {
                JSONObject ladron = (JSONObject) o;
                String nombre = (String) ladron.get("Nombre");
                String sexo = (String) ladron.get("Sexo");
                String hobby = (String) ladron.get("Hobby");
                String cabello = (String) ladron.get("Cabello");
                String caracteristica = (String) ladron.get("Caracter?stica");
                String vehiculo = (String) ladron.get("Veh?culo");
                ArrayList<String> descripciones = (ArrayList<String>) ladron.get("Descripciones");
                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);
                ladrones.add(objLadron);
            }
        } catch (FileNotFoundException e) {
            System.out.println("No se encontro el archivo");
        } catch (IOException e) {
            System.out.println("Entrada y salida interrumpida");
        } catch (ParseException e) {
            System.out.println("Error de parseo en el archivo");
        }
        return ladrones;
    }

    public HashMap<String, ArrayList<String>> obtenerCaracteristicas() {
        HashMap<String, ArrayList<String>> diccionario = new HashMap();
        diccionario.put("Sexo", new ArrayList<String>());
        diccionario.put("Cabello", new ArrayList<String>());
        diccionario.put("Hobby", new ArrayList<String>());
        diccionario.put("Vehiculo", new ArrayList<String>());
        diccionario.put("Senia", new ArrayList<String>());
        JSONParser parser = new JSONParser();
        try {
            JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));
            for (Object o : JSONLadrones) {
                JSONObject ladron = (JSONObject) o;
                String nombre = (String) ladron.get("Nombre");
                String sexo = (String) ladron.get("Sexo");
                ArrayList<String> sexos = diccionario.get("Sexo");
                if (!sexos.contains(sexo)) {
                    sexos.add(sexo);
                }
                String hobby = (String) ladron.get("Hobby");
                ArrayList<String> hobbys = diccionario.get("Hobby");
                if (!hobbys.contains(hobby)) {
                    hobbys.add(hobby);
                }
                String cabello = (String) ladron.get("Cabello");
                ArrayList<String> cabellos = diccionario.get("Cabello");
                if (!cabellos.contains(cabello)) {
                    cabellos.add(cabello);
                }
                String caracteristica = (String) ladron.get("Caracter?stica");
                ArrayList<String> senias = diccionario.get("Senia");
                if (!senias.contains(caracteristica)) {
                    senias.add(caracteristica);
                }
                String vehiculo = (String) ladron.get("Veh?culo");
                ArrayList<String> vehiculos = diccionario.get("Vehiculo");
                if (!vehiculos.contains(vehiculo)) {
                    vehiculos.add(vehiculo);
                }
                ArrayList<String> descripciones = (ArrayList<String>) ladron.get("Descripciones");
                Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);
            }
        } catch (FileNotFoundException e) {
            System.out.println("No se encontro el archivo");
        } catch (IOException e) {
            System.out.println("Entrada y salida interrumpida");
        } catch (ParseException e) {
            System.out.println("Error de parseo en el archivo");
        }
        return diccionario;
    }
}

```


Overlapping Code:
```
/main/java/edu/fiuba/algo3/modelo/archivosJson/modelosladrones.json";
public ArrayList<Ladron> cargarLadrones() {
ArrayList<Ladron> ladrones = new ArrayList<Ladron>();
JSONParser parser = new JSONParser();
try {
JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));
for (Object o : JSONLadrones) {
JSONObject ladron = (JSONObject) o;
String nombre = (String) ladron.get("Nombre");
String sexo = (String) ladron.get("Sexo");
String hobby = (String) ladron.get("Hobby");
String cabello = (String) ladron.get("Cabello");
String cara);
ArrayList<String> descripciones = (ArrayList<String>) ladron.get("Descripciones");
Ladron objLadron = new Ladron(nombre, sexo, hobby, cabello, caracteristica, vehiculo, descripciones);
ladrones.addon);
}
} catch (FileNotFoundException e) {
System.out.println("No se encontro el archivo");
} catch (IOException e) {
System.out.println("Entrada y salida interrumpida");
} catch (ParseException e) {
System.out.println("Error de parseo en el archivo");
}
return ladrones;
}
public HashMap<String, ArrayList<String>> obtenerCaracteristicas() {
HashMap<String, ArrayList<String>> diccionario = new HashMap();
diccionario.put("Sexo", new ArrayList<String>());
diccionario.put("Cabello", new ArrayList<String>());
diccionario.put("Hobby", new ArrayList<String>());
diccionario.put("Vehiculo", new ArrayList<String>());
diccionario.put("Senia", new ArrayList<String>());
JSONParser parser = new JSONParser();
try {
JSONArray JSONLadrones = (JSONArray) parser.parse(new FileReader(this.ruta));
for (Object o : JSONLadrones) {
JSONObject ladron = (JSONObject) o;
String nombre = (String) ladron.get("Nombre");
String sexo = (String) ladron.get("Sexo");
ArrayList<String> sexos = diccionario.get("Sexo");
if (!sexos.contains(sexo)) {
sexos.add(sexo);
```
<Overlap Ratio: 0.9024635495223731>

---

--- 339 --
Question ID: 16d5f6bd57d22f954e4f4bcebb596da796cc9164
Original Code:
```
@UnitTest
public class MavenCodeLocationPackagerTest {

    @Test
    public void testParseProject() {
        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());
        Dependency dependency = mavenCodeLocationPackager.textToProject("stuff:things:jar:0.0.1");
        assertNotNull(dependency);
        dependency = mavenCodeLocationPackager.textToProject("stuff:things:jar:classifier:0.0.1");
        assertNotNull(dependency);
        dependency = mavenCodeLocationPackager.textToProject("stuff:things:jar");
        assertNull(dependency);
        dependency = mavenCodeLocationPackager.textToProject("stuff:things:jar:classifier:0.0.1:monkey");
        assertNull(dependency);
    }

    @Test
    public void testParseDependency() {
        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());
        ScopedDependency dependency = mavenCodeLocationPackager.textToDependency("stuff:things:jar:0.0.1:compile");
        assertNotNull(dependency);
        dependency = mavenCodeLocationPackager.textToDependency("stuff:things:jar:classifier:0.0.1:test");
        assertNotNull(dependency);
        dependency = mavenCodeLocationPackager.textToDependency("stuff:things:jar");
        assertNull(dependency);
        dependency = mavenCodeLocationPackager.textToDependency("stuff:things:jar:classifier:0.0.1");
        assertNotNull(dependency);
    }

    @Test
    public void testIsLineRelevant() {
        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);
        assertTrue(mavenCodeLocationPackager.isLineRelevant("weird garbage 3525356 [thingsINFO 346534623465] stuff"));
        assertTrue(mavenCodeLocationPackager.isLineRelevant("[thingsINFO 346534623465]stuff"));
        assertTrue(mavenCodeLocationPackager.isLineRelevant("[thingsINFO]  stuff"));
        assertFalse(mavenCodeLocationPackager.isLineRelevant(" [INFO]     "));
        assertFalse(mavenCodeLocationPackager.isLineRelevant("weird garbage 3525356 [thingsINFO 346534623465]"));
        assertFalse(mavenCodeLocationPackager.isLineRelevant("[thingsINFO 346534623465]"));
        assertFalse(mavenCodeLocationPackager.isLineRelevant("[thingsINFO]"));
        assertFalse(mavenCodeLocationPackager.isLineRelevant(" [INFO]"));
        assertFalse(mavenCodeLocationPackager.isLineRelevant(" "));
        assertFalse(mavenCodeLocationPackager.isLineRelevant("[INFO] Downloaded"));
        assertFalse(mavenCodeLocationPackager.isLineRelevant("[INFO] stuff and thingsDownloaded stuff and things"));
        assertFalse(mavenCodeLocationPackager.isLineRelevant("[INFO] Downloading"));
        assertFalse(mavenCodeLocationPackager.isLineRelevant("[INFO] stuff and things Downloadingstuff and things"));
    }

    @Test
    public void testTrimLogLevel() {
        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);
        String actualLine = "";
        final String expectedValue = "thing";
        actualLine = mavenCodeLocationPackager.trimLogLevel("weird garbage 3525356 [thingsINFO 346534623465]" + expectedValue);
        assertEquals(expectedValue, actualLine);
        actualLine = mavenCodeLocationPackager.trimLogLevel("[thingsINFO 346534623465]" + expectedValue);
        assertEquals(expectedValue, actualLine);
        actualLine = mavenCodeLocationPackager.trimLogLevel("[thingsINFO]" + expectedValue);
        assertEquals(expectedValue, actualLine);
        actualLine = mavenCodeLocationPackager.trimLogLevel(" [INFO] " + expectedValue);
        assertEquals(expectedValue, actualLine);
    }

    @Test
    public void testIsProjectSection() {
        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);
        assertFalse(mavenCodeLocationPackager.isProjectSection(" "));
        assertFalse(mavenCodeLocationPackager.isProjectSection("       "));
        assertFalse(mavenCodeLocationPackager.isProjectSection("---maven-dependency-plugin:"));
        assertFalse(mavenCodeLocationPackager.isProjectSection("---maven-dependency-plugin:other      stuff"));
        assertFalse(mavenCodeLocationPackager.isProjectSection("maven-dependency-plugin:tree      stuff"));
        assertTrue(mavenCodeLocationPackager.isProjectSection("---maven-dependency-plugin:tree      stuff"));
        assertTrue(mavenCodeLocationPackager.isProjectSection("things --- stuff maven-dependency-plugin garbage:tree      stuff"));
        assertTrue(mavenCodeLocationPackager.isProjectSection("things --- stuff maven-dependency-plugin:tree      stuff"));
        assertTrue(mavenCodeLocationPackager.isProjectSection("---maven-dependency-plugin:tree"));
        assertTrue(mavenCodeLocationPackager.isProjectSection("      ---       maven-dependency-plugin      :       tree"));
    }

    @Test
    public void testIsDependencyTreeUpdates() {
        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);
        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates("artifact com.google.guava:guava:jar:15.0:compile checking for updates from"));
        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates("         artifact       com.google.guava:guava:         checking for updates"));
        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates("      checking for updates   artifact       com.google.guava:guava:      "));
        assertTrue(mavenCodeLocationPackager.isDependencyTreeUpdates("checking for updates"));
        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates("com.google.guava:guava:jar:15.0:compile"));
        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates("+- com.google.guava:guava:jar:15.0:compile"));
        assertFalse(mavenCodeLocationPackager.isDependencyTreeUpdates("|  \\- com.google.guava:guava:jar:15.0:compile"));
    }

    @Test
    public void testIsGav() {
        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);
        assertFalse(mavenCodeLocationPackager.isGav(" "));
        assertFalse(mavenCodeLocationPackager.isGav("       "));
        assertFalse(mavenCodeLocationPackager.isGav("::::"));
        assertFalse(mavenCodeLocationPackager.isGav(" : : : : "));
        assertFalse(mavenCodeLocationPackager.isGav("group"));
        assertFalse(mavenCodeLocationPackager.isGav("group:artifact"));
        assertFalse(mavenCodeLocationPackager.isGav("group:artifact:version"));
        assertFalse(mavenCodeLocationPackager.isGav("group-artifact:type-classifier-version:scope-garbage"));
        assertFalse(mavenCodeLocationPackager.isGav("group:artifact::classifier:version: :garbage"));
        assertTrue(mavenCodeLocationPackager.isGav("group:artifact:type:version"));
        assertTrue(mavenCodeLocationPackager.isGav("group:artifact:type:classifier:version"));
        assertTrue(mavenCodeLocationPackager.isGav("group:artifact:type:classifier:version:scope"));
        assertTrue(mavenCodeLocationPackager.isGav("group:artifact:type:classifier:version:scope:garbage"));
    }

    @Test
    public void testIndexOfEndOfSegments() {
        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);
        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments(""));
        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments("stuff and things"));
        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments("stuff and things", "things", "and"));
        assertEquals(-1, mavenCodeLocationPackager.indexOfEndOfSegments("stuff and things", "things", "and", "stuff"));
        assertEquals(5, mavenCodeLocationPackager.indexOfEndOfSegments("stuff and things", "stuff"));
        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments("stuff and things", "stuff", "and"));
        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments("stuff and things", "stuff", "and", "things"));
        assertEquals(9, mavenCodeLocationPackager.indexOfEndOfSegments("stuff and things", "and"));
        assertEquals(16, mavenCodeLocationPackager.indexOfEndOfSegments("stuff and things", "things"));
    }

    @Test
    public void testDoesLineContainSegmentsInOrder() {
        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);
        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder(""));
        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder("stuff and things"));
        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder("stuff and things", "things", "and"));
        assertFalse(mavenCodeLocationPackager.doesLineContainSegmentsInOrder("stuff and things", "things", "and", "stuff"));
        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder("stuff and things", "stuff"));
        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder("stuff and things", "stuff", "and"));
        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder("stuff and things", "stuff", "and", "things"));
        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder("stuff and things", "and"));
        assertTrue(mavenCodeLocationPackager.doesLineContainSegmentsInOrder("stuff and things", "things"));
    }

    @Test
    public void testLineWithExtraTextAfterScope() {
        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());
        String line = "[INFO] |  |  |  \\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:compile (version selected from constraint [3.8.0,3.8.1))";
        line = mavenCodeLocationPackager.trimLogLevel(line);
        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);
        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);
        assertEquals("org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411", dependency.getExternalId().createExternalId());
    }

    @Test
    public void testLineWithUnknownScope() {
        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());
        String line = "[INFO] |  |  |  \\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from constraint [3.8.0,3.8.1))";
        line = mavenCodeLocationPackager.trimLogLevel(line);
        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);
        final ScopedDependency scopedDependency = mavenCodeLocationPackager.textToDependency(cleanedLine);
        assertEquals("org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:3.8.0.v20160509-0411", scopedDependency.getExternalId().createExternalId());
    }

    @Test
    public void testLineWithBadColonPlacement() {
        final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());
        String line = "[INFO] |  |  |  \\- org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:jar:3.8.0.v20160509-0411:pants (version selected from: [3.8.0,3.8.1))";
        line = mavenCodeLocationPackager.trimLogLevel(line);
        final String cleanedLine = mavenCodeLocationPackager.calculateCurrentLevelAndCleanLine(line);
        final Dependency dependency = mavenCodeLocationPackager.textToDependency(cleanedLine);
        assertEquals("org.eclipse.scout.sdk.deps:org.eclipse.core.jobs:pants (version selected from", dependency.getExternalId().createExternalId());
    }
}

```


Overlapping Code:
```
CodeLocationPackagerTest {
@Test
public void testParseProject() {
final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());
Dependency dependency = mavenCodeLocationPackager.textToProject("stuff:things:jar:0.0.1");
assertNotNull(dependency);
dependency = mavenCodeLocationPackager.textToProject("stuff:things:jar:classifier:0.0.1");
assertNotNull(dependency);
dependency = mavenCodeLocationPackager.textToProject("stuff:things:jar");
assertNull(dependency);
dependency = mavenCodeLocationPackager.textToProject("stuff:things:jar:classifier:0.0.1:monkey");
assertNull(dependency);
}
@Test
public void testParseDependency() {
final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(new ExternalIdFactory());
ScopedDependency dependency = mavenCodeLocationPackager.textToDependency("stuff:things:jar:0.0.1:compile");
assertNotNull(dependency);
dependency = mavenCodeLocationPackager.textToDependency("stuff:things:jar:classifier:0.0.1:test");
assertNotNull(dependency);
dependency = mavenCodeLocationPackager.textToDependency("stuff:things:jar");
assertNull(dependency);
dependency = mavenCodeLocationPackager.textToDependency("stuff:things:jar:classifier:0.0.1");
assertNotNull(dependency);
}
@Test
public void testIsLineRelevant() {
final MavenCodeLocationPackager mavenCodeLocationPackager = new MavenCodeLocationPackager(null);
assertTrue(mavenCodeLocationPackager.isLineRelevant("weird garbage 3525356 [thingsINFO 346534623465] stuff"));
assertTrue(mavenCodeLocationPackager.isLineRelevant("[thingsINFO 346534623465]stuff"));
assertTrue(mavenCodeLocationPackager.isLineRelevant("[thingsINFO] stuff"));
assertFalse(mavenCodeLocationPackager.isLineRelevant(" [INFO] "));
assertFalse(mavenCodeLocationPackager.isLineRelevant("weird garbage 3525356 [thingsINFO 346534623465]"));
assertFalse(mavenCodeLocationPackager.isLineRelevant("[thingsINFO 346534623465]"));
assertFalse(mavenCodeLocationPackager.isLineRelevant("[thingsINFO]"));
assertFalse(mavenCodeLocationPackager.isLineRelevant(" [INFO]"));
assertFalse(mavenCodeLocationPackager.isLineRelevant(" "));
assertFalse(mavenCodeLocationPackager.isLineRele
```
<Overlap Ratio: 0.9869779973057925>

---

--- 340 --
Question ID: 21bf6ff3974912f326f07e60b655d83815cf8d49
Original Code:
```
public class CertificateBuilderTest {

    @Test
    public void SelfSignCertificateBuilder() {
        KeyPair keyPair = new KeyPairBuilder().setAlgorithm("RSA").setLength(2048).setProvider("bc").setSecureRandom(new SecureRandom()).build();
        PKCS10CertificationRequest pkcs10CertificationRequest = new CertificateRequestBuilder().setSubject("C=CN,L=nanjing,O=koal,OU=develop,CN=robert").setPublicKey(keyPair.getPublic()).setPrivateKey(keyPair.getPrivate()).setProvider("BC").build();
        try {
            X509Certificate signCertificate = Converter.file2Cert(new FileInputStream("/Users/robert/client.crt"));
            X509Certificate x509Certificate = new CertificateBuilder().setSignCertificate(signCertificate).setCA(true).setPathLen(10).setRequest(pkcs10CertificationRequest).setSerialNumber(new BigInteger("1")).setSignKey(keyPair.getPrivate()).build();
            Converter.cert2File(x509Certificate, new FileOutputStream("/Users/robert/test.crt"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```


Overlapping Code:
```
st {
@Test
public void SelfSignCertificateBuilder(;
PKCS10CertificationRequest pkcs10CertificationRequest = new icKey(keyPair.getPublic()).setPrivateKey(keyPair.getPrivate()509Certificate signCertificate = Converter.file2Cert(new FileInputStream("/Users/robert/client.crt"));
X509Certificate x509Certificate = new Certificart"));
} catch (IOException e) {
e.printStackTrace();
}
}
}
```
<Overlap Ratio: 0.4>

---

--- 341 --
Question ID: 7cbaabecd2cc61947ab6279a547d2c9290a3bb1e
Original Code:
```
@Path("/shop")
@Produces(MediaType.APPLICATION_JSON)
public class ShoppingController {

    private static final Logger logger = LoggerFactory.getLogger(ShoppingService.class);

    private final StylingApi stylingApi;

    ShoppingController() {
        String stylingUrl = "http://localhost:50051";
        WavefrontJaxrsClientFilter wavefrontJaxrsFilter = null;
        // wavefrontJaxrsFilter = wfJaxrsClientFilter;
        this.stylingApi = BeachShirtsUtils.createProxyClient(stylingUrl, StylingApi.class, wavefrontJaxrsFilter);
    }

    @GET
    @Path("/menu")
    public Response getShoppingMenu(@Context HttpHeaders httpHeaders) {
        return Response.ok(stylingApi.getAllStyles()).build();
    }

    @POST
    @Path("/order")
    @Consumes(APPLICATION_JSON)
    public Response orderShirts(OrderDTO orderDTO, @Context HttpHeaders httpHeaders) {
        if (ThreadLocalRandom.current().nextInt(0, 10) == 0) {
            String msg = "Failed to order shirts!";
            logger.warn(msg);
            return Response.status(Response.Status.SERVICE_UNAVAILABLE).entity(msg).build();
        }
        Response deliveryResponse = stylingApi.makeShirts(orderDTO.getStyleName(), orderDTO.getQuantity());
        if (deliveryResponse.getStatus() < 400) {
            DeliveryStatusDTO deliveryStatus = deliveryResponse.readEntity(DeliveryStatusDTO.class);
            return Response.ok().entity(deliveryStatus).build();
        } else {
            String msg = "Failed to order shirts!";
            logger.warn(msg);
            return Response.status(deliveryResponse.getStatus()).entity(msg).build();
        }
    }
}

```


Overlapping Code:
```
op")
@Produces(MediaType.APPLICATION_JSON)
public class ShoppingController {
private static final Logger logger = LoggerFactory.getLogger(ShoppingService.class);
private final StylingApi stylingApi;
ShoppingController() {
String stylingUrl = "http://localhost:50051";
WavefrontJaxrsClientFilter wavefrontJaxrsFilter = null;
// wavefrontJaxrsFilter = wfJaxrsClientFilter;
this.stylingApi = BeachShirtsUtils.createProxyClient(stylingUrl, StylingApi.class, wavefrontJaxrsFilter);
}
@GET
@Path("/menu")
public Response getShoppingMenu(@Context HttpHeaders httpHeaders) {
return Response.ok(stylingApi.getAllStyles()).build();
}
@POST
@Path("/order")
@Consumes(APPLICATION_JSON)
public Response orderShirts(OrderDTO orderDTO, @Context HttpHeaders httpHeaders) {
if (ThreadLocalRandom.current().nextInt(0, 10) == 0) {
String msg = "Failed to order shirts!";
logger.warn(msg);
return Response.status(Response.Status.SERVICE_UNAVAILABLE).entity(msg).build();
}
Response deliveryResponse = stylingApi.makeShirts(orderDTO.getStyleName(), orderDTO.getQuant);
if (deliveryResponse.getStatus() < 400) {
DeliveryStatusDTO deliveryStatus = deliveryResponse.readEntity(DeliveryStatusDTO.class);
return Response.ok().entity(deliveryStatus).build();
} else {
String msg = "Failed to order shirts!";
logger.warn(msg);
return Response.status(deliveryResponse.getStatus()).entit
```
<Overlap Ratio: 0.9741564967695621>

---

--- 342 --
Question ID: a38fec13b412ae11bdd8b5e9e7e1fe1d7cd98108
Original Code:
```
public class IndustrialJackhammerItem extends JackhammerItem {

    public IndustrialJackhammerItem() {
        super(ToolMaterials.DIAMOND, TechRebornConfig.industrialJackhammerCharge, EnergyTier.INSANE, TechRebornConfig.industrialJackhammerCost);
    }

    // Cycle Inactive, Active 3*3 and Active 5*5
    private void switchAOE(ItemStack stack, int cost, boolean isClient, int messageId) {
        ItemUtils.checkActive(stack, cost, isClient, messageId);
        if (!ItemUtils.isActive(stack)) {
            ItemUtils.switchActive(stack, cost, isClient, messageId);
            stack.getOrCreateTag().putBoolean("AOE5", false);
            if (isClient) {
                ChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t("techreborn.message.setTo") + " " + Formatting.GOLD + "3*3"));
            }
        } else {
            if (isAOE5(stack)) {
                ItemUtils.switchActive(stack, cost, isClient, messageId);
                stack.getOrCreateTag().putBoolean("AOE5", false);
            } else {
                stack.getOrCreateTag().putBoolean("AOE5", true);
                if (isClient) {
                    ChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t("techreborn.message.setTo") + " " + Formatting.GOLD + "5*5"));
                }
            }
        }
    }

    private boolean shouldBreak(World worldIn, BlockPos originalPos, BlockPos pos) {
        if (originalPos.equals(pos)) {
            return false;
        }
        BlockState blockState = worldIn.getBlockState(pos);
        if (blockState.getMaterial() == Material.AIR) {
            return false;
        }
        if (blockState.getMaterial().isLiquid()) {
            return false;
        }
        if (blockState.getBlock() instanceof OreBlock) {
            return false;
        }
        if (blockState.getBlock() instanceof RedstoneOreBlock) {
            return false;
        }
        return (Items.IRON_PICKAXE.isEffectiveOn(blockState));
    }

    private boolean isAOE5(ItemStack stack) {
        return !stack.isEmpty() && stack.getTag() != null && stack.getTag().getBoolean("AOE5");
    }

    // JackhammerItem
    @Override
    public boolean postMine(ItemStack stack, World worldIn, BlockState stateIn, BlockPos pos, LivingEntity entityLiving) {
        if (!ItemUtils.isActive(stack)) {
            return super.postMine(stack, worldIn, stateIn, pos, entityLiving);
        }
        int radius = isAOE5(stack) ? 2 : 1;
        for (BlockPos additionalPos : ToolsUtil.getAOEMiningBlocks(worldIn, pos, entityLiving, radius)) {
            if (shouldBreak(worldIn, pos, additionalPos)) {
                ToolsUtil.breakBlock(stack, worldIn, additionalPos, entityLiving, cost);
            }
        }
        return super.postMine(stack, worldIn, stateIn, pos, entityLiving);
    }

    // PickaxeItem
    @Override
    public float getMiningSpeed(ItemStack stack, BlockState state) {
        if (state.getMaterial() == Material.STONE && Energy.of(stack).getEnergy() >= cost) {
            // x4 diamond mining speed
            return 32.0F;
        } else {
            return 0.5F;
        }
    }

    // Item
    @Override
    public TypedActionResult<ItemStack> use(final World world, final PlayerEntity player, final Hand hand) {
        final ItemStack stack = player.getStackInHand(hand);
        if (player.isSneaking()) {
            switchAOE(stack, cost, world.isClient, MessageIDs.poweredToolID);
            return new TypedActionResult<>(ActionResult.SUCCESS, stack);
        }
        return new TypedActionResult<>(ActionResult.PASS, stack);
    }

    @Override
    public void usageTick(World world, LivingEntity entity, ItemStack stack, int i) {
        ItemUtils.checkActive(stack, cost, entity.world.isClient, MessageIDs.poweredToolID);
    }

    @Environment(EnvType.CLIENT)
    @Override
    public void appendTooltip(ItemStack stack, @Nullable World worldIn, List<Text> tooltip, TooltipContext flagIn) {
        ItemUtils.buildActiveTooltip(stack, tooltip);
        if (ItemUtils.isActive(stack)) {
            if (isAOE5(stack)) {
                tooltip.add(new LiteralText("5*5").formatted(Formatting.RED));
            } else {
                tooltip.add(new LiteralText("3*3").formatted(Formatting.RED));
            }
        }
    }
}

```


Overlapping Code:
```
JackhammerItem extends JackhammerItem {
public IndustrialJackhammerItem() {
super(ToolMaterials.DIAMOND, TechRebornConfig.industrialJackhammerCharge, EnergyTier.INSANE, TechRebornConfig.industrialJackhammerCost);
}
// Cycle Inactive, Active 3*3 and Active 5*5
private void switchAOE(ItemStack stack, int cost, boolean isClient, int messageId) {
ItemUtils.checkActive(stack, cost, isClient, messageId);
if (!ItemUtils.isActive(stack)) {
ItemUtils.switchActive(stack, cost, isClient, messageId);
stack.getOrCreateTag().putBoolean("AOE5", false);
if (isClient) {
ChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t("techreborn.message.setTo") + " " + Formatting.GOLD + "3*3"));
}
} else {
if (isAOE5(stack)) {
ItemUtils.switchActive(stack, cost, isClient, messageId);
stack.getOrCreateTag().putBoolean("AOE5", false);
} else {
stack.getOrCreateTag().putBoolean("AOE5", true);
if (isClient) {
ChatUtils.sendNoSpamMessages(messageId, new LiteralText(Formatting.GRAY + StringUtils.t("techreborn.message.setTo") + " " + Formatting.GOLD + "5*5"));
}
}
}
}
private boolean shouldBreak(World worldIn, BlockPos originalPos, BlockPos pos) {
if (originalPos.equals(pos)) {
return false;
}
BlockState blockState = worldIn.getBlockState(pos);
if (blockState.getMaterial() == Material.AIR) {
return false;
}
if (blockState.getMaterial().isLiquid()) {
return false;
}
if (blockState.getBlock() instanceof OreBlock) {
return false;
}
if (blockState.getBlock() instanceof RedstoneOreBlock) {
return false;
}
return (Items.IRON_PICKAXE.isEffectiveOn(blockState));
}
private boolean isAOE5(ItemStack stack) {
return !stack.isEmpty() && stack.getTag() != null && stack.getTag().getBoolean("AOE5");
}
// JackhammerItem
@Override
public boolean postMine(ItemStack stack, World worldIn, BlockState stateIn, BlockPos pos, LivingEntity entityLiving) {
if (!ItemUtils.isActive(stack)) {
return super.postMine(stack, worldIn, stateIn, pos, entityLiving);
}
int radius = 
```
<Overlap Ratio: 0.985543369890329>

---

--- 343 --
Question ID: 0a4a4369ec3b6de4d86e3c5f2ecc32c64dac30a0
Original Code:
```
public class Identifieds {

    private Identifieds() {
    }

    public static Function<Identified, Description> TO_DESCRIPTION = new Function<Identified, Description>() {

        @Override
        public Description apply(Identified input) {
            return (Description) input;
        }
    };

    public static Predicate<Identified> IS_DESCRIPTION = new Predicate<Identified>() {

        @Override
        public boolean apply(Identified input) {
            return input instanceof Description;
        }
    };

    public static List<Description> getDescriptions(Iterable<? extends Identified> identifieds) {
        return ImmutableList.copyOf(Iterables.transform(Iterables.filter(identifieds, IS_DESCRIPTION), TO_DESCRIPTION));
    }

    private static Iterable<Person> getEmbeddedPeople(Iterable<Item> items) {
        return Iterables.concat(Iterables.transform(items, TO_PEOPLE));
    }

    private static Iterable<Identified> getEmbeddedBrandsAndSeries(Iterable<Item> items) {
        return Iterables.concat(Iterables.transform(items, TO_BRAND_AND_SERIES_SUMMARIES));
    }

    public static Iterable<Identified> getFlattenedIdentifieds(Iterable<? extends Identified> identifieds) {
        Iterable<Person> people = Iterables.filter(identifieds, Person.class);
        Iterable<Description> allDescriptions = Iterables.filter(identifieds, Description.class);
        List<Item> allItems = Descriptions.getItems(allDescriptions);
        Iterable<Identified> embeddedBrandsAndSeries = getEmbeddedBrandsAndSeries(allItems);
        Iterable<Person> embeddedPeople = getEmbeddedPeople(allItems);
        return Iterables.concat(allDescriptions, embeddedBrandsAndSeries, people, embeddedPeople);
    }

    public static Iterable<ContentIdentifier> getContentIdentifiers(Iterable<? extends Identified> identifieds) {
        Builder<ContentIdentifier> builder = ImmutableList.builder();
        Iterable<Playlist> playlists = Iterables.filter(identifieds, Playlist.class);
        for (Playlist playlist : playlists) {
            builder.addAll(playlist.getContent());
            builder.addAll(playlist.getSeriesList());
            if (playlist.getAvailableContent() != null) {
                builder.addAll(playlist.getAvailableContent());
            }
            if (playlist.getUpcomingContent() != null) {
                builder.addAll(playlist.getUpcomingContent());
            }
        }
        Iterable<Person> people = Iterables.filter(identifieds, Person.class);
        for (Person person : people) {
            // people embedded in items/brands don't have content attached
            if (person.getContent() != null) {
                builder.addAll(person.getContent());
            }
        }
        return builder.build();
    }

    private static final Function<Item, Iterable<Identified>> TO_BRAND_AND_SERIES_SUMMARIES = new Function<Item, Iterable<Identified>>() {

        @Override
        public Iterable<Identified> apply(Item input) {
            Builder<Identified> builder = ImmutableList.builder();
            if (input.getSeriesSummary() != null) {
                builder.add(input.getSeriesSummary());
            }
            if (input.getBrandSummary() != null) {
                builder.add(input.getBrandSummary());
            }
            return builder.build();
        }
    };
}

```


Overlapping Code:
```
iption> TO_DESCRIPTION = new Function<Identified, Description>() {
@Override
public Description apply(Identified input) {
return (Description) input;
IPTION = new Predicate<Identified>() {
@Override
public boolean apply(Identified input) {
return inpt<Description> getDescriptions(Iterable<? extends Identified> identifieds) {
return ImmutableList.copyOf(Iterables.transform(Iterables.filter(identifi static Iterable<Person> getEmbeddedPeople(Iterable<Item> items) {
return Iterables.concat(Iterablesterable<Identified> getEmbeddedBrandsAndSeries(Iterable<Item> items) {
return Iterables.concat(Iterables.transform(items, TO_BRAND_AND_SERIES_SUMMARIEtenedIdentifieds(Iterable<? extends Identified> idle<Person> people = Iterables.filter(identifieds, Person.class);
Iterable<Description> allDescriptions = Iterables.filter(identifiscriptions.getItems(allDescriptions);
Iterable<Identified> embeddedBrandsAndSeries = getEmbeddedBrandsAndSeries(allItems);
Iterable<Person> embeddedPeles.concat(allDescriptions, embeddedBrandsAndSerieble<ContentIdentifier> getContentIdentifiers(Iterable<? extends Identified> identifieds) {
Builder<ContentIdentifier> builder = ImmutableList.builder(r(identifieds, Playlist.class);
for (Playlist playlist : playlists) {
builder.addAll(playlist.getContent());
builder.addAll(playlist.getSeriesList());
if (playlist.getAvailableContent() != null) {
builder.addAll(playlist.getAvailableContent());
}
if (playlist.getUpcomingContent() != null) {
builder.le<Person> people = Iterables.filter(identifieds, 
```
<Overlap Ratio: 0.7146193367585241>

---

--- 344 --
Question ID: cbdaafcd9298f370a6c6ed63c5358f105f12b3e8
Original Code:
```
public final class CookieManager extends CookieHandler {

    private static final Logger logger = Logger.getLogger(CookieManager.class.getName());

    private final CookieStore store = new CookieStore();

    /**
     * Creates a new {@code CookieManager}.
     */
    public CookieManager() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Map<String, List<String>> get(URI uri, Map<String, List<String>> requestHeaders) {
        if (logger.isLoggable(Level.FINEST)) {
            logger.log(Level.FINEST, "uri: [{0}], requestHeaders: {1}", new Object[] { uri, toLogString(requestHeaders) });
        }
        if (uri == null) {
            throw new IllegalArgumentException("uri is null");
        }
        if (requestHeaders == null) {
            throw new IllegalArgumentException("requestHeaders is null");
        }
        String cookieString = get(uri);
        Map<String, List<String>> result;
        if (cookieString != null) {
            result = new HashMap<String, List<String>>();
            result.put("Cookie", Arrays.asList(cookieString));
        } else {
            result = Collections.emptyMap();
        }
        if (logger.isLoggable(Level.FINEST)) {
            logger.log(Level.FINEST, "result: {0}", toLogString(result));
        }
        return result;
    }

    /**
     * Returns the cookie string for a given URI.
     */
    private String get(URI uri) {
        String host = uri.getHost();
        if (host == null || host.length() == 0) {
            logger.log(Level.FINEST, "Null or empty URI host, returning null");
            return null;
        }
        host = canonicalize(host);
        String scheme = uri.getScheme();
        boolean secureProtocol = "https".equalsIgnoreCase(scheme) || "javascripts".equalsIgnoreCase(scheme);
        boolean httpApi = "http".equalsIgnoreCase(scheme) || "https".equalsIgnoreCase(scheme);
        List<Cookie> cookieList;
        synchronized (store) {
            cookieList = store.get(host, uri.getPath(), secureProtocol, httpApi);
        }
        StringBuilder sb = new StringBuilder();
        for (Cookie cookie : cookieList) {
            if (sb.length() > 0) {
                sb.append("; ");
            }
            sb.append(cookie.getName());
            sb.append('=');
            sb.append(cookie.getValue());
        }
        return sb.length() > 0 ? sb.toString() : null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void put(URI uri, Map<String, List<String>> responseHeaders) {
        if (logger.isLoggable(Level.FINEST)) {
            logger.log(Level.FINEST, "uri: [{0}], responseHeaders: {1}", new Object[] { uri, toLogString(responseHeaders) });
        }
        if (uri == null) {
            throw new IllegalArgumentException("uri is null");
        }
        if (responseHeaders == null) {
            throw new IllegalArgumentException("responseHeaders is null");
        }
        for (Map.Entry<String, List<String>> entry : responseHeaders.entrySet()) {
            String key = entry.getKey();
            if (!"Set-Cookie".equalsIgnoreCase(key)) {
                continue;
            }
            ExtendedTime currentTime = ExtendedTime.currentTime();
            // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7059532
            ListIterator<String> it = entry.getValue().listIterator(entry.getValue().size());
            for (; it.hasPrevious(); ) {
                Cookie cookie = Cookie.parse(it.previous(), currentTime);
                if (cookie != null) {
                    put(uri, cookie);
                    currentTime = currentTime.incrementSubtime();
                }
            }
        }
    }

    /**
     * Puts an individual cookie.
     */
    private void put(URI uri, Cookie cookie) {
        logger.log(Level.FINEST, "cookie: {0}", cookie);
        String host = uri.getHost();
        if (host == null || host.length() == 0) {
            logger.log(Level.FINEST, "Null or empty URI host, ignoring cookie");
            return;
        }
        host = canonicalize(host);
        if (PublicSuffixes.isPublicSuffix(cookie.getDomain())) {
            if (cookie.getDomain().equals(host)) {
                cookie.setDomain("");
            } else {
                logger.log(Level.FINEST, "Domain is public suffix, " + "ignoring cookie");
                return;
            }
        }
        if (cookie.getDomain().length() > 0) {
            if (!Cookie.domainMatches(host, cookie.getDomain())) {
                logger.log(Level.FINEST, "Hostname does not match domain, " + "ignoring cookie");
                return;
            } else {
                cookie.setHostOnly(false);
            }
        } else {
            cookie.setHostOnly(true);
            cookie.setDomain(host);
        }
        if (cookie.getPath() == null) {
            cookie.setPath(Cookie.defaultPath(uri));
        }
        boolean httpApi = "http".equalsIgnoreCase(uri.getScheme()) || "https".equalsIgnoreCase(uri.getScheme());
        if (cookie.getHttpOnly() && !httpApi) {
            logger.log(Level.FINEST, "HttpOnly cookie received from non-HTTP " + "API, ignoring cookie");
            return;
        }
        synchronized (store) {
            Cookie oldCookie = store.get(cookie);
            if (oldCookie != null) {
                if (oldCookie.getHttpOnly() && !httpApi) {
                    logger.log(Level.FINEST, "Non-HTTP API attempts to " + "overwrite HttpOnly cookie, blocked");
                    return;
                }
                cookie.setCreationTime(oldCookie.getCreationTime());
            }
            store.put(cookie);
        }
        logger.log(Level.FINEST, "Stored: {0}", cookie);
    }

    /**
     * Converts a map of HTTP headers to a string suitable for displaying
     * in the log.
     */
    private static String toLogString(Map<String, List<String>> headers) {
        if (headers == null) {
            return null;
        }
        if (headers.isEmpty()) {
            return "{}";
        }
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<String, List<String>> entry : headers.entrySet()) {
            String key = entry.getKey();
            for (String value : entry.getValue()) {
                sb.append(String.format("%n    "));
                sb.append(key);
                sb.append(": ");
                sb.append(value);
            }
        }
        return sb.toString();
    }

    /**
     * Canonicalizes a hostname as required by RFC 6265.
     */
    private static String canonicalize(String hostname) {
        // The hostname is already all-ASCII at this point
        return hostname.toLowerCase();
    }
}

```


Overlapping Code:
```
kieManager extends CookieHandler {
private static final Logger logger = Logger.getLogger(CookieManager.class.getName());
private final CookieStore store = new CookieStore();
/**
* Creates a new {@code CookieManager}.
*/
public CookieManager() {
}
/**
* {@inheritDoc}
*/
@Override
public Map<String, List<String>> get(URI uri, Map<String, List<String>> requestHeaders) {
if (logger.isLoggable(Level.FINEST)) {
logger.log(Level.FINEST, "uri: [{0}], reque;
}
if (uri == null) {
throw new IllegalArgumentException("uri is null");
}
if (requestHeaders == null) {
throw new IllegalArgumentException("requestHeaders is null");
}
String cookieSt
if (cookieString != null) {
result = new HashMap<String, List<String>>();
result.put("Cs.asList(cookieString));
} else {
result = Collections.emptyMap();
}
if (logger.isLoggable(Level.FINEST)) {
logger.log(Level.FINEST, "result: {0}", toLogString(result));
}
return result;
}
/**
* Returns the cookie string for a given URI.
*/
private String get(URI uri) {
String host = uri.getHost();
if (host == null || host.length() == 0) {
logger.log(Level.FINEST, "Null or empty URI host, returning null");
return null;
}
host = canonicalize(host);
String scheme = uri.getScheme();
boolean secureProtocol = "https".equalsIgnoreCase(scheme) || "javascripts".equalsIgnoreCase(scheme);
boolean httpApi = "http".equalsIgnoreCase(scheme) || "https".equalsIgnoreCase(scheme);
List<Cookie> cookieList;
synchronized (store) {
cookieList = store.get(host, uri.getPath(), secureProtocol, httpApi);
}
StringBuilder sb = new StringBuilder();
for (Cookie cookie : cookieList) {
if (sb.length() > 0) {
sb.append("; ");
}
sb.append(cookie.getName());
sb.append('=');
sb.append(cookie.getValue());
}
return sb.length() > 0 ? sb.toString() : null;
}
/**
* {@inheritDoc}
*/
@Override
public void put(
```
<Overlap Ratio: 0.9173846933603649>

---

--- 345 --
Question ID: 1aa4b7d2a9d3993327fbc3ab5af3a225a40834a6
Original Code:
```
public class Main {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        Examples e = new Examples();
    }
}

```


Overlapping Code:
```
public class Main {
/**
* @param args the command line arguments
*/
public static void main(String[] args) {
// TODO code application logic here
Examples e = new Ex
```
<Overlap Ratio: 0.9265536723163842>

---

--- 346 --
Question ID: 9fe15468b8a7ba983a58726361f89a67189c0327
Original Code:
```
public class VivecraftTransformationService implements ITransformationService {

    private static final Logger LOGGER = LogManager.getLogger();

    public static URL ZipFileUrl;

    private static ZipFile ZipFile;

    private static VivecraftTransformer transformer;

    @Override
    public String name() {
        return "Vivecraft";
    }

    @Override
    public void initialize(IEnvironment environment) {
        LOGGER.info("VivecraftTransformationService.initialize");
    }

    @Override
    public void beginScanning(IEnvironment environment) {
    }

    @Override
    public void onLoad(IEnvironment env, Set<String> otherServices) throws IncompatibleEnvironmentException {
        LOGGER.info("VivecraftTransformationService.onLoad");
        try {
            ZipFileUrl = Utils.getVivecraftZipLocation().toURL();
            ZipFile = Utils.getVivecraftZip();
            transformer = new VivecraftTransformer(ZipFile);
        } catch (Exception exception) {
            LOGGER.error("Error loading ZIP file: " + ZipFileUrl, (Throwable) exception);
            throw new IncompatibleEnvironmentException("Error loading ZIP file: " + ZipFileUrl);
        }
    }

    @Override
    public Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> additionalResourcesLocator() {
        return ITransformationService.super.additionalResourcesLocator();
    }

    @Override
    public Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> additionalClassesLocator() {
        Set<String> set = new HashSet<>();
        set.add("org.vivecraft.");
        Supplier<Function<String, Optional<URL>>> supplier = () -> {
            return this::getResourceUrl;
        };
        Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> entry = new SimpleEntry<>(set, supplier);
        LOGGER.info("additionalClassesLocator: " + set);
        return entry;
    }

    public Optional<URL> getResourceUrl(String name) {
        if (name.endsWith(".class") && !name.startsWith("optifine/")) {
            name = "srg/" + name;
        }
        if (transformer == null) {
            return Optional.empty();
        } else {
            ZipEntry zipentry = ZipFile.getEntry(name);
            if (zipentry == null) {
                return Optional.empty();
            } else {
                try {
                    String s = ZipFileUrl.toExternalForm();
                    URL url = new URL("jar:" + s + "!/" + name);
                    return Optional.of(url);
                } catch (IOException ioexception) {
                    LOGGER.error(ioexception);
                    return Optional.empty();
                }
            }
        }
    }

    @Override
    public List<ITransformer> transformers() {
        LOGGER.info("VivecraftTransformationService.transformers");
        List<ITransformer> list = new ArrayList<>();
        if (transformer != null) {
            list.add(transformer);
        }
        list.add(new VivecraftASMTransformer());
        return list;
    }

    public static VivecraftTransformer getTransformer() {
        return transformer;
    }
}

```


Overlapping Code:
```
ic class VivecraftTransformationService implements ITransformationService {
private static final Logger LOGGER = LogManager.getLogger();
public static URL ZipFileUrl;
private static ZipFile ZipFile;
private static VivecraftTransformer transformer;
@Override
public Strin;
}
@Override
public void initialize(IEnvironment environment) {
.info("VivecraftTransformationService.initialize");
}
@Override
public void beginScanning(IEnvironment environment) {
}
@Override
public void onLoad(IEnvironment env, Set<String> otherServices) throws IncompatibleEnvironmentException {GGER.info("VivecraftTransformationService.onLoad");
try {
ZipFileUrl = Utils.getVivecraftZipLocation().toURL();
ZipFile = Utils.getVivecraftZip();
transformer = nile);
} catch (Exception exception) {
LOGGER.error("Error loading ZIP file: " + ZipFileUnew IncompatibleEnvironmentException("Error loading ZIP file: " + ZipFileUrl);
}
}
@Override
public Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> additionalResourcesLocator(TransformationService.super.additionalResourcesLocator();
}
@Override
public Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> additionalClassesLocet<String> set = new HashSet<>();
set.add("org.vivecraft.");
Supplier<Function<String, Optional<URL>>> supplier = () is::getResourceUrl;
};
Entry<Set<String>, Supplier<Function<String, Optional<URL>>>> entry = new SimpleEntry<>(set, supplier);
LOGGER.info("additionalClassesLocator: " + set);
return entry;
}
public Optional<URL> getResourceUrl(String ne.endsWith(".class") && !name.startsWith("optifine zipentry = ZipFile.getEntry(name);
if (zipentry =String s = ZipFileUrl.toExternalForm();
URL url = new URL("jar:" + s + "!/" + name);
return Optional.
```
<Overlap Ratio: 0.849112426035503>

---

--- 347 --
Question ID: b03dd0c9940a7be99af35e2cda606850ecc8f431
Original Code:
```
@Controller
@RequestMapping("/applications")
public class ApplicationCrudController extends AbstractCrudController<Application> {

    private static final String[] ALLOWED_FIELDS = new String[] { "name", "shortDescription", "scm.user", "scm.repo" };

    @Inject
    private ApplicationService applicationService;

    @Inject
    private FarmService farmService;

    /* (non-Javadoc)
	 * @see org.zkybase.web.controller.AbstractCrudController#getService()
	 */
    @Override
    public CIService<Application> getService() {
        return applicationService;
    }

    /* (non-Javadoc)
	 * @see org.zkybase.web.controller.AbstractCrudController#getAllowedFields()
	 */
    @Override
    protected String[] getAllowedFields() {
        return ALLOWED_FIELDS;
    }

    /* (non-Javadoc)
	 * @see org.zkybase.web.controller.AbstractEntityNoFormController#doGetDetails(java.lang.Long, org.springframework.ui.Model)
	 */
    @Override
    protected Application doGetDetails(Long id, Model model) {
        Application app = getService().findOne(id);
        List<Farm> farms = CollectionsUtil.asSortedList(farmService.findByApplication(app));
        model.addAttribute(farms);
        return app;
    }
}

```


Overlapping Code:
```
ntroller
@RequestMapping("/applications")
public class ApplicationCrudController extends AbstractCrudController<Application> {
private static final String[] ALLOWED_FIELDS = new String[] { "name", ";
@Inject
private ApplicationService applicationService;
@Inject
private 
/* (non-Javadoc)
* @see org.zkybase.web.controller.AbstractCrudController#getService()
*/
@Override
pu
/* (non-Javadoc)
* @see org.zkybase.web.controller.AbstractCrudController#getAllowedFields()
*/
@Override
protected String[] getAllowedFiel
/* (non-Javadoc)
* @see org.zkybase.web.controller.AbstractEntityNoFormController#doGetDetails(java.lang.Long, org.springframework.ui.Model)
*/
@Override
protected Application doGetDetails(Long id, Model model) {
Application app = getService().findOne(id);
List<Farm> farms = CollectionsUtil.asSortedList(farmService.findByApplication(app));
model.addAttr
```
<Overlap Ratio: 0.8123249299719888>

---

--- 348 --
Question ID: ee7e106a17a6d3c50b58c0f6591bc9a924d1b4d4
Original Code:
```
@Entity
@EntityListeners(AuditingEntityListener.class)
@TypeDef(name = "pgsql_enum", typeClass = PostgreSQLEnumType.class)
@Table(name = "test_item", schema = "public")
public class TestItem implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "item_id")
    private Long itemId;

    @Column(name = "uuid")
    private String uuid;

    @Column(name = "name", length = 256)
    private String name;

    @Column(name = "code_ref")
    private String codeRef;

    @Enumerated(EnumType.STRING)
    @Type(type = "pqsql_enum")
    @Column(name = "type", nullable = false)
    private TestItemTypeEnum type;

    @Column(name = "start_time", nullable = false)
    private LocalDateTime startTime;

    @Column(name = "description")
    private String description;

    @Column(name = "launch_id", nullable = false)
    private Long launchId;

    @LastModifiedDate
    @Column(name = "last_modified", nullable = false)
    private LocalDateTime lastModified;

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "parameter", joinColumns = @JoinColumn(name = "item_id"))
    @Fetch(FetchMode.SUBSELECT)
    private Set<Parameter> parameters = Sets.newHashSet();

    @Column(name = "unique_id", nullable = false, length = 256)
    private String uniqueId;

    @Column(name = "test_case_id")
    private String testCaseId;

    @Column(name = "test_case_hash")
    private Integer testCaseHash;

    @OneToMany(mappedBy = "testItem", cascade = CascadeType.ALL, fetch = FetchType.EAGER, orphanRemoval = true)
    @Fetch(FetchMode.SUBSELECT)
    private Set<ItemAttribute> attributes = Sets.newHashSet();

    @OneToMany(mappedBy = "testItem", fetch = FetchType.LAZY, orphanRemoval = true)
    private Set<Log> logs = Sets.newHashSet();

    @Column(name = "path", nullable = false, columnDefinition = "ltree")
    @Type(type = "com.epam.ta.reportportal.entity.LTreeType")
    private String path;

    @Column(name = "retry_of", precision = 64)
    private Long retryOf;

    @Column(name = "parent_id")
    private Long parentId;

    @OneToOne(cascade = CascadeType.ALL, mappedBy = "testItem")
    private TestItemResults itemResults;

    @OneToMany(mappedBy = "testItem", cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE }, fetch = FetchType.LAZY)
    @OrderBy(value = "pattern_id")
    @Fetch(FetchMode.SUBSELECT)
    private Set<PatternTemplateTestItem> patternTemplateTestItems = Sets.newLinkedHashSet();

    @Column(name = "has_children")
    private boolean hasChildren;

    @Column(name = "has_retries")
    private boolean hasRetries;

    @Column(name = "has_stats")
    private boolean hasStats;

    public TestItem() {
    }

    public TestItem(Long id) {
        this.itemId = id;
    }

    public TestItem(Long itemId, String name, TestItemTypeEnum type, LocalDateTime startTime, String description, LocalDateTime lastModified, String uniqueId, boolean hasChildren, boolean hasRetries, boolean hasStats) {
        this.itemId = itemId;
        this.name = name;
        this.type = type;
        this.startTime = startTime;
        this.description = description;
        this.lastModified = lastModified;
        this.uniqueId = uniqueId;
        this.hasChildren = hasChildren;
        this.hasRetries = hasRetries;
    }

    public Set<ItemAttribute> getAttributes() {
        return attributes;
    }

    public void setAttributes(Set<ItemAttribute> tags) {
        this.attributes.clear();
        this.attributes.addAll(tags);
    }

    public Set<Log> getLogs() {
        return logs;
    }

    public void setLogs(Set<Log> logs) {
        this.logs.clear();
        this.logs.addAll(logs);
    }

    public void addLog(Log log) {
        logs.add(log);
    }

    public Long getItemId() {
        return itemId;
    }

    public void setItemId(Long itemId) {
        this.itemId = itemId;
    }

    public String getUuid() {
        return uuid;
    }

    public void setUuid(String uuid) {
        this.uuid = uuid;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCodeRef() {
        return codeRef;
    }

    public void setCodeRef(String codeRef) {
        this.codeRef = codeRef;
    }

    public TestItemTypeEnum getType() {
        return type;
    }

    public void setType(TestItemTypeEnum type) {
        this.type = type;
    }

    public LocalDateTime getStartTime() {
        return startTime;
    }

    public void setStartTime(LocalDateTime startTime) {
        this.startTime = startTime;
    }

    public LocalDateTime getLastModified() {
        return lastModified;
    }

    public void setLastModified(LocalDateTime lastModified) {
        this.lastModified = lastModified;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Set<Parameter> getParameters() {
        return parameters;
    }

    public void setParameters(Set<Parameter> parameters) {
        this.parameters = parameters;
    }

    public String getUniqueId() {
        return uniqueId;
    }

    public void setUniqueId(String uniqueId) {
        this.uniqueId = uniqueId;
    }

    public String getTestCaseId() {
        return testCaseId;
    }

    public void setTestCaseId(String testCaseId) {
        this.testCaseId = testCaseId;
    }

    public Integer getTestCaseHash() {
        return testCaseHash;
    }

    public void setTestCaseHash(Integer testCaseHash) {
        this.testCaseHash = testCaseHash;
    }

    public Long getLaunchId() {
        return launchId;
    }

    public void setLaunchId(Long launchId) {
        this.launchId = launchId;
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public Long getRetryOf() {
        return retryOf;
    }

    public void setRetryOf(Long retryOf) {
        this.retryOf = retryOf;
    }

    public Long getParentId() {
        return parentId;
    }

    public void setParentId(Long parentId) {
        this.parentId = parentId;
    }

    public TestItemResults getItemResults() {
        return itemResults;
    }

    public void setItemResults(TestItemResults itemResults) {
        this.itemResults = itemResults;
    }

    public boolean isHasChildren() {
        return hasChildren;
    }

    public void setHasChildren(boolean hasChildren) {
        this.hasChildren = hasChildren;
    }

    public Set<PatternTemplateTestItem> getPatternTemplateTestItems() {
        return patternTemplateTestItems;
    }

    public void setPatternTemplateTestItems(Set<PatternTemplateTestItem> patternTemplateTestItems) {
        this.patternTemplateTestItems = patternTemplateTestItems;
    }

    public boolean isHasRetries() {
        return hasRetries;
    }

    public void setHasRetries(boolean hasRetries) {
        this.hasRetries = hasRetries;
    }

    public boolean isHasStats() {
        return hasStats;
    }

    public void setHasStats(boolean hasStats) {
        this.hasStats = hasStats;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        TestItem testItem = (TestItem) o;
        return Objects.equals(itemId, testItem.itemId) && Objects.equals(name, testItem.name) && Objects.equals(codeRef, testItem.codeRef) && type == testItem.type && Objects.equals(uniqueId, testItem.uniqueId) && Objects.equals(testCaseId, testItem.testCaseId) && Objects.equals(testCaseHash, testItem.testCaseHash) && Objects.equals(path, testItem.path) && Objects.equals(retryOf, testItem.retryOf);
    }

    @Override
    public int hashCode() {
        return Objects.hash(itemId, name, codeRef, type, uniqueId, testCaseId, testCaseHash, path, retryOf);
    }
}

```


Overlapping Code:
```
@Entity
@EntityListeners(AuditingEntityListener.class)
@TypeDef(name = "pgsql_enum", typeClass = PostgreSQLEnumType.class)
@Table(name = "test_item", schema = "public")
public class TestItem implements Serializable {
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "item_id")
private Long itemId;
@Column(name = "uuid")
private String uuid;
@Column(name = "name", length = 256)
private String name;
@Column(name = "code_ref")
private String codeRef;
@Enumerated(EnumType.STRING)
@Type(type = "pqsql_enum")
@Column(name = "type", nullable = false)
private TestItemTypeEnum type;
@Column(name = "start_time", nullable = false)
private LocalDateTime startTime;
@Column(name = "description")
private String description;
@Column(name = "launch_id", nullable = false)
private Long launchId;
@LastModifiedDate
@Column(name = "last_modified", nullable = false)
private LocalDateTime lastModified;
@ElementCollection(fetch = FetchType.EAGER)
@CollectionTable(name = "parameter", joinColumns = @JoinColumn(name = "item_id"))
@Fetch(FetchMode.SUBSELECT)
private Set<Parameter> parameters = Sets.newHashSet();
@Column(name = "unique_id", nullable = false, length = 256)
private String uniqueId;
@Column(name = "test_case_id")
private String testCaseId;
@Column(name = "test_case_hash")
private Integer testCaseHash;
@OneToMany(mappedBy = "testItem", cascade = CascadeType.ALL, fetch = FetchType.EAGER, orphanRemoval = true)
@Fetch(FetchMode.SUBSELECT)
private Set<ItemAttribute> attributes = Sets.newHashSet();
@OneToMany(mappedBy = "testItem", fetch = FetchType.LAZY, orphanRemoval = true)
private Set<Log> logs = Sets.newHashSet();
@Column(name = "path", nullable = false, columnDefinition = "ltree")
@Type(type = "com.epam.ta.reportportal.entity.LTreeType")
private String path;
@Column(name = "retry_of", precision = 64)
private Long retryOf;
@Column(name = "parent_id")
private Long parentId;
@OneToOne(cascade = CascadeType.ALL, mappedBy = "testItem")
private TestItemResults itemResults;
@OneToMany(mappedBy = "testItem", cascade = { CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE }, fetch = FetchType.LAZY)
@OrderBy(value = "pattern_id")
@Fetch(FetchMode.SUBSELECT)
private Set<PatternTemplateTestItem> patternTemplateTestItems = Sets.newLink
```
<Overlap Ratio: 0.9991208791208791>

---

--- 349 --
Question ID: 05c8c395b91c6ea8a0b51f65d49c4ecd0e41e210
Original Code:
```
@Internal
final class CurrentRowEvaluationSheet implements EvaluationSheet {

    private final Sheet _xs;

    private final Row _row;

    CurrentRowEvaluationSheet(Sheet sheet, Row row) {
        _xs = sheet;
        _row = row;
    }

    Sheet getSheet() {
        return _xs;
    }

    /* (non-Javadoc)
   * @see org.apache.poi.ss.formula.EvaluationSheet#getlastRowNum()
   * @since POI 4.0.0
   */
    @Override
    public int getLastRowNum() {
        return _xs.getLastRowNum();
    }

    /* (non-Javadoc)
   * @see org.apache.poi.ss.formula.EvaluationSheet#isRowHidden(int)
   * @since POI 4.1.0
   */
    @Override
    public boolean isRowHidden(int rowIndex) {
        if (_row == null)
            return false;
        return _row.getZeroHeight();
    }

    @Override
    public EvaluationCell getCell(int rowIndex, int columnIndex) {
        if (_row == null) {
            return null;
        }
        Cell cell = _row.getCell(columnIndex);
        if (cell == null) {
            return null;
        }
        return new OoxmlEvaluationCell(cell, this);
    }

    /* (non-JavaDoc), inherit JavaDoc from EvaluationSheet
   * @since POI 3.15 beta 3
   */
    @Override
    public void clearAllCachedResultValues() {
    }
}

```


Overlapping Code:
```
ntRowEvaluationSheet implements EvaluationSheet {
private final Sheet _xs;
private final Row _row;
CurrentRowEvaluationSheet(Sheet sheet, Row row) {
_xs = sheet;
_row = row;
}
Sheet getSheet() {
return _xs;
}
/* (non-Javadoc)
* @see org.apache.poi.ss.formula.EvaluationSheet#getlastRowNum()
* @since POI 4.0.0
*/
@Override
public int getLastRowNum() {
return _xs.getLastRowNum();
}
/* (non-Javadoc)
* @see org.apache.poi.ss.formula.EvaluationSheet#isRowHidden(int)
* @since POI 4.1.0
*/
@Override
public boolean isRowHidden(int rowIndex) {
if (_row =
}
@Override
public EvaluationCell getCell(int rowIndex, int columnIndex) {
if (_row == null) {
return null;
}
Cell cell = _row.getCell(columnIndex);
if (cell == null) {
return null;
}
return new OoxmlEvaluationCell(cell, this);
}
/* (non-JavaDoc), inherit JavaDoc from EvaluationSheet
* @since POI 3.15 beta 3
*/
@Override
public void clearAllCachedResultV
```
<Overlap Ratio: 0.9097291875626881>

---

--- 350 --
Question ID: d620dafeb60e8e45312cbc5cd34054b25cd5a7e5
Original Code:
```
public class Conta {

    private static int chave_conta;

    private String nome;

    private String descricao;

    private String senha;

    private Pessoa pessoa;

    private java.util.Date data;

    public Conta() {
        Conta.chave_conta++;
    }

    public Conta(String nome) {
        this.nome = nome;
        Conta.chave_conta++;
    }

    public static int CHAVE_CONTA() {
        return Conta.chave_conta;
    }

    public String getNome() {
        return this.nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getDescricao() {
        return this.descricao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }

    public String getSenha() {
        return this.senha;
    }

    public void setSenha(String senha) {
        this.senha = senha;
    }

    public Pessoa getPessoa() {
        return this.pessoa;
    }

    public void setPessoa(Pessoa pessoa) {
        this.pessoa = pessoa;
    }

    public java.util.Date getData() {
        return this.data;
    }

    public void setData(java.util.Date data) {
        GregorianCalendar gc = new GregorianCalendar(2021, 2, 31);
        if (data.equals(gc.getTime())) {
            this.data = null;
        }
        this.data = data;
    }
}

```


Overlapping Code:
```
;
private String nome;
private String descricao;
private String senha;
pra;
}
public String getNome() {
return this.nome;
}
public void setNome(String nome) {
this.nome = nome;
}
public String getDescricao() {
return this.descricao;
}
public void setDescricao(String descricao) {
this.descricao = descricao;
}
public String getSenha() {
return this.senha;
}
public void setSenha(String senha) {
this.senha = senha;
}
public Pessoa getPessoa() {
return this.pessoa;
}
public void setPessoa(Pessoa pessoa) {
this.pessoa = pessoa;
}
public Date getData() {
return this.data;
}
public void setData( data) {
GregorianCalendar gc = new GregorianCalendar(2021, 2, 31);
if (data.equals(gc.getTime())) {
```
<Overlap Ratio: 0.6757546251217137>

---

--- 351 --
Question ID: 495a13909672c96a7ef84b5eadc8a58384dc2c30
Original Code:
```
public class DiffAlgorithm {

    // XXX: Caution, enabling logging significantly impacts performance
    public static final int VERBOSE_LOGGING = 1;

    private DocumentModel baseModel, witnessModel;

    private SymbolTable symbolTable;

    private Correlator correlator;

    private DifferenceCollector collector;

    private DifferenceSet differenceSet;

    public DifferenceSet diffDocuments(DocumentModel baseModel, DocumentModel witnessModel) {
        if (baseModel.getTokenizerSettings().equals(witnessModel.getTokenizerSettings()) == false) {
            SimpleLogger.logError("Documents must be tokenized the same way to be comparable.");
            return null;
        }
        this.baseModel = baseModel;
        this.witnessModel = witnessModel;
        return performDiff();
    }

    //  perform the actual diff algorithm
    private DifferenceSet performDiff() {
        // create a common symbol table based on the two documents
        symbolTable = new SymbolTable(baseModel, witnessModel);
        // Correlate the contents of the two documents
        correlator = new Correlator(symbolTable);
        // Collect difference information from the correlation data
        collector = new DifferenceCollector(correlator);
        differenceSet = collector.getDifferenceSet();
        return differenceSet;
    }

    public void updateDifferenceSet(DifferenceSet differenceSet) {
        this.differenceSet = differenceSet;
    }

    public int getCorrespondingWitnessOffset(int baseOffset, boolean getEnd) {
        int baseIndex = convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd);
        FileInfo witnessFileInfo = correlator.getNewInfo();
        // converting to a token and back will do that.
        baseOffset = convertIndexToOffset(convertOffsetToIndex(baseOffset, Difference.BASE, !getEnd), Difference.BASE);
        Iterator i = differenceSet.getDifferenceList().iterator();
        while (i.hasNext()) try {
            Difference difference = (Difference) i.next();
            if ((difference.getOffset(Difference.BASE) <= baseOffset) && (baseOffset <= difference.getOffset(Difference.BASE) + difference.getLength(Difference.BASE))) {
                if (getEnd)
                    return difference.getOffset(Difference.WITNESS) + difference.getLength(Difference.WITNESS);
                else
                    return difference.getOffset(Difference.WITNESS);
            }
        } finally {
        }
        int witnessIndex = 1;
        while (witnessIndex < witnessFileInfo.getSymbolCount() + 1) try {
            if (witnessFileInfo.getCrossIndex(witnessIndex) == baseIndex) {
                if (getEnd)
                    return convertIndexToOffset(witnessIndex, Difference.WITNESS) + witnessFileInfo.getSymbol(witnessIndex + 1).getSymbolLength();
                else
                    return convertIndexToOffset(witnessIndex, Difference.WITNESS);
            }
        } finally {
            witnessIndex++;
        }
        return -1;
    }

    public int getCorrespondingBaseOffset(int witnessOffset, boolean getEnd) {
        int witnessIndex = convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd);
        FileInfo baseFileInfo = correlator.getOldInfo();
        // converting to a token and back will do that.
        witnessOffset = convertIndexToOffset(convertOffsetToIndex(witnessOffset, Difference.WITNESS, !getEnd), Difference.WITNESS);
        Iterator i = differenceSet.getDifferenceList().iterator();
        while (i.hasNext()) try {
            Difference difference = (Difference) i.next();
            if ((difference.getOffset(Difference.WITNESS) <= witnessOffset) && (witnessOffset <= difference.getOffset(Difference.WITNESS) + difference.getLength(Difference.WITNESS))) {
                if (getEnd)
                    return difference.getOffset(Difference.BASE) + difference.getLength(Difference.BASE);
                else
                    return difference.getOffset(Difference.BASE);
            }
        } finally {
        }
        int baseIndex = 1;
        while (baseIndex < baseFileInfo.getSymbolCount() + 1) try {
            if (baseFileInfo.getCrossIndex(baseIndex) == witnessIndex) {
                if (getEnd)
                    return convertIndexToOffset(baseIndex, Difference.BASE) + baseFileInfo.getSymbol(baseIndex + 1).getSymbolLength();
                else
                    return convertIndexToOffset(baseIndex, Difference.BASE);
            }
        } finally {
            baseIndex++;
        }
        return -1;
    }

    private int convertIndexToOffset(int index, int type) {
        // For some reason, getDocumentOffset immediately subtracts one from the index, so we'll compensate by adding one first.
        if (type == Difference.BASE) {
            return symbolTable.getOldInfo().getDocumentOffset(index + 1);
        } else {
            return symbolTable.getNewInfo().getDocumentOffset(index + 1);
        }
    }

    // so in that case we need to know if we're interested in the token before that or the token after that.
    private int convertOffsetToIndex(int offset, int type, boolean useNext) {
        DocumentModel targetDocument = (type == Difference.BASE) ? baseModel : witnessModel;
        List<Token> tokenList = targetDocument.getTokenList();
        int i = 0;
        for (Token token : tokenList) {
            int tokenEnd = token.getOffset() + token.getToken().length();
            // Therefore, we'll trick it out by subtracting 1 so the test will appear as < instead of <=
            int fudge = (useNext ? 0 : 1);
            if ((token.getOffset() <= offset - fudge) && (offset <= tokenEnd))
                // Exact match
                return i;
            if (// We've passed the spot, so we must be in the crack between tokens
            token.getOffset() >= offset) {
                if (useNext) {
                    if (i == tokenList.size() - 1)
                        return i;
                    else
                        return i;
                } else
                    return (i - 1 > 0) ? i - 1 : 0;
            }
            i++;
        }
        return (tokenList.size() > 0) ? tokenList.size() - 1 : 0;
    }
}

```


Overlapping Code:
```
ion, enabling logging significantly impacts performance
public static final int VERBOSE_LOGGING = 1;rivate SymbolTable symbolTable;
private Correlator correlator;
private DifferenceCollector collectorTokenizerSettings().equals(witnessModel.getTokeniz"Documents must be tokenized the same way to be comparable.");
return null;
}
this.baseModel = baseModel;
this.witnessModel = witnessModel;
return performDiff();
}
// perform the actual diff algorithma common symbol table based on the two documents
sl);
// Correlate the contents of the two documents
correlator = new Correlator(symbolTable);
// Collect difference information from the correlation data
collector = new DifferenceCollector(correlator)ceSet = collector.getDifferenceSet();
return diffeseIndex = convertOffsetToIndex(baseOffset, Differed back will do that.
baseOffset = convertIndexToOffset(convertOffsetToIndex(baseOffset, Difference.Bi.next();
if ((difference.getOffset(Difference.BASE) <= baseOffset) && (baseOffset <= difference.getOffset(Difference.BASE) + difference.getLength(Difference.BAffset(Difference.WITNESS) + difference.getLength(Difference.WITNESS);
else
return difference.getOffs
```
<Overlap Ratio: 0.5595754944524843>

---

--- 352 --
Question ID: 86b5e913c45589f56c85f9e8a132f6c76a82df60
Original Code:
```
public final class ConverterStore {

    private static final ConditionalConverter<?, ?>[] DEFAULT_CONVERTERS = new ConditionalConverter<?, ?>[] { new ArrayConverter(), new CollectionConverter(), new MapConverter(), new AssignableConverter(), new StringConverter(), new EnumConverter(), new NumberConverter(), new BooleanConverter(), new CharacterConverter(), new DateConverter(), new CalendarConverter() };

    private final List<ConditionalConverter<?, ?>> converters;

    public ConverterStore() {
        this(new CopyOnWriteArrayList<ConditionalConverter<?, ?>>(DEFAULT_CONVERTERS));
    }

    ConverterStore(List<ConditionalConverter<?, ?>> converters) {
        this.converters = converters;
    }

    /**
     * Returns the first converter that supports converting from {@code sourceType} to
     * {@code destinationType}. It will select converter that was full match first.
     * Then it will select {@code MatchResult.PARTIAL} if there is no full match converter
     * exists.
     */
    @SuppressWarnings("unchecked")
    public <S, D> ConditionalConverter<S, D> getFirstSupported(Class<?> sourceType, Class<?> destinationType) {
        ConditionalConverter<S, D> firstPartialMatchConverter = null;
        for (ConditionalConverter<?, ?> converter : converters) {
            MatchResult matchResult = converter.match(sourceType, destinationType);
            if (matchResult == MatchResult.FULL)
                return (ConditionalConverter<S, D>) converter;
            if (firstPartialMatchConverter == null && matchResult == MatchResult.PARTIAL)
                firstPartialMatchConverter = (ConditionalConverter<S, D>) converter;
        }
        return firstPartialMatchConverter;
    }

    public List<ConditionalConverter<?, ?>> getConverters() {
        return converters;
    }

    public ConverterStore removeConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {
        ConditionalConverter<?, ?> matchConverter = getConverterByType(converterClass);
        if (matchConverter != null)
            converters.remove(matchConverter);
        return this;
    }

    public boolean hasConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {
        return getConverterByType(converterClass) != null;
    }

    public ConverterStore addConverter(ConditionalConverter<?, ?> converter) {
        converters.add(converter);
        return this;
    }

    private ConditionalConverter<?, ?> getConverterByType(Class<? extends ConditionalConverter<?, ?>> converterClass) {
        for (ConditionalConverter<?, ?> converter : converters) {
            if (converter.getClass().equals(converterClass))
                return converter;
        }
        return null;
    }
}

```


Overlapping Code:
```
ConverterStore {
private static final ConditionalConverter<?, ?>[] DEFAULT_CONVERTERS = new ConditiognableConverter(), new StringConverter(), new Enumverter(), new CharacterConverter(), new DateConver };
private final List<ConditionalConverter<?, ?>> converters;
public ConverterStore() {
this(new CopyOnWriteArrayList<ConditionalConverter<?, ?>>(DEFAULT_CONVERTERS));
}
ConverterStore(List<ConditionalConverter<?, ?>> converters) {
this.converters = converters;
}
/**
* Returns the first converter that supports converting from {@code sourceType} to
* {@code destinationType}. It will select converter that was full match first.
* Then it will select {@code MatchResult.PARTIAL} if there is no full match converter
* exists.
*/
@SuppressWarnings("unchecked")
public <S, D> ConditionalConverter<S, D> getFirstSupported(Class<?> sourceType, Class<?> destinationType) {
nditionalConverter<S, D> firstPartialMatchConverter = null;
for (ConditionalConverter<?, ?> converter : converters) {
MatchResult matchResult = converter.match(sourceType, destinationType);
if (matchResult == MatchResult.FULL)
return (ConditionalConverter<S, D>) converter;
if (firstPartialMatchConve)
firstPartialMatchConverter = (ConditionalConverter<S, D>) converter;
}
return firstPartialMatchConverter;
}
public List<ConditionalConverter<?, ?>> getConverters() {
return converters;
}
public ConverterStore removeConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {
ConditionalConverter<?, ?> matchConverter = getConverterByType(converterClass);
if (matchConverter != null)
converters.remove(matchConverter);
return this;
}
public boolean hasConverter(Class<? extends ConditionalConverter<?, ?>> converterClass) {
return getConverterByType(converterClass) != null;
}
public ConverterStore addConverter(ConditionalConverter<?, ?> converter) {
converters.add(converter);
return t
```
<Overlap Ratio: 0.8684332868433287>

---

--- 353 --
Question ID: 4d7f0a0119dc23fe4bd356b1832ed7063663cf23
Original Code:
```
public class D11_ValidAnagram {

    public static void main(String[] args) {
        ValidAnagramSolution vas = new ValidAnagramSolution();
        ValidAnagramSolution_1 vas_1 = new ValidAnagramSolution_1();
        System.out.println(vas.isAnagram("azamat", "tamaza"));
        System.out.println(vas_1.isAnagram("azamat", "tamaza"));
    }
}

```


Overlapping Code:
```
lidAnagram {
public static void main(String[] args) {
ValidAnagramSolution vas = new ValidAnagramSolution();
ValidAnagramSolution_1 vas_1 = new ValidAnagramSolution_1();
System.out.println(vas.isAnagram("azamat", "tamaza"));
System.out.println(vas_1.isAnagram("azamat", "t
```
<Overlap Ratio: 0.8947368421052632>

---

--- 354 --
Question ID: 4a17c9b5e055a50b149cdea259f2165215f2fe4d
Original Code:
```
@ApplicationScoped
public class RtppmFeed implements Consumer<String> {

    private static final Logger LOG = Logger.getLogger(RtppmFeed.class.getName());

    private static final String ROUTING_KEY = "nr.rtppm";

    @Inject
    private NetworkRailConnection networkRailFeed;

    @Inject
    private Rabbit rabbit;

    @Inject
    private RtppmLogger rtppmLogger;

    @Inject
    private RtppmArchiver rtppmArchiver;

    private Consumer<String> publisher;

    private Consumer<String> monitor;

    @PostConstruct
    public void start() {
        publisher = rabbit.publishString(ROUTING_KEY);
        monitor = RateMonitor.log(LOG, ROUTING_KEY);
        networkRailFeed.registerTopicConsumer("RTPPM_ALL", JMS.toText, this);
        rtppmArchiver.start();
        rtppmLogger.start();
    }

    @Override
    public void accept(String t) {
        if (t != null) {
            monitor.accept(t);
            publisher.accept(t);
        }
    }
}

```


Overlapping Code:
```
mplements Consumer<String> {
private static final Logger LOG = Logger.getLogger(R
private NetworkRailConnection networkRailFeed;
@Inject
private Rabbit rabbit;
@Inject
private RtppmLogger rtppmLogger;
@Inject
private RtppmArchiver rtppmArchiver;
private Consumer<String> publisher;
private Consumer<String> monitor;
@PostConstruct
public voiver.start();
rtppmLogger.start();
}
@Override
publ
```
<Overlap Ratio: 0.4918238993710692>

---

--- 355 --
Question ID: 691009fba7ccb50b017dca2a77a8604c2a1e3792
Original Code:
```
public class ExecSQL extends AbstractStep {

    @Override
    public void decode(StepMetaInterface stepMetaInterface, mxCell cell, List<DatabaseMeta> databases, IMetaStore metaStore) throws Exception {
        ExecSQLMeta execSQLMeta = (ExecSQLMeta) stepMetaInterface;
        String con = cell.getAttribute("connection");
        execSQLMeta.setDatabaseMeta(DatabaseMeta.findDatabase(databases, con));
        execSQLMeta.setSql(StringEscapeHelper.decode(cell.getAttribute("sql")));
        execSQLMeta.setExecutedEachInputRow("true".equalsIgnoreCase(cell.getAttribute("executedEachInputRow")));
        execSQLMeta.setSingleStatement("true".equalsIgnoreCase(cell.getAttribute("singleStatement")));
        execSQLMeta.setVariableReplacementActive("true".equalsIgnoreCase(cell.getAttribute("replaceVariables")));
        execSQLMeta.setParams("true".equalsIgnoreCase(cell.getAttribute("setParams")));
        execSQLMeta.setQuoteString("true".equalsIgnoreCase(cell.getAttribute("quoteString")));
        JSONArray jsonArray = JSONArray.fromObject(cell.getAttribute("arguments"));
        execSQLMeta.allocate(jsonArray.size());
        int i = 0;
        while (i < jsonArray.size()) try {
            JSONObject jsonObject = jsonArray.getJSONObject(i);
            execSQLMeta.getArguments()[i] = jsonObject.optString("name");
        } finally {
            i++;
        }
    }

    @Override
    public Element encode(StepMetaInterface stepMetaInterface) throws Exception {
        ExecSQLMeta execSQLMeta = (ExecSQLMeta) stepMetaInterface;
        Document doc = mxUtils.createDocument();
        Element e = doc.createElement("Step");
        e.setAttribute("connection", execSQLMeta.getDatabaseMeta() == null ? "" : execSQLMeta.getDatabaseMeta().getName());
        e.setAttribute("sql", StringEscapeHelper.encode(execSQLMeta.getSql()));
        e.setAttribute("executedEachInputRow", Boolean.toString(execSQLMeta.isExecutedEachInputRow()));
        e.setAttribute("singleStatement", Boolean.toString(execSQLMeta.isSingleStatement()));
        e.setAttribute("replaceVariables", Boolean.toString(execSQLMeta.isReplaceVariables()));
        e.setAttribute("setParams", Boolean.toString(execSQLMeta.isParams()));
        e.setAttribute("quoteString", Boolean.toString(execSQLMeta.isQuoteString()));
        JSONArray arguments = new JSONArray();
        int i = 0;
        while (i < execSQLMeta.getArguments().length) try {
            String name = execSQLMeta.getArguments()[i];
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("name", name);
            arguments.add(jsonObject);
        } finally {
            i++;
        }
        e.setAttribute("arguments", arguments.toString());
        return e;
    }
}

```


Overlapping Code:
```
blic class ExecSQL extends AbstractStep {
@Override
public void decode(StepMetaInterface stepMetaInterface, mxCell cell, List<DatabaseMeta> databases, IMetaStore metaStore) throws Exception {
ExecSQLMeta execSQLMeta = (ExecSQLMeta) stepMetaInterface;xecSQLMeta.setDatabaseMeta(DatabaseMeta.findDatabase(databases, cecSQLMeta.setSql(StringEscapeHelper.decode(cell.geecSQLMeta.setExecutedEachInputRow("true".equalsIgn)));
execSQLMeta.setSingleStatement("true".equalsI;
execSQLMeta.setVariableReplacementActive("true".eta.setQuoteString("true".equalsIgnoreCase(cell.geJSONArray jsonArray = JSONArray.fromObject(cell.getAttributery {
JSONObject jsonObject = jsonArray.getJSONObject(i);
execSQLMeta.getArguments()[i] = jsonObject.optS
@Override
public Element encode(StepMetaInterface stepMetaInterface) throws Exception {
ExecSQLMeta execSQLMeta = (ExecSQLMeta) stepMetaInterface;
Document doc = mxUtils.createDocument();
Element e = doc.createElement("Step");
e.setAttribute("connection", execSQLMeta.getDatabaseMeta() == null ? "" : execSQLMeta.getDatabaseMeta().getName());
e.setAttribute("sql", StringEscapeHelper.encode(execSQLMeta.getSql()));
e.setAttribute("executedEachInputRow", Boolean.toString(execSQLMeta.isExecutedEachInputRow()));
e.setAttribute("singleStatement", Boolean.toString(execSQLMeta.isSingleStatement()));
e.setAttribute("replaceVariables", Boolean.toString(execSQLMeta.isReplaceVariables()));
e.setAttribute("setParams", Boolean.toString(execSQLMeta.isParams()));
e.setAttribute("quoteString", Boolean.toString(execSQLMeta.isQuoteStrin
```
<Overlap Ratio: 0.7096627164995443>

---

--- 356 --
Question ID: 312f282becf9715a6ec29fbea270e619ab8bcb3b
Original Code:
```
@SuppressWarnings({ "SpringJavaAutowiringInspection" })
public abstract class AbstractToolHandlerMethodProcessor<T, U> extends AbstractToolOrderedBean implements ToolHandlerMethodProcessor<T, U> {

    protected AbstractApplicationContext appContext;

    protected Class<? extends T> targetArgsClass;

    protected Class<? extends U> targetReturnTypeClass;

    protected boolean resolveArgs;

    protected boolean handleReturnValue;

    private final static Logger LOGGER = LoggerFactory.getLogger(AbstractToolHandlerMethodProcessor.class);

    protected AbstractToolHandlerMethodProcessor(Class<? extends T> targetArgsClass, Class<? extends U> targetReturnTypeClass, boolean resolveArgs, boolean handleReturnValue) {
        this.targetArgsClass = targetArgsClass;
        this.targetReturnTypeClass = targetReturnTypeClass;
        this.resolveArgs = resolveArgs;
        this.handleReturnValue = handleReturnValue;
    }

    @Override
    public boolean supportsReturnType(MethodParameter returnType) {
        return this.handleReturnValue && ToolClassUtils.isAssignable(returnType.getParameterType(), this.targetReturnTypeClass);
    }

    @Override
    public boolean supportsParameter(MethodParameter methodParam) {
        return this.resolveArgs && ToolClassUtils.isAssignable(methodParam.getParameterType(), this.targetArgsClass);
    }

    @Override
    public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
        this.handleReturnValueInternal(this.targetReturnTypeClass.cast(returnValue), returnType, mavContainer, webRequest);
        LOGGER.trace(String.format("Processed (class=%s) handler method (class=%s, name=%s) return value (class=%s, targetClass=%s).", ToolClassUtils.getName(this), ToolClassUtils.getName(returnType.getContainingClass()), returnType.getMethod().getName(), ToolClassUtils.getName(returnValue), ToolClassUtils.getName(this.targetReturnTypeClass)));
    }

    @Nullable
    @Override
    public Object resolveArgument(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        Object argObj = this.resolveArgumentInternal(methodParam, mavContainer, webRequest, binderFactory);
        LOGGER.trace(String.format("Processed (class=%s) handler method (class=%s, name=%s) parameter (class=%s, targetClass=%s).", ToolClassUtils.getName(this), ToolClassUtils.getName(methodParam.getContainingClass()), methodParam.getMethod().getName(), ToolClassUtils.getName(argObj), ToolClassUtils.getName(this.targetArgsClass)));
        return argObj;
    }

    protected void handleReturnValueInternal(@Nullable U returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
    }

    @Nullable
    protected Object resolveArgumentInternal(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        return null;
    }

    @Override
    public void setApplicationContext(ApplicationContext appContext) throws BeansException {
        this.appContext = (AbstractApplicationContext) appContext;
    }
}

```


Overlapping Code:
```
@SuppressWarnings({ "SpringJavaAutowiringInspection" })
public abstract class AbstractToolHandlerMethodProcessor<T, U> extends AbstractToolOrderedBean implements ToolHandlerMethodProcessor<T, U> {
protected AbstractApplicationContext appContext;
protected Class<? extends T> targetArgsClass;
protected Class<? extends U> targetReturnTypeClass;
protected boolean resolveArgs;
protected boolean handleReturnValue;
private final static Logger LOGGER = LoggerFactory.getLogger(AbstractToolHandlerMethodProcessor.class);
protected AbstractToolHandlerMethodProcessor(Class<? extends T> targetArgsClass, Class<? extends U> targetReturnTypeClass, boolean resolveArgss = targetArgsClass;
this.targetReturnTypeClass = targetReturnTypeClass;
this.resolveArgs = resolveArgs;
this.handleReturnValue = handleReturnValue;
}
@Override
public boolean supportsReturnType(MethodParameter returnType) {
return this.handleReturnValue && ToolClassUtils.isAssignable(returnType.getParameterType(), this.targetReturnTypeClass);
}
@Override
public boolean supportsParameter(MethodParameter methodParam) {
return this.resolveArgs && ToolClassUtils.isAssignable(methodParam.getParameterType(), this.targetArgsClass);
}
@Override
public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
this.handleReturnValueInternal(this.targetReturnTypeClass.cast(returnValue), returnType, mavContainer, webRequest);
LOGGER.trace(String.format("Processed (class=%s) handler method (class=%s, name=%s) return value (class=%s, targetClaoolClassUtils.getName(this), ToolClassUtils.getName(returnType.getContainingClass()), retame(returnValue), ToolClassUtils.getName(this.targetReturnTypeClass)));
}
@Nullable
@Override
public Object resolveArgument(MethodParameter methodParam, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
Object argObj = this.resolveArgumentInternal(methodParam, mavContainer, webRequest, binderFactory);
LOGGER.trace(String.format("Processed (class=%s) handler method (class=%s, na
```
<Overlap Ratio: 0.9218213058419243>

---

--- 357 --
Question ID: df86a5988dc4ae6c04ca10898aecb3dc91b26047
Original Code:
```
@Mixin(ContainerRepair.class)
public abstract class ContainerRepairMixin extends Container {

    @Shadow
    public int maximumCost;

    @Shadow
    @Final
    private IInventory inputSlots;

    @Shadow
    @Final
    private IInventory outputSlot;

    @Shadow
    public int materialCost;

    @Shadow
    private String repairedItemName;

    @Shadow
    @Final
    private EntityPlayer player;

    /**
     * @author Enaium
     */
    @Overwrite
    public void updateRepairOutput() {
        ItemStack itemstack = this.inputSlots.getStackInSlot(0);
        this.maximumCost = 1;
        int i = 0;
        int j = 0;
        int k = 0;
        if (itemstack.isEmpty()) {
            this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);
            this.maximumCost = 0;
        } else {
            ItemStack itemstack1 = itemstack.copy();
            ItemStack itemstack2 = this.inputSlots.getStackInSlot(1);
            Map<Enchantment, Integer> map = EnchantmentHelper.getEnchantments(itemstack1);
            j = j + itemstack.getRepairCost() + (itemstack2.isEmpty() ? 0 : itemstack2.getRepairCost());
            this.materialCost = 0;
            boolean flag = false;
            int k2;
            if (!itemstack2.isEmpty()) {
                if (!onAnvilChange(itemstack, itemstack2, this.outputSlot, this.repairedItemName, j)) {
                    return;
                }
                flag = itemstack2.getItem() == Items.ENCHANTED_BOOK && !ItemEnchantedBook.getEnchantments(itemstack2).isEmpty();
                int i1;
                int j1;
                if (itemstack1.isItemStackDamageable() && itemstack1.getItem().getIsRepairable(itemstack, itemstack2)) {
                    k2 = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);
                    if (k2 <= 0) {
                        this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);
                        this.maximumCost = 0;
                        return;
                    }
                    for (i1 = 0; k2 > 0 && i1 < itemstack2.getCount(); ++i1) {
                        j1 = itemstack1.getItemDamage() - k2;
                        itemstack1.setItemDamage(j1);
                        ++i;
                        k2 = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);
                    }
                    this.materialCost = i1;
                } else {
                    if (!flag && (itemstack1.getItem() != itemstack2.getItem() || !itemstack1.isItemStackDamageable())) {
                        this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);
                        this.maximumCost = 0;
                        return;
                    }
                    if (itemstack1.isItemStackDamageable() && !flag) {
                        k2 = itemstack.getMaxDamage() - itemstack.getItemDamage();
                        i1 = itemstack2.getMaxDamage() - itemstack2.getItemDamage();
                        j1 = i1 + itemstack1.getMaxDamage() * 12 / 100;
                        int k1 = k2 + j1;
                        int l1 = itemstack1.getMaxDamage() - k1;
                        if (l1 < 0) {
                            l1 = 0;
                        }
                        if (l1 < itemstack1.getItemDamage()) {
                            itemstack1.setItemDamage(l1);
                            i += 2;
                        }
                    }
                    Map<Enchantment, Integer> map1 = EnchantmentHelper.getEnchantments(itemstack2);
                    boolean flag2 = false;
                    boolean flag3 = false;
                    Iterator var23 = map1.keySet().iterator();
                    label177: for (; true; ) {
                        Enchantment enchantment1;
                        for (; ; ) try {
                            if (!var23.hasNext()) {
                                if (flag3 && !flag2) {
                                    this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);
                                    this.maximumCost = 0;
                                    return;
                                }
                                break label177;
                            }
                            enchantment1 = (Enchantment) var23.next();
                        } finally {
                            if (!enchantment1 == null) {
                                break;
                            }
                        }
                        int i2 = map.containsKey(enchantment1) ? (Integer) map.get(enchantment1) : 0;
                        int j2 = (Integer) map1.get(enchantment1);
                        j2 = i2 == j2 ? j2 + 1 : Math.max(j2, i2);
                        boolean flag1 = enchantment1.canApply(itemstack);
                        if (this.player.capabilities.isCreativeMode || itemstack.getItem() == Items.ENCHANTED_BOOK) {
                            flag1 = true;
                        }
                        Iterator var17 = map.keySet().iterator();
                        for (; var17.hasNext(); ) {
                            Enchantment enchantment = (Enchantment) var17.next();
                            if (enchantment != enchantment1 && !isCompatibleWith(enchantment, enchantment1)) {
                                flag1 = false;
                                ++i;
                            }
                        }
                        if (!flag1) {
                            flag3 = true;
                        } else {
                            flag2 = true;
                            if (j2 > enchantment1.getMaxLevel()) {
                                j2 = enchantment1.getMaxLevel();
                            }
                            map.put(enchantment1, j2);
                            int k3 = 0;
                            switch(enchantment1.getRarity()) {
                                case COMMON:
                                    k3 = 1;
                                    break;
                                case UNCOMMON:
                                    k3 = 2;
                                    break;
                                case RARE:
                                    k3 = 4;
                                    break;
                                case VERY_RARE:
                                    k3 = 8;
                            }
                            if (flag) {
                                k3 = Math.max(1, k3 / 2);
                            }
                            i += k3 * j2;
                            if (itemstack.getCount() > 1) {
                                i = 40;
                            }
                        }
                    }
                }
            }
            if (StringUtils.isBlank(this.repairedItemName)) {
                if (itemstack.hasDisplayName()) {
                    k = 1;
                    i += k;
                    itemstack1.clearCustomName();
                }
            } else if (!this.repairedItemName.equals(itemstack.getDisplayName())) {
                k = 1;
                i += k;
                itemstack1.setStackDisplayName(this.repairedItemName);
            }
            if (flag && !itemstack1.getItem().isBookEnchantable(itemstack1, itemstack2)) {
                itemstack1 = ItemStack.EMPTY;
            }
            this.maximumCost = j + i;
            if (i <= 0) {
                itemstack1 = ItemStack.EMPTY;
            }
            if (k == i && k > 0 && this.maximumCost >= 40) {
                this.maximumCost = 39;
            }
            if (this.maximumCost >= 40 && !this.player.capabilities.isCreativeMode) {
                this.maximumCost = 39;
            }
            if (!itemstack1.isEmpty()) {
                k2 = itemstack1.getRepairCost();
                if (!itemstack2.isEmpty() && k2 < itemstack2.getRepairCost()) {
                    k2 = itemstack2.getRepairCost();
                }
                if (k != i || k == 0) {
                    k2 = k2 * 2 + 1;
                }
                itemstack1.setRepairCost(k2);
                EnchantmentHelper.setEnchantments(map, itemstack1);
            }
            this.outputSlot.setInventorySlotContents(0, itemstack1);
            this.detectAndSendChanges();
        }
    }

    private boolean onAnvilChange(ItemStack left, ItemStack right, IInventory outputSlot, String name, int baseCost) {
        AnvilUpdateEvent e = new AnvilUpdateEvent(left, right, name, baseCost);
        if (MinecraftForge.EVENT_BUS.post(e)) {
            return false;
        } else if (e.getOutput().isEmpty()) {
            return true;
        } else {
            outputSlot.setInventorySlotContents(0, e.getOutput());
            this.maximumCost = e.getCost();
            this.materialCost = e.getMaterialCost();
            return false;
        }
    }

    private boolean isCompatibleWith(Enchantment enchantment1, Enchantment enchantment2) {
        if ((enchantment1 instanceof EnchantmentArrowInfinite && enchantment2 instanceof EnchantmentMending) || (enchantment2 instanceof EnchantmentArrowInfinite && enchantment1 instanceof EnchantmentMending)) {
            return true;
        }
        return enchantment1.isCompatibleWith(enchantment2);
    }
}

```


Overlapping Code:
```
 abstract class ContainerRepairMixin extends Container {
@Shadow
public int maximumCost;
@Shadow
@Final
private IInventory inputSlots;
@Shadow
@Final
private IInventory outputSlot;
@Shadow
public int materialCost;
@Shadow
private String repairedItemName;
@Shadow
@Final
private EntityPlayer player;
/**
* @author Enaium
*/
@Overwrite
public void updateRepairOutput() {
ItemStack itemstack = this.inputSlots.getStackInSlot(0);
this.maximumCost = 1;
int i = 0;
int j = 0;
int k = 0;
if (itemstack.isEmpty()) {
this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);
this.maximumCost = 0;
} else {
ItemStack itemstack1 = itemstack.copy();
ItemStack itemstack2 = this.inputSlots.getStackInSlot(1);
Map<Enchantment, Integer> map = EnchantmentHelper.getEnchantments(itemstack1);
j = j + itemstack.getRepairCost() + (itemstack2.isEmpty() ? 0 : itemstack2.getRepairCost());
this.materialCost = 0;
boolean flag = false;
int k2;
if (!itemstack2.isEmpty()) {
if (!onAnvilChange(itemstack, itemstack2, this.outputSlot, this.repairedItemName, j)) {
return;
}
flag = itemstack2.getItem() == Items.ENCHANTED_BOOK && !ItemEnchantedBook.getEnchantments(itemstack2).isEmpty();
int i1;
int j1;
if (itemstack1.isItemStackDamageable() && itemstack1.getItem().getIsRepairable(itemstack, itemstack2)) {
k2 = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);
if (k2 <= 0) {
this.outputSlot.setInventorySlotContents(0, ItemStack.EMPTY);
this.maximumCost = 0;
return;
}
for (i1 = 0; k2 > 0 && i1 < itemstack2.getCount(); ++i1) {
j1 = itemstack1.getItemDamage() - k2;
itemstack1.setItemDamage(j1);
++i;
k2 = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);
}
this.materialCost = i1;
} else {
if (!flag && (itemstack1.getItem() != items
```
<Overlap Ratio: 0.9771460423634337>

---

--- 358 --
Question ID: 278ec218a2e650deb4500198e2ed05508b55549c
Original Code:
```
public class Builders {

    private Builders() {
    }

    private static Map<Class<? extends BasicEntity>, ? super EntityBuilder> map = new ConcurrentHashMap<>();

    static {
        map.put(User.class, new UserBuilder());
        map.put(Content.class, new ContentBuilder());
        map.put(Company.class, new CompanyBuilder());
    }

    @SuppressWarnings("unchecked")
    public static <K extends EntityBuilder> K of(Class<? extends BasicEntity> clazz) {
        K builder = (K) map.get(clazz);
        if (builder == null)
            throw new IllegalArgumentException("No builder for entity: " + clazz.getName());
        return (K) builder.newInstance();
    }

    @SuppressWarnings("unchecked")
    public static <T extends BasicEntity, K extends EntityBuilder> K of(T entity) {
        if (entity == null)
            throw new IllegalArgumentException("Entity should not be a null.");
        K builder = (K) map.get(entity.getClass());
        if (builder == null)
            throw new IllegalArgumentException("No builder for entity: " + entity.getClass().getName());
        return (K) builder.newInstance(entity);
    }
}

```


Overlapping Code:
```
ders {
private Builders() {
}
private static Map<Class<? extends BasicEntity>, ? super EntityBuilder> map = new ConcurrentHashMap<>();
static {
map.put(User.class, new UserBuilder());
map.put(Content.class, new ContentBuilder());
map.put(Company.class, new CompanyBuilder());
}
@SuppressWarnings("unchecked")
public static <K extends EntityBuilder> K of(Class<? extends BasicEntity> clazz) {
K buildeif (builder == null)
throw new IllegalArgumentException("No builder for entity: " + clazz.getName());
return (K) builder.newInstance();
}
@SuppressWarnings("unchecked")
public static <T extends BasicEntity, K extends EntityBuitity) {
if (entity == null)
throw new IllegalArgumentException("Entity should not be a null.");
K builder = (K) map.get(entity.getClass());
if (builder == null)
throw new IllegalArgumentException("No builder for entity: " + entity.getClass().getName());
return (K) builder.newInstance(
```
<Overlap Ratio: 0.9305413687436159>

---

--- 359 --
Question ID: 5243c099bbc4d6b225d8d4ed73dce3be7503010c
Original Code:
```
public class ScannerImplTest {

    private ClientContext context;

    @Before
    public void setup() {
        context = EasyMock.createMock(ClientContext.class);
    }

    @Test
    public void testValidReadaheadValues() {
        Scanner s = new ScannerImpl(context, "foo", Authorizations.EMPTY);
        s.setReadaheadThreshold(0);
        s.setReadaheadThreshold(10);
        s.setReadaheadThreshold(Long.MAX_VALUE);
        assertEquals(Long.MAX_VALUE, s.getReadaheadThreshold());
        s.close();
    }

    @Test(expected = IllegalArgumentException.class)
    public void testInValidReadaheadValues() {
        Scanner s = new ScannerImpl(context, "foo", Authorizations.EMPTY);
        s.setReadaheadThreshold(-1);
        s.close();
    }

    @Test
    public void testGetAuthorizations() {
        Authorizations expected = new Authorizations("a,b");
        Scanner s = new ScannerImpl(context, "foo", expected);
        assertEquals(expected, s.getAuthorizations());
        s.close();
    }

    @SuppressWarnings("resource")
    @Test(expected = IllegalArgumentException.class)
    public void testNullAuthorizationsFails() {
        new ScannerImpl(context, "foo", null);
    }
}

```


Overlapping Code:
```
te ClientContext context;
@Before
public void setup() {
context = EasyMock.createMock(ClientContext.class);
}
@Test
public void testValidReadaheadValues() {
Scanner s = new ScannerImpl(context, "foo", Authorizations.EMPTY);
s.setReadaheadThreshold(0);
s.setReadaheadThreshold(10);
s.setReadaheadThreshold(Long.MAX_VALUE);
assertEquals(Long.MAX_VALUE, s.getReadaheadThreshold());
s.close();
}
@Test(expected = IllegalArgumentException.class)
public void testInValidReadaheadValues() {
Scanner s = new ScannerImpl(context, "foo", Authorizations.EMPTY);
s.setReadaheadThreshold(-1);
s.close();
}
@Test
public void testGetAuthorizations() {
Authorizations expected = new Authorizations("a,b");
Scanner s = new ScannerImpl(context, "foo", expected);
assertEquals(expected, s.getAuthorizations());
s.close();
}
@SuppressWarnings("resource")
@Test(expected = IllegalArgumentException.class)
public void testNullAuthorizationsFails() {
new ScannerImpl(contex
```
<Overlap Ratio: 0.9443339960238568>

---

--- 360 --
Question ID: c100f09e24353bbe744b998aaca1669e27678b45
Original Code:
```
public class exercicio5 {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Ol?! Por favor informe qual o valor do seu sal?rio: R$ ");
        Double salario = scanner.nextDouble();
        final Double salarioMinimo = 788.0;
        Double quantidadeSalariosMinimos = salario / salarioMinimo;
        DecimalFormat df = new DecimalFormat("##.##");
        System.out.println("A quantidade de sal?rios m?nimos ?: " + df.format(quantidadeSalariosMinimos));
        scanner.close();
    }
}

```


Overlapping Code:
```
ercicio5 {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
System.out.print("e salario = scanner.nextDouble();
final Double salarioMinimo = 788.0;
Double quantidadeSalariosMinim;
DecimalFormat df = new DecimalFormat("##.##");
System.out.println("A quantidad
```
<Overlap Ratio: 0.5995893223819302>

---

--- 361 --
Question ID: 9687d6ab54c8b9d8f51dadc5b7c29d4734a45987
Original Code:
```
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "AddClientsToClassesRequest", propOrder = { "clientIDs", "classIDs", "test", "requirePayment", "waitlist", "sendEmail" })
public class AddClientsToClassesRequest extends MBRequest implements Serializable, Equals, HashCode, ToString {

    private final static long serialVersionUID = 1L;

    @XmlElement(name = "ClientIDs")
    protected ArrayOfString clientIDs;

    @XmlElement(name = "ClassIDs")
    protected ArrayOfInt classIDs;

    @XmlElement(name = "Test", required = true, type = Boolean.class, nillable = true)
    protected Boolean test;

    @XmlElement(name = "RequirePayment", required = true, type = Boolean.class, nillable = true)
    protected Boolean requirePayment;

    @XmlElement(name = "Waitlist", required = true, type = Boolean.class, nillable = true)
    protected Boolean waitlist;

    @XmlElement(name = "SendEmail", required = true, type = Boolean.class, nillable = true)
    protected Boolean sendEmail;

    /**
     * Gets the value of the clientIDs property.
     *
     * @return
     *     possible object is
     *     {@link ArrayOfString }
     */
    public ArrayOfString getClientIDs() {
        return clientIDs;
    }

    /**
     * Sets the value of the clientIDs property.
     *
     * @param value
     *     allowed object is
     *     {@link ArrayOfString }
     */
    public void setClientIDs(ArrayOfString value) {
        this.clientIDs = value;
    }

    /**
     * Gets the value of the classIDs property.
     *
     * @return
     *     possible object is
     *     {@link ArrayOfInt }
     */
    public ArrayOfInt getClassIDs() {
        return classIDs;
    }

    /**
     * Sets the value of the classIDs property.
     *
     * @param value
     *     allowed object is
     *     {@link ArrayOfInt }
     */
    public void setClassIDs(ArrayOfInt value) {
        this.classIDs = value;
    }

    /**
     * Gets the value of the test property.
     *
     * @return
     *     possible object is
     *     {@link Boolean }
     */
    public Boolean getTest() {
        return test;
    }

    /**
     * Sets the value of the test property.
     *
     * @param value
     *     allowed object is
     *     {@link Boolean }
     */
    public void setTest(Boolean value) {
        this.test = value;
    }

    /**
     * Gets the value of the requirePayment property.
     *
     * @return
     *     possible object is
     *     {@link Boolean }
     */
    public Boolean getRequirePayment() {
        return requirePayment;
    }

    /**
     * Sets the value of the requirePayment property.
     *
     * @param value
     *     allowed object is
     *     {@link Boolean }
     */
    public void setRequirePayment(Boolean value) {
        this.requirePayment = value;
    }

    /**
     * Gets the value of the waitlist property.
     *
     * @return
     *     possible object is
     *     {@link Boolean }
     */
    public Boolean getWaitlist() {
        return waitlist;
    }

    /**
     * Sets the value of the waitlist property.
     *
     * @param value
     *     allowed object is
     *     {@link Boolean }
     */
    public void setWaitlist(Boolean value) {
        this.waitlist = value;
    }

    /**
     * Gets the value of the sendEmail property.
     *
     * @return
     *     possible object is
     *     {@link Boolean }
     */
    public Boolean getSendEmail() {
        return sendEmail;
    }

    /**
     * Sets the value of the sendEmail property.
     *
     * @param value
     *     allowed object is
     *     {@link Boolean }
     */
    public void setSendEmail(Boolean value) {
        this.sendEmail = value;
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = super.hashCode(locator, strategy);
        {
            ArrayOfString theClientIDs;
            theClientIDs = this.getClientIDs();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "clientIDs", theClientIDs), currentHashCode, theClientIDs);
        }
        {
            ArrayOfInt theClassIDs;
            theClassIDs = this.getClassIDs();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "classIDs", theClassIDs), currentHashCode, theClassIDs);
        }
        {
            Boolean theTest;
            theTest = this.getTest();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "test", theTest), currentHashCode, theTest);
        }
        {
            Boolean theRequirePayment;
            theRequirePayment = this.getRequirePayment();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "requirePayment", theRequirePayment), currentHashCode, theRequirePayment);
        }
        {
            Boolean theWaitlist;
            theWaitlist = this.getWaitlist();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "waitlist", theWaitlist), currentHashCode, theWaitlist);
        }
        {
            Boolean theSendEmail;
            theSendEmail = this.getSendEmail();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "sendEmail", theSendEmail), currentHashCode, theSendEmail);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof AddClientsToClassesRequest)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        if (!super.equals(thisLocator, thatLocator, object, strategy)) {
            return false;
        }
        final AddClientsToClassesRequest that = ((AddClientsToClassesRequest) object);
        {
            ArrayOfString lhsClientIDs;
            lhsClientIDs = this.getClientIDs();
            ArrayOfString rhsClientIDs;
            rhsClientIDs = that.getClientIDs();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "clientIDs", lhsClientIDs), LocatorUtils.property(thatLocator, "clientIDs", rhsClientIDs), lhsClientIDs, rhsClientIDs)) {
                return false;
            }
        }
        {
            ArrayOfInt lhsClassIDs;
            lhsClassIDs = this.getClassIDs();
            ArrayOfInt rhsClassIDs;
            rhsClassIDs = that.getClassIDs();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "classIDs", lhsClassIDs), LocatorUtils.property(thatLocator, "classIDs", rhsClassIDs), lhsClassIDs, rhsClassIDs)) {
                return false;
            }
        }
        {
            Boolean lhsTest;
            lhsTest = this.getTest();
            Boolean rhsTest;
            rhsTest = that.getTest();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "test", lhsTest), LocatorUtils.property(thatLocator, "test", rhsTest), lhsTest, rhsTest)) {
                return false;
            }
        }
        {
            Boolean lhsRequirePayment;
            lhsRequirePayment = this.getRequirePayment();
            Boolean rhsRequirePayment;
            rhsRequirePayment = that.getRequirePayment();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "requirePayment", lhsRequirePayment), LocatorUtils.property(thatLocator, "requirePayment", rhsRequirePayment), lhsRequirePayment, rhsRequirePayment)) {
                return false;
            }
        }
        {
            Boolean lhsWaitlist;
            lhsWaitlist = this.getWaitlist();
            Boolean rhsWaitlist;
            rhsWaitlist = that.getWaitlist();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "waitlist", lhsWaitlist), LocatorUtils.property(thatLocator, "waitlist", rhsWaitlist), lhsWaitlist, rhsWaitlist)) {
                return false;
            }
        }
        {
            Boolean lhsSendEmail;
            lhsSendEmail = this.getSendEmail();
            Boolean rhsSendEmail;
            rhsSendEmail = that.getSendEmail();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "sendEmail", lhsSendEmail), LocatorUtils.property(thatLocator, "sendEmail", rhsSendEmail), lhsSendEmail, rhsSendEmail)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public String toString() {
        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        super.appendFields(locator, buffer, strategy);
        {
            ArrayOfString theClientIDs;
            theClientIDs = this.getClientIDs();
            strategy.appendField(locator, this, "clientIDs", buffer, theClientIDs);
        }
        {
            ArrayOfInt theClassIDs;
            theClassIDs = this.getClassIDs();
            strategy.appendField(locator, this, "classIDs", buffer, theClassIDs);
        }
        {
            Boolean theTest;
            theTest = this.getTest();
            strategy.appendField(locator, this, "test", buffer, theTest);
        }
        {
            Boolean theRequirePayment;
            theRequirePayment = this.getRequirePayment();
            strategy.appendField(locator, this, "requirePayment", buffer, theRequirePayment);
        }
        {
            Boolean theWaitlist;
            theWaitlist = this.getWaitlist();
            strategy.appendField(locator, this, "waitlist", buffer, theWaitlist);
        }
        {
            Boolean theSendEmail;
            theSendEmail = this.getSendEmail();
            strategy.appendField(locator, this, "sendEmail", buffer, theSendEmail);
        }
        return buffer;
    }
}

```


Overlapping Code:
```
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "AddClientsToClassesRequest", propOrderimplements Serializable, Equals, HashCode, ToString {
private final static long serialVersionUID = 1L;
@XmlElement(name = "ClientIDs")
protected ArrayOfString clientIDs;
@XmlElement(name = "ClassIDs")
protected ArrayOfInt classIDs;
@XmlElement(name = "Test", required = true, type = Boolean.class, nillable = true)
protected Boolean test;
@XmlElement(name = "RequirePayment", required = true, type = Boolean.class, nillable = true)
protected Boolean requirePayment;
@XmlElement(name = "Waitlist", required = true, type = Boolean.class, nillable = true)
protected Boolean waitlist;
@XmlElement(name = "SendEmail", required = true, type = Boolean.class, nillable = true)
protected Boolean sendEmail;
/**
* Gets thIDs property.
*
* @return
* possible object is
* {@link ArrayOfString }
*/
public ArrayOfString getClientIDs() {
return clientIDs;
}
/**
* Sets the value of the clientIDs property.
*
* @param value
* allowed object is
* {@link ArrayOfString }
*/
public void setClientIDs(ArrayOfString value) {
this.clientIDs = value;
}
/**
* Gets the value of the classIDs property.
*
* @return
* possible object is
* {@link ArrayOfInt }
*ic ArrayOfInt getClassIDs() {
return classIDs;
}
/**
* Sets the value of the classIDs property.
*
* @param value
* allowed object is
* {@link ArrayOfInt }
*tClassIDs(ArrayOfInt value) {
this.classIDs = value;
}
/**
* Gets the value of the test property.
*
* @return
* possible object is
* {@link Boolean }
*/
public Boolean getTest() {
return test;
}
/**
* Sets the value of the test property.
*
* @param value
* allowed object is
* {@link Boolean }
*/
public void setTest(Boolean value) {
this.test = value;
}
/**
* Gets the value of the requirePayment property.
*
* @return
* possible object is
* {@link Boolean }
*/
public Bo
```
<Overlap Ratio: 0.9097596861206474>

---

--- 362 --
Question ID: e622e9d58ce211f568a1cb75a3cb263859d636e1
Original Code:
```
@Name("pythonpaths")
@Summary("A utility command to manage system installed and manually registered python binaries.")
@Description("A utility command to manage system installed and manually registered python binaries. Python binaries " + "could be from either a regular python install, through a conda environment, javacpp cpython or a virtual " + "environment through 'venv' package. Each python installation has been assigned a particular id and a " + "specific type which ultimately identifies which python installation is going to be used with a particular " + "PythonStep configuration. You can also register a python binary if it's not listed through 'pythonpaths add' " + "subcommand. \n\n" + "Example usages:\n" + "--------------\n" + "- Lists all the installed and registered python binaries:\n" + "$ konduit pythonpaths list \n\n" + "- Lists python installs with their included packages:\n" + "$ konduit pythonpaths -wip \n\n" + "- Register a custom python installation:\n" + "$ konduit pythonpaths add -t=python -p=E:\\python37\\python.exe \n" + "--------------")
@Slf4j
public class PythonPathsCommand extends DefaultCommand {

    private SubCommand subCommand;

    private Object type;

    private String path;

    private boolean withInstalledPackages;

    @Argument(index = 0, argName = "sub_command", required = false)
    @DefaultValue("LIST")
    @Description("Sub command to be used with the pythonpaths command. Sub commands are: [add, list, config]. " + "Defaults to 'LIST'")
    public void setSubCommand(String subCommand) {
        try {
            this.subCommand = PythonPathsCommand.SubCommand.valueOf(subCommand.toUpperCase());
        } catch (Exception e) {
            System.out.format("Invalid sub command name: '%s'. Allowed values are: %s -> (case insensitive).", subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));
            System.exit(1);
        }
    }

    @Option(shortName = "t", longName = "type", argName = "type", required = true)
    @Description("Name of the python type. For the 'add' subcommand, accepted values are: [python, conda, venv]. " + "For the 'list' subcommand, accepted values are: [all, javacpp, python, conda, venv]. " + "For 'config' subcommand the accepted values are: [custom, javacpp, python, conda, venv]")
    public void setType(String type) {
        this.type = type;
    }

    @Option(shortName = "p", longName = "path", argName = "install_path")
    @Description("Absolute path of the python installation. For conda and venv types this refers to the absolute path " + "of the root installation folder.")
    public void setPath(String path) {
        this.path = path;
    }

    @Option(shortName = "wip", longName = "with-installed-packages", flag = true)
    @Description("Absolute path of the python installation. For conda and venv types this refers to the absolute path " + "of the root installation folder.")
    public void setPath(boolean withInstalledPackages) {
        this.withInstalledPackages = withInstalledPackages;
    }

    private enum SubCommand {

        ADD, LIST, CONFIG
    }

    public enum ListInstallationType {

        ALL, JAVACPP, PYTHON, CONDA, VENV
    }

    @Override
    public void run() {
        switch(this.subCommand) {
            case ADD:
                try {
                    this.type = PythonType.valueOf(((String) type).toUpperCase());
                } catch (Exception e) {
                    out.format("Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).", type, Arrays.toString(PythonType.values()));
                    System.exit(1);
                }
                break;
            case CONFIG:
                try {
                    this.type = PythonConfigType.valueOf(((String) type).toUpperCase());
                } catch (Exception e) {
                    out.format("Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).", type, Arrays.toString(PythonConfigType.values()));
                    System.exit(1);
                }
                break;
            case LIST:
                try {
                    this.type = PythonPathsCommand.ListInstallationType.valueOf(((String) type).toUpperCase());
                } catch (Exception e) {
                    out.format("Invalid type name: '%s'. Allowed values are: %s -> (case insensitive).", type, Arrays.toString(PythonPathsCommand.ListInstallationType.values()));
                    System.exit(1);
                }
                break;
            default:
                out.format("Invalid sub command name: '%s'. Allowed values are: %s -> (case insensitive).", subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));
        }
        switch(this.subCommand) {
            case ADD:
                registerInstallation((PythonType) type, path);
                break;
            case LIST:
                listInstallations((ListInstallationType) type, withInstalledPackages);
                break;
            case CONFIG:
                createConfig((PythonConfigType) type);
                break;
            default:
                log.error("Invalid sub command name: {}. Allowed values are: {} -> (case insensitive).", subCommand, Arrays.toString(PythonPathsCommand.SubCommand.values()));
        }
    }

    private void createConfig(PythonConfigType pythonConfigType) {
        throw new UnsupportedOperationException("This will be implemented in a continuation PR");
    }

    public static void listInstallations(ListInstallationType type, boolean withInstalledPackages) {
        switch(type) {
            case ALL:
                listJavacppInstallations(withInstalledPackages);
                listPythonInstallations(withInstalledPackages);
                listCondaInstallations(withInstalledPackages);
                listVenvInstallations(withInstalledPackages);
                break;
            case JAVACPP:
                listJavacppInstallations(withInstalledPackages);
                break;
            case PYTHON:
                listPythonInstallations(withInstalledPackages);
                break;
            case CONDA:
                listCondaInstallations(withInstalledPackages);
                break;
            case VENV:
                listVenvInstallations(withInstalledPackages);
                break;
            default:
                System.out.format("Invalid installation type name: '%s'. Allowed values are: %s -> (case insensitive).", type.name(), Arrays.toString(PythonPathsCommand.ListInstallationType.values()));
        }
    }

    private static void listJavacppInstallations(boolean withInstalledPackages) {
        JavaCppDetails javaCppDetails = getJavaCppDetails();
        System.out.println("\n----------------------------JAVACPP INSTALLS---------------------------");
        System.out.print(formatPythonInstallation(new PythonDetails(javaCppDetails.id(), javaCppDetails.path(), javaCppDetails.version()), false));
        if (!withInstalledPackages) {
            System.out.println("\n-----------------------------------------------------------------------");
        } else {
            System.out.println("\t--------Installed Modules--------");
            printJavaCppInstalledModules();
            System.out.println("\t---------------------------------");
            System.out.println("-----------------------------------------------------------------------");
        }
    }

    public static JavaCppDetails getJavaCppDetails() {
        try {
            Py_AddPath(cachePackages());
            Pointer program = Py_DecodeLocale(PythonPathsCommand.class.getSimpleName(), null);
            if (program == null) {
                System.out.println("Fatal error: cannot get class name");
                System.exit(1);
            }
            Py_SetProgramName(program);
            /* optional but recommended */
            Py_Initialize();
            PyObject globals = PyModule_GetDict(PyImport_AddModule("__main__"));
            PyRun_StringFlags("import os, sys; " + "executable = os.path.abspath(os.path.join(os.__file__, '..', '..')) + ' (embedded python)'; " + "version = sys.version.split(' ')[0]", Py_single_input, globals, null, null);
            JavaCppDetails javaCppDetails = new JavaCppDetails("0", getStringFromPythonObject(PyDict_GetItemString(globals, "executable")), getStringFromPythonObject(PyDict_GetItemString(globals, "version")) + System.lineSeparator());
            PyMem_RawFree(program);
            if (Py_FinalizeEx() < 0) {
                System.exit(120);
            }
            return javaCppDetails;
        } catch (IOException e) {
            System.out.println(e.getMessage());
            System.exit(1);
            return null;
        }
    }

    private static void listPythonInstallations(boolean withInstalledPackages) {
        System.out.println("\n----------------------------PYTHON INSTALLS----------------------------");
        System.out.print(findPythonInstallations().stream().map(pythonDetails -> formatPythonInstallation(pythonDetails, withInstalledPackages)).collect(Collectors.joining(System.lineSeparator())));
        System.out.println("-----------------------------------------------------------------------");
    }

    private static void listCondaInstallations(boolean withInstalledPackages) {
        System.out.println("\n----------------------------CONDA INSTALLS-----------------------------");
        System.out.print(findCondaInstallations().stream().map(condaDetails -> formatCondaInstallation(condaDetails, withInstalledPackages)).collect(Collectors.joining(System.lineSeparator())));
        System.out.println("-----------------------------------------------------------------------");
    }

    private static String formatPythonInstallation(PythonDetails pythonDetails, boolean withInstalledPackages) {
        return formatPythonInstallation(pythonDetails, 1, withInstalledPackages);
    }

    private static String formatPythonInstallation(PythonDetails pythonDetails, int numberOfTabs, boolean withInstalledPackages) {
        String tabs = IntStream.range(0, numberOfTabs).mapToObj(index -> "\t").collect(Collectors.joining(""));
        return String.format(" -%s%s: %s%n%spath: %s%n%sversion: %s%s", "\t", numberOfTabs > 1 ? "name" : "id", pythonDetails.id(), tabs, pythonDetails.path(), tabs, pythonDetails.version(), withInstalledPackages ? String.format("%s--------Installed Modules--------%n%s%n%s---------------------------------%n", tabs, Arrays.stream(ProcessUtils.runAndGetOutput(pythonDetails.path(), "-c", "from pip import _internal; _internal.main(['list'])").split(System.lineSeparator())).map(line -> String.format("%s- %s", tabs, line)).collect(Collectors.joining(System.lineSeparator())), tabs) : "");
    }

    private static void printJavaCppInstalledModules() {
        try {
            Py_AddPath(cachePackages());
            Pointer program = Py_DecodeLocale(PythonPathsCommand.class.getSimpleName(), null);
            if (program == null) {
                System.out.println("Fatal error: cannot get class name");
                System.exit(1);
            }
            Py_SetProgramName(program);
            /* optional but recommended */
            Py_Initialize();
            PyRun_SimpleStringFlags("from pip import _internal\n" + "import warnings\n" + "warnings.filterwarnings(action='ignore')\n" + "class writer :\n" + "    def __init__(self, *writers) :\n" + "        self.writers = writers\n" + "\n" + "    def write(self, text) :\n" + "        for w in self.writers :\n" + "            w.write('\t- ' + text)\n" + "\n" + "    def flush(self):\n" + "        pass\n" + "import sys\n" + "sys.stdout = writer(sys.stdout)\n" + "installed_modules = _internal.main(['list'])", null);
            if (Py_FinalizeEx() < 0) {
                System.exit(120);
            }
            PyMem_RawFree(program);
        } catch (IOException e) {
            System.out.println(e.getMessage());
            System.exit(1);
        }
    }

    private static String formatCondaInstallation(CondaDetails condaDetails, boolean withInstalledPackages) {
        List<String> formattedCondaEnvironments = new ArrayList<>();
        condaDetails.environments().forEach(pythonDetails -> formattedCondaEnvironments.add(formatPythonInstallation(pythonDetails, 2, withInstalledPackages)));
        return String.format(" -\tid: %s%n\tpath: %s%n\tversion: %s%s", condaDetails.id(), condaDetails.path(), condaDetails.version(), String.format("\t--------------------------ENVIRONMENTS-------------------------%n" + "\t%s" + "\t---------------------------------------------------------------%n", String.join(System.lineSeparator() + "\t", formattedCondaEnvironments)));
    }

    private static void listVenvInstallations(boolean withInstalledPackages) {
        System.out.println("\n-----------------------------VENV INSTALLS-----------------------------");
        System.out.print(findVenvInstallations().stream().map(venvDetails -> formatPythonInstallation(new PythonDetails(venvDetails.id(), venvDetails.path(), venvDetails.version()), withInstalledPackages)).collect(Collectors.joining(System.lineSeparator())));
        System.out.println("-----------------------------------------------------------------------");
    }

    private static String getStringFromPythonObject(PyObject pythonObject) {
        PyObject pythonEncodedString = PyUnicode_AsEncodedString(pythonObject, "utf-8", "~E~");
        String javaString = PyBytes_AsString(pythonEncodedString).getString();
        Py_DecRef(pythonEncodedString);
        return javaString;
    }
}

```


Overlapping Code:
```
ity command to manage system installed and manually registered python binaries.")
@Description("A utility command to manage system installed and manually reython binaries " + "could be from either a regular python install, through a conda environment, javacpp cpython or a virtpython installation has been assigned a particulartifies which python installation is going to be us. You can also register a python binary if it's noonduit pythonpaths add -t=python -p=E:\\python37\\lass PythonPathsCommand extends DefaultCommand {
private SubCommand subCommand;
private Object type;
private String path;
private boolean withInstalledPackages;
@Argument(index = 0, argName = "sub_command", required = false)
@DefaultValue("LIST")
@Description("Sub command to be used with the pythonpaths command. Sub commands are: [add, list, configDefaults to 'LIST'")
public void setSubCommand(String subCommand) {
try {
this.subCommand = PythonPathsCommand.SubCommand.valueOf(subCommand.toUpperCase());
} catch (Exception e) {
System.out.format("Invalid sub command name: '%s'. Allowed values are: %s -> (case insensitive)."Command, Arrays.toString(PythonPathsCommand.SubCommand.values()));
System.exit(1);
}
}
@Option(shortName = "t", longName = "type", argName = "type", required = true)
@Description("Name of the python type. For the 'add' subcommand, accepted values are: [pythoncepted values are: [all, javacpp, python, conda, vlues are: [custom, javacpp, python, conda, venv]")
public void setType(String type) {
this.type = type;
}
@Option(shortName = "p", longName = "path", argName = "install_path")
@Description("Absolute p
```
<Overlap Ratio: 0.682741116751269>

---

--- 363 --
Question ID: 221d19854b3387b4e611c94a1b3119ad951a1176
Original Code:
```
public final class zzz implements ObjectEncoder<zzn> {

    public void encode(Object obj, Object obj2) throws EncodingException, IOException {
        zzn zzn = (zzn) obj;
        ObjectEncoderContext objectEncoderContext = (ObjectEncoderContext) obj2;
        if (zzn.zzb() != null) {
            objectEncoderContext.add("mobileSubtype", (Object) zzn.zzb().name());
        }
        if (zzn.zzc() != null) {
            objectEncoderContext.add("networkType", (Object) zzn.zzc().name());
        }
    }
}

```


Overlapping Code:
```
ements ObjectEncoder<zzn> {
public void encode(Object obj, Object obj2) throws EncodingException, IOException {
zzn zzn = (zzn) obj;
ObjectEncoderContext objectEncoderContext = (ObjectEncoderContext) obj2;
if (zzn.zzb() != null) {
objectEncoderContext.add("mobileSubtype", (Object) zzn.zzb().name());
}
if (zzn.zzc() != null) {
objectEncoderContext.add("networkType", (Object) zzn.zzc().name());
}
}

```
<Overlap Ratio: 0.9345794392523364>

---

--- 364 --
Question ID: e2f527d42211782844bffcb67f211f4aac0df984
Original Code:
```
public class SignupIntegrationTest extends ApiGatewayHandlerIntegrationTest {

    @BeforeEach
    void setup() {
        handler = new SignUpHandler(TEST_CONFIGURATION_SERVICE);
    }

    @Test
    void shouldReturn200WhenValidSignUpRequest() throws IOException {
        String sessionId = redis.createSession();
        redis.setSessionState(sessionId, EMAIL_CODE_VERIFIED);
        Map<String, String> headers = new HashMap<>();
        headers.put("Session-Id", sessionId);
        headers.put("X-API-Key", FRONTEND_API_KEY);
        var response = makeRequest(Optional.of(new SignupRequest("joe.bloggs+5@digital.cabinet-office.gov.uk", "password-1")), headers, Map.of());
        assertThat(response, hasStatus(200));
        BaseAPIResponse BaseAPIResponse = objectMapper.readValue(response.getBody(), BaseAPIResponse.class);
        assertThat(BaseAPIResponse.getSessionState(), equalTo(TWO_FACTOR_REQUIRED));
        assertTrue(userStore.userExists("joe.bloggs+5@digital.cabinet-office.gov.uk"));
    }
}

```


Overlapping Code:
```
gnupIntegrationTest extends ApiGatewayHandlerIntegrationTest {
@BeforeEach
void setup() {
handler = new SignUpHandler(TEST_CONFIGURATION_SERVICE);
}
@Test
void shouldReturn200WhenValidSignUpRequest() throws IOException {
String sessionId = redis.createSession();
redis.setSessionState(sessionId, EMAIL_CODE_VERIFIED);
Map<String, String> headers = new HashMap<>();
headers.put("Session-Id", sessionId);
headers.put("X-API-Key", FRONTEND_API_KEY);
var response = makeReque+5@digital.cabinet-office.gov.uk", "password-1")),p.of());
assertThat(response, hasStatus(200));
BaseAPIResResponse = objectMapper.readValue(response.getBody(), BaseAPIResponse.class);
assertThat(BaseAPIResponse.getSessionState(), equalTo(TWO_FACTOR_REQUIRED));
assertTrue(userStore.userExist
```
<Overlap Ratio: 0.8477777777777777>

---

--- 365 --
Question ID: 176afd6c9a0292ae4cd8a03ac5d1212ccc2d7dc6
Original Code:
```
class Arithmatic {

    public static void main(String[] args) {
        if (args.length != 2) {
            System.out.println("Please Enter Values ");
            return;
        }
        // take the numbers from args, would be in string form
        String s1 = args[0];
        String s2 = args[1];
        // convert them into numeric
        double d1 = Double.parseDouble(s1);
        double d2 = Double.parseDouble(s2);
        double d3 = d1 + d2;
        System.out.println("The Sum is : " + d3);
    }
}

```


Overlapping Code:
```
hmatic {
public static void main(String[] args) {
if (args.length != 2) {
System.out.println("Please Enter Values ");
return;
}
// taketring s1 = args[0];
String s2 = args[1];
// convert them into numeric
double d1 = Double.parseDouble(s1);
double d2 = Double.parseDouble(s2);
double d3 = d1 + d2;
System.out.println("The Sum is : " + 
```
<Overlap Ratio: 0.8333333333333334>

---

--- 366 --
Question ID: 396fe0097ad6ee2717cc47e6dc55b22f44414219
Original Code:
```
public abstract class GeometryBase extends Geometry {

    private static final long serialVersionUID = 1L;

    // default (clampToGround)
    private AltitudeModeEnumType altitudeMode;

    // default (false)
    private Boolean extrude;

    // default (false)
    private Boolean tessellate;

    // indicates gx:drawOrder (default = 0) for non-point geometries (line, ring, polygon)
    private Integer drawOrder;

    /**
     * Altitude Mode ([clampToGround], relativeToGround, absolute). If value is null
     * then the default clampToGround is assumed and altitude can be ignored.
     *
     * @return the altitudeMode
     */
    @CheckForNull
    public AltitudeModeEnumType getAltitudeMode() {
        return altitudeMode;
    }

    /**
     * Set altitudeMode
     *
     * @param altitudeMode the altitudeMode to set ([clampToGround], relativeToGround, absolute)
     */
    public void setAltitudeMode(AltitudeModeEnumType altitudeMode) {
        this.altitudeMode = altitudeMode;
    }

    /**
     * Set altitudeMode to normalized AltitudeModeEnumType value or null if invalid.
     *
     * @param altitudeMode the altitudeMode to set ([clampToGround], relativeToGround, absolute)
     *                     also includes gx:extensions (clampToSeaFloor and relativeToSeaFloor)
     */
    public void setAltitudeMode(String altitudeMode) {
        this.altitudeMode = AltitudeModeEnumType.getNormalizedMode(altitudeMode);
    }

    @CheckForNull
    public Boolean getExtrude() {
        return extrude;
    }

    public void setExtrude(Boolean extrude) {
        this.extrude = extrude;
    }

    @CheckForNull
    public Boolean getTessellate() {
        return tessellate;
    }

    public void setTessellate(Boolean tessellate) {
        this.tessellate = tessellate;
    }

    public Integer getDrawOrder() {
        return drawOrder;
    }

    public void setDrawOrder(Integer drawOrder) {
        this.drawOrder = drawOrder;
    }

    /**
     * Read data from SimpleObjectInputStream
     *
     * @param in SimpleObjectInputStream
     * @throws IOException              if an I/O error occurs or if this input stream has reached the end.
     * @throws ClassNotFoundException   if the class cannot be located
     * @throws IllegalAccessException   if the class or its nullary
     *                                  constructor is not accessible.
     * @throws InstantiationException   if this <code>Class</code> represents an abstract class,
     *                                  an interface, an array class, a primitive type, or void;
     *                                  or if the class has no nullary constructor;
     *                                  or if the instantiation fails for some other reason.
     * @throws IllegalArgumentException if enumerated AltitudeMode value is invalid
     * @see org.mitre.giscore.utils.SimpleObjectInputStream#readObject()
     */
    @Override
    public void readData(SimpleObjectInputStream in) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        super.readData(in);
        String val = in.readString();
        altitudeMode = val != null && val.length() != 0 ? AltitudeModeEnumType.valueOf(val) : null;
        int mask = in.readByte();
        // extrude: 2 = null, 1 = true, 0 = false
        int exMask = mask & 0x3;
        extrude = (exMask == 0 || exMask == 0x1) ? Boolean.valueOf(exMask == 0x1) : null;
        // tessellate: 2x = null, 1x = true, 0x = false
        int tessMask = mask & 0x30;
        tessellate = (tessMask == 0 || tessMask == 0x10) ? Boolean.valueOf(tessMask == 0x10) : null;
        this.drawOrder = (mask & 0x80) != 0 ? null : in.readInt();
    }

    /*
      * (non-Javadoc)
      * @see SimpleObjectOutputStream#writeObject(org.mitre.giscore.utils.IDataSerializable)
      */
    @Override
    public void writeData(SimpleObjectOutputStream out) throws IOException {
        super.writeData(out);
        out.writeString(altitudeMode == null ? "" : altitudeMode.toString());
        // with values: 0,1,null
        int mask = extrude == null ? 0x2 : extrude ? 0x1 : 0;
        if (tessellate == null)
            mask |= 0x20;
        else if (tessellate)
            mask |= 0x10;
        if (drawOrder == null)
            mask |= 0x80;
        out.writeByte(mask);
        if (drawOrder != null) {
            out.writeInt(drawOrder);
        }
    }
}

```


Overlapping Code:
```
lic abstract class GeometryBase extends Geometry {
private static final long serialVersionUID = 1L;
// d gx:drawOrder (default = 0) for non-point geometrititude Mode ([clampToGround], relativeToGround, absolute). If value is null
* then the default clampToGround is assumed and altitude can be ignored.
*
* @return the altitudeMode
*/
@CheckForNull
public AltitudeModeEnumType getAltitudeMode() {
return altitudeMode;
}
/**
* Set altitudeMode
*
* @param altitudeMode the altitudeMode to set ([clampToGround], relativeToGround, absolute)
*/
public void setAltitudeMode(AltitudeModeEnumType altitudeMode) {
this.altitudeMode = altitudeMode;
}
/**
* Set altitudeMode to normalized AltitudeModeEnumType value or null if invalid.
*
* @param altitudeMode the altitudeMode to set ([clampToGround], relativeToGround, absolute)
* also includes gx:extensions (clampToSeaFloor and relativeToSeaFloor)
*/
public void setAltitudeMode(String altitudeMode) {
this.altitudeMode = AltitudeModeEnumType.getNormalizedMode(altitudeMode);
}
@CheckForNull
public Boolean getExtrude() {
return extrude;
}
public void setExtrude(Boolean extrude) {
this.extrude = extrude;
}
@CheckForNull
public Boolean getTessellate() {
return tessellate;
}
public void setTessellate(Boolean tessellate) {
this.tessellate = tessellate;
}
public Integer getDrawOrder() {
return drawOrder;
}
public void setDrawOrder(Integer drawOrder) {
this.drawOrder = drawOrder;
}
/**
* Read data from SimpleObjectInputStream
*
* @param in SimpleObjectInputStream
* @throws IOException if an I/O error occurs or if this input stream has reached the end.
* @throws ClassNotFoundException if the class cannot be located
* @throws IllegalAccessException if the class or its nullary
* constructor is not accessible.
* @throws InstantiationExce
```
<Overlap Ratio: 0.8849206349206349>

---

--- 367 --
Question ID: 37ecfb9df884be7d35bf5475a3abf4d1b0e8fe8d
Original Code:
```
@RunWith(JMock.class)
public class PasswordValueSemanticsProviderTest extends ValueSemanticsProviderAbstractTestCase {

    private PasswordValueSemanticsProvider adapter;

    private Object password;

    private FacetHolder holder;

    @Before
    public void setUpObjects() throws Exception {
        holder = new FacetHolderImpl();
        setValue(adapter = new PasswordValueSemanticsProvider(holder, mockConfiguration, mockSpecificationLoader, mockRuntimeContext));
        password = new Password("secret");
    }

    @Test
    public void testEncoding() {
        assertEquals("secret", new String(adapter.toEncodedString(password)));
    }
}

```


Overlapping Code:
```
ass)
public class PasswordValueSemanticsProviderTest extends ValueSemanticsProviderAbstractTestCase {
private PasswordValueSemanticsProvider adapter;
private Object password;
private FacetHolder holder;
@Before
public void setUpObjects() throws Exception {
holder = new FacetHolderImpl();
setValue(adapter = new PasswordValueSemanticsProvider(holder, mockConfiguration, mockSpecificationLoader, mockRuntimeContext));quals("secret", new String(adapter.toEncodedString
```
<Overlap Ratio: 0.803448275862069>

---

--- 368 --
Question ID: 977a9650b30ee1056d3003eb9836578725120840
Original Code:
```
@EActivity(R.layout.activity_main)
public class PDFViewActivity extends AppCompatActivity implements OnPageChangeListener {

    public static final String SAMPLE_FILE = "sample.pdf";

    @ViewById
    PDFView pdfView;

    @ViewById
    ScrollBar scrollBar;

    @NonConfigurationInstance
    String pdfName = SAMPLE_FILE;

    @NonConfigurationInstance
    Integer pageNumber = 1;

    @AfterViews
    void afterViews() {
        pdfView.setScrollBar(scrollBar);
        display(pdfName, false);
    }

    private void display(String assetFileName, boolean jumpToFirstPage) {
        if (jumpToFirstPage)
            pageNumber = 1;
        setTitle(pdfName = assetFileName);
        pdfView.fromAsset(assetFileName).defaultPage(pageNumber).onPageChange(this).swipeVertical(true).showMinimap(false).load();
    }

    @Override
    public void onPageChanged(int page, int pageCount) {
        pageNumber = page;
        setTitle(format("%s %s / %s", pdfName, page, pageCount));
    }
}

```


Overlapping Code:
```
ublic class PDFViewActivity extends AppCompatActivity implements OnPageChangeListener {
public static final String SAMPLE_FILE = "sample.pdf";
@ViewById
PDFView pdfView;
@ViewById
ScrollBar scrollBar;
@NonConfigurationInstance
String pdfName = SAMPLE_FILE;
@NonConfigurationInstance
Integer pageNumber = 1;
@AfterViews
void afterViews() {
pdfView.setScrollBar(scrollBar);
display(pdfName, false);
}
private void display(String assetFileName, boolean jumpToFirstPage) {
if (jumpToFirstPage)
pageNumber =tle(pdfName = assetFileName);
pdfView.fromAsset(asleName).defaultPage(pageNumber).onPageChange(this)load();
}
@Override
public void onPageChanged(int page, int pageCount) {
pageNumber = page;
setTitle(format("%s %s / %s", pdfName, page, pageCount));

```
<Overlap Ratio: 0.8899408284023669>

---

--- 369 --
Question ID: bd5b15cd144abcfa59c8caa88db76b914d05a608
Original Code:
```
public class CalendarFormatterStressTest {

    private static final int DATE = 0x01;

    private static final int TIME = 0x02;

    private static final int WRAPPER = 0x04;

    private static final int DATESKEL = 0x08;

    private static final int TIMESKEL = 0x10;

    private static final CalendarFormat[] FORMATS = CalendarFormat.values();

    private static final int FORMATS_LEN = FORMATS.length;

    private static final CalendarSkeleton[] SKELETONS = CalendarSkeleton.values();

    private static final int SKELETONS_LEN = SKELETONS.length;

    @Test
    public void testCalendarFormatter() {
        StringBuilder buffer = new StringBuilder();
        long epoch = 1288648500000L;
        CLDR.Locale[] locales = new CLDR.Locale[] { CLDR.Locale.en_US, CLDR.Locale.am, CLDR.Locale.ar, CLDR.Locale.fr, CLDR.Locale.de, CLDR.Locale.en_GB };
        ZoneId zoneId = ZoneId.of("America/New_York");
        ZonedDateTime datetime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(epoch), zoneId);
        for (CLDR.Locale locale : locales) {
            CalendarFormatter f = CLDR.get().getCalendarFormatter(locale);
            int outer = DATE * TIME * WRAPPER * DATESKEL * TIMESKEL;
            int inner = FORMATS_LEN * SKELETONS_LEN;
            int i = 0;
            while (i < outer) try {
                int j = 0;
                while (j < inner) try {
                    CalendarFormatOptions options = options(i, j);
                    buffer.setLength(0);
                    f.format(datetime, options, buffer);
                } finally {
                    j++;
                }
            } finally {
                i++;
            }
        }
    }

    private static CalendarFormatOptions options(int flag, int choice) {
        CalendarFormatOptions opts = new CalendarFormatOptions();
        if ((flag & DATE) != 0) {
            opts.setDateFormat(format(choice));
        }
        if ((flag & TIME) != 0) {
            opts.setTimeFormat(format(choice));
        }
        if ((flag & WRAPPER) != 0) {
            opts.setWrapperFormat(format(choice));
        }
        if ((flag & DATESKEL) != 0) {
            opts.setDateSkeleton(skeleton(choice));
        }
        if ((flag & TIMESKEL) != 0) {
            opts.setTimeSkeleton(skeleton(choice));
        }
        return opts;
    }

    private static CalendarFormat format(int choice) {
        return FORMATS[choice % FORMATS_LEN];
    }

    private static CalendarSkeleton skeleton(int choice) {
        return SKELETONS[choice % SKELETONS_LEN];
    }
}

```


Overlapping Code:
```
vate static final int DATE = 0x01;
private static final int TIME = 0x02;
private static final int WRAPPER = 0x04;
private static final int DATESKEL = rivate static final CalendarFormat[] FORMATS = CalendarFormat.values();
private static final int FORMATS_LEN = FORMATS.length;
private static final CalendarSkeleton[] SKELETONS = CalendarSkeleton.values();
private static final int SKELETONS_LEN = SKEatter() {
StringBuilder buffer = new StringBuilder();
long epoch = 1288648500000L;
CLDR.Locale[] loconeId = ZoneId.of("America/New_York");
ZonedDateTime datetime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(epoch), zoneId);
for (CLDR.Locale locale : locales) {
CalendarFormatter f = CLDR.get().getCalendarFormatter(locale);
int outer = DATE * TIME * WRAPPER * DATESKEL * TIMESKEL;
int inner = FORMATS_LEN * Sons options = options(i, j);
buffer.setLength(0);
f.format(datetime, options, buffer)ate static CalendarFormatOptions options(int flag, int choice) {
CalendarFormatOptions opts = new CalendarFormatOptions();
if ((flag & DATE) != 0) {
opts.setDateFormat(format(choice));
}
if ((flag & TIME) != 0) {
opts.setTimeFormat(format(choice));
}
if ((flag & WRAPPER) != 0) {
opts.setWrapperFormat(format(choice));
}
if ((flag & DATESKEL) != 0) {
opts.setDateSkeleton(skeleton(choice));
}
if ((flag & TIMESKEL) != 0) {
opts.setTimeSkeleton(skeletndarFormat format(int choice) {
return FORMATS[cho
```
<Overlap Ratio: 0.7142857142857143>

---

--- 370 --
Question ID: 6c338a1f6834fb9094f88ce1c7d13fe385e54000
Original Code:
```
@RunWith(value = YBTestRunnerNonTsanOnly.class)
public class TestPgAlterTableAddPrimaryKey extends BasePgSQLTest {

    private static final Logger LOG = LoggerFactory.getLogger(TestPgAlterTableAddPrimaryKey.class);

    @Test
    public void simplest() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (id int)");
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
        }
    }

    @Test
    public void duplicates() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (id int, v int)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (1, 1)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (1, 2)");
            // PG error in this case mentions "nopk_pkey", not just "nopk"
            runInvalidQuery(stmt, "ALTER TABLE nopk ADD PRIMARY KEY (id)", "duplicate key value violates unique constraint \"nopk\"");
            stmt.executeUpdate("DELETE FROM nopk WHERE v = 2");
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1)));
        }
    }

    @Test
    public void nulls() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (id int)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (NULL)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (1)");
            runInvalidQuery(stmt, "ALTER TABLE nopk ADD PRIMARY KEY (id)", "column \"id\" contains null values");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1), new Row((Object) null)));
        }
    }

    @Test
    public void columnTypes() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (id int, v1 int[10][20], v2 text)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (1, '{1,2,3}', 'qwe')");
            stmt.executeUpdate("INSERT INTO nopk VALUES (2, '{3,4}',   'zxcv')");
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, new Integer[] { 1, 2, 3 }, "qwe"), new Row(2, new Integer[] { 3, 4 }, "zxcv")));
        }
    }

    @Test
    public void columnTypesUnsupported() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TYPE typeid AS (i int)");
            stmt.executeUpdate("CREATE TABLE nopk (id typeid, v int)");
            String msg = "PRIMARY KEY containing column of type 'user_defined_type' not yet supported";
            runInvalidQuery(stmt, "ALTER TABLE nopk ADD PRIMARY KEY (id)", msg);
            runInvalidQuery(stmt, "ALTER TABLE nopk ADD PRIMARY KEY (id HASH, v)", msg);
            runInvalidQuery(stmt, "ALTER TABLE nopk ADD PRIMARY KEY (v HASH, id)", msg);
        }
    }

    @Test
    public void missing() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (id int)");
            String msg = "column \"missme\" named in key does not exist";
            runInvalidQuery(stmt, "ALTER TABLE nopk ADD PRIMARY KEY (missme)", msg);
            runInvalidQuery(stmt, "ALTER TABLE nopk ADD PRIMARY KEY (id HASH, missme)", msg);
            runInvalidQuery(stmt, "ALTER TABLE nopk ADD PRIMARY KEY (missme HASH, id)", msg);
        }
    }

    @Test
    public void complexPk() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (v1 int, v2 text, v3 char, v4 boolean)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (1, '111', '1', true)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (2, '222', '2', false)");
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY ((v1, v2) HASH, v3 ASC, v4 DESC)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (2, '222', '3', true)");
            runInvalidQuery(stmt, "INSERT INTO nopk VALUES (2, '222', '2', false)", "duplicate key value violates unique constraint \"nopk_pkey\"");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY v1, v2, v3, v4", Arrays.asList(new Row(1, "111", "1", true), new Row(2, "222", "2", false), new Row(2, "222", "3", true)));
        }
    }

    @Test
    public void pkInclude() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (id int, v1 int, v2 int)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (1, 11, 111)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (2, 22, 222)");
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id) INCLUDE (v1, v2)");
            // Scan is supposed to be index-only scan, but it's index scan for us.
            {
                String includeQuery = "SELECT v1 FROM nopk WHERE id = 2";
                assertTrue(isIndexScan(stmt, includeQuery, "nopk_pkey"));
                assertQuery(stmt, includeQuery, new Row(22));
            }
            stmt.executeUpdate("INSERT INTO nopk VALUES (3, 11, 111)");
            runInvalidQuery(stmt, "INSERT INTO nopk VALUES (3, 99, 999)", "duplicate key value violates unique constraint \"nopk_pkey\"");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 11, 111), new Row(2, 22, 222), new Row(3, 11, 111)));
            {
                String includeQuery = "SELECT v1 FROM nopk WHERE id = 3";
                assertTrue(isIndexScan(stmt, includeQuery, "nopk_pkey"));
                assertQuery(stmt, includeQuery, new Row(11));
            }
        }
    }

    @Test
    public void pkUsingIndex() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (id int)");
            stmt.executeUpdate("CREATE UNIQUE INDEX nopk_idx ON nopk (id ASC)");
            runInvalidQuery(stmt, "ALTER TABLE nopk ADD CONSTRAINT nopk_pkey PRIMARY KEY" + " USING INDEX nopk_idx", "ALTER TABLE / ADD CONSTRAINT PRIMARY KEY USING INDEX is not supported");
        }
    }

    @Test
    public void sequences() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (" + "id serial," + "v1 int GENERATED ALWAYS AS IDENTITY," + "v2 int GENERATED BY DEFAULT AS IDENTITY (MINVALUE 10)," + "stuff text)");
            stmt.executeUpdate("INSERT INTO nopk (stuff) VALUES ('r1')");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1, 10, "r1")));
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
            stmt.executeUpdate("INSERT INTO nopk (stuff) VALUES ('r2')");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1, 10, "r1"), new Row(2, 2, 11, "r2")));
        }
    }

    @Test
    public void typedTable() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TYPE nopk_type AS (id int, v int)");
            stmt.executeUpdate("CREATE TABLE nopk OF nopk_type");
            stmt.executeUpdate("INSERT INTO nopk VALUES (1, 10)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (2, 20)");
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 10), new Row(2, 20)));
            runInvalidQuery(stmt, "ALTER TABLE nopk DROP COLUMN v", "cannot drop column from typed table");
        }
    }

    // TODO(alex): Enable after INHERITS is supported in #1129
    @Ignore
    public void inheritedTable() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk_parent (id int)");
            stmt.executeUpdate("INSERT INTO nopk_parent VALUES (1)");
            stmt.executeUpdate("INSERT INTO nopk_parent VALUES (2)");
            stmt.executeUpdate("CREATE TABLE nopk_child (v int) INHERITS (nopk_parent);");
            stmt.executeUpdate("INSERT INTO nopk_child VALUES (3, 30)");
            stmt.executeUpdate("INSERT INTO nopk_child VALUES (4, 40)");
            alterAddPrimaryKey(stmt, "nopk_parent", "ADD PRIMARY KEY (id)");
            alterAddPrimaryKey(stmt, "nopk_child", "ADD PRIMARY KEY (id)");
            assertRowList(stmt, "SELECT * FROM nopk_parent ORDER BY id", Arrays.asList(new Row(1), new Row(2)));
            assertRowList(stmt, "SELECT * FROM nopk_child ORDER BY id", Arrays.asList(new Row(3, 30), new Row(4, 40)));
        }
    }

    /**
     * Adding PK to a partitioned table is not yet implemented.
     */
    @Test
    public void partitionedTable() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk_whole (id int) PARTITION BY LIST (id)");
            stmt.executeUpdate("CREATE TABLE nopk_part1 PARTITION OF nopk_whole" + " FOR VALUES IN (1, 2, 3)");
            stmt.executeUpdate("CREATE TABLE nopk_part2 PARTITION OF nopk_whole" + " FOR VALUES IN (10, 20, 30, 40) PARTITION BY LIST (id)");
            stmt.executeUpdate("CREATE TABLE nopk_part2_part1 PARTITION OF nopk_part2" + " FOR VALUES IN (10, 20)");
            stmt.executeUpdate("CREATE TABLE nopk_part2_part2 PARTITION OF nopk_part2" + " FOR VALUES IN (30, 40)");
            runInvalidQuery(stmt, "ALTER TABLE nopk_whole ADD PRIMARY KEY (id)", "adding primary key to a partitioned table is not yet implemented");
            runInvalidQuery(stmt, "ALTER TABLE nopk_part1 ADD PRIMARY KEY (id)", "adding primary key to a partitioned table is not yet implemented");
            runInvalidQuery(stmt, "ALTER TABLE nopk_part2 ADD PRIMARY KEY (id)", "adding primary key to a partitioned table is not yet implemented");
            runInvalidQuery(stmt, "ALTER TABLE nopk_part2_part1 ADD PRIMARY KEY (id)", "adding primary key to a partitioned table is not yet implemented");
            runInvalidQuery(stmt, "ALTER TABLE nopk_part2_part2 ADD PRIMARY KEY (id)", "adding primary key to a partitioned table is not yet implemented");
        }
    }

    @Test
    public void tablesInColocatedDb() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE DATABASE clc WITH colocated = true");
        }
        try (Connection conn2 = getConnectionBuilder().withDatabase("clc").connect();
            Statement stmt = conn2.createStatement()) {
            stmt.executeUpdate("CREATE TABLE normal_table (id int PRIMARY KEY)");
            stmt.executeUpdate("INSERT INTO normal_table VALUES (1)");
            stmt.executeUpdate("INSERT INTO normal_table VALUES (2)");
            stmt.executeUpdate("CREATE TABLE nopk_c (id int)");
            stmt.executeUpdate("INSERT INTO nopk_c VALUES (3)");
            stmt.executeUpdate("INSERT INTO nopk_c VALUES (4)");
            stmt.executeUpdate("CREATE TABLE nopk_nc (id int) WITH (colocated = false)");
            stmt.executeUpdate("INSERT INTO nopk_nc VALUES (5)");
            stmt.executeUpdate("INSERT INTO nopk_nc VALUES (6)");
            assertEquals(1, getNumTablets("clc", "normal_table"));
            assertEquals(1, getNumTablets("clc", "nopk_c"));
            assertEquals(NUM_TABLET_SERVERS, getNumTablets("clc", "nopk_nc"));
            // See #6159
            alterAddPrimaryKey(stmt, "nopk_c", "ADD PRIMARY KEY (id)");
            alterAddPrimaryKey(stmt, "nopk_nc", "ADD PRIMARY KEY (id)");
            assertRowList(stmt, "SELECT * FROM normal_table ORDER BY id", Arrays.asList(new Row(1), new Row(2)));
            assertRowList(stmt, "SELECT * FROM nopk_c ORDER BY id", Arrays.asList(new Row(3), new Row(4)));
            assertRowList(stmt, "SELECT * FROM nopk_nc ORDER BY id", Arrays.asList(new Row(5), new Row(6)));
            assertEquals(1, getNumTablets("clc", "normal_table"));
            assertEquals(1, getNumTablets("clc", "nopk_c"));
            assertEquals(NUM_TABLET_SERVERS, getNumTablets("clc", "nopk_nc"));
        }
    }

    @Test
    public void tablesInTablegroup() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLEGROUP tgroup1");
            stmt.executeUpdate("CREATE TABLE normal_table (id int PRIMARY KEY)" + " TABLEGROUP tgroup1");
            stmt.executeUpdate("INSERT INTO normal_table VALUES (1)");
            stmt.executeUpdate("INSERT INTO normal_table VALUES (2)");
            stmt.executeUpdate("CREATE TABLE nopk (id int)" + " TABLEGROUP tgroup1");
            stmt.executeUpdate("INSERT INTO nopk VALUES (3)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (4)");
            stmt.executeUpdate("CREATE TABLE nopk2 (id int, id2 int unique)" + " TABLEGROUP tgroup1");
            stmt.executeUpdate("INSERT INTO nopk2 VALUES (5, 5)");
            stmt.executeUpdate("INSERT INTO nopk2 VALUES (6, 6)");
            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, "normal_table"));
            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, "nopk"));
            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, "nopk2"));
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
            alterAddPrimaryKey(stmt, "nopk2", "ADD PRIMARY KEY (id)");
            assertRowList(stmt, "SELECT * FROM normal_table ORDER BY id", Arrays.asList(new Row(1), new Row(2)));
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(3), new Row(4)));
            assertRowList(stmt, "SELECT * FROM nopk2 ORDER BY id", Arrays.asList(new Row(5, 5), new Row(6, 6)));
            assertRowList(stmt, "SELECT s.relname, pg_tablegroup.grpname " + "FROM (SELECT relname, unnest(reloptions) AS opts FROM pg_class) " + "s, pg_tablegroup WHERE opts LIKE " + "CONCAT('%tablegroup=', CAST(pg_tablegroup.oid AS text), '%') " + "ORDER BY s", Arrays.asList(new Row("nopk", "tgroup1"), new Row("nopk2", "tgroup1"), new Row("nopk2_id2_key", "tgroup1"), new Row("nopk2_pkey", "tgroup1"), new Row("nopk_pkey", "tgroup1"), new Row("normal_table", "tgroup1"), new Row("normal_table_pkey", "tgroup1")));
            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, "normal_table"));
            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, "nopk"));
            assertEquals(1, getNumTablets(DEFAULT_PG_DATABASE, "nopk2"));
        }
    }

    @Test
    public void defaults() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (" + " id int DEFAULT 10, " + " drop_me int DEFAULT 10, " + " v int DEFAULT 10" + ")");
            stmt.executeUpdate("INSERT INTO nopk VALUES (1, 1, 1)");
            stmt.executeUpdate("ALTER TABLE nopk DROP COLUMN drop_me");
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1)));
            stmt.executeUpdate("INSERT INTO nopk (id) VALUES (2)");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1), new Row(2, 10)));
            stmt.executeUpdate("INSERT INTO nopk (v) VALUES (2)");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1), new Row(2, 10), new Row(10, 2)));
        }
    }

    @Test
    public void notNullAndCheck() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (" + " id int CHECK (id > 0)," + " drop_me int," + " v1 int CHECK (v1 > 0)," + " v2 int NOT NULL" + ")");
            stmt.executeUpdate("ALTER TABLE nopk DROP COLUMN drop_me");
            stmt.executeUpdate("INSERT INTO nopk VALUES (1, 1, 1)");
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1, 1)));
            runInvalidQuery(stmt, "INSERT INTO nopk VALUES (0, 2, 2)", "violates check constraint \"nopk_id_check\"");
            runInvalidQuery(stmt, "INSERT INTO nopk VALUES (2, 0, 2)", "violates check constraint \"nopk_v1_check\"");
            runInvalidQuery(stmt, "INSERT INTO nopk VALUES (2, 2, NULL)", "violates not-null constraint");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1, 1)));
        }
    }

    /**
     * Altered table references a FK table.
     */
    @Test
    public void foreignKeys() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE fk_ref_table (id int PRIMARY KEY, v int UNIQUE)");
            stmt.executeUpdate("CREATE UNIQUE INDEX ON fk_ref_table (v, id)");
            stmt.executeUpdate("INSERT INTO fk_ref_table VALUES (1, 1)");
            stmt.executeUpdate("INSERT INTO fk_ref_table VALUES (2, 2)");
            stmt.executeUpdate("CREATE TABLE nopk (" + " id int," + " fk1 int REFERENCES fk_ref_table (id)," + " drop_me int," + " fk2 int REFERENCES fk_ref_table (v)," + " fk3 int)");
            stmt.executeUpdate("ALTER TABLE nopk ADD FOREIGN KEY (fk2, fk3)" + " REFERENCES fk_ref_table (v, id)");
            stmt.executeUpdate("ALTER TABLE nopk DROP COLUMN drop_me");
            stmt.executeUpdate("INSERT INTO nopk VALUES (1, 1, 1, 1)");
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1, 1, 1)));
            runInvalidQuery(stmt, "INSERT INTO nopk VALUES (2, 20, 2, 2)", "violates foreign key constraint \"nopk_fk1_fkey\"");
            runInvalidQuery(stmt, "INSERT INTO nopk VALUES (2, 2, 20, 2)", "violates foreign key constraint \"nopk_fk2_fkey\"");
            runInvalidQuery(stmt, "INSERT INTO nopk VALUES (2, 2, 2, 20)", "violates foreign key constraint \"nopk_fk2_fkey1\"");
            stmt.executeUpdate("INSERT INTO nopk VALUES (2, 2, 2, 2)");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1, 1, 1), new Row(2, 2, 2, 2)));
            runInvalidQuery(stmt, "DELETE FROM fk_ref_table WHERE id = 1", "violates foreign key constraint \"nopk_fk1_fkey\" on table \"nopk\"");
        }
    }

    /**
     * Altered table itself is referenced through FK constraints from other table.
     */
    @Test
    public void foreignKeys2() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (id int UNIQUE, drop_me int, v int)");
            stmt.executeUpdate("CREATE UNIQUE INDEX ON nopk (v)");
            stmt.executeUpdate("CREATE UNIQUE INDEX ON nopk (v, id)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (1, 1, 1)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (2, 2, 2)");
            stmt.executeUpdate("ALTER TABLE nopk DROP COLUMN drop_me");
            stmt.executeUpdate("CREATE TABLE referencing_table (" + " id int PRIMARY KEY," + " fk1 int REFERENCES nopk (id)," + " drop_me int," + " fk2 int REFERENCES nopk (v)," + " fk3 int)");
            stmt.executeUpdate("ALTER TABLE referencing_table ADD FOREIGN KEY (fk2, fk3)" + " REFERENCES nopk (v, id)");
            stmt.executeUpdate("INSERT INTO referencing_table VALUES (1, 1, 1, 1, 1)");
            stmt.executeUpdate("ALTER TABLE referencing_table DROP COLUMN drop_me");
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1), new Row(2, 2)));
            assertRowList(stmt, "SELECT * FROM referencing_table ORDER BY id", Arrays.asList(new Row(1, 1, 1, 1)));
            runInvalidQuery(stmt, "INSERT INTO referencing_table VALUES (2, 20, 2, 2)", "violates foreign key constraint \"referencing_table_fk1_fkey\"");
            runInvalidQuery(stmt, "INSERT INTO referencing_table VALUES (2, 2, 20, 2)", "violates foreign key constraint \"referencing_table_fk2_fkey\"");
            runInvalidQuery(stmt, "INSERT INTO referencing_table VALUES (2, 2, 2, 20)", "violates foreign key constraint \"referencing_table_fk2_fkey1\"");
            stmt.executeUpdate("INSERT INTO referencing_table VALUES (2, 2, 2, 2)");
            assertRowList(stmt, "SELECT * FROM referencing_table ORDER BY id", Arrays.asList(new Row(1, 1, 1, 1), new Row(2, 2, 2, 2)));
            runInvalidQuery(stmt, "DELETE FROM nopk WHERE id = 1", "violates foreign key constraint \"referencing_table_fk1_fkey\"" + " on table \"referencing_table\"");
        }
    }

    @Test
    public void otherConstraintsAndIndexes() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            // TODO(alex): Add EXCLUDE constraint after #997, in the meantime just make sure it's NYI.
            runInvalidQuery(stmt, "CREATE TABLE fail (c circle, EXCLUDE USING gist (c WITH &&))", "EXCLUDE constraint not supported yet");
            stmt.executeUpdate("CREATE TABLE nopk (" + " id int," + " v1 int UNIQUE," + " drop_me int," + " v2 int," + " v3 int," + " v4 int" + ")");
            stmt.executeUpdate("CREATE UNIQUE INDEX ON nopk (v2)");
            stmt.executeUpdate("CREATE INDEX ON nopk (v3)");
            stmt.executeUpdate("CREATE INDEX ON nopk ((v4 * 2))");
            stmt.executeUpdate("CREATE INDEX ON nopk ((v2, v3) HASH, v4 DESC NULLS LAST)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (1, 1, 1, 1, 1, 1)");
            stmt.executeUpdate("ALTER TABLE nopk DROP COLUMN drop_me");
            String v3query = "SELECT v3 FROM nopk WHERE v3 = 1";
            String v4query = "SELECT v4 FROM nopk WHERE v4 * 2 = 2";
            assertTrue(isIndexOnlyScan(stmt, v3query, "nopk_v3_idx"));
            assertTrue(isIndexScan(stmt, v4query, "nopk_expr_idx"));
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1, 1, 1, 1)));
            runInvalidQuery(stmt, "INSERT INTO nopk VALUES (2, 1, 2, 2, 2)", "violates unique constraint \"nopk_v1_key\"");
            runInvalidQuery(stmt, "INSERT INTO nopk VALUES (2, 2, 1, 2, 2)", "violates unique constraint \"nopk_v2_idx\"");
            stmt.executeUpdate("INSERT INTO nopk VALUES (2, 2, 2, 1, 2)");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1, 1, 1, 1), new Row(2, 2, 2, 1, 2)));
            assertTrue(isIndexOnlyScan(stmt, v3query, "nopk_v3_idx"));
            assertRowList(stmt, v3query, Arrays.asList(new Row(1), new Row(1)));
            assertTrue(isIndexScan(stmt, v4query, "nopk_expr_idx"));
            assertRowList(stmt, v4query, Arrays.asList(new Row(1)));
        }
    }

    @Test
    public void triggers() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (id int, drop_me int, v int)");
            stmt.executeUpdate("INSERT INTO nopk VALUES (1, 1, 1)");
            stmt.executeUpdate("CREATE FUNCTION notice_on_trigger() RETURNS trigger" + " LANGUAGE plpgsql" + " AS $$" + "   BEGIN RAISE NOTICE 'Trigger called: %', TG_NAME;" + "   RETURN NEW;" + "   END;" + " $$;");
            for (String timing : Arrays.asList("before", "after")) {
                for (String scope : Arrays.asList("statement", "row")) {
                    for (String action : Arrays.asList("insert", "update", "delete")) {
                        stmt.executeUpdate(MessageFormat.format("CREATE TRIGGER nopk__{0}_{2}_{1}" + " {0} {2} ON nopk" + " FOR EACH {1}" + " EXECUTE PROCEDURE notice_on_trigger()", timing, scope, action));
                    }
                    String whenExpr = scope.equals("row") ? "OLD.id > 0 AND NEW.id > 0 AND OLD.v > 0 AND NEW.v > 0" : "RANDOM() >= 0";
                    stmt.executeUpdate(MessageFormat.format("CREATE TRIGGER nopk__{0}_update_c_{1}" + " {0} UPDATE OF id, v ON nopk" + " FOR EACH {1}" + " WHEN (" + whenExpr + ")" + " EXECUTE PROCEDURE notice_on_trigger()", timing, scope));
                }
            }
            stmt.executeUpdate("ALTER TABLE nopk DROP COLUMN drop_me");
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
            assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(new Row(1, 1)));
        }
    }

    @Test
    public void secondPk() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (id int PRIMARY KEY)");
            runInvalidQuery(stmt, "ALTER TABLE nopk ADD PRIMARY KEY (id)", "multiple primary keys for table \"nopk\" are not allowed");
        }
    }

    @Test
    public void splitInto() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (id int) SPLIT INTO 2 TABLETS");
            assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, "nopk"));
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
            assertEquals(2, getNumTablets(DEFAULT_PG_DATABASE, "nopk"));
        }
    }

    @Test
    public void roles() throws Exception {
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate("CREATE TABLE nopk (id int)");
            stmt.executeUpdate("CREATE ROLE new_user");
            stmt.executeUpdate("ALTER TABLE nopk OWNER TO new_user");
            assertQuery(stmt, "SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'", new Row("new_user"));
            alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
            assertQuery(stmt, "SELECT pg_get_userbyid(relowner) FROM pg_class WHERE relname = 'nopk'", new Row("new_user"));
        }
    }

    /**
     * Test to verify basic compatibility with pg_dump output (we don't check pg_X tables content).
     * <p>
     * Source was a real output from pg_dump in its default configuration.
     */
    @Test
    public void restorePgDump() throws Exception {
        URL sqlFileRes = getClass().getClassLoader().getResource("TestPgAlterTableAddPrimaryKey/restorePgDump.sql");
        assertTrue("Dump SQL resource not found!", sqlFileRes != null);
        File sqlFile = new File(sqlFileRes.getFile());
        String ysqlshPath = new File(PgRegressBuilder.getPgBinDir(), "ysqlsh").getAbsolutePath();
        ProcessBuilder procBuilder = new ProcessBuilder(ysqlshPath, "-h", getPgHost(0), "-p", Integer.toString(getPgPort(0)), DEFAULT_PG_DATABASE);
        procBuilder.redirectInput(sqlFile);
        List<String> output = runProcess(procBuilder);
        // Sanity checks.
        assertTrue(output.size() > 0);
        assertFalse("There was an error executing SQL: " + output, StringUtils.join(output, '\n').toLowerCase().contains("error"));
        try (Statement stmt = connection.createStatement()) {
            assertRowList(stmt, "SELECT * FROM public.with_constraints_and_such ORDER BY id", Arrays.asList(new Row(1, new Integer[] { 1, 2 }, 10, 123, 321, 111), new Row(2, new Integer[] { 2, 3 }, 20, 234, 432, 222), new Row(3, new Integer[] { 3, 4 }, 30, 345, 543, 333)));
        }
    }

    /**
     * Execute ALTER TABLE with the given alter spec, ensuring everything was migrated properly.
     */
    private void alterAddPrimaryKey(Statement stmt, String tableName, String alterSpec) throws Exception {
        String countPgClass = "SELECT COUNT(*) FROM pg_class";
        String getTableNames = "SELECT table_name FROM information_schema.tables" + " WHERE table_schema = 'public' ORDER BY table_name";
        String getOid = "SELECT oid FROM pg_class WHERE relname = '" + tableName + "'";
        // We're also selecting owning_tab_name instead of owning_tab OID.
        String getSequences = "SELECT c.oid, c.relname, " + "     c.relkind, c.relnamespace, " + "     (SELECT rolname FROM pg_catalog.pg_roles WHERE oid = c.relowner) AS rolname, " + "     c.relchecks, c.relhastriggers, " + "     c.relhasindex, c.relhasrules, c.relhasoids, " + "     c.relrowsecurity, c.relforcerowsecurity, " + "     c.relfrozenxid, c.relminmxid, tc.oid AS toid, " + "     tc.relfrozenxid AS tfrozenxid, " + "     tc.relminmxid AS tminmxid, " + "     c.relpersistence, c.relispopulated, " + "     c.relreplident, c.relpages, " + "     CASE WHEN c.reloftype <> 0" + "       THEN c.reloftype::pg_catalog.regtype ELSE NULL END" + "     AS reloftype, " + "     (SELECT c2.relname FROM pg_class c2 WHERE c2.oid = d.refobjid) AS owning_tab_name, " + "     d.refobjsubid AS owning_col, " + "     (SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace)" + "       AS reltablespace, " + "     array_remove(array_remove(c.reloptions,'check_option=local')," + "                  'check_option=cascaded')" + "     AS reloptions, " + "     CASE" + "       WHEN 'check_option=local' = ANY (c.reloptions)" + "         THEN 'LOCAL'::text " + "       WHEN 'check_option=cascaded' = ANY (c.reloptions)" + "         THEN 'CASCADED'::text ELSE NULL END" + "     AS checkoption, " + "     tc.reloptions AS toast_reloptions, " + "     c.relkind = 'S' AND EXISTS (" + "       SELECT 1 FROM pg_depend" + "       WHERE classid = 'pg_class'::regclass" + "         AND objid = c.oid" + "         AND objsubid = 0" + "         AND refclassid = 'pg_class'::regclass" + "         AND deptype = 'i'" + "     ) AS is_identity_sequence" + " FROM pg_class c " + " LEFT JOIN pg_depend d" + "   ON (c.relkind = 'S' AND d.classid = c.tableoid AND" + "     d.objid = c.oid AND d.objsubid = 0 AND " + "     d.refclassid = c.tableoid AND d.deptype IN ('a', 'i')) " + " LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) " + " LEFT JOIN pg_init_privs pip" + "   ON (c.oid = pip.objoid AND" + "     pip.classoid = 'pg_class'::regclass AND" + "     pip.objsubid = 0) " + " WHERE c.relkind in ('S') " + " ORDER BY c.oid";
        long oldOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);
        long oldPgClassSize = getSingleRow(stmt.executeQuery(countPgClass)).getLong(0);
        List<Row> oldTableNames = getRowList(stmt.executeQuery(getTableNames));
        List<Row> oldSequences = getRowList(stmt.executeQuery(getSequences));
        PgSystemTableInfo oldState = new PgSystemTableInfo(stmt.getConnection(), oldOid);
        stmt.executeUpdate("ALTER TABLE " + tableName + " " + alterSpec);
        // OID has changed, but the pg_class row content did not.
        long newOid = getSingleRow(stmt.executeQuery(getOid)).getLong(0);
        assertNotEquals(oldOid, newOid);
        // There's one more index in the pool now.
        assertQuery(stmt, countPgClass, new Row(oldPgClassSize + 1));
        // Everything else should remain as it was.
        assertRowList(stmt, getTableNames, oldTableNames);
        assertRowList(stmt, getSequences, oldSequences);
        PgSystemTableInfo newState = new PgSystemTableInfo(stmt.getConnection(), newOid);
        assertPgStateEquals(oldState, newState);
    }

    private List<Row> execCheckQuery(PreparedStatement ps, long oid) throws Exception {
        ps.setLong(1, oid);
        return getRowList(ps.executeQuery());
    }

    private void assertPgStateEquals(PgSystemTableInfo oldState, PgSystemTableInfo newState) {
        assertRow(oldState.pgClassRow, newState.pgClassRow);
        assertRows(oldState.attrs, newState.attrs);
        assertRows(oldState.defaults, newState.defaults);
        assertRows(oldState.checkConstrs, newState.checkConstrs);
        assertRows(oldState.indexes, newState.indexes);
        assertRows(oldState.foreignKeys, newState.foreignKeys);
        assertRows(oldState.triggers, newState.triggers);
    }

    private int getNumTablets(String databaseName, String tableName) throws Exception {
        List<String> lines = runProcess(TestUtils.findBinary("yb-admin"), "--master_addresses", masterAddresses, "list_tablets", "ysql." + databaseName, tableName);
        // We don't care about the output, just number of lines (minus header line).
        return lines.size() - 1;
    }

    private class PgSystemTableInfo {

        Row pgClassRow;

        List<Row> attrs;

        List<Row> defaults;

        List<Row> checkConstrs;

        List<Row> indexes;

        List<Row> foreignKeys;

        List<Row> triggers;

        public PgSystemTableInfo(Connection conn, long oid) throws Exception {
            // relnatts (because it includes dropped attributes).
            PreparedStatement getPgClassRow = conn.prepareStatement("SELECT relname, relnamespace, reloftype, relowner, relam, reltablespace, relpages," + "   reltuples, relallvisible, reltoastrelid, relisshared," + "   relpersistence, relkind, relchecks, relhasoids, relhasrules," + "   relhastriggers, relhassubclass, relrowsecurity, relforcerowsecurity," + "   relispopulated, relreplident, relispartition, relrewrite, relfrozenxid," + "   relminmxid, relacl" + " FROM pg_class WHERE oid = ?");
            //  * Added ORDER BY to all queries.
            PreparedStatement getAttrs = conn.prepareStatement("SELECT a.attname, a.atttypmod, " + "   a.attstattarget, a.attstorage, t.typstorage, " + "   a.atthasdef, a.attlen, a.attalign, a.attislocal, " + "   pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, " + "   array_to_string(a.attoptions, ', ') AS attoptions, " + "   CASE WHEN a.attcollation <> t.typcollation " + "     THEN a.attcollation ELSE 0 END AS attcollation, " + "   a.attidentity, " + "   pg_catalog.array_to_string(ARRAY(" + "     SELECT pg_catalog.quote_ident(option_name) || " + "     ' ' || pg_catalog.quote_literal(option_value) " + "     FROM pg_catalog.pg_options_to_table(attfdwoptions) " + "     ORDER BY option_name" + "   ), E',\n    ') AS attfdwoptions ," + "   CASE WHEN a.atthasmissing AND NOT a.attisdropped " + "     THEN a.attmissingval ELSE null END AS attmissingval " + " FROM pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_type t " + "   ON a.atttypid = t.oid " + " WHERE a.attrelid = ?::pg_catalog.oid " + "   AND a.attnum > 0::pg_catalog.int2 " + "   AND NOT a.attisdropped " + " ORDER BY a.attnum");
            PreparedStatement getDefaults = conn.prepareStatement("SELECT pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc " + " FROM pg_catalog.pg_attrdef " + " WHERE adrelid = ?::pg_catalog.oid " + " ORDER BY adnum");
            PreparedStatement getCheckConstrs = conn.prepareStatement("SELECT conname, pg_catalog.pg_get_constraintdef(oid) AS consrc," + "   conislocal, convalidated" + " FROM pg_catalog.pg_constraint " + " WHERE conrelid = ?::pg_catalog.oid AND contype = 'c'" + " ORDER BY conname");
            PreparedStatement getIndexes = conn.prepareStatement("SELECT t.relname AS indexname, " + "   inh.inhparent AS parentidx, " + "   pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, " + "   i.indnkeyatts AS indnkeyatts, " + "   i.indnatts AS indnatts, " + "   ARRAY(SELECT a.attname FROM UNNEST(i.indkey) k " + "     INNER JOIN pg_attribute a ON a.attrelid = t2.oid AND a.attnum = k) " + "     AS indkey_colnames, " + "   i.indisclustered, " + "   i.indisreplident, i.indoption, t.relpages, " + "   c.contype, c.conname, " + "   c.condeferrable, c.condeferred, " + "   pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, " + "   (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace)" + "     AS tablespace, " + "   t.reloptions AS indreloptions, " + "   (SELECT pg_catalog.array_agg(attnum ORDER BY attnum) " + "     FROM pg_catalog.pg_attribute " + "     WHERE attrelid = i.indexrelid AND " + "       attstattarget >= 0) AS indstatcols," + "   (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum) " + "     FROM pg_catalog.pg_attribute " + "     WHERE attrelid = i.indexrelid AND " + "       attstattarget >= 0) AS indstatvals " + " FROM pg_catalog.pg_index i " + " JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) " + " JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) " + " LEFT JOIN pg_catalog.pg_constraint c " + "   ON (i.indrelid = c.conrelid AND " + "     i.indexrelid = c.conindid AND " + "     c.contype IN ('u','x')) " + " LEFT JOIN pg_catalog.pg_inherits inh " + "   ON (inh.inhrelid = indexrelid) " + " WHERE i.indrelid = ?::pg_catalog.oid " + "   AND (i.indisvalid OR t2.relkind = 'p') " + "   AND i.indisready " + "   AND i.indisprimary = false " + " ORDER BY indexname");
            PreparedStatement getForeignKeys = conn.prepareStatement("SELECT conname, confrelid, " + "   pg_catalog.pg_get_constraintdef(oid) AS condef " + " FROM pg_catalog.pg_constraint " + " WHERE conrelid = ?::pg_catalog.oid " + "  AND conparentid = 0 " + "  AND contype = 'f'" + " ORDER BY conname");
            PreparedStatement getTriggers = conn.prepareStatement("SELECT tgname, " + "   tgfoid::pg_catalog.regproc AS tgfname, " + "   pg_catalog.pg_get_triggerdef(oid, false) AS tgdef, " + "   ARRAY(SELECT a.attname FROM UNNEST(t.tgattr) k " + "     INNER JOIN pg_attribute a ON a.attrelid = t.tgrelid AND a.attnum = k) " + "     AS tgattr_colnames, " + "   tgenabled " + " FROM pg_catalog.pg_trigger t " + " WHERE tgrelid = ?::pg_catalog.oid " + "   AND NOT tgisinternal" + " ORDER BY tgfname");
            List<Row> pgClassRows = execCheckQuery(getPgClassRow, oid);
            assertTrue("Table with OID " + oid + " not found!", pgClassRows.size() > 0);
            this.pgClassRow = pgClassRows.get(0);
            this.attrs = execCheckQuery(getAttrs, oid);
            this.defaults = execCheckQuery(getDefaults, oid);
            this.checkConstrs = execCheckQuery(getCheckConstrs, oid);
            this.indexes = execCheckQuery(getIndexes, oid);
            this.foreignKeys = execCheckQuery(getForeignKeys, oid);
            this.triggers = execCheckQuery(getTriggers, oid);
        }
    }
}

```


Overlapping Code:
```
RunWith(value = YBTestRunnerNonTsanOnly.class)
public class TestPgAlterTableAddPrimaryKey extends BasePgSQLTest {
private static final Logger LOG = LoggerFactory.getLogger(TestPgAlterTableAddPrimaryKey.class);
@Test
public void simplest() throws Exception {
try (Statement stmt = connection.createStatement()) {
stmt.executeUpdate("CREATE TABLE nopk (id int)");
alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
}
}
@Test
public void duplicates() throws Exception {
try (Statement stmt = connection.createStatement()) {
stmt.executeUpdate("CREATE TABLE nopk (id int, v int)");
stmt.executeUpdate("INSERT INTO nopk VALUES (1, 1)");
stmt.executeUpdate("INSERT INTO nopk VALUES (1ions "nopk_pkey", not just "nopk"
runInvalidQuery(stmt, "ALTER TABLE nopk ADD PRIMARY KEY (id)", "duplicate key value violates unique constraint \"nopk\"");
stmt.executeUpdate("DELETE FROM nopk WHERE v = 2");
alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList();
}
}
@Test
public void nulls() throws Exception {
try (Statement stmt = connection.createStatement()) {
stmt.executeUpdate("CREATE TABLE nopk (id int)");
stmt.executeUpdate("INSERT INTO nopk VALUES (NULL)");
stmt.executeUpdate("INSERT INTO nopk VALUES (1)");
runInvalidQuery(stmt, "ALTER TABLE nopk ADD PRIMARY KEY (id)", "ll values");
assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(w((Object) null)));
}
}
@Test
public void columnTypes() throws Exception {
try (Statement stmt = connection.createStatement()) {
stmt.executeUpdate("CREATE TABLE nopk (id int, v1 int[10][20], v2 text)");
stmt.executeUpdate("INSERT INTO nopk VALUES (1, '{1,2,3}', 'qwe')");
stmt.executeUpdate("INSERT INTO nopk VALUES (2, '{3,4}', 'zxcv')");
alterAddPrimaryKey(stmt, "nopk", "ADD PRIMARY KEY (id)");
assertRowList(stmt, "SELECT * FROM nopk ORDER BY id", Arrays.asList(zxcv")));
}
}
@Test
public void columnTypesUnsuppo
```
<Overlap Ratio: 0.9139228598306679>

---

--- 371 --
Question ID: 0497272e2b6a1d4fbfc2a7ce34c849fbfbcb0d9d
Original Code:
```
@SpringBootTest(classes = { Application.class, TestIdamConfiguration.class })
@AutoConfigureMockMvc
@AutoConfigureWireMock(port = 0, stubs = "classpath:/wiremock-stubs")
@ActiveProfiles("itest")
public class BaseTest {

    public static final long AUTH_TOKEN_TTL = 14400000;

    public static final String IDAM_MOCK_USER_ID = "445";

    private static final String EXAMPLE_REQUEST_ID = "TEST REQUEST ID";

    @SpyBean
    @Autowired
    protected AuditRepository auditRepository;

    public static HttpHeaders createHttpHeaders(String serviceName) throws JOSEException {
        return createHttpHeaders(AUTH_TOKEN_TTL, serviceName, AUTH_TOKEN_TTL);
    }

    protected static HttpHeaders createHttpHeaders(long authTtlMillis, String serviceName, long s2sAuthTtlMillis) throws JOSEException {
        HttpHeaders headers = new HttpHeaders();
        String authToken = BEARER + generateAuthToken(authTtlMillis);
        headers.add(AUTHORIZATION, authToken);
        String s2SToken = generateS2SToken(serviceName, s2sAuthTtlMillis);
        headers.add(SERVICE_AUTHORIZATION, s2SToken);
        headers.add(AuditConfiguration.REQUEST_ID, EXAMPLE_REQUEST_ID);
        return headers;
    }

    protected ResultMatcher hasGeneratedLogAudit(AuditOperationType operationType, String invokingService, List<String> documentIds, String caseId, String jurisdiction, String caseType) {
        return result -> verifyLogAuditValues(result, operationType, invokingService, documentIds, caseId, jurisdiction, caseType);
    }

    protected void verifyLogAuditValues(MvcResult result, AuditOperationType operationType, String invokingService, List<String> documentIds, String caseId, String jurisdiction, String caseType) {
        ArgumentCaptor<AuditEntry> captor = ArgumentCaptor.forClass(AuditEntry.class);
        verify(auditRepository).save(captor.capture());
        AuditEntry auditEntry = captor.getValue();
        assertNotNull("DateTime", auditEntry.getDateTime());
        assertEquals("Operation Type", operationType.getLabel(), auditEntry.getOperationType());
        assertEquals("Idam ID", IDAM_MOCK_USER_ID, auditEntry.getIdamId());
        assertEquals("Invoking Service", invokingService, auditEntry.getInvokingService());
        assertEquals("HTTP Status", result.getResponse().getStatus(), auditEntry.getHttpStatus());
        assertEquals("HTTP Method", result.getRequest().getMethod(), auditEntry.getHttpMethod());
        assertEquals("Request Path", result.getRequest().getRequestURI(), auditEntry.getRequestPath());
        assertEquals("Request ID", EXAMPLE_REQUEST_ID, auditEntry.getRequestId());
        // NB: skip validation of inputs for BAD_REQUEST as some may not have been populated
        if (result.getResponse().getStatus() != HttpStatus.BAD_REQUEST.value()) {
            if (documentIds != null && !documentIds.isEmpty()) {
                assertThat(auditEntry.getDocumentIds()).isNotNull().hasSize(documentIds.size()).containsAll(documentIds);
            } else {
                assertThat(auditEntry.getDocumentIds()).isNullOrEmpty();
            }
            if (caseId != null && !caseId.equals("")) {
                assertThat(auditEntry.getCaseId()).isNotNull();
            } else {
                assertThat(auditEntry.getCaseId()).isNullOrEmpty();
            }
            if (jurisdiction != null && !jurisdiction.equals("")) {
                assertThat(auditEntry.getJurisdiction()).isNotNull();
            } else {
                assertThat(auditEntry.getJurisdiction()).isNullOrEmpty();
            }
            if (caseType != null && !caseType.equals("")) {
                assertThat(auditEntry.getCaseType()).isNotNull();
            } else {
                assertThat(auditEntry.getCaseType()).isNullOrEmpty();
            }
        }
    }

    private static String generateAuthToken(long ttlMillis) throws JOSEException {
        JWTClaimsSet.Builder builder = new JWTClaimsSet.Builder().subject("API_Stub").issueTime(new Date()).claim(TOKEN_NAME, ACCESS_TOKEN).expirationTime(new Date(System.currentTimeMillis() + ttlMillis));
        SignedJWT signedJWT = new SignedJWT(new JWSHeader.Builder(JWSAlgorithm.RS256).keyID(KeyGenUtil.getRsaJWK().getKeyID()).build(), builder.build());
        signedJWT.sign(new RSASSASigner(KeyGenUtil.getRsaJWK()));
        return signedJWT.serialize();
    }

    private static String generateS2SToken(String serviceName, long ttlMillis) {
        return Jwts.builder().setSubject(serviceName).setExpiration(new Date(System.currentTimeMillis() + ttlMillis)).signWith(SignatureAlgorithm.HS256, TextCodec.BASE64.encode("AA")).compact();
    }
}

```


Overlapping Code:
```
toConfigureMockMvc
@AutoConfigureWireMock(port = 0, stubs = "classpath:/wiremock-stubs")
@ActiveProfiles("itest")
public class BaseTest {
public static final long AUTH_TOKEN_TTL = 14400000;
public static final String IDAM_MOCK_USER_ID = "445";
private static final String EXAMPLE_REQUEST_ID = "TEST REQUEST ID";
@SpyBean
@Autowired
protected AuditRepository auditRepository;
public static HttpHeaders createHttpHeaders(String serviceName) throws JOSEException {
return createHttpHeaders(AUTH_TOKEN_TTL, serviceName, AUTH_TOKEN_TTL);
}
protected static HttpHeaders createHttpHe s2sAuthTtlMillis) throws JOSEException {
HttpHeaders headers = new HttpHeaders();
String authToken = BEARER + generateAuthToken(authTtlMillis);
headers.add(AUTHORIZATION, authToken);
String s2SToken = generateS2SToken(serviceName, s2sAuthTtlMillis);
headers.add(SERVICE_AUTHORIZATION, s2SToken);
headers.add(AuditConfiguration.REQUEST_ID, EXAMPLE_REQUEST_ID);
return headers;
}
protected ResultMatcher hasGeneratedLogAudit(AuditOperationType operatidocumentIds, String caseId, String jurisdiction, S caseType) {
return result -> verifyLogAuditValuesdocumentIds, String caseId, String jurisdiction, S
ArgumentCaptor<AuditEntry> captor = ArgumentCaptor.forClass(AuditEntry.class);
verify(auditRepository).save(captor.capture());
AuditEntry auditEntry = captor.getValue();
assertNotNull("DateTime", auditEntry.getDateTime());
assertEquals("Operation Type", operationType.getLabel(), auditEntry.getOperationType());
assertEquals("Idam ID", IDAM_MOCK_USER_ID, auditEntry.getIdamId());
assertEquals("Invoking Service", invokingService, auditEntry.getInvokingService());
assertEquals("HTTP Status", result.getResponse().getStatus(), auditEntry.getHttpStatus());
assertEquals("HTTP Method", result.getRequest().getMethod(), auditEntry.getHttpMethod());
assertEquals("Request P
```
<Overlap Ratio: 0.8067337122868387>

---

--- 372 --
Question ID: d93af83b46884f4e33c75a2aeeab3e3f01c313cc
Original Code:
```
public class CoreTests extends TestCase {

    public static Test suite() {
        TestSuite suite = new TestSuite(CoreTests.class.getName());
        suite.addTest(AddImportTest.suite());
        suite.addTest(SourceActionTests.suite());
        suite.addTest(ASTNodesInsertTest.suite());
        suite.addTest(BindingsNameTest.suite());
        suite.addTest(CallHierarchyTest.suite());
        suite.addTest(ClassPathDetectorTest.suite());
        suite.addTest(CodeFormatterUtilTest.suite());
        suite.addTest(CodeFormatterTest.suite());
        suite.addTest(HierarchicalASTVisitorTest.suite());
        suite.addTest(ImportOrganizeTest.suite());
        suite.addTest(ImportOrganizeTest18.suite());
        suite.addTest(JavaElementLabelsTest.suite());
        suite.addTest(JavaElementLabelsTest18.suite());
        suite.addTest(BindingLabelsTest.suite());
        suite.addTest(BindingLabels18Test.suite());
        suite.addTest(JavaElementPropertyTesterTest.suite());
        suite.addTest(JavaModelUtilTest.suite());
        suite.addTest(MethodOverrideTest.suite());
        suite.addTest(MethodOverrideTest18.suite());
        suite.addTest(NameProposerTest.suite());
        suite.addTest(OverrideTest.suite());
        suite.addTest(PartialASTTest.suite());
        suite.addTest(ScopeAnalyzerTest.suite());
        suite.addTest(TemplateStoreTest.suite());
        suite.addTest(TypeHierarchyTest.suite());
        suite.addTest(TypeRulesTest.suite());
        suite.addTest(TypeInfoTest.suite());
        suite.addTest(StringsTest.suite());
        suite.addTest(IndentManipulationTest.suite());
        suite.addTest(SelectionHistoryTest.suite());
        suite.addTest(ASTProviderTest.suite());
        suite.addTest(JDTFlagsTest18.suite());
        return new ProjectTestSetup(suite);
    }

    public CoreTests(String name) {
        super(name);
    }

    public static void assertEqualString(String actual, String expected) {
        StringAsserts.assertEqualString(actual, expected);
    }

    public static void assertEqualStringIgnoreDelim(String actual, String expected) throws IOException {
        StringAsserts.assertEqualStringIgnoreDelim(actual, expected);
    }

    public static void assertEqualStringsIgnoreOrder(String[] actuals, String[] expecteds) {
        StringAsserts.assertEqualStringsIgnoreOrder(actuals, expecteds);
    }

    public static void assertNumberOf(String name, int is, int expected) {
        assertTrue("Wrong number of " + name + ", is: " + is + ", expected: " + expected, is == expected);
    }

    protected ImportRewrite newImportsRewrite(ICompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) throws CoreException {
        ImportRewrite rewrite = StubUtility.createImportRewrite(cu, restoreExistingImports);
        rewrite.setImportOrder(order);
        rewrite.setOnDemandImportThreshold(normalThreshold);
        rewrite.setStaticOnDemandImportThreshold(staticThreshold);
        return rewrite;
    }

    protected ImportRewrite newImportsRewrite(CompilationUnit cu, String[] order, int normalThreshold, int staticThreshold, boolean restoreExistingImports) {
        ImportRewrite rewrite = ImportRewrite.create(cu, restoreExistingImports);
        rewrite.setImportOrder(order);
        rewrite.setOnDemandImportThreshold(normalThreshold);
        rewrite.setStaticOnDemandImportThreshold(staticThreshold);
        return rewrite;
    }
}

```


Overlapping Code:
```
Tests extends TestCase {
public static Test suite() {
TestSuite suite = new TestSuite(CoreTests.class.getName());
suite.addTest(AddImportTest.suite());
suite.addTest(SourceActionTests.suite());
suite.addTest(ASTNodesInsertTest.suite());
suite.addTest(BindingsNameTest.suite());
suite.addTest(CallHierarchyTest.suite());
suite.addTest(ClassPathDetectorTest.suite());
suite.addTest(CodeFormatterUtilTest.suite());
suite.addTest(CodeFormatterTest.suite());
suite.addTest(HierarchicalASTVisitorTest.suite());
suite.addTest(ImportOrganizeTest.suite());
suite.addTest(ImportOrganizeTest18.suite());
suite.addTest(JavaElementLabelsTest.suite());
suite.addTest(JavaElementLabelsTest18.suite());
suite.addTest(BindingLabelsTest.suite());
suite.addTest(BindingLabels18Test.suite());
suite.addTest(JavaElementPropertyTesterTest.suite());
suite.addTest(JavaModelUtilTest.suite());
suite.addTest(MethodOverrideTest.suite());
suite.addTest(MethodOverrideTest18.suite());
suite.addTest(NameProposerTest.suite());
suite.addTest(OverrideTest.suite());
suite.addTest(PartialASTTest.suite());
suite.addTest(ScopeAnalyzerTest.suite());
suite.addTest(TemplateStoreTest.suite());
suite.addTest(TypeHierarchyTest.suite());
suite.addTest(TypeRulesTest.suite());
suite.addTest(TypeInfoTest.suite());
suite.addTest(StringsTest.suite());
suite.addTest(IndentManipulationTest.suite());
suite.addTest(SelectionHistoryTest.suite());
suite.addTest(ASTProviderTest.suite());
suite.addTest(JDTFlagsTest18.suite());
return new ProjectTestSetup(suite);
}
public CoreTests(String name) {
super(name);
}
public static void assertEqualString(String actual, String expected) {
StringAsserts.assertEqualString(actual, expected);
}
public static void assertEqualStringIgnoreDelim(String actual, String expected) throws IOException {
StringAsserts.assertEqualStringIgnoreDelim(actual, expected);
}
public static void assertEqualStringsIgnoreOrder(String[] actuals, String[] expecteds) {
StringAsserts.assertEqualStringsIgnoreOrder(actuals, expecteds);
}
public static void assertNumberOf(String name, int is, int expected) {
assertTrue("Wrong number of " +
```
<Overlap Ratio: 0.9897003745318352>

---

--- 373 --
Question ID: e0ea20945f697123219e25bb900d86a4b8cb0fbb
Original Code:
```
public class Facade {

    private SubSystemOne subSystemOne;

    private SubSystemTwo subSystemTwo;

    private SubSystemThree subSystemThree;

    private SubSystemFour subSystemFour;

    public Facade() {
        subSystemOne = new SubSystemOne();
        subSystemTwo = new SubSystemTwo();
        subSystemThree = new SubSystemThree();
        subSystemFour = new SubSystemFour();
    }

    public void methodA() {
        subSystemOne.methodOne();
        subSystemTwo.methodOne();
        subSystemThree.methodOne();
    }

    public void methodB() {
        subSystemTwo.methodOne();
        subSystemThree.methodOne();
        subSystemFour.methodOne();
    }
}

```


Overlapping Code:
```
s Facade {
private SubSystemOne subSystemOne;
private SubSystemTwo subSystemTwo;
private SubSystemThree subSystemThree;
private SubSystemFour subSystemFour;
public Facade() {
subSystemOne = new SubSystemOne();
subSystemTwo = new SubSystemTwo();
subSystemThree = new SubSystemThree();
subSystemFour = new SubSystemFour();
}
public void methodA() {
subSystemOne.methodOne();
subSystemTwo.methodOne();
subSystemThree.methodOne();
}
public void methodB() {
subSystemTwo.methodOne();
subSystemThree.methodOne
```
<Overlap Ratio: 0.9178832116788321>

---

--- 374 --
Question ID: e94bc548a7921195722fe2cbedc8ac5317dc5070
Original Code:
```
public class Location {

    private static Pattern pattern = Pattern.compile("(\\S+), (\\S+), (\\S+)");

    private double x;

    private double y;

    private double z;

    Location(double x, double y, double z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    private Location(String x, String y, String z) {
        this(Double.parseDouble(x), Double.parseDouble(y), Double.parseDouble(z));
    }

    /**
     * Construct Location object from comma separated string
     *
     * @param str comma separated string, e.g. 1.0, 2.0, 3.0
     * @return Location object from string data
     */
    public static Location fromString(String str) {
        if (str == null)
            throw new IllegalArgumentException("str must not be null");
        Matcher matcher = pattern.matcher(str);
        if (matcher.find()) {
            return new Location(matcher.group(1), matcher.group(2), matcher.group(3));
        }
        return null;
    }

    public double getX() {
        return x;
    }

    public void setX(long x) {
        this.x = x;
    }

    public double getY() {
        return y;
    }

    public void setY(long y) {
        this.y = y;
    }

    public double getZ() {
        return z;
    }

    public void setZ(long z) {
        this.z = z;
    }

    @Override
    public String toString() {
        return this.x + ", " + this.y + ", " + this.z;
    }
}

```


Overlapping Code:
```
 {
private static Pattern pattern = Pattern.compile("(\\S+), (\\S+), (\\S+)");
private double x;
private double y;
private double z;
Location(double x, double y, double z) {
this.x = x;
this.y = y;
this.z = z;
}
private Location(String x, String y, String z) {
this(Double.parseDouble(x), Double.parseDouble(y), Double.parseDouble(z));
}
/**
* Construct Location object from comma separated string
*
* @param str comma separated string, e.g. 1.0, 2.0, 3.0
* @return Location object from string data
*/
public static Location fromString(String str) {
if (str == null)
throw new IllegalArgumentException("str must not be null");
Matcher matcher = pattern.matcher(str);
if (matcher.find()) {
return new Location(matcher.group(1), matcher.group(2), matcher.group(3));
}
return null;
}
public double getX() {
return x;
}
public void setX(long x) {
this.x = x;
}
public double getY() {
return y;
}
public void setY(long y) {
this.y = y;
}
public double getZ() {
return z;
}
public void setZ(long z) {
this.z = z;
}
@Override
public String toString() {
return this.x + ", " + this.y + ", " + this.z;

```
<Overlap Ratio: 0.9785138764547896>

---

--- 375 --
Question ID: a0b3fec9ca0c28a20691df8528413edb7042e26c
Original Code:
```
public class MainApp {

    public static void main(String[] args) throws Exception {
        ApplicationContext appContext = new ClassPathXmlApplicationContext("Spring-Customer.xml");
        Customer customer = (Customer) appContext.getBean("custom");
        customer.addCustomer();
        customer.addCustomerReturnValue();
        customer.addCustomerThrowException();
        customer.addCustomerAround("mkyong");
    }
}

```


Overlapping Code:
```
public class MainApp {
public static void main(String[] args) throws Exception {
ApplicationContext appContext = new ClassPathXmlApplicationContext("Spring-Customer.xml"
```
<Overlap Ratio: 0.4555256064690027>

---

--- 376 --
Question ID: 0b6a14048aa7baf6a73dc2a1cc1f8a4284ce3354
Original Code:
```
@TestPropertySource("classpath:testFm.properties")
public class DgFmTest extends AbstractWebTest {

    @Autowired
    private DgFmService fmService;

    @Test
    public void testFmInit() {
        assertTrue("Must have at least one feature", fmService.featuresCount() > 0);
    }

    @Test
    public void testBasics() {
        assertThatFeature("defaults", allOf(visible(), enabled(), not(mandatory())));
        assertThatFeature("allEnabled", allOf(visible(), enabled(), mandatory()));
        assertThatFeature("allDisabled", allOf(not(visible()), not(enabled()), not(mandatory())));
        assertThatFeature("reverseDefaults", allOf(not(visible()), not(enabled()), mandatory()));
    }

    @Test
    public void testMixins() {
        assertThatFeature("allDisabledMixin", allOf(not(visible()), not(enabled()), not(mandatory())));
        assertThatFeature("mandatoryWithAllDisabledMixin", allOf(not(visible()), not(enabled()), mandatory()));
        assertThatFeature("mandatoryWithAllDisabledChainedMixin", allOf(not(visible()), not(enabled()), mandatory()));
        assertThatFeature("mixingInAllEnabled", allOf(not(visible()), not(enabled()), mandatory()));
    }

    @Test
    public void testVisibleDeps() {
        assertThatFeature("visibleDepsAllDisabled", allOf(not(visible()), enabled(), not(mandatory())));
        assertThatFeature("visibleDepsAllDisabledChained", allOf(not(visible()), enabled(), not(mandatory())));
        assertThatFeature("visibleDepsAllEnabled", allOf(not(visible()), enabled(), not(mandatory())));
    }

    @Test
    public void testMandatoryDeps() {
        assertThatFeature("mandatoryDepsAllDisabled", allOf(visible(), enabled(), mandatory()));
        assertThatFeature("mandatoryDepsAllEnabled", allOf(visible(), enabled(), mandatory()));
        assertThatFeature("mandatoryDepsAllEnabledChained", allOf(visible(), enabled(), mandatory()));
    }

    @Test
    public void testEnabledDeps() {
        assertThatFeature("enabledDepsAllDisabled", allOf(visible(), not(enabled()), not(mandatory())));
        assertThatFeature("enabledDepsAllDisabledChained", allOf(visible(), not(enabled()), not(mandatory())));
        assertThatFeature("enabledDepsAllEnabled", allOf(visible(), not(enabled()), not(mandatory())));
    }

    private void assertThatFeature(String featureName, Matcher<DgFeature> matcher) {
        assertThat(fmService.getFeature(featureName), matcher);
    }

    private void assertFeature(String featureName, boolean visible, boolean enabled, boolean mandatory) {
        assertEquals(fmService.isFeatureVisible(featureName), visible);
        assertEquals(fmService.isFeatureEnabled(featureName), enabled);
        assertEquals(fmService.isFeatureMandatory(featureName), mandatory);
    }

    private Matcher<DgFeature> visible() {
        return describedAs("visible", hasProperty("visible", equalTo(true)));
    }

    private Matcher<DgFeature> mandatory() {
        return describedAs("mandatory", hasProperty("mandatory", equalTo(true)));
    }

    private Matcher<DgFeature> enabled() {
        return describedAs("enabled", hasProperty("enabled", equalTo(true)));
    }
}

```


Overlapping Code:
```
)
public class DgFmTest extends AbstractWebTest {
@Autowired
private DgFmService fmService;
@Test
public void testFmInit() {
assertTrue("Must have at least one feature", fmService.featuresCount() > 0);
}
@Test
public void testBasics() {
assertThatFeature("defaults", allOf(visible(), enabled(), not(mandatory())));
assertThatFeature("allEnabled", allOf(visible(), enabled(), mandatory()));
assertThatFeature("allDisabled", allOf(not(visible()), not(enabled()), not(mandatory())));
assertThatFeature("reverseDefaults", allOf(not(visible()), not(enabled()), mandatory()));
}
@Test
public void testMixins() {
assertThatFeature("allDisabledMixin", allOf(not(visible()), not(enabled()), not(mandatory())));
assertThatFeature("mandatoryWithAllDisabledMixin", allOf(not(visible()), not(enabled()), mandatory()));
assertThatFeature("mandatoryWithAllDisabledChainedMixin", allOf(not(visible()), not(enabled()), mandatory()));
assertThatFeature("mixingInAllEnabled", allOf(not(visible()), not(enabled()), mandatory()));
}
@Test
public void testVisibleDeps() {
assertThatFeature("visibleDepsAllDisabled", allOf(not(visible()), enabled(), not(mandatory())));
assertThatFeature("visibleDepsAllDisabledChained", allOf(not(visible()), enabled(), not(mandatory())));
assertThatFeature("visibleDepsAllEnabled", allOf(not(visible()), enabled(), not(mandatory())));
}
@Test
public void testMandatoryDeps() {
assertThatFeature("mandatoryDepsAllDisabled", allOf(visible(), enabled(), mandatory()));
assertThatFeature("mandatoryDepsAllEnabled", allOf(visible(), enabled(), mandatory()));
assertThatFeature("mandatoryDepsAllEnabledChained", allOf(visible(), enabled(), mandatory()));
}
@Test
public void testEnabledDeps() {
assertThatFeature("enabledDepsAllDisabled", allOf(visible(), not(enabled()), not(mandatory())));
assertThatFeature("enabledDepsAllDisabledChained", allOf(visible(), not(enabled()), not(mandatory())));
assertThatFeature("enabledDepsAllEnabled", allOf(visible(), not(enabled()), not(mandatory())));
}
private void assertThatFeature(String featureName, Matcher<DgFeature> matcher) {
assertThat(fmService.getFeature(featureName), matcher);
}
private voi
```
<Overlap Ratio: 0.9572573463935886>

---

--- 377 --
Question ID: 13885d2553f83227a07c14f88340bf149ac6a251
Original Code:
```
public class IndexBall extends CommandBase {

    FeederSubsystem feeder;

    int targetPositon;

    int incrementTicks;

    boolean reversing;

    boolean isDone;

    boolean maxBalls;

    boolean outputSwitchPressed;

    private final boolean setTalonPosistionEveryCycle = true;

    public IndexBall() {
        feeder = FeederSubsystem.getInstance();
        addRequirements(feeder);
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
        incrementTicks = -1 * Config.FEEDERSUBSYSTEM_INCREMENT_TICKS.get().intValue();
        int currentPosition = (int) feeder.getCurrentPosition();
        targetPositon = currentPosition + incrementTicks;
        reversing = false;
        isDone = false;
        if (feeder.getBallsAroundFeeder() >= Config.FEEDER_MAX_BALLS) {
            maxBalls = true;
            this.cancel();
            return;
        } else if (FeederSubsystem.isBallAtOutput()) {
            outputSwitchPressed = true;
            this.cancel();
            return;
        }
        maxBalls = false;
        outputSwitchPressed = false;
        feeder.setFeederPosistion(targetPositon);
    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
        if (maxBalls == true) {
            isDone = true;
            return;
        } else if (FeederSubsystem.isBallAtOutput()) {
            outputSwitchPressed = true;
            isDone = true;
            return;
        }
        int currentPosition = (int) feeder.getCurrentPosition();
        boolean atPosistion = feeder.isFeederAtPosistion(Config.FEEDERSUBSYSTEM_INDEX_ALLOWABLE_ERROR);
        int ticksChanged = currentPosition - (targetPositon - incrementTicks);
        if (currentPosition >= targetPositon || atPosistion) {
            isDone = true;
        } else if (reversing) {
            if (atPosistion) {
                isDone = true;
            } else if (setTalonPosistionEveryCycle) {
                feeder.setFeederPosistion(targetPositon - incrementTicks);
            }
        } else if (setTalonPosistionEveryCycle) {
            feeder.setFeederPosistion(targetPositon);
        }
    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
        if (reversing == false && maxBalls == false && outputSwitchPressed == false) {
            feeder.setBallsAroundFeeder(feeder.getBallsAroundFeeder() + 1);
        }
        if (outputSwitchPressed || FeederSubsystem.isBallAtOutput()) {
            feeder.setFeederPosistion((int) feeder.getCurrentPosition());
            feeder.stopFeeder();
        }
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        return isDone;
    }
}

```


Overlapping Code:
```
 feeder;
int targetPositon;
int incrementTicks;
boolean reversing;
boolean isDone;
boolean maxBalls;
boolean outputSwitchPressed;
private final boolea
addRequirements(feeder);
}
// Called when the command is initially scheduled.
@Override
public void initialize() {
incrementTicks = -1 * Config.FEEDERSUBSYSTEM_INCREMENT_TICKS.get().intValue();
int currentPosition = (int) feeder.getCurrentPosition();
targetPositon = currentPosition + incrementTicks;
reversing = false;
isDone = false;
if (feeder.getBallsAroundFeeder() >= Config.FEEDER_MAX_BALLS) {
maxBalls = true;
this.cancel();
return;
} else if (FeederSubsystem.isBallAtOutput()) {
outputSwitchPressed = true;
this.cancel();
return;
}
maxBalls = false;
outputSwitchPressed = false;
feeder.setFen);
}
// Called every time the scheduler runs while the command is scheduled.
@Override
public void execute() {
if (maxBalls == true) {
isDone = true;
return;
} else if (FeederSubsystem.isBallAtOutput()) {
outputSwitchPressed = true;
isDone = true;
return;
}
int currentPosition = (int) feeder.getCurrentPosition();
boolean atPosistion = feeder.isFeederAtPosistion(Config.FEEDERSUBSYSTEM_INDEX_ALLOWABLE_ERROR);
int ticksChanged = currentPosition - (targetPositon - increme);
if (currentPosition >= targetPositon || atPosistion) {
isDone = true;
} else if (reversinetTalonPosistionEveryCycle) {
feeder.setFeederPosistion(targetPositon - incrementTicketTalonPosistionEveryCycle) {
feeder.setFeederPosistion(targetPositon);
}
}
// Called once the command ends or is interrupted.
@Override
public void end(boolean interrupted) {
if (reversing == false && maxBalls == false && outputSwitchPressed == false) {
feeder.setBallsAroundFeeder(feeder.getBallsAroundFeeder() 
```
<Overlap Ratio: 0.8677811550151976>

---

--- 378 --
Question ID: 43bc2c085e6a2cac1f9ce49766096d0942154236
Original Code:
```
public class ExclusiveFilterSetTest {

    @Test
    public void constructor_null_throwsNullPointerException() {
        assertThrows(NullPointerException.class, () -> new ExclusiveFilterSet<String>(null));
    }

    @Test
    public void hasAny() {
        // EP 1: Fully contains
        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));
        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_A));
        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_B));
        // EP 2: Partially contains
        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));
        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));
        // EP 3: Disjoint
        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_B));
        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_A));
    }

    @Test
    public void hasAll() {
        // EP 1: Has All
        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_ABC));
        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB));
        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_A));
        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_B));
        // EP 2: Has Some
        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AC));
        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB));
        // EP 3: Disjoint
        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_B));
        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_A));
    }

    @Test
    public void add() {
        FilterSet<String> filterSet = new ExclusiveFilterSet<>();
        // EP 1: Empty
        filterSet.add(TypicalFilters.FILTER_A);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_A, filterSet);
        // EP 2: Not Empty
        filterSet.add(TypicalFilters.FILTER_B);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_AB, filterSet);
        filterSet.add(TypicalFilters.FILTER_C);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);
        // EP 3: Duplicate
        filterSet.add(TypicalFilters.FILTER_C);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);
        // EP 4: null
        assertThrows(NullPointerException.class, () -> filterSet.add(null));
    }

    @Test
    public void remove() {
        FilterSet<String> filterSet = new ExclusiveFilterSet<>(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.getFilters());
        // EP 1: Has Multiple
        filterSet.remove(TypicalFilters.FILTER_C);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_AB, filterSet);
        filterSet.remove(TypicalFilters.FILTER_B);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_A, filterSet);
        // EP 2: Has One
        filterSet.remove(TypicalFilters.FILTER_A);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);
        // EP 3: Empty
        filterSet.remove(TypicalFilters.FILTER_A);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);
        // EP 4: null
        filterSet.remove(null);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);
    }

    @Test
    public void addAll() {
        FilterSet<String> filterSet = new ExclusiveFilterSet<>();
        // EP 1: Empty
        filterSet.addAll(TypicalFilters.SET_C);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_C, filterSet);
        // EP 2: Not Empty
        filterSet.addAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);
        // EP 3: Duplicate
        filterSet.addAll(TypicalFilters.SET_B);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_ABC, filterSet);
        // EP 4: null
        assertThrows(NullPointerException.class, () -> filterSet.addAll((FilterSet<String>) null));
    }

    @Test
    public void removeAll() {
        FilterSet<String> filterSet = new ExclusiveFilterSet<>(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.getFilters());
        // EP 1: Has Multiple
        filterSet.removeAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_C, filterSet);
        // EP 2: Has One
        filterSet.removeAll(TypicalFilters.SET_C);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);
        // EP 3: Empty
        filterSet.removeAll(TypicalFilters.SET_A);
        assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_EMPTY, filterSet);
        // EP 4: null
        assertThrows(NullPointerException.class, () -> filterSet.removeAll((FilterSet<String>) null));
    }

    @Test
    public void test() {
        // EP 1: One filter match
        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_A.test(TypicalFilters.FILTERABLE_A));
        // EP 2: Multiple filters match
        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B));
        assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B + TypicalFilters.FILTERABLE_C));
        // EP 3: One filter no match
        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.test(TypicalFilters.FILTERABLE_B));
        // EP 4: Multiple filters no match
        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_A));
        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.test(TypicalFilters.FILTERABLE_A + TypicalFilters.FILTERABLE_B));
        assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.test(TypicalFilters.FILTERABLE_C));
        // EP 5: null
        assertThrows(NullPointerException.class, () -> TypicalFilters.EXCLUSIVE_FILTERSET_A.test(null));
    }
}

```


Overlapping Code:
```
SetTest {
@Test
public void constructor_null_throwsNullPointerException() {
assertThrows(NullPointerException.class, () -> new ExclusiveFilterSet<String>(null));
}
@Test
public void hasAny() {
// EP 1: Fully contains
assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));
assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_A));
assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_B));
// EP 2: Partially contains
assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));
assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_AB));
// EP 3: Disjoint
assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_B));
assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAny(TypicalFilters.EXCLUSIVE_FILTERSET_A));
}
@Test
public void hasAll() {
// EP 1: Has All
assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_ABC));
assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB));
assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_ABC.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_A));
assertTrue(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_B));
// EP 2: Has Some
assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_AB.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AC));
assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_AB));
// EP 3: Disjoint
assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_A.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_B));
assertFalse(TypicalFilters.EXCLUSIVE_FILTERSET_B.hasAll(TypicalFilters.EXCLUSIVE_FILTERSET_A));
}
@Test
public void add() {
FilterSet<String> filterSet = new ExclusiveFilterSet<>();
// EP 1: Empty
filterSet.add(TypicalFilters.FILTER_A);
assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_A, filterSet);
// EP 2: Not Empty
filterSet.add(TypicalFilters.FILTER_B);
assertEquals(TypicalFilters.EXCLUSIVE_FILTERSET_AB, filterSet);
filterSet.add(TypicalFilters.FILTER_C);
ass
```
<Overlap Ratio: 0.9836586472991375>

---

--- 379 --
Question ID: 75e7aff9329d69de6955705804c709b35b64974f
Original Code:
```
public class ZookeeperWatcher {

    private static final Logger LOG = LoggerFactory.getLogger(ZookeeperWatcher.class);

    private static final String yuzhouwan4 = "yuzhouwan04:2181";

    private static final String zNode = "/yuzhouwan";

    {
        init();
    }

    public void init() {
        RetryPolicy retrypolicy = new ExponentialBackoffRetry(3000, 60);
        CuratorFramework curatorClient;
        /**
         * using fluent api
         */
        // root path: /watcher
        curatorClient = // root path: /watcher
        CuratorFrameworkFactory.builder().connectString(yuzhouwan4).sessionTimeoutMs(5000).connectionTimeoutMs(3000).retryPolicy(retrypolicy).namespace("watcher").build();
        curatorClient.start();
        final PathChildrenCache cached = new PathChildrenCache(curatorClient, zNode, true);
        cached.getListenable().addListener((client, event) -> {
            PathChildrenCacheEvent.Type childrenEventType = event.getType();
            if (childrenEventType != null) {
                switch(childrenEventType) {
                    case CONNECTION_RECONNECTED:
                        cached.rebuild();
                        break;
                    case CONNECTION_SUSPENDED:
                    case CONNECTION_LOST:
                        LOG.error("Connection error, waiting...");
                        break;
                    default:
                        LOG.info("PathChildrenCache changed : {path:" + event.getData().getPath() + " data:" + new String(event.getData().getData()) + "}");
                }
            }
        });
        try {
            cached.start();
        } catch (Exception e) {
            LOG.error("Can not start PathChildrenCache!!");
            throw new RuntimeException(e);
        }
    }
}

```


Overlapping Code:
```
class ZookeeperWatcher {
private static final Logger LOG = LoggerFactory.getLogger(ZookeeperWatcher.class);
private static final String yuzhouwan4 = "yuzhouwan04:2181";
private static final String zNode = "/yuzhouwan";
{
init();
}
public void init() {
RetryPolicy retrypolicy = new ExponentialBackoffRetry(3000, 6renCache cached = new PathChildrenCache(curatorClient, zNode, true);
cached.getListenable().addListener((client, event) -> {
PathChildrenCacheEvent.Type childrenEventType = event.getType();
if (childr{
case CONNECTION_RECONNECTED:
cached.rebuild();
break;
case CONNECTION_SUSPENDED:
case CONNECTION_LOST:
LOG.error("Connection error, waiting...");
break;
default:
LOG.info("PathChildrenCache changed  new String(event.getData().getData()) + "}");
}
}
});
try {
cached.start();
} catch (Exception e) {
LOG.error("Can not start PathChildrenCache!!");
t
```
<Overlap Ratio: 0.6488721804511278>

---

--- 380 --
Question ID: 48e6cf123eb4cbfdcdfdd0e229d4bb6928328e8c
Original Code:
```
@Service
@Transactional
public class CommonFloatService {

    private final Logger log = LoggerFactory.getLogger(CommonFloatService.class);

    private final CommonFloatRepository commonFloatRepository;

    private final CacheManager cacheManager;

    private final CommonFloatMapper commonFloatMapper;

    public CommonFloatService(CommonFloatRepository commonFloatRepository, CacheManager cacheManager, CommonFloatMapper commonFloatMapper) {
        this.commonFloatRepository = commonFloatRepository;
        this.cacheManager = cacheManager;
        this.commonFloatMapper = commonFloatMapper;
    }

    /**
     * Save a commonFloat.
     *
     * @param commonFloatDTO the entity to save.
     * @return the persisted entity.
     */
    public CommonFloatDTO save(CommonFloatDTO commonFloatDTO) {
        log.debug("Request to save CommonFloat : {}", commonFloatDTO);
        CommonFloat commonFloat = commonFloatMapper.toEntity(commonFloatDTO);
        commonFloat = commonFloatRepository.save(commonFloat);
        return commonFloatMapper.toDto(commonFloat);
    }

    /**
     * Get all the commonFloats.
     *
     * @param pageable the pagination information.
     * @return the list of entities.
     */
    @Transactional(readOnly = true)
    public Page<CommonFloatDTO> findAll(Pageable pageable) {
        log.debug("Request to get all CommonFloats");
        return commonFloatRepository.findAll(pageable).map(commonFloatMapper::toDto);
    }

    /**
     * count all the commonFloats.
     *
     * @return the count of entities
     * by wangxin
     */
    @Transactional(readOnly = true)
    public long count() {
        log.debug("Request to count all CommonFloats");
        return commonFloatRepository.count();
    }

    /**
     * Get one commonFloat by id.
     *
     * @param id the id of the entity.
     * @return the entity.
     */
    @Transactional(readOnly = true)
    public Optional<CommonFloatDTO> findOne(Long id) {
        log.debug("Request to get CommonFloat : {}", id);
        return commonFloatRepository.findById(id).map(commonFloatMapper::toDto);
    }

    /**
     * Delete the commonFloat by id.
     *
     * @param id the id of the entity.
     */
    public void delete(Long id) {
        log.debug("Request to delete CommonFloat : {}", id);
        commonFloatRepository.deleteById(id);
    }

    /**
     * Update specified fields by commonFloat
     */
    public CommonFloatDTO updateBySpecifiedFields(CommonFloatDTO changeCommonFloatDTO, Set<String> unchangedFields) {
        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();
        BeanUtil.copyProperties(changeCommonFloatDTO, commonFloatDTO, unchangedFields.toArray(new String[0]));
        commonFloatDTO = save(commonFloatDTO);
        return commonFloatDTO;
    }

    /**
     * Update specified field by commonFloat
     */
    public CommonFloatDTO updateBySpecifiedField(CommonFloatDTO changeCommonFloatDTO, String fieldName) {
        CommonFloatDTO commonFloatDTO = findOne(changeCommonFloatDTO.getId()).get();
        BeanUtil.setFieldValue(commonFloatDTO, fieldName, BeanUtil.getFieldValue(changeCommonFloatDTO, fieldName));
        commonFloatDTO = save(commonFloatDTO);
        return commonFloatDTO;
    }
}

```


Overlapping Code:
```
mmonFloatService {
private final Logger log = LoggerFactory.getLogger(CommonFloatService.class);
private final CommonFloatRepository commonFloatRepository;
private final CacheManager cacheManager;
private final CommonFloatMapper commonFloatMapper;
public CommonFloatService(CommonFloatRepository commonFloatRepository, CacheManager cacheManager, CommonFloatMapper commonFloatMapper) {
this.commonFloatRepository = commonFloatRepository;
this.cacheManager = cacheManager;
this.commonFloatMapper = commonFloatMapper;
}
/**
* Save a commonFloat.
*
* @param commonFloatDTO the entity to save.
* @return the persisted entity.
*/
public CommonFloatDTO save(CommonFloatDTO commonFloatDTO) {
log.debug("Request to save CommonFloat : {}", commonFloatDTO);
CommonFloat commonFloat = commonFloatMapper.toEntity(commonFloatDTO);
commonFloat = commonFloatRepository.save(commonFloat);
return commonFloatMapper.toDto(commonFloat);
}
/**
* Get all the commonFloats.
*
* @param pageable the pagination information.
* @return the list of entities.
*/
@Transactional(readOnly = true)
public Page<CommonFloatDTO> findAll(Pageable pageable) {
log.debug("Request to get all CommonFloats");
return commonFloatRepository.fi/**
* count all the commonFloats.
*
* @return the count of entities
* by wangxin
*/
@Transactional(readOnly = true)
public long count() {
log.debug("Request to count all CommonFloats");
return commonFloatRepository.count();
}
/**
* Get one commonFloat by id.
*
* @param id the id of the entity.
* @return the entity.
*/
@Transactional(readOnly = true)
public Optional<CommonFloatDTO> findOne(Long id) {
log.debug("Request to get CommonFloat : {}", idcommonFloatMapper::toDto);
}
/**
* Delete the commonFloat by id.
*
* @param id the id of the entity.
*/
public void delete(Long id) {
log.debug("Request to delete CommonFloat : {}", id);
commonFloatRepository.deleteById(id);
}
/**
* Update specified fields by commonFloat
*/
public CommonFloatDTO upd
```
<Overlap Ratio: 0.9137769447047798>

---

--- 381 --
Question ID: bbc956ee5ff3ca405fd0af54c93d59a6b745685b
Original Code:
```
@Service
public class ItemService {

    @Autowired
    private GmallPmsClient pmsClient;

    @Autowired
    private GmallSmsClient smsClient;

    @Autowired
    private GmallWmsClient wmsClient;

    @Autowired
    private ThreadPoolExecutor threadPoolExecutor;

    public ItemVO queryItemVO(Long skuId) {
        ItemVO itemVO = new ItemVO();
        CompletableFuture<SkuInfoEntity> completableFuture = CompletableFuture.supplyAsync(() -> {
            itemVO.setSkuId(skuId);
            Resp<SkuInfoEntity> skuInfoEntityResp = pmsClient.querySkuById(skuId);
            SkuInfoEntity skuInfoEntity = skuInfoEntityResp.getData();
            if (skuInfoEntity == null) {
                return null;
            }
            itemVO.setWeight(skuInfoEntity.getWeight());
            itemVO.setSkuTitle(skuInfoEntity.getSkuTitle());
            itemVO.setSkuSubtitle(skuInfoEntity.getSkuSubtitle());
            itemVO.setPrice(skuInfoEntity.getPrice());
            return skuInfoEntity;
        }, threadPoolExecutor);
        //thanApplyAsync: ???????
        CompletableFuture<Void> cateCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {
            Resp<CategoryEntity> categoryEntityResp = pmsClient.queryCategoryById1(skuInfoEntity.getCatalogId());
            CategoryEntity categoryEntity = categoryEntityResp.getData();
            if (categoryEntity != null) {
                itemVO.setCategoryId(categoryEntity.getCatId());
                itemVO.setCategoryName(categoryEntity.getName());
            }
        }, threadPoolExecutor);
        //??sku??brandID????
        CompletableFuture<Void> brandCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {
            Resp<BrandEntity> brandEntityResp = pmsClient.queryBrandById(skuInfoEntity.getBrandId());
            BrandEntity brandEntity = brandEntityResp.getData();
            if (brandEntity != null) {
                itemVO.setBrandId(brandEntity.getBrandId());
                itemVO.setBrandName(brandEntity.getName());
            }
        }, threadPoolExecutor);
        //??sku??spu??spu
        CompletableFuture<Void> spuCompletable = completableFuture.thenAcceptAsync(skuInfoEntity -> {
            Resp<SpuInfoEntity> spuInfoEntityResp = pmsClient.querySpuById(skuInfoEntity.getSpuId());
            SpuInfoEntity spuInfoEntity = spuInfoEntityResp.getData();
            if (skuInfoEntity != null) {
                itemVO.setSpuId(spuInfoEntity.getId());
                itemVO.setSpuName(spuInfoEntity.getSpuName());
            }
        }, threadPoolExecutor);
        //??sku????????
        CompletableFuture<Void> imagesCompletableFuture = CompletableFuture.runAsync(() -> {
            Resp<List<SkuImagesEntity>> queryImagesBySkuId = pmsClient.queryImagesBySkuId(skuId);
            List<SkuImagesEntity> imagesEntities = queryImagesBySkuId.getData();
            if (!CollectionUtils.isEmpty(imagesEntities)) {
                itemVO.setImeges(imagesEntities);
            }
        }, threadPoolExecutor);
        //??skuid????
        CompletableFuture<Void> skuCompletableFuture = CompletableFuture.runAsync(() -> {
            Resp<List<WareSkuEntity>> listResp = wmsClient.querySkuBySpuId(skuId);
            List<WareSkuEntity> wareSkuEntities = listResp.getData();
            if (!CollectionUtils.isEmpty(wareSkuEntities)) {
                itemVO.setStore(wareSkuEntities.stream().anyMatch(wareSkuEntity -> wareSkuEntity.getStock() > 0));
            }
        }, threadPoolExecutor);
        //??skuid??????3?
        CompletableFuture<Void> saleCompletableFuture = CompletableFuture.runAsync(() -> {
            Resp<List<ItemSaleVO>> listResp1 = this.smsClient.querySaleVoBySkuId(skuId);
            List<ItemSaleVO> itemSaleVOList = listResp1.getData();
            itemVO.setSales(itemSaleVOList);
        }, threadPoolExecutor);
        //??sku??spuID??????
        CompletableFuture<Void> descCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {
            Resp<SpuInfoDescEntity> spuInfoDescEntityResp = pmsClient.querySpuDescBySpuId(skuInfoEntity.getSpuId());
            SpuInfoDescEntity spuInfoDescEntity = spuInfoDescEntityResp.getData();
            if (spuInfoDescEntity != null && StringUtils.isNotBlank(spuInfoDescEntity.getDecript())) {
                itemVO.setDesc(Arrays.asList(StringUtils.split(spuInfoDescEntity.getDecript(), ",")));
            }
        }, threadPoolExecutor);
        CompletableFuture<Void> groupCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {
            Resp<List<ItemGroupVO>> listResp2 = this.pmsClient.queryItemGroupVOsByCidAndSpuId(skuInfoEntity.getCatalogId(), skuInfoEntity.getSpuId());
            List<ItemGroupVO> itemGroupVOS = listResp2.getData();
            itemVO.setGroupVOS(itemGroupVOS);
        }, threadPoolExecutor);
        //??skuIds??????
        CompletableFuture<Void> attrValueCompletableFuture = completableFuture.thenAcceptAsync(skuInfoEntity -> {
            Resp<List<SkuSaleAttrValueEntity>> listResp3 = pmsClient.querySaleAttrValueBySpuId(skuInfoEntity.getSpuId());
            List<SkuSaleAttrValueEntity> skuSaleAttrValueEntities = listResp3.getData();
            itemVO.setSaleAttrs(skuSaleAttrValueEntities);
        }, threadPoolExecutor);
        CompletableFuture.allOf(completableFuture, cateCompletablbe, brandCompletablbe, spuCompletable, imagesCompletableFuture, skuCompletableFuture, saleCompletableFuture, descCompletableFuture, groupCompletableFuture, attrValueCompletableFuture).join();
        return itemVO;
    }
}

```


Overlapping Code:
```
@Service
public class ItemService {
@Autowired
private GmallPmsClient pmsClient;
@Autowired
private GmallSmsClient smsClient;
@Autowired
private GmallWmsClient wmsClient;
@Autowired
private ThreadPoolExecutor threadPoolExecutor;
public ItemVO queryItemVO(Long skuId) {
ItemVO itemVO = new ItemVO();
CompletableFuture<SkuInfoEntity> completableFuture = CompletableFuture.supplyAsync(() -> {
itemVO.setSkuId(skuId);
Resp<SkuInfoEntity> skuInfoEntityResp = pmsClient.querySkuById(skuId);
SkuInfoEntity skuInfoEntity = skuInfoEntityResp.getData();
if (skuInfoEntity == null) {
return null;
}
itemVO.setWeight(skuInfoEntity.getWeight());
itemVO.setSkuTitle(skuInfoEntity.getSkuTitle());
itemVO.setSkuSubtitle(skuInfoEntity.getSkuSubtitle());
itemVO.setPrice(skuInfoEntity.getPrice());
return skuInfoEntity;
}, threadPoolblbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {
Resp<CategoryEntity> categoryEntityResp = pmsClient.queryCategoryById1(skuInfoEntity.getCatalogId());
CategoryEntity categoryEntity = categoryEntityResp.getData();
if (categoryEntity != null) {
itemVO.setCategoryId(categoryEntity.getCatId());
itemVO.setCategoryName(categoryEntity.getName());
}
}, threompletableFuture<Void> brandCompletablbe = completableFuture.thenAcceptAsync(skuInfoEntity -> {
Resp<BrandEntity> brandEntityResp = pmsClient.queryBrandById(skuInfoEntity.getBrandId());
BrandEntity brandEntity = brandEntityResp.getData();
if (brandEntity != null) {
itemVO.setBrandId(brandEntity.getBrandId());
itemVO.setBrandName(brandEntity.getName());
}
}, threadPoolExecutor);
//tableFuture<Void> spuCompletable = completableFuture.thenAcceptAsync(skuInfoEntity -> {
Resp<SpuInfoEntity> spuInfoEntityResp = pmsClient.querySpuById(skuInfoEntity.getSpuId());
SpuInfoEntity spuInfoEntity = spuInfoEntityResp.getData();
if (skuInfoEntity != null) {
itemVO.setSpuId(spuInfoEntity.getId());
itemV
```
<Overlap Ratio: 0.9327018943170489>

---

--- 382 --
Question ID: 4e80fb61037a20340836b0ea84f7505d3b249026
Original Code:
```
public class Perspective {

    public static final int LOCAL_COORD_BITS = 7;

    public static final int LOCAL_HALF_TILE_SIZE = 64;

    public static final int LOCAL_TILE_SIZE = 128;

    public static final int SCENE_SIZE = 104;

    public static final double UNIT = Math.PI / 1024d;

    // sine angles for each of the 2048 units, * 65536 and stored as an int
    public static final int[] SINE = new int[2048];

    // cosine
    public static final int[] COSINE = new int[2048];

    static {
        int i = 0;
        while (i < 2048) try {
            SINE[i] = (int) (65536.0D * Math.sin((double) i * UNIT));
            COSINE[i] = (int) (65536.0D * Math.cos((double) i * UNIT));
        } finally {
            ++i;
        }
    }

    public static Point getCanvasTextLocation(@Nonnull Client client, @Nonnull LocalPoint localPoint, String string, int plane, int n) {
        if (string == null) {
            return null;
        }
        Point p = Perspective.localToCanvas(client, localPoint, plane, n);
        if (p == null) {
            return null;
        } else {
            Log.e("Perspective", p.toString());
        }
        return new Point(p.getX(), p.getY());
    }

    public static Path getCanvasTileAreaPoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {
        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, n, 0);
    }

    public static Path getCanvasTileAreaPoly(@Nonnull Client client, @Nonnull LocalPoint localPoint, int n, int n2) {
        int n3 = client.getPlane();
        int n4 = localPoint.getX() - n * 128 / 2;
        int n5 = localPoint.getY() - n * 128 / 2;
        int n6 = localPoint.getX() + n * 128 / 2;
        int n7 = localPoint.getY() + n * 128 / 2;
        byte[][][] tileSettings = client.getTileSettings();
        int n8 = localPoint.getSceneX();
        int n9 = localPoint.getSceneY();
        if (n8 >= 0 && n9 >= 0 && n8 < 104 && n9 < 104) {
            int n10;
            n = n10 = n3;
            if (n3 < 3) {
                n = n10;
                if ((tileSettings[1][n8][n9] & 2) == 2) {
                    n = n3 + 1;
                }
            }
            n10 = Perspective.getHeight(client, n4, n5, n);
            n8 = Perspective.getHeight(client, n6, n5, n);
            n3 = Perspective.getHeight(client, n6, n7, n);
            n = Perspective.getHeight(client, n4, n7, n);
            Point p1 = Perspective.localToCanvas(client, n4, n5, n10 - n2);
            Point p2 = Perspective.localToCanvas(client, n6, n5, n8 - n2);
            Point p3 = Perspective.localToCanvas(client, n6, n7, n3 - n2);
            Point p4 = Perspective.localToCanvas(client, n4, n7, n - n2);
            if (p1 != null && p2 != null && p3 != null && p4 != null) {
                Path path = new Path();
                path.moveTo((float) ((Point) p1).getX(), (float) ((Point) p1).getY());
                path.lineTo((float) ((Point) p2).getX(), (float) ((Point) p2).getY());
                path.lineTo((float) p3.getX(), (float) p3.getY());
                path.lineTo((float) ((Point) p4).getX(), (float) ((Point) p4).getY());
                return path;
            }
            return null;
        }
        return null;
    }

    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint) {
        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1);
    }

    public static Path getCanvasTilePoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {
        return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, 1, n);
    }

    private static int getHeight(@Nonnull Client client, int localX, int localY, int plane) {
        int sceneX = localX >> LOCAL_COORD_BITS;
        int sceneY = localY >> LOCAL_COORD_BITS;
        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE) {
            int[][][] tileHeights = client.getTileHeights();
            int x = localX & (LOCAL_TILE_SIZE - 1);
            int y = localY & (LOCAL_TILE_SIZE - 1);
            int var8 = x * tileHeights[plane][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[plane][sceneX][sceneY] >> LOCAL_COORD_BITS;
            int var9 = tileHeights[plane][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[plane][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;
            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;
        }
        return 0;
    }

    public static int getTileHeight(@Nonnull Client client, @Nonnull LocalPoint point, int plane) {
        int sceneX = point.getSceneX();
        int sceneY = point.getSceneY();
        if (sceneX >= 0 && sceneY >= 0 && sceneX < SCENE_SIZE && sceneY < SCENE_SIZE) {
            byte[][][] tileSettings = client.getTileSettings();
            int[][][] tileHeights = client.getTileHeights();
            if (plane < 0)
                plane = 0;
            int z1 = plane;
            if (plane < Constants.MAX_Z - 1 && (tileSettings[1][sceneX][sceneY] & TILE_FLAG_BRIDGE) == TILE_FLAG_BRIDGE) {
                z1 = plane + 1;
            }
            int x = point.getX() & (LOCAL_TILE_SIZE - 1);
            int y = point.getY() & (LOCAL_TILE_SIZE - 1);
            int var8 = x * tileHeights[z1][sceneX + 1][sceneY] + (LOCAL_TILE_SIZE - x) * tileHeights[z1][sceneX][sceneY] >> LOCAL_COORD_BITS;
            int var9 = tileHeights[z1][sceneX][sceneY + 1] * (LOCAL_TILE_SIZE - x) + x * tileHeights[z1][sceneX + 1][sceneY + 1] >> LOCAL_COORD_BITS;
            return (LOCAL_TILE_SIZE - y) * var8 + y * var9 >> LOCAL_COORD_BITS;
        }
        return 0;
    }

    public static Point localToCanvas(@Nonnull Client client, int x, int y, int z) {
        if (x >= 128 && y >= 128 && x <= 13056 && y <= 13056) {
            x -= client.getCameraX();
            y -= client.getCameraY();
            z -= client.getCameraZ();
            int cameraPitch = client.getCameraPitch();
            int cameraYaw = client.getCameraYaw();
            int pitchSin = SINE[cameraPitch];
            int pitchCos = COSINE[cameraPitch];
            int yawSin = SINE[cameraYaw];
            int yawCos = COSINE[cameraYaw];
            int var8 = yawCos * x + y * yawSin >> 16;
            y = yawCos * y - yawSin * x >> 16;
            x = var8;
            var8 = pitchCos * z - y * pitchSin >> 16;
            y = z * pitchSin + y * pitchCos >> 16;
            if (y >= 50) {
                Log.e("Points", "x:" + x + " y:" + y);
                double pointX = (double) (client.getViewportWidth() / 2 + x * client.getCameraZoom() / y) * (double) client.getOverlayWidth() / (double) client.getViewportWidth();
                double pointY = (double) (client.getViewportHeight() / 2 + var8 * client.getCameraZoom() / y) * (double) client.getOverlayWidth() / (double) client.getViewportWidth();
                return new Point((int) pointX, (int) pointY);
            }
        }
        return null;
    }

    public static Point localToCanvas(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n, int n2) {
        n = Perspective.getTileHeight(clientAPI, localPoint, n);
        return Perspective.localToCanvas(clientAPI, localPoint.getX(), localPoint.getY(), n - n2);
    }
}

```


Overlapping Code:
```

public static final int LOCAL_COORD_BITS = 7;
public static final int LOCAL_HALF_TILE_SIZE = 64;
public static final int LOCAL_TILE_SIZE = 128;
public static final int SCENE_SIZE = 104;
public static final de angles for each of the 2048 units, * 65536 and stored as an int
public static final int[{
SINE[i] = (int) (65536.0D * Math.sin((double) i * UNIT));
COSINE[i] = (int) (65536.0D * Math.cos((doublevasTextLocation(@Nonnull Client client, @Nonnull LocalPoint localPoint, String string, int plane, int n) {
if (string == null) {
return null;
}
Point p = Perspective.localToCanvas(client, localPoint, Log.e("Perspective", p.toString());
}
return new Point(p.getX(), p.getY());
}
public static Path getCanvasTileAreaPoly(@Nonnull Client clientAPI, @Nonnull LocalPoint localPoint, int n) {
return Perspective.getCanvasTileAreaPoly(clientAPI, localPoint, n, 0);
}
public static Path getCanvasTileAreaPoly(@Nonnull Client client, @Nonnull LocalPoint localPoint, int n, int n2) {
int n3 = client.getPlane();
int n4 = localPoint.getX() - n * 128 / 2;
int n5 = localPoint.getY() - n * 128 / 2;
int n6 = localPoint.getX() + n * 128 / 2;
int n7 = localPoint.getY() + n * 128 / 2;
byte[][][] tileSettings = client.getTileSettings();
int n8 = localPoint.getSceneX();
int n9 = localPoint.getSceneY();
if (n8 >= 0 && n9 >= 0 && n8 < 104 && n9 < 104) {
int n10;
n = n10 = n3;
if (n3 < 3) {
n = n10;
if ((tileSettings[1][n8][n9] & 2) == 2) {
n = n3 + 1;
}
}
n10 = Perspective.getHeight(client, n4, n5, n);
n8 = Perspective.getHeight(client, n6, n5, n);
n3 = Perspective.getHeight(client, n6, n7, n);
n = Perspective.getHeight(client, n4, n7, n);
Point p1 = Perspecti
```
<Overlap Ratio: 0.8290726817042606>

---

--- 383 --
Question ID: 89a1a2463b6876a99f9253a15a2bbf7c892f989a
Original Code:
```
public class JavaDebugImages {

    //$NON-NLS-1$
    private static String ICONS_PATH = "$nl$/icons/full/";

    // The plugin registry
    private static ImageRegistry fgImageRegistry = null;

    //$NON-NLS-1$
    public static final String IMG_OBJS_EXCEPTION = "IMG_OBJS_EXCEPTION";

    //$NON-NLS-1$
    public static final String IMG_OBJS_EXCEPTION_DISABLED = "IMG_OBJS_EXCEPTION_DISABLED";

    //$NON-NLS-1$
    public static final String IMG_OBJS_ERROR = "IMG_OBJS_ERROR";

    //$NON-NLS-1$
    public static final String IMG_OVR_BREAKPOINT_INSTALLED = "IMG_OBJS_BREAKPOINT_INSTALLED";

    //$NON-NLS-1$
    public static final String IMG_OVR_BREAKPOINT_INSTALLED_DISABLED = "IMG_OBJS_BREAKPOINT_INSTALLED_DISABLED";

    //$NON-NLS-1$
    public static final String IMG_OBJS_LOCAL_VARIABLE = "IMG_OBJS_LOCAL_VARIABLE";

    //$NON-NLS-1$
    public static final String IMG_OBJS_METHOD_RESULT = "IMG_OBJS_METHOD_RESULT";

    //$NON-NLS-1$
    public static final String IMG_OBJS_METHOD_RESULT_DISABLED = "IMG_OBJS_METHOD_RESULT_DISABLED";

    //$NON-NLS-1$
    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY = "IMG_OBJS_METHOD_BREAKPOINT_ENTRY";

    //$NON-NLS-1$
    public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED = "IMG_OBJS_METHOD_BREAKPOINT_ENTRY_DISABLED";

    //$NON-NLS-1$
    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT = "IMG_OBJS_METHOD_BREAKPOINT_EXIT";

    //$NON-NLS-1$
    public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED = "IMG_OBJS_METHOD_BREAKPOINT_EXIT_DISABLED";

    //$NON-NLS-1$
    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT = "IMG_OBJS_CONDITIONAL_BREAKPOINT";

    //$NON-NLS-1$
    public static final String IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED = "IMG_OBJS_CONDITIONAL_BREAKPOINT_DISABLED";

    //$NON-NLS-1$
    public static final String IMG_OVR_SCOPED_BREAKPOINT = "IMG_OBJS_SCOPED_BREAKPOINT";

    //$NON-NLS-1$
    public static final String IMG_OVR_SCOPED_BREAKPOINT_DISABLED = "IMG_OBJS_SCOPED_BREAKPOINT_DISABLED";

    //$NON-NLS-1$
    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT = "IMG_OBJS_UNCAUGHT_BREAKPOINT";

    //$NON-NLS-1$
    public static final String IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED = "IMG_OBJS_UNCAUGHT_BREAKPOINT_DISABLED";

    //$NON-NLS-1$
    public static final String IMG_OVR_CAUGHT_BREAKPOINT = "IMG_OBJS_CAUGHT_BREAKPOINT";

    //$NON-NLS-1$
    public static final String IMG_OVR_CAUGHT_BREAKPOINT_DISABLED = "IMG_OBJS_CAUGHT_BREAKPOINT_DISABLED";

    //$NON-NLS-1$
    public static final String IMG_OBJS_SNIPPET_EVALUATING = "IMG_OBJS_SNIPPET_EVALUATING";

    //$NON-NLS-1$
    public static final String IMG_VIEW_ARGUMENTS_TAB = "IMG_VIEW_ARGUMENTS_TAB";

    //$NON-NLS-1$
    public static final String IMG_OBJS_MONITOR = "IMG_OBJS_MONITOR";

    //$NON-NLS-1$
    public static final String IMG_OBJS_CONTENDED_MONITOR = "IMG_OBJS_CONTENDED_MONITOR";

    //$NON-NLS-1$
    public static final String IMG_OBJS_OWNED_MONITOR = "IMG_OBJS_OWNED_MONITOR";

    //$NON-NLS-1$
    public static final String IMG_OBJS_REFERENCE = "IMG_OBJS_REFERENCE";

    //$NON-NLS-1$
    public static final String IMG_OVR_OWNED = "IMG_OVR_OWNED";

    //$NON-NLS-1$
    public static final String IMG_OVR_OWNS_MONITOR = "IMG_OVR_OWNS_MONITOR";

    //$NON-NLS-1$
    public static final String IMG_OVR_IN_CONTENTION = "IMG_OVR_IN_CONTENTION";

    //$NON-NLS-1$
    public static final String IMG_OVR_IN_CONTENTION_FOR_MONITOR = "IMG_OVR_IN_CONTENTION_FOR_MONITOR";

    //$NON-NLS-1$
    public static final String IMG_OVR_IN_DEADLOCK = "IMG_OVR_IN_DEADLOCK";

    //$NON-NLS-1$
    public static final String IMG_OBJS_EXCEPTION_BRKPT_TYPE = "IMG_OBJS_EXCEPTION_BRKPT_TYPE";

    //$NON-NLS-1$
    public static final String IMG_OBJS_LINE_BRKPT_TYPE = "IMG_OBJS_LINE_BRKPT_TYPE";

    //$NON-NLS-1$
    public static final String IMG_OBJS_CLASSLOAD_BRKPT_TYPE = "IMG_OBJS_CLASSLOAD_BRKPT_TYPE";

    //$NON-NLS-1$
    public static final String IMG_OBJS_WATCHPOINT_TYPE = "IMG_OBJS_WATCHPOINT_TYPE";

    //$NON-NLS-1$
    public static final String IMG_OBJS_JSP_BRKPT_TYPE = "IMG_OBJS_JSP_BRKPT_TYPE";

    //$NON-NLS-1$
    public static final String IMG_OBJS_METHOD_BRKPT_TYPE = "IMG_OBJS_METHOD_BRKPT_TYPE";

    //$NON-NLS-1$
    public static final String IMG_OBJS_THREAD_GROUP = "IMG_OBJS_THREAD_GROUP";

    //$NON-NLS-1$
    public static final String IMG_OBJS_CLASSPATH = "IMG_OBJS_CLASSPATH";

    //$NON-NLS-1$
    public static final String IMG_OVR_OUT_OF_SYNCH = "IMG_OVR_OUT_OF_SYNCH";

    //$NON-NLS-1$
    public static final String IMG_OVR_MAY_BE_OUT_OF_SYNCH = "IMG_OVR_MAY_BE_OUT_OF_SYNCH";

    //$NON-NLS-1$
    public static final String IMG_OVR_SYNCHRONIZED = "IMG_OVR_SYNCHRONIZED";

    //$NON-NLS-1$
    public static final String IMG_WIZBAN_NEWSCRAPPAGE = "IMG_WIZBAN_NEWSCRAPPAGE";

    //$NON-NLS-1$
    public static final String IMG_WIZBAN_LIBRARY = "IMG_WIZBAN_LIBRARY";

    //$NON-NLS-1$
    public static final String IMG_TOOL_TERMSNIPPET = "IMG_TOOL_TERMSNIPPET";

    //$NON-NLS-1$
    public static final String IMG_TOOL_TERMSNIPPET_HOVER = "IMG_TOOL_TERMSNIPPET_HOVER";

    //$NON-NLS-1$
    public static final String IMG_TOOL_TERMSNIPPET_DISABLED = "IMG_TOOL_TERMSNIPPET_DISABLED";

    //$NON-NLS-1$
    public static final String IMG_OBJ_JAVA_INSPECT_EXPRESSION = "IMG_OBJ_JAVA_INSPECT_EXPRESSION";

    //$NON-NLS-1$
    public static final String IMG_ELCL_AUTO_FORMAT = "IMG_ELCL_AUTO_FORMAT";

    //$NON-NLS-1$
    public static final String IMG_ELCL_ALL_REFERENCES = "IMG_ELCL_ALL_REFERENCES";

    //$NON-NLS-1$
    public static final String IMG_OVR_IN_TRIGGER_POINT = "IMG_OVR_IN_TRIGGER_POINT";

    //$NON-NLS-1$
    public static final String IMG_OVR_TRIGGER_SUPPRESSED = "IMG_OVR_TRIGGER_SUPPRESSED";

    //$NON-NLS-1$
    private static final String T_OBJ = ICONS_PATH + "obj16/";

    //$NON-NLS-1$
    private static final String T_OVR = ICONS_PATH + "ovr16/";

    //$NON-NLS-1$
    private static final String T_WIZBAN = ICONS_PATH + "wizban/";

    //$NON-NLS-1$
    private static final String T_EVIEW = ICONS_PATH + "eview16/";

    //$NON-NLS-1$
    private static final String T_DLCL = ICONS_PATH + "dtool16/";

    //$NON-NLS-1$
    private static final String T_ELCL = ICONS_PATH + "etool16/";

    //$NON-NLS-1$
    private static final String E_LCL = ICONS_PATH + "elcl16/";

    /**
     * Returns the image managed under the given key in this registry.
     *
     * @param key the image's key
     * @return the image managed under the given key
     */
    public static Image get(String key) {
        return getImageRegistry().get(key);
    }

    /**
     * Returns the <code>ImageDescriptor</code> identified by the given key,
     * or <code>null</code> if it does not exist.
     */
    public static ImageDescriptor getImageDescriptor(String key) {
        return getImageRegistry().getDescriptor(key);
    }

    /* package */
    static ImageRegistry getImageRegistry() {
        if (fgImageRegistry == null) {
            initializeImageRegistry();
        }
        return fgImageRegistry;
    }

    private static void initializeImageRegistry() {
        fgImageRegistry = new ImageRegistry(JDIDebugUIPlugin.getStandardDisplay());
        declareImages();
    }

    private static void declareImages() {
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_EXCEPTION, T_OBJ + "jexception_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_EXCEPTION_DISABLED, T_OBJ + "jexceptiond_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED, T_OVR + "installed_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_BREAKPOINT_INSTALLED_DISABLED, T_OVR + "installed_ovr_disabled.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_REFERENCE, T_OBJ + "reference_obj.gif");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_LOCAL_VARIABLE, T_OBJ + "localvariable_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_METHOD_RESULT, T_OBJ + "methodresult_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_METHOD_RESULT_DISABLED, T_OBJ + "methodresult_obj_disabled.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY, T_OVR + "entry_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED, T_OVR + "entry_ovr_disabled.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT, T_OVR + "exit_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED, T_OVR + "exit_ovr_disabled.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT, T_OVR + "conditional_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED, T_OVR + "conditional_ovr_disabled.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT, T_OVR + "scoped_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_SCOPED_BREAKPOINT_DISABLED, T_OVR + "scoped_ovr_disabled.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT, T_OVR + "uncaught_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED, T_OVR + "uncaught_ovr_disabled.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT, T_OVR + "caught_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_CAUGHT_BREAKPOINT_DISABLED, T_OVR + "caught_ovr_disabled.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_ERROR, T_OBJ + "jrtexception_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_SNIPPET_EVALUATING, T_OBJ + "jsbook_run_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_VIEW_ARGUMENTS_TAB, T_EVIEW + "variable_tab.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_OUT_OF_SYNCH, T_OVR + "error_co.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_MAY_BE_OUT_OF_SYNCH, T_OVR + "warning_co.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_SYNCHRONIZED, T_OVR + "sync_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_MONITOR, T_OBJ + "monitor_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_OWNED, T_OVR + "owned_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_OWNS_MONITOR, T_OVR + "ownsmonitor_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_IN_CONTENTION, T_OVR + "contention_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_IN_CONTENTION_FOR_MONITOR, T_OVR + "contentionformonitor_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_IN_DEADLOCK, T_OVR + "deadlock_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_CONTENDED_MONITOR, T_OBJ + "contended_monitor_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_OWNED_MONITOR, T_OBJ + "owned_monitor_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_THREAD_GROUP, T_OBJ + "threadgroup_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_WIZBAN_NEWSCRAPPAGE, T_WIZBAN + "newsbook_wiz.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_WIZBAN_LIBRARY, T_WIZBAN + "library_wiz.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_TOOL_TERMSNIPPET, T_ELCL + "term_sbook.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_TOOL_TERMSNIPPET_HOVER, T_ELCL + "term_sbook.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_TOOL_TERMSNIPPET_DISABLED, T_DLCL + "term_sbook.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJ_JAVA_INSPECT_EXPRESSION, T_OBJ + "insp_sbook.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_CLASSPATH, T_OBJ + "classpath_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_EXCEPTION_BRKPT_TYPE, T_OBJ + "jexception_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_LINE_BRKPT_TYPE, T_OBJ + "jline_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_CLASSLOAD_BRKPT_TYPE, T_OBJ + "jload_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_METHOD_BRKPT_TYPE, T_OBJ + "jmeth_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_JSP_BRKPT_TYPE, T_OBJ + "jspbrkpt_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OBJS_WATCHPOINT_TYPE, T_OBJ + "jwatch_obj.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_ELCL_AUTO_FORMAT, E_LCL + "autoform_menu.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_ELCL_ALL_REFERENCES, E_LCL + "all_references.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_IN_TRIGGER_POINT, T_OVR + "trigger_ovr.png");
        //$NON-NLS-1$
        declareRegistryImage(IMG_OVR_TRIGGER_SUPPRESSED, T_OVR + "trigger_suppressed_ovr.png");
    }

    /**
     * Declare an Image in the registry table.
     * @param key   The key to use when registering the image
     * @param path  The path where the image can be found. This path is relative to where
     *              this plugin class is found (i.e. typically the packages directory)
     */
    private static final void declareRegistryImage(String key, String path) {
        ImageDescriptor desc = ImageDescriptor.getMissingImageDescriptor();
        Bundle bundle = Platform.getBundle(JDIDebugUIPlugin.getUniqueIdentifier());
        URL url = null;
        if (bundle != null) {
            url = FileLocator.find(bundle, new Path(path), null);
            if (url != null) {
                desc = ImageDescriptor.createFromURL(url);
            }
        }
        fgImageRegistry.put(key, desc);
    }
}

```


Overlapping Code:
```
-NLS-1$
private static String ICONS_PATH = "$nl$/icons/full/";
// The plugin registry
private static ImageRegistry fgImageRegistry = null;
//$NON-NLS-1$
public static final String IMG_OBJS_EXCEPTION = "IMG_OBJS_EXCEPTION";
//$NON-NLS-1$
public static final String IMG_OBJS_EXCEPTION_DISABLED = "IMG_OBJS_EXCEPTION_DISABLED";
//$NON-NLS-1$
public static final String IMG_OBJS_ERROR = "IMG_OBJS_ERROR";
//$NON-NLS-1$
public static final String IMG_OVR_BREAKPOINT_INSTALLED = "IMG_OBJS_BREAKPOINT_INSTALLED";
//$NON-NLS-1$
public static final String IMG_OVR_BREAKPOINT_INSTALLED_DISABLED = "IMG_OBJS_BREAKPOINT_INSTALLED_DISABLED";
//$NON-NLS-1$
public static final String IMG_OBJS_LOCAL_VARIABLE = "IMG_OBJS_LOCAL_VARIABLE";
//$NON-NLS-1$
public static final String IMG_OBJS_METHOD_RESULT = "IMG_OBJS_METHOD_RESULT";
//$NON-NLS-1$
public static final String IMG_OBJS_METHOD_RESULT_DISABLED = "IMG_OBJS_METHOD_RESULT_DISABLED";
//$NON-NLS-1$
public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY = "IMG_OBJS_METHOD_BREAKPOINT_ENTRY";
//$NON-NLS-1$
public static final String IMG_OVR_METHOD_BREAKPOINT_ENTRY_DISABLED = "IMG_OBJS_METHOD_BREAKPOINT_ENTRY_DISABLED";
//$NON-NLS-1$
public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT = "IMG_OBJS_METHOD_BREAKPOINT_EXIT";
//$NON-NLS-1$
public static final String IMG_OVR_METHOD_BREAKPOINT_EXIT_DISABLED = "IMG_OBJS_METHOD_BREAKPOINT_EXIT_DISABLED";
//$NON-NLS-1$
public static final String IMG_OVR_CONDITIONAL_BREAKPOINT = "IMG_OBJS_CONDITIONAL_BREAKPOINT";
//$NON-NLS-1$
public static final String IMG_OVR_CONDITIONAL_BREAKPOINT_DISABLED = "IMG_OBJS_CONDITIONAL_BREAKPOINT_DISABLED";
//$NON-NLS-1$
public static final String IMG_OVR_SCOPED_BREAKPOINT = "IMG_OBJS_SCOPED_BREAKPOINT";
//$NON-NLS-1$
public static final String IMG_OVR_SCOPED_BREAKPOINT_DISABLED = "IMG_OBJS_SCOPED_BREAKPOINT_DISABLED";
//$NON-NLS-1$
public static final String IMG_OVR_UNCAUGHT_BREAKPOINT = "IMG_OBJS_UNCAUGHT_BREAKPOINT";
//$NON-NLS-1$
public static final String IMG_OVR_UNCAUGHT_BREAKPOINT_DISABLED = "IMG_OBJS_UNCAUGHT_BREAKPOINT_DISABLED";
//$NON-NLS-1$
public static final String IMG_OVR_CAUGHT_BREAKPOINT = "IMG_OBJS_CAUGHT_BREAKPOINT";
//$NON-NLS-1$
public static final String IMG_OVR_C
```
<Overlap Ratio: 0.9674054758800521>

---

