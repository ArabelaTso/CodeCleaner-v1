{"hexsha": "07bea0dee804f4a3dd1cb8de837a2c6f9ce9c771", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef pretty_print_post(url: str):\n    try:\n        text = parse_post(url)\n    except api2ch.Api2chError as e:\n        print('Request Error', e.code, e.reason)\n    else:\n        print(text)", "fn_id": 1, "class_fn": false, "repo": "uburuntu/api2ch", "file": "examples/complex.py", "last_update_at": "2021-07-26T09:40:57+00:00", "original_content": "def pretty_print_post(url: str):\n    try:\n        text = parse_post(url)\n    except api2ch.Api2chError as e:\n        print('Request Error', e.code, e.reason)\n    else:\n        print(text)", "refactored": true, "pred": {"ppl": 7.687551498413086, "ppl_lower": 9.06020450592041, "ppl/lowercase_ppl": -1.0805497020286101, "ppl/zlib": 0.013507300212521604, "Min_5.0% Prob": 11.246746063232422, "Min_10.0% Prob": 9.519223292668661, "Min_20.0% Prob": 7.758267806126521, "Min_30.0% Prob": 6.084716403484345, "Min_40.0% Prob": 4.932328418449119, "Min_50.0% Prob": 4.039477966287556, "Min_60.0% Prob": 3.450038936175406}}
{"hexsha": "6c31f616e579c190b006f0e8ba4f595d892ad988", "ext": "py", "lang": "Python", "content": "@card('Braids, Cabal Minion')\ndef braids_cabal_minion(card, abilities):\n\n    @timeing\n    @measure_memory_usage\n    def braids_cabal_minion():\n        return AbilityNotImplemented\n    return (braids_cabal_minion,)", "fn_id": 28, "class_fn": false, "repo": "Julian/cardboard", "file": "cardboard/cards/sets/odyssey.py", "last_update_at": "2021-05-29T06:00:40+00:00", "original_content": "@card('Braids, Cabal Minion')\ndef braids_cabal_minion(card, abilities):\n\n    def braids_cabal_minion():\n        return AbilityNotImplemented\n    return (braids_cabal_minion,)", "refactored": true, "pred": {"ppl": 9.307662963867188, "ppl_lower": 14.561443328857422, "ppl/lowercase_ppl": -1.2006148025887464, "ppl/zlib": 0.016283489310130413, "Min_5.0% Prob": 14.134929339090982, "Min_10.0% Prob": 11.793504238128662, "Min_20.0% Prob": 8.87164280964778, "Min_30.0% Prob": 7.1574759232370475, "Min_40.0% Prob": 5.615102919248434, "Min_50.0% Prob": 4.453632997179573, "Min_60.0% Prob": 3.77333895327189}}
{"hexsha": "fc7e94a2224575fc9faaa120b95dfa7c40d2f253", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_extended_projection(ra_module):\n    initial_set = ra_module.NamedRelationalAlgebraFrozenSet(('x', 'y'), [(7, 8), (9, 2)])\n    expected_sum = ra_module.NamedRelationalAlgebraFrozenSet(('z',), [(15,), (11,)])\n    expected_lambda = ra_module.NamedRelationalAlgebraFrozenSet(('z',), [(14,), (10,)])\n    expected_lambda2 = ra_module.NamedRelationalAlgebraFrozenSet(('z', 'x'), [(14, 8), (10, 10)])\n    expected_new_colum_str = ra_module.NamedRelationalAlgebraFrozenSet(('x', 'z'), [(7, 'a'), (9, 'a')])\n    expected_new_colum_int = ra_module.NamedRelationalAlgebraFrozenSet(('z',), [(1,), (1,)])\n    new_set = initial_set.extended_projection({'z': sum})\n    assert expected_sum == new_set\n    new_set = initial_set.extended_projection({'z': ra_module.RelationalAlgebraStringExpression('x+y')})\n    assert expected_sum == new_set\n    new_set = initial_set.extended_projection({'z': lambda r: r.x + r.y - 1})\n    assert expected_lambda == new_set\n    new_set = initial_set.extended_projection({'z': lambda r: r.x + r.y - 1, 'x': ra_module.RelationalAlgebraStringExpression('x+1')})\n    assert expected_lambda2 == new_set\n    new_set = initial_set.extended_projection({'z': 'a', 'x': ra_module.RelationalAlgebraStringExpression('x')})\n    assert expected_new_colum_str == new_set\n    new_set = initial_set.extended_projection({'z': 1})\n    assert expected_new_colum_int == new_set\n    new_set = initial_set.extended_projection({'x': ra_module.RelationalAlgebraColumnStr('x')})\n    assert initial_set.projection('x') == new_set\n    base_set = ra_module.NamedRelationalAlgebraFrozenSet((1, 2), [(7, 8), (9, 2)])\n    new_set = base_set.extended_projection({'x': ra_module.RelationalAlgebraColumnInt(1), 'y': ra_module.RelationalAlgebraColumnInt(2)})\n    assert initial_set == new_set", "fn_id": 31, "class_fn": false, "repo": "demianw/NeuroLang", "file": "neurolang/utils/tests/test_relational_algebra_set.py", "last_update_at": "2021-07-02T09:06:30+00:00", "original_content": "def test_extended_projection(ra_module):\n    initial_set = ra_module.NamedRelationalAlgebraFrozenSet(('x', 'y'), [(7, 8), (9, 2)])\n    expected_sum = ra_module.NamedRelationalAlgebraFrozenSet(('z',), [(15,), (11,)])\n    expected_lambda = ra_module.NamedRelationalAlgebraFrozenSet(('z',), [(14,), (10,)])\n    expected_lambda2 = ra_module.NamedRelationalAlgebraFrozenSet(('z', 'x'), [(14, 8), (10, 10)])\n    expected_new_colum_str = ra_module.NamedRelationalAlgebraFrozenSet(('x', 'z'), [(7, 'a'), (9, 'a')])\n    expected_new_colum_int = ra_module.NamedRelationalAlgebraFrozenSet(('z',), [(1,), (1,)])\n    new_set = initial_set.extended_projection({'z': sum})\n    assert expected_sum == new_set\n    new_set = initial_set.extended_projection({'z': ra_module.RelationalAlgebraStringExpression('x+y')})\n    assert expected_sum == new_set\n    new_set = initial_set.extended_projection({'z': lambda r: r.x + r.y - 1})\n    assert expected_lambda == new_set\n    new_set = initial_set.extended_projection({'z': lambda r: r.x + r.y - 1, 'x': ra_module.RelationalAlgebraStringExpression('x+1')})\n    assert expected_lambda2 == new_set\n    new_set = initial_set.extended_projection({'z': 'a', 'x': ra_module.RelationalAlgebraStringExpression('x')})\n    assert expected_new_colum_str == new_set\n    new_set = initial_set.extended_projection({'z': 1})\n    assert expected_new_colum_int == new_set\n    new_set = initial_set.extended_projection({'x': ra_module.RelationalAlgebraColumnStr('x')})\n    assert initial_set.projection('x') == new_set\n    base_set = ra_module.NamedRelationalAlgebraFrozenSet((1, 2), [(7, 8), (9, 2)])\n    new_set = base_set.extended_projection({'x': ra_module.RelationalAlgebraColumnInt(1), 'y': ra_module.RelationalAlgebraColumnInt(2)})\n    assert initial_set == new_set", "refactored": true, "pred": {"ppl": 2.176560878753662, "ppl_lower": 2.332341194152832, "ppl/lowercase_ppl": -1.0888805731243438, "ppl/zlib": 0.0019346916730355725, "Min_5.0% Prob": 7.943558267184666, "Min_10.0% Prob": 6.010805130004883, "Min_20.0% Prob": 3.7573951129364755, "Min_30.0% Prob": 2.5789231985807417, "Min_40.0% Prob": 1.9457664906584744, "Min_50.0% Prob": 1.5575781327583762, "Min_60.0% Prob": 1.2976607055911287}}
{"hexsha": "b41186cab3d777d1b3f6deea4852d5203576ebc3", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef say(text):\n    hash = hashlib.md5(text.encode()).hexdigest()\n    file = 'speech-cache/{}.wav'.format(hash)\n    cmd = 'play {}'.format(file)\n    if not os.path.isfile(file):\n        cmd = 'pico2wave -w {} \"{}\" && {}'.format(file, text, cmd)\n    os.system(cmd)", "fn_id": 3, "class_fn": false, "repo": "yousefamar/sanctum", "file": "sanctum.py", "last_update_at": "2021-01-17T00:14:06+00:00", "original_content": "def say(text):\n    hash = hashlib.md5(text.encode()).hexdigest()\n    file = 'speech-cache/{}.wav'.format(hash)\n    cmd = 'play {}'.format(file)\n    if not os.path.isfile(file):\n        cmd = 'pico2wave -w {} \"{}\" && {}'.format(file, text, cmd)\n    os.system(cmd)", "refactored": true, "pred": {"ppl": 3.649374008178711, "ppl_lower": 3.649374008178711, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.006505304765212215, "Min_5.0% Prob": 9.723703145980835, "Min_10.0% Prob": 7.577635659111871, "Min_20.0% Prob": 5.575163791054173, "Min_30.0% Prob": 4.302363340343748, "Min_40.0% Prob": 3.254474972619822, "Min_50.0% Prob": 2.5860183655361957, "Min_60.0% Prob": 2.1797407861276152}}
{"hexsha": "efba18d12458eb11af1a1ce332ee1fe30fca6aa2", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef stft(sig, frameSize=FRAMESIZE, overlapFac=OVERLAP, window=np.hanning):\n    hop = int(frameSize - np.floor(overlapFac * frameSize))\n    w = np.sqrt(window(frameSize))\n    out = np.array([np.fft.rfft(w * sig[i:i + frameSize]) for i in range(0, len(sig) - frameSize, hop)])\n    out = np.abs(out)\n    out -= np.mean(out)\n    return out", "fn_id": 0, "class_fn": false, "repo": "glkuzi/CountMTS", "file": "DataGenerator.py", "last_update_at": "2021-07-22T03:45:54+00:00", "original_content": "def stft(sig, frameSize=FRAMESIZE, overlapFac=OVERLAP, window=np.hanning):\n    hop = int(frameSize - np.floor(overlapFac * frameSize))\n    w = np.sqrt(window(frameSize))\n    out = np.array([np.fft.rfft(w * sig[i:i + frameSize]) for i in range(0, len(sig) - frameSize, hop)])\n    out = np.abs(out)\n    out -= np.mean(out)\n    return out", "refactored": true, "pred": {"ppl": 2.6310102939605713, "ppl_lower": 2.776993751525879, "ppl/lowercase_ppl": -1.055822653211071, "ppl/zlib": 0.00411645921113312, "Min_5.0% Prob": 8.393463691075643, "Min_10.0% Prob": 6.365025023619334, "Min_20.0% Prob": 4.42528751373291, "Min_30.0% Prob": 3.1629197134783396, "Min_40.0% Prob": 2.4140381027086106, "Min_50.0% Prob": 1.943470494239591, "Min_60.0% Prob": 1.6195397289082796}}
{"hexsha": "3daf2b90efe24d08876eb33fa7e809886b79aacb", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef write_float_list():\n    global result\n    with open('result_shared_memory.txt', 'w') as f:\n        f.write(str(result))\n        f.close()", "fn_id": 7, "class_fn": false, "repo": "alansouls/interop-pysharp", "file": "proof_of_concept/python/text_transfer/connector_file.py", "last_update_at": "2021-05-22T22:37:44+00:00", "original_content": "def write_float_list():\n    global result\n    with open('result_shared_memory.txt', 'w') as f:\n        f.write(str(result))\n        f.close()", "refactored": true, "pred": {"ppl": 7.283885955810547, "ppl_lower": 7.283885955810547, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.015392748100269728, "Min_5.0% Prob": 11.038225173950195, "Min_10.0% Prob": 8.971581172943115, "Min_20.0% Prob": 7.254643154144287, "Min_30.0% Prob": 6.048995621999105, "Min_40.0% Prob": 4.908707669377327, "Min_50.0% Prob": 3.908915389042634, "Min_60.0% Prob": 3.3147625228570354}}
{"hexsha": "e13fa130c6f556d3b69fbf1da32dc9e4fc944723", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef report():\n    value = grp.value\n    try:\n        say(labels[value], 'selected')\n    except (TypeError, IndexError):\n        say('Value =', value)", "fn_id": 0, "class_fn": false, "repo": "gcewing/PyGUI", "file": "Tests/07-radiogroup.py", "last_update_at": "2021-11-24T19:50:02+00:00", "original_content": "def report():\n    value = grp.value\n    try:\n        say(labels[value], 'selected')\n    except (TypeError, IndexError):\n        say('Value =', value)", "refactored": true, "pred": {"ppl": 23.05365562438965, "ppl_lower": 28.46556282043457, "ppl/lowercase_ppl": -1.0672028318396125, "ppl/zlib": 0.022903827388948465, "Min_5.0% Prob": 15.147937774658203, "Min_10.0% Prob": 12.996138334274292, "Min_20.0% Prob": 10.38160620795356, "Min_30.0% Prob": 8.673551627567836, "Min_40.0% Prob": 7.551316565937466, "Min_50.0% Prob": 6.229396358780239, "Min_60.0% Prob": 5.219448987926755}}
{"hexsha": "d5c45875560e75035fb70d3ac4fa58d21599d27d", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_vsi_path_zip_plus_https():\n    \"\"\"A zip+https:// URLs vsi path is correct (see #1151)\"\"\"\n    url = 'zip+https://example.com/foo.zip!bar.tif'\n    assert vsi_path(parse_path(url)) == '/vsizip/vsicurl/https://example.com/foo.zip/bar.tif'", "fn_id": 16, "class_fn": false, "repo": "CloudNiner/rasterio", "file": "tests/test_path.py", "last_update_at": "2021-09-16T00:44:50+00:00", "original_content": "def test_vsi_path_zip_plus_https():\n    \"\"\"A zip+https:// URLs vsi path is correct (see #1151)\"\"\"\n    url = 'zip+https://example.com/foo.zip!bar.tif'\n    assert vsi_path(parse_path(url)) == '/vsizip/vsicurl/https://example.com/foo.zip/bar.tif'", "refactored": true, "pred": {"ppl": 6.428691387176514, "ppl_lower": 6.48480224609375, "ppl/lowercase_ppl": -1.0046702804819805, "ppl/zlib": 0.010058221625774941, "Min_5.0% Prob": 9.282826805114746, "Min_10.0% Prob": 8.294491291046143, "Min_20.0% Prob": 6.8320914030075075, "Min_30.0% Prob": 5.626288866996765, "Min_40.0% Prob": 4.505604573866216, "Min_50.0% Prob": 3.732982865151237, "Min_60.0% Prob": 3.1364683414824674}}
{"hexsha": "995e126c50514275c11a5e83f7c9eaa1aa63e240", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef timestamp_unpack(seconds, timedelta=datetime.timedelta, relative_to=pg_epoch_datetime.__add__):\n    \"\"\"\n\tCreate a `datetime.datetime` instance from a (seconds, microseconds) pair.\n\t\"\"\"\n    return relative_to(timedelta(0, *seconds))", "fn_id": 1, "class_fn": false, "repo": "autolog/TRV_Controller", "file": "TRV.indigoPlugin/Contents/Server Plugin/postgresql/types/io/stdlib_datetime.py", "last_update_at": "2021-02-03T16:31:26+00:00", "original_content": "def timestamp_unpack(seconds, timedelta=datetime.timedelta, relative_to=pg_epoch_datetime.__add__):\n    \"\"\"\n\tCreate a `datetime.datetime` instance from a (seconds, microseconds) pair.\n\t\"\"\"\n    return relative_to(timedelta(0, *seconds))", "refactored": true, "pred": {"ppl": 12.155335426330566, "ppl_lower": 13.474176406860352, "ppl/lowercase_ppl": -1.041239531985706, "ppl/zlib": 0.01452190815777007, "Min_5.0% Prob": 13.80172348022461, "Min_10.0% Prob": 10.808932304382324, "Min_20.0% Prob": 8.730544669287545, "Min_30.0% Prob": 7.087971297177401, "Min_40.0% Prob": 5.931591786187271, "Min_50.0% Prob": 4.894071347004658, "Min_60.0% Prob": 4.174741422249512}}
{"hexsha": "6f8e9b82a7e7f7ef2e5696e6e11a9da88873c108", "ext": "py", "lang": "Python", "content": "@app.route('/ext/<api_key>/new_session/<session_name>', methods=['POST'])\n@timeing\n@measure_memory_usage\ndef ext_create_new_session_name(api_key, session_name):\n    logging.debug('EXTERNAL: Create new Session with name')\n    db = Database()\n    user = db.get_user_by_api_key(api_key)\n    if user is None:\n        return (\"Provided API key ('{}') is not associated with any registered user\".format(api_key), HTTPStatus.UNAUTHORIZED.value)\n    if db.does_session_name_exist(session_name):\n        return (\"Provided session name ('{}') already exists\".format(session_name), HTTPStatus.UNAUTHORIZED.value)\n    logging.debug('Creating new session: %s (userid: %s)', session_name, user['user_id'])\n    session_id = db.create_session(session_name, user['user_id'])\n    logging.debug('New session id: %s', session_id)\n    set_current_session(session_id, session_name)\n    return \"New Session ID: '{}'\".format(session_id)", "fn_id": 2, "class_fn": false, "repo": "Samiasa/UsabilityConsole", "file": "console/routes/external.py", "last_update_at": "2021-06-07T17:15:42+00:00", "original_content": "@app.route('/ext/<api_key>/new_session/<session_name>', methods=['POST'])\ndef ext_create_new_session_name(api_key, session_name):\n    logging.debug('EXTERNAL: Create new Session with name')\n    db = Database()\n    user = db.get_user_by_api_key(api_key)\n    if user is None:\n        return (\"Provided API key ('{}') is not associated with any registered user\".format(api_key), HTTPStatus.UNAUTHORIZED.value)\n    if db.does_session_name_exist(session_name):\n        return (\"Provided session name ('{}') already exists\".format(session_name), HTTPStatus.UNAUTHORIZED.value)\n    logging.debug('Creating new session: %s (userid: %s)', session_name, user['user_id'])\n    session_id = db.create_session(session_name, user['user_id'])\n    logging.debug('New session id: %s', session_id)\n    set_current_session(session_id, session_name)\n    return \"New Session ID: '{}'\".format(session_id)", "refactored": true, "pred": {"ppl": 3.2076587677001953, "ppl_lower": 3.5978989601135254, "ppl/lowercase_ppl": -1.0985025037095506, "ppl/zlib": 0.0026855790672255866, "Min_5.0% Prob": 8.904146231137789, "Min_10.0% Prob": 7.23266678590041, "Min_20.0% Prob": 5.0505529282228006, "Min_30.0% Prob": 3.759464028515393, "Min_40.0% Prob": 2.884350446597585, "Min_50.0% Prob": 2.334251569273571, "Min_60.0% Prob": 1.9418788409598593}}
{"hexsha": "3b40f31f9e2306102a844f470092207c102189e3", "ext": "py", "lang": "Python", "content": "@pb.route('/detail/<id>', methods=['GET', 'POST'])\n@timeing\n@measure_memory_usage\ndef single_product(id):\n    product = Product.query.filter_by(id=id).first()\n    if product.out_of_stock == True:\n        status = 'Sold Out'\n    else:\n        status = 'In stock'\n    data = {'id': product.id, 'name': product.name, 'img_url': product.img_url, 'description': product.description, 'seller': User.query.filter_by(id=product.seller_id).first().name, 'seller_id': product.seller_id, 'created': product.created, 'price': product.price, 'status': status, 'seller_img': User.query.filter_by(id=product.seller_id).first().avatar_url}\n    return jsonify(data)", "fn_id": 3, "class_fn": false, "repo": "sori9088/mealplan-server", "file": "app/components/product/__init__.py", "last_update_at": "2021-06-02T00:44:12+00:00", "original_content": "@pb.route('/detail/<id>', methods=['GET', 'POST'])\ndef single_product(id):\n    product = Product.query.filter_by(id=id).first()\n    if product.out_of_stock == True:\n        status = 'Sold Out'\n    else:\n        status = 'In stock'\n    data = {'id': product.id, 'name': product.name, 'img_url': product.img_url, 'description': product.description, 'seller': User.query.filter_by(id=product.seller_id).first().name, 'seller_id': product.seller_id, 'created': product.created, 'price': product.price, 'status': status, 'seller_img': User.query.filter_by(id=product.seller_id).first().avatar_url}\n    return jsonify(data)", "refactored": true, "pred": {"ppl": 2.7360332012176514, "ppl_lower": 3.1037869453430176, "ppl/lowercase_ppl": -1.1252982434518801, "ppl/zlib": 0.0032156841362129336, "Min_5.0% Prob": 9.167449235916138, "Min_10.0% Prob": 7.324668526649475, "Min_20.0% Prob": 4.809322553873062, "Min_30.0% Prob": 3.349124362319708, "Min_40.0% Prob": 2.5325426929164676, "Min_50.0% Prob": 2.0112857748708217, "Min_60.0% Prob": 1.6799092259323456}}
{"hexsha": "fe240d6eafcfe9043656fc61dbcdc36afa2f5d4c", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_feature(internel_layer, layers, filters, batch_norm=False):\n    \"\"\"Get VGG feature body as stacks of convoltions.\"\"\"\n    for i, num in enumerate(layers):\n        for j in range(num):\n            internel_layer = sym.conv2d(data=internel_layer, kernel_size=(3, 3), padding=(1, 1), channels=filters[i], name='conv%s_%s' % (i + 1, j + 1))\n            if batch_norm:\n                internel_layer = sym.batch_norm(data=internel_layer, name='bn%s_%s' % (i + 1, j + 1))\n            internel_layer = sym.relu(data=internel_layer, name='relu%s_%s' % (i + 1, j + 1))\n        internel_layer = sym.max_pool2d(data=internel_layer, pool_size=(2, 2), strides=(2, 2), name='pool%s' % (i + 1))\n    return internel_layer", "fn_id": 0, "class_fn": false, "repo": "CynthiaProtector/helo", "file": "nnvm/python/nnvm/testing/vgg.py", "last_update_at": "2021-12-25T06:09:46+00:00", "original_content": "def get_feature(internel_layer, layers, filters, batch_norm=False):\n    \"\"\"Get VGG feature body as stacks of convoltions.\"\"\"\n    for i, num in enumerate(layers):\n        for j in range(num):\n            internel_layer = sym.conv2d(data=internel_layer, kernel_size=(3, 3), padding=(1, 1), channels=filters[i], name='conv%s_%s' % (i + 1, j + 1))\n            if batch_norm:\n                internel_layer = sym.batch_norm(data=internel_layer, name='bn%s_%s' % (i + 1, j + 1))\n            internel_layer = sym.relu(data=internel_layer, name='relu%s_%s' % (i + 1, j + 1))\n        internel_layer = sym.max_pool2d(data=internel_layer, pool_size=(2, 2), strides=(2, 2), name='pool%s' % (i + 1))\n    return internel_layer", "refactored": true, "pred": {"ppl": 2.3526980876922607, "ppl_lower": 2.459120273590088, "ppl/lowercase_ppl": -1.0517096840212907, "ppl/zlib": 0.002673633724968135, "Min_5.0% Prob": 9.358761860774113, "Min_10.0% Prob": 6.817171252690828, "Min_20.0% Prob": 4.174638751607675, "Min_30.0% Prob": 2.8528486002141085, "Min_40.0% Prob": 2.1455467581981793, "Min_50.0% Prob": 1.71753021136571, "Min_60.0% Prob": 1.4314021383342594}}
{"hexsha": "d1b6df0cf562b4a74a407607abec54818df78080", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef mech():\n    item = {0: 'mail', 1: 'password'}\n    try:\n        choice = int(input(bcolors.OKBLUE + 'Enter the option no. of data: \\n [0] Mail \\n [1] Password\\n [2] Exit\\nOption:' + bcolors.ENDC))\n        try:\n            pass_data = input(bcolors.OKBLUE + 'Enter the ' + str(item[choice]) + ' to check: ' + bcolors.ENDC)\n        except:\n            exit(0)\n        data = main(str(choice), pass_data)\n        print(bcolors.OKGREEN + data + bcolors.ENDC)\n        print(bcolors.OKBLUE + ' [0] Dump data in a file \\n [1] Go back \\n [2] Exit' + bcolors.ENDC)\n        choice_ = input(bcolors.OKBLUE + 'Option: ' + bcolors.ENDC)\n        if choice_ == '0':\n            raw_filename = input(bcolors.OKBLUE + 'File name to save: ' + bcolors.ENDC)\n            filename = raw_filename + '_' + str(item[choice]) + '.txt'\n            file = open(filename, 'w')\n            file.write(data)\n            file.close()\n            print(bcolors.OKGREEN + 'File is saved in same directory with name {}.'.format(raw_filename) + bcolors.ENDC)\n            print()\n        elif choice_ == '1':\n            print()\n            print()\n            mech()\n        else:\n            exit(0)\n    except Exception as e:\n        print(bcolors.FAIL + e + bcolors.ENDC)\n        exit(0)", "fn_id": 1, "class_fn": false, "repo": "StrinTH/checkleaks", "file": "leakcheck.py", "last_update_at": "2021-01-06T14:45:08+00:00", "original_content": "def mech():\n    item = {0: 'mail', 1: 'password'}\n    try:\n        choice = int(input(bcolors.OKBLUE + 'Enter the option no. of data: \\n [0] Mail \\n [1] Password\\n [2] Exit\\nOption:' + bcolors.ENDC))\n        try:\n            pass_data = input(bcolors.OKBLUE + 'Enter the ' + str(item[choice]) + ' to check: ' + bcolors.ENDC)\n        except:\n            exit(0)\n        data = main(str(choice), pass_data)\n        print(bcolors.OKGREEN + data + bcolors.ENDC)\n        print(bcolors.OKBLUE + ' [0] Dump data in a file \\n [1] Go back \\n [2] Exit' + bcolors.ENDC)\n        choice_ = input(bcolors.OKBLUE + 'Option: ' + bcolors.ENDC)\n        if choice_ == '0':\n            raw_filename = input(bcolors.OKBLUE + 'File name to save: ' + bcolors.ENDC)\n            filename = raw_filename + '_' + str(item[choice]) + '.txt'\n            file = open(filename, 'w')\n            file.write(data)\n            file.close()\n            print(bcolors.OKGREEN + 'File is saved in same directory with name {}.'.format(raw_filename) + bcolors.ENDC)\n            print()\n        elif choice_ == '1':\n            print()\n            print()\n            mech()\n        else:\n            exit(0)\n    except Exception as e:\n        print(bcolors.FAIL + e + bcolors.ENDC)\n        exit(0)", "refactored": true, "pred": {"ppl": 3.4641008377075195, "ppl_lower": 3.691333055496216, "ppl/lowercase_ppl": -1.0511363800951985, "ppl/zlib": 0.0026101955892210023, "Min_5.0% Prob": 9.817361128957648, "Min_10.0% Prob": 7.9028753230446265, "Min_20.0% Prob": 5.542731489453997, "Min_30.0% Prob": 4.036963955081743, "Min_40.0% Prob": 3.0947801649570463, "Min_50.0% Prob": 2.4823041872419034, "Min_60.0% Prob": 2.077395514486727}}
{"hexsha": "a113b237351d78e1a5fa0fd0d24d0327976b7f7a", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef process_data(dataframe: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"delete column that have most na, and fill na with mean\"\"\"\n    na_count = dataframe.isnull().sum(axis=0).tolist()\n    most_na_col = na_count.index(max(na_count))\n    result = dataframe.drop(dataframe.columns[most_na_col], axis=1)\n    return result.fillna(result.mean())", "fn_id": 1, "class_fn": false, "repo": "coookie89/Intern-Training", "file": "txya900619/Week1/ch2/2.2/exercise1.py", "last_update_at": "2021-08-24T12:14:46+00:00", "original_content": "def process_data(dataframe: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"delete column that have most na, and fill na with mean\"\"\"\n    na_count = dataframe.isnull().sum(axis=0).tolist()\n    most_na_col = na_count.index(max(na_count))\n    result = dataframe.drop(dataframe.columns[most_na_col], axis=1)\n    return result.fillna(result.mean())", "refactored": true, "pred": {"ppl": 3.6226794719696045, "ppl_lower": 3.950305223464966, "ppl/lowercase_ppl": -1.0672606996362026, "ppl/zlib": 0.005695636892311338, "Min_5.0% Prob": 9.13307752609253, "Min_10.0% Prob": 7.424196767807007, "Min_20.0% Prob": 5.486895243326823, "Min_30.0% Prob": 4.194174814969301, "Min_40.0% Prob": 3.2130380168903705, "Min_50.0% Prob": 2.570845273012916, "Min_60.0% Prob": 2.171509092593624}}
{"hexsha": "be83fdd493ff018b94ad39f9ed435403d860ea8e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef generate_bio(spans, length):\n    tags = ['O'] * length\n    for span in spans:\n        tags[span.tokens[0]] = f'B-{span.type}'\n        for i in span.tokens[1:]:\n            tags[i] = f'I-{span.type}'\n    return tags", "fn_id": 4, "class_fn": false, "repo": "blester125/iobes", "file": "tests/utils.py", "last_update_at": "2021-12-06T23:15:18+00:00", "original_content": "def generate_bio(spans, length):\n    tags = ['O'] * length\n    for span in spans:\n        tags[span.tokens[0]] = f'B-{span.type}'\n        for i in span.tokens[1:]:\n            tags[i] = f'I-{span.type}'\n    return tags", "refactored": true, "pred": {"ppl": 3.5449371337890625, "ppl_lower": 4.251497268676758, "ppl/lowercase_ppl": -1.1436174316950511, "ppl/zlib": 0.007959247962628258, "Min_5.0% Prob": 10.95126756032308, "Min_10.0% Prob": 8.668580736432757, "Min_20.0% Prob": 6.109028291702271, "Min_30.0% Prob": 4.248280932074008, "Min_40.0% Prob": 3.2090138007075555, "Min_50.0% Prob": 2.5611046632417502, "Min_60.0% Prob": 2.1269229856924095}}
{"hexsha": "1a9febc6fc48fe142ca3755fceef4aa604dfb595", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef assemble(mappings, sequence_file, out_file, min_overlap, max_overhang, min_length):\n    graph, assembled = OverlapGraph.parse_paf(mappings, min_overlap, max_overhang)\n    paths = graph.max_paths()\n    sequences = parse_fasta(sequence_file)\n    with open(out_file, 'w') as f:\n        for path in paths:\n            seq, contained_reads, name = construct_merged_sequence(path, graph, sequences)\n            assembled += contained_reads\n            if len(seq) > min_length:\n                f.write('>%s\\n%s\\n' % (name, seq))\n        for n, s in sequences.items():\n            if n in assembled:\n                continue\n            if len(s) < min_length:\n                continue\n            f.write('>%s\\n%s\\n' % (n, s))", "fn_id": 2, "class_fn": false, "repo": "rikuu/hgga", "file": "asm_node.py", "last_update_at": "2021-04-09T21:56:00+00:00", "original_content": "def assemble(mappings, sequence_file, out_file, min_overlap, max_overhang, min_length):\n    graph, assembled = OverlapGraph.parse_paf(mappings, min_overlap, max_overhang)\n    paths = graph.max_paths()\n    sequences = parse_fasta(sequence_file)\n    with open(out_file, 'w') as f:\n        for path in paths:\n            seq, contained_reads, name = construct_merged_sequence(path, graph, sequences)\n            assembled += contained_reads\n            if len(seq) > min_length:\n                f.write('>%s\\n%s\\n' % (name, seq))\n        for n, s in sequences.items():\n            if n in assembled:\n                continue\n            if len(s) < min_length:\n                continue\n            f.write('>%s\\n%s\\n' % (n, s))", "refactored": true, "pred": {"ppl": 3.3110663890838623, "ppl_lower": 3.394176483154297, "ppl/lowercase_ppl": -1.0207061466451999, "ppl/zlib": 0.00369527873281296, "Min_5.0% Prob": 9.074338626861572, "Min_10.0% Prob": 7.447075775691441, "Min_20.0% Prob": 5.310212067195347, "Min_30.0% Prob": 3.963664907311636, "Min_40.0% Prob": 2.9890762232682286, "Min_50.0% Prob": 2.4040089920338876, "Min_60.0% Prob": 2.0077834342236036}}
{"hexsha": "a2c6556c09f53bd180fe20a7e14114c3b4f5b12b", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_mycroft_version():\n    try:\n        from mycroft.version import CORE_VERSION_STR\n        return CORE_VERSION_STR\n    except:\n        pass\n    root = search_mycroft_core_location()\n    if root:\n        version_file = join(root, 'version', '__init__.py')\n        if not isfile(version_file):\n            version_file = join(root, 'mycroft', 'version', '__init__.py')\n        if isfile(version_file):\n            version = []\n            with open(version_file) as f:\n                text = f.read()\n                version.append(text.split('CORE_VERSION_MAJOR =')[-1].split('\\n')[0].strip())\n                version.append(text.split('CORE_VERSION_MINOR =')[-1].split('\\n')[0].strip())\n                version.append(text.split('CORE_VERSION_BUILD =')[-1].split('\\n')[0].strip())\n                version = '.'.join(version)\n                if \"CORE_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE)) + \" in text:\n                    version += text.split(\"CORE_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE)) + \")[-1].split('\\n')[0][1:-1]\n                return version\n        return None", "fn_id": 3, "class_fn": false, "repo": "NeonJarbas/ovos_utils", "file": "ovos_utils/fingerprinting.py", "last_update_at": "2021-11-08T07:19:25+00:00", "original_content": "def get_mycroft_version():\n    try:\n        from mycroft.version import CORE_VERSION_STR\n        return CORE_VERSION_STR\n    except:\n        pass\n    root = search_mycroft_core_location()\n    if root:\n        version_file = join(root, 'version', '__init__.py')\n        if not isfile(version_file):\n            version_file = join(root, 'mycroft', 'version', '__init__.py')\n        if isfile(version_file):\n            version = []\n            with open(version_file) as f:\n                text = f.read()\n                version.append(text.split('CORE_VERSION_MAJOR =')[-1].split('\\n')[0].strip())\n                version.append(text.split('CORE_VERSION_MINOR =')[-1].split('\\n')[0].strip())\n                version.append(text.split('CORE_VERSION_BUILD =')[-1].split('\\n')[0].strip())\n                version = '.'.join(version)\n                if \"CORE_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE)) + \" in text:\n                    version += text.split(\"CORE_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE)) + \")[-1].split('\\n')[0][1:-1]\n                return version\n        return None", "refactored": true, "pred": {"ppl": 2.1616058349609375, "ppl_lower": 2.3533754348754883, "ppl/lowercase_ppl": -1.1102667344543486, "ppl/zlib": 0.002044698640826059, "Min_5.0% Prob": 8.11680653889974, "Min_10.0% Prob": 6.010317587083386, "Min_20.0% Prob": 3.6834360701697215, "Min_30.0% Prob": 2.563709107485223, "Min_40.0% Prob": 1.9244174715722837, "Min_50.0% Prob": 1.5463631291010649, "Min_60.0% Prob": 1.2847271192481338}}
{"hexsha": "d9fc432fc00d588e5c0efee2aee23a3f4e8a0c91", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    usr_dir.import_usr_dir(FLAGS.t2t_usr_dir)\n    trainer_utils.log_registry()\n    trainer_utils.validate_flags()\n    output_dir = os.path.expanduser(FLAGS.output_dir)\n    tmp_dir = os.path.expanduser(FLAGS.tmp_dir)\n    if not FLAGS.data_dir:\n        raise ValueError('You must specify a --data_dir')\n    data_dir = os.path.expanduser(FLAGS.data_dir)\n    tf.gfile.MakeDirs(output_dir)\n    if FLAGS.generate_data:\n        tf.gfile.MakeDirs(data_dir)\n        tf.gfile.MakeDirs(tmp_dir)\n        for problem_name in FLAGS.problems.split('-'):\n            tf.logging.info('Generating data for %s' % problem_name)\n            problem = registry.problem(problem_name)\n            problem.generate_data(data_dir, tmp_dir)\n    trainer_utils.run(data_dir=data_dir, model=FLAGS.model, output_dir=output_dir, train_steps=FLAGS.train_steps, eval_steps=FLAGS.eval_steps, schedule=FLAGS.schedule)", "fn_id": 0, "class_fn": false, "repo": "ctuning/ck-ml", "file": "program/tensor2tensor-attention-tf/source/tensor2tensor/tensor2tensor/bin/t2t-trainer.py", "last_update_at": "2021-09-14T14:14:10+00:00", "original_content": "def main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    usr_dir.import_usr_dir(FLAGS.t2t_usr_dir)\n    trainer_utils.log_registry()\n    trainer_utils.validate_flags()\n    output_dir = os.path.expanduser(FLAGS.output_dir)\n    tmp_dir = os.path.expanduser(FLAGS.tmp_dir)\n    if not FLAGS.data_dir:\n        raise ValueError('You must specify a --data_dir')\n    data_dir = os.path.expanduser(FLAGS.data_dir)\n    tf.gfile.MakeDirs(output_dir)\n    if FLAGS.generate_data:\n        tf.gfile.MakeDirs(data_dir)\n        tf.gfile.MakeDirs(tmp_dir)\n        for problem_name in FLAGS.problems.split('-'):\n            tf.logging.info('Generating data for %s' % problem_name)\n            problem = registry.problem(problem_name)\n            problem.generate_data(data_dir, tmp_dir)\n    trainer_utils.run(data_dir=data_dir, model=FLAGS.model, output_dir=output_dir, train_steps=FLAGS.train_steps, eval_steps=FLAGS.eval_steps, schedule=FLAGS.schedule)", "refactored": true, "pred": {"ppl": 2.0292632579803467, "ppl_lower": 2.5152738094329834, "ppl/lowercase_ppl": -1.3034013290831556, "ppl/zlib": 0.0017736160402918259, "Min_5.0% Prob": 6.930977535247803, "Min_10.0% Prob": 5.251862827936808, "Min_20.0% Prob": 3.3650213072697324, "Min_30.0% Prob": 2.365330898761749, "Min_40.0% Prob": 1.7708363109999452, "Min_50.0% Prob": 1.419880649202892, "Min_60.0% Prob": 1.1846429870706063}}
{"hexsha": "01b86d405494b9108be791ee779c96fe8f5fc81b", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_code_point_of_name():\n    assert demojiprocess.code_point_of_name('yellow_heart') == '1f49b'\n    assert demojiprocess.code_point_of_name(':yellow_heart:') == '1f49b'\n    assert demojiprocess.code_point_of_name('woman_health_worker_tone2') == '1f469-1f3fc-200d-2695-fe0f'\n    assert demojiprocess.code_point_of_name('adult:skin-tone-4') == '1f9d1-1f3fe'", "fn_id": 4, "class_fn": false, "repo": "PommeBleue/discord-emoji", "file": "src/tests/tests.py", "last_update_at": "2021-06-18T09:37:53+00:00", "original_content": "def test_code_point_of_name():\n    assert demojiprocess.code_point_of_name('yellow_heart') == '1f49b'\n    assert demojiprocess.code_point_of_name(':yellow_heart:') == '1f49b'\n    assert demojiprocess.code_point_of_name('woman_health_worker_tone2') == '1f469-1f3fc-200d-2695-fe0f'\n    assert demojiprocess.code_point_of_name('adult:skin-tone-4') == '1f9d1-1f3fe'", "refactored": true, "pred": {"ppl": 3.213940143585205, "ppl_lower": 3.213940143585205, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.006379768543665294, "Min_5.0% Prob": 10.134548783302307, "Min_10.0% Prob": 8.297213822603226, "Min_20.0% Prob": 5.5132224932312965, "Min_30.0% Prob": 3.8554565804079175, "Min_40.0% Prob": 2.9146428438834846, "Min_50.0% Prob": 2.334479570982512, "Min_60.0% Prob": 1.945763978591761}}
{"hexsha": "b9a0444e34d229fe92febc414b59c043e61e95ce", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_blue_marble_image(month):\n    filename = 'world.2004%02i.3x21600x10800.jpg' % month\n    fullpath = os.path.join(os.path.expanduser('~'), '.cache/burned_area/' + filename)\n    if os.path.exists(fullpath):\n        with open(fullpath, 'rb') as f:\n            imgdata = f.read()\n    else:\n        code = _nasa_blue_marble_ng_monthly_image_url_codes[month - 1]\n        url = ('https://eoimages.gsfc.nasa.gov/images/imagerecords/' + '%s/' + filename) % code\n        print('Downloading', url)\n        req = requests.get(url)\n        req.raise_for_status()\n        imgdata = req.content\n        os.makedirs(os.path.dirname(fullpath), exist_ok=True)\n        with open(fullpath, 'wb') as f:\n            f.write(imgdata)\n    img = Image.open(io.BytesIO(imgdata))\n    return img", "fn_id": 4, "class_fn": false, "repo": "benbarsdell/burned-area-viz", "file": "burned_area_viz.py", "last_update_at": "2021-04-16T18:20:36+00:00", "original_content": "def get_blue_marble_image(month):\n    filename = 'world.2004%02i.3x21600x10800.jpg' % month\n    fullpath = os.path.join(os.path.expanduser('~'), '.cache/burned_area/' + filename)\n    if os.path.exists(fullpath):\n        with open(fullpath, 'rb') as f:\n            imgdata = f.read()\n    else:\n        code = _nasa_blue_marble_ng_monthly_image_url_codes[month - 1]\n        url = ('https://eoimages.gsfc.nasa.gov/images/imagerecords/' + '%s/' + filename) % code\n        print('Downloading', url)\n        req = requests.get(url)\n        req.raise_for_status()\n        imgdata = req.content\n        os.makedirs(os.path.dirname(fullpath), exist_ok=True)\n        with open(fullpath, 'wb') as f:\n            f.write(imgdata)\n    img = Image.open(io.BytesIO(imgdata))\n    return img", "refactored": true, "pred": {"ppl": 2.5115745067596436, "ppl_lower": 2.8438706398010254, "ppl/lowercase_ppl": -1.1349276214131436, "ppl/zlib": 0.0021317357639052906, "Min_5.0% Prob": 8.923107293935923, "Min_10.0% Prob": 6.740717823688801, "Min_20.0% Prob": 4.40234590476414, "Min_30.0% Prob": 3.0620475566014647, "Min_40.0% Prob": 2.310688597855167, "Min_50.0% Prob": 1.8482008802760115, "Min_60.0% Prob": 1.5385822070591146}}
{"hexsha": "965d7f77982b9eaf53ae37fba39562b4f8c0b34f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _split_points_into_batches(points: NumericArray, number_of_points_per_batch: int) -> tp.List[tp.List[NumericArray]]:\n    number_of_points = points.shape[1]\n    n_begin = 0\n    args_list = []\n    while n_begin < number_of_points:\n        n_end = min(n_begin + number_of_points_per_batch, number_of_points)\n        args_list.append([points[:, n_begin:n_end]])\n        n_begin = n_end\n    return args_list", "fn_id": 0, "class_fn": false, "repo": "michaelnowotny/cocos", "file": "cocos/scientific/kde.py", "last_update_at": "2021-11-27T09:09:40+00:00", "original_content": "def _split_points_into_batches(points: NumericArray, number_of_points_per_batch: int) -> tp.List[tp.List[NumericArray]]:\n    number_of_points = points.shape[1]\n    n_begin = 0\n    args_list = []\n    while n_begin < number_of_points:\n        n_end = min(n_begin + number_of_points_per_batch, number_of_points)\n        args_list.append([points[:, n_begin:n_end]])\n        n_begin = n_end\n    return args_list", "refactored": true, "pred": {"ppl": 2.887075662612915, "ppl_lower": 3.2941064834594727, "ppl/lowercase_ppl": -1.1243966821445532, "ppl/zlib": 0.004775874362062479, "Min_5.0% Prob": 10.021343776157924, "Min_10.0% Prob": 7.99224192755563, "Min_20.0% Prob": 5.259134705577578, "Min_30.0% Prob": 3.523776623572028, "Min_40.0% Prob": 2.6732141033076404, "Min_50.0% Prob": 2.119654627309905, "Min_60.0% Prob": 1.7751855386291133}}
{"hexsha": "01eaa1599fa6952fceac0db02f61801ac8392d27", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef plot_correlation(py, correlated, minimum_arg, minimums):\n    plt.figure()\n    plt.plot(py, correlated[:, 0, 0])\n    plt.plot(py, correlated[:, -1, -1])\n    plt.legend(['pixel 0,0', 'pixel n,n', 'minimum 0 0', 'minimum n n'])\n    plt.title('cross correlation between calibration curve and pixel values')\n    plt.xlabel('Physical distance (im)')\n    plt.ylabel('Focus unit')", "fn_id": 17, "class_fn": false, "repo": "idiap/deepfocus2019", "file": "detection/calibration_fit.py", "last_update_at": "2021-11-26T09:33:14+00:00", "original_content": "def plot_correlation(py, correlated, minimum_arg, minimums):\n    plt.figure()\n    plt.plot(py, correlated[:, 0, 0])\n    plt.plot(py, correlated[:, -1, -1])\n    plt.legend(['pixel 0,0', 'pixel n,n', 'minimum 0 0', 'minimum n n'])\n    plt.title('cross correlation between calibration curve and pixel values')\n    plt.xlabel('Physical distance (im)')\n    plt.ylabel('Focus unit')", "refactored": true, "pred": {"ppl": 8.765810012817383, "ppl_lower": 8.648435592651367, "ppl/lowercase_ppl": -0.9937902550239417, "ppl/zlib": 0.009734793401667515, "Min_5.0% Prob": 12.052257219950357, "Min_10.0% Prob": 10.582161784172058, "Min_20.0% Prob": 8.205308647155762, "Min_30.0% Prob": 6.585137302811082, "Min_40.0% Prob": 5.239320864677429, "Min_50.0% Prob": 4.323693300687498, "Min_60.0% Prob": 3.602492703696092}}
{"hexsha": "d4fedd0a36cd395e4706b0c47428c1465d2a2a9d", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef wl_predict(datasets, test_datasets):\n    \"\"\"\n\n    \"\"\"\n    log_dir = tfu.get_logdir()\n    datasets, test_datasets = get_wl_datasets()\n    x, y = tfu.get_example(datasets)\n    loss_fxn = tf.losses.BinaryCrossentropy()\n    optim = tf.keras.optimizers.Adam()\n    model = lstm.make_mlp_functional(x.shape[-2:], tf.size(y[0]), classify=True)\n    train_summary_writer, test_summary_writer = tfu.init_summary_writers(log_dir)\n    train_loss, train_accuracy, test_loss, test_accuracy = tfu.get_classification_metrics()\n    tr_step = 0\n    te_step = 0\n    for epoch, dataset in enumerate(datasets):\n        if not dataset:\n            continue\n        for xtr, ytr in dataset:\n            ytr = tf.reshape(ytr, (1, -1))\n            tl, ta, preds = fwd.train_step_classify(model, optim, loss_fxn, xtr, ytr, train_loss, train_accuracy)\n            tr_step += 1\n            with train_summary_writer.as_default():\n                tf.summary.scalar('loss', tl.numpy(), step=tr_step)\n                tf.summary.scalar('accuracy', ta.numpy(), step=tr_step)\n            maxed_pred = tf.argmax(preds, 1).numpy()[0]\n            maxed_true = tf.argmax(ytr).numpy()\n            correct = tf.equal(maxed_pred, maxed_true).numpy()\n        test_dataset = random.choice(test_datasets)\n        if not test_dataset:\n            continue\n        for xte, yte in test_dataset:\n            yte = tf.reshape(yte, (1, -1))\n            tel, tea = fwd.test_step(model, loss_fxn, xte, yte, test_loss, test_accuracy)\n            te_step += 1\n            with test_summary_writer.as_default():\n                tf.summary.scalar('loss', tel.numpy(), step=te_step)\n                tf.summary.scalar('accuracy', tea.numpy(), step=te_step)\n        template = 'Epoch {}, Loss: {}, Accuracy: {}, Test Loss: {}, Test Accuracy: {}, Preds: {}, Acts: {}'\n        print(template.format(epoch + 1, train_loss.result(), train_accuracy.result() * 100, test_loss.result(), test_accuracy.result() * 100, preds, ytr))\n        train_loss.reset_states()\n        test_loss.reset_states()\n        train_accuracy.reset_states()\n        test_accuracy.reset_states()\n    tf.saved_model.save(model, tfm.WRITE_TO + 'win_loss/')\n    return datasets", "fn_id": 1, "class_fn": false, "repo": "AnandIJain/sip", "file": "sips/ml/tf_models/win_loss.py", "last_update_at": "2021-06-13T13:53:59+00:00", "original_content": "def wl_predict(datasets, test_datasets):\n    \"\"\"\n\n    \"\"\"\n    log_dir = tfu.get_logdir()\n    datasets, test_datasets = get_wl_datasets()\n    x, y = tfu.get_example(datasets)\n    loss_fxn = tf.losses.BinaryCrossentropy()\n    optim = tf.keras.optimizers.Adam()\n    model = lstm.make_mlp_functional(x.shape[-2:], tf.size(y[0]), classify=True)\n    train_summary_writer, test_summary_writer = tfu.init_summary_writers(log_dir)\n    train_loss, train_accuracy, test_loss, test_accuracy = tfu.get_classification_metrics()\n    tr_step = 0\n    te_step = 0\n    for epoch, dataset in enumerate(datasets):\n        if not dataset:\n            continue\n        for xtr, ytr in dataset:\n            ytr = tf.reshape(ytr, (1, -1))\n            tl, ta, preds = fwd.train_step_classify(model, optim, loss_fxn, xtr, ytr, train_loss, train_accuracy)\n            tr_step += 1\n            with train_summary_writer.as_default():\n                tf.summary.scalar('loss', tl.numpy(), step=tr_step)\n                tf.summary.scalar('accuracy', ta.numpy(), step=tr_step)\n            maxed_pred = tf.argmax(preds, 1).numpy()[0]\n            maxed_true = tf.argmax(ytr).numpy()\n            correct = tf.equal(maxed_pred, maxed_true).numpy()\n        test_dataset = random.choice(test_datasets)\n        if not test_dataset:\n            continue\n        for xte, yte in test_dataset:\n            yte = tf.reshape(yte, (1, -1))\n            tel, tea = fwd.test_step(model, loss_fxn, xte, yte, test_loss, test_accuracy)\n            te_step += 1\n            with test_summary_writer.as_default():\n                tf.summary.scalar('loss', tel.numpy(), step=te_step)\n                tf.summary.scalar('accuracy', tea.numpy(), step=te_step)\n        template = 'Epoch {}, Loss: {}, Accuracy: {}, Test Loss: {}, Test Accuracy: {}, Preds: {}, Acts: {}'\n        print(template.format(epoch + 1, train_loss.result(), train_accuracy.result() * 100, test_loss.result(), test_accuracy.result() * 100, preds, ytr))\n        train_loss.reset_states()\n        test_loss.reset_states()\n        train_accuracy.reset_states()\n        test_accuracy.reset_states()\n    tf.saved_model.save(model, tfm.WRITE_TO + 'win_loss/')\n    return datasets", "refactored": true, "pred": {"ppl": 2.7731337547302246, "ppl_lower": 3.068688154220581, "ppl/lowercase_ppl": -1.0992885717106802, "ppl/zlib": 0.001343844532459676, "Min_5.0% Prob": 9.380869764270205, "Min_10.0% Prob": 7.264354283159429, "Min_20.0% Prob": 4.77660842646252, "Min_30.0% Prob": 3.36268791069637, "Min_40.0% Prob": 2.5495231735115906, "Min_50.0% Prob": 2.039332197075822, "Min_60.0% Prob": 1.7015912482018019}}
{"hexsha": "982db6db807b1cdc32803139fd8028059a1a1f18", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef plotvfonsph(theta_rad, phi_rad, F_th, F_ph, freq=0.0, vcoordlist=['sph'], projection='orthographic', cmplx_rep='AbsAng', vfname='Unknown'):\n    \"\"\"Plot transverse vector field on sphere. Different projections are\n    supported as are different bases and complex value representations.\"\"\"\n    x, y, xyNames, nom_xticks, F_th, F_ph = projectdomain(theta_rad, phi_rad, F_th, F_ph, projection)\n    F0_c, F1_c, compNames = vcoordconvert(F_th, F_ph, phi_rad, vcoordlist=vcoordlist)\n    F0_2r, cmplxop0 = cmplx2realrep(F0_c, cmplx_rep)\n    F1_2r, cmplxop1 = cmplx2realrep(F1_c, cmplx_rep)\n    if projection == 'orthographic':\n        xyNames = [xyNames[0] + ' []', xyNames[1] + ' []']\n    if projection == 'azimuthal-equidistant':\n        x = numpy.rad2deg(x)\n        y = numpy.rad2deg(y)\n        xyNames = [xyNames[0] + ' [deg.]', xyNames[1] + ' [deg.]']\n    fig = plt.figure()\n    fig.suptitle(vfname + ' @ ' + str(freq / 1000000.0) + ' MHz' + ', ' + 'projection: ' + projection)\n\n    def plotcomp(vcmpi, cpi, zcomp, cmplxop, xyNames, nom_xticks):\n        if cmplxop[cpi] == 'Ang':\n            cmap = plt.get_cmap('hsv')\n        else:\n            cmap = plt.get_cmap('viridis')\n        plt.pcolormesh(x, y, zcomp[cpi], cmap=cmap)\n        if nom_xticks is not None:\n            plt.xticks(nom_xticks)\n        ax.set_title(cmplxop[cpi] + '(' + compNames[vcmpi] + ')')\n        plt.xlabel(xyNames[0])\n        plt.ylabel(xyNames[1])\n        plt.grid()\n        plt.colorbar()\n        if projection == 'equirectangular':\n            ax.invert_yaxis()\n    ax = plt.subplot(221, polar=False)\n    plotcomp(0, 0, F0_2r, cmplxop0, xyNames, nom_xticks)\n    ax = plt.subplot(222, polar=False)\n    plotcomp(0, 1, F0_2r, cmplxop0, xyNames, nom_xticks)\n    ax = plt.subplot(223, polar=False)\n    plotcomp(1, 0, F1_2r, cmplxop1, xyNames, nom_xticks)\n    ax = plt.subplot(224, polar=False)\n    plotcomp(1, 1, F1_2r, cmplxop1, xyNames, nom_xticks)\n    plt.show()", "fn_id": 12, "class_fn": false, "repo": "David-McKenna/AntPat", "file": "antpat/reps/sphgridfun/tvecfun.py", "last_update_at": "2021-04-06T06:23:25+00:00", "original_content": "def plotvfonsph(theta_rad, phi_rad, F_th, F_ph, freq=0.0, vcoordlist=['sph'], projection='orthographic', cmplx_rep='AbsAng', vfname='Unknown'):\n    \"\"\"Plot transverse vector field on sphere. Different projections are\n    supported as are different bases and complex value representations.\"\"\"\n    x, y, xyNames, nom_xticks, F_th, F_ph = projectdomain(theta_rad, phi_rad, F_th, F_ph, projection)\n    F0_c, F1_c, compNames = vcoordconvert(F_th, F_ph, phi_rad, vcoordlist=vcoordlist)\n    F0_2r, cmplxop0 = cmplx2realrep(F0_c, cmplx_rep)\n    F1_2r, cmplxop1 = cmplx2realrep(F1_c, cmplx_rep)\n    if projection == 'orthographic':\n        xyNames = [xyNames[0] + ' []', xyNames[1] + ' []']\n    if projection == 'azimuthal-equidistant':\n        x = numpy.rad2deg(x)\n        y = numpy.rad2deg(y)\n        xyNames = [xyNames[0] + ' [deg.]', xyNames[1] + ' [deg.]']\n    fig = plt.figure()\n    fig.suptitle(vfname + ' @ ' + str(freq / 1000000.0) + ' MHz' + ', ' + 'projection: ' + projection)\n\n    def plotcomp(vcmpi, cpi, zcomp, cmplxop, xyNames, nom_xticks):\n        if cmplxop[cpi] == 'Ang':\n            cmap = plt.get_cmap('hsv')\n        else:\n            cmap = plt.get_cmap('viridis')\n        plt.pcolormesh(x, y, zcomp[cpi], cmap=cmap)\n        if nom_xticks is not None:\n            plt.xticks(nom_xticks)\n        ax.set_title(cmplxop[cpi] + '(' + compNames[vcmpi] + ')')\n        plt.xlabel(xyNames[0])\n        plt.ylabel(xyNames[1])\n        plt.grid()\n        plt.colorbar()\n        if projection == 'equirectangular':\n            ax.invert_yaxis()\n    ax = plt.subplot(221, polar=False)\n    plotcomp(0, 0, F0_2r, cmplxop0, xyNames, nom_xticks)\n    ax = plt.subplot(222, polar=False)\n    plotcomp(0, 1, F0_2r, cmplxop0, xyNames, nom_xticks)\n    ax = plt.subplot(223, polar=False)\n    plotcomp(1, 0, F1_2r, cmplxop1, xyNames, nom_xticks)\n    ax = plt.subplot(224, polar=False)\n    plotcomp(1, 1, F1_2r, cmplxop1, xyNames, nom_xticks)\n    plt.show()", "refactored": true, "pred": {"ppl": 3.3283002376556396, "ppl_lower": 3.4609427452087402, "ppl/lowercase_ppl": -1.0324994018655755, "ppl/zlib": 0.0016337795306134437, "Min_5.0% Prob": 10.149522953563267, "Min_10.0% Prob": 7.908771190378401, "Min_20.0% Prob": 5.3701186246342125, "Min_30.0% Prob": 3.920669168371845, "Min_40.0% Prob": 2.9982005782787584, "Min_50.0% Prob": 2.4068449654590545, "Min_60.0% Prob": 2.0067404214577333}}
{"hexsha": "acf70d67c75b3c219a4cc6fc3e0736e214b7ac7f", "ext": "py", "lang": "Python", "content": "@pytest.fixture\n@timeing\n@measure_memory_usage\ndef color_image(image):\n    image.ndim = 3\n    return image", "fn_id": 2, "class_fn": false, "repo": "dxxxm/opencv_wrapper", "file": "tests/conftest.py", "last_update_at": "2021-11-24T09:24:10+00:00", "original_content": "@pytest.fixture\ndef color_image(image):\n    image.ndim = 3\n    return image", "refactored": true, "pred": {"ppl": 16.995697021484375, "ppl_lower": 16.995697021484375, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.02982063363824827, "Min_5.0% Prob": 11.328649520874023, "Min_10.0% Prob": 10.341335932413736, "Min_20.0% Prob": 9.267442226409912, "Min_30.0% Prob": 7.975930584801568, "Min_40.0% Prob": 6.553804318110148, "Min_50.0% Prob": 5.310348883271217, "Min_60.0% Prob": 4.659635336775529}}
{"hexsha": "53f7bb295a7670c88ce420c9fc2d3c662110f9c1", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef AvgPooling(pytorch_layer):\n    layer = pb2.LayerParameter()\n    layer.type = 'Pooling'\n    layer.pooling_param.pool = pb2.PoolingParameter.AVE\n    CopyPoolingParameter(pytorch_layer, layer)\n    return layer", "fn_id": 14, "class_fn": false, "repo": "UltronAI/pytorch-caffe", "file": "pytorch2caffe/ConvertLayer_caffe.py", "last_update_at": "2021-11-12T07:39:36+00:00", "original_content": "def AvgPooling(pytorch_layer):\n    layer = pb2.LayerParameter()\n    layer.type = 'Pooling'\n    layer.pooling_param.pool = pb2.PoolingParameter.AVE\n    CopyPoolingParameter(pytorch_layer, layer)\n    return layer", "refactored": true, "pred": {"ppl": 5.271653175354004, "ppl_lower": 8.623063087463379, "ppl/lowercase_ppl": -1.2960255859360212, "ppl/zlib": 0.011232054114014962, "Min_5.0% Prob": 11.639641125996908, "Min_10.0% Prob": 10.09014860788981, "Min_20.0% Prob": 7.061280819085928, "Min_30.0% Prob": 5.271997031569481, "Min_40.0% Prob": 4.18568784227738, "Min_50.0% Prob": 3.3531800016309274, "Min_60.0% Prob": 2.779510292131454}}
{"hexsha": "ed1e84994c73c427aad1a29aacc2fb28de4545f1", "ext": "py", "lang": "Python", "content": "@pytest.mark.parametrize('transaction_args,method_args,method_kwargs,expected,skip_testrpc', (({}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'chainId': None}, False), ({'gas': 800000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'chainId': None}, False), ({'gasPrice': 21000000000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 21000000000, 'chainId': None}, False), ({'nonce': 7}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'nonce': 7, 'chainId': None}, True), ({'value': 20000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 20000, 'gasPrice': 1, 'chainId': None}, False)), ids=['Standard', 'Explicit Gas', 'Explicit Gas Price', 'Explicit Nonce', 'With Value'])\n@timeing\n@measure_memory_usage\ndef test_build_transaction_with_contract_with_arguments(web3, skip_if_testrpc, math_contract, transaction_args, method_args, method_kwargs, expected, skip_testrpc, buildTransaction):\n    if skip_testrpc:\n        skip_if_testrpc(web3)\n    txn = buildTransaction(contract=math_contract, contract_function='increment', func_args=method_args, func_kwargs=method_kwargs, tx_params=transaction_args)\n    expected['to'] = math_contract.address\n    assert txn is not None\n    if 'gas' in transaction_args:\n        assert txn['gas'] == transaction_args['gas']\n    else:\n        assert 'gas' in txn\n    assert dissoc(txn, 'gas') == expected", "fn_id": 4, "class_fn": false, "repo": "onlinedeal4unow/web3.py", "file": "tests/core/contracts/test_contract_buildTransaction.py", "last_update_at": "2021-11-12T00:38:42+00:00", "original_content": "@pytest.mark.parametrize('transaction_args,method_args,method_kwargs,expected,skip_testrpc', (({}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'chainId': None}, False), ({'gas': 800000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'chainId': None}, False), ({'gasPrice': 21000000000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 21000000000, 'chainId': None}, False), ({'nonce': 7}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'nonce': 7, 'chainId': None}, True), ({'value': 20000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 20000, 'gasPrice': 1, 'chainId': None}, False)), ids=['Standard', 'Explicit Gas', 'Explicit Gas Price', 'Explicit Nonce', 'With Value'])\ndef test_build_transaction_with_contract_with_arguments(web3, skip_if_testrpc, math_contract, transaction_args, method_args, method_kwargs, expected, skip_testrpc, buildTransaction):\n    if skip_testrpc:\n        skip_if_testrpc(web3)\n    txn = buildTransaction(contract=math_contract, contract_function='increment', func_args=method_args, func_kwargs=method_kwargs, tx_params=transaction_args)\n    expected['to'] = math_contract.address\n    assert txn is not None\n    if 'gas' in transaction_args:\n        assert txn['gas'] == transaction_args['gas']\n    else:\n        assert 'gas' in txn\n    assert dissoc(txn, 'gas') == expected", "refactored": true, "pred": {"ppl": 1.792870044708252, "ppl_lower": 1.8854082822799683, "ppl/lowercase_ppl": -1.0862027289913272, "ppl/zlib": 0.0011629834915302816, "Min_5.0% Prob": 7.683360314369201, "Min_10.0% Prob": 5.158089023828507, "Min_20.0% Prob": 2.891567541112811, "Min_30.0% Prob": 1.94847843899153, "Min_40.0% Prob": 1.46202469712315, "Min_50.0% Prob": 1.169042750235934, "Min_60.0% Prob": 0.9738263049697145}}
{"hexsha": "6f98bbabb72a1fe6a11d10ff1c78a84452e1e916", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef add_preproc_params(parser):\n    parser.add_argument('--effdir_out_preproc', required=False, help='Output directory for preproc')\n    parser.add_argument('--preproc_mask', required=False, help='Preproc processing mask file')\n    parser.add_argument('--preproc_mask_adc', required=False, help='Preproc ADC NL processing mask file')\n    parser.add_argument('--preproc_dark', dest='preproc_dark', default=False, action='store_true', help='Preprocess dark data')\n    parser.add_argument('--preproc_common', dest='preproc_common', default=False, action='store_true', help='Preprocess common data')\n    parser.add_argument('--nbin', required=False, default=10000, type=np.int, help='Number of phase bins')\n    parser.add_argument('--jump_filter_len', required=False, default=40000, type=np.int, help='Jump filter length')\n    parser.add_argument('--jump_threshold', required=False, default=5.0, type=np.float, help='Jump detection threshold')\n    parser.add_argument('--preproc_timeout', required=False, default=120, type=np.int, help='Maximum time allowed for preprocessing a ring')\n    parser.add_argument('--preproc_timeout_intermediate', required=False, default=60, type=np.int, help='Maximum time allowed for preprocessing a ring before last iteration')\n    parser.add_argument('--adc_correction', required=False, help='Full (new) NL correction file.')\n    parser.add_argument('--measure_ADC', dest='measure_ADC', default=False, action='store_true', help='Measure ADC NL')\n    parser.add_argument('--niter_ADC', default=1, type=np.int, help='Number of ADC NL iterations')\n    parser.add_argument('--delta_ADC', default=1.0, type=np.float, help='Width of ADC bin in ADU')\n    parser.add_argument('--nphase4k', required=False, default=2, type=np.int, help='Number of 4K cooler phases to measure ADC NL for.')\n    parser.add_argument('--skip_preproc', dest='skip_preproc', default=False, action='store_true', help='Do not pre-process the TOD')\n    parser.add_argument('--flag_planets', dest='flag_planets', default=False, action='store_true', help='Derive planet flags')\n    parser.add_argument('--planet_flag_radius', required=False, default=2.0, type=np.float, help='New planet flag radius (in FWHM) when --flag_planets')\n    parser.add_argument('--detmask', required=False, type=np.int, help='Detector flag mask')\n    parser.add_argument('--intense_threshold', required=False, default=10000000000.0, type=np.float, help='Intense signal threshold [K_CMB]')\n    parser.add_argument('--preproc_async_time', required=False, default=1000, type=np.int, help='Initial asynchronous processing time before load balancing')\n    parser.add_argument('--preproc_async_time_intermediate', required=False, default=800, type=np.int, help='Initial asynchronous processing time before load balancing before last iteration')\n    return", "fn_id": 5, "class_fn": false, "repo": "planck-npipe/toast-npipe", "file": "pipelines/toast_planck_reduce.py", "last_update_at": "2021-04-20T08:09:35+00:00", "original_content": "def add_preproc_params(parser):\n    parser.add_argument('--effdir_out_preproc', required=False, help='Output directory for preproc')\n    parser.add_argument('--preproc_mask', required=False, help='Preproc processing mask file')\n    parser.add_argument('--preproc_mask_adc', required=False, help='Preproc ADC NL processing mask file')\n    parser.add_argument('--preproc_dark', dest='preproc_dark', default=False, action='store_true', help='Preprocess dark data')\n    parser.add_argument('--preproc_common', dest='preproc_common', default=False, action='store_true', help='Preprocess common data')\n    parser.add_argument('--nbin', required=False, default=10000, type=np.int, help='Number of phase bins')\n    parser.add_argument('--jump_filter_len', required=False, default=40000, type=np.int, help='Jump filter length')\n    parser.add_argument('--jump_threshold', required=False, default=5.0, type=np.float, help='Jump detection threshold')\n    parser.add_argument('--preproc_timeout', required=False, default=120, type=np.int, help='Maximum time allowed for preprocessing a ring')\n    parser.add_argument('--preproc_timeout_intermediate', required=False, default=60, type=np.int, help='Maximum time allowed for preprocessing a ring before last iteration')\n    parser.add_argument('--adc_correction', required=False, help='Full (new) NL correction file.')\n    parser.add_argument('--measure_ADC', dest='measure_ADC', default=False, action='store_true', help='Measure ADC NL')\n    parser.add_argument('--niter_ADC', default=1, type=np.int, help='Number of ADC NL iterations')\n    parser.add_argument('--delta_ADC', default=1.0, type=np.float, help='Width of ADC bin in ADU')\n    parser.add_argument('--nphase4k', required=False, default=2, type=np.int, help='Number of 4K cooler phases to measure ADC NL for.')\n    parser.add_argument('--skip_preproc', dest='skip_preproc', default=False, action='store_true', help='Do not pre-process the TOD')\n    parser.add_argument('--flag_planets', dest='flag_planets', default=False, action='store_true', help='Derive planet flags')\n    parser.add_argument('--planet_flag_radius', required=False, default=2.0, type=np.float, help='New planet flag radius (in FWHM) when --flag_planets')\n    parser.add_argument('--detmask', required=False, type=np.int, help='Detector flag mask')\n    parser.add_argument('--intense_threshold', required=False, default=10000000000.0, type=np.float, help='Intense signal threshold [K_CMB]')\n    parser.add_argument('--preproc_async_time', required=False, default=1000, type=np.int, help='Initial asynchronous processing time before load balancing')\n    parser.add_argument('--preproc_async_time_intermediate', required=False, default=800, type=np.int, help='Initial asynchronous processing time before load balancing before last iteration')\n    return", "refactored": true, "pred": {"ppl": 2.482720136642456, "ppl_lower": 2.6290149688720703, "ppl/lowercase_ppl": -1.0629616205064496, "ppl/zlib": 0.001280781392099206, "Min_5.0% Prob": 8.076219058036804, "Min_10.0% Prob": 6.206738442182541, "Min_20.0% Prob": 4.125872121834607, "Min_30.0% Prob": 2.9690803774624817, "Min_40.0% Prob": 2.2639257533723725, "Min_50.0% Prob": 1.8189091674089064, "Min_60.0% Prob": 1.5163870724172515}}
{"hexsha": "c0b95f623054d53abb9621aff1a8155369c99b80", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef seed_everything(seed):\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n    random.seed(seed)", "fn_id": 0, "class_fn": false, "repo": "boostcampaitech2/model-optimization-level3-cv-17", "file": "train.py", "last_update_at": "2021-12-22T04:52:08+00:00", "original_content": "def seed_everything(seed):\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.backends.cudnn.deterministic = True\n    torch.backends.cudnn.benchmark = False\n    random.seed(seed)", "refactored": true, "pred": {"ppl": 2.3149099349975586, "ppl_lower": 2.7964963912963867, "ppl/lowercase_ppl": -1.2251645722311495, "ppl/zlib": 0.006082396969657408, "Min_5.0% Prob": 9.04937998453776, "Min_10.0% Prob": 6.774101813634236, "Min_20.0% Prob": 4.13966211447349, "Min_30.0% Prob": 2.788098093494773, "Min_40.0% Prob": 2.1586496146539083, "Min_50.0% Prob": 1.7038235491085234, "Min_60.0% Prob": 1.4059151116540307}}
{"hexsha": "5ecff52b202fb2311f75b717f10ecda7192b0a5e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef extract_cands_in_generate(type, constraints=set()):\n    cands = []\n    for t in CONCEPTS[type]:\n        if all([is_consistent(t, c) for c in constraints]) or not constraints:\n            cands.append(t)\n    return cands", "fn_id": 5, "class_fn": false, "repo": "simon555/baby-ai-game", "file": "levels/instr_gen.py", "last_update_at": "2021-11-03T15:36:56+00:00", "original_content": "def extract_cands_in_generate(type, constraints=set()):\n    cands = []\n    for t in CONCEPTS[type]:\n        if all([is_consistent(t, c) for c in constraints]) or not constraints:\n            cands.append(t)\n    return cands", "refactored": true, "pred": {"ppl": 7.518923282623291, "ppl_lower": 7.491931438446045, "ppl/lowercase_ppl": -0.9982173723288199, "ppl/zlib": 0.011797795012913566, "Min_5.0% Prob": 10.527646700541178, "Min_10.0% Prob": 8.839593955448695, "Min_20.0% Prob": 7.316801105226789, "Min_30.0% Prob": 5.867482293735851, "Min_40.0% Prob": 4.920535432881322, "Min_50.0% Prob": 3.9849683336309485, "Min_60.0% Prob": 3.3815726715732706}}
{"hexsha": "57728a0d7226be69507552ec44dac52e55264baf", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef make_test_data():\n    \"\"\" \"\"\"\n    tgrid = np.array([0.0, 86400.0])\n    xgrid = np.linspace(-8, 8, 120)\n    ygrid = np.linspace(-7, 7, 110)\n    zgrid = np.linspace(-6, 6, 100)\n    bdip = np.array([[[ptm_dipole.dipole_field([x, y, z]) for z in zgrid] for y in ygrid] for x in xgrid])\n    ex = np.zeros([xgrid.size, ygrid.size, zgrid.size])\n    ey = np.zeros_like(ex)\n    ez = np.zeros_like(ex)\n    pf = ptm_preprocessing.PTMfields()\n    pf.set_grid(xgrid, ygrid, zgrid)\n    pf.set_magnetic(bdip[:, :, :, 0], bdip[:, :, :, 1], bdip[:, :, :, 2])\n    pf.set_electric(ex, ey, ez)\n    pf.write_file('ptm_data/ptm_fields_0001.dat')\n    pf.write_file('ptm_data/ptm_fields_0002.dat')\n    np.savetxt('ptm_data/tgrid.dat', tgrid)", "fn_id": 1, "class_fn": false, "repo": "Pheosics/SHIELDS-PTM", "file": "ptm_python/ptm_test_data.py", "last_update_at": "2021-09-20T19:58:27+00:00", "original_content": "def make_test_data():\n    \"\"\" \"\"\"\n    tgrid = np.array([0.0, 86400.0])\n    xgrid = np.linspace(-8, 8, 120)\n    ygrid = np.linspace(-7, 7, 110)\n    zgrid = np.linspace(-6, 6, 100)\n    bdip = np.array([[[ptm_dipole.dipole_field([x, y, z]) for z in zgrid] for y in ygrid] for x in xgrid])\n    ex = np.zeros([xgrid.size, ygrid.size, zgrid.size])\n    ey = np.zeros_like(ex)\n    ez = np.zeros_like(ex)\n    pf = ptm_preprocessing.PTMfields()\n    pf.set_grid(xgrid, ygrid, zgrid)\n    pf.set_magnetic(bdip[:, :, :, 0], bdip[:, :, :, 1], bdip[:, :, :, 2])\n    pf.set_electric(ex, ey, ez)\n    pf.write_file('ptm_data/ptm_fields_0001.dat')\n    pf.write_file('ptm_data/ptm_fields_0002.dat')\n    np.savetxt('ptm_data/tgrid.dat', tgrid)", "refactored": true, "pred": {"ppl": 2.681363105773926, "ppl_lower": 2.7312211990356445, "ppl/lowercase_ppl": -1.0186789777181697, "ppl/zlib": 0.002770576648247468, "Min_5.0% Prob": 8.93556722998619, "Min_10.0% Prob": 6.8041075468063354, "Min_20.0% Prob": 4.4964699983596805, "Min_30.0% Prob": 3.2354610891071793, "Min_40.0% Prob": 2.4547884956002237, "Min_50.0% Prob": 1.968830507294349, "Min_60.0% Prob": 1.6481619743057168}}
{"hexsha": "bb68959040f9d60e5d44b71c03cdbfca7f860c20", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _read(fname):\n    try:\n        return open(path.join(path.dirname(__file__), fname)).read()\n    except IOError:\n        return ''", "fn_id": 0, "class_fn": false, "repo": "inveniosoftware/flask-collect", "file": "setup.py", "last_update_at": "2021-11-15T12:08:13+00:00", "original_content": "def _read(fname):\n    try:\n        return open(path.join(path.dirname(__file__), fname)).read()\n    except IOError:\n        return ''", "refactored": true, "pred": {"ppl": 5.7493157386779785, "ppl_lower": 7.732585430145264, "ppl/lowercase_ppl": -1.1694389534182064, "ppl/zlib": 0.013992646766071325, "Min_5.0% Prob": 8.61384654045105, "Min_10.0% Prob": 7.60902726650238, "Min_20.0% Prob": 6.359835624694824, "Min_30.0% Prob": 5.275948762893677, "Min_40.0% Prob": 4.3944375550045685, "Min_50.0% Prob": 3.465555127371441, "Min_60.0% Prob": 2.9469185437147436}}
{"hexsha": "9f339190f0ef239c8b99606a869e09ec3bd344b0", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef top(stack):\n    if len(stack):\n        return stack[-1]\n    return None", "fn_id": 2, "class_fn": false, "repo": "suvambasak/cp", "file": "others/stack.py", "last_update_at": "2021-02-28T20:17:32+00:00", "original_content": "def top(stack):\n    if len(stack):\n        return stack[-1]\n    return None", "refactored": true, "pred": {"ppl": 7.889552116394043, "ppl_lower": 12.396306991577148, "ppl/lowercase_ppl": -1.2187608935907335, "ppl/zlib": 0.023741831807626696, "Min_5.0% Prob": 8.983485221862793, "Min_10.0% Prob": 8.453679402669271, "Min_20.0% Prob": 7.258394479751587, "Min_30.0% Prob": 6.101782904730903, "Min_40.0% Prob": 4.905927419662476, "Min_50.0% Prob": 4.0647509654363, "Min_60.0% Prob": 3.4285797658893795}}
{"hexsha": "a7cb7c0cbe1316b9f471be562240d8e6e68b5ee9", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_items(list_, doc_type):\n    data_table_names = {'PO': 'fss.dbo.bsPRItem', 'SO': 'fss.dbo.bsSaleOrderItem'}\n    result_dict = {}\n    item_list = []\n    try:\n        table_name = data_table_names[doc_type]\n    except KeyError as e:\n        print(f'ERROR: DocType {e} not found')\n        sys.exit()\n        return ({}, [])\n    for p in list_:\n        doc_no = p[1]\n        statement_items = f\"SELECT * FROM {table_name}                            WHERE DocNo = '{doc_no}'\"\n        cursor.execute(statement_items)\n        package = []\n        for r in cursor:\n            item_list.append(r)\n            package.append(r)\n        result_dict[r[1]] = package\n    return (result_dict, item_list)", "fn_id": 1, "class_fn": false, "repo": "adadesions/tenzing-project", "file": "tenzing-mini/tenzing_mini.py", "last_update_at": "2021-01-25T04:45:56+00:00", "original_content": "def get_items(list_, doc_type):\n    data_table_names = {'PO': 'fss.dbo.bsPRItem', 'SO': 'fss.dbo.bsSaleOrderItem'}\n    result_dict = {}\n    item_list = []\n    try:\n        table_name = data_table_names[doc_type]\n    except KeyError as e:\n        print(f'ERROR: DocType {e} not found')\n        sys.exit()\n        return ({}, [])\n    for p in list_:\n        doc_no = p[1]\n        statement_items = f\"SELECT * FROM {table_name}                            WHERE DocNo = '{doc_no}'\"\n        cursor.execute(statement_items)\n        package = []\n        for r in cursor:\n            item_list.append(r)\n            package.append(r)\n        result_dict[r[1]] = package\n    return (result_dict, item_list)", "refactored": true, "pred": {"ppl": 5.534512996673584, "ppl_lower": 6.277939796447754, "ppl/lowercase_ppl": -1.0736633718258823, "ppl/zlib": 0.004662135084855835, "Min_5.0% Prob": 12.095773887634277, "Min_10.0% Prob": 9.471113749912806, "Min_20.0% Prob": 7.096115634554908, "Min_30.0% Prob": 5.450870366767049, "Min_40.0% Prob": 4.247494682494332, "Min_50.0% Prob": 3.407489471973103, "Min_60.0% Prob": 2.8577436957421014}}
{"hexsha": "e376bb9a7337aed835807b7a81d670cdfa095d2c", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef plot_values(registration_method):\n    global metric_values, multires_iterations\n    metric_values.append(registration_method.GetMetricValue())\n    clear_output(wait=True)\n    plt.plot(metric_values, 'r')\n    plt.plot(multires_iterations, [metric_values[index] for index in multires_iterations], 'b*')\n    plt.xlabel('Iteration Number', fontsize=12)\n    plt.ylabel('Metric Value', fontsize=12)\n    plt.show()", "fn_id": 10, "class_fn": false, "repo": "neurodata/ndreg", "file": "ndreg/plotter.py", "last_update_at": "2021-09-27T01:06:33+00:00", "original_content": "def plot_values(registration_method):\n    global metric_values, multires_iterations\n    metric_values.append(registration_method.GetMetricValue())\n    clear_output(wait=True)\n    plt.plot(metric_values, 'r')\n    plt.plot(multires_iterations, [metric_values[index] for index in multires_iterations], 'b*')\n    plt.xlabel('Iteration Number', fontsize=12)\n    plt.ylabel('Metric Value', fontsize=12)\n    plt.show()", "refactored": true, "pred": {"ppl": 2.8377621173858643, "ppl_lower": 3.828240394592285, "ppl/lowercase_ppl": -1.287042179908844, "ppl/zlib": 0.004476462466576545, "Min_5.0% Prob": 9.536216974258423, "Min_10.0% Prob": 7.421933650970459, "Min_20.0% Prob": 4.8435824632644655, "Min_30.0% Prob": 3.467503331400253, "Min_40.0% Prob": 2.595248675122857, "Min_50.0% Prob": 2.099485838845853, "Min_60.0% Prob": 1.7379295129763583}}
{"hexsha": "56d66414c84d9d6eef940c2d2989f3d4532fde9e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef pose_to_transformation(pose):\n    \"\"\"\n    Convert poses to transformation matrix\n    \"\"\"\n    temp_0 = pose[0]\n    temp_1 = pose[1]\n    temp_2 = pose[2]\n    temp_x = pose[3]\n    temp_y = pose[4]\n    temp_z = pose[5]\n    temp_w = pose[6]\n    pose[4:6] *= -1\n    pose[0] *= -1\n    rot_mat = quat2mat(pose[3:])\n    translation_vector = np.array([[pose[0]], [pose[1]], [pose[2]]]) / 1000\n    print(translation_vector)\n    rot_mat_2 = np.array([[0, 1, 0, 0], [-1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])\n    flip_x = np.eye(4)\n    flip_x[0, 0] *= -1\n    trans = flip_x @ rot_mat_2\n    translation_offset = np.ones((3, 1)) * 1\n    transformation_mat = np.vstack((np.hstack((rot_mat, translation_vector + 0.5)), np.array([0, 0, 0, 1])))\n    print(transformation_mat.shape)\n    return transformation_mat @ trans", "fn_id": 8, "class_fn": false, "repo": "RahulSajnani/DRACO-Weakly-Supervised-Dense-Reconstruction-And-Canonicalization-of-Objects", "file": "DRACO/visualization-scripts/gen_point_cloud.py", "last_update_at": "2021-12-17T16:55:00+00:00", "original_content": "def pose_to_transformation(pose):\n    \"\"\"\n    Convert poses to transformation matrix\n    \"\"\"\n    temp_0 = pose[0]\n    temp_1 = pose[1]\n    temp_2 = pose[2]\n    temp_x = pose[3]\n    temp_y = pose[4]\n    temp_z = pose[5]\n    temp_w = pose[6]\n    pose[4:6] *= -1\n    pose[0] *= -1\n    rot_mat = quat2mat(pose[3:])\n    translation_vector = np.array([[pose[0]], [pose[1]], [pose[2]]]) / 1000\n    print(translation_vector)\n    rot_mat_2 = np.array([[0, 1, 0, 0], [-1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])\n    flip_x = np.eye(4)\n    flip_x[0, 0] *= -1\n    trans = flip_x @ rot_mat_2\n    translation_offset = np.ones((3, 1)) * 1\n    transformation_mat = np.vstack((np.hstack((rot_mat, translation_vector + 0.5)), np.array([0, 0, 0, 1])))\n    print(transformation_mat.shape)\n    return transformation_mat @ trans", "refactored": true, "pred": {"ppl": 2.651935338973999, "ppl_lower": 2.673755407333374, "ppl/lowercase_ppl": -1.0084019279948153, "ppl/zlib": 0.0027945263324948397, "Min_5.0% Prob": 8.053151488304138, "Min_10.0% Prob": 6.241272789059264, "Min_20.0% Prob": 4.30615640409065, "Min_30.0% Prob": 3.167659399485347, "Min_40.0% Prob": 2.4312368336161883, "Min_50.0% Prob": 1.9544526067308403, "Min_60.0% Prob": 1.63011180865108}}
{"hexsha": "d7f4490b643639fa5528139f79a00b5f88a06a1f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef v_bool(Inout=InOut_t.Internal_t, Default=0, varSigConst=None):\n    value = Default\n    if type(Default).__name__ == 'int':\n        Default = \"'\" + str(Default) + \"'\"\n    return v_symbol(v_type='boolean', DefaultValue=Default, Inout=Inout, includes=slv_includes, value=value, varSigConst=varSigConst, Bitwidth=1, primitive_type='boolean')", "fn_id": 0, "class_fn": false, "repo": "HardwareDesignWithPython/HDPython", "file": "HDPython/v_symbol.py", "last_update_at": "2021-10-20T20:08:16+00:00", "original_content": "def v_bool(Inout=InOut_t.Internal_t, Default=0, varSigConst=None):\n    value = Default\n    if type(Default).__name__ == 'int':\n        Default = \"'\" + str(Default) + \"'\"\n    return v_symbol(v_type='boolean', DefaultValue=Default, Inout=Inout, includes=slv_includes, value=value, varSigConst=varSigConst, Bitwidth=1, primitive_type='boolean')", "refactored": true, "pred": {"ppl": 18.921873092651367, "ppl_lower": 18.301671981811523, "ppl/lowercase_ppl": -0.9886658068100939, "ppl/zlib": 0.012619392958764663, "Min_5.0% Prob": 14.975789070129395, "Min_10.0% Prob": 12.060887683521617, "Min_20.0% Prob": 9.744643128436545, "Min_30.0% Prob": 8.23907080117394, "Min_40.0% Prob": 6.951504551846048, "Min_50.0% Prob": 5.858088314533234, "Min_60.0% Prob": 4.885510268094747}}
{"hexsha": "db3168c7636e669ffaa426160820cfab9e45c298", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef event(self, event):\n    if event.type() == QEvent.KeyPress and event.key() == Qt.Key_Tab:\n        self.emit(SIGNAL('tabPressed'))\n        return True", "fn_id": 3, "class_fn": false, "repo": "anjanatiha/Generative-Open-Domain-Chatbot-Application-with-Deep-Learning", "file": "code/chat_gui.py", "last_update_at": "2021-11-19T07:31:14+00:00", "original_content": "def event(self, event):\n    if event.type() == QEvent.KeyPress and event.key() == Qt.Key_Tab:\n        self.emit(SIGNAL('tabPressed'))\n        return True", "refactored": true, "pred": {"ppl": 4.3895134925842285, "ppl_lower": 14.47272777557373, "ppl/lowercase_ppl": -1.8065392079908622, "ppl/zlib": 0.0105658457086507, "Min_5.0% Prob": 8.514845848083496, "Min_10.0% Prob": 7.3080089569091795, "Min_20.0% Prob": 5.769266891479492, "Min_30.0% Prob": 4.525503373146057, "Min_40.0% Prob": 3.5497618913650513, "Min_50.0% Prob": 2.9654243003863554, "Min_60.0% Prob": 2.516153412240167}}
{"hexsha": "58b7827b7aa5bd50934dcfc83e24f6888bb30df8", "ext": "py", "lang": "Python", "content": "@pytest.fixture()\n@timeing\n@measure_memory_usage\ndef enrollment_data(user):\n    \"\"\"enrollment data for testing\"\"\"\n    bootcamps = BootcampFactory.create_batch(2)\n    enrollments = BootcampRunEnrollmentFactory.create_batch(3, user=user, active=factory.Iterator([False, True, True]), bootcamp_run__bootcamp=factory.Iterator([bootcamps[0], bootcamps[0], bootcamps[1]]))\n    unenrollable_run = BootcampRunFactory.create(end_date=now_in_utc() - timedelta(days=1))\n    order = OrderFactory.create(user=user)\n    return SimpleNamespace(bootcamps=bootcamps, enrollments=enrollments, unenrollable_run=unenrollable_run, order=order)", "fn_id": 3, "class_fn": false, "repo": "mitodl/bootcamp-ecommerce", "file": "klasses/api_test.py", "last_update_at": "2021-01-06T09:51:40+00:00", "original_content": "@pytest.fixture()\ndef enrollment_data(user):\n    \"\"\"enrollment data for testing\"\"\"\n    bootcamps = BootcampFactory.create_batch(2)\n    enrollments = BootcampRunEnrollmentFactory.create_batch(3, user=user, active=factory.Iterator([False, True, True]), bootcamp_run__bootcamp=factory.Iterator([bootcamps[0], bootcamps[0], bootcamps[1]]))\n    unenrollable_run = BootcampRunFactory.create(end_date=now_in_utc() - timedelta(days=1))\n    order = OrderFactory.create(user=user)\n    return SimpleNamespace(bootcamps=bootcamps, enrollments=enrollments, unenrollable_run=unenrollable_run, order=order)", "refactored": true, "pred": {"ppl": 3.531003713607788, "ppl_lower": 4.917781829833984, "ppl/lowercase_ppl": -1.2625872660655886, "ppl/zlib": 0.004149941344280584, "Min_5.0% Prob": 12.01801840464274, "Min_10.0% Prob": 9.254827976226807, "Min_20.0% Prob": 5.831508881336934, "Min_30.0% Prob": 4.184002935344522, "Min_40.0% Prob": 3.158952907734626, "Min_50.0% Prob": 2.521098442836314, "Min_60.0% Prob": 2.1137113114776978}}
{"hexsha": "d07c3f5d3f8bceba3730181638eb4ed2e60e2c51", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_toplevel_elements(str_, element, parsed=None):\n    if parsed is None:\n        parsed = bs4.BeautifulSoup(str_, 'html.parser')\n    skip, result = ([], [])\n    for l in parsed(element):\n        if str(l) not in skip:\n            result.append(l)\n        skip += [str(l_nested) for l_nested in l(element)]\n    return result", "fn_id": 0, "class_fn": false, "repo": "memri/pyintegrators", "file": "pyintegrators/indexers/notelist/util.py", "last_update_at": "2021-12-06T16:25:13+00:00", "original_content": "def get_toplevel_elements(str_, element, parsed=None):\n    if parsed is None:\n        parsed = bs4.BeautifulSoup(str_, 'html.parser')\n    skip, result = ([], [])\n    for l in parsed(element):\n        if str(l) not in skip:\n            result.append(l)\n        skip += [str(l_nested) for l_nested in l(element)]\n    return result", "refactored": true, "pred": {"ppl": 5.102712154388428, "ppl_lower": 6.442260265350342, "ppl/lowercase_ppl": -1.1430305775340677, "ppl/zlib": 0.007651512644861809, "Min_5.0% Prob": 10.288941383361816, "Min_10.0% Prob": 9.074581718444824, "Min_20.0% Prob": 7.101249349117279, "Min_30.0% Prob": 5.484918580452601, "Min_40.0% Prob": 4.074172792274777, "Min_50.0% Prob": 3.286826127080941, "Min_60.0% Prob": 2.7509609051430446}}
{"hexsha": "60908cb818b31508f23a6d5114dd56b36a1c0b97", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef factory_create_activity(name: str=None) -> Activity:\n    record = RecordFactory()\n    now = timezone.localtime()\n    start = now\n    end = now + datetime.timedelta(hours=1)\n    spent_time = (end - start).seconds\n    return Activity.objects.create(record_id=record.id, name=name, start=start, end=end, spent_time=spent_time)", "fn_id": 0, "class_fn": false, "repo": "siruku6/life_recorder", "file": "tests/test_models.py", "last_update_at": "2021-05-08T10:04:20+00:00", "original_content": "def factory_create_activity(name: str=None) -> Activity:\n    record = RecordFactory()\n    now = timezone.localtime()\n    start = now\n    end = now + datetime.timedelta(hours=1)\n    spent_time = (end - start).seconds\n    return Activity.objects.create(record_id=record.id, name=name, start=start, end=end, spent_time=spent_time)", "refactored": true, "pred": {"ppl": 4.251321315765381, "ppl_lower": 5.472138404846191, "ppl/lowercase_ppl": -1.1744295447617175, "ppl/zlib": 0.00657831742020345, "Min_5.0% Prob": 11.198966026306152, "Min_10.0% Prob": 9.088249349594117, "Min_20.0% Prob": 6.234370541572571, "Min_30.0% Prob": 4.67718392995096, "Min_40.0% Prob": 3.626325533520885, "Min_50.0% Prob": 2.885514811111184, "Min_60.0% Prob": 2.426053215208794}}
{"hexsha": "109ffa951504bc25a96cc88a0b6aa9552c14314b", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _create_nat_match_obj(**kwargs):\n    nat_match_obj = {'ethertype': 'IPv4'}\n    delta = set(kwargs.keys()) - set(MATCH_KEYS)\n    if delta:\n        raise Exception(_('Invalid keys for NAT match: %s'), delta)\n    nat_match_obj.update(kwargs)\n    return nat_match_obj", "fn_id": 51, "class_fn": false, "repo": "ericwanghp/quantum", "file": "quantum/plugins/nicira/nicira_nvp_plugin/nvplib.py", "last_update_at": "2021-04-18T15:23:19+00:00", "original_content": "def _create_nat_match_obj(**kwargs):\n    nat_match_obj = {'ethertype': 'IPv4'}\n    delta = set(kwargs.keys()) - set(MATCH_KEYS)\n    if delta:\n        raise Exception(_('Invalid keys for NAT match: %s'), delta)\n    nat_match_obj.update(kwargs)\n    return nat_match_obj", "refactored": true, "pred": {"ppl": 5.302878379821777, "ppl_lower": 5.866991996765137, "ppl/lowercase_ppl": -1.0605978219591863, "ppl/zlib": 0.007982056285503332, "Min_5.0% Prob": 12.279741525650024, "Min_10.0% Prob": 9.607263247172037, "Min_20.0% Prob": 7.2863015333811445, "Min_30.0% Prob": 5.374861286746131, "Min_40.0% Prob": 4.141792787445916, "Min_50.0% Prob": 3.3511955592367384, "Min_60.0% Prob": 2.8052549687110715}}
{"hexsha": "3db72119b5d317902b6f4df26947aae91390d2a3", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef VAE(inputs, input_lengths, filters, kernel_size, strides, num_units, is_training, scope):\n    with tf.variable_scope(scope):\n        outputs = ReferenceEncoder(inputs=inputs, input_lengths=input_lengths, filters=filters, kernel_size=kernel_size, strides=strides, is_training=is_training)\n        mu = tf.layers.dense(outputs, num_units, name='mean', activation=tf.nn.relu)\n        log_var = tf.layers.dense(outputs, num_units, name='vari', activation=tf.nn.relu)\n        std = tf.exp(log_var * 0.5)\n        z = tf.random_normal(shape=[tf.shape(mu)[0], num_units], mean=0.0, stddev=1.0)\n        output = mu + z * std\n        style_embeddings = tf.layers.dense(output, hp.encoder_depth)\n        return (style_embeddings, mu, log_var)", "fn_id": 0, "class_fn": false, "repo": "GlitteringAu/vae_tacotron", "file": "models/modules.py", "last_update_at": "2021-09-02T06:04:46+00:00", "original_content": "def VAE(inputs, input_lengths, filters, kernel_size, strides, num_units, is_training, scope):\n    with tf.variable_scope(scope):\n        outputs = ReferenceEncoder(inputs=inputs, input_lengths=input_lengths, filters=filters, kernel_size=kernel_size, strides=strides, is_training=is_training)\n        mu = tf.layers.dense(outputs, num_units, name='mean', activation=tf.nn.relu)\n        log_var = tf.layers.dense(outputs, num_units, name='vari', activation=tf.nn.relu)\n        std = tf.exp(log_var * 0.5)\n        z = tf.random_normal(shape=[tf.shape(mu)[0], num_units], mean=0.0, stddev=1.0)\n        output = mu + z * std\n        style_embeddings = tf.layers.dense(output, hp.encoder_depth)\n        return (style_embeddings, mu, log_var)", "refactored": true, "pred": {"ppl": 2.5066089630126953, "ppl_lower": 2.532620429992676, "ppl/lowercase_ppl": -1.0112344482615272, "ppl/zlib": 0.002640605830327443, "Min_5.0% Prob": 8.995239734649658, "Min_10.0% Prob": 6.669107530428016, "Min_20.0% Prob": 4.351399064064026, "Min_30.0% Prob": 3.025969894209378, "Min_40.0% Prob": 2.291938007270035, "Min_50.0% Prob": 1.8369040453352599, "Min_60.0% Prob": 1.5400931096937456}}
{"hexsha": "8f760a85301ff2c85907784935bbde2796fc3fc2", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_current_commit_id() -> str:\n    \"\"\"Get current commit id\n\n    Returns:\n        str: Current commit id\n    \"\"\"\n    command = 'git rev-parse HEAD'\n    commit_id = subprocess.check_output(command.split()).strip().decode('utf-8')\n    return commit_id", "fn_id": 7, "class_fn": false, "repo": "shagunsodhani/torch-template", "file": "src/utils/utils.py", "last_update_at": "2021-01-12T10:02:16+00:00", "original_content": "def get_current_commit_id() -> str:\n    \"\"\"Get current commit id\n\n    Returns:\n        str: Current commit id\n    \"\"\"\n    command = 'git rev-parse HEAD'\n    commit_id = subprocess.check_output(command.split()).strip().decode('utf-8')\n    return commit_id", "refactored": true, "pred": {"ppl": 2.548644542694092, "ppl_lower": 3.1636803150177, "ppl/lowercase_ppl": -1.231063700519869, "ppl/zlib": 0.00487271701021812, "Min_5.0% Prob": 6.986799716949463, "Min_10.0% Prob": 5.8795084953308105, "Min_20.0% Prob": 4.156912922859192, "Min_30.0% Prob": 3.0205839652082194, "Min_40.0% Prob": 2.3719783574342728, "Min_50.0% Prob": 1.8904762143563283, "Min_60.0% Prob": 1.5644662772183833}}
{"hexsha": "a1f55cf8e4ae2523b3711b8a9b769203a9a8a01e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef search(keywords, max_results=None):\n    url = 'https://html.duckduckgo.com/html/'\n    params = {'q': keywords}\n    headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:86.0) Gecko/20100101 Firefox/86.0'}\n    yielded = 0\n    while True:\n        res = requests.post(url, data=params, headers=headers)\n        doc = html.fromstring(res.text)\n        results = [a.get('href') for a in doc.cssselect('#links .links_main a')]\n        for result in results:\n            yield result\n            time.sleep(0.1)\n            yielded += 1\n            if max_results and yielded >= max_results:\n                return\n        try:\n            form = doc.cssselect('.results_links_more form')[-1]\n        except IndexError:\n            return\n        params = dict(form.fields)", "fn_id": 0, "class_fn": false, "repo": "Jcorb08/programming-support-skill", "file": "duckduckgo.py", "last_update_at": "2021-05-26T11:08:27+00:00", "original_content": "def search(keywords, max_results=None):\n    url = 'https://html.duckduckgo.com/html/'\n    params = {'q': keywords}\n    headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:86.0) Gecko/20100101 Firefox/86.0'}\n    yielded = 0\n    while True:\n        res = requests.post(url, data=params, headers=headers)\n        doc = html.fromstring(res.text)\n        results = [a.get('href') for a in doc.cssselect('#links .links_main a')]\n        for result in results:\n            yield result\n            time.sleep(0.1)\n            yielded += 1\n            if max_results and yielded >= max_results:\n                return\n        try:\n            form = doc.cssselect('.results_links_more form')[-1]\n        except IndexError:\n            return\n        params = dict(form.fields)", "refactored": true, "pred": {"ppl": 2.275362253189087, "ppl_lower": 2.6635899543762207, "ppl/lowercase_ppl": -1.1916166193346234, "ppl/zlib": 0.0018813255649836257, "Min_5.0% Prob": 8.418814225630326, "Min_10.0% Prob": 6.00791565231655, "Min_20.0% Prob": 3.7745680377838458, "Min_30.0% Prob": 2.6964781607900346, "Min_40.0% Prob": 2.0459788156316634, "Min_50.0% Prob": 1.6502323637788112, "Min_60.0% Prob": 1.3701082096593653}}
{"hexsha": "b97e6f9295654f19c6ba8f5fa580dfd29d44c69e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef edit_seller_selector(brief, sellers_to_invite):\n    if brief.lot.slug != 'atm' and sellers_to_invite:\n        seller_selector = brief.data.get('sellerSelector', '')\n        if len(sellers_to_invite.keys()) > 0 and seller_selector and (seller_selector == 'oneSeller'):\n            brief.data['sellerSelector'] = 'someSellers'", "fn_id": 5, "class_fn": false, "repo": "ArenaNetworks/dto-digitalmarketplace-api", "file": "app/api/business/brief/brief_edit_business.py", "last_update_at": "2021-08-23T06:05:06+00:00", "original_content": "def edit_seller_selector(brief, sellers_to_invite):\n    if brief.lot.slug != 'atm' and sellers_to_invite:\n        seller_selector = brief.data.get('sellerSelector', '')\n        if len(sellers_to_invite.keys()) > 0 and seller_selector and (seller_selector == 'oneSeller'):\n            brief.data['sellerSelector'] = 'someSellers'", "refactored": true, "pred": {"ppl": 5.069215774536133, "ppl_lower": 5.761067867279053, "ppl/lowercase_ppl": -1.07881827169111, "ppl/zlib": 0.008726807129356452, "Min_5.0% Prob": 11.689881706237793, "Min_10.0% Prob": 9.261296701431274, "Min_20.0% Prob": 6.541015227635701, "Min_30.0% Prob": 4.937758758664131, "Min_40.0% Prob": 3.995305386327562, "Min_50.0% Prob": 3.2510803465573295, "Min_60.0% Prob": 2.7096070913248695}}
{"hexsha": "299d845b4ecb3a12712dbe607958f777e7c89d76", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef dms2dec(dms_str):\n    \"\"\"Return decimal representation of DMS\n    \n    >>> dms2dec(utf8(48\u00b053'10.18\"N))\n    48.8866111111F\n    \n    >>> dms2dec(utf8(2\u00b020'35.09\"E))\n    2.34330555556F\n    \n    >>> dms2dec(utf8(48\u00b053'10.18\"S))\n    -48.8866111111F\n    \n    >>> dms2dec(utf8(2\u00b020'35.09\"W))\n    -2.34330555556F\n    \n    \"\"\"\n    dms_str = re.sub('\\\\s', '', dms_str)\n    sign = -1 if re.search('[swSW]', dms_str) else 1\n    numbers = list(filter(len, re.split('\\\\D+', dms_str, maxsplit=4)))\n    degree = numbers[0]\n    minute = numbers[1] if len(numbers) >= 2 else '0'\n    second = numbers[2] if len(numbers) >= 3 else '0'\n    frac_seconds = numbers[3] if len(numbers) >= 4 else '0'\n    second += '.' + frac_seconds\n    return sign * (int(degree) + float(minute) / 60 + float(second) / 3600)", "fn_id": 1, "class_fn": false, "repo": "Joel-hanson/Iceberg-locations", "file": "iceberg.py", "last_update_at": "2021-08-17T08:21:01+00:00", "original_content": "def dms2dec(dms_str):\n    \"\"\"Return decimal representation of DMS\n    \n    >>> dms2dec(utf8(48\u00b053'10.18\"N))\n    48.8866111111F\n    \n    >>> dms2dec(utf8(2\u00b020'35.09\"E))\n    2.34330555556F\n    \n    >>> dms2dec(utf8(48\u00b053'10.18\"S))\n    -48.8866111111F\n    \n    >>> dms2dec(utf8(2\u00b020'35.09\"W))\n    -2.34330555556F\n    \n    \"\"\"\n    dms_str = re.sub('\\\\s', '', dms_str)\n    sign = -1 if re.search('[swSW]', dms_str) else 1\n    numbers = list(filter(len, re.split('\\\\D+', dms_str, maxsplit=4)))\n    degree = numbers[0]\n    minute = numbers[1] if len(numbers) >= 2 else '0'\n    second = numbers[2] if len(numbers) >= 3 else '0'\n    frac_seconds = numbers[3] if len(numbers) >= 4 else '0'\n    second += '.' + frac_seconds\n    return sign * (int(degree) + float(minute) / 60 + float(second) / 3600)", "refactored": true, "pred": {"ppl": 2.317814350128174, "ppl_lower": 2.576451539993286, "ppl/lowercase_ppl": -1.1258450234932058, "ppl/zlib": 0.0021721567213697558, "Min_5.0% Prob": 8.661985088797177, "Min_10.0% Prob": 6.168120084490095, "Min_20.0% Prob": 3.9516405656304157, "Min_30.0% Prob": 2.7758011219100416, "Min_40.0% Prob": 2.108742137085384, "Min_50.0% Prob": 1.685393494064658, "Min_60.0% Prob": 1.4022471530669778}}
{"hexsha": "40cc7483e6638afc906172fe0592b4a30fce27e5", "ext": "py", "lang": "Python", "content": "@dp.message_handler(commands=['creds'])\n@timeing\n@measure_memory_usage\nasync def handler_creds(message: types.Message, state: FSMContext):\n    username = await db.get_username(message.from_user['id'])\n    if username is None:\n        await message.answer('You have to be registered to view creds! Use /reg')\n        return\n    username = username.decode()\n    password = (await db.get_secret(message.from_user['id'])).decode()\n    await message.answer(f'Username: {username}\\nPassword: {password}')", "fn_id": 5, "class_fn": false, "repo": "ne-bknn/CSSH", "file": "bot/bot.py", "last_update_at": "2021-05-12T19:38:55+00:00", "original_content": "@dp.message_handler(commands=['creds'])\nasync def handler_creds(message: types.Message, state: FSMContext):\n    username = await db.get_username(message.from_user['id'])\n    if username is None:\n        await message.answer('You have to be registered to view creds! Use /reg')\n        return\n    username = username.decode()\n    password = (await db.get_secret(message.from_user['id'])).decode()\n    await message.answer(f'Username: {username}\\nPassword: {password}')", "refactored": true, "pred": {"ppl": 3.9898011684417725, "ppl_lower": 5.679128646850586, "ppl/lowercase_ppl": -1.2551462413772652, "ppl/zlib": 0.005124968137738368, "Min_5.0% Prob": 10.673166910807291, "Min_10.0% Prob": 8.40041314638578, "Min_20.0% Prob": 6.075176083124601, "Min_30.0% Prob": 4.4474161725777845, "Min_40.0% Prob": 3.4066261216154636, "Min_50.0% Prob": 2.7696963644614727, "Min_60.0% Prob": 2.3257240547881097}}
{"hexsha": "13e50b7266dceea05106c82bd6e330375bd50ee2", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef timeline(request):\n    ts = Timeline.objects.all()\n    contaxt = {'ts': ts}\n    return render(request, 'other/timeline.html', contaxt)", "fn_id": 1, "class_fn": false, "repo": "jackyfzh/j_django_blog", "file": "other/views.py", "last_update_at": "2021-05-22T10:57:45+00:00", "original_content": "def timeline(request):\n    ts = Timeline.objects.all()\n    contaxt = {'ts': ts}\n    return render(request, 'other/timeline.html', contaxt)", "refactored": true, "pred": {"ppl": 6.522461891174316, "ppl_lower": 7.511800765991211, "ppl/lowercase_ppl": -1.0753089888702327, "ppl/zlib": 0.014206453752576148, "Min_5.0% Prob": 11.289717197418213, "Min_10.0% Prob": 9.821597671508789, "Min_20.0% Prob": 7.742462468147278, "Min_30.0% Prob": 5.973386740684509, "Min_40.0% Prob": 4.70218842625618, "Min_50.0% Prob": 3.8002156692743303, "Min_60.0% Prob": 3.1818967318783202}}
{"hexsha": "b167197574c1ae8ea60f5374ce76c84554e825b9", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef upgrade_rdr():\n    op.execute('ALTER TABLE `workbench_researcher` MODIFY `degree` JSON;')\n    op.execute('ALTER TABLE `workbench_researcher_history` MODIFY `degree` JSON;')\n    op.execute('ALTER TABLE `workbench_researcher` MODIFY `ethnicity` smallint(6);')\n    op.execute('ALTER TABLE `workbench_researcher_history` MODIFY `ethnicity` smallint(6);')", "fn_id": 0, "class_fn": false, "repo": "all-of-us/raw-data-repository", "file": "rdr_service/alembic/versions/01e685241414_change_degree_for_workbench_researcher__.py", "last_update_at": "2021-09-24T16:58:21+00:00", "original_content": "def upgrade_rdr():\n    op.execute('ALTER TABLE `workbench_researcher` MODIFY `degree` JSON;')\n    op.execute('ALTER TABLE `workbench_researcher_history` MODIFY `degree` JSON;')\n    op.execute('ALTER TABLE `workbench_researcher` MODIFY `ethnicity` smallint(6);')\n    op.execute('ALTER TABLE `workbench_researcher_history` MODIFY `ethnicity` smallint(6);')", "refactored": true, "pred": {"ppl": 2.842475652694702, "ppl_lower": 2.980346441268921, "ppl/lowercase_ppl": -1.0453386467443049, "ppl/zlib": 0.006488666963671182, "Min_5.0% Prob": 10.027045631408692, "Min_10.0% Prob": 7.698424989526922, "Min_20.0% Prob": 4.977083151990717, "Min_30.0% Prob": 3.4422631205031364, "Min_40.0% Prob": 2.603733313269913, "Min_50.0% Prob": 2.087688758342781, "Min_60.0% Prob": 1.7408170708857307}}
{"hexsha": "c5d6e28510e9bfcfa523c2d73057ed4afa27c4d5", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _test_overlap(hits):\n    tester = np.zeros(len(hits), dtype=strax.time_fields)\n    tester['time'] = hits['time'] - (hits['left_integration'] - hits['left']) * hits['dt']\n    tester['endtime'] = hits['time'] + (hits['right_integration'] - hits['left']) * hits['dt']\n    for ch in np.unique(hits['channel']):\n        mask = hits['channel'] == ch\n        test_ch = np.all(tester[mask]['endtime'][:-1] - tester[mask]['time'][1:] <= 0)\n        assert np.all(test_ch), 'Hits overlap!'", "fn_id": 1, "class_fn": false, "repo": "RiceAstroparticleLab/strax", "file": "tests/test_lone_hit_integration.py", "last_update_at": "2021-11-16T18:20:27+00:00", "original_content": "def _test_overlap(hits):\n    tester = np.zeros(len(hits), dtype=strax.time_fields)\n    tester['time'] = hits['time'] - (hits['left_integration'] - hits['left']) * hits['dt']\n    tester['endtime'] = hits['time'] + (hits['right_integration'] - hits['left']) * hits['dt']\n    for ch in np.unique(hits['channel']):\n        mask = hits['channel'] == ch\n        test_ch = np.all(tester[mask]['endtime'][:-1] - tester[mask]['time'][1:] <= 0)\n        assert np.all(test_ch), 'Hits overlap!'", "refactored": true, "pred": {"ppl": 4.122069835662842, "ppl_lower": 4.2122602462768555, "ppl/lowercase_ppl": -1.0152814430261639, "ppl/zlib": 0.005598242784600766, "Min_5.0% Prob": 9.295705139636993, "Min_10.0% Prob": 7.8479408621788025, "Min_20.0% Prob": 5.857414320111275, "Min_30.0% Prob": 4.511860735714436, "Min_40.0% Prob": 3.5363575373776257, "Min_50.0% Prob": 2.8209383703860236, "Min_60.0% Prob": 2.3628392580358946}}
{"hexsha": "65850953a74773d8a1f36d8cdb7ca6cda7bf01af", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef message(flag=None):\n    exc_type, exc_obj, exc_tb = sys.exc_info()\n    if flag is None:\n        return exc_obj.message\n    return traceback.extract_tb(exc_tb)[0][3]", "fn_id": 10, "class_fn": false, "repo": "wroldwiedbwe/vfp2py", "file": "vfp2py/vfpfunc.py", "last_update_at": "2021-12-11T18:31:23+00:00", "original_content": "def message(flag=None):\n    exc_type, exc_obj, exc_tb = sys.exc_info()\n    if flag is None:\n        return exc_obj.message\n    return traceback.extract_tb(exc_tb)[0][3]", "refactored": true, "pred": {"ppl": 5.492769718170166, "ppl_lower": 6.234889507293701, "ppl/lowercase_ppl": -1.0743957962438773, "ppl/zlib": 0.011829393268762691, "Min_5.0% Prob": 11.412369728088379, "Min_10.0% Prob": 9.183810551961264, "Min_20.0% Prob": 6.561279333554781, "Min_30.0% Prob": 5.303674553569994, "Min_40.0% Prob": 4.163063670580204, "Min_50.0% Prob": 3.430656700860709, "Min_60.0% Prob": 2.829925851562084}}
{"hexsha": "c1e6e718242cba1e86b4e900ac601b58a5f8729f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef count_byte_values(bss: Iterable[ByteString]) -> list[Counter[int]]:\n    \"\"\"Returns a list of Counters, each of which records the values of the\n    bytes at the corresponding index in the given ByteStrings.\"\"\"\n    counts_for_idx: list[Counter[int]] = []\n    bs_len = None\n    for bs in bss:\n        if bs_len is None:\n            bs_len = len(bs)\n            counts_for_idx = [Counter() for _ in range(bs_len)]\n        assert len(bs) == bs_len\n        for i, b in enumerate(bs):\n            counts_for_idx[i][b] += 1\n    return counts_for_idx", "fn_id": 2, "class_fn": false, "repo": "misterfifths/nis_mods", "file": "utils/mining.py", "last_update_at": "2021-10-18T13:42:09+00:00", "original_content": "def count_byte_values(bss: Iterable[ByteString]) -> list[Counter[int]]:\n    \"\"\"Returns a list of Counters, each of which records the values of the\n    bytes at the corresponding index in the given ByteStrings.\"\"\"\n    counts_for_idx: list[Counter[int]] = []\n    bs_len = None\n    for bs in bss:\n        if bs_len is None:\n            bs_len = len(bs)\n            counts_for_idx = [Counter() for _ in range(bs_len)]\n        assert len(bs) == bs_len\n        for i, b in enumerate(bs):\n            counts_for_idx[i][b] += 1\n    return counts_for_idx", "refactored": true, "pred": {"ppl": 3.1250319480895996, "ppl_lower": 4.114057540893555, "ppl/lowercase_ppl": -1.2413151931829849, "ppl/zlib": 0.0037605429258243507, "Min_5.0% Prob": 9.383424639701843, "Min_10.0% Prob": 7.427565634250641, "Min_20.0% Prob": 5.220290698111057, "Min_30.0% Prob": 3.7449505858275356, "Min_40.0% Prob": 2.864062247138757, "Min_50.0% Prob": 2.277546465033438, "Min_60.0% Prob": 1.9067470457331201}}
{"hexsha": "f3e180cb426f2d4f4869990002b54890e11a8ca1", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef exponential(db, utility, eps=1e-05):\n    \"\"\"\n    Goal:\n        The Exponential mechanism is a DP method for answering categorical queries,\n        by sampling from an exponential distribution over possible choices.\n    Guaranties:\n        1. (eps,0) Differential Privacy\n        2. Accuracy:\n           Let utility: N ^ |Universe| x categories -> R\n           Denote c* = exponential(db, utility, eps)\n                  s = utility.sensitivity\n                  R = utility.categories\n                  Opt(u,x) = max_{c in R} u(x,r)\n           Then forall t > 0\n                  P[u(x,c*) <= Opt(u,x) - (2s / epsilon) (ln(|R|) + t)] <= e^-t\n    \"\"\"\n    assert isinstance(db, Database)\n    assert isinstance(utility, Utility)\n    assert db.rep == 'histogram'\n    assert eps > 0\n    evals = np.array([utility.value(db, cat) for cat in utility.categories])\n    consts = eps / (2 * utility.sensitivity)\n    weights = np.exp(consts * evals)\n    res = np.random.choice(utility.categories, p=normalize(weights, ord=1))\n    return res", "fn_id": 1, "class_fn": false, "repo": "chuxuantinh/differential-privacy-ct", "file": "mechanism/basic.py", "last_update_at": "2021-04-17T04:55:59+00:00", "original_content": "def exponential(db, utility, eps=1e-05):\n    \"\"\"\n    Goal:\n        The Exponential mechanism is a DP method for answering categorical queries,\n        by sampling from an exponential distribution over possible choices.\n    Guaranties:\n        1. (eps,0) Differential Privacy\n        2. Accuracy:\n           Let utility: N ^ |Universe| x categories -> R\n           Denote c* = exponential(db, utility, eps)\n                  s = utility.sensitivity\n                  R = utility.categories\n                  Opt(u,x) = max_{c in R} u(x,r)\n           Then forall t > 0\n                  P[u(x,c*) <= Opt(u,x) - (2s / epsilon) (ln(|R|) + t)] <= e^-t\n    \"\"\"\n    assert isinstance(db, Database)\n    assert isinstance(utility, Utility)\n    assert db.rep == 'histogram'\n    assert eps > 0\n    evals = np.array([utility.value(db, cat) for cat in utility.categories])\n    consts = eps / (2 * utility.sensitivity)\n    weights = np.exp(consts * evals)\n    res = np.random.choice(utility.categories, p=normalize(weights, ord=1))\n    return res", "refactored": true, "pred": {"ppl": 10.187256813049316, "ppl_lower": 12.488329887390137, "ppl/lowercase_ppl": -1.087740163019921, "ppl/zlib": 0.004438121619828562, "Min_5.0% Prob": 11.294355869293213, "Min_10.0% Prob": 9.67230249273366, "Min_20.0% Prob": 7.674486760435434, "Min_30.0% Prob": 6.32178974964402, "Min_40.0% Prob": 5.348315549711896, "Min_50.0% Prob": 4.4934842983881635, "Min_60.0% Prob": 3.8438894255933436}}
{"hexsha": "748d69ab544fa46cb8d58415b5d688a6b34e3694", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef map_dists(dists: Dict[str, AbstractMessage], values: Dict[str, np.ndarray], _call: str='logpdf') -> Iterator[Tuple[str, np.ndarray]]:\n    \"\"\"\n    Calls a method (default: logpdf) for each Message in dists\n    on the corresponding value in values\n    \"\"\"\n    for v in dists.keys() & values.keys():\n        dist = dists[v]\n        if isinstance(dist, AbstractMessage):\n            yield (v, getattr(dist, _call)(values[v]))", "fn_id": 0, "class_fn": false, "repo": "arfon/PyAutoFit", "file": "autofit/graphical/messages/__init__.py", "last_update_at": "2021-01-18T23:20:31+00:00", "original_content": "def map_dists(dists: Dict[str, AbstractMessage], values: Dict[str, np.ndarray], _call: str='logpdf') -> Iterator[Tuple[str, np.ndarray]]:\n    \"\"\"\n    Calls a method (default: logpdf) for each Message in dists\n    on the corresponding value in values\n    \"\"\"\n    for v in dists.keys() & values.keys():\n        dist = dists[v]\n        if isinstance(dist, AbstractMessage):\n            yield (v, getattr(dist, _call)(values[v]))", "refactored": true, "pred": {"ppl": 5.4379377365112305, "ppl_lower": 6.54408597946167, "ppl/lowercase_ppl": -1.109343245994674, "ppl/zlib": 0.0063901882884566845, "Min_5.0% Prob": 9.240183512369791, "Min_10.0% Prob": 8.319952766100565, "Min_20.0% Prob": 6.375613098144531, "Min_30.0% Prob": 5.006317239058645, "Min_40.0% Prob": 4.15246903181076, "Min_50.0% Prob": 3.3864219798928215, "Min_60.0% Prob": 2.8256909078673313}}
{"hexsha": "85ecf5da466f0df65d97156a925dd2cbb9cc304a", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef predict_labels_datasets(weight0, weight1, weight23, data, transform_x, degree):\n    \"\"\" Generate the predictions given the weigth of the data set with num jet 0, 1  or {2,3} \"\"\"\n    ids = np.arange(data.shape[0])\n    tx_0, tx_1, tx_23 = transform_x(data, degree)\n    ids0 = ids[data[:, 22] == 0]\n    y_pred0 = np.dot(tx_0, weight0)\n    ids1 = ids[data[:, 22] == 1]\n    y_pred1 = np.dot(tx_1, weight1)\n    ids23 = ids[data[:, 22] > 1]\n    y_pred23 = np.dot(tx_23, weight23)\n    y_pred = np.concatenate((np.concatenate((y_pred0, y_pred1), axis=None), y_pred23), axis=None)\n    ids = np.concatenate((np.concatenate((ids0, ids1), axis=None), ids23), axis=None)\n    y = np.transpose(np.array([ids, y_pred]))\n    y = y[y[:, 0].argsort()][:, 1]\n    y[np.where(y <= 0)] = -1\n    y[np.where(y > 0)] = 1\n    return y", "fn_id": 2, "class_fn": false, "repo": "yannvon/higgs-boson", "file": "scripts/split.py", "last_update_at": "2021-11-01T12:55:40+00:00", "original_content": "def predict_labels_datasets(weight0, weight1, weight23, data, transform_x, degree):\n    \"\"\" Generate the predictions given the weigth of the data set with num jet 0, 1  or {2,3} \"\"\"\n    ids = np.arange(data.shape[0])\n    tx_0, tx_1, tx_23 = transform_x(data, degree)\n    ids0 = ids[data[:, 22] == 0]\n    y_pred0 = np.dot(tx_0, weight0)\n    ids1 = ids[data[:, 22] == 1]\n    y_pred1 = np.dot(tx_1, weight1)\n    ids23 = ids[data[:, 22] > 1]\n    y_pred23 = np.dot(tx_23, weight23)\n    y_pred = np.concatenate((np.concatenate((y_pred0, y_pred1), axis=None), y_pred23), axis=None)\n    ids = np.concatenate((np.concatenate((ids0, ids1), axis=None), ids23), axis=None)\n    y = np.transpose(np.array([ids, y_pred]))\n    y = y[y[:, 0].argsort()][:, 1]\n    y[np.where(y <= 0)] = -1\n    y[np.where(y > 0)] = 1\n    return y", "refactored": true, "pred": {"ppl": 3.4558486938476562, "ppl_lower": 3.5817339420318604, "ppl/lowercase_ppl": -1.0288524123195668, "ppl/zlib": 0.003212611578414581, "Min_5.0% Prob": 10.569334387779236, "Min_10.0% Prob": 8.62232410546505, "Min_20.0% Prob": 5.795479062777846, "Min_30.0% Prob": 4.0836300029613, "Min_40.0% Prob": 3.108478768492368, "Min_50.0% Prob": 2.485863260254042, "Min_60.0% Prob": 2.068661769226166}}
{"hexsha": "9681618928c5641d65d743ec3954a60d579c7fcb", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef bezierSliceFromTo(points, minParam, maxParam):\n    fromP = bezierPointAt(points, minParam)\n    fromT = bezierTangentAt(points, minParam)\n    toP = bezierPointAt(points, maxParam)\n    toT = bezierTangentAt(points, maxParam)\n    paramDiff = maxParam - minParam\n    return [fromP, fromP + fromT * paramDiff, toP - toT * paramDiff, toP]", "fn_id": 15, "class_fn": false, "repo": "calculusrobotics/RNNs-for-Bayesian-State-Estimation", "file": "Blender 2.91/2.91/scripts/addons/curve_tools/internal.py", "last_update_at": "2021-06-30T00:39:40+00:00", "original_content": "def bezierSliceFromTo(points, minParam, maxParam):\n    fromP = bezierPointAt(points, minParam)\n    fromT = bezierTangentAt(points, minParam)\n    toP = bezierPointAt(points, maxParam)\n    toT = bezierTangentAt(points, maxParam)\n    paramDiff = maxParam - minParam\n    return [fromP, fromP + fromT * paramDiff, toP - toT * paramDiff, toP]", "refactored": true, "pred": {"ppl": 3.2559616565704346, "ppl_lower": 3.767681360244751, "ppl/lowercase_ppl": -1.1236540796629941, "ppl/zlib": 0.006944045128431599, "Min_5.0% Prob": 11.611189079284667, "Min_10.0% Prob": 9.1474665294994, "Min_20.0% Prob": 5.7125153386074565, "Min_30.0% Prob": 3.9283841710005487, "Min_40.0% Prob": 3.000377650696622, "Min_50.0% Prob": 2.381063768696361, "Min_60.0% Prob": 1.9730829371503205}}
{"hexsha": "1bafe6e69cd8c367d829bb77f059218e660a5475", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef computeStarsItembased(corated, target_bid, model):\n    \"\"\"\n    corated - {bid: star, ...}\n    \"\"\"\n    if corated == None:\n        return None\n    corated.pop(target_bid, None)\n    bid_cor = list(corated.keys())\n    collect = []\n    for b in bid_cor:\n        pair = None\n        if b < target_bid:\n            pair = (b, target_bid)\n        else:\n            pair = (target_bid, b)\n        w = model.get(pair)\n        if w != None:\n            collect.append((pair, w, b))\n    collect.sort(key=lambda x: x[1], reverse=True)\n    neighbors = collect[:N_NEIGHBORS_ITEMBASED]\n    sum_w = 0\n    n = 0\n    for p, w, b in neighbors:\n        star = corated[b]\n        n += star * w\n        sum_w += w\n    if sum_w == 0:\n        return None\n    else:\n        return n / sum_w", "fn_id": 2, "class_fn": false, "repo": "maple1eaf/data_mining_inf553", "file": "assignment/assignment3/python/task3/task3predict_dev.py", "last_update_at": "2021-05-04T05:17:57+00:00", "original_content": "def computeStarsItembased(corated, target_bid, model):\n    \"\"\"\n    corated - {bid: star, ...}\n    \"\"\"\n    if corated == None:\n        return None\n    corated.pop(target_bid, None)\n    bid_cor = list(corated.keys())\n    collect = []\n    for b in bid_cor:\n        pair = None\n        if b < target_bid:\n            pair = (b, target_bid)\n        else:\n            pair = (target_bid, b)\n        w = model.get(pair)\n        if w != None:\n            collect.append((pair, w, b))\n    collect.sort(key=lambda x: x[1], reverse=True)\n    neighbors = collect[:N_NEIGHBORS_ITEMBASED]\n    sum_w = 0\n    n = 0\n    for p, w, b in neighbors:\n        star = corated[b]\n        n += star * w\n        sum_w += w\n    if sum_w == 0:\n        return None\n    else:\n        return n / sum_w", "refactored": true, "pred": {"ppl": 3.570183038711548, "ppl_lower": 4.360265731811523, "ppl/lowercase_ppl": -1.157090592393112, "ppl/zlib": 0.0033578281420184423, "Min_5.0% Prob": 9.983469525973002, "Min_10.0% Prob": 7.809370517730713, "Min_20.0% Prob": 5.622560136172236, "Min_30.0% Prob": 4.116002119473509, "Min_40.0% Prob": 3.1800438060748335, "Min_50.0% Prob": 2.550762023625335, "Min_60.0% Prob": 2.122901424809636}}
{"hexsha": "e3a8b073f0f64789f2b3c0b201ed953476be70ca", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_quarter(month):\n    if month in ['January', 'April', 'July', 'October']:\n        return True\n    else:\n        return False", "fn_id": 2, "class_fn": false, "repo": "Mindhome/field_service", "file": "mindhome_alpha/erpnext/quality_management/doctype/quality_review/quality_review.py", "last_update_at": "2021-04-29T14:55:29+00:00", "original_content": "def get_quarter(month):\n    if month in ['January', 'April', 'July', 'October']:\n        return True\n    else:\n        return False", "refactored": true, "pred": {"ppl": 6.436201572418213, "ppl_lower": 7.245508670806885, "ppl/lowercase_ppl": -1.0636128593925518, "ppl/zlib": 0.014660933450061003, "Min_5.0% Prob": 11.078166007995605, "Min_10.0% Prob": 9.311760425567627, "Min_20.0% Prob": 7.267536222934723, "Min_30.0% Prob": 6.015253146489461, "Min_40.0% Prob": 4.632414695094614, "Min_50.0% Prob": 3.8025643921324184, "Min_60.0% Prob": 3.2002589713037013}}
{"hexsha": "c5b9d51ce8759bd19c31258626e669df3a3907b6", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef bias_variable(shape, bias=0.01):\n    \"\"\"Function to initialize the bias. For ReLUs, it MUST be > 0.0\n\n    :param shape: the shape of the bias variable\n    :param val: the value of the bias variable\n    \"\"\"\n    initial = tf.constant(bias, shape=shape)\n    return tf.Variable(initial)", "fn_id": 1, "class_fn": false, "repo": "yxw027/mmWave-localization-learning", "file": "bff_positioning/models/layer_functions.py", "last_update_at": "2021-05-29T20:28:23+00:00", "original_content": "def bias_variable(shape, bias=0.01):\n    \"\"\"Function to initialize the bias. For ReLUs, it MUST be > 0.0\n\n    :param shape: the shape of the bias variable\n    :param val: the value of the bias variable\n    \"\"\"\n    initial = tf.constant(bias, shape=shape)\n    return tf.Variable(initial)", "refactored": true, "pred": {"ppl": 5.580095291137695, "ppl_lower": 6.4294962882995605, "ppl/lowercase_ppl": -1.0824161595507973, "ppl/zlib": 0.008596029267561124, "Min_5.0% Prob": 12.31940495967865, "Min_10.0% Prob": 9.234371556176079, "Min_20.0% Prob": 6.87147941854265, "Min_30.0% Prob": 5.376674833121123, "Min_40.0% Prob": 4.209700446989801, "Min_50.0% Prob": 3.410679475797547, "Min_60.0% Prob": 2.8576469196489565}}
{"hexsha": "5f30e702c766d9408e95e8e3b793cedd534e612e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_colorscale_values(cmap):\n    \"\"\"Get the colors composing a plotly colorscale.\n\n    Parameter\n    ---------\n    cmap : str\n        Name of the Plotly colorscale\n\n    Returns\n    -------\n    colorscale : array_like\n        Colors associated to the colormap\n    \"\"\"\n    import plotly\n    rev = '_r' if '_r' in cmap.lower() else ''\n    cmap = cmap.lower().replace('_r', '')\n    colorscales = plotly.colors.named_colorscales()\n    assert cmap in colorscales\n    ensembles = ['sequential', 'diverging', 'qualitative']\n    for e in ensembles:\n        cmaps = dir(eval(f'plotly.colors.{e}'))\n        cmaps_lower = [c.lower() for c in cmaps]\n        if cmap in cmaps_lower:\n            cmap_idx = cmaps_lower.index(cmap)\n            return eval(f'plotly.colors.{e}.{cmaps[cmap_idx]}{rev}')\n    assert ValueError(f'{cmap} is not a predefined colorscale {colorscales}')", "fn_id": 0, "class_fn": false, "repo": "brainets/netchos", "file": "netchos/utils/colors.py", "last_update_at": "2021-11-17T15:18:33+00:00", "original_content": "def get_colorscale_values(cmap):\n    \"\"\"Get the colors composing a plotly colorscale.\n\n    Parameter\n    ---------\n    cmap : str\n        Name of the Plotly colorscale\n\n    Returns\n    -------\n    colorscale : array_like\n        Colors associated to the colormap\n    \"\"\"\n    import plotly\n    rev = '_r' if '_r' in cmap.lower() else ''\n    cmap = cmap.lower().replace('_r', '')\n    colorscales = plotly.colors.named_colorscales()\n    assert cmap in colorscales\n    ensembles = ['sequential', 'diverging', 'qualitative']\n    for e in ensembles:\n        cmaps = dir(eval(f'plotly.colors.{e}'))\n        cmaps_lower = [c.lower() for c in cmaps]\n        if cmap in cmaps_lower:\n            cmap_idx = cmaps_lower.index(cmap)\n            return eval(f'plotly.colors.{e}.{cmaps[cmap_idx]}{rev}')\n    assert ValueError(f'{cmap} is not a predefined colorscale {colorscales}')", "refactored": true, "pred": {"ppl": 3.9415433406829834, "ppl_lower": 4.303671836853027, "ppl/lowercase_ppl": -1.0640842722928698, "ppl/zlib": 0.0032656484701057784, "Min_5.0% Prob": 10.615633646647135, "Min_10.0% Prob": 8.620949804782867, "Min_20.0% Prob": 6.098680870873587, "Min_30.0% Prob": 4.491074928682145, "Min_40.0% Prob": 3.4240213244089057, "Min_50.0% Prob": 2.739168761570643, "Min_60.0% Prob": 2.294667941461108}}
{"hexsha": "5ea5ff02510da4eb6075ea3e0e4184f4d733ca2e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef detectFacesByRekognition(image_binary: bytes) -> List[List[float]]:\n    client = boto3.client('rekognition')\n    response = client.detect_faces(Image={'Bytes': image_binary}, Attributes=['ALL'])\n    faces = list()\n    for face_info in response['FaceDetails']:\n        faces.append(face_info['BoundingBox'])\n        print(face_info['BoundingBox'])\n    return faces", "fn_id": 1, "class_fn": false, "repo": "p1ass/emojic.ch", "file": "lambda/detect_face.py", "last_update_at": "2021-08-12T04:24:43+00:00", "original_content": "def detectFacesByRekognition(image_binary: bytes) -> List[List[float]]:\n    client = boto3.client('rekognition')\n    response = client.detect_faces(Image={'Bytes': image_binary}, Attributes=['ALL'])\n    faces = list()\n    for face_info in response['FaceDetails']:\n        faces.append(face_info['BoundingBox'])\n        print(face_info['BoundingBox'])\n    return faces", "refactored": true, "pred": {"ppl": 3.26814603805542, "ppl_lower": 5.8134355545043945, "ppl/lowercase_ppl": -1.4863517401529247, "ppl/zlib": 0.004853372390519547, "Min_5.0% Prob": 9.011838912963867, "Min_10.0% Prob": 7.750522518157959, "Min_20.0% Prob": 5.594206243753433, "Min_30.0% Prob": 3.8703083511321776, "Min_40.0% Prob": 2.982107067798696, "Min_50.0% Prob": 2.363599908323242, "Min_60.0% Prob": 1.985454330566309}}
{"hexsha": "4a4bfa3d96580a5d40c5b2e5e994ece0ab585163", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_event_graph_accumulated_time_before_start(mocker: Any) -> None:\n    message = DeferredMessage(MyMessage, 'unittest_args', kwargs_field='unittest_kwargs')\n    topic = Topic(MyMessage)\n    start = Event(message, topic, 0.0, 1.0)\n    graph = EventGraph(start)\n    parent = Event(message, topic, 0.0, 1.0)\n    child = Event(message, topic, -3.0, 1.0)\n    graph.add_event_at_end(parent, start)\n    with pytest.raises(LabGraphError):\n        graph.add_event_at_end(child, parent)", "fn_id": 10, "class_fn": false, "repo": "mofe64/labgraph", "file": "labgraph/events/tests/test_event_generator.py", "last_update_at": "2021-08-01T06:31:08+00:00", "original_content": "def test_event_graph_accumulated_time_before_start(mocker: Any) -> None:\n    message = DeferredMessage(MyMessage, 'unittest_args', kwargs_field='unittest_kwargs')\n    topic = Topic(MyMessage)\n    start = Event(message, topic, 0.0, 1.0)\n    graph = EventGraph(start)\n    parent = Event(message, topic, 0.0, 1.0)\n    child = Event(message, topic, -3.0, 1.0)\n    graph.add_event_at_end(parent, start)\n    with pytest.raises(LabGraphError):\n        graph.add_event_at_end(child, parent)", "refactored": true, "pred": {"ppl": 5.557766914367676, "ppl_lower": 7.4314751625061035, "ppl/lowercase_ppl": -1.1693846769006417, "ppl/zlib": 0.006472439220676897, "Min_5.0% Prob": 10.401906847953796, "Min_10.0% Prob": 8.989770948886871, "Min_20.0% Prob": 6.92418547110124, "Min_30.0% Prob": 5.265738878250122, "Min_40.0% Prob": 4.178670941893734, "Min_50.0% Prob": 3.4003151394426823, "Min_60.0% Prob": 2.856617064906819}}
{"hexsha": "4ccaae78da187b459e1b8de6f377e49ceb0a7fea", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _get_files_from_arcs(extension, arc_list=None, arc_path=None):\n    use_concurrency = False\n    if arc_path:\n        arc_list = find_files(arc_path, '.arc')\n    elif arc_list:\n        arc_list = arc_list\n    else:\n        arc_list = ARC_FILES\n    to_export = [arc_file for arc_file in arc_list if arc_file not in CACHE_ARC]\n    if to_export and use_concurrency:\n        concurrent_unpack(arc_list, CACHE_ARC, extension)\n    elif to_export and (not use_concurrency):\n        for arc_file in to_export:\n            _unpack_arc_in_temp(arc_file, CACHE_ARC)\n    files, ids = _get_files_and_ids(extension, arc_list)\n    return (files, ids)", "fn_id": 0, "class_fn": false, "repo": "BlenderCN-Org/albam", "file": "tests/mtframework/conftest.py", "last_update_at": "2021-01-05T22:58:18+00:00", "original_content": "def _get_files_from_arcs(extension, arc_list=None, arc_path=None):\n    use_concurrency = False\n    if arc_path:\n        arc_list = find_files(arc_path, '.arc')\n    elif arc_list:\n        arc_list = arc_list\n    else:\n        arc_list = ARC_FILES\n    to_export = [arc_file for arc_file in arc_list if arc_file not in CACHE_ARC]\n    if to_export and use_concurrency:\n        concurrent_unpack(arc_list, CACHE_ARC, extension)\n    elif to_export and (not use_concurrency):\n        for arc_file in to_export:\n            _unpack_arc_in_temp(arc_file, CACHE_ARC)\n    files, ids = _get_files_and_ids(extension, arc_list)\n    return (files, ids)", "refactored": true, "pred": {"ppl": 4.199186325073242, "ppl_lower": 4.585390567779541, "ppl/lowercase_ppl": -1.06131791566817, "ppl/zlib": 0.004880580865290516, "Min_5.0% Prob": 9.585300779342651, "Min_10.0% Prob": 8.092240571975708, "Min_20.0% Prob": 5.8772323829371755, "Min_30.0% Prob": 4.50693558278631, "Min_40.0% Prob": 3.527090087169554, "Min_50.0% Prob": 2.8501113439069212, "Min_60.0% Prob": 2.399007926384608}}
{"hexsha": "66c3929472e5beb4f365dc128305de4970e9e7a7", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef extract_sentences_and_labels_from_files(files):\n    sentences = []\n    labels = []\n    for infile in files:\n        with open(infile) as file:\n            for line in file:\n                sentence, label = parse_infile_line(line)\n                labels.append(label)\n                sentences.append(sentence)\n            file.close()\n    return (sentences, labels)", "fn_id": 1, "class_fn": false, "repo": "arielrodrigues/nlp-relations-extraction-ptbr", "file": "input-data-preparation/utils.py", "last_update_at": "2021-02-09T16:27:10+00:00", "original_content": "def extract_sentences_and_labels_from_files(files):\n    sentences = []\n    labels = []\n    for infile in files:\n        with open(infile) as file:\n            for line in file:\n                sentence, label = parse_infile_line(line)\n                labels.append(label)\n                sentences.append(sentence)\n            file.close()\n    return (sentences, labels)", "refactored": true, "pred": {"ppl": 3.3067264556884766, "ppl_lower": 3.3067264556884766, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.006164735638260867, "Min_5.0% Prob": 9.25806999206543, "Min_10.0% Prob": 7.730270491706, "Min_20.0% Prob": 5.605846676561567, "Min_30.0% Prob": 4.070250751795592, "Min_40.0% Prob": 2.99658650079289, "Min_50.0% Prob": 2.4151859960478284, "Min_60.0% Prob": 2.021692143736238}}
{"hexsha": "0924022c1119a245a7cbca668d233e67f604810f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_shifted_3D(tau, X, Y, Z, cam_left, cam_top, traj_left, traj_top, timespan):\n    corr_top, corr_left = shift_cam_coord(timespan, traj_top, traj_left, tau)\n    len_traj = len(corr_top)\n    x = np.zeros(np.shape(X)) * np.nan\n    y = np.zeros(np.shape(Y)) * np.nan\n    z = np.zeros(np.shape(Z)) * np.nan\n    for i in range(0, len_traj):\n        if not (np.isnan(X[i]) or np.isnan(Y[i]) or np.isnan(Z[i])):\n            A, B = make_system_mat(cam_top, cam_left, corr_left[i, :], corr_top[i, :])\n            x[i], y[i], z[i] = np.linalg.solve(np.matrix(A), np.matrix(B).T)\n    return (x, y, z, corr_top, corr_left)", "fn_id": 12, "class_fn": false, "repo": "simonBreumier/3Deye", "file": "data_treat/reconstruction_3d.py", "last_update_at": "2021-06-05T07:51:00+00:00", "original_content": "def get_shifted_3D(tau, X, Y, Z, cam_left, cam_top, traj_left, traj_top, timespan):\n    corr_top, corr_left = shift_cam_coord(timespan, traj_top, traj_left, tau)\n    len_traj = len(corr_top)\n    x = np.zeros(np.shape(X)) * np.nan\n    y = np.zeros(np.shape(Y)) * np.nan\n    z = np.zeros(np.shape(Z)) * np.nan\n    for i in range(0, len_traj):\n        if not (np.isnan(X[i]) or np.isnan(Y[i]) or np.isnan(Z[i])):\n            A, B = make_system_mat(cam_top, cam_left, corr_left[i, :], corr_top[i, :])\n            x[i], y[i], z[i] = np.linalg.solve(np.matrix(A), np.matrix(B).T)\n    return (x, y, z, corr_top, corr_left)", "refactored": true, "pred": {"ppl": 3.412559986114502, "ppl_lower": 3.5751805305480957, "ppl/lowercase_ppl": -1.0379261485936058, "ppl/zlib": 0.003909117002245709, "Min_5.0% Prob": 9.879701137542725, "Min_10.0% Prob": 8.036513511951153, "Min_20.0% Prob": 5.576249513985975, "Min_30.0% Prob": 4.015975145976754, "Min_40.0% Prob": 3.0520736654552647, "Min_50.0% Prob": 2.4617330352493534, "Min_60.0% Prob": 2.0454958916477763}}
{"hexsha": "f441d0b6f5533ef1211ad198d6e281b4230affcd", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_class4_ex4():\n    base_path = '../class4/exercises/exercise4'\n    cmd_list = ['ansible-playbook', 'exercise4.yml']\n    std_out, std_err, return_code = subprocess_runner(cmd_list, exercise_dir=base_path)\n    assert std_err == ''\n    assert return_code == 0", "fn_id": 4, "class_fn": false, "repo": "kinther/ansible_course", "file": "tests/test_class4.py", "last_update_at": "2021-05-24T01:58:08+00:00", "original_content": "def test_class4_ex4():\n    base_path = '../class4/exercises/exercise4'\n    cmd_list = ['ansible-playbook', 'exercise4.yml']\n    std_out, std_err, return_code = subprocess_runner(cmd_list, exercise_dir=base_path)\n    assert std_err == ''\n    assert return_code == 0", "refactored": true, "pred": {"ppl": 3.427527904510498, "ppl_lower": 3.427527904510498, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.006415829550942336, "Min_5.0% Prob": 7.932331085205078, "Min_10.0% Prob": 6.8381242752075195, "Min_20.0% Prob": 5.377317084206475, "Min_30.0% Prob": 4.030103727623269, "Min_40.0% Prob": 3.062884023463404, "Min_50.0% Prob": 2.4795415635504154, "Min_60.0% Prob": 2.0797446648844264}}
{"hexsha": "f2310222e3119de7c2f2b3c8746814477e78d8d7", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef class_add_student(student_id, student_name):\n    \"\"\"\n    \u7528\u4e8e\u6dfb\u52a0\u5b66\u751f\n    \"\"\"\n    cur.execute(f\"insert into student_list values ({student_id},'{student_name}')\")\n    conn.commit()", "fn_id": 1, "class_fn": false, "repo": "XieJianCheng/ClassAdminSystem", "file": "module_new/class_admin_n.py", "last_update_at": "2021-11-11T12:41:09+00:00", "original_content": "def class_add_student(student_id, student_name):\n    \"\"\"\n    \u7528\u4e8e\u6dfb\u52a0\u5b66\u751f\n    \"\"\"\n    cur.execute(f\"insert into student_list values ({student_id},'{student_name}')\")\n    conn.commit()", "refactored": true, "pred": {"ppl": 7.148194313049316, "ppl_lower": 7.148194313049316, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.01156976341871728, "Min_5.0% Prob": 8.510284264882406, "Min_10.0% Prob": 7.99465537071228, "Min_20.0% Prob": 6.607682863871257, "Min_30.0% Prob": 5.564681318071154, "Min_40.0% Prob": 4.5635793590545655, "Min_50.0% Prob": 3.901227391535236, "Min_60.0% Prob": 3.3332746576618506}}
{"hexsha": "78f066607cb84040dfcf6fa504ecdea051a0dfbc", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_calculate_raises_with_no_active_phases_passed():\n    \"\"\"Passing inactive phases to calculate() raises a ConditionError.\"\"\"\n    with pytest.raises(ConditionError):\n        calculate(ALFE_DBF, ['AL', 'VA'], ['AL13FE4'], T=1200, P=101325)", "fn_id": 3, "class_fn": false, "repo": "dschwen/pycalphad", "file": "pycalphad/tests/test_calculate.py", "last_update_at": "2021-07-19T14:25:43+00:00", "original_content": "def test_calculate_raises_with_no_active_phases_passed():\n    \"\"\"Passing inactive phases to calculate() raises a ConditionError.\"\"\"\n    with pytest.raises(ConditionError):\n        calculate(ALFE_DBF, ['AL', 'VA'], ['AL13FE4'], T=1200, P=101325)", "refactored": true, "pred": {"ppl": 11.496782302856445, "ppl_lower": 16.151315689086914, "ppl/lowercase_ppl": -1.1391994115446529, "ppl/zlib": 0.012333672709425945, "Min_5.0% Prob": 11.774789094924927, "Min_10.0% Prob": 10.122488141059875, "Min_20.0% Prob": 8.121618467218736, "Min_30.0% Prob": 6.7686464878229, "Min_40.0% Prob": 5.648638595853533, "Min_50.0% Prob": 4.7136870568448845, "Min_60.0% Prob": 4.02470551571756}}
{"hexsha": "3546a7402fd9a0f1b6c55afe3610cdd62558560c", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef __get_stock_bar(code, start, end, freq):\n    df = None\n    _start = start.format()\n    _end = end.format()\n    if freq == util.FREQ_DAY or freq == util.FREQ_WEEK or freq == util.FREQ_MONTH:\n        covert = {util.FREQ_DAY: 'D', util.FREQ_WEEK: 'W', util.FREQ_MONTH: 'M'}\n        df = ts.get_stock_bar(code=code, start=_start, end=_end, freq=covert[freq], factors=['vr', 'tor'])\n    else:\n        covert = {util.FREQ_1M: '1MIN', util.FREQ_5M: '5MIN', util.FREQ_15M: '15MIN', util.FREQ_30M: '30MIN'}\n        df = ts.tushare_bar(code=code, start=_start, end=_end, freq=covert[freq], factors=['vr', 'tor'])\n    if not isinstance(df, pd.DataFrame):\n        raise TypeError('df is unknown type %s' % type(df))\n    elif df.empty:\n        log.warn('%s from %s to %s bar[%s] is empty' % (code, start, end, freq))\n    return df", "fn_id": 3, "class_fn": false, "repo": "lijielife/carp", "file": "carp/request.py", "last_update_at": "2021-03-02T15:48:57+00:00", "original_content": "def __get_stock_bar(code, start, end, freq):\n    df = None\n    _start = start.format()\n    _end = end.format()\n    if freq == util.FREQ_DAY or freq == util.FREQ_WEEK or freq == util.FREQ_MONTH:\n        covert = {util.FREQ_DAY: 'D', util.FREQ_WEEK: 'W', util.FREQ_MONTH: 'M'}\n        df = ts.get_stock_bar(code=code, start=_start, end=_end, freq=covert[freq], factors=['vr', 'tor'])\n    else:\n        covert = {util.FREQ_1M: '1MIN', util.FREQ_5M: '5MIN', util.FREQ_15M: '15MIN', util.FREQ_30M: '30MIN'}\n        df = ts.tushare_bar(code=code, start=_start, end=_end, freq=covert[freq], factors=['vr', 'tor'])\n    if not isinstance(df, pd.DataFrame):\n        raise TypeError('df is unknown type %s' % type(df))\n    elif df.empty:\n        log.warn('%s from %s to %s bar[%s] is empty' % (code, start, end, freq))\n    return df", "refactored": true, "pred": {"ppl": 2.7373645305633545, "ppl_lower": 3.0794007778167725, "ppl/lowercase_ppl": -1.116921481259316, "ppl/zlib": 0.0026292313508248567, "Min_5.0% Prob": 10.1683098588671, "Min_10.0% Prob": 7.543184025534268, "Min_20.0% Prob": 4.806256023503966, "Min_30.0% Prob": 3.3525024541978086, "Min_40.0% Prob": 2.5256571801645413, "Min_50.0% Prob": 2.0199422016864856, "Min_60.0% Prob": 1.6819251482225381}}
{"hexsha": "8644f9b2a8f01c213caf5bcbd4d123b465cabeeb", "ext": "py", "lang": "Python", "content": "@leet2git.command()\n@click.option('--source-repository', '-s', default='', help='the path to the folder where the code will be saved')\n@click.option('--language', '-l', default='python3', help='the default language')\n@click.option('--soft/--hard', default=True, help='A soft reset only erases the database. A hard reset also erase the files.')\n@click.pass_obj\n@timeing\n@measure_memory_usage\ndef reset(cm: ConfigManager, source_repository: str, language: str, soft: bool):\n    \"\"\"Reset the configuration file\n    \\x0c\n    Args:\n        source_repository (str, optional): the path to the folder where the code will be saved.\n            Defaults to \"\".\n        language (str, optional): the default language. Defaults to \"python3\".\n        soft(bool, optional): the reset hardness. Defaults to soft.\n    \"\"\"\n    if not soft:\n        try:\n            click.confirm(f\"This will delete EVERY solution and test file inside                     the {cm.config['source_path']} folder.                      Still want to proceed?\", abort=True)\n        except Abort:\n            return\n        file_list = glob.glob(os.path.join(cm.config['source_path'], 'src', 'leetcode_*')) + glob.glob(os.path.join(cm.config['source_path'], 'tests', 'test_*'))\n        for file in file_list:\n            try:\n                os.remove(file)\n            except FileNotFoundError as e:\n                click.secho(e.args)\n    else:\n        try:\n            click.confirm('This will delete the question database. Still want to proceed?', abort=True)\n        except Abort:\n            return\n    reset_config(cm, source_repository, language)\n    cm.load_config()\n    qdb = QuestionDB(cm.config)\n    qdb.reset()\n    if not soft:\n        data = QuestionData(language=cm.config['language'])\n        file_handler = create_file_handler(data, cm.config)\n        file_handler.generate_repo(cm.config['source_path'])", "fn_id": 7, "class_fn": false, "repo": "sungho-joo/leetcode2github", "file": "src/leet2git/leet2git.py", "last_update_at": "2021-05-07T08:26:47+00:00", "original_content": "@leet2git.command()\n@click.option('--source-repository', '-s', default='', help='the path to the folder where the code will be saved')\n@click.option('--language', '-l', default='python3', help='the default language')\n@click.option('--soft/--hard', default=True, help='A soft reset only erases the database. A hard reset also erase the files.')\n@click.pass_obj\ndef reset(cm: ConfigManager, source_repository: str, language: str, soft: bool):\n    \"\"\"Reset the configuration file\n    \\x0c\n    Args:\n        source_repository (str, optional): the path to the folder where the code will be saved.\n            Defaults to \"\".\n        language (str, optional): the default language. Defaults to \"python3\".\n        soft(bool, optional): the reset hardness. Defaults to soft.\n    \"\"\"\n    if not soft:\n        try:\n            click.confirm(f\"This will delete EVERY solution and test file inside                     the {cm.config['source_path']} folder.                      Still want to proceed?\", abort=True)\n        except Abort:\n            return\n        file_list = glob.glob(os.path.join(cm.config['source_path'], 'src', 'leetcode_*')) + glob.glob(os.path.join(cm.config['source_path'], 'tests', 'test_*'))\n        for file in file_list:\n            try:\n                os.remove(file)\n            except FileNotFoundError as e:\n                click.secho(e.args)\n    else:\n        try:\n            click.confirm('This will delete the question database. Still want to proceed?', abort=True)\n        except Abort:\n            return\n    reset_config(cm, source_repository, language)\n    cm.load_config()\n    qdb = QuestionDB(cm.config)\n    qdb.reset()\n    if not soft:\n        data = QuestionData(language=cm.config['language'])\n        file_handler = create_file_handler(data, cm.config)\n        file_handler.generate_repo(cm.config['source_path'])", "refactored": true, "pred": {"ppl": 3.945688247680664, "ppl_lower": 4.618869781494141, "ppl/lowercase_ppl": -1.1147631894567556, "ppl/zlib": 0.0019143980471923077, "Min_5.0% Prob": 10.737914043924082, "Min_10.0% Prob": 8.597492907909636, "Min_20.0% Prob": 6.017717384277506, "Min_30.0% Prob": 4.410115418299823, "Min_40.0% Prob": 3.411520167475655, "Min_50.0% Prob": 2.7393499067375426, "Min_60.0% Prob": 2.2899044315317565}}
{"hexsha": "d1aed9946c2cb489d711ae8a1fe207359b86da6f", "ext": "py", "lang": "Python", "content": "def buildStartEndBreakProb(fit, nSegments, tag):\n\n    @timeing\n    @measure_memory_usage\n    def sebBuilder(s):\n        return ee.String(s).cat('_' + tag)\n    segmentTag = buildSegmentTag(nSegments).map(sebBuilder)\n    zeros = ee.Array(0).repeat(0, nSegments)\n    magImg = fit.select(tag).arrayCat(zeros, 0).float().arraySlice(0, 0, nSegments)\n    return magImg.arrayFlatten([segmentTag])", "fn_id": 5, "class_fn": false, "repo": "rjsheperd/gee-gateway", "file": "gee/ccdc.py", "last_update_at": "2021-03-19T19:51:49+00:00", "original_content": "def buildStartEndBreakProb(fit, nSegments, tag):\n\n    def sebBuilder(s):\n        return ee.String(s).cat('_' + tag)\n    segmentTag = buildSegmentTag(nSegments).map(sebBuilder)\n    zeros = ee.Array(0).repeat(0, nSegments)\n    magImg = fit.select(tag).arrayCat(zeros, 0).float().arraySlice(0, 0, nSegments)\n    return magImg.arrayFlatten([segmentTag])", "refactored": true, "pred": {"ppl": 14.245885848999023, "ppl_lower": 21.423452377319336, "ppl/lowercase_ppl": -1.1535941902237101, "ppl/zlib": 0.01140115086986386, "Min_5.0% Prob": 11.839327494303385, "Min_10.0% Prob": 10.936208407084147, "Min_20.0% Prob": 9.342001616954803, "Min_30.0% Prob": 7.581209745672014, "Min_40.0% Prob": 6.238450855016708, "Min_50.0% Prob": 5.195206001400948, "Min_60.0% Prob": 4.4003355751434965}}
{"hexsha": "b735786ce4c39a03aae76e4daf78a4867d561247", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_subtraction_with_other_types():\n    price1 = Money(40, 'EUR')\n    price2 = Money(80, 'EUR')\n    price_range = MoneyRange(price1, price2)\n    with pytest.raises(TypeError):\n        price_range - 1", "fn_id": 6, "class_fn": false, "repo": "anton-shestakov/prices", "file": "tests/test_money_range.py", "last_update_at": "2021-11-17T14:38:52+00:00", "original_content": "def test_subtraction_with_other_types():\n    price1 = Money(40, 'EUR')\n    price2 = Money(80, 'EUR')\n    price_range = MoneyRange(price1, price2)\n    with pytest.raises(TypeError):\n        price_range - 1", "refactored": true, "pred": {"ppl": 5.13371467590332, "ppl_lower": 7.5855865478515625, "ppl/lowercase_ppl": -1.2386681698578665, "ppl/zlib": 0.010419296213413547, "Min_5.0% Prob": 9.28478209177653, "Min_10.0% Prob": 8.171731744493757, "Min_20.0% Prob": 6.162216822306315, "Min_30.0% Prob": 5.005936497991735, "Min_40.0% Prob": 3.9792951305707294, "Min_50.0% Prob": 3.286537269885476, "Min_60.0% Prob": 2.7196992523140375}}
{"hexsha": "1869c8f32f7f9bd4afb8cbf0bd42e3c02a87fce7", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef Vector4CrossProduct(vectorLeft, vectorRight):\n    assert isinstance(vectorRight, Vector4)\n    v = Vector4()\n    v.x = vectorLeft.y * vectorRight.z - vectorLeft.z * vectorRight.y\n    v.y = vectorLeft.z * vectorRight.x - vectorLeft.x * vectorRight.z\n    v.z = vectorLeft.x * vectorRight.y - vectorLeft.y * vectorRight.x\n    v.w = 0\n    return v", "fn_id": 11, "class_fn": false, "repo": "pome-ta/draftPythonistaScripts", "file": "simd/vector4.py", "last_update_at": "2021-08-05T04:31:02+00:00", "original_content": "def Vector4CrossProduct(vectorLeft, vectorRight):\n    assert isinstance(vectorRight, Vector4)\n    v = Vector4()\n    v.x = vectorLeft.y * vectorRight.z - vectorLeft.z * vectorRight.y\n    v.y = vectorLeft.z * vectorRight.x - vectorLeft.x * vectorRight.z\n    v.z = vectorLeft.x * vectorRight.y - vectorLeft.y * vectorRight.x\n    v.w = 0\n    return v", "refactored": true, "pred": {"ppl": 2.3360114097595215, "ppl_lower": 2.5063135623931885, "ppl/lowercase_ppl": -1.0829376426794146, "ppl/zlib": 0.004876120398097219, "Min_5.0% Prob": 8.98529084523519, "Min_10.0% Prob": 7.346636017163594, "Min_20.0% Prob": 4.200091023618977, "Min_30.0% Prob": 2.82490521022636, "Min_40.0% Prob": 2.1208654358779313, "Min_50.0% Prob": 1.6968751397983093, "Min_60.0% Prob": 1.4140724442702068}}
{"hexsha": "6780c64eb55bdd7710a2ca7590d41b28234c58e4", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef polyClipboard(*args, **kwargs):\n    \"\"\"\n    The command allows the user to copy and paste certain polygonal attributes to a clipboard. These attributes are:  1)\n    Shader (shading engine) assignment.  2) Texture coordinate (UV) assignment.  3) Color value assignment. Any combination\n    of attributes can be chosen for the copy or paste operation. If the attribute has not been copied to the clipboard, then\n    naturally it cannot be pasted from the clipboard. The copy option will copy the attribute assignments from a single\n    source polygonal dag object or polygon component. If the source does not have the either UV or color attributes, then\n    nothing will be copied to the clipboard. The paste option will paste the attribute assignments to one or more polygon\n    components or polygonal dag objects. If the destination does not have either UV or color attributes, then new values\n    will be assigned as needed. Additionally, there is the option to clear the clipboard contents\n    \n    Flags:\n      - clear : cl                     (bool)          [create]\n          When used, will mean to clear the specified attribute argument(s).\n    \n      - color : clr                    (bool)          [create]\n          When used, will be to copy or paste color attributes\n    \n      - copy : cp                      (bool)          [create]\n          When used, will mean to copy the specified attribute argument(s).\n    \n      - paste : ps                     (bool)          [create]\n          When used, will mean to paste the specified attribute argument(s).\n    \n      - shader : sh                    (bool)          [create]\n          When used, will be to copy or paste shader attributes\n    \n      - uvCoordinates : uv             (bool)          [create]\n          When used, will be to copy or paste texture coordinate attributes                                  Flag can have\n          multiple arguments, passed either as a tuple or a list.\n    \n    \n    Derived from mel command `maya.cmds.polyClipboard`\n    \"\"\"\n    pass", "fn_id": 220, "class_fn": false, "repo": "FXTD-ODYSSEY/vscode-mayapy", "file": "mayaSDK/pymel/core/modeling.py", "last_update_at": "2021-12-26T06:56:16+00:00", "original_content": "def polyClipboard(*args, **kwargs):\n    \"\"\"\n    The command allows the user to copy and paste certain polygonal attributes to a clipboard. These attributes are:  1)\n    Shader (shading engine) assignment.  2) Texture coordinate (UV) assignment.  3) Color value assignment. Any combination\n    of attributes can be chosen for the copy or paste operation. If the attribute has not been copied to the clipboard, then\n    naturally it cannot be pasted from the clipboard. The copy option will copy the attribute assignments from a single\n    source polygonal dag object or polygon component. If the source does not have the either UV or color attributes, then\n    nothing will be copied to the clipboard. The paste option will paste the attribute assignments to one or more polygon\n    components or polygonal dag objects. If the destination does not have either UV or color attributes, then new values\n    will be assigned as needed. Additionally, there is the option to clear the clipboard contents\n    \n    Flags:\n      - clear : cl                     (bool)          [create]\n          When used, will mean to clear the specified attribute argument(s).\n    \n      - color : clr                    (bool)          [create]\n          When used, will be to copy or paste color attributes\n    \n      - copy : cp                      (bool)          [create]\n          When used, will mean to copy the specified attribute argument(s).\n    \n      - paste : ps                     (bool)          [create]\n          When used, will mean to paste the specified attribute argument(s).\n    \n      - shader : sh                    (bool)          [create]\n          When used, will be to copy or paste shader attributes\n    \n      - uvCoordinates : uv             (bool)          [create]\n          When used, will be to copy or paste texture coordinate attributes                                  Flag can have\n          multiple arguments, passed either as a tuple or a list.\n    \n    \n    Derived from mel command `maya.cmds.polyClipboard`\n    \"\"\"\n    pass", "refactored": true, "pred": {"ppl": 5.817309856414795, "ppl_lower": 7.20708703994751, "ppl/lowercase_ppl": -1.1216619192196013, "ppl/zlib": 0.0025894675454429398, "Min_5.0% Prob": 12.346295046806336, "Min_10.0% Prob": 9.337969919530357, "Min_20.0% Prob": 6.87496388249281, "Min_30.0% Prob": 5.3906476100285845, "Min_40.0% Prob": 4.285465180512631, "Min_50.0% Prob": 3.5094134360551834, "Min_60.0% Prob": 2.9405868574524456}}
{"hexsha": "ce10512207649c9489cbc69c74570eefc9c463ff", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_data_int():\n    X = np.array([[2, 20, 3], [4, 50, 6], [7, 80, 9], [10, 110, 12]])\n    y_int = np.array([1, 2, 3, 4])\n    return (X, y_int)", "fn_id": 0, "class_fn": false, "repo": "gradientzero/dq0-sdk", "file": "tests/test_pipeline/test_pipeline.py", "last_update_at": "2021-03-18T21:26:29+00:00", "original_content": "def get_data_int():\n    X = np.array([[2, 20, 3], [4, 50, 6], [7, 80, 9], [10, 110, 12]])\n    y_int = np.array([1, 2, 3, 4])\n    return (X, y_int)", "refactored": true, "pred": {"ppl": 2.9117648601531982, "ppl_lower": 2.92207407951355, "ppl/lowercase_ppl": -1.003306906034901, "ppl/zlib": 0.007744633177538649, "Min_5.0% Prob": 8.053182005882263, "Min_10.0% Prob": 6.443743705749512, "Min_20.0% Prob": 4.513625640618174, "Min_30.0% Prob": 3.4458189564091817, "Min_40.0% Prob": 2.639677926113731, "Min_50.0% Prob": 2.1502926292571614, "Min_60.0% Prob": 1.7795458530778425}}
{"hexsha": "a0e82345e90e71c8a988186287df593c48a61aad", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\nasync def selectDB(userid):\n    conn = sqlite3.connect('ID_DATA.db')\n    c = conn.cursor()\n    cursor = c.execute('SELECT *  FROM UIDDATA WHERE USERID = ?', (userid,))\n    for row in cursor:\n        if row[0]:\n            if row[2]:\n                return [row[2], 3]\n            elif row[1]:\n                return [row[1], 2]\n            else:\n                return None\n        else:\n            return None", "fn_id": 1, "class_fn": false, "repo": "Twip-Emma/QQbot-Twip", "file": "bot_plugins/GenshinUID/getDB.py", "last_update_at": "2021-12-23T15:36:48+00:00", "original_content": "async def selectDB(userid):\n    conn = sqlite3.connect('ID_DATA.db')\n    c = conn.cursor()\n    cursor = c.execute('SELECT *  FROM UIDDATA WHERE USERID = ?', (userid,))\n    for row in cursor:\n        if row[0]:\n            if row[2]:\n                return [row[2], 3]\n            elif row[1]:\n                return [row[1], 2]\n            else:\n                return None\n        else:\n            return None", "refactored": true, "pred": {"ppl": 4.597407341003418, "ppl_lower": 5.0893168449401855, "ppl/lowercase_ppl": -1.0666349272760551, "ppl/zlib": 0.006491457545020157, "Min_5.0% Prob": 10.938199996948242, "Min_10.0% Prob": 8.868337067690762, "Min_20.0% Prob": 6.433833142985469, "Min_30.0% Prob": 4.902516161694246, "Min_40.0% Prob": 3.774701091258422, "Min_50.0% Prob": 3.032068337602862, "Min_60.0% Prob": 2.561792018080967}}
{"hexsha": "de5093d7a37e19119c9ed380921063f98f98a572", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef solve_all(l, r):\n    res.clear()\n    nl = l.copy()\n    for i in range(len(nl)):\n        nl[i] = (frac(nl[i]), str(nl[i]))\n    solve_all_rec(nl, frac(r))\n    return res", "fn_id": 1, "class_fn": false, "repo": "mateo-cv/KryptoCards", "file": "solver_all.py", "last_update_at": "2021-11-06T02:19:58+00:00", "original_content": "def solve_all(l, r):\n    res.clear()\n    nl = l.copy()\n    for i in range(len(nl)):\n        nl[i] = (frac(nl[i]), str(nl[i]))\n    solve_all_rec(nl, frac(r))\n    return res", "refactored": true, "pred": {"ppl": 6.28898286819458, "ppl_lower": 6.28898286819458, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.013041130152249033, "Min_5.0% Prob": 12.098713239034018, "Min_10.0% Prob": 9.297002383640834, "Min_20.0% Prob": 6.812346267700195, "Min_30.0% Prob": 5.540786970745433, "Min_40.0% Prob": 4.466721049944559, "Min_50.0% Prob": 3.637741078671656, "Min_60.0% Prob": 3.0935916049612895}}
{"hexsha": "6a6c2ee6803eaaa2206bcf41874368968655c509", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef tsne_plot(model):\n    labels = []\n    tokens = []\n    print('Displaying t-SNE...')\n    for word in model.wv.vocab:\n        tokens.append(model[word])\n        labels.append(word)\n    tsne_model = TSNE(perplexity=40, n_components=2, init='pca', n_iter=2500, random_state=23)\n    new_values = tsne_model.fit_transform(tokens)\n    x = []\n    y = []\n    for value in new_values:\n        x.append(value[0])\n        y.append(value[1])\n    plt.figure(figsize=(16, 16))\n    for i in range(len(x)):\n        plt.scatter(x[i], y[i])\n        plt.annotate(labels[i], xy=(x[i], y[i]), xytext=(5, 2), textcoords='offset points', ha='right', va='bottom')\n    plt.title('t-SNE')\n    plt.show()", "fn_id": 3, "class_fn": false, "repo": "cjbayron/artist2lyrics", "file": "common/utils.py", "last_update_at": "2021-11-08T12:49:36+00:00", "original_content": "def tsne_plot(model):\n    labels = []\n    tokens = []\n    print('Displaying t-SNE...')\n    for word in model.wv.vocab:\n        tokens.append(model[word])\n        labels.append(word)\n    tsne_model = TSNE(perplexity=40, n_components=2, init='pca', n_iter=2500, random_state=23)\n    new_values = tsne_model.fit_transform(tokens)\n    x = []\n    y = []\n    for value in new_values:\n        x.append(value[0])\n        y.append(value[1])\n    plt.figure(figsize=(16, 16))\n    for i in range(len(x)):\n        plt.scatter(x[i], y[i])\n        plt.annotate(labels[i], xy=(x[i], y[i]), xytext=(5, 2), textcoords='offset points', ha='right', va='bottom')\n    plt.title('t-SNE')\n    plt.show()", "refactored": true, "pred": {"ppl": 1.5437448024749756, "ppl_lower": 1.7675044536590576, "ppl/lowercase_ppl": -1.3117319362721855, "ppl/zlib": 0.0011076815167618697, "Min_5.0% Prob": 6.720989724000295, "Min_10.0% Prob": 4.247717037796974, "Min_20.0% Prob": 2.176461152048135, "Min_30.0% Prob": 1.4477407847707335, "Min_40.0% Prob": 1.0941036724941615, "Min_50.0% Prob": 0.8719101792465938, "Min_60.0% Prob": 0.7246565149883748}}
{"hexsha": "71850fd6a06c73964f1a9b9a4f6b911414e14aff", "ext": "py", "lang": "Python", "content": "@pytest.mark.usefixtures('aftersocialregister_app')\n@timeing\n@measure_memory_usage\ndef test_aftersocialregister(aftersocialregister_config, db_session):\n    \"\"\"Register fresh user and logs him in and check response if redirect from AfterSocialRegister.\"\"\"\n    profile = {'accounts': [{'domain': 'facebook.com', 'userid': '2343'}], 'displayName': 'teddy', 'verifiedEmail': 'we@po.pl', 'preferredUsername': 'teddy', 'emails': [{'value': 'aasd@bwwqwe.pl'}], 'name': 'ted'}\n    credentials = {'oauthAccessToken': '7897048593434'}\n    provider_name = 'facebook'\n    provider_type = 'facebook'\n    request = testing.DummyRequest()\n    request.user = None\n    request.registry = aftersocialregister_config.registry\n    request.remote_addr = '127.0.0.123'\n    request.context = AuthenticationComplete(profile, credentials, provider_name, provider_type)\n    request.login_perform = MagicMock(name='login_perform')\n    request.login_perform.return_value = {'status': True}\n    view = SocialLoginViews(request)\n    out = view()\n    assert out.location == EVENT_PATH.format(AfterSocialRegister)\n    transaction.commit()\n    user = db_session.query(User).one()\n    assert user.is_active\n    assert user.provider_id('facebook') == profile['accounts'][0]['userid']", "fn_id": 24, "class_fn": false, "repo": "fizyk/pyramid_fullauth", "file": "tests/views/test_events.py", "last_update_at": "2021-11-14T15:36:07+00:00", "original_content": "@pytest.mark.usefixtures('aftersocialregister_app')\ndef test_aftersocialregister(aftersocialregister_config, db_session):\n    \"\"\"Register fresh user and logs him in and check response if redirect from AfterSocialRegister.\"\"\"\n    profile = {'accounts': [{'domain': 'facebook.com', 'userid': '2343'}], 'displayName': 'teddy', 'verifiedEmail': 'we@po.pl', 'preferredUsername': 'teddy', 'emails': [{'value': 'aasd@bwwqwe.pl'}], 'name': 'ted'}\n    credentials = {'oauthAccessToken': '7897048593434'}\n    provider_name = 'facebook'\n    provider_type = 'facebook'\n    request = testing.DummyRequest()\n    request.user = None\n    request.registry = aftersocialregister_config.registry\n    request.remote_addr = '127.0.0.123'\n    request.context = AuthenticationComplete(profile, credentials, provider_name, provider_type)\n    request.login_perform = MagicMock(name='login_perform')\n    request.login_perform.return_value = {'status': True}\n    view = SocialLoginViews(request)\n    out = view()\n    assert out.location == EVENT_PATH.format(AfterSocialRegister)\n    transaction.commit()\n    user = db_session.query(User).one()\n    assert user.is_active\n    assert user.provider_id('facebook') == profile['accounts'][0]['userid']", "refactored": true, "pred": {"ppl": 5.734683036804199, "ppl_lower": 8.026778221130371, "ppl/lowercase_ppl": -1.19252476120753, "ppl/zlib": 0.002812451659971004, "Min_5.0% Prob": 11.454376781688017, "Min_10.0% Prob": 9.302129296695485, "Min_20.0% Prob": 6.711691718170608, "Min_30.0% Prob": 5.253690434891043, "Min_40.0% Prob": 4.222407258507134, "Min_50.0% Prob": 3.4641762273602708, "Min_60.0% Prob": 2.901872445275818}}
{"hexsha": "9109af01b75d406c726ca60fbd26a94a9e80f374", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef MultiscaleEntropy_mse(x, scale_factor=[i for i in range(1, 21)], m=[2], r=[0.15], return_type='dict', safe_mode=False):\n    \"\"\"[Multiscale Entropy]\n\n    Arguments:\n        x {[input signal]} -- [an iterator of numbers]\n\n    Keyword Arguments:\n        scale_factor {list} -- [scale factors of coarse graining] (default: {[i for i in range(1,21)]})\n        m {list} -- [m in sample entropy] (default: {[2]})\n        r {list} -- [r in sample entropy] (default: {[0.15]})\n        return_type {str} -- [can be dict or list] (default: {'dict'})\n        safe_mode {bool} -- [if set True, type checking will be skipped] (default: {False})\n\n    Raises:\n        ValueError -- [some values too big]\n\n    Returns:\n        [dict or list as return_type indicates] -- [if dict, nest as [scale_factor][m][r] for each value of scale_factor, m, r; if list nest as [i][j][k] for lengths of scale_factor, m, r]\n    \"\"\"\n    if not safe_mode:\n        m = MultiscaleEntropy_check_type(m, int, 'm')\n        r = MultiscaleEntropy_check_type(r, float, 'r')\n        scale_factor = MultiscaleEntropy_check_type(scale_factor, int, 'scale_factor')\n    try:\n        x = np.array(x)\n    except:\n        print('x should be a sequence of numbers')\n    if max(scale_factor) > len(x):\n        raise ValueError(\"the max scale_factor is bigger than x's length\")\n    sd = np.sqrt(np.var(x))\n    ms_en = MultiscaleEntropy_init_return_type(return_type)\n    for s_f in scale_factor:\n        y = MultiscaleEntropy_coarse_grain(x, s_f)\n        if return_type == 'dict':\n            ms_en[s_f] = MultiscaleEntropy_sample_entropy(y, m, r, sd, 'dict', True)\n        else:\n            ms_en.append(MultiscaleEntropy_sample_entropy(y, m, r, sd, 'list', True))\n    if return_type == 'list':\n        ms_en = [i[0] for i in ms_en]\n        ms_en = [i[0] for i in ms_en]\n    return ms_en", "fn_id": 18, "class_fn": false, "repo": "LRydin/NeuroKit", "file": "tests/tests_complexity.py", "last_update_at": "2021-06-10T03:27:15+00:00", "original_content": "def MultiscaleEntropy_mse(x, scale_factor=[i for i in range(1, 21)], m=[2], r=[0.15], return_type='dict', safe_mode=False):\n    \"\"\"[Multiscale Entropy]\n\n    Arguments:\n        x {[input signal]} -- [an iterator of numbers]\n\n    Keyword Arguments:\n        scale_factor {list} -- [scale factors of coarse graining] (default: {[i for i in range(1,21)]})\n        m {list} -- [m in sample entropy] (default: {[2]})\n        r {list} -- [r in sample entropy] (default: {[0.15]})\n        return_type {str} -- [can be dict or list] (default: {'dict'})\n        safe_mode {bool} -- [if set True, type checking will be skipped] (default: {False})\n\n    Raises:\n        ValueError -- [some values too big]\n\n    Returns:\n        [dict or list as return_type indicates] -- [if dict, nest as [scale_factor][m][r] for each value of scale_factor, m, r; if list nest as [i][j][k] for lengths of scale_factor, m, r]\n    \"\"\"\n    if not safe_mode:\n        m = MultiscaleEntropy_check_type(m, int, 'm')\n        r = MultiscaleEntropy_check_type(r, float, 'r')\n        scale_factor = MultiscaleEntropy_check_type(scale_factor, int, 'scale_factor')\n    try:\n        x = np.array(x)\n    except:\n        print('x should be a sequence of numbers')\n    if max(scale_factor) > len(x):\n        raise ValueError(\"the max scale_factor is bigger than x's length\")\n    sd = np.sqrt(np.var(x))\n    ms_en = MultiscaleEntropy_init_return_type(return_type)\n    for s_f in scale_factor:\n        y = MultiscaleEntropy_coarse_grain(x, s_f)\n        if return_type == 'dict':\n            ms_en[s_f] = MultiscaleEntropy_sample_entropy(y, m, r, sd, 'dict', True)\n        else:\n            ms_en.append(MultiscaleEntropy_sample_entropy(y, m, r, sd, 'list', True))\n    if return_type == 'list':\n        ms_en = [i[0] for i in ms_en]\n        ms_en = [i[0] for i in ms_en]\n    return ms_en", "refactored": true, "pred": {"ppl": 3.190351724624634, "ppl_lower": 3.4597394466400146, "ppl/lowercase_ppl": -1.0698732304791332, "ppl/zlib": 0.0016046074263094763, "Min_5.0% Prob": 10.522004193273084, "Min_10.0% Prob": 7.9251763941877975, "Min_20.0% Prob": 5.2964539921889875, "Min_30.0% Prob": 3.802980214020627, "Min_40.0% Prob": 2.890961930061443, "Min_50.0% Prob": 2.322529452723904, "Min_60.0% Prob": 1.9377033244365904}}
{"hexsha": "d2664e1063dfac0585b27173768ffad2c031b7e9", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _InceptionV3_blockH(x):\n    block1 = conv2d_bn(x, 320, (1, 1))\n    block2 = conv2d_bn(x, 384, (1, 1))\n    block2_1 = conv2d_bn(block2, 384, (1, 3))\n    block2_2 = conv2d_bn(block2, 384, (3, 1))\n    block2 = Concatenate()([block2_1, block2_2])\n    block3 = conv2d_bn(x, 448, (1, 1))\n    block3_1 = conv2d_bn(block3, 384, (3, 3))\n    block3_2 = conv2d_bn(block3, 384, (1, 3))\n    block3_3 = conv2d_bn(block3, 384, (3, 1))\n    block3 = Concatenate()([block3_1, block3_2, block3_3])\n    block4 = AveragePooling2D((3, 3), strides=(1, 1), padding='same')(x)\n    block4 = conv2d_bn(block4, 192, (1, 1))\n    x = Concatenate()([block1, block2, block3, block4])\n    return x", "fn_id": 8, "class_fn": false, "repo": "Hiroaki-Ozaki/modelib-classification", "file": "keras/models/InceptionV3.py", "last_update_at": "2021-04-14T08:56:01+00:00", "original_content": "def _InceptionV3_blockH(x):\n    block1 = conv2d_bn(x, 320, (1, 1))\n    block2 = conv2d_bn(x, 384, (1, 1))\n    block2_1 = conv2d_bn(block2, 384, (1, 3))\n    block2_2 = conv2d_bn(block2, 384, (3, 1))\n    block2 = Concatenate()([block2_1, block2_2])\n    block3 = conv2d_bn(x, 448, (1, 1))\n    block3_1 = conv2d_bn(block3, 384, (3, 3))\n    block3_2 = conv2d_bn(block3, 384, (1, 3))\n    block3_3 = conv2d_bn(block3, 384, (3, 1))\n    block3 = Concatenate()([block3_1, block3_2, block3_3])\n    block4 = AveragePooling2D((3, 3), strides=(1, 1), padding='same')(x)\n    block4 = conv2d_bn(block4, 192, (1, 1))\n    x = Concatenate()([block1, block2, block3, block4])\n    return x", "refactored": true, "pred": {"ppl": 1.4145411252975464, "ppl_lower": 1.4962553977966309, "ppl/lowercase_ppl": -1.161936448383273, "ppl/zlib": 0.0013236839138354637, "Min_5.0% Prob": 5.9347459226846695, "Min_10.0% Prob": 3.3390205827626316, "Min_20.0% Prob": 1.722186958889908, "Min_30.0% Prob": 1.160866103922017, "Min_40.0% Prob": 0.8668499060479903, "Min_50.0% Prob": 0.6956513580088197, "Min_60.0% Prob": 0.5780003822537086}}
{"hexsha": "be392b1159ec0d0cbf136ec1807d49c872f36a16", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef plot_oi(ticker: str, expiry: str, min_sp: float, max_sp: float, calls_only: bool, puts_only: bool, export: str):\n    \"\"\"Plot open interest\n\n    Parameters\n    ----------\n    ticker: str\n        Ticker\n    expiry: str\n        Expiry date for options\n    min_sp: float\n        Min strike to consider\n    max_sp: float\n        Max strike to consider\n    calls_only: bool\n        Show calls only\n    puts_only: bool\n        Show puts only\n    export: str\n        Format to export file\n    \"\"\"\n    options = tradier_model.get_option_chains(ticker, expiry)\n    export_data(export, os.path.dirname(os.path.abspath(__file__)), 'oi_tr', options)\n    current_price = tradier_model.last_price(ticker)\n    if min_sp == -1:\n        min_strike = 0.75 * current_price\n    else:\n        min_strike = min_sp\n    if max_sp == -1:\n        max_strike = 1.25 * current_price\n    else:\n        max_strike = max_sp\n    if calls_only and puts_only:\n        print('Both flags selected, please select one', '\\n')\n        return\n    calls = options[options.option_type == 'call'][['strike', 'open_interest']]\n    puts = options[options.option_type == 'put'][['strike', 'open_interest']]\n    call_oi = calls.set_index('strike')['open_interest'] / 1000\n    put_oi = puts.set_index('strike')['open_interest'] / 1000\n    df_opt = pd.merge(call_oi, put_oi, left_index=True, right_index=True)\n    df_opt = df_opt.rename(columns={'open_interest_x': 'OI_call', 'open_interest_y': 'OI_put'})\n    max_pain = op_helpers.calculate_max_pain(df_opt)\n    plt.style.use('classic')\n    fig, ax = plt.subplots(figsize=plot_autoscale(), dpi=cfp.PLOT_DPI)\n    if not calls_only:\n        put_oi.plot(x='strike', y='open_interest', label='Puts', ax=ax, marker='o', ls='-', c='r')\n    if not puts_only:\n        call_oi.plot(x='strike', y='open_interest', label='Calls', ax=ax, marker='o', ls='-', c='g')\n        ax.axvline(current_price, lw=2, c='k', ls='--', label='Current Price', alpha=0.7)\n        ax.axvline(max_pain, lw=3, c='k', label=f'Max Pain: {max_pain}', alpha=0.7)\n        ax.grid('on')\n        ax.set_xlabel('Strike Price')\n        ax.set_ylabel('Open Interest (1k) ')\n        ax.set_xlim(min_strike, max_strike)\n        if gtff.USE_ION:\n            plt.ion()\n        ax.set_title(f'Open Interest for {ticker.upper()} expiring {expiry}')\n        plt.legend(loc=0)\n        fig.tight_layout(pad=1)\n    plt.show()\n    plt.style.use('default')\n    print('')", "fn_id": 4, "class_fn": false, "repo": "Aerex/GamestonkTerminal", "file": "gamestonk_terminal/stocks/options/tradier_view.py", "last_update_at": "2021-03-11T17:42:35+00:00", "original_content": "def plot_oi(ticker: str, expiry: str, min_sp: float, max_sp: float, calls_only: bool, puts_only: bool, export: str):\n    \"\"\"Plot open interest\n\n    Parameters\n    ----------\n    ticker: str\n        Ticker\n    expiry: str\n        Expiry date for options\n    min_sp: float\n        Min strike to consider\n    max_sp: float\n        Max strike to consider\n    calls_only: bool\n        Show calls only\n    puts_only: bool\n        Show puts only\n    export: str\n        Format to export file\n    \"\"\"\n    options = tradier_model.get_option_chains(ticker, expiry)\n    export_data(export, os.path.dirname(os.path.abspath(__file__)), 'oi_tr', options)\n    current_price = tradier_model.last_price(ticker)\n    if min_sp == -1:\n        min_strike = 0.75 * current_price\n    else:\n        min_strike = min_sp\n    if max_sp == -1:\n        max_strike = 1.25 * current_price\n    else:\n        max_strike = max_sp\n    if calls_only and puts_only:\n        print('Both flags selected, please select one', '\\n')\n        return\n    calls = options[options.option_type == 'call'][['strike', 'open_interest']]\n    puts = options[options.option_type == 'put'][['strike', 'open_interest']]\n    call_oi = calls.set_index('strike')['open_interest'] / 1000\n    put_oi = puts.set_index('strike')['open_interest'] / 1000\n    df_opt = pd.merge(call_oi, put_oi, left_index=True, right_index=True)\n    df_opt = df_opt.rename(columns={'open_interest_x': 'OI_call', 'open_interest_y': 'OI_put'})\n    max_pain = op_helpers.calculate_max_pain(df_opt)\n    plt.style.use('classic')\n    fig, ax = plt.subplots(figsize=plot_autoscale(), dpi=cfp.PLOT_DPI)\n    if not calls_only:\n        put_oi.plot(x='strike', y='open_interest', label='Puts', ax=ax, marker='o', ls='-', c='r')\n    if not puts_only:\n        call_oi.plot(x='strike', y='open_interest', label='Calls', ax=ax, marker='o', ls='-', c='g')\n        ax.axvline(current_price, lw=2, c='k', ls='--', label='Current Price', alpha=0.7)\n        ax.axvline(max_pain, lw=3, c='k', label=f'Max Pain: {max_pain}', alpha=0.7)\n        ax.grid('on')\n        ax.set_xlabel('Strike Price')\n        ax.set_ylabel('Open Interest (1k) ')\n        ax.set_xlim(min_strike, max_strike)\n        if gtff.USE_ION:\n            plt.ion()\n        ax.set_title(f'Open Interest for {ticker.upper()} expiring {expiry}')\n        plt.legend(loc=0)\n        fig.tight_layout(pad=1)\n    plt.show()\n    plt.style.use('default')\n    print('')", "refactored": true, "pred": {"ppl": 1.985456943511963, "ppl_lower": 2.150026559829712, "ppl/lowercase_ppl": -1.1161058769636611, "ppl/zlib": 0.0007174153618100483, "Min_5.0% Prob": 7.3641618803927775, "Min_10.0% Prob": 5.467391630271813, "Min_20.0% Prob": 3.3003085824751084, "Min_30.0% Prob": 2.2757018026414104, "Min_40.0% Prob": 1.7141950121449847, "Min_50.0% Prob": 1.3714101658191906, "Min_60.0% Prob": 1.1445105594176028}}
{"hexsha": "467014e3a54821c2e5ac7b33d2f939b0052d1b15", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef run_task(hosts, command, timeout=None):\n    \"\"\"Create a task to run a command on each host in parallel.\n\n    Args:\n        hosts (list): list of hosts\n        command (str): the command to run in parallel\n        timeout (int, optional): command timeout in seconds. Defaults to None.\n\n    Returns:\n        Task: a ClusterShell.Task.Task object for the executed command\n\n    \"\"\"\n    task = task_self()\n    task.set_info('ssh_options', '-oForwardAgent=yes')\n    kwargs = {'command': command, 'nodes': NodeSet.fromlist(hosts)}\n    if timeout is not None:\n        kwargs['timeout'] = timeout\n    task.run(**kwargs)\n    return task", "fn_id": 3, "class_fn": false, "repo": "kmajzero/daos", "file": "src/tests/ftest/util/general_utils.py", "last_update_at": "2021-04-13T16:04:21+00:00", "original_content": "def run_task(hosts, command, timeout=None):\n    \"\"\"Create a task to run a command on each host in parallel.\n\n    Args:\n        hosts (list): list of hosts\n        command (str): the command to run in parallel\n        timeout (int, optional): command timeout in seconds. Defaults to None.\n\n    Returns:\n        Task: a ClusterShell.Task.Task object for the executed command\n\n    \"\"\"\n    task = task_self()\n    task.set_info('ssh_options', '-oForwardAgent=yes')\n    kwargs = {'command': command, 'nodes': NodeSet.fromlist(hosts)}\n    if timeout is not None:\n        kwargs['timeout'] = timeout\n    task.run(**kwargs)\n    return task", "refactored": true, "pred": {"ppl": 3.7201437950134277, "ppl_lower": 4.958712577819824, "ppl/lowercase_ppl": -1.2187487182219332, "ppl/zlib": 0.0036493397836430234, "Min_5.0% Prob": 9.110578298568726, "Min_10.0% Prob": 7.524549037218094, "Min_20.0% Prob": 5.4174894243478775, "Min_30.0% Prob": 4.11129543124413, "Min_40.0% Prob": 3.2341408527814424, "Min_50.0% Prob": 2.6077715227516687, "Min_60.0% Prob": 2.193904116597711}}
{"hexsha": "dac2bf672e1bd9ca92568b7538b014b4a37dd949", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef find_euler_random(n):\n    while True:\n        el = np.array([random.randint(0, 4) * 2 for x in range(n + 1)])\n        try:\n            g = Graph.from_sequence(el)\n            choose_biggest_comp(g)\n            if g.adjacency.shape[0] != n:\n                continue\n            print(g.adjacency)\n            for i in range(el.shape[0] * 3):\n                g.randomize_edges()\n            print(g.adjacency)\n            graph = nx.from_numpy_matrix(g.adjacency)\n            euler_list = []\n            euler(g.adjacency.tolist(), 0, euler_list)\n            print(euler_list)\n            plt.subplot(111)\n            nx.draw(graph, with_labels=True, font_weight='bold')\n            plt.show()\n            break\n        except NotGraphicSequenceException:\n            continue", "fn_id": 3, "class_fn": false, "repo": "timcki/graficiarze", "file": "02_project/main.py", "last_update_at": "2021-05-14T11:35:04+00:00", "original_content": "def find_euler_random(n):\n    while True:\n        el = np.array([random.randint(0, 4) * 2 for x in range(n + 1)])\n        try:\n            g = Graph.from_sequence(el)\n            choose_biggest_comp(g)\n            if g.adjacency.shape[0] != n:\n                continue\n            print(g.adjacency)\n            for i in range(el.shape[0] * 3):\n                g.randomize_edges()\n            print(g.adjacency)\n            graph = nx.from_numpy_matrix(g.adjacency)\n            euler_list = []\n            euler(g.adjacency.tolist(), 0, euler_list)\n            print(euler_list)\n            plt.subplot(111)\n            nx.draw(graph, with_labels=True, font_weight='bold')\n            plt.show()\n            break\n        except NotGraphicSequenceException:\n            continue", "refactored": true, "pred": {"ppl": 4.644679546356201, "ppl_lower": 5.48959493637085, "ppl/lowercase_ppl": -1.1088296243184717, "ppl/zlib": 0.004139413425720184, "Min_5.0% Prob": 10.26519571651112, "Min_10.0% Prob": 8.476302927190607, "Min_20.0% Prob": 6.28938856654697, "Min_30.0% Prob": 4.819066019200567, "Min_40.0% Prob": 3.7375168903006446, "Min_50.0% Prob": 3.0543573458812068, "Min_60.0% Prob": 2.5541661068245216}}
{"hexsha": "b27331e2a40b51e2950c979f9bac602c12eef9c1", "ext": "py", "lang": "Python", "content": "@app.route('/')\n@app.route('/index')\n@timeing\n@measure_memory_usage\ndef index():\n    app.logger.debug('Entering index')\n    flask.session['user_id'] = 'creator'\n    flask.session['finished'] = check_completed()\n    flask.session['to_finish'] = PEOPLE_TO_INVITE\n    events = []\n    for record in collection.find({'user_id': 'creator'}):\n        events.append(record)\n    if len(events) > 0:\n        return render_template('waiting.html')\n    if 'begin_date' not in flask.session:\n        init_session_values()\n    return render_template('index.html')", "fn_id": 0, "class_fn": false, "repo": "Dream7hief/MeetMe", "file": "flask_main.py", "last_update_at": "2021-02-08T20:18:11+00:00", "original_content": "@app.route('/')\n@app.route('/index')\ndef index():\n    app.logger.debug('Entering index')\n    flask.session['user_id'] = 'creator'\n    flask.session['finished'] = check_completed()\n    flask.session['to_finish'] = PEOPLE_TO_INVITE\n    events = []\n    for record in collection.find({'user_id': 'creator'}):\n        events.append(record)\n    if len(events) > 0:\n        return render_template('waiting.html')\n    if 'begin_date' not in flask.session:\n        init_session_values()\n    return render_template('index.html')", "refactored": true, "pred": {"ppl": 5.676433563232422, "ppl_lower": 5.981773853302002, "ppl/lowercase_ppl": -1.0301752663291652, "ppl/zlib": 0.005730439411643849, "Min_5.0% Prob": 12.11322021484375, "Min_10.0% Prob": 10.310849285125732, "Min_20.0% Prob": 7.381569916202176, "Min_30.0% Prob": 5.511767646099659, "Min_40.0% Prob": 4.281917072004742, "Min_50.0% Prob": 3.4499671598778496, "Min_60.0% Prob": 2.9108875197298985}}
{"hexsha": "11ad143814ad6766582b44de612f20dfd8d0423f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_x86_direct():\n    insn = ms.ISA_X86.parse_instruction('mov eax, dword ptr [0x8000]')\n    assert insn.num_operands == 2\n    op = insn.operands[1]\n    assert op.is_direct\n    assert op.offset == 32768\n    assert op.base_reg is None\n    assert op.index_reg is None\n    assert op.scale == 1\n    assert str(op) == '0x8000'\n    assert repr(op) == '<MemoryOperand(offset=0x8000)>'", "fn_id": 11, "class_fn": false, "repo": "giltom/megastone", "file": "tests/test_disasm.py", "last_update_at": "2021-04-12T15:12:10+00:00", "original_content": "def test_x86_direct():\n    insn = ms.ISA_X86.parse_instruction('mov eax, dword ptr [0x8000]')\n    assert insn.num_operands == 2\n    op = insn.operands[1]\n    assert op.is_direct\n    assert op.offset == 32768\n    assert op.base_reg is None\n    assert op.index_reg is None\n    assert op.scale == 1\n    assert str(op) == '0x8000'\n    assert repr(op) == '<MemoryOperand(offset=0x8000)>'", "refactored": true, "pred": {"ppl": 3.5963215827941895, "ppl_lower": 4.359600067138672, "ppl/lowercase_ppl": -1.1503766305790126, "ppl/zlib": 0.00533296475220513, "Min_5.0% Prob": 8.876195430755615, "Min_10.0% Prob": 7.422489132199969, "Min_20.0% Prob": 5.279129579149443, "Min_30.0% Prob": 3.999208986759186, "Min_40.0% Prob": 3.18193880391532, "Min_50.0% Prob": 2.5621156357739068, "Min_60.0% Prob": 2.134382893119685}}
{"hexsha": "12b9c9e1e1cd70be553e0f6bc5aeab33f9e284de", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef build_data_str(records):\n    records_data_str = []\n    for record in records:\n        records_data_str.append(tup_to_str(record))\n    return records_data_str", "fn_id": 0, "class_fn": false, "repo": "pangeon/Taskello", "file": "utils/str_utils.py", "last_update_at": "2021-06-22T21:18:37+00:00", "original_content": "def build_data_str(records):\n    records_data_str = []\n    for record in records:\n        records_data_str.append(tup_to_str(record))\n    return records_data_str", "refactored": true, "pred": {"ppl": 4.521440505981445, "ppl_lower": 4.521440505981445, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.012679249067940726, "Min_5.0% Prob": 10.461410522460938, "Min_10.0% Prob": 8.670522785186767, "Min_20.0% Prob": 6.491625048897483, "Min_30.0% Prob": 4.828096109278062, "Min_40.0% Prob": 3.846154210242358, "Min_50.0% Prob": 3.0573336854577065, "Min_60.0% Prob": 2.5266306265531218}}
{"hexsha": "e7dae2609f1a6ef8908cb001bd4912ee60a48a48", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef construct_tabs(selected_pipeline, window, prefs, include_eeg):\n    \"\"\"Constructs as set of tabs based on specifications and the\n    selected pipeline.\n\n    Parameters\n    ----------\n    selected_pipeline : str\n        ID of the selected pipeline\n    window : instance of main window\n        The main window.\n    prefs : Instance of PreferencesHandler\n        Stores e.g. active plugins.\n    include_eeg : bool\n        Whether to add EEG-related actions\n\n    Returns\n    -------\n    list of QDialog\n        Contains the constructed tabs relevant to the pipeline\n    \"\"\"\n    active_plugins = prefs.active_plugins\n    action_specs = find_all_action_specs()\n    datatype_specs = find_all_datatype_specs()\n    package_specs = find_all_package_specs()\n    tabs = []\n    pipelines = []\n    for source, package_spec in package_specs.items():\n        if source not in active_plugins and source != 'meggie':\n            continue\n        if 'tabs' in package_spec:\n            tabs.extend(package_spec['tabs'])\n        if 'pipelines' in package_spec:\n            pipelines.extend(package_spec['pipelines'])\n    for tab in tabs:\n        if 'id' not in tab:\n            raise Exception('Every tab specification must have id.')\n        if 'name' not in tab:\n            tab['name'] = tab['id']\n        if 'inputs' not in tab:\n            tab['inputs'] = []\n        if 'outputs' not in tab:\n            tab['outputs'] = []\n        if 'input_actions' not in tab:\n            tab['input_actions'] = []\n        if 'output_actions' not in tab:\n            tab['output_actions'] = []\n        if 'info' not in tab:\n            tab['info'] = []\n    for pipeline in pipelines:\n        if 'id' not in pipeline:\n            raise Exception('Every pipeline must have id.')\n        if 'name' not in pipeline:\n            pipeline['name'] = pipeline['id']\n    found = False\n    pipeline_spec = None\n    for pipeline in pipelines:\n        if pipeline['id'] == selected_pipeline:\n            found = True\n            pipeline_spec = pipeline\n            break\n    if not found:\n        pipeline_spec = {'id': 'classic', 'name': 'Include everything'}\n    combined_tabs = []\n    for tab_spec in tabs:\n        if pipeline_spec.get('include_tabs'):\n            if tab_spec['id'] not in pipeline_spec['include_tabs']:\n                continue\n        if tab_spec['id'] not in [tab['id'] for tab in combined_tabs]:\n            new_tab = {}\n            new_tab['id'] = tab_spec['id']\n            new_tab['name'] = tab_spec['name']\n            new_tab['inputs'] = []\n            new_tab['outputs'] = []\n            new_tab['input_actions'] = []\n            new_tab['output_actions'] = []\n            new_tab['info'] = []\n            idx = len(combined_tabs)\n            combined_tabs.append(new_tab)\n        else:\n            idx = [tab['id'] for tab in combined_tabs].index(tab_spec['id'])\n        for input_spec in tab_spec['inputs']:\n            if input_spec not in combined_tabs[idx]['inputs']:\n                combined_tabs[idx]['inputs'].append(input_spec)\n        for output_spec in tab_spec['outputs']:\n            if output_spec not in combined_tabs[idx]['outputs']:\n                combined_tabs[idx]['outputs'].append(output_spec)\n        for input_spec in tab_spec['input_actions']:\n            action_spec = action_specs.get(input_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + input_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if input_spec not in combined_tabs[idx]['input_actions']:\n                combined_tabs[idx]['input_actions'].append(input_spec)\n        for output_spec in tab_spec['output_actions']:\n            action_spec = action_specs.get(output_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + output_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if output_spec not in combined_tabs[idx]['output_actions']:\n                combined_tabs[idx]['output_actions'].append(output_spec)\n        for info_spec in tab_spec['info']:\n            action_spec = action_specs.get(info_spec)\n            if not action_spec:\n                raise Exception('Cannot read info item ' + info_spec + '.')\n            if info_spec not in combined_tabs[idx]['info']:\n                combined_tabs[idx]['info'].append(info_spec)\n    tabs = []\n    for tab_spec in combined_tabs:\n        tabs.append(construct_tab(tab_spec, action_specs, datatype_specs, window))\n    return tabs", "fn_id": 6, "class_fn": false, "repo": "Teekuningas/meggie", "file": "meggie/mainwindow/dynamic.py", "last_update_at": "2021-01-15T21:21:51+00:00", "original_content": "def construct_tabs(selected_pipeline, window, prefs, include_eeg):\n    \"\"\"Constructs as set of tabs based on specifications and the\n    selected pipeline.\n\n    Parameters\n    ----------\n    selected_pipeline : str\n        ID of the selected pipeline\n    window : instance of main window\n        The main window.\n    prefs : Instance of PreferencesHandler\n        Stores e.g. active plugins.\n    include_eeg : bool\n        Whether to add EEG-related actions\n\n    Returns\n    -------\n    list of QDialog\n        Contains the constructed tabs relevant to the pipeline\n    \"\"\"\n    active_plugins = prefs.active_plugins\n    action_specs = find_all_action_specs()\n    datatype_specs = find_all_datatype_specs()\n    package_specs = find_all_package_specs()\n    tabs = []\n    pipelines = []\n    for source, package_spec in package_specs.items():\n        if source not in active_plugins and source != 'meggie':\n            continue\n        if 'tabs' in package_spec:\n            tabs.extend(package_spec['tabs'])\n        if 'pipelines' in package_spec:\n            pipelines.extend(package_spec['pipelines'])\n    for tab in tabs:\n        if 'id' not in tab:\n            raise Exception('Every tab specification must have id.')\n        if 'name' not in tab:\n            tab['name'] = tab['id']\n        if 'inputs' not in tab:\n            tab['inputs'] = []\n        if 'outputs' not in tab:\n            tab['outputs'] = []\n        if 'input_actions' not in tab:\n            tab['input_actions'] = []\n        if 'output_actions' not in tab:\n            tab['output_actions'] = []\n        if 'info' not in tab:\n            tab['info'] = []\n    for pipeline in pipelines:\n        if 'id' not in pipeline:\n            raise Exception('Every pipeline must have id.')\n        if 'name' not in pipeline:\n            pipeline['name'] = pipeline['id']\n    found = False\n    pipeline_spec = None\n    for pipeline in pipelines:\n        if pipeline['id'] == selected_pipeline:\n            found = True\n            pipeline_spec = pipeline\n            break\n    if not found:\n        pipeline_spec = {'id': 'classic', 'name': 'Include everything'}\n    combined_tabs = []\n    for tab_spec in tabs:\n        if pipeline_spec.get('include_tabs'):\n            if tab_spec['id'] not in pipeline_spec['include_tabs']:\n                continue\n        if tab_spec['id'] not in [tab['id'] for tab in combined_tabs]:\n            new_tab = {}\n            new_tab['id'] = tab_spec['id']\n            new_tab['name'] = tab_spec['name']\n            new_tab['inputs'] = []\n            new_tab['outputs'] = []\n            new_tab['input_actions'] = []\n            new_tab['output_actions'] = []\n            new_tab['info'] = []\n            idx = len(combined_tabs)\n            combined_tabs.append(new_tab)\n        else:\n            idx = [tab['id'] for tab in combined_tabs].index(tab_spec['id'])\n        for input_spec in tab_spec['inputs']:\n            if input_spec not in combined_tabs[idx]['inputs']:\n                combined_tabs[idx]['inputs'].append(input_spec)\n        for output_spec in tab_spec['outputs']:\n            if output_spec not in combined_tabs[idx]['outputs']:\n                combined_tabs[idx]['outputs'].append(output_spec)\n        for input_spec in tab_spec['input_actions']:\n            action_spec = action_specs.get(input_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + input_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if input_spec not in combined_tabs[idx]['input_actions']:\n                combined_tabs[idx]['input_actions'].append(input_spec)\n        for output_spec in tab_spec['output_actions']:\n            action_spec = action_specs.get(output_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + output_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if output_spec not in combined_tabs[idx]['output_actions']:\n                combined_tabs[idx]['output_actions'].append(output_spec)\n        for info_spec in tab_spec['info']:\n            action_spec = action_specs.get(info_spec)\n            if not action_spec:\n                raise Exception('Cannot read info item ' + info_spec + '.')\n            if info_spec not in combined_tabs[idx]['info']:\n                combined_tabs[idx]['info'].append(info_spec)\n    tabs = []\n    for tab_spec in combined_tabs:\n        tabs.append(construct_tab(tab_spec, action_specs, datatype_specs, window))\n    return tabs", "refactored": true, "pred": {"ppl": 2.0361557006835938, "ppl_lower": 2.181586503982544, "ppl/lowercase_ppl": -1.0970219817341254, "ppl/zlib": 0.0006411754459670544, "Min_5.0% Prob": 8.43142225228104, "Min_10.0% Prob": 5.942445811103372, "Min_20.0% Prob": 3.482025560356823, "Min_30.0% Prob": 2.370411973397911, "Min_40.0% Prob": 1.7778056713235553, "Min_50.0% Prob": 1.4234030222023133, "Min_60.0% Prob": 1.1866373315894216}}
{"hexsha": "8ce8096f58ca81419a2edfa556d2c57b16fdd66c", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef deepcopy_and_sign(rlp_signable, privatekey):\n    msg = deepcopy(rlp_signable)\n    msg.sign(privatekey)\n    return msg", "fn_id": 0, "class_fn": false, "repo": "luehrsFred/raidex", "file": "raidex/tests/unit/commitment_service/old_test_swap_commitment.py", "last_update_at": "2021-06-22T05:01:56+00:00", "original_content": "def deepcopy_and_sign(rlp_signable, privatekey):\n    msg = deepcopy(rlp_signable)\n    msg.sign(privatekey)\n    return msg", "refactored": true, "pred": {"ppl": 8.130766868591309, "ppl_lower": 8.130766868591309, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.018879776981002808, "Min_5.0% Prob": 11.38077974319458, "Min_10.0% Prob": 10.465718388557434, "Min_20.0% Prob": 8.412068049112955, "Min_30.0% Prob": 6.67985234941755, "Min_40.0% Prob": 5.221221412483015, "Min_50.0% Prob": 4.175877930906911, "Min_60.0% Prob": 3.5875066679769327}}
{"hexsha": "338af77e36625c6e736374eb318b1d3d29015cd3", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef find_replacement_chord(chord):\n    t = chord.transpose(-chord.bass)\n    if t.pitches == (0, 4, 6, 10):\n        return Chord(bass=0, root=0, pitches=(0, 4, 10)).transpose(chord.bass)\n    if t.pitches == (0, 3, 8, 10):\n        return Chord(bass=0, root=8, pitches=(0, 3, 8)).transpose(chord.bass)\n    if t.pitches == (0, 4, 6, 11):\n        return Chord(bass=0, root=0, pitches=(0, 4, 6, 7, 11)).transpose(chord.bass)\n    if t.pitches == (0, 2, 4, 6, 10):\n        return Chord(bass=0, root=10, pitches=(0, 2, 6, 10)).transpose(chord.bass)\n    raise ValueError('no such chord: ' + str(chord))", "fn_id": 7, "class_fn": false, "repo": "andreasjansson/music-inpainting-bert", "file": "data.py", "last_update_at": "2021-11-25T22:59:11+00:00", "original_content": "def find_replacement_chord(chord):\n    t = chord.transpose(-chord.bass)\n    if t.pitches == (0, 4, 6, 10):\n        return Chord(bass=0, root=0, pitches=(0, 4, 10)).transpose(chord.bass)\n    if t.pitches == (0, 3, 8, 10):\n        return Chord(bass=0, root=8, pitches=(0, 3, 8)).transpose(chord.bass)\n    if t.pitches == (0, 4, 6, 11):\n        return Chord(bass=0, root=0, pitches=(0, 4, 6, 7, 11)).transpose(chord.bass)\n    if t.pitches == (0, 2, 4, 6, 10):\n        return Chord(bass=0, root=10, pitches=(0, 2, 6, 10)).transpose(chord.bass)\n    raise ValueError('no such chord: ' + str(chord))", "refactored": true, "pred": {"ppl": 2.0373785495758057, "ppl_lower": 2.2355101108551025, "ppl/lowercase_ppl": -1.1304063271313634, "ppl/zlib": 0.003177071235652331, "Min_5.0% Prob": 6.8492093819838304, "Min_10.0% Prob": 5.151512561021028, "Min_20.0% Prob": 3.314250287142667, "Min_30.0% Prob": 2.3543339581733727, "Min_40.0% Prob": 1.7822545584928882, "Min_50.0% Prob": 1.427678053592258, "Min_60.0% Prob": 1.1887980250447912}}
{"hexsha": "969279abcd7947481d7b6dda02b897ac7a615367", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef main() -> typing.NoReturn:\n    h, w, d = map(int, input().split())\n    I = np.array(sys.stdin.read().split(), dtype=np.int64)\n    a = I[:h * w].reshape(h, w) - 1\n    lr = I[h * w + 1:].reshape(-1, 2) - 1\n    solve(a, d, lr)", "fn_id": 1, "class_fn": false, "repo": "kagemeka/competitive-programming", "file": "src/atcoder/abc089/d/sol_0.py", "last_update_at": "2021-07-11T03:20:10+00:00", "original_content": "def main() -> typing.NoReturn:\n    h, w, d = map(int, input().split())\n    I = np.array(sys.stdin.read().split(), dtype=np.int64)\n    a = I[:h * w].reshape(h, w) - 1\n    lr = I[h * w + 1:].reshape(-1, 2) - 1\n    solve(a, d, lr)", "refactored": true, "pred": {"ppl": 3.116896629333496, "ppl_lower": 3.6068854331970215, "ppl/lowercase_ppl": -1.1284323916967538, "ppl/zlib": 0.006145069387694092, "Min_5.0% Prob": 9.338286304473877, "Min_10.0% Prob": 7.777338361740112, "Min_20.0% Prob": 5.167191074008033, "Min_30.0% Prob": 3.674515273422003, "Min_40.0% Prob": 2.858078310532229, "Min_50.0% Prob": 2.2848575032263434, "Min_60.0% Prob": 1.8980118958861567}}
{"hexsha": "f25d845a5d072ddbe9a4ba42086800a674959571", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef func_18fc8c7e787b450bb9ba27326af7b455(x):\n    x = sorted(x, reverse=True)\n    rmax = 0.0\n    y = [x[i] for i in xrange(len(x))]\n    return y", "fn_id": 134, "class_fn": false, "repo": "DynamicCodeSearch/CodeSeer", "file": "projects/src/main/python/CodeJam/Y13R5P1/gepa/generated_py_84001afe6c4e45fca49f21e859b1c46f.py", "last_update_at": "2021-04-13T20:34:19+00:00", "original_content": "def func_18fc8c7e787b450bb9ba27326af7b455(x):\n    x = sorted(x, reverse=True)\n    rmax = 0.0\n    y = [x[i] for i in xrange(len(x))]\n    return y", "refactored": true, "pred": {"ppl": 11.395318031311035, "ppl_lower": 12.700725555419922, "ppl/lowercase_ppl": -1.0445735802660194, "ppl/zlib": 0.016552398449202105, "Min_5.0% Prob": 9.767007112503052, "Min_10.0% Prob": 8.499874830245972, "Min_20.0% Prob": 6.905271291732788, "Min_30.0% Prob": 5.687928368647893, "Min_40.0% Prob": 4.895637013695457, "Min_50.0% Prob": 4.430740333184963, "Min_60.0% Prob": 4.004350533290785}}
{"hexsha": "35f904677ad8fd1f812f7b5f6172973cf62eaed0", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef mixture_fit(x, K=3, x_w=None, n_itr=100, verbose=False, random_state=0, f_write=None, output_folder=None, suffix=None, fold_number=0):\n    \"\"\"Fit a slope+bump mixture using EM algorithm.\n\n    Args:\n        x ((n,d) ndarray): The covaraites.\n        K (int): The number of bump components.\n        x_w ((n,) ndarray): The weights for each sample.\n        n_itr (int): The maximum number of iterations for the EM algorithm\n        verbose (bool): Indicate if output the computation details.\n        random_state (int): The random seed.\n        f_write (file handler (write mode)): The output file.\n        output_folder (string): The output directory.\n        suffix (string): The suffix of the output file.\n        fold_number (int(0,1)): The fold number.\n\n    Returns:\n        a ((d,) ndarray): slope parameter.\n        mu,sigma ((k,d) ndarray): bump parameter.\n        w ((n,) ndarray): proportion of each component. \n    \"\"\"\n    np.random.seed(random_state)\n    if len(x.shape) == 1:\n        x = x.reshape([-1, 1])\n    n_samp, d = x.shape\n    if x_w is None:\n        x_w = np.ones([n_samp], dtype=float)\n    GMM = GaussianMixture(n_components=K, covariance_type='diag').fit(x)\n    w_old = np.zeros([K + 1])\n    w = 0.5 * np.ones([K + 1]) / K\n    w[0] = 0.5\n    a = ML_slope(x, x_w)\n    mu, sigma = (GMM.means_, GMM.covariances_ ** 0.5)\n    w_samp = np.zeros([K + 1, n_samp], dtype=float)\n    i = 0\n    if verbose:\n        if f_write is not None:\n            f_write.write('## mixture_fit: initialization parameters\\n')\n            f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n            for k in range(K):\n                f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n                f_write.write('         mu=%s\\n' % mu[k])\n                f_write.write('      sigma=%s\\n' % sigma[k])\n            f_write.write('\\n')\n    while np.linalg.norm(w - w_old, 1) > 0.005 and i < n_itr:\n        w_old = w\n        w_samp[0, :] = w[0] * f_slope(x, a)\n        for k in range(K):\n            w_samp[k + 1, :] = w[k + 1] * f_bump(x, mu[k], sigma[k])\n        w_samp = w_samp / np.sum(w_samp, axis=0) * x_w\n        w = np.mean(w_samp, axis=1)\n        a = ML_slope(x, w_samp[0, :])\n        for k in range(K):\n            if w[k + 1] > 0.0001:\n                mu[k], sigma[k] = ML_bump(x, w_samp[k + 1, :])\n        sigma = sigma.clip(min=0.0001)\n        w[w < 0.001] = 0\n        w /= w.sum()\n        i += 1\n    if i >= n_itr and verbose:\n        print('Warning: the model does not converge, w_dif=%0.4f' % np.linalg.norm(w - w_old, 1))\n        if f_write is not None:\n            f_write.write('Warning: the model does not converge, w_dif=%0.4f\\n' % np.linalg.norm(w - w_old, 1))\n    if verbose and f_write is not None:\n        f_write.write('## mixture_fit: learned parameters\\n')\n        f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n        for k in range(K):\n            f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n            f_write.write('         mu=%s\\n' % mu[k])\n            f_write.write('      sigma=%s\\n' % sigma[k])\n        f_write.write('\\n')\n    if output_folder is not None:\n        bins_ = np.linspace(0, 1, 101)\n        x_grid = bins_.reshape([-1, 1])\n        if d == 1:\n            plt.figure(figsize=[8, 5])\n            plt.hist(x, bins=bins_, weights=x_w / np.sum(x_w) * 100)\n            temp_p = f_all(x_grid, a, mu, sigma, w)\n            plt.plot(bins_, temp_p)\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        else:\n            plt.figure(figsize=[8, 12])\n            n_figure = min(d, 5)\n            for i_dim in range(n_figure):\n                plt.subplot(str(n_figure) + '1' + str(i_dim + 1))\n                plt.hist(x[:, i_dim], bins=bins_, weights=x_w / np.sum(x_w) * 100)\n                temp_p = f_all(x_grid, a[[i_dim]], mu[:, [i_dim]], sigma[:, [i_dim]], w)\n                plt.plot(bins_, temp_p)\n                plt.title('Dimension %d' % (i_dim + 1))\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        plt.close('all')\n    return (a, mu, sigma, w)", "fn_id": 14, "class_fn": false, "repo": "martinjzhang/adafdr", "file": "adafdr/method.py", "last_update_at": "2021-05-21T09:23:58+00:00", "original_content": "def mixture_fit(x, K=3, x_w=None, n_itr=100, verbose=False, random_state=0, f_write=None, output_folder=None, suffix=None, fold_number=0):\n    \"\"\"Fit a slope+bump mixture using EM algorithm.\n\n    Args:\n        x ((n,d) ndarray): The covaraites.\n        K (int): The number of bump components.\n        x_w ((n,) ndarray): The weights for each sample.\n        n_itr (int): The maximum number of iterations for the EM algorithm\n        verbose (bool): Indicate if output the computation details.\n        random_state (int): The random seed.\n        f_write (file handler (write mode)): The output file.\n        output_folder (string): The output directory.\n        suffix (string): The suffix of the output file.\n        fold_number (int(0,1)): The fold number.\n\n    Returns:\n        a ((d,) ndarray): slope parameter.\n        mu,sigma ((k,d) ndarray): bump parameter.\n        w ((n,) ndarray): proportion of each component. \n    \"\"\"\n    np.random.seed(random_state)\n    if len(x.shape) == 1:\n        x = x.reshape([-1, 1])\n    n_samp, d = x.shape\n    if x_w is None:\n        x_w = np.ones([n_samp], dtype=float)\n    GMM = GaussianMixture(n_components=K, covariance_type='diag').fit(x)\n    w_old = np.zeros([K + 1])\n    w = 0.5 * np.ones([K + 1]) / K\n    w[0] = 0.5\n    a = ML_slope(x, x_w)\n    mu, sigma = (GMM.means_, GMM.covariances_ ** 0.5)\n    w_samp = np.zeros([K + 1, n_samp], dtype=float)\n    i = 0\n    if verbose:\n        if f_write is not None:\n            f_write.write('## mixture_fit: initialization parameters\\n')\n            f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n            for k in range(K):\n                f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n                f_write.write('         mu=%s\\n' % mu[k])\n                f_write.write('      sigma=%s\\n' % sigma[k])\n            f_write.write('\\n')\n    while np.linalg.norm(w - w_old, 1) > 0.005 and i < n_itr:\n        w_old = w\n        w_samp[0, :] = w[0] * f_slope(x, a)\n        for k in range(K):\n            w_samp[k + 1, :] = w[k + 1] * f_bump(x, mu[k], sigma[k])\n        w_samp = w_samp / np.sum(w_samp, axis=0) * x_w\n        w = np.mean(w_samp, axis=1)\n        a = ML_slope(x, w_samp[0, :])\n        for k in range(K):\n            if w[k + 1] > 0.0001:\n                mu[k], sigma[k] = ML_bump(x, w_samp[k + 1, :])\n        sigma = sigma.clip(min=0.0001)\n        w[w < 0.001] = 0\n        w /= w.sum()\n        i += 1\n    if i >= n_itr and verbose:\n        print('Warning: the model does not converge, w_dif=%0.4f' % np.linalg.norm(w - w_old, 1))\n        if f_write is not None:\n            f_write.write('Warning: the model does not converge, w_dif=%0.4f\\n' % np.linalg.norm(w - w_old, 1))\n    if verbose and f_write is not None:\n        f_write.write('## mixture_fit: learned parameters\\n')\n        f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n        for k in range(K):\n            f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n            f_write.write('         mu=%s\\n' % mu[k])\n            f_write.write('      sigma=%s\\n' % sigma[k])\n        f_write.write('\\n')\n    if output_folder is not None:\n        bins_ = np.linspace(0, 1, 101)\n        x_grid = bins_.reshape([-1, 1])\n        if d == 1:\n            plt.figure(figsize=[8, 5])\n            plt.hist(x, bins=bins_, weights=x_w / np.sum(x_w) * 100)\n            temp_p = f_all(x_grid, a, mu, sigma, w)\n            plt.plot(bins_, temp_p)\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        else:\n            plt.figure(figsize=[8, 12])\n            n_figure = min(d, 5)\n            for i_dim in range(n_figure):\n                plt.subplot(str(n_figure) + '1' + str(i_dim + 1))\n                plt.hist(x[:, i_dim], bins=bins_, weights=x_w / np.sum(x_w) * 100)\n                temp_p = f_all(x_grid, a[[i_dim]], mu[:, [i_dim]], sigma[:, [i_dim]], w)\n                plt.plot(bins_, temp_p)\n                plt.title('Dimension %d' % (i_dim + 1))\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        plt.close('all')\n    return (a, mu, sigma, w)", "refactored": true, "pred": {"ppl": 2.533370018005371, "ppl_lower": 2.6099417209625244, "ppl/lowercase_ppl": -1.0320342515929752, "ppl/zlib": 0.000678999590438951, "Min_5.0% Prob": 8.739674988914938, "Min_10.0% Prob": 6.679569744596295, "Min_20.0% Prob": 4.266515160308165, "Min_30.0% Prob": 3.031343787324195, "Min_40.0% Prob": 2.310638909690392, "Min_50.0% Prob": 1.8581328390789476, "Min_60.0% Prob": 1.550769801520504}}
{"hexsha": "184edbc2fe82843b354712c8ba7f81417e3fb3d2", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef main(arguments):\n    cap = cv2.VideoCapture(arguments.video)\n    model: tf.keras.Model = tf.keras.models.load_model(arguments.weights_path)\n    model.compile(optimizer='adam', loss=tf.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=['accuracy'])\n    classes = get_classes(os.path.join(arguments.data_path, 'training_set'))\n    success, img = cap.read()\n    while success:\n        img_pp = preprocess_image(img, INPUT_SHAPE)\n        x = model.predict(np.expand_dims(img_pp, 0), batch_size=1)\n        img_out = write_class_on_img(img_pp, classes[int(np.argmax(np.array(x)))])\n        cv2.imshow('EfficientNet Prediction', img_out)\n        cv2.waitKey(10)\n        success, img = cap.read()", "fn_id": 0, "class_fn": false, "repo": "vincenzosantopietro/Action-Recognition-EfficientNet-TensorFlow", "file": "demo.py", "last_update_at": "2021-08-24T06:48:24+00:00", "original_content": "def main(arguments):\n    cap = cv2.VideoCapture(arguments.video)\n    model: tf.keras.Model = tf.keras.models.load_model(arguments.weights_path)\n    model.compile(optimizer='adam', loss=tf.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=['accuracy'])\n    classes = get_classes(os.path.join(arguments.data_path, 'training_set'))\n    success, img = cap.read()\n    while success:\n        img_pp = preprocess_image(img, INPUT_SHAPE)\n        x = model.predict(np.expand_dims(img_pp, 0), batch_size=1)\n        img_out = write_class_on_img(img_pp, classes[int(np.argmax(np.array(x)))])\n        cv2.imshow('EfficientNet Prediction', img_out)\n        cv2.waitKey(10)\n        success, img = cap.read()", "refactored": true, "pred": {"ppl": 3.1773488521575928, "ppl_lower": 4.153816223144531, "ppl/lowercase_ppl": -1.2318074376486143, "ppl/zlib": 0.0027201109524368538, "Min_5.0% Prob": 8.74725953015414, "Min_10.0% Prob": 7.117135698145086, "Min_20.0% Prob": 5.0517966376410595, "Min_30.0% Prob": 3.7083615012028637, "Min_40.0% Prob": 2.8555125487702235, "Min_50.0% Prob": 2.3022920458593914, "Min_60.0% Prob": 1.9362396556774484}}
{"hexsha": "3836b014a35e2f166dd6e956235064be019753de", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef createSampleFile(sampleFilePath):\n    if not os.path.exists(sampleFilePath):\n        _dir = os.path.dirname(sampleFilePath)\n        if not os.path.exists(_dir):\n            os.makedirs(_dir, mode=493)\n        import uuid\n        with open(sampleFilePath, 'w') as f:\n            f.write(str(uuid.uuid1()) + '\\n')\n            f.write(str(uuid.uuid4()) + '\\n')\n    return sampleFilePath", "fn_id": 0, "class_fn": false, "repo": "Fanduzi/huaweicloud-sdk-python-obs", "file": "examples/download_sample.py", "last_update_at": "2021-12-13T07:21:48+00:00", "original_content": "def createSampleFile(sampleFilePath):\n    if not os.path.exists(sampleFilePath):\n        _dir = os.path.dirname(sampleFilePath)\n        if not os.path.exists(_dir):\n            os.makedirs(_dir, mode=493)\n        import uuid\n        with open(sampleFilePath, 'w') as f:\n            f.write(str(uuid.uuid1()) + '\\n')\n            f.write(str(uuid.uuid4()) + '\\n')\n    return sampleFilePath", "refactored": true, "pred": {"ppl": 2.692819118499756, "ppl_lower": 2.7129745483398438, "ppl/lowercase_ppl": -1.0075278552975164, "ppl/zlib": 0.004977832383356748, "Min_5.0% Prob": 8.849504566192627, "Min_10.0% Prob": 6.898499098691073, "Min_20.0% Prob": 4.8446366475976035, "Min_30.0% Prob": 3.318787011504173, "Min_40.0% Prob": 2.4983698090023183, "Min_50.0% Prob": 1.9968941034275596, "Min_60.0% Prob": 1.6601381711858574}}
{"hexsha": "8ee4e5b90ef2f57ff31c13abfc6ea37b6aa9f151", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef cosine_similarity(A, B):\n    t1 = vector_multiply(A, B)\n    t2 = sqrt(vector_multiply(A, A))\n    t3 = sqrt(vector_multiply(B, B))\n    if t2 > 0 and t3 > 0:\n        return t1 / (t2 * t3)\n    else:\n        return 0", "fn_id": 0, "class_fn": false, "repo": "Pengeace/LncRNA-Disease-link", "file": "sample/parallel_prediction_CV.py", "last_update_at": "2021-12-12T13:15:20+00:00", "original_content": "def cosine_similarity(A, B):\n    t1 = vector_multiply(A, B)\n    t2 = sqrt(vector_multiply(A, A))\n    t3 = sqrt(vector_multiply(B, B))\n    if t2 > 0 and t3 > 0:\n        return t1 / (t2 * t3)\n    else:\n        return 0", "refactored": true, "pred": {"ppl": 2.597050666809082, "ppl_lower": 2.4975414276123047, "ppl/lowercase_ppl": -0.9590626701674181, "ppl/zlib": 0.006448489474566256, "Min_5.0% Prob": 8.806594848632812, "Min_10.0% Prob": 7.402534484863281, "Min_20.0% Prob": 4.800091872612636, "Min_30.0% Prob": 3.2661094207454613, "Min_40.0% Prob": 2.3956728242337704, "Min_50.0% Prob": 1.9289364355120242, "Min_60.0% Prob": 1.6136265182761813}}
{"hexsha": "0a460dfb309ddfb8343e04a6b02b1cc8858e4c42", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef import_no_virt_driver_import_deps(physical_line, filename):\n    \"\"\"Check virt drivers' modules aren't imported by other drivers\n\n    Modules under each virt driver's directory are\n    considered private to that virt driver. Other drivers\n    in Nova must not access those drivers. Any code that\n    is to be shared should be refactored into a common\n    module\n\n    N311\n    \"\"\"\n    thisdriver = _get_virt_name(virt_file_re, filename)\n    thatdriver = _get_virt_name(virt_import_re, physical_line)\n    if thatdriver is not None and thisdriver is not None and (thisdriver != thatdriver):\n        return (0, 'N311: importing code from other virt drivers forbidden')", "fn_id": 4, "class_fn": false, "repo": "KevinWang2015/nova", "file": "nova/hacking/checks.py", "last_update_at": "2021-05-12T07:52:44+00:00", "original_content": "def import_no_virt_driver_import_deps(physical_line, filename):\n    \"\"\"Check virt drivers' modules aren't imported by other drivers\n\n    Modules under each virt driver's directory are\n    considered private to that virt driver. Other drivers\n    in Nova must not access those drivers. Any code that\n    is to be shared should be refactored into a common\n    module\n\n    N311\n    \"\"\"\n    thisdriver = _get_virt_name(virt_file_re, filename)\n    thatdriver = _get_virt_name(virt_import_re, physical_line)\n    if thatdriver is not None and thisdriver is not None and (thisdriver != thatdriver):\n        return (0, 'N311: importing code from other virt drivers forbidden')", "refactored": true, "pred": {"ppl": 9.919815063476562, "ppl_lower": 12.72250747680664, "ppl/lowercase_ppl": -1.1084483205094806, "ppl/zlib": 0.0065745967860409765, "Min_5.0% Prob": 10.052239060401917, "Min_10.0% Prob": 8.975607479319853, "Min_20.0% Prob": 7.328294590541295, "Min_30.0% Prob": 6.193601479897132, "Min_40.0% Prob": 5.247185441425868, "Min_50.0% Prob": 4.470810881976424, "Min_60.0% Prob": 3.799569787156014}}
{"hexsha": "8a91b3f07767ea74f9a6d8cb283d9cb8dd32dbfa", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef task_factory(name, func=None, vars=None, color='GREEN', ext_in=[], ext_out=[], before=[], after=[], shell=False, scan=None):\n    params = {'vars': vars or [], 'color': color, 'name': name, 'ext_in': Utils.to_list(ext_in), 'ext_out': Utils.to_list(ext_out), 'before': Utils.to_list(before), 'after': Utils.to_list(after), 'shell': shell, 'scan': scan}\n    if isinstance(func, str):\n        params['run_str'] = func\n    else:\n        params['run'] = func\n    cls = type(Task)(name, (Task,), params)\n    global classes\n    classes[name] = cls\n    return cls", "fn_id": 8, "class_fn": false, "repo": "He-Ze/Distributed-System-SYSU", "file": "\u4f5c\u4e1a/\u4f5c\u4e1a5/nack-oriented-reliable-multicast-master/norm-1.5r6/.waf3-1.8.11-930623f783bdf2f01355c2002e2b4462/waflib/Task.py", "last_update_at": "2021-09-17T07:35:05+00:00", "original_content": "def task_factory(name, func=None, vars=None, color='GREEN', ext_in=[], ext_out=[], before=[], after=[], shell=False, scan=None):\n    params = {'vars': vars or [], 'color': color, 'name': name, 'ext_in': Utils.to_list(ext_in), 'ext_out': Utils.to_list(ext_out), 'before': Utils.to_list(before), 'after': Utils.to_list(after), 'shell': shell, 'scan': scan}\n    if isinstance(func, str):\n        params['run_str'] = func\n    else:\n        params['run'] = func\n    cls = type(Task)(name, (Task,), params)\n    global classes\n    classes[name] = cls\n    return cls", "refactored": true, "pred": {"ppl": 3.643376350402832, "ppl_lower": 4.061220645904541, "ppl/lowercase_ppl": -1.0839754435420779, "ppl/zlib": 0.004239051870539479, "Min_5.0% Prob": 10.38974412282308, "Min_10.0% Prob": 8.586560461256239, "Min_20.0% Prob": 5.896707001659605, "Min_30.0% Prob": 4.220831582762978, "Min_40.0% Prob": 3.2383974706881666, "Min_50.0% Prob": 2.580774297674551, "Min_60.0% Prob": 2.1614595585672016}}
{"hexsha": "1407f6d79ec90ec0ceecb5413d805601158c4cae", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_bot() -> Bot:\n    for bot in DRIVER.bots.values():\n        return bot\n    return None", "fn_id": 0, "class_fn": false, "repo": "7sDream/nonebot_plugin_bam", "file": "nonebot_plugin_bam/common.py", "last_update_at": "2021-12-28T07:13:51+00:00", "original_content": "def get_bot() -> Bot:\n    for bot in DRIVER.bots.values():\n        return bot\n    return None", "refactored": true, "pred": {"ppl": 11.960101127624512, "ppl_lower": 22.23186683654785, "ppl/lowercase_ppl": -1.2498212618802247, "ppl/zlib": 0.022559783672488523, "Min_5.0% Prob": 10.446242332458496, "Min_10.0% Prob": 8.88290023803711, "Min_20.0% Prob": 7.837648936680385, "Min_30.0% Prob": 6.896856141090393, "Min_40.0% Prob": 5.647850326129368, "Min_50.0% Prob": 4.935833369984346, "Min_60.0% Prob": 4.121788203716278}}
{"hexsha": "8b6e4daf34e200f38605973d93690899eefdcfed", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef check_build_is_legit(build):\n    build_string = build.lower()\n    build_number = build_string.replace('build', '')\n    if build_number in BUILD_MAP.keys():\n        return True\n    return False", "fn_id": 1, "class_fn": false, "repo": "EBISPOT/gwas-sumstats-validator", "file": "validate/validator.py", "last_update_at": "2021-04-14T17:38:42+00:00", "original_content": "def check_build_is_legit(build):\n    build_string = build.lower()\n    build_number = build_string.replace('build', '')\n    if build_number in BUILD_MAP.keys():\n        return True\n    return False", "refactored": true, "pred": {"ppl": 6.665757179260254, "ppl_lower": 7.793636322021484, "ppl/lowercase_ppl": -1.0824066143751434, "ppl/zlib": 0.012160150977361797, "Min_5.0% Prob": 8.157659689585367, "Min_10.0% Prob": 7.599539756774902, "Min_20.0% Prob": 6.697124163309733, "Min_30.0% Prob": 5.623061113887363, "Min_40.0% Prob": 4.532533583641052, "Min_50.0% Prob": 3.7656149691151035, "Min_60.0% Prob": 3.197270142468246}}
{"hexsha": "eb4e6315d4870bd2d06b1d9423ac6fcf2195cdeb", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef SOIC(A, B, L, T, W, num_pins, pitch=1.27, profile=ipc.LandPatternSize.Nominal):\n    f = fp.Footprint(name='{0}-SOIC'.format(num_pins), description='{0}-pin SOIC'.format(num_pins))\n    f.from_ipc(lib.SOIC(profile, A, B, L, T, W, num_pins, pitch))\n    return f", "fn_id": 2, "class_fn": false, "repo": "TheWylieStCoyote/kidraw", "file": "kidraw/footprint/library.py", "last_update_at": "2021-01-11T20:14:23+00:00", "original_content": "def SOIC(A, B, L, T, W, num_pins, pitch=1.27, profile=ipc.LandPatternSize.Nominal):\n    f = fp.Footprint(name='{0}-SOIC'.format(num_pins), description='{0}-pin SOIC'.format(num_pins))\n    f.from_ipc(lib.SOIC(profile, A, B, L, T, W, num_pins, pitch))\n    return f", "refactored": true, "pred": {"ppl": 9.886334419250488, "ppl_lower": 11.969971656799316, "ppl/lowercase_ppl": -1.083472239941274, "ppl/zlib": 0.011342343771642834, "Min_5.0% Prob": 11.44960994720459, "Min_10.0% Prob": 10.089137770912863, "Min_20.0% Prob": 8.169539191506125, "Min_30.0% Prob": 6.620492808959064, "Min_40.0% Prob": 5.474263019031948, "Min_50.0% Prob": 4.5021746038344865, "Min_60.0% Prob": 3.8159264862975655}}
{"hexsha": "4f4f6f8ac9dec0a03002fe61bd6214effc3be501", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef change_request_wrapper(func):\n\n    @functools.wraps(func)\n    def _inner(prep_req, *args, **kwargs):\n        prep_req.url = prep_req.url + '?some=stuff'\n        return func(prep_req, *args, **kwargs)\n    return _inner", "fn_id": 0, "class_fn": false, "repo": "HappyEinara/pytest-vts", "file": "tests/test_request_wrapper.py", "last_update_at": "2021-12-13T23:15:20+00:00", "original_content": "def change_request_wrapper(func):\n\n    @functools.wraps(func)\n    def _inner(prep_req, *args, **kwargs):\n        prep_req.url = prep_req.url + '?some=stuff'\n        return func(prep_req, *args, **kwargs)\n    return _inner", "refactored": true, "pred": {"ppl": 5.1560821533203125, "ppl_lower": 5.1560821533203125, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.010790638279524279, "Min_5.0% Prob": 9.821356058120728, "Min_10.0% Prob": 8.681561291217804, "Min_20.0% Prob": 6.745396643877029, "Min_30.0% Prob": 5.305978178977966, "Min_40.0% Prob": 4.121674546971917, "Min_50.0% Prob": 3.3164671658538283, "Min_60.0% Prob": 2.767465014641251}}
{"hexsha": "5ad02454c22c71588ac4c352b70a914a8fe47bc8", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_set_args_settings(mocker):\n    mocker.patch('json.load', new=lambda x: x())\n    args = Namespace()\n    set_args(args)\n    assert args.settings == {}\n    args = Namespace(settings=None)\n    set_args(args)\n    assert args.settings == {}\n    s = list(range(3))\n    mock = MagicMock(return_value=s)\n    args = Namespace(settings=mock)\n    set_args(args)\n    assert args.settings == s\n    mock.close.assert_called_with()", "fn_id": 10, "class_fn": false, "repo": "akx/markovchain", "file": "tests/cli/test_util.py", "last_update_at": "2021-06-05T15:38:34+00:00", "original_content": "def test_set_args_settings(mocker):\n    mocker.patch('json.load', new=lambda x: x())\n    args = Namespace()\n    set_args(args)\n    assert args.settings == {}\n    args = Namespace(settings=None)\n    set_args(args)\n    assert args.settings == {}\n    s = list(range(3))\n    mock = MagicMock(return_value=s)\n    args = Namespace(settings=mock)\n    set_args(args)\n    assert args.settings == s\n    mock.close.assert_called_with()", "refactored": true, "pred": {"ppl": 4.027331829071045, "ppl_lower": 4.6962432861328125, "ppl/lowercase_ppl": -1.1102995899618056, "ppl/zlib": 0.006419834467903863, "Min_5.0% Prob": 10.600571791330973, "Min_10.0% Prob": 8.500111286456768, "Min_20.0% Prob": 5.898937260663068, "Min_30.0% Prob": 4.417687618732453, "Min_40.0% Prob": 3.419488114891229, "Min_50.0% Prob": 2.793098890625719, "Min_60.0% Prob": 2.3191578256449215}}
{"hexsha": "714d3dfaa367d1733c257ba0266824ee7c931162", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef getAllClass(p, period):\n    data = {}\n    data['{}'.format(period)] = getRawAssignments(p, period)\n    data['assignments'] = data.pop('{}'.format(period))\n    data['info'] = getRawClass(p)['{}'.format(period)]\n    return data", "fn_id": 5, "class_fn": false, "repo": "Grant2464/powerschool_api", "file": "powerschool.py", "last_update_at": "2021-11-02T17:43:43+00:00", "original_content": "def getAllClass(p, period):\n    data = {}\n    data['{}'.format(period)] = getRawAssignments(p, period)\n    data['assignments'] = data.pop('{}'.format(period))\n    data['info'] = getRawClass(p)['{}'.format(period)]\n    return data", "refactored": true, "pred": {"ppl": 8.498987197875977, "ppl_lower": 8.470756530761719, "ppl/lowercase_ppl": -0.9984452046412458, "ppl/zlib": 0.014078598705301999, "Min_5.0% Prob": 11.220340410868326, "Min_10.0% Prob": 9.308599744524274, "Min_20.0% Prob": 7.689897366932461, "Min_30.0% Prob": 6.321052139455622, "Min_40.0% Prob": 5.262272686793886, "Min_50.0% Prob": 4.2385959907158, "Min_60.0% Prob": 3.585111765190959}}
{"hexsha": "4bf042cd1a9ebeebeb1cce1bd259939ff32e8532", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef ret_a_dict(existing):\n    \"\"\"\n    Append a key-value to 'existing' (if it exists)\n    \"\"\"\n    existing = existing or {}\n    ret = {'secret': 42}\n    ret.update(existing)\n    return ret", "fn_id": 1, "class_fn": false, "repo": "siriobalmelli/replacement", "file": "tests/demo.py", "last_update_at": "2021-02-07T16:24:31+00:00", "original_content": "def ret_a_dict(existing):\n    \"\"\"\n    Append a key-value to 'existing' (if it exists)\n    \"\"\"\n    existing = existing or {}\n    ret = {'secret': 42}\n    ret.update(existing)\n    return ret", "refactored": true, "pred": {"ppl": 11.284342765808105, "ppl_lower": 12.195097923278809, "ppl/lowercase_ppl": -1.0320282968616776, "ppl/zlib": 0.016374433573962163, "Min_5.0% Prob": 11.18101723988851, "Min_10.0% Prob": 9.943770249684652, "Min_20.0% Prob": 7.927366693814595, "Min_30.0% Prob": 6.64235069877223, "Min_40.0% Prob": 5.753795299530029, "Min_50.0% Prob": 4.759213199838996, "Min_60.0% Prob": 4.063333305481233}}
{"hexsha": "0e12d22364ddbf0f90693961db9219ea9d1c3443", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_uwsgi_emperor_opts(settings, port):\n    if settings['DATABASES']['default'].get('PASSWORD'):\n        os.environ['DB_PASSWORD'] = settings['DATABASES']['default']['PASSWORD']\n        pg_str = 'pg://host={HOST} port={PORT} user={USER} password=$(DB_PASSWORD) dbname={NAME};{query}'\n    else:\n        pg_str = 'pg://host={HOST} port={PORT} user={USER} dbname={NAME};{query}'\n    return get_uwsgi_regular_opts(settings, port) + ['http = 0.0.0.0:{}'.format(port or settings.get('PORT')), 'http-to = /tmp/fastrouter.sock', 'fastrouter = /tmp/fastrouter.sock', 'fastrouter-use-code-string = 0:{}:get'.format(os.path.join(HERE, 'fastrouter_lookup.py')), 'emperor = {}'.format(pg_str.format(query=VASSALS_SQL_QUERY, **settings['DATABASES']['default']))]", "fn_id": 3, "class_fn": false, "repo": "yakky/django-multisite-plus", "file": "django_multisite_plus/cli.py", "last_update_at": "2021-08-17T20:18:51+00:00", "original_content": "def get_uwsgi_emperor_opts(settings, port):\n    if settings['DATABASES']['default'].get('PASSWORD'):\n        os.environ['DB_PASSWORD'] = settings['DATABASES']['default']['PASSWORD']\n        pg_str = 'pg://host={HOST} port={PORT} user={USER} password=$(DB_PASSWORD) dbname={NAME};{query}'\n    else:\n        pg_str = 'pg://host={HOST} port={PORT} user={USER} dbname={NAME};{query}'\n    return get_uwsgi_regular_opts(settings, port) + ['http = 0.0.0.0:{}'.format(port or settings.get('PORT')), 'http-to = /tmp/fastrouter.sock', 'fastrouter = /tmp/fastrouter.sock', 'fastrouter-use-code-string = 0:{}:get'.format(os.path.join(HERE, 'fastrouter_lookup.py')), 'emperor = {}'.format(pg_str.format(query=VASSALS_SQL_QUERY, **settings['DATABASES']['default']))]", "refactored": true, "pred": {"ppl": 4.679940700531006, "ppl_lower": 4.898158073425293, "ppl/lowercase_ppl": -1.029530371303764, "ppl/zlib": 0.003936952650567785, "Min_5.0% Prob": 10.94517437616984, "Min_10.0% Prob": 9.009436302185058, "Min_20.0% Prob": 6.652390322685242, "Min_30.0% Prob": 4.930554937375219, "Min_40.0% Prob": 3.842631951417073, "Min_50.0% Prob": 3.079551274294224, "Min_60.0% Prob": 2.5776560452558392}}
{"hexsha": "d83d43b9c49703cda927b344f9e7b3b7da45f5b3", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef read_kitti_annotations(label_paths, calib_paths):\n    all_labels = []\n    all_calib = []\n    for label_file, calib_file in zip(label_paths, calib_paths):\n        calib = o3d.ml.datasets.KITTI.read_calib(calib_file)\n        labels = o3d.ml.datasets.KITTI.read_label(label_file, calib)\n        all_labels.append(labels)\n        all_calib.append(calib)\n    return (all_labels, all_calib)", "fn_id": 1, "class_fn": false, "repo": "supervisely-ecosystem/Open3D-ML", "file": "supervisely/src_backup/convert_kitty3d_to_sly.py", "last_update_at": "2021-08-31T09:06:08+00:00", "original_content": "def read_kitti_annotations(label_paths, calib_paths):\n    all_labels = []\n    all_calib = []\n    for label_file, calib_file in zip(label_paths, calib_paths):\n        calib = o3d.ml.datasets.KITTI.read_calib(calib_file)\n        labels = o3d.ml.datasets.KITTI.read_label(label_file, calib)\n        all_labels.append(labels)\n        all_calib.append(calib)\n    return (all_labels, all_calib)", "refactored": true, "pred": {"ppl": 2.4495034217834473, "ppl_lower": 2.5372135639190674, "ppl/lowercase_ppl": -1.0392696888854975, "ppl/zlib": 0.004641892844699015, "Min_5.0% Prob": 9.093303600947062, "Min_10.0% Prob": 7.118646695063664, "Min_20.0% Prob": 4.464565167824428, "Min_30.0% Prob": 2.999925217068777, "Min_40.0% Prob": 2.2445035000416365, "Min_50.0% Prob": 1.7911769991025221, "Min_60.0% Prob": 1.5075887611345955}}
{"hexsha": "07fe364d937fe8b983df03d9c0471b986fbd990b", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _add_workload_inner():\n    OpArgMngr.add_workload('inner', np.zeros(shape=(1, 80), dtype=np.float64), np.zeros(shape=(1, 80), dtype=np.float64))\n    for dt in [np.float32, np.float64]:\n        A = np.array([[1, 2], [3, 4]], dtype=dt)\n        B = np.array([[1, 3], [2, 4]], dtype=dt)\n        C = np.array([1, 1], dtype=dt)\n        OpArgMngr.add_workload('inner', A.T, C)\n        OpArgMngr.add_workload('inner', C, A.T)\n        OpArgMngr.add_workload('inner', B, C)\n        OpArgMngr.add_workload('inner', C, B)\n        OpArgMngr.add_workload('inner', A, B)\n        OpArgMngr.add_workload('inner', A, A)\n        OpArgMngr.add_workload('inner', A, A.copy())\n        a = np.arange(5).astype(dt)\n        b = a[::-1]\n        OpArgMngr.add_workload('inner', b, a)\n        a = np.arange(24).reshape(2, 3, 4).astype(dt)\n        b = np.arange(24, 48).reshape(2, 3, 4).astype(dt)\n        OpArgMngr.add_workload('inner', a, b)\n        OpArgMngr.add_workload('inner', b, a)", "fn_id": 74, "class_fn": false, "repo": "sxjscience/mxnet", "file": "tests/python/unittest/test_numpy_interoperability.py", "last_update_at": "2021-03-23T03:07:38+00:00", "original_content": "def _add_workload_inner():\n    OpArgMngr.add_workload('inner', np.zeros(shape=(1, 80), dtype=np.float64), np.zeros(shape=(1, 80), dtype=np.float64))\n    for dt in [np.float32, np.float64]:\n        A = np.array([[1, 2], [3, 4]], dtype=dt)\n        B = np.array([[1, 3], [2, 4]], dtype=dt)\n        C = np.array([1, 1], dtype=dt)\n        OpArgMngr.add_workload('inner', A.T, C)\n        OpArgMngr.add_workload('inner', C, A.T)\n        OpArgMngr.add_workload('inner', B, C)\n        OpArgMngr.add_workload('inner', C, B)\n        OpArgMngr.add_workload('inner', A, B)\n        OpArgMngr.add_workload('inner', A, A)\n        OpArgMngr.add_workload('inner', A, A.copy())\n        a = np.arange(5).astype(dt)\n        b = a[::-1]\n        OpArgMngr.add_workload('inner', b, a)\n        a = np.arange(24).reshape(2, 3, 4).astype(dt)\n        b = np.arange(24, 48).reshape(2, 3, 4).astype(dt)\n        OpArgMngr.add_workload('inner', a, b)\n        OpArgMngr.add_workload('inner', b, a)", "refactored": true, "pred": {"ppl": 2.0204882621765137, "ppl_lower": 2.15466046333313, "ppl/lowercase_ppl": -1.0914124475388105, "ppl/zlib": 0.0024421499866450437, "Min_5.0% Prob": 6.98037136228461, "Min_10.0% Prob": 5.172491575542249, "Min_20.0% Prob": 3.3471781913336223, "Min_30.0% Prob": 2.3280085377071216, "Min_40.0% Prob": 1.7579254329736744, "Min_50.0% Prob": 1.4058982462844198, "Min_60.0% Prob": 1.1751945258039593}}
{"hexsha": "0460f6e42c23c688c2c6afb0f673aa2cf4d651bf", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef load_state(network, state_dict):\n    net_state_keys = list(network.state_dict().keys())\n    net_state_keys_copy = net_state_keys.copy()\n    sup_string = ''\n    for key in state_dict.keys():\n        if 'backbone' in key:\n            sup_string = 'backbone.'\n        elif 'module' in key:\n            sup_string = 'module.'\n    for i, _ in enumerate(net_state_keys_copy):\n        name = net_state_keys_copy[i]\n        if name.startswith('classifier') or name.startswith('fc'):\n            continue\n        if not sup_string:\n            name_pretrained = name\n        else:\n            name_pretrained = sup_string + name\n        if name_pretrained in state_dict.keys():\n            dst_param_shape = network.state_dict()[name].shape\n            if state_dict[name_pretrained].shape == dst_param_shape:\n                network.state_dict()[name].copy_(state_dict[name_pretrained].view(dst_param_shape))\n                net_state_keys.remove(name)\n    if net_state_keys:\n        num_batches_list = []\n        for i in range(len(net_state_keys)):\n            if 'num_batches_tracked' in net_state_keys[i]:\n                num_batches_list.append(net_state_keys[i])\n        pruned_additional_states = [x for x in net_state_keys if x not in num_batches_list]\n        if pruned_additional_states:\n            logging.info('There are layers in current network not initialized by pretrained')\n            logging.warning('>> Failed to load: {}'.format(pruned_additional_states))\n        return False\n    return True", "fn_id": 0, "class_fn": false, "repo": "xuyu0010/PATAN", "file": "network/util.py", "last_update_at": "2021-12-27T19:45:45+00:00", "original_content": "def load_state(network, state_dict):\n    net_state_keys = list(network.state_dict().keys())\n    net_state_keys_copy = net_state_keys.copy()\n    sup_string = ''\n    for key in state_dict.keys():\n        if 'backbone' in key:\n            sup_string = 'backbone.'\n        elif 'module' in key:\n            sup_string = 'module.'\n    for i, _ in enumerate(net_state_keys_copy):\n        name = net_state_keys_copy[i]\n        if name.startswith('classifier') or name.startswith('fc'):\n            continue\n        if not sup_string:\n            name_pretrained = name\n        else:\n            name_pretrained = sup_string + name\n        if name_pretrained in state_dict.keys():\n            dst_param_shape = network.state_dict()[name].shape\n            if state_dict[name_pretrained].shape == dst_param_shape:\n                network.state_dict()[name].copy_(state_dict[name_pretrained].view(dst_param_shape))\n                net_state_keys.remove(name)\n    if net_state_keys:\n        num_batches_list = []\n        for i in range(len(net_state_keys)):\n            if 'num_batches_tracked' in net_state_keys[i]:\n                num_batches_list.append(net_state_keys[i])\n        pruned_additional_states = [x for x in net_state_keys if x not in num_batches_list]\n        if pruned_additional_states:\n            logging.info('There are layers in current network not initialized by pretrained')\n            logging.warning('>> Failed to load: {}'.format(pruned_additional_states))\n        return False\n    return True", "refactored": true, "pred": {"ppl": 2.2797679901123047, "ppl_lower": 2.395559072494507, "ppl/lowercase_ppl": -1.0601195730504371, "ppl/zlib": 0.0015204311421880183, "Min_5.0% Prob": 8.567017364501954, "Min_10.0% Prob": 6.1920012652873995, "Min_20.0% Prob": 3.912917751073837, "Min_30.0% Prob": 2.73715705635647, "Min_40.0% Prob": 2.05832729312759, "Min_50.0% Prob": 1.6515748135615789, "Min_60.0% Prob": 1.3779543112645591}}
{"hexsha": "f6b4cf055a04d3fdf48e80ef79e23515af8b5c83", "ext": "py", "lang": "Python", "content": "@pytest.fixture(scope='function')\ndef boto_status():\n    status_mock = Mock()\n    status_mock.get_status.side_effect = ['PENDING', 'INSYNC']\n\n    @timeing\n    @measure_memory_usage\n    def update():\n        status_mock.status = status_mock.get_status()\n    status_mock.update.side_effect = update\n    status_mock.status = 'PENDING'\n    return status_mock", "fn_id": 0, "class_fn": false, "repo": "dron22/r53dyndns", "file": "r53dyndns/tests/test_r53updater.py", "last_update_at": "2021-05-13T21:14:44+00:00", "original_content": "@pytest.fixture(scope='function')\ndef boto_status():\n    status_mock = Mock()\n    status_mock.get_status.side_effect = ['PENDING', 'INSYNC']\n\n    def update():\n        status_mock.status = status_mock.get_status()\n    status_mock.update.side_effect = update\n    status_mock.status = 'PENDING'\n    return status_mock", "refactored": true, "pred": {"ppl": 6.134983539581299, "ppl_lower": 6.959650993347168, "ppl/lowercase_ppl": -1.0695266919360724, "ppl/zlib": 0.009547407342760222, "Min_5.0% Prob": 11.426620244979858, "Min_10.0% Prob": 9.861797703637016, "Min_20.0% Prob": 7.108505663118865, "Min_30.0% Prob": 5.537273152121182, "Min_40.0% Prob": 4.426325313555888, "Min_50.0% Prob": 3.6037339513399163, "Min_60.0% Prob": 3.062869392239071}}
{"hexsha": "cc8172756946d110aef633b85d99fdb465e813dc", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef used_tracks_set(image, all=False):\n    \"\"\"Determine the set of tracks used by directory and files on the disk\"\"\"\n    bam = Disk.from_image(image).bam()\n    used_tracks = set()\n    for head in range(2):\n        for cyl in range(80):\n            track = head << 7 | cyl\n            offset = (80 * head + cyl - 4) * image.spt\n            if all or track <= 4 or bam[offset:offset + image.spt].any():\n                used_tracks.add(track)\n    return used_tracks", "fn_id": 1, "class_fn": false, "repo": "simonowen/writeusb", "file": "mgtwriteusb/writeusb.py", "last_update_at": "2021-08-03T21:10:03+00:00", "original_content": "def used_tracks_set(image, all=False):\n    \"\"\"Determine the set of tracks used by directory and files on the disk\"\"\"\n    bam = Disk.from_image(image).bam()\n    used_tracks = set()\n    for head in range(2):\n        for cyl in range(80):\n            track = head << 7 | cyl\n            offset = (80 * head + cyl - 4) * image.spt\n            if all or track <= 4 or bam[offset:offset + image.spt].any():\n                used_tracks.add(track)\n    return used_tracks", "refactored": true, "pred": {"ppl": 7.870233058929443, "ppl_lower": 8.879740715026855, "ppl/lowercase_ppl": -1.0584971175342526, "ppl/zlib": 0.007641065465102989, "Min_5.0% Prob": 10.978419167654854, "Min_10.0% Prob": 9.218873228345599, "Min_20.0% Prob": 7.411826298154634, "Min_30.0% Prob": 6.038616019625996, "Min_40.0% Prob": 4.900956410786201, "Min_50.0% Prob": 4.039872863929566, "Min_60.0% Prob": 3.442497845525029}}
{"hexsha": "0261d48fadbcba94432255ef1726dce932739202", "ext": "py", "lang": "Python", "content": "@deprecated(version='0.2.0', reason='Use AnyLE instead')\n@timeing\n@measure_memory_usage\ndef any_le(bound: Any) -> Any:\n    \"\"\"\n    Returns a matcher that matches any value less than or equal to ``bound``\n    \"\"\"\n    return AnyLE(bound)", "fn_id": 13, "class_fn": false, "repo": "jwodder/anys", "file": "src/anys/__init__.py", "last_update_at": "2021-12-14T23:07:16+00:00", "original_content": "@deprecated(version='0.2.0', reason='Use AnyLE instead')\ndef any_le(bound: Any) -> Any:\n    \"\"\"\n    Returns a matcher that matches any value less than or equal to ``bound``\n    \"\"\"\n    return AnyLE(bound)", "refactored": true, "pred": {"ppl": 8.048460960388184, "ppl_lower": 12.588702201843262, "ppl/lowercase_ppl": -1.2144919550795057, "ppl/zlib": 0.011917033646327629, "Min_5.0% Prob": 12.202194213867188, "Min_10.0% Prob": 10.707921663920084, "Min_20.0% Prob": 7.879726263192984, "Min_30.0% Prob": 5.946223139762878, "Min_40.0% Prob": 4.795239232204579, "Min_50.0% Prob": 3.9968989456401154, "Min_60.0% Prob": 3.472973544895649}}
{"hexsha": "8521926dba5b85612435ecc4000212db9efd4499", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_previous_benefit_put_unauthenticated(anonymous_client, previous_benefit):\n    data = PreviousBenefitSerializer(previous_benefit).data\n    data['monthly_amount'] = '1234.56'\n    response = anonymous_client.put(get_previous_benefits_detail_url(previous_benefit), data)\n    assert response.status_code == 403", "fn_id": 7, "class_fn": false, "repo": "City-of-Helsinki/kesaseteli", "file": "backend/benefit/calculator/tests/test_previous_benefits_api.py", "last_update_at": "2021-05-17T12:15:34+00:00", "original_content": "def test_previous_benefit_put_unauthenticated(anonymous_client, previous_benefit):\n    data = PreviousBenefitSerializer(previous_benefit).data\n    data['monthly_amount'] = '1234.56'\n    response = anonymous_client.put(get_previous_benefits_detail_url(previous_benefit), data)\n    assert response.status_code == 403", "refactored": true, "pred": {"ppl": 4.60889196395874, "ppl_lower": 5.938295841217041, "ppl/lowercase_ppl": -1.1658617809408873, "ppl/zlib": 0.007453597430385596, "Min_5.0% Prob": 11.009450435638428, "Min_10.0% Prob": 9.337353229522705, "Min_20.0% Prob": 6.689585761020058, "Min_30.0% Prob": 4.860693425967775, "Min_40.0% Prob": 3.837801401552401, "Min_50.0% Prob": 3.0728153901485107, "Min_60.0% Prob": 2.55213557447082}}
{"hexsha": "9c1f3df34d1f27d3dbdd982cd272b1268f3600c6", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef inference(net, data_label, use_aux):\n    if use_aux:\n        img, cls_label, seg_label = data_label\n        img, cls_label, seg_label = (img.cuda(), cls_label.long().cuda(), seg_label.long().cuda())\n        cls_out, seg_out = net(img)\n        return {'cls_out': cls_out, 'cls_label': cls_label, 'seg_out': seg_out, 'seg_label': seg_label}\n    else:\n        img, cls_label = data_label\n        img, cls_label = (img.cuda(), cls_label.long().cuda())\n        cls_out = net(img)\n        return {'cls_out': cls_out, 'cls_label': cls_label}", "fn_id": 0, "class_fn": false, "repo": "kjannakh/Ultra-Fast-Lane-Detection", "file": "train.py", "last_update_at": "2021-09-12T20:02:53+00:00", "original_content": "def inference(net, data_label, use_aux):\n    if use_aux:\n        img, cls_label, seg_label = data_label\n        img, cls_label, seg_label = (img.cuda(), cls_label.long().cuda(), seg_label.long().cuda())\n        cls_out, seg_out = net(img)\n        return {'cls_out': cls_out, 'cls_label': cls_label, 'seg_out': seg_out, 'seg_label': seg_label}\n    else:\n        img, cls_label = data_label\n        img, cls_label = (img.cuda(), cls_label.long().cuda())\n        cls_out = net(img)\n        return {'cls_out': cls_out, 'cls_label': cls_label}", "refactored": true, "pred": {"ppl": 2.0130510330200195, "ppl_lower": 2.0130510330200195, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.003606451020928402, "Min_5.0% Prob": 7.728749328189426, "Min_10.0% Prob": 5.9490452077653675, "Min_20.0% Prob": 3.4963637928704956, "Min_30.0% Prob": 2.3430027243947342, "Min_40.0% Prob": 1.7532497651595622, "Min_50.0% Prob": 1.3991962619134513, "Min_60.0% Prob": 1.1743886970473665}}
{"hexsha": "9cf488ea53f16e45eefa82773cf77f48e6b49c9a", "ext": "py", "lang": "Python", "content": "@pytest.fixture\n@timeing\n@measure_memory_usage\ndef mock_trained_emulator(mock_emulator):\n    filename = os.path.join(test_base, 'data', 'emu.hdf5')\n    if os.path.exists(filename):\n        yield Emulator.load(filename)\n    else:\n        mock_emulator.train()\n        mock_emulator.save(filename)\n        yield mock_emulator", "fn_id": 6, "class_fn": false, "repo": "spencerhurt/Starfish", "file": "tests/conftest.py", "last_update_at": "2021-05-13T16:23:26+00:00", "original_content": "@pytest.fixture\ndef mock_trained_emulator(mock_emulator):\n    filename = os.path.join(test_base, 'data', 'emu.hdf5')\n    if os.path.exists(filename):\n        yield Emulator.load(filename)\n    else:\n        mock_emulator.train()\n        mock_emulator.save(filename)\n        yield mock_emulator", "refactored": true, "pred": {"ppl": 5.120084762573242, "ppl_lower": 5.39072847366333, "ppl/lowercase_ppl": -1.0315395844545956, "ppl/zlib": 0.009123860302259593, "Min_5.0% Prob": 11.32621431350708, "Min_10.0% Prob": 9.5009323226081, "Min_20.0% Prob": 7.071089347203572, "Min_30.0% Prob": 5.3061019402963145, "Min_40.0% Prob": 4.088157140132454, "Min_50.0% Prob": 3.2939632224539914, "Min_60.0% Prob": 2.7499536174452968}}
{"hexsha": "511d2698d35dc4f9fe7517171c56725c07784116", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef make_char_dict():\n    chars = string.ascii_lowercase\n    char_dict = {'<blank>': 0}\n    for idx, c in enumerate(chars):\n        char_dict[c] = idx + 1\n    current_len = len(list(char_dict.keys()))\n    char_dict['<eos>'] = current_len\n    print(char_dict)\n    return char_dict", "fn_id": 0, "class_fn": false, "repo": "duguqiankun/lips_reading", "file": "cnn2d/cnn2d_image_generator.py", "last_update_at": "2021-11-14T13:10:30+00:00", "original_content": "def make_char_dict():\n    chars = string.ascii_lowercase\n    char_dict = {'<blank>': 0}\n    for idx, c in enumerate(chars):\n        char_dict[c] = idx + 1\n    current_len = len(list(char_dict.keys()))\n    char_dict['<eos>'] = current_len\n    print(char_dict)\n    return char_dict", "refactored": true, "pred": {"ppl": 3.3494560718536377, "ppl_lower": 3.3494560718536377, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.006263201896597076, "Min_5.0% Prob": 9.527847576141358, "Min_10.0% Prob": 7.443902397155762, "Min_20.0% Prob": 5.39667683839798, "Min_30.0% Prob": 3.9903306394815443, "Min_40.0% Prob": 3.0141603561118244, "Min_50.0% Prob": 2.4162955142743887, "Min_60.0% Prob": 2.0145276674903774}}
{"hexsha": "67a636a6cf8ea63426b938047e0e18deaa078baf", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_project_creation_without_pylint(cookies):\n    with generate_temporary_project(cookies, extra_context=NO_PLINT) as result:\n        assert_successful_creation(result)\n        assert_expected_files_exist(result, files=EXPECTED_PROJECT_FILES_NO_PYLINT)\n        assert_expected_files_do_not_exist(result, files=('pylintrc',))", "fn_id": 4, "class_fn": false, "repo": "mendix/python-project-template", "file": "tests/test_project_creation.py", "last_update_at": "2021-07-31T12:31:00+00:00", "original_content": "def test_project_creation_without_pylint(cookies):\n    with generate_temporary_project(cookies, extra_context=NO_PLINT) as result:\n        assert_successful_creation(result)\n        assert_expected_files_exist(result, files=EXPECTED_PROJECT_FILES_NO_PYLINT)\n        assert_expected_files_do_not_exist(result, files=('pylintrc',))", "refactored": true, "pred": {"ppl": 5.420899868011475, "ppl_lower": 5.626278400421143, "ppl/lowercase_ppl": -1.0220003574817802, "ppl/zlib": 0.007545811736513111, "Min_5.0% Prob": 9.246702194213867, "Min_10.0% Prob": 7.749966382980347, "Min_20.0% Prob": 6.135543096065521, "Min_30.0% Prob": 5.032261443138123, "Min_40.0% Prob": 4.131231048703194, "Min_50.0% Prob": 3.354489903824002, "Min_60.0% Prob": 2.82222463453158}}
{"hexsha": "4ab2bfd86a6ca0acdb74024739a1d2b31d9cbebd", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef zero_shot_transform(image, caption, p=0.5, transform_to_apply='solarized'):\n    \"\"\"\n    Output PIL.Image of a two-panel style transfer image with an english word describing the transform included in the caption.\n    See OpenAI DALL-E blog post for more details:\n    The top half of the image is the original image, and the bottom half is a stylized image.\n    \"\"\"\n    if p >= 0.5:\n        friendly_transform = transform_to_apply.replace('_', ' ')\n        style_caption = 'Two panel image of the exact same picture.' + f'On the top {caption} and on the bottom the same image but with {friendly_transform} applied.' + f'The original image is on the top and the {friendly_transform} image on the bottom. The caption is {caption}.'\n        style_image_transform = transform_lookup[transform_to_apply]\n        return (two_panel_style_transfer(image, img_transform=style_image_transform, resize_ratio=1.0), style_caption)\n    return (image, style_caption)", "fn_id": 3, "class_fn": false, "repo": "afiaka87/ZeroShotTransform", "file": "transforms.py", "last_update_at": "2021-07-20T00:07:04+00:00", "original_content": "def zero_shot_transform(image, caption, p=0.5, transform_to_apply='solarized'):\n    \"\"\"\n    Output PIL.Image of a two-panel style transfer image with an english word describing the transform included in the caption.\n    See OpenAI DALL-E blog post for more details:\n    The top half of the image is the original image, and the bottom half is a stylized image.\n    \"\"\"\n    if p >= 0.5:\n        friendly_transform = transform_to_apply.replace('_', ' ')\n        style_caption = 'Two panel image of the exact same picture.' + f'On the top {caption} and on the bottom the same image but with {friendly_transform} applied.' + f'The original image is on the top and the {friendly_transform} image on the bottom. The caption is {caption}.'\n        style_image_transform = transform_lookup[transform_to_apply]\n        return (two_panel_style_transfer(image, img_transform=style_image_transform, resize_ratio=1.0), style_caption)\n    return (image, style_caption)", "refactored": true, "pred": {"ppl": 10.296358108520508, "ppl_lower": 11.69336223602295, "ppl/lowercase_ppl": -1.0545636982088922, "ppl/zlib": 0.004940233582656366, "Min_5.0% Prob": 11.755584478378296, "Min_10.0% Prob": 10.134163913726807, "Min_20.0% Prob": 8.024228993584128, "Min_30.0% Prob": 6.5563983824345975, "Min_40.0% Prob": 5.50033477825277, "Min_50.0% Prob": 4.589544233866036, "Min_60.0% Prob": 3.873058008296149}}
{"hexsha": "b605c74be7fc59d0693eaf81e6720e58b5e14ac4", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef func_645e7dad5f4c4c1db11925e9517ff3b9(infile):\n    n, p, q, r, s = [int(x) for x in infile.readline().split()]\n    dev = [(i * p + q) % r + s for i in range(n)]\n    tot = sum(dev)\n    i = 0\n    return q", "fn_id": 88, "class_fn": false, "repo": "DynamicCodeSearch/CodeSeer", "file": "projects/src/main/python/CodeJam/Y14R5P1/Smithers/generated_py_263a1af396df4e8fa1f96950f5309feb.py", "last_update_at": "2021-04-13T20:34:19+00:00", "original_content": "def func_645e7dad5f4c4c1db11925e9517ff3b9(infile):\n    n, p, q, r, s = [int(x) for x in infile.readline().split()]\n    dev = [(i * p + q) % r + s for i in range(n)]\n    tot = sum(dev)\n    i = 0\n    return q", "refactored": true, "pred": {"ppl": 6.680035591125488, "ppl_lower": 6.680035591125488, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.010210340406167518, "Min_5.0% Prob": 9.052091693878173, "Min_10.0% Prob": 8.162792634963989, "Min_20.0% Prob": 6.349725064777193, "Min_30.0% Prob": 5.251896896669941, "Min_40.0% Prob": 4.5044430040177845, "Min_50.0% Prob": 3.798977702856064, "Min_60.0% Prob": 3.1592165934188023}}
{"hexsha": "fa024eaa7abd499c2cfb6beea3f81e7389c03dac", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_pblog(*args, **kwargs):\n    global pblog\n    if pblog is None:\n        pblog = ProgressBarLog(*args, **kwargs)\n    return pblog", "fn_id": 0, "class_fn": false, "repo": "youngyzzZ/Sonographic_Gallbladder_Diagnose", "file": "src/logger.py", "last_update_at": "2021-07-16T10:20:23+00:00", "original_content": "def get_pblog(*args, **kwargs):\n    global pblog\n    if pblog is None:\n        pblog = ProgressBarLog(*args, **kwargs)\n    return pblog", "refactored": true, "pred": {"ppl": 5.231020927429199, "ppl_lower": 9.245439529418945, "ppl/lowercase_ppl": -1.344205074197562, "ppl/zlib": 0.013674433595339047, "Min_5.0% Prob": 9.660905838012695, "Min_10.0% Prob": 9.184345006942749, "Min_20.0% Prob": 7.67889420191447, "Min_30.0% Prob": 5.575383801545415, "Min_40.0% Prob": 4.2090764484907455, "Min_50.0% Prob": 3.3657443520302572, "Min_60.0% Prob": 2.792627009916408}}
{"hexsha": "1183023f80519f66fa1c64d6437b4cc896c39a21", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef main():\n    args = arguments().parse_args()\n    sys.path.insert(0, os.getcwd())\n    conn = get_connection(args)\n    headers = None\n    editfile = tempfile.NamedTemporaryFile()\n    with open(editfile.name, 'w', newline='') as cfile:\n        headers = write_csv(cfile, conn, args.table)\n    reffile = tempfile.NamedTemporaryFile()\n    shutil.copy(editfile.name, reffile.name)\n    call_vim(editfile.name)\n    while True:\n        try:\n            process_changes(reffile, editfile, conn, args.table, headers)\n            break\n        except Exception as err:\n            print('Failed to save changes: ', err)\n            q = '(C)ancel, (r)etry save, (e)dit the file again?'\n            cmd = query_options(q, ('c', 'r', 'e'))\n            if cmd == 'c':\n                print('Changes cancelled')\n                break\n            elif cmd == 'r':\n                continue\n            elif cmd == 'e':\n                call_vim(editfile.name)\n            else:\n                raise ValueError('Not a command')", "fn_id": 14, "class_fn": false, "repo": "BnMcGn/vibase", "file": "src/vibase.py", "last_update_at": "2021-10-17T07:52:04+00:00", "original_content": "def main():\n    args = arguments().parse_args()\n    sys.path.insert(0, os.getcwd())\n    conn = get_connection(args)\n    headers = None\n    editfile = tempfile.NamedTemporaryFile()\n    with open(editfile.name, 'w', newline='') as cfile:\n        headers = write_csv(cfile, conn, args.table)\n    reffile = tempfile.NamedTemporaryFile()\n    shutil.copy(editfile.name, reffile.name)\n    call_vim(editfile.name)\n    while True:\n        try:\n            process_changes(reffile, editfile, conn, args.table, headers)\n            break\n        except Exception as err:\n            print('Failed to save changes: ', err)\n            q = '(C)ancel, (r)etry save, (e)dit the file again?'\n            cmd = query_options(q, ('c', 'r', 'e'))\n            if cmd == 'c':\n                print('Changes cancelled')\n                break\n            elif cmd == 'r':\n                continue\n            elif cmd == 'e':\n                call_vim(editfile.name)\n            else:\n                raise ValueError('Not a command')", "refactored": true, "pred": {"ppl": 3.7425825595855713, "ppl_lower": 4.71595573425293, "ppl/lowercase_ppl": -1.1751628437633754, "ppl/zlib": 0.0028942453883285804, "Min_5.0% Prob": 9.272928164555477, "Min_10.0% Prob": 7.846803059944739, "Min_20.0% Prob": 5.695347498048027, "Min_30.0% Prob": 4.2014663644135, "Min_40.0% Prob": 3.2780353892243133, "Min_50.0% Prob": 2.6394465404345575, "Min_60.0% Prob": 2.2008047161973083}}
{"hexsha": "93702be6e0d4de5b5113d03f1b9b9f088babbad8", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef macro_do_exist_op(macro: str, specs: typ.Dict[str, str]) -> str:\n    macro_no_encloser = macro[1:-1]\n    l, r = macro_no_encloser.split(MACRO_OP_EXIST)\n    if l in specs:\n        return specs[with_encloser(l)]\n    else:\n        return specs[with_encloser(r)]", "fn_id": 2, "class_fn": false, "repo": "Tootooroo/VerManager", "file": "manager/basic/macros.py", "last_update_at": "2021-03-18T12:03:54+00:00", "original_content": "def macro_do_exist_op(macro: str, specs: typ.Dict[str, str]) -> str:\n    macro_no_encloser = macro[1:-1]\n    l, r = macro_no_encloser.split(MACRO_OP_EXIST)\n    if l in specs:\n        return specs[with_encloser(l)]\n    else:\n        return specs[with_encloser(r)]", "refactored": true, "pred": {"ppl": 7.451507568359375, "ppl_lower": 8.491581916809082, "ppl/lowercase_ppl": -1.0650557035342683, "ppl/zlib": 0.010915306359178582, "Min_5.0% Prob": 14.173401641845704, "Min_10.0% Prob": 11.149424409866333, "Min_20.0% Prob": 8.11741676784697, "Min_30.0% Prob": 6.349805224326349, "Min_40.0% Prob": 4.914782553911209, "Min_50.0% Prob": 4.021527364276922, "Min_60.0% Prob": 3.3371488035671293}}
{"hexsha": "0778557121cb9d3021b5bcd3f81aaa9f8612eb04", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef write_glottal_tier(utterance, tao):\n    return_str = ''\n    glottal_dur = utterance.duration\n    for ii in range(len(utterance.duration)):\n        return_str += f'    <gesture value=\"{utterance.glottal[ii]}\" slope=\"0.000000\" duration_s=\"{utterance.duration[ii]:.6f}\" time_constant_s=\"{tao:.6f}\" neutral=\"0\" />\\n'\n    return return_str", "fn_id": 4, "class_fn": false, "repo": "quantling/create_vtl_corpus", "file": "generate_gestural_score.py", "last_update_at": "2021-11-01T02:35:12+00:00", "original_content": "def write_glottal_tier(utterance, tao):\n    return_str = ''\n    glottal_dur = utterance.duration\n    for ii in range(len(utterance.duration)):\n        return_str += f'    <gesture value=\"{utterance.glottal[ii]}\" slope=\"0.000000\" duration_s=\"{utterance.duration[ii]:.6f}\" time_constant_s=\"{tao:.6f}\" neutral=\"0\" />\\n'\n    return return_str", "refactored": true, "pred": {"ppl": 6.9683098793029785, "ppl_lower": 6.9683098793029785, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.009071835095012814, "Min_5.0% Prob": 11.983423391977945, "Min_10.0% Prob": 10.090576529502869, "Min_20.0% Prob": 7.695297050476074, "Min_30.0% Prob": 5.932784718436164, "Min_40.0% Prob": 4.7003488290309905, "Min_50.0% Prob": 3.830587051217518, "Min_60.0% Prob": 3.2479272451003394}}
{"hexsha": "9ec5c4528bc5fd84b15a1a39d42df73c0372c253", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef make_parser():\n    parser = argparse.ArgumentParser('Extract frames from a video. If `-r` and `-n N` parameters are specified, then dump `N` randomly selected frames. If `-s START -i STRIDE` are specified then dump every `STRIDE`-th frame starting from `START` frame.')\n    parser.add_argument('-f', dest='fname', type=str, help='input filename')\n    parser.add_argument('-s', dest='start', default=0, type=int, help='starting frame')\n    parser.add_argument('-i', dest='stride', default=1, type=int, help='stride, interval between successive frames to save.')\n    parser.add_argument('-c', dest='cmap', default='', type=str, help='colormap to conevrt to, default same as original')\n    parser.add_argument('-x', dest='scale', default=1, type=float, help='factor by which to scale the images')\n    parser.add_argument('-r', dest='random', action='store_true', help='extract random frames')\n    parser.add_argument('-n', dest='num', default=-1, type=int, help='number of frames to extract.')\n    parser.add_argument('-o', dest='outdir', default='.', type=str, help='output directory')\n    return parser", "fn_id": 0, "class_fn": false, "repo": "subhacom/argos", "file": "argos/extract_frames.py", "last_update_at": "2021-05-18T01:07:16+00:00", "original_content": "def make_parser():\n    parser = argparse.ArgumentParser('Extract frames from a video. If `-r` and `-n N` parameters are specified, then dump `N` randomly selected frames. If `-s START -i STRIDE` are specified then dump every `STRIDE`-th frame starting from `START` frame.')\n    parser.add_argument('-f', dest='fname', type=str, help='input filename')\n    parser.add_argument('-s', dest='start', default=0, type=int, help='starting frame')\n    parser.add_argument('-i', dest='stride', default=1, type=int, help='stride, interval between successive frames to save.')\n    parser.add_argument('-c', dest='cmap', default='', type=str, help='colormap to conevrt to, default same as original')\n    parser.add_argument('-x', dest='scale', default=1, type=float, help='factor by which to scale the images')\n    parser.add_argument('-r', dest='random', action='store_true', help='extract random frames')\n    parser.add_argument('-n', dest='num', default=-1, type=int, help='number of frames to extract.')\n    parser.add_argument('-o', dest='outdir', default='.', type=str, help='output directory')\n    return parser", "refactored": true, "pred": {"ppl": 3.5354504585266113, "ppl_lower": 3.8177053928375244, "ppl/lowercase_ppl": -1.0608222708290007, "ppl/zlib": 0.0027041557160275946, "Min_5.0% Prob": 10.41996072133382, "Min_10.0% Prob": 8.144718472162882, "Min_20.0% Prob": 5.745211241642634, "Min_30.0% Prob": 4.135276203299616, "Min_40.0% Prob": 3.162752385228133, "Min_50.0% Prob": 2.524427420429052, "Min_60.0% Prob": 2.1091606164335754}}
{"hexsha": "328dbe2b5b1e986ae40f5e053574fec17b83fbb1", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef trio_perf_counter():\n    \"\"\"Trio task-local equivalent of time.perf_counter().\n\n    For the current Trio task, return the value (in fractional seconds) of a\n    performance counter, i.e. a clock with the highest available resolution to\n    measure a short duration.  It includes time elapsed during time.sleep,\n    but not trio.sleep.  The reference point of the returned value is\n    undefined, so that only the difference between the results of consecutive\n    calls is valid.\n\n    Performance note: calling this function installs instrumentation on the\n    Trio scheduler which may affect application performance.  The\n    instrumentation is automatically removed when the corresponding tasks\n    have exited.\n    \"\"\"\n    trio_lowlevel.add_instrument(_instrument)\n    task = trio_lowlevel.current_task()\n    return perf_counter() - _instrument.get_elapsed_descheduled_time(task)", "fn_id": 0, "class_fn": false, "repo": "belm0/perf-timer", "file": "src/perf_timer/_trio.py", "last_update_at": "2021-05-29T02:50:31+00:00", "original_content": "def trio_perf_counter():\n    \"\"\"Trio task-local equivalent of time.perf_counter().\n\n    For the current Trio task, return the value (in fractional seconds) of a\n    performance counter, i.e. a clock with the highest available resolution to\n    measure a short duration.  It includes time elapsed during time.sleep,\n    but not trio.sleep.  The reference point of the returned value is\n    undefined, so that only the difference between the results of consecutive\n    calls is valid.\n\n    Performance note: calling this function installs instrumentation on the\n    Trio scheduler which may affect application performance.  The\n    instrumentation is automatically removed when the corresponding tasks\n    have exited.\n    \"\"\"\n    trio_lowlevel.add_instrument(_instrument)\n    task = trio_lowlevel.current_task()\n    return perf_counter() - _instrument.get_elapsed_descheduled_time(task)", "refactored": true, "pred": {"ppl": 6.800451278686523, "ppl_lower": 7.590805530548096, "ppl/lowercase_ppl": -1.0573549160967006, "ppl/zlib": 0.0040104371851312935, "Min_5.0% Prob": 12.135315227508546, "Min_10.0% Prob": 10.017655181884766, "Min_20.0% Prob": 7.4846003578930365, "Min_30.0% Prob": 5.846860589519624, "Min_40.0% Prob": 4.694554575954575, "Min_50.0% Prob": 3.8139417201567154, "Min_60.0% Prob": 3.209955656270106}}
{"hexsha": "1c1c76f7c4bea462b7291fe3d05a036ce7b22f07", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef main():\n    if not os.path.exists('benchmark.py'):\n        logging.warning('Please change current path to %s', PYARMOR_PATH)\n        return\n    output = '.benchtest'\n    name = 'bfoo'\n    filename = os.path.join(output, name + '.py')\n    obname = 'obfoo'\n    obfilename = os.path.join(output, obname + '.py')\n    if len(sys.argv) > 1 and 'bootstrap'.startswith(sys.argv[1]):\n        if len(sys.argv) < 5:\n            sys.argv.extend(['1', '1', '1'])\n        obf_mod, obf_code, wrap_mode = sys.argv[2:5]\n        if not os.path.exists(output):\n            logging.info('Create output path: %s', output)\n            os.makedirs(output)\n        else:\n            logging.info('Output path: %s', output)\n        logging.info('Generate test script %s ...', filename)\n        make_test_script(filename)\n        logging.info('Obffuscate test script ...')\n        shutil.copy(filename, obfilename)\n        obffuscate_scripts(output, os.path.basename(obfilename), obf_mod, obf_code, wrap_mode)\n        if not os.path.exists(obfilename):\n            logging.info('Something is wrong to obsfucate the script')\n            return\n        logging.info('Generate obffuscated script %s', obfilename)\n        logging.info('Copy benchmark.py to %s', output)\n        shutil.copy('benchmark.py', output)\n        logging.info('')\n        logging.info('Now change to \"%s\"', output)\n        logging.info('Run \"%s benchmark.py\".', sys.executable)\n        return\n    filename = os.path.basename(filename)\n    if os.path.exists(filename):\n        logging.info('Test script: %s', filename)\n    else:\n        logging.warning('Test script: %s not found', filename)\n        logging.info('Run \"%s benchmark.py bootstrap\" first.', sys.executable)\n        return\n    obfilename = os.path.basename(obfilename)\n    if os.path.exists(obfilename):\n        logging.info('Obfuscated script: %s', obfilename)\n    else:\n        logging.warning('Obfuscated script: %s not found', obfilename)\n        logging.info('Run \"%s benchmark.py bootstrap\" first.', sys.executable)\n        return\n    logging.info('--------------------------------------')\n    logging.info('')\n    total_extra_init_time()\n    logging.info('')\n    foo = import_no_obfuscated_module(name)\n    obfoo = import_obfuscated_module(obname)\n    logging.info('')\n    foo = re_import_no_obfuscated_module(name)\n    obfoo = re_import_obfuscated_module(obname)\n    logging.info('')\n    run_empty_no_obfuscated_code_object(foo)\n    run_empty_obfuscated_code_object(obfoo)\n    logging.info('')\n    run_one_thousand_no_obfuscated_bytecode(foo)\n    run_one_thousand_obfuscated_bytecode(obfoo)\n    logging.info('')\n    run_ten_thousand_no_obfuscated_bytecode(foo)\n    run_ten_thousand_obfuscated_bytecode(obfoo)\n    logging.info('')\n    logging.info('--------------------------------------')", "fn_id": 6, "class_fn": false, "repo": "HildeTeamTNT/pyarmor", "file": "src/benchmark.py", "last_update_at": "2021-04-23T16:33:54+00:00", "original_content": "def main():\n    if not os.path.exists('benchmark.py'):\n        logging.warning('Please change current path to %s', PYARMOR_PATH)\n        return\n    output = '.benchtest'\n    name = 'bfoo'\n    filename = os.path.join(output, name + '.py')\n    obname = 'obfoo'\n    obfilename = os.path.join(output, obname + '.py')\n    if len(sys.argv) > 1 and 'bootstrap'.startswith(sys.argv[1]):\n        if len(sys.argv) < 5:\n            sys.argv.extend(['1', '1', '1'])\n        obf_mod, obf_code, wrap_mode = sys.argv[2:5]\n        if not os.path.exists(output):\n            logging.info('Create output path: %s', output)\n            os.makedirs(output)\n        else:\n            logging.info('Output path: %s', output)\n        logging.info('Generate test script %s ...', filename)\n        make_test_script(filename)\n        logging.info('Obffuscate test script ...')\n        shutil.copy(filename, obfilename)\n        obffuscate_scripts(output, os.path.basename(obfilename), obf_mod, obf_code, wrap_mode)\n        if not os.path.exists(obfilename):\n            logging.info('Something is wrong to obsfucate the script')\n            return\n        logging.info('Generate obffuscated script %s', obfilename)\n        logging.info('Copy benchmark.py to %s', output)\n        shutil.copy('benchmark.py', output)\n        logging.info('')\n        logging.info('Now change to \"%s\"', output)\n        logging.info('Run \"%s benchmark.py\".', sys.executable)\n        return\n    filename = os.path.basename(filename)\n    if os.path.exists(filename):\n        logging.info('Test script: %s', filename)\n    else:\n        logging.warning('Test script: %s not found', filename)\n        logging.info('Run \"%s benchmark.py bootstrap\" first.', sys.executable)\n        return\n    obfilename = os.path.basename(obfilename)\n    if os.path.exists(obfilename):\n        logging.info('Obfuscated script: %s', obfilename)\n    else:\n        logging.warning('Obfuscated script: %s not found', obfilename)\n        logging.info('Run \"%s benchmark.py bootstrap\" first.', sys.executable)\n        return\n    logging.info('--------------------------------------')\n    logging.info('')\n    total_extra_init_time()\n    logging.info('')\n    foo = import_no_obfuscated_module(name)\n    obfoo = import_obfuscated_module(obname)\n    logging.info('')\n    foo = re_import_no_obfuscated_module(name)\n    obfoo = re_import_obfuscated_module(obname)\n    logging.info('')\n    run_empty_no_obfuscated_code_object(foo)\n    run_empty_obfuscated_code_object(obfoo)\n    logging.info('')\n    run_one_thousand_no_obfuscated_bytecode(foo)\n    run_one_thousand_obfuscated_bytecode(obfoo)\n    logging.info('')\n    run_ten_thousand_no_obfuscated_bytecode(foo)\n    run_ten_thousand_obfuscated_bytecode(obfoo)\n    logging.info('')\n    logging.info('--------------------------------------')", "refactored": true, "pred": {"ppl": 2.652448892593384, "ppl_lower": 2.569549322128296, "ppl/lowercase_ppl": -0.9674491604083371, "ppl/zlib": 0.0012937444611188014, "Min_5.0% Prob": 9.124047719515287, "Min_10.0% Prob": 7.10737559122917, "Min_20.0% Prob": 4.555750008980939, "Min_30.0% Prob": 3.209091474191617, "Min_40.0% Prob": 2.435361169266795, "Min_50.0% Prob": 1.9522605110196216, "Min_60.0% Prob": 1.6270188419003115}}
{"hexsha": "07d1a12410a8c57d20254595d70eb26c45d6f0ba", "ext": "py", "lang": "Python", "content": "@app.route('/robots.txt')\n@app.route('/AI_list.xml')\n@timeing\n@measure_memory_usage\ndef static_from_root():\n    return send_from_directory(app.static_folder, request.path[1:])", "fn_id": 0, "class_fn": false, "repo": "mattarderne/CommitLearn", "file": "src/app.py", "last_update_at": "2021-12-13T20:29:20+00:00", "original_content": "@app.route('/robots.txt')\n@app.route('/AI_list.xml')\ndef static_from_root():\n    return send_from_directory(app.static_folder, request.path[1:])", "refactored": true, "pred": {"ppl": 5.3555803298950195, "ppl_lower": 5.185290813446045, "ppl/lowercase_ppl": -0.9807446577900066, "ppl/zlib": 0.011986707640168882, "Min_5.0% Prob": 14.395939350128174, "Min_10.0% Prob": 11.874946975708008, "Min_20.0% Prob": 8.045012192292647, "Min_30.0% Prob": 5.71351216470494, "Min_40.0% Prob": 4.282018139310505, "Min_50.0% Prob": 3.4078681070742936, "Min_60.0% Prob": 2.8275803953143104}}
{"hexsha": "241dc5d98f8878f2c0b9e622971ebdf6ac69b24e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef dye(image, lw=5, rw=5, sh=3, value=255):\n    h, w = image.shape\n    mask = np.ones([h, w], np.uint8)\n    mask *= value\n    mask[2 * int(h / sh):h, int(w / lw):int(w - w / rw)] = 0\n    dst = cv.add(mask, image)\n    return dst", "fn_id": 5, "class_fn": false, "repo": "shinki-alice/-", "file": "V3.py", "last_update_at": "2021-12-08T10:42:49+00:00", "original_content": "def dye(image, lw=5, rw=5, sh=3, value=255):\n    h, w = image.shape\n    mask = np.ones([h, w], np.uint8)\n    mask *= value\n    mask[2 * int(h / sh):h, int(w / lw):int(w - w / rw)] = 0\n    dst = cv.add(mask, image)\n    return dst", "refactored": true, "pred": {"ppl": 5.150841236114502, "ppl_lower": 5.150841236114502, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.009056132862731247, "Min_5.0% Prob": 10.228158569335937, "Min_10.0% Prob": 8.856127977371216, "Min_20.0% Prob": 6.233560198829288, "Min_30.0% Prob": 4.909134080333095, "Min_40.0% Prob": 3.937033160811379, "Min_50.0% Prob": 3.240173709280086, "Min_60.0% Prob": 2.7479852089687946}}
{"hexsha": "585c8c30c7d2aa1d2bbdf2724d7af40b9b92f226", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_straightline_path_to(target, robot_pos):\n    pts = []\n    cur_pos = robot_pos\n    while np.linalg.norm(target[:2] - cur_pos[:2]) > 0.5:\n        t = get_step_target_for_move(cur_pos, [target[0], CAMERA_HEIGHT, target[1]], step_size=0.5)\n        pts.append(t)\n        cur_pos = t\n    return np.asarray(pts)", "fn_id": 7, "class_fn": false, "repo": "Jigyasu/droidlet", "file": "droidlet/lowlevel/robot_mover_utils.py", "last_update_at": "2021-09-13T13:25:16+00:00", "original_content": "def get_straightline_path_to(target, robot_pos):\n    pts = []\n    cur_pos = robot_pos\n    while np.linalg.norm(target[:2] - cur_pos[:2]) > 0.5:\n        t = get_step_target_for_move(cur_pos, [target[0], CAMERA_HEIGHT, target[1]], step_size=0.5)\n        pts.append(t)\n        cur_pos = t\n    return np.asarray(pts)", "refactored": true, "pred": {"ppl": 5.040539264678955, "ppl_lower": 4.954057216644287, "ppl/lowercase_ppl": -0.9893007401179195, "ppl/zlib": 0.00709435558473518, "Min_5.0% Prob": 11.664964199066162, "Min_10.0% Prob": 9.199776649475098, "Min_20.0% Prob": 6.89983535806338, "Min_30.0% Prob": 5.1629463240907, "Min_40.0% Prob": 4.0333860060390165, "Min_50.0% Prob": 3.222172358463849, "Min_60.0% Prob": 2.707273807401794}}
{"hexsha": "60f2593114913a3c96f097967b6e4f643d2df767", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef root_sum_squares(arr1, arr2):\n    \"\"\"\n    Function to calculate magnitude of two arrays of vectors.\n    \"\"\"\n    rss_arr = np.sqrt(arr1 ** 2 + arr2 ** 2)\n    v_line = np.median(rss_arr)\n    return (rss_arr, v_line)", "fn_id": 5, "class_fn": false, "repo": "geohackweek/ghw2019_planetpieces", "file": "contributors/matt/data_tools.py", "last_update_at": "2021-08-15T12:01:11+00:00", "original_content": "def root_sum_squares(arr1, arr2):\n    \"\"\"\n    Function to calculate magnitude of two arrays of vectors.\n    \"\"\"\n    rss_arr = np.sqrt(arr1 ** 2 + arr2 ** 2)\n    v_line = np.median(rss_arr)\n    return (rss_arr, v_line)", "refactored": true, "pred": {"ppl": 6.690370082855225, "ppl_lower": 7.011368751525879, "ppl/lowercase_ppl": -1.0246564461448526, "ppl/zlib": 0.011180407008367931, "Min_5.0% Prob": 12.65748405456543, "Min_10.0% Prob": 10.206386744976044, "Min_20.0% Prob": 7.563650071620941, "Min_30.0% Prob": 5.890089845657348, "Min_40.0% Prob": 4.735694870804295, "Min_50.0% Prob": 3.7788458732622012, "Min_60.0% Prob": 3.188242622166872}}
{"hexsha": "70e4742585e29853d1350672ced44f958ac66764", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _extract_metrics(out_lines) -> Tuple[pd.DataFrame, Dict[str, Optional[Union[str, int, float]]]]:\n    loss_table = {'i': [], 'loss': [], 'since_last': []}\n    metrics = {}\n    try:\n        record = False\n        for line in out_lines:\n            line = line.strip()\n            if record:\n                if line == '':\n                    record = False\n                else:\n                    counter_line = line.split()\n                    try:\n                        count, average_loss, since_last = (counter_line[2], counter_line[0], counter_line[1])\n                        average_loss_f = float(average_loss)\n                        since_last_f = float(since_last)\n                        loss_table['i'].append(count)\n                        loss_table['loss'].append(average_loss_f)\n                        loss_table['since_last'].append(since_last_f)\n                    except (ValueError, TypeError):\n                        ...\n            elif line.startswith('loss'):\n                fields = line.split()\n                if fields[0] == 'loss' and fields[1] == 'last' and (fields[2] == 'counter'):\n                    record = True\n            elif '=' in line:\n                key_value = [p.strip() for p in line.split('=')]\n                if key_value[0] == 'average loss':\n                    metrics[key_value[0]] = _parse_loss(key_value[1])\n                else:\n                    metrics[key_value[0]] = _to(key_value[1], [int, float])\n    finally:\n        return (pd.DataFrame(loss_table).set_index('i'), metrics)", "fn_id": 3, "class_fn": false, "repo": "ataymano/data-science", "file": "from_mwt_ds/DataScience/vw_executor/artifacts.py", "last_update_at": "2021-12-15T21:45:13+00:00", "original_content": "def _extract_metrics(out_lines) -> Tuple[pd.DataFrame, Dict[str, Optional[Union[str, int, float]]]]:\n    loss_table = {'i': [], 'loss': [], 'since_last': []}\n    metrics = {}\n    try:\n        record = False\n        for line in out_lines:\n            line = line.strip()\n            if record:\n                if line == '':\n                    record = False\n                else:\n                    counter_line = line.split()\n                    try:\n                        count, average_loss, since_last = (counter_line[2], counter_line[0], counter_line[1])\n                        average_loss_f = float(average_loss)\n                        since_last_f = float(since_last)\n                        loss_table['i'].append(count)\n                        loss_table['loss'].append(average_loss_f)\n                        loss_table['since_last'].append(since_last_f)\n                    except (ValueError, TypeError):\n                        ...\n            elif line.startswith('loss'):\n                fields = line.split()\n                if fields[0] == 'loss' and fields[1] == 'last' and (fields[2] == 'counter'):\n                    record = True\n            elif '=' in line:\n                key_value = [p.strip() for p in line.split('=')]\n                if key_value[0] == 'average loss':\n                    metrics[key_value[0]] = _parse_loss(key_value[1])\n                else:\n                    metrics[key_value[0]] = _to(key_value[1], [int, float])\n    finally:\n        return (pd.DataFrame(loss_table).set_index('i'), metrics)", "refactored": true, "pred": {"ppl": 3.121917963027954, "ppl_lower": 3.587813377380371, "ppl/lowercase_ppl": -1.1221798806702283, "ppl/zlib": 0.0021561506528237936, "Min_5.0% Prob": 8.814968761644865, "Min_10.0% Prob": 7.328497359627171, "Min_20.0% Prob": 5.212466382666638, "Min_30.0% Prob": 3.708922369961153, "Min_40.0% Prob": 2.830447525864369, "Min_50.0% Prob": 2.274378537347442, "Min_60.0% Prob": 1.8971159993139863}}
{"hexsha": "ee05a0d4fc4e0216722d78972336a384e87d7578", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef show_video():\n    mp4list = glob.glob('video/*.mp4')\n    if len(mp4list) > 0:\n        mp4 = mp4list[0]\n        video = io.open(mp4, 'r+b').read()\n        encoded = base64.b64encode(video)\n        ipythondisplay.display(HTML(data='<video alt=\"test\" autoplay\\n                 controls style=\"height: 400px;\">\\n                <source src=\"data:video/mp4;base64,{0}\" type=\"video/mp4\" />\\n             </video>'.format(encoded.decode('ascii'))))\n    else:\n        print('Could not find video')", "fn_id": 6, "class_fn": false, "repo": "perceptualrobots/pct", "file": "pct/putils.py", "last_update_at": "2021-11-17T14:33:13+00:00", "original_content": "def show_video():\n    mp4list = glob.glob('video/*.mp4')\n    if len(mp4list) > 0:\n        mp4 = mp4list[0]\n        video = io.open(mp4, 'r+b').read()\n        encoded = base64.b64encode(video)\n        ipythondisplay.display(HTML(data='<video alt=\"test\" autoplay\\n                 controls style=\"height: 400px;\">\\n                <source src=\"data:video/mp4;base64,{0}\" type=\"video/mp4\" />\\n             </video>'.format(encoded.decode('ascii'))))\n    else:\n        print('Could not find video')", "refactored": true, "pred": {"ppl": 2.0659756660461426, "ppl_lower": 2.2771859169006348, "ppl/lowercase_ppl": -1.1341475931539717, "ppl/zlib": 0.0023182191448397147, "Min_5.0% Prob": 8.47509628534317, "Min_10.0% Prob": 6.178960934281349, "Min_20.0% Prob": 3.563836520368403, "Min_30.0% Prob": 2.4424364153979994, "Min_40.0% Prob": 1.8215857896615157, "Min_50.0% Prob": 1.4506887925553125, "Min_60.0% Prob": 1.2166061491700773}}
{"hexsha": "e2638a4bcd52d33f3d9e3b6ccc08e027bf129a22", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef build_random_ts(num_samples, length_of_ts):\n    data = {}\n    labels = []\n    for s in range(0, num_samples):\n        labels.append(np.random.choice([1, 2]))\n    data['y'] = labels\n    for col in range(0, length_of_ts):\n        key = 'feature_' + str(col + 1)\n        values = []\n        for s in range(0, num_samples):\n            values.append(np.random.normal())\n        data[key] = values\n    df = pd.DataFrame.from_dict(data)\n    X = df.iloc[:, 1:]\n    y = df.iloc[:, :1]\n    return (X, y)", "fn_id": 19, "class_fn": false, "repo": "AkashPushkar/dsitributed-time-series", "file": "src/full.py", "last_update_at": "2021-06-18T20:51:28+00:00", "original_content": "def build_random_ts(num_samples, length_of_ts):\n    data = {}\n    labels = []\n    for s in range(0, num_samples):\n        labels.append(np.random.choice([1, 2]))\n    data['y'] = labels\n    for col in range(0, length_of_ts):\n        key = 'feature_' + str(col + 1)\n        values = []\n        for s in range(0, num_samples):\n            values.append(np.random.normal())\n        data[key] = values\n    df = pd.DataFrame.from_dict(data)\n    X = df.iloc[:, 1:]\n    y = df.iloc[:, :1]\n    return (X, y)", "refactored": true, "pred": {"ppl": 3.1047451496124268, "ppl_lower": 3.511579751968384, "ppl/lowercase_ppl": -1.1086864993915286, "ppl/zlib": 0.004119751398535993, "Min_5.0% Prob": 8.049181282520294, "Min_10.0% Prob": 6.886061640346751, "Min_20.0% Prob": 5.057832451427684, "Min_30.0% Prob": 3.7518383504128923, "Min_40.0% Prob": 2.8555897761355427, "Min_50.0% Prob": 2.2644074858859353, "Min_60.0% Prob": 1.8916523799309235}}
{"hexsha": "a2ffeaa240b71382db18bba9227270f5573e50fb", "ext": "py", "lang": "Python", "content": "@Transform_Wrapper()\n@timeing\n@measure_memory_usage\ndef Annotate_Script_Names(empty_diffs=0):\n    \"\"\"\n    For every ai script, annotate the pilot entity with the name\n    of the script running.\n    \"\"\"\n    aiscript_files = Load_Files('aiscripts/*.xml')\n    for game_file in aiscript_files:\n        xml_root = game_file.Get_Root()\n        changed = False\n        for tag in ['dock_masstraffic_drone', 'execute_custom_trade', 'execute_trade', 'move_approach_path', 'move_docking', 'move_undocking', 'move_gate', 'move_navmesh', 'move_strafe', 'move_target_points', 'move_waypoints', 'move_to', 'detach_from_masstraffic', 'wait_for_prev_script', 'wait']:\n            nodes = xml_root.xpath('.//{}'.format(tag))\n            if not nodes:\n                continue\n            changed = True\n            if empty_diffs:\n                continue\n            for node in nodes:\n                script_name = etree.Element('set_value', name='this.$script_name', exact=\"'{}'\".format(game_file.name.replace('.xml', '')))\n                node.addprevious(script_name)\n                element_name = etree.Element('set_value', name='this.$element_name', exact=\"'{}'\".format(tag))\n                node.addprevious(element_name)\n                if node.sourceline:\n                    name_line = \"'${} {}'\".format(game_file.name.replace('.xml', ''), node.sourceline)\n                    script_line_node = etree.Element('set_value', name='this.$script_line_name', exact=name_line)\n                    node.addprevious(script_line_node)\n                    record_group = [etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts?\">\\n                              <set_value name=\"this.$script_line_counts\" exact=\"table[]\"/>\\n                            </do_if>'), etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts.{FIELD}?\">\\n                              <set_value name=\"this.$script_line_counts.{FIELD}\" exact=\"0.0\"/>\\n                            </do_if>'.replace('FIELD', name_line)), etree.fromstring('\\n                            <set_value name=\"this.$script_line_counts.{FIELD}\" operation=\"add\"/>'.replace('FIELD', name_line))]\n                    for record_node in record_group:\n                        node.addprevious(record_node)\n        if changed:\n            game_file.Update_Root(xml_root)\n    return", "fn_id": 1, "class_fn": false, "repo": "abouquet/x4-projects", "file": "extensions/sn_measure_perf/Customizer_Script.py", "last_update_at": "2021-03-17T13:54:15+00:00", "original_content": "@Transform_Wrapper()\ndef Annotate_Script_Names(empty_diffs=0):\n    \"\"\"\n    For every ai script, annotate the pilot entity with the name\n    of the script running.\n    \"\"\"\n    aiscript_files = Load_Files('aiscripts/*.xml')\n    for game_file in aiscript_files:\n        xml_root = game_file.Get_Root()\n        changed = False\n        for tag in ['dock_masstraffic_drone', 'execute_custom_trade', 'execute_trade', 'move_approach_path', 'move_docking', 'move_undocking', 'move_gate', 'move_navmesh', 'move_strafe', 'move_target_points', 'move_waypoints', 'move_to', 'detach_from_masstraffic', 'wait_for_prev_script', 'wait']:\n            nodes = xml_root.xpath('.//{}'.format(tag))\n            if not nodes:\n                continue\n            changed = True\n            if empty_diffs:\n                continue\n            for node in nodes:\n                script_name = etree.Element('set_value', name='this.$script_name', exact=\"'{}'\".format(game_file.name.replace('.xml', '')))\n                node.addprevious(script_name)\n                element_name = etree.Element('set_value', name='this.$element_name', exact=\"'{}'\".format(tag))\n                node.addprevious(element_name)\n                if node.sourceline:\n                    name_line = \"'${} {}'\".format(game_file.name.replace('.xml', ''), node.sourceline)\n                    script_line_node = etree.Element('set_value', name='this.$script_line_name', exact=name_line)\n                    node.addprevious(script_line_node)\n                    record_group = [etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts?\">\\n                              <set_value name=\"this.$script_line_counts\" exact=\"table[]\"/>\\n                            </do_if>'), etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts.{FIELD}?\">\\n                              <set_value name=\"this.$script_line_counts.{FIELD}\" exact=\"0.0\"/>\\n                            </do_if>'.replace('FIELD', name_line)), etree.fromstring('\\n                            <set_value name=\"this.$script_line_counts.{FIELD}\" operation=\"add\"/>'.replace('FIELD', name_line))]\n                    for record_node in record_group:\n                        node.addprevious(record_node)\n        if changed:\n            game_file.Update_Root(xml_root)\n    return", "refactored": true, "pred": {"ppl": 4.009283542633057, "ppl_lower": 4.3000102043151855, "ppl/lowercase_ppl": -1.050413513634871, "ppl/zlib": 0.001815179813964645, "Min_5.0% Prob": 11.021384639124717, "Min_10.0% Prob": 8.898077218763289, "Min_20.0% Prob": 6.116402295327956, "Min_30.0% Prob": 4.498695926961078, "Min_40.0% Prob": 3.452485047761471, "Min_50.0% Prob": 2.7774907817643495, "Min_60.0% Prob": 2.317440658798992}}
{"hexsha": "b2384578a7677f29cd7e0fe11a8a0c2097dd4658", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef export_result(request, uid):\n    if request.method == 'GET':\n        data = request.GET.get('data')\n        img = request.GET.get('image')\n        gif = request.GET.get('gif')\n        if data == '1':\n            data = True\n        else:\n            data = False\n        if img == '1':\n            img = True\n        else:\n            img = False\n        if gif == '1':\n            gif = True\n        else:\n            gif = False\n        work = Work(uid)\n        zip_path, file_name = work.export(data, img, gif)\n        response = StreamingHttpResponse(Tools.file_iterator(zip_path))\n        response['Content-Type'] = 'application/octet-stream'\n        response['Content-Disposition'] = 'attachment; filename={0}'.format(file_name)\n        response['Access-Control-Expose-Headers'] = 'Content-Disposition'\n        return response", "fn_id": 3, "class_fn": false, "repo": "Mr-Gump/Bamboo-Web", "file": "src/BambooReConstruct/BackEnd/views.py", "last_update_at": "2021-07-03T09:36:27+00:00", "original_content": "def export_result(request, uid):\n    if request.method == 'GET':\n        data = request.GET.get('data')\n        img = request.GET.get('image')\n        gif = request.GET.get('gif')\n        if data == '1':\n            data = True\n        else:\n            data = False\n        if img == '1':\n            img = True\n        else:\n            img = False\n        if gif == '1':\n            gif = True\n        else:\n            gif = False\n        work = Work(uid)\n        zip_path, file_name = work.export(data, img, gif)\n        response = StreamingHttpResponse(Tools.file_iterator(zip_path))\n        response['Content-Type'] = 'application/octet-stream'\n        response['Content-Disposition'] = 'attachment; filename={0}'.format(file_name)\n        response['Access-Control-Expose-Headers'] = 'Content-Disposition'\n        return response", "refactored": true, "pred": {"ppl": 2.456709384918213, "ppl_lower": 3.4578704833984375, "ppl/lowercase_ppl": -1.3803086926192765, "ppl/zlib": 0.002489813867276425, "Min_5.0% Prob": 9.13607316017151, "Min_10.0% Prob": 6.6419351895650225, "Min_20.0% Prob": 4.200495907238552, "Min_30.0% Prob": 2.9937627081360136, "Min_40.0% Prob": 2.2448471024194183, "Min_50.0% Prob": 1.804520680665759, "Min_60.0% Prob": 1.5072388632010345}}
{"hexsha": "521ca7e8f2b91498b1cecc645438b8f39926f276", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_haversine():\n    \"\"\"\n    TODO...\n    \"\"\"\n    pass", "fn_id": 1, "class_fn": false, "repo": "peterprescott/optimize-nn", "file": "tests/test_given.py", "last_update_at": "2021-10-12T04:46:20+00:00", "original_content": "def test_haversine():\n    \"\"\"\n    TODO...\n    \"\"\"\n    pass", "refactored": true, "pred": {"ppl": 14.836199760437012, "ppl_lower": 16.93831443786621, "ppl/lowercase_ppl": -1.0491303719098255, "ppl/zlib": 0.03329716202607227, "Min_5.0% Prob": 10.962910652160645, "Min_10.0% Prob": 10.36802053451538, "Min_20.0% Prob": 8.922346878051759, "Min_30.0% Prob": 7.7203681128365655, "Min_40.0% Prob": 6.411702871322632, "Min_50.0% Prob": 5.2523787296735325, "Min_60.0% Prob": 4.616950582464536}}
{"hexsha": "aa06ab4636c128273f66fb5d6c82aabd460f2220", "ext": "py", "lang": "Python", "content": "@mock.patch('six.moves.builtins.super')\n@timeing\n@measure_memory_usage\ndef test_algosec_servers_http_adapter(mock_super, mocker):\n    adapter = AlgoSecServersHTTPAdapter()\n    adapter.send()\n    assert super.return_value.send.call_args == mocker.call(timeout=(AlgoSecServersHTTPAdapter.ALGOSEC_SERVER_CONNECT_TIMEOUT, AlgoSecServersHTTPAdapter.ALGOSEC_SERVER_READ_TIMEOUT))\n    assert mock_super(AlgoSecServersHTTPAdapter, adapter).calls[0]", "fn_id": 0, "class_fn": false, "repo": "chanilurya/algosec-python", "file": "tests/test_helpers.py", "last_update_at": "2021-09-25T13:15:19+00:00", "original_content": "@mock.patch('six.moves.builtins.super')\ndef test_algosec_servers_http_adapter(mock_super, mocker):\n    adapter = AlgoSecServersHTTPAdapter()\n    adapter.send()\n    assert super.return_value.send.call_args == mocker.call(timeout=(AlgoSecServersHTTPAdapter.ALGOSEC_SERVER_CONNECT_TIMEOUT, AlgoSecServersHTTPAdapter.ALGOSEC_SERVER_READ_TIMEOUT))\n    assert mock_super(AlgoSecServersHTTPAdapter, adapter).calls[0]", "refactored": true, "pred": {"ppl": 6.2385735511779785, "ppl_lower": 8.043076515197754, "ppl/lowercase_ppl": -1.1387736644311799, "ppl/zlib": 0.007382062736618138, "Min_5.0% Prob": 12.133453845977783, "Min_10.0% Prob": 10.264106392860413, "Min_20.0% Prob": 7.739264516830445, "Min_30.0% Prob": 5.853806975640748, "Min_40.0% Prob": 4.529600938161214, "Min_50.0% Prob": 3.6510661349166185, "Min_60.0% Prob": 3.0818763688500774}}
{"hexsha": "1ac41f241705a181f54bcd99f611ca86824ed455", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef Hosts_Ping(context, nameSpace, className, methodName, instanceName, parameters):\n    be = BookEnd('Hosts_Ping')\n    outParams = context.NewParameters('Hosts', 'Ping')\n    outParams.SetValue('MIReturn', MI_Uint64(123))\n    context.PostInstance(outParams)\n    context.PostResult(MI_RESULT_OK)", "fn_id": 5, "class_fn": false, "repo": "Bhaskers-Blu-Org2/omi-script-provider", "file": "samples/hosts/_mi_main.py", "last_update_at": "2021-04-20T16:09:19+00:00", "original_content": "def Hosts_Ping(context, nameSpace, className, methodName, instanceName, parameters):\n    be = BookEnd('Hosts_Ping')\n    outParams = context.NewParameters('Hosts', 'Ping')\n    outParams.SetValue('MIReturn', MI_Uint64(123))\n    context.PostInstance(outParams)\n    context.PostResult(MI_RESULT_OK)", "refactored": true, "pred": {"ppl": 11.789478302001953, "ppl_lower": 21.630638122558594, "ppl/lowercase_ppl": -1.2459879380445509, "ppl/zlib": 0.011475383555238085, "Min_5.0% Prob": 14.133927345275879, "Min_10.0% Prob": 11.808530118730333, "Min_20.0% Prob": 9.063010109795464, "Min_30.0% Prob": 7.133687896387918, "Min_40.0% Prob": 5.873905781153086, "Min_50.0% Prob": 4.822781226736434, "Min_60.0% Prob": 4.115746085931148}}
{"hexsha": "73401fdbf7f3329cc097f204980f1eaf451bd20d", "ext": "py", "lang": "Python", "content": "def updateStateByKey(ssc):\n\n    @timeing\n    @measure_memory_usage\n    def processStateUpdateByKey(input_stream, state):\n        print('i', input_stream)\n        print('s', state)\n        return state if not input_stream else input_stream[-1]\n    ssc.checkpoint('checkpoints/')\n    ssc.queueStream([[('a', 1), ('b', 3)], [('a', 2), ('a', 5), ('c', 4)]]).updateStateByKey(processStateUpdateByKey).pprint()", "fn_id": 0, "class_fn": false, "repo": "svaningelgem/pyspark_fast_tester", "file": "src/main/scripts/pyspark_streaming.py", "last_update_at": "2021-08-02T13:59:46+00:00", "original_content": "def updateStateByKey(ssc):\n\n    def processStateUpdateByKey(input_stream, state):\n        print('i', input_stream)\n        print('s', state)\n        return state if not input_stream else input_stream[-1]\n    ssc.checkpoint('checkpoints/')\n    ssc.queueStream([[('a', 1), ('b', 3)], [('a', 2), ('a', 5), ('c', 4)]]).updateStateByKey(processStateUpdateByKey).pprint()", "refactored": true, "pred": {"ppl": 8.398118019104004, "ppl_lower": 9.687044143676758, "ppl/lowercase_ppl": -1.0670964237429, "ppl/zlib": 0.009628993825351125, "Min_5.0% Prob": 10.454860210418701, "Min_10.0% Prob": 9.205112059911093, "Min_20.0% Prob": 7.339394549528758, "Min_30.0% Prob": 6.104630682203505, "Min_40.0% Prob": 5.114810461799304, "Min_50.0% Prob": 4.2416182026267055, "Min_60.0% Prob": 3.563782006295191}}
{"hexsha": "00cef5ab0b6c71719e9da7da7a1b9a6407ebc5d7", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef main():\n    N = 7\n    M = 10\n    key = gfdb.Management.retrieval.Retrieve.create_key(N, M)\n    print('key: ' + key)\n    r_configuration = 'rectangle'\n    r = gfdb.Management.retrieval.Retrieve(r_configuration)\n    library_boundaries = r.query_database()\n    r_data = r.retrieve(N, M)\n    print(r_data)\n    r_level = r.levels[r_configuration]\n    L_configuration = 'L'\n    L = gfdb.Management.retrieval.Retrieve(L_configuration)\n    library_boundaries = L.query_database()\n    L_data = L.retrieve(N, M)\n    print(L_data)\n    LopU_configuration = 'LopU'\n    LopU = gfdb.Management.retrieval.Retrieve(LopU_configuration)\n    LopU_data = LopU.retrieve(N, M)\n    print(LopU_data)\n    U_configuration = 'U'\n    U = gfdb.Management.retrieval.Retrieve(U_configuration)\n    U_data = U.retrieve(N, M)\n    print(U_data)\n    c_configuration = 'C'\n    c = gfdb.Management.retrieval.Retrieve(c_configuration)\n    library_boundaries = c.query_database()\n    c_data = c.retrieve(N, M)\n    print(c_data)\n    Open_configuration = 'Open'\n    Open = gfdb.Management.retrieval.Retrieve(Open_configuration)\n    Open_data = Open.retrieve(N, M)\n    print(Open_data)\n    zoned_configuration = 'zoned'\n    zoned = gfdb.Management.retrieval.Retrieve(zoned_configuration)\n    zoned_data = zoned.retrieve(N, M)\n    print(zoned_data)", "fn_id": 0, "class_fn": false, "repo": "j-c-cook/gFunctionDatabase", "file": "gFunctionDatabase/Management/examples/retreive.py", "last_update_at": "2021-03-13T11:23:49+00:00", "original_content": "def main():\n    N = 7\n    M = 10\n    key = gfdb.Management.retrieval.Retrieve.create_key(N, M)\n    print('key: ' + key)\n    r_configuration = 'rectangle'\n    r = gfdb.Management.retrieval.Retrieve(r_configuration)\n    library_boundaries = r.query_database()\n    r_data = r.retrieve(N, M)\n    print(r_data)\n    r_level = r.levels[r_configuration]\n    L_configuration = 'L'\n    L = gfdb.Management.retrieval.Retrieve(L_configuration)\n    library_boundaries = L.query_database()\n    L_data = L.retrieve(N, M)\n    print(L_data)\n    LopU_configuration = 'LopU'\n    LopU = gfdb.Management.retrieval.Retrieve(LopU_configuration)\n    LopU_data = LopU.retrieve(N, M)\n    print(LopU_data)\n    U_configuration = 'U'\n    U = gfdb.Management.retrieval.Retrieve(U_configuration)\n    U_data = U.retrieve(N, M)\n    print(U_data)\n    c_configuration = 'C'\n    c = gfdb.Management.retrieval.Retrieve(c_configuration)\n    library_boundaries = c.query_database()\n    c_data = c.retrieve(N, M)\n    print(c_data)\n    Open_configuration = 'Open'\n    Open = gfdb.Management.retrieval.Retrieve(Open_configuration)\n    Open_data = Open.retrieve(N, M)\n    print(Open_data)\n    zoned_configuration = 'zoned'\n    zoned = gfdb.Management.retrieval.Retrieve(zoned_configuration)\n    zoned_data = zoned.retrieve(N, M)\n    print(zoned_data)", "refactored": true, "pred": {"ppl": 2.337162971496582, "ppl_lower": 2.436267375946045, "ppl/lowercase_ppl": -1.048919150685494, "ppl/zlib": 0.0024186261779724247, "Min_5.0% Prob": 10.020174276261102, "Min_10.0% Prob": 7.083883618199548, "Min_20.0% Prob": 4.172603386572038, "Min_30.0% Prob": 2.8355902797393218, "Min_40.0% Prob": 2.1285716794910177, "Min_50.0% Prob": 1.7015753797059836, "Min_60.0% Prob": 1.417006702978118}}
{"hexsha": "e357f5174eb4389ae8c75eadb4fb65ed5718efd2", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef initialize_routes(api, limiter):\n    RegisterApi.decorators = [limiter.limit('10/hour', methods=['POST'])]\n    LoginApi.decorators = [limiter.limit('30/minute', methods=['POST'])]\n    PasswordChangeApi.decorators = [limiter.limit('5/day', methods=['POST'])]\n    CaffSearchApi.decorators = [limiter.limit('1/second', methods=['GET'])]\n    CaffDownloadApi.decorators = [limiter.limit('10/minute', methods=['GET'])]\n    CaffUploadApi.decorators = [limiter.limit('10/minute', methods=['POST'])]\n    CommentApi.decorators = [limiter.limit('10/minute', methods=['POST'])]\n    UserDataApi.decorators = [limiter.limit('60/second', methods=['GET', 'DELETE'])]\n    CaffDataApi.decorators = [limiter.limit('60/second', methods=['GET', 'DELETE'])]\n    api.add_resource(RegisterApi, '/user/register')\n    api.add_resource(LoginApi, '/user/login')\n    api.add_resource(LogoutApi, '/user/logout')\n    api.add_resource(PasswordChangeApi, '/user/password')\n    api.add_resource(UsersListApi, '/user/')\n    api.add_resource(UserDataApi, '/user/<username>')\n    api.add_resource(CaffDataApi, '/caff/<caff_id>')\n    api.add_resource(CaffSearchApi, '/caff/search')\n    api.add_resource(CaffUploadApi, '/caff/upload')\n    api.add_resource(CaffDownloadApi, '/caff/download/<caff_id>')\n    api.add_resource(CommentApi, '/comment')", "fn_id": 0, "class_fn": false, "repo": "nemkrisz11/Computer-Security-Homework-2021-SHAjt", "file": "Backend/flaskapp/resources/routes.py", "last_update_at": "2021-12-03T09:58:04+00:00", "original_content": "def initialize_routes(api, limiter):\n    RegisterApi.decorators = [limiter.limit('10/hour', methods=['POST'])]\n    LoginApi.decorators = [limiter.limit('30/minute', methods=['POST'])]\n    PasswordChangeApi.decorators = [limiter.limit('5/day', methods=['POST'])]\n    CaffSearchApi.decorators = [limiter.limit('1/second', methods=['GET'])]\n    CaffDownloadApi.decorators = [limiter.limit('10/minute', methods=['GET'])]\n    CaffUploadApi.decorators = [limiter.limit('10/minute', methods=['POST'])]\n    CommentApi.decorators = [limiter.limit('10/minute', methods=['POST'])]\n    UserDataApi.decorators = [limiter.limit('60/second', methods=['GET', 'DELETE'])]\n    CaffDataApi.decorators = [limiter.limit('60/second', methods=['GET', 'DELETE'])]\n    api.add_resource(RegisterApi, '/user/register')\n    api.add_resource(LoginApi, '/user/login')\n    api.add_resource(LogoutApi, '/user/logout')\n    api.add_resource(PasswordChangeApi, '/user/password')\n    api.add_resource(UsersListApi, '/user/')\n    api.add_resource(UserDataApi, '/user/<username>')\n    api.add_resource(CaffDataApi, '/caff/<caff_id>')\n    api.add_resource(CaffSearchApi, '/caff/search')\n    api.add_resource(CaffUploadApi, '/caff/upload')\n    api.add_resource(CaffDownloadApi, '/caff/download/<caff_id>')\n    api.add_resource(CommentApi, '/comment')", "refactored": true, "pred": {"ppl": 1.9018077850341797, "ppl_lower": 2.0775399208068848, "ppl/lowercase_ppl": -1.1374904948344315, "ppl/zlib": 0.0017420186981657946, "Min_5.0% Prob": 7.2441449642181395, "Min_10.0% Prob": 5.316274464130402, "Min_20.0% Prob": 3.1394019811241716, "Min_30.0% Prob": 2.147834352841062, "Min_40.0% Prob": 1.6099928733921482, "Min_50.0% Prob": 1.2854731115460938, "Min_60.0% Prob": 1.073964382843627}}
{"hexsha": "fe661c2264845a793c67f4141a080dbf2325c8ac", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_significance_matrix(df):\n    \"\"\"\n    returns matrix in which item[y,x] is test of whether y-x is center around zero\n    \"\"\"\n    return df.apply(lambda x: df.apply(lambda y: wilcox_test(x, y)))", "fn_id": 4, "class_fn": false, "repo": "nweir127/COD3S", "file": "src/utils/metrics.py", "last_update_at": "2021-12-10T16:33:52+00:00", "original_content": "def get_significance_matrix(df):\n    \"\"\"\n    returns matrix in which item[y,x] is test of whether y-x is center around zero\n    \"\"\"\n    return df.apply(lambda x: df.apply(lambda y: wilcox_test(x, y)))", "refactored": true, "pred": {"ppl": 12.461410522460938, "ppl_lower": 12.461410522460938, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.015571831549395348, "Min_5.0% Prob": 12.313379605611166, "Min_10.0% Prob": 10.122497286115374, "Min_20.0% Prob": 8.70114006314959, "Min_30.0% Prob": 7.088545419953086, "Min_40.0% Prob": 5.91747941641972, "Min_50.0% Prob": 4.8663602294148625, "Min_60.0% Prob": 4.189391235058958}}
{"hexsha": "4aa6ab3efd6286da2d8af7db8b33a3b6c6534a0f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_object_beside_object():\n    ball = situation_object(BALL)\n    table = situation_object(TABLE)\n    situation = HighLevelSemanticsSituation(ontology=GAILA_PHASE_1_ONTOLOGY, salient_objects=[ball, table], always_relations=[Relation(IN_REGION, ball, Region(table, distance=PROXIMAL, direction=Direction(positive=True, relative_to_axis=HorizontalAxisOfObject(table, index=0))))])\n    assert generated_tokens(situation) == ('a', 'ball', 'beside', 'a', 'table')", "fn_id": 37, "class_fn": false, "repo": "Tubbz-alt/adam", "file": "tests/language_specific/english/test_english_language_generator.py", "last_update_at": "2021-04-26T23:59:57+00:00", "original_content": "def test_object_beside_object():\n    ball = situation_object(BALL)\n    table = situation_object(TABLE)\n    situation = HighLevelSemanticsSituation(ontology=GAILA_PHASE_1_ONTOLOGY, salient_objects=[ball, table], always_relations=[Relation(IN_REGION, ball, Region(table, distance=PROXIMAL, direction=Direction(positive=True, relative_to_axis=HorizontalAxisOfObject(table, index=0))))])\n    assert generated_tokens(situation) == ('a', 'ball', 'beside', 'a', 'table')", "refactored": true, "pred": {"ppl": 4.516861438751221, "ppl_lower": 10.970608711242676, "ppl/lowercase_ppl": -1.5885343889301387, "ppl/zlib": 0.004756521705673759, "Min_5.0% Prob": 11.344093595232282, "Min_10.0% Prob": 9.080917767116002, "Min_20.0% Prob": 6.5368664264678955, "Min_30.0% Prob": 4.940209528734518, "Min_40.0% Prob": 3.7693721898670853, "Min_50.0% Prob": 3.0084270905346084, "Min_60.0% Prob": 2.5287236600857357}}
{"hexsha": "4fc83d3fdc1d39e0640dd521e048db83a30a09cb", "ext": "py", "lang": "Python", "content": "@task\n@timeing\n@measure_memory_usage\ndef prepare_python_packages():\n    local('mkdir -p {local_python_packages_dir}'.format(**env))\n    local('cp {local_project_root}/requirements.txt {local_python_packages_dir}/'.format(**env))\n    existing_files = set((filenameToRequirement(filename) for filename in os.listdir(env.local_python_packages_dir)))\n    missing_requirements = tempfile.NamedTemporaryFile()\n    for raw_line in open(os.path.join(env.local_project_root, 'requirements.txt')):\n        line = raw_line.strip()\n        if not line or line.startswith('#') or line not in existing_files:\n            missing_requirements.write(raw_line)\n    missing_requirements.flush()\n    local('pip install --no-use-wheel -d {env.local_python_packages_dir} --exists-action=i -r {missing_requirements_file}'.format(env=env, missing_requirements_file=missing_requirements.name))\n    missing_requirements.close()", "fn_id": 8, "class_fn": false, "repo": "jsavikko/futurice-ldap-user-manager", "file": "fabfile.py", "last_update_at": "2021-05-06T07:57:56+00:00", "original_content": "@task\ndef prepare_python_packages():\n    local('mkdir -p {local_python_packages_dir}'.format(**env))\n    local('cp {local_project_root}/requirements.txt {local_python_packages_dir}/'.format(**env))\n    existing_files = set((filenameToRequirement(filename) for filename in os.listdir(env.local_python_packages_dir)))\n    missing_requirements = tempfile.NamedTemporaryFile()\n    for raw_line in open(os.path.join(env.local_project_root, 'requirements.txt')):\n        line = raw_line.strip()\n        if not line or line.startswith('#') or line not in existing_files:\n            missing_requirements.write(raw_line)\n    missing_requirements.flush()\n    local('pip install --no-use-wheel -d {env.local_python_packages_dir} --exists-action=i -r {missing_requirements_file}'.format(env=env, missing_requirements_file=missing_requirements.name))\n    missing_requirements.close()", "refactored": true, "pred": {"ppl": 3.1725826263427734, "ppl_lower": 3.519010543823242, "ppl/lowercase_ppl": -1.0897615971373968, "ppl/zlib": 0.0030066301167180776, "Min_5.0% Prob": 11.027279575665792, "Min_10.0% Prob": 8.173205892244974, "Min_20.0% Prob": 5.375677861273289, "Min_30.0% Prob": 3.7829511373826903, "Min_40.0% Prob": 2.891258305956408, "Min_50.0% Prob": 2.307693676229139, "Min_60.0% Prob": 1.929376121403088}}
{"hexsha": "073a2f50e72052b77841f9cbe00704769b1c08c3", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef predict(pdb_file: Path) -> float:\n    \"\"\"\n    The function that puts it all together: parsing the PDB file, generating\n    features from it and performing inference with the ML model.\n    \"\"\"\n    parser = PDBParser()\n    structure = parser.get_structure(pdb_file.stem, pdb_file)\n    features = featurize(structure)\n    predicted_solubility = ml_inference(features)\n    return predicted_solubility", "fn_id": 0, "class_fn": false, "repo": "krmstrong322/cbh21-protein-solubility-challenge", "file": "predict.py", "last_update_at": "2021-05-03T20:23:32+00:00", "original_content": "def predict(pdb_file: Path) -> float:\n    \"\"\"\n    The function that puts it all together: parsing the PDB file, generating\n    features from it and performing inference with the ML model.\n    \"\"\"\n    parser = PDBParser()\n    structure = parser.get_structure(pdb_file.stem, pdb_file)\n    features = featurize(structure)\n    predicted_solubility = ml_inference(features)\n    return predicted_solubility", "refactored": true, "pred": {"ppl": 3.743840217590332, "ppl_lower": 5.498641014099121, "ppl/lowercase_ppl": -1.2911791782039164, "ppl/zlib": 0.005301654139674701, "Min_5.0% Prob": 8.656164932250977, "Min_10.0% Prob": 7.0148717880249025, "Min_20.0% Prob": 5.121267852329073, "Min_30.0% Prob": 4.091392781585455, "Min_40.0% Prob": 3.2633594669574917, "Min_50.0% Prob": 2.6465344569749303, "Min_60.0% Prob": 2.2099312177071204}}
{"hexsha": "6a51a788efc3cd04bcda0ebddae5641c0b5fd64a", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef AdvSrch_Type_f(AdvSrch_Type):\n    if AdvSrch_Type == 'Computer':\n        return ('advancedcomputersearches', 'advanced_computer_search', 'computers')\n    if AdvSrch_Type == 'Mobile':\n        return ('advancedmobiledevicesearches', 'advanced_mobile_device_search', 'mobile_devices')\n    else:\n        print('Failed to set AdvSrch_Type properly.\\rPlease uncomment AdvSrch_Type = \"Computer\" or AdvSrch_Type = \"Mobile\"')", "fn_id": 0, "class_fn": false, "repo": "distorted-fields/jamf-to-google-reporting", "file": "jamf-to-google.py", "last_update_at": "2021-11-29T16:15:17+00:00", "original_content": "def AdvSrch_Type_f(AdvSrch_Type):\n    if AdvSrch_Type == 'Computer':\n        return ('advancedcomputersearches', 'advanced_computer_search', 'computers')\n    if AdvSrch_Type == 'Mobile':\n        return ('advancedmobiledevicesearches', 'advanced_mobile_device_search', 'mobile_devices')\n    else:\n        print('Failed to set AdvSrch_Type properly.\\rPlease uncomment AdvSrch_Type = \"Computer\" or AdvSrch_Type = \"Mobile\"')", "refactored": true, "pred": {"ppl": 6.624100208282471, "ppl_lower": 6.194847583770752, "ppl/lowercase_ppl": -0.9645654424502417, "ppl/zlib": 0.008918464835049518, "Min_5.0% Prob": 12.237682660420736, "Min_10.0% Prob": 9.948116183280945, "Min_20.0% Prob": 7.690574531555176, "Min_30.0% Prob": 6.073684821003361, "Min_40.0% Prob": 4.715524879156375, "Min_50.0% Prob": 3.8008419728139415, "Min_60.0% Prob": 3.1662382315723345}}
{"hexsha": "35daad5aecd0ac3a78c0c2339cbf51e0014f3f74", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef Predict(Phi, b, mu, s, t, r, outd):\n    print(t, '--t')\n    dt = t[1] - t[0]\n    tmin = min(t)\n    tmax = max(t)\n    t2 = np.linspace(tmin, tmax, num_pred)\n    Psi = np.zeros([r, len(t2)], dtype='complex')\n    for i, _x in enumerate(t2):\n        print(_x, '_x')\n        print(b, 'b')\n        print(i)\n        print(shape(Psi))\n        Psi[:, i] = multiply(power(mu, _x / dt), b)\n    D2 = dot(Phi, Psi)\n    sigmaps = []\n    tps = []\n    for i in range(len(D2[0, :])):\n        print(str(i) + '--predicted...' + str(t2[i]))\n        F = D2[:, i]\n        if i == 0:\n            F0 = average(F)\n        eps = t2[i]\n        sigma = MakeImagePred(F - F0, i, s, eps, outd)\n        tps.append(t2[i])\n        sigmaps.append(sigma + eps)\n    return (tps, sigmaps)", "fn_id": 10, "class_fn": false, "repo": "PapStatMechMat/SeaPy", "file": "RunSEAmodes.py", "last_update_at": "2021-05-26T05:16:05+00:00", "original_content": "def Predict(Phi, b, mu, s, t, r, outd):\n    print(t, '--t')\n    dt = t[1] - t[0]\n    tmin = min(t)\n    tmax = max(t)\n    t2 = np.linspace(tmin, tmax, num_pred)\n    Psi = np.zeros([r, len(t2)], dtype='complex')\n    for i, _x in enumerate(t2):\n        print(_x, '_x')\n        print(b, 'b')\n        print(i)\n        print(shape(Psi))\n        Psi[:, i] = multiply(power(mu, _x / dt), b)\n    D2 = dot(Phi, Psi)\n    sigmaps = []\n    tps = []\n    for i in range(len(D2[0, :])):\n        print(str(i) + '--predicted...' + str(t2[i]))\n        F = D2[:, i]\n        if i == 0:\n            F0 = average(F)\n        eps = t2[i]\n        sigma = MakeImagePred(F - F0, i, s, eps, outd)\n        tps.append(t2[i])\n        sigmaps.append(sigma + eps)\n    return (tps, sigmaps)", "refactored": true, "pred": {"ppl": 5.769132137298584, "ppl_lower": 5.719511985778809, "ppl/lowercase_ppl": -0.9950710023475854, "ppl/zlib": 0.0042640429677057255, "Min_5.0% Prob": 10.82647773197719, "Min_10.0% Prob": 9.072820515468203, "Min_20.0% Prob": 6.907329583572129, "Min_30.0% Prob": 5.404231854460456, "Min_40.0% Prob": 4.28022051236387, "Min_50.0% Prob": 3.487099230188091, "Min_60.0% Prob": 2.9134286360257424}}
{"hexsha": "70f2b74641e7867f742d38f95ce15e96044fc424", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _predict(X_, theta_, model_):\n    n = X_.shape[0]\n    t_init = time()\n    Z_hat_ = _predict_proba(X_, model_)\n    W_hat_ = _classify(Z_hat_, prob=theta_[0], invert_label=model_[-1])\n    tm = time() - t_init\n    return (W_hat_, tm)", "fn_id": 2, "class_fn": false, "repo": "gterren/cloud_segmentation", "file": "GDA_segm.py", "last_update_at": "2021-11-18T07:50:33+00:00", "original_content": "def _predict(X_, theta_, model_):\n    n = X_.shape[0]\n    t_init = time()\n    Z_hat_ = _predict_proba(X_, model_)\n    W_hat_ = _classify(Z_hat_, prob=theta_[0], invert_label=model_[-1])\n    tm = time() - t_init\n    return (W_hat_, tm)", "refactored": true, "pred": {"ppl": 6.574041843414307, "ppl_lower": 6.413365364074707, "ppl/lowercase_ppl": -0.9868598001774694, "ppl/zlib": 0.010760736229755513, "Min_5.0% Prob": 9.657212495803833, "Min_10.0% Prob": 7.92556185192532, "Min_20.0% Prob": 6.388007766322086, "Min_30.0% Prob": 5.277001553568347, "Min_40.0% Prob": 4.391089528034895, "Min_50.0% Prob": 3.699939713186147, "Min_60.0% Prob": 3.169828785262231}}
{"hexsha": "0e47d06b09a13065c0203d222fb5c4959d610194", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef checkIfRange(request, response):\n    \"\"\"Checks for the If-Range header, and if it exists, checks if the\n    test passes. Returns true if the server should return partial data.\"\"\"\n    ifrange = request.headers.getHeader('if-range')\n    if ifrange is None:\n        return True\n    if isinstance(ifrange, http_headers.ETag):\n        return ifrange.match(response.headers.getHeader('etag'), strongCompare=True)\n    else:\n        return ifrange == response.headers.getHeader('last-modified')", "fn_id": 4, "class_fn": false, "repo": "twonds/twisted", "file": "twisted/web2/http.py", "last_update_at": "2021-01-27T19:11:21+00:00", "original_content": "def checkIfRange(request, response):\n    \"\"\"Checks for the If-Range header, and if it exists, checks if the\n    test passes. Returns true if the server should return partial data.\"\"\"\n    ifrange = request.headers.getHeader('if-range')\n    if ifrange is None:\n        return True\n    if isinstance(ifrange, http_headers.ETag):\n        return ifrange.match(response.headers.getHeader('etag'), strongCompare=True)\n    else:\n        return ifrange == response.headers.getHeader('last-modified')", "refactored": true, "pred": {"ppl": 5.065478324890137, "ppl_lower": 6.360124588012695, "ppl/lowercase_ppl": -1.140281424057929, "ppl/zlib": 0.005753363725301212, "Min_5.0% Prob": 10.811763445536295, "Min_10.0% Prob": 9.05979605515798, "Min_20.0% Prob": 6.360613317489624, "Min_30.0% Prob": 4.874295476235841, "Min_40.0% Prob": 3.9622456574440004, "Min_50.0% Prob": 3.2208576909606417, "Min_60.0% Prob": 2.6973529467849353}}
{"hexsha": "68c4a5c1dfedd1f00d406e741e54edfced34cff1", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef user_info_strlist(user: telegram.User) -> list[str]:\n    keys = ['User ID', 'First Name', 'Last Name', 'User Name', 'Language Code']\n    values = [user.id, user.first_name, user.last_name, user.username, user.language_code]\n    return combine_no_none(keys, values)", "fn_id": 5, "class_fn": false, "repo": "punch-dango/telegram-bot", "file": "dango_bot.py", "last_update_at": "2021-06-15T11:47:09+00:00", "original_content": "def user_info_strlist(user: telegram.User) -> list[str]:\n    keys = ['User ID', 'First Name', 'Last Name', 'User Name', 'Language Code']\n    values = [user.id, user.first_name, user.last_name, user.username, user.language_code]\n    return combine_no_none(keys, values)", "refactored": true, "pred": {"ppl": 4.024655818939209, "ppl_lower": 4.615816116333008, "ppl/lowercase_ppl": -1.0984238856111468, "ppl/zlib": 0.007214711898402648, "Min_5.0% Prob": 11.3048574924469, "Min_10.0% Prob": 9.172008726331923, "Min_20.0% Prob": 6.5118473830975985, "Min_30.0% Prob": 4.632104016840458, "Min_40.0% Prob": 3.4661830608782016, "Min_50.0% Prob": 2.810977958737219, "Min_60.0% Prob": 2.320165935429957}}
{"hexsha": "039644328490858f1aa80d268898976f6bf2523f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef deploy():\n    execute(checkout)\n    execute(dependencies)\n    execute(make_current)\n    execute(restart)\n    execute(cleanup)", "fn_id": 1, "class_fn": false, "repo": "anupam123148/shaaaaaaaaaaaaa", "file": "fabfile.py", "last_update_at": "2021-04-24T16:37:31+00:00", "original_content": "def deploy():\n    execute(checkout)\n    execute(dependencies)\n    execute(make_current)\n    execute(restart)\n    execute(cleanup)", "refactored": true, "pred": {"ppl": 8.600761413574219, "ppl_lower": 8.600761413574219, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.021096575841200584, "Min_5.0% Prob": 9.394176959991455, "Min_10.0% Prob": 8.697361588478088, "Min_20.0% Prob": 7.217442035675049, "Min_30.0% Prob": 6.14314192533493, "Min_40.0% Prob": 5.178429692983627, "Min_50.0% Prob": 4.262339363992214, "Min_60.0% Prob": 3.575912060216069}}
{"hexsha": "d7d328944b6c85472fc3b3a7461b51d1e20de3b9", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef punctuation_count(documents: list) -> int:\n    \"\"\"Count number of punctuation characters in a list of textual documents\n\n    Keyword arguments:\n    documents -- the list of textual documents.\n    \"\"\"\n    __check_documents_param(documents)\n    char_cnt = char_count(documents, ignore_spaces=True)\n    char_wo_punctuation = letter_count(documents, ignore_spaces=True, ignore_digits=False)\n    return char_cnt - char_wo_punctuation", "fn_id": 4, "class_fn": false, "repo": "Perevalov/language_features", "file": "linguaf/descriptive_statistics.py", "last_update_at": "2021-09-21T00:47:55+00:00", "original_content": "def punctuation_count(documents: list) -> int:\n    \"\"\"Count number of punctuation characters in a list of textual documents\n\n    Keyword arguments:\n    documents -- the list of textual documents.\n    \"\"\"\n    __check_documents_param(documents)\n    char_cnt = char_count(documents, ignore_spaces=True)\n    char_wo_punctuation = letter_count(documents, ignore_spaces=True, ignore_digits=False)\n    return char_cnt - char_wo_punctuation", "refactored": true, "pred": {"ppl": 7.319525241851807, "ppl_lower": 8.806151390075684, "ppl/lowercase_ppl": -1.0928916388178662, "ppl/zlib": 0.008617079948914946, "Min_5.0% Prob": 12.729579162597656, "Min_10.0% Prob": 10.828064051541416, "Min_20.0% Prob": 8.280499458312988, "Min_30.0% Prob": 6.391296213013785, "Min_40.0% Prob": 5.0146903985220455, "Min_50.0% Prob": 4.003411144917381, "Min_60.0% Prob": 3.3246132728244575}}
{"hexsha": "8e9b1c035fd0fe23e9e05c70dd0f5fd3d8067103", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _read_version_file():\n    \"\"\"\n    Attempt to read the `version.py` file from the top level package.\n    \"\"\"\n    version_file = configuration.version_path()\n    logging.info(\"Attempting to open '%s' and read the current version.\", version_file)\n    loader = importlib.machinery.SourceFileLoader('version_module', version_file)\n    spec = importlib.util.spec_from_loader('version_module', loader)\n    version_module = importlib.util.module_from_spec(spec)\n    try:\n        loader.exec_module(version_module)\n        logging.info(\"Version file found. Using version '%s' found within.\", version_module.__version__)\n        return version_module.__version__\n    except FileNotFoundError:\n        logging.warning(\"Version file was not found at '%s'. Attempting to determine version another way.\", version_file)\n    except AttributeError as err:\n        logging.error(err)\n        logging.warning(\"Version file was found at '%s', however it did not contain the variable __version__. Attempting to determine version another way.\", version_file)\n    return None", "fn_id": 3, "class_fn": false, "repo": "timepieces141/dynamic-versioning", "file": "src/dynamic_versioning/utils.py", "last_update_at": "2021-10-20T21:33:32+00:00", "original_content": "def _read_version_file():\n    \"\"\"\n    Attempt to read the `version.py` file from the top level package.\n    \"\"\"\n    version_file = configuration.version_path()\n    logging.info(\"Attempting to open '%s' and read the current version.\", version_file)\n    loader = importlib.machinery.SourceFileLoader('version_module', version_file)\n    spec = importlib.util.spec_from_loader('version_module', loader)\n    version_module = importlib.util.module_from_spec(spec)\n    try:\n        loader.exec_module(version_module)\n        logging.info(\"Version file found. Using version '%s' found within.\", version_module.__version__)\n        return version_module.__version__\n    except FileNotFoundError:\n        logging.warning(\"Version file was not found at '%s'. Attempting to determine version another way.\", version_file)\n    except AttributeError as err:\n        logging.error(err)\n        logging.warning(\"Version file was found at '%s', however it did not contain the variable __version__. Attempting to determine version another way.\", version_file)\n    return None", "refactored": true, "pred": {"ppl": 3.436887502670288, "ppl_lower": 4.413508892059326, "ppl/lowercase_ppl": -1.2025843253736528, "ppl/zlib": 0.002805832422898162, "Min_5.0% Prob": 9.025594393412272, "Min_10.0% Prob": 7.096035671234131, "Min_20.0% Prob": 5.249803504943848, "Min_30.0% Prob": 3.9356104770773337, "Min_40.0% Prob": 3.0796818072252936, "Min_50.0% Prob": 2.4663400481653026, "Min_60.0% Prob": 2.0627942458698896}}
{"hexsha": "ac9620fc76910d66d5eadf9c78f39e41ea6edc77", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef plot_14(id, query):\n    if 'category__in' in query:\n        del query['category__in']\n    query['category'] = 'B'\n    data = data_plot_groupby_category(query, values=['category', 'cloud'], sum_param='jobdefcount', label_cols=['cloud'], label_translation=False)\n    colors = prepare_colors_for_piechart(data)\n    title = PLOT_TITLES['title' + id]\n    unit = PLOT_UNITS[id]\n    return (data, colors, title, unit)", "fn_id": 16, "class_fn": false, "repo": "PanDAWMS/panda-bigmon-core-new", "file": "core/pbm/utils.py", "last_update_at": "2021-11-18T04:57:18+00:00", "original_content": "def plot_14(id, query):\n    if 'category__in' in query:\n        del query['category__in']\n    query['category'] = 'B'\n    data = data_plot_groupby_category(query, values=['category', 'cloud'], sum_param='jobdefcount', label_cols=['cloud'], label_translation=False)\n    colors = prepare_colors_for_piechart(data)\n    title = PLOT_TITLES['title' + id]\n    unit = PLOT_UNITS[id]\n    return (data, colors, title, unit)", "refactored": true, "pred": {"ppl": 11.99238109588623, "ppl_lower": 13.75034236907959, "ppl/lowercase_ppl": -1.0550632979231827, "ppl/zlib": 0.009201005701748097, "Min_5.0% Prob": 11.138876597086588, "Min_10.0% Prob": 9.74638634461623, "Min_20.0% Prob": 8.09813352867409, "Min_30.0% Prob": 6.987539005279541, "Min_40.0% Prob": 5.814587699042426, "Min_50.0% Prob": 4.8632048499934815, "Min_60.0% Prob": 4.144949277609955}}
{"hexsha": "8502057a4b3bf916aba610da48747e7b8d5604e4", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef load_data():\n    moon_data = np.load('moon_data.npz')\n    x_s = moon_data['x_s']\n    y_s = moon_data['y_s']\n    x_t = moon_data['x_t']\n    return (torch.from_numpy(x_s).float(), torch.from_numpy(y_s).float(), torch.from_numpy(x_t).float())", "fn_id": 2, "class_fn": false, "repo": "krumo/swd_pytorch", "file": "swd_pytorch.py", "last_update_at": "2021-11-09T07:08:23+00:00", "original_content": "def load_data():\n    moon_data = np.load('moon_data.npz')\n    x_s = moon_data['x_s']\n    y_s = moon_data['y_s']\n    x_t = moon_data['x_t']\n    return (torch.from_numpy(x_s).float(), torch.from_numpy(y_s).float(), torch.from_numpy(x_t).float())", "refactored": true, "pred": {"ppl": 2.421321153640747, "ppl_lower": 2.421321153640747, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.006015736887475157, "Min_5.0% Prob": 10.13851556777954, "Min_10.0% Prob": 7.481031847000122, "Min_20.0% Prob": 4.324744221710024, "Min_30.0% Prob": 2.9548153588548303, "Min_40.0% Prob": 2.2159118830811146, "Min_50.0% Prob": 1.7679906129336882, "Min_60.0% Prob": 1.4922165209718514}}
{"hexsha": "85d7907789cbbb8ce6e2019eb09711694ee29577", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_main():\n\n    def cmd(*args, **kwargs):\n        try:\n            main.callback(*args, **kwargs)\n            return 0\n        except SystemExit as e:\n            return e.code\n    inpath = 'examples/test.py'\n    outpath = 'examples/test.xml'\n    assert cmd(inpath, outpath, verbose=True, string=True) == 0\n    assert cmd(inpath, outpath, help=True) == 0\n    assert cmd(inpath, outpath, reload=True) == 0\n    assert cmd(inpath, outpath, version=True) == 0\n    assert cmd(inpath, outpath, list_peripherals=True) == 0", "fn_id": 0, "class_fn": false, "repo": "loggerhead/Easy-Karabiner", "file": "tests/test_main.py", "last_update_at": "2021-05-26T00:28:59+00:00", "original_content": "def test_main():\n\n    def cmd(*args, **kwargs):\n        try:\n            main.callback(*args, **kwargs)\n            return 0\n        except SystemExit as e:\n            return e.code\n    inpath = 'examples/test.py'\n    outpath = 'examples/test.xml'\n    assert cmd(inpath, outpath, verbose=True, string=True) == 0\n    assert cmd(inpath, outpath, help=True) == 0\n    assert cmd(inpath, outpath, reload=True) == 0\n    assert cmd(inpath, outpath, version=True) == 0\n    assert cmd(inpath, outpath, list_peripherals=True) == 0", "refactored": true, "pred": {"ppl": 3.5389621257781982, "ppl_lower": 4.126019477844238, "ppl/lowercase_ppl": -1.1214397593700758, "ppl/zlib": 0.005400997860470924, "Min_5.0% Prob": 10.142939925193787, "Min_10.0% Prob": 7.866278320550919, "Min_20.0% Prob": 5.699649008837613, "Min_30.0% Prob": 4.122528715133667, "Min_40.0% Prob": 3.139277451296351, "Min_50.0% Prob": 2.519508368956546, "Min_60.0% Prob": 2.120605019982904}}
{"hexsha": "dbdac17e96cf66994ed82d897eac1d43424c6c6f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef collect_bstock(pop, sp_idcs, farm_idx):\n    \"\"\"Migrate marked broodstock from source subpopulation\n    to farm subpopulation.\"\"\"\n    for sp_idx in sp_idcs:\n        for ind in pop.individuals([sp_idx]):\n            if ind.broodstock == 1:\n                ind.migrate_to = farm_idx\n            else:\n                ind.migrate_to = sp_idx\n    sim.migrate(pop, mode=sim.BY_IND_INFO)", "fn_id": 12, "class_fn": false, "repo": "nwfsc-cb/shellfish-genetic-risks", "file": "inst/GRs.py", "last_update_at": "2021-09-14T05:30:49+00:00", "original_content": "def collect_bstock(pop, sp_idcs, farm_idx):\n    \"\"\"Migrate marked broodstock from source subpopulation\n    to farm subpopulation.\"\"\"\n    for sp_idx in sp_idcs:\n        for ind in pop.individuals([sp_idx]):\n            if ind.broodstock == 1:\n                ind.migrate_to = farm_idx\n            else:\n                ind.migrate_to = sp_idx\n    sim.migrate(pop, mode=sim.BY_IND_INFO)", "refactored": true, "pred": {"ppl": 10.95179557800293, "ppl_lower": 12.954057693481445, "ppl/lowercase_ppl": -1.070150579415533, "ppl/zlib": 0.01054406794072951, "Min_5.0% Prob": 12.624779510498048, "Min_10.0% Prob": 10.97016750682484, "Min_20.0% Prob": 8.932306455529254, "Min_30.0% Prob": 7.020261423928397, "Min_40.0% Prob": 5.692190203260868, "Min_50.0% Prob": 4.732196231009596, "Min_60.0% Prob": 3.99572958115121}}
{"hexsha": "b85923ab8b9e16da8df9357a1215d9b3530c1988", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef detect(image):\n    detector = dlib.get_frontal_face_detector()\n    img_gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)\n    rects = detector(img_gray, 0)\n    return rects", "fn_id": 1, "class_fn": false, "repo": "ForrestPi/FaceProjects", "file": "facialLandmarker/pfld/algin_dlib.py", "last_update_at": "2021-06-22T06:21:29+00:00", "original_content": "def detect(image):\n    detector = dlib.get_frontal_face_detector()\n    img_gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)\n    rects = detector(img_gray, 0)\n    return rects", "refactored": true, "pred": {"ppl": 2.4736475944519043, "ppl_lower": 4.07717227935791, "ppl/lowercase_ppl": -1.551742595584153, "ppl/zlib": 0.006078482014706153, "Min_5.0% Prob": 7.801036198933919, "Min_10.0% Prob": 6.4475908279418945, "Min_20.0% Prob": 4.370101442703834, "Min_30.0% Prob": 3.073859317600727, "Min_40.0% Prob": 2.308567732434582, "Min_50.0% Prob": 1.8372902953449417, "Min_60.0% Prob": 1.524155247632823}}
{"hexsha": "b36f29adbca75035b8a5747f2e0405b7dd6b8caf", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef roll20(querry=None):\n    \"\"\"\n    Searches roll20.net for a querry and opens the search in a webbrowser.\n    :param querry: String to search for.  If none is provided, asks the user.\n    :return: None\n    \"\"\"\n    if querry is None:\n        querry = simpledialog.askstring('Search Roll20', 'Search Roll20.net for:')\n    if querry is not None:\n        url = 'https://roll20.net/compendium/dnd5e/searchbook/?terms=' + querry\n        webbrowser.open(url)", "fn_id": 1, "class_fn": false, "repo": "spudhunter/DnD-Combat-Manager", "file": "CombatManager.py", "last_update_at": "2021-01-20T05:11:23+00:00", "original_content": "def roll20(querry=None):\n    \"\"\"\n    Searches roll20.net for a querry and opens the search in a webbrowser.\n    :param querry: String to search for.  If none is provided, asks the user.\n    :return: None\n    \"\"\"\n    if querry is None:\n        querry = simpledialog.askstring('Search Roll20', 'Search Roll20.net for:')\n    if querry is not None:\n        url = 'https://roll20.net/compendium/dnd5e/searchbook/?terms=' + querry\n        webbrowser.open(url)", "refactored": true, "pred": {"ppl": 4.0254106521606445, "ppl_lower": 5.072683334350586, "ppl/lowercase_ppl": -1.166048062593774, "ppl/zlib": 0.005064097931082975, "Min_5.0% Prob": 11.203102111816406, "Min_10.0% Prob": 8.784749031066895, "Min_20.0% Prob": 5.953234524562441, "Min_30.0% Prob": 4.397825556722554, "Min_40.0% Prob": 3.43234195446564, "Min_50.0% Prob": 2.7836496409129454, "Min_60.0% Prob": 2.3279246772859206}}
{"hexsha": "31a0f40f5b3b73886fe6be3847e4043e0c0b0471", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef checkEntries(DataSetFile, preprocess=lambda x: x, dataType='jpg'):\n    dataset = wds.WebDataset(DataSetFile)\n    itemsTouched = 0\n    for element in dataset:\n        print(element['__key__'])\n        preprocess(element[dataType])\n        tmp = element[0]\n        if not tmp == None:\n            itemsTouched += 1\n    return itemsTouched", "fn_id": 8, "class_fn": false, "repo": "AaltoRSE/ImageNetTools", "file": "ImageNetTools/IOTesters.py", "last_update_at": "2021-11-15T11:21:55+00:00", "original_content": "def checkEntries(DataSetFile, preprocess=lambda x: x, dataType='jpg'):\n    dataset = wds.WebDataset(DataSetFile)\n    itemsTouched = 0\n    for element in dataset:\n        print(element['__key__'])\n        preprocess(element[dataType])\n        tmp = element[0]\n        if not tmp == None:\n            itemsTouched += 1\n    return itemsTouched", "refactored": true, "pred": {"ppl": 9.593247413635254, "ppl_lower": 10.500484466552734, "ppl/lowercase_ppl": -1.0399644241754027, "ppl/zlib": 0.010419628832087005, "Min_5.0% Prob": 15.191473007202148, "Min_10.0% Prob": 12.293164783053928, "Min_20.0% Prob": 9.122669721904554, "Min_30.0% Prob": 7.139224576098578, "Min_40.0% Prob": 5.527186070617876, "Min_50.0% Prob": 4.526382636199606, "Min_60.0% Prob": 3.756096459010191}}
{"hexsha": "db491fb88dce762693e7f13205150b53101924e2", "ext": "py", "lang": "Python", "content": "@pytest.mark.parametrize(['augmentation_cls', 'params'], get_dual_transforms(custom_arguments={A.Crop: {'y_min': 0, 'y_max': 10, 'x_min': 0, 'x_max': 10}, A.CenterCrop: {'height': 10, 'width': 10}, A.CropNonEmptyMaskIfExists: {'height': 10, 'width': 10}, A.RandomCrop: {'height': 10, 'width': 10}, A.RandomResizedCrop: {'height': 10, 'width': 10}, A.RandomSizedCrop: {'min_max_height': (4, 8), 'height': 10, 'width': 10}, A.CropAndPad: {'px': 10}, A.Resize: {'height': 10, 'width': 10}}, except_augmentations={A.RandomCropNearBBox, A.RandomSizedBBoxSafeCrop}))\n@timeing\n@measure_memory_usage\ndef test_dual_augmentations(augmentation_cls, params, image, mask):\n    aug = augmentation_cls(p=1, **params)\n    data = aug(image=image, mask=mask)\n    assert data['image'].dtype == np.uint8\n    assert data['mask'].dtype == np.uint8", "fn_id": 2, "class_fn": false, "repo": "rayxke/albumentations", "file": "tests/test_augmentations.py", "last_update_at": "2021-08-25T08:41:00+00:00", "original_content": "@pytest.mark.parametrize(['augmentation_cls', 'params'], get_dual_transforms(custom_arguments={A.Crop: {'y_min': 0, 'y_max': 10, 'x_min': 0, 'x_max': 10}, A.CenterCrop: {'height': 10, 'width': 10}, A.CropNonEmptyMaskIfExists: {'height': 10, 'width': 10}, A.RandomCrop: {'height': 10, 'width': 10}, A.RandomResizedCrop: {'height': 10, 'width': 10}, A.RandomSizedCrop: {'min_max_height': (4, 8), 'height': 10, 'width': 10}, A.CropAndPad: {'px': 10}, A.Resize: {'height': 10, 'width': 10}}, except_augmentations={A.RandomCropNearBBox, A.RandomSizedBBoxSafeCrop}))\ndef test_dual_augmentations(augmentation_cls, params, image, mask):\n    aug = augmentation_cls(p=1, **params)\n    data = aug(image=image, mask=mask)\n    assert data['image'].dtype == np.uint8\n    assert data['mask'].dtype == np.uint8", "refactored": true, "pred": {"ppl": 2.0907232761383057, "ppl_lower": 2.9793736934661865, "ppl/lowercase_ppl": -1.480268746165645, "ppl/zlib": 0.0020150548394752364, "Min_5.0% Prob": 8.202761363983154, "Min_10.0% Prob": 5.8403552962887675, "Min_20.0% Prob": 3.521453364241508, "Min_30.0% Prob": 2.4528102346004976, "Min_40.0% Prob": 1.852008315494224, "Min_50.0% Prob": 1.4743568119204913, "Min_60.0% Prob": 1.2303821114906643}}
{"hexsha": "1b67a7d9d4167a9df6ed58c7d637b09510718d46", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef spider(headers, conferences_url):\n    for conference_url in conferences_url:\n        html_level1 = requests.get(conference_url, headers=headers).content\n        tree_level1 = etree.HTML(html_level1)\n        conferences = tree_level1.xpath(\"//a[contains(@href, 'dblp.uni-trier.de/db/conf/') and contains(@href, 'html')]/@href\")\n        conferences = list(set(conferences))\n        fp_dir = os.path.split(os.path.realpath(sys.argv[0]))[0] + os.sep + 'source' + os.sep + 'conf' + os.sep + conference_url.split('/')[-2]\n        if not os.path.exists(fp_dir):\n            os.makedirs(fp_dir)\n        for conference in conferences:\n            fp_name = fp_dir + os.sep + conference.split('/')[-1].split('.')[0] + '.csv'\n            if os.path.exists(fp_name):\n                print('History: ', fp_name.encode('utf-8'))\n                continue\n            html_level2 = requests.get(conference, headers=headers).content\n            tree_level2 = etree.HTML(html_level2)\n            if tree_level2.xpath(\"//li[@class='entry inproceedings']\"):\n                extractor(tree_level2, fp_name)\n            else:\n                volumes = tree_level2.xpath(\"//*[@id='main']/ul/li/a/@href\")\n                for volume in volumes:\n                    fp_name = fp_dir + os.sep + volume.split('/')[-1].split('.')[0] + '.csv'\n                    if os.path.exists(fp_name):\n                        print('History: ', fp_name.encode('utf-8'))\n                        continue\n                    html_level3 = requests.get(volume, headers=headers).content\n                    tree_level3 = etree.HTML(html_level3)\n                    extractor(tree_level3, fp_name)", "fn_id": 1, "class_fn": false, "repo": "Aticode/spider_dblp", "file": "conferences.py", "last_update_at": "2021-01-18T09:00:14+00:00", "original_content": "def spider(headers, conferences_url):\n    for conference_url in conferences_url:\n        html_level1 = requests.get(conference_url, headers=headers).content\n        tree_level1 = etree.HTML(html_level1)\n        conferences = tree_level1.xpath(\"//a[contains(@href, 'dblp.uni-trier.de/db/conf/') and contains(@href, 'html')]/@href\")\n        conferences = list(set(conferences))\n        fp_dir = os.path.split(os.path.realpath(sys.argv[0]))[0] + os.sep + 'source' + os.sep + 'conf' + os.sep + conference_url.split('/')[-2]\n        if not os.path.exists(fp_dir):\n            os.makedirs(fp_dir)\n        for conference in conferences:\n            fp_name = fp_dir + os.sep + conference.split('/')[-1].split('.')[0] + '.csv'\n            if os.path.exists(fp_name):\n                print('History: ', fp_name.encode('utf-8'))\n                continue\n            html_level2 = requests.get(conference, headers=headers).content\n            tree_level2 = etree.HTML(html_level2)\n            if tree_level2.xpath(\"//li[@class='entry inproceedings']\"):\n                extractor(tree_level2, fp_name)\n            else:\n                volumes = tree_level2.xpath(\"//*[@id='main']/ul/li/a/@href\")\n                for volume in volumes:\n                    fp_name = fp_dir + os.sep + volume.split('/')[-1].split('.')[0] + '.csv'\n                    if os.path.exists(fp_name):\n                        print('History: ', fp_name.encode('utf-8'))\n                        continue\n                    html_level3 = requests.get(volume, headers=headers).content\n                    tree_level3 = etree.HTML(html_level3)\n                    extractor(tree_level3, fp_name)", "refactored": true, "pred": {"ppl": 2.112490177154541, "ppl_lower": 2.1547586917877197, "ppl/lowercase_ppl": -1.0264904047724477, "ppl/zlib": 0.0013697205684445209, "Min_5.0% Prob": 8.5253499072531, "Min_10.0% Prob": 5.907092251676194, "Min_20.0% Prob": 3.585554094390666, "Min_30.0% Prob": 2.478936378520431, "Min_40.0% Prob": 1.8708390503368797, "Min_50.0% Prob": 1.498467115225627, "Min_60.0% Prob": 1.2490307977307482}}
{"hexsha": "86b7411d0f37a9a1b85f3b8b0f899c31c9cc6336", "ext": "py", "lang": "Python", "content": "@pytest.mark.filterwarnings('ignore:This function is not safe at the moment')\n@pytest.mark.parametrize('input_type', [tuple, list])\n@requires_tables\n@timeing\n@measure_memory_usage\ndef test_complete_irradiance_arrays(sapm_dc_snl_ac_system_same_arrays, location, input_type):\n    \"\"\"ModelChain.complete_irradiance can accept a tuple of weather\n    DataFrames.\"\"\"\n    times = pd.date_range(start='2020-01-01 0700-0700', periods=2, freq='H')\n    weather = pd.DataFrame({'dni': [2, 3], 'dhi': [4, 6], 'ghi': [9, 5]}, index=times)\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n    with pytest.raises(ValueError, match='Input DataFrames must have same index\\\\.'):\n        mc.complete_irradiance(input_type((weather, weather[1:])))\n    mc.complete_irradiance(input_type((weather, weather)))\n    for mc_weather in mc.results.weather:\n        assert_series_equal(mc_weather['dni'], pd.Series([2, 3], index=times, name='dni'))\n        assert_series_equal(mc_weather['dhi'], pd.Series([4, 6], index=times, name='dhi'))\n        assert_series_equal(mc_weather['ghi'], pd.Series([9, 5], index=times, name='ghi'))\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n    mc.complete_irradiance(input_type((weather[['ghi', 'dhi']], weather[['dhi', 'dni']])))\n    assert 'dni' in mc.results.weather[0].columns\n    assert 'ghi' in mc.results.weather[1].columns\n    mc.complete_irradiance(input_type((weather, weather[['ghi', 'dni']])))\n    assert_series_equal(mc.results.weather[0]['dhi'], pd.Series([4, 6], index=times, name='dhi'))\n    assert_series_equal(mc.results.weather[0]['ghi'], pd.Series([9, 5], index=times, name='ghi'))\n    assert_series_equal(mc.results.weather[0]['dni'], pd.Series([2, 3], index=times, name='dni'))\n    assert 'dhi' in mc.results.weather[1].columns", "fn_id": 104, "class_fn": false, "repo": "Kaustubh1598/pvlib-python", "file": "pvlib/tests/test_modelchain.py", "last_update_at": "2021-08-16T06:47:01+00:00", "original_content": "@pytest.mark.filterwarnings('ignore:This function is not safe at the moment')\n@pytest.mark.parametrize('input_type', [tuple, list])\n@requires_tables\ndef test_complete_irradiance_arrays(sapm_dc_snl_ac_system_same_arrays, location, input_type):\n    \"\"\"ModelChain.complete_irradiance can accept a tuple of weather\n    DataFrames.\"\"\"\n    times = pd.date_range(start='2020-01-01 0700-0700', periods=2, freq='H')\n    weather = pd.DataFrame({'dni': [2, 3], 'dhi': [4, 6], 'ghi': [9, 5]}, index=times)\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n    with pytest.raises(ValueError, match='Input DataFrames must have same index\\\\.'):\n        mc.complete_irradiance(input_type((weather, weather[1:])))\n    mc.complete_irradiance(input_type((weather, weather)))\n    for mc_weather in mc.results.weather:\n        assert_series_equal(mc_weather['dni'], pd.Series([2, 3], index=times, name='dni'))\n        assert_series_equal(mc_weather['dhi'], pd.Series([4, 6], index=times, name='dhi'))\n        assert_series_equal(mc_weather['ghi'], pd.Series([9, 5], index=times, name='ghi'))\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n    mc.complete_irradiance(input_type((weather[['ghi', 'dhi']], weather[['dhi', 'dni']])))\n    assert 'dni' in mc.results.weather[0].columns\n    assert 'ghi' in mc.results.weather[1].columns\n    mc.complete_irradiance(input_type((weather, weather[['ghi', 'dni']])))\n    assert_series_equal(mc.results.weather[0]['dhi'], pd.Series([4, 6], index=times, name='dhi'))\n    assert_series_equal(mc.results.weather[0]['ghi'], pd.Series([9, 5], index=times, name='ghi'))\n    assert_series_equal(mc.results.weather[0]['dni'], pd.Series([2, 3], index=times, name='dni'))\n    assert 'dhi' in mc.results.weather[1].columns", "refactored": true, "pred": {"ppl": 2.293482780456543, "ppl_lower": 2.512334108352661, "ppl/lowercase_ppl": -1.1097986313928723, "ppl/zlib": 0.0013974268132166436, "Min_5.0% Prob": 8.514939975738525, "Min_10.0% Prob": 6.176317056020101, "Min_20.0% Prob": 3.926178221901258, "Min_30.0% Prob": 2.739910380045573, "Min_40.0% Prob": 2.0771182445033145, "Min_50.0% Prob": 1.6594802796534351, "Min_60.0% Prob": 1.3841650347440462}}
{"hexsha": "3ad888b6411bf731d2ffa031e8ac7e352cb37d45", "ext": "py", "lang": "Python", "content": "@bp.route('/create', methods=('GET', 'POST'))\n@login_required\n@timeing\n@measure_memory_usage\ndef create():\n    if request.method == 'POST':\n        name = request.form['name']\n        description = request.form['description']\n        error = None\n        if not name:\n            error = 'Name is required.'\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute('INSERT INTO dens (name, description, author_id) VALUES (?, ?, ?)', (name, description, g.user['id']))\n            db.commit()\n            return redirect(url_for('dens.index'))\n    return render_template('dens/create.html')", "fn_id": 1, "class_fn": false, "repo": "tsainez/bobchat", "file": "bobchat/dens.py", "last_update_at": "2021-12-14T19:16:11+00:00", "original_content": "@bp.route('/create', methods=('GET', 'POST'))\n@login_required\ndef create():\n    if request.method == 'POST':\n        name = request.form['name']\n        description = request.form['description']\n        error = None\n        if not name:\n            error = 'Name is required.'\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute('INSERT INTO dens (name, description, author_id) VALUES (?, ?, ?)', (name, description, g.user['id']))\n            db.commit()\n            return redirect(url_for('dens.index'))\n    return render_template('dens/create.html')", "refactored": true, "pred": {"ppl": 2.0368828773498535, "ppl_lower": 2.735605001449585, "ppl/lowercase_ppl": -1.414567647897682, "ppl/zlib": 0.002111040468761121, "Min_5.0% Prob": 8.043397009372711, "Min_10.0% Prob": 5.677493095397949, "Min_20.0% Prob": 3.498010527342558, "Min_30.0% Prob": 2.394713618171712, "Min_40.0% Prob": 1.7796632445488985, "Min_50.0% Prob": 1.4304286294018873, "Min_60.0% Prob": 1.1951321864779079}}
{"hexsha": "1e6e4ef45a8b40afebac91fb3f7bf135a4a6341f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_tags(pipeline):\n    nodes = pipeline.nodes\n    tags = {node.name: node.tags for node in nodes}\n    return tags", "fn_id": 3, "class_fn": false, "repo": "gcalmettes/kedro-argo", "file": "src/kedro_argo/cli.py", "last_update_at": "2021-01-20T04:23:56+00:00", "original_content": "def get_tags(pipeline):\n    nodes = pipeline.nodes\n    tags = {node.name: node.tags for node in nodes}\n    return tags", "refactored": true, "pred": {"ppl": 5.11191463470459, "ppl_lower": 5.11191463470459, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.014567625160128163, "Min_5.0% Prob": 9.000168800354004, "Min_10.0% Prob": 8.272761821746826, "Min_20.0% Prob": 6.895078390836716, "Min_30.0% Prob": 5.230929623047511, "Min_40.0% Prob": 4.104633886367083, "Min_50.0% Prob": 3.2147009046304795, "Min_60.0% Prob": 2.7244378194212913}}
{"hexsha": "c0e6fb6fdeb419f4456ff38cda990830605dba2c", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef calculate_bead_lims(bead_size, region_revs, region_fors):\n    \"\"\"\n    Divides a region on a chromosome (or rather, the part of it covered by complete\n    restriction fragments) into segments of equal, given length and one last\n    segment which is smaller than the others such that the segments completely\n    cover the region. These segments will be represented by spherical beads later.\n    Returns the limits of the segments\n    \"\"\"\n    region_length = np.max((region_fors[-1, 1], region_revs[1, -1])) - np.min((region_fors[0, 0], region_revs[0, 0]))\n    n_beads = int(round(region_length / bead_size)) + 1\n    bead_lims = [np.min((region_fors[0, 0], region_revs[0, 0])) + i * bead_size for i in range(n_beads)]\n    bead_lims[-1] = np.max((region_fors[-1, 1], region_revs[1, -1]))\n    return np.array(bead_lims)", "fn_id": 2, "class_fn": false, "repo": "simeoncarstens/ensemble_hic", "file": "data/nora2012/make_processed_files.py", "last_update_at": "2021-03-16T04:38:07+00:00", "original_content": "def calculate_bead_lims(bead_size, region_revs, region_fors):\n    \"\"\"\n    Divides a region on a chromosome (or rather, the part of it covered by complete\n    restriction fragments) into segments of equal, given length and one last\n    segment which is smaller than the others such that the segments completely\n    cover the region. These segments will be represented by spherical beads later.\n    Returns the limits of the segments\n    \"\"\"\n    region_length = np.max((region_fors[-1, 1], region_revs[1, -1])) - np.min((region_fors[0, 0], region_revs[0, 0]))\n    n_beads = int(round(region_length / bead_size)) + 1\n    bead_lims = [np.min((region_fors[0, 0], region_revs[0, 0])) + i * bead_size for i in range(n_beads)]\n    bead_lims[-1] = np.max((region_fors[-1, 1], region_revs[1, -1]))\n    return np.array(bead_lims)", "refactored": true, "pred": {"ppl": 4.296186447143555, "ppl_lower": 4.298313617706299, "ppl/lowercase_ppl": -1.000339574661478, "ppl/zlib": 0.0036171904626250227, "Min_5.0% Prob": 9.844409135671762, "Min_10.0% Prob": 8.157022882390905, "Min_20.0% Prob": 6.046992765773426, "Min_30.0% Prob": 4.660229155098099, "Min_40.0% Prob": 3.620355978742376, "Min_50.0% Prob": 2.9188938016514125, "Min_60.0% Prob": 2.4340506372861785}}
{"hexsha": "8086f65407ad32c804e1c9c38b95a0d946baf627", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _spec_from_colon_separated_text_list(spec_name: str):\n    \"\"\"\n    Get a specification value from a list of colon separated values in\n\n    `_general_specs(...)` returns a list of strings of with the format\n    `Spec Name: Spec Value`.\n    TODO: Implement and use this. Refactor `ttaf(...)`\n    \"\"\"", "fn_id": 14, "class_fn": false, "repo": "jwalleser/plane-finder-app", "file": "planefinder/trade_a_plane.py", "last_update_at": "2021-12-31T02:54:08+00:00", "original_content": "def _spec_from_colon_separated_text_list(spec_name: str):\n    \"\"\"\n    Get a specification value from a list of colon separated values in\n\n    `_general_specs(...)` returns a list of strings of with the format\n    `Spec Name: Spec Value`.\n    TODO: Implement and use this. Refactor `ttaf(...)`\n    \"\"\"", "refactored": true, "pred": {"ppl": 36.07729721069336, "ppl_lower": 37.141082763671875, "ppl/lowercase_ppl": -1.0081044764559681, "ppl/zlib": 0.016151638654849677, "Min_5.0% Prob": 12.532531499862671, "Min_10.0% Prob": 11.596829533576965, "Min_20.0% Prob": 10.033888227799359, "Min_30.0% Prob": 8.805756149291993, "Min_40.0% Prob": 7.616626676391153, "Min_50.0% Prob": 6.663872413857039, "Min_60.0% Prob": 5.870592301967097}}
{"hexsha": "623568b4c78cf9a439d74b2c528e6cff22e0cadb", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef detect_text(content):\n    \"\"\"Detects text in the file.\"\"\"\n    from google.cloud import vision\n    import io\n    client = vision.ImageAnnotatorClient()\n    content_base64 = base64.b64decode(content)\n    image = vision.Image(content=content_base64)\n    response = client.text_detection(image=image)\n    text = response.text_annotations[0].description\n    return text", "fn_id": 0, "class_fn": false, "repo": "OmkarMehta/anuvad", "file": "anuvad/callbacks.py", "last_update_at": "2021-08-18T00:50:53+00:00", "original_content": "def detect_text(content):\n    \"\"\"Detects text in the file.\"\"\"\n    from google.cloud import vision\n    import io\n    client = vision.ImageAnnotatorClient()\n    content_base64 = base64.b64decode(content)\n    image = vision.Image(content=content_base64)\n    response = client.text_detection(image=image)\n    text = response.text_annotations[0].description\n    return text", "refactored": true, "pred": {"ppl": 2.5144152641296387, "ppl_lower": 4.385163307189941, "ppl/lowercase_ppl": -1.6032129007469833, "ppl/zlib": 0.003991516351374484, "Min_5.0% Prob": 7.845612049102783, "Min_10.0% Prob": 6.5164916038513185, "Min_20.0% Prob": 4.354114898613521, "Min_30.0% Prob": 3.035137275699526, "Min_40.0% Prob": 2.3364091641491367, "Min_50.0% Prob": 1.8581816687617663, "Min_60.0% Prob": 1.5409231297526276}}
{"hexsha": "811ab0d25f1780d5e5c2deb38dcaf25cb83fa07a", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef deletecall(bam_url, api_call, call_parameters, delete_entity, header):\n    \"\"\"API request to delete and return values\"\"\"\n    call_url = 'http://' + bam_url + '/Services/REST/v1/' + api_call + '?'\n    print('You are requesting to delete:')\n    print(delete_entity)\n    answer = input('Do you want to proceed (y (yes) or n (no))? ')\n    try:\n        if answer.lower() == 'y':\n            response = requests.delete(call_url, params=call_parameters, headers=header)\n            return response.json()\n        elif answer.lower() == 'n':\n            return 'You aborted deletion'\n        else:\n            return 'You entered an invalid character'\n    except requests.exceptions.RequestException as e:\n        print(e)", "fn_id": 1, "class_fn": false, "repo": "bluecatlabs/making-apis-work-for-you", "file": "Episodes/Episode6/2-getServers-REST.py", "last_update_at": "2021-02-16T12:51:20+00:00", "original_content": "def deletecall(bam_url, api_call, call_parameters, delete_entity, header):\n    \"\"\"API request to delete and return values\"\"\"\n    call_url = 'http://' + bam_url + '/Services/REST/v1/' + api_call + '?'\n    print('You are requesting to delete:')\n    print(delete_entity)\n    answer = input('Do you want to proceed (y (yes) or n (no))? ')\n    try:\n        if answer.lower() == 'y':\n            response = requests.delete(call_url, params=call_parameters, headers=header)\n            return response.json()\n        elif answer.lower() == 'n':\n            return 'You aborted deletion'\n        else:\n            return 'You entered an invalid character'\n    except requests.exceptions.RequestException as e:\n        print(e)", "refactored": true, "pred": {"ppl": 5.09067964553833, "ppl_lower": 5.787774085998535, "ppl/lowercase_ppl": -1.0788592444568448, "ppl/zlib": 0.004339763592785902, "Min_5.0% Prob": 11.35498481326633, "Min_10.0% Prob": 9.313528763620477, "Min_20.0% Prob": 6.9355740170729785, "Min_30.0% Prob": 5.16373257390384, "Min_40.0% Prob": 4.026638066613829, "Min_50.0% Prob": 3.238404505108435, "Min_60.0% Prob": 2.7174959562975785}}
{"hexsha": "f6667e4bee5b954c1e12aaebccf65cda7aa78ce7", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef generate_sub_id():\n    timestamp = floor(time() * 1000)\n    random_id = randint(0, 999)\n    return f'sub-{timestamp}-{random_id:03}'", "fn_id": 0, "class_fn": false, "repo": "ChessTerm/jiuqi-runner", "file": "run.py", "last_update_at": "2021-06-13T03:48:20+00:00", "original_content": "def generate_sub_id():\n    timestamp = floor(time() * 1000)\n    random_id = randint(0, 999)\n    return f'sub-{timestamp}-{random_id:03}'", "refactored": true, "pred": {"ppl": 4.128161907196045, "ppl_lower": 4.128161907196045, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.010580837679959544, "Min_5.0% Prob": 8.15607182184855, "Min_10.0% Prob": 7.42780613899231, "Min_20.0% Prob": 5.659286538759868, "Min_30.0% Prob": 4.433857474062178, "Min_40.0% Prob": 3.534568764269352, "Min_50.0% Prob": 2.8677051432430742, "Min_60.0% Prob": 2.3968730724623635}}
{"hexsha": "793c76b7aef3c3464b9f0b5785241de95f0cc1ed", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef draw_flow(img, flow, step=16):\n    h, w = img.shape[:2]\n    y, x = np.mgrid[step / 2:h:step, step / 2:w:step].reshape(2, -1).astype(int)\n    fx, fy = flow[y, x].T\n    lines = np.vstack([x, y, x + fx, y + fy]).T.reshape(-1, 2, 2)\n    lines = np.int32(lines + 0.5)\n    vis = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n    cv2.polylines(vis, lines, 0, (0, 255, 0))\n    for (x1, y1), (_x2, _y2) in lines:\n        cv2.circle(vis, (x1, y1), 1, (0, 255, 0), -1)\n    return vis", "fn_id": 4, "class_fn": false, "repo": "mcv-m6-video/mcv-m6-2021-team6", "file": "W4/display.py", "last_update_at": "2021-03-23T18:54:28+00:00", "original_content": "def draw_flow(img, flow, step=16):\n    h, w = img.shape[:2]\n    y, x = np.mgrid[step / 2:h:step, step / 2:w:step].reshape(2, -1).astype(int)\n    fx, fy = flow[y, x].T\n    lines = np.vstack([x, y, x + fx, y + fy]).T.reshape(-1, 2, 2)\n    lines = np.int32(lines + 0.5)\n    vis = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n    cv2.polylines(vis, lines, 0, (0, 255, 0))\n    for (x1, y1), (_x2, _y2) in lines:\n        cv2.circle(vis, (x1, y1), 1, (0, 255, 0), -1)\n    return vis", "refactored": true, "pred": {"ppl": 1.2756682634353638, "ppl_lower": 1.8027935028076172, "ppl/lowercase_ppl": -2.4205733668421217, "ppl/zlib": 0.0007879293510931624, "Min_5.0% Prob": 4.738365715200251, "Min_10.0% Prob": 2.441974997844385, "Min_20.0% Prob": 1.2361007805346795, "Min_30.0% Prob": 0.8135271543703441, "Min_40.0% Prob": 0.6125477037219811, "Min_50.0% Prob": 0.48692795780908243, "Min_60.0% Prob": 0.4069395780530093}}
{"hexsha": "ff326af30a0e940467d42ebccf60e036d6b028f5", "ext": "py", "lang": "Python", "content": "@bot.command()\n@timeing\n@measure_memory_usage\nasync def listening(ctx, *, message=None):\n    await ctx.message.delete()\n    if message is None:\n        commandprint(\"Command 'listening' has been used by \" + bot.user.name + ' with no message')\n        embed = discord.Embed(title=f'**Invalid syntax**', description='You have not specified a listening \\nExample: ' + prefix + 'listening flairings piss', color=errorcolor)\n        embed.set_footer(text=footer)\n        await ctx.send(embed=embed, delete_after=deletetimer)\n    else:\n        try:\n            commandprint(\"Command 'listening' has been used by \" + bot.user.name + \" with a message of '\" + message + \"'\")\n            await bot.change_presence(activity=discord.Activity(type=discord.ActivityType.listening, name=message))\n            em = discord.Embed(title=f'**STATUS CHANGED**', description=\"Your listening status has been set to **'\" + message + \"'**\", color=color)\n            em.set_footer(text=footer)\n            await ctx.send(embed=em, delete_after=deletetimer)\n        except Exception as error:\n            errorprint(\"Exception ' {0} ', expected error message sent to users chat\".format(error))\n            em = discord.Embed(title='Exception Error:', description='Expected Exception: You already have a custom status. \\n Console Exception {0}'.format(error), color=errorcolor)\n            await ctx.send(embed=em, delete_after=deletetimer)", "fn_id": 78, "class_fn": false, "repo": "Flairings/Project-Mars", "file": "Mars.py", "last_update_at": "2021-09-18T03:13:13+00:00", "original_content": "@bot.command()\nasync def listening(ctx, *, message=None):\n    await ctx.message.delete()\n    if message is None:\n        commandprint(\"Command 'listening' has been used by \" + bot.user.name + ' with no message')\n        embed = discord.Embed(title=f'**Invalid syntax**', description='You have not specified a listening \\nExample: ' + prefix + 'listening flairings piss', color=errorcolor)\n        embed.set_footer(text=footer)\n        await ctx.send(embed=embed, delete_after=deletetimer)\n    else:\n        try:\n            commandprint(\"Command 'listening' has been used by \" + bot.user.name + \" with a message of '\" + message + \"'\")\n            await bot.change_presence(activity=discord.Activity(type=discord.ActivityType.listening, name=message))\n            em = discord.Embed(title=f'**STATUS CHANGED**', description=\"Your listening status has been set to **'\" + message + \"'**\", color=color)\n            em.set_footer(text=footer)\n            await ctx.send(embed=em, delete_after=deletetimer)\n        except Exception as error:\n            errorprint(\"Exception ' {0} ', expected error message sent to users chat\".format(error))\n            em = discord.Embed(title='Exception Error:', description='Expected Exception: You already have a custom status. \\n Console Exception {0}'.format(error), color=errorcolor)\n            await ctx.send(embed=em, delete_after=deletetimer)", "refactored": true, "pred": {"ppl": 4.709419250488281, "ppl_lower": 5.266974449157715, "ppl/lowercase_ppl": -1.0722083418763413, "ppl/zlib": 0.0027329181640979813, "Min_5.0% Prob": 11.348955313364664, "Min_10.0% Prob": 9.266136076715258, "Min_20.0% Prob": 6.589052869849009, "Min_30.0% Prob": 4.993331397892138, "Min_40.0% Prob": 3.84865729133152, "Min_50.0% Prob": 3.1035747487445944, "Min_60.0% Prob": 2.581944613317751}}
{"hexsha": "d7d3d58fe31aa429507c3843cdedb9be62480884", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef outgoing_message(message):\n    message_label = tk.Label(messages_frame, bg='gray20', fg='snow', text=message, font=('Helvetica', 15))\n    message_label.pack(side=tk.TOP, anchor=tk.E, padx=20, pady=10)\n    message_labels.append(message_label)", "fn_id": 3, "class_fn": false, "repo": "Jothin-kumar/chat-app", "file": "scripts/client/gui.py", "last_update_at": "2021-12-10T13:33:11+00:00", "original_content": "def outgoing_message(message):\n    message_label = tk.Label(messages_frame, bg='gray20', fg='snow', text=message, font=('Helvetica', 15))\n    message_label.pack(side=tk.TOP, anchor=tk.E, padx=20, pady=10)\n    message_labels.append(message_label)", "refactored": true, "pred": {"ppl": 3.931488037109375, "ppl_lower": 5.154341220855713, "ppl/lowercase_ppl": -1.1978215973311725, "ppl/zlib": 0.007360311772116477, "Min_5.0% Prob": 9.898731231689453, "Min_10.0% Prob": 7.449392265743679, "Min_20.0% Prob": 5.442381077342564, "Min_30.0% Prob": 4.149356607879911, "Min_40.0% Prob": 3.3459137484834, "Min_50.0% Prob": 2.70404866591413, "Min_60.0% Prob": 2.2884356513885513}}
{"hexsha": "82966286972b9d3c71d206d1668d569e596aeedd", "ext": "py", "lang": "Python", "content": "@require_context\n@timeing\n@measure_memory_usage\ndef quota_class_get_all_by_name(context, class_name):\n    authorize_quota_class_context(context, class_name)\n    rows = model_query(context, models.QuotaClass, read_deleted='no').filter_by(class_name=class_name).all()\n    result = {'class_name': class_name}\n    for row in rows:\n        result[row.resource] = row.hard_limit\n    return result", "fn_id": 105, "class_fn": false, "repo": "scottwedge/OpenStack-Stein", "file": "karbor-1.3.0/karbor/db/sqlalchemy/api.py", "last_update_at": "2021-12-13T20:01:25+00:00", "original_content": "@require_context\ndef quota_class_get_all_by_name(context, class_name):\n    authorize_quota_class_context(context, class_name)\n    rows = model_query(context, models.QuotaClass, read_deleted='no').filter_by(class_name=class_name).all()\n    result = {'class_name': class_name}\n    for row in rows:\n        result[row.resource] = row.hard_limit\n    return result", "refactored": true, "pred": {"ppl": 2.89294171333313, "ppl_lower": 3.237157106399536, "ppl/lowercase_ppl": -1.105831115988392, "ppl/zlib": 0.004806669132617809, "Min_5.0% Prob": 9.302379035949707, "Min_10.0% Prob": 7.1224421154369, "Min_20.0% Prob": 4.713798813197924, "Min_30.0% Prob": 3.446962685244424, "Min_40.0% Prob": 2.682806685242964, "Min_50.0% Prob": 2.1386698317425004, "Min_60.0% Prob": 1.7746039344197406}}
{"hexsha": "8c0c41d89d485b342b3470a122b1a94215a4cc9f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef main():\n    import glob\n    parent = sys.argv[1]\n    folders = glob.glob('{}/*_output'.format(parent))\n    submit_qsub(parent, folders)", "fn_id": 1, "class_fn": false, "repo": "ckrivacic/helix_matcher", "file": "helix/rifdock/submit_align.py", "last_update_at": "2021-06-07T10:56:37+00:00", "original_content": "def main():\n    import glob\n    parent = sys.argv[1]\n    folders = glob.glob('{}/*_output'.format(parent))\n    submit_qsub(parent, folders)", "refactored": true, "pred": {"ppl": 7.5626397132873535, "ppl_lower": 7.5626397132873535, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.014768031369858296, "Min_5.0% Prob": 11.629161834716797, "Min_10.0% Prob": 9.124632930755615, "Min_20.0% Prob": 7.23310694694519, "Min_30.0% Prob": 6.058258930842082, "Min_40.0% Prob": 4.9382057130336765, "Min_50.0% Prob": 4.003751303553582, "Min_60.0% Prob": 3.3546408511698247}}
{"hexsha": "f32dd5e74bf9879ee46da2157293834813f6746b", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _get_package_bin_dir_app_paths(venv: Venv, package_info: PackageInfo, local_bin_dir: Path) -> Set[Path]:\n    suffix = package_info.suffix\n    apps = []\n    if package_info.include_apps:\n        apps += package_info.apps\n    if package_info.include_dependencies:\n        apps += package_info.apps_of_dependencies\n    return get_exposed_app_paths_for_package(venv.bin_path, local_bin_dir, [add_suffix(app, suffix) for app in apps])", "fn_id": 1, "class_fn": false, "repo": "KenMacD/pipx", "file": "src/pipx/commands/uninstall.py", "last_update_at": "2021-05-27T02:34:20+00:00", "original_content": "def _get_package_bin_dir_app_paths(venv: Venv, package_info: PackageInfo, local_bin_dir: Path) -> Set[Path]:\n    suffix = package_info.suffix\n    apps = []\n    if package_info.include_apps:\n        apps += package_info.apps\n    if package_info.include_dependencies:\n        apps += package_info.apps_of_dependencies\n    return get_exposed_app_paths_for_package(venv.bin_path, local_bin_dir, [add_suffix(app, suffix) for app in apps])", "refactored": true, "pred": {"ppl": 5.400412559509277, "ppl_lower": 6.929030895233154, "ppl/lowercase_ppl": -1.1477902483551694, "ppl/zlib": 0.007176490853451191, "Min_5.0% Prob": 9.774995395115443, "Min_10.0% Prob": 8.34292653628758, "Min_20.0% Prob": 6.579572635037558, "Min_30.0% Prob": 5.240266201041994, "Min_40.0% Prob": 4.165743010384696, "Min_50.0% Prob": 3.351720901861997, "Min_60.0% Prob": 2.813080705307862}}
{"hexsha": "c039023785903aca6301e71b8b73beaa059d6ec4", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef duplicateGroup(id):\n    group = CreatureGroup.objects.get(id=id)\n    newGroup = CreatureGroup(name='%s_duplicate' % group.name, Augmented=group.Augmented)\n    newGroup.Grouping = group.Grouping\n    newGroup.save()\n    for item in group.AllowedExtraType.all():\n        newGroup.AllowedExtraType.add(item)\n    for item in group.DefaultExtraType.all():\n        newGroup.DefaultExtraType.add(item)\n    for item in group.groupentry_set.all():\n        GroupEntry(Group=newGroup, creature=item.creature).save()", "fn_id": 1, "class_fn": false, "repo": "mkarasch/pfss", "file": "pfss/models.py", "last_update_at": "2021-09-14T09:55:03+00:00", "original_content": "def duplicateGroup(id):\n    group = CreatureGroup.objects.get(id=id)\n    newGroup = CreatureGroup(name='%s_duplicate' % group.name, Augmented=group.Augmented)\n    newGroup.Grouping = group.Grouping\n    newGroup.save()\n    for item in group.AllowedExtraType.all():\n        newGroup.AllowedExtraType.add(item)\n    for item in group.DefaultExtraType.all():\n        newGroup.DefaultExtraType.add(item)\n    for item in group.groupentry_set.all():\n        GroupEntry(Group=newGroup, creature=item.creature).save()", "refactored": true, "pred": {"ppl": 4.405577182769775, "ppl_lower": 3.708667039871216, "ppl/lowercase_ppl": -0.8838747782498794, "ppl/zlib": 0.006256840843081084, "Min_5.0% Prob": 15.189882414681572, "Min_10.0% Prob": 11.149236583709717, "Min_20.0% Prob": 7.152205351988474, "Min_30.0% Prob": 4.989758084217708, "Min_40.0% Prob": 3.712243766875052, "Min_50.0% Prob": 2.9843257937923466, "Min_60.0% Prob": 2.493030117604636}}
{"hexsha": "21093aba0c887e3f2abc8c2d98ef2ec29048b249", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef time_stamps(seconds, sample_rate, sample_length, sample_duration):\n    \"\"\"Process to calculate the intervals based on the window size or time intervals.\n    Parameters\n    ----------\n    seconds : int or list\n        Can be of two types. int; a single value that determines the window size (seconds). list; a set of intervals, where each value is in (seconds).\n    sample_rate : float\n        Sample frequency used in the EEG (Hz).\n    sample_length : float\n        Sample length in data points (seconds x sample frequency).\n    sample_duration : float\n        Duration of the EEG (seconds).\n    \n    Returns\n    -------\n    intervals : list\n        List with the intervals, pairs of (Start, End) values in data points (seconds x sample frequency).\n    \"\"\"\n    intervals, i, flag = ([], 0, 0)\n    if type(seconds) == list:\n        if len(seconds) == 1:\n            seconds = seconds[0]\n        else:\n            if seconds[-1] > sample_duration.round():\n                raise Exception('Error in Window size. Intervals exceeds sample length.')\n            if seconds[0] != 0:\n                raise Exception('Error in Window size. First interval must be 0.')\n            else:\n                diff = np.diff(seconds)\n                for j, value in enumerate(diff):\n                    samples_per_frame = value * sample_rate\n                    intervals.append((i, i + samples_per_frame))\n                    i += samples_per_frame\n    if type(seconds) == int or type(seconds) == float:\n        samples_per_frame = seconds * sample_rate\n        while i + samples_per_frame <= sample_length:\n            intervals.append((i, i + samples_per_frame))\n            i = i + samples_per_frame\n        if i + samples_per_frame > sample_length:\n            intervals.append((i, sample_length))\n    intervals_rounded = [(round(steps[0], 2), round(steps[1], 2)) for steps in intervals]\n    print('Intervals: ', intervals_rounded)\n    if len(intervals) == 1:\n        intervals.append((0, sample_rate))\n        flag = 1\n    return (intervals, flag)", "fn_id": 5, "class_fn": false, "repo": "danive97/EEGRAPH", "file": "eegraph/tools.py", "last_update_at": "2021-03-26T09:28:21+00:00", "original_content": "def time_stamps(seconds, sample_rate, sample_length, sample_duration):\n    \"\"\"Process to calculate the intervals based on the window size or time intervals.\n    Parameters\n    ----------\n    seconds : int or list\n        Can be of two types. int; a single value that determines the window size (seconds). list; a set of intervals, where each value is in (seconds).\n    sample_rate : float\n        Sample frequency used in the EEG (Hz).\n    sample_length : float\n        Sample length in data points (seconds x sample frequency).\n    sample_duration : float\n        Duration of the EEG (seconds).\n    \n    Returns\n    -------\n    intervals : list\n        List with the intervals, pairs of (Start, End) values in data points (seconds x sample frequency).\n    \"\"\"\n    intervals, i, flag = ([], 0, 0)\n    if type(seconds) == list:\n        if len(seconds) == 1:\n            seconds = seconds[0]\n        else:\n            if seconds[-1] > sample_duration.round():\n                raise Exception('Error in Window size. Intervals exceeds sample length.')\n            if seconds[0] != 0:\n                raise Exception('Error in Window size. First interval must be 0.')\n            else:\n                diff = np.diff(seconds)\n                for j, value in enumerate(diff):\n                    samples_per_frame = value * sample_rate\n                    intervals.append((i, i + samples_per_frame))\n                    i += samples_per_frame\n    if type(seconds) == int or type(seconds) == float:\n        samples_per_frame = seconds * sample_rate\n        while i + samples_per_frame <= sample_length:\n            intervals.append((i, i + samples_per_frame))\n            i = i + samples_per_frame\n        if i + samples_per_frame > sample_length:\n            intervals.append((i, sample_length))\n    intervals_rounded = [(round(steps[0], 2), round(steps[1], 2)) for steps in intervals]\n    print('Intervals: ', intervals_rounded)\n    if len(intervals) == 1:\n        intervals.append((0, sample_rate))\n        flag = 1\n    return (intervals, flag)", "refactored": true, "pred": {"ppl": 4.135180473327637, "ppl_lower": 4.230832576751709, "ppl/lowercase_ppl": -1.01610942484328, "ppl/zlib": 0.002013519110391718, "Min_5.0% Prob": 9.750504990418753, "Min_10.0% Prob": 7.763937638730419, "Min_20.0% Prob": 5.730855773906319, "Min_30.0% Prob": 4.46500669450176, "Min_40.0% Prob": 3.5033431139391693, "Min_50.0% Prob": 2.835478764027357, "Min_60.0% Prob": 2.370541346003696}}
{"hexsha": "df37bb46962a858756a40ea08c445056a8eba2a4", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef config_to_functions(config):\n    \"\"\"\n    Takes in the data for a config and returns a list of functions to call the meet it's criteria.\n    list of str -> list of (none -> (str, any))\n    \"\"\"\n    functions = []\n    in_multiline_comment = False\n    for line in config:\n        line = remove_new_lines(line)\n        in_multiline_comment = in_multiline_comment or line_starts_multiline_comment_start(line)\n        multiline_comment_end = line_starts_multiline_comment_end(line)\n        if not in_multiline_comment and multiline_comment_end:\n            message = 'Multiline comment end: ' + constants.MULTILINE_COMMENT_END\n            message += ' must inclose a comment.'\n            raise Exception(message)\n        if multiline_comment_end:\n            in_multiline_comment = False\n        if is_line_commented(line) or is_empty_line(line) or in_multiline_comment or multiline_comment_end:\n            continue\n        check_config_line(line)\n        command_type = get_command_type(line)\n        if not is_type(command_type) and (not is_complex_type(command_type)):\n            on_not_valid_type(command_type)\n        definition = get_command_definition(line)\n        functions.append(build_input_func(any_type_to_input_functions(command_type, definition), command_type))\n    if in_multiline_comment:\n        message = 'Multiline comment start: ' + constants.MULTILINE_COMMENT_START\n        message += ' must be inclosed with: ' + constants.MULTILINE_COMMENT_END\n        raise Exception(message)\n    return functions", "fn_id": 1, "class_fn": false, "repo": "FroshTheFrog/life_logger", "file": "config_utils.py", "last_update_at": "2021-03-19T03:40:42+00:00", "original_content": "def config_to_functions(config):\n    \"\"\"\n    Takes in the data for a config and returns a list of functions to call the meet it's criteria.\n    list of str -> list of (none -> (str, any))\n    \"\"\"\n    functions = []\n    in_multiline_comment = False\n    for line in config:\n        line = remove_new_lines(line)\n        in_multiline_comment = in_multiline_comment or line_starts_multiline_comment_start(line)\n        multiline_comment_end = line_starts_multiline_comment_end(line)\n        if not in_multiline_comment and multiline_comment_end:\n            message = 'Multiline comment end: ' + constants.MULTILINE_COMMENT_END\n            message += ' must inclose a comment.'\n            raise Exception(message)\n        if multiline_comment_end:\n            in_multiline_comment = False\n        if is_line_commented(line) or is_empty_line(line) or in_multiline_comment or multiline_comment_end:\n            continue\n        check_config_line(line)\n        command_type = get_command_type(line)\n        if not is_type(command_type) and (not is_complex_type(command_type)):\n            on_not_valid_type(command_type)\n        definition = get_command_definition(line)\n        functions.append(build_input_func(any_type_to_input_functions(command_type, definition), command_type))\n    if in_multiline_comment:\n        message = 'Multiline comment start: ' + constants.MULTILINE_COMMENT_START\n        message += ' must be inclosed with: ' + constants.MULTILINE_COMMENT_END\n        raise Exception(message)\n    return functions", "refactored": true, "pred": {"ppl": 4.831942558288574, "ppl_lower": 5.2464919090271, "ppl/lowercase_ppl": -1.0522527517752807, "ppl/zlib": 0.002949903694364137, "Min_5.0% Prob": 11.346818876266479, "Min_10.0% Prob": 9.384375441074372, "Min_20.0% Prob": 6.780620267987251, "Min_30.0% Prob": 5.073343563079834, "Min_40.0% Prob": 3.9067083887802148, "Min_50.0% Prob": 3.1522155856500516, "Min_60.0% Prob": 2.6333341129139622}}
{"hexsha": "4fbd04e883334dd6fb994cd9cbab874f5c4a5931", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef load_spectrum(filename, grid):\n    \"\"\"\n    Load a single spectrum\n    \"\"\"\n    file_in = pyfits.open(filename)\n    wl = np.array(file_in[0].data[2])\n    flux = np.array(file_in[0].data[0])\n    ivar = np.array(file_in[0].data[1])\n    redshift = file_in[0].header['Z']\n    wl_shifted = wl - redshift * wl\n    flux_rs = interpolate.interp1d(wl_shifted, flux)(grid)\n    ivar_rs = interpolate.interp1d(wl_shifted, ivar)(grid)\n    ivar_rs[ivar_rs < 0] = 0.0\n    return (flux_rs, ivar_rs)", "fn_id": 1, "class_fn": false, "repo": "HaifengWangNAOC/Cannon", "file": "TheCannon/lamost.py", "last_update_at": "2021-07-22T12:57:40+00:00", "original_content": "def load_spectrum(filename, grid):\n    \"\"\"\n    Load a single spectrum\n    \"\"\"\n    file_in = pyfits.open(filename)\n    wl = np.array(file_in[0].data[2])\n    flux = np.array(file_in[0].data[0])\n    ivar = np.array(file_in[0].data[1])\n    redshift = file_in[0].header['Z']\n    wl_shifted = wl - redshift * wl\n    flux_rs = interpolate.interp1d(wl_shifted, flux)(grid)\n    ivar_rs = interpolate.interp1d(wl_shifted, ivar)(grid)\n    ivar_rs[ivar_rs < 0] = 0.0\n    return (flux_rs, ivar_rs)", "refactored": true, "pred": {"ppl": 2.753448724746704, "ppl_lower": 2.8238413333892822, "ppl/lowercase_ppl": -1.0249235527672997, "ppl/zlib": 0.004134098806942404, "Min_5.0% Prob": 8.024892859988743, "Min_10.0% Prob": 6.595165051912007, "Min_20.0% Prob": 4.613602377866444, "Min_30.0% Prob": 3.303122792850461, "Min_40.0% Prob": 2.51836000029978, "Min_50.0% Prob": 2.023538544813269, "Min_60.0% Prob": 1.68774782619725}}
{"hexsha": "60a398f13b9ba05c02fed5b550c7fed93451f969", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef serializedATN():\n    with StringIO() as buf:\n        buf.write('\\x03\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\\x03\\x1a')\n        buf.write('\\x82\\x04\\x02\\t\\x02\\x04\\x03\\t\\x03\\x04\\x04\\t\\x04\\x04\\x05\\t\\x05\\x04\\x06\\t\\x06\\x04\\x07\\t\\x07')\n        buf.write('\\x04\\x08\\t\\x08\\x04\\t\\t\\t\\x04\\n\\t\\n\\x04\\x0b\\t\\x0b\\x04\\x0c\\t\\x0c\\x04\\r\\t\\r\\x04\\x0e')\n        buf.write('\\t\\x0e\\x04\\x0f\\t\\x0f\\x03\\x02\\x05\\x02 \\n\\x02\\x03\\x02\\x03\\x02\\x05\\x02$\\n\\x02\\x03\\x02\\x03\\x02')\n        buf.write('\\x03\\x02\\x03\\x02\\x03\\x03\\x03\\x03\\x05\\x03,\\n\\x03\\x07\\x03.\\n\\x03\\x0c\\x03\\x0e\\x031\\x0b\\x03\\x03')\n        buf.write('\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x05\\x04;\\n\\x04\\x03\\x05\\x03\\x05\\x03\\x05\\x03')\n        buf.write('\\x06\\x03\\x06\\x05\\x06B\\n\\x06\\x03\\x06\\x06\\x06E\\n\\x06\\r\\x06\\x0e\\x06F\\x03\\x07\\x03\\x07\\x03\\x07\\x05\\x07')\n        buf.write('L\\n\\x07\\x03\\x07\\x05\\x07O\\n\\x07\\x06\\x07Q\\n\\x07\\r\\x07\\x0e\\x07R\\x03\\x08\\x03\\x08\\x05\\x08W\\n\\x08')\n        buf.write('\\x03\\x08\\x03\\x08\\x05\\x08[\\n\\x08\\x03\\t\\x03\\t\\x03\\t\\x05\\t`\\n\\t\\x06\\tb\\n\\t\\r\\t\\x0e')\n        buf.write('\\tc\\x03\\n\\x03\\n\\x03\\x0b\\x03\\x0b\\x05\\x0bj\\n\\x0b\\x03\\x0c\\x03\\x0c\\x05\\x0cn\\n\\x0c\\x03\\r')\n        buf.write('\\x03\\r\\x03\\r\\x03\\r\\x05\\rt\\n\\r\\x03\\x0e\\x03\\x0e\\x05\\x0ex\\n\\x0e\\x05\\x0ez\\n\\x0e')\n        buf.write('\\x03\\x0e\\x03\\x0e\\x03\\x0e\\x03\\x0e\\x03\\x0f\\x03\\x0f\\x03\\x0f\\x02\\x02\\x10\\x02\\x04\\x06\\x08\\n\\x0c')\n        buf.write('\\x0e\\x10\\x12\\x14\\x16\\x18\\x1a\\x1c\\x02\\x06\\x03\\x02\\x0e\\x0f\\x04\\x02\\x0e\\x0e\\x10\\x11')\n        buf.write('\\x03\\x02\\n\\x0b\\x03\\x02\\x13\\x16\\x02\\x89\\x02\\x1f\\x03\\x02\\x02\\x02\\x04/\\x03\\x02\\x02\\x02\\x06')\n        buf.write(':\\x03\\x02\\x02\\x02\\x08<\\x03\\x02\\x02\\x02\\nD\\x03\\x02\\x02\\x02\\x0cP\\x03\\x02\\x02\\x02\\x0eV\\x03\\x02\\x02\\x02')\n        buf.write('\\x10a\\x03\\x02\\x02\\x02\\x12e\\x03\\x02\\x02\\x02\\x14g\\x03\\x02\\x02\\x02\\x16k\\x03\\x02\\x02\\x02\\x18o\\x03')\n        buf.write('\\x02\\x02\\x02\\x1ay\\x03\\x02\\x02\\x02\\x1c\\x7f\\x03\\x02\\x02\\x02\\x1e \\x07\\r\\x02\\x02\\x1f\\x1e\\x03')\n        buf.write('\\x02\\x02\\x02\\x1f \\x03\\x02\\x02\\x02 !\\x03\\x02\\x02\\x02!#\\t\\x02\\x02\\x02\"$\\x05\\x1c\\x0f\\x02#\"')\n        buf.write(\"\\x03\\x02\\x02\\x02#$\\x03\\x02\\x02\\x02$%\\x03\\x02\\x02\\x02%&\\x07\\x03\\x02\\x02&'\\x05\\x04\\x03\\x02'(\\x07\")\n        buf.write('\\x04\\x02\\x02(\\x03\\x03\\x02\\x02\\x02)+\\x05\\x06\\x04\\x02*,\\x07\\x05\\x02\\x02+*\\x03\\x02\\x02\\x02+,\\x03\\x02')\n        buf.write('\\x02\\x02,.\\x03\\x02\\x02\\x02-)\\x03\\x02\\x02\\x02.1\\x03\\x02\\x02\\x02/-\\x03\\x02\\x02\\x02/0\\x03\\x02')\n        buf.write('\\x02\\x020\\x05\\x03\\x02\\x02\\x021/\\x03\\x02\\x02\\x022;\\x05\\x14\\x0b\\x023;\\x05\\x0e\\x08')\n        buf.write('\\x024;\\x05\\x08\\x05\\x0256\\x05\\x1c\\x0f\\x0267\\x07\\x06\\x02\\x0278\\x05\\x1c')\n        buf.write('\\x0f\\x028;\\x03\\x02\\x02\\x029;\\x05\\x1a\\x0e\\x02:2\\x03\\x02\\x02\\x02:3\\x03\\x02\\x02\\x02:4')\n        buf.write('\\x03\\x02\\x02\\x02:5\\x03\\x02\\x02\\x02:9\\x03\\x02\\x02\\x02;\\x07\\x03\\x02\\x02\\x02<=\\t\\x03\\x02\\x02=>')\n        buf.write('\\x05\\n\\x06\\x02>\\t\\x03\\x02\\x02\\x02?A\\x07\\x07\\x02\\x02@B\\x05\\x0c\\x07\\x02A@\\x03\\x02\\x02\\x02AB\\x03')\n        buf.write('\\x02\\x02\\x02BC\\x03\\x02\\x02\\x02CE\\x07\\x08\\x02\\x02D?\\x03\\x02\\x02\\x02EF\\x03\\x02\\x02\\x02FD\\x03\\x02\\x02')\n        buf.write('\\x02FG\\x03\\x02\\x02\\x02G\\x0b\\x03\\x02\\x02\\x02HK\\x05\\x1c\\x0f\\x02IJ\\x07\\x06\\x02\\x02JL\\x05\\x1c')\n        buf.write('\\x0f\\x02KI\\x03\\x02\\x02\\x02KL\\x03\\x02\\x02\\x02LN\\x03\\x02\\x02\\x02MO\\x07\\t\\x02\\x02NM\\x03\\x02\\x02')\n        buf.write('\\x02NO\\x03\\x02\\x02\\x02OQ\\x03\\x02\\x02\\x02PH\\x03\\x02\\x02\\x02QR\\x03\\x02\\x02\\x02RP\\x03\\x02\\x02\\x02R')\n        buf.write('S\\x03\\x02\\x02\\x02S\\r\\x03\\x02\\x02\\x02TW\\x05\\x16\\x0c\\x02UW\\x05\\x1a\\x0e\\x02VT\\x03\\x02\\x02\\x02')\n        buf.write('VU\\x03\\x02\\x02\\x02WX\\x03\\x02\\x02\\x02XZ\\x05\\x10\\t\\x02Y[\\x05\\n\\x06\\x02ZY\\x03\\x02\\x02\\x02Z[')\n        buf.write('\\x03\\x02\\x02\\x02[\\x0f\\x03\\x02\\x02\\x02\\\\_\\x05\\x12\\n\\x02]`\\x05\\x16\\x0c\\x02^`\\x05\\x1a\\x0e')\n        buf.write('\\x02_]\\x03\\x02\\x02\\x02_^\\x03\\x02\\x02\\x02`b\\x03\\x02\\x02\\x02a\\\\\\x03\\x02\\x02\\x02bc\\x03\\x02\\x02\\x02')\n        buf.write('ca\\x03\\x02\\x02\\x02cd\\x03\\x02\\x02\\x02d\\x11\\x03\\x02\\x02\\x02ef\\t\\x04\\x02\\x02f\\x13\\x03\\x02\\x02\\x02')\n        buf.write('gi\\x05\\x16\\x0c\\x02hj\\x05\\n\\x06\\x02ih\\x03\\x02\\x02\\x02ij\\x03\\x02\\x02\\x02j\\x15\\x03\\x02\\x02\\x02')\n        buf.write('km\\x05\\x1c\\x0f\\x02ln\\x05\\x18\\r\\x02ml\\x03\\x02\\x02\\x02mn\\x03\\x02\\x02\\x02n\\x17\\x03\\x02\\x02')\n        buf.write('\\x02op\\x07\\x0c\\x02\\x02ps\\x05\\x1c\\x0f\\x02qr\\x07\\x0c\\x02\\x02rt\\x05\\x1c\\x0f\\x02sq\\x03\\x02\\x02')\n        buf.write('\\x02st\\x03\\x02\\x02\\x02t\\x19\\x03\\x02\\x02\\x02uw\\x07\\x12\\x02\\x02vx\\x05\\x1c\\x0f\\x02wv\\x03\\x02')\n        buf.write('\\x02\\x02wx\\x03\\x02\\x02\\x02xz\\x03\\x02\\x02\\x02yu\\x03\\x02\\x02\\x02yz\\x03\\x02\\x02\\x02z{\\x03\\x02\\x02\\x02')\n        buf.write('{|\\x07\\x03\\x02\\x02|}\\x05\\x04\\x03\\x02}~\\x07\\x04\\x02\\x02~\\x1b\\x03\\x02\\x02\\x02\\x7f\\x80\\t')\n        buf.write('\\x05\\x02\\x02\\x80\\x1d\\x03\\x02\\x02\\x02\\x15\\x1f#+/:AFKNRVZ_cimswy')\n        return buf.getvalue()", "fn_id": 0, "class_fn": false, "repo": "qwang70/GraphVizDotToDatabaseParsing", "file": "script/DOTParser.py", "last_update_at": "2021-08-13T04:55:13+00:00", "original_content": "def serializedATN():\n    with StringIO() as buf:\n        buf.write('\\x03\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\\x03\\x1a')\n        buf.write('\\x82\\x04\\x02\\t\\x02\\x04\\x03\\t\\x03\\x04\\x04\\t\\x04\\x04\\x05\\t\\x05\\x04\\x06\\t\\x06\\x04\\x07\\t\\x07')\n        buf.write('\\x04\\x08\\t\\x08\\x04\\t\\t\\t\\x04\\n\\t\\n\\x04\\x0b\\t\\x0b\\x04\\x0c\\t\\x0c\\x04\\r\\t\\r\\x04\\x0e')\n        buf.write('\\t\\x0e\\x04\\x0f\\t\\x0f\\x03\\x02\\x05\\x02 \\n\\x02\\x03\\x02\\x03\\x02\\x05\\x02$\\n\\x02\\x03\\x02\\x03\\x02')\n        buf.write('\\x03\\x02\\x03\\x02\\x03\\x03\\x03\\x03\\x05\\x03,\\n\\x03\\x07\\x03.\\n\\x03\\x0c\\x03\\x0e\\x031\\x0b\\x03\\x03')\n        buf.write('\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x05\\x04;\\n\\x04\\x03\\x05\\x03\\x05\\x03\\x05\\x03')\n        buf.write('\\x06\\x03\\x06\\x05\\x06B\\n\\x06\\x03\\x06\\x06\\x06E\\n\\x06\\r\\x06\\x0e\\x06F\\x03\\x07\\x03\\x07\\x03\\x07\\x05\\x07')\n        buf.write('L\\n\\x07\\x03\\x07\\x05\\x07O\\n\\x07\\x06\\x07Q\\n\\x07\\r\\x07\\x0e\\x07R\\x03\\x08\\x03\\x08\\x05\\x08W\\n\\x08')\n        buf.write('\\x03\\x08\\x03\\x08\\x05\\x08[\\n\\x08\\x03\\t\\x03\\t\\x03\\t\\x05\\t`\\n\\t\\x06\\tb\\n\\t\\r\\t\\x0e')\n        buf.write('\\tc\\x03\\n\\x03\\n\\x03\\x0b\\x03\\x0b\\x05\\x0bj\\n\\x0b\\x03\\x0c\\x03\\x0c\\x05\\x0cn\\n\\x0c\\x03\\r')\n        buf.write('\\x03\\r\\x03\\r\\x03\\r\\x05\\rt\\n\\r\\x03\\x0e\\x03\\x0e\\x05\\x0ex\\n\\x0e\\x05\\x0ez\\n\\x0e')\n        buf.write('\\x03\\x0e\\x03\\x0e\\x03\\x0e\\x03\\x0e\\x03\\x0f\\x03\\x0f\\x03\\x0f\\x02\\x02\\x10\\x02\\x04\\x06\\x08\\n\\x0c')\n        buf.write('\\x0e\\x10\\x12\\x14\\x16\\x18\\x1a\\x1c\\x02\\x06\\x03\\x02\\x0e\\x0f\\x04\\x02\\x0e\\x0e\\x10\\x11')\n        buf.write('\\x03\\x02\\n\\x0b\\x03\\x02\\x13\\x16\\x02\\x89\\x02\\x1f\\x03\\x02\\x02\\x02\\x04/\\x03\\x02\\x02\\x02\\x06')\n        buf.write(':\\x03\\x02\\x02\\x02\\x08<\\x03\\x02\\x02\\x02\\nD\\x03\\x02\\x02\\x02\\x0cP\\x03\\x02\\x02\\x02\\x0eV\\x03\\x02\\x02\\x02')\n        buf.write('\\x10a\\x03\\x02\\x02\\x02\\x12e\\x03\\x02\\x02\\x02\\x14g\\x03\\x02\\x02\\x02\\x16k\\x03\\x02\\x02\\x02\\x18o\\x03')\n        buf.write('\\x02\\x02\\x02\\x1ay\\x03\\x02\\x02\\x02\\x1c\\x7f\\x03\\x02\\x02\\x02\\x1e \\x07\\r\\x02\\x02\\x1f\\x1e\\x03')\n        buf.write('\\x02\\x02\\x02\\x1f \\x03\\x02\\x02\\x02 !\\x03\\x02\\x02\\x02!#\\t\\x02\\x02\\x02\"$\\x05\\x1c\\x0f\\x02#\"')\n        buf.write(\"\\x03\\x02\\x02\\x02#$\\x03\\x02\\x02\\x02$%\\x03\\x02\\x02\\x02%&\\x07\\x03\\x02\\x02&'\\x05\\x04\\x03\\x02'(\\x07\")\n        buf.write('\\x04\\x02\\x02(\\x03\\x03\\x02\\x02\\x02)+\\x05\\x06\\x04\\x02*,\\x07\\x05\\x02\\x02+*\\x03\\x02\\x02\\x02+,\\x03\\x02')\n        buf.write('\\x02\\x02,.\\x03\\x02\\x02\\x02-)\\x03\\x02\\x02\\x02.1\\x03\\x02\\x02\\x02/-\\x03\\x02\\x02\\x02/0\\x03\\x02')\n        buf.write('\\x02\\x020\\x05\\x03\\x02\\x02\\x021/\\x03\\x02\\x02\\x022;\\x05\\x14\\x0b\\x023;\\x05\\x0e\\x08')\n        buf.write('\\x024;\\x05\\x08\\x05\\x0256\\x05\\x1c\\x0f\\x0267\\x07\\x06\\x02\\x0278\\x05\\x1c')\n        buf.write('\\x0f\\x028;\\x03\\x02\\x02\\x029;\\x05\\x1a\\x0e\\x02:2\\x03\\x02\\x02\\x02:3\\x03\\x02\\x02\\x02:4')\n        buf.write('\\x03\\x02\\x02\\x02:5\\x03\\x02\\x02\\x02:9\\x03\\x02\\x02\\x02;\\x07\\x03\\x02\\x02\\x02<=\\t\\x03\\x02\\x02=>')\n        buf.write('\\x05\\n\\x06\\x02>\\t\\x03\\x02\\x02\\x02?A\\x07\\x07\\x02\\x02@B\\x05\\x0c\\x07\\x02A@\\x03\\x02\\x02\\x02AB\\x03')\n        buf.write('\\x02\\x02\\x02BC\\x03\\x02\\x02\\x02CE\\x07\\x08\\x02\\x02D?\\x03\\x02\\x02\\x02EF\\x03\\x02\\x02\\x02FD\\x03\\x02\\x02')\n        buf.write('\\x02FG\\x03\\x02\\x02\\x02G\\x0b\\x03\\x02\\x02\\x02HK\\x05\\x1c\\x0f\\x02IJ\\x07\\x06\\x02\\x02JL\\x05\\x1c')\n        buf.write('\\x0f\\x02KI\\x03\\x02\\x02\\x02KL\\x03\\x02\\x02\\x02LN\\x03\\x02\\x02\\x02MO\\x07\\t\\x02\\x02NM\\x03\\x02\\x02')\n        buf.write('\\x02NO\\x03\\x02\\x02\\x02OQ\\x03\\x02\\x02\\x02PH\\x03\\x02\\x02\\x02QR\\x03\\x02\\x02\\x02RP\\x03\\x02\\x02\\x02R')\n        buf.write('S\\x03\\x02\\x02\\x02S\\r\\x03\\x02\\x02\\x02TW\\x05\\x16\\x0c\\x02UW\\x05\\x1a\\x0e\\x02VT\\x03\\x02\\x02\\x02')\n        buf.write('VU\\x03\\x02\\x02\\x02WX\\x03\\x02\\x02\\x02XZ\\x05\\x10\\t\\x02Y[\\x05\\n\\x06\\x02ZY\\x03\\x02\\x02\\x02Z[')\n        buf.write('\\x03\\x02\\x02\\x02[\\x0f\\x03\\x02\\x02\\x02\\\\_\\x05\\x12\\n\\x02]`\\x05\\x16\\x0c\\x02^`\\x05\\x1a\\x0e')\n        buf.write('\\x02_]\\x03\\x02\\x02\\x02_^\\x03\\x02\\x02\\x02`b\\x03\\x02\\x02\\x02a\\\\\\x03\\x02\\x02\\x02bc\\x03\\x02\\x02\\x02')\n        buf.write('ca\\x03\\x02\\x02\\x02cd\\x03\\x02\\x02\\x02d\\x11\\x03\\x02\\x02\\x02ef\\t\\x04\\x02\\x02f\\x13\\x03\\x02\\x02\\x02')\n        buf.write('gi\\x05\\x16\\x0c\\x02hj\\x05\\n\\x06\\x02ih\\x03\\x02\\x02\\x02ij\\x03\\x02\\x02\\x02j\\x15\\x03\\x02\\x02\\x02')\n        buf.write('km\\x05\\x1c\\x0f\\x02ln\\x05\\x18\\r\\x02ml\\x03\\x02\\x02\\x02mn\\x03\\x02\\x02\\x02n\\x17\\x03\\x02\\x02')\n        buf.write('\\x02op\\x07\\x0c\\x02\\x02ps\\x05\\x1c\\x0f\\x02qr\\x07\\x0c\\x02\\x02rt\\x05\\x1c\\x0f\\x02sq\\x03\\x02\\x02')\n        buf.write('\\x02st\\x03\\x02\\x02\\x02t\\x19\\x03\\x02\\x02\\x02uw\\x07\\x12\\x02\\x02vx\\x05\\x1c\\x0f\\x02wv\\x03\\x02')\n        buf.write('\\x02\\x02wx\\x03\\x02\\x02\\x02xz\\x03\\x02\\x02\\x02yu\\x03\\x02\\x02\\x02yz\\x03\\x02\\x02\\x02z{\\x03\\x02\\x02\\x02')\n        buf.write('{|\\x07\\x03\\x02\\x02|}\\x05\\x04\\x03\\x02}~\\x07\\x04\\x02\\x02~\\x1b\\x03\\x02\\x02\\x02\\x7f\\x80\\t')\n        buf.write('\\x05\\x02\\x02\\x80\\x1d\\x03\\x02\\x02\\x02\\x15\\x1f#+/:AFKNRVZ_cimswy')\n        return buf.getvalue()", "refactored": true, "pred": {"ppl": 1.5498380661010742, "ppl_lower": 1.6618374586105347, "ppl/lowercase_ppl": -1.1592453931600886, "ppl/zlib": 0.0003621078115621842, "Min_5.0% Prob": 5.342167601865881, "Min_10.0% Prob": 3.769435910617604, "Min_20.0% Prob": 2.1435319605265177, "Min_30.0% Prob": 1.4604262081979245, "Min_40.0% Prob": 1.0953105159199508, "Min_50.0% Prob": 0.8770347435762987, "Min_60.0% Prob": 0.7311708149727609}}
{"hexsha": "79b07cf6f3f380f296c7ce80ec1c84c5aa0ae81e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef deep_seq_design():\n    root_dir = f'data/design/cullpdb_val_deep/{exp_flag}anneal_val_deep'\n    mut_matrix_anneal = np.zeros((20, 20))\n    native_aa_all = []\n    design_aa_all = []\n    seq_len = []\n    recovery = []\n    pdb_id_all = []\n    recovery_res = np.zeros(20)\n    count_res = np.zeros(20)\n    num = 100\n    for pdb_id in pdb_selected:\n        seq_best_all = []\n        for j in range(num):\n            data_anneal = h5py.File(f'{root_dir}/{pdb_id}_profile_{j}.h5', 'r')\n            designed_seq = data_anneal['profile'][()]\n            seq_best = designed_seq[1]\n            seq_best_all.append(seq_best)\n            seq_native = designed_seq[0]\n            recovery_fraction = np.sum(seq_best == seq_native) / float(len(seq_native))\n            recovery.append(recovery_fraction)\n            seq_len.append(len(seq_native))\n            pdb_id_all.append(pdb_id)\n            for i in range(seq_native.shape[0]):\n                mut_matrix_anneal[map_aa[seq_native[i]], map_aa[seq_best[i]]] += 1\n                native_aa_all.append(map_aa[seq_native[i]])\n                design_aa_all.append(map_aa[seq_best[i]])\n            for i in range(20):\n                idx = seq_native == i\n                recovery_res[i] += np.sum(seq_best[idx] == seq_native[idx])\n                count_res[i] += len(seq_native[idx])\n        with open(f'{root_dir}/{pdb_id}_seq_best.fasta', 'w') as mf:\n            s = ''.join([idx2aa[x] for x in seq_native])\n            mf.write(f'>0\\n{s}\\n')\n            for j in range(len(seq_best_all)):\n                s = ''.join([idx2aa[x] for x in seq_best_all[j]])\n                mf.write(f'>{j + 1}\\n')\n                mf.write(f'{s}\\n')\n    df = pd.DataFrame({'pdb': pdb_id_all, 'seq_len': seq_len, 'recovery': recovery})\n    df.to_csv(f'{root_dir}/recovery.csv', index=False)\n    np.save(f'data/design/cullpdb_val_deep/{exp_flag}anneal_val_deep/mut_matrix_anneal.npy', mut_matrix_anneal)\n    df = pd.DataFrame({'native_aa': native_aa_all, 'design_aa': design_aa_all})\n    df.to_csv(f'{root_dir}/native_design_aa.csv', index=False)\n    fig = pl.figure()\n    pl.plot(df['seq_len'], df['recovery'], 'bo')\n    pl.title('full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_seqlen_recovery.pdf')\n    fig = pl.figure()\n    pl.hist(df['recovery'], bins=np.arange(10) * 0.05 + 0.05)\n    pl.xlabel('native sequence recovery fraction')\n    pl.ylabel('N')\n    pl.savefig(f'{root_dir}/full_seq_design_recovery_hist.pdf')\n    fig = pl.figure()\n    pl.plot(np.arange(20), recovery_res / count_res)\n    pl.xticks(np.arange(20), labels=aa)\n    pl.title('residue recovery fraction in full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_recovery.pdf')\n    fig = pl.figure()\n    mut_matrix_anneal_freq = mut_matrix_anneal / mut_matrix_anneal.sum(axis=1)[:, None]\n    pl.imshow(mut_matrix_anneal_freq, cmap='jet')\n    pl.xlabel('mutated residue')\n    pl.ylabel('native residue')\n    pl.xticks(np.arange(20), labels=ordered_aa)\n    pl.yticks(np.arange(20), labels=ordered_aa)\n    pl.colorbar()\n    pl.title('full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_use.pdf')\n    fig = pl.figure()\n    res_all = np.concatenate(seq_best_all).flatten()\n    aa_bins = np.arange(21) - 0.5\n    pl.hist(res_all, bins=aa_bins, histtype='step')\n    pl.xticks(np.arange(20), labels=aa)\n    pl.title('residue use frequency')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_use_frequency.pdf')", "fn_id": 2, "class_fn": false, "repo": "lahplover/nnef", "file": "nnef/scripts/designed_seq.py", "last_update_at": "2021-06-30T06:47:00+00:00", "original_content": "def deep_seq_design():\n    root_dir = f'data/design/cullpdb_val_deep/{exp_flag}anneal_val_deep'\n    mut_matrix_anneal = np.zeros((20, 20))\n    native_aa_all = []\n    design_aa_all = []\n    seq_len = []\n    recovery = []\n    pdb_id_all = []\n    recovery_res = np.zeros(20)\n    count_res = np.zeros(20)\n    num = 100\n    for pdb_id in pdb_selected:\n        seq_best_all = []\n        for j in range(num):\n            data_anneal = h5py.File(f'{root_dir}/{pdb_id}_profile_{j}.h5', 'r')\n            designed_seq = data_anneal['profile'][()]\n            seq_best = designed_seq[1]\n            seq_best_all.append(seq_best)\n            seq_native = designed_seq[0]\n            recovery_fraction = np.sum(seq_best == seq_native) / float(len(seq_native))\n            recovery.append(recovery_fraction)\n            seq_len.append(len(seq_native))\n            pdb_id_all.append(pdb_id)\n            for i in range(seq_native.shape[0]):\n                mut_matrix_anneal[map_aa[seq_native[i]], map_aa[seq_best[i]]] += 1\n                native_aa_all.append(map_aa[seq_native[i]])\n                design_aa_all.append(map_aa[seq_best[i]])\n            for i in range(20):\n                idx = seq_native == i\n                recovery_res[i] += np.sum(seq_best[idx] == seq_native[idx])\n                count_res[i] += len(seq_native[idx])\n        with open(f'{root_dir}/{pdb_id}_seq_best.fasta', 'w') as mf:\n            s = ''.join([idx2aa[x] for x in seq_native])\n            mf.write(f'>0\\n{s}\\n')\n            for j in range(len(seq_best_all)):\n                s = ''.join([idx2aa[x] for x in seq_best_all[j]])\n                mf.write(f'>{j + 1}\\n')\n                mf.write(f'{s}\\n')\n    df = pd.DataFrame({'pdb': pdb_id_all, 'seq_len': seq_len, 'recovery': recovery})\n    df.to_csv(f'{root_dir}/recovery.csv', index=False)\n    np.save(f'data/design/cullpdb_val_deep/{exp_flag}anneal_val_deep/mut_matrix_anneal.npy', mut_matrix_anneal)\n    df = pd.DataFrame({'native_aa': native_aa_all, 'design_aa': design_aa_all})\n    df.to_csv(f'{root_dir}/native_design_aa.csv', index=False)\n    fig = pl.figure()\n    pl.plot(df['seq_len'], df['recovery'], 'bo')\n    pl.title('full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_seqlen_recovery.pdf')\n    fig = pl.figure()\n    pl.hist(df['recovery'], bins=np.arange(10) * 0.05 + 0.05)\n    pl.xlabel('native sequence recovery fraction')\n    pl.ylabel('N')\n    pl.savefig(f'{root_dir}/full_seq_design_recovery_hist.pdf')\n    fig = pl.figure()\n    pl.plot(np.arange(20), recovery_res / count_res)\n    pl.xticks(np.arange(20), labels=aa)\n    pl.title('residue recovery fraction in full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_recovery.pdf')\n    fig = pl.figure()\n    mut_matrix_anneal_freq = mut_matrix_anneal / mut_matrix_anneal.sum(axis=1)[:, None]\n    pl.imshow(mut_matrix_anneal_freq, cmap='jet')\n    pl.xlabel('mutated residue')\n    pl.ylabel('native residue')\n    pl.xticks(np.arange(20), labels=ordered_aa)\n    pl.yticks(np.arange(20), labels=ordered_aa)\n    pl.colorbar()\n    pl.title('full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_use.pdf')\n    fig = pl.figure()\n    res_all = np.concatenate(seq_best_all).flatten()\n    aa_bins = np.arange(21) - 0.5\n    pl.hist(res_all, bins=aa_bins, histtype='step')\n    pl.xticks(np.arange(20), labels=aa)\n    pl.title('residue use frequency')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_use_frequency.pdf')", "refactored": true, "pred": {"ppl": 2.4240798950195312, "ppl_lower": 2.5381908416748047, "ppl/lowercase_ppl": -1.051950338469416, "ppl/zlib": 0.0008513961804379377, "Min_5.0% Prob": 8.971189751344568, "Min_10.0% Prob": 6.594556794447057, "Min_20.0% Prob": 4.169946719034045, "Min_30.0% Prob": 2.9246017949935657, "Min_40.0% Prob": 2.2098484225844404, "Min_50.0% Prob": 1.7718908113715424, "Min_60.0% Prob": 1.477570398794039}}
{"hexsha": "1d58be5f8c298cf630d37e7dc4f29b9760416dc5", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef parse_net_xml(doc):\n    total = len(list(doc.getiterator('wireless-network')))\n    tenth = total / 10\n    count = 0\n    clients = list()\n    parsed_list = []\n    for network in doc.getiterator('wireless-network'):\n        count += 1\n        try:\n            if count % tenth == 0:\n                continue\n        except ZeroDivisionError:\n            print('Division by zero error')\n        type = network.attrib['type']\n        channel = network.find('channel').text\n        bssid = network.find('BSSID').text\n        if type == 'probe' or channel == '0':\n            continue\n        encryption = network.getiterator('encryption')\n        privacy = ''\n        cipher = ''\n        auth = ''\n        if encryption is not None:\n            for item in encryption:\n                if item.text.startswith('WEP'):\n                    privacy = 'WEP'\n                    cipher = 'WEP'\n                    auth = ''\n                    break\n                elif item.text.startswith('WPA'):\n                    if item.text.endswith('PSK'):\n                        auth = 'PSK'\n                    elif item.text.endswith('AES-CCM'):\n                        cipher = 'CCMP ' + cipher\n                    elif item.text.endswith('TKIP'):\n                        cipher += 'TKIP '\n                elif item.text == 'None':\n                    privacy = 'OPN'\n        cipher = cipher.strip()\n        if cipher.find('CCMP') > -1:\n            privacy = 'WPA2'\n        if cipher.find('TKIP') > -1:\n            privacy += 'WPA'\n        power = network.find('snr-info')\n        dbm = ''\n        if power is not None:\n            dbm = power.find('max_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('last_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('min_signal_dbm').text\n        ssid = network.find('SSID')\n        essid_text = ''\n        if ssid is not None:\n            essid_text = network.find('SSID').find('essid').text\n        gps = network.find('gps-info')\n        lat, lon = ('', '')\n        if gps is not None:\n            lat = network.find('gps-info').find('min-lat').text\n            lon = network.find('gps-info').find('min-lon').text\n        data = dict(ESSID=essid_text, BSSID=bssid, Channel=channel, Privacy=privacy, Cipher=cipher, Authenticaiton=auth, DBM=dbm)\n        if lat and lon is not None:\n            google_map = 'https://maps.google.com/maps?q=' + lat + ',' + lon + '&ll=' + lat + ',' + lon + '&z=17'\n            google_map_link = '<a href=\"' + google_map + '\" target=\"_blank\"> Google map link</a>'\n            location = dict(Latitude=lat, Longitude=lon, Googlemap=google_map_link)\n        else:\n            not_found = 'Not coordinates available'\n            location = dict(Latitude=not_found, Longitude=not_found)\n        client_list = associatedClients(network, bssid, essid_text)\n        if client_list is not None:\n            data['client'] = client_list\n        else:\n            not_found = 'No clients found'\n            data['client'] = not_found\n        data['location'] = location\n        parsed_list.append(data)\n    return parsed_list", "fn_id": 1, "class_fn": false, "repo": "binkybear/kismet_web_viewer", "file": "app/netxml_to_csv.py", "last_update_at": "2021-05-22T03:59:05+00:00", "original_content": "def parse_net_xml(doc):\n    total = len(list(doc.getiterator('wireless-network')))\n    tenth = total / 10\n    count = 0\n    clients = list()\n    parsed_list = []\n    for network in doc.getiterator('wireless-network'):\n        count += 1\n        try:\n            if count % tenth == 0:\n                continue\n        except ZeroDivisionError:\n            print('Division by zero error')\n        type = network.attrib['type']\n        channel = network.find('channel').text\n        bssid = network.find('BSSID').text\n        if type == 'probe' or channel == '0':\n            continue\n        encryption = network.getiterator('encryption')\n        privacy = ''\n        cipher = ''\n        auth = ''\n        if encryption is not None:\n            for item in encryption:\n                if item.text.startswith('WEP'):\n                    privacy = 'WEP'\n                    cipher = 'WEP'\n                    auth = ''\n                    break\n                elif item.text.startswith('WPA'):\n                    if item.text.endswith('PSK'):\n                        auth = 'PSK'\n                    elif item.text.endswith('AES-CCM'):\n                        cipher = 'CCMP ' + cipher\n                    elif item.text.endswith('TKIP'):\n                        cipher += 'TKIP '\n                elif item.text == 'None':\n                    privacy = 'OPN'\n        cipher = cipher.strip()\n        if cipher.find('CCMP') > -1:\n            privacy = 'WPA2'\n        if cipher.find('TKIP') > -1:\n            privacy += 'WPA'\n        power = network.find('snr-info')\n        dbm = ''\n        if power is not None:\n            dbm = power.find('max_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('last_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('min_signal_dbm').text\n        ssid = network.find('SSID')\n        essid_text = ''\n        if ssid is not None:\n            essid_text = network.find('SSID').find('essid').text\n        gps = network.find('gps-info')\n        lat, lon = ('', '')\n        if gps is not None:\n            lat = network.find('gps-info').find('min-lat').text\n            lon = network.find('gps-info').find('min-lon').text\n        data = dict(ESSID=essid_text, BSSID=bssid, Channel=channel, Privacy=privacy, Cipher=cipher, Authenticaiton=auth, DBM=dbm)\n        if lat and lon is not None:\n            google_map = 'https://maps.google.com/maps?q=' + lat + ',' + lon + '&ll=' + lat + ',' + lon + '&z=17'\n            google_map_link = '<a href=\"' + google_map + '\" target=\"_blank\"> Google map link</a>'\n            location = dict(Latitude=lat, Longitude=lon, Googlemap=google_map_link)\n        else:\n            not_found = 'Not coordinates available'\n            location = dict(Latitude=not_found, Longitude=not_found)\n        client_list = associatedClients(network, bssid, essid_text)\n        if client_list is not None:\n            data['client'] = client_list\n        else:\n            not_found = 'No clients found'\n            data['client'] = not_found\n        data['location'] = location\n        parsed_list.append(data)\n    return parsed_list", "refactored": true, "pred": {"ppl": 2.8783931732177734, "ppl_lower": 3.092963457107544, "ppl/lowercase_ppl": -1.0680053687286664, "ppl/zlib": 0.001057232212483197, "Min_5.0% Prob": 9.105029284954071, "Min_10.0% Prob": 7.106186002492905, "Min_20.0% Prob": 4.854938627029798, "Min_30.0% Prob": 3.4623194856584565, "Min_40.0% Prob": 2.6379894094298715, "Min_50.0% Prob": 2.114544702973448, "Min_60.0% Prob": 1.7621567126590574}}
{"hexsha": "bc9332449ba47eee635aabdc3d23964f3b29f165", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_ratings(path, users_file_name, books_file_name):\n    df_users = pd.read_csv(path + users_file_name, encoding='UTF8')\n    df_books = pd.read_csv(path + books_file_name, encoding='UTF8')\n    df_users_books = pd.DataFrame(df_users, columns=['user_id', 'like'])\n    sr_users = []\n    sr_books = []\n    sr_ratings = []\n    str_like = list(np.array(df_users_books['like'].tolist()))\n    list_like = []\n    for i in str_like:\n        i = i.lstrip('[').rstrip(']')\n        i = i.split(', ')\n        list_like.append(i)\n    for user_idx in df_users_books['user_id']:\n        for book_idx in list_like[user_idx]:\n            if book_idx == '':\n                break\n            sr_users.append(user_idx)\n            sr_books.append(book_idx)\n            sr_ratings.append(1)\n    for book_idx in range(len(df_books)):\n        if sr_users[0]:\n            sr_users.append(sr_users[0])\n        if sr_books[0]:\n            sr_books.append(book_idx)\n        if sr_ratings[0]:\n            sr_ratings.append(0)\n    R = pd.DataFrame({'user_idx': sr_users, 'book_idx': sr_books, 'ratings': sr_ratings})\n    R = R.pivot_table('ratings', index='user_idx', columns='book_idx').fillna(0)\n    R.rename(columns=lambda x: int(x), inplace=True)\n    R = R.sort_index(axis=1)\n    return R", "fn_id": 0, "class_fn": false, "repo": "osamhack2021/AI_APP_handylib_devlib", "file": "AI/recommendation/ALS.py", "last_update_at": "2021-12-16T10:41:16+00:00", "original_content": "def get_ratings(path, users_file_name, books_file_name):\n    df_users = pd.read_csv(path + users_file_name, encoding='UTF8')\n    df_books = pd.read_csv(path + books_file_name, encoding='UTF8')\n    df_users_books = pd.DataFrame(df_users, columns=['user_id', 'like'])\n    sr_users = []\n    sr_books = []\n    sr_ratings = []\n    str_like = list(np.array(df_users_books['like'].tolist()))\n    list_like = []\n    for i in str_like:\n        i = i.lstrip('[').rstrip(']')\n        i = i.split(', ')\n        list_like.append(i)\n    for user_idx in df_users_books['user_id']:\n        for book_idx in list_like[user_idx]:\n            if book_idx == '':\n                break\n            sr_users.append(user_idx)\n            sr_books.append(book_idx)\n            sr_ratings.append(1)\n    for book_idx in range(len(df_books)):\n        if sr_users[0]:\n            sr_users.append(sr_users[0])\n        if sr_books[0]:\n            sr_books.append(book_idx)\n        if sr_ratings[0]:\n            sr_ratings.append(0)\n    R = pd.DataFrame({'user_idx': sr_users, 'book_idx': sr_books, 'ratings': sr_ratings})\n    R = R.pivot_table('ratings', index='user_idx', columns='book_idx').fillna(0)\n    R.rename(columns=lambda x: int(x), inplace=True)\n    R = R.sort_index(axis=1)\n    return R", "refactored": true, "pred": {"ppl": 2.416233777999878, "ppl_lower": 2.4938769340515137, "ppl/lowercase_ppl": -1.0358513982718096, "ppl/zlib": 0.001826521817409018, "Min_5.0% Prob": 7.942436528205872, "Min_10.0% Prob": 6.0023429917126165, "Min_20.0% Prob": 4.065258810319096, "Min_30.0% Prob": 2.8885207579135894, "Min_40.0% Prob": 2.2065044251012513, "Min_50.0% Prob": 1.767081801376592, "Min_60.0% Prob": 1.4713473881632089}}
{"hexsha": "876c7c08adc0ef2ebe9987da8f1125f3cf04b813", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef word_bag_list(org_text):\n    \"\"\"Take text and do sum, return sumed sentence list.\"\"\"\n    nlp = spacy.load('en_core_web_sm')\n    tr = pytextrank.TextRank(logger=None)\n    nlp.add_pipe(tr.PipelineComponent, name='textrank', last=True)\n    doc = nlp(org_text)\n    whole_sent = ''\n    for sent in doc._.textrank.summary(limit_phrases=15, limit_sentences=5):\n        whole_sent = whole_sent + repr(sent).rstrip() + ' '\n    return [whole_sent]", "fn_id": 0, "class_fn": false, "repo": "liux2/Allegheny-College-CMPSC-COMP-liux2", "file": "music_sug/music_main/text_proc.py", "last_update_at": "2021-05-21T01:37:44+00:00", "original_content": "def word_bag_list(org_text):\n    \"\"\"Take text and do sum, return sumed sentence list.\"\"\"\n    nlp = spacy.load('en_core_web_sm')\n    tr = pytextrank.TextRank(logger=None)\n    nlp.add_pipe(tr.PipelineComponent, name='textrank', last=True)\n    doc = nlp(org_text)\n    whole_sent = ''\n    for sent in doc._.textrank.summary(limit_phrases=15, limit_sentences=5):\n        whole_sent = whole_sent + repr(sent).rstrip() + ' '\n    return [whole_sent]", "refactored": true, "pred": {"ppl": 4.5196733474731445, "ppl_lower": 6.313168048858643, "ppl/lowercase_ppl": -1.2215520384802465, "ppl/zlib": 0.00514825844018604, "Min_5.0% Prob": 11.661109515598842, "Min_10.0% Prob": 9.467079734802246, "Min_20.0% Prob": 6.825967396459272, "Min_30.0% Prob": 4.925080948687614, "Min_40.0% Prob": 3.7520677220253718, "Min_50.0% Prob": 3.01062778430649, "Min_60.0% Prob": 2.534439019482345}}
{"hexsha": "6e58f05000ac2f4b1655ab9325ef2cbb23caea8b", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef remapchunk(seg, chunk, chunkindex, scratchpath, layer=1, bits_per_dim=10, maxmip=11, correctvers=True):\n    x, y, z = chunkindex\n    pcgchunkid = io.pcg.get_chunk_id(layer=layer, x=x, y=y, z=z, bits_per_dim=bits_per_dim)\n    data = seg[chunk.index()]\n    try:\n        if correctvers:\n            mappings = readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n        else:\n            mappings = _readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n    except subprocess.CalledProcessError as e:\n        if data.max() == 0:\n            return data\n        else:\n            raise e\n    for mapping in mappings:\n        data = fastremap.remap(data, mapping, in_place=False, preserve_missing_labels=True)\n    seg[chunk.index()] = data\n    return seg", "fn_id": 2, "class_fn": false, "repo": "ZettaAI/Synaptor", "file": "synaptor/proc/io/agglomeration.py", "last_update_at": "2021-09-13T07:02:16+00:00", "original_content": "def remapchunk(seg, chunk, chunkindex, scratchpath, layer=1, bits_per_dim=10, maxmip=11, correctvers=True):\n    x, y, z = chunkindex\n    pcgchunkid = io.pcg.get_chunk_id(layer=layer, x=x, y=y, z=z, bits_per_dim=bits_per_dim)\n    data = seg[chunk.index()]\n    try:\n        if correctvers:\n            mappings = readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n        else:\n            mappings = _readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n    except subprocess.CalledProcessError as e:\n        if data.max() == 0:\n            return data\n        else:\n            raise e\n    for mapping in mappings:\n        data = fastremap.remap(data, mapping, in_place=False, preserve_missing_labels=True)\n    seg[chunk.index()] = data\n    return seg", "refactored": true, "pred": {"ppl": 5.071335315704346, "ppl_lower": 5.669004440307617, "ppl/lowercase_ppl": -1.0686185479352064, "ppl/zlib": 0.004485094361337909, "Min_5.0% Prob": 11.459334055582682, "Min_10.0% Prob": 9.349120279153189, "Min_20.0% Prob": 6.673058281342189, "Min_30.0% Prob": 5.0409064962439345, "Min_40.0% Prob": 3.9904813858651624, "Min_50.0% Prob": 3.2250834148926812, "Min_60.0% Prob": 2.7084647877371473}}
{"hexsha": "639b37fb1f2788f702b824b85cd19c165e09f9f6", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_cached_property():\n    \"\"\"Test the cached_property decorator\"\"\"\n    new_value = '99999'\n\n    class DummyClass:\n\n        def __init__(self):\n            self.value = '11111'\n\n        def change_value_in_instance(self, value):\n            self.value = value\n\n        @cached_property\n        def test_property(self):\n            return self.value\n\n        @property\n        def test_uncached_property(self):\n            return self.value\n    testClass = DummyClass()\n    first_cached_test_property = testClass.test_property\n    first_uncached_test_property = testClass.test_uncached_property\n    testClass.change_value_in_instance(new_value)\n    second_cached_test_property = testClass.test_property\n    second_uncached_test_property = testClass.test_uncached_property\n    assert first_cached_test_property == second_cached_test_property\n    assert first_cached_test_property == '11111'\n    assert first_uncached_test_property != second_uncached_test_property\n    assert first_uncached_test_property == '11111'\n    assert second_uncached_test_property == '99999'", "fn_id": 0, "class_fn": false, "repo": "musa-atlihan/jina", "file": "tests/unit/test_helper.py", "last_update_at": "2021-04-22T17:14:32+00:00", "original_content": "def test_cached_property():\n    \"\"\"Test the cached_property decorator\"\"\"\n    new_value = '99999'\n\n    class DummyClass:\n\n        def __init__(self):\n            self.value = '11111'\n\n        def change_value_in_instance(self, value):\n            self.value = value\n\n        @cached_property\n        def test_property(self):\n            return self.value\n\n        @property\n        def test_uncached_property(self):\n            return self.value\n    testClass = DummyClass()\n    first_cached_test_property = testClass.test_property\n    first_uncached_test_property = testClass.test_uncached_property\n    testClass.change_value_in_instance(new_value)\n    second_cached_test_property = testClass.test_property\n    second_uncached_test_property = testClass.test_uncached_property\n    assert first_cached_test_property == second_cached_test_property\n    assert first_cached_test_property == '11111'\n    assert first_uncached_test_property != second_uncached_test_property\n    assert first_uncached_test_property == '11111'\n    assert second_uncached_test_property == '99999'", "refactored": true, "pred": {"ppl": 1.8960049152374268, "ppl_lower": 1.9489350318908691, "ppl/lowercase_ppl": -1.043038894634196, "ppl/zlib": 0.0021686406652687215, "Min_5.0% Prob": 7.806715079716274, "Min_10.0% Prob": 5.564955588044791, "Min_20.0% Prob": 3.185334557193821, "Min_30.0% Prob": 2.1443564359182385, "Min_40.0% Prob": 1.6069432692465317, "Min_50.0% Prob": 1.283752253637907, "Min_60.0% Prob": 1.0686284609009664}}
{"hexsha": "b93ceb63b6b34d7c97ec44530d47645b54199e3e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef ndcg_at_ks(r, k_list, method=1, include_dcg=False):\n    \"\"\"\n\n    :param r: \u5339\u914darray \u957f\u5ea6\u4e3a\u6bcf\u4e2a\u9884\u6d4b\u7ed3\u679c\u7684\u5339\u914d\u7ed3\u679c\n    :param k_list:\n    :param method:\n    :param include_dcg:\n    :return:\n    \"\"\"\n    if r.shape[0] == 0:\n        ndcg_array = [0.0] * len(k_list)\n        dcg_array = [0.0] * len(k_list)\n    else:\n        dcg_array = dcg_at_ks(r, k_list, method)\n        ideal_r = np.array(sorted(r, reverse=True))\n        dcg_max_array = dcg_at_ks(ideal_r, k_list, method)\n        ndcg_array = dcg_array / dcg_max_array\n        ndcg_array = np.nan_to_num(ndcg_array)\n    if include_dcg:\n        return (ndcg_array, dcg_array)\n    else:\n        return ndcg_array", "fn_id": 18, "class_fn": false, "repo": "qtli/AOT", "file": "utils/common.py", "last_update_at": "2021-09-07T14:49:29+00:00", "original_content": "def ndcg_at_ks(r, k_list, method=1, include_dcg=False):\n    \"\"\"\n\n    :param r: \u5339\u914darray \u957f\u5ea6\u4e3a\u6bcf\u4e2a\u9884\u6d4b\u7ed3\u679c\u7684\u5339\u914d\u7ed3\u679c\n    :param k_list:\n    :param method:\n    :param include_dcg:\n    :return:\n    \"\"\"\n    if r.shape[0] == 0:\n        ndcg_array = [0.0] * len(k_list)\n        dcg_array = [0.0] * len(k_list)\n    else:\n        dcg_array = dcg_at_ks(r, k_list, method)\n        ideal_r = np.array(sorted(r, reverse=True))\n        dcg_max_array = dcg_at_ks(ideal_r, k_list, method)\n        ndcg_array = dcg_array / dcg_max_array\n        ndcg_array = np.nan_to_num(ndcg_array)\n    if include_dcg:\n        return (ndcg_array, dcg_array)\n    else:\n        return ndcg_array", "refactored": true, "pred": {"ppl": 2.4949941635131836, "ppl_lower": 2.643813133239746, "ppl/lowercase_ppl": -1.0633672932500875, "ppl/zlib": 0.002778985987621498, "Min_5.0% Prob": 8.399379436786358, "Min_10.0% Prob": 6.482224180148198, "Min_20.0% Prob": 4.283627692258583, "Min_30.0% Prob": 3.0400751563189905, "Min_40.0% Prob": 2.288564904434782, "Min_50.0% Prob": 1.8279923732581556, "Min_60.0% Prob": 1.5294809477944102}}
{"hexsha": "7d0de049fa37b3a2b53aa13e4a8de6bd43d360ad", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef update_progress(value):\n    global PROGRESS\n    PROGRESS['value'] = value\n    return PROGRESS['value']", "fn_id": 0, "class_fn": false, "repo": "scyv/Smiley", "file": "smiley/utils.py", "last_update_at": "2021-12-10T23:49:05+00:00", "original_content": "def update_progress(value):\n    global PROGRESS\n    PROGRESS['value'] = value\n    return PROGRESS['value']", "refactored": true, "pred": {"ppl": 6.804867744445801, "ppl_lower": 7.056074619293213, "ppl/lowercase_ppl": -1.0189038229787826, "ppl/zlib": 0.017593011017053604, "Min_5.0% Prob": 7.643188953399658, "Min_10.0% Prob": 7.447107791900635, "Min_20.0% Prob": 6.285211631229946, "Min_30.0% Prob": 5.627979826927185, "Min_40.0% Prob": 4.694839656352997, "Min_50.0% Prob": 3.7760158048735724, "Min_60.0% Prob": 3.2699744523990724}}
{"hexsha": "6494d7e235268c91bde539243623f44dd265dd50", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef create_fake_server(messages=[]):\n    all_messages = _standard_join_messages() + messages\n\n    async def _fake_server(websocket, _path):\n        _join_message = await websocket.recv()\n        for message in all_messages:\n            await websocket.send(json.dumps(message))\n    return _fake_server", "fn_id": 1, "class_fn": false, "repo": "UrbanOS-Examples/PredictiveParking", "file": "tests/fake_websocket_server.py", "last_update_at": "2021-07-01T16:51:18+00:00", "original_content": "def create_fake_server(messages=[]):\n    all_messages = _standard_join_messages() + messages\n\n    async def _fake_server(websocket, _path):\n        _join_message = await websocket.recv()\n        for message in all_messages:\n            await websocket.send(json.dumps(message))\n    return _fake_server", "refactored": true, "pred": {"ppl": 6.110935688018799, "ppl_lower": 6.110935688018799, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.010000441446891238, "Min_5.0% Prob": 9.352094411849976, "Min_10.0% Prob": 8.597876787185669, "Min_20.0% Prob": 7.012108266353607, "Min_30.0% Prob": 5.602310094833374, "Min_40.0% Prob": 4.523590087890625, "Min_50.0% Prob": 3.60620235225984, "Min_60.0% Prob": 3.0378228000923992}}
{"hexsha": "be45de239f2a958420b5ae5de4b313cf3431599f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_playlist_tracks(args):\n    playlists = []\n    current_user_id = args.get('current_user_id')\n    limit = args.get('limit')\n    offset = args.get('offset')\n    db = get_db_read_replica()\n    with db.scoped_session() as session:\n        try:\n            playlist_id = args.get('playlist_id')\n            playlist = session.query(Playlist).filter(Playlist.is_current == True, Playlist.playlist_id == playlist_id).first()\n            if playlist is None:\n                return None\n            playlist_track_ids = [track_id['track'] for track_id in playlist.playlist_contents['track_ids']]\n            if limit and offset:\n                playlist_track_ids = playlist_track_ids[offset:offset + limit]\n            playlist_tracks = session.query(Track).filter(Track.is_current == True, Track.track_id.in_(playlist_track_ids)).all()\n            tracks = helpers.query_result_to_list(playlist_tracks)\n            tracks = populate_track_metadata(session, playlist_track_ids, tracks, current_user_id)\n            if args.get('with_users', False):\n                add_users_to_tracks(session, tracks)\n            tracks_dict = {track['track_id']: track for track in tracks}\n            playlist_tracks = []\n            for track_id in playlist_track_ids:\n                playlist_tracks.append(tracks_dict[track_id])\n            return playlist_tracks\n        except sqlalchemy.orm.exc.NoResultFound:\n            pass\n    return playlists", "fn_id": 0, "class_fn": false, "repo": "raymondjacobson/audius-protocol", "file": "discovery-provider/src/queries/get_playlist_tracks.py", "last_update_at": "2021-05-29T04:25:03+00:00", "original_content": "def get_playlist_tracks(args):\n    playlists = []\n    current_user_id = args.get('current_user_id')\n    limit = args.get('limit')\n    offset = args.get('offset')\n    db = get_db_read_replica()\n    with db.scoped_session() as session:\n        try:\n            playlist_id = args.get('playlist_id')\n            playlist = session.query(Playlist).filter(Playlist.is_current == True, Playlist.playlist_id == playlist_id).first()\n            if playlist is None:\n                return None\n            playlist_track_ids = [track_id['track'] for track_id in playlist.playlist_contents['track_ids']]\n            if limit and offset:\n                playlist_track_ids = playlist_track_ids[offset:offset + limit]\n            playlist_tracks = session.query(Track).filter(Track.is_current == True, Track.track_id.in_(playlist_track_ids)).all()\n            tracks = helpers.query_result_to_list(playlist_tracks)\n            tracks = populate_track_metadata(session, playlist_track_ids, tracks, current_user_id)\n            if args.get('with_users', False):\n                add_users_to_tracks(session, tracks)\n            tracks_dict = {track['track_id']: track for track in tracks}\n            playlist_tracks = []\n            for track_id in playlist_track_ids:\n                playlist_tracks.append(tracks_dict[track_id])\n            return playlist_tracks\n        except sqlalchemy.orm.exc.NoResultFound:\n            pass\n    return playlists", "refactored": true, "pred": {"ppl": 2.093169689178467, "ppl_lower": 2.4714548587799072, "ppl/lowercase_ppl": -1.2248979033094503, "ppl/zlib": 0.0014598409383338405, "Min_5.0% Prob": 7.173942115571764, "Min_10.0% Prob": 5.458973864714305, "Min_20.0% Prob": 3.465428649562679, "Min_30.0% Prob": 2.430573416298086, "Min_40.0% Prob": 1.8455249287796265, "Min_50.0% Prob": 1.4801189612961658, "Min_60.0% Prob": 1.233181158265592}}
{"hexsha": "e739faa956bee4ffde5b12e2607b0430bc975de6", "ext": "py", "lang": "Python", "content": "@pytest.fixture\n@timeing\n@measure_memory_usage\ndef archive_repositories(archive_repositories_raw: bytes) -> ArchiveRepositories:\n    \"\"\"Provides an ArchiveRepositories instance for the sample archive manifest.\"\"\"\n    return ArchiveRepositories(archive_repositories_raw)", "fn_id": 0, "class_fn": false, "repo": "crashvb/docker-sign-verify", "file": "tests/test_archiverepositories.py", "last_update_at": "2021-09-16T18:44:39+00:00", "original_content": "@pytest.fixture\ndef archive_repositories(archive_repositories_raw: bytes) -> ArchiveRepositories:\n    \"\"\"Provides an ArchiveRepositories instance for the sample archive manifest.\"\"\"\n    return ArchiveRepositories(archive_repositories_raw)", "refactored": true, "pred": {"ppl": 14.450926780700684, "ppl_lower": 18.8896541595459, "ppl/lowercase_ppl": -1.1002920401361176, "ppl/zlib": 0.017230700319835215, "Min_5.0% Prob": 11.17871904373169, "Min_10.0% Prob": 9.832250785827636, "Min_20.0% Prob": 8.549754749644887, "Min_30.0% Prob": 7.6608472764492035, "Min_40.0% Prob": 6.284339785575867, "Min_50.0% Prob": 5.171392943177905, "Min_60.0% Prob": 4.479652000196053}}
{"hexsha": "f2e5aa3454e20bde6dfc287c3f2e7fede42c0287", "ext": "py", "lang": "Python", "content": "@overload\n@timeing\n@measure_memory_usage\ndef assert_equal(actual: scipy.special.orthogonal.orthopoly1d, desired: numpy.poly1d):\n    \"\"\"\n    usage.scipy: 2\n    \"\"\"\n    ...", "fn_id": 2892, "class_fn": false, "repo": "pydata-apis/python-api-record", "file": "data/typing/numpy.testing._private.utils.py", "last_update_at": "2021-11-08T20:16:06+00:00", "original_content": "@overload\ndef assert_equal(actual: scipy.special.orthogonal.orthopoly1d, desired: numpy.poly1d):\n    \"\"\"\n    usage.scipy: 2\n    \"\"\"\n    ...", "refactored": true, "pred": {"ppl": 13.64012622833252, "ppl_lower": 13.64012622833252, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.020255937260845527, "Min_5.0% Prob": 12.761251449584961, "Min_10.0% Prob": 11.318618011474609, "Min_20.0% Prob": 9.223935270309449, "Min_30.0% Prob": 7.421538978815079, "Min_40.0% Prob": 6.221973101298015, "Min_50.0% Prob": 5.1485308761949895, "Min_60.0% Prob": 4.392842118628323}}
{"hexsha": "bcc284a877dbebcbe1f579fbdd8c29590594f15e", "ext": "py", "lang": "Python", "content": "@unittest.skipIf(sys.platform == 'win32', 'Fail to create temp dir.')\n@pytest.mark.parametrize('client_mode', [True, False])\n@timeing\n@measure_memory_usage\ndef test_two_node(two_node_cluster, working_dir, client_mode):\n    cluster, _ = two_node_cluster\n    address, env, PKG_DIR = start_client_server(cluster, client_mode)\n    runtime_env = f'{{  \"working_dir\": \"{working_dir}\" }}'\n    execute_statement = 'print(sum(ray.get([run_test.remote()] * 1000)))'\n    script = driver_script.format(**locals())\n    out = run_string_as_driver(script, env)\n    assert out.strip().split()[-1] == '1000'\n    assert len(list(Path(PKG_DIR).iterdir())) == 1", "fn_id": 7, "class_fn": false, "repo": "jenhaoyang/ray", "file": "python/ray/tests/test_runtime_env.py", "last_update_at": "2021-04-30T05:22:12+00:00", "original_content": "@unittest.skipIf(sys.platform == 'win32', 'Fail to create temp dir.')\n@pytest.mark.parametrize('client_mode', [True, False])\ndef test_two_node(two_node_cluster, working_dir, client_mode):\n    cluster, _ = two_node_cluster\n    address, env, PKG_DIR = start_client_server(cluster, client_mode)\n    runtime_env = f'{{  \"working_dir\": \"{working_dir}\" }}'\n    execute_statement = 'print(sum(ray.get([run_test.remote()] * 1000)))'\n    script = driver_script.format(**locals())\n    out = run_string_as_driver(script, env)\n    assert out.strip().split()[-1] == '1000'\n    assert len(list(Path(PKG_DIR).iterdir())) == 1", "refactored": true, "pred": {"ppl": 4.483009338378906, "ppl_lower": 5.133694171905518, "ppl/lowercase_ppl": -1.0903362365962994, "ppl/zlib": 0.003817543379734862, "Min_5.0% Prob": 11.449512577056884, "Min_10.0% Prob": 8.71514556521461, "Min_20.0% Prob": 6.188777123178754, "Min_30.0% Prob": 4.6484699584543705, "Min_40.0% Prob": 3.6660754824385924, "Min_50.0% Prob": 2.967792628385196, "Min_60.0% Prob": 2.5008853334293235}}
{"hexsha": "a318f13cb13b18c46060393025e55c03c4986095", "ext": "py", "lang": "Python", "content": "@MSC.route('/candidates')\n@timeing\n@measure_memory_usage\ndef candidates():\n    text = request.args.get('text', default='', type=str)\n    limit = request.args.get('limit', default=5, type=int)\n    htmlflag = request.args.get('html', default=0, type=int)\n    rval = {}\n    rval['input'] = text\n    runningOffset = 0\n    if text == '':\n        return 'No text received. Usage: url/candidates?html=0&limit=2&text=texttomedicalspellcheck'\n    respJSONstring = corrector.GetALLCandidatesScoredJSON(text)\n    print(respJSONstring)\n    rval = json.loads(respJSONstring)\n    for result in rval['results']:\n        result['candidates'] = result['candidates'][:limit]\n    if 'results' not in rval.keys() or len(rval['results']) == 0:\n        rval['results'] = 'CORRECT'\n    if bool(htmlflag):\n        return json2html.convert(json.dumps(rval)) + '<br><br><br>Try me out: <br><br>' + formcode\n    else:\n        return json.dumps(rval, indent=2)", "fn_id": 2, "class_fn": false, "repo": "jackneil/medSpellCheck", "file": "webserver.py", "last_update_at": "2021-07-07T02:07:24+00:00", "original_content": "@MSC.route('/candidates')\ndef candidates():\n    text = request.args.get('text', default='', type=str)\n    limit = request.args.get('limit', default=5, type=int)\n    htmlflag = request.args.get('html', default=0, type=int)\n    rval = {}\n    rval['input'] = text\n    runningOffset = 0\n    if text == '':\n        return 'No text received. Usage: url/candidates?html=0&limit=2&text=texttomedicalspellcheck'\n    respJSONstring = corrector.GetALLCandidatesScoredJSON(text)\n    print(respJSONstring)\n    rval = json.loads(respJSONstring)\n    for result in rval['results']:\n        result['candidates'] = result['candidates'][:limit]\n    if 'results' not in rval.keys() or len(rval['results']) == 0:\n        rval['results'] = 'CORRECT'\n    if bool(htmlflag):\n        return json2html.convert(json.dumps(rval)) + '<br><br><br>Try me out: <br><br>' + formcode\n    else:\n        return json.dumps(rval, indent=2)", "refactored": true, "pred": {"ppl": 6.130869388580322, "ppl_lower": 5.908751487731934, "ppl/lowercase_ppl": -0.9796496629974181, "ppl/zlib": 0.003976615274361607, "Min_5.0% Prob": 12.362235436072716, "Min_10.0% Prob": 10.299913512335884, "Min_20.0% Prob": 7.578986714103005, "Min_30.0% Prob": 5.712253577737923, "Min_40.0% Prob": 4.498124653642828, "Min_50.0% Prob": 3.627478657587283, "Min_60.0% Prob": 3.023439258101385}}
{"hexsha": "c908d4e2fcbe9433c55ec3ffa39b22b2f66872dd", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef calc_data_maxima(data, order):\n    \"\"\"Calculate the local maxima using an exclusion of order to avoid multiple close maxima.\n\n    :param data: 3D numpy array (axis 0: time)\n    :param order: number of points to consider for maxima\n    :return: 3D numpy bool array with same shape as data, True if maximum\n    \"\"\"\n    argrelmax = signal.argrelmax(data, order=order, mode='wrap')\n    dmean = data.mean(axis=0)\n    data_maxima = np.zeros(data.shape, dtype=bool)\n    for i, j, k in zip(*argrelmax):\n        if data[i, j, k] > dmean[j, k]:\n            data_maxima[i, j, k] = True\n    return data_maxima", "fn_id": 0, "class_fn": false, "repo": "markmuetz/cosmic", "file": "cosmic/WP2/multipeak.py", "last_update_at": "2021-01-26T02:25:48+00:00", "original_content": "def calc_data_maxima(data, order):\n    \"\"\"Calculate the local maxima using an exclusion of order to avoid multiple close maxima.\n\n    :param data: 3D numpy array (axis 0: time)\n    :param order: number of points to consider for maxima\n    :return: 3D numpy bool array with same shape as data, True if maximum\n    \"\"\"\n    argrelmax = signal.argrelmax(data, order=order, mode='wrap')\n    dmean = data.mean(axis=0)\n    data_maxima = np.zeros(data.shape, dtype=bool)\n    for i, j, k in zip(*argrelmax):\n        if data[i, j, k] > dmean[j, k]:\n            data_maxima[i, j, k] = True\n    return data_maxima", "refactored": true, "pred": {"ppl": 3.5298264026641846, "ppl_lower": 4.060679912567139, "ppl/lowercase_ppl": -1.1110817673058977, "ppl/zlib": 0.003687861672574308, "Min_5.0% Prob": 9.773341655731201, "Min_10.0% Prob": 7.952927288256194, "Min_20.0% Prob": 5.545040821417784, "Min_30.0% Prob": 4.090537817313753, "Min_40.0% Prob": 3.125759963423778, "Min_50.0% Prob": 2.5117635967932186, "Min_60.0% Prob": 2.110825590502757}}
{"hexsha": "6fb0abbb3b81f5bf6e666d791414fa75ce85b499", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _read_checkpoint_file(checkpoint_file: Optional[str]) -> Tuple[Set[str], Set[str]]:\n    colls, users = (set(), set())\n    if checkpoint_file:\n        with open(checkpoint_file) as fd:\n            for line in fd.readlines():\n                if line.startswith('CHECKPOINT'):\n                    _, type_, oid = line.split()\n                    if type_ == 'collection':\n                        colls.add(oid)\n                    elif type_ == 'user':\n                        users.add(oid)\n    return (colls, users)", "fn_id": 6, "class_fn": false, "repo": "girder/dkc-next", "file": "dkc/core/management/commands/migrate_dkc_db.py", "last_update_at": "2021-02-17T20:34:11+00:00", "original_content": "def _read_checkpoint_file(checkpoint_file: Optional[str]) -> Tuple[Set[str], Set[str]]:\n    colls, users = (set(), set())\n    if checkpoint_file:\n        with open(checkpoint_file) as fd:\n            for line in fd.readlines():\n                if line.startswith('CHECKPOINT'):\n                    _, type_, oid = line.split()\n                    if type_ == 'collection':\n                        colls.add(oid)\n                    elif type_ == 'user':\n                        users.add(oid)\n    return (colls, users)", "refactored": true, "pred": {"ppl": 3.3728108406066895, "ppl_lower": 3.57110857963562, "ppl/lowercase_ppl": -1.0469913763024683, "ppl/zlib": 0.004622610167476929, "Min_5.0% Prob": 9.364866495132446, "Min_10.0% Prob": 7.671627081357515, "Min_20.0% Prob": 5.580840532596294, "Min_30.0% Prob": 4.017189232966839, "Min_40.0% Prob": 3.054399135021063, "Min_50.0% Prob": 2.448529478248495, "Min_60.0% Prob": 2.041590387115064}}
{"hexsha": "567e27ecd176008a4a9c4c66d72d8200e72ba772", "ext": "py", "lang": "Python", "content": "@pytest.fixture(scope='session', autouse=True)\n@timeing\n@measure_memory_usage\ndef cleanup(request):\n\n    def remove_test_dir():\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.scistree.CFMatrix'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.scistree.log'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.scite.CFMatrix'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.scite.log'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.huntress.CFMatrix'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.huntress.log'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.CFMatrix'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.log'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.booster.CFMatrix'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.booster.log'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/consensus.CFMatrix'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.info2'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.newick'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.png'))\n        tsc.ul.cleanup(tsc.ul.get_file('trisicell.datasets/test/_map'))\n        tsc.ul.cleanup(tsc.ul.get_file('trisicell.datasets/test/_tmp'))\n        tsc.ul.cleanup(tsc.ul.get_file('trisicell.datasets/test/test'))\n    request.addfinalizer(remove_test_dir)", "fn_id": 0, "class_fn": false, "repo": "faridrashidi/trisicell", "file": "tests/test_commands.py", "last_update_at": "2021-11-16T03:14:36+00:00", "original_content": "@pytest.fixture(scope='session', autouse=True)\ndef cleanup(request):\n\n    def remove_test_dir():\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.scistree.CFMatrix'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.scistree.log'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.scite.CFMatrix'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.scite.log'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.huntress.CFMatrix'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.huntress.log'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.CFMatrix'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.log'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.booster.CFMatrix'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.booster.log'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/consensus.CFMatrix'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.info2'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.newick'))\n        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.png'))\n        tsc.ul.cleanup(tsc.ul.get_file('trisicell.datasets/test/_map'))\n        tsc.ul.cleanup(tsc.ul.get_file('trisicell.datasets/test/_tmp'))\n        tsc.ul.cleanup(tsc.ul.get_file('trisicell.datasets/test/test'))\n    request.addfinalizer(remove_test_dir)", "refactored": true, "pred": {"ppl": 1.8453210592269897, "ppl_lower": 1.9044803380966187, "ppl/lowercase_ppl": -1.051506954900699, "ppl/zlib": 0.0021958898860024267, "Min_5.0% Prob": 8.24301055382038, "Min_10.0% Prob": 5.594255073317166, "Min_20.0% Prob": 3.0518964932396493, "Min_30.0% Prob": 2.046593280493057, "Min_40.0% Prob": 1.536537264239902, "Min_50.0% Prob": 1.2252486923420873, "Min_60.0% Prob": 1.021665797409016}}
{"hexsha": "454c918ee83d8f3c85828d2e941785840208d81e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef text_error(code: int, error: Exception, url: str, usage: str='') -> Response:\n    \"\"\"Format error message as plain text\n\n    Returns\n    -------\n    error message formatted as plain text.\n    \"\"\"\n    return PlainTextResponse(content=f'Error {code}: {ERROR_CODE_MESSAGES[code]}\\n\\n{error}\\n\\nUsage details are available from {usage}\\n\\nRequest:\\n{url}\\n\\nRequest Submitted:\\n{UTCDateTime().isoformat()}Z\\n\\nService Version:\\n{VERSION}\\n', status_code=code)", "fn_id": 5, "class_fn": false, "repo": "alejandrodelcampillo/geomag-algorithms", "file": "geomagio/api/ws/app.py", "last_update_at": "2021-02-22T23:45:22+00:00", "original_content": "def text_error(code: int, error: Exception, url: str, usage: str='') -> Response:\n    \"\"\"Format error message as plain text\n\n    Returns\n    -------\n    error message formatted as plain text.\n    \"\"\"\n    return PlainTextResponse(content=f'Error {code}: {ERROR_CODE_MESSAGES[code]}\\n\\n{error}\\n\\nUsage details are available from {usage}\\n\\nRequest:\\n{url}\\n\\nRequest Submitted:\\n{UTCDateTime().isoformat()}Z\\n\\nService Version:\\n{VERSION}\\n', status_code=code)", "refactored": true, "pred": {"ppl": 9.875377655029297, "ppl_lower": 14.788650512695312, "ppl/lowercase_ppl": -1.176335204961739, "ppl/zlib": 0.007293135521029268, "Min_5.0% Prob": 10.54516955784389, "Min_10.0% Prob": 9.21848794392177, "Min_20.0% Prob": 7.383003541401455, "Min_30.0% Prob": 6.191067638851347, "Min_40.0% Prob": 5.2944392051015585, "Min_50.0% Prob": 4.501336960281645, "Min_60.0% Prob": 3.8173596126337848}}
{"hexsha": "8c985af6b5bde8b51d64a34a81f930b1cbbde109", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef decode_UHFRFModeTable(data):\n    logger.debug(func())\n    par = {}\n    if len(data) == 0:\n        return (None, data)\n    header = data[0:par_header_len]\n    msgtype, length = struct.unpack(par_header, header)\n    msgtype = msgtype & BITMASK(10)\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    if msgtype != Message_struct['UHFRFModeTable']['type']:\n        return (None, data)\n    body = data[par_header_len:length]\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    i = 0\n    ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n    while ret:\n        par['UHFC1G2RFModeTableEntry' + str(i)] = ret\n        ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n        i += 1\n    return (par, data[length:])", "fn_id": 18, "class_fn": false, "repo": "amjadmajid/stork", "file": "Host_software/sllurp/llrp_proto.py", "last_update_at": "2021-11-21T08:23:03+00:00", "original_content": "def decode_UHFRFModeTable(data):\n    logger.debug(func())\n    par = {}\n    if len(data) == 0:\n        return (None, data)\n    header = data[0:par_header_len]\n    msgtype, length = struct.unpack(par_header, header)\n    msgtype = msgtype & BITMASK(10)\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    if msgtype != Message_struct['UHFRFModeTable']['type']:\n        return (None, data)\n    body = data[par_header_len:length]\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    i = 0\n    ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n    while ret:\n        par['UHFC1G2RFModeTableEntry' + str(i)] = ret\n        ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n        i += 1\n    return (par, data[length:])", "refactored": true, "pred": {"ppl": 4.421286582946777, "ppl_lower": 4.729626178741455, "ppl/lowercase_ppl": -1.0453539004059633, "ppl/zlib": 0.004308494886516182, "Min_5.0% Prob": 10.57851791381836, "Min_10.0% Prob": 8.64631097793579, "Min_20.0% Prob": 6.291384582519531, "Min_30.0% Prob": 4.754816360473633, "Min_40.0% Prob": 3.7074283738434315, "Min_50.0% Prob": 2.9660485801065253, "Min_60.0% Prob": 2.4792690415441103}}
{"hexsha": "b0b49ffed87028f7676ecd3a3526e65ea082c9a2", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef obtain_pcaplot(model):\n    for idx, layer in enumerate(model.layers):\n        if layer.__class__.__name__ == 'Dense':\n            all_weights = layer.get_weights()\n            weights = all_weights[0]\n            pca = applyPCA(weights, np.array(weights).shape[1], drawPlot=True, isReshape=False)\n            break", "fn_id": 10, "class_fn": false, "repo": "kilinco/spec-img-finesse", "file": "CNN_version/final.py", "last_update_at": "2021-06-03T16:52:44+00:00", "original_content": "def obtain_pcaplot(model):\n    for idx, layer in enumerate(model.layers):\n        if layer.__class__.__name__ == 'Dense':\n            all_weights = layer.get_weights()\n            weights = all_weights[0]\n            pca = applyPCA(weights, np.array(weights).shape[1], drawPlot=True, isReshape=False)\n            break", "refactored": true, "pred": {"ppl": 7.170498371124268, "ppl_lower": 9.958803176879883, "ppl/lowercase_ppl": -1.1667441032022603, "ppl/zlib": 0.009162675162900577, "Min_5.0% Prob": 12.151801347732544, "Min_10.0% Prob": 10.231731679704454, "Min_20.0% Prob": 7.945848862330119, "Min_30.0% Prob": 6.046194979122707, "Min_40.0% Prob": 4.8595563527700065, "Min_50.0% Prob": 3.9080769448204244, "Min_60.0% Prob": 3.295078311780734}}
{"hexsha": "af3e93794d127b40b4269b409917fdaa6143f215", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef parse_function_args(query_param_definition, is_strict=False):\n\n    def inner_get_fu(fu):\n        return FuncArgParser(query_param_definition, is_strict=is_strict)(fu)\n    return inner_get_fu", "fn_id": 0, "class_fn": false, "repo": "sabariramc/funcargparser", "file": "testimplementation.py", "last_update_at": "2021-05-05T09:56:14+00:00", "original_content": "def parse_function_args(query_param_definition, is_strict=False):\n\n    def inner_get_fu(fu):\n        return FuncArgParser(query_param_definition, is_strict=is_strict)(fu)\n    return inner_get_fu", "refactored": true, "pred": {"ppl": 11.042240142822266, "ppl_lower": 14.72243595123291, "ppl/lowercase_ppl": -1.119765711124606, "ppl/zlib": 0.017278618214048358, "Min_5.0% Prob": 11.149365107218424, "Min_10.0% Prob": 9.484905083974203, "Min_20.0% Prob": 7.990509253281814, "Min_30.0% Prob": 6.8943078994750975, "Min_40.0% Prob": 5.680667523984556, "Min_50.0% Prob": 4.735475370112588, "Min_60.0% Prob": 4.071149880066514}}
{"hexsha": "80c466f827f74902bd68bfb5f88abcaf94f6d86e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_handle_xevent_atom_ok(monkeypatch):\n    \"\"\"Return false when event type is invalid\"\"\"\n    event = MagicMock(spec=Xlib.protocol.event.PropertyNotify)\n    event.type = xwindow.Xlib.X.PropertyNotify\n    event.atom = xwindow.NET_ACTIVE_WINDOW\n    monkeypatch.setattr(xwindow, 'ROOT', MagicMock())\n    monkeypatch.setattr(xwindow, 'DISP', MagicMock())\n    result = xwindow.handle_xevent(event, callback=lambda *args, **kwargs: 'callback')\n    assert result is True", "fn_id": 6, "class_fn": false, "repo": "eddie-dunn/swytcher", "file": "tests/test_xwindow.py", "last_update_at": "2021-07-07T08:52:49+00:00", "original_content": "def test_handle_xevent_atom_ok(monkeypatch):\n    \"\"\"Return false when event type is invalid\"\"\"\n    event = MagicMock(spec=Xlib.protocol.event.PropertyNotify)\n    event.type = xwindow.Xlib.X.PropertyNotify\n    event.atom = xwindow.NET_ACTIVE_WINDOW\n    monkeypatch.setattr(xwindow, 'ROOT', MagicMock())\n    monkeypatch.setattr(xwindow, 'DISP', MagicMock())\n    result = xwindow.handle_xevent(event, callback=lambda *args, **kwargs: 'callback')\n    assert result is True", "refactored": true, "pred": {"ppl": 4.7387189865112305, "ppl_lower": 8.930487632751465, "ppl/lowercase_ppl": -1.407325917208877, "ppl/zlib": 0.005401968205454721, "Min_5.0% Prob": 8.790867941720146, "Min_10.0% Prob": 7.909738336290632, "Min_20.0% Prob": 6.156925192901066, "Min_30.0% Prob": 4.781229595343272, "Min_40.0% Prob": 3.819578031344073, "Min_50.0% Prob": 3.1017399340867997, "Min_60.0% Prob": 2.6017900997151933}}
{"hexsha": "a6247751a993a8d45edcb88a38537df9fdda2f2e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef decode_vector_type(contract_address, abi):\n    wasm_contract_obj = platon.wasmcontract(address=contract_address, abi=abi, vmtype=1)\n    tx_hash = wasm_contract_obj.functions.clearElement().transact({'from': from_address, 'gas': gas})\n    tx_receipt = platon.waitForTransactionReceipt(tx_hash)\n    topic_param = wasm_contract_obj.events.clear().processReceipt(tx_receipt)\n    print(topic_param)", "fn_id": 4, "class_fn": false, "repo": "AlayaNetwork/client-sdk-python", "file": "tests/wasm_unit_test.py", "last_update_at": "2021-05-06T07:41:02+00:00", "original_content": "def decode_vector_type(contract_address, abi):\n    wasm_contract_obj = platon.wasmcontract(address=contract_address, abi=abi, vmtype=1)\n    tx_hash = wasm_contract_obj.functions.clearElement().transact({'from': from_address, 'gas': gas})\n    tx_receipt = platon.waitForTransactionReceipt(tx_hash)\n    topic_param = wasm_contract_obj.events.clear().processReceipt(tx_receipt)\n    print(topic_param)", "refactored": true, "pred": {"ppl": 6.121098041534424, "ppl_lower": 7.216229438781738, "ppl/lowercase_ppl": -1.0908468891424845, "ppl/zlib": 0.007676870758398423, "Min_5.0% Prob": 10.338262240091959, "Min_10.0% Prob": 9.321106354395548, "Min_20.0% Prob": 7.119733905792236, "Min_30.0% Prob": 5.604295817581383, "Min_40.0% Prob": 4.423162990808487, "Min_50.0% Prob": 3.623086280399753, "Min_60.0% Prob": 3.014146388421456}}
{"hexsha": "3931e032c422dda461181a2d4fc71a72aab1d761", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef main():\n    \"\"\"Main function.\"\"\"\n    try:\n        tickers = os.listdir('data')\n        tickers = (os.path.basename(t) for t in tickers if t.endswith('.csv.gz'))\n        tickers = [t.split('.')[0] for t in tickers]\n        epilog = '\\nValid values for ticker are: %s' % tickers\n        epilog += '\\n\\nSample usage: ./predict.py IBM 2010-01-01 2011-01-01 21'\n    except OSError:\n        tickers = []\n        epilog = ''\n    parser = argparse.ArgumentParser(description='Predicts stock prices.', epilog=epilog, add_help=True)\n    parser.add_argument('ticker', metavar='TICKER', help='The stock item to predict')\n    parser.add_argument('start_date', metavar='START_DATE', help='The initial date to start looking into history.')\n    parser.add_argument('end_date', metavar='END_DATE', help='The final date to stop looking into history.')\n    parser.add_argument('shift', metavar='SHIFT', type=int, help='How many days in advance to predict.')\n    options = parser.parse_args()\n    if not tickers:\n        print('\"No tickers available. Unable to predict.')\n        raise SystemExit\n    ticker = options.ticker\n    if ticker not in tickers:\n        print('\"ticker\" must be one of %s' % tickers)\n        raise SystemExit\n    try:\n        start_date = pd.to_datetime(options.start_date)\n    except ValueError:\n        print('\"start_date\" must be a valid date. Not %s' % start_date)\n        raise SystemExit\n    try:\n        end_date = pd.to_datetime(options.end_date)\n    except ValueError:\n        print('\"end_date\" must be a valid date. Not %s' % end_date)\n        raise SystemExit\n    shift = options.shift\n    if shift <= 0:\n        print('\"shift\" must be a positive integer')\n        raise SystemExit\n    print('Loading data...')\n    X, y, tX, _, scaler = models.get_processed_dataset(ticker, 0.9999999999, shift, 0, False, start_date, end_date)\n    print('Training model...')\n    _, _, model = models.cross_validate_model('huber', X, y)\n    print('Predicting...')\n    yhat = model.predict(tX)\n    prediction = scaler.inverse_transform(np.array([[yhat[0]] + [0] * (X.shape[1] - 1)]))\n    print('Predicted value:', prediction[0, 0])", "fn_id": 0, "class_fn": false, "repo": "renatolfc/stock-prediction", "file": "predict.py", "last_update_at": "2021-07-01T12:17:06+00:00", "original_content": "def main():\n    \"\"\"Main function.\"\"\"\n    try:\n        tickers = os.listdir('data')\n        tickers = (os.path.basename(t) for t in tickers if t.endswith('.csv.gz'))\n        tickers = [t.split('.')[0] for t in tickers]\n        epilog = '\\nValid values for ticker are: %s' % tickers\n        epilog += '\\n\\nSample usage: ./predict.py IBM 2010-01-01 2011-01-01 21'\n    except OSError:\n        tickers = []\n        epilog = ''\n    parser = argparse.ArgumentParser(description='Predicts stock prices.', epilog=epilog, add_help=True)\n    parser.add_argument('ticker', metavar='TICKER', help='The stock item to predict')\n    parser.add_argument('start_date', metavar='START_DATE', help='The initial date to start looking into history.')\n    parser.add_argument('end_date', metavar='END_DATE', help='The final date to stop looking into history.')\n    parser.add_argument('shift', metavar='SHIFT', type=int, help='How many days in advance to predict.')\n    options = parser.parse_args()\n    if not tickers:\n        print('\"No tickers available. Unable to predict.')\n        raise SystemExit\n    ticker = options.ticker\n    if ticker not in tickers:\n        print('\"ticker\" must be one of %s' % tickers)\n        raise SystemExit\n    try:\n        start_date = pd.to_datetime(options.start_date)\n    except ValueError:\n        print('\"start_date\" must be a valid date. Not %s' % start_date)\n        raise SystemExit\n    try:\n        end_date = pd.to_datetime(options.end_date)\n    except ValueError:\n        print('\"end_date\" must be a valid date. Not %s' % end_date)\n        raise SystemExit\n    shift = options.shift\n    if shift <= 0:\n        print('\"shift\" must be a positive integer')\n        raise SystemExit\n    print('Loading data...')\n    X, y, tX, _, scaler = models.get_processed_dataset(ticker, 0.9999999999, shift, 0, False, start_date, end_date)\n    print('Training model...')\n    _, _, model = models.cross_validate_model('huber', X, y)\n    print('Predicting...')\n    yhat = model.predict(tX)\n    prediction = scaler.inverse_transform(np.array([[yhat[0]] + [0] * (X.shape[1] - 1)]))\n    print('Predicted value:', prediction[0, 0])", "refactored": true, "pred": {"ppl": 2.7589690685272217, "ppl_lower": 2.997211217880249, "ppl/lowercase_ppl": -1.0816126521990788, "ppl/zlib": 0.0011732451838785555, "Min_5.0% Prob": 7.981057536217474, "Min_10.0% Prob": 6.479081019278495, "Min_20.0% Prob": 4.482341221809387, "Min_30.0% Prob": 3.2983926999125073, "Min_40.0% Prob": 2.525874408563057, "Min_50.0% Prob": 2.028156441861799, "Min_60.0% Prob": 1.694815573688755}}
{"hexsha": "73ef8d1f69375bfcaedacdc382f9d2e3fbedc2b8", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef sig_gen_multi(public_as, private_as, public_ams, private_ams, body, amsh, arsh, fold=False, verbose=False, as_tmp=None, ams_tmp=None):\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h.update(body)\n    bh = base64.b64encode(h.digest())\n    print('ams bh= ')\n    print(bh)\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h = HashThrough(hasher())\n    h.update(b'\\r\\n'.join([x + b':' + y for x, y in amsh(bh)]))\n    if verbose:\n        print('\\nsign ams hashed: %r' % h.hashed())\n    pk = parse_pem_private_key(private_ams)\n    sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)\n    msb = base64.b64encode(bytes(sig2))\n    if fold:\n        msb = msb[:70] + b' ' + msb[70:142] + b' ' + msb[142:214]\n    print('ams b= ')\n    print(msb)\n    pk_ams = parse_public_key(base64.b64decode(public_ams))\n    signature = base64.b64decode(msb)\n    ams_valid = RSASSA_PKCS1_v1_5_verify(h, signature, pk_ams)\n    print('ams sig valid: %r' % ams_valid)\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h = HashThrough(hasher())\n    h.update(b'\\r\\n'.join([x + b':' + y for x, y in arsh(msb, bh)]))\n    if verbose:\n        print('\\nsign ars hashed: %r' % h.hashed())\n    pk = parse_pem_private_key(private_as)\n    sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)\n    sb = base64.b64encode(bytes(sig2))\n    print('arsh b=')\n    print(sb)\n    pk_as = parse_public_key(base64.b64decode(public_as))\n    signature = base64.b64decode(sb)\n    ams_valid = RSASSA_PKCS1_v1_5_verify(h, signature, pk_as)\n    print('arsh sig valid: %r' % ams_valid)\n    spc = fold and b'' or b'  '\n    accum = ''\n    if as_tmp:\n        sb = sb[:70] + b'\\n    ' + spc + sb[70:142] + b'\\n    ' + spc + sb[142:214]\n        res = as_tmp.replace(b'%b', sb)\n        accum = res\n        print(res.decode('utf-8'))\n    if ams_tmp:\n        msb = msb.replace(b' ', b'')\n        msb = msb[:70] + b'\\n    ' + spc + msb[70:142] + b'\\n    ' + spc + msb[142:214]\n        res = ams_tmp.replace(b'%bh', bh)\n        res = res.replace(b'%b', msb)\n        accum += b'\\n' + res\n        print(res.decode('utf-8'))\n    os.system(b'echo \"' + accum + b'\" | pbcopy')", "fn_id": 1, "class_fn": false, "repo": "ValiMail/arc_test_suite", "file": "sig_gen/sig_gen.py", "last_update_at": "2021-02-25T00:59:54+00:00", "original_content": "def sig_gen_multi(public_as, private_as, public_ams, private_ams, body, amsh, arsh, fold=False, verbose=False, as_tmp=None, ams_tmp=None):\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h.update(body)\n    bh = base64.b64encode(h.digest())\n    print('ams bh= ')\n    print(bh)\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h = HashThrough(hasher())\n    h.update(b'\\r\\n'.join([x + b':' + y for x, y in amsh(bh)]))\n    if verbose:\n        print('\\nsign ams hashed: %r' % h.hashed())\n    pk = parse_pem_private_key(private_ams)\n    sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)\n    msb = base64.b64encode(bytes(sig2))\n    if fold:\n        msb = msb[:70] + b' ' + msb[70:142] + b' ' + msb[142:214]\n    print('ams b= ')\n    print(msb)\n    pk_ams = parse_public_key(base64.b64decode(public_ams))\n    signature = base64.b64decode(msb)\n    ams_valid = RSASSA_PKCS1_v1_5_verify(h, signature, pk_ams)\n    print('ams sig valid: %r' % ams_valid)\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h = HashThrough(hasher())\n    h.update(b'\\r\\n'.join([x + b':' + y for x, y in arsh(msb, bh)]))\n    if verbose:\n        print('\\nsign ars hashed: %r' % h.hashed())\n    pk = parse_pem_private_key(private_as)\n    sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)\n    sb = base64.b64encode(bytes(sig2))\n    print('arsh b=')\n    print(sb)\n    pk_as = parse_public_key(base64.b64decode(public_as))\n    signature = base64.b64decode(sb)\n    ams_valid = RSASSA_PKCS1_v1_5_verify(h, signature, pk_as)\n    print('arsh sig valid: %r' % ams_valid)\n    spc = fold and b'' or b'  '\n    accum = ''\n    if as_tmp:\n        sb = sb[:70] + b'\\n    ' + spc + sb[70:142] + b'\\n    ' + spc + sb[142:214]\n        res = as_tmp.replace(b'%b', sb)\n        accum = res\n        print(res.decode('utf-8'))\n    if ams_tmp:\n        msb = msb.replace(b' ', b'')\n        msb = msb[:70] + b'\\n    ' + spc + msb[70:142] + b'\\n    ' + spc + msb[142:214]\n        res = ams_tmp.replace(b'%bh', bh)\n        res = res.replace(b'%b', msb)\n        accum += b'\\n' + res\n        print(res.decode('utf-8'))\n    os.system(b'echo \"' + accum + b'\" | pbcopy')", "refactored": true, "pred": {"ppl": 2.67826509475708, "ppl_lower": 2.7879679203033447, "ppl/lowercase_ppl": -1.040748079594578, "ppl/zlib": 0.0014340163496316606, "Min_5.0% Prob": 9.189133677371712, "Min_10.0% Prob": 7.233916496408397, "Min_20.0% Prob": 4.674390303066799, "Min_30.0% Prob": 3.2605792544073933, "Min_40.0% Prob": 2.4606768198290103, "Min_50.0% Prob": 1.9696989006241932, "Min_60.0% Prob": 1.644337490731505}}
{"hexsha": "8e27225db54d8f1ce0cedbcc4f4b9dfe2b6fdaf9", "ext": "py", "lang": "Python", "content": "def draw_iterations(g, eval_map_function, x0, n):\n\n    @timeing\n    @measure_memory_usage\n    def draw_mid_point_arrows(x, x_next, both=True):\n        if x_next > x:\n            arrow_direction_angles = (0.5 * math.pi, 0)\n        else:\n            arrow_direction_angles = (-0.5 * math.pi, math.pi)\n        g.draw_arrow_tip((x, mid_value), arrow_direction_angles[0])\n        if both:\n            g.draw_arrow_tip((mid_value, x_next), arrow_direction_angles[1])\n    xs = [x0]\n    for i in range(n):\n        xs.append(eval_map_function(xs[-1]))\n    g.set_dash_dash_structure(12, 4, units='svg')\n    g.set_dash_mode('dash')\n    g.set_svg_options(stroke_width=iterations_stroke_w, units='svg')\n    g.set_arrow_options(width=iteration_arrow_rel_size * arrow_size, curvature=0, units='svg')\n    g.set_point_size(0.01)\n    g.draw_line_segment((x0, 0), (x0, x0))\n    for i, x in enumerate(xs[:-2]):\n        x_next = xs[i + 1]\n        g.draw_polyline([(x, x), (x, x_next), (x_next, x_next)])\n        mid_value = 0.5 * (x + x_next)\n        draw_mid_point_arrows(x, x_next)\n    g.draw_polyline([(xs[-2], xs[-2]), (xs[-2], xs[-1])])\n    g.draw_point((xs[-2], xs[-1]))\n    draw_mid_point_arrows(xs[-2], xs[-1], both=False)\n    g.reset_dash_and_dot_structures()", "fn_id": 2, "class_fn": false, "repo": "alexn11/mathsvg", "file": "more-examples/iteration-graph.py", "last_update_at": "2021-11-27T08:46:20+00:00", "original_content": "def draw_iterations(g, eval_map_function, x0, n):\n\n    def draw_mid_point_arrows(x, x_next, both=True):\n        if x_next > x:\n            arrow_direction_angles = (0.5 * math.pi, 0)\n        else:\n            arrow_direction_angles = (-0.5 * math.pi, math.pi)\n        g.draw_arrow_tip((x, mid_value), arrow_direction_angles[0])\n        if both:\n            g.draw_arrow_tip((mid_value, x_next), arrow_direction_angles[1])\n    xs = [x0]\n    for i in range(n):\n        xs.append(eval_map_function(xs[-1]))\n    g.set_dash_dash_structure(12, 4, units='svg')\n    g.set_dash_mode('dash')\n    g.set_svg_options(stroke_width=iterations_stroke_w, units='svg')\n    g.set_arrow_options(width=iteration_arrow_rel_size * arrow_size, curvature=0, units='svg')\n    g.set_point_size(0.01)\n    g.draw_line_segment((x0, 0), (x0, x0))\n    for i, x in enumerate(xs[:-2]):\n        x_next = xs[i + 1]\n        g.draw_polyline([(x, x), (x, x_next), (x_next, x_next)])\n        mid_value = 0.5 * (x + x_next)\n        draw_mid_point_arrows(x, x_next)\n    g.draw_polyline([(xs[-2], xs[-2]), (xs[-2], xs[-1])])\n    g.draw_point((xs[-2], xs[-1]))\n    draw_mid_point_arrows(xs[-2], xs[-1], both=False)\n    g.reset_dash_and_dot_structures()", "refactored": true, "pred": {"ppl": 3.5349135398864746, "ppl_lower": 3.608332633972168, "ppl/lowercase_ppl": -1.0162802980400778, "ppl/zlib": 0.0025406214099454997, "Min_5.0% Prob": 10.362167088881783, "Min_10.0% Prob": 8.126389565675154, "Min_20.0% Prob": 5.461585122606029, "Min_30.0% Prob": 4.0551497141520185, "Min_40.0% Prob": 3.128589172621031, "Min_50.0% Prob": 2.524002480477869, "Min_60.0% Prob": 2.1094606037181047}}
{"hexsha": "47fe8ba25f624d3f52e3accc1fc3872135959f05", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef main(args):\n    \"\"\"\n    The starting point of the program.\n    \"\"\"\n    while True:\n        num_items = 1\n        read_data = ReadData() if len(args) == 1 else ReadData(args)\n        data_log_df = get_file_df(read_data.get_data_log())\n        exe_table_df = get_file_df(read_data.get_exe_table())\n        doses_delta_df = get_file_df(read_data.get_doses_delta())\n        summary = get_summary(read_data.get_summary())\n        dfs = [('data_log', data_log_df[-num_items:]), ('exe_table', exe_table_df[-num_items:]), ('doses_delta', doses_delta_df[-num_items:])]\n        data_json = get_json(dfs, summary, read_data.json_name)\n        read_data.json = data_json\n        time.sleep(5)", "fn_id": 3, "class_fn": false, "repo": "cs481-ekh/s21-team-jat", "file": "python/read_data.py", "last_update_at": "2021-04-06T17:16:24+00:00", "original_content": "def main(args):\n    \"\"\"\n    The starting point of the program.\n    \"\"\"\n    while True:\n        num_items = 1\n        read_data = ReadData() if len(args) == 1 else ReadData(args)\n        data_log_df = get_file_df(read_data.get_data_log())\n        exe_table_df = get_file_df(read_data.get_exe_table())\n        doses_delta_df = get_file_df(read_data.get_doses_delta())\n        summary = get_summary(read_data.get_summary())\n        dfs = [('data_log', data_log_df[-num_items:]), ('exe_table', exe_table_df[-num_items:]), ('doses_delta', doses_delta_df[-num_items:])]\n        data_json = get_json(dfs, summary, read_data.json_name)\n        read_data.json = data_json\n        time.sleep(5)", "refactored": true, "pred": {"ppl": 3.9276044368743896, "ppl_lower": 4.442816257476807, "ppl/lowercase_ppl": -1.0900994965505706, "ppl/zlib": 0.004560098939926346, "Min_5.0% Prob": 10.198830864646219, "Min_10.0% Prob": 8.402681081191353, "Min_20.0% Prob": 6.0228227757393045, "Min_30.0% Prob": 4.402609896491951, "Min_40.0% Prob": 3.4158813985104257, "Min_50.0% Prob": 2.7396327076574503, "Min_60.0% Prob": 2.282090596828452}}
{"hexsha": "7848c02f06f57265c259b7cf28bbf7fbc43f4a4a", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef fecha_caixa():\n    global aberto\n    tot = 0\n    for elemento in transacoes_finalizadas:\n        tot += elemento[1]\n    print(f'TOTAL DE VENDAS R${tot:.2f}')\n    print()\n    while len(transacoes_finalizadas) != 0:\n        print('ELIMINE AS TRANSA\u00c7\u00d5ES FINALIZADAS:')\n        for i, elemento in enumerate(transacoes_finalizadas):\n            print(f'{i:<1}', end='|    ')\n            print(f'{elemento[0]:<17}', end='|')\n            print(f'{elemento[1]:>5.2f}')\n        try:\n            aux = int(input(''))\n            tot -= transacoes_finalizadas[aux][1]\n            tot = round(tot, 2)\n            transacoes_finalizadas.pop(aux)\n        except ValueError:\n            print('[ERRO]: Digite valores v\u00e1lidos')\n            return fecha_caixa()\n        except IndexError:\n            print(f' Indice <= {len(transacoes_finalizadas)}')\n    print(f'TRANSA\u00c7\u00d5ES ELIMINADAS TOTAL: R${tot}')\n    print('CAIXA FECHADO COM SUCESSO!')\n    aberto = False", "fn_id": 17, "class_fn": false, "repo": "FelipeECarvalho/Projetos", "file": "Sistema Caixa Supermercados/principal.py", "last_update_at": "2021-08-22T17:10:08+00:00", "original_content": "def fecha_caixa():\n    global aberto\n    tot = 0\n    for elemento in transacoes_finalizadas:\n        tot += elemento[1]\n    print(f'TOTAL DE VENDAS R${tot:.2f}')\n    print()\n    while len(transacoes_finalizadas) != 0:\n        print('ELIMINE AS TRANSA\u00c7\u00d5ES FINALIZADAS:')\n        for i, elemento in enumerate(transacoes_finalizadas):\n            print(f'{i:<1}', end='|    ')\n            print(f'{elemento[0]:<17}', end='|')\n            print(f'{elemento[1]:>5.2f}')\n        try:\n            aux = int(input(''))\n            tot -= transacoes_finalizadas[aux][1]\n            tot = round(tot, 2)\n            transacoes_finalizadas.pop(aux)\n        except ValueError:\n            print('[ERRO]: Digite valores v\u00e1lidos')\n            return fecha_caixa()\n        except IndexError:\n            print(f' Indice <= {len(transacoes_finalizadas)}')\n    print(f'TRANSA\u00c7\u00d5ES ELIMINADAS TOTAL: R${tot}')\n    print('CAIXA FECHADO COM SUCESSO!')\n    aberto = False", "refactored": true, "pred": {"ppl": 3.6765477657318115, "ppl_lower": 4.634505271911621, "ppl/lowercase_ppl": -1.1778493385511002, "ppl/zlib": 0.0028120393191033645, "Min_5.0% Prob": 10.225714547293526, "Min_10.0% Prob": 8.292155232922784, "Min_20.0% Prob": 5.666360188338716, "Min_30.0% Prob": 4.214715417135846, "Min_40.0% Prob": 3.2409453972921534, "Min_50.0% Prob": 2.5998960566782467, "Min_60.0% Prob": 2.1767511339174153}}
{"hexsha": "c370b87e8143a97ff5064d02515dc7a0a2cf09a6", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef patch():\n    global _patched\n    if not _patched:\n        conf.Settings = Settings\n        conf.LazySettings = LazySettings\n        conf.settings = settings\n        _patched = True", "fn_id": 0, "class_fn": false, "repo": "jayvdb/django-service-urls", "file": "service_urls/patch.py", "last_update_at": "2021-01-13T02:41:26+00:00", "original_content": "def patch():\n    global _patched\n    if not _patched:\n        conf.Settings = Settings\n        conf.LazySettings = LazySettings\n        conf.settings = settings\n        _patched = True", "refactored": true, "pred": {"ppl": 7.158792972564697, "ppl_lower": 11.93605899810791, "ppl/lowercase_ppl": -1.2597225268203824, "ppl/zlib": 0.016002775508217354, "Min_5.0% Prob": 11.036725044250488, "Min_10.0% Prob": 10.003520131111145, "Min_20.0% Prob": 7.568093299865723, "Min_30.0% Prob": 5.94993645804269, "Min_40.0% Prob": 4.803918571848619, "Min_50.0% Prob": 3.894930557658275, "Min_60.0% Prob": 3.35978129612548}}
{"hexsha": "a9d142291ba38842e31d3177869d6447f084d025", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef time_model(model: nn.Module, test_set: Type[LightFieldDataset], device) -> np.ndarray:\n    model.eval()\n    custom = CustomProgressBar('N/A')\n    loader = torch.utils.data.DataLoader(dataset=test_set, batch_size=1, sampler=SequentialSampler(test_set), num_workers=1, pin_memory=True)\n    test_set.set_only_x_dataset()\n    model.eval()\n    torch.set_grad_enabled(False)\n    print('Timing')\n    all_times = []\n    for input_data in custom.bar(loader):\n        tick = time.time()\n        input_var = input_data.to(device).float().div_(255.0)\n        _ = model(input_var)\n        tock = time.time()\n        time_taken = tock - tick\n        all_times.append(time_taken)\n    test_set.revert_only_x_dataset()\n    return np.array(all_times)", "fn_id": 0, "class_fn": false, "repo": "leaveitout/deep_light_field_interp", "file": "deeplfinterp/util/train_tools.py", "last_update_at": "2021-08-06T13:39:19+00:00", "original_content": "def time_model(model: nn.Module, test_set: Type[LightFieldDataset], device) -> np.ndarray:\n    model.eval()\n    custom = CustomProgressBar('N/A')\n    loader = torch.utils.data.DataLoader(dataset=test_set, batch_size=1, sampler=SequentialSampler(test_set), num_workers=1, pin_memory=True)\n    test_set.set_only_x_dataset()\n    model.eval()\n    torch.set_grad_enabled(False)\n    print('Timing')\n    all_times = []\n    for input_data in custom.bar(loader):\n        tick = time.time()\n        input_var = input_data.to(device).float().div_(255.0)\n        _ = model(input_var)\n        tock = time.time()\n        time_taken = tock - tick\n        all_times.append(time_taken)\n    test_set.revert_only_x_dataset()\n    return np.array(all_times)", "refactored": true, "pred": {"ppl": 3.635160207748413, "ppl_lower": 4.756925582885742, "ppl/lowercase_ppl": -1.2083816112262948, "ppl/zlib": 0.003132653358428891, "Min_5.0% Prob": 9.28312436017123, "Min_10.0% Prob": 7.5103142987126885, "Min_20.0% Prob": 5.586111368016994, "Min_30.0% Prob": 4.151727989525862, "Min_40.0% Prob": 3.217498793727473, "Min_50.0% Prob": 2.58849079071098, "Min_60.0% Prob": 2.1565690027953655}}
{"hexsha": "e8bc0e0cfb812d7c32521e012f61a1e17efddd71", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef save_mel_dataset(out_path, *paths, in_db=True, root_path=None):\n    \"\"\"\n    \"\"\"\n    ds_len = len(paths)\n    with IncrementalHDF5(out_path, CONF.NUM_MELS, np.float32) as ihdf5:\n        LOGGER.info(f'Writing to {out_path}')\n        for i, abspath in enumerate(paths, 1):\n            if root_path is not None:\n                metadata_str = str(abspath.relative_to(root_path))\n            else:\n                metadata_str = str(abspath)\n            if i % 100 == 0:\n                LOGGER.info(f'[{i}/{ds_len}] save_mel_dataset: {metadata_str}')\n            arr = wavpath_to_mel(str(abspath), CONF.WAV_SR, wav_norm=CONF.WAV_NORM, n_mels=CONF.NUM_MELS, hop_length=CONF.STFT_HOPSIZE, pad_mode='constant', in_decibels=in_db, logger=LOGGER)\n            if arr is None:\n                continue\n            ihdf5.append(arr, metadata_str)\n            _, arr_w = arr.shape\n            assert (arr == ihdf5.data_ds[:, -arr_w:]).all(), 'Should never happen'\n        LOGGER.info(f'Finished writing to {out_path}')", "fn_id": 1, "class_fn": false, "repo": "andres-fr/dcase2021_umaps", "file": "00c_precompute_fraunhofer_fixed.py", "last_update_at": "2021-11-30T09:28:21+00:00", "original_content": "def save_mel_dataset(out_path, *paths, in_db=True, root_path=None):\n    \"\"\"\n    \"\"\"\n    ds_len = len(paths)\n    with IncrementalHDF5(out_path, CONF.NUM_MELS, np.float32) as ihdf5:\n        LOGGER.info(f'Writing to {out_path}')\n        for i, abspath in enumerate(paths, 1):\n            if root_path is not None:\n                metadata_str = str(abspath.relative_to(root_path))\n            else:\n                metadata_str = str(abspath)\n            if i % 100 == 0:\n                LOGGER.info(f'[{i}/{ds_len}] save_mel_dataset: {metadata_str}')\n            arr = wavpath_to_mel(str(abspath), CONF.WAV_SR, wav_norm=CONF.WAV_NORM, n_mels=CONF.NUM_MELS, hop_length=CONF.STFT_HOPSIZE, pad_mode='constant', in_decibels=in_db, logger=LOGGER)\n            if arr is None:\n                continue\n            ihdf5.append(arr, metadata_str)\n            _, arr_w = arr.shape\n            assert (arr == ihdf5.data_ds[:, -arr_w:]).all(), 'Should never happen'\n        LOGGER.info(f'Finished writing to {out_path}')", "refactored": true, "pred": {"ppl": 3.835521936416626, "ppl_lower": 4.488982677459717, "ppl/lowercase_ppl": -1.1170273977303018, "ppl/zlib": 0.002651490184835646, "Min_5.0% Prob": 10.166665226221085, "Min_10.0% Prob": 8.333345726132393, "Min_20.0% Prob": 5.95253105530372, "Min_30.0% Prob": 4.329899423584646, "Min_40.0% Prob": 3.3252741013091938, "Min_50.0% Prob": 2.6847545383725224, "Min_60.0% Prob": 2.242745112476464}}
{"hexsha": "5a93cf64a2f1ac340c8208f986a4fd8f35d03148", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef view(location, browser=None, new='same', autoraise=True):\n    \"\"\" Opens a browser to view the specified location.\n\n        Args:\n            location (str) : location to open\n                If location does not begin with \"http:\" it is assumed\n                to be a file path on the local filesystem.\n            browser (str) : what browser to use\n            new (str) : how to open the location\n                Valid values are:\n                    * \"same\" - open in the current tab\n                    * \"tab\" - open a new tab in the current window\n                    * \"window\" - open in a new window\n            autoraise (bool) : whether to raise the new location\n\n        Returns:\n            None\n\n        \"\"\"\n    new_map = {'same': 0, 'window': 1, 'tab': 2}\n    if location.startswith('http'):\n        url = location\n    else:\n        url = 'file://' + abspath(location)\n    try:\n        controller = get_browser_controller(browser)\n        controller.open(url, new=new_map[new], autoraise=autoraise)\n    except (SystemExit, KeyboardInterrupt):\n        raise\n    except:\n        pass", "fn_id": 1, "class_fn": false, "repo": "tswicegood/bokeh", "file": "bokeh/browserlib.py", "last_update_at": "2021-11-17T10:48:36+00:00", "original_content": "def view(location, browser=None, new='same', autoraise=True):\n    \"\"\" Opens a browser to view the specified location.\n\n        Args:\n            location (str) : location to open\n                If location does not begin with \"http:\" it is assumed\n                to be a file path on the local filesystem.\n            browser (str) : what browser to use\n            new (str) : how to open the location\n                Valid values are:\n                    * \"same\" - open in the current tab\n                    * \"tab\" - open a new tab in the current window\n                    * \"window\" - open in a new window\n            autoraise (bool) : whether to raise the new location\n\n        Returns:\n            None\n\n        \"\"\"\n    new_map = {'same': 0, 'window': 1, 'tab': 2}\n    if location.startswith('http'):\n        url = location\n    else:\n        url = 'file://' + abspath(location)\n    try:\n        controller = get_browser_controller(browser)\n        controller.open(url, new=new_map[new], autoraise=autoraise)\n    except (SystemExit, KeyboardInterrupt):\n        raise\n    except:\n        pass", "refactored": true, "pred": {"ppl": 3.324589729309082, "ppl_lower": 3.9138543605804443, "ppl/lowercase_ppl": -1.135827933003797, "ppl/zlib": 0.0024075075687639384, "Min_5.0% Prob": 8.72600375688993, "Min_10.0% Prob": 7.18628270809467, "Min_20.0% Prob": 5.255584042805892, "Min_30.0% Prob": 3.883926753050242, "Min_40.0% Prob": 2.9776755468203473, "Min_50.0% Prob": 2.3976262838508076, "Min_60.0% Prob": 2.0012418130854477}}
{"hexsha": "ad091436c7271a654fb820601c6d942f23f49ff5", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_rna(fq_dict):\n    \"\"\"\n    Obtain a numpy array with all detected spots in the image. Detection results\n    are saved in a dictionary (see read_FQ_results_matlab for more details).\n    \"\"\"\n    RNAall = nested_lookup('spots', fq_dict)\n    for idx, val in enumerate(RNAall):\n        if idx == 0:\n            spots_all = np.copy(val)\n        else:\n            spots_all = np.append(spots_all, val, axis=0)\n    return spots_all", "fn_id": 3, "class_fn": false, "repo": "muellerflorian/parker-rna-loc-elegans", "file": "rnaloc/FQtoolbox.py", "last_update_at": "2021-01-12T16:51:38+00:00", "original_content": "def get_rna(fq_dict):\n    \"\"\"\n    Obtain a numpy array with all detected spots in the image. Detection results\n    are saved in a dictionary (see read_FQ_results_matlab for more details).\n    \"\"\"\n    RNAall = nested_lookup('spots', fq_dict)\n    for idx, val in enumerate(RNAall):\n        if idx == 0:\n            spots_all = np.copy(val)\n        else:\n            spots_all = np.append(spots_all, val, axis=0)\n    return spots_all", "refactored": true, "pred": {"ppl": 6.5017781257629395, "ppl_lower": 6.623969554901123, "ppl/lowercase_ppl": -1.0099457108586436, "ppl/zlib": 0.006908028403325311, "Min_5.0% Prob": 10.564033508300781, "Min_10.0% Prob": 8.930326351752647, "Min_20.0% Prob": 7.1266851883668165, "Min_30.0% Prob": 5.6511630594730375, "Min_40.0% Prob": 4.5875652882288085, "Min_50.0% Prob": 3.727367591057251, "Min_60.0% Prob": 3.1333608468063177}}
{"hexsha": "8b2fa9137563469049632eeb151af101a87de1b0", "ext": "py", "lang": "Python", "content": "@client.event\n@timeing\n@measure_memory_usage\nasync def on_message(message):\n    if message.author == client.user:\n        if message.content == 'Authentication invalid':\n            await renew_auth(message)\n        return\n    if message.content.startswith('>'):\n        return\n        await parse(message)\n    if isinstance(message.channel, discord.channel.DMChannel):\n        if message.content == 'quit':\n            await do_quit(message)\n        if message.content == 'test':\n            return\n            await do_tests(message)\n        if message.content == 'renew' or message.content == 'reset':\n            await renew_auth(message)\n    if message.content.startswith('/'):\n        await client.process_commands(message)", "fn_id": 5, "class_fn": false, "repo": "joshmiller17/venntbot", "file": "venntbot.py", "last_update_at": "2021-09-11T23:15:38+00:00", "original_content": "@client.event\nasync def on_message(message):\n    if message.author == client.user:\n        if message.content == 'Authentication invalid':\n            await renew_auth(message)\n        return\n    if message.content.startswith('>'):\n        return\n        await parse(message)\n    if isinstance(message.channel, discord.channel.DMChannel):\n        if message.content == 'quit':\n            await do_quit(message)\n        if message.content == 'test':\n            return\n            await do_tests(message)\n        if message.content == 'renew' or message.content == 'reset':\n            await renew_auth(message)\n    if message.content.startswith('/'):\n        await client.process_commands(message)", "refactored": true, "pred": {"ppl": 3.83493971824646, "ppl_lower": 4.408315658569336, "ppl/lowercase_ppl": -1.1036629681347063, "ppl/zlib": 0.005015498939757907, "Min_5.0% Prob": 9.8638916015625, "Min_10.0% Prob": 8.315688967704773, "Min_20.0% Prob": 5.774638053142663, "Min_30.0% Prob": 4.277466738710598, "Min_40.0% Prob": 3.3024463364572236, "Min_50.0% Prob": 2.668800861630813, "Min_60.0% Prob": 2.249218715938053}}
{"hexsha": "385dabe838e94b3bc682d337123e8384c47a3724", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef parse_patterns(query, graph=False):\n    \"\"\"\n    if query['patterns'] looks like so:\n    ['target_type=', 'what=', '!tag_k=not_equals_thistag_v', 'tag_k:match_this_val', 'arbitrary', 'words']\n\n    then the patterns will look like so:\n    {\n    'tag_k=not_equals_thistag_v': {'negate': True, 'match_tag_equality': ['tag_k', 'not_equals_thistag_v']},\n    'target_type=':               {'negate': False, 'match_tag_equality': ['target_type', '']},\n    'what=':                      {'negate': False, 'match_tag_equality': ['what', '']},\n    'tag_k:match_this_val':       {'negate': False, 'match_tag_regex': ['tag_k', 'match_this_val']},\n    'words':                      {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x2612cb0>},\n    'arbitrary':                  {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x7f6cc000bd90>}\n    }\n    \"\"\"\n    patterns = {}\n    for pattern in query['patterns']:\n        negate = False\n        if pattern.startswith('!'):\n            negate = True\n            pattern = pattern[1:]\n        patterns[pattern] = {'negate': negate}\n        if '=' in pattern:\n            if not graph or pattern not in ('target_type=', 'what='):\n                patterns[pattern]['match_tag_equality'] = pattern.split('=')\n            else:\n                del patterns[pattern]\n        elif ':' in pattern:\n            if not graph or pattern not in ('target_type:', 'what:'):\n                patterns[pattern]['match_tag_regex'] = pattern.split(':')\n            else:\n                del patterns[pattern]\n        else:\n            patterns[pattern]['match_id_regex'] = re.compile(pattern)\n    return patterns", "fn_id": 2, "class_fn": false, "repo": "bittorrent/graph-explorer", "file": "query.py", "last_update_at": "2021-03-14T19:37:11+00:00", "original_content": "def parse_patterns(query, graph=False):\n    \"\"\"\n    if query['patterns'] looks like so:\n    ['target_type=', 'what=', '!tag_k=not_equals_thistag_v', 'tag_k:match_this_val', 'arbitrary', 'words']\n\n    then the patterns will look like so:\n    {\n    'tag_k=not_equals_thistag_v': {'negate': True, 'match_tag_equality': ['tag_k', 'not_equals_thistag_v']},\n    'target_type=':               {'negate': False, 'match_tag_equality': ['target_type', '']},\n    'what=':                      {'negate': False, 'match_tag_equality': ['what', '']},\n    'tag_k:match_this_val':       {'negate': False, 'match_tag_regex': ['tag_k', 'match_this_val']},\n    'words':                      {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x2612cb0>},\n    'arbitrary':                  {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x7f6cc000bd90>}\n    }\n    \"\"\"\n    patterns = {}\n    for pattern in query['patterns']:\n        negate = False\n        if pattern.startswith('!'):\n            negate = True\n            pattern = pattern[1:]\n        patterns[pattern] = {'negate': negate}\n        if '=' in pattern:\n            if not graph or pattern not in ('target_type=', 'what='):\n                patterns[pattern]['match_tag_equality'] = pattern.split('=')\n            else:\n                del patterns[pattern]\n        elif ':' in pattern:\n            if not graph or pattern not in ('target_type:', 'what:'):\n                patterns[pattern]['match_tag_regex'] = pattern.split(':')\n            else:\n                del patterns[pattern]\n        else:\n            patterns[pattern]['match_id_regex'] = re.compile(pattern)\n    return patterns", "refactored": true, "pred": {"ppl": 2.8694424629211426, "ppl_lower": 3.017702579498291, "ppl/lowercase_ppl": -1.04779168137926, "ppl/zlib": 0.002023258631687779, "Min_5.0% Prob": 9.13646916548411, "Min_10.0% Prob": 7.461646894613902, "Min_20.0% Prob": 4.9160029826704985, "Min_30.0% Prob": 3.480559577715808, "Min_40.0% Prob": 2.628520041992216, "Min_50.0% Prob": 2.1114045183659216, "Min_60.0% Prob": 1.7566963298193456}}
{"hexsha": "c465816e2eca187bfd4fc478284eec3b6c703e51", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef generalInquiry(choiceList, message):\n    choiceList.append(colored('Return', 'red'))\n    options = [inquirer.List('inputVal', message=message, choices=choiceList)]\n    print(colored('Use arrow keys to navigate\\n', 'blue'))\n    print(colored('Proceed --> Enter / Return key\\n', 'green'))\n    return inquirer.prompt(options)['inputVal']", "fn_id": 15, "class_fn": false, "repo": "HiLabTufts/GailBot-3", "file": "gailbot-3.py", "last_update_at": "2021-06-28T10:26:20+00:00", "original_content": "def generalInquiry(choiceList, message):\n    choiceList.append(colored('Return', 'red'))\n    options = [inquirer.List('inputVal', message=message, choices=choiceList)]\n    print(colored('Use arrow keys to navigate\\n', 'blue'))\n    print(colored('Proceed --> Enter / Return key\\n', 'green'))\n    return inquirer.prompt(options)['inputVal']", "refactored": true, "pred": {"ppl": 8.503805160522461, "ppl_lower": 10.854001998901367, "ppl/lowercase_ppl": -1.1140007313196505, "ppl/zlib": 0.009471299687024716, "Min_5.0% Prob": 11.469852828979493, "Min_10.0% Prob": 9.942226886749268, "Min_20.0% Prob": 8.059290051460266, "Min_30.0% Prob": 6.509184634685516, "Min_40.0% Prob": 5.201973442733288, "Min_50.0% Prob": 4.2448174482584, "Min_60.0% Prob": 3.559161358575026}}
{"hexsha": "3b7d7e72a7f0b786dd6d72495ed17a1c7b0e1e9f", "ext": "py", "lang": "Python", "content": "@card('Rolling Spoil')\ndef rolling_spoil(card, abilities):\n\n    @timeing\n    @measure_memory_usage\n    def rolling_spoil():\n        return AbilityNotImplemented\n    return (rolling_spoil,)", "fn_id": 155, "class_fn": false, "repo": "Julian/cardboard", "file": "cardboard/cards/sets/ravnica_city_of_guilds.py", "last_update_at": "2021-05-29T06:00:40+00:00", "original_content": "@card('Rolling Spoil')\ndef rolling_spoil(card, abilities):\n\n    def rolling_spoil():\n        return AbilityNotImplemented\n    return (rolling_spoil,)", "refactored": true, "pred": {"ppl": 23.790372848510742, "ppl_lower": 36.05373764038086, "ppl/lowercase_ppl": -1.1311747180057177, "ppl/zlib": 0.024568069741712762, "Min_5.0% Prob": 14.415420055389404, "Min_10.0% Prob": 12.355581998825073, "Min_20.0% Prob": 10.208032025231255, "Min_30.0% Prob": 8.710013593946185, "Min_40.0% Prob": 7.489037488636217, "Min_50.0% Prob": 6.355574583013852, "Min_60.0% Prob": 5.331257211750951}}
{"hexsha": "d090023df2a9fa2d3a531ad91449ef05aefa4e12", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef dice_loss(pred, target, smooth=1.0):\n    pred = pred.contiguous()\n    target = target.contiguous()\n    intersection = (pred * target).sum(dim=1).sum(dim=1)\n    loss = 1 - (2.0 * intersection + smooth) / (pred.sum(dim=1).sum(dim=1) + target.sum(dim=1).sum(dim=1) + smooth)\n    return loss.mean()", "fn_id": 1, "class_fn": false, "repo": "rispoli-lab/Deep-Learning-Breast-FGT", "file": "loss.py", "last_update_at": "2021-09-17T17:10:52+00:00", "original_content": "def dice_loss(pred, target, smooth=1.0):\n    pred = pred.contiguous()\n    target = target.contiguous()\n    intersection = (pred * target).sum(dim=1).sum(dim=1)\n    loss = 1 - (2.0 * intersection + smooth) / (pred.sum(dim=1).sum(dim=1) + target.sum(dim=1).sum(dim=1) + smooth)\n    return loss.mean()", "refactored": true, "pred": {"ppl": 1.9547587633132935, "ppl_lower": 1.9547587633132935, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0038300959491366607, "Min_5.0% Prob": 7.752908229827881, "Min_10.0% Prob": 5.443957068703392, "Min_20.0% Prob": 3.3286509215831757, "Min_30.0% Prob": 2.2295235831509617, "Min_40.0% Prob": 1.6938290148973465, "Min_50.0% Prob": 1.3397893818552817, "Min_60.0% Prob": 1.123573408849017}}
{"hexsha": "20fd1f5105839af2bba28ff254523016e1e09b8f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _get_pipeline_definition_args(dag):\n    check.inst_param(dag, 'dag', DAG)\n    pipeline_dependencies = {}\n    solid_defs = []\n    seen_tasks = []\n    dag_roots = sorted(dag.roots, key=lambda x: x.task_id)\n    for task in dag_roots:\n        _traverse_airflow_dag(task, seen_tasks, pipeline_dependencies, solid_defs)\n    return (pipeline_dependencies, solid_defs)", "fn_id": 1, "class_fn": false, "repo": "uranusbeam/bit-dagster", "file": "python_modules/libraries/dagster-airflow/dagster_airflow/dagster_pipeline_factory.py", "last_update_at": "2021-11-08T02:10:42+00:00", "original_content": "def _get_pipeline_definition_args(dag):\n    check.inst_param(dag, 'dag', DAG)\n    pipeline_dependencies = {}\n    solid_defs = []\n    seen_tasks = []\n    dag_roots = sorted(dag.roots, key=lambda x: x.task_id)\n    for task in dag_roots:\n        _traverse_airflow_dag(task, seen_tasks, pipeline_dependencies, solid_defs)\n    return (pipeline_dependencies, solid_defs)", "refactored": true, "pred": {"ppl": 4.199489116668701, "ppl_lower": 4.514114856719971, "ppl/lowercase_ppl": -1.0503471167660248, "ppl/zlib": 0.006406084281260306, "Min_5.0% Prob": 8.505488681793214, "Min_10.0% Prob": 7.598019296472723, "Min_20.0% Prob": 5.977459316668303, "Min_30.0% Prob": 4.529350083214896, "Min_40.0% Prob": 3.597466241406358, "Min_50.0% Prob": 2.881561362666303, "Min_60.0% Prob": 2.395853008010558}}
{"hexsha": "200733e11c459547d9421419b37fface7ce8edae", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_qcovariate_num_qs(exreaddata):\n    test = covariate.QCovariate()\n    assert test.num_qs() == 0\n    test.consume_read(exreaddata)\n    assert test.num_qs() == 11", "fn_id": 11, "class_fn": false, "repo": "adamjorr/kbbq-py", "file": "tests/test_covariate.py", "last_update_at": "2021-06-02T00:07:35+00:00", "original_content": "def test_qcovariate_num_qs(exreaddata):\n    test = covariate.QCovariate()\n    assert test.num_qs() == 0\n    test.consume_read(exreaddata)\n    assert test.num_qs() == 11", "refactored": true, "pred": {"ppl": 9.998440742492676, "ppl_lower": 10.60062026977539, "ppl/lowercase_ppl": -1.0254007208898324, "ppl/zlib": 0.01784828802391961, "Min_5.0% Prob": 13.03461742401123, "Min_10.0% Prob": 10.280460902622767, "Min_20.0% Prob": 8.396594558443342, "Min_30.0% Prob": 7.018369651976085, "Min_40.0% Prob": 5.6992970790181845, "Min_50.0% Prob": 4.561467044883305, "Min_60.0% Prob": 3.841803894833077}}
{"hexsha": "eac9bfadf6afe42b2ba6db1b9064946fdf240cf1", "ext": "py", "lang": "Python", "content": "@card('Goblin Archaeologist')\n@timeing\n@measure_memory_usage\ndef goblin_archaeologist(card, abilities):\n\n    def goblin_archaeologist():\n        return AbilityNotImplemented\n    return (goblin_archaeologist,)", "fn_id": 17, "class_fn": false, "repo": "Julian/cardboard", "file": "cardboard/cards/sets/darksteel.py", "last_update_at": "2021-05-29T06:00:40+00:00", "original_content": "@card('Goblin Archaeologist')\ndef goblin_archaeologist(card, abilities):\n\n    def goblin_archaeologist():\n        return AbilityNotImplemented\n    return (goblin_archaeologist,)", "refactored": true, "pred": {"ppl": 9.787886619567871, "ppl_lower": 13.103524208068848, "ppl/lowercase_ppl": -1.1278899779649931, "ppl/zlib": 0.017281405771950496, "Min_5.0% Prob": 13.671483675638834, "Min_10.0% Prob": 11.432703971862793, "Min_20.0% Prob": 8.337818622589111, "Min_30.0% Prob": 6.922920252147474, "Min_40.0% Prob": 5.701025495162377, "Min_50.0% Prob": 4.553628846099882, "Min_60.0% Prob": 3.858981767334999}}
{"hexsha": "d2beff782efe625c4f930164ec0ecae6152de846", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_final_seats_occupied_based_on_sight(seats: list[str]) -> int:\n    old_grid = Grid(seats)\n    while (new_grid := transform_based_on_los(old_grid)) != old_grid:\n        old_grid = new_grid\n    return new_grid.count('#')", "fn_id": 2, "class_fn": false, "repo": "pviafore/AdventOfCode2020", "file": "challenge11.py", "last_update_at": "2021-12-09T09:54:54+00:00", "original_content": "def get_final_seats_occupied_based_on_sight(seats: list[str]) -> int:\n    old_grid = Grid(seats)\n    while (new_grid := transform_based_on_los(old_grid)) != old_grid:\n        old_grid = new_grid\n    return new_grid.count('#')", "refactored": true, "pred": {"ppl": 6.694361686706543, "ppl_lower": 6.678310394287109, "ppl/lowercase_ppl": -0.9987373609469162, "ppl/zlib": 0.011183915487096548, "Min_5.0% Prob": 10.069693565368652, "Min_10.0% Prob": 9.077896416187286, "Min_20.0% Prob": 7.42678373000201, "Min_30.0% Prob": 6.0539747333526615, "Min_40.0% Prob": 4.721353442353361, "Min_50.0% Prob": 3.842862980617654, "Min_60.0% Prob": 3.1678987235451737}}
{"hexsha": "65d2c4247e06b070e56286e1c0516a47f5fdba82", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef generate_testcase_files(instance, env, testcase_dir_path):\n    testcases_list = []\n    config = {'config': {'name': instance.name, 'variables': [], 'request': {'base_url': env.base_url if env else ''}}}\n    testcases_list.append(config)\n    include = json.loads(instance.include, encoding='utf-8')\n    request = json.loads(instance.request, encoding='utf-8')\n    module_name = instance.module.name\n    project_name = instance.module.project.name\n    testcase_dir_path = os.path.join(testcase_dir_path, project_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n        debugtalk_obj = Projects.objects.get(name=project_name).debugtalk\n        if debugtalk_obj:\n            debugtalk = debugtalk_obj.debugtalk\n        else:\n            debugtalk = ''\n        with open(os.path.join(testcase_dir_path, 'debugtalk.py'), mode='w', encoding='utf-8') as one_file:\n            one_file.write(debugtalk)\n    testcase_dir_path = os.path.join(testcase_dir_path, module_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n    if 'testcases' in include:\n        for t_id in include.get('testcases'):\n            testcase_obj = Testcases.objects.filter(id=t_id).first()\n            if testcase_obj:\n                try:\n                    testcase_request = json.loads(testcase_obj.request, encoding='utf-8')\n                except Exception as e:\n                    logger.error(e)\n                    continue\n                else:\n                    extract = testcase_request['test'].get('extract')\n                    if extract:\n                        for e in extract:\n                            testcases_list[0]['config']['variables'].append({[i for i in e.keys()][0]: ''})\n                    testcase_request['test'] = OrderedDict(testcase_request['test'])\n                    testcases_list.append(OrderedDict(testcase_request))\n    request['test'] = OrderedDict(request['test'])\n    testcases_list.append(request)\n    with open(os.path.join(testcase_dir_path, instance.name + '.yml'), mode='w', encoding='utf-8') as one_file:\n        ordered_yaml_dump(testcases_list, one_file, default_flow_style=False, allow_unicode=True)", "fn_id": 1, "class_fn": false, "repo": "op896898466/apitest", "file": "utils/common.py", "last_update_at": "2021-08-16T05:48:43+00:00", "original_content": "def generate_testcase_files(instance, env, testcase_dir_path):\n    testcases_list = []\n    config = {'config': {'name': instance.name, 'variables': [], 'request': {'base_url': env.base_url if env else ''}}}\n    testcases_list.append(config)\n    include = json.loads(instance.include, encoding='utf-8')\n    request = json.loads(instance.request, encoding='utf-8')\n    module_name = instance.module.name\n    project_name = instance.module.project.name\n    testcase_dir_path = os.path.join(testcase_dir_path, project_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n        debugtalk_obj = Projects.objects.get(name=project_name).debugtalk\n        if debugtalk_obj:\n            debugtalk = debugtalk_obj.debugtalk\n        else:\n            debugtalk = ''\n        with open(os.path.join(testcase_dir_path, 'debugtalk.py'), mode='w', encoding='utf-8') as one_file:\n            one_file.write(debugtalk)\n    testcase_dir_path = os.path.join(testcase_dir_path, module_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n    if 'testcases' in include:\n        for t_id in include.get('testcases'):\n            testcase_obj = Testcases.objects.filter(id=t_id).first()\n            if testcase_obj:\n                try:\n                    testcase_request = json.loads(testcase_obj.request, encoding='utf-8')\n                except Exception as e:\n                    logger.error(e)\n                    continue\n                else:\n                    extract = testcase_request['test'].get('extract')\n                    if extract:\n                        for e in extract:\n                            testcases_list[0]['config']['variables'].append({[i for i in e.keys()][0]: ''})\n                    testcase_request['test'] = OrderedDict(testcase_request['test'])\n                    testcases_list.append(OrderedDict(testcase_request))\n    request['test'] = OrderedDict(request['test'])\n    testcases_list.append(request)\n    with open(os.path.join(testcase_dir_path, instance.name + '.yml'), mode='w', encoding='utf-8') as one_file:\n        ordered_yaml_dump(testcases_list, one_file, default_flow_style=False, allow_unicode=True)", "refactored": true, "pred": {"ppl": 2.3981404304504395, "ppl_lower": 2.550283670425415, "ppl/lowercase_ppl": -1.0703228865009329, "ppl/zlib": 0.0012769249874154589, "Min_5.0% Prob": 8.556583388098355, "Min_10.0% Prob": 6.381429652036247, "Min_20.0% Prob": 4.092674462735152, "Min_30.0% Prob": 2.880604043770372, "Min_40.0% Prob": 2.181376284974463, "Min_50.0% Prob": 1.748010884807914, "Min_60.0% Prob": 1.4601213626862903}}
{"hexsha": "679616cb8b1011d2bf2813d8352a4c19d23a2b17", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef save_current_window_and_open_tools_window():\n    \"\"\"\n    Save the current window with `save_current_window' and open the eiffel\n    tools buffer in a window. The window containing the eiffel tools buffer\n    will be selected after the launch of this routine. To reselect the\n    window saved by this routine, use the `select_saved_window' routine.\n    \"\"\"\n    tools_buffer_name = environment.get_global_variable('eiffel_tools_buffer_name')\n    tools_buffer_number = get_tools_buffer_number()\n    if tools_buffer_number < 0:\n        save_current_window_and_open_new_tools_window(tools_buffer_name)\n    else:\n        tools_buffer_window_number = int(environment.evaluate('bufwinnr(\"' + tools_buffer_name + '\")'))\n        if tools_buffer_window_number < 0:\n            save_current_window_and_open_existing_tools_window(tools_buffer_name)\n        else:\n            save_current_window_and_select_tools_window(tools_buffer_window_number)\n    environment.execute('setlocal filetype=')", "fn_id": 8, "class_fn": false, "repo": "tioui/Vim_Eiffel_IDE", "file": "pyplugin/eiffel_ide.py", "last_update_at": "2021-11-23T20:12:06+00:00", "original_content": "def save_current_window_and_open_tools_window():\n    \"\"\"\n    Save the current window with `save_current_window' and open the eiffel\n    tools buffer in a window. The window containing the eiffel tools buffer\n    will be selected after the launch of this routine. To reselect the\n    window saved by this routine, use the `select_saved_window' routine.\n    \"\"\"\n    tools_buffer_name = environment.get_global_variable('eiffel_tools_buffer_name')\n    tools_buffer_number = get_tools_buffer_number()\n    if tools_buffer_number < 0:\n        save_current_window_and_open_new_tools_window(tools_buffer_name)\n    else:\n        tools_buffer_window_number = int(environment.evaluate('bufwinnr(\"' + tools_buffer_name + '\")'))\n        if tools_buffer_window_number < 0:\n            save_current_window_and_open_existing_tools_window(tools_buffer_name)\n        else:\n            save_current_window_and_select_tools_window(tools_buffer_window_number)\n    environment.execute('setlocal filetype=')", "refactored": true, "pred": {"ppl": 3.9996895790100098, "ppl_lower": 4.237583637237549, "ppl/lowercase_ppl": -1.041679237343502, "ppl/zlib": 0.003638364180737402, "Min_5.0% Prob": 10.058139140789326, "Min_10.0% Prob": 8.123419143535473, "Min_20.0% Prob": 5.829979372024536, "Min_30.0% Prob": 4.427945743246776, "Min_40.0% Prob": 3.4214926210316743, "Min_50.0% Prob": 2.7716110762018356, "Min_60.0% Prob": 2.3081913579255344}}
{"hexsha": "a1475fa68fd62c2546f13e320d8164046b674af2", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef sub_special_tokens(text):\n    text = re.sub(' www.', ' http://www.', text)\n    text = re.sub('(https|http)?:\\\\/\\\\/(\\\\w|\\\\.|\\\\/|\\\\?|\\\\=|\\\\&|\\\\%)*\\\\b', ' xxurl ', text)\n    pat = '\\\\d{3}[-\\\\.\\\\s]??\\\\d{4}[-\\\\.\\\\s]??\\\\d{4}|\\\\d{5}[-\\\\.\\\\s]??\\\\d{3}[-\\\\.\\\\s]??\\\\d{3}|(?:\\\\d{4}\\\\)?[\\\\s-]?\\\\d{3}[\\\\s-]?\\\\d{4})'\n    text = re.sub(pat, ' xxphone ', text)\n    text = text.replace('\u00a3', '$ ')\n    text = re.sub('(\\\\d+)[ ]{0,1}p', '$ 0.\\x01', text)\n    text = re.sub('\\\\$[ ]*(\\\\d+[,\\\\.])*\\\\d+', ' xxmon ', text)\n    text = re.sub('(\\\\b[A-Z][A-Z0-9]*\\\\b)', ' xxup \\\\1 ', text)\n    text = re.sub('(\\\\b[A-Z][a-z0-9]+\\\\b)', ' xxcap \\\\1 ', text)\n    text = re.sub('[:;][ ]*[-]*[ ]*[()]', ' xxemoji ', text)\n    return text", "fn_id": 0, "class_fn": false, "repo": "rkingery/ml_tutorials", "file": "notebooks/utils.py", "last_update_at": "2021-01-15T10:26:34+00:00", "original_content": "def sub_special_tokens(text):\n    text = re.sub(' www.', ' http://www.', text)\n    text = re.sub('(https|http)?:\\\\/\\\\/(\\\\w|\\\\.|\\\\/|\\\\?|\\\\=|\\\\&|\\\\%)*\\\\b', ' xxurl ', text)\n    pat = '\\\\d{3}[-\\\\.\\\\s]??\\\\d{4}[-\\\\.\\\\s]??\\\\d{4}|\\\\d{5}[-\\\\.\\\\s]??\\\\d{3}[-\\\\.\\\\s]??\\\\d{3}|(?:\\\\d{4}\\\\)?[\\\\s-]?\\\\d{3}[\\\\s-]?\\\\d{4})'\n    text = re.sub(pat, ' xxphone ', text)\n    text = text.replace('\u00a3', '$ ')\n    text = re.sub('(\\\\d+)[ ]{0,1}p', '$ 0.\\x01', text)\n    text = re.sub('\\\\$[ ]*(\\\\d+[,\\\\.])*\\\\d+', ' xxmon ', text)\n    text = re.sub('(\\\\b[A-Z][A-Z0-9]*\\\\b)', ' xxup \\\\1 ', text)\n    text = re.sub('(\\\\b[A-Z][a-z0-9]+\\\\b)', ' xxcap \\\\1 ', text)\n    text = re.sub('[:;][ ]*[-]*[ ]*[()]', ' xxemoji ', text)\n    return text", "refactored": true, "pred": {"ppl": 3.408949136734009, "ppl_lower": 3.479395627975464, "ppl/lowercase_ppl": -1.0166784637144994, "ppl/zlib": 0.003607070802221252, "Min_5.0% Prob": 8.90572676062584, "Min_10.0% Prob": 6.8379676847746875, "Min_20.0% Prob": 4.920321952051191, "Min_30.0% Prob": 3.7303622117136963, "Min_40.0% Prob": 2.984741027675458, "Min_50.0% Prob": 2.4396576463643993, "Min_60.0% Prob": 2.041809786904124}}
{"hexsha": "10e63bec5b7e172368421e76129581befebd5bc0", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef part_sum(bitlist, indices):\n    \"\"\"Compute the mod 2 sum of the subset of bits in bitlist given by the list of indices.\"\"\"\n    sum = 0\n    for x in indices:\n        sum = sum ^ bitlist[x]\n    return sum", "fn_id": 6, "class_fn": false, "repo": "wmkirby1/CS-VQE", "file": "misc/legacy/fermions/yaferp/general/fermions.py", "last_update_at": "2021-11-10T18:03:49+00:00", "original_content": "def part_sum(bitlist, indices):\n    \"\"\"Compute the mod 2 sum of the subset of bits in bitlist given by the list of indices.\"\"\"\n    sum = 0\n    for x in indices:\n        sum = sum ^ bitlist[x]\n    return sum", "refactored": true, "pred": {"ppl": 7.634791374206543, "ppl_lower": 8.676300048828125, "ppl/lowercase_ppl": -1.0629107003096865, "ppl/zlib": 0.012784374926876925, "Min_5.0% Prob": 12.406093915303549, "Min_10.0% Prob": 10.219534397125244, "Min_20.0% Prob": 7.563452427203838, "Min_30.0% Prob": 6.023134911060334, "Min_40.0% Prob": 4.997352508398203, "Min_50.0% Prob": 4.06053397601301, "Min_60.0% Prob": 3.394821036234498}}
{"hexsha": "90681b31e1662f4f8ed10dcfc71a183b60796d93", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef experimental_parallel_interleave_dataset(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, f, output_types, output_shapes, name=None):\n    \"\"\"Creates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  The resulting dataset is similar to the `InterleaveDataset`, with the exception\n  that if retrieving the next value from a dataset would cause the requester to\n  block, it will skip that input dataset. This dataset is especially useful\n  when loading data from a variable-latency datastores (e.g. HDFS, GCS), as it\n  allows the training step to proceed so long as some data is available.\n\n  !! WARNING !! This dataset is not deterministic!\n\n  Args:\n    input_dataset: A `Tensor` of type `variant`.\n    other_arguments: A list of `Tensor` objects.\n    cycle_length: A `Tensor` of type `int64`.\n    block_length: A `Tensor` of type `int64`.\n    sloppy: A `Tensor` of type `bool`.\n    buffer_output_elements: A `Tensor` of type `int64`.\n    prefetch_input_elements: A `Tensor` of type `int64`.\n    f: A function decorated with @Defun.\n      A function mapping elements of `input_dataset`, concatenated with\n      `other_arguments`, to a Dataset variant that contains elements matching\n      `output_types` and `output_shapes`.\n    output_types: A list of `tf.DTypes` that has length `>= 1`.\n    output_shapes: A list of shapes (each a `tf.TensorShape` or list of `ints`) that has length `>= 1`.\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor` of type `variant`.\n  \"\"\"\n    _ctx = _context._context or _context.context()\n    tld = _ctx._thread_local_data\n    if tld.is_eager:\n        try:\n            _result = pywrap_tfe.TFE_Py_FastPathExecute(_ctx._context_handle, tld.device_name, 'ExperimentalParallelInterleaveDataset', name, tld.op_callbacks, input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, 'f', f, 'output_types', output_types, 'output_shapes', output_shapes)\n            return _result\n        except _core._NotOkStatusException as e:\n            _ops.raise_from_not_ok_status(e, name)\n        except _core._FallbackException:\n            pass\n        try:\n            return experimental_parallel_interleave_dataset_eager_fallback(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, f=f, output_types=output_types, output_shapes=output_shapes, name=name, ctx=_ctx)\n        except _core._SymbolicException:\n            pass\n    if not isinstance(output_types, (list, tuple)):\n        raise TypeError(\"Expected list for 'output_types' argument to 'experimental_parallel_interleave_dataset' Op, not %r.\" % output_types)\n    output_types = [_execute.make_type(_t, 'output_types') for _t in output_types]\n    if not isinstance(output_shapes, (list, tuple)):\n        raise TypeError(\"Expected list for 'output_shapes' argument to 'experimental_parallel_interleave_dataset' Op, not %r.\" % output_shapes)\n    output_shapes = [_execute.make_shape(_s, 'output_shapes') for _s in output_shapes]\n    _, _, _op, _outputs = _op_def_library._apply_op_helper('ExperimentalParallelInterleaveDataset', input_dataset=input_dataset, other_arguments=other_arguments, cycle_length=cycle_length, block_length=block_length, sloppy=sloppy, buffer_output_elements=buffer_output_elements, prefetch_input_elements=prefetch_input_elements, f=f, output_types=output_types, output_shapes=output_shapes, name=name)\n    _result = _outputs[:]\n    if _execute.must_record_gradient():\n        _attrs = ('f', _op.get_attr('f'), 'Targuments', _op.get_attr('Targuments'), 'output_types', _op.get_attr('output_types'), 'output_shapes', _op.get_attr('output_shapes'))\n        _inputs_flat = _op.inputs\n        _execute.record_gradient('ExperimentalParallelInterleaveDataset', _inputs_flat, _attrs, _result)\n    _result, = _result\n    return _result", "fn_id": 68, "class_fn": false, "repo": "Lube-Project/ProgettoLube", "file": "ProgettoLube/WebInspector/venv/Lib/site-packages/tensorflow/python/ops/gen_experimental_dataset_ops.py", "last_update_at": "2021-01-28T01:57:41+00:00", "original_content": "def experimental_parallel_interleave_dataset(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, f, output_types, output_shapes, name=None):\n    \"\"\"Creates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  The resulting dataset is similar to the `InterleaveDataset`, with the exception\n  that if retrieving the next value from a dataset would cause the requester to\n  block, it will skip that input dataset. This dataset is especially useful\n  when loading data from a variable-latency datastores (e.g. HDFS, GCS), as it\n  allows the training step to proceed so long as some data is available.\n\n  !! WARNING !! This dataset is not deterministic!\n\n  Args:\n    input_dataset: A `Tensor` of type `variant`.\n    other_arguments: A list of `Tensor` objects.\n    cycle_length: A `Tensor` of type `int64`.\n    block_length: A `Tensor` of type `int64`.\n    sloppy: A `Tensor` of type `bool`.\n    buffer_output_elements: A `Tensor` of type `int64`.\n    prefetch_input_elements: A `Tensor` of type `int64`.\n    f: A function decorated with @Defun.\n      A function mapping elements of `input_dataset`, concatenated with\n      `other_arguments`, to a Dataset variant that contains elements matching\n      `output_types` and `output_shapes`.\n    output_types: A list of `tf.DTypes` that has length `>= 1`.\n    output_shapes: A list of shapes (each a `tf.TensorShape` or list of `ints`) that has length `>= 1`.\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor` of type `variant`.\n  \"\"\"\n    _ctx = _context._context or _context.context()\n    tld = _ctx._thread_local_data\n    if tld.is_eager:\n        try:\n            _result = pywrap_tfe.TFE_Py_FastPathExecute(_ctx._context_handle, tld.device_name, 'ExperimentalParallelInterleaveDataset', name, tld.op_callbacks, input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, 'f', f, 'output_types', output_types, 'output_shapes', output_shapes)\n            return _result\n        except _core._NotOkStatusException as e:\n            _ops.raise_from_not_ok_status(e, name)\n        except _core._FallbackException:\n            pass\n        try:\n            return experimental_parallel_interleave_dataset_eager_fallback(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, f=f, output_types=output_types, output_shapes=output_shapes, name=name, ctx=_ctx)\n        except _core._SymbolicException:\n            pass\n    if not isinstance(output_types, (list, tuple)):\n        raise TypeError(\"Expected list for 'output_types' argument to 'experimental_parallel_interleave_dataset' Op, not %r.\" % output_types)\n    output_types = [_execute.make_type(_t, 'output_types') for _t in output_types]\n    if not isinstance(output_shapes, (list, tuple)):\n        raise TypeError(\"Expected list for 'output_shapes' argument to 'experimental_parallel_interleave_dataset' Op, not %r.\" % output_shapes)\n    output_shapes = [_execute.make_shape(_s, 'output_shapes') for _s in output_shapes]\n    _, _, _op, _outputs = _op_def_library._apply_op_helper('ExperimentalParallelInterleaveDataset', input_dataset=input_dataset, other_arguments=other_arguments, cycle_length=cycle_length, block_length=block_length, sloppy=sloppy, buffer_output_elements=buffer_output_elements, prefetch_input_elements=prefetch_input_elements, f=f, output_types=output_types, output_shapes=output_shapes, name=name)\n    _result = _outputs[:]\n    if _execute.must_record_gradient():\n        _attrs = ('f', _op.get_attr('f'), 'Targuments', _op.get_attr('Targuments'), 'output_types', _op.get_attr('output_types'), 'output_shapes', _op.get_attr('output_shapes'))\n        _inputs_flat = _op.inputs\n        _execute.record_gradient('ExperimentalParallelInterleaveDataset', _inputs_flat, _attrs, _result)\n    _result, = _result\n    return _result", "refactored": true, "pred": {"ppl": 1.5129748582839966, "ppl_lower": 2.2432668209075928, "ppl/lowercase_ppl": -1.9511627317384428, "ppl/zlib": 0.0003222395467231654, "Min_5.0% Prob": 5.6134715641246125, "Min_10.0% Prob": 3.6850917725002064, "Min_20.0% Prob": 2.0608677771307673, "Min_30.0% Prob": 1.383427124901133, "Min_40.0% Prob": 1.0356078093518812, "Min_50.0% Prob": 0.8289541273980615, "Min_60.0% Prob": 0.6910286065670543}}
{"hexsha": "5d67dd4c40040dcf2e4bbcd0df1123cacc8a09a7", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_conversion_rate(response_data):\n    data = str(response_data)\n    keyword_conversion = 'conversion_rate'\n    slen = len(keyword_conversion)\n    start_index = data.find(keyword_conversion)\n    extra_len = 9\n    extracted_str = data[start_index:start_index + slen + extra_len]\n    word_list = extracted_str.split(':')\n    conversion_rate = word_list[1]\n    result = float(conversion_rate)\n    loginfo('Conversion Rate = ' + str(result), get_conversion_rate.__name__)\n    return result", "fn_id": 3, "class_fn": false, "repo": "jamesjallorina/currency_exchange", "file": "backend/backend.py", "last_update_at": "2021-12-15T17:54:21+00:00", "original_content": "def get_conversion_rate(response_data):\n    data = str(response_data)\n    keyword_conversion = 'conversion_rate'\n    slen = len(keyword_conversion)\n    start_index = data.find(keyword_conversion)\n    extra_len = 9\n    extracted_str = data[start_index:start_index + slen + extra_len]\n    word_list = extracted_str.split(':')\n    conversion_rate = word_list[1]\n    result = float(conversion_rate)\n    loginfo('Conversion Rate = ' + str(result), get_conversion_rate.__name__)\n    return result", "refactored": true, "pred": {"ppl": 4.310441970825195, "ppl_lower": 4.3939924240112305, "ppl/lowercase_ppl": -1.0131398179809725, "ppl/zlib": 0.005963430384870665, "Min_5.0% Prob": 10.063111577715192, "Min_10.0% Prob": 8.954346656799316, "Min_20.0% Prob": 6.505251169204712, "Min_30.0% Prob": 4.740235569802198, "Min_40.0% Prob": 3.6327629728337465, "Min_50.0% Prob": 2.9151244209324187, "Min_60.0% Prob": 2.4554086376235564}}
{"hexsha": "b740c4349aa6a00f9a664792b9a5d497e887cbae", "ext": "py", "lang": "Python", "content": "@pytest.mark.parametrize('value,expected', (('', ''), (None, ''), ('very long ' * 100, '')))\n@timeing\n@measure_memory_usage\ndef test_mobile_number_clean(value, expected):\n    field = forms.MobileNumberField(max_length=100)\n    assert field.to_python(value) == expected", "fn_id": 0, "class_fn": false, "repo": "konradko/directory-api", "file": "company/tests/test_forms.py", "last_update_at": "2021-11-06T12:08:26+00:00", "original_content": "@pytest.mark.parametrize('value,expected', (('', ''), (None, ''), ('very long ' * 100, '')))\ndef test_mobile_number_clean(value, expected):\n    field = forms.MobileNumberField(max_length=100)\n    assert field.to_python(value) == expected", "refactored": true, "pred": {"ppl": 6.742295265197754, "ppl_lower": 8.536381721496582, "ppl/lowercase_ppl": -1.1236306699230911, "ppl/zlib": 0.00983711551933105, "Min_5.0% Prob": 11.859055280685425, "Min_10.0% Prob": 10.18300199508667, "Min_20.0% Prob": 7.656259328126907, "Min_30.0% Prob": 5.933405796686809, "Min_40.0% Prob": 4.668227701476126, "Min_50.0% Prob": 3.833711108783396, "Min_60.0% Prob": 3.227943828063352}}
{"hexsha": "eedf072c408246eee339cda55c42a69c694380b4", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef extract_bucket_reference_for_param_reference(template, param_name):\n    param_value = template.get_parameter_default(param_name)\n    if param_value is None:\n        return\n    for resource in template.resources('AWS::Serverless::Function'):\n        policies = resource['Properties'].get('Policies')\n        if policies is None:\n            continue\n        for policy in policies:\n            for statement in policy['Statement']:\n                if param_value not in statement.get('Resource', ''):\n                    continue\n                old_value = statement['Resource']\n                parts = list(old_value.partition(param_value))\n                parts[1] = {'Ref': param_name}\n                new_value = {'Fn::Join': ['', parts]}\n                statement['Resource'] = new_value", "fn_id": 2, "class_fn": false, "repo": "jmespath/jmespath-playground", "file": "template-fixups.py", "last_update_at": "2021-11-24T14:33:45+00:00", "original_content": "def extract_bucket_reference_for_param_reference(template, param_name):\n    param_value = template.get_parameter_default(param_name)\n    if param_value is None:\n        return\n    for resource in template.resources('AWS::Serverless::Function'):\n        policies = resource['Properties'].get('Policies')\n        if policies is None:\n            continue\n        for policy in policies:\n            for statement in policy['Statement']:\n                if param_value not in statement.get('Resource', ''):\n                    continue\n                old_value = statement['Resource']\n                parts = list(old_value.partition(param_value))\n                parts[1] = {'Ref': param_name}\n                new_value = {'Fn::Join': ['', parts]}\n                statement['Resource'] = new_value", "refactored": true, "pred": {"ppl": 3.5438544750213623, "ppl_lower": 4.869338035583496, "ppl/lowercase_ppl": -1.2511375844988741, "ppl/zlib": 0.003604601052840069, "Min_5.0% Prob": 10.317540751563179, "Min_10.0% Prob": 8.429047875934177, "Min_20.0% Prob": 5.822861664825016, "Min_30.0% Prob": 4.118542408501661, "Min_40.0% Prob": 3.1513962764292955, "Min_50.0% Prob": 2.5382347654137347, "Min_60.0% Prob": 2.1194296957907715}}
{"hexsha": "6f11be4ebd108a94cb1027e16e858ff097fa14e5", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef text_to_spreadsheet(directory='.', output_file='text_to_sheet.xlsx'):\n    \"\"\"\n    Searches for all text files at the given directory. Each individual\n    text file is converted to a column in the output_file spreadsheet.\n\n    :param str directory: path to directory to search\n    :param str output_file: name of output file\n    \"\"\"\n    path = os.path.abspath(directory)\n    wb = openpyxl.Workbook()\n    wb.create_sheet(title='Text to Columns', index=0)\n    sheet = wb.active\n    bold = Font(bold=True)\n    print(f'Searching for text files...')\n    files = [file for file in os.listdir(path) if file.lower().endswith('.txt')]\n    column = 1\n    print(f'Writing lines of text to columns...')\n    for file in files:\n        row = 2\n        with open(os.path.join(path, file)) as text:\n            sheet.cell(row=1, column=column).value = file\n            sheet.cell(row=1, column=column).font = bold\n            for line in text:\n                sheet.cell(row=row, column=column).value = line\n                row += 1\n        column += 1\n    wb.save(filename=output_file)\n    print(f\"Resulting file saved as '{output_file}'\")", "fn_id": 0, "class_fn": false, "repo": "zspatter/automate-the-boring-stuff", "file": "text_to_spreadsheet/text_to_spreadsheet.py", "last_update_at": "2021-09-05T20:19:40+00:00", "original_content": "def text_to_spreadsheet(directory='.', output_file='text_to_sheet.xlsx'):\n    \"\"\"\n    Searches for all text files at the given directory. Each individual\n    text file is converted to a column in the output_file spreadsheet.\n\n    :param str directory: path to directory to search\n    :param str output_file: name of output file\n    \"\"\"\n    path = os.path.abspath(directory)\n    wb = openpyxl.Workbook()\n    wb.create_sheet(title='Text to Columns', index=0)\n    sheet = wb.active\n    bold = Font(bold=True)\n    print(f'Searching for text files...')\n    files = [file for file in os.listdir(path) if file.lower().endswith('.txt')]\n    column = 1\n    print(f'Writing lines of text to columns...')\n    for file in files:\n        row = 2\n        with open(os.path.join(path, file)) as text:\n            sheet.cell(row=1, column=column).value = file\n            sheet.cell(row=1, column=column).font = bold\n            for line in text:\n                sheet.cell(row=row, column=column).value = line\n                row += 1\n        column += 1\n    wb.save(filename=output_file)\n    print(f\"Resulting file saved as '{output_file}'\")", "refactored": true, "pred": {"ppl": 3.198775291442871, "ppl_lower": 3.752328634262085, "ppl/lowercase_ppl": -1.1372660747424446, "ppl/zlib": 0.002198049177930136, "Min_5.0% Prob": 9.120443725585938, "Min_10.0% Prob": 7.466976581081267, "Min_20.0% Prob": 5.163265970445448, "Min_30.0% Prob": 3.7863279750911136, "Min_40.0% Prob": 2.895020692398952, "Min_50.0% Prob": 2.3232643746680792, "Min_60.0% Prob": 1.9376869764772333}}
{"hexsha": "1b7c720289e99957b1d1e5c9b70d89bb7e355da1", "ext": "py", "lang": "Python", "content": "@tf.function\n@timeing\n@measure_memory_usage\ndef train_step(x_target, y_target, model, optimizer, model_loss):\n    with tf.GradientTape() as model_tape:\n        y_predic = model(x_target, training=True)\n        loss = model_loss(y_target, y_predic)\n    gradients_of_model = model_tape.gradient(loss, model.trainable_variables)\n    optimizer.apply_gradients(zip(gradients_of_model, model.trainable_variables))\n    return loss", "fn_id": 1, "class_fn": false, "repo": "awagot/CNN-POD", "file": "training/training.py", "last_update_at": "2021-08-18T11:23:05+00:00", "original_content": "@tf.function\ndef train_step(x_target, y_target, model, optimizer, model_loss):\n    with tf.GradientTape() as model_tape:\n        y_predic = model(x_target, training=True)\n        loss = model_loss(y_target, y_predic)\n    gradients_of_model = model_tape.gradient(loss, model.trainable_variables)\n    optimizer.apply_gradients(zip(gradients_of_model, model.trainable_variables))\n    return loss", "refactored": true, "pred": {"ppl": 2.3993687629699707, "ppl_lower": 3.3450188636779785, "ppl/lowercase_ppl": -1.3796440658577303, "ppl/zlib": 0.0039782076696822585, "Min_5.0% Prob": 8.835598389307657, "Min_10.0% Prob": 7.604265630245209, "Min_20.0% Prob": 4.235780377388, "Min_30.0% Prob": 2.9320284021464555, "Min_40.0% Prob": 2.185145614258945, "Min_50.0% Prob": 1.764079044708201, "Min_60.0% Prob": 1.4586169260949828}}
{"hexsha": "49f5a6884183e7a4dcbfcde101a491ad27898026", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _get_eval_config_from_service_classification(classification: configuration_pb2.ClassificationProblemSpec, eval_config: model_evaluation_pb2.EvaluationConfig) -> None:\n    if classification.HasField('ground_truth_column_spec'):\n        eval_config.data_spec.label_key_spec.CopyFrom(classification.ground_truth_column_spec)\n    if classification.HasField('example_weight_column_spec'):\n        eval_config.data_spec.example_weight_key_spec.CopyFrom(classification.example_weight_column_spec)\n    if classification.HasField('prediction_score_column_spec'):\n        eval_config.data_spec.predicted_score_key_spec.CopyFrom(classification.prediction_score_column_spec)\n    if classification.HasField('prediction_label_column_spec'):\n        eval_config.data_spec.predicted_label_key_spec.CopyFrom(classification.prediction_label_column_spec)\n    if classification.HasField('prediction_id_column_spec'):\n        eval_config.data_spec.predicted_label_id_key_spec.CopyFrom(classification.prediction_id_column_spec)\n    eval_config.data_spec.labels.extend(classification.class_names)\n    num_classes = len(classification.class_names)\n    if classification.type == configuration_pb2.ClassificationProblemSpec.MULTICLASS:\n        problem_type = constants.ProblemType.MULTICLASS\n    elif classification.type == configuration_pb2.ClassificationProblemSpec.MULTILABEL:\n        problem_type = constants.ProblemType.MULTILABEL\n    else:\n        raise NotImplementedError('Classification type %r not implemented' % classification.type)\n    adapter = tfma_adapter.TFMAToME(class_name_list=list(classification.class_names))\n    tfma_metric_specs = _get_metric_specs(problem_type, list(classification.class_names), list(classification.evaluation_options.positive_classes), list(classification.evaluation_options.top_k_list))\n    for tfma_metric_spec in tfma_metric_specs:\n        eval_config.metrics_specs.append(adapter.metrics_spec(tfma_metric_spec))", "fn_id": 3, "class_fn": false, "repo": "tomar27/pipelines", "file": "components/google-cloud/google_cloud_pipeline_components/experimental/evaluation/flex/lib/config.py", "last_update_at": "2021-10-23T00:39:47+00:00", "original_content": "def _get_eval_config_from_service_classification(classification: configuration_pb2.ClassificationProblemSpec, eval_config: model_evaluation_pb2.EvaluationConfig) -> None:\n    if classification.HasField('ground_truth_column_spec'):\n        eval_config.data_spec.label_key_spec.CopyFrom(classification.ground_truth_column_spec)\n    if classification.HasField('example_weight_column_spec'):\n        eval_config.data_spec.example_weight_key_spec.CopyFrom(classification.example_weight_column_spec)\n    if classification.HasField('prediction_score_column_spec'):\n        eval_config.data_spec.predicted_score_key_spec.CopyFrom(classification.prediction_score_column_spec)\n    if classification.HasField('prediction_label_column_spec'):\n        eval_config.data_spec.predicted_label_key_spec.CopyFrom(classification.prediction_label_column_spec)\n    if classification.HasField('prediction_id_column_spec'):\n        eval_config.data_spec.predicted_label_id_key_spec.CopyFrom(classification.prediction_id_column_spec)\n    eval_config.data_spec.labels.extend(classification.class_names)\n    num_classes = len(classification.class_names)\n    if classification.type == configuration_pb2.ClassificationProblemSpec.MULTICLASS:\n        problem_type = constants.ProblemType.MULTICLASS\n    elif classification.type == configuration_pb2.ClassificationProblemSpec.MULTILABEL:\n        problem_type = constants.ProblemType.MULTILABEL\n    else:\n        raise NotImplementedError('Classification type %r not implemented' % classification.type)\n    adapter = tfma_adapter.TFMAToME(class_name_list=list(classification.class_names))\n    tfma_metric_specs = _get_metric_specs(problem_type, list(classification.class_names), list(classification.evaluation_options.positive_classes), list(classification.evaluation_options.top_k_list))\n    for tfma_metric_spec in tfma_metric_specs:\n        eval_config.metrics_specs.append(adapter.metrics_spec(tfma_metric_spec))", "refactored": true, "pred": {"ppl": 2.2175443172454834, "ppl_lower": 2.832935333251953, "ppl/lowercase_ppl": -1.3075249182343185, "ppl/zlib": 0.0015111962433225327, "Min_5.0% Prob": 8.368903331756592, "Min_10.0% Prob": 6.051673580618465, "Min_20.0% Prob": 3.7723955425243934, "Min_30.0% Prob": 2.64916524716786, "Min_40.0% Prob": 1.9926385374884437, "Min_50.0% Prob": 1.5926298058813784, "Min_60.0% Prob": 1.3298882161202865}}
{"hexsha": "02819a01b041692ac69ff145ea5f13a590fc9b34", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _guess_package_name(file_type, file_name):\n    if not file_type:\n        return None\n    file_name = file_name.lower()\n    if 'Bourne-Again' in file_type or 'bash' in file_type:\n        return 'bash'\n    elif 'Mach-O' in file_type and 'executable' in file_type:\n        return 'macho'\n    elif 'directory' in file_type or (file_name.endswith('.app') or file_name.endswith('.app/')) or (file_name.endswith('.pkg') or file_name.endswith('.pkg/')):\n        return 'app'\n    elif 'Zip archive' in file_type and file_name.endswith('.zip'):\n        return 'zip'\n    elif 'PDF' in file_type or file_name.endswith('.pdf'):\n        return 'pdf'\n    elif 'Microsoft Word' in file_type or 'Microsoft Office Word' in file_type or file_name.endswith('.docx') or file_name.endswith('.doc'):\n        return 'doc'\n    elif 'Rich Text Format' in file_type or file_name.endswith('.rtf') or 'property list' in file_type or file_name.endswith('.plist'):\n        return 'rtf'\n    elif 'HTML' in file_type or file_name.endswith('.htm') or file_name.endswith('.html'):\n        return 'html'\n    elif file_name.endswith('.jar'):\n        return 'jar'\n    elif file_name.endswith('.py') or 'Python script' in file_type:\n        return 'python'\n    elif file_name.endswith('.pl') or 'perl script' in file_type.lower():\n        return 'perl'\n    elif file_name.endswith('.dmg'):\n        return 'dmg'\n    else:\n        return 'generic'", "fn_id": 2, "class_fn": false, "repo": "phdphuc/mac-a-mal-cuckoo", "file": "analyzer/darwin/lib/core/packages.py", "last_update_at": "2021-04-07T08:26:25+00:00", "original_content": "def _guess_package_name(file_type, file_name):\n    if not file_type:\n        return None\n    file_name = file_name.lower()\n    if 'Bourne-Again' in file_type or 'bash' in file_type:\n        return 'bash'\n    elif 'Mach-O' in file_type and 'executable' in file_type:\n        return 'macho'\n    elif 'directory' in file_type or (file_name.endswith('.app') or file_name.endswith('.app/')) or (file_name.endswith('.pkg') or file_name.endswith('.pkg/')):\n        return 'app'\n    elif 'Zip archive' in file_type and file_name.endswith('.zip'):\n        return 'zip'\n    elif 'PDF' in file_type or file_name.endswith('.pdf'):\n        return 'pdf'\n    elif 'Microsoft Word' in file_type or 'Microsoft Office Word' in file_type or file_name.endswith('.docx') or file_name.endswith('.doc'):\n        return 'doc'\n    elif 'Rich Text Format' in file_type or file_name.endswith('.rtf') or 'property list' in file_type or file_name.endswith('.plist'):\n        return 'rtf'\n    elif 'HTML' in file_type or file_name.endswith('.htm') or file_name.endswith('.html'):\n        return 'html'\n    elif file_name.endswith('.jar'):\n        return 'jar'\n    elif file_name.endswith('.py') or 'Python script' in file_type:\n        return 'python'\n    elif file_name.endswith('.pl') or 'perl script' in file_type.lower():\n        return 'perl'\n    elif file_name.endswith('.dmg'):\n        return 'dmg'\n    else:\n        return 'generic'", "refactored": true, "pred": {"ppl": 1.9723972082138062, "ppl_lower": 2.1038522720336914, "ppl/lowercase_ppl": -1.0949877833776744, "ppl/zlib": 0.0016211209067800878, "Min_5.0% Prob": 7.088073444366455, "Min_10.0% Prob": 5.1122990310192105, "Min_20.0% Prob": 3.2342285153306563, "Min_30.0% Prob": 2.2512832440313746, "Min_40.0% Prob": 1.699483612129476, "Min_50.0% Prob": 1.3608017519216837, "Min_60.0% Prob": 1.1337192012134902}}
{"hexsha": "6576548aed0db505fcd1e0ff4f67a6208131321a", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef login0(auth=None):\n    \"\"\"Handle secure login for performance and stress testing.\n\n    Signature is the signature of email value with the application key.\n    \"\"\"\n    if not auth:\n        auth = request.headers.get('Authorization')\n        if not auth:\n            resp = Response()\n            resp.headers['WWW-Authenticate'] = 'Basic realm=\"Access to the load-testing login\"'\n            resp.status_code = 401\n            return resp\n        if ':' not in auth:\n            auth = base64.b64decode(auth).decode()\n    email, signature = auth.split(':')\n    s = Signer(app.secret_key)\n    if s.validate(email + '.' + signature):\n        try:\n            u = User.get(email=email)\n            login_user(u)\n            return redirect(get_next_url() or url_for('index'))\n        except User.DoesNotExist:\n            return handle_login()\n    abort(403)", "fn_id": 7, "class_fn": false, "repo": "tenet-ac-za/NZ-ORCID-Hub", "file": "orcid_hub/authcontroller.py", "last_update_at": "2021-07-22T08:53:40+00:00", "original_content": "def login0(auth=None):\n    \"\"\"Handle secure login for performance and stress testing.\n\n    Signature is the signature of email value with the application key.\n    \"\"\"\n    if not auth:\n        auth = request.headers.get('Authorization')\n        if not auth:\n            resp = Response()\n            resp.headers['WWW-Authenticate'] = 'Basic realm=\"Access to the load-testing login\"'\n            resp.status_code = 401\n            return resp\n        if ':' not in auth:\n            auth = base64.b64decode(auth).decode()\n    email, signature = auth.split(':')\n    s = Signer(app.secret_key)\n    if s.validate(email + '.' + signature):\n        try:\n            u = User.get(email=email)\n            login_user(u)\n            return redirect(get_next_url() or url_for('index'))\n        except User.DoesNotExist:\n            return handle_login()\n    abort(403)", "refactored": true, "pred": {"ppl": 5.489949703216553, "ppl_lower": 7.747810363769531, "ppl/lowercase_ppl": -1.2022945053636949, "ppl/zlib": 0.003685972064832105, "Min_5.0% Prob": 11.126636331731623, "Min_10.0% Prob": 9.371941826560281, "Min_20.0% Prob": 6.91621779311787, "Min_30.0% Prob": 5.372667130195733, "Min_40.0% Prob": 4.216810408640992, "Min_50.0% Prob": 3.411909490010955, "Min_60.0% Prob": 2.8498527021641196}}
{"hexsha": "782e47ae6e2a1bc565a53c10fee16a15dc5e46b5", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef readStr_qm9():\n    f = open(current_dir + '/../_dataset/QM9/qm9.smi', 'r')\n    L = []\n    for line in f:\n        line = line.strip()\n        L.append(line)\n    f.close()\n    np.random.seed(1)\n    np.random.shuffle(L)\n    return L", "fn_id": 2, "class_fn": false, "repo": "drigoni/ComparisonsDGM", "file": "_utils/read_dataset.py", "last_update_at": "2021-04-12T13:17:50+00:00", "original_content": "def readStr_qm9():\n    f = open(current_dir + '/../_dataset/QM9/qm9.smi', 'r')\n    L = []\n    for line in f:\n        line = line.strip()\n        L.append(line)\n    f.close()\n    np.random.seed(1)\n    np.random.shuffle(L)\n    return L", "refactored": true, "pred": {"ppl": 4.776181697845459, "ppl_lower": 4.772194862365723, "ppl/lowercase_ppl": -0.999465938056984, "ppl/zlib": 0.00845211578002238, "Min_5.0% Prob": 11.027247428894043, "Min_10.0% Prob": 8.999835120307075, "Min_20.0% Prob": 6.600032859378391, "Min_30.0% Prob": 5.068363474475013, "Min_40.0% Prob": 3.9113720253937774, "Min_50.0% Prob": 3.149535577661461, "Min_60.0% Prob": 2.6324436348621494}}
{"hexsha": "cbd6d9414697897c65c3690922a074fdd0eec5b2", "ext": "py", "lang": "Python", "content": "@pytest.mark.parametrize('method_name', ['from_pandas', 'iter_from_pandas'])\n@timeing\n@measure_memory_usage\ndef test_dynamic_defines_key_fields(pandas_data, method_name):\n    model = PandasToRecordsTransformer(pandas_data, 'MyRecord', key_fields={'key_field'})\n    from_pandas_method = getattr(model, method_name)\n    record = list(from_pandas_method(pandas_data))[0]\n    assert record.key_fields == {'key_field'}", "fn_id": 4, "class_fn": false, "repo": "AbsaOSS/py2k", "file": "tests/test_models.py", "last_update_at": "2021-09-08T12:33:46+00:00", "original_content": "@pytest.mark.parametrize('method_name', ['from_pandas', 'iter_from_pandas'])\ndef test_dynamic_defines_key_fields(pandas_data, method_name):\n    model = PandasToRecordsTransformer(pandas_data, 'MyRecord', key_fields={'key_field'})\n    from_pandas_method = getattr(model, method_name)\n    record = list(from_pandas_method(pandas_data))[0]\n    assert record.key_fields == {'key_field'}", "refactored": true, "pred": {"ppl": 6.470132350921631, "ppl_lower": 8.574528694152832, "ppl/lowercase_ppl": -1.1508140437559742, "ppl/zlib": 0.00808310201037478, "Min_5.0% Prob": 11.857945760091146, "Min_10.0% Prob": 9.987905939420065, "Min_20.0% Prob": 7.545867125193278, "Min_30.0% Prob": 5.890716714991464, "Min_40.0% Prob": 4.614071586479743, "Min_50.0% Prob": 3.706907550819585, "Min_60.0% Prob": 3.1155011971315294}}
{"hexsha": "6b441b738c1e2efec58e60abe442cbe344419f54", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef avro_schema(avsc: Union[dict, str]) -> dict:\n    \"\"\" Create avro schema from dictionary or filepath string \"\"\"\n    logging.info('Parsing avro schema')\n    if isinstance(avsc, dict):\n        avsc = avro.schema.parse_schema(avsc)\n    elif isinstance(avsc, str):\n        avsc = avro.schema.load_schema(avsc)\n    return avsc", "fn_id": 3, "class_fn": false, "repo": "staylorx/cupyopt", "file": "src/cupyopt/nuggets/schema.py", "last_update_at": "2021-03-12T20:46:34+00:00", "original_content": "def avro_schema(avsc: Union[dict, str]) -> dict:\n    \"\"\" Create avro schema from dictionary or filepath string \"\"\"\n    logging.info('Parsing avro schema')\n    if isinstance(avsc, dict):\n        avsc = avro.schema.parse_schema(avsc)\n    elif isinstance(avsc, str):\n        avsc = avro.schema.load_schema(avsc)\n    return avsc", "refactored": true, "pred": {"ppl": 4.052378177642822, "ppl_lower": 4.637179851531982, "ppl/lowercase_ppl": -1.0963353824977948, "ppl/zlib": 0.007067191480493352, "Min_5.0% Prob": 9.044874477386475, "Min_10.0% Prob": 7.6667286396026615, "Min_20.0% Prob": 5.737192225456238, "Min_30.0% Prob": 4.41731737506005, "Min_40.0% Prob": 3.511461986274254, "Min_50.0% Prob": 2.789505612463332, "Min_60.0% Prob": 2.3451824116430458}}
{"hexsha": "f4365a09ba1797e4fafc8682981c9fb04235a5c1", "ext": "py", "lang": "Python", "content": "@pytest.mark.parametrize('space_group', ['P2', 'P3', 'P6', 'R3:h', 'I23'][:])\n@timeing\n@measure_memory_usage\ndef test_determine_space_group(space_group):\n    sgi = sgtbx.space_group_info(symbol=space_group)\n    sg = sgi.group()\n    cs = sgi.any_compatible_crystal_symmetry(volume=10000)\n    cs = cs.best_cell()\n    cs = cs.minimum_cell()\n    intensities = generate_fake_intensities(cs)\n    result = LaueGroupAnalysis([intensities], normalisation=None)\n    print(result)\n    assert result.best_solution.subgroup['best_subsym'].space_group() == sg.build_derived_patterson_group()\n    assert result.best_solution.likelihood > 0.8\n    for score in result.subgroup_scores[1:]:\n        assert score.likelihood < 0.1", "fn_id": 1, "class_fn": false, "repo": "TiankunZhou/dials", "file": "algorithms/symmetry/test_laue_group.py", "last_update_at": "2021-11-18T04:20:54+00:00", "original_content": "@pytest.mark.parametrize('space_group', ['P2', 'P3', 'P6', 'R3:h', 'I23'][:])\ndef test_determine_space_group(space_group):\n    sgi = sgtbx.space_group_info(symbol=space_group)\n    sg = sgi.group()\n    cs = sgi.any_compatible_crystal_symmetry(volume=10000)\n    cs = cs.best_cell()\n    cs = cs.minimum_cell()\n    intensities = generate_fake_intensities(cs)\n    result = LaueGroupAnalysis([intensities], normalisation=None)\n    print(result)\n    assert result.best_solution.subgroup['best_subsym'].space_group() == sg.build_derived_patterson_group()\n    assert result.best_solution.likelihood > 0.8\n    for score in result.subgroup_scores[1:]:\n        assert score.likelihood < 0.1", "refactored": true, "pred": {"ppl": 3.5344481468200684, "ppl_lower": 4.019406318664551, "ppl/lowercase_ppl": -1.1018385830868824, "ppl/zlib": 0.003331285424635979, "Min_5.0% Prob": 9.574934612620961, "Min_10.0% Prob": 7.515194042869236, "Min_20.0% Prob": 5.143244682474339, "Min_30.0% Prob": 3.907403116494837, "Min_40.0% Prob": 3.104335386385309, "Min_50.0% Prob": 2.517456053361549, "Min_60.0% Prob": 2.1030503357957366}}
{"hexsha": "3f0ef81e04475f7801a661ee804b85c33aca42e7", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_installed_packages():\n    reqs = subprocess.check_output([sys.executable, '-m', 'pip', 'freeze'])\n    installed_packages = [r.decode().split('==')[0] for r in reqs.split()]\n    return installed_packages", "fn_id": 0, "class_fn": false, "repo": "vymana/nlpwiz", "file": "nlpwiz/utils/pkg_utils.py", "last_update_at": "2021-04-20T18:46:52+00:00", "original_content": "def get_installed_packages():\n    reqs = subprocess.check_output([sys.executable, '-m', 'pip', 'freeze'])\n    installed_packages = [r.decode().split('==')[0] for r in reqs.split()]\n    return installed_packages", "refactored": true, "pred": {"ppl": 2.3005053997039795, "ppl_lower": 2.3005053997039795, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.004929756436673112, "Min_5.0% Prob": 8.312368710835775, "Min_10.0% Prob": 7.199227412541707, "Min_20.0% Prob": 4.280359483682192, "Min_30.0% Prob": 2.856570692360401, "Min_40.0% Prob": 2.126541060154085, "Min_50.0% Prob": 1.69024233036565, "Min_60.0% Prob": 1.4019845908098831}}
{"hexsha": "9cb1075cc24b8fabc3e7e078623e7b3ba9e43ca3", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef run_sample_whole_range():\n    log_file = '../results/DBEsti_tpcds_100k_all.log'\n    db = DBEst(dataset='tpcds', logger_file=log_file)\n    table = 'store_sales'\n    file = '../data/tpcDs10k/store_sales.csv'\n    num_of_points = {'store_sales': '2685596178'}\n    tableColumnSets = [['ss_list_price', 'ss_wholesale_cost']]\n    db.init_whole_range(file=file, table=table, columnItems=tableColumnSets, num_of_points=num_of_points)\n    db.clear_training_data()\n    db.logger.logger.info('Total size of DBEst is ' + str(db.get_size()) + ' bytes.')", "fn_id": 7, "class_fn": false, "repo": "qingzma/CRegressionRDBM", "file": "dbest/dbestclient.py", "last_update_at": "2021-08-04T06:39:19+00:00", "original_content": "def run_sample_whole_range():\n    log_file = '../results/DBEsti_tpcds_100k_all.log'\n    db = DBEst(dataset='tpcds', logger_file=log_file)\n    table = 'store_sales'\n    file = '../data/tpcDs10k/store_sales.csv'\n    num_of_points = {'store_sales': '2685596178'}\n    tableColumnSets = [['ss_list_price', 'ss_wholesale_cost']]\n    db.init_whole_range(file=file, table=table, columnItems=tableColumnSets, num_of_points=num_of_points)\n    db.clear_training_data()\n    db.logger.logger.info('Total size of DBEst is ' + str(db.get_size()) + ' bytes.')", "refactored": true, "pred": {"ppl": 7.941026210784912, "ppl_lower": 8.389474868774414, "ppl/lowercase_ppl": -1.0265126875794113, "ppl/zlib": 0.006203720097599804, "Min_5.0% Prob": 11.259872102737427, "Min_10.0% Prob": 9.298531460762025, "Min_20.0% Prob": 7.4892060233325495, "Min_30.0% Prob": 6.182893130087083, "Min_40.0% Prob": 5.025237380022026, "Min_50.0% Prob": 4.098032048115363, "Min_60.0% Prob": 3.4649643520073545}}
{"hexsha": "41a7419f7ecd636b33374eda954170a04c2d6f82", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_cert(client, service, file_path, local_path, remote_cert_path, remote_csr_path):\n    \"\"\"\n    Gets the certificate (sign or auth) from the CA.\n\n    NB! This requires the user to have sudo rights without password prompt.\n    :param client: SSHClient object\n    :param service: str - service type: sign-sign (signing certificates) or sign-auth (authentication certificates)\n    :param file_path: str - local CSR path (input)\n    :param local_path: str - local certificate path (output)\n    :param remote_cert_path: str - remote certificate path (output)\n    :param remote_csr_path: str - remote CSR path (input)\n    :return: None\n    \"\"\"\n    client.exec_command('rm temp*')\n    sftp = client.get_client().open_sftp()\n    sftp.put(file_path, remote_csr_path)\n    client.exec_command('cat ' + remote_csr_path + ' | ' + service + ' > ' + remote_cert_path)\n    time.sleep(3)\n    sftp.get(remote_cert_path, local_path)\n    sftp.close()\n    client.close()", "fn_id": 2, "class_fn": false, "repo": "ria-ee/XTM", "file": "common/xrd-ui-tests-python/tests/xroad_ss_delete_hardware_token_certificate/del_management.py", "last_update_at": "2021-11-08T10:30:35+00:00", "original_content": "def get_cert(client, service, file_path, local_path, remote_cert_path, remote_csr_path):\n    \"\"\"\n    Gets the certificate (sign or auth) from the CA.\n\n    NB! This requires the user to have sudo rights without password prompt.\n    :param client: SSHClient object\n    :param service: str - service type: sign-sign (signing certificates) or sign-auth (authentication certificates)\n    :param file_path: str - local CSR path (input)\n    :param local_path: str - local certificate path (output)\n    :param remote_cert_path: str - remote certificate path (output)\n    :param remote_csr_path: str - remote CSR path (input)\n    :return: None\n    \"\"\"\n    client.exec_command('rm temp*')\n    sftp = client.get_client().open_sftp()\n    sftp.put(file_path, remote_csr_path)\n    client.exec_command('cat ' + remote_csr_path + ' | ' + service + ' > ' + remote_cert_path)\n    time.sleep(3)\n    sftp.get(remote_cert_path, local_path)\n    sftp.close()\n    client.close()", "refactored": true, "pred": {"ppl": 3.532015562057495, "ppl_lower": 3.90413498878479, "ppl/lowercase_ppl": -1.0793803326295301, "ppl/zlib": 0.003011619782220884, "Min_5.0% Prob": 8.925363200051445, "Min_10.0% Prob": 7.403818692479815, "Min_20.0% Prob": 5.416267986808505, "Min_30.0% Prob": 4.066818554486547, "Min_40.0% Prob": 3.143409271857568, "Min_50.0% Prob": 2.5300943302389767, "Min_60.0% Prob": 2.1103463003791623}}
{"hexsha": "2cf7ecb49570612ea3ef106c4439aab58551dc8a", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef render_bokeh_figure(result, state):\n    from bokeh.resources import CDN\n    if 'headers' not in state:\n        state['headers'] = set()\n    state['headers'].update(['<script src=\"%s\" async=\"\"></script>' % CDN.js_files[0], '<link rel=\"stylesheet\" href=\"%s\" type=\"text/css\"/>' % CDN.css_files[0]])\n    from bokeh.embed import components\n    script, div = components(result, CDN)\n    if 'footers' not in state:\n        state['footers'] = list()\n    state['footers'].append(script)\n    return [closing_fence(state['code']), div, state['code']]", "fn_id": 9, "class_fn": false, "repo": "mrocklin/pymarkdown", "file": "pymarkdown/core.py", "last_update_at": "2021-12-25T10:56:53+00:00", "original_content": "def render_bokeh_figure(result, state):\n    from bokeh.resources import CDN\n    if 'headers' not in state:\n        state['headers'] = set()\n    state['headers'].update(['<script src=\"%s\" async=\"\"></script>' % CDN.js_files[0], '<link rel=\"stylesheet\" href=\"%s\" type=\"text/css\"/>' % CDN.css_files[0]])\n    from bokeh.embed import components\n    script, div = components(result, CDN)\n    if 'footers' not in state:\n        state['footers'] = list()\n    state['footers'].append(script)\n    return [closing_fence(state['code']), div, state['code']]", "refactored": true, "pred": {"ppl": 4.565204620361328, "ppl_lower": 5.2597503662109375, "ppl/lowercase_ppl": -1.0932654918416962, "ppl/zlib": 0.004914120831002586, "Min_5.0% Prob": 11.536995649337769, "Min_10.0% Prob": 9.285346120595932, "Min_20.0% Prob": 6.65967383980751, "Min_30.0% Prob": 4.935725118432726, "Min_40.0% Prob": 3.811623292473646, "Min_50.0% Prob": 3.0337039863509014, "Min_60.0% Prob": 2.5405861538340697}}
{"hexsha": "17fa8f3d90779608a0fa731c756323ee0bb02290", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef set_up_outputs(OutputObj):\n    OutputObj.add_output('lead_snps_matching_quality_file', 'lead_snps_matching_quality.tsv', add_root=True)\n    OutputObj.add_output('ldscore_for_expanded_control_sets_quality_file', 'ldscore_matching_quality_for_ldexpanded_sets.tsv', add_root=True)\n    OutputObj.add_output('ldsnp_coverage_by_input_snp', 'ldsnp_coverage_by_input_snp.tsv', add_root=True)\n    return OutputObj", "fn_id": 6, "class_fn": false, "repo": "abraham-abin13/gsel_vec", "file": "gsel_vec/scripts/check_ld_expanded_control_sets.py", "last_update_at": "2021-07-22T23:14:33+00:00", "original_content": "def set_up_outputs(OutputObj):\n    OutputObj.add_output('lead_snps_matching_quality_file', 'lead_snps_matching_quality.tsv', add_root=True)\n    OutputObj.add_output('ldscore_for_expanded_control_sets_quality_file', 'ldscore_matching_quality_for_ldexpanded_sets.tsv', add_root=True)\n    OutputObj.add_output('ldsnp_coverage_by_input_snp', 'ldsnp_coverage_by_input_snp.tsv', add_root=True)\n    return OutputObj", "refactored": true, "pred": {"ppl": 5.572360515594482, "ppl_lower": 6.119534492492676, "ppl/lowercase_ppl": -1.0545268672369736, "ppl/zlib": 0.008900615311480342, "Min_5.0% Prob": 10.581008229936872, "Min_10.0% Prob": 9.11812515258789, "Min_20.0% Prob": 7.269545340538025, "Min_30.0% Prob": 5.549344121085273, "Min_40.0% Prob": 4.261989189684391, "Min_50.0% Prob": 3.427806813567877, "Min_60.0% Prob": 2.8611065566022362}}
{"hexsha": "44f8ed8d741874b6b1b7ec273d09a2bf1be84c93", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_schemakey():\n    typemap = {'BareAsset': 'Asset', 'PublishedAsset': 'Asset', 'PublishedDandiset': 'Dandiset'}\n    for val in dir(models):\n        if val in ['BaseModel']:\n            continue\n        klass = getattr(models, val)\n        if isinstance(klass, pydantic.main.ModelMetaclass):\n            assert 'schemaKey' in klass.__fields__\n            if val in typemap:\n                assert typemap[val] == klass.__fields__['schemaKey'].default\n            else:\n                assert val == klass.__fields__['schemaKey'].default", "fn_id": 3, "class_fn": false, "repo": "dandi/dandischema", "file": "dandischema/tests/test_models.py", "last_update_at": "2021-09-19T10:56:25+00:00", "original_content": "def test_schemakey():\n    typemap = {'BareAsset': 'Asset', 'PublishedAsset': 'Asset', 'PublishedDandiset': 'Dandiset'}\n    for val in dir(models):\n        if val in ['BaseModel']:\n            continue\n        klass = getattr(models, val)\n        if isinstance(klass, pydantic.main.ModelMetaclass):\n            assert 'schemaKey' in klass.__fields__\n            if val in typemap:\n                assert typemap[val] == klass.__fields__['schemaKey'].default\n            else:\n                assert val == klass.__fields__['schemaKey'].default", "refactored": true, "pred": {"ppl": 4.105043888092041, "ppl_lower": 5.226151943206787, "ppl/lowercase_ppl": -1.1709786128230812, "ppl/zlib": 0.005269464306797278, "Min_5.0% Prob": 10.4937531153361, "Min_10.0% Prob": 8.82446157015287, "Min_20.0% Prob": 6.308055127108538, "Min_30.0% Prob": 4.633542699057881, "Min_40.0% Prob": 3.5466589706865226, "Min_50.0% Prob": 2.8402400430885777, "Min_60.0% Prob": 2.3642824687490083}}
{"hexsha": "2888eb7991df8f7416f4f9dbfa57abb2f621d817", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef plot_mne_circular_connectivity_network(con_mat, labels, perc_conn=0.25, cfc=False, fig=None, subplot=111, fig_title=None, node_name=True, vmax=None, vmin=0, colormap='Blues', facecolor='white', textcolor='black'):\n    from mne.viz import circular_layout, plot_connectivity_circle\n    fig_title = '' if fig_title is None else fig_title\n    node_colors = [label.color for label in labels]\n    label_names = [label.name for label in labels]\n    lh_labels = [name for name in label_names if name.endswith('lh')]\n    rh_labels = [name for name in label_names if name.endswith('rh')]\n    labels_network_sorted, idx_lbl_sort = rearrange_labels_network(labels)\n    label_names_sorted = [label_names[ii] for ii in idx_lbl_sort]\n    lh_labels = [name[:-3] for name in label_names_sorted if name.endswith('lh')]\n    rh_labels = [name[:-3] for name in label_names_sorted if name.endswith('rh')]\n    label_names = [name[:-3] for name in label_names]\n    node_order = lh_labels[::-1] + rh_labels\n    node_angles = circular_layout(label_names, node_order, start_pos=90, group_boundaries=[0, len(label_names) // 2])\n    if not node_name:\n        label_names = [''] * len(label_names)\n    else:\n        label_names = [label.name[13:-3] for label in labels]\n    if perc_conn < 1:\n        n_lines = int(np.prod(con_mat.shape) / 2 * perc_conn)\n    else:\n        n_lines = None\n    if fig is None:\n        fig = plt.figure(num=None, figsize=(8, 8), facecolor='black')\n    if cfc:\n        return plot_connectivity_circle_cfc(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)\n    else:\n        plot_connectivity_circle(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)", "fn_id": 3, "class_fn": false, "repo": "harmonic-minimization/harmoni_manuscript_codes", "file": "tools_connectivity_plot.py", "last_update_at": "2021-12-16T08:00:15+00:00", "original_content": "def plot_mne_circular_connectivity_network(con_mat, labels, perc_conn=0.25, cfc=False, fig=None, subplot=111, fig_title=None, node_name=True, vmax=None, vmin=0, colormap='Blues', facecolor='white', textcolor='black'):\n    from mne.viz import circular_layout, plot_connectivity_circle\n    fig_title = '' if fig_title is None else fig_title\n    node_colors = [label.color for label in labels]\n    label_names = [label.name for label in labels]\n    lh_labels = [name for name in label_names if name.endswith('lh')]\n    rh_labels = [name for name in label_names if name.endswith('rh')]\n    labels_network_sorted, idx_lbl_sort = rearrange_labels_network(labels)\n    label_names_sorted = [label_names[ii] for ii in idx_lbl_sort]\n    lh_labels = [name[:-3] for name in label_names_sorted if name.endswith('lh')]\n    rh_labels = [name[:-3] for name in label_names_sorted if name.endswith('rh')]\n    label_names = [name[:-3] for name in label_names]\n    node_order = lh_labels[::-1] + rh_labels\n    node_angles = circular_layout(label_names, node_order, start_pos=90, group_boundaries=[0, len(label_names) // 2])\n    if not node_name:\n        label_names = [''] * len(label_names)\n    else:\n        label_names = [label.name[13:-3] for label in labels]\n    if perc_conn < 1:\n        n_lines = int(np.prod(con_mat.shape) / 2 * perc_conn)\n    else:\n        n_lines = None\n    if fig is None:\n        fig = plt.figure(num=None, figsize=(8, 8), facecolor='black')\n    if cfc:\n        return plot_connectivity_circle_cfc(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)\n    else:\n        plot_connectivity_circle(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)", "refactored": true, "pred": {"ppl": 2.1803083419799805, "ppl_lower": 2.2862467765808105, "ppl/lowercase_ppl": -1.0608688306866867, "ppl/zlib": 0.0011955004725066627, "Min_5.0% Prob": 7.576291397213936, "Min_10.0% Prob": 5.719285143338717, "Min_20.0% Prob": 3.668379296706273, "Min_30.0% Prob": 2.5831454829527782, "Min_40.0% Prob": 1.9468158601115946, "Min_50.0% Prob": 1.5608051749320553, "Min_60.0% Prob": 1.301709179385521}}
{"hexsha": "27b7373c43ce0501e65b8ff161bfcf8803e53e2c", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef showmesh(node, elem, **kwargs):\n    triangulation = tri.Triangulation(node[:, 0], node[:, 1], elem)\n    markersize = 3000 / len(node)\n    if kwargs.items():\n        h = plt.triplot(triangulation, 'b-h', **kwargs)\n    else:\n        h = plt.triplot(triangulation, 'b-h', linewidth=0.5, alpha=0.5, markersize=markersize)\n    return h", "fn_id": 0, "class_fn": false, "repo": "scaomath/torch-fem", "file": "mesh/utils.py", "last_update_at": "2021-11-14T04:02:54+00:00", "original_content": "def showmesh(node, elem, **kwargs):\n    triangulation = tri.Triangulation(node[:, 0], node[:, 1], elem)\n    markersize = 3000 / len(node)\n    if kwargs.items():\n        h = plt.triplot(triangulation, 'b-h', **kwargs)\n    else:\n        h = plt.triplot(triangulation, 'b-h', linewidth=0.5, alpha=0.5, markersize=markersize)\n    return h", "refactored": true, "pred": {"ppl": 3.6792309284210205, "ppl_lower": 4.016761302947998, "ppl/lowercase_ppl": -1.0673769372591997, "ppl/zlib": 0.006385802664205551, "Min_5.0% Prob": 10.072059313456217, "Min_10.0% Prob": 8.075364907582602, "Min_20.0% Prob": 5.538981065750122, "Min_30.0% Prob": 4.175502134336008, "Min_40.0% Prob": 3.2265628564357756, "Min_50.0% Prob": 2.621683187662594, "Min_60.0% Prob": 2.1701291076714795}}
{"hexsha": "6e9344b369513894bde3339419e2b7d6be02f344", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef load_character_json(path):\n    with open(path, 'r') as f:\n        raw = f.read()\n        raw = raw.replace('inf,', '999999999,')\n        logging.info('Returning python object')\n        return json.loads(raw)", "fn_id": 1, "class_fn": false, "repo": "trainb0y1/PyMultibound", "file": "editor.py", "last_update_at": "2021-09-18T17:59:47+00:00", "original_content": "def load_character_json(path):\n    with open(path, 'r') as f:\n        raw = f.read()\n        raw = raw.replace('inf,', '999999999,')\n        logging.info('Returning python object')\n        return json.loads(raw)", "refactored": true, "pred": {"ppl": 5.792641639709473, "ppl_lower": 5.911424160003662, "ppl/lowercase_ppl": -1.0115555513092835, "ppl/zlib": 0.010455883507644684, "Min_5.0% Prob": 11.428932825724283, "Min_10.0% Prob": 9.461077349526542, "Min_20.0% Prob": 7.474548435211181, "Min_30.0% Prob": 5.548668654068656, "Min_40.0% Prob": 4.444206583499908, "Min_50.0% Prob": 3.5418427445386587, "Min_60.0% Prob": 2.9337788517384427}}
{"hexsha": "58199be75c2f936778ed896013450ada42119647", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _setup(dataset_dir, label_types=None, classes=None, attrs=None, seed=None, download=False):\n    did_download = False\n    _label_types = _parse_label_types(label_types)\n    if etau.is_str(classes):\n        classes = [classes]\n    if etau.is_str(attrs):\n        attrs = [attrs]\n    if seed is not None:\n        random.seed(seed)\n    classes_map, _did_download = _get_classes_map(dataset_dir, download=download)\n    classes_map_rev = {v: k for k, v in classes_map.items()}\n    did_download |= _did_download\n    all_classes = sorted(classes_map.values())\n    if classes is not None:\n        oi_classes = []\n        missing_classes = []\n        filtered_classes = []\n        for c in classes:\n            if c in classes_map_rev:\n                oi_classes.append(classes_map_rev[c])\n                filtered_classes.append(c)\n            else:\n                missing_classes.append(c)\n        classes = filtered_classes\n        if missing_classes:\n            logger.warning('Ignoring invalid classes %s\\nYou can view the available classes via `fiftyone.utils.openimages.get_classes()`', missing_classes)\n    else:\n        oi_classes = None\n    if 'relationships' in _label_types:\n        attrs_map, _did_download = _get_attrs_map(dataset_dir, download=download)\n        attrs_map_rev = {v: k for k, v in attrs_map.items()}\n        did_download |= _did_download\n        all_attrs = sorted(attrs_map.values())\n        if attrs is None:\n            oi_attrs = [attrs_map_rev[a] for a in all_attrs]\n        else:\n            oi_attrs = []\n            missing_attrs = []\n            filtered_attrs = []\n            for a in attrs:\n                if a in attrs_map_rev:\n                    oi_attrs.append(attrs_map_rev[a])\n                    filtered_attrs.append(a)\n                else:\n                    missing_attrs.append(a)\n            attrs = filtered_attrs\n            if missing_attrs:\n                logger.warning('Ignoring invalid attributes %s\\nYou can view the available attributes via `fiftyone.utils.openimages.get_attributes()`', missing_attrs)\n    else:\n        attrs = None\n        attrs_map = None\n        oi_attrs = None\n        all_attrs = None\n    if 'segmentations' in _label_types:\n        seg_classes, _did_download = _get_seg_classes(dataset_dir, classes_map=classes_map, download=download)\n        did_download |= _did_download\n    else:\n        seg_classes = None\n    return (classes_map, all_classes, classes, oi_classes, attrs_map, all_attrs, attrs, oi_attrs, seg_classes, did_download)", "fn_id": 4, "class_fn": false, "repo": "Fariborzzz/fiftyone", "file": "fiftyone/utils/openimages.py", "last_update_at": "2021-12-17T10:11:37+00:00", "original_content": "def _setup(dataset_dir, label_types=None, classes=None, attrs=None, seed=None, download=False):\n    did_download = False\n    _label_types = _parse_label_types(label_types)\n    if etau.is_str(classes):\n        classes = [classes]\n    if etau.is_str(attrs):\n        attrs = [attrs]\n    if seed is not None:\n        random.seed(seed)\n    classes_map, _did_download = _get_classes_map(dataset_dir, download=download)\n    classes_map_rev = {v: k for k, v in classes_map.items()}\n    did_download |= _did_download\n    all_classes = sorted(classes_map.values())\n    if classes is not None:\n        oi_classes = []\n        missing_classes = []\n        filtered_classes = []\n        for c in classes:\n            if c in classes_map_rev:\n                oi_classes.append(classes_map_rev[c])\n                filtered_classes.append(c)\n            else:\n                missing_classes.append(c)\n        classes = filtered_classes\n        if missing_classes:\n            logger.warning('Ignoring invalid classes %s\\nYou can view the available classes via `fiftyone.utils.openimages.get_classes()`', missing_classes)\n    else:\n        oi_classes = None\n    if 'relationships' in _label_types:\n        attrs_map, _did_download = _get_attrs_map(dataset_dir, download=download)\n        attrs_map_rev = {v: k for k, v in attrs_map.items()}\n        did_download |= _did_download\n        all_attrs = sorted(attrs_map.values())\n        if attrs is None:\n            oi_attrs = [attrs_map_rev[a] for a in all_attrs]\n        else:\n            oi_attrs = []\n            missing_attrs = []\n            filtered_attrs = []\n            for a in attrs:\n                if a in attrs_map_rev:\n                    oi_attrs.append(attrs_map_rev[a])\n                    filtered_attrs.append(a)\n                else:\n                    missing_attrs.append(a)\n            attrs = filtered_attrs\n            if missing_attrs:\n                logger.warning('Ignoring invalid attributes %s\\nYou can view the available attributes via `fiftyone.utils.openimages.get_attributes()`', missing_attrs)\n    else:\n        attrs = None\n        attrs_map = None\n        oi_attrs = None\n        all_attrs = None\n    if 'segmentations' in _label_types:\n        seg_classes, _did_download = _get_seg_classes(dataset_dir, classes_map=classes_map, download=download)\n        did_download |= _did_download\n    else:\n        seg_classes = None\n    return (classes_map, all_classes, classes, oi_classes, attrs_map, all_attrs, attrs, oi_attrs, seg_classes, did_download)", "refactored": true, "pred": {"ppl": 1.9714651107788086, "ppl_lower": 2.0260233879089355, "ppl/lowercase_ppl": -1.0402164085761052, "ppl/zlib": 0.0009851625216097295, "Min_5.0% Prob": 7.7250074498793655, "Min_10.0% Prob": 5.537407264989965, "Min_20.0% Prob": 3.320331066189443, "Min_30.0% Prob": 2.2564627355373488, "Min_40.0% Prob": 1.6998893593765467, "Min_50.0% Prob": 1.357471701092351, "Min_60.0% Prob": 1.1323857797512418}}
{"hexsha": "55c73198735716cc50f10f1745bd41508e18f45d", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef count_verbose_skip(func):\n\n    def decorator(obj, *args, **kw):\n        fname = check_parameters(func, args, kw)\n        if obj.is_truncated() or obj.is_canceled() or obj.is_aborted():\n            return 0\n        if obj.testing_syntax:\n            func(obj, *args, calc_time=True, **kw)\n            return 0\n        obj.debug('{} {} {}'.format(fname, args, kw))\n        return func(obj, *args, **kw)\n    return decorator", "fn_id": 0, "class_fn": false, "repo": "ael-noblegas/pychron", "file": "pychron/pyscripts/decorators.py", "last_update_at": "2021-08-17T15:38:24+00:00", "original_content": "def count_verbose_skip(func):\n\n    def decorator(obj, *args, **kw):\n        fname = check_parameters(func, args, kw)\n        if obj.is_truncated() or obj.is_canceled() or obj.is_aborted():\n            return 0\n        if obj.testing_syntax:\n            func(obj, *args, calc_time=True, **kw)\n            return 0\n        obj.debug('{} {} {}'.format(fname, args, kw))\n        return func(obj, *args, **kw)\n    return decorator", "refactored": true, "pred": {"ppl": 6.995872974395752, "ppl_lower": 7.5424957275390625, "ppl/lowercase_ppl": -1.0386736938008658, "ppl/zlib": 0.008385001724574391, "Min_5.0% Prob": 13.491157372792562, "Min_10.0% Prob": 10.513680898226225, "Min_20.0% Prob": 7.722637735880339, "Min_30.0% Prob": 6.030981470377017, "Min_40.0% Prob": 4.805710539221764, "Min_50.0% Prob": 3.8570544721953794, "Min_60.0% Prob": 3.2417447561327415}}
{"hexsha": "ae4b7326c41a7e04e0d0c89af9536dff4cc979a0", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef process_ccdlab(output=None, time_list=None, XY_integers=None, XY_fractions=None, flat_list=None, framecount_per_sec=framecount_per_sec):\n    \"\"\"Generate a Curvit compatible events list from CCDLAB files.\n\n    Parameters\n    ----------\n    output : file path\n        The name of the output events list FITS file.\n        \n    time_list : file path\n        The name of the CCDLAB time list FITS file\n        \n    XY_integers : file path\n        The name of the CCDLAB XY integers FITS file\n        \n    XY_fractions : file path\n        The name of the CCDLAB XY fractions FITS file\n        \n    flat_list : file path\n        The name of the CCDLAB flat list FITS file\n        \n    framecount_per_sec : float, optional\n        The framerate of the observation, with a default value of 28.7185\n        frames per second for 512 x 512 window mode. \n        The most accurate way to get the framerate would be to take the value \n        of (``1 / INT_TIME``). \n        ``INT_TIME`` value can be found from the corresponding image header. \n        Approximate values of framerate for different window modes of UVIT \n        are given in the table below.\n\n        +---------------+---------------------+\n        | window mode   | frames per second   |\n        +===============+=====================+\n        | 512 x 512     | 28.7                |\n        +---------------+---------------------+\n        | 350 x 350     | 61                  |\n        +---------------+---------------------+\n        | 300 x 300     | 82                  |\n        +---------------+---------------------+\n        | 250 x 250     | 115                 |\n        +---------------+---------------------+\n        | 200 x 200     | 180                 |\n        +---------------+---------------------+\n        | 150 x 150     | 300                 |\n        +---------------+---------------------+\n        | 100 x 100     | 640                 |\n        +---------------+---------------------+ \n        \n\n    Note\n    ---- \n    It is essential to set the correct value of the framerate. \n    Most UVIT observations are carried out in 512 x 512 window mode.\n            \n    Warning\n    -------\n    This function is new; please report if you find any bugs.\n        \n    Example\n    --------\n    >>> import curvit\n    >>> process_ccdlab(output = 'output_events_list.fits',\n    ...                time_list = 'sample_TimeList.fits', \n    ...                XY_integers = 'sample_XYInts_List.fits',\n    ...                XY_fractions = 'sample_XYFrac_List.fits',\n    ...                flat_list = 'sample_FlatList.fits',\n    ...                framecount_per_sec = 28.7185)\n    \n    The above script will generate a FITS table called ``output_events_list.fits``.\n    You may then use it as input to ``curve`` or ``makecurves``. \n    \"\"\"\n    time = fits.open(time_list)[0].data / 1000\n    XYFrac = fits.open(XY_fractions)[0].data\n    XYInts = fits.open(XY_integers)[0].data\n    weight = fits.open(flat_list)[0].data\n    photons = weight * framecount_per_sec\n    fx = CCDLAB_to_4k(XYInts[:, 0], XYFrac[:, 0])\n    fy = CCDLAB_to_4k(XYInts[:, 1], XYFrac[:, 1])\n    col1 = fits.Column(name='MJD_L2', format='D', array=time)\n    col2 = fits.Column(name='Fx', format='D', array=fx)\n    col3 = fits.Column(name='Fy', format='D', array=fy)\n    col4 = fits.Column(name='EFFECTIVE_NUM_PHOTONS', format='D', array=photons)\n    cols = fits.ColDefs([col1, col2, col3, col4])\n    tbhdu = fits.BinTableHDU.from_columns(cols)\n    tbhdu.writeto(output, overwrite=True)\n    return", "fn_id": 14, "class_fn": false, "repo": "prajwel/curvit", "file": "curvit/curvit.py", "last_update_at": "2021-11-15T12:01:29+00:00", "original_content": "def process_ccdlab(output=None, time_list=None, XY_integers=None, XY_fractions=None, flat_list=None, framecount_per_sec=framecount_per_sec):\n    \"\"\"Generate a Curvit compatible events list from CCDLAB files.\n\n    Parameters\n    ----------\n    output : file path\n        The name of the output events list FITS file.\n        \n    time_list : file path\n        The name of the CCDLAB time list FITS file\n        \n    XY_integers : file path\n        The name of the CCDLAB XY integers FITS file\n        \n    XY_fractions : file path\n        The name of the CCDLAB XY fractions FITS file\n        \n    flat_list : file path\n        The name of the CCDLAB flat list FITS file\n        \n    framecount_per_sec : float, optional\n        The framerate of the observation, with a default value of 28.7185\n        frames per second for 512 x 512 window mode. \n        The most accurate way to get the framerate would be to take the value \n        of (``1 / INT_TIME``). \n        ``INT_TIME`` value can be found from the corresponding image header. \n        Approximate values of framerate for different window modes of UVIT \n        are given in the table below.\n\n        +---------------+---------------------+\n        | window mode   | frames per second   |\n        +===============+=====================+\n        | 512 x 512     | 28.7                |\n        +---------------+---------------------+\n        | 350 x 350     | 61                  |\n        +---------------+---------------------+\n        | 300 x 300     | 82                  |\n        +---------------+---------------------+\n        | 250 x 250     | 115                 |\n        +---------------+---------------------+\n        | 200 x 200     | 180                 |\n        +---------------+---------------------+\n        | 150 x 150     | 300                 |\n        +---------------+---------------------+\n        | 100 x 100     | 640                 |\n        +---------------+---------------------+ \n        \n\n    Note\n    ---- \n    It is essential to set the correct value of the framerate. \n    Most UVIT observations are carried out in 512 x 512 window mode.\n            \n    Warning\n    -------\n    This function is new; please report if you find any bugs.\n        \n    Example\n    --------\n    >>> import curvit\n    >>> process_ccdlab(output = 'output_events_list.fits',\n    ...                time_list = 'sample_TimeList.fits', \n    ...                XY_integers = 'sample_XYInts_List.fits',\n    ...                XY_fractions = 'sample_XYFrac_List.fits',\n    ...                flat_list = 'sample_FlatList.fits',\n    ...                framecount_per_sec = 28.7185)\n    \n    The above script will generate a FITS table called ``output_events_list.fits``.\n    You may then use it as input to ``curve`` or ``makecurves``. \n    \"\"\"\n    time = fits.open(time_list)[0].data / 1000\n    XYFrac = fits.open(XY_fractions)[0].data\n    XYInts = fits.open(XY_integers)[0].data\n    weight = fits.open(flat_list)[0].data\n    photons = weight * framecount_per_sec\n    fx = CCDLAB_to_4k(XYInts[:, 0], XYFrac[:, 0])\n    fy = CCDLAB_to_4k(XYInts[:, 1], XYFrac[:, 1])\n    col1 = fits.Column(name='MJD_L2', format='D', array=time)\n    col2 = fits.Column(name='Fx', format='D', array=fx)\n    col3 = fits.Column(name='Fy', format='D', array=fy)\n    col4 = fits.Column(name='EFFECTIVE_NUM_PHOTONS', format='D', array=photons)\n    cols = fits.ColDefs([col1, col2, col3, col4])\n    tbhdu = fits.BinTableHDU.from_columns(cols)\n    tbhdu.writeto(output, overwrite=True)\n    return", "refactored": true, "pred": {"ppl": 3.301694869995117, "ppl_lower": 3.581157684326172, "ppl/lowercase_ppl": -1.068023899623242, "ppl/zlib": 0.0010287992537423522, "Min_5.0% Prob": 10.023391236861547, "Min_10.0% Prob": 7.955455367763837, "Min_20.0% Prob": 5.4005950244597205, "Min_30.0% Prob": 3.910037660804288, "Min_40.0% Prob": 2.978740053525729, "Min_50.0% Prob": 2.388076939394944, "Min_60.0% Prob": 1.9933589136912406}}
{"hexsha": "7d9f104ac0e3008ea503327f64672715cc84a452", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef encode_routing_info(r_tags):\n    result = bitstring.BitArray()\n    for route in r_tags:\n        result.append(bitstring.pack('uint:8', len(route)))\n        for step in route:\n            pubkey, channel, feebase, feerate, cltv = step\n            result.append(bitstring.BitArray(pubkey) + bitstring.BitArray(channel) + bitstring.pack('intbe:32', feebase) + bitstring.pack('intbe:32', feerate) + bitstring.pack('intbe:16', cltv))\n    return result.tobytes()", "fn_id": 0, "class_fn": false, "repo": "RonSherfey/electrum", "file": "electrum/trampoline.py", "last_update_at": "2021-04-22T07:51:24+00:00", "original_content": "def encode_routing_info(r_tags):\n    result = bitstring.BitArray()\n    for route in r_tags:\n        result.append(bitstring.pack('uint:8', len(route)))\n        for step in route:\n            pubkey, channel, feebase, feerate, cltv = step\n            result.append(bitstring.BitArray(pubkey) + bitstring.BitArray(channel) + bitstring.pack('intbe:32', feebase) + bitstring.pack('intbe:32', feerate) + bitstring.pack('intbe:16', cltv))\n    return result.tobytes()", "refactored": true, "pred": {"ppl": 2.6330180168151855, "ppl_lower": 2.883700370788574, "ppl/lowercase_ppl": -1.0939373113960689, "ppl/zlib": 0.004084939760276273, "Min_5.0% Prob": 10.110031264168876, "Min_10.0% Prob": 7.292560386657715, "Min_20.0% Prob": 4.540413765112559, "Min_30.0% Prob": 3.157399181438529, "Min_40.0% Prob": 2.423584477823289, "Min_50.0% Prob": 1.9309194722007235, "Min_60.0% Prob": 1.6195804505487499}}
{"hexsha": "a016e584bf0e1d2da7b3d8766cb1e7cb07b0e46c", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef preprocess(paragraph):\n    result = []\n    sentences = tokenizer.tokenize(paragraph)\n    for sentence in sentences:\n        words = nltk.regexp_tokenize(sentence, pattern)\n        temp = []\n        for word in words:\n            toDeal = []\n            if camelCase1.match(word) or camelCase2.match(word):\n                toDeal = splitCode(word)\n            elif upperExtCase.match(word):\n                toDeal = splitFinalExt(word)\n            else:\n                toDeal.append(word)\n            for deal in toDeal:\n                if not isDelete(deal.lower()):\n                    temp.append(stemmer.stem(deal))\n        result.append(temp)\n    return result", "fn_id": 1, "class_fn": false, "repo": "anonym-user-1/ICSME2021", "file": "preprocessor.py", "last_update_at": "2021-07-01T17:13:10+00:00", "original_content": "def preprocess(paragraph):\n    result = []\n    sentences = tokenizer.tokenize(paragraph)\n    for sentence in sentences:\n        words = nltk.regexp_tokenize(sentence, pattern)\n        temp = []\n        for word in words:\n            toDeal = []\n            if camelCase1.match(word) or camelCase2.match(word):\n                toDeal = splitCode(word)\n            elif upperExtCase.match(word):\n                toDeal = splitFinalExt(word)\n            else:\n                toDeal.append(word)\n            for deal in toDeal:\n                if not isDelete(deal.lower()):\n                    temp.append(stemmer.stem(deal))\n        result.append(temp)\n    return result", "refactored": true, "pred": {"ppl": 4.828506946563721, "ppl_lower": 5.021076202392578, "ppl/lowercase_ppl": -1.0248371344482432, "ppl/zlib": 0.005337414573161151, "Min_5.0% Prob": 12.135619640350342, "Min_10.0% Prob": 10.340223461389542, "Min_20.0% Prob": 7.0959016270935535, "Min_30.0% Prob": 5.116398379827539, "Min_40.0% Prob": 3.9106244219001383, "Min_50.0% Prob": 3.1441199605818837, "Min_60.0% Prob": 2.62332954495893}}
{"hexsha": "225b550790ae56458e3be71c37a81107f822f14e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef find_boost(self):\n    global boost_pos\n    boost_pos = pyAG.locateCenterOnScreen('images/{}.png'.format(self))\n    if boost_pos == None:\n        print('No', self.replace('_', ' '), 'found')\n        return False\n    else:\n        return True", "fn_id": 7, "class_fn": false, "repo": "nebelorz/NST", "file": "NST v1.3 (source)/functions.py", "last_update_at": "2021-11-30T22:09:13+00:00", "original_content": "def find_boost(self):\n    global boost_pos\n    boost_pos = pyAG.locateCenterOnScreen('images/{}.png'.format(self))\n    if boost_pos == None:\n        print('No', self.replace('_', ' '), 'found')\n        return False\n    else:\n        return True", "refactored": true, "pred": {"ppl": 9.641408920288086, "ppl_lower": 12.475783348083496, "ppl/lowercase_ppl": -1.113731038401088, "ppl/zlib": 0.011926669744736417, "Min_5.0% Prob": 14.15213712056478, "Min_10.0% Prob": 10.697813170296806, "Min_20.0% Prob": 8.170105775197348, "Min_30.0% Prob": 6.767254341732372, "Min_40.0% Prob": 5.43553394873937, "Min_50.0% Prob": 4.434842221831021, "Min_60.0% Prob": 3.7958258648713428}}
{"hexsha": "63b326f4f249f15f3d820d4b7228b3b70a34e6a6", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef write_file(filename, data):\n    os.makedirs(os.path.dirname(filename), exist_ok=True)\n    with open(filename, 'w+') as f:\n        print('writing file %s' % filename)\n        f.write(data)", "fn_id": 0, "class_fn": false, "repo": "ahmednofal/DFFRAM", "file": "openlane/rtl/RTL_openlane_flow.py", "last_update_at": "2021-11-08T09:13:45+00:00", "original_content": "def write_file(filename, data):\n    os.makedirs(os.path.dirname(filename), exist_ok=True)\n    with open(filename, 'w+') as f:\n        print('writing file %s' % filename)\n        f.write(data)", "refactored": true, "pred": {"ppl": 3.111384868621826, "ppl_lower": 3.900578022003174, "ppl/lowercase_ppl": -1.1991570953582547, "ppl/zlib": 0.0072760764259831535, "Min_5.0% Prob": 8.056149164835611, "Min_10.0% Prob": 7.376430034637451, "Min_20.0% Prob": 5.371944225751436, "Min_30.0% Prob": 3.808722215890884, "Min_40.0% Prob": 2.8517790021443807, "Min_50.0% Prob": 2.268651579561479, "Min_60.0% Prob": 1.9291740629356355}}
{"hexsha": "67b6579ce4e0d25dfadfeb81d73e475c2f423051", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef millify(n):\n    n = float(n)\n    millidx = max(0, min(len(millnames) - 1, int(math.floor(0 if n == 0 else math.log10(abs(n)) / 3))))\n    return '{:.0f}{}'.format(n / 10 ** (3 * millidx), millnames[millidx])", "fn_id": 0, "class_fn": false, "repo": "ZhiruiFeng/CarsMemory", "file": "web/app.py", "last_update_at": "2021-08-13T11:55:56+00:00", "original_content": "def millify(n):\n    n = float(n)\n    millidx = max(0, min(len(millnames) - 1, int(math.floor(0 if n == 0 else math.log10(abs(n)) / 3))))\n    return '{:.0f}{}'.format(n / 10 ** (3 * millidx), millnames[millidx])", "refactored": true, "pred": {"ppl": 1.8077186346054077, "ppl_lower": 1.8077186346054077, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0033450035446711476, "Min_5.0% Prob": 8.11718463897705, "Min_10.0% Prob": 5.67568646536933, "Min_20.0% Prob": 2.9568963403764523, "Min_30.0% Prob": 1.9665183662597476, "Min_40.0% Prob": 1.5084627667245896, "Min_50.0% Prob": 1.196324572027758, "Min_60.0% Prob": 0.9901546029758375}}
{"hexsha": "e3f7b9dd2486d6d82391b6ab2cce6e07c345cb5c", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef uninitializePlugin(mobject):\n    mplugin = OpenMayaMPx.MFnPlugin(mobject)\n    try:\n        mplugin.deregisterNode(spSimpleSpringNodeId)\n    except:\n        sys.stderr.write('Failed to deregister node: %s' % kPluginNodeTypeName)\n        raise", "fn_id": 2, "class_fn": false, "repo": "leegoonz/Maya-devkit", "file": "osx/devkit/plug-ins/scripted/simpleSpring.py", "last_update_at": "2021-12-07T07:29:19+00:00", "original_content": "def uninitializePlugin(mobject):\n    mplugin = OpenMayaMPx.MFnPlugin(mobject)\n    try:\n        mplugin.deregisterNode(spSimpleSpringNodeId)\n    except:\n        sys.stderr.write('Failed to deregister node: %s' % kPluginNodeTypeName)\n        raise", "refactored": true, "pred": {"ppl": 3.705019950866699, "ppl_lower": 18.10208511352539, "ppl/lowercase_ppl": -2.211233292331642, "ppl/zlib": 0.006929569542766473, "Min_5.0% Prob": 10.342907905578613, "Min_10.0% Prob": 8.702860491616386, "Min_20.0% Prob": 6.440333759784698, "Min_30.0% Prob": 4.383330574502116, "Min_40.0% Prob": 3.2805249210326903, "Min_50.0% Prob": 2.6147307788427825, "Min_60.0% Prob": 2.2195210889103296}}
{"hexsha": "67782e299b60e3d6714308f0cda66ce9bb82d1a5", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_depths(flows, x, h, roughness=0.01, slope=0.001, conv=1.0, dd=0.0001, verbose=False):\n    if isinstance(flows, float):\n        flows = np.array([flows], dtype=float)\n    if isinstance(roughness, float):\n        roughness = np.ones(x.shape, dtype=float) * roughness\n    depths = np.zeros(flows.shape, dtype=float)\n    for idx, q in enumerate(flows):\n        depths[idx] = qtodepth(x, h, q, roughness=roughness, slope=slope, conv=conv, dd=dd, verbose=False)\n    return depths", "fn_id": 7, "class_fn": false, "repo": "scharlton2/modflow6", "file": "autotest/scripts/cross_section_functions.py", "last_update_at": "2021-10-08T00:56:20+00:00", "original_content": "def get_depths(flows, x, h, roughness=0.01, slope=0.001, conv=1.0, dd=0.0001, verbose=False):\n    if isinstance(flows, float):\n        flows = np.array([flows], dtype=float)\n    if isinstance(roughness, float):\n        roughness = np.ones(x.shape, dtype=float) * roughness\n    depths = np.zeros(flows.shape, dtype=float)\n    for idx, q in enumerate(flows):\n        depths[idx] = qtodepth(x, h, q, roughness=roughness, slope=slope, conv=conv, dd=dd, verbose=False)\n    return depths", "refactored": true, "pred": {"ppl": 3.5843563079833984, "ppl_lower": 3.9010610580444336, "ppl/lowercase_ppl": -1.066325454233801, "ppl/zlib": 0.004986636353364152, "Min_5.0% Prob": 9.346854388713837, "Min_10.0% Prob": 7.60509308646707, "Min_20.0% Prob": 5.3201394319534305, "Min_30.0% Prob": 4.009491993830754, "Min_40.0% Prob": 3.121809250542096, "Min_50.0% Prob": 2.5498750112180053, "Min_60.0% Prob": 2.123130876198411}}
{"hexsha": "6a706ba112e6e0c7b57c1e46bd9b0418402db376", "ext": "pyde", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef draw():\n    loadPixels()\n    x = 4.0\n    y = 0.0\n    for i in range(1, 120000, 1):\n        x1 = b * y + f(x)\n        y = -x + f(x1)\n        x = x1\n        pixels[350 + int(x * 26) + (280 - int(y * 26)) * width] = color(i % 255, 100, 100)\n    updatePixels()", "fn_id": 1, "class_fn": false, "repo": "kantel/processingpy", "file": "sketches/mira/mira.pyde", "last_update_at": "2021-08-18T19:55:15+00:00", "original_content": "def draw():\n    loadPixels()\n    x = 4.0\n    y = 0.0\n    for i in range(1, 120000, 1):\n        x1 = b * y + f(x)\n        y = -x + f(x1)\n        x = x1\n        pixels[350 + int(x * 26) + (280 - int(y * 26)) * width] = color(i % 255, 100, 100)\n    updatePixels()", "refactored": true, "pred": {"ppl": 5.147161483764648, "ppl_lower": 5.321177959442139, "ppl/lowercase_ppl": -1.0202932031649268, "ppl/zlib": 0.00840228407449014, "Min_5.0% Prob": 9.953093449274698, "Min_10.0% Prob": 8.003528851729174, "Min_20.0% Prob": 6.138347515693078, "Min_30.0% Prob": 4.773121958971023, "Min_40.0% Prob": 3.903473842818782, "Min_50.0% Prob": 3.210178256034851, "Min_60.0% Prob": 2.726408351305872}}
{"hexsha": "704ba9392622d555589cf12d7af04a6f1811b620", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef energy_plot(scenarios, color_dict):\n    \"\"\"\n    \"\"\"\n    layout = go.Layout(barmode='relative', legend_orientation='h', title='Aggregated supply and demand', paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', yaxis=dict(title='Energy in {}'.format('TWh'), titlefont=dict(size=16, color='rgb(107, 107, 107)'), tickfont=dict(size=14, color='rgb(107, 107, 107)')))\n    data = []\n    for idx, row in scenarios.T.iteritems():\n        if '-cos' in idx:\n            legend = False\n        else:\n            legend = True\n        data.append(go.Bar(x=row.index, y=row.values, text=[v.round(1) if v > 20 or v < -20 else None for v in row.values], hovertext=[', '.join([str(v.round(2)), idx.replace('-cos', '')]) for v in row.values], hoverinfo='text', textposition='auto', showlegend=legend, name=idx, marker=dict(color=color_dict.get(idx.replace('-cos', ''), 'gray'))))\n    return {'data': data, 'layout': layout}", "fn_id": 3, "class_fn": false, "repo": "znes/angus-scenarios", "file": "documentation/plotly_plots.py", "last_update_at": "2021-06-02T01:43:57+00:00", "original_content": "def energy_plot(scenarios, color_dict):\n    \"\"\"\n    \"\"\"\n    layout = go.Layout(barmode='relative', legend_orientation='h', title='Aggregated supply and demand', paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', yaxis=dict(title='Energy in {}'.format('TWh'), titlefont=dict(size=16, color='rgb(107, 107, 107)'), tickfont=dict(size=14, color='rgb(107, 107, 107)')))\n    data = []\n    for idx, row in scenarios.T.iteritems():\n        if '-cos' in idx:\n            legend = False\n        else:\n            legend = True\n        data.append(go.Bar(x=row.index, y=row.values, text=[v.round(1) if v > 20 or v < -20 else None for v in row.values], hovertext=[', '.join([str(v.round(2)), idx.replace('-cos', '')]) for v in row.values], hoverinfo='text', textposition='auto', showlegend=legend, name=idx, marker=dict(color=color_dict.get(idx.replace('-cos', ''), 'gray'))))\n    return {'data': data, 'layout': layout}", "refactored": true, "pred": {"ppl": 2.7520196437835693, "ppl_lower": 3.324342727661133, "ppl/lowercase_ppl": -1.1866347699069555, "ppl/zlib": 0.002028727571239223, "Min_5.0% Prob": 8.151688545942307, "Min_10.0% Prob": 6.3652894124388695, "Min_20.0% Prob": 4.481399232521653, "Min_30.0% Prob": 3.2823456271241107, "Min_40.0% Prob": 2.5128044577878574, "Min_50.0% Prob": 2.026472970889592, "Min_60.0% Prob": 1.6935362415436481}}
{"hexsha": "bb6e599aba13747a581a01c8843fac9626122356", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef show_image_series(image_series: ImageSeries, neurodata_vis_spec: dict):\n    if len(image_series.data.shape) == 3:\n        return show_grayscale_image_series(image_series, neurodata_vis_spec)\n\n    def show_image(index=0, mode='rgb'):\n        fig, ax = plt.subplots(subplot_kw={'xticks': [], 'yticks': []})\n        image = image_series.data[index]\n        if mode == 'bgr':\n            image = image[:, :, ::-1]\n        ax.imshow(image.transpose([1, 0, 2]), cmap='gray', aspect='auto')\n        fig.show()\n        return fig2widget(fig)\n    slider = widgets.IntSlider(value=0, min=0, max=image_series.data.shape[0] - 1, orientation='horizontal', continuous_update=False, description='index')\n    mode = widgets.Dropdown(options=('rgb', 'bgr'), layout=Layout(width='200px'), description='mode')\n    controls = {'index': slider, 'mode': mode}\n    out_fig = widgets.interactive_output(show_image, controls)\n    vbox = widgets.VBox(children=[out_fig, slider, mode])\n    return vbox", "fn_id": 0, "class_fn": false, "repo": "NeurodataWithoutBorders/nwb-jupyter-widgets", "file": "nwbwidgets/image.py", "last_update_at": "2021-11-16T11:50:33+00:00", "original_content": "def show_image_series(image_series: ImageSeries, neurodata_vis_spec: dict):\n    if len(image_series.data.shape) == 3:\n        return show_grayscale_image_series(image_series, neurodata_vis_spec)\n\n    def show_image(index=0, mode='rgb'):\n        fig, ax = plt.subplots(subplot_kw={'xticks': [], 'yticks': []})\n        image = image_series.data[index]\n        if mode == 'bgr':\n            image = image[:, :, ::-1]\n        ax.imshow(image.transpose([1, 0, 2]), cmap='gray', aspect='auto')\n        fig.show()\n        return fig2widget(fig)\n    slider = widgets.IntSlider(value=0, min=0, max=image_series.data.shape[0] - 1, orientation='horizontal', continuous_update=False, description='index')\n    mode = widgets.Dropdown(options=('rgb', 'bgr'), layout=Layout(width='200px'), description='mode')\n    controls = {'index': slider, 'mode': mode}\n    out_fig = widgets.interactive_output(show_image, controls)\n    vbox = widgets.VBox(children=[out_fig, slider, mode])\n    return vbox", "refactored": true, "pred": {"ppl": 2.5553574562072754, "ppl_lower": 3.0849151611328125, "ppl/lowercase_ppl": -1.200739309550727, "ppl/zlib": 0.0018763842369040767, "Min_5.0% Prob": 7.751611932118734, "Min_10.0% Prob": 6.090518760681152, "Min_20.0% Prob": 4.213278758721273, "Min_30.0% Prob": 3.0560609875144538, "Min_40.0% Prob": 2.3265027885676406, "Min_50.0% Prob": 1.8788729658914043, "Min_60.0% Prob": 1.5632365221549538}}
{"hexsha": "ca0dd379bf0cfd2ef3ea5b0e3ce3a98b03b1d3f8", "ext": "py", "lang": "Python", "content": "@api.route('/send_code/<email>', methods=['POST'])\n@cross_domain\n@timeing\n@measure_memory_usage\ndef send_code(email):\n    \"\"\"\n    This endpoint generates a unique code that will be used to allow\n    the user to change his/her password. The unique code is send to\n    the specified email address.\n    \"\"\"\n    from zeeguu.core.emailer.password_reset import send_password_reset_email\n    try:\n        User.find(email)\n    except sqlalchemy.orm.exc.NoResultFound:\n        return bad_request('Email unknown')\n    code = UniqueCode(email)\n    db_session.add(code)\n    db_session.commit()\n    send_password_reset_email(email, code)\n    return 'OK'", "fn_id": 2, "class_fn": false, "repo": "zeeguu-ecosystem/zeeguu-api", "file": "zeeguu/api/api/accounts.py", "last_update_at": "2021-05-26T15:24:49+00:00", "original_content": "@api.route('/send_code/<email>', methods=['POST'])\n@cross_domain\ndef send_code(email):\n    \"\"\"\n    This endpoint generates a unique code that will be used to allow\n    the user to change his/her password. The unique code is send to\n    the specified email address.\n    \"\"\"\n    from zeeguu.core.emailer.password_reset import send_password_reset_email\n    try:\n        User.find(email)\n    except sqlalchemy.orm.exc.NoResultFound:\n        return bad_request('Email unknown')\n    code = UniqueCode(email)\n    db_session.add(code)\n    db_session.commit()\n    send_password_reset_email(email, code)\n    return 'OK'", "refactored": true, "pred": {"ppl": 3.98394775390625, "ppl_lower": 5.621762752532959, "ppl/lowercase_ppl": -1.2491345702939147, "ppl/zlib": 0.0038184343250193585, "Min_5.0% Prob": 9.712593615055084, "Min_10.0% Prob": 7.273780093473547, "Min_20.0% Prob": 5.36862399297602, "Min_30.0% Prob": 4.262327399908328, "Min_40.0% Prob": 3.370413605717645, "Min_50.0% Prob": 2.7632828328845114, "Min_60.0% Prob": 2.3180827203667858}}
{"hexsha": "861044681bbdc6a4088c31b9167d9eb267f0536d", "ext": "py", "lang": "Python", "content": "@app.route('/rest/<jobname>/<jobid>/executionduration')\n@timeing\n@measure_memory_usage\ndef get_executionduration(jobname, jobid):\n    \"\"\"Get the maximum execution duration of job <jobid>\n\n    Returns:\n        200 OK: text/plain: integer number of seconds (on success)\n        404 Not Found: Job not found (on NotFoundWarning)\n        500 Internal Server Error (on error)\n    \"\"\"\n    user = set_user()\n    try:\n        logger.info('{} {}'.format(jobname, jobid))\n        job = Job(jobname, jobid, user)\n        response.content_type = 'text/plain; charset=UTF-8'\n        return str(job.execution_duration)\n    except JobAccessDenied as e:\n        abort_403(str(e))\n    except storage.NotFoundWarning as e:\n        abort_404(str(e))\n    except:\n        abort_500_except()", "fn_id": 45, "class_fn": false, "repo": "ParisAstronomicalDataCentre/OPUS", "file": "uws_server/uws_server.py", "last_update_at": "2021-01-06T08:54:54+00:00", "original_content": "@app.route('/rest/<jobname>/<jobid>/executionduration')\ndef get_executionduration(jobname, jobid):\n    \"\"\"Get the maximum execution duration of job <jobid>\n\n    Returns:\n        200 OK: text/plain: integer number of seconds (on success)\n        404 Not Found: Job not found (on NotFoundWarning)\n        500 Internal Server Error (on error)\n    \"\"\"\n    user = set_user()\n    try:\n        logger.info('{} {}'.format(jobname, jobid))\n        job = Job(jobname, jobid, user)\n        response.content_type = 'text/plain; charset=UTF-8'\n        return str(job.execution_duration)\n    except JobAccessDenied as e:\n        abort_403(str(e))\n    except storage.NotFoundWarning as e:\n        abort_404(str(e))\n    except:\n        abort_500_except()", "refactored": true, "pred": {"ppl": 5.796244144439697, "ppl_lower": 6.416999340057373, "ppl/lowercase_ppl": -1.0578988629437505, "ppl/zlib": 0.0043387904851617115, "Min_5.0% Prob": 10.718671191822398, "Min_10.0% Prob": 9.283355062658137, "Min_20.0% Prob": 7.145980721170252, "Min_30.0% Prob": 5.507580771590725, "Min_40.0% Prob": 4.304322066632184, "Min_50.0% Prob": 3.4957054383375428, "Min_60.0% Prob": 2.9249786639473205}}
{"hexsha": "2c2b3fa036cbe03c2fdfc1bafeba98b37b90d378", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef bbox_sample(region, metric):\n    \"\"\"Extract image that lies within region bounding box\n\n    Parameters\n    ----------\n    region: skimage.RegionProperties\n        Region defining pixels within image to analyse\n    metric: array-like\n        Metric for all pixels in image to be analysed\n    \"\"\"\n    indices = bbox_indices(region)\n    return metric[indices]", "fn_id": 1, "class_fn": false, "repo": "franklongford/ImageCol", "file": "pyfibre/model/tools/utilities.py", "last_update_at": "2021-07-26T05:53:01+00:00", "original_content": "def bbox_sample(region, metric):\n    \"\"\"Extract image that lies within region bounding box\n\n    Parameters\n    ----------\n    region: skimage.RegionProperties\n        Region defining pixels within image to analyse\n    metric: array-like\n        Metric for all pixels in image to be analysed\n    \"\"\"\n    indices = bbox_indices(region)\n    return metric[indices]", "refactored": true, "pred": {"ppl": 12.977686882019043, "ppl_lower": 15.089674949645996, "ppl/lowercase_ppl": -1.0588238882566214, "ppl/zlib": 0.011291768674358446, "Min_5.0% Prob": 11.698158264160156, "Min_10.0% Prob": 9.990065336227417, "Min_20.0% Prob": 8.333076983690262, "Min_30.0% Prob": 6.978651237487793, "Min_40.0% Prob": 5.9342601371533945, "Min_50.0% Prob": 4.989235568614233, "Min_60.0% Prob": 4.271643644869328}}
{"hexsha": "2b6b31ac1b8a4e33d35999ea6fa8cea0493f8cb2", "ext": "py", "lang": "Python", "content": "@njit(fastmath=False, cache=True)\n@timeing\n@measure_memory_usage\ndef get_mean_curvature(traj_list, num_traj):\n    out = np.empty((num_traj,))\n    for i in range(num_traj):\n        out[i] = np.mean(np.abs(traj_list[i * trajectory_generator.NUM_STEPS:(i + 1) * trajectory_generator.NUM_STEPS, 3]))\n    return out", "fn_id": 9, "class_fn": false, "repo": "travelbureau/f0_icml_code", "file": "Simulator/python/mpc/trajectory_generator_utils.py", "last_update_at": "2021-02-17T20:53:38+00:00", "original_content": "@njit(fastmath=False, cache=True)\ndef get_mean_curvature(traj_list, num_traj):\n    out = np.empty((num_traj,))\n    for i in range(num_traj):\n        out[i] = np.mean(np.abs(traj_list[i * trajectory_generator.NUM_STEPS:(i + 1) * trajectory_generator.NUM_STEPS, 3]))\n    return out", "refactored": true, "pred": {"ppl": 4.665168285369873, "ppl_lower": 5.299654483795166, "ppl/lowercase_ppl": -1.082797051832773, "ppl/zlib": 0.0075496269984457135, "Min_5.0% Prob": 9.743642425537109, "Min_10.0% Prob": 8.54695987701416, "Min_20.0% Prob": 6.452692627906799, "Min_30.0% Prob": 4.871893940549908, "Min_40.0% Prob": 3.8071508515964854, "Min_50.0% Prob": 3.0710428407246417, "Min_60.0% Prob": 2.565237720440509}}
{"hexsha": "5148fe31f1a672fe0541555158917c8256ff125f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_dataframe_barh(dataframe, with_plotting_backend):\n    chart = dataframe.plot.barh()\n    spec = chart.to_dict()\n    assert spec['mark'] == {'type': 'bar', 'orient': 'horizontal'}\n    assert spec['encoding']['y']['field'] == 'index'\n    assert spec['encoding']['x']['field'] == 'value'\n    assert spec['encoding']['color']['field'] == 'column'\n    assert spec['transform'][0]['fold'] == ['x', 'y']", "fn_id": 5, "class_fn": false, "repo": "altair-viz/altair_pandas", "file": "altair_pandas/test_plotting.py", "last_update_at": "2021-12-15T21:34:00+00:00", "original_content": "def test_dataframe_barh(dataframe, with_plotting_backend):\n    chart = dataframe.plot.barh()\n    spec = chart.to_dict()\n    assert spec['mark'] == {'type': 'bar', 'orient': 'horizontal'}\n    assert spec['encoding']['y']['field'] == 'index'\n    assert spec['encoding']['x']['field'] == 'value'\n    assert spec['encoding']['color']['field'] == 'column'\n    assert spec['transform'][0]['fold'] == ['x', 'y']", "refactored": true, "pred": {"ppl": 3.6136720180511475, "ppl_lower": 3.6136720180511475, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005634756293350007, "Min_5.0% Prob": 9.388210773468018, "Min_10.0% Prob": 7.981844464937846, "Min_20.0% Prob": 5.580877458055814, "Min_30.0% Prob": 4.020830091592428, "Min_40.0% Prob": 3.175798669761541, "Min_50.0% Prob": 2.5463163464540437, "Min_60.0% Prob": 2.1445496972348237}}
{"hexsha": "ac18a96ded8e760d6d2a171c418c6b63db8231ef", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef init_estimators_train(columns, null_value, no_compression=False):\n    if no_compression:\n        res = [NoCompressionEstimatorTrain(columns, null_value)]\n    else:\n        res = [NoCompressionEstimatorTrain(columns, null_value), DictEstimatorTrain(columns, null_value, max_dict_size), RleEstimatorTrain(columns, null_value), ForEstimatorTrain(columns, null_value)]\n    return res", "fn_id": 1, "class_fn": false, "repo": "bogdanghita/whitebox-compression", "file": "evaluation/theoretical_evaluation.py", "last_update_at": "2021-12-28T05:31:03+00:00", "original_content": "def init_estimators_train(columns, null_value, no_compression=False):\n    if no_compression:\n        res = [NoCompressionEstimatorTrain(columns, null_value)]\n    else:\n        res = [NoCompressionEstimatorTrain(columns, null_value), DictEstimatorTrain(columns, null_value, max_dict_size), RleEstimatorTrain(columns, null_value), ForEstimatorTrain(columns, null_value)]\n    return res", "refactored": true, "pred": {"ppl": 5.020605564117432, "ppl_lower": 7.1197285652160645, "ppl/lowercase_ppl": -1.2164909203783447, "ppl/zlib": 0.009381107887968983, "Min_5.0% Prob": 9.779084968566895, "Min_10.0% Prob": 8.77032504081726, "Min_20.0% Prob": 6.651185194651286, "Min_30.0% Prob": 5.28145370259881, "Min_40.0% Prob": 4.0226456893737925, "Min_50.0% Prob": 3.219964203459245, "Min_60.0% Prob": 2.721135136060184}}
{"hexsha": "0629068ef6b33dbfeb46975094295e4a4c07df96", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef which(program):\n    \"\"\"Determines if and where an executable exists on the users path.\n    This code was contributed by Jay at http://stackoverflow.com/a/377028\n    Args:\n        program (str): The name, or path for the program.\n    Returns:\n        The program or executable.\n    \"\"\"\n    import os\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n    fpath, fname = os.path.split(program)\n    if fpath and is_exe(program):\n        return program\n    else:\n        for path in os.environ['PATH'].split(os.pathsep):\n            path = path.strip('\"')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n    return None", "fn_id": 5, "class_fn": false, "repo": "wsmorgan/phonon-enumeration", "file": "phenum/io_utils.py", "last_update_at": "2021-05-30T21:02:08+00:00", "original_content": "def which(program):\n    \"\"\"Determines if and where an executable exists on the users path.\n    This code was contributed by Jay at http://stackoverflow.com/a/377028\n    Args:\n        program (str): The name, or path for the program.\n    Returns:\n        The program or executable.\n    \"\"\"\n    import os\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n    fpath, fname = os.path.split(program)\n    if fpath and is_exe(program):\n        return program\n    else:\n        for path in os.environ['PATH'].split(os.pathsep):\n            path = path.strip('\"')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n    return None", "refactored": true, "pred": {"ppl": 2.499896764755249, "ppl_lower": 3.3637094497680664, "ppl/lowercase_ppl": -1.323923725390874, "ppl/zlib": 0.0023860662419886197, "Min_5.0% Prob": 9.32781457901001, "Min_10.0% Prob": 7.142334246635437, "Min_20.0% Prob": 4.484904216557014, "Min_30.0% Prob": 3.049983726994645, "Min_40.0% Prob": 2.312047464273325, "Min_50.0% Prob": 1.8412970607914936, "Min_60.0% Prob": 1.529529999253892}}
{"hexsha": "12f9436289446182577ceaab3eda30ea64c2e38b", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef upscale2d_conv2d(x, fmaps, kernel, gain=np.sqrt(2), use_wscale=False):\n    assert kernel >= 1 and kernel % 2 == 1\n    w = get_weight([kernel, kernel, fmaps, x.shape[1].value], gain=gain, use_wscale=use_wscale, fan_in=kernel ** 2 * x.shape[1].value)\n    w = tf.pad(w, [[1, 1], [1, 1], [0, 0], [0, 0]], mode='CONSTANT')\n    w = tf.add_n([w[1:, 1:], w[:-1, 1:], w[1:, :-1], w[:-1, :-1]])\n    w = tf.cast(w, x.dtype)\n    os = [tf.shape(x)[0], fmaps, x.shape[2] * 2, x.shape[3] * 2]\n    return tf.nn.conv2d_transpose(x, w, os, strides=[1, 1, 2, 2], padding='SAME', data_format='NCHW')", "fn_id": 7, "class_fn": false, "repo": "zhuxinqimac/stylegan2", "file": "training/vc2_subnets_pggan.py", "last_update_at": "2021-07-04T09:51:28+00:00", "original_content": "def upscale2d_conv2d(x, fmaps, kernel, gain=np.sqrt(2), use_wscale=False):\n    assert kernel >= 1 and kernel % 2 == 1\n    w = get_weight([kernel, kernel, fmaps, x.shape[1].value], gain=gain, use_wscale=use_wscale, fan_in=kernel ** 2 * x.shape[1].value)\n    w = tf.pad(w, [[1, 1], [1, 1], [0, 0], [0, 0]], mode='CONSTANT')\n    w = tf.add_n([w[1:, 1:], w[:-1, 1:], w[1:, :-1], w[:-1, :-1]])\n    w = tf.cast(w, x.dtype)\n    os = [tf.shape(x)[0], fmaps, x.shape[2] * 2, x.shape[3] * 2]\n    return tf.nn.conv2d_transpose(x, w, os, strides=[1, 1, 2, 2], padding='SAME', data_format='NCHW')", "refactored": true, "pred": {"ppl": 1.6149799823760986, "ppl_lower": 1.7853869199752808, "ppl/lowercase_ppl": -1.209279929313995, "ppl/zlib": 0.0013426402290875135, "Min_5.0% Prob": 5.952067705301138, "Min_10.0% Prob": 4.103745023409526, "Min_20.0% Prob": 2.3596872604555554, "Min_30.0% Prob": 1.5908277139703675, "Min_40.0% Prob": 1.2029578195235462, "Min_50.0% Prob": 0.9584157688604382, "Min_60.0% Prob": 0.8007786534763887}}
{"hexsha": "5306ddb4712ea725043386b81d8c897bbc57d019", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_first_pos(vcf):\n    p = {}\n    for line in file_util.gzopen(vcf):\n        line = file_util.decodeb(line)\n        if line[0] != '#':\n            arr = line.split('\\t')\n            print(arr)\n            p['chrom'] = arr[0]\n            p['spos'] = int(arr[1])\n            p['epos'] = int(arr[1])\n            p['str'] = p['chrom'] + ':' + str(p['spos']) + '-' + str(p['epos'])\n    return p", "fn_id": 0, "class_fn": false, "repo": "dbmi-bgm/cgap-annotation-server", "file": "tests/annotviewer.py", "last_update_at": "2021-05-27T14:27:47+00:00", "original_content": "def get_first_pos(vcf):\n    p = {}\n    for line in file_util.gzopen(vcf):\n        line = file_util.decodeb(line)\n        if line[0] != '#':\n            arr = line.split('\\t')\n            print(arr)\n            p['chrom'] = arr[0]\n            p['spos'] = int(arr[1])\n            p['epos'] = int(arr[1])\n            p['str'] = p['chrom'] + ':' + str(p['spos']) + '-' + str(p['epos'])\n    return p", "refactored": true, "pred": {"ppl": 3.0422985553741455, "ppl_lower": 3.0422985553741455, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005127250384595375, "Min_5.0% Prob": 9.638033253805977, "Min_10.0% Prob": 7.805221625736782, "Min_20.0% Prob": 5.215921555246625, "Min_30.0% Prob": 3.668799221160866, "Min_40.0% Prob": 2.7720807744190097, "Min_50.0% Prob": 2.223602482689811, "Min_60.0% Prob": 1.854010451122165}}
{"hexsha": "427cceb85af895991c1b9f9596f2e1bb0c5b7263", "ext": "py", "lang": "Python", "content": "def deprecated(version, reason):\n\n    @timeing\n    @measure_memory_usage\n    def decorator_deprecated(fn):\n\n        @wraps(fn)\n        def wrapper_deprecated(*args, **kwds):\n            warnings.warn(f'Deprecated since {version}. The reason: {reason}', category=DeprecationWarning)\n            return fn(*args, **kwds)\n        return wrapper_deprecated\n    return decorator_deprecated", "fn_id": 16, "class_fn": false, "repo": "Sberbank-Technology/ignite-python-thin-client", "file": "pyignite/utils.py", "last_update_at": "2021-07-16T01:35:39+00:00", "original_content": "def deprecated(version, reason):\n\n    def decorator_deprecated(fn):\n\n        @wraps(fn)\n        def wrapper_deprecated(*args, **kwds):\n            warnings.warn(f'Deprecated since {version}. The reason: {reason}', category=DeprecationWarning)\n            return fn(*args, **kwds)\n        return wrapper_deprecated\n    return decorator_deprecated", "refactored": true, "pred": {"ppl": 4.649106025695801, "ppl_lower": 5.9996843338012695, "ppl/lowercase_ppl": -1.1659634709794102, "ppl/zlib": 0.007921004889576491, "Min_5.0% Prob": 11.311817169189453, "Min_10.0% Prob": 9.355496227741241, "Min_20.0% Prob": 6.201980913386626, "Min_30.0% Prob": 4.910834851264954, "Min_40.0% Prob": 3.8226682517458412, "Min_50.0% Prob": 3.0663416292085204, "Min_60.0% Prob": 2.5909968686892704}}
{"hexsha": "208074ab27944df3955e997903e9acaee5afdb6b", "ext": "py", "lang": "Python", "content": "@pytest.fixture\n@timeing\n@measure_memory_usage\ndef rus_player_json():\n    \"\"\"Expected JSON for rus_player model-fixture\"\"\"\n    return {'name': 'Rus', 'id_': 'PjBYO_8gbf'}", "fn_id": 0, "class_fn": false, "repo": "BenjaminNMitchell/Pyker", "file": "test/encoders/json_fixtures.py", "last_update_at": "2021-04-12T17:18:19+00:00", "original_content": "@pytest.fixture\ndef rus_player_json():\n    \"\"\"Expected JSON for rus_player model-fixture\"\"\"\n    return {'name': 'Rus', 'id_': 'PjBYO_8gbf'}", "refactored": true, "pred": {"ppl": 34.31033706665039, "ppl_lower": 33.69565963745117, "ppl/lowercase_ppl": -0.9948867434068445, "ppl/zlib": 0.02388815324982408, "Min_5.0% Prob": 13.951558589935303, "Min_10.0% Prob": 12.26039981842041, "Min_20.0% Prob": 10.137858477505771, "Min_30.0% Prob": 8.738095171311322, "Min_40.0% Prob": 7.530648853467858, "Min_50.0% Prob": 6.52962522260074, "Min_60.0% Prob": 5.7941654920578}}
{"hexsha": "2c502e5877d8fa61f6c9c0acfe9451fb744aa183", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef create_table(name):\n    name = name.title()\n    name = name.split()\n    name = ''.join(name)\n    with sqlite3.connect('supplies.db') as conn:\n        cur = conn.cursor()\n        cur.execute(f'CREATE TABLE IF NOT EXISTS {name} (Item TEXT, Part Number TEXT, Description TEXT, Vendor TEXT, Price REAL, QOH INT, QNeed INT, Ordering TEXT, Ordered DATE)')", "fn_id": 0, "class_fn": false, "repo": "irondru562/InventoryManagement", "file": "inback.py", "last_update_at": "2021-04-14T18:41:41+00:00", "original_content": "def create_table(name):\n    name = name.title()\n    name = name.split()\n    name = ''.join(name)\n    with sqlite3.connect('supplies.db') as conn:\n        cur = conn.cursor()\n        cur.execute(f'CREATE TABLE IF NOT EXISTS {name} (Item TEXT, Part Number TEXT, Description TEXT, Vendor TEXT, Price REAL, QOH INT, QNeed INT, Ordering TEXT, Ordered DATE)')", "refactored": true, "pred": {"ppl": 5.641092777252197, "ppl_lower": 7.5316314697265625, "ppl/lowercase_ppl": -1.1670640933912444, "ppl/zlib": 0.006705727913077032, "Min_5.0% Prob": 9.552301597595214, "Min_10.0% Prob": 8.54094967842102, "Min_20.0% Prob": 6.509318294979277, "Min_30.0% Prob": 5.190477900207043, "Min_40.0% Prob": 4.2104155378682275, "Min_50.0% Prob": 3.4462757093726464, "Min_60.0% Prob": 2.8826669446425512}}
{"hexsha": "5b2a8ea69b3198b3f678cebb3485c95da3b6d811", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _graph_from_dict(P, weights=False):\n    G = pairDiGraph()\n    for (a, b), n in P.items():\n        if weights:\n            G.add_edge(a, b, weight=n)\n        else:\n            G.add_edge(a, b)\n    if weights:\n        G.addPd()\n    return G", "fn_id": 2, "class_fn": false, "repo": "jpgil/logdelay", "file": "src/theory202105.py", "last_update_at": "2021-05-28T16:03:39+00:00", "original_content": "def _graph_from_dict(P, weights=False):\n    G = pairDiGraph()\n    for (a, b), n in P.items():\n        if weights:\n            G.add_edge(a, b, weight=n)\n        else:\n            G.add_edge(a, b)\n    if weights:\n        G.addPd()\n    return G", "refactored": true, "pred": {"ppl": 5.105680465698242, "ppl_lower": 6.280346870422363, "ppl/lowercase_ppl": -1.1270101522982556, "ppl/zlib": 0.01006391195493909, "Min_5.0% Prob": 14.531797170639038, "Min_10.0% Prob": 10.42618661456638, "Min_20.0% Prob": 7.309497541851467, "Min_30.0% Prob": 5.311811168988545, "Min_40.0% Prob": 4.0524714113109646, "Min_50.0% Prob": 3.2554058199127516, "Min_60.0% Prob": 2.7164187009653284}}
{"hexsha": "2c730cc2f3073d60e2b37cd3db6bc2590e864582", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef parse_args():\n    parser = argparse.ArgumentParser(description='Train a network with Detectron')\n    parser.add_argument('--cfg', dest='cfg_file', help='Config file for training (and optionally testing)', default=None, type=str)\n    parser.add_argument('--multi-gpu-testing', dest='multi_gpu_testing', help='Use cfg.NUM_GPUS GPUs for inference', action='store_true')\n    parser.add_argument('--skip-test', dest='skip_test', help='Do not test the final model', action='store_true')\n    parser.add_argument('opts', help='See detectron/core/config.py for all options', default=None, nargs=argparse.REMAINDER)\n    if len(sys.argv) == 1:\n        parser.print_help()\n        sys.exit(1)\n    return parser.parse_args()", "fn_id": 0, "class_fn": false, "repo": "994374821/maskrcnn_body25", "file": "tools/train_stage2.py", "last_update_at": "2021-10-12T22:58:13+00:00", "original_content": "def parse_args():\n    parser = argparse.ArgumentParser(description='Train a network with Detectron')\n    parser.add_argument('--cfg', dest='cfg_file', help='Config file for training (and optionally testing)', default=None, type=str)\n    parser.add_argument('--multi-gpu-testing', dest='multi_gpu_testing', help='Use cfg.NUM_GPUS GPUs for inference', action='store_true')\n    parser.add_argument('--skip-test', dest='skip_test', help='Do not test the final model', action='store_true')\n    parser.add_argument('opts', help='See detectron/core/config.py for all options', default=None, nargs=argparse.REMAINDER)\n    if len(sys.argv) == 1:\n        parser.print_help()\n        sys.exit(1)\n    return parser.parse_args()", "refactored": true, "pred": {"ppl": 1.4773378372192383, "ppl_lower": 2.0423882007598877, "ppl/lowercase_ppl": -1.8299422960817242, "ppl/zlib": 0.0010323854746863955, "Min_5.0% Prob": 5.334777283668518, "Min_10.0% Prob": 3.5063317787079584, "Min_20.0% Prob": 1.9159298743165674, "Min_30.0% Prob": 1.2935447836265204, "Min_40.0% Prob": 0.9747302928673369, "Min_50.0% Prob": 0.7803980351691799, "Min_60.0% Prob": 0.6503868695661021}}
{"hexsha": "01415ebda64b25b4823eab1699f9886d6bb0651b", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_buildings_in_radius(poly: Polygon, radius: float, excluded_poly: Polygon=None) -> List[Polygon]:\n    \"\"\"\n    Get all buildings within $radius\n    Args:\n        poly: polygon to intersect the buildings in\n        radius: radius from within we will retrieve all buildings\n        excluded_poly: optional polygon to exclude from the nearest\n\n    Returns:\n        A Geoseries with all the polygons of the buildings\n    \"\"\"\n    eng = get_connection('POSTGRES')\n    if excluded_poly is not None:\n        excluded_sql = f\"AND ST_INTERSECTS(way, ST_GEOMFROMTEXT('{excluded_poly.wkt}', 4326))=FALSE\"\n    else:\n        excluded_sql = ''\n    query = f\"\\n        SELECT st_astext(way) as geom FROM (\\n            SELECT way\\n            FROM {OSM_POLYGON_TABLE}\\n            WHERE {BUILDING}\\n                  {excluded_sql}\\n                  AND ST_DWithin(way, ST_GEOMFROMTEXT('{poly.wkt}', 4326), {radius}, true)\\n            ) t\\n        \"\n    df = get_df(query, eng)\n    eng.dispose()\n    gs = [wkt.loads(geom) for geom in df['geom'].unique()]\n    return gs", "fn_id": 3, "class_fn": false, "repo": "jonzarecki/coord2vec", "file": "coord2vec/feature_extraction/osm/osm_utils.py", "last_update_at": "2021-01-25T09:21:17+00:00", "original_content": "def get_buildings_in_radius(poly: Polygon, radius: float, excluded_poly: Polygon=None) -> List[Polygon]:\n    \"\"\"\n    Get all buildings within $radius\n    Args:\n        poly: polygon to intersect the buildings in\n        radius: radius from within we will retrieve all buildings\n        excluded_poly: optional polygon to exclude from the nearest\n\n    Returns:\n        A Geoseries with all the polygons of the buildings\n    \"\"\"\n    eng = get_connection('POSTGRES')\n    if excluded_poly is not None:\n        excluded_sql = f\"AND ST_INTERSECTS(way, ST_GEOMFROMTEXT('{excluded_poly.wkt}', 4326))=FALSE\"\n    else:\n        excluded_sql = ''\n    query = f\"\\n        SELECT st_astext(way) as geom FROM (\\n            SELECT way\\n            FROM {OSM_POLYGON_TABLE}\\n            WHERE {BUILDING}\\n                  {excluded_sql}\\n                  AND ST_DWithin(way, ST_GEOMFROMTEXT('{poly.wkt}', 4326), {radius}, true)\\n            ) t\\n        \"\n    df = get_df(query, eng)\n    eng.dispose()\n    gs = [wkt.loads(geom) for geom in df['geom'].unique()]\n    return gs", "refactored": true, "pred": {"ppl": 4.9458088874816895, "ppl_lower": 5.560256481170654, "ppl/lowercase_ppl": -1.073256640213863, "ppl/zlib": 0.00297679800472819, "Min_5.0% Prob": 10.509885660807292, "Min_10.0% Prob": 8.782248417536417, "Min_20.0% Prob": 6.55882176955541, "Min_30.0% Prob": 5.041732721858555, "Min_40.0% Prob": 3.947371317827997, "Min_50.0% Prob": 3.1982923070622595, "Min_60.0% Prob": 2.6744227732907344}}
{"hexsha": "0ea7da24a0926bef44f6a6ab9c0f2b679c6306d1", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_corner_loss_lidar(pred_bbox3d, gt_bbox3d):\n    \"\"\"\n    :param pred_bbox3d: (N, 7)\n    :param gt_bbox3d: (N, 7)\n    :return: corner_loss: (N)\n    \"\"\"\n    assert pred_bbox3d.shape[0] == gt_bbox3d.shape[0]\n    pred_box_corners = box_torch_ops.center_to_corner_box3d(pred_bbox3d[:, 0:3], pred_bbox3d[:, 3:6], pred_bbox3d[:, 6], [0.5, 0.5, 0], axis=2)\n    gt_box_corners = box_torch_ops.center_to_corner_box3d(gt_bbox3d[:, 0:3], gt_bbox3d[:, 3:6], gt_bbox3d[:, 6], [0.5, 0.5, 0], axis=2)\n    gt_bbox3d_flip = gt_bbox3d.clone()\n    gt_bbox3d_flip[:, 6] += np.pi\n    gt_box_corners_flip = box_torch_ops.center_to_corner_box3d(gt_bbox3d_flip[:, 0:3], gt_bbox3d_flip[:, 3:6], gt_bbox3d_flip[:, 6], [0.5, 0.5, 0], axis=2)\n    corner_dist = torch.min(torch.norm(pred_box_corners - gt_box_corners, dim=2), torch.norm(pred_box_corners - gt_box_corners_flip, dim=2))\n    corner_loss = huber_loss(corner_dist, delta=1.0)\n    return corner_loss.mean(dim=1)", "fn_id": 2, "class_fn": false, "repo": "xy-guo/mmdetection_kitti", "file": "mmdet/utils/det3d/loss_utils.py", "last_update_at": "2021-12-27T10:59:51+00:00", "original_content": "def get_corner_loss_lidar(pred_bbox3d, gt_bbox3d):\n    \"\"\"\n    :param pred_bbox3d: (N, 7)\n    :param gt_bbox3d: (N, 7)\n    :return: corner_loss: (N)\n    \"\"\"\n    assert pred_bbox3d.shape[0] == gt_bbox3d.shape[0]\n    pred_box_corners = box_torch_ops.center_to_corner_box3d(pred_bbox3d[:, 0:3], pred_bbox3d[:, 3:6], pred_bbox3d[:, 6], [0.5, 0.5, 0], axis=2)\n    gt_box_corners = box_torch_ops.center_to_corner_box3d(gt_bbox3d[:, 0:3], gt_bbox3d[:, 3:6], gt_bbox3d[:, 6], [0.5, 0.5, 0], axis=2)\n    gt_bbox3d_flip = gt_bbox3d.clone()\n    gt_bbox3d_flip[:, 6] += np.pi\n    gt_box_corners_flip = box_torch_ops.center_to_corner_box3d(gt_bbox3d_flip[:, 0:3], gt_bbox3d_flip[:, 3:6], gt_bbox3d_flip[:, 6], [0.5, 0.5, 0], axis=2)\n    corner_dist = torch.min(torch.norm(pred_box_corners - gt_box_corners, dim=2), torch.norm(pred_box_corners - gt_box_corners_flip, dim=2))\n    corner_loss = huber_loss(corner_dist, delta=1.0)\n    return corner_loss.mean(dim=1)", "refactored": true, "pred": {"ppl": 1.3507884740829468, "ppl_lower": 1.3754810094833374, "ppl/lowercase_ppl": -1.060245136031391, "ppl/zlib": 0.0008843778730380223, "Min_5.0% Prob": 4.929930130640666, "Min_10.0% Prob": 2.9010098569614944, "Min_20.0% Prob": 1.5010775394908997, "Min_30.0% Prob": 1.002296355961758, "Min_40.0% Prob": 0.7551147502561999, "Min_50.0% Prob": 0.6027479028316103, "Min_60.0% Prob": 0.5015289362431585}}
{"hexsha": "605df9b62c38bf133d0aa401619574d4bb7f6839", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_position(fallback=defaults.CURSOR_POS_FALLBACK):\n    \"\"\" Return the current column number of the terminal cursor.\n        Used to figure out if we need to print an extra newline.\n\n        Returns:\n            tuple(int): (x, y) | (,)  - empty, if an error occurred.\n    \"\"\"\n    values = fallback\n    try:\n        with TermStack() as fd:\n            termios.tcflush(fd, termios.TCIFLUSH)\n            tty.setcbreak(fd, termios.TCSANOW)\n            sys.stdout.write(CSI + '6n')\n            sys.stdout.flush()\n            log.debug('about to read get_position response\u2026')\n            resp = _read_until_select(max_bytes=10, end='R')\n    except AttributeError:\n        return values\n    resp = resp.lstrip(CSI)\n    try:\n        values = tuple((int(token) for token in resp.partition(';')[::-2]))\n    except (ValueError, IndexError) as err:\n        log.error('parse error: %s on %r', err, resp)\n    return values", "fn_id": 16, "class_fn": false, "repo": "Dsa-Terminal/Dsa-Terminal", "file": "Python3/Lib/site-packages/console/detection.py", "last_update_at": "2021-04-02T17:14:25+00:00", "original_content": "def get_position(fallback=defaults.CURSOR_POS_FALLBACK):\n    \"\"\" Return the current column number of the terminal cursor.\n        Used to figure out if we need to print an extra newline.\n\n        Returns:\n            tuple(int): (x, y) | (,)  - empty, if an error occurred.\n    \"\"\"\n    values = fallback\n    try:\n        with TermStack() as fd:\n            termios.tcflush(fd, termios.TCIFLUSH)\n            tty.setcbreak(fd, termios.TCSANOW)\n            sys.stdout.write(CSI + '6n')\n            sys.stdout.flush()\n            log.debug('about to read get_position response\u2026')\n            resp = _read_until_select(max_bytes=10, end='R')\n    except AttributeError:\n        return values\n    resp = resp.lstrip(CSI)\n    try:\n        values = tuple((int(token) for token in resp.partition(';')[::-2]))\n    except (ValueError, IndexError) as err:\n        log.error('parse error: %s on %r', err, resp)\n    return values", "refactored": true, "pred": {"ppl": 7.7780842781066895, "ppl_lower": 9.515582084655762, "ppl/lowercase_ppl": -1.098288701483844, "ppl/zlib": 0.003914713876186722, "Min_5.0% Prob": 12.141865571339926, "Min_10.0% Prob": 10.256678314208985, "Min_20.0% Prob": 8.060592810312906, "Min_30.0% Prob": 6.316598675752941, "Min_40.0% Prob": 4.99812581784585, "Min_50.0% Prob": 4.0874726171568625, "Min_60.0% Prob": 3.412687351257583}}
{"hexsha": "5ee4210df799d29db459911536ee02f9a5a1fd24", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef readlines(file):\n    with open(file) as f:\n        content = f.readlines()\n    return [x.strip() for x in content]", "fn_id": 1, "class_fn": false, "repo": "omidroshani/DeepDIA", "file": "code/deepdetect/py/predict_ensemble.py", "last_update_at": "2021-12-25T20:09:40+00:00", "original_content": "def readlines(file):\n    with open(file) as f:\n        content = f.readlines()\n    return [x.strip() for x in content]", "refactored": true, "pred": {"ppl": 4.279530048370361, "ppl_lower": 4.279530048370361, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.012426010271644637, "Min_5.0% Prob": 8.286144256591797, "Min_10.0% Prob": 7.915749549865723, "Min_20.0% Prob": 6.461580574512482, "Min_30.0% Prob": 4.750158731754009, "Min_40.0% Prob": 3.744914696935345, "Min_50.0% Prob": 2.902984351597049, "Min_60.0% Prob": 2.4594989073677707}}
{"hexsha": "12e6a066caf160f30a66f07074f6d4b7810f6f9d", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef motion(pin):\n    print('Bewegung erkannt')\n    with picamera.PiCamera() as camera:\n        for filename in camera.capture_continuous('/home/pi/Desktop/Fotos/{timestamp:%d.%m_%H-%M-%S}Uhr.jpg'):\n            print('Captured %s' % filename)\n            break", "fn_id": 0, "class_fn": false, "repo": "meigrafd/Sample-Code", "file": "PIR_interrupt_pic.py", "last_update_at": "2021-03-31T04:22:25+00:00", "original_content": "def motion(pin):\n    print('Bewegung erkannt')\n    with picamera.PiCamera() as camera:\n        for filename in camera.capture_continuous('/home/pi/Desktop/Fotos/{timestamp:%d.%m_%H-%M-%S}Uhr.jpg'):\n            print('Captured %s' % filename)\n            break", "refactored": true, "pred": {"ppl": 6.3703932762146, "ppl_lower": 10.207191467285156, "ppl/lowercase_ppl": -1.254599118637489, "ppl/zlib": 0.008988646633434513, "Min_5.0% Prob": 10.31090784072876, "Min_10.0% Prob": 9.09925639629364, "Min_20.0% Prob": 7.0464348793029785, "Min_30.0% Prob": 5.716927900314331, "Min_40.0% Prob": 4.554386580691618, "Min_50.0% Prob": 3.6848238734311836, "Min_60.0% Prob": 3.116854662258251}}
{"hexsha": "971e98315817be02de95647ef3faaea39f4b2047", "ext": "py", "lang": "Python", "content": "@export\n@timeing\n@measure_memory_usage\ndef tlv_pack(*args):\n    if len(args) == 2:\n        tlv = {'type': args[0], 'value': args[1]}\n    else:\n        tlv = args[0]\n    data = ''\n    if tlv['type'] & TLV_META_TYPE_UINT == TLV_META_TYPE_UINT:\n        data = struct.pack('>III', 12, tlv['type'], tlv['value'])\n    elif tlv['type'] & TLV_META_TYPE_QWORD == TLV_META_TYPE_QWORD:\n        data = struct.pack('>IIQ', 16, tlv['type'], tlv['value'])\n    elif tlv['type'] & TLV_META_TYPE_BOOL == TLV_META_TYPE_BOOL:\n        data = struct.pack('>II', 9, tlv['type']) + bytes(chr(int(bool(tlv['value']))), 'UTF-8')\n    else:\n        value = tlv['value']\n        if sys.version_info[0] < 3 and value.__class__.__name__ == 'unicode':\n            value = value.encode('UTF-8')\n        elif not is_bytes(value):\n            value = bytes(value, 'UTF-8')\n        if tlv['type'] & TLV_META_TYPE_STRING == TLV_META_TYPE_STRING:\n            data = struct.pack('>II', 8 + len(value) + 1, tlv['type']) + value + NULL_BYTE\n        elif tlv['type'] & TLV_META_TYPE_RAW == TLV_META_TYPE_RAW:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n        elif tlv['type'] & TLV_META_TYPE_GROUP == TLV_META_TYPE_GROUP:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n        elif tlv['type'] & TLV_META_TYPE_COMPLEX == TLV_META_TYPE_COMPLEX:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n    return data", "fn_id": 6, "class_fn": false, "repo": "madhavarao-yejarla/VoIP", "file": "data/meterpreter/meterpreter.py", "last_update_at": "2021-04-07T18:00:44+00:00", "original_content": "@export\ndef tlv_pack(*args):\n    if len(args) == 2:\n        tlv = {'type': args[0], 'value': args[1]}\n    else:\n        tlv = args[0]\n    data = ''\n    if tlv['type'] & TLV_META_TYPE_UINT == TLV_META_TYPE_UINT:\n        data = struct.pack('>III', 12, tlv['type'], tlv['value'])\n    elif tlv['type'] & TLV_META_TYPE_QWORD == TLV_META_TYPE_QWORD:\n        data = struct.pack('>IIQ', 16, tlv['type'], tlv['value'])\n    elif tlv['type'] & TLV_META_TYPE_BOOL == TLV_META_TYPE_BOOL:\n        data = struct.pack('>II', 9, tlv['type']) + bytes(chr(int(bool(tlv['value']))), 'UTF-8')\n    else:\n        value = tlv['value']\n        if sys.version_info[0] < 3 and value.__class__.__name__ == 'unicode':\n            value = value.encode('UTF-8')\n        elif not is_bytes(value):\n            value = bytes(value, 'UTF-8')\n        if tlv['type'] & TLV_META_TYPE_STRING == TLV_META_TYPE_STRING:\n            data = struct.pack('>II', 8 + len(value) + 1, tlv['type']) + value + NULL_BYTE\n        elif tlv['type'] & TLV_META_TYPE_RAW == TLV_META_TYPE_RAW:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n        elif tlv['type'] & TLV_META_TYPE_GROUP == TLV_META_TYPE_GROUP:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n        elif tlv['type'] & TLV_META_TYPE_COMPLEX == TLV_META_TYPE_COMPLEX:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n    return data", "refactored": true, "pred": {"ppl": 1.612273931503296, "ppl_lower": 1.7235980033874512, "ppl/lowercase_ppl": -1.1397865096724686, "ppl/zlib": 0.0010709541756544038, "Min_5.0% Prob": 6.100949230194092, "Min_10.0% Prob": 4.313530445098877, "Min_20.0% Prob": 2.3731071094770244, "Min_30.0% Prob": 1.5968424301949868, "Min_40.0% Prob": 1.1973096530579417, "Min_50.0% Prob": 0.9571176388772575, "Min_60.0% Prob": 0.7971110736489387}}
{"hexsha": "83e9ee54f5b91fb9bed39ac8b9254bc4e100e0bc", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef vector_valued_monomial_basis_fn(nu, i, n):\n    \"\"\"\n    Generate a vector valued monomial basis polynomial :math:`p_{\\\\nu, i}` in the space\n    :math:`\\\\mathcal{P}_r(\\\\mathbb{R}^m, \\\\mathbb{R}^n)`, where :math:`r = |\\\\nu|` and m is equal to the length of nu.\n\n    The vector valued basis polynomial is generated by specifying a scalar valued basis polynomial and the component\n    of the vector valued basis polynomial that should be equal to the scalar valued basis polynomial. All other\n    components of the vector valued basis polynomial will be zero, i.e.\n\n    .. math:: p_{\\\\nu, i}^j (x) = \\\\begin{cases} p_{\\\\nu} (x), & i = j \\\\\\\\ 0, & \\\\text{else} \\\\end{cases}.\n\n    :param nu: Multi-index indicating which scalar valued monomial basis polynomial should be generated for the\n        non-zero component.\n    :type nu: int or :class:`~polynomials_on_simplices.algebra.multiindex.MultiIndex` or Tuple[int, ...]\n    :param int i: Index of the vector component that is non-zero.\n    :param int n: Dimension of the target.\n    :return: The monomial base polynomial as specified by nu, r, i and n.\n    :rtype: :class:`Polynomial`.\n\n    .. rubric:: Examples\n\n    >>> import sympy as sp\n    >>> x1, x2 = sp.symbols('x1 x2')\n    >>> vector_valued_monomial_basis_fn(0, 0, 2)(x1)\n    array([1, 0])\n    >>> vector_valued_monomial_basis_fn(1, 1, 2)(x1)\n    array([0, x1], dtype=object)\n    >>> vector_valued_monomial_basis_fn((1, 0), 0, 2)((x1, x2))\n    array([x1, 0], dtype=object)\n    >>> vector_valued_monomial_basis_fn((1, 1), 1, 3)((x1, x2))\n    array([0, x1*x2, 0], dtype=object)\n    \"\"\"\n    if n == 1:\n        assert i == 0\n        return monomial_basis_fn(nu)\n    assert i >= 0\n    assert i < n\n    try:\n        m = len(nu)\n    except TypeError:\n        m = 1\n    if not isinstance(nu, multiindex.MultiIndex):\n        nu = multiindex.MultiIndex(nu)\n    r = multiindex.norm(nu)\n    dim = get_dimension(r, m)\n    coeff = np.zeros((dim, n), dtype=int)\n    j = multiindex.get_index(nu, r)\n    coeff[j][i] = 1\n    return Polynomial(coeff, r, m)", "fn_id": 3, "class_fn": false, "repo": "FAndersson/polynomials_on_simplices", "file": "polynomials_on_simplices/polynomial/polynomials_monomial_basis.py", "last_update_at": "2021-03-17T11:41:21+00:00", "original_content": "def vector_valued_monomial_basis_fn(nu, i, n):\n    \"\"\"\n    Generate a vector valued monomial basis polynomial :math:`p_{\\\\nu, i}` in the space\n    :math:`\\\\mathcal{P}_r(\\\\mathbb{R}^m, \\\\mathbb{R}^n)`, where :math:`r = |\\\\nu|` and m is equal to the length of nu.\n\n    The vector valued basis polynomial is generated by specifying a scalar valued basis polynomial and the component\n    of the vector valued basis polynomial that should be equal to the scalar valued basis polynomial. All other\n    components of the vector valued basis polynomial will be zero, i.e.\n\n    .. math:: p_{\\\\nu, i}^j (x) = \\\\begin{cases} p_{\\\\nu} (x), & i = j \\\\\\\\ 0, & \\\\text{else} \\\\end{cases}.\n\n    :param nu: Multi-index indicating which scalar valued monomial basis polynomial should be generated for the\n        non-zero component.\n    :type nu: int or :class:`~polynomials_on_simplices.algebra.multiindex.MultiIndex` or Tuple[int, ...]\n    :param int i: Index of the vector component that is non-zero.\n    :param int n: Dimension of the target.\n    :return: The monomial base polynomial as specified by nu, r, i and n.\n    :rtype: :class:`Polynomial`.\n\n    .. rubric:: Examples\n\n    >>> import sympy as sp\n    >>> x1, x2 = sp.symbols('x1 x2')\n    >>> vector_valued_monomial_basis_fn(0, 0, 2)(x1)\n    array([1, 0])\n    >>> vector_valued_monomial_basis_fn(1, 1, 2)(x1)\n    array([0, x1], dtype=object)\n    >>> vector_valued_monomial_basis_fn((1, 0), 0, 2)((x1, x2))\n    array([x1, 0], dtype=object)\n    >>> vector_valued_monomial_basis_fn((1, 1), 1, 3)((x1, x2))\n    array([0, x1*x2, 0], dtype=object)\n    \"\"\"\n    if n == 1:\n        assert i == 0\n        return monomial_basis_fn(nu)\n    assert i >= 0\n    assert i < n\n    try:\n        m = len(nu)\n    except TypeError:\n        m = 1\n    if not isinstance(nu, multiindex.MultiIndex):\n        nu = multiindex.MultiIndex(nu)\n    r = multiindex.norm(nu)\n    dim = get_dimension(r, m)\n    coeff = np.zeros((dim, n), dtype=int)\n    j = multiindex.get_index(nu, r)\n    coeff[j][i] = 1\n    return Polynomial(coeff, r, m)", "refactored": true, "pred": {"ppl": 2.5977556705474854, "ppl_lower": 3.0846357345581055, "ppl/lowercase_ppl": -1.1799466704925547, "ppl/zlib": 0.0011446617129700957, "Min_5.0% Prob": 7.877215732227672, "Min_10.0% Prob": 6.035699537306121, "Min_20.0% Prob": 4.132219132624175, "Min_30.0% Prob": 3.0560760402679445, "Min_40.0% Prob": 2.36657767980063, "Min_50.0% Prob": 1.9063397926573982, "Min_60.0% Prob": 1.5938106563314796}}
{"hexsha": "6bd2ed2c7bff37b5c4b35bd8f9b870bb8d243202", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef main(argv=None):\n    \"\"\"Main entrance into app.  Setup logging, create App, and enter main loop\n    \"\"\"\n    global DEBUG\n    args = process_command_line(argv)\n    if args.debug:\n        DEBUG = True\n        log_level = logging.DEBUG\n    else:\n        log_level = logging.INFO\n    if another_instance_running(args.srcfiles):\n        print('Another instance of Marcam is already running.  Exiting.')\n        return 1\n    if (const.USER_CONFIG_DIR / 'debug').exists():\n        DEBUG = True\n        log_level = logging.DEBUG\n    logging_setup(log_level)\n    sys.stderr = marcam_extra.StderrToLog()\n    log_debug_main()\n    LOGGER.info(repr(args))\n    sanity_checks()\n    myapp = MarcamApp(args.srcfiles)\n    myapp.MainLoop()\n    return 0", "fn_id": 7, "class_fn": false, "repo": "itsayellow/marcam", "file": "marcam/marcam.py", "last_update_at": "2021-10-05T10:22:16+00:00", "original_content": "def main(argv=None):\n    \"\"\"Main entrance into app.  Setup logging, create App, and enter main loop\n    \"\"\"\n    global DEBUG\n    args = process_command_line(argv)\n    if args.debug:\n        DEBUG = True\n        log_level = logging.DEBUG\n    else:\n        log_level = logging.INFO\n    if another_instance_running(args.srcfiles):\n        print('Another instance of Marcam is already running.  Exiting.')\n        return 1\n    if (const.USER_CONFIG_DIR / 'debug').exists():\n        DEBUG = True\n        log_level = logging.DEBUG\n    logging_setup(log_level)\n    sys.stderr = marcam_extra.StderrToLog()\n    log_debug_main()\n    LOGGER.info(repr(args))\n    sanity_checks()\n    myapp = MarcamApp(args.srcfiles)\n    myapp.MainLoop()\n    return 0", "refactored": true, "pred": {"ppl": 7.141081809997559, "ppl_lower": 8.611993789672852, "ppl/lowercase_ppl": -1.095271876858195, "ppl/zlib": 0.004866000690296202, "Min_5.0% Prob": 12.364775657653809, "Min_10.0% Prob": 10.162849471682595, "Min_20.0% Prob": 7.739573648997715, "Min_30.0% Prob": 6.002716616978721, "Min_40.0% Prob": 4.790095551382928, "Min_50.0% Prob": 3.8992044387828737, "Min_60.0% Prob": 3.2655789985188415}}
{"hexsha": "3ee5df8aa3ce8621360bf2c27434ac72151c3d37", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef context_geo(key, values, dataset, namecount):\n    geoname = '\"' + key + '\"'\n    spar2 = '\\n    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\\n    PREFIX gndo: <http://d-nb.info/standards/elementset/gnd#>\\n    PREFIX pro: <http://purl.org/hpi/patchr#>\\n    PREFIX owl: <http://www.w3.org/2002/07/owl#>\\n    PREFIX edm: <http://www.europeana.eu/schemas/edm/>\\n    PREFIX dc: <http://purl.org/dc/elements/1.1/>\\n    PREFIX foaf: <http://xmlns.com/foaf/0.1/>\\n    PREFIX skos: <http://www.w3.org/2004/02/skos/core#>\\n    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\\n    PREFIX dblp: <http://dblp.org/rdf/schema-2015-01-26#>\\n    PREFIX dcterms: <http://purl.org/dc/terms/>\\n    PREFIX bibtex: <http://data.bibbase.org/ontology/#>\\n    PREFIX geo: <http://www.opengis.net/ont/geosparql#>\\n\\n        select ?x  (group_concat(?alt; SEPARATOR=\", \") as ?altname) (group_concat(?sameas; SEPARATOR=\", \") as ?same)\\n\\n        WHERE{{\\n\\n          graph <http://maral.wisslab.org/graphs/gnd> {{\\n\\n\\n            \\t?x (gndo:preferredNameForThePlaceOrGeographicName | gndo:variantNameForThePlaceOrGeographicName){0}.\\n                optional {{?x gndo:variantNameForThePlaceOrGeographicName ?alt.}}\\n                optional {{?x owl:sameAs ?sameas.}}\\n               # ?x geo:hasGeometry ?geo.\\n               # optional {{?geo geo:asWKT ?coo}}\\n          }}\\n          }} group by ?x\\n\\n        '.format(geoname)\n    sparql.setQuery(spar2)\n    sparql.setReturnFormat(XML)\n    results = sparql.query().convert()\n    for i in range(0, len(results.bindings)):\n        uri = 'https://data.jhn.ngo/spatial/' + str(dataset) + '/' + str(namecount)\n        graph.add((URIRef(uri), RDF.type, edm.Place))\n        for z in range(0, len(values)):\n            graph.add((URIRef(uri), edm.identifier, Literal(values[z])))\n        graph.add((URIRef(uri), skos.prefLabel, Literal(key)))\n        if 'altname' in results.bindings[i].keys():\n            count1 = results.bindings[i]['altname'].value.count(',')\n            if count1 > 0:\n                for j in range(0, count1 + 1):\n                    graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value.rsplit(', ', count1)[count1 - j])))\n            else:\n                graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value)))\n        if 'same' in results.bindings[i].keys():\n            count2 = results.bindings[i]['same'].value.count(',')\n            if count2 > 0:\n                for j in range(0, count2 + 1):\n                    graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value.rsplit(', ', count2)[count2 - j])))\n            else:\n                graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value)))\n    graph.serialize(destination=dataset + '_Spatial_01.ttl', format='turtle')", "fn_id": 1, "class_fn": false, "repo": "ubffm/judaica-europeana-2-0", "file": "scripts/contextualize_output_spatial_01.py", "last_update_at": "2021-03-17T08:38:58+00:00", "original_content": "def context_geo(key, values, dataset, namecount):\n    geoname = '\"' + key + '\"'\n    spar2 = '\\n    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\\n    PREFIX gndo: <http://d-nb.info/standards/elementset/gnd#>\\n    PREFIX pro: <http://purl.org/hpi/patchr#>\\n    PREFIX owl: <http://www.w3.org/2002/07/owl#>\\n    PREFIX edm: <http://www.europeana.eu/schemas/edm/>\\n    PREFIX dc: <http://purl.org/dc/elements/1.1/>\\n    PREFIX foaf: <http://xmlns.com/foaf/0.1/>\\n    PREFIX skos: <http://www.w3.org/2004/02/skos/core#>\\n    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\\n    PREFIX dblp: <http://dblp.org/rdf/schema-2015-01-26#>\\n    PREFIX dcterms: <http://purl.org/dc/terms/>\\n    PREFIX bibtex: <http://data.bibbase.org/ontology/#>\\n    PREFIX geo: <http://www.opengis.net/ont/geosparql#>\\n\\n        select ?x  (group_concat(?alt; SEPARATOR=\", \") as ?altname) (group_concat(?sameas; SEPARATOR=\", \") as ?same)\\n\\n        WHERE{{\\n\\n          graph <http://maral.wisslab.org/graphs/gnd> {{\\n\\n\\n            \\t?x (gndo:preferredNameForThePlaceOrGeographicName | gndo:variantNameForThePlaceOrGeographicName){0}.\\n                optional {{?x gndo:variantNameForThePlaceOrGeographicName ?alt.}}\\n                optional {{?x owl:sameAs ?sameas.}}\\n               # ?x geo:hasGeometry ?geo.\\n               # optional {{?geo geo:asWKT ?coo}}\\n          }}\\n          }} group by ?x\\n\\n        '.format(geoname)\n    sparql.setQuery(spar2)\n    sparql.setReturnFormat(XML)\n    results = sparql.query().convert()\n    for i in range(0, len(results.bindings)):\n        uri = 'https://data.jhn.ngo/spatial/' + str(dataset) + '/' + str(namecount)\n        graph.add((URIRef(uri), RDF.type, edm.Place))\n        for z in range(0, len(values)):\n            graph.add((URIRef(uri), edm.identifier, Literal(values[z])))\n        graph.add((URIRef(uri), skos.prefLabel, Literal(key)))\n        if 'altname' in results.bindings[i].keys():\n            count1 = results.bindings[i]['altname'].value.count(',')\n            if count1 > 0:\n                for j in range(0, count1 + 1):\n                    graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value.rsplit(', ', count1)[count1 - j])))\n            else:\n                graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value)))\n        if 'same' in results.bindings[i].keys():\n            count2 = results.bindings[i]['same'].value.count(',')\n            if count2 > 0:\n                for j in range(0, count2 + 1):\n                    graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value.rsplit(', ', count2)[count2 - j])))\n            else:\n                graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value)))\n    graph.serialize(destination=dataset + '_Spatial_01.ttl', format='turtle')", "refactored": true, "pred": {"ppl": 1.9272326231002808, "ppl_lower": 2.1450438499450684, "ppl/lowercase_ppl": -1.1632027539700753, "ppl/zlib": 0.0006432206861709496, "Min_5.0% Prob": 7.323383162419002, "Min_10.0% Prob": 5.328409401079019, "Min_20.0% Prob": 3.193951280777936, "Min_30.0% Prob": 2.1784563650858813, "Min_40.0% Prob": 1.6426984179859083, "Min_50.0% Prob": 1.3133978705456013, "Min_60.0% Prob": 1.0938320017337964}}
{"hexsha": "00500ee126bf98712c024187bb2a8536d5e82f46", "ext": "py", "lang": "Python", "content": "@login_required\n@timeing\n@measure_memory_usage\ndef productlist(request):\n    organization = request.user.info.organization\n    if not hasattr(request.user, 'organization'):\n        if not hasattr(request.user, 'permissions'):\n            return HttpResponseForbidden('<h1>403 Forbidden</h1>')\n        if request.user.permissions.product_permissions < 1:\n            return HttpResponseForbidden('<h1>403 Forbidden</h1>')\n    products = Product.objects.filter(organization=organization).order_by('-id').annotate(earmarked=Sum('salesinvoiceentry__quantity', filter=Q(salesinvoiceentry__invoice__finalized=0)))\n    productfilter = ProductFilter(request.GET, queryset=products)\n    paginator = Paginator(productfilter.qs, 25)\n    page_number = request.GET.get('page')\n    page_obj = paginator.get_page(page_number)\n    context = {'page_obj': page_obj, 'filter': productfilter}\n    return render(request, 'products/product_list.html', context=context)", "fn_id": 0, "class_fn": false, "repo": "drtweety/busman", "file": "products/views.py", "last_update_at": "2021-06-13T18:12:21+00:00", "original_content": "@login_required\ndef productlist(request):\n    organization = request.user.info.organization\n    if not hasattr(request.user, 'organization'):\n        if not hasattr(request.user, 'permissions'):\n            return HttpResponseForbidden('<h1>403 Forbidden</h1>')\n        if request.user.permissions.product_permissions < 1:\n            return HttpResponseForbidden('<h1>403 Forbidden</h1>')\n    products = Product.objects.filter(organization=organization).order_by('-id').annotate(earmarked=Sum('salesinvoiceentry__quantity', filter=Q(salesinvoiceentry__invoice__finalized=0)))\n    productfilter = ProductFilter(request.GET, queryset=products)\n    paginator = Paginator(productfilter.qs, 25)\n    page_number = request.GET.get('page')\n    page_obj = paginator.get_page(page_number)\n    context = {'page_obj': page_obj, 'filter': productfilter}\n    return render(request, 'products/product_list.html', context=context)", "refactored": true, "pred": {"ppl": 3.1155002117156982, "ppl_lower": 4.663239002227783, "ppl/lowercase_ppl": -1.354913937667384, "ppl/zlib": 0.002718635696071162, "Min_5.0% Prob": 9.834420363108316, "Min_10.0% Prob": 8.046155989170074, "Min_20.0% Prob": 5.180059201863347, "Min_30.0% Prob": 3.735355747712625, "Min_40.0% Prob": 2.8330145227638157, "Min_50.0% Prob": 2.2700510573152815, "Min_60.0% Prob": 1.9036544552009955}}
{"hexsha": "04feed9797eeb64fb97ec419811711f467958210", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_marks(cos_scores, max_marks, bias):\n    max_cos_score = max(cos_scores)\n    marks_obtained = max([(max_cos_score - bias[0]) / (1 - bias[0]) * max_marks if max_cos_score < bias[1] else max_marks, 0])\n    return marks_obtained", "fn_id": 1, "class_fn": false, "repo": "iamyajat/auto-grader", "file": "autograder/text_similarity.py", "last_update_at": "2021-12-24T13:03:22+00:00", "original_content": "def get_marks(cos_scores, max_marks, bias):\n    max_cos_score = max(cos_scores)\n    marks_obtained = max([(max_cos_score - bias[0]) / (1 - bias[0]) * max_marks if max_cos_score < bias[1] else max_marks, 0])\n    return marks_obtained", "refactored": true, "pred": {"ppl": 5.414255619049072, "ppl_lower": 5.414255619049072, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.011260236030204268, "Min_5.0% Prob": 10.88017725944519, "Min_10.0% Prob": 8.763372421264648, "Min_20.0% Prob": 6.831184334225124, "Min_30.0% Prob": 5.390271164752819, "Min_40.0% Prob": 4.153268454848109, "Min_50.0% Prob": 3.3952613298011864, "Min_60.0% Prob": 2.8518343578008087}}
{"hexsha": "6e4206da9fd80226e539745dda7d6ae8f2010e3a", "ext": "py", "lang": "Python", "content": "@card('Pacifism')\ndef pacifism(card, abilities):\n\n    def pacifism():\n        return AbilityNotImplemented\n\n    @timeing\n    @measure_memory_usage\n    def pacifism():\n        return AbilityNotImplemented\n    return (pacifism, pacifism)", "fn_id": 150, "class_fn": false, "repo": "Julian/cardboard", "file": "cardboard/cards/sets/mirage.py", "last_update_at": "2021-05-29T06:00:40+00:00", "original_content": "@card('Pacifism')\ndef pacifism(card, abilities):\n\n    def pacifism():\n        return AbilityNotImplemented\n\n    def pacifism():\n        return AbilityNotImplemented\n    return (pacifism, pacifism)", "refactored": true, "pred": {"ppl": 7.5741753578186035, "ppl_lower": 13.557201385498047, "ppl/lowercase_ppl": -1.2875293140072424, "ppl/zlib": 0.015942869935551537, "Min_5.0% Prob": 12.672956466674805, "Min_10.0% Prob": 11.168851852416992, "Min_20.0% Prob": 8.78140605579723, "Min_30.0% Prob": 6.602982654291041, "Min_40.0% Prob": 5.047366157821987, "Min_50.0% Prob": 4.036976535772455, "Min_60.0% Prob": 3.4508505907347975}}
{"hexsha": "58f3964892634b3c801b485b006283a9cc644941", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_vertex_merger_vertices():\n    merger = MeshVertexMerger()\n    merger.add_vertices([(1, 2, 3), (4, 5, 6)])\n    merger.add_vertices([(1, 2, 3), (4, 5, 6)])\n    assert merger.vertices == [(1, 2, 3), (4, 5, 6)]", "fn_id": 1, "class_fn": false, "repo": "jpsantos-mf/ezdxf", "file": "tests/test_07_render/test_703_render_mesh.py", "last_update_at": "2021-06-05T09:15:15+00:00", "original_content": "def test_vertex_merger_vertices():\n    merger = MeshVertexMerger()\n    merger.add_vertices([(1, 2, 3), (4, 5, 6)])\n    merger.add_vertices([(1, 2, 3), (4, 5, 6)])\n    assert merger.vertices == [(1, 2, 3), (4, 5, 6)]", "refactored": true, "pred": {"ppl": 2.512615442276001, "ppl_lower": 2.9796743392944336, "ppl/lowercase_ppl": -1.1850486390308865, "ppl/zlib": 0.006824623848179131, "Min_5.0% Prob": 8.50110740661621, "Min_10.0% Prob": 6.580274176597595, "Min_20.0% Prob": 4.340515458583832, "Min_30.0% Prob": 3.023350364738895, "Min_40.0% Prob": 2.3183070948211157, "Min_50.0% Prob": 1.8390723004793892, "Min_60.0% Prob": 1.5451662584222974}}
{"hexsha": "40c216bc802b50376ba5e2720ccd9e0872685eb7", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef parse_args():\n    global args\n    parser = argparse.ArgumentParser(description='Reset RFID Reader')\n    parser.add_argument('host', help='hostname or IP address of RFID reader', nargs='+')\n    parser.add_argument('-p', '--port', default=llrp.LLRP_PORT, help='port to connect to (default {})'.format(llrp.LLRP_PORT))\n    parser.add_argument('-d', '--debug', action='store_true', help='show debugging output')\n    args = parser.parse_args()", "fn_id": 0, "class_fn": false, "repo": "amjadmajid/stork", "file": "Host_software/sllurp/reset.py", "last_update_at": "2021-11-21T08:23:03+00:00", "original_content": "def parse_args():\n    global args\n    parser = argparse.ArgumentParser(description='Reset RFID Reader')\n    parser.add_argument('host', help='hostname or IP address of RFID reader', nargs='+')\n    parser.add_argument('-p', '--port', default=llrp.LLRP_PORT, help='port to connect to (default {})'.format(llrp.LLRP_PORT))\n    parser.add_argument('-d', '--debug', action='store_true', help='show debugging output')\n    args = parser.parse_args()", "refactored": true, "pred": {"ppl": 2.831366539001465, "ppl_lower": 3.5910468101501465, "ppl/lowercase_ppl": -1.2283758025665277, "ppl/zlib": 0.0038689943162836804, "Min_5.0% Prob": 9.5056312084198, "Min_10.0% Prob": 6.901196571496817, "Min_20.0% Prob": 4.6619307077848, "Min_30.0% Prob": 3.36807141548548, "Min_40.0% Prob": 2.57783743710472, "Min_50.0% Prob": 2.075257142346639, "Min_60.0% Prob": 1.7334368027364597}}
{"hexsha": "81170dea07b0b06f634847b4f0645d72a042dbbb", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_laser_timing_delay(lxt):\n    \"\"\"\n    Check basic moves are getting to the fs_tgt_time signal.\n\n    That signal's value is off by 10e9 for the ns to s conversion\n    and negative due to the convention that positive lxt means earlier laser.\n    \"\"\"\n    logger.debug('test_laser_timing_delay')\n    assert lxt.wm() == 0\n    assert lxt._fs_tgt_time.get() == -0\n    lxt.mv(1e-06)\n    assert lxt.wm() == 1e-06\n    assert lxt._fs_tgt_time.get() == pytest.approx(-1000)\n    lxt.mv(-5e-06)\n    assert lxt.wm() == -5e-06\n    assert lxt._fs_tgt_time.get() == pytest.approx(5000)", "fn_id": 7, "class_fn": false, "repo": "cristinasewell/pcdsdevices", "file": "tests/test_lxe.py", "last_update_at": "2021-06-15T14:09:42+00:00", "original_content": "def test_laser_timing_delay(lxt):\n    \"\"\"\n    Check basic moves are getting to the fs_tgt_time signal.\n\n    That signal's value is off by 10e9 for the ns to s conversion\n    and negative due to the convention that positive lxt means earlier laser.\n    \"\"\"\n    logger.debug('test_laser_timing_delay')\n    assert lxt.wm() == 0\n    assert lxt._fs_tgt_time.get() == -0\n    lxt.mv(1e-06)\n    assert lxt.wm() == 1e-06\n    assert lxt._fs_tgt_time.get() == pytest.approx(-1000)\n    lxt.mv(-5e-06)\n    assert lxt.wm() == -5e-06\n    assert lxt._fs_tgt_time.get() == pytest.approx(5000)", "refactored": true, "pred": {"ppl": 5.837337493896484, "ppl_lower": 5.9831624031066895, "ppl/lowercase_ppl": -1.0139856183678946, "ppl/zlib": 0.006104757039110215, "Min_5.0% Prob": 11.258835792541504, "Min_10.0% Prob": 9.379589693886894, "Min_20.0% Prob": 6.965794103486197, "Min_30.0% Prob": 5.383059460669756, "Min_40.0% Prob": 4.323078717904933, "Min_50.0% Prob": 3.502955553826885, "Min_60.0% Prob": 2.9459313707775436}}
{"hexsha": "10296073b3cc74d61d9da67e57a17da208e30b41", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef corrSpin2(ra, dec, g1a, g2a, g1b=None, g2b=None, raUnits='degrees', decUnits='degrees', **treecorrKwargs):\n    \"\"\"Function to compute correlations between at most two shear-like fields.\n    This is used to compute Rho statistics, given the appropriate spin-2\n    (shear-like) fields.\n    Parameters\n    ----------\n    ra : `numpy.array`\n        The right ascension values of entries in the catalog.\n    dec : `numpy.array`\n        The declination values of entries in the catalog.\n    g1a : `numpy.array`\n        The first component of the primary shear-like field.\n    g2a : `numpy.array`\n        The second component of the primary shear-like field.\n    g1b : `numpy.array`, optional\n        The first component of the secondary shear-like field.\n        Autocorrelation of the primary field is computed if `None` (default).\n    g2b : `numpy.array`, optional\n        The second component of the secondary shear-like field.\n        Autocorrelation of the primary field is computed if `None` (default).\n    raUnits : `str`, optional\n        Unit of the right ascension values.\n        Valid options are \"degrees\", \"arcmin\", \"arcsec\", \"hours\" or \"radians\".\n    decUnits : `str`, optional\n        Unit of the declination values.\n        Valid options are \"degrees\", \"arcmin\", \"arcsec\", \"hours\" or \"radians\".\n    **treecorrKwargs\n        Keyword arguments to be passed to `treecorr.GGCorrelation`.\n    Returns\n    -------\n    xy : `treecorr.GGCorrelation`\n        A `treecorr.GGCorrelation` object containing the correlation function.\n    \"\"\"\n    xy = treecorr.GGCorrelation(**treecorrKwargs)\n    catA = treecorr.Catalog(ra=ra, dec=dec, g1=g1a, g2=g2a, ra_units=raUnits, dec_units=decUnits)\n    if g1b is None or g2b is None:\n        xy.process(catA)\n    else:\n        catB = treecorr.Catalog(ra=ra, dec=dec, g1=g1b, g2=g2b, ra_units=raUnits, dec_units=decUnits)\n        xy.process(catA, catB)\n    return xy", "fn_id": 1, "class_fn": false, "repo": "lsst-dmsst/metric-pipeline-tasks", "file": "python/lsst/faro/utils/tex.py", "last_update_at": "2021-02-23T16:05:17+00:00", "original_content": "def corrSpin2(ra, dec, g1a, g2a, g1b=None, g2b=None, raUnits='degrees', decUnits='degrees', **treecorrKwargs):\n    \"\"\"Function to compute correlations between at most two shear-like fields.\n    This is used to compute Rho statistics, given the appropriate spin-2\n    (shear-like) fields.\n    Parameters\n    ----------\n    ra : `numpy.array`\n        The right ascension values of entries in the catalog.\n    dec : `numpy.array`\n        The declination values of entries in the catalog.\n    g1a : `numpy.array`\n        The first component of the primary shear-like field.\n    g2a : `numpy.array`\n        The second component of the primary shear-like field.\n    g1b : `numpy.array`, optional\n        The first component of the secondary shear-like field.\n        Autocorrelation of the primary field is computed if `None` (default).\n    g2b : `numpy.array`, optional\n        The second component of the secondary shear-like field.\n        Autocorrelation of the primary field is computed if `None` (default).\n    raUnits : `str`, optional\n        Unit of the right ascension values.\n        Valid options are \"degrees\", \"arcmin\", \"arcsec\", \"hours\" or \"radians\".\n    decUnits : `str`, optional\n        Unit of the declination values.\n        Valid options are \"degrees\", \"arcmin\", \"arcsec\", \"hours\" or \"radians\".\n    **treecorrKwargs\n        Keyword arguments to be passed to `treecorr.GGCorrelation`.\n    Returns\n    -------\n    xy : `treecorr.GGCorrelation`\n        A `treecorr.GGCorrelation` object containing the correlation function.\n    \"\"\"\n    xy = treecorr.GGCorrelation(**treecorrKwargs)\n    catA = treecorr.Catalog(ra=ra, dec=dec, g1=g1a, g2=g2a, ra_units=raUnits, dec_units=decUnits)\n    if g1b is None or g2b is None:\n        xy.process(catA)\n    else:\n        catB = treecorr.Catalog(ra=ra, dec=dec, g1=g1b, g2=g2b, ra_units=raUnits, dec_units=decUnits)\n        xy.process(catA, catB)\n    return xy", "refactored": true, "pred": {"ppl": 2.0328664779663086, "ppl_lower": 2.2925310134887695, "ppl/lowercase_ppl": -1.1694413010295652, "ppl/zlib": 0.001115482476648797, "Min_5.0% Prob": 8.264738400777182, "Min_10.0% Prob": 5.747324059226296, "Min_20.0% Prob": 3.4349813437139667, "Min_30.0% Prob": 2.3617717137861396, "Min_40.0% Prob": 1.7773044630383965, "Min_50.0% Prob": 1.4212958717887294, "Min_60.0% Prob": 1.1837917876216137}}
{"hexsha": "7cfa76a0e321448c9b715a43fe2ae910c799972c", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef make_summary_file(filename):\n    \"\"\"\n    Given a DLIS file, make a short human readable summary of it.\n    Show things like headers, well parameters and which well curves are\n    available.\n\n    Args:\n    filename: A DLIS file.\n\n    Returns:\n    summaryfile: The DLIS file without the extention and the suffix\n    _summary.txt.\n    \"\"\"\n    summaryfile = open(filename.replace('.DLIS', '_summary.txt'), 'w')\n    f, *f_tail = dlis.load(filename)\n    if len(f_tail):\n        print('There are more logical files in tail')\n    origin, *origin_tail = f.origins\n    if len(origin_tail):\n        print(filename + ' contains multiple origins')\n    header = f.fileheader\n    parameter_table = summarize(f.parameters, name='Name', long_name='Long name', values='Value(s)')\n    mask = ~parameter_table['Name'].isin(['R8', 'RR1', 'WITN', 'ENGI'])\n    parameter_table = parameter_table[mask]\n    parameter_table.sort_values('Name')\n    summaryfile.write(str(f.describe()))\n    summaryfile.write(str(origin.describe()))\n    summaryfile.write(str(header.describe()))\n    summaryfile.write(str(parameter_table))\n    for frame in f.frames:\n        index_channel = next((ch for ch in frame.channels if ch.name == frame.index))\n        summaryfile.write(f'\\nFrame {frame.name}:\\n')\n        summaryfile.write(f'Description      : {frame.description}\\n')\n        summaryfile.write(f'Indexed by       : {frame.index_type}\\n')\n        summaryfile.write(f'Interval         : [{frame.index_min}, {frame.index_max}] {index_channel.units}\\n')\n        summaryfile.write(f'Direction        : {frame.direction}\\n')\n        summaryfile.write(f'Constant spacing : {frame.spacing} {index_channel.units}\\n')\n        summaryfile.write(f'Index channel    : {index_channel}\\n')\n        summaryfile.write(f'No. of channels  : {len(frame.channels)}\\n')\n    channel_table = summarize(f.channels, name='Name', long_name='Long name', units='Units', dimension='Dimension', frame='Frame')\n    channel_table.sort_values('Name')\n    summaryfile.write(str(channel_table))\n    summaryfile.close()\n    return summaryfile", "fn_id": 1, "class_fn": false, "repo": "softwareunderground/northern-lights", "file": "scripts/dlis_summary.py", "last_update_at": "2021-04-17T09:13:20+00:00", "original_content": "def make_summary_file(filename):\n    \"\"\"\n    Given a DLIS file, make a short human readable summary of it.\n    Show things like headers, well parameters and which well curves are\n    available.\n\n    Args:\n    filename: A DLIS file.\n\n    Returns:\n    summaryfile: The DLIS file without the extention and the suffix\n    _summary.txt.\n    \"\"\"\n    summaryfile = open(filename.replace('.DLIS', '_summary.txt'), 'w')\n    f, *f_tail = dlis.load(filename)\n    if len(f_tail):\n        print('There are more logical files in tail')\n    origin, *origin_tail = f.origins\n    if len(origin_tail):\n        print(filename + ' contains multiple origins')\n    header = f.fileheader\n    parameter_table = summarize(f.parameters, name='Name', long_name='Long name', values='Value(s)')\n    mask = ~parameter_table['Name'].isin(['R8', 'RR1', 'WITN', 'ENGI'])\n    parameter_table = parameter_table[mask]\n    parameter_table.sort_values('Name')\n    summaryfile.write(str(f.describe()))\n    summaryfile.write(str(origin.describe()))\n    summaryfile.write(str(header.describe()))\n    summaryfile.write(str(parameter_table))\n    for frame in f.frames:\n        index_channel = next((ch for ch in frame.channels if ch.name == frame.index))\n        summaryfile.write(f'\\nFrame {frame.name}:\\n')\n        summaryfile.write(f'Description      : {frame.description}\\n')\n        summaryfile.write(f'Indexed by       : {frame.index_type}\\n')\n        summaryfile.write(f'Interval         : [{frame.index_min}, {frame.index_max}] {index_channel.units}\\n')\n        summaryfile.write(f'Direction        : {frame.direction}\\n')\n        summaryfile.write(f'Constant spacing : {frame.spacing} {index_channel.units}\\n')\n        summaryfile.write(f'Index channel    : {index_channel}\\n')\n        summaryfile.write(f'No. of channels  : {len(frame.channels)}\\n')\n    channel_table = summarize(f.channels, name='Name', long_name='Long name', units='Units', dimension='Dimension', frame='Frame')\n    channel_table.sort_values('Name')\n    summaryfile.write(str(channel_table))\n    summaryfile.close()\n    return summaryfile", "refactored": true, "pred": {"ppl": 4.087120532989502, "ppl_lower": 4.275178909301758, "ppl/lowercase_ppl": -1.03195337073548, "ppl/zlib": 0.0018236278444921964, "Min_5.0% Prob": 10.000617356135928, "Min_10.0% Prob": 8.289531625550369, "Min_20.0% Prob": 6.0951693859593625, "Min_30.0% Prob": 4.509178176693533, "Min_40.0% Prob": 3.485626498108794, "Min_50.0% Prob": 2.805725636376753, "Min_60.0% Prob": 2.3456644363658645}}
{"hexsha": "4be3288dc749ae714f5530e0b9af4e86fbcb9c14", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef set_crs(df: GDF, epsg_code: Union[int, str]) -> GDF:\n    \"\"\"Sets dataframe crs in geopandas pipeline.\n\n    TODO: Deprecate with next rasterio version that will integrate set_crs method.\n    \"\"\"\n    df.crs = {'init': f'epsg:{str(epsg_code)}'}\n    return df", "fn_id": 2, "class_fn": false, "repo": "ZakariaELHAJOUY/Remote-sensing-", "file": "utils/geo.py", "last_update_at": "2021-07-12T06:28:31+00:00", "original_content": "def set_crs(df: GDF, epsg_code: Union[int, str]) -> GDF:\n    \"\"\"Sets dataframe crs in geopandas pipeline.\n\n    TODO: Deprecate with next rasterio version that will integrate set_crs method.\n    \"\"\"\n    df.crs = {'init': f'epsg:{str(epsg_code)}'}\n    return df", "refactored": true, "pred": {"ppl": 7.526429176330566, "ppl_lower": 9.552223205566406, "ppl/lowercase_ppl": -1.1180889620755854, "ppl/zlib": 0.009301477955606284, "Min_5.0% Prob": 12.189992666244507, "Min_10.0% Prob": 9.609725952148438, "Min_20.0% Prob": 7.62615344259474, "Min_30.0% Prob": 6.131330472451669, "Min_40.0% Prob": 4.947181998027696, "Min_50.0% Prob": 4.052072256803513, "Min_60.0% Prob": 3.396174999643807}}
{"hexsha": "28241061cc6276467c762df6e87e9db4f4a59e1b", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef total_lights():\n    total_lights_on = 0\n    for y, _ in enumerate(lights):\n        for x, _ in enumerate(lights[y]):\n            if lights[y][x] == 1:\n                total_lights_on += 1\n    return total_lights_on", "fn_id": 6, "class_fn": false, "repo": "josephroquedev/advent-of-code", "file": "2015/day_18/python/day18.py", "last_update_at": "2021-11-30T10:05:29+00:00", "original_content": "def total_lights():\n    total_lights_on = 0\n    for y, _ in enumerate(lights):\n        for x, _ in enumerate(lights[y]):\n            if lights[y][x] == 1:\n                total_lights_on += 1\n    return total_lights_on", "refactored": true, "pred": {"ppl": 3.175283193588257, "ppl_lower": 3.175283193588257, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.008622364352223728, "Min_5.0% Prob": 9.0956818262736, "Min_10.0% Prob": 7.472194875989642, "Min_20.0% Prob": 5.463560853685651, "Min_30.0% Prob": 3.821522657166828, "Min_40.0% Prob": 2.9378170609988015, "Min_50.0% Prob": 2.3089465563865126, "Min_60.0% Prob": 1.9430109733207659}}
{"hexsha": "c85e03d56b4d6fc548188cd588d9ea2d6a3b23be", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef argopen(file, mode, encoding=None, errors=None):\n    closefd = True\n    if file == '-':\n        closefd = False\n        if 'r' in mode:\n            file = sys.stdin.fileno()\n        else:\n            file = sys.stdout.fileno()\n    return io.open(file, mode, encoding=encoding, errors=errors, closefd=closefd)", "fn_id": 0, "class_fn": false, "repo": "olivier-compilatio/uniseg-python", "file": "uniseg/samples/unibreak.py", "last_update_at": "2021-05-11T02:01:47+00:00", "original_content": "def argopen(file, mode, encoding=None, errors=None):\n    closefd = True\n    if file == '-':\n        closefd = False\n        if 'r' in mode:\n            file = sys.stdin.fileno()\n        else:\n            file = sys.stdout.fileno()\n    return io.open(file, mode, encoding=encoding, errors=errors, closefd=closefd)", "refactored": true, "pred": {"ppl": 2.7688798904418945, "ppl_lower": 3.308380126953125, "ppl/lowercase_ppl": -1.1747921469618117, "ppl/zlib": 0.005753914501340933, "Min_5.0% Prob": 10.591905355453491, "Min_10.0% Prob": 7.58787907494439, "Min_20.0% Prob": 4.69988771488792, "Min_30.0% Prob": 3.2920425184841813, "Min_40.0% Prob": 2.5782422356699644, "Min_50.0% Prob": 2.0554292438707003, "Min_60.0% Prob": 1.703032948438014}}
{"hexsha": "96a9ce1af1b9abc8e61b5491562c9ddee1c883c3", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef infer_replicates(target_labels_long):\n    \"\"\" Infer replicate experiments based on their long form labels.\n\n    In:\n        target_labels_long [str]: list of long form target labels\n    Out:\n        replicate_lists {exp_label -> [target indexes]}\n    \"\"\"\n    replicate_lists = {}\n    rep_re = []\n    rep_re.append(re.compile('rep\\\\d+'))\n    rep_re.append(re.compile('donor\\\\d+'))\n    for ti in range(len(target_labels_long)):\n        label = target_labels_long[ti]\n        for ri in range(len(rep_re)):\n            rep_m = rep_re[ri].search(label)\n            if rep_m:\n                rep_str = rep_m.group(0)\n                label = label.replace(rep_str, '')\n        replicate_lists.setdefault(label, []).append(ti)\n    return replicate_lists", "fn_id": 1, "class_fn": false, "repo": "JasperSnoek/basenji", "file": "bin/basenji_test_reps.py", "last_update_at": "2021-05-12T08:51:44+00:00", "original_content": "def infer_replicates(target_labels_long):\n    \"\"\" Infer replicate experiments based on their long form labels.\n\n    In:\n        target_labels_long [str]: list of long form target labels\n    Out:\n        replicate_lists {exp_label -> [target indexes]}\n    \"\"\"\n    replicate_lists = {}\n    rep_re = []\n    rep_re.append(re.compile('rep\\\\d+'))\n    rep_re.append(re.compile('donor\\\\d+'))\n    for ti in range(len(target_labels_long)):\n        label = target_labels_long[ti]\n        for ri in range(len(rep_re)):\n            rep_m = rep_re[ri].search(label)\n            if rep_m:\n                rep_str = rep_m.group(0)\n                label = label.replace(rep_str, '')\n        replicate_lists.setdefault(label, []).append(ti)\n    return replicate_lists", "refactored": true, "pred": {"ppl": 4.2300896644592285, "ppl_lower": 4.252078056335449, "ppl/lowercase_ppl": -1.0035948858673795, "ppl/zlib": 0.004204732332668259, "Min_5.0% Prob": 10.893129348754883, "Min_10.0% Prob": 8.76245896021525, "Min_20.0% Prob": 6.466132274893827, "Min_30.0% Prob": 4.739769515165916, "Min_40.0% Prob": 3.597890457202648, "Min_50.0% Prob": 2.8824073286778336, "Min_60.0% Prob": 2.4183322712922326}}
{"hexsha": "eb9320bc73ea082b4d99c1b4dbcaed9bf2e92e33", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef verify_flow_region_func(height: float, boundary_layer_height: float) -> FlowFieldRegion:\n    if height < boundary_layer_height:\n        return FlowFieldRegion.BOUNDARY_LAYER\n    else:\n        return FlowFieldRegion.FREE_FLOW", "fn_id": 0, "class_fn": false, "repo": "lucasralves/steady-flow-prediction", "file": "src/pre_processing/core/mesh/functions/verify_flow_region.py", "last_update_at": "2021-07-16T19:59:39+00:00", "original_content": "def verify_flow_region_func(height: float, boundary_layer_height: float) -> FlowFieldRegion:\n    if height < boundary_layer_height:\n        return FlowFieldRegion.BOUNDARY_LAYER\n    else:\n        return FlowFieldRegion.FREE_FLOW", "refactored": true, "pred": {"ppl": 6.405967712402344, "ppl_lower": 8.743277549743652, "ppl/lowercase_ppl": -1.1674833554613808, "ppl/zlib": 0.011535590130200803, "Min_5.0% Prob": 8.905384063720703, "Min_10.0% Prob": 8.336674372355143, "Min_20.0% Prob": 6.917436709770789, "Min_30.0% Prob": 5.7202138781547545, "Min_40.0% Prob": 4.520834821241873, "Min_50.0% Prob": 3.68972299335634, "Min_60.0% Prob": 3.1512447665445507}}
{"hexsha": "3f5030776c04f54c1b5b6703282b5954e3f6c54c", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef timeit(method):\n\n    def timed(*args, **kw):\n        ts = time.time()\n        result = method(*args, **kw)\n        te = time.time()\n        if 'log_time' in kw:\n            name = kw.get('log_name', method.__name__.upper())\n            kw['log_time'][name] = int((te - ts) * 1000)\n        else:\n            print('%r  %2.2f ms' % (method.__name__, (te - ts) * 1000))\n        return result\n    return timed", "fn_id": 0, "class_fn": false, "repo": "xiongjuncheng/futu_algo", "file": "strategies/Strategies.py", "last_update_at": "2021-06-09T01:16:13+00:00", "original_content": "def timeit(method):\n\n    def timed(*args, **kw):\n        ts = time.time()\n        result = method(*args, **kw)\n        te = time.time()\n        if 'log_time' in kw:\n            name = kw.get('log_name', method.__name__.upper())\n            kw['log_time'][name] = int((te - ts) * 1000)\n        else:\n            print('%r  %2.2f ms' % (method.__name__, (te - ts) * 1000))\n        return result\n    return timed", "refactored": true, "pred": {"ppl": 1.5786464214324951, "ppl_lower": 1.5786464214324951, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.002038249038258271, "Min_5.0% Prob": 6.004768530527751, "Min_10.0% Prob": 4.478991141686072, "Min_20.0% Prob": 2.3198470059368343, "Min_30.0% Prob": 1.535389651657968, "Min_40.0% Prob": 1.1453712179198523, "Min_50.0% Prob": 0.9130767945816447, "Min_60.0% Prob": 0.7683487086957562}}
{"hexsha": "89cf74e1d86ffce9e2a638d3306254d23a748771", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef infer_remote_zip_file_directory_name() -> List[str]:\n    from ..version import __version__\n    remote_zip_file_directory_name: List[str] = [__version__]\n    remote_zip_file_directory_name.append(f'python_{PYTHON_VERSION}')\n    if Env.ON_WINDOWS:\n        remote_zip_file_directory_name.append('windows')\n    else:\n        remote_zip_file_directory_name.append('linux')\n    return remote_zip_file_directory_name", "fn_id": 3, "class_fn": false, "repo": "Reefledge/reefledge", "file": "reefledge/remote_zip_file_path/__init__.py", "last_update_at": "2021-09-23T10:44:32+00:00", "original_content": "def infer_remote_zip_file_directory_name() -> List[str]:\n    from ..version import __version__\n    remote_zip_file_directory_name: List[str] = [__version__]\n    remote_zip_file_directory_name.append(f'python_{PYTHON_VERSION}')\n    if Env.ON_WINDOWS:\n        remote_zip_file_directory_name.append('windows')\n    else:\n        remote_zip_file_directory_name.append('linux')\n    return remote_zip_file_directory_name", "refactored": true, "pred": {"ppl": 3.48386549949646, "ppl_lower": 3.661546468734741, "ppl/lowercase_ppl": -1.0398537341970826, "ppl/zlib": 0.005859823723234096, "Min_5.0% Prob": 9.84784746170044, "Min_10.0% Prob": 8.257257571587196, "Min_20.0% Prob": 5.770662252719585, "Min_30.0% Prob": 4.066904320930823, "Min_40.0% Prob": 3.1016715502796264, "Min_50.0% Prob": 2.492527883614485, "Min_60.0% Prob": 2.0799502272767803}}
{"hexsha": "c8cc0e831e5f48f15a8c98373df38d2e3f24ded3", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef heap_sort(list_item):\n    \"\"\"\n    Heap Sort\n    Time Complexity of Solution:\n    Best - O(nlog(n))\n    Average - O(nlog(n))\n    Worst - O(nlog(n))\n\n    Approach:\n    Heap sort takes place in two steps. In first step, array is\n    transformed into a heap.\n    In second step, heap is continously reduced to a sorted array.\n\n    \"\"\"\n    end = len(list_item)\n    start = end // 2 - 1\n    for i in range(start, -1, -1):\n        heapify(list_item, end, i)\n    for i in range(end - 1, 0, -1):\n        swap(list_item, i, 0)\n        heapify(list_item, i, 0)", "fn_id": 0, "class_fn": false, "repo": "mish24/pydsa", "file": "pydsa/heap_sort.py", "last_update_at": "2021-11-02T09:24:38+00:00", "original_content": "def heap_sort(list_item):\n    \"\"\"\n    Heap Sort\n    Time Complexity of Solution:\n    Best - O(nlog(n))\n    Average - O(nlog(n))\n    Worst - O(nlog(n))\n\n    Approach:\n    Heap sort takes place in two steps. In first step, array is\n    transformed into a heap.\n    In second step, heap is continously reduced to a sorted array.\n\n    \"\"\"\n    end = len(list_item)\n    start = end // 2 - 1\n    for i in range(start, -1, -1):\n        heapify(list_item, end, i)\n    for i in range(end - 1, 0, -1):\n        swap(list_item, i, 0)\n        heapify(list_item, i, 0)", "refactored": true, "pred": {"ppl": 3.416212320327759, "ppl_lower": 4.031954765319824, "ppl/lowercase_ppl": -1.134891745031947, "ppl/zlib": 0.004014811858357828, "Min_5.0% Prob": 9.83213726679484, "Min_10.0% Prob": 8.330317346673263, "Min_20.0% Prob": 5.610765253242693, "Min_30.0% Prob": 4.04573719125045, "Min_40.0% Prob": 3.0927066153993734, "Min_50.0% Prob": 2.45664473772437, "Min_60.0% Prob": 2.0510819514894494}}
{"hexsha": "29dcd0e7194a9a266ef5c8a71033e49f8cc50186", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef a_star(grid, h, start, goal):\n    path = []\n    path_cost = 0\n    queue = PriorityQueue()\n    queue.put((0, start))\n    visited = set(start)\n    branch = {}\n    found = False\n    while not queue.empty():\n        item = queue.get()\n        current_node = item[1]\n        if current_node == start:\n            current_cost = 0.0\n        else:\n            current_cost = branch[current_node][0]\n        if current_node == goal:\n            print('Found a path.')\n            found = True\n            break\n        else:\n            for action in valid_actions(grid, current_node):\n                da = action.delta\n                next_node = (current_node[0] + da[0], current_node[1] + da[1])\n                branch_cost = current_cost + action.cost\n                queue_cost = branch_cost + h(next_node, goal)\n                if next_node not in visited:\n                    visited.add(next_node)\n                    branch[next_node] = (branch_cost, current_node, action)\n                    queue.put((queue_cost, next_node))\n    if found:\n        n = goal\n        path_cost = branch[n][0]\n        path.append(goal)\n        while branch[n][1] != start:\n            path.append(branch[n][1])\n            n = branch[n][1]\n        path.append(branch[n][1])\n    else:\n        print('**********************')\n        print('Failed to find a path!')\n        print('**********************')\n    return (path[::-1], path_cost)", "fn_id": 2, "class_fn": false, "repo": "allthatido/Drone_Motion_Planning", "file": "planning_utils.py", "last_update_at": "2021-07-08T18:54:42+00:00", "original_content": "def a_star(grid, h, start, goal):\n    path = []\n    path_cost = 0\n    queue = PriorityQueue()\n    queue.put((0, start))\n    visited = set(start)\n    branch = {}\n    found = False\n    while not queue.empty():\n        item = queue.get()\n        current_node = item[1]\n        if current_node == start:\n            current_cost = 0.0\n        else:\n            current_cost = branch[current_node][0]\n        if current_node == goal:\n            print('Found a path.')\n            found = True\n            break\n        else:\n            for action in valid_actions(grid, current_node):\n                da = action.delta\n                next_node = (current_node[0] + da[0], current_node[1] + da[1])\n                branch_cost = current_cost + action.cost\n                queue_cost = branch_cost + h(next_node, goal)\n                if next_node not in visited:\n                    visited.add(next_node)\n                    branch[next_node] = (branch_cost, current_node, action)\n                    queue.put((queue_cost, next_node))\n    if found:\n        n = goal\n        path_cost = branch[n][0]\n        path.append(goal)\n        while branch[n][1] != start:\n            path.append(branch[n][1])\n            n = branch[n][1]\n        path.append(branch[n][1])\n    else:\n        print('**********************')\n        print('Failed to find a path!')\n        print('**********************')\n    return (path[::-1], path_cost)", "refactored": true, "pred": {"ppl": 1.708198070526123, "ppl_lower": 1.8668122291564941, "ppl/lowercase_ppl": -1.1658325632338429, "ppl/zlib": 0.0010882907621808735, "Min_5.0% Prob": 6.800524393717448, "Min_10.0% Prob": 4.90943934788575, "Min_20.0% Prob": 2.646668241719405, "Min_30.0% Prob": 1.788957723416388, "Min_40.0% Prob": 1.338061469675352, "Min_50.0% Prob": 1.0736650002231314, "Min_60.0% Prob": 0.8923838384717238}}
{"hexsha": "7fa31603a252cfd1d536877477d7abb4da4bdef3", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef decimal_to_binary(n: int):\n    \"\"\"\n    Function to convert Decimal number to Binary number \n    \n    :param n: \n    :return: \n    \"\"\"\n    return int('{0:b}'.format(n))", "fn_id": 0, "class_fn": false, "repo": "ikostan/python", "file": "secret-handshake/secret_handshake.py", "last_update_at": "2021-08-02T19:20:10+00:00", "original_content": "def decimal_to_binary(n: int):\n    \"\"\"\n    Function to convert Decimal number to Binary number \n    \n    :param n: \n    :return: \n    \"\"\"\n    return int('{0:b}'.format(n))", "refactored": true, "pred": {"ppl": 7.804781913757324, "ppl_lower": 7.841054916381836, "ppl/lowercase_ppl": -1.0022566246356188, "ppl/zlib": 0.014170597322163882, "Min_5.0% Prob": 11.99351453781128, "Min_10.0% Prob": 10.091504859924317, "Min_20.0% Prob": 7.669569579037753, "Min_30.0% Prob": 6.347352147102356, "Min_40.0% Prob": 5.002346190539273, "Min_50.0% Prob": 4.155826650283955, "Min_60.0% Prob": 3.4178696924989875}}
{"hexsha": "66a6d587f9640fe42f4703541334c4465b7b3a16", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _parse_word(operand):\n    value = OP_EVALUATOR.eval_int(operand)\n    if 0 <= value < 65536:\n        return (value % 256, value // 256)\n    raise ValueError", "fn_id": 6, "class_fn": false, "repo": "skoolkid/sk6502", "file": "sk6502/assembler.py", "last_update_at": "2021-01-26T17:44:49+00:00", "original_content": "def _parse_word(operand):\n    value = OP_EVALUATOR.eval_int(operand)\n    if 0 <= value < 65536:\n        return (value % 256, value // 256)\n    raise ValueError", "refactored": true, "pred": {"ppl": 7.012874126434326, "ppl_lower": 7.89487361907959, "ppl/lowercase_ppl": -1.0608220581608552, "ppl/zlib": 0.012898990866151424, "Min_5.0% Prob": 12.331350644429525, "Min_10.0% Prob": 9.992042779922485, "Min_20.0% Prob": 7.640803850614107, "Min_30.0% Prob": 6.01328873038292, "Min_40.0% Prob": 4.875713513447688, "Min_50.0% Prob": 3.9130138154282714, "Min_60.0% Prob": 3.2500711634755133}}
{"hexsha": "f46d4201935576f7c5b0f071b01e8b9a5b4caddc", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_proportions_delta_aa(proportions_data_small):\n    exp = Experiment(proportions_data_small, name='proportions-test')\n    test_aa = HypothesisTest(metric='metric', control='A', variation='A', hypothesis='larger', inference_method='proportions_delta')\n    results_aa = exp.run_test(test_aa)\n    assert not results_aa.accept_hypothesis", "fn_id": 4, "class_fn": false, "repo": "quizlet/abracadabra", "file": "test/test_proportions_delta.py", "last_update_at": "2021-09-01T12:25:38+00:00", "original_content": "def test_proportions_delta_aa(proportions_data_small):\n    exp = Experiment(proportions_data_small, name='proportions-test')\n    test_aa = HypothesisTest(metric='metric', control='A', variation='A', hypothesis='larger', inference_method='proportions_delta')\n    results_aa = exp.run_test(test_aa)\n    assert not results_aa.accept_hypothesis", "refactored": true, "pred": {"ppl": 6.53222131729126, "ppl_lower": 7.401306629180908, "ppl/lowercase_ppl": -1.0665563849715547, "ppl/zlib": 0.008648603947209831, "Min_5.0% Prob": 9.48695240020752, "Min_10.0% Prob": 8.26604140888561, "Min_20.0% Prob": 6.635379292748191, "Min_30.0% Prob": 5.5103762944539385, "Min_40.0% Prob": 4.528162697499448, "Min_50.0% Prob": 3.680714842464243, "Min_60.0% Prob": 3.118239055596181}}
{"hexsha": "dd575f7aaba2cc90075652902b7b83a55562e8f2", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _load_cache():\n    if not os.path.exists(cache_file_name):\n        raise ValueError('No cache file found.')\n    else:\n        with open(cache_file_name, 'rb') as f:\n            dataset_stats = pickle.load(f)\n    return dataset_stats", "fn_id": 0, "class_fn": false, "repo": "cmusatyalab/dronesearch", "file": "experiments/random_select/plot_random_select_and_filter.py", "last_update_at": "2021-10-08T23:19:12+00:00", "original_content": "def _load_cache():\n    if not os.path.exists(cache_file_name):\n        raise ValueError('No cache file found.')\n    else:\n        with open(cache_file_name, 'rb') as f:\n            dataset_stats = pickle.load(f)\n    return dataset_stats", "refactored": true, "pred": {"ppl": 3.60776948928833, "ppl_lower": 4.652432441711426, "ppl/lowercase_ppl": -1.1981938401770598, "ppl/zlib": 0.0072902824510296775, "Min_5.0% Prob": 8.0007963180542, "Min_10.0% Prob": 6.6987898009163995, "Min_20.0% Prob": 5.170148833592733, "Min_30.0% Prob": 4.036389117891138, "Min_40.0% Prob": 3.1476008454958597, "Min_50.0% Prob": 2.585311496579969, "Min_60.0% Prob": 2.13672543913126}}
{"hexsha": "d4e3e838774528218776e66d0b619c26190040dd", "ext": "py", "lang": "Python", "content": "@api_view(['PUT'])\n@permission_classes((IsAuthenticated,))\n@allowed_groups(group_names=['admin'])\n@timeing\n@measure_memory_usage\ndef updateUser(request: HttpRequest, id):\n    user = get_object_or_404(User, id=id)\n    groups = request.data.pop('authGroups', [])\n    serialised = UserSerializer(user, data=request.data, context={'request': request}, partial=True)\n    if serialised.is_valid():\n        serialised.save()\n        user_group_many.objects.filter(user=user).delete()\n        for group in groups:\n            user_group_many.objects.create(user=user, group_id=group['id'])\n        return Response(status=status.HTTP_200_OK)\n    print(serialised.error_messages)\n    return Response(status=status.HTTP_400_BAD_REQUEST)", "fn_id": 6, "class_fn": false, "repo": "JetLightStudio/Jet-Gest-stock-management", "file": "server/auth_app/views/authViews.py", "last_update_at": "2021-08-18T18:53:02+00:00", "original_content": "@api_view(['PUT'])\n@permission_classes((IsAuthenticated,))\n@allowed_groups(group_names=['admin'])\ndef updateUser(request: HttpRequest, id):\n    user = get_object_or_404(User, id=id)\n    groups = request.data.pop('authGroups', [])\n    serialised = UserSerializer(user, data=request.data, context={'request': request}, partial=True)\n    if serialised.is_valid():\n        serialised.save()\n        user_group_many.objects.filter(user=user).delete()\n        for group in groups:\n            user_group_many.objects.create(user=user, group_id=group['id'])\n        return Response(status=status.HTTP_200_OK)\n    print(serialised.error_messages)\n    return Response(status=status.HTTP_400_BAD_REQUEST)", "refactored": true, "pred": {"ppl": 2.8275203704833984, "ppl_lower": 3.724256992340088, "ppl/lowercase_ppl": -1.2650252049656603, "ppl/zlib": 0.0025920202827859895, "Min_5.0% Prob": 10.252448654174804, "Min_10.0% Prob": 7.614110197339739, "Min_20.0% Prob": 4.898880535647983, "Min_30.0% Prob": 3.40994107794194, "Min_40.0% Prob": 2.5917346198111773, "Min_50.0% Prob": 2.0851122447067785, "Min_60.0% Prob": 1.7398211385810836}}
{"hexsha": "7a6ac05f5c406402bdf62d0f733ffe486364b813", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef speak_rank_top_10():\n    sql = '\\n        select * \\n        from(select row_number() over(order by user_speak_total desc) as row_number,* from user_info)\\n        where row_number <= 10\\n    '\n    data = sql_dql(sql)\n    msg = f'\ud83d\ude48\u53d1\u8a00\u5149\u8363\u699c\ud83d\ude48\\n__________________\\n'\n    for item in data:\n        rank = item[0]\n        name = item[1]\n        id = item[2]\n        num = item[3]\n        num_emoji = rank_emoji(rank)\n        msg += f'{num_emoji}{name}({id})\ud83d\udde3\ufe0f:{num}\\n'\n    msg += f'\u8fd9\u4e9b\ud83d\udc68\u90fd4\ufe0f\u20e3\u5927\ud83d\udca6\ud83d\udc7e'\n    return msg", "fn_id": 2, "class_fn": false, "repo": "Twip-Emma/QQbot-Twip", "file": "bot_plugins/user/user_speaki_rank/__init__.py", "last_update_at": "2021-12-23T15:36:48+00:00", "original_content": "def speak_rank_top_10():\n    sql = '\\n        select * \\n        from(select row_number() over(order by user_speak_total desc) as row_number,* from user_info)\\n        where row_number <= 10\\n    '\n    data = sql_dql(sql)\n    msg = f'\ud83d\ude48\u53d1\u8a00\u5149\u8363\u699c\ud83d\ude48\\n__________________\\n'\n    for item in data:\n        rank = item[0]\n        name = item[1]\n        id = item[2]\n        num = item[3]\n        num_emoji = rank_emoji(rank)\n        msg += f'{num_emoji}{name}({id})\ud83d\udde3\ufe0f:{num}\\n'\n    msg += f'\u8fd9\u4e9b\ud83d\udc68\u90fd4\ufe0f\u20e3\u5927\ud83d\udca6\ud83d\udc7e'\n    return msg", "refactored": true, "pred": {"ppl": 7.329914569854736, "ppl_lower": 7.329914569854736, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005595404103841892, "Min_5.0% Prob": 11.844713401794433, "Min_10.0% Prob": 9.919131994247437, "Min_20.0% Prob": 7.7128061890602115, "Min_30.0% Prob": 6.073864475886027, "Min_40.0% Prob": 4.8629365235567095, "Min_50.0% Prob": 3.9577796606719495, "Min_60.0% Prob": 3.3134162331310413}}
{"hexsha": "43ee7c52704e9f62de936933b0306b16b4a79105", "ext": "py", "lang": "Python", "content": "def test_model_default_implementations():\n\n    class MyModel(Model):\n        pass\n    model = MyModel()\n    with pytest.raises(NotImplementedError):\n        model.__prior__()\n    with pytest.raises(NotImplementedError):\n        model.__condition__(None, None)\n    with pytest.raises(NotImplementedError):\n        model.__noiseless__()\n    with pytest.raises(NotImplementedError):\n        model.logpdf(None, None)\n    with pytest.raises(NotImplementedError):\n        model.sample(None)\n\n    class MyModel2(Model):\n\n        @timeing\n        @measure_memory_usage\n        def __prior__(self):\n            pass\n\n        def sample(self, x):\n            return 1\n    model = MyModel2()\n    assert model.predict(None, num_samples=100) == (1, 0)", "fn_id": 8, "class_fn": false, "repo": "wesselb/probmods", "file": "tests/test_model.py", "last_update_at": "2021-08-28T16:32:03+00:00", "original_content": "def test_model_default_implementations():\n\n    class MyModel(Model):\n        pass\n    model = MyModel()\n    with pytest.raises(NotImplementedError):\n        model.__prior__()\n    with pytest.raises(NotImplementedError):\n        model.__condition__(None, None)\n    with pytest.raises(NotImplementedError):\n        model.__noiseless__()\n    with pytest.raises(NotImplementedError):\n        model.logpdf(None, None)\n    with pytest.raises(NotImplementedError):\n        model.sample(None)\n\n    class MyModel2(Model):\n\n        def __prior__(self):\n            pass\n\n        def sample(self, x):\n            return 1\n    model = MyModel2()\n    assert model.predict(None, num_samples=100) == (1, 0)", "refactored": true, "pred": {"ppl": 3.513701915740967, "ppl_lower": 4.084327220916748, "ppl/lowercase_ppl": -1.1197504851823348, "ppl/zlib": 0.004796450986817442, "Min_5.0% Prob": 10.11643934249878, "Min_10.0% Prob": 7.921335753272562, "Min_20.0% Prob": 5.484970164299011, "Min_30.0% Prob": 4.084594696760178, "Min_40.0% Prob": 3.1173037007451057, "Min_50.0% Prob": 2.5050346242179247, "Min_60.0% Prob": 2.1047675047513277}}
{"hexsha": "7d2d407dbcaa652ae9d9750427e051162ad2d2e3", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef pattern_loader(path_to_rules='patterns.jsonl') -> List:\n    \"\"\" Loads the patterns from the pattern list. \"\"\"\n    patterns = []\n    patternDicts = []\n    with open(path_to_rules, encoding='utf8') as f:\n        try:\n            for line in f:\n                data = json.loads(line)\n                patternDicts.append(data)\n        except:\n            pass\n    for patternDict in patternDicts:\n        patterns.append(Pattern(**patternDict))\n    return patterns", "fn_id": 5, "class_fn": false, "repo": "ChrisChross/turCy", "file": "turcy/tree_dep_pattern.py", "last_update_at": "2021-04-15T12:29:32+00:00", "original_content": "def pattern_loader(path_to_rules='patterns.jsonl') -> List:\n    \"\"\" Loads the patterns from the pattern list. \"\"\"\n    patterns = []\n    patternDicts = []\n    with open(path_to_rules, encoding='utf8') as f:\n        try:\n            for line in f:\n                data = json.loads(line)\n                patternDicts.append(data)\n        except:\n            pass\n    for patternDict in patternDicts:\n        patterns.append(Pattern(**patternDict))\n    return patterns", "refactored": true, "pred": {"ppl": 4.617842674255371, "ppl_lower": 5.312884330749512, "ppl/lowercase_ppl": -1.0916430489561597, "ppl/zlib": 0.006295998528446397, "Min_5.0% Prob": 10.319804430007935, "Min_10.0% Prob": 8.649988810221354, "Min_20.0% Prob": 6.495216389497121, "Min_30.0% Prob": 4.958544636766116, "Min_40.0% Prob": 3.8550706387807927, "Min_50.0% Prob": 3.052214028649643, "Min_60.0% Prob": 2.555330294248176}}
{"hexsha": "9a23cc6017e673eb9497903c018a6480ea3f8e60", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef readVDAT(fid, address):\n    vdat = namedtuple('vdat', [])\n    if address != -1:\n        fid.seek(address, 0)\n    [dumCRC, lastSize, lastType, dumMisc] = readARDFpointer(fid, -1)\n    vdat.force = struct.unpack('i', fid.read(4))[0]\n    vdat.line = struct.unpack('i', fid.read(4))[0]\n    vdat.point = struct.unpack('i', fid.read(4))[0]\n    vdat.sizeData = struct.unpack('i', fid.read(4))[0]\n    vdat.forceType = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt0 = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt1 = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt2 = struct.unpack('i', fid.read(4))[0]\n    dum = struct.unpack('i' * 2, fid.read(4 * 2))[0]\n    sizeData = vdat.sizeData\n    vdat.data = struct.unpack('f' * sizeData, fid.read(4 * sizeData))\n    return vdat", "fn_id": 6, "class_fn": false, "repo": "yu-efremov/ViscoIndent", "file": "import_ARDF.py", "last_update_at": "2021-12-21T13:26:53+00:00", "original_content": "def readVDAT(fid, address):\n    vdat = namedtuple('vdat', [])\n    if address != -1:\n        fid.seek(address, 0)\n    [dumCRC, lastSize, lastType, dumMisc] = readARDFpointer(fid, -1)\n    vdat.force = struct.unpack('i', fid.read(4))[0]\n    vdat.line = struct.unpack('i', fid.read(4))[0]\n    vdat.point = struct.unpack('i', fid.read(4))[0]\n    vdat.sizeData = struct.unpack('i', fid.read(4))[0]\n    vdat.forceType = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt0 = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt1 = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt2 = struct.unpack('i', fid.read(4))[0]\n    dum = struct.unpack('i' * 2, fid.read(4 * 2))[0]\n    sizeData = vdat.sizeData\n    vdat.data = struct.unpack('f' * sizeData, fid.read(4 * sizeData))\n    return vdat", "refactored": true, "pred": {"ppl": 3.354396343231201, "ppl_lower": 3.310424566268921, "ppl/lowercase_ppl": -0.989097178399859, "ppl/zlib": 0.0043070171769853125, "Min_5.0% Prob": 11.237955093383789, "Min_10.0% Prob": 8.894348955154419, "Min_20.0% Prob": 5.754022041956584, "Min_30.0% Prob": 4.01503041850196, "Min_40.0% Prob": 3.0317291697797675, "Min_50.0% Prob": 2.4282596093105773, "Min_60.0% Prob": 2.023812112147506}}
{"hexsha": "4621fba19fcf958d4877519ee2e7db8ca9d513e9", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef search_froms():\n    \"\"\"\n    Search for unique \"from xxx import yyy\" statements, returning a sorted list.\n    \"\"\"\n    _froms = []\n    _lib_dir_regex = '{}\\\\.'.format(LIB_DIR)\n    _regex = '^[ ]*from '\n    print(Fore.GREEN + '\\nimport list contents:' + Style.RESET_ALL)\n    for _items in _find_in_files('^[ ]*from.*import.*'):\n        _item = _items[0]\n        _filename = _items[1]\n        _library_name = re.sub(' import.*', '', _item)\n        _library_name = re.sub(_regex, '', _library_name).strip()\n        if IGNORE_LIB and re.match(_lib_dir_regex, _library_name):\n            pass\n        elif len(_library_name) > 1 and _library_name not in _froms:\n            _froms.append(_library_name)\n    _froms.sort()\n    print(Fore.CYAN + \"\\n-- complete: {:d} instances of '{}' found.\".format(len(_froms), _regex) + Style.RESET_ALL)\n    return _froms", "fn_id": 3, "class_fn": false, "repo": "ifurusato/ros", "file": "import_report.py", "last_update_at": "2021-07-23T14:20:05+00:00", "original_content": "def search_froms():\n    \"\"\"\n    Search for unique \"from xxx import yyy\" statements, returning a sorted list.\n    \"\"\"\n    _froms = []\n    _lib_dir_regex = '{}\\\\.'.format(LIB_DIR)\n    _regex = '^[ ]*from '\n    print(Fore.GREEN + '\\nimport list contents:' + Style.RESET_ALL)\n    for _items in _find_in_files('^[ ]*from.*import.*'):\n        _item = _items[0]\n        _filename = _items[1]\n        _library_name = re.sub(' import.*', '', _item)\n        _library_name = re.sub(_regex, '', _library_name).strip()\n        if IGNORE_LIB and re.match(_lib_dir_regex, _library_name):\n            pass\n        elif len(_library_name) > 1 and _library_name not in _froms:\n            _froms.append(_library_name)\n    _froms.sort()\n    print(Fore.CYAN + \"\\n-- complete: {:d} instances of '{}' found.\".format(len(_froms), _regex) + Style.RESET_ALL)\n    return _froms", "refactored": true, "pred": {"ppl": 6.267065525054932, "ppl_lower": 6.68787145614624, "ppl/lowercase_ppl": -1.0354095447396108, "ppl/zlib": 0.0041150408671693246, "Min_5.0% Prob": 11.3548798927894, "Min_10.0% Prob": 9.12203559169063, "Min_20.0% Prob": 7.065733212011832, "Min_30.0% Prob": 5.71876871438674, "Min_40.0% Prob": 4.518846157493941, "Min_50.0% Prob": 3.6684544810148725, "Min_60.0% Prob": 3.0707846263115024}}
{"hexsha": "f5243a5a3b358ca43895541eb22f25937e8336f3", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef try_to_get_last_line_as_json(file_location: str, max_tries=3, await_in_seconds_between_tries=1) -> Optional[dict]:\n    attempts = 0\n    while True:\n        line = last_line_from_some_file(file_location)\n        line_as_json = json.loads(line) if line else None\n        if line_as_json:\n            return line_as_json\n        if attempts >= max_tries:\n            return None\n        sleep(await_in_seconds_between_tries)\n        attempts += 1", "fn_id": 5, "class_fn": false, "repo": "juntossomosmais/python-fluentd-testing", "file": "python_fluentd_testing/utils.py", "last_update_at": "2021-11-12T20:00:54+00:00", "original_content": "def try_to_get_last_line_as_json(file_location: str, max_tries=3, await_in_seconds_between_tries=1) -> Optional[dict]:\n    attempts = 0\n    while True:\n        line = last_line_from_some_file(file_location)\n        line_as_json = json.loads(line) if line else None\n        if line_as_json:\n            return line_as_json\n        if attempts >= max_tries:\n            return None\n        sleep(await_in_seconds_between_tries)\n        attempts += 1", "refactored": true, "pred": {"ppl": 3.631347417831421, "ppl_lower": 4.42364501953125, "ppl/lowercase_ppl": -1.1530394506945727, "ppl/zlib": 0.005328941193752997, "Min_5.0% Prob": 10.213140283312116, "Min_10.0% Prob": 8.575750691550118, "Min_20.0% Prob": 5.90130065227377, "Min_30.0% Prob": 4.282033379687819, "Min_40.0% Prob": 3.2143518247737966, "Min_50.0% Prob": 2.595164357412917, "Min_60.0% Prob": 2.1489508003638735}}
{"hexsha": "b82969bc09d27dd516accba17236411cb1f5adb8", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_get_binary_patterns():\n    wl = Wordlist(data_path('wichmannmixezoquean.tsv'))\n    pats, characters = get_binary_patterns(wl, 'cogid')\n    etd = wl.get_etymdict(ref='cogid')\n    assert len(etd) == len(pats)", "fn_id": 0, "class_fn": false, "repo": "WesScivetti/data", "file": "tests/test_wordlist.py", "last_update_at": "2021-05-23T18:25:06+00:00", "original_content": "def test_get_binary_patterns():\n    wl = Wordlist(data_path('wichmannmixezoquean.tsv'))\n    pats, characters = get_binary_patterns(wl, 'cogid')\n    etd = wl.get_etymdict(ref='cogid')\n    assert len(etd) == len(pats)", "refactored": true, "pred": {"ppl": 9.354883193969727, "ppl_lower": 9.8104248046875, "ppl/lowercase_ppl": -1.0212653225213761, "ppl/zlib": 0.012924268634112838, "Min_5.0% Prob": 13.230922222137451, "Min_10.0% Prob": 10.58533787727356, "Min_20.0% Prob": 8.164865802316104, "Min_30.0% Prob": 6.436427419002239, "Min_40.0% Prob": 5.3605774816344764, "Min_50.0% Prob": 4.438035256640855, "Min_60.0% Prob": 3.717393578818211}}
{"hexsha": "1609ca3cfecd7e4bdac13a4eed7e722233b86773", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\nasync def get_prefix(bot_, message):\n    \"\"\"Returns the appropriate prefix for the bot.\"\"\"\n    with open('./data/options.json', 'r') as options_file:\n        options_dict = json.load(options_file)\n    if message.guild and str(message.guild.id) in options_dict:\n        prefixes = options_dict[str(message.guild.id)]['prefix']\n    else:\n        prefixes = '.'\n    return commands.when_mentioned_or(*prefixes)(bot_, message)", "fn_id": 0, "class_fn": false, "repo": "ethantv1234567890/ServerAntiRaid", "file": "main.py", "last_update_at": "2021-01-28T06:22:08+00:00", "original_content": "async def get_prefix(bot_, message):\n    \"\"\"Returns the appropriate prefix for the bot.\"\"\"\n    with open('./data/options.json', 'r') as options_file:\n        options_dict = json.load(options_file)\n    if message.guild and str(message.guild.id) in options_dict:\n        prefixes = options_dict[str(message.guild.id)]['prefix']\n    else:\n        prefixes = '.'\n    return commands.when_mentioned_or(*prefixes)(bot_, message)", "refactored": true, "pred": {"ppl": 2.979400634765625, "ppl_lower": 3.092411756515503, "ppl/lowercase_ppl": -1.0341012950523019, "ppl/zlib": 0.004419927736902138, "Min_5.0% Prob": 8.828831593195597, "Min_10.0% Prob": 7.043788929780324, "Min_20.0% Prob": 5.122366686662038, "Min_30.0% Prob": 3.650432208345996, "Min_40.0% Prob": 2.764696385478601, "Min_50.0% Prob": 2.181272521126466, "Min_60.0% Prob": 1.8242767948006624}}
{"hexsha": "9886643486593889d35875fc98bf1b7805dee00d", "ext": "py", "lang": "Python", "content": "@pytest.mark.parametrize('operation', [cirq.CNOT(AspenQubit(0, 1), AspenQubit(0, 2))])\n@timeing\n@measure_memory_usage\ndef test_rigetti_qcs_aspen_device_valid_operation(operation: cirq.Operation, qcs_aspen8_isa: InstructionSetArchitecture):\n    \"\"\"test RigettiQCSAspenDevice throws no error when validating 2Q operations on\n    adjacent qubits\n    \"\"\"\n    device = RigettiQCSAspenDevice(isa=qcs_aspen8_isa)\n    device.validate_operation(operation)", "fn_id": 14, "class_fn": false, "repo": "dabacon/Cirq", "file": "cirq-rigetti/cirq_rigetti/aspen_device_test.py", "last_update_at": "2021-04-29T15:30:32+00:00", "original_content": "@pytest.mark.parametrize('operation', [cirq.CNOT(AspenQubit(0, 1), AspenQubit(0, 2))])\ndef test_rigetti_qcs_aspen_device_valid_operation(operation: cirq.Operation, qcs_aspen8_isa: InstructionSetArchitecture):\n    \"\"\"test RigettiQCSAspenDevice throws no error when validating 2Q operations on\n    adjacent qubits\n    \"\"\"\n    device = RigettiQCSAspenDevice(isa=qcs_aspen8_isa)\n    device.validate_operation(operation)", "refactored": true, "pred": {"ppl": 5.983086109161377, "ppl_lower": 9.281530380249023, "ppl/lowercase_ppl": -1.2454474692839879, "ppl/zlib": 0.00672532521281737, "Min_5.0% Prob": 12.224702290126256, "Min_10.0% Prob": 10.165456533432007, "Min_20.0% Prob": 7.31914156880872, "Min_30.0% Prob": 5.596038313799126, "Min_40.0% Prob": 4.409592126977855, "Min_50.0% Prob": 3.560467947733729, "Min_60.0% Prob": 2.9978807367726987}}
{"hexsha": "8090bbc869f16bd9ee00e270a16a5e0352ae7028", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef categoryFilter(doc):\n    categories = doc.Settings.Categories\n    cats = [ElementCategoryFilter(c.Id) for c in categories if c.CategoryType == CategoryType.Model and c.CanAddSubcategory]\n    filter = None\n    if len(cats):\n        try:\n            filter = LogicalOrFilter(List[ElementFilter](cats))\n        except Exception as ex:\n            raise Exception(str(ex) + str(len(cats)))\n    return filter", "fn_id": 0, "class_fn": false, "repo": "pabloderen/pyRevitExtension", "file": "lib/tools.py", "last_update_at": "2021-10-24T00:05:02+00:00", "original_content": "def categoryFilter(doc):\n    categories = doc.Settings.Categories\n    cats = [ElementCategoryFilter(c.Id) for c in categories if c.CategoryType == CategoryType.Model and c.CanAddSubcategory]\n    filter = None\n    if len(cats):\n        try:\n            filter = LogicalOrFilter(List[ElementFilter](cats))\n        except Exception as ex:\n            raise Exception(str(ex) + str(len(cats)))\n    return filter", "refactored": true, "pred": {"ppl": 8.198894500732422, "ppl_lower": 16.922563552856445, "ppl/lowercase_ppl": -1.3444148080316471, "ppl/zlib": 0.008915251390668347, "Min_5.0% Prob": 12.726673698425293, "Min_10.0% Prob": 10.4823166847229, "Min_20.0% Prob": 7.892218907674153, "Min_30.0% Prob": 6.403500698506832, "Min_40.0% Prob": 5.138717817705731, "Min_50.0% Prob": 4.189108538958761, "Min_60.0% Prob": 3.510333247253528}}
{"hexsha": "534d6702940b8bc6ddbaba4862587a1683235de5", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef view_form_force(form, force, forcescale=0.5, edge_label=True):\n    if edge_label:\n        form_edge_label = {uv: index for index, uv in enumerate(form.edges())}\n        force_edge_label = force_edge_labels\n    else:\n        form_edge_label = None\n        force_edge_label = None\n    viewer = Viewer(form, force, delay_setup=False)\n    viewer.draw_form(edgelabel=form_edge_label, forces_on=True, forcescale=forcescale, vertexcolor={key: '#000000' for key in form.vertices_where({'is_fixed': True})})\n    viewer.draw_force(edgelabel=force_edge_label)\n    viewer.show()", "fn_id": 0, "class_fn": false, "repo": "BlockResearchGroup/compas_ags", "file": "scripts/paper-CSD/exampleD_truss_constant.py", "last_update_at": "2021-12-15T18:47:04+00:00", "original_content": "def view_form_force(form, force, forcescale=0.5, edge_label=True):\n    if edge_label:\n        form_edge_label = {uv: index for index, uv in enumerate(form.edges())}\n        force_edge_label = force_edge_labels\n    else:\n        form_edge_label = None\n        force_edge_label = None\n    viewer = Viewer(form, force, delay_setup=False)\n    viewer.draw_form(edgelabel=form_edge_label, forces_on=True, forcescale=forcescale, vertexcolor={key: '#000000' for key in form.vertices_where({'is_fixed': True})})\n    viewer.draw_force(edgelabel=force_edge_label)\n    viewer.show()", "refactored": true, "pred": {"ppl": 3.4872021675109863, "ppl_lower": 4.167428016662598, "ppl/lowercase_ppl": -1.1426622016136672, "ppl/zlib": 0.004509385355609556, "Min_5.0% Prob": 9.47539202372233, "Min_10.0% Prob": 7.7850455443064375, "Min_20.0% Prob": 5.204237042246638, "Min_30.0% Prob": 3.9236901806933537, "Min_40.0% Prob": 3.105858470539789, "Min_50.0% Prob": 2.5004438516753975, "Min_60.0% Prob": 2.0829586048909863}}
{"hexsha": "b36cd3ac7c6ccf4bb43ebb3004f30af35e47297a", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef generateCoordsForLayersPG(dictDlsLayers, graphvizLayout, isHorizontal):\n    theGraph = pyg.AGraph()\n    for kk, vv in dictDlsLayers.items():\n        for ll in vv['cfg']['wires']:\n            theGraph.add_edge(kk, ll)\n    if isHorizontal:\n        pArgs = '-Grankdir=LR'\n    else:\n        pArgs = '-Grankdir=TB'\n    if graphvizLayout is None:\n        graphvizLayout = 'dot'\n    theGraph.layout(prog=graphvizLayout, args=pArgs)\n    theGraphPos = {}\n    for kk in dictDlsLayers.keys():\n        tnode = theGraph.get_node(kk)\n        tpos = [int(float(xx)) for xx in tnode.attr['pos'].split(',')]\n        theGraphPos[kk] = tuple(tpos)\n    return theGraphPos", "fn_id": 2, "class_fn": false, "repo": "SummaLabs/DLS", "file": "app/backend/core/models/convertors/keras2dls.py", "last_update_at": "2021-02-16T23:08:34+00:00", "original_content": "def generateCoordsForLayersPG(dictDlsLayers, graphvizLayout, isHorizontal):\n    theGraph = pyg.AGraph()\n    for kk, vv in dictDlsLayers.items():\n        for ll in vv['cfg']['wires']:\n            theGraph.add_edge(kk, ll)\n    if isHorizontal:\n        pArgs = '-Grankdir=LR'\n    else:\n        pArgs = '-Grankdir=TB'\n    if graphvizLayout is None:\n        graphvizLayout = 'dot'\n    theGraph.layout(prog=graphvizLayout, args=pArgs)\n    theGraphPos = {}\n    for kk in dictDlsLayers.keys():\n        tnode = theGraph.get_node(kk)\n        tpos = [int(float(xx)) for xx in tnode.attr['pos'].split(',')]\n        theGraphPos[kk] = tuple(tpos)\n    return theGraphPos", "refactored": true, "pred": {"ppl": 4.579631328582764, "ppl_lower": 5.673424243927002, "ppl/lowercase_ppl": -1.1407543084865854, "ppl/zlib": 0.004462224337077693, "Min_5.0% Prob": 11.468782234191895, "Min_10.0% Prob": 9.506255626678467, "Min_20.0% Prob": 6.717163909049261, "Min_30.0% Prob": 4.957398655868712, "Min_40.0% Prob": 3.7893861863939535, "Min_50.0% Prob": 3.041200264303812, "Min_60.0% Prob": 2.5356140900255433}}
{"hexsha": "3fa1da9767d379e042b89a14701794778faba152", "ext": "py", "lang": "Python", "content": "@numba.njit([types.Long(types.Keys)], cache=True)\n@timeing\n@measure_memory_usage\ndef find_depth(tree):\n    \"\"\"\n    Return maximum depth of a linear octree.\n    \"\"\"\n    levels = morton.find_level(np.unique(tree))\n    return np.max(levels)", "fn_id": 7, "class_fn": false, "repo": "Excalibur-SLE/AdapOctree", "file": "adaptoctree/tree.py", "last_update_at": "2021-04-27T10:58:52+00:00", "original_content": "@numba.njit([types.Long(types.Keys)], cache=True)\ndef find_depth(tree):\n    \"\"\"\n    Return maximum depth of a linear octree.\n    \"\"\"\n    levels = morton.find_level(np.unique(tree))\n    return np.max(levels)", "refactored": true, "pred": {"ppl": 14.530838012695312, "ppl_lower": 17.619430541992188, "ppl/lowercase_ppl": -1.072014005943591, "ppl/zlib": 0.01546978699752135, "Min_5.0% Prob": 13.965209007263184, "Min_10.0% Prob": 12.251651082720075, "Min_20.0% Prob": 9.70387134552002, "Min_30.0% Prob": 8.019489765167236, "Min_40.0% Prob": 6.413133903344472, "Min_50.0% Prob": 5.34146618681985, "Min_60.0% Prob": 4.446831102669239}}
{"hexsha": "52b60b2ec451113de42ad06d277c614499c2007a", "ext": "py", "lang": "Python", "content": "@expose_builtin('del_attrs', unwrap_spec=['obj'])\n@timeing\n@measure_memory_usage\ndef impl_del_attrs(engine, heap, attvar):\n    if isinstance(attvar, AttVar):\n        if attvar.value_list is not None:\n            for name, index in attvar.attmap.indexes.iteritems():\n                heap.add_trail_atts(attvar, name)\n            attvar.value_list = None", "fn_id": 5, "class_fn": false, "repo": "ForoughA/CORGI", "file": "testnet/prolog/builtin/attvars.py", "last_update_at": "2021-12-11T12:39:51+00:00", "original_content": "@expose_builtin('del_attrs', unwrap_spec=['obj'])\ndef impl_del_attrs(engine, heap, attvar):\n    if isinstance(attvar, AttVar):\n        if attvar.value_list is not None:\n            for name, index in attvar.attmap.indexes.iteritems():\n                heap.add_trail_atts(attvar, name)\n            attvar.value_list = None", "refactored": true, "pred": {"ppl": 13.255412101745605, "ppl_lower": 16.670320510864258, "ppl/lowercase_ppl": -1.0886950425317885, "ppl/zlib": 0.012076663222168452, "Min_5.0% Prob": 12.426151466369628, "Min_10.0% Prob": 10.887593173980713, "Min_20.0% Prob": 8.83476173877716, "Min_30.0% Prob": 7.359148097038269, "Min_40.0% Prob": 6.129472148418427, "Min_50.0% Prob": 5.119123980998993, "Min_60.0% Prob": 4.329237619290749}}
{"hexsha": "504b87ddee9917d8fa486f13be56f5b536985c45", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_client_with_wrong_credentials(zendesk_credentials):\n    \"\"\"Test check with wrong credentials\"\"\"\n    client = Client(**zendesk_credentials)\n    alive, error = client.health_check()\n    assert not alive\n    assert error", "fn_id": 0, "class_fn": false, "repo": "rajatariya21/airbyte", "file": "airbyte-integrations/connectors/source-zendesk-talk/unit_tests/unit_test.py", "last_update_at": "2021-04-30T13:53:34+00:00", "original_content": "def test_client_with_wrong_credentials(zendesk_credentials):\n    \"\"\"Test check with wrong credentials\"\"\"\n    client = Client(**zendesk_credentials)\n    alive, error = client.health_check()\n    assert not alive\n    assert error", "refactored": true, "pred": {"ppl": 6.908171653747559, "ppl_lower": 9.732403755187988, "ppl/lowercase_ppl": -1.1773451723929413, "ppl/zlib": 0.012155377412078765, "Min_5.0% Prob": 10.567446072896322, "Min_10.0% Prob": 9.2098179658254, "Min_20.0% Prob": 7.218440453211467, "Min_30.0% Prob": 5.846730536884731, "Min_40.0% Prob": 4.737311750650406, "Min_50.0% Prob": 3.810988176253534, "Min_60.0% Prob": 3.2209132605710544}}
{"hexsha": "241fb0211e37aae619cf601b0686c40ee27576eb", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef update_doing_card():\n    \"\"\"\n    DOING \uc0c1\ud0dc\uc758 \uce74\ub4dc\uc758 DURATION\uc744 \uc0c8\ub85c \uae30\ub85d\ud569\ub2c8\ub2e4.\n    DURATION\uc758 \uac12\uc774 \uc5c6\uc744 \uacbd\uc6b0\uc5d0\ub294 \uc2dc\uc791\uc77c\uc744 \ub2f9\uc77c\ub85c \uc124\uc815\ud569\ub2c8\ub2e4.\n    \"\"\"\n    status = notion.CARD_STATUS\n    doing = notion.DOING\n    duration = notion.CARD_DURATION\n    today = date.today()\n    for card_id in notion.get_filtered_card_ids(status, doing):\n        card = notion.client.get_block(card_id)\n        notion_date = card.get_property(duration)\n        if not notion_date or notion_date.start == None:\n            notion_date = NotionDate(start=today)\n        card.set_property(duration, notion_date)", "fn_id": 1, "class_fn": false, "repo": "wormwlrm/notion-scrum-analytics", "file": "commands/run_update_duration.py", "last_update_at": "2021-08-29T03:23:02+00:00", "original_content": "def update_doing_card():\n    \"\"\"\n    DOING \uc0c1\ud0dc\uc758 \uce74\ub4dc\uc758 DURATION\uc744 \uc0c8\ub85c \uae30\ub85d\ud569\ub2c8\ub2e4.\n    DURATION\uc758 \uac12\uc774 \uc5c6\uc744 \uacbd\uc6b0\uc5d0\ub294 \uc2dc\uc791\uc77c\uc744 \ub2f9\uc77c\ub85c \uc124\uc815\ud569\ub2c8\ub2e4.\n    \"\"\"\n    status = notion.CARD_STATUS\n    doing = notion.DOING\n    duration = notion.CARD_DURATION\n    today = date.today()\n    for card_id in notion.get_filtered_card_ids(status, doing):\n        card = notion.client.get_block(card_id)\n        notion_date = card.get_property(duration)\n        if not notion_date or notion_date.start == None:\n            notion_date = NotionDate(start=today)\n        card.set_property(duration, notion_date)", "refactored": true, "pred": {"ppl": 4.647822856903076, "ppl_lower": 5.551001071929932, "ppl/lowercase_ppl": -1.1155815568774152, "ppl/zlib": 0.004097063752377492, "Min_5.0% Prob": 10.554024590386284, "Min_10.0% Prob": 8.74895707766215, "Min_20.0% Prob": 6.314694398158306, "Min_30.0% Prob": 4.795393532940319, "Min_40.0% Prob": 3.774858011007309, "Min_50.0% Prob": 3.0684636744095926, "Min_60.0% Prob": 2.564475275872819}}
{"hexsha": "7354359d5802ce995119a41c90b85838a4204d5d", "ext": "py", "lang": "Python", "content": "@app.route('/commands_per_day')\n@cache(time=datetime.timedelta(minutes=DEFAULT_CACHE_MINUTES))\n@timeing\n@measure_memory_usage\ndef commands_per_day():\n    command_names = [row.get('command_name') for row in bigquery_client.query('SELECT DISTINCT command_name FROM analytics.commands').result()]\n    print(command_names)\n    command_names = filter(lambda item: item not in ['list', 'set', 'voices', 'languages', 'property'], command_names)\n    result = {}\n    for command_name in command_names:\n        usage = {date: {'text_count': 0, 'slash_count': 0} for date in get_days_in_range(datetime.datetime(2021, 1, 1), datetime.datetime.today())}\n        query = 'SELECT DATE(time) as d, COUNTIF(NOT is_slash) as cnt, COUNTIF(is_slash) as slash_cnt FROM analytics.commands WHERE command_name = @command_name GROUP BY d ORDER BY d'\n        job_config = bigquery.QueryJobConfig(query_parameters=[bigquery.ScalarQueryParameter('command_name', 'STRING', command_name)])\n        for row in bigquery_client.query(query, job_config=job_config).result():\n            d = row_to_dict(row)\n            usage[d['d']]['text_count'] = d['cnt']\n            usage[d['d']]['slash_count'] = d['slash_cnt']\n        result[command_name] = [{'date': date, **usage[date]} for date in usage.keys()]\n    response = jsonify(result)\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    return response", "fn_id": 4, "class_fn": false, "repo": "TychoTheTaco/Discord-Dictionary-Bot", "file": "api/main.py", "last_update_at": "2021-12-12T20:35:49+00:00", "original_content": "@app.route('/commands_per_day')\n@cache(time=datetime.timedelta(minutes=DEFAULT_CACHE_MINUTES))\ndef commands_per_day():\n    command_names = [row.get('command_name') for row in bigquery_client.query('SELECT DISTINCT command_name FROM analytics.commands').result()]\n    print(command_names)\n    command_names = filter(lambda item: item not in ['list', 'set', 'voices', 'languages', 'property'], command_names)\n    result = {}\n    for command_name in command_names:\n        usage = {date: {'text_count': 0, 'slash_count': 0} for date in get_days_in_range(datetime.datetime(2021, 1, 1), datetime.datetime.today())}\n        query = 'SELECT DATE(time) as d, COUNTIF(NOT is_slash) as cnt, COUNTIF(is_slash) as slash_cnt FROM analytics.commands WHERE command_name = @command_name GROUP BY d ORDER BY d'\n        job_config = bigquery.QueryJobConfig(query_parameters=[bigquery.ScalarQueryParameter('command_name', 'STRING', command_name)])\n        for row in bigquery_client.query(query, job_config=job_config).result():\n            d = row_to_dict(row)\n            usage[d['d']]['text_count'] = d['cnt']\n            usage[d['d']]['slash_count'] = d['slash_cnt']\n        result[command_name] = [{'date': date, **usage[date]} for date in usage.keys()]\n    response = jsonify(result)\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    return response", "refactored": true, "pred": {"ppl": 2.860931634902954, "ppl_lower": 3.5226473808288574, "ppl/lowercase_ppl": -1.1979413179122715, "ppl/zlib": 0.0016072588964181397, "Min_5.0% Prob": 9.89031249598453, "Min_10.0% Prob": 7.585093375964043, "Min_20.0% Prob": 4.911280046535444, "Min_30.0% Prob": 3.464834202988809, "Min_40.0% Prob": 2.621911253709838, "Min_50.0% Prob": 2.100877063269329, "Min_60.0% Prob": 1.7576555752316725}}
{"hexsha": "f31065a13878fbae4e2467fa58de8efe0ace1f13", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_delete_all_album():\n    rq_album.delete_all(token=env.env_var['USER_1_TOKEN'], user_id=env.env_var['USER_1_MAIL'])\n    rq_album.delete_all(token=env.env_var['USER_2_TOKEN'], user_id=env.env_var['USER_2_MAIL'])\n    rq_album.delete_all(token=env.env_var['USER_3_TOKEN'], user_id=env.env_var['USER_3_MAIL'])", "fn_id": 3, "class_fn": false, "repo": "OsiriX-Foundation/IntegrationTest", "file": "test_sharing_with_album_token_no_permission.py", "last_update_at": "2021-06-02T07:41:28+00:00", "original_content": "def test_delete_all_album():\n    rq_album.delete_all(token=env.env_var['USER_1_TOKEN'], user_id=env.env_var['USER_1_MAIL'])\n    rq_album.delete_all(token=env.env_var['USER_2_TOKEN'], user_id=env.env_var['USER_2_MAIL'])\n    rq_album.delete_all(token=env.env_var['USER_3_TOKEN'], user_id=env.env_var['USER_3_MAIL'])", "refactored": true, "pred": {"ppl": 2.859715223312378, "ppl_lower": 2.961707830429077, "ppl/lowercase_ppl": -1.0333523258283368, "ppl/zlib": 0.007399451039476862, "Min_5.0% Prob": 8.709227959314982, "Min_10.0% Prob": 7.372351939861591, "Min_20.0% Prob": 5.0965190419444335, "Min_30.0% Prob": 3.5449544500286985, "Min_40.0% Prob": 2.6543082257224753, "Min_50.0% Prob": 2.1165573602606393, "Min_60.0% Prob": 1.7596232296928065}}
{"hexsha": "1b7e2d214e5eeb85cf50702bb2e69e77348f954c", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _delete_old(old_ids):\n    db = get_db('yahoo')\n    for item in ['financial_data', 'key_stats']:\n        collection = db[item]\n        id_ = old_ids[item]\n        if id_:\n            result = collection.delete_many({'_id': {'$lte': id_}})\n            logger.info(f'\u5220\u9664 {item} \u65e7\u6570\u636e {result.deleted_count} \u884c')", "fn_id": 5, "class_fn": false, "repo": "NeoBert/liudengfeng-cnswd", "file": "cnswd/scripts/yahoo.py", "last_update_at": "2021-06-26T13:23:01+00:00", "original_content": "def _delete_old(old_ids):\n    db = get_db('yahoo')\n    for item in ['financial_data', 'key_stats']:\n        collection = db[item]\n        id_ = old_ids[item]\n        if id_:\n            result = collection.delete_many({'_id': {'$lte': id_}})\n            logger.info(f'\u5220\u9664 {item} \u65e7\u6570\u636e {result.deleted_count} \u884c')", "refactored": true, "pred": {"ppl": 4.998400688171387, "ppl_lower": 4.998400688171387, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0066218847691419756, "Min_5.0% Prob": 8.757856464385986, "Min_10.0% Prob": 7.780958986282348, "Min_20.0% Prob": 6.065248409907023, "Min_30.0% Prob": 4.91251914203167, "Min_40.0% Prob": 3.9954554452782585, "Min_50.0% Prob": 3.2310160048446566, "Min_60.0% Prob": 2.686828421894461}}
{"hexsha": "a9df1185d80d2c045bcd42e083755fc20bd784de", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef split_indices(idx, n_total, fractions):\n    \"\"\"\n    splits idx containing n_total distinct events into fractions given in fractions list.\n    returns the number of events in each split\n    \"\"\"\n    num_ids = [ceil(n_total * f) for f in fractions]\n    if sum(num_ids) > n_total:\n        num_ids[-1] -= sum(num_ids) - n_total\n    return num_ids", "fn_id": 0, "class_fn": false, "repo": "fact-project/classifier", "file": "aict_tools/scripts/split_data.py", "last_update_at": "2021-01-22T11:57:26+00:00", "original_content": "def split_indices(idx, n_total, fractions):\n    \"\"\"\n    splits idx containing n_total distinct events into fractions given in fractions list.\n    returns the number of events in each split\n    \"\"\"\n    num_ids = [ceil(n_total * f) for f in fractions]\n    if sum(num_ids) > n_total:\n        num_ids[-1] -= sum(num_ids) - n_total\n    return num_ids", "refactored": true, "pred": {"ppl": 5.060968399047852, "ppl_lower": 5.060968399047852, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.007758649991382687, "Min_5.0% Prob": 10.219864082336425, "Min_10.0% Prob": 8.781447410583496, "Min_20.0% Prob": 6.672332741997459, "Min_30.0% Prob": 5.13551770918297, "Min_40.0% Prob": 4.034220256588676, "Min_50.0% Prob": 3.263234394382347, "Min_60.0% Prob": 2.725504248036128}}
{"hexsha": "0e43d54d54e3eafdf583b28f0be4bd0753b4013d", "ext": "py", "lang": "Python", "content": "@app.route('/json-rpc', methods=['GET', 'POST', 'OPTIONS'])\n@timeing\n@measure_memory_usage\ndef jsonrpc():\n    result = ''\n    if request.headers['CONTENT_LENGTH']:\n        handler = JSONRPCHandler()\n        result = handler.handle(request.data)\n    response = make_response(result, 200)\n    hdr = 'Access-Control-Allow-%s'\n    response.headers[hdr % 'Origin'] = '*'\n    response.headers[hdr % 'Headers'] = 'Content-Type, Authentication'\n    response.headers[hdr % 'Method'] = 'POST, GET, OPTIONS, PUT, DELETE, TRACE'\n    return response", "fn_id": 0, "class_fn": false, "repo": "MasonM/apeye", "file": "examples/api.apeye.org/example_server/rpc.py", "last_update_at": "2021-07-27T18:31:15+00:00", "original_content": "@app.route('/json-rpc', methods=['GET', 'POST', 'OPTIONS'])\ndef jsonrpc():\n    result = ''\n    if request.headers['CONTENT_LENGTH']:\n        handler = JSONRPCHandler()\n        result = handler.handle(request.data)\n    response = make_response(result, 200)\n    hdr = 'Access-Control-Allow-%s'\n    response.headers[hdr % 'Origin'] = '*'\n    response.headers[hdr % 'Headers'] = 'Content-Type, Authentication'\n    response.headers[hdr % 'Method'] = 'POST, GET, OPTIONS, PUT, DELETE, TRACE'\n    return response", "refactored": true, "pred": {"ppl": 4.059423923492432, "ppl_lower": 4.910472393035889, "ppl/lowercase_ppl": -1.1358483191461566, "ppl/zlib": 0.0044761695615999466, "Min_5.0% Prob": 12.128582681928362, "Min_10.0% Prob": 8.927930323282878, "Min_20.0% Prob": 6.216084611415863, "Min_30.0% Prob": 4.5180426677068075, "Min_40.0% Prob": 3.4700663504501184, "Min_50.0% Prob": 2.795833412259817, "Min_60.0% Prob": 2.3341393045460186}}
{"hexsha": "6461501746c4c91ad65a43d4651b57d08946bf5f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef contains_inappropriate_phrases(tweet_text):\n    if 'sex' in tweet_text:\n        return True\n    return False", "fn_id": 4, "class_fn": false, "repo": "mgreiler/code-review-twitter-bot", "file": "code-review-bot/matching_rules.py", "last_update_at": "2021-10-04T08:36:17+00:00", "original_content": "def contains_inappropriate_phrases(tweet_text):\n    if 'sex' in tweet_text:\n        return True\n    return False", "refactored": true, "pred": {"ppl": 7.240550518035889, "ppl_lower": 9.137236595153809, "ppl/lowercase_ppl": -1.1175234025838325, "ppl/zlib": 0.01767586823133571, "Min_5.0% Prob": 9.710349082946777, "Min_10.0% Prob": 8.627851963043213, "Min_20.0% Prob": 7.091066777706146, "Min_30.0% Prob": 5.910088916619618, "Min_40.0% Prob": 4.833116322755814, "Min_50.0% Prob": 3.9340981166809796, "Min_60.0% Prob": 3.2900250234330692}}
{"hexsha": "dedf80bf95ac67960c80fd880c96b74b9b20d6cf", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_local_missing_url(tmpdir):\n    \"\"\" Test creating a toolchain from path to a local feed xml \"\"\"\n    full = '<feed>\\n<feed />\\n</feed>\\n'\n    with pytest.raises(Exception) as e:\n        _generic_test_local(tmpdir, full)\n    assert 'not parse' in str(e)\n    assert \"Non-root 'feed' element must have an 'url' attribute\" in str(e)", "fn_id": 9, "class_fn": false, "repo": "aldebaran/qibuild", "file": "python/qitoolchain/test/test_feed.py", "last_update_at": "2021-07-27T06:46:59+00:00", "original_content": "def test_local_missing_url(tmpdir):\n    \"\"\" Test creating a toolchain from path to a local feed xml \"\"\"\n    full = '<feed>\\n<feed />\\n</feed>\\n'\n    with pytest.raises(Exception) as e:\n        _generic_test_local(tmpdir, full)\n    assert 'not parse' in str(e)\n    assert \"Non-root 'feed' element must have an 'url' attribute\" in str(e)", "refactored": true, "pred": {"ppl": 12.431931495666504, "ppl_lower": 14.360209465026855, "ppl/lowercase_ppl": -1.0572133006170987, "ppl/zlib": 0.010457544743930597, "Min_5.0% Prob": 13.078358840942382, "Min_10.0% Prob": 11.33273754119873, "Min_20.0% Prob": 8.82476148151216, "Min_30.0% Prob": 7.245883427560329, "Min_40.0% Prob": 6.012562521668368, "Min_50.0% Prob": 4.979787082583816, "Min_60.0% Prob": 4.2364620686275885}}
{"hexsha": "3ca816c1fdae9c07f862a54969748690cccccdc9", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_authorization_token(event) -> str:\n    cookie = SimpleCookie()\n    cookie.load(', '.join(event['cookies']))\n    if COOKIE_TOKEN_KEY in cookie:\n        return cookie[COOKIE_TOKEN_KEY].value\n    header = event['headers'].get('authorization')\n    if header is None:\n        return None\n    return header.replace('Bearer ', '')", "fn_id": 0, "class_fn": false, "repo": "adacotech/terraform-aws-api-auth-proxy", "file": "modules/oauth2/lambda/authorizer/function.py", "last_update_at": "2021-09-17T03:22:05+00:00", "original_content": "def get_authorization_token(event) -> str:\n    cookie = SimpleCookie()\n    cookie.load(', '.join(event['cookies']))\n    if COOKIE_TOKEN_KEY in cookie:\n        return cookie[COOKIE_TOKEN_KEY].value\n    header = event['headers'].get('authorization')\n    if header is None:\n        return None\n    return header.replace('Bearer ', '')", "refactored": true, "pred": {"ppl": 5.064260482788086, "ppl_lower": 7.657153606414795, "ppl/lowercase_ppl": -1.2548576817318762, "ppl/zlib": 0.007340308242842918, "Min_5.0% Prob": 11.020477294921875, "Min_10.0% Prob": 9.41462230682373, "Min_20.0% Prob": 7.01451575756073, "Min_30.0% Prob": 5.203237001542692, "Min_40.0% Prob": 4.008961342275143, "Min_50.0% Prob": 3.230339116520352, "Min_60.0% Prob": 2.6999543695538133}}
{"hexsha": "fbbdcaf00a8d9fa8c6f2f80cfad9ef55df7708dc", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef fromList(li: List[int]):\n    if len(li) == 0:\n        return None\n    root = TreeNode(val=li[0])\n    queue = [root]\n    i = 1\n    while i < len(li):\n        node = queue[0]\n        del queue[0]\n        if li[i] is not None:\n            node.left = TreeNode(val=li[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(li):\n            if li[i]:\n                node.right = TreeNode(val=li[i])\n                queue.append(node.right)\n            i += 1\n    return root", "fn_id": 0, "class_fn": false, "repo": "wanglongjiang/leetcode", "file": "easy/897-increasing-order-search-tree.py", "last_update_at": "2021-03-14T11:38:30+00:00", "original_content": "def fromList(li: List[int]):\n    if len(li) == 0:\n        return None\n    root = TreeNode(val=li[0])\n    queue = [root]\n    i = 1\n    while i < len(li):\n        node = queue[0]\n        del queue[0]\n        if li[i] is not None:\n            node.left = TreeNode(val=li[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(li):\n            if li[i]:\n                node.right = TreeNode(val=li[i])\n                queue.append(node.right)\n            i += 1\n    return root", "refactored": true, "pred": {"ppl": 1.8420006036758423, "ppl_lower": 2.1667399406433105, "ppl/lowercase_ppl": -1.2658113098906136, "ppl/zlib": 0.002644382101997973, "Min_5.0% Prob": 8.071430615016393, "Min_10.0% Prob": 5.660433689753215, "Min_20.0% Prob": 3.0587699836300266, "Min_30.0% Prob": 2.03929730706868, "Min_40.0% Prob": 1.5467098163658632, "Min_50.0% Prob": 1.2295161520801814, "Min_60.0% Prob": 1.0202508108521873}}
{"hexsha": "9a9f21e89303399d79c67e75c99b8d626266c51f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_maximum_mutation_frequency(counts, distance_matrix, frequencies):\n    \"\"\"\n    # ========================================================================\n\n    GET MAXMIMUM MUTATION FREQUENCY\n\n    PURPOSE\n    -------\n\n    Returns the maximum mutation frequency of the haplotypes.\n\n\n    INPUT\n    -----\n\n    [INT LIST] [counts]\n        A haplotype counts, from the counts of the most abundant to the counts\n        of the least abundant haplotype.\n\n    [FLOAT LIST] [frequencies]\n        A list of (relative) frequencies of the Haplotypes.\n\n    [2D ARRAY] [distance_matrix]\n        A two dimensional array, representing the distance matrix of distances\n        between the sorted haplotypes.\n\n        This is expected to be calculated in a similar manner as:\n            haplotype.build_distiance_matrix(haplotypes)\n\n\n    RETURN\n    ------\n\n    [FLOAT] [maximum_mutation_frequency]\n        The maximum mutation frequency.\n\n    # ========================================================================\n    \"\"\"\n    H = len(counts)\n    F = frequencies\n    D = distance_matrix\n    maximum_mutation_frequency = calculate.maximum_mutation_frequency(H, F, D)\n    return maximum_mutation_frequency", "fn_id": 7, "class_fn": false, "repo": "phac-nml/quasitools", "file": "quasitools/commands/cmd_complexity.py", "last_update_at": "2021-03-15T07:28:20+00:00", "original_content": "def get_maximum_mutation_frequency(counts, distance_matrix, frequencies):\n    \"\"\"\n    # ========================================================================\n\n    GET MAXMIMUM MUTATION FREQUENCY\n\n    PURPOSE\n    -------\n\n    Returns the maximum mutation frequency of the haplotypes.\n\n\n    INPUT\n    -----\n\n    [INT LIST] [counts]\n        A haplotype counts, from the counts of the most abundant to the counts\n        of the least abundant haplotype.\n\n    [FLOAT LIST] [frequencies]\n        A list of (relative) frequencies of the Haplotypes.\n\n    [2D ARRAY] [distance_matrix]\n        A two dimensional array, representing the distance matrix of distances\n        between the sorted haplotypes.\n\n        This is expected to be calculated in a similar manner as:\n            haplotype.build_distiance_matrix(haplotypes)\n\n\n    RETURN\n    ------\n\n    [FLOAT] [maximum_mutation_frequency]\n        The maximum mutation frequency.\n\n    # ========================================================================\n    \"\"\"\n    H = len(counts)\n    F = frequencies\n    D = distance_matrix\n    maximum_mutation_frequency = calculate.maximum_mutation_frequency(H, F, D)\n    return maximum_mutation_frequency", "refactored": true, "pred": {"ppl": 7.009170055389404, "ppl_lower": 6.9424967765808105, "ppl/lowercase_ppl": -0.9950915524708972, "ppl/zlib": 0.00399020348290238, "Min_5.0% Prob": 9.778159538904825, "Min_10.0% Prob": 8.755908699035645, "Min_20.0% Prob": 7.199034765654919, "Min_30.0% Prob": 5.824742740706394, "Min_40.0% Prob": 4.696050413683349, "Min_50.0% Prob": 3.8731948210029152, "Min_60.0% Prob": 3.2401370014630113}}
{"hexsha": "e8db797381a8d4f3d0f04952d696026266dfabdc", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef add_zero(lst):\n    \"\"\" Add pulses for logical zero \"\"\"\n    pulse = 1875\n    space = 1875\n    lst.extend([pulse, space])\n    return lst", "fn_id": 2, "class_fn": false, "repo": "skbobade/UniversalRemote", "file": "src/irxm.py", "last_update_at": "2021-03-31T23:54:12+00:00", "original_content": "def add_zero(lst):\n    \"\"\" Add pulses for logical zero \"\"\"\n    pulse = 1875\n    space = 1875\n    lst.extend([pulse, space])\n    return lst", "refactored": true, "pred": {"ppl": 11.798600196838379, "ppl_lower": 12.32048225402832, "ppl/lowercase_ppl": -1.0175374956664305, "ppl/zlib": 0.018696824977638304, "Min_5.0% Prob": 14.32482624053955, "Min_10.0% Prob": 10.618812751770019, "Min_20.0% Prob": 8.349271106719971, "Min_30.0% Prob": 6.749330073595047, "Min_40.0% Prob": 5.752869361922855, "Min_50.0% Prob": 4.776007365297388, "Min_60.0% Prob": 4.127006574999541}}
{"hexsha": "6e0e15f18889c25b4f39d64ec87555d40f8d8c97", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef apply_mask_criteria(column):\n    \"\"\"Apply simple masking criteria to a single column, and return '-' if the\n    column does not meet the criteria, and 'I' if it does.\n    \"\"\"\n    mask_char = '-'\n    num_seqs = len(column)\n    half_num_seqs = num_seqs / 2\n    num_gaps_in_col = column.count('-')\n    column_no_gaps = column.replace('-', '')\n    if column_no_gaps == '':\n        return mask_char\n    elif not column_no_gaps == '':\n        most_common_residue = collections.Counter(column_no_gaps).most_common(1)[0]\n        most_common_residue_count = most_common_residue[1]\n        percent_identity = most_common_residue_count * 100 / num_seqs\n        if num_gaps_in_col < num_seqs * 0.3:\n            mask_char = 'I'\n        if percent_identity >= 50:\n            mask_char = 'I'\n        return mask_char", "fn_id": 0, "class_fn": false, "repo": "laelbarlow/amoebae", "file": "amoebaelib/mask_nex.py", "last_update_at": "2021-11-28T08:32:05+00:00", "original_content": "def apply_mask_criteria(column):\n    \"\"\"Apply simple masking criteria to a single column, and return '-' if the\n    column does not meet the criteria, and 'I' if it does.\n    \"\"\"\n    mask_char = '-'\n    num_seqs = len(column)\n    half_num_seqs = num_seqs / 2\n    num_gaps_in_col = column.count('-')\n    column_no_gaps = column.replace('-', '')\n    if column_no_gaps == '':\n        return mask_char\n    elif not column_no_gaps == '':\n        most_common_residue = collections.Counter(column_no_gaps).most_common(1)[0]\n        most_common_residue_count = most_common_residue[1]\n        percent_identity = most_common_residue_count * 100 / num_seqs\n        if num_gaps_in_col < num_seqs * 0.3:\n            mask_char = 'I'\n        if percent_identity >= 50:\n            mask_char = 'I'\n        return mask_char", "refactored": true, "pred": {"ppl": 3.3479604721069336, "ppl_lower": 3.61004900932312, "ppl/lowercase_ppl": -1.0623742443333717, "ppl/zlib": 0.003432816324255282, "Min_5.0% Prob": 9.86280087629954, "Min_10.0% Prob": 7.607013092041016, "Min_20.0% Prob": 5.222883289935542, "Min_30.0% Prob": 3.947179213166237, "Min_40.0% Prob": 3.011399840315183, "Min_50.0% Prob": 2.4124190732254647, "Min_60.0% Prob": 2.0215037893169114}}
{"hexsha": "d24a6419f9fcb2d3facd5e3d432818cfe2776fbb", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_activity_rawdata(cfg: DictConfig, id: int) -> pd.DataFrame:\n    \"\"\"query rawdata from strava api for a given id\n\n    Args:\n        cfg (DictConfig): configuration\n        id (int): activity id\n\n    Returns:\n        pd.DataFrame: activity rawdata\n    \"\"\"\n    with MySession(cfg) as session:\n        stream = session.get(cfg.api.BASE_URL + f'/activities/{id}/streams', params={'keys': ','.join(cfg.api.STREAMS)})\n    activity = dict()\n    found = list()\n    for values in stream.json():\n        activity[values['type']] = values['data']\n        found.append(values['type'])\n    res_df = pd.DataFrame(activity)\n    try:\n        res_df['lat'] = res_df['latlng'].apply(lambda x: x[0])\n        res_df['long'] = res_df['latlng'].apply(lambda x: x[-1])\n    except KeyError:\n        res_df['lat'], res_df['long'] = (np.nan, np.nan)\n    missings = set(cfg.api.STREAMS) - set(found)\n    if missings:\n        for missing in missings:\n            res_df[missing] = np.nan\n    res_df['id'] = id\n    if 'latlng' in res_df:\n        del res_df['latlng']\n    if cfg.TO_DB:\n        res_df['last_update'] = save_datetime_now()\n        with sqlite3.connect(call(cfg.DB)) as con:\n            res_df.to_sql('ACTIVITIES_RAW', con=con, if_exists='append', index=False, index_label='id')\n    time.sleep(cfg.api.SLEEP)\n    return res_df", "fn_id": 6, "class_fn": false, "repo": "Ektoplasmakugel/strava_datacollect", "file": "strava_datacollect/strava_query.py", "last_update_at": "2021-01-05T10:58:30+00:00", "original_content": "def get_activity_rawdata(cfg: DictConfig, id: int) -> pd.DataFrame:\n    \"\"\"query rawdata from strava api for a given id\n\n    Args:\n        cfg (DictConfig): configuration\n        id (int): activity id\n\n    Returns:\n        pd.DataFrame: activity rawdata\n    \"\"\"\n    with MySession(cfg) as session:\n        stream = session.get(cfg.api.BASE_URL + f'/activities/{id}/streams', params={'keys': ','.join(cfg.api.STREAMS)})\n    activity = dict()\n    found = list()\n    for values in stream.json():\n        activity[values['type']] = values['data']\n        found.append(values['type'])\n    res_df = pd.DataFrame(activity)\n    try:\n        res_df['lat'] = res_df['latlng'].apply(lambda x: x[0])\n        res_df['long'] = res_df['latlng'].apply(lambda x: x[-1])\n    except KeyError:\n        res_df['lat'], res_df['long'] = (np.nan, np.nan)\n    missings = set(cfg.api.STREAMS) - set(found)\n    if missings:\n        for missing in missings:\n            res_df[missing] = np.nan\n    res_df['id'] = id\n    if 'latlng' in res_df:\n        del res_df['latlng']\n    if cfg.TO_DB:\n        res_df['last_update'] = save_datetime_now()\n        with sqlite3.connect(call(cfg.DB)) as con:\n            res_df.to_sql('ACTIVITIES_RAW', con=con, if_exists='append', index=False, index_label='id')\n    time.sleep(cfg.api.SLEEP)\n    return res_df", "refactored": true, "pred": {"ppl": 3.357654094696045, "ppl_lower": 3.8144049644470215, "ppl/lowercase_ppl": -1.1052985932099277, "ppl/zlib": 0.00190147966095341, "Min_5.0% Prob": 10.323092126846314, "Min_10.0% Prob": 8.04357043708243, "Min_20.0% Prob": 5.472539987505936, "Min_30.0% Prob": 3.9695711794907487, "Min_40.0% Prob": 3.0232840569281, "Min_50.0% Prob": 2.4263843271245316, "Min_60.0% Prob": 2.0233398180197533}}
{"hexsha": "66ec3f6ee6f74fd6f9a9ebdb2510fc97b493104f", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_output_dir(output_dir):\n    if not output_dir or os.path.isfile(output_dir):\n        output_dir = '.'\n    elif not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    return output_dir", "fn_id": 0, "class_fn": false, "repo": "bjwuzh/autocase", "file": "axxac/path_tool.py", "last_update_at": "2021-07-02T09:46:23+00:00", "original_content": "def get_output_dir(output_dir):\n    if not output_dir or os.path.isfile(output_dir):\n        output_dir = '.'\n    elif not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    return output_dir", "refactored": true, "pred": {"ppl": 2.6899099349975586, "ppl_lower": 2.6899099349975586, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.007553493981982334, "Min_5.0% Prob": 7.10729964574178, "Min_10.0% Prob": 5.851149082183838, "Min_20.0% Prob": 4.519855252334049, "Min_30.0% Prob": 3.2587303803080605, "Min_40.0% Prob": 2.499137473691787, "Min_50.0% Prob": 2.0052110547465936, "Min_60.0% Prob": 1.6726447741190593}}
{"hexsha": "95f32217242b488480e02ece9bfc4b27508cb75d", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef minimal(input_size=2, output_size=2, weight_low=-2, weight_high=2, depth=3):\n    \"\"\" Builds a minimal genome with specified inputs and\n    outputs, weight bounds, depth and one connected node in\n    the first layer.\n\n    :param input_size: Number of input nodes\n    :param output_size: Number of output nodes\n    :param weight_low: Maximum weight on node and edges\n    :param weight_high: Minimum weight on node and edges\n    :param depth: Number of layers in network.\n    :return: Constructed genome.\n    \"\"\"\n    genome = Genome(input_size=input_size, output_size=output_size, weight_low=weight_low, weight_high=weight_high, depth=depth)\n    genome.layers = [genome.inputs, *[[] for _ in range(depth)], genome.outputs]\n    genome.add_node(1)\n    for n in genome.inputs:\n        genome.add_edge(n, genome.layers[1][0])\n    for n in genome.outputs:\n        genome.add_edge(genome.layers[1][0], n)\n    return genome", "fn_id": 1, "class_fn": false, "repo": "mauicv/genrl", "file": "src/gerel/genome/factories.py", "last_update_at": "2021-03-25T23:29:07+00:00", "original_content": "def minimal(input_size=2, output_size=2, weight_low=-2, weight_high=2, depth=3):\n    \"\"\" Builds a minimal genome with specified inputs and\n    outputs, weight bounds, depth and one connected node in\n    the first layer.\n\n    :param input_size: Number of input nodes\n    :param output_size: Number of output nodes\n    :param weight_low: Maximum weight on node and edges\n    :param weight_high: Minimum weight on node and edges\n    :param depth: Number of layers in network.\n    :return: Constructed genome.\n    \"\"\"\n    genome = Genome(input_size=input_size, output_size=output_size, weight_low=weight_low, weight_high=weight_high, depth=depth)\n    genome.layers = [genome.inputs, *[[] for _ in range(depth)], genome.outputs]\n    genome.add_node(1)\n    for n in genome.inputs:\n        genome.add_edge(n, genome.layers[1][0])\n    for n in genome.outputs:\n        genome.add_edge(genome.layers[1][0], n)\n    return genome", "refactored": true, "pred": {"ppl": 3.486327886581421, "ppl_lower": 3.789634943008423, "ppl/lowercase_ppl": -1.0667980616624582, "ppl/zlib": 0.0032522109395507807, "Min_5.0% Prob": 9.292919012216421, "Min_10.0% Prob": 7.55681272653433, "Min_20.0% Prob": 5.399705318304209, "Min_30.0% Prob": 4.027321010450773, "Min_40.0% Prob": 3.1168796624456134, "Min_50.0% Prob": 2.4946759713700777, "Min_60.0% Prob": 2.086505019553949}}
{"hexsha": "5d7651dffd876fa23e9cd979e7ddb5ed364b6b00", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef validate_bool(value):\n    \"\"\"Check that ``value`` is an boolean value.\"\"\"\n    if value not in (0, 1, False, True):\n        raise ValidationError(value, INVALID_BOOL)\n    return bool(value)", "fn_id": 4, "class_fn": false, "repo": "agarwalrounak/readthedocs.org", "file": "readthedocs/config/validation.py", "last_update_at": "2021-04-26T21:59:29+00:00", "original_content": "def validate_bool(value):\n    \"\"\"Check that ``value`` is an boolean value.\"\"\"\n    if value not in (0, 1, False, True):\n        raise ValidationError(value, INVALID_BOOL)\n    return bool(value)", "refactored": true, "pred": {"ppl": 7.666176795959473, "ppl_lower": 12.70820426940918, "ppl/lowercase_ppl": -1.24814674365184, "ppl/zlib": 0.012123916839526148, "Min_5.0% Prob": 10.66084655125936, "Min_10.0% Prob": 9.098783572514852, "Min_20.0% Prob": 7.292698582013448, "Min_30.0% Prob": 5.938454058435228, "Min_40.0% Prob": 4.860885481039683, "Min_50.0% Prob": 4.02335170507431, "Min_60.0% Prob": 3.3850197713408203}}
{"hexsha": "65836e5e8c8f2024ffb8b16e84f296ad241bb07d", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef run_async(factor, func, *args, **kwargs):\n    \"\"\"\n    Asynchronously executes a callable within a :class:`hiro.Timeline`\n\n    :param int factor: scale factor to use for the timeline during execution\n    :param function func: the function to invoke\n    :param args: the arguments to pass to the function\n    :param kwargs: the keyword arguments to pass to the function\n    :returns: an instance of :class:`hiro.core.ScaledAsyncRunner`\n\n    \"\"\"\n    return ScaledAsyncRunner(factor, func, *args, **kwargs)", "fn_id": 1, "class_fn": false, "repo": "alisaifee/hiro", "file": "hiro/core.py", "last_update_at": "2021-04-07T15:42:23+00:00", "original_content": "def run_async(factor, func, *args, **kwargs):\n    \"\"\"\n    Asynchronously executes a callable within a :class:`hiro.Timeline`\n\n    :param int factor: scale factor to use for the timeline during execution\n    :param function func: the function to invoke\n    :param args: the arguments to pass to the function\n    :param kwargs: the keyword arguments to pass to the function\n    :returns: an instance of :class:`hiro.core.ScaledAsyncRunner`\n\n    \"\"\"\n    return ScaledAsyncRunner(factor, func, *args, **kwargs)", "refactored": true, "pred": {"ppl": 5.35359001159668, "ppl_lower": 6.921132564544678, "ppl/lowercase_ppl": -1.1530677379682348, "ppl/zlib": 0.00633119760782189, "Min_5.0% Prob": 10.95465882619222, "Min_10.0% Prob": 9.019013514885536, "Min_20.0% Prob": 6.74324527153602, "Min_30.0% Prob": 5.2340415104841576, "Min_40.0% Prob": 4.136797749079191, "Min_50.0% Prob": 3.3629706922632, "Min_60.0% Prob": 2.814043205517989}}
{"hexsha": "f3817abe4aba076e3056537deae3e73cf43cce08", "ext": "py", "lang": "Python", "content": "@patch('inventory.readers._logger', autospec=True)\n@timeing\n@measure_memory_usage\ndef test_given_error_from_boto_then_account_is_skipped_but_others_still_processed(mock_logger):\n    os.environ['ACCOUNT_LIST'] = '[ { \"name\": \"foo\", \"id\": \"210987654321\" }, { \"name\": \"bar\", \"id\": \"123456789012\" } ]'\n    mock_mapper = Mock(spec=DataMapper)\n    mock_mapper.can_map.return_value = True\n    mock_mapper.map.return_value = [{'test': True}]\n    mock_select_resource_config = Mock(side_effect=[ClientError(error_response={'Error': {'Code': 'ResourceInUseException'}}, operation_name='select_resource_config'), {'NextToken': None, 'Results': [json.dumps({'resourceType': 'foobar'})]}])\n    mock_config_client_factory = Mock()\n    mock_config_client_factory.return_value.select_resource_config = mock_select_resource_config\n    reader = AwsConfigInventoryReader(lambda_context=MagicMock(), sts_client=Mock(), mappers=[mock_mapper])\n    reader._get_config_client = mock_config_client_factory\n    all_inventory = reader.get_resources_from_all_accounts()\n    assert len(all_inventory) == 1, 'inventory from the successful call should be returned'\n    assert len(mock_select_resource_config.mock_calls) == 2, 'boto should have been called twice to page through results'\n    mock_logger.error.assert_called_with(String() & Contains('moving onto next account'), ANY, ANY, exc_info=True)", "fn_id": 2, "class_fn": false, "repo": "Alpacked/fedramp-integrated-inventory-workbook", "file": "tests/test_inventory_reader.py", "last_update_at": "2021-12-15T22:29:08+00:00", "original_content": "@patch('inventory.readers._logger', autospec=True)\ndef test_given_error_from_boto_then_account_is_skipped_but_others_still_processed(mock_logger):\n    os.environ['ACCOUNT_LIST'] = '[ { \"name\": \"foo\", \"id\": \"210987654321\" }, { \"name\": \"bar\", \"id\": \"123456789012\" } ]'\n    mock_mapper = Mock(spec=DataMapper)\n    mock_mapper.can_map.return_value = True\n    mock_mapper.map.return_value = [{'test': True}]\n    mock_select_resource_config = Mock(side_effect=[ClientError(error_response={'Error': {'Code': 'ResourceInUseException'}}, operation_name='select_resource_config'), {'NextToken': None, 'Results': [json.dumps({'resourceType': 'foobar'})]}])\n    mock_config_client_factory = Mock()\n    mock_config_client_factory.return_value.select_resource_config = mock_select_resource_config\n    reader = AwsConfigInventoryReader(lambda_context=MagicMock(), sts_client=Mock(), mappers=[mock_mapper])\n    reader._get_config_client = mock_config_client_factory\n    all_inventory = reader.get_resources_from_all_accounts()\n    assert len(all_inventory) == 1, 'inventory from the successful call should be returned'\n    assert len(mock_select_resource_config.mock_calls) == 2, 'boto should have been called twice to page through results'\n    mock_logger.error.assert_called_with(String() & Contains('moving onto next account'), ANY, ANY, exc_info=True)", "refactored": true, "pred": {"ppl": 4.150192737579346, "ppl_lower": 5.713146686553955, "ppl/lowercase_ppl": -1.224582164064352, "ppl/zlib": 0.002059558286475221, "Min_5.0% Prob": 10.530564308166504, "Min_10.0% Prob": 8.554225049367766, "Min_20.0% Prob": 6.006103864530238, "Min_30.0% Prob": 4.558851711633729, "Min_40.0% Prob": 3.5382881936867063, "Min_50.0% Prob": 2.841219634016596, "Min_60.0% Prob": 2.373146580796131}}
{"hexsha": "640f81533781b97654cf6abb19ee0b856a6e367b", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef th_mdn_loss_dense(gt, mu, sigma, pi, mask, V, **kwargs):\n    C = 17\n    BS = gt.shape[0]\n    M = pi.shape[1]\n    H = gt.shape[2]\n    W = gt.shape[3]\n    gt = gt.permute(0, 2, 3, 1)\n    mu = mu.permute(0, 2, 3, 1)\n    sigma = sigma.permute(0, 2, 3, 1)\n    pi = pi.permute(0, 2, 3, 1)\n    mask = mask.permute(0, 2, 3, 1)\n    lmask = (torch.sum(mask, 3) > 0).float()\n    mask = torch.reshape(mask[:, :, :, np.repeat(np.arange(C), 2)], (BS, H, W, 1, C * 2))\n    mask = mask.repeat(1, 1, 1, M, 1)\n    gt = gt.reshape(BS, H, W, 1, 2 * C)\n    gt = gt.repeat(1, 1, 1, M, 1)\n    mu = mu.reshape(BS, H, W, M, 2 * C)\n    V = torch.reshape(V[np.repeat(np.arange(C), 2)], (1, 1, 1, 1, C * 2))\n    sigma = torch.reshape(sigma, (BS, H, W, M, 2))[:, :, :, :, np.concatenate([np.arange(2) for _ in np.arange(C)])]\n    e = 0.5 * ((gt - mu) * torch.reciprocal(sigma) * torch.reciprocal(V)) ** 2\n    e = torch.where(mask > 0.0, e, torch.zeros_like(e))\n    e = torch.sum(e, -1)\n    nviskps = torch.sum(mask[:, :, :, :, 0::2] > 0.0, -1).float().detach()\n    sigma_y = sigma[:, :, :, :, 0]\n    sigma_x = sigma[:, :, :, :, 1]\n    PI = torch.tensor(np.pi).cuda()\n    coef = -nviskps * torch.log(sigma_y) - nviskps * torch.log(sigma_x) - nviskps * torch.log(2 * PI)\n    exponent = torch.log(pi) + coef - e\n    loss = -torch.squeeze(log_sum_exp(exponent, 3), 3)\n    if kwargs.get('debug', False):\n        print('exponent.shape', exponent.shape)\n        print('loss.shape', loss.shape)\n    loss = torch.sum(lmask * loss) / (1.0 + torch.sum(lmask))\n    return loss", "fn_id": 4, "class_fn": false, "repo": "alivaramesh/MixtureDenseRegression", "file": "src/lib/models/losses.py", "last_update_at": "2021-11-30T01:22:48+00:00", "original_content": "def th_mdn_loss_dense(gt, mu, sigma, pi, mask, V, **kwargs):\n    C = 17\n    BS = gt.shape[0]\n    M = pi.shape[1]\n    H = gt.shape[2]\n    W = gt.shape[3]\n    gt = gt.permute(0, 2, 3, 1)\n    mu = mu.permute(0, 2, 3, 1)\n    sigma = sigma.permute(0, 2, 3, 1)\n    pi = pi.permute(0, 2, 3, 1)\n    mask = mask.permute(0, 2, 3, 1)\n    lmask = (torch.sum(mask, 3) > 0).float()\n    mask = torch.reshape(mask[:, :, :, np.repeat(np.arange(C), 2)], (BS, H, W, 1, C * 2))\n    mask = mask.repeat(1, 1, 1, M, 1)\n    gt = gt.reshape(BS, H, W, 1, 2 * C)\n    gt = gt.repeat(1, 1, 1, M, 1)\n    mu = mu.reshape(BS, H, W, M, 2 * C)\n    V = torch.reshape(V[np.repeat(np.arange(C), 2)], (1, 1, 1, 1, C * 2))\n    sigma = torch.reshape(sigma, (BS, H, W, M, 2))[:, :, :, :, np.concatenate([np.arange(2) for _ in np.arange(C)])]\n    e = 0.5 * ((gt - mu) * torch.reciprocal(sigma) * torch.reciprocal(V)) ** 2\n    e = torch.where(mask > 0.0, e, torch.zeros_like(e))\n    e = torch.sum(e, -1)\n    nviskps = torch.sum(mask[:, :, :, :, 0::2] > 0.0, -1).float().detach()\n    sigma_y = sigma[:, :, :, :, 0]\n    sigma_x = sigma[:, :, :, :, 1]\n    PI = torch.tensor(np.pi).cuda()\n    coef = -nviskps * torch.log(sigma_y) - nviskps * torch.log(sigma_x) - nviskps * torch.log(2 * PI)\n    exponent = torch.log(pi) + coef - e\n    loss = -torch.squeeze(log_sum_exp(exponent, 3), 3)\n    if kwargs.get('debug', False):\n        print('exponent.shape', exponent.shape)\n        print('loss.shape', loss.shape)\n    loss = torch.sum(lmask * loss) / (1.0 + torch.sum(lmask))\n    return loss", "refactored": true, "pred": {"ppl": 2.54262375831604, "ppl_lower": 2.5490357875823975, "ppl/lowercase_ppl": -1.0026989401379824, "ppl/zlib": 0.0015051556832147287, "Min_5.0% Prob": 8.305287072152803, "Min_10.0% Prob": 6.470055206498103, "Min_20.0% Prob": 4.276489139486242, "Min_30.0% Prob": 3.039578731864544, "Min_40.0% Prob": 2.3208641209725522, "Min_50.0% Prob": 1.8636089698590097, "Min_60.0% Prob": 1.5579852188164323}}
{"hexsha": "075a378bb5687e7c4ee731ece7a5af55df206c93", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef validate(model, dataset, opt, ctx):\n    \"\"\"Test on validation dataset.\"\"\"\n    detector = CenterDetector(opt)\n    detector.model = model\n    results = {}\n    num_iters = len(dataset)\n    bar = Bar('{}'.format(opt.exp_id), max=num_iters)\n    time_stats = ['tot', 'load', 'pre', 'net', 'dec', 'post', 'merge']\n    avg_time_stats = {t: AverageMeter() for t in time_stats}\n    print('Reporting every 1000 images...')\n    for ind in range(num_iters):\n        img_id = dataset.images[ind]\n        img_info = dataset.coco.loadImgs(ids=[img_id])[0]\n        img_path = os.path.join(dataset.img_dir, img_info['file_name'])\n        ret = detector.run(img_path)\n        results[img_id] = ret['results']\n        Bar.suffix = '[{0}/{1}]|Tot: {total:} |ETA: {eta:} '.format(ind, num_iters, total=bar.elapsed_td, eta=bar.eta_td)\n        for t in avg_time_stats:\n            avg_time_stats[t].update(ret[t])\n            Bar.suffix = Bar.suffix + '|{} {:.3f} '.format(t, avg_time_stats[t].avg)\n        if ind % 1000 == 0:\n            bar.next()\n    bar.finish()\n    val_dataset.run_eval(results=results, save_dir='./output/')", "fn_id": 3, "class_fn": false, "repo": "Guanghan/mxnet-centernet", "file": "train.py", "last_update_at": "2021-05-12T08:41:33+00:00", "original_content": "def validate(model, dataset, opt, ctx):\n    \"\"\"Test on validation dataset.\"\"\"\n    detector = CenterDetector(opt)\n    detector.model = model\n    results = {}\n    num_iters = len(dataset)\n    bar = Bar('{}'.format(opt.exp_id), max=num_iters)\n    time_stats = ['tot', 'load', 'pre', 'net', 'dec', 'post', 'merge']\n    avg_time_stats = {t: AverageMeter() for t in time_stats}\n    print('Reporting every 1000 images...')\n    for ind in range(num_iters):\n        img_id = dataset.images[ind]\n        img_info = dataset.coco.loadImgs(ids=[img_id])[0]\n        img_path = os.path.join(dataset.img_dir, img_info['file_name'])\n        ret = detector.run(img_path)\n        results[img_id] = ret['results']\n        Bar.suffix = '[{0}/{1}]|Tot: {total:} |ETA: {eta:} '.format(ind, num_iters, total=bar.elapsed_td, eta=bar.eta_td)\n        for t in avg_time_stats:\n            avg_time_stats[t].update(ret[t])\n            Bar.suffix = Bar.suffix + '|{} {:.3f} '.format(t, avg_time_stats[t].avg)\n        if ind % 1000 == 0:\n            bar.next()\n    bar.finish()\n    val_dataset.run_eval(results=results, save_dir='./output/')", "refactored": true, "pred": {"ppl": 1.8562273979187012, "ppl_lower": 2.376173734664917, "ppl/lowercase_ppl": -1.399235163407449, "ppl/zlib": 0.001100615920443645, "Min_5.0% Prob": 6.756286316447788, "Min_10.0% Prob": 4.776840538591952, "Min_20.0% Prob": 2.9513507183339143, "Min_30.0% Prob": 2.0410138792819805, "Min_40.0% Prob": 1.5459265250813317, "Min_50.0% Prob": 1.2394344905013772, "Min_60.0% Prob": 1.0335093543462053}}
{"hexsha": "2b63ae4e99c2f9a3f9a1f7f166698e9931cfc29c", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_roc_data(df_test, df_prob, encoding):\n    tprs = []\n    aucs = []\n    mean_fpr = np.linspace(0, 1, 100)\n    for i in range(df_test.shape[0]):\n        y_true = df_test.iloc[i, :].dropna().values\n        y_pred = df_prob.iloc[i, :].dropna().values\n        fpr, tpr, _ = roc_curve(y_true, y_pred)\n        interp_tpr = np.interp(mean_fpr, fpr, tpr)\n        interp_tpr[0] = 0.0\n        tprs.append(interp_tpr)\n        aucs.append(roc_auc_score(y_true, y_pred))\n    mean_tpr = np.mean(tprs, axis=0)\n    mean_tpr[-1] = 1.0\n    mean_auc = auc(mean_fpr, mean_tpr)\n    std_auc = np.std(aucs)\n    std_tpr = np.std(tprs, axis=0)\n    tprs_upper = np.minimum(mean_tpr + std_tpr, 1)\n    tprs_lower = np.maximum(mean_tpr - std_tpr, 0)\n    df = pd.DataFrame({'x': mean_fpr, 'y': mean_tpr, 'tprs_lower': tprs_lower, 'tprs_upper': tprs_upper})\n    df['Encoding'] = encoding\n    df['mean_auc'] = np.round(mean_auc, 2)\n    df['legend_label'] = df.apply(lambda row: f\"{row['Encoding']} (AUC: {row['mean_auc']})\", axis=1)\n    return df", "fn_id": 1, "class_fn": false, "repo": "spaenigs/peptidereactor", "file": "nodes/vis/sds_3_Curves/scripts/roc_pr_curve.py", "last_update_at": "2021-06-07T07:03:38+00:00", "original_content": "def get_roc_data(df_test, df_prob, encoding):\n    tprs = []\n    aucs = []\n    mean_fpr = np.linspace(0, 1, 100)\n    for i in range(df_test.shape[0]):\n        y_true = df_test.iloc[i, :].dropna().values\n        y_pred = df_prob.iloc[i, :].dropna().values\n        fpr, tpr, _ = roc_curve(y_true, y_pred)\n        interp_tpr = np.interp(mean_fpr, fpr, tpr)\n        interp_tpr[0] = 0.0\n        tprs.append(interp_tpr)\n        aucs.append(roc_auc_score(y_true, y_pred))\n    mean_tpr = np.mean(tprs, axis=0)\n    mean_tpr[-1] = 1.0\n    mean_auc = auc(mean_fpr, mean_tpr)\n    std_auc = np.std(aucs)\n    std_tpr = np.std(tprs, axis=0)\n    tprs_upper = np.minimum(mean_tpr + std_tpr, 1)\n    tprs_lower = np.maximum(mean_tpr - std_tpr, 0)\n    df = pd.DataFrame({'x': mean_fpr, 'y': mean_tpr, 'tprs_lower': tprs_lower, 'tprs_upper': tprs_upper})\n    df['Encoding'] = encoding\n    df['mean_auc'] = np.round(mean_auc, 2)\n    df['legend_label'] = df.apply(lambda row: f\"{row['Encoding']} (AUC: {row['mean_auc']})\", axis=1)\n    return df", "refactored": true, "pred": {"ppl": 1.5841678380966187, "ppl_lower": 1.6249667406082153, "ppl/lowercase_ppl": -1.0552713640522482, "ppl/zlib": 0.0009893747229534836, "Min_5.0% Prob": 6.138792798632667, "Min_10.0% Prob": 4.057818526313419, "Min_20.0% Prob": 2.2803786423589503, "Min_30.0% Prob": 1.5347300235566401, "Min_40.0% Prob": 1.1526454820649676, "Min_50.0% Prob": 0.9222735943250535, "Min_60.0% Prob": 0.7685848790620978}}
{"hexsha": "d7d0cc76bd9ced96d824215c265e0b8c9d95c87b", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_unique_changed_packages(diffs):\n    packages_changed = {}\n    for change in diffs:\n        if len(change) != 2:\n            logging.debug(change)\n            continue\n        change_type, path = change\n        path_tokens = path.split('/')\n        if path_tokens[-1] in IGNORE_CHANGES_FILES:\n            continue\n        try:\n            package = Package(package_dir=path_tokens[0])\n        except PackageDoesNotExistException:\n            continue\n        if package.package_name not in packages_changed:\n            packages_changed.update({package.package_name: package})\n    return packages_changed", "fn_id": 2, "class_fn": false, "repo": "r-kells/scream", "file": "scream/detect_changed_packages.py", "last_update_at": "2021-11-22T18:45:19+00:00", "original_content": "def get_unique_changed_packages(diffs):\n    packages_changed = {}\n    for change in diffs:\n        if len(change) != 2:\n            logging.debug(change)\n            continue\n        change_type, path = change\n        path_tokens = path.split('/')\n        if path_tokens[-1] in IGNORE_CHANGES_FILES:\n            continue\n        try:\n            package = Package(package_dir=path_tokens[0])\n        except PackageDoesNotExistException:\n            continue\n        if package.package_name not in packages_changed:\n            packages_changed.update({package.package_name: package})\n    return packages_changed", "refactored": true, "pred": {"ppl": 4.266097068786621, "ppl_lower": 5.571242809295654, "ppl/lowercase_ppl": -1.1839931729257749, "ppl/zlib": 0.0047877867123514006, "Min_5.0% Prob": 8.639249188559395, "Min_10.0% Prob": 7.1555867195129395, "Min_20.0% Prob": 5.688097156327347, "Min_30.0% Prob": 4.5430846796794375, "Min_40.0% Prob": 3.5658152300422477, "Min_50.0% Prob": 2.8865520744710356, "Min_60.0% Prob": 2.4360367183742877}}
{"hexsha": "bc24e936ef606bdcce7d65b0ddb291682889d4ea", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef tx_register(tx, cursor):\n    payload = json.loads(tx.payload)\n    owner = models.Account(tx.chain_id, tx.sender, cursor)\n    parcel = models.Parcel(tx.chain_id, payload['target'], owner.address, cursor)\n    storage = models.Storage(tx.chain_id, parcel.storage_id, None, cursor)\n    host = models.Account(tx.chain_id, storage.owner, cursor)\n    parcel.custody = payload['custody']\n    if parcel.custody != None and len(parcel.custody) > 100:\n        parcel.custody = parcel.custody[:100]\n    parcel.proxy_account = payload.get('proxy_account', None)\n    if parcel.proxy_account != None and len(parcel.proxy_account) > 40:\n        parcel.proxy_account = parcel.proxy_account[:40]\n    parcel.extra = payload.get('extra', '{}')\n    parcel.on_sale = True\n    parcel.save(cursor)\n    owner.balance -= storage.registration_fee\n    owner.save(cursor)\n    host.balance += storage.registration_fee\n    host.save(cursor)", "fn_id": 7, "class_fn": false, "repo": "MECTrace/edge-data-chain-explorer", "file": "crawler/tx.py", "last_update_at": "2021-12-17T08:52:58+00:00", "original_content": "def tx_register(tx, cursor):\n    payload = json.loads(tx.payload)\n    owner = models.Account(tx.chain_id, tx.sender, cursor)\n    parcel = models.Parcel(tx.chain_id, payload['target'], owner.address, cursor)\n    storage = models.Storage(tx.chain_id, parcel.storage_id, None, cursor)\n    host = models.Account(tx.chain_id, storage.owner, cursor)\n    parcel.custody = payload['custody']\n    if parcel.custody != None and len(parcel.custody) > 100:\n        parcel.custody = parcel.custody[:100]\n    parcel.proxy_account = payload.get('proxy_account', None)\n    if parcel.proxy_account != None and len(parcel.proxy_account) > 40:\n        parcel.proxy_account = parcel.proxy_account[:40]\n    parcel.extra = payload.get('extra', '{}')\n    parcel.on_sale = True\n    parcel.save(cursor)\n    owner.balance -= storage.registration_fee\n    owner.save(cursor)\n    host.balance += storage.registration_fee\n    host.save(cursor)", "refactored": true, "pred": {"ppl": 3.0769901275634766, "ppl_lower": 3.1882638931274414, "ppl/lowercase_ppl": -1.031606910427814, "ppl/zlib": 0.003139530413053349, "Min_5.0% Prob": 9.368507964270455, "Min_10.0% Prob": 7.3955157824925015, "Min_20.0% Prob": 4.997790711266654, "Min_30.0% Prob": 3.6087074304620423, "Min_40.0% Prob": 2.7791809272021055, "Min_50.0% Prob": 2.2412912646840724, "Min_60.0% Prob": 1.8721905786632782}}
{"hexsha": "a6ecbbb0e40168d4238d3a4dc7a1087809d1ed3f", "ext": "py", "lang": "Python", "content": "@box.cron('0 3 * * *')\n@timeing\n@measure_memory_usage\nasync def refresh_db(bot):\n    logger.info('refresh subway')\n    tasks = []\n    for service_region, api_version in REGION_TABLE.values():\n        tasks.append(fetch_station_db(bot, service_region, api_version))\n    await asyncio.wait(tasks)", "fn_id": 2, "class_fn": false, "repo": "item4/yui", "file": "yui/apps/search/subway.py", "last_update_at": "2021-01-31T17:57:41+00:00", "original_content": "@box.cron('0 3 * * *')\nasync def refresh_db(bot):\n    logger.info('refresh subway')\n    tasks = []\n    for service_region, api_version in REGION_TABLE.values():\n        tasks.append(fetch_station_db(bot, service_region, api_version))\n    await asyncio.wait(tasks)", "refactored": true, "pred": {"ppl": 8.561776161193848, "ppl_lower": 8.654873847961426, "ppl/lowercase_ppl": -1.0050365157174626, "ppl/zlib": 0.010323594538923148, "Min_5.0% Prob": 10.852829694747925, "Min_10.0% Prob": 9.368111252784729, "Min_20.0% Prob": 7.495062042685116, "Min_30.0% Prob": 6.311306770031269, "Min_40.0% Prob": 5.300328533990043, "Min_50.0% Prob": 4.311081534420902, "Min_60.0% Prob": 3.5967814204687216}}
{"hexsha": "70836ca1748caea3d326c0101f9ea4804dc8b95e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef save_3D_animation(embeddings, emb_space_sizes, train_losses, test_losses, opt_name, n_bins=10, horizon_size=10, cmap_name='jet', **plotting_kwargs):\n    \"\"\"Utility function for visualizing the changes in weights over time in\n    UMAP space. The visualization is in 3D for better appreciating the descent\n    on the error surface.\n\n        Args:\n            - embeddings: list of embeddings, result of alligned UMAP\n            - emb_space_sizes: list of arrays, define the limits of the\n                embedding space for the three layers of the MLP.\n            - train_losses: list, training losses history.\n            - test_losses: list, test losses.\n            - opt_name: string, name of the optimizer used.\n            - n_bins: int, number of bins for discretizing the training loss.\n            -  horizon_size: int, maximum number of points simultaneously\n                on screen.\n            - cmap_name: string, name of the colormap used for representing\n                the change in train losses.\n            - **plotting_kwargs: keyword arguments, keyword arguments for the\n                plotting function.\n\n        Returns:\n            - None\n    \"\"\"\n    discretizer = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy='uniform')\n    cmap = matplotlib.cm.get_cmap(cmap_name)\n    colors = np.array(train_losses)\n    colors = discretizer.fit_transform(colors.reshape(-1, 1)).flatten()\n    norm = plt.Normalize(colors.min(), colors.max())\n    for i in tqdm(range(embeddings[0].shape[0])):\n        fig, axs = plt.subplots(1, 3, figsize=(30, 10), subplot_kw=dict(projection='3d'))\n        for index, emb in enumerate(embeddings):\n            min_sizes, max_sizes = emb_space_sizes[index]\n            past_horizon = max(0, i - horizon_size)\n            axs[index].scatter(emb[past_horizon:i, 0], emb[past_horizon:i, 1], train_losses[past_horizon:i], c=[cmap(norm(color)) for color in colors[past_horizon:i]], **plotting_kwargs)\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=train_losses[past_horizon:i], c='grey', zdir='y', zs=max_sizes[1], linewidth=5, alpha=0.25)\n            axs[index].plot(xs=emb[past_horizon:i, 1], ys=train_losses[past_horizon:i], c='grey', zdir='x', linewidth=5, alpha=0.25, zs=min_sizes[0])\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=emb[past_horizon:i, 1], c='grey', zdir='z', linewidth=5, alpha=0.25, zs=min_sizes[2])\n            axs[index].text2D(0.05, 0.95, f'Layer {index + 1}', transform=axs[index].transAxes)\n            if index == 1:\n                axs[index].text2D(0.5, 1.1, f'Optimizer: {opt_name}                     \\nTrain Loss: {round(train_losses[i], 3)}                     \\n Test Loss: {round(test_losses[i], 3)}', transform=axs[index].transAxes)\n            elif index == 2:\n                axs[index].set_xlabel('Weights Space \\n UMAP 1')\n                axs[index].set_ylabel('Weights Space \\n UMAP 2')\n                axs[index].set_zlabel('Trainining Loss')\n        if not os.path.exists(f'results\\\\3D_{opt_name}'):\n            os.makedirs(f'results\\\\3D_{opt_name}')\n        plt.savefig(f'results\\\\3D_{opt_name}\\\\{i}.png', bbox_inches='tight')\n        plt.close('all')\n    return None", "fn_id": 0, "class_fn": false, "repo": "vb690/machine_learning_exercises", "file": "shops/visualize_gradient_descent/utilities/viz_utils.py", "last_update_at": "2021-04-26T19:06:06+00:00", "original_content": "def save_3D_animation(embeddings, emb_space_sizes, train_losses, test_losses, opt_name, n_bins=10, horizon_size=10, cmap_name='jet', **plotting_kwargs):\n    \"\"\"Utility function for visualizing the changes in weights over time in\n    UMAP space. The visualization is in 3D for better appreciating the descent\n    on the error surface.\n\n        Args:\n            - embeddings: list of embeddings, result of alligned UMAP\n            - emb_space_sizes: list of arrays, define the limits of the\n                embedding space for the three layers of the MLP.\n            - train_losses: list, training losses history.\n            - test_losses: list, test losses.\n            - opt_name: string, name of the optimizer used.\n            - n_bins: int, number of bins for discretizing the training loss.\n            -  horizon_size: int, maximum number of points simultaneously\n                on screen.\n            - cmap_name: string, name of the colormap used for representing\n                the change in train losses.\n            - **plotting_kwargs: keyword arguments, keyword arguments for the\n                plotting function.\n\n        Returns:\n            - None\n    \"\"\"\n    discretizer = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy='uniform')\n    cmap = matplotlib.cm.get_cmap(cmap_name)\n    colors = np.array(train_losses)\n    colors = discretizer.fit_transform(colors.reshape(-1, 1)).flatten()\n    norm = plt.Normalize(colors.min(), colors.max())\n    for i in tqdm(range(embeddings[0].shape[0])):\n        fig, axs = plt.subplots(1, 3, figsize=(30, 10), subplot_kw=dict(projection='3d'))\n        for index, emb in enumerate(embeddings):\n            min_sizes, max_sizes = emb_space_sizes[index]\n            past_horizon = max(0, i - horizon_size)\n            axs[index].scatter(emb[past_horizon:i, 0], emb[past_horizon:i, 1], train_losses[past_horizon:i], c=[cmap(norm(color)) for color in colors[past_horizon:i]], **plotting_kwargs)\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=train_losses[past_horizon:i], c='grey', zdir='y', zs=max_sizes[1], linewidth=5, alpha=0.25)\n            axs[index].plot(xs=emb[past_horizon:i, 1], ys=train_losses[past_horizon:i], c='grey', zdir='x', linewidth=5, alpha=0.25, zs=min_sizes[0])\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=emb[past_horizon:i, 1], c='grey', zdir='z', linewidth=5, alpha=0.25, zs=min_sizes[2])\n            axs[index].text2D(0.05, 0.95, f'Layer {index + 1}', transform=axs[index].transAxes)\n            if index == 1:\n                axs[index].text2D(0.5, 1.1, f'Optimizer: {opt_name}                     \\nTrain Loss: {round(train_losses[i], 3)}                     \\n Test Loss: {round(test_losses[i], 3)}', transform=axs[index].transAxes)\n            elif index == 2:\n                axs[index].set_xlabel('Weights Space \\n UMAP 1')\n                axs[index].set_ylabel('Weights Space \\n UMAP 2')\n                axs[index].set_zlabel('Trainining Loss')\n        if not os.path.exists(f'results\\\\3D_{opt_name}'):\n            os.makedirs(f'results\\\\3D_{opt_name}')\n        plt.savefig(f'results\\\\3D_{opt_name}\\\\{i}.png', bbox_inches='tight')\n        plt.close('all')\n    return None", "refactored": true, "pred": {"ppl": 2.81864595413208, "ppl_lower": 3.1452431678771973, "ppl/lowercase_ppl": -1.1057986924239271, "ppl/zlib": 0.0008693427949060504, "Min_5.0% Prob": 9.60594097773234, "Min_10.0% Prob": 7.27681890130043, "Min_20.0% Prob": 4.791944081301517, "Min_30.0% Prob": 3.39092080949912, "Min_40.0% Prob": 2.581112861034938, "Min_50.0% Prob": 2.070507742244727, "Min_60.0% Prob": 1.728562579165729}}
{"hexsha": "2096e74d026f92b88f279c71ae6c465be2f77b95", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef is_accuracy_aware_training(config: NNCFConfig, compression_config_passed: bool=False) -> bool:\n    \"\"\"\n    Returns True if the compression config contains an accuracy-aware\n    training related section, False otherwise.\n    \"\"\"\n    compression_config = config.get('compression', {}) if not compression_config_passed else config\n    if isinstance(compression_config, list):\n        for algo_config in compression_config:\n            if algo_config.get('accuracy_aware_training') is not None:\n                return True\n        return False\n    if compression_config.get('accuracy_aware_training') is not None:\n        return True\n    return False", "fn_id": 0, "class_fn": false, "repo": "sarthakpati/nncf", "file": "nncf/config/utils.py", "last_update_at": "2021-07-23T07:46:52+00:00", "original_content": "def is_accuracy_aware_training(config: NNCFConfig, compression_config_passed: bool=False) -> bool:\n    \"\"\"\n    Returns True if the compression config contains an accuracy-aware\n    training related section, False otherwise.\n    \"\"\"\n    compression_config = config.get('compression', {}) if not compression_config_passed else config\n    if isinstance(compression_config, list):\n        for algo_config in compression_config:\n            if algo_config.get('accuracy_aware_training') is not None:\n                return True\n        return False\n    if compression_config.get('accuracy_aware_training') is not None:\n        return True\n    return False", "refactored": true, "pred": {"ppl": 3.0038702487945557, "ppl_lower": 4.1694512367248535, "ppl/lowercase_ppl": -1.29810203651373, "ppl/zlib": 0.0037927639315781117, "Min_5.0% Prob": 8.46659551348005, "Min_10.0% Prob": 6.686157178878784, "Min_20.0% Prob": 4.741484765211741, "Min_30.0% Prob": 3.5302209787898593, "Min_40.0% Prob": 2.7444659086565175, "Min_50.0% Prob": 2.2096701486905417, "Min_60.0% Prob": 1.844493861693061}}
{"hexsha": "f4d5118418f49eeb3e5a0e0d7756f5a28b10fda6", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef decoder_layer(input_prob, input_aspect, n_hidden, n_class, n_aspects, random_base, l2_reg, sub_vocab, FLAGS, scope_name='1', use_aspect=True):\n    \"\"\"\n    Decoder structure of the autoencoder-like model taht reconstructs the sentence using the sentimenet embedding matrix\n\n    :param input_prob:\n    :param input_aspect:\n    :param n_hidden:\n    :param n_class:\n    :param n_aspects:\n    :param random_base:\n    :param l2_reg:\n    :param sub_vocab:\n    :param FLAGS:\n    :param scope_name:\n    :param use_aspect:\n    :return:\n    \"\"\"\n    w = tf.get_variable(name='sentiment_embedding' + scope_name, shape=[n_class, n_hidden], initializer=tf.random_uniform_initializer(-random_base, random_base), regularizer=tf.keras.regularizers.L2(l2_reg), trainable=True)\n    if use_aspect:\n        w_aspect = tf.get_variable(name='aspect_w' + scope_name, shape=[n_aspects, n_hidden], initializer=tf.random_uniform_initializer(-random_base, random_base), regularizer=tf.keras.regularizers.L2(l2_reg), trainable=True)\n    batch_size = tf.shape(input_prob)[0]\n    if use_aspect:\n        outputs = tf.matmul(input_prob, w) + tf.matmul(input_aspect, w_aspect)\n    else:\n        outputs = tf.matmul(input_prob, w)\n    return (outputs, w)", "fn_id": 3, "class_fn": false, "repo": "LucaZampierin/ABSE", "file": "nn_layer.py", "last_update_at": "2021-10-17T13:53:20+00:00", "original_content": "def decoder_layer(input_prob, input_aspect, n_hidden, n_class, n_aspects, random_base, l2_reg, sub_vocab, FLAGS, scope_name='1', use_aspect=True):\n    \"\"\"\n    Decoder structure of the autoencoder-like model taht reconstructs the sentence using the sentimenet embedding matrix\n\n    :param input_prob:\n    :param input_aspect:\n    :param n_hidden:\n    :param n_class:\n    :param n_aspects:\n    :param random_base:\n    :param l2_reg:\n    :param sub_vocab:\n    :param FLAGS:\n    :param scope_name:\n    :param use_aspect:\n    :return:\n    \"\"\"\n    w = tf.get_variable(name='sentiment_embedding' + scope_name, shape=[n_class, n_hidden], initializer=tf.random_uniform_initializer(-random_base, random_base), regularizer=tf.keras.regularizers.L2(l2_reg), trainable=True)\n    if use_aspect:\n        w_aspect = tf.get_variable(name='aspect_w' + scope_name, shape=[n_aspects, n_hidden], initializer=tf.random_uniform_initializer(-random_base, random_base), regularizer=tf.keras.regularizers.L2(l2_reg), trainable=True)\n    batch_size = tf.shape(input_prob)[0]\n    if use_aspect:\n        outputs = tf.matmul(input_prob, w) + tf.matmul(input_aspect, w_aspect)\n    else:\n        outputs = tf.matmul(input_prob, w)\n    return (outputs, w)", "refactored": true, "pred": {"ppl": 2.730839490890503, "ppl_lower": 2.8638601303100586, "ppl/lowercase_ppl": -1.0473431352584643, "ppl/zlib": 0.002179195374723082, "Min_5.0% Prob": 9.138273766166286, "Min_10.0% Prob": 7.187607612365332, "Min_20.0% Prob": 4.721252649258345, "Min_30.0% Prob": 3.3301532902778725, "Min_40.0% Prob": 2.5191360412117763, "Min_50.0% Prob": 2.008285842156418, "Min_60.0% Prob": 1.6756174801650674}}
{"hexsha": "c4ee4862ccbeff5f750d6e6bb757e31dbab056f4", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef solve_format_ArithOperation(optree, integer_size_func=lambda lhs_prec, rhs_prec: None, frac_size_func=lambda lhs_prec, rhs_prec: None, signed_func=lambda lhs, lhs_prec, rhs, rhs_prec: False, format_solver=None):\n    \"\"\" determining fixed-point format for a generic 2-op arithmetic\n        operation (e.g. Multiplication, Addition, Subtraction)\n    \"\"\"\n    lhs = optree.get_input(0)\n    rhs = optree.get_input(1)\n    lhs_precision = lhs.get_precision()\n    rhs_precision = rhs.get_precision()\n    abstract_operation = lhs_precision is ML_Integer and rhs_precision is ML_Integer\n    if abstract_operation:\n        return ML_Integer\n    if lhs_precision is ML_Integer:\n        cst_eval = evaluate_cst_graph(lhs, input_prec_solver=format_solver)\n        lhs_precision = solve_format_Constant(Constant(cst_eval))\n    if rhs_precision is ML_Integer:\n        cst_eval = evaluate_cst_graph(rhs, input_prec_solver=format_solver)\n        rhs_precision = solve_format_Constant(Constant(cst_eval))\n    if is_fixed_point(lhs_precision) and is_fixed_point(rhs_precision):\n        int_size = integer_size_func(lhs_precision, rhs_precision)\n        frac_size = frac_size_func(lhs_precision, rhs_precision)\n        is_signed = signed_func(lhs, lhs_precision, rhs, rhs_precision)\n        return fixed_point(int_size, frac_size, signed=is_signed)\n    else:\n        return optree.get_precision()", "fn_id": 3, "class_fn": false, "repo": "nibrunie/metalibm", "file": "metalibm_core/opt/p_size_datapath.py", "last_update_at": "2021-03-12T18:54:53+00:00", "original_content": "def solve_format_ArithOperation(optree, integer_size_func=lambda lhs_prec, rhs_prec: None, frac_size_func=lambda lhs_prec, rhs_prec: None, signed_func=lambda lhs, lhs_prec, rhs, rhs_prec: False, format_solver=None):\n    \"\"\" determining fixed-point format for a generic 2-op arithmetic\n        operation (e.g. Multiplication, Addition, Subtraction)\n    \"\"\"\n    lhs = optree.get_input(0)\n    rhs = optree.get_input(1)\n    lhs_precision = lhs.get_precision()\n    rhs_precision = rhs.get_precision()\n    abstract_operation = lhs_precision is ML_Integer and rhs_precision is ML_Integer\n    if abstract_operation:\n        return ML_Integer\n    if lhs_precision is ML_Integer:\n        cst_eval = evaluate_cst_graph(lhs, input_prec_solver=format_solver)\n        lhs_precision = solve_format_Constant(Constant(cst_eval))\n    if rhs_precision is ML_Integer:\n        cst_eval = evaluate_cst_graph(rhs, input_prec_solver=format_solver)\n        rhs_precision = solve_format_Constant(Constant(cst_eval))\n    if is_fixed_point(lhs_precision) and is_fixed_point(rhs_precision):\n        int_size = integer_size_func(lhs_precision, rhs_precision)\n        frac_size = frac_size_func(lhs_precision, rhs_precision)\n        is_signed = signed_func(lhs, lhs_precision, rhs, rhs_precision)\n        return fixed_point(int_size, frac_size, signed=is_signed)\n    else:\n        return optree.get_precision()", "refactored": true, "pred": {"ppl": 3.0248920917510986, "ppl_lower": 3.206130027770996, "ppl/lowercase_ppl": -1.0525706789731546, "ppl/zlib": 0.002380377244512132, "Min_5.0% Prob": 10.768845438957214, "Min_10.0% Prob": 8.172159600257874, "Min_20.0% Prob": 5.181918036790542, "Min_30.0% Prob": 3.6483250008743315, "Min_40.0% Prob": 2.7759565625247764, "Min_50.0% Prob": 2.2186699132366208, "Min_60.0% Prob": 1.8462582591357621}}
{"hexsha": "bc8a29dc53319c769a4b51f92593b8f3fdee45c6", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef update_df_all(df_all, training_data, validation_data, test_data):\n    \"\"\"Add a column \"group\" to df_all indicating train/validation or test\"\"\"\n    df_all['group'] = 0\n    for simu_name in training_data:\n        df_all['group'][df_all['topo_name'] == simu_name] = 'train'\n    for simu_name in validation_data:\n        df_all['group'][df_all['topo_name'] == simu_name] = 'validation'\n    for simu_name in test_data:\n        df_all['group'][df_all['topo_name'] == simu_name] = 'test'\n    return df_all", "fn_id": 1, "class_fn": false, "repo": "louisletoumelin/wind_downscaling_cnn", "file": "pre_process/preprocess_folds.py", "last_update_at": "2021-12-13T16:26:31+00:00", "original_content": "def update_df_all(df_all, training_data, validation_data, test_data):\n    \"\"\"Add a column \"group\" to df_all indicating train/validation or test\"\"\"\n    df_all['group'] = 0\n    for simu_name in training_data:\n        df_all['group'][df_all['topo_name'] == simu_name] = 'train'\n    for simu_name in validation_data:\n        df_all['group'][df_all['topo_name'] == simu_name] = 'validation'\n    for simu_name in test_data:\n        df_all['group'][df_all['topo_name'] == simu_name] = 'test'\n    return df_all", "refactored": true, "pred": {"ppl": 2.7517762184143066, "ppl_lower": 2.7692978382110596, "ppl/lowercase_ppl": -1.0062704080890785, "ppl/zlib": 0.004866570196065385, "Min_5.0% Prob": 9.903834700584412, "Min_10.0% Prob": 7.604919770184686, "Min_20.0% Prob": 4.839240734917777, "Min_30.0% Prob": 3.3800457690197687, "Min_40.0% Prob": 2.5293591515294143, "Min_50.0% Prob": 2.0360615112779974, "Min_60.0% Prob": 1.6870748470978774}}
{"hexsha": "6bef08836876832f7516142a645d88720de907e9", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef update_image_metadata_from_image_path(image_path: str, metadata: Dict):\n    \"\"\" \"\"\"\n    pickled = codecs.encode(pickle.dumps(metadata), 'base64').decode()\n    db = get_db()\n    cur = db.cursor()\n    cur.execute(f'UPDATE images SET metadata = \"{pickled}\" WHERE path = \"{image_path}\" AND metadata IS NULL')\n    db.commit()", "fn_id": 0, "class_fn": false, "repo": "frederikgram/describe", "file": "dev/frontend/models/database_updaters.py", "last_update_at": "2021-03-10T01:32:19+00:00", "original_content": "def update_image_metadata_from_image_path(image_path: str, metadata: Dict):\n    \"\"\" \"\"\"\n    pickled = codecs.encode(pickle.dumps(metadata), 'base64').decode()\n    db = get_db()\n    cur = db.cursor()\n    cur.execute(f'UPDATE images SET metadata = \"{pickled}\" WHERE path = \"{image_path}\" AND metadata IS NULL')\n    db.commit()", "refactored": true, "pred": {"ppl": 3.7800893783569336, "ppl_lower": 3.874465227127075, "ppl/lowercase_ppl": -1.018544866672285, "ppl/zlib": 0.005707071478197116, "Min_5.0% Prob": 10.052384376525879, "Min_10.0% Prob": 8.101202869415284, "Min_20.0% Prob": 5.591695671989804, "Min_30.0% Prob": 4.213484041152462, "Min_40.0% Prob": 3.2480110831203914, "Min_50.0% Prob": 2.6609463296257534, "Min_60.0% Prob": 2.2115373720252323}}
{"hexsha": "6c468eb327991e8438e939f0e8280fc938e87e2b", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef float_sanitiser():\n\n    def sanitise(n, debug_name):\n        if not isinstance(n, float):\n            raise CefTypeError('{}: Expected float, got {}'.format(debug_name, type(n)))\n        else:\n            return str(n)\n    return sanitise", "fn_id": 3, "class_fn": false, "repo": "slallum/format_cef", "file": "src/format_cef/_cef/base.py", "last_update_at": "2021-04-28T08:58:00+00:00", "original_content": "def float_sanitiser():\n\n    def sanitise(n, debug_name):\n        if not isinstance(n, float):\n            raise CefTypeError('{}: Expected float, got {}'.format(debug_name, type(n)))\n        else:\n            return str(n)\n    return sanitise", "refactored": true, "pred": {"ppl": 8.655948638916016, "ppl_lower": 9.488432884216309, "ppl/lowercase_ppl": -1.0425468846238466, "ppl/zlib": 0.012403717175314546, "Min_5.0% Prob": 10.504427909851074, "Min_10.0% Prob": 9.026430674961635, "Min_20.0% Prob": 7.629647220884051, "Min_30.0% Prob": 6.506483271008446, "Min_40.0% Prob": 5.303998193570545, "Min_50.0% Prob": 4.337404608300754, "Min_60.0% Prob": 3.637787391919465}}
{"hexsha": "22b492bfb5e030f558182e6d784c2ccfc5064429", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef hive_copy_to_table(source_dataset, source_table_name, destination_dataset, destination_table_name, s3_step_path, local_step_path, action_id, set_hive_vars, step_num, steps_total):\n    hive_source_path = os.path.join(local_step_path, 'hive', 'copy_to_table.hql')\n    hive_target_path = os.path.join(local_step_path, 'hive', 'copy_to_table_%s.hql' % destination_table_name)\n    with open(hive_source_path, 'r') as s, open(hive_target_path, 'w') as t:\n        contents = s.read().format(source_table_name=source_table_name, destination_table_name=destination_table_name, partitions=get_partitions(source_dataset), columns=get_columns(source_dataset, destination_dataset), compression=get_emr_compression(destination_dataset), set_hive_vars=set_hive_vars if set_hive_vars else '')\n        t.write(contents)\n    return StepWrapper(JarStep(name='dart: (%s) copy_to_table_%s.hql (from %s)' % (_title_data(action_id, step_num, steps_total), destination_table_name, source_table_name), jar=_command_runner_jar, action_on_failure='CONTINUE', step_args=_hive_args + [s3_step_path + '/hive/copy_to_table_%s.hql' % destination_table_name]), step_num, steps_total)", "fn_id": 4, "class_fn": false, "repo": "RetailMeNotSandbox/dart", "file": "src/python/dart/engine/emr/steps.py", "last_update_at": "2021-07-14T22:37:35+00:00", "original_content": "def hive_copy_to_table(source_dataset, source_table_name, destination_dataset, destination_table_name, s3_step_path, local_step_path, action_id, set_hive_vars, step_num, steps_total):\n    hive_source_path = os.path.join(local_step_path, 'hive', 'copy_to_table.hql')\n    hive_target_path = os.path.join(local_step_path, 'hive', 'copy_to_table_%s.hql' % destination_table_name)\n    with open(hive_source_path, 'r') as s, open(hive_target_path, 'w') as t:\n        contents = s.read().format(source_table_name=source_table_name, destination_table_name=destination_table_name, partitions=get_partitions(source_dataset), columns=get_columns(source_dataset, destination_dataset), compression=get_emr_compression(destination_dataset), set_hive_vars=set_hive_vars if set_hive_vars else '')\n        t.write(contents)\n    return StepWrapper(JarStep(name='dart: (%s) copy_to_table_%s.hql (from %s)' % (_title_data(action_id, step_num, steps_total), destination_table_name, source_table_name), jar=_command_runner_jar, action_on_failure='CONTINUE', step_args=_hive_args + [s3_step_path + '/hive/copy_to_table_%s.hql' % destination_table_name]), step_num, steps_total)", "refactored": true, "pred": {"ppl": 3.73341703414917, "ppl_lower": 3.894709587097168, "ppl/lowercase_ppl": -1.0321069150616586, "ppl/zlib": 0.002895217382951654, "Min_5.0% Prob": 10.77807913328472, "Min_10.0% Prob": 8.32766403296055, "Min_20.0% Prob": 5.8158467060480366, "Min_30.0% Prob": 4.288606648771172, "Min_40.0% Prob": 3.2815397433509492, "Min_50.0% Prob": 2.6394314798526466, "Min_60.0% Prob": 2.2028496998084828}}
{"hexsha": "1a8166a42e84641b39cb8babc256e3c8ddcff393", "ext": "py", "lang": "Python", "content": "def check_post_status(func):\n    \"\"\"\n     call the func only if the smc.setting is not already posted via API\n    Args:\n        func:write_file\n\n    Returns:\n        wrapper: confirmation if the smc.settings file has been posted already\n    \"\"\"\n\n    @timeing\n    @measure_memory_usage\n    def wrapper(*args, **kwargs):\n        if os.environ.get('stealth_watch_post', '0') == '0':\n            func(*args, **kwargs)\n        else:\n            print(f'{Style.RED}smc.setting file data is already posted to smc server from this machine, so skipping the operation for function {func.__qualname__}{Style.RESET}')\n            print(f'{Style.GREEN}Thank you!{Style.RESET}')\n    return wrapper", "fn_id": 2, "class_fn": false, "repo": "CiscoDevNet/sna-initial-config-setup-script", "file": "utils/misc.py", "last_update_at": "2021-12-23T20:16:15+00:00", "original_content": "def check_post_status(func):\n    \"\"\"\n     call the func only if the smc.setting is not already posted via API\n    Args:\n        func:write_file\n\n    Returns:\n        wrapper: confirmation if the smc.settings file has been posted already\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        if os.environ.get('stealth_watch_post', '0') == '0':\n            func(*args, **kwargs)\n        else:\n            print(f'{Style.RED}smc.setting file data is already posted to smc server from this machine, so skipping the operation for function {func.__qualname__}{Style.RESET}')\n            print(f'{Style.GREEN}Thank you!{Style.RESET}')\n    return wrapper", "refactored": true, "pred": {"ppl": 12.774040222167969, "ppl_lower": 12.96838092803955, "ppl/lowercase_ppl": -1.0059272456804078, "ppl/zlib": 0.006998392867822024, "Min_5.0% Prob": 14.479835629463196, "Min_10.0% Prob": 12.145418279311237, "Min_20.0% Prob": 9.12184092577766, "Min_30.0% Prob": 7.246200799942017, "Min_40.0% Prob": 6.039666775394888, "Min_50.0% Prob": 5.00401617274728, "Min_60.0% Prob": 4.241793777468135}}
{"hexsha": "1380364880e72805de31c21c228ab7d9dbd45947", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef update_activity_notice_seed_date_of_notice_earlier_than_update_window(activity_notice_seed):\n    status = ''\n    success = True\n    activity_notice_seed_changed = False\n    from activity.models import get_lifespan_of_seed\n    lifespan_of_seed_in_seconds = get_lifespan_of_seed(activity_notice_seed.kind_of_seed)\n    earliest_date_of_notice = now() - timedelta(seconds=lifespan_of_seed_in_seconds)\n    if activity_notice_seed.date_of_notice < earliest_date_of_notice:\n        try:\n            activity_notice_seed.date_of_notice_earlier_than_update_window = True\n            activity_notice_seed.save()\n            activity_notice_seed_changed = True\n            status += 'DATE_OF_NOTICE_EARLIER_THAN_UPDATE_WINDOW_SET_TRUE '\n        except Exception as e:\n            status += 'COULD_NOT_UPDATE-date_of_notice_earlier_than_update_window: ' + str(e) + ' '\n            success = False\n    results = {'success': success, 'status': status, 'activity_notice_seed': activity_notice_seed, 'activity_notice_seed_changed': activity_notice_seed_changed, 'date_of_notice_earlier_than_update_window': activity_notice_seed.date_of_notice_earlier_than_update_window}\n    return results", "fn_id": 24, "class_fn": false, "repo": "aucoeur/WeVoteServer", "file": "activity/controllers.py", "last_update_at": "2021-03-17T02:08:26+00:00", "original_content": "def update_activity_notice_seed_date_of_notice_earlier_than_update_window(activity_notice_seed):\n    status = ''\n    success = True\n    activity_notice_seed_changed = False\n    from activity.models import get_lifespan_of_seed\n    lifespan_of_seed_in_seconds = get_lifespan_of_seed(activity_notice_seed.kind_of_seed)\n    earliest_date_of_notice = now() - timedelta(seconds=lifespan_of_seed_in_seconds)\n    if activity_notice_seed.date_of_notice < earliest_date_of_notice:\n        try:\n            activity_notice_seed.date_of_notice_earlier_than_update_window = True\n            activity_notice_seed.save()\n            activity_notice_seed_changed = True\n            status += 'DATE_OF_NOTICE_EARLIER_THAN_UPDATE_WINDOW_SET_TRUE '\n        except Exception as e:\n            status += 'COULD_NOT_UPDATE-date_of_notice_earlier_than_update_window: ' + str(e) + ' '\n            success = False\n    results = {'success': success, 'status': status, 'activity_notice_seed': activity_notice_seed, 'activity_notice_seed_changed': activity_notice_seed_changed, 'date_of_notice_earlier_than_update_window': activity_notice_seed.date_of_notice_earlier_than_update_window}\n    return results", "refactored": true, "pred": {"ppl": 2.422759771347046, "ppl_lower": 2.5344202518463135, "ppl/lowercase_ppl": -1.0509179006903218, "ppl/zlib": 0.0021583104677755168, "Min_5.0% Prob": 8.790707840639001, "Min_10.0% Prob": 6.898383201871599, "Min_20.0% Prob": 4.235484773004559, "Min_30.0% Prob": 2.9356731605306963, "Min_40.0% Prob": 2.211546163719434, "Min_50.0% Prob": 1.7694722070728102, "Min_60.0% Prob": 1.4803391073415084}}
{"hexsha": "6f641f627b8305f23c544478d79bdef1903c7e0c", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef sample_mask(idx, l):\n    \"\"\"Create mask.\"\"\"\n    mask = np.zeros(l)\n    mask[idx] = 1\n    return np.array(mask, dtype=np.bool)", "fn_id": 1, "class_fn": false, "repo": "psychologyphd/HWGCN", "file": "utils.py", "last_update_at": "2021-08-04T09:31:04+00:00", "original_content": "def sample_mask(idx, l):\n    \"\"\"Create mask.\"\"\"\n    mask = np.zeros(l)\n    mask[idx] = 1\n    return np.array(mask, dtype=np.bool)", "refactored": true, "pred": {"ppl": 3.8856706619262695, "ppl_lower": 4.542843341827393, "ppl/lowercase_ppl": -1.11512415245513, "ppl/zlib": 0.010361035095217306, "Min_5.0% Prob": 8.657185077667236, "Min_10.0% Prob": 7.390705013275147, "Min_20.0% Prob": 5.759266875006936, "Min_30.0% Prob": 4.451691310852766, "Min_40.0% Prob": 3.344521952623671, "Min_50.0% Prob": 2.745800159871578, "Min_60.0% Prob": 2.2570066342525408}}
{"hexsha": "6f3e2a72a770d5215943ec27b58899302ae9bfa0", "ext": "py", "lang": "Python", "content": "def table_args(model: Base) -> None:\n\n    @timeing\n    @measure_memory_usage\n    def create_new_column(column: sa.Column) -> sa.Column:\n        attributes: List[str] = ['name', 'type', 'key', 'primary_key', 'nullable', 'default', 'server_default', 'server_onupdate', 'index', 'unique', 'system', 'doc', 'onupdate', 'autoincrement', 'comment']\n        kwargs: Dict[str, Any] = {a: getattr(column, a, None) for a in attributes}\n        kwargs['type_']: 'TypeEngine' = kwargs.get('type', None)\n        del kwargs['type']\n        return sa.Column(**kwargs)\n    columns: List[sa.Column] = list(map(create_new_column, model.__table__.columns.values()))\n    return (model.__tablename__, *columns)", "fn_id": 0, "class_fn": false, "repo": "h4wldev/seed", "file": "migrations/utils.py", "last_update_at": "2021-06-01T06:23:41+00:00", "original_content": "def table_args(model: Base) -> None:\n\n    def create_new_column(column: sa.Column) -> sa.Column:\n        attributes: List[str] = ['name', 'type', 'key', 'primary_key', 'nullable', 'default', 'server_default', 'server_onupdate', 'index', 'unique', 'system', 'doc', 'onupdate', 'autoincrement', 'comment']\n        kwargs: Dict[str, Any] = {a: getattr(column, a, None) for a in attributes}\n        kwargs['type_']: 'TypeEngine' = kwargs.get('type', None)\n        del kwargs['type']\n        return sa.Column(**kwargs)\n    columns: List[sa.Column] = list(map(create_new_column, model.__table__.columns.values()))\n    return (model.__tablename__, *columns)", "refactored": true, "pred": {"ppl": 3.922626256942749, "ppl_lower": 4.7328667640686035, "ppl/lowercase_ppl": -1.1373829463507497, "ppl/zlib": 0.0038392173960191366, "Min_5.0% Prob": 9.803059482574463, "Min_10.0% Prob": 7.741917657852173, "Min_20.0% Prob": 5.797241497039795, "Min_30.0% Prob": 4.3653391808271405, "Min_40.0% Prob": 3.3743690310046075, "Min_50.0% Prob": 2.7241410640999675, "Min_60.0% Prob": 2.276016018213704}}
{"hexsha": "fe84bfb3726301394e904f8a5ed253c3c9774c54", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef enlarge_bbox(bbox, im_size, ratio=0.15):\n    width, height = (bbox[2] - bbox[0], bbox[3] - bbox[1])\n    half_width_inc, half_height_inc = ((width * ratio).astype(np.int32), (height * ratio).astype(np.int32))\n    bbox[0], bbox[1], bbox[2], bbox[3] = (bbox[0] - half_width_inc, bbox[1] - half_height_inc, bbox[2] + half_width_inc, bbox[3] + half_height_inc)\n    bbox[0], bbox[1] = (max(bbox[0], 0), max(bbox[1], 0))\n    bbox[3], bbox[2] = (min(bbox[3], im_size[0]), min(bbox[2], im_size[1]))\n    return bbox", "fn_id": 0, "class_fn": false, "repo": "ErestorX/Buddha_alignment", "file": "generate_dataset.py", "last_update_at": "2021-05-10T08:27:46+00:00", "original_content": "def enlarge_bbox(bbox, im_size, ratio=0.15):\n    width, height = (bbox[2] - bbox[0], bbox[3] - bbox[1])\n    half_width_inc, half_height_inc = ((width * ratio).astype(np.int32), (height * ratio).astype(np.int32))\n    bbox[0], bbox[1], bbox[2], bbox[3] = (bbox[0] - half_width_inc, bbox[1] - half_height_inc, bbox[2] + half_width_inc, bbox[3] + half_height_inc)\n    bbox[0], bbox[1] = (max(bbox[0], 0), max(bbox[1], 0))\n    bbox[3], bbox[2] = (min(bbox[3], im_size[0]), min(bbox[2], im_size[1]))\n    return bbox", "refactored": true, "pred": {"ppl": 2.0591933727264404, "ppl_lower": 2.0591933727264404, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.002972486993751463, "Min_5.0% Prob": 8.492654757066207, "Min_10.0% Prob": 6.173426920717413, "Min_20.0% Prob": 3.557915900241245, "Min_30.0% Prob": 2.424587176999811, "Min_40.0% Prob": 1.8217458572206935, "Min_50.0% Prob": 1.4445602356703733, "Min_60.0% Prob": 1.2056525062875345}}
{"hexsha": "13d942d0b49cb364c495b965f3f53cdb29e47d14", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef line_counts_as_uncovered(line: str, is_from_cover_annotation_file: bool) -> bool:\n    \"\"\"\n    Args:\n        line: The line of code (including coverage annotation).\n        is_from_cover_annotation_file: Whether this line has been annotated.\n    Returns:\n        Does the line count as uncovered?\n    \"\"\"\n    if is_from_cover_annotation_file:\n        if not line.startswith('! '):\n            return False\n        content = line[2:]\n    else:\n        content = line\n    content = content.strip()\n    if '#' in content:\n        content = content[:content.index('#')].strip()\n    if any((re.search(pat, content) for pat in IGNORED_LINE_PATTERNS)):\n        return False\n    return is_from_cover_annotation_file or line_content_counts_as_uncovered_manual(content)", "fn_id": 6, "class_fn": false, "repo": "Uzayyy/Cirq", "file": "dev_tools/incremental_coverage.py", "last_update_at": "2021-03-07T19:34:28+00:00", "original_content": "def line_counts_as_uncovered(line: str, is_from_cover_annotation_file: bool) -> bool:\n    \"\"\"\n    Args:\n        line: The line of code (including coverage annotation).\n        is_from_cover_annotation_file: Whether this line has been annotated.\n    Returns:\n        Does the line count as uncovered?\n    \"\"\"\n    if is_from_cover_annotation_file:\n        if not line.startswith('! '):\n            return False\n        content = line[2:]\n    else:\n        content = line\n    content = content.strip()\n    if '#' in content:\n        content = content[:content.index('#')].strip()\n    if any((re.search(pat, content) for pat in IGNORED_LINE_PATTERNS)):\n        return False\n    return is_from_cover_annotation_file or line_content_counts_as_uncovered_manual(content)", "refactored": true, "pred": {"ppl": 4.929691791534424, "ppl_lower": 5.724623203277588, "ppl/lowercase_ppl": -1.0937143278747912, "ppl/zlib": 0.004382627662555486, "Min_5.0% Prob": 9.87785701751709, "Min_10.0% Prob": 8.659400272369385, "Min_20.0% Prob": 6.725459651249211, "Min_30.0% Prob": 5.0966482066339065, "Min_40.0% Prob": 3.944869149521173, "Min_50.0% Prob": 3.1797481010166497, "Min_60.0% Prob": 2.6740750683651817}}
{"hexsha": "3013d6318ebcca79568b59c329de03eb84f3b683", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef save_builtin(img, path):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    img.filepath = str(path).replace('.png', '-builtinsave.png')\n    img.file_format = 'PNG'\n    img.save()\n    log.info(f'wrote {path}')", "fn_id": 0, "class_fn": false, "repo": "drewp/megasecond", "file": "world_export/image.py", "last_update_at": "2021-04-06T07:51:27+00:00", "original_content": "def save_builtin(img, path):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    img.filepath = str(path).replace('.png', '-builtinsave.png')\n    img.file_format = 'PNG'\n    img.save()\n    log.info(f'wrote {path}')", "refactored": true, "pred": {"ppl": 5.275660514831543, "ppl_lower": 6.607814788818359, "ppl/lowercase_ppl": -1.1353788669320717, "ppl/zlib": 0.009291083170977989, "Min_5.0% Prob": 11.86266040802002, "Min_10.0% Prob": 9.579705774784088, "Min_20.0% Prob": 7.28370127081871, "Min_30.0% Prob": 5.426534913480282, "Min_40.0% Prob": 4.196210770867765, "Min_50.0% Prob": 3.315557688292934, "Min_60.0% Prob": 2.7807238246029127}}
{"hexsha": "0322be0d34cfd540d38d08178833c28642a03567", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef MinSpanning(n, m):\n    dt = defaultdict(list)\n    for i in range(m):\n        x, y, w = map(int, input().slpit())\n        dt[x].append([y, w])\n        dt[y].append([x, w])\n    parent = [-1] * n\n    key = [float('inf')] * n\n    mstSet = [False] * n\n    prq = [(0, 0)]\n    key[0] = 0\n    for i in range(n - 1):\n        u = heappop(prq)[1]\n        mstSet[u] = True\n        for x, w in dt[u]:\n            if not mstSet[x] and w < key[x]:\n                parent[x] = u\n                key[x] = w\n                heappush(prq, (key[x], x))", "fn_id": 0, "class_fn": false, "repo": "Saicharan67/Interview-Coding-Questions", "file": "Graphs/MinSpanningTreeByPrims.py", "last_update_at": "2021-11-04T03:30:00+00:00", "original_content": "def MinSpanning(n, m):\n    dt = defaultdict(list)\n    for i in range(m):\n        x, y, w = map(int, input().slpit())\n        dt[x].append([y, w])\n        dt[y].append([x, w])\n    parent = [-1] * n\n    key = [float('inf')] * n\n    mstSet = [False] * n\n    prq = [(0, 0)]\n    key[0] = 0\n    for i in range(n - 1):\n        u = heappop(prq)[1]\n        mstSet[u] = True\n        for x, w in dt[u]:\n            if not mstSet[x] and w < key[x]:\n                parent[x] = u\n                key[x] = w\n                heappush(prq, (key[x], x))", "refactored": true, "pred": {"ppl": 2.50140118598938, "ppl_lower": 2.785861015319824, "ppl/lowercase_ppl": -1.1174737577245017, "ppl/zlib": 0.0031506908909374426, "Min_5.0% Prob": 9.669431447982788, "Min_10.0% Prob": 7.183993148803711, "Min_20.0% Prob": 4.474546628754314, "Min_30.0% Prob": 3.0828966020804938, "Min_40.0% Prob": 2.3024643485706937, "Min_50.0% Prob": 1.8335863539001913, "Min_60.0% Prob": 1.53551427672328}}
{"hexsha": "715d0f56efd10b24b6c396c628f36713f9d9d35a", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef is_frozen():\n    \"\"\"Return a bool indicating if application is compressed\"\"\"\n    import imp\n    return hasattr(sys, 'frozen') or imp.is_frozen('__main__')", "fn_id": 4, "class_fn": false, "repo": "zywek123/accessible_output2", "file": "build/lib/accessible_output2/platform_utils/paths.py", "last_update_at": "2021-11-29T05:20:10+00:00", "original_content": "def is_frozen():\n    \"\"\"Return a bool indicating if application is compressed\"\"\"\n    import imp\n    return hasattr(sys, 'frozen') or imp.is_frozen('__main__')", "refactored": true, "pred": {"ppl": 6.818643569946289, "ppl_lower": 7.238757610321045, "ppl/lowercase_ppl": -1.0311456254473317, "ppl/zlib": 0.013239038358875334, "Min_5.0% Prob": 10.712995052337646, "Min_10.0% Prob": 9.129174947738647, "Min_20.0% Prob": 7.125073220994738, "Min_30.0% Prob": 5.786783371652875, "Min_40.0% Prob": 4.712795464616073, "Min_50.0% Prob": 3.879576894144217, "Min_60.0% Prob": 3.2317881026658517}}
{"hexsha": "9c4f0f1dce62fe32e46d081a9b30a7b8429010c4", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_offline_chunked():\n    r = http('--offline', '--chunked', '--form', 'https://this-should.never-resolve/foo', 'hello=world')\n    assert 'POST /foo' in r\n    assert 'Transfer-Encoding: chunked' in r, r\n    assert 'hello=world' in r", "fn_id": 5, "class_fn": false, "repo": "Wallyhs04/httpie", "file": "tests/test_offline.py", "last_update_at": "2021-05-29T14:40:37+00:00", "original_content": "def test_offline_chunked():\n    r = http('--offline', '--chunked', '--form', 'https://this-should.never-resolve/foo', 'hello=world')\n    assert 'POST /foo' in r\n    assert 'Transfer-Encoding: chunked' in r, r\n    assert 'hello=world' in r", "refactored": true, "pred": {"ppl": 6.145746231079102, "ppl_lower": 7.220959663391113, "ppl/lowercase_ppl": -1.0887934932688221, "ppl/zlib": 0.010258532049498966, "Min_5.0% Prob": 11.002309083938599, "Min_10.0% Prob": 8.943986117839813, "Min_20.0% Prob": 6.774393245577812, "Min_30.0% Prob": 5.484413693348567, "Min_40.0% Prob": 4.455936253070831, "Min_50.0% Prob": 3.592049866914749, "Min_60.0% Prob": 3.026176615028965}}
{"hexsha": "9c3d586ec62841559008de5a1baefd1f7c1ea4ef", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef parse_logging_lvl(lvl_name: str) -> int:\n    if lvl_name:\n        lvl_name = lvl_name.strip().upper()\n        return logging._nameToLevel.get(lvl_name, logging.INFO)\n    else:\n        return logging.INFO", "fn_id": 0, "class_fn": false, "repo": "ove/ove-asset-manager", "file": "common/util.py", "last_update_at": "2021-06-06T23:01:57+00:00", "original_content": "def parse_logging_lvl(lvl_name: str) -> int:\n    if lvl_name:\n        lvl_name = lvl_name.strip().upper()\n        return logging._nameToLevel.get(lvl_name, logging.INFO)\n    else:\n        return logging.INFO", "refactored": true, "pred": {"ppl": 3.2862210273742676, "ppl_lower": 4.560831546783447, "ppl/lowercase_ppl": -1.2754947775178036, "ppl/zlib": 0.007931588538032504, "Min_5.0% Prob": 9.223700841267904, "Min_10.0% Prob": 7.371070657457624, "Min_20.0% Prob": 5.342223967824664, "Min_30.0% Prob": 3.8721992316700162, "Min_40.0% Prob": 2.986318857009922, "Min_50.0% Prob": 2.4057780677718776, "Min_60.0% Prob": 2.009345579182818}}
{"hexsha": "977d85f77545dff9112557fdde20247c847ed065", "ext": "py", "lang": "Python", "content": "@login_required\n@timeing\n@measure_memory_usage\ndef edit_folder(request, set_id):\n    folder = get_object_or_404(CardFolder, id=set_id)\n    if folder.user != request.user:\n        return redirect('/no_access/')\n    if folder.being_edited:\n        return render(request, 'Cards/folder_being_updated.html', {'folder': folder})\n    if request.method == 'POST':\n        form = FolderForm(request.POST or None, instance=folder)\n        if form.is_valid():\n            folder = form.save(commit=False)\n            folder.being_edited = True\n            folder.save()\n            t = Thread(target=edit_folder_translate, args=[folder])\n            t.setDaemon(False)\n            t.start()\n            enough = len(folder.multicard_set.all()) > 2\n            return render(request, 'Cards/view_set.html', {'folder': folder, 'enough': enough})\n    else:\n        form = FolderForm(instance=folder)\n    return render(request, 'Cards/edit_set.html', {'form': form, 'folder': folder})", "fn_id": 3, "class_fn": false, "repo": "Solurix/Flashcards-Django", "file": "FCards/Cards/views.py", "last_update_at": "2021-05-16T03:20:23+00:00", "original_content": "@login_required\ndef edit_folder(request, set_id):\n    folder = get_object_or_404(CardFolder, id=set_id)\n    if folder.user != request.user:\n        return redirect('/no_access/')\n    if folder.being_edited:\n        return render(request, 'Cards/folder_being_updated.html', {'folder': folder})\n    if request.method == 'POST':\n        form = FolderForm(request.POST or None, instance=folder)\n        if form.is_valid():\n            folder = form.save(commit=False)\n            folder.being_edited = True\n            folder.save()\n            t = Thread(target=edit_folder_translate, args=[folder])\n            t.setDaemon(False)\n            t.start()\n            enough = len(folder.multicard_set.all()) > 2\n            return render(request, 'Cards/view_set.html', {'folder': folder, 'enough': enough})\n    else:\n        form = FolderForm(instance=folder)\n    return render(request, 'Cards/edit_set.html', {'form': form, 'folder': folder})", "refactored": true, "pred": {"ppl": 2.7474029064178467, "ppl_lower": 3.580634593963623, "ppl/lowercase_ppl": -1.2620911170893614, "ppl/zlib": 0.0024353158259947036, "Min_5.0% Prob": 11.075093709505522, "Min_10.0% Prob": 8.169210974986736, "Min_20.0% Prob": 4.815978586673737, "Min_30.0% Prob": 3.3459950591189953, "Min_40.0% Prob": 2.517335368039192, "Min_50.0% Prob": 2.027090513436688, "Min_60.0% Prob": 1.6841303762443856}}
{"hexsha": "1767ab96cf054ceb50f317b23720f5c55d829e30", "ext": "py", "lang": "Python", "content": "@pytest.fixture\n@timeing\n@measure_memory_usage\ndef fixture_property_typed_multiple_choice_filter():\n    TypedMultipleChoiceFilterModel.objects.create(id=-1, text='1')\n    TypedMultipleChoiceFilterModel.objects.create(id=0, text='One')\n    TypedMultipleChoiceFilterModel.objects.create(id=1, text='2')\n    TypedMultipleChoiceFilterModel.objects.create(id=2, text='2')\n    TypedMultipleChoiceFilterModel.objects.create(id=3, text='Not a Number')\n    TypedMultipleChoiceFilterModel.objects.create(id=4, text='3')\n    TypedMultipleChoiceFilterModel.objects.create(id=5, text='3.3')\n    TypedMultipleChoiceFilterModel.objects.create(id=6)\n    global LOOKUP_CHOICES\n    LOOKUP_CHOICES = [(c.text, c.text) for c in TypedMultipleChoiceFilterModel.objects.order_by('id')]\n    LOOKUP_CHOICES.append(('666', '666'))", "fn_id": 0, "class_fn": false, "repo": "ericziethen/django-filter-property", "file": "tests/django_property_filter/filters/test_property_typed_multiple_choice_filter.py", "last_update_at": "2021-11-28T12:02:59+00:00", "original_content": "@pytest.fixture\ndef fixture_property_typed_multiple_choice_filter():\n    TypedMultipleChoiceFilterModel.objects.create(id=-1, text='1')\n    TypedMultipleChoiceFilterModel.objects.create(id=0, text='One')\n    TypedMultipleChoiceFilterModel.objects.create(id=1, text='2')\n    TypedMultipleChoiceFilterModel.objects.create(id=2, text='2')\n    TypedMultipleChoiceFilterModel.objects.create(id=3, text='Not a Number')\n    TypedMultipleChoiceFilterModel.objects.create(id=4, text='3')\n    TypedMultipleChoiceFilterModel.objects.create(id=5, text='3.3')\n    TypedMultipleChoiceFilterModel.objects.create(id=6)\n    global LOOKUP_CHOICES\n    LOOKUP_CHOICES = [(c.text, c.text) for c in TypedMultipleChoiceFilterModel.objects.order_by('id')]\n    LOOKUP_CHOICES.append(('666', '666'))", "refactored": true, "pred": {"ppl": 2.6727609634399414, "ppl_lower": 2.982085943222046, "ppl/lowercase_ppl": -1.1113922208201947, "ppl/zlib": 0.0036820674413314755, "Min_5.0% Prob": 9.41549019018809, "Min_10.0% Prob": 7.302014499902725, "Min_20.0% Prob": 4.704131528735161, "Min_30.0% Prob": 3.2732241389652095, "Min_40.0% Prob": 2.4667930324600698, "Min_50.0% Prob": 1.9742765065389298, "Min_60.0% Prob": 1.6453297189747091}}
{"hexsha": "ea4d849d98e292e6186433a00e5238e2edf41505", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_render(using_temp_config, disabling_caching):\n    scene = SquareToCircle()\n    renderer = scene.renderer\n    renderer.update_frame = Mock(wraps=renderer.update_frame)\n    renderer.add_frame = Mock(wraps=renderer.add_frame)\n    scene.render()\n    assert renderer.add_frame.call_count == config['frame_rate']\n    assert renderer.update_frame.call_count == config['frame_rate']\n    assert_file_exists(config['output_file'])", "fn_id": 0, "class_fn": false, "repo": "fargetan/manim", "file": "tests/test_scene_rendering/test_cairo_renderer.py", "last_update_at": "2021-07-17T04:09:59+00:00", "original_content": "def test_render(using_temp_config, disabling_caching):\n    scene = SquareToCircle()\n    renderer = scene.renderer\n    renderer.update_frame = Mock(wraps=renderer.update_frame)\n    renderer.add_frame = Mock(wraps=renderer.add_frame)\n    scene.render()\n    assert renderer.add_frame.call_count == config['frame_rate']\n    assert renderer.update_frame.call_count == config['frame_rate']\n    assert_file_exists(config['output_file'])", "refactored": true, "pred": {"ppl": 3.7722725868225098, "ppl_lower": 4.724423408508301, "ppl/lowercase_ppl": -1.1695199879732956, "ppl/zlib": 0.006118330083040488, "Min_5.0% Prob": 8.761094252268473, "Min_10.0% Prob": 7.561864097913106, "Min_20.0% Prob": 5.712400875091553, "Min_30.0% Prob": 4.264955512787166, "Min_40.0% Prob": 3.2740478550686554, "Min_50.0% Prob": 2.643481031875126, "Min_60.0% Prob": 2.234297243927262}}
{"hexsha": "5479d7749b7f0f4c38907d23268688673d78cc7e", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef save():\n    website = website_e.get()\n    email = email_e.get()\n    password = password_e.get()\n    new_data = {website.upper(): {'email': email, 'password': password}}\n    if len(website) == 0 or len(password) == 0:\n        messagebox.showinfo(title='Oops!', message=\"Please don't leave any fields empty!!\")\n    else:\n        out = messagebox.askokcancel(title=website, message=f'These are the details entered: \\nEmail: {email}\\nPassword: {password} \\nDo you wish to proceed with these details?\\n\\n Note: If you want to update a new password for an existing website,also click OK\\n Else cancel the operation and search for the existing password!')\n        if out:\n            try:\n                with open('data.json', 'r') as data_file:\n                    data = json.load(data_file)\n            except FileNotFoundError:\n                with open('data.json', 'w') as data_file:\n                    json.dump(new_data, data_file, indent=4)\n            else:\n                data.update(new_data)\n                with open('data.json', 'w') as data_file:\n                    json.dump(data, data_file, indent=4)\n            finally:\n                messagebox.showinfo(title=website, message='Password saved successfully!')\n                website_e.delete(0, END)\n                password_e.delete(0, END)", "fn_id": 2, "class_fn": false, "repo": "SrihariMurali01/Password-manager", "file": "main.py", "last_update_at": "2021-12-21T18:17:28+00:00", "original_content": "def save():\n    website = website_e.get()\n    email = email_e.get()\n    password = password_e.get()\n    new_data = {website.upper(): {'email': email, 'password': password}}\n    if len(website) == 0 or len(password) == 0:\n        messagebox.showinfo(title='Oops!', message=\"Please don't leave any fields empty!!\")\n    else:\n        out = messagebox.askokcancel(title=website, message=f'These are the details entered: \\nEmail: {email}\\nPassword: {password} \\nDo you wish to proceed with these details?\\n\\n Note: If you want to update a new password for an existing website,also click OK\\n Else cancel the operation and search for the existing password!')\n        if out:\n            try:\n                with open('data.json', 'r') as data_file:\n                    data = json.load(data_file)\n            except FileNotFoundError:\n                with open('data.json', 'w') as data_file:\n                    json.dump(new_data, data_file, indent=4)\n            else:\n                data.update(new_data)\n                with open('data.json', 'w') as data_file:\n                    json.dump(data, data_file, indent=4)\n            finally:\n                messagebox.showinfo(title=website, message='Password saved successfully!')\n                website_e.delete(0, END)\n                password_e.delete(0, END)", "refactored": true, "pred": {"ppl": 2.8478572368621826, "ppl_lower": 3.166217803955078, "ppl/lowercase_ppl": -1.1012557272262968, "ppl/zlib": 0.0018891098642365486, "Min_5.0% Prob": 9.506678469040814, "Min_10.0% Prob": 7.229858440511367, "Min_20.0% Prob": 4.8158171948264625, "Min_30.0% Prob": 3.455209430526285, "Min_40.0% Prob": 2.6142509640840284, "Min_50.0% Prob": 2.0985029183725734, "Min_60.0% Prob": 1.7509630167760273}}
{"hexsha": "293907725bd25c3293fb9246b3cf2af13bae51d7", "ext": "py", "lang": "Python", "content": "@app.route('/getNotifications', methods=['GET'])\n@timeing\n@measure_memory_usage\ndef getNotifications():\n    page = request.args.get('page', default=1, type=int)\n    limit = request.args.get('limit', default=25, type=int)\n    data = rdb.getNotifications(page, limit)\n    return jsonify(data)", "fn_id": 10, "class_fn": false, "repo": "naztronaut/easyUptime", "file": "upService.py", "last_update_at": "2021-05-05T06:29:10+00:00", "original_content": "@app.route('/getNotifications', methods=['GET'])\ndef getNotifications():\n    page = request.args.get('page', default=1, type=int)\n    limit = request.args.get('limit', default=25, type=int)\n    data = rdb.getNotifications(page, limit)\n    return jsonify(data)", "refactored": true, "pred": {"ppl": 3.4167001247406006, "ppl_lower": 3.7218191623687744, "ppl/lowercase_ppl": -1.0696175529218965, "ppl/zlib": 0.0067882608258307475, "Min_5.0% Prob": 12.19736647605896, "Min_10.0% Prob": 9.3721062541008, "Min_20.0% Prob": 5.919948525726795, "Min_30.0% Prob": 4.062069315314293, "Min_40.0% Prob": 3.1060557451212043, "Min_50.0% Prob": 2.4513584584707306, "Min_60.0% Prob": 2.0624628714099527}}
{"hexsha": "6d928cb5cd52bb854817785ae392fcb7dd1a50d7", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_eds_plugins_built_property():\n    e = Event(False, True, 'url', 'project_name', 'project_version')\n    assert e.eds_plugins_built\n    e = Event(True, False, 'url', 'project_name', 'project_version')\n    assert not e.eds_plugins_built", "fn_id": 1, "class_fn": false, "repo": "jleopold28/eds", "file": "tests/test_event.py", "last_update_at": "2021-12-06T13:21:15+00:00", "original_content": "def test_eds_plugins_built_property():\n    e = Event(False, True, 'url', 'project_name', 'project_version')\n    assert e.eds_plugins_built\n    e = Event(True, False, 'url', 'project_name', 'project_version')\n    assert not e.eds_plugins_built", "refactored": true, "pred": {"ppl": 6.018176555633545, "ppl_lower": 6.962630271911621, "ppl/lowercase_ppl": -1.0812203441986243, "ppl/zlib": 0.012377822866914853, "Min_5.0% Prob": 12.247268199920654, "Min_10.0% Prob": 9.98160970211029, "Min_20.0% Prob": 7.707926005125046, "Min_30.0% Prob": 5.690702519416809, "Min_40.0% Prob": 4.500841887611331, "Min_50.0% Prob": 3.5773573964834213, "Min_60.0% Prob": 3.0138251983374356}}
{"hexsha": "2aa04fe50cb3ff88be7ef0d11bebb4e8eabb4c12", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _h(y):\n\n    def foo(x):\n        \"\"\"funcdoc\"\"\"\n        return [x + z for z in y]\n    return foo", "fn_id": 3, "class_fn": false, "repo": "QZLin/nogil", "file": "Lib/test/test_dis.py", "last_update_at": "2021-11-19T02:20:24+00:00", "original_content": "def _h(y):\n\n    def foo(x):\n        \"\"\"funcdoc\"\"\"\n        return [x + z for z in y]\n    return foo", "refactored": true, "pred": {"ppl": 16.30667495727539, "ppl_lower": 16.30667495727539, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.026842062793933585, "Min_5.0% Prob": 8.318751096725464, "Min_10.0% Prob": 8.03846788406372, "Min_20.0% Prob": 7.7533212304115295, "Min_30.0% Prob": 7.115043481190999, "Min_40.0% Prob": 6.482865735888481, "Min_50.0% Prob": 5.5912081688642505, "Min_60.0% Prob": 4.732986939450105}}
{"hexsha": "be2ff543f0b705a68df4d91c081b06d11c31d754", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef LogSquad_Damage(data_str, server_id):\n    matchObj = re.search('[([0-9.:-]+]\\\\[([ 0-9]*)]LogSquad: Player:(.*) ActualDamage=(\\\\d+(\\\\.\\\\d+)?) from (.*) caused by (.*).*', data_str, re.M | re.I)\n    date_time = datetime.datetime.strptime(matchObj.group(0).split('[')[1].split(']')[0], '%Y.%m.%d-%H.%M.%S:%f')\n    date_time_n = (date_time + datetime.timedelta(hours=8)).strftime('%Y.%m.%d-%H.%M.%S:%f')\n    date = date_time_n.split('-')[0]\n    time = date_time_n.split('-')[1]\n    Player_take_damage = matchObj.group(2)\n    Damage = matchObj.group(3)\n    Player_make_damage = matchObj.group(5)\n    Weapon = matchObj.group(6).split('_C_')[0]\n    return (date, time, str(Player_take_damage), str(Damage), str(Player_make_damage), str(Weapon), server_id)\n    pass", "fn_id": 0, "class_fn": false, "repo": "ChenjianS47/SquadPy", "file": "Core/Log_Plugins/LogSquad_Damage.py", "last_update_at": "2021-09-27T07:32:32+00:00", "original_content": "def LogSquad_Damage(data_str, server_id):\n    matchObj = re.search('[([0-9.:-]+]\\\\[([ 0-9]*)]LogSquad: Player:(.*) ActualDamage=(\\\\d+(\\\\.\\\\d+)?) from (.*) caused by (.*).*', data_str, re.M | re.I)\n    date_time = datetime.datetime.strptime(matchObj.group(0).split('[')[1].split(']')[0], '%Y.%m.%d-%H.%M.%S:%f')\n    date_time_n = (date_time + datetime.timedelta(hours=8)).strftime('%Y.%m.%d-%H.%M.%S:%f')\n    date = date_time_n.split('-')[0]\n    time = date_time_n.split('-')[1]\n    Player_take_damage = matchObj.group(2)\n    Damage = matchObj.group(3)\n    Player_make_damage = matchObj.group(5)\n    Weapon = matchObj.group(6).split('_C_')[0]\n    return (date, time, str(Player_take_damage), str(Damage), str(Player_make_damage), str(Weapon), server_id)\n    pass", "refactored": true, "pred": {"ppl": 3.2840726375579834, "ppl_lower": 4.304506301879883, "ppl/lowercase_ppl": -1.2275516873775845, "ppl/zlib": 0.003104658772763928, "Min_5.0% Prob": 9.6951995577131, "Min_10.0% Prob": 7.71910756209801, "Min_20.0% Prob": 5.365637401054645, "Min_30.0% Prob": 3.8708845863397094, "Min_40.0% Prob": 2.959119182786551, "Min_50.0% Prob": 2.3808318810730147, "Min_60.0% Prob": 1.9877522081918158}}
{"hexsha": "fea44362f63483b4569ec189eda480b3e3b01e26", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef QA_save_tdx_to_mongo(file_dir, client=DATABASE):\n    reader = TdxMinBarReader()\n    __coll = client.stock_min_five\n    for a, v, files in os.walk(file_dir):\n        for file in files:\n            if str(file)[0:2] == 'sh' and int(str(file)[2]) == 6 or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 0) or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 3):\n                QA_util_log_info('Now_saving ' + str(file)[2:8] + \"'s 5 min tick\")\n                fname = file_dir + os.sep + file\n                df = reader.get_df(fname)\n                df['code'] = str(file)[2:8]\n                df['market'] = str(file)[0:2]\n                df['datetime'] = [str(x) for x in list(df.index)]\n                df['date'] = [str(x)[0:10] for x in list(df.index)]\n                df['time_stamp'] = df['datetime'].apply(lambda x: QA_util_time_stamp(x))\n                df['date_stamp'] = df['date'].apply(lambda x: QA_util_date_stamp(x))\n                data_json = json.loads(df.to_json(orient='records'))\n                __coll.insert_many(data_json)", "fn_id": 0, "class_fn": false, "repo": "liujiannong/QUANTAXIS", "file": "QUANTAXIS/QASU/save_tdx_file.py", "last_update_at": "2021-04-01T08:59:46+00:00", "original_content": "def QA_save_tdx_to_mongo(file_dir, client=DATABASE):\n    reader = TdxMinBarReader()\n    __coll = client.stock_min_five\n    for a, v, files in os.walk(file_dir):\n        for file in files:\n            if str(file)[0:2] == 'sh' and int(str(file)[2]) == 6 or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 0) or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 3):\n                QA_util_log_info('Now_saving ' + str(file)[2:8] + \"'s 5 min tick\")\n                fname = file_dir + os.sep + file\n                df = reader.get_df(fname)\n                df['code'] = str(file)[2:8]\n                df['market'] = str(file)[0:2]\n                df['datetime'] = [str(x) for x in list(df.index)]\n                df['date'] = [str(x)[0:10] for x in list(df.index)]\n                df['time_stamp'] = df['datetime'].apply(lambda x: QA_util_time_stamp(x))\n                df['date_stamp'] = df['date'].apply(lambda x: QA_util_date_stamp(x))\n                data_json = json.loads(df.to_json(orient='records'))\n                __coll.insert_many(data_json)", "refactored": true, "pred": {"ppl": 2.8624749183654785, "ppl_lower": 3.473573684692383, "ppl/lowercase_ppl": -1.1839876407850558, "ppl/zlib": 0.002352766457939387, "Min_5.0% Prob": 9.258457130855984, "Min_10.0% Prob": 7.198572675387065, "Min_20.0% Prob": 4.8221480084790125, "Min_30.0% Prob": 3.456504907872942, "Min_40.0% Prob": 2.62187131607327, "Min_50.0% Prob": 2.106819025328311, "Min_60.0% Prob": 1.7587139383366135}}
{"hexsha": "9d3c3cf62b10c24e35584ee9f62074dd84ba8c6b", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef preprocess_prices(df_prices: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Preprocessing of price dataframe. Get latest available price.\n    :param df_prices: Needed columns: ISIN, Price, Datum, Currency\n    :return: dataframe containing prices of stocks defined by ISIN on latest available date\n    \"\"\"\n    dfp = df_prices.copy()\n    assert dfp['Currency'].drop_duplicates().count() == 1, 'Multiple currencies used for price data!'\n    assert dfp['Currency'].iloc[0] == 'EUR', 'Currency is not Euro!'\n    dfp['Date'] = pd.to_datetime(dfp['Date'], format='%d.%m.%Y')\n    latest_date = dfp['Date'].max()\n    df_current_prices = dfp[dfp['Date'] == latest_date].reset_index(drop=True)\n    return df_current_prices", "fn_id": 5, "class_fn": false, "repo": "christophpernul/personal-finance-dashboard", "file": "lib_data_operations.py", "last_update_at": "2021-02-19T15:27:06+00:00", "original_content": "def preprocess_prices(df_prices: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Preprocessing of price dataframe. Get latest available price.\n    :param df_prices: Needed columns: ISIN, Price, Datum, Currency\n    :return: dataframe containing prices of stocks defined by ISIN on latest available date\n    \"\"\"\n    dfp = df_prices.copy()\n    assert dfp['Currency'].drop_duplicates().count() == 1, 'Multiple currencies used for price data!'\n    assert dfp['Currency'].iloc[0] == 'EUR', 'Currency is not Euro!'\n    dfp['Date'] = pd.to_datetime(dfp['Date'], format='%d.%m.%Y')\n    latest_date = dfp['Date'].max()\n    df_current_prices = dfp[dfp['Date'] == latest_date].reset_index(drop=True)\n    return df_current_prices", "refactored": true, "pred": {"ppl": 4.444192409515381, "ppl_lower": 5.473508834838867, "ppl/lowercase_ppl": -1.1396634274078394, "ppl/zlib": 0.0038148290724059493, "Min_5.0% Prob": 9.646126651763916, "Min_10.0% Prob": 8.075632731119791, "Min_20.0% Prob": 6.1306665397825695, "Min_30.0% Prob": 4.735710268928891, "Min_40.0% Prob": 3.7147745436855724, "Min_50.0% Prob": 2.973499001197095, "Min_60.0% Prob": 2.487762997029569}}
{"hexsha": "178e3d96179baff608652d760ff54f1c5c188588", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_phonopy_options(postprocess_parameters):\n    \"\"\"Return phonopy command option strings.\"\"\"\n    mesh_opts = []\n    if 'mesh' in postprocess_parameters:\n        mesh = postprocess_parameters['mesh']\n        try:\n            length = float(mesh)\n            mesh_opts.append('--mesh=%f' % length)\n        except TypeError:\n            mesh_opts.append('--mesh=\"%d %d %d\"' % tuple(mesh))\n        mesh_opts.append('--nowritemesh')\n    fc_opts = []\n    if 'fc_calculator' in postprocess_parameters:\n        if postprocess_parameters['fc_calculator'].lower().strip() == 'alm':\n            fc_opts.append('--alm')\n    return (mesh_opts, fc_opts)", "fn_id": 4, "class_fn": false, "repo": "atztogo/aiida-phonopy", "file": "aiida_phonopy/common/file_generators.py", "last_update_at": "2021-12-18T03:05:40+00:00", "original_content": "def get_phonopy_options(postprocess_parameters):\n    \"\"\"Return phonopy command option strings.\"\"\"\n    mesh_opts = []\n    if 'mesh' in postprocess_parameters:\n        mesh = postprocess_parameters['mesh']\n        try:\n            length = float(mesh)\n            mesh_opts.append('--mesh=%f' % length)\n        except TypeError:\n            mesh_opts.append('--mesh=\"%d %d %d\"' % tuple(mesh))\n        mesh_opts.append('--nowritemesh')\n    fc_opts = []\n    if 'fc_calculator' in postprocess_parameters:\n        if postprocess_parameters['fc_calculator'].lower().strip() == 'alm':\n            fc_opts.append('--alm')\n    return (mesh_opts, fc_opts)", "refactored": true, "pred": {"ppl": 3.064093589782715, "ppl_lower": 3.5257551670074463, "ppl/lowercase_ppl": -1.1253338902144507, "ppl/zlib": 0.0038216784859389278, "Min_5.0% Prob": 8.642113149166107, "Min_10.0% Prob": 6.900997750899371, "Min_20.0% Prob": 4.920376355307443, "Min_30.0% Prob": 3.6446485980501713, "Min_40.0% Prob": 2.813974424877337, "Min_50.0% Prob": 2.2484495228114114, "Min_60.0% Prob": 1.8689378236139298}}
{"hexsha": "b087ca6dbcea8e5a3be1946bdd709bb2ed25f366", "ext": "py", "lang": "Python", "content": "@pytest.mark.parametrize('factory', [lambda x: list(x), lambda x: MultiDict(x), lambda x: MultiDictProxy(MultiDict(x))])\n@timeing\n@measure_memory_usage\ndef test_multi_dict_multidict_less_keys_substitution(factory: Callable):\n    with given:\n        sch = schema_multi_dict([('id', schema.int), ('name', schema.str)])\n    with when:\n        res = substitute(sch, factory([('id', 1)]))\n    with then:\n        assert res == schema_multi_dict([('id', schema.int(1)), ('name', schema.str)])\n        assert res != sch", "fn_id": 5, "class_fn": false, "repo": "nikitanovosibirsk/district42-exp-types", "file": "tests/multi_dict/substitutor/test_multi_dict_multidict_substitutor.py", "last_update_at": "2021-08-01T10:06:28+00:00", "original_content": "@pytest.mark.parametrize('factory', [lambda x: list(x), lambda x: MultiDict(x), lambda x: MultiDictProxy(MultiDict(x))])\ndef test_multi_dict_multidict_less_keys_substitution(factory: Callable):\n    with given:\n        sch = schema_multi_dict([('id', schema.int), ('name', schema.str)])\n    with when:\n        res = substitute(sch, factory([('id', 1)]))\n    with then:\n        assert res == schema_multi_dict([('id', schema.int(1)), ('name', schema.str)])\n        assert res != sch", "refactored": true, "pred": {"ppl": 5.090408802032471, "ppl_lower": 5.3895792961120605, "ppl/lowercase_ppl": -1.0350931891696504, "ppl/zlib": 0.006432245620863749, "Min_5.0% Prob": 12.618282318115234, "Min_10.0% Prob": 9.988728427886963, "Min_20.0% Prob": 7.069601241747538, "Min_30.0% Prob": 5.231933596399095, "Min_40.0% Prob": 4.053393161296844, "Min_50.0% Prob": 3.2412254495644257, "Min_60.0% Prob": 2.714822633478504}}
{"hexsha": "f04872eed07d871c244788341ce7469a3e8c2ec3", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef get_random_vals(mean_vel):\n    init_v = 20 + np.random.choice(range(-5, 5))\n    action_magnitute = np.random.uniform(-3, 3)\n    action_freq = np.random.uniform(0.02, 0.06)\n    return (init_v, action_magnitute, action_freq)", "fn_id": 3, "class_fn": false, "repo": "saArbabi/sim", "file": "src/exploratory_experiments/_data_generator.py", "last_update_at": "2021-03-26T15:28:31+00:00", "original_content": "def get_random_vals(mean_vel):\n    init_v = 20 + np.random.choice(range(-5, 5))\n    action_magnitute = np.random.uniform(-3, 3)\n    action_freq = np.random.uniform(0.02, 0.06)\n    return (init_v, action_magnitute, action_freq)", "refactored": true, "pred": {"ppl": 5.3204216957092285, "ppl_lower": 5.3204216957092285, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.010254923719772503, "Min_5.0% Prob": 10.893173456192017, "Min_10.0% Prob": 8.942006429036459, "Min_20.0% Prob": 6.535356747476678, "Min_30.0% Prob": 5.160104299413747, "Min_40.0% Prob": 4.073761007724664, "Min_50.0% Prob": 3.315854759240637, "Min_60.0% Prob": 2.8177602912845283}}
{"hexsha": "539c6e5edfed9d87bb33e2513733ff5fcbd5e916", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef _make_dagster_event(event_type: DagsterEventType, pipeline_name: str, step_key: str):\n    event_specific_data = None\n    if event_type == DagsterEventType.STEP_SUCCESS:\n        event_specific_data = StepSuccessData(duration_ms=1.0)\n    elif event_type == DagsterEventType.STEP_FAILURE:\n        event_specific_data = StepFailureData(error=None, user_failure_data=None)\n    return DagsterEvent(event_type.value, pipeline_name, step_key=step_key, event_specific_data=event_specific_data)", "fn_id": 1, "class_fn": false, "repo": "denimalpaca/OpenLineage", "file": "integration/dagster/tests/conftest.py", "last_update_at": "2021-12-03T17:00:00+00:00", "original_content": "def _make_dagster_event(event_type: DagsterEventType, pipeline_name: str, step_key: str):\n    event_specific_data = None\n    if event_type == DagsterEventType.STEP_SUCCESS:\n        event_specific_data = StepSuccessData(duration_ms=1.0)\n    elif event_type == DagsterEventType.STEP_FAILURE:\n        event_specific_data = StepFailureData(error=None, user_failure_data=None)\n    return DagsterEvent(event_type.value, pipeline_name, step_key=step_key, event_specific_data=event_specific_data)", "refactored": true, "pred": {"ppl": 2.0839333534240723, "ppl_lower": 3.461796522140503, "ppl/lowercase_ppl": -1.6912163426322386, "ppl/zlib": 0.002960714287326369, "Min_5.0% Prob": 7.128270421709333, "Min_10.0% Prob": 5.657007296880086, "Min_20.0% Prob": 3.482392199577824, "Min_30.0% Prob": 2.4198336439563874, "Min_40.0% Prob": 1.854740808747949, "Min_50.0% Prob": 1.47753024703035, "Min_60.0% Prob": 1.2263351290250206}}
{"hexsha": "8e050af63a97f4a7f86ee722501d806903d052be", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef test_clip_lines(two_line_gdf, single_rectangle_gdf):\n    \"\"\"Test what happens when you give the clip_extent a line GDF.\"\"\"\n    clip_line = cl.clip_shp(two_line_gdf, single_rectangle_gdf)\n    assert len(clip_line.geometry) == 2", "fn_id": 19, "class_fn": false, "repo": "jlpalomino/earthpy", "file": "earthpy/tests/test_clip.py", "last_update_at": "2021-01-02T02:32:41+00:00", "original_content": "def test_clip_lines(two_line_gdf, single_rectangle_gdf):\n    \"\"\"Test what happens when you give the clip_extent a line GDF.\"\"\"\n    clip_line = cl.clip_shp(two_line_gdf, single_rectangle_gdf)\n    assert len(clip_line.geometry) == 2", "refactored": true, "pred": {"ppl": 8.042890548706055, "ppl_lower": 8.473166465759277, "ppl/lowercase_ppl": -1.0249980960112703, "ppl/zlib": 0.0123360268613138, "Min_5.0% Prob": 11.98010778427124, "Min_10.0% Prob": 10.410995483398438, "Min_20.0% Prob": 7.822175530826344, "Min_30.0% Prob": 6.35469331741333, "Min_40.0% Prob": 5.109180727425744, "Min_50.0% Prob": 4.145499281065408, "Min_60.0% Prob": 3.5092201164978394}}
{"hexsha": "cab40a1d1240c5bed8edb2cf223d0f234868dfd0", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef daily_mean(data):\n    \"\"\"Calculate the daily mean of a 2D inflammation data array.\n\n    :param data: A 2D data array with inflammation data (each row contains measurements for a single patient across all days).\n    :returns: An array of mean values of measurements for each day.\n    \"\"\"\n    return np.mean(data, axis=0)", "fn_id": 1, "class_fn": false, "repo": "raphaelshirley/python-intermediate-inflammation-1", "file": "inflammation/models.py", "last_update_at": "2021-12-10T12:28:49+00:00", "original_content": "def daily_mean(data):\n    \"\"\"Calculate the daily mean of a 2D inflammation data array.\n\n    :param data: A 2D data array with inflammation data (each row contains measurements for a single patient across all days).\n    :returns: An array of mean values of measurements for each day.\n    \"\"\"\n    return np.mean(data, axis=0)", "refactored": true, "pred": {"ppl": 4.694331645965576, "ppl_lower": 4.890295505523682, "ppl/lowercase_ppl": -1.0264473321799803, "ppl/zlib": 0.007225961439719372, "Min_5.0% Prob": 10.810753345489502, "Min_10.0% Prob": 8.210290378994411, "Min_20.0% Prob": 6.005275395181444, "Min_30.0% Prob": 4.793664609944379, "Min_40.0% Prob": 3.8201428999503455, "Min_50.0% Prob": 3.0631588590533836, "Min_60.0% Prob": 2.5805339547720823}}
{"hexsha": "bc9cb89c9de7c8845a3f7858c2bf081cca88afc4", "ext": "py", "lang": "Python", "content": "@timeing\n@measure_memory_usage\ndef main():\n    parser = argparse.ArgumentParser()\n    default_url = 'https://search.api.hubmapconsortium.org/portal/search'\n    parser.add_argument('--url', default=default_url, help=f'ES endpoint. Default: {default_url}')\n    default_size = 20\n    parser.add_argument('--size', type=int, default=default_size, help=f'Number of records to pull. Default: {default_size}')\n    default_type = 'Dataset'\n    parser.add_argument('--type', default=default_type, help=f'Entity type to query. Default: {default_type}')\n    args = parser.parse_args()\n    query = {'post_filter': {'term': {'entity_type.keyword': args.type}}, 'size': args.size, '_source': ['metadata.metadata' if args.type == 'Dataset' else 'metadata']}\n    response = requests.post(args.url, json=query)\n    hits = response.json()['hits']['hits']\n    writer = DictWriter(sys.stdout, fieldnames=['uuid', 'assay_type', 'field', 'value'], extrasaction='ignore')\n    writer.writeheader()\n    for hit in hits:\n        uuid = hit['_id']\n        if 'metadata' not in hit['_source']:\n            continue\n        meta = hit['_source']['metadata']\n        if 'metadata' in meta:\n            meta = meta['metadata']\n        for field, value in meta.items():\n            if not re.search('[A-Za-z]', value):\n                continue\n            writer.writerow({'uuid': uuid, 'assay_type': meta['assay_type'] if 'assay_type' in meta else 'Sample', 'field': field, 'value': value})\n    assert len(hits) < args.size, f'Result truncated at {args.size}'\n    return 0", "fn_id": 0, "class_fn": false, "repo": "lukasz-migas/ingest-validation-tools", "file": "src/generate_field_values_csv.py", "last_update_at": "2021-03-17T20:48:41+00:00", "original_content": "def main():\n    parser = argparse.ArgumentParser()\n    default_url = 'https://search.api.hubmapconsortium.org/portal/search'\n    parser.add_argument('--url', default=default_url, help=f'ES endpoint. Default: {default_url}')\n    default_size = 20\n    parser.add_argument('--size', type=int, default=default_size, help=f'Number of records to pull. Default: {default_size}')\n    default_type = 'Dataset'\n    parser.add_argument('--type', default=default_type, help=f'Entity type to query. Default: {default_type}')\n    args = parser.parse_args()\n    query = {'post_filter': {'term': {'entity_type.keyword': args.type}}, 'size': args.size, '_source': ['metadata.metadata' if args.type == 'Dataset' else 'metadata']}\n    response = requests.post(args.url, json=query)\n    hits = response.json()['hits']['hits']\n    writer = DictWriter(sys.stdout, fieldnames=['uuid', 'assay_type', 'field', 'value'], extrasaction='ignore')\n    writer.writeheader()\n    for hit in hits:\n        uuid = hit['_id']\n        if 'metadata' not in hit['_source']:\n            continue\n        meta = hit['_source']['metadata']\n        if 'metadata' in meta:\n            meta = meta['metadata']\n        for field, value in meta.items():\n            if not re.search('[A-Za-z]', value):\n                continue\n            writer.writerow({'uuid': uuid, 'assay_type': meta['assay_type'] if 'assay_type' in meta else 'Sample', 'field': field, 'value': value})\n    assert len(hits) < args.size, f'Result truncated at {args.size}'\n    return 0", "refactored": true, "pred": {"ppl": 2.259688377380371, "ppl_lower": 2.529639959335327, "ppl/lowercase_ppl": -1.1384277971475303, "ppl/zlib": 0.001222229261862294, "Min_5.0% Prob": 8.03878014428275, "Min_10.0% Prob": 5.992854975518727, "Min_20.0% Prob": 3.879877741897807, "Min_30.0% Prob": 2.705849391444931, "Min_40.0% Prob": 2.0379482771543898, "Min_50.0% Prob": 1.629672256704997, "Min_60.0% Prob": 1.3618054219749847}}
