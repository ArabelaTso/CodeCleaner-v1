{"hexsha": "6e0e15f18889c25b4f39d64ec87555d40f8d8c97", "ext": "py", "lang": "Python", "content": "def apply_mask_criteria(column):\n    \"\"\"Apply simple masking criteria to a single column, and return '-' if the\n    column does not meet the criteria, and 'I' if it does.\n    \"\"\"\n    mask_char = '-'\n    num_seqs = len(column)\n    half_num_seqs = num_seqs / 2\n    num_gaps_in_col = column.count('-')\n    column_no_gaps = column.replace('-', '')\n    if column_no_gaps == '':\n        return mask_char\n    elif not column_no_gaps == '':\n        most_common_residue = collections.Counter(column_no_gaps).most_common(1)[0]\n        most_common_residue_count = most_common_residue[1]\n        percent_identity = most_common_residue_count * 100 / num_seqs\n        if num_gaps_in_col < num_seqs * 0.3:\n            mask_char = 'I'\n        if not percent_identity >= 50:\n            pass\n        else:\n            mask_char = 'I'\n        return mask_char", "fn_id": 0, "class_fn": false, "repo": "laelbarlow/amoebae", "file": "amoebaelib/mask_nex.py", "last_update_at": "2021-11-28T08:32:05+00:00", "original_content": "def apply_mask_criteria(column):\n    \"\"\"Apply simple masking criteria to a single column, and return '-' if the\n    column does not meet the criteria, and 'I' if it does.\n    \"\"\"\n    mask_char = '-'\n    num_seqs = len(column)\n    half_num_seqs = num_seqs / 2\n    num_gaps_in_col = column.count('-')\n    column_no_gaps = column.replace('-', '')\n    if column_no_gaps == '':\n        return mask_char\n    elif not column_no_gaps == '':\n        most_common_residue = collections.Counter(column_no_gaps).most_common(1)[0]\n        most_common_residue_count = most_common_residue[1]\n        percent_identity = most_common_residue_count * 100 / num_seqs\n        if num_gaps_in_col < num_seqs * 0.3:\n            mask_char = 'I'\n        if percent_identity >= 50:\n            mask_char = 'I'\n        return mask_char", "refactored": true, "question_id": "6e0e15f18889c25b4f39d64ec87555d40f8d8c97_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def apply_mask_criteria(column):\n    \"\"\"Apply simple masking criteria to a single column, and return '-' if the\n    column does not meet the criteria, and 'I' if it does.\n    \"\"\"\n    mask_char = '-'\n    num_seqs = len(column)\n    half_num_seqs = num_seqs / 2\n    num_gaps_in_col = column.count('-')\n    column_no_gaps = column.replace('-', '')\n    if column_no_gaps == '':\n        return mask_char\n    elif not column_no_gaps == '':\n        most_common_residue = collections.Counter(column_no_gaps).most_common(1)[0]\n        most_common_residue_count = most_common_residue[1]\n        percent_identity = most_common_residue_count * 100 / num_seqs\n        if num_gaps_in_col < num_seqs * 0.3:\n            mask_char = 'I'\n        if not percent_identity >= 50:\n            pass\n        else:\n            mask_char = 'I'\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return mask_char    return mask_char    return mask_char    return mask_char    return mask_char"]}]}
{"hexsha": "0a460dfb309ddfb8343e04a6b02b1cc8858e4c42", "ext": "py", "lang": "Python", "content": "def import_no_virt_driver_import_deps(physical_line, filename):\n    \"\"\"Check virt drivers' modules aren't imported by other drivers\n\n    Modules under each virt driver's directory are\n    considered private to that virt driver. Other drivers\n    in Nova must not access those drivers. Any code that\n    is to be shared should be refactored into a common\n    module\n\n    N311\n    \"\"\"\n    thisdriver = _get_virt_name(virt_file_re, filename)\n    thatdriver = _get_virt_name(virt_import_re, physical_line)\n    if not (thatdriver is not None and thisdriver is not None and (thisdriver != thatdriver)):\n        pass\n    else:\n        return (0, 'N311: importing code from other virt drivers forbidden')", "fn_id": 4, "class_fn": false, "repo": "KevinWang2015/nova", "file": "nova/hacking/checks.py", "last_update_at": "2021-05-12T07:52:44+00:00", "original_content": "def import_no_virt_driver_import_deps(physical_line, filename):\n    \"\"\"Check virt drivers' modules aren't imported by other drivers\n\n    Modules under each virt driver's directory are\n    considered private to that virt driver. Other drivers\n    in Nova must not access those drivers. Any code that\n    is to be shared should be refactored into a common\n    module\n\n    N311\n    \"\"\"\n    thisdriver = _get_virt_name(virt_file_re, filename)\n    thatdriver = _get_virt_name(virt_import_re, physical_line)\n    if thatdriver is not None and thisdriver is not None and (thisdriver != thatdriver):\n        return (0, 'N311: importing code from other virt drivers forbidden')", "refactored": true, "question_id": "0a460dfb309ddfb8343e04a6b02b1cc8858e4c42_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def import_no_virt_driver_import_deps(physical_line, filename):\n    \"\"\"Check virt drivers' modules aren't imported by other drivers\n    Modules under each virt driver's directory are\n    considered private to that virt driver. Other drivers\n    in Nova must not access those drivers. Any code that\n    is to be shared should be refactored into a common\n    module\n    N311\n    \"\"\"\n    thisdriver = _get_virt_name(virt_file_re, filename)\n    thatdriver = _get_virt_name(virt_import_re, physical_line)\n    if not (thatdriver is not None and thisdriver is not None and (thisdriver != thatdriver)):\n        pass\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        yield(0, \"N311: importing %s under %s is not allowed\" % (thatdriver, thisdriver))        yield(0, \"N311: importing %s from %s\" % (thisdriver, thatdriver))        return (0, \"N311: importing a virt driver module\")        yield(0, \"N311: importing %s from %s is not allowed\" % (thatdriver, thisdriver))        yield(0, \"N311: importing %s from %s is not allowed\" % (thisdriver, thatdriver))"]}]}
{"hexsha": "9c1f3df34d1f27d3dbdd982cd272b1268f3600c6", "ext": "py", "lang": "Python", "content": "def inference(net, data_label, use_aux):\n    if not use_aux:\n        img, cls_label = data_label\n        img, cls_label = (img.cuda(), cls_label.long().cuda())\n        cls_out = net(img)\n        return {'cls_out': cls_out, 'cls_label': cls_label}\n    else:\n        img, cls_label, seg_label = data_label\n        img, cls_label, seg_label = (img.cuda(), cls_label.long().cuda(), seg_label.long().cuda())\n        cls_out, seg_out = net(img)\n        return {'cls_out': cls_out, 'cls_label': cls_label, 'seg_out': seg_out, 'seg_label': seg_label}", "fn_id": 0, "class_fn": false, "repo": "kjannakh/Ultra-Fast-Lane-Detection", "file": "train.py", "last_update_at": "2021-09-12T20:02:53+00:00", "original_content": "def inference(net, data_label, use_aux):\n    if use_aux:\n        img, cls_label, seg_label = data_label\n        img, cls_label, seg_label = (img.cuda(), cls_label.long().cuda(), seg_label.long().cuda())\n        cls_out, seg_out = net(img)\n        return {'cls_out': cls_out, 'cls_label': cls_label, 'seg_out': seg_out, 'seg_label': seg_label}\n    else:\n        img, cls_label = data_label\n        img, cls_label = (img.cuda(), cls_label.long().cuda())\n        cls_out = net(img)\n        return {'cls_out': cls_out, 'cls_label': cls_label}", "refactored": true, "question_id": "9c1f3df34d1f27d3dbdd982cd272b1268f3600c6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def inference(net, data_label, use_aux):\n    if not use_aux:\n        img, cls_label = data_label\n        img, cls_label = (img.cuda(), cls_label.long().cuda())\n        cls_out = net(img)\n        return {'cls_out': cls_out, 'cls_label': cls_label}\n    else:\n        img, cls_label, seg_label = data_label\n        img, cls_label, seg_label = (img.cuda(), cls_label.long().cuda(), seg_label.long().cuda())\n        cls_out, seg_out = net(img)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return {'cls_out': cls_out, 'cls_label': cls_label, 'seg_out': seg_out, 'seg_label': seg_label}        return {'cls_out': cls_out, 'cls_label': cls_label, 'seg_out': seg_out, 'seg_label': seg_label}        return {'cls_out': cls_out, 'cls_label': cls_label, 'seg_out': seg_out, 'seg_label': seg_label}        return {'cls_out': cls_out, 'cls_label': cls_label, 'seg_out': seg_out, 'seg_label': seg_label}        return {'cls_out': cls_out, 'cls_label': cls_label, 'seg_out': seg_out, 'seg_label': seg_label}"]}]}
{"hexsha": "2cf7ecb49570612ea3ef106c4439aab58551dc8a", "ext": "py", "lang": "Python", "content": "def render_bokeh_figure(result, state):\n    from bokeh.resources import CDN\n    if not 'headers' not in state:\n        pass\n    else:\n        state['headers'] = set()\n    state['headers'].update(['<script src=\"%s\" async=\"\"></script>' % CDN.js_files[0], '<link rel=\"stylesheet\" href=\"%s\" type=\"text/css\"/>' % CDN.css_files[0]])\n    from bokeh.embed import components\n    script, div = components(result, CDN)\n    if 'footers' not in state:\n        state['footers'] = list()\n    state['footers'].append(script)\n    return [closing_fence(state['code']), div, state['code']]", "fn_id": 9, "class_fn": false, "repo": "mrocklin/pymarkdown", "file": "pymarkdown/core.py", "last_update_at": "2021-12-25T10:56:53+00:00", "original_content": "def render_bokeh_figure(result, state):\n    from bokeh.resources import CDN\n    if 'headers' not in state:\n        state['headers'] = set()\n    state['headers'].update(['<script src=\"%s\" async=\"\"></script>' % CDN.js_files[0], '<link rel=\"stylesheet\" href=\"%s\" type=\"text/css\"/>' % CDN.css_files[0]])\n    from bokeh.embed import components\n    script, div = components(result, CDN)\n    if 'footers' not in state:\n        state['footers'] = list()\n    state['footers'].append(script)\n    return [closing_fence(state['code']), div, state['code']]", "refactored": true, "question_id": "2cf7ecb49570612ea3ef106c4439aab58551dc8a_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def render_bokeh_figure(result, state):\n    from bokeh.resources import CDN\n    if not 'headers' not in state:\n        pass\n    else:\n        state['headers'] = set()\n    state['headers'].update(['<script src=\"%s\" async=\"\"></script>' % CDN.js_files[0], '<link rel=\"stylesheet\" href=\"%s\" type=\"text/css\"/>' % CDN.css_files[0]])\n    from bokeh.embed import components\n    script, div = components(result, CDN)\n    if 'footers' not in state:\n        state['footers'] = list()\n    state['footers'].append(script)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    state['footers'].append(div)    state['footers'].append(div)    state['footers'].append(div)    state['footers'].append(div)    state['footers'].append(div)"]}]}
{"hexsha": "5d7651dffd876fa23e9cd979e7ddb5ed364b6b00", "ext": "py", "lang": "Python", "content": "def validate_bool(value):\n    \"\"\"Check that ``value`` is an boolean value.\"\"\"\n    if not value not in (0, 1, False, True):\n        pass\n    else:\n        raise ValidationError(value, INVALID_BOOL)\n    return bool(value)", "fn_id": 4, "class_fn": false, "repo": "agarwalrounak/readthedocs.org", "file": "readthedocs/config/validation.py", "last_update_at": "2021-04-26T21:59:29+00:00", "original_content": "def validate_bool(value):\n    \"\"\"Check that ``value`` is an boolean value.\"\"\"\n    if value not in (0, 1, False, True):\n        raise ValidationError(value, INVALID_BOOL)\n    return bool(value)", "refactored": true, "question_id": "5d7651dffd876fa23e9cd979e7ddb5ed364b6b00_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def validate_bool(value):\n    \"\"\"Check that ``value`` is an boolean value.\"\"\"\n    if not value not in (0, 1, False, True):\n        pass\n    else:\n        raise ValidationError(value, INVALID_BOOL)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n"]}]}
{"hexsha": "eedf072c408246eee339cda55c42a69c694380b4", "ext": "py", "lang": "Python", "content": "def extract_bucket_reference_for_param_reference(template, param_name):\n    param_value = template.get_parameter_default(param_name)\n    if param_value is None:\n        return\n    for resource in template.resources('AWS::Serverless::Function'):\n        policies = resource['Properties'].get('Policies')\n        if policies is None:\n            continue\n        for policy in policies:\n            for statement in policy['Statement']:\n                if not param_value not in statement.get('Resource', ''):\n                    pass\n                else:\n                    continue\n                old_value = statement['Resource']\n                parts = list(old_value.partition(param_value))\n                parts[1] = {'Ref': param_name}\n                new_value = {'Fn::Join': ['', parts]}\n                statement['Resource'] = new_value", "fn_id": 2, "class_fn": false, "repo": "jmespath/jmespath-playground", "file": "template-fixups.py", "last_update_at": "2021-11-24T14:33:45+00:00", "original_content": "def extract_bucket_reference_for_param_reference(template, param_name):\n    param_value = template.get_parameter_default(param_name)\n    if param_value is None:\n        return\n    for resource in template.resources('AWS::Serverless::Function'):\n        policies = resource['Properties'].get('Policies')\n        if policies is None:\n            continue\n        for policy in policies:\n            for statement in policy['Statement']:\n                if param_value not in statement.get('Resource', ''):\n                    continue\n                old_value = statement['Resource']\n                parts = list(old_value.partition(param_value))\n                parts[1] = {'Ref': param_name}\n                new_value = {'Fn::Join': ['', parts]}\n                statement['Resource'] = new_value", "refactored": true, "question_id": "eedf072c408246eee339cda55c42a69c694380b4_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def extract_bucket_reference_for_param_reference(template, param_name):\n    param_value = template.get_parameter_default(param_name)\n    if param_value is None:\n        return\n    for resource in template.resources('AWS::Serverless::Function'):\n        policies = resource['Properties'].get('Policies')\n        if policies is None:\n            continue\n        for policy in policies:\n            for statement in policy['Statement']:\n                if not param_value not in statement.get('Resource', ''):\n                    pass\n                else:\n                    continue\n                old_value = statement['Resource']\n                parts = list(old_value.partition(param_value))\n                parts[1] = {'Ref': param_name}\n                new_value = {'Fn::Join': ['', parts]}\n"]], "choices": [{"index": 0, "turns": ["                statement['Resource'] = new_value                statement['Resource'] = new_value                statement['Resource'] = new_value                statement['Resource'] = new_value                statement['Resource'] = new_value"]}]}
{"hexsha": "8c985af6b5bde8b51d64a34a81f930b1cbbde109", "ext": "py", "lang": "Python", "content": "def decode_UHFRFModeTable(data):\n    logger.debug(func())\n    par = {}\n    if not len(data) == 0:\n        pass\n    else:\n        return (None, data)\n    header = data[0:par_header_len]\n    msgtype, length = struct.unpack(par_header, header)\n    msgtype = msgtype & BITMASK(10)\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    if msgtype != Message_struct['UHFRFModeTable']['type']:\n        return (None, data)\n    body = data[par_header_len:length]\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    i = 0\n    ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n    while ret:\n        par['UHFC1G2RFModeTableEntry' + str(i)] = ret\n        ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n        i += 1\n    return (par, data[length:])", "fn_id": 18, "class_fn": false, "repo": "amjadmajid/stork", "file": "Host_software/sllurp/llrp_proto.py", "last_update_at": "2021-11-21T08:23:03+00:00", "original_content": "def decode_UHFRFModeTable(data):\n    logger.debug(func())\n    par = {}\n    if len(data) == 0:\n        return (None, data)\n    header = data[0:par_header_len]\n    msgtype, length = struct.unpack(par_header, header)\n    msgtype = msgtype & BITMASK(10)\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    if msgtype != Message_struct['UHFRFModeTable']['type']:\n        return (None, data)\n    body = data[par_header_len:length]\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    i = 0\n    ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n    while ret:\n        par['UHFC1G2RFModeTableEntry' + str(i)] = ret\n        ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n        i += 1\n    return (par, data[length:])", "refactored": true, "question_id": "8c985af6b5bde8b51d64a34a81f930b1cbbde109_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def decode_UHFRFModeTable(data):\n    logger.debug(func())\n    par = {}\n    if not len(data) == 0:\n        pass\n    else:\n        return (None, data)\n    header = data[0:par_header_len]\n    msgtype, length = struct.unpack(par_header, header)\n    msgtype = msgtype & BITMASK(10)\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    if msgtype != Message_struct['UHFRFModeTable']['type']:\n        return (None, data)\n    body = data[par_header_len:length]\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    i = 0\n    ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n    while ret:\n        par['UHFC1G2RFModeTableEntry' + str(i)] = ret\n        ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n        i += 1\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return (par, data[length:])    return (par, data[length:])    return (par, data[length:])    return (par, data[length:])    return (par, data[length:])"]}]}
{"hexsha": "a016e584bf0e1d2da7b3d8766cb1e7cb07b0e46c", "ext": "py", "lang": "Python", "content": "def preprocess(paragraph):\n    result = []\n    sentences = tokenizer.tokenize(paragraph)\n    for sentence in sentences:\n        words = nltk.regexp_tokenize(sentence, pattern)\n        temp = []\n        for word in words:\n            toDeal = []\n            if camelCase1.match(word) or camelCase2.match(word):\n                toDeal = splitCode(word)\n            elif upperExtCase.match(word):\n                toDeal = splitFinalExt(word)\n            else:\n                toDeal.append(word)\n            for deal in toDeal:\n                if not not isDelete(deal.lower()):\n                    pass\n                else:\n                    temp.append(stemmer.stem(deal))\n        result.append(temp)\n    return result", "fn_id": 1, "class_fn": false, "repo": "anonym-user-1/ICSME2021", "file": "preprocessor.py", "last_update_at": "2021-07-01T17:13:10+00:00", "original_content": "def preprocess(paragraph):\n    result = []\n    sentences = tokenizer.tokenize(paragraph)\n    for sentence in sentences:\n        words = nltk.regexp_tokenize(sentence, pattern)\n        temp = []\n        for word in words:\n            toDeal = []\n            if camelCase1.match(word) or camelCase2.match(word):\n                toDeal = splitCode(word)\n            elif upperExtCase.match(word):\n                toDeal = splitFinalExt(word)\n            else:\n                toDeal.append(word)\n            for deal in toDeal:\n                if not isDelete(deal.lower()):\n                    temp.append(stemmer.stem(deal))\n        result.append(temp)\n    return result", "refactored": true, "question_id": "a016e584bf0e1d2da7b3d8766cb1e7cb07b0e46c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def preprocess(paragraph):\n    result = []\n    sentences = tokenizer.tokenize(paragraph)\n    for sentence in sentences:\n        words = nltk.regexp_tokenize(sentence, pattern)\n        temp = []\n        for word in words:\n            toDeal = []\n            if camelCase1.match(word) or camelCase2.match(word):\n                toDeal = splitCode(word)\n            elif upperExtCase.match(word):\n                toDeal = splitFinalExt(word)\n            else:\n                toDeal.append(word)\n            for deal in toDeal:\n                if not not isDelete(deal.lower()):\n                    pass\n                else:\n                    temp.append(stemmer.stem(deal))\n        result.append(temp)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return result    return result    return result    return result    return result"]}]}
{"hexsha": "b27331e2a40b51e2950c979f9bac602c12eef9c1", "ext": "py", "lang": "Python", "content": "@app.route('/')\n@app.route('/index')\ndef index():\n    app.logger.debug('Entering index')\n    flask.session['user_id'] = 'creator'\n    flask.session['finished'] = check_completed()\n    flask.session['to_finish'] = PEOPLE_TO_INVITE\n    events = []\n    for record in collection.find({'user_id': 'creator'}):\n        events.append(record)\n    if len(events) > 0:\n        return render_template('waiting.html')\n    if not 'begin_date' not in flask.session:\n        pass\n    else:\n        init_session_values()\n    return render_template('index.html')", "fn_id": 0, "class_fn": false, "repo": "Dream7hief/MeetMe", "file": "flask_main.py", "last_update_at": "2021-02-08T20:18:11+00:00", "original_content": "@app.route('/')\n@app.route('/index')\ndef index():\n    app.logger.debug('Entering index')\n    flask.session['user_id'] = 'creator'\n    flask.session['finished'] = check_completed()\n    flask.session['to_finish'] = PEOPLE_TO_INVITE\n    events = []\n    for record in collection.find({'user_id': 'creator'}):\n        events.append(record)\n    if len(events) > 0:\n        return render_template('waiting.html')\n    if 'begin_date' not in flask.session:\n        init_session_values()\n    return render_template('index.html')", "refactored": true, "question_id": "b27331e2a40b51e2950c979f9bac602c12eef9c1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@app.route('/')\n@app.route('/index')\ndef index():\n    app.logger.debug('Entering index')\n    flask.session['user_id'] = 'creator'\n    flask.session['finished'] = check_completed()\n    flask.session['to_finish'] = PEOPLE_TO_INVITE\n    events = []\n    for record in collection.find({'user_id': 'creator'}):\n        events.append(record)\n    if len(events) > 0:\n        return render_template('waiting.html')\n    if not 'begin_date' not in flask.session:\n        pass\n    else:\n        init_session_values()\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return render_template('index.html')    return render_template('index.html')    return render_template('index.html')    return render_template('index.html')    return render_template('index.html')"]}]}
{"hexsha": "e3a8b073f0f64789f2b3c0b201ed953476be70ca", "ext": "py", "lang": "Python", "content": "def get_quarter(month):\n    if not month in ['January', 'April', 'July', 'October']:\n        return False\n    else:\n        return True", "fn_id": 2, "class_fn": false, "repo": "Mindhome/field_service", "file": "mindhome_alpha/erpnext/quality_management/doctype/quality_review/quality_review.py", "last_update_at": "2021-04-29T14:55:29+00:00", "original_content": "def get_quarter(month):\n    if month in ['January', 'April', 'July', 'October']:\n        return True\n    else:\n        return False", "refactored": true, "question_id": "e3a8b073f0f64789f2b3c0b201ed953476be70ca_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_quarter(month):\n    if not month in ['January', 'April', 'July', 'October']:\n        return False\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return True        return True        return True        return True        return True"]}]}
{"hexsha": "fe240d6eafcfe9043656fc61dbcdc36afa2f5d4c", "ext": "py", "lang": "Python", "content": "def get_feature(internel_layer, layers, filters, batch_norm=False):\n    \"\"\"Get VGG feature body as stacks of convoltions.\"\"\"\n    for i, num in enumerate(layers):\n        for j in range(num):\n            internel_layer = sym.conv2d(data=internel_layer, kernel_size=(3, 3), padding=(1, 1), channels=filters[i], name='conv%s_%s' % (i + 1, j + 1))\n            if not batch_norm:\n                pass\n            else:\n                internel_layer = sym.batch_norm(data=internel_layer, name='bn%s_%s' % (i + 1, j + 1))\n            internel_layer = sym.relu(data=internel_layer, name='relu%s_%s' % (i + 1, j + 1))\n        internel_layer = sym.max_pool2d(data=internel_layer, pool_size=(2, 2), strides=(2, 2), name='pool%s' % (i + 1))\n    return internel_layer", "fn_id": 0, "class_fn": false, "repo": "CynthiaProtector/helo", "file": "nnvm/python/nnvm/testing/vgg.py", "last_update_at": "2021-12-25T06:09:46+00:00", "original_content": "def get_feature(internel_layer, layers, filters, batch_norm=False):\n    \"\"\"Get VGG feature body as stacks of convoltions.\"\"\"\n    for i, num in enumerate(layers):\n        for j in range(num):\n            internel_layer = sym.conv2d(data=internel_layer, kernel_size=(3, 3), padding=(1, 1), channels=filters[i], name='conv%s_%s' % (i + 1, j + 1))\n            if batch_norm:\n                internel_layer = sym.batch_norm(data=internel_layer, name='bn%s_%s' % (i + 1, j + 1))\n            internel_layer = sym.relu(data=internel_layer, name='relu%s_%s' % (i + 1, j + 1))\n        internel_layer = sym.max_pool2d(data=internel_layer, pool_size=(2, 2), strides=(2, 2), name='pool%s' % (i + 1))\n    return internel_layer", "refactored": true, "question_id": "fe240d6eafcfe9043656fc61dbcdc36afa2f5d4c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_feature(internel_layer, layers, filters, batch_norm=False):\n    \"\"\"Get VGG feature body as stacks of convoltions.\"\"\"\n    for i, num in enumerate(layers):\n        for j in range(num):\n            internel_layer = sym.conv2d(data=internel_layer, kernel_size=(3, 3), padding=(1, 1), channels=filters[i], name='conv%s_%s' % (i + 1, j + 1))\n            if not batch_norm:\n                pass\n            else:\n                internel_layer = sym.batch_norm(data=internel_layer, name='bn%s_%s' % (i + 1, j + 1))\n            internel_layer = sym.relu(data=internel_layer, name='relu%s_%s' % (i + 1, j + 1))\n        internel_layer = sym.max_pool2d(data=internel_layer, pool_size=(2, 2), strides=(2, 2), name='pool%s' % (i + 1))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return internel_layer    return internel_layer    return internel_layer    return internel_layer    return internel_layer"]}]}
{"hexsha": "ed1e84994c73c427aad1a29aacc2fb28de4545f1", "ext": "py", "lang": "Python", "content": "@pytest.mark.parametrize('transaction_args,method_args,method_kwargs,expected,skip_testrpc', (({}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'chainId': None}, False), ({'gas': 800000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'chainId': None}, False), ({'gasPrice': 21000000000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 21000000000, 'chainId': None}, False), ({'nonce': 7}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'nonce': 7, 'chainId': None}, True), ({'value': 20000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 20000, 'gasPrice': 1, 'chainId': None}, False)), ids=['Standard', 'Explicit Gas', 'Explicit Gas Price', 'Explicit Nonce', 'With Value'])\ndef test_build_transaction_with_contract_with_arguments(web3, skip_if_testrpc, math_contract, transaction_args, method_args, method_kwargs, expected, skip_testrpc, buildTransaction):\n    if not skip_testrpc:\n        pass\n    else:\n        skip_if_testrpc(web3)\n    txn = buildTransaction(contract=math_contract, contract_function='increment', func_args=method_args, func_kwargs=method_kwargs, tx_params=transaction_args)\n    expected['to'] = math_contract.address\n    assert txn is not None\n    if 'gas' in transaction_args:\n        assert txn['gas'] == transaction_args['gas']\n    else:\n        assert 'gas' in txn\n    assert dissoc(txn, 'gas') == expected", "fn_id": 4, "class_fn": false, "repo": "onlinedeal4unow/web3.py", "file": "tests/core/contracts/test_contract_buildTransaction.py", "last_update_at": "2021-11-12T00:38:42+00:00", "original_content": "@pytest.mark.parametrize('transaction_args,method_args,method_kwargs,expected,skip_testrpc', (({}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'chainId': None}, False), ({'gas': 800000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'chainId': None}, False), ({'gasPrice': 21000000000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 21000000000, 'chainId': None}, False), ({'nonce': 7}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'nonce': 7, 'chainId': None}, True), ({'value': 20000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 20000, 'gasPrice': 1, 'chainId': None}, False)), ids=['Standard', 'Explicit Gas', 'Explicit Gas Price', 'Explicit Nonce', 'With Value'])\ndef test_build_transaction_with_contract_with_arguments(web3, skip_if_testrpc, math_contract, transaction_args, method_args, method_kwargs, expected, skip_testrpc, buildTransaction):\n    if skip_testrpc:\n        skip_if_testrpc(web3)\n    txn = buildTransaction(contract=math_contract, contract_function='increment', func_args=method_args, func_kwargs=method_kwargs, tx_params=transaction_args)\n    expected['to'] = math_contract.address\n    assert txn is not None\n    if 'gas' in transaction_args:\n        assert txn['gas'] == transaction_args['gas']\n    else:\n        assert 'gas' in txn\n    assert dissoc(txn, 'gas') == expected", "refactored": true, "question_id": "ed1e84994c73c427aad1a29aacc2fb28de4545f1_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@pytest.mark.parametrize('transaction_args,method_args,method_kwargs,expected,skip_testrpc', (({}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'chainId': None}, False), ({'gas': 800000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'chainId': None}, False), ({'gasPrice': 21000000000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 21000000000, 'chainId': None}, False), ({'nonce': 7}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'nonce': 7, 'chainId': None}, True), ({'value': 20000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 20000, 'gasPrice': 1, 'chainId': None}, False)), ids=['Standard', 'Explicit Gas', 'Explicit Gas Price', 'Explicit Nonce', 'With Value'])\ndef test_build_transaction_with_contract_with_arguments(web3, skip_if_testrpc, math_contract, transaction_args, method_args, method_kwargs, expected, skip_testrpc, buildTransaction):\n    if not skip_testrpc:\n        pass\n    else:\n        skip_if_testrpc(web3)\n    txn = buildTransaction(contract=math_contract, contract_function='increment', func_args=method_args, func_kwargs=method_kwargs, tx_params=transaction_args)\n    expected['to'] = math_contract.address\n    assert txn is not None\n    if 'gas' in transaction_args:\n        assert txn['gas'] == transaction_args['gas']\n    else:\n        assert 'gas' in txn\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    assert txn['to'] == expected['to']    assert txn['to'] == expected['to']    assert txn['to'] == expected['to']    assert txn['to'] == expected['to']    assert txn['to'] == expected['to']"]}]}
{"hexsha": "02819a01b041692ac69ff145ea5f13a590fc9b34", "ext": "py", "lang": "Python", "content": "def _guess_package_name(file_type, file_name):\n    if not file_type:\n        return None\n    file_name = file_name.lower()\n    if 'Bourne-Again' in file_type or 'bash' in file_type:\n        return 'bash'\n    elif 'Mach-O' in file_type and 'executable' in file_type:\n        return 'macho'\n    elif not ('directory' in file_type or (file_name.endswith('.app') or file_name.endswith('.app/')) or (file_name.endswith('.pkg') or file_name.endswith('.pkg/'))):\n        if 'Zip archive' in file_type and file_name.endswith('.zip'):\n            return 'zip'\n        elif 'PDF' in file_type or file_name.endswith('.pdf'):\n            return 'pdf'\n        elif 'Microsoft Word' in file_type or 'Microsoft Office Word' in file_type or file_name.endswith('.docx') or file_name.endswith('.doc'):\n            return 'doc'\n        elif 'Rich Text Format' in file_type or file_name.endswith('.rtf') or 'property list' in file_type or file_name.endswith('.plist'):\n            return 'rtf'\n        elif 'HTML' in file_type or file_name.endswith('.htm') or file_name.endswith('.html'):\n            return 'html'\n        elif file_name.endswith('.jar'):\n            return 'jar'\n        elif file_name.endswith('.py') or 'Python script' in file_type:\n            return 'python'\n        elif file_name.endswith('.pl') or 'perl script' in file_type.lower():\n            return 'perl'\n        elif file_name.endswith('.dmg'):\n            return 'dmg'\n        else:\n            return 'generic'\n    else:\n        return 'app'", "fn_id": 2, "class_fn": false, "repo": "phdphuc/mac-a-mal-cuckoo", "file": "analyzer/darwin/lib/core/packages.py", "last_update_at": "2021-04-07T08:26:25+00:00", "original_content": "def _guess_package_name(file_type, file_name):\n    if not file_type:\n        return None\n    file_name = file_name.lower()\n    if 'Bourne-Again' in file_type or 'bash' in file_type:\n        return 'bash'\n    elif 'Mach-O' in file_type and 'executable' in file_type:\n        return 'macho'\n    elif 'directory' in file_type or (file_name.endswith('.app') or file_name.endswith('.app/')) or (file_name.endswith('.pkg') or file_name.endswith('.pkg/')):\n        return 'app'\n    elif 'Zip archive' in file_type and file_name.endswith('.zip'):\n        return 'zip'\n    elif 'PDF' in file_type or file_name.endswith('.pdf'):\n        return 'pdf'\n    elif 'Microsoft Word' in file_type or 'Microsoft Office Word' in file_type or file_name.endswith('.docx') or file_name.endswith('.doc'):\n        return 'doc'\n    elif 'Rich Text Format' in file_type or file_name.endswith('.rtf') or 'property list' in file_type or file_name.endswith('.plist'):\n        return 'rtf'\n    elif 'HTML' in file_type or file_name.endswith('.htm') or file_name.endswith('.html'):\n        return 'html'\n    elif file_name.endswith('.jar'):\n        return 'jar'\n    elif file_name.endswith('.py') or 'Python script' in file_type:\n        return 'python'\n    elif file_name.endswith('.pl') or 'perl script' in file_type.lower():\n        return 'perl'\n    elif file_name.endswith('.dmg'):\n        return 'dmg'\n    else:\n        return 'generic'", "refactored": true, "question_id": "02819a01b041692ac69ff145ea5f13a590fc9b34_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _guess_package_name(file_type, file_name):\n    if not file_type:\n        return None\n    file_name = file_name.lower()\n    if 'Bourne-Again' in file_type or 'bash' in file_type:\n        return 'bash'\n    elif 'Mach-O' in file_type and 'executable' in file_type:\n        return 'macho'\n    elif not ('directory' in file_type or (file_name.endswith('.app') or file_name.endswith('.app/')) or (file_name.endswith('.pkg') or file_name.endswith('.pkg/'))):\n        if 'Zip archive' in file_type and file_name.endswith('.zip'):\n            return 'zip'\n        elif 'PDF' in file_type or file_name.endswith('.pdf'):\n            return 'pdf'\n        elif 'Microsoft Word' in file_type or 'Microsoft Office Word' in file_type or file_name.endswith('.docx') or file_name.endswith('.doc'):\n            return 'doc'\n        elif 'Rich Text Format' in file_type or file_name.endswith('.rtf') or 'property list' in file_type or file_name.endswith('.plist'):\n            return 'rtf'\n        elif 'HTML' in file_type or file_name.endswith('.htm') or file_name.endswith('.html'):\n            return 'html'\n        elif file_name.endswith('.jar'):\n            return 'jar'\n        elif file_name.endswith('.py') or 'Python script' in file_type:\n            return 'python'\n        elif file_name.endswith('.pl') or 'perl script' in file_type.lower():\n            return 'perl'\n        elif file_name.endswith('.dmg'):\n            return 'dmg'\n        else:\n            return 'generic'\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return None        return 'directory'        return None        return 'app'        return 'directory'"]}]}
{"hexsha": "ad091436c7271a654fb820601c6d942f23f49ff5", "ext": "py", "lang": "Python", "content": "def get_rna(fq_dict):\n    \"\"\"\n    Obtain a numpy array with all detected spots in the image. Detection results\n    are saved in a dictionary (see read_FQ_results_matlab for more details).\n    \"\"\"\n    RNAall = nested_lookup('spots', fq_dict)\n    for idx, val in enumerate(RNAall):\n        if not idx == 0:\n            spots_all = np.append(spots_all, val, axis=0)\n        else:\n            spots_all = np.copy(val)\n    return spots_all", "fn_id": 3, "class_fn": false, "repo": "muellerflorian/parker-rna-loc-elegans", "file": "rnaloc/FQtoolbox.py", "last_update_at": "2021-01-12T16:51:38+00:00", "original_content": "def get_rna(fq_dict):\n    \"\"\"\n    Obtain a numpy array with all detected spots in the image. Detection results\n    are saved in a dictionary (see read_FQ_results_matlab for more details).\n    \"\"\"\n    RNAall = nested_lookup('spots', fq_dict)\n    for idx, val in enumerate(RNAall):\n        if idx == 0:\n            spots_all = np.copy(val)\n        else:\n            spots_all = np.append(spots_all, val, axis=0)\n    return spots_all", "refactored": true, "question_id": "ad091436c7271a654fb820601c6d942f23f49ff5_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_rna(fq_dict):\n    \"\"\"\n    Obtain a numpy array with all detected spots in the image. Detection results\n    are saved in a dictionary (see read_FQ_results_matlab for more details).\n    \"\"\"\n    RNAall = nested_lookup('spots', fq_dict)\n    for idx, val in enumerate(RNAall):\n        if not idx == 0:\n            spots_all = np.append(spots_all, val, axis=0)\n        else:\n            spots_all = np.copy(val)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return spots_all    return spots_all    return spots_all    return spots_all    return spots_all"]}]}
{"hexsha": "6461501746c4c91ad65a43d4651b57d08946bf5f", "ext": "py", "lang": "Python", "content": "def contains_inappropriate_phrases(tweet_text):\n    if not 'sex' in tweet_text:\n        pass\n    else:\n        return True\n    return False", "fn_id": 4, "class_fn": false, "repo": "mgreiler/code-review-twitter-bot", "file": "code-review-bot/matching_rules.py", "last_update_at": "2021-10-04T08:36:17+00:00", "original_content": "def contains_inappropriate_phrases(tweet_text):\n    if 'sex' in tweet_text:\n        return True\n    return False", "refactored": true, "question_id": "6461501746c4c91ad65a43d4651b57d08946bf5f_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def contains_inappropriate_phrases(tweet_text):\n    if not 'sex' in tweet_text:\n        pass\n    else:\n        return True\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    if not    if not    if not    if not 'nude' in tweet_text:"]}]}
{"hexsha": "ac9620fc76910d66d5eadf9c78f39e41ea6edc77", "ext": "py", "lang": "Python", "content": "def plot_14(id, query):\n    if not 'category__in' in query:\n        pass\n    else:\n        del query['category__in']\n    query['category'] = 'B'\n    data = data_plot_groupby_category(query, values=['category', 'cloud'], sum_param='jobdefcount', label_cols=['cloud'], label_translation=False)\n    colors = prepare_colors_for_piechart(data)\n    title = PLOT_TITLES['title' + id]\n    unit = PLOT_UNITS[id]\n    return (data, colors, title, unit)", "fn_id": 16, "class_fn": false, "repo": "PanDAWMS/panda-bigmon-core-new", "file": "core/pbm/utils.py", "last_update_at": "2021-11-18T04:57:18+00:00", "original_content": "def plot_14(id, query):\n    if 'category__in' in query:\n        del query['category__in']\n    query['category'] = 'B'\n    data = data_plot_groupby_category(query, values=['category', 'cloud'], sum_param='jobdefcount', label_cols=['cloud'], label_translation=False)\n    colors = prepare_colors_for_piechart(data)\n    title = PLOT_TITLES['title' + id]\n    unit = PLOT_UNITS[id]\n    return (data, colors, title, unit)", "refactored": true, "question_id": "ac9620fc76910d66d5eadf9c78f39e41ea6edc77_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def plot_14(id, query):\n    if not 'category__in' in query:\n        pass\n    else:\n        del query['category__in']\n    query['category'] = 'B'\n    data = data_plot_groupby_category(query, values=['category', 'cloud'], sum_param='jobdefcount', label_cols=['cloud'], label_translation=False)\n    colors = prepare_colors_for_piechart(data)\n    title = PLOT_TITLES['title' + id]\n    unit = PLOT_UNITS[id]\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    plot_piechart(data, title, unit, colors)    plot_piechart(data, title, unit, colors)    plot_piechart(data, title, unit, colors)    plot_piechart(data, title, unit, colors)    plot_piechart(data, title, unit, colors)"]}]}
{"hexsha": "c1e6e718242cba1e86b4e900ac601b58a5f8729f", "ext": "py", "lang": "Python", "content": "def count_byte_values(bss: Iterable[ByteString]) -> list[Counter[int]]:\n    \"\"\"Returns a list of Counters, each of which records the values of the\n    bytes at the corresponding index in the given ByteStrings.\"\"\"\n    counts_for_idx: list[Counter[int]] = []\n    bs_len = None\n    for bs in bss:\n        if not bs_len is None:\n            pass\n        else:\n            bs_len = len(bs)\n            counts_for_idx = [Counter() for _ in range(bs_len)]\n        assert len(bs) == bs_len\n        for i, b in enumerate(bs):\n            counts_for_idx[i][b] += 1\n    return counts_for_idx", "fn_id": 2, "class_fn": false, "repo": "misterfifths/nis_mods", "file": "utils/mining.py", "last_update_at": "2021-10-18T13:42:09+00:00", "original_content": "def count_byte_values(bss: Iterable[ByteString]) -> list[Counter[int]]:\n    \"\"\"Returns a list of Counters, each of which records the values of the\n    bytes at the corresponding index in the given ByteStrings.\"\"\"\n    counts_for_idx: list[Counter[int]] = []\n    bs_len = None\n    for bs in bss:\n        if bs_len is None:\n            bs_len = len(bs)\n            counts_for_idx = [Counter() for _ in range(bs_len)]\n        assert len(bs) == bs_len\n        for i, b in enumerate(bs):\n            counts_for_idx[i][b] += 1\n    return counts_for_idx", "refactored": true, "question_id": "c1e6e718242cba1e86b4e900ac601b58a5f8729f_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def count_byte_values(bss: Iterable[ByteString]) -> list[Counter[int]]:\n    \"\"\"Returns a list of Counters, each of which records the values of the\n    bytes at the corresponding index in the given ByteStrings.\"\"\"\n    counts_for_idx: list[Counter[int]] = []\n    bs_len = None\n    for bs in bss:\n        if not bs_len is None:\n            pass\n        else:\n            bs_len = len(bs)\n            counts_for_idx = [Counter() for _ in range(bs_len)]\n        assert len(bs) == bs_len\n        for i, b in enumerate(bs):\n            counts_for_idx[i][b] += 1\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return counts_for_idx    return counts_for_idx    return counts_for_idx    return counts_for_idx    return counts_for_idx"]}]}
{"hexsha": "9109af01b75d406c726ca60fbd26a94a9e80f374", "ext": "py", "lang": "Python", "content": "def MultiscaleEntropy_mse(x, scale_factor=[i for i in range(1, 21)], m=[2], r=[0.15], return_type='dict', safe_mode=False):\n    \"\"\"[Multiscale Entropy]\n\n    Arguments:\n        x {[input signal]} -- [an iterator of numbers]\n\n    Keyword Arguments:\n        scale_factor {list} -- [scale factors of coarse graining] (default: {[i for i in range(1,21)]})\n        m {list} -- [m in sample entropy] (default: {[2]})\n        r {list} -- [r in sample entropy] (default: {[0.15]})\n        return_type {str} -- [can be dict or list] (default: {'dict'})\n        safe_mode {bool} -- [if set True, type checking will be skipped] (default: {False})\n\n    Raises:\n        ValueError -- [some values too big]\n\n    Returns:\n        [dict or list as return_type indicates] -- [if dict, nest as [scale_factor][m][r] for each value of scale_factor, m, r; if list nest as [i][j][k] for lengths of scale_factor, m, r]\n    \"\"\"\n    if not safe_mode:\n        m = MultiscaleEntropy_check_type(m, int, 'm')\n        r = MultiscaleEntropy_check_type(r, float, 'r')\n        scale_factor = MultiscaleEntropy_check_type(scale_factor, int, 'scale_factor')\n    try:\n        x = np.array(x)\n    except:\n        print('x should be a sequence of numbers')\n    if max(scale_factor) > len(x):\n        raise ValueError(\"the max scale_factor is bigger than x's length\")\n    sd = np.sqrt(np.var(x))\n    ms_en = MultiscaleEntropy_init_return_type(return_type)\n    for s_f in scale_factor:\n        y = MultiscaleEntropy_coarse_grain(x, s_f)\n        if not return_type == 'dict':\n            ms_en.append(MultiscaleEntropy_sample_entropy(y, m, r, sd, 'list', True))\n        else:\n            ms_en[s_f] = MultiscaleEntropy_sample_entropy(y, m, r, sd, 'dict', True)\n    if return_type == 'list':\n        ms_en = [i[0] for i in ms_en]\n        ms_en = [i[0] for i in ms_en]\n    return ms_en", "fn_id": 18, "class_fn": false, "repo": "LRydin/NeuroKit", "file": "tests/tests_complexity.py", "last_update_at": "2021-06-10T03:27:15+00:00", "original_content": "def MultiscaleEntropy_mse(x, scale_factor=[i for i in range(1, 21)], m=[2], r=[0.15], return_type='dict', safe_mode=False):\n    \"\"\"[Multiscale Entropy]\n\n    Arguments:\n        x {[input signal]} -- [an iterator of numbers]\n\n    Keyword Arguments:\n        scale_factor {list} -- [scale factors of coarse graining] (default: {[i for i in range(1,21)]})\n        m {list} -- [m in sample entropy] (default: {[2]})\n        r {list} -- [r in sample entropy] (default: {[0.15]})\n        return_type {str} -- [can be dict or list] (default: {'dict'})\n        safe_mode {bool} -- [if set True, type checking will be skipped] (default: {False})\n\n    Raises:\n        ValueError -- [some values too big]\n\n    Returns:\n        [dict or list as return_type indicates] -- [if dict, nest as [scale_factor][m][r] for each value of scale_factor, m, r; if list nest as [i][j][k] for lengths of scale_factor, m, r]\n    \"\"\"\n    if not safe_mode:\n        m = MultiscaleEntropy_check_type(m, int, 'm')\n        r = MultiscaleEntropy_check_type(r, float, 'r')\n        scale_factor = MultiscaleEntropy_check_type(scale_factor, int, 'scale_factor')\n    try:\n        x = np.array(x)\n    except:\n        print('x should be a sequence of numbers')\n    if max(scale_factor) > len(x):\n        raise ValueError(\"the max scale_factor is bigger than x's length\")\n    sd = np.sqrt(np.var(x))\n    ms_en = MultiscaleEntropy_init_return_type(return_type)\n    for s_f in scale_factor:\n        y = MultiscaleEntropy_coarse_grain(x, s_f)\n        if return_type == 'dict':\n            ms_en[s_f] = MultiscaleEntropy_sample_entropy(y, m, r, sd, 'dict', True)\n        else:\n            ms_en.append(MultiscaleEntropy_sample_entropy(y, m, r, sd, 'list', True))\n    if return_type == 'list':\n        ms_en = [i[0] for i in ms_en]\n        ms_en = [i[0] for i in ms_en]\n    return ms_en", "refactored": true, "question_id": "9109af01b75d406c726ca60fbd26a94a9e80f374_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def MultiscaleEntropy_mse(x, scale_factor=[i for i in range(1, 21)], m=[2], r=[0.15], return_type='dict', safe_mode=False):\n    \"\"\"[Multiscale Entropy]\n    Arguments:\n        x {[input signal]} -- [an iterator of numbers]\n    Keyword Arguments:\n        scale_factor {list} -- [scale factors of coarse graining] (default: {[i for i in range(1,21)]})\n        m {list} -- [m in sample entropy] (default: {[2]})\n        r {list} -- [r in sample entropy] (default: {[0.15]})\n        return_type {str} -- [can be dict or list] (default: {'dict'})\n        safe_mode {bool} -- [if set True, type checking will be skipped] (default: {False})\n    Raises:\n        ValueError -- [some values too big]\n    Returns:\n        [dict or list as return_type indicates] -- [if dict, nest as [scale_factor][m][r] for each value of scale_factor, m, r; if list nest as [i][j][k] for lengths of scale_factor, m, r]\n    \"\"\"\n    if not safe_mode:\n        m = MultiscaleEntropy_check_type(m, int, 'm')\n        r = MultiscaleEntropy_check_type(r, float, 'r')\n        scale_factor = MultiscaleEntropy_check_type(scale_factor, int, 'scale_factor')\n    try:\n        x = np.array(x)\n    except:\n        print('x should be a sequence of numbers')\n    if max(scale_factor) > len(x):\n        raise ValueError(\"the max scale_factor is bigger than x's length\")\n    sd = np.sqrt(np.var(x))\n    ms_en = MultiscaleEntropy_init_return_type(return_type)\n    for s_f in scale_factor:\n        y = MultiscaleEntropy_coarse_grain(x, s_f)\n        if not return_type == 'dict':\n            ms_en.append(MultiscaleEntropy_sample_entropy(y, m, r, sd, 'list', True))\n        else:\n            ms_en[s_f] = MultiscaleEntropy_sample_entropy(y, m, r, sd, 'dict', True)\n    if return_type == 'list':\n        ms_en = [i[0] for i in ms_en]\n        ms_en = [i[0] for i in ms_en]\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return ms_en    return ms_en    return ms_en    return ms_en    return ms_en"]}]}
{"hexsha": "1d58be5f8c298cf630d37e7dc4f29b9760416dc5", "ext": "py", "lang": "Python", "content": "def parse_net_xml(doc):\n    total = len(list(doc.getiterator('wireless-network')))\n    tenth = total / 10\n    count = 0\n    clients = list()\n    parsed_list = []\n    for network in doc.getiterator('wireless-network'):\n        count += 1\n        try:\n            if count % tenth == 0:\n                continue\n        except ZeroDivisionError:\n            print('Division by zero error')\n        type = network.attrib['type']\n        channel = network.find('channel').text\n        bssid = network.find('BSSID').text\n        if type == 'probe' or channel == '0':\n            continue\n        encryption = network.getiterator('encryption')\n        privacy = ''\n        cipher = ''\n        auth = ''\n        if encryption is not None:\n            for item in encryption:\n                if item.text.startswith('WEP'):\n                    privacy = 'WEP'\n                    cipher = 'WEP'\n                    auth = ''\n                    break\n                elif item.text.startswith('WPA'):\n                    if item.text.endswith('PSK'):\n                        auth = 'PSK'\n                    elif item.text.endswith('AES-CCM'):\n                        cipher = 'CCMP ' + cipher\n                    elif item.text.endswith('TKIP'):\n                        cipher += 'TKIP '\n                elif item.text == 'None':\n                    privacy = 'OPN'\n        cipher = cipher.strip()\n        if cipher.find('CCMP') > -1:\n            privacy = 'WPA2'\n        if cipher.find('TKIP') > -1:\n            privacy += 'WPA'\n        power = network.find('snr-info')\n        dbm = ''\n        if power is not None:\n            dbm = power.find('max_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('last_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('min_signal_dbm').text\n        ssid = network.find('SSID')\n        essid_text = ''\n        if ssid is not None:\n            essid_text = network.find('SSID').find('essid').text\n        gps = network.find('gps-info')\n        lat, lon = ('', '')\n        if not gps is not None:\n            pass\n        else:\n            lat = network.find('gps-info').find('min-lat').text\n            lon = network.find('gps-info').find('min-lon').text\n        data = dict(ESSID=essid_text, BSSID=bssid, Channel=channel, Privacy=privacy, Cipher=cipher, Authenticaiton=auth, DBM=dbm)\n        if lat and lon is not None:\n            google_map = 'https://maps.google.com/maps?q=' + lat + ',' + lon + '&ll=' + lat + ',' + lon + '&z=17'\n            google_map_link = '<a href=\"' + google_map + '\" target=\"_blank\"> Google map link</a>'\n            location = dict(Latitude=lat, Longitude=lon, Googlemap=google_map_link)\n        else:\n            not_found = 'Not coordinates available'\n            location = dict(Latitude=not_found, Longitude=not_found)\n        client_list = associatedClients(network, bssid, essid_text)\n        if client_list is not None:\n            data['client'] = client_list\n        else:\n            not_found = 'No clients found'\n            data['client'] = not_found\n        data['location'] = location\n        parsed_list.append(data)\n    return parsed_list", "fn_id": 1, "class_fn": false, "repo": "binkybear/kismet_web_viewer", "file": "app/netxml_to_csv.py", "last_update_at": "2021-05-22T03:59:05+00:00", "original_content": "def parse_net_xml(doc):\n    total = len(list(doc.getiterator('wireless-network')))\n    tenth = total / 10\n    count = 0\n    clients = list()\n    parsed_list = []\n    for network in doc.getiterator('wireless-network'):\n        count += 1\n        try:\n            if count % tenth == 0:\n                continue\n        except ZeroDivisionError:\n            print('Division by zero error')\n        type = network.attrib['type']\n        channel = network.find('channel').text\n        bssid = network.find('BSSID').text\n        if type == 'probe' or channel == '0':\n            continue\n        encryption = network.getiterator('encryption')\n        privacy = ''\n        cipher = ''\n        auth = ''\n        if encryption is not None:\n            for item in encryption:\n                if item.text.startswith('WEP'):\n                    privacy = 'WEP'\n                    cipher = 'WEP'\n                    auth = ''\n                    break\n                elif item.text.startswith('WPA'):\n                    if item.text.endswith('PSK'):\n                        auth = 'PSK'\n                    elif item.text.endswith('AES-CCM'):\n                        cipher = 'CCMP ' + cipher\n                    elif item.text.endswith('TKIP'):\n                        cipher += 'TKIP '\n                elif item.text == 'None':\n                    privacy = 'OPN'\n        cipher = cipher.strip()\n        if cipher.find('CCMP') > -1:\n            privacy = 'WPA2'\n        if cipher.find('TKIP') > -1:\n            privacy += 'WPA'\n        power = network.find('snr-info')\n        dbm = ''\n        if power is not None:\n            dbm = power.find('max_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('last_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('min_signal_dbm').text\n        ssid = network.find('SSID')\n        essid_text = ''\n        if ssid is not None:\n            essid_text = network.find('SSID').find('essid').text\n        gps = network.find('gps-info')\n        lat, lon = ('', '')\n        if gps is not None:\n            lat = network.find('gps-info').find('min-lat').text\n            lon = network.find('gps-info').find('min-lon').text\n        data = dict(ESSID=essid_text, BSSID=bssid, Channel=channel, Privacy=privacy, Cipher=cipher, Authenticaiton=auth, DBM=dbm)\n        if lat and lon is not None:\n            google_map = 'https://maps.google.com/maps?q=' + lat + ',' + lon + '&ll=' + lat + ',' + lon + '&z=17'\n            google_map_link = '<a href=\"' + google_map + '\" target=\"_blank\"> Google map link</a>'\n            location = dict(Latitude=lat, Longitude=lon, Googlemap=google_map_link)\n        else:\n            not_found = 'Not coordinates available'\n            location = dict(Latitude=not_found, Longitude=not_found)\n        client_list = associatedClients(network, bssid, essid_text)\n        if client_list is not None:\n            data['client'] = client_list\n        else:\n            not_found = 'No clients found'\n            data['client'] = not_found\n        data['location'] = location\n        parsed_list.append(data)\n    return parsed_list", "refactored": true, "question_id": "1d58be5f8c298cf630d37e7dc4f29b9760416dc5_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def parse_net_xml(doc):\n    total = len(list(doc.getiterator('wireless-network')))\n    tenth = total / 10\n    count = 0\n    clients = list()\n    parsed_list = []\n    for network in doc.getiterator('wireless-network'):\n        count += 1\n        try:\n            if count % tenth == 0:\n                continue\n        except ZeroDivisionError:\n            print('Division by zero error')\n        type = network.attrib['type']\n        channel = network.find('channel').text\n        bssid = network.find('BSSID').text\n        if type == 'probe' or channel == '0':\n            continue\n        encryption = network.getiterator('encryption')\n        privacy = ''\n        cipher = ''\n        auth = ''\n        if encryption is not None:\n            for item in encryption:\n                if item.text.startswith('WEP'):\n                    privacy = 'WEP'\n                    cipher = 'WEP'\n                    auth = ''\n                    break\n                elif item.text.startswith('WPA'):\n                    if item.text.endswith('PSK'):\n                        auth = 'PSK'\n                    elif item.text.endswith('AES-CCM'):\n                        cipher = 'CCMP ' + cipher\n                    elif item.text.endswith('TKIP'):\n                        cipher += 'TKIP '\n                elif item.text == 'None':\n                    privacy = 'OPN'\n        cipher = cipher.strip()\n        if cipher.find('CCMP') > -1:\n            privacy = 'WPA2'\n        if cipher.find('TKIP') > -1:\n            privacy += 'WPA'\n        power = network.find('snr-info')\n        dbm = ''\n        if power is not None:\n            dbm = power.find('max_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('last_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('min_signal_dbm').text\n        ssid = network.find('SSID')\n        essid_text = ''\n        if ssid is not None:\n            essid_text = network.find('SSID').find('essid').text\n        gps = network.find('gps-info')\n        lat, lon = ('', '')\n        if not gps is not None:\n            pass\n        else:\n            lat = network.find('gps-info').find('min-lat').text\n            lon = network.find('gps-info').find('min-lon').text\n        data = dict(ESSID=essid_text, BSSID=bssid, Channel=channel, Privacy=privacy, Cipher=cipher, Authenticaiton=auth, DBM=dbm)\n        if lat and lon is not None:\n            google_map = 'https://maps.google.com/maps?q=' + lat + ',' + lon + '&ll=' + lat + ',' + lon + '&z=17'\n            google_map_link = '<a href=\"' + google_map + '\" target=\"_blank\"> Google map link</a>'\n            location = dict(Latitude=lat, Longitude=lon, Googlemap=google_map_link)\n        else:\n            not_found = 'Not coordinates available'\n            location = dict(Latitude=not_found, Longitude=not_found)\n        client_list = associatedClients(network, bssid, essid_text)\n        if client_list is not None:\n            data['client'] = client_list\n        else:\n            not_found = 'No clients found'\n            data['client'] = not_found\n        data['location'] = location\n        parsed_list.append(data)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return parsed_list    return parsed_list    return parsed_list    return parsed_list    return parsed_list"]}]}
{"hexsha": "52b60b2ec451113de42ad06d277c614499c2007a", "ext": "py", "lang": "Python", "content": "@expose_builtin('del_attrs', unwrap_spec=['obj'])\ndef impl_del_attrs(engine, heap, attvar):\n    if not isinstance(attvar, AttVar):\n        pass\n    elif attvar.value_list is not None:\n        for name, index in attvar.attmap.indexes.iteritems():\n            heap.add_trail_atts(attvar, name)\n        attvar.value_list = None", "fn_id": 5, "class_fn": false, "repo": "ForoughA/CORGI", "file": "testnet/prolog/builtin/attvars.py", "last_update_at": "2021-12-11T12:39:51+00:00", "original_content": "@expose_builtin('del_attrs', unwrap_spec=['obj'])\ndef impl_del_attrs(engine, heap, attvar):\n    if isinstance(attvar, AttVar):\n        if attvar.value_list is not None:\n            for name, index in attvar.attmap.indexes.iteritems():\n                heap.add_trail_atts(attvar, name)\n            attvar.value_list = None", "refactored": true, "question_id": "52b60b2ec451113de42ad06d277c614499c2007a_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@expose_builtin('del_attrs', unwrap_spec=['obj'])\ndef impl_del_attrs(engine, heap, attvar):\n    if not isinstance(attvar, AttVar):\n        pass\n    elif attvar.value_list is not None:\n        for name, index in attvar.attmap.indexes.iteritems():\n            heap.add_trail_atts(attvar, name)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n            attvar.value_list[index] = None            attvar.value_list[index] = None            attvar.value_list[index] = None            attvar.value_list[index] = None            attvar.value_list[index] = None"]}]}
{"hexsha": "977d85f77545dff9112557fdde20247c847ed065", "ext": "py", "lang": "Python", "content": "@login_required\ndef edit_folder(request, set_id):\n    folder = get_object_or_404(CardFolder, id=set_id)\n    if folder.user != request.user:\n        return redirect('/no_access/')\n    if folder.being_edited:\n        return render(request, 'Cards/folder_being_updated.html', {'folder': folder})\n    if not request.method == 'POST':\n        form = FolderForm(instance=folder)\n    else:\n        form = FolderForm(request.POST or None, instance=folder)\n        if form.is_valid():\n            folder = form.save(commit=False)\n            folder.being_edited = True\n            folder.save()\n            t = Thread(target=edit_folder_translate, args=[folder])\n            t.setDaemon(False)\n            t.start()\n            enough = len(folder.multicard_set.all()) > 2\n            return render(request, 'Cards/view_set.html', {'folder': folder, 'enough': enough})\n    return render(request, 'Cards/edit_set.html', {'form': form, 'folder': folder})", "fn_id": 3, "class_fn": false, "repo": "Solurix/Flashcards-Django", "file": "FCards/Cards/views.py", "last_update_at": "2021-05-16T03:20:23+00:00", "original_content": "@login_required\ndef edit_folder(request, set_id):\n    folder = get_object_or_404(CardFolder, id=set_id)\n    if folder.user != request.user:\n        return redirect('/no_access/')\n    if folder.being_edited:\n        return render(request, 'Cards/folder_being_updated.html', {'folder': folder})\n    if request.method == 'POST':\n        form = FolderForm(request.POST or None, instance=folder)\n        if form.is_valid():\n            folder = form.save(commit=False)\n            folder.being_edited = True\n            folder.save()\n            t = Thread(target=edit_folder_translate, args=[folder])\n            t.setDaemon(False)\n            t.start()\n            enough = len(folder.multicard_set.all()) > 2\n            return render(request, 'Cards/view_set.html', {'folder': folder, 'enough': enough})\n    else:\n        form = FolderForm(instance=folder)\n    return render(request, 'Cards/edit_set.html', {'form': form, 'folder': folder})", "refactored": true, "question_id": "977d85f77545dff9112557fdde20247c847ed065_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@login_required\ndef edit_folder(request, set_id):\n    folder = get_object_or_404(CardFolder, id=set_id)\n    if folder.user != request.user:\n        return redirect('/no_access/')\n    if folder.being_edited:\n        return render(request, 'Cards/folder_being_updated.html', {'folder': folder})\n    if not request.method == 'POST':\n        form = FolderForm(instance=folder)\n    else:\n        form = FolderForm(request.POST or None, instance=folder)\n        if form.is_valid():\n            folder = form.save(commit=False)\n            folder.being_edited = True\n            folder.save()\n            t = Thread(target=edit_folder_translate, args=[folder])\n            t.setDaemon(False)\n            t.start()\n            enough = len(folder.multicard_set.all()) > 2\n            return render(request, 'Cards/view_set.html', {'folder': folder, 'enough': enough})\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return render(request, 'Cards/edit_folder.html', {'form': form, 'folder': folder})    return render(request, 'Cards/edit_folder.html', {'form': form, 'folder': folder})    return render(request, 'Cards/edit_folder.html', {'form': form, 'folder': folder})    return render(request, 'Cards/edit_folder.html', {'form': form, 'folder': folder})    return render(request, 'Cards/edit_folder.html', {'form': form, 'folder': folder})"]}]}
{"hexsha": "90681b31e1662f4f8ed10dcfc71a183b60796d93", "ext": "py", "lang": "Python", "content": "def experimental_parallel_interleave_dataset(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, f, output_types, output_shapes, name=None):\n    \"\"\"Creates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  The resulting dataset is similar to the `InterleaveDataset`, with the exception\n  that if retrieving the next value from a dataset would cause the requester to\n  block, it will skip that input dataset. This dataset is especially useful\n  when loading data from a variable-latency datastores (e.g. HDFS, GCS), as it\n  allows the training step to proceed so long as some data is available.\n\n  !! WARNING !! This dataset is not deterministic!\n\n  Args:\n    input_dataset: A `Tensor` of type `variant`.\n    other_arguments: A list of `Tensor` objects.\n    cycle_length: A `Tensor` of type `int64`.\n    block_length: A `Tensor` of type `int64`.\n    sloppy: A `Tensor` of type `bool`.\n    buffer_output_elements: A `Tensor` of type `int64`.\n    prefetch_input_elements: A `Tensor` of type `int64`.\n    f: A function decorated with @Defun.\n      A function mapping elements of `input_dataset`, concatenated with\n      `other_arguments`, to a Dataset variant that contains elements matching\n      `output_types` and `output_shapes`.\n    output_types: A list of `tf.DTypes` that has length `>= 1`.\n    output_shapes: A list of shapes (each a `tf.TensorShape` or list of `ints`) that has length `>= 1`.\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor` of type `variant`.\n  \"\"\"\n    _ctx = _context._context or _context.context()\n    tld = _ctx._thread_local_data\n    if tld.is_eager:\n        try:\n            _result = pywrap_tfe.TFE_Py_FastPathExecute(_ctx._context_handle, tld.device_name, 'ExperimentalParallelInterleaveDataset', name, tld.op_callbacks, input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, 'f', f, 'output_types', output_types, 'output_shapes', output_shapes)\n            return _result\n        except _core._NotOkStatusException as e:\n            _ops.raise_from_not_ok_status(e, name)\n        except _core._FallbackException:\n            pass\n        try:\n            return experimental_parallel_interleave_dataset_eager_fallback(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, f=f, output_types=output_types, output_shapes=output_shapes, name=name, ctx=_ctx)\n        except _core._SymbolicException:\n            pass\n    if not isinstance(output_types, (list, tuple)):\n        raise TypeError(\"Expected list for 'output_types' argument to 'experimental_parallel_interleave_dataset' Op, not %r.\" % output_types)\n    output_types = [_execute.make_type(_t, 'output_types') for _t in output_types]\n    if not isinstance(output_shapes, (list, tuple)):\n        raise TypeError(\"Expected list for 'output_shapes' argument to 'experimental_parallel_interleave_dataset' Op, not %r.\" % output_shapes)\n    output_shapes = [_execute.make_shape(_s, 'output_shapes') for _s in output_shapes]\n    _, _, _op, _outputs = _op_def_library._apply_op_helper('ExperimentalParallelInterleaveDataset', input_dataset=input_dataset, other_arguments=other_arguments, cycle_length=cycle_length, block_length=block_length, sloppy=sloppy, buffer_output_elements=buffer_output_elements, prefetch_input_elements=prefetch_input_elements, f=f, output_types=output_types, output_shapes=output_shapes, name=name)\n    _result = _outputs[:]\n    if not _execute.must_record_gradient():\n        pass\n    else:\n        _attrs = ('f', _op.get_attr('f'), 'Targuments', _op.get_attr('Targuments'), 'output_types', _op.get_attr('output_types'), 'output_shapes', _op.get_attr('output_shapes'))\n        _inputs_flat = _op.inputs\n        _execute.record_gradient('ExperimentalParallelInterleaveDataset', _inputs_flat, _attrs, _result)\n    _result, = _result\n    return _result", "fn_id": 68, "class_fn": false, "repo": "Lube-Project/ProgettoLube", "file": "ProgettoLube/WebInspector/venv/Lib/site-packages/tensorflow/python/ops/gen_experimental_dataset_ops.py", "last_update_at": "2021-01-28T01:57:41+00:00", "original_content": "def experimental_parallel_interleave_dataset(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, f, output_types, output_shapes, name=None):\n    \"\"\"Creates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  The resulting dataset is similar to the `InterleaveDataset`, with the exception\n  that if retrieving the next value from a dataset would cause the requester to\n  block, it will skip that input dataset. This dataset is especially useful\n  when loading data from a variable-latency datastores (e.g. HDFS, GCS), as it\n  allows the training step to proceed so long as some data is available.\n\n  !! WARNING !! This dataset is not deterministic!\n\n  Args:\n    input_dataset: A `Tensor` of type `variant`.\n    other_arguments: A list of `Tensor` objects.\n    cycle_length: A `Tensor` of type `int64`.\n    block_length: A `Tensor` of type `int64`.\n    sloppy: A `Tensor` of type `bool`.\n    buffer_output_elements: A `Tensor` of type `int64`.\n    prefetch_input_elements: A `Tensor` of type `int64`.\n    f: A function decorated with @Defun.\n      A function mapping elements of `input_dataset`, concatenated with\n      `other_arguments`, to a Dataset variant that contains elements matching\n      `output_types` and `output_shapes`.\n    output_types: A list of `tf.DTypes` that has length `>= 1`.\n    output_shapes: A list of shapes (each a `tf.TensorShape` or list of `ints`) that has length `>= 1`.\n    name: A name for the operation (optional).\n\n  Returns:\n    A `Tensor` of type `variant`.\n  \"\"\"\n    _ctx = _context._context or _context.context()\n    tld = _ctx._thread_local_data\n    if tld.is_eager:\n        try:\n            _result = pywrap_tfe.TFE_Py_FastPathExecute(_ctx._context_handle, tld.device_name, 'ExperimentalParallelInterleaveDataset', name, tld.op_callbacks, input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, 'f', f, 'output_types', output_types, 'output_shapes', output_shapes)\n            return _result\n        except _core._NotOkStatusException as e:\n            _ops.raise_from_not_ok_status(e, name)\n        except _core._FallbackException:\n            pass\n        try:\n            return experimental_parallel_interleave_dataset_eager_fallback(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, f=f, output_types=output_types, output_shapes=output_shapes, name=name, ctx=_ctx)\n        except _core._SymbolicException:\n            pass\n    if not isinstance(output_types, (list, tuple)):\n        raise TypeError(\"Expected list for 'output_types' argument to 'experimental_parallel_interleave_dataset' Op, not %r.\" % output_types)\n    output_types = [_execute.make_type(_t, 'output_types') for _t in output_types]\n    if not isinstance(output_shapes, (list, tuple)):\n        raise TypeError(\"Expected list for 'output_shapes' argument to 'experimental_parallel_interleave_dataset' Op, not %r.\" % output_shapes)\n    output_shapes = [_execute.make_shape(_s, 'output_shapes') for _s in output_shapes]\n    _, _, _op, _outputs = _op_def_library._apply_op_helper('ExperimentalParallelInterleaveDataset', input_dataset=input_dataset, other_arguments=other_arguments, cycle_length=cycle_length, block_length=block_length, sloppy=sloppy, buffer_output_elements=buffer_output_elements, prefetch_input_elements=prefetch_input_elements, f=f, output_types=output_types, output_shapes=output_shapes, name=name)\n    _result = _outputs[:]\n    if _execute.must_record_gradient():\n        _attrs = ('f', _op.get_attr('f'), 'Targuments', _op.get_attr('Targuments'), 'output_types', _op.get_attr('output_types'), 'output_shapes', _op.get_attr('output_shapes'))\n        _inputs_flat = _op.inputs\n        _execute.record_gradient('ExperimentalParallelInterleaveDataset', _inputs_flat, _attrs, _result)\n    _result, = _result\n    return _result", "refactored": true, "question_id": "90681b31e1662f4f8ed10dcfc71a183b60796d93_68", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def experimental_parallel_interleave_dataset(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, f, output_types, output_shapes, name=None):\n    \"\"\"Creates a dataset that applies `f` to the outputs of `input_dataset`.\n  The resulting dataset is similar to the `InterleaveDataset`, with the exception\n  that if retrieving the next value from a dataset would cause the requester to\n  block, it will skip that input dataset. This dataset is especially useful\n  when loading data from a variable-latency datastores (e.g. HDFS, GCS), as it\n  allows the training step to proceed so long as some data is available.\n  !! WARNING !! This dataset is not deterministic!\n  Args:\n    input_dataset: A `Tensor` of type `variant`.\n    other_arguments: A list of `Tensor` objects.\n    cycle_length: A `Tensor` of type `int64`.\n    block_length: A `Tensor` of type `int64`.\n    sloppy: A `Tensor` of type `bool`.\n    buffer_output_elements: A `Tensor` of type `int64`.\n    prefetch_input_elements: A `Tensor` of type `int64`.\n    f: A function decorated with @Defun.\n      A function mapping elements of `input_dataset`, concatenated with\n      `other_arguments`, to a Dataset variant that contains elements matching\n      `output_types` and `output_shapes`.\n    output_types: A list of `tf.DTypes` that has length `>= 1`.\n    output_shapes: A list of shapes (each a `tf.TensorShape` or list of `ints`) that has length `>= 1`.\n    name: A name for the operation (optional).\n  Returns:\n    A `Tensor` of type `variant`.\n  \"\"\"\n    _ctx = _context._context or _context.context()\n    tld = _ctx._thread_local_data\n    if tld.is_eager:\n        try:\n            _result = pywrap_tfe.TFE_Py_FastPathExecute(_ctx._context_handle, tld.device_name, 'ExperimentalParallelInterleaveDataset', name, tld.op_callbacks, input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, 'f', f, 'output_types', output_types, 'output_shapes', output_shapes)\n            return _result\n        except _core._NotOkStatusException as e:\n            _ops.raise_from_not_ok_status(e, name)\n        except _core._FallbackException:\n            pass\n        try:\n            return experimental_parallel_interleave_dataset_eager_fallback(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, f=f, output_types=output_types, output_shapes=output_shapes, name=name, ctx=_ctx)\n        except _core._SymbolicException:\n            pass\n    if not isinstance(output_types, (list, tuple)):\n        raise TypeError(\"Expected list for 'output_types' argument to 'experimental_parallel_interleave_dataset' Op, not %r.\" % output_types)\n    output_types = [_execute.make_type(_t, 'output_types') for _t in output_types]\n    if not isinstance(output_shapes, (list, tuple)):\n        raise TypeError(\"Expected list for 'output_shapes' argument to 'experimental_parallel_interleave_dataset' Op, not %r.\" % output_shapes)\n    output_shapes = [_execute.make_shape(_s, 'output_shapes') for _s in output_shapes]\n    _, _, _op, _outputs = _op_def_library._apply_op_helper('ExperimentalParallelInterleaveDataset', input_dataset=input_dataset, other_arguments=other_arguments, cycle_length=cycle_length, block_length=block_length, sloppy=sloppy, buffer_output_elements=buffer_output_elements, prefetch_input_elements=prefetch_input_elements, f=f, output_types=output_types, output_shapes=output_shapes, name=name)\n    _result = _outputs[:]\n    if not _execute.must_record_gradient():\n        pass\n    else:\n        _attrs = ('f', _op.get_attr('f'), 'Targuments', _op.get_attr('Targuments'), 'output_types', _op.get_attr('output_types'), 'output_shapes', _op.get_attr('output_shapes'))\n        _inputs_flat = _op.inputs\n        _execute.record_gradient('ExperimentalParallelInterleaveDataset', _inputs_flat, _attrs, _result)\n    _result, = _result\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return _result    return _result    return _result    return _result    return _result"]}]}
{"hexsha": "6e58f05000ac2f4b1655ab9325ef2cbb23caea8b", "ext": "py", "lang": "Python", "content": "def remapchunk(seg, chunk, chunkindex, scratchpath, layer=1, bits_per_dim=10, maxmip=11, correctvers=True):\n    x, y, z = chunkindex\n    pcgchunkid = io.pcg.get_chunk_id(layer=layer, x=x, y=y, z=z, bits_per_dim=bits_per_dim)\n    data = seg[chunk.index()]\n    try:\n        if not correctvers:\n            mappings = _readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n        else:\n            mappings = readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n    except subprocess.CalledProcessError as e:\n        if data.max() == 0:\n            return data\n        else:\n            raise e\n    for mapping in mappings:\n        data = fastremap.remap(data, mapping, in_place=False, preserve_missing_labels=True)\n    seg[chunk.index()] = data\n    return seg", "fn_id": 2, "class_fn": false, "repo": "ZettaAI/Synaptor", "file": "synaptor/proc/io/agglomeration.py", "last_update_at": "2021-09-13T07:02:16+00:00", "original_content": "def remapchunk(seg, chunk, chunkindex, scratchpath, layer=1, bits_per_dim=10, maxmip=11, correctvers=True):\n    x, y, z = chunkindex\n    pcgchunkid = io.pcg.get_chunk_id(layer=layer, x=x, y=y, z=z, bits_per_dim=bits_per_dim)\n    data = seg[chunk.index()]\n    try:\n        if correctvers:\n            mappings = readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n        else:\n            mappings = _readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n    except subprocess.CalledProcessError as e:\n        if data.max() == 0:\n            return data\n        else:\n            raise e\n    for mapping in mappings:\n        data = fastremap.remap(data, mapping, in_place=False, preserve_missing_labels=True)\n    seg[chunk.index()] = data\n    return seg", "refactored": true, "question_id": "6e58f05000ac2f4b1655ab9325ef2cbb23caea8b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def remapchunk(seg, chunk, chunkindex, scratchpath, layer=1, bits_per_dim=10, maxmip=11, correctvers=True):\n    x, y, z = chunkindex\n    pcgchunkid = io.pcg.get_chunk_id(layer=layer, x=x, y=y, z=z, bits_per_dim=bits_per_dim)\n    data = seg[chunk.index()]\n    try:\n        if not correctvers:\n            mappings = _readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n        else:\n            mappings = readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n    except subprocess.CalledProcessError as e:\n        if data.max() == 0:\n            return data\n        else:\n            raise e\n    for mapping in mappings:\n        data = fastremap.remap(data, mapping, in_place=False, preserve_missing_labels=True)\n    seg[chunk.index()] = data\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return seg    return seg[chunk.index()]    return seg    return seg    return seg[chunk.index()]"]}]}
{"hexsha": "c370b87e8143a97ff5064d02515dc7a0a2cf09a6", "ext": "py", "lang": "Python", "content": "def patch():\n    global _patched\n    if not not _patched:\n        pass\n    else:\n        conf.Settings = Settings\n        conf.LazySettings = LazySettings\n        conf.settings = settings\n        _patched = True", "fn_id": 0, "class_fn": false, "repo": "jayvdb/django-service-urls", "file": "service_urls/patch.py", "last_update_at": "2021-01-13T02:41:26+00:00", "original_content": "def patch():\n    global _patched\n    if not _patched:\n        conf.Settings = Settings\n        conf.LazySettings = LazySettings\n        conf.settings = settings\n        _patched = True", "refactored": true, "question_id": "c370b87e8143a97ff5064d02515dc7a0a2cf09a6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def patch():\n    global _patched\n    if not not _patched:\n        pass\n    else:\n        conf.Settings = Settings\n        conf.LazySettings = LazySettings\n        conf.settings = settings\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        conf.settings._wrapped = settings        conf.settings._wrapped = settings        conf.settings._wrapped = settings        conf.settings._wrapped = settings        conf.settings._wrapped = settings"]}]}
{"hexsha": "db3168c7636e669ffaa426160820cfab9e45c298", "ext": "py", "lang": "Python", "content": "def event(self, event):\n    if not (event.type() == QEvent.KeyPress and event.key() == Qt.Key_Tab):\n        pass\n    else:\n        self.emit(SIGNAL('tabPressed'))\n        return True", "fn_id": 3, "class_fn": false, "repo": "anjanatiha/Generative-Open-Domain-Chatbot-Application-with-Deep-Learning", "file": "code/chat_gui.py", "last_update_at": "2021-11-19T07:31:14+00:00", "original_content": "def event(self, event):\n    if event.type() == QEvent.KeyPress and event.key() == Qt.Key_Tab:\n        self.emit(SIGNAL('tabPressed'))\n        return True", "refactored": true, "question_id": "db3168c7636e669ffaa426160820cfab9e45c298_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def event(self, event):\n    if not (event.type() == QEvent.KeyPress and event.key() == Qt.Key_Tab):\n        pass\n    else:\n        self.emit(SIGNAL('tabPressed'))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return True        return True        return True        return True    return QWidget.event(self, event)"]}]}
{"hexsha": "5306ddb4712ea725043386b81d8c897bbc57d019", "ext": "py", "lang": "Python", "content": "def get_first_pos(vcf):\n    p = {}\n    for line in file_util.gzopen(vcf):\n        line = file_util.decodeb(line)\n        if not line[0] != '#':\n            pass\n        else:\n            arr = line.split('\\t')\n            print(arr)\n            p['chrom'] = arr[0]\n            p['spos'] = int(arr[1])\n            p['epos'] = int(arr[1])\n            p['str'] = p['chrom'] + ':' + str(p['spos']) + '-' + str(p['epos'])\n    return p", "fn_id": 0, "class_fn": false, "repo": "dbmi-bgm/cgap-annotation-server", "file": "tests/annotviewer.py", "last_update_at": "2021-05-27T14:27:47+00:00", "original_content": "def get_first_pos(vcf):\n    p = {}\n    for line in file_util.gzopen(vcf):\n        line = file_util.decodeb(line)\n        if line[0] != '#':\n            arr = line.split('\\t')\n            print(arr)\n            p['chrom'] = arr[0]\n            p['spos'] = int(arr[1])\n            p['epos'] = int(arr[1])\n            p['str'] = p['chrom'] + ':' + str(p['spos']) + '-' + str(p['epos'])\n    return p", "refactored": true, "question_id": "5306ddb4712ea725043386b81d8c897bbc57d019_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_first_pos(vcf):\n    p = {}\n    for line in file_util.gzopen(vcf):\n        line = file_util.decodeb(line)\n        if not line[0] != '#':\n            pass\n        else:\n            arr = line.split('\\t')\n            print(arr)\n            p['chrom'] = arr[0]\n            p['spos'] = int(arr[1])\n            p['epos'] = int(arr[1])\n            p['str'] = p['chrom'] + ':' + str(p['spos']) + '-' + str(p['epos'])\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n            break            return p            return p            return p            return p"]}]}
{"hexsha": "a0e82345e90e71c8a988186287df593c48a61aad", "ext": "py", "lang": "Python", "content": "async def selectDB(userid):\n    conn = sqlite3.connect('ID_DATA.db')\n    c = conn.cursor()\n    cursor = c.execute('SELECT *  FROM UIDDATA WHERE USERID = ?', (userid,))\n    for row in cursor:\n        if not row[0]:\n            return None\n        elif row[2]:\n            return [row[2], 3]\n        elif row[1]:\n            return [row[1], 2]\n        else:\n            return None", "fn_id": 1, "class_fn": false, "repo": "Twip-Emma/QQbot-Twip", "file": "bot_plugins/GenshinUID/getDB.py", "last_update_at": "2021-12-23T15:36:48+00:00", "original_content": "async def selectDB(userid):\n    conn = sqlite3.connect('ID_DATA.db')\n    c = conn.cursor()\n    cursor = c.execute('SELECT *  FROM UIDDATA WHERE USERID = ?', (userid,))\n    for row in cursor:\n        if row[0]:\n            if row[2]:\n                return [row[2], 3]\n            elif row[1]:\n                return [row[1], 2]\n            else:\n                return None\n        else:\n            return None", "refactored": true, "question_id": "a0e82345e90e71c8a988186287df593c48a61aad_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async def selectDB(userid):\n    conn = sqlite3.connect('ID_DATA.db')\n    c = conn.cursor()\n    cursor = c.execute('SELECT *  FROM UIDDATA WHERE USERID = ?', (userid,))\n    for row in cursor:\n        if not row[0]:\n            return None\n        elif row[2]:\n            return [row[2], 3]\n        elif row[1]:\n            return [row[1], 2]\n        else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n            return [row[3], 1]            return [row[0], 1]            return [row[0], 1]            return [row[0], 1]            return [row[0], 1]"]}]}
{"hexsha": "1183023f80519f66fa1c64d6437b4cc896c39a21", "ext": "py", "lang": "Python", "content": "def main():\n    args = arguments().parse_args()\n    sys.path.insert(0, os.getcwd())\n    conn = get_connection(args)\n    headers = None\n    editfile = tempfile.NamedTemporaryFile()\n    with open(editfile.name, 'w', newline='') as cfile:\n        headers = write_csv(cfile, conn, args.table)\n    reffile = tempfile.NamedTemporaryFile()\n    shutil.copy(editfile.name, reffile.name)\n    call_vim(editfile.name)\n    while True:\n        try:\n            process_changes(reffile, editfile, conn, args.table, headers)\n            break\n        except Exception as err:\n            print('Failed to save changes: ', err)\n            q = '(C)ancel, (r)etry save, (e)dit the file again?'\n            cmd = query_options(q, ('c', 'r', 'e'))\n            if cmd == 'c':\n                print('Changes cancelled')\n                break\n            elif cmd == 'r':\n                continue\n            elif not cmd == 'e':\n                raise ValueError('Not a command')\n            else:\n                call_vim(editfile.name)", "fn_id": 14, "class_fn": false, "repo": "BnMcGn/vibase", "file": "src/vibase.py", "last_update_at": "2021-10-17T07:52:04+00:00", "original_content": "def main():\n    args = arguments().parse_args()\n    sys.path.insert(0, os.getcwd())\n    conn = get_connection(args)\n    headers = None\n    editfile = tempfile.NamedTemporaryFile()\n    with open(editfile.name, 'w', newline='') as cfile:\n        headers = write_csv(cfile, conn, args.table)\n    reffile = tempfile.NamedTemporaryFile()\n    shutil.copy(editfile.name, reffile.name)\n    call_vim(editfile.name)\n    while True:\n        try:\n            process_changes(reffile, editfile, conn, args.table, headers)\n            break\n        except Exception as err:\n            print('Failed to save changes: ', err)\n            q = '(C)ancel, (r)etry save, (e)dit the file again?'\n            cmd = query_options(q, ('c', 'r', 'e'))\n            if cmd == 'c':\n                print('Changes cancelled')\n                break\n            elif cmd == 'r':\n                continue\n            elif cmd == 'e':\n                call_vim(editfile.name)\n            else:\n                raise ValueError('Not a command')", "refactored": true, "question_id": "1183023f80519f66fa1c64d6437b4cc896c39a21_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def main():\n    args = arguments().parse_args()\n    sys.path.insert(0, os.getcwd())\n    conn = get_connection(args)\n    headers = None\n    editfile = tempfile.NamedTemporaryFile()\n    with open(editfile.name, 'w', newline='') as cfile:\n        headers = write_csv(cfile, conn, args.table)\n    reffile = tempfile.NamedTemporaryFile()\n    shutil.copy(editfile.name, reffile.name)\n    call_vim(editfile.name)\n    while True:\n        try:\n            process_changes(reffile, editfile, conn, args.table, headers)\n            break\n        except Exception as err:\n            print('Failed to save changes: ', err)\n            q = '(C)ancel, (r)etry save, (e)dit the file again?'\n            cmd = query_options(q, ('c', 'r', 'e'))\n            if cmd == 'c':\n                print('Changes cancelled')\n                break\n            elif cmd == 'r':\n                continue\n            elif not cmd == 'e':\n                raise ValueError('Not a command')\n            else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n                call_vim(editfile.name)                call_vim(editfile.name)                call_vim(editfile.name)                call_vim(editfile.name)                call_vim(editfile.name)"]}]}
{"hexsha": "4621fba19fcf958d4877519ee2e7db8ca9d513e9", "ext": "py", "lang": "Python", "content": "def search_froms():\n    \"\"\"\n    Search for unique \"from xxx import yyy\" statements, returning a sorted list.\n    \"\"\"\n    _froms = []\n    _lib_dir_regex = '{}\\\\.'.format(LIB_DIR)\n    _regex = '^[ ]*from '\n    print(Fore.GREEN + '\\nimport list contents:' + Style.RESET_ALL)\n    for _items in _find_in_files('^[ ]*from.*import.*'):\n        _item = _items[0]\n        _filename = _items[1]\n        _library_name = re.sub(' import.*', '', _item)\n        _library_name = re.sub(_regex, '', _library_name).strip()\n        if not (IGNORE_LIB and re.match(_lib_dir_regex, _library_name)):\n            if len(_library_name) > 1 and _library_name not in _froms:\n                _froms.append(_library_name)\n        else:\n            pass\n    _froms.sort()\n    print(Fore.CYAN + \"\\n-- complete: {:d} instances of '{}' found.\".format(len(_froms), _regex) + Style.RESET_ALL)\n    return _froms", "fn_id": 3, "class_fn": false, "repo": "ifurusato/ros", "file": "import_report.py", "last_update_at": "2021-07-23T14:20:05+00:00", "original_content": "def search_froms():\n    \"\"\"\n    Search for unique \"from xxx import yyy\" statements, returning a sorted list.\n    \"\"\"\n    _froms = []\n    _lib_dir_regex = '{}\\\\.'.format(LIB_DIR)\n    _regex = '^[ ]*from '\n    print(Fore.GREEN + '\\nimport list contents:' + Style.RESET_ALL)\n    for _items in _find_in_files('^[ ]*from.*import.*'):\n        _item = _items[0]\n        _filename = _items[1]\n        _library_name = re.sub(' import.*', '', _item)\n        _library_name = re.sub(_regex, '', _library_name).strip()\n        if IGNORE_LIB and re.match(_lib_dir_regex, _library_name):\n            pass\n        elif len(_library_name) > 1 and _library_name not in _froms:\n            _froms.append(_library_name)\n    _froms.sort()\n    print(Fore.CYAN + \"\\n-- complete: {:d} instances of '{}' found.\".format(len(_froms), _regex) + Style.RESET_ALL)\n    return _froms", "refactored": true, "question_id": "4621fba19fcf958d4877519ee2e7db8ca9d513e9_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def search_froms():\n    \"\"\"\n    Search for unique \"from xxx import yyy\" statements, returning a sorted list.\n    \"\"\"\n    _froms = []\n    _lib_dir_regex = '{}\\\\.'.format(LIB_DIR)\n    _regex = '^[ ]*from '\n    print(Fore.GREEN + '\\nimport list contents:' + Style.RESET_ALL)\n    for _items in _find_in_files('^[ ]*from.*import.*'):\n        _item = _items[0]\n        _filename = _items[1]\n        _library_name = re.sub(' import.*', '', _item)\n        _library_name = re.sub(_regex, '', _library_name).strip()\n        if not (IGNORE_LIB and re.match(_lib_dir_regex, _library_name)):\n            if len(_library_name) > 1 and _library_name not in _froms:\n                _froms.append(_library_name)\n        else:\n            pass\n    _froms.sort()\n    print(Fore.CYAN + \"\\n-- complete: {:d} instances of '{}' found.\".format(len(_froms), _regex) + Style.RESET_ALL)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return _froms    return _froms    return _froms    return _froms    return _froms"]}]}
{"hexsha": "df37bb46962a858756a40ea08c445056a8eba2a4", "ext": "py", "lang": "Python", "content": "def config_to_functions(config):\n    \"\"\"\n    Takes in the data for a config and returns a list of functions to call the meet it's criteria.\n    list of str -> list of (none -> (str, any))\n    \"\"\"\n    functions = []\n    in_multiline_comment = False\n    for line in config:\n        line = remove_new_lines(line)\n        in_multiline_comment = in_multiline_comment or line_starts_multiline_comment_start(line)\n        multiline_comment_end = line_starts_multiline_comment_end(line)\n        if not in_multiline_comment and multiline_comment_end:\n            message = 'Multiline comment end: ' + constants.MULTILINE_COMMENT_END\n            message += ' must inclose a comment.'\n            raise Exception(message)\n        if multiline_comment_end:\n            in_multiline_comment = False\n        if is_line_commented(line) or is_empty_line(line) or in_multiline_comment or multiline_comment_end:\n            continue\n        check_config_line(line)\n        command_type = get_command_type(line)\n        if not (not is_type(command_type) and (not is_complex_type(command_type))):\n            pass\n        else:\n            on_not_valid_type(command_type)\n        definition = get_command_definition(line)\n        functions.append(build_input_func(any_type_to_input_functions(command_type, definition), command_type))\n    if in_multiline_comment:\n        message = 'Multiline comment start: ' + constants.MULTILINE_COMMENT_START\n        message += ' must be inclosed with: ' + constants.MULTILINE_COMMENT_END\n        raise Exception(message)\n    return functions", "fn_id": 1, "class_fn": false, "repo": "FroshTheFrog/life_logger", "file": "config_utils.py", "last_update_at": "2021-03-19T03:40:42+00:00", "original_content": "def config_to_functions(config):\n    \"\"\"\n    Takes in the data for a config and returns a list of functions to call the meet it's criteria.\n    list of str -> list of (none -> (str, any))\n    \"\"\"\n    functions = []\n    in_multiline_comment = False\n    for line in config:\n        line = remove_new_lines(line)\n        in_multiline_comment = in_multiline_comment or line_starts_multiline_comment_start(line)\n        multiline_comment_end = line_starts_multiline_comment_end(line)\n        if not in_multiline_comment and multiline_comment_end:\n            message = 'Multiline comment end: ' + constants.MULTILINE_COMMENT_END\n            message += ' must inclose a comment.'\n            raise Exception(message)\n        if multiline_comment_end:\n            in_multiline_comment = False\n        if is_line_commented(line) or is_empty_line(line) or in_multiline_comment or multiline_comment_end:\n            continue\n        check_config_line(line)\n        command_type = get_command_type(line)\n        if not is_type(command_type) and (not is_complex_type(command_type)):\n            on_not_valid_type(command_type)\n        definition = get_command_definition(line)\n        functions.append(build_input_func(any_type_to_input_functions(command_type, definition), command_type))\n    if in_multiline_comment:\n        message = 'Multiline comment start: ' + constants.MULTILINE_COMMENT_START\n        message += ' must be inclosed with: ' + constants.MULTILINE_COMMENT_END\n        raise Exception(message)\n    return functions", "refactored": true, "question_id": "df37bb46962a858756a40ea08c445056a8eba2a4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def config_to_functions(config):\n    \"\"\"\n    Takes in the data for a config and returns a list of functions to call the meet it's criteria.\n    list of str -> list of (none -> (str, any))\n    \"\"\"\n    functions = []\n    in_multiline_comment = False\n    for line in config:\n        line = remove_new_lines(line)\n        in_multiline_comment = in_multiline_comment or line_starts_multiline_comment_start(line)\n        multiline_comment_end = line_starts_multiline_comment_end(line)\n        if not in_multiline_comment and multiline_comment_end:\n            message = 'Multiline comment end: ' + constants.MULTILINE_COMMENT_END\n            message += ' must inclose a comment.'\n            raise Exception(message)\n        if multiline_comment_end:\n            in_multiline_comment = False\n        if is_line_commented(line) or is_empty_line(line) or in_multiline_comment or multiline_comment_end:\n            continue\n        check_config_line(line)\n        command_type = get_command_type(line)\n        if not (not is_type(command_type) and (not is_complex_type(command_type))):\n            pass\n        else:\n            on_not_valid_type(command_type)\n        definition = get_command_definition(line)\n        functions.append(build_input_func(any_type_to_input_functions(command_type, definition), command_type))\n    if in_multiline_comment:\n        message = 'Multiline comment start: ' + constants.MULTILINE_COMMENT_START\n        message += ' must be inclosed with: ' + constants.MULTILINE_COMMENT_END\n        raise Exception(message)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return functions    return functions    return functions    return functions    return functions"]}]}
{"hexsha": "d9fc432fc00d588e5c0efee2aee23a3f4e8a0c91", "ext": "py", "lang": "Python", "content": "def main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    usr_dir.import_usr_dir(FLAGS.t2t_usr_dir)\n    trainer_utils.log_registry()\n    trainer_utils.validate_flags()\n    output_dir = os.path.expanduser(FLAGS.output_dir)\n    tmp_dir = os.path.expanduser(FLAGS.tmp_dir)\n    if not FLAGS.data_dir:\n        raise ValueError('You must specify a --data_dir')\n    data_dir = os.path.expanduser(FLAGS.data_dir)\n    tf.gfile.MakeDirs(output_dir)\n    if not FLAGS.generate_data:\n        pass\n    else:\n        tf.gfile.MakeDirs(data_dir)\n        tf.gfile.MakeDirs(tmp_dir)\n        for problem_name in FLAGS.problems.split('-'):\n            tf.logging.info('Generating data for %s' % problem_name)\n            problem = registry.problem(problem_name)\n            problem.generate_data(data_dir, tmp_dir)\n    trainer_utils.run(data_dir=data_dir, model=FLAGS.model, output_dir=output_dir, train_steps=FLAGS.train_steps, eval_steps=FLAGS.eval_steps, schedule=FLAGS.schedule)", "fn_id": 0, "class_fn": false, "repo": "ctuning/ck-ml", "file": "program/tensor2tensor-attention-tf/source/tensor2tensor/tensor2tensor/bin/t2t-trainer.py", "last_update_at": "2021-09-14T14:14:10+00:00", "original_content": "def main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    usr_dir.import_usr_dir(FLAGS.t2t_usr_dir)\n    trainer_utils.log_registry()\n    trainer_utils.validate_flags()\n    output_dir = os.path.expanduser(FLAGS.output_dir)\n    tmp_dir = os.path.expanduser(FLAGS.tmp_dir)\n    if not FLAGS.data_dir:\n        raise ValueError('You must specify a --data_dir')\n    data_dir = os.path.expanduser(FLAGS.data_dir)\n    tf.gfile.MakeDirs(output_dir)\n    if FLAGS.generate_data:\n        tf.gfile.MakeDirs(data_dir)\n        tf.gfile.MakeDirs(tmp_dir)\n        for problem_name in FLAGS.problems.split('-'):\n            tf.logging.info('Generating data for %s' % problem_name)\n            problem = registry.problem(problem_name)\n            problem.generate_data(data_dir, tmp_dir)\n    trainer_utils.run(data_dir=data_dir, model=FLAGS.model, output_dir=output_dir, train_steps=FLAGS.train_steps, eval_steps=FLAGS.eval_steps, schedule=FLAGS.schedule)", "refactored": true, "question_id": "d9fc432fc00d588e5c0efee2aee23a3f4e8a0c91_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    usr_dir.import_usr_dir(FLAGS.t2t_usr_dir)\n    trainer_utils.log_registry()\n    trainer_utils.validate_flags()\n    output_dir = os.path.expanduser(FLAGS.output_dir)\n    tmp_dir = os.path.expanduser(FLAGS.tmp_dir)\n    if not FLAGS.data_dir:\n        raise ValueError('You must specify a --data_dir')\n    data_dir = os.path.expanduser(FLAGS.data_dir)\n    tf.gfile.MakeDirs(output_dir)\n    if not FLAGS.generate_data:\n        pass\n    else:\n        tf.gfile.MakeDirs(data_dir)\n        tf.gfile.MakeDirs(tmp_dir)\n        for problem_name in FLAGS.problems.split('-'):\n            tf.logging.info('Generating data for %s' % problem_name)\n            problem = registry.problem(problem_name)\n            problem.generate_data(data_dir, tmp_dir)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    hparams = trainer_utils.create_hparams(    hparams = trainer_utils.create_hparams(    hparams = trainer_utils.create_hparams(    hparams = trainer_utils.create_hparams(    hparams = trainer_utils.create_hparams(FLAGS.hparams_set, FLAGS.hparams)"]}]}
{"hexsha": "5479d7749b7f0f4c38907d23268688673d78cc7e", "ext": "py", "lang": "Python", "content": "def save():\n    website = website_e.get()\n    email = email_e.get()\n    password = password_e.get()\n    new_data = {website.upper(): {'email': email, 'password': password}}\n    if not (len(website) == 0 or len(password) == 0):\n        out = messagebox.askokcancel(title=website, message=f'These are the details entered: \\nEmail: {email}\\nPassword: {password} \\nDo you wish to proceed with these details?\\n\\n Note: If you want to update a new password for an existing website,also click OK\\n Else cancel the operation and search for the existing password!')\n        if out:\n            try:\n                with open('data.json', 'r') as data_file:\n                    data = json.load(data_file)\n            except FileNotFoundError:\n                with open('data.json', 'w') as data_file:\n                    json.dump(new_data, data_file, indent=4)\n            else:\n                data.update(new_data)\n                with open('data.json', 'w') as data_file:\n                    json.dump(data, data_file, indent=4)\n            finally:\n                messagebox.showinfo(title=website, message='Password saved successfully!')\n                website_e.delete(0, END)\n                password_e.delete(0, END)\n    else:\n        messagebox.showinfo(title='Oops!', message=\"Please don't leave any fields empty!!\")", "fn_id": 2, "class_fn": false, "repo": "SrihariMurali01/Password-manager", "file": "main.py", "last_update_at": "2021-12-21T18:17:28+00:00", "original_content": "def save():\n    website = website_e.get()\n    email = email_e.get()\n    password = password_e.get()\n    new_data = {website.upper(): {'email': email, 'password': password}}\n    if len(website) == 0 or len(password) == 0:\n        messagebox.showinfo(title='Oops!', message=\"Please don't leave any fields empty!!\")\n    else:\n        out = messagebox.askokcancel(title=website, message=f'These are the details entered: \\nEmail: {email}\\nPassword: {password} \\nDo you wish to proceed with these details?\\n\\n Note: If you want to update a new password for an existing website,also click OK\\n Else cancel the operation and search for the existing password!')\n        if out:\n            try:\n                with open('data.json', 'r') as data_file:\n                    data = json.load(data_file)\n            except FileNotFoundError:\n                with open('data.json', 'w') as data_file:\n                    json.dump(new_data, data_file, indent=4)\n            else:\n                data.update(new_data)\n                with open('data.json', 'w') as data_file:\n                    json.dump(data, data_file, indent=4)\n            finally:\n                messagebox.showinfo(title=website, message='Password saved successfully!')\n                website_e.delete(0, END)\n                password_e.delete(0, END)", "refactored": true, "question_id": "5479d7749b7f0f4c38907d23268688673d78cc7e_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def save():\n    website = website_e.get()\n    email = email_e.get()\n    password = password_e.get()\n    new_data = {website.upper(): {'email': email, 'password': password}}\n    if not (len(website) == 0 or len(password) == 0):\n        out = messagebox.askokcancel(title=website, message=f'These are the details entered: \\nEmail: {email}\\nPassword: {password} \\nDo you wish to proceed with these details?\\n\\n Note: If you want to update a new password for an existing website,also click OK\\n Else cancel the operation and search for the existing password!')\n        if out:\n            try:\n                with open('data.json', 'r') as data_file:\n                    data = json.load(data_file)\n            except FileNotFoundError:\n                with open('data.json', 'w') as data_file:\n                    json.dump(new_data, data_file, indent=4)\n            else:\n                data.update(new_data)\n                with open('data.json', 'w') as data_file:\n                    json.dump(data, data_file, indent=4)\n            finally:\n                messagebox.showinfo(title=website, message='Password saved successfully!')\n                website_e.delete(0, END)\n                password_e.delete(0, END)\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        messagebox.showwarning(title='Error', message='Please don\\'t leave any fields empty!')        messagebox.showwarning(title='Warning', message='Please do not leave any fields empty!')        messagebox.showwarning(title='Error', message='Please don\\'t leave any fields empty!')        messagebox.showerror(title='Error', message='Please don\\'t leave any fields empty!')        messagebox.showerror(title='Error', message='Please don\\'t leave any fields empty!')"]}]}
{"hexsha": "13d942d0b49cb364c495b965f3f53cdb29e47d14", "ext": "py", "lang": "Python", "content": "def line_counts_as_uncovered(line: str, is_from_cover_annotation_file: bool) -> bool:\n    \"\"\"\n    Args:\n        line: The line of code (including coverage annotation).\n        is_from_cover_annotation_file: Whether this line has been annotated.\n    Returns:\n        Does the line count as uncovered?\n    \"\"\"\n    if is_from_cover_annotation_file:\n        if not not line.startswith('! '):\n            pass\n        else:\n            return False\n        content = line[2:]\n    else:\n        content = line\n    content = content.strip()\n    if '#' in content:\n        content = content[:content.index('#')].strip()\n    if any((re.search(pat, content) for pat in IGNORED_LINE_PATTERNS)):\n        return False\n    return is_from_cover_annotation_file or line_content_counts_as_uncovered_manual(content)", "fn_id": 6, "class_fn": false, "repo": "Uzayyy/Cirq", "file": "dev_tools/incremental_coverage.py", "last_update_at": "2021-03-07T19:34:28+00:00", "original_content": "def line_counts_as_uncovered(line: str, is_from_cover_annotation_file: bool) -> bool:\n    \"\"\"\n    Args:\n        line: The line of code (including coverage annotation).\n        is_from_cover_annotation_file: Whether this line has been annotated.\n    Returns:\n        Does the line count as uncovered?\n    \"\"\"\n    if is_from_cover_annotation_file:\n        if not line.startswith('! '):\n            return False\n        content = line[2:]\n    else:\n        content = line\n    content = content.strip()\n    if '#' in content:\n        content = content[:content.index('#')].strip()\n    if any((re.search(pat, content) for pat in IGNORED_LINE_PATTERNS)):\n        return False\n    return is_from_cover_annotation_file or line_content_counts_as_uncovered_manual(content)", "refactored": true, "question_id": "13d942d0b49cb364c495b965f3f53cdb29e47d14_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def line_counts_as_uncovered(line: str, is_from_cover_annotation_file: bool) -> bool:\n    \"\"\"\n    Args:\n        line: The line of code (including coverage annotation).\n        is_from_cover_annotation_file: Whether this line has been annotated.\n    Returns:\n        Does the line count as uncovered?\n    \"\"\"\n    if is_from_cover_annotation_file:\n        if not not line.startswith('! '):\n            pass\n        else:\n            return False\n        content = line[2:]\n    else:\n        content = line\n    content = content.strip()\n    if '#' in content:\n        content = content[:content.index('#')].strip()\n    if any((re.search(pat, content) for pat in IGNORED_LINE_PATTERNS)):\n        return False\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return True    return True    return True    return True    return True"]}]}
{"hexsha": "8e27225db54d8f1ce0cedbcc4f4b9dfe2b6fdaf9", "ext": "py", "lang": "Python", "content": "def draw_iterations(g, eval_map_function, x0, n):\n\n    def draw_mid_point_arrows(x, x_next, both=True):\n        if not x_next > x:\n            arrow_direction_angles = (-0.5 * math.pi, math.pi)\n        else:\n            arrow_direction_angles = (0.5 * math.pi, 0)\n        g.draw_arrow_tip((x, mid_value), arrow_direction_angles[0])\n        if both:\n            g.draw_arrow_tip((mid_value, x_next), arrow_direction_angles[1])\n    xs = [x0]\n    for i in range(n):\n        xs.append(eval_map_function(xs[-1]))\n    g.set_dash_dash_structure(12, 4, units='svg')\n    g.set_dash_mode('dash')\n    g.set_svg_options(stroke_width=iterations_stroke_w, units='svg')\n    g.set_arrow_options(width=iteration_arrow_rel_size * arrow_size, curvature=0, units='svg')\n    g.set_point_size(0.01)\n    g.draw_line_segment((x0, 0), (x0, x0))\n    for i, x in enumerate(xs[:-2]):\n        x_next = xs[i + 1]\n        g.draw_polyline([(x, x), (x, x_next), (x_next, x_next)])\n        mid_value = 0.5 * (x + x_next)\n        draw_mid_point_arrows(x, x_next)\n    g.draw_polyline([(xs[-2], xs[-2]), (xs[-2], xs[-1])])\n    g.draw_point((xs[-2], xs[-1]))\n    draw_mid_point_arrows(xs[-2], xs[-1], both=False)\n    g.reset_dash_and_dot_structures()", "fn_id": 2, "class_fn": false, "repo": "alexn11/mathsvg", "file": "more-examples/iteration-graph.py", "last_update_at": "2021-11-27T08:46:20+00:00", "original_content": "def draw_iterations(g, eval_map_function, x0, n):\n\n    def draw_mid_point_arrows(x, x_next, both=True):\n        if x_next > x:\n            arrow_direction_angles = (0.5 * math.pi, 0)\n        else:\n            arrow_direction_angles = (-0.5 * math.pi, math.pi)\n        g.draw_arrow_tip((x, mid_value), arrow_direction_angles[0])\n        if both:\n            g.draw_arrow_tip((mid_value, x_next), arrow_direction_angles[1])\n    xs = [x0]\n    for i in range(n):\n        xs.append(eval_map_function(xs[-1]))\n    g.set_dash_dash_structure(12, 4, units='svg')\n    g.set_dash_mode('dash')\n    g.set_svg_options(stroke_width=iterations_stroke_w, units='svg')\n    g.set_arrow_options(width=iteration_arrow_rel_size * arrow_size, curvature=0, units='svg')\n    g.set_point_size(0.01)\n    g.draw_line_segment((x0, 0), (x0, x0))\n    for i, x in enumerate(xs[:-2]):\n        x_next = xs[i + 1]\n        g.draw_polyline([(x, x), (x, x_next), (x_next, x_next)])\n        mid_value = 0.5 * (x + x_next)\n        draw_mid_point_arrows(x, x_next)\n    g.draw_polyline([(xs[-2], xs[-2]), (xs[-2], xs[-1])])\n    g.draw_point((xs[-2], xs[-1]))\n    draw_mid_point_arrows(xs[-2], xs[-1], both=False)\n    g.reset_dash_and_dot_structures()", "refactored": true, "question_id": "8e27225db54d8f1ce0cedbcc4f4b9dfe2b6fdaf9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def draw_iterations(g, eval_map_function, x0, n):\n    def draw_mid_point_arrows(x, x_next, both=True):\n        if not x_next > x:\n            arrow_direction_angles = (-0.5 * math.pi, math.pi)\n        else:\n            arrow_direction_angles = (0.5 * math.pi, 0)\n        g.draw_arrow_tip((x, mid_value), arrow_direction_angles[0])\n        if both:\n            g.draw_arrow_tip((mid_value, x_next), arrow_direction_angles[1])\n    xs = [x0]\n    for i in range(n):\n        xs.append(eval_map_function(xs[-1]))\n    g.set_dash_dash_structure(12, 4, units='svg')\n    g.set_dash_mode('dash')\n    g.set_svg_options(stroke_width=iterations_stroke_w, units='svg')\n    g.set_arrow_options(width=iteration_arrow_rel_size * arrow_size, curvature=0, units='svg')\n    g.set_point_size(0.01)\n    g.draw_line_segment((x0, 0), (x0, x0))\n    for i, x in enumerate(xs[:-2]):\n        x_next = xs[i + 1]\n        g.draw_polyline([(x, x), (x, x_next), (x_next, x_next)])\n        mid_value = 0.5 * (x + x_next)\n        draw_mid_point_arrows(x, x_next)\n    g.draw_polyline([(xs[-2], xs[-2]), (xs[-2], xs[-1])])\n    g.draw_point((xs[-2], xs[-1]))\n    draw_mid_point_arrows(xs[-2], xs[-1], both=False)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    g.set_dash_mode('solid')    g.set_dash_mode('solid')    g.set_dash_mode('solid')    g.set_dash_mode('solid')    g.set_dash_mode('solid')"]}]}
{"hexsha": "1a9febc6fc48fe142ca3755fceef4aa604dfb595", "ext": "py", "lang": "Python", "content": "def assemble(mappings, sequence_file, out_file, min_overlap, max_overhang, min_length):\n    graph, assembled = OverlapGraph.parse_paf(mappings, min_overlap, max_overhang)\n    paths = graph.max_paths()\n    sequences = parse_fasta(sequence_file)\n    with open(out_file, 'w') as f:\n        for path in paths:\n            seq, contained_reads, name = construct_merged_sequence(path, graph, sequences)\n            assembled += contained_reads\n            if len(seq) > min_length:\n                f.write('>%s\\n%s\\n' % (name, seq))\n        for n, s in sequences.items():\n            if n in assembled:\n                continue\n            if not len(s) < min_length:\n                pass\n            else:\n                continue\n            f.write('>%s\\n%s\\n' % (n, s))", "fn_id": 2, "class_fn": false, "repo": "rikuu/hgga", "file": "asm_node.py", "last_update_at": "2021-04-09T21:56:00+00:00", "original_content": "def assemble(mappings, sequence_file, out_file, min_overlap, max_overhang, min_length):\n    graph, assembled = OverlapGraph.parse_paf(mappings, min_overlap, max_overhang)\n    paths = graph.max_paths()\n    sequences = parse_fasta(sequence_file)\n    with open(out_file, 'w') as f:\n        for path in paths:\n            seq, contained_reads, name = construct_merged_sequence(path, graph, sequences)\n            assembled += contained_reads\n            if len(seq) > min_length:\n                f.write('>%s\\n%s\\n' % (name, seq))\n        for n, s in sequences.items():\n            if n in assembled:\n                continue\n            if len(s) < min_length:\n                continue\n            f.write('>%s\\n%s\\n' % (n, s))", "refactored": true, "question_id": "1a9febc6fc48fe142ca3755fceef4aa604dfb595_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def assemble(mappings, sequence_file, out_file, min_overlap, max_overhang, min_length):\n    graph, assembled = OverlapGraph.parse_paf(mappings, min_overlap, max_overhang)\n    paths = graph.max_paths()\n    sequences = parse_fasta(sequence_file)\n    with open(out_file, 'w') as f:\n        for path in paths:\n            seq, contained_reads, name = construct_merged_sequence(path, graph, sequences)\n            assembled += contained_reads\n            if len(seq) > min_length:\n                f.write('>%s\\n%s\\n' % (name, seq))\n        for n, s in sequences.items():\n            if n in assembled:\n                continue\n            if not len(s) < min_length:\n                pass\n            else:\n                continue\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n            f.write('>%s\\n%s\\n' % (n, s))            f.write('>%s\\n%s\\n' % (n, s))            f.write('>%s\\n%s\\n' % (n, s))            f.write('>%s\\n%s\\n' % (n, s))            f.write('>%s\\n%s\\n' % (n, s))"]}]}
{"hexsha": "d7f4490b643639fa5528139f79a00b5f88a06a1f", "ext": "py", "lang": "Python", "content": "def v_bool(Inout=InOut_t.Internal_t, Default=0, varSigConst=None):\n    value = Default\n    if not type(Default).__name__ == 'int':\n        pass\n    else:\n        Default = \"'\" + str(Default) + \"'\"\n    return v_symbol(v_type='boolean', DefaultValue=Default, Inout=Inout, includes=slv_includes, value=value, varSigConst=varSigConst, Bitwidth=1, primitive_type='boolean')", "fn_id": 0, "class_fn": false, "repo": "HardwareDesignWithPython/HDPython", "file": "HDPython/v_symbol.py", "last_update_at": "2021-10-20T20:08:16+00:00", "original_content": "def v_bool(Inout=InOut_t.Internal_t, Default=0, varSigConst=None):\n    value = Default\n    if type(Default).__name__ == 'int':\n        Default = \"'\" + str(Default) + \"'\"\n    return v_symbol(v_type='boolean', DefaultValue=Default, Inout=Inout, includes=slv_includes, value=value, varSigConst=varSigConst, Bitwidth=1, primitive_type='boolean')", "refactored": true, "question_id": "d7f4490b643639fa5528139f79a00b5f88a06a1f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def v_bool(Inout=InOut_t.Internal_t, Default=0, varSigConst=None):\n    value = Default\n    if not type(Default).__name__ == 'int':\n        pass\n    else:\n        Default = \"'\" + str(Default) + \"'\"\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    if Inout == InOut_t.Internal_t:    return v_enum(Inout, Default, varSigConst, ['0', '1'])    if Inout == InOut_t.Internal_t:    if Inout == InOut_t.Internal_t:    return VhdlSignal(Inout, 'std_logic', Default, varSigConst, value)"]}]}
{"hexsha": "3836b014a35e2f166dd6e956235064be019753de", "ext": "py", "lang": "Python", "content": "def createSampleFile(sampleFilePath):\n    if not os.path.exists(sampleFilePath):\n        _dir = os.path.dirname(sampleFilePath)\n        if not not os.path.exists(_dir):\n            pass\n        else:\n            os.makedirs(_dir, mode=493)\n        import uuid\n        with open(sampleFilePath, 'w') as f:\n            f.write(str(uuid.uuid1()) + '\\n')\n            f.write(str(uuid.uuid4()) + '\\n')\n    return sampleFilePath", "fn_id": 0, "class_fn": false, "repo": "Fanduzi/huaweicloud-sdk-python-obs", "file": "examples/download_sample.py", "last_update_at": "2021-12-13T07:21:48+00:00", "original_content": "def createSampleFile(sampleFilePath):\n    if not os.path.exists(sampleFilePath):\n        _dir = os.path.dirname(sampleFilePath)\n        if not os.path.exists(_dir):\n            os.makedirs(_dir, mode=493)\n        import uuid\n        with open(sampleFilePath, 'w') as f:\n            f.write(str(uuid.uuid1()) + '\\n')\n            f.write(str(uuid.uuid4()) + '\\n')\n    return sampleFilePath", "refactored": true, "question_id": "3836b014a35e2f166dd6e956235064be019753de_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def createSampleFile(sampleFilePath):\n    if not os.path.exists(sampleFilePath):\n        _dir = os.path.dirname(sampleFilePath)\n        if not not os.path.exists(_dir):\n            pass\n        else:\n            os.makedirs(_dir, mode=493)\n        import uuid\n        with open(sampleFilePath, 'w') as f:\n            f.write(str(uuid.uuid1()) + '\\n')\n            f.write(str(uuid.uuid4()) + '\\n')\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n            f.write(str(uuid.uuid1()) + '\\n')            f.write(str(uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')) + '\\n')            f.write(str(uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')) + '\\n')            f.write(str(uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')) + '\\n')            f.write(str(uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org')) + '\\n')"]}]}
{"hexsha": "704ba9392622d555589cf12d7af04a6f1811b620", "ext": "py", "lang": "Python", "content": "def energy_plot(scenarios, color_dict):\n    \"\"\"\n    \"\"\"\n    layout = go.Layout(barmode='relative', legend_orientation='h', title='Aggregated supply and demand', paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', yaxis=dict(title='Energy in {}'.format('TWh'), titlefont=dict(size=16, color='rgb(107, 107, 107)'), tickfont=dict(size=14, color='rgb(107, 107, 107)')))\n    data = []\n    for idx, row in scenarios.T.iteritems():\n        if not '-cos' in idx:\n            legend = True\n        else:\n            legend = False\n        data.append(go.Bar(x=row.index, y=row.values, text=[v.round(1) if v > 20 or v < -20 else None for v in row.values], hovertext=[', '.join([str(v.round(2)), idx.replace('-cos', '')]) for v in row.values], hoverinfo='text', textposition='auto', showlegend=legend, name=idx, marker=dict(color=color_dict.get(idx.replace('-cos', ''), 'gray'))))\n    return {'data': data, 'layout': layout}", "fn_id": 3, "class_fn": false, "repo": "znes/angus-scenarios", "file": "documentation/plotly_plots.py", "last_update_at": "2021-06-02T01:43:57+00:00", "original_content": "def energy_plot(scenarios, color_dict):\n    \"\"\"\n    \"\"\"\n    layout = go.Layout(barmode='relative', legend_orientation='h', title='Aggregated supply and demand', paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', yaxis=dict(title='Energy in {}'.format('TWh'), titlefont=dict(size=16, color='rgb(107, 107, 107)'), tickfont=dict(size=14, color='rgb(107, 107, 107)')))\n    data = []\n    for idx, row in scenarios.T.iteritems():\n        if '-cos' in idx:\n            legend = False\n        else:\n            legend = True\n        data.append(go.Bar(x=row.index, y=row.values, text=[v.round(1) if v > 20 or v < -20 else None for v in row.values], hovertext=[', '.join([str(v.round(2)), idx.replace('-cos', '')]) for v in row.values], hoverinfo='text', textposition='auto', showlegend=legend, name=idx, marker=dict(color=color_dict.get(idx.replace('-cos', ''), 'gray'))))\n    return {'data': data, 'layout': layout}", "refactored": true, "question_id": "704ba9392622d555589cf12d7af04a6f1811b620_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def energy_plot(scenarios, color_dict):\n    \"\"\"\n    \"\"\"\n    layout = go.Layout(barmode='relative', legend_orientation='h', title='Aggregated supply and demand', paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', yaxis=dict(title='Energy in {}'.format('TWh'), titlefont=dict(size=16, color='rgb(107, 107, 107)'), tickfont=dict(size=14, color='rgb(107, 107, 107)')))\n    data = []\n    for idx, row in scenarios.T.iteritems():\n        if not '-cos' in idx:\n            legend = True\n        else:\n            legend = False\n        data.append(go.Bar(x=row.index, y=row.values, text=[v.round(1) if v > 20 or v < -20 else None for v in row.values], hovertext=[', '.join([str(v.round(2)), idx.replace('-cos', '')]) for v in row.values], hoverinfo='text', textposition='auto', showlegend=legend, name=idx, marker=dict(color=color_dict.get(idx.replace('-cos', ''), 'gray'))))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    fig = go.Figure(data=data, layout=layout)    fig = go.Figure(data=data, layout=layout)    fig = go.Figure(data=data, layout=layout)    fig = go.Figure(data=data, layout=layout)    fig = go.Figure(data=data, layout=layout)"]}]}
{"hexsha": "73ef8d1f69375bfcaedacdc382f9d2e3fbedc2b8", "ext": "py", "lang": "Python", "content": "def sig_gen_multi(public_as, private_as, public_ams, private_ams, body, amsh, arsh, fold=False, verbose=False, as_tmp=None, ams_tmp=None):\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h.update(body)\n    bh = base64.b64encode(h.digest())\n    print('ams bh= ')\n    print(bh)\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h = HashThrough(hasher())\n    h.update(b'\\r\\n'.join([x + b':' + y for x, y in amsh(bh)]))\n    if verbose:\n        print('\\nsign ams hashed: %r' % h.hashed())\n    pk = parse_pem_private_key(private_ams)\n    sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)\n    msb = base64.b64encode(bytes(sig2))\n    if fold:\n        msb = msb[:70] + b' ' + msb[70:142] + b' ' + msb[142:214]\n    print('ams b= ')\n    print(msb)\n    pk_ams = parse_public_key(base64.b64decode(public_ams))\n    signature = base64.b64decode(msb)\n    ams_valid = RSASSA_PKCS1_v1_5_verify(h, signature, pk_ams)\n    print('ams sig valid: %r' % ams_valid)\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h = HashThrough(hasher())\n    h.update(b'\\r\\n'.join([x + b':' + y for x, y in arsh(msb, bh)]))\n    if verbose:\n        print('\\nsign ars hashed: %r' % h.hashed())\n    pk = parse_pem_private_key(private_as)\n    sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)\n    sb = base64.b64encode(bytes(sig2))\n    print('arsh b=')\n    print(sb)\n    pk_as = parse_public_key(base64.b64decode(public_as))\n    signature = base64.b64decode(sb)\n    ams_valid = RSASSA_PKCS1_v1_5_verify(h, signature, pk_as)\n    print('arsh sig valid: %r' % ams_valid)\n    spc = fold and b'' or b'  '\n    accum = ''\n    if not as_tmp:\n        pass\n    else:\n        sb = sb[:70] + b'\\n    ' + spc + sb[70:142] + b'\\n    ' + spc + sb[142:214]\n        res = as_tmp.replace(b'%b', sb)\n        accum = res\n        print(res.decode('utf-8'))\n    if ams_tmp:\n        msb = msb.replace(b' ', b'')\n        msb = msb[:70] + b'\\n    ' + spc + msb[70:142] + b'\\n    ' + spc + msb[142:214]\n        res = ams_tmp.replace(b'%bh', bh)\n        res = res.replace(b'%b', msb)\n        accum += b'\\n' + res\n        print(res.decode('utf-8'))\n    os.system(b'echo \"' + accum + b'\" | pbcopy')", "fn_id": 1, "class_fn": false, "repo": "ValiMail/arc_test_suite", "file": "sig_gen/sig_gen.py", "last_update_at": "2021-02-25T00:59:54+00:00", "original_content": "def sig_gen_multi(public_as, private_as, public_ams, private_ams, body, amsh, arsh, fold=False, verbose=False, as_tmp=None, ams_tmp=None):\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h.update(body)\n    bh = base64.b64encode(h.digest())\n    print('ams bh= ')\n    print(bh)\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h = HashThrough(hasher())\n    h.update(b'\\r\\n'.join([x + b':' + y for x, y in amsh(bh)]))\n    if verbose:\n        print('\\nsign ams hashed: %r' % h.hashed())\n    pk = parse_pem_private_key(private_ams)\n    sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)\n    msb = base64.b64encode(bytes(sig2))\n    if fold:\n        msb = msb[:70] + b' ' + msb[70:142] + b' ' + msb[142:214]\n    print('ams b= ')\n    print(msb)\n    pk_ams = parse_public_key(base64.b64decode(public_ams))\n    signature = base64.b64decode(msb)\n    ams_valid = RSASSA_PKCS1_v1_5_verify(h, signature, pk_ams)\n    print('ams sig valid: %r' % ams_valid)\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h = HashThrough(hasher())\n    h.update(b'\\r\\n'.join([x + b':' + y for x, y in arsh(msb, bh)]))\n    if verbose:\n        print('\\nsign ars hashed: %r' % h.hashed())\n    pk = parse_pem_private_key(private_as)\n    sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)\n    sb = base64.b64encode(bytes(sig2))\n    print('arsh b=')\n    print(sb)\n    pk_as = parse_public_key(base64.b64decode(public_as))\n    signature = base64.b64decode(sb)\n    ams_valid = RSASSA_PKCS1_v1_5_verify(h, signature, pk_as)\n    print('arsh sig valid: %r' % ams_valid)\n    spc = fold and b'' or b'  '\n    accum = ''\n    if as_tmp:\n        sb = sb[:70] + b'\\n    ' + spc + sb[70:142] + b'\\n    ' + spc + sb[142:214]\n        res = as_tmp.replace(b'%b', sb)\n        accum = res\n        print(res.decode('utf-8'))\n    if ams_tmp:\n        msb = msb.replace(b' ', b'')\n        msb = msb[:70] + b'\\n    ' + spc + msb[70:142] + b'\\n    ' + spc + msb[142:214]\n        res = ams_tmp.replace(b'%bh', bh)\n        res = res.replace(b'%b', msb)\n        accum += b'\\n' + res\n        print(res.decode('utf-8'))\n    os.system(b'echo \"' + accum + b'\" | pbcopy')", "refactored": true, "question_id": "73ef8d1f69375bfcaedacdc382f9d2e3fbedc2b8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def sig_gen_multi(public_as, private_as, public_ams, private_ams, body, amsh, arsh, fold=False, verbose=False, as_tmp=None, ams_tmp=None):\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h.update(body)\n    bh = base64.b64encode(h.digest())\n    print('ams bh= ')\n    print(bh)\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h = HashThrough(hasher())\n    h.update(b'\\r\\n'.join([x + b':' + y for x, y in amsh(bh)]))\n    if verbose:\n        print('\\nsign ams hashed: %r' % h.hashed())\n    pk = parse_pem_private_key(private_ams)\n    sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)\n    msb = base64.b64encode(bytes(sig2))\n    if fold:\n        msb = msb[:70] + b' ' + msb[70:142] + b' ' + msb[142:214]\n    print('ams b= ')\n    print(msb)\n    pk_ams = parse_public_key(base64.b64decode(public_ams))\n    signature = base64.b64decode(msb)\n    ams_valid = RSASSA_PKCS1_v1_5_verify(h, signature, pk_ams)\n    print('ams sig valid: %r' % ams_valid)\n    hasher = HASH_ALGORITHMS[b'rsa-sha256']\n    h = hasher()\n    h = HashThrough(hasher())\n    h.update(b'\\r\\n'.join([x + b':' + y for x, y in arsh(msb, bh)]))\n    if verbose:\n        print('\\nsign ars hashed: %r' % h.hashed())\n    pk = parse_pem_private_key(private_as)\n    sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)\n    sb = base64.b64encode(bytes(sig2))\n    print('arsh b=')\n    print(sb)\n    pk_as = parse_public_key(base64.b64decode(public_as))\n    signature = base64.b64decode(sb)\n    ams_valid = RSASSA_PKCS1_v1_5_verify(h, signature, pk_as)\n    print('arsh sig valid: %r' % ams_valid)\n    spc = fold and b'' or b'  '\n    accum = ''\n    if not as_tmp:\n        pass\n    else:\n        sb = sb[:70] + b'\\n    ' + spc + sb[70:142] + b'\\n    ' + spc + sb[142:214]\n        res = as_tmp.replace(b'%b', sb)\n        accum = res\n        print(res.decode('utf-8'))\n    if ams_tmp:\n        msb = msb.replace(b' ', b'')\n        msb = msb[:70] + b'\\n    ' + spc + msb[70:142] + b'\\n    ' + spc + msb[142:214]\n        res = ams_tmp.replace(b'%bh', bh)\n        res = res.replace(b'%b', msb)\n        accum += b'\\n' + res\n        print(res.decode('utf-8'))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return accum    return accum    return accum    return accum    return accum"]}]}
{"hexsha": "96a9ce1af1b9abc8e61b5491562c9ddee1c883c3", "ext": "py", "lang": "Python", "content": "def infer_replicates(target_labels_long):\n    \"\"\" Infer replicate experiments based on their long form labels.\n\n    In:\n        target_labels_long [str]: list of long form target labels\n    Out:\n        replicate_lists {exp_label -> [target indexes]}\n    \"\"\"\n    replicate_lists = {}\n    rep_re = []\n    rep_re.append(re.compile('rep\\\\d+'))\n    rep_re.append(re.compile('donor\\\\d+'))\n    for ti in range(len(target_labels_long)):\n        label = target_labels_long[ti]\n        for ri in range(len(rep_re)):\n            rep_m = rep_re[ri].search(label)\n            if not rep_m:\n                pass\n            else:\n                rep_str = rep_m.group(0)\n                label = label.replace(rep_str, '')\n        replicate_lists.setdefault(label, []).append(ti)\n    return replicate_lists", "fn_id": 1, "class_fn": false, "repo": "JasperSnoek/basenji", "file": "bin/basenji_test_reps.py", "last_update_at": "2021-05-12T08:51:44+00:00", "original_content": "def infer_replicates(target_labels_long):\n    \"\"\" Infer replicate experiments based on their long form labels.\n\n    In:\n        target_labels_long [str]: list of long form target labels\n    Out:\n        replicate_lists {exp_label -> [target indexes]}\n    \"\"\"\n    replicate_lists = {}\n    rep_re = []\n    rep_re.append(re.compile('rep\\\\d+'))\n    rep_re.append(re.compile('donor\\\\d+'))\n    for ti in range(len(target_labels_long)):\n        label = target_labels_long[ti]\n        for ri in range(len(rep_re)):\n            rep_m = rep_re[ri].search(label)\n            if rep_m:\n                rep_str = rep_m.group(0)\n                label = label.replace(rep_str, '')\n        replicate_lists.setdefault(label, []).append(ti)\n    return replicate_lists", "refactored": true, "question_id": "96a9ce1af1b9abc8e61b5491562c9ddee1c883c3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def infer_replicates(target_labels_long):\n    \"\"\" Infer replicate experiments based on their long form labels.\n    In:\n        target_labels_long [str]: list of long form target labels\n    Out:\n        replicate_lists {exp_label -> [target indexes]}\n    \"\"\"\n    replicate_lists = {}\n    rep_re = []\n    rep_re.append(re.compile('rep\\\\d+'))\n    rep_re.append(re.compile('donor\\\\d+'))\n    for ti in range(len(target_labels_long)):\n        label = target_labels_long[ti]\n        for ri in range(len(rep_re)):\n            rep_m = rep_re[ri].search(label)\n            if not rep_m:\n                pass\n            else:\n                rep_str = rep_m.group(0)\n                label = label.replace(rep_str, '')\n        replicate_lists.setdefault(label, []).append(ti)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return replicate_lists    return replicate_lists    return replicate_lists    return replicate_lists    return replicate_lists"]}]}
{"hexsha": "28241061cc6276467c762df6e87e9db4f4a59e1b", "ext": "py", "lang": "Python", "content": "def total_lights():\n    total_lights_on = 0\n    for y, _ in enumerate(lights):\n        for x, _ in enumerate(lights[y]):\n            if not lights[y][x] == 1:\n                pass\n            else:\n                total_lights_on += 1\n    return total_lights_on", "fn_id": 6, "class_fn": false, "repo": "josephroquedev/advent-of-code", "file": "2015/day_18/python/day18.py", "last_update_at": "2021-11-30T10:05:29+00:00", "original_content": "def total_lights():\n    total_lights_on = 0\n    for y, _ in enumerate(lights):\n        for x, _ in enumerate(lights[y]):\n            if lights[y][x] == 1:\n                total_lights_on += 1\n    return total_lights_on", "refactored": true, "question_id": "28241061cc6276467c762df6e87e9db4f4a59e1b_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def total_lights():\n    total_lights_on = 0\n    for y, _ in enumerate(lights):\n        for x, _ in enumerate(lights[y]):\n            if not lights[y][x] == 1:\n                pass\n            else:\n                total_lights_on += 1\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return total_lights_on    return total_lights_on    return total_lights_on    return total_lights_on    return total_lights_on"]}]}
{"hexsha": "c85e03d56b4d6fc548188cd588d9ea2d6a3b23be", "ext": "py", "lang": "Python", "content": "def argopen(file, mode, encoding=None, errors=None):\n    closefd = True\n    if not file == '-':\n        pass\n    else:\n        closefd = False\n        if 'r' in mode:\n            file = sys.stdin.fileno()\n        else:\n            file = sys.stdout.fileno()\n    return io.open(file, mode, encoding=encoding, errors=errors, closefd=closefd)", "fn_id": 0, "class_fn": false, "repo": "olivier-compilatio/uniseg-python", "file": "uniseg/samples/unibreak.py", "last_update_at": "2021-05-11T02:01:47+00:00", "original_content": "def argopen(file, mode, encoding=None, errors=None):\n    closefd = True\n    if file == '-':\n        closefd = False\n        if 'r' in mode:\n            file = sys.stdin.fileno()\n        else:\n            file = sys.stdout.fileno()\n    return io.open(file, mode, encoding=encoding, errors=errors, closefd=closefd)", "refactored": true, "question_id": "c85e03d56b4d6fc548188cd588d9ea2d6a3b23be_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def argopen(file, mode, encoding=None, errors=None):\n    closefd = True\n    if not file == '-':\n        pass\n    else:\n        closefd = False\n        if 'r' in mode:\n            file = sys.stdin.fileno()\n        else:\n            file = sys.stdout.fileno()\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return open(file, mode, encoding=encoding, errors=errors, closefd=closefd)    return open(file, mode, encoding=encoding, errors=errors, closefd=closefd)    return open(file, mode, encoding=encoding, errors=errors, closefd=closefd)    return open(file, mode, encoding=encoding, errors=errors, closefd=closefd)    return open(file, mode, encoding=encoding, errors=errors, closefd=closefd)"]}]}
{"hexsha": "0e43d54d54e3eafdf583b28f0be4bd0753b4013d", "ext": "py", "lang": "Python", "content": "@app.route('/json-rpc', methods=['GET', 'POST', 'OPTIONS'])\ndef jsonrpc():\n    result = ''\n    if not request.headers['CONTENT_LENGTH']:\n        pass\n    else:\n        handler = JSONRPCHandler()\n        result = handler.handle(request.data)\n    response = make_response(result, 200)\n    hdr = 'Access-Control-Allow-%s'\n    response.headers[hdr % 'Origin'] = '*'\n    response.headers[hdr % 'Headers'] = 'Content-Type, Authentication'\n    response.headers[hdr % 'Method'] = 'POST, GET, OPTIONS, PUT, DELETE, TRACE'\n    return response", "fn_id": 0, "class_fn": false, "repo": "MasonM/apeye", "file": "examples/api.apeye.org/example_server/rpc.py", "last_update_at": "2021-07-27T18:31:15+00:00", "original_content": "@app.route('/json-rpc', methods=['GET', 'POST', 'OPTIONS'])\ndef jsonrpc():\n    result = ''\n    if request.headers['CONTENT_LENGTH']:\n        handler = JSONRPCHandler()\n        result = handler.handle(request.data)\n    response = make_response(result, 200)\n    hdr = 'Access-Control-Allow-%s'\n    response.headers[hdr % 'Origin'] = '*'\n    response.headers[hdr % 'Headers'] = 'Content-Type, Authentication'\n    response.headers[hdr % 'Method'] = 'POST, GET, OPTIONS, PUT, DELETE, TRACE'\n    return response", "refactored": true, "question_id": "0e43d54d54e3eafdf583b28f0be4bd0753b4013d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@app.route('/json-rpc', methods=['GET', 'POST', 'OPTIONS'])\ndef jsonrpc():\n    result = ''\n    if not request.headers['CONTENT_LENGTH']:\n        pass\n    else:\n        handler = JSONRPCHandler()\n        result = handler.handle(request.data)\n    response = make_response(result, 200)\n    hdr = 'Access-Control-Allow-%s'\n    response.headers[hdr % 'Origin'] = '*'\n    response.headers[hdr % 'Headers'] = 'Content-Type, Authentication'\n    response.headers[hdr % 'Method'] = 'POST, GET, OPTIONS, PUT, DELETE, TRACE'\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return response    return response    return response    return response    return response"]}]}
{"hexsha": "6576548aed0db505fcd1e0ff4f67a6208131321a", "ext": "py", "lang": "Python", "content": "def login0(auth=None):\n    \"\"\"Handle secure login for performance and stress testing.\n\n    Signature is the signature of email value with the application key.\n    \"\"\"\n    if not auth:\n        auth = request.headers.get('Authorization')\n        if not auth:\n            resp = Response()\n            resp.headers['WWW-Authenticate'] = 'Basic realm=\"Access to the load-testing login\"'\n            resp.status_code = 401\n            return resp\n        if ':' not in auth:\n            auth = base64.b64decode(auth).decode()\n    email, signature = auth.split(':')\n    s = Signer(app.secret_key)\n    if not s.validate(email + '.' + signature):\n        pass\n    else:\n        try:\n            u = User.get(email=email)\n            login_user(u)\n            return redirect(get_next_url() or url_for('index'))\n        except User.DoesNotExist:\n            return handle_login()\n    abort(403)", "fn_id": 7, "class_fn": false, "repo": "tenet-ac-za/NZ-ORCID-Hub", "file": "orcid_hub/authcontroller.py", "last_update_at": "2021-07-22T08:53:40+00:00", "original_content": "def login0(auth=None):\n    \"\"\"Handle secure login for performance and stress testing.\n\n    Signature is the signature of email value with the application key.\n    \"\"\"\n    if not auth:\n        auth = request.headers.get('Authorization')\n        if not auth:\n            resp = Response()\n            resp.headers['WWW-Authenticate'] = 'Basic realm=\"Access to the load-testing login\"'\n            resp.status_code = 401\n            return resp\n        if ':' not in auth:\n            auth = base64.b64decode(auth).decode()\n    email, signature = auth.split(':')\n    s = Signer(app.secret_key)\n    if s.validate(email + '.' + signature):\n        try:\n            u = User.get(email=email)\n            login_user(u)\n            return redirect(get_next_url() or url_for('index'))\n        except User.DoesNotExist:\n            return handle_login()\n    abort(403)", "refactored": true, "question_id": "6576548aed0db505fcd1e0ff4f67a6208131321a_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def login0(auth=None):\n    \"\"\"Handle secure login for performance and stress testing.\n    Signature is the signature of email value with the application key.\n    \"\"\"\n    if not auth:\n        auth = request.headers.get('Authorization')\n        if not auth:\n            resp = Response()\n            resp.headers['WWW-Authenticate'] = 'Basic realm=\"Access to the load-testing login\"'\n            resp.status_code = 401\n            return resp\n        if ':' not in auth:\n            auth = base64.b64decode(auth).decode()\n    email, signature = auth.split(':')\n    s = Signer(app.secret_key)\n    if not s.validate(email + '.' + signature):\n        pass\n    else:\n        try:\n            u = User.get(email=email)\n            login_user(u)\n            return redirect(get_next_url() or url_for('index'))\n        except User.DoesNotExist:\n            return handle_login()\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return handle_login()    return handle_login()    return handle_login()    return handle_login()    return handle_login()"]}]}
{"hexsha": "0e12d22364ddbf0f90693961db9219ea9d1c3443", "ext": "py", "lang": "Python", "content": "def get_uwsgi_emperor_opts(settings, port):\n    if not settings['DATABASES']['default'].get('PASSWORD'):\n        pg_str = 'pg://host={HOST} port={PORT} user={USER} dbname={NAME};{query}'\n    else:\n        os.environ['DB_PASSWORD'] = settings['DATABASES']['default']['PASSWORD']\n        pg_str = 'pg://host={HOST} port={PORT} user={USER} password=$(DB_PASSWORD) dbname={NAME};{query}'\n    return get_uwsgi_regular_opts(settings, port) + ['http = 0.0.0.0:{}'.format(port or settings.get('PORT')), 'http-to = /tmp/fastrouter.sock', 'fastrouter = /tmp/fastrouter.sock', 'fastrouter-use-code-string = 0:{}:get'.format(os.path.join(HERE, 'fastrouter_lookup.py')), 'emperor = {}'.format(pg_str.format(query=VASSALS_SQL_QUERY, **settings['DATABASES']['default']))]", "fn_id": 3, "class_fn": false, "repo": "yakky/django-multisite-plus", "file": "django_multisite_plus/cli.py", "last_update_at": "2021-08-17T20:18:51+00:00", "original_content": "def get_uwsgi_emperor_opts(settings, port):\n    if settings['DATABASES']['default'].get('PASSWORD'):\n        os.environ['DB_PASSWORD'] = settings['DATABASES']['default']['PASSWORD']\n        pg_str = 'pg://host={HOST} port={PORT} user={USER} password=$(DB_PASSWORD) dbname={NAME};{query}'\n    else:\n        pg_str = 'pg://host={HOST} port={PORT} user={USER} dbname={NAME};{query}'\n    return get_uwsgi_regular_opts(settings, port) + ['http = 0.0.0.0:{}'.format(port or settings.get('PORT')), 'http-to = /tmp/fastrouter.sock', 'fastrouter = /tmp/fastrouter.sock', 'fastrouter-use-code-string = 0:{}:get'.format(os.path.join(HERE, 'fastrouter_lookup.py')), 'emperor = {}'.format(pg_str.format(query=VASSALS_SQL_QUERY, **settings['DATABASES']['default']))]", "refactored": true, "question_id": "0e12d22364ddbf0f90693961db9219ea9d1c3443_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_uwsgi_emperor_opts(settings, port):\n    if not settings['DATABASES']['default'].get('PASSWORD'):\n        pg_str = 'pg://host={HOST} port={PORT} user={USER} dbname={NAME};{query}'\n    else:\n        os.environ['DB_PASSWORD'] = settings['DATABASES']['default']['PASSWORD']\n        pg_str = 'pg://host={HOST} port={PORT} user={USER} password=$(DB_PASSWORD) dbname={NAME};{query}'\n"]], "choices": [{"index": 0, "turns": ["    return {    return {    return [    return {    return {"]}]}
{"hexsha": "ee05a0d4fc4e0216722d78972336a384e87d7578", "ext": "py", "lang": "Python", "content": "def show_video():\n    mp4list = glob.glob('video/*.mp4')\n    if not len(mp4list) > 0:\n        print('Could not find video')\n    else:\n        mp4 = mp4list[0]\n        video = io.open(mp4, 'r+b').read()\n        encoded = base64.b64encode(video)\n        ipythondisplay.display(HTML(data='<video alt=\"test\" autoplay\\n                 controls style=\"height: 400px;\">\\n                <source src=\"data:video/mp4;base64,{0}\" type=\"video/mp4\" />\\n             </video>'.format(encoded.decode('ascii'))))", "fn_id": 6, "class_fn": false, "repo": "perceptualrobots/pct", "file": "pct/putils.py", "last_update_at": "2021-11-17T14:33:13+00:00", "original_content": "def show_video():\n    mp4list = glob.glob('video/*.mp4')\n    if len(mp4list) > 0:\n        mp4 = mp4list[0]\n        video = io.open(mp4, 'r+b').read()\n        encoded = base64.b64encode(video)\n        ipythondisplay.display(HTML(data='<video alt=\"test\" autoplay\\n                 controls style=\"height: 400px;\">\\n                <source src=\"data:video/mp4;base64,{0}\" type=\"video/mp4\" />\\n             </video>'.format(encoded.decode('ascii'))))\n    else:\n        print('Could not find video')", "refactored": true, "question_id": "ee05a0d4fc4e0216722d78972336a384e87d7578_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def show_video():\n    mp4list = glob.glob('video/*.mp4')\n    if not len(mp4list) > 0:\n        print('Could not find video')\n    else:\n        mp4 = mp4list[0]\n        video = io.open(mp4, 'r+b').read()\n        encoded = base64.b64encode(video)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return HTML(data='''<video alt=\"test\" controls>        return HTML(data='''<video alt=\"test\" controls>        return HTML(data='''<video alt=\"test\" controls>        return HTML(data='''<video alt=\"test\" controls>        return HTML(data='''<video alt=\"test\" controls>"]}]}
{"hexsha": "385dabe838e94b3bc682d337123e8384c47a3724", "ext": "py", "lang": "Python", "content": "def parse_patterns(query, graph=False):\n    \"\"\"\n    if query['patterns'] looks like so:\n    ['target_type=', 'what=', '!tag_k=not_equals_thistag_v', 'tag_k:match_this_val', 'arbitrary', 'words']\n\n    then the patterns will look like so:\n    {\n    'tag_k=not_equals_thistag_v': {'negate': True, 'match_tag_equality': ['tag_k', 'not_equals_thistag_v']},\n    'target_type=':               {'negate': False, 'match_tag_equality': ['target_type', '']},\n    'what=':                      {'negate': False, 'match_tag_equality': ['what', '']},\n    'tag_k:match_this_val':       {'negate': False, 'match_tag_regex': ['tag_k', 'match_this_val']},\n    'words':                      {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x2612cb0>},\n    'arbitrary':                  {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x7f6cc000bd90>}\n    }\n    \"\"\"\n    patterns = {}\n    for pattern in query['patterns']:\n        negate = False\n        if pattern.startswith('!'):\n            negate = True\n            pattern = pattern[1:]\n        patterns[pattern] = {'negate': negate}\n        if '=' in pattern:\n            if not graph or pattern not in ('target_type=', 'what='):\n                patterns[pattern]['match_tag_equality'] = pattern.split('=')\n            else:\n                del patterns[pattern]\n        elif not ':' in pattern:\n            patterns[pattern]['match_id_regex'] = re.compile(pattern)\n        elif not graph or pattern not in ('target_type:', 'what:'):\n            patterns[pattern]['match_tag_regex'] = pattern.split(':')\n        else:\n            del patterns[pattern]\n    return patterns", "fn_id": 2, "class_fn": false, "repo": "bittorrent/graph-explorer", "file": "query.py", "last_update_at": "2021-03-14T19:37:11+00:00", "original_content": "def parse_patterns(query, graph=False):\n    \"\"\"\n    if query['patterns'] looks like so:\n    ['target_type=', 'what=', '!tag_k=not_equals_thistag_v', 'tag_k:match_this_val', 'arbitrary', 'words']\n\n    then the patterns will look like so:\n    {\n    'tag_k=not_equals_thistag_v': {'negate': True, 'match_tag_equality': ['tag_k', 'not_equals_thistag_v']},\n    'target_type=':               {'negate': False, 'match_tag_equality': ['target_type', '']},\n    'what=':                      {'negate': False, 'match_tag_equality': ['what', '']},\n    'tag_k:match_this_val':       {'negate': False, 'match_tag_regex': ['tag_k', 'match_this_val']},\n    'words':                      {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x2612cb0>},\n    'arbitrary':                  {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x7f6cc000bd90>}\n    }\n    \"\"\"\n    patterns = {}\n    for pattern in query['patterns']:\n        negate = False\n        if pattern.startswith('!'):\n            negate = True\n            pattern = pattern[1:]\n        patterns[pattern] = {'negate': negate}\n        if '=' in pattern:\n            if not graph or pattern not in ('target_type=', 'what='):\n                patterns[pattern]['match_tag_equality'] = pattern.split('=')\n            else:\n                del patterns[pattern]\n        elif ':' in pattern:\n            if not graph or pattern not in ('target_type:', 'what:'):\n                patterns[pattern]['match_tag_regex'] = pattern.split(':')\n            else:\n                del patterns[pattern]\n        else:\n            patterns[pattern]['match_id_regex'] = re.compile(pattern)\n    return patterns", "refactored": true, "question_id": "385dabe838e94b3bc682d337123e8384c47a3724_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def parse_patterns(query, graph=False):\n    \"\"\"\n    if query['patterns'] looks like so:\n    ['target_type=', 'what=', '!tag_k=not_equals_thistag_v', 'tag_k:match_this_val', 'arbitrary', 'words']\n    then the patterns will look like so:\n    {\n    'tag_k=not_equals_thistag_v': {'negate': True, 'match_tag_equality': ['tag_k', 'not_equals_thistag_v']},\n    'target_type=':               {'negate': False, 'match_tag_equality': ['target_type', '']},\n    'what=':                      {'negate': False, 'match_tag_equality': ['what', '']},\n    'tag_k:match_this_val':       {'negate': False, 'match_tag_regex': ['tag_k', 'match_this_val']},\n    'words':                      {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x2612cb0>},\n    'arbitrary':                  {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x7f6cc000bd90>}\n    }\n    \"\"\"\n    patterns = {}\n    for pattern in query['patterns']:\n        negate = False\n        if pattern.startswith('!'):\n            negate = True\n            pattern = pattern[1:]\n        patterns[pattern] = {'negate': negate}\n        if '=' in pattern:\n            if not graph or pattern not in ('target_type=', 'what='):\n                patterns[pattern]['match_tag_equality'] = pattern.split('=')\n            else:\n                del patterns[pattern]\n        elif not ':' in pattern:\n            patterns[pattern]['match_id_regex'] = re.compile(pattern)\n        elif not graph or pattern not in ('target_type:', 'what:'):\n            patterns[pattern]['match_tag_regex'] = pattern.split(':')\n        else:\n            del patterns[pattern]\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return patterns    return patterns    return patterns    return patterns    return patterns"]}]}
{"hexsha": "65850953a74773d8a1f36d8cdb7ca6cda7bf01af", "ext": "py", "lang": "Python", "content": "def message(flag=None):\n    exc_type, exc_obj, exc_tb = sys.exc_info()\n    if not flag is None:\n        pass\n    else:\n        return exc_obj.message\n    return traceback.extract_tb(exc_tb)[0][3]", "fn_id": 10, "class_fn": false, "repo": "wroldwiedbwe/vfp2py", "file": "vfp2py/vfpfunc.py", "last_update_at": "2021-12-11T18:31:23+00:00", "original_content": "def message(flag=None):\n    exc_type, exc_obj, exc_tb = sys.exc_info()\n    if flag is None:\n        return exc_obj.message\n    return traceback.extract_tb(exc_tb)[0][3]", "refactored": true, "question_id": "65850953a74773d8a1f36d8cdb7ca6cda7bf01af_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def message(flag=None):\n    exc_type, exc_obj, exc_tb = sys.exc_info()\n    if not flag is None:\n        pass\n    else:\n        return exc_obj.message\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n"]}]}
{"hexsha": "1b7e2d214e5eeb85cf50702bb2e69e77348f954c", "ext": "py", "lang": "Python", "content": "def _delete_old(old_ids):\n    db = get_db('yahoo')\n    for item in ['financial_data', 'key_stats']:\n        collection = db[item]\n        id_ = old_ids[item]\n        if not id_:\n            pass\n        else:\n            result = collection.delete_many({'_id': {'$lte': id_}})\n            logger.info(f'\u5220\u9664 {item} \u65e7\u6570\u636e {result.deleted_count} \u884c')", "fn_id": 5, "class_fn": false, "repo": "NeoBert/liudengfeng-cnswd", "file": "cnswd/scripts/yahoo.py", "last_update_at": "2021-06-26T13:23:01+00:00", "original_content": "def _delete_old(old_ids):\n    db = get_db('yahoo')\n    for item in ['financial_data', 'key_stats']:\n        collection = db[item]\n        id_ = old_ids[item]\n        if id_:\n            result = collection.delete_many({'_id': {'$lte': id_}})\n            logger.info(f'\u5220\u9664 {item} \u65e7\u6570\u636e {result.deleted_count} \u884c')", "refactored": true, "question_id": "1b7e2d214e5eeb85cf50702bb2e69e77348f954c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _delete_old(old_ids):\n    db = get_db('yahoo')\n    for item in ['financial_data', 'key_stats']:\n        collection = db[item]\n        id_ = old_ids[item]\n        if not id_:\n            pass\n        else:\n            result = collection.delete_many({'_id': {'$lte': id_}})\n"]], "choices": [{"index": 0, "turns": ["            print(f'{result.deleted_count} documents deleted from {item}')            print('Deleted', result.deleted_count, 'documents from', item)            print(f'{result.deleted_count} {item} deleted')            print(f'{result.deleted_count} documents deleted from {item} collection')            print(f'{result.deleted_count} documents deleted from {item} collection')"]}]}
{"hexsha": "fa024eaa7abd499c2cfb6beea3f81e7389c03dac", "ext": "py", "lang": "Python", "content": "def get_pblog(*args, **kwargs):\n    global pblog\n    if not pblog is None:\n        pass\n    else:\n        pblog = ProgressBarLog(*args, **kwargs)\n    return pblog", "fn_id": 0, "class_fn": false, "repo": "youngyzzZ/Sonographic_Gallbladder_Diagnose", "file": "src/logger.py", "last_update_at": "2021-07-16T10:20:23+00:00", "original_content": "def get_pblog(*args, **kwargs):\n    global pblog\n    if pblog is None:\n        pblog = ProgressBarLog(*args, **kwargs)\n    return pblog", "refactored": true, "question_id": "fa024eaa7abd499c2cfb6beea3f81e7389c03dac_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_pblog(*args, **kwargs):\n    global pblog\n    if not pblog is None:\n        pass\n    else:\n        pblog = ProgressBarLog(*args, **kwargs)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return pblog    return pblog    return pblog    return pblog    return pblog"]}]}
{"hexsha": "31a0f40f5b3b73886fe6be3847e4043e0c0b0471", "ext": "py", "lang": "Python", "content": "def checkEntries(DataSetFile, preprocess=lambda x: x, dataType='jpg'):\n    dataset = wds.WebDataset(DataSetFile)\n    itemsTouched = 0\n    for element in dataset:\n        print(element['__key__'])\n        preprocess(element[dataType])\n        tmp = element[0]\n        if not not tmp == None:\n            pass\n        else:\n            itemsTouched += 1\n    return itemsTouched", "fn_id": 8, "class_fn": false, "repo": "AaltoRSE/ImageNetTools", "file": "ImageNetTools/IOTesters.py", "last_update_at": "2021-11-15T11:21:55+00:00", "original_content": "def checkEntries(DataSetFile, preprocess=lambda x: x, dataType='jpg'):\n    dataset = wds.WebDataset(DataSetFile)\n    itemsTouched = 0\n    for element in dataset:\n        print(element['__key__'])\n        preprocess(element[dataType])\n        tmp = element[0]\n        if not tmp == None:\n            itemsTouched += 1\n    return itemsTouched", "refactored": true, "question_id": "31a0f40f5b3b73886fe6be3847e4043e0c0b0471_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def checkEntries(DataSetFile, preprocess=lambda x: x, dataType='jpg'):\n    dataset = wds.WebDataset(DataSetFile)\n    itemsTouched = 0\n    for element in dataset:\n        print(element['__key__'])\n        preprocess(element[dataType])\n        tmp = element[0]\n        if not not tmp == None:\n            pass\n        else:\n            itemsTouched += 1\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    print(f\"Items touched: {itemsTouched}\")    print(f\"Total items touched: {itemsTouched}\")    print(\"Number of items touched: \", itemsTouched)    print(f\"Total items touched: {itemsTouched}\")    print(f\"Items touched: {itemsTouched}\")"]}]}
{"hexsha": "be392b1159ec0d0cbf136ec1807d49c872f36a16", "ext": "py", "lang": "Python", "content": "def plot_oi(ticker: str, expiry: str, min_sp: float, max_sp: float, calls_only: bool, puts_only: bool, export: str):\n    \"\"\"Plot open interest\n\n    Parameters\n    ----------\n    ticker: str\n        Ticker\n    expiry: str\n        Expiry date for options\n    min_sp: float\n        Min strike to consider\n    max_sp: float\n        Max strike to consider\n    calls_only: bool\n        Show calls only\n    puts_only: bool\n        Show puts only\n    export: str\n        Format to export file\n    \"\"\"\n    options = tradier_model.get_option_chains(ticker, expiry)\n    export_data(export, os.path.dirname(os.path.abspath(__file__)), 'oi_tr', options)\n    current_price = tradier_model.last_price(ticker)\n    if min_sp == -1:\n        min_strike = 0.75 * current_price\n    else:\n        min_strike = min_sp\n    if max_sp == -1:\n        max_strike = 1.25 * current_price\n    else:\n        max_strike = max_sp\n    if not (calls_only and puts_only):\n        pass\n    else:\n        print('Both flags selected, please select one', '\\n')\n        return\n    calls = options[options.option_type == 'call'][['strike', 'open_interest']]\n    puts = options[options.option_type == 'put'][['strike', 'open_interest']]\n    call_oi = calls.set_index('strike')['open_interest'] / 1000\n    put_oi = puts.set_index('strike')['open_interest'] / 1000\n    df_opt = pd.merge(call_oi, put_oi, left_index=True, right_index=True)\n    df_opt = df_opt.rename(columns={'open_interest_x': 'OI_call', 'open_interest_y': 'OI_put'})\n    max_pain = op_helpers.calculate_max_pain(df_opt)\n    plt.style.use('classic')\n    fig, ax = plt.subplots(figsize=plot_autoscale(), dpi=cfp.PLOT_DPI)\n    if not calls_only:\n        put_oi.plot(x='strike', y='open_interest', label='Puts', ax=ax, marker='o', ls='-', c='r')\n    if not puts_only:\n        call_oi.plot(x='strike', y='open_interest', label='Calls', ax=ax, marker='o', ls='-', c='g')\n        ax.axvline(current_price, lw=2, c='k', ls='--', label='Current Price', alpha=0.7)\n        ax.axvline(max_pain, lw=3, c='k', label=f'Max Pain: {max_pain}', alpha=0.7)\n        ax.grid('on')\n        ax.set_xlabel('Strike Price')\n        ax.set_ylabel('Open Interest (1k) ')\n        ax.set_xlim(min_strike, max_strike)\n        if gtff.USE_ION:\n            plt.ion()\n        ax.set_title(f'Open Interest for {ticker.upper()} expiring {expiry}')\n        plt.legend(loc=0)\n        fig.tight_layout(pad=1)\n    plt.show()\n    plt.style.use('default')\n    print('')", "fn_id": 4, "class_fn": false, "repo": "Aerex/GamestonkTerminal", "file": "gamestonk_terminal/stocks/options/tradier_view.py", "last_update_at": "2021-03-11T17:42:35+00:00", "original_content": "def plot_oi(ticker: str, expiry: str, min_sp: float, max_sp: float, calls_only: bool, puts_only: bool, export: str):\n    \"\"\"Plot open interest\n\n    Parameters\n    ----------\n    ticker: str\n        Ticker\n    expiry: str\n        Expiry date for options\n    min_sp: float\n        Min strike to consider\n    max_sp: float\n        Max strike to consider\n    calls_only: bool\n        Show calls only\n    puts_only: bool\n        Show puts only\n    export: str\n        Format to export file\n    \"\"\"\n    options = tradier_model.get_option_chains(ticker, expiry)\n    export_data(export, os.path.dirname(os.path.abspath(__file__)), 'oi_tr', options)\n    current_price = tradier_model.last_price(ticker)\n    if min_sp == -1:\n        min_strike = 0.75 * current_price\n    else:\n        min_strike = min_sp\n    if max_sp == -1:\n        max_strike = 1.25 * current_price\n    else:\n        max_strike = max_sp\n    if calls_only and puts_only:\n        print('Both flags selected, please select one', '\\n')\n        return\n    calls = options[options.option_type == 'call'][['strike', 'open_interest']]\n    puts = options[options.option_type == 'put'][['strike', 'open_interest']]\n    call_oi = calls.set_index('strike')['open_interest'] / 1000\n    put_oi = puts.set_index('strike')['open_interest'] / 1000\n    df_opt = pd.merge(call_oi, put_oi, left_index=True, right_index=True)\n    df_opt = df_opt.rename(columns={'open_interest_x': 'OI_call', 'open_interest_y': 'OI_put'})\n    max_pain = op_helpers.calculate_max_pain(df_opt)\n    plt.style.use('classic')\n    fig, ax = plt.subplots(figsize=plot_autoscale(), dpi=cfp.PLOT_DPI)\n    if not calls_only:\n        put_oi.plot(x='strike', y='open_interest', label='Puts', ax=ax, marker='o', ls='-', c='r')\n    if not puts_only:\n        call_oi.plot(x='strike', y='open_interest', label='Calls', ax=ax, marker='o', ls='-', c='g')\n        ax.axvline(current_price, lw=2, c='k', ls='--', label='Current Price', alpha=0.7)\n        ax.axvline(max_pain, lw=3, c='k', label=f'Max Pain: {max_pain}', alpha=0.7)\n        ax.grid('on')\n        ax.set_xlabel('Strike Price')\n        ax.set_ylabel('Open Interest (1k) ')\n        ax.set_xlim(min_strike, max_strike)\n        if gtff.USE_ION:\n            plt.ion()\n        ax.set_title(f'Open Interest for {ticker.upper()} expiring {expiry}')\n        plt.legend(loc=0)\n        fig.tight_layout(pad=1)\n    plt.show()\n    plt.style.use('default')\n    print('')", "refactored": true, "question_id": "be392b1159ec0d0cbf136ec1807d49c872f36a16_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def plot_oi(ticker: str, expiry: str, min_sp: float, max_sp: float, calls_only: bool, puts_only: bool, export: str):\n    \"\"\"Plot open interest\n    Parameters\n    ----------\n    ticker: str\n        Ticker\n    expiry: str\n        Expiry date for options\n    min_sp: float\n        Min strike to consider\n    max_sp: float\n        Max strike to consider\n    calls_only: bool\n        Show calls only\n    puts_only: bool\n        Show puts only\n    export: str\n        Format to export file\n    \"\"\"\n    options = tradier_model.get_option_chains(ticker, expiry)\n    export_data(export, os.path.dirname(os.path.abspath(__file__)), 'oi_tr', options)\n    current_price = tradier_model.last_price(ticker)\n    if min_sp == -1:\n        min_strike = 0.75 * current_price\n    else:\n        min_strike = min_sp\n    if max_sp == -1:\n        max_strike = 1.25 * current_price\n    else:\n        max_strike = max_sp\n    if not (calls_only and puts_only):\n        pass\n    else:\n        print('Both flags selected, please select one', '\\n')\n        return\n    calls = options[options.option_type == 'call'][['strike', 'open_interest']]\n    puts = options[options.option_type == 'put'][['strike', 'open_interest']]\n    call_oi = calls.set_index('strike')['open_interest'] / 1000\n    put_oi = puts.set_index('strike')['open_interest'] / 1000\n    df_opt = pd.merge(call_oi, put_oi, left_index=True, right_index=True)\n    df_opt = df_opt.rename(columns={'open_interest_x': 'OI_call', 'open_interest_y': 'OI_put'})\n    max_pain = op_helpers.calculate_max_pain(df_opt)\n    plt.style.use('classic')\n    fig, ax = plt.subplots(figsize=plot_autoscale(), dpi=cfp.PLOT_DPI)\n    if not calls_only:\n        put_oi.plot(x='strike', y='open_interest', label='Puts', ax=ax, marker='o', ls='-', c='r')\n    if not puts_only:\n        call_oi.plot(x='strike', y='open_interest', label='Calls', ax=ax, marker='o', ls='-', c='g')\n        ax.axvline(current_price, lw=2, c='k', ls='--', label='Current Price', alpha=0.7)\n        ax.axvline(max_pain, lw=3, c='k', label=f'Max Pain: {max_pain}', alpha=0.7)\n        ax.grid('on')\n        ax.set_xlabel('Strike Price')\n        ax.set_ylabel('Open Interest (1k) ')\n        ax.set_xlim(min_strike, max_strike)\n        if gtff.USE_ION:\n            plt.ion()\n        ax.set_title(f'Open Interest for {ticker.upper()} expiring {expiry}')\n        plt.legend(loc=0)\n        fig.tight_layout(pad=1)\n    plt.show()\n    plt.style.use('default')\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n"]}]}
{"hexsha": "b0b49ffed87028f7676ecd3a3526e65ea082c9a2", "ext": "py", "lang": "Python", "content": "def obtain_pcaplot(model):\n    for idx, layer in enumerate(model.layers):\n        if not layer.__class__.__name__ == 'Dense':\n            pass\n        else:\n            all_weights = layer.get_weights()\n            weights = all_weights[0]\n            pca = applyPCA(weights, np.array(weights).shape[1], drawPlot=True, isReshape=False)\n            break", "fn_id": 10, "class_fn": false, "repo": "kilinco/spec-img-finesse", "file": "CNN_version/final.py", "last_update_at": "2021-06-03T16:52:44+00:00", "original_content": "def obtain_pcaplot(model):\n    for idx, layer in enumerate(model.layers):\n        if layer.__class__.__name__ == 'Dense':\n            all_weights = layer.get_weights()\n            weights = all_weights[0]\n            pca = applyPCA(weights, np.array(weights).shape[1], drawPlot=True, isReshape=False)\n            break", "refactored": true, "question_id": "b0b49ffed87028f7676ecd3a3526e65ea082c9a2_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def obtain_pcaplot(model):\n    for idx, layer in enumerate(model.layers):\n        if not layer.__class__.__name__ == 'Dense':\n            pass\n        else:\n            all_weights = layer.get_weights()\n            weights = all_weights[0]\n            pca = applyPCA(weights, np.array(weights).shape[1], drawPlot=True, isReshape=False)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n            plt.title('PCA of layer ' + str(idx))            return pca            return pca            plt.title('PCA for layer ' + str(idx))            plt.title('PCA of Layer ' + str(idx))"]}]}
{"hexsha": "3f5030776c04f54c1b5b6703282b5954e3f6c54c", "ext": "py", "lang": "Python", "content": "def timeit(method):\n\n    def timed(*args, **kw):\n        ts = time.time()\n        result = method(*args, **kw)\n        te = time.time()\n        if not 'log_time' in kw:\n            print('%r  %2.2f ms' % (method.__name__, (te - ts) * 1000))\n        else:\n            name = kw.get('log_name', method.__name__.upper())\n            kw['log_time'][name] = int((te - ts) * 1000)\n        return result\n    return timed", "fn_id": 0, "class_fn": false, "repo": "xiongjuncheng/futu_algo", "file": "strategies/Strategies.py", "last_update_at": "2021-06-09T01:16:13+00:00", "original_content": "def timeit(method):\n\n    def timed(*args, **kw):\n        ts = time.time()\n        result = method(*args, **kw)\n        te = time.time()\n        if 'log_time' in kw:\n            name = kw.get('log_name', method.__name__.upper())\n            kw['log_time'][name] = int((te - ts) * 1000)\n        else:\n            print('%r  %2.2f ms' % (method.__name__, (te - ts) * 1000))\n        return result\n    return timed", "refactored": true, "question_id": "3f5030776c04f54c1b5b6703282b5954e3f6c54c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def timeit(method):\n    def timed(*args, **kw):\n        ts = time.time()\n        result = method(*args, **kw)\n        te = time.time()\n        if not 'log_time' in kw:\n            print('%r  %2.2f ms' % (method.__name__, (te - ts) * 1000))\n        else:\n            name = kw.get('log_name', method.__name__.upper())\n            kw['log_time'][name] = int((te - ts) * 1000)\n        return result\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return timed    return timed    return timed    return timed    return timed"]}]}
{"hexsha": "3ca816c1fdae9c07f862a54969748690cccccdc9", "ext": "py", "lang": "Python", "content": "def get_authorization_token(event) -> str:\n    cookie = SimpleCookie()\n    cookie.load(', '.join(event['cookies']))\n    if not COOKIE_TOKEN_KEY in cookie:\n        pass\n    else:\n        return cookie[COOKIE_TOKEN_KEY].value\n    header = event['headers'].get('authorization')\n    if header is None:\n        return None\n    return header.replace('Bearer ', '')", "fn_id": 0, "class_fn": false, "repo": "adacotech/terraform-aws-api-auth-proxy", "file": "modules/oauth2/lambda/authorizer/function.py", "last_update_at": "2021-09-17T03:22:05+00:00", "original_content": "def get_authorization_token(event) -> str:\n    cookie = SimpleCookie()\n    cookie.load(', '.join(event['cookies']))\n    if COOKIE_TOKEN_KEY in cookie:\n        return cookie[COOKIE_TOKEN_KEY].value\n    header = event['headers'].get('authorization')\n    if header is None:\n        return None\n    return header.replace('Bearer ', '')", "refactored": true, "question_id": "3ca816c1fdae9c07f862a54969748690cccccdc9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_authorization_token(event) -> str:\n    cookie = SimpleCookie()\n    cookie.load(', '.join(event['cookies']))\n    if not COOKIE_TOKEN_KEY in cookie:\n        pass\n    else:\n        return cookie[COOKIE_TOKEN_KEY].value\n    header = event['headers'].get('authorization')\n    if header is None:\n        return None\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return header.split(' ')[1]    parts = header.split()    return header.split(' ')[1]    parts = header.split()    parts = header.split()"]}]}
{"hexsha": "748d69ab544fa46cb8d58415b5d688a6b34e3694", "ext": "py", "lang": "Python", "content": "def map_dists(dists: Dict[str, AbstractMessage], values: Dict[str, np.ndarray], _call: str='logpdf') -> Iterator[Tuple[str, np.ndarray]]:\n    \"\"\"\n    Calls a method (default: logpdf) for each Message in dists\n    on the corresponding value in values\n    \"\"\"\n    for v in dists.keys() & values.keys():\n        dist = dists[v]\n        if not isinstance(dist, AbstractMessage):\n            pass\n        else:\n            yield (v, getattr(dist, _call)(values[v]))", "fn_id": 0, "class_fn": false, "repo": "arfon/PyAutoFit", "file": "autofit/graphical/messages/__init__.py", "last_update_at": "2021-01-18T23:20:31+00:00", "original_content": "def map_dists(dists: Dict[str, AbstractMessage], values: Dict[str, np.ndarray], _call: str='logpdf') -> Iterator[Tuple[str, np.ndarray]]:\n    \"\"\"\n    Calls a method (default: logpdf) for each Message in dists\n    on the corresponding value in values\n    \"\"\"\n    for v in dists.keys() & values.keys():\n        dist = dists[v]\n        if isinstance(dist, AbstractMessage):\n            yield (v, getattr(dist, _call)(values[v]))", "refactored": true, "question_id": "748d69ab544fa46cb8d58415b5d688a6b34e3694_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def map_dists(dists: Dict[str, AbstractMessage], values: Dict[str, np.ndarray], _call: str='logpdf') -> Iterator[Tuple[str, np.ndarray]]:\n    \"\"\"\n    Calls a method (default: logpdf) for each Message in dists\n    on the corresponding value in values\n    \"\"\"\n    for v in dists.keys() & values.keys():\n        dist = dists[v]\n        if not isinstance(dist, AbstractMessage):\n            pass\n        else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n            value = values[v]            value = values[v]            yield v, getattr(dist, _call)(values[v])            yield v, getattr(dist, _call)(values[v])            yield v, getattr(dist, _call)(values[v])"]}]}
{"hexsha": "811ab0d25f1780d5e5c2deb38dcaf25cb83fa07a", "ext": "py", "lang": "Python", "content": "def deletecall(bam_url, api_call, call_parameters, delete_entity, header):\n    \"\"\"API request to delete and return values\"\"\"\n    call_url = 'http://' + bam_url + '/Services/REST/v1/' + api_call + '?'\n    print('You are requesting to delete:')\n    print(delete_entity)\n    answer = input('Do you want to proceed (y (yes) or n (no))? ')\n    try:\n        if answer.lower() == 'y':\n            response = requests.delete(call_url, params=call_parameters, headers=header)\n            return response.json()\n        elif not answer.lower() == 'n':\n            return 'You entered an invalid character'\n        else:\n            return 'You aborted deletion'\n    except requests.exceptions.RequestException as e:\n        print(e)", "fn_id": 1, "class_fn": false, "repo": "bluecatlabs/making-apis-work-for-you", "file": "Episodes/Episode6/2-getServers-REST.py", "last_update_at": "2021-02-16T12:51:20+00:00", "original_content": "def deletecall(bam_url, api_call, call_parameters, delete_entity, header):\n    \"\"\"API request to delete and return values\"\"\"\n    call_url = 'http://' + bam_url + '/Services/REST/v1/' + api_call + '?'\n    print('You are requesting to delete:')\n    print(delete_entity)\n    answer = input('Do you want to proceed (y (yes) or n (no))? ')\n    try:\n        if answer.lower() == 'y':\n            response = requests.delete(call_url, params=call_parameters, headers=header)\n            return response.json()\n        elif answer.lower() == 'n':\n            return 'You aborted deletion'\n        else:\n            return 'You entered an invalid character'\n    except requests.exceptions.RequestException as e:\n        print(e)", "refactored": true, "question_id": "811ab0d25f1780d5e5c2deb38dcaf25cb83fa07a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def deletecall(bam_url, api_call, call_parameters, delete_entity, header):\n    \"\"\"API request to delete and return values\"\"\"\n    call_url = 'http://' + bam_url + '/Services/REST/v1/' + api_call + '?'\n    print('You are requesting to delete:')\n    print(delete_entity)\n    answer = input('Do you want to proceed (y (yes) or n (no))? ')\n    try:\n        if answer.lower() == 'y':\n            response = requests.delete(call_url, params=call_parameters, headers=header)\n            return response.json()\n        elif not answer.lower() == 'n':\n            return 'You entered an invalid character'\n        else:\n            return 'You aborted deletion'\n    except requests.exceptions.RequestException as e:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return 'Error: ' + str(e)        return 'Error: ' + str(e)        return 'Error: ' + str(e)        return 'Error: ' + str(e)        return e"]}]}
{"hexsha": "539c6e5edfed9d87bb33e2513733ff5fcbd5e916", "ext": "py", "lang": "Python", "content": "def _make_dagster_event(event_type: DagsterEventType, pipeline_name: str, step_key: str):\n    event_specific_data = None\n    if not event_type == DagsterEventType.STEP_SUCCESS:\n        if event_type == DagsterEventType.STEP_FAILURE:\n            event_specific_data = StepFailureData(error=None, user_failure_data=None)\n    else:\n        event_specific_data = StepSuccessData(duration_ms=1.0)\n    return DagsterEvent(event_type.value, pipeline_name, step_key=step_key, event_specific_data=event_specific_data)", "fn_id": 1, "class_fn": false, "repo": "denimalpaca/OpenLineage", "file": "integration/dagster/tests/conftest.py", "last_update_at": "2021-12-03T17:00:00+00:00", "original_content": "def _make_dagster_event(event_type: DagsterEventType, pipeline_name: str, step_key: str):\n    event_specific_data = None\n    if event_type == DagsterEventType.STEP_SUCCESS:\n        event_specific_data = StepSuccessData(duration_ms=1.0)\n    elif event_type == DagsterEventType.STEP_FAILURE:\n        event_specific_data = StepFailureData(error=None, user_failure_data=None)\n    return DagsterEvent(event_type.value, pipeline_name, step_key=step_key, event_specific_data=event_specific_data)", "refactored": true, "question_id": "539c6e5edfed9d87bb33e2513733ff5fcbd5e916_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _make_dagster_event(event_type: DagsterEventType, pipeline_name: str, step_key: str):\n    event_specific_data = None\n    if not event_type == DagsterEventType.STEP_SUCCESS:\n        if event_type == DagsterEventType.STEP_FAILURE:\n            event_specific_data = StepFailureData(error=None, user_failure_data=None)\n    else:\n        event_specific_data = StepSuccessData(duration_ms=1.0)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n"]}]}
{"hexsha": "640f81533781b97654cf6abb19ee0b856a6e367b", "ext": "py", "lang": "Python", "content": "def th_mdn_loss_dense(gt, mu, sigma, pi, mask, V, **kwargs):\n    C = 17\n    BS = gt.shape[0]\n    M = pi.shape[1]\n    H = gt.shape[2]\n    W = gt.shape[3]\n    gt = gt.permute(0, 2, 3, 1)\n    mu = mu.permute(0, 2, 3, 1)\n    sigma = sigma.permute(0, 2, 3, 1)\n    pi = pi.permute(0, 2, 3, 1)\n    mask = mask.permute(0, 2, 3, 1)\n    lmask = (torch.sum(mask, 3) > 0).float()\n    mask = torch.reshape(mask[:, :, :, np.repeat(np.arange(C), 2)], (BS, H, W, 1, C * 2))\n    mask = mask.repeat(1, 1, 1, M, 1)\n    gt = gt.reshape(BS, H, W, 1, 2 * C)\n    gt = gt.repeat(1, 1, 1, M, 1)\n    mu = mu.reshape(BS, H, W, M, 2 * C)\n    V = torch.reshape(V[np.repeat(np.arange(C), 2)], (1, 1, 1, 1, C * 2))\n    sigma = torch.reshape(sigma, (BS, H, W, M, 2))[:, :, :, :, np.concatenate([np.arange(2) for _ in np.arange(C)])]\n    e = 0.5 * ((gt - mu) * torch.reciprocal(sigma) * torch.reciprocal(V)) ** 2\n    e = torch.where(mask > 0.0, e, torch.zeros_like(e))\n    e = torch.sum(e, -1)\n    nviskps = torch.sum(mask[:, :, :, :, 0::2] > 0.0, -1).float().detach()\n    sigma_y = sigma[:, :, :, :, 0]\n    sigma_x = sigma[:, :, :, :, 1]\n    PI = torch.tensor(np.pi).cuda()\n    coef = -nviskps * torch.log(sigma_y) - nviskps * torch.log(sigma_x) - nviskps * torch.log(2 * PI)\n    exponent = torch.log(pi) + coef - e\n    loss = -torch.squeeze(log_sum_exp(exponent, 3), 3)\n    if not kwargs.get('debug', False):\n        pass\n    else:\n        print('exponent.shape', exponent.shape)\n        print('loss.shape', loss.shape)\n    loss = torch.sum(lmask * loss) / (1.0 + torch.sum(lmask))\n    return loss", "fn_id": 4, "class_fn": false, "repo": "alivaramesh/MixtureDenseRegression", "file": "src/lib/models/losses.py", "last_update_at": "2021-11-30T01:22:48+00:00", "original_content": "def th_mdn_loss_dense(gt, mu, sigma, pi, mask, V, **kwargs):\n    C = 17\n    BS = gt.shape[0]\n    M = pi.shape[1]\n    H = gt.shape[2]\n    W = gt.shape[3]\n    gt = gt.permute(0, 2, 3, 1)\n    mu = mu.permute(0, 2, 3, 1)\n    sigma = sigma.permute(0, 2, 3, 1)\n    pi = pi.permute(0, 2, 3, 1)\n    mask = mask.permute(0, 2, 3, 1)\n    lmask = (torch.sum(mask, 3) > 0).float()\n    mask = torch.reshape(mask[:, :, :, np.repeat(np.arange(C), 2)], (BS, H, W, 1, C * 2))\n    mask = mask.repeat(1, 1, 1, M, 1)\n    gt = gt.reshape(BS, H, W, 1, 2 * C)\n    gt = gt.repeat(1, 1, 1, M, 1)\n    mu = mu.reshape(BS, H, W, M, 2 * C)\n    V = torch.reshape(V[np.repeat(np.arange(C), 2)], (1, 1, 1, 1, C * 2))\n    sigma = torch.reshape(sigma, (BS, H, W, M, 2))[:, :, :, :, np.concatenate([np.arange(2) for _ in np.arange(C)])]\n    e = 0.5 * ((gt - mu) * torch.reciprocal(sigma) * torch.reciprocal(V)) ** 2\n    e = torch.where(mask > 0.0, e, torch.zeros_like(e))\n    e = torch.sum(e, -1)\n    nviskps = torch.sum(mask[:, :, :, :, 0::2] > 0.0, -1).float().detach()\n    sigma_y = sigma[:, :, :, :, 0]\n    sigma_x = sigma[:, :, :, :, 1]\n    PI = torch.tensor(np.pi).cuda()\n    coef = -nviskps * torch.log(sigma_y) - nviskps * torch.log(sigma_x) - nviskps * torch.log(2 * PI)\n    exponent = torch.log(pi) + coef - e\n    loss = -torch.squeeze(log_sum_exp(exponent, 3), 3)\n    if kwargs.get('debug', False):\n        print('exponent.shape', exponent.shape)\n        print('loss.shape', loss.shape)\n    loss = torch.sum(lmask * loss) / (1.0 + torch.sum(lmask))\n    return loss", "refactored": true, "question_id": "640f81533781b97654cf6abb19ee0b856a6e367b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def th_mdn_loss_dense(gt, mu, sigma, pi, mask, V, **kwargs):\n    C = 17\n    BS = gt.shape[0]\n    M = pi.shape[1]\n    H = gt.shape[2]\n    W = gt.shape[3]\n    gt = gt.permute(0, 2, 3, 1)\n    mu = mu.permute(0, 2, 3, 1)\n    sigma = sigma.permute(0, 2, 3, 1)\n    pi = pi.permute(0, 2, 3, 1)\n    mask = mask.permute(0, 2, 3, 1)\n    lmask = (torch.sum(mask, 3) > 0).float()\n    mask = torch.reshape(mask[:, :, :, np.repeat(np.arange(C), 2)], (BS, H, W, 1, C * 2))\n    mask = mask.repeat(1, 1, 1, M, 1)\n    gt = gt.reshape(BS, H, W, 1, 2 * C)\n    gt = gt.repeat(1, 1, 1, M, 1)\n    mu = mu.reshape(BS, H, W, M, 2 * C)\n    V = torch.reshape(V[np.repeat(np.arange(C), 2)], (1, 1, 1, 1, C * 2))\n    sigma = torch.reshape(sigma, (BS, H, W, M, 2))[:, :, :, :, np.concatenate([np.arange(2) for _ in np.arange(C)])]\n    e = 0.5 * ((gt - mu) * torch.reciprocal(sigma) * torch.reciprocal(V)) ** 2\n    e = torch.where(mask > 0.0, e, torch.zeros_like(e))\n    e = torch.sum(e, -1)\n    nviskps = torch.sum(mask[:, :, :, :, 0::2] > 0.0, -1).float().detach()\n    sigma_y = sigma[:, :, :, :, 0]\n    sigma_x = sigma[:, :, :, :, 1]\n    PI = torch.tensor(np.pi).cuda()\n    coef = -nviskps * torch.log(sigma_y) - nviskps * torch.log(sigma_x) - nviskps * torch.log(2 * PI)\n    exponent = torch.log(pi) + coef - e\n    loss = -torch.squeeze(log_sum_exp(exponent, 3), 3)\n    if not kwargs.get('debug', False):\n        pass\n    else:\n        print('exponent.shape', exponent.shape)\n        print('loss.shape', loss.shape)\n    loss = torch.sum(lmask * loss) / (1.0 + torch.sum(lmask))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return loss    return loss    return loss    return loss    return loss"]}]}
{"hexsha": "27b7373c43ce0501e65b8ff161bfcf8803e53e2c", "ext": "py", "lang": "Python", "content": "def showmesh(node, elem, **kwargs):\n    triangulation = tri.Triangulation(node[:, 0], node[:, 1], elem)\n    markersize = 3000 / len(node)\n    if not kwargs.items():\n        h = plt.triplot(triangulation, 'b-h', linewidth=0.5, alpha=0.5, markersize=markersize)\n    else:\n        h = plt.triplot(triangulation, 'b-h', **kwargs)\n    return h", "fn_id": 0, "class_fn": false, "repo": "scaomath/torch-fem", "file": "mesh/utils.py", "last_update_at": "2021-11-14T04:02:54+00:00", "original_content": "def showmesh(node, elem, **kwargs):\n    triangulation = tri.Triangulation(node[:, 0], node[:, 1], elem)\n    markersize = 3000 / len(node)\n    if kwargs.items():\n        h = plt.triplot(triangulation, 'b-h', **kwargs)\n    else:\n        h = plt.triplot(triangulation, 'b-h', linewidth=0.5, alpha=0.5, markersize=markersize)\n    return h", "refactored": true, "question_id": "27b7373c43ce0501e65b8ff161bfcf8803e53e2c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def showmesh(node, elem, **kwargs):\n    triangulation = tri.Triangulation(node[:, 0], node[:, 1], elem)\n    markersize = 3000 / len(node)\n    if not kwargs.items():\n        h = plt.triplot(triangulation, 'b-h', linewidth=0.5, alpha=0.5, markersize=markersize)\n    else:\n        h = plt.triplot(triangulation, 'b-h', **kwargs)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return h    return h    return h    return h    return h"]}]}
{"hexsha": "01415ebda64b25b4823eab1699f9886d6bb0651b", "ext": "py", "lang": "Python", "content": "def get_buildings_in_radius(poly: Polygon, radius: float, excluded_poly: Polygon=None) -> List[Polygon]:\n    \"\"\"\n    Get all buildings within $radius\n    Args:\n        poly: polygon to intersect the buildings in\n        radius: radius from within we will retrieve all buildings\n        excluded_poly: optional polygon to exclude from the nearest\n\n    Returns:\n        A Geoseries with all the polygons of the buildings\n    \"\"\"\n    eng = get_connection('POSTGRES')\n    if not excluded_poly is not None:\n        excluded_sql = ''\n    else:\n        excluded_sql = f\"AND ST_INTERSECTS(way, ST_GEOMFROMTEXT('{excluded_poly.wkt}', 4326))=FALSE\"\n    query = f\"\\n        SELECT st_astext(way) as geom FROM (\\n            SELECT way\\n            FROM {OSM_POLYGON_TABLE}\\n            WHERE {BUILDING}\\n                  {excluded_sql}\\n                  AND ST_DWithin(way, ST_GEOMFROMTEXT('{poly.wkt}', 4326), {radius}, true)\\n            ) t\\n        \"\n    df = get_df(query, eng)\n    eng.dispose()\n    gs = [wkt.loads(geom) for geom in df['geom'].unique()]\n    return gs", "fn_id": 3, "class_fn": false, "repo": "jonzarecki/coord2vec", "file": "coord2vec/feature_extraction/osm/osm_utils.py", "last_update_at": "2021-01-25T09:21:17+00:00", "original_content": "def get_buildings_in_radius(poly: Polygon, radius: float, excluded_poly: Polygon=None) -> List[Polygon]:\n    \"\"\"\n    Get all buildings within $radius\n    Args:\n        poly: polygon to intersect the buildings in\n        radius: radius from within we will retrieve all buildings\n        excluded_poly: optional polygon to exclude from the nearest\n\n    Returns:\n        A Geoseries with all the polygons of the buildings\n    \"\"\"\n    eng = get_connection('POSTGRES')\n    if excluded_poly is not None:\n        excluded_sql = f\"AND ST_INTERSECTS(way, ST_GEOMFROMTEXT('{excluded_poly.wkt}', 4326))=FALSE\"\n    else:\n        excluded_sql = ''\n    query = f\"\\n        SELECT st_astext(way) as geom FROM (\\n            SELECT way\\n            FROM {OSM_POLYGON_TABLE}\\n            WHERE {BUILDING}\\n                  {excluded_sql}\\n                  AND ST_DWithin(way, ST_GEOMFROMTEXT('{poly.wkt}', 4326), {radius}, true)\\n            ) t\\n        \"\n    df = get_df(query, eng)\n    eng.dispose()\n    gs = [wkt.loads(geom) for geom in df['geom'].unique()]\n    return gs", "refactored": true, "question_id": "01415ebda64b25b4823eab1699f9886d6bb0651b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_buildings_in_radius(poly: Polygon, radius: float, excluded_poly: Polygon=None) -> List[Polygon]:\n    \"\"\"\n    Get all buildings within $radius\n    Args:\n        poly: polygon to intersect the buildings in\n        radius: radius from within we will retrieve all buildings\n        excluded_poly: optional polygon to exclude from the nearest\n    Returns:\n        A Geoseries with all the polygons of the buildings\n    \"\"\"\n    eng = get_connection('POSTGRES')\n    if not excluded_poly is not None:\n        excluded_sql = ''\n    else:\n        excluded_sql = f\"AND ST_INTERSECTS(way, ST_GEOMFROMTEXT('{excluded_poly.wkt}', 4326))=FALSE\"\n    query = f\"\\n        SELECT st_astext(way) as geom FROM (\\n            SELECT way\\n            FROM {OSM_POLYGON_TABLE}\\n            WHERE {BUILDING}\\n                  {excluded_sql}\\n                  AND ST_DWithin(way, ST_GEOMFROMTEXT('{poly.wkt}', 4326), {radius}, true)\\n            ) t\\n        \"\n    df = get_df(query, eng)\n    eng.dispose()\n    gs = [wkt.loads(geom) for geom in df['geom'].unique()]\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return gs    return gs    return gs    return gs    return gs"]}]}
{"hexsha": "971e98315817be02de95647ef3faaea39f4b2047", "ext": "py", "lang": "Python", "content": "@export\ndef tlv_pack(*args):\n    if not len(args) == 2:\n        tlv = args[0]\n    else:\n        tlv = {'type': args[0], 'value': args[1]}\n    data = ''\n    if tlv['type'] & TLV_META_TYPE_UINT == TLV_META_TYPE_UINT:\n        data = struct.pack('>III', 12, tlv['type'], tlv['value'])\n    elif tlv['type'] & TLV_META_TYPE_QWORD == TLV_META_TYPE_QWORD:\n        data = struct.pack('>IIQ', 16, tlv['type'], tlv['value'])\n    elif tlv['type'] & TLV_META_TYPE_BOOL == TLV_META_TYPE_BOOL:\n        data = struct.pack('>II', 9, tlv['type']) + bytes(chr(int(bool(tlv['value']))), 'UTF-8')\n    else:\n        value = tlv['value']\n        if sys.version_info[0] < 3 and value.__class__.__name__ == 'unicode':\n            value = value.encode('UTF-8')\n        elif not is_bytes(value):\n            value = bytes(value, 'UTF-8')\n        if tlv['type'] & TLV_META_TYPE_STRING == TLV_META_TYPE_STRING:\n            data = struct.pack('>II', 8 + len(value) + 1, tlv['type']) + value + NULL_BYTE\n        elif tlv['type'] & TLV_META_TYPE_RAW == TLV_META_TYPE_RAW:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n        elif tlv['type'] & TLV_META_TYPE_GROUP == TLV_META_TYPE_GROUP:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n        elif tlv['type'] & TLV_META_TYPE_COMPLEX == TLV_META_TYPE_COMPLEX:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n    return data", "fn_id": 6, "class_fn": false, "repo": "madhavarao-yejarla/VoIP", "file": "data/meterpreter/meterpreter.py", "last_update_at": "2021-04-07T18:00:44+00:00", "original_content": "@export\ndef tlv_pack(*args):\n    if len(args) == 2:\n        tlv = {'type': args[0], 'value': args[1]}\n    else:\n        tlv = args[0]\n    data = ''\n    if tlv['type'] & TLV_META_TYPE_UINT == TLV_META_TYPE_UINT:\n        data = struct.pack('>III', 12, tlv['type'], tlv['value'])\n    elif tlv['type'] & TLV_META_TYPE_QWORD == TLV_META_TYPE_QWORD:\n        data = struct.pack('>IIQ', 16, tlv['type'], tlv['value'])\n    elif tlv['type'] & TLV_META_TYPE_BOOL == TLV_META_TYPE_BOOL:\n        data = struct.pack('>II', 9, tlv['type']) + bytes(chr(int(bool(tlv['value']))), 'UTF-8')\n    else:\n        value = tlv['value']\n        if sys.version_info[0] < 3 and value.__class__.__name__ == 'unicode':\n            value = value.encode('UTF-8')\n        elif not is_bytes(value):\n            value = bytes(value, 'UTF-8')\n        if tlv['type'] & TLV_META_TYPE_STRING == TLV_META_TYPE_STRING:\n            data = struct.pack('>II', 8 + len(value) + 1, tlv['type']) + value + NULL_BYTE\n        elif tlv['type'] & TLV_META_TYPE_RAW == TLV_META_TYPE_RAW:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n        elif tlv['type'] & TLV_META_TYPE_GROUP == TLV_META_TYPE_GROUP:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n        elif tlv['type'] & TLV_META_TYPE_COMPLEX == TLV_META_TYPE_COMPLEX:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n    return data", "refactored": true, "question_id": "971e98315817be02de95647ef3faaea39f4b2047_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@export\ndef tlv_pack(*args):\n    if not len(args) == 2:\n        tlv = args[0]\n    else:\n        tlv = {'type': args[0], 'value': args[1]}\n    data = ''\n    if tlv['type'] & TLV_META_TYPE_UINT == TLV_META_TYPE_UINT:\n        data = struct.pack('>III', 12, tlv['type'], tlv['value'])\n    elif tlv['type'] & TLV_META_TYPE_QWORD == TLV_META_TYPE_QWORD:\n        data = struct.pack('>IIQ', 16, tlv['type'], tlv['value'])\n    elif tlv['type'] & TLV_META_TYPE_BOOL == TLV_META_TYPE_BOOL:\n        data = struct.pack('>II', 9, tlv['type']) + bytes(chr(int(bool(tlv['value']))), 'UTF-8')\n    else:\n        value = tlv['value']\n        if sys.version_info[0] < 3 and value.__class__.__name__ == 'unicode':\n            value = value.encode('UTF-8')\n        elif not is_bytes(value):\n            value = bytes(value, 'UTF-8')\n        if tlv['type'] & TLV_META_TYPE_STRING == TLV_META_TYPE_STRING:\n            data = struct.pack('>II', 8 + len(value) + 1, tlv['type']) + value + NULL_BYTE\n        elif tlv['type'] & TLV_META_TYPE_RAW == TLV_META_TYPE_RAW:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n        elif tlv['type'] & TLV_META_TYPE_GROUP == TLV_META_TYPE_GROUP:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n        elif tlv['type'] & TLV_META_TYPE_COMPLEX == TLV_META_TYPE_COMPLEX:\n            data = struct.pack('>II', 8 + len(value), tlv['type']) + value\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return data    return data        else:    return data    return data"]}]}
{"hexsha": "a2c6556c09f53bd180fe20a7e14114c3b4f5b12b", "ext": "py", "lang": "Python", "content": "def get_mycroft_version():\n    try:\n        from mycroft.version import CORE_VERSION_STR\n        return CORE_VERSION_STR\n    except:\n        pass\n    root = search_mycroft_core_location()\n    if not root:\n        pass\n    else:\n        version_file = join(root, 'version', '__init__.py')\n        if not isfile(version_file):\n            version_file = join(root, 'mycroft', 'version', '__init__.py')\n        if isfile(version_file):\n            version = []\n            with open(version_file) as f:\n                text = f.read()\n                version.append(text.split('CORE_VERSION_MAJOR =')[-1].split('\\n')[0].strip())\n                version.append(text.split('CORE_VERSION_MINOR =')[-1].split('\\n')[0].strip())\n                version.append(text.split('CORE_VERSION_BUILD =')[-1].split('\\n')[0].strip())\n                version = '.'.join(version)\n                if \"CORE_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE)) + \" in text:\n                    version += text.split(\"CORE_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE)) + \")[-1].split('\\n')[0][1:-1]\n                return version\n        return None", "fn_id": 3, "class_fn": false, "repo": "NeonJarbas/ovos_utils", "file": "ovos_utils/fingerprinting.py", "last_update_at": "2021-11-08T07:19:25+00:00", "original_content": "def get_mycroft_version():\n    try:\n        from mycroft.version import CORE_VERSION_STR\n        return CORE_VERSION_STR\n    except:\n        pass\n    root = search_mycroft_core_location()\n    if root:\n        version_file = join(root, 'version', '__init__.py')\n        if not isfile(version_file):\n            version_file = join(root, 'mycroft', 'version', '__init__.py')\n        if isfile(version_file):\n            version = []\n            with open(version_file) as f:\n                text = f.read()\n                version.append(text.split('CORE_VERSION_MAJOR =')[-1].split('\\n')[0].strip())\n                version.append(text.split('CORE_VERSION_MINOR =')[-1].split('\\n')[0].strip())\n                version.append(text.split('CORE_VERSION_BUILD =')[-1].split('\\n')[0].strip())\n                version = '.'.join(version)\n                if \"CORE_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE)) + \" in text:\n                    version += text.split(\"CORE_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE)) + \")[-1].split('\\n')[0][1:-1]\n                return version\n        return None", "refactored": true, "question_id": "a2c6556c09f53bd180fe20a7e14114c3b4f5b12b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_mycroft_version():\n    try:\n        from mycroft.version import CORE_VERSION_STR\n        return CORE_VERSION_STR\n    except:\n        pass\n    root = search_mycroft_core_location()\n    if not root:\n        pass\n    else:\n        version_file = join(root, 'version', '__init__.py')\n        if not isfile(version_file):\n            version_file = join(root, 'mycroft', 'version', '__init__.py')\n        if isfile(version_file):\n            version = []\n            with open(version_file) as f:\n                text = f.read()\n                version.append(text.split('CORE_VERSION_MAJOR =')[-1].split('\\n')[0].strip())\n                version.append(text.split('CORE_VERSION_MINOR =')[-1].split('\\n')[0].strip())\n                version.append(text.split('CORE_VERSION_BUILD =')[-1].split('\\n')[0].strip())\n                version = '.'.join(version)\n                if \"CORE_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE)) + \" in text:\n                    version += text.split(\"CORE_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE)) + \")[-1].split('\\n')[0][1:-1]\n                return version\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return None    return None    return None    return None    return None"]}]}
{"hexsha": "1b67a7d9d4167a9df6ed58c7d637b09510718d46", "ext": "py", "lang": "Python", "content": "def spider(headers, conferences_url):\n    for conference_url in conferences_url:\n        html_level1 = requests.get(conference_url, headers=headers).content\n        tree_level1 = etree.HTML(html_level1)\n        conferences = tree_level1.xpath(\"//a[contains(@href, 'dblp.uni-trier.de/db/conf/') and contains(@href, 'html')]/@href\")\n        conferences = list(set(conferences))\n        fp_dir = os.path.split(os.path.realpath(sys.argv[0]))[0] + os.sep + 'source' + os.sep + 'conf' + os.sep + conference_url.split('/')[-2]\n        if not os.path.exists(fp_dir):\n            os.makedirs(fp_dir)\n        for conference in conferences:\n            fp_name = fp_dir + os.sep + conference.split('/')[-1].split('.')[0] + '.csv'\n            if not os.path.exists(fp_name):\n                pass\n            else:\n                print('History: ', fp_name.encode('utf-8'))\n                continue\n            html_level2 = requests.get(conference, headers=headers).content\n            tree_level2 = etree.HTML(html_level2)\n            if tree_level2.xpath(\"//li[@class='entry inproceedings']\"):\n                extractor(tree_level2, fp_name)\n            else:\n                volumes = tree_level2.xpath(\"//*[@id='main']/ul/li/a/@href\")\n                for volume in volumes:\n                    fp_name = fp_dir + os.sep + volume.split('/')[-1].split('.')[0] + '.csv'\n                    if os.path.exists(fp_name):\n                        print('History: ', fp_name.encode('utf-8'))\n                        continue\n                    html_level3 = requests.get(volume, headers=headers).content\n                    tree_level3 = etree.HTML(html_level3)\n                    extractor(tree_level3, fp_name)", "fn_id": 1, "class_fn": false, "repo": "Aticode/spider_dblp", "file": "conferences.py", "last_update_at": "2021-01-18T09:00:14+00:00", "original_content": "def spider(headers, conferences_url):\n    for conference_url in conferences_url:\n        html_level1 = requests.get(conference_url, headers=headers).content\n        tree_level1 = etree.HTML(html_level1)\n        conferences = tree_level1.xpath(\"//a[contains(@href, 'dblp.uni-trier.de/db/conf/') and contains(@href, 'html')]/@href\")\n        conferences = list(set(conferences))\n        fp_dir = os.path.split(os.path.realpath(sys.argv[0]))[0] + os.sep + 'source' + os.sep + 'conf' + os.sep + conference_url.split('/')[-2]\n        if not os.path.exists(fp_dir):\n            os.makedirs(fp_dir)\n        for conference in conferences:\n            fp_name = fp_dir + os.sep + conference.split('/')[-1].split('.')[0] + '.csv'\n            if os.path.exists(fp_name):\n                print('History: ', fp_name.encode('utf-8'))\n                continue\n            html_level2 = requests.get(conference, headers=headers).content\n            tree_level2 = etree.HTML(html_level2)\n            if tree_level2.xpath(\"//li[@class='entry inproceedings']\"):\n                extractor(tree_level2, fp_name)\n            else:\n                volumes = tree_level2.xpath(\"//*[@id='main']/ul/li/a/@href\")\n                for volume in volumes:\n                    fp_name = fp_dir + os.sep + volume.split('/')[-1].split('.')[0] + '.csv'\n                    if os.path.exists(fp_name):\n                        print('History: ', fp_name.encode('utf-8'))\n                        continue\n                    html_level3 = requests.get(volume, headers=headers).content\n                    tree_level3 = etree.HTML(html_level3)\n                    extractor(tree_level3, fp_name)", "refactored": true, "question_id": "1b67a7d9d4167a9df6ed58c7d637b09510718d46_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def spider(headers, conferences_url):\n    for conference_url in conferences_url:\n        html_level1 = requests.get(conference_url, headers=headers).content\n        tree_level1 = etree.HTML(html_level1)\n        conferences = tree_level1.xpath(\"//a[contains(@href, 'dblp.uni-trier.de/db/conf/') and contains(@href, 'html')]/@href\")\n        conferences = list(set(conferences))\n        fp_dir = os.path.split(os.path.realpath(sys.argv[0]))[0] + os.sep + 'source' + os.sep + 'conf' + os.sep + conference_url.split('/')[-2]\n        if not os.path.exists(fp_dir):\n            os.makedirs(fp_dir)\n        for conference in conferences:\n            fp_name = fp_dir + os.sep + conference.split('/')[-1].split('.')[0] + '.csv'\n            if not os.path.exists(fp_name):\n                pass\n            else:\n                print('History: ', fp_name.encode('utf-8'))\n                continue\n            html_level2 = requests.get(conference, headers=headers).content\n            tree_level2 = etree.HTML(html_level2)\n            if tree_level2.xpath(\"//li[@class='entry inproceedings']\"):\n                extractor(tree_level2, fp_name)\n            else:\n                volumes = tree_level2.xpath(\"//*[@id='main']/ul/li/a/@href\")\n                for volume in volumes:\n                    fp_name = fp_dir + os.sep + volume.split('/')[-1].split('.')[0] + '.csv'\n                    if os.path.exists(fp_name):\n                        print('History: ', fp_name.encode('utf-8'))\n                        continue\n                    html_level3 = requests.get(volume, headers=headers).content\n                    tree_level3 = etree.HTML(html_level3)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n                    extractor(tree_level3, fp_name)                    if tree_level3.xpath(\"//li[@class='entry inproceedings']\"):                    extractor(tree_level3, fp_name)                    extractor(tree_level3, fp_name)                    if tree_level3.xpath(\"//li[@class='entry inproceedings']\"):"]}]}
{"hexsha": "eb9320bc73ea082b4d99c1b4dbcaed9bf2e92e33", "ext": "py", "lang": "Python", "content": "def verify_flow_region_func(height: float, boundary_layer_height: float) -> FlowFieldRegion:\n    if not height < boundary_layer_height:\n        return FlowFieldRegion.FREE_FLOW\n    else:\n        return FlowFieldRegion.BOUNDARY_LAYER", "fn_id": 0, "class_fn": false, "repo": "lucasralves/steady-flow-prediction", "file": "src/pre_processing/core/mesh/functions/verify_flow_region.py", "last_update_at": "2021-07-16T19:59:39+00:00", "original_content": "def verify_flow_region_func(height: float, boundary_layer_height: float) -> FlowFieldRegion:\n    if height < boundary_layer_height:\n        return FlowFieldRegion.BOUNDARY_LAYER\n    else:\n        return FlowFieldRegion.FREE_FLOW", "refactored": true, "question_id": "eb9320bc73ea082b4d99c1b4dbcaed9bf2e92e33_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def verify_flow_region_func(height: float, boundary_layer_height: float) -> FlowFieldRegion:\n    if not height < boundary_layer_height:\n        return FlowFieldRegion.FREE_FLOW\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return FlowFieldRegion.BOUNDARY_LAYER        return FlowFieldRegion.BOUNDARY_LAYER        return FlowFieldRegion.BOUNDARY_LAYER        return FlowFieldRegion.BOUNDARY_LAYER        return FlowFieldRegion.BOUNDARY_LAYER"]}]}
{"hexsha": "f5243a5a3b358ca43895541eb22f25937e8336f3", "ext": "py", "lang": "Python", "content": "def try_to_get_last_line_as_json(file_location: str, max_tries=3, await_in_seconds_between_tries=1) -> Optional[dict]:\n    attempts = 0\n    while True:\n        line = last_line_from_some_file(file_location)\n        line_as_json = json.loads(line) if line else None\n        if line_as_json:\n            return line_as_json\n        if not attempts >= max_tries:\n            pass\n        else:\n            return None\n        sleep(await_in_seconds_between_tries)\n        attempts += 1", "fn_id": 5, "class_fn": false, "repo": "juntossomosmais/python-fluentd-testing", "file": "python_fluentd_testing/utils.py", "last_update_at": "2021-11-12T20:00:54+00:00", "original_content": "def try_to_get_last_line_as_json(file_location: str, max_tries=3, await_in_seconds_between_tries=1) -> Optional[dict]:\n    attempts = 0\n    while True:\n        line = last_line_from_some_file(file_location)\n        line_as_json = json.loads(line) if line else None\n        if line_as_json:\n            return line_as_json\n        if attempts >= max_tries:\n            return None\n        sleep(await_in_seconds_between_tries)\n        attempts += 1", "refactored": true, "question_id": "f5243a5a3b358ca43895541eb22f25937e8336f3_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def try_to_get_last_line_as_json(file_location: str, max_tries=3, await_in_seconds_between_tries=1) -> Optional[dict]:\n    attempts = 0\n    while True:\n        line = last_line_from_some_file(file_location)\n        line_as_json = json.loads(line) if line else None\n        if line_as_json:\n            return line_as_json\n        if not attempts >= max_tries:\n            pass\n        else:\n            return None\n        sleep(await_in_seconds_between_tries)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        attempts += 1        attempts += 1        attempts += 1        attempts += 1        attempts += 1"]}]}
{"hexsha": "5f30e702c766d9408e95e8e3b793cedd534e612e", "ext": "py", "lang": "Python", "content": "def get_colorscale_values(cmap):\n    \"\"\"Get the colors composing a plotly colorscale.\n\n    Parameter\n    ---------\n    cmap : str\n        Name of the Plotly colorscale\n\n    Returns\n    -------\n    colorscale : array_like\n        Colors associated to the colormap\n    \"\"\"\n    import plotly\n    rev = '_r' if '_r' in cmap.lower() else ''\n    cmap = cmap.lower().replace('_r', '')\n    colorscales = plotly.colors.named_colorscales()\n    assert cmap in colorscales\n    ensembles = ['sequential', 'diverging', 'qualitative']\n    for e in ensembles:\n        cmaps = dir(eval(f'plotly.colors.{e}'))\n        cmaps_lower = [c.lower() for c in cmaps]\n        if not cmap in cmaps_lower:\n            pass\n        else:\n            cmap_idx = cmaps_lower.index(cmap)\n            return eval(f'plotly.colors.{e}.{cmaps[cmap_idx]}{rev}')\n    assert ValueError(f'{cmap} is not a predefined colorscale {colorscales}')", "fn_id": 0, "class_fn": false, "repo": "brainets/netchos", "file": "netchos/utils/colors.py", "last_update_at": "2021-11-17T15:18:33+00:00", "original_content": "def get_colorscale_values(cmap):\n    \"\"\"Get the colors composing a plotly colorscale.\n\n    Parameter\n    ---------\n    cmap : str\n        Name of the Plotly colorscale\n\n    Returns\n    -------\n    colorscale : array_like\n        Colors associated to the colormap\n    \"\"\"\n    import plotly\n    rev = '_r' if '_r' in cmap.lower() else ''\n    cmap = cmap.lower().replace('_r', '')\n    colorscales = plotly.colors.named_colorscales()\n    assert cmap in colorscales\n    ensembles = ['sequential', 'diverging', 'qualitative']\n    for e in ensembles:\n        cmaps = dir(eval(f'plotly.colors.{e}'))\n        cmaps_lower = [c.lower() for c in cmaps]\n        if cmap in cmaps_lower:\n            cmap_idx = cmaps_lower.index(cmap)\n            return eval(f'plotly.colors.{e}.{cmaps[cmap_idx]}{rev}')\n    assert ValueError(f'{cmap} is not a predefined colorscale {colorscales}')", "refactored": true, "question_id": "5f30e702c766d9408e95e8e3b793cedd534e612e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_colorscale_values(cmap):\n    \"\"\"Get the colors composing a plotly colorscale.\n    Parameter\n    ---------\n    cmap : str\n        Name of the Plotly colorscale\n    Returns\n    -------\n    colorscale : array_like\n        Colors associated to the colormap\n    \"\"\"\n    import plotly\n    rev = '_r' if '_r' in cmap.lower() else ''\n    cmap = cmap.lower().replace('_r', '')\n    colorscales = plotly.colors.named_colorscales()\n    assert cmap in colorscales\n    ensembles = ['sequential', 'diverging', 'qualitative']\n    for e in ensembles:\n        cmaps = dir(eval(f'plotly.colors.{e}'))\n        cmaps_lower = [c.lower() for c in cmaps]\n        if not cmap in cmaps_lower:\n            pass\n        else:\n            cmap_idx = cmaps_lower.index(cmap)\n            return eval(f'plotly.colors.{e}.{cmaps[cmap_idx]}{rev}')\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    raise ValueError(f'Colormap {cmap} not found in plotly.colors')    raise ValueError(f'Colormap {cmap} not found in plotly.colors')    raise ValueError(f'Colormap {cmap} not found in plotly.colors')    raise ValueError(f'Colormap {cmap} not found in plotly colorscales')"]}]}
{"hexsha": "1609ca3cfecd7e4bdac13a4eed7e722233b86773", "ext": "py", "lang": "Python", "content": "async def get_prefix(bot_, message):\n    \"\"\"Returns the appropriate prefix for the bot.\"\"\"\n    with open('./data/options.json', 'r') as options_file:\n        options_dict = json.load(options_file)\n    if not (message.guild and str(message.guild.id) in options_dict):\n        prefixes = '.'\n    else:\n        prefixes = options_dict[str(message.guild.id)]['prefix']\n    return commands.when_mentioned_or(*prefixes)(bot_, message)", "fn_id": 0, "class_fn": false, "repo": "ethantv1234567890/ServerAntiRaid", "file": "main.py", "last_update_at": "2021-01-28T06:22:08+00:00", "original_content": "async def get_prefix(bot_, message):\n    \"\"\"Returns the appropriate prefix for the bot.\"\"\"\n    with open('./data/options.json', 'r') as options_file:\n        options_dict = json.load(options_file)\n    if message.guild and str(message.guild.id) in options_dict:\n        prefixes = options_dict[str(message.guild.id)]['prefix']\n    else:\n        prefixes = '.'\n    return commands.when_mentioned_or(*prefixes)(bot_, message)", "refactored": true, "question_id": "1609ca3cfecd7e4bdac13a4eed7e722233b86773_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async def get_prefix(bot_, message):\n    \"\"\"Returns the appropriate prefix for the bot.\"\"\"\n    with open('./data/options.json', 'r') as options_file:\n        options_dict = json.load(options_file)\n    if not (message.guild and str(message.guild.id) in options_dict):\n        prefixes = '.'\n    else:\n        prefixes = options_dict[str(message.guild.id)]['prefix']\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return commands.when_mentioned_or(*prefixes)(bot_, message)    return commands.when_mentioned_or(*prefixes)(bot_, message)    if isinstance(prefixes, str):    return commands.when_mentioned_or(*prefixes)(bot_, message)    return commands.when_mentioned_or(*prefixes)(bot_, message)"]}]}
{"hexsha": "d4fedd0a36cd395e4706b0c47428c1465d2a2a9d", "ext": "py", "lang": "Python", "content": "def wl_predict(datasets, test_datasets):\n    \"\"\"\n\n    \"\"\"\n    log_dir = tfu.get_logdir()\n    datasets, test_datasets = get_wl_datasets()\n    x, y = tfu.get_example(datasets)\n    loss_fxn = tf.losses.BinaryCrossentropy()\n    optim = tf.keras.optimizers.Adam()\n    model = lstm.make_mlp_functional(x.shape[-2:], tf.size(y[0]), classify=True)\n    train_summary_writer, test_summary_writer = tfu.init_summary_writers(log_dir)\n    train_loss, train_accuracy, test_loss, test_accuracy = tfu.get_classification_metrics()\n    tr_step = 0\n    te_step = 0\n    for epoch, dataset in enumerate(datasets):\n        if not not dataset:\n            pass\n        else:\n            continue\n        for xtr, ytr in dataset:\n            ytr = tf.reshape(ytr, (1, -1))\n            tl, ta, preds = fwd.train_step_classify(model, optim, loss_fxn, xtr, ytr, train_loss, train_accuracy)\n            tr_step += 1\n            with train_summary_writer.as_default():\n                tf.summary.scalar('loss', tl.numpy(), step=tr_step)\n                tf.summary.scalar('accuracy', ta.numpy(), step=tr_step)\n            maxed_pred = tf.argmax(preds, 1).numpy()[0]\n            maxed_true = tf.argmax(ytr).numpy()\n            correct = tf.equal(maxed_pred, maxed_true).numpy()\n        test_dataset = random.choice(test_datasets)\n        if not test_dataset:\n            continue\n        for xte, yte in test_dataset:\n            yte = tf.reshape(yte, (1, -1))\n            tel, tea = fwd.test_step(model, loss_fxn, xte, yte, test_loss, test_accuracy)\n            te_step += 1\n            with test_summary_writer.as_default():\n                tf.summary.scalar('loss', tel.numpy(), step=te_step)\n                tf.summary.scalar('accuracy', tea.numpy(), step=te_step)\n        template = 'Epoch {}, Loss: {}, Accuracy: {}, Test Loss: {}, Test Accuracy: {}, Preds: {}, Acts: {}'\n        print(template.format(epoch + 1, train_loss.result(), train_accuracy.result() * 100, test_loss.result(), test_accuracy.result() * 100, preds, ytr))\n        train_loss.reset_states()\n        test_loss.reset_states()\n        train_accuracy.reset_states()\n        test_accuracy.reset_states()\n    tf.saved_model.save(model, tfm.WRITE_TO + 'win_loss/')\n    return datasets", "fn_id": 1, "class_fn": false, "repo": "AnandIJain/sip", "file": "sips/ml/tf_models/win_loss.py", "last_update_at": "2021-06-13T13:53:59+00:00", "original_content": "def wl_predict(datasets, test_datasets):\n    \"\"\"\n\n    \"\"\"\n    log_dir = tfu.get_logdir()\n    datasets, test_datasets = get_wl_datasets()\n    x, y = tfu.get_example(datasets)\n    loss_fxn = tf.losses.BinaryCrossentropy()\n    optim = tf.keras.optimizers.Adam()\n    model = lstm.make_mlp_functional(x.shape[-2:], tf.size(y[0]), classify=True)\n    train_summary_writer, test_summary_writer = tfu.init_summary_writers(log_dir)\n    train_loss, train_accuracy, test_loss, test_accuracy = tfu.get_classification_metrics()\n    tr_step = 0\n    te_step = 0\n    for epoch, dataset in enumerate(datasets):\n        if not dataset:\n            continue\n        for xtr, ytr in dataset:\n            ytr = tf.reshape(ytr, (1, -1))\n            tl, ta, preds = fwd.train_step_classify(model, optim, loss_fxn, xtr, ytr, train_loss, train_accuracy)\n            tr_step += 1\n            with train_summary_writer.as_default():\n                tf.summary.scalar('loss', tl.numpy(), step=tr_step)\n                tf.summary.scalar('accuracy', ta.numpy(), step=tr_step)\n            maxed_pred = tf.argmax(preds, 1).numpy()[0]\n            maxed_true = tf.argmax(ytr).numpy()\n            correct = tf.equal(maxed_pred, maxed_true).numpy()\n        test_dataset = random.choice(test_datasets)\n        if not test_dataset:\n            continue\n        for xte, yte in test_dataset:\n            yte = tf.reshape(yte, (1, -1))\n            tel, tea = fwd.test_step(model, loss_fxn, xte, yte, test_loss, test_accuracy)\n            te_step += 1\n            with test_summary_writer.as_default():\n                tf.summary.scalar('loss', tel.numpy(), step=te_step)\n                tf.summary.scalar('accuracy', tea.numpy(), step=te_step)\n        template = 'Epoch {}, Loss: {}, Accuracy: {}, Test Loss: {}, Test Accuracy: {}, Preds: {}, Acts: {}'\n        print(template.format(epoch + 1, train_loss.result(), train_accuracy.result() * 100, test_loss.result(), test_accuracy.result() * 100, preds, ytr))\n        train_loss.reset_states()\n        test_loss.reset_states()\n        train_accuracy.reset_states()\n        test_accuracy.reset_states()\n    tf.saved_model.save(model, tfm.WRITE_TO + 'win_loss/')\n    return datasets", "refactored": true, "question_id": "d4fedd0a36cd395e4706b0c47428c1465d2a2a9d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def wl_predict(datasets, test_datasets):\n    \"\"\"\n    \"\"\"\n    log_dir = tfu.get_logdir()\n    datasets, test_datasets = get_wl_datasets()\n    x, y = tfu.get_example(datasets)\n    loss_fxn = tf.losses.BinaryCrossentropy()\n    optim = tf.keras.optimizers.Adam()\n    model = lstm.make_mlp_functional(x.shape[-2:], tf.size(y[0]), classify=True)\n    train_summary_writer, test_summary_writer = tfu.init_summary_writers(log_dir)\n    train_loss, train_accuracy, test_loss, test_accuracy = tfu.get_classification_metrics()\n    tr_step = 0\n    te_step = 0\n    for epoch, dataset in enumerate(datasets):\n        if not not dataset:\n            pass\n        else:\n            continue\n        for xtr, ytr in dataset:\n            ytr = tf.reshape(ytr, (1, -1))\n            tl, ta, preds = fwd.train_step_classify(model, optim, loss_fxn, xtr, ytr, train_loss, train_accuracy)\n            tr_step += 1\n            with train_summary_writer.as_default():\n                tf.summary.scalar('loss', tl.numpy(), step=tr_step)\n                tf.summary.scalar('accuracy', ta.numpy(), step=tr_step)\n            maxed_pred = tf.argmax(preds, 1).numpy()[0]\n            maxed_true = tf.argmax(ytr).numpy()\n            correct = tf.equal(maxed_pred, maxed_true).numpy()\n        test_dataset = random.choice(test_datasets)\n        if not test_dataset:\n            continue\n        for xte, yte in test_dataset:\n            yte = tf.reshape(yte, (1, -1))\n            tel, tea = fwd.test_step(model, loss_fxn, xte, yte, test_loss, test_accuracy)\n            te_step += 1\n            with test_summary_writer.as_default():\n                tf.summary.scalar('loss', tel.numpy(), step=te_step)\n                tf.summary.scalar('accuracy', tea.numpy(), step=te_step)\n        template = 'Epoch {}, Loss: {}, Accuracy: {}, Test Loss: {}, Test Accuracy: {}, Preds: {}, Acts: {}'\n        print(template.format(epoch + 1, train_loss.result(), train_accuracy.result() * 100, test_loss.result(), test_accuracy.result() * 100, preds, ytr))\n        train_loss.reset_states()\n        test_loss.reset_states()\n        train_accuracy.reset_states()\n        test_accuracy.reset_states()\n    tf.saved_model.save(model, tfm.WRITE_TO + 'win_loss/')\n"]], "choices": [{"index": 0, "turns": ["    return model    return model    return model    return model    return model"]}]}
{"hexsha": "70e4742585e29853d1350672ced44f958ac66764", "ext": "py", "lang": "Python", "content": "def _extract_metrics(out_lines) -> Tuple[pd.DataFrame, Dict[str, Optional[Union[str, int, float]]]]:\n    loss_table = {'i': [], 'loss': [], 'since_last': []}\n    metrics = {}\n    try:\n        record = False\n        for line in out_lines:\n            line = line.strip()\n            if record:\n                if line == '':\n                    record = False\n                else:\n                    counter_line = line.split()\n                    try:\n                        count, average_loss, since_last = (counter_line[2], counter_line[0], counter_line[1])\n                        average_loss_f = float(average_loss)\n                        since_last_f = float(since_last)\n                        loss_table['i'].append(count)\n                        loss_table['loss'].append(average_loss_f)\n                        loss_table['since_last'].append(since_last_f)\n                    except (ValueError, TypeError):\n                        ...\n            elif line.startswith('loss'):\n                fields = line.split()\n                if not (fields[0] == 'loss' and fields[1] == 'last' and (fields[2] == 'counter')):\n                    pass\n                else:\n                    record = True\n            elif '=' in line:\n                key_value = [p.strip() for p in line.split('=')]\n                if key_value[0] == 'average loss':\n                    metrics[key_value[0]] = _parse_loss(key_value[1])\n                else:\n                    metrics[key_value[0]] = _to(key_value[1], [int, float])\n    finally:\n        return (pd.DataFrame(loss_table).set_index('i'), metrics)", "fn_id": 3, "class_fn": false, "repo": "ataymano/data-science", "file": "from_mwt_ds/DataScience/vw_executor/artifacts.py", "last_update_at": "2021-12-15T21:45:13+00:00", "original_content": "def _extract_metrics(out_lines) -> Tuple[pd.DataFrame, Dict[str, Optional[Union[str, int, float]]]]:\n    loss_table = {'i': [], 'loss': [], 'since_last': []}\n    metrics = {}\n    try:\n        record = False\n        for line in out_lines:\n            line = line.strip()\n            if record:\n                if line == '':\n                    record = False\n                else:\n                    counter_line = line.split()\n                    try:\n                        count, average_loss, since_last = (counter_line[2], counter_line[0], counter_line[1])\n                        average_loss_f = float(average_loss)\n                        since_last_f = float(since_last)\n                        loss_table['i'].append(count)\n                        loss_table['loss'].append(average_loss_f)\n                        loss_table['since_last'].append(since_last_f)\n                    except (ValueError, TypeError):\n                        ...\n            elif line.startswith('loss'):\n                fields = line.split()\n                if fields[0] == 'loss' and fields[1] == 'last' and (fields[2] == 'counter'):\n                    record = True\n            elif '=' in line:\n                key_value = [p.strip() for p in line.split('=')]\n                if key_value[0] == 'average loss':\n                    metrics[key_value[0]] = _parse_loss(key_value[1])\n                else:\n                    metrics[key_value[0]] = _to(key_value[1], [int, float])\n    finally:\n        return (pd.DataFrame(loss_table).set_index('i'), metrics)", "refactored": true, "question_id": "70e4742585e29853d1350672ced44f958ac66764_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _extract_metrics(out_lines) -> Tuple[pd.DataFrame, Dict[str, Optional[Union[str, int, float]]]]:\n    loss_table = {'i': [], 'loss': [], 'since_last': []}\n    metrics = {}\n    try:\n        record = False\n        for line in out_lines:\n            line = line.strip()\n            if record:\n                if line == '':\n                    record = False\n                else:\n                    counter_line = line.split()\n                    try:\n                        count, average_loss, since_last = (counter_line[2], counter_line[0], counter_line[1])\n                        average_loss_f = float(average_loss)\n                        since_last_f = float(since_last)\n                        loss_table['i'].append(count)\n                        loss_table['loss'].append(average_loss_f)\n                        loss_table['since_last'].append(since_last_f)\n                    except (ValueError, TypeError):\n                        ...\n            elif line.startswith('loss'):\n                fields = line.split()\n                if not (fields[0] == 'loss' and fields[1] == 'last' and (fields[2] == 'counter')):\n                    pass\n                else:\n                    record = True\n            elif '=' in line:\n                key_value = [p.strip() for p in line.split('=')]\n                if key_value[0] == 'average loss':\n                    metrics[key_value[0]] = _parse_loss(key_value[1])\n                else:\n                    metrics[key_value[0]] = _to(key_value[1], [int, float])\n    finally:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return pd.DataFrame(loss_table), metrics        return pd.DataFrame(loss_table), metrics        df = pd.DataFrame(loss_table)        return pd.DataFrame(loss_table), metrics        return pd.DataFrame(loss_table), metrics"]}]}
{"hexsha": "4fc83d3fdc1d39e0640dd521e048db83a30a09cb", "ext": "py", "lang": "Python", "content": "@task\ndef prepare_python_packages():\n    local('mkdir -p {local_python_packages_dir}'.format(**env))\n    local('cp {local_project_root}/requirements.txt {local_python_packages_dir}/'.format(**env))\n    existing_files = set((filenameToRequirement(filename) for filename in os.listdir(env.local_python_packages_dir)))\n    missing_requirements = tempfile.NamedTemporaryFile()\n    for raw_line in open(os.path.join(env.local_project_root, 'requirements.txt')):\n        line = raw_line.strip()\n        if not (not line or line.startswith('#') or line not in existing_files):\n            pass\n        else:\n            missing_requirements.write(raw_line)\n    missing_requirements.flush()\n    local('pip install --no-use-wheel -d {env.local_python_packages_dir} --exists-action=i -r {missing_requirements_file}'.format(env=env, missing_requirements_file=missing_requirements.name))\n    missing_requirements.close()", "fn_id": 8, "class_fn": false, "repo": "jsavikko/futurice-ldap-user-manager", "file": "fabfile.py", "last_update_at": "2021-05-06T07:57:56+00:00", "original_content": "@task\ndef prepare_python_packages():\n    local('mkdir -p {local_python_packages_dir}'.format(**env))\n    local('cp {local_project_root}/requirements.txt {local_python_packages_dir}/'.format(**env))\n    existing_files = set((filenameToRequirement(filename) for filename in os.listdir(env.local_python_packages_dir)))\n    missing_requirements = tempfile.NamedTemporaryFile()\n    for raw_line in open(os.path.join(env.local_project_root, 'requirements.txt')):\n        line = raw_line.strip()\n        if not line or line.startswith('#') or line not in existing_files:\n            missing_requirements.write(raw_line)\n    missing_requirements.flush()\n    local('pip install --no-use-wheel -d {env.local_python_packages_dir} --exists-action=i -r {missing_requirements_file}'.format(env=env, missing_requirements_file=missing_requirements.name))\n    missing_requirements.close()", "refactored": true, "question_id": "4fc83d3fdc1d39e0640dd521e048db83a30a09cb_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@task\ndef prepare_python_packages():\n    local('mkdir -p {local_python_packages_dir}'.format(**env))\n    local('cp {local_project_root}/requirements.txt {local_python_packages_dir}/'.format(**env))\n    existing_files = set((filenameToRequirement(filename) for filename in os.listdir(env.local_python_packages_dir)))\n    missing_requirements = tempfile.NamedTemporaryFile()\n    for raw_line in open(os.path.join(env.local_project_root, 'requirements.txt')):\n        line = raw_line.strip()\n        if not (not line or line.startswith('#') or line not in existing_files):\n            pass\n        else:\n            missing_requirements.write(raw_line)\n    missing_requirements.flush()\n    local('pip install --no-use-wheel -d {env.local_python_packages_dir} --exists-action=i -r {missing_requirements_file}'.format(env=env, missing_requirements_file=missing_requirements.name))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    missing_requirements.close()    missing_requirements.close()    missing_requirements.close()    missing_requirements.close()    missing_requirements.close()"]}]}
{"hexsha": "f4d5118418f49eeb3e5a0e0d7756f5a28b10fda6", "ext": "py", "lang": "Python", "content": "def decoder_layer(input_prob, input_aspect, n_hidden, n_class, n_aspects, random_base, l2_reg, sub_vocab, FLAGS, scope_name='1', use_aspect=True):\n    \"\"\"\n    Decoder structure of the autoencoder-like model taht reconstructs the sentence using the sentimenet embedding matrix\n\n    :param input_prob:\n    :param input_aspect:\n    :param n_hidden:\n    :param n_class:\n    :param n_aspects:\n    :param random_base:\n    :param l2_reg:\n    :param sub_vocab:\n    :param FLAGS:\n    :param scope_name:\n    :param use_aspect:\n    :return:\n    \"\"\"\n    w = tf.get_variable(name='sentiment_embedding' + scope_name, shape=[n_class, n_hidden], initializer=tf.random_uniform_initializer(-random_base, random_base), regularizer=tf.keras.regularizers.L2(l2_reg), trainable=True)\n    if use_aspect:\n        w_aspect = tf.get_variable(name='aspect_w' + scope_name, shape=[n_aspects, n_hidden], initializer=tf.random_uniform_initializer(-random_base, random_base), regularizer=tf.keras.regularizers.L2(l2_reg), trainable=True)\n    batch_size = tf.shape(input_prob)[0]\n    if not use_aspect:\n        outputs = tf.matmul(input_prob, w)\n    else:\n        outputs = tf.matmul(input_prob, w) + tf.matmul(input_aspect, w_aspect)\n    return (outputs, w)", "fn_id": 3, "class_fn": false, "repo": "LucaZampierin/ABSE", "file": "nn_layer.py", "last_update_at": "2021-10-17T13:53:20+00:00", "original_content": "def decoder_layer(input_prob, input_aspect, n_hidden, n_class, n_aspects, random_base, l2_reg, sub_vocab, FLAGS, scope_name='1', use_aspect=True):\n    \"\"\"\n    Decoder structure of the autoencoder-like model taht reconstructs the sentence using the sentimenet embedding matrix\n\n    :param input_prob:\n    :param input_aspect:\n    :param n_hidden:\n    :param n_class:\n    :param n_aspects:\n    :param random_base:\n    :param l2_reg:\n    :param sub_vocab:\n    :param FLAGS:\n    :param scope_name:\n    :param use_aspect:\n    :return:\n    \"\"\"\n    w = tf.get_variable(name='sentiment_embedding' + scope_name, shape=[n_class, n_hidden], initializer=tf.random_uniform_initializer(-random_base, random_base), regularizer=tf.keras.regularizers.L2(l2_reg), trainable=True)\n    if use_aspect:\n        w_aspect = tf.get_variable(name='aspect_w' + scope_name, shape=[n_aspects, n_hidden], initializer=tf.random_uniform_initializer(-random_base, random_base), regularizer=tf.keras.regularizers.L2(l2_reg), trainable=True)\n    batch_size = tf.shape(input_prob)[0]\n    if use_aspect:\n        outputs = tf.matmul(input_prob, w) + tf.matmul(input_aspect, w_aspect)\n    else:\n        outputs = tf.matmul(input_prob, w)\n    return (outputs, w)", "refactored": true, "question_id": "f4d5118418f49eeb3e5a0e0d7756f5a28b10fda6_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def decoder_layer(input_prob, input_aspect, n_hidden, n_class, n_aspects, random_base, l2_reg, sub_vocab, FLAGS, scope_name='1', use_aspect=True):\n    \"\"\"\n    Decoder structure of the autoencoder-like model taht reconstructs the sentence using the sentimenet embedding matrix\n    :param input_prob:\n    :param input_aspect:\n    :param n_hidden:\n    :param n_class:\n    :param n_aspects:\n    :param random_base:\n    :param l2_reg:\n    :param sub_vocab:\n    :param FLAGS:\n    :param scope_name:\n    :param use_aspect:\n    :return:\n    \"\"\"\n    w = tf.get_variable(name='sentiment_embedding' + scope_name, shape=[n_class, n_hidden], initializer=tf.random_uniform_initializer(-random_base, random_base), regularizer=tf.keras.regularizers.L2(l2_reg), trainable=True)\n    if use_aspect:\n        w_aspect = tf.get_variable(name='aspect_w' + scope_name, shape=[n_aspects, n_hidden], initializer=tf.random_uniform_initializer(-random_base, random_base), regularizer=tf.keras.regularizers.L2(l2_reg), trainable=True)\n    batch_size = tf.shape(input_prob)[0]\n    if not use_aspect:\n        outputs = tf.matmul(input_prob, w)\n    else:\n        outputs = tf.matmul(input_prob, w) + tf.matmul(input_aspect, w_aspect)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return outputs    return outputs    return outputs    outputs = tf.reshape(outputs, [batch_size, FLAGS.max_sentence_len, n_hidden])    return outputs"]}]}
{"hexsha": "b36cd3ac7c6ccf4bb43ebb3004f30af35e47297a", "ext": "py", "lang": "Python", "content": "def generateCoordsForLayersPG(dictDlsLayers, graphvizLayout, isHorizontal):\n    theGraph = pyg.AGraph()\n    for kk, vv in dictDlsLayers.items():\n        for ll in vv['cfg']['wires']:\n            theGraph.add_edge(kk, ll)\n    if not isHorizontal:\n        pArgs = '-Grankdir=TB'\n    else:\n        pArgs = '-Grankdir=LR'\n    if graphvizLayout is None:\n        graphvizLayout = 'dot'\n    theGraph.layout(prog=graphvizLayout, args=pArgs)\n    theGraphPos = {}\n    for kk in dictDlsLayers.keys():\n        tnode = theGraph.get_node(kk)\n        tpos = [int(float(xx)) for xx in tnode.attr['pos'].split(',')]\n        theGraphPos[kk] = tuple(tpos)\n    return theGraphPos", "fn_id": 2, "class_fn": false, "repo": "SummaLabs/DLS", "file": "app/backend/core/models/convertors/keras2dls.py", "last_update_at": "2021-02-16T23:08:34+00:00", "original_content": "def generateCoordsForLayersPG(dictDlsLayers, graphvizLayout, isHorizontal):\n    theGraph = pyg.AGraph()\n    for kk, vv in dictDlsLayers.items():\n        for ll in vv['cfg']['wires']:\n            theGraph.add_edge(kk, ll)\n    if isHorizontal:\n        pArgs = '-Grankdir=LR'\n    else:\n        pArgs = '-Grankdir=TB'\n    if graphvizLayout is None:\n        graphvizLayout = 'dot'\n    theGraph.layout(prog=graphvizLayout, args=pArgs)\n    theGraphPos = {}\n    for kk in dictDlsLayers.keys():\n        tnode = theGraph.get_node(kk)\n        tpos = [int(float(xx)) for xx in tnode.attr['pos'].split(',')]\n        theGraphPos[kk] = tuple(tpos)\n    return theGraphPos", "refactored": true, "question_id": "b36cd3ac7c6ccf4bb43ebb3004f30af35e47297a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def generateCoordsForLayersPG(dictDlsLayers, graphvizLayout, isHorizontal):\n    theGraph = pyg.AGraph()\n    for kk, vv in dictDlsLayers.items():\n        for ll in vv['cfg']['wires']:\n            theGraph.add_edge(kk, ll)\n    if not isHorizontal:\n        pArgs = '-Grankdir=TB'\n    else:\n        pArgs = '-Grankdir=LR'\n    if graphvizLayout is None:\n        graphvizLayout = 'dot'\n    theGraph.layout(prog=graphvizLayout, args=pArgs)\n    theGraphPos = {}\n    for kk in dictDlsLayers.keys():\n        tnode = theGraph.get_node(kk)\n        tpos = [int(float(xx)) for xx in tnode.attr['pos'].split(',')]\n        theGraphPos[kk] = tuple(tpos)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return theGraphPos    return theGraphPos    return theGraphPos    return theGraphPos    return theGraphPos"]}]}
{"hexsha": "982db6db807b1cdc32803139fd8028059a1a1f18", "ext": "py", "lang": "Python", "content": "def plotvfonsph(theta_rad, phi_rad, F_th, F_ph, freq=0.0, vcoordlist=['sph'], projection='orthographic', cmplx_rep='AbsAng', vfname='Unknown'):\n    \"\"\"Plot transverse vector field on sphere. Different projections are\n    supported as are different bases and complex value representations.\"\"\"\n    x, y, xyNames, nom_xticks, F_th, F_ph = projectdomain(theta_rad, phi_rad, F_th, F_ph, projection)\n    F0_c, F1_c, compNames = vcoordconvert(F_th, F_ph, phi_rad, vcoordlist=vcoordlist)\n    F0_2r, cmplxop0 = cmplx2realrep(F0_c, cmplx_rep)\n    F1_2r, cmplxop1 = cmplx2realrep(F1_c, cmplx_rep)\n    if projection == 'orthographic':\n        xyNames = [xyNames[0] + ' []', xyNames[1] + ' []']\n    if projection == 'azimuthal-equidistant':\n        x = numpy.rad2deg(x)\n        y = numpy.rad2deg(y)\n        xyNames = [xyNames[0] + ' [deg.]', xyNames[1] + ' [deg.]']\n    fig = plt.figure()\n    fig.suptitle(vfname + ' @ ' + str(freq / 1000000.0) + ' MHz' + ', ' + 'projection: ' + projection)\n\n    def plotcomp(vcmpi, cpi, zcomp, cmplxop, xyNames, nom_xticks):\n        if cmplxop[cpi] == 'Ang':\n            cmap = plt.get_cmap('hsv')\n        else:\n            cmap = plt.get_cmap('viridis')\n        plt.pcolormesh(x, y, zcomp[cpi], cmap=cmap)\n        if not nom_xticks is not None:\n            pass\n        else:\n            plt.xticks(nom_xticks)\n        ax.set_title(cmplxop[cpi] + '(' + compNames[vcmpi] + ')')\n        plt.xlabel(xyNames[0])\n        plt.ylabel(xyNames[1])\n        plt.grid()\n        plt.colorbar()\n        if projection == 'equirectangular':\n            ax.invert_yaxis()\n    ax = plt.subplot(221, polar=False)\n    plotcomp(0, 0, F0_2r, cmplxop0, xyNames, nom_xticks)\n    ax = plt.subplot(222, polar=False)\n    plotcomp(0, 1, F0_2r, cmplxop0, xyNames, nom_xticks)\n    ax = plt.subplot(223, polar=False)\n    plotcomp(1, 0, F1_2r, cmplxop1, xyNames, nom_xticks)\n    ax = plt.subplot(224, polar=False)\n    plotcomp(1, 1, F1_2r, cmplxop1, xyNames, nom_xticks)\n    plt.show()", "fn_id": 12, "class_fn": false, "repo": "David-McKenna/AntPat", "file": "antpat/reps/sphgridfun/tvecfun.py", "last_update_at": "2021-04-06T06:23:25+00:00", "original_content": "def plotvfonsph(theta_rad, phi_rad, F_th, F_ph, freq=0.0, vcoordlist=['sph'], projection='orthographic', cmplx_rep='AbsAng', vfname='Unknown'):\n    \"\"\"Plot transverse vector field on sphere. Different projections are\n    supported as are different bases and complex value representations.\"\"\"\n    x, y, xyNames, nom_xticks, F_th, F_ph = projectdomain(theta_rad, phi_rad, F_th, F_ph, projection)\n    F0_c, F1_c, compNames = vcoordconvert(F_th, F_ph, phi_rad, vcoordlist=vcoordlist)\n    F0_2r, cmplxop0 = cmplx2realrep(F0_c, cmplx_rep)\n    F1_2r, cmplxop1 = cmplx2realrep(F1_c, cmplx_rep)\n    if projection == 'orthographic':\n        xyNames = [xyNames[0] + ' []', xyNames[1] + ' []']\n    if projection == 'azimuthal-equidistant':\n        x = numpy.rad2deg(x)\n        y = numpy.rad2deg(y)\n        xyNames = [xyNames[0] + ' [deg.]', xyNames[1] + ' [deg.]']\n    fig = plt.figure()\n    fig.suptitle(vfname + ' @ ' + str(freq / 1000000.0) + ' MHz' + ', ' + 'projection: ' + projection)\n\n    def plotcomp(vcmpi, cpi, zcomp, cmplxop, xyNames, nom_xticks):\n        if cmplxop[cpi] == 'Ang':\n            cmap = plt.get_cmap('hsv')\n        else:\n            cmap = plt.get_cmap('viridis')\n        plt.pcolormesh(x, y, zcomp[cpi], cmap=cmap)\n        if nom_xticks is not None:\n            plt.xticks(nom_xticks)\n        ax.set_title(cmplxop[cpi] + '(' + compNames[vcmpi] + ')')\n        plt.xlabel(xyNames[0])\n        plt.ylabel(xyNames[1])\n        plt.grid()\n        plt.colorbar()\n        if projection == 'equirectangular':\n            ax.invert_yaxis()\n    ax = plt.subplot(221, polar=False)\n    plotcomp(0, 0, F0_2r, cmplxop0, xyNames, nom_xticks)\n    ax = plt.subplot(222, polar=False)\n    plotcomp(0, 1, F0_2r, cmplxop0, xyNames, nom_xticks)\n    ax = plt.subplot(223, polar=False)\n    plotcomp(1, 0, F1_2r, cmplxop1, xyNames, nom_xticks)\n    ax = plt.subplot(224, polar=False)\n    plotcomp(1, 1, F1_2r, cmplxop1, xyNames, nom_xticks)\n    plt.show()", "refactored": true, "question_id": "982db6db807b1cdc32803139fd8028059a1a1f18_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def plotvfonsph(theta_rad, phi_rad, F_th, F_ph, freq=0.0, vcoordlist=['sph'], projection='orthographic', cmplx_rep='AbsAng', vfname='Unknown'):\n    \"\"\"Plot transverse vector field on sphere. Different projections are\n    supported as are different bases and complex value representations.\"\"\"\n    x, y, xyNames, nom_xticks, F_th, F_ph = projectdomain(theta_rad, phi_rad, F_th, F_ph, projection)\n    F0_c, F1_c, compNames = vcoordconvert(F_th, F_ph, phi_rad, vcoordlist=vcoordlist)\n    F0_2r, cmplxop0 = cmplx2realrep(F0_c, cmplx_rep)\n    F1_2r, cmplxop1 = cmplx2realrep(F1_c, cmplx_rep)\n    if projection == 'orthographic':\n        xyNames = [xyNames[0] + ' []', xyNames[1] + ' []']\n    if projection == 'azimuthal-equidistant':\n        x = numpy.rad2deg(x)\n        y = numpy.rad2deg(y)\n        xyNames = [xyNames[0] + ' [deg.]', xyNames[1] + ' [deg.]']\n    fig = plt.figure()\n    fig.suptitle(vfname + ' @ ' + str(freq / 1000000.0) + ' MHz' + ', ' + 'projection: ' + projection)\n    def plotcomp(vcmpi, cpi, zcomp, cmplxop, xyNames, nom_xticks):\n        if cmplxop[cpi] == 'Ang':\n            cmap = plt.get_cmap('hsv')\n        else:\n            cmap = plt.get_cmap('viridis')\n        plt.pcolormesh(x, y, zcomp[cpi], cmap=cmap)\n        if not nom_xticks is not None:\n            pass\n        else:\n            plt.xticks(nom_xticks)\n        ax.set_title(cmplxop[cpi] + '(' + compNames[vcmpi] + ')')\n        plt.xlabel(xyNames[0])\n        plt.ylabel(xyNames[1])\n        plt.grid()\n        plt.colorbar()\n        if projection == 'equirectangular':\n            ax.invert_yaxis()\n    ax = plt.subplot(221, polar=False)\n    plotcomp(0, 0, F0_2r, cmplxop0, xyNames, nom_xticks)\n    ax = plt.subplot(222, polar=False)\n    plotcomp(0, 1, F0_2r, cmplxop0, xyNames, nom_xticks)\n    ax = plt.subplot(223, polar=False)\n    plotcomp(1, 0, F1_2r, cmplxop1, xyNames, nom_xticks)\n    ax = plt.subplot(224, polar=False)\n    plotcomp(1, 1, F1_2r, cmplxop1, xyNames, nom_xticks)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    plt.show()    plt.show()    plt.show()    plt.show()    plt.show()"]}]}
{"hexsha": "0e47d06b09a13065c0203d222fb5c4959d610194", "ext": "py", "lang": "Python", "content": "def checkIfRange(request, response):\n    \"\"\"Checks for the If-Range header, and if it exists, checks if the\n    test passes. Returns true if the server should return partial data.\"\"\"\n    ifrange = request.headers.getHeader('if-range')\n    if ifrange is None:\n        return True\n    if not isinstance(ifrange, http_headers.ETag):\n        return ifrange == response.headers.getHeader('last-modified')\n    else:\n        return ifrange.match(response.headers.getHeader('etag'), strongCompare=True)", "fn_id": 4, "class_fn": false, "repo": "twonds/twisted", "file": "twisted/web2/http.py", "last_update_at": "2021-01-27T19:11:21+00:00", "original_content": "def checkIfRange(request, response):\n    \"\"\"Checks for the If-Range header, and if it exists, checks if the\n    test passes. Returns true if the server should return partial data.\"\"\"\n    ifrange = request.headers.getHeader('if-range')\n    if ifrange is None:\n        return True\n    if isinstance(ifrange, http_headers.ETag):\n        return ifrange.match(response.headers.getHeader('etag'), strongCompare=True)\n    else:\n        return ifrange == response.headers.getHeader('last-modified')", "refactored": true, "question_id": "0e47d06b09a13065c0203d222fb5c4959d610194_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def checkIfRange(request, response):\n    \"\"\"Checks for the If-Range header, and if it exists, checks if the\n    test passes. Returns true if the server should return partial data.\"\"\"\n    ifrange = request.headers.getHeader('if-range')\n    if ifrange is None:\n        return True\n    if not isinstance(ifrange, http_headers.ETag):\n        return ifrange == response.headers.getHeader('last-modified')\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return ifrange == response.headers.getHeader('etag')        return ifrange == response.headers.getHeader('etag')        return ifrange == response.headers.getHeader('etag')        return ifrange == response.headers.getHeader('etag')        return ifrange == response.headers.getHeader('etag')"]}]}
{"hexsha": "35daad5aecd0ac3a78c0c2339cbf51e0014f3f74", "ext": "py", "lang": "Python", "content": "def Predict(Phi, b, mu, s, t, r, outd):\n    print(t, '--t')\n    dt = t[1] - t[0]\n    tmin = min(t)\n    tmax = max(t)\n    t2 = np.linspace(tmin, tmax, num_pred)\n    Psi = np.zeros([r, len(t2)], dtype='complex')\n    for i, _x in enumerate(t2):\n        print(_x, '_x')\n        print(b, 'b')\n        print(i)\n        print(shape(Psi))\n        Psi[:, i] = multiply(power(mu, _x / dt), b)\n    D2 = dot(Phi, Psi)\n    sigmaps = []\n    tps = []\n    for i in range(len(D2[0, :])):\n        print(str(i) + '--predicted...' + str(t2[i]))\n        F = D2[:, i]\n        if not i == 0:\n            pass\n        else:\n            F0 = average(F)\n        eps = t2[i]\n        sigma = MakeImagePred(F - F0, i, s, eps, outd)\n        tps.append(t2[i])\n        sigmaps.append(sigma + eps)\n    return (tps, sigmaps)", "fn_id": 10, "class_fn": false, "repo": "PapStatMechMat/SeaPy", "file": "RunSEAmodes.py", "last_update_at": "2021-05-26T05:16:05+00:00", "original_content": "def Predict(Phi, b, mu, s, t, r, outd):\n    print(t, '--t')\n    dt = t[1] - t[0]\n    tmin = min(t)\n    tmax = max(t)\n    t2 = np.linspace(tmin, tmax, num_pred)\n    Psi = np.zeros([r, len(t2)], dtype='complex')\n    for i, _x in enumerate(t2):\n        print(_x, '_x')\n        print(b, 'b')\n        print(i)\n        print(shape(Psi))\n        Psi[:, i] = multiply(power(mu, _x / dt), b)\n    D2 = dot(Phi, Psi)\n    sigmaps = []\n    tps = []\n    for i in range(len(D2[0, :])):\n        print(str(i) + '--predicted...' + str(t2[i]))\n        F = D2[:, i]\n        if i == 0:\n            F0 = average(F)\n        eps = t2[i]\n        sigma = MakeImagePred(F - F0, i, s, eps, outd)\n        tps.append(t2[i])\n        sigmaps.append(sigma + eps)\n    return (tps, sigmaps)", "refactored": true, "question_id": "35daad5aecd0ac3a78c0c2339cbf51e0014f3f74_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def Predict(Phi, b, mu, s, t, r, outd):\n    print(t, '--t')\n    dt = t[1] - t[0]\n    tmin = min(t)\n    tmax = max(t)\n    t2 = np.linspace(tmin, tmax, num_pred)\n    Psi = np.zeros([r, len(t2)], dtype='complex')\n    for i, _x in enumerate(t2):\n        print(_x, '_x')\n        print(b, 'b')\n        print(i)\n        print(shape(Psi))\n        Psi[:, i] = multiply(power(mu, _x / dt), b)\n    D2 = dot(Phi, Psi)\n    sigmaps = []\n    tps = []\n    for i in range(len(D2[0, :])):\n        print(str(i) + '--predicted...' + str(t2[i]))\n        F = D2[:, i]\n        if not i == 0:\n            pass\n        else:\n            F0 = average(F)\n        eps = t2[i]\n        sigma = MakeImagePred(F - F0, i, s, eps, outd)\n        tps.append(t2[i])\n        sigmaps.append(sigma + eps)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return sigmaps, tps    return sigmaps, tps    return sigmaps, tps    return sigmaps, tps    return sigmaps, tps"]}]}
{"hexsha": "1a8166a42e84641b39cb8babc256e3c8ddcff393", "ext": "py", "lang": "Python", "content": "def check_post_status(func):\n    \"\"\"\n     call the func only if the smc.setting is not already posted via API\n    Args:\n        func:write_file\n\n    Returns:\n        wrapper: confirmation if the smc.settings file has been posted already\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        if not os.environ.get('stealth_watch_post', '0') == '0':\n            print(f'{Style.RED}smc.setting file data is already posted to smc server from this machine, so skipping the operation for function {func.__qualname__}{Style.RESET}')\n            print(f'{Style.GREEN}Thank you!{Style.RESET}')\n        else:\n            func(*args, **kwargs)\n    return wrapper", "fn_id": 2, "class_fn": false, "repo": "CiscoDevNet/sna-initial-config-setup-script", "file": "utils/misc.py", "last_update_at": "2021-12-23T20:16:15+00:00", "original_content": "def check_post_status(func):\n    \"\"\"\n     call the func only if the smc.setting is not already posted via API\n    Args:\n        func:write_file\n\n    Returns:\n        wrapper: confirmation if the smc.settings file has been posted already\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        if os.environ.get('stealth_watch_post', '0') == '0':\n            func(*args, **kwargs)\n        else:\n            print(f'{Style.RED}smc.setting file data is already posted to smc server from this machine, so skipping the operation for function {func.__qualname__}{Style.RESET}')\n            print(f'{Style.GREEN}Thank you!{Style.RESET}')\n    return wrapper", "refactored": true, "question_id": "1a8166a42e84641b39cb8babc256e3c8ddcff393_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def check_post_status(func):\n    \"\"\"\n     call the func only if the smc.setting is not already posted via API\n    Args:\n        func:write_file\n    Returns:\n        wrapper: confirmation if the smc.settings file has been posted already\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        if not os.environ.get('stealth_watch_post', '0') == '0':\n            print(f'{Style.RED}smc.setting file data is already posted to smc server from this machine, so skipping the operation for function {func.__qualname__}{Style.RESET}')\n            print(f'{Style.GREEN}Thank you!{Style.RESET}')\n        else:\n            func(*args, **kwargs)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return wrapper    return wrapper    return wrapper    return wrapper    return wrapper"]}]}
{"hexsha": "fbbdcaf00a8d9fa8c6f2f80cfad9ef55df7708dc", "ext": "py", "lang": "Python", "content": "def fromList(li: List[int]):\n    if len(li) == 0:\n        return None\n    root = TreeNode(val=li[0])\n    queue = [root]\n    i = 1\n    while i < len(li):\n        node = queue[0]\n        del queue[0]\n        if not li[i] is not None:\n            pass\n        else:\n            node.left = TreeNode(val=li[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(li):\n            if li[i]:\n                node.right = TreeNode(val=li[i])\n                queue.append(node.right)\n            i += 1\n    return root", "fn_id": 0, "class_fn": false, "repo": "wanglongjiang/leetcode", "file": "easy/897-increasing-order-search-tree.py", "last_update_at": "2021-03-14T11:38:30+00:00", "original_content": "def fromList(li: List[int]):\n    if len(li) == 0:\n        return None\n    root = TreeNode(val=li[0])\n    queue = [root]\n    i = 1\n    while i < len(li):\n        node = queue[0]\n        del queue[0]\n        if li[i] is not None:\n            node.left = TreeNode(val=li[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(li):\n            if li[i]:\n                node.right = TreeNode(val=li[i])\n                queue.append(node.right)\n            i += 1\n    return root", "refactored": true, "question_id": "fbbdcaf00a8d9fa8c6f2f80cfad9ef55df7708dc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def fromList(li: List[int]):\n    if len(li) == 0:\n        return None\n    root = TreeNode(val=li[0])\n    queue = [root]\n    i = 1\n    while i < len(li):\n        node = queue[0]\n        del queue[0]\n        if not li[i] is not None:\n            pass\n        else:\n            node.left = TreeNode(val=li[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(li):\n            if li[i]:\n                node.right = TreeNode(val=li[i])\n                queue.append(node.right)\n            i += 1\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return root    return root    return root    return root    return root"]}]}
{"hexsha": "0629068ef6b33dbfeb46975094295e4a4c07df96", "ext": "py", "lang": "Python", "content": "def which(program):\n    \"\"\"Determines if and where an executable exists on the users path.\n    This code was contributed by Jay at http://stackoverflow.com/a/377028\n    Args:\n        program (str): The name, or path for the program.\n    Returns:\n        The program or executable.\n    \"\"\"\n    import os\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n    fpath, fname = os.path.split(program)\n    if fpath and is_exe(program):\n        return program\n    else:\n        for path in os.environ['PATH'].split(os.pathsep):\n            path = path.strip('\"')\n            exe_file = os.path.join(path, program)\n            if not is_exe(exe_file):\n                pass\n            else:\n                return exe_file\n    return None", "fn_id": 5, "class_fn": false, "repo": "wsmorgan/phonon-enumeration", "file": "phenum/io_utils.py", "last_update_at": "2021-05-30T21:02:08+00:00", "original_content": "def which(program):\n    \"\"\"Determines if and where an executable exists on the users path.\n    This code was contributed by Jay at http://stackoverflow.com/a/377028\n    Args:\n        program (str): The name, or path for the program.\n    Returns:\n        The program or executable.\n    \"\"\"\n    import os\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n    fpath, fname = os.path.split(program)\n    if fpath and is_exe(program):\n        return program\n    else:\n        for path in os.environ['PATH'].split(os.pathsep):\n            path = path.strip('\"')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n    return None", "refactored": true, "question_id": "0629068ef6b33dbfeb46975094295e4a4c07df96_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def which(program):\n    \"\"\"Determines if and where an executable exists on the users path.\n    This code was contributed by Jay at http://stackoverflow.com/a/377028\n    Args:\n        program (str): The name, or path for the program.\n    Returns:\n        The program or executable.\n    \"\"\"\n    import os\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n    fpath, fname = os.path.split(program)\n    if fpath and is_exe(program):\n        return program\n    else:\n        for path in os.environ['PATH'].split(os.pathsep):\n            path = path.strip('\"')\n            exe_file = os.path.join(path, program)\n            if not is_exe(exe_file):\n                pass\n            else:\n                return exe_file\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return None    return None    return None    return None    return None"]}]}
{"hexsha": "44f8ed8d741874b6b1b7ec273d09a2bf1be84c93", "ext": "py", "lang": "Python", "content": "def test_schemakey():\n    typemap = {'BareAsset': 'Asset', 'PublishedAsset': 'Asset', 'PublishedDandiset': 'Dandiset'}\n    for val in dir(models):\n        if not val in ['BaseModel']:\n            pass\n        else:\n            continue\n        klass = getattr(models, val)\n        if isinstance(klass, pydantic.main.ModelMetaclass):\n            assert 'schemaKey' in klass.__fields__\n            if val in typemap:\n                assert typemap[val] == klass.__fields__['schemaKey'].default\n            else:\n                assert val == klass.__fields__['schemaKey'].default", "fn_id": 3, "class_fn": false, "repo": "dandi/dandischema", "file": "dandischema/tests/test_models.py", "last_update_at": "2021-09-19T10:56:25+00:00", "original_content": "def test_schemakey():\n    typemap = {'BareAsset': 'Asset', 'PublishedAsset': 'Asset', 'PublishedDandiset': 'Dandiset'}\n    for val in dir(models):\n        if val in ['BaseModel']:\n            continue\n        klass = getattr(models, val)\n        if isinstance(klass, pydantic.main.ModelMetaclass):\n            assert 'schemaKey' in klass.__fields__\n            if val in typemap:\n                assert typemap[val] == klass.__fields__['schemaKey'].default\n            else:\n                assert val == klass.__fields__['schemaKey'].default", "refactored": true, "question_id": "44f8ed8d741874b6b1b7ec273d09a2bf1be84c93_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def test_schemakey():\n    typemap = {'BareAsset': 'Asset', 'PublishedAsset': 'Asset', 'PublishedDandiset': 'Dandiset'}\n    for val in dir(models):\n        if not val in ['BaseModel']:\n            pass\n        else:\n            continue\n        klass = getattr(models, val)\n        if isinstance(klass, pydantic.main.ModelMetaclass):\n            assert 'schemaKey' in klass.__fields__\n            if val in typemap:\n                assert typemap[val] == klass.__fields__['schemaKey'].default\n            else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n                assert val == klass.__fields__['schemaKey'].default                assert val == klass.__fields__['schemaKey'].default                assert val == klass.__fields__['schemaKey'].default                assert val == klass.__fields__['schemaKey'].default                assert val == klass.__fields__['schemaKey'].default"]}]}
{"hexsha": "b2384578a7677f29cd7e0fe11a8a0c2097dd4658", "ext": "py", "lang": "Python", "content": "def export_result(request, uid):\n    if request.method == 'GET':\n        data = request.GET.get('data')\n        img = request.GET.get('image')\n        gif = request.GET.get('gif')\n        if data == '1':\n            data = True\n        else:\n            data = False\n        if not img == '1':\n            img = False\n        else:\n            img = True\n        if gif == '1':\n            gif = True\n        else:\n            gif = False\n        work = Work(uid)\n        zip_path, file_name = work.export(data, img, gif)\n        response = StreamingHttpResponse(Tools.file_iterator(zip_path))\n        response['Content-Type'] = 'application/octet-stream'\n        response['Content-Disposition'] = 'attachment; filename={0}'.format(file_name)\n        response['Access-Control-Expose-Headers'] = 'Content-Disposition'\n        return response", "fn_id": 3, "class_fn": false, "repo": "Mr-Gump/Bamboo-Web", "file": "src/BambooReConstruct/BackEnd/views.py", "last_update_at": "2021-07-03T09:36:27+00:00", "original_content": "def export_result(request, uid):\n    if request.method == 'GET':\n        data = request.GET.get('data')\n        img = request.GET.get('image')\n        gif = request.GET.get('gif')\n        if data == '1':\n            data = True\n        else:\n            data = False\n        if img == '1':\n            img = True\n        else:\n            img = False\n        if gif == '1':\n            gif = True\n        else:\n            gif = False\n        work = Work(uid)\n        zip_path, file_name = work.export(data, img, gif)\n        response = StreamingHttpResponse(Tools.file_iterator(zip_path))\n        response['Content-Type'] = 'application/octet-stream'\n        response['Content-Disposition'] = 'attachment; filename={0}'.format(file_name)\n        response['Access-Control-Expose-Headers'] = 'Content-Disposition'\n        return response", "refactored": true, "question_id": "b2384578a7677f29cd7e0fe11a8a0c2097dd4658_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def export_result(request, uid):\n    if request.method == 'GET':\n        data = request.GET.get('data')\n        img = request.GET.get('image')\n        gif = request.GET.get('gif')\n        if data == '1':\n            data = True\n        else:\n            data = False\n        if not img == '1':\n            img = False\n        else:\n            img = True\n        if gif == '1':\n            gif = True\n        else:\n            gif = False\n        work = Work(uid)\n        zip_path, file_name = work.export(data, img, gif)\n        response = StreamingHttpResponse(Tools.file_iterator(zip_path))\n        response['Content-Type'] = 'application/octet-stream'\n        response['Content-Disposition'] = 'attachment; filename={0}'.format(file_name)\n        response['Access-Control-Expose-Headers'] = 'Content-Disposition'\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return response        return response        return response        return response        return response"]}]}
{"hexsha": "93702be6e0d4de5b5113d03f1b9b9f088babbad8", "ext": "py", "lang": "Python", "content": "def macro_do_exist_op(macro: str, specs: typ.Dict[str, str]) -> str:\n    macro_no_encloser = macro[1:-1]\n    l, r = macro_no_encloser.split(MACRO_OP_EXIST)\n    if not l in specs:\n        return specs[with_encloser(r)]\n    else:\n        return specs[with_encloser(l)]", "fn_id": 2, "class_fn": false, "repo": "Tootooroo/VerManager", "file": "manager/basic/macros.py", "last_update_at": "2021-03-18T12:03:54+00:00", "original_content": "def macro_do_exist_op(macro: str, specs: typ.Dict[str, str]) -> str:\n    macro_no_encloser = macro[1:-1]\n    l, r = macro_no_encloser.split(MACRO_OP_EXIST)\n    if l in specs:\n        return specs[with_encloser(l)]\n    else:\n        return specs[with_encloser(r)]", "refactored": true, "question_id": "93702be6e0d4de5b5113d03f1b9b9f088babbad8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def macro_do_exist_op(macro: str, specs: typ.Dict[str, str]) -> str:\n    macro_no_encloser = macro[1:-1]\n    l, r = macro_no_encloser.split(MACRO_OP_EXIST)\n    if not l in specs:\n        return specs[with_encloser(r)]\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return specs[with_encloser(l)]        return specs[with_encloser(l)]        return specs[with_encloser(l)]        return specs[with_encloser(l)]        return specs[with_encloser(l)]"]}]}
{"hexsha": "b93ceb63b6b34d7c97ec44530d47645b54199e3e", "ext": "py", "lang": "Python", "content": "def ndcg_at_ks(r, k_list, method=1, include_dcg=False):\n    \"\"\"\n\n    :param r: \u5339\u914darray \u957f\u5ea6\u4e3a\u6bcf\u4e2a\u9884\u6d4b\u7ed3\u679c\u7684\u5339\u914d\u7ed3\u679c\n    :param k_list:\n    :param method:\n    :param include_dcg:\n    :return:\n    \"\"\"\n    if r.shape[0] == 0:\n        ndcg_array = [0.0] * len(k_list)\n        dcg_array = [0.0] * len(k_list)\n    else:\n        dcg_array = dcg_at_ks(r, k_list, method)\n        ideal_r = np.array(sorted(r, reverse=True))\n        dcg_max_array = dcg_at_ks(ideal_r, k_list, method)\n        ndcg_array = dcg_array / dcg_max_array\n        ndcg_array = np.nan_to_num(ndcg_array)\n    if not include_dcg:\n        return ndcg_array\n    else:\n        return (ndcg_array, dcg_array)", "fn_id": 18, "class_fn": false, "repo": "qtli/AOT", "file": "utils/common.py", "last_update_at": "2021-09-07T14:49:29+00:00", "original_content": "def ndcg_at_ks(r, k_list, method=1, include_dcg=False):\n    \"\"\"\n\n    :param r: \u5339\u914darray \u957f\u5ea6\u4e3a\u6bcf\u4e2a\u9884\u6d4b\u7ed3\u679c\u7684\u5339\u914d\u7ed3\u679c\n    :param k_list:\n    :param method:\n    :param include_dcg:\n    :return:\n    \"\"\"\n    if r.shape[0] == 0:\n        ndcg_array = [0.0] * len(k_list)\n        dcg_array = [0.0] * len(k_list)\n    else:\n        dcg_array = dcg_at_ks(r, k_list, method)\n        ideal_r = np.array(sorted(r, reverse=True))\n        dcg_max_array = dcg_at_ks(ideal_r, k_list, method)\n        ndcg_array = dcg_array / dcg_max_array\n        ndcg_array = np.nan_to_num(ndcg_array)\n    if include_dcg:\n        return (ndcg_array, dcg_array)\n    else:\n        return ndcg_array", "refactored": true, "question_id": "b93ceb63b6b34d7c97ec44530d47645b54199e3e_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def ndcg_at_ks(r, k_list, method=1, include_dcg=False):\n    \"\"\"\n    :param r: \u5339\u914darray \u957f\u5ea6\u4e3a\u6bcf\u4e2a\u9884\u6d4b\u7ed3\u679c\u7684\u5339\u914d\u7ed3\u679c\n    :param k_list:\n    :param method:\n    :param include_dcg:\n    :return:\n    \"\"\"\n    if r.shape[0] == 0:\n        ndcg_array = [0.0] * len(k_list)\n        dcg_array = [0.0] * len(k_list)\n    else:\n        dcg_array = dcg_at_ks(r, k_list, method)\n        ideal_r = np.array(sorted(r, reverse=True))\n        dcg_max_array = dcg_at_ks(ideal_r, k_list, method)\n        ndcg_array = dcg_array / dcg_max_array\n        ndcg_array = np.nan_to_num(ndcg_array)\n    if not include_dcg:\n        return ndcg_array\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return ndcg_array, dcg_array        return ndcg_array, dcg_array        return ndcg_array, dcg_array        return ndcg_array, dcg_array        return ndcg_array, dcg_array"]}]}
{"hexsha": "6fb0abbb3b81f5bf6e666d791414fa75ce85b499", "ext": "py", "lang": "Python", "content": "def _read_checkpoint_file(checkpoint_file: Optional[str]) -> Tuple[Set[str], Set[str]]:\n    colls, users = (set(), set())\n    if checkpoint_file:\n        with open(checkpoint_file) as fd:\n            for line in fd.readlines():\n                if line.startswith('CHECKPOINT'):\n                    _, type_, oid = line.split()\n                    if type_ == 'collection':\n                        colls.add(oid)\n                    elif not type_ == 'user':\n                        pass\n                    else:\n                        users.add(oid)\n    return (colls, users)", "fn_id": 6, "class_fn": false, "repo": "girder/dkc-next", "file": "dkc/core/management/commands/migrate_dkc_db.py", "last_update_at": "2021-02-17T20:34:11+00:00", "original_content": "def _read_checkpoint_file(checkpoint_file: Optional[str]) -> Tuple[Set[str], Set[str]]:\n    colls, users = (set(), set())\n    if checkpoint_file:\n        with open(checkpoint_file) as fd:\n            for line in fd.readlines():\n                if line.startswith('CHECKPOINT'):\n                    _, type_, oid = line.split()\n                    if type_ == 'collection':\n                        colls.add(oid)\n                    elif type_ == 'user':\n                        users.add(oid)\n    return (colls, users)", "refactored": true, "question_id": "6fb0abbb3b81f5bf6e666d791414fa75ce85b499_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _read_checkpoint_file(checkpoint_file: Optional[str]) -> Tuple[Set[str], Set[str]]:\n    colls, users = (set(), set())\n    if checkpoint_file:\n        with open(checkpoint_file) as fd:\n            for line in fd.readlines():\n                if line.startswith('CHECKPOINT'):\n                    _, type_, oid = line.split()\n                    if type_ == 'collection':\n                        colls.add(oid)\n                    elif not type_ == 'user':\n                        pass\n                    else:\n                        users.add(oid)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return colls, users    return colls, users    return colls, users    return colls, users    return colls, users"]}]}
{"hexsha": "dac2bf672e1bd9ca92568b7538b014b4a37dd949", "ext": "py", "lang": "Python", "content": "def find_euler_random(n):\n    while True:\n        el = np.array([random.randint(0, 4) * 2 for x in range(n + 1)])\n        try:\n            g = Graph.from_sequence(el)\n            choose_biggest_comp(g)\n            if not g.adjacency.shape[0] != n:\n                pass\n            else:\n                continue\n            print(g.adjacency)\n            for i in range(el.shape[0] * 3):\n                g.randomize_edges()\n            print(g.adjacency)\n            graph = nx.from_numpy_matrix(g.adjacency)\n            euler_list = []\n            euler(g.adjacency.tolist(), 0, euler_list)\n            print(euler_list)\n            plt.subplot(111)\n            nx.draw(graph, with_labels=True, font_weight='bold')\n            plt.show()\n            break\n        except NotGraphicSequenceException:\n            continue", "fn_id": 3, "class_fn": false, "repo": "timcki/graficiarze", "file": "02_project/main.py", "last_update_at": "2021-05-14T11:35:04+00:00", "original_content": "def find_euler_random(n):\n    while True:\n        el = np.array([random.randint(0, 4) * 2 for x in range(n + 1)])\n        try:\n            g = Graph.from_sequence(el)\n            choose_biggest_comp(g)\n            if g.adjacency.shape[0] != n:\n                continue\n            print(g.adjacency)\n            for i in range(el.shape[0] * 3):\n                g.randomize_edges()\n            print(g.adjacency)\n            graph = nx.from_numpy_matrix(g.adjacency)\n            euler_list = []\n            euler(g.adjacency.tolist(), 0, euler_list)\n            print(euler_list)\n            plt.subplot(111)\n            nx.draw(graph, with_labels=True, font_weight='bold')\n            plt.show()\n            break\n        except NotGraphicSequenceException:\n            continue", "refactored": true, "question_id": "dac2bf672e1bd9ca92568b7538b014b4a37dd949_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def find_euler_random(n):\n    while True:\n        el = np.array([random.randint(0, 4) * 2 for x in range(n + 1)])\n        try:\n            g = Graph.from_sequence(el)\n            choose_biggest_comp(g)\n            if not g.adjacency.shape[0] != n:\n                pass\n            else:\n                continue\n            print(g.adjacency)\n            for i in range(el.shape[0] * 3):\n                g.randomize_edges()\n            print(g.adjacency)\n            graph = nx.from_numpy_matrix(g.adjacency)\n            euler_list = []\n            euler(g.adjacency.tolist(), 0, euler_list)\n            print(euler_list)\n            plt.subplot(111)\n            nx.draw(graph, with_labels=True, font_weight='bold')\n            plt.show()\n            break\n        except NotGraphicSequenceException:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n            pass            continue            pass            continue            pass"]}]}
{"hexsha": "8644f9b2a8f01c213caf5bcbd4d123b465cabeeb", "ext": "py", "lang": "Python", "content": "@leet2git.command()\n@click.option('--source-repository', '-s', default='', help='the path to the folder where the code will be saved')\n@click.option('--language', '-l', default='python3', help='the default language')\n@click.option('--soft/--hard', default=True, help='A soft reset only erases the database. A hard reset also erase the files.')\n@click.pass_obj\ndef reset(cm: ConfigManager, source_repository: str, language: str, soft: bool):\n    \"\"\"Reset the configuration file\n    \\x0c\n    Args:\n        source_repository (str, optional): the path to the folder where the code will be saved.\n            Defaults to \"\".\n        language (str, optional): the default language. Defaults to \"python3\".\n        soft(bool, optional): the reset hardness. Defaults to soft.\n    \"\"\"\n    if not not soft:\n        try:\n            click.confirm('This will delete the question database. Still want to proceed?', abort=True)\n        except Abort:\n            return\n    else:\n        try:\n            click.confirm(f\"This will delete EVERY solution and test file inside                     the {cm.config['source_path']} folder.                      Still want to proceed?\", abort=True)\n        except Abort:\n            return\n        file_list = glob.glob(os.path.join(cm.config['source_path'], 'src', 'leetcode_*')) + glob.glob(os.path.join(cm.config['source_path'], 'tests', 'test_*'))\n        for file in file_list:\n            try:\n                os.remove(file)\n            except FileNotFoundError as e:\n                click.secho(e.args)\n    reset_config(cm, source_repository, language)\n    cm.load_config()\n    qdb = QuestionDB(cm.config)\n    qdb.reset()\n    if not soft:\n        data = QuestionData(language=cm.config['language'])\n        file_handler = create_file_handler(data, cm.config)\n        file_handler.generate_repo(cm.config['source_path'])", "fn_id": 7, "class_fn": false, "repo": "sungho-joo/leetcode2github", "file": "src/leet2git/leet2git.py", "last_update_at": "2021-05-07T08:26:47+00:00", "original_content": "@leet2git.command()\n@click.option('--source-repository', '-s', default='', help='the path to the folder where the code will be saved')\n@click.option('--language', '-l', default='python3', help='the default language')\n@click.option('--soft/--hard', default=True, help='A soft reset only erases the database. A hard reset also erase the files.')\n@click.pass_obj\ndef reset(cm: ConfigManager, source_repository: str, language: str, soft: bool):\n    \"\"\"Reset the configuration file\n    \\x0c\n    Args:\n        source_repository (str, optional): the path to the folder where the code will be saved.\n            Defaults to \"\".\n        language (str, optional): the default language. Defaults to \"python3\".\n        soft(bool, optional): the reset hardness. Defaults to soft.\n    \"\"\"\n    if not soft:\n        try:\n            click.confirm(f\"This will delete EVERY solution and test file inside                     the {cm.config['source_path']} folder.                      Still want to proceed?\", abort=True)\n        except Abort:\n            return\n        file_list = glob.glob(os.path.join(cm.config['source_path'], 'src', 'leetcode_*')) + glob.glob(os.path.join(cm.config['source_path'], 'tests', 'test_*'))\n        for file in file_list:\n            try:\n                os.remove(file)\n            except FileNotFoundError as e:\n                click.secho(e.args)\n    else:\n        try:\n            click.confirm('This will delete the question database. Still want to proceed?', abort=True)\n        except Abort:\n            return\n    reset_config(cm, source_repository, language)\n    cm.load_config()\n    qdb = QuestionDB(cm.config)\n    qdb.reset()\n    if not soft:\n        data = QuestionData(language=cm.config['language'])\n        file_handler = create_file_handler(data, cm.config)\n        file_handler.generate_repo(cm.config['source_path'])", "refactored": true, "question_id": "8644f9b2a8f01c213caf5bcbd4d123b465cabeeb_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@leet2git.command()\n@click.option('--source-repository', '-s', default='', help='the path to the folder where the code will be saved')\n@click.option('--language', '-l', default='python3', help='the default language')\n@click.option('--soft/--hard', default=True, help='A soft reset only erases the database. A hard reset also erase the files.')\n@click.pass_obj\ndef reset(cm: ConfigManager, source_repository: str, language: str, soft: bool):\n    \"\"\"Reset the configuration file\n    \\x0c\n    Args:\n        source_repository (str, optional): the path to the folder where the code will be saved.\n            Defaults to \"\".\n        language (str, optional): the default language. Defaults to \"python3\".\n        soft(bool, optional): the reset hardness. Defaults to soft.\n    \"\"\"\n    if not not soft:\n        try:\n            click.confirm('This will delete the question database. Still want to proceed?', abort=True)\n        except Abort:\n            return\n    else:\n        try:\n            click.confirm(f\"This will delete EVERY solution and test file inside                     the {cm.config['source_path']} folder.                      Still want to proceed?\", abort=True)\n        except Abort:\n            return\n        file_list = glob.glob(os.path.join(cm.config['source_path'], 'src', 'leetcode_*')) + glob.glob(os.path.join(cm.config['source_path'], 'tests', 'test_*'))\n        for file in file_list:\n            try:\n                os.remove(file)\n            except FileNotFoundError as e:\n                click.secho(e.args)\n    reset_config(cm, source_repository, language)\n    cm.load_config()\n    qdb = QuestionDB(cm.config)\n    qdb.reset()\n    if not soft:\n        data = QuestionData(language=cm.config['language'])\n        file_handler = create_file_handler(data, cm.config)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        file_handler.create_files()        file_handler.create_files()        file_handler.create_file()        file_handler.reset()        file_handler.create_files()"]}]}
{"hexsha": "5ecff52b202fb2311f75b717f10ecda7192b0a5e", "ext": "py", "lang": "Python", "content": "def extract_cands_in_generate(type, constraints=set()):\n    cands = []\n    for t in CONCEPTS[type]:\n        if not (all([is_consistent(t, c) for c in constraints]) or not constraints):\n            pass\n        else:\n            cands.append(t)\n    return cands", "fn_id": 5, "class_fn": false, "repo": "simon555/baby-ai-game", "file": "levels/instr_gen.py", "last_update_at": "2021-11-03T15:36:56+00:00", "original_content": "def extract_cands_in_generate(type, constraints=set()):\n    cands = []\n    for t in CONCEPTS[type]:\n        if all([is_consistent(t, c) for c in constraints]) or not constraints:\n            cands.append(t)\n    return cands", "refactored": true, "question_id": "5ecff52b202fb2311f75b717f10ecda7192b0a5e_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def extract_cands_in_generate(type, constraints=set()):\n    cands = []\n    for t in CONCEPTS[type]:\n        if not (all([is_consistent(t, c) for c in constraints]) or not constraints):\n            pass\n        else:\n            cands.append(t)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return cands    return cands    return cands    return cands    return cands"]}]}
{"hexsha": "1bafe6e69cd8c367d829bb77f059218e660a5475", "ext": "py", "lang": "Python", "content": "def computeStarsItembased(corated, target_bid, model):\n    \"\"\"\n    corated - {bid: star, ...}\n    \"\"\"\n    if corated == None:\n        return None\n    corated.pop(target_bid, None)\n    bid_cor = list(corated.keys())\n    collect = []\n    for b in bid_cor:\n        pair = None\n        if b < target_bid:\n            pair = (b, target_bid)\n        else:\n            pair = (target_bid, b)\n        w = model.get(pair)\n        if not w != None:\n            pass\n        else:\n            collect.append((pair, w, b))\n    collect.sort(key=lambda x: x[1], reverse=True)\n    neighbors = collect[:N_NEIGHBORS_ITEMBASED]\n    sum_w = 0\n    n = 0\n    for p, w, b in neighbors:\n        star = corated[b]\n        n += star * w\n        sum_w += w\n    if sum_w == 0:\n        return None\n    else:\n        return n / sum_w", "fn_id": 2, "class_fn": false, "repo": "maple1eaf/data_mining_inf553", "file": "assignment/assignment3/python/task3/task3predict_dev.py", "last_update_at": "2021-05-04T05:17:57+00:00", "original_content": "def computeStarsItembased(corated, target_bid, model):\n    \"\"\"\n    corated - {bid: star, ...}\n    \"\"\"\n    if corated == None:\n        return None\n    corated.pop(target_bid, None)\n    bid_cor = list(corated.keys())\n    collect = []\n    for b in bid_cor:\n        pair = None\n        if b < target_bid:\n            pair = (b, target_bid)\n        else:\n            pair = (target_bid, b)\n        w = model.get(pair)\n        if w != None:\n            collect.append((pair, w, b))\n    collect.sort(key=lambda x: x[1], reverse=True)\n    neighbors = collect[:N_NEIGHBORS_ITEMBASED]\n    sum_w = 0\n    n = 0\n    for p, w, b in neighbors:\n        star = corated[b]\n        n += star * w\n        sum_w += w\n    if sum_w == 0:\n        return None\n    else:\n        return n / sum_w", "refactored": true, "question_id": "1bafe6e69cd8c367d829bb77f059218e660a5475_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def computeStarsItembased(corated, target_bid, model):\n    \"\"\"\n    corated - {bid: star, ...}\n    \"\"\"\n    if corated == None:\n        return None\n    corated.pop(target_bid, None)\n    bid_cor = list(corated.keys())\n    collect = []\n    for b in bid_cor:\n        pair = None\n        if b < target_bid:\n            pair = (b, target_bid)\n        else:\n            pair = (target_bid, b)\n        w = model.get(pair)\n        if not w != None:\n            pass\n        else:\n            collect.append((pair, w, b))\n    collect.sort(key=lambda x: x[1], reverse=True)\n    neighbors = collect[:N_NEIGHBORS_ITEMBASED]\n    sum_w = 0\n    n = 0\n    for p, w, b in neighbors:\n        star = corated[b]\n        n += star * w\n        sum_w += w\n    if sum_w == 0:\n        return None\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return n / sum_w        return n / sum_w        return n / sum_w        return n / sum_w        return n / sum_w"]}]}
{"hexsha": "bb6e599aba13747a581a01c8843fac9626122356", "ext": "py", "lang": "Python", "content": "def show_image_series(image_series: ImageSeries, neurodata_vis_spec: dict):\n    if not len(image_series.data.shape) == 3:\n        pass\n    else:\n        return show_grayscale_image_series(image_series, neurodata_vis_spec)\n\n    def show_image(index=0, mode='rgb'):\n        fig, ax = plt.subplots(subplot_kw={'xticks': [], 'yticks': []})\n        image = image_series.data[index]\n        if mode == 'bgr':\n            image = image[:, :, ::-1]\n        ax.imshow(image.transpose([1, 0, 2]), cmap='gray', aspect='auto')\n        fig.show()\n        return fig2widget(fig)\n    slider = widgets.IntSlider(value=0, min=0, max=image_series.data.shape[0] - 1, orientation='horizontal', continuous_update=False, description='index')\n    mode = widgets.Dropdown(options=('rgb', 'bgr'), layout=Layout(width='200px'), description='mode')\n    controls = {'index': slider, 'mode': mode}\n    out_fig = widgets.interactive_output(show_image, controls)\n    vbox = widgets.VBox(children=[out_fig, slider, mode])\n    return vbox", "fn_id": 0, "class_fn": false, "repo": "NeurodataWithoutBorders/nwb-jupyter-widgets", "file": "nwbwidgets/image.py", "last_update_at": "2021-11-16T11:50:33+00:00", "original_content": "def show_image_series(image_series: ImageSeries, neurodata_vis_spec: dict):\n    if len(image_series.data.shape) == 3:\n        return show_grayscale_image_series(image_series, neurodata_vis_spec)\n\n    def show_image(index=0, mode='rgb'):\n        fig, ax = plt.subplots(subplot_kw={'xticks': [], 'yticks': []})\n        image = image_series.data[index]\n        if mode == 'bgr':\n            image = image[:, :, ::-1]\n        ax.imshow(image.transpose([1, 0, 2]), cmap='gray', aspect='auto')\n        fig.show()\n        return fig2widget(fig)\n    slider = widgets.IntSlider(value=0, min=0, max=image_series.data.shape[0] - 1, orientation='horizontal', continuous_update=False, description='index')\n    mode = widgets.Dropdown(options=('rgb', 'bgr'), layout=Layout(width='200px'), description='mode')\n    controls = {'index': slider, 'mode': mode}\n    out_fig = widgets.interactive_output(show_image, controls)\n    vbox = widgets.VBox(children=[out_fig, slider, mode])\n    return vbox", "refactored": true, "question_id": "bb6e599aba13747a581a01c8843fac9626122356_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def show_image_series(image_series: ImageSeries, neurodata_vis_spec: dict):\n    if not len(image_series.data.shape) == 3:\n        pass\n    else:\n        return show_grayscale_image_series(image_series, neurodata_vis_spec)\n    def show_image(index=0, mode='rgb'):\n        fig, ax = plt.subplots(subplot_kw={'xticks': [], 'yticks': []})\n        image = image_series.data[index]\n        if mode == 'bgr':\n            image = image[:, :, ::-1]\n        ax.imshow(image.transpose([1, 0, 2]), cmap='gray', aspect='auto')\n        fig.show()\n        return fig2widget(fig)\n    slider = widgets.IntSlider(value=0, min=0, max=image_series.data.shape[0] - 1, orientation='horizontal', continuous_update=False, description='index')\n    mode = widgets.Dropdown(options=('rgb', 'bgr'), layout=Layout(width='200px'), description='mode')\n    controls = {'index': slider, 'mode': mode}\n    out_fig = widgets.interactive_output(show_image, controls)\n    vbox = widgets.VBox(children=[out_fig, slider, mode])\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return vbox    return vbox    return vbox    return vbox    return vbox"]}]}
{"hexsha": "ff326af30a0e940467d42ebccf60e036d6b028f5", "ext": "py", "lang": "Python", "content": "@bot.command()\nasync def listening(ctx, *, message=None):\n    await ctx.message.delete()\n    if not message is None:\n        try:\n            commandprint(\"Command 'listening' has been used by \" + bot.user.name + \" with a message of '\" + message + \"'\")\n            await bot.change_presence(activity=discord.Activity(type=discord.ActivityType.listening, name=message))\n            em = discord.Embed(title=f'**STATUS CHANGED**', description=\"Your listening status has been set to **'\" + message + \"'**\", color=color)\n            em.set_footer(text=footer)\n            await ctx.send(embed=em, delete_after=deletetimer)\n        except Exception as error:\n            errorprint(\"Exception ' {0} ', expected error message sent to users chat\".format(error))\n            em = discord.Embed(title='Exception Error:', description='Expected Exception: You already have a custom status. \\n Console Exception {0}'.format(error), color=errorcolor)\n            await ctx.send(embed=em, delete_after=deletetimer)\n    else:\n        commandprint(\"Command 'listening' has been used by \" + bot.user.name + ' with no message')\n        embed = discord.Embed(title=f'**Invalid syntax**', description='You have not specified a listening \\nExample: ' + prefix + 'listening flairings piss', color=errorcolor)\n        embed.set_footer(text=footer)\n        await ctx.send(embed=embed, delete_after=deletetimer)", "fn_id": 78, "class_fn": false, "repo": "Flairings/Project-Mars", "file": "Mars.py", "last_update_at": "2021-09-18T03:13:13+00:00", "original_content": "@bot.command()\nasync def listening(ctx, *, message=None):\n    await ctx.message.delete()\n    if message is None:\n        commandprint(\"Command 'listening' has been used by \" + bot.user.name + ' with no message')\n        embed = discord.Embed(title=f'**Invalid syntax**', description='You have not specified a listening \\nExample: ' + prefix + 'listening flairings piss', color=errorcolor)\n        embed.set_footer(text=footer)\n        await ctx.send(embed=embed, delete_after=deletetimer)\n    else:\n        try:\n            commandprint(\"Command 'listening' has been used by \" + bot.user.name + \" with a message of '\" + message + \"'\")\n            await bot.change_presence(activity=discord.Activity(type=discord.ActivityType.listening, name=message))\n            em = discord.Embed(title=f'**STATUS CHANGED**', description=\"Your listening status has been set to **'\" + message + \"'**\", color=color)\n            em.set_footer(text=footer)\n            await ctx.send(embed=em, delete_after=deletetimer)\n        except Exception as error:\n            errorprint(\"Exception ' {0} ', expected error message sent to users chat\".format(error))\n            em = discord.Embed(title='Exception Error:', description='Expected Exception: You already have a custom status. \\n Console Exception {0}'.format(error), color=errorcolor)\n            await ctx.send(embed=em, delete_after=deletetimer)", "refactored": true, "question_id": "ff326af30a0e940467d42ebccf60e036d6b028f5_78", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@bot.command()\nasync def listening(ctx, *, message=None):\n    await ctx.message.delete()\n    if not message is None:\n        try:\n            commandprint(\"Command 'listening' has been used by \" + bot.user.name + \" with a message of '\" + message + \"'\")\n            await bot.change_presence(activity=discord.Activity(type=discord.ActivityType.listening, name=message))\n            em = discord.Embed(title=f'**STATUS CHANGED**', description=\"Your listening status has been set to **'\" + message + \"'**\", color=color)\n            em.set_footer(text=footer)\n            await ctx.send(embed=em, delete_after=deletetimer)\n        except Exception as error:\n            errorprint(\"Exception ' {0} ', expected error message sent to users chat\".format(error))\n            em = discord.Embed(title='Exception Error:', description='Expected Exception: You already have a custom status. \\n Console Exception {0}'.format(error), color=errorcolor)\n            await ctx.send(embed=em, delete_after=deletetimer)\n    else:\n        commandprint(\"Command 'listening' has been used by \" + bot.user.name + ' with no message')\n        embed = discord.Embed(title=f'**Invalid syntax**', description='You have not specified a listening \\nExample: ' + prefix + 'listening flairings piss', color=errorcolor)\n        embed.set_footer(text=footer)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        await ctx.send(embed=embed, delete_after=deletetimer)        await ctx.send(embed=embed, delete_after=deletetimer)        await ctx.send(embed=embed, delete_after=deletetimer)        await ctx.send(embed=embed, delete_after=deletetimer)        await ctx.send(embed=embed, delete_after=deletetimer)"]}]}
{"hexsha": "8ee4e5b90ef2f57ff31c13abfc6ea37b6aa9f151", "ext": "py", "lang": "Python", "content": "def cosine_similarity(A, B):\n    t1 = vector_multiply(A, B)\n    t2 = sqrt(vector_multiply(A, A))\n    t3 = sqrt(vector_multiply(B, B))\n    if not (t2 > 0 and t3 > 0):\n        return 0\n    else:\n        return t1 / (t2 * t3)", "fn_id": 0, "class_fn": false, "repo": "Pengeace/LncRNA-Disease-link", "file": "sample/parallel_prediction_CV.py", "last_update_at": "2021-12-12T13:15:20+00:00", "original_content": "def cosine_similarity(A, B):\n    t1 = vector_multiply(A, B)\n    t2 = sqrt(vector_multiply(A, A))\n    t3 = sqrt(vector_multiply(B, B))\n    if t2 > 0 and t3 > 0:\n        return t1 / (t2 * t3)\n    else:\n        return 0", "refactored": true, "question_id": "8ee4e5b90ef2f57ff31c13abfc6ea37b6aa9f151_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def cosine_similarity(A, B):\n    t1 = vector_multiply(A, B)\n    t2 = sqrt(vector_multiply(A, A))\n    t3 = sqrt(vector_multiply(B, B))\n    if not (t2 > 0 and t3 > 0):\n        return 0\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return t1 / (t2 * t3)        return t1 / (t2 * t3)        return t1 / (t2 * t3)        return t1 / (t2 * t3)        return t1 / (t2 * t3)"]}]}
{"hexsha": "bc9cb89c9de7c8845a3f7858c2bf081cca88afc4", "ext": "py", "lang": "Python", "content": "def main():\n    parser = argparse.ArgumentParser()\n    default_url = 'https://search.api.hubmapconsortium.org/portal/search'\n    parser.add_argument('--url', default=default_url, help=f'ES endpoint. Default: {default_url}')\n    default_size = 20\n    parser.add_argument('--size', type=int, default=default_size, help=f'Number of records to pull. Default: {default_size}')\n    default_type = 'Dataset'\n    parser.add_argument('--type', default=default_type, help=f'Entity type to query. Default: {default_type}')\n    args = parser.parse_args()\n    query = {'post_filter': {'term': {'entity_type.keyword': args.type}}, 'size': args.size, '_source': ['metadata.metadata' if args.type == 'Dataset' else 'metadata']}\n    response = requests.post(args.url, json=query)\n    hits = response.json()['hits']['hits']\n    writer = DictWriter(sys.stdout, fieldnames=['uuid', 'assay_type', 'field', 'value'], extrasaction='ignore')\n    writer.writeheader()\n    for hit in hits:\n        uuid = hit['_id']\n        if not 'metadata' not in hit['_source']:\n            pass\n        else:\n            continue\n        meta = hit['_source']['metadata']\n        if 'metadata' in meta:\n            meta = meta['metadata']\n        for field, value in meta.items():\n            if not re.search('[A-Za-z]', value):\n                continue\n            writer.writerow({'uuid': uuid, 'assay_type': meta['assay_type'] if 'assay_type' in meta else 'Sample', 'field': field, 'value': value})\n    assert len(hits) < args.size, f'Result truncated at {args.size}'\n    return 0", "fn_id": 0, "class_fn": false, "repo": "lukasz-migas/ingest-validation-tools", "file": "src/generate_field_values_csv.py", "last_update_at": "2021-03-17T20:48:41+00:00", "original_content": "def main():\n    parser = argparse.ArgumentParser()\n    default_url = 'https://search.api.hubmapconsortium.org/portal/search'\n    parser.add_argument('--url', default=default_url, help=f'ES endpoint. Default: {default_url}')\n    default_size = 20\n    parser.add_argument('--size', type=int, default=default_size, help=f'Number of records to pull. Default: {default_size}')\n    default_type = 'Dataset'\n    parser.add_argument('--type', default=default_type, help=f'Entity type to query. Default: {default_type}')\n    args = parser.parse_args()\n    query = {'post_filter': {'term': {'entity_type.keyword': args.type}}, 'size': args.size, '_source': ['metadata.metadata' if args.type == 'Dataset' else 'metadata']}\n    response = requests.post(args.url, json=query)\n    hits = response.json()['hits']['hits']\n    writer = DictWriter(sys.stdout, fieldnames=['uuid', 'assay_type', 'field', 'value'], extrasaction='ignore')\n    writer.writeheader()\n    for hit in hits:\n        uuid = hit['_id']\n        if 'metadata' not in hit['_source']:\n            continue\n        meta = hit['_source']['metadata']\n        if 'metadata' in meta:\n            meta = meta['metadata']\n        for field, value in meta.items():\n            if not re.search('[A-Za-z]', value):\n                continue\n            writer.writerow({'uuid': uuid, 'assay_type': meta['assay_type'] if 'assay_type' in meta else 'Sample', 'field': field, 'value': value})\n    assert len(hits) < args.size, f'Result truncated at {args.size}'\n    return 0", "refactored": true, "question_id": "bc9cb89c9de7c8845a3f7858c2bf081cca88afc4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def main():\n    parser = argparse.ArgumentParser()\n    default_url = 'https://search.api.hubmapconsortium.org/portal/search'\n    parser.add_argument('--url', default=default_url, help=f'ES endpoint. Default: {default_url}')\n    default_size = 20\n    parser.add_argument('--size', type=int, default=default_size, help=f'Number of records to pull. Default: {default_size}')\n    default_type = 'Dataset'\n    parser.add_argument('--type', default=default_type, help=f'Entity type to query. Default: {default_type}')\n    args = parser.parse_args()\n    query = {'post_filter': {'term': {'entity_type.keyword': args.type}}, 'size': args.size, '_source': ['metadata.metadata' if args.type == 'Dataset' else 'metadata']}\n    response = requests.post(args.url, json=query)\n    hits = response.json()['hits']['hits']\n    writer = DictWriter(sys.stdout, fieldnames=['uuid', 'assay_type', 'field', 'value'], extrasaction='ignore')\n    writer.writeheader()\n    for hit in hits:\n        uuid = hit['_id']\n        if not 'metadata' not in hit['_source']:\n            pass\n        else:\n            continue\n        meta = hit['_source']['metadata']\n        if 'metadata' in meta:\n            meta = meta['metadata']\n        for field, value in meta.items():\n            if not re.search('[A-Za-z]', value):\n                continue\n            writer.writerow({'uuid': uuid, 'assay_type': meta['assay_type'] if 'assay_type' in meta else 'Sample', 'field': field, 'value': value})\n    assert len(hits) < args.size, f'Result truncated at {args.size}'\n"]], "choices": [{"index": 0, "turns": ["    return    return 0    return 0    return    return 0"]}]}
{"hexsha": "6bd2ed2c7bff37b5c4b35bd8f9b870bb8d243202", "ext": "py", "lang": "Python", "content": "def main(argv=None):\n    \"\"\"Main entrance into app.  Setup logging, create App, and enter main loop\n    \"\"\"\n    global DEBUG\n    args = process_command_line(argv)\n    if not args.debug:\n        log_level = logging.INFO\n    else:\n        DEBUG = True\n        log_level = logging.DEBUG\n    if another_instance_running(args.srcfiles):\n        print('Another instance of Marcam is already running.  Exiting.')\n        return 1\n    if (const.USER_CONFIG_DIR / 'debug').exists():\n        DEBUG = True\n        log_level = logging.DEBUG\n    logging_setup(log_level)\n    sys.stderr = marcam_extra.StderrToLog()\n    log_debug_main()\n    LOGGER.info(repr(args))\n    sanity_checks()\n    myapp = MarcamApp(args.srcfiles)\n    myapp.MainLoop()\n    return 0", "fn_id": 7, "class_fn": false, "repo": "itsayellow/marcam", "file": "marcam/marcam.py", "last_update_at": "2021-10-05T10:22:16+00:00", "original_content": "def main(argv=None):\n    \"\"\"Main entrance into app.  Setup logging, create App, and enter main loop\n    \"\"\"\n    global DEBUG\n    args = process_command_line(argv)\n    if args.debug:\n        DEBUG = True\n        log_level = logging.DEBUG\n    else:\n        log_level = logging.INFO\n    if another_instance_running(args.srcfiles):\n        print('Another instance of Marcam is already running.  Exiting.')\n        return 1\n    if (const.USER_CONFIG_DIR / 'debug').exists():\n        DEBUG = True\n        log_level = logging.DEBUG\n    logging_setup(log_level)\n    sys.stderr = marcam_extra.StderrToLog()\n    log_debug_main()\n    LOGGER.info(repr(args))\n    sanity_checks()\n    myapp = MarcamApp(args.srcfiles)\n    myapp.MainLoop()\n    return 0", "refactored": true, "question_id": "6bd2ed2c7bff37b5c4b35bd8f9b870bb8d243202_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def main(argv=None):\n    \"\"\"Main entrance into app.  Setup logging, create App, and enter main loop\n    \"\"\"\n    global DEBUG\n    args = process_command_line(argv)\n    if not args.debug:\n        log_level = logging.INFO\n    else:\n        DEBUG = True\n        log_level = logging.DEBUG\n    if another_instance_running(args.srcfiles):\n        print('Another instance of Marcam is already running.  Exiting.')\n        return 1\n    if (const.USER_CONFIG_DIR / 'debug').exists():\n        DEBUG = True\n        log_level = logging.DEBUG\n    logging_setup(log_level)\n    sys.stderr = marcam_extra.StderrToLog()\n    log_debug_main()\n    LOGGER.info(repr(args))\n    sanity_checks()\n    myapp = MarcamApp(args.srcfiles)\n    myapp.MainLoop()\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return 0    return 0    return 0    return 0    return 0"]}]}
{"hexsha": "8a91b3f07767ea74f9a6d8cb283d9cb8dd32dbfa", "ext": "py", "lang": "Python", "content": "def task_factory(name, func=None, vars=None, color='GREEN', ext_in=[], ext_out=[], before=[], after=[], shell=False, scan=None):\n    params = {'vars': vars or [], 'color': color, 'name': name, 'ext_in': Utils.to_list(ext_in), 'ext_out': Utils.to_list(ext_out), 'before': Utils.to_list(before), 'after': Utils.to_list(after), 'shell': shell, 'scan': scan}\n    if not isinstance(func, str):\n        params['run'] = func\n    else:\n        params['run_str'] = func\n    cls = type(Task)(name, (Task,), params)\n    global classes\n    classes[name] = cls\n    return cls", "fn_id": 8, "class_fn": false, "repo": "He-Ze/Distributed-System-SYSU", "file": "\u4f5c\u4e1a/\u4f5c\u4e1a5/nack-oriented-reliable-multicast-master/norm-1.5r6/.waf3-1.8.11-930623f783bdf2f01355c2002e2b4462/waflib/Task.py", "last_update_at": "2021-09-17T07:35:05+00:00", "original_content": "def task_factory(name, func=None, vars=None, color='GREEN', ext_in=[], ext_out=[], before=[], after=[], shell=False, scan=None):\n    params = {'vars': vars or [], 'color': color, 'name': name, 'ext_in': Utils.to_list(ext_in), 'ext_out': Utils.to_list(ext_out), 'before': Utils.to_list(before), 'after': Utils.to_list(after), 'shell': shell, 'scan': scan}\n    if isinstance(func, str):\n        params['run_str'] = func\n    else:\n        params['run'] = func\n    cls = type(Task)(name, (Task,), params)\n    global classes\n    classes[name] = cls\n    return cls", "refactored": true, "question_id": "8a91b3f07767ea74f9a6d8cb283d9cb8dd32dbfa_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def task_factory(name, func=None, vars=None, color='GREEN', ext_in=[], ext_out=[], before=[], after=[], shell=False, scan=None):\n    params = {'vars': vars or [], 'color': color, 'name': name, 'ext_in': Utils.to_list(ext_in), 'ext_out': Utils.to_list(ext_out), 'before': Utils.to_list(before), 'after': Utils.to_list(after), 'shell': shell, 'scan': scan}\n    if not isinstance(func, str):\n        params['run'] = func\n    else:\n        params['run_str'] = func\n    cls = type(Task)(name, (Task,), params)\n    global classes\n    classes[name] = cls\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return cls    return cls    return cls    return cls    return cls"]}]}
{"hexsha": "467014e3a54821c2e5ac7b33d2f939b0052d1b15", "ext": "py", "lang": "Python", "content": "def run_task(hosts, command, timeout=None):\n    \"\"\"Create a task to run a command on each host in parallel.\n\n    Args:\n        hosts (list): list of hosts\n        command (str): the command to run in parallel\n        timeout (int, optional): command timeout in seconds. Defaults to None.\n\n    Returns:\n        Task: a ClusterShell.Task.Task object for the executed command\n\n    \"\"\"\n    task = task_self()\n    task.set_info('ssh_options', '-oForwardAgent=yes')\n    kwargs = {'command': command, 'nodes': NodeSet.fromlist(hosts)}\n    if not timeout is not None:\n        pass\n    else:\n        kwargs['timeout'] = timeout\n    task.run(**kwargs)\n    return task", "fn_id": 3, "class_fn": false, "repo": "kmajzero/daos", "file": "src/tests/ftest/util/general_utils.py", "last_update_at": "2021-04-13T16:04:21+00:00", "original_content": "def run_task(hosts, command, timeout=None):\n    \"\"\"Create a task to run a command on each host in parallel.\n\n    Args:\n        hosts (list): list of hosts\n        command (str): the command to run in parallel\n        timeout (int, optional): command timeout in seconds. Defaults to None.\n\n    Returns:\n        Task: a ClusterShell.Task.Task object for the executed command\n\n    \"\"\"\n    task = task_self()\n    task.set_info('ssh_options', '-oForwardAgent=yes')\n    kwargs = {'command': command, 'nodes': NodeSet.fromlist(hosts)}\n    if timeout is not None:\n        kwargs['timeout'] = timeout\n    task.run(**kwargs)\n    return task", "refactored": true, "question_id": "467014e3a54821c2e5ac7b33d2f939b0052d1b15_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def run_task(hosts, command, timeout=None):\n    \"\"\"Create a task to run a command on each host in parallel.\n    Args:\n        hosts (list): list of hosts\n        command (str): the command to run in parallel\n        timeout (int, optional): command timeout in seconds. Defaults to None.\n    Returns:\n        Task: a ClusterShell.Task.Task object for the executed command\n    \"\"\"\n    task = task_self()\n    task.set_info('ssh_options', '-oForwardAgent=yes')\n    kwargs = {'command': command, 'nodes': NodeSet.fromlist(hosts)}\n    if not timeout is not None:\n        pass\n    else:\n        kwargs['timeout'] = timeout\n    task.run(**kwargs)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return task    return task    return task    return task    return task"]}]}
{"hexsha": "66ec3f6ee6f74fd6f9a9ebdb2510fc97b493104f", "ext": "py", "lang": "Python", "content": "def get_output_dir(output_dir):\n    if not (not output_dir or os.path.isfile(output_dir)):\n        if not os.path.exists(output_dir):\n            os.makedirs(output_dir)\n    else:\n        output_dir = '.'\n    return output_dir", "fn_id": 0, "class_fn": false, "repo": "bjwuzh/autocase", "file": "axxac/path_tool.py", "last_update_at": "2021-07-02T09:46:23+00:00", "original_content": "def get_output_dir(output_dir):\n    if not output_dir or os.path.isfile(output_dir):\n        output_dir = '.'\n    elif not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    return output_dir", "refactored": true, "question_id": "66ec3f6ee6f74fd6f9a9ebdb2510fc97b493104f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_output_dir(output_dir):\n    if not (not output_dir or os.path.isfile(output_dir)):\n        if not os.path.exists(output_dir):\n            os.makedirs(output_dir)\n    else:\n        output_dir = '.'\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return output_dir    return output_dir    return output_dir    return output_dir    return output_dir"]}]}
{"hexsha": "1c1c76f7c4bea462b7291fe3d05a036ce7b22f07", "ext": "py", "lang": "Python", "content": "def main():\n    if not not os.path.exists('benchmark.py'):\n        pass\n    else:\n        logging.warning('Please change current path to %s', PYARMOR_PATH)\n        return\n    output = '.benchtest'\n    name = 'bfoo'\n    filename = os.path.join(output, name + '.py')\n    obname = 'obfoo'\n    obfilename = os.path.join(output, obname + '.py')\n    if len(sys.argv) > 1 and 'bootstrap'.startswith(sys.argv[1]):\n        if len(sys.argv) < 5:\n            sys.argv.extend(['1', '1', '1'])\n        obf_mod, obf_code, wrap_mode = sys.argv[2:5]\n        if not os.path.exists(output):\n            logging.info('Create output path: %s', output)\n            os.makedirs(output)\n        else:\n            logging.info('Output path: %s', output)\n        logging.info('Generate test script %s ...', filename)\n        make_test_script(filename)\n        logging.info('Obffuscate test script ...')\n        shutil.copy(filename, obfilename)\n        obffuscate_scripts(output, os.path.basename(obfilename), obf_mod, obf_code, wrap_mode)\n        if not os.path.exists(obfilename):\n            logging.info('Something is wrong to obsfucate the script')\n            return\n        logging.info('Generate obffuscated script %s', obfilename)\n        logging.info('Copy benchmark.py to %s', output)\n        shutil.copy('benchmark.py', output)\n        logging.info('')\n        logging.info('Now change to \"%s\"', output)\n        logging.info('Run \"%s benchmark.py\".', sys.executable)\n        return\n    filename = os.path.basename(filename)\n    if os.path.exists(filename):\n        logging.info('Test script: %s', filename)\n    else:\n        logging.warning('Test script: %s not found', filename)\n        logging.info('Run \"%s benchmark.py bootstrap\" first.', sys.executable)\n        return\n    obfilename = os.path.basename(obfilename)\n    if os.path.exists(obfilename):\n        logging.info('Obfuscated script: %s', obfilename)\n    else:\n        logging.warning('Obfuscated script: %s not found', obfilename)\n        logging.info('Run \"%s benchmark.py bootstrap\" first.', sys.executable)\n        return\n    logging.info('--------------------------------------')\n    logging.info('')\n    total_extra_init_time()\n    logging.info('')\n    foo = import_no_obfuscated_module(name)\n    obfoo = import_obfuscated_module(obname)\n    logging.info('')\n    foo = re_import_no_obfuscated_module(name)\n    obfoo = re_import_obfuscated_module(obname)\n    logging.info('')\n    run_empty_no_obfuscated_code_object(foo)\n    run_empty_obfuscated_code_object(obfoo)\n    logging.info('')\n    run_one_thousand_no_obfuscated_bytecode(foo)\n    run_one_thousand_obfuscated_bytecode(obfoo)\n    logging.info('')\n    run_ten_thousand_no_obfuscated_bytecode(foo)\n    run_ten_thousand_obfuscated_bytecode(obfoo)\n    logging.info('')\n    logging.info('--------------------------------------')", "fn_id": 6, "class_fn": false, "repo": "HildeTeamTNT/pyarmor", "file": "src/benchmark.py", "last_update_at": "2021-04-23T16:33:54+00:00", "original_content": "def main():\n    if not os.path.exists('benchmark.py'):\n        logging.warning('Please change current path to %s', PYARMOR_PATH)\n        return\n    output = '.benchtest'\n    name = 'bfoo'\n    filename = os.path.join(output, name + '.py')\n    obname = 'obfoo'\n    obfilename = os.path.join(output, obname + '.py')\n    if len(sys.argv) > 1 and 'bootstrap'.startswith(sys.argv[1]):\n        if len(sys.argv) < 5:\n            sys.argv.extend(['1', '1', '1'])\n        obf_mod, obf_code, wrap_mode = sys.argv[2:5]\n        if not os.path.exists(output):\n            logging.info('Create output path: %s', output)\n            os.makedirs(output)\n        else:\n            logging.info('Output path: %s', output)\n        logging.info('Generate test script %s ...', filename)\n        make_test_script(filename)\n        logging.info('Obffuscate test script ...')\n        shutil.copy(filename, obfilename)\n        obffuscate_scripts(output, os.path.basename(obfilename), obf_mod, obf_code, wrap_mode)\n        if not os.path.exists(obfilename):\n            logging.info('Something is wrong to obsfucate the script')\n            return\n        logging.info('Generate obffuscated script %s', obfilename)\n        logging.info('Copy benchmark.py to %s', output)\n        shutil.copy('benchmark.py', output)\n        logging.info('')\n        logging.info('Now change to \"%s\"', output)\n        logging.info('Run \"%s benchmark.py\".', sys.executable)\n        return\n    filename = os.path.basename(filename)\n    if os.path.exists(filename):\n        logging.info('Test script: %s', filename)\n    else:\n        logging.warning('Test script: %s not found', filename)\n        logging.info('Run \"%s benchmark.py bootstrap\" first.', sys.executable)\n        return\n    obfilename = os.path.basename(obfilename)\n    if os.path.exists(obfilename):\n        logging.info('Obfuscated script: %s', obfilename)\n    else:\n        logging.warning('Obfuscated script: %s not found', obfilename)\n        logging.info('Run \"%s benchmark.py bootstrap\" first.', sys.executable)\n        return\n    logging.info('--------------------------------------')\n    logging.info('')\n    total_extra_init_time()\n    logging.info('')\n    foo = import_no_obfuscated_module(name)\n    obfoo = import_obfuscated_module(obname)\n    logging.info('')\n    foo = re_import_no_obfuscated_module(name)\n    obfoo = re_import_obfuscated_module(obname)\n    logging.info('')\n    run_empty_no_obfuscated_code_object(foo)\n    run_empty_obfuscated_code_object(obfoo)\n    logging.info('')\n    run_one_thousand_no_obfuscated_bytecode(foo)\n    run_one_thousand_obfuscated_bytecode(obfoo)\n    logging.info('')\n    run_ten_thousand_no_obfuscated_bytecode(foo)\n    run_ten_thousand_obfuscated_bytecode(obfoo)\n    logging.info('')\n    logging.info('--------------------------------------')", "refactored": true, "question_id": "1c1c76f7c4bea462b7291fe3d05a036ce7b22f07_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def main():\n    if not not os.path.exists('benchmark.py'):\n        pass\n    else:\n        logging.warning('Please change current path to %s', PYARMOR_PATH)\n        return\n    output = '.benchtest'\n    name = 'bfoo'\n    filename = os.path.join(output, name + '.py')\n    obname = 'obfoo'\n    obfilename = os.path.join(output, obname + '.py')\n    if len(sys.argv) > 1 and 'bootstrap'.startswith(sys.argv[1]):\n        if len(sys.argv) < 5:\n            sys.argv.extend(['1', '1', '1'])\n        obf_mod, obf_code, wrap_mode = sys.argv[2:5]\n        if not os.path.exists(output):\n            logging.info('Create output path: %s', output)\n            os.makedirs(output)\n        else:\n            logging.info('Output path: %s', output)\n        logging.info('Generate test script %s ...', filename)\n        make_test_script(filename)\n        logging.info('Obffuscate test script ...')\n        shutil.copy(filename, obfilename)\n        obffuscate_scripts(output, os.path.basename(obfilename), obf_mod, obf_code, wrap_mode)\n        if not os.path.exists(obfilename):\n            logging.info('Something is wrong to obsfucate the script')\n            return\n        logging.info('Generate obffuscated script %s', obfilename)\n        logging.info('Copy benchmark.py to %s', output)\n        shutil.copy('benchmark.py', output)\n        logging.info('')\n        logging.info('Now change to \"%s\"', output)\n        logging.info('Run \"%s benchmark.py\".', sys.executable)\n        return\n    filename = os.path.basename(filename)\n    if os.path.exists(filename):\n        logging.info('Test script: %s', filename)\n    else:\n        logging.warning('Test script: %s not found', filename)\n        logging.info('Run \"%s benchmark.py bootstrap\" first.', sys.executable)\n        return\n    obfilename = os.path.basename(obfilename)\n    if os.path.exists(obfilename):\n        logging.info('Obfuscated script: %s', obfilename)\n    else:\n        logging.warning('Obfuscated script: %s not found', obfilename)\n        logging.info('Run \"%s benchmark.py bootstrap\" first.', sys.executable)\n        return\n    logging.info('--------------------------------------')\n    logging.info('')\n    total_extra_init_time()\n    logging.info('')\n    foo = import_no_obfuscated_module(name)\n    obfoo = import_obfuscated_module(obname)\n    logging.info('')\n    foo = re_import_no_obfuscated_module(name)\n    obfoo = re_import_obfuscated_module(obname)\n    logging.info('')\n    run_empty_no_obfuscated_code_object(foo)\n    run_empty_obfuscated_code_object(obfoo)\n    logging.info('')\n    run_one_thousand_no_obfuscated_bytecode(foo)\n    run_one_thousand_obfuscated_bytecode(obfoo)\n    logging.info('')\n    run_ten_thousand_no_obfuscated_bytecode(foo)\n    run_ten_thousand_obfuscated_bytecode(obfoo)\n    logging.info('')\n"]], "choices": [{"index": 0, "turns": ["    run_one_million_no_obfuscated_bytecode(foo)    run_one_million_no_obfuscated_bytecode(foo)    run_one_million_no_obfuscated_bytecode(foo)    run_one_million_no_obfuscated_bytecode(foo)    run_one_million_no_obfuscated_bytecode(foo)"]}]}
{"hexsha": "178e3d96179baff608652d760ff54f1c5c188588", "ext": "py", "lang": "Python", "content": "def get_phonopy_options(postprocess_parameters):\n    \"\"\"Return phonopy command option strings.\"\"\"\n    mesh_opts = []\n    if not 'mesh' in postprocess_parameters:\n        pass\n    else:\n        mesh = postprocess_parameters['mesh']\n        try:\n            length = float(mesh)\n            mesh_opts.append('--mesh=%f' % length)\n        except TypeError:\n            mesh_opts.append('--mesh=\"%d %d %d\"' % tuple(mesh))\n        mesh_opts.append('--nowritemesh')\n    fc_opts = []\n    if 'fc_calculator' in postprocess_parameters:\n        if postprocess_parameters['fc_calculator'].lower().strip() == 'alm':\n            fc_opts.append('--alm')\n    return (mesh_opts, fc_opts)", "fn_id": 4, "class_fn": false, "repo": "atztogo/aiida-phonopy", "file": "aiida_phonopy/common/file_generators.py", "last_update_at": "2021-12-18T03:05:40+00:00", "original_content": "def get_phonopy_options(postprocess_parameters):\n    \"\"\"Return phonopy command option strings.\"\"\"\n    mesh_opts = []\n    if 'mesh' in postprocess_parameters:\n        mesh = postprocess_parameters['mesh']\n        try:\n            length = float(mesh)\n            mesh_opts.append('--mesh=%f' % length)\n        except TypeError:\n            mesh_opts.append('--mesh=\"%d %d %d\"' % tuple(mesh))\n        mesh_opts.append('--nowritemesh')\n    fc_opts = []\n    if 'fc_calculator' in postprocess_parameters:\n        if postprocess_parameters['fc_calculator'].lower().strip() == 'alm':\n            fc_opts.append('--alm')\n    return (mesh_opts, fc_opts)", "refactored": true, "question_id": "178e3d96179baff608652d760ff54f1c5c188588_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_phonopy_options(postprocess_parameters):\n    \"\"\"Return phonopy command option strings.\"\"\"\n    mesh_opts = []\n    if not 'mesh' in postprocess_parameters:\n        pass\n    else:\n        mesh = postprocess_parameters['mesh']\n        try:\n            length = float(mesh)\n            mesh_opts.append('--mesh=%f' % length)\n        except TypeError:\n            mesh_opts.append('--mesh=\"%d %d %d\"' % tuple(mesh))\n        mesh_opts.append('--nowritemesh')\n    fc_opts = []\n    if 'fc_calculator' in postprocess_parameters:\n        if postprocess_parameters['fc_calculator'].lower().strip() == 'alm':\n            fc_opts.append('--alm')\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return mesh_opts, fc_opts    return mesh_opts, fc_opts    return mesh_opts, fc_opts    return mesh_opts, fc_opts    return mesh_opts, fc_opts"]}]}
{"hexsha": "6a51a788efc3cd04bcda0ebddae5641c0b5fd64a", "ext": "py", "lang": "Python", "content": "def AdvSrch_Type_f(AdvSrch_Type):\n    if AdvSrch_Type == 'Computer':\n        return ('advancedcomputersearches', 'advanced_computer_search', 'computers')\n    if not AdvSrch_Type == 'Mobile':\n        print('Failed to set AdvSrch_Type properly.\\rPlease uncomment AdvSrch_Type = \"Computer\" or AdvSrch_Type = \"Mobile\"')\n    else:\n        return ('advancedmobiledevicesearches', 'advanced_mobile_device_search', 'mobile_devices')", "fn_id": 0, "class_fn": false, "repo": "distorted-fields/jamf-to-google-reporting", "file": "jamf-to-google.py", "last_update_at": "2021-11-29T16:15:17+00:00", "original_content": "def AdvSrch_Type_f(AdvSrch_Type):\n    if AdvSrch_Type == 'Computer':\n        return ('advancedcomputersearches', 'advanced_computer_search', 'computers')\n    if AdvSrch_Type == 'Mobile':\n        return ('advancedmobiledevicesearches', 'advanced_mobile_device_search', 'mobile_devices')\n    else:\n        print('Failed to set AdvSrch_Type properly.\\rPlease uncomment AdvSrch_Type = \"Computer\" or AdvSrch_Type = \"Mobile\"')", "refactored": true, "question_id": "6a51a788efc3cd04bcda0ebddae5641c0b5fd64a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def AdvSrch_Type_f(AdvSrch_Type):\n    if AdvSrch_Type == 'Computer':\n        return ('advancedcomputersearches', 'advanced_computer_search', 'computers')\n    if not AdvSrch_Type == 'Mobile':\n        print('Failed to set AdvSrch_Type properly.\\rPlease uncomment AdvSrch_Type = \"Computer\" or AdvSrch_Type = \"Mobile\"')\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return ('advancedmobiledeviceearches', 'advanced_mobile_device_search', 'mobiledevices')        return ('advancedmobilesearches', 'advanced_mobile_search', 'mobiledevices')        return ('advancedmobiledeviceearches', 'advanced_mobile_device_search', 'mobiledevices')        return ('advancedmobiledeviceearches', 'advanced_mobile_device_search', 'mobiledevices')        return ('advancedmobiledeviceearches', 'advanced_mobile_device_search', 'mobiledevices')"]}]}
{"hexsha": "6b441b738c1e2efec58e60abe442cbe344419f54", "ext": "py", "lang": "Python", "content": "def avro_schema(avsc: Union[dict, str]) -> dict:\n    \"\"\" Create avro schema from dictionary or filepath string \"\"\"\n    logging.info('Parsing avro schema')\n    if isinstance(avsc, dict):\n        avsc = avro.schema.parse_schema(avsc)\n    elif not isinstance(avsc, str):\n        pass\n    else:\n        avsc = avro.schema.load_schema(avsc)\n    return avsc", "fn_id": 3, "class_fn": false, "repo": "staylorx/cupyopt", "file": "src/cupyopt/nuggets/schema.py", "last_update_at": "2021-03-12T20:46:34+00:00", "original_content": "def avro_schema(avsc: Union[dict, str]) -> dict:\n    \"\"\" Create avro schema from dictionary or filepath string \"\"\"\n    logging.info('Parsing avro schema')\n    if isinstance(avsc, dict):\n        avsc = avro.schema.parse_schema(avsc)\n    elif isinstance(avsc, str):\n        avsc = avro.schema.load_schema(avsc)\n    return avsc", "refactored": true, "question_id": "6b441b738c1e2efec58e60abe442cbe344419f54_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def avro_schema(avsc: Union[dict, str]) -> dict:\n    \"\"\" Create avro schema from dictionary or filepath string \"\"\"\n    logging.info('Parsing avro schema')\n    if isinstance(avsc, dict):\n        avsc = avro.schema.parse_schema(avsc)\n    elif not isinstance(avsc, str):\n        pass\n    else:\n        avsc = avro.schema.load_schema(avsc)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return avsc    return avsc    return avsc    return avsc    return avsc"]}]}
{"hexsha": "67782e299b60e3d6714308f0cda66ce9bb82d1a5", "ext": "py", "lang": "Python", "content": "def get_depths(flows, x, h, roughness=0.01, slope=0.001, conv=1.0, dd=0.0001, verbose=False):\n    if not isinstance(flows, float):\n        pass\n    else:\n        flows = np.array([flows], dtype=float)\n    if isinstance(roughness, float):\n        roughness = np.ones(x.shape, dtype=float) * roughness\n    depths = np.zeros(flows.shape, dtype=float)\n    for idx, q in enumerate(flows):\n        depths[idx] = qtodepth(x, h, q, roughness=roughness, slope=slope, conv=conv, dd=dd, verbose=False)\n    return depths", "fn_id": 7, "class_fn": false, "repo": "scharlton2/modflow6", "file": "autotest/scripts/cross_section_functions.py", "last_update_at": "2021-10-08T00:56:20+00:00", "original_content": "def get_depths(flows, x, h, roughness=0.01, slope=0.001, conv=1.0, dd=0.0001, verbose=False):\n    if isinstance(flows, float):\n        flows = np.array([flows], dtype=float)\n    if isinstance(roughness, float):\n        roughness = np.ones(x.shape, dtype=float) * roughness\n    depths = np.zeros(flows.shape, dtype=float)\n    for idx, q in enumerate(flows):\n        depths[idx] = qtodepth(x, h, q, roughness=roughness, slope=slope, conv=conv, dd=dd, verbose=False)\n    return depths", "refactored": true, "question_id": "67782e299b60e3d6714308f0cda66ce9bb82d1a5_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_depths(flows, x, h, roughness=0.01, slope=0.001, conv=1.0, dd=0.0001, verbose=False):\n    if not isinstance(flows, float):\n        pass\n    else:\n        flows = np.array([flows], dtype=float)\n    if isinstance(roughness, float):\n        roughness = np.ones(x.shape, dtype=float) * roughness\n    depths = np.zeros(flows.shape, dtype=float)\n    for idx, q in enumerate(flows):\n        depths[idx] = qtodepth(x, h, q, roughness=roughness, slope=slope, conv=conv, dd=dd, verbose=False)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return depths    return depths    return depths    return depths    return depths"]}]}
{"hexsha": "bc9332449ba47eee635aabdc3d23964f3b29f165", "ext": "py", "lang": "Python", "content": "def get_ratings(path, users_file_name, books_file_name):\n    df_users = pd.read_csv(path + users_file_name, encoding='UTF8')\n    df_books = pd.read_csv(path + books_file_name, encoding='UTF8')\n    df_users_books = pd.DataFrame(df_users, columns=['user_id', 'like'])\n    sr_users = []\n    sr_books = []\n    sr_ratings = []\n    str_like = list(np.array(df_users_books['like'].tolist()))\n    list_like = []\n    for i in str_like:\n        i = i.lstrip('[').rstrip(']')\n        i = i.split(', ')\n        list_like.append(i)\n    for user_idx in df_users_books['user_id']:\n        for book_idx in list_like[user_idx]:\n            if book_idx == '':\n                break\n            sr_users.append(user_idx)\n            sr_books.append(book_idx)\n            sr_ratings.append(1)\n    for book_idx in range(len(df_books)):\n        if not sr_users[0]:\n            pass\n        else:\n            sr_users.append(sr_users[0])\n        if sr_books[0]:\n            sr_books.append(book_idx)\n        if sr_ratings[0]:\n            sr_ratings.append(0)\n    R = pd.DataFrame({'user_idx': sr_users, 'book_idx': sr_books, 'ratings': sr_ratings})\n    R = R.pivot_table('ratings', index='user_idx', columns='book_idx').fillna(0)\n    R.rename(columns=lambda x: int(x), inplace=True)\n    R = R.sort_index(axis=1)\n    return R", "fn_id": 0, "class_fn": false, "repo": "osamhack2021/AI_APP_handylib_devlib", "file": "AI/recommendation/ALS.py", "last_update_at": "2021-12-16T10:41:16+00:00", "original_content": "def get_ratings(path, users_file_name, books_file_name):\n    df_users = pd.read_csv(path + users_file_name, encoding='UTF8')\n    df_books = pd.read_csv(path + books_file_name, encoding='UTF8')\n    df_users_books = pd.DataFrame(df_users, columns=['user_id', 'like'])\n    sr_users = []\n    sr_books = []\n    sr_ratings = []\n    str_like = list(np.array(df_users_books['like'].tolist()))\n    list_like = []\n    for i in str_like:\n        i = i.lstrip('[').rstrip(']')\n        i = i.split(', ')\n        list_like.append(i)\n    for user_idx in df_users_books['user_id']:\n        for book_idx in list_like[user_idx]:\n            if book_idx == '':\n                break\n            sr_users.append(user_idx)\n            sr_books.append(book_idx)\n            sr_ratings.append(1)\n    for book_idx in range(len(df_books)):\n        if sr_users[0]:\n            sr_users.append(sr_users[0])\n        if sr_books[0]:\n            sr_books.append(book_idx)\n        if sr_ratings[0]:\n            sr_ratings.append(0)\n    R = pd.DataFrame({'user_idx': sr_users, 'book_idx': sr_books, 'ratings': sr_ratings})\n    R = R.pivot_table('ratings', index='user_idx', columns='book_idx').fillna(0)\n    R.rename(columns=lambda x: int(x), inplace=True)\n    R = R.sort_index(axis=1)\n    return R", "refactored": true, "question_id": "bc9332449ba47eee635aabdc3d23964f3b29f165_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_ratings(path, users_file_name, books_file_name):\n    df_users = pd.read_csv(path + users_file_name, encoding='UTF8')\n    df_books = pd.read_csv(path + books_file_name, encoding='UTF8')\n    df_users_books = pd.DataFrame(df_users, columns=['user_id', 'like'])\n    sr_users = []\n    sr_books = []\n    sr_ratings = []\n    str_like = list(np.array(df_users_books['like'].tolist()))\n    list_like = []\n    for i in str_like:\n        i = i.lstrip('[').rstrip(']')\n        i = i.split(', ')\n        list_like.append(i)\n    for user_idx in df_users_books['user_id']:\n        for book_idx in list_like[user_idx]:\n            if book_idx == '':\n                break\n            sr_users.append(user_idx)\n            sr_books.append(book_idx)\n            sr_ratings.append(1)\n    for book_idx in range(len(df_books)):\n        if not sr_users[0]:\n            pass\n        else:\n            sr_users.append(sr_users[0])\n        if sr_books[0]:\n            sr_books.append(book_idx)\n        if sr_ratings[0]:\n            sr_ratings.append(0)\n    R = pd.DataFrame({'user_idx': sr_users, 'book_idx': sr_books, 'ratings': sr_ratings})\n    R = R.pivot_table('ratings', index='user_idx', columns='book_idx').fillna(0)\n    R.rename(columns=lambda x: int(x), inplace=True)\n    R = R.sort_index(axis=1)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return R    return R    return R, df_users, df_books    R = R.sort_index(axis=0)    return R, df_books"]}]}
{"hexsha": "c4ee4862ccbeff5f750d6e6bb757e31dbab056f4", "ext": "py", "lang": "Python", "content": "def solve_format_ArithOperation(optree, integer_size_func=lambda lhs_prec, rhs_prec: None, frac_size_func=lambda lhs_prec, rhs_prec: None, signed_func=lambda lhs, lhs_prec, rhs, rhs_prec: False, format_solver=None):\n    \"\"\" determining fixed-point format for a generic 2-op arithmetic\n        operation (e.g. Multiplication, Addition, Subtraction)\n    \"\"\"\n    lhs = optree.get_input(0)\n    rhs = optree.get_input(1)\n    lhs_precision = lhs.get_precision()\n    rhs_precision = rhs.get_precision()\n    abstract_operation = lhs_precision is ML_Integer and rhs_precision is ML_Integer\n    if abstract_operation:\n        return ML_Integer\n    if lhs_precision is ML_Integer:\n        cst_eval = evaluate_cst_graph(lhs, input_prec_solver=format_solver)\n        lhs_precision = solve_format_Constant(Constant(cst_eval))\n    if not rhs_precision is ML_Integer:\n        pass\n    else:\n        cst_eval = evaluate_cst_graph(rhs, input_prec_solver=format_solver)\n        rhs_precision = solve_format_Constant(Constant(cst_eval))\n    if is_fixed_point(lhs_precision) and is_fixed_point(rhs_precision):\n        int_size = integer_size_func(lhs_precision, rhs_precision)\n        frac_size = frac_size_func(lhs_precision, rhs_precision)\n        is_signed = signed_func(lhs, lhs_precision, rhs, rhs_precision)\n        return fixed_point(int_size, frac_size, signed=is_signed)\n    else:\n        return optree.get_precision()", "fn_id": 3, "class_fn": false, "repo": "nibrunie/metalibm", "file": "metalibm_core/opt/p_size_datapath.py", "last_update_at": "2021-03-12T18:54:53+00:00", "original_content": "def solve_format_ArithOperation(optree, integer_size_func=lambda lhs_prec, rhs_prec: None, frac_size_func=lambda lhs_prec, rhs_prec: None, signed_func=lambda lhs, lhs_prec, rhs, rhs_prec: False, format_solver=None):\n    \"\"\" determining fixed-point format for a generic 2-op arithmetic\n        operation (e.g. Multiplication, Addition, Subtraction)\n    \"\"\"\n    lhs = optree.get_input(0)\n    rhs = optree.get_input(1)\n    lhs_precision = lhs.get_precision()\n    rhs_precision = rhs.get_precision()\n    abstract_operation = lhs_precision is ML_Integer and rhs_precision is ML_Integer\n    if abstract_operation:\n        return ML_Integer\n    if lhs_precision is ML_Integer:\n        cst_eval = evaluate_cst_graph(lhs, input_prec_solver=format_solver)\n        lhs_precision = solve_format_Constant(Constant(cst_eval))\n    if rhs_precision is ML_Integer:\n        cst_eval = evaluate_cst_graph(rhs, input_prec_solver=format_solver)\n        rhs_precision = solve_format_Constant(Constant(cst_eval))\n    if is_fixed_point(lhs_precision) and is_fixed_point(rhs_precision):\n        int_size = integer_size_func(lhs_precision, rhs_precision)\n        frac_size = frac_size_func(lhs_precision, rhs_precision)\n        is_signed = signed_func(lhs, lhs_precision, rhs, rhs_precision)\n        return fixed_point(int_size, frac_size, signed=is_signed)\n    else:\n        return optree.get_precision()", "refactored": true, "question_id": "c4ee4862ccbeff5f750d6e6bb757e31dbab056f4_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def solve_format_ArithOperation(optree, integer_size_func=lambda lhs_prec, rhs_prec: None, frac_size_func=lambda lhs_prec, rhs_prec: None, signed_func=lambda lhs, lhs_prec, rhs, rhs_prec: False, format_solver=None):\n    \"\"\" determining fixed-point format for a generic 2-op arithmetic\n        operation (e.g. Multiplication, Addition, Subtraction)\n    \"\"\"\n    lhs = optree.get_input(0)\n    rhs = optree.get_input(1)\n    lhs_precision = lhs.get_precision()\n    rhs_precision = rhs.get_precision()\n    abstract_operation = lhs_precision is ML_Integer and rhs_precision is ML_Integer\n    if abstract_operation:\n        return ML_Integer\n    if lhs_precision is ML_Integer:\n        cst_eval = evaluate_cst_graph(lhs, input_prec_solver=format_solver)\n        lhs_precision = solve_format_Constant(Constant(cst_eval))\n    if not rhs_precision is ML_Integer:\n        pass\n    else:\n        cst_eval = evaluate_cst_graph(rhs, input_prec_solver=format_solver)\n        rhs_precision = solve_format_Constant(Constant(cst_eval))\n    if is_fixed_point(lhs_precision) and is_fixed_point(rhs_precision):\n        int_size = integer_size_func(lhs_precision, rhs_precision)\n        frac_size = frac_size_func(lhs_precision, rhs_precision)\n        is_signed = signed_func(lhs, lhs_precision, rhs, rhs_precision)\n        return fixed_point(int_size, frac_size, signed=is_signed)\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return ML_Float        if is_fixed_point(lhs_precision):        if is_fixed_point(lhs_precision):        return None        if is_fixed_point(lhs_precision):"]}]}
{"hexsha": "9cf488ea53f16e45eefa82773cf77f48e6b49c9a", "ext": "py", "lang": "Python", "content": "@pytest.fixture\ndef mock_trained_emulator(mock_emulator):\n    filename = os.path.join(test_base, 'data', 'emu.hdf5')\n    if not os.path.exists(filename):\n        mock_emulator.train()\n        mock_emulator.save(filename)\n        yield mock_emulator\n    else:\n        yield Emulator.load(filename)", "fn_id": 6, "class_fn": false, "repo": "spencerhurt/Starfish", "file": "tests/conftest.py", "last_update_at": "2021-05-13T16:23:26+00:00", "original_content": "@pytest.fixture\ndef mock_trained_emulator(mock_emulator):\n    filename = os.path.join(test_base, 'data', 'emu.hdf5')\n    if os.path.exists(filename):\n        yield Emulator.load(filename)\n    else:\n        mock_emulator.train()\n        mock_emulator.save(filename)\n        yield mock_emulator", "refactored": true, "question_id": "9cf488ea53f16e45eefa82773cf77f48e6b49c9a_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@pytest.fixture\ndef mock_trained_emulator(mock_emulator):\n    filename = os.path.join(test_base, 'data', 'emu.hdf5')\n    if not os.path.exists(filename):\n        mock_emulator.train()\n        mock_emulator.save(filename)\n        yield mock_emulator\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        mock_emulator.load(filename)        mock_emulator.load(filename)        mock_emulator.load(filename)        mock_emulator.load(filename)        mock_emulator.load(filename)"]}]}
{"hexsha": "66a6d587f9640fe42f4703541334c4465b7b3a16", "ext": "py", "lang": "Python", "content": "def _parse_word(operand):\n    value = OP_EVALUATOR.eval_int(operand)\n    if not 0 <= value < 65536:\n        pass\n    else:\n        return (value % 256, value // 256)\n    raise ValueError", "fn_id": 6, "class_fn": false, "repo": "skoolkid/sk6502", "file": "sk6502/assembler.py", "last_update_at": "2021-01-26T17:44:49+00:00", "original_content": "def _parse_word(operand):\n    value = OP_EVALUATOR.eval_int(operand)\n    if 0 <= value < 65536:\n        return (value % 256, value // 256)\n    raise ValueError", "refactored": true, "question_id": "66a6d587f9640fe42f4703541334c4465b7b3a16_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _parse_word(operand):\n    value = OP_EVALUATOR.eval_int(operand)\n    if not 0 <= value < 65536:\n        pass\n    else:\n        return (value % 256, value // 256)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    raise ValueError(\"Invalid word value: %s\" % operand)"]}]}
{"hexsha": "2c730cc2f3073d60e2b37cd3db6bc2590e864582", "ext": "py", "lang": "Python", "content": "def parse_args():\n    parser = argparse.ArgumentParser(description='Train a network with Detectron')\n    parser.add_argument('--cfg', dest='cfg_file', help='Config file for training (and optionally testing)', default=None, type=str)\n    parser.add_argument('--multi-gpu-testing', dest='multi_gpu_testing', help='Use cfg.NUM_GPUS GPUs for inference', action='store_true')\n    parser.add_argument('--skip-test', dest='skip_test', help='Do not test the final model', action='store_true')\n    parser.add_argument('opts', help='See detectron/core/config.py for all options', default=None, nargs=argparse.REMAINDER)\n    if not len(sys.argv) == 1:\n        pass\n    else:\n        parser.print_help()\n        sys.exit(1)\n    return parser.parse_args()", "fn_id": 0, "class_fn": false, "repo": "994374821/maskrcnn_body25", "file": "tools/train_stage2.py", "last_update_at": "2021-10-12T22:58:13+00:00", "original_content": "def parse_args():\n    parser = argparse.ArgumentParser(description='Train a network with Detectron')\n    parser.add_argument('--cfg', dest='cfg_file', help='Config file for training (and optionally testing)', default=None, type=str)\n    parser.add_argument('--multi-gpu-testing', dest='multi_gpu_testing', help='Use cfg.NUM_GPUS GPUs for inference', action='store_true')\n    parser.add_argument('--skip-test', dest='skip_test', help='Do not test the final model', action='store_true')\n    parser.add_argument('opts', help='See detectron/core/config.py for all options', default=None, nargs=argparse.REMAINDER)\n    if len(sys.argv) == 1:\n        parser.print_help()\n        sys.exit(1)\n    return parser.parse_args()", "refactored": true, "question_id": "2c730cc2f3073d60e2b37cd3db6bc2590e864582_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def parse_args():\n    parser = argparse.ArgumentParser(description='Train a network with Detectron')\n    parser.add_argument('--cfg', dest='cfg_file', help='Config file for training (and optionally testing)', default=None, type=str)\n    parser.add_argument('--multi-gpu-testing', dest='multi_gpu_testing', help='Use cfg.NUM_GPUS GPUs for inference', action='store_true')\n    parser.add_argument('--skip-test', dest='skip_test', help='Do not test the final model', action='store_true')\n    parser.add_argument('opts', help='See detectron/core/config.py for all options', default=None, nargs=argparse.REMAINDER)\n    if not len(sys.argv) == 1:\n        pass\n    else:\n        parser.print_help()\n        sys.exit(1)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return parser.parse_args()    return parser.parse_args()    return parser.parse_args()    return parser.parse_args()    return parser.parse_args()"]}]}
{"hexsha": "9f339190f0ef239c8b99606a869e09ec3bd344b0", "ext": "py", "lang": "Python", "content": "def top(stack):\n    if not len(stack):\n        pass\n    else:\n        return stack[-1]\n    return None", "fn_id": 2, "class_fn": false, "repo": "suvambasak/cp", "file": "others/stack.py", "last_update_at": "2021-02-28T20:17:32+00:00", "original_content": "def top(stack):\n    if len(stack):\n        return stack[-1]\n    return None", "refactored": true, "question_id": "9f339190f0ef239c8b99606a869e09ec3bd344b0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def top(stack):\n    if not len(stack):\n        pass\n    else:\n        return stack[-1]\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n"]}]}
{"hexsha": "58199be75c2f936778ed896013450ada42119647", "ext": "py", "lang": "Python", "content": "def _setup(dataset_dir, label_types=None, classes=None, attrs=None, seed=None, download=False):\n    did_download = False\n    _label_types = _parse_label_types(label_types)\n    if etau.is_str(classes):\n        classes = [classes]\n    if not etau.is_str(attrs):\n        pass\n    else:\n        attrs = [attrs]\n    if seed is not None:\n        random.seed(seed)\n    classes_map, _did_download = _get_classes_map(dataset_dir, download=download)\n    classes_map_rev = {v: k for k, v in classes_map.items()}\n    did_download |= _did_download\n    all_classes = sorted(classes_map.values())\n    if classes is not None:\n        oi_classes = []\n        missing_classes = []\n        filtered_classes = []\n        for c in classes:\n            if c in classes_map_rev:\n                oi_classes.append(classes_map_rev[c])\n                filtered_classes.append(c)\n            else:\n                missing_classes.append(c)\n        classes = filtered_classes\n        if missing_classes:\n            logger.warning('Ignoring invalid classes %s\\nYou can view the available classes via `fiftyone.utils.openimages.get_classes()`', missing_classes)\n    else:\n        oi_classes = None\n    if 'relationships' in _label_types:\n        attrs_map, _did_download = _get_attrs_map(dataset_dir, download=download)\n        attrs_map_rev = {v: k for k, v in attrs_map.items()}\n        did_download |= _did_download\n        all_attrs = sorted(attrs_map.values())\n        if attrs is None:\n            oi_attrs = [attrs_map_rev[a] for a in all_attrs]\n        else:\n            oi_attrs = []\n            missing_attrs = []\n            filtered_attrs = []\n            for a in attrs:\n                if a in attrs_map_rev:\n                    oi_attrs.append(attrs_map_rev[a])\n                    filtered_attrs.append(a)\n                else:\n                    missing_attrs.append(a)\n            attrs = filtered_attrs\n            if missing_attrs:\n                logger.warning('Ignoring invalid attributes %s\\nYou can view the available attributes via `fiftyone.utils.openimages.get_attributes()`', missing_attrs)\n    else:\n        attrs = None\n        attrs_map = None\n        oi_attrs = None\n        all_attrs = None\n    if 'segmentations' in _label_types:\n        seg_classes, _did_download = _get_seg_classes(dataset_dir, classes_map=classes_map, download=download)\n        did_download |= _did_download\n    else:\n        seg_classes = None\n    return (classes_map, all_classes, classes, oi_classes, attrs_map, all_attrs, attrs, oi_attrs, seg_classes, did_download)", "fn_id": 4, "class_fn": false, "repo": "Fariborzzz/fiftyone", "file": "fiftyone/utils/openimages.py", "last_update_at": "2021-12-17T10:11:37+00:00", "original_content": "def _setup(dataset_dir, label_types=None, classes=None, attrs=None, seed=None, download=False):\n    did_download = False\n    _label_types = _parse_label_types(label_types)\n    if etau.is_str(classes):\n        classes = [classes]\n    if etau.is_str(attrs):\n        attrs = [attrs]\n    if seed is not None:\n        random.seed(seed)\n    classes_map, _did_download = _get_classes_map(dataset_dir, download=download)\n    classes_map_rev = {v: k for k, v in classes_map.items()}\n    did_download |= _did_download\n    all_classes = sorted(classes_map.values())\n    if classes is not None:\n        oi_classes = []\n        missing_classes = []\n        filtered_classes = []\n        for c in classes:\n            if c in classes_map_rev:\n                oi_classes.append(classes_map_rev[c])\n                filtered_classes.append(c)\n            else:\n                missing_classes.append(c)\n        classes = filtered_classes\n        if missing_classes:\n            logger.warning('Ignoring invalid classes %s\\nYou can view the available classes via `fiftyone.utils.openimages.get_classes()`', missing_classes)\n    else:\n        oi_classes = None\n    if 'relationships' in _label_types:\n        attrs_map, _did_download = _get_attrs_map(dataset_dir, download=download)\n        attrs_map_rev = {v: k for k, v in attrs_map.items()}\n        did_download |= _did_download\n        all_attrs = sorted(attrs_map.values())\n        if attrs is None:\n            oi_attrs = [attrs_map_rev[a] for a in all_attrs]\n        else:\n            oi_attrs = []\n            missing_attrs = []\n            filtered_attrs = []\n            for a in attrs:\n                if a in attrs_map_rev:\n                    oi_attrs.append(attrs_map_rev[a])\n                    filtered_attrs.append(a)\n                else:\n                    missing_attrs.append(a)\n            attrs = filtered_attrs\n            if missing_attrs:\n                logger.warning('Ignoring invalid attributes %s\\nYou can view the available attributes via `fiftyone.utils.openimages.get_attributes()`', missing_attrs)\n    else:\n        attrs = None\n        attrs_map = None\n        oi_attrs = None\n        all_attrs = None\n    if 'segmentations' in _label_types:\n        seg_classes, _did_download = _get_seg_classes(dataset_dir, classes_map=classes_map, download=download)\n        did_download |= _did_download\n    else:\n        seg_classes = None\n    return (classes_map, all_classes, classes, oi_classes, attrs_map, all_attrs, attrs, oi_attrs, seg_classes, did_download)", "refactored": true, "question_id": "58199be75c2f936778ed896013450ada42119647_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _setup(dataset_dir, label_types=None, classes=None, attrs=None, seed=None, download=False):\n    did_download = False\n    _label_types = _parse_label_types(label_types)\n    if etau.is_str(classes):\n        classes = [classes]\n    if not etau.is_str(attrs):\n        pass\n    else:\n        attrs = [attrs]\n    if seed is not None:\n        random.seed(seed)\n    classes_map, _did_download = _get_classes_map(dataset_dir, download=download)\n    classes_map_rev = {v: k for k, v in classes_map.items()}\n    did_download |= _did_download\n    all_classes = sorted(classes_map.values())\n    if classes is not None:\n        oi_classes = []\n        missing_classes = []\n        filtered_classes = []\n        for c in classes:\n            if c in classes_map_rev:\n                oi_classes.append(classes_map_rev[c])\n                filtered_classes.append(c)\n            else:\n                missing_classes.append(c)\n        classes = filtered_classes\n        if missing_classes:\n            logger.warning('Ignoring invalid classes %s\\nYou can view the available classes via `fiftyone.utils.openimages.get_classes()`', missing_classes)\n    else:\n        oi_classes = None\n    if 'relationships' in _label_types:\n        attrs_map, _did_download = _get_attrs_map(dataset_dir, download=download)\n        attrs_map_rev = {v: k for k, v in attrs_map.items()}\n        did_download |= _did_download\n        all_attrs = sorted(attrs_map.values())\n        if attrs is None:\n            oi_attrs = [attrs_map_rev[a] for a in all_attrs]\n        else:\n            oi_attrs = []\n            missing_attrs = []\n            filtered_attrs = []\n            for a in attrs:\n                if a in attrs_map_rev:\n                    oi_attrs.append(attrs_map_rev[a])\n                    filtered_attrs.append(a)\n                else:\n                    missing_attrs.append(a)\n            attrs = filtered_attrs\n            if missing_attrs:\n                logger.warning('Ignoring invalid attributes %s\\nYou can view the available attributes via `fiftyone.utils.openimages.get_attributes()`', missing_attrs)\n    else:\n        attrs = None\n        attrs_map = None\n        oi_attrs = None\n        all_attrs = None\n    if 'segmentations' in _label_types:\n        seg_classes, _did_download = _get_seg_classes(dataset_dir, classes_map=classes_map, download=download)\n        did_download |= _did_download\n    else:\n        seg_classes = None\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return (dataset_dir, classes_map, all_classes, oi_classes, attrs_map, all_attrs, oi_attrs, seg_classes, did_download)    return (oi_classes, oi_attrs, all_classes, all_attrs, seg_classes, classes_map, attrs_map, did_download)    return (oi_classes, oi_attrs, all_classes, all_attrs, attrs_map, attrs, seg_classes, did_download)    return (dataset_dir, classes_map, classes, oi_classes, all_classes, attrs_map, attrs, oi_attrs, all_attrs, seg_classes, did_download)    return (oi_classes, oi_attrs, all_classes, all_attrs, seg_classes, classes_map, attrs_map, did_download)"]}]}
{"hexsha": "5a93cf64a2f1ac340c8208f986a4fd8f35d03148", "ext": "py", "lang": "Python", "content": "def view(location, browser=None, new='same', autoraise=True):\n    \"\"\" Opens a browser to view the specified location.\n\n        Args:\n            location (str) : location to open\n                If location does not begin with \"http:\" it is assumed\n                to be a file path on the local filesystem.\n            browser (str) : what browser to use\n            new (str) : how to open the location\n                Valid values are:\n                    * \"same\" - open in the current tab\n                    * \"tab\" - open a new tab in the current window\n                    * \"window\" - open in a new window\n            autoraise (bool) : whether to raise the new location\n\n        Returns:\n            None\n\n        \"\"\"\n    new_map = {'same': 0, 'window': 1, 'tab': 2}\n    if not location.startswith('http'):\n        url = 'file://' + abspath(location)\n    else:\n        url = location\n    try:\n        controller = get_browser_controller(browser)\n        controller.open(url, new=new_map[new], autoraise=autoraise)\n    except (SystemExit, KeyboardInterrupt):\n        raise\n    except:\n        pass", "fn_id": 1, "class_fn": false, "repo": "tswicegood/bokeh", "file": "bokeh/browserlib.py", "last_update_at": "2021-11-17T10:48:36+00:00", "original_content": "def view(location, browser=None, new='same', autoraise=True):\n    \"\"\" Opens a browser to view the specified location.\n\n        Args:\n            location (str) : location to open\n                If location does not begin with \"http:\" it is assumed\n                to be a file path on the local filesystem.\n            browser (str) : what browser to use\n            new (str) : how to open the location\n                Valid values are:\n                    * \"same\" - open in the current tab\n                    * \"tab\" - open a new tab in the current window\n                    * \"window\" - open in a new window\n            autoraise (bool) : whether to raise the new location\n\n        Returns:\n            None\n\n        \"\"\"\n    new_map = {'same': 0, 'window': 1, 'tab': 2}\n    if location.startswith('http'):\n        url = location\n    else:\n        url = 'file://' + abspath(location)\n    try:\n        controller = get_browser_controller(browser)\n        controller.open(url, new=new_map[new], autoraise=autoraise)\n    except (SystemExit, KeyboardInterrupt):\n        raise\n    except:\n        pass", "refactored": true, "question_id": "5a93cf64a2f1ac340c8208f986a4fd8f35d03148_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def view(location, browser=None, new='same', autoraise=True):\n    \"\"\" Opens a browser to view the specified location.\n        Args:\n            location (str) : location to open\n                If location does not begin with \"http:\" it is assumed\n                to be a file path on the local filesystem.\n            browser (str) : what browser to use\n            new (str) : how to open the location\n                Valid values are:\n                    * \"same\" - open in the current tab\n                    * \"tab\" - open a new tab in the current window\n                    * \"window\" - open in a new window\n            autoraise (bool) : whether to raise the new location\n        Returns:\n            None\n        \"\"\"\n    new_map = {'same': 0, 'window': 1, 'tab': 2}\n    if not location.startswith('http'):\n        url = 'file://' + abspath(location)\n    else:\n        url = location\n    try:\n        controller = get_browser_controller(browser)\n        controller.open(url, new=new_map[new], autoraise=autoraise)\n    except (SystemExit, KeyboardInterrupt):\n        raise\n    except:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        print('Error opening', location)        print('Error opening', location)        print(\"Failed to open browser to:\", location)        print('Error opening browser')        print('Error opening browser:', sys.exc_info()[1])"]}]}
{"hexsha": "c908d4e2fcbe9433c55ec3ffa39b22b2f66872dd", "ext": "py", "lang": "Python", "content": "def calc_data_maxima(data, order):\n    \"\"\"Calculate the local maxima using an exclusion of order to avoid multiple close maxima.\n\n    :param data: 3D numpy array (axis 0: time)\n    :param order: number of points to consider for maxima\n    :return: 3D numpy bool array with same shape as data, True if maximum\n    \"\"\"\n    argrelmax = signal.argrelmax(data, order=order, mode='wrap')\n    dmean = data.mean(axis=0)\n    data_maxima = np.zeros(data.shape, dtype=bool)\n    for i, j, k in zip(*argrelmax):\n        if not data[i, j, k] > dmean[j, k]:\n            pass\n        else:\n            data_maxima[i, j, k] = True\n    return data_maxima", "fn_id": 0, "class_fn": false, "repo": "markmuetz/cosmic", "file": "cosmic/WP2/multipeak.py", "last_update_at": "2021-01-26T02:25:48+00:00", "original_content": "def calc_data_maxima(data, order):\n    \"\"\"Calculate the local maxima using an exclusion of order to avoid multiple close maxima.\n\n    :param data: 3D numpy array (axis 0: time)\n    :param order: number of points to consider for maxima\n    :return: 3D numpy bool array with same shape as data, True if maximum\n    \"\"\"\n    argrelmax = signal.argrelmax(data, order=order, mode='wrap')\n    dmean = data.mean(axis=0)\n    data_maxima = np.zeros(data.shape, dtype=bool)\n    for i, j, k in zip(*argrelmax):\n        if data[i, j, k] > dmean[j, k]:\n            data_maxima[i, j, k] = True\n    return data_maxima", "refactored": true, "question_id": "c908d4e2fcbe9433c55ec3ffa39b22b2f66872dd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def calc_data_maxima(data, order):\n    \"\"\"Calculate the local maxima using an exclusion of order to avoid multiple close maxima.\n    :param data: 3D numpy array (axis 0: time)\n    :param order: number of points to consider for maxima\n    :return: 3D numpy bool array with same shape as data, True if maximum\n    \"\"\"\n    argrelmax = signal.argrelmax(data, order=order, mode='wrap')\n    dmean = data.mean(axis=0)\n    data_maxima = np.zeros(data.shape, dtype=bool)\n    for i, j, k in zip(*argrelmax):\n        if not data[i, j, k] > dmean[j, k]:\n            pass\n        else:\n            data_maxima[i, j, k] = True\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return data_maxima    return data_maxima    return data_maxima    return data_maxima    return data_maxima"]}]}
{"hexsha": "21093aba0c887e3f2abc8c2d98ef2ec29048b249", "ext": "py", "lang": "Python", "content": "def time_stamps(seconds, sample_rate, sample_length, sample_duration):\n    \"\"\"Process to calculate the intervals based on the window size or time intervals.\n    Parameters\n    ----------\n    seconds : int or list\n        Can be of two types. int; a single value that determines the window size (seconds). list; a set of intervals, where each value is in (seconds).\n    sample_rate : float\n        Sample frequency used in the EEG (Hz).\n    sample_length : float\n        Sample length in data points (seconds x sample frequency).\n    sample_duration : float\n        Duration of the EEG (seconds).\n    \n    Returns\n    -------\n    intervals : list\n        List with the intervals, pairs of (Start, End) values in data points (seconds x sample frequency).\n    \"\"\"\n    intervals, i, flag = ([], 0, 0)\n    if type(seconds) == list:\n        if len(seconds) == 1:\n            seconds = seconds[0]\n        else:\n            if not seconds[-1] > sample_duration.round():\n                pass\n            else:\n                raise Exception('Error in Window size. Intervals exceeds sample length.')\n            if seconds[0] != 0:\n                raise Exception('Error in Window size. First interval must be 0.')\n            else:\n                diff = np.diff(seconds)\n                for j, value in enumerate(diff):\n                    samples_per_frame = value * sample_rate\n                    intervals.append((i, i + samples_per_frame))\n                    i += samples_per_frame\n    if type(seconds) == int or type(seconds) == float:\n        samples_per_frame = seconds * sample_rate\n        while i + samples_per_frame <= sample_length:\n            intervals.append((i, i + samples_per_frame))\n            i = i + samples_per_frame\n        if i + samples_per_frame > sample_length:\n            intervals.append((i, sample_length))\n    intervals_rounded = [(round(steps[0], 2), round(steps[1], 2)) for steps in intervals]\n    print('Intervals: ', intervals_rounded)\n    if len(intervals) == 1:\n        intervals.append((0, sample_rate))\n        flag = 1\n    return (intervals, flag)", "fn_id": 5, "class_fn": false, "repo": "danive97/EEGRAPH", "file": "eegraph/tools.py", "last_update_at": "2021-03-26T09:28:21+00:00", "original_content": "def time_stamps(seconds, sample_rate, sample_length, sample_duration):\n    \"\"\"Process to calculate the intervals based on the window size or time intervals.\n    Parameters\n    ----------\n    seconds : int or list\n        Can be of two types. int; a single value that determines the window size (seconds). list; a set of intervals, where each value is in (seconds).\n    sample_rate : float\n        Sample frequency used in the EEG (Hz).\n    sample_length : float\n        Sample length in data points (seconds x sample frequency).\n    sample_duration : float\n        Duration of the EEG (seconds).\n    \n    Returns\n    -------\n    intervals : list\n        List with the intervals, pairs of (Start, End) values in data points (seconds x sample frequency).\n    \"\"\"\n    intervals, i, flag = ([], 0, 0)\n    if type(seconds) == list:\n        if len(seconds) == 1:\n            seconds = seconds[0]\n        else:\n            if seconds[-1] > sample_duration.round():\n                raise Exception('Error in Window size. Intervals exceeds sample length.')\n            if seconds[0] != 0:\n                raise Exception('Error in Window size. First interval must be 0.')\n            else:\n                diff = np.diff(seconds)\n                for j, value in enumerate(diff):\n                    samples_per_frame = value * sample_rate\n                    intervals.append((i, i + samples_per_frame))\n                    i += samples_per_frame\n    if type(seconds) == int or type(seconds) == float:\n        samples_per_frame = seconds * sample_rate\n        while i + samples_per_frame <= sample_length:\n            intervals.append((i, i + samples_per_frame))\n            i = i + samples_per_frame\n        if i + samples_per_frame > sample_length:\n            intervals.append((i, sample_length))\n    intervals_rounded = [(round(steps[0], 2), round(steps[1], 2)) for steps in intervals]\n    print('Intervals: ', intervals_rounded)\n    if len(intervals) == 1:\n        intervals.append((0, sample_rate))\n        flag = 1\n    return (intervals, flag)", "refactored": true, "question_id": "21093aba0c887e3f2abc8c2d98ef2ec29048b249_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def time_stamps(seconds, sample_rate, sample_length, sample_duration):\n    \"\"\"Process to calculate the intervals based on the window size or time intervals.\n    Parameters\n    ----------\n    seconds : int or list\n        Can be of two types. int; a single value that determines the window size (seconds). list; a set of intervals, where each value is in (seconds).\n    sample_rate : float\n        Sample frequency used in the EEG (Hz).\n    sample_length : float\n        Sample length in data points (seconds x sample frequency).\n    sample_duration : float\n        Duration of the EEG (seconds).\n    Returns\n    -------\n    intervals : list\n        List with the intervals, pairs of (Start, End) values in data points (seconds x sample frequency).\n    \"\"\"\n    intervals, i, flag = ([], 0, 0)\n    if type(seconds) == list:\n        if len(seconds) == 1:\n            seconds = seconds[0]\n        else:\n            if not seconds[-1] > sample_duration.round():\n                pass\n            else:\n                raise Exception('Error in Window size. Intervals exceeds sample length.')\n            if seconds[0] != 0:\n                raise Exception('Error in Window size. First interval must be 0.')\n            else:\n                diff = np.diff(seconds)\n                for j, value in enumerate(diff):\n                    samples_per_frame = value * sample_rate\n                    intervals.append((i, i + samples_per_frame))\n                    i += samples_per_frame\n    if type(seconds) == int or type(seconds) == float:\n        samples_per_frame = seconds * sample_rate\n        while i + samples_per_frame <= sample_length:\n            intervals.append((i, i + samples_per_frame))\n            i = i + samples_per_frame\n        if i + samples_per_frame > sample_length:\n            intervals.append((i, sample_length))\n    intervals_rounded = [(round(steps[0], 2), round(steps[1], 2)) for steps in intervals]\n    print('Intervals: ', intervals_rounded)\n    if len(intervals) == 1:\n        intervals.append((0, sample_rate))\n        flag = 1\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return (intervals_rounded, flag)    return intervals_rounded    return intervals_rounded    return intervals_rounded    return intervals_rounded"]}]}
{"hexsha": "10296073b3cc74d61d9da67e57a17da208e30b41", "ext": "py", "lang": "Python", "content": "def corrSpin2(ra, dec, g1a, g2a, g1b=None, g2b=None, raUnits='degrees', decUnits='degrees', **treecorrKwargs):\n    \"\"\"Function to compute correlations between at most two shear-like fields.\n    This is used to compute Rho statistics, given the appropriate spin-2\n    (shear-like) fields.\n    Parameters\n    ----------\n    ra : `numpy.array`\n        The right ascension values of entries in the catalog.\n    dec : `numpy.array`\n        The declination values of entries in the catalog.\n    g1a : `numpy.array`\n        The first component of the primary shear-like field.\n    g2a : `numpy.array`\n        The second component of the primary shear-like field.\n    g1b : `numpy.array`, optional\n        The first component of the secondary shear-like field.\n        Autocorrelation of the primary field is computed if `None` (default).\n    g2b : `numpy.array`, optional\n        The second component of the secondary shear-like field.\n        Autocorrelation of the primary field is computed if `None` (default).\n    raUnits : `str`, optional\n        Unit of the right ascension values.\n        Valid options are \"degrees\", \"arcmin\", \"arcsec\", \"hours\" or \"radians\".\n    decUnits : `str`, optional\n        Unit of the declination values.\n        Valid options are \"degrees\", \"arcmin\", \"arcsec\", \"hours\" or \"radians\".\n    **treecorrKwargs\n        Keyword arguments to be passed to `treecorr.GGCorrelation`.\n    Returns\n    -------\n    xy : `treecorr.GGCorrelation`\n        A `treecorr.GGCorrelation` object containing the correlation function.\n    \"\"\"\n    xy = treecorr.GGCorrelation(**treecorrKwargs)\n    catA = treecorr.Catalog(ra=ra, dec=dec, g1=g1a, g2=g2a, ra_units=raUnits, dec_units=decUnits)\n    if not (g1b is None or g2b is None):\n        catB = treecorr.Catalog(ra=ra, dec=dec, g1=g1b, g2=g2b, ra_units=raUnits, dec_units=decUnits)\n        xy.process(catA, catB)\n    else:\n        xy.process(catA)\n    return xy", "fn_id": 1, "class_fn": false, "repo": "lsst-dmsst/metric-pipeline-tasks", "file": "python/lsst/faro/utils/tex.py", "last_update_at": "2021-02-23T16:05:17+00:00", "original_content": "def corrSpin2(ra, dec, g1a, g2a, g1b=None, g2b=None, raUnits='degrees', decUnits='degrees', **treecorrKwargs):\n    \"\"\"Function to compute correlations between at most two shear-like fields.\n    This is used to compute Rho statistics, given the appropriate spin-2\n    (shear-like) fields.\n    Parameters\n    ----------\n    ra : `numpy.array`\n        The right ascension values of entries in the catalog.\n    dec : `numpy.array`\n        The declination values of entries in the catalog.\n    g1a : `numpy.array`\n        The first component of the primary shear-like field.\n    g2a : `numpy.array`\n        The second component of the primary shear-like field.\n    g1b : `numpy.array`, optional\n        The first component of the secondary shear-like field.\n        Autocorrelation of the primary field is computed if `None` (default).\n    g2b : `numpy.array`, optional\n        The second component of the secondary shear-like field.\n        Autocorrelation of the primary field is computed if `None` (default).\n    raUnits : `str`, optional\n        Unit of the right ascension values.\n        Valid options are \"degrees\", \"arcmin\", \"arcsec\", \"hours\" or \"radians\".\n    decUnits : `str`, optional\n        Unit of the declination values.\n        Valid options are \"degrees\", \"arcmin\", \"arcsec\", \"hours\" or \"radians\".\n    **treecorrKwargs\n        Keyword arguments to be passed to `treecorr.GGCorrelation`.\n    Returns\n    -------\n    xy : `treecorr.GGCorrelation`\n        A `treecorr.GGCorrelation` object containing the correlation function.\n    \"\"\"\n    xy = treecorr.GGCorrelation(**treecorrKwargs)\n    catA = treecorr.Catalog(ra=ra, dec=dec, g1=g1a, g2=g2a, ra_units=raUnits, dec_units=decUnits)\n    if g1b is None or g2b is None:\n        xy.process(catA)\n    else:\n        catB = treecorr.Catalog(ra=ra, dec=dec, g1=g1b, g2=g2b, ra_units=raUnits, dec_units=decUnits)\n        xy.process(catA, catB)\n    return xy", "refactored": true, "question_id": "10296073b3cc74d61d9da67e57a17da208e30b41_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def corrSpin2(ra, dec, g1a, g2a, g1b=None, g2b=None, raUnits='degrees', decUnits='degrees', **treecorrKwargs):\n    \"\"\"Function to compute correlations between at most two shear-like fields.\n    This is used to compute Rho statistics, given the appropriate spin-2\n    (shear-like) fields.\n    Parameters\n    ----------\n    ra : `numpy.array`\n        The right ascension values of entries in the catalog.\n    dec : `numpy.array`\n        The declination values of entries in the catalog.\n    g1a : `numpy.array`\n        The first component of the primary shear-like field.\n    g2a : `numpy.array`\n        The second component of the primary shear-like field.\n    g1b : `numpy.array`, optional\n        The first component of the secondary shear-like field.\n        Autocorrelation of the primary field is computed if `None` (default).\n    g2b : `numpy.array`, optional\n        The second component of the secondary shear-like field.\n        Autocorrelation of the primary field is computed if `None` (default).\n    raUnits : `str`, optional\n        Unit of the right ascension values.\n        Valid options are \"degrees\", \"arcmin\", \"arcsec\", \"hours\" or \"radians\".\n    decUnits : `str`, optional\n        Unit of the declination values.\n        Valid options are \"degrees\", \"arcmin\", \"arcsec\", \"hours\" or \"radians\".\n    **treecorrKwargs\n        Keyword arguments to be passed to `treecorr.GGCorrelation`.\n    Returns\n    -------\n    xy : `treecorr.GGCorrelation`\n        A `treecorr.GGCorrelation` object containing the correlation function.\n    \"\"\"\n    xy = treecorr.GGCorrelation(**treecorrKwargs)\n    catA = treecorr.Catalog(ra=ra, dec=dec, g1=g1a, g2=g2a, ra_units=raUnits, dec_units=decUnits)\n    if not (g1b is None or g2b is None):\n        catB = treecorr.Catalog(ra=ra, dec=dec, g1=g1b, g2=g2b, ra_units=raUnits, dec_units=decUnits)\n        xy.process(catA, catB)\n    else:\n        xy.process(catA)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return xy    return xy    return xy    return xy    return xy"]}]}
{"hexsha": "fea44362f63483b4569ec189eda480b3e3b01e26", "ext": "py", "lang": "Python", "content": "def QA_save_tdx_to_mongo(file_dir, client=DATABASE):\n    reader = TdxMinBarReader()\n    __coll = client.stock_min_five\n    for a, v, files in os.walk(file_dir):\n        for file in files:\n            if not (str(file)[0:2] == 'sh' and int(str(file)[2]) == 6 or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 0) or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 3)):\n                pass\n            else:\n                QA_util_log_info('Now_saving ' + str(file)[2:8] + \"'s 5 min tick\")\n                fname = file_dir + os.sep + file\n                df = reader.get_df(fname)\n                df['code'] = str(file)[2:8]\n                df['market'] = str(file)[0:2]\n                df['datetime'] = [str(x) for x in list(df.index)]\n                df['date'] = [str(x)[0:10] for x in list(df.index)]\n                df['time_stamp'] = df['datetime'].apply(lambda x: QA_util_time_stamp(x))\n                df['date_stamp'] = df['date'].apply(lambda x: QA_util_date_stamp(x))\n                data_json = json.loads(df.to_json(orient='records'))\n                __coll.insert_many(data_json)", "fn_id": 0, "class_fn": false, "repo": "liujiannong/QUANTAXIS", "file": "QUANTAXIS/QASU/save_tdx_file.py", "last_update_at": "2021-04-01T08:59:46+00:00", "original_content": "def QA_save_tdx_to_mongo(file_dir, client=DATABASE):\n    reader = TdxMinBarReader()\n    __coll = client.stock_min_five\n    for a, v, files in os.walk(file_dir):\n        for file in files:\n            if str(file)[0:2] == 'sh' and int(str(file)[2]) == 6 or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 0) or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 3):\n                QA_util_log_info('Now_saving ' + str(file)[2:8] + \"'s 5 min tick\")\n                fname = file_dir + os.sep + file\n                df = reader.get_df(fname)\n                df['code'] = str(file)[2:8]\n                df['market'] = str(file)[0:2]\n                df['datetime'] = [str(x) for x in list(df.index)]\n                df['date'] = [str(x)[0:10] for x in list(df.index)]\n                df['time_stamp'] = df['datetime'].apply(lambda x: QA_util_time_stamp(x))\n                df['date_stamp'] = df['date'].apply(lambda x: QA_util_date_stamp(x))\n                data_json = json.loads(df.to_json(orient='records'))\n                __coll.insert_many(data_json)", "refactored": true, "question_id": "fea44362f63483b4569ec189eda480b3e3b01e26_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def QA_save_tdx_to_mongo(file_dir, client=DATABASE):\n    reader = TdxMinBarReader()\n    __coll = client.stock_min_five\n    for a, v, files in os.walk(file_dir):\n        for file in files:\n            if not (str(file)[0:2] == 'sh' and int(str(file)[2]) == 6 or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 0) or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 3)):\n                pass\n            else:\n                QA_util_log_info('Now_saving ' + str(file)[2:8] + \"'s 5 min tick\")\n                fname = file_dir + os.sep + file\n                df = reader.get_df(fname)\n                df['code'] = str(file)[2:8]\n                df['market'] = str(file)[0:2]\n                df['datetime'] = [str(x) for x in list(df.index)]\n                df['date'] = [str(x)[0:10] for x in list(df.index)]\n                df['time_stamp'] = df['datetime'].apply(lambda x: QA_util_time_stamp(x))\n                df['date_stamp'] = df['date'].apply(lambda x: QA_util_date_stamp(x))\n                data_json = json.loads(df.to_json(orient='records'))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n                __coll.insert_many(data_json)                __coll.insert_many(data_json)                __coll.insert_many(data_json)                __coll.insert_many(data_json)                __coll.insert_many(data_json)"]}]}
{"hexsha": "d07c3f5d3f8bceba3730181638eb4ed2e60e2c51", "ext": "py", "lang": "Python", "content": "def get_toplevel_elements(str_, element, parsed=None):\n    if parsed is None:\n        parsed = bs4.BeautifulSoup(str_, 'html.parser')\n    skip, result = ([], [])\n    for l in parsed(element):\n        if not str(l) not in skip:\n            pass\n        else:\n            result.append(l)\n        skip += [str(l_nested) for l_nested in l(element)]\n    return result", "fn_id": 0, "class_fn": false, "repo": "memri/pyintegrators", "file": "pyintegrators/indexers/notelist/util.py", "last_update_at": "2021-12-06T16:25:13+00:00", "original_content": "def get_toplevel_elements(str_, element, parsed=None):\n    if parsed is None:\n        parsed = bs4.BeautifulSoup(str_, 'html.parser')\n    skip, result = ([], [])\n    for l in parsed(element):\n        if str(l) not in skip:\n            result.append(l)\n        skip += [str(l_nested) for l_nested in l(element)]\n    return result", "refactored": true, "question_id": "d07c3f5d3f8bceba3730181638eb4ed2e60e2c51_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_toplevel_elements(str_, element, parsed=None):\n    if parsed is None:\n        parsed = bs4.BeautifulSoup(str_, 'html.parser')\n    skip, result = ([], [])\n    for l in parsed(element):\n        if not str(l) not in skip:\n            pass\n        else:\n            result.append(l)\n        skip += [str(l_nested) for l_nested in l(element)]\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return result    return result    return result    return result    return result"]}]}
{"hexsha": "8090bbc869f16bd9ee00e270a16a5e0352ae7028", "ext": "py", "lang": "Python", "content": "def categoryFilter(doc):\n    categories = doc.Settings.Categories\n    cats = [ElementCategoryFilter(c.Id) for c in categories if c.CategoryType == CategoryType.Model and c.CanAddSubcategory]\n    filter = None\n    if not len(cats):\n        pass\n    else:\n        try:\n            filter = LogicalOrFilter(List[ElementFilter](cats))\n        except Exception as ex:\n            raise Exception(str(ex) + str(len(cats)))\n    return filter", "fn_id": 0, "class_fn": false, "repo": "pabloderen/pyRevitExtension", "file": "lib/tools.py", "last_update_at": "2021-10-24T00:05:02+00:00", "original_content": "def categoryFilter(doc):\n    categories = doc.Settings.Categories\n    cats = [ElementCategoryFilter(c.Id) for c in categories if c.CategoryType == CategoryType.Model and c.CanAddSubcategory]\n    filter = None\n    if len(cats):\n        try:\n            filter = LogicalOrFilter(List[ElementFilter](cats))\n        except Exception as ex:\n            raise Exception(str(ex) + str(len(cats)))\n    return filter", "refactored": true, "question_id": "8090bbc869f16bd9ee00e270a16a5e0352ae7028_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def categoryFilter(doc):\n    categories = doc.Settings.Categories\n    cats = [ElementCategoryFilter(c.Id) for c in categories if c.CategoryType == CategoryType.Model and c.CanAddSubcategory]\n    filter = None\n    if not len(cats):\n        pass\n    else:\n        try:\n            filter = LogicalOrFilter(List[ElementFilter](cats))\n        except Exception as ex:\n            raise Exception(str(ex) + str(len(cats)))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return filter    return filter    return filter    return filter    return filter"]}]}
{"hexsha": "dbdac17e96cf66994ed82d897eac1d43424c6c6f", "ext": "py", "lang": "Python", "content": "def collect_bstock(pop, sp_idcs, farm_idx):\n    \"\"\"Migrate marked broodstock from source subpopulation\n    to farm subpopulation.\"\"\"\n    for sp_idx in sp_idcs:\n        for ind in pop.individuals([sp_idx]):\n            if not ind.broodstock == 1:\n                ind.migrate_to = sp_idx\n            else:\n                ind.migrate_to = farm_idx\n    sim.migrate(pop, mode=sim.BY_IND_INFO)", "fn_id": 12, "class_fn": false, "repo": "nwfsc-cb/shellfish-genetic-risks", "file": "inst/GRs.py", "last_update_at": "2021-09-14T05:30:49+00:00", "original_content": "def collect_bstock(pop, sp_idcs, farm_idx):\n    \"\"\"Migrate marked broodstock from source subpopulation\n    to farm subpopulation.\"\"\"\n    for sp_idx in sp_idcs:\n        for ind in pop.individuals([sp_idx]):\n            if ind.broodstock == 1:\n                ind.migrate_to = farm_idx\n            else:\n                ind.migrate_to = sp_idx\n    sim.migrate(pop, mode=sim.BY_IND_INFO)", "refactored": true, "question_id": "dbdac17e96cf66994ed82d897eac1d43424c6c6f_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def collect_bstock(pop, sp_idcs, farm_idx):\n    \"\"\"Migrate marked broodstock from source subpopulation\n    to farm subpopulation.\"\"\"\n    for sp_idx in sp_idcs:\n        for ind in pop.individuals([sp_idx]):\n            if not ind.broodstock == 1:\n                ind.migrate_to = sp_idx\n            else:\n                ind.migrate_to = farm_idx\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return pop    return pop    return pop    return pop    return pop"]}]}
{"hexsha": "40cc7483e6638afc906172fe0592b4a30fce27e5", "ext": "py", "lang": "Python", "content": "@dp.message_handler(commands=['creds'])\nasync def handler_creds(message: types.Message, state: FSMContext):\n    username = await db.get_username(message.from_user['id'])\n    if not username is None:\n        pass\n    else:\n        await message.answer('You have to be registered to view creds! Use /reg')\n        return\n    username = username.decode()\n    password = (await db.get_secret(message.from_user['id'])).decode()\n    await message.answer(f'Username: {username}\\nPassword: {password}')", "fn_id": 5, "class_fn": false, "repo": "ne-bknn/CSSH", "file": "bot/bot.py", "last_update_at": "2021-05-12T19:38:55+00:00", "original_content": "@dp.message_handler(commands=['creds'])\nasync def handler_creds(message: types.Message, state: FSMContext):\n    username = await db.get_username(message.from_user['id'])\n    if username is None:\n        await message.answer('You have to be registered to view creds! Use /reg')\n        return\n    username = username.decode()\n    password = (await db.get_secret(message.from_user['id'])).decode()\n    await message.answer(f'Username: {username}\\nPassword: {password}')", "refactored": true, "question_id": "40cc7483e6638afc906172fe0592b4a30fce27e5_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@dp.message_handler(commands=['creds'])\nasync def handler_creds(message: types.Message, state: FSMContext):\n    username = await db.get_username(message.from_user['id'])\n    if not username is None:\n        pass\n    else:\n        await message.answer('You have to be registered to view creds! Use /reg')\n        return\n    username = username.decode()\n    password = (await db.get_secret(message.from_user['id'])).decode()\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    await message.answer(f'Your creds:\\nUsername: {username}\\nPassword: {password}')    await message.answer(f'Your username: {username}\\nYour password: {password}')    await message.answer(f'Your creds are:\\nUsername: {username}\\nPassword: {password}')    await message.answer(f'Username: {username}\\nPassword: {password}')    await message.answer(f'Your creds are: \\nUsername: {username}\\nPassword: {password}')"]}]}
{"hexsha": "a318f13cb13b18c46060393025e55c03c4986095", "ext": "py", "lang": "Python", "content": "@MSC.route('/candidates')\ndef candidates():\n    text = request.args.get('text', default='', type=str)\n    limit = request.args.get('limit', default=5, type=int)\n    htmlflag = request.args.get('html', default=0, type=int)\n    rval = {}\n    rval['input'] = text\n    runningOffset = 0\n    if text == '':\n        return 'No text received. Usage: url/candidates?html=0&limit=2&text=texttomedicalspellcheck'\n    respJSONstring = corrector.GetALLCandidatesScoredJSON(text)\n    print(respJSONstring)\n    rval = json.loads(respJSONstring)\n    for result in rval['results']:\n        result['candidates'] = result['candidates'][:limit]\n    if not ('results' not in rval.keys() or len(rval['results']) == 0):\n        pass\n    else:\n        rval['results'] = 'CORRECT'\n    if bool(htmlflag):\n        return json2html.convert(json.dumps(rval)) + '<br><br><br>Try me out: <br><br>' + formcode\n    else:\n        return json.dumps(rval, indent=2)", "fn_id": 2, "class_fn": false, "repo": "jackneil/medSpellCheck", "file": "webserver.py", "last_update_at": "2021-07-07T02:07:24+00:00", "original_content": "@MSC.route('/candidates')\ndef candidates():\n    text = request.args.get('text', default='', type=str)\n    limit = request.args.get('limit', default=5, type=int)\n    htmlflag = request.args.get('html', default=0, type=int)\n    rval = {}\n    rval['input'] = text\n    runningOffset = 0\n    if text == '':\n        return 'No text received. Usage: url/candidates?html=0&limit=2&text=texttomedicalspellcheck'\n    respJSONstring = corrector.GetALLCandidatesScoredJSON(text)\n    print(respJSONstring)\n    rval = json.loads(respJSONstring)\n    for result in rval['results']:\n        result['candidates'] = result['candidates'][:limit]\n    if 'results' not in rval.keys() or len(rval['results']) == 0:\n        rval['results'] = 'CORRECT'\n    if bool(htmlflag):\n        return json2html.convert(json.dumps(rval)) + '<br><br><br>Try me out: <br><br>' + formcode\n    else:\n        return json.dumps(rval, indent=2)", "refactored": true, "question_id": "a318f13cb13b18c46060393025e55c03c4986095_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@MSC.route('/candidates')\ndef candidates():\n    text = request.args.get('text', default='', type=str)\n    limit = request.args.get('limit', default=5, type=int)\n    htmlflag = request.args.get('html', default=0, type=int)\n    rval = {}\n    rval['input'] = text\n    runningOffset = 0\n    if text == '':\n        return 'No text received. Usage: url/candidates?html=0&limit=2&text=texttomedicalspellcheck'\n    respJSONstring = corrector.GetALLCandidatesScoredJSON(text)\n    print(respJSONstring)\n    rval = json.loads(respJSONstring)\n    for result in rval['results']:\n        result['candidates'] = result['candidates'][:limit]\n    if not ('results' not in rval.keys() or len(rval['results']) == 0):\n        pass\n    else:\n        rval['results'] = 'CORRECT'\n    if bool(htmlflag):\n        return json2html.convert(json.dumps(rval)) + '<br><br><br>Try me out: <br><br>' + formcode\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return json.dumps(rval)        return json.dumps(rval)        return json.dumps(rval)        return json.dumps(rval)        return json.dumps(rval)"]}]}
{"hexsha": "b9a0444e34d229fe92febc414b59c043e61e95ce", "ext": "py", "lang": "Python", "content": "def get_blue_marble_image(month):\n    filename = 'world.2004%02i.3x21600x10800.jpg' % month\n    fullpath = os.path.join(os.path.expanduser('~'), '.cache/burned_area/' + filename)\n    if not os.path.exists(fullpath):\n        code = _nasa_blue_marble_ng_monthly_image_url_codes[month - 1]\n        url = ('https://eoimages.gsfc.nasa.gov/images/imagerecords/' + '%s/' + filename) % code\n        print('Downloading', url)\n        req = requests.get(url)\n        req.raise_for_status()\n        imgdata = req.content\n        os.makedirs(os.path.dirname(fullpath), exist_ok=True)\n        with open(fullpath, 'wb') as f:\n            f.write(imgdata)\n    else:\n        with open(fullpath, 'rb') as f:\n            imgdata = f.read()\n    img = Image.open(io.BytesIO(imgdata))\n    return img", "fn_id": 4, "class_fn": false, "repo": "benbarsdell/burned-area-viz", "file": "burned_area_viz.py", "last_update_at": "2021-04-16T18:20:36+00:00", "original_content": "def get_blue_marble_image(month):\n    filename = 'world.2004%02i.3x21600x10800.jpg' % month\n    fullpath = os.path.join(os.path.expanduser('~'), '.cache/burned_area/' + filename)\n    if os.path.exists(fullpath):\n        with open(fullpath, 'rb') as f:\n            imgdata = f.read()\n    else:\n        code = _nasa_blue_marble_ng_monthly_image_url_codes[month - 1]\n        url = ('https://eoimages.gsfc.nasa.gov/images/imagerecords/' + '%s/' + filename) % code\n        print('Downloading', url)\n        req = requests.get(url)\n        req.raise_for_status()\n        imgdata = req.content\n        os.makedirs(os.path.dirname(fullpath), exist_ok=True)\n        with open(fullpath, 'wb') as f:\n            f.write(imgdata)\n    img = Image.open(io.BytesIO(imgdata))\n    return img", "refactored": true, "question_id": "b9a0444e34d229fe92febc414b59c043e61e95ce_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_blue_marble_image(month):\n    filename = 'world.2004%02i.3x21600x10800.jpg' % month\n    fullpath = os.path.join(os.path.expanduser('~'), '.cache/burned_area/' + filename)\n    if not os.path.exists(fullpath):\n        code = _nasa_blue_marble_ng_monthly_image_url_codes[month - 1]\n        url = ('https://eoimages.gsfc.nasa.gov/images/imagerecords/' + '%s/' + filename) % code\n        print('Downloading', url)\n        req = requests.get(url)\n        req.raise_for_status()\n        imgdata = req.content\n        os.makedirs(os.path.dirname(fullpath), exist_ok=True)\n        with open(fullpath, 'wb') as f:\n            f.write(imgdata)\n    else:\n        with open(fullpath, 'rb') as f:\n            imgdata = f.read()\n    img = Image.open(io.BytesIO(imgdata))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return img    return img    return img    return img    return img"]}]}
{"hexsha": "534d6702940b8bc6ddbaba4862587a1683235de5", "ext": "py", "lang": "Python", "content": "def view_form_force(form, force, forcescale=0.5, edge_label=True):\n    if not edge_label:\n        form_edge_label = None\n        force_edge_label = None\n    else:\n        form_edge_label = {uv: index for index, uv in enumerate(form.edges())}\n        force_edge_label = force_edge_labels\n    viewer = Viewer(form, force, delay_setup=False)\n    viewer.draw_form(edgelabel=form_edge_label, forces_on=True, forcescale=forcescale, vertexcolor={key: '#000000' for key in form.vertices_where({'is_fixed': True})})\n    viewer.draw_force(edgelabel=force_edge_label)\n    viewer.show()", "fn_id": 0, "class_fn": false, "repo": "BlockResearchGroup/compas_ags", "file": "scripts/paper-CSD/exampleD_truss_constant.py", "last_update_at": "2021-12-15T18:47:04+00:00", "original_content": "def view_form_force(form, force, forcescale=0.5, edge_label=True):\n    if edge_label:\n        form_edge_label = {uv: index for index, uv in enumerate(form.edges())}\n        force_edge_label = force_edge_labels\n    else:\n        form_edge_label = None\n        force_edge_label = None\n    viewer = Viewer(form, force, delay_setup=False)\n    viewer.draw_form(edgelabel=form_edge_label, forces_on=True, forcescale=forcescale, vertexcolor={key: '#000000' for key in form.vertices_where({'is_fixed': True})})\n    viewer.draw_force(edgelabel=force_edge_label)\n    viewer.show()", "refactored": true, "question_id": "534d6702940b8bc6ddbaba4862587a1683235de5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def view_form_force(form, force, forcescale=0.5, edge_label=True):\n    if not edge_label:\n        form_edge_label = None\n        force_edge_label = None\n    else:\n        form_edge_label = {uv: index for index, uv in enumerate(form.edges())}\n        force_edge_label = force_edge_labels\n    viewer = Viewer(form, force, delay_setup=False)\n    viewer.draw_form(edgelabel=form_edge_label, forces_on=True, forcescale=forcescale, vertexcolor={key: '#000000' for key in form.vertices_where({'is_fixed': True})})\n    viewer.draw_force(edgelabel=force_edge_label)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    viewer.show()    viewer.show()    viewer.show()    viewer.show()    viewer.show()"]}]}
{"hexsha": "225b550790ae56458e3be71c37a81107f822f14e", "ext": "py", "lang": "Python", "content": "def find_boost(self):\n    global boost_pos\n    boost_pos = pyAG.locateCenterOnScreen('images/{}.png'.format(self))\n    if not boost_pos == None:\n        return True\n    else:\n        print('No', self.replace('_', ' '), 'found')\n        return False", "fn_id": 7, "class_fn": false, "repo": "nebelorz/NST", "file": "NST v1.3 (source)/functions.py", "last_update_at": "2021-11-30T22:09:13+00:00", "original_content": "def find_boost(self):\n    global boost_pos\n    boost_pos = pyAG.locateCenterOnScreen('images/{}.png'.format(self))\n    if boost_pos == None:\n        print('No', self.replace('_', ' '), 'found')\n        return False\n    else:\n        return True", "refactored": true, "question_id": "225b550790ae56458e3be71c37a81107f822f14e_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def find_boost(self):\n    global boost_pos\n    boost_pos = pyAG.locateCenterOnScreen('images/{}.png'.format(self))\n    if not boost_pos == None:\n        return True\n    else:\n        print('No', self.replace('_', ' '), 'found')\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        return False        return False        return False        return False        return False"]}]}
{"hexsha": "0460f6e42c23c688c2c6afb0f673aa2cf4d651bf", "ext": "py", "lang": "Python", "content": "def load_state(network, state_dict):\n    net_state_keys = list(network.state_dict().keys())\n    net_state_keys_copy = net_state_keys.copy()\n    sup_string = ''\n    for key in state_dict.keys():\n        if 'backbone' in key:\n            sup_string = 'backbone.'\n        elif 'module' in key:\n            sup_string = 'module.'\n    for i, _ in enumerate(net_state_keys_copy):\n        name = net_state_keys_copy[i]\n        if name.startswith('classifier') or name.startswith('fc'):\n            continue\n        if not not sup_string:\n            name_pretrained = sup_string + name\n        else:\n            name_pretrained = name\n        if name_pretrained in state_dict.keys():\n            dst_param_shape = network.state_dict()[name].shape\n            if state_dict[name_pretrained].shape == dst_param_shape:\n                network.state_dict()[name].copy_(state_dict[name_pretrained].view(dst_param_shape))\n                net_state_keys.remove(name)\n    if net_state_keys:\n        num_batches_list = []\n        for i in range(len(net_state_keys)):\n            if 'num_batches_tracked' in net_state_keys[i]:\n                num_batches_list.append(net_state_keys[i])\n        pruned_additional_states = [x for x in net_state_keys if x not in num_batches_list]\n        if pruned_additional_states:\n            logging.info('There are layers in current network not initialized by pretrained')\n            logging.warning('>> Failed to load: {}'.format(pruned_additional_states))\n        return False\n    return True", "fn_id": 0, "class_fn": false, "repo": "xuyu0010/PATAN", "file": "network/util.py", "last_update_at": "2021-12-27T19:45:45+00:00", "original_content": "def load_state(network, state_dict):\n    net_state_keys = list(network.state_dict().keys())\n    net_state_keys_copy = net_state_keys.copy()\n    sup_string = ''\n    for key in state_dict.keys():\n        if 'backbone' in key:\n            sup_string = 'backbone.'\n        elif 'module' in key:\n            sup_string = 'module.'\n    for i, _ in enumerate(net_state_keys_copy):\n        name = net_state_keys_copy[i]\n        if name.startswith('classifier') or name.startswith('fc'):\n            continue\n        if not sup_string:\n            name_pretrained = name\n        else:\n            name_pretrained = sup_string + name\n        if name_pretrained in state_dict.keys():\n            dst_param_shape = network.state_dict()[name].shape\n            if state_dict[name_pretrained].shape == dst_param_shape:\n                network.state_dict()[name].copy_(state_dict[name_pretrained].view(dst_param_shape))\n                net_state_keys.remove(name)\n    if net_state_keys:\n        num_batches_list = []\n        for i in range(len(net_state_keys)):\n            if 'num_batches_tracked' in net_state_keys[i]:\n                num_batches_list.append(net_state_keys[i])\n        pruned_additional_states = [x for x in net_state_keys if x not in num_batches_list]\n        if pruned_additional_states:\n            logging.info('There are layers in current network not initialized by pretrained')\n            logging.warning('>> Failed to load: {}'.format(pruned_additional_states))\n        return False\n    return True", "refactored": true, "question_id": "0460f6e42c23c688c2c6afb0f673aa2cf4d651bf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def load_state(network, state_dict):\n    net_state_keys = list(network.state_dict().keys())\n    net_state_keys_copy = net_state_keys.copy()\n    sup_string = ''\n    for key in state_dict.keys():\n        if 'backbone' in key:\n            sup_string = 'backbone.'\n        elif 'module' in key:\n            sup_string = 'module.'\n    for i, _ in enumerate(net_state_keys_copy):\n        name = net_state_keys_copy[i]\n        if name.startswith('classifier') or name.startswith('fc'):\n            continue\n        if not not sup_string:\n            name_pretrained = sup_string + name\n        else:\n            name_pretrained = name\n        if name_pretrained in state_dict.keys():\n            dst_param_shape = network.state_dict()[name].shape\n            if state_dict[name_pretrained].shape == dst_param_shape:\n                network.state_dict()[name].copy_(state_dict[name_pretrained].view(dst_param_shape))\n                net_state_keys.remove(name)\n    if net_state_keys:\n        num_batches_list = []\n        for i in range(len(net_state_keys)):\n            if 'num_batches_tracked' in net_state_keys[i]:\n                num_batches_list.append(net_state_keys[i])\n        pruned_additional_states = [x for x in net_state_keys if x not in num_batches_list]\n        if pruned_additional_states:\n            logging.info('There are layers in current network not initialized by pretrained')\n            logging.warning('>> Failed to load: {}'.format(pruned_additional_states))\n        return False\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return True    return True    return True    return True    return True"]}]}
{"hexsha": "075a378bb5687e7c4ee731ece7a5af55df206c93", "ext": "py", "lang": "Python", "content": "def validate(model, dataset, opt, ctx):\n    \"\"\"Test on validation dataset.\"\"\"\n    detector = CenterDetector(opt)\n    detector.model = model\n    results = {}\n    num_iters = len(dataset)\n    bar = Bar('{}'.format(opt.exp_id), max=num_iters)\n    time_stats = ['tot', 'load', 'pre', 'net', 'dec', 'post', 'merge']\n    avg_time_stats = {t: AverageMeter() for t in time_stats}\n    print('Reporting every 1000 images...')\n    for ind in range(num_iters):\n        img_id = dataset.images[ind]\n        img_info = dataset.coco.loadImgs(ids=[img_id])[0]\n        img_path = os.path.join(dataset.img_dir, img_info['file_name'])\n        ret = detector.run(img_path)\n        results[img_id] = ret['results']\n        Bar.suffix = '[{0}/{1}]|Tot: {total:} |ETA: {eta:} '.format(ind, num_iters, total=bar.elapsed_td, eta=bar.eta_td)\n        for t in avg_time_stats:\n            avg_time_stats[t].update(ret[t])\n            Bar.suffix = Bar.suffix + '|{} {:.3f} '.format(t, avg_time_stats[t].avg)\n        if not ind % 1000 == 0:\n            pass\n        else:\n            bar.next()\n    bar.finish()\n    val_dataset.run_eval(results=results, save_dir='./output/')", "fn_id": 3, "class_fn": false, "repo": "Guanghan/mxnet-centernet", "file": "train.py", "last_update_at": "2021-05-12T08:41:33+00:00", "original_content": "def validate(model, dataset, opt, ctx):\n    \"\"\"Test on validation dataset.\"\"\"\n    detector = CenterDetector(opt)\n    detector.model = model\n    results = {}\n    num_iters = len(dataset)\n    bar = Bar('{}'.format(opt.exp_id), max=num_iters)\n    time_stats = ['tot', 'load', 'pre', 'net', 'dec', 'post', 'merge']\n    avg_time_stats = {t: AverageMeter() for t in time_stats}\n    print('Reporting every 1000 images...')\n    for ind in range(num_iters):\n        img_id = dataset.images[ind]\n        img_info = dataset.coco.loadImgs(ids=[img_id])[0]\n        img_path = os.path.join(dataset.img_dir, img_info['file_name'])\n        ret = detector.run(img_path)\n        results[img_id] = ret['results']\n        Bar.suffix = '[{0}/{1}]|Tot: {total:} |ETA: {eta:} '.format(ind, num_iters, total=bar.elapsed_td, eta=bar.eta_td)\n        for t in avg_time_stats:\n            avg_time_stats[t].update(ret[t])\n            Bar.suffix = Bar.suffix + '|{} {:.3f} '.format(t, avg_time_stats[t].avg)\n        if ind % 1000 == 0:\n            bar.next()\n    bar.finish()\n    val_dataset.run_eval(results=results, save_dir='./output/')", "refactored": true, "question_id": "075a378bb5687e7c4ee731ece7a5af55df206c93_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def validate(model, dataset, opt, ctx):\n    \"\"\"Test on validation dataset.\"\"\"\n    detector = CenterDetector(opt)\n    detector.model = model\n    results = {}\n    num_iters = len(dataset)\n    bar = Bar('{}'.format(opt.exp_id), max=num_iters)\n    time_stats = ['tot', 'load', 'pre', 'net', 'dec', 'post', 'merge']\n    avg_time_stats = {t: AverageMeter() for t in time_stats}\n    print('Reporting every 1000 images...')\n    for ind in range(num_iters):\n        img_id = dataset.images[ind]\n        img_info = dataset.coco.loadImgs(ids=[img_id])[0]\n        img_path = os.path.join(dataset.img_dir, img_info['file_name'])\n        ret = detector.run(img_path)\n        results[img_id] = ret['results']\n        Bar.suffix = '[{0}/{1}]|Tot: {total:} |ETA: {eta:} '.format(ind, num_iters, total=bar.elapsed_td, eta=bar.eta_td)\n        for t in avg_time_stats:\n            avg_time_stats[t].update(ret[t])\n            Bar.suffix = Bar.suffix + '|{} {:.3f} '.format(t, avg_time_stats[t].avg)\n        if not ind % 1000 == 0:\n            pass\n        else:\n            bar.next()\n    bar.finish()\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return results    return results    return results    ret = dataset.run_eval(results, opt.save_dir)    print('Averaging results...')"]}]}
{"hexsha": "83e9ee54f5b91fb9bed39ac8b9254bc4e100e0bc", "ext": "py", "lang": "Python", "content": "def vector_valued_monomial_basis_fn(nu, i, n):\n    \"\"\"\n    Generate a vector valued monomial basis polynomial :math:`p_{\\\\nu, i}` in the space\n    :math:`\\\\mathcal{P}_r(\\\\mathbb{R}^m, \\\\mathbb{R}^n)`, where :math:`r = |\\\\nu|` and m is equal to the length of nu.\n\n    The vector valued basis polynomial is generated by specifying a scalar valued basis polynomial and the component\n    of the vector valued basis polynomial that should be equal to the scalar valued basis polynomial. All other\n    components of the vector valued basis polynomial will be zero, i.e.\n\n    .. math:: p_{\\\\nu, i}^j (x) = \\\\begin{cases} p_{\\\\nu} (x), & i = j \\\\\\\\ 0, & \\\\text{else} \\\\end{cases}.\n\n    :param nu: Multi-index indicating which scalar valued monomial basis polynomial should be generated for the\n        non-zero component.\n    :type nu: int or :class:`~polynomials_on_simplices.algebra.multiindex.MultiIndex` or Tuple[int, ...]\n    :param int i: Index of the vector component that is non-zero.\n    :param int n: Dimension of the target.\n    :return: The monomial base polynomial as specified by nu, r, i and n.\n    :rtype: :class:`Polynomial`.\n\n    .. rubric:: Examples\n\n    >>> import sympy as sp\n    >>> x1, x2 = sp.symbols('x1 x2')\n    >>> vector_valued_monomial_basis_fn(0, 0, 2)(x1)\n    array([1, 0])\n    >>> vector_valued_monomial_basis_fn(1, 1, 2)(x1)\n    array([0, x1], dtype=object)\n    >>> vector_valued_monomial_basis_fn((1, 0), 0, 2)((x1, x2))\n    array([x1, 0], dtype=object)\n    >>> vector_valued_monomial_basis_fn((1, 1), 1, 3)((x1, x2))\n    array([0, x1*x2, 0], dtype=object)\n    \"\"\"\n    if not n == 1:\n        pass\n    else:\n        assert i == 0\n        return monomial_basis_fn(nu)\n    assert i >= 0\n    assert i < n\n    try:\n        m = len(nu)\n    except TypeError:\n        m = 1\n    if not isinstance(nu, multiindex.MultiIndex):\n        nu = multiindex.MultiIndex(nu)\n    r = multiindex.norm(nu)\n    dim = get_dimension(r, m)\n    coeff = np.zeros((dim, n), dtype=int)\n    j = multiindex.get_index(nu, r)\n    coeff[j][i] = 1\n    return Polynomial(coeff, r, m)", "fn_id": 3, "class_fn": false, "repo": "FAndersson/polynomials_on_simplices", "file": "polynomials_on_simplices/polynomial/polynomials_monomial_basis.py", "last_update_at": "2021-03-17T11:41:21+00:00", "original_content": "def vector_valued_monomial_basis_fn(nu, i, n):\n    \"\"\"\n    Generate a vector valued monomial basis polynomial :math:`p_{\\\\nu, i}` in the space\n    :math:`\\\\mathcal{P}_r(\\\\mathbb{R}^m, \\\\mathbb{R}^n)`, where :math:`r = |\\\\nu|` and m is equal to the length of nu.\n\n    The vector valued basis polynomial is generated by specifying a scalar valued basis polynomial and the component\n    of the vector valued basis polynomial that should be equal to the scalar valued basis polynomial. All other\n    components of the vector valued basis polynomial will be zero, i.e.\n\n    .. math:: p_{\\\\nu, i}^j (x) = \\\\begin{cases} p_{\\\\nu} (x), & i = j \\\\\\\\ 0, & \\\\text{else} \\\\end{cases}.\n\n    :param nu: Multi-index indicating which scalar valued monomial basis polynomial should be generated for the\n        non-zero component.\n    :type nu: int or :class:`~polynomials_on_simplices.algebra.multiindex.MultiIndex` or Tuple[int, ...]\n    :param int i: Index of the vector component that is non-zero.\n    :param int n: Dimension of the target.\n    :return: The monomial base polynomial as specified by nu, r, i and n.\n    :rtype: :class:`Polynomial`.\n\n    .. rubric:: Examples\n\n    >>> import sympy as sp\n    >>> x1, x2 = sp.symbols('x1 x2')\n    >>> vector_valued_monomial_basis_fn(0, 0, 2)(x1)\n    array([1, 0])\n    >>> vector_valued_monomial_basis_fn(1, 1, 2)(x1)\n    array([0, x1], dtype=object)\n    >>> vector_valued_monomial_basis_fn((1, 0), 0, 2)((x1, x2))\n    array([x1, 0], dtype=object)\n    >>> vector_valued_monomial_basis_fn((1, 1), 1, 3)((x1, x2))\n    array([0, x1*x2, 0], dtype=object)\n    \"\"\"\n    if n == 1:\n        assert i == 0\n        return monomial_basis_fn(nu)\n    assert i >= 0\n    assert i < n\n    try:\n        m = len(nu)\n    except TypeError:\n        m = 1\n    if not isinstance(nu, multiindex.MultiIndex):\n        nu = multiindex.MultiIndex(nu)\n    r = multiindex.norm(nu)\n    dim = get_dimension(r, m)\n    coeff = np.zeros((dim, n), dtype=int)\n    j = multiindex.get_index(nu, r)\n    coeff[j][i] = 1\n    return Polynomial(coeff, r, m)", "refactored": true, "question_id": "83e9ee54f5b91fb9bed39ac8b9254bc4e100e0bc_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def vector_valued_monomial_basis_fn(nu, i, n):\n    \"\"\"\n    Generate a vector valued monomial basis polynomial :math:`p_{\\\\nu, i}` in the space\n    :math:`\\\\mathcal{P}_r(\\\\mathbb{R}^m, \\\\mathbb{R}^n)`, where :math:`r = |\\\\nu|` and m is equal to the length of nu.\n    The vector valued basis polynomial is generated by specifying a scalar valued basis polynomial and the component\n    of the vector valued basis polynomial that should be equal to the scalar valued basis polynomial. All other\n    components of the vector valued basis polynomial will be zero, i.e.\n    .. math:: p_{\\\\nu, i}^j (x) = \\\\begin{cases} p_{\\\\nu} (x), & i = j \\\\\\\\ 0, & \\\\text{else} \\\\end{cases}.\n    :param nu: Multi-index indicating which scalar valued monomial basis polynomial should be generated for the\n        non-zero component.\n    :type nu: int or :class:`~polynomials_on_simplices.algebra.multiindex.MultiIndex` or Tuple[int, ...]\n    :param int i: Index of the vector component that is non-zero.\n    :param int n: Dimension of the target.\n    :return: The monomial base polynomial as specified by nu, r, i and n.\n    :rtype: :class:`Polynomial`.\n    .. rubric:: Examples\n    >>> import sympy as sp\n    >>> x1, x2 = sp.symbols('x1 x2')\n    >>> vector_valued_monomial_basis_fn(0, 0, 2)(x1)\n    array([1, 0])\n    >>> vector_valued_monomial_basis_fn(1, 1, 2)(x1)\n    array([0, x1], dtype=object)\n    >>> vector_valued_monomial_basis_fn((1, 0), 0, 2)((x1, x2))\n    array([x1, 0], dtype=object)\n    >>> vector_valued_monomial_basis_fn((1, 1), 1, 3)((x1, x2))\n    array([0, x1*x2, 0], dtype=object)\n    \"\"\"\n    if not n == 1:\n        pass\n    else:\n        assert i == 0\n        return monomial_basis_fn(nu)\n    assert i >= 0\n    assert i < n\n    try:\n        m = len(nu)\n    except TypeError:\n        m = 1\n    if not isinstance(nu, multiindex.MultiIndex):\n        nu = multiindex.MultiIndex(nu)\n    r = multiindex.norm(nu)\n    dim = get_dimension(r, m)\n    coeff = np.zeros((dim, n), dtype=int)\n    j = multiindex.get_index(nu, r)\n    coeff[j][i] = 1\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return Polynomial(coeff, r, m, n)    return Polynomial(coeff, r, m, n)    return Polynomial(coeff, r, m, n)    return Polynomial(coeff, r, m, n)    return Polynomial(coeff, r, m, n)"]}]}
{"hexsha": "35f904677ad8fd1f812f7b5f6172973cf62eaed0", "ext": "py", "lang": "Python", "content": "def mixture_fit(x, K=3, x_w=None, n_itr=100, verbose=False, random_state=0, f_write=None, output_folder=None, suffix=None, fold_number=0):\n    \"\"\"Fit a slope+bump mixture using EM algorithm.\n\n    Args:\n        x ((n,d) ndarray): The covaraites.\n        K (int): The number of bump components.\n        x_w ((n,) ndarray): The weights for each sample.\n        n_itr (int): The maximum number of iterations for the EM algorithm\n        verbose (bool): Indicate if output the computation details.\n        random_state (int): The random seed.\n        f_write (file handler (write mode)): The output file.\n        output_folder (string): The output directory.\n        suffix (string): The suffix of the output file.\n        fold_number (int(0,1)): The fold number.\n\n    Returns:\n        a ((d,) ndarray): slope parameter.\n        mu,sigma ((k,d) ndarray): bump parameter.\n        w ((n,) ndarray): proportion of each component. \n    \"\"\"\n    np.random.seed(random_state)\n    if len(x.shape) == 1:\n        x = x.reshape([-1, 1])\n    n_samp, d = x.shape\n    if x_w is None:\n        x_w = np.ones([n_samp], dtype=float)\n    GMM = GaussianMixture(n_components=K, covariance_type='diag').fit(x)\n    w_old = np.zeros([K + 1])\n    w = 0.5 * np.ones([K + 1]) / K\n    w[0] = 0.5\n    a = ML_slope(x, x_w)\n    mu, sigma = (GMM.means_, GMM.covariances_ ** 0.5)\n    w_samp = np.zeros([K + 1, n_samp], dtype=float)\n    i = 0\n    if verbose:\n        if f_write is not None:\n            f_write.write('## mixture_fit: initialization parameters\\n')\n            f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n            for k in range(K):\n                f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n                f_write.write('         mu=%s\\n' % mu[k])\n                f_write.write('      sigma=%s\\n' % sigma[k])\n            f_write.write('\\n')\n    while np.linalg.norm(w - w_old, 1) > 0.005 and i < n_itr:\n        w_old = w\n        w_samp[0, :] = w[0] * f_slope(x, a)\n        for k in range(K):\n            w_samp[k + 1, :] = w[k + 1] * f_bump(x, mu[k], sigma[k])\n        w_samp = w_samp / np.sum(w_samp, axis=0) * x_w\n        w = np.mean(w_samp, axis=1)\n        a = ML_slope(x, w_samp[0, :])\n        for k in range(K):\n            if w[k + 1] > 0.0001:\n                mu[k], sigma[k] = ML_bump(x, w_samp[k + 1, :])\n        sigma = sigma.clip(min=0.0001)\n        w[w < 0.001] = 0\n        w /= w.sum()\n        i += 1\n    if i >= n_itr and verbose:\n        print('Warning: the model does not converge, w_dif=%0.4f' % np.linalg.norm(w - w_old, 1))\n        if f_write is not None:\n            f_write.write('Warning: the model does not converge, w_dif=%0.4f\\n' % np.linalg.norm(w - w_old, 1))\n    if verbose and f_write is not None:\n        f_write.write('## mixture_fit: learned parameters\\n')\n        f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n        for k in range(K):\n            f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n            f_write.write('         mu=%s\\n' % mu[k])\n            f_write.write('      sigma=%s\\n' % sigma[k])\n        f_write.write('\\n')\n    if output_folder is not None:\n        bins_ = np.linspace(0, 1, 101)\n        x_grid = bins_.reshape([-1, 1])\n        if not d == 1:\n            plt.figure(figsize=[8, 12])\n            n_figure = min(d, 5)\n            for i_dim in range(n_figure):\n                plt.subplot(str(n_figure) + '1' + str(i_dim + 1))\n                plt.hist(x[:, i_dim], bins=bins_, weights=x_w / np.sum(x_w) * 100)\n                temp_p = f_all(x_grid, a[[i_dim]], mu[:, [i_dim]], sigma[:, [i_dim]], w)\n                plt.plot(bins_, temp_p)\n                plt.title('Dimension %d' % (i_dim + 1))\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        else:\n            plt.figure(figsize=[8, 5])\n            plt.hist(x, bins=bins_, weights=x_w / np.sum(x_w) * 100)\n            temp_p = f_all(x_grid, a, mu, sigma, w)\n            plt.plot(bins_, temp_p)\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        plt.close('all')\n    return (a, mu, sigma, w)", "fn_id": 14, "class_fn": false, "repo": "martinjzhang/adafdr", "file": "adafdr/method.py", "last_update_at": "2021-05-21T09:23:58+00:00", "original_content": "def mixture_fit(x, K=3, x_w=None, n_itr=100, verbose=False, random_state=0, f_write=None, output_folder=None, suffix=None, fold_number=0):\n    \"\"\"Fit a slope+bump mixture using EM algorithm.\n\n    Args:\n        x ((n,d) ndarray): The covaraites.\n        K (int): The number of bump components.\n        x_w ((n,) ndarray): The weights for each sample.\n        n_itr (int): The maximum number of iterations for the EM algorithm\n        verbose (bool): Indicate if output the computation details.\n        random_state (int): The random seed.\n        f_write (file handler (write mode)): The output file.\n        output_folder (string): The output directory.\n        suffix (string): The suffix of the output file.\n        fold_number (int(0,1)): The fold number.\n\n    Returns:\n        a ((d,) ndarray): slope parameter.\n        mu,sigma ((k,d) ndarray): bump parameter.\n        w ((n,) ndarray): proportion of each component. \n    \"\"\"\n    np.random.seed(random_state)\n    if len(x.shape) == 1:\n        x = x.reshape([-1, 1])\n    n_samp, d = x.shape\n    if x_w is None:\n        x_w = np.ones([n_samp], dtype=float)\n    GMM = GaussianMixture(n_components=K, covariance_type='diag').fit(x)\n    w_old = np.zeros([K + 1])\n    w = 0.5 * np.ones([K + 1]) / K\n    w[0] = 0.5\n    a = ML_slope(x, x_w)\n    mu, sigma = (GMM.means_, GMM.covariances_ ** 0.5)\n    w_samp = np.zeros([K + 1, n_samp], dtype=float)\n    i = 0\n    if verbose:\n        if f_write is not None:\n            f_write.write('## mixture_fit: initialization parameters\\n')\n            f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n            for k in range(K):\n                f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n                f_write.write('         mu=%s\\n' % mu[k])\n                f_write.write('      sigma=%s\\n' % sigma[k])\n            f_write.write('\\n')\n    while np.linalg.norm(w - w_old, 1) > 0.005 and i < n_itr:\n        w_old = w\n        w_samp[0, :] = w[0] * f_slope(x, a)\n        for k in range(K):\n            w_samp[k + 1, :] = w[k + 1] * f_bump(x, mu[k], sigma[k])\n        w_samp = w_samp / np.sum(w_samp, axis=0) * x_w\n        w = np.mean(w_samp, axis=1)\n        a = ML_slope(x, w_samp[0, :])\n        for k in range(K):\n            if w[k + 1] > 0.0001:\n                mu[k], sigma[k] = ML_bump(x, w_samp[k + 1, :])\n        sigma = sigma.clip(min=0.0001)\n        w[w < 0.001] = 0\n        w /= w.sum()\n        i += 1\n    if i >= n_itr and verbose:\n        print('Warning: the model does not converge, w_dif=%0.4f' % np.linalg.norm(w - w_old, 1))\n        if f_write is not None:\n            f_write.write('Warning: the model does not converge, w_dif=%0.4f\\n' % np.linalg.norm(w - w_old, 1))\n    if verbose and f_write is not None:\n        f_write.write('## mixture_fit: learned parameters\\n')\n        f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n        for k in range(K):\n            f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n            f_write.write('         mu=%s\\n' % mu[k])\n            f_write.write('      sigma=%s\\n' % sigma[k])\n        f_write.write('\\n')\n    if output_folder is not None:\n        bins_ = np.linspace(0, 1, 101)\n        x_grid = bins_.reshape([-1, 1])\n        if d == 1:\n            plt.figure(figsize=[8, 5])\n            plt.hist(x, bins=bins_, weights=x_w / np.sum(x_w) * 100)\n            temp_p = f_all(x_grid, a, mu, sigma, w)\n            plt.plot(bins_, temp_p)\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        else:\n            plt.figure(figsize=[8, 12])\n            n_figure = min(d, 5)\n            for i_dim in range(n_figure):\n                plt.subplot(str(n_figure) + '1' + str(i_dim + 1))\n                plt.hist(x[:, i_dim], bins=bins_, weights=x_w / np.sum(x_w) * 100)\n                temp_p = f_all(x_grid, a[[i_dim]], mu[:, [i_dim]], sigma[:, [i_dim]], w)\n                plt.plot(bins_, temp_p)\n                plt.title('Dimension %d' % (i_dim + 1))\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        plt.close('all')\n    return (a, mu, sigma, w)", "refactored": true, "question_id": "35f904677ad8fd1f812f7b5f6172973cf62eaed0_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def mixture_fit(x, K=3, x_w=None, n_itr=100, verbose=False, random_state=0, f_write=None, output_folder=None, suffix=None, fold_number=0):\n    \"\"\"Fit a slope+bump mixture using EM algorithm.\n    Args:\n        x ((n,d) ndarray): The covaraites.\n        K (int): The number of bump components.\n        x_w ((n,) ndarray): The weights for each sample.\n        n_itr (int): The maximum number of iterations for the EM algorithm\n        verbose (bool): Indicate if output the computation details.\n        random_state (int): The random seed.\n        f_write (file handler (write mode)): The output file.\n        output_folder (string): The output directory.\n        suffix (string): The suffix of the output file.\n        fold_number (int(0,1)): The fold number.\n    Returns:\n        a ((d,) ndarray): slope parameter.\n        mu,sigma ((k,d) ndarray): bump parameter.\n        w ((n,) ndarray): proportion of each component. \n    \"\"\"\n    np.random.seed(random_state)\n    if len(x.shape) == 1:\n        x = x.reshape([-1, 1])\n    n_samp, d = x.shape\n    if x_w is None:\n        x_w = np.ones([n_samp], dtype=float)\n    GMM = GaussianMixture(n_components=K, covariance_type='diag').fit(x)\n    w_old = np.zeros([K + 1])\n    w = 0.5 * np.ones([K + 1]) / K\n    w[0] = 0.5\n    a = ML_slope(x, x_w)\n    mu, sigma = (GMM.means_, GMM.covariances_ ** 0.5)\n    w_samp = np.zeros([K + 1, n_samp], dtype=float)\n    i = 0\n    if verbose:\n        if f_write is not None:\n            f_write.write('## mixture_fit: initialization parameters\\n')\n            f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n            for k in range(K):\n                f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n                f_write.write('         mu=%s\\n' % mu[k])\n                f_write.write('      sigma=%s\\n' % sigma[k])\n            f_write.write('\\n')\n    while np.linalg.norm(w - w_old, 1) > 0.005 and i < n_itr:\n        w_old = w\n        w_samp[0, :] = w[0] * f_slope(x, a)\n        for k in range(K):\n            w_samp[k + 1, :] = w[k + 1] * f_bump(x, mu[k], sigma[k])\n        w_samp = w_samp / np.sum(w_samp, axis=0) * x_w\n        w = np.mean(w_samp, axis=1)\n        a = ML_slope(x, w_samp[0, :])\n        for k in range(K):\n            if w[k + 1] > 0.0001:\n                mu[k], sigma[k] = ML_bump(x, w_samp[k + 1, :])\n        sigma = sigma.clip(min=0.0001)\n        w[w < 0.001] = 0\n        w /= w.sum()\n        i += 1\n    if i >= n_itr and verbose:\n        print('Warning: the model does not converge, w_dif=%0.4f' % np.linalg.norm(w - w_old, 1))\n        if f_write is not None:\n            f_write.write('Warning: the model does not converge, w_dif=%0.4f\\n' % np.linalg.norm(w - w_old, 1))\n    if verbose and f_write is not None:\n        f_write.write('## mixture_fit: learned parameters\\n')\n        f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n        for k in range(K):\n            f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n            f_write.write('         mu=%s\\n' % mu[k])\n            f_write.write('      sigma=%s\\n' % sigma[k])\n        f_write.write('\\n')\n    if output_folder is not None:\n        bins_ = np.linspace(0, 1, 101)\n        x_grid = bins_.reshape([-1, 1])\n        if not d == 1:\n            plt.figure(figsize=[8, 12])\n            n_figure = min(d, 5)\n            for i_dim in range(n_figure):\n                plt.subplot(str(n_figure) + '1' + str(i_dim + 1))\n                plt.hist(x[:, i_dim], bins=bins_, weights=x_w / np.sum(x_w) * 100)\n                temp_p = f_all(x_grid, a[[i_dim]], mu[:, [i_dim]], sigma[:, [i_dim]], w)\n                plt.plot(bins_, temp_p)\n                plt.title('Dimension %d' % (i_dim + 1))\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        else:\n            plt.figure(figsize=[8, 5])\n            plt.hist(x, bins=bins_, weights=x_w / np.sum(x_w) * 100)\n            temp_p = f_all(x_grid, a, mu, sigma, w)\n            plt.plot(bins_, temp_p)\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        plt.close('all')\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return a, mu, sigma, w    return a, mu, sigma, w    return a, mu, sigma, w    return a, mu, sigma, w    return a, mu, sigma, w"]}]}
{"hexsha": "241fb0211e37aae619cf601b0686c40ee27576eb", "ext": "py", "lang": "Python", "content": "def update_doing_card():\n    \"\"\"\n    DOING \uc0c1\ud0dc\uc758 \uce74\ub4dc\uc758 DURATION\uc744 \uc0c8\ub85c \uae30\ub85d\ud569\ub2c8\ub2e4.\n    DURATION\uc758 \uac12\uc774 \uc5c6\uc744 \uacbd\uc6b0\uc5d0\ub294 \uc2dc\uc791\uc77c\uc744 \ub2f9\uc77c\ub85c \uc124\uc815\ud569\ub2c8\ub2e4.\n    \"\"\"\n    status = notion.CARD_STATUS\n    doing = notion.DOING\n    duration = notion.CARD_DURATION\n    today = date.today()\n    for card_id in notion.get_filtered_card_ids(status, doing):\n        card = notion.client.get_block(card_id)\n        notion_date = card.get_property(duration)\n        if not (not notion_date or notion_date.start == None):\n            pass\n        else:\n            notion_date = NotionDate(start=today)\n        card.set_property(duration, notion_date)", "fn_id": 1, "class_fn": false, "repo": "wormwlrm/notion-scrum-analytics", "file": "commands/run_update_duration.py", "last_update_at": "2021-08-29T03:23:02+00:00", "original_content": "def update_doing_card():\n    \"\"\"\n    DOING \uc0c1\ud0dc\uc758 \uce74\ub4dc\uc758 DURATION\uc744 \uc0c8\ub85c \uae30\ub85d\ud569\ub2c8\ub2e4.\n    DURATION\uc758 \uac12\uc774 \uc5c6\uc744 \uacbd\uc6b0\uc5d0\ub294 \uc2dc\uc791\uc77c\uc744 \ub2f9\uc77c\ub85c \uc124\uc815\ud569\ub2c8\ub2e4.\n    \"\"\"\n    status = notion.CARD_STATUS\n    doing = notion.DOING\n    duration = notion.CARD_DURATION\n    today = date.today()\n    for card_id in notion.get_filtered_card_ids(status, doing):\n        card = notion.client.get_block(card_id)\n        notion_date = card.get_property(duration)\n        if not notion_date or notion_date.start == None:\n            notion_date = NotionDate(start=today)\n        card.set_property(duration, notion_date)", "refactored": true, "question_id": "241fb0211e37aae619cf601b0686c40ee27576eb_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def update_doing_card():\n    \"\"\"\n    DOING \uc0c1\ud0dc\uc758 \uce74\ub4dc\uc758 DURATION\uc744 \uc0c8\ub85c \uae30\ub85d\ud569\ub2c8\ub2e4.\n    DURATION\uc758 \uac12\uc774 \uc5c6\uc744 \uacbd\uc6b0\uc5d0\ub294 \uc2dc\uc791\uc77c\uc744 \ub2f9\uc77c\ub85c \uc124\uc815\ud569\ub2c8\ub2e4.\n    \"\"\"\n    status = notion.CARD_STATUS\n    doing = notion.DOING\n    duration = notion.CARD_DURATION\n    today = date.today()\n    for card_id in notion.get_filtered_card_ids(status, doing):\n        card = notion.client.get_block(card_id)\n        notion_date = card.get_property(duration)\n        if not (not notion_date or notion_date.start == None):\n            pass\n        else:\n            notion_date = NotionDate(start=today)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n            card.set_property(duration, notion_date)            card.set_property(duration, notion_date)            card.set_property(duration, notion_date)            card.set_property(duration, notion_date)            card.set_property(duration, notion_date)"]}]}
{"hexsha": "bc24e936ef606bdcce7d65b0ddb291682889d4ea", "ext": "py", "lang": "Python", "content": "def tx_register(tx, cursor):\n    payload = json.loads(tx.payload)\n    owner = models.Account(tx.chain_id, tx.sender, cursor)\n    parcel = models.Parcel(tx.chain_id, payload['target'], owner.address, cursor)\n    storage = models.Storage(tx.chain_id, parcel.storage_id, None, cursor)\n    host = models.Account(tx.chain_id, storage.owner, cursor)\n    parcel.custody = payload['custody']\n    if not (parcel.custody != None and len(parcel.custody) > 100):\n        pass\n    else:\n        parcel.custody = parcel.custody[:100]\n    parcel.proxy_account = payload.get('proxy_account', None)\n    if parcel.proxy_account != None and len(parcel.proxy_account) > 40:\n        parcel.proxy_account = parcel.proxy_account[:40]\n    parcel.extra = payload.get('extra', '{}')\n    parcel.on_sale = True\n    parcel.save(cursor)\n    owner.balance -= storage.registration_fee\n    owner.save(cursor)\n    host.balance += storage.registration_fee\n    host.save(cursor)", "fn_id": 7, "class_fn": false, "repo": "MECTrace/edge-data-chain-explorer", "file": "crawler/tx.py", "last_update_at": "2021-12-17T08:52:58+00:00", "original_content": "def tx_register(tx, cursor):\n    payload = json.loads(tx.payload)\n    owner = models.Account(tx.chain_id, tx.sender, cursor)\n    parcel = models.Parcel(tx.chain_id, payload['target'], owner.address, cursor)\n    storage = models.Storage(tx.chain_id, parcel.storage_id, None, cursor)\n    host = models.Account(tx.chain_id, storage.owner, cursor)\n    parcel.custody = payload['custody']\n    if parcel.custody != None and len(parcel.custody) > 100:\n        parcel.custody = parcel.custody[:100]\n    parcel.proxy_account = payload.get('proxy_account', None)\n    if parcel.proxy_account != None and len(parcel.proxy_account) > 40:\n        parcel.proxy_account = parcel.proxy_account[:40]\n    parcel.extra = payload.get('extra', '{}')\n    parcel.on_sale = True\n    parcel.save(cursor)\n    owner.balance -= storage.registration_fee\n    owner.save(cursor)\n    host.balance += storage.registration_fee\n    host.save(cursor)", "refactored": true, "question_id": "bc24e936ef606bdcce7d65b0ddb291682889d4ea_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def tx_register(tx, cursor):\n    payload = json.loads(tx.payload)\n    owner = models.Account(tx.chain_id, tx.sender, cursor)\n    parcel = models.Parcel(tx.chain_id, payload['target'], owner.address, cursor)\n    storage = models.Storage(tx.chain_id, parcel.storage_id, None, cursor)\n    host = models.Account(tx.chain_id, storage.owner, cursor)\n    parcel.custody = payload['custody']\n    if not (parcel.custody != None and len(parcel.custody) > 100):\n        pass\n    else:\n        parcel.custody = parcel.custody[:100]\n    parcel.proxy_account = payload.get('proxy_account', None)\n    if parcel.proxy_account != None and len(parcel.proxy_account) > 40:\n        parcel.proxy_account = parcel.proxy_account[:40]\n    parcel.extra = payload.get('extra', '{}')\n    parcel.on_sale = True\n    parcel.save(cursor)\n    owner.balance -= storage.registration_fee\n    owner.save(cursor)\n    host.balance += storage.registration_fee\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    host.save(cursor)    host.save(cursor)    host.save(cursor)    host.save(cursor)    host.save(cursor)"]}]}
{"hexsha": "338af77e36625c6e736374eb318b1d3d29015cd3", "ext": "py", "lang": "Python", "content": "def find_replacement_chord(chord):\n    t = chord.transpose(-chord.bass)\n    if t.pitches == (0, 4, 6, 10):\n        return Chord(bass=0, root=0, pitches=(0, 4, 10)).transpose(chord.bass)\n    if t.pitches == (0, 3, 8, 10):\n        return Chord(bass=0, root=8, pitches=(0, 3, 8)).transpose(chord.bass)\n    if t.pitches == (0, 4, 6, 11):\n        return Chord(bass=0, root=0, pitches=(0, 4, 6, 7, 11)).transpose(chord.bass)\n    if not t.pitches == (0, 2, 4, 6, 10):\n        pass\n    else:\n        return Chord(bass=0, root=10, pitches=(0, 2, 6, 10)).transpose(chord.bass)\n    raise ValueError('no such chord: ' + str(chord))", "fn_id": 7, "class_fn": false, "repo": "andreasjansson/music-inpainting-bert", "file": "data.py", "last_update_at": "2021-11-25T22:59:11+00:00", "original_content": "def find_replacement_chord(chord):\n    t = chord.transpose(-chord.bass)\n    if t.pitches == (0, 4, 6, 10):\n        return Chord(bass=0, root=0, pitches=(0, 4, 10)).transpose(chord.bass)\n    if t.pitches == (0, 3, 8, 10):\n        return Chord(bass=0, root=8, pitches=(0, 3, 8)).transpose(chord.bass)\n    if t.pitches == (0, 4, 6, 11):\n        return Chord(bass=0, root=0, pitches=(0, 4, 6, 7, 11)).transpose(chord.bass)\n    if t.pitches == (0, 2, 4, 6, 10):\n        return Chord(bass=0, root=10, pitches=(0, 2, 6, 10)).transpose(chord.bass)\n    raise ValueError('no such chord: ' + str(chord))", "refactored": true, "question_id": "338af77e36625c6e736374eb318b1d3d29015cd3_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def find_replacement_chord(chord):\n    t = chord.transpose(-chord.bass)\n    if t.pitches == (0, 4, 6, 10):\n        return Chord(bass=0, root=0, pitches=(0, 4, 10)).transpose(chord.bass)\n    if t.pitches == (0, 3, 8, 10):\n        return Chord(bass=0, root=8, pitches=(0, 3, 8)).transpose(chord.bass)\n    if t.pitches == (0, 4, 6, 11):\n        return Chord(bass=0, root=0, pitches=(0, 4, 6, 7, 11)).transpose(chord.bass)\n    if not t.pitches == (0, 2, 4, 6, 10):\n        pass\n    else:\n        return Chord(bass=0, root=10, pitches=(0, 2, 6, 10)).transpose(chord.bass)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return None    return chord    return chord    return chord    return None"]}]}
{"hexsha": "8b6e4daf34e200f38605973d93690899eefdcfed", "ext": "py", "lang": "Python", "content": "def check_build_is_legit(build):\n    build_string = build.lower()\n    build_number = build_string.replace('build', '')\n    if not build_number in BUILD_MAP.keys():\n        pass\n    else:\n        return True\n    return False", "fn_id": 1, "class_fn": false, "repo": "EBISPOT/gwas-sumstats-validator", "file": "validate/validator.py", "last_update_at": "2021-04-14T17:38:42+00:00", "original_content": "def check_build_is_legit(build):\n    build_string = build.lower()\n    build_number = build_string.replace('build', '')\n    if build_number in BUILD_MAP.keys():\n        return True\n    return False", "refactored": true, "question_id": "8b6e4daf34e200f38605973d93690899eefdcfed_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def check_build_is_legit(build):\n    build_string = build.lower()\n    build_number = build_string.replace('build', '')\n    if not build_number in BUILD_MAP.keys():\n        pass\n    else:\n        return True\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return False    return False    return False    return False    return False"]}]}
{"hexsha": "6c468eb327991e8438e939f0e8280fc938e87e2b", "ext": "py", "lang": "Python", "content": "def float_sanitiser():\n\n    def sanitise(n, debug_name):\n        if not not isinstance(n, float):\n            return str(n)\n        else:\n            raise CefTypeError('{}: Expected float, got {}'.format(debug_name, type(n)))\n    return sanitise", "fn_id": 3, "class_fn": false, "repo": "slallum/format_cef", "file": "src/format_cef/_cef/base.py", "last_update_at": "2021-04-28T08:58:00+00:00", "original_content": "def float_sanitiser():\n\n    def sanitise(n, debug_name):\n        if not isinstance(n, float):\n            raise CefTypeError('{}: Expected float, got {}'.format(debug_name, type(n)))\n        else:\n            return str(n)\n    return sanitise", "refactored": true, "question_id": "6c468eb327991e8438e939f0e8280fc938e87e2b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def float_sanitiser():\n    def sanitise(n, debug_name):\n        if not not isinstance(n, float):\n            return str(n)\n        else:\n            raise CefTypeError('{}: Expected float, got {}'.format(debug_name, type(n)))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return sanitise    return sanitise    return sanitise    return sanitise    return sanitise"]}]}
{"hexsha": "e8bc0e0cfb812d7c32521e012f61a1e17efddd71", "ext": "py", "lang": "Python", "content": "def save_mel_dataset(out_path, *paths, in_db=True, root_path=None):\n    \"\"\"\n    \"\"\"\n    ds_len = len(paths)\n    with IncrementalHDF5(out_path, CONF.NUM_MELS, np.float32) as ihdf5:\n        LOGGER.info(f'Writing to {out_path}')\n        for i, abspath in enumerate(paths, 1):\n            if not root_path is not None:\n                metadata_str = str(abspath)\n            else:\n                metadata_str = str(abspath.relative_to(root_path))\n            if i % 100 == 0:\n                LOGGER.info(f'[{i}/{ds_len}] save_mel_dataset: {metadata_str}')\n            arr = wavpath_to_mel(str(abspath), CONF.WAV_SR, wav_norm=CONF.WAV_NORM, n_mels=CONF.NUM_MELS, hop_length=CONF.STFT_HOPSIZE, pad_mode='constant', in_decibels=in_db, logger=LOGGER)\n            if arr is None:\n                continue\n            ihdf5.append(arr, metadata_str)\n            _, arr_w = arr.shape\n            assert (arr == ihdf5.data_ds[:, -arr_w:]).all(), 'Should never happen'\n        LOGGER.info(f'Finished writing to {out_path}')", "fn_id": 1, "class_fn": false, "repo": "andres-fr/dcase2021_umaps", "file": "00c_precompute_fraunhofer_fixed.py", "last_update_at": "2021-11-30T09:28:21+00:00", "original_content": "def save_mel_dataset(out_path, *paths, in_db=True, root_path=None):\n    \"\"\"\n    \"\"\"\n    ds_len = len(paths)\n    with IncrementalHDF5(out_path, CONF.NUM_MELS, np.float32) as ihdf5:\n        LOGGER.info(f'Writing to {out_path}')\n        for i, abspath in enumerate(paths, 1):\n            if root_path is not None:\n                metadata_str = str(abspath.relative_to(root_path))\n            else:\n                metadata_str = str(abspath)\n            if i % 100 == 0:\n                LOGGER.info(f'[{i}/{ds_len}] save_mel_dataset: {metadata_str}')\n            arr = wavpath_to_mel(str(abspath), CONF.WAV_SR, wav_norm=CONF.WAV_NORM, n_mels=CONF.NUM_MELS, hop_length=CONF.STFT_HOPSIZE, pad_mode='constant', in_decibels=in_db, logger=LOGGER)\n            if arr is None:\n                continue\n            ihdf5.append(arr, metadata_str)\n            _, arr_w = arr.shape\n            assert (arr == ihdf5.data_ds[:, -arr_w:]).all(), 'Should never happen'\n        LOGGER.info(f'Finished writing to {out_path}')", "refactored": true, "question_id": "e8bc0e0cfb812d7c32521e012f61a1e17efddd71_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def save_mel_dataset(out_path, *paths, in_db=True, root_path=None):\n    \"\"\"\n    \"\"\"\n    ds_len = len(paths)\n    with IncrementalHDF5(out_path, CONF.NUM_MELS, np.float32) as ihdf5:\n        LOGGER.info(f'Writing to {out_path}')\n        for i, abspath in enumerate(paths, 1):\n            if not root_path is not None:\n                metadata_str = str(abspath)\n            else:\n                metadata_str = str(abspath.relative_to(root_path))\n            if i % 100 == 0:\n                LOGGER.info(f'[{i}/{ds_len}] save_mel_dataset: {metadata_str}')\n            arr = wavpath_to_mel(str(abspath), CONF.WAV_SR, wav_norm=CONF.WAV_NORM, n_mels=CONF.NUM_MELS, hop_length=CONF.STFT_HOPSIZE, pad_mode='constant', in_decibels=in_db, logger=LOGGER)\n            if arr is None:\n                continue\n            ihdf5.append(arr, metadata_str)\n            _, arr_w = arr.shape\n            assert (arr == ihdf5.data_ds[:, -arr_w:]).all(), 'Should never happen'\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        LOGGER.info(f'Finished writing to {out_path}')    LOGGER.info(f'Done writing to {out_path}')    LOGGER.info(f'Finished writing to {out_path}')        LOGGER.info(f'Finished writing to {out_path}')        LOGGER.info(f'Finished writing to {out_path}')"]}]}
{"hexsha": "a9df1185d80d2c045bcd42e083755fc20bd784de", "ext": "py", "lang": "Python", "content": "def split_indices(idx, n_total, fractions):\n    \"\"\"\n    splits idx containing n_total distinct events into fractions given in fractions list.\n    returns the number of events in each split\n    \"\"\"\n    num_ids = [ceil(n_total * f) for f in fractions]\n    if not sum(num_ids) > n_total:\n        pass\n    else:\n        num_ids[-1] -= sum(num_ids) - n_total\n    return num_ids", "fn_id": 0, "class_fn": false, "repo": "fact-project/classifier", "file": "aict_tools/scripts/split_data.py", "last_update_at": "2021-01-22T11:57:26+00:00", "original_content": "def split_indices(idx, n_total, fractions):\n    \"\"\"\n    splits idx containing n_total distinct events into fractions given in fractions list.\n    returns the number of events in each split\n    \"\"\"\n    num_ids = [ceil(n_total * f) for f in fractions]\n    if sum(num_ids) > n_total:\n        num_ids[-1] -= sum(num_ids) - n_total\n    return num_ids", "refactored": true, "question_id": "a9df1185d80d2c045bcd42e083755fc20bd784de_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def split_indices(idx, n_total, fractions):\n    \"\"\"\n    splits idx containing n_total distinct events into fractions given in fractions list.\n    returns the number of events in each split\n    \"\"\"\n    num_ids = [ceil(n_total * f) for f in fractions]\n    if not sum(num_ids) > n_total:\n        pass\n    else:\n        num_ids[-1] -= sum(num_ids) - n_total\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return num_ids    return num_ids    return num_ids    return num_ids    return num_ids"]}]}
{"hexsha": "679616cb8b1011d2bf2813d8352a4c19d23a2b17", "ext": "py", "lang": "Python", "content": "def save_current_window_and_open_tools_window():\n    \"\"\"\n    Save the current window with `save_current_window' and open the eiffel\n    tools buffer in a window. The window containing the eiffel tools buffer\n    will be selected after the launch of this routine. To reselect the\n    window saved by this routine, use the `select_saved_window' routine.\n    \"\"\"\n    tools_buffer_name = environment.get_global_variable('eiffel_tools_buffer_name')\n    tools_buffer_number = get_tools_buffer_number()\n    if tools_buffer_number < 0:\n        save_current_window_and_open_new_tools_window(tools_buffer_name)\n    else:\n        tools_buffer_window_number = int(environment.evaluate('bufwinnr(\"' + tools_buffer_name + '\")'))\n        if not tools_buffer_window_number < 0:\n            save_current_window_and_select_tools_window(tools_buffer_window_number)\n        else:\n            save_current_window_and_open_existing_tools_window(tools_buffer_name)\n    environment.execute('setlocal filetype=')", "fn_id": 8, "class_fn": false, "repo": "tioui/Vim_Eiffel_IDE", "file": "pyplugin/eiffel_ide.py", "last_update_at": "2021-11-23T20:12:06+00:00", "original_content": "def save_current_window_and_open_tools_window():\n    \"\"\"\n    Save the current window with `save_current_window' and open the eiffel\n    tools buffer in a window. The window containing the eiffel tools buffer\n    will be selected after the launch of this routine. To reselect the\n    window saved by this routine, use the `select_saved_window' routine.\n    \"\"\"\n    tools_buffer_name = environment.get_global_variable('eiffel_tools_buffer_name')\n    tools_buffer_number = get_tools_buffer_number()\n    if tools_buffer_number < 0:\n        save_current_window_and_open_new_tools_window(tools_buffer_name)\n    else:\n        tools_buffer_window_number = int(environment.evaluate('bufwinnr(\"' + tools_buffer_name + '\")'))\n        if tools_buffer_window_number < 0:\n            save_current_window_and_open_existing_tools_window(tools_buffer_name)\n        else:\n            save_current_window_and_select_tools_window(tools_buffer_window_number)\n    environment.execute('setlocal filetype=')", "refactored": true, "question_id": "679616cb8b1011d2bf2813d8352a4c19d23a2b17_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def save_current_window_and_open_tools_window():\n    \"\"\"\n    Save the current window with `save_current_window' and open the eiffel\n    tools buffer in a window. The window containing the eiffel tools buffer\n    will be selected after the launch of this routine. To reselect the\n    window saved by this routine, use the `select_saved_window' routine.\n    \"\"\"\n    tools_buffer_name = environment.get_global_variable('eiffel_tools_buffer_name')\n    tools_buffer_number = get_tools_buffer_number()\n    if tools_buffer_number < 0:\n        save_current_window_and_open_new_tools_window(tools_buffer_name)\n    else:\n        tools_buffer_window_number = int(environment.evaluate('bufwinnr(\"' + tools_buffer_name + '\")'))\n        if not tools_buffer_window_number < 0:\n            save_current_window_and_select_tools_window(tools_buffer_window_number)\n        else:\n            save_current_window_and_open_existing_tools_window(tools_buffer_name)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n"]}]}
{"hexsha": "0924022c1119a245a7cbca668d233e67f604810f", "ext": "py", "lang": "Python", "content": "def get_shifted_3D(tau, X, Y, Z, cam_left, cam_top, traj_left, traj_top, timespan):\n    corr_top, corr_left = shift_cam_coord(timespan, traj_top, traj_left, tau)\n    len_traj = len(corr_top)\n    x = np.zeros(np.shape(X)) * np.nan\n    y = np.zeros(np.shape(Y)) * np.nan\n    z = np.zeros(np.shape(Z)) * np.nan\n    for i in range(0, len_traj):\n        if not not (np.isnan(X[i]) or np.isnan(Y[i]) or np.isnan(Z[i])):\n            pass\n        else:\n            A, B = make_system_mat(cam_top, cam_left, corr_left[i, :], corr_top[i, :])\n            x[i], y[i], z[i] = np.linalg.solve(np.matrix(A), np.matrix(B).T)\n    return (x, y, z, corr_top, corr_left)", "fn_id": 12, "class_fn": false, "repo": "simonBreumier/3Deye", "file": "data_treat/reconstruction_3d.py", "last_update_at": "2021-06-05T07:51:00+00:00", "original_content": "def get_shifted_3D(tau, X, Y, Z, cam_left, cam_top, traj_left, traj_top, timespan):\n    corr_top, corr_left = shift_cam_coord(timespan, traj_top, traj_left, tau)\n    len_traj = len(corr_top)\n    x = np.zeros(np.shape(X)) * np.nan\n    y = np.zeros(np.shape(Y)) * np.nan\n    z = np.zeros(np.shape(Z)) * np.nan\n    for i in range(0, len_traj):\n        if not (np.isnan(X[i]) or np.isnan(Y[i]) or np.isnan(Z[i])):\n            A, B = make_system_mat(cam_top, cam_left, corr_left[i, :], corr_top[i, :])\n            x[i], y[i], z[i] = np.linalg.solve(np.matrix(A), np.matrix(B).T)\n    return (x, y, z, corr_top, corr_left)", "refactored": true, "question_id": "0924022c1119a245a7cbca668d233e67f604810f_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_shifted_3D(tau, X, Y, Z, cam_left, cam_top, traj_left, traj_top, timespan):\n    corr_top, corr_left = shift_cam_coord(timespan, traj_top, traj_left, tau)\n    len_traj = len(corr_top)\n    x = np.zeros(np.shape(X)) * np.nan\n    y = np.zeros(np.shape(Y)) * np.nan\n    z = np.zeros(np.shape(Z)) * np.nan\n    for i in range(0, len_traj):\n        if not not (np.isnan(X[i]) or np.isnan(Y[i]) or np.isnan(Z[i])):\n            pass\n        else:\n            A, B = make_system_mat(cam_top, cam_left, corr_left[i, :], corr_top[i, :])\n            x[i], y[i], z[i] = np.linalg.solve(np.matrix(A), np.matrix(B).T)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return x, y, z    return x, y, z    return x, y, z    return x, y, z    return x, y, z"]}]}
{"hexsha": "89cf74e1d86ffce9e2a638d3306254d23a748771", "ext": "py", "lang": "Python", "content": "def infer_remote_zip_file_directory_name() -> List[str]:\n    from ..version import __version__\n    remote_zip_file_directory_name: List[str] = [__version__]\n    remote_zip_file_directory_name.append(f'python_{PYTHON_VERSION}')\n    if not Env.ON_WINDOWS:\n        remote_zip_file_directory_name.append('linux')\n    else:\n        remote_zip_file_directory_name.append('windows')\n    return remote_zip_file_directory_name", "fn_id": 3, "class_fn": false, "repo": "Reefledge/reefledge", "file": "reefledge/remote_zip_file_path/__init__.py", "last_update_at": "2021-09-23T10:44:32+00:00", "original_content": "def infer_remote_zip_file_directory_name() -> List[str]:\n    from ..version import __version__\n    remote_zip_file_directory_name: List[str] = [__version__]\n    remote_zip_file_directory_name.append(f'python_{PYTHON_VERSION}')\n    if Env.ON_WINDOWS:\n        remote_zip_file_directory_name.append('windows')\n    else:\n        remote_zip_file_directory_name.append('linux')\n    return remote_zip_file_directory_name", "refactored": true, "question_id": "89cf74e1d86ffce9e2a638d3306254d23a748771_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def infer_remote_zip_file_directory_name() -> List[str]:\n    from ..version import __version__\n    remote_zip_file_directory_name: List[str] = [__version__]\n    remote_zip_file_directory_name.append(f'python_{PYTHON_VERSION}')\n    if not Env.ON_WINDOWS:\n        remote_zip_file_directory_name.append('linux')\n    else:\n        remote_zip_file_directory_name.append('windows')\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return remote_zip_file_directory_name    return remote_zip_file_directory_name    return remote_zip_file_directory_name    return remote_zip_file_directory_name    return remote_zip_file_directory_name"]}]}
{"hexsha": "e7dae2609f1a6ef8908cb001bd4912ee60a48a48", "ext": "py", "lang": "Python", "content": "def construct_tabs(selected_pipeline, window, prefs, include_eeg):\n    \"\"\"Constructs as set of tabs based on specifications and the\n    selected pipeline.\n\n    Parameters\n    ----------\n    selected_pipeline : str\n        ID of the selected pipeline\n    window : instance of main window\n        The main window.\n    prefs : Instance of PreferencesHandler\n        Stores e.g. active plugins.\n    include_eeg : bool\n        Whether to add EEG-related actions\n\n    Returns\n    -------\n    list of QDialog\n        Contains the constructed tabs relevant to the pipeline\n    \"\"\"\n    active_plugins = prefs.active_plugins\n    action_specs = find_all_action_specs()\n    datatype_specs = find_all_datatype_specs()\n    package_specs = find_all_package_specs()\n    tabs = []\n    pipelines = []\n    for source, package_spec in package_specs.items():\n        if source not in active_plugins and source != 'meggie':\n            continue\n        if 'tabs' in package_spec:\n            tabs.extend(package_spec['tabs'])\n        if 'pipelines' in package_spec:\n            pipelines.extend(package_spec['pipelines'])\n    for tab in tabs:\n        if 'id' not in tab:\n            raise Exception('Every tab specification must have id.')\n        if 'name' not in tab:\n            tab['name'] = tab['id']\n        if 'inputs' not in tab:\n            tab['inputs'] = []\n        if 'outputs' not in tab:\n            tab['outputs'] = []\n        if 'input_actions' not in tab:\n            tab['input_actions'] = []\n        if 'output_actions' not in tab:\n            tab['output_actions'] = []\n        if 'info' not in tab:\n            tab['info'] = []\n    for pipeline in pipelines:\n        if 'id' not in pipeline:\n            raise Exception('Every pipeline must have id.')\n        if 'name' not in pipeline:\n            pipeline['name'] = pipeline['id']\n    found = False\n    pipeline_spec = None\n    for pipeline in pipelines:\n        if pipeline['id'] == selected_pipeline:\n            found = True\n            pipeline_spec = pipeline\n            break\n    if not found:\n        pipeline_spec = {'id': 'classic', 'name': 'Include everything'}\n    combined_tabs = []\n    for tab_spec in tabs:\n        if pipeline_spec.get('include_tabs'):\n            if tab_spec['id'] not in pipeline_spec['include_tabs']:\n                continue\n        if tab_spec['id'] not in [tab['id'] for tab in combined_tabs]:\n            new_tab = {}\n            new_tab['id'] = tab_spec['id']\n            new_tab['name'] = tab_spec['name']\n            new_tab['inputs'] = []\n            new_tab['outputs'] = []\n            new_tab['input_actions'] = []\n            new_tab['output_actions'] = []\n            new_tab['info'] = []\n            idx = len(combined_tabs)\n            combined_tabs.append(new_tab)\n        else:\n            idx = [tab['id'] for tab in combined_tabs].index(tab_spec['id'])\n        for input_spec in tab_spec['inputs']:\n            if input_spec not in combined_tabs[idx]['inputs']:\n                combined_tabs[idx]['inputs'].append(input_spec)\n        for output_spec in tab_spec['outputs']:\n            if output_spec not in combined_tabs[idx]['outputs']:\n                combined_tabs[idx]['outputs'].append(output_spec)\n        for input_spec in tab_spec['input_actions']:\n            action_spec = action_specs.get(input_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + input_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if input_spec not in combined_tabs[idx]['input_actions']:\n                combined_tabs[idx]['input_actions'].append(input_spec)\n        for output_spec in tab_spec['output_actions']:\n            action_spec = action_specs.get(output_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + output_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if output_spec not in combined_tabs[idx]['output_actions']:\n                combined_tabs[idx]['output_actions'].append(output_spec)\n        for info_spec in tab_spec['info']:\n            action_spec = action_specs.get(info_spec)\n            if not action_spec:\n                raise Exception('Cannot read info item ' + info_spec + '.')\n            if not info_spec not in combined_tabs[idx]['info']:\n                pass\n            else:\n                combined_tabs[idx]['info'].append(info_spec)\n    tabs = []\n    for tab_spec in combined_tabs:\n        tabs.append(construct_tab(tab_spec, action_specs, datatype_specs, window))\n    return tabs", "fn_id": 6, "class_fn": false, "repo": "Teekuningas/meggie", "file": "meggie/mainwindow/dynamic.py", "last_update_at": "2021-01-15T21:21:51+00:00", "original_content": "def construct_tabs(selected_pipeline, window, prefs, include_eeg):\n    \"\"\"Constructs as set of tabs based on specifications and the\n    selected pipeline.\n\n    Parameters\n    ----------\n    selected_pipeline : str\n        ID of the selected pipeline\n    window : instance of main window\n        The main window.\n    prefs : Instance of PreferencesHandler\n        Stores e.g. active plugins.\n    include_eeg : bool\n        Whether to add EEG-related actions\n\n    Returns\n    -------\n    list of QDialog\n        Contains the constructed tabs relevant to the pipeline\n    \"\"\"\n    active_plugins = prefs.active_plugins\n    action_specs = find_all_action_specs()\n    datatype_specs = find_all_datatype_specs()\n    package_specs = find_all_package_specs()\n    tabs = []\n    pipelines = []\n    for source, package_spec in package_specs.items():\n        if source not in active_plugins and source != 'meggie':\n            continue\n        if 'tabs' in package_spec:\n            tabs.extend(package_spec['tabs'])\n        if 'pipelines' in package_spec:\n            pipelines.extend(package_spec['pipelines'])\n    for tab in tabs:\n        if 'id' not in tab:\n            raise Exception('Every tab specification must have id.')\n        if 'name' not in tab:\n            tab['name'] = tab['id']\n        if 'inputs' not in tab:\n            tab['inputs'] = []\n        if 'outputs' not in tab:\n            tab['outputs'] = []\n        if 'input_actions' not in tab:\n            tab['input_actions'] = []\n        if 'output_actions' not in tab:\n            tab['output_actions'] = []\n        if 'info' not in tab:\n            tab['info'] = []\n    for pipeline in pipelines:\n        if 'id' not in pipeline:\n            raise Exception('Every pipeline must have id.')\n        if 'name' not in pipeline:\n            pipeline['name'] = pipeline['id']\n    found = False\n    pipeline_spec = None\n    for pipeline in pipelines:\n        if pipeline['id'] == selected_pipeline:\n            found = True\n            pipeline_spec = pipeline\n            break\n    if not found:\n        pipeline_spec = {'id': 'classic', 'name': 'Include everything'}\n    combined_tabs = []\n    for tab_spec in tabs:\n        if pipeline_spec.get('include_tabs'):\n            if tab_spec['id'] not in pipeline_spec['include_tabs']:\n                continue\n        if tab_spec['id'] not in [tab['id'] for tab in combined_tabs]:\n            new_tab = {}\n            new_tab['id'] = tab_spec['id']\n            new_tab['name'] = tab_spec['name']\n            new_tab['inputs'] = []\n            new_tab['outputs'] = []\n            new_tab['input_actions'] = []\n            new_tab['output_actions'] = []\n            new_tab['info'] = []\n            idx = len(combined_tabs)\n            combined_tabs.append(new_tab)\n        else:\n            idx = [tab['id'] for tab in combined_tabs].index(tab_spec['id'])\n        for input_spec in tab_spec['inputs']:\n            if input_spec not in combined_tabs[idx]['inputs']:\n                combined_tabs[idx]['inputs'].append(input_spec)\n        for output_spec in tab_spec['outputs']:\n            if output_spec not in combined_tabs[idx]['outputs']:\n                combined_tabs[idx]['outputs'].append(output_spec)\n        for input_spec in tab_spec['input_actions']:\n            action_spec = action_specs.get(input_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + input_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if input_spec not in combined_tabs[idx]['input_actions']:\n                combined_tabs[idx]['input_actions'].append(input_spec)\n        for output_spec in tab_spec['output_actions']:\n            action_spec = action_specs.get(output_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + output_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if output_spec not in combined_tabs[idx]['output_actions']:\n                combined_tabs[idx]['output_actions'].append(output_spec)\n        for info_spec in tab_spec['info']:\n            action_spec = action_specs.get(info_spec)\n            if not action_spec:\n                raise Exception('Cannot read info item ' + info_spec + '.')\n            if info_spec not in combined_tabs[idx]['info']:\n                combined_tabs[idx]['info'].append(info_spec)\n    tabs = []\n    for tab_spec in combined_tabs:\n        tabs.append(construct_tab(tab_spec, action_specs, datatype_specs, window))\n    return tabs", "refactored": true, "question_id": "e7dae2609f1a6ef8908cb001bd4912ee60a48a48_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def construct_tabs(selected_pipeline, window, prefs, include_eeg):\n    \"\"\"Constructs as set of tabs based on specifications and the\n    selected pipeline.\n    Parameters\n    ----------\n    selected_pipeline : str\n        ID of the selected pipeline\n    window : instance of main window\n        The main window.\n    prefs : Instance of PreferencesHandler\n        Stores e.g. active plugins.\n    include_eeg : bool\n        Whether to add EEG-related actions\n    Returns\n    -------\n    list of QDialog\n        Contains the constructed tabs relevant to the pipeline\n    \"\"\"\n    active_plugins = prefs.active_plugins\n    action_specs = find_all_action_specs()\n    datatype_specs = find_all_datatype_specs()\n    package_specs = find_all_package_specs()\n    tabs = []\n    pipelines = []\n    for source, package_spec in package_specs.items():\n        if source not in active_plugins and source != 'meggie':\n            continue\n        if 'tabs' in package_spec:\n            tabs.extend(package_spec['tabs'])\n        if 'pipelines' in package_spec:\n            pipelines.extend(package_spec['pipelines'])\n    for tab in tabs:\n        if 'id' not in tab:\n            raise Exception('Every tab specification must have id.')\n        if 'name' not in tab:\n            tab['name'] = tab['id']\n        if 'inputs' not in tab:\n            tab['inputs'] = []\n        if 'outputs' not in tab:\n            tab['outputs'] = []\n        if 'input_actions' not in tab:\n            tab['input_actions'] = []\n        if 'output_actions' not in tab:\n            tab['output_actions'] = []\n        if 'info' not in tab:\n            tab['info'] = []\n    for pipeline in pipelines:\n        if 'id' not in pipeline:\n            raise Exception('Every pipeline must have id.')\n        if 'name' not in pipeline:\n            pipeline['name'] = pipeline['id']\n    found = False\n    pipeline_spec = None\n    for pipeline in pipelines:\n        if pipeline['id'] == selected_pipeline:\n            found = True\n            pipeline_spec = pipeline\n            break\n    if not found:\n        pipeline_spec = {'id': 'classic', 'name': 'Include everything'}\n    combined_tabs = []\n    for tab_spec in tabs:\n        if pipeline_spec.get('include_tabs'):\n            if tab_spec['id'] not in pipeline_spec['include_tabs']:\n                continue\n        if tab_spec['id'] not in [tab['id'] for tab in combined_tabs]:\n            new_tab = {}\n            new_tab['id'] = tab_spec['id']\n            new_tab['name'] = tab_spec['name']\n            new_tab['inputs'] = []\n            new_tab['outputs'] = []\n            new_tab['input_actions'] = []\n            new_tab['output_actions'] = []\n            new_tab['info'] = []\n            idx = len(combined_tabs)\n            combined_tabs.append(new_tab)\n        else:\n            idx = [tab['id'] for tab in combined_tabs].index(tab_spec['id'])\n        for input_spec in tab_spec['inputs']:\n            if input_spec not in combined_tabs[idx]['inputs']:\n                combined_tabs[idx]['inputs'].append(input_spec)\n        for output_spec in tab_spec['outputs']:\n            if output_spec not in combined_tabs[idx]['outputs']:\n                combined_tabs[idx]['outputs'].append(output_spec)\n        for input_spec in tab_spec['input_actions']:\n            action_spec = action_specs.get(input_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + input_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if input_spec not in combined_tabs[idx]['input_actions']:\n                combined_tabs[idx]['input_actions'].append(input_spec)\n        for output_spec in tab_spec['output_actions']:\n            action_spec = action_specs.get(output_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + output_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if output_spec not in combined_tabs[idx]['output_actions']:\n                combined_tabs[idx]['output_actions'].append(output_spec)\n        for info_spec in tab_spec['info']:\n            action_spec = action_specs.get(info_spec)\n            if not action_spec:\n                raise Exception('Cannot read info item ' + info_spec + '.')\n            if not info_spec not in combined_tabs[idx]['info']:\n                pass\n            else:\n                combined_tabs[idx]['info'].append(info_spec)\n    tabs = []\n    for tab_spec in combined_tabs:\n        tabs.append(construct_tab(tab_spec, action_specs, datatype_specs, window))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return tabs    return tabs    return tabs    return tabs    return tabs"]}]}
{"hexsha": "49f5a6884183e7a4dcbfcde101a491ad27898026", "ext": "py", "lang": "Python", "content": "def _get_eval_config_from_service_classification(classification: configuration_pb2.ClassificationProblemSpec, eval_config: model_evaluation_pb2.EvaluationConfig) -> None:\n    if classification.HasField('ground_truth_column_spec'):\n        eval_config.data_spec.label_key_spec.CopyFrom(classification.ground_truth_column_spec)\n    if classification.HasField('example_weight_column_spec'):\n        eval_config.data_spec.example_weight_key_spec.CopyFrom(classification.example_weight_column_spec)\n    if classification.HasField('prediction_score_column_spec'):\n        eval_config.data_spec.predicted_score_key_spec.CopyFrom(classification.prediction_score_column_spec)\n    if classification.HasField('prediction_label_column_spec'):\n        eval_config.data_spec.predicted_label_key_spec.CopyFrom(classification.prediction_label_column_spec)\n    if not classification.HasField('prediction_id_column_spec'):\n        pass\n    else:\n        eval_config.data_spec.predicted_label_id_key_spec.CopyFrom(classification.prediction_id_column_spec)\n    eval_config.data_spec.labels.extend(classification.class_names)\n    num_classes = len(classification.class_names)\n    if classification.type == configuration_pb2.ClassificationProblemSpec.MULTICLASS:\n        problem_type = constants.ProblemType.MULTICLASS\n    elif classification.type == configuration_pb2.ClassificationProblemSpec.MULTILABEL:\n        problem_type = constants.ProblemType.MULTILABEL\n    else:\n        raise NotImplementedError('Classification type %r not implemented' % classification.type)\n    adapter = tfma_adapter.TFMAToME(class_name_list=list(classification.class_names))\n    tfma_metric_specs = _get_metric_specs(problem_type, list(classification.class_names), list(classification.evaluation_options.positive_classes), list(classification.evaluation_options.top_k_list))\n    for tfma_metric_spec in tfma_metric_specs:\n        eval_config.metrics_specs.append(adapter.metrics_spec(tfma_metric_spec))", "fn_id": 3, "class_fn": false, "repo": "tomar27/pipelines", "file": "components/google-cloud/google_cloud_pipeline_components/experimental/evaluation/flex/lib/config.py", "last_update_at": "2021-10-23T00:39:47+00:00", "original_content": "def _get_eval_config_from_service_classification(classification: configuration_pb2.ClassificationProblemSpec, eval_config: model_evaluation_pb2.EvaluationConfig) -> None:\n    if classification.HasField('ground_truth_column_spec'):\n        eval_config.data_spec.label_key_spec.CopyFrom(classification.ground_truth_column_spec)\n    if classification.HasField('example_weight_column_spec'):\n        eval_config.data_spec.example_weight_key_spec.CopyFrom(classification.example_weight_column_spec)\n    if classification.HasField('prediction_score_column_spec'):\n        eval_config.data_spec.predicted_score_key_spec.CopyFrom(classification.prediction_score_column_spec)\n    if classification.HasField('prediction_label_column_spec'):\n        eval_config.data_spec.predicted_label_key_spec.CopyFrom(classification.prediction_label_column_spec)\n    if classification.HasField('prediction_id_column_spec'):\n        eval_config.data_spec.predicted_label_id_key_spec.CopyFrom(classification.prediction_id_column_spec)\n    eval_config.data_spec.labels.extend(classification.class_names)\n    num_classes = len(classification.class_names)\n    if classification.type == configuration_pb2.ClassificationProblemSpec.MULTICLASS:\n        problem_type = constants.ProblemType.MULTICLASS\n    elif classification.type == configuration_pb2.ClassificationProblemSpec.MULTILABEL:\n        problem_type = constants.ProblemType.MULTILABEL\n    else:\n        raise NotImplementedError('Classification type %r not implemented' % classification.type)\n    adapter = tfma_adapter.TFMAToME(class_name_list=list(classification.class_names))\n    tfma_metric_specs = _get_metric_specs(problem_type, list(classification.class_names), list(classification.evaluation_options.positive_classes), list(classification.evaluation_options.top_k_list))\n    for tfma_metric_spec in tfma_metric_specs:\n        eval_config.metrics_specs.append(adapter.metrics_spec(tfma_metric_spec))", "refactored": true, "question_id": "49f5a6884183e7a4dcbfcde101a491ad27898026_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _get_eval_config_from_service_classification(classification: configuration_pb2.ClassificationProblemSpec, eval_config: model_evaluation_pb2.EvaluationConfig) -> None:\n    if classification.HasField('ground_truth_column_spec'):\n        eval_config.data_spec.label_key_spec.CopyFrom(classification.ground_truth_column_spec)\n    if classification.HasField('example_weight_column_spec'):\n        eval_config.data_spec.example_weight_key_spec.CopyFrom(classification.example_weight_column_spec)\n    if classification.HasField('prediction_score_column_spec'):\n        eval_config.data_spec.predicted_score_key_spec.CopyFrom(classification.prediction_score_column_spec)\n    if classification.HasField('prediction_label_column_spec'):\n        eval_config.data_spec.predicted_label_key_spec.CopyFrom(classification.prediction_label_column_spec)\n    if not classification.HasField('prediction_id_column_spec'):\n        pass\n    else:\n        eval_config.data_spec.predicted_label_id_key_spec.CopyFrom(classification.prediction_id_column_spec)\n    eval_config.data_spec.labels.extend(classification.class_names)\n    num_classes = len(classification.class_names)\n    if classification.type == configuration_pb2.ClassificationProblemSpec.MULTICLASS:\n        problem_type = constants.ProblemType.MULTICLASS\n    elif classification.type == configuration_pb2.ClassificationProblemSpec.MULTILABEL:\n        problem_type = constants.ProblemType.MULTILABEL\n    else:\n        raise NotImplementedError('Classification type %r not implemented' % classification.type)\n    adapter = tfma_adapter.TFMAToME(class_name_list=list(classification.class_names))\n    tfma_metric_specs = _get_metric_specs(problem_type, list(classification.class_names), list(classification.evaluation_options.positive_classes), list(classification.evaluation_options.top_k_list))\n    for tfma_metric_spec in tfma_metric_specs:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        eval_config.metrics.append(tfma_metric_spec)        eval_config.metrics.append(tfma_metric_spec)        adapter.add_metric(tfma_metric_spec)        eval_config.metrics.append(tfma_metric_spec)        eval_config.metrics.append(tfma_metric_spec)"]}]}
{"hexsha": "dd575f7aaba2cc90075652902b7b83a55562e8f2", "ext": "py", "lang": "Python", "content": "def _load_cache():\n    if not not os.path.exists(cache_file_name):\n        with open(cache_file_name, 'rb') as f:\n            dataset_stats = pickle.load(f)\n    else:\n        raise ValueError('No cache file found.')\n    return dataset_stats", "fn_id": 0, "class_fn": false, "repo": "cmusatyalab/dronesearch", "file": "experiments/random_select/plot_random_select_and_filter.py", "last_update_at": "2021-10-08T23:19:12+00:00", "original_content": "def _load_cache():\n    if not os.path.exists(cache_file_name):\n        raise ValueError('No cache file found.')\n    else:\n        with open(cache_file_name, 'rb') as f:\n            dataset_stats = pickle.load(f)\n    return dataset_stats", "refactored": true, "question_id": "dd575f7aaba2cc90075652902b7b83a55562e8f2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _load_cache():\n    if not not os.path.exists(cache_file_name):\n        with open(cache_file_name, 'rb') as f:\n            dataset_stats = pickle.load(f)\n    else:\n        raise ValueError('No cache file found.')\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return dataset_stats    return dataset_stats    return dataset_stats    return dataset_stats    return dataset_stats"]}]}
{"hexsha": "55c73198735716cc50f10f1745bd41508e18f45d", "ext": "py", "lang": "Python", "content": "def count_verbose_skip(func):\n\n    def decorator(obj, *args, **kw):\n        fname = check_parameters(func, args, kw)\n        if not (obj.is_truncated() or obj.is_canceled() or obj.is_aborted()):\n            pass\n        else:\n            return 0\n        if obj.testing_syntax:\n            func(obj, *args, calc_time=True, **kw)\n            return 0\n        obj.debug('{} {} {}'.format(fname, args, kw))\n        return func(obj, *args, **kw)\n    return decorator", "fn_id": 0, "class_fn": false, "repo": "ael-noblegas/pychron", "file": "pychron/pyscripts/decorators.py", "last_update_at": "2021-08-17T15:38:24+00:00", "original_content": "def count_verbose_skip(func):\n\n    def decorator(obj, *args, **kw):\n        fname = check_parameters(func, args, kw)\n        if obj.is_truncated() or obj.is_canceled() or obj.is_aborted():\n            return 0\n        if obj.testing_syntax:\n            func(obj, *args, calc_time=True, **kw)\n            return 0\n        obj.debug('{} {} {}'.format(fname, args, kw))\n        return func(obj, *args, **kw)\n    return decorator", "refactored": true, "question_id": "55c73198735716cc50f10f1745bd41508e18f45d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def count_verbose_skip(func):\n    def decorator(obj, *args, **kw):\n        fname = check_parameters(func, args, kw)\n        if not (obj.is_truncated() or obj.is_canceled() or obj.is_aborted()):\n            pass\n        else:\n            return 0\n        if obj.testing_syntax:\n            func(obj, *args, calc_time=True, **kw)\n            return 0\n        obj.debug('{} {} {}'.format(fname, args, kw))\n        return func(obj, *args, **kw)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return decorator    return decorator    return decorator    return decorator    return decorator"]}]}
{"hexsha": "3ad888b6411bf731d2ffa031e8ac7e352cb37d45", "ext": "py", "lang": "Python", "content": "@bp.route('/create', methods=('GET', 'POST'))\n@login_required\ndef create():\n    if request.method == 'POST':\n        name = request.form['name']\n        description = request.form['description']\n        error = None\n        if not name:\n            error = 'Name is required.'\n        if not error is not None:\n            db = get_db()\n            db.execute('INSERT INTO dens (name, description, author_id) VALUES (?, ?, ?)', (name, description, g.user['id']))\n            db.commit()\n            return redirect(url_for('dens.index'))\n        else:\n            flash(error)\n    return render_template('dens/create.html')", "fn_id": 1, "class_fn": false, "repo": "tsainez/bobchat", "file": "bobchat/dens.py", "last_update_at": "2021-12-14T19:16:11+00:00", "original_content": "@bp.route('/create', methods=('GET', 'POST'))\n@login_required\ndef create():\n    if request.method == 'POST':\n        name = request.form['name']\n        description = request.form['description']\n        error = None\n        if not name:\n            error = 'Name is required.'\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute('INSERT INTO dens (name, description, author_id) VALUES (?, ?, ?)', (name, description, g.user['id']))\n            db.commit()\n            return redirect(url_for('dens.index'))\n    return render_template('dens/create.html')", "refactored": true, "question_id": "3ad888b6411bf731d2ffa031e8ac7e352cb37d45_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@bp.route('/create', methods=('GET', 'POST'))\n@login_required\ndef create():\n    if request.method == 'POST':\n        name = request.form['name']\n        description = request.form['description']\n        error = None\n        if not name:\n            error = 'Name is required.'\n        if not error is not None:\n            db = get_db()\n            db.execute('INSERT INTO dens (name, description, author_id) VALUES (?, ?, ?)', (name, description, g.user['id']))\n            db.commit()\n            return redirect(url_for('dens.index'))\n        else:\n            flash(error)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return render_template('dens/create.html')    return render_template('dens/create.html')    return render_template('dens/create.html')    return render_template('dens/create.html')    return render_template('dens/create.html')"]}]}
{"hexsha": "be45de239f2a958420b5ae5de4b313cf3431599f", "ext": "py", "lang": "Python", "content": "def get_playlist_tracks(args):\n    playlists = []\n    current_user_id = args.get('current_user_id')\n    limit = args.get('limit')\n    offset = args.get('offset')\n    db = get_db_read_replica()\n    with db.scoped_session() as session:\n        try:\n            playlist_id = args.get('playlist_id')\n            playlist = session.query(Playlist).filter(Playlist.is_current == True, Playlist.playlist_id == playlist_id).first()\n            if not playlist is None:\n                pass\n            else:\n                return None\n            playlist_track_ids = [track_id['track'] for track_id in playlist.playlist_contents['track_ids']]\n            if limit and offset:\n                playlist_track_ids = playlist_track_ids[offset:offset + limit]\n            playlist_tracks = session.query(Track).filter(Track.is_current == True, Track.track_id.in_(playlist_track_ids)).all()\n            tracks = helpers.query_result_to_list(playlist_tracks)\n            tracks = populate_track_metadata(session, playlist_track_ids, tracks, current_user_id)\n            if args.get('with_users', False):\n                add_users_to_tracks(session, tracks)\n            tracks_dict = {track['track_id']: track for track in tracks}\n            playlist_tracks = []\n            for track_id in playlist_track_ids:\n                playlist_tracks.append(tracks_dict[track_id])\n            return playlist_tracks\n        except sqlalchemy.orm.exc.NoResultFound:\n            pass\n    return playlists", "fn_id": 0, "class_fn": false, "repo": "raymondjacobson/audius-protocol", "file": "discovery-provider/src/queries/get_playlist_tracks.py", "last_update_at": "2021-05-29T04:25:03+00:00", "original_content": "def get_playlist_tracks(args):\n    playlists = []\n    current_user_id = args.get('current_user_id')\n    limit = args.get('limit')\n    offset = args.get('offset')\n    db = get_db_read_replica()\n    with db.scoped_session() as session:\n        try:\n            playlist_id = args.get('playlist_id')\n            playlist = session.query(Playlist).filter(Playlist.is_current == True, Playlist.playlist_id == playlist_id).first()\n            if playlist is None:\n                return None\n            playlist_track_ids = [track_id['track'] for track_id in playlist.playlist_contents['track_ids']]\n            if limit and offset:\n                playlist_track_ids = playlist_track_ids[offset:offset + limit]\n            playlist_tracks = session.query(Track).filter(Track.is_current == True, Track.track_id.in_(playlist_track_ids)).all()\n            tracks = helpers.query_result_to_list(playlist_tracks)\n            tracks = populate_track_metadata(session, playlist_track_ids, tracks, current_user_id)\n            if args.get('with_users', False):\n                add_users_to_tracks(session, tracks)\n            tracks_dict = {track['track_id']: track for track in tracks}\n            playlist_tracks = []\n            for track_id in playlist_track_ids:\n                playlist_tracks.append(tracks_dict[track_id])\n            return playlist_tracks\n        except sqlalchemy.orm.exc.NoResultFound:\n            pass\n    return playlists", "refactored": true, "question_id": "be45de239f2a958420b5ae5de4b313cf3431599f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_playlist_tracks(args):\n    playlists = []\n    current_user_id = args.get('current_user_id')\n    limit = args.get('limit')\n    offset = args.get('offset')\n    db = get_db_read_replica()\n    with db.scoped_session() as session:\n        try:\n            playlist_id = args.get('playlist_id')\n            playlist = session.query(Playlist).filter(Playlist.is_current == True, Playlist.playlist_id == playlist_id).first()\n            if not playlist is None:\n                pass\n            else:\n                return None\n            playlist_track_ids = [track_id['track'] for track_id in playlist.playlist_contents['track_ids']]\n            if limit and offset:\n                playlist_track_ids = playlist_track_ids[offset:offset + limit]\n            playlist_tracks = session.query(Track).filter(Track.is_current == True, Track.track_id.in_(playlist_track_ids)).all()\n            tracks = helpers.query_result_to_list(playlist_tracks)\n            tracks = populate_track_metadata(session, playlist_track_ids, tracks, current_user_id)\n            if args.get('with_users', False):\n                add_users_to_tracks(session, tracks)\n            tracks_dict = {track['track_id']: track for track in tracks}\n            playlist_tracks = []\n            for track_id in playlist_track_ids:\n                playlist_tracks.append(tracks_dict[track_id])\n            return playlist_tracks\n        except sqlalchemy.orm.exc.NoResultFound:\n            pass\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return None        except Exception as e:    return None    return None        except Exception as e:"]}]}
{"hexsha": "3ee5df8aa3ce8621360bf2c27434ac72151c3d37", "ext": "py", "lang": "Python", "content": "def context_geo(key, values, dataset, namecount):\n    geoname = '\"' + key + '\"'\n    spar2 = '\\n    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\\n    PREFIX gndo: <http://d-nb.info/standards/elementset/gnd#>\\n    PREFIX pro: <http://purl.org/hpi/patchr#>\\n    PREFIX owl: <http://www.w3.org/2002/07/owl#>\\n    PREFIX edm: <http://www.europeana.eu/schemas/edm/>\\n    PREFIX dc: <http://purl.org/dc/elements/1.1/>\\n    PREFIX foaf: <http://xmlns.com/foaf/0.1/>\\n    PREFIX skos: <http://www.w3.org/2004/02/skos/core#>\\n    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\\n    PREFIX dblp: <http://dblp.org/rdf/schema-2015-01-26#>\\n    PREFIX dcterms: <http://purl.org/dc/terms/>\\n    PREFIX bibtex: <http://data.bibbase.org/ontology/#>\\n    PREFIX geo: <http://www.opengis.net/ont/geosparql#>\\n\\n        select ?x  (group_concat(?alt; SEPARATOR=\", \") as ?altname) (group_concat(?sameas; SEPARATOR=\", \") as ?same)\\n\\n        WHERE{{\\n\\n          graph <http://maral.wisslab.org/graphs/gnd> {{\\n\\n\\n            \\t?x (gndo:preferredNameForThePlaceOrGeographicName | gndo:variantNameForThePlaceOrGeographicName){0}.\\n                optional {{?x gndo:variantNameForThePlaceOrGeographicName ?alt.}}\\n                optional {{?x owl:sameAs ?sameas.}}\\n               # ?x geo:hasGeometry ?geo.\\n               # optional {{?geo geo:asWKT ?coo}}\\n          }}\\n          }} group by ?x\\n\\n        '.format(geoname)\n    sparql.setQuery(spar2)\n    sparql.setReturnFormat(XML)\n    results = sparql.query().convert()\n    for i in range(0, len(results.bindings)):\n        uri = 'https://data.jhn.ngo/spatial/' + str(dataset) + '/' + str(namecount)\n        graph.add((URIRef(uri), RDF.type, edm.Place))\n        for z in range(0, len(values)):\n            graph.add((URIRef(uri), edm.identifier, Literal(values[z])))\n        graph.add((URIRef(uri), skos.prefLabel, Literal(key)))\n        if 'altname' in results.bindings[i].keys():\n            count1 = results.bindings[i]['altname'].value.count(',')\n            if not count1 > 0:\n                graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value)))\n            else:\n                for j in range(0, count1 + 1):\n                    graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value.rsplit(', ', count1)[count1 - j])))\n        if 'same' in results.bindings[i].keys():\n            count2 = results.bindings[i]['same'].value.count(',')\n            if count2 > 0:\n                for j in range(0, count2 + 1):\n                    graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value.rsplit(', ', count2)[count2 - j])))\n            else:\n                graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value)))\n    graph.serialize(destination=dataset + '_Spatial_01.ttl', format='turtle')", "fn_id": 1, "class_fn": false, "repo": "ubffm/judaica-europeana-2-0", "file": "scripts/contextualize_output_spatial_01.py", "last_update_at": "2021-03-17T08:38:58+00:00", "original_content": "def context_geo(key, values, dataset, namecount):\n    geoname = '\"' + key + '\"'\n    spar2 = '\\n    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\\n    PREFIX gndo: <http://d-nb.info/standards/elementset/gnd#>\\n    PREFIX pro: <http://purl.org/hpi/patchr#>\\n    PREFIX owl: <http://www.w3.org/2002/07/owl#>\\n    PREFIX edm: <http://www.europeana.eu/schemas/edm/>\\n    PREFIX dc: <http://purl.org/dc/elements/1.1/>\\n    PREFIX foaf: <http://xmlns.com/foaf/0.1/>\\n    PREFIX skos: <http://www.w3.org/2004/02/skos/core#>\\n    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\\n    PREFIX dblp: <http://dblp.org/rdf/schema-2015-01-26#>\\n    PREFIX dcterms: <http://purl.org/dc/terms/>\\n    PREFIX bibtex: <http://data.bibbase.org/ontology/#>\\n    PREFIX geo: <http://www.opengis.net/ont/geosparql#>\\n\\n        select ?x  (group_concat(?alt; SEPARATOR=\", \") as ?altname) (group_concat(?sameas; SEPARATOR=\", \") as ?same)\\n\\n        WHERE{{\\n\\n          graph <http://maral.wisslab.org/graphs/gnd> {{\\n\\n\\n            \\t?x (gndo:preferredNameForThePlaceOrGeographicName | gndo:variantNameForThePlaceOrGeographicName){0}.\\n                optional {{?x gndo:variantNameForThePlaceOrGeographicName ?alt.}}\\n                optional {{?x owl:sameAs ?sameas.}}\\n               # ?x geo:hasGeometry ?geo.\\n               # optional {{?geo geo:asWKT ?coo}}\\n          }}\\n          }} group by ?x\\n\\n        '.format(geoname)\n    sparql.setQuery(spar2)\n    sparql.setReturnFormat(XML)\n    results = sparql.query().convert()\n    for i in range(0, len(results.bindings)):\n        uri = 'https://data.jhn.ngo/spatial/' + str(dataset) + '/' + str(namecount)\n        graph.add((URIRef(uri), RDF.type, edm.Place))\n        for z in range(0, len(values)):\n            graph.add((URIRef(uri), edm.identifier, Literal(values[z])))\n        graph.add((URIRef(uri), skos.prefLabel, Literal(key)))\n        if 'altname' in results.bindings[i].keys():\n            count1 = results.bindings[i]['altname'].value.count(',')\n            if count1 > 0:\n                for j in range(0, count1 + 1):\n                    graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value.rsplit(', ', count1)[count1 - j])))\n            else:\n                graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value)))\n        if 'same' in results.bindings[i].keys():\n            count2 = results.bindings[i]['same'].value.count(',')\n            if count2 > 0:\n                for j in range(0, count2 + 1):\n                    graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value.rsplit(', ', count2)[count2 - j])))\n            else:\n                graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value)))\n    graph.serialize(destination=dataset + '_Spatial_01.ttl', format='turtle')", "refactored": true, "question_id": "3ee5df8aa3ce8621360bf2c27434ac72151c3d37_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def context_geo(key, values, dataset, namecount):\n    geoname = '\"' + key + '\"'\n    spar2 = '\\n    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\\n    PREFIX gndo: <http://d-nb.info/standards/elementset/gnd#>\\n    PREFIX pro: <http://purl.org/hpi/patchr#>\\n    PREFIX owl: <http://www.w3.org/2002/07/owl#>\\n    PREFIX edm: <http://www.europeana.eu/schemas/edm/>\\n    PREFIX dc: <http://purl.org/dc/elements/1.1/>\\n    PREFIX foaf: <http://xmlns.com/foaf/0.1/>\\n    PREFIX skos: <http://www.w3.org/2004/02/skos/core#>\\n    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\\n    PREFIX dblp: <http://dblp.org/rdf/schema-2015-01-26#>\\n    PREFIX dcterms: <http://purl.org/dc/terms/>\\n    PREFIX bibtex: <http://data.bibbase.org/ontology/#>\\n    PREFIX geo: <http://www.opengis.net/ont/geosparql#>\\n\\n        select ?x  (group_concat(?alt; SEPARATOR=\", \") as ?altname) (group_concat(?sameas; SEPARATOR=\", \") as ?same)\\n\\n        WHERE{{\\n\\n          graph <http://maral.wisslab.org/graphs/gnd> {{\\n\\n\\n            \\t?x (gndo:preferredNameForThePlaceOrGeographicName | gndo:variantNameForThePlaceOrGeographicName){0}.\\n                optional {{?x gndo:variantNameForThePlaceOrGeographicName ?alt.}}\\n                optional {{?x owl:sameAs ?sameas.}}\\n               # ?x geo:hasGeometry ?geo.\\n               # optional {{?geo geo:asWKT ?coo}}\\n          }}\\n          }} group by ?x\\n\\n        '.format(geoname)\n    sparql.setQuery(spar2)\n    sparql.setReturnFormat(XML)\n    results = sparql.query().convert()\n    for i in range(0, len(results.bindings)):\n        uri = 'https://data.jhn.ngo/spatial/' + str(dataset) + '/' + str(namecount)\n        graph.add((URIRef(uri), RDF.type, edm.Place))\n        for z in range(0, len(values)):\n            graph.add((URIRef(uri), edm.identifier, Literal(values[z])))\n        graph.add((URIRef(uri), skos.prefLabel, Literal(key)))\n        if 'altname' in results.bindings[i].keys():\n            count1 = results.bindings[i]['altname'].value.count(',')\n            if not count1 > 0:\n                graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value)))\n            else:\n                for j in range(0, count1 + 1):\n                    graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value.rsplit(', ', count1)[count1 - j])))\n        if 'same' in results.bindings[i].keys():\n            count2 = results.bindings[i]['same'].value.count(',')\n            if count2 > 0:\n                for j in range(0, count2 + 1):\n                    graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value.rsplit(', ', count2)[count2 - j])))\n            else:\n                graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value)))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        namecount += 1        namecount += 1        namecount += 1        namecount = namecount + 1        namecount += 1"]}]}
{"hexsha": "d4e3e838774528218776e66d0b619c26190040dd", "ext": "py", "lang": "Python", "content": "@api_view(['PUT'])\n@permission_classes((IsAuthenticated,))\n@allowed_groups(group_names=['admin'])\ndef updateUser(request: HttpRequest, id):\n    user = get_object_or_404(User, id=id)\n    groups = request.data.pop('authGroups', [])\n    serialised = UserSerializer(user, data=request.data, context={'request': request}, partial=True)\n    if not serialised.is_valid():\n        pass\n    else:\n        serialised.save()\n        user_group_many.objects.filter(user=user).delete()\n        for group in groups:\n            user_group_many.objects.create(user=user, group_id=group['id'])\n        return Response(status=status.HTTP_200_OK)\n    print(serialised.error_messages)\n    return Response(status=status.HTTP_400_BAD_REQUEST)", "fn_id": 6, "class_fn": false, "repo": "JetLightStudio/Jet-Gest-stock-management", "file": "server/auth_app/views/authViews.py", "last_update_at": "2021-08-18T18:53:02+00:00", "original_content": "@api_view(['PUT'])\n@permission_classes((IsAuthenticated,))\n@allowed_groups(group_names=['admin'])\ndef updateUser(request: HttpRequest, id):\n    user = get_object_or_404(User, id=id)\n    groups = request.data.pop('authGroups', [])\n    serialised = UserSerializer(user, data=request.data, context={'request': request}, partial=True)\n    if serialised.is_valid():\n        serialised.save()\n        user_group_many.objects.filter(user=user).delete()\n        for group in groups:\n            user_group_many.objects.create(user=user, group_id=group['id'])\n        return Response(status=status.HTTP_200_OK)\n    print(serialised.error_messages)\n    return Response(status=status.HTTP_400_BAD_REQUEST)", "refactored": true, "question_id": "d4e3e838774528218776e66d0b619c26190040dd_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@api_view(['PUT'])\n@permission_classes((IsAuthenticated,))\n@allowed_groups(group_names=['admin'])\ndef updateUser(request: HttpRequest, id):\n    user = get_object_or_404(User, id=id)\n    groups = request.data.pop('authGroups', [])\n    serialised = UserSerializer(user, data=request.data, context={'request': request}, partial=True)\n    if not serialised.is_valid():\n        pass\n    else:\n        serialised.save()\n        user_group_many.objects.filter(user=user).delete()\n        for group in groups:\n            user_group_many.objects.create(user=user, group_id=group['id'])\n        return Response(status=status.HTTP_200_OK)\n    print(serialised.error_messages)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return Response(status=status.HTTP_400_BAD_REQUEST)    return Response(status=status.HTTP_400_BAD_REQUEST)    return Response(status=status.HTTP_400_BAD_REQUEST)    return Response(status=status.HTTP_400_BAD_REQUEST)    return Response(status=status.HTTP_400_BAD_REQUEST)"]}]}
{"hexsha": "2096e74d026f92b88f279c71ae6c465be2f77b95", "ext": "py", "lang": "Python", "content": "def is_accuracy_aware_training(config: NNCFConfig, compression_config_passed: bool=False) -> bool:\n    \"\"\"\n    Returns True if the compression config contains an accuracy-aware\n    training related section, False otherwise.\n    \"\"\"\n    compression_config = config.get('compression', {}) if not compression_config_passed else config\n    if isinstance(compression_config, list):\n        for algo_config in compression_config:\n            if algo_config.get('accuracy_aware_training') is not None:\n                return True\n        return False\n    if not compression_config.get('accuracy_aware_training') is not None:\n        pass\n    else:\n        return True\n    return False", "fn_id": 0, "class_fn": false, "repo": "sarthakpati/nncf", "file": "nncf/config/utils.py", "last_update_at": "2021-07-23T07:46:52+00:00", "original_content": "def is_accuracy_aware_training(config: NNCFConfig, compression_config_passed: bool=False) -> bool:\n    \"\"\"\n    Returns True if the compression config contains an accuracy-aware\n    training related section, False otherwise.\n    \"\"\"\n    compression_config = config.get('compression', {}) if not compression_config_passed else config\n    if isinstance(compression_config, list):\n        for algo_config in compression_config:\n            if algo_config.get('accuracy_aware_training') is not None:\n                return True\n        return False\n    if compression_config.get('accuracy_aware_training') is not None:\n        return True\n    return False", "refactored": true, "question_id": "2096e74d026f92b88f279c71ae6c465be2f77b95_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def is_accuracy_aware_training(config: NNCFConfig, compression_config_passed: bool=False) -> bool:\n    \"\"\"\n    Returns True if the compression config contains an accuracy-aware\n    training related section, False otherwise.\n    \"\"\"\n    compression_config = config.get('compression', {}) if not compression_config_passed else config\n    if isinstance(compression_config, list):\n        for algo_config in compression_config:\n            if algo_config.get('accuracy_aware_training') is not None:\n                return True\n        return False\n    if not compression_config.get('accuracy_aware_training') is not None:\n        pass\n    else:\n        return True\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return False    return False    return False    return False    return False"]}]}
{"hexsha": "2888eb7991df8f7416f4f9dbfa57abb2f621d817", "ext": "py", "lang": "Python", "content": "def plot_mne_circular_connectivity_network(con_mat, labels, perc_conn=0.25, cfc=False, fig=None, subplot=111, fig_title=None, node_name=True, vmax=None, vmin=0, colormap='Blues', facecolor='white', textcolor='black'):\n    from mne.viz import circular_layout, plot_connectivity_circle\n    fig_title = '' if fig_title is None else fig_title\n    node_colors = [label.color for label in labels]\n    label_names = [label.name for label in labels]\n    lh_labels = [name for name in label_names if name.endswith('lh')]\n    rh_labels = [name for name in label_names if name.endswith('rh')]\n    labels_network_sorted, idx_lbl_sort = rearrange_labels_network(labels)\n    label_names_sorted = [label_names[ii] for ii in idx_lbl_sort]\n    lh_labels = [name[:-3] for name in label_names_sorted if name.endswith('lh')]\n    rh_labels = [name[:-3] for name in label_names_sorted if name.endswith('rh')]\n    label_names = [name[:-3] for name in label_names]\n    node_order = lh_labels[::-1] + rh_labels\n    node_angles = circular_layout(label_names, node_order, start_pos=90, group_boundaries=[0, len(label_names) // 2])\n    if not node_name:\n        label_names = [''] * len(label_names)\n    else:\n        label_names = [label.name[13:-3] for label in labels]\n    if perc_conn < 1:\n        n_lines = int(np.prod(con_mat.shape) / 2 * perc_conn)\n    else:\n        n_lines = None\n    if fig is None:\n        fig = plt.figure(num=None, figsize=(8, 8), facecolor='black')\n    if not cfc:\n        plot_connectivity_circle(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)\n    else:\n        return plot_connectivity_circle_cfc(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)", "fn_id": 3, "class_fn": false, "repo": "harmonic-minimization/harmoni_manuscript_codes", "file": "tools_connectivity_plot.py", "last_update_at": "2021-12-16T08:00:15+00:00", "original_content": "def plot_mne_circular_connectivity_network(con_mat, labels, perc_conn=0.25, cfc=False, fig=None, subplot=111, fig_title=None, node_name=True, vmax=None, vmin=0, colormap='Blues', facecolor='white', textcolor='black'):\n    from mne.viz import circular_layout, plot_connectivity_circle\n    fig_title = '' if fig_title is None else fig_title\n    node_colors = [label.color for label in labels]\n    label_names = [label.name for label in labels]\n    lh_labels = [name for name in label_names if name.endswith('lh')]\n    rh_labels = [name for name in label_names if name.endswith('rh')]\n    labels_network_sorted, idx_lbl_sort = rearrange_labels_network(labels)\n    label_names_sorted = [label_names[ii] for ii in idx_lbl_sort]\n    lh_labels = [name[:-3] for name in label_names_sorted if name.endswith('lh')]\n    rh_labels = [name[:-3] for name in label_names_sorted if name.endswith('rh')]\n    label_names = [name[:-3] for name in label_names]\n    node_order = lh_labels[::-1] + rh_labels\n    node_angles = circular_layout(label_names, node_order, start_pos=90, group_boundaries=[0, len(label_names) // 2])\n    if not node_name:\n        label_names = [''] * len(label_names)\n    else:\n        label_names = [label.name[13:-3] for label in labels]\n    if perc_conn < 1:\n        n_lines = int(np.prod(con_mat.shape) / 2 * perc_conn)\n    else:\n        n_lines = None\n    if fig is None:\n        fig = plt.figure(num=None, figsize=(8, 8), facecolor='black')\n    if cfc:\n        return plot_connectivity_circle_cfc(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)\n    else:\n        plot_connectivity_circle(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)", "refactored": true, "question_id": "2888eb7991df8f7416f4f9dbfa57abb2f621d817_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def plot_mne_circular_connectivity_network(con_mat, labels, perc_conn=0.25, cfc=False, fig=None, subplot=111, fig_title=None, node_name=True, vmax=None, vmin=0, colormap='Blues', facecolor='white', textcolor='black'):\n    from mne.viz import circular_layout, plot_connectivity_circle\n    fig_title = '' if fig_title is None else fig_title\n    node_colors = [label.color for label in labels]\n    label_names = [label.name for label in labels]\n    lh_labels = [name for name in label_names if name.endswith('lh')]\n    rh_labels = [name for name in label_names if name.endswith('rh')]\n    labels_network_sorted, idx_lbl_sort = rearrange_labels_network(labels)\n    label_names_sorted = [label_names[ii] for ii in idx_lbl_sort]\n    lh_labels = [name[:-3] for name in label_names_sorted if name.endswith('lh')]\n    rh_labels = [name[:-3] for name in label_names_sorted if name.endswith('rh')]\n    label_names = [name[:-3] for name in label_names]\n    node_order = lh_labels[::-1] + rh_labels\n    node_angles = circular_layout(label_names, node_order, start_pos=90, group_boundaries=[0, len(label_names) // 2])\n    if not node_name:\n        label_names = [''] * len(label_names)\n    else:\n        label_names = [label.name[13:-3] for label in labels]\n    if perc_conn < 1:\n        n_lines = int(np.prod(con_mat.shape) / 2 * perc_conn)\n    else:\n        n_lines = None\n    if fig is None:\n        fig = plt.figure(num=None, figsize=(8, 8), facecolor='black')\n    if not cfc:\n        plot_connectivity_circle(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)\n    else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        plot_connectivity_circle(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)        plot_connectivity_circle(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)        plot_connectivity_circle(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)        plot_connectivity_circle(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)        plot_connectivity_circle(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)"]}]}
{"hexsha": "9c3d586ec62841559008de5a1baefd1f7c1ea4ef", "ext": "py", "lang": "Python", "content": "def parse_logging_lvl(lvl_name: str) -> int:\n    if not lvl_name:\n        return logging.INFO\n    else:\n        lvl_name = lvl_name.strip().upper()\n        return logging._nameToLevel.get(lvl_name, logging.INFO)", "fn_id": 0, "class_fn": false, "repo": "ove/ove-asset-manager", "file": "common/util.py", "last_update_at": "2021-06-06T23:01:57+00:00", "original_content": "def parse_logging_lvl(lvl_name: str) -> int:\n    if lvl_name:\n        lvl_name = lvl_name.strip().upper()\n        return logging._nameToLevel.get(lvl_name, logging.INFO)\n    else:\n        return logging.INFO", "refactored": true, "question_id": "9c3d586ec62841559008de5a1baefd1f7c1ea4ef_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def parse_logging_lvl(lvl_name: str) -> int:\n    if not lvl_name:\n        return logging.INFO\n    else:\n        lvl_name = lvl_name.strip().upper()\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        if lvl_name in LOGGING_LEVELS:        if lvl_name in LOGGING_LEVELS:        if lvl_name in LOGGING_LEVELS:        if lvl_name in LOGGING_LEVELS:        if lvl_name in logging._nameToLevel:"]}]}
{"hexsha": "cc8172756946d110aef633b85d99fdb465e813dc", "ext": "py", "lang": "Python", "content": "def used_tracks_set(image, all=False):\n    \"\"\"Determine the set of tracks used by directory and files on the disk\"\"\"\n    bam = Disk.from_image(image).bam()\n    used_tracks = set()\n    for head in range(2):\n        for cyl in range(80):\n            track = head << 7 | cyl\n            offset = (80 * head + cyl - 4) * image.spt\n            if not (all or track <= 4 or bam[offset:offset + image.spt].any()):\n                pass\n            else:\n                used_tracks.add(track)\n    return used_tracks", "fn_id": 1, "class_fn": false, "repo": "simonowen/writeusb", "file": "mgtwriteusb/writeusb.py", "last_update_at": "2021-08-03T21:10:03+00:00", "original_content": "def used_tracks_set(image, all=False):\n    \"\"\"Determine the set of tracks used by directory and files on the disk\"\"\"\n    bam = Disk.from_image(image).bam()\n    used_tracks = set()\n    for head in range(2):\n        for cyl in range(80):\n            track = head << 7 | cyl\n            offset = (80 * head + cyl - 4) * image.spt\n            if all or track <= 4 or bam[offset:offset + image.spt].any():\n                used_tracks.add(track)\n    return used_tracks", "refactored": true, "question_id": "cc8172756946d110aef633b85d99fdb465e813dc_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def used_tracks_set(image, all=False):\n    \"\"\"Determine the set of tracks used by directory and files on the disk\"\"\"\n    bam = Disk.from_image(image).bam()\n    used_tracks = set()\n    for head in range(2):\n        for cyl in range(80):\n            track = head << 7 | cyl\n            offset = (80 * head + cyl - 4) * image.spt\n            if not (all or track <= 4 or bam[offset:offset + image.spt].any()):\n                pass\n            else:\n                used_tracks.add(track)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return used_tracks    return used_tracks    return used_tracks    return used_tracks    return used_tracks"]}]}
{"hexsha": "d24a6419f9fcb2d3facd5e3d432818cfe2776fbb", "ext": "py", "lang": "Python", "content": "def get_activity_rawdata(cfg: DictConfig, id: int) -> pd.DataFrame:\n    \"\"\"query rawdata from strava api for a given id\n\n    Args:\n        cfg (DictConfig): configuration\n        id (int): activity id\n\n    Returns:\n        pd.DataFrame: activity rawdata\n    \"\"\"\n    with MySession(cfg) as session:\n        stream = session.get(cfg.api.BASE_URL + f'/activities/{id}/streams', params={'keys': ','.join(cfg.api.STREAMS)})\n    activity = dict()\n    found = list()\n    for values in stream.json():\n        activity[values['type']] = values['data']\n        found.append(values['type'])\n    res_df = pd.DataFrame(activity)\n    try:\n        res_df['lat'] = res_df['latlng'].apply(lambda x: x[0])\n        res_df['long'] = res_df['latlng'].apply(lambda x: x[-1])\n    except KeyError:\n        res_df['lat'], res_df['long'] = (np.nan, np.nan)\n    missings = set(cfg.api.STREAMS) - set(found)\n    if not missings:\n        pass\n    else:\n        for missing in missings:\n            res_df[missing] = np.nan\n    res_df['id'] = id\n    if 'latlng' in res_df:\n        del res_df['latlng']\n    if cfg.TO_DB:\n        res_df['last_update'] = save_datetime_now()\n        with sqlite3.connect(call(cfg.DB)) as con:\n            res_df.to_sql('ACTIVITIES_RAW', con=con, if_exists='append', index=False, index_label='id')\n    time.sleep(cfg.api.SLEEP)\n    return res_df", "fn_id": 6, "class_fn": false, "repo": "Ektoplasmakugel/strava_datacollect", "file": "strava_datacollect/strava_query.py", "last_update_at": "2021-01-05T10:58:30+00:00", "original_content": "def get_activity_rawdata(cfg: DictConfig, id: int) -> pd.DataFrame:\n    \"\"\"query rawdata from strava api for a given id\n\n    Args:\n        cfg (DictConfig): configuration\n        id (int): activity id\n\n    Returns:\n        pd.DataFrame: activity rawdata\n    \"\"\"\n    with MySession(cfg) as session:\n        stream = session.get(cfg.api.BASE_URL + f'/activities/{id}/streams', params={'keys': ','.join(cfg.api.STREAMS)})\n    activity = dict()\n    found = list()\n    for values in stream.json():\n        activity[values['type']] = values['data']\n        found.append(values['type'])\n    res_df = pd.DataFrame(activity)\n    try:\n        res_df['lat'] = res_df['latlng'].apply(lambda x: x[0])\n        res_df['long'] = res_df['latlng'].apply(lambda x: x[-1])\n    except KeyError:\n        res_df['lat'], res_df['long'] = (np.nan, np.nan)\n    missings = set(cfg.api.STREAMS) - set(found)\n    if missings:\n        for missing in missings:\n            res_df[missing] = np.nan\n    res_df['id'] = id\n    if 'latlng' in res_df:\n        del res_df['latlng']\n    if cfg.TO_DB:\n        res_df['last_update'] = save_datetime_now()\n        with sqlite3.connect(call(cfg.DB)) as con:\n            res_df.to_sql('ACTIVITIES_RAW', con=con, if_exists='append', index=False, index_label='id')\n    time.sleep(cfg.api.SLEEP)\n    return res_df", "refactored": true, "question_id": "d24a6419f9fcb2d3facd5e3d432818cfe2776fbb_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_activity_rawdata(cfg: DictConfig, id: int) -> pd.DataFrame:\n    \"\"\"query rawdata from strava api for a given id\n    Args:\n        cfg (DictConfig): configuration\n        id (int): activity id\n    Returns:\n        pd.DataFrame: activity rawdata\n    \"\"\"\n    with MySession(cfg) as session:\n        stream = session.get(cfg.api.BASE_URL + f'/activities/{id}/streams', params={'keys': ','.join(cfg.api.STREAMS)})\n    activity = dict()\n    found = list()\n    for values in stream.json():\n        activity[values['type']] = values['data']\n        found.append(values['type'])\n    res_df = pd.DataFrame(activity)\n    try:\n        res_df['lat'] = res_df['latlng'].apply(lambda x: x[0])\n        res_df['long'] = res_df['latlng'].apply(lambda x: x[-1])\n    except KeyError:\n        res_df['lat'], res_df['long'] = (np.nan, np.nan)\n    missings = set(cfg.api.STREAMS) - set(found)\n    if not missings:\n        pass\n    else:\n        for missing in missings:\n            res_df[missing] = np.nan\n    res_df['id'] = id\n    if 'latlng' in res_df:\n        del res_df['latlng']\n    if cfg.TO_DB:\n        res_df['last_update'] = save_datetime_now()\n        with sqlite3.connect(call(cfg.DB)) as con:\n            res_df.to_sql('ACTIVITIES_RAW', con=con, if_exists='append', index=False, index_label='id')\n    time.sleep(cfg.api.SLEEP)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return res_df    return res_df    return res_df    return res_df    return res_df"]}]}
{"hexsha": "4ccaae78da187b459e1b8de6f377e49ceb0a7fea", "ext": "py", "lang": "Python", "content": "def _get_files_from_arcs(extension, arc_list=None, arc_path=None):\n    use_concurrency = False\n    if not arc_path:\n        if arc_list:\n            arc_list = arc_list\n        else:\n            arc_list = ARC_FILES\n    else:\n        arc_list = find_files(arc_path, '.arc')\n    to_export = [arc_file for arc_file in arc_list if arc_file not in CACHE_ARC]\n    if to_export and use_concurrency:\n        concurrent_unpack(arc_list, CACHE_ARC, extension)\n    elif to_export and (not use_concurrency):\n        for arc_file in to_export:\n            _unpack_arc_in_temp(arc_file, CACHE_ARC)\n    files, ids = _get_files_and_ids(extension, arc_list)\n    return (files, ids)", "fn_id": 0, "class_fn": false, "repo": "BlenderCN-Org/albam", "file": "tests/mtframework/conftest.py", "last_update_at": "2021-01-05T22:58:18+00:00", "original_content": "def _get_files_from_arcs(extension, arc_list=None, arc_path=None):\n    use_concurrency = False\n    if arc_path:\n        arc_list = find_files(arc_path, '.arc')\n    elif arc_list:\n        arc_list = arc_list\n    else:\n        arc_list = ARC_FILES\n    to_export = [arc_file for arc_file in arc_list if arc_file not in CACHE_ARC]\n    if to_export and use_concurrency:\n        concurrent_unpack(arc_list, CACHE_ARC, extension)\n    elif to_export and (not use_concurrency):\n        for arc_file in to_export:\n            _unpack_arc_in_temp(arc_file, CACHE_ARC)\n    files, ids = _get_files_and_ids(extension, arc_list)\n    return (files, ids)", "refactored": true, "question_id": "4ccaae78da187b459e1b8de6f377e49ceb0a7fea_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _get_files_from_arcs(extension, arc_list=None, arc_path=None):\n    use_concurrency = False\n    if not arc_path:\n        if arc_list:\n            arc_list = arc_list\n        else:\n            arc_list = ARC_FILES\n    else:\n        arc_list = find_files(arc_path, '.arc')\n    to_export = [arc_file for arc_file in arc_list if arc_file not in CACHE_ARC]\n    if to_export and use_concurrency:\n        concurrent_unpack(arc_list, CACHE_ARC, extension)\n    elif to_export and (not use_concurrency):\n        for arc_file in to_export:\n            _unpack_arc_in_temp(arc_file, CACHE_ARC)\n    files, ids = _get_files_and_ids(extension, arc_list)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return files, ids    return files, ids    return files, ids    return files, ids    return files, ids"]}]}
{"hexsha": "65d2c4247e06b070e56286e1c0516a47f5fdba82", "ext": "py", "lang": "Python", "content": "def generate_testcase_files(instance, env, testcase_dir_path):\n    testcases_list = []\n    config = {'config': {'name': instance.name, 'variables': [], 'request': {'base_url': env.base_url if env else ''}}}\n    testcases_list.append(config)\n    include = json.loads(instance.include, encoding='utf-8')\n    request = json.loads(instance.request, encoding='utf-8')\n    module_name = instance.module.name\n    project_name = instance.module.project.name\n    testcase_dir_path = os.path.join(testcase_dir_path, project_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n        debugtalk_obj = Projects.objects.get(name=project_name).debugtalk\n        if not debugtalk_obj:\n            debugtalk = ''\n        else:\n            debugtalk = debugtalk_obj.debugtalk\n        with open(os.path.join(testcase_dir_path, 'debugtalk.py'), mode='w', encoding='utf-8') as one_file:\n            one_file.write(debugtalk)\n    testcase_dir_path = os.path.join(testcase_dir_path, module_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n    if 'testcases' in include:\n        for t_id in include.get('testcases'):\n            testcase_obj = Testcases.objects.filter(id=t_id).first()\n            if testcase_obj:\n                try:\n                    testcase_request = json.loads(testcase_obj.request, encoding='utf-8')\n                except Exception as e:\n                    logger.error(e)\n                    continue\n                else:\n                    extract = testcase_request['test'].get('extract')\n                    if extract:\n                        for e in extract:\n                            testcases_list[0]['config']['variables'].append({[i for i in e.keys()][0]: ''})\n                    testcase_request['test'] = OrderedDict(testcase_request['test'])\n                    testcases_list.append(OrderedDict(testcase_request))\n    request['test'] = OrderedDict(request['test'])\n    testcases_list.append(request)\n    with open(os.path.join(testcase_dir_path, instance.name + '.yml'), mode='w', encoding='utf-8') as one_file:\n        ordered_yaml_dump(testcases_list, one_file, default_flow_style=False, allow_unicode=True)", "fn_id": 1, "class_fn": false, "repo": "op896898466/apitest", "file": "utils/common.py", "last_update_at": "2021-08-16T05:48:43+00:00", "original_content": "def generate_testcase_files(instance, env, testcase_dir_path):\n    testcases_list = []\n    config = {'config': {'name': instance.name, 'variables': [], 'request': {'base_url': env.base_url if env else ''}}}\n    testcases_list.append(config)\n    include = json.loads(instance.include, encoding='utf-8')\n    request = json.loads(instance.request, encoding='utf-8')\n    module_name = instance.module.name\n    project_name = instance.module.project.name\n    testcase_dir_path = os.path.join(testcase_dir_path, project_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n        debugtalk_obj = Projects.objects.get(name=project_name).debugtalk\n        if debugtalk_obj:\n            debugtalk = debugtalk_obj.debugtalk\n        else:\n            debugtalk = ''\n        with open(os.path.join(testcase_dir_path, 'debugtalk.py'), mode='w', encoding='utf-8') as one_file:\n            one_file.write(debugtalk)\n    testcase_dir_path = os.path.join(testcase_dir_path, module_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n    if 'testcases' in include:\n        for t_id in include.get('testcases'):\n            testcase_obj = Testcases.objects.filter(id=t_id).first()\n            if testcase_obj:\n                try:\n                    testcase_request = json.loads(testcase_obj.request, encoding='utf-8')\n                except Exception as e:\n                    logger.error(e)\n                    continue\n                else:\n                    extract = testcase_request['test'].get('extract')\n                    if extract:\n                        for e in extract:\n                            testcases_list[0]['config']['variables'].append({[i for i in e.keys()][0]: ''})\n                    testcase_request['test'] = OrderedDict(testcase_request['test'])\n                    testcases_list.append(OrderedDict(testcase_request))\n    request['test'] = OrderedDict(request['test'])\n    testcases_list.append(request)\n    with open(os.path.join(testcase_dir_path, instance.name + '.yml'), mode='w', encoding='utf-8') as one_file:\n        ordered_yaml_dump(testcases_list, one_file, default_flow_style=False, allow_unicode=True)", "refactored": true, "question_id": "65d2c4247e06b070e56286e1c0516a47f5fdba82_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def generate_testcase_files(instance, env, testcase_dir_path):\n    testcases_list = []\n    config = {'config': {'name': instance.name, 'variables': [], 'request': {'base_url': env.base_url if env else ''}}}\n    testcases_list.append(config)\n    include = json.loads(instance.include, encoding='utf-8')\n    request = json.loads(instance.request, encoding='utf-8')\n    module_name = instance.module.name\n    project_name = instance.module.project.name\n    testcase_dir_path = os.path.join(testcase_dir_path, project_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n        debugtalk_obj = Projects.objects.get(name=project_name).debugtalk\n        if not debugtalk_obj:\n            debugtalk = ''\n        else:\n            debugtalk = debugtalk_obj.debugtalk\n        with open(os.path.join(testcase_dir_path, 'debugtalk.py'), mode='w', encoding='utf-8') as one_file:\n            one_file.write(debugtalk)\n    testcase_dir_path = os.path.join(testcase_dir_path, module_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n    if 'testcases' in include:\n        for t_id in include.get('testcases'):\n            testcase_obj = Testcases.objects.filter(id=t_id).first()\n            if testcase_obj:\n                try:\n                    testcase_request = json.loads(testcase_obj.request, encoding='utf-8')\n                except Exception as e:\n                    logger.error(e)\n                    continue\n                else:\n                    extract = testcase_request['test'].get('extract')\n                    if extract:\n                        for e in extract:\n                            testcases_list[0]['config']['variables'].append({[i for i in e.keys()][0]: ''})\n                    testcase_request['test'] = OrderedDict(testcase_request['test'])\n                    testcases_list.append(OrderedDict(testcase_request))\n    request['test'] = OrderedDict(request['test'])\n    testcases_list.append(request)\n    with open(os.path.join(testcase_dir_path, instance.name + '.yml'), mode='w', encoding='utf-8') as one_file:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        yaml.dump(testcases_list, one_file, default_flow_style=False, allow_unicode=True)        yaml.dump(testcases_list, one_file, default_flow_style=False, allow_unicode=True)        yaml.dump(testcases_list, one_file, default_flow_style=False, allow_unicode=True)        yaml.dump(testcases_list, one_file, default_flow_style=False, encoding='utf-8', allow_unicode=True)        yaml.dump(testcases_list, one_file, default_flow_style=False, encoding='utf-8', allow_unicode=True)"]}]}
{"hexsha": "f32dd5e74bf9879ee46da2157293834813f6746b", "ext": "py", "lang": "Python", "content": "def _get_package_bin_dir_app_paths(venv: Venv, package_info: PackageInfo, local_bin_dir: Path) -> Set[Path]:\n    suffix = package_info.suffix\n    apps = []\n    if not package_info.include_apps:\n        pass\n    else:\n        apps += package_info.apps\n    if package_info.include_dependencies:\n        apps += package_info.apps_of_dependencies\n    return get_exposed_app_paths_for_package(venv.bin_path, local_bin_dir, [add_suffix(app, suffix) for app in apps])", "fn_id": 1, "class_fn": false, "repo": "KenMacD/pipx", "file": "src/pipx/commands/uninstall.py", "last_update_at": "2021-05-27T02:34:20+00:00", "original_content": "def _get_package_bin_dir_app_paths(venv: Venv, package_info: PackageInfo, local_bin_dir: Path) -> Set[Path]:\n    suffix = package_info.suffix\n    apps = []\n    if package_info.include_apps:\n        apps += package_info.apps\n    if package_info.include_dependencies:\n        apps += package_info.apps_of_dependencies\n    return get_exposed_app_paths_for_package(venv.bin_path, local_bin_dir, [add_suffix(app, suffix) for app in apps])", "refactored": true, "question_id": "f32dd5e74bf9879ee46da2157293834813f6746b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _get_package_bin_dir_app_paths(venv: Venv, package_info: PackageInfo, local_bin_dir: Path) -> Set[Path]:\n    suffix = package_info.suffix\n    apps = []\n    if not package_info.include_apps:\n        pass\n    else:\n        apps += package_info.apps\n    if package_info.include_dependencies:\n        apps += package_info.apps_of_dependencies\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    app_paths = set()    app_paths = set()    if not apps:    app_paths = set()    app_paths = set()"]}]}
{"hexsha": "70836ca1748caea3d326c0101f9ea4804dc8b95e", "ext": "py", "lang": "Python", "content": "def save_3D_animation(embeddings, emb_space_sizes, train_losses, test_losses, opt_name, n_bins=10, horizon_size=10, cmap_name='jet', **plotting_kwargs):\n    \"\"\"Utility function for visualizing the changes in weights over time in\n    UMAP space. The visualization is in 3D for better appreciating the descent\n    on the error surface.\n\n        Args:\n            - embeddings: list of embeddings, result of alligned UMAP\n            - emb_space_sizes: list of arrays, define the limits of the\n                embedding space for the three layers of the MLP.\n            - train_losses: list, training losses history.\n            - test_losses: list, test losses.\n            - opt_name: string, name of the optimizer used.\n            - n_bins: int, number of bins for discretizing the training loss.\n            -  horizon_size: int, maximum number of points simultaneously\n                on screen.\n            - cmap_name: string, name of the colormap used for representing\n                the change in train losses.\n            - **plotting_kwargs: keyword arguments, keyword arguments for the\n                plotting function.\n\n        Returns:\n            - None\n    \"\"\"\n    discretizer = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy='uniform')\n    cmap = matplotlib.cm.get_cmap(cmap_name)\n    colors = np.array(train_losses)\n    colors = discretizer.fit_transform(colors.reshape(-1, 1)).flatten()\n    norm = plt.Normalize(colors.min(), colors.max())\n    for i in tqdm(range(embeddings[0].shape[0])):\n        fig, axs = plt.subplots(1, 3, figsize=(30, 10), subplot_kw=dict(projection='3d'))\n        for index, emb in enumerate(embeddings):\n            min_sizes, max_sizes = emb_space_sizes[index]\n            past_horizon = max(0, i - horizon_size)\n            axs[index].scatter(emb[past_horizon:i, 0], emb[past_horizon:i, 1], train_losses[past_horizon:i], c=[cmap(norm(color)) for color in colors[past_horizon:i]], **plotting_kwargs)\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=train_losses[past_horizon:i], c='grey', zdir='y', zs=max_sizes[1], linewidth=5, alpha=0.25)\n            axs[index].plot(xs=emb[past_horizon:i, 1], ys=train_losses[past_horizon:i], c='grey', zdir='x', linewidth=5, alpha=0.25, zs=min_sizes[0])\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=emb[past_horizon:i, 1], c='grey', zdir='z', linewidth=5, alpha=0.25, zs=min_sizes[2])\n            axs[index].text2D(0.05, 0.95, f'Layer {index + 1}', transform=axs[index].transAxes)\n            if not index == 1:\n                if index == 2:\n                    axs[index].set_xlabel('Weights Space \\n UMAP 1')\n                    axs[index].set_ylabel('Weights Space \\n UMAP 2')\n                    axs[index].set_zlabel('Trainining Loss')\n            else:\n                axs[index].text2D(0.5, 1.1, f'Optimizer: {opt_name}                     \\nTrain Loss: {round(train_losses[i], 3)}                     \\n Test Loss: {round(test_losses[i], 3)}', transform=axs[index].transAxes)\n        if not os.path.exists(f'results\\\\3D_{opt_name}'):\n            os.makedirs(f'results\\\\3D_{opt_name}')\n        plt.savefig(f'results\\\\3D_{opt_name}\\\\{i}.png', bbox_inches='tight')\n        plt.close('all')\n    return None", "fn_id": 0, "class_fn": false, "repo": "vb690/machine_learning_exercises", "file": "shops/visualize_gradient_descent/utilities/viz_utils.py", "last_update_at": "2021-04-26T19:06:06+00:00", "original_content": "def save_3D_animation(embeddings, emb_space_sizes, train_losses, test_losses, opt_name, n_bins=10, horizon_size=10, cmap_name='jet', **plotting_kwargs):\n    \"\"\"Utility function for visualizing the changes in weights over time in\n    UMAP space. The visualization is in 3D for better appreciating the descent\n    on the error surface.\n\n        Args:\n            - embeddings: list of embeddings, result of alligned UMAP\n            - emb_space_sizes: list of arrays, define the limits of the\n                embedding space for the three layers of the MLP.\n            - train_losses: list, training losses history.\n            - test_losses: list, test losses.\n            - opt_name: string, name of the optimizer used.\n            - n_bins: int, number of bins for discretizing the training loss.\n            -  horizon_size: int, maximum number of points simultaneously\n                on screen.\n            - cmap_name: string, name of the colormap used for representing\n                the change in train losses.\n            - **plotting_kwargs: keyword arguments, keyword arguments for the\n                plotting function.\n\n        Returns:\n            - None\n    \"\"\"\n    discretizer = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy='uniform')\n    cmap = matplotlib.cm.get_cmap(cmap_name)\n    colors = np.array(train_losses)\n    colors = discretizer.fit_transform(colors.reshape(-1, 1)).flatten()\n    norm = plt.Normalize(colors.min(), colors.max())\n    for i in tqdm(range(embeddings[0].shape[0])):\n        fig, axs = plt.subplots(1, 3, figsize=(30, 10), subplot_kw=dict(projection='3d'))\n        for index, emb in enumerate(embeddings):\n            min_sizes, max_sizes = emb_space_sizes[index]\n            past_horizon = max(0, i - horizon_size)\n            axs[index].scatter(emb[past_horizon:i, 0], emb[past_horizon:i, 1], train_losses[past_horizon:i], c=[cmap(norm(color)) for color in colors[past_horizon:i]], **plotting_kwargs)\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=train_losses[past_horizon:i], c='grey', zdir='y', zs=max_sizes[1], linewidth=5, alpha=0.25)\n            axs[index].plot(xs=emb[past_horizon:i, 1], ys=train_losses[past_horizon:i], c='grey', zdir='x', linewidth=5, alpha=0.25, zs=min_sizes[0])\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=emb[past_horizon:i, 1], c='grey', zdir='z', linewidth=5, alpha=0.25, zs=min_sizes[2])\n            axs[index].text2D(0.05, 0.95, f'Layer {index + 1}', transform=axs[index].transAxes)\n            if index == 1:\n                axs[index].text2D(0.5, 1.1, f'Optimizer: {opt_name}                     \\nTrain Loss: {round(train_losses[i], 3)}                     \\n Test Loss: {round(test_losses[i], 3)}', transform=axs[index].transAxes)\n            elif index == 2:\n                axs[index].set_xlabel('Weights Space \\n UMAP 1')\n                axs[index].set_ylabel('Weights Space \\n UMAP 2')\n                axs[index].set_zlabel('Trainining Loss')\n        if not os.path.exists(f'results\\\\3D_{opt_name}'):\n            os.makedirs(f'results\\\\3D_{opt_name}')\n        plt.savefig(f'results\\\\3D_{opt_name}\\\\{i}.png', bbox_inches='tight')\n        plt.close('all')\n    return None", "refactored": true, "question_id": "70836ca1748caea3d326c0101f9ea4804dc8b95e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def save_3D_animation(embeddings, emb_space_sizes, train_losses, test_losses, opt_name, n_bins=10, horizon_size=10, cmap_name='jet', **plotting_kwargs):\n    \"\"\"Utility function for visualizing the changes in weights over time in\n    UMAP space. The visualization is in 3D for better appreciating the descent\n    on the error surface.\n        Args:\n            - embeddings: list of embeddings, result of alligned UMAP\n            - emb_space_sizes: list of arrays, define the limits of the\n                embedding space for the three layers of the MLP.\n            - train_losses: list, training losses history.\n            - test_losses: list, test losses.\n            - opt_name: string, name of the optimizer used.\n            - n_bins: int, number of bins for discretizing the training loss.\n            -  horizon_size: int, maximum number of points simultaneously\n                on screen.\n            - cmap_name: string, name of the colormap used for representing\n                the change in train losses.\n            - **plotting_kwargs: keyword arguments, keyword arguments for the\n                plotting function.\n        Returns:\n            - None\n    \"\"\"\n    discretizer = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy='uniform')\n    cmap = matplotlib.cm.get_cmap(cmap_name)\n    colors = np.array(train_losses)\n    colors = discretizer.fit_transform(colors.reshape(-1, 1)).flatten()\n    norm = plt.Normalize(colors.min(), colors.max())\n    for i in tqdm(range(embeddings[0].shape[0])):\n        fig, axs = plt.subplots(1, 3, figsize=(30, 10), subplot_kw=dict(projection='3d'))\n        for index, emb in enumerate(embeddings):\n            min_sizes, max_sizes = emb_space_sizes[index]\n            past_horizon = max(0, i - horizon_size)\n            axs[index].scatter(emb[past_horizon:i, 0], emb[past_horizon:i, 1], train_losses[past_horizon:i], c=[cmap(norm(color)) for color in colors[past_horizon:i]], **plotting_kwargs)\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=train_losses[past_horizon:i], c='grey', zdir='y', zs=max_sizes[1], linewidth=5, alpha=0.25)\n            axs[index].plot(xs=emb[past_horizon:i, 1], ys=train_losses[past_horizon:i], c='grey', zdir='x', linewidth=5, alpha=0.25, zs=min_sizes[0])\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=emb[past_horizon:i, 1], c='grey', zdir='z', linewidth=5, alpha=0.25, zs=min_sizes[2])\n            axs[index].text2D(0.05, 0.95, f'Layer {index + 1}', transform=axs[index].transAxes)\n            if not index == 1:\n                if index == 2:\n                    axs[index].set_xlabel('Weights Space \\n UMAP 1')\n                    axs[index].set_ylabel('Weights Space \\n UMAP 2')\n                    axs[index].set_zlabel('Trainining Loss')\n            else:\n                axs[index].text2D(0.5, 1.1, f'Optimizer: {opt_name}                     \\nTrain Loss: {round(train_losses[i], 3)}                     \\n Test Loss: {round(test_losses[i], 3)}', transform=axs[index].transAxes)\n        if not os.path.exists(f'results\\\\3D_{opt_name}'):\n            os.makedirs(f'results\\\\3D_{opt_name}')\n        plt.savefig(f'results\\\\3D_{opt_name}\\\\{i}.png', bbox_inches='tight')\n        plt.close('all')\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return None    return None    return None    return None"]}]}
{"hexsha": "ac18a96ded8e760d6d2a171c418c6b63db8231ef", "ext": "py", "lang": "Python", "content": "def init_estimators_train(columns, null_value, no_compression=False):\n    if not no_compression:\n        res = [NoCompressionEstimatorTrain(columns, null_value), DictEstimatorTrain(columns, null_value, max_dict_size), RleEstimatorTrain(columns, null_value), ForEstimatorTrain(columns, null_value)]\n    else:\n        res = [NoCompressionEstimatorTrain(columns, null_value)]\n    return res", "fn_id": 1, "class_fn": false, "repo": "bogdanghita/whitebox-compression", "file": "evaluation/theoretical_evaluation.py", "last_update_at": "2021-12-28T05:31:03+00:00", "original_content": "def init_estimators_train(columns, null_value, no_compression=False):\n    if no_compression:\n        res = [NoCompressionEstimatorTrain(columns, null_value)]\n    else:\n        res = [NoCompressionEstimatorTrain(columns, null_value), DictEstimatorTrain(columns, null_value, max_dict_size), RleEstimatorTrain(columns, null_value), ForEstimatorTrain(columns, null_value)]\n    return res", "refactored": true, "question_id": "ac18a96ded8e760d6d2a171c418c6b63db8231ef_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def init_estimators_train(columns, null_value, no_compression=False):\n    if not no_compression:\n        res = [NoCompressionEstimatorTrain(columns, null_value), DictEstimatorTrain(columns, null_value, max_dict_size), RleEstimatorTrain(columns, null_value), ForEstimatorTrain(columns, null_value)]\n    else:\n        res = [NoCompressionEstimatorTrain(columns, null_value)]\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return res    return res    return res    return res    return res"]}]}
{"hexsha": "3546a7402fd9a0f1b6c55afe3610cdd62558560c", "ext": "py", "lang": "Python", "content": "def __get_stock_bar(code, start, end, freq):\n    df = None\n    _start = start.format()\n    _end = end.format()\n    if freq == util.FREQ_DAY or freq == util.FREQ_WEEK or freq == util.FREQ_MONTH:\n        covert = {util.FREQ_DAY: 'D', util.FREQ_WEEK: 'W', util.FREQ_MONTH: 'M'}\n        df = ts.get_stock_bar(code=code, start=_start, end=_end, freq=covert[freq], factors=['vr', 'tor'])\n    else:\n        covert = {util.FREQ_1M: '1MIN', util.FREQ_5M: '5MIN', util.FREQ_15M: '15MIN', util.FREQ_30M: '30MIN'}\n        df = ts.tushare_bar(code=code, start=_start, end=_end, freq=covert[freq], factors=['vr', 'tor'])\n    if not not isinstance(df, pd.DataFrame):\n        if df.empty:\n            log.warn('%s from %s to %s bar[%s] is empty' % (code, start, end, freq))\n    else:\n        raise TypeError('df is unknown type %s' % type(df))\n    return df", "fn_id": 3, "class_fn": false, "repo": "lijielife/carp", "file": "carp/request.py", "last_update_at": "2021-03-02T15:48:57+00:00", "original_content": "def __get_stock_bar(code, start, end, freq):\n    df = None\n    _start = start.format()\n    _end = end.format()\n    if freq == util.FREQ_DAY or freq == util.FREQ_WEEK or freq == util.FREQ_MONTH:\n        covert = {util.FREQ_DAY: 'D', util.FREQ_WEEK: 'W', util.FREQ_MONTH: 'M'}\n        df = ts.get_stock_bar(code=code, start=_start, end=_end, freq=covert[freq], factors=['vr', 'tor'])\n    else:\n        covert = {util.FREQ_1M: '1MIN', util.FREQ_5M: '5MIN', util.FREQ_15M: '15MIN', util.FREQ_30M: '30MIN'}\n        df = ts.tushare_bar(code=code, start=_start, end=_end, freq=covert[freq], factors=['vr', 'tor'])\n    if not isinstance(df, pd.DataFrame):\n        raise TypeError('df is unknown type %s' % type(df))\n    elif df.empty:\n        log.warn('%s from %s to %s bar[%s] is empty' % (code, start, end, freq))\n    return df", "refactored": true, "question_id": "3546a7402fd9a0f1b6c55afe3610cdd62558560c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def __get_stock_bar(code, start, end, freq):\n    df = None\n    _start = start.format()\n    _end = end.format()\n    if freq == util.FREQ_DAY or freq == util.FREQ_WEEK or freq == util.FREQ_MONTH:\n        covert = {util.FREQ_DAY: 'D', util.FREQ_WEEK: 'W', util.FREQ_MONTH: 'M'}\n        df = ts.get_stock_bar(code=code, start=_start, end=_end, freq=covert[freq], factors=['vr', 'tor'])\n    else:\n        covert = {util.FREQ_1M: '1MIN', util.FREQ_5M: '5MIN', util.FREQ_15M: '15MIN', util.FREQ_30M: '30MIN'}\n        df = ts.tushare_bar(code=code, start=_start, end=_end, freq=covert[freq], factors=['vr', 'tor'])\n    if not not isinstance(df, pd.DataFrame):\n        if df.empty:\n            log.warn('%s from %s to %s bar[%s] is empty' % (code, start, end, freq))\n    else:\n        raise TypeError('df is unknown type %s' % type(df))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return df    return df    return df    return df    return df"]}]}
{"hexsha": "5b2a8ea69b3198b3f678cebb3485c95da3b6d811", "ext": "py", "lang": "Python", "content": "def _graph_from_dict(P, weights=False):\n    G = pairDiGraph()\n    for (a, b), n in P.items():\n        if not weights:\n            G.add_edge(a, b)\n        else:\n            G.add_edge(a, b, weight=n)\n    if weights:\n        G.addPd()\n    return G", "fn_id": 2, "class_fn": false, "repo": "jpgil/logdelay", "file": "src/theory202105.py", "last_update_at": "2021-05-28T16:03:39+00:00", "original_content": "def _graph_from_dict(P, weights=False):\n    G = pairDiGraph()\n    for (a, b), n in P.items():\n        if weights:\n            G.add_edge(a, b, weight=n)\n        else:\n            G.add_edge(a, b)\n    if weights:\n        G.addPd()\n    return G", "refactored": true, "question_id": "5b2a8ea69b3198b3f678cebb3485c95da3b6d811_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _graph_from_dict(P, weights=False):\n    G = pairDiGraph()\n    for (a, b), n in P.items():\n        if not weights:\n            G.add_edge(a, b)\n        else:\n            G.add_edge(a, b, weight=n)\n    if weights:\n        G.addPd()\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return G    return G    return G    return G    return G"]}]}
{"hexsha": "109ffa951504bc25a96cc88a0b6aa9552c14314b", "ext": "py", "lang": "Python", "content": "def _create_nat_match_obj(**kwargs):\n    nat_match_obj = {'ethertype': 'IPv4'}\n    delta = set(kwargs.keys()) - set(MATCH_KEYS)\n    if not delta:\n        pass\n    else:\n        raise Exception(_('Invalid keys for NAT match: %s'), delta)\n    nat_match_obj.update(kwargs)\n    return nat_match_obj", "fn_id": 51, "class_fn": false, "repo": "ericwanghp/quantum", "file": "quantum/plugins/nicira/nicira_nvp_plugin/nvplib.py", "last_update_at": "2021-04-18T15:23:19+00:00", "original_content": "def _create_nat_match_obj(**kwargs):\n    nat_match_obj = {'ethertype': 'IPv4'}\n    delta = set(kwargs.keys()) - set(MATCH_KEYS)\n    if delta:\n        raise Exception(_('Invalid keys for NAT match: %s'), delta)\n    nat_match_obj.update(kwargs)\n    return nat_match_obj", "refactored": true, "question_id": "109ffa951504bc25a96cc88a0b6aa9552c14314b_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _create_nat_match_obj(**kwargs):\n    nat_match_obj = {'ethertype': 'IPv4'}\n    delta = set(kwargs.keys()) - set(MATCH_KEYS)\n    if not delta:\n        pass\n    else:\n        raise Exception(_('Invalid keys for NAT match: %s'), delta)\n    nat_match_obj.update(kwargs)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return nat_match_obj    return nat_match_obj    return nat_match_obj    return nat_match_obj    return nat_match_obj"]}]}
{"hexsha": "00500ee126bf98712c024187bb2a8536d5e82f46", "ext": "py", "lang": "Python", "content": "@login_required\ndef productlist(request):\n    organization = request.user.info.organization\n    if not not hasattr(request.user, 'organization'):\n        pass\n    else:\n        if not hasattr(request.user, 'permissions'):\n            return HttpResponseForbidden('<h1>403 Forbidden</h1>')\n        if request.user.permissions.product_permissions < 1:\n            return HttpResponseForbidden('<h1>403 Forbidden</h1>')\n    products = Product.objects.filter(organization=organization).order_by('-id').annotate(earmarked=Sum('salesinvoiceentry__quantity', filter=Q(salesinvoiceentry__invoice__finalized=0)))\n    productfilter = ProductFilter(request.GET, queryset=products)\n    paginator = Paginator(productfilter.qs, 25)\n    page_number = request.GET.get('page')\n    page_obj = paginator.get_page(page_number)\n    context = {'page_obj': page_obj, 'filter': productfilter}\n    return render(request, 'products/product_list.html', context=context)", "fn_id": 0, "class_fn": false, "repo": "drtweety/busman", "file": "products/views.py", "last_update_at": "2021-06-13T18:12:21+00:00", "original_content": "@login_required\ndef productlist(request):\n    organization = request.user.info.organization\n    if not hasattr(request.user, 'organization'):\n        if not hasattr(request.user, 'permissions'):\n            return HttpResponseForbidden('<h1>403 Forbidden</h1>')\n        if request.user.permissions.product_permissions < 1:\n            return HttpResponseForbidden('<h1>403 Forbidden</h1>')\n    products = Product.objects.filter(organization=organization).order_by('-id').annotate(earmarked=Sum('salesinvoiceentry__quantity', filter=Q(salesinvoiceentry__invoice__finalized=0)))\n    productfilter = ProductFilter(request.GET, queryset=products)\n    paginator = Paginator(productfilter.qs, 25)\n    page_number = request.GET.get('page')\n    page_obj = paginator.get_page(page_number)\n    context = {'page_obj': page_obj, 'filter': productfilter}\n    return render(request, 'products/product_list.html', context=context)", "refactored": true, "question_id": "00500ee126bf98712c024187bb2a8536d5e82f46_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@login_required\ndef productlist(request):\n    organization = request.user.info.organization\n    if not not hasattr(request.user, 'organization'):\n        pass\n    else:\n        if not hasattr(request.user, 'permissions'):\n            return HttpResponseForbidden('<h1>403 Forbidden</h1>')\n        if request.user.permissions.product_permissions < 1:\n            return HttpResponseForbidden('<h1>403 Forbidden</h1>')\n    products = Product.objects.filter(organization=organization).order_by('-id').annotate(earmarked=Sum('salesinvoiceentry__quantity', filter=Q(salesinvoiceentry__invoice__finalized=0)))\n    productfilter = ProductFilter(request.GET, queryset=products)\n    paginator = Paginator(productfilter.qs, 25)\n    page_number = request.GET.get('page')\n    page_obj = paginator.get_page(page_number)\n    context = {'page_obj': page_obj, 'filter': productfilter}\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return render(request, 'products/productlist.html', context)    return render(request, 'productlist.html', context)    return render(request, 'productlist.html', context)    return render(request, 'productlist.html', context)    return render(request, 'productlist.html', context)"]}]}
{"hexsha": "3b40f31f9e2306102a844f470092207c102189e3", "ext": "py", "lang": "Python", "content": "@pb.route('/detail/<id>', methods=['GET', 'POST'])\ndef single_product(id):\n    product = Product.query.filter_by(id=id).first()\n    if not product.out_of_stock == True:\n        status = 'In stock'\n    else:\n        status = 'Sold Out'\n    data = {'id': product.id, 'name': product.name, 'img_url': product.img_url, 'description': product.description, 'seller': User.query.filter_by(id=product.seller_id).first().name, 'seller_id': product.seller_id, 'created': product.created, 'price': product.price, 'status': status, 'seller_img': User.query.filter_by(id=product.seller_id).first().avatar_url}\n    return jsonify(data)", "fn_id": 3, "class_fn": false, "repo": "sori9088/mealplan-server", "file": "app/components/product/__init__.py", "last_update_at": "2021-06-02T00:44:12+00:00", "original_content": "@pb.route('/detail/<id>', methods=['GET', 'POST'])\ndef single_product(id):\n    product = Product.query.filter_by(id=id).first()\n    if product.out_of_stock == True:\n        status = 'Sold Out'\n    else:\n        status = 'In stock'\n    data = {'id': product.id, 'name': product.name, 'img_url': product.img_url, 'description': product.description, 'seller': User.query.filter_by(id=product.seller_id).first().name, 'seller_id': product.seller_id, 'created': product.created, 'price': product.price, 'status': status, 'seller_img': User.query.filter_by(id=product.seller_id).first().avatar_url}\n    return jsonify(data)", "refactored": true, "question_id": "3b40f31f9e2306102a844f470092207c102189e3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@pb.route('/detail/<id>', methods=['GET', 'POST'])\ndef single_product(id):\n    product = Product.query.filter_by(id=id).first()\n    if not product.out_of_stock == True:\n        status = 'In stock'\n    else:\n        status = 'Sold Out'\n    data = {'id': product.id, 'name': product.name, 'img_url': product.img_url, 'description': product.description, 'seller': User.query.filter_by(id=product.seller_id).first().name, 'seller_id': product.seller_id, 'created': product.created, 'price': product.price, 'status': status, 'seller_img': User.query.filter_by(id=product.seller_id).first().avatar_url}\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return render_template('product_detail.html', data=data)    return render_template('product_detail.html', data=data)    return render_template('single_product.html', data=data)    return render_template('detail.html', data=data)    return render_template('detail.html', data=data)"]}]}
{"hexsha": "9a23cc6017e673eb9497903c018a6480ea3f8e60", "ext": "py", "lang": "Python", "content": "def readVDAT(fid, address):\n    vdat = namedtuple('vdat', [])\n    if not address != -1:\n        pass\n    else:\n        fid.seek(address, 0)\n    [dumCRC, lastSize, lastType, dumMisc] = readARDFpointer(fid, -1)\n    vdat.force = struct.unpack('i', fid.read(4))[0]\n    vdat.line = struct.unpack('i', fid.read(4))[0]\n    vdat.point = struct.unpack('i', fid.read(4))[0]\n    vdat.sizeData = struct.unpack('i', fid.read(4))[0]\n    vdat.forceType = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt0 = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt1 = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt2 = struct.unpack('i', fid.read(4))[0]\n    dum = struct.unpack('i' * 2, fid.read(4 * 2))[0]\n    sizeData = vdat.sizeData\n    vdat.data = struct.unpack('f' * sizeData, fid.read(4 * sizeData))\n    return vdat", "fn_id": 6, "class_fn": false, "repo": "yu-efremov/ViscoIndent", "file": "import_ARDF.py", "last_update_at": "2021-12-21T13:26:53+00:00", "original_content": "def readVDAT(fid, address):\n    vdat = namedtuple('vdat', [])\n    if address != -1:\n        fid.seek(address, 0)\n    [dumCRC, lastSize, lastType, dumMisc] = readARDFpointer(fid, -1)\n    vdat.force = struct.unpack('i', fid.read(4))[0]\n    vdat.line = struct.unpack('i', fid.read(4))[0]\n    vdat.point = struct.unpack('i', fid.read(4))[0]\n    vdat.sizeData = struct.unpack('i', fid.read(4))[0]\n    vdat.forceType = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt0 = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt1 = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt2 = struct.unpack('i', fid.read(4))[0]\n    dum = struct.unpack('i' * 2, fid.read(4 * 2))[0]\n    sizeData = vdat.sizeData\n    vdat.data = struct.unpack('f' * sizeData, fid.read(4 * sizeData))\n    return vdat", "refactored": true, "question_id": "9a23cc6017e673eb9497903c018a6480ea3f8e60_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def readVDAT(fid, address):\n    vdat = namedtuple('vdat', [])\n    if not address != -1:\n        pass\n    else:\n        fid.seek(address, 0)\n    [dumCRC, lastSize, lastType, dumMisc] = readARDFpointer(fid, -1)\n    vdat.force = struct.unpack('i', fid.read(4))[0]\n    vdat.line = struct.unpack('i', fid.read(4))[0]\n    vdat.point = struct.unpack('i', fid.read(4))[0]\n    vdat.sizeData = struct.unpack('i', fid.read(4))[0]\n    vdat.forceType = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt0 = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt1 = struct.unpack('i', fid.read(4))[0]\n    vdat.pnt2 = struct.unpack('i', fid.read(4))[0]\n    dum = struct.unpack('i' * 2, fid.read(4 * 2))[0]\n    sizeData = vdat.sizeData\n    vdat.data = struct.unpack('f' * sizeData, fid.read(4 * sizeData))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return vdat    return vdat    return vdat    dumCRC = readARDFpointer(fid, -1)    return vdat"]}]}
{"hexsha": "7cfa76a0e321448c9b715a43fe2ae910c799972c", "ext": "py", "lang": "Python", "content": "def make_summary_file(filename):\n    \"\"\"\n    Given a DLIS file, make a short human readable summary of it.\n    Show things like headers, well parameters and which well curves are\n    available.\n\n    Args:\n    filename: A DLIS file.\n\n    Returns:\n    summaryfile: The DLIS file without the extention and the suffix\n    _summary.txt.\n    \"\"\"\n    summaryfile = open(filename.replace('.DLIS', '_summary.txt'), 'w')\n    f, *f_tail = dlis.load(filename)\n    if not len(f_tail):\n        pass\n    else:\n        print('There are more logical files in tail')\n    origin, *origin_tail = f.origins\n    if len(origin_tail):\n        print(filename + ' contains multiple origins')\n    header = f.fileheader\n    parameter_table = summarize(f.parameters, name='Name', long_name='Long name', values='Value(s)')\n    mask = ~parameter_table['Name'].isin(['R8', 'RR1', 'WITN', 'ENGI'])\n    parameter_table = parameter_table[mask]\n    parameter_table.sort_values('Name')\n    summaryfile.write(str(f.describe()))\n    summaryfile.write(str(origin.describe()))\n    summaryfile.write(str(header.describe()))\n    summaryfile.write(str(parameter_table))\n    for frame in f.frames:\n        index_channel = next((ch for ch in frame.channels if ch.name == frame.index))\n        summaryfile.write(f'\\nFrame {frame.name}:\\n')\n        summaryfile.write(f'Description      : {frame.description}\\n')\n        summaryfile.write(f'Indexed by       : {frame.index_type}\\n')\n        summaryfile.write(f'Interval         : [{frame.index_min}, {frame.index_max}] {index_channel.units}\\n')\n        summaryfile.write(f'Direction        : {frame.direction}\\n')\n        summaryfile.write(f'Constant spacing : {frame.spacing} {index_channel.units}\\n')\n        summaryfile.write(f'Index channel    : {index_channel}\\n')\n        summaryfile.write(f'No. of channels  : {len(frame.channels)}\\n')\n    channel_table = summarize(f.channels, name='Name', long_name='Long name', units='Units', dimension='Dimension', frame='Frame')\n    channel_table.sort_values('Name')\n    summaryfile.write(str(channel_table))\n    summaryfile.close()\n    return summaryfile", "fn_id": 1, "class_fn": false, "repo": "softwareunderground/northern-lights", "file": "scripts/dlis_summary.py", "last_update_at": "2021-04-17T09:13:20+00:00", "original_content": "def make_summary_file(filename):\n    \"\"\"\n    Given a DLIS file, make a short human readable summary of it.\n    Show things like headers, well parameters and which well curves are\n    available.\n\n    Args:\n    filename: A DLIS file.\n\n    Returns:\n    summaryfile: The DLIS file without the extention and the suffix\n    _summary.txt.\n    \"\"\"\n    summaryfile = open(filename.replace('.DLIS', '_summary.txt'), 'w')\n    f, *f_tail = dlis.load(filename)\n    if len(f_tail):\n        print('There are more logical files in tail')\n    origin, *origin_tail = f.origins\n    if len(origin_tail):\n        print(filename + ' contains multiple origins')\n    header = f.fileheader\n    parameter_table = summarize(f.parameters, name='Name', long_name='Long name', values='Value(s)')\n    mask = ~parameter_table['Name'].isin(['R8', 'RR1', 'WITN', 'ENGI'])\n    parameter_table = parameter_table[mask]\n    parameter_table.sort_values('Name')\n    summaryfile.write(str(f.describe()))\n    summaryfile.write(str(origin.describe()))\n    summaryfile.write(str(header.describe()))\n    summaryfile.write(str(parameter_table))\n    for frame in f.frames:\n        index_channel = next((ch for ch in frame.channels if ch.name == frame.index))\n        summaryfile.write(f'\\nFrame {frame.name}:\\n')\n        summaryfile.write(f'Description      : {frame.description}\\n')\n        summaryfile.write(f'Indexed by       : {frame.index_type}\\n')\n        summaryfile.write(f'Interval         : [{frame.index_min}, {frame.index_max}] {index_channel.units}\\n')\n        summaryfile.write(f'Direction        : {frame.direction}\\n')\n        summaryfile.write(f'Constant spacing : {frame.spacing} {index_channel.units}\\n')\n        summaryfile.write(f'Index channel    : {index_channel}\\n')\n        summaryfile.write(f'No. of channels  : {len(frame.channels)}\\n')\n    channel_table = summarize(f.channels, name='Name', long_name='Long name', units='Units', dimension='Dimension', frame='Frame')\n    channel_table.sort_values('Name')\n    summaryfile.write(str(channel_table))\n    summaryfile.close()\n    return summaryfile", "refactored": true, "question_id": "7cfa76a0e321448c9b715a43fe2ae910c799972c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def make_summary_file(filename):\n    \"\"\"\n    Given a DLIS file, make a short human readable summary of it.\n    Show things like headers, well parameters and which well curves are\n    available.\n    Args:\n    filename: A DLIS file.\n    Returns:\n    summaryfile: The DLIS file without the extention and the suffix\n    _summary.txt.\n    \"\"\"\n    summaryfile = open(filename.replace('.DLIS', '_summary.txt'), 'w')\n    f, *f_tail = dlis.load(filename)\n    if not len(f_tail):\n        pass\n    else:\n        print('There are more logical files in tail')\n    origin, *origin_tail = f.origins\n    if len(origin_tail):\n        print(filename + ' contains multiple origins')\n    header = f.fileheader\n    parameter_table = summarize(f.parameters, name='Name', long_name='Long name', values='Value(s)')\n    mask = ~parameter_table['Name'].isin(['R8', 'RR1', 'WITN', 'ENGI'])\n    parameter_table = parameter_table[mask]\n    parameter_table.sort_values('Name')\n    summaryfile.write(str(f.describe()))\n    summaryfile.write(str(origin.describe()))\n    summaryfile.write(str(header.describe()))\n    summaryfile.write(str(parameter_table))\n    for frame in f.frames:\n        index_channel = next((ch for ch in frame.channels if ch.name == frame.index))\n        summaryfile.write(f'\\nFrame {frame.name}:\\n')\n        summaryfile.write(f'Description      : {frame.description}\\n')\n        summaryfile.write(f'Indexed by       : {frame.index_type}\\n')\n        summaryfile.write(f'Interval         : [{frame.index_min}, {frame.index_max}] {index_channel.units}\\n')\n        summaryfile.write(f'Direction        : {frame.direction}\\n')\n        summaryfile.write(f'Constant spacing : {frame.spacing} {index_channel.units}\\n')\n        summaryfile.write(f'Index channel    : {index_channel}\\n')\n        summaryfile.write(f'No. of channels  : {len(frame.channels)}\\n')\n    channel_table = summarize(f.channels, name='Name', long_name='Long name', units='Units', dimension='Dimension', frame='Frame')\n    channel_table.sort_values('Name')\n    summaryfile.write(str(channel_table))\n    summaryfile.close()\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return summaryfile    return summaryfile    return summaryfile    return summaryfile    return summaryfile"]}]}
{"hexsha": "a2ffeaa240b71382db18bba9227270f5573e50fb", "ext": "py", "lang": "Python", "content": "@Transform_Wrapper()\ndef Annotate_Script_Names(empty_diffs=0):\n    \"\"\"\n    For every ai script, annotate the pilot entity with the name\n    of the script running.\n    \"\"\"\n    aiscript_files = Load_Files('aiscripts/*.xml')\n    for game_file in aiscript_files:\n        xml_root = game_file.Get_Root()\n        changed = False\n        for tag in ['dock_masstraffic_drone', 'execute_custom_trade', 'execute_trade', 'move_approach_path', 'move_docking', 'move_undocking', 'move_gate', 'move_navmesh', 'move_strafe', 'move_target_points', 'move_waypoints', 'move_to', 'detach_from_masstraffic', 'wait_for_prev_script', 'wait']:\n            nodes = xml_root.xpath('.//{}'.format(tag))\n            if not nodes:\n                continue\n            changed = True\n            if empty_diffs:\n                continue\n            for node in nodes:\n                script_name = etree.Element('set_value', name='this.$script_name', exact=\"'{}'\".format(game_file.name.replace('.xml', '')))\n                node.addprevious(script_name)\n                element_name = etree.Element('set_value', name='this.$element_name', exact=\"'{}'\".format(tag))\n                node.addprevious(element_name)\n                if not node.sourceline:\n                    pass\n                else:\n                    name_line = \"'${} {}'\".format(game_file.name.replace('.xml', ''), node.sourceline)\n                    script_line_node = etree.Element('set_value', name='this.$script_line_name', exact=name_line)\n                    node.addprevious(script_line_node)\n                    record_group = [etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts?\">\\n                              <set_value name=\"this.$script_line_counts\" exact=\"table[]\"/>\\n                            </do_if>'), etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts.{FIELD}?\">\\n                              <set_value name=\"this.$script_line_counts.{FIELD}\" exact=\"0.0\"/>\\n                            </do_if>'.replace('FIELD', name_line)), etree.fromstring('\\n                            <set_value name=\"this.$script_line_counts.{FIELD}\" operation=\"add\"/>'.replace('FIELD', name_line))]\n                    for record_node in record_group:\n                        node.addprevious(record_node)\n        if changed:\n            game_file.Update_Root(xml_root)\n    return", "fn_id": 1, "class_fn": false, "repo": "abouquet/x4-projects", "file": "extensions/sn_measure_perf/Customizer_Script.py", "last_update_at": "2021-03-17T13:54:15+00:00", "original_content": "@Transform_Wrapper()\ndef Annotate_Script_Names(empty_diffs=0):\n    \"\"\"\n    For every ai script, annotate the pilot entity with the name\n    of the script running.\n    \"\"\"\n    aiscript_files = Load_Files('aiscripts/*.xml')\n    for game_file in aiscript_files:\n        xml_root = game_file.Get_Root()\n        changed = False\n        for tag in ['dock_masstraffic_drone', 'execute_custom_trade', 'execute_trade', 'move_approach_path', 'move_docking', 'move_undocking', 'move_gate', 'move_navmesh', 'move_strafe', 'move_target_points', 'move_waypoints', 'move_to', 'detach_from_masstraffic', 'wait_for_prev_script', 'wait']:\n            nodes = xml_root.xpath('.//{}'.format(tag))\n            if not nodes:\n                continue\n            changed = True\n            if empty_diffs:\n                continue\n            for node in nodes:\n                script_name = etree.Element('set_value', name='this.$script_name', exact=\"'{}'\".format(game_file.name.replace('.xml', '')))\n                node.addprevious(script_name)\n                element_name = etree.Element('set_value', name='this.$element_name', exact=\"'{}'\".format(tag))\n                node.addprevious(element_name)\n                if node.sourceline:\n                    name_line = \"'${} {}'\".format(game_file.name.replace('.xml', ''), node.sourceline)\n                    script_line_node = etree.Element('set_value', name='this.$script_line_name', exact=name_line)\n                    node.addprevious(script_line_node)\n                    record_group = [etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts?\">\\n                              <set_value name=\"this.$script_line_counts\" exact=\"table[]\"/>\\n                            </do_if>'), etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts.{FIELD}?\">\\n                              <set_value name=\"this.$script_line_counts.{FIELD}\" exact=\"0.0\"/>\\n                            </do_if>'.replace('FIELD', name_line)), etree.fromstring('\\n                            <set_value name=\"this.$script_line_counts.{FIELD}\" operation=\"add\"/>'.replace('FIELD', name_line))]\n                    for record_node in record_group:\n                        node.addprevious(record_node)\n        if changed:\n            game_file.Update_Root(xml_root)\n    return", "refactored": true, "question_id": "a2ffeaa240b71382db18bba9227270f5573e50fb_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Transform_Wrapper()\ndef Annotate_Script_Names(empty_diffs=0):\n    \"\"\"\n    For every ai script, annotate the pilot entity with the name\n    of the script running.\n    \"\"\"\n    aiscript_files = Load_Files('aiscripts/*.xml')\n    for game_file in aiscript_files:\n        xml_root = game_file.Get_Root()\n        changed = False\n        for tag in ['dock_masstraffic_drone', 'execute_custom_trade', 'execute_trade', 'move_approach_path', 'move_docking', 'move_undocking', 'move_gate', 'move_navmesh', 'move_strafe', 'move_target_points', 'move_waypoints', 'move_to', 'detach_from_masstraffic', 'wait_for_prev_script', 'wait']:\n            nodes = xml_root.xpath('.//{}'.format(tag))\n            if not nodes:\n                continue\n            changed = True\n            if empty_diffs:\n                continue\n            for node in nodes:\n                script_name = etree.Element('set_value', name='this.$script_name', exact=\"'{}'\".format(game_file.name.replace('.xml', '')))\n                node.addprevious(script_name)\n                element_name = etree.Element('set_value', name='this.$element_name', exact=\"'{}'\".format(tag))\n                node.addprevious(element_name)\n                if not node.sourceline:\n                    pass\n                else:\n                    name_line = \"'${} {}'\".format(game_file.name.replace('.xml', ''), node.sourceline)\n                    script_line_node = etree.Element('set_value', name='this.$script_line_name', exact=name_line)\n                    node.addprevious(script_line_node)\n                    record_group = [etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts?\">\\n                              <set_value name=\"this.$script_line_counts\" exact=\"table[]\"/>\\n                            </do_if>'), etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts.{FIELD}?\">\\n                              <set_value name=\"this.$script_line_counts.{FIELD}\" exact=\"0.0\"/>\\n                            </do_if>'.replace('FIELD', name_line)), etree.fromstring('\\n                            <set_value name=\"this.$script_line_counts.{FIELD}\" operation=\"add\"/>'.replace('FIELD', name_line))]\n                    for record_node in record_group:\n                        node.addprevious(record_node)\n        if changed:\n            game_file.Update_Root(xml_root)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return aiscript_files    return aiscript_files    return aiscript_files    return aiscript_files    return aiscript_files"]}]}
{"hexsha": "b97e6f9295654f19c6ba8f5fa580dfd29d44c69e", "ext": "py", "lang": "Python", "content": "def edit_seller_selector(brief, sellers_to_invite):\n    if brief.lot.slug != 'atm' and sellers_to_invite:\n        seller_selector = brief.data.get('sellerSelector', '')\n        if not (len(sellers_to_invite.keys()) > 0 and seller_selector and (seller_selector == 'oneSeller')):\n            pass\n        else:\n            brief.data['sellerSelector'] = 'someSellers'", "fn_id": 5, "class_fn": false, "repo": "ArenaNetworks/dto-digitalmarketplace-api", "file": "app/api/business/brief/brief_edit_business.py", "last_update_at": "2021-08-23T06:05:06+00:00", "original_content": "def edit_seller_selector(brief, sellers_to_invite):\n    if brief.lot.slug != 'atm' and sellers_to_invite:\n        seller_selector = brief.data.get('sellerSelector', '')\n        if len(sellers_to_invite.keys()) > 0 and seller_selector and (seller_selector == 'oneSeller'):\n            brief.data['sellerSelector'] = 'someSellers'", "refactored": true, "question_id": "b97e6f9295654f19c6ba8f5fa580dfd29d44c69e_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def edit_seller_selector(brief, sellers_to_invite):\n    if brief.lot.slug != 'atm' and sellers_to_invite:\n        seller_selector = brief.data.get('sellerSelector', '')\n        if not (len(sellers_to_invite.keys()) > 0 and seller_selector and (seller_selector == 'oneSeller')):\n            pass\n        else:\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n            raise ValidationError('You must select a seller to invite')            raise ValidationError('You cannot edit the seller selector for this brief')            raise ValidationError(\"You can't edit the seller selector for this brief\")            raise ValidationError('sellerSelector', 'You must select a seller to invite')            raise ValidationError('You cannot edit the seller selector for this brief')"]}]}
{"hexsha": "1380364880e72805de31c21c228ab7d9dbd45947", "ext": "py", "lang": "Python", "content": "def update_activity_notice_seed_date_of_notice_earlier_than_update_window(activity_notice_seed):\n    status = ''\n    success = True\n    activity_notice_seed_changed = False\n    from activity.models import get_lifespan_of_seed\n    lifespan_of_seed_in_seconds = get_lifespan_of_seed(activity_notice_seed.kind_of_seed)\n    earliest_date_of_notice = now() - timedelta(seconds=lifespan_of_seed_in_seconds)\n    if not activity_notice_seed.date_of_notice < earliest_date_of_notice:\n        pass\n    else:\n        try:\n            activity_notice_seed.date_of_notice_earlier_than_update_window = True\n            activity_notice_seed.save()\n            activity_notice_seed_changed = True\n            status += 'DATE_OF_NOTICE_EARLIER_THAN_UPDATE_WINDOW_SET_TRUE '\n        except Exception as e:\n            status += 'COULD_NOT_UPDATE-date_of_notice_earlier_than_update_window: ' + str(e) + ' '\n            success = False\n    results = {'success': success, 'status': status, 'activity_notice_seed': activity_notice_seed, 'activity_notice_seed_changed': activity_notice_seed_changed, 'date_of_notice_earlier_than_update_window': activity_notice_seed.date_of_notice_earlier_than_update_window}\n    return results", "fn_id": 24, "class_fn": false, "repo": "aucoeur/WeVoteServer", "file": "activity/controllers.py", "last_update_at": "2021-03-17T02:08:26+00:00", "original_content": "def update_activity_notice_seed_date_of_notice_earlier_than_update_window(activity_notice_seed):\n    status = ''\n    success = True\n    activity_notice_seed_changed = False\n    from activity.models import get_lifespan_of_seed\n    lifespan_of_seed_in_seconds = get_lifespan_of_seed(activity_notice_seed.kind_of_seed)\n    earliest_date_of_notice = now() - timedelta(seconds=lifespan_of_seed_in_seconds)\n    if activity_notice_seed.date_of_notice < earliest_date_of_notice:\n        try:\n            activity_notice_seed.date_of_notice_earlier_than_update_window = True\n            activity_notice_seed.save()\n            activity_notice_seed_changed = True\n            status += 'DATE_OF_NOTICE_EARLIER_THAN_UPDATE_WINDOW_SET_TRUE '\n        except Exception as e:\n            status += 'COULD_NOT_UPDATE-date_of_notice_earlier_than_update_window: ' + str(e) + ' '\n            success = False\n    results = {'success': success, 'status': status, 'activity_notice_seed': activity_notice_seed, 'activity_notice_seed_changed': activity_notice_seed_changed, 'date_of_notice_earlier_than_update_window': activity_notice_seed.date_of_notice_earlier_than_update_window}\n    return results", "refactored": true, "question_id": "1380364880e72805de31c21c228ab7d9dbd45947_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def update_activity_notice_seed_date_of_notice_earlier_than_update_window(activity_notice_seed):\n    status = ''\n    success = True\n    activity_notice_seed_changed = False\n    from activity.models import get_lifespan_of_seed\n    lifespan_of_seed_in_seconds = get_lifespan_of_seed(activity_notice_seed.kind_of_seed)\n    earliest_date_of_notice = now() - timedelta(seconds=lifespan_of_seed_in_seconds)\n    if not activity_notice_seed.date_of_notice < earliest_date_of_notice:\n        pass\n    else:\n        try:\n            activity_notice_seed.date_of_notice_earlier_than_update_window = True\n            activity_notice_seed.save()\n            activity_notice_seed_changed = True\n            status += 'DATE_OF_NOTICE_EARLIER_THAN_UPDATE_WINDOW_SET_TRUE '\n        except Exception as e:\n            status += 'COULD_NOT_UPDATE-date_of_notice_earlier_than_update_window: ' + str(e) + ' '\n            success = False\n    results = {'success': success, 'status': status, 'activity_notice_seed': activity_notice_seed, 'activity_notice_seed_changed': activity_notice_seed_changed, 'date_of_notice_earlier_than_update_window': activity_notice_seed.date_of_notice_earlier_than_update_window}\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return results    return results    return results    return results    return results"]}]}
{"hexsha": "6f8e9b82a7e7f7ef2e5696e6e11a9da88873c108", "ext": "py", "lang": "Python", "content": "@app.route('/ext/<api_key>/new_session/<session_name>', methods=['POST'])\ndef ext_create_new_session_name(api_key, session_name):\n    logging.debug('EXTERNAL: Create new Session with name')\n    db = Database()\n    user = db.get_user_by_api_key(api_key)\n    if user is None:\n        return (\"Provided API key ('{}') is not associated with any registered user\".format(api_key), HTTPStatus.UNAUTHORIZED.value)\n    if not db.does_session_name_exist(session_name):\n        pass\n    else:\n        return (\"Provided session name ('{}') already exists\".format(session_name), HTTPStatus.UNAUTHORIZED.value)\n    logging.debug('Creating new session: %s (userid: %s)', session_name, user['user_id'])\n    session_id = db.create_session(session_name, user['user_id'])\n    logging.debug('New session id: %s', session_id)\n    set_current_session(session_id, session_name)\n    return \"New Session ID: '{}'\".format(session_id)", "fn_id": 2, "class_fn": false, "repo": "Samiasa/UsabilityConsole", "file": "console/routes/external.py", "last_update_at": "2021-06-07T17:15:42+00:00", "original_content": "@app.route('/ext/<api_key>/new_session/<session_name>', methods=['POST'])\ndef ext_create_new_session_name(api_key, session_name):\n    logging.debug('EXTERNAL: Create new Session with name')\n    db = Database()\n    user = db.get_user_by_api_key(api_key)\n    if user is None:\n        return (\"Provided API key ('{}') is not associated with any registered user\".format(api_key), HTTPStatus.UNAUTHORIZED.value)\n    if db.does_session_name_exist(session_name):\n        return (\"Provided session name ('{}') already exists\".format(session_name), HTTPStatus.UNAUTHORIZED.value)\n    logging.debug('Creating new session: %s (userid: %s)', session_name, user['user_id'])\n    session_id = db.create_session(session_name, user['user_id'])\n    logging.debug('New session id: %s', session_id)\n    set_current_session(session_id, session_name)\n    return \"New Session ID: '{}'\".format(session_id)", "refactored": true, "question_id": "6f8e9b82a7e7f7ef2e5696e6e11a9da88873c108_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@app.route('/ext/<api_key>/new_session/<session_name>', methods=['POST'])\ndef ext_create_new_session_name(api_key, session_name):\n    logging.debug('EXTERNAL: Create new Session with name')\n    db = Database()\n    user = db.get_user_by_api_key(api_key)\n    if user is None:\n        return (\"Provided API key ('{}') is not associated with any registered user\".format(api_key), HTTPStatus.UNAUTHORIZED.value)\n    if not db.does_session_name_exist(session_name):\n        pass\n    else:\n        return (\"Provided session name ('{}') already exists\".format(session_name), HTTPStatus.UNAUTHORIZED.value)\n    logging.debug('Creating new session: %s (userid: %s)', session_name, user['user_id'])\n    session_id = db.create_session(session_name, user['user_id'])\n    logging.debug('New session id: %s', session_id)\n    set_current_session(session_id, session_name)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return jsonify({'session_id': session_id, 'session_name': session_name})    return jsonify({'session_id': session_id, 'session_name': session_name})    return (\"Session '{}' created successfully\".format(session_name), HTTPStatus.OK.value)    return jsonify({'session_id': session_id, 'session_name': session_name})    return ('', HTTPStatus.OK.value)"]}]}
{"hexsha": "b41186cab3d777d1b3f6deea4852d5203576ebc3", "ext": "py", "lang": "Python", "content": "def say(text):\n    hash = hashlib.md5(text.encode()).hexdigest()\n    file = 'speech-cache/{}.wav'.format(hash)\n    cmd = 'play {}'.format(file)\n    if not not os.path.isfile(file):\n        pass\n    else:\n        cmd = 'pico2wave -w {} \"{}\" && {}'.format(file, text, cmd)\n    os.system(cmd)", "fn_id": 3, "class_fn": false, "repo": "yousefamar/sanctum", "file": "sanctum.py", "last_update_at": "2021-01-17T00:14:06+00:00", "original_content": "def say(text):\n    hash = hashlib.md5(text.encode()).hexdigest()\n    file = 'speech-cache/{}.wav'.format(hash)\n    cmd = 'play {}'.format(file)\n    if not os.path.isfile(file):\n        cmd = 'pico2wave -w {} \"{}\" && {}'.format(file, text, cmd)\n    os.system(cmd)", "refactored": true, "question_id": "b41186cab3d777d1b3f6deea4852d5203576ebc3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def say(text):\n    hash = hashlib.md5(text.encode()).hexdigest()\n    file = 'speech-cache/{}.wav'.format(hash)\n    cmd = 'play {}'.format(file)\n    if not not os.path.isfile(file):\n        pass\n    else:\n        cmd = 'pico2wave -w {} \"{}\" && {}'.format(file, text, cmd)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    os.system(cmd)    os.system(cmd)    os.system(cmd)    os.system(cmd)    os.system(cmd)"]}]}
{"hexsha": "8b2fa9137563469049632eeb151af101a87de1b0", "ext": "py", "lang": "Python", "content": "@client.event\nasync def on_message(message):\n    if message.author == client.user:\n        if message.content == 'Authentication invalid':\n            await renew_auth(message)\n        return\n    if not message.content.startswith('>'):\n        pass\n    else:\n        return\n        await parse(message)\n    if isinstance(message.channel, discord.channel.DMChannel):\n        if message.content == 'quit':\n            await do_quit(message)\n        if message.content == 'test':\n            return\n            await do_tests(message)\n        if message.content == 'renew' or message.content == 'reset':\n            await renew_auth(message)\n    if message.content.startswith('/'):\n        await client.process_commands(message)", "fn_id": 5, "class_fn": false, "repo": "joshmiller17/venntbot", "file": "venntbot.py", "last_update_at": "2021-09-11T23:15:38+00:00", "original_content": "@client.event\nasync def on_message(message):\n    if message.author == client.user:\n        if message.content == 'Authentication invalid':\n            await renew_auth(message)\n        return\n    if message.content.startswith('>'):\n        return\n        await parse(message)\n    if isinstance(message.channel, discord.channel.DMChannel):\n        if message.content == 'quit':\n            await do_quit(message)\n        if message.content == 'test':\n            return\n            await do_tests(message)\n        if message.content == 'renew' or message.content == 'reset':\n            await renew_auth(message)\n    if message.content.startswith('/'):\n        await client.process_commands(message)", "refactored": true, "question_id": "8b2fa9137563469049632eeb151af101a87de1b0_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@client.event\nasync def on_message(message):\n    if message.author == client.user:\n        if message.content == 'Authentication invalid':\n            await renew_auth(message)\n        return\n    if not message.content.startswith('>'):\n        pass\n    else:\n        return\n        await parse(message)\n    if isinstance(message.channel, discord.channel.DMChannel):\n        if message.content == 'quit':\n            await do_quit(message)\n        if message.content == 'test':\n            return\n            await do_tests(message)\n        if message.content == 'renew' or message.content == 'reset':\n            await renew_auth(message)\n    if message.content.startswith('/'):\n"]], "choices": [{"index": 0, "turns": ["        await parse(message)        await parse(message)        return        await parse(message)        return"]}]}
{"hexsha": "0322be0d34cfd540d38d08178833c28642a03567", "ext": "py", "lang": "Python", "content": "def MinSpanning(n, m):\n    dt = defaultdict(list)\n    for i in range(m):\n        x, y, w = map(int, input().slpit())\n        dt[x].append([y, w])\n        dt[y].append([x, w])\n    parent = [-1] * n\n    key = [float('inf')] * n\n    mstSet = [False] * n\n    prq = [(0, 0)]\n    key[0] = 0\n    for i in range(n - 1):\n        u = heappop(prq)[1]\n        mstSet[u] = True\n        for x, w in dt[u]:\n            if not (not mstSet[x] and w < key[x]):\n                pass\n            else:\n                parent[x] = u\n                key[x] = w\n                heappush(prq, (key[x], x))", "fn_id": 0, "class_fn": false, "repo": "Saicharan67/Interview-Coding-Questions", "file": "Graphs/MinSpanningTreeByPrims.py", "last_update_at": "2021-11-04T03:30:00+00:00", "original_content": "def MinSpanning(n, m):\n    dt = defaultdict(list)\n    for i in range(m):\n        x, y, w = map(int, input().slpit())\n        dt[x].append([y, w])\n        dt[y].append([x, w])\n    parent = [-1] * n\n    key = [float('inf')] * n\n    mstSet = [False] * n\n    prq = [(0, 0)]\n    key[0] = 0\n    for i in range(n - 1):\n        u = heappop(prq)[1]\n        mstSet[u] = True\n        for x, w in dt[u]:\n            if not mstSet[x] and w < key[x]:\n                parent[x] = u\n                key[x] = w\n                heappush(prq, (key[x], x))", "refactored": true, "question_id": "0322be0d34cfd540d38d08178833c28642a03567_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def MinSpanning(n, m):\n    dt = defaultdict(list)\n    for i in range(m):\n        x, y, w = map(int, input().slpit())\n        dt[x].append([y, w])\n        dt[y].append([x, w])\n    parent = [-1] * n\n    key = [float('inf')] * n\n    mstSet = [False] * n\n    prq = [(0, 0)]\n    key[0] = 0\n    for i in range(n - 1):\n        u = heappop(prq)[1]\n        mstSet[u] = True\n        for x, w in dt[u]:\n            if not (not mstSet[x] and w < key[x]):\n                pass\n            else:\n                parent[x] = u\n                key[x] = w\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n                heappush(prq, (key[x], x))                heappush(prq, (key[x], x))                heappush(prq, (key[x], x))                heappush(prq, (key[x], x))                heappush(prq, (key[x], x))"]}]}
{"hexsha": "a1f55cf8e4ae2523b3711b8a9b769203a9a8a01e", "ext": "py", "lang": "Python", "content": "def search(keywords, max_results=None):\n    url = 'https://html.duckduckgo.com/html/'\n    params = {'q': keywords}\n    headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:86.0) Gecko/20100101 Firefox/86.0'}\n    yielded = 0\n    while True:\n        res = requests.post(url, data=params, headers=headers)\n        doc = html.fromstring(res.text)\n        results = [a.get('href') for a in doc.cssselect('#links .links_main a')]\n        for result in results:\n            yield result\n            time.sleep(0.1)\n            yielded += 1\n            if not (max_results and yielded >= max_results):\n                pass\n            else:\n                return\n        try:\n            form = doc.cssselect('.results_links_more form')[-1]\n        except IndexError:\n            return\n        params = dict(form.fields)", "fn_id": 0, "class_fn": false, "repo": "Jcorb08/programming-support-skill", "file": "duckduckgo.py", "last_update_at": "2021-05-26T11:08:27+00:00", "original_content": "def search(keywords, max_results=None):\n    url = 'https://html.duckduckgo.com/html/'\n    params = {'q': keywords}\n    headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:86.0) Gecko/20100101 Firefox/86.0'}\n    yielded = 0\n    while True:\n        res = requests.post(url, data=params, headers=headers)\n        doc = html.fromstring(res.text)\n        results = [a.get('href') for a in doc.cssselect('#links .links_main a')]\n        for result in results:\n            yield result\n            time.sleep(0.1)\n            yielded += 1\n            if max_results and yielded >= max_results:\n                return\n        try:\n            form = doc.cssselect('.results_links_more form')[-1]\n        except IndexError:\n            return\n        params = dict(form.fields)", "refactored": true, "question_id": "a1f55cf8e4ae2523b3711b8a9b769203a9a8a01e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def search(keywords, max_results=None):\n    url = 'https://html.duckduckgo.com/html/'\n    params = {'q': keywords}\n    headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:86.0) Gecko/20100101 Firefox/86.0'}\n    yielded = 0\n    while True:\n        res = requests.post(url, data=params, headers=headers)\n        doc = html.fromstring(res.text)\n        results = [a.get('href') for a in doc.cssselect('#links .links_main a')]\n        for result in results:\n            yield result\n            time.sleep(0.1)\n            yielded += 1\n            if not (max_results and yielded >= max_results):\n                pass\n            else:\n                return\n        try:\n            form = doc.cssselect('.results_links_more form')[-1]\n        except IndexError:\n            return\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        params = {i.get('name'): i.get('value') for i in form.cssselect('input')}        url = 'https://html.duckduckgo.com' + form.get('action')        url = 'https://html.duckduckgo.com' + form.get('action')        url = 'https://html.duckduckgo.com' + form.get('action')        params = dict(form.fields)"]}]}
{"hexsha": "d1b6df0cf562b4a74a407607abec54818df78080", "ext": "py", "lang": "Python", "content": "def mech():\n    item = {0: 'mail', 1: 'password'}\n    try:\n        choice = int(input(bcolors.OKBLUE + 'Enter the option no. of data: \\n [0] Mail \\n [1] Password\\n [2] Exit\\nOption:' + bcolors.ENDC))\n        try:\n            pass_data = input(bcolors.OKBLUE + 'Enter the ' + str(item[choice]) + ' to check: ' + bcolors.ENDC)\n        except:\n            exit(0)\n        data = main(str(choice), pass_data)\n        print(bcolors.OKGREEN + data + bcolors.ENDC)\n        print(bcolors.OKBLUE + ' [0] Dump data in a file \\n [1] Go back \\n [2] Exit' + bcolors.ENDC)\n        choice_ = input(bcolors.OKBLUE + 'Option: ' + bcolors.ENDC)\n        if choice_ == '0':\n            raw_filename = input(bcolors.OKBLUE + 'File name to save: ' + bcolors.ENDC)\n            filename = raw_filename + '_' + str(item[choice]) + '.txt'\n            file = open(filename, 'w')\n            file.write(data)\n            file.close()\n            print(bcolors.OKGREEN + 'File is saved in same directory with name {}.'.format(raw_filename) + bcolors.ENDC)\n            print()\n        elif not choice_ == '1':\n            exit(0)\n        else:\n            print()\n            print()\n            mech()\n    except Exception as e:\n        print(bcolors.FAIL + e + bcolors.ENDC)\n        exit(0)", "fn_id": 1, "class_fn": false, "repo": "StrinTH/checkleaks", "file": "leakcheck.py", "last_update_at": "2021-01-06T14:45:08+00:00", "original_content": "def mech():\n    item = {0: 'mail', 1: 'password'}\n    try:\n        choice = int(input(bcolors.OKBLUE + 'Enter the option no. of data: \\n [0] Mail \\n [1] Password\\n [2] Exit\\nOption:' + bcolors.ENDC))\n        try:\n            pass_data = input(bcolors.OKBLUE + 'Enter the ' + str(item[choice]) + ' to check: ' + bcolors.ENDC)\n        except:\n            exit(0)\n        data = main(str(choice), pass_data)\n        print(bcolors.OKGREEN + data + bcolors.ENDC)\n        print(bcolors.OKBLUE + ' [0] Dump data in a file \\n [1] Go back \\n [2] Exit' + bcolors.ENDC)\n        choice_ = input(bcolors.OKBLUE + 'Option: ' + bcolors.ENDC)\n        if choice_ == '0':\n            raw_filename = input(bcolors.OKBLUE + 'File name to save: ' + bcolors.ENDC)\n            filename = raw_filename + '_' + str(item[choice]) + '.txt'\n            file = open(filename, 'w')\n            file.write(data)\n            file.close()\n            print(bcolors.OKGREEN + 'File is saved in same directory with name {}.'.format(raw_filename) + bcolors.ENDC)\n            print()\n        elif choice_ == '1':\n            print()\n            print()\n            mech()\n        else:\n            exit(0)\n    except Exception as e:\n        print(bcolors.FAIL + e + bcolors.ENDC)\n        exit(0)", "refactored": true, "question_id": "d1b6df0cf562b4a74a407607abec54818df78080_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def mech():\n    item = {0: 'mail', 1: 'password'}\n    try:\n        choice = int(input(bcolors.OKBLUE + 'Enter the option no. of data: \\n [0] Mail \\n [1] Password\\n [2] Exit\\nOption:' + bcolors.ENDC))\n        try:\n            pass_data = input(bcolors.OKBLUE + 'Enter the ' + str(item[choice]) + ' to check: ' + bcolors.ENDC)\n        except:\n            exit(0)\n        data = main(str(choice), pass_data)\n        print(bcolors.OKGREEN + data + bcolors.ENDC)\n        print(bcolors.OKBLUE + ' [0] Dump data in a file \\n [1] Go back \\n [2] Exit' + bcolors.ENDC)\n        choice_ = input(bcolors.OKBLUE + 'Option: ' + bcolors.ENDC)\n        if choice_ == '0':\n            raw_filename = input(bcolors.OKBLUE + 'File name to save: ' + bcolors.ENDC)\n            filename = raw_filename + '_' + str(item[choice]) + '.txt'\n            file = open(filename, 'w')\n            file.write(data)\n            file.close()\n            print(bcolors.OKGREEN + 'File is saved in same directory with name {}.'.format(raw_filename) + bcolors.ENDC)\n            print()\n        elif not choice_ == '1':\n            exit(0)\n        else:\n            print()\n            print()\n            mech()\n    except Exception as e:\n        print(bcolors.FAIL + e + bcolors.ENDC)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        print(bcolors.FAIL + 'Invalid option' + bcolors.ENDC)        print(bcolors.FAIL + 'Please enter a valid option.' + bcolors.ENDC)        print(bcolors.FAIL + 'Invalid option.' + bcolors.ENDC)        print(bcolors.FAIL + 'Invalid option selected.' + bcolors.ENDC)        print()"]}]}
{"hexsha": "3931e032c422dda461181a2d4fc71a72aab1d761", "ext": "py", "lang": "Python", "content": "def main():\n    \"\"\"Main function.\"\"\"\n    try:\n        tickers = os.listdir('data')\n        tickers = (os.path.basename(t) for t in tickers if t.endswith('.csv.gz'))\n        tickers = [t.split('.')[0] for t in tickers]\n        epilog = '\\nValid values for ticker are: %s' % tickers\n        epilog += '\\n\\nSample usage: ./predict.py IBM 2010-01-01 2011-01-01 21'\n    except OSError:\n        tickers = []\n        epilog = ''\n    parser = argparse.ArgumentParser(description='Predicts stock prices.', epilog=epilog, add_help=True)\n    parser.add_argument('ticker', metavar='TICKER', help='The stock item to predict')\n    parser.add_argument('start_date', metavar='START_DATE', help='The initial date to start looking into history.')\n    parser.add_argument('end_date', metavar='END_DATE', help='The final date to stop looking into history.')\n    parser.add_argument('shift', metavar='SHIFT', type=int, help='How many days in advance to predict.')\n    options = parser.parse_args()\n    if not tickers:\n        print('\"No tickers available. Unable to predict.')\n        raise SystemExit\n    ticker = options.ticker\n    if not ticker not in tickers:\n        pass\n    else:\n        print('\"ticker\" must be one of %s' % tickers)\n        raise SystemExit\n    try:\n        start_date = pd.to_datetime(options.start_date)\n    except ValueError:\n        print('\"start_date\" must be a valid date. Not %s' % start_date)\n        raise SystemExit\n    try:\n        end_date = pd.to_datetime(options.end_date)\n    except ValueError:\n        print('\"end_date\" must be a valid date. Not %s' % end_date)\n        raise SystemExit\n    shift = options.shift\n    if shift <= 0:\n        print('\"shift\" must be a positive integer')\n        raise SystemExit\n    print('Loading data...')\n    X, y, tX, _, scaler = models.get_processed_dataset(ticker, 0.9999999999, shift, 0, False, start_date, end_date)\n    print('Training model...')\n    _, _, model = models.cross_validate_model('huber', X, y)\n    print('Predicting...')\n    yhat = model.predict(tX)\n    prediction = scaler.inverse_transform(np.array([[yhat[0]] + [0] * (X.shape[1] - 1)]))\n    print('Predicted value:', prediction[0, 0])", "fn_id": 0, "class_fn": false, "repo": "renatolfc/stock-prediction", "file": "predict.py", "last_update_at": "2021-07-01T12:17:06+00:00", "original_content": "def main():\n    \"\"\"Main function.\"\"\"\n    try:\n        tickers = os.listdir('data')\n        tickers = (os.path.basename(t) for t in tickers if t.endswith('.csv.gz'))\n        tickers = [t.split('.')[0] for t in tickers]\n        epilog = '\\nValid values for ticker are: %s' % tickers\n        epilog += '\\n\\nSample usage: ./predict.py IBM 2010-01-01 2011-01-01 21'\n    except OSError:\n        tickers = []\n        epilog = ''\n    parser = argparse.ArgumentParser(description='Predicts stock prices.', epilog=epilog, add_help=True)\n    parser.add_argument('ticker', metavar='TICKER', help='The stock item to predict')\n    parser.add_argument('start_date', metavar='START_DATE', help='The initial date to start looking into history.')\n    parser.add_argument('end_date', metavar='END_DATE', help='The final date to stop looking into history.')\n    parser.add_argument('shift', metavar='SHIFT', type=int, help='How many days in advance to predict.')\n    options = parser.parse_args()\n    if not tickers:\n        print('\"No tickers available. Unable to predict.')\n        raise SystemExit\n    ticker = options.ticker\n    if ticker not in tickers:\n        print('\"ticker\" must be one of %s' % tickers)\n        raise SystemExit\n    try:\n        start_date = pd.to_datetime(options.start_date)\n    except ValueError:\n        print('\"start_date\" must be a valid date. Not %s' % start_date)\n        raise SystemExit\n    try:\n        end_date = pd.to_datetime(options.end_date)\n    except ValueError:\n        print('\"end_date\" must be a valid date. Not %s' % end_date)\n        raise SystemExit\n    shift = options.shift\n    if shift <= 0:\n        print('\"shift\" must be a positive integer')\n        raise SystemExit\n    print('Loading data...')\n    X, y, tX, _, scaler = models.get_processed_dataset(ticker, 0.9999999999, shift, 0, False, start_date, end_date)\n    print('Training model...')\n    _, _, model = models.cross_validate_model('huber', X, y)\n    print('Predicting...')\n    yhat = model.predict(tX)\n    prediction = scaler.inverse_transform(np.array([[yhat[0]] + [0] * (X.shape[1] - 1)]))\n    print('Predicted value:', prediction[0, 0])", "refactored": true, "question_id": "3931e032c422dda461181a2d4fc71a72aab1d761_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def main():\n    \"\"\"Main function.\"\"\"\n    try:\n        tickers = os.listdir('data')\n        tickers = (os.path.basename(t) for t in tickers if t.endswith('.csv.gz'))\n        tickers = [t.split('.')[0] for t in tickers]\n        epilog = '\\nValid values for ticker are: %s' % tickers\n        epilog += '\\n\\nSample usage: ./predict.py IBM 2010-01-01 2011-01-01 21'\n    except OSError:\n        tickers = []\n        epilog = ''\n    parser = argparse.ArgumentParser(description='Predicts stock prices.', epilog=epilog, add_help=True)\n    parser.add_argument('ticker', metavar='TICKER', help='The stock item to predict')\n    parser.add_argument('start_date', metavar='START_DATE', help='The initial date to start looking into history.')\n    parser.add_argument('end_date', metavar='END_DATE', help='The final date to stop looking into history.')\n    parser.add_argument('shift', metavar='SHIFT', type=int, help='How many days in advance to predict.')\n    options = parser.parse_args()\n    if not tickers:\n        print('\"No tickers available. Unable to predict.')\n        raise SystemExit\n    ticker = options.ticker\n    if not ticker not in tickers:\n        pass\n    else:\n        print('\"ticker\" must be one of %s' % tickers)\n        raise SystemExit\n    try:\n        start_date = pd.to_datetime(options.start_date)\n    except ValueError:\n        print('\"start_date\" must be a valid date. Not %s' % start_date)\n        raise SystemExit\n    try:\n        end_date = pd.to_datetime(options.end_date)\n    except ValueError:\n        print('\"end_date\" must be a valid date. Not %s' % end_date)\n        raise SystemExit\n    shift = options.shift\n    if shift <= 0:\n        print('\"shift\" must be a positive integer')\n        raise SystemExit\n    print('Loading data...')\n    X, y, tX, _, scaler = models.get_processed_dataset(ticker, 0.9999999999, shift, 0, False, start_date, end_date)\n    print('Training model...')\n    _, _, model = models.cross_validate_model('huber', X, y)\n    print('Predicting...')\n    yhat = model.predict(tX)\n    prediction = scaler.inverse_transform(np.array([[yhat[0]] + [0] * (X.shape[1] - 1)]))\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    print('Predicted price for %s on %s: %f' % (ticker, end_date + pd.Timedelta(days=shift), prediction[0, 0]))    print('Predicted price for %s on %s: %f' % (ticker, end_date + pd.DateOffset(days=shift), prediction[0, 0]))    print('Predicted price for %s on %s: %f' % (ticker, end_date + pd.DateOffset(days=shift), prediction[0][0]))    print('Predicted price for %s: %.2f' % (ticker, prediction[0, 0]))    print('Predicted price for %s on %s: %f' % (ticker, end_date + pd.Timedelta(days=shift), prediction[0, 0]))"]}]}
{"hexsha": "d7d0cc76bd9ced96d824215c265e0b8c9d95c87b", "ext": "py", "lang": "Python", "content": "def get_unique_changed_packages(diffs):\n    packages_changed = {}\n    for change in diffs:\n        if len(change) != 2:\n            logging.debug(change)\n            continue\n        change_type, path = change\n        path_tokens = path.split('/')\n        if path_tokens[-1] in IGNORE_CHANGES_FILES:\n            continue\n        try:\n            package = Package(package_dir=path_tokens[0])\n        except PackageDoesNotExistException:\n            continue\n        if not package.package_name not in packages_changed:\n            pass\n        else:\n            packages_changed.update({package.package_name: package})\n    return packages_changed", "fn_id": 2, "class_fn": false, "repo": "r-kells/scream", "file": "scream/detect_changed_packages.py", "last_update_at": "2021-11-22T18:45:19+00:00", "original_content": "def get_unique_changed_packages(diffs):\n    packages_changed = {}\n    for change in diffs:\n        if len(change) != 2:\n            logging.debug(change)\n            continue\n        change_type, path = change\n        path_tokens = path.split('/')\n        if path_tokens[-1] in IGNORE_CHANGES_FILES:\n            continue\n        try:\n            package = Package(package_dir=path_tokens[0])\n        except PackageDoesNotExistException:\n            continue\n        if package.package_name not in packages_changed:\n            packages_changed.update({package.package_name: package})\n    return packages_changed", "refactored": true, "question_id": "d7d0cc76bd9ced96d824215c265e0b8c9d95c87b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_unique_changed_packages(diffs):\n    packages_changed = {}\n    for change in diffs:\n        if len(change) != 2:\n            logging.debug(change)\n            continue\n        change_type, path = change\n        path_tokens = path.split('/')\n        if path_tokens[-1] in IGNORE_CHANGES_FILES:\n            continue\n        try:\n            package = Package(package_dir=path_tokens[0])\n        except PackageDoesNotExistException:\n            continue\n        if not package.package_name not in packages_changed:\n            pass\n        else:\n            packages_changed.update({package.package_name: package})\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return packages_changed.values()    return packages_changed.values()    return packages_changed    return packages_changed    return packages_changed"]}]}
{"hexsha": "4ab2bfd86a6ca0acdb74024739a1d2b31d9cbebd", "ext": "py", "lang": "Python", "content": "def zero_shot_transform(image, caption, p=0.5, transform_to_apply='solarized'):\n    \"\"\"\n    Output PIL.Image of a two-panel style transfer image with an english word describing the transform included in the caption.\n    See OpenAI DALL-E blog post for more details:\n    The top half of the image is the original image, and the bottom half is a stylized image.\n    \"\"\"\n    if not p >= 0.5:\n        pass\n    else:\n        friendly_transform = transform_to_apply.replace('_', ' ')\n        style_caption = 'Two panel image of the exact same picture.' + f'On the top {caption} and on the bottom the same image but with {friendly_transform} applied.' + f'The original image is on the top and the {friendly_transform} image on the bottom. The caption is {caption}.'\n        style_image_transform = transform_lookup[transform_to_apply]\n        return (two_panel_style_transfer(image, img_transform=style_image_transform, resize_ratio=1.0), style_caption)\n    return (image, style_caption)", "fn_id": 3, "class_fn": false, "repo": "afiaka87/ZeroShotTransform", "file": "transforms.py", "last_update_at": "2021-07-20T00:07:04+00:00", "original_content": "def zero_shot_transform(image, caption, p=0.5, transform_to_apply='solarized'):\n    \"\"\"\n    Output PIL.Image of a two-panel style transfer image with an english word describing the transform included in the caption.\n    See OpenAI DALL-E blog post for more details:\n    The top half of the image is the original image, and the bottom half is a stylized image.\n    \"\"\"\n    if p >= 0.5:\n        friendly_transform = transform_to_apply.replace('_', ' ')\n        style_caption = 'Two panel image of the exact same picture.' + f'On the top {caption} and on the bottom the same image but with {friendly_transform} applied.' + f'The original image is on the top and the {friendly_transform} image on the bottom. The caption is {caption}.'\n        style_image_transform = transform_lookup[transform_to_apply]\n        return (two_panel_style_transfer(image, img_transform=style_image_transform, resize_ratio=1.0), style_caption)\n    return (image, style_caption)", "refactored": true, "question_id": "4ab2bfd86a6ca0acdb74024739a1d2b31d9cbebd_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def zero_shot_transform(image, caption, p=0.5, transform_to_apply='solarized'):\n    \"\"\"\n    Output PIL.Image of a two-panel style transfer image with an english word describing the transform included in the caption.\n    See OpenAI DALL-E blog post for more details:\n    The top half of the image is the original image, and the bottom half is a stylized image.\n    \"\"\"\n    if not p >= 0.5:\n        pass\n    else:\n        friendly_transform = transform_to_apply.replace('_', ' ')\n        style_caption = 'Two panel image of the exact same picture.' + f'On the top {caption} and on the bottom the same image but with {friendly_transform} applied.' + f'The original image is on the top and the {friendly_transform} image on the bottom. The caption is {caption}.'\n        style_image_transform = transform_lookup[transform_to_apply]\n        return (two_panel_style_transfer(image, img_transform=style_image_transform, resize_ratio=1.0), style_caption)\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    "]}]}
{"hexsha": "b36f29adbca75035b8a5747f2e0405b7dd6b8caf", "ext": "py", "lang": "Python", "content": "def roll20(querry=None):\n    \"\"\"\n    Searches roll20.net for a querry and opens the search in a webbrowser.\n    :param querry: String to search for.  If none is provided, asks the user.\n    :return: None\n    \"\"\"\n    if querry is None:\n        querry = simpledialog.askstring('Search Roll20', 'Search Roll20.net for:')\n    if not querry is not None:\n        pass\n    else:\n        url = 'https://roll20.net/compendium/dnd5e/searchbook/?terms=' + querry\n        webbrowser.open(url)", "fn_id": 1, "class_fn": false, "repo": "spudhunter/DnD-Combat-Manager", "file": "CombatManager.py", "last_update_at": "2021-01-20T05:11:23+00:00", "original_content": "def roll20(querry=None):\n    \"\"\"\n    Searches roll20.net for a querry and opens the search in a webbrowser.\n    :param querry: String to search for.  If none is provided, asks the user.\n    :return: None\n    \"\"\"\n    if querry is None:\n        querry = simpledialog.askstring('Search Roll20', 'Search Roll20.net for:')\n    if querry is not None:\n        url = 'https://roll20.net/compendium/dnd5e/searchbook/?terms=' + querry\n        webbrowser.open(url)", "refactored": true, "question_id": "b36f29adbca75035b8a5747f2e0405b7dd6b8caf_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def roll20(querry=None):\n    \"\"\"\n    Searches roll20.net for a querry and opens the search in a webbrowser.\n    :param querry: String to search for.  If none is provided, asks the user.\n    :return: None\n    \"\"\"\n    if querry is None:\n        querry = simpledialog.askstring('Search Roll20', 'Search Roll20.net for:')\n    if not querry is not None:\n        pass\n    else:\n        url = 'https://roll20.net/compendium/dnd5e/searchbook/?terms=' + querry\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n        webbrowser.open(url)        webbrowser.open(url)        webbrowser.open(url)        webbrowser.open(url)        webbrowser.open(url)"]}]}
{"hexsha": "29dcd0e7194a9a266ef5c8a71033e49f8cc50186", "ext": "py", "lang": "Python", "content": "def a_star(grid, h, start, goal):\n    path = []\n    path_cost = 0\n    queue = PriorityQueue()\n    queue.put((0, start))\n    visited = set(start)\n    branch = {}\n    found = False\n    while not queue.empty():\n        item = queue.get()\n        current_node = item[1]\n        if not current_node == start:\n            current_cost = branch[current_node][0]\n        else:\n            current_cost = 0.0\n        if current_node == goal:\n            print('Found a path.')\n            found = True\n            break\n        else:\n            for action in valid_actions(grid, current_node):\n                da = action.delta\n                next_node = (current_node[0] + da[0], current_node[1] + da[1])\n                branch_cost = current_cost + action.cost\n                queue_cost = branch_cost + h(next_node, goal)\n                if next_node not in visited:\n                    visited.add(next_node)\n                    branch[next_node] = (branch_cost, current_node, action)\n                    queue.put((queue_cost, next_node))\n    if found:\n        n = goal\n        path_cost = branch[n][0]\n        path.append(goal)\n        while branch[n][1] != start:\n            path.append(branch[n][1])\n            n = branch[n][1]\n        path.append(branch[n][1])\n    else:\n        print('**********************')\n        print('Failed to find a path!')\n        print('**********************')\n    return (path[::-1], path_cost)", "fn_id": 2, "class_fn": false, "repo": "allthatido/Drone_Motion_Planning", "file": "planning_utils.py", "last_update_at": "2021-07-08T18:54:42+00:00", "original_content": "def a_star(grid, h, start, goal):\n    path = []\n    path_cost = 0\n    queue = PriorityQueue()\n    queue.put((0, start))\n    visited = set(start)\n    branch = {}\n    found = False\n    while not queue.empty():\n        item = queue.get()\n        current_node = item[1]\n        if current_node == start:\n            current_cost = 0.0\n        else:\n            current_cost = branch[current_node][0]\n        if current_node == goal:\n            print('Found a path.')\n            found = True\n            break\n        else:\n            for action in valid_actions(grid, current_node):\n                da = action.delta\n                next_node = (current_node[0] + da[0], current_node[1] + da[1])\n                branch_cost = current_cost + action.cost\n                queue_cost = branch_cost + h(next_node, goal)\n                if next_node not in visited:\n                    visited.add(next_node)\n                    branch[next_node] = (branch_cost, current_node, action)\n                    queue.put((queue_cost, next_node))\n    if found:\n        n = goal\n        path_cost = branch[n][0]\n        path.append(goal)\n        while branch[n][1] != start:\n            path.append(branch[n][1])\n            n = branch[n][1]\n        path.append(branch[n][1])\n    else:\n        print('**********************')\n        print('Failed to find a path!')\n        print('**********************')\n    return (path[::-1], path_cost)", "refactored": true, "question_id": "29dcd0e7194a9a266ef5c8a71033e49f8cc50186_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def a_star(grid, h, start, goal):\n    path = []\n    path_cost = 0\n    queue = PriorityQueue()\n    queue.put((0, start))\n    visited = set(start)\n    branch = {}\n    found = False\n    while not queue.empty():\n        item = queue.get()\n        current_node = item[1]\n        if not current_node == start:\n            current_cost = branch[current_node][0]\n        else:\n            current_cost = 0.0\n        if current_node == goal:\n            print('Found a path.')\n            found = True\n            break\n        else:\n            for action in valid_actions(grid, current_node):\n                da = action.delta\n                next_node = (current_node[0] + da[0], current_node[1] + da[1])\n                branch_cost = current_cost + action.cost\n                queue_cost = branch_cost + h(next_node, goal)\n                if next_node not in visited:\n                    visited.add(next_node)\n                    branch[next_node] = (branch_cost, current_node, action)\n                    queue.put((queue_cost, next_node))\n    if found:\n        n = goal\n        path_cost = branch[n][0]\n        path.append(goal)\n        while branch[n][1] != start:\n            path.append(branch[n][1])\n            n = branch[n][1]\n        path.append(branch[n][1])\n    else:\n        print('**********************')\n        print('Failed to find a path!')\n        print('**********************')\n"]], "choices": [{"index": 0, "turns": ["\n\n\n\n\n    return path[::-1], path_cost    return path[::-1], path_cost    return path[::-1], path_cost    return path[::-1], path_cost    return path[::-1], path_cost"]}]}
