{"hexsha": "2b6b31ac1b8a4e33d35999ea6fa8cea0493f8cb2", "ext": "py", "lang": "Python", "content": "@njit(fastmath=False, cache=True)\ndef get_mean_curvature(traj_list, num_traj):\n    out = np.empty((num_traj,))\n    _iter0 = range(num_traj)\n    while True:\n        try:\n            i = next(_iter0)\n        except StopIteration:\n            break\n        out[i] = np.mean(np.abs(traj_list[i * trajectory_generator.NUM_STEPS:(i + 1) * trajectory_generator.NUM_STEPS, 3]))\n    return out", "fn_id": 9, "class_fn": false, "repo": "travelbureau/f0_icml_code", "file": "Simulator/python/mpc/trajectory_generator_utils.py", "last_update_at": "2021-02-17T20:53:38+00:00", "original_content": "@njit(fastmath=False, cache=True)\ndef get_mean_curvature(traj_list, num_traj):\n    out = np.empty((num_traj,))\n    for i in range(num_traj):\n        out[i] = np.mean(np.abs(traj_list[i * trajectory_generator.NUM_STEPS:(i + 1) * trajectory_generator.NUM_STEPS, 3]))\n    return out", "refactored": true, "question_id": "2b6b31ac1b8a4e33d35999ea6fa8cea0493f8cb2_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@njit(fastmath=False, cache=True)\ndef get_mean_curvature(traj_list, num_traj):\n    out = np.empty((num_traj,))\n    _iter0 = range(num_traj)\n    while True:\n        try:\n            i = next(_iter0)\n        except StopIteration:\n            break\n        out[i] = np.mean(np.abs(traj_list[i * trajectory_generator.NUM_STEPS:(i + 1) * trajectory_generator.NUM_STEPS, 3]))\n"]]}
{"hexsha": "eedf072c408246eee339cda55c42a69c694380b4", "ext": "py", "lang": "Python", "content": "def extract_bucket_reference_for_param_reference(template, param_name):\n    param_value = template.get_parameter_default(param_name)\n    if param_value is None:\n        return\n    for resource in template.resources('AWS::Serverless::Function'):\n        policies = resource['Properties'].get('Policies')\n        if policies is None:\n            continue\n        for policy in policies:\n            _iter1 = policy['Statement']\n            while True:\n                try:\n                    statement = next(_iter1)\n                except StopIteration:\n                    break\n                if param_value not in statement.get('Resource', ''):\n                    continue\n                old_value = statement['Resource']\n                parts = list(old_value.partition(param_value))\n                parts[1] = {'Ref': param_name}\n                new_value = {'Fn::Join': ['', parts]}\n                statement['Resource'] = new_value", "fn_id": 2, "class_fn": false, "repo": "jmespath/jmespath-playground", "file": "template-fixups.py", "last_update_at": "2021-11-24T14:33:45+00:00", "original_content": "def extract_bucket_reference_for_param_reference(template, param_name):\n    param_value = template.get_parameter_default(param_name)\n    if param_value is None:\n        return\n    for resource in template.resources('AWS::Serverless::Function'):\n        policies = resource['Properties'].get('Policies')\n        if policies is None:\n            continue\n        for policy in policies:\n            for statement in policy['Statement']:\n                if param_value not in statement.get('Resource', ''):\n                    continue\n                old_value = statement['Resource']\n                parts = list(old_value.partition(param_value))\n                parts[1] = {'Ref': param_name}\n                new_value = {'Fn::Join': ['', parts]}\n                statement['Resource'] = new_value", "refactored": true, "question_id": "eedf072c408246eee339cda55c42a69c694380b4_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def extract_bucket_reference_for_param_reference(template, param_name):\n    param_value = template.get_parameter_default(param_name)\n    if param_value is None:\n        return\n    for resource in template.resources('AWS::Serverless::Function'):\n        policies = resource['Properties'].get('Policies')\n        if policies is None:\n            continue\n        for policy in policies:\n            _iter1 = policy['Statement']\n            while True:\n                try:\n                    statement = next(_iter1)\n                except StopIteration:\n                    break\n                if param_value not in statement.get('Resource', ''):\n                    continue\n                old_value = statement['Resource']\n                parts = list(old_value.partition(param_value))\n                parts[1] = {'Ref': param_name}\n                new_value = {'Fn::Join': ['', parts]}\n"]]}
{"hexsha": "8c985af6b5bde8b51d64a34a81f930b1cbbde109", "ext": "py", "lang": "Python", "content": "def decode_UHFRFModeTable(data):\n    logger.debug(func())\n    par = {}\n    if len(data) == 0:\n        return (None, data)\n    header = data[0:par_header_len]\n    msgtype, length = struct.unpack(par_header, header)\n    msgtype = msgtype & BITMASK(10)\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    if msgtype != Message_struct['UHFRFModeTable']['type']:\n        return (None, data)\n    body = data[par_header_len:length]\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    i = 0\n    ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n    for _ in iter(lambda: 0, 1):\n        if not ret:\n            break\n        par['UHFC1G2RFModeTableEntry' + str(i)] = ret\n        ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n        i += 1\n    return (par, data[length:])", "fn_id": 18, "class_fn": false, "repo": "amjadmajid/stork", "file": "Host_software/sllurp/llrp_proto.py", "last_update_at": "2021-11-21T08:23:03+00:00", "original_content": "def decode_UHFRFModeTable(data):\n    logger.debug(func())\n    par = {}\n    if len(data) == 0:\n        return (None, data)\n    header = data[0:par_header_len]\n    msgtype, length = struct.unpack(par_header, header)\n    msgtype = msgtype & BITMASK(10)\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    if msgtype != Message_struct['UHFRFModeTable']['type']:\n        return (None, data)\n    body = data[par_header_len:length]\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    i = 0\n    ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n    while ret:\n        par['UHFC1G2RFModeTableEntry' + str(i)] = ret\n        ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n        i += 1\n    return (par, data[length:])", "refactored": true, "question_id": "8c985af6b5bde8b51d64a34a81f930b1cbbde109_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def decode_UHFRFModeTable(data):\n    logger.debug(func())\n    par = {}\n    if len(data) == 0:\n        return (None, data)\n    header = data[0:par_header_len]\n    msgtype, length = struct.unpack(par_header, header)\n    msgtype = msgtype & BITMASK(10)\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    if msgtype != Message_struct['UHFRFModeTable']['type']:\n        return (None, data)\n    body = data[par_header_len:length]\n    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))\n    i = 0\n    ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n    for _ in iter(lambda: 0, 1):\n        if not ret:\n            break\n        par['UHFC1G2RFModeTableEntry' + str(i)] = ret\n        ret, body = decode('UHFC1G2RFModeTableEntry')(body)\n        i += 1\n"]]}
{"hexsha": "a016e584bf0e1d2da7b3d8766cb1e7cb07b0e46c", "ext": "py", "lang": "Python", "content": "def preprocess(paragraph):\n    result = []\n    sentences = tokenizer.tokenize(paragraph)\n    for sentence in sentences:\n        words = nltk.regexp_tokenize(sentence, pattern)\n        temp = []\n        _iter2 = words\n        while True:\n            try:\n                word = next(_iter2)\n            except StopIteration:\n                break\n            toDeal = []\n            if camelCase1.match(word) or camelCase2.match(word):\n                toDeal = splitCode(word)\n            elif upperExtCase.match(word):\n                toDeal = splitFinalExt(word)\n            else:\n                toDeal.append(word)\n            for deal in toDeal:\n                if not isDelete(deal.lower()):\n                    temp.append(stemmer.stem(deal))\n        result.append(temp)\n    return result", "fn_id": 1, "class_fn": false, "repo": "anonym-user-1/ICSME2021", "file": "preprocessor.py", "last_update_at": "2021-07-01T17:13:10+00:00", "original_content": "def preprocess(paragraph):\n    result = []\n    sentences = tokenizer.tokenize(paragraph)\n    for sentence in sentences:\n        words = nltk.regexp_tokenize(sentence, pattern)\n        temp = []\n        for word in words:\n            toDeal = []\n            if camelCase1.match(word) or camelCase2.match(word):\n                toDeal = splitCode(word)\n            elif upperExtCase.match(word):\n                toDeal = splitFinalExt(word)\n            else:\n                toDeal.append(word)\n            for deal in toDeal:\n                if not isDelete(deal.lower()):\n                    temp.append(stemmer.stem(deal))\n        result.append(temp)\n    return result", "refactored": true, "question_id": "a016e584bf0e1d2da7b3d8766cb1e7cb07b0e46c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def preprocess(paragraph):\n    result = []\n    sentences = tokenizer.tokenize(paragraph)\n    for sentence in sentences:\n        words = nltk.regexp_tokenize(sentence, pattern)\n        temp = []\n        _iter2 = words\n        while True:\n            try:\n                word = next(_iter2)\n            except StopIteration:\n                break\n            toDeal = []\n            if camelCase1.match(word) or camelCase2.match(word):\n                toDeal = splitCode(word)\n            elif upperExtCase.match(word):\n                toDeal = splitFinalExt(word)\n            else:\n                toDeal.append(word)\n            for deal in toDeal:\n                if not isDelete(deal.lower()):\n                    temp.append(stemmer.stem(deal))\n        result.append(temp)\n"]]}
{"hexsha": "b27331e2a40b51e2950c979f9bac602c12eef9c1", "ext": "py", "lang": "Python", "content": "@app.route('/')\n@app.route('/index')\ndef index():\n    app.logger.debug('Entering index')\n    flask.session['user_id'] = 'creator'\n    flask.session['finished'] = check_completed()\n    flask.session['to_finish'] = PEOPLE_TO_INVITE\n    events = []\n    _iter3 = collection.find({'user_id': 'creator'})\n    while True:\n        try:\n            record = next(_iter3)\n        except StopIteration:\n            break\n        events.append(record)\n    if len(events) > 0:\n        return render_template('waiting.html')\n    if 'begin_date' not in flask.session:\n        init_session_values()\n    return render_template('index.html')", "fn_id": 0, "class_fn": false, "repo": "Dream7hief/MeetMe", "file": "flask_main.py", "last_update_at": "2021-02-08T20:18:11+00:00", "original_content": "@app.route('/')\n@app.route('/index')\ndef index():\n    app.logger.debug('Entering index')\n    flask.session['user_id'] = 'creator'\n    flask.session['finished'] = check_completed()\n    flask.session['to_finish'] = PEOPLE_TO_INVITE\n    events = []\n    for record in collection.find({'user_id': 'creator'}):\n        events.append(record)\n    if len(events) > 0:\n        return render_template('waiting.html')\n    if 'begin_date' not in flask.session:\n        init_session_values()\n    return render_template('index.html')", "refactored": true, "question_id": "b27331e2a40b51e2950c979f9bac602c12eef9c1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@app.route('/')\n@app.route('/index')\ndef index():\n    app.logger.debug('Entering index')\n    flask.session['user_id'] = 'creator'\n    flask.session['finished'] = check_completed()\n    flask.session['to_finish'] = PEOPLE_TO_INVITE\n    events = []\n    _iter3 = collection.find({'user_id': 'creator'})\n    while True:\n        try:\n            record = next(_iter3)\n        except StopIteration:\n            break\n        events.append(record)\n    if len(events) > 0:\n        return render_template('waiting.html')\n    if 'begin_date' not in flask.session:\n        init_session_values()\n"]]}
{"hexsha": "876c7c08adc0ef2ebe9987da8f1125f3cf04b813", "ext": "py", "lang": "Python", "content": "def word_bag_list(org_text):\n    \"\"\"Take text and do sum, return sumed sentence list.\"\"\"\n    nlp = spacy.load('en_core_web_sm')\n    tr = pytextrank.TextRank(logger=None)\n    nlp.add_pipe(tr.PipelineComponent, name='textrank', last=True)\n    doc = nlp(org_text)\n    whole_sent = ''\n    _iter4 = doc._.textrank.summary(limit_phrases=15, limit_sentences=5)\n    while True:\n        try:\n            sent = next(_iter4)\n        except StopIteration:\n            break\n        whole_sent = whole_sent + repr(sent).rstrip() + ' '\n    return [whole_sent]", "fn_id": 0, "class_fn": false, "repo": "liux2/Allegheny-College-CMPSC-COMP-liux2", "file": "music_sug/music_main/text_proc.py", "last_update_at": "2021-05-21T01:37:44+00:00", "original_content": "def word_bag_list(org_text):\n    \"\"\"Take text and do sum, return sumed sentence list.\"\"\"\n    nlp = spacy.load('en_core_web_sm')\n    tr = pytextrank.TextRank(logger=None)\n    nlp.add_pipe(tr.PipelineComponent, name='textrank', last=True)\n    doc = nlp(org_text)\n    whole_sent = ''\n    for sent in doc._.textrank.summary(limit_phrases=15, limit_sentences=5):\n        whole_sent = whole_sent + repr(sent).rstrip() + ' '\n    return [whole_sent]", "refactored": true, "question_id": "876c7c08adc0ef2ebe9987da8f1125f3cf04b813_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def word_bag_list(org_text):\n    \"\"\"Take text and do sum, return sumed sentence list.\"\"\"\n    nlp = spacy.load('en_core_web_sm')\n    tr = pytextrank.TextRank(logger=None)\n    nlp.add_pipe(tr.PipelineComponent, name='textrank', last=True)\n    doc = nlp(org_text)\n    whole_sent = ''\n    _iter4 = doc._.textrank.summary(limit_phrases=15, limit_sentences=5)\n    while True:\n        try:\n            sent = next(_iter4)\n        except StopIteration:\n            break\n        whole_sent = whole_sent + repr(sent).rstrip() + ' '\n"]]}
{"hexsha": "20fd1f5105839af2bba28ff254523016e1e09b8f", "ext": "py", "lang": "Python", "content": "def _get_pipeline_definition_args(dag):\n    check.inst_param(dag, 'dag', DAG)\n    pipeline_dependencies = {}\n    solid_defs = []\n    seen_tasks = []\n    dag_roots = sorted(dag.roots, key=lambda x: x.task_id)\n    _iter5 = dag_roots\n    while True:\n        try:\n            task = next(_iter5)\n        except StopIteration:\n            break\n        _traverse_airflow_dag(task, seen_tasks, pipeline_dependencies, solid_defs)\n    return (pipeline_dependencies, solid_defs)", "fn_id": 1, "class_fn": false, "repo": "uranusbeam/bit-dagster", "file": "python_modules/libraries/dagster-airflow/dagster_airflow/dagster_pipeline_factory.py", "last_update_at": "2021-11-08T02:10:42+00:00", "original_content": "def _get_pipeline_definition_args(dag):\n    check.inst_param(dag, 'dag', DAG)\n    pipeline_dependencies = {}\n    solid_defs = []\n    seen_tasks = []\n    dag_roots = sorted(dag.roots, key=lambda x: x.task_id)\n    for task in dag_roots:\n        _traverse_airflow_dag(task, seen_tasks, pipeline_dependencies, solid_defs)\n    return (pipeline_dependencies, solid_defs)", "refactored": true, "question_id": "20fd1f5105839af2bba28ff254523016e1e09b8f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _get_pipeline_definition_args(dag):\n    check.inst_param(dag, 'dag', DAG)\n    pipeline_dependencies = {}\n    solid_defs = []\n    seen_tasks = []\n    dag_roots = sorted(dag.roots, key=lambda x: x.task_id)\n    _iter5 = dag_roots\n    while True:\n        try:\n            task = next(_iter5)\n        except StopIteration:\n            break\n        _traverse_airflow_dag(task, seen_tasks, pipeline_dependencies, solid_defs)\n"]]}
{"hexsha": "a9d142291ba38842e31d3177869d6447f084d025", "ext": "py", "lang": "Python", "content": "def time_model(model: nn.Module, test_set: Type[LightFieldDataset], device) -> np.ndarray:\n    model.eval()\n    custom = CustomProgressBar('N/A')\n    loader = torch.utils.data.DataLoader(dataset=test_set, batch_size=1, sampler=SequentialSampler(test_set), num_workers=1, pin_memory=True)\n    test_set.set_only_x_dataset()\n    model.eval()\n    torch.set_grad_enabled(False)\n    print('Timing')\n    all_times = []\n    _iter6 = custom.bar(loader)\n    while True:\n        try:\n            input_data = next(_iter6)\n        except StopIteration:\n            break\n        tick = time.time()\n        input_var = input_data.to(device).float().div_(255.0)\n        _ = model(input_var)\n        tock = time.time()\n        time_taken = tock - tick\n        all_times.append(time_taken)\n    test_set.revert_only_x_dataset()\n    return np.array(all_times)", "fn_id": 0, "class_fn": false, "repo": "leaveitout/deep_light_field_interp", "file": "deeplfinterp/util/train_tools.py", "last_update_at": "2021-08-06T13:39:19+00:00", "original_content": "def time_model(model: nn.Module, test_set: Type[LightFieldDataset], device) -> np.ndarray:\n    model.eval()\n    custom = CustomProgressBar('N/A')\n    loader = torch.utils.data.DataLoader(dataset=test_set, batch_size=1, sampler=SequentialSampler(test_set), num_workers=1, pin_memory=True)\n    test_set.set_only_x_dataset()\n    model.eval()\n    torch.set_grad_enabled(False)\n    print('Timing')\n    all_times = []\n    for input_data in custom.bar(loader):\n        tick = time.time()\n        input_var = input_data.to(device).float().div_(255.0)\n        _ = model(input_var)\n        tock = time.time()\n        time_taken = tock - tick\n        all_times.append(time_taken)\n    test_set.revert_only_x_dataset()\n    return np.array(all_times)", "refactored": true, "question_id": "a9d142291ba38842e31d3177869d6447f084d025_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def time_model(model: nn.Module, test_set: Type[LightFieldDataset], device) -> np.ndarray:\n    model.eval()\n    custom = CustomProgressBar('N/A')\n    loader = torch.utils.data.DataLoader(dataset=test_set, batch_size=1, sampler=SequentialSampler(test_set), num_workers=1, pin_memory=True)\n    test_set.set_only_x_dataset()\n    model.eval()\n    torch.set_grad_enabled(False)\n    print('Timing')\n    all_times = []\n    _iter6 = custom.bar(loader)\n    while True:\n        try:\n            input_data = next(_iter6)\n        except StopIteration:\n            break\n        tick = time.time()\n        input_var = input_data.to(device).float().div_(255.0)\n        _ = model(input_var)\n        tock = time.time()\n        time_taken = tock - tick\n        all_times.append(time_taken)\n    test_set.revert_only_x_dataset()\n"]]}
{"hexsha": "fe240d6eafcfe9043656fc61dbcdc36afa2f5d4c", "ext": "py", "lang": "Python", "content": "def get_feature(internel_layer, layers, filters, batch_norm=False):\n    \"\"\"Get VGG feature body as stacks of convoltions.\"\"\"\n    _iter7 = enumerate(layers)\n    while True:\n        try:\n            i, num = next(_iter7)\n        except StopIteration:\n            break\n        for j in range(num):\n            internel_layer = sym.conv2d(data=internel_layer, kernel_size=(3, 3), padding=(1, 1), channels=filters[i], name='conv%s_%s' % (i + 1, j + 1))\n            if batch_norm:\n                internel_layer = sym.batch_norm(data=internel_layer, name='bn%s_%s' % (i + 1, j + 1))\n            internel_layer = sym.relu(data=internel_layer, name='relu%s_%s' % (i + 1, j + 1))\n        internel_layer = sym.max_pool2d(data=internel_layer, pool_size=(2, 2), strides=(2, 2), name='pool%s' % (i + 1))\n    return internel_layer", "fn_id": 0, "class_fn": false, "repo": "CynthiaProtector/helo", "file": "nnvm/python/nnvm/testing/vgg.py", "last_update_at": "2021-12-25T06:09:46+00:00", "original_content": "def get_feature(internel_layer, layers, filters, batch_norm=False):\n    \"\"\"Get VGG feature body as stacks of convoltions.\"\"\"\n    for i, num in enumerate(layers):\n        for j in range(num):\n            internel_layer = sym.conv2d(data=internel_layer, kernel_size=(3, 3), padding=(1, 1), channels=filters[i], name='conv%s_%s' % (i + 1, j + 1))\n            if batch_norm:\n                internel_layer = sym.batch_norm(data=internel_layer, name='bn%s_%s' % (i + 1, j + 1))\n            internel_layer = sym.relu(data=internel_layer, name='relu%s_%s' % (i + 1, j + 1))\n        internel_layer = sym.max_pool2d(data=internel_layer, pool_size=(2, 2), strides=(2, 2), name='pool%s' % (i + 1))\n    return internel_layer", "refactored": true, "question_id": "fe240d6eafcfe9043656fc61dbcdc36afa2f5d4c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_feature(internel_layer, layers, filters, batch_norm=False):\n    \"\"\"Get VGG feature body as stacks of convoltions.\"\"\"\n    _iter7 = enumerate(layers)\n    while True:\n        try:\n            i, num = next(_iter7)\n        except StopIteration:\n            break\n        for j in range(num):\n            internel_layer = sym.conv2d(data=internel_layer, kernel_size=(3, 3), padding=(1, 1), channels=filters[i], name='conv%s_%s' % (i + 1, j + 1))\n            if batch_norm:\n                internel_layer = sym.batch_norm(data=internel_layer, name='bn%s_%s' % (i + 1, j + 1))\n            internel_layer = sym.relu(data=internel_layer, name='relu%s_%s' % (i + 1, j + 1))\n        internel_layer = sym.max_pool2d(data=internel_layer, pool_size=(2, 2), strides=(2, 2), name='pool%s' % (i + 1))\n"]]}
{"hexsha": "ad091436c7271a654fb820601c6d942f23f49ff5", "ext": "py", "lang": "Python", "content": "def get_rna(fq_dict):\n    \"\"\"\n    Obtain a numpy array with all detected spots in the image. Detection results\n    are saved in a dictionary (see read_FQ_results_matlab for more details).\n    \"\"\"\n    RNAall = nested_lookup('spots', fq_dict)\n    _iter8 = enumerate(RNAall)\n    while True:\n        try:\n            idx, val = next(_iter8)\n        except StopIteration:\n            break\n        if idx == 0:\n            spots_all = np.copy(val)\n        else:\n            spots_all = np.append(spots_all, val, axis=0)\n    return spots_all", "fn_id": 3, "class_fn": false, "repo": "muellerflorian/parker-rna-loc-elegans", "file": "rnaloc/FQtoolbox.py", "last_update_at": "2021-01-12T16:51:38+00:00", "original_content": "def get_rna(fq_dict):\n    \"\"\"\n    Obtain a numpy array with all detected spots in the image. Detection results\n    are saved in a dictionary (see read_FQ_results_matlab for more details).\n    \"\"\"\n    RNAall = nested_lookup('spots', fq_dict)\n    for idx, val in enumerate(RNAall):\n        if idx == 0:\n            spots_all = np.copy(val)\n        else:\n            spots_all = np.append(spots_all, val, axis=0)\n    return spots_all", "refactored": true, "question_id": "ad091436c7271a654fb820601c6d942f23f49ff5_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_rna(fq_dict):\n    \"\"\"\n    Obtain a numpy array with all detected spots in the image. Detection results\n    are saved in a dictionary (see read_FQ_results_matlab for more details).\n    \"\"\"\n    RNAall = nested_lookup('spots', fq_dict)\n    _iter8 = enumerate(RNAall)\n    while True:\n        try:\n            idx, val = next(_iter8)\n        except StopIteration:\n            break\n        if idx == 0:\n            spots_all = np.copy(val)\n        else:\n            spots_all = np.append(spots_all, val, axis=0)\n"]]}
{"hexsha": "6f11be4ebd108a94cb1027e16e858ff097fa14e5", "ext": "py", "lang": "Python", "content": "def text_to_spreadsheet(directory='.', output_file='text_to_sheet.xlsx'):\n    \"\"\"\n    Searches for all text files at the given directory. Each individual\n    text file is converted to a column in the output_file spreadsheet.\n\n    :param str directory: path to directory to search\n    :param str output_file: name of output file\n    \"\"\"\n    path = os.path.abspath(directory)\n    wb = openpyxl.Workbook()\n    wb.create_sheet(title='Text to Columns', index=0)\n    sheet = wb.active\n    bold = Font(bold=True)\n    print(f'Searching for text files...')\n    files = [file for file in os.listdir(path) if file.lower().endswith('.txt')]\n    column = 1\n    print(f'Writing lines of text to columns...')\n    _iter9 = files\n    while True:\n        try:\n            file = next(_iter9)\n        except StopIteration:\n            break\n        row = 2\n        with open(os.path.join(path, file)) as text:\n            sheet.cell(row=1, column=column).value = file\n            sheet.cell(row=1, column=column).font = bold\n            for line in text:\n                sheet.cell(row=row, column=column).value = line\n                row += 1\n        column += 1\n    wb.save(filename=output_file)\n    print(f\"Resulting file saved as '{output_file}'\")", "fn_id": 0, "class_fn": false, "repo": "zspatter/automate-the-boring-stuff", "file": "text_to_spreadsheet/text_to_spreadsheet.py", "last_update_at": "2021-09-05T20:19:40+00:00", "original_content": "def text_to_spreadsheet(directory='.', output_file='text_to_sheet.xlsx'):\n    \"\"\"\n    Searches for all text files at the given directory. Each individual\n    text file is converted to a column in the output_file spreadsheet.\n\n    :param str directory: path to directory to search\n    :param str output_file: name of output file\n    \"\"\"\n    path = os.path.abspath(directory)\n    wb = openpyxl.Workbook()\n    wb.create_sheet(title='Text to Columns', index=0)\n    sheet = wb.active\n    bold = Font(bold=True)\n    print(f'Searching for text files...')\n    files = [file for file in os.listdir(path) if file.lower().endswith('.txt')]\n    column = 1\n    print(f'Writing lines of text to columns...')\n    for file in files:\n        row = 2\n        with open(os.path.join(path, file)) as text:\n            sheet.cell(row=1, column=column).value = file\n            sheet.cell(row=1, column=column).font = bold\n            for line in text:\n                sheet.cell(row=row, column=column).value = line\n                row += 1\n        column += 1\n    wb.save(filename=output_file)\n    print(f\"Resulting file saved as '{output_file}'\")", "refactored": true, "question_id": "6f11be4ebd108a94cb1027e16e858ff097fa14e5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def text_to_spreadsheet(directory='.', output_file='text_to_sheet.xlsx'):\n    \"\"\"\n    Searches for all text files at the given directory. Each individual\n    text file is converted to a column in the output_file spreadsheet.\n    :param str directory: path to directory to search\n    :param str output_file: name of output file\n    \"\"\"\n    path = os.path.abspath(directory)\n    wb = openpyxl.Workbook()\n    wb.create_sheet(title='Text to Columns', index=0)\n    sheet = wb.active\n    bold = Font(bold=True)\n    print(f'Searching for text files...')\n    files = [file for file in os.listdir(path) if file.lower().endswith('.txt')]\n    column = 1\n    print(f'Writing lines of text to columns...')\n    _iter9 = files\n    while True:\n        try:\n            file = next(_iter9)\n        except StopIteration:\n            break\n        row = 2\n        with open(os.path.join(path, file)) as text:\n            sheet.cell(row=1, column=column).value = file\n            sheet.cell(row=1, column=column).font = bold\n            for line in text:\n                sheet.cell(row=row, column=column).value = line\n                row += 1\n        column += 1\n    wb.save(filename=output_file)\n"]]}
{"hexsha": "782e47ae6e2a1bc565a53c10fee16a15dc5e46b5", "ext": "py", "lang": "Python", "content": "def readStr_qm9():\n    f = open(current_dir + '/../_dataset/QM9/qm9.smi', 'r')\n    L = []\n    _iter10 = f\n    while True:\n        try:\n            line = next(_iter10)\n        except StopIteration:\n            break\n        line = line.strip()\n        L.append(line)\n    f.close()\n    np.random.seed(1)\n    np.random.shuffle(L)\n    return L", "fn_id": 2, "class_fn": false, "repo": "drigoni/ComparisonsDGM", "file": "_utils/read_dataset.py", "last_update_at": "2021-04-12T13:17:50+00:00", "original_content": "def readStr_qm9():\n    f = open(current_dir + '/../_dataset/QM9/qm9.smi', 'r')\n    L = []\n    for line in f:\n        line = line.strip()\n        L.append(line)\n    f.close()\n    np.random.seed(1)\n    np.random.shuffle(L)\n    return L", "refactored": true, "question_id": "782e47ae6e2a1bc565a53c10fee16a15dc5e46b5_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def readStr_qm9():\n    f = open(current_dir + '/../_dataset/QM9/qm9.smi', 'r')\n    L = []\n    _iter10 = f\n    while True:\n        try:\n            line = next(_iter10)\n        except StopIteration:\n            break\n        line = line.strip()\n        L.append(line)\n    f.close()\n    np.random.seed(1)\n    np.random.shuffle(L)\n"]]}
{"hexsha": "c1e6e718242cba1e86b4e900ac601b58a5f8729f", "ext": "py", "lang": "Python", "content": "def count_byte_values(bss: Iterable[ByteString]) -> list[Counter[int]]:\n    \"\"\"Returns a list of Counters, each of which records the values of the\n    bytes at the corresponding index in the given ByteStrings.\"\"\"\n    counts_for_idx: list[Counter[int]] = []\n    bs_len = None\n    _iter11 = bss\n    while True:\n        try:\n            bs = next(_iter11)\n        except StopIteration:\n            break\n        if bs_len is None:\n            bs_len = len(bs)\n            counts_for_idx = [Counter() for _ in range(bs_len)]\n        assert len(bs) == bs_len\n        for i, b in enumerate(bs):\n            counts_for_idx[i][b] += 1\n    return counts_for_idx", "fn_id": 2, "class_fn": false, "repo": "misterfifths/nis_mods", "file": "utils/mining.py", "last_update_at": "2021-10-18T13:42:09+00:00", "original_content": "def count_byte_values(bss: Iterable[ByteString]) -> list[Counter[int]]:\n    \"\"\"Returns a list of Counters, each of which records the values of the\n    bytes at the corresponding index in the given ByteStrings.\"\"\"\n    counts_for_idx: list[Counter[int]] = []\n    bs_len = None\n    for bs in bss:\n        if bs_len is None:\n            bs_len = len(bs)\n            counts_for_idx = [Counter() for _ in range(bs_len)]\n        assert len(bs) == bs_len\n        for i, b in enumerate(bs):\n            counts_for_idx[i][b] += 1\n    return counts_for_idx", "refactored": true, "question_id": "c1e6e718242cba1e86b4e900ac601b58a5f8729f_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def count_byte_values(bss: Iterable[ByteString]) -> list[Counter[int]]:\n    \"\"\"Returns a list of Counters, each of which records the values of the\n    bytes at the corresponding index in the given ByteStrings.\"\"\"\n    counts_for_idx: list[Counter[int]] = []\n    bs_len = None\n    _iter11 = bss\n    while True:\n        try:\n            bs = next(_iter11)\n        except StopIteration:\n            break\n        if bs_len is None:\n            bs_len = len(bs)\n            counts_for_idx = [Counter() for _ in range(bs_len)]\n        assert len(bs) == bs_len\n        for i, b in enumerate(bs):\n            counts_for_idx[i][b] += 1\n"]]}
{"hexsha": "9109af01b75d406c726ca60fbd26a94a9e80f374", "ext": "py", "lang": "Python", "content": "def MultiscaleEntropy_mse(x, scale_factor=[i for i in range(1, 21)], m=[2], r=[0.15], return_type='dict', safe_mode=False):\n    \"\"\"[Multiscale Entropy]\n\n    Arguments:\n        x {[input signal]} -- [an iterator of numbers]\n\n    Keyword Arguments:\n        scale_factor {list} -- [scale factors of coarse graining] (default: {[i for i in range(1,21)]})\n        m {list} -- [m in sample entropy] (default: {[2]})\n        r {list} -- [r in sample entropy] (default: {[0.15]})\n        return_type {str} -- [can be dict or list] (default: {'dict'})\n        safe_mode {bool} -- [if set True, type checking will be skipped] (default: {False})\n\n    Raises:\n        ValueError -- [some values too big]\n\n    Returns:\n        [dict or list as return_type indicates] -- [if dict, nest as [scale_factor][m][r] for each value of scale_factor, m, r; if list nest as [i][j][k] for lengths of scale_factor, m, r]\n    \"\"\"\n    if not safe_mode:\n        m = MultiscaleEntropy_check_type(m, int, 'm')\n        r = MultiscaleEntropy_check_type(r, float, 'r')\n        scale_factor = MultiscaleEntropy_check_type(scale_factor, int, 'scale_factor')\n    try:\n        x = np.array(x)\n    except:\n        print('x should be a sequence of numbers')\n    if max(scale_factor) > len(x):\n        raise ValueError(\"the max scale_factor is bigger than x's length\")\n    sd = np.sqrt(np.var(x))\n    ms_en = MultiscaleEntropy_init_return_type(return_type)\n    _iter12 = scale_factor\n    while True:\n        try:\n            s_f = next(_iter12)\n        except StopIteration:\n            break\n        y = MultiscaleEntropy_coarse_grain(x, s_f)\n        if return_type == 'dict':\n            ms_en[s_f] = MultiscaleEntropy_sample_entropy(y, m, r, sd, 'dict', True)\n        else:\n            ms_en.append(MultiscaleEntropy_sample_entropy(y, m, r, sd, 'list', True))\n    if return_type == 'list':\n        ms_en = [i[0] for i in ms_en]\n        ms_en = [i[0] for i in ms_en]\n    return ms_en", "fn_id": 18, "class_fn": false, "repo": "LRydin/NeuroKit", "file": "tests/tests_complexity.py", "last_update_at": "2021-06-10T03:27:15+00:00", "original_content": "def MultiscaleEntropy_mse(x, scale_factor=[i for i in range(1, 21)], m=[2], r=[0.15], return_type='dict', safe_mode=False):\n    \"\"\"[Multiscale Entropy]\n\n    Arguments:\n        x {[input signal]} -- [an iterator of numbers]\n\n    Keyword Arguments:\n        scale_factor {list} -- [scale factors of coarse graining] (default: {[i for i in range(1,21)]})\n        m {list} -- [m in sample entropy] (default: {[2]})\n        r {list} -- [r in sample entropy] (default: {[0.15]})\n        return_type {str} -- [can be dict or list] (default: {'dict'})\n        safe_mode {bool} -- [if set True, type checking will be skipped] (default: {False})\n\n    Raises:\n        ValueError -- [some values too big]\n\n    Returns:\n        [dict or list as return_type indicates] -- [if dict, nest as [scale_factor][m][r] for each value of scale_factor, m, r; if list nest as [i][j][k] for lengths of scale_factor, m, r]\n    \"\"\"\n    if not safe_mode:\n        m = MultiscaleEntropy_check_type(m, int, 'm')\n        r = MultiscaleEntropy_check_type(r, float, 'r')\n        scale_factor = MultiscaleEntropy_check_type(scale_factor, int, 'scale_factor')\n    try:\n        x = np.array(x)\n    except:\n        print('x should be a sequence of numbers')\n    if max(scale_factor) > len(x):\n        raise ValueError(\"the max scale_factor is bigger than x's length\")\n    sd = np.sqrt(np.var(x))\n    ms_en = MultiscaleEntropy_init_return_type(return_type)\n    for s_f in scale_factor:\n        y = MultiscaleEntropy_coarse_grain(x, s_f)\n        if return_type == 'dict':\n            ms_en[s_f] = MultiscaleEntropy_sample_entropy(y, m, r, sd, 'dict', True)\n        else:\n            ms_en.append(MultiscaleEntropy_sample_entropy(y, m, r, sd, 'list', True))\n    if return_type == 'list':\n        ms_en = [i[0] for i in ms_en]\n        ms_en = [i[0] for i in ms_en]\n    return ms_en", "refactored": true, "question_id": "9109af01b75d406c726ca60fbd26a94a9e80f374_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def MultiscaleEntropy_mse(x, scale_factor=[i for i in range(1, 21)], m=[2], r=[0.15], return_type='dict', safe_mode=False):\n    \"\"\"[Multiscale Entropy]\n    Arguments:\n        x {[input signal]} -- [an iterator of numbers]\n    Keyword Arguments:\n        scale_factor {list} -- [scale factors of coarse graining] (default: {[i for i in range(1,21)]})\n        m {list} -- [m in sample entropy] (default: {[2]})\n        r {list} -- [r in sample entropy] (default: {[0.15]})\n        return_type {str} -- [can be dict or list] (default: {'dict'})\n        safe_mode {bool} -- [if set True, type checking will be skipped] (default: {False})\n    Raises:\n        ValueError -- [some values too big]\n    Returns:\n        [dict or list as return_type indicates] -- [if dict, nest as [scale_factor][m][r] for each value of scale_factor, m, r; if list nest as [i][j][k] for lengths of scale_factor, m, r]\n    \"\"\"\n    if not safe_mode:\n        m = MultiscaleEntropy_check_type(m, int, 'm')\n        r = MultiscaleEntropy_check_type(r, float, 'r')\n        scale_factor = MultiscaleEntropy_check_type(scale_factor, int, 'scale_factor')\n    try:\n        x = np.array(x)\n    except:\n        print('x should be a sequence of numbers')\n    if max(scale_factor) > len(x):\n        raise ValueError(\"the max scale_factor is bigger than x's length\")\n    sd = np.sqrt(np.var(x))\n    ms_en = MultiscaleEntropy_init_return_type(return_type)\n    _iter12 = scale_factor\n    while True:\n        try:\n            s_f = next(_iter12)\n        except StopIteration:\n            break\n        y = MultiscaleEntropy_coarse_grain(x, s_f)\n        if return_type == 'dict':\n            ms_en[s_f] = MultiscaleEntropy_sample_entropy(y, m, r, sd, 'dict', True)\n        else:\n            ms_en.append(MultiscaleEntropy_sample_entropy(y, m, r, sd, 'list', True))\n    if return_type == 'list':\n        ms_en = [i[0] for i in ms_en]\n        ms_en = [i[0] for i in ms_en]\n"]]}
{"hexsha": "86b7411d0f37a9a1b85f3b8b0f899c31c9cc6336", "ext": "py", "lang": "Python", "content": "@pytest.mark.filterwarnings('ignore:This function is not safe at the moment')\n@pytest.mark.parametrize('input_type', [tuple, list])\n@requires_tables\ndef test_complete_irradiance_arrays(sapm_dc_snl_ac_system_same_arrays, location, input_type):\n    \"\"\"ModelChain.complete_irradiance can accept a tuple of weather\n    DataFrames.\"\"\"\n    times = pd.date_range(start='2020-01-01 0700-0700', periods=2, freq='H')\n    weather = pd.DataFrame({'dni': [2, 3], 'dhi': [4, 6], 'ghi': [9, 5]}, index=times)\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n    with pytest.raises(ValueError, match='Input DataFrames must have same index\\\\.'):\n        mc.complete_irradiance(input_type((weather, weather[1:])))\n    mc.complete_irradiance(input_type((weather, weather)))\n    _iter13 = mc.results.weather\n    while True:\n        try:\n            mc_weather = next(_iter13)\n        except StopIteration:\n            break\n        assert_series_equal(mc_weather['dni'], pd.Series([2, 3], index=times, name='dni'))\n        assert_series_equal(mc_weather['dhi'], pd.Series([4, 6], index=times, name='dhi'))\n        assert_series_equal(mc_weather['ghi'], pd.Series([9, 5], index=times, name='ghi'))\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n    mc.complete_irradiance(input_type((weather[['ghi', 'dhi']], weather[['dhi', 'dni']])))\n    assert 'dni' in mc.results.weather[0].columns\n    assert 'ghi' in mc.results.weather[1].columns\n    mc.complete_irradiance(input_type((weather, weather[['ghi', 'dni']])))\n    assert_series_equal(mc.results.weather[0]['dhi'], pd.Series([4, 6], index=times, name='dhi'))\n    assert_series_equal(mc.results.weather[0]['ghi'], pd.Series([9, 5], index=times, name='ghi'))\n    assert_series_equal(mc.results.weather[0]['dni'], pd.Series([2, 3], index=times, name='dni'))\n    assert 'dhi' in mc.results.weather[1].columns", "fn_id": 104, "class_fn": false, "repo": "Kaustubh1598/pvlib-python", "file": "pvlib/tests/test_modelchain.py", "last_update_at": "2021-08-16T06:47:01+00:00", "original_content": "@pytest.mark.filterwarnings('ignore:This function is not safe at the moment')\n@pytest.mark.parametrize('input_type', [tuple, list])\n@requires_tables\ndef test_complete_irradiance_arrays(sapm_dc_snl_ac_system_same_arrays, location, input_type):\n    \"\"\"ModelChain.complete_irradiance can accept a tuple of weather\n    DataFrames.\"\"\"\n    times = pd.date_range(start='2020-01-01 0700-0700', periods=2, freq='H')\n    weather = pd.DataFrame({'dni': [2, 3], 'dhi': [4, 6], 'ghi': [9, 5]}, index=times)\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n    with pytest.raises(ValueError, match='Input DataFrames must have same index\\\\.'):\n        mc.complete_irradiance(input_type((weather, weather[1:])))\n    mc.complete_irradiance(input_type((weather, weather)))\n    for mc_weather in mc.results.weather:\n        assert_series_equal(mc_weather['dni'], pd.Series([2, 3], index=times, name='dni'))\n        assert_series_equal(mc_weather['dhi'], pd.Series([4, 6], index=times, name='dhi'))\n        assert_series_equal(mc_weather['ghi'], pd.Series([9, 5], index=times, name='ghi'))\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n    mc.complete_irradiance(input_type((weather[['ghi', 'dhi']], weather[['dhi', 'dni']])))\n    assert 'dni' in mc.results.weather[0].columns\n    assert 'ghi' in mc.results.weather[1].columns\n    mc.complete_irradiance(input_type((weather, weather[['ghi', 'dni']])))\n    assert_series_equal(mc.results.weather[0]['dhi'], pd.Series([4, 6], index=times, name='dhi'))\n    assert_series_equal(mc.results.weather[0]['ghi'], pd.Series([9, 5], index=times, name='ghi'))\n    assert_series_equal(mc.results.weather[0]['dni'], pd.Series([2, 3], index=times, name='dni'))\n    assert 'dhi' in mc.results.weather[1].columns", "refactored": true, "question_id": "86b7411d0f37a9a1b85f3b8b0f899c31c9cc6336_104", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@pytest.mark.filterwarnings('ignore:This function is not safe at the moment')\n@pytest.mark.parametrize('input_type', [tuple, list])\n@requires_tables\ndef test_complete_irradiance_arrays(sapm_dc_snl_ac_system_same_arrays, location, input_type):\n    \"\"\"ModelChain.complete_irradiance can accept a tuple of weather\n    DataFrames.\"\"\"\n    times = pd.date_range(start='2020-01-01 0700-0700', periods=2, freq='H')\n    weather = pd.DataFrame({'dni': [2, 3], 'dhi': [4, 6], 'ghi': [9, 5]}, index=times)\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n    with pytest.raises(ValueError, match='Input DataFrames must have same index\\\\.'):\n        mc.complete_irradiance(input_type((weather, weather[1:])))\n    mc.complete_irradiance(input_type((weather, weather)))\n    _iter13 = mc.results.weather\n    while True:\n        try:\n            mc_weather = next(_iter13)\n        except StopIteration:\n            break\n        assert_series_equal(mc_weather['dni'], pd.Series([2, 3], index=times, name='dni'))\n        assert_series_equal(mc_weather['dhi'], pd.Series([4, 6], index=times, name='dhi'))\n        assert_series_equal(mc_weather['ghi'], pd.Series([9, 5], index=times, name='ghi'))\n    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)\n    mc.complete_irradiance(input_type((weather[['ghi', 'dhi']], weather[['dhi', 'dni']])))\n    assert 'dni' in mc.results.weather[0].columns\n    assert 'ghi' in mc.results.weather[1].columns\n    mc.complete_irradiance(input_type((weather, weather[['ghi', 'dni']])))\n    assert_series_equal(mc.results.weather[0]['dhi'], pd.Series([4, 6], index=times, name='dhi'))\n    assert_series_equal(mc.results.weather[0]['ghi'], pd.Series([9, 5], index=times, name='ghi'))\n    assert_series_equal(mc.results.weather[0]['dni'], pd.Series([2, 3], index=times, name='dni'))\n"]]}
{"hexsha": "1d58be5f8c298cf630d37e7dc4f29b9760416dc5", "ext": "py", "lang": "Python", "content": "def parse_net_xml(doc):\n    total = len(list(doc.getiterator('wireless-network')))\n    tenth = total / 10\n    count = 0\n    clients = list()\n    parsed_list = []\n    for network in doc.getiterator('wireless-network'):\n        count += 1\n        try:\n            if count % tenth == 0:\n                continue\n        except ZeroDivisionError:\n            print('Division by zero error')\n        type = network.attrib['type']\n        channel = network.find('channel').text\n        bssid = network.find('BSSID').text\n        if type == 'probe' or channel == '0':\n            continue\n        encryption = network.getiterator('encryption')\n        privacy = ''\n        cipher = ''\n        auth = ''\n        if encryption is not None:\n            _iter14 = encryption\n            while True:\n                try:\n                    item = next(_iter14)\n                except StopIteration:\n                    break\n                if item.text.startswith('WEP'):\n                    privacy = 'WEP'\n                    cipher = 'WEP'\n                    auth = ''\n                    break\n                elif item.text.startswith('WPA'):\n                    if item.text.endswith('PSK'):\n                        auth = 'PSK'\n                    elif item.text.endswith('AES-CCM'):\n                        cipher = 'CCMP ' + cipher\n                    elif item.text.endswith('TKIP'):\n                        cipher += 'TKIP '\n                elif item.text == 'None':\n                    privacy = 'OPN'\n        cipher = cipher.strip()\n        if cipher.find('CCMP') > -1:\n            privacy = 'WPA2'\n        if cipher.find('TKIP') > -1:\n            privacy += 'WPA'\n        power = network.find('snr-info')\n        dbm = ''\n        if power is not None:\n            dbm = power.find('max_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('last_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('min_signal_dbm').text\n        ssid = network.find('SSID')\n        essid_text = ''\n        if ssid is not None:\n            essid_text = network.find('SSID').find('essid').text\n        gps = network.find('gps-info')\n        lat, lon = ('', '')\n        if gps is not None:\n            lat = network.find('gps-info').find('min-lat').text\n            lon = network.find('gps-info').find('min-lon').text\n        data = dict(ESSID=essid_text, BSSID=bssid, Channel=channel, Privacy=privacy, Cipher=cipher, Authenticaiton=auth, DBM=dbm)\n        if lat and lon is not None:\n            google_map = 'https://maps.google.com/maps?q=' + lat + ',' + lon + '&ll=' + lat + ',' + lon + '&z=17'\n            google_map_link = '<a href=\"' + google_map + '\" target=\"_blank\"> Google map link</a>'\n            location = dict(Latitude=lat, Longitude=lon, Googlemap=google_map_link)\n        else:\n            not_found = 'Not coordinates available'\n            location = dict(Latitude=not_found, Longitude=not_found)\n        client_list = associatedClients(network, bssid, essid_text)\n        if client_list is not None:\n            data['client'] = client_list\n        else:\n            not_found = 'No clients found'\n            data['client'] = not_found\n        data['location'] = location\n        parsed_list.append(data)\n    return parsed_list", "fn_id": 1, "class_fn": false, "repo": "binkybear/kismet_web_viewer", "file": "app/netxml_to_csv.py", "last_update_at": "2021-05-22T03:59:05+00:00", "original_content": "def parse_net_xml(doc):\n    total = len(list(doc.getiterator('wireless-network')))\n    tenth = total / 10\n    count = 0\n    clients = list()\n    parsed_list = []\n    for network in doc.getiterator('wireless-network'):\n        count += 1\n        try:\n            if count % tenth == 0:\n                continue\n        except ZeroDivisionError:\n            print('Division by zero error')\n        type = network.attrib['type']\n        channel = network.find('channel').text\n        bssid = network.find('BSSID').text\n        if type == 'probe' or channel == '0':\n            continue\n        encryption = network.getiterator('encryption')\n        privacy = ''\n        cipher = ''\n        auth = ''\n        if encryption is not None:\n            for item in encryption:\n                if item.text.startswith('WEP'):\n                    privacy = 'WEP'\n                    cipher = 'WEP'\n                    auth = ''\n                    break\n                elif item.text.startswith('WPA'):\n                    if item.text.endswith('PSK'):\n                        auth = 'PSK'\n                    elif item.text.endswith('AES-CCM'):\n                        cipher = 'CCMP ' + cipher\n                    elif item.text.endswith('TKIP'):\n                        cipher += 'TKIP '\n                elif item.text == 'None':\n                    privacy = 'OPN'\n        cipher = cipher.strip()\n        if cipher.find('CCMP') > -1:\n            privacy = 'WPA2'\n        if cipher.find('TKIP') > -1:\n            privacy += 'WPA'\n        power = network.find('snr-info')\n        dbm = ''\n        if power is not None:\n            dbm = power.find('max_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('last_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('min_signal_dbm').text\n        ssid = network.find('SSID')\n        essid_text = ''\n        if ssid is not None:\n            essid_text = network.find('SSID').find('essid').text\n        gps = network.find('gps-info')\n        lat, lon = ('', '')\n        if gps is not None:\n            lat = network.find('gps-info').find('min-lat').text\n            lon = network.find('gps-info').find('min-lon').text\n        data = dict(ESSID=essid_text, BSSID=bssid, Channel=channel, Privacy=privacy, Cipher=cipher, Authenticaiton=auth, DBM=dbm)\n        if lat and lon is not None:\n            google_map = 'https://maps.google.com/maps?q=' + lat + ',' + lon + '&ll=' + lat + ',' + lon + '&z=17'\n            google_map_link = '<a href=\"' + google_map + '\" target=\"_blank\"> Google map link</a>'\n            location = dict(Latitude=lat, Longitude=lon, Googlemap=google_map_link)\n        else:\n            not_found = 'Not coordinates available'\n            location = dict(Latitude=not_found, Longitude=not_found)\n        client_list = associatedClients(network, bssid, essid_text)\n        if client_list is not None:\n            data['client'] = client_list\n        else:\n            not_found = 'No clients found'\n            data['client'] = not_found\n        data['location'] = location\n        parsed_list.append(data)\n    return parsed_list", "refactored": true, "question_id": "1d58be5f8c298cf630d37e7dc4f29b9760416dc5_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def parse_net_xml(doc):\n    total = len(list(doc.getiterator('wireless-network')))\n    tenth = total / 10\n    count = 0\n    clients = list()\n    parsed_list = []\n    for network in doc.getiterator('wireless-network'):\n        count += 1\n        try:\n            if count % tenth == 0:\n                continue\n        except ZeroDivisionError:\n            print('Division by zero error')\n        type = network.attrib['type']\n        channel = network.find('channel').text\n        bssid = network.find('BSSID').text\n        if type == 'probe' or channel == '0':\n            continue\n        encryption = network.getiterator('encryption')\n        privacy = ''\n        cipher = ''\n        auth = ''\n        if encryption is not None:\n            _iter14 = encryption\n            while True:\n                try:\n                    item = next(_iter14)\n                except StopIteration:\n                    break\n                if item.text.startswith('WEP'):\n                    privacy = 'WEP'\n                    cipher = 'WEP'\n                    auth = ''\n                    break\n                elif item.text.startswith('WPA'):\n                    if item.text.endswith('PSK'):\n                        auth = 'PSK'\n                    elif item.text.endswith('AES-CCM'):\n                        cipher = 'CCMP ' + cipher\n                    elif item.text.endswith('TKIP'):\n                        cipher += 'TKIP '\n                elif item.text == 'None':\n                    privacy = 'OPN'\n        cipher = cipher.strip()\n        if cipher.find('CCMP') > -1:\n            privacy = 'WPA2'\n        if cipher.find('TKIP') > -1:\n            privacy += 'WPA'\n        power = network.find('snr-info')\n        dbm = ''\n        if power is not None:\n            dbm = power.find('max_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('last_signal_dbm').text\n        if int(dbm) > 1:\n            dbm = power.find('min_signal_dbm').text\n        ssid = network.find('SSID')\n        essid_text = ''\n        if ssid is not None:\n            essid_text = network.find('SSID').find('essid').text\n        gps = network.find('gps-info')\n        lat, lon = ('', '')\n        if gps is not None:\n            lat = network.find('gps-info').find('min-lat').text\n            lon = network.find('gps-info').find('min-lon').text\n        data = dict(ESSID=essid_text, BSSID=bssid, Channel=channel, Privacy=privacy, Cipher=cipher, Authenticaiton=auth, DBM=dbm)\n        if lat and lon is not None:\n            google_map = 'https://maps.google.com/maps?q=' + lat + ',' + lon + '&ll=' + lat + ',' + lon + '&z=17'\n            google_map_link = '<a href=\"' + google_map + '\" target=\"_blank\"> Google map link</a>'\n            location = dict(Latitude=lat, Longitude=lon, Googlemap=google_map_link)\n        else:\n            not_found = 'Not coordinates available'\n            location = dict(Latitude=not_found, Longitude=not_found)\n        client_list = associatedClients(network, bssid, essid_text)\n        if client_list is not None:\n            data['client'] = client_list\n        else:\n            not_found = 'No clients found'\n            data['client'] = not_found\n        data['location'] = location\n        parsed_list.append(data)\n"]]}
{"hexsha": "82966286972b9d3c71d206d1668d569e596aeedd", "ext": "py", "lang": "Python", "content": "@require_context\ndef quota_class_get_all_by_name(context, class_name):\n    authorize_quota_class_context(context, class_name)\n    rows = model_query(context, models.QuotaClass, read_deleted='no').filter_by(class_name=class_name).all()\n    result = {'class_name': class_name}\n    _iter15 = rows\n    while True:\n        try:\n            row = next(_iter15)\n        except StopIteration:\n            break\n        result[row.resource] = row.hard_limit\n    return result", "fn_id": 105, "class_fn": false, "repo": "scottwedge/OpenStack-Stein", "file": "karbor-1.3.0/karbor/db/sqlalchemy/api.py", "last_update_at": "2021-12-13T20:01:25+00:00", "original_content": "@require_context\ndef quota_class_get_all_by_name(context, class_name):\n    authorize_quota_class_context(context, class_name)\n    rows = model_query(context, models.QuotaClass, read_deleted='no').filter_by(class_name=class_name).all()\n    result = {'class_name': class_name}\n    for row in rows:\n        result[row.resource] = row.hard_limit\n    return result", "refactored": true, "question_id": "82966286972b9d3c71d206d1668d569e596aeedd_105", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@require_context\ndef quota_class_get_all_by_name(context, class_name):\n    authorize_quota_class_context(context, class_name)\n    rows = model_query(context, models.QuotaClass, read_deleted='no').filter_by(class_name=class_name).all()\n    result = {'class_name': class_name}\n    _iter15 = rows\n    while True:\n        try:\n            row = next(_iter15)\n        except StopIteration:\n            break\n        result[row.resource] = row.hard_limit\n"]]}
{"hexsha": "52b60b2ec451113de42ad06d277c614499c2007a", "ext": "py", "lang": "Python", "content": "@expose_builtin('del_attrs', unwrap_spec=['obj'])\ndef impl_del_attrs(engine, heap, attvar):\n    if isinstance(attvar, AttVar):\n        if attvar.value_list is not None:\n            _iter16 = attvar.attmap.indexes.iteritems()\n            while True:\n                try:\n                    name, index = next(_iter16)\n                except StopIteration:\n                    break\n                heap.add_trail_atts(attvar, name)\n            attvar.value_list = None", "fn_id": 5, "class_fn": false, "repo": "ForoughA/CORGI", "file": "testnet/prolog/builtin/attvars.py", "last_update_at": "2021-12-11T12:39:51+00:00", "original_content": "@expose_builtin('del_attrs', unwrap_spec=['obj'])\ndef impl_del_attrs(engine, heap, attvar):\n    if isinstance(attvar, AttVar):\n        if attvar.value_list is not None:\n            for name, index in attvar.attmap.indexes.iteritems():\n                heap.add_trail_atts(attvar, name)\n            attvar.value_list = None", "refactored": true, "question_id": "52b60b2ec451113de42ad06d277c614499c2007a_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@expose_builtin('del_attrs', unwrap_spec=['obj'])\ndef impl_del_attrs(engine, heap, attvar):\n    if isinstance(attvar, AttVar):\n        if attvar.value_list is not None:\n            _iter16 = attvar.attmap.indexes.iteritems()\n            while True:\n                try:\n                    name, index = next(_iter16)\n                except StopIteration:\n                    break\n                heap.add_trail_atts(attvar, name)\n"]]}
{"hexsha": "95f32217242b488480e02ece9bfc4b27508cb75d", "ext": "py", "lang": "Python", "content": "def minimal(input_size=2, output_size=2, weight_low=-2, weight_high=2, depth=3):\n    \"\"\" Builds a minimal genome with specified inputs and\n    outputs, weight bounds, depth and one connected node in\n    the first layer.\n\n    :param input_size: Number of input nodes\n    :param output_size: Number of output nodes\n    :param weight_low: Maximum weight on node and edges\n    :param weight_high: Minimum weight on node and edges\n    :param depth: Number of layers in network.\n    :return: Constructed genome.\n    \"\"\"\n    genome = Genome(input_size=input_size, output_size=output_size, weight_low=weight_low, weight_high=weight_high, depth=depth)\n    genome.layers = [genome.inputs, *[[] for _ in range(depth)], genome.outputs]\n    genome.add_node(1)\n    for n in genome.inputs:\n        genome.add_edge(n, genome.layers[1][0])\n    _iter17 = genome.outputs\n    while True:\n        try:\n            n = next(_iter17)\n        except StopIteration:\n            break\n        genome.add_edge(genome.layers[1][0], n)\n    return genome", "fn_id": 1, "class_fn": false, "repo": "mauicv/genrl", "file": "src/gerel/genome/factories.py", "last_update_at": "2021-03-25T23:29:07+00:00", "original_content": "def minimal(input_size=2, output_size=2, weight_low=-2, weight_high=2, depth=3):\n    \"\"\" Builds a minimal genome with specified inputs and\n    outputs, weight bounds, depth and one connected node in\n    the first layer.\n\n    :param input_size: Number of input nodes\n    :param output_size: Number of output nodes\n    :param weight_low: Maximum weight on node and edges\n    :param weight_high: Minimum weight on node and edges\n    :param depth: Number of layers in network.\n    :return: Constructed genome.\n    \"\"\"\n    genome = Genome(input_size=input_size, output_size=output_size, weight_low=weight_low, weight_high=weight_high, depth=depth)\n    genome.layers = [genome.inputs, *[[] for _ in range(depth)], genome.outputs]\n    genome.add_node(1)\n    for n in genome.inputs:\n        genome.add_edge(n, genome.layers[1][0])\n    for n in genome.outputs:\n        genome.add_edge(genome.layers[1][0], n)\n    return genome", "refactored": true, "question_id": "95f32217242b488480e02ece9bfc4b27508cb75d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def minimal(input_size=2, output_size=2, weight_low=-2, weight_high=2, depth=3):\n    \"\"\" Builds a minimal genome with specified inputs and\n    outputs, weight bounds, depth and one connected node in\n    the first layer.\n    :param input_size: Number of input nodes\n    :param output_size: Number of output nodes\n    :param weight_low: Maximum weight on node and edges\n    :param weight_high: Minimum weight on node and edges\n    :param depth: Number of layers in network.\n    :return: Constructed genome.\n    \"\"\"\n    genome = Genome(input_size=input_size, output_size=output_size, weight_low=weight_low, weight_high=weight_high, depth=depth)\n    genome.layers = [genome.inputs, *[[] for _ in range(depth)], genome.outputs]\n    genome.add_node(1)\n    for n in genome.inputs:\n        genome.add_edge(n, genome.layers[1][0])\n    _iter17 = genome.outputs\n    while True:\n        try:\n            n = next(_iter17)\n        except StopIteration:\n            break\n        genome.add_edge(genome.layers[1][0], n)\n"]]}
{"hexsha": "6e58f05000ac2f4b1655ab9325ef2cbb23caea8b", "ext": "py", "lang": "Python", "content": "def remapchunk(seg, chunk, chunkindex, scratchpath, layer=1, bits_per_dim=10, maxmip=11, correctvers=True):\n    x, y, z = chunkindex\n    pcgchunkid = io.pcg.get_chunk_id(layer=layer, x=x, y=y, z=z, bits_per_dim=bits_per_dim)\n    data = seg[chunk.index()]\n    try:\n        if correctvers:\n            mappings = readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n        else:\n            mappings = _readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n    except subprocess.CalledProcessError as e:\n        if data.max() == 0:\n            return data\n        else:\n            raise e\n    _iter18 = mappings\n    while True:\n        try:\n            mapping = next(_iter18)\n        except StopIteration:\n            break\n        data = fastremap.remap(data, mapping, in_place=False, preserve_missing_labels=True)\n    seg[chunk.index()] = data\n    return seg", "fn_id": 2, "class_fn": false, "repo": "ZettaAI/Synaptor", "file": "synaptor/proc/io/agglomeration.py", "last_update_at": "2021-09-13T07:02:16+00:00", "original_content": "def remapchunk(seg, chunk, chunkindex, scratchpath, layer=1, bits_per_dim=10, maxmip=11, correctvers=True):\n    x, y, z = chunkindex\n    pcgchunkid = io.pcg.get_chunk_id(layer=layer, x=x, y=y, z=z, bits_per_dim=bits_per_dim)\n    data = seg[chunk.index()]\n    try:\n        if correctvers:\n            mappings = readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n        else:\n            mappings = _readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n    except subprocess.CalledProcessError as e:\n        if data.max() == 0:\n            return data\n        else:\n            raise e\n    for mapping in mappings:\n        data = fastremap.remap(data, mapping, in_place=False, preserve_missing_labels=True)\n    seg[chunk.index()] = data\n    return seg", "refactored": true, "question_id": "6e58f05000ac2f4b1655ab9325ef2cbb23caea8b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def remapchunk(seg, chunk, chunkindex, scratchpath, layer=1, bits_per_dim=10, maxmip=11, correctvers=True):\n    x, y, z = chunkindex\n    pcgchunkid = io.pcg.get_chunk_id(layer=layer, x=x, y=y, z=z, bits_per_dim=bits_per_dim)\n    data = seg[chunk.index()]\n    try:\n        if correctvers:\n            mappings = readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n        else:\n            mappings = _readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)\n    except subprocess.CalledProcessError as e:\n        if data.max() == 0:\n            return data\n        else:\n            raise e\n    _iter18 = mappings\n    while True:\n        try:\n            mapping = next(_iter18)\n        except StopIteration:\n            break\n        data = fastremap.remap(data, mapping, in_place=False, preserve_missing_labels=True)\n    seg[chunk.index()] = data\n"]]}
{"hexsha": "d2beff782efe625c4f930164ec0ecae6152de846", "ext": "py", "lang": "Python", "content": "def get_final_seats_occupied_based_on_sight(seats: list[str]) -> int:\n    old_grid = Grid(seats)\n    for _ in iter(lambda: 0, 1):\n        if not (new_grid := transform_based_on_los(old_grid)) != old_grid:\n            break\n        old_grid = new_grid\n    return new_grid.count('#')", "fn_id": 2, "class_fn": false, "repo": "pviafore/AdventOfCode2020", "file": "challenge11.py", "last_update_at": "2021-12-09T09:54:54+00:00", "original_content": "def get_final_seats_occupied_based_on_sight(seats: list[str]) -> int:\n    old_grid = Grid(seats)\n    while (new_grid := transform_based_on_los(old_grid)) != old_grid:\n        old_grid = new_grid\n    return new_grid.count('#')", "refactored": true, "question_id": "d2beff782efe625c4f930164ec0ecae6152de846_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_final_seats_occupied_based_on_sight(seats: list[str]) -> int:\n    old_grid = Grid(seats)\n    for _ in iter(lambda: 0, 1):\n        if not (new_grid := transform_based_on_los(old_grid)) != old_grid:\n            break\n        old_grid = new_grid\n"]]}
{"hexsha": "5306ddb4712ea725043386b81d8c897bbc57d019", "ext": "py", "lang": "Python", "content": "def get_first_pos(vcf):\n    p = {}\n    _iter19 = file_util.gzopen(vcf)\n    while True:\n        try:\n            line = next(_iter19)\n        except StopIteration:\n            break\n        line = file_util.decodeb(line)\n        if line[0] != '#':\n            arr = line.split('\\t')\n            print(arr)\n            p['chrom'] = arr[0]\n            p['spos'] = int(arr[1])\n            p['epos'] = int(arr[1])\n            p['str'] = p['chrom'] + ':' + str(p['spos']) + '-' + str(p['epos'])\n    return p", "fn_id": 0, "class_fn": false, "repo": "dbmi-bgm/cgap-annotation-server", "file": "tests/annotviewer.py", "last_update_at": "2021-05-27T14:27:47+00:00", "original_content": "def get_first_pos(vcf):\n    p = {}\n    for line in file_util.gzopen(vcf):\n        line = file_util.decodeb(line)\n        if line[0] != '#':\n            arr = line.split('\\t')\n            print(arr)\n            p['chrom'] = arr[0]\n            p['spos'] = int(arr[1])\n            p['epos'] = int(arr[1])\n            p['str'] = p['chrom'] + ':' + str(p['spos']) + '-' + str(p['epos'])\n    return p", "refactored": true, "question_id": "5306ddb4712ea725043386b81d8c897bbc57d019_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_first_pos(vcf):\n    p = {}\n    _iter19 = file_util.gzopen(vcf)\n    while True:\n        try:\n            line = next(_iter19)\n        except StopIteration:\n            break\n        line = file_util.decodeb(line)\n        if line[0] != '#':\n            arr = line.split('\\t')\n            print(arr)\n            p['chrom'] = arr[0]\n            p['spos'] = int(arr[1])\n            p['epos'] = int(arr[1])\n            p['str'] = p['chrom'] + ':' + str(p['spos']) + '-' + str(p['epos'])\n"]]}
{"hexsha": "a0e82345e90e71c8a988186287df593c48a61aad", "ext": "py", "lang": "Python", "content": "async def selectDB(userid):\n    conn = sqlite3.connect('ID_DATA.db')\n    c = conn.cursor()\n    cursor = c.execute('SELECT *  FROM UIDDATA WHERE USERID = ?', (userid,))\n    _iter20 = cursor\n    while True:\n        try:\n            row = next(_iter20)\n        except StopIteration:\n            break\n        if row[0]:\n            if row[2]:\n                return [row[2], 3]\n            elif row[1]:\n                return [row[1], 2]\n            else:\n                return None\n        else:\n            return None", "fn_id": 1, "class_fn": false, "repo": "Twip-Emma/QQbot-Twip", "file": "bot_plugins/GenshinUID/getDB.py", "last_update_at": "2021-12-23T15:36:48+00:00", "original_content": "async def selectDB(userid):\n    conn = sqlite3.connect('ID_DATA.db')\n    c = conn.cursor()\n    cursor = c.execute('SELECT *  FROM UIDDATA WHERE USERID = ?', (userid,))\n    for row in cursor:\n        if row[0]:\n            if row[2]:\n                return [row[2], 3]\n            elif row[1]:\n                return [row[1], 2]\n            else:\n                return None\n        else:\n            return None", "refactored": true, "question_id": "a0e82345e90e71c8a988186287df593c48a61aad_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async def selectDB(userid):\n    conn = sqlite3.connect('ID_DATA.db')\n    c = conn.cursor()\n    cursor = c.execute('SELECT *  FROM UIDDATA WHERE USERID = ?', (userid,))\n    _iter20 = cursor\n    while True:\n        try:\n            row = next(_iter20)\n        except StopIteration:\n            break\n        if row[0]:\n            if row[2]:\n                return [row[2], 3]\n            elif row[1]:\n                return [row[1], 2]\n            else:\n                return None\n        else:\n"]]}
{"hexsha": "1183023f80519f66fa1c64d6437b4cc896c39a21", "ext": "py", "lang": "Python", "content": "def main():\n    args = arguments().parse_args()\n    sys.path.insert(0, os.getcwd())\n    conn = get_connection(args)\n    headers = None\n    editfile = tempfile.NamedTemporaryFile()\n    with open(editfile.name, 'w', newline='') as cfile:\n        headers = write_csv(cfile, conn, args.table)\n    reffile = tempfile.NamedTemporaryFile()\n    shutil.copy(editfile.name, reffile.name)\n    call_vim(editfile.name)\n    for _ in iter(lambda: 0, 1):\n        if not True:\n            break\n        try:\n            process_changes(reffile, editfile, conn, args.table, headers)\n            break\n        except Exception as err:\n            print('Failed to save changes: ', err)\n            q = '(C)ancel, (r)etry save, (e)dit the file again?'\n            cmd = query_options(q, ('c', 'r', 'e'))\n            if cmd == 'c':\n                print('Changes cancelled')\n                break\n            elif cmd == 'r':\n                continue\n            elif cmd == 'e':\n                call_vim(editfile.name)\n            else:\n                raise ValueError('Not a command')", "fn_id": 14, "class_fn": false, "repo": "BnMcGn/vibase", "file": "src/vibase.py", "last_update_at": "2021-10-17T07:52:04+00:00", "original_content": "def main():\n    args = arguments().parse_args()\n    sys.path.insert(0, os.getcwd())\n    conn = get_connection(args)\n    headers = None\n    editfile = tempfile.NamedTemporaryFile()\n    with open(editfile.name, 'w', newline='') as cfile:\n        headers = write_csv(cfile, conn, args.table)\n    reffile = tempfile.NamedTemporaryFile()\n    shutil.copy(editfile.name, reffile.name)\n    call_vim(editfile.name)\n    while True:\n        try:\n            process_changes(reffile, editfile, conn, args.table, headers)\n            break\n        except Exception as err:\n            print('Failed to save changes: ', err)\n            q = '(C)ancel, (r)etry save, (e)dit the file again?'\n            cmd = query_options(q, ('c', 'r', 'e'))\n            if cmd == 'c':\n                print('Changes cancelled')\n                break\n            elif cmd == 'r':\n                continue\n            elif cmd == 'e':\n                call_vim(editfile.name)\n            else:\n                raise ValueError('Not a command')", "refactored": true, "question_id": "1183023f80519f66fa1c64d6437b4cc896c39a21_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def main():\n    args = arguments().parse_args()\n    sys.path.insert(0, os.getcwd())\n    conn = get_connection(args)\n    headers = None\n    editfile = tempfile.NamedTemporaryFile()\n    with open(editfile.name, 'w', newline='') as cfile:\n        headers = write_csv(cfile, conn, args.table)\n    reffile = tempfile.NamedTemporaryFile()\n    shutil.copy(editfile.name, reffile.name)\n    call_vim(editfile.name)\n    for _ in iter(lambda: 0, 1):\n        if not True:\n            break\n        try:\n            process_changes(reffile, editfile, conn, args.table, headers)\n            break\n        except Exception as err:\n            print('Failed to save changes: ', err)\n            q = '(C)ancel, (r)etry save, (e)dit the file again?'\n            cmd = query_options(q, ('c', 'r', 'e'))\n            if cmd == 'c':\n                print('Changes cancelled')\n                break\n            elif cmd == 'r':\n                continue\n            elif cmd == 'e':\n                call_vim(editfile.name)\n            else:\n"]]}
{"hexsha": "4621fba19fcf958d4877519ee2e7db8ca9d513e9", "ext": "py", "lang": "Python", "content": "def search_froms():\n    \"\"\"\n    Search for unique \"from xxx import yyy\" statements, returning a sorted list.\n    \"\"\"\n    _froms = []\n    _lib_dir_regex = '{}\\\\.'.format(LIB_DIR)\n    _regex = '^[ ]*from '\n    print(Fore.GREEN + '\\nimport list contents:' + Style.RESET_ALL)\n    _iter21 = _find_in_files('^[ ]*from.*import.*')\n    while True:\n        try:\n            _items = next(_iter21)\n        except StopIteration:\n            break\n        _item = _items[0]\n        _filename = _items[1]\n        _library_name = re.sub(' import.*', '', _item)\n        _library_name = re.sub(_regex, '', _library_name).strip()\n        if IGNORE_LIB and re.match(_lib_dir_regex, _library_name):\n            pass\n        elif len(_library_name) > 1 and _library_name not in _froms:\n            _froms.append(_library_name)\n    _froms.sort()\n    print(Fore.CYAN + \"\\n-- complete: {:d} instances of '{}' found.\".format(len(_froms), _regex) + Style.RESET_ALL)\n    return _froms", "fn_id": 3, "class_fn": false, "repo": "ifurusato/ros", "file": "import_report.py", "last_update_at": "2021-07-23T14:20:05+00:00", "original_content": "def search_froms():\n    \"\"\"\n    Search for unique \"from xxx import yyy\" statements, returning a sorted list.\n    \"\"\"\n    _froms = []\n    _lib_dir_regex = '{}\\\\.'.format(LIB_DIR)\n    _regex = '^[ ]*from '\n    print(Fore.GREEN + '\\nimport list contents:' + Style.RESET_ALL)\n    for _items in _find_in_files('^[ ]*from.*import.*'):\n        _item = _items[0]\n        _filename = _items[1]\n        _library_name = re.sub(' import.*', '', _item)\n        _library_name = re.sub(_regex, '', _library_name).strip()\n        if IGNORE_LIB and re.match(_lib_dir_regex, _library_name):\n            pass\n        elif len(_library_name) > 1 and _library_name not in _froms:\n            _froms.append(_library_name)\n    _froms.sort()\n    print(Fore.CYAN + \"\\n-- complete: {:d} instances of '{}' found.\".format(len(_froms), _regex) + Style.RESET_ALL)\n    return _froms", "refactored": true, "question_id": "4621fba19fcf958d4877519ee2e7db8ca9d513e9_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def search_froms():\n    \"\"\"\n    Search for unique \"from xxx import yyy\" statements, returning a sorted list.\n    \"\"\"\n    _froms = []\n    _lib_dir_regex = '{}\\\\.'.format(LIB_DIR)\n    _regex = '^[ ]*from '\n    print(Fore.GREEN + '\\nimport list contents:' + Style.RESET_ALL)\n    _iter21 = _find_in_files('^[ ]*from.*import.*')\n    while True:\n        try:\n            _items = next(_iter21)\n        except StopIteration:\n            break\n        _item = _items[0]\n        _filename = _items[1]\n        _library_name = re.sub(' import.*', '', _item)\n        _library_name = re.sub(_regex, '', _library_name).strip()\n        if IGNORE_LIB and re.match(_lib_dir_regex, _library_name):\n            pass\n        elif len(_library_name) > 1 and _library_name not in _froms:\n            _froms.append(_library_name)\n    _froms.sort()\n    print(Fore.CYAN + \"\\n-- complete: {:d} instances of '{}' found.\".format(len(_froms), _regex) + Style.RESET_ALL)\n"]]}
{"hexsha": "df37bb46962a858756a40ea08c445056a8eba2a4", "ext": "py", "lang": "Python", "content": "def config_to_functions(config):\n    \"\"\"\n    Takes in the data for a config and returns a list of functions to call the meet it's criteria.\n    list of str -> list of (none -> (str, any))\n    \"\"\"\n    functions = []\n    in_multiline_comment = False\n    _iter22 = config\n    while True:\n        try:\n            line = next(_iter22)\n        except StopIteration:\n            break\n        line = remove_new_lines(line)\n        in_multiline_comment = in_multiline_comment or line_starts_multiline_comment_start(line)\n        multiline_comment_end = line_starts_multiline_comment_end(line)\n        if not in_multiline_comment and multiline_comment_end:\n            message = 'Multiline comment end: ' + constants.MULTILINE_COMMENT_END\n            message += ' must inclose a comment.'\n            raise Exception(message)\n        if multiline_comment_end:\n            in_multiline_comment = False\n        if is_line_commented(line) or is_empty_line(line) or in_multiline_comment or multiline_comment_end:\n            continue\n        check_config_line(line)\n        command_type = get_command_type(line)\n        if not is_type(command_type) and (not is_complex_type(command_type)):\n            on_not_valid_type(command_type)\n        definition = get_command_definition(line)\n        functions.append(build_input_func(any_type_to_input_functions(command_type, definition), command_type))\n    if in_multiline_comment:\n        message = 'Multiline comment start: ' + constants.MULTILINE_COMMENT_START\n        message += ' must be inclosed with: ' + constants.MULTILINE_COMMENT_END\n        raise Exception(message)\n    return functions", "fn_id": 1, "class_fn": false, "repo": "FroshTheFrog/life_logger", "file": "config_utils.py", "last_update_at": "2021-03-19T03:40:42+00:00", "original_content": "def config_to_functions(config):\n    \"\"\"\n    Takes in the data for a config and returns a list of functions to call the meet it's criteria.\n    list of str -> list of (none -> (str, any))\n    \"\"\"\n    functions = []\n    in_multiline_comment = False\n    for line in config:\n        line = remove_new_lines(line)\n        in_multiline_comment = in_multiline_comment or line_starts_multiline_comment_start(line)\n        multiline_comment_end = line_starts_multiline_comment_end(line)\n        if not in_multiline_comment and multiline_comment_end:\n            message = 'Multiline comment end: ' + constants.MULTILINE_COMMENT_END\n            message += ' must inclose a comment.'\n            raise Exception(message)\n        if multiline_comment_end:\n            in_multiline_comment = False\n        if is_line_commented(line) or is_empty_line(line) or in_multiline_comment or multiline_comment_end:\n            continue\n        check_config_line(line)\n        command_type = get_command_type(line)\n        if not is_type(command_type) and (not is_complex_type(command_type)):\n            on_not_valid_type(command_type)\n        definition = get_command_definition(line)\n        functions.append(build_input_func(any_type_to_input_functions(command_type, definition), command_type))\n    if in_multiline_comment:\n        message = 'Multiline comment start: ' + constants.MULTILINE_COMMENT_START\n        message += ' must be inclosed with: ' + constants.MULTILINE_COMMENT_END\n        raise Exception(message)\n    return functions", "refactored": true, "question_id": "df37bb46962a858756a40ea08c445056a8eba2a4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def config_to_functions(config):\n    \"\"\"\n    Takes in the data for a config and returns a list of functions to call the meet it's criteria.\n    list of str -> list of (none -> (str, any))\n    \"\"\"\n    functions = []\n    in_multiline_comment = False\n    _iter22 = config\n    while True:\n        try:\n            line = next(_iter22)\n        except StopIteration:\n            break\n        line = remove_new_lines(line)\n        in_multiline_comment = in_multiline_comment or line_starts_multiline_comment_start(line)\n        multiline_comment_end = line_starts_multiline_comment_end(line)\n        if not in_multiline_comment and multiline_comment_end:\n            message = 'Multiline comment end: ' + constants.MULTILINE_COMMENT_END\n            message += ' must inclose a comment.'\n            raise Exception(message)\n        if multiline_comment_end:\n            in_multiline_comment = False\n        if is_line_commented(line) or is_empty_line(line) or in_multiline_comment or multiline_comment_end:\n            continue\n        check_config_line(line)\n        command_type = get_command_type(line)\n        if not is_type(command_type) and (not is_complex_type(command_type)):\n            on_not_valid_type(command_type)\n        definition = get_command_definition(line)\n        functions.append(build_input_func(any_type_to_input_functions(command_type, definition), command_type))\n    if in_multiline_comment:\n        message = 'Multiline comment start: ' + constants.MULTILINE_COMMENT_START\n        message += ' must be inclosed with: ' + constants.MULTILINE_COMMENT_END\n        raise Exception(message)\n"]]}
{"hexsha": "0778557121cb9d3021b5bcd3f81aaa9f8612eb04", "ext": "py", "lang": "Python", "content": "def write_glottal_tier(utterance, tao):\n    return_str = ''\n    glottal_dur = utterance.duration\n    _iter23 = range(len(utterance.duration))\n    while True:\n        try:\n            ii = next(_iter23)\n        except StopIteration:\n            break\n        return_str += f'    <gesture value=\"{utterance.glottal[ii]}\" slope=\"0.000000\" duration_s=\"{utterance.duration[ii]:.6f}\" time_constant_s=\"{tao:.6f}\" neutral=\"0\" />\\n'\n    return return_str", "fn_id": 4, "class_fn": false, "repo": "quantling/create_vtl_corpus", "file": "generate_gestural_score.py", "last_update_at": "2021-11-01T02:35:12+00:00", "original_content": "def write_glottal_tier(utterance, tao):\n    return_str = ''\n    glottal_dur = utterance.duration\n    for ii in range(len(utterance.duration)):\n        return_str += f'    <gesture value=\"{utterance.glottal[ii]}\" slope=\"0.000000\" duration_s=\"{utterance.duration[ii]:.6f}\" time_constant_s=\"{tao:.6f}\" neutral=\"0\" />\\n'\n    return return_str", "refactored": true, "question_id": "0778557121cb9d3021b5bcd3f81aaa9f8612eb04_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def write_glottal_tier(utterance, tao):\n    return_str = ''\n    glottal_dur = utterance.duration\n    _iter23 = range(len(utterance.duration))\n    while True:\n        try:\n            ii = next(_iter23)\n        except StopIteration:\n            break\n        return_str += f'    <gesture value=\"{utterance.glottal[ii]}\" slope=\"0.000000\" duration_s=\"{utterance.duration[ii]:.6f}\" time_constant_s=\"{tao:.6f}\" neutral=\"0\" />\\n'\n"]]}
{"hexsha": "d9fc432fc00d588e5c0efee2aee23a3f4e8a0c91", "ext": "py", "lang": "Python", "content": "def main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    usr_dir.import_usr_dir(FLAGS.t2t_usr_dir)\n    trainer_utils.log_registry()\n    trainer_utils.validate_flags()\n    output_dir = os.path.expanduser(FLAGS.output_dir)\n    tmp_dir = os.path.expanduser(FLAGS.tmp_dir)\n    if not FLAGS.data_dir:\n        raise ValueError('You must specify a --data_dir')\n    data_dir = os.path.expanduser(FLAGS.data_dir)\n    tf.gfile.MakeDirs(output_dir)\n    if FLAGS.generate_data:\n        tf.gfile.MakeDirs(data_dir)\n        tf.gfile.MakeDirs(tmp_dir)\n        _iter24 = FLAGS.problems.split('-')\n        while True:\n            try:\n                problem_name = next(_iter24)\n            except StopIteration:\n                break\n            tf.logging.info('Generating data for %s' % problem_name)\n            problem = registry.problem(problem_name)\n            problem.generate_data(data_dir, tmp_dir)\n    trainer_utils.run(data_dir=data_dir, model=FLAGS.model, output_dir=output_dir, train_steps=FLAGS.train_steps, eval_steps=FLAGS.eval_steps, schedule=FLAGS.schedule)", "fn_id": 0, "class_fn": false, "repo": "ctuning/ck-ml", "file": "program/tensor2tensor-attention-tf/source/tensor2tensor/tensor2tensor/bin/t2t-trainer.py", "last_update_at": "2021-09-14T14:14:10+00:00", "original_content": "def main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    usr_dir.import_usr_dir(FLAGS.t2t_usr_dir)\n    trainer_utils.log_registry()\n    trainer_utils.validate_flags()\n    output_dir = os.path.expanduser(FLAGS.output_dir)\n    tmp_dir = os.path.expanduser(FLAGS.tmp_dir)\n    if not FLAGS.data_dir:\n        raise ValueError('You must specify a --data_dir')\n    data_dir = os.path.expanduser(FLAGS.data_dir)\n    tf.gfile.MakeDirs(output_dir)\n    if FLAGS.generate_data:\n        tf.gfile.MakeDirs(data_dir)\n        tf.gfile.MakeDirs(tmp_dir)\n        for problem_name in FLAGS.problems.split('-'):\n            tf.logging.info('Generating data for %s' % problem_name)\n            problem = registry.problem(problem_name)\n            problem.generate_data(data_dir, tmp_dir)\n    trainer_utils.run(data_dir=data_dir, model=FLAGS.model, output_dir=output_dir, train_steps=FLAGS.train_steps, eval_steps=FLAGS.eval_steps, schedule=FLAGS.schedule)", "refactored": true, "question_id": "d9fc432fc00d588e5c0efee2aee23a3f4e8a0c91_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def main(_):\n    tf.logging.set_verbosity(tf.logging.INFO)\n    usr_dir.import_usr_dir(FLAGS.t2t_usr_dir)\n    trainer_utils.log_registry()\n    trainer_utils.validate_flags()\n    output_dir = os.path.expanduser(FLAGS.output_dir)\n    tmp_dir = os.path.expanduser(FLAGS.tmp_dir)\n    if not FLAGS.data_dir:\n        raise ValueError('You must specify a --data_dir')\n    data_dir = os.path.expanduser(FLAGS.data_dir)\n    tf.gfile.MakeDirs(output_dir)\n    if FLAGS.generate_data:\n        tf.gfile.MakeDirs(data_dir)\n        tf.gfile.MakeDirs(tmp_dir)\n        _iter24 = FLAGS.problems.split('-')\n        while True:\n            try:\n                problem_name = next(_iter24)\n            except StopIteration:\n                break\n            tf.logging.info('Generating data for %s' % problem_name)\n            problem = registry.problem(problem_name)\n            problem.generate_data(data_dir, tmp_dir)\n"]]}
{"hexsha": "7354359d5802ce995119a41c90b85838a4204d5d", "ext": "py", "lang": "Python", "content": "@app.route('/commands_per_day')\n@cache(time=datetime.timedelta(minutes=DEFAULT_CACHE_MINUTES))\ndef commands_per_day():\n    command_names = [row.get('command_name') for row in bigquery_client.query('SELECT DISTINCT command_name FROM analytics.commands').result()]\n    print(command_names)\n    command_names = filter(lambda item: item not in ['list', 'set', 'voices', 'languages', 'property'], command_names)\n    result = {}\n    _iter25 = command_names\n    while True:\n        try:\n            command_name = next(_iter25)\n        except StopIteration:\n            break\n        usage = {date: {'text_count': 0, 'slash_count': 0} for date in get_days_in_range(datetime.datetime(2021, 1, 1), datetime.datetime.today())}\n        query = 'SELECT DATE(time) as d, COUNTIF(NOT is_slash) as cnt, COUNTIF(is_slash) as slash_cnt FROM analytics.commands WHERE command_name = @command_name GROUP BY d ORDER BY d'\n        job_config = bigquery.QueryJobConfig(query_parameters=[bigquery.ScalarQueryParameter('command_name', 'STRING', command_name)])\n        for row in bigquery_client.query(query, job_config=job_config).result():\n            d = row_to_dict(row)\n            usage[d['d']]['text_count'] = d['cnt']\n            usage[d['d']]['slash_count'] = d['slash_cnt']\n        result[command_name] = [{'date': date, **usage[date]} for date in usage.keys()]\n    response = jsonify(result)\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    return response", "fn_id": 4, "class_fn": false, "repo": "TychoTheTaco/Discord-Dictionary-Bot", "file": "api/main.py", "last_update_at": "2021-12-12T20:35:49+00:00", "original_content": "@app.route('/commands_per_day')\n@cache(time=datetime.timedelta(minutes=DEFAULT_CACHE_MINUTES))\ndef commands_per_day():\n    command_names = [row.get('command_name') for row in bigquery_client.query('SELECT DISTINCT command_name FROM analytics.commands').result()]\n    print(command_names)\n    command_names = filter(lambda item: item not in ['list', 'set', 'voices', 'languages', 'property'], command_names)\n    result = {}\n    for command_name in command_names:\n        usage = {date: {'text_count': 0, 'slash_count': 0} for date in get_days_in_range(datetime.datetime(2021, 1, 1), datetime.datetime.today())}\n        query = 'SELECT DATE(time) as d, COUNTIF(NOT is_slash) as cnt, COUNTIF(is_slash) as slash_cnt FROM analytics.commands WHERE command_name = @command_name GROUP BY d ORDER BY d'\n        job_config = bigquery.QueryJobConfig(query_parameters=[bigquery.ScalarQueryParameter('command_name', 'STRING', command_name)])\n        for row in bigquery_client.query(query, job_config=job_config).result():\n            d = row_to_dict(row)\n            usage[d['d']]['text_count'] = d['cnt']\n            usage[d['d']]['slash_count'] = d['slash_cnt']\n        result[command_name] = [{'date': date, **usage[date]} for date in usage.keys()]\n    response = jsonify(result)\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    return response", "refactored": true, "question_id": "7354359d5802ce995119a41c90b85838a4204d5d_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@app.route('/commands_per_day')\n@cache(time=datetime.timedelta(minutes=DEFAULT_CACHE_MINUTES))\ndef commands_per_day():\n    command_names = [row.get('command_name') for row in bigquery_client.query('SELECT DISTINCT command_name FROM analytics.commands').result()]\n    print(command_names)\n    command_names = filter(lambda item: item not in ['list', 'set', 'voices', 'languages', 'property'], command_names)\n    result = {}\n    _iter25 = command_names\n    while True:\n        try:\n            command_name = next(_iter25)\n        except StopIteration:\n            break\n        usage = {date: {'text_count': 0, 'slash_count': 0} for date in get_days_in_range(datetime.datetime(2021, 1, 1), datetime.datetime.today())}\n        query = 'SELECT DATE(time) as d, COUNTIF(NOT is_slash) as cnt, COUNTIF(is_slash) as slash_cnt FROM analytics.commands WHERE command_name = @command_name GROUP BY d ORDER BY d'\n        job_config = bigquery.QueryJobConfig(query_parameters=[bigquery.ScalarQueryParameter('command_name', 'STRING', command_name)])\n        for row in bigquery_client.query(query, job_config=job_config).result():\n            d = row_to_dict(row)\n            usage[d['d']]['text_count'] = d['cnt']\n            usage[d['d']]['slash_count'] = d['slash_cnt']\n        result[command_name] = [{'date': date, **usage[date]} for date in usage.keys()]\n    response = jsonify(result)\n    response.headers['Access-Control-Allow-Origin'] = '*'\n"]]}
{"hexsha": "8e27225db54d8f1ce0cedbcc4f4b9dfe2b6fdaf9", "ext": "py", "lang": "Python", "content": "def draw_iterations(g, eval_map_function, x0, n):\n\n    def draw_mid_point_arrows(x, x_next, both=True):\n        if x_next > x:\n            arrow_direction_angles = (0.5 * math.pi, 0)\n        else:\n            arrow_direction_angles = (-0.5 * math.pi, math.pi)\n        g.draw_arrow_tip((x, mid_value), arrow_direction_angles[0])\n        if both:\n            g.draw_arrow_tip((mid_value, x_next), arrow_direction_angles[1])\n    xs = [x0]\n    _iter26 = range(n)\n    while True:\n        try:\n            i = next(_iter26)\n        except StopIteration:\n            break\n        xs.append(eval_map_function(xs[-1]))\n    g.set_dash_dash_structure(12, 4, units='svg')\n    g.set_dash_mode('dash')\n    g.set_svg_options(stroke_width=iterations_stroke_w, units='svg')\n    g.set_arrow_options(width=iteration_arrow_rel_size * arrow_size, curvature=0, units='svg')\n    g.set_point_size(0.01)\n    g.draw_line_segment((x0, 0), (x0, x0))\n    for i, x in enumerate(xs[:-2]):\n        x_next = xs[i + 1]\n        g.draw_polyline([(x, x), (x, x_next), (x_next, x_next)])\n        mid_value = 0.5 * (x + x_next)\n        draw_mid_point_arrows(x, x_next)\n    g.draw_polyline([(xs[-2], xs[-2]), (xs[-2], xs[-1])])\n    g.draw_point((xs[-2], xs[-1]))\n    draw_mid_point_arrows(xs[-2], xs[-1], both=False)\n    g.reset_dash_and_dot_structures()", "fn_id": 2, "class_fn": false, "repo": "alexn11/mathsvg", "file": "more-examples/iteration-graph.py", "last_update_at": "2021-11-27T08:46:20+00:00", "original_content": "def draw_iterations(g, eval_map_function, x0, n):\n\n    def draw_mid_point_arrows(x, x_next, both=True):\n        if x_next > x:\n            arrow_direction_angles = (0.5 * math.pi, 0)\n        else:\n            arrow_direction_angles = (-0.5 * math.pi, math.pi)\n        g.draw_arrow_tip((x, mid_value), arrow_direction_angles[0])\n        if both:\n            g.draw_arrow_tip((mid_value, x_next), arrow_direction_angles[1])\n    xs = [x0]\n    for i in range(n):\n        xs.append(eval_map_function(xs[-1]))\n    g.set_dash_dash_structure(12, 4, units='svg')\n    g.set_dash_mode('dash')\n    g.set_svg_options(stroke_width=iterations_stroke_w, units='svg')\n    g.set_arrow_options(width=iteration_arrow_rel_size * arrow_size, curvature=0, units='svg')\n    g.set_point_size(0.01)\n    g.draw_line_segment((x0, 0), (x0, x0))\n    for i, x in enumerate(xs[:-2]):\n        x_next = xs[i + 1]\n        g.draw_polyline([(x, x), (x, x_next), (x_next, x_next)])\n        mid_value = 0.5 * (x + x_next)\n        draw_mid_point_arrows(x, x_next)\n    g.draw_polyline([(xs[-2], xs[-2]), (xs[-2], xs[-1])])\n    g.draw_point((xs[-2], xs[-1]))\n    draw_mid_point_arrows(xs[-2], xs[-1], both=False)\n    g.reset_dash_and_dot_structures()", "refactored": true, "question_id": "8e27225db54d8f1ce0cedbcc4f4b9dfe2b6fdaf9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def draw_iterations(g, eval_map_function, x0, n):\n    def draw_mid_point_arrows(x, x_next, both=True):\n        if x_next > x:\n            arrow_direction_angles = (0.5 * math.pi, 0)\n        else:\n            arrow_direction_angles = (-0.5 * math.pi, math.pi)\n        g.draw_arrow_tip((x, mid_value), arrow_direction_angles[0])\n        if both:\n            g.draw_arrow_tip((mid_value, x_next), arrow_direction_angles[1])\n    xs = [x0]\n    _iter26 = range(n)\n    while True:\n        try:\n            i = next(_iter26)\n        except StopIteration:\n            break\n        xs.append(eval_map_function(xs[-1]))\n    g.set_dash_dash_structure(12, 4, units='svg')\n    g.set_dash_mode('dash')\n    g.set_svg_options(stroke_width=iterations_stroke_w, units='svg')\n    g.set_arrow_options(width=iteration_arrow_rel_size * arrow_size, curvature=0, units='svg')\n    g.set_point_size(0.01)\n    g.draw_line_segment((x0, 0), (x0, x0))\n    for i, x in enumerate(xs[:-2]):\n        x_next = xs[i + 1]\n        g.draw_polyline([(x, x), (x, x_next), (x_next, x_next)])\n        mid_value = 0.5 * (x + x_next)\n        draw_mid_point_arrows(x, x_next)\n    g.draw_polyline([(xs[-2], xs[-2]), (xs[-2], xs[-1])])\n    g.draw_point((xs[-2], xs[-1]))\n    draw_mid_point_arrows(xs[-2], xs[-1], both=False)\n"]]}
{"hexsha": "1a9febc6fc48fe142ca3755fceef4aa604dfb595", "ext": "py", "lang": "Python", "content": "def assemble(mappings, sequence_file, out_file, min_overlap, max_overhang, min_length):\n    graph, assembled = OverlapGraph.parse_paf(mappings, min_overlap, max_overhang)\n    paths = graph.max_paths()\n    sequences = parse_fasta(sequence_file)\n    with open(out_file, 'w') as f:\n        for path in paths:\n            seq, contained_reads, name = construct_merged_sequence(path, graph, sequences)\n            assembled += contained_reads\n            if len(seq) > min_length:\n                f.write('>%s\\n%s\\n' % (name, seq))\n        _iter27 = sequences.items()\n        while True:\n            try:\n                n, s = next(_iter27)\n            except StopIteration:\n                break\n            if n in assembled:\n                continue\n            if len(s) < min_length:\n                continue\n            f.write('>%s\\n%s\\n' % (n, s))", "fn_id": 2, "class_fn": false, "repo": "rikuu/hgga", "file": "asm_node.py", "last_update_at": "2021-04-09T21:56:00+00:00", "original_content": "def assemble(mappings, sequence_file, out_file, min_overlap, max_overhang, min_length):\n    graph, assembled = OverlapGraph.parse_paf(mappings, min_overlap, max_overhang)\n    paths = graph.max_paths()\n    sequences = parse_fasta(sequence_file)\n    with open(out_file, 'w') as f:\n        for path in paths:\n            seq, contained_reads, name = construct_merged_sequence(path, graph, sequences)\n            assembled += contained_reads\n            if len(seq) > min_length:\n                f.write('>%s\\n%s\\n' % (name, seq))\n        for n, s in sequences.items():\n            if n in assembled:\n                continue\n            if len(s) < min_length:\n                continue\n            f.write('>%s\\n%s\\n' % (n, s))", "refactored": true, "question_id": "1a9febc6fc48fe142ca3755fceef4aa604dfb595_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def assemble(mappings, sequence_file, out_file, min_overlap, max_overhang, min_length):\n    graph, assembled = OverlapGraph.parse_paf(mappings, min_overlap, max_overhang)\n    paths = graph.max_paths()\n    sequences = parse_fasta(sequence_file)\n    with open(out_file, 'w') as f:\n        for path in paths:\n            seq, contained_reads, name = construct_merged_sequence(path, graph, sequences)\n            assembled += contained_reads\n            if len(seq) > min_length:\n                f.write('>%s\\n%s\\n' % (name, seq))\n        _iter27 = sequences.items()\n        while True:\n            try:\n                n, s = next(_iter27)\n            except StopIteration:\n                break\n            if n in assembled:\n                continue\n            if len(s) < min_length:\n                continue\n"]]}
{"hexsha": "704ba9392622d555589cf12d7af04a6f1811b620", "ext": "py", "lang": "Python", "content": "def energy_plot(scenarios, color_dict):\n    \"\"\"\n    \"\"\"\n    layout = go.Layout(barmode='relative', legend_orientation='h', title='Aggregated supply and demand', paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', yaxis=dict(title='Energy in {}'.format('TWh'), titlefont=dict(size=16, color='rgb(107, 107, 107)'), tickfont=dict(size=14, color='rgb(107, 107, 107)')))\n    data = []\n    _iter28 = scenarios.T.iteritems()\n    while True:\n        try:\n            idx, row = next(_iter28)\n        except StopIteration:\n            break\n        if '-cos' in idx:\n            legend = False\n        else:\n            legend = True\n        data.append(go.Bar(x=row.index, y=row.values, text=[v.round(1) if v > 20 or v < -20 else None for v in row.values], hovertext=[', '.join([str(v.round(2)), idx.replace('-cos', '')]) for v in row.values], hoverinfo='text', textposition='auto', showlegend=legend, name=idx, marker=dict(color=color_dict.get(idx.replace('-cos', ''), 'gray'))))\n    return {'data': data, 'layout': layout}", "fn_id": 3, "class_fn": false, "repo": "znes/angus-scenarios", "file": "documentation/plotly_plots.py", "last_update_at": "2021-06-02T01:43:57+00:00", "original_content": "def energy_plot(scenarios, color_dict):\n    \"\"\"\n    \"\"\"\n    layout = go.Layout(barmode='relative', legend_orientation='h', title='Aggregated supply and demand', paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', yaxis=dict(title='Energy in {}'.format('TWh'), titlefont=dict(size=16, color='rgb(107, 107, 107)'), tickfont=dict(size=14, color='rgb(107, 107, 107)')))\n    data = []\n    for idx, row in scenarios.T.iteritems():\n        if '-cos' in idx:\n            legend = False\n        else:\n            legend = True\n        data.append(go.Bar(x=row.index, y=row.values, text=[v.round(1) if v > 20 or v < -20 else None for v in row.values], hovertext=[', '.join([str(v.round(2)), idx.replace('-cos', '')]) for v in row.values], hoverinfo='text', textposition='auto', showlegend=legend, name=idx, marker=dict(color=color_dict.get(idx.replace('-cos', ''), 'gray'))))\n    return {'data': data, 'layout': layout}", "refactored": true, "question_id": "704ba9392622d555589cf12d7af04a6f1811b620_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def energy_plot(scenarios, color_dict):\n    \"\"\"\n    \"\"\"\n    layout = go.Layout(barmode='relative', legend_orientation='h', title='Aggregated supply and demand', paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', yaxis=dict(title='Energy in {}'.format('TWh'), titlefont=dict(size=16, color='rgb(107, 107, 107)'), tickfont=dict(size=14, color='rgb(107, 107, 107)')))\n    data = []\n    _iter28 = scenarios.T.iteritems()\n    while True:\n        try:\n            idx, row = next(_iter28)\n        except StopIteration:\n            break\n        if '-cos' in idx:\n            legend = False\n        else:\n            legend = True\n        data.append(go.Bar(x=row.index, y=row.values, text=[v.round(1) if v > 20 or v < -20 else None for v in row.values], hovertext=[', '.join([str(v.round(2)), idx.replace('-cos', '')]) for v in row.values], hoverinfo='text', textposition='auto', showlegend=legend, name=idx, marker=dict(color=color_dict.get(idx.replace('-cos', ''), 'gray'))))\n"]]}
{"hexsha": "1407f6d79ec90ec0ceecb5413d805601158c4cae", "ext": "py", "lang": "Python", "content": "def get_bot() -> Bot:\n    _iter29 = DRIVER.bots.values()\n    while True:\n        try:\n            bot = next(_iter29)\n        except StopIteration:\n            break\n        return bot\n    return None", "fn_id": 0, "class_fn": false, "repo": "7sDream/nonebot_plugin_bam", "file": "nonebot_plugin_bam/common.py", "last_update_at": "2021-12-28T07:13:51+00:00", "original_content": "def get_bot() -> Bot:\n    for bot in DRIVER.bots.values():\n        return bot\n    return None", "refactored": true, "question_id": "1407f6d79ec90ec0ceecb5413d805601158c4cae_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_bot() -> Bot:\n    _iter29 = DRIVER.bots.values()\n    while True:\n        try:\n            bot = next(_iter29)\n        except StopIteration:\n            break\n        return bot\n"]]}
{"hexsha": "96a9ce1af1b9abc8e61b5491562c9ddee1c883c3", "ext": "py", "lang": "Python", "content": "def infer_replicates(target_labels_long):\n    \"\"\" Infer replicate experiments based on their long form labels.\n\n    In:\n        target_labels_long [str]: list of long form target labels\n    Out:\n        replicate_lists {exp_label -> [target indexes]}\n    \"\"\"\n    replicate_lists = {}\n    rep_re = []\n    rep_re.append(re.compile('rep\\\\d+'))\n    rep_re.append(re.compile('donor\\\\d+'))\n    _iter30 = range(len(target_labels_long))\n    while True:\n        try:\n            ti = next(_iter30)\n        except StopIteration:\n            break\n        label = target_labels_long[ti]\n        for ri in range(len(rep_re)):\n            rep_m = rep_re[ri].search(label)\n            if rep_m:\n                rep_str = rep_m.group(0)\n                label = label.replace(rep_str, '')\n        replicate_lists.setdefault(label, []).append(ti)\n    return replicate_lists", "fn_id": 1, "class_fn": false, "repo": "JasperSnoek/basenji", "file": "bin/basenji_test_reps.py", "last_update_at": "2021-05-12T08:51:44+00:00", "original_content": "def infer_replicates(target_labels_long):\n    \"\"\" Infer replicate experiments based on their long form labels.\n\n    In:\n        target_labels_long [str]: list of long form target labels\n    Out:\n        replicate_lists {exp_label -> [target indexes]}\n    \"\"\"\n    replicate_lists = {}\n    rep_re = []\n    rep_re.append(re.compile('rep\\\\d+'))\n    rep_re.append(re.compile('donor\\\\d+'))\n    for ti in range(len(target_labels_long)):\n        label = target_labels_long[ti]\n        for ri in range(len(rep_re)):\n            rep_m = rep_re[ri].search(label)\n            if rep_m:\n                rep_str = rep_m.group(0)\n                label = label.replace(rep_str, '')\n        replicate_lists.setdefault(label, []).append(ti)\n    return replicate_lists", "refactored": true, "question_id": "96a9ce1af1b9abc8e61b5491562c9ddee1c883c3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def infer_replicates(target_labels_long):\n    \"\"\" Infer replicate experiments based on their long form labels.\n    In:\n        target_labels_long [str]: list of long form target labels\n    Out:\n        replicate_lists {exp_label -> [target indexes]}\n    \"\"\"\n    replicate_lists = {}\n    rep_re = []\n    rep_re.append(re.compile('rep\\\\d+'))\n    rep_re.append(re.compile('donor\\\\d+'))\n    _iter30 = range(len(target_labels_long))\n    while True:\n        try:\n            ti = next(_iter30)\n        except StopIteration:\n            break\n        label = target_labels_long[ti]\n        for ri in range(len(rep_re)):\n            rep_m = rep_re[ri].search(label)\n            if rep_m:\n                rep_str = rep_m.group(0)\n                label = label.replace(rep_str, '')\n        replicate_lists.setdefault(label, []).append(ti)\n"]]}
{"hexsha": "28241061cc6276467c762df6e87e9db4f4a59e1b", "ext": "py", "lang": "Python", "content": "def total_lights():\n    total_lights_on = 0\n    _iter31 = enumerate(lights)\n    while True:\n        try:\n            y, _ = next(_iter31)\n        except StopIteration:\n            break\n        for x, _ in enumerate(lights[y]):\n            if lights[y][x] == 1:\n                total_lights_on += 1\n    return total_lights_on", "fn_id": 6, "class_fn": false, "repo": "josephroquedev/advent-of-code", "file": "2015/day_18/python/day18.py", "last_update_at": "2021-11-30T10:05:29+00:00", "original_content": "def total_lights():\n    total_lights_on = 0\n    for y, _ in enumerate(lights):\n        for x, _ in enumerate(lights[y]):\n            if lights[y][x] == 1:\n                total_lights_on += 1\n    return total_lights_on", "refactored": true, "question_id": "28241061cc6276467c762df6e87e9db4f4a59e1b_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def total_lights():\n    total_lights_on = 0\n    _iter31 = enumerate(lights)\n    while True:\n        try:\n            y, _ = next(_iter31)\n        except StopIteration:\n            break\n        for x, _ in enumerate(lights[y]):\n            if lights[y][x] == 1:\n                total_lights_on += 1\n"]]}
{"hexsha": "e2638a4bcd52d33f3d9e3b6ccc08e027bf129a22", "ext": "py", "lang": "Python", "content": "def build_random_ts(num_samples, length_of_ts):\n    data = {}\n    labels = []\n    for s in range(0, num_samples):\n        labels.append(np.random.choice([1, 2]))\n    data['y'] = labels\n    _iter32 = range(0, length_of_ts)\n    while True:\n        try:\n            col = next(_iter32)\n        except StopIteration:\n            break\n        key = 'feature_' + str(col + 1)\n        values = []\n        for s in range(0, num_samples):\n            values.append(np.random.normal())\n        data[key] = values\n    df = pd.DataFrame.from_dict(data)\n    X = df.iloc[:, 1:]\n    y = df.iloc[:, :1]\n    return (X, y)", "fn_id": 19, "class_fn": false, "repo": "AkashPushkar/dsitributed-time-series", "file": "src/full.py", "last_update_at": "2021-06-18T20:51:28+00:00", "original_content": "def build_random_ts(num_samples, length_of_ts):\n    data = {}\n    labels = []\n    for s in range(0, num_samples):\n        labels.append(np.random.choice([1, 2]))\n    data['y'] = labels\n    for col in range(0, length_of_ts):\n        key = 'feature_' + str(col + 1)\n        values = []\n        for s in range(0, num_samples):\n            values.append(np.random.normal())\n        data[key] = values\n    df = pd.DataFrame.from_dict(data)\n    X = df.iloc[:, 1:]\n    y = df.iloc[:, :1]\n    return (X, y)", "refactored": true, "question_id": "e2638a4bcd52d33f3d9e3b6ccc08e027bf129a22_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def build_random_ts(num_samples, length_of_ts):\n    data = {}\n    labels = []\n    for s in range(0, num_samples):\n        labels.append(np.random.choice([1, 2]))\n    data['y'] = labels\n    _iter32 = range(0, length_of_ts)\n    while True:\n        try:\n            col = next(_iter32)\n        except StopIteration:\n            break\n        key = 'feature_' + str(col + 1)\n        values = []\n        for s in range(0, num_samples):\n            values.append(np.random.normal())\n        data[key] = values\n    df = pd.DataFrame.from_dict(data)\n    X = df.iloc[:, 1:]\n    y = df.iloc[:, :1]\n"]]}
{"hexsha": "d83d43b9c49703cda927b344f9e7b3b7da45f5b3", "ext": "py", "lang": "Python", "content": "def read_kitti_annotations(label_paths, calib_paths):\n    all_labels = []\n    all_calib = []\n    _iter33 = zip(label_paths, calib_paths)\n    while True:\n        try:\n            label_file, calib_file = next(_iter33)\n        except StopIteration:\n            break\n        calib = o3d.ml.datasets.KITTI.read_calib(calib_file)\n        labels = o3d.ml.datasets.KITTI.read_label(label_file, calib)\n        all_labels.append(labels)\n        all_calib.append(calib)\n    return (all_labels, all_calib)", "fn_id": 1, "class_fn": false, "repo": "supervisely-ecosystem/Open3D-ML", "file": "supervisely/src_backup/convert_kitty3d_to_sly.py", "last_update_at": "2021-08-31T09:06:08+00:00", "original_content": "def read_kitti_annotations(label_paths, calib_paths):\n    all_labels = []\n    all_calib = []\n    for label_file, calib_file in zip(label_paths, calib_paths):\n        calib = o3d.ml.datasets.KITTI.read_calib(calib_file)\n        labels = o3d.ml.datasets.KITTI.read_label(label_file, calib)\n        all_labels.append(labels)\n        all_calib.append(calib)\n    return (all_labels, all_calib)", "refactored": true, "question_id": "d83d43b9c49703cda927b344f9e7b3b7da45f5b3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def read_kitti_annotations(label_paths, calib_paths):\n    all_labels = []\n    all_calib = []\n    _iter33 = zip(label_paths, calib_paths)\n    while True:\n        try:\n            label_file, calib_file = next(_iter33)\n        except StopIteration:\n            break\n        calib = o3d.ml.datasets.KITTI.read_calib(calib_file)\n        labels = o3d.ml.datasets.KITTI.read_label(label_file, calib)\n        all_labels.append(labels)\n        all_calib.append(calib)\n"]]}
{"hexsha": "a6ecbbb0e40168d4238d3a4dc7a1087809d1ed3f", "ext": "py", "lang": "Python", "content": "@box.cron('0 3 * * *')\nasync def refresh_db(bot):\n    logger.info('refresh subway')\n    tasks = []\n    _iter34 = REGION_TABLE.values()\n    while True:\n        try:\n            service_region, api_version = next(_iter34)\n        except StopIteration:\n            break\n        tasks.append(fetch_station_db(bot, service_region, api_version))\n    await asyncio.wait(tasks)", "fn_id": 2, "class_fn": false, "repo": "item4/yui", "file": "yui/apps/search/subway.py", "last_update_at": "2021-01-31T17:57:41+00:00", "original_content": "@box.cron('0 3 * * *')\nasync def refresh_db(bot):\n    logger.info('refresh subway')\n    tasks = []\n    for service_region, api_version in REGION_TABLE.values():\n        tasks.append(fetch_station_db(bot, service_region, api_version))\n    await asyncio.wait(tasks)", "refactored": true, "question_id": "a6ecbbb0e40168d4238d3a4dc7a1087809d1ed3f_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@box.cron('0 3 * * *')\nasync def refresh_db(bot):\n    logger.info('refresh subway')\n    tasks = []\n    _iter34 = REGION_TABLE.values()\n    while True:\n        try:\n            service_region, api_version = next(_iter34)\n        except StopIteration:\n            break\n        tasks.append(fetch_station_db(bot, service_region, api_version))\n"]]}
{"hexsha": "385dabe838e94b3bc682d337123e8384c47a3724", "ext": "py", "lang": "Python", "content": "def parse_patterns(query, graph=False):\n    \"\"\"\n    if query['patterns'] looks like so:\n    ['target_type=', 'what=', '!tag_k=not_equals_thistag_v', 'tag_k:match_this_val', 'arbitrary', 'words']\n\n    then the patterns will look like so:\n    {\n    'tag_k=not_equals_thistag_v': {'negate': True, 'match_tag_equality': ['tag_k', 'not_equals_thistag_v']},\n    'target_type=':               {'negate': False, 'match_tag_equality': ['target_type', '']},\n    'what=':                      {'negate': False, 'match_tag_equality': ['what', '']},\n    'tag_k:match_this_val':       {'negate': False, 'match_tag_regex': ['tag_k', 'match_this_val']},\n    'words':                      {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x2612cb0>},\n    'arbitrary':                  {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x7f6cc000bd90>}\n    }\n    \"\"\"\n    patterns = {}\n    _iter35 = query['patterns']\n    while True:\n        try:\n            pattern = next(_iter35)\n        except StopIteration:\n            break\n        negate = False\n        if pattern.startswith('!'):\n            negate = True\n            pattern = pattern[1:]\n        patterns[pattern] = {'negate': negate}\n        if '=' in pattern:\n            if not graph or pattern not in ('target_type=', 'what='):\n                patterns[pattern]['match_tag_equality'] = pattern.split('=')\n            else:\n                del patterns[pattern]\n        elif ':' in pattern:\n            if not graph or pattern not in ('target_type:', 'what:'):\n                patterns[pattern]['match_tag_regex'] = pattern.split(':')\n            else:\n                del patterns[pattern]\n        else:\n            patterns[pattern]['match_id_regex'] = re.compile(pattern)\n    return patterns", "fn_id": 2, "class_fn": false, "repo": "bittorrent/graph-explorer", "file": "query.py", "last_update_at": "2021-03-14T19:37:11+00:00", "original_content": "def parse_patterns(query, graph=False):\n    \"\"\"\n    if query['patterns'] looks like so:\n    ['target_type=', 'what=', '!tag_k=not_equals_thistag_v', 'tag_k:match_this_val', 'arbitrary', 'words']\n\n    then the patterns will look like so:\n    {\n    'tag_k=not_equals_thistag_v': {'negate': True, 'match_tag_equality': ['tag_k', 'not_equals_thistag_v']},\n    'target_type=':               {'negate': False, 'match_tag_equality': ['target_type', '']},\n    'what=':                      {'negate': False, 'match_tag_equality': ['what', '']},\n    'tag_k:match_this_val':       {'negate': False, 'match_tag_regex': ['tag_k', 'match_this_val']},\n    'words':                      {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x2612cb0>},\n    'arbitrary':                  {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x7f6cc000bd90>}\n    }\n    \"\"\"\n    patterns = {}\n    for pattern in query['patterns']:\n        negate = False\n        if pattern.startswith('!'):\n            negate = True\n            pattern = pattern[1:]\n        patterns[pattern] = {'negate': negate}\n        if '=' in pattern:\n            if not graph or pattern not in ('target_type=', 'what='):\n                patterns[pattern]['match_tag_equality'] = pattern.split('=')\n            else:\n                del patterns[pattern]\n        elif ':' in pattern:\n            if not graph or pattern not in ('target_type:', 'what:'):\n                patterns[pattern]['match_tag_regex'] = pattern.split(':')\n            else:\n                del patterns[pattern]\n        else:\n            patterns[pattern]['match_id_regex'] = re.compile(pattern)\n    return patterns", "refactored": true, "question_id": "385dabe838e94b3bc682d337123e8384c47a3724_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def parse_patterns(query, graph=False):\n    \"\"\"\n    if query['patterns'] looks like so:\n    ['target_type=', 'what=', '!tag_k=not_equals_thistag_v', 'tag_k:match_this_val', 'arbitrary', 'words']\n    then the patterns will look like so:\n    {\n    'tag_k=not_equals_thistag_v': {'negate': True, 'match_tag_equality': ['tag_k', 'not_equals_thistag_v']},\n    'target_type=':               {'negate': False, 'match_tag_equality': ['target_type', '']},\n    'what=':                      {'negate': False, 'match_tag_equality': ['what', '']},\n    'tag_k:match_this_val':       {'negate': False, 'match_tag_regex': ['tag_k', 'match_this_val']},\n    'words':                      {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x2612cb0>},\n    'arbitrary':                  {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x7f6cc000bd90>}\n    }\n    \"\"\"\n    patterns = {}\n    _iter35 = query['patterns']\n    while True:\n        try:\n            pattern = next(_iter35)\n        except StopIteration:\n            break\n        negate = False\n        if pattern.startswith('!'):\n            negate = True\n            pattern = pattern[1:]\n        patterns[pattern] = {'negate': negate}\n        if '=' in pattern:\n            if not graph or pattern not in ('target_type=', 'what='):\n                patterns[pattern]['match_tag_equality'] = pattern.split('=')\n            else:\n                del patterns[pattern]\n        elif ':' in pattern:\n            if not graph or pattern not in ('target_type:', 'what:'):\n                patterns[pattern]['match_tag_regex'] = pattern.split(':')\n            else:\n                del patterns[pattern]\n        else:\n            patterns[pattern]['match_id_regex'] = re.compile(pattern)\n"]]}
{"hexsha": "1b7e2d214e5eeb85cf50702bb2e69e77348f954c", "ext": "py", "lang": "Python", "content": "def _delete_old(old_ids):\n    db = get_db('yahoo')\n    _iter36 = ['financial_data', 'key_stats']\n    while True:\n        try:\n            item = next(_iter36)\n        except StopIteration:\n            break\n        collection = db[item]\n        id_ = old_ids[item]\n        if id_:\n            result = collection.delete_many({'_id': {'$lte': id_}})\n            logger.info(f'\u5220\u9664 {item} \u65e7\u6570\u636e {result.deleted_count} \u884c')", "fn_id": 5, "class_fn": false, "repo": "NeoBert/liudengfeng-cnswd", "file": "cnswd/scripts/yahoo.py", "last_update_at": "2021-06-26T13:23:01+00:00", "original_content": "def _delete_old(old_ids):\n    db = get_db('yahoo')\n    for item in ['financial_data', 'key_stats']:\n        collection = db[item]\n        id_ = old_ids[item]\n        if id_:\n            result = collection.delete_many({'_id': {'$lte': id_}})\n            logger.info(f'\u5220\u9664 {item} \u65e7\u6570\u636e {result.deleted_count} \u884c')", "refactored": true, "question_id": "1b7e2d214e5eeb85cf50702bb2e69e77348f954c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _delete_old(old_ids):\n    db = get_db('yahoo')\n    _iter36 = ['financial_data', 'key_stats']\n    while True:\n        try:\n            item = next(_iter36)\n        except StopIteration:\n            break\n        collection = db[item]\n        id_ = old_ids[item]\n        if id_:\n            result = collection.delete_many({'_id': {'$lte': id_}})\n"]]}
{"hexsha": "31a0f40f5b3b73886fe6be3847e4043e0c0b0471", "ext": "py", "lang": "Python", "content": "def checkEntries(DataSetFile, preprocess=lambda x: x, dataType='jpg'):\n    dataset = wds.WebDataset(DataSetFile)\n    itemsTouched = 0\n    _iter37 = dataset\n    while True:\n        try:\n            element = next(_iter37)\n        except StopIteration:\n            break\n        print(element['__key__'])\n        preprocess(element[dataType])\n        tmp = element[0]\n        if not tmp == None:\n            itemsTouched += 1\n    return itemsTouched", "fn_id": 8, "class_fn": false, "repo": "AaltoRSE/ImageNetTools", "file": "ImageNetTools/IOTesters.py", "last_update_at": "2021-11-15T11:21:55+00:00", "original_content": "def checkEntries(DataSetFile, preprocess=lambda x: x, dataType='jpg'):\n    dataset = wds.WebDataset(DataSetFile)\n    itemsTouched = 0\n    for element in dataset:\n        print(element['__key__'])\n        preprocess(element[dataType])\n        tmp = element[0]\n        if not tmp == None:\n            itemsTouched += 1\n    return itemsTouched", "refactored": true, "question_id": "31a0f40f5b3b73886fe6be3847e4043e0c0b0471_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def checkEntries(DataSetFile, preprocess=lambda x: x, dataType='jpg'):\n    dataset = wds.WebDataset(DataSetFile)\n    itemsTouched = 0\n    _iter37 = dataset\n    while True:\n        try:\n            element = next(_iter37)\n        except StopIteration:\n            break\n        print(element['__key__'])\n        preprocess(element[dataType])\n        tmp = element[0]\n        if not tmp == None:\n            itemsTouched += 1\n"]]}
{"hexsha": "b0b49ffed87028f7676ecd3a3526e65ea082c9a2", "ext": "py", "lang": "Python", "content": "def obtain_pcaplot(model):\n    _iter38 = enumerate(model.layers)\n    while True:\n        try:\n            idx, layer = next(_iter38)\n        except StopIteration:\n            break\n        if layer.__class__.__name__ == 'Dense':\n            all_weights = layer.get_weights()\n            weights = all_weights[0]\n            pca = applyPCA(weights, np.array(weights).shape[1], drawPlot=True, isReshape=False)\n            break", "fn_id": 10, "class_fn": false, "repo": "kilinco/spec-img-finesse", "file": "CNN_version/final.py", "last_update_at": "2021-06-03T16:52:44+00:00", "original_content": "def obtain_pcaplot(model):\n    for idx, layer in enumerate(model.layers):\n        if layer.__class__.__name__ == 'Dense':\n            all_weights = layer.get_weights()\n            weights = all_weights[0]\n            pca = applyPCA(weights, np.array(weights).shape[1], drawPlot=True, isReshape=False)\n            break", "refactored": true, "question_id": "b0b49ffed87028f7676ecd3a3526e65ea082c9a2_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def obtain_pcaplot(model):\n    _iter38 = enumerate(model.layers)\n    while True:\n        try:\n            idx, layer = next(_iter38)\n        except StopIteration:\n            break\n        if layer.__class__.__name__ == 'Dense':\n            all_weights = layer.get_weights()\n            weights = all_weights[0]\n            pca = applyPCA(weights, np.array(weights).shape[1], drawPlot=True, isReshape=False)\n"]]}
{"hexsha": "be83fdd493ff018b94ad39f9ed435403d860ea8e", "ext": "py", "lang": "Python", "content": "def generate_bio(spans, length):\n    tags = ['O'] * length\n    for span in spans:\n        tags[span.tokens[0]] = f'B-{span.type}'\n        _iter39 = span.tokens[1:]\n        while True:\n            try:\n                i = next(_iter39)\n            except StopIteration:\n                break\n            tags[i] = f'I-{span.type}'\n    return tags", "fn_id": 4, "class_fn": false, "repo": "blester125/iobes", "file": "tests/utils.py", "last_update_at": "2021-12-06T23:15:18+00:00", "original_content": "def generate_bio(spans, length):\n    tags = ['O'] * length\n    for span in spans:\n        tags[span.tokens[0]] = f'B-{span.type}'\n        for i in span.tokens[1:]:\n            tags[i] = f'I-{span.type}'\n    return tags", "refactored": true, "question_id": "be83fdd493ff018b94ad39f9ed435403d860ea8e_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def generate_bio(spans, length):\n    tags = ['O'] * length\n    for span in spans:\n        tags[span.tokens[0]] = f'B-{span.type}'\n        _iter39 = span.tokens[1:]\n        while True:\n            try:\n                i = next(_iter39)\n            except StopIteration:\n                break\n            tags[i] = f'I-{span.type}'\n"]]}
{"hexsha": "748d69ab544fa46cb8d58415b5d688a6b34e3694", "ext": "py", "lang": "Python", "content": "def map_dists(dists: Dict[str, AbstractMessage], values: Dict[str, np.ndarray], _call: str='logpdf') -> Iterator[Tuple[str, np.ndarray]]:\n    \"\"\"\n    Calls a method (default: logpdf) for each Message in dists\n    on the corresponding value in values\n    \"\"\"\n    _iter40 = dists.keys() & values.keys()\n    while True:\n        try:\n            v = next(_iter40)\n        except StopIteration:\n            break\n        dist = dists[v]\n        if isinstance(dist, AbstractMessage):\n            yield (v, getattr(dist, _call)(values[v]))", "fn_id": 0, "class_fn": false, "repo": "arfon/PyAutoFit", "file": "autofit/graphical/messages/__init__.py", "last_update_at": "2021-01-18T23:20:31+00:00", "original_content": "def map_dists(dists: Dict[str, AbstractMessage], values: Dict[str, np.ndarray], _call: str='logpdf') -> Iterator[Tuple[str, np.ndarray]]:\n    \"\"\"\n    Calls a method (default: logpdf) for each Message in dists\n    on the corresponding value in values\n    \"\"\"\n    for v in dists.keys() & values.keys():\n        dist = dists[v]\n        if isinstance(dist, AbstractMessage):\n            yield (v, getattr(dist, _call)(values[v]))", "refactored": true, "question_id": "748d69ab544fa46cb8d58415b5d688a6b34e3694_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def map_dists(dists: Dict[str, AbstractMessage], values: Dict[str, np.ndarray], _call: str='logpdf') -> Iterator[Tuple[str, np.ndarray]]:\n    \"\"\"\n    Calls a method (default: logpdf) for each Message in dists\n    on the corresponding value in values\n    \"\"\"\n    _iter40 = dists.keys() & values.keys()\n    while True:\n        try:\n            v = next(_iter40)\n        except StopIteration:\n            break\n        dist = dists[v]\n        if isinstance(dist, AbstractMessage):\n"]]}
{"hexsha": "a7cb7c0cbe1316b9f471be562240d8e6e68b5ee9", "ext": "py", "lang": "Python", "content": "def get_items(list_, doc_type):\n    data_table_names = {'PO': 'fss.dbo.bsPRItem', 'SO': 'fss.dbo.bsSaleOrderItem'}\n    result_dict = {}\n    item_list = []\n    try:\n        table_name = data_table_names[doc_type]\n    except KeyError as e:\n        print(f'ERROR: DocType {e} not found')\n        sys.exit()\n        return ({}, [])\n    _iter41 = list_\n    while True:\n        try:\n            p = next(_iter41)\n        except StopIteration:\n            break\n        doc_no = p[1]\n        statement_items = f\"SELECT * FROM {table_name}                            WHERE DocNo = '{doc_no}'\"\n        cursor.execute(statement_items)\n        package = []\n        for r in cursor:\n            item_list.append(r)\n            package.append(r)\n        result_dict[r[1]] = package\n    return (result_dict, item_list)", "fn_id": 1, "class_fn": false, "repo": "adadesions/tenzing-project", "file": "tenzing-mini/tenzing_mini.py", "last_update_at": "2021-01-25T04:45:56+00:00", "original_content": "def get_items(list_, doc_type):\n    data_table_names = {'PO': 'fss.dbo.bsPRItem', 'SO': 'fss.dbo.bsSaleOrderItem'}\n    result_dict = {}\n    item_list = []\n    try:\n        table_name = data_table_names[doc_type]\n    except KeyError as e:\n        print(f'ERROR: DocType {e} not found')\n        sys.exit()\n        return ({}, [])\n    for p in list_:\n        doc_no = p[1]\n        statement_items = f\"SELECT * FROM {table_name}                            WHERE DocNo = '{doc_no}'\"\n        cursor.execute(statement_items)\n        package = []\n        for r in cursor:\n            item_list.append(r)\n            package.append(r)\n        result_dict[r[1]] = package\n    return (result_dict, item_list)", "refactored": true, "question_id": "a7cb7c0cbe1316b9f471be562240d8e6e68b5ee9_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_items(list_, doc_type):\n    data_table_names = {'PO': 'fss.dbo.bsPRItem', 'SO': 'fss.dbo.bsSaleOrderItem'}\n    result_dict = {}\n    item_list = []\n    try:\n        table_name = data_table_names[doc_type]\n    except KeyError as e:\n        print(f'ERROR: DocType {e} not found')\n        sys.exit()\n        return ({}, [])\n    _iter41 = list_\n    while True:\n        try:\n            p = next(_iter41)\n        except StopIteration:\n            break\n        doc_no = p[1]\n        statement_items = f\"SELECT * FROM {table_name}                            WHERE DocNo = '{doc_no}'\"\n        cursor.execute(statement_items)\n        package = []\n        for r in cursor:\n            item_list.append(r)\n            package.append(r)\n        result_dict[r[1]] = package\n"]]}
{"hexsha": "585c8c30c7d2aa1d2bbdf2724d7af40b9b92f226", "ext": "py", "lang": "Python", "content": "def get_straightline_path_to(target, robot_pos):\n    pts = []\n    cur_pos = robot_pos\n    for _ in iter(lambda: 0, 1):\n        if not np.linalg.norm(target[:2] - cur_pos[:2]) > 0.5:\n            break\n        t = get_step_target_for_move(cur_pos, [target[0], CAMERA_HEIGHT, target[1]], step_size=0.5)\n        pts.append(t)\n        cur_pos = t\n    return np.asarray(pts)", "fn_id": 7, "class_fn": false, "repo": "Jigyasu/droidlet", "file": "droidlet/lowlevel/robot_mover_utils.py", "last_update_at": "2021-09-13T13:25:16+00:00", "original_content": "def get_straightline_path_to(target, robot_pos):\n    pts = []\n    cur_pos = robot_pos\n    while np.linalg.norm(target[:2] - cur_pos[:2]) > 0.5:\n        t = get_step_target_for_move(cur_pos, [target[0], CAMERA_HEIGHT, target[1]], step_size=0.5)\n        pts.append(t)\n        cur_pos = t\n    return np.asarray(pts)", "refactored": true, "question_id": "585c8c30c7d2aa1d2bbdf2724d7af40b9b92f226_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_straightline_path_to(target, robot_pos):\n    pts = []\n    cur_pos = robot_pos\n    for _ in iter(lambda: 0, 1):\n        if not np.linalg.norm(target[:2] - cur_pos[:2]) > 0.5:\n            break\n        t = get_step_target_for_move(cur_pos, [target[0], CAMERA_HEIGHT, target[1]], step_size=0.5)\n        pts.append(t)\n        cur_pos = t\n"]]}
{"hexsha": "1b67a7d9d4167a9df6ed58c7d637b09510718d46", "ext": "py", "lang": "Python", "content": "def spider(headers, conferences_url):\n    for conference_url in conferences_url:\n        html_level1 = requests.get(conference_url, headers=headers).content\n        tree_level1 = etree.HTML(html_level1)\n        conferences = tree_level1.xpath(\"//a[contains(@href, 'dblp.uni-trier.de/db/conf/') and contains(@href, 'html')]/@href\")\n        conferences = list(set(conferences))\n        fp_dir = os.path.split(os.path.realpath(sys.argv[0]))[0] + os.sep + 'source' + os.sep + 'conf' + os.sep + conference_url.split('/')[-2]\n        if not os.path.exists(fp_dir):\n            os.makedirs(fp_dir)\n        for conference in conferences:\n            fp_name = fp_dir + os.sep + conference.split('/')[-1].split('.')[0] + '.csv'\n            if os.path.exists(fp_name):\n                print('History: ', fp_name.encode('utf-8'))\n                continue\n            html_level2 = requests.get(conference, headers=headers).content\n            tree_level2 = etree.HTML(html_level2)\n            if tree_level2.xpath(\"//li[@class='entry inproceedings']\"):\n                extractor(tree_level2, fp_name)\n            else:\n                volumes = tree_level2.xpath(\"//*[@id='main']/ul/li/a/@href\")\n                _iter42 = volumes\n                while True:\n                    try:\n                        volume = next(_iter42)\n                    except StopIteration:\n                        break\n                    fp_name = fp_dir + os.sep + volume.split('/')[-1].split('.')[0] + '.csv'\n                    if os.path.exists(fp_name):\n                        print('History: ', fp_name.encode('utf-8'))\n                        continue\n                    html_level3 = requests.get(volume, headers=headers).content\n                    tree_level3 = etree.HTML(html_level3)\n                    extractor(tree_level3, fp_name)", "fn_id": 1, "class_fn": false, "repo": "Aticode/spider_dblp", "file": "conferences.py", "last_update_at": "2021-01-18T09:00:14+00:00", "original_content": "def spider(headers, conferences_url):\n    for conference_url in conferences_url:\n        html_level1 = requests.get(conference_url, headers=headers).content\n        tree_level1 = etree.HTML(html_level1)\n        conferences = tree_level1.xpath(\"//a[contains(@href, 'dblp.uni-trier.de/db/conf/') and contains(@href, 'html')]/@href\")\n        conferences = list(set(conferences))\n        fp_dir = os.path.split(os.path.realpath(sys.argv[0]))[0] + os.sep + 'source' + os.sep + 'conf' + os.sep + conference_url.split('/')[-2]\n        if not os.path.exists(fp_dir):\n            os.makedirs(fp_dir)\n        for conference in conferences:\n            fp_name = fp_dir + os.sep + conference.split('/')[-1].split('.')[0] + '.csv'\n            if os.path.exists(fp_name):\n                print('History: ', fp_name.encode('utf-8'))\n                continue\n            html_level2 = requests.get(conference, headers=headers).content\n            tree_level2 = etree.HTML(html_level2)\n            if tree_level2.xpath(\"//li[@class='entry inproceedings']\"):\n                extractor(tree_level2, fp_name)\n            else:\n                volumes = tree_level2.xpath(\"//*[@id='main']/ul/li/a/@href\")\n                for volume in volumes:\n                    fp_name = fp_dir + os.sep + volume.split('/')[-1].split('.')[0] + '.csv'\n                    if os.path.exists(fp_name):\n                        print('History: ', fp_name.encode('utf-8'))\n                        continue\n                    html_level3 = requests.get(volume, headers=headers).content\n                    tree_level3 = etree.HTML(html_level3)\n                    extractor(tree_level3, fp_name)", "refactored": true, "question_id": "1b67a7d9d4167a9df6ed58c7d637b09510718d46_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def spider(headers, conferences_url):\n    for conference_url in conferences_url:\n        html_level1 = requests.get(conference_url, headers=headers).content\n        tree_level1 = etree.HTML(html_level1)\n        conferences = tree_level1.xpath(\"//a[contains(@href, 'dblp.uni-trier.de/db/conf/') and contains(@href, 'html')]/@href\")\n        conferences = list(set(conferences))\n        fp_dir = os.path.split(os.path.realpath(sys.argv[0]))[0] + os.sep + 'source' + os.sep + 'conf' + os.sep + conference_url.split('/')[-2]\n        if not os.path.exists(fp_dir):\n            os.makedirs(fp_dir)\n        for conference in conferences:\n            fp_name = fp_dir + os.sep + conference.split('/')[-1].split('.')[0] + '.csv'\n            if os.path.exists(fp_name):\n                print('History: ', fp_name.encode('utf-8'))\n                continue\n            html_level2 = requests.get(conference, headers=headers).content\n            tree_level2 = etree.HTML(html_level2)\n            if tree_level2.xpath(\"//li[@class='entry inproceedings']\"):\n                extractor(tree_level2, fp_name)\n            else:\n                volumes = tree_level2.xpath(\"//*[@id='main']/ul/li/a/@href\")\n                _iter42 = volumes\n                while True:\n                    try:\n                        volume = next(_iter42)\n                    except StopIteration:\n                        break\n                    fp_name = fp_dir + os.sep + volume.split('/')[-1].split('.')[0] + '.csv'\n                    if os.path.exists(fp_name):\n                        print('History: ', fp_name.encode('utf-8'))\n                        continue\n                    html_level3 = requests.get(volume, headers=headers).content\n                    tree_level3 = etree.HTML(html_level3)\n"]]}
{"hexsha": "6494d7e235268c91bde539243623f44dd265dd50", "ext": "py", "lang": "Python", "content": "def create_fake_server(messages=[]):\n    all_messages = _standard_join_messages() + messages\n\n    async def _fake_server(websocket, _path):\n        _join_message = await websocket.recv()\n        _iter43 = all_messages\n        while True:\n            try:\n                message = next(_iter43)\n            except StopIteration:\n                break\n            await websocket.send(json.dumps(message))\n    return _fake_server", "fn_id": 1, "class_fn": false, "repo": "UrbanOS-Examples/PredictiveParking", "file": "tests/fake_websocket_server.py", "last_update_at": "2021-07-01T16:51:18+00:00", "original_content": "def create_fake_server(messages=[]):\n    all_messages = _standard_join_messages() + messages\n\n    async def _fake_server(websocket, _path):\n        _join_message = await websocket.recv()\n        for message in all_messages:\n            await websocket.send(json.dumps(message))\n    return _fake_server", "refactored": true, "question_id": "6494d7e235268c91bde539243623f44dd265dd50_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def create_fake_server(messages=[]):\n    all_messages = _standard_join_messages() + messages\n    async def _fake_server(websocket, _path):\n        _join_message = await websocket.recv()\n        _iter43 = all_messages\n        while True:\n            try:\n                message = next(_iter43)\n            except StopIteration:\n                break\n            await websocket.send(json.dumps(message))\n"]]}
{"hexsha": "f5243a5a3b358ca43895541eb22f25937e8336f3", "ext": "py", "lang": "Python", "content": "def try_to_get_last_line_as_json(file_location: str, max_tries=3, await_in_seconds_between_tries=1) -> Optional[dict]:\n    attempts = 0\n    for _ in iter(lambda: 0, 1):\n        if not True:\n            break\n        line = last_line_from_some_file(file_location)\n        line_as_json = json.loads(line) if line else None\n        if line_as_json:\n            return line_as_json\n        if attempts >= max_tries:\n            return None\n        sleep(await_in_seconds_between_tries)\n        attempts += 1", "fn_id": 5, "class_fn": false, "repo": "juntossomosmais/python-fluentd-testing", "file": "python_fluentd_testing/utils.py", "last_update_at": "2021-11-12T20:00:54+00:00", "original_content": "def try_to_get_last_line_as_json(file_location: str, max_tries=3, await_in_seconds_between_tries=1) -> Optional[dict]:\n    attempts = 0\n    while True:\n        line = last_line_from_some_file(file_location)\n        line_as_json = json.loads(line) if line else None\n        if line_as_json:\n            return line_as_json\n        if attempts >= max_tries:\n            return None\n        sleep(await_in_seconds_between_tries)\n        attempts += 1", "refactored": true, "question_id": "f5243a5a3b358ca43895541eb22f25937e8336f3_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def try_to_get_last_line_as_json(file_location: str, max_tries=3, await_in_seconds_between_tries=1) -> Optional[dict]:\n    attempts = 0\n    for _ in iter(lambda: 0, 1):\n        if not True:\n            break\n        line = last_line_from_some_file(file_location)\n        line_as_json = json.loads(line) if line else None\n        if line_as_json:\n            return line_as_json\n        if attempts >= max_tries:\n            return None\n        sleep(await_in_seconds_between_tries)\n"]]}
{"hexsha": "5f30e702c766d9408e95e8e3b793cedd534e612e", "ext": "py", "lang": "Python", "content": "def get_colorscale_values(cmap):\n    \"\"\"Get the colors composing a plotly colorscale.\n\n    Parameter\n    ---------\n    cmap : str\n        Name of the Plotly colorscale\n\n    Returns\n    -------\n    colorscale : array_like\n        Colors associated to the colormap\n    \"\"\"\n    import plotly\n    rev = '_r' if '_r' in cmap.lower() else ''\n    cmap = cmap.lower().replace('_r', '')\n    colorscales = plotly.colors.named_colorscales()\n    assert cmap in colorscales\n    ensembles = ['sequential', 'diverging', 'qualitative']\n    _iter44 = ensembles\n    while True:\n        try:\n            e = next(_iter44)\n        except StopIteration:\n            break\n        cmaps = dir(eval(f'plotly.colors.{e}'))\n        cmaps_lower = [c.lower() for c in cmaps]\n        if cmap in cmaps_lower:\n            cmap_idx = cmaps_lower.index(cmap)\n            return eval(f'plotly.colors.{e}.{cmaps[cmap_idx]}{rev}')\n    assert ValueError(f'{cmap} is not a predefined colorscale {colorscales}')", "fn_id": 0, "class_fn": false, "repo": "brainets/netchos", "file": "netchos/utils/colors.py", "last_update_at": "2021-11-17T15:18:33+00:00", "original_content": "def get_colorscale_values(cmap):\n    \"\"\"Get the colors composing a plotly colorscale.\n\n    Parameter\n    ---------\n    cmap : str\n        Name of the Plotly colorscale\n\n    Returns\n    -------\n    colorscale : array_like\n        Colors associated to the colormap\n    \"\"\"\n    import plotly\n    rev = '_r' if '_r' in cmap.lower() else ''\n    cmap = cmap.lower().replace('_r', '')\n    colorscales = plotly.colors.named_colorscales()\n    assert cmap in colorscales\n    ensembles = ['sequential', 'diverging', 'qualitative']\n    for e in ensembles:\n        cmaps = dir(eval(f'plotly.colors.{e}'))\n        cmaps_lower = [c.lower() for c in cmaps]\n        if cmap in cmaps_lower:\n            cmap_idx = cmaps_lower.index(cmap)\n            return eval(f'plotly.colors.{e}.{cmaps[cmap_idx]}{rev}')\n    assert ValueError(f'{cmap} is not a predefined colorscale {colorscales}')", "refactored": true, "question_id": "5f30e702c766d9408e95e8e3b793cedd534e612e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_colorscale_values(cmap):\n    \"\"\"Get the colors composing a plotly colorscale.\n    Parameter\n    ---------\n    cmap : str\n        Name of the Plotly colorscale\n    Returns\n    -------\n    colorscale : array_like\n        Colors associated to the colormap\n    \"\"\"\n    import plotly\n    rev = '_r' if '_r' in cmap.lower() else ''\n    cmap = cmap.lower().replace('_r', '')\n    colorscales = plotly.colors.named_colorscales()\n    assert cmap in colorscales\n    ensembles = ['sequential', 'diverging', 'qualitative']\n    _iter44 = ensembles\n    while True:\n        try:\n            e = next(_iter44)\n        except StopIteration:\n            break\n        cmaps = dir(eval(f'plotly.colors.{e}'))\n        cmaps_lower = [c.lower() for c in cmaps]\n        if cmap in cmaps_lower:\n            cmap_idx = cmaps_lower.index(cmap)\n            return eval(f'plotly.colors.{e}.{cmaps[cmap_idx]}{rev}')\n"]]}
{"hexsha": "5ea5ff02510da4eb6075ea3e0e4184f4d733ca2e", "ext": "py", "lang": "Python", "content": "def detectFacesByRekognition(image_binary: bytes) -> List[List[float]]:\n    client = boto3.client('rekognition')\n    response = client.detect_faces(Image={'Bytes': image_binary}, Attributes=['ALL'])\n    faces = list()\n    _iter45 = response['FaceDetails']\n    while True:\n        try:\n            face_info = next(_iter45)\n        except StopIteration:\n            break\n        faces.append(face_info['BoundingBox'])\n        print(face_info['BoundingBox'])\n    return faces", "fn_id": 1, "class_fn": false, "repo": "p1ass/emojic.ch", "file": "lambda/detect_face.py", "last_update_at": "2021-08-12T04:24:43+00:00", "original_content": "def detectFacesByRekognition(image_binary: bytes) -> List[List[float]]:\n    client = boto3.client('rekognition')\n    response = client.detect_faces(Image={'Bytes': image_binary}, Attributes=['ALL'])\n    faces = list()\n    for face_info in response['FaceDetails']:\n        faces.append(face_info['BoundingBox'])\n        print(face_info['BoundingBox'])\n    return faces", "refactored": true, "question_id": "5ea5ff02510da4eb6075ea3e0e4184f4d733ca2e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def detectFacesByRekognition(image_binary: bytes) -> List[List[float]]:\n    client = boto3.client('rekognition')\n    response = client.detect_faces(Image={'Bytes': image_binary}, Attributes=['ALL'])\n    faces = list()\n    _iter45 = response['FaceDetails']\n    while True:\n        try:\n            face_info = next(_iter45)\n        except StopIteration:\n            break\n        faces.append(face_info['BoundingBox'])\n        print(face_info['BoundingBox'])\n"]]}
{"hexsha": "d4fedd0a36cd395e4706b0c47428c1465d2a2a9d", "ext": "py", "lang": "Python", "content": "def wl_predict(datasets, test_datasets):\n    \"\"\"\n\n    \"\"\"\n    log_dir = tfu.get_logdir()\n    datasets, test_datasets = get_wl_datasets()\n    x, y = tfu.get_example(datasets)\n    loss_fxn = tf.losses.BinaryCrossentropy()\n    optim = tf.keras.optimizers.Adam()\n    model = lstm.make_mlp_functional(x.shape[-2:], tf.size(y[0]), classify=True)\n    train_summary_writer, test_summary_writer = tfu.init_summary_writers(log_dir)\n    train_loss, train_accuracy, test_loss, test_accuracy = tfu.get_classification_metrics()\n    tr_step = 0\n    te_step = 0\n    _iter46 = enumerate(datasets)\n    while True:\n        try:\n            epoch, dataset = next(_iter46)\n        except StopIteration:\n            break\n        if not dataset:\n            continue\n        for xtr, ytr in dataset:\n            ytr = tf.reshape(ytr, (1, -1))\n            tl, ta, preds = fwd.train_step_classify(model, optim, loss_fxn, xtr, ytr, train_loss, train_accuracy)\n            tr_step += 1\n            with train_summary_writer.as_default():\n                tf.summary.scalar('loss', tl.numpy(), step=tr_step)\n                tf.summary.scalar('accuracy', ta.numpy(), step=tr_step)\n            maxed_pred = tf.argmax(preds, 1).numpy()[0]\n            maxed_true = tf.argmax(ytr).numpy()\n            correct = tf.equal(maxed_pred, maxed_true).numpy()\n        test_dataset = random.choice(test_datasets)\n        if not test_dataset:\n            continue\n        for xte, yte in test_dataset:\n            yte = tf.reshape(yte, (1, -1))\n            tel, tea = fwd.test_step(model, loss_fxn, xte, yte, test_loss, test_accuracy)\n            te_step += 1\n            with test_summary_writer.as_default():\n                tf.summary.scalar('loss', tel.numpy(), step=te_step)\n                tf.summary.scalar('accuracy', tea.numpy(), step=te_step)\n        template = 'Epoch {}, Loss: {}, Accuracy: {}, Test Loss: {}, Test Accuracy: {}, Preds: {}, Acts: {}'\n        print(template.format(epoch + 1, train_loss.result(), train_accuracy.result() * 100, test_loss.result(), test_accuracy.result() * 100, preds, ytr))\n        train_loss.reset_states()\n        test_loss.reset_states()\n        train_accuracy.reset_states()\n        test_accuracy.reset_states()\n    tf.saved_model.save(model, tfm.WRITE_TO + 'win_loss/')\n    return datasets", "fn_id": 1, "class_fn": false, "repo": "AnandIJain/sip", "file": "sips/ml/tf_models/win_loss.py", "last_update_at": "2021-06-13T13:53:59+00:00", "original_content": "def wl_predict(datasets, test_datasets):\n    \"\"\"\n\n    \"\"\"\n    log_dir = tfu.get_logdir()\n    datasets, test_datasets = get_wl_datasets()\n    x, y = tfu.get_example(datasets)\n    loss_fxn = tf.losses.BinaryCrossentropy()\n    optim = tf.keras.optimizers.Adam()\n    model = lstm.make_mlp_functional(x.shape[-2:], tf.size(y[0]), classify=True)\n    train_summary_writer, test_summary_writer = tfu.init_summary_writers(log_dir)\n    train_loss, train_accuracy, test_loss, test_accuracy = tfu.get_classification_metrics()\n    tr_step = 0\n    te_step = 0\n    for epoch, dataset in enumerate(datasets):\n        if not dataset:\n            continue\n        for xtr, ytr in dataset:\n            ytr = tf.reshape(ytr, (1, -1))\n            tl, ta, preds = fwd.train_step_classify(model, optim, loss_fxn, xtr, ytr, train_loss, train_accuracy)\n            tr_step += 1\n            with train_summary_writer.as_default():\n                tf.summary.scalar('loss', tl.numpy(), step=tr_step)\n                tf.summary.scalar('accuracy', ta.numpy(), step=tr_step)\n            maxed_pred = tf.argmax(preds, 1).numpy()[0]\n            maxed_true = tf.argmax(ytr).numpy()\n            correct = tf.equal(maxed_pred, maxed_true).numpy()\n        test_dataset = random.choice(test_datasets)\n        if not test_dataset:\n            continue\n        for xte, yte in test_dataset:\n            yte = tf.reshape(yte, (1, -1))\n            tel, tea = fwd.test_step(model, loss_fxn, xte, yte, test_loss, test_accuracy)\n            te_step += 1\n            with test_summary_writer.as_default():\n                tf.summary.scalar('loss', tel.numpy(), step=te_step)\n                tf.summary.scalar('accuracy', tea.numpy(), step=te_step)\n        template = 'Epoch {}, Loss: {}, Accuracy: {}, Test Loss: {}, Test Accuracy: {}, Preds: {}, Acts: {}'\n        print(template.format(epoch + 1, train_loss.result(), train_accuracy.result() * 100, test_loss.result(), test_accuracy.result() * 100, preds, ytr))\n        train_loss.reset_states()\n        test_loss.reset_states()\n        train_accuracy.reset_states()\n        test_accuracy.reset_states()\n    tf.saved_model.save(model, tfm.WRITE_TO + 'win_loss/')\n    return datasets", "refactored": true, "question_id": "d4fedd0a36cd395e4706b0c47428c1465d2a2a9d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def wl_predict(datasets, test_datasets):\n    \"\"\"\n    \"\"\"\n    log_dir = tfu.get_logdir()\n    datasets, test_datasets = get_wl_datasets()\n    x, y = tfu.get_example(datasets)\n    loss_fxn = tf.losses.BinaryCrossentropy()\n    optim = tf.keras.optimizers.Adam()\n    model = lstm.make_mlp_functional(x.shape[-2:], tf.size(y[0]), classify=True)\n    train_summary_writer, test_summary_writer = tfu.init_summary_writers(log_dir)\n    train_loss, train_accuracy, test_loss, test_accuracy = tfu.get_classification_metrics()\n    tr_step = 0\n    te_step = 0\n    _iter46 = enumerate(datasets)\n    while True:\n        try:\n            epoch, dataset = next(_iter46)\n        except StopIteration:\n            break\n        if not dataset:\n            continue\n        for xtr, ytr in dataset:\n            ytr = tf.reshape(ytr, (1, -1))\n            tl, ta, preds = fwd.train_step_classify(model, optim, loss_fxn, xtr, ytr, train_loss, train_accuracy)\n            tr_step += 1\n            with train_summary_writer.as_default():\n                tf.summary.scalar('loss', tl.numpy(), step=tr_step)\n                tf.summary.scalar('accuracy', ta.numpy(), step=tr_step)\n            maxed_pred = tf.argmax(preds, 1).numpy()[0]\n            maxed_true = tf.argmax(ytr).numpy()\n            correct = tf.equal(maxed_pred, maxed_true).numpy()\n        test_dataset = random.choice(test_datasets)\n        if not test_dataset:\n            continue\n        for xte, yte in test_dataset:\n            yte = tf.reshape(yte, (1, -1))\n            tel, tea = fwd.test_step(model, loss_fxn, xte, yte, test_loss, test_accuracy)\n            te_step += 1\n            with test_summary_writer.as_default():\n                tf.summary.scalar('loss', tel.numpy(), step=te_step)\n                tf.summary.scalar('accuracy', tea.numpy(), step=te_step)\n        template = 'Epoch {}, Loss: {}, Accuracy: {}, Test Loss: {}, Test Accuracy: {}, Preds: {}, Acts: {}'\n        print(template.format(epoch + 1, train_loss.result(), train_accuracy.result() * 100, test_loss.result(), test_accuracy.result() * 100, preds, ytr))\n        train_loss.reset_states()\n        test_loss.reset_states()\n        train_accuracy.reset_states()\n        test_accuracy.reset_states()\n    tf.saved_model.save(model, tfm.WRITE_TO + 'win_loss/')\n"]]}
{"hexsha": "70e4742585e29853d1350672ced44f958ac66764", "ext": "py", "lang": "Python", "content": "def _extract_metrics(out_lines) -> Tuple[pd.DataFrame, Dict[str, Optional[Union[str, int, float]]]]:\n    loss_table = {'i': [], 'loss': [], 'since_last': []}\n    metrics = {}\n    try:\n        record = False\n        _iter47 = out_lines\n        while True:\n            try:\n                line = next(_iter47)\n            except StopIteration:\n                break\n            line = line.strip()\n            if record:\n                if line == '':\n                    record = False\n                else:\n                    counter_line = line.split()\n                    try:\n                        count, average_loss, since_last = (counter_line[2], counter_line[0], counter_line[1])\n                        average_loss_f = float(average_loss)\n                        since_last_f = float(since_last)\n                        loss_table['i'].append(count)\n                        loss_table['loss'].append(average_loss_f)\n                        loss_table['since_last'].append(since_last_f)\n                    except (ValueError, TypeError):\n                        ...\n            elif line.startswith('loss'):\n                fields = line.split()\n                if fields[0] == 'loss' and fields[1] == 'last' and (fields[2] == 'counter'):\n                    record = True\n            elif '=' in line:\n                key_value = [p.strip() for p in line.split('=')]\n                if key_value[0] == 'average loss':\n                    metrics[key_value[0]] = _parse_loss(key_value[1])\n                else:\n                    metrics[key_value[0]] = _to(key_value[1], [int, float])\n    finally:\n        return (pd.DataFrame(loss_table).set_index('i'), metrics)", "fn_id": 3, "class_fn": false, "repo": "ataymano/data-science", "file": "from_mwt_ds/DataScience/vw_executor/artifacts.py", "last_update_at": "2021-12-15T21:45:13+00:00", "original_content": "def _extract_metrics(out_lines) -> Tuple[pd.DataFrame, Dict[str, Optional[Union[str, int, float]]]]:\n    loss_table = {'i': [], 'loss': [], 'since_last': []}\n    metrics = {}\n    try:\n        record = False\n        for line in out_lines:\n            line = line.strip()\n            if record:\n                if line == '':\n                    record = False\n                else:\n                    counter_line = line.split()\n                    try:\n                        count, average_loss, since_last = (counter_line[2], counter_line[0], counter_line[1])\n                        average_loss_f = float(average_loss)\n                        since_last_f = float(since_last)\n                        loss_table['i'].append(count)\n                        loss_table['loss'].append(average_loss_f)\n                        loss_table['since_last'].append(since_last_f)\n                    except (ValueError, TypeError):\n                        ...\n            elif line.startswith('loss'):\n                fields = line.split()\n                if fields[0] == 'loss' and fields[1] == 'last' and (fields[2] == 'counter'):\n                    record = True\n            elif '=' in line:\n                key_value = [p.strip() for p in line.split('=')]\n                if key_value[0] == 'average loss':\n                    metrics[key_value[0]] = _parse_loss(key_value[1])\n                else:\n                    metrics[key_value[0]] = _to(key_value[1], [int, float])\n    finally:\n        return (pd.DataFrame(loss_table).set_index('i'), metrics)", "refactored": true, "question_id": "70e4742585e29853d1350672ced44f958ac66764_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _extract_metrics(out_lines) -> Tuple[pd.DataFrame, Dict[str, Optional[Union[str, int, float]]]]:\n    loss_table = {'i': [], 'loss': [], 'since_last': []}\n    metrics = {}\n    try:\n        record = False\n        _iter47 = out_lines\n        while True:\n            try:\n                line = next(_iter47)\n            except StopIteration:\n                break\n            line = line.strip()\n            if record:\n                if line == '':\n                    record = False\n                else:\n                    counter_line = line.split()\n                    try:\n                        count, average_loss, since_last = (counter_line[2], counter_line[0], counter_line[1])\n                        average_loss_f = float(average_loss)\n                        since_last_f = float(since_last)\n                        loss_table['i'].append(count)\n                        loss_table['loss'].append(average_loss_f)\n                        loss_table['since_last'].append(since_last_f)\n                    except (ValueError, TypeError):\n                        ...\n            elif line.startswith('loss'):\n                fields = line.split()\n                if fields[0] == 'loss' and fields[1] == 'last' and (fields[2] == 'counter'):\n                    record = True\n            elif '=' in line:\n                key_value = [p.strip() for p in line.split('=')]\n                if key_value[0] == 'average loss':\n                    metrics[key_value[0]] = _parse_loss(key_value[1])\n                else:\n                    metrics[key_value[0]] = _to(key_value[1], [int, float])\n    finally:\n"]]}
{"hexsha": "4fc83d3fdc1d39e0640dd521e048db83a30a09cb", "ext": "py", "lang": "Python", "content": "@task\ndef prepare_python_packages():\n    local('mkdir -p {local_python_packages_dir}'.format(**env))\n    local('cp {local_project_root}/requirements.txt {local_python_packages_dir}/'.format(**env))\n    existing_files = set((filenameToRequirement(filename) for filename in os.listdir(env.local_python_packages_dir)))\n    missing_requirements = tempfile.NamedTemporaryFile()\n    _iter48 = open(os.path.join(env.local_project_root, 'requirements.txt'))\n    while True:\n        try:\n            raw_line = next(_iter48)\n        except StopIteration:\n            break\n        line = raw_line.strip()\n        if not line or line.startswith('#') or line not in existing_files:\n            missing_requirements.write(raw_line)\n    missing_requirements.flush()\n    local('pip install --no-use-wheel -d {env.local_python_packages_dir} --exists-action=i -r {missing_requirements_file}'.format(env=env, missing_requirements_file=missing_requirements.name))\n    missing_requirements.close()", "fn_id": 8, "class_fn": false, "repo": "jsavikko/futurice-ldap-user-manager", "file": "fabfile.py", "last_update_at": "2021-05-06T07:57:56+00:00", "original_content": "@task\ndef prepare_python_packages():\n    local('mkdir -p {local_python_packages_dir}'.format(**env))\n    local('cp {local_project_root}/requirements.txt {local_python_packages_dir}/'.format(**env))\n    existing_files = set((filenameToRequirement(filename) for filename in os.listdir(env.local_python_packages_dir)))\n    missing_requirements = tempfile.NamedTemporaryFile()\n    for raw_line in open(os.path.join(env.local_project_root, 'requirements.txt')):\n        line = raw_line.strip()\n        if not line or line.startswith('#') or line not in existing_files:\n            missing_requirements.write(raw_line)\n    missing_requirements.flush()\n    local('pip install --no-use-wheel -d {env.local_python_packages_dir} --exists-action=i -r {missing_requirements_file}'.format(env=env, missing_requirements_file=missing_requirements.name))\n    missing_requirements.close()", "refactored": true, "question_id": "4fc83d3fdc1d39e0640dd521e048db83a30a09cb_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@task\ndef prepare_python_packages():\n    local('mkdir -p {local_python_packages_dir}'.format(**env))\n    local('cp {local_project_root}/requirements.txt {local_python_packages_dir}/'.format(**env))\n    existing_files = set((filenameToRequirement(filename) for filename in os.listdir(env.local_python_packages_dir)))\n    missing_requirements = tempfile.NamedTemporaryFile()\n    _iter48 = open(os.path.join(env.local_project_root, 'requirements.txt'))\n    while True:\n        try:\n            raw_line = next(_iter48)\n        except StopIteration:\n            break\n        line = raw_line.strip()\n        if not line or line.startswith('#') or line not in existing_files:\n            missing_requirements.write(raw_line)\n    missing_requirements.flush()\n    local('pip install --no-use-wheel -d {env.local_python_packages_dir} --exists-action=i -r {missing_requirements_file}'.format(env=env, missing_requirements_file=missing_requirements.name))\n"]]}
{"hexsha": "c8cc0e831e5f48f15a8c98373df38d2e3f24ded3", "ext": "py", "lang": "Python", "content": "def heap_sort(list_item):\n    \"\"\"\n    Heap Sort\n    Time Complexity of Solution:\n    Best - O(nlog(n))\n    Average - O(nlog(n))\n    Worst - O(nlog(n))\n\n    Approach:\n    Heap sort takes place in two steps. In first step, array is\n    transformed into a heap.\n    In second step, heap is continously reduced to a sorted array.\n\n    \"\"\"\n    end = len(list_item)\n    start = end // 2 - 1\n    for i in range(start, -1, -1):\n        heapify(list_item, end, i)\n    _iter49 = range(end - 1, 0, -1)\n    while True:\n        try:\n            i = next(_iter49)\n        except StopIteration:\n            break\n        swap(list_item, i, 0)\n        heapify(list_item, i, 0)", "fn_id": 0, "class_fn": false, "repo": "mish24/pydsa", "file": "pydsa/heap_sort.py", "last_update_at": "2021-11-02T09:24:38+00:00", "original_content": "def heap_sort(list_item):\n    \"\"\"\n    Heap Sort\n    Time Complexity of Solution:\n    Best - O(nlog(n))\n    Average - O(nlog(n))\n    Worst - O(nlog(n))\n\n    Approach:\n    Heap sort takes place in two steps. In first step, array is\n    transformed into a heap.\n    In second step, heap is continously reduced to a sorted array.\n\n    \"\"\"\n    end = len(list_item)\n    start = end // 2 - 1\n    for i in range(start, -1, -1):\n        heapify(list_item, end, i)\n    for i in range(end - 1, 0, -1):\n        swap(list_item, i, 0)\n        heapify(list_item, i, 0)", "refactored": true, "question_id": "c8cc0e831e5f48f15a8c98373df38d2e3f24ded3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def heap_sort(list_item):\n    \"\"\"\n    Heap Sort\n    Time Complexity of Solution:\n    Best - O(nlog(n))\n    Average - O(nlog(n))\n    Worst - O(nlog(n))\n    Approach:\n    Heap sort takes place in two steps. In first step, array is\n    transformed into a heap.\n    In second step, heap is continously reduced to a sorted array.\n    \"\"\"\n    end = len(list_item)\n    start = end // 2 - 1\n    for i in range(start, -1, -1):\n        heapify(list_item, end, i)\n    _iter49 = range(end - 1, 0, -1)\n    while True:\n        try:\n            i = next(_iter49)\n        except StopIteration:\n            break\n        swap(list_item, i, 0)\n"]]}
{"hexsha": "b36cd3ac7c6ccf4bb43ebb3004f30af35e47297a", "ext": "py", "lang": "Python", "content": "def generateCoordsForLayersPG(dictDlsLayers, graphvizLayout, isHorizontal):\n    theGraph = pyg.AGraph()\n    for kk, vv in dictDlsLayers.items():\n        for ll in vv['cfg']['wires']:\n            theGraph.add_edge(kk, ll)\n    if isHorizontal:\n        pArgs = '-Grankdir=LR'\n    else:\n        pArgs = '-Grankdir=TB'\n    if graphvizLayout is None:\n        graphvizLayout = 'dot'\n    theGraph.layout(prog=graphvizLayout, args=pArgs)\n    theGraphPos = {}\n    _iter50 = dictDlsLayers.keys()\n    while True:\n        try:\n            kk = next(_iter50)\n        except StopIteration:\n            break\n        tnode = theGraph.get_node(kk)\n        tpos = [int(float(xx)) for xx in tnode.attr['pos'].split(',')]\n        theGraphPos[kk] = tuple(tpos)\n    return theGraphPos", "fn_id": 2, "class_fn": false, "repo": "SummaLabs/DLS", "file": "app/backend/core/models/convertors/keras2dls.py", "last_update_at": "2021-02-16T23:08:34+00:00", "original_content": "def generateCoordsForLayersPG(dictDlsLayers, graphvizLayout, isHorizontal):\n    theGraph = pyg.AGraph()\n    for kk, vv in dictDlsLayers.items():\n        for ll in vv['cfg']['wires']:\n            theGraph.add_edge(kk, ll)\n    if isHorizontal:\n        pArgs = '-Grankdir=LR'\n    else:\n        pArgs = '-Grankdir=TB'\n    if graphvizLayout is None:\n        graphvizLayout = 'dot'\n    theGraph.layout(prog=graphvizLayout, args=pArgs)\n    theGraphPos = {}\n    for kk in dictDlsLayers.keys():\n        tnode = theGraph.get_node(kk)\n        tpos = [int(float(xx)) for xx in tnode.attr['pos'].split(',')]\n        theGraphPos[kk] = tuple(tpos)\n    return theGraphPos", "refactored": true, "question_id": "b36cd3ac7c6ccf4bb43ebb3004f30af35e47297a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def generateCoordsForLayersPG(dictDlsLayers, graphvizLayout, isHorizontal):\n    theGraph = pyg.AGraph()\n    for kk, vv in dictDlsLayers.items():\n        for ll in vv['cfg']['wires']:\n            theGraph.add_edge(kk, ll)\n    if isHorizontal:\n        pArgs = '-Grankdir=LR'\n    else:\n        pArgs = '-Grankdir=TB'\n    if graphvizLayout is None:\n        graphvizLayout = 'dot'\n    theGraph.layout(prog=graphvizLayout, args=pArgs)\n    theGraphPos = {}\n    _iter50 = dictDlsLayers.keys()\n    while True:\n        try:\n            kk = next(_iter50)\n        except StopIteration:\n            break\n        tnode = theGraph.get_node(kk)\n        tpos = [int(float(xx)) for xx in tnode.attr['pos'].split(',')]\n        theGraphPos[kk] = tuple(tpos)\n"]]}
{"hexsha": "47fe8ba25f624d3f52e3accc1fc3872135959f05", "ext": "py", "lang": "Python", "content": "def main(args):\n    \"\"\"\n    The starting point of the program.\n    \"\"\"\n    for _ in iter(lambda: 0, 1):\n        if not True:\n            break\n        num_items = 1\n        read_data = ReadData() if len(args) == 1 else ReadData(args)\n        data_log_df = get_file_df(read_data.get_data_log())\n        exe_table_df = get_file_df(read_data.get_exe_table())\n        doses_delta_df = get_file_df(read_data.get_doses_delta())\n        summary = get_summary(read_data.get_summary())\n        dfs = [('data_log', data_log_df[-num_items:]), ('exe_table', exe_table_df[-num_items:]), ('doses_delta', doses_delta_df[-num_items:])]\n        data_json = get_json(dfs, summary, read_data.json_name)\n        read_data.json = data_json\n        time.sleep(5)", "fn_id": 3, "class_fn": false, "repo": "cs481-ekh/s21-team-jat", "file": "python/read_data.py", "last_update_at": "2021-04-06T17:16:24+00:00", "original_content": "def main(args):\n    \"\"\"\n    The starting point of the program.\n    \"\"\"\n    while True:\n        num_items = 1\n        read_data = ReadData() if len(args) == 1 else ReadData(args)\n        data_log_df = get_file_df(read_data.get_data_log())\n        exe_table_df = get_file_df(read_data.get_exe_table())\n        doses_delta_df = get_file_df(read_data.get_doses_delta())\n        summary = get_summary(read_data.get_summary())\n        dfs = [('data_log', data_log_df[-num_items:]), ('exe_table', exe_table_df[-num_items:]), ('doses_delta', doses_delta_df[-num_items:])]\n        data_json = get_json(dfs, summary, read_data.json_name)\n        read_data.json = data_json\n        time.sleep(5)", "refactored": true, "question_id": "47fe8ba25f624d3f52e3accc1fc3872135959f05_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def main(args):\n    \"\"\"\n    The starting point of the program.\n    \"\"\"\n    for _ in iter(lambda: 0, 1):\n        if not True:\n            break\n        num_items = 1\n        read_data = ReadData() if len(args) == 1 else ReadData(args)\n        data_log_df = get_file_df(read_data.get_data_log())\n        exe_table_df = get_file_df(read_data.get_exe_table())\n        doses_delta_df = get_file_df(read_data.get_doses_delta())\n        summary = get_summary(read_data.get_summary())\n        dfs = [('data_log', data_log_df[-num_items:]), ('exe_table', exe_table_df[-num_items:]), ('doses_delta', doses_delta_df[-num_items:])]\n        data_json = get_json(dfs, summary, read_data.json_name)\n        read_data.json = data_json\n"]]}
{"hexsha": "35daad5aecd0ac3a78c0c2339cbf51e0014f3f74", "ext": "py", "lang": "Python", "content": "def Predict(Phi, b, mu, s, t, r, outd):\n    print(t, '--t')\n    dt = t[1] - t[0]\n    tmin = min(t)\n    tmax = max(t)\n    t2 = np.linspace(tmin, tmax, num_pred)\n    Psi = np.zeros([r, len(t2)], dtype='complex')\n    for i, _x in enumerate(t2):\n        print(_x, '_x')\n        print(b, 'b')\n        print(i)\n        print(shape(Psi))\n        Psi[:, i] = multiply(power(mu, _x / dt), b)\n    D2 = dot(Phi, Psi)\n    sigmaps = []\n    tps = []\n    _iter51 = range(len(D2[0, :]))\n    while True:\n        try:\n            i = next(_iter51)\n        except StopIteration:\n            break\n        print(str(i) + '--predicted...' + str(t2[i]))\n        F = D2[:, i]\n        if i == 0:\n            F0 = average(F)\n        eps = t2[i]\n        sigma = MakeImagePred(F - F0, i, s, eps, outd)\n        tps.append(t2[i])\n        sigmaps.append(sigma + eps)\n    return (tps, sigmaps)", "fn_id": 10, "class_fn": false, "repo": "PapStatMechMat/SeaPy", "file": "RunSEAmodes.py", "last_update_at": "2021-05-26T05:16:05+00:00", "original_content": "def Predict(Phi, b, mu, s, t, r, outd):\n    print(t, '--t')\n    dt = t[1] - t[0]\n    tmin = min(t)\n    tmax = max(t)\n    t2 = np.linspace(tmin, tmax, num_pred)\n    Psi = np.zeros([r, len(t2)], dtype='complex')\n    for i, _x in enumerate(t2):\n        print(_x, '_x')\n        print(b, 'b')\n        print(i)\n        print(shape(Psi))\n        Psi[:, i] = multiply(power(mu, _x / dt), b)\n    D2 = dot(Phi, Psi)\n    sigmaps = []\n    tps = []\n    for i in range(len(D2[0, :])):\n        print(str(i) + '--predicted...' + str(t2[i]))\n        F = D2[:, i]\n        if i == 0:\n            F0 = average(F)\n        eps = t2[i]\n        sigma = MakeImagePred(F - F0, i, s, eps, outd)\n        tps.append(t2[i])\n        sigmaps.append(sigma + eps)\n    return (tps, sigmaps)", "refactored": true, "question_id": "35daad5aecd0ac3a78c0c2339cbf51e0014f3f74_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def Predict(Phi, b, mu, s, t, r, outd):\n    print(t, '--t')\n    dt = t[1] - t[0]\n    tmin = min(t)\n    tmax = max(t)\n    t2 = np.linspace(tmin, tmax, num_pred)\n    Psi = np.zeros([r, len(t2)], dtype='complex')\n    for i, _x in enumerate(t2):\n        print(_x, '_x')\n        print(b, 'b')\n        print(i)\n        print(shape(Psi))\n        Psi[:, i] = multiply(power(mu, _x / dt), b)\n    D2 = dot(Phi, Psi)\n    sigmaps = []\n    tps = []\n    _iter51 = range(len(D2[0, :]))\n    while True:\n        try:\n            i = next(_iter51)\n        except StopIteration:\n            break\n        print(str(i) + '--predicted...' + str(t2[i]))\n        F = D2[:, i]\n        if i == 0:\n            F0 = average(F)\n        eps = t2[i]\n        sigma = MakeImagePred(F - F0, i, s, eps, outd)\n        tps.append(t2[i])\n        sigmaps.append(sigma + eps)\n"]]}
{"hexsha": "fbbdcaf00a8d9fa8c6f2f80cfad9ef55df7708dc", "ext": "py", "lang": "Python", "content": "def fromList(li: List[int]):\n    if len(li) == 0:\n        return None\n    root = TreeNode(val=li[0])\n    queue = [root]\n    i = 1\n    for _ in iter(lambda: 0, 1):\n        if not i < len(li):\n            break\n        node = queue[0]\n        del queue[0]\n        if li[i] is not None:\n            node.left = TreeNode(val=li[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(li):\n            if li[i]:\n                node.right = TreeNode(val=li[i])\n                queue.append(node.right)\n            i += 1\n    return root", "fn_id": 0, "class_fn": false, "repo": "wanglongjiang/leetcode", "file": "easy/897-increasing-order-search-tree.py", "last_update_at": "2021-03-14T11:38:30+00:00", "original_content": "def fromList(li: List[int]):\n    if len(li) == 0:\n        return None\n    root = TreeNode(val=li[0])\n    queue = [root]\n    i = 1\n    while i < len(li):\n        node = queue[0]\n        del queue[0]\n        if li[i] is not None:\n            node.left = TreeNode(val=li[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(li):\n            if li[i]:\n                node.right = TreeNode(val=li[i])\n                queue.append(node.right)\n            i += 1\n    return root", "refactored": true, "question_id": "fbbdcaf00a8d9fa8c6f2f80cfad9ef55df7708dc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def fromList(li: List[int]):\n    if len(li) == 0:\n        return None\n    root = TreeNode(val=li[0])\n    queue = [root]\n    i = 1\n    for _ in iter(lambda: 0, 1):\n        if not i < len(li):\n            break\n        node = queue[0]\n        del queue[0]\n        if li[i] is not None:\n            node.left = TreeNode(val=li[i])\n            queue.append(node.left)\n        i += 1\n        if i < len(li):\n            if li[i]:\n                node.right = TreeNode(val=li[i])\n                queue.append(node.right)\n            i += 1\n"]]}
{"hexsha": "0629068ef6b33dbfeb46975094295e4a4c07df96", "ext": "py", "lang": "Python", "content": "def which(program):\n    \"\"\"Determines if and where an executable exists on the users path.\n    This code was contributed by Jay at http://stackoverflow.com/a/377028\n    Args:\n        program (str): The name, or path for the program.\n    Returns:\n        The program or executable.\n    \"\"\"\n    import os\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n    fpath, fname = os.path.split(program)\n    if fpath and is_exe(program):\n        return program\n    else:\n        _iter52 = os.environ['PATH'].split(os.pathsep)\n        while True:\n            try:\n                path = next(_iter52)\n            except StopIteration:\n                break\n            path = path.strip('\"')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n    return None", "fn_id": 5, "class_fn": false, "repo": "wsmorgan/phonon-enumeration", "file": "phenum/io_utils.py", "last_update_at": "2021-05-30T21:02:08+00:00", "original_content": "def which(program):\n    \"\"\"Determines if and where an executable exists on the users path.\n    This code was contributed by Jay at http://stackoverflow.com/a/377028\n    Args:\n        program (str): The name, or path for the program.\n    Returns:\n        The program or executable.\n    \"\"\"\n    import os\n\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n    fpath, fname = os.path.split(program)\n    if fpath and is_exe(program):\n        return program\n    else:\n        for path in os.environ['PATH'].split(os.pathsep):\n            path = path.strip('\"')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n    return None", "refactored": true, "question_id": "0629068ef6b33dbfeb46975094295e4a4c07df96_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def which(program):\n    \"\"\"Determines if and where an executable exists on the users path.\n    This code was contributed by Jay at http://stackoverflow.com/a/377028\n    Args:\n        program (str): The name, or path for the program.\n    Returns:\n        The program or executable.\n    \"\"\"\n    import os\n    def is_exe(fpath):\n        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)\n    fpath, fname = os.path.split(program)\n    if fpath and is_exe(program):\n        return program\n    else:\n        _iter52 = os.environ['PATH'].split(os.pathsep)\n        while True:\n            try:\n                path = next(_iter52)\n            except StopIteration:\n                break\n            path = path.strip('\"')\n            exe_file = os.path.join(path, program)\n            if is_exe(exe_file):\n                return exe_file\n"]]}
{"hexsha": "44f8ed8d741874b6b1b7ec273d09a2bf1be84c93", "ext": "py", "lang": "Python", "content": "def test_schemakey():\n    typemap = {'BareAsset': 'Asset', 'PublishedAsset': 'Asset', 'PublishedDandiset': 'Dandiset'}\n    _iter53 = dir(models)\n    while True:\n        try:\n            val = next(_iter53)\n        except StopIteration:\n            break\n        if val in ['BaseModel']:\n            continue\n        klass = getattr(models, val)\n        if isinstance(klass, pydantic.main.ModelMetaclass):\n            assert 'schemaKey' in klass.__fields__\n            if val in typemap:\n                assert typemap[val] == klass.__fields__['schemaKey'].default\n            else:\n                assert val == klass.__fields__['schemaKey'].default", "fn_id": 3, "class_fn": false, "repo": "dandi/dandischema", "file": "dandischema/tests/test_models.py", "last_update_at": "2021-09-19T10:56:25+00:00", "original_content": "def test_schemakey():\n    typemap = {'BareAsset': 'Asset', 'PublishedAsset': 'Asset', 'PublishedDandiset': 'Dandiset'}\n    for val in dir(models):\n        if val in ['BaseModel']:\n            continue\n        klass = getattr(models, val)\n        if isinstance(klass, pydantic.main.ModelMetaclass):\n            assert 'schemaKey' in klass.__fields__\n            if val in typemap:\n                assert typemap[val] == klass.__fields__['schemaKey'].default\n            else:\n                assert val == klass.__fields__['schemaKey'].default", "refactored": true, "question_id": "44f8ed8d741874b6b1b7ec273d09a2bf1be84c93_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def test_schemakey():\n    typemap = {'BareAsset': 'Asset', 'PublishedAsset': 'Asset', 'PublishedDandiset': 'Dandiset'}\n    _iter53 = dir(models)\n    while True:\n        try:\n            val = next(_iter53)\n        except StopIteration:\n            break\n        if val in ['BaseModel']:\n            continue\n        klass = getattr(models, val)\n        if isinstance(klass, pydantic.main.ModelMetaclass):\n            assert 'schemaKey' in klass.__fields__\n            if val in typemap:\n                assert typemap[val] == klass.__fields__['schemaKey'].default\n            else:\n"]]}
{"hexsha": "12b9c9e1e1cd70be553e0f6bc5aeab33f9e284de", "ext": "py", "lang": "Python", "content": "def build_data_str(records):\n    records_data_str = []\n    _iter54 = records\n    while True:\n        try:\n            record = next(_iter54)\n        except StopIteration:\n            break\n        records_data_str.append(tup_to_str(record))\n    return records_data_str", "fn_id": 0, "class_fn": false, "repo": "pangeon/Taskello", "file": "utils/str_utils.py", "last_update_at": "2021-06-22T21:18:37+00:00", "original_content": "def build_data_str(records):\n    records_data_str = []\n    for record in records:\n        records_data_str.append(tup_to_str(record))\n    return records_data_str", "refactored": true, "question_id": "12b9c9e1e1cd70be553e0f6bc5aeab33f9e284de_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def build_data_str(records):\n    records_data_str = []\n    _iter54 = records\n    while True:\n        try:\n            record = next(_iter54)\n        except StopIteration:\n            break\n        records_data_str.append(tup_to_str(record))\n"]]}
{"hexsha": "6fb0abbb3b81f5bf6e666d791414fa75ce85b499", "ext": "py", "lang": "Python", "content": "def _read_checkpoint_file(checkpoint_file: Optional[str]) -> Tuple[Set[str], Set[str]]:\n    colls, users = (set(), set())\n    if checkpoint_file:\n        with open(checkpoint_file) as fd:\n            _iter55 = fd.readlines()\n            while True:\n                try:\n                    line = next(_iter55)\n                except StopIteration:\n                    break\n                if line.startswith('CHECKPOINT'):\n                    _, type_, oid = line.split()\n                    if type_ == 'collection':\n                        colls.add(oid)\n                    elif type_ == 'user':\n                        users.add(oid)\n    return (colls, users)", "fn_id": 6, "class_fn": false, "repo": "girder/dkc-next", "file": "dkc/core/management/commands/migrate_dkc_db.py", "last_update_at": "2021-02-17T20:34:11+00:00", "original_content": "def _read_checkpoint_file(checkpoint_file: Optional[str]) -> Tuple[Set[str], Set[str]]:\n    colls, users = (set(), set())\n    if checkpoint_file:\n        with open(checkpoint_file) as fd:\n            for line in fd.readlines():\n                if line.startswith('CHECKPOINT'):\n                    _, type_, oid = line.split()\n                    if type_ == 'collection':\n                        colls.add(oid)\n                    elif type_ == 'user':\n                        users.add(oid)\n    return (colls, users)", "refactored": true, "question_id": "6fb0abbb3b81f5bf6e666d791414fa75ce85b499_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _read_checkpoint_file(checkpoint_file: Optional[str]) -> Tuple[Set[str], Set[str]]:\n    colls, users = (set(), set())\n    if checkpoint_file:\n        with open(checkpoint_file) as fd:\n            _iter55 = fd.readlines()\n            while True:\n                try:\n                    line = next(_iter55)\n                except StopIteration:\n                    break\n                if line.startswith('CHECKPOINT'):\n                    _, type_, oid = line.split()\n                    if type_ == 'collection':\n                        colls.add(oid)\n                    elif type_ == 'user':\n                        users.add(oid)\n"]]}
{"hexsha": "dac2bf672e1bd9ca92568b7538b014b4a37dd949", "ext": "py", "lang": "Python", "content": "def find_euler_random(n):\n    for _ in iter(lambda: 0, 1):\n        if not True:\n            break\n        el = np.array([random.randint(0, 4) * 2 for x in range(n + 1)])\n        try:\n            g = Graph.from_sequence(el)\n            choose_biggest_comp(g)\n            if g.adjacency.shape[0] != n:\n                continue\n            print(g.adjacency)\n            for i in range(el.shape[0] * 3):\n                g.randomize_edges()\n            print(g.adjacency)\n            graph = nx.from_numpy_matrix(g.adjacency)\n            euler_list = []\n            euler(g.adjacency.tolist(), 0, euler_list)\n            print(euler_list)\n            plt.subplot(111)\n            nx.draw(graph, with_labels=True, font_weight='bold')\n            plt.show()\n            break\n        except NotGraphicSequenceException:\n            continue", "fn_id": 3, "class_fn": false, "repo": "timcki/graficiarze", "file": "02_project/main.py", "last_update_at": "2021-05-14T11:35:04+00:00", "original_content": "def find_euler_random(n):\n    while True:\n        el = np.array([random.randint(0, 4) * 2 for x in range(n + 1)])\n        try:\n            g = Graph.from_sequence(el)\n            choose_biggest_comp(g)\n            if g.adjacency.shape[0] != n:\n                continue\n            print(g.adjacency)\n            for i in range(el.shape[0] * 3):\n                g.randomize_edges()\n            print(g.adjacency)\n            graph = nx.from_numpy_matrix(g.adjacency)\n            euler_list = []\n            euler(g.adjacency.tolist(), 0, euler_list)\n            print(euler_list)\n            plt.subplot(111)\n            nx.draw(graph, with_labels=True, font_weight='bold')\n            plt.show()\n            break\n        except NotGraphicSequenceException:\n            continue", "refactored": true, "question_id": "dac2bf672e1bd9ca92568b7538b014b4a37dd949_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def find_euler_random(n):\n    for _ in iter(lambda: 0, 1):\n        if not True:\n            break\n        el = np.array([random.randint(0, 4) * 2 for x in range(n + 1)])\n        try:\n            g = Graph.from_sequence(el)\n            choose_biggest_comp(g)\n            if g.adjacency.shape[0] != n:\n                continue\n            print(g.adjacency)\n            for i in range(el.shape[0] * 3):\n                g.randomize_edges()\n            print(g.adjacency)\n            graph = nx.from_numpy_matrix(g.adjacency)\n            euler_list = []\n            euler(g.adjacency.tolist(), 0, euler_list)\n            print(euler_list)\n            plt.subplot(111)\n            nx.draw(graph, with_labels=True, font_weight='bold')\n            plt.show()\n            break\n        except NotGraphicSequenceException:\n"]]}
{"hexsha": "bc8a29dc53319c769a4b51f92593b8f3fdee45c6", "ext": "py", "lang": "Python", "content": "def update_df_all(df_all, training_data, validation_data, test_data):\n    \"\"\"Add a column \"group\" to df_all indicating train/validation or test\"\"\"\n    df_all['group'] = 0\n    _iter56 = training_data\n    while True:\n        try:\n            simu_name = next(_iter56)\n        except StopIteration:\n            break\n        df_all['group'][df_all['topo_name'] == simu_name] = 'train'\n    for simu_name in validation_data:\n        df_all['group'][df_all['topo_name'] == simu_name] = 'validation'\n    for simu_name in test_data:\n        df_all['group'][df_all['topo_name'] == simu_name] = 'test'\n    return df_all", "fn_id": 1, "class_fn": false, "repo": "louisletoumelin/wind_downscaling_cnn", "file": "pre_process/preprocess_folds.py", "last_update_at": "2021-12-13T16:26:31+00:00", "original_content": "def update_df_all(df_all, training_data, validation_data, test_data):\n    \"\"\"Add a column \"group\" to df_all indicating train/validation or test\"\"\"\n    df_all['group'] = 0\n    for simu_name in training_data:\n        df_all['group'][df_all['topo_name'] == simu_name] = 'train'\n    for simu_name in validation_data:\n        df_all['group'][df_all['topo_name'] == simu_name] = 'validation'\n    for simu_name in test_data:\n        df_all['group'][df_all['topo_name'] == simu_name] = 'test'\n    return df_all", "refactored": true, "question_id": "bc8a29dc53319c769a4b51f92593b8f3fdee45c6_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def update_df_all(df_all, training_data, validation_data, test_data):\n    \"\"\"Add a column \"group\" to df_all indicating train/validation or test\"\"\"\n    df_all['group'] = 0\n    _iter56 = training_data\n    while True:\n        try:\n            simu_name = next(_iter56)\n        except StopIteration:\n            break\n        df_all['group'][df_all['topo_name'] == simu_name] = 'train'\n    for simu_name in validation_data:\n        df_all['group'][df_all['topo_name'] == simu_name] = 'validation'\n    for simu_name in test_data:\n        df_all['group'][df_all['topo_name'] == simu_name] = 'test'\n"]]}
{"hexsha": "8644f9b2a8f01c213caf5bcbd4d123b465cabeeb", "ext": "py", "lang": "Python", "content": "@leet2git.command()\n@click.option('--source-repository', '-s', default='', help='the path to the folder where the code will be saved')\n@click.option('--language', '-l', default='python3', help='the default language')\n@click.option('--soft/--hard', default=True, help='A soft reset only erases the database. A hard reset also erase the files.')\n@click.pass_obj\ndef reset(cm: ConfigManager, source_repository: str, language: str, soft: bool):\n    \"\"\"Reset the configuration file\n    \\x0c\n    Args:\n        source_repository (str, optional): the path to the folder where the code will be saved.\n            Defaults to \"\".\n        language (str, optional): the default language. Defaults to \"python3\".\n        soft(bool, optional): the reset hardness. Defaults to soft.\n    \"\"\"\n    if not soft:\n        try:\n            click.confirm(f\"This will delete EVERY solution and test file inside                     the {cm.config['source_path']} folder.                      Still want to proceed?\", abort=True)\n        except Abort:\n            return\n        file_list = glob.glob(os.path.join(cm.config['source_path'], 'src', 'leetcode_*')) + glob.glob(os.path.join(cm.config['source_path'], 'tests', 'test_*'))\n        _iter57 = file_list\n        while True:\n            try:\n                file = next(_iter57)\n            except StopIteration:\n                break\n            try:\n                os.remove(file)\n            except FileNotFoundError as e:\n                click.secho(e.args)\n    else:\n        try:\n            click.confirm('This will delete the question database. Still want to proceed?', abort=True)\n        except Abort:\n            return\n    reset_config(cm, source_repository, language)\n    cm.load_config()\n    qdb = QuestionDB(cm.config)\n    qdb.reset()\n    if not soft:\n        data = QuestionData(language=cm.config['language'])\n        file_handler = create_file_handler(data, cm.config)\n        file_handler.generate_repo(cm.config['source_path'])", "fn_id": 7, "class_fn": false, "repo": "sungho-joo/leetcode2github", "file": "src/leet2git/leet2git.py", "last_update_at": "2021-05-07T08:26:47+00:00", "original_content": "@leet2git.command()\n@click.option('--source-repository', '-s', default='', help='the path to the folder where the code will be saved')\n@click.option('--language', '-l', default='python3', help='the default language')\n@click.option('--soft/--hard', default=True, help='A soft reset only erases the database. A hard reset also erase the files.')\n@click.pass_obj\ndef reset(cm: ConfigManager, source_repository: str, language: str, soft: bool):\n    \"\"\"Reset the configuration file\n    \\x0c\n    Args:\n        source_repository (str, optional): the path to the folder where the code will be saved.\n            Defaults to \"\".\n        language (str, optional): the default language. Defaults to \"python3\".\n        soft(bool, optional): the reset hardness. Defaults to soft.\n    \"\"\"\n    if not soft:\n        try:\n            click.confirm(f\"This will delete EVERY solution and test file inside                     the {cm.config['source_path']} folder.                      Still want to proceed?\", abort=True)\n        except Abort:\n            return\n        file_list = glob.glob(os.path.join(cm.config['source_path'], 'src', 'leetcode_*')) + glob.glob(os.path.join(cm.config['source_path'], 'tests', 'test_*'))\n        for file in file_list:\n            try:\n                os.remove(file)\n            except FileNotFoundError as e:\n                click.secho(e.args)\n    else:\n        try:\n            click.confirm('This will delete the question database. Still want to proceed?', abort=True)\n        except Abort:\n            return\n    reset_config(cm, source_repository, language)\n    cm.load_config()\n    qdb = QuestionDB(cm.config)\n    qdb.reset()\n    if not soft:\n        data = QuestionData(language=cm.config['language'])\n        file_handler = create_file_handler(data, cm.config)\n        file_handler.generate_repo(cm.config['source_path'])", "refactored": true, "question_id": "8644f9b2a8f01c213caf5bcbd4d123b465cabeeb_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@leet2git.command()\n@click.option('--source-repository', '-s', default='', help='the path to the folder where the code will be saved')\n@click.option('--language', '-l', default='python3', help='the default language')\n@click.option('--soft/--hard', default=True, help='A soft reset only erases the database. A hard reset also erase the files.')\n@click.pass_obj\ndef reset(cm: ConfigManager, source_repository: str, language: str, soft: bool):\n    \"\"\"Reset the configuration file\n    \\x0c\n    Args:\n        source_repository (str, optional): the path to the folder where the code will be saved.\n            Defaults to \"\".\n        language (str, optional): the default language. Defaults to \"python3\".\n        soft(bool, optional): the reset hardness. Defaults to soft.\n    \"\"\"\n    if not soft:\n        try:\n            click.confirm(f\"This will delete EVERY solution and test file inside                     the {cm.config['source_path']} folder.                      Still want to proceed?\", abort=True)\n        except Abort:\n            return\n        file_list = glob.glob(os.path.join(cm.config['source_path'], 'src', 'leetcode_*')) + glob.glob(os.path.join(cm.config['source_path'], 'tests', 'test_*'))\n        _iter57 = file_list\n        while True:\n            try:\n                file = next(_iter57)\n            except StopIteration:\n                break\n            try:\n                os.remove(file)\n            except FileNotFoundError as e:\n                click.secho(e.args)\n    else:\n        try:\n            click.confirm('This will delete the question database. Still want to proceed?', abort=True)\n        except Abort:\n            return\n    reset_config(cm, source_repository, language)\n    cm.load_config()\n    qdb = QuestionDB(cm.config)\n    qdb.reset()\n    if not soft:\n        data = QuestionData(language=cm.config['language'])\n        file_handler = create_file_handler(data, cm.config)\n"]]}
{"hexsha": "5ecff52b202fb2311f75b717f10ecda7192b0a5e", "ext": "py", "lang": "Python", "content": "def extract_cands_in_generate(type, constraints=set()):\n    cands = []\n    _iter58 = CONCEPTS[type]\n    while True:\n        try:\n            t = next(_iter58)\n        except StopIteration:\n            break\n        if all([is_consistent(t, c) for c in constraints]) or not constraints:\n            cands.append(t)\n    return cands", "fn_id": 5, "class_fn": false, "repo": "simon555/baby-ai-game", "file": "levels/instr_gen.py", "last_update_at": "2021-11-03T15:36:56+00:00", "original_content": "def extract_cands_in_generate(type, constraints=set()):\n    cands = []\n    for t in CONCEPTS[type]:\n        if all([is_consistent(t, c) for c in constraints]) or not constraints:\n            cands.append(t)\n    return cands", "refactored": true, "question_id": "5ecff52b202fb2311f75b717f10ecda7192b0a5e_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def extract_cands_in_generate(type, constraints=set()):\n    cands = []\n    _iter58 = CONCEPTS[type]\n    while True:\n        try:\n            t = next(_iter58)\n        except StopIteration:\n            break\n        if all([is_consistent(t, c) for c in constraints]) or not constraints:\n            cands.append(t)\n"]]}
{"hexsha": "1bafe6e69cd8c367d829bb77f059218e660a5475", "ext": "py", "lang": "Python", "content": "def computeStarsItembased(corated, target_bid, model):\n    \"\"\"\n    corated - {bid: star, ...}\n    \"\"\"\n    if corated == None:\n        return None\n    corated.pop(target_bid, None)\n    bid_cor = list(corated.keys())\n    collect = []\n    for b in bid_cor:\n        pair = None\n        if b < target_bid:\n            pair = (b, target_bid)\n        else:\n            pair = (target_bid, b)\n        w = model.get(pair)\n        if w != None:\n            collect.append((pair, w, b))\n    collect.sort(key=lambda x: x[1], reverse=True)\n    neighbors = collect[:N_NEIGHBORS_ITEMBASED]\n    sum_w = 0\n    n = 0\n    _iter59 = neighbors\n    while True:\n        try:\n            p, w, b = next(_iter59)\n        except StopIteration:\n            break\n        star = corated[b]\n        n += star * w\n        sum_w += w\n    if sum_w == 0:\n        return None\n    else:\n        return n / sum_w", "fn_id": 2, "class_fn": false, "repo": "maple1eaf/data_mining_inf553", "file": "assignment/assignment3/python/task3/task3predict_dev.py", "last_update_at": "2021-05-04T05:17:57+00:00", "original_content": "def computeStarsItembased(corated, target_bid, model):\n    \"\"\"\n    corated - {bid: star, ...}\n    \"\"\"\n    if corated == None:\n        return None\n    corated.pop(target_bid, None)\n    bid_cor = list(corated.keys())\n    collect = []\n    for b in bid_cor:\n        pair = None\n        if b < target_bid:\n            pair = (b, target_bid)\n        else:\n            pair = (target_bid, b)\n        w = model.get(pair)\n        if w != None:\n            collect.append((pair, w, b))\n    collect.sort(key=lambda x: x[1], reverse=True)\n    neighbors = collect[:N_NEIGHBORS_ITEMBASED]\n    sum_w = 0\n    n = 0\n    for p, w, b in neighbors:\n        star = corated[b]\n        n += star * w\n        sum_w += w\n    if sum_w == 0:\n        return None\n    else:\n        return n / sum_w", "refactored": true, "question_id": "1bafe6e69cd8c367d829bb77f059218e660a5475_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def computeStarsItembased(corated, target_bid, model):\n    \"\"\"\n    corated - {bid: star, ...}\n    \"\"\"\n    if corated == None:\n        return None\n    corated.pop(target_bid, None)\n    bid_cor = list(corated.keys())\n    collect = []\n    for b in bid_cor:\n        pair = None\n        if b < target_bid:\n            pair = (b, target_bid)\n        else:\n            pair = (target_bid, b)\n        w = model.get(pair)\n        if w != None:\n            collect.append((pair, w, b))\n    collect.sort(key=lambda x: x[1], reverse=True)\n    neighbors = collect[:N_NEIGHBORS_ITEMBASED]\n    sum_w = 0\n    n = 0\n    _iter59 = neighbors\n    while True:\n        try:\n            p, w, b = next(_iter59)\n        except StopIteration:\n            break\n        star = corated[b]\n        n += star * w\n        sum_w += w\n    if sum_w == 0:\n        return None\n    else:\n"]]}
{"hexsha": "bc9cb89c9de7c8845a3f7858c2bf081cca88afc4", "ext": "py", "lang": "Python", "content": "def main():\n    parser = argparse.ArgumentParser()\n    default_url = 'https://search.api.hubmapconsortium.org/portal/search'\n    parser.add_argument('--url', default=default_url, help=f'ES endpoint. Default: {default_url}')\n    default_size = 20\n    parser.add_argument('--size', type=int, default=default_size, help=f'Number of records to pull. Default: {default_size}')\n    default_type = 'Dataset'\n    parser.add_argument('--type', default=default_type, help=f'Entity type to query. Default: {default_type}')\n    args = parser.parse_args()\n    query = {'post_filter': {'term': {'entity_type.keyword': args.type}}, 'size': args.size, '_source': ['metadata.metadata' if args.type == 'Dataset' else 'metadata']}\n    response = requests.post(args.url, json=query)\n    hits = response.json()['hits']['hits']\n    writer = DictWriter(sys.stdout, fieldnames=['uuid', 'assay_type', 'field', 'value'], extrasaction='ignore')\n    writer.writeheader()\n    for hit in hits:\n        uuid = hit['_id']\n        if 'metadata' not in hit['_source']:\n            continue\n        meta = hit['_source']['metadata']\n        if 'metadata' in meta:\n            meta = meta['metadata']\n        _iter60 = meta.items()\n        while True:\n            try:\n                field, value = next(_iter60)\n            except StopIteration:\n                break\n            if not re.search('[A-Za-z]', value):\n                continue\n            writer.writerow({'uuid': uuid, 'assay_type': meta['assay_type'] if 'assay_type' in meta else 'Sample', 'field': field, 'value': value})\n    assert len(hits) < args.size, f'Result truncated at {args.size}'\n    return 0", "fn_id": 0, "class_fn": false, "repo": "lukasz-migas/ingest-validation-tools", "file": "src/generate_field_values_csv.py", "last_update_at": "2021-03-17T20:48:41+00:00", "original_content": "def main():\n    parser = argparse.ArgumentParser()\n    default_url = 'https://search.api.hubmapconsortium.org/portal/search'\n    parser.add_argument('--url', default=default_url, help=f'ES endpoint. Default: {default_url}')\n    default_size = 20\n    parser.add_argument('--size', type=int, default=default_size, help=f'Number of records to pull. Default: {default_size}')\n    default_type = 'Dataset'\n    parser.add_argument('--type', default=default_type, help=f'Entity type to query. Default: {default_type}')\n    args = parser.parse_args()\n    query = {'post_filter': {'term': {'entity_type.keyword': args.type}}, 'size': args.size, '_source': ['metadata.metadata' if args.type == 'Dataset' else 'metadata']}\n    response = requests.post(args.url, json=query)\n    hits = response.json()['hits']['hits']\n    writer = DictWriter(sys.stdout, fieldnames=['uuid', 'assay_type', 'field', 'value'], extrasaction='ignore')\n    writer.writeheader()\n    for hit in hits:\n        uuid = hit['_id']\n        if 'metadata' not in hit['_source']:\n            continue\n        meta = hit['_source']['metadata']\n        if 'metadata' in meta:\n            meta = meta['metadata']\n        for field, value in meta.items():\n            if not re.search('[A-Za-z]', value):\n                continue\n            writer.writerow({'uuid': uuid, 'assay_type': meta['assay_type'] if 'assay_type' in meta else 'Sample', 'field': field, 'value': value})\n    assert len(hits) < args.size, f'Result truncated at {args.size}'\n    return 0", "refactored": true, "question_id": "bc9cb89c9de7c8845a3f7858c2bf081cca88afc4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def main():\n    parser = argparse.ArgumentParser()\n    default_url = 'https://search.api.hubmapconsortium.org/portal/search'\n    parser.add_argument('--url', default=default_url, help=f'ES endpoint. Default: {default_url}')\n    default_size = 20\n    parser.add_argument('--size', type=int, default=default_size, help=f'Number of records to pull. Default: {default_size}')\n    default_type = 'Dataset'\n    parser.add_argument('--type', default=default_type, help=f'Entity type to query. Default: {default_type}')\n    args = parser.parse_args()\n    query = {'post_filter': {'term': {'entity_type.keyword': args.type}}, 'size': args.size, '_source': ['metadata.metadata' if args.type == 'Dataset' else 'metadata']}\n    response = requests.post(args.url, json=query)\n    hits = response.json()['hits']['hits']\n    writer = DictWriter(sys.stdout, fieldnames=['uuid', 'assay_type', 'field', 'value'], extrasaction='ignore')\n    writer.writeheader()\n    for hit in hits:\n        uuid = hit['_id']\n        if 'metadata' not in hit['_source']:\n            continue\n        meta = hit['_source']['metadata']\n        if 'metadata' in meta:\n            meta = meta['metadata']\n        _iter60 = meta.items()\n        while True:\n            try:\n                field, value = next(_iter60)\n            except StopIteration:\n                break\n            if not re.search('[A-Za-z]', value):\n                continue\n            writer.writerow({'uuid': uuid, 'assay_type': meta['assay_type'] if 'assay_type' in meta else 'Sample', 'field': field, 'value': value})\n    assert len(hits) < args.size, f'Result truncated at {args.size}'\n"]]}
{"hexsha": "c039023785903aca6301e71b8b73beaa059d6ec4", "ext": "py", "lang": "Python", "content": "def duplicateGroup(id):\n    group = CreatureGroup.objects.get(id=id)\n    newGroup = CreatureGroup(name='%s_duplicate' % group.name, Augmented=group.Augmented)\n    newGroup.Grouping = group.Grouping\n    newGroup.save()\n    _iter61 = group.AllowedExtraType.all()\n    while True:\n        try:\n            item = next(_iter61)\n        except StopIteration:\n            break\n        newGroup.AllowedExtraType.add(item)\n    for item in group.DefaultExtraType.all():\n        newGroup.DefaultExtraType.add(item)\n    for item in group.groupentry_set.all():\n        GroupEntry(Group=newGroup, creature=item.creature).save()", "fn_id": 1, "class_fn": false, "repo": "mkarasch/pfss", "file": "pfss/models.py", "last_update_at": "2021-09-14T09:55:03+00:00", "original_content": "def duplicateGroup(id):\n    group = CreatureGroup.objects.get(id=id)\n    newGroup = CreatureGroup(name='%s_duplicate' % group.name, Augmented=group.Augmented)\n    newGroup.Grouping = group.Grouping\n    newGroup.save()\n    for item in group.AllowedExtraType.all():\n        newGroup.AllowedExtraType.add(item)\n    for item in group.DefaultExtraType.all():\n        newGroup.DefaultExtraType.add(item)\n    for item in group.groupentry_set.all():\n        GroupEntry(Group=newGroup, creature=item.creature).save()", "refactored": true, "question_id": "c039023785903aca6301e71b8b73beaa059d6ec4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def duplicateGroup(id):\n    group = CreatureGroup.objects.get(id=id)\n    newGroup = CreatureGroup(name='%s_duplicate' % group.name, Augmented=group.Augmented)\n    newGroup.Grouping = group.Grouping\n    newGroup.save()\n    _iter61 = group.AllowedExtraType.all()\n    while True:\n        try:\n            item = next(_iter61)\n        except StopIteration:\n            break\n        newGroup.AllowedExtraType.add(item)\n    for item in group.DefaultExtraType.all():\n        newGroup.DefaultExtraType.add(item)\n    for item in group.groupentry_set.all():\n"]]}
{"hexsha": "7d9f104ac0e3008ea503327f64672715cc84a452", "ext": "py", "lang": "Python", "content": "def encode_routing_info(r_tags):\n    result = bitstring.BitArray()\n    for route in r_tags:\n        result.append(bitstring.pack('uint:8', len(route)))\n        _iter62 = route\n        while True:\n            try:\n                step = next(_iter62)\n            except StopIteration:\n                break\n            pubkey, channel, feebase, feerate, cltv = step\n            result.append(bitstring.BitArray(pubkey) + bitstring.BitArray(channel) + bitstring.pack('intbe:32', feebase) + bitstring.pack('intbe:32', feerate) + bitstring.pack('intbe:16', cltv))\n    return result.tobytes()", "fn_id": 0, "class_fn": false, "repo": "RonSherfey/electrum", "file": "electrum/trampoline.py", "last_update_at": "2021-04-22T07:51:24+00:00", "original_content": "def encode_routing_info(r_tags):\n    result = bitstring.BitArray()\n    for route in r_tags:\n        result.append(bitstring.pack('uint:8', len(route)))\n        for step in route:\n            pubkey, channel, feebase, feerate, cltv = step\n            result.append(bitstring.BitArray(pubkey) + bitstring.BitArray(channel) + bitstring.pack('intbe:32', feebase) + bitstring.pack('intbe:32', feerate) + bitstring.pack('intbe:16', cltv))\n    return result.tobytes()", "refactored": true, "question_id": "7d9f104ac0e3008ea503327f64672715cc84a452_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def encode_routing_info(r_tags):\n    result = bitstring.BitArray()\n    for route in r_tags:\n        result.append(bitstring.pack('uint:8', len(route)))\n        _iter62 = route\n        while True:\n            try:\n                step = next(_iter62)\n            except StopIteration:\n                break\n            pubkey, channel, feebase, feerate, cltv = step\n            result.append(bitstring.BitArray(pubkey) + bitstring.BitArray(channel) + bitstring.pack('intbe:32', feebase) + bitstring.pack('intbe:32', feerate) + bitstring.pack('intbe:16', cltv))\n"]]}
{"hexsha": "67782e299b60e3d6714308f0cda66ce9bb82d1a5", "ext": "py", "lang": "Python", "content": "def get_depths(flows, x, h, roughness=0.01, slope=0.001, conv=1.0, dd=0.0001, verbose=False):\n    if isinstance(flows, float):\n        flows = np.array([flows], dtype=float)\n    if isinstance(roughness, float):\n        roughness = np.ones(x.shape, dtype=float) * roughness\n    depths = np.zeros(flows.shape, dtype=float)\n    _iter63 = enumerate(flows)\n    while True:\n        try:\n            idx, q = next(_iter63)\n        except StopIteration:\n            break\n        depths[idx] = qtodepth(x, h, q, roughness=roughness, slope=slope, conv=conv, dd=dd, verbose=False)\n    return depths", "fn_id": 7, "class_fn": false, "repo": "scharlton2/modflow6", "file": "autotest/scripts/cross_section_functions.py", "last_update_at": "2021-10-08T00:56:20+00:00", "original_content": "def get_depths(flows, x, h, roughness=0.01, slope=0.001, conv=1.0, dd=0.0001, verbose=False):\n    if isinstance(flows, float):\n        flows = np.array([flows], dtype=float)\n    if isinstance(roughness, float):\n        roughness = np.ones(x.shape, dtype=float) * roughness\n    depths = np.zeros(flows.shape, dtype=float)\n    for idx, q in enumerate(flows):\n        depths[idx] = qtodepth(x, h, q, roughness=roughness, slope=slope, conv=conv, dd=dd, verbose=False)\n    return depths", "refactored": true, "question_id": "67782e299b60e3d6714308f0cda66ce9bb82d1a5_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_depths(flows, x, h, roughness=0.01, slope=0.001, conv=1.0, dd=0.0001, verbose=False):\n    if isinstance(flows, float):\n        flows = np.array([flows], dtype=float)\n    if isinstance(roughness, float):\n        roughness = np.ones(x.shape, dtype=float) * roughness\n    depths = np.zeros(flows.shape, dtype=float)\n    _iter63 = enumerate(flows)\n    while True:\n        try:\n            idx, q = next(_iter63)\n        except StopIteration:\n            break\n        depths[idx] = qtodepth(x, h, q, roughness=roughness, slope=slope, conv=conv, dd=dd, verbose=False)\n"]]}
{"hexsha": "bc9332449ba47eee635aabdc3d23964f3b29f165", "ext": "py", "lang": "Python", "content": "def get_ratings(path, users_file_name, books_file_name):\n    df_users = pd.read_csv(path + users_file_name, encoding='UTF8')\n    df_books = pd.read_csv(path + books_file_name, encoding='UTF8')\n    df_users_books = pd.DataFrame(df_users, columns=['user_id', 'like'])\n    sr_users = []\n    sr_books = []\n    sr_ratings = []\n    str_like = list(np.array(df_users_books['like'].tolist()))\n    list_like = []\n    for i in str_like:\n        i = i.lstrip('[').rstrip(']')\n        i = i.split(', ')\n        list_like.append(i)\n    for user_idx in df_users_books['user_id']:\n        for book_idx in list_like[user_idx]:\n            if book_idx == '':\n                break\n            sr_users.append(user_idx)\n            sr_books.append(book_idx)\n            sr_ratings.append(1)\n    _iter64 = range(len(df_books))\n    while True:\n        try:\n            book_idx = next(_iter64)\n        except StopIteration:\n            break\n        if sr_users[0]:\n            sr_users.append(sr_users[0])\n        if sr_books[0]:\n            sr_books.append(book_idx)\n        if sr_ratings[0]:\n            sr_ratings.append(0)\n    R = pd.DataFrame({'user_idx': sr_users, 'book_idx': sr_books, 'ratings': sr_ratings})\n    R = R.pivot_table('ratings', index='user_idx', columns='book_idx').fillna(0)\n    R.rename(columns=lambda x: int(x), inplace=True)\n    R = R.sort_index(axis=1)\n    return R", "fn_id": 0, "class_fn": false, "repo": "osamhack2021/AI_APP_handylib_devlib", "file": "AI/recommendation/ALS.py", "last_update_at": "2021-12-16T10:41:16+00:00", "original_content": "def get_ratings(path, users_file_name, books_file_name):\n    df_users = pd.read_csv(path + users_file_name, encoding='UTF8')\n    df_books = pd.read_csv(path + books_file_name, encoding='UTF8')\n    df_users_books = pd.DataFrame(df_users, columns=['user_id', 'like'])\n    sr_users = []\n    sr_books = []\n    sr_ratings = []\n    str_like = list(np.array(df_users_books['like'].tolist()))\n    list_like = []\n    for i in str_like:\n        i = i.lstrip('[').rstrip(']')\n        i = i.split(', ')\n        list_like.append(i)\n    for user_idx in df_users_books['user_id']:\n        for book_idx in list_like[user_idx]:\n            if book_idx == '':\n                break\n            sr_users.append(user_idx)\n            sr_books.append(book_idx)\n            sr_ratings.append(1)\n    for book_idx in range(len(df_books)):\n        if sr_users[0]:\n            sr_users.append(sr_users[0])\n        if sr_books[0]:\n            sr_books.append(book_idx)\n        if sr_ratings[0]:\n            sr_ratings.append(0)\n    R = pd.DataFrame({'user_idx': sr_users, 'book_idx': sr_books, 'ratings': sr_ratings})\n    R = R.pivot_table('ratings', index='user_idx', columns='book_idx').fillna(0)\n    R.rename(columns=lambda x: int(x), inplace=True)\n    R = R.sort_index(axis=1)\n    return R", "refactored": true, "question_id": "bc9332449ba47eee635aabdc3d23964f3b29f165_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_ratings(path, users_file_name, books_file_name):\n    df_users = pd.read_csv(path + users_file_name, encoding='UTF8')\n    df_books = pd.read_csv(path + books_file_name, encoding='UTF8')\n    df_users_books = pd.DataFrame(df_users, columns=['user_id', 'like'])\n    sr_users = []\n    sr_books = []\n    sr_ratings = []\n    str_like = list(np.array(df_users_books['like'].tolist()))\n    list_like = []\n    for i in str_like:\n        i = i.lstrip('[').rstrip(']')\n        i = i.split(', ')\n        list_like.append(i)\n    for user_idx in df_users_books['user_id']:\n        for book_idx in list_like[user_idx]:\n            if book_idx == '':\n                break\n            sr_users.append(user_idx)\n            sr_books.append(book_idx)\n            sr_ratings.append(1)\n    _iter64 = range(len(df_books))\n    while True:\n        try:\n            book_idx = next(_iter64)\n        except StopIteration:\n            break\n        if sr_users[0]:\n            sr_users.append(sr_users[0])\n        if sr_books[0]:\n            sr_books.append(book_idx)\n        if sr_ratings[0]:\n            sr_ratings.append(0)\n    R = pd.DataFrame({'user_idx': sr_users, 'book_idx': sr_books, 'ratings': sr_ratings})\n    R = R.pivot_table('ratings', index='user_idx', columns='book_idx').fillna(0)\n    R.rename(columns=lambda x: int(x), inplace=True)\n    R = R.sort_index(axis=1)\n"]]}
{"hexsha": "2b63ae4e99c2f9a3f9a1f7f166698e9931cfc29c", "ext": "py", "lang": "Python", "content": "def get_roc_data(df_test, df_prob, encoding):\n    tprs = []\n    aucs = []\n    mean_fpr = np.linspace(0, 1, 100)\n    _iter65 = range(df_test.shape[0])\n    while True:\n        try:\n            i = next(_iter65)\n        except StopIteration:\n            break\n        y_true = df_test.iloc[i, :].dropna().values\n        y_pred = df_prob.iloc[i, :].dropna().values\n        fpr, tpr, _ = roc_curve(y_true, y_pred)\n        interp_tpr = np.interp(mean_fpr, fpr, tpr)\n        interp_tpr[0] = 0.0\n        tprs.append(interp_tpr)\n        aucs.append(roc_auc_score(y_true, y_pred))\n    mean_tpr = np.mean(tprs, axis=0)\n    mean_tpr[-1] = 1.0\n    mean_auc = auc(mean_fpr, mean_tpr)\n    std_auc = np.std(aucs)\n    std_tpr = np.std(tprs, axis=0)\n    tprs_upper = np.minimum(mean_tpr + std_tpr, 1)\n    tprs_lower = np.maximum(mean_tpr - std_tpr, 0)\n    df = pd.DataFrame({'x': mean_fpr, 'y': mean_tpr, 'tprs_lower': tprs_lower, 'tprs_upper': tprs_upper})\n    df['Encoding'] = encoding\n    df['mean_auc'] = np.round(mean_auc, 2)\n    df['legend_label'] = df.apply(lambda row: f\"{row['Encoding']} (AUC: {row['mean_auc']})\", axis=1)\n    return df", "fn_id": 1, "class_fn": false, "repo": "spaenigs/peptidereactor", "file": "nodes/vis/sds_3_Curves/scripts/roc_pr_curve.py", "last_update_at": "2021-06-07T07:03:38+00:00", "original_content": "def get_roc_data(df_test, df_prob, encoding):\n    tprs = []\n    aucs = []\n    mean_fpr = np.linspace(0, 1, 100)\n    for i in range(df_test.shape[0]):\n        y_true = df_test.iloc[i, :].dropna().values\n        y_pred = df_prob.iloc[i, :].dropna().values\n        fpr, tpr, _ = roc_curve(y_true, y_pred)\n        interp_tpr = np.interp(mean_fpr, fpr, tpr)\n        interp_tpr[0] = 0.0\n        tprs.append(interp_tpr)\n        aucs.append(roc_auc_score(y_true, y_pred))\n    mean_tpr = np.mean(tprs, axis=0)\n    mean_tpr[-1] = 1.0\n    mean_auc = auc(mean_fpr, mean_tpr)\n    std_auc = np.std(aucs)\n    std_tpr = np.std(tprs, axis=0)\n    tprs_upper = np.minimum(mean_tpr + std_tpr, 1)\n    tprs_lower = np.maximum(mean_tpr - std_tpr, 0)\n    df = pd.DataFrame({'x': mean_fpr, 'y': mean_tpr, 'tprs_lower': tprs_lower, 'tprs_upper': tprs_upper})\n    df['Encoding'] = encoding\n    df['mean_auc'] = np.round(mean_auc, 2)\n    df['legend_label'] = df.apply(lambda row: f\"{row['Encoding']} (AUC: {row['mean_auc']})\", axis=1)\n    return df", "refactored": true, "question_id": "2b63ae4e99c2f9a3f9a1f7f166698e9931cfc29c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_roc_data(df_test, df_prob, encoding):\n    tprs = []\n    aucs = []\n    mean_fpr = np.linspace(0, 1, 100)\n    _iter65 = range(df_test.shape[0])\n    while True:\n        try:\n            i = next(_iter65)\n        except StopIteration:\n            break\n        y_true = df_test.iloc[i, :].dropna().values\n        y_pred = df_prob.iloc[i, :].dropna().values\n        fpr, tpr, _ = roc_curve(y_true, y_pred)\n        interp_tpr = np.interp(mean_fpr, fpr, tpr)\n        interp_tpr[0] = 0.0\n        tprs.append(interp_tpr)\n        aucs.append(roc_auc_score(y_true, y_pred))\n    mean_tpr = np.mean(tprs, axis=0)\n    mean_tpr[-1] = 1.0\n    mean_auc = auc(mean_fpr, mean_tpr)\n    std_auc = np.std(aucs)\n    std_tpr = np.std(tprs, axis=0)\n    tprs_upper = np.minimum(mean_tpr + std_tpr, 1)\n    tprs_lower = np.maximum(mean_tpr - std_tpr, 0)\n    df = pd.DataFrame({'x': mean_fpr, 'y': mean_tpr, 'tprs_lower': tprs_lower, 'tprs_upper': tprs_upper})\n    df['Encoding'] = encoding\n    df['mean_auc'] = np.round(mean_auc, 2)\n    df['legend_label'] = df.apply(lambda row: f\"{row['Encoding']} (AUC: {row['mean_auc']})\", axis=1)\n"]]}
{"hexsha": "58199be75c2f936778ed896013450ada42119647", "ext": "py", "lang": "Python", "content": "def _setup(dataset_dir, label_types=None, classes=None, attrs=None, seed=None, download=False):\n    did_download = False\n    _label_types = _parse_label_types(label_types)\n    if etau.is_str(classes):\n        classes = [classes]\n    if etau.is_str(attrs):\n        attrs = [attrs]\n    if seed is not None:\n        random.seed(seed)\n    classes_map, _did_download = _get_classes_map(dataset_dir, download=download)\n    classes_map_rev = {v: k for k, v in classes_map.items()}\n    did_download |= _did_download\n    all_classes = sorted(classes_map.values())\n    if classes is not None:\n        oi_classes = []\n        missing_classes = []\n        filtered_classes = []\n        _iter66 = classes\n        while True:\n            try:\n                c = next(_iter66)\n            except StopIteration:\n                break\n            if c in classes_map_rev:\n                oi_classes.append(classes_map_rev[c])\n                filtered_classes.append(c)\n            else:\n                missing_classes.append(c)\n        classes = filtered_classes\n        if missing_classes:\n            logger.warning('Ignoring invalid classes %s\\nYou can view the available classes via `fiftyone.utils.openimages.get_classes()`', missing_classes)\n    else:\n        oi_classes = None\n    if 'relationships' in _label_types:\n        attrs_map, _did_download = _get_attrs_map(dataset_dir, download=download)\n        attrs_map_rev = {v: k for k, v in attrs_map.items()}\n        did_download |= _did_download\n        all_attrs = sorted(attrs_map.values())\n        if attrs is None:\n            oi_attrs = [attrs_map_rev[a] for a in all_attrs]\n        else:\n            oi_attrs = []\n            missing_attrs = []\n            filtered_attrs = []\n            for a in attrs:\n                if a in attrs_map_rev:\n                    oi_attrs.append(attrs_map_rev[a])\n                    filtered_attrs.append(a)\n                else:\n                    missing_attrs.append(a)\n            attrs = filtered_attrs\n            if missing_attrs:\n                logger.warning('Ignoring invalid attributes %s\\nYou can view the available attributes via `fiftyone.utils.openimages.get_attributes()`', missing_attrs)\n    else:\n        attrs = None\n        attrs_map = None\n        oi_attrs = None\n        all_attrs = None\n    if 'segmentations' in _label_types:\n        seg_classes, _did_download = _get_seg_classes(dataset_dir, classes_map=classes_map, download=download)\n        did_download |= _did_download\n    else:\n        seg_classes = None\n    return (classes_map, all_classes, classes, oi_classes, attrs_map, all_attrs, attrs, oi_attrs, seg_classes, did_download)", "fn_id": 4, "class_fn": false, "repo": "Fariborzzz/fiftyone", "file": "fiftyone/utils/openimages.py", "last_update_at": "2021-12-17T10:11:37+00:00", "original_content": "def _setup(dataset_dir, label_types=None, classes=None, attrs=None, seed=None, download=False):\n    did_download = False\n    _label_types = _parse_label_types(label_types)\n    if etau.is_str(classes):\n        classes = [classes]\n    if etau.is_str(attrs):\n        attrs = [attrs]\n    if seed is not None:\n        random.seed(seed)\n    classes_map, _did_download = _get_classes_map(dataset_dir, download=download)\n    classes_map_rev = {v: k for k, v in classes_map.items()}\n    did_download |= _did_download\n    all_classes = sorted(classes_map.values())\n    if classes is not None:\n        oi_classes = []\n        missing_classes = []\n        filtered_classes = []\n        for c in classes:\n            if c in classes_map_rev:\n                oi_classes.append(classes_map_rev[c])\n                filtered_classes.append(c)\n            else:\n                missing_classes.append(c)\n        classes = filtered_classes\n        if missing_classes:\n            logger.warning('Ignoring invalid classes %s\\nYou can view the available classes via `fiftyone.utils.openimages.get_classes()`', missing_classes)\n    else:\n        oi_classes = None\n    if 'relationships' in _label_types:\n        attrs_map, _did_download = _get_attrs_map(dataset_dir, download=download)\n        attrs_map_rev = {v: k for k, v in attrs_map.items()}\n        did_download |= _did_download\n        all_attrs = sorted(attrs_map.values())\n        if attrs is None:\n            oi_attrs = [attrs_map_rev[a] for a in all_attrs]\n        else:\n            oi_attrs = []\n            missing_attrs = []\n            filtered_attrs = []\n            for a in attrs:\n                if a in attrs_map_rev:\n                    oi_attrs.append(attrs_map_rev[a])\n                    filtered_attrs.append(a)\n                else:\n                    missing_attrs.append(a)\n            attrs = filtered_attrs\n            if missing_attrs:\n                logger.warning('Ignoring invalid attributes %s\\nYou can view the available attributes via `fiftyone.utils.openimages.get_attributes()`', missing_attrs)\n    else:\n        attrs = None\n        attrs_map = None\n        oi_attrs = None\n        all_attrs = None\n    if 'segmentations' in _label_types:\n        seg_classes, _did_download = _get_seg_classes(dataset_dir, classes_map=classes_map, download=download)\n        did_download |= _did_download\n    else:\n        seg_classes = None\n    return (classes_map, all_classes, classes, oi_classes, attrs_map, all_attrs, attrs, oi_attrs, seg_classes, did_download)", "refactored": true, "question_id": "58199be75c2f936778ed896013450ada42119647_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _setup(dataset_dir, label_types=None, classes=None, attrs=None, seed=None, download=False):\n    did_download = False\n    _label_types = _parse_label_types(label_types)\n    if etau.is_str(classes):\n        classes = [classes]\n    if etau.is_str(attrs):\n        attrs = [attrs]\n    if seed is not None:\n        random.seed(seed)\n    classes_map, _did_download = _get_classes_map(dataset_dir, download=download)\n    classes_map_rev = {v: k for k, v in classes_map.items()}\n    did_download |= _did_download\n    all_classes = sorted(classes_map.values())\n    if classes is not None:\n        oi_classes = []\n        missing_classes = []\n        filtered_classes = []\n        _iter66 = classes\n        while True:\n            try:\n                c = next(_iter66)\n            except StopIteration:\n                break\n            if c in classes_map_rev:\n                oi_classes.append(classes_map_rev[c])\n                filtered_classes.append(c)\n            else:\n                missing_classes.append(c)\n        classes = filtered_classes\n        if missing_classes:\n            logger.warning('Ignoring invalid classes %s\\nYou can view the available classes via `fiftyone.utils.openimages.get_classes()`', missing_classes)\n    else:\n        oi_classes = None\n    if 'relationships' in _label_types:\n        attrs_map, _did_download = _get_attrs_map(dataset_dir, download=download)\n        attrs_map_rev = {v: k for k, v in attrs_map.items()}\n        did_download |= _did_download\n        all_attrs = sorted(attrs_map.values())\n        if attrs is None:\n            oi_attrs = [attrs_map_rev[a] for a in all_attrs]\n        else:\n            oi_attrs = []\n            missing_attrs = []\n            filtered_attrs = []\n            for a in attrs:\n                if a in attrs_map_rev:\n                    oi_attrs.append(attrs_map_rev[a])\n                    filtered_attrs.append(a)\n                else:\n                    missing_attrs.append(a)\n            attrs = filtered_attrs\n            if missing_attrs:\n                logger.warning('Ignoring invalid attributes %s\\nYou can view the available attributes via `fiftyone.utils.openimages.get_attributes()`', missing_attrs)\n    else:\n        attrs = None\n        attrs_map = None\n        oi_attrs = None\n        all_attrs = None\n    if 'segmentations' in _label_types:\n        seg_classes, _did_download = _get_seg_classes(dataset_dir, classes_map=classes_map, download=download)\n        did_download |= _did_download\n    else:\n        seg_classes = None\n"]]}
{"hexsha": "6a6c2ee6803eaaa2206bcf41874368968655c509", "ext": "py", "lang": "Python", "content": "def tsne_plot(model):\n    labels = []\n    tokens = []\n    print('Displaying t-SNE...')\n    for word in model.wv.vocab:\n        tokens.append(model[word])\n        labels.append(word)\n    tsne_model = TSNE(perplexity=40, n_components=2, init='pca', n_iter=2500, random_state=23)\n    new_values = tsne_model.fit_transform(tokens)\n    x = []\n    y = []\n    for value in new_values:\n        x.append(value[0])\n        y.append(value[1])\n    plt.figure(figsize=(16, 16))\n    _iter67 = range(len(x))\n    while True:\n        try:\n            i = next(_iter67)\n        except StopIteration:\n            break\n        plt.scatter(x[i], y[i])\n        plt.annotate(labels[i], xy=(x[i], y[i]), xytext=(5, 2), textcoords='offset points', ha='right', va='bottom')\n    plt.title('t-SNE')\n    plt.show()", "fn_id": 3, "class_fn": false, "repo": "cjbayron/artist2lyrics", "file": "common/utils.py", "last_update_at": "2021-11-08T12:49:36+00:00", "original_content": "def tsne_plot(model):\n    labels = []\n    tokens = []\n    print('Displaying t-SNE...')\n    for word in model.wv.vocab:\n        tokens.append(model[word])\n        labels.append(word)\n    tsne_model = TSNE(perplexity=40, n_components=2, init='pca', n_iter=2500, random_state=23)\n    new_values = tsne_model.fit_transform(tokens)\n    x = []\n    y = []\n    for value in new_values:\n        x.append(value[0])\n        y.append(value[1])\n    plt.figure(figsize=(16, 16))\n    for i in range(len(x)):\n        plt.scatter(x[i], y[i])\n        plt.annotate(labels[i], xy=(x[i], y[i]), xytext=(5, 2), textcoords='offset points', ha='right', va='bottom')\n    plt.title('t-SNE')\n    plt.show()", "refactored": true, "question_id": "6a6c2ee6803eaaa2206bcf41874368968655c509_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def tsne_plot(model):\n    labels = []\n    tokens = []\n    print('Displaying t-SNE...')\n    for word in model.wv.vocab:\n        tokens.append(model[word])\n        labels.append(word)\n    tsne_model = TSNE(perplexity=40, n_components=2, init='pca', n_iter=2500, random_state=23)\n    new_values = tsne_model.fit_transform(tokens)\n    x = []\n    y = []\n    for value in new_values:\n        x.append(value[0])\n        y.append(value[1])\n    plt.figure(figsize=(16, 16))\n    _iter67 = range(len(x))\n    while True:\n        try:\n            i = next(_iter67)\n        except StopIteration:\n            break\n        plt.scatter(x[i], y[i])\n        plt.annotate(labels[i], xy=(x[i], y[i]), xytext=(5, 2), textcoords='offset points', ha='right', va='bottom')\n    plt.title('t-SNE')\n"]]}
{"hexsha": "c908d4e2fcbe9433c55ec3ffa39b22b2f66872dd", "ext": "py", "lang": "Python", "content": "def calc_data_maxima(data, order):\n    \"\"\"Calculate the local maxima using an exclusion of order to avoid multiple close maxima.\n\n    :param data: 3D numpy array (axis 0: time)\n    :param order: number of points to consider for maxima\n    :return: 3D numpy bool array with same shape as data, True if maximum\n    \"\"\"\n    argrelmax = signal.argrelmax(data, order=order, mode='wrap')\n    dmean = data.mean(axis=0)\n    data_maxima = np.zeros(data.shape, dtype=bool)\n    _iter68 = zip(*argrelmax)\n    while True:\n        try:\n            i, j, k = next(_iter68)\n        except StopIteration:\n            break\n        if data[i, j, k] > dmean[j, k]:\n            data_maxima[i, j, k] = True\n    return data_maxima", "fn_id": 0, "class_fn": false, "repo": "markmuetz/cosmic", "file": "cosmic/WP2/multipeak.py", "last_update_at": "2021-01-26T02:25:48+00:00", "original_content": "def calc_data_maxima(data, order):\n    \"\"\"Calculate the local maxima using an exclusion of order to avoid multiple close maxima.\n\n    :param data: 3D numpy array (axis 0: time)\n    :param order: number of points to consider for maxima\n    :return: 3D numpy bool array with same shape as data, True if maximum\n    \"\"\"\n    argrelmax = signal.argrelmax(data, order=order, mode='wrap')\n    dmean = data.mean(axis=0)\n    data_maxima = np.zeros(data.shape, dtype=bool)\n    for i, j, k in zip(*argrelmax):\n        if data[i, j, k] > dmean[j, k]:\n            data_maxima[i, j, k] = True\n    return data_maxima", "refactored": true, "question_id": "c908d4e2fcbe9433c55ec3ffa39b22b2f66872dd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def calc_data_maxima(data, order):\n    \"\"\"Calculate the local maxima using an exclusion of order to avoid multiple close maxima.\n    :param data: 3D numpy array (axis 0: time)\n    :param order: number of points to consider for maxima\n    :return: 3D numpy bool array with same shape as data, True if maximum\n    \"\"\"\n    argrelmax = signal.argrelmax(data, order=order, mode='wrap')\n    dmean = data.mean(axis=0)\n    data_maxima = np.zeros(data.shape, dtype=bool)\n    _iter68 = zip(*argrelmax)\n    while True:\n        try:\n            i, j, k = next(_iter68)\n        except StopIteration:\n            break\n        if data[i, j, k] > dmean[j, k]:\n            data_maxima[i, j, k] = True\n"]]}
{"hexsha": "21093aba0c887e3f2abc8c2d98ef2ec29048b249", "ext": "py", "lang": "Python", "content": "def time_stamps(seconds, sample_rate, sample_length, sample_duration):\n    \"\"\"Process to calculate the intervals based on the window size or time intervals.\n    Parameters\n    ----------\n    seconds : int or list\n        Can be of two types. int; a single value that determines the window size (seconds). list; a set of intervals, where each value is in (seconds).\n    sample_rate : float\n        Sample frequency used in the EEG (Hz).\n    sample_length : float\n        Sample length in data points (seconds x sample frequency).\n    sample_duration : float\n        Duration of the EEG (seconds).\n    \n    Returns\n    -------\n    intervals : list\n        List with the intervals, pairs of (Start, End) values in data points (seconds x sample frequency).\n    \"\"\"\n    intervals, i, flag = ([], 0, 0)\n    if type(seconds) == list:\n        if len(seconds) == 1:\n            seconds = seconds[0]\n        else:\n            if seconds[-1] > sample_duration.round():\n                raise Exception('Error in Window size. Intervals exceeds sample length.')\n            if seconds[0] != 0:\n                raise Exception('Error in Window size. First interval must be 0.')\n            else:\n                diff = np.diff(seconds)\n                for j, value in enumerate(diff):\n                    samples_per_frame = value * sample_rate\n                    intervals.append((i, i + samples_per_frame))\n                    i += samples_per_frame\n    if type(seconds) == int or type(seconds) == float:\n        samples_per_frame = seconds * sample_rate\n        for _ in iter(lambda: 0, 1):\n            if not i + samples_per_frame <= sample_length:\n                break\n            intervals.append((i, i + samples_per_frame))\n            i = i + samples_per_frame\n        if i + samples_per_frame > sample_length:\n            intervals.append((i, sample_length))\n    intervals_rounded = [(round(steps[0], 2), round(steps[1], 2)) for steps in intervals]\n    print('Intervals: ', intervals_rounded)\n    if len(intervals) == 1:\n        intervals.append((0, sample_rate))\n        flag = 1\n    return (intervals, flag)", "fn_id": 5, "class_fn": false, "repo": "danive97/EEGRAPH", "file": "eegraph/tools.py", "last_update_at": "2021-03-26T09:28:21+00:00", "original_content": "def time_stamps(seconds, sample_rate, sample_length, sample_duration):\n    \"\"\"Process to calculate the intervals based on the window size or time intervals.\n    Parameters\n    ----------\n    seconds : int or list\n        Can be of two types. int; a single value that determines the window size (seconds). list; a set of intervals, where each value is in (seconds).\n    sample_rate : float\n        Sample frequency used in the EEG (Hz).\n    sample_length : float\n        Sample length in data points (seconds x sample frequency).\n    sample_duration : float\n        Duration of the EEG (seconds).\n    \n    Returns\n    -------\n    intervals : list\n        List with the intervals, pairs of (Start, End) values in data points (seconds x sample frequency).\n    \"\"\"\n    intervals, i, flag = ([], 0, 0)\n    if type(seconds) == list:\n        if len(seconds) == 1:\n            seconds = seconds[0]\n        else:\n            if seconds[-1] > sample_duration.round():\n                raise Exception('Error in Window size. Intervals exceeds sample length.')\n            if seconds[0] != 0:\n                raise Exception('Error in Window size. First interval must be 0.')\n            else:\n                diff = np.diff(seconds)\n                for j, value in enumerate(diff):\n                    samples_per_frame = value * sample_rate\n                    intervals.append((i, i + samples_per_frame))\n                    i += samples_per_frame\n    if type(seconds) == int or type(seconds) == float:\n        samples_per_frame = seconds * sample_rate\n        while i + samples_per_frame <= sample_length:\n            intervals.append((i, i + samples_per_frame))\n            i = i + samples_per_frame\n        if i + samples_per_frame > sample_length:\n            intervals.append((i, sample_length))\n    intervals_rounded = [(round(steps[0], 2), round(steps[1], 2)) for steps in intervals]\n    print('Intervals: ', intervals_rounded)\n    if len(intervals) == 1:\n        intervals.append((0, sample_rate))\n        flag = 1\n    return (intervals, flag)", "refactored": true, "question_id": "21093aba0c887e3f2abc8c2d98ef2ec29048b249_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def time_stamps(seconds, sample_rate, sample_length, sample_duration):\n    \"\"\"Process to calculate the intervals based on the window size or time intervals.\n    Parameters\n    ----------\n    seconds : int or list\n        Can be of two types. int; a single value that determines the window size (seconds). list; a set of intervals, where each value is in (seconds).\n    sample_rate : float\n        Sample frequency used in the EEG (Hz).\n    sample_length : float\n        Sample length in data points (seconds x sample frequency).\n    sample_duration : float\n        Duration of the EEG (seconds).\n    Returns\n    -------\n    intervals : list\n        List with the intervals, pairs of (Start, End) values in data points (seconds x sample frequency).\n    \"\"\"\n    intervals, i, flag = ([], 0, 0)\n    if type(seconds) == list:\n        if len(seconds) == 1:\n            seconds = seconds[0]\n        else:\n            if seconds[-1] > sample_duration.round():\n                raise Exception('Error in Window size. Intervals exceeds sample length.')\n            if seconds[0] != 0:\n                raise Exception('Error in Window size. First interval must be 0.')\n            else:\n                diff = np.diff(seconds)\n                for j, value in enumerate(diff):\n                    samples_per_frame = value * sample_rate\n                    intervals.append((i, i + samples_per_frame))\n                    i += samples_per_frame\n    if type(seconds) == int or type(seconds) == float:\n        samples_per_frame = seconds * sample_rate\n        for _ in iter(lambda: 0, 1):\n            if not i + samples_per_frame <= sample_length:\n                break\n            intervals.append((i, i + samples_per_frame))\n            i = i + samples_per_frame\n        if i + samples_per_frame > sample_length:\n            intervals.append((i, sample_length))\n    intervals_rounded = [(round(steps[0], 2), round(steps[1], 2)) for steps in intervals]\n    print('Intervals: ', intervals_rounded)\n    if len(intervals) == 1:\n        intervals.append((0, sample_rate))\n        flag = 1\n"]]}
{"hexsha": "511d2698d35dc4f9fe7517171c56725c07784116", "ext": "py", "lang": "Python", "content": "def make_char_dict():\n    chars = string.ascii_lowercase\n    char_dict = {'<blank>': 0}\n    _iter69 = enumerate(chars)\n    while True:\n        try:\n            idx, c = next(_iter69)\n        except StopIteration:\n            break\n        char_dict[c] = idx + 1\n    current_len = len(list(char_dict.keys()))\n    char_dict['<eos>'] = current_len\n    print(char_dict)\n    return char_dict", "fn_id": 0, "class_fn": false, "repo": "duguqiankun/lips_reading", "file": "cnn2d/cnn2d_image_generator.py", "last_update_at": "2021-11-14T13:10:30+00:00", "original_content": "def make_char_dict():\n    chars = string.ascii_lowercase\n    char_dict = {'<blank>': 0}\n    for idx, c in enumerate(chars):\n        char_dict[c] = idx + 1\n    current_len = len(list(char_dict.keys()))\n    char_dict['<eos>'] = current_len\n    print(char_dict)\n    return char_dict", "refactored": true, "question_id": "511d2698d35dc4f9fe7517171c56725c07784116_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def make_char_dict():\n    chars = string.ascii_lowercase\n    char_dict = {'<blank>': 0}\n    _iter69 = enumerate(chars)\n    while True:\n        try:\n            idx, c = next(_iter69)\n        except StopIteration:\n            break\n        char_dict[c] = idx + 1\n    current_len = len(list(char_dict.keys()))\n    char_dict['<eos>'] = current_len\n    print(char_dict)\n"]]}
{"hexsha": "fea44362f63483b4569ec189eda480b3e3b01e26", "ext": "py", "lang": "Python", "content": "def QA_save_tdx_to_mongo(file_dir, client=DATABASE):\n    reader = TdxMinBarReader()\n    __coll = client.stock_min_five\n    for a, v, files in os.walk(file_dir):\n        _iter70 = files\n        while True:\n            try:\n                file = next(_iter70)\n            except StopIteration:\n                break\n            if str(file)[0:2] == 'sh' and int(str(file)[2]) == 6 or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 0) or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 3):\n                QA_util_log_info('Now_saving ' + str(file)[2:8] + \"'s 5 min tick\")\n                fname = file_dir + os.sep + file\n                df = reader.get_df(fname)\n                df['code'] = str(file)[2:8]\n                df['market'] = str(file)[0:2]\n                df['datetime'] = [str(x) for x in list(df.index)]\n                df['date'] = [str(x)[0:10] for x in list(df.index)]\n                df['time_stamp'] = df['datetime'].apply(lambda x: QA_util_time_stamp(x))\n                df['date_stamp'] = df['date'].apply(lambda x: QA_util_date_stamp(x))\n                data_json = json.loads(df.to_json(orient='records'))\n                __coll.insert_many(data_json)", "fn_id": 0, "class_fn": false, "repo": "liujiannong/QUANTAXIS", "file": "QUANTAXIS/QASU/save_tdx_file.py", "last_update_at": "2021-04-01T08:59:46+00:00", "original_content": "def QA_save_tdx_to_mongo(file_dir, client=DATABASE):\n    reader = TdxMinBarReader()\n    __coll = client.stock_min_five\n    for a, v, files in os.walk(file_dir):\n        for file in files:\n            if str(file)[0:2] == 'sh' and int(str(file)[2]) == 6 or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 0) or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 3):\n                QA_util_log_info('Now_saving ' + str(file)[2:8] + \"'s 5 min tick\")\n                fname = file_dir + os.sep + file\n                df = reader.get_df(fname)\n                df['code'] = str(file)[2:8]\n                df['market'] = str(file)[0:2]\n                df['datetime'] = [str(x) for x in list(df.index)]\n                df['date'] = [str(x)[0:10] for x in list(df.index)]\n                df['time_stamp'] = df['datetime'].apply(lambda x: QA_util_time_stamp(x))\n                df['date_stamp'] = df['date'].apply(lambda x: QA_util_date_stamp(x))\n                data_json = json.loads(df.to_json(orient='records'))\n                __coll.insert_many(data_json)", "refactored": true, "question_id": "fea44362f63483b4569ec189eda480b3e3b01e26_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def QA_save_tdx_to_mongo(file_dir, client=DATABASE):\n    reader = TdxMinBarReader()\n    __coll = client.stock_min_five\n    for a, v, files in os.walk(file_dir):\n        _iter70 = files\n        while True:\n            try:\n                file = next(_iter70)\n            except StopIteration:\n                break\n            if str(file)[0:2] == 'sh' and int(str(file)[2]) == 6 or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 0) or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 3):\n                QA_util_log_info('Now_saving ' + str(file)[2:8] + \"'s 5 min tick\")\n                fname = file_dir + os.sep + file\n                df = reader.get_df(fname)\n                df['code'] = str(file)[2:8]\n                df['market'] = str(file)[0:2]\n                df['datetime'] = [str(x) for x in list(df.index)]\n                df['date'] = [str(x)[0:10] for x in list(df.index)]\n                df['time_stamp'] = df['datetime'].apply(lambda x: QA_util_time_stamp(x))\n                df['date_stamp'] = df['date'].apply(lambda x: QA_util_date_stamp(x))\n                data_json = json.loads(df.to_json(orient='records'))\n"]]}
{"hexsha": "7848c02f06f57265c259b7cf28bbf7fbc43f4a4a", "ext": "py", "lang": "Python", "content": "def fecha_caixa():\n    global aberto\n    tot = 0\n    for elemento in transacoes_finalizadas:\n        tot += elemento[1]\n    print(f'TOTAL DE VENDAS R${tot:.2f}')\n    print()\n    for _ in iter(lambda: 0, 1):\n        if not len(transacoes_finalizadas) != 0:\n            break\n        print('ELIMINE AS TRANSA\u00c7\u00d5ES FINALIZADAS:')\n        for i, elemento in enumerate(transacoes_finalizadas):\n            print(f'{i:<1}', end='|    ')\n            print(f'{elemento[0]:<17}', end='|')\n            print(f'{elemento[1]:>5.2f}')\n        try:\n            aux = int(input(''))\n            tot -= transacoes_finalizadas[aux][1]\n            tot = round(tot, 2)\n            transacoes_finalizadas.pop(aux)\n        except ValueError:\n            print('[ERRO]: Digite valores v\u00e1lidos')\n            return fecha_caixa()\n        except IndexError:\n            print(f' Indice <= {len(transacoes_finalizadas)}')\n    print(f'TRANSA\u00c7\u00d5ES ELIMINADAS TOTAL: R${tot}')\n    print('CAIXA FECHADO COM SUCESSO!')\n    aberto = False", "fn_id": 17, "class_fn": false, "repo": "FelipeECarvalho/Projetos", "file": "Sistema Caixa Supermercados/principal.py", "last_update_at": "2021-08-22T17:10:08+00:00", "original_content": "def fecha_caixa():\n    global aberto\n    tot = 0\n    for elemento in transacoes_finalizadas:\n        tot += elemento[1]\n    print(f'TOTAL DE VENDAS R${tot:.2f}')\n    print()\n    while len(transacoes_finalizadas) != 0:\n        print('ELIMINE AS TRANSA\u00c7\u00d5ES FINALIZADAS:')\n        for i, elemento in enumerate(transacoes_finalizadas):\n            print(f'{i:<1}', end='|    ')\n            print(f'{elemento[0]:<17}', end='|')\n            print(f'{elemento[1]:>5.2f}')\n        try:\n            aux = int(input(''))\n            tot -= transacoes_finalizadas[aux][1]\n            tot = round(tot, 2)\n            transacoes_finalizadas.pop(aux)\n        except ValueError:\n            print('[ERRO]: Digite valores v\u00e1lidos')\n            return fecha_caixa()\n        except IndexError:\n            print(f' Indice <= {len(transacoes_finalizadas)}')\n    print(f'TRANSA\u00c7\u00d5ES ELIMINADAS TOTAL: R${tot}')\n    print('CAIXA FECHADO COM SUCESSO!')\n    aberto = False", "refactored": true, "question_id": "7848c02f06f57265c259b7cf28bbf7fbc43f4a4a_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def fecha_caixa():\n    global aberto\n    tot = 0\n    for elemento in transacoes_finalizadas:\n        tot += elemento[1]\n    print(f'TOTAL DE VENDAS R${tot:.2f}')\n    print()\n    for _ in iter(lambda: 0, 1):\n        if not len(transacoes_finalizadas) != 0:\n            break\n        print('ELIMINE AS TRANSA\u00c7\u00d5ES FINALIZADAS:')\n        for i, elemento in enumerate(transacoes_finalizadas):\n            print(f'{i:<1}', end='|    ')\n            print(f'{elemento[0]:<17}', end='|')\n            print(f'{elemento[1]:>5.2f}')\n        try:\n            aux = int(input(''))\n            tot -= transacoes_finalizadas[aux][1]\n            tot = round(tot, 2)\n            transacoes_finalizadas.pop(aux)\n        except ValueError:\n            print('[ERRO]: Digite valores v\u00e1lidos')\n            return fecha_caixa()\n        except IndexError:\n            print(f' Indice <= {len(transacoes_finalizadas)}')\n    print(f'TRANSA\u00c7\u00d5ES ELIMINADAS TOTAL: R${tot}')\n    print('CAIXA FECHADO COM SUCESSO!')\n"]]}
{"hexsha": "d07c3f5d3f8bceba3730181638eb4ed2e60e2c51", "ext": "py", "lang": "Python", "content": "def get_toplevel_elements(str_, element, parsed=None):\n    if parsed is None:\n        parsed = bs4.BeautifulSoup(str_, 'html.parser')\n    skip, result = ([], [])\n    _iter71 = parsed(element)\n    while True:\n        try:\n            l = next(_iter71)\n        except StopIteration:\n            break\n        if str(l) not in skip:\n            result.append(l)\n        skip += [str(l_nested) for l_nested in l(element)]\n    return result", "fn_id": 0, "class_fn": false, "repo": "memri/pyintegrators", "file": "pyintegrators/indexers/notelist/util.py", "last_update_at": "2021-12-06T16:25:13+00:00", "original_content": "def get_toplevel_elements(str_, element, parsed=None):\n    if parsed is None:\n        parsed = bs4.BeautifulSoup(str_, 'html.parser')\n    skip, result = ([], [])\n    for l in parsed(element):\n        if str(l) not in skip:\n            result.append(l)\n        skip += [str(l_nested) for l_nested in l(element)]\n    return result", "refactored": true, "question_id": "d07c3f5d3f8bceba3730181638eb4ed2e60e2c51_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_toplevel_elements(str_, element, parsed=None):\n    if parsed is None:\n        parsed = bs4.BeautifulSoup(str_, 'html.parser')\n    skip, result = ([], [])\n    _iter71 = parsed(element)\n    while True:\n        try:\n            l = next(_iter71)\n        except StopIteration:\n            break\n        if str(l) not in skip:\n            result.append(l)\n        skip += [str(l_nested) for l_nested in l(element)]\n"]]}
{"hexsha": "dbdac17e96cf66994ed82d897eac1d43424c6c6f", "ext": "py", "lang": "Python", "content": "def collect_bstock(pop, sp_idcs, farm_idx):\n    \"\"\"Migrate marked broodstock from source subpopulation\n    to farm subpopulation.\"\"\"\n    _iter72 = sp_idcs\n    while True:\n        try:\n            sp_idx = next(_iter72)\n        except StopIteration:\n            break\n        for ind in pop.individuals([sp_idx]):\n            if ind.broodstock == 1:\n                ind.migrate_to = farm_idx\n            else:\n                ind.migrate_to = sp_idx\n    sim.migrate(pop, mode=sim.BY_IND_INFO)", "fn_id": 12, "class_fn": false, "repo": "nwfsc-cb/shellfish-genetic-risks", "file": "inst/GRs.py", "last_update_at": "2021-09-14T05:30:49+00:00", "original_content": "def collect_bstock(pop, sp_idcs, farm_idx):\n    \"\"\"Migrate marked broodstock from source subpopulation\n    to farm subpopulation.\"\"\"\n    for sp_idx in sp_idcs:\n        for ind in pop.individuals([sp_idx]):\n            if ind.broodstock == 1:\n                ind.migrate_to = farm_idx\n            else:\n                ind.migrate_to = sp_idx\n    sim.migrate(pop, mode=sim.BY_IND_INFO)", "refactored": true, "question_id": "dbdac17e96cf66994ed82d897eac1d43424c6c6f_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def collect_bstock(pop, sp_idcs, farm_idx):\n    \"\"\"Migrate marked broodstock from source subpopulation\n    to farm subpopulation.\"\"\"\n    _iter72 = sp_idcs\n    while True:\n        try:\n            sp_idx = next(_iter72)\n        except StopIteration:\n            break\n        for ind in pop.individuals([sp_idx]):\n            if ind.broodstock == 1:\n                ind.migrate_to = farm_idx\n            else:\n                ind.migrate_to = sp_idx\n"]]}
{"hexsha": "a318f13cb13b18c46060393025e55c03c4986095", "ext": "py", "lang": "Python", "content": "@MSC.route('/candidates')\ndef candidates():\n    text = request.args.get('text', default='', type=str)\n    limit = request.args.get('limit', default=5, type=int)\n    htmlflag = request.args.get('html', default=0, type=int)\n    rval = {}\n    rval['input'] = text\n    runningOffset = 0\n    if text == '':\n        return 'No text received. Usage: url/candidates?html=0&limit=2&text=texttomedicalspellcheck'\n    respJSONstring = corrector.GetALLCandidatesScoredJSON(text)\n    print(respJSONstring)\n    rval = json.loads(respJSONstring)\n    _iter73 = rval['results']\n    while True:\n        try:\n            result = next(_iter73)\n        except StopIteration:\n            break\n        result['candidates'] = result['candidates'][:limit]\n    if 'results' not in rval.keys() or len(rval['results']) == 0:\n        rval['results'] = 'CORRECT'\n    if bool(htmlflag):\n        return json2html.convert(json.dumps(rval)) + '<br><br><br>Try me out: <br><br>' + formcode\n    else:\n        return json.dumps(rval, indent=2)", "fn_id": 2, "class_fn": false, "repo": "jackneil/medSpellCheck", "file": "webserver.py", "last_update_at": "2021-07-07T02:07:24+00:00", "original_content": "@MSC.route('/candidates')\ndef candidates():\n    text = request.args.get('text', default='', type=str)\n    limit = request.args.get('limit', default=5, type=int)\n    htmlflag = request.args.get('html', default=0, type=int)\n    rval = {}\n    rval['input'] = text\n    runningOffset = 0\n    if text == '':\n        return 'No text received. Usage: url/candidates?html=0&limit=2&text=texttomedicalspellcheck'\n    respJSONstring = corrector.GetALLCandidatesScoredJSON(text)\n    print(respJSONstring)\n    rval = json.loads(respJSONstring)\n    for result in rval['results']:\n        result['candidates'] = result['candidates'][:limit]\n    if 'results' not in rval.keys() or len(rval['results']) == 0:\n        rval['results'] = 'CORRECT'\n    if bool(htmlflag):\n        return json2html.convert(json.dumps(rval)) + '<br><br><br>Try me out: <br><br>' + formcode\n    else:\n        return json.dumps(rval, indent=2)", "refactored": true, "question_id": "a318f13cb13b18c46060393025e55c03c4986095_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@MSC.route('/candidates')\ndef candidates():\n    text = request.args.get('text', default='', type=str)\n    limit = request.args.get('limit', default=5, type=int)\n    htmlflag = request.args.get('html', default=0, type=int)\n    rval = {}\n    rval['input'] = text\n    runningOffset = 0\n    if text == '':\n        return 'No text received. Usage: url/candidates?html=0&limit=2&text=texttomedicalspellcheck'\n    respJSONstring = corrector.GetALLCandidatesScoredJSON(text)\n    print(respJSONstring)\n    rval = json.loads(respJSONstring)\n    _iter73 = rval['results']\n    while True:\n        try:\n            result = next(_iter73)\n        except StopIteration:\n            break\n        result['candidates'] = result['candidates'][:limit]\n    if 'results' not in rval.keys() or len(rval['results']) == 0:\n        rval['results'] = 'CORRECT'\n    if bool(htmlflag):\n        return json2html.convert(json.dumps(rval)) + '<br><br><br>Try me out: <br><br>' + formcode\n    else:\n"]]}
{"hexsha": "0460f6e42c23c688c2c6afb0f673aa2cf4d651bf", "ext": "py", "lang": "Python", "content": "def load_state(network, state_dict):\n    net_state_keys = list(network.state_dict().keys())\n    net_state_keys_copy = net_state_keys.copy()\n    sup_string = ''\n    _iter74 = state_dict.keys()\n    while True:\n        try:\n            key = next(_iter74)\n        except StopIteration:\n            break\n        if 'backbone' in key:\n            sup_string = 'backbone.'\n        elif 'module' in key:\n            sup_string = 'module.'\n    for i, _ in enumerate(net_state_keys_copy):\n        name = net_state_keys_copy[i]\n        if name.startswith('classifier') or name.startswith('fc'):\n            continue\n        if not sup_string:\n            name_pretrained = name\n        else:\n            name_pretrained = sup_string + name\n        if name_pretrained in state_dict.keys():\n            dst_param_shape = network.state_dict()[name].shape\n            if state_dict[name_pretrained].shape == dst_param_shape:\n                network.state_dict()[name].copy_(state_dict[name_pretrained].view(dst_param_shape))\n                net_state_keys.remove(name)\n    if net_state_keys:\n        num_batches_list = []\n        for i in range(len(net_state_keys)):\n            if 'num_batches_tracked' in net_state_keys[i]:\n                num_batches_list.append(net_state_keys[i])\n        pruned_additional_states = [x for x in net_state_keys if x not in num_batches_list]\n        if pruned_additional_states:\n            logging.info('There are layers in current network not initialized by pretrained')\n            logging.warning('>> Failed to load: {}'.format(pruned_additional_states))\n        return False\n    return True", "fn_id": 0, "class_fn": false, "repo": "xuyu0010/PATAN", "file": "network/util.py", "last_update_at": "2021-12-27T19:45:45+00:00", "original_content": "def load_state(network, state_dict):\n    net_state_keys = list(network.state_dict().keys())\n    net_state_keys_copy = net_state_keys.copy()\n    sup_string = ''\n    for key in state_dict.keys():\n        if 'backbone' in key:\n            sup_string = 'backbone.'\n        elif 'module' in key:\n            sup_string = 'module.'\n    for i, _ in enumerate(net_state_keys_copy):\n        name = net_state_keys_copy[i]\n        if name.startswith('classifier') or name.startswith('fc'):\n            continue\n        if not sup_string:\n            name_pretrained = name\n        else:\n            name_pretrained = sup_string + name\n        if name_pretrained in state_dict.keys():\n            dst_param_shape = network.state_dict()[name].shape\n            if state_dict[name_pretrained].shape == dst_param_shape:\n                network.state_dict()[name].copy_(state_dict[name_pretrained].view(dst_param_shape))\n                net_state_keys.remove(name)\n    if net_state_keys:\n        num_batches_list = []\n        for i in range(len(net_state_keys)):\n            if 'num_batches_tracked' in net_state_keys[i]:\n                num_batches_list.append(net_state_keys[i])\n        pruned_additional_states = [x for x in net_state_keys if x not in num_batches_list]\n        if pruned_additional_states:\n            logging.info('There are layers in current network not initialized by pretrained')\n            logging.warning('>> Failed to load: {}'.format(pruned_additional_states))\n        return False\n    return True", "refactored": true, "question_id": "0460f6e42c23c688c2c6afb0f673aa2cf4d651bf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def load_state(network, state_dict):\n    net_state_keys = list(network.state_dict().keys())\n    net_state_keys_copy = net_state_keys.copy()\n    sup_string = ''\n    _iter74 = state_dict.keys()\n    while True:\n        try:\n            key = next(_iter74)\n        except StopIteration:\n            break\n        if 'backbone' in key:\n            sup_string = 'backbone.'\n        elif 'module' in key:\n            sup_string = 'module.'\n    for i, _ in enumerate(net_state_keys_copy):\n        name = net_state_keys_copy[i]\n        if name.startswith('classifier') or name.startswith('fc'):\n            continue\n        if not sup_string:\n            name_pretrained = name\n        else:\n            name_pretrained = sup_string + name\n        if name_pretrained in state_dict.keys():\n            dst_param_shape = network.state_dict()[name].shape\n            if state_dict[name_pretrained].shape == dst_param_shape:\n                network.state_dict()[name].copy_(state_dict[name_pretrained].view(dst_param_shape))\n                net_state_keys.remove(name)\n    if net_state_keys:\n        num_batches_list = []\n        for i in range(len(net_state_keys)):\n            if 'num_batches_tracked' in net_state_keys[i]:\n                num_batches_list.append(net_state_keys[i])\n        pruned_additional_states = [x for x in net_state_keys if x not in num_batches_list]\n        if pruned_additional_states:\n            logging.info('There are layers in current network not initialized by pretrained')\n            logging.warning('>> Failed to load: {}'.format(pruned_additional_states))\n        return False\n"]]}
{"hexsha": "075a378bb5687e7c4ee731ece7a5af55df206c93", "ext": "py", "lang": "Python", "content": "def validate(model, dataset, opt, ctx):\n    \"\"\"Test on validation dataset.\"\"\"\n    detector = CenterDetector(opt)\n    detector.model = model\n    results = {}\n    num_iters = len(dataset)\n    bar = Bar('{}'.format(opt.exp_id), max=num_iters)\n    time_stats = ['tot', 'load', 'pre', 'net', 'dec', 'post', 'merge']\n    avg_time_stats = {t: AverageMeter() for t in time_stats}\n    print('Reporting every 1000 images...')\n    _iter75 = range(num_iters)\n    while True:\n        try:\n            ind = next(_iter75)\n        except StopIteration:\n            break\n        img_id = dataset.images[ind]\n        img_info = dataset.coco.loadImgs(ids=[img_id])[0]\n        img_path = os.path.join(dataset.img_dir, img_info['file_name'])\n        ret = detector.run(img_path)\n        results[img_id] = ret['results']\n        Bar.suffix = '[{0}/{1}]|Tot: {total:} |ETA: {eta:} '.format(ind, num_iters, total=bar.elapsed_td, eta=bar.eta_td)\n        for t in avg_time_stats:\n            avg_time_stats[t].update(ret[t])\n            Bar.suffix = Bar.suffix + '|{} {:.3f} '.format(t, avg_time_stats[t].avg)\n        if ind % 1000 == 0:\n            bar.next()\n    bar.finish()\n    val_dataset.run_eval(results=results, save_dir='./output/')", "fn_id": 3, "class_fn": false, "repo": "Guanghan/mxnet-centernet", "file": "train.py", "last_update_at": "2021-05-12T08:41:33+00:00", "original_content": "def validate(model, dataset, opt, ctx):\n    \"\"\"Test on validation dataset.\"\"\"\n    detector = CenterDetector(opt)\n    detector.model = model\n    results = {}\n    num_iters = len(dataset)\n    bar = Bar('{}'.format(opt.exp_id), max=num_iters)\n    time_stats = ['tot', 'load', 'pre', 'net', 'dec', 'post', 'merge']\n    avg_time_stats = {t: AverageMeter() for t in time_stats}\n    print('Reporting every 1000 images...')\n    for ind in range(num_iters):\n        img_id = dataset.images[ind]\n        img_info = dataset.coco.loadImgs(ids=[img_id])[0]\n        img_path = os.path.join(dataset.img_dir, img_info['file_name'])\n        ret = detector.run(img_path)\n        results[img_id] = ret['results']\n        Bar.suffix = '[{0}/{1}]|Tot: {total:} |ETA: {eta:} '.format(ind, num_iters, total=bar.elapsed_td, eta=bar.eta_td)\n        for t in avg_time_stats:\n            avg_time_stats[t].update(ret[t])\n            Bar.suffix = Bar.suffix + '|{} {:.3f} '.format(t, avg_time_stats[t].avg)\n        if ind % 1000 == 0:\n            bar.next()\n    bar.finish()\n    val_dataset.run_eval(results=results, save_dir='./output/')", "refactored": true, "question_id": "075a378bb5687e7c4ee731ece7a5af55df206c93_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def validate(model, dataset, opt, ctx):\n    \"\"\"Test on validation dataset.\"\"\"\n    detector = CenterDetector(opt)\n    detector.model = model\n    results = {}\n    num_iters = len(dataset)\n    bar = Bar('{}'.format(opt.exp_id), max=num_iters)\n    time_stats = ['tot', 'load', 'pre', 'net', 'dec', 'post', 'merge']\n    avg_time_stats = {t: AverageMeter() for t in time_stats}\n    print('Reporting every 1000 images...')\n    _iter75 = range(num_iters)\n    while True:\n        try:\n            ind = next(_iter75)\n        except StopIteration:\n            break\n        img_id = dataset.images[ind]\n        img_info = dataset.coco.loadImgs(ids=[img_id])[0]\n        img_path = os.path.join(dataset.img_dir, img_info['file_name'])\n        ret = detector.run(img_path)\n        results[img_id] = ret['results']\n        Bar.suffix = '[{0}/{1}]|Tot: {total:} |ETA: {eta:} '.format(ind, num_iters, total=bar.elapsed_td, eta=bar.eta_td)\n        for t in avg_time_stats:\n            avg_time_stats[t].update(ret[t])\n            Bar.suffix = Bar.suffix + '|{} {:.3f} '.format(t, avg_time_stats[t].avg)\n        if ind % 1000 == 0:\n            bar.next()\n    bar.finish()\n"]]}
{"hexsha": "12e6a066caf160f30a66f07074f6d4b7810f6f9d", "ext": "py", "lang": "Python", "content": "def motion(pin):\n    print('Bewegung erkannt')\n    with picamera.PiCamera() as camera:\n        _iter76 = camera.capture_continuous('/home/pi/Desktop/Fotos/{timestamp:%d.%m_%H-%M-%S}Uhr.jpg')\n        while True:\n            try:\n                filename = next(_iter76)\n            except StopIteration:\n                break\n            print('Captured %s' % filename)\n            break", "fn_id": 0, "class_fn": false, "repo": "meigrafd/Sample-Code", "file": "PIR_interrupt_pic.py", "last_update_at": "2021-03-31T04:22:25+00:00", "original_content": "def motion(pin):\n    print('Bewegung erkannt')\n    with picamera.PiCamera() as camera:\n        for filename in camera.capture_continuous('/home/pi/Desktop/Fotos/{timestamp:%d.%m_%H-%M-%S}Uhr.jpg'):\n            print('Captured %s' % filename)\n            break", "refactored": true, "question_id": "12e6a066caf160f30a66f07074f6d4b7810f6f9d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def motion(pin):\n    print('Bewegung erkannt')\n    with picamera.PiCamera() as camera:\n        _iter76 = camera.capture_continuous('/home/pi/Desktop/Fotos/{timestamp:%d.%m_%H-%M-%S}Uhr.jpg')\n        while True:\n            try:\n                filename = next(_iter76)\n            except StopIteration:\n                break\n            print('Captured %s' % filename)\n"]]}
{"hexsha": "184edbc2fe82843b354712c8ba7f81417e3fb3d2", "ext": "py", "lang": "Python", "content": "def main(arguments):\n    cap = cv2.VideoCapture(arguments.video)\n    model: tf.keras.Model = tf.keras.models.load_model(arguments.weights_path)\n    model.compile(optimizer='adam', loss=tf.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=['accuracy'])\n    classes = get_classes(os.path.join(arguments.data_path, 'training_set'))\n    success, img = cap.read()\n    for _ in iter(lambda: 0, 1):\n        if not success:\n            break\n        img_pp = preprocess_image(img, INPUT_SHAPE)\n        x = model.predict(np.expand_dims(img_pp, 0), batch_size=1)\n        img_out = write_class_on_img(img_pp, classes[int(np.argmax(np.array(x)))])\n        cv2.imshow('EfficientNet Prediction', img_out)\n        cv2.waitKey(10)\n        success, img = cap.read()", "fn_id": 0, "class_fn": false, "repo": "vincenzosantopietro/Action-Recognition-EfficientNet-TensorFlow", "file": "demo.py", "last_update_at": "2021-08-24T06:48:24+00:00", "original_content": "def main(arguments):\n    cap = cv2.VideoCapture(arguments.video)\n    model: tf.keras.Model = tf.keras.models.load_model(arguments.weights_path)\n    model.compile(optimizer='adam', loss=tf.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=['accuracy'])\n    classes = get_classes(os.path.join(arguments.data_path, 'training_set'))\n    success, img = cap.read()\n    while success:\n        img_pp = preprocess_image(img, INPUT_SHAPE)\n        x = model.predict(np.expand_dims(img_pp, 0), batch_size=1)\n        img_out = write_class_on_img(img_pp, classes[int(np.argmax(np.array(x)))])\n        cv2.imshow('EfficientNet Prediction', img_out)\n        cv2.waitKey(10)\n        success, img = cap.read()", "refactored": true, "question_id": "184edbc2fe82843b354712c8ba7f81417e3fb3d2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def main(arguments):\n    cap = cv2.VideoCapture(arguments.video)\n    model: tf.keras.Model = tf.keras.models.load_model(arguments.weights_path)\n    model.compile(optimizer='adam', loss=tf.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=['accuracy'])\n    classes = get_classes(os.path.join(arguments.data_path, 'training_set'))\n    success, img = cap.read()\n    for _ in iter(lambda: 0, 1):\n        if not success:\n            break\n        img_pp = preprocess_image(img, INPUT_SHAPE)\n        x = model.predict(np.expand_dims(img_pp, 0), batch_size=1)\n        img_out = write_class_on_img(img_pp, classes[int(np.argmax(np.array(x)))])\n        cv2.imshow('EfficientNet Prediction', img_out)\n        cv2.waitKey(10)\n"]]}
{"hexsha": "35f904677ad8fd1f812f7b5f6172973cf62eaed0", "ext": "py", "lang": "Python", "content": "def mixture_fit(x, K=3, x_w=None, n_itr=100, verbose=False, random_state=0, f_write=None, output_folder=None, suffix=None, fold_number=0):\n    \"\"\"Fit a slope+bump mixture using EM algorithm.\n\n    Args:\n        x ((n,d) ndarray): The covaraites.\n        K (int): The number of bump components.\n        x_w ((n,) ndarray): The weights for each sample.\n        n_itr (int): The maximum number of iterations for the EM algorithm\n        verbose (bool): Indicate if output the computation details.\n        random_state (int): The random seed.\n        f_write (file handler (write mode)): The output file.\n        output_folder (string): The output directory.\n        suffix (string): The suffix of the output file.\n        fold_number (int(0,1)): The fold number.\n\n    Returns:\n        a ((d,) ndarray): slope parameter.\n        mu,sigma ((k,d) ndarray): bump parameter.\n        w ((n,) ndarray): proportion of each component. \n    \"\"\"\n    np.random.seed(random_state)\n    if len(x.shape) == 1:\n        x = x.reshape([-1, 1])\n    n_samp, d = x.shape\n    if x_w is None:\n        x_w = np.ones([n_samp], dtype=float)\n    GMM = GaussianMixture(n_components=K, covariance_type='diag').fit(x)\n    w_old = np.zeros([K + 1])\n    w = 0.5 * np.ones([K + 1]) / K\n    w[0] = 0.5\n    a = ML_slope(x, x_w)\n    mu, sigma = (GMM.means_, GMM.covariances_ ** 0.5)\n    w_samp = np.zeros([K + 1, n_samp], dtype=float)\n    i = 0\n    if verbose:\n        if f_write is not None:\n            f_write.write('## mixture_fit: initialization parameters\\n')\n            f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n            for k in range(K):\n                f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n                f_write.write('         mu=%s\\n' % mu[k])\n                f_write.write('      sigma=%s\\n' % sigma[k])\n            f_write.write('\\n')\n    for _ in iter(lambda: 0, 1):\n        if not (np.linalg.norm(w - w_old, 1) > 0.005 and i < n_itr):\n            break\n        w_old = w\n        w_samp[0, :] = w[0] * f_slope(x, a)\n        for k in range(K):\n            w_samp[k + 1, :] = w[k + 1] * f_bump(x, mu[k], sigma[k])\n        w_samp = w_samp / np.sum(w_samp, axis=0) * x_w\n        w = np.mean(w_samp, axis=1)\n        a = ML_slope(x, w_samp[0, :])\n        for k in range(K):\n            if w[k + 1] > 0.0001:\n                mu[k], sigma[k] = ML_bump(x, w_samp[k + 1, :])\n        sigma = sigma.clip(min=0.0001)\n        w[w < 0.001] = 0\n        w /= w.sum()\n        i += 1\n    if i >= n_itr and verbose:\n        print('Warning: the model does not converge, w_dif=%0.4f' % np.linalg.norm(w - w_old, 1))\n        if f_write is not None:\n            f_write.write('Warning: the model does not converge, w_dif=%0.4f\\n' % np.linalg.norm(w - w_old, 1))\n    if verbose and f_write is not None:\n        f_write.write('## mixture_fit: learned parameters\\n')\n        f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n        for k in range(K):\n            f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n            f_write.write('         mu=%s\\n' % mu[k])\n            f_write.write('      sigma=%s\\n' % sigma[k])\n        f_write.write('\\n')\n    if output_folder is not None:\n        bins_ = np.linspace(0, 1, 101)\n        x_grid = bins_.reshape([-1, 1])\n        if d == 1:\n            plt.figure(figsize=[8, 5])\n            plt.hist(x, bins=bins_, weights=x_w / np.sum(x_w) * 100)\n            temp_p = f_all(x_grid, a, mu, sigma, w)\n            plt.plot(bins_, temp_p)\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        else:\n            plt.figure(figsize=[8, 12])\n            n_figure = min(d, 5)\n            for i_dim in range(n_figure):\n                plt.subplot(str(n_figure) + '1' + str(i_dim + 1))\n                plt.hist(x[:, i_dim], bins=bins_, weights=x_w / np.sum(x_w) * 100)\n                temp_p = f_all(x_grid, a[[i_dim]], mu[:, [i_dim]], sigma[:, [i_dim]], w)\n                plt.plot(bins_, temp_p)\n                plt.title('Dimension %d' % (i_dim + 1))\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        plt.close('all')\n    return (a, mu, sigma, w)", "fn_id": 14, "class_fn": false, "repo": "martinjzhang/adafdr", "file": "adafdr/method.py", "last_update_at": "2021-05-21T09:23:58+00:00", "original_content": "def mixture_fit(x, K=3, x_w=None, n_itr=100, verbose=False, random_state=0, f_write=None, output_folder=None, suffix=None, fold_number=0):\n    \"\"\"Fit a slope+bump mixture using EM algorithm.\n\n    Args:\n        x ((n,d) ndarray): The covaraites.\n        K (int): The number of bump components.\n        x_w ((n,) ndarray): The weights for each sample.\n        n_itr (int): The maximum number of iterations for the EM algorithm\n        verbose (bool): Indicate if output the computation details.\n        random_state (int): The random seed.\n        f_write (file handler (write mode)): The output file.\n        output_folder (string): The output directory.\n        suffix (string): The suffix of the output file.\n        fold_number (int(0,1)): The fold number.\n\n    Returns:\n        a ((d,) ndarray): slope parameter.\n        mu,sigma ((k,d) ndarray): bump parameter.\n        w ((n,) ndarray): proportion of each component. \n    \"\"\"\n    np.random.seed(random_state)\n    if len(x.shape) == 1:\n        x = x.reshape([-1, 1])\n    n_samp, d = x.shape\n    if x_w is None:\n        x_w = np.ones([n_samp], dtype=float)\n    GMM = GaussianMixture(n_components=K, covariance_type='diag').fit(x)\n    w_old = np.zeros([K + 1])\n    w = 0.5 * np.ones([K + 1]) / K\n    w[0] = 0.5\n    a = ML_slope(x, x_w)\n    mu, sigma = (GMM.means_, GMM.covariances_ ** 0.5)\n    w_samp = np.zeros([K + 1, n_samp], dtype=float)\n    i = 0\n    if verbose:\n        if f_write is not None:\n            f_write.write('## mixture_fit: initialization parameters\\n')\n            f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n            for k in range(K):\n                f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n                f_write.write('         mu=%s\\n' % mu[k])\n                f_write.write('      sigma=%s\\n' % sigma[k])\n            f_write.write('\\n')\n    while np.linalg.norm(w - w_old, 1) > 0.005 and i < n_itr:\n        w_old = w\n        w_samp[0, :] = w[0] * f_slope(x, a)\n        for k in range(K):\n            w_samp[k + 1, :] = w[k + 1] * f_bump(x, mu[k], sigma[k])\n        w_samp = w_samp / np.sum(w_samp, axis=0) * x_w\n        w = np.mean(w_samp, axis=1)\n        a = ML_slope(x, w_samp[0, :])\n        for k in range(K):\n            if w[k + 1] > 0.0001:\n                mu[k], sigma[k] = ML_bump(x, w_samp[k + 1, :])\n        sigma = sigma.clip(min=0.0001)\n        w[w < 0.001] = 0\n        w /= w.sum()\n        i += 1\n    if i >= n_itr and verbose:\n        print('Warning: the model does not converge, w_dif=%0.4f' % np.linalg.norm(w - w_old, 1))\n        if f_write is not None:\n            f_write.write('Warning: the model does not converge, w_dif=%0.4f\\n' % np.linalg.norm(w - w_old, 1))\n    if verbose and f_write is not None:\n        f_write.write('## mixture_fit: learned parameters\\n')\n        f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n        for k in range(K):\n            f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n            f_write.write('         mu=%s\\n' % mu[k])\n            f_write.write('      sigma=%s\\n' % sigma[k])\n        f_write.write('\\n')\n    if output_folder is not None:\n        bins_ = np.linspace(0, 1, 101)\n        x_grid = bins_.reshape([-1, 1])\n        if d == 1:\n            plt.figure(figsize=[8, 5])\n            plt.hist(x, bins=bins_, weights=x_w / np.sum(x_w) * 100)\n            temp_p = f_all(x_grid, a, mu, sigma, w)\n            plt.plot(bins_, temp_p)\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        else:\n            plt.figure(figsize=[8, 12])\n            n_figure = min(d, 5)\n            for i_dim in range(n_figure):\n                plt.subplot(str(n_figure) + '1' + str(i_dim + 1))\n                plt.hist(x[:, i_dim], bins=bins_, weights=x_w / np.sum(x_w) * 100)\n                temp_p = f_all(x_grid, a[[i_dim]], mu[:, [i_dim]], sigma[:, [i_dim]], w)\n                plt.plot(bins_, temp_p)\n                plt.title('Dimension %d' % (i_dim + 1))\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        plt.close('all')\n    return (a, mu, sigma, w)", "refactored": true, "question_id": "35f904677ad8fd1f812f7b5f6172973cf62eaed0_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def mixture_fit(x, K=3, x_w=None, n_itr=100, verbose=False, random_state=0, f_write=None, output_folder=None, suffix=None, fold_number=0):\n    \"\"\"Fit a slope+bump mixture using EM algorithm.\n    Args:\n        x ((n,d) ndarray): The covaraites.\n        K (int): The number of bump components.\n        x_w ((n,) ndarray): The weights for each sample.\n        n_itr (int): The maximum number of iterations for the EM algorithm\n        verbose (bool): Indicate if output the computation details.\n        random_state (int): The random seed.\n        f_write (file handler (write mode)): The output file.\n        output_folder (string): The output directory.\n        suffix (string): The suffix of the output file.\n        fold_number (int(0,1)): The fold number.\n    Returns:\n        a ((d,) ndarray): slope parameter.\n        mu,sigma ((k,d) ndarray): bump parameter.\n        w ((n,) ndarray): proportion of each component. \n    \"\"\"\n    np.random.seed(random_state)\n    if len(x.shape) == 1:\n        x = x.reshape([-1, 1])\n    n_samp, d = x.shape\n    if x_w is None:\n        x_w = np.ones([n_samp], dtype=float)\n    GMM = GaussianMixture(n_components=K, covariance_type='diag').fit(x)\n    w_old = np.zeros([K + 1])\n    w = 0.5 * np.ones([K + 1]) / K\n    w[0] = 0.5\n    a = ML_slope(x, x_w)\n    mu, sigma = (GMM.means_, GMM.covariances_ ** 0.5)\n    w_samp = np.zeros([K + 1, n_samp], dtype=float)\n    i = 0\n    if verbose:\n        if f_write is not None:\n            f_write.write('## mixture_fit: initialization parameters\\n')\n            f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n            for k in range(K):\n                f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n                f_write.write('         mu=%s\\n' % mu[k])\n                f_write.write('      sigma=%s\\n' % sigma[k])\n            f_write.write('\\n')\n    for _ in iter(lambda: 0, 1):\n        if not (np.linalg.norm(w - w_old, 1) > 0.005 and i < n_itr):\n            break\n        w_old = w\n        w_samp[0, :] = w[0] * f_slope(x, a)\n        for k in range(K):\n            w_samp[k + 1, :] = w[k + 1] * f_bump(x, mu[k], sigma[k])\n        w_samp = w_samp / np.sum(w_samp, axis=0) * x_w\n        w = np.mean(w_samp, axis=1)\n        a = ML_slope(x, w_samp[0, :])\n        for k in range(K):\n            if w[k + 1] > 0.0001:\n                mu[k], sigma[k] = ML_bump(x, w_samp[k + 1, :])\n        sigma = sigma.clip(min=0.0001)\n        w[w < 0.001] = 0\n        w /= w.sum()\n        i += 1\n    if i >= n_itr and verbose:\n        print('Warning: the model does not converge, w_dif=%0.4f' % np.linalg.norm(w - w_old, 1))\n        if f_write is not None:\n            f_write.write('Warning: the model does not converge, w_dif=%0.4f\\n' % np.linalg.norm(w - w_old, 1))\n    if verbose and f_write is not None:\n        f_write.write('## mixture_fit: learned parameters\\n')\n        f_write.write('# Slope: w=%0.4f, a=%s\\n' % (w[0], a))\n        for k in range(K):\n            f_write.write('# Bump %d: w=%0.4f\\n' % (k, w[k + 1]))\n            f_write.write('         mu=%s\\n' % mu[k])\n            f_write.write('      sigma=%s\\n' % sigma[k])\n        f_write.write('\\n')\n    if output_folder is not None:\n        bins_ = np.linspace(0, 1, 101)\n        x_grid = bins_.reshape([-1, 1])\n        if d == 1:\n            plt.figure(figsize=[8, 5])\n            plt.hist(x, bins=bins_, weights=x_w / np.sum(x_w) * 100)\n            temp_p = f_all(x_grid, a, mu, sigma, w)\n            plt.plot(bins_, temp_p)\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        else:\n            plt.figure(figsize=[8, 12])\n            n_figure = min(d, 5)\n            for i_dim in range(n_figure):\n                plt.subplot(str(n_figure) + '1' + str(i_dim + 1))\n                plt.hist(x[:, i_dim], bins=bins_, weights=x_w / np.sum(x_w) * 100)\n                temp_p = f_all(x_grid, a[[i_dim]], mu[:, [i_dim]], sigma[:, [i_dim]], w)\n                plt.plot(bins_, temp_p)\n                plt.title('Dimension %d' % (i_dim + 1))\n            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))\n        plt.close('all')\n"]]}
{"hexsha": "241fb0211e37aae619cf601b0686c40ee27576eb", "ext": "py", "lang": "Python", "content": "def update_doing_card():\n    \"\"\"\n    DOING \uc0c1\ud0dc\uc758 \uce74\ub4dc\uc758 DURATION\uc744 \uc0c8\ub85c \uae30\ub85d\ud569\ub2c8\ub2e4.\n    DURATION\uc758 \uac12\uc774 \uc5c6\uc744 \uacbd\uc6b0\uc5d0\ub294 \uc2dc\uc791\uc77c\uc744 \ub2f9\uc77c\ub85c \uc124\uc815\ud569\ub2c8\ub2e4.\n    \"\"\"\n    status = notion.CARD_STATUS\n    doing = notion.DOING\n    duration = notion.CARD_DURATION\n    today = date.today()\n    _iter77 = notion.get_filtered_card_ids(status, doing)\n    while True:\n        try:\n            card_id = next(_iter77)\n        except StopIteration:\n            break\n        card = notion.client.get_block(card_id)\n        notion_date = card.get_property(duration)\n        if not notion_date or notion_date.start == None:\n            notion_date = NotionDate(start=today)\n        card.set_property(duration, notion_date)", "fn_id": 1, "class_fn": false, "repo": "wormwlrm/notion-scrum-analytics", "file": "commands/run_update_duration.py", "last_update_at": "2021-08-29T03:23:02+00:00", "original_content": "def update_doing_card():\n    \"\"\"\n    DOING \uc0c1\ud0dc\uc758 \uce74\ub4dc\uc758 DURATION\uc744 \uc0c8\ub85c \uae30\ub85d\ud569\ub2c8\ub2e4.\n    DURATION\uc758 \uac12\uc774 \uc5c6\uc744 \uacbd\uc6b0\uc5d0\ub294 \uc2dc\uc791\uc77c\uc744 \ub2f9\uc77c\ub85c \uc124\uc815\ud569\ub2c8\ub2e4.\n    \"\"\"\n    status = notion.CARD_STATUS\n    doing = notion.DOING\n    duration = notion.CARD_DURATION\n    today = date.today()\n    for card_id in notion.get_filtered_card_ids(status, doing):\n        card = notion.client.get_block(card_id)\n        notion_date = card.get_property(duration)\n        if not notion_date or notion_date.start == None:\n            notion_date = NotionDate(start=today)\n        card.set_property(duration, notion_date)", "refactored": true, "question_id": "241fb0211e37aae619cf601b0686c40ee27576eb_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def update_doing_card():\n    \"\"\"\n    DOING \uc0c1\ud0dc\uc758 \uce74\ub4dc\uc758 DURATION\uc744 \uc0c8\ub85c \uae30\ub85d\ud569\ub2c8\ub2e4.\n    DURATION\uc758 \uac12\uc774 \uc5c6\uc744 \uacbd\uc6b0\uc5d0\ub294 \uc2dc\uc791\uc77c\uc744 \ub2f9\uc77c\ub85c \uc124\uc815\ud569\ub2c8\ub2e4.\n    \"\"\"\n    status = notion.CARD_STATUS\n    doing = notion.DOING\n    duration = notion.CARD_DURATION\n    today = date.today()\n    _iter77 = notion.get_filtered_card_ids(status, doing)\n    while True:\n        try:\n            card_id = next(_iter77)\n        except StopIteration:\n            break\n        card = notion.client.get_block(card_id)\n        notion_date = card.get_property(duration)\n        if not notion_date or notion_date.start == None:\n            notion_date = NotionDate(start=today)\n"]]}
{"hexsha": "66c3929472e5beb4f365dc128305de4970e9e7a7", "ext": "py", "lang": "Python", "content": "def extract_sentences_and_labels_from_files(files):\n    sentences = []\n    labels = []\n    for infile in files:\n        with open(infile) as file:\n            _iter78 = file\n            while True:\n                try:\n                    line = next(_iter78)\n                except StopIteration:\n                    break\n                sentence, label = parse_infile_line(line)\n                labels.append(label)\n                sentences.append(sentence)\n            file.close()\n    return (sentences, labels)", "fn_id": 1, "class_fn": false, "repo": "arielrodrigues/nlp-relations-extraction-ptbr", "file": "input-data-preparation/utils.py", "last_update_at": "2021-02-09T16:27:10+00:00", "original_content": "def extract_sentences_and_labels_from_files(files):\n    sentences = []\n    labels = []\n    for infile in files:\n        with open(infile) as file:\n            for line in file:\n                sentence, label = parse_infile_line(line)\n                labels.append(label)\n                sentences.append(sentence)\n            file.close()\n    return (sentences, labels)", "refactored": true, "question_id": "66c3929472e5beb4f365dc128305de4970e9e7a7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def extract_sentences_and_labels_from_files(files):\n    sentences = []\n    labels = []\n    for infile in files:\n        with open(infile) as file:\n            _iter78 = file\n            while True:\n                try:\n                    line = next(_iter78)\n                except StopIteration:\n                    break\n                sentence, label = parse_infile_line(line)\n                labels.append(label)\n                sentences.append(sentence)\n            file.close()\n"]]}
{"hexsha": "e8bc0e0cfb812d7c32521e012f61a1e17efddd71", "ext": "py", "lang": "Python", "content": "def save_mel_dataset(out_path, *paths, in_db=True, root_path=None):\n    \"\"\"\n    \"\"\"\n    ds_len = len(paths)\n    with IncrementalHDF5(out_path, CONF.NUM_MELS, np.float32) as ihdf5:\n        LOGGER.info(f'Writing to {out_path}')\n        _iter79 = enumerate(paths, 1)\n        while True:\n            try:\n                i, abspath = next(_iter79)\n            except StopIteration:\n                break\n            if root_path is not None:\n                metadata_str = str(abspath.relative_to(root_path))\n            else:\n                metadata_str = str(abspath)\n            if i % 100 == 0:\n                LOGGER.info(f'[{i}/{ds_len}] save_mel_dataset: {metadata_str}')\n            arr = wavpath_to_mel(str(abspath), CONF.WAV_SR, wav_norm=CONF.WAV_NORM, n_mels=CONF.NUM_MELS, hop_length=CONF.STFT_HOPSIZE, pad_mode='constant', in_decibels=in_db, logger=LOGGER)\n            if arr is None:\n                continue\n            ihdf5.append(arr, metadata_str)\n            _, arr_w = arr.shape\n            assert (arr == ihdf5.data_ds[:, -arr_w:]).all(), 'Should never happen'\n        LOGGER.info(f'Finished writing to {out_path}')", "fn_id": 1, "class_fn": false, "repo": "andres-fr/dcase2021_umaps", "file": "00c_precompute_fraunhofer_fixed.py", "last_update_at": "2021-11-30T09:28:21+00:00", "original_content": "def save_mel_dataset(out_path, *paths, in_db=True, root_path=None):\n    \"\"\"\n    \"\"\"\n    ds_len = len(paths)\n    with IncrementalHDF5(out_path, CONF.NUM_MELS, np.float32) as ihdf5:\n        LOGGER.info(f'Writing to {out_path}')\n        for i, abspath in enumerate(paths, 1):\n            if root_path is not None:\n                metadata_str = str(abspath.relative_to(root_path))\n            else:\n                metadata_str = str(abspath)\n            if i % 100 == 0:\n                LOGGER.info(f'[{i}/{ds_len}] save_mel_dataset: {metadata_str}')\n            arr = wavpath_to_mel(str(abspath), CONF.WAV_SR, wav_norm=CONF.WAV_NORM, n_mels=CONF.NUM_MELS, hop_length=CONF.STFT_HOPSIZE, pad_mode='constant', in_decibels=in_db, logger=LOGGER)\n            if arr is None:\n                continue\n            ihdf5.append(arr, metadata_str)\n            _, arr_w = arr.shape\n            assert (arr == ihdf5.data_ds[:, -arr_w:]).all(), 'Should never happen'\n        LOGGER.info(f'Finished writing to {out_path}')", "refactored": true, "question_id": "e8bc0e0cfb812d7c32521e012f61a1e17efddd71_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def save_mel_dataset(out_path, *paths, in_db=True, root_path=None):\n    \"\"\"\n    \"\"\"\n    ds_len = len(paths)\n    with IncrementalHDF5(out_path, CONF.NUM_MELS, np.float32) as ihdf5:\n        LOGGER.info(f'Writing to {out_path}')\n        _iter79 = enumerate(paths, 1)\n        while True:\n            try:\n                i, abspath = next(_iter79)\n            except StopIteration:\n                break\n            if root_path is not None:\n                metadata_str = str(abspath.relative_to(root_path))\n            else:\n                metadata_str = str(abspath)\n            if i % 100 == 0:\n                LOGGER.info(f'[{i}/{ds_len}] save_mel_dataset: {metadata_str}')\n            arr = wavpath_to_mel(str(abspath), CONF.WAV_SR, wav_norm=CONF.WAV_NORM, n_mels=CONF.NUM_MELS, hop_length=CONF.STFT_HOPSIZE, pad_mode='constant', in_decibels=in_db, logger=LOGGER)\n            if arr is None:\n                continue\n            ihdf5.append(arr, metadata_str)\n            _, arr_w = arr.shape\n            assert (arr == ihdf5.data_ds[:, -arr_w:]).all(), 'Should never happen'\n"]]}
{"hexsha": "0924022c1119a245a7cbca668d233e67f604810f", "ext": "py", "lang": "Python", "content": "def get_shifted_3D(tau, X, Y, Z, cam_left, cam_top, traj_left, traj_top, timespan):\n    corr_top, corr_left = shift_cam_coord(timespan, traj_top, traj_left, tau)\n    len_traj = len(corr_top)\n    x = np.zeros(np.shape(X)) * np.nan\n    y = np.zeros(np.shape(Y)) * np.nan\n    z = np.zeros(np.shape(Z)) * np.nan\n    _iter80 = range(0, len_traj)\n    while True:\n        try:\n            i = next(_iter80)\n        except StopIteration:\n            break\n        if not (np.isnan(X[i]) or np.isnan(Y[i]) or np.isnan(Z[i])):\n            A, B = make_system_mat(cam_top, cam_left, corr_left[i, :], corr_top[i, :])\n            x[i], y[i], z[i] = np.linalg.solve(np.matrix(A), np.matrix(B).T)\n    return (x, y, z, corr_top, corr_left)", "fn_id": 12, "class_fn": false, "repo": "simonBreumier/3Deye", "file": "data_treat/reconstruction_3d.py", "last_update_at": "2021-06-05T07:51:00+00:00", "original_content": "def get_shifted_3D(tau, X, Y, Z, cam_left, cam_top, traj_left, traj_top, timespan):\n    corr_top, corr_left = shift_cam_coord(timespan, traj_top, traj_left, tau)\n    len_traj = len(corr_top)\n    x = np.zeros(np.shape(X)) * np.nan\n    y = np.zeros(np.shape(Y)) * np.nan\n    z = np.zeros(np.shape(Z)) * np.nan\n    for i in range(0, len_traj):\n        if not (np.isnan(X[i]) or np.isnan(Y[i]) or np.isnan(Z[i])):\n            A, B = make_system_mat(cam_top, cam_left, corr_left[i, :], corr_top[i, :])\n            x[i], y[i], z[i] = np.linalg.solve(np.matrix(A), np.matrix(B).T)\n    return (x, y, z, corr_top, corr_left)", "refactored": true, "question_id": "0924022c1119a245a7cbca668d233e67f604810f_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_shifted_3D(tau, X, Y, Z, cam_left, cam_top, traj_left, traj_top, timespan):\n    corr_top, corr_left = shift_cam_coord(timespan, traj_top, traj_left, tau)\n    len_traj = len(corr_top)\n    x = np.zeros(np.shape(X)) * np.nan\n    y = np.zeros(np.shape(Y)) * np.nan\n    z = np.zeros(np.shape(Z)) * np.nan\n    _iter80 = range(0, len_traj)\n    while True:\n        try:\n            i = next(_iter80)\n        except StopIteration:\n            break\n        if not (np.isnan(X[i]) or np.isnan(Y[i]) or np.isnan(Z[i])):\n            A, B = make_system_mat(cam_top, cam_left, corr_left[i, :], corr_top[i, :])\n            x[i], y[i], z[i] = np.linalg.solve(np.matrix(A), np.matrix(B).T)\n"]]}
{"hexsha": "e7dae2609f1a6ef8908cb001bd4912ee60a48a48", "ext": "py", "lang": "Python", "content": "def construct_tabs(selected_pipeline, window, prefs, include_eeg):\n    \"\"\"Constructs as set of tabs based on specifications and the\n    selected pipeline.\n\n    Parameters\n    ----------\n    selected_pipeline : str\n        ID of the selected pipeline\n    window : instance of main window\n        The main window.\n    prefs : Instance of PreferencesHandler\n        Stores e.g. active plugins.\n    include_eeg : bool\n        Whether to add EEG-related actions\n\n    Returns\n    -------\n    list of QDialog\n        Contains the constructed tabs relevant to the pipeline\n    \"\"\"\n    active_plugins = prefs.active_plugins\n    action_specs = find_all_action_specs()\n    datatype_specs = find_all_datatype_specs()\n    package_specs = find_all_package_specs()\n    tabs = []\n    pipelines = []\n    for source, package_spec in package_specs.items():\n        if source not in active_plugins and source != 'meggie':\n            continue\n        if 'tabs' in package_spec:\n            tabs.extend(package_spec['tabs'])\n        if 'pipelines' in package_spec:\n            pipelines.extend(package_spec['pipelines'])\n    for tab in tabs:\n        if 'id' not in tab:\n            raise Exception('Every tab specification must have id.')\n        if 'name' not in tab:\n            tab['name'] = tab['id']\n        if 'inputs' not in tab:\n            tab['inputs'] = []\n        if 'outputs' not in tab:\n            tab['outputs'] = []\n        if 'input_actions' not in tab:\n            tab['input_actions'] = []\n        if 'output_actions' not in tab:\n            tab['output_actions'] = []\n        if 'info' not in tab:\n            tab['info'] = []\n    for pipeline in pipelines:\n        if 'id' not in pipeline:\n            raise Exception('Every pipeline must have id.')\n        if 'name' not in pipeline:\n            pipeline['name'] = pipeline['id']\n    found = False\n    pipeline_spec = None\n    for pipeline in pipelines:\n        if pipeline['id'] == selected_pipeline:\n            found = True\n            pipeline_spec = pipeline\n            break\n    if not found:\n        pipeline_spec = {'id': 'classic', 'name': 'Include everything'}\n    combined_tabs = []\n    _iter81 = tabs\n    while True:\n        try:\n            tab_spec = next(_iter81)\n        except StopIteration:\n            break\n        if pipeline_spec.get('include_tabs'):\n            if tab_spec['id'] not in pipeline_spec['include_tabs']:\n                continue\n        if tab_spec['id'] not in [tab['id'] for tab in combined_tabs]:\n            new_tab = {}\n            new_tab['id'] = tab_spec['id']\n            new_tab['name'] = tab_spec['name']\n            new_tab['inputs'] = []\n            new_tab['outputs'] = []\n            new_tab['input_actions'] = []\n            new_tab['output_actions'] = []\n            new_tab['info'] = []\n            idx = len(combined_tabs)\n            combined_tabs.append(new_tab)\n        else:\n            idx = [tab['id'] for tab in combined_tabs].index(tab_spec['id'])\n        for input_spec in tab_spec['inputs']:\n            if input_spec not in combined_tabs[idx]['inputs']:\n                combined_tabs[idx]['inputs'].append(input_spec)\n        for output_spec in tab_spec['outputs']:\n            if output_spec not in combined_tabs[idx]['outputs']:\n                combined_tabs[idx]['outputs'].append(output_spec)\n        for input_spec in tab_spec['input_actions']:\n            action_spec = action_specs.get(input_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + input_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if input_spec not in combined_tabs[idx]['input_actions']:\n                combined_tabs[idx]['input_actions'].append(input_spec)\n        for output_spec in tab_spec['output_actions']:\n            action_spec = action_specs.get(output_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + output_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if output_spec not in combined_tabs[idx]['output_actions']:\n                combined_tabs[idx]['output_actions'].append(output_spec)\n        for info_spec in tab_spec['info']:\n            action_spec = action_specs.get(info_spec)\n            if not action_spec:\n                raise Exception('Cannot read info item ' + info_spec + '.')\n            if info_spec not in combined_tabs[idx]['info']:\n                combined_tabs[idx]['info'].append(info_spec)\n    tabs = []\n    for tab_spec in combined_tabs:\n        tabs.append(construct_tab(tab_spec, action_specs, datatype_specs, window))\n    return tabs", "fn_id": 6, "class_fn": false, "repo": "Teekuningas/meggie", "file": "meggie/mainwindow/dynamic.py", "last_update_at": "2021-01-15T21:21:51+00:00", "original_content": "def construct_tabs(selected_pipeline, window, prefs, include_eeg):\n    \"\"\"Constructs as set of tabs based on specifications and the\n    selected pipeline.\n\n    Parameters\n    ----------\n    selected_pipeline : str\n        ID of the selected pipeline\n    window : instance of main window\n        The main window.\n    prefs : Instance of PreferencesHandler\n        Stores e.g. active plugins.\n    include_eeg : bool\n        Whether to add EEG-related actions\n\n    Returns\n    -------\n    list of QDialog\n        Contains the constructed tabs relevant to the pipeline\n    \"\"\"\n    active_plugins = prefs.active_plugins\n    action_specs = find_all_action_specs()\n    datatype_specs = find_all_datatype_specs()\n    package_specs = find_all_package_specs()\n    tabs = []\n    pipelines = []\n    for source, package_spec in package_specs.items():\n        if source not in active_plugins and source != 'meggie':\n            continue\n        if 'tabs' in package_spec:\n            tabs.extend(package_spec['tabs'])\n        if 'pipelines' in package_spec:\n            pipelines.extend(package_spec['pipelines'])\n    for tab in tabs:\n        if 'id' not in tab:\n            raise Exception('Every tab specification must have id.')\n        if 'name' not in tab:\n            tab['name'] = tab['id']\n        if 'inputs' not in tab:\n            tab['inputs'] = []\n        if 'outputs' not in tab:\n            tab['outputs'] = []\n        if 'input_actions' not in tab:\n            tab['input_actions'] = []\n        if 'output_actions' not in tab:\n            tab['output_actions'] = []\n        if 'info' not in tab:\n            tab['info'] = []\n    for pipeline in pipelines:\n        if 'id' not in pipeline:\n            raise Exception('Every pipeline must have id.')\n        if 'name' not in pipeline:\n            pipeline['name'] = pipeline['id']\n    found = False\n    pipeline_spec = None\n    for pipeline in pipelines:\n        if pipeline['id'] == selected_pipeline:\n            found = True\n            pipeline_spec = pipeline\n            break\n    if not found:\n        pipeline_spec = {'id': 'classic', 'name': 'Include everything'}\n    combined_tabs = []\n    for tab_spec in tabs:\n        if pipeline_spec.get('include_tabs'):\n            if tab_spec['id'] not in pipeline_spec['include_tabs']:\n                continue\n        if tab_spec['id'] not in [tab['id'] for tab in combined_tabs]:\n            new_tab = {}\n            new_tab['id'] = tab_spec['id']\n            new_tab['name'] = tab_spec['name']\n            new_tab['inputs'] = []\n            new_tab['outputs'] = []\n            new_tab['input_actions'] = []\n            new_tab['output_actions'] = []\n            new_tab['info'] = []\n            idx = len(combined_tabs)\n            combined_tabs.append(new_tab)\n        else:\n            idx = [tab['id'] for tab in combined_tabs].index(tab_spec['id'])\n        for input_spec in tab_spec['inputs']:\n            if input_spec not in combined_tabs[idx]['inputs']:\n                combined_tabs[idx]['inputs'].append(input_spec)\n        for output_spec in tab_spec['outputs']:\n            if output_spec not in combined_tabs[idx]['outputs']:\n                combined_tabs[idx]['outputs'].append(output_spec)\n        for input_spec in tab_spec['input_actions']:\n            action_spec = action_specs.get(input_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + input_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if input_spec not in combined_tabs[idx]['input_actions']:\n                combined_tabs[idx]['input_actions'].append(input_spec)\n        for output_spec in tab_spec['output_actions']:\n            action_spec = action_specs.get(output_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + output_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if output_spec not in combined_tabs[idx]['output_actions']:\n                combined_tabs[idx]['output_actions'].append(output_spec)\n        for info_spec in tab_spec['info']:\n            action_spec = action_specs.get(info_spec)\n            if not action_spec:\n                raise Exception('Cannot read info item ' + info_spec + '.')\n            if info_spec not in combined_tabs[idx]['info']:\n                combined_tabs[idx]['info'].append(info_spec)\n    tabs = []\n    for tab_spec in combined_tabs:\n        tabs.append(construct_tab(tab_spec, action_specs, datatype_specs, window))\n    return tabs", "refactored": true, "question_id": "e7dae2609f1a6ef8908cb001bd4912ee60a48a48_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def construct_tabs(selected_pipeline, window, prefs, include_eeg):\n    \"\"\"Constructs as set of tabs based on specifications and the\n    selected pipeline.\n    Parameters\n    ----------\n    selected_pipeline : str\n        ID of the selected pipeline\n    window : instance of main window\n        The main window.\n    prefs : Instance of PreferencesHandler\n        Stores e.g. active plugins.\n    include_eeg : bool\n        Whether to add EEG-related actions\n    Returns\n    -------\n    list of QDialog\n        Contains the constructed tabs relevant to the pipeline\n    \"\"\"\n    active_plugins = prefs.active_plugins\n    action_specs = find_all_action_specs()\n    datatype_specs = find_all_datatype_specs()\n    package_specs = find_all_package_specs()\n    tabs = []\n    pipelines = []\n    for source, package_spec in package_specs.items():\n        if source not in active_plugins and source != 'meggie':\n            continue\n        if 'tabs' in package_spec:\n            tabs.extend(package_spec['tabs'])\n        if 'pipelines' in package_spec:\n            pipelines.extend(package_spec['pipelines'])\n    for tab in tabs:\n        if 'id' not in tab:\n            raise Exception('Every tab specification must have id.')\n        if 'name' not in tab:\n            tab['name'] = tab['id']\n        if 'inputs' not in tab:\n            tab['inputs'] = []\n        if 'outputs' not in tab:\n            tab['outputs'] = []\n        if 'input_actions' not in tab:\n            tab['input_actions'] = []\n        if 'output_actions' not in tab:\n            tab['output_actions'] = []\n        if 'info' not in tab:\n            tab['info'] = []\n    for pipeline in pipelines:\n        if 'id' not in pipeline:\n            raise Exception('Every pipeline must have id.')\n        if 'name' not in pipeline:\n            pipeline['name'] = pipeline['id']\n    found = False\n    pipeline_spec = None\n    for pipeline in pipelines:\n        if pipeline['id'] == selected_pipeline:\n            found = True\n            pipeline_spec = pipeline\n            break\n    if not found:\n        pipeline_spec = {'id': 'classic', 'name': 'Include everything'}\n    combined_tabs = []\n    _iter81 = tabs\n    while True:\n        try:\n            tab_spec = next(_iter81)\n        except StopIteration:\n            break\n        if pipeline_spec.get('include_tabs'):\n            if tab_spec['id'] not in pipeline_spec['include_tabs']:\n                continue\n        if tab_spec['id'] not in [tab['id'] for tab in combined_tabs]:\n            new_tab = {}\n            new_tab['id'] = tab_spec['id']\n            new_tab['name'] = tab_spec['name']\n            new_tab['inputs'] = []\n            new_tab['outputs'] = []\n            new_tab['input_actions'] = []\n            new_tab['output_actions'] = []\n            new_tab['info'] = []\n            idx = len(combined_tabs)\n            combined_tabs.append(new_tab)\n        else:\n            idx = [tab['id'] for tab in combined_tabs].index(tab_spec['id'])\n        for input_spec in tab_spec['inputs']:\n            if input_spec not in combined_tabs[idx]['inputs']:\n                combined_tabs[idx]['inputs'].append(input_spec)\n        for output_spec in tab_spec['outputs']:\n            if output_spec not in combined_tabs[idx]['outputs']:\n                combined_tabs[idx]['outputs'].append(output_spec)\n        for input_spec in tab_spec['input_actions']:\n            action_spec = action_specs.get(input_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + input_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if input_spec not in combined_tabs[idx]['input_actions']:\n                combined_tabs[idx]['input_actions'].append(input_spec)\n        for output_spec in tab_spec['output_actions']:\n            action_spec = action_specs.get(output_spec)\n            if not action_spec:\n                raise Exception('Cannot read action ' + output_spec + '.')\n            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):\n                continue\n            if output_spec not in combined_tabs[idx]['output_actions']:\n                combined_tabs[idx]['output_actions'].append(output_spec)\n        for info_spec in tab_spec['info']:\n            action_spec = action_specs.get(info_spec)\n            if not action_spec:\n                raise Exception('Cannot read info item ' + info_spec + '.')\n            if info_spec not in combined_tabs[idx]['info']:\n                combined_tabs[idx]['info'].append(info_spec)\n    tabs = []\n    for tab_spec in combined_tabs:\n        tabs.append(construct_tab(tab_spec, action_specs, datatype_specs, window))\n"]]}
{"hexsha": "49f5a6884183e7a4dcbfcde101a491ad27898026", "ext": "py", "lang": "Python", "content": "def _get_eval_config_from_service_classification(classification: configuration_pb2.ClassificationProblemSpec, eval_config: model_evaluation_pb2.EvaluationConfig) -> None:\n    if classification.HasField('ground_truth_column_spec'):\n        eval_config.data_spec.label_key_spec.CopyFrom(classification.ground_truth_column_spec)\n    if classification.HasField('example_weight_column_spec'):\n        eval_config.data_spec.example_weight_key_spec.CopyFrom(classification.example_weight_column_spec)\n    if classification.HasField('prediction_score_column_spec'):\n        eval_config.data_spec.predicted_score_key_spec.CopyFrom(classification.prediction_score_column_spec)\n    if classification.HasField('prediction_label_column_spec'):\n        eval_config.data_spec.predicted_label_key_spec.CopyFrom(classification.prediction_label_column_spec)\n    if classification.HasField('prediction_id_column_spec'):\n        eval_config.data_spec.predicted_label_id_key_spec.CopyFrom(classification.prediction_id_column_spec)\n    eval_config.data_spec.labels.extend(classification.class_names)\n    num_classes = len(classification.class_names)\n    if classification.type == configuration_pb2.ClassificationProblemSpec.MULTICLASS:\n        problem_type = constants.ProblemType.MULTICLASS\n    elif classification.type == configuration_pb2.ClassificationProblemSpec.MULTILABEL:\n        problem_type = constants.ProblemType.MULTILABEL\n    else:\n        raise NotImplementedError('Classification type %r not implemented' % classification.type)\n    adapter = tfma_adapter.TFMAToME(class_name_list=list(classification.class_names))\n    tfma_metric_specs = _get_metric_specs(problem_type, list(classification.class_names), list(classification.evaluation_options.positive_classes), list(classification.evaluation_options.top_k_list))\n    _iter82 = tfma_metric_specs\n    while True:\n        try:\n            tfma_metric_spec = next(_iter82)\n        except StopIteration:\n            break\n        eval_config.metrics_specs.append(adapter.metrics_spec(tfma_metric_spec))", "fn_id": 3, "class_fn": false, "repo": "tomar27/pipelines", "file": "components/google-cloud/google_cloud_pipeline_components/experimental/evaluation/flex/lib/config.py", "last_update_at": "2021-10-23T00:39:47+00:00", "original_content": "def _get_eval_config_from_service_classification(classification: configuration_pb2.ClassificationProblemSpec, eval_config: model_evaluation_pb2.EvaluationConfig) -> None:\n    if classification.HasField('ground_truth_column_spec'):\n        eval_config.data_spec.label_key_spec.CopyFrom(classification.ground_truth_column_spec)\n    if classification.HasField('example_weight_column_spec'):\n        eval_config.data_spec.example_weight_key_spec.CopyFrom(classification.example_weight_column_spec)\n    if classification.HasField('prediction_score_column_spec'):\n        eval_config.data_spec.predicted_score_key_spec.CopyFrom(classification.prediction_score_column_spec)\n    if classification.HasField('prediction_label_column_spec'):\n        eval_config.data_spec.predicted_label_key_spec.CopyFrom(classification.prediction_label_column_spec)\n    if classification.HasField('prediction_id_column_spec'):\n        eval_config.data_spec.predicted_label_id_key_spec.CopyFrom(classification.prediction_id_column_spec)\n    eval_config.data_spec.labels.extend(classification.class_names)\n    num_classes = len(classification.class_names)\n    if classification.type == configuration_pb2.ClassificationProblemSpec.MULTICLASS:\n        problem_type = constants.ProblemType.MULTICLASS\n    elif classification.type == configuration_pb2.ClassificationProblemSpec.MULTILABEL:\n        problem_type = constants.ProblemType.MULTILABEL\n    else:\n        raise NotImplementedError('Classification type %r not implemented' % classification.type)\n    adapter = tfma_adapter.TFMAToME(class_name_list=list(classification.class_names))\n    tfma_metric_specs = _get_metric_specs(problem_type, list(classification.class_names), list(classification.evaluation_options.positive_classes), list(classification.evaluation_options.top_k_list))\n    for tfma_metric_spec in tfma_metric_specs:\n        eval_config.metrics_specs.append(adapter.metrics_spec(tfma_metric_spec))", "refactored": true, "question_id": "49f5a6884183e7a4dcbfcde101a491ad27898026_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _get_eval_config_from_service_classification(classification: configuration_pb2.ClassificationProblemSpec, eval_config: model_evaluation_pb2.EvaluationConfig) -> None:\n    if classification.HasField('ground_truth_column_spec'):\n        eval_config.data_spec.label_key_spec.CopyFrom(classification.ground_truth_column_spec)\n    if classification.HasField('example_weight_column_spec'):\n        eval_config.data_spec.example_weight_key_spec.CopyFrom(classification.example_weight_column_spec)\n    if classification.HasField('prediction_score_column_spec'):\n        eval_config.data_spec.predicted_score_key_spec.CopyFrom(classification.prediction_score_column_spec)\n    if classification.HasField('prediction_label_column_spec'):\n        eval_config.data_spec.predicted_label_key_spec.CopyFrom(classification.prediction_label_column_spec)\n    if classification.HasField('prediction_id_column_spec'):\n        eval_config.data_spec.predicted_label_id_key_spec.CopyFrom(classification.prediction_id_column_spec)\n    eval_config.data_spec.labels.extend(classification.class_names)\n    num_classes = len(classification.class_names)\n    if classification.type == configuration_pb2.ClassificationProblemSpec.MULTICLASS:\n        problem_type = constants.ProblemType.MULTICLASS\n    elif classification.type == configuration_pb2.ClassificationProblemSpec.MULTILABEL:\n        problem_type = constants.ProblemType.MULTILABEL\n    else:\n        raise NotImplementedError('Classification type %r not implemented' % classification.type)\n    adapter = tfma_adapter.TFMAToME(class_name_list=list(classification.class_names))\n    tfma_metric_specs = _get_metric_specs(problem_type, list(classification.class_names), list(classification.evaluation_options.positive_classes), list(classification.evaluation_options.top_k_list))\n    _iter82 = tfma_metric_specs\n    while True:\n        try:\n            tfma_metric_spec = next(_iter82)\n        except StopIteration:\n            break\n"]]}
{"hexsha": "c5d6e28510e9bfcfa523c2d73057ed4afa27c4d5", "ext": "py", "lang": "Python", "content": "def _test_overlap(hits):\n    tester = np.zeros(len(hits), dtype=strax.time_fields)\n    tester['time'] = hits['time'] - (hits['left_integration'] - hits['left']) * hits['dt']\n    tester['endtime'] = hits['time'] + (hits['right_integration'] - hits['left']) * hits['dt']\n    _iter83 = np.unique(hits['channel'])\n    while True:\n        try:\n            ch = next(_iter83)\n        except StopIteration:\n            break\n        mask = hits['channel'] == ch\n        test_ch = np.all(tester[mask]['endtime'][:-1] - tester[mask]['time'][1:] <= 0)\n        assert np.all(test_ch), 'Hits overlap!'", "fn_id": 1, "class_fn": false, "repo": "RiceAstroparticleLab/strax", "file": "tests/test_lone_hit_integration.py", "last_update_at": "2021-11-16T18:20:27+00:00", "original_content": "def _test_overlap(hits):\n    tester = np.zeros(len(hits), dtype=strax.time_fields)\n    tester['time'] = hits['time'] - (hits['left_integration'] - hits['left']) * hits['dt']\n    tester['endtime'] = hits['time'] + (hits['right_integration'] - hits['left']) * hits['dt']\n    for ch in np.unique(hits['channel']):\n        mask = hits['channel'] == ch\n        test_ch = np.all(tester[mask]['endtime'][:-1] - tester[mask]['time'][1:] <= 0)\n        assert np.all(test_ch), 'Hits overlap!'", "refactored": true, "question_id": "c5d6e28510e9bfcfa523c2d73057ed4afa27c4d5_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _test_overlap(hits):\n    tester = np.zeros(len(hits), dtype=strax.time_fields)\n    tester['time'] = hits['time'] - (hits['left_integration'] - hits['left']) * hits['dt']\n    tester['endtime'] = hits['time'] + (hits['right_integration'] - hits['left']) * hits['dt']\n    _iter83 = np.unique(hits['channel'])\n    while True:\n        try:\n            ch = next(_iter83)\n        except StopIteration:\n            break\n        mask = hits['channel'] == ch\n        test_ch = np.all(tester[mask]['endtime'][:-1] - tester[mask]['time'][1:] <= 0)\n"]]}
{"hexsha": "be45de239f2a958420b5ae5de4b313cf3431599f", "ext": "py", "lang": "Python", "content": "def get_playlist_tracks(args):\n    playlists = []\n    current_user_id = args.get('current_user_id')\n    limit = args.get('limit')\n    offset = args.get('offset')\n    db = get_db_read_replica()\n    with db.scoped_session() as session:\n        try:\n            playlist_id = args.get('playlist_id')\n            playlist = session.query(Playlist).filter(Playlist.is_current == True, Playlist.playlist_id == playlist_id).first()\n            if playlist is None:\n                return None\n            playlist_track_ids = [track_id['track'] for track_id in playlist.playlist_contents['track_ids']]\n            if limit and offset:\n                playlist_track_ids = playlist_track_ids[offset:offset + limit]\n            playlist_tracks = session.query(Track).filter(Track.is_current == True, Track.track_id.in_(playlist_track_ids)).all()\n            tracks = helpers.query_result_to_list(playlist_tracks)\n            tracks = populate_track_metadata(session, playlist_track_ids, tracks, current_user_id)\n            if args.get('with_users', False):\n                add_users_to_tracks(session, tracks)\n            tracks_dict = {track['track_id']: track for track in tracks}\n            playlist_tracks = []\n            _iter84 = playlist_track_ids\n            while True:\n                try:\n                    track_id = next(_iter84)\n                except StopIteration:\n                    break\n                playlist_tracks.append(tracks_dict[track_id])\n            return playlist_tracks\n        except sqlalchemy.orm.exc.NoResultFound:\n            pass\n    return playlists", "fn_id": 0, "class_fn": false, "repo": "raymondjacobson/audius-protocol", "file": "discovery-provider/src/queries/get_playlist_tracks.py", "last_update_at": "2021-05-29T04:25:03+00:00", "original_content": "def get_playlist_tracks(args):\n    playlists = []\n    current_user_id = args.get('current_user_id')\n    limit = args.get('limit')\n    offset = args.get('offset')\n    db = get_db_read_replica()\n    with db.scoped_session() as session:\n        try:\n            playlist_id = args.get('playlist_id')\n            playlist = session.query(Playlist).filter(Playlist.is_current == True, Playlist.playlist_id == playlist_id).first()\n            if playlist is None:\n                return None\n            playlist_track_ids = [track_id['track'] for track_id in playlist.playlist_contents['track_ids']]\n            if limit and offset:\n                playlist_track_ids = playlist_track_ids[offset:offset + limit]\n            playlist_tracks = session.query(Track).filter(Track.is_current == True, Track.track_id.in_(playlist_track_ids)).all()\n            tracks = helpers.query_result_to_list(playlist_tracks)\n            tracks = populate_track_metadata(session, playlist_track_ids, tracks, current_user_id)\n            if args.get('with_users', False):\n                add_users_to_tracks(session, tracks)\n            tracks_dict = {track['track_id']: track for track in tracks}\n            playlist_tracks = []\n            for track_id in playlist_track_ids:\n                playlist_tracks.append(tracks_dict[track_id])\n            return playlist_tracks\n        except sqlalchemy.orm.exc.NoResultFound:\n            pass\n    return playlists", "refactored": true, "question_id": "be45de239f2a958420b5ae5de4b313cf3431599f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_playlist_tracks(args):\n    playlists = []\n    current_user_id = args.get('current_user_id')\n    limit = args.get('limit')\n    offset = args.get('offset')\n    db = get_db_read_replica()\n    with db.scoped_session() as session:\n        try:\n            playlist_id = args.get('playlist_id')\n            playlist = session.query(Playlist).filter(Playlist.is_current == True, Playlist.playlist_id == playlist_id).first()\n            if playlist is None:\n                return None\n            playlist_track_ids = [track_id['track'] for track_id in playlist.playlist_contents['track_ids']]\n            if limit and offset:\n                playlist_track_ids = playlist_track_ids[offset:offset + limit]\n            playlist_tracks = session.query(Track).filter(Track.is_current == True, Track.track_id.in_(playlist_track_ids)).all()\n            tracks = helpers.query_result_to_list(playlist_tracks)\n            tracks = populate_track_metadata(session, playlist_track_ids, tracks, current_user_id)\n            if args.get('with_users', False):\n                add_users_to_tracks(session, tracks)\n            tracks_dict = {track['track_id']: track for track in tracks}\n            playlist_tracks = []\n            _iter84 = playlist_track_ids\n            while True:\n                try:\n                    track_id = next(_iter84)\n                except StopIteration:\n                    break\n                playlist_tracks.append(tracks_dict[track_id])\n            return playlist_tracks\n        except sqlalchemy.orm.exc.NoResultFound:\n            pass\n"]]}
{"hexsha": "3ee5df8aa3ce8621360bf2c27434ac72151c3d37", "ext": "py", "lang": "Python", "content": "def context_geo(key, values, dataset, namecount):\n    geoname = '\"' + key + '\"'\n    spar2 = '\\n    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\\n    PREFIX gndo: <http://d-nb.info/standards/elementset/gnd#>\\n    PREFIX pro: <http://purl.org/hpi/patchr#>\\n    PREFIX owl: <http://www.w3.org/2002/07/owl#>\\n    PREFIX edm: <http://www.europeana.eu/schemas/edm/>\\n    PREFIX dc: <http://purl.org/dc/elements/1.1/>\\n    PREFIX foaf: <http://xmlns.com/foaf/0.1/>\\n    PREFIX skos: <http://www.w3.org/2004/02/skos/core#>\\n    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\\n    PREFIX dblp: <http://dblp.org/rdf/schema-2015-01-26#>\\n    PREFIX dcterms: <http://purl.org/dc/terms/>\\n    PREFIX bibtex: <http://data.bibbase.org/ontology/#>\\n    PREFIX geo: <http://www.opengis.net/ont/geosparql#>\\n\\n        select ?x  (group_concat(?alt; SEPARATOR=\", \") as ?altname) (group_concat(?sameas; SEPARATOR=\", \") as ?same)\\n\\n        WHERE{{\\n\\n          graph <http://maral.wisslab.org/graphs/gnd> {{\\n\\n\\n            \\t?x (gndo:preferredNameForThePlaceOrGeographicName | gndo:variantNameForThePlaceOrGeographicName){0}.\\n                optional {{?x gndo:variantNameForThePlaceOrGeographicName ?alt.}}\\n                optional {{?x owl:sameAs ?sameas.}}\\n               # ?x geo:hasGeometry ?geo.\\n               # optional {{?geo geo:asWKT ?coo}}\\n          }}\\n          }} group by ?x\\n\\n        '.format(geoname)\n    sparql.setQuery(spar2)\n    sparql.setReturnFormat(XML)\n    results = sparql.query().convert()\n    for i in range(0, len(results.bindings)):\n        uri = 'https://data.jhn.ngo/spatial/' + str(dataset) + '/' + str(namecount)\n        graph.add((URIRef(uri), RDF.type, edm.Place))\n        for z in range(0, len(values)):\n            graph.add((URIRef(uri), edm.identifier, Literal(values[z])))\n        graph.add((URIRef(uri), skos.prefLabel, Literal(key)))\n        if 'altname' in results.bindings[i].keys():\n            count1 = results.bindings[i]['altname'].value.count(',')\n            if count1 > 0:\n                for j in range(0, count1 + 1):\n                    graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value.rsplit(', ', count1)[count1 - j])))\n            else:\n                graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value)))\n        if 'same' in results.bindings[i].keys():\n            count2 = results.bindings[i]['same'].value.count(',')\n            if count2 > 0:\n                _iter85 = range(0, count2 + 1)\n                while True:\n                    try:\n                        j = next(_iter85)\n                    except StopIteration:\n                        break\n                    graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value.rsplit(', ', count2)[count2 - j])))\n            else:\n                graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value)))\n    graph.serialize(destination=dataset + '_Spatial_01.ttl', format='turtle')", "fn_id": 1, "class_fn": false, "repo": "ubffm/judaica-europeana-2-0", "file": "scripts/contextualize_output_spatial_01.py", "last_update_at": "2021-03-17T08:38:58+00:00", "original_content": "def context_geo(key, values, dataset, namecount):\n    geoname = '\"' + key + '\"'\n    spar2 = '\\n    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\\n    PREFIX gndo: <http://d-nb.info/standards/elementset/gnd#>\\n    PREFIX pro: <http://purl.org/hpi/patchr#>\\n    PREFIX owl: <http://www.w3.org/2002/07/owl#>\\n    PREFIX edm: <http://www.europeana.eu/schemas/edm/>\\n    PREFIX dc: <http://purl.org/dc/elements/1.1/>\\n    PREFIX foaf: <http://xmlns.com/foaf/0.1/>\\n    PREFIX skos: <http://www.w3.org/2004/02/skos/core#>\\n    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\\n    PREFIX dblp: <http://dblp.org/rdf/schema-2015-01-26#>\\n    PREFIX dcterms: <http://purl.org/dc/terms/>\\n    PREFIX bibtex: <http://data.bibbase.org/ontology/#>\\n    PREFIX geo: <http://www.opengis.net/ont/geosparql#>\\n\\n        select ?x  (group_concat(?alt; SEPARATOR=\", \") as ?altname) (group_concat(?sameas; SEPARATOR=\", \") as ?same)\\n\\n        WHERE{{\\n\\n          graph <http://maral.wisslab.org/graphs/gnd> {{\\n\\n\\n            \\t?x (gndo:preferredNameForThePlaceOrGeographicName | gndo:variantNameForThePlaceOrGeographicName){0}.\\n                optional {{?x gndo:variantNameForThePlaceOrGeographicName ?alt.}}\\n                optional {{?x owl:sameAs ?sameas.}}\\n               # ?x geo:hasGeometry ?geo.\\n               # optional {{?geo geo:asWKT ?coo}}\\n          }}\\n          }} group by ?x\\n\\n        '.format(geoname)\n    sparql.setQuery(spar2)\n    sparql.setReturnFormat(XML)\n    results = sparql.query().convert()\n    for i in range(0, len(results.bindings)):\n        uri = 'https://data.jhn.ngo/spatial/' + str(dataset) + '/' + str(namecount)\n        graph.add((URIRef(uri), RDF.type, edm.Place))\n        for z in range(0, len(values)):\n            graph.add((URIRef(uri), edm.identifier, Literal(values[z])))\n        graph.add((URIRef(uri), skos.prefLabel, Literal(key)))\n        if 'altname' in results.bindings[i].keys():\n            count1 = results.bindings[i]['altname'].value.count(',')\n            if count1 > 0:\n                for j in range(0, count1 + 1):\n                    graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value.rsplit(', ', count1)[count1 - j])))\n            else:\n                graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value)))\n        if 'same' in results.bindings[i].keys():\n            count2 = results.bindings[i]['same'].value.count(',')\n            if count2 > 0:\n                for j in range(0, count2 + 1):\n                    graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value.rsplit(', ', count2)[count2 - j])))\n            else:\n                graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value)))\n    graph.serialize(destination=dataset + '_Spatial_01.ttl', format='turtle')", "refactored": true, "question_id": "3ee5df8aa3ce8621360bf2c27434ac72151c3d37_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def context_geo(key, values, dataset, namecount):\n    geoname = '\"' + key + '\"'\n    spar2 = '\\n    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\\n    PREFIX gndo: <http://d-nb.info/standards/elementset/gnd#>\\n    PREFIX pro: <http://purl.org/hpi/patchr#>\\n    PREFIX owl: <http://www.w3.org/2002/07/owl#>\\n    PREFIX edm: <http://www.europeana.eu/schemas/edm/>\\n    PREFIX dc: <http://purl.org/dc/elements/1.1/>\\n    PREFIX foaf: <http://xmlns.com/foaf/0.1/>\\n    PREFIX skos: <http://www.w3.org/2004/02/skos/core#>\\n    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\\n    PREFIX dblp: <http://dblp.org/rdf/schema-2015-01-26#>\\n    PREFIX dcterms: <http://purl.org/dc/terms/>\\n    PREFIX bibtex: <http://data.bibbase.org/ontology/#>\\n    PREFIX geo: <http://www.opengis.net/ont/geosparql#>\\n\\n        select ?x  (group_concat(?alt; SEPARATOR=\", \") as ?altname) (group_concat(?sameas; SEPARATOR=\", \") as ?same)\\n\\n        WHERE{{\\n\\n          graph <http://maral.wisslab.org/graphs/gnd> {{\\n\\n\\n            \\t?x (gndo:preferredNameForThePlaceOrGeographicName | gndo:variantNameForThePlaceOrGeographicName){0}.\\n                optional {{?x gndo:variantNameForThePlaceOrGeographicName ?alt.}}\\n                optional {{?x owl:sameAs ?sameas.}}\\n               # ?x geo:hasGeometry ?geo.\\n               # optional {{?geo geo:asWKT ?coo}}\\n          }}\\n          }} group by ?x\\n\\n        '.format(geoname)\n    sparql.setQuery(spar2)\n    sparql.setReturnFormat(XML)\n    results = sparql.query().convert()\n    for i in range(0, len(results.bindings)):\n        uri = 'https://data.jhn.ngo/spatial/' + str(dataset) + '/' + str(namecount)\n        graph.add((URIRef(uri), RDF.type, edm.Place))\n        for z in range(0, len(values)):\n            graph.add((URIRef(uri), edm.identifier, Literal(values[z])))\n        graph.add((URIRef(uri), skos.prefLabel, Literal(key)))\n        if 'altname' in results.bindings[i].keys():\n            count1 = results.bindings[i]['altname'].value.count(',')\n            if count1 > 0:\n                for j in range(0, count1 + 1):\n                    graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value.rsplit(', ', count1)[count1 - j])))\n            else:\n                graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value)))\n        if 'same' in results.bindings[i].keys():\n            count2 = results.bindings[i]['same'].value.count(',')\n            if count2 > 0:\n                _iter85 = range(0, count2 + 1)\n                while True:\n                    try:\n                        j = next(_iter85)\n                    except StopIteration:\n                        break\n                    graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value.rsplit(', ', count2)[count2 - j])))\n            else:\n                graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value)))\n"]]}
{"hexsha": "6a706ba112e6e0c7b57c1e46bd9b0418402db376", "ext": "pyde", "lang": "Python", "content": "def draw():\n    loadPixels()\n    x = 4.0\n    y = 0.0\n    _iter86 = range(1, 120000, 1)\n    while True:\n        try:\n            i = next(_iter86)\n        except StopIteration:\n            break\n        x1 = b * y + f(x)\n        y = -x + f(x1)\n        x = x1\n        pixels[350 + int(x * 26) + (280 - int(y * 26)) * width] = color(i % 255, 100, 100)\n    updatePixels()", "fn_id": 1, "class_fn": false, "repo": "kantel/processingpy", "file": "sketches/mira/mira.pyde", "last_update_at": "2021-08-18T19:55:15+00:00", "original_content": "def draw():\n    loadPixels()\n    x = 4.0\n    y = 0.0\n    for i in range(1, 120000, 1):\n        x1 = b * y + f(x)\n        y = -x + f(x1)\n        x = x1\n        pixels[350 + int(x * 26) + (280 - int(y * 26)) * width] = color(i % 255, 100, 100)\n    updatePixels()", "refactored": true, "question_id": "6a706ba112e6e0c7b57c1e46bd9b0418402db376_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def draw():\n    loadPixels()\n    x = 4.0\n    y = 0.0\n    _iter86 = range(1, 120000, 1)\n    while True:\n        try:\n            i = next(_iter86)\n        except StopIteration:\n            break\n        x1 = b * y + f(x)\n        y = -x + f(x1)\n        x = x1\n        pixels[350 + int(x * 26) + (280 - int(y * 26)) * width] = color(i % 255, 100, 100)\n"]]}
{"hexsha": "d4e3e838774528218776e66d0b619c26190040dd", "ext": "py", "lang": "Python", "content": "@api_view(['PUT'])\n@permission_classes((IsAuthenticated,))\n@allowed_groups(group_names=['admin'])\ndef updateUser(request: HttpRequest, id):\n    user = get_object_or_404(User, id=id)\n    groups = request.data.pop('authGroups', [])\n    serialised = UserSerializer(user, data=request.data, context={'request': request}, partial=True)\n    if serialised.is_valid():\n        serialised.save()\n        user_group_many.objects.filter(user=user).delete()\n        _iter87 = groups\n        while True:\n            try:\n                group = next(_iter87)\n            except StopIteration:\n                break\n            user_group_many.objects.create(user=user, group_id=group['id'])\n        return Response(status=status.HTTP_200_OK)\n    print(serialised.error_messages)\n    return Response(status=status.HTTP_400_BAD_REQUEST)", "fn_id": 6, "class_fn": false, "repo": "JetLightStudio/Jet-Gest-stock-management", "file": "server/auth_app/views/authViews.py", "last_update_at": "2021-08-18T18:53:02+00:00", "original_content": "@api_view(['PUT'])\n@permission_classes((IsAuthenticated,))\n@allowed_groups(group_names=['admin'])\ndef updateUser(request: HttpRequest, id):\n    user = get_object_or_404(User, id=id)\n    groups = request.data.pop('authGroups', [])\n    serialised = UserSerializer(user, data=request.data, context={'request': request}, partial=True)\n    if serialised.is_valid():\n        serialised.save()\n        user_group_many.objects.filter(user=user).delete()\n        for group in groups:\n            user_group_many.objects.create(user=user, group_id=group['id'])\n        return Response(status=status.HTTP_200_OK)\n    print(serialised.error_messages)\n    return Response(status=status.HTTP_400_BAD_REQUEST)", "refactored": true, "question_id": "d4e3e838774528218776e66d0b619c26190040dd_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@api_view(['PUT'])\n@permission_classes((IsAuthenticated,))\n@allowed_groups(group_names=['admin'])\ndef updateUser(request: HttpRequest, id):\n    user = get_object_or_404(User, id=id)\n    groups = request.data.pop('authGroups', [])\n    serialised = UserSerializer(user, data=request.data, context={'request': request}, partial=True)\n    if serialised.is_valid():\n        serialised.save()\n        user_group_many.objects.filter(user=user).delete()\n        _iter87 = groups\n        while True:\n            try:\n                group = next(_iter87)\n            except StopIteration:\n                break\n            user_group_many.objects.create(user=user, group_id=group['id'])\n        return Response(status=status.HTTP_200_OK)\n    print(serialised.error_messages)\n"]]}
{"hexsha": "2096e74d026f92b88f279c71ae6c465be2f77b95", "ext": "py", "lang": "Python", "content": "def is_accuracy_aware_training(config: NNCFConfig, compression_config_passed: bool=False) -> bool:\n    \"\"\"\n    Returns True if the compression config contains an accuracy-aware\n    training related section, False otherwise.\n    \"\"\"\n    compression_config = config.get('compression', {}) if not compression_config_passed else config\n    if isinstance(compression_config, list):\n        _iter88 = compression_config\n        while True:\n            try:\n                algo_config = next(_iter88)\n            except StopIteration:\n                break\n            if algo_config.get('accuracy_aware_training') is not None:\n                return True\n        return False\n    if compression_config.get('accuracy_aware_training') is not None:\n        return True\n    return False", "fn_id": 0, "class_fn": false, "repo": "sarthakpati/nncf", "file": "nncf/config/utils.py", "last_update_at": "2021-07-23T07:46:52+00:00", "original_content": "def is_accuracy_aware_training(config: NNCFConfig, compression_config_passed: bool=False) -> bool:\n    \"\"\"\n    Returns True if the compression config contains an accuracy-aware\n    training related section, False otherwise.\n    \"\"\"\n    compression_config = config.get('compression', {}) if not compression_config_passed else config\n    if isinstance(compression_config, list):\n        for algo_config in compression_config:\n            if algo_config.get('accuracy_aware_training') is not None:\n                return True\n        return False\n    if compression_config.get('accuracy_aware_training') is not None:\n        return True\n    return False", "refactored": true, "question_id": "2096e74d026f92b88f279c71ae6c465be2f77b95_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def is_accuracy_aware_training(config: NNCFConfig, compression_config_passed: bool=False) -> bool:\n    \"\"\"\n    Returns True if the compression config contains an accuracy-aware\n    training related section, False otherwise.\n    \"\"\"\n    compression_config = config.get('compression', {}) if not compression_config_passed else config\n    if isinstance(compression_config, list):\n        _iter88 = compression_config\n        while True:\n            try:\n                algo_config = next(_iter88)\n            except StopIteration:\n                break\n            if algo_config.get('accuracy_aware_training') is not None:\n                return True\n        return False\n    if compression_config.get('accuracy_aware_training') is not None:\n        return True\n"]]}
{"hexsha": "de5093d7a37e19119c9ed380921063f98f98a572", "ext": "py", "lang": "Python", "content": "def solve_all(l, r):\n    res.clear()\n    nl = l.copy()\n    _iter89 = range(len(nl))\n    while True:\n        try:\n            i = next(_iter89)\n        except StopIteration:\n            break\n        nl[i] = (frac(nl[i]), str(nl[i]))\n    solve_all_rec(nl, frac(r))\n    return res", "fn_id": 1, "class_fn": false, "repo": "mateo-cv/KryptoCards", "file": "solver_all.py", "last_update_at": "2021-11-06T02:19:58+00:00", "original_content": "def solve_all(l, r):\n    res.clear()\n    nl = l.copy()\n    for i in range(len(nl)):\n        nl[i] = (frac(nl[i]), str(nl[i]))\n    solve_all_rec(nl, frac(r))\n    return res", "refactored": true, "question_id": "de5093d7a37e19119c9ed380921063f98f98a572_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def solve_all(l, r):\n    res.clear()\n    nl = l.copy()\n    _iter89 = range(len(nl))\n    while True:\n        try:\n            i = next(_iter89)\n        except StopIteration:\n            break\n        nl[i] = (frac(nl[i]), str(nl[i]))\n    solve_all_rec(nl, frac(r))\n"]]}
{"hexsha": "cc8172756946d110aef633b85d99fdb465e813dc", "ext": "py", "lang": "Python", "content": "def used_tracks_set(image, all=False):\n    \"\"\"Determine the set of tracks used by directory and files on the disk\"\"\"\n    bam = Disk.from_image(image).bam()\n    used_tracks = set()\n    _iter90 = range(2)\n    while True:\n        try:\n            head = next(_iter90)\n        except StopIteration:\n            break\n        for cyl in range(80):\n            track = head << 7 | cyl\n            offset = (80 * head + cyl - 4) * image.spt\n            if all or track <= 4 or bam[offset:offset + image.spt].any():\n                used_tracks.add(track)\n    return used_tracks", "fn_id": 1, "class_fn": false, "repo": "simonowen/writeusb", "file": "mgtwriteusb/writeusb.py", "last_update_at": "2021-08-03T21:10:03+00:00", "original_content": "def used_tracks_set(image, all=False):\n    \"\"\"Determine the set of tracks used by directory and files on the disk\"\"\"\n    bam = Disk.from_image(image).bam()\n    used_tracks = set()\n    for head in range(2):\n        for cyl in range(80):\n            track = head << 7 | cyl\n            offset = (80 * head + cyl - 4) * image.spt\n            if all or track <= 4 or bam[offset:offset + image.spt].any():\n                used_tracks.add(track)\n    return used_tracks", "refactored": true, "question_id": "cc8172756946d110aef633b85d99fdb465e813dc_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def used_tracks_set(image, all=False):\n    \"\"\"Determine the set of tracks used by directory and files on the disk\"\"\"\n    bam = Disk.from_image(image).bam()\n    used_tracks = set()\n    _iter90 = range(2)\n    while True:\n        try:\n            head = next(_iter90)\n        except StopIteration:\n            break\n        for cyl in range(80):\n            track = head << 7 | cyl\n            offset = (80 * head + cyl - 4) * image.spt\n            if all or track <= 4 or bam[offset:offset + image.spt].any():\n                used_tracks.add(track)\n"]]}
{"hexsha": "d24a6419f9fcb2d3facd5e3d432818cfe2776fbb", "ext": "py", "lang": "Python", "content": "def get_activity_rawdata(cfg: DictConfig, id: int) -> pd.DataFrame:\n    \"\"\"query rawdata from strava api for a given id\n\n    Args:\n        cfg (DictConfig): configuration\n        id (int): activity id\n\n    Returns:\n        pd.DataFrame: activity rawdata\n    \"\"\"\n    with MySession(cfg) as session:\n        stream = session.get(cfg.api.BASE_URL + f'/activities/{id}/streams', params={'keys': ','.join(cfg.api.STREAMS)})\n    activity = dict()\n    found = list()\n    for values in stream.json():\n        activity[values['type']] = values['data']\n        found.append(values['type'])\n    res_df = pd.DataFrame(activity)\n    try:\n        res_df['lat'] = res_df['latlng'].apply(lambda x: x[0])\n        res_df['long'] = res_df['latlng'].apply(lambda x: x[-1])\n    except KeyError:\n        res_df['lat'], res_df['long'] = (np.nan, np.nan)\n    missings = set(cfg.api.STREAMS) - set(found)\n    if missings:\n        _iter91 = missings\n        while True:\n            try:\n                missing = next(_iter91)\n            except StopIteration:\n                break\n            res_df[missing] = np.nan\n    res_df['id'] = id\n    if 'latlng' in res_df:\n        del res_df['latlng']\n    if cfg.TO_DB:\n        res_df['last_update'] = save_datetime_now()\n        with sqlite3.connect(call(cfg.DB)) as con:\n            res_df.to_sql('ACTIVITIES_RAW', con=con, if_exists='append', index=False, index_label='id')\n    time.sleep(cfg.api.SLEEP)\n    return res_df", "fn_id": 6, "class_fn": false, "repo": "Ektoplasmakugel/strava_datacollect", "file": "strava_datacollect/strava_query.py", "last_update_at": "2021-01-05T10:58:30+00:00", "original_content": "def get_activity_rawdata(cfg: DictConfig, id: int) -> pd.DataFrame:\n    \"\"\"query rawdata from strava api for a given id\n\n    Args:\n        cfg (DictConfig): configuration\n        id (int): activity id\n\n    Returns:\n        pd.DataFrame: activity rawdata\n    \"\"\"\n    with MySession(cfg) as session:\n        stream = session.get(cfg.api.BASE_URL + f'/activities/{id}/streams', params={'keys': ','.join(cfg.api.STREAMS)})\n    activity = dict()\n    found = list()\n    for values in stream.json():\n        activity[values['type']] = values['data']\n        found.append(values['type'])\n    res_df = pd.DataFrame(activity)\n    try:\n        res_df['lat'] = res_df['latlng'].apply(lambda x: x[0])\n        res_df['long'] = res_df['latlng'].apply(lambda x: x[-1])\n    except KeyError:\n        res_df['lat'], res_df['long'] = (np.nan, np.nan)\n    missings = set(cfg.api.STREAMS) - set(found)\n    if missings:\n        for missing in missings:\n            res_df[missing] = np.nan\n    res_df['id'] = id\n    if 'latlng' in res_df:\n        del res_df['latlng']\n    if cfg.TO_DB:\n        res_df['last_update'] = save_datetime_now()\n        with sqlite3.connect(call(cfg.DB)) as con:\n            res_df.to_sql('ACTIVITIES_RAW', con=con, if_exists='append', index=False, index_label='id')\n    time.sleep(cfg.api.SLEEP)\n    return res_df", "refactored": true, "question_id": "d24a6419f9fcb2d3facd5e3d432818cfe2776fbb_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_activity_rawdata(cfg: DictConfig, id: int) -> pd.DataFrame:\n    \"\"\"query rawdata from strava api for a given id\n    Args:\n        cfg (DictConfig): configuration\n        id (int): activity id\n    Returns:\n        pd.DataFrame: activity rawdata\n    \"\"\"\n    with MySession(cfg) as session:\n        stream = session.get(cfg.api.BASE_URL + f'/activities/{id}/streams', params={'keys': ','.join(cfg.api.STREAMS)})\n    activity = dict()\n    found = list()\n    for values in stream.json():\n        activity[values['type']] = values['data']\n        found.append(values['type'])\n    res_df = pd.DataFrame(activity)\n    try:\n        res_df['lat'] = res_df['latlng'].apply(lambda x: x[0])\n        res_df['long'] = res_df['latlng'].apply(lambda x: x[-1])\n    except KeyError:\n        res_df['lat'], res_df['long'] = (np.nan, np.nan)\n    missings = set(cfg.api.STREAMS) - set(found)\n    if missings:\n        _iter91 = missings\n        while True:\n            try:\n                missing = next(_iter91)\n            except StopIteration:\n                break\n            res_df[missing] = np.nan\n    res_df['id'] = id\n    if 'latlng' in res_df:\n        del res_df['latlng']\n    if cfg.TO_DB:\n        res_df['last_update'] = save_datetime_now()\n        with sqlite3.connect(call(cfg.DB)) as con:\n            res_df.to_sql('ACTIVITIES_RAW', con=con, if_exists='append', index=False, index_label='id')\n    time.sleep(cfg.api.SLEEP)\n"]]}
{"hexsha": "4ccaae78da187b459e1b8de6f377e49ceb0a7fea", "ext": "py", "lang": "Python", "content": "def _get_files_from_arcs(extension, arc_list=None, arc_path=None):\n    use_concurrency = False\n    if arc_path:\n        arc_list = find_files(arc_path, '.arc')\n    elif arc_list:\n        arc_list = arc_list\n    else:\n        arc_list = ARC_FILES\n    to_export = [arc_file for arc_file in arc_list if arc_file not in CACHE_ARC]\n    if to_export and use_concurrency:\n        concurrent_unpack(arc_list, CACHE_ARC, extension)\n    elif to_export and (not use_concurrency):\n        _iter92 = to_export\n        while True:\n            try:\n                arc_file = next(_iter92)\n            except StopIteration:\n                break\n            _unpack_arc_in_temp(arc_file, CACHE_ARC)\n    files, ids = _get_files_and_ids(extension, arc_list)\n    return (files, ids)", "fn_id": 0, "class_fn": false, "repo": "BlenderCN-Org/albam", "file": "tests/mtframework/conftest.py", "last_update_at": "2021-01-05T22:58:18+00:00", "original_content": "def _get_files_from_arcs(extension, arc_list=None, arc_path=None):\n    use_concurrency = False\n    if arc_path:\n        arc_list = find_files(arc_path, '.arc')\n    elif arc_list:\n        arc_list = arc_list\n    else:\n        arc_list = ARC_FILES\n    to_export = [arc_file for arc_file in arc_list if arc_file not in CACHE_ARC]\n    if to_export and use_concurrency:\n        concurrent_unpack(arc_list, CACHE_ARC, extension)\n    elif to_export and (not use_concurrency):\n        for arc_file in to_export:\n            _unpack_arc_in_temp(arc_file, CACHE_ARC)\n    files, ids = _get_files_and_ids(extension, arc_list)\n    return (files, ids)", "refactored": true, "question_id": "4ccaae78da187b459e1b8de6f377e49ceb0a7fea_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _get_files_from_arcs(extension, arc_list=None, arc_path=None):\n    use_concurrency = False\n    if arc_path:\n        arc_list = find_files(arc_path, '.arc')\n    elif arc_list:\n        arc_list = arc_list\n    else:\n        arc_list = ARC_FILES\n    to_export = [arc_file for arc_file in arc_list if arc_file not in CACHE_ARC]\n    if to_export and use_concurrency:\n        concurrent_unpack(arc_list, CACHE_ARC, extension)\n    elif to_export and (not use_concurrency):\n        _iter92 = to_export\n        while True:\n            try:\n                arc_file = next(_iter92)\n            except StopIteration:\n                break\n            _unpack_arc_in_temp(arc_file, CACHE_ARC)\n    files, ids = _get_files_and_ids(extension, arc_list)\n"]]}
{"hexsha": "65d2c4247e06b070e56286e1c0516a47f5fdba82", "ext": "py", "lang": "Python", "content": "def generate_testcase_files(instance, env, testcase_dir_path):\n    testcases_list = []\n    config = {'config': {'name': instance.name, 'variables': [], 'request': {'base_url': env.base_url if env else ''}}}\n    testcases_list.append(config)\n    include = json.loads(instance.include, encoding='utf-8')\n    request = json.loads(instance.request, encoding='utf-8')\n    module_name = instance.module.name\n    project_name = instance.module.project.name\n    testcase_dir_path = os.path.join(testcase_dir_path, project_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n        debugtalk_obj = Projects.objects.get(name=project_name).debugtalk\n        if debugtalk_obj:\n            debugtalk = debugtalk_obj.debugtalk\n        else:\n            debugtalk = ''\n        with open(os.path.join(testcase_dir_path, 'debugtalk.py'), mode='w', encoding='utf-8') as one_file:\n            one_file.write(debugtalk)\n    testcase_dir_path = os.path.join(testcase_dir_path, module_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n    if 'testcases' in include:\n        for t_id in include.get('testcases'):\n            testcase_obj = Testcases.objects.filter(id=t_id).first()\n            if testcase_obj:\n                try:\n                    testcase_request = json.loads(testcase_obj.request, encoding='utf-8')\n                except Exception as e:\n                    logger.error(e)\n                    continue\n                else:\n                    extract = testcase_request['test'].get('extract')\n                    if extract:\n                        _iter93 = extract\n                        while True:\n                            try:\n                                e = next(_iter93)\n                            except StopIteration:\n                                break\n                            testcases_list[0]['config']['variables'].append({[i for i in e.keys()][0]: ''})\n                    testcase_request['test'] = OrderedDict(testcase_request['test'])\n                    testcases_list.append(OrderedDict(testcase_request))\n    request['test'] = OrderedDict(request['test'])\n    testcases_list.append(request)\n    with open(os.path.join(testcase_dir_path, instance.name + '.yml'), mode='w', encoding='utf-8') as one_file:\n        ordered_yaml_dump(testcases_list, one_file, default_flow_style=False, allow_unicode=True)", "fn_id": 1, "class_fn": false, "repo": "op896898466/apitest", "file": "utils/common.py", "last_update_at": "2021-08-16T05:48:43+00:00", "original_content": "def generate_testcase_files(instance, env, testcase_dir_path):\n    testcases_list = []\n    config = {'config': {'name': instance.name, 'variables': [], 'request': {'base_url': env.base_url if env else ''}}}\n    testcases_list.append(config)\n    include = json.loads(instance.include, encoding='utf-8')\n    request = json.loads(instance.request, encoding='utf-8')\n    module_name = instance.module.name\n    project_name = instance.module.project.name\n    testcase_dir_path = os.path.join(testcase_dir_path, project_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n        debugtalk_obj = Projects.objects.get(name=project_name).debugtalk\n        if debugtalk_obj:\n            debugtalk = debugtalk_obj.debugtalk\n        else:\n            debugtalk = ''\n        with open(os.path.join(testcase_dir_path, 'debugtalk.py'), mode='w', encoding='utf-8') as one_file:\n            one_file.write(debugtalk)\n    testcase_dir_path = os.path.join(testcase_dir_path, module_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n    if 'testcases' in include:\n        for t_id in include.get('testcases'):\n            testcase_obj = Testcases.objects.filter(id=t_id).first()\n            if testcase_obj:\n                try:\n                    testcase_request = json.loads(testcase_obj.request, encoding='utf-8')\n                except Exception as e:\n                    logger.error(e)\n                    continue\n                else:\n                    extract = testcase_request['test'].get('extract')\n                    if extract:\n                        for e in extract:\n                            testcases_list[0]['config']['variables'].append({[i for i in e.keys()][0]: ''})\n                    testcase_request['test'] = OrderedDict(testcase_request['test'])\n                    testcases_list.append(OrderedDict(testcase_request))\n    request['test'] = OrderedDict(request['test'])\n    testcases_list.append(request)\n    with open(os.path.join(testcase_dir_path, instance.name + '.yml'), mode='w', encoding='utf-8') as one_file:\n        ordered_yaml_dump(testcases_list, one_file, default_flow_style=False, allow_unicode=True)", "refactored": true, "question_id": "65d2c4247e06b070e56286e1c0516a47f5fdba82_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def generate_testcase_files(instance, env, testcase_dir_path):\n    testcases_list = []\n    config = {'config': {'name': instance.name, 'variables': [], 'request': {'base_url': env.base_url if env else ''}}}\n    testcases_list.append(config)\n    include = json.loads(instance.include, encoding='utf-8')\n    request = json.loads(instance.request, encoding='utf-8')\n    module_name = instance.module.name\n    project_name = instance.module.project.name\n    testcase_dir_path = os.path.join(testcase_dir_path, project_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n        debugtalk_obj = Projects.objects.get(name=project_name).debugtalk\n        if debugtalk_obj:\n            debugtalk = debugtalk_obj.debugtalk\n        else:\n            debugtalk = ''\n        with open(os.path.join(testcase_dir_path, 'debugtalk.py'), mode='w', encoding='utf-8') as one_file:\n            one_file.write(debugtalk)\n    testcase_dir_path = os.path.join(testcase_dir_path, module_name)\n    if not os.path.exists(testcase_dir_path):\n        os.makedirs(testcase_dir_path)\n    if 'testcases' in include:\n        for t_id in include.get('testcases'):\n            testcase_obj = Testcases.objects.filter(id=t_id).first()\n            if testcase_obj:\n                try:\n                    testcase_request = json.loads(testcase_obj.request, encoding='utf-8')\n                except Exception as e:\n                    logger.error(e)\n                    continue\n                else:\n                    extract = testcase_request['test'].get('extract')\n                    if extract:\n                        _iter93 = extract\n                        while True:\n                            try:\n                                e = next(_iter93)\n                            except StopIteration:\n                                break\n                            testcases_list[0]['config']['variables'].append({[i for i in e.keys()][0]: ''})\n                    testcase_request['test'] = OrderedDict(testcase_request['test'])\n                    testcases_list.append(OrderedDict(testcase_request))\n    request['test'] = OrderedDict(request['test'])\n    testcases_list.append(request)\n    with open(os.path.join(testcase_dir_path, instance.name + '.yml'), mode='w', encoding='utf-8') as one_file:\n"]]}
{"hexsha": "70836ca1748caea3d326c0101f9ea4804dc8b95e", "ext": "py", "lang": "Python", "content": "def save_3D_animation(embeddings, emb_space_sizes, train_losses, test_losses, opt_name, n_bins=10, horizon_size=10, cmap_name='jet', **plotting_kwargs):\n    \"\"\"Utility function for visualizing the changes in weights over time in\n    UMAP space. The visualization is in 3D for better appreciating the descent\n    on the error surface.\n\n        Args:\n            - embeddings: list of embeddings, result of alligned UMAP\n            - emb_space_sizes: list of arrays, define the limits of the\n                embedding space for the three layers of the MLP.\n            - train_losses: list, training losses history.\n            - test_losses: list, test losses.\n            - opt_name: string, name of the optimizer used.\n            - n_bins: int, number of bins for discretizing the training loss.\n            -  horizon_size: int, maximum number of points simultaneously\n                on screen.\n            - cmap_name: string, name of the colormap used for representing\n                the change in train losses.\n            - **plotting_kwargs: keyword arguments, keyword arguments for the\n                plotting function.\n\n        Returns:\n            - None\n    \"\"\"\n    discretizer = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy='uniform')\n    cmap = matplotlib.cm.get_cmap(cmap_name)\n    colors = np.array(train_losses)\n    colors = discretizer.fit_transform(colors.reshape(-1, 1)).flatten()\n    norm = plt.Normalize(colors.min(), colors.max())\n    _iter94 = tqdm(range(embeddings[0].shape[0]))\n    while True:\n        try:\n            i = next(_iter94)\n        except StopIteration:\n            break\n        fig, axs = plt.subplots(1, 3, figsize=(30, 10), subplot_kw=dict(projection='3d'))\n        for index, emb in enumerate(embeddings):\n            min_sizes, max_sizes = emb_space_sizes[index]\n            past_horizon = max(0, i - horizon_size)\n            axs[index].scatter(emb[past_horizon:i, 0], emb[past_horizon:i, 1], train_losses[past_horizon:i], c=[cmap(norm(color)) for color in colors[past_horizon:i]], **plotting_kwargs)\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=train_losses[past_horizon:i], c='grey', zdir='y', zs=max_sizes[1], linewidth=5, alpha=0.25)\n            axs[index].plot(xs=emb[past_horizon:i, 1], ys=train_losses[past_horizon:i], c='grey', zdir='x', linewidth=5, alpha=0.25, zs=min_sizes[0])\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=emb[past_horizon:i, 1], c='grey', zdir='z', linewidth=5, alpha=0.25, zs=min_sizes[2])\n            axs[index].text2D(0.05, 0.95, f'Layer {index + 1}', transform=axs[index].transAxes)\n            if index == 1:\n                axs[index].text2D(0.5, 1.1, f'Optimizer: {opt_name}                     \\nTrain Loss: {round(train_losses[i], 3)}                     \\n Test Loss: {round(test_losses[i], 3)}', transform=axs[index].transAxes)\n            elif index == 2:\n                axs[index].set_xlabel('Weights Space \\n UMAP 1')\n                axs[index].set_ylabel('Weights Space \\n UMAP 2')\n                axs[index].set_zlabel('Trainining Loss')\n        if not os.path.exists(f'results\\\\3D_{opt_name}'):\n            os.makedirs(f'results\\\\3D_{opt_name}')\n        plt.savefig(f'results\\\\3D_{opt_name}\\\\{i}.png', bbox_inches='tight')\n        plt.close('all')\n    return None", "fn_id": 0, "class_fn": false, "repo": "vb690/machine_learning_exercises", "file": "shops/visualize_gradient_descent/utilities/viz_utils.py", "last_update_at": "2021-04-26T19:06:06+00:00", "original_content": "def save_3D_animation(embeddings, emb_space_sizes, train_losses, test_losses, opt_name, n_bins=10, horizon_size=10, cmap_name='jet', **plotting_kwargs):\n    \"\"\"Utility function for visualizing the changes in weights over time in\n    UMAP space. The visualization is in 3D for better appreciating the descent\n    on the error surface.\n\n        Args:\n            - embeddings: list of embeddings, result of alligned UMAP\n            - emb_space_sizes: list of arrays, define the limits of the\n                embedding space for the three layers of the MLP.\n            - train_losses: list, training losses history.\n            - test_losses: list, test losses.\n            - opt_name: string, name of the optimizer used.\n            - n_bins: int, number of bins for discretizing the training loss.\n            -  horizon_size: int, maximum number of points simultaneously\n                on screen.\n            - cmap_name: string, name of the colormap used for representing\n                the change in train losses.\n            - **plotting_kwargs: keyword arguments, keyword arguments for the\n                plotting function.\n\n        Returns:\n            - None\n    \"\"\"\n    discretizer = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy='uniform')\n    cmap = matplotlib.cm.get_cmap(cmap_name)\n    colors = np.array(train_losses)\n    colors = discretizer.fit_transform(colors.reshape(-1, 1)).flatten()\n    norm = plt.Normalize(colors.min(), colors.max())\n    for i in tqdm(range(embeddings[0].shape[0])):\n        fig, axs = plt.subplots(1, 3, figsize=(30, 10), subplot_kw=dict(projection='3d'))\n        for index, emb in enumerate(embeddings):\n            min_sizes, max_sizes = emb_space_sizes[index]\n            past_horizon = max(0, i - horizon_size)\n            axs[index].scatter(emb[past_horizon:i, 0], emb[past_horizon:i, 1], train_losses[past_horizon:i], c=[cmap(norm(color)) for color in colors[past_horizon:i]], **plotting_kwargs)\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=train_losses[past_horizon:i], c='grey', zdir='y', zs=max_sizes[1], linewidth=5, alpha=0.25)\n            axs[index].plot(xs=emb[past_horizon:i, 1], ys=train_losses[past_horizon:i], c='grey', zdir='x', linewidth=5, alpha=0.25, zs=min_sizes[0])\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=emb[past_horizon:i, 1], c='grey', zdir='z', linewidth=5, alpha=0.25, zs=min_sizes[2])\n            axs[index].text2D(0.05, 0.95, f'Layer {index + 1}', transform=axs[index].transAxes)\n            if index == 1:\n                axs[index].text2D(0.5, 1.1, f'Optimizer: {opt_name}                     \\nTrain Loss: {round(train_losses[i], 3)}                     \\n Test Loss: {round(test_losses[i], 3)}', transform=axs[index].transAxes)\n            elif index == 2:\n                axs[index].set_xlabel('Weights Space \\n UMAP 1')\n                axs[index].set_ylabel('Weights Space \\n UMAP 2')\n                axs[index].set_zlabel('Trainining Loss')\n        if not os.path.exists(f'results\\\\3D_{opt_name}'):\n            os.makedirs(f'results\\\\3D_{opt_name}')\n        plt.savefig(f'results\\\\3D_{opt_name}\\\\{i}.png', bbox_inches='tight')\n        plt.close('all')\n    return None", "refactored": true, "question_id": "70836ca1748caea3d326c0101f9ea4804dc8b95e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def save_3D_animation(embeddings, emb_space_sizes, train_losses, test_losses, opt_name, n_bins=10, horizon_size=10, cmap_name='jet', **plotting_kwargs):\n    \"\"\"Utility function for visualizing the changes in weights over time in\n    UMAP space. The visualization is in 3D for better appreciating the descent\n    on the error surface.\n        Args:\n            - embeddings: list of embeddings, result of alligned UMAP\n            - emb_space_sizes: list of arrays, define the limits of the\n                embedding space for the three layers of the MLP.\n            - train_losses: list, training losses history.\n            - test_losses: list, test losses.\n            - opt_name: string, name of the optimizer used.\n            - n_bins: int, number of bins for discretizing the training loss.\n            -  horizon_size: int, maximum number of points simultaneously\n                on screen.\n            - cmap_name: string, name of the colormap used for representing\n                the change in train losses.\n            - **plotting_kwargs: keyword arguments, keyword arguments for the\n                plotting function.\n        Returns:\n            - None\n    \"\"\"\n    discretizer = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy='uniform')\n    cmap = matplotlib.cm.get_cmap(cmap_name)\n    colors = np.array(train_losses)\n    colors = discretizer.fit_transform(colors.reshape(-1, 1)).flatten()\n    norm = plt.Normalize(colors.min(), colors.max())\n    _iter94 = tqdm(range(embeddings[0].shape[0]))\n    while True:\n        try:\n            i = next(_iter94)\n        except StopIteration:\n            break\n        fig, axs = plt.subplots(1, 3, figsize=(30, 10), subplot_kw=dict(projection='3d'))\n        for index, emb in enumerate(embeddings):\n            min_sizes, max_sizes = emb_space_sizes[index]\n            past_horizon = max(0, i - horizon_size)\n            axs[index].scatter(emb[past_horizon:i, 0], emb[past_horizon:i, 1], train_losses[past_horizon:i], c=[cmap(norm(color)) for color in colors[past_horizon:i]], **plotting_kwargs)\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=train_losses[past_horizon:i], c='grey', zdir='y', zs=max_sizes[1], linewidth=5, alpha=0.25)\n            axs[index].plot(xs=emb[past_horizon:i, 1], ys=train_losses[past_horizon:i], c='grey', zdir='x', linewidth=5, alpha=0.25, zs=min_sizes[0])\n            axs[index].plot(xs=emb[past_horizon:i, 0], ys=emb[past_horizon:i, 1], c='grey', zdir='z', linewidth=5, alpha=0.25, zs=min_sizes[2])\n            axs[index].text2D(0.05, 0.95, f'Layer {index + 1}', transform=axs[index].transAxes)\n            if index == 1:\n                axs[index].text2D(0.5, 1.1, f'Optimizer: {opt_name}                     \\nTrain Loss: {round(train_losses[i], 3)}                     \\n Test Loss: {round(test_losses[i], 3)}', transform=axs[index].transAxes)\n            elif index == 2:\n                axs[index].set_xlabel('Weights Space \\n UMAP 1')\n                axs[index].set_ylabel('Weights Space \\n UMAP 2')\n                axs[index].set_zlabel('Trainining Loss')\n        if not os.path.exists(f'results\\\\3D_{opt_name}'):\n            os.makedirs(f'results\\\\3D_{opt_name}')\n        plt.savefig(f'results\\\\3D_{opt_name}\\\\{i}.png', bbox_inches='tight')\n        plt.close('all')\n"]]}
{"hexsha": "7d2d407dbcaa652ae9d9750427e051162ad2d2e3", "ext": "py", "lang": "Python", "content": "def pattern_loader(path_to_rules='patterns.jsonl') -> List:\n    \"\"\" Loads the patterns from the pattern list. \"\"\"\n    patterns = []\n    patternDicts = []\n    with open(path_to_rules, encoding='utf8') as f:\n        try:\n            for line in f:\n                data = json.loads(line)\n                patternDicts.append(data)\n        except:\n            pass\n    _iter95 = patternDicts\n    while True:\n        try:\n            patternDict = next(_iter95)\n        except StopIteration:\n            break\n        patterns.append(Pattern(**patternDict))\n    return patterns", "fn_id": 5, "class_fn": false, "repo": "ChrisChross/turCy", "file": "turcy/tree_dep_pattern.py", "last_update_at": "2021-04-15T12:29:32+00:00", "original_content": "def pattern_loader(path_to_rules='patterns.jsonl') -> List:\n    \"\"\" Loads the patterns from the pattern list. \"\"\"\n    patterns = []\n    patternDicts = []\n    with open(path_to_rules, encoding='utf8') as f:\n        try:\n            for line in f:\n                data = json.loads(line)\n                patternDicts.append(data)\n        except:\n            pass\n    for patternDict in patternDicts:\n        patterns.append(Pattern(**patternDict))\n    return patterns", "refactored": true, "question_id": "7d2d407dbcaa652ae9d9750427e051162ad2d2e3_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def pattern_loader(path_to_rules='patterns.jsonl') -> List:\n    \"\"\" Loads the patterns from the pattern list. \"\"\"\n    patterns = []\n    patternDicts = []\n    with open(path_to_rules, encoding='utf8') as f:\n        try:\n            for line in f:\n                data = json.loads(line)\n                patternDicts.append(data)\n        except:\n            pass\n    _iter95 = patternDicts\n    while True:\n        try:\n            patternDict = next(_iter95)\n        except StopIteration:\n            break\n        patterns.append(Pattern(**patternDict))\n"]]}
{"hexsha": "5b2a8ea69b3198b3f678cebb3485c95da3b6d811", "ext": "py", "lang": "Python", "content": "def _graph_from_dict(P, weights=False):\n    G = pairDiGraph()\n    _iter96 = P.items()\n    while True:\n        try:\n            (a, b), n = next(_iter96)\n        except StopIteration:\n            break\n        if weights:\n            G.add_edge(a, b, weight=n)\n        else:\n            G.add_edge(a, b)\n    if weights:\n        G.addPd()\n    return G", "fn_id": 2, "class_fn": false, "repo": "jpgil/logdelay", "file": "src/theory202105.py", "last_update_at": "2021-05-28T16:03:39+00:00", "original_content": "def _graph_from_dict(P, weights=False):\n    G = pairDiGraph()\n    for (a, b), n in P.items():\n        if weights:\n            G.add_edge(a, b, weight=n)\n        else:\n            G.add_edge(a, b)\n    if weights:\n        G.addPd()\n    return G", "refactored": true, "question_id": "5b2a8ea69b3198b3f678cebb3485c95da3b6d811_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _graph_from_dict(P, weights=False):\n    G = pairDiGraph()\n    _iter96 = P.items()\n    while True:\n        try:\n            (a, b), n = next(_iter96)\n        except StopIteration:\n            break\n        if weights:\n            G.add_edge(a, b, weight=n)\n        else:\n            G.add_edge(a, b)\n    if weights:\n        G.addPd()\n"]]}
{"hexsha": "10e63bec5b7e172368421e76129581befebd5bc0", "ext": "py", "lang": "Python", "content": "def part_sum(bitlist, indices):\n    \"\"\"Compute the mod 2 sum of the subset of bits in bitlist given by the list of indices.\"\"\"\n    sum = 0\n    _iter97 = indices\n    while True:\n        try:\n            x = next(_iter97)\n        except StopIteration:\n            break\n        sum = sum ^ bitlist[x]\n    return sum", "fn_id": 6, "class_fn": false, "repo": "wmkirby1/CS-VQE", "file": "misc/legacy/fermions/yaferp/general/fermions.py", "last_update_at": "2021-11-10T18:03:49+00:00", "original_content": "def part_sum(bitlist, indices):\n    \"\"\"Compute the mod 2 sum of the subset of bits in bitlist given by the list of indices.\"\"\"\n    sum = 0\n    for x in indices:\n        sum = sum ^ bitlist[x]\n    return sum", "refactored": true, "question_id": "10e63bec5b7e172368421e76129581befebd5bc0_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def part_sum(bitlist, indices):\n    \"\"\"Compute the mod 2 sum of the subset of bits in bitlist given by the list of indices.\"\"\"\n    sum = 0\n    _iter97 = indices\n    while True:\n        try:\n            x = next(_iter97)\n        except StopIteration:\n            break\n        sum = sum ^ bitlist[x]\n"]]}
{"hexsha": "7cfa76a0e321448c9b715a43fe2ae910c799972c", "ext": "py", "lang": "Python", "content": "def make_summary_file(filename):\n    \"\"\"\n    Given a DLIS file, make a short human readable summary of it.\n    Show things like headers, well parameters and which well curves are\n    available.\n\n    Args:\n    filename: A DLIS file.\n\n    Returns:\n    summaryfile: The DLIS file without the extention and the suffix\n    _summary.txt.\n    \"\"\"\n    summaryfile = open(filename.replace('.DLIS', '_summary.txt'), 'w')\n    f, *f_tail = dlis.load(filename)\n    if len(f_tail):\n        print('There are more logical files in tail')\n    origin, *origin_tail = f.origins\n    if len(origin_tail):\n        print(filename + ' contains multiple origins')\n    header = f.fileheader\n    parameter_table = summarize(f.parameters, name='Name', long_name='Long name', values='Value(s)')\n    mask = ~parameter_table['Name'].isin(['R8', 'RR1', 'WITN', 'ENGI'])\n    parameter_table = parameter_table[mask]\n    parameter_table.sort_values('Name')\n    summaryfile.write(str(f.describe()))\n    summaryfile.write(str(origin.describe()))\n    summaryfile.write(str(header.describe()))\n    summaryfile.write(str(parameter_table))\n    _iter98 = f.frames\n    while True:\n        try:\n            frame = next(_iter98)\n        except StopIteration:\n            break\n        index_channel = next((ch for ch in frame.channels if ch.name == frame.index))\n        summaryfile.write(f'\\nFrame {frame.name}:\\n')\n        summaryfile.write(f'Description      : {frame.description}\\n')\n        summaryfile.write(f'Indexed by       : {frame.index_type}\\n')\n        summaryfile.write(f'Interval         : [{frame.index_min}, {frame.index_max}] {index_channel.units}\\n')\n        summaryfile.write(f'Direction        : {frame.direction}\\n')\n        summaryfile.write(f'Constant spacing : {frame.spacing} {index_channel.units}\\n')\n        summaryfile.write(f'Index channel    : {index_channel}\\n')\n        summaryfile.write(f'No. of channels  : {len(frame.channels)}\\n')\n    channel_table = summarize(f.channels, name='Name', long_name='Long name', units='Units', dimension='Dimension', frame='Frame')\n    channel_table.sort_values('Name')\n    summaryfile.write(str(channel_table))\n    summaryfile.close()\n    return summaryfile", "fn_id": 1, "class_fn": false, "repo": "softwareunderground/northern-lights", "file": "scripts/dlis_summary.py", "last_update_at": "2021-04-17T09:13:20+00:00", "original_content": "def make_summary_file(filename):\n    \"\"\"\n    Given a DLIS file, make a short human readable summary of it.\n    Show things like headers, well parameters and which well curves are\n    available.\n\n    Args:\n    filename: A DLIS file.\n\n    Returns:\n    summaryfile: The DLIS file without the extention and the suffix\n    _summary.txt.\n    \"\"\"\n    summaryfile = open(filename.replace('.DLIS', '_summary.txt'), 'w')\n    f, *f_tail = dlis.load(filename)\n    if len(f_tail):\n        print('There are more logical files in tail')\n    origin, *origin_tail = f.origins\n    if len(origin_tail):\n        print(filename + ' contains multiple origins')\n    header = f.fileheader\n    parameter_table = summarize(f.parameters, name='Name', long_name='Long name', values='Value(s)')\n    mask = ~parameter_table['Name'].isin(['R8', 'RR1', 'WITN', 'ENGI'])\n    parameter_table = parameter_table[mask]\n    parameter_table.sort_values('Name')\n    summaryfile.write(str(f.describe()))\n    summaryfile.write(str(origin.describe()))\n    summaryfile.write(str(header.describe()))\n    summaryfile.write(str(parameter_table))\n    for frame in f.frames:\n        index_channel = next((ch for ch in frame.channels if ch.name == frame.index))\n        summaryfile.write(f'\\nFrame {frame.name}:\\n')\n        summaryfile.write(f'Description      : {frame.description}\\n')\n        summaryfile.write(f'Indexed by       : {frame.index_type}\\n')\n        summaryfile.write(f'Interval         : [{frame.index_min}, {frame.index_max}] {index_channel.units}\\n')\n        summaryfile.write(f'Direction        : {frame.direction}\\n')\n        summaryfile.write(f'Constant spacing : {frame.spacing} {index_channel.units}\\n')\n        summaryfile.write(f'Index channel    : {index_channel}\\n')\n        summaryfile.write(f'No. of channels  : {len(frame.channels)}\\n')\n    channel_table = summarize(f.channels, name='Name', long_name='Long name', units='Units', dimension='Dimension', frame='Frame')\n    channel_table.sort_values('Name')\n    summaryfile.write(str(channel_table))\n    summaryfile.close()\n    return summaryfile", "refactored": true, "question_id": "7cfa76a0e321448c9b715a43fe2ae910c799972c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def make_summary_file(filename):\n    \"\"\"\n    Given a DLIS file, make a short human readable summary of it.\n    Show things like headers, well parameters and which well curves are\n    available.\n    Args:\n    filename: A DLIS file.\n    Returns:\n    summaryfile: The DLIS file without the extention and the suffix\n    _summary.txt.\n    \"\"\"\n    summaryfile = open(filename.replace('.DLIS', '_summary.txt'), 'w')\n    f, *f_tail = dlis.load(filename)\n    if len(f_tail):\n        print('There are more logical files in tail')\n    origin, *origin_tail = f.origins\n    if len(origin_tail):\n        print(filename + ' contains multiple origins')\n    header = f.fileheader\n    parameter_table = summarize(f.parameters, name='Name', long_name='Long name', values='Value(s)')\n    mask = ~parameter_table['Name'].isin(['R8', 'RR1', 'WITN', 'ENGI'])\n    parameter_table = parameter_table[mask]\n    parameter_table.sort_values('Name')\n    summaryfile.write(str(f.describe()))\n    summaryfile.write(str(origin.describe()))\n    summaryfile.write(str(header.describe()))\n    summaryfile.write(str(parameter_table))\n    _iter98 = f.frames\n    while True:\n        try:\n            frame = next(_iter98)\n        except StopIteration:\n            break\n        index_channel = next((ch for ch in frame.channels if ch.name == frame.index))\n        summaryfile.write(f'\\nFrame {frame.name}:\\n')\n        summaryfile.write(f'Description      : {frame.description}\\n')\n        summaryfile.write(f'Indexed by       : {frame.index_type}\\n')\n        summaryfile.write(f'Interval         : [{frame.index_min}, {frame.index_max}] {index_channel.units}\\n')\n        summaryfile.write(f'Direction        : {frame.direction}\\n')\n        summaryfile.write(f'Constant spacing : {frame.spacing} {index_channel.units}\\n')\n        summaryfile.write(f'Index channel    : {index_channel}\\n')\n        summaryfile.write(f'No. of channels  : {len(frame.channels)}\\n')\n    channel_table = summarize(f.channels, name='Name', long_name='Long name', units='Units', dimension='Dimension', frame='Frame')\n    channel_table.sort_values('Name')\n    summaryfile.write(str(channel_table))\n    summaryfile.close()\n"]]}
{"hexsha": "a2ffeaa240b71382db18bba9227270f5573e50fb", "ext": "py", "lang": "Python", "content": "@Transform_Wrapper()\ndef Annotate_Script_Names(empty_diffs=0):\n    \"\"\"\n    For every ai script, annotate the pilot entity with the name\n    of the script running.\n    \"\"\"\n    aiscript_files = Load_Files('aiscripts/*.xml')\n    for game_file in aiscript_files:\n        xml_root = game_file.Get_Root()\n        changed = False\n        _iter99 = ['dock_masstraffic_drone', 'execute_custom_trade', 'execute_trade', 'move_approach_path', 'move_docking', 'move_undocking', 'move_gate', 'move_navmesh', 'move_strafe', 'move_target_points', 'move_waypoints', 'move_to', 'detach_from_masstraffic', 'wait_for_prev_script', 'wait']\n        while True:\n            try:\n                tag = next(_iter99)\n            except StopIteration:\n                break\n            nodes = xml_root.xpath('.//{}'.format(tag))\n            if not nodes:\n                continue\n            changed = True\n            if empty_diffs:\n                continue\n            for node in nodes:\n                script_name = etree.Element('set_value', name='this.$script_name', exact=\"'{}'\".format(game_file.name.replace('.xml', '')))\n                node.addprevious(script_name)\n                element_name = etree.Element('set_value', name='this.$element_name', exact=\"'{}'\".format(tag))\n                node.addprevious(element_name)\n                if node.sourceline:\n                    name_line = \"'${} {}'\".format(game_file.name.replace('.xml', ''), node.sourceline)\n                    script_line_node = etree.Element('set_value', name='this.$script_line_name', exact=name_line)\n                    node.addprevious(script_line_node)\n                    record_group = [etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts?\">\\n                              <set_value name=\"this.$script_line_counts\" exact=\"table[]\"/>\\n                            </do_if>'), etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts.{FIELD}?\">\\n                              <set_value name=\"this.$script_line_counts.{FIELD}\" exact=\"0.0\"/>\\n                            </do_if>'.replace('FIELD', name_line)), etree.fromstring('\\n                            <set_value name=\"this.$script_line_counts.{FIELD}\" operation=\"add\"/>'.replace('FIELD', name_line))]\n                    for record_node in record_group:\n                        node.addprevious(record_node)\n        if changed:\n            game_file.Update_Root(xml_root)\n    return", "fn_id": 1, "class_fn": false, "repo": "abouquet/x4-projects", "file": "extensions/sn_measure_perf/Customizer_Script.py", "last_update_at": "2021-03-17T13:54:15+00:00", "original_content": "@Transform_Wrapper()\ndef Annotate_Script_Names(empty_diffs=0):\n    \"\"\"\n    For every ai script, annotate the pilot entity with the name\n    of the script running.\n    \"\"\"\n    aiscript_files = Load_Files('aiscripts/*.xml')\n    for game_file in aiscript_files:\n        xml_root = game_file.Get_Root()\n        changed = False\n        for tag in ['dock_masstraffic_drone', 'execute_custom_trade', 'execute_trade', 'move_approach_path', 'move_docking', 'move_undocking', 'move_gate', 'move_navmesh', 'move_strafe', 'move_target_points', 'move_waypoints', 'move_to', 'detach_from_masstraffic', 'wait_for_prev_script', 'wait']:\n            nodes = xml_root.xpath('.//{}'.format(tag))\n            if not nodes:\n                continue\n            changed = True\n            if empty_diffs:\n                continue\n            for node in nodes:\n                script_name = etree.Element('set_value', name='this.$script_name', exact=\"'{}'\".format(game_file.name.replace('.xml', '')))\n                node.addprevious(script_name)\n                element_name = etree.Element('set_value', name='this.$element_name', exact=\"'{}'\".format(tag))\n                node.addprevious(element_name)\n                if node.sourceline:\n                    name_line = \"'${} {}'\".format(game_file.name.replace('.xml', ''), node.sourceline)\n                    script_line_node = etree.Element('set_value', name='this.$script_line_name', exact=name_line)\n                    node.addprevious(script_line_node)\n                    record_group = [etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts?\">\\n                              <set_value name=\"this.$script_line_counts\" exact=\"table[]\"/>\\n                            </do_if>'), etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts.{FIELD}?\">\\n                              <set_value name=\"this.$script_line_counts.{FIELD}\" exact=\"0.0\"/>\\n                            </do_if>'.replace('FIELD', name_line)), etree.fromstring('\\n                            <set_value name=\"this.$script_line_counts.{FIELD}\" operation=\"add\"/>'.replace('FIELD', name_line))]\n                    for record_node in record_group:\n                        node.addprevious(record_node)\n        if changed:\n            game_file.Update_Root(xml_root)\n    return", "refactored": true, "question_id": "a2ffeaa240b71382db18bba9227270f5573e50fb_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@Transform_Wrapper()\ndef Annotate_Script_Names(empty_diffs=0):\n    \"\"\"\n    For every ai script, annotate the pilot entity with the name\n    of the script running.\n    \"\"\"\n    aiscript_files = Load_Files('aiscripts/*.xml')\n    for game_file in aiscript_files:\n        xml_root = game_file.Get_Root()\n        changed = False\n        _iter99 = ['dock_masstraffic_drone', 'execute_custom_trade', 'execute_trade', 'move_approach_path', 'move_docking', 'move_undocking', 'move_gate', 'move_navmesh', 'move_strafe', 'move_target_points', 'move_waypoints', 'move_to', 'detach_from_masstraffic', 'wait_for_prev_script', 'wait']\n        while True:\n            try:\n                tag = next(_iter99)\n            except StopIteration:\n                break\n            nodes = xml_root.xpath('.//{}'.format(tag))\n            if not nodes:\n                continue\n            changed = True\n            if empty_diffs:\n                continue\n            for node in nodes:\n                script_name = etree.Element('set_value', name='this.$script_name', exact=\"'{}'\".format(game_file.name.replace('.xml', '')))\n                node.addprevious(script_name)\n                element_name = etree.Element('set_value', name='this.$element_name', exact=\"'{}'\".format(tag))\n                node.addprevious(element_name)\n                if node.sourceline:\n                    name_line = \"'${} {}'\".format(game_file.name.replace('.xml', ''), node.sourceline)\n                    script_line_node = etree.Element('set_value', name='this.$script_line_name', exact=name_line)\n                    node.addprevious(script_line_node)\n                    record_group = [etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts?\">\\n                              <set_value name=\"this.$script_line_counts\" exact=\"table[]\"/>\\n                            </do_if>'), etree.fromstring('\\n                            <do_if value=\"not this.$script_line_counts.{FIELD}?\">\\n                              <set_value name=\"this.$script_line_counts.{FIELD}\" exact=\"0.0\"/>\\n                            </do_if>'.replace('FIELD', name_line)), etree.fromstring('\\n                            <set_value name=\"this.$script_line_counts.{FIELD}\" operation=\"add\"/>'.replace('FIELD', name_line))]\n                    for record_node in record_group:\n                        node.addprevious(record_node)\n        if changed:\n            game_file.Update_Root(xml_root)\n"]]}
{"hexsha": "07fe364d937fe8b983df03d9c0471b986fbd990b", "ext": "py", "lang": "Python", "content": "def _add_workload_inner():\n    OpArgMngr.add_workload('inner', np.zeros(shape=(1, 80), dtype=np.float64), np.zeros(shape=(1, 80), dtype=np.float64))\n    _iter100 = [np.float32, np.float64]\n    while True:\n        try:\n            dt = next(_iter100)\n        except StopIteration:\n            break\n        A = np.array([[1, 2], [3, 4]], dtype=dt)\n        B = np.array([[1, 3], [2, 4]], dtype=dt)\n        C = np.array([1, 1], dtype=dt)\n        OpArgMngr.add_workload('inner', A.T, C)\n        OpArgMngr.add_workload('inner', C, A.T)\n        OpArgMngr.add_workload('inner', B, C)\n        OpArgMngr.add_workload('inner', C, B)\n        OpArgMngr.add_workload('inner', A, B)\n        OpArgMngr.add_workload('inner', A, A)\n        OpArgMngr.add_workload('inner', A, A.copy())\n        a = np.arange(5).astype(dt)\n        b = a[::-1]\n        OpArgMngr.add_workload('inner', b, a)\n        a = np.arange(24).reshape(2, 3, 4).astype(dt)\n        b = np.arange(24, 48).reshape(2, 3, 4).astype(dt)\n        OpArgMngr.add_workload('inner', a, b)\n        OpArgMngr.add_workload('inner', b, a)", "fn_id": 74, "class_fn": false, "repo": "sxjscience/mxnet", "file": "tests/python/unittest/test_numpy_interoperability.py", "last_update_at": "2021-03-23T03:07:38+00:00", "original_content": "def _add_workload_inner():\n    OpArgMngr.add_workload('inner', np.zeros(shape=(1, 80), dtype=np.float64), np.zeros(shape=(1, 80), dtype=np.float64))\n    for dt in [np.float32, np.float64]:\n        A = np.array([[1, 2], [3, 4]], dtype=dt)\n        B = np.array([[1, 3], [2, 4]], dtype=dt)\n        C = np.array([1, 1], dtype=dt)\n        OpArgMngr.add_workload('inner', A.T, C)\n        OpArgMngr.add_workload('inner', C, A.T)\n        OpArgMngr.add_workload('inner', B, C)\n        OpArgMngr.add_workload('inner', C, B)\n        OpArgMngr.add_workload('inner', A, B)\n        OpArgMngr.add_workload('inner', A, A)\n        OpArgMngr.add_workload('inner', A, A.copy())\n        a = np.arange(5).astype(dt)\n        b = a[::-1]\n        OpArgMngr.add_workload('inner', b, a)\n        a = np.arange(24).reshape(2, 3, 4).astype(dt)\n        b = np.arange(24, 48).reshape(2, 3, 4).astype(dt)\n        OpArgMngr.add_workload('inner', a, b)\n        OpArgMngr.add_workload('inner', b, a)", "refactored": true, "question_id": "07fe364d937fe8b983df03d9c0471b986fbd990b_74", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _add_workload_inner():\n    OpArgMngr.add_workload('inner', np.zeros(shape=(1, 80), dtype=np.float64), np.zeros(shape=(1, 80), dtype=np.float64))\n    _iter100 = [np.float32, np.float64]\n    while True:\n        try:\n            dt = next(_iter100)\n        except StopIteration:\n            break\n        A = np.array([[1, 2], [3, 4]], dtype=dt)\n        B = np.array([[1, 3], [2, 4]], dtype=dt)\n        C = np.array([1, 1], dtype=dt)\n        OpArgMngr.add_workload('inner', A.T, C)\n        OpArgMngr.add_workload('inner', C, A.T)\n        OpArgMngr.add_workload('inner', B, C)\n        OpArgMngr.add_workload('inner', C, B)\n        OpArgMngr.add_workload('inner', A, B)\n        OpArgMngr.add_workload('inner', A, A)\n        OpArgMngr.add_workload('inner', A, A.copy())\n        a = np.arange(5).astype(dt)\n        b = a[::-1]\n        OpArgMngr.add_workload('inner', b, a)\n        a = np.arange(24).reshape(2, 3, 4).astype(dt)\n        b = np.arange(24, 48).reshape(2, 3, 4).astype(dt)\n        OpArgMngr.add_workload('inner', a, b)\n"]]}
{"hexsha": "7a6ac05f5c406402bdf62d0f733ffe486364b813", "ext": "py", "lang": "Python", "content": "def speak_rank_top_10():\n    sql = '\\n        select * \\n        from(select row_number() over(order by user_speak_total desc) as row_number,* from user_info)\\n        where row_number <= 10\\n    '\n    data = sql_dql(sql)\n    msg = f'\ud83d\ude48\u53d1\u8a00\u5149\u8363\u699c\ud83d\ude48\\n__________________\\n'\n    _iter101 = data\n    while True:\n        try:\n            item = next(_iter101)\n        except StopIteration:\n            break\n        rank = item[0]\n        name = item[1]\n        id = item[2]\n        num = item[3]\n        num_emoji = rank_emoji(rank)\n        msg += f'{num_emoji}{name}({id})\ud83d\udde3\ufe0f:{num}\\n'\n    msg += f'\u8fd9\u4e9b\ud83d\udc68\u90fd4\ufe0f\u20e3\u5927\ud83d\udca6\ud83d\udc7e'\n    return msg", "fn_id": 2, "class_fn": false, "repo": "Twip-Emma/QQbot-Twip", "file": "bot_plugins/user/user_speaki_rank/__init__.py", "last_update_at": "2021-12-23T15:36:48+00:00", "original_content": "def speak_rank_top_10():\n    sql = '\\n        select * \\n        from(select row_number() over(order by user_speak_total desc) as row_number,* from user_info)\\n        where row_number <= 10\\n    '\n    data = sql_dql(sql)\n    msg = f'\ud83d\ude48\u53d1\u8a00\u5149\u8363\u699c\ud83d\ude48\\n__________________\\n'\n    for item in data:\n        rank = item[0]\n        name = item[1]\n        id = item[2]\n        num = item[3]\n        num_emoji = rank_emoji(rank)\n        msg += f'{num_emoji}{name}({id})\ud83d\udde3\ufe0f:{num}\\n'\n    msg += f'\u8fd9\u4e9b\ud83d\udc68\u90fd4\ufe0f\u20e3\u5927\ud83d\udca6\ud83d\udc7e'\n    return msg", "refactored": true, "question_id": "7a6ac05f5c406402bdf62d0f733ffe486364b813_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def speak_rank_top_10():\n    sql = '\\n        select * \\n        from(select row_number() over(order by user_speak_total desc) as row_number,* from user_info)\\n        where row_number <= 10\\n    '\n    data = sql_dql(sql)\n    msg = f'\ud83d\ude48\u53d1\u8a00\u5149\u8363\u699c\ud83d\ude48\\n__________________\\n'\n    _iter101 = data\n    while True:\n        try:\n            item = next(_iter101)\n        except StopIteration:\n            break\n        rank = item[0]\n        name = item[1]\n        id = item[2]\n        num = item[3]\n        num_emoji = rank_emoji(rank)\n        msg += f'{num_emoji}{name}({id})\ud83d\udde3\ufe0f:{num}\\n'\n    msg += f'\u8fd9\u4e9b\ud83d\udc68\u90fd4\ufe0f\u20e3\u5927\ud83d\udca6\ud83d\udc7e'\n"]]}
{"hexsha": "79b07cf6f3f380f296c7ce80ec1c84c5aa0ae81e", "ext": "py", "lang": "Python", "content": "def deep_seq_design():\n    root_dir = f'data/design/cullpdb_val_deep/{exp_flag}anneal_val_deep'\n    mut_matrix_anneal = np.zeros((20, 20))\n    native_aa_all = []\n    design_aa_all = []\n    seq_len = []\n    recovery = []\n    pdb_id_all = []\n    recovery_res = np.zeros(20)\n    count_res = np.zeros(20)\n    num = 100\n    for pdb_id in pdb_selected:\n        seq_best_all = []\n        for j in range(num):\n            data_anneal = h5py.File(f'{root_dir}/{pdb_id}_profile_{j}.h5', 'r')\n            designed_seq = data_anneal['profile'][()]\n            seq_best = designed_seq[1]\n            seq_best_all.append(seq_best)\n            seq_native = designed_seq[0]\n            recovery_fraction = np.sum(seq_best == seq_native) / float(len(seq_native))\n            recovery.append(recovery_fraction)\n            seq_len.append(len(seq_native))\n            pdb_id_all.append(pdb_id)\n            for i in range(seq_native.shape[0]):\n                mut_matrix_anneal[map_aa[seq_native[i]], map_aa[seq_best[i]]] += 1\n                native_aa_all.append(map_aa[seq_native[i]])\n                design_aa_all.append(map_aa[seq_best[i]])\n            _iter102 = range(20)\n            while True:\n                try:\n                    i = next(_iter102)\n                except StopIteration:\n                    break\n                idx = seq_native == i\n                recovery_res[i] += np.sum(seq_best[idx] == seq_native[idx])\n                count_res[i] += len(seq_native[idx])\n        with open(f'{root_dir}/{pdb_id}_seq_best.fasta', 'w') as mf:\n            s = ''.join([idx2aa[x] for x in seq_native])\n            mf.write(f'>0\\n{s}\\n')\n            for j in range(len(seq_best_all)):\n                s = ''.join([idx2aa[x] for x in seq_best_all[j]])\n                mf.write(f'>{j + 1}\\n')\n                mf.write(f'{s}\\n')\n    df = pd.DataFrame({'pdb': pdb_id_all, 'seq_len': seq_len, 'recovery': recovery})\n    df.to_csv(f'{root_dir}/recovery.csv', index=False)\n    np.save(f'data/design/cullpdb_val_deep/{exp_flag}anneal_val_deep/mut_matrix_anneal.npy', mut_matrix_anneal)\n    df = pd.DataFrame({'native_aa': native_aa_all, 'design_aa': design_aa_all})\n    df.to_csv(f'{root_dir}/native_design_aa.csv', index=False)\n    fig = pl.figure()\n    pl.plot(df['seq_len'], df['recovery'], 'bo')\n    pl.title('full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_seqlen_recovery.pdf')\n    fig = pl.figure()\n    pl.hist(df['recovery'], bins=np.arange(10) * 0.05 + 0.05)\n    pl.xlabel('native sequence recovery fraction')\n    pl.ylabel('N')\n    pl.savefig(f'{root_dir}/full_seq_design_recovery_hist.pdf')\n    fig = pl.figure()\n    pl.plot(np.arange(20), recovery_res / count_res)\n    pl.xticks(np.arange(20), labels=aa)\n    pl.title('residue recovery fraction in full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_recovery.pdf')\n    fig = pl.figure()\n    mut_matrix_anneal_freq = mut_matrix_anneal / mut_matrix_anneal.sum(axis=1)[:, None]\n    pl.imshow(mut_matrix_anneal_freq, cmap='jet')\n    pl.xlabel('mutated residue')\n    pl.ylabel('native residue')\n    pl.xticks(np.arange(20), labels=ordered_aa)\n    pl.yticks(np.arange(20), labels=ordered_aa)\n    pl.colorbar()\n    pl.title('full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_use.pdf')\n    fig = pl.figure()\n    res_all = np.concatenate(seq_best_all).flatten()\n    aa_bins = np.arange(21) - 0.5\n    pl.hist(res_all, bins=aa_bins, histtype='step')\n    pl.xticks(np.arange(20), labels=aa)\n    pl.title('residue use frequency')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_use_frequency.pdf')", "fn_id": 2, "class_fn": false, "repo": "lahplover/nnef", "file": "nnef/scripts/designed_seq.py", "last_update_at": "2021-06-30T06:47:00+00:00", "original_content": "def deep_seq_design():\n    root_dir = f'data/design/cullpdb_val_deep/{exp_flag}anneal_val_deep'\n    mut_matrix_anneal = np.zeros((20, 20))\n    native_aa_all = []\n    design_aa_all = []\n    seq_len = []\n    recovery = []\n    pdb_id_all = []\n    recovery_res = np.zeros(20)\n    count_res = np.zeros(20)\n    num = 100\n    for pdb_id in pdb_selected:\n        seq_best_all = []\n        for j in range(num):\n            data_anneal = h5py.File(f'{root_dir}/{pdb_id}_profile_{j}.h5', 'r')\n            designed_seq = data_anneal['profile'][()]\n            seq_best = designed_seq[1]\n            seq_best_all.append(seq_best)\n            seq_native = designed_seq[0]\n            recovery_fraction = np.sum(seq_best == seq_native) / float(len(seq_native))\n            recovery.append(recovery_fraction)\n            seq_len.append(len(seq_native))\n            pdb_id_all.append(pdb_id)\n            for i in range(seq_native.shape[0]):\n                mut_matrix_anneal[map_aa[seq_native[i]], map_aa[seq_best[i]]] += 1\n                native_aa_all.append(map_aa[seq_native[i]])\n                design_aa_all.append(map_aa[seq_best[i]])\n            for i in range(20):\n                idx = seq_native == i\n                recovery_res[i] += np.sum(seq_best[idx] == seq_native[idx])\n                count_res[i] += len(seq_native[idx])\n        with open(f'{root_dir}/{pdb_id}_seq_best.fasta', 'w') as mf:\n            s = ''.join([idx2aa[x] for x in seq_native])\n            mf.write(f'>0\\n{s}\\n')\n            for j in range(len(seq_best_all)):\n                s = ''.join([idx2aa[x] for x in seq_best_all[j]])\n                mf.write(f'>{j + 1}\\n')\n                mf.write(f'{s}\\n')\n    df = pd.DataFrame({'pdb': pdb_id_all, 'seq_len': seq_len, 'recovery': recovery})\n    df.to_csv(f'{root_dir}/recovery.csv', index=False)\n    np.save(f'data/design/cullpdb_val_deep/{exp_flag}anneal_val_deep/mut_matrix_anneal.npy', mut_matrix_anneal)\n    df = pd.DataFrame({'native_aa': native_aa_all, 'design_aa': design_aa_all})\n    df.to_csv(f'{root_dir}/native_design_aa.csv', index=False)\n    fig = pl.figure()\n    pl.plot(df['seq_len'], df['recovery'], 'bo')\n    pl.title('full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_seqlen_recovery.pdf')\n    fig = pl.figure()\n    pl.hist(df['recovery'], bins=np.arange(10) * 0.05 + 0.05)\n    pl.xlabel('native sequence recovery fraction')\n    pl.ylabel('N')\n    pl.savefig(f'{root_dir}/full_seq_design_recovery_hist.pdf')\n    fig = pl.figure()\n    pl.plot(np.arange(20), recovery_res / count_res)\n    pl.xticks(np.arange(20), labels=aa)\n    pl.title('residue recovery fraction in full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_recovery.pdf')\n    fig = pl.figure()\n    mut_matrix_anneal_freq = mut_matrix_anneal / mut_matrix_anneal.sum(axis=1)[:, None]\n    pl.imshow(mut_matrix_anneal_freq, cmap='jet')\n    pl.xlabel('mutated residue')\n    pl.ylabel('native residue')\n    pl.xticks(np.arange(20), labels=ordered_aa)\n    pl.yticks(np.arange(20), labels=ordered_aa)\n    pl.colorbar()\n    pl.title('full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_use.pdf')\n    fig = pl.figure()\n    res_all = np.concatenate(seq_best_all).flatten()\n    aa_bins = np.arange(21) - 0.5\n    pl.hist(res_all, bins=aa_bins, histtype='step')\n    pl.xticks(np.arange(20), labels=aa)\n    pl.title('residue use frequency')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_use_frequency.pdf')", "refactored": true, "question_id": "79b07cf6f3f380f296c7ce80ec1c84c5aa0ae81e_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def deep_seq_design():\n    root_dir = f'data/design/cullpdb_val_deep/{exp_flag}anneal_val_deep'\n    mut_matrix_anneal = np.zeros((20, 20))\n    native_aa_all = []\n    design_aa_all = []\n    seq_len = []\n    recovery = []\n    pdb_id_all = []\n    recovery_res = np.zeros(20)\n    count_res = np.zeros(20)\n    num = 100\n    for pdb_id in pdb_selected:\n        seq_best_all = []\n        for j in range(num):\n            data_anneal = h5py.File(f'{root_dir}/{pdb_id}_profile_{j}.h5', 'r')\n            designed_seq = data_anneal['profile'][()]\n            seq_best = designed_seq[1]\n            seq_best_all.append(seq_best)\n            seq_native = designed_seq[0]\n            recovery_fraction = np.sum(seq_best == seq_native) / float(len(seq_native))\n            recovery.append(recovery_fraction)\n            seq_len.append(len(seq_native))\n            pdb_id_all.append(pdb_id)\n            for i in range(seq_native.shape[0]):\n                mut_matrix_anneal[map_aa[seq_native[i]], map_aa[seq_best[i]]] += 1\n                native_aa_all.append(map_aa[seq_native[i]])\n                design_aa_all.append(map_aa[seq_best[i]])\n            _iter102 = range(20)\n            while True:\n                try:\n                    i = next(_iter102)\n                except StopIteration:\n                    break\n                idx = seq_native == i\n                recovery_res[i] += np.sum(seq_best[idx] == seq_native[idx])\n                count_res[i] += len(seq_native[idx])\n        with open(f'{root_dir}/{pdb_id}_seq_best.fasta', 'w') as mf:\n            s = ''.join([idx2aa[x] for x in seq_native])\n            mf.write(f'>0\\n{s}\\n')\n            for j in range(len(seq_best_all)):\n                s = ''.join([idx2aa[x] for x in seq_best_all[j]])\n                mf.write(f'>{j + 1}\\n')\n                mf.write(f'{s}\\n')\n    df = pd.DataFrame({'pdb': pdb_id_all, 'seq_len': seq_len, 'recovery': recovery})\n    df.to_csv(f'{root_dir}/recovery.csv', index=False)\n    np.save(f'data/design/cullpdb_val_deep/{exp_flag}anneal_val_deep/mut_matrix_anneal.npy', mut_matrix_anneal)\n    df = pd.DataFrame({'native_aa': native_aa_all, 'design_aa': design_aa_all})\n    df.to_csv(f'{root_dir}/native_design_aa.csv', index=False)\n    fig = pl.figure()\n    pl.plot(df['seq_len'], df['recovery'], 'bo')\n    pl.title('full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_seqlen_recovery.pdf')\n    fig = pl.figure()\n    pl.hist(df['recovery'], bins=np.arange(10) * 0.05 + 0.05)\n    pl.xlabel('native sequence recovery fraction')\n    pl.ylabel('N')\n    pl.savefig(f'{root_dir}/full_seq_design_recovery_hist.pdf')\n    fig = pl.figure()\n    pl.plot(np.arange(20), recovery_res / count_res)\n    pl.xticks(np.arange(20), labels=aa)\n    pl.title('residue recovery fraction in full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_recovery.pdf')\n    fig = pl.figure()\n    mut_matrix_anneal_freq = mut_matrix_anneal / mut_matrix_anneal.sum(axis=1)[:, None]\n    pl.imshow(mut_matrix_anneal_freq, cmap='jet')\n    pl.xlabel('mutated residue')\n    pl.ylabel('native residue')\n    pl.xticks(np.arange(20), labels=ordered_aa)\n    pl.yticks(np.arange(20), labels=ordered_aa)\n    pl.colorbar()\n    pl.title('full seq redesign')\n    pl.savefig(f'{root_dir}/full_seq_design_residue_use.pdf')\n    fig = pl.figure()\n    res_all = np.concatenate(seq_best_all).flatten()\n    aa_bins = np.arange(21) - 0.5\n    pl.hist(res_all, bins=aa_bins, histtype='step')\n    pl.xticks(np.arange(20), labels=aa)\n    pl.title('residue use frequency')\n"]]}
{"hexsha": "0322be0d34cfd540d38d08178833c28642a03567", "ext": "py", "lang": "Python", "content": "def MinSpanning(n, m):\n    dt = defaultdict(list)\n    for i in range(m):\n        x, y, w = map(int, input().slpit())\n        dt[x].append([y, w])\n        dt[y].append([x, w])\n    parent = [-1] * n\n    key = [float('inf')] * n\n    mstSet = [False] * n\n    prq = [(0, 0)]\n    key[0] = 0\n    _iter103 = range(n - 1)\n    while True:\n        try:\n            i = next(_iter103)\n        except StopIteration:\n            break\n        u = heappop(prq)[1]\n        mstSet[u] = True\n        for x, w in dt[u]:\n            if not mstSet[x] and w < key[x]:\n                parent[x] = u\n                key[x] = w\n                heappush(prq, (key[x], x))", "fn_id": 0, "class_fn": false, "repo": "Saicharan67/Interview-Coding-Questions", "file": "Graphs/MinSpanningTreeByPrims.py", "last_update_at": "2021-11-04T03:30:00+00:00", "original_content": "def MinSpanning(n, m):\n    dt = defaultdict(list)\n    for i in range(m):\n        x, y, w = map(int, input().slpit())\n        dt[x].append([y, w])\n        dt[y].append([x, w])\n    parent = [-1] * n\n    key = [float('inf')] * n\n    mstSet = [False] * n\n    prq = [(0, 0)]\n    key[0] = 0\n    for i in range(n - 1):\n        u = heappop(prq)[1]\n        mstSet[u] = True\n        for x, w in dt[u]:\n            if not mstSet[x] and w < key[x]:\n                parent[x] = u\n                key[x] = w\n                heappush(prq, (key[x], x))", "refactored": true, "question_id": "0322be0d34cfd540d38d08178833c28642a03567_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def MinSpanning(n, m):\n    dt = defaultdict(list)\n    for i in range(m):\n        x, y, w = map(int, input().slpit())\n        dt[x].append([y, w])\n        dt[y].append([x, w])\n    parent = [-1] * n\n    key = [float('inf')] * n\n    mstSet = [False] * n\n    prq = [(0, 0)]\n    key[0] = 0\n    _iter103 = range(n - 1)\n    while True:\n        try:\n            i = next(_iter103)\n        except StopIteration:\n            break\n        u = heappop(prq)[1]\n        mstSet[u] = True\n        for x, w in dt[u]:\n            if not mstSet[x] and w < key[x]:\n                parent[x] = u\n                key[x] = w\n"]]}
{"hexsha": "793c76b7aef3c3464b9f0b5785241de95f0cc1ed", "ext": "py", "lang": "Python", "content": "def draw_flow(img, flow, step=16):\n    h, w = img.shape[:2]\n    y, x = np.mgrid[step / 2:h:step, step / 2:w:step].reshape(2, -1).astype(int)\n    fx, fy = flow[y, x].T\n    lines = np.vstack([x, y, x + fx, y + fy]).T.reshape(-1, 2, 2)\n    lines = np.int32(lines + 0.5)\n    vis = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n    cv2.polylines(vis, lines, 0, (0, 255, 0))\n    _iter104 = lines\n    while True:\n        try:\n            (x1, y1), (_x2, _y2) = next(_iter104)\n        except StopIteration:\n            break\n        cv2.circle(vis, (x1, y1), 1, (0, 255, 0), -1)\n    return vis", "fn_id": 4, "class_fn": false, "repo": "mcv-m6-video/mcv-m6-2021-team6", "file": "W4/display.py", "last_update_at": "2021-03-23T18:54:28+00:00", "original_content": "def draw_flow(img, flow, step=16):\n    h, w = img.shape[:2]\n    y, x = np.mgrid[step / 2:h:step, step / 2:w:step].reshape(2, -1).astype(int)\n    fx, fy = flow[y, x].T\n    lines = np.vstack([x, y, x + fx, y + fy]).T.reshape(-1, 2, 2)\n    lines = np.int32(lines + 0.5)\n    vis = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n    cv2.polylines(vis, lines, 0, (0, 255, 0))\n    for (x1, y1), (_x2, _y2) in lines:\n        cv2.circle(vis, (x1, y1), 1, (0, 255, 0), -1)\n    return vis", "refactored": true, "question_id": "793c76b7aef3c3464b9f0b5785241de95f0cc1ed_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def draw_flow(img, flow, step=16):\n    h, w = img.shape[:2]\n    y, x = np.mgrid[step / 2:h:step, step / 2:w:step].reshape(2, -1).astype(int)\n    fx, fy = flow[y, x].T\n    lines = np.vstack([x, y, x + fx, y + fy]).T.reshape(-1, 2, 2)\n    lines = np.int32(lines + 0.5)\n    vis = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n    cv2.polylines(vis, lines, 0, (0, 255, 0))\n    _iter104 = lines\n    while True:\n        try:\n            (x1, y1), (_x2, _y2) = next(_iter104)\n        except StopIteration:\n            break\n        cv2.circle(vis, (x1, y1), 1, (0, 255, 0), -1)\n"]]}
{"hexsha": "a1f55cf8e4ae2523b3711b8a9b769203a9a8a01e", "ext": "py", "lang": "Python", "content": "def search(keywords, max_results=None):\n    url = 'https://html.duckduckgo.com/html/'\n    params = {'q': keywords}\n    headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:86.0) Gecko/20100101 Firefox/86.0'}\n    yielded = 0\n    for _ in iter(lambda: 0, 1):\n        if not True:\n            break\n        res = requests.post(url, data=params, headers=headers)\n        doc = html.fromstring(res.text)\n        results = [a.get('href') for a in doc.cssselect('#links .links_main a')]\n        for result in results:\n            yield result\n            time.sleep(0.1)\n            yielded += 1\n            if max_results and yielded >= max_results:\n                return\n        try:\n            form = doc.cssselect('.results_links_more form')[-1]\n        except IndexError:\n            return\n        params = dict(form.fields)", "fn_id": 0, "class_fn": false, "repo": "Jcorb08/programming-support-skill", "file": "duckduckgo.py", "last_update_at": "2021-05-26T11:08:27+00:00", "original_content": "def search(keywords, max_results=None):\n    url = 'https://html.duckduckgo.com/html/'\n    params = {'q': keywords}\n    headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:86.0) Gecko/20100101 Firefox/86.0'}\n    yielded = 0\n    while True:\n        res = requests.post(url, data=params, headers=headers)\n        doc = html.fromstring(res.text)\n        results = [a.get('href') for a in doc.cssselect('#links .links_main a')]\n        for result in results:\n            yield result\n            time.sleep(0.1)\n            yielded += 1\n            if max_results and yielded >= max_results:\n                return\n        try:\n            form = doc.cssselect('.results_links_more form')[-1]\n        except IndexError:\n            return\n        params = dict(form.fields)", "refactored": true, "question_id": "a1f55cf8e4ae2523b3711b8a9b769203a9a8a01e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def search(keywords, max_results=None):\n    url = 'https://html.duckduckgo.com/html/'\n    params = {'q': keywords}\n    headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:86.0) Gecko/20100101 Firefox/86.0'}\n    yielded = 0\n    for _ in iter(lambda: 0, 1):\n        if not True:\n            break\n        res = requests.post(url, data=params, headers=headers)\n        doc = html.fromstring(res.text)\n        results = [a.get('href') for a in doc.cssselect('#links .links_main a')]\n        for result in results:\n            yield result\n            time.sleep(0.1)\n            yielded += 1\n            if max_results and yielded >= max_results:\n                return\n        try:\n            form = doc.cssselect('.results_links_more form')[-1]\n        except IndexError:\n            return\n"]]}
{"hexsha": "965d7f77982b9eaf53ae37fba39562b4f8c0b34f", "ext": "py", "lang": "Python", "content": "def _split_points_into_batches(points: NumericArray, number_of_points_per_batch: int) -> tp.List[tp.List[NumericArray]]:\n    number_of_points = points.shape[1]\n    n_begin = 0\n    args_list = []\n    for _ in iter(lambda: 0, 1):\n        if not n_begin < number_of_points:\n            break\n        n_end = min(n_begin + number_of_points_per_batch, number_of_points)\n        args_list.append([points[:, n_begin:n_end]])\n        n_begin = n_end\n    return args_list", "fn_id": 0, "class_fn": false, "repo": "michaelnowotny/cocos", "file": "cocos/scientific/kde.py", "last_update_at": "2021-11-27T09:09:40+00:00", "original_content": "def _split_points_into_batches(points: NumericArray, number_of_points_per_batch: int) -> tp.List[tp.List[NumericArray]]:\n    number_of_points = points.shape[1]\n    n_begin = 0\n    args_list = []\n    while n_begin < number_of_points:\n        n_end = min(n_begin + number_of_points_per_batch, number_of_points)\n        args_list.append([points[:, n_begin:n_end]])\n        n_begin = n_end\n    return args_list", "refactored": true, "question_id": "965d7f77982b9eaf53ae37fba39562b4f8c0b34f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def _split_points_into_batches(points: NumericArray, number_of_points_per_batch: int) -> tp.List[tp.List[NumericArray]]:\n    number_of_points = points.shape[1]\n    n_begin = 0\n    args_list = []\n    for _ in iter(lambda: 0, 1):\n        if not n_begin < number_of_points:\n            break\n        n_end = min(n_begin + number_of_points_per_batch, number_of_points)\n        args_list.append([points[:, n_begin:n_end]])\n        n_begin = n_end\n"]]}
{"hexsha": "d7d0cc76bd9ced96d824215c265e0b8c9d95c87b", "ext": "py", "lang": "Python", "content": "def get_unique_changed_packages(diffs):\n    packages_changed = {}\n    _iter105 = diffs\n    while True:\n        try:\n            change = next(_iter105)\n        except StopIteration:\n            break\n        if len(change) != 2:\n            logging.debug(change)\n            continue\n        change_type, path = change\n        path_tokens = path.split('/')\n        if path_tokens[-1] in IGNORE_CHANGES_FILES:\n            continue\n        try:\n            package = Package(package_dir=path_tokens[0])\n        except PackageDoesNotExistException:\n            continue\n        if package.package_name not in packages_changed:\n            packages_changed.update({package.package_name: package})\n    return packages_changed", "fn_id": 2, "class_fn": false, "repo": "r-kells/scream", "file": "scream/detect_changed_packages.py", "last_update_at": "2021-11-22T18:45:19+00:00", "original_content": "def get_unique_changed_packages(diffs):\n    packages_changed = {}\n    for change in diffs:\n        if len(change) != 2:\n            logging.debug(change)\n            continue\n        change_type, path = change\n        path_tokens = path.split('/')\n        if path_tokens[-1] in IGNORE_CHANGES_FILES:\n            continue\n        try:\n            package = Package(package_dir=path_tokens[0])\n        except PackageDoesNotExistException:\n            continue\n        if package.package_name not in packages_changed:\n            packages_changed.update({package.package_name: package})\n    return packages_changed", "refactored": true, "question_id": "d7d0cc76bd9ced96d824215c265e0b8c9d95c87b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def get_unique_changed_packages(diffs):\n    packages_changed = {}\n    _iter105 = diffs\n    while True:\n        try:\n            change = next(_iter105)\n        except StopIteration:\n            break\n        if len(change) != 2:\n            logging.debug(change)\n            continue\n        change_type, path = change\n        path_tokens = path.split('/')\n        if path_tokens[-1] in IGNORE_CHANGES_FILES:\n            continue\n        try:\n            package = Package(package_dir=path_tokens[0])\n        except PackageDoesNotExistException:\n            continue\n        if package.package_name not in packages_changed:\n            packages_changed.update({package.package_name: package})\n"]]}
{"hexsha": "f4365a09ba1797e4fafc8682981c9fb04235a5c1", "ext": "py", "lang": "Python", "content": "@pytest.mark.parametrize('space_group', ['P2', 'P3', 'P6', 'R3:h', 'I23'][:])\ndef test_determine_space_group(space_group):\n    sgi = sgtbx.space_group_info(symbol=space_group)\n    sg = sgi.group()\n    cs = sgi.any_compatible_crystal_symmetry(volume=10000)\n    cs = cs.best_cell()\n    cs = cs.minimum_cell()\n    intensities = generate_fake_intensities(cs)\n    result = LaueGroupAnalysis([intensities], normalisation=None)\n    print(result)\n    assert result.best_solution.subgroup['best_subsym'].space_group() == sg.build_derived_patterson_group()\n    assert result.best_solution.likelihood > 0.8\n    _iter106 = result.subgroup_scores[1:]\n    while True:\n        try:\n            score = next(_iter106)\n        except StopIteration:\n            break\n        assert score.likelihood < 0.1", "fn_id": 1, "class_fn": false, "repo": "TiankunZhou/dials", "file": "algorithms/symmetry/test_laue_group.py", "last_update_at": "2021-11-18T04:20:54+00:00", "original_content": "@pytest.mark.parametrize('space_group', ['P2', 'P3', 'P6', 'R3:h', 'I23'][:])\ndef test_determine_space_group(space_group):\n    sgi = sgtbx.space_group_info(symbol=space_group)\n    sg = sgi.group()\n    cs = sgi.any_compatible_crystal_symmetry(volume=10000)\n    cs = cs.best_cell()\n    cs = cs.minimum_cell()\n    intensities = generate_fake_intensities(cs)\n    result = LaueGroupAnalysis([intensities], normalisation=None)\n    print(result)\n    assert result.best_solution.subgroup['best_subsym'].space_group() == sg.build_derived_patterson_group()\n    assert result.best_solution.likelihood > 0.8\n    for score in result.subgroup_scores[1:]:\n        assert score.likelihood < 0.1", "refactored": true, "question_id": "f4365a09ba1797e4fafc8682981c9fb04235a5c1_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["@pytest.mark.parametrize('space_group', ['P2', 'P3', 'P6', 'R3:h', 'I23'][:])\ndef test_determine_space_group(space_group):\n    sgi = sgtbx.space_group_info(symbol=space_group)\n    sg = sgi.group()\n    cs = sgi.any_compatible_crystal_symmetry(volume=10000)\n    cs = cs.best_cell()\n    cs = cs.minimum_cell()\n    intensities = generate_fake_intensities(cs)\n    result = LaueGroupAnalysis([intensities], normalisation=None)\n    print(result)\n    assert result.best_solution.subgroup['best_subsym'].space_group() == sg.build_derived_patterson_group()\n    assert result.best_solution.likelihood > 0.8\n    _iter106 = result.subgroup_scores[1:]\n    while True:\n        try:\n            score = next(_iter106)\n        except StopIteration:\n            break\n"]]}
{"hexsha": "29dcd0e7194a9a266ef5c8a71033e49f8cc50186", "ext": "py", "lang": "Python", "content": "def a_star(grid, h, start, goal):\n    path = []\n    path_cost = 0\n    queue = PriorityQueue()\n    queue.put((0, start))\n    visited = set(start)\n    branch = {}\n    found = False\n    while not queue.empty():\n        item = queue.get()\n        current_node = item[1]\n        if current_node == start:\n            current_cost = 0.0\n        else:\n            current_cost = branch[current_node][0]\n        if current_node == goal:\n            print('Found a path.')\n            found = True\n            break\n        else:\n            for action in valid_actions(grid, current_node):\n                da = action.delta\n                next_node = (current_node[0] + da[0], current_node[1] + da[1])\n                branch_cost = current_cost + action.cost\n                queue_cost = branch_cost + h(next_node, goal)\n                if next_node not in visited:\n                    visited.add(next_node)\n                    branch[next_node] = (branch_cost, current_node, action)\n                    queue.put((queue_cost, next_node))\n    if found:\n        n = goal\n        path_cost = branch[n][0]\n        path.append(goal)\n        for _ in iter(lambda: 0, 1):\n            if not branch[n][1] != start:\n                break\n            path.append(branch[n][1])\n            n = branch[n][1]\n        path.append(branch[n][1])\n    else:\n        print('**********************')\n        print('Failed to find a path!')\n        print('**********************')\n    return (path[::-1], path_cost)", "fn_id": 2, "class_fn": false, "repo": "allthatido/Drone_Motion_Planning", "file": "planning_utils.py", "last_update_at": "2021-07-08T18:54:42+00:00", "original_content": "def a_star(grid, h, start, goal):\n    path = []\n    path_cost = 0\n    queue = PriorityQueue()\n    queue.put((0, start))\n    visited = set(start)\n    branch = {}\n    found = False\n    while not queue.empty():\n        item = queue.get()\n        current_node = item[1]\n        if current_node == start:\n            current_cost = 0.0\n        else:\n            current_cost = branch[current_node][0]\n        if current_node == goal:\n            print('Found a path.')\n            found = True\n            break\n        else:\n            for action in valid_actions(grid, current_node):\n                da = action.delta\n                next_node = (current_node[0] + da[0], current_node[1] + da[1])\n                branch_cost = current_cost + action.cost\n                queue_cost = branch_cost + h(next_node, goal)\n                if next_node not in visited:\n                    visited.add(next_node)\n                    branch[next_node] = (branch_cost, current_node, action)\n                    queue.put((queue_cost, next_node))\n    if found:\n        n = goal\n        path_cost = branch[n][0]\n        path.append(goal)\n        while branch[n][1] != start:\n            path.append(branch[n][1])\n            n = branch[n][1]\n        path.append(branch[n][1])\n    else:\n        print('**********************')\n        print('Failed to find a path!')\n        print('**********************')\n    return (path[::-1], path_cost)", "refactored": true, "question_id": "29dcd0e7194a9a266ef5c8a71033e49f8cc50186_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["def a_star(grid, h, start, goal):\n    path = []\n    path_cost = 0\n    queue = PriorityQueue()\n    queue.put((0, start))\n    visited = set(start)\n    branch = {}\n    found = False\n    while not queue.empty():\n        item = queue.get()\n        current_node = item[1]\n        if current_node == start:\n            current_cost = 0.0\n        else:\n            current_cost = branch[current_node][0]\n        if current_node == goal:\n            print('Found a path.')\n            found = True\n            break\n        else:\n            for action in valid_actions(grid, current_node):\n                da = action.delta\n                next_node = (current_node[0] + da[0], current_node[1] + da[1])\n                branch_cost = current_cost + action.cost\n                queue_cost = branch_cost + h(next_node, goal)\n                if next_node not in visited:\n                    visited.add(next_node)\n                    branch[next_node] = (branch_cost, current_node, action)\n                    queue.put((queue_cost, next_node))\n    if found:\n        n = goal\n        path_cost = branch[n][0]\n        path.append(goal)\n        for _ in iter(lambda: 0, 1):\n            if not branch[n][1] != start:\n                break\n            path.append(branch[n][1])\n            n = branch[n][1]\n        path.append(branch[n][1])\n    else:\n        print('**********************')\n        print('Failed to find a path!')\n        print('**********************')\n"]]}
