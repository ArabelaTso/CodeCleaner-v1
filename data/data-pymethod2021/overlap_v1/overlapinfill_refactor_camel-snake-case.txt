--- 0 --
Question ID: 07bea0dee804f4a3dd1cb8de837a2c6f9ce9c771_1
Original Code:
```
def pretty_print_post(url: str):
    try:
        text = parse_post(url)
    except api2ch.Api2chError as e:
        print('Request Error', e.code, e.reason)
    else:
        print(text)
```


Overlapping Code:
```
ost(url: str):
try:
text = parse_post(url)
except api2ch.Api2chError as e:
print('Request Error', e.code, e.reason)
else:
```
<Overlap Ratio: 0.8013245033112583>

---

--- 1 --
Question ID: 6c31f616e579c190b006f0e8ba4f595d892ad988_28
Original Code:
```
@card('Braids, Cabal Minion')
def braids_cabal_minion(card, abilities):

    def braids_cabal_minion():
        return AbilityNotImplemented
    return (braids_cabal_minion,)
```


Overlapping Code:
```
bilities):
def braids_cabal_minion():
return Abili
```
<Overlap Ratio: 0.3184713375796178>

---

--- 2 --
Question ID: fc7e94a2224575fc9faaa120b95dfa7c40d2f253_31
Original Code:
```
def test_extended_projection(ra_module):
    initial_set = ra_module.NamedRelationalAlgebraFrozenSet(('x', 'y'), [(7, 8), (9, 2)])
    expected_sum = ra_module.NamedRelationalAlgebraFrozenSet(('z',), [(15,), (11,)])
    expected_lambda = ra_module.NamedRelationalAlgebraFrozenSet(('z',), [(14,), (10,)])
    expected_lambda2 = ra_module.NamedRelationalAlgebraFrozenSet(('z', 'x'), [(14, 8), (10, 10)])
    expected_new_colum_str = ra_module.NamedRelationalAlgebraFrozenSet(('x', 'z'), [(7, 'a'), (9, 'a')])
    expected_new_colum_int = ra_module.NamedRelationalAlgebraFrozenSet(('z',), [(1,), (1,)])
    new_set = initial_set.extended_projection({'z': sum})
    assert expected_sum == new_set
    new_set = initial_set.extended_projection({'z': ra_module.RelationalAlgebraStringExpression('x+y')})
    assert expected_sum == new_set
    new_set = initial_set.extended_projection({'z': lambda r: r.x + r.y - 1})
    assert expected_lambda == new_set
    new_set = initial_set.extended_projection({'z': lambda r: r.x + r.y - 1, 'x': ra_module.RelationalAlgebraStringExpression('x+1')})
    assert expected_lambda2 == new_set
    new_set = initial_set.extended_projection({'z': 'a', 'x': ra_module.RelationalAlgebraStringExpression('x')})
    assert expected_new_colum_str == new_set
    new_set = initial_set.extended_projection({'z': 1})
    assert expected_new_colum_int == new_set
    new_set = initial_set.extended_projection({'x': ra_module.RelationalAlgebraColumnStr('x')})
    assert initial_set.projection('x') == new_set
    baseSet = ra_module.NamedRelationalAlgebraFrozenSet((1, 2), [(7, 8), (9, 2)])
    new_set = baseSet.extended_projection({'x': ra_module.RelationalAlgebraColumnInt(1), 'y': ra_module.RelationalAlgebraColumnInt(2)})
    assert initial_set == new_set
```


Overlapping Code:
```
(ra_module):
initial_set = ra_module.NamedRelation
expected_sum = ra_module.NamedRelationalAlgebraFrd_lambda = ra_module.NamedRelationalAlgebraFrozenS
assert expected_sum == new_set
new_set = initial_set.extended_projection(
assert expected_sum == new_set
new_set = initial_set.extended_projection(- 1})
assert expected_lambda == new_set
new_set = initial_set.extended_projection(2 == new_set
new_set = initial_set.extended_projection(str == new_set
new_set = initial_set.extended_projection(new_set
new_set = initial_set.extended_projection(
```
<Overlap Ratio: 0.3212803793716657>

---

--- 3 --
Question ID: b41186cab3d777d1b3f6deea4852d5203576ebc3_3
Original Code:
```
def say(text):
    hash = hashlib.md5(text.encode()).hexdigest()
    file = 'speech-cache/{}.wav'.format(hash)
    cmd = 'play {}'.format(file)
    if not os.path.isfile(file):
        cmd = 'pico2wave -w {} "{}" && {}'.format(file, text, cmd)
    os.system(cmd)
```


Overlapping Code:
```
hexdigest()
file = 'speech-cache/{}.wav'.format(hash)
cmd = 'play {}'.format(file)
if not os.path.isfile(file):
cmd = 'pico2wave -w {} "{}" && {}'.for
```
<Overlap Ratio: 0.6410256410256411>

---

--- 4 --
Question ID: efba18d12458eb11af1a1ce332ee1fe30fca6aa2_0
Original Code:
```
def stft(sig, frameSize=FRAMESIZE, overlapFac=OVERLAP, window=np.hanning):
    hop = int(frameSize - np.floor(overlapFac * frameSize))
    w = np.sqrt(window(frameSize))
    out = np.array([np.fft.rfft(w * sig[i:i + frameSize]) for i in range(0, len(sig) - frameSize, hop)])
    out = np.abs(out)
    out -= np.mean(out)
    return out
```


Overlapping Code:
```
ft(sig, frameSize=FRAMESIZE, overlapFac=OVERLAP, window=np.hanning):
hop = int(frameSize - np.floor(overlapFac * frameSize))
w = np.sqrt(window(frameS
```
<Overlap Ratio: 0.48231511254019294>

---

--- 5 --
Question ID: 3daf2b90efe24d08876eb33fa7e809886b79aacb_7
Original Code:
```
def write_float_list():
    global result
    with open('result_shared_memory.txt', 'w') as f:
        f.write(str(result))
        f.close()
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 6 --
Question ID: e13fa130c6f556d3b69fbf1da32dc9e4fc944723_0
Original Code:
```
def report():
    value = grp.value
    try:
        say(labels[value], 'selected')
    except (TypeError, IndexError):
        say('Value =', value)
```


Overlapping Code:
```
report():
value = grp.value
try:
say(labels[value]
```
<Overlap Ratio: 0.4132231404958678>

---

--- 7 --
Question ID: d5c45875560e75035fb70d3ac4fa58d21599d27d_16
Original Code:
```
def test_vsi_path_zip_plus_https():
    """A zip+https:// URLs vsi path is correct (see #1151)"""
    url = 'zip+https://example.com/foo.zip!bar.tif'
    assert vsi_path(parse_path(url)) == '/vsizip/vsicurl/https://example.com/foo.zip/bar.tif'
```


Overlapping Code:
```
 test_vsi_path_zip_plus_https():
"""A zip+https:// URLs vsi path is correct (see #1151)"""
url = 'zip+https://example.com/foo.zip!bar.tif'
assert vsi_path(parse_path(url)) == '/vsizip/vsicurl/https://
```
<Overlap Ratio: 0.8658008658008658>

---

--- 8 --
Question ID: 995e126c50514275c11a5e83f7c9eaa1aa63e240_1
Original Code:
```
def timestamp_unpack(seconds, timedelta=datetime.timedelta, relative_to=pg_epoch_datetime.__add__):
    """
	Create a `datetime.datetime` instance from a (seconds, microseconds) pair.
	"""
    return relative_to(timedelta(0, *seconds))
```


Overlapping Code:
```
Create a `datetime.datetime` instance from a (seconds, microseconds) pair.
"""
return relative_to(tim
```
<Overlap Ratio: 0.4488888888888889>

---

--- 9 --
Question ID: 6f8e9b82a7e7f7ef2e5696e6e11a9da88873c108_2
Original Code:
```
@app.route('/ext/<api_key>/new_session/<session_name>', methods=['POST'])
def ext_create_new_session_name(api_key, session_name):
    logging.debug('EXTERNAL: Create new Session with name')
    db = Database()
    user = db.get_user_by_api_key(api_key)
    if user is None:
        return ("Provided API key ('{}') is not associated with any registered user".format(api_key), HTTPStatus.UNAUTHORIZED.value)
    if db.does_session_name_exist(session_name):
        return ("Provided session name ('{}') already exists".format(session_name), HTTPStatus.UNAUTHORIZED.value)
    logging.debug('Creating new session: %s (userid: %s)', session_name, user['user_id'])
    sessionId = db.create_session(session_name, user['user_id'])
    logging.debug('New session id: %s', sessionId)
    set_current_session(sessionId, session_name)
    return "New Session ID: '{}'".format(sessionId)
```


Overlapping Code:
```
xt/<api_key>/new_session/<session_name>', methods=['POST'])
def ext_create_new_session_name(api_key,user = db.get_user_by_api_key(api_key)
if user is None:
returPI key ('{}') is not associated with any registered user".format(api_key), HTTPStatus.UNAUTHORIZED.valready exists".format(session_name), HTTPStatus.Uate_session(session_name, user['user_id'])
loggingion_name)
return "New Session ID: '{}'".format(ses
```
<Overlap Ratio: 0.5006090133982948>

---

--- 10 --
Question ID: 3b40f31f9e2306102a844f470092207c102189e3_3
Original Code:
```
@pb.route('/detail/<id>', methods=['GET', 'POST'])
def single_product(id):
    product = Product.query.filter_by(id=id).first()
    if product.out_of_stock == True:
        status = 'Sold Out'
    else:
        status = 'In stock'
    data = {'id': product.id, 'name': product.name, 'img_url': product.img_url, 'description': product.description, 'seller': User.query.filter_by(id=product.seller_id).first().name, 'seller_id': product.seller_id, 'created': product.created, 'price': product.price, 'status': status, 'seller_img': User.query.filter_by(id=product.seller_id).first().avatar_url}
    return jsonify(data)
```


Overlapping Code:
```
oute('/detail/<id>', methods=['GET', 'POST'])
def _product(id):
product = Product.query.filter_by(id=id).first()
if User.query.filter_by(id=product.seller_id).first().nam User.query.filter_by(id=product.seller_id).first(
```
<Overlap Ratio: 0.37865748709122204>

---

--- 11 --
Question ID: fe240d6eafcfe9043656fc61dbcdc36afa2f5d4c_0
Original Code:
```
def get_feature(internelLayer, layers, filters, batch_norm=False):
    """Get VGG feature body as stacks of convoltions."""
    for (i, num) in enumerate(layers):
        for j in range(num):
            internelLayer = sym.conv2d(data=internelLayer, kernel_size=(3, 3), padding=(1, 1), channels=filters[i], name='conv%s_%s' % (i + 1, j + 1))
            if batch_norm:
                internelLayer = sym.batch_norm(data=internelLayer, name='bn%s_%s' % (i + 1, j + 1))
            internelLayer = sym.relu(data=internelLayer, name='relu%s_%s' % (i + 1, j + 1))
        internelLayer = sym.max_pool2d(data=internelLayer, pool_size=(2, 2), strides=(2, 2), name='pool%s' % (i + 1))
    return internelLayer
```


Overlapping Code:
```
ayer, layers, filters, batch_norm=False):
"""Get VGG feature body as stacks of convol
```
<Overlap Ratio: 0.1362179487179487>

---

--- 12 --
Question ID: d1b6df0cf562b4a74a407607abec54818df78080_1
Original Code:
```
def mech():
    item = {0: 'mail', 1: 'password'}
    try:
        choice = int(input(bcolors.OKBLUE + 'Enter the option no. of data: \n [0] Mail \n [1] Password\n [2] Exit\nOption:' + bcolors.ENDC))
        try:
            passData = input(bcolors.OKBLUE + 'Enter the ' + str(item[choice]) + ' to check: ' + bcolors.ENDC)
        except:
            exit(0)
        data = main(str(choice), passData)
        print(bcolors.OKGREEN + data + bcolors.ENDC)
        print(bcolors.OKBLUE + ' [0] Dump data in a file \n [1] Go back \n [2] Exit' + bcolors.ENDC)
        choice_ = input(bcolors.OKBLUE + 'Option: ' + bcolors.ENDC)
        if choice_ == '0':
            raw_filename = input(bcolors.OKBLUE + 'File name to save: ' + bcolors.ENDC)
            filename = raw_filename + '_' + str(item[choice]) + '.txt'
            file = open(filename, 'w')
            file.write(data)
            file.close()
            print(bcolors.OKGREEN + 'File is saved in same directory with name {}.'.format(raw_filename) + bcolors.ENDC)
            print()
        elif choice_ == '1':
            print()
            print()
            mech()
        else:
            exit(0)
    except Exception as e:
        print(bcolors.FAIL + e + bcolors.ENDC)
        exit(0)
```


Overlapping Code:
```
lors.OKBLUE + 'Enter the option no. of data: \n [0] Mail \n [1] Password\n [2] Exit\nOption:' + bcol 'Enter the ' + str(item[choice]) + ' to check: ' + bcolors.ENDC)
except:
exit(0)
data = main(str(chcolors.ENDC)
print(bcolors.OKBLUE + ' [0] Dump data in a file \n [1] Go back \n [2] Exit' + bcolors. bcolors.ENDC)
if choice_ == '0':
raw_filename = irs.ENDC)
filename = raw_filename + '_' + str(item[
file = open(filename, 'w')
file.write(data)
file.close()
print(bcolors.OKGREEN + 'File is saved in same directory with name {}.'.format(raw_filename) + bcolors.ENDC)
print()
elif choice_ == '1':
print()
print()
mech()
else:
exit(0)
except Exception as e:
print(bcolors.FAIL + e + b
```
<Overlap Ratio: 0.6875>

---

--- 13 --
Question ID: a113b237351d78e1a5fa0fd0d24d0327976b7f7a_1
Original Code:
```
def process_data(dataframe: pd.DataFrame) -> pd.DataFrame:
    """delete column that have most na, and fill na with mean"""
    naCount = dataframe.isnull().sum(axis=0).tolist()
    most_na_col = naCount.index(max(naCount))
    result = dataframe.drop(dataframe.columns[most_na_col], axis=1)
    return result.fillna(result.mean())
```


Overlapping Code:
```
process_data(dataframe: pd.DataFrame) -> pd.DataFrame:
"""delete column that have most na,  = dataframe.drop(dataframe.columns[most_na_col], axis=1)
return result.fi
```
<Overlap Ratio: 0.5305466237942122>

---

--- 14 --
Question ID: be83fdd493ff018b94ad39f9ed435403d860ea8e_4
Original Code:
```
def generate_bio(spans, length):
    tags = ['O'] * length
    for span in spans:
        tags[span.tokens[0]] = f'B-{span.type}'
        for i in span.tokens[1:]:
            tags[i] = f'I-{span.type}'
    return tags
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 15 --
Question ID: 1a9febc6fc48fe142ca3755fceef4aa604dfb595_2
Original Code:
```
def assemble(mappings, sequence_file, out_file, min_overlap, max_overhang, min_length):
    (graph, assembled) = OverlapGraph.parse_paf(mappings, min_overlap, max_overhang)
    paths = graph.max_paths()
    sequences = parse_fasta(sequence_file)
    with open(out_file, 'w') as f:
        for path in paths:
            (seq, containedReads, name) = construct_merged_sequence(path, graph, sequences)
            assembled += containedReads
            if len(seq) > min_length:
                f.write('>%s\n%s\n' % (name, seq))
        for (n, s) in sequences.items():
            if n in assembled:
                continue
            if len(s) < min_length:
                continue
            f.write('>%s\n%s\n' % (n, s))
```


Overlapping Code:
```
s, min_overlap, max_overhang)
paths = graph.max_paths()
sequences = parse_fasta(sequence_file)
with openf len(seq) > min_length:
f.write('>%s\n%s\n' % (nainue
if len(s) < min_length:
continue
f.write('>%s
```
<Overlap Ratio: 0.3541666666666667>

---

--- 16 --
Question ID: a2c6556c09f53bd180fe20a7e14114c3b4f5b12b_3
Original Code:
```
def get_mycroft_version():
    try:
        from mycroft.version import CORE_VERSION_STR
        return CORE_VERSION_STR
    except:
        pass
    root = search_mycroft_core_location()
    if root:
        versionFile = join(root, 'version', '__init__.py')
        if not isfile(versionFile):
            versionFile = join(root, 'mycroft', 'version', '__init__.py')
        if isfile(versionFile):
            version = []
            with open(versionFile) as f:
                text = f.read()
                version.append(text.split('CORE_VERSION_MAJOR =')[-1].split('\n')[0].strip())
                version.append(text.split('CORE_VERSION_MINOR =')[-1].split('\n')[0].strip())
                version.append(text.split('CORE_VERSION_BUILD =')[-1].split('\n')[0].strip())
                version = '.'.join(version)
                if "CORE_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE)) + " in text:
                    version += text.split("CORE_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE)) + ")[-1].split('\n')[0][1:-1]
                return version
        return None
```


Overlapping Code:
```
version():
try:
from mycroft.version import CORE_VERSION_STR
return CORE_VERSION_STR
except:
pass
root = search_mycroft_core_location()
if root:
versi_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE))_VERSION_STR = '.'.join(map(str, CORE_VERSION_TUPLE))
```
<Overlap Ratio: 0.29836829836829837>

---

--- 17 --
Question ID: d9fc432fc00d588e5c0efee2aee23a3f4e8a0c91_0
Original Code:
```
def main(_):
    tf.logging.set_verbosity(tf.logging.INFO)
    usr_dir.import_usr_dir(FLAGS.t2t_usr_dir)
    trainer_utils.log_registry()
    trainer_utils.validate_flags()
    output_dir = os.path.expanduser(FLAGS.output_dir)
    tmp_dir = os.path.expanduser(FLAGS.tmp_dir)
    if not FLAGS.data_dir:
        raise ValueError('You must specify a --data_dir')
    dataDir = os.path.expanduser(FLAGS.data_dir)
    tf.gfile.MakeDirs(output_dir)
    if FLAGS.generate_data:
        tf.gfile.MakeDirs(dataDir)
        tf.gfile.MakeDirs(tmp_dir)
        for problem_name in FLAGS.problems.split('-'):
            tf.logging.info('Generating data for %s' % problem_name)
            problem = registry.problem(problem_name)
            problem.generate_data(dataDir, tmp_dir)
    trainer_utils.run(data_dir=dataDir, model=FLAGS.model, output_dir=output_dir, train_steps=FLAGS.train_steps, eval_steps=FLAGS.eval_steps, schedule=FLAGS.schedule)
```


Overlapping Code:
```
def main(_):
tf.logging.set_verbosity(tf.logging.INFO)
usr_dir.import_usr_dir(FLAGS.t2t_usr_dir)
trainer_utils.log_registry()
trainer_utils.validate_flags()
output_dir = os.path.expanduser(FLAGS.output_dir)
tmp_dir = os.path.expanduser(FLAGS.tmp_dir)
if not FLAGS.doblem_name)
problem = registry.problem(problem_name)
problem.gen
```
<Overlap Ratio: 0.39927184466019416>

---

--- 18 --
Question ID: 01b86d405494b9108be791ee779c96fe8f5fc81b_4
Original Code:
```
def test_code_point_of_name():
    assert demojiprocess.code_point_of_name('yellow_heart') == '1f49b'
    assert demojiprocess.code_point_of_name(':yellow_heart:') == '1f49b'
    assert demojiprocess.code_point_of_name('woman_health_worker_tone2') == '1f469-1f3fc-200d-2695-fe0f'
    assert demojiprocess.code_point_of_name('adult:skin-tone-4') == '1f9d1-1f3fe'
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 19 --
Question ID: b9a0444e34d229fe92febc414b59c043e61e95ce_4
Original Code:
```
def get_blue_marble_image(month):
    filename = 'world.2004%02i.3x21600x10800.jpg' % month
    fullpath = os.path.join(os.path.expanduser('~'), '.cache/burned_area/' + filename)
    if os.path.exists(fullpath):
        with open(fullpath, 'rb') as f:
            imgdata = f.read()
    else:
        code = _nasa_blue_marble_ng_monthly_image_url_codes[month - 1]
        url = ('https://eoimages.gsfc.nasa.gov/images/imagerecords/' + '%s/' + filename) % code
        print('Downloading', url)
        req = requests.get(url)
        req.raise_for_status()
        imgdata = req.content
        os.makedirs(os.path.dirname(fullpath), exist_ok=True)
        with open(fullpath, 'wb') as f:
            f.write(imgdata)
    img = Image.open(io.BytesIO(imgdata))
    return img
```


Overlapping Code:
```
:
filename = 'world.2004%02i.3x21600x10800.jpg' % month
fullpath = os.path.join(os.path.expanduser('/' + filename)
if os.path.exists(fullpath):
with open(fullpath, 'rb') as f:
imgdata = f.read()
else:
code = _nasa_blue_marble_ng_monthly_image_url_codes[month - 1]
url = ('https://eoimages.gsfc.nasa.gov/images/imagerecords/' +rl)
req = requests.get(url)
req.raise_for_status()
imgdata = req.content
os.makedirs(os.path.dirname(fullpath), exist_ok=True)
with open(fullpath, 'wb') as f:
f.write(imgdata)
img = Image.open(io.BytesIO(imgdata))
return 
```
<Overlap Ratio: 0.8363914373088684>

---

--- 20 --
Question ID: 965d7f77982b9eaf53ae37fba39562b4f8c0b34f_0
Original Code:
```
def _split_points_into_batches(points: NumericArray, number_of_points_per_batch: int) -> tp.List[tp.List[NumericArray]]:
    number_of_points = points.shape[1]
    n_begin = 0
    args_list = []
    while n_begin < number_of_points:
        nEnd = min(n_begin + number_of_points_per_batch, number_of_points)
        args_list.append([points[:, n_begin:nEnd]])
        n_begin = nEnd
    return args_list
```


Overlapping Code:
```
of_points = points.shape[1]
n_begin = 0
args_list (n_begin + number_of_points_per_batch, number_of_p
```
<Overlap Ratio: 0.2785515320334262>

---

--- 21 --
Question ID: 01eaa1599fa6952fceac0db02f61801ac8392d27_17
Original Code:
```
def plot_correlation(py, correlated, minimum_arg, minimums):
    plt.figure()
    plt.plot(py, correlated[:, 0, 0])
    plt.plot(py, correlated[:, -1, -1])
    plt.legend(['pixel 0,0', 'pixel n,n', 'minimum 0 0', 'minimum n n'])
    plt.title('cross correlation between calibration curve and pixel values')
    plt.xlabel('Physical distance (im)')
    plt.ylabel('Focus unit')
```


Overlapping Code:
```
ated, minimum_arg, minimums):
plt.figure()
plt.plo', 'minimum 0 0', 'minimum n n'])
plt.title('cross correlation between calibration curve and pixel values')
plt.xlabel('Physical distance (im)')
plt.ylabel('Focus u
```
<Overlap Ratio: 0.6149425287356322>

---

--- 22 --
Question ID: d4fedd0a36cd395e4706b0c47428c1465d2a2a9d_1
Original Code:
```
def wl_predict(datasets, test_datasets):
    """

    """
    log_dir = tfu.get_logdir()
    (datasets, test_datasets) = get_wl_datasets()
    (x, y) = tfu.get_example(datasets)
    loss_fxn = tf.losses.BinaryCrossentropy()
    optim = tf.keras.optimizers.Adam()
    model = lstm.make_mlp_functional(x.shape[-2:], tf.size(y[0]), classify=True)
    (train_summary_writer, test_summary_writer) = tfu.init_summary_writers(log_dir)
    (train_loss, trainAccuracy, test_loss, test_accuracy) = tfu.get_classification_metrics()
    tr_step = 0
    te_step = 0
    for (epoch, dataset) in enumerate(datasets):
        if not dataset:
            continue
        for (xtr, ytr) in dataset:
            ytr = tf.reshape(ytr, (1, -1))
            (tl, ta, preds) = fwd.train_step_classify(model, optim, loss_fxn, xtr, ytr, train_loss, trainAccuracy)
            tr_step += 1
            with train_summary_writer.as_default():
                tf.summary.scalar('loss', tl.numpy(), step=tr_step)
                tf.summary.scalar('accuracy', ta.numpy(), step=tr_step)
            maxed_pred = tf.argmax(preds, 1).numpy()[0]
            maxed_true = tf.argmax(ytr).numpy()
            correct = tf.equal(maxed_pred, maxed_true).numpy()
        test_dataset = random.choice(test_datasets)
        if not test_dataset:
            continue
        for (xte, yte) in test_dataset:
            yte = tf.reshape(yte, (1, -1))
            (tel, tea) = fwd.test_step(model, loss_fxn, xte, yte, test_loss, test_accuracy)
            te_step += 1
            with test_summary_writer.as_default():
                tf.summary.scalar('loss', tel.numpy(), step=te_step)
                tf.summary.scalar('accuracy', tea.numpy(), step=te_step)
        template = 'Epoch {}, Loss: {}, Accuracy: {}, Test Loss: {}, Test Accuracy: {}, Preds: {}, Acts: {}'
        print(template.format(epoch + 1, train_loss.result(), trainAccuracy.result() * 100, test_loss.result(), test_accuracy.result() * 100, preds, ytr))
        train_loss.reset_states()
        test_loss.reset_states()
        trainAccuracy.reset_states()
        test_accuracy.reset_states()
    tf.saved_model.save(model, tfm.WRITE_TO + 'win_loss/')
    return datasets
```


Overlapping Code:
```
(datasets, test_datasets):
"""
"""
log_dir = tfu.gtf.losses.BinaryCrossentropy()
optim = tf.keras.optimizers.Adam()
model = lstm.make_mlp_functional(x in enumerate(datasets):
if not dataset:
continue
for (xtr, ytr) in dataset:
ytr = tf.reshape( 1
with train_summary_writer.as_default():
tf.summary.scalar('loss', tl.numpy(),x(preds, 1).numpy()[0]
maxed_true = tf.argmax(ytr).numpy()
correct = tf.equal(maxed_pred, maxed_true).numpy()
test_dataset = random.choice(test_datasets)
if not test_dataset:
continue
for (xte, yte) i
with test_summary_writer.as_default():
tf.summary.scalar('loss', ttep)
template = 'Epoch {}, Loss: {}, Accuracy: {}, Test Loss: {}, Test Accuracy: {}'
print(template.format(epoch + 1, train_loss.resulturacy.result() * 100, test_loss.result(), test_accuracy.result() * 100
train_loss.reset_states()
test_loss.reset_states()
trainAccuracy.reset_states()
test_accuracy.reset_states()
tf.saved_model.save(model, tfm.WRIT
```
<Overlap Ratio: 0.5133660665575559>

---

--- 23 --
Question ID: 982db6db807b1cdc32803139fd8028059a1a1f18_12
Original Code:
```
def plotvfonsph(theta_rad, phi_rad, F_th, F_ph, freq=0.0, vcoordlist=['sph'], projection='orthographic', cmplx_rep='AbsAng', vfname='Unknown'):
    """Plot transverse vector field on sphere. Different projections are
    supported as are different bases and complex value representations."""
    (x, y, xy_names, nomXticks, F_th, F_ph) = projectdomain(theta_rad, phi_rad, F_th, F_ph, projection)
    (F0_c, F1_c, comp_names) = vcoordconvert(F_th, F_ph, phi_rad, vcoordlist=vcoordlist)
    (F0_2r, cmplxop0) = cmplx2realrep(F0_c, cmplx_rep)
    (F1_2r, cmplxop1) = cmplx2realrep(F1_c, cmplx_rep)
    if projection == 'orthographic':
        xy_names = [xy_names[0] + ' []', xy_names[1] + ' []']
    if projection == 'azimuthal-equidistant':
        x = numpy.rad2deg(x)
        y = numpy.rad2deg(y)
        xy_names = [xy_names[0] + ' [deg.]', xy_names[1] + ' [deg.]']
    fig = plt.figure()
    fig.suptitle(vfname + ' @ ' + str(freq / 1000000.0) + ' MHz' + ', ' + 'projection: ' + projection)

    def plotcomp(vcmpi, cpi, zcomp, cmplxop, xy_names, nomXticks):
        if cmplxop[cpi] == 'Ang':
            cmap = plt.get_cmap('hsv')
        else:
            cmap = plt.get_cmap('viridis')
        plt.pcolormesh(x, y, zcomp[cpi], cmap=cmap)
        if nomXticks is not None:
            plt.xticks(nomXticks)
        ax.set_title(cmplxop[cpi] + '(' + comp_names[vcmpi] + ')')
        plt.xlabel(xy_names[0])
        plt.ylabel(xy_names[1])
        plt.grid()
        plt.colorbar()
        if projection == 'equirectangular':
            ax.invert_yaxis()
    ax = plt.subplot(221, polar=False)
    plotcomp(0, 0, F0_2r, cmplxop0, xy_names, nomXticks)
    ax = plt.subplot(222, polar=False)
    plotcomp(0, 1, F0_2r, cmplxop0, xy_names, nomXticks)
    ax = plt.subplot(223, polar=False)
    plotcomp(1, 0, F1_2r, cmplxop1, xy_names, nomXticks)
    ax = plt.subplot(224, polar=False)
    plotcomp(1, 1, F1_2r, cmplxop1, xy_names, nomXticks)
    plt.show()
```


Overlapping Code:
```
'):
"""Plot transverse vector field on sphere. Different projections are
supported as are different domain(theta_rad, phi_rad, F_th, F_ph, projection)lrep(F1_c, cmplx_rep)
if projection == 'orthograph]
if projection == 'azimuthal-equidistant':
x = nus):
if cmplxop[cpi] == 'Ang':
cmap = plt.get_cmap('hsv')
else:
cmap = plt.get_cmap('viridis')
plt.pc
plt.xlabel(xy_names[0])
plt.ylabel(xy_names[1])
plt.grid()
plt.colorbar()
if projection == 'equirectangular':
ax.invert_yaxis()
ax = plt.subplot(221, polar=False)
plotcomp(0, 0, F0_2r, cmplxop0, x plt.subplot(224, polar=False)
plotcomp(1, 1, F1_2
```
<Overlap Ratio: 0.3479020979020979>

---

--- 24 --
Question ID: acf70d67c75b3c219a4cc6fc3e0736e214b7ac7f_2
Original Code:
```
@pytest.fixture
def color_image(image):
    image.ndim = 3
    return image
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 25 --
Question ID: 53f7bb295a7670c88ce420c9fc2d3c662110f9c1_14
Original Code:
```
def AvgPooling(pytorch_layer):
    layer = pb2.LayerParameter()
    layer.type = 'Pooling'
    layer.pooling_param.pool = pb2.PoolingParameter.AVE
    CopyPoolingParameter(pytorch_layer, layer)
    return layer
```


Overlapping Code:
```
(pytorch_layer):
layer = pb2.LayerParameter()
layer.type = AVE
CopyPoolingParameter(pytorch_layer, layer)
return 
```
<Overlap Ratio: 0.5947368421052631>

---

--- 26 --
Question ID: ed1e84994c73c427aad1a29aacc2fb28de4545f1_4
Original Code:
```
@pytest.mark.parametrize('transaction_args,method_args,method_kwargs,expected,skip_testrpc', (({}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'chainId': None}, False), ({'gas': 800000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'chainId': None}, False), ({'gasPrice': 21000000000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 21000000000, 'chainId': None}, False), ({'nonce': 7}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 0, 'gasPrice': 1, 'nonce': 7, 'chainId': None}, True), ({'value': 20000}, (5,), {}, {'data': '0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 'value': 20000, 'gasPrice': 1, 'chainId': None}, False)), ids=['Standard', 'Explicit Gas', 'Explicit Gas Price', 'Explicit Nonce', 'With Value'])
def test_build_transaction_with_contract_with_arguments(web3, skip_if_testrpc, math_contract, transaction_args, method_args, method_kwargs, expected, skip_testrpc, buildTransaction):
    if skip_testrpc:
        skip_if_testrpc(web3)
    txn = buildTransaction(contract=math_contract, contract_function='increment', func_args=method_args, func_kwargs=method_kwargs, tx_params=transaction_args)
    expected['to'] = math_contract.address
    assert txn is not None
    if 'gas' in transaction_args:
        assert txn['gas'] == transaction_args['gas']
    else:
        assert 'gas' in txn
    assert dissoc(txn, 'gas') == expected
```


Overlapping Code:
```
pytest.mark.parametrize('transaction_args,method_args,method_kwargs,expected,skip_0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', 0x7cf5dab00000000000000000000000000000000000000000000000000000000000000005', saction_with_contract_with_arguments(web3, skip_ifTransaction):
if skip_testrpc:
skip_if_testrpc(web
txn = buildTransaction(contract=math_contract, contract_function='incremon_args)
expected['to'] = math_contract.address
assert txn is not None
if 'gas' in transaction_args:
assert txn['gas'] == transaction_args['gas']
else:
assert 'gas' in txn
assert dissoc(txn, 'gas') ==
```
<Overlap Ratio: 0.5181986428130784>

---

--- 27 --
Question ID: 6f98bbabb72a1fe6a11d10ff1c78a84452e1e916_5
Original Code:
```
def add_preproc_params(parser):
    parser.add_argument('--effdir_out_preproc', required=False, help='Output directory for preproc')
    parser.add_argument('--preproc_mask', required=False, help='Preproc processing mask file')
    parser.add_argument('--preproc_mask_adc', required=False, help='Preproc ADC NL processing mask file')
    parser.add_argument('--preproc_dark', dest='preproc_dark', default=False, action='store_true', help='Preprocess dark data')
    parser.add_argument('--preproc_common', dest='preproc_common', default=False, action='store_true', help='Preprocess common data')
    parser.add_argument('--nbin', required=False, default=10000, type=np.int, help='Number of phase bins')
    parser.add_argument('--jump_filter_len', required=False, default=40000, type=np.int, help='Jump filter length')
    parser.add_argument('--jump_threshold', required=False, default=5.0, type=np.float, help='Jump detection threshold')
    parser.add_argument('--preproc_timeout', required=False, default=120, type=np.int, help='Maximum time allowed for preprocessing a ring')
    parser.add_argument('--preproc_timeout_intermediate', required=False, default=60, type=np.int, help='Maximum time allowed for preprocessing a ring before last iteration')
    parser.add_argument('--adc_correction', required=False, help='Full (new) NL correction file.')
    parser.add_argument('--measure_ADC', dest='measure_ADC', default=False, action='store_true', help='Measure ADC NL')
    parser.add_argument('--niter_ADC', default=1, type=np.int, help='Number of ADC NL iterations')
    parser.add_argument('--delta_ADC', default=1.0, type=np.float, help='Width of ADC bin in ADU')
    parser.add_argument('--nphase4k', required=False, default=2, type=np.int, help='Number of 4K cooler phases to measure ADC NL for.')
    parser.add_argument('--skip_preproc', dest='skip_preproc', default=False, action='store_true', help='Do not pre-process the TOD')
    parser.add_argument('--flag_planets', dest='flag_planets', default=False, action='store_true', help='Derive planet flags')
    parser.add_argument('--planet_flag_radius', required=False, default=2.0, type=np.float, help='New planet flag radius (in FWHM) when --flag_planets')
    parser.add_argument('--detmask', required=False, type=np.int, help='Detector flag mask')
    parser.add_argument('--intense_threshold', required=False, default=10000000000.0, type=np.float, help='Intense signal threshold [K_CMB]')
    parser.add_argument('--preproc_async_time', required=False, default=1000, type=np.int, help='Initial asynchronous processing time before load balancing')
    parser.add_argument('--preproc_async_time_intermediate', required=False, default=800, type=np.int, help='Initial asynchronous processing time before load balancing before last iteration')
    return
```


Overlapping Code:
```
utput directory for preproc')
parser.add_argument(dd_argument('--preproc_dark', dest='preproc_dark',er of phase bins')
parser.add_argument('--jump_filnt, help='Jump filter length')
parser.add_argument('--jump_threshold', required=False, default=e allowed for preprocessing a ring before last iteL correction file.')
parser.add_argument('--measur'store_true', help='Measure ADC NL')
parser.add_ar='Number of ADC NL iterations')
parser.add_argumen'Width of ADC bin in ADU')
parser.add_argument('--nphase4k', required=False, default=2, type=np.int,, default=False, action='store_true', help='Do not pre-process the TOD')
rgument('--flag_planets', dest='flag_planets', defet flags')
parser.add_argument('--planet_flag_radi
```
<Overlap Ratio: 0.29730848861283643>

---

--- 28 --
Question ID: c0b95f623054d53abb9621aff1a8155369c99b80_0
Original Code:
```
def seed_everything(seed):
    torch.manual_seed(seed)
    torch.cuda.manual_seed(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False
    random.seed(seed)
```


Overlapping Code:
```
ef seed_everything(seed):
torch.manual_seed(seed)
torch.cuda.manual_seed(seed)
torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark = False
random.seed(seed)
```
<Overlap Ratio: 0.9943820224719101>

---

--- 29 --
Question ID: 5ecff52b202fb2311f75b717f10ecda7192b0a5e_5
Original Code:
```
def extract_cands_in_generate(type, constraints=set()):
    cands = []
    for t in CONCEPTS[type]:
        if all([is_consistent(t, c) for c in constraints]) or not constraints:
            cands.append(t)
    return cands
```


Overlapping Code:
```
ints=set()):
cands = []
for t in CONCEPTS[type]:
if all([is_consistent(t, c) for c in constraints]) 
```
<Overlap Ratio: 0.5235602094240838>

---

--- 30 --
Question ID: 57728a0d7226be69507552ec44dac52e55264baf_1
Original Code:
```
def make_test_data():
    """ """
    tgrid = np.array([0.0, 86400.0])
    xgrid = np.linspace(-8, 8, 120)
    ygrid = np.linspace(-7, 7, 110)
    zgrid = np.linspace(-6, 6, 100)
    bdip = np.array([[[ptm_dipole.dipole_field([x, y, z]) for z in zgrid] for y in ygrid] for x in xgrid])
    ex = np.zeros([xgrid.size, ygrid.size, zgrid.size])
    ey = np.zeros_like(ex)
    ez = np.zeros_like(ex)
    pf = ptm_preprocessing.PTMfields()
    pf.set_grid(xgrid, ygrid, zgrid)
    pf.set_magnetic(bdip[:, :, :, 0], bdip[:, :, :, 1], bdip[:, :, :, 2])
    pf.set_electric(ex, ey, ez)
    pf.write_file('ptm_data/ptm_fields_0001.dat')
    pf.write_file('ptm_data/ptm_fields_0002.dat')
    np.savetxt('ptm_data/tgrid.dat', tgrid)
```


Overlapping Code:
```

tgrid = np.array([0.0, 86400.0])
xgrid = np.linspdipole.dipole_field([x, y, z]) for z in zgrid] for y in ygrid] for x in xgrid])
ex = np.zeros([xgrid.size, ygrid.size, zgrid.size])
ey = np.zeros_like(ex)
ez = np.zeros_like(ex)
pf = ptm_preprocessing.PTMfields()
pf.set_grid(xgrid, ygrid, zgrid)
pf.sfields_0001.dat')
pf.write_file('ptm_data/ptm_fiel
```
<Overlap Ratio: 0.532724505327245>

---

--- 31 --
Question ID: bb68959040f9d60e5d44b71c03cdbfca7f860c20_0
Original Code:
```
def _read(fname):
    try:
        return open(path.join(path.dirname(__file__), fname)).read()
    except IOError:
        return ''
```


Overlapping Code:
```
 _read(fname):
try:
return open(path.join(path.dirname(__file__), fname)).read()
except IOError:
return ''
```
<Overlap Ratio: 0.9724770642201835>

---

--- 32 --
Question ID: 9f339190f0ef239c8b99606a869e09ec3bd344b0_2
Original Code:
```
def top(stack):
    if len(stack):
        return stack[-1]
    return None
```


Overlapping Code:
```
f top(stack):
if len(stack):
return stack[-1]
retu
```
<Overlap Ratio: 0.847457627118644>

---

--- 33 --
Question ID: a7cb7c0cbe1316b9f471be562240d8e6e68b5ee9_1
Original Code:
```
def get_items(list_, doc_type):
    data_table_names = {'PO': 'fss.dbo.bsPRItem', 'SO': 'fss.dbo.bsSaleOrderItem'}
    resultDict = {}
    item_list = []
    try:
        table_name = data_table_names[doc_type]
    except KeyError as e:
        print(f'ERROR: DocType {e} not found')
        sys.exit()
        return ({}, [])
    for p in list_:
        doc_no = p[1]
        statement_items = f"SELECT * FROM {table_name}                            WHERE DocNo = '{doc_no}'"
        cursor.execute(statement_items)
        package = []
        for r in cursor:
            item_list.append(r)
            package.append(r)
        resultDict[r[1]] = package
    return (resultDict, item_list)
```


Overlapping Code:
```
y:
table_name = data_table_names[doc_type]
except no = p[1]
statement_items = f"SELECT * FROM {tabletatement_items)
package = []
for r in cursor:
item
```
<Overlap Ratio: 0.2803738317757009>

---

--- 34 --
Question ID: e376bb9a7337aed835807b7a81d670cdfa095d2c_10
Original Code:
```
def plot_values(registration_method):
    global metric_values, multires_iterations
    metric_values.append(registration_method.GetMetricValue())
    clear_output(wait=True)
    plt.plot(metric_values, 'r')
    plt.plot(multires_iterations, [metric_values[index] for index in multires_iterations], 'b*')
    plt.xlabel('Iteration Number', fontsize=12)
    plt.ylabel('Metric Value', fontsize=12)
    plt.show()
```


Overlapping Code:
```
def plot_values(registration_method):
global metric_values, multires_iterations
metric_values.append(registration_method.GetMetricValue()put(wait=True)
plt.plot(metric_values, 'r')
plt.plot(multires_iterations, [metric_values[index] for index in multires_iterations], 'b*')
plt.xlabel('Iteration Number', fontsize=12)
plt.ylabel('Metric Value', fontsi
```
<Overlap Ratio: 0.9261213720316622>

---

--- 35 --
Question ID: 56d66414c84d9d6eef940c2d2989f3d4532fde9e_8
Original Code:
```
def pose_to_transformation(pose):
    """
    Convert poses to transformation matrix
    """
    temp_0 = pose[0]
    temp_1 = pose[1]
    temp_2 = pose[2]
    temp_x = pose[3]
    temp_y = pose[4]
    temp_z = pose[5]
    temp_w = pose[6]
    pose[4:6] *= -1
    pose[0] *= -1
    rotMat = quat2mat(pose[3:])
    translation_vector = np.array([[pose[0]], [pose[1]], [pose[2]]]) / 1000
    print(translation_vector)
    rot_mat_2 = np.array([[0, 1, 0, 0], [-1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])
    flip_x = np.eye(4)
    flip_x[0, 0] *= -1
    trans = flip_x @ rot_mat_2
    translation_offset = np.ones((3, 1)) * 1
    transformation_mat = np.vstack((np.hstack((rotMat, translation_vector + 0.5)), np.array([0, 0, 0, 1])))
    print(transformation_mat.shape)
    return transformation_mat @ trans
```


Overlapping Code:
```
temp_0 = pose[0]
temp_1 = pose[1]
temp_2 = pose[2] pose[3]
temp_y = pose[4]
temp_z = pose[5]
temp_w = pose[6]
pose[4:6] *= -1
p[3:])
translation_vector = np.array([[pose[0]], [pose[1]], [pose[2]]]) / 1, 0, 0], [-1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]p_x[0, 0] *= -1
trans = flip_x @ rot_mat_2
translation_offset = np.ones((3p.array([0, 0, 0, 1])))
print(transformation_mat.s
```
<Overlap Ratio: 0.5288326300984529>

---

--- 36 --
Question ID: d7f4490b643639fa5528139f79a00b5f88a06a1f_0
Original Code:
```
def v_bool(Inout=InOut_t.Internal_t, Default=0, varSigConst=None):
    value = Default
    if type(Default).__name__ == 'int':
        Default = "'" + str(Default) + "'"
    return v_symbol(v_type='boolean', DefaultValue=Default, Inout=Inout, includes=slv_includes, value=value, varSigConst=varSigConst, Bitwidth=1, primitive_type='boolean')
```


Overlapping Code:
```
ne):
value = Default
if type(Default).__name__ == 
```
<Overlap Ratio: 0.1557632398753894>

---

--- 37 --
Question ID: db3168c7636e669ffaa426160820cfab9e45c298_3
Original Code:
```
def event(self, event):
    if event.type() == QEvent.KeyPress and event.key() == Qt.Key_Tab:
        self.emit(SIGNAL('tabPressed'))
        return True
```


Overlapping Code:
```
def event(self, event):
if event.type() == QEvent.KeyPress and event.key() == Qt.Key_Tab:

```
<Overlap Ratio: 0.6766917293233082>

---

--- 38 --
Question ID: 58b7827b7aa5bd50934dcfc83e24f6888bb30df8_3
Original Code:
```
@pytest.fixture()
def enrollment_data(user):
    """enrollment data for testing"""
    bootcamps = BootcampFactory.create_batch(2)
    enrollments = BootcampRunEnrollmentFactory.create_batch(3, user=user, active=factory.Iterator([False, True, True]), bootcamp_run__bootcamp=factory.Iterator([bootcamps[0], bootcamps[0], bootcamps[1]]))
    unenrollableRun = BootcampRunFactory.create(end_date=now_in_utc() - timedelta(days=1))
    order = OrderFactory.create(user=user)
    return SimpleNamespace(bootcamps=bootcamps, enrollments=enrollments, unenrollable_run=unenrollableRun, order=order)
```


Overlapping Code:
```

"""enrollment data for testing"""
bootcamps = BootcampFactory.create_batch(2)
enrollments = Bootcam
```
<Overlap Ratio: 0.17699115044247787>

---

--- 39 --
Question ID: d07c3f5d3f8bceba3730181638eb4ed2e60e2c51_0
Original Code:
```
def get_toplevel_elements(str_, element, parsed=None):
    if parsed is None:
        parsed = bs4.BeautifulSoup(str_, 'html.parser')
    (skip, result) = ([], [])
    for l in parsed(element):
        if str(l) not in skip:
            result.append(l)
        skip += [str(lNested) for lNested in l(element)]
    return result
```


Overlapping Code:
```
toplevel_elements(str_, element, parsed=None):
if parsed is None:
parsed = bs4d(element):
if str(l) not in skip:
result.append(l)
skip 
```
<Overlap Ratio: 0.4891304347826087>

---

--- 40 --
Question ID: 60908cb818b31508f23a6d5114dd56b36a1c0b97_0
Original Code:
```
def factory_create_activity(name: str=None) -> Activity:
    record = RecordFactory()
    now = timezone.localtime()
    start = now
    end = now + datetime.timedelta(hours=1)
    spentTime = (end - start).seconds
    return Activity.objects.create(record_id=record.id, name=name, start=start, end=end, spent_time=spentTime)
```


Overlapping Code:
```
ne) -> Activity:
record = RecordFactory()
now = timezone.localtime()
start = now
end = now + datetim
```
<Overlap Ratio: 0.33222591362126247>

---

--- 41 --
Question ID: 109ffa951504bc25a96cc88a0b6aa9552c14314b_51
Original Code:
```
def _create_nat_match_obj(**kwargs):
    natMatchObj = {'ethertype': 'IPv4'}
    delta = set(kwargs.keys()) - set(MATCH_KEYS)
    if delta:
        raise Exception(_('Invalid keys for NAT match: %s'), delta)
    natMatchObj.update(kwargs)
    return natMatchObj
```


Overlapping Code:
```
type': 'IPv4'}
delta = set(kwargs.keys()) - set(MATCH_KEYS)
i
```
<Overlap Ratio: 0.26180257510729615>

---

--- 42 --
Question ID: 3db72119b5d317902b6f4df26947aae91390d2a3_0
Original Code:
```
def VAE(inputs, input_lengths, filters, kernel_size, strides, num_units, is_training, scope):
    with tf.variable_scope(scope):
        outputs = ReferenceEncoder(inputs=inputs, input_lengths=input_lengths, filters=filters, kernel_size=kernel_size, strides=strides, is_training=is_training)
        mu = tf.layers.dense(outputs, num_units, name='mean', activation=tf.nn.relu)
        logVar = tf.layers.dense(outputs, num_units, name='vari', activation=tf.nn.relu)
        std = tf.exp(logVar * 0.5)
        z = tf.random_normal(shape=[tf.shape(mu)[0], num_units], mean=0.0, stddev=1.0)
        output = mu + z * std
        style_embeddings = tf.layers.dense(output, hp.encoder_depth)
        return (style_embeddings, mu, logVar)
```


Overlapping Code:
```
 input_lengths, filters, kernel_size, strides, num_units, is_training, scope):
with tf.variable_scope(scope):
outputs = References, filters=filters, kernel_size=kernel_size, strides=strides, ng=is_training)
mu = tf.layers.dense(outputs, num_ = tf.layers.dense(outputs, num_units, name='vari'5)
z = tf.random_normal(shape=[tf.shape(mu)[0], num_units], mean=0.0, stddev=1.0)
output = mu + z * std
style_embeddings = tf.layers.dense(output, hp.
```
<Overlap Ratio: 0.6641566265060241>

---

--- 43 --
Question ID: 8f760a85301ff2c85907784935bbde2796fc3fc2_7
Original Code:
```
def get_current_commit_id() -> str:
    """Get current commit id

    Returns:
        str: Current commit id
    """
    command = 'git rev-parse HEAD'
    commitId = subprocess.check_output(command.split()).strip().decode('utf-8')
    return commitId
```


Overlapping Code:
```
ef get_current_commit_id() -> str:
"""Get current commit id
Returns:
str: Current commit id
"""
commsubprocess.check_output(command.split()).strip().decode('utf-8')
```
<Overlap Ratio: 0.7488584474885844>

---

--- 44 --
Question ID: a1f55cf8e4ae2523b3711b8a9b769203a9a8a01e_0
Original Code:
```
def search(keywords, max_results=None):
    url = 'https://html.duckduckgo.com/html/'
    params = {'q': keywords}
    headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:86.0) Gecko/20100101 Firefox/86.0'}
    yielded = 0
    while True:
        res = requests.post(url, data=params, headers=headers)
        doc = html.fromstring(res.text)
        results = [a.get('href') for a in doc.cssselect('#links .links_main a')]
        for result in results:
            yield result
            time.sleep(0.1)
            yielded += 1
            if max_results and yielded >= max_results:
                return
        try:
            form = doc.cssselect('.results_links_more form')[-1]
        except IndexError:
            return
        params = dict(form.fields)
```


Overlapping Code:
```
ults=None):
url = 'https://html.duckduckgo.com/html/'
params = {'q': keywords}
headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:86.0) Gecko/20100101 Firefox/86.0'}
yielded = 0
while True:
res = requests.post(url, data=params, headers=headers)
doc = html.fromstring(res.text)
results = [a.get('href') for a in doc.cssselect('#links .links_main a')]
for result in results:
yield result
time.sleep(0.1)
yielded += 1
if max_results and yielded >= max_results:
return
try:
form = doc.cssselect('.results_links_more form')[-1]
except IndexError:
return
params = dict(
```
<Overlap Ratio: 0.9347471451876019>

---

--- 45 --
Question ID: b97e6f9295654f19c6ba8f5fa580dfd29d44c69e_5
Original Code:
```
def edit_seller_selector(brief, sellers_to_invite):
    if brief.lot.slug != 'atm' and sellers_to_invite:
        sellerSelector = brief.data.get('sellerSelector', '')
        if len(sellers_to_invite.keys()) > 0 and sellerSelector and (sellerSelector == 'oneSeller'):
            brief.data['sellerSelector'] = 'someSellers'
```


Overlapping Code:
```
ef edit_seller_selector(brief, sellers_to_invite):
if brief.lot.slug != 'atm' and sellers_to_invite:, '')
if len(sellers_to_invite.keys()) > 0 and sel
```
<Overlap Ratio: 0.5119453924914675>

---

--- 46 --
Question ID: 299d845b4ecb3a12712dbe607958f777e7c89d76_1
Original Code:
```
def dms2dec(dmsStr):
    """Return decimal representation of DMS
    
    >>> dms2dec(utf8(48°53'10.18"N))
    48.8866111111F
    
    >>> dms2dec(utf8(2°20'35.09"E))
    2.34330555556F
    
    >>> dms2dec(utf8(48°53'10.18"S))
    -48.8866111111F
    
    >>> dms2dec(utf8(2°20'35.09"W))
    -2.34330555556F
    
    """
    dmsStr = re.sub('\\s', '', dmsStr)
    sign = -1 if re.search('[swSW]', dmsStr) else 1
    numbers = list(filter(len, re.split('\\D+', dmsStr, maxsplit=4)))
    degree = numbers[0]
    minute = numbers[1] if len(numbers) >= 2 else '0'
    second = numbers[2] if len(numbers) >= 3 else '0'
    frac_seconds = numbers[3] if len(numbers) >= 4 else '0'
    second += '.' + frac_seconds
    return sign * (int(degree) + float(minute) / 60 + float(second) / 3600)
```


Overlapping Code:
```
"""Return decimal representation of DMS

>>> dms2dec(utf8(48°53'10.18"N))
48.8866111111F

>>> dms2dec(utf8(2°20'35.09"E))
2.34330555556F

>>> dms2dec(utf8(48°53'10.18"S))
-48.8866111111F

>>> dms2dec(degree = numbers[0]
minute = numbers[1] if len(numbers) >= 2 else '0'
second = numbers[2] if len(numbers) >= 3 else '0'
frac_seconds = numbers[3] if len(numbers) >= 4 else '0'onds
return sign * (int(degree) + float(minute) / 60 + float(second) / 3600
```
<Overlap Ratio: 0.6550218340611353>

---

--- 47 --
Question ID: 40cc7483e6638afc906172fe0592b4a30fce27e5_5
Original Code:
```
@dp.message_handler(commands=['creds'])
async def handler_creds(message: types.Message, state: FSMContext):
    username = await db.get_username(message.from_user['id'])
    if username is None:
        await message.answer('You have to be registered to view creds! Use /reg')
        return
    username = username.decode()
    password = (await db.get_secret(message.from_user['id'])).decode()
    await message.answer(f'Username: {username}\nPassword: {password}')
```


Overlapping Code:
```
er_creds(message: types.Message, state: FSMContext):
username = await db.get_username(message.from_uage.answer('You have to be registered to view cred
username = username.decode()
password = (await db
```
<Overlap Ratio: 0.46403712296983757>

---

--- 48 --
Question ID: 13e50b7266dceea05106c82bd6e330375bd50ee2_1
Original Code:
```
def timeline(request):
    ts = Timeline.objects.all()
    contaxt = {'ts': ts}
    return render(request, 'other/timeline.html', contaxt)
```


Overlapping Code:
```
imeline(request):
ts = Timeline.objects.all()
cont
```
<Overlap Ratio: 0.3968253968253968>

---

--- 49 --
Question ID: b167197574c1ae8ea60f5374ce76c84554e825b9_0
Original Code:
```
def upgrade_rdr():
    op.execute('ALTER TABLE `workbench_researcher` MODIFY `degree` JSON;')
    op.execute('ALTER TABLE `workbench_researcher_history` MODIFY `degree` JSON;')
    op.execute('ALTER TABLE `workbench_researcher` MODIFY `ethnicity` smallint(6);')
    op.execute('ALTER TABLE `workbench_researcher_history` MODIFY `ethnicity` smallint(6);')
```


Overlapping Code:
```
LTER TABLE `workbench_researcher_history` MODIFY `degrTABLE `workbench_researcher` MODIFY `ethnicity` smLTER TABLE `workbench_researcher_history` MODIFY `ethnicity` sma
```
<Overlap Ratio: 0.4970414201183432>

---

--- 50 --
Question ID: c5d6e28510e9bfcfa523c2d73057ed4afa27c4d5_1
Original Code:
```
def _test_overlap(hits):
    tester = np.zeros(len(hits), dtype=strax.time_fields)
    tester['time'] = hits['time'] - (hits['left_integration'] - hits['left']) * hits['dt']
    tester['endtime'] = hits['time'] + (hits['right_integration'] - hits['left']) * hits['dt']
    for ch in np.unique(hits['channel']):
        mask = hits['channel'] == ch
        testCh = np.all(tester[mask]['endtime'][:-1] - tester[mask]['time'][1:] <= 0)
        assert np.all(testCh), 'Hits overlap!'
```


Overlapping Code:
```
hits), dtype=strax.time_fields)
tester['time'] = hits['time'] - (hits['left_integration'] - hits['le'dt']
for ch in np.unique(hits['channel']):
mask =ester[mask]['time'][1:] <= 0)
assert np.all(testCh
```
<Overlap Ratio: 0.45454545454545453>

---

--- 51 --
Question ID: 65850953a74773d8a1f36d8cdb7ca6cda7bf01af_10
Original Code:
```
def message(flag=None):
    (excType, exc_obj, exc_tb) = sys.exc_info()
    if flag is None:
        return exc_obj.message
    return traceback.extract_tb(exc_tb)[0][3]
```


Overlapping Code:
```
s None:
return exc_obj.message
return traceback.ex
```
<Overlap Ratio: 0.33557046979865773>

---

--- 52 --
Question ID: c1e6e718242cba1e86b4e900ac601b58a5f8729f_2
Original Code:
```
def count_byte_values(bss: Iterable[ByteString]) -> list[Counter[int]]:
    """Returns a list of Counters, each of which records the values of the
    bytes at the corresponding index in the given ByteStrings."""
    countsForIdx: list[Counter[int]] = []
    bs_len = None
    for bs in bss:
        if bs_len is None:
            bs_len = len(bs)
            countsForIdx = [Counter() for _ in range(bs_len)]
        assert len(bs) == bs_len
        for (i, b) in enumerate(bs):
            countsForIdx[i][b] += 1
    return countsForIdx
```


Overlapping Code:
```
String]) -> list[Counter[int]]:
"""Returns a list of Counters, each of which records the values of the
bytes at the corresponding index in the given B= []
bs_len = None
for bs in bss:
if bs_len is Nonr _ in range(bs_len)]
assert len(bs) == bs_len
for
```
<Overlap Ratio: 0.5494505494505495>

---

--- 53 --
Question ID: f3e180cb426f2d4f4869990002b54890e11a8ca1_1
Original Code:
```
def exponential(db, utility, eps=1e-05):
    """
    Goal:
        The Exponential mechanism is a DP method for answering categorical queries,
        by sampling from an exponential distribution over possible choices.
    Guaranties:
        1. (eps,0) Differential Privacy
        2. Accuracy:
           Let utility: N ^ |Universe| x categories -> R
           Denote c* = exponential(db, utility, eps)
                  s = utility.sensitivity
                  R = utility.categories
                  Opt(u,x) = max_{c in R} u(x,r)
           Then forall t > 0
                  P[u(x,c*) <= Opt(u,x) - (2s / epsilon) (ln(|R|) + t)] <= e^-t
    """
    assert isinstance(db, Database)
    assert isinstance(utility, Utility)
    assert db.rep == 'histogram'
    assert eps > 0
    evals = np.array([utility.value(db, cat) for cat in utility.categories])
    consts = eps / (2 * utility.sensitivity)
    weights = np.exp(consts * evals)
    res = np.random.choice(utility.categories, p=normalize(weights, ord=1))
    return res
```


Overlapping Code:
```

The Exponential mechanism is a DP method for answering categorical queries,
by sampling from an exponential distribution over possible choices.
Guaranties:
1. (eps,0) Differential Privacy
2. Accuracy:
Let utility: N ^ |Universe| x categories -> R
Denote c* = exponential(db, utility, eps)
s = utility.sensitivity
R = utility.categories
Opt(u,x) = max_{c in R} u(x,r)
Then forall t > 0
P[u(x,c*) <= Opt(u,x) - (2s / epsilon) (ln(|R|) + t)] <= e^-t
""(utility.categories, p=normalize(weights, ord=1))

```
<Overlap Ratio: 0.5931198102016607>

---

--- 54 --
Question ID: 748d69ab544fa46cb8d58415b5d688a6b34e3694_0
Original Code:
```
def map_dists(dists: Dict[str, AbstractMessage], values: Dict[str, np.ndarray], _call: str='logpdf') -> Iterator[Tuple[str, np.ndarray]]:
    """
    Calls a method (default: logpdf) for each Message in dists
    on the corresponding value in values
    """
    for v in dists.keys() & values.keys():
        dist = dists[v]
        if isinstance(dist, AbstractMessage):
            yield (v, getattr(dist, _call)(values[v]))
```


Overlapping Code:
```
 np.ndarray]]:
"""
Calls a method (default: logpdf) for each Message in dists
on the corresponding value in values
"""
for v in dists.keys() & values.keys():
dist = dists[v]
if isinstance(dist, AbstractMessag
```
<Overlap Ratio: 0.5517241379310345>

---

--- 55 --
Question ID: 85ecf5da466f0df65d97156a925dd2cbb9cc304a_2
Original Code:
```
def predict_labels_datasets(weight0, weight1, weight23, data, transform_x, degree):
    """ Generate the predictions given the weigth of the data set with num jet 0, 1  or {2,3} """
    ids = np.arange(data.shape[0])
    (tx_0, tx_1, tx_23) = transform_x(data, degree)
    ids0 = ids[data[:, 22] == 0]
    y_pred0 = np.dot(tx_0, weight0)
    ids1 = ids[data[:, 22] == 1]
    y_pred1 = np.dot(tx_1, weight1)
    ids23 = ids[data[:, 22] > 1]
    y_pred23 = np.dot(tx_23, weight23)
    yPred = np.concatenate((np.concatenate((y_pred0, y_pred1), axis=None), y_pred23), axis=None)
    ids = np.concatenate((np.concatenate((ids0, ids1), axis=None), ids23), axis=None)
    y = np.transpose(np.array([ids, yPred]))
    y = y[y[:, 0].argsort()][:, 1]
    y[np.where(y <= 0)] = -1
    y[np.where(y > 0)] = 1
    return y
```


Overlapping Code:
```
_datasets(weight0, weight1, weight23, data, transfn the weigth of the data set with num jet 0, 1 or {
ids0 = ids[data[:, 22] == 0]
y_pred0 = np.dot(tx_0, we
ids23 = ids[data[:, 22] > 1]
y_pred23 = np.dot(tx np.concatenate((np.concatenate((y_pred0, y_pred1), axi
```
<Overlap Ratio: 0.3503355704697987>

---

--- 56 --
Question ID: 9681618928c5641d65d743ec3954a60d579c7fcb_15
Original Code:
```
def bezierSliceFromTo(points, minParam, maxParam):
    from_p = bezierPointAt(points, minParam)
    from_t = bezierTangentAt(points, minParam)
    to_p = bezierPointAt(points, maxParam)
    to_t = bezierTangentAt(points, maxParam)
    param_diff = maxParam - minParam
    return [from_p, from_p + from_t * param_diff, to_p - to_t * param_diff, to_p]
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 57 --
Question ID: 1bafe6e69cd8c367d829bb77f059218e660a5475_2
Original Code:
```
def computeStarsItembased(corated, target_bid, model):
    """
    corated - {bid: star, ...}
    """
    if corated == None:
        return None
    corated.pop(target_bid, None)
    bidCor = list(corated.keys())
    collect = []
    for b in bidCor:
        pair = None
        if b < target_bid:
            pair = (b, target_bid)
        else:
            pair = (target_bid, b)
        w = model.get(pair)
        if w != None:
            collect.append((pair, w, b))
    collect.sort(key=lambda x: x[1], reverse=True)
    neighbors = collect[:N_NEIGHBORS_ITEMBASED]
    sum_w = 0
    n = 0
    for (p, w, b) in neighbors:
        star = corated[b]
        n += star * w
        sum_w += w
    if sum_w == 0:
        return None
    else:
        return n / sum_w
```


Overlapping Code:
```
def computeStarsItembased(corated, target_bid, model):
"""
corated - {bid: star, ...}
"""
if corated == None:
return None
corated.pop(target_bid, NoneNone
if b < target_bid:
pair = (b, target_bid)
else:
pair =collect.sort(key=lambda x: x[1], reverse=True)
neighbors = collect[:N_NEIGHBORS_ITEMBASED]
sum_w = 0 neighbors:
star = corated[b]
n += star * w
sum_w += w
if sum_w == 0:
return None
else:
return n
```
<Overlap Ratio: 0.6923076923076923>

---

--- 58 --
Question ID: e3a8b073f0f64789f2b3c0b201ed953476be70ca_2
Original Code:
```
def get_quarter(month):
    if month in ['January', 'April', 'July', 'October']:
        return True
    else:
        return False
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 59 --
Question ID: c5b9d51ce8759bd19c31258626e669df3a3907b6_1
Original Code:
```
def bias_variable(shape, bias=0.01):
    """Function to initialize the bias. For ReLUs, it MUST be > 0.0

    :param shape: the shape of the bias variable
    :param val: the value of the bias variable
    """
    initial = tf.constant(bias, shape=shape)
    return tf.Variable(initial)
```


Overlapping Code:
```
as=0.01):
"""Function to initialize the bias. For ReLUs, it MUST be > 0.0
:param shape: the shape of the bias variable
:param val: the value of the bias variable
"""
initial = tf.constant(bias, shape=
```
<Overlap Ratio: 0.7662835249042146>

---

--- 60 --
Question ID: 5f30e702c766d9408e95e8e3b793cedd534e612e_0
Original Code:
```
def get_colorscale_values(cmap):
    """Get the colors composing a plotly colorscale.

    Parameter
    ---------
    cmap : str
        Name of the Plotly colorscale

    Returns
    -------
    colorscale : array_like
        Colors associated to the colormap
    """
    import plotly
    rev = '_r' if '_r' in cmap.lower() else ''
    cmap = cmap.lower().replace('_r', '')
    colorscales = plotly.colors.named_colorscales()
    assert cmap in colorscales
    ensembles = ['sequential', 'diverging', 'qualitative']
    for e in ensembles:
        cmaps = dir(eval(f'plotly.colors.{e}'))
        cmapsLower = [c.lower() for c in cmaps]
        if cmap in cmapsLower:
            cmap_idx = cmapsLower.index(cmap)
            return eval(f'plotly.colors.{e}.{cmaps[cmap_idx]}{rev}')
    assert ValueError(f'{cmap} is not a predefined colorscale {colorscales}')
```


Overlapping Code:
```
def get_colorscale_values(cmap):
"""Get the colors composing a plotly colorscale.
Parameter
---------
cmap : str
Name of the Plotly colorscale
Returns
-------
colorscale : array_like
Colors associated to the colormap
"""
import plotly
rev = '_r' if '_r' in cmap.lower() else ''
cmap = cmap.lower().replace('_r', '')
colorscales = plotly.colors.named_colorscales()
assert cmap in colorscales
ensembles = ['sequential', 'diverging', 'qualitative']
for e in ensembles:
cmaps = dir(eval(f'plotly.colors.{cmap)
return eval(f'plotly.colors.{e}.{cmaps[cmap_
```
<Overlap Ratio: 0.7503410641200545>

---

--- 61 --
Question ID: 5ea5ff02510da4eb6075ea3e0e4184f4d733ca2e_1
Original Code:
```
def detectFacesByRekognition(image_binary: bytes) -> List[List[float]]:
    client = boto3.client('rekognition')
    response = client.detect_faces(Image={'Bytes': image_binary}, Attributes=['ALL'])
    faces = list()
    for faceInfo in response['FaceDetails']:
        faces.append(faceInfo['BoundingBox'])
        print(faceInfo['BoundingBox'])
    return faces
```


Overlapping Code:
```
kognition(image_binary: bytes) -> List[List[float]]:
client = boto3.client('rekognition')
response = client.detect_faces(Image={'Bytes': image_binary}, Attributes=['
```
<Overlap Ratio: 0.5030487804878049>

---

--- 62 --
Question ID: 4a4bfa3d96580a5d40c5b2e5e994ece0ab585163_10
Original Code:
```
def test_event_graph_accumulated_time_before_start(mocker: Any) -> None:
    message = DeferredMessage(MyMessage, 'unittest_args', kwargs_field='unittest_kwargs')
    topic = Topic(MyMessage)
    start = Event(message, topic, 0.0, 1.0)
    graph = EventGraph(start)
    parent = Event(message, topic, 0.0, 1.0)
    child = Event(message, topic, -3.0, 1.0)
    graph.add_event_at_end(parent, start)
    with pytest.raises(LabGraphError):
        graph.add_event_at_end(child, parent)
```


Overlapping Code:
```
_event_graph_accumulated_time_before_start(mocker:ic = Topic(MyMessage)
start = Event(message, topic, 0.0, 1.0)
graph = EventGraph(start)
parent = Event(message, topic, 0.0, 1.0)
child = Event(message, topic, -3.0, 1.0)
graph.add_event_at_end(parent, start)
with pytest.raises(LabGraphError):
g
```
<Overlap Ratio: 0.665158371040724>

---

--- 63 --
Question ID: 4ccaae78da187b459e1b8de6f377e49ceb0a7fea_0
Original Code:
```
def _get_files_from_arcs(extension, arc_list=None, arc_path=None):
    use_concurrency = False
    if arc_path:
        arc_list = find_files(arc_path, '.arc')
    elif arc_list:
        arc_list = arc_list
    else:
        arc_list = ARC_FILES
    toExport = [arc_file for arc_file in arc_list if arc_file not in CACHE_ARC]
    if toExport and use_concurrency:
        concurrent_unpack(arc_list, CACHE_ARC, extension)
    elif toExport and (not use_concurrency):
        for arc_file in toExport:
            _unpack_arc_in_temp(arc_file, CACHE_ARC)
    (files, ids) = _get_files_and_ids(extension, arc_list)
    return (files, ids)
```


Overlapping Code:
```
m_arcs(extension, arc_list=None, arc_path=None):
u
arc_list = find_files(arc_path, '.arc')
elif arc_list:
arc_list = arc_list
else:
arc_list = ARC_FIL_concurrency:
concurrent_unpack(arc_list, CACHE_AR
```
<Overlap Ratio: 0.3656307129798903>

---

--- 64 --
Question ID: 66c3929472e5beb4f365dc128305de4970e9e7a7_1
Original Code:
```
def extract_sentences_and_labels_from_files(files):
    sentences = []
    labels = []
    for infile in files:
        with open(infile) as file:
            for line in file:
                (sentence, label) = parse_infile_line(line)
                labels.append(label)
                sentences.append(sentence)
            file.close()
    return (sentences, labels)
```


Overlapping Code:
```
rom_files(files):
sentences = []
labels = []
for infile in files:
with open(infile) as file:
for line)
labels.append(label)
sentences.append(sentence)
```
<Overlap Ratio: 0.5434782608695652>

---

--- 65 --
Question ID: 0924022c1119a245a7cbca668d233e67f604810f_12
Original Code:
```
def get_shifted_3D(tau, X, Y, Z, cam_left, cam_top, traj_left, traj_top, timespan):
    (corr_top, corrLeft) = shift_cam_coord(timespan, traj_top, traj_left, tau)
    len_traj = len(corr_top)
    x = np.zeros(np.shape(X)) * np.nan
    y = np.zeros(np.shape(Y)) * np.nan
    z = np.zeros(np.shape(Z)) * np.nan
    for i in range(0, len_traj):
        if not (np.isnan(X[i]) or np.isnan(Y[i]) or np.isnan(Z[i])):
            (A, B) = make_system_mat(cam_top, cam_left, corrLeft[i, :], corr_top[i, :])
            (x[i], y[i], z[i]) = np.linalg.solve(np.matrix(A), np.matrix(B).T)
    return (x, y, z, corr_top, corrLeft)
```


Overlapping Code:
```
D(tau, X, Y, Z, cam_left, cam_top, traj_left, trajoord(timespan, traj_top, traj_left, tau)
len_traj = len(corr_top)
x = np.zeros(np.shape(X)) * np.nan
y = np.zeros(np.shape(Y)) * np.nan
z = np.zeros(np.shape(Z)) * np.nan
for i in range(0, len_traj):
if not (np.isnan(X[i]) or np.isnan(Y[i]) or np.isn
```
<Overlap Ratio: 0.5376344086021505>

---

--- 66 --
Question ID: f441d0b6f5533ef1211ad198d6e281b4230affcd_4
Original Code:
```
def test_class4_ex4():
    base_path = '../class4/exercises/exercise4'
    cmd_list = ['ansible-playbook', 'exercise4.yml']
    (stdOut, std_err, return_code) = subprocess_runner(cmd_list, exercise_dir=base_path)
    assert std_err == ''
    assert return_code == 0
```


Overlapping Code:
```
 = subprocess_runner(cmd_list, exercise_dir=base_path)
assert std_err == 
```
<Overlap Ratio: 0.2979591836734694>

---

--- 67 --
Question ID: f2310222e3119de7c2f2b3c8746814477e78d8d7_1
Original Code:
```
def class_add_student(student_id, student_name):
    """
    用于添加学生
    """
    cur.execute(f"insert into student_list values ({student_id},'{student_name}')")
    conn.commit()
```


Overlapping Code:
```
 class_add_student(student_id, student_name):
"""
ert into student_list values ({student_id},'{stude
```
<Overlap Ratio: 0.6369426751592356>

---

--- 68 --
Question ID: 78f066607cb84040dfcf6fa504ecdea051a0dfbc_3
Original Code:
```
def test_calculate_raises_with_no_active_phases_passed():
    """Passing inactive phases to calculate() raises a ConditionError."""
    with pytest.raises(ConditionError):
        calculate(ALFE_DBF, ['AL', 'VA'], ['AL13FE4'], T=1200, P=101325)
```


Overlapping Code:
```
ises_with_no_active_phases_passed():
"""Passing inactive phases to calculate() raises a ConditionErrest.raises(ConditionError):
calculate(ALFE_DBF, ['AL', 'VA'], [
```
<Overlap Ratio: 0.7149122807017544>

---

--- 69 --
Question ID: 3546a7402fd9a0f1b6c55afe3610cdd62558560c_3
Original Code:
```
def __get_stock_bar(code, start, end, freq):
    df = None
    _start = start.format()
    _end = end.format()
    if freq == util.FREQ_DAY or freq == util.FREQ_WEEK or freq == util.FREQ_MONTH:
        covert = {util.FREQ_DAY: 'D', util.FREQ_WEEK: 'W', util.FREQ_MONTH: 'M'}
        df = ts.get_stock_bar(code=code, start=_start, end=_end, freq=covert[freq], factors=['vr', 'tor'])
    else:
        covert = {util.FREQ_1M: '1MIN', util.FREQ_5M: '5MIN', util.FREQ_15M: '15MIN', util.FREQ_30M: '30MIN'}
        df = ts.tushare_bar(code=code, start=_start, end=_end, freq=covert[freq], factors=['vr', 'tor'])
    if not isinstance(df, pd.DataFrame):
        raise TypeError('df is unknown type %s' % type(df))
    elif df.empty:
        log.warn('%s from %s to %s bar[%s] is empty' % (code, start, end, freq))
    return df
```


Overlapping Code:
```
_stock_bar(code, start, end, freq):
df = None
_start = start.format()
_end = end.format()
if freq == util.FREQ_DAY or freq == util.FREQ_WEEK or freq =
if not isinstance(df, pd.DataFrame):
raise TypeError('df is unknown type %s' % type(df))
elif df.empty:
log.warn('%s from %s to %s bar[%s] is empty' % (code, start, end, freq))
return 
```
<Overlap Ratio: 0.45209176788124156>

---

--- 70 --
Question ID: 8644f9b2a8f01c213caf5bcbd4d123b465cabeeb_7
Original Code:
```
@leet2git.command()
@click.option('--source-repository', '-s', default='', help='the path to the folder where the code will be saved')
@click.option('--language', '-l', default='python3', help='the default language')
@click.option('--soft/--hard', default=True, help='A soft reset only erases the database. A hard reset also erase the files.')
@click.pass_obj
def reset(cm: ConfigManager, source_repository: str, language: str, soft: bool):
    """Reset the configuration file
    \x0c
    Args:
        source_repository (str, optional): the path to the folder where the code will be saved.
            Defaults to "".
        language (str, optional): the default language. Defaults to "python3".
        soft(bool, optional): the reset hardness. Defaults to soft.
    """
    if not soft:
        try:
            click.confirm(f"This will delete EVERY solution and test file inside                     the {cm.config['source_path']} folder.                      Still want to proceed?", abort=True)
        except Abort:
            return
        fileList = glob.glob(os.path.join(cm.config['source_path'], 'src', 'leetcode_*')) + glob.glob(os.path.join(cm.config['source_path'], 'tests', 'test_*'))
        for file in fileList:
            try:
                os.remove(file)
            except FileNotFoundError as e:
                click.secho(e.args)
    else:
        try:
            click.confirm('This will delete the question database. Still want to proceed?', abort=True)
        except Abort:
            return
    reset_config(cm, source_repository, language)
    cm.load_config()
    qdb = QuestionDB(cm.config)
    qdb.reset()
    if not soft:
        data = QuestionData(language=cm.config['language'])
        file_handler = create_file_handler(data, cm.config)
        file_handler.generate_repo(cm.config['source_path'])
```


Overlapping Code:
```
he path to the folder where the code will be savedick.pass_obj
def reset(cm: ConfigManager, source_repository: str, language: str, soft: bool):
"""Resository (str, optional): the path to the folder where the code will be saved.
Defaults to "".
language (str, optional): the default language. Defaults to "python3".
soft(bool, optional): the reset hardness. Defaults to soft.
"""
if not soft:
try:
click.cos.remove(file)
except FileNotFoundError as e:
clicl delete the question database. Still want to procig(cm, source_repository, language)
cm.load_config()
qdb = QuestionDB(cm.config)
qdb.reset()
if not ndler = create_file_handler(data, cm.config)
file_
```
<Overlap Ratio: 0.42258064516129035>

---

--- 71 --
Question ID: d1aed9946c2cb489d711ae8a1fe207359b86da6f_5
Original Code:
```
def buildStartEndBreakProb(fit, nSegments, tag):

    def sebBuilder(s):
        return ee.String(s).cat('_' + tag)
    segment_tag = buildSegmentTag(nSegments).map(sebBuilder)
    zeros = ee.Array(0).repeat(0, nSegments)
    mag_img = fit.select(tag).arrayCat(zeros, 0).float().arraySlice(0, 0, nSegments)
    return mag_img.arrayFlatten([segment_tag])
```


Overlapping Code:
```
akProb(fit, nSegments, tag):
def sebBuilder(s):
redSegmentTag(nSegments).map(sebBuilder)
zeros = ee.tag).arrayCat(zeros, 0).float().arraySlice(0, 0, nSegment
```
<Overlap Ratio: 0.4845679012345679>

---

--- 72 --
Question ID: b735786ce4c39a03aae76e4daf78a4867d561247_6
Original Code:
```
def test_subtraction_with_other_types():
    price1 = Money(40, 'EUR')
    price2 = Money(80, 'EUR')
    priceRange = MoneyRange(price1, price2)
    with pytest.raises(TypeError):
        priceRange - 1
```


Overlapping Code:
```
1 = Money(40, 'EUR')
price2 = Money(80, 'EUR')
pringe(price1, price2)
with pytest.raises(TypeError):
```
<Overlap Ratio: 0.5617977528089888>

---

--- 73 --
Question ID: 1869c8f32f7f9bd4afb8cbf0bd42e3c02a87fce7_11
Original Code:
```
def Vector4CrossProduct(vectorLeft, vectorRight):
    assert isinstance(vectorRight, Vector4)
    v = Vector4()
    v.x = vectorLeft.y * vectorRight.z - vectorLeft.z * vectorRight.y
    v.y = vectorLeft.z * vectorRight.x - vectorLeft.x * vectorRight.z
    v.z = vectorLeft.x * vectorRight.y - vectorLeft.y * vectorRight.x
    v.w = 0
    return v
```


Overlapping Code:
```
roduct(vectorLeft, vectorRight):
assert isinstance(vectorRight, Vector4)
v = Vector4()
v.x = vectorLeft.y * vectorRight.z - vectorLeft.z * vectorRight.y
v.y = vectorLeft.z * vectorRight.x - vectorLeft.x * vectorRight.z
v.z = vectorLeft.x * vectorRight.y - vectorLeft.y * vectorRight.x
v.w = 0
retu
```
<Overlap Ratio: 0.9339622641509434>

---

--- 74 --
Question ID: 6780c64eb55bdd7710a2ca7590d41b28234c58e4_220
Original Code:
```
def polyClipboard(*args, **kwargs):
    """
    The command allows the user to copy and paste certain polygonal attributes to a clipboard. These attributes are:  1)
    Shader (shading engine) assignment.  2) Texture coordinate (UV) assignment.  3) Color value assignment. Any combination
    of attributes can be chosen for the copy or paste operation. If the attribute has not been copied to the clipboard, then
    naturally it cannot be pasted from the clipboard. The copy option will copy the attribute assignments from a single
    source polygonal dag object or polygon component. If the source does not have the either UV or color attributes, then
    nothing will be copied to the clipboard. The paste option will paste the attribute assignments to one or more polygon
    components or polygonal dag objects. If the destination does not have either UV or color attributes, then new values
    will be assigned as needed. Additionally, there is the option to clear the clipboard contents
    
    Flags:
      - clear : cl                     (bool)          [create]
          When used, will mean to clear the specified attribute argument(s).
    
      - color : clr                    (bool)          [create]
          When used, will be to copy or paste color attributes
    
      - copy : cp                      (bool)          [create]
          When used, will mean to copy the specified attribute argument(s).
    
      - paste : ps                     (bool)          [create]
          When used, will mean to paste the specified attribute argument(s).
    
      - shader : sh                    (bool)          [create]
          When used, will be to copy or paste shader attributes
    
      - uvCoordinates : uv             (bool)          [create]
          When used, will be to copy or paste texture coordinate attributes                                  Flag can have
          multiple arguments, passed either as a tuple or a list.
    
    
    Derived from mel command `maya.cmds.polyClipboard`
    """
    pass
```


Overlapping Code:
```
 **kwargs):
"""
The command allows the user to copy and paste certain polygonal attributes to a clipboard. These attributes are: 1)
Shader (shading engine) assignment. 2) Texture coordinate (UV) assignment. 3) Color value assignment. Any combination
of attributes can be chosen for the copy or paste operation. If the attribute has not been copied to the clipboard, then
naturally it cannot be pasted from the clipboard. The copy option will copy the attribute assignments from a single
source polygonal dag object or polygon component. If the source does not have the either UV or color attributes, then
nothing will be copied to the clipboard. The paste option will paste the attribute assignments to one or more polygon
components or polygonal dag objects. If the destination does not have either UV or color attributes, then new values
will be assigned as needed. Additionally, there is the option to clear the clipboard contents

Flags:
- clear : cl (bool) [create]
When used, will mean to clear the specified attribute argument(s).

- color : clr (bool) [create]
When used, will be to copy or paste color attributes

- copy : cp (bool) [create]
When used, will mean to copy the specified attribute argument(s).

- paste : ps (bool) [create]
When used, will mean to paste the specified attribute argument(s).

- shader : sh (bool) [create]
When used, will be to copy or paste shader attributes

- uvCoordinates : uv (bool) [create]
When used, will be to copy or paste texture coordinate attributes Flag can have
multiple arguments, passed either as a tuple or a list.


Derived from mel command `maya.cmds.polyClipb
```
<Overlap Ratio: 0.97708082026538>

---

--- 75 --
Question ID: ce10512207649c9489cbc69c74570eefc9c463ff_0
Original Code:
```
def get_data_int():
    X = np.array([[2, 20, 3], [4, 50, 6], [7, 80, 9], [10, 110, 12]])
    yInt = np.array([1, 2, 3, 4])
    return (X, yInt)
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 76 --
Question ID: a0e82345e90e71c8a988186287df593c48a61aad_1
Original Code:
```
async def selectDB(userid):
    conn = sqlite3.connect('ID_DATA.db')
    c = conn.cursor()
    cursor = c.execute('SELECT *  FROM UIDDATA WHERE USERID = ?', (userid,))
    for row in cursor:
        if row[0]:
            if row[2]:
                return [row[2], 3]
            elif row[1]:
                return [row[1], 2]
            else:
                return None
        else:
            return None
```


Overlapping Code:
```
id):
conn = sqlite3.connect('ID_DATA.db')
c = conn.cursor()
cursor = c.executn [row[2], 3]
elif row[1]:
return [row[1], 2]
else
```
<Overlap Ratio: 0.450354609929078>

---

--- 77 --
Question ID: de5093d7a37e19119c9ed380921063f98f98a572_1
Original Code:
```
def solve_all(l, r):
    res.clear()
    nl = l.copy()
    for i in range(len(nl)):
        nl[i] = (frac(nl[i]), str(nl[i]))
    solve_all_rec(nl, frac(r))
    return res
```


Overlapping Code:
```

res.clear()
nl = l.copy()
for i in range(len(nl))
```
<Overlap Ratio: 0.34965034965034963>

---

--- 78 --
Question ID: 6a6c2ee6803eaaa2206bcf41874368968655c509_3
Original Code:
```
def tsne_plot(model):
    labels = []
    tokens = []
    print('Displaying t-SNE...')
    for word in model.wv.vocab:
        tokens.append(model[word])
        labels.append(word)
    tsne_model = TSNE(perplexity=40, n_components=2, init='pca', n_iter=2500, random_state=23)
    newValues = tsne_model.fit_transform(tokens)
    x = []
    y = []
    for value in newValues:
        x.append(value[0])
        y.append(value[1])
    plt.figure(figsize=(16, 16))
    for i in range(len(x)):
        plt.scatter(x[i], y[i])
        plt.annotate(labels[i], xy=(x[i], y[i]), xytext=(5, 2), textcoords='offset points', ha='right', va='bottom')
    plt.title('t-SNE')
    plt.show()
```


Overlapping Code:
```

for word in model.wv.vocab:
tokens.append(model[word])
labels.append(word)
tsne_model = TSNE(perplexity=40, n_components=2, init='pca', n_iter=2500, random_state=23)
newalues = tsne_model.fit_transform(tokens)
x = []
y = []
for value in newalues:
x.append(value[0])
y.append(value[1])
plt.figure(figsize=(16, 16))
for i in range(len(x)):
plt.scatter(x[i], y[i])
plt.annotate(labels[i], xy=(x[i], y[i]), xytext=(5, 2), textcoords='offset points', ha='right', va='bottom')
plt.
```
<Overlap Ratio: 0.8249566724436742>

---

--- 79 --
Question ID: 71850fd6a06c73964f1a9b9a4f6b911414e14aff_24
Original Code:
```
@pytest.mark.usefixtures('aftersocialregister_app')
def test_aftersocialregister(aftersocialregister_config, db_session):
    """Register fresh user and logs him in and check response if redirect from AfterSocialRegister."""
    profile = {'accounts': [{'domain': 'facebook.com', 'userid': '2343'}], 'displayName': 'teddy', 'verifiedEmail': 'we@po.pl', 'preferredUsername': 'teddy', 'emails': [{'value': 'aasd@bwwqwe.pl'}], 'name': 'ted'}
    credentials = {'oauthAccessToken': '7897048593434'}
    providerName = 'facebook'
    provider_type = 'facebook'
    request = testing.DummyRequest()
    request.user = None
    request.registry = aftersocialregister_config.registry
    request.remote_addr = '127.0.0.123'
    request.context = AuthenticationComplete(profile, credentials, providerName, provider_type)
    request.login_perform = MagicMock(name='login_perform')
    request.login_perform.return_value = {'status': True}
    view = SocialLoginViews(request)
    out = view()
    assert out.location == EVENT_PATH.format(AfterSocialRegister)
    transaction.commit()
    user = db_session.query(User).one()
    assert user.is_active
    assert user.provider_id('facebook') == profile['accounts'][0]['userid']
```


Overlapping Code:
```
sion):
"""Register fresh user and logs him in and check response if redirect from AfterSocialRegisteequest = testing.DummyRequest()
request.user = None
request.registry = aftersocialregister_config.registry
request.remote_addr = 7.0.0.123'
request.context = AuthenticationComplete(profile, credentials, provide provider_type)
request.login_perform = MagicMock(name='login_perform')
request.login_perform.return_value = {'status': True}
view = SocialLoginViews(request)
out = view()
assert out.location == EVENT_PATH.format(Aft
transaction.commit()
user = db_session.query(User).one()
assert user.is_active
assert user.provider_id('facebook') == profile['accounts'][0]['useri
```
<Overlap Ratio: 0.5912280701754385>

---

--- 80 --
Question ID: 9109af01b75d406c726ca60fbd26a94a9e80f374_18
Original Code:
```
def MultiscaleEntropy_mse(x, scaleFactor=[i for i in range(1, 21)], m=[2], r=[0.15], return_type='dict', safe_mode=False):
    """[Multiscale Entropy]

    Arguments:
        x {[input signal]} -- [an iterator of numbers]

    Keyword Arguments:
        scale_factor {list} -- [scale factors of coarse graining] (default: {[i for i in range(1,21)]})
        m {list} -- [m in sample entropy] (default: {[2]})
        r {list} -- [r in sample entropy] (default: {[0.15]})
        return_type {str} -- [can be dict or list] (default: {'dict'})
        safe_mode {bool} -- [if set True, type checking will be skipped] (default: {False})

    Raises:
        ValueError -- [some values too big]

    Returns:
        [dict or list as return_type indicates] -- [if dict, nest as [scale_factor][m][r] for each value of scale_factor, m, r; if list nest as [i][j][k] for lengths of scale_factor, m, r]
    """
    if not safe_mode:
        m = MultiscaleEntropy_check_type(m, int, 'm')
        r = MultiscaleEntropy_check_type(r, float, 'r')
        scaleFactor = MultiscaleEntropy_check_type(scaleFactor, int, 'scale_factor')
    try:
        x = np.array(x)
    except:
        print('x should be a sequence of numbers')
    if max(scaleFactor) > len(x):
        raise ValueError("the max scale_factor is bigger than x's length")
    sd = np.sqrt(np.var(x))
    ms_en = MultiscaleEntropy_init_return_type(return_type)
    for s_f in scaleFactor:
        y = MultiscaleEntropy_coarse_grain(x, s_f)
        if return_type == 'dict':
            ms_en[s_f] = MultiscaleEntropy_sample_entropy(y, m, r, sd, 'dict', True)
        else:
            ms_en.append(MultiscaleEntropy_sample_entropy(y, m, r, sd, 'list', True))
    if return_type == 'list':
        ms_en = [i[0] for i in ms_en]
        ms_en = [i[0] for i in ms_en]
    return ms_en
```


Overlapping Code:
```
nput signal]} -- [an iterator of numbers]
Keyword Arguments:
scale_factor {list} -- [scale factors of coarse graining] (default: {[i for i in range(1,21)]})
m {list} -- [m in sample entropy] (default: {[2]})
r {list} -- [r in sample entropy] (default: {[0.15]})
return_type {str} -- [can be dict or list] (default: {'dict'})
safe_mode {bool} -- [if set True, type checking will be skipped] (default: {False})
Raises:
ValueError -- [some values too big]
Returns:
[dict or list as return_type indicates] -- [if dict, nest as [scale_factor][m][r] for each value of scale_factor, m, r; if list nest as [iropy_init_return_type(return_type)
for s_f in scal)
else:
ms_en.append(MultiscaleEntropy_sample_entr
```
<Overlap Ratio: 0.4396984924623116>

---

--- 81 --
Question ID: d2664e1063dfac0585b27173768ffad2c031b7e9_8
Original Code:
```
def _InceptionV3_blockH(x):
    block1 = conv2d_bn(x, 320, (1, 1))
    block2 = conv2d_bn(x, 384, (1, 1))
    block2_1 = conv2d_bn(block2, 384, (1, 3))
    block2_2 = conv2d_bn(block2, 384, (3, 1))
    block2 = Concatenate()([block2_1, block2_2])
    block3 = conv2d_bn(x, 448, (1, 1))
    block3_1 = conv2d_bn(block3, 384, (3, 3))
    block3_2 = conv2d_bn(block3, 384, (1, 3))
    block3_3 = conv2d_bn(block3, 384, (3, 1))
    block3 = Concatenate()([block3_1, block3_2, block3_3])
    block4 = AveragePooling2D((3, 3), strides=(1, 1), padding='same')(x)
    block4 = conv2d_bn(block4, 192, (1, 1))
    x = Concatenate()([block1, block2, block3, block4])
    return x
```


Overlapping Code:
```
nv2d_bn(x, 320, (1, 1))
block2 = conv2d_bn(x, 384, (1, 1))
block2_1 = conv2d_bn(block2, 384, (1, 3))
block2_2 = conv2d_bn(block2, 384, (3, 1))
block2 = Concatenate()([block2_1, block2_2])
block3 = conv2d_bn(x, 448, (1, 1))
block3_1 = conv2d_bn(block3, 384, (3, 3))
block3_2 = conv2d_bn(block3, 384, (1, 3))
block3_3 = conv2d_bn(block3, 384, (3, 1))
block3 = Concatenate()([block3_1, block3_2, block3_3])
block4 = AveragePooling2D((3, 3), strides=(1, 1), padding='same')(x)
block4 = conv2d_bn(block4, 192, (1, 1))
x = Concatenate()([block1, block2, block3, block4])
return x
```
<Overlap Ratio: 0.9362745098039216>

---

--- 82 --
Question ID: be392b1159ec0d0cbf136ec1807d49c872f36a16_4
Original Code:
```
def plot_oi(ticker: str, expiry: str, min_sp: float, max_sp: float, calls_only: bool, puts_only: bool, export: str):
    """Plot open interest

    Parameters
    ----------
    ticker: str
        Ticker
    expiry: str
        Expiry date for options
    min_sp: float
        Min strike to consider
    max_sp: float
        Max strike to consider
    calls_only: bool
        Show calls only
    puts_only: bool
        Show puts only
    export: str
        Format to export file
    """
    options = tradier_model.get_option_chains(ticker, expiry)
    export_data(export, os.path.dirname(os.path.abspath(__file__)), 'oi_tr', options)
    current_price = tradier_model.last_price(ticker)
    if min_sp == -1:
        minStrike = 0.75 * current_price
    else:
        minStrike = min_sp
    if max_sp == -1:
        max_strike = 1.25 * current_price
    else:
        max_strike = max_sp
    if calls_only and puts_only:
        print('Both flags selected, please select one', '\n')
        return
    calls = options[options.option_type == 'call'][['strike', 'open_interest']]
    puts = options[options.option_type == 'put'][['strike', 'open_interest']]
    call_oi = calls.set_index('strike')['open_interest'] / 1000
    put_oi = puts.set_index('strike')['open_interest'] / 1000
    df_opt = pd.merge(call_oi, put_oi, left_index=True, right_index=True)
    df_opt = df_opt.rename(columns={'open_interest_x': 'OI_call', 'open_interest_y': 'OI_put'})
    max_pain = op_helpers.calculate_max_pain(df_opt)
    plt.style.use('classic')
    (fig, ax) = plt.subplots(figsize=plot_autoscale(), dpi=cfp.PLOT_DPI)
    if not calls_only:
        put_oi.plot(x='strike', y='open_interest', label='Puts', ax=ax, marker='o', ls='-', c='r')
    if not puts_only:
        call_oi.plot(x='strike', y='open_interest', label='Calls', ax=ax, marker='o', ls='-', c='g')
        ax.axvline(current_price, lw=2, c='k', ls='--', label='Current Price', alpha=0.7)
        ax.axvline(max_pain, lw=3, c='k', label=f'Max Pain: {max_pain}', alpha=0.7)
        ax.grid('on')
        ax.set_xlabel('Strike Price')
        ax.set_ylabel('Open Interest (1k) ')
        ax.set_xlim(minStrike, max_strike)
        if gtff.USE_ION:
            plt.ion()
        ax.set_title(f'Open Interest for {ticker.upper()} expiring {expiry}')
        plt.legend(loc=0)
        fig.tight_layout(pad=1)
    plt.show()
    plt.style.use('default')
    print('')
```


Overlapping Code:
```
ot open interest
Parameters
----------
ticker: str
Ticker
expiry: str
Expiry date for options
min_sp: float
Min strike to consider
max_sp: float
Max strike to consider
calls_only: bool
Show calls only
puts_only: bool
Show puts only
export: str
Format to export file
"""
options = tradier_model.get_option_chains(ticker, expiry)
export_data(export, os.path.dirname(os.path.abspath(__file__)), 'oi_t
current_price = tradier_model.last_price(ticker)
if min_spif max_sp == -1:
max_strike = 1.25 * current_price
else:
max_strike = max_sp
if calls_only and puts_only:
pr] / 1000
df_opt = pd.merge(call_oi, put_oi, left_index=True, right_index=True)
df_opt = df_opt.renam
max_pain = op_helpers.calculate_max_pain(df_opt)
plt.style.use( = plt.subplots(figsize=plot_autoscale(), dpi=cfp.PLOT_DPI)
if not calls_only:
put_oi.plotrike, max_strike)
if gtff.USE_ION:
plt.ion()
ax.set_title(f.legend(loc=0)
fig.tight_layout(pad=1)
plt.show()
plt.style.us
```
<Overlap Ratio: 0.4525301204819277>

---

--- 83 --
Question ID: 467014e3a54821c2e5ac7b33d2f939b0052d1b15_3
Original Code:
```
def run_task(hosts, command, timeout=None):
    """Create a task to run a command on each host in parallel.

    Args:
        hosts (list): list of hosts
        command (str): the command to run in parallel
        timeout (int, optional): command timeout in seconds. Defaults to None.

    Returns:
        Task: a ClusterShell.Task.Task object for the executed command

    """
    task = task_self()
    task.set_info('ssh_options', '-oForwardAgent=yes')
    kwargs = {'command': command, 'nodes': NodeSet.fromlist(hosts)}
    if timeout is not None:
        kwargs['timeout'] = timeout
    task.run(**kwargs)
    return task
```


Overlapping Code:
```
ef run_task(hosts, command, timeout=None):
"""Create a task to run a command on each host in parallel.
Args:
hosts (list): list of hosts
command (str): the command to run in parallel
timeout (int, optional): command timeout in seconds. Defaults to None.
Returns:
Task: a ClusterShell.Task.Task object for the executed command
"""
task = tas: NodeSet.fromlist(hosts)}
if timeout is not None:
kwargs['timeout'] = timeout

```
<Overlap Ratio: 0.7659963436928702>

---

--- 84 --
Question ID: dac2bf672e1bd9ca92568b7538b014b4a37dd949_3
Original Code:
```
def find_euler_random(n):
    while True:
        el = np.array([random.randint(0, 4) * 2 for x in range(n + 1)])
        try:
            g = Graph.from_sequence(el)
            choose_biggest_comp(g)
            if g.adjacency.shape[0] != n:
                continue
            print(g.adjacency)
            for i in range(el.shape[0] * 3):
                g.randomize_edges()
            print(g.adjacency)
            graph = nx.from_numpy_matrix(g.adjacency)
            eulerList = []
            euler(g.adjacency.tolist(), 0, eulerList)
            print(eulerList)
            plt.subplot(111)
            nx.draw(graph, with_labels=True, font_weight='bold')
            plt.show()
            break
        except NotGraphicSequenceException:
            continue
```


Overlapping Code:
```
(n):
while True:
el = np.array([random.randint(0, uence(el)
choose_biggest_comp(g)
if g.adjacency.she_edges()
print(g.adjacency)
graph = nx.from_numpylt.subplot(111)
nx.draw(graph, with_labels=True, font_weight='bold')
plt.show()
break
except NotGrap
```
<Overlap Ratio: 0.4672897196261682>

---

--- 85 --
Question ID: b27331e2a40b51e2950c979f9bac602c12eef9c1_0
Original Code:
```
@app.route('/')
@app.route('/index')
def index():
    app.logger.debug('Entering index')
    flask.session['user_id'] = 'creator'
    flask.session['finished'] = check_completed()
    flask.session['to_finish'] = PEOPLE_TO_INVITE
    events = []
    for record in collection.find({'user_id': 'creator'}):
        events.append(record)
    if len(events) > 0:
        return render_template('waiting.html')
    if 'begin_date' not in flask.session:
        init_session_values()
    return render_template('index.html')
```


Overlapping Code:
```
@app.route('/')
@app.route('/index')
def index():
app.logger.debug('En(events) > 0:
return render_template('waiting.html')
if 'begin_date' not in flask.session:
init_session_values()
return render_template('index.html')
```
<Overlap Ratio: 0.4781659388646288>

---

--- 86 --
Question ID: 11ad143814ad6766582b44de612f20dfd8d0423f_11
Original Code:
```
def test_x86_direct():
    insn = ms.ISA_X86.parse_instruction('mov eax, dword ptr [0x8000]')
    assert insn.num_operands == 2
    op = insn.operands[1]
    assert op.is_direct
    assert op.offset == 32768
    assert op.base_reg is None
    assert op.index_reg is None
    assert op.scale == 1
    assert str(op) == '0x8000'
    assert repr(op) == '<MemoryOperand(offset=0x8000)>'
```


Overlapping Code:
```
rect():
insn = ms.ISA_X86.parse_instruction('mov eax, dword ptr [0x8000]')
assert insn.num_operands == 2
op = insn.operands[1]
assert op.is_direct
ass
assert op.index_reg is None
assert op.scale == 1

```
<Overlap Ratio: 0.5847953216374269>

---

--- 87 --
Question ID: 12b9c9e1e1cd70be553e0f6bc5aeab33f9e284de_0
Original Code:
```
def build_data_str(records):
    recordsDataStr = []
    for record in records:
        recordsDataStr.append(tup_to_str(record))
    return recordsDataStr
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 88 --
Question ID: e7dae2609f1a6ef8908cb001bd4912ee60a48a48_6
Original Code:
```
def construct_tabs(selected_pipeline, window, prefs, include_eeg):
    """Constructs as set of tabs based on specifications and the
    selected pipeline.

    Parameters
    ----------
    selected_pipeline : str
        ID of the selected pipeline
    window : instance of main window
        The main window.
    prefs : Instance of PreferencesHandler
        Stores e.g. active plugins.
    include_eeg : bool
        Whether to add EEG-related actions

    Returns
    -------
    list of QDialog
        Contains the constructed tabs relevant to the pipeline
    """
    active_plugins = prefs.active_plugins
    action_specs = find_all_action_specs()
    datatype_specs = find_all_datatype_specs()
    packageSpecs = find_all_package_specs()
    tabs = []
    pipelines = []
    for (source, package_spec) in packageSpecs.items():
        if source not in active_plugins and source != 'meggie':
            continue
        if 'tabs' in package_spec:
            tabs.extend(package_spec['tabs'])
        if 'pipelines' in package_spec:
            pipelines.extend(package_spec['pipelines'])
    for tab in tabs:
        if 'id' not in tab:
            raise Exception('Every tab specification must have id.')
        if 'name' not in tab:
            tab['name'] = tab['id']
        if 'inputs' not in tab:
            tab['inputs'] = []
        if 'outputs' not in tab:
            tab['outputs'] = []
        if 'input_actions' not in tab:
            tab['input_actions'] = []
        if 'output_actions' not in tab:
            tab['output_actions'] = []
        if 'info' not in tab:
            tab['info'] = []
    for pipeline in pipelines:
        if 'id' not in pipeline:
            raise Exception('Every pipeline must have id.')
        if 'name' not in pipeline:
            pipeline['name'] = pipeline['id']
    found = False
    pipeline_spec = None
    for pipeline in pipelines:
        if pipeline['id'] == selected_pipeline:
            found = True
            pipeline_spec = pipeline
            break
    if not found:
        pipeline_spec = {'id': 'classic', 'name': 'Include everything'}
    combined_tabs = []
    for tab_spec in tabs:
        if pipeline_spec.get('include_tabs'):
            if tab_spec['id'] not in pipeline_spec['include_tabs']:
                continue
        if tab_spec['id'] not in [tab['id'] for tab in combined_tabs]:
            new_tab = {}
            new_tab['id'] = tab_spec['id']
            new_tab['name'] = tab_spec['name']
            new_tab['inputs'] = []
            new_tab['outputs'] = []
            new_tab['input_actions'] = []
            new_tab['output_actions'] = []
            new_tab['info'] = []
            idx = len(combined_tabs)
            combined_tabs.append(new_tab)
        else:
            idx = [tab['id'] for tab in combined_tabs].index(tab_spec['id'])
        for input_spec in tab_spec['inputs']:
            if input_spec not in combined_tabs[idx]['inputs']:
                combined_tabs[idx]['inputs'].append(input_spec)
        for output_spec in tab_spec['outputs']:
            if output_spec not in combined_tabs[idx]['outputs']:
                combined_tabs[idx]['outputs'].append(output_spec)
        for input_spec in tab_spec['input_actions']:
            action_spec = action_specs.get(input_spec)
            if not action_spec:
                raise Exception('Cannot read action ' + input_spec + '.')
            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):
                continue
            if input_spec not in combined_tabs[idx]['input_actions']:
                combined_tabs[idx]['input_actions'].append(input_spec)
        for output_spec in tab_spec['output_actions']:
            action_spec = action_specs.get(output_spec)
            if not action_spec:
                raise Exception('Cannot read action ' + output_spec + '.')
            if not include_eeg and 'eeg' in action_spec[2].get('tags', []):
                continue
            if output_spec not in combined_tabs[idx]['output_actions']:
                combined_tabs[idx]['output_actions'].append(output_spec)
        for info_spec in tab_spec['info']:
            action_spec = action_specs.get(info_spec)
            if not action_spec:
                raise Exception('Cannot read info item ' + info_spec + '.')
            if info_spec not in combined_tabs[idx]['info']:
                combined_tabs[idx]['info'].append(info_spec)
    tabs = []
    for tab_spec in combined_tabs:
        tabs.append(construct_tab(tab_spec, action_specs, datatype_specs, window))
    return tabs
```


Overlapping Code:
```
efs, include_eeg):
"""Constructs as set of tabs based on specifications and the
selected pipeline.
Parameters
----------
selected_pipeline : str
ID of the selected pipeline
window : instance of main window
The main window.
prefs : Instance of PreferencesHandler
Stores e.g. active plugins.
include_eeg : bool
Whether to add EEG-related actions
Returns
-------
list of QDialog
Contains the constructed = prefs.active_plugins
action_specs = find_all_action_specs()
datatype_specs = find_all_datatype_sp package_spec:
tabs.extend(package_spec['tabs'])
if 'pipelines' in package_spec:
pipelines.extend(paception('Every tab specification must have id.')
if 'name' not in tab:
tab['name'] = tab['id']
if 'inputs' not in tab:
tab['inputs'] = []
if 'outputs' not in tab:
tab['outputs'] = []
if 'input_actions' not in tab:
tab['input_actions'] = []
if 'output_actions' not in tab:
tab['output_actions'] = []
i
for pipeline in pipelines:
if 'id' not in pipeline:
raise Exception('Every pipeline must have id.')
if 'name' not in pipeline:
pipeline['name'] = pipeline['id']
found = False
pipeline_spec = None
for pipeline in pipelines:
if pipeline['id'] == selected_pipeline:
found = True
pipeline_spec = pipeline
break
if n for tab in combined_tabs]:
new_tab = {}
new_tab['id'] = tab_spec['id']
new_tab['name'] = tab_spec['
```
<Overlap Ratio: 0.6643037974683544>

---

--- 89 --
Question ID: 8ce8096f58ca81419a2edfa556d2c57b16fdd66c_0
Original Code:
```
def deepcopy_and_sign(rlp_signable, privatekey):
    msg = deepcopy(rlp_signable)
    msg.sign(privatekey)
    return msg
```


Overlapping Code:
```
gnable, privatekey):
msg = deepcopy(rlp_signable)
msg.sign(privateke
```
<Overlap Ratio: 0.6238532110091743>

---

--- 90 --
Question ID: 338af77e36625c6e736374eb318b1d3d29015cd3_7
Original Code:
```
def find_replacement_chord(chord):
    t = chord.transpose(-chord.bass)
    if t.pitches == (0, 4, 6, 10):
        return Chord(bass=0, root=0, pitches=(0, 4, 10)).transpose(chord.bass)
    if t.pitches == (0, 3, 8, 10):
        return Chord(bass=0, root=8, pitches=(0, 3, 8)).transpose(chord.bass)
    if t.pitches == (0, 4, 6, 11):
        return Chord(bass=0, root=0, pitches=(0, 4, 6, 7, 11)).transpose(chord.bass)
    if t.pitches == (0, 2, 4, 6, 10):
        return Chord(bass=0, root=10, pitches=(0, 2, 6, 10)).transpose(chord.bass)
    raise ValueError('no such chord: ' + str(chord))
```


Overlapping Code:
```
def find_replacement_chord(chord):
t = chord.transpose(-chord.bass)
if t.pitches == (0, 4, 6, 10):
return Chord(bass=0, root=0, pitches=(0, 4, 10)).transpose(chord.bass)
if t.pitches == (0, 3, 8, 10):
return Chord(bass=0, root=8, pitches=(0, 3, 8)).transpose(chord.bass)
if t.pitches == (0, 4, 6, 11):
return Chord(bass=0, root=0, pitches=(0, 4, 6, 7, 11)).transpose(chord.bass)
if t.pitches == (0, 2, 4, 6, 10):
return Chord(bass=0, root=10, pitches=(0, 2, 6, 10)).transpose(chord.bass)
raise ValueE
```
<Overlap Ratio: 0.9328358208955224>

---

--- 91 --
Question ID: 969279abcd7947481d7b6dda02b897ac7a615367_1
Original Code:
```
def main() -> typing.NoReturn:
    (h, w, d) = map(int, input().split())
    I = np.array(sys.stdin.read().split(), dtype=np.int64)
    a = I[:h * w].reshape(h, w) - 1
    lr = I[h * w + 1:].reshape(-1, 2) - 1
    solve(a, d, lr)
```


Overlapping Code:
```
(int, input().split())
I = np.array(sys.stdin.read().split(), dtype=np.int64)
 w) - 1
lr = I[h * w + 1:].reshape(-1, 2) - 1
solv
```
<Overlap Ratio: 0.6124401913875598>

---

--- 92 --
Question ID: f25d845a5d072ddbe9a4ba42086800a674959571_134
Original Code:
```
def func_18fc8c7e787b450bb9ba27326af7b455(x):
    x = sorted(x, reverse=True)
    rmax = 0.0
    y = [x[i] for i in xrange(len(x))]
    return y
```


Overlapping Code:
```
 func_18fc8c7e787b450bb9ba27326af7b455(x):
x = sorted(x, reverse=True)
rmax = 0.0
y = [x[i] for i in xrange(len(x))]
return 
```
<Overlap Ratio: 0.96875>

---

--- 93 --
Question ID: 35f904677ad8fd1f812f7b5f6172973cf62eaed0_14
Original Code:
```
def mixture_fit(x, K=3, x_w=None, n_itr=100, verbose=False, random_state=0, f_write=None, output_folder=None, suffix=None, fold_number=0):
    """Fit a slope+bump mixture using EM algorithm.

    Args:
        x ((n,d) ndarray): The covaraites.
        K (int): The number of bump components.
        x_w ((n,) ndarray): The weights for each sample.
        n_itr (int): The maximum number of iterations for the EM algorithm
        verbose (bool): Indicate if output the computation details.
        random_state (int): The random seed.
        f_write (file handler (write mode)): The output file.
        output_folder (string): The output directory.
        suffix (string): The suffix of the output file.
        fold_number (int(0,1)): The fold number.

    Returns:
        a ((d,) ndarray): slope parameter.
        mu,sigma ((k,d) ndarray): bump parameter.
        w ((n,) ndarray): proportion of each component. 
    """
    np.random.seed(random_state)
    if len(x.shape) == 1:
        x = x.reshape([-1, 1])
    (nSamp, d) = x.shape
    if x_w is None:
        x_w = np.ones([nSamp], dtype=float)
    GMM = GaussianMixture(n_components=K, covariance_type='diag').fit(x)
    w_old = np.zeros([K + 1])
    w = 0.5 * np.ones([K + 1]) / K
    w[0] = 0.5
    a = ML_slope(x, x_w)
    (mu, sigma) = (GMM.means_, GMM.covariances_ ** 0.5)
    w_samp = np.zeros([K + 1, nSamp], dtype=float)
    i = 0
    if verbose:
        if f_write is not None:
            f_write.write('## mixture_fit: initialization parameters\n')
            f_write.write('# Slope: w=%0.4f, a=%s\n' % (w[0], a))
            for k in range(K):
                f_write.write('# Bump %d: w=%0.4f\n' % (k, w[k + 1]))
                f_write.write('         mu=%s\n' % mu[k])
                f_write.write('      sigma=%s\n' % sigma[k])
            f_write.write('\n')
    while np.linalg.norm(w - w_old, 1) > 0.005 and i < n_itr:
        w_old = w
        w_samp[0, :] = w[0] * f_slope(x, a)
        for k in range(K):
            w_samp[k + 1, :] = w[k + 1] * f_bump(x, mu[k], sigma[k])
        w_samp = w_samp / np.sum(w_samp, axis=0) * x_w
        w = np.mean(w_samp, axis=1)
        a = ML_slope(x, w_samp[0, :])
        for k in range(K):
            if w[k + 1] > 0.0001:
                (mu[k], sigma[k]) = ML_bump(x, w_samp[k + 1, :])
        sigma = sigma.clip(min=0.0001)
        w[w < 0.001] = 0
        w /= w.sum()
        i += 1
    if i >= n_itr and verbose:
        print('Warning: the model does not converge, w_dif=%0.4f' % np.linalg.norm(w - w_old, 1))
        if f_write is not None:
            f_write.write('Warning: the model does not converge, w_dif=%0.4f\n' % np.linalg.norm(w - w_old, 1))
    if verbose and f_write is not None:
        f_write.write('## mixture_fit: learned parameters\n')
        f_write.write('# Slope: w=%0.4f, a=%s\n' % (w[0], a))
        for k in range(K):
            f_write.write('# Bump %d: w=%0.4f\n' % (k, w[k + 1]))
            f_write.write('         mu=%s\n' % mu[k])
            f_write.write('      sigma=%s\n' % sigma[k])
        f_write.write('\n')
    if output_folder is not None:
        bins_ = np.linspace(0, 1, 101)
        x_grid = bins_.reshape([-1, 1])
        if d == 1:
            plt.figure(figsize=[8, 5])
            plt.hist(x, bins=bins_, weights=x_w / np.sum(x_w) * 100)
            temp_p = f_all(x_grid, a, mu, sigma, w)
            plt.plot(bins_, temp_p)
            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))
        else:
            plt.figure(figsize=[8, 12])
            n_figure = min(d, 5)
            for i_dim in range(n_figure):
                plt.subplot(str(n_figure) + '1' + str(i_dim + 1))
                plt.hist(x[:, i_dim], bins=bins_, weights=x_w / np.sum(x_w) * 100)
                temp_p = f_all(x_grid, a[[i_dim]], mu[:, [i_dim]], sigma[:, [i_dim]], w)
                plt.plot(bins_, temp_p)
                plt.title('Dimension %d' % (i_dim + 1))
            plt.savefig(output_folder + '/projection%s_fold_%d.png' % (suffix, fold_number))
        plt.close('all')
    return (a, mu, sigma, w)
```


Overlapping Code:
```
 EM algorithm.
Args:
x ((n,d) ndarray): The covaraites.
K (int): The number of bump components.
x_w ((n,) ndarray): The weights for each sample.
n_itr (int): The maximum number of iterations for the EM algorithm
verbose (bool): Indicate if output the computation details.
random_state (int): The random seed.
f_write (file handler (write mode)): The output file.
output_folder (string): The output directory.
suffix (string): The suffix of the output file.
fold_number (int(0,1)): The fold number.
Returns:
a ((d,) ndarray): slope parameter.
mu,sigma ((k,d) ndarray): bump parameter.
w ((n,) ndarray): proportion of each component._state)
if len(x.shape) == 1:
x = x.reshape([-1, 1 = GaussianMixture(n_components=K, covariance_typete is not None:
f_write.write('## mixture_fit: initialization parameters\n')
f_write.write('# Slope:amp[k + 1, :])
sigma = sigma.clip(min=0.0001)
w[w 
```
<Overlap Ratio: 0.43017578125>

---

--- 94 --
Question ID: 184edbc2fe82843b354712c8ba7f81417e3fb3d2_0
Original Code:
```
def main(arguments):
    cap = cv2.VideoCapture(arguments.video)
    model: tf.keras.Model = tf.keras.models.load_model(arguments.weights_path)
    model.compile(optimizer='adam', loss=tf.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=['accuracy'])
    classes = get_classes(os.path.join(arguments.data_path, 'training_set'))
    (success, img) = cap.read()
    while success:
        img_pp = preprocess_image(img, INPUT_SHAPE)
        x = model.predict(np.expand_dims(img_pp, 0), batch_size=1)
        imgOut = write_class_on_img(img_pp, classes[int(np.argmax(np.array(x)))])
        cv2.imshow('EfficientNet Prediction', imgOut)
        cv2.waitKey(10)
        (success, img) = cap.read()
```


Overlapping Code:
```
def main(arguments):
cap = cv2.VideoCapture(arguments.video)
model: tf.keras.Model = tf.keras.models.load_model(arguments.weights_path)
model.compile(optimizer='adam', loss=tf.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=['accuracy'])
classes = get_classes(os.path.join(arguments.d()
while success:
img_pp = preprocess_image(img, I
```
<Overlap Ratio: 0.550314465408805>

---

--- 95 --
Question ID: 3836b014a35e2f166dd6e956235064be019753de_0
Original Code:
```
def createSampleFile(sampleFilePath):
    if not os.path.exists(sampleFilePath):
        _dir = os.path.dirname(sampleFilePath)
        if not os.path.exists(_dir):
            os.makedirs(_dir, mode=493)
        import uuid
        with open(sampleFilePath, 'w') as f:
            f.write(str(uuid.uuid1()) + '\n')
            f.write(str(uuid.uuid4()) + '\n')
    return sampleFilePath
```


Overlapping Code:
```
ampleFile(sampleFilePath):
if not os.path.exists(sampleFilePath):
_dir = os.path.dirname(sampleFilePath)
if not os.path.exists(_dir):
os.makedirs(_dir, , 'w') as f:
f.write(str(uuid.uuid1()) + '\n')
f.write(str(uuid.uuid4()) + '\n')
return sampleFilePath
```
<Overlap Ratio: 0.8167202572347267>

---

--- 96 --
Question ID: 8ee4e5b90ef2f57ff31c13abfc6ea37b6aa9f151_0
Original Code:
```
def cosine_similarity(A, B):
    t1 = vector_multiply(A, B)
    t2 = sqrt(vector_multiply(A, A))
    t3 = sqrt(vector_multiply(B, B))
    if t2 > 0 and t3 > 0:
        return t1 / (t2 * t3)
    else:
        return 0
```


Overlapping Code:
```
B):
t1 = vector_multiply(A, B)
t2 = sqrt(vector_multiply(A, A))
t3 = sqrt(vector_multiply(B, B))
if t2 > 0 and t3 > 0:
return t1 / (t2 * t3)
else:
ret
```
<Overlap Ratio: 0.8333333333333334>

---

--- 97 --
Question ID: 0a460dfb309ddfb8343e04a6b02b1cc8858e4c42_4
Original Code:
```
def import_no_virt_driver_import_deps(physical_line, filename):
    """Check virt drivers' modules aren't imported by other drivers

    Modules under each virt driver's directory are
    considered private to that virt driver. Other drivers
    in Nova must not access those drivers. Any code that
    is to be shared should be refactored into a common
    module

    N311
    """
    thisdriver = _get_virt_name(virt_file_re, filename)
    thatdriver = _get_virt_name(virt_import_re, physical_line)
    if thatdriver is not None and thisdriver is not None and (thisdriver != thatdriver):
        return (0, 'N311: importing code from other virt drivers forbidden')
```


Overlapping Code:
```
mport_deps(physical_line, filename):
"""Check virt drivers' modules aren't imported by other drivers
Modules under each virt driver's directory are
considered private to that virt driver. Other drivers
in Nova must not access those drivers. Any code that
is to be shared should be refactored into a common
module
N311
"""
thisdriver = _get_virt_name(virt_file_re, filename)
thatdriver = _get_virt_nam
```
<Overlap Ratio: 0.6525285481239804>

---

--- 98 --
Question ID: 8a91b3f07767ea74f9a6d8cb283d9cb8dd32dbfa_8
Original Code:
```
def task_factory(name, func=None, vars=None, color='GREEN', ext_in=[], ext_out=[], before=[], after=[], shell=False, scan=None):
    params = {'vars': vars or [], 'color': color, 'name': name, 'ext_in': Utils.to_list(ext_in), 'ext_out': Utils.to_list(ext_out), 'before': Utils.to_list(before), 'after': Utils.to_list(after), 'shell': shell, 'scan': scan}
    if isinstance(func, str):
        params['run_str'] = func
    else:
        params['run'] = func
    cls = type(Task)(name, (Task,), params)
    global classes
    classes[name] = cls
    return cls
```


Overlapping Code:
```
ctory(name, func=None, vars=None, color='GREEN', ext_in=[], ext_out=[], before=[], after=[], shell=False, n_str'] = func
else:
params['run'] = func
cls = type(Task)(name, (Task,), params)
global classes
cla
```
<Overlap Ratio: 0.40077821011673154>

---

--- 99 --
Question ID: 1407f6d79ec90ec0ceecb5413d805601158c4cae_0
Original Code:
```
def get_bot() -> Bot:
    for bot in DRIVER.bots.values():
        return bot
    return None
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 100 --
Question ID: 8b6e4daf34e200f38605973d93690899eefdcfed_1
Original Code:
```
def check_build_is_legit(build):
    buildString = build.lower()
    build_number = buildString.replace('build', '')
    if build_number in BUILD_MAP.keys():
        return True
    return False
```


Overlapping Code:
```
ld_number in BUILD_MAP.keys():
return True
return 
```
<Overlap Ratio: 0.29411764705882354>

---

--- 101 --
Question ID: eb4e6315d4870bd2d06b1d9423ac6fcf2195cdeb_2
Original Code:
```
def SOIC(A, B, L, T, W, num_pins, pitch=1.27, profile=ipc.LandPatternSize.Nominal):
    f = fp.Footprint(name='{0}-SOIC'.format(num_pins), description='{0}-pin SOIC'.format(num_pins))
    f.from_ipc(lib.SOIC(profile, A, B, L, T, W, num_pins, pitch))
    return f
```


Overlapping Code:
```
IC(A, B, L, T, W, num_pins, pitch=1.27, profile=ipc.LandPatternSize.Nominal):
f = fp.Footprint(name='{0}-SOIC'.format(num_pins))
f.from_ipc(lib.SOIC(profil
```
<Overlap Ratio: 0.62>

---

--- 102 --
Question ID: 4f4f6f8ac9dec0a03002fe61bd6214effc3be501_0
Original Code:
```
def change_request_wrapper(func):

    @functools.wraps(func)
    def _inner(prep_req, *args, **kwargs):
        prep_req.url = prep_req.url + '?some=stuff'
        return func(prep_req, *args, **kwargs)
    return _inner
```


Overlapping Code:
```
quest_wrapper(func):
@functools.wraps(func)
def _inner(prep_req, *args, **kwargs):
prep_req.url = pr
```
<Overlap Ratio: 0.5208333333333334>

---

--- 103 --
Question ID: 5ad02454c22c71588ac4c352b70a914a8fe47bc8_10
Original Code:
```
def test_set_args_settings(mocker):
    mocker.patch('json.load', new=lambda x: x())
    args = Namespace()
    set_args(args)
    assert args.settings == {}
    args = Namespace(settings=None)
    set_args(args)
    assert args.settings == {}
    s = list(range(3))
    mock = MagicMock(return_value=s)
    args = Namespace(settings=mock)
    set_args(args)
    assert args.settings == s
    mock.close.assert_called_with()
```


Overlapping Code:
```
ocker):
mocker.patch('json.load', new=lambda x: x())
args = Namespace()
set_args(args)
assert args.smespace(settings=None)
set_args(args)
assert args.(range(3))
mock = MagicMock(return_value=s)
args = Namespace(settings=mock)
set_args(args)
assert ar
```
<Overlap Ratio: 0.6720430107526881>

---

--- 104 --
Question ID: 714d3dfaa367d1733c257ba0266824ee7c931162_5
Original Code:
```
def getAllClass(p, period):
    data = {}
    data['{}'.format(period)] = getRawAssignments(p, period)
    data['assignments'] = data.pop('{}'.format(period))
    data['info'] = getRawClass(p)['{}'.format(period)]
    return data
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 105 --
Question ID: 4bf042cd1a9ebeebeb1cce1bd259939ff32e8532_1
Original Code:
```
def ret_a_dict(existing):
    """
    Append a key-value to 'existing' (if it exists)
    """
    existing = existing or {}
    ret = {'secret': 42}
    ret.update(existing)
    return ret
```


Overlapping Code:
```
end a key-value to 'existing' (if it exists)
"""
existing = existing or {}
ret = {'secret': 42}
ret.
```
<Overlap Ratio: 0.625>

---

--- 106 --
Question ID: 0e12d22364ddbf0f90693961db9219ea9d1c3443_3
Original Code:
```
def get_uwsgi_emperor_opts(settings, port):
    if settings['DATABASES']['default'].get('PASSWORD'):
        os.environ['DB_PASSWORD'] = settings['DATABASES']['default']['PASSWORD']
        pgStr = 'pg://host={HOST} port={PORT} user={USER} password=$(DB_PASSWORD) dbname={NAME};{query}'
    else:
        pgStr = 'pg://host={HOST} port={PORT} user={USER} dbname={NAME};{query}'
    return get_uwsgi_regular_opts(settings, port) + ['http = 0.0.0.0:{}'.format(port or settings.get('PORT')), 'http-to = /tmp/fastrouter.sock', 'fastrouter = /tmp/fastrouter.sock', 'fastrouter-use-code-string = 0:{}:get'.format(os.path.join(HERE, 'fastrouter_lookup.py')), 'emperor = {}'.format(pgStr.format(query=VASSALS_SQL_QUERY, **settings['DATABASES']['default']))]
```


Overlapping Code:
```
 get_uwsgi_emperor_opts(settings, port):
if settings['DATABASES']['default'].get('PASSWORD'):
os.environ['DB_PASSWORD'] = settings['DATABASES']['defauPORT} user={USER} password=$(DB_PASSWORD) dbname={ = 0.0.0.0:{}'.format(port or settings.get('PORT')fastrouter-use-code-string = 0:{}:get'.format(os.p
```
<Overlap Ratio: 0.42075736325385693>

---

--- 107 --
Question ID: d83d43b9c49703cda927b344f9e7b3b7da45f5b3_1
Original Code:
```
def read_kitti_annotations(label_paths, calib_paths):
    allLabels = []
    all_calib = []
    for (label_file, calib_file) in zip(label_paths, calib_paths):
        calib = o3d.ml.datasets.KITTI.read_calib(calib_file)
        labels = o3d.ml.datasets.KITTI.read_label(label_file, calib)
        allLabels.append(labels)
        all_calib.append(calib)
    return (allLabels, all_calib)
```


Overlapping Code:
```
ib = o3d.ml.datasets.KITTI.read_calib(calib_file)
labels = o3d.ml.datasets.KITTI.read_label(label_fi
```
<Overlap Ratio: 0.2949852507374631>

---

--- 108 --
Question ID: 07fe364d937fe8b983df03d9c0471b986fbd990b_74
Original Code:
```
def _add_workload_inner():
    OpArgMngr.add_workload('inner', np.zeros(shape=(1, 80), dtype=np.float64), np.zeros(shape=(1, 80), dtype=np.float64))
    for dt in [np.float32, np.float64]:
        A = np.array([[1, 2], [3, 4]], dtype=dt)
        B = np.array([[1, 3], [2, 4]], dtype=dt)
        C = np.array([1, 1], dtype=dt)
        OpArgMngr.add_workload('inner', A.T, C)
        OpArgMngr.add_workload('inner', C, A.T)
        OpArgMngr.add_workload('inner', B, C)
        OpArgMngr.add_workload('inner', C, B)
        OpArgMngr.add_workload('inner', A, B)
        OpArgMngr.add_workload('inner', A, A)
        OpArgMngr.add_workload('inner', A, A.copy())
        a = np.arange(5).astype(dt)
        b = a[::-1]
        OpArgMngr.add_workload('inner', b, a)
        a = np.arange(24).reshape(2, 3, 4).astype(dt)
        b = np.arange(24, 48).reshape(2, 3, 4).astype(dt)
        OpArgMngr.add_workload('inner', a, b)
        OpArgMngr.add_workload('inner', b, a)
```


Overlapping Code:
```
r():
OpArgMngr.add_workload('inner', np.zeros(shape=(1, 80), dtype=np.float64), np.zeros(shape=(1, 80), dtype=np.float64))
for dt in [np.float32, np.f[[1, 2], [3, 4]], dtype=dt)
B = np.array([[1, 3], [2, 4]], dtype=dt)
C = np.array([1, 1], dtype=dt)
OpArgMngr.add_workload('inner', A.T, C)
OpArgMngr.add_workload('inner', C, A.T)
OpArgMngr.add_workload('inner', B, C)
OpArgMngr.add_workload('inner', C, B)
OpArgMngr.add_workload('inner', A, B)
OpArgMngr.add_workload('inner', A, A)
OpArgMngr.add_workload('inner', A, A.copy())
a = np.arange(5).astype(dt)
b = a[::-1]
OpArgMngr.add_workload('inner', brgMngr.add_workload('inner', a, b)
OpArgMngr.add_w
```
<Overlap Ratio: 0.7926829268292683>

---

--- 109 --
Question ID: 0460f6e42c23c688c2c6afb0f673aa2cf4d651bf_0
Original Code:
```
def load_state(network, state_dict):
    net_state_keys = list(network.state_dict().keys())
    netStateKeysCopy = net_state_keys.copy()
    sup_string = ''
    for key in state_dict.keys():
        if 'backbone' in key:
            sup_string = 'backbone.'
        elif 'module' in key:
            sup_string = 'module.'
    for (i, _) in enumerate(netStateKeysCopy):
        name = netStateKeysCopy[i]
        if name.startswith('classifier') or name.startswith('fc'):
            continue
        if not sup_string:
            name_pretrained = name
        else:
            name_pretrained = sup_string + name
        if name_pretrained in state_dict.keys():
            dst_param_shape = network.state_dict()[name].shape
            if state_dict[name_pretrained].shape == dst_param_shape:
                network.state_dict()[name].copy_(state_dict[name_pretrained].view(dst_param_shape))
                net_state_keys.remove(name)
    if net_state_keys:
        num_batches_list = []
        for i in range(len(net_state_keys)):
            if 'num_batches_tracked' in net_state_keys[i]:
                num_batches_list.append(net_state_keys[i])
        pruned_additional_states = [x for x in net_state_keys if x not in num_batches_list]
        if pruned_additional_states:
            logging.info('There are layers in current network not initialized by pretrained')
            logging.warning('>> Failed to load: {}'.format(pruned_additional_states))
        return False
    return True
```


Overlapping Code:
```
for key in state_dict.keys():
if 'backbone' in key
if name.startswith('classifier') or name.startswith('fc'):
continue
if not sup_string:
name_pretrained = name
else:
name_pretrained = sup_string + name
if name_pretrained in state_dict.keys():
dst_param_shape = network.state_dict()[name].shape
if state_dict[name_pretrained].shape == dst_param_shape:
network.state_dict()[name].copy_(state_dict[name_pretrained].view(dst_param_shape))
net_state_keyate_keys:
num_batches_list = []
for i in range(len(net_state_keys)):
if 'num_batches_tracked' in net_state_keys[i]:
num_batches_list.append(net_state_keys[i])
pruned_additional_states = [x for x in net_state_keys if x not in num_batches_list]
if pruned_additional_states:
logging.info(rs in current network not initialized by pretraine(pruned_additional_states))
return False
return Tr
```
<Overlap Ratio: 0.6886870355078447>

---

--- 110 --
Question ID: f6b4cf055a04d3fdf48e80ef79e23515af8b5c83_0
Original Code:
```
@pytest.fixture(scope='function')
def boto_status():
    statusMock = Mock()
    statusMock.get_status.side_effect = ['PENDING', 'INSYNC']

    def update():
        statusMock.status = statusMock.get_status()
    statusMock.update.side_effect = update
    statusMock.status = 'PENDING'
    return statusMock
```


Overlapping Code:
```
de_effect = ['PENDING', 'INSYNC']
def update():
st
```
<Overlap Ratio: 0.18181818181818182>

---

--- 111 --
Question ID: cc8172756946d110aef633b85d99fdb465e813dc_1
Original Code:
```
def used_tracks_set(image, all=False):
    """Determine the set of tracks used by directory and files on the disk"""
    bam = Disk.from_image(image).bam()
    usedTracks = set()
    for head in range(2):
        for cyl in range(80):
            track = head << 7 | cyl
            offset = (80 * head + cyl - 4) * image.spt
            if all or track <= 4 or bam[offset:offset + image.spt].any():
                usedTracks.add(track)
    return usedTracks
```


Overlapping Code:
```
ine the set of tracks used by directory and files on the disk"""
bam = Disk.from_image(image).bam()
80 * head + cyl - 4) * image.spt
if all or track <
```
<Overlap Ratio: 0.39577836411609496>

---

--- 112 --
Question ID: 0261d48fadbcba94432255ef1726dce932739202_13
Original Code:
```
@deprecated(version='0.2.0', reason='Use AnyLE instead')
def any_le(bound: Any) -> Any:
    """
    Returns a matcher that matches any value less than or equal to ``bound``
    """
    return AnyLE(bound)
```


Overlapping Code:
```

"""
Returns a matcher that matches any value less than or equal
```
<Overlap Ratio: 0.3404255319148936>

---

--- 113 --
Question ID: 8521926dba5b85612435ecc4000212db9efd4499_7
Original Code:
```
def test_previous_benefit_put_unauthenticated(anonymous_client, previous_benefit):
    data = PreviousBenefitSerializer(previous_benefit).data
    data['monthly_amount'] = '1234.56'
    response = anonymous_client.put(get_previous_benefits_detail_url(previous_benefit), data)
    assert response.status_code == 403
```


Overlapping Code:
```
t_unauthenticated(anonymous_client, previous_benefit):
data = PreviousBenefitSerializer(previous_ben
```
<Overlap Ratio: 0.33557046979865773>

---

--- 114 --
Question ID: 9c1f3df34d1f27d3dbdd982cd272b1268f3600c6_0
Original Code:
```
def inference(net, data_label, use_aux):
    if use_aux:
        (img, cls_label, seg_label) = data_label
        (img, cls_label, seg_label) = (img.cuda(), cls_label.long().cuda(), seg_label.long().cuda())
        (clsOut, seg_out) = net(img)
        return {'cls_out': clsOut, 'cls_label': cls_label, 'seg_out': seg_out, 'seg_label': seg_label}
    else:
        (img, cls_label) = data_label
        (img, cls_label) = (img.cuda(), cls_label.long().cuda())
        clsOut = net(img)
        return {'cls_out': clsOut, 'cls_label': cls_label}
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 115 --
Question ID: 9cf488ea53f16e45eefa82773cf77f48e6b49c9a_6
Original Code:
```
@pytest.fixture
def mock_trained_emulator(mock_emulator):
    filename = os.path.join(test_base, 'data', 'emu.hdf5')
    if os.path.exists(filename):
        yield Emulator.load(filename)
    else:
        mock_emulator.train()
        mock_emulator.save(filename)
        yield mock_emulator
```


Overlapping Code:
```
emulator(mock_emulator):
filename = os.path.join(tlename):
yield Emulator.load(filename)
else:
mock_emulator.train()
mock_emulator.save(filename)
yiel
```
<Overlap Ratio: 0.6048387096774194>

---

--- 116 --
Question ID: 511d2698d35dc4f9fe7517171c56725c07784116_0
Original Code:
```
def make_char_dict():
    chars = string.ascii_lowercase
    charDict = {'<blank>': 0}
    for (idx, c) in enumerate(chars):
        charDict[c] = idx + 1
    current_len = len(list(charDict.keys()))
    charDict['<eos>'] = current_len
    print(charDict)
    return charDict
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 117 --
Question ID: 67a636a6cf8ea63426b938047e0e18deaa078baf_4
Original Code:
```
def test_project_creation_without_pylint(cookies):
    with generate_temporary_project(cookies, extra_context=NO_PLINT) as result:
        assert_successful_creation(result)
        assert_expected_files_exist(result, files=EXPECTED_PROJECT_FILES_NO_PYLINT)
        assert_expected_files_do_not_exist(result, files=('pylintrc',))
```


Overlapping Code:
```
ookies):
with generate_temporary_project(cookies, extra_context=NO_PLINT) as result:
assert_successful_creation(result)
assert_expected_file
```
<Overlap Ratio: 0.46511627906976744>

---

--- 118 --
Question ID: 4ab2bfd86a6ca0acdb74024739a1d2b31d9cbebd_3
Original Code:
```
def zero_shot_transform(image, caption, p=0.5, transform_to_apply='solarized'):
    """
    Output PIL.Image of a two-panel style transfer image with an english word describing the transform included in the caption.
    See OpenAI DALL-E blog post for more details:
    The top half of the image is the original image, and the bottom half is a stylized image.
    """
    if p >= 0.5:
        friendly_transform = transform_to_apply.replace('_', ' ')
        style_caption = 'Two panel image of the exact same picture.' + f'On the top {caption} and on the bottom the same image but with {friendly_transform} applied.' + f'The original image is on the top and the {friendly_transform} image on the bottom. The caption is {caption}.'
        styleImageTransform = transform_lookup[transform_to_apply]
        return (two_panel_style_transfer(image, img_transform=styleImageTransform, resize_ratio=1.0), style_caption)
    return (image, style_caption)
```


Overlapping Code:
```
e of a two-panel style transfer image with an english word describing the transform included in the caption.
See OpenAI DALL-E blog post for more details:
The top half of the image is the original image, and the bottom half is a stylized image.
"""
if p >= 0.5:
friendly_transform = transform_to_applaption} and on the bottom the same image but with image is on the top and the {friendly_transform} i
```
<Overlap Ratio: 0.4499437570303712>

---

--- 119 --
Question ID: b605c74be7fc59d0693eaf81e6720e58b5e14ac4_88
Original Code:
```
def func_645e7dad5f4c4c1db11925e9517ff3b9(infile):
    (n, p, q, r, s) = [int(x) for x in infile.readline().split()]
    dev = [(i * p + q) % r + s for i in range(n)]
    tot = sum(dev)
    i = 0
    return q
```


Overlapping Code:
```
 = [int(x) for x in infile.readline().split()]
dev = [(
```
<Overlap Ratio: 0.2925531914893617>

---

--- 120 --
Question ID: fa024eaa7abd499c2cfb6beea3f81e7389c03dac_0
Original Code:
```
def get_pblog(*args, **kwargs):
    global pblog
    if pblog is None:
        pblog = ProgressBarLog(*args, **kwargs)
    return pblog
```


Overlapping Code:
```
global pblog
if pblog is None:
pblog = ProgressBar
```
<Overlap Ratio: 0.43478260869565216>

---

--- 121 --
Question ID: 1183023f80519f66fa1c64d6437b4cc896c39a21_14
Original Code:
```
def main():
    args = arguments().parse_args()
    sys.path.insert(0, os.getcwd())
    conn = get_connection(args)
    headers = None
    editfile = tempfile.NamedTemporaryFile()
    with open(editfile.name, 'w', newline='') as cfile:
        headers = write_csv(cfile, conn, args.table)
    reffile = tempfile.NamedTemporaryFile()
    shutil.copy(editfile.name, reffile.name)
    call_vim(editfile.name)
    while True:
        try:
            process_changes(reffile, editfile, conn, args.table, headers)
            break
        except Exception as err:
            print('Failed to save changes: ', err)
            q = '(C)ancel, (r)etry save, (e)dit the file again?'
            cmd = query_options(q, ('c', 'r', 'e'))
            if cmd == 'c':
                print('Changes cancelled')
                break
            elif cmd == 'r':
                continue
            elif cmd == 'e':
                call_vim(editfile.name)
            else:
                raise ValueError('Not a command')
```


Overlapping Code:
```
)
sys.path.insert(0, os.getcwd())
conn = get_conneone
editfile = tempfile.NamedTemporaryFile()
with aders = write_csv(cfile, conn, args.table)
reffile = tempfile.NamedTemporaryFile()
shutil.copy(editfhile True:
try:
process_changes(reffile, editfile, conn, args.table, headers)
break
except Exception== 'r':
continue
elif cmd == 'e':
call_vim(editfil
```
<Overlap Ratio: 0.46174142480211083>

---

--- 122 --
Question ID: 93702be6e0d4de5b5113d03f1b9b9f088babbad8_2
Original Code:
```
def macro_do_exist_op(macro: str, specs: typ.Dict[str, str]) -> str:
    macroNoEncloser = macro[1:-1]
    (l, r) = macroNoEncloser.split(MACRO_OP_EXIST)
    if l in specs:
        return specs[with_encloser(l)]
    else:
        return specs[with_encloser(r)]
```


Overlapping Code:
```
cro: str, specs: typ.Dict[str, str]) -> str:
macror.split(MACRO_OP_EXIST)
if l in specs:
return specs[with_encloser(l)]
else:
return specs[with_enclos
```
<Overlap Ratio: 0.6578947368421053>

---

--- 123 --
Question ID: 0778557121cb9d3021b5bcd3f81aaa9f8612eb04_4
Original Code:
```
def write_glottal_tier(utterance, tao):
    returnStr = ''
    glottal_dur = utterance.duration
    for ii in range(len(utterance.duration)):
        returnStr += f'    <gesture value="{utterance.glottal[ii]}" slope="0.000000" duration_s="{utterance.duration[ii]:.6f}" time_constant_s="{tao:.6f}" neutral="0" />\n'
    return returnStr
```


Overlapping Code:
```
e.duration
for ii in range(len(utterance.duration)ttal[ii]}" slope="0.000000" duration_s="{utterance.duration[ii]:.6f}" time_constant_s="{tao:.6f}" ne
```
<Overlap Ratio: 0.487012987012987>

---

--- 124 --
Question ID: 9ec5c4528bc5fd84b15a1a39d42df73c0372c253_0
Original Code:
```
def make_parser():
    parser = argparse.ArgumentParser('Extract frames from a video. If `-r` and `-n N` parameters are specified, then dump `N` randomly selected frames. If `-s START -i STRIDE` are specified then dump every `STRIDE`-th frame starting from `START` frame.')
    parser.add_argument('-f', dest='fname', type=str, help='input filename')
    parser.add_argument('-s', dest='start', default=0, type=int, help='starting frame')
    parser.add_argument('-i', dest='stride', default=1, type=int, help='stride, interval between successive frames to save.')
    parser.add_argument('-c', dest='cmap', default='', type=str, help='colormap to conevrt to, default same as original')
    parser.add_argument('-x', dest='scale', default=1, type=float, help='factor by which to scale the images')
    parser.add_argument('-r', dest='random', action='store_true', help='extract random frames')
    parser.add_argument('-n', dest='num', default=-1, type=int, help='number of frames to extract.')
    parser.add_argument('-o', dest='outdir', default='.', type=str, help='output directory')
    return parser
```


Overlapping Code:
```
def make_parser():
parser = argparse.ArgumentParser('rom `START` frame.')
parser.add_argument('-f', dest='fname', type=str, help='input filename')
parser.add_argument('-s', dest='start', default=0, type=')
parser.add_argument('-c', dest='cmap', default=by which to scale the images')
parser.add_argumentxtract random frames')
parser.add_argument('-n', drames to extract.')
parser.add_argument('-o', dest
```
<Overlap Ratio: 0.3784037558685446>

---

--- 125 --
Question ID: 328dbe2b5b1e986ae40f5e053574fec17b83fbb1_0
Original Code:
```
def trio_perf_counter():
    """Trio task-local equivalent of time.perf_counter().

    For the current Trio task, return the value (in fractional seconds) of a
    performance counter, i.e. a clock with the highest available resolution to
    measure a short duration.  It includes time elapsed during time.sleep,
    but not trio.sleep.  The reference point of the returned value is
    undefined, so that only the difference between the results of consecutive
    calls is valid.

    Performance note: calling this function installs instrumentation on the
    Trio scheduler which may affect application performance.  The
    instrumentation is automatically removed when the corresponding tasks
    have exited.
    """
    trio_lowlevel.add_instrument(_instrument)
    task = trio_lowlevel.current_task()
    return perf_counter() - _instrument.get_elapsed_descheduled_time(task)
```


Overlapping Code:
```
local equivalent of time.perf_counter().
For the current Trio task, return the value (in fractional seconds) of a
performance counter, i.e. a clock with the highest available resolution to
measure a short duration. It includes time elapsed during time.sleep,
but not trio.sleep. The reference point of the returned value is
undefined, so that only the difference between the results of consecutive
calls is valid.
Performance note: calling this function installs instrumentation on the
Trio scheduler which may affect application performance. The
instrumentation is automatically removed when the corresponding tasks
have exited.
"""
trio_lowlevel.add_instrument(_instrument)
task = trio_lowlevel.current_task()
return perf_counter() - _instrument.ge
```
<Overlap Ratio: 0.9146341463414634>

---

--- 126 --
Question ID: 1c1c76f7c4bea462b7291fe3d05a036ce7b22f07_6
Original Code:
```
def main():
    if not os.path.exists('benchmark.py'):
        logging.warning('Please change current path to %s', PYARMOR_PATH)
        return
    output = '.benchtest'
    name = 'bfoo'
    filename = os.path.join(output, name + '.py')
    obname = 'obfoo'
    obfilename = os.path.join(output, obname + '.py')
    if len(sys.argv) > 1 and 'bootstrap'.startswith(sys.argv[1]):
        if len(sys.argv) < 5:
            sys.argv.extend(['1', '1', '1'])
        (obfMod, obf_code, wrap_mode) = sys.argv[2:5]
        if not os.path.exists(output):
            logging.info('Create output path: %s', output)
            os.makedirs(output)
        else:
            logging.info('Output path: %s', output)
        logging.info('Generate test script %s ...', filename)
        make_test_script(filename)
        logging.info('Obffuscate test script ...')
        shutil.copy(filename, obfilename)
        obffuscate_scripts(output, os.path.basename(obfilename), obfMod, obf_code, wrap_mode)
        if not os.path.exists(obfilename):
            logging.info('Something is wrong to obsfucate the script')
            return
        logging.info('Generate obffuscated script %s', obfilename)
        logging.info('Copy benchmark.py to %s', output)
        shutil.copy('benchmark.py', output)
        logging.info('')
        logging.info('Now change to "%s"', output)
        logging.info('Run "%s benchmark.py".', sys.executable)
        return
    filename = os.path.basename(filename)
    if os.path.exists(filename):
        logging.info('Test script: %s', filename)
    else:
        logging.warning('Test script: %s not found', filename)
        logging.info('Run "%s benchmark.py bootstrap" first.', sys.executable)
        return
    obfilename = os.path.basename(obfilename)
    if os.path.exists(obfilename):
        logging.info('Obfuscated script: %s', obfilename)
    else:
        logging.warning('Obfuscated script: %s not found', obfilename)
        logging.info('Run "%s benchmark.py bootstrap" first.', sys.executable)
        return
    logging.info('--------------------------------------')
    logging.info('')
    total_extra_init_time()
    logging.info('')
    foo = import_no_obfuscated_module(name)
    obfoo = import_obfuscated_module(obname)
    logging.info('')
    foo = re_import_no_obfuscated_module(name)
    obfoo = re_import_obfuscated_module(obname)
    logging.info('')
    run_empty_no_obfuscated_code_object(foo)
    run_empty_obfuscated_code_object(obfoo)
    logging.info('')
    run_one_thousand_no_obfuscated_bytecode(foo)
    run_one_thousand_obfuscated_bytecode(obfoo)
    logging.info('')
    run_ten_thousand_no_obfuscated_bytecode(foo)
    run_ten_thousand_obfuscated_bytecode(obfoo)
    logging.info('')
    logging.info('--------------------------------------')
```


Overlapping Code:
```
f not os.path.exists('benchmark.py'):
logging.warning('Please change current path to %s', PYARMOR_PATH)
return
output = '.benchtest'
name = 'bfoo'
filename = os.path.join(output, name + '.py')
obname = 'obfoo'
obfilename = os.path.join(output, obname + '.py')
if len(sys.argv) > 1 and 'bootstrap'.startswith(sys.argv[1]):
if len(sys.argv) < 5:
sys.arts(output):
logging.info('Create output path: %s', output)
os.makedirs(output)
else:
logging.info('Output path: %s', output)
logging.info('Generate test script %s ...', filename)
make_test_script(filename)
logging.info('Obffuscate test script ...')
shutil.copy(filename, obfilename)
obffuscate_scripts(output,wrap_mode)
if not os.path.exists(obfilename):
logging.info('Something is wrong to obsfucate the script')
return
logging.info('Generate obffuscated script %s', obfilename)
logging.info('Copy benchmark.py to %s', output)
shutil.copy('benchmark.py', output)
logging.info('')
logging.info('Now change to "%s"', output)
logging.info('Run "%s benchmark.py".', sys.executable)
return
filename = os.path.basename(filename)
if os.path.exists(filename):
logging.info('Test script: %s', filename)
else:
logging.warning('Test script: %s not found', filename)
logging.info('Run "%s benchmark.py bootstrap" first.', sys.executable)
return
obfilename = os.path.basename(obfilename)
if os.path.exists(obfilename):
logging.info('Obfuscated script: %s', obfilename)
else:
logging.warning('Obfuscated script: %s not found', obfilename)
logging.info('Run "%s benchmark.py bootstrap" first.', sys.executable)
return
logging.info('--------------------------------------')
logging.info('')
total_extra_init_time()
logging.info('')
foo = import_no_obfuscated_module(name)
obfoo = import_obfuscated_module(obname)
logging.info('')
foo = re_import_no_obfuscated_module(name)
obfoo = re_import_obfuscated_module(obname)
logging.info('')
run_empty_no_obfuscated_code_object(foo)
run_empty_obfuscated_code_object(obfoo
```
<Overlap Ratio: 0.9245372567631703>

---

--- 127 --
Question ID: 07d1a12410a8c57d20254595d70eb26c45d6f0ba_0
Original Code:
```
@app.route('/robots.txt')
@app.route('/AI_list.xml')
def static_from_root():
    return send_from_directory(app.static_folder, request.path[1:])
```


Overlapping Code:
```
app.route('/AI_list.xml')
def static_from_root():
return send_from_directory(app.static_folder, request.path[1:])
```
<Overlap Ratio: 0.8071428571428572>

---

--- 128 --
Question ID: 241dc5d98f8878f2c0b9e622971ebdf6ac69b24e_5
Original Code:
```
def dye(image, lw=5, rw=5, sh=3, value=255):
    (h, w) = image.shape
    mask = np.ones([h, w], np.uint8)
    mask *= value
    mask[2 * int(h / sh):h, int(w / lw):int(w - w / rw)] = 0
    dst = cv.add(mask, image)
    return dst
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 129 --
Question ID: 585c8c30c7d2aa1d2bbdf2724d7af40b9b92f226_7
Original Code:
```
def get_straightline_path_to(target, robot_pos):
    pts = []
    curPos = robot_pos
    while np.linalg.norm(target[:2] - curPos[:2]) > 0.5:
        t = get_step_target_for_move(curPos, [target[0], CAMERA_HEIGHT, target[1]], step_size=0.5)
        pts.append(t)
        curPos = t
    return np.asarray(pts)
```


Overlapping Code:
```
 [target[0], CAMERA_HEIGHT, target[1]], step_size=
```
<Overlap Ratio: 0.1865671641791045>

---

--- 130 --
Question ID: 60f2593114913a3c96f097967b6e4f643d2df767_5
Original Code:
```
def root_sum_squares(arr1, arr2):
    """
    Function to calculate magnitude of two arrays of vectors.
    """
    rss_arr = np.sqrt(arr1 ** 2 + arr2 ** 2)
    vLine = np.median(rss_arr)
    return (rss_arr, vLine)
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 131 --
Question ID: 70e4742585e29853d1350672ced44f958ac66764_3
Original Code:
```
def _extract_metrics(out_lines) -> Tuple[pd.DataFrame, Dict[str, Optional[Union[str, int, float]]]]:
    loss_table = {'i': [], 'loss': [], 'since_last': []}
    metrics = {}
    try:
        record = False
        for line in out_lines:
            line = line.strip()
            if record:
                if line == '':
                    record = False
                else:
                    counter_line = line.split()
                    try:
                        (count, average_loss, sinceLast) = (counter_line[2], counter_line[0], counter_line[1])
                        average_loss_f = float(average_loss)
                        since_last_f = float(sinceLast)
                        loss_table['i'].append(count)
                        loss_table['loss'].append(average_loss_f)
                        loss_table['since_last'].append(since_last_f)
                    except (ValueError, TypeError):
                        ...
            elif line.startswith('loss'):
                fields = line.split()
                if fields[0] == 'loss' and fields[1] == 'last' and (fields[2] == 'counter'):
                    record = True
            elif '=' in line:
                key_value = [p.strip() for p in line.split('=')]
                if key_value[0] == 'average loss':
                    metrics[key_value[0]] = _parse_loss(key_value[1])
                else:
                    metrics[key_value[0]] = _to(key_value[1], [int, float])
    finally:
        return (pd.DataFrame(loss_table).set_index('i'), metrics)
```


Overlapping Code:
```
etrics(out_lines) -> Tuple[pd.DataFrame, Dict[str, Optional[Union[str, int, float]]]]:
loss_table = {'i': [], 'loss': [], 'since_last': []}
metrics = {}
try:
record = False
for line in out_lines:
line = line.strip()
if record:
if line == '':
record = False
else:
countloss_table['i'].append(count)
loss_table['loss'].append(average_loss_f)
loss_table['since_last'].append(since_last_f)
except (ValueError, TypeError):
ith('loss'):
fields = line.split()
if fields[0] == 'loss' and fird = True
elif '=' in line:
key_value = [p.strip() for p in line.split('=')]
if key_value[0] == 'average loss':
metrics[key_value[0]] = _parse_loss(key_value[1])
else:
metrics[key_value[0]] = _to(key_
```
<Overlap Ratio: 0.6538830297219559>

---

--- 132 --
Question ID: ee05a0d4fc4e0216722d78972336a384e87d7578_6
Original Code:
```
def show_video():
    mp4list = glob.glob('video/*.mp4')
    if len(mp4list) > 0:
        mp4 = mp4list[0]
        video = io.open(mp4, 'r+b').read()
        encoded = base64.b64encode(video)
        ipythondisplay.display(HTML(data='<video alt="test" autoplay\n                 controls style="height: 400px;">\n                <source src="data:video/mp4;base64,{0}" type="video/mp4" />\n             </video>'.format(encoded.decode('ascii'))))
    else:
        print('Could not find video')
```


Overlapping Code:
```
def show_video():
mp4list = glob.glob('video/*.mp4')
if len(mp4list) > 0:
mp4 = mp4list[0]
video = io.open(mp4, 'r+b').read()
encoded = base64.b64encode(video)
ipythondisplay.display(HTML(data='<source src="data:video/mp4;base64,{0}" type="video/mp4" />
```
<Overlap Ratio: 0.6340852130325815>

---

--- 133 --
Question ID: e2638a4bcd52d33f3d9e3b6ccc08e027bf129a22_19
Original Code:
```
def build_random_ts(num_samples, length_of_ts):
    data = {}
    labels = []
    for s in range(0, num_samples):
        labels.append(np.random.choice([1, 2]))
    data['y'] = labels
    for col in range(0, length_of_ts):
        key = 'feature_' + str(col + 1)
        values = []
        for s in range(0, num_samples):
            values.append(np.random.normal())
        data[key] = values
    df = pd.DataFrame.from_dict(data)
    X = df.iloc[:, 1:]
    y = df.iloc[:, :1]
    return (X, y)
```


Overlapping Code:
```
_samples):
labels.append(np.random.choice([1, 2]))
data['y'] = labels
for col in range(0, length_of_ts):
key = 'feature_' + str(col + 1)
values = []
fandom.normal())
data[key] = values
df = pd.DataFra
```
<Overlap Ratio: 0.4878048780487805>

---

--- 134 --
Question ID: a2ffeaa240b71382db18bba9227270f5573e50fb_1
Original Code:
```
@Transform_Wrapper()
def Annotate_Script_Names(empty_diffs=0):
    """
    For every ai script, annotate the pilot entity with the name
    of the script running.
    """
    aiscriptFiles = Load_Files('aiscripts/*.xml')
    for game_file in aiscriptFiles:
        xml_root = game_file.Get_Root()
        changed = False
        for tag in ['dock_masstraffic_drone', 'execute_custom_trade', 'execute_trade', 'move_approach_path', 'move_docking', 'move_undocking', 'move_gate', 'move_navmesh', 'move_strafe', 'move_target_points', 'move_waypoints', 'move_to', 'detach_from_masstraffic', 'wait_for_prev_script', 'wait']:
            nodes = xml_root.xpath('.//{}'.format(tag))
            if not nodes:
                continue
            changed = True
            if empty_diffs:
                continue
            for node in nodes:
                script_name = etree.Element('set_value', name='this.$script_name', exact="'{}'".format(game_file.name.replace('.xml', '')))
                node.addprevious(script_name)
                element_name = etree.Element('set_value', name='this.$element_name', exact="'{}'".format(tag))
                node.addprevious(element_name)
                if node.sourceline:
                    name_line = "'${} {}'".format(game_file.name.replace('.xml', ''), node.sourceline)
                    script_line_node = etree.Element('set_value', name='this.$script_line_name', exact=name_line)
                    node.addprevious(script_line_node)
                    record_group = [etree.fromstring('\n                            <do_if value="not this.$script_line_counts?">\n                              <set_value name="this.$script_line_counts" exact="table[]"/>\n                            </do_if>'), etree.fromstring('\n                            <do_if value="not this.$script_line_counts.{FIELD}?">\n                              <set_value name="this.$script_line_counts.{FIELD}" exact="0.0"/>\n                            </do_if>'.replace('FIELD', name_line)), etree.fromstring('\n                            <set_value name="this.$script_line_counts.{FIELD}" operation="add"/>'.replace('FIELD', name_line))]
                    for record_node in record_group:
                        node.addprevious(record_node)
        if changed:
            game_file.Update_Root(xml_root)
    return
```


Overlapping Code:
```
y ai script, annotate the pilot entity with the naxml_root = game_file.Get_Root()
changed = False
for tag in [f not nodes:
continue
changed = True
if empty_diffs:
continuerceline:
name_line = "'${} {}'".format(game_file.n
```
<Overlap Ratio: 0.12367095691102406>

---

--- 135 --
Question ID: b2384578a7677f29cd7e0fe11a8a0c2097dd4658_3
Original Code:
```
def export_result(request, uid):
    if request.method == 'GET':
        data = request.GET.get('data')
        img = request.GET.get('image')
        gif = request.GET.get('gif')
        if data == '1':
            data = True
        else:
            data = False
        if img == '1':
            img = True
        else:
            img = False
        if gif == '1':
            gif = True
        else:
            gif = False
        work = Work(uid)
        (zipPath, file_name) = work.export(data, img, gif)
        response = StreamingHttpResponse(Tools.file_iterator(zipPath))
        response['Content-Type'] = 'application/octet-stream'
        response['Content-Disposition'] = 'attachment; filename={0}'.format(file_name)
        response['Access-Control-Expose-Headers'] = 'Content-Disposition'
        return response
```


Overlapping Code:
```
id):
if request.method == 'GET':
data = request.GET.get('data')
img = request.GET.get('image')
gif =e
else:
data = False
if img == '1':
img = True
else:
img = False
if gif == '1':
gif = True
else:
gif))
response['Content-Type'] = 'application/octet-stream'
response['Content-Disposition'] = 'attachment; filename={0}'.format(fileesponse['Access-Control-Expose-Headers'] = 'Content-Disposition'
return response
```
<Overlap Ratio: 0.6471518987341772>

---

--- 136 --
Question ID: 521ca7e8f2b91498b1cecc645438b8f39926f276_1
Original Code:
```
def test_haversine():
    """
    TODO...
    """
    pass
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 137 --
Question ID: aa06ab4636c128273f66fb5d6c82aabd460f2220_0
Original Code:
```
@mock.patch('six.moves.builtins.super')
def test_algosec_servers_http_adapter(mock_super, mocker):
    adapter = AlgoSecServersHTTPAdapter()
    adapter.send()
    assert super.return_value.send.call_args == mocker.call(timeout=(AlgoSecServersHTTPAdapter.ALGOSEC_SERVER_CONNECT_TIMEOUT, AlgoSecServersHTTPAdapter.ALGOSEC_SERVER_READ_TIMEOUT))
    assert mock_super(AlgoSecServersHTTPAdapter, adapter).calls[0]
```


Overlapping Code:
```
servers_http_adapter(mock_super, mocker):
adapter = AlgoSecServersHTTPAdapter()
adapter.send()
assert super.return_value.send.call_args == mocker.call
```
<Overlap Ratio: 0.3816793893129771>

---

--- 138 --
Question ID: 1ac41f241705a181f54bcd99f611ca86824ed455_5
Original Code:
```
def Hosts_Ping(context, nameSpace, className, methodName, instanceName, parameters):
    be = BookEnd('Hosts_Ping')
    out_params = context.NewParameters('Hosts', 'Ping')
    out_params.SetValue('MIReturn', MI_Uint64(123))
    context.PostInstance(out_params)
    context.PostResult(MI_RESULT_OK)
```


Overlapping Code:
```
text, nameSpace, className, methodName, instanceName, paramet
```
<Overlap Ratio: 0.22021660649819494>

---

--- 139 --
Question ID: 73401fdbf7f3329cc097f204980f1eaf451bd20d_0
Original Code:
```
def updateStateByKey(ssc):

    def processStateUpdateByKey(input_stream, state):
        print('i', input_stream)
        print('s', state)
        return state if not input_stream else input_stream[-1]
    ssc.checkpoint('checkpoints/')
    ssc.queueStream([[('a', 1), ('b', 3)], [('a', 2), ('a', 5), ('c', 4)]]).updateStateByKey(processStateUpdateByKey).pprint()
```


Overlapping Code:
```
ateByKey(ssc):
def processStateUpdateByKey(input_stream, state):
print('i', input_stream)
print('s', state)
return state if not input_stream else inpuqueueStream([[('a', 1), ('b', 3)], [('a', 2), ('a'
```
<Overlap Ratio: 0.6097560975609756>

---

--- 140 --
Question ID: 00cef5ab0b6c71719e9da7da7a1b9a6407ebc5d7_0
Original Code:
```
def main():
    N = 7
    M = 10
    key = gfdb.Management.retrieval.Retrieve.create_key(N, M)
    print('key: ' + key)
    rConfiguration = 'rectangle'
    r = gfdb.Management.retrieval.Retrieve(rConfiguration)
    library_boundaries = r.query_database()
    r_data = r.retrieve(N, M)
    print(r_data)
    r_level = r.levels[rConfiguration]
    L_configuration = 'L'
    L = gfdb.Management.retrieval.Retrieve(L_configuration)
    library_boundaries = L.query_database()
    L_data = L.retrieve(N, M)
    print(L_data)
    LopU_configuration = 'LopU'
    LopU = gfdb.Management.retrieval.Retrieve(LopU_configuration)
    LopU_data = LopU.retrieve(N, M)
    print(LopU_data)
    U_configuration = 'U'
    U = gfdb.Management.retrieval.Retrieve(U_configuration)
    U_data = U.retrieve(N, M)
    print(U_data)
    c_configuration = 'C'
    c = gfdb.Management.retrieval.Retrieve(c_configuration)
    library_boundaries = c.query_database()
    c_data = c.retrieve(N, M)
    print(c_data)
    Open_configuration = 'Open'
    Open = gfdb.Management.retrieval.Retrieve(Open_configuration)
    Open_data = Open.retrieve(N, M)
    print(Open_data)
    zoned_configuration = 'zoned'
    zoned = gfdb.Management.retrieval.Retrieve(zoned_configuration)
    zoned_data = zoned.retrieve(N, M)
    print(zoned_data)
```


Overlapping Code:
```

M = 10
key = gfdb.Management.retrieval.Retrieve.create_key(N, M)
print('key: ion = 'rectangle'
r = gfdb.Management.retrieval.Retry_database()
r_data = r.retrieve(N, M)
print(r_da.Management.retrieval.Retrieve(L_configuration)
library_boundaries = L.query_database()
L_data = L.retrieve(N, M)configuration = 'LopU'
LopU = gfdb.Management.retrieval.Retrieve(LopU_configuration)
LopU_data = LopU.retrieve(N, M)
print(LopU_daton = 'U'
U = gfdb.Management.retrieval.Retrieve(U_configurdb.Management.retrieval.Retrieve(c_configuration)
library_boundaries = c.query_database()
c_data = cn = 'Open'
Open = gfdb.Management.retrieval.Retrieve(Open_configuration)
Open_data = Open.retrieve(N, M)
print(Openation = 'zoned'
zoned = gfdb.Management.retrieval.Retrieve(zoned_configuration)
zoned_data = zoned.retrie
```
<Overlap Ratio: 0.6905172413793104>

---

--- 141 --
Question ID: e357f5174eb4389ae8c75eadb4fb65ed5718efd2_0
Original Code:
```
def initialize_routes(api, limiter):
    RegisterApi.decorators = [limiter.limit('10/hour', methods=['POST'])]
    LoginApi.decorators = [limiter.limit('30/minute', methods=['POST'])]
    PasswordChangeApi.decorators = [limiter.limit('5/day', methods=['POST'])]
    CaffSearchApi.decorators = [limiter.limit('1/second', methods=['GET'])]
    CaffDownloadApi.decorators = [limiter.limit('10/minute', methods=['GET'])]
    CaffUploadApi.decorators = [limiter.limit('10/minute', methods=['POST'])]
    CommentApi.decorators = [limiter.limit('10/minute', methods=['POST'])]
    UserDataApi.decorators = [limiter.limit('60/second', methods=['GET', 'DELETE'])]
    CaffDataApi.decorators = [limiter.limit('60/second', methods=['GET', 'DELETE'])]
    api.add_resource(RegisterApi, '/user/register')
    api.add_resource(LoginApi, '/user/login')
    api.add_resource(LogoutApi, '/user/logout')
    api.add_resource(PasswordChangeApi, '/user/password')
    api.add_resource(UsersListApi, '/user/')
    api.add_resource(UserDataApi, '/user/<username>')
    api.add_resource(CaffDataApi, '/caff/<caff_id>')
    api.add_resource(CaffSearchApi, '/caff/search')
    api.add_resource(CaffUploadApi, '/caff/upload')
    api.add_resource(CaffDownloadApi, '/caff/download/<caff_id>')
    api.add_resource(CommentApi, '/comment')
```


Overlapping Code:
```
):
RegisterApi.decorators = [limiter.limit('10/hour', methods=['POST'])]
LoginApi.decorators = [limiter.limit('30/minute', methods=['POST'])]
PasswordChangeApi.decorators = [limiter.limit('5/day', methods=['POST'])]
CaffSearchApi.decorators = [limiter.limit('1/second', methods=['GET'])]
CaffDownloadApi.decorators = [limiter.limit('10/minute', methods=['GET'])]
CaffUploadApi.decorators = [limiter.limit('10/minute', methods=['POST'])]
CommentApi.decorators = [limiter.limit('10/minute', methods=['POST'])]
UserDataApi.decorators = [limiter.limit('60/second', methods=['GET', 'DELETE'])]
CaffDataApi.decorators = [limiter.limit('60/second', methods=['GET', 'DELETE'])]
api.add_resource(RegisterApi, '/user/register')
api.add_resource(LoginApi, '/user/login')
api.add_resource(LogoutApi, '/user/logout')
api.add_resource(PasswordChangeApi, '/user/password')
api.add_resource(UsersListApi, '/user/')
api.add_resource(UserDataApi, '/user/<username>')
api.add_resource(CaffDataApi, '/caff/<caff_id>')
api.add_resource(CaffSearchApi, '/caff/search')
api.add_resource(CaffUploadApi, '/caff/upload')
api.add_resource(CaffDownloadApi, '/caff/download/<caff_
```
<Overlap Ratio: 0.9349593495934959>

---

--- 142 --
Question ID: fe661c2264845a793c67f4141a080dbf2325c8ac_4
Original Code:
```
def get_significance_matrix(df):
    """
    returns matrix in which item[y,x] is test of whether y-x is center around zero
    """
    return df.apply(lambda x: df.apply(lambda y: wilcox_test(x, y)))
```


Overlapping Code:
```
:
"""
returns matrix in which item[y,x] is test of whether y-x is center around zero
"""
return df.a
```
<Overlap Ratio: 0.5434782608695652>

---

--- 143 --
Question ID: 4aa6ab3efd6286da2d8af7db8b33a3b6c6534a0f_37
Original Code:
```
def test_object_beside_object():
    ball = situation_object(BALL)
    table = situation_object(TABLE)
    situation = HighLevelSemanticsSituation(ontology=GAILA_PHASE_1_ONTOLOGY, salient_objects=[ball, table], always_relations=[Relation(IN_REGION, ball, Region(table, distance=PROXIMAL, direction=Direction(positive=True, relative_to_axis=HorizontalAxisOfObject(table, index=0))))])
    assert generated_tokens(situation) == ('a', 'ball', 'beside', 'a', 'table')
```


Overlapping Code:
```

ball = situation_object(BALL)
table = situation_object(TABLE)
situation = HighLevelSemanticsSituation
```
<Overlap Ratio: 0.22818791946308725>

---

--- 144 --
Question ID: 4fc83d3fdc1d39e0640dd521e048db83a30a09cb_8
Original Code:
```
@task
def prepare_python_packages():
    local('mkdir -p {local_python_packages_dir}'.format(**env))
    local('cp {local_project_root}/requirements.txt {local_python_packages_dir}/'.format(**env))
    existing_files = set((filenameToRequirement(filename) for filename in os.listdir(env.local_python_packages_dir)))
    missingRequirements = tempfile.NamedTemporaryFile()
    for raw_line in open(os.path.join(env.local_project_root, 'requirements.txt')):
        line = raw_line.strip()
        if not line or line.startswith('#') or line not in existing_files:
            missingRequirements.write(raw_line)
    missingRequirements.flush()
    local('pip install --no-use-wheel -d {env.local_python_packages_dir} --exists-action=i -r {missing_requirements_file}'.format(env=env, missing_requirements_file=missingRequirements.name))
    missingRequirements.close()
```


Overlapping Code:
```
def prepare_python_packages():
local('mkdir -p {local_python_packages_dir}'.format(**env))
local('cpilename in os.listdir(env.local_python_packages_dipfile.NamedTemporaryFile()
for raw_line in open(os.path.join(env.local_project_root, 'requirements.txt')):
line = raw_line.strip()
if not line or line.startswith('#') or line not in existing_files:
mi
```
<Overlap Ratio: 0.43424317617866004>

---

--- 145 --
Question ID: 073a2f50e72052b77841f9cbe00704769b1c08c3_0
Original Code:
```
def predict(pdb_file: Path) -> float:
    """
    The function that puts it all together: parsing the PDB file, generating
    features from it and performing inference with the ML model.
    """
    parser = PDBParser()
    structure = parser.get_structure(pdb_file.stem, pdb_file)
    features = featurize(structure)
    predictedSolubility = ml_inference(features)
    return predictedSolubility
```


Overlapping Code:
```
: Path) -> float:
"""
The function that puts it all together: parsing the PDB file, generating
features from it and performing inference with the ML model.
"
parser = PDBParser()
structure = parser.get_structure(pdb_file.stem, pdb_file)
```
<Overlap Ratio: 0.6519337016574586>

---

--- 146 --
Question ID: 6a51a788efc3cd04bcda0ebddae5641c0b5fd64a_0
Original Code:
```
def AdvSrch_Type_f(AdvSrch_Type):
    if AdvSrch_Type == 'Computer':
        return ('advancedcomputersearches', 'advanced_computer_search', 'computers')
    if AdvSrch_Type == 'Mobile':
        return ('advancedmobiledevicesearches', 'advanced_mobile_device_search', 'mobile_devices')
    else:
        print('Failed to set AdvSrch_Type properly.\rPlease uncomment AdvSrch_Type = "Computer" or AdvSrch_Type = "Mobile"')
```


Overlapping Code:
```
Failed to set AdvSrch_Type properly.\rPlease uncomment AdvSrch_Type = "Computer" or AdvSrch_Type = "
```
<Overlap Ratio: 0.2604166666666667>

---

--- 147 --
Question ID: 35daad5aecd0ac3a78c0c2339cbf51e0014f3f74_10
Original Code:
```
def Predict(Phi, b, mu, s, t, r, outd):
    print(t, '--t')
    dt = t[1] - t[0]
    tmin = min(t)
    tmax = max(t)
    t2 = np.linspace(tmin, tmax, num_pred)
    Psi = np.zeros([r, len(t2)], dtype='complex')
    for (i, _x) in enumerate(t2):
        print(_x, '_x')
        print(b, 'b')
        print(i)
        print(shape(Psi))
        Psi[:, i] = multiply(power(mu, _x / dt), b)
    D2 = dot(Phi, Psi)
    sigmaps = []
    tps = []
    for i in range(len(D2[0, :])):
        print(str(i) + '--predicted...' + str(t2[i]))
        F = D2[:, i]
        if i == 0:
            F0 = average(F)
        eps = t2[i]
        sigma = MakeImagePred(F - F0, i, s, eps, outd)
        tps.append(t2[i])
        sigmaps.append(sigma + eps)
    return (tps, sigmaps)
```


Overlapping Code:
```
 np.linspace(tmin, tmax, num_pred)
Psi = np.zeros([r, len(t2)], dtype='
```
<Overlap Ratio: 0.11813643926788686>

---

--- 148 --
Question ID: 70f2b74641e7867f742d38f95ce15e96044fc424_2
Original Code:
```
def _predict(X_, theta_, model_):
    n = X_.shape[0]
    tInit = time()
    Z_hat_ = _predict_proba(X_, model_)
    W_hat_ = _classify(Z_hat_, prob=theta_[0], invert_label=model_[-1])
    tm = time() - tInit
    return (W_hat_, tm)
```


Overlapping Code:
```
_hat_ = _predict_proba(X_, model_)
W_hat_ = _classify(Z_hat_, prob
```
<Overlap Ratio: 0.3173076923076923>

---

--- 149 --
Question ID: 0e47d06b09a13065c0203d222fb5c4959d610194_4
Original Code:
```
def checkIfRange(request, response):
    """Checks for the If-Range header, and if it exists, checks if the
    test passes. Returns true if the server should return partial data."""
    ifrange = request.headers.getHeader('if-range')
    if ifrange is None:
        return True
    if isinstance(ifrange, http_headers.ETag):
        return ifrange.match(response.headers.getHeader('etag'), strongCompare=True)
    else:
        return ifrange == response.headers.getHeader('last-modified')
```


Overlapping Code:
```
onse):
"""Checks for the If-Range header, and if it exists, checks if the
test passes. Returns true if the server should return partial data."""
ifrange = request.headee')
if ifrange is None:
return True
if isinstance(ifrange, http_headers.ETag):
return ifrange.match(response.he
```
<Overlap Ratio: 0.6312217194570136>

---

--- 150 --
Question ID: 68c4a5c1dfedd1f00d406e741e54edfced34cff1_5
Original Code:
```
def user_info_strlist(user: telegram.User) -> list[str]:
    keys = ['User ID', 'First Name', 'Last Name', 'User Name', 'Language Code']
    values = [user.id, user.first_name, user.last_name, user.username, user.language_code]
    return combine_no_none(keys, values)
```


Overlapping Code:
```
ist[str]:
keys = ['User ID', 'First Name', 'Last Nser.id, user.first_name, user.last_name, user.username, user.language_code]
return combine_no_none(keys
```
<Overlap Ratio: 0.59765625>

---

--- 151 --
Question ID: 039644328490858f1aa80d268898976f6bf2523f_1
Original Code:
```
def deploy():
    execute(checkout)
    execute(dependencies)
    execute(make_current)
    execute(restart)
    execute(cleanup)
```


Overlapping Code:
```
 deploy():
execute(checkout)
execute(dependencies)
execute(make_current)
execute(restart)
execute(cle
```
<Overlap Ratio: 0.926605504587156>

---

--- 152 --
Question ID: d7d328944b6c85472fc3b3a7461b51d1e20de3b9_4
Original Code:
```
def punctuation_count(documents: list) -> int:
    """Count number of punctuation characters in a list of textual documents

    Keyword arguments:
    documents -- the list of textual documents.
    """
    __check_documents_param(documents)
    char_cnt = char_count(documents, ignore_spaces=True)
    charWoPunctuation = letter_count(documents, ignore_spaces=True, ignore_digits=False)
    return char_cnt - charWoPunctuation
```


Overlapping Code:
```
def punctuation_count(documents: list) -> int:
"""Count number of punctuation characters in a list of textual documents
Keyword arguments:
documents -- the list of textual documents.
"""
__check_documents_param(documents)
char_cnt = char_count(documeter_count(documents, ignore_spaces=True, ignore_di
```
<Overlap Ratio: 0.759493670886076>

---

--- 153 --
Question ID: 8e9b1c035fd0fe23e9e05c70dd0f5fd3d8067103_3
Original Code:
```
def _read_version_file():
    """
    Attempt to read the `version.py` file from the top level package.
    """
    versionFile = configuration.version_path()
    logging.info("Attempting to open '%s' and read the current version.", versionFile)
    loader = importlib.machinery.SourceFileLoader('version_module', versionFile)
    spec = importlib.util.spec_from_loader('version_module', loader)
    version_module = importlib.util.module_from_spec(spec)
    try:
        loader.exec_module(version_module)
        logging.info("Version file found. Using version '%s' found within.", version_module.__version__)
        return version_module.__version__
    except FileNotFoundError:
        logging.warning("Version file was not found at '%s'. Attempting to determine version another way.", versionFile)
    except AttributeError as err:
        logging.error(err)
        logging.warning("Version file was found at '%s', however it did not contain the variable __version__. Attempting to determine version another way.", versionFile)
    return None
```


Overlapping Code:
```
ead the `version.py` file from the top level packa)
version_module = importlib.util.module_from_spec(spec)
try:
e(version_module)
logging.info("Version file found. Using version '%s' found within.", version_module.__version__)
return version_module.__version__
except FileNotFoundError:
logging.warning("Version file was not found at '%s'. Attempting to determin
except AttributeError as err:
logging.error(err)
logging.warning("Version file was found at '%s', however it di
```
<Overlap Ratio: 0.4963350785340314>

---

--- 154 --
Question ID: ac9620fc76910d66d5eadf9c78f39e41ea6edc77_16
Original Code:
```
def plot_14(id, query):
    if 'category__in' in query:
        del query['category__in']
    query['category'] = 'B'
    data = data_plot_groupby_category(query, values=['category', 'cloud'], sum_param='jobdefcount', label_cols=['cloud'], label_translation=False)
    colors = prepare_colors_for_piechart(data)
    title = PLOT_TITLES['title' + id]
    unit = PLOT_UNITS[id]
    return (data, colors, title, unit)
```


Overlapping Code:
```
 plot_14(id, query):
if 'category__in' in query:
del query['category__in']
query['category'] = 'B'
data = data_plot_groupby_category(query, values=['category', 'cloud'], sum_param='jobdefcoel_cols=['cloud'], label_translation=False)
colors = prepare_colors_for_piechart(data)
title = PLOT_TITLES['title' + id]
unit = PLOT_UNITS[id]
return 
```
<Overlap Ratio: 0.8968253968253969>

---

--- 155 --
Question ID: 8502057a4b3bf916aba610da48747e7b8d5604e4_2
Original Code:
```
def load_data():
    moon_data = np.load('moon_data.npz')
    x_s = moon_data['x_s']
    y_s = moon_data['y_s']
    xT = moon_data['x_t']
    return (torch.from_numpy(x_s).float(), torch.from_numpy(y_s).float(), torch.from_numpy(xT).float())
```


Overlapping Code:
```
n_data.npz')
x_s = moon_data['x_s']
y_s = moon_data['y_s']
t(), torch.from_numpy(y_s).float(), torch.from_num
```
<Overlap Ratio: 0.49321266968325794>

---

--- 156 --
Question ID: 85d7907789cbbb8ce6e2019eb09711694ee29577_0
Original Code:
```
def test_main():

    def cmd(*args, **kwargs):
        try:
            main.callback(*args, **kwargs)
            return 0
        except SystemExit as e:
            return e.code
    inpath = 'examples/test.py'
    outpath = 'examples/test.xml'
    assert cmd(inpath, outpath, verbose=True, string=True) == 0
    assert cmd(inpath, outpath, help=True) == 0
    assert cmd(inpath, outpath, reload=True) == 0
    assert cmd(inpath, outpath, version=True) == 0
    assert cmd(inpath, outpath, list_peripherals=True) == 0
```


Overlapping Code:
```

try:
main.callback(*args, **kwargs)
return 0
except SystemExit as e:
return e.code
inpath = 'examplmd(inpath, outpath, verbose=True, string=True) == 
```
<Overlap Ratio: 0.3440366972477064>

---

--- 157 --
Question ID: dbdac17e96cf66994ed82d897eac1d43424c6c6f_12
Original Code:
```
def collect_bstock(pop, sp_idcs, farm_idx):
    """Migrate marked broodstock from source subpopulation
    to farm subpopulation."""
    for spIdx in sp_idcs:
        for ind in pop.individuals([spIdx]):
            if ind.broodstock == 1:
                ind.migrate_to = farm_idx
            else:
                ind.migrate_to = spIdx
    sim.migrate(pop, mode=sim.BY_IND_INFO)
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 158 --
Question ID: b85923ab8b9e16da8df9357a1215d9b3530c1988_1
Original Code:
```
def detect(image):
    detector = dlib.get_frontal_face_detector()
    imgGray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
    rects = detector(imgGray, 0)
    return rects
```


Overlapping Code:
```
 detect(image):
detector = dlib.get_frontal_face_d
```
<Overlap Ratio: 0.3246753246753247>

---

--- 159 --
Question ID: b36f29adbca75035b8a5747f2e0405b7dd6b8caf_1
Original Code:
```
def roll20(querry=None):
    """
    Searches roll20.net for a querry and opens the search in a webbrowser.
    :param querry: String to search for.  If none is provided, asks the user.
    :return: None
    """
    if querry is None:
        querry = simpledialog.askstring('Search Roll20', 'Search Roll20.net for:')
    if querry is not None:
        url = 'https://roll20.net/compendium/dnd5e/searchbook/?terms=' + querry
        webbrowser.open(url)
```


Overlapping Code:
```
s roll20.net for a querry and opens the search in a webbrowser.
:param querry: String to search for. If none is provided, asks the user.
:return: None
"""
if querry is None:
querry = simpledialog.asks
```
<Overlap Ratio: 0.5>

---

--- 160 --
Question ID: 31a0f40f5b3b73886fe6be3847e4043e0c0b0471_8
Original Code:
```
def checkEntries(DataSetFile, preprocess=lambda x: x, dataType='jpg'):
    dataset = wds.WebDataset(DataSetFile)
    items_touched = 0
    for element in dataset:
        print(element['__key__'])
        preprocess(element[dataType])
        tmp = element[0]
        if not tmp == None:
            items_touched += 1
    return items_touched
```


Overlapping Code:
```
et:
print(element['__key__'])
preprocess(element[d
```
<Overlap Ratio: 0.17667844522968199>

---

--- 161 --
Question ID: db491fb88dce762693e7f13205150b53101924e2_2
Original Code:
```
@pytest.mark.parametrize(['augmentation_cls', 'params'], get_dual_transforms(custom_arguments={A.Crop: {'y_min': 0, 'y_max': 10, 'x_min': 0, 'x_max': 10}, A.CenterCrop: {'height': 10, 'width': 10}, A.CropNonEmptyMaskIfExists: {'height': 10, 'width': 10}, A.RandomCrop: {'height': 10, 'width': 10}, A.RandomResizedCrop: {'height': 10, 'width': 10}, A.RandomSizedCrop: {'min_max_height': (4, 8), 'height': 10, 'width': 10}, A.CropAndPad: {'px': 10}, A.Resize: {'height': 10, 'width': 10}}, except_augmentations={A.RandomCropNearBBox, A.RandomSizedBBoxSafeCrop}))
def test_dual_augmentations(augmentation_cls, params, image, mask):
    aug = augmentation_cls(p=1, **params)
    data = aug(image=image, mask=mask)
    assert data['image'].dtype == np.uint8
    assert data['mask'].dtype == np.uint8
```


Overlapping Code:
```
t.mark.parametrize(['augmentation_cls', 'params'], ns={A.RandomCropNearBBox, A.RandomSizedBBoxSafeCrodef test_dual_augmentations(augmentation_cls, params, image, mask):
aug = augmentation_cls(p=1, **params)
data = aug(image=image, mask=mask)
assert data['image'].dtype == np.uint8
assert data['mask'].dtype == np.
```
<Overlap Ratio: 0.4023136246786632>

---

--- 162 --
Question ID: 1b67a7d9d4167a9df6ed58c7d637b09510718d46_1
Original Code:
```
def spider(headers, conferences_url):
    for conferenceUrl in conferences_url:
        html_level1 = requests.get(conferenceUrl, headers=headers).content
        tree_level1 = etree.HTML(html_level1)
        conferences = tree_level1.xpath("//a[contains(@href, 'dblp.uni-trier.de/db/conf/') and contains(@href, 'html')]/@href")
        conferences = list(set(conferences))
        fp_dir = os.path.split(os.path.realpath(sys.argv[0]))[0] + os.sep + 'source' + os.sep + 'conf' + os.sep + conferenceUrl.split('/')[-2]
        if not os.path.exists(fp_dir):
            os.makedirs(fp_dir)
        for conference in conferences:
            fp_name = fp_dir + os.sep + conference.split('/')[-1].split('.')[0] + '.csv'
            if os.path.exists(fp_name):
                print('History: ', fp_name.encode('utf-8'))
                continue
            html_level2 = requests.get(conference, headers=headers).content
            tree_level2 = etree.HTML(html_level2)
            if tree_level2.xpath("//li[@class='entry inproceedings']"):
                extractor(tree_level2, fp_name)
            else:
                volumes = tree_level2.xpath("//*[@id='main']/ul/li/a/@href")
                for volume in volumes:
                    fp_name = fp_dir + os.sep + volume.split('/')[-1].split('.')[0] + '.csv'
                    if os.path.exists(fp_name):
                        print('History: ', fp_name.encode('utf-8'))
                        continue
                    html_level3 = requests.get(volume, headers=headers).content
                    tree_level3 = etree.HTML(html_level3)
                    extractor(tree_level3, fp_name)
```


Overlapping Code:
```
ferences_url:
html_level1 = requests.get(conferencders).content
tree_level1 = etree.HTML(html_level1)
conferences = tree_level1.xpath("//a[contains(@href, 'dblp.uni-trier.de/db/conf/') and contains(@href, 'html')]/@href")
conferences = list(set(conferences))
fp_dir = os.path.split(os.path.realpath(sys.argv[0]))[0] + os.sep + 'source' + os.sel.split('/')[-2]
if not os.path.exists(fp_dir):
osor conference in conferences:
fp_name = fp_dir + oh.exists(fp_name):
print('History: ', fp_name.encode('utf-8'))
continue
html_level2 = requests.get(cevel2.xpath("//*[@id='main']/ul/li/a/@href")
for vh.exists(fp_name):
print('History: ', fp_name.encode('utf-8'))
con
```
<Overlap Ratio: 0.51484375>

---

--- 163 --
Question ID: 86b7411d0f37a9a1b85f3b8b0f899c31c9cc6336_104
Original Code:
```
@pytest.mark.filterwarnings('ignore:This function is not safe at the moment')
@pytest.mark.parametrize('input_type', [tuple, list])
@requires_tables
def test_complete_irradiance_arrays(sapm_dc_snl_ac_system_same_arrays, location, input_type):
    """ModelChain.complete_irradiance can accept a tuple of weather
    DataFrames."""
    times = pd.date_range(start='2020-01-01 0700-0700', periods=2, freq='H')
    weather = pd.DataFrame({'dni': [2, 3], 'dhi': [4, 6], 'ghi': [9, 5]}, index=times)
    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)
    with pytest.raises(ValueError, match='Input DataFrames must have same index\\.'):
        mc.complete_irradiance(input_type((weather, weather[1:])))
    mc.complete_irradiance(input_type((weather, weather)))
    for mcWeather in mc.results.weather:
        assert_series_equal(mcWeather['dni'], pd.Series([2, 3], index=times, name='dni'))
        assert_series_equal(mcWeather['dhi'], pd.Series([4, 6], index=times, name='dhi'))
        assert_series_equal(mcWeather['ghi'], pd.Series([9, 5], index=times, name='ghi'))
    mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)
    mc.complete_irradiance(input_type((weather[['ghi', 'dhi']], weather[['dhi', 'dni']])))
    assert 'dni' in mc.results.weather[0].columns
    assert 'ghi' in mc.results.weather[1].columns
    mc.complete_irradiance(input_type((weather, weather[['ghi', 'dni']])))
    assert_series_equal(mc.results.weather[0]['dhi'], pd.Series([4, 6], index=times, name='dhi'))
    assert_series_equal(mc.results.weather[0]['ghi'], pd.Series([9, 5], index=times, name='ghi'))
    assert_series_equal(mc.results.weather[0]['dni'], pd.Series([2, 3], index=times, name='dni'))
    assert 'dhi' in mc.results.weather[1].columns
```


Overlapping Code:
```
m_same_arrays, location, input_type):
"""ModelChain.complete_irradiance can accept a tuple of weather
DataFrames."""
times = pd.date_range(start='2020-01-01 0700-0700', periods=2, freq='H')
weather = ataFrame({'dni': [2, 3], 'dhi': [4, 6], 'ghi': [9, 5]}, index=times)
mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)
with pytest.rais(weather, weather[1:])))
mc.complete_irradiance(ind.Series([2, 3], index=times, name='dni'))
assert_series_eq[4, 6], index=times, name='dhi'))
assert_series_eqes, name='ghi'))
mc = ModelChain(sapm_dc_snl_ac_system_same_arrays, location)
mc.complete_irradiancei', 'dni']])))
assert 'dni' in mc.results.weather[0].columns
assert 'ghi' in mc.results.weather[1].columns
mc.complete_irradiance(input_type((weather, weather[['ghi', 'dni']])))
assert_series_equal(mc[4, 6], index=times, name='dhi'))
assert_series_equal(mc.resuls, name='ghi'))
assert_series_equal(mc.results.weae='dni'))
assert 'dhi' in mc.results.weather[1].co
```
<Overlap Ratio: 0.5839371980676329>

---

--- 164 --
Question ID: 3ad888b6411bf731d2ffa031e8ac7e352cb37d45_1
Original Code:
```
@bp.route('/create', methods=('GET', 'POST'))
@login_required
def create():
    if request.method == 'POST':
        name = request.form['name']
        description = request.form['description']
        error = None
        if not name:
            error = 'Name is required.'
        if error is not None:
            flash(error)
        else:
            db = get_db()
            db.execute('INSERT INTO dens (name, description, author_id) VALUES (?, ?, ?)', (name, description, g.user['id']))
            db.commit()
            return redirect(url_for('dens.index'))
    return render_template('dens/create.html')
```


Overlapping Code:
```
@bp.route('/create', methods=('GET', 'POST'))
@login_required
def create():
if request.method == 'POST':
name = request.form['name']
description = request.form['description']
error = None
if not name:
error = 'Name is required.'
if error is not None:
flash(error)
else:
db = get_db()
db.execute(mmit()
return redirect(url_for('dens.index'))
retu
```
<Overlap Ratio: 0.7026476578411406>

---

--- 165 --
Question ID: 1e6e4ef45a8b40afebac91fb3f7bf135a4a6341f_3
Original Code:
```
def get_tags(pipeline):
    nodes = pipeline.nodes
    tags = {node.name: node.tags for node in nodes}
    return tags
```


Overlapping Code:
```
e):
nodes = pipeline.nodes
tags = {node.name: node
```
<Overlap Ratio: 0.4716981132075472>

---

--- 166 --
Question ID: c0e6fb6fdeb419f4456ff38cda990830605dba2c_2
Original Code:
```
def calculate_bead_lims(bead_size, region_revs, region_fors):
    """
    Divides a region on a chromosome (or rather, the part of it covered by complete
    restriction fragments) into segments of equal, given length and one last
    segment which is smaller than the others such that the segments completely
    cover the region. These segments will be represented by spherical beads later.
    Returns the limits of the segments
    """
    regionLength = np.max((region_fors[-1, 1], region_revs[1, -1])) - np.min((region_fors[0, 0], region_revs[0, 0]))
    n_beads = int(round(regionLength / bead_size)) + 1
    bead_lims = [np.min((region_fors[0, 0], region_revs[0, 0])) + i * bead_size for i in range(n_beads)]
    bead_lims[-1] = np.max((region_fors[-1, 1], region_revs[1, -1]))
    return np.array(bead_lims)
```


Overlapping Code:
```
ef calculate_bead_lims(bead_size, region_revs, region_fors):
"""
Divides a region on a chromosome (or rather, the part of it covered by complete
restriction fragments) into segments of equal, given length and one last
segment which is smaller than the others such that the segments completely
cover the region. These segments will be represented by spherical beads later.
Returns the limits of the sep.min((region_fors[0, 0], region_revs[0, 0]))
n_beor i in range(n_beads)]
bead_lims[-1] = np.max((re
```
<Overlap Ratio: 0.6510416666666666>

---

--- 167 --
Question ID: 8086f65407ad32c804e1c9c38b95a0d946baf627_14
Original Code:
```
def _spec_from_colon_separated_text_list(spec_name: str):
    """
    Get a specification value from a list of colon separated values in

    `_general_specs(...)` returns a list of strings of with the format
    `Spec Name: Spec Value`.
    TODO: Implement and use this. Refactor `ttaf(...)`
    """
```


Overlapping Code:
```
m_colon_separated_text_list(spec_name: str):
"""
Get a specification value from a list of colon separated values in
`_general_specs(...)` returns a list of strings of with the format
`Spec Name: Spec Value`.
TODO: Implement and use this. Refactor `tt
```
<Overlap Ratio: 0.9090909090909091>

---

--- 168 --
Question ID: 623568b4c78cf9a439d74b2c528e6cff22e0cadb_0
Original Code:
```
def detect_text(content):
    """Detects text in the file."""
    from google.cloud import vision
    import io
    client = vision.ImageAnnotatorClient()
    content_base64 = base64.b64decode(content)
    image = vision.Image(content=content_base64)
    response = client.text_detection(image=image)
    text = response.text_annotations[0].description
    return text
```


Overlapping Code:
```
(content):
"""Detects text in the file."""
from google.cloud import vision
import io
client = vision.ImageAnnotatorClient()
content_base64 = base64.b64decode(content)
image = vision.Image(content=content_base64)
response = client.text_detection(image=image)
text = response.text_annotations[0].descri
```
<Overlap Ratio: 0.9036144578313253>

---

--- 169 --
Question ID: 811ab0d25f1780d5e5c2deb38dcaf25cb83fa07a_1
Original Code:
```
def deletecall(bam_url, api_call, call_parameters, delete_entity, header):
    """API request to delete and return values"""
    callUrl = 'http://' + bam_url + '/Services/REST/v1/' + api_call + '?'
    print('You are requesting to delete:')
    print(delete_entity)
    answer = input('Do you want to proceed (y (yes) or n (no))? ')
    try:
        if answer.lower() == 'y':
            response = requests.delete(callUrl, params=call_parameters, headers=header)
            return response.json()
        elif answer.lower() == 'n':
            return 'You aborted deletion'
        else:
            return 'You entered an invalid character'
    except requests.exceptions.RequestException as e:
        print(e)
```


Overlapping Code:
```
i_call, call_parameters, delete_entity, header):
"""API request to delete and return values"""'
except requests.exceptions.RequestException as e:
print(e)
```
<Overlap Ratio: 0.2532894736842105>

---

--- 170 --
Question ID: f6667e4bee5b954c1e12aaebccf65cda7aa78ce7_0
Original Code:
```
def generate_sub_id():
    timestamp = floor(time() * 1000)
    randomId = randint(0, 999)
    return f'sub-{timestamp}-{randomId:03}'
```


Overlapping Code:
```
generate_sub_id():
timestamp = floor(time() * 1000)
ran
```
<Overlap Ratio: 0.45081967213114754>

---

--- 171 --
Question ID: 793c76b7aef3c3464b9f0b5785241de95f0cc1ed_4
Original Code:
```
def draw_flow(img, flow, step=16):
    (h, w) = img.shape[:2]
    (y, x) = np.mgrid[step / 2:h:step, step / 2:w:step].reshape(2, -1).astype(int)
    (fx, fy) = flow[y, x].T
    lines = np.vstack([x, y, x + fx, y + fy]).T.reshape(-1, 2, 2)
    lines = np.int32(lines + 0.5)
    vis = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
    cv2.polylines(vis, lines, 0, (0, 255, 0))
    for ((x1, y1), (_x2, _y2)) in lines:
        cv2.circle(vis, (x1, y1), 1, (0, 255, 0), -1)
    return vis
```


Overlapping Code:
```
 = np.mgrid[step / 2:h:step, step / 2:w:step].reshape(2, -1).astype(iflow[y, x].T
lines = np.vstack([x, y, x + fx, y + fy]).T.reshape(-1, 2, 2)
lines = np.int32(lines + 0.5)
vis = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
cv2.polylines(vis, lines, 0, (0, 255, 0))
for ((x1, y1), (_x2, _y2)) in lines:
cv2.circle(vis, (x1, y1), 1, (0, 255, 0), -1)
return vis
```
<Overlap Ratio: 0.8171296296296297>

---

--- 172 --
Question ID: ff326af30a0e940467d42ebccf60e036d6b028f5_78
Original Code:
```
@bot.command()
async def listening(ctx, *, message=None):
    await ctx.message.delete()
    if message is None:
        commandprint("Command 'listening' has been used by " + bot.user.name + ' with no message')
        embed = discord.Embed(title=f'**Invalid syntax**', description='You have not specified a listening \nExample: ' + prefix + 'listening flairings piss', color=errorcolor)
        embed.set_footer(text=footer)
        await ctx.send(embed=embed, delete_after=deletetimer)
    else:
        try:
            commandprint("Command 'listening' has been used by " + bot.user.name + " with a message of '" + message + "'")
            await bot.change_presence(activity=discord.Activity(type=discord.ActivityType.listening, name=message))
            em = discord.Embed(title=f'**STATUS CHANGED**', description="Your listening status has been set to **'" + message + "'**", color=color)
            em.set_footer(text=footer)
            await ctx.send(embed=em, delete_after=deletetimer)
        except Exception as error:
            errorprint("Exception ' {0} ', expected error message sent to users chat".format(error))
            em = discord.Embed(title='Exception Error:', description='Expected Exception: You already have a custom status. \n Console Exception {0}'.format(error), color=errorcolor)
            await ctx.send(embed=em, delete_after=deletetimer)
```


Overlapping Code:
```
ctx, *, message=None):
await ctx.message.delete()

embed.set_footer(text=footer)
await ctx.send(embed=embed")
await bot.change_presence(activity=discord.Activity(type=discord.ActivityType.listening, name=messaem.set_footer(text=footer)
await ctx.send(embed=em
```
<Overlap Ratio: 0.21125611745513867>

---

--- 173 --
Question ID: d7d3d58fe31aa429507c3843cdedb9be62480884_3
Original Code:
```
def outgoing_message(message):
    messageLabel = tk.Label(messages_frame, bg='gray20', fg='snow', text=message, font=('Helvetica', 15))
    messageLabel.pack(side=tk.TOP, anchor=tk.E, padx=20, pady=10)
    message_labels.append(messageLabel)
```


Overlapping Code:
```
abel = tk.Label(messages_frame, bg='gray20', fg='s
```
<Overlap Ratio: 0.21739130434782608>

---

--- 174 --
Question ID: 82966286972b9d3c71d206d1668d569e596aeedd_105
Original Code:
```
@require_context
def quota_class_get_all_by_name(context, class_name):
    authorize_quota_class_context(context, class_name)
    rows = model_query(context, models.QuotaClass, read_deleted='no').filter_by(class_name=class_name).all()
    result = {'class_name': class_name}
    for row in rows:
        result[row.resource] = row.hard_limit
    return result
```


Overlapping Code:
```
ire_context
def quota_class_get_all_by_name(context, class_name):
authorize_quota_class_context(context, class_name)
rows = model_query(context, models.QuotaClass, read_deleted=()
result = {'class_name': class_name}
for row in rows:
result[row.resource] = row.hard_limit
return resul
```
<Overlap Ratio: 0.8549848942598187>

---

--- 175 --
Question ID: 8c0c41d89d485b342b3470a122b1a94215a4cc9f_1
Original Code:
```
def main():
    import glob
    parent = sys.argv[1]
    folders = glob.glob('{}/*_output'.format(parent))
    submit_qsub(parent, folders)
```


Overlapping Code:
```
lders = glob.glob('{}/*_output'.format(parent))
su
```
<Overlap Ratio: 0.4065040650406504>

---

--- 176 --
Question ID: f32dd5e74bf9879ee46da2157293834813f6746b_1
Original Code:
```
def _get_package_bin_dir_app_paths(venv: Venv, package_info: PackageInfo, local_bin_dir: Path) -> Set[Path]:
    suffix = package_info.suffix
    apps = []
    if package_info.include_apps:
        apps += package_info.apps
    if package_info.include_dependencies:
        apps += package_info.apps_of_dependencies
    return get_exposed_app_paths_for_package(venv.bin_path, local_bin_dir, [add_suffix(app, suffix) for app in apps])
```


Overlapping Code:
```
ix = package_info.suffix
apps = []
if package_info.include_apps:
apps += package_info.apps
if package_info.include_dependencies:
apps += package_info.apps_of_dependencies
return get_exposed_app_paths_
```
<Overlap Ratio: 0.5037783375314862>

---

--- 177 --
Question ID: c039023785903aca6301e71b8b73beaa059d6ec4_1
Original Code:
```
def duplicateGroup(id):
    group = CreatureGroup.objects.get(id=id)
    new_group = CreatureGroup(name='%s_duplicate' % group.name, Augmented=group.Augmented)
    new_group.Grouping = group.Grouping
    new_group.save()
    for item in group.AllowedExtraType.all():
        new_group.AllowedExtraType.add(item)
    for item in group.DefaultExtraType.all():
        new_group.DefaultExtraType.add(item)
    for item in group.groupentry_set.all():
        GroupEntry(Group=new_group, creature=item.creature).save()
```


Overlapping Code:
```
oup.save()
for item in group.AllowedExtraType.all(raType.add(item)
for item in group.groupentry_set.
```
<Overlap Ratio: 0.21691973969631237>

---

--- 178 --
Question ID: 21093aba0c887e3f2abc8c2d98ef2ec29048b249_5
Original Code:
```
def time_stamps(seconds, sample_rate, sample_length, sample_duration):
    """Process to calculate the intervals based on the window size or time intervals.
    Parameters
    ----------
    seconds : int or list
        Can be of two types. int; a single value that determines the window size (seconds). list; a set of intervals, where each value is in (seconds).
    sample_rate : float
        Sample frequency used in the EEG (Hz).
    sample_length : float
        Sample length in data points (seconds x sample frequency).
    sample_duration : float
        Duration of the EEG (seconds).
    
    Returns
    -------
    intervals : list
        List with the intervals, pairs of (Start, End) values in data points (seconds x sample frequency).
    """
    (intervals, i, flag) = ([], 0, 0)
    if type(seconds) == list:
        if len(seconds) == 1:
            seconds = seconds[0]
        else:
            if seconds[-1] > sample_duration.round():
                raise Exception('Error in Window size. Intervals exceeds sample length.')
            if seconds[0] != 0:
                raise Exception('Error in Window size. First interval must be 0.')
            else:
                diff = np.diff(seconds)
                for (j, value) in enumerate(diff):
                    samplesPerFrame = value * sample_rate
                    intervals.append((i, i + samplesPerFrame))
                    i += samplesPerFrame
    if type(seconds) == int or type(seconds) == float:
        samplesPerFrame = seconds * sample_rate
        while i + samplesPerFrame <= sample_length:
            intervals.append((i, i + samplesPerFrame))
            i = i + samplesPerFrame
        if i + samplesPerFrame > sample_length:
            intervals.append((i, sample_length))
    intervals_rounded = [(round(steps[0], 2), round(steps[1], 2)) for steps in intervals]
    print('Intervals: ', intervals_rounded)
    if len(intervals) == 1:
        intervals.append((0, sample_rate))
        flag = 1
    return (intervals, flag)
```


Overlapping Code:
```
 sample_length, sample_duration):
"""Process to calculate the intervals based on the window size or time intervals.
Parameters
----------
seconds : int or list
Can be of two types. int; a single value that determines the window size (seconds). list; a set of intervals, where each value is in (seconds).
sample_rate : float
Sample frequency used in the EEG (Hz).
sample_length : float
Sample length in data points (seconds x sample frequency).
sample_duration : float
Duration of the EEG (seconds).

Returns
-------
intervals : list
List with the intervals, pairs of (Start, End) values in data pointe(seconds) == list:
if len(seconds) == 1:
seconds 
```
<Overlap Ratio: 0.3941782898726501>

---

--- 179 --
Question ID: df37bb46962a858756a40ea08c445056a8eba2a4_1
Original Code:
```
def config_to_functions(config):
    """
    Takes in the data for a config and returns a list of functions to call the meet it's criteria.
    list of str -> list of (none -> (str, any))
    """
    functions = []
    inMultilineComment = False
    for line in config:
        line = remove_new_lines(line)
        inMultilineComment = inMultilineComment or line_starts_multiline_comment_start(line)
        multiline_comment_end = line_starts_multiline_comment_end(line)
        if not inMultilineComment and multiline_comment_end:
            message = 'Multiline comment end: ' + constants.MULTILINE_COMMENT_END
            message += ' must inclose a comment.'
            raise Exception(message)
        if multiline_comment_end:
            inMultilineComment = False
        if is_line_commented(line) or is_empty_line(line) or inMultilineComment or multiline_comment_end:
            continue
        check_config_line(line)
        command_type = get_command_type(line)
        if not is_type(command_type) and (not is_complex_type(command_type)):
            on_not_valid_type(command_type)
        definition = get_command_definition(line)
        functions.append(build_input_func(any_type_to_input_functions(command_type, definition), command_type))
    if inMultilineComment:
        message = 'Multiline comment start: ' + constants.MULTILINE_COMMENT_START
        message += ' must be inclosed with: ' + constants.MULTILINE_COMMENT_END
        raise Exception(message)
    return functions
```


Overlapping Code:
```
he data for a config and returns a list of functions to call the meet it's criteria.
list of str -> mment_start(line)
multiline_comment_end = line_staultiline comment end: ' + constants.MULTILINE_COMMENT_END
message += ' must inclose a comment.'
raise = get_command_type(line)
if not is_type(command_t_valid_type(command_type)
definition = get_commanonstants.MULTILINE_COMMENT_START
message += ' must be inclosed with: ' + constants.MULTILINE_COMMENT
```
<Overlap Ratio: 0.34965034965034963>

---

--- 180 --
Question ID: 4fbd04e883334dd6fb994cd9cbab874f5c4a5931_1
Original Code:
```
def load_spectrum(filename, grid):
    """
    Load a single spectrum
    """
    file_in = pyfits.open(filename)
    wl = np.array(file_in[0].data[2])
    flux = np.array(file_in[0].data[0])
    ivar = np.array(file_in[0].data[1])
    redshift = file_in[0].header['Z']
    wlShifted = wl - redshift * wl
    flux_rs = interpolate.interp1d(wlShifted, flux)(grid)
    ivar_rs = interpolate.interp1d(wlShifted, ivar)(grid)
    ivar_rs[ivar_rs < 0] = 0.0
    return (flux_rs, ivar_rs)
```


Overlapping Code:
```
, grid):
"""
Load a single spectrum
"""
file_in = pyfits.open(filename)
wl = np.array(file_in[0].data[2])
flux = np.array(file_in[0].data[0])
ivar = np
```
<Overlap Ratio: 0.351981351981352>

---

--- 181 --
Question ID: 60a398f13b9ba05c02fed5b550c7fed93451f969_0
Original Code:
```
def serializedATN():
    with StringIO() as buf:
        buf.write('\x03悋Ꜫ脳맭䅼㯧瞆奤\x03\x1a')
        buf.write('\x82\x04\x02\t\x02\x04\x03\t\x03\x04\x04\t\x04\x04\x05\t\x05\x04\x06\t\x06\x04\x07\t\x07')
        buf.write('\x04\x08\t\x08\x04\t\t\t\x04\n\t\n\x04\x0b\t\x0b\x04\x0c\t\x0c\x04\r\t\r\x04\x0e')
        buf.write('\t\x0e\x04\x0f\t\x0f\x03\x02\x05\x02 \n\x02\x03\x02\x03\x02\x05\x02$\n\x02\x03\x02\x03\x02')
        buf.write('\x03\x02\x03\x02\x03\x03\x03\x03\x05\x03,\n\x03\x07\x03.\n\x03\x0c\x03\x0e\x031\x0b\x03\x03')
        buf.write('\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x05\x04;\n\x04\x03\x05\x03\x05\x03\x05\x03')
        buf.write('\x06\x03\x06\x05\x06B\n\x06\x03\x06\x06\x06E\n\x06\r\x06\x0e\x06F\x03\x07\x03\x07\x03\x07\x05\x07')
        buf.write('L\n\x07\x03\x07\x05\x07O\n\x07\x06\x07Q\n\x07\r\x07\x0e\x07R\x03\x08\x03\x08\x05\x08W\n\x08')
        buf.write('\x03\x08\x03\x08\x05\x08[\n\x08\x03\t\x03\t\x03\t\x05\t`\n\t\x06\tb\n\t\r\t\x0e')
        buf.write('\tc\x03\n\x03\n\x03\x0b\x03\x0b\x05\x0bj\n\x0b\x03\x0c\x03\x0c\x05\x0cn\n\x0c\x03\r')
        buf.write('\x03\r\x03\r\x03\r\x05\rt\n\r\x03\x0e\x03\x0e\x05\x0ex\n\x0e\x05\x0ez\n\x0e')
        buf.write('\x03\x0e\x03\x0e\x03\x0e\x03\x0e\x03\x0f\x03\x0f\x03\x0f\x02\x02\x10\x02\x04\x06\x08\n\x0c')
        buf.write('\x0e\x10\x12\x14\x16\x18\x1a\x1c\x02\x06\x03\x02\x0e\x0f\x04\x02\x0e\x0e\x10\x11')
        buf.write('\x03\x02\n\x0b\x03\x02\x13\x16\x02\x89\x02\x1f\x03\x02\x02\x02\x04/\x03\x02\x02\x02\x06')
        buf.write(':\x03\x02\x02\x02\x08<\x03\x02\x02\x02\nD\x03\x02\x02\x02\x0cP\x03\x02\x02\x02\x0eV\x03\x02\x02\x02')
        buf.write('\x10a\x03\x02\x02\x02\x12e\x03\x02\x02\x02\x14g\x03\x02\x02\x02\x16k\x03\x02\x02\x02\x18o\x03')
        buf.write('\x02\x02\x02\x1ay\x03\x02\x02\x02\x1c\x7f\x03\x02\x02\x02\x1e \x07\r\x02\x02\x1f\x1e\x03')
        buf.write('\x02\x02\x02\x1f \x03\x02\x02\x02 !\x03\x02\x02\x02!#\t\x02\x02\x02"$\x05\x1c\x0f\x02#"')
        buf.write("\x03\x02\x02\x02#$\x03\x02\x02\x02$%\x03\x02\x02\x02%&\x07\x03\x02\x02&'\x05\x04\x03\x02'(\x07")
        buf.write('\x04\x02\x02(\x03\x03\x02\x02\x02)+\x05\x06\x04\x02*,\x07\x05\x02\x02+*\x03\x02\x02\x02+,\x03\x02')
        buf.write('\x02\x02,.\x03\x02\x02\x02-)\x03\x02\x02\x02.1\x03\x02\x02\x02/-\x03\x02\x02\x02/0\x03\x02')
        buf.write('\x02\x020\x05\x03\x02\x02\x021/\x03\x02\x02\x022;\x05\x14\x0b\x023;\x05\x0e\x08')
        buf.write('\x024;\x05\x08\x05\x0256\x05\x1c\x0f\x0267\x07\x06\x02\x0278\x05\x1c')
        buf.write('\x0f\x028;\x03\x02\x02\x029;\x05\x1a\x0e\x02:2\x03\x02\x02\x02:3\x03\x02\x02\x02:4')
        buf.write('\x03\x02\x02\x02:5\x03\x02\x02\x02:9\x03\x02\x02\x02;\x07\x03\x02\x02\x02<=\t\x03\x02\x02=>')
        buf.write('\x05\n\x06\x02>\t\x03\x02\x02\x02?A\x07\x07\x02\x02@B\x05\x0c\x07\x02A@\x03\x02\x02\x02AB\x03')
        buf.write('\x02\x02\x02BC\x03\x02\x02\x02CE\x07\x08\x02\x02D?\x03\x02\x02\x02EF\x03\x02\x02\x02FD\x03\x02\x02')
        buf.write('\x02FG\x03\x02\x02\x02G\x0b\x03\x02\x02\x02HK\x05\x1c\x0f\x02IJ\x07\x06\x02\x02JL\x05\x1c')
        buf.write('\x0f\x02KI\x03\x02\x02\x02KL\x03\x02\x02\x02LN\x03\x02\x02\x02MO\x07\t\x02\x02NM\x03\x02\x02')
        buf.write('\x02NO\x03\x02\x02\x02OQ\x03\x02\x02\x02PH\x03\x02\x02\x02QR\x03\x02\x02\x02RP\x03\x02\x02\x02R')
        buf.write('S\x03\x02\x02\x02S\r\x03\x02\x02\x02TW\x05\x16\x0c\x02UW\x05\x1a\x0e\x02VT\x03\x02\x02\x02')
        buf.write('VU\x03\x02\x02\x02WX\x03\x02\x02\x02XZ\x05\x10\t\x02Y[\x05\n\x06\x02ZY\x03\x02\x02\x02Z[')
        buf.write('\x03\x02\x02\x02[\x0f\x03\x02\x02\x02\\_\x05\x12\n\x02]`\x05\x16\x0c\x02^`\x05\x1a\x0e')
        buf.write('\x02_]\x03\x02\x02\x02_^\x03\x02\x02\x02`b\x03\x02\x02\x02a\\\x03\x02\x02\x02bc\x03\x02\x02\x02')
        buf.write('ca\x03\x02\x02\x02cd\x03\x02\x02\x02d\x11\x03\x02\x02\x02ef\t\x04\x02\x02f\x13\x03\x02\x02\x02')
        buf.write('gi\x05\x16\x0c\x02hj\x05\n\x06\x02ih\x03\x02\x02\x02ij\x03\x02\x02\x02j\x15\x03\x02\x02\x02')
        buf.write('km\x05\x1c\x0f\x02ln\x05\x18\r\x02ml\x03\x02\x02\x02mn\x03\x02\x02\x02n\x17\x03\x02\x02')
        buf.write('\x02op\x07\x0c\x02\x02ps\x05\x1c\x0f\x02qr\x07\x0c\x02\x02rt\x05\x1c\x0f\x02sq\x03\x02\x02')
        buf.write('\x02st\x03\x02\x02\x02t\x19\x03\x02\x02\x02uw\x07\x12\x02\x02vx\x05\x1c\x0f\x02wv\x03\x02')
        buf.write('\x02\x02wx\x03\x02\x02\x02xz\x03\x02\x02\x02yu\x03\x02\x02\x02yz\x03\x02\x02\x02z{\x03\x02\x02\x02')
        buf.write('{|\x07\x03\x02\x02|}\x05\x04\x03\x02}~\x07\x04\x02\x02~\x1b\x03\x02\x02\x02\x7f\x80\t')
        buf.write('\x05\x02\x02\x80\x1d\x03\x02\x02\x02\x15\x1f#+/:AFKNRVZ_cimswy')
        return buf.getvalue()
```


Overlapping Code:
```
def serializedATN():
with StringIO() as buf:
buf.write(\x04\x02\t\x02\x04\x03\t\x03\x04\x04\t\x04\x04\x05\t\x05\x04\x06\t\x06\x04\x07\\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x05\\x0e')
buf.write('\tc\x03\n\x03\n\x03\x0b\x03\x0b\03\x0e\x03\x0e\x03\x0e\x03\x0e\x03\x0f\x03\x0f\x03
```
<Overlap Ratio: 0.1293812202509736>

---

--- 182 --
Question ID: 79b07cf6f3f380f296c7ce80ec1c84c5aa0ae81e_2
Original Code:
```
def deep_seq_design():
    root_dir = f'data/design/cullpdb_val_deep/{exp_flag}anneal_val_deep'
    mut_matrix_anneal = np.zeros((20, 20))
    native_aa_all = []
    design_aa_all = []
    seq_len = []
    recovery = []
    pdb_id_all = []
    recovery_res = np.zeros(20)
    countRes = np.zeros(20)
    num = 100
    for pdb_id in pdb_selected:
        seq_best_all = []
        for j in range(num):
            data_anneal = h5py.File(f'{root_dir}/{pdb_id}_profile_{j}.h5', 'r')
            designed_seq = data_anneal['profile'][()]
            seq_best = designed_seq[1]
            seq_best_all.append(seq_best)
            seq_native = designed_seq[0]
            recovery_fraction = np.sum(seq_best == seq_native) / float(len(seq_native))
            recovery.append(recovery_fraction)
            seq_len.append(len(seq_native))
            pdb_id_all.append(pdb_id)
            for i in range(seq_native.shape[0]):
                mut_matrix_anneal[map_aa[seq_native[i]], map_aa[seq_best[i]]] += 1
                native_aa_all.append(map_aa[seq_native[i]])
                design_aa_all.append(map_aa[seq_best[i]])
            for i in range(20):
                idx = seq_native == i
                recovery_res[i] += np.sum(seq_best[idx] == seq_native[idx])
                countRes[i] += len(seq_native[idx])
        with open(f'{root_dir}/{pdb_id}_seq_best.fasta', 'w') as mf:
            s = ''.join([idx2aa[x] for x in seq_native])
            mf.write(f'>0\n{s}\n')
            for j in range(len(seq_best_all)):
                s = ''.join([idx2aa[x] for x in seq_best_all[j]])
                mf.write(f'>{j + 1}\n')
                mf.write(f'{s}\n')
    df = pd.DataFrame({'pdb': pdb_id_all, 'seq_len': seq_len, 'recovery': recovery})
    df.to_csv(f'{root_dir}/recovery.csv', index=False)
    np.save(f'data/design/cullpdb_val_deep/{exp_flag}anneal_val_deep/mut_matrix_anneal.npy', mut_matrix_anneal)
    df = pd.DataFrame({'native_aa': native_aa_all, 'design_aa': design_aa_all})
    df.to_csv(f'{root_dir}/native_design_aa.csv', index=False)
    fig = pl.figure()
    pl.plot(df['seq_len'], df['recovery'], 'bo')
    pl.title('full seq redesign')
    pl.savefig(f'{root_dir}/full_seq_design_seqlen_recovery.pdf')
    fig = pl.figure()
    pl.hist(df['recovery'], bins=np.arange(10) * 0.05 + 0.05)
    pl.xlabel('native sequence recovery fraction')
    pl.ylabel('N')
    pl.savefig(f'{root_dir}/full_seq_design_recovery_hist.pdf')
    fig = pl.figure()
    pl.plot(np.arange(20), recovery_res / countRes)
    pl.xticks(np.arange(20), labels=aa)
    pl.title('residue recovery fraction in full seq redesign')
    pl.savefig(f'{root_dir}/full_seq_design_residue_recovery.pdf')
    fig = pl.figure()
    mut_matrix_anneal_freq = mut_matrix_anneal / mut_matrix_anneal.sum(axis=1)[:, None]
    pl.imshow(mut_matrix_anneal_freq, cmap='jet')
    pl.xlabel('mutated residue')
    pl.ylabel('native residue')
    pl.xticks(np.arange(20), labels=ordered_aa)
    pl.yticks(np.arange(20), labels=ordered_aa)
    pl.colorbar()
    pl.title('full seq redesign')
    pl.savefig(f'{root_dir}/full_seq_design_residue_use.pdf')
    fig = pl.figure()
    res_all = np.concatenate(seq_best_all).flatten()
    aa_bins = np.arange(21) - 0.5
    pl.hist(res_all, bins=aa_bins, histtype='step')
    pl.xticks(np.arange(20), labels=aa)
    pl.title('residue use frequency')
    pl.savefig(f'{root_dir}/full_seq_design_residue_use_frequency.pdf')
```


Overlapping Code:
```
esign/cullpdb_val_deep/{exp_flag}anneal_val_deep'
mut_matrix_anneal = np.zeros((20, 20))
native_aa_all = []
design_aa_all = []
seq_len = []
recovery = []
pdb_id_all = []
recovery_res = np.zeros(20)
co_selected:
seq_best_all = []
for j in range(num):
data_anneal = h5py.File(f'{root_dir}/{pdb_id}_profile_{j}.h5', 'r')
designed_seq = data_anneal['profile'][()]
seq_best = designed_seq[1]
seq_best_all.append(seq_best)
seq_native = designed_seq[0]
recovery_fraction = np.sum(seq_best == seq_native) / float(len(seq_native))
recovery.append(recovery_fraction)
seq_len.append(len(seq_native))
pdb_id_all.seq_native[i]], map_aa[seq_best[i]]] += 1
native_aa_all.append(map_aa[seq_native[i]])
design_aa_all.recovery_res[i] += np.sum(seq_best[idx] == seq_nath open(f'{root_dir}/{pdb_id}_seq_best.fasta', 'w') as mf:
s = ''.join([idx2aa[x] for x in seq_native])
mf.write(f'>0\n{s}\n')
for j in range(len(seq_best_all)):
s = ''.join([idx2aa[x] for x in seq_bes)
df = pd.DataFrame({'pdb': pdb_id_all, 'seq_len':p/{exp_flag}anneal_val_deep/mut_matrix_anneal.npy', mut_matrix_anneal)
df = pd.DataFrame({'native_aa': native_aa_all, 'design_aa': design_aa_all})
df.to_csv(f'{root_dir}/native_design_aa.csv', index=False)
fig = pl.figure()
pl.plot(df['seq_len'], df['recovery'], 'bo')
pl.title('full seq redesign')
pl.savefig(f'{root_dir}/full_seq_design_seqlen_recofraction')
pl.ylabel('N')
pl.savefig(f'{root_dir}/full_seq_design_recovery_hist.pdf')
fig = pl.figur
```
<Overlap Ratio: 0.7055961070559611>

---

--- 183 --
Question ID: 1d58be5f8c298cf630d37e7dc4f29b9760416dc5_1
Original Code:
```
def parse_net_xml(doc):
    total = len(list(doc.getiterator('wireless-network')))
    tenth = total / 10
    count = 0
    clients = list()
    parsedList = []
    for network in doc.getiterator('wireless-network'):
        count += 1
        try:
            if count % tenth == 0:
                continue
        except ZeroDivisionError:
            print('Division by zero error')
        type = network.attrib['type']
        channel = network.find('channel').text
        bssid = network.find('BSSID').text
        if type == 'probe' or channel == '0':
            continue
        encryption = network.getiterator('encryption')
        privacy = ''
        cipher = ''
        auth = ''
        if encryption is not None:
            for item in encryption:
                if item.text.startswith('WEP'):
                    privacy = 'WEP'
                    cipher = 'WEP'
                    auth = ''
                    break
                elif item.text.startswith('WPA'):
                    if item.text.endswith('PSK'):
                        auth = 'PSK'
                    elif item.text.endswith('AES-CCM'):
                        cipher = 'CCMP ' + cipher
                    elif item.text.endswith('TKIP'):
                        cipher += 'TKIP '
                elif item.text == 'None':
                    privacy = 'OPN'
        cipher = cipher.strip()
        if cipher.find('CCMP') > -1:
            privacy = 'WPA2'
        if cipher.find('TKIP') > -1:
            privacy += 'WPA'
        power = network.find('snr-info')
        dbm = ''
        if power is not None:
            dbm = power.find('max_signal_dbm').text
        if int(dbm) > 1:
            dbm = power.find('last_signal_dbm').text
        if int(dbm) > 1:
            dbm = power.find('min_signal_dbm').text
        ssid = network.find('SSID')
        essid_text = ''
        if ssid is not None:
            essid_text = network.find('SSID').find('essid').text
        gps = network.find('gps-info')
        (lat, lon) = ('', '')
        if gps is not None:
            lat = network.find('gps-info').find('min-lat').text
            lon = network.find('gps-info').find('min-lon').text
        data = dict(ESSID=essid_text, BSSID=bssid, Channel=channel, Privacy=privacy, Cipher=cipher, Authenticaiton=auth, DBM=dbm)
        if lat and lon is not None:
            google_map = 'https://maps.google.com/maps?q=' + lat + ',' + lon + '&ll=' + lat + ',' + lon + '&z=17'
            google_map_link = '<a href="' + google_map + '" target="_blank"> Google map link</a>'
            location = dict(Latitude=lat, Longitude=lon, Googlemap=google_map_link)
        else:
            not_found = 'Not coordinates available'
            location = dict(Latitude=not_found, Longitude=not_found)
        client_list = associatedClients(network, bssid, essid_text)
        if client_list is not None:
            data['client'] = client_list
        else:
            not_found = 'No clients found'
            data['client'] = not_found
        data['location'] = location
        parsedList.append(data)
    return parsedList
```


Overlapping Code:
```

except ZeroDivisionError:
print('Division by zero
channel = network.find('channel').text
bssid = network.find('Bcontinue
encryption = network.getiterator('encryption')
privacytion is not None:
for item in encryption:
if item.text.startswi'max_signal_dbm').text
if int(dbm) > 1:
dbm = power.find('last_signal_dbm').text
if int(dbm) > 1:
dbm = power.find('min_signal_dbm').text
ssid = networnd('SSID')
essid_text = ''
if ssid is not None:
essid_text = network.find('SSID').find('essid').
if gps is not None:
lat = network.find('gps-info').find('min-lat').text
lon = network.find('gpsssid_text, BSSID=bssid, Channel=channel, Privacy=piton=auth, DBM=dbm)
if lat and lon is not None:
go
```
<Overlap Ratio: 0.38164521544487967>

---

--- 184 --
Question ID: bc9332449ba47eee635aabdc3d23964f3b29f165_0
Original Code:
```
def get_ratings(path, users_file_name, books_file_name):
    dfUsers = pd.read_csv(path + users_file_name, encoding='UTF8')
    df_books = pd.read_csv(path + books_file_name, encoding='UTF8')
    df_users_books = pd.DataFrame(dfUsers, columns=['user_id', 'like'])
    sr_users = []
    sr_books = []
    sr_ratings = []
    str_like = list(np.array(df_users_books['like'].tolist()))
    list_like = []
    for i in str_like:
        i = i.lstrip('[').rstrip(']')
        i = i.split(', ')
        list_like.append(i)
    for user_idx in df_users_books['user_id']:
        for book_idx in list_like[user_idx]:
            if book_idx == '':
                break
            sr_users.append(user_idx)
            sr_books.append(book_idx)
            sr_ratings.append(1)
    for book_idx in range(len(df_books)):
        if sr_users[0]:
            sr_users.append(sr_users[0])
        if sr_books[0]:
            sr_books.append(book_idx)
        if sr_ratings[0]:
            sr_ratings.append(0)
    R = pd.DataFrame({'user_idx': sr_users, 'book_idx': sr_books, 'ratings': sr_ratings})
    R = R.pivot_table('ratings', index='user_idx', columns='book_idx').fillna(0)
    R.rename(columns=lambda x: int(x), inplace=True)
    R = R.sort_index(axis=1)
    return R
```


Overlapping Code:
```
sers = pd.read_csv(path + users_file_name, encoding='UTF8')
df_books = pd.read_csv(path + books_file_name, encoding='UTF8')
df_users_books = pd.DataFr', 'like'])
sr_users = []
sr_books = []
sr_ratings = []
str_like = list(np.array(df_users_books['like'].tolist()))
list_like = []
for i in str_like:
i = i.lstrip('[').rstrip(']')
i = i.split(', ')
list_like.append(i)
for user_idx in df_users_books['user_id']:
for book_idx in list_like[user_idx]:
if book_idx == '':
break
sr_users.append(user_idx)
sr_books.append(book_idx)
sr_ratings.append(1)
for book_idx in range(len(df_books)):
if sr_users[0]:
sr_users.append(sr_users[0])
if sr_books[0]:
sr_books.append(book_idx)
if sr_ratings[0]:
sr_ratings.append(0)
R = pd.Datings', index='user_idx', columns='book_idx').fillna(0)
R.r
```
<Overlap Ratio: 0.7442528735632183>

---

--- 185 --
Question ID: 876c7c08adc0ef2ebe9987da8f1125f3cf04b813_0
Original Code:
```
def word_bag_list(org_text):
    """Take text and do sum, return sumed sentence list."""
    nlp = spacy.load('en_core_web_sm')
    tr = pytextrank.TextRank(logger=None)
    nlp.add_pipe(tr.PipelineComponent, name='textrank', last=True)
    doc = nlp(org_text)
    wholeSent = ''
    for sent in doc._.textrank.summary(limit_phrases=15, limit_sentences=5):
        wholeSent = wholeSent + repr(sent).rstrip() + ' '
    return [wholeSent]
```


Overlapping Code:
```

"""Take text and do sum, return sumed sentence li
nlp = spacy.load('en_core_web_sm')
tr = pytextrank.TextRank(logger=None)
nlp.add_pipe(tr.PipelineComponent, name='textrank', last=True)n doc._.textrank.summary(limit_phrases=15, limit_sentences=
```
<Overlap Ratio: 0.6171284634760705>

---

--- 186 --
Question ID: 6e58f05000ac2f4b1655ab9325ef2cbb23caea8b_2
Original Code:
```
def remapchunk(seg, chunk, chunkindex, scratchpath, layer=1, bits_per_dim=10, maxmip=11, correctvers=True):
    (x, y, z) = chunkindex
    pcgchunkid = io.pcg.get_chunk_id(layer=layer, x=x, y=y, z=z, bits_per_dim=bits_per_dim)
    data = seg[chunk.index()]
    try:
        if correctvers:
            mappings = readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)
        else:
            mappings = _readremapfiles(scratchpath, chunkindex, pcgchunkid, maxmip=maxmip)
    except subprocess.CalledProcessError as e:
        if data.max() == 0:
            return data
        else:
            raise e
    for mapping in mappings:
        data = fastremap.remap(data, mapping, in_place=False, preserve_missing_labels=True)
    seg[chunk.index()] = data
    return seg
```


Overlapping Code:
```
ndex()]
try:
if correctvers:
mappings = readremapfiles(scratchpath, chunkindex, pcgchunkid, maxaxmip)
else:
mappings = _readremapfiles(scratchpath, chunkindex, pcgchunkid, maxubprocess.CalledProcessError as e:
if data.max() == 0:
return data
else:
raise e
for mapping in mappings:
data = fastremap.remap(data, mapping, in_pla
```
<Overlap Ratio: 0.49019607843137253>

---

--- 187 --
Question ID: 639b37fb1f2788f702b824b85cd19c165e09f9f6_0
Original Code:
```
def test_cached_property():
    """Test the cached_property decorator"""
    newValue = '99999'

    class DummyClass:

        def __init__(self):
            self.value = '11111'

        def change_value_in_instance(self, value):
            self.value = value

        @cached_property
        def test_property(self):
            return self.value

        @property
        def test_uncached_property(self):
            return self.value
    testClass = DummyClass()
    first_cached_test_property = testClass.test_property
    first_uncached_test_property = testClass.test_uncached_property
    testClass.change_value_in_instance(newValue)
    second_cached_test_property = testClass.test_property
    second_uncached_test_property = testClass.test_uncached_property
    assert first_cached_test_property == second_cached_test_property
    assert first_cached_test_property == '11111'
    assert first_uncached_test_property != second_uncached_test_property
    assert first_uncached_test_property == '11111'
    assert second_uncached_test_property == '99999'
```


Overlapping Code:
```
 test_cached_property():
"""Test the cached_property decorator"""
nelass DummyClass:
def __init__(self):
self.value = hange_value_in_instance(self, value):
self.value = value
@cached_property
def test_property(self):
return self.value
@property
def test_uncached_property(self):
return self.value
testClass = DummyClass()
first_cached_test_property = testClass.test_property
first_uncached_test_property = testClass.test_uncached_property
testClass.change_value_in_insecond_cached_test_property = testClass.test_property
second_uncached_test_property = testClass.test_uncached_property
assert first_cached_test_property == second_cached_test_property
assert first_cached_test_property ==rt first_uncached_test_property != second_uncached_test_property
assert first_uncached_test_property
```
<Overlap Ratio: 0.8648351648351649>

---

--- 188 --
Question ID: b93ceb63b6b34d7c97ec44530d47645b54199e3e_18
Original Code:
```
def ndcg_at_ks(r, k_list, method=1, include_dcg=False):
    """

    :param r: 匹配array 长度为每个预测结果的匹配结果
    :param k_list:
    :param method:
    :param include_dcg:
    :return:
    """
    if r.shape[0] == 0:
        ndcgArray = [0.0] * len(k_list)
        dcg_array = [0.0] * len(k_list)
    else:
        dcg_array = dcg_at_ks(r, k_list, method)
        ideal_r = np.array(sorted(r, reverse=True))
        dcg_max_array = dcg_at_ks(ideal_r, k_list, method)
        ndcgArray = dcg_array / dcg_max_array
        ndcgArray = np.nan_to_num(ndcgArray)
    if include_dcg:
        return (ndcgArray, dcg_array)
    else:
        return ndcgArray
```


Overlapping Code:
```
cg_at_ks(r, k_list, method=1, include_dcg=False):
am k_list:
:param method:
:param include_dcg:
:ret= [0.0] * len(k_list)
dcg_array = [0.0] * len(k_list)
else:
dcg_array = dcg_at_ks(r, k_list, method)
ideal_r = np.array(sorted(r, reverse=True))
dcg_max_array = dcg_at_ks(idea
```
<Overlap Ratio: 0.5238095238095238>

---

--- 189 --
Question ID: 7d0de049fa37b3a2b53aa13e4a8de6bd43d360ad_0
Original Code:
```
def update_progress(value):
    global PROGRESS
    PROGRESS['value'] = value
    return PROGRESS['value']
```


Overlapping Code:
```
bal PROGRESS
PROGRESS['value'] = value
return PROG
```
<Overlap Ratio: 0.5319148936170213>

---

--- 190 --
Question ID: 6494d7e235268c91bde539243623f44dd265dd50_1
Original Code:
```
def create_fake_server(messages=[]):
    allMessages = _standard_join_messages() + messages

    async def _fake_server(websocket, _path):
        _join_message = await websocket.recv()
        for message in allMessages:
            await websocket.send(json.dumps(message))
    return _fake_server
```


Overlapping Code:
```
s = _standard_join_messages() + messages
async def _fake_server(websocket, _path):
_join_message = a
await websocket.send(json.dumps(message))
return 
```
<Overlap Ratio: 0.5813953488372093>

---

--- 191 --
Question ID: be45de239f2a958420b5ae5de4b313cf3431599f_0
Original Code:
```
def get_playlist_tracks(args):
    playlists = []
    current_user_id = args.get('current_user_id')
    limit = args.get('limit')
    offset = args.get('offset')
    db = get_db_read_replica()
    with db.scoped_session() as session:
        try:
            playlist_id = args.get('playlist_id')
            playlist = session.query(Playlist).filter(Playlist.is_current == True, Playlist.playlist_id == playlist_id).first()
            if playlist is None:
                return None
            playlist_track_ids = [trackId['track'] for trackId in playlist.playlist_contents['track_ids']]
            if limit and offset:
                playlist_track_ids = playlist_track_ids[offset:offset + limit]
            playlist_tracks = session.query(Track).filter(Track.is_current == True, Track.track_id.in_(playlist_track_ids)).all()
            tracks = helpers.query_result_to_list(playlist_tracks)
            tracks = populate_track_metadata(session, playlist_track_ids, tracks, current_user_id)
            if args.get('with_users', False):
                add_users_to_tracks(session, tracks)
            tracks_dict = {track['track_id']: track for track in tracks}
            playlist_tracks = []
            for trackId in playlist_track_ids:
                playlist_tracks.append(tracks_dict[trackId])
            return playlist_tracks
        except sqlalchemy.orm.exc.NoResultFound:
            pass
    return playlists
```


Overlapping Code:
```
ef get_playlist_tracks(args):
playlists = []
curreid')
limit = args.get('limit')
offset = args.get('offse)
db = get_db_read_replica()
with db.scoped_session() as session:
laylist.playlist_id == playlist_id).first()
if plaids']]
if limit and offset:
playlist_track_ids = pist(playlist_tracks)
tracks = populate_track_metadrs_to_tracks(session, tracks)
tracks_dict = {track['track_id']: track for track in tracks}
playlist_ playlist_tracks
except sqlalchemy.orm.exc.NoResultFound:
pass
return playlist
```
<Overlap Ratio: 0.43054357204486626>

---

--- 192 --
Question ID: e739faa956bee4ffde5b12e2607b0430bc975de6_0
Original Code:
```
@pytest.fixture
def archive_repositories(archive_repositories_raw: bytes) -> ArchiveRepositories:
    """Provides an ArchiveRepositories instance for the sample archive manifest."""
    return ArchiveRepositories(archive_repositories_raw)
```


Overlapping Code:
```
xture
def archive_repositories(archive_repositories_raw: bytes) -> ArchiveRepositories:
"""Provides an ArchiveRepositories instance for the sample arc
```
<Overlap Ratio: 0.6521739130434783>

---

--- 193 --
Question ID: f2e5aa3454e20bde6dfc287c3f2e7fede42c0287_2892
Original Code:
```
@overload
def assert_equal(actual: scipy.special.orthogonal.orthopoly1d, desired: numpy.poly1d):
    """
    usage.scipy: 2
    """
    ...
```


Overlapping Code:
```
ef assert_equal(actual: scipy.special.orthogonal.orthopoly1d, desired: numpy.poly1d):
"""
usage.scip
```
<Overlap Ratio: 0.8130081300813008>

---

--- 194 --
Question ID: bcc284a877dbebcbe1f579fbdd8c29590594f15e_7
Original Code:
```
@unittest.skipIf(sys.platform == 'win32', 'Fail to create temp dir.')
@pytest.mark.parametrize('client_mode', [True, False])
def test_two_node(two_node_cluster, working_dir, client_mode):
    (cluster, _) = two_node_cluster
    (address, env, PKG_DIR) = start_client_server(cluster, client_mode)
    runtimeEnv = f'{{  "working_dir": "{working_dir}" }}'
    execute_statement = 'print(sum(ray.get([run_test.remote()] * 1000)))'
    script = driver_script.format(**locals())
    out = run_string_as_driver(script, env)
    assert out.strip().split()[-1] == '1000'
    assert len(list(Path(PKG_DIR).iterdir())) == 1
```


Overlapping Code:
```
e, False])
def test_two_node(two_node_cluster, working_diter
(address, env, PKG_DIR) = start_client_server(cluster, client_mode)

script = driver_script.format(**locals())
out = run_string_as_driver(script, env)
assert out.strip().split()[-1] == 
```
<Overlap Ratio: 0.4241379310344828>

---

--- 195 --
Question ID: a318f13cb13b18c46060393025e55c03c4986095_2
Original Code:
```
@MSC.route('/candidates')
def candidates():
    text = request.args.get('text', default='', type=str)
    limit = request.args.get('limit', default=5, type=int)
    htmlflag = request.args.get('html', default=0, type=int)
    rval = {}
    rval['input'] = text
    running_offset = 0
    if text == '':
        return 'No text received. Usage: url/candidates?html=0&limit=2&text=texttomedicalspellcheck'
    resp_jso_nstring = corrector.GetALLCandidatesScoredJSON(text)
    print(resp_jso_nstring)
    rval = json.loads(resp_jso_nstring)
    for result in rval['results']:
        result['candidates'] = result['candidates'][:limit]
    if 'results' not in rval.keys() or len(rval['results']) == 0:
        rval['results'] = 'CORRECT'
    if bool(htmlflag):
        return json2html.convert(json.dumps(rval)) + '<br><br><br>Try me out: <br><br>' + formcode
    else:
        return json.dumps(rval, indent=2)
```


Overlapping Code:
```
pe=str)
limit = request.args.get('limit', default=ived. Usage: url/candidates?html=0&limit=2&text=te in rval['results']:
result['candidates'] = result['candidates'][:limit]
if 'results' not in rval.ke
```
<Overlap Ratio: 0.24630541871921183>

---

--- 196 --
Question ID: c908d4e2fcbe9433c55ec3ffa39b22b2f66872dd_0
Original Code:
```
def calc_data_maxima(data, order):
    """Calculate the local maxima using an exclusion of order to avoid multiple close maxima.

    :param data: 3D numpy array (axis 0: time)
    :param order: number of points to consider for maxima
    :return: 3D numpy bool array with same shape as data, True if maximum
    """
    argrelmax = signal.argrelmax(data, order=order, mode='wrap')
    dmean = data.mean(axis=0)
    dataMaxima = np.zeros(data.shape, dtype=bool)
    for (i, j, k) in zip(*argrelmax):
        if data[i, j, k] > dmean[j, k]:
            dataMaxima[i, j, k] = True
    return dataMaxima
```


Overlapping Code:
```
er):
"""Calculate the local maxima using an exclusion of order to avoid multiple close maxima.
:param data: 3D numpy array (axis 0: time)
:param order: number of points to consider for maxima
:return: 3D numpy bool array with same shape as data, True if maximum
"""
argrelmax = signal.argrelmax(data, order=order, mode='wrap')
dmean = data.mean(axis=
```
<Overlap Ratio: 0.6493506493506493>

---

--- 197 --
Question ID: 6fb0abbb3b81f5bf6e666d791414fa75ce85b499_6
Original Code:
```
def _read_checkpoint_file(checkpoint_file: Optional[str]) -> Tuple[Set[str], Set[str]]:
    (colls, users) = (set(), set())
    if checkpoint_file:
        with open(checkpoint_file) as fd:
            for line in fd.readlines():
                if line.startswith('CHECKPOINT'):
                    (_, type_, oid) = line.split()
                    if type_ == 'collection':
                        colls.add(oid)
                    elif type_ == 'user':
                        users.add(oid)
    return (colls, users)
```


Overlapping Code:
```
ckpoint_file(checkpoint_file: Optional[str]) -> Tu_file) as fd:
for line in fd.readlines():
if line.startswith type_ == 'collection':
colls.add(oid)
elif type_ 
```
<Overlap Ratio: 0.4371584699453552>

---

--- 198 --
Question ID: 567e27ecd176008a4a9c4c66d72d8200e72ba772_0
Original Code:
```
@pytest.fixture(scope='session', autouse=True)
def cleanup(request):

    def remove_test_dir():
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.scistree.CFMatrix'))
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.scistree.log'))
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.scite.CFMatrix'))
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.scite.log'))
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.huntress.CFMatrix'))
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.huntress.log'))
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.CFMatrix'))
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.log'))
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.booster.CFMatrix'))
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.booster.log'))
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/consensus.CFMatrix'))
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.info2'))
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.newick'))
        tsc.ul.remove(tsc.ul.get_file('trisicell.datasets/test/test.phiscsb.png'))
        tsc.ul.cleanup(tsc.ul.get_file('trisicell.datasets/test/_map'))
        tsc.ul.cleanup(tsc.ul.get_file('trisicell.datasets/test/_tmp'))
        tsc.ul.cleanup(tsc.ul.get_file('trisicell.datasets/test/test'))
    request.addfinalizer(remove_test_dir)
```


Overlapping Code:
```
@pytest.fixture(scope='session', autouse=True)
def cleanup(request):
def remove_test_di
```
<Overlap Ratio: 0.06200997861724875>

---

--- 199 --
Question ID: 454c918ee83d8f3c85828d2e941785840208d81e_5
Original Code:
```
def text_error(code: int, error: Exception, url: str, usage: str='') -> Response:
    """Format error message as plain text

    Returns
    -------
    error message formatted as plain text.
    """
    return PlainTextResponse(content=f'Error {code}: {ERROR_CODE_MESSAGES[code]}\n\n{error}\n\nUsage details are available from {usage}\n\nRequest:\n{url}\n\nRequest Submitted:\n{UTCDateTime().isoformat()}Z\n\nService Version:\n{VERSION}\n', status_code=code)
```


Overlapping Code:
```
text_error(code: int, error: Exception, url: str, age as plain text
Returns
-------
error message formatted as plain text.
"""
return PlainTextRespons
```
<Overlap Ratio: 0.3456221198156682>

---

--- 200 --
Question ID: 8c985af6b5bde8b51d64a34a81f930b1cbbde109_18
Original Code:
```
def decode_UHFRFModeTable(data):
    logger.debug(func())
    par = {}
    if len(data) == 0:
        return (None, data)
    header = data[0:par_header_len]
    (msgtype, length) = struct.unpack(par_header, header)
    msgtype = msgtype & BITMASK(10)
    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))
    if msgtype != Message_struct['UHFRFModeTable']['type']:
        return (None, data)
    body = data[par_header_len:length]
    logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))
    i = 0
    (ret, body) = decode('UHFC1G2RFModeTableEntry')(body)
    while ret:
        par['UHFC1G2RFModeTableEntry' + str(i)] = ret
        (ret, body) = decode('UHFC1G2RFModeTableEntry')(body)
        i += 1
    return (par, data[length:])
```


Overlapping Code:
```
ata):
logger.debug(func())
par = {}
if len(data) == 0:
retur = struct.unpack(par_header, header)
msgtype = msgtype & BITMASK(10)
logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length))
if msgtype != Message_struct['UHFRFModeTable']['type']:
return (None, data)
body = data[par_header_leth]
logger.debug('%s (type=%d len=%d)' % (func(), msgtype, length)body)
while ret:
par['UHFC1G2RFModeTableEntry' + s
```
<Overlap Ratio: 0.6174698795180723>

---

--- 201 --
Question ID: b0b49ffed87028f7676ecd3a3526e65ea082c9a2_10
Original Code:
```
def obtain_pcaplot(model):
    for (idx, layer) in enumerate(model.layers):
        if layer.__class__.__name__ == 'Dense':
            allWeights = layer.get_weights()
            weights = allWeights[0]
            pca = applyPCA(weights, np.array(weights).shape[1], drawPlot=True, isReshape=False)
            break
```


Overlapping Code:
```
numerate(model.layers):
if layer.__class__.__name__ == 
```
<Overlap Ratio: 0.2131782945736434>

---

--- 202 --
Question ID: af3e93794d127b40b4269b409917fdaa6143f215_0
Original Code:
```
def parse_function_args(query_param_definition, is_strict=False):

    def inner_get_fu(fu):
        return FuncArgParser(query_param_definition, is_strict=is_strict)(fu)
    return inner_get_fu
```


Overlapping Code:
```
nction_args(query_param_definition, is_strict=False):
def inner_get_fu(fu):
return FuncArgParser(query_param_definition, is_strict=is_strict)(fu)
return inner_ge
```
<Overlap Ratio: 0.9096045197740112>

---

--- 203 --
Question ID: 80c466f827f74902bd68bfb5f88abcaf94f6d86e_6
Original Code:
```
def test_handle_xevent_atom_ok(monkeypatch):
    """Return false when event type is invalid"""
    event = MagicMock(spec=Xlib.protocol.event.PropertyNotify)
    event.type = xwindow.Xlib.X.PropertyNotify
    event.atom = xwindow.NET_ACTIVE_WINDOW
    monkeypatch.setattr(xwindow, 'ROOT', MagicMock())
    monkeypatch.setattr(xwindow, 'DISP', MagicMock())
    result = xwindow.handle_xevent(event, callback=lambda *args, **kwargs: 'callback')
    assert result is True
```


Overlapping Code:
```
dle_xevent_atom_ok(monkeypatch):
"""Return false when event type is invalid"""
event = MagicMock(spec=Xlib.protocol.event.PropertyNotify)
event.type = xwindow.Xlib.X.PropertyNotify
event.atom = xwindow.NET_ACTIVE_WINDOW
monkeypatch.setattr(xwindow, 'ROOT', MagicMock())
monkeypatch.setattr(xwindow, 'DISP', MagicMock())
reda *args, **kwargs: 'callback')
assert result is T
```
<Overlap Ratio: 0.8532110091743119>

---

--- 204 --
Question ID: a6247751a993a8d45edcb88a38537df9fdda2f2e_4
Original Code:
```
def decode_vector_type(contract_address, abi):
    wasm_contract_obj = platon.wasmcontract(address=contract_address, abi=abi, vmtype=1)
    tx_hash = wasm_contract_obj.functions.clearElement().transact({'from': from_address, 'gas': gas})
    txReceipt = platon.waitForTransactionReceipt(tx_hash)
    topic_param = wasm_contract_obj.events.clear().processReceipt(txReceipt)
    print(topic_param)
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 205 --
Question ID: 3931e032c422dda461181a2d4fc71a72aab1d761_0
Original Code:
```
def main():
    """Main function."""
    try:
        tickers = os.listdir('data')
        tickers = (os.path.basename(t) for t in tickers if t.endswith('.csv.gz'))
        tickers = [t.split('.')[0] for t in tickers]
        epilog = '\nValid values for ticker are: %s' % tickers
        epilog += '\n\nSample usage: ./predict.py IBM 2010-01-01 2011-01-01 21'
    except OSError:
        tickers = []
        epilog = ''
    parser = argparse.ArgumentParser(description='Predicts stock prices.', epilog=epilog, add_help=True)
    parser.add_argument('ticker', metavar='TICKER', help='The stock item to predict')
    parser.add_argument('start_date', metavar='START_DATE', help='The initial date to start looking into history.')
    parser.add_argument('end_date', metavar='END_DATE', help='The final date to stop looking into history.')
    parser.add_argument('shift', metavar='SHIFT', type=int, help='How many days in advance to predict.')
    options = parser.parse_args()
    if not tickers:
        print('"No tickers available. Unable to predict.')
        raise SystemExit
    ticker = options.ticker
    if ticker not in tickers:
        print('"ticker" must be one of %s' % tickers)
        raise SystemExit
    try:
        startDate = pd.to_datetime(options.start_date)
    except ValueError:
        print('"start_date" must be a valid date. Not %s' % startDate)
        raise SystemExit
    try:
        end_date = pd.to_datetime(options.end_date)
    except ValueError:
        print('"end_date" must be a valid date. Not %s' % end_date)
        raise SystemExit
    shift = options.shift
    if shift <= 0:
        print('"shift" must be a positive integer')
        raise SystemExit
    print('Loading data...')
    (X, y, tX, _, scaler) = models.get_processed_dataset(ticker, 0.9999999999, shift, 0, False, startDate, end_date)
    print('Training model...')
    (_, _, model) = models.cross_validate_model('huber', X, y)
    print('Predicting...')
    yhat = model.predict(tX)
    prediction = scaler.inverse_transform(np.array([[yhat[0]] + [0] * (X.shape[1] - 1)]))
    print('Predicted value:', prediction[0, 0])
```


Overlapping Code:
```
.listdir('data')
tickers = (os.path.basename(t) for t in tickers if t.endswith('.csv.gz'))
tickers = [t.split('.')[0] for t in tickers]
epilog = '\nValid values for ticker are: %s' % tickers
epilog += '\n\nSample usage: ./predict.py IBM 2010-01-01 2011-01-01 21'
except OSError:
tickers = []
epilog = ''
parser = argparse.ArgumentParser(description='Predictsepilog=epilog, add_help=True)
parser.add_argument('ticker', metavar='TICKERhe initial date to start looking into history.')
parser.add_argument('end_date', metavar='END_DATE',.')
parser.add_argument('shift', metavar='SHIFT', t.')
options = parser.parse_args()
if not tickers:
print('"No tickers available. Unable to predict.')
raise SystemExit
ticker = options.ticker
if ticker not in tickers:
print('"ticker" must be one of pd.to_datetime(options.start_date)
except ValueError:
print('"start_date" must be a valid date. Not  pd.to_datetime(options.end_date)
except ValueError:
print('"end_date" must be a valid date. Not %s' % end_date)
raise SystemExit
shift = options.shift
if shift <= 0:
print('"shift" must be a positive integer')
raise SystemExit
print('Loading data...els.get_processed_dataset(ticker, 0.9999999999, sh
print('Predicting...')
yhat = model.predict(tX)
p
```
<Overlap Ratio: 0.6568993074054342>

---

--- 206 --
Question ID: 73ef8d1f69375bfcaedacdc382f9d2e3fbedc2b8_1
Original Code:
```
def sig_gen_multi(public_as, private_as, public_ams, private_ams, body, amsh, arsh, fold=False, verbose=False, as_tmp=None, ams_tmp=None):
    hasher = HASH_ALGORITHMS[b'rsa-sha256']
    h = hasher()
    h.update(body)
    bh = base64.b64encode(h.digest())
    print('ams bh= ')
    print(bh)
    hasher = HASH_ALGORITHMS[b'rsa-sha256']
    h = hasher()
    h = HashThrough(hasher())
    h.update(b'\r\n'.join([x + b':' + y for (x, y) in amsh(bh)]))
    if verbose:
        print('\nsign ams hashed: %r' % h.hashed())
    pk = parse_pem_private_key(private_ams)
    sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)
    msb = base64.b64encode(bytes(sig2))
    if fold:
        msb = msb[:70] + b' ' + msb[70:142] + b' ' + msb[142:214]
    print('ams b= ')
    print(msb)
    pkAms = parse_public_key(base64.b64decode(public_ams))
    signature = base64.b64decode(msb)
    ams_valid = RSASSA_PKCS1_v1_5_verify(h, signature, pkAms)
    print('ams sig valid: %r' % ams_valid)
    hasher = HASH_ALGORITHMS[b'rsa-sha256']
    h = hasher()
    h = HashThrough(hasher())
    h.update(b'\r\n'.join([x + b':' + y for (x, y) in arsh(msb, bh)]))
    if verbose:
        print('\nsign ars hashed: %r' % h.hashed())
    pk = parse_pem_private_key(private_as)
    sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)
    sb = base64.b64encode(bytes(sig2))
    print('arsh b=')
    print(sb)
    pk_as = parse_public_key(base64.b64decode(public_as))
    signature = base64.b64decode(sb)
    ams_valid = RSASSA_PKCS1_v1_5_verify(h, signature, pk_as)
    print('arsh sig valid: %r' % ams_valid)
    spc = fold and b'' or b'  '
    accum = ''
    if as_tmp:
        sb = sb[:70] + b'\n    ' + spc + sb[70:142] + b'\n    ' + spc + sb[142:214]
        res = as_tmp.replace(b'%b', sb)
        accum = res
        print(res.decode('utf-8'))
    if ams_tmp:
        msb = msb.replace(b' ', b'')
        msb = msb[:70] + b'\n    ' + spc + msb[70:142] + b'\n    ' + spc + msb[142:214]
        res = ams_tmp.replace(b'%bh', bh)
        res = res.replace(b'%b', msb)
        accum += b'\n' + res
        print(res.decode('utf-8'))
    os.system(b'echo "' + accum + b'" | pbcopy')
```


Overlapping Code:
```
s, private_as, public_ams, private_ams, body, amsh, arsh, foldasher = HASH_ALGORITHMS[b'rsa-sha256']
h = hasher()
h.update(body)
bh = base64.b64encode(h.digest())asher = HASH_ALGORITHMS[b'rsa-sha256']
h = hasher()
h = HashThroed())
pk = parse_pem_private_key(private_ams)
sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)
msb = base64.b64encode(bytes(sig2))
if fold:
mublic_ams))
signature = base64.b64decode(msb)
ams_lid)
hasher = HASH_ALGORITHMS[b'rsa-sha256']
h = hasher()
h = HashThroparse_pem_private_key(private_as)
sig2 = RSASSA_PKCS1_v1_5_sign(h, pk)
sb = base64.b64encode(bytes(slic_key(base64.b64decode(public_as))
signature = base64.b64decode(sb)
ams_valid = RSASSA_PKCS1_v1_5_verify(h, signature, pk_place(b'%b', sb)
accum = res
print(res.decode('utf-8'))
if ams_tmp:
msb = msb.replace(b' ', b'')
msb = s
print(res.decode('utf-8'))
os.system(b'echo "' + ac
```
<Overlap Ratio: 0.46316359696641385>

---

--- 207 --
Question ID: 8e27225db54d8f1ce0cedbcc4f4b9dfe2b6fdaf9_2
Original Code:
```
def draw_iterations(g, eval_map_function, x0, n):

    def draw_mid_point_arrows(x, xNext, both=True):
        if xNext > x:
            arrow_direction_angles = (0.5 * math.pi, 0)
        else:
            arrow_direction_angles = (-0.5 * math.pi, math.pi)
        g.draw_arrow_tip((x, mid_value), arrow_direction_angles[0])
        if both:
            g.draw_arrow_tip((mid_value, xNext), arrow_direction_angles[1])
    xs = [x0]
    for i in range(n):
        xs.append(eval_map_function(xs[-1]))
    g.set_dash_dash_structure(12, 4, units='svg')
    g.set_dash_mode('dash')
    g.set_svg_options(stroke_width=iterations_stroke_w, units='svg')
    g.set_arrow_options(width=iteration_arrow_rel_size * arrow_size, curvature=0, units='svg')
    g.set_point_size(0.01)
    g.draw_line_segment((x0, 0), (x0, x0))
    for (i, x) in enumerate(xs[:-2]):
        xNext = xs[i + 1]
        g.draw_polyline([(x, x), (x, xNext), (xNext, xNext)])
        mid_value = 0.5 * (x + xNext)
        draw_mid_point_arrows(x, xNext)
    g.draw_polyline([(xs[-2], xs[-2]), (xs[-2], xs[-1])])
    g.draw_point((xs[-2], xs[-1]))
    draw_mid_point_arrows(xs[-2], xs[-1], both=False)
    g.reset_dash_and_dot_structures()
```


Overlapping Code:
```
_map_function(xs[-1]))
g.set_dash_dash_structure(1sh')
g.set_svg_options(stroke_width=iterations_stroke_w, units')
g.set_point_size(0.01)
g.draw_line_segment((x0,int((xs[-2], xs[-1]))
draw_mid_point_arrows(xs[-2], xs[-1], both=False)
g.reset_dash_and_dot_structu
```
<Overlap Ratio: 0.2528957528957529>

---

--- 208 --
Question ID: 47fe8ba25f624d3f52e3accc1fc3872135959f05_3
Original Code:
```
def main(args):
    """
    The starting point of the program.
    """
    while True:
        num_items = 1
        read_data = ReadData() if len(args) == 1 else ReadData(args)
        dataLogDf = get_file_df(read_data.get_data_log())
        exe_table_df = get_file_df(read_data.get_exe_table())
        doses_delta_df = get_file_df(read_data.get_doses_delta())
        summary = get_summary(read_data.get_summary())
        dfs = [('data_log', dataLogDf[-num_items:]), ('exe_table', exe_table_df[-num_items:]), ('doses_delta', doses_delta_df[-num_items:])]
        data_json = get_json(dfs, summary, read_data.json_name)
        read_data.json = data_json
        time.sleep(5)
```


Overlapping Code:
```
g point of the program.
"""
while True:
num_items = ReadData() if len(args) == 1 else ReadData(args)))
exe_table_df = get_file_df(read_data.get_exe_table())
doses_delta_df = get_file_df(read_data.get_doses_delta())
summary = get_summary(read_data.geton = get_json(dfs, summary, read_data.json_name)
r
```
<Overlap Ratio: 0.5136986301369864>

---

--- 209 --
Question ID: 7848c02f06f57265c259b7cf28bbf7fbc43f4a4a_17
Original Code:
```
def fecha_caixa():
    global aberto
    tot = 0
    for elemento in transacoes_finalizadas:
        tot += elemento[1]
    print(f'TOTAL DE VENDAS R${tot:.2f}')
    print()
    while len(transacoes_finalizadas) != 0:
        print('ELIMINE AS TRANSAÇÕES FINALIZADAS:')
        for (i, elemento) in enumerate(transacoes_finalizadas):
            print(f'{i:<1}', end='|    ')
            print(f'{elemento[0]:<17}', end='|')
            print(f'{elemento[1]:>5.2f}')
        try:
            aux = int(input(''))
            tot -= transacoes_finalizadas[aux][1]
            tot = round(tot, 2)
            transacoes_finalizadas.pop(aux)
        except ValueError:
            print('[ERRO]: Digite valores válidos')
            return fecha_caixa()
        except IndexError:
            print(f' Indice <= {len(transacoes_finalizadas)}')
    print(f'TRANSAÇÕES ELIMINADAS TOTAL: R${tot}')
    print('CAIXA FECHADO COM SUCESSO!')
    aberto = False
```


Overlapping Code:
```
l aberto
tot = 0
for elemento in transacoes_finalinalizadas[aux][1]
tot = round(tot, 2)
transacoes_f
```
<Overlap Ratio: 0.13458950201884254>

---

--- 210 --
Question ID: c370b87e8143a97ff5064d02515dc7a0a2cf09a6_0
Original Code:
```
def patch():
    global _patched
    if not _patched:
        conf.Settings = Settings
        conf.LazySettings = LazySettings
        conf.settings = settings
        _patched = True
```


Overlapping Code:
```
ch():
global _patched
if not _patched:
conf.Settings = Settings
conf.LazySettings = LazySettings
con
```
<Overlap Ratio: 0.6944444444444444>

---

--- 211 --
Question ID: a9d142291ba38842e31d3177869d6447f084d025_0
Original Code:
```
def time_model(model: nn.Module, test_set: Type[LightFieldDataset], device) -> np.ndarray:
    model.eval()
    custom = CustomProgressBar('N/A')
    loader = torch.utils.data.DataLoader(dataset=test_set, batch_size=1, sampler=SequentialSampler(test_set), num_workers=1, pin_memory=True)
    test_set.set_only_x_dataset()
    model.eval()
    torch.set_grad_enabled(False)
    print('Timing')
    all_times = []
    for input_data in custom.bar(loader):
        tick = time.time()
        input_var = input_data.to(device).float().div_(255.0)
        _ = model(input_var)
        tock = time.time()
        timeTaken = tock - tick
        all_times.append(timeTaken)
    test_set.revert_only_x_dataset()
    return np.array(all_times)
```


Overlapping Code:
```
ay:
model.eval()
custom = CustomProgressBar('N/A')loader = torch.utils.data.DataLoader(dataset=test_set, batch_size=1set_only_x_dataset()
model.eval()
torch.set_grad_enabled(False)
print('Timing')
all_times = []
for input_data in custom.bar(loader):
tick = time.time()
input_var = input_data.to(device).float().div_(255.0)
_ = model(input_var)
tock = time.time()
timetest_set.revert_only_x_dataset()
return np.array(a
```
<Overlap Ratio: 0.6495327102803738>

---

--- 212 --
Question ID: e8bc0e0cfb812d7c32521e012f61a1e17efddd71_1
Original Code:
```
def save_mel_dataset(out_path, *paths, in_db=True, root_path=None):
    """
    """
    ds_len = len(paths)
    with IncrementalHDF5(out_path, CONF.NUM_MELS, np.float32) as ihdf5:
        LOGGER.info(f'Writing to {out_path}')
        for (i, abspath) in enumerate(paths, 1):
            if root_path is not None:
                metadata_str = str(abspath.relative_to(root_path))
            else:
                metadata_str = str(abspath)
            if i % 100 == 0:
                LOGGER.info(f'[{i}/{ds_len}] save_mel_dataset: {metadata_str}')
            arr = wavpath_to_mel(str(abspath), CONF.WAV_SR, wav_norm=CONF.WAV_NORM, n_mels=CONF.NUM_MELS, hop_length=CONF.STFT_HOPSIZE, pad_mode='constant', in_decibels=in_db, logger=LOGGER)
            if arr is None:
                continue
            ihdf5.append(arr, metadata_str)
            (_, arrW) = arr.shape
            assert (arr == ihdf5.data_ds[:, -arrW:]).all(), 'Should never happen'
        LOGGER.info(f'Finished writing to {out_path}')
```


Overlapping Code:
```
ve_mel_dataset(out_path, *paths, in_db=True, root_path=None):
"""
"""
ds_len = len(paths)
with IncrementalHDF5(out_path, CONF.NUM_MELS, np.float32) as not None:
metadata_str = str(abspath.relative_to(root_path))
else:
metadata_str = str(abspath)
if in_mels=CONF.NUM_MELS, hop_length=CONF.STFT_HOPSIZE
```
<Overlap Ratio: 0.37082818294190356>

---

--- 213 --
Question ID: 5a93cf64a2f1ac340c8208f986a4fd8f35d03148_1
Original Code:
```
def view(location, browser=None, new='same', autoraise=True):
    """ Opens a browser to view the specified location.

        Args:
            location (str) : location to open
                If location does not begin with "http:" it is assumed
                to be a file path on the local filesystem.
            browser (str) : what browser to use
            new (str) : how to open the location
                Valid values are:
                    * "same" - open in the current tab
                    * "tab" - open a new tab in the current window
                    * "window" - open in a new window
            autoraise (bool) : whether to raise the new location

        Returns:
            None

        """
    newMap = {'same': 0, 'window': 1, 'tab': 2}
    if location.startswith('http'):
        url = location
    else:
        url = 'file://' + abspath(location)
    try:
        controller = get_browser_controller(browser)
        controller.open(url, new=newMap[new], autoraise=autoraise)
    except (SystemExit, KeyboardInterrupt):
        raise
    except:
        pass
```


Overlapping Code:
```
True):
""" Opens a browser to view the specified location.
Args:
location (str) : location to open
If location does not begin with "http:" it is assumed
to be a file path on the local filesystem.
browser (str) : what browser to use
new (str) : how to open the location
Valid values are:
* "same" - open in the current tab
* "tab" - open a new tab in the current window
* "window" - open in a new window
autoraise (bool) : whether to raise the new location
Returns:
location)
try:
controller = get_browser_controller(browser)
controller.open(urutoraise=autoraise)
except (SystemExit, KeyboardInterrupt):
raise
except:
pas
```
<Overlap Ratio: 0.7478890229191797>

---

--- 214 --
Question ID: ad091436c7271a654fb820601c6d942f23f49ff5_3
Original Code:
```
def get_rna(fq_dict):
    """
    Obtain a numpy array with all detected spots in the image. Detection results
    are saved in a dictionary (see read_FQ_results_matlab for more details).
    """
    RNAall = nested_lookup('spots', fq_dict)
    for (idx, val) in enumerate(RNAall):
        if idx == 0:
            spotsAll = np.copy(val)
        else:
            spotsAll = np.append(spotsAll, val, axis=0)
    return spotsAll
```


Overlapping Code:
```
(fq_dict):
"""
Obtain a numpy array with all detected spots in the image. Detection results
are saved in a dictionary (see read_FQ_results_matlab for more details).
"""
RNAall = nested_lookup('spots',
```
<Overlap Ratio: 0.5555555555555556>

---

--- 215 --
Question ID: 8b2fa9137563469049632eeb151af101a87de1b0_5
Original Code:
```
@client.event
async def on_message(message):
    if message.author == client.user:
        if message.content == 'Authentication invalid':
            await renew_auth(message)
        return
    if message.content.startswith('>'):
        return
        await parse(message)
    if isinstance(message.channel, discord.channel.DMChannel):
        if message.content == 'quit':
            await do_quit(message)
        if message.content == 'test':
            return
            await do_tests(message)
        if message.content == 'renew' or message.content == 'reset':
            await renew_auth(message)
    if message.content.startswith('/'):
        await client.process_commands(message)
```


Overlapping Code:
```
@client.event
async def on_message(message):
if message.author == client.user:
if message.contf isinstance(message.channel, discord.channel.DMChannel):
if messageif message.content.startswith('/'):
await client.p
```
<Overlap Ratio: 0.37992831541218636>

---

--- 216 --
Question ID: 385dabe838e94b3bc682d337123e8384c47a3724_2
Original Code:
```
def parse_patterns(query, graph=False):
    """
    if query['patterns'] looks like so:
    ['target_type=', 'what=', '!tag_k=not_equals_thistag_v', 'tag_k:match_this_val', 'arbitrary', 'words']

    then the patterns will look like so:
    {
    'tag_k=not_equals_thistag_v': {'negate': True, 'match_tag_equality': ['tag_k', 'not_equals_thistag_v']},
    'target_type=':               {'negate': False, 'match_tag_equality': ['target_type', '']},
    'what=':                      {'negate': False, 'match_tag_equality': ['what', '']},
    'tag_k:match_this_val':       {'negate': False, 'match_tag_regex': ['tag_k', 'match_this_val']},
    'words':                      {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x2612cb0>},
    'arbitrary':                  {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x7f6cc000bd90>}
    }
    """
    patterns = {}
    for pattern in query['patterns']:
        negate = False
        if pattern.startswith('!'):
            negate = True
            pattern = pattern[1:]
        patterns[pattern] = {'negate': negate}
        if '=' in pattern:
            if not graph or pattern not in ('target_type=', 'what='):
                patterns[pattern]['match_tag_equality'] = pattern.split('=')
            else:
                del patterns[pattern]
        elif ':' in pattern:
            if not graph or pattern not in ('target_type:', 'what:'):
                patterns[pattern]['match_tag_regex'] = pattern.split(':')
            else:
                del patterns[pattern]
        else:
            patterns[pattern]['match_id_regex'] = re.compile(pattern)
    return patterns
```


Overlapping Code:
```

if query['patterns'] looks like so:
['target_type=', 'what=', '!tag_k=not_equals_thistag_v', 'tag_k:match_this_val', 'arbitrary', 'words']
then the patterns will look like so:
{
'tag_k=not_equals_thistag_v': {'negate': True, 'match_tag_equality': ['tag_k', 'not_equals_thistag_v']},
'target_type=': {'negate': False, 'match_tag_equality': ['target_type', '']},
'what=': {'negate': False, 'match_tag_equality': ['what', '']},
'tag_k:match_this_val': {'negate': False, 'match_tag_regex': ['tag_k', 'match_this_val']},
'words': {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x2612cb0>},
'arbitrary': {'negate': False, 'match_id_regex': <_sre.SRE_Pattern object at 0x7f6cc000bd90>}
}
"""
patterns = {}
for pattern in query['patterns']:
negate = False
if pattern.startswith('!'):
negate = True
pattern = pattern[1:]
patterns[pattern] = {'negate': negate}
if '=' in pattern:
if not graph or pattern not in ('target_type=', 'what='):
patterns[pattern]['match_tag_equality'] = pattern.split('=')
else:
del patterns[pattern]
elif ':' in pattern:
if not graph or pattern not in ('target_type:', 'what:'):
patterns[pattern]['match_tag_regex'] = pattern.split(':')
else:
del patterns[pattern]
else:
patterns[pattern]['match_id_regex'] = re.com
```
<Overlap Ratio: 0.9455370650529501>

---

--- 217 --
Question ID: c465816e2eca187bfd4fc478284eec3b6c703e51_15
Original Code:
```
def generalInquiry(choiceList, message):
    choiceList.append(colored('Return', 'red'))
    options = [inquirer.List('inputVal', message=message, choices=choiceList)]
    print(colored('Use arrow keys to navigate\n', 'blue'))
    print(colored('Proceed --> Enter / Return key\n', 'green'))
    return inquirer.prompt(options)['inputVal']
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 218 --
Question ID: 3b7d7e72a7f0b786dd6d72495ed17a1c7b0e1e9f_155
Original Code:
```
@card('Rolling Spoil')
def rolling_spoil(card, abilities):

    def rolling_spoil():
        return AbilityNotImplemented
    return (rolling_spoil,)
```


Overlapping Code:
```
ef rolling_spoil(card, abilities):
def rolling_spo
```
<Overlap Ratio: 0.3787878787878788>

---

--- 219 --
Question ID: d090023df2a9fa2d3a531ad91449ef05aefa4e12_1
Original Code:
```
def dice_loss(pred, target, smooth=1.0):
    pred = pred.contiguous()
    target = target.contiguous()
    intersection = (pred * target).sum(dim=1).sum(dim=1)
    loss = 1 - (2.0 * intersection + smooth) / (pred.sum(dim=1).sum(dim=1) + target.sum(dim=1).sum(dim=1) + smooth)
    return loss.mean()
```


Overlapping Code:
```
et, smooth=1.0):
pred = pred.contiguous()
target = target.contiguous()
intersection = (pred * target).sum(dimmooth) / (pred.sum(dim=1).sum(dim=1) + target.sum(
```
<Overlap Ratio: 0.5719424460431655>

---

--- 220 --
Question ID: 20fd1f5105839af2bba28ff254523016e1e09b8f_1
Original Code:
```
def _get_pipeline_definition_args(dag):
    check.inst_param(dag, 'dag', DAG)
    pipeline_dependencies = {}
    solid_defs = []
    seenTasks = []
    dag_roots = sorted(dag.roots, key=lambda x: x.task_id)
    for task in dag_roots:
        _traverse_airflow_dag(task, seenTasks, pipeline_dependencies, solid_defs)
    return (pipeline_dependencies, solid_defs)
```


Overlapping Code:
```
args(dag):
check.inst_param(dag, 'dag', DAG)
pipeline_deoots = sorted(dag.roots, key=lambda x: x.task_id)
for task in dag_roots:
_traverse_airflow_dag(task, se
```
<Overlap Ratio: 0.48773006134969327>

---

--- 221 --
Question ID: 200733e11c459547d9421419b37fface7ce8edae_11
Original Code:
```
def test_qcovariate_num_qs(exreaddata):
    test = covariate.QCovariate()
    assert test.num_qs() == 0
    test.consume_read(exreaddata)
    assert test.num_qs() == 11
```


Overlapping Code:
```
xreaddata):
test = covariate.QCovariate()
assert test.num_qs() == 0
test.consume_read(exreaddata)
as
```
<Overlap Ratio: 0.6578947368421053>

---

--- 222 --
Question ID: eac9bfadf6afe42b2ba6db1b9064946fdf240cf1_17
Original Code:
```
@card('Goblin Archaeologist')
def goblin_archaeologist(card, abilities):

    def goblin_archaeologist():
        return AbilityNotImplemented
    return (goblin_archaeologist,)
```


Overlapping Code:
```
ef goblin_archaeologist(card, abilities):
def goblin_archaeologist():
return AbilityNotImplemented
retu
```
<Overlap Ratio: 0.64375>

---

--- 223 --
Question ID: d2beff782efe625c4f930164ec0ecae6152de846_2
Original Code:
```
def get_final_seats_occupied_based_on_sight(seats: list[str]) -> int:
    old_grid = Grid(seats)
    while (newGrid := transform_based_on_los(old_grid)) != old_grid:
        old_grid = newGrid
    return newGrid.count('#')
```


Overlapping Code:
```
ased_on_sight(seats: list[str]) -> int:
old_grid =
```
<Overlap Ratio: 0.24752475247524752>

---

--- 224 --
Question ID: 65d2c4247e06b070e56286e1c0516a47f5fdba82_1
Original Code:
```
def generate_testcase_files(instance, env, testcase_dir_path):
    testcases_list = []
    config = {'config': {'name': instance.name, 'variables': [], 'request': {'base_url': env.base_url if env else ''}}}
    testcases_list.append(config)
    include = json.loads(instance.include, encoding='utf-8')
    request = json.loads(instance.request, encoding='utf-8')
    module_name = instance.module.name
    projectName = instance.module.project.name
    testcase_dir_path = os.path.join(testcase_dir_path, projectName)
    if not os.path.exists(testcase_dir_path):
        os.makedirs(testcase_dir_path)
        debugtalk_obj = Projects.objects.get(name=projectName).debugtalk
        if debugtalk_obj:
            debugtalk = debugtalk_obj.debugtalk
        else:
            debugtalk = ''
        with open(os.path.join(testcase_dir_path, 'debugtalk.py'), mode='w', encoding='utf-8') as one_file:
            one_file.write(debugtalk)
    testcase_dir_path = os.path.join(testcase_dir_path, module_name)
    if not os.path.exists(testcase_dir_path):
        os.makedirs(testcase_dir_path)
    if 'testcases' in include:
        for t_id in include.get('testcases'):
            testcase_obj = Testcases.objects.filter(id=t_id).first()
            if testcase_obj:
                try:
                    testcase_request = json.loads(testcase_obj.request, encoding='utf-8')
                except Exception as e:
                    logger.error(e)
                    continue
                else:
                    extract = testcase_request['test'].get('extract')
                    if extract:
                        for e in extract:
                            testcases_list[0]['config']['variables'].append({[i for i in e.keys()][0]: ''})
                    testcase_request['test'] = OrderedDict(testcase_request['test'])
                    testcases_list.append(OrderedDict(testcase_request))
    request['test'] = OrderedDict(request['test'])
    testcases_list.append(request)
    with open(os.path.join(testcase_dir_path, instance.name + '.yml'), mode='w', encoding='utf-8') as one_file:
        ordered_yaml_dump(testcases_list, one_file, default_flow_style=False, allow_unicode=True)
```


Overlapping Code:
```
ef generate_testcase_files(instance, env, testcase_dir_pathlude = json.loads(instance.include, encoding='utf-t = json.loads(instance.request, encoding='utf-8')testcase_dir_path = os.path.join(testcase_dir_path, projot os.path.exists(testcase_dir_path):
os.makedirs(testcase_dir_path)
debu).debugtalk
if debugtalk_obj:
debugtalk = debugtalk_obj.debugtalk
elsen(os.path.join(testcase_dir_path, 'debugtalk.py'),file:
one_file.write(debugtalk)
testcase_dir_path = os.path.join(testcase_dir_path, ot os.path.exists(testcase_dir_path):
os.makedirs(testcase_dir_patin include:
for t_id in include.get('testcases'):
testcase_obj = Testcases.objects.filter(id=t_id).first()
if testcase_obj:
try:
testcase_request = json.loads(testcase_obj.request, encoding='utf-8')
except Exception as e:
logger.error(e)
continue
else:d({[i for i in e.keys()][0]: ''})
testcase_requestestcases_list.append(OrderedDict(testcase_request)st.append(request)
with open(os.path.join(testcase_dir_pist, one_file, default_flow_style=False, allow_unicode=True)
```
<Overlap Ratio: 0.5751121076233184>

---

--- 225 --
Question ID: 679616cb8b1011d2bf2813d8352a4c19d23a2b17_8
Original Code:
```
def save_current_window_and_open_tools_window():
    """
    Save the current window with `save_current_window' and open the eiffel
    tools buffer in a window. The window containing the eiffel tools buffer
    will be selected after the launch of this routine. To reselect the
    window saved by this routine, use the `select_saved_window' routine.
    """
    tools_buffer_name = environment.get_global_variable('eiffel_tools_buffer_name')
    toolsBufferNumber = get_tools_buffer_number()
    if toolsBufferNumber < 0:
        save_current_window_and_open_new_tools_window(tools_buffer_name)
    else:
        tools_buffer_window_number = int(environment.evaluate('bufwinnr("' + tools_buffer_name + '")'))
        if tools_buffer_window_number < 0:
            save_current_window_and_open_existing_tools_window(tools_buffer_name)
        else:
            save_current_window_and_select_tools_window(tools_buffer_window_number)
    environment.execute('setlocal filetype=')
```


Overlapping Code:
```
pen_tools_window():
"""
Save the current window with `save_current_window' and open the eiffel
tools buffer in a window. The window containing the eiffel tools buffer
will be selected after the launch of this routine. To reselect the
window saved by this routine, use the `select_saved_window' routine.
"""
tools_buffer_name = environment.get_global_ols_window(tools_buffer_name)
else:
tools_buffer_wr_window_number < 0:
save_current_window_and_open_
```
<Overlap Ratio: 0.5119453924914675>

---

--- 226 --
Question ID: a1475fa68fd62c2546f13e320d8164046b674af2_0
Original Code:
```
def sub_special_tokens(text):
    text = re.sub(' www.', ' http://www.', text)
    text = re.sub('(https|http)?:\\/\\/(\\w|\\.|\\/|\\?|\\=|\\&|\\%)*\\b', ' xxurl ', text)
    pat = '\\d{3}[-\\.\\s]??\\d{4}[-\\.\\s]??\\d{4}|\\d{5}[-\\.\\s]??\\d{3}[-\\.\\s]??\\d{3}|(?:\\d{4}\\)?[\\s-]?\\d{3}[\\s-]?\\d{4})'
    text = re.sub(pat, ' xxphone ', text)
    text = text.replace('£', '$ ')
    text = re.sub('(\\d+)[ ]{0,1}p', '$ 0.\x01', text)
    text = re.sub('\\$[ ]*(\\d+[,\\.])*\\d+', ' xxmon ', text)
    text = re.sub('(\\b[A-Z][A-Z0-9]*\\b)', ' xxup \\1 ', text)
    text = re.sub('(\\b[A-Z][a-z0-9]+\\b)', ' xxcap \\1 ', text)
    text = re.sub('[:;][ ]*[-]*[ ]*[()]', ' xxemoji ', text)
    return text
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 227 --
Question ID: 10e63bec5b7e172368421e76129581befebd5bc0_6
Original Code:
```
def part_sum(bitlist, indices):
    """Compute the mod 2 sum of the subset of bits in bitlist given by the list of indices."""
    sum = 0
    for x in indices:
        sum = sum ^ bitlist[x]
    return sum
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 228 --
Question ID: 90681b31e1662f4f8ed10dcfc71a183b60796d93_68
Original Code:
```
def experimental_parallel_interleave_dataset(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, f, outputTypes, output_shapes, name=None):
    """Creates a dataset that applies `f` to the outputs of `input_dataset`.

  The resulting dataset is similar to the `InterleaveDataset`, with the exception
  that if retrieving the next value from a dataset would cause the requester to
  block, it will skip that input dataset. This dataset is especially useful
  when loading data from a variable-latency datastores (e.g. HDFS, GCS), as it
  allows the training step to proceed so long as some data is available.

  !! WARNING !! This dataset is not deterministic!

  Args:
    input_dataset: A `Tensor` of type `variant`.
    other_arguments: A list of `Tensor` objects.
    cycle_length: A `Tensor` of type `int64`.
    block_length: A `Tensor` of type `int64`.
    sloppy: A `Tensor` of type `bool`.
    buffer_output_elements: A `Tensor` of type `int64`.
    prefetch_input_elements: A `Tensor` of type `int64`.
    f: A function decorated with @Defun.
      A function mapping elements of `input_dataset`, concatenated with
      `other_arguments`, to a Dataset variant that contains elements matching
      `output_types` and `output_shapes`.
    output_types: A list of `tf.DTypes` that has length `>= 1`.
    output_shapes: A list of shapes (each a `tf.TensorShape` or list of `ints`) that has length `>= 1`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `variant`.
  """
    _ctx = _context._context or _context.context()
    tld = _ctx._thread_local_data
    if tld.is_eager:
        try:
            _result = pywrap_tfe.TFE_Py_FastPathExecute(_ctx._context_handle, tld.device_name, 'ExperimentalParallelInterleaveDataset', name, tld.op_callbacks, input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, 'f', f, 'output_types', outputTypes, 'output_shapes', output_shapes)
            return _result
        except _core._NotOkStatusException as e:
            _ops.raise_from_not_ok_status(e, name)
        except _core._FallbackException:
            pass
        try:
            return experimental_parallel_interleave_dataset_eager_fallback(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, f=f, output_types=outputTypes, output_shapes=output_shapes, name=name, ctx=_ctx)
        except _core._SymbolicException:
            pass
    if not isinstance(outputTypes, (list, tuple)):
        raise TypeError("Expected list for 'output_types' argument to 'experimental_parallel_interleave_dataset' Op, not %r." % outputTypes)
    outputTypes = [_execute.make_type(_t, 'output_types') for _t in outputTypes]
    if not isinstance(output_shapes, (list, tuple)):
        raise TypeError("Expected list for 'output_shapes' argument to 'experimental_parallel_interleave_dataset' Op, not %r." % output_shapes)
    output_shapes = [_execute.make_shape(_s, 'output_shapes') for _s in output_shapes]
    (_, _, _op, _outputs) = _op_def_library._apply_op_helper('ExperimentalParallelInterleaveDataset', input_dataset=input_dataset, other_arguments=other_arguments, cycle_length=cycle_length, block_length=block_length, sloppy=sloppy, buffer_output_elements=buffer_output_elements, prefetch_input_elements=prefetch_input_elements, f=f, output_types=outputTypes, output_shapes=output_shapes, name=name)
    _result = _outputs[:]
    if _execute.must_record_gradient():
        _attrs = ('f', _op.get_attr('f'), 'Targuments', _op.get_attr('Targuments'), 'output_types', _op.get_attr('output_types'), 'output_shapes', _op.get_attr('output_shapes'))
        _inputs_flat = _op.inputs
        _execute.record_gradient('ExperimentalParallelInterleaveDataset', _inputs_flat, _attrs, _result)
    (_result,) = _result
    return _result
```


Overlapping Code:
```
l_parallel_interleave_dataset(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, f, Creates a dataset that applies `f` to the outputs of `input_dataset`.
The resulting dataset is similar to the `InterleaveDataset`, with the exception
that if retrieving the next value from a dataset would cause the requester to
block, it will skip that input dataset. This dataset is especially useful
when loading data from a variable-latency datastores (e.g. HDFS, GCS), as it
allows the training step to proceed so long as some data is available.
!! WARNING !! This dataset is not deterministic!
Args:
input_dataset: A `Tensor` of type `variant`.
other_arguments: A list of `Tensor` objects.
cycle_length: A `Tensor` of type `int64`.
block_length: A `Tensor` of type `int64`.
sloppy: A `Tensor` of type `bool`.
buffer_output_elements: A `Tensor` of type `int64`.
prefetch_input_elements: A `Tensor` of type `int64`.
f: A function decorated with @Defun.
A function mapping elements of `input_dataset`, concatenated with
`other_arguments`, to a Dataset variant that contains elements matching
`output_types` and `output_shapes`.
output_types: A list of `tf.DTypes` that has length `>= 1`.
output_shapes: A list of shapes (each a `tf.TensorShape` or list of `ints`) that has length `>= 1`.
name: A name for the operation (optional).
Returns:
A `Tensor` of type `variant`.
"""
_ctx = _context._context or _context.context()
tld = _ctx._thread_local_data
if tld.is_eager:
try:
_result = pywrap_tfe.TFE_Py_FastPathExecute(e, tld.op_callbacks, input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements output_shapes)
return _result
except _core._NotOkStatusException as e:
_ops.raise_from_not_ok_status(e, name)
except _core._FallbackException:
pass
try:
return experimental_parallel_interleave_dataset_eager_fallback(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements
```
<Overlap Ratio: 0.8844984802431611>

---

--- 229 --
Question ID: 5d67dd4c40040dcf2e4bbcd0df1123cacc8a09a7_3
Original Code:
```
def get_conversion_rate(response_data):
    data = str(response_data)
    keyword_conversion = 'conversion_rate'
    slen = len(keyword_conversion)
    start_index = data.find(keyword_conversion)
    extra_len = 9
    extractedStr = data[start_index:start_index + slen + extra_len]
    word_list = extractedStr.split(':')
    conversion_rate = word_list[1]
    result = float(conversion_rate)
    loginfo('Conversion Rate = ' + str(result), get_conversion_rate.__name__)
    return result
```


Overlapping Code:
```
version_rate(response_data):
data = str(response_data)
keyword_conversion = 'conversion_rate'
slen = len(keyword_conversion)
start_index = data.find(keyword_conversion)
extra_len (':')
conversion_rate = word_list[1]
result = floatr(result), get_conversion_rate.__name__)
return r
```
<Overlap Ratio: 0.6283783783783784>

---

--- 230 --
Question ID: b740c4349aa6a00f9a664792b9a5d497e887cbae_0
Original Code:
```
@pytest.mark.parametrize('value,expected', (('', ''), (None, ''), ('very long ' * 100, '')))
def test_mobile_number_clean(value, expected):
    field = forms.MobileNumberField(max_length=100)
    assert field.to_python(value) == expected
```


Overlapping Code:
```
est_mobile_number_clean(value, expected):
field = forms.MobileNumberField(max_length=100)
assert field.to_pytho
```
<Overlap Ratio: 0.4847161572052402>

---

--- 231 --
Question ID: eedf072c408246eee339cda55c42a69c694380b4_2
Original Code:
```
def extract_bucket_reference_for_param_reference(template, param_name):
    param_value = template.get_parameter_default(param_name)
    if param_value is None:
        return
    for resource in template.resources('AWS::Serverless::Function'):
        policies = resource['Properties'].get('Policies')
        if policies is None:
            continue
        for policy in policies:
            for statement in policy['Statement']:
                if param_value not in statement.get('Resource', ''):
                    continue
                old_value = statement['Resource']
                parts = list(old_value.partition(param_value))
                parts[1] = {'Ref': param_name}
                newValue = {'Fn::Join': ['', parts]}
                statement['Resource'] = newValue
```


Overlapping Code:
```
extract_bucket_reference_for_param_reference(templer_default(param_name)
if param_value is None:
return
for resource in template.resources('AWS::Serverless::Function'):
policies = resource['Properties'].get('Policies')
if policies is None:
continue
for policy in policies:
for statement in policy['Statement']:
if param_value not in statement.get('Resource', ''):
continue
old_value = statement['Resource']
parts = list(old_value.partition(param_valu
```
<Overlap Ratio: 0.7377049180327869>

---

--- 232 --
Question ID: 6f11be4ebd108a94cb1027e16e858ff097fa14e5_0
Original Code:
```
def text_to_spreadsheet(directory='.', output_file='text_to_sheet.xlsx'):
    """
    Searches for all text files at the given directory. Each individual
    text file is converted to a column in the output_file spreadsheet.

    :param str directory: path to directory to search
    :param str output_file: name of output file
    """
    path = os.path.abspath(directory)
    wb = openpyxl.Workbook()
    wb.create_sheet(title='Text to Columns', index=0)
    sheet = wb.active
    bold = Font(bold=True)
    print(f'Searching for text files...')
    files = [file for file in os.listdir(path) if file.lower().endswith('.txt')]
    column = 1
    print(f'Writing lines of text to columns...')
    for file in files:
        row = 2
        with open(os.path.join(path, file)) as text:
            sheet.cell(row=1, column=column).value = file
            sheet.cell(row=1, column=column).font = bold
            for line in text:
                sheet.cell(row=row, column=column).value = line
                row += 1
        column += 1
    wb.save(filename=output_file)
    print(f"Resulting file saved as '{output_file}'")
```


Overlapping Code:
```
ef text_to_spreadsheet(directory='.', output_file='text_to_sheet.xlsx'):
"""
Searches for all text files at the given directory. Each individual
text file is converted to a column in the output_file spreadsheet.
:param str directory: path to directory to search
:param str output_file: name of output file
"""
path = os.path.abspath(directory)
wb = openpyxl.Workbook()
wb.create_sheet(title='Text to Columns', index=0)
sheet = wb.active
bold = Font(bfiles = [file for file in os.listdir(path) if file.lower().endswith('.txt')]
column = 1
print(f'Writing t:
sheet.cell(row=1, column=column).value = file
sheet.cell(row=1, column=column).font = bold
for line in text:
sheet.cell(row=row, column=column).value = line
row += 1
column += 1
wb.save(filename=output_file)
print(f"Resulting file saved as '{outpu
```
<Overlap Ratio: 0.8357588357588358>

---

--- 233 --
Question ID: 1b7c720289e99957b1d1e5c9b70d89bb7e355da1_1
Original Code:
```
@tf.function
def train_step(x_target, y_target, model, optimizer, model_loss):
    with tf.GradientTape() as model_tape:
        y_predic = model(x_target, training=True)
        loss = model_loss(y_target, y_predic)
    gradientsOfModel = model_tape.gradient(loss, model.trainable_variables)
    optimizer.apply_gradients(zip(gradientsOfModel, model.trainable_variables))
    return loss
```


Overlapping Code:
```
function
def train_step(x_target, y_target, model,() as model_tape:
y_predic = model(x_target, training=tape.gradient(loss, model.trainable_variables)
optimizer.apply_gradients(zip(gradients
```
<Overlap Ratio: 0.5337078651685393>

---

--- 234 --
Question ID: 49f5a6884183e7a4dcbfcde101a491ad27898026_3
Original Code:
```
def _get_eval_config_from_service_classification(classification: configuration_pb2.ClassificationProblemSpec, eval_config: model_evaluation_pb2.EvaluationConfig) -> None:
    if classification.HasField('ground_truth_column_spec'):
        eval_config.data_spec.label_key_spec.CopyFrom(classification.ground_truth_column_spec)
    if classification.HasField('example_weight_column_spec'):
        eval_config.data_spec.example_weight_key_spec.CopyFrom(classification.example_weight_column_spec)
    if classification.HasField('prediction_score_column_spec'):
        eval_config.data_spec.predicted_score_key_spec.CopyFrom(classification.prediction_score_column_spec)
    if classification.HasField('prediction_label_column_spec'):
        eval_config.data_spec.predicted_label_key_spec.CopyFrom(classification.prediction_label_column_spec)
    if classification.HasField('prediction_id_column_spec'):
        eval_config.data_spec.predicted_label_id_key_spec.CopyFrom(classification.prediction_id_column_spec)
    eval_config.data_spec.labels.extend(classification.class_names)
    numClasses = len(classification.class_names)
    if classification.type == configuration_pb2.ClassificationProblemSpec.MULTICLASS:
        problem_type = constants.ProblemType.MULTICLASS
    elif classification.type == configuration_pb2.ClassificationProblemSpec.MULTILABEL:
        problem_type = constants.ProblemType.MULTILABEL
    else:
        raise NotImplementedError('Classification type %r not implemented' % classification.type)
    adapter = tfma_adapter.TFMAToME(class_name_list=list(classification.class_names))
    tfma_metric_specs = _get_metric_specs(problem_type, list(classification.class_names), list(classification.evaluation_options.positive_classes), list(classification.evaluation_options.top_k_list))
    for tfma_metric_spec in tfma_metric_specs:
        eval_config.metrics_specs.append(adapter.metrics_spec(tfma_metric_spec))
```


Overlapping Code:
```
fig: model_evaluation_pb2.EvaluationConfig) -> None:
if classification.HasField('ground_truth_column_spec'):
eval_config.data_spec.lasification.ground_truth_column_spec)
if classification.HasField('example_weight_column_spec'):
eval_config.data_spec.example_weight_key_spec.CopyFrom(ssification.HasField('prediction_score_column_spec'):
eval_config.data_spec.predicted_score_key_specspec)
if classification.HasField('prediction_label_column_spec'):
eval_config.data_spec.predicted_laabel_column_spec)
if classification.HasField('prediction_id_column_spec'):
eval_config.data_spec.predicted_laprediction_id_column_spec)
eval_config.data_spec.les = len(classification.class_names)
if classification.type == configuration_pb2.ClassificationProblemSpec.MULTICLASS:
problem_type = constants.ProblemType.MULTICLASS
elif classification.type == configuration_pb2.ClassificationProblemSpec.MULTILABEL:
problem_type = constants.ProblemType.MULTILABEL
else:
raise NotImplementedError('Classification typs_name_list=list(classification.class_names))
tfmasification.evaluation_options.top_k_list))
for tfma_metric_spec in tfma_metric_specs:
eval_config.metrics_specs.append(adapter.metrics_spec(tfma_metri
```
<Overlap Ratio: 0.6585635359116022>

---

--- 235 --
Question ID: 02819a01b041692ac69ff145ea5f13a590fc9b34_2
Original Code:
```
def _guess_package_name(file_type, fileName):
    if not file_type:
        return None
    fileName = fileName.lower()
    if 'Bourne-Again' in file_type or 'bash' in file_type:
        return 'bash'
    elif 'Mach-O' in file_type and 'executable' in file_type:
        return 'macho'
    elif 'directory' in file_type or (fileName.endswith('.app') or fileName.endswith('.app/')) or (fileName.endswith('.pkg') or fileName.endswith('.pkg/')):
        return 'app'
    elif 'Zip archive' in file_type and fileName.endswith('.zip'):
        return 'zip'
    elif 'PDF' in file_type or fileName.endswith('.pdf'):
        return 'pdf'
    elif 'Microsoft Word' in file_type or 'Microsoft Office Word' in file_type or fileName.endswith('.docx') or fileName.endswith('.doc'):
        return 'doc'
    elif 'Rich Text Format' in file_type or fileName.endswith('.rtf') or 'property list' in file_type or fileName.endswith('.plist'):
        return 'rtf'
    elif 'HTML' in file_type or fileName.endswith('.htm') or fileName.endswith('.html'):
        return 'html'
    elif fileName.endswith('.jar'):
        return 'jar'
    elif fileName.endswith('.py') or 'Python script' in file_type:
        return 'python'
    elif fileName.endswith('.pl') or 'perl script' in file_type.lower():
        return 'perl'
    elif fileName.endswith('.dmg'):
        return 'dmg'
    else:
        return 'generic'
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 236 --
Question ID: 6576548aed0db505fcd1e0ff4f67a6208131321a_7
Original Code:
```
def login0(auth=None):
    """Handle secure login for performance and stress testing.

    Signature is the signature of email value with the application key.
    """
    if not auth:
        auth = request.headers.get('Authorization')
        if not auth:
            resp = Response()
            resp.headers['WWW-Authenticate'] = 'Basic realm="Access to the load-testing login"'
            resp.status_code = 401
            return resp
        if ':' not in auth:
            auth = base64.b64decode(auth).decode()
    (email, signature) = auth.split(':')
    s = Signer(app.secret_key)
    if s.validate(email + '.' + signature):
        try:
            u = User.get(email=email)
            login_user(u)
            return redirect(get_next_url() or url_for('index'))
        except User.DoesNotExist:
            return handle_login()
    abort(403)
```


Overlapping Code:
```
gin0(auth=None):
"""Handle secure login for performance and stress testing.
Signature is the signature of email value with the application key.
"""
if:
auth = request.headers.get('Authorization')
if not auth:
r= Response()
resp.headers['WWW-Authenticate'] = 'Basic realm=oad-testing login"'
resp.status_code = 401
return in_user(u)
return redirect(get_next_url() or url_f
```
<Overlap Ratio: 0.5463917525773195>

---

--- 237 --
Question ID: 782e47ae6e2a1bc565a53c10fee16a15dc5e46b5_2
Original Code:
```
def readStr_qm9():
    f = open(current_dir + '/../_dataset/QM9/qm9.smi', 'r')
    L = []
    for line in f:
        line = line.strip()
        L.append(line)
    f.close()
    np.random.seed(1)
    np.random.shuffle(L)
    return L
```


Overlapping Code:
```
 + '/../_dataset/QM9/qm9.smi', 'r')
L = []
for line in f:
line = line.strip()
L.append(line)
f.close()
np.random.seed(1)
np.random.shuffle(L)
return L
```
<Overlap Ratio: 0.7936507936507936>

---

--- 238 --
Question ID: cbd6d9414697897c65c3690922a074fdd0eec5b2_4
Original Code:
```
@pytest.mark.parametrize('method_name', ['from_pandas', 'iter_from_pandas'])
def test_dynamic_defines_key_fields(pandas_data, method_name):
    model = PandasToRecordsTransformer(pandas_data, 'MyRecord', key_fields={'key_field'})
    fromPandasMethod = getattr(model, method_name)
    record = list(fromPandasMethod(pandas_data))[0]
    assert record.key_fields == {'key_field'}
```


Overlapping Code:
```
(pandas_data, method_name):
model = PandasToRecordsTransformer(pandas_as_data))[0]
assert record.key_fields == {'key_fie
```
<Overlap Ratio: 0.3314917127071823>

---

--- 239 --
Question ID: 6b441b738c1e2efec58e60abe442cbe344419f54_3
Original Code:
```
def avro_schema(avsc: Union[dict, str]) -> dict:
    """ Create avro schema from dictionary or filepath string """
    logging.info('Parsing avro schema')
    if isinstance(avsc, dict):
        avsc = avro.schema.parse_schema(avsc)
    elif isinstance(avsc, str):
        avsc = avro.schema.load_schema(avsc)
    return avsc
```


Overlapping Code:
```
tr]) -> dict:
""" Create avro schema from dictiona)
if isinstance(avsc, dict):
avsc = avro.schema.palif isinstance(avsc, str):
avsc = avro.schema.load
```
<Overlap Ratio: 0.5208333333333334>

---

--- 240 --
Question ID: f4365a09ba1797e4fafc8682981c9fb04235a5c1_1
Original Code:
```
@pytest.mark.parametrize('space_group', ['P2', 'P3', 'P6', 'R3:h', 'I23'][:])
def test_determine_space_group(space_group):
    sgi = sgtbx.space_group_info(symbol=space_group)
    sg = sgi.group()
    cs = sgi.any_compatible_crystal_symmetry(volume=10000)
    cs = cs.best_cell()
    cs = cs.minimum_cell()
    intensities = generate_fake_intensities(cs)
    result = LaueGroupAnalysis([intensities], normalisation=None)
    print(result)
    assert result.best_solution.subgroup['best_subsym'].space_group() == sg.build_derived_patterson_group()
    assert result.best_solution.likelihood > 0.8
    for score in result.subgroup_scores[1:]:
        assert score.likelihood < 0.1
```


Overlapping Code:
```
space_group', ['P2', 'P3', 'P6', 'R3:h', 'I23'][:])
def test_determine_space_group(space_group):
sgi = sgtbx.space_group_info(symbol=space_group)
sg = sgi.group()
cs = sgi.any_compatible_crystal_symmetry(volume=10000)
cs = cs.best_cell()
cs = cs.minimum_cell()
intensities = generate_fake_intensities(cs)
result = LaueGroupAnalysis([intensities], normalisation=None)
prinbest_solution.subgroup['best_subsym'].space_group() == sg.build_derived_patterson_group()
assert result.best_solution.likelihood > 0.8
for score in result.subgroup_scores[1:]:
assert score.likelihood 
```
<Overlap Ratio: 0.9121405750798722>

---

--- 241 --
Question ID: 3f0ef81e04475f7801a661ee804b85c33aca42e7_0
Original Code:
```
def get_installed_packages():
    reqs = subprocess.check_output([sys.executable, '-m', 'pip', 'freeze'])
    installedPackages = [r.decode().split('==')[0] for r in reqs.split()]
    return installedPackages
```


Overlapping Code:
```
:
reqs = subprocess.check_output([sys.executable, '-m', 'pip', 'freeze'])
installedckages = [r.decode().split('==')[0] for r in reqs.split()]
return ins
```
<Overlap Ratio: 0.7755102040816326>

---

--- 242 --
Question ID: 9cb1075cc24b8fabc3e7e078623e7b3ba9e43ca3_7
Original Code:
```
def run_sample_whole_range():
    log_file = '../results/DBEsti_tpcds_100k_all.log'
    db = DBEst(dataset='tpcds', logger_file=log_file)
    table = 'store_sales'
    file = '../data/tpcDs10k/store_sales.csv'
    numOfPoints = {'store_sales': '2685596178'}
    table_column_sets = [['ss_list_price', 'ss_wholesale_cost']]
    db.init_whole_range(file=file, table=table, columnItems=table_column_sets, num_of_points=numOfPoints)
    db.clear_training_data()
    db.logger.logger.info('Total size of DBEst is ' + str(db.get_size()) + ' bytes.')
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 243 --
Question ID: 41a7419f7ecd636b33374eda954170a04c2d6f82_2
Original Code:
```
def get_cert(client, service, file_path, local_path, remote_cert_path, remote_csr_path):
    """
    Gets the certificate (sign or auth) from the CA.

    NB! This requires the user to have sudo rights without password prompt.
    :param client: SSHClient object
    :param service: str - service type: sign-sign (signing certificates) or sign-auth (authentication certificates)
    :param file_path: str - local CSR path (input)
    :param local_path: str - local certificate path (output)
    :param remote_cert_path: str - remote certificate path (output)
    :param remote_csr_path: str - remote CSR path (input)
    :return: None
    """
    client.exec_command('rm temp*')
    sftp = client.get_client().open_sftp()
    sftp.put(file_path, remote_csr_path)
    client.exec_command('cat ' + remote_csr_path + ' | ' + service + ' > ' + remote_cert_path)
    time.sleep(3)
    sftp.get(remote_cert_path, local_path)
    sftp.close()
    client.close()
```


Overlapping Code:
```
t, service, file_path, local_path, remote_cert_pat certificate (sign or auth) from the CA.
NB! This requires the user to have sudo rights without password prompt.
:param client: SSHClient object
:param service: str - service type: sign-sign (signing certificates) or sign-auth (authentication certificates)
:param file_path: str - local CSR path (input)
:param local_path: str - local certificate path (output)
:param remote_cert_path: str - remote certificate path (output)
:param remote_csr_path: str - remote CSR pent.exec_command('cat ' + remote_csr_path + ' | ' + service + ' > ' + remote_cert_path)
time.sleep(3
```
<Overlap Ratio: 0.7035347776510832>

---

--- 244 --
Question ID: 2cf7ecb49570612ea3ef106c4439aab58551dc8a_9
Original Code:
```
def render_bokeh_figure(result, state):
    from bokeh.resources import CDN
    if 'headers' not in state:
        state['headers'] = set()
    state['headers'].update(['<script src="%s" async=""></script>' % CDN.js_files[0], '<link rel="stylesheet" href="%s" type="text/css"/>' % CDN.css_files[0]])
    from bokeh.embed import components
    (script, div) = components(result, CDN)
    if 'footers' not in state:
        state['footers'] = list()
    state['footers'].append(script)
    return [closing_fence(state['code']), div, state['code']]
```


Overlapping Code:
```
eh.resources import CDN
if 'headers' not in state:
state['headers'] = set()
state['headers'].update(k rel="stylesheet" href="%s" type="text/css"/>' % , CDN)
if 'footers' not in state:
state['footers'] = list()
state['footers'].append(script)
return [
```
<Overlap Ratio: 0.5030181086519114>

---

--- 245 --
Question ID: 17fa8f3d90779608a0fa731c756323ee0bb02290_6
Original Code:
```
def set_up_outputs(OutputObj):
    OutputObj.add_output('lead_snps_matching_quality_file', 'lead_snps_matching_quality.tsv', add_root=True)
    OutputObj.add_output('ldscore_for_expanded_control_sets_quality_file', 'ldscore_matching_quality_for_ldexpanded_sets.tsv', add_root=True)
    OutputObj.add_output('ldsnp_coverage_by_input_snp', 'ldsnp_coverage_by_input_snp.tsv', add_root=True)
    return OutputObj
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 246 --
Question ID: 44f8ed8d741874b6b1b7ec273d09a2bf1be84c93_3
Original Code:
```
def test_schemakey():
    typemap = {'BareAsset': 'Asset', 'PublishedAsset': 'Asset', 'PublishedDandiset': 'Dandiset'}
    for val in dir(models):
        if val in ['BaseModel']:
            continue
        klass = getattr(models, val)
        if isinstance(klass, pydantic.main.ModelMetaclass):
            assert 'schemaKey' in klass.__fields__
            if val in typemap:
                assert typemap[val] == klass.__fields__['schemaKey'].default
            else:
                assert val == klass.__fields__['schemaKey'].default
```


Overlapping Code:
```
ntinue
klass = getattr(models, val)
if isinstance(
```
<Overlap Ratio: 0.11627906976744186>

---

--- 247 --
Question ID: 2888eb7991df8f7416f4f9dbfa57abb2f621d817_3
Original Code:
```
def plot_mne_circular_connectivity_network(con_mat, labels, perc_conn=0.25, cfc=False, fig=None, subplot=111, fig_title=None, node_name=True, vmax=None, vmin=0, colormap='Blues', facecolor='white', textcolor='black'):
    from mne.viz import circular_layout, plot_connectivity_circle
    fig_title = '' if fig_title is None else fig_title
    node_colors = [label.color for label in labels]
    label_names = [label.name for label in labels]
    lh_labels = [name for name in label_names if name.endswith('lh')]
    rhLabels = [name for name in label_names if name.endswith('rh')]
    (labels_network_sorted, idx_lbl_sort) = rearrange_labels_network(labels)
    label_names_sorted = [label_names[ii] for ii in idx_lbl_sort]
    lh_labels = [name[:-3] for name in label_names_sorted if name.endswith('lh')]
    rhLabels = [name[:-3] for name in label_names_sorted if name.endswith('rh')]
    label_names = [name[:-3] for name in label_names]
    node_order = lh_labels[::-1] + rhLabels
    node_angles = circular_layout(label_names, node_order, start_pos=90, group_boundaries=[0, len(label_names) // 2])
    if not node_name:
        label_names = [''] * len(label_names)
    else:
        label_names = [label.name[13:-3] for label in labels]
    if perc_conn < 1:
        n_lines = int(np.prod(con_mat.shape) / 2 * perc_conn)
    else:
        n_lines = None
    if fig is None:
        fig = plt.figure(num=None, figsize=(8, 8), facecolor='black')
    if cfc:
        return plot_connectivity_circle_cfc(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)
    else:
        plot_connectivity_circle(con_mat, label_names, n_lines=n_lines, node_angles=node_angles, node_colors=node_colors, title=fig_title, fig=fig, subplot=subplot, vmax=vmax, vmin=vmin, facecolor=facecolor, colormap=colormap, textcolor=textcolor)
```


Overlapping Code:
```
te', textcolor='black'):
from mne.viz import circular_layout, plot_connectivity_circle
fig_title = '' if fig_title isabel_names = [label.name for label in labels]
lh_labels = [name for name in label_names if name.endswith('lh')]
bels = [name for name in label_names if name.endswith('rhe_labels_network(labels)
label_names_sorted = [labme[:-3] for name in label_names_sorted if name.endswime[:-3] for name in label_names_sorted if name.endswith('rh')]
label_names abels
node_angles = circular_layout(label_names, node_order, start_p_names) // 2])
if not node_name:
label_names = [''] * len(label_names)
else:
label_names = [label.namef fig is None:
fig = plt.figure(num=None, figsize=(8, 8), facecolor='black')
if cfc:
return plot_connectivity_circle_cfc(con_mat, label_names, n_linesrmap=colormap, textcolor=textcolor)
else:
plot_connectivity_circle(con_mat, label_names, n_lines=n_l
```
<Overlap Ratio: 0.4799131378935939>

---

--- 248 --
Question ID: 27b7373c43ce0501e65b8ff161bfcf8803e53e2c_0
Original Code:
```
def showmesh(node, elem, **kwargs):
    triangulation = tri.Triangulation(node[:, 0], node[:, 1], elem)
    markersize = 3000 / len(node)
    if kwargs.items():
        h = plt.triplot(triangulation, 'b-h', **kwargs)
    else:
        h = plt.triplot(triangulation, 'b-h', linewidth=0.5, alpha=0.5, markersize=markersize)
    return h
```


Overlapping Code:
```
wmesh(node, elem, **kwargs):
triangulation = tri.Triangulation(node[:, 0], node[:, 1], elem)
markersde)
if kwargs.items():
h = plt.triplot(triangulation, 'b-h', **kwargs)
else:
h = plt.triplot(triangulation, 'b-h', linewidth=0.5, alpha=0.5, markersiz
```
<Overlap Ratio: 0.8389261744966443>

---

--- 249 --
Question ID: 6e9344b369513894bde3339419e2b7d6be02f344_1
Original Code:
```
def load_character_json(path):
    with open(path, 'r') as f:
        raw = f.read()
        raw = raw.replace('inf,', '999999999,')
        logging.info('Returning python object')
        return json.loads(raw)
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 250 --
Question ID: 58199be75c2f936778ed896013450ada42119647_4
Original Code:
```
def _setup(dataset_dir, label_types=None, classes=None, attrs=None, seed=None, download=False):
    did_download = False
    _label_types = _parse_label_types(label_types)
    if etau.is_str(classes):
        classes = [classes]
    if etau.is_str(attrs):
        attrs = [attrs]
    if seed is not None:
        random.seed(seed)
    (classes_map, _did_download) = _get_classes_map(dataset_dir, download=download)
    classes_map_rev = {v: k for (k, v) in classes_map.items()}
    did_download |= _did_download
    all_classes = sorted(classes_map.values())
    if classes is not None:
        oi_classes = []
        missing_classes = []
        filtered_classes = []
        for c in classes:
            if c in classes_map_rev:
                oi_classes.append(classes_map_rev[c])
                filtered_classes.append(c)
            else:
                missing_classes.append(c)
        classes = filtered_classes
        if missing_classes:
            logger.warning('Ignoring invalid classes %s\nYou can view the available classes via `fiftyone.utils.openimages.get_classes()`', missing_classes)
    else:
        oi_classes = None
    if 'relationships' in _label_types:
        (attrs_map, _did_download) = _get_attrs_map(dataset_dir, download=download)
        attrs_map_rev = {v: k for (k, v) in attrs_map.items()}
        did_download |= _did_download
        all_attrs = sorted(attrs_map.values())
        if attrs is None:
            oi_attrs = [attrs_map_rev[a] for a in all_attrs]
        else:
            oi_attrs = []
            missingAttrs = []
            filtered_attrs = []
            for a in attrs:
                if a in attrs_map_rev:
                    oi_attrs.append(attrs_map_rev[a])
                    filtered_attrs.append(a)
                else:
                    missingAttrs.append(a)
            attrs = filtered_attrs
            if missingAttrs:
                logger.warning('Ignoring invalid attributes %s\nYou can view the available attributes via `fiftyone.utils.openimages.get_attributes()`', missingAttrs)
    else:
        attrs = None
        attrs_map = None
        oi_attrs = None
        all_attrs = None
    if 'segmentations' in _label_types:
        (seg_classes, _did_download) = _get_seg_classes(dataset_dir, classes_map=classes_map, download=download)
        did_download |= _did_download
    else:
        seg_classes = None
    return (classes_map, all_classes, classes, oi_classes, attrs_map, all_attrs, attrs, oi_attrs, seg_classes, did_download)
```


Overlapping Code:
```
se
_label_types = _parse_label_types(label_types)
if etau.is_str(classes):
classes = [classes]
if etau.is_str(attrs):
attrs = [attrs]
if seed is not Nt_dir, download=download)
classes_map_rev = {v: k items()}
did_download |= _did_download
all_classes = sorted(classes_map.values())
if classes is not None:
oi_classes = []
missing_classes = []
filtered_classes = []
for c in classes:
if c in classes_map_rev:
oi_classes.append(classes_map_rev[c])
filtered_classes.append(c)
else:
missing_classes.append(c)
classes = filtered_classes
if missing_classes:
logger.warninattrs_map.items()}
did_download |= _did_download
all_attrs = sorted(attrs_map.values())
if attrs is None:
oi_attrs = [attrs_map_rev[a] for a in all_ated_attrs = []
for a in attrs:
if a in attrs_map_rev:
oi_attrs.append(attrs_map_rev[a])
filtered_attrattrs = None
attrs_map = None
oi_attrs = None
all_set_dir, classes_map=classes_map, download=downloa
```
<Overlap Ratio: 0.46329113924050636>

---

--- 251 --
Question ID: 55c73198735716cc50f10f1745bd41508e18f45d_0
Original Code:
```
def count_verbose_skip(func):

    def decorator(obj, *args, **kw):
        fname = check_parameters(func, args, kw)
        if obj.is_truncated() or obj.is_canceled() or obj.is_aborted():
            return 0
        if obj.testing_syntax:
            func(obj, *args, calc_time=True, **kw)
            return 0
        obj.debug('{} {} {}'.format(fname, args, kw))
        return func(obj, *args, **kw)
    return decorator
```


Overlapping Code:
```
ount_verbose_skip(func):
def decorator(obj, *args, **kw):
fname = check_parameters(func, args, kw)
if obj.is_truncated() or obj.is_canceled() or obj.is_aborted():
return 0
if obj.testing_syntax:
func(ug('{} {} {}'.format(fname, args, kw))
return func
```
<Overlap Ratio: 0.7352941176470589>

---

--- 252 --
Question ID: ae4b7326c41a7e04e0d0c89af9536dff4cc979a0_14
Original Code:
```
def process_ccdlab(output=None, time_list=None, XY_integers=None, XY_fractions=None, flat_list=None, framecount_per_sec=framecount_per_sec):
    """Generate a Curvit compatible events list from CCDLAB files.

    Parameters
    ----------
    output : file path
        The name of the output events list FITS file.
        
    time_list : file path
        The name of the CCDLAB time list FITS file
        
    XY_integers : file path
        The name of the CCDLAB XY integers FITS file
        
    XY_fractions : file path
        The name of the CCDLAB XY fractions FITS file
        
    flat_list : file path
        The name of the CCDLAB flat list FITS file
        
    framecount_per_sec : float, optional
        The framerate of the observation, with a default value of 28.7185
        frames per second for 512 x 512 window mode. 
        The most accurate way to get the framerate would be to take the value 
        of (``1 / INT_TIME``). 
        ``INT_TIME`` value can be found from the corresponding image header. 
        Approximate values of framerate for different window modes of UVIT 
        are given in the table below.

        +---------------+---------------------+
        | window mode   | frames per second   |
        +===============+=====================+
        | 512 x 512     | 28.7                |
        +---------------+---------------------+
        | 350 x 350     | 61                  |
        +---------------+---------------------+
        | 300 x 300     | 82                  |
        +---------------+---------------------+
        | 250 x 250     | 115                 |
        +---------------+---------------------+
        | 200 x 200     | 180                 |
        +---------------+---------------------+
        | 150 x 150     | 300                 |
        +---------------+---------------------+
        | 100 x 100     | 640                 |
        +---------------+---------------------+ 
        

    Note
    ---- 
    It is essential to set the correct value of the framerate. 
    Most UVIT observations are carried out in 512 x 512 window mode.
            
    Warning
    -------
    This function is new; please report if you find any bugs.
        
    Example
    --------
    >>> import curvit
    >>> process_ccdlab(output = 'output_events_list.fits',
    ...                time_list = 'sample_TimeList.fits', 
    ...                XY_integers = 'sample_XYInts_List.fits',
    ...                XY_fractions = 'sample_XYFrac_List.fits',
    ...                flat_list = 'sample_FlatList.fits',
    ...                framecount_per_sec = 28.7185)
    
    The above script will generate a FITS table called ``output_events_list.fits``.
    You may then use it as input to ``curve`` or ``makecurves``. 
    """
    time = fits.open(time_list)[0].data / 1000
    XYFrac = fits.open(XY_fractions)[0].data
    XYInts = fits.open(XY_integers)[0].data
    weight = fits.open(flat_list)[0].data
    photons = weight * framecount_per_sec
    fx = CCDLAB_to_4k(XYInts[:, 0], XYFrac[:, 0])
    fy = CCDLAB_to_4k(XYInts[:, 1], XYFrac[:, 1])
    col1 = fits.Column(name='MJD_L2', format='D', array=time)
    col2 = fits.Column(name='Fx', format='D', array=fx)
    col3 = fits.Column(name='Fy', format='D', array=fy)
    col4 = fits.Column(name='EFFECTIVE_NUM_PHOTONS', format='D', array=photons)
    cols = fits.ColDefs([col1, col2, col3, col4])
    tbhdu = fits.BinTableHDU.from_columns(cols)
    tbhdu.writeto(output, overwrite=True)
    return
```


Overlapping Code:
```
om CCDLAB files.
Parameters
----------
output : file path
The name of the output events list FITS file.

time_list : file path
The name of the CCDLAB time list FITS file

XY_integers : file path
The name of the CCDLAB XY integers FITS file

XY_fractions : file path
The name of the CCDLAB XY fractions FITS file

flat_list : file path
The name of the CCDLAB flat list FITS file

framecount_per_sec : float, optional
The framerate of the observation, with a default value of 28.7185
frames per second for 512 x 512 window mode. 
The most accurate way to get the framerate would be to take the value 
of (``1 / INT_TIME``). 
``INT_TIME`` value can be found from the corresponding image header. 
Approximate values of framerate for different window modes of UVIT 
are given in the table below.
+---------------+---------------------+
| window mode | frames per second |
+===============+=====================+
| 512 x 512 | 28.7 |
+---------------+---------------------+
| 350 x 350 | 61 |
+---------------+---------------------+
| 300 x 300 | 82 |
+---------------+---------------------+
| 250 x 250 | 115 |
+---------------+---------------------+
| 200 x 200 | 180 |
+---------------+---------------------+
| 150 x 150 | 300 |
+---------------+---------------------+
| 100 x 100 | 640 |
+---------------+---------------------+ 

Note
---- 
It is essential to set the correct value of the framerate. 
Most UVIT observations are carried out in 512 x 512 window mode.

Warning
-------
This function is new; please report if you find any bugs.

Example
--------
>>> import curvit
>>> process_ccdlab(output = 'output_events_list.fits',
... time_list = 'sample_TimeList.fits', 
... XY_integers = 'sample_XYI
```
<Overlap Ratio: 0.8881922675026124>

---

--- 253 --
Question ID: 7d9f104ac0e3008ea503327f64672715cc84a452_0
Original Code:
```
def encode_routing_info(r_tags):
    result = bitstring.BitArray()
    for route in r_tags:
        result.append(bitstring.pack('uint:8', len(route)))
        for step in route:
            (pubkey, channel, feebase, feerate, cltv) = step
            result.append(bitstring.BitArray(pubkey) + bitstring.BitArray(channel) + bitstring.pack('intbe:32', feebase) + bitstring.pack('intbe:32', feerate) + bitstring.pack('intbe:16', cltv))
    return result.tobytes()
```


Overlapping Code:
```
ncode_routing_info(r_tags):
result = bitstring.BitArray()
for route in r_tags:
result.append(bitstring.pack('uint:8', len(route)))
for step in route:
step
result.append(bitstring.BitArray(pubkey) + bitstring.BitArray(channel) + bitstring.pack('intbe:32', feebase) + bitstring.pack('intbe:32', feerate) + bitstring.pack('intbe:16', cltv))
return result.tobytes()
```
<Overlap Ratio: 0.8804878048780488>

---

--- 254 --
Question ID: a016e584bf0e1d2da7b3d8766cb1e7cb07b0e46c_1
Original Code:
```
def preprocess(paragraph):
    result = []
    sentences = tokenizer.tokenize(paragraph)
    for sentence in sentences:
        words = nltk.regexp_tokenize(sentence, pattern)
        temp = []
        for word in words:
            to_deal = []
            if camelCase1.match(word) or camelCase2.match(word):
                to_deal = splitCode(word)
            elif upperExtCase.match(word):
                to_deal = splitFinalExt(word)
            else:
                to_deal.append(word)
            for deal in to_deal:
                if not isDelete(deal.lower()):
                    temp.append(stemmer.stem(deal))
        result.append(temp)
    return result
```


Overlapping Code:
```
t = []
sentences = tokenizer.tokenize(paragraph)
for sentence in sentences:
words = nltk.regexp_tokenize(sentence, pattern)
te= []
if camelCase1.match(word) or camelCase2.match(word):= splitCode(word)
elif upperExtCase.match(word):
tte(deal.lower()):
temp.append(stemmer.stem(deal))

```
<Overlap Ratio: 0.5871369294605809>

---

--- 255 --
Question ID: 225b550790ae56458e3be71c37a81107f822f14e_7
Original Code:
```
def find_boost(self):
    global boost_pos
    boostPos = pyAG.locateCenterOnScreen('images/{}.png'.format(self))
    if boostPos == None:
        print('No', self.replace('_', ' '), 'found')
        return False
    else:
        return True
```


Overlapping Code:
```
s = pyAG.locateCenterOnScreen('images/{}.png'.form
```
<Overlap Ratio: 0.24752475247524752>

---

--- 256 --
Question ID: 63b326f4f249f15f3d820d4b7228b3b70a34e6a6_0
Original Code:
```
def write_file(filename, data):
    os.makedirs(os.path.dirname(filename), exist_ok=True)
    with open(filename, 'w+') as f:
        print('writing file %s' % filename)
        f.write(data)
```


Overlapping Code:
```
filename, data):
os.makedirs(os.path.dirname(filename), exist_ok=True)
with open(filename, 'w+') as 
```
<Overlap Ratio: 0.5988023952095808>

---

--- 257 --
Question ID: 67b6579ce4e0d25dfadfeb81d73e475c2f423051_0
Original Code:
```
def millify(n):
    n = float(n)
    millidx = max(0, min(len(millnames) - 1, int(math.floor(0 if n == 0 else math.log10(abs(n)) / 3))))
    return '{:.0f}{}'.format(n / 10 ** (3 * millidx), millnames[millidx])
```


Overlapping Code:
```

n = float(n)
millidx = max(0, min(len(millnames) - 1, int(math.floor(0 if n == 0 else math.log10(abs(n)) / 3))))
return '{:.0f}{}'.format(n / 10 ** (3 * millidx), millnames[millidx])
```
<Overlap Ratio: 0.9242424242424242>

---

--- 258 --
Question ID: e3f7b9dd2486d6d82391b6ab2cce6e07c345cb5c_2
Original Code:
```
def uninitializePlugin(mobject):
    mplugin = OpenMayaMPx.MFnPlugin(mobject)
    try:
        mplugin.deregisterNode(spSimpleSpringNodeId)
    except:
        sys.stderr.write('Failed to deregister node: %s' % kPluginNodeTypeName)
        raise
```


Overlapping Code:
```
f uninitializePlugin(mobject):
mplugin = OpenMayaMPx.MFnPlugin(mobject)
try:
mplugin.deregisterNode(deId)
except:
sys.stderr.write('Failed to deregister node: 
```
<Overlap Ratio: 0.7607655502392344>

---

--- 259 --
Question ID: 67782e299b60e3d6714308f0cda66ce9bb82d1a5_7
Original Code:
```
def get_depths(flows, x, h, roughness=0.01, slope=0.001, conv=1.0, dd=0.0001, verbose=False):
    if isinstance(flows, float):
        flows = np.array([flows], dtype=float)
    if isinstance(roughness, float):
        roughness = np.ones(x.shape, dtype=float) * roughness
    depths = np.zeros(flows.shape, dtype=float)
    for (idx, q) in enumerate(flows):
        depths[idx] = qtodepth(x, h, q, roughness=roughness, slope=slope, conv=conv, dd=dd, verbose=False)
    return depths
```


Overlapping Code:
```
):
if isinstance(flows, float):
flows = np.array([flows], dtype=float)
if isinstance(roughness, float):
roughness = np.ones(x.shape, dtype=float) * roughness
depths = np.zeros(flows.shape, dtype=float
```
<Overlap Ratio: 0.45558086560364464>

---

--- 260 --
Question ID: 6a706ba112e6e0c7b57c1e46bd9b0418402db376_1
Original Code:
```
def draw():
    loadPixels()
    x = 4.0
    y = 0.0
    for i in range(1, 120000, 1):
        x1 = b * y + f(x)
        y = -x + f(x1)
        x = x1
        pixels[350 + int(x * 26) + (280 - int(y * 26)) * width] = color(i % 255, 100, 100)
    updatePixels()
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 261 --
Question ID: 704ba9392622d555589cf12d7af04a6f1811b620_3
Original Code:
```
def energy_plot(scenarios, color_dict):
    """
    """
    layout = go.Layout(barmode='relative', legend_orientation='h', title='Aggregated supply and demand', paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', yaxis=dict(title='Energy in {}'.format('TWh'), titlefont=dict(size=16, color='rgb(107, 107, 107)'), tickfont=dict(size=14, color='rgb(107, 107, 107)')))
    data = []
    for (idx, row) in scenarios.T.iteritems():
        if '-cos' in idx:
            legend = False
        else:
            legend = True
        data.append(go.Bar(x=row.index, y=row.values, text=[v.round(1) if v > 20 or v < -20 else None for v in row.values], hovertext=[', '.join([str(v.round(2)), idx.replace('-cos', '')]) for v in row.values], hoverinfo='text', textposition='auto', showlegend=legend, name=idx, marker=dict(color=color_dict.get(idx.replace('-cos', ''), 'gray'))))
    return {'data': data, 'layout': layout}
```


Overlapping Code:
```
gy_plot(scenarios, color_dict):
"""
"""
layout = g, paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', tickfont=dict(size=14, color='rgb(107, 107, 107)')idx.replace('-cos', ''), 'gray'))))
return {'data'
```
<Overlap Ratio: 0.2511792452830189>

---

--- 262 --
Question ID: bb6e599aba13747a581a01c8843fac9626122356_0
Original Code:
```
def show_image_series(image_series: ImageSeries, neurodata_vis_spec: dict):
    if len(image_series.data.shape) == 3:
        return show_grayscale_image_series(image_series, neurodata_vis_spec)

    def show_image(index=0, mode='rgb'):
        (fig, ax) = plt.subplots(subplot_kw={'xticks': [], 'yticks': []})
        image = image_series.data[index]
        if mode == 'bgr':
            image = image[:, :, ::-1]
        ax.imshow(image.transpose([1, 0, 2]), cmap='gray', aspect='auto')
        fig.show()
        return fig2widget(fig)
    slider = widgets.IntSlider(value=0, min=0, max=image_series.data.shape[0] - 1, orientation='horizontal', continuous_update=False, description='index')
    mode = widgets.Dropdown(options=('rgb', 'bgr'), layout=Layout(width='200px'), description='mode')
    controls = {'index': slider, 'mode': mode}
    outFig = widgets.interactive_output(show_image, controls)
    vbox = widgets.VBox(children=[outFig, slider, mode])
    return vbox
```


Overlapping Code:
```
 show_image_series(image_series: ImageSeries, neurodata_vis_spec: dict):
if len(image_series.data.shape) == 3:
return show_grayscale_image_series(image_series, neurodata_vis_spec plt.subplots(subplot_kw={'xticks': [], 'yticks': []})
image = image_series.data[index]
if mode == 'bgp='gray', aspect='auto')
fig.show()
return fig2widget(fig)
slider = widgets.IntSlider(value=0, min=0='index')
mode = widgets.Dropdown(options=('rgb', 'mode')
controls = {'index': slider, 'mode': mode}widgets.interactive_output(show_image, controls)
v
```
<Overlap Ratio: 0.6043329532497149>

---

--- 263 --
Question ID: ca0dd379bf0cfd2ef3ea5b0e3ce3a98b03b1d3f8_2
Original Code:
```
@api.route('/send_code/<email>', methods=['POST'])
@cross_domain
def send_code(email):
    """
    This endpoint generates a unique code that will be used to allow
    the user to change his/her password. The unique code is send to
    the specified email address.
    """
    from zeeguu.core.emailer.password_reset import send_password_reset_email
    try:
        User.find(email)
    except sqlalchemy.orm.exc.NoResultFound:
        return bad_request('Email unknown')
    code = UniqueCode(email)
    db_session.add(code)
    db_session.commit()
    send_password_reset_email(email, code)
    return 'OK'
```


Overlapping Code:
```
oss_domain
def send_code(email):
"""
This endpoint generates a unique code that will be used to allow
the user to change his/her password. The unique code is send to
the specified email address.
"""
from zeeguu.core.emailer.password_reset import send_password_reset_email
try:
User.find(email)
except sqlalchemy.orm.exc.NoResultFound:
return bad_requ
db_session.add(code)
db_session.commit()
send_password
```
<Overlap Ratio: 0.7486136783733827>

---

--- 264 --
Question ID: 861044681bbdc6a4088c31b9167d9eb267f0536d_45
Original Code:
```
@app.route('/rest/<jobname>/<jobid>/executionduration')
def get_executionduration(jobname, jobid):
    """Get the maximum execution duration of job <jobid>

    Returns:
        200 OK: text/plain: integer number of seconds (on success)
        404 Not Found: Job not found (on NotFoundWarning)
        500 Internal Server Error (on error)
    """
    user = set_user()
    try:
        logger.info('{} {}'.format(jobname, jobid))
        job = Job(jobname, jobid, user)
        response.content_type = 'text/plain; charset=UTF-8'
        return str(job.execution_duration)
    except JobAccessDenied as e:
        abort_403(str(e))
    except storage.NotFoundWarning as e:
        abort_404(str(e))
    except:
        abort_500_except()
```


Overlapping Code:
```
/executionduration')
def get_executionduration(jobname, jobid):
"""Get the maximum execution duration of job <jobid>
Returns:
200 OK: text/plain: integer number of seconds (on success)
404 Not Found: Job not found (on NotFoundWarning)
500 Internal Server Error (on error)
"""
user = set_user()
try:
logger.info('{} {}'.format(jobname, jobid)))
response.content_type = 'text/plain; charset=UTF-8'
return str(job.execution_duration)
except JobAccessDenied as e:
abort_403(str(e))
except storage.NotFoundWarning as e:
abort_404(str(e))
except:
abort_500_except(
```
<Overlap Ratio: 0.8928>

---

--- 265 --
Question ID: 2c2b3fa036cbe03c2fdfc1bafeba98b37b90d378_1
Original Code:
```
def bbox_sample(region, metric):
    """Extract image that lies within region bounding box

    Parameters
    ----------
    region: skimage.RegionProperties
        Region defining pixels within image to analyse
    metric: array-like
        Metric for all pixels in image to be analysed
    """
    indices = bbox_indices(region)
    return metric[indices]
```


Overlapping Code:
```
"Extract image that lies within region bounding box
Parameters
----------
region: skimage.RegionProperties
Region defining pixels within image to analyse
metric: array-like
Metric for all pixels in im
```
<Overlap Ratio: 0.6430868167202572>

---

--- 266 --
Question ID: 2b6b31ac1b8a4e33d35999ea6fa8cea0493f8cb2_9
Original Code:
```
@njit(fastmath=False, cache=True)
def get_mean_curvature(traj_list, num_traj):
    out = np.empty((num_traj,))
    for i in range(num_traj):
        out[i] = np.mean(np.abs(traj_list[i * trajectory_generator.NUM_STEPS:(i + 1) * trajectory_generator.NUM_STEPS, 3]))
    return out
```


Overlapping Code:
```
mpty((num_traj,))
for i in range(num_traj):
out[i]
```
<Overlap Ratio: 0.19305019305019305>

---

--- 267 --
Question ID: 5148fe31f1a672fe0541555158917c8256ff125f_5
Original Code:
```
def test_dataframe_barh(dataframe, with_plotting_backend):
    chart = dataframe.plot.barh()
    spec = chart.to_dict()
    assert spec['mark'] == {'type': 'bar', 'orient': 'horizontal'}
    assert spec['encoding']['y']['field'] == 'index'
    assert spec['encoding']['x']['field'] == 'value'
    assert spec['encoding']['color']['field'] == 'column'
    assert spec['transform'][0]['fold'] == ['x', 'y']
```


Overlapping Code:
```
ataframe, with_plotting_backend):
chart = dataframe.plot.barh()
spec =field'] == 'value'
assert spec['encoding']['color']['field'] == 'column'
assert spec['transform'][0]['fold'] == 
```
<Overlap Ratio: 0.48404255319148937>

---

--- 268 --
Question ID: ac18a96ded8e760d6d2a171c418c6b63db8231ef_1
Original Code:
```
def init_estimators_train(columns, null_value, no_compression=False):
    if no_compression:
        res = [NoCompressionEstimatorTrain(columns, null_value)]
    else:
        res = [NoCompressionEstimatorTrain(columns, null_value), DictEstimatorTrain(columns, null_value, max_dict_size), RleEstimatorTrain(columns, null_value), ForEstimatorTrain(columns, null_value)]
    return res
```


Overlapping Code:
```
_value, no_compression=False):
if no_compression:

```
<Overlap Ratio: 0.14084507042253522>

---

--- 269 --
Question ID: 0629068ef6b33dbfeb46975094295e4a4c07df96_5
Original Code:
```
def which(program):
    """Determines if and where an executable exists on the users path.
    This code was contributed by Jay at http://stackoverflow.com/a/377028
    Args:
        program (str): The name, or path for the program.
    Returns:
        The program or executable.
    """
    import os

    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)
    (fpath, fname) = os.path.split(program)
    if fpath and is_exe(program):
        return program
    else:
        for path in os.environ['PATH'].split(os.pathsep):
            path = path.strip('"')
            exeFile = os.path.join(path, program)
            if is_exe(exeFile):
                return exeFile
    return None
```


Overlapping Code:
```
gram):
"""Determines if and where an executable exists on the users path.
This code was contributed by Jay at http://stackoverflow.com/a/377028
Args:
program (str): The name, or path for the program.
Returns:
The program or executable.
"""
import os
def is_exe(fpath):
return os.path.isfile(fpath) and os.access(fpath, os.X_OK)
(fpath, fname) = os.path.split(program)
if fpath and is_exe(program):
return program
else:
for path in os.environ['PATH'].split(os.pathsep):
path = path.strip('"')
exeFile = os.path.join(path, program)
if 
```
<Overlap Ratio: 0.9049235993208828>

---

--- 270 --
Question ID: 12f9436289446182577ceaab3eda30ea64c2e38b_7
Original Code:
```
def upscale2d_conv2d(x, fmaps, kernel, gain=np.sqrt(2), use_wscale=False):
    assert kernel >= 1 and kernel % 2 == 1
    w = get_weight([kernel, kernel, fmaps, x.shape[1].value], gain=gain, use_wscale=use_wscale, fan_in=kernel ** 2 * x.shape[1].value)
    w = tf.pad(w, [[1, 1], [1, 1], [0, 0], [0, 0]], mode='CONSTANT')
    w = tf.add_n([w[1:, 1:], w[:-1, 1:], w[1:, :-1], w[:-1, :-1]])
    w = tf.cast(w, x.dtype)
    os = [tf.shape(x)[0], fmaps, x.shape[2] * 2, x.shape[3] * 2]
    return tf.nn.conv2d_transpose(x, w, os, strides=[1, 1, 2, 2], padding='SAME', data_format='NCHW')
```


Overlapping Code:
```
v2d(x, fmaps, kernel, gain=np.sqrt(2), use_wscale=False):
assert kernel >= 1 and kernel % 2 == 1
w = get_weight([kernel, kernel, fmaps, x.shape[1].value], gain=gain, use_wsca [[1, 1], [1, 1], [0, 0], [0, 0]], mode='CONSTANT')
w = tf.add_n([w[1:, 1:], w[:-1, 1:], w[1:, :-1], w[:-1, :-1]])
w = tf.cast(w, x.dtype)
os = [tf.shape(x)[0], fmaps, x.shape[2] * 2, x.shape[3] * 2]
return tf.nn.conv2d_transpose(x, w, os,des=[1, 1, 2, 2], padding='SAME', data_format='NCH
```
<Overlap Ratio: 0.8342342342342343>

---

--- 271 --
Question ID: 5306ddb4712ea725043386b81d8c897bbc57d019_0
Original Code:
```
def get_first_pos(vcf):
    p = {}
    for line in file_util.gzopen(vcf):
        line = file_util.decodeb(line)
        if line[0] != '#':
            arr = line.split('\t')
            print(arr)
            p['chrom'] = arr[0]
            p['spos'] = int(arr[1])
            p['epos'] = int(arr[1])
            p['str'] = p['chrom'] + ':' + str(p['spos']) + '-' + str(p['epos'])
    return p
```


Overlapping Code:
```
 {}
for line in file_util.gzopen(vcf):
line = file_util.decodeb(line)
if line[0] != '#':
arr = line.split('\t')
print(arr)
p['chrom'] = arr[0]
p['spos'] = int(arr[1])
p['epos'] = int(arr[1])
p['str'] = p['chrom'] + ':' + str(p['spos']) + '-' + str(p[
```
<Overlap Ratio: 0.8503401360544217>

---

--- 272 --
Question ID: 427cceb85af895991c1b9f9596f2e1bb0c5b7263_16
Original Code:
```
def deprecated(version, reason):

    def decorator_deprecated(fn):

        @wraps(fn)
        def wrapper_deprecated(*args, **kwds):
            warnings.warn(f'Deprecated since {version}. The reason: {reason}', category=DeprecationWarning)
            return fn(*args, **kwds)
        return wrapper_deprecated
    return decorator_deprecated
```


Overlapping Code:
```
son):
def decorator_deprecated(fn):
@wraps(fn)
def wrapper_deprecated(*args, **kwds):
warnings.warn(f'Deprecated since {version}. The reason: {reason}', category=DeprecationWarning)
return fn(*args, **kwds)
return wrapper_deprecated
return decorator_
```
<Overlap Ratio: 0.8710801393728222>

---

--- 273 --
Question ID: 208074ab27944df3955e997903e9acaee5afdb6b_0
Original Code:
```
@pytest.fixture
def rus_player_json():
    """Expected JSON for rus_player model-fixture"""
    return {'name': 'Rus', 'id_': 'PjBYO_8gbf'}
```


Overlapping Code:
```
f rus_player_json():
"""Expected JSON for rus_play
```
<Overlap Ratio: 0.3816793893129771>

---

--- 274 --
Question ID: 2c502e5877d8fa61f6c9c0acfe9451fb744aa183_0
Original Code:
```
def create_table(name):
    name = name.title()
    name = name.split()
    name = ''.join(name)
    with sqlite3.connect('supplies.db') as conn:
        cur = conn.cursor()
        cur.execute(f'CREATE TABLE IF NOT EXISTS {name} (Item TEXT, Part Number TEXT, Description TEXT, Vendor TEXT, Price REAL, QOH INT, QNeed INT, Ordering TEXT, Ordered DATE)')
```


Overlapping Code:
```
name = ''.join(name)
with sqlite3.connect('supplies.db') as conn:
cur = conn.cursor()
cur.execute(f'CREATE TABLE IF NOT EXISTS {name} (Item TEXT, Part Number TEXT, Description TEXT, Vendor TEXT, Price REAL, QOH INT, QNeed INT, Ordering TEXT, Ordered 
```
<Overlap Ratio: 0.778816199376947>

---

--- 275 --
Question ID: 5b2a8ea69b3198b3f678cebb3485c95da3b6d811_2
Original Code:
```
def _graph_from_dict(P, weights=False):
    G = pairDiGraph()
    for ((a, b), n) in P.items():
        if weights:
            G.add_edge(a, b, weight=n)
        else:
            G.add_edge(a, b)
    if weights:
        G.addPd()
    return G
```


Overlapping Code:
```
eights:
G.add_edge(a, b, weight=n)
else:
G.add_edge(a, b)
if weights:

```
<Overlap Ratio: 0.3888888888888889>

---

--- 276 --
Question ID: 2c730cc2f3073d60e2b37cd3db6bc2590e864582_0
Original Code:
```
def parse_args():
    parser = argparse.ArgumentParser(description='Train a network with Detectron')
    parser.add_argument('--cfg', dest='cfg_file', help='Config file for training (and optionally testing)', default=None, type=str)
    parser.add_argument('--multi-gpu-testing', dest='multi_gpu_testing', help='Use cfg.NUM_GPUS GPUs for inference', action='store_true')
    parser.add_argument('--skip-test', dest='skip_test', help='Do not test the final model', action='store_true')
    parser.add_argument('opts', help='See detectron/core/config.py for all options', default=None, nargs=argparse.REMAINDER)
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)
    return parser.parse_args()
```


Overlapping Code:
```
def parse_args():
parser = argparse.ArgumentParser(description='Train a networ)
parser.add_argument('--cfg', dest='cfg_file', help='Config file for training (and optionally testing)', default=None, type=str)
parser.add_argument('--mnference', action='store_true')
parser.add_argument('--skip-model', action='store_true')
parser.add_argument('opts', or all options', default=None, nargs=argparse.REMAINDER)
if len(sys.argv) == 1:
parser.print_help()
sys.exit(1)
return parser.parse_args()
```
<Overlap Ratio: 0.7257824143070045>

---

--- 277 --
Question ID: 01415ebda64b25b4823eab1699f9886d6bb0651b_3
Original Code:
```
def get_buildings_in_radius(poly: Polygon, radius: float, excluded_poly: Polygon=None) -> List[Polygon]:
    """
    Get all buildings within $radius
    Args:
        poly: polygon to intersect the buildings in
        radius: radius from within we will retrieve all buildings
        excluded_poly: optional polygon to exclude from the nearest

    Returns:
        A Geoseries with all the polygons of the buildings
    """
    eng = get_connection('POSTGRES')
    if excluded_poly is not None:
        excludedSql = f"AND ST_INTERSECTS(way, ST_GEOMFROMTEXT('{excluded_poly.wkt}', 4326))=FALSE"
    else:
        excludedSql = ''
    query = f"\n        SELECT st_astext(way) as geom FROM (\n            SELECT way\n            FROM {OSM_POLYGON_TABLE}\n            WHERE {BUILDING}\n                  {excludedSql}\n                  AND ST_DWithin(way, ST_GEOMFROMTEXT('{poly.wkt}', 4326), {radius}, true)\n            ) t\n        "
    df = get_df(query, eng)
    eng.dispose()
    gs = [wkt.loads(geom) for geom in df['geom'].unique()]
    return gs
```


Overlapping Code:
```
gs_in_radius(poly: Polygon, radius: float, excluded_poly: Polygon=None) -> List[Polygon]:
"""
Get all buildings within $radius
Args:
poly: polygon to intersect the buildings in
radius: radius from within we will retrieve all buildings
excluded_poly: optional polygon to exclude from the nearest
Returns:
A Geoseries with all the polygons of the buildings
"""
eng = get_connection('POSTGRES')
if excluded_poly is not NoneRSECTS(way, ST_GEOMFROMTEXT('{excluded_poly.wkt}', 4326))=FALSE"
else:ithin(way, ST_GEOMFROMTEXT('{poly.wkt}', 4326), {r)
eng.dispose()
gs = [wkt.loads(geom) for geom in df['ge
```
<Overlap Ratio: 0.6898148148148148>

---

--- 278 --
Question ID: 0ea7da24a0926bef44f6a6ab9c0f2b679c6306d1_2
Original Code:
```
def get_corner_loss_lidar(pred_bbox3d, gt_bbox3d):
    """
    :param pred_bbox3d: (N, 7)
    :param gt_bbox3d: (N, 7)
    :return: corner_loss: (N)
    """
    assert pred_bbox3d.shape[0] == gt_bbox3d.shape[0]
    pred_box_corners = box_torch_ops.center_to_corner_box3d(pred_bbox3d[:, 0:3], pred_bbox3d[:, 3:6], pred_bbox3d[:, 6], [0.5, 0.5, 0], axis=2)
    gt_box_corners = box_torch_ops.center_to_corner_box3d(gt_bbox3d[:, 0:3], gt_bbox3d[:, 3:6], gt_bbox3d[:, 6], [0.5, 0.5, 0], axis=2)
    gt_bbox3d_flip = gt_bbox3d.clone()
    gt_bbox3d_flip[:, 6] += np.pi
    gtBoxCornersFlip = box_torch_ops.center_to_corner_box3d(gt_bbox3d_flip[:, 0:3], gt_bbox3d_flip[:, 3:6], gt_bbox3d_flip[:, 6], [0.5, 0.5, 0], axis=2)
    corner_dist = torch.min(torch.norm(pred_box_corners - gt_box_corners, dim=2), torch.norm(pred_box_corners - gtBoxCornersFlip, dim=2))
    corner_loss = huber_loss(corner_dist, delta=1.0)
    return corner_loss.mean(dim=1)
```


Overlapping Code:
```
d):
"""
:param pred_bbox3d: (N, 7)
:param gt_bbox3d: (N, 7)
:return: corner_loss: (N)
"""
assert pred_bbox3d.shape[0] == gt_bbox3d.shape[0]
pred_box_corners = box_torch_ops.center_to_corner_box3d(d_bbox3d[:, 0:3], pred_bbox3d[:, 3:6], pred_bbox3d[:, 6], [0.5, 0.5, 0], axis=2)
gt_box_corners = box_torch_ops.center_to_corner_box3d(:3], gt_bbox3d[:, 3:6], gt_bbox3d[:, 6], [0.5, 0.5, 0], axis=2)
gt_bbox3d_flip = gt_bbox3d.clone()
gt_bbox3d_flip[:, 6] += np.pi
lip[:, 0:3], gt_bbox3d_flip[:, 3:6], gt_bbox3d_flip[:, 6], [0.5, 0.5, 0], axis=2)
corner_dist = torch.min(torch.norm(pred_box_corners - gt_box_corners, dim=2),
```
<Overlap Ratio: 0.698645598194131>

---

--- 279 --
Question ID: 605df9b62c38bf133d0aa401619574d4bb7f6839_16
Original Code:
```
def get_position(fallback=defaults.CURSOR_POS_FALLBACK):
    """ Return the current column number of the terminal cursor.
        Used to figure out if we need to print an extra newline.

        Returns:
            tuple(int): (x, y) | (,)  - empty, if an error occurred.
    """
    values = fallback
    try:
        with TermStack() as fd:
            termios.tcflush(fd, termios.TCIFLUSH)
            tty.setcbreak(fd, termios.TCSANOW)
            sys.stdout.write(CSI + '6n')
            sys.stdout.flush()
            log.debug('about to read get_position response…')
            resp = _read_until_select(max_bytes=10, end='R')
    except AttributeError:
        return values
    resp = resp.lstrip(CSI)
    try:
        values = tuple((int(token) for token in resp.partition(';')[::-2]))
    except (ValueError, IndexError) as err:
        log.error('parse error: %s on %r', err, resp)
    return values
```


Overlapping Code:
```
he current column number of the terminal cursor.
Used to figure out if we need to print an extra newline.
Returns:
tuple(int): (x, y) | (,) - empty, i:
with TermStack() as fd:
termios.tcflush(fd, termios.TCIFLUSHlog.debug('about to read get_position response…')
resp = _read_until_select(max_bytes=10, end='R')
eError) as err:
log.error('parse error: %s on %r', 
```
<Overlap Ratio: 0.48655913978494625>

---

--- 280 --
Question ID: 5ee4210df799d29db459911536ee02f9a5a1fd24_1
Original Code:
```
def readlines(file):
    with open(file) as f:
        content = f.readlines()
    return [x.strip() for x in content]
```


Overlapping Code:
```
e):
with open(file) as f:
content = f.readlines()
return [x.strip() for x in content]
```
<Overlap Ratio: 0.8333333333333334>

---

--- 281 --
Question ID: 12e6a066caf160f30a66f07074f6d4b7810f6f9d_0
Original Code:
```
def motion(pin):
    print('Bewegung erkannt')
    with picamera.PiCamera() as camera:
        for filename in camera.capture_continuous('/home/pi/Desktop/Fotos/{timestamp:%d.%m_%H-%M-%S}Uhr.jpg'):
            print('Captured %s' % filename)
            break
```


Overlapping Code:
```
with picamera.PiCamera() as camera:
for filename in camera.capture_continuous('/home/pi/Desktop/Fotos/{timestamp:%d.%m_%H-%M-%S}Uhr.jpg'):
print
```
<Overlap Ratio: 0.6575342465753424>

---

--- 282 --
Question ID: 971e98315817be02de95647ef3faaea39f4b2047_6
Original Code:
```
@export
def tlv_pack(*args):
    if len(args) == 2:
        tlv = {'type': args[0], 'value': args[1]}
    else:
        tlv = args[0]
    data = ''
    if tlv['type'] & TLV_META_TYPE_UINT == TLV_META_TYPE_UINT:
        data = struct.pack('>III', 12, tlv['type'], tlv['value'])
    elif tlv['type'] & TLV_META_TYPE_QWORD == TLV_META_TYPE_QWORD:
        data = struct.pack('>IIQ', 16, tlv['type'], tlv['value'])
    elif tlv['type'] & TLV_META_TYPE_BOOL == TLV_META_TYPE_BOOL:
        data = struct.pack('>II', 9, tlv['type']) + bytes(chr(int(bool(tlv['value']))), 'UTF-8')
    else:
        value = tlv['value']
        if sys.version_info[0] < 3 and value.__class__.__name__ == 'unicode':
            value = value.encode('UTF-8')
        elif not is_bytes(value):
            value = bytes(value, 'UTF-8')
        if tlv['type'] & TLV_META_TYPE_STRING == TLV_META_TYPE_STRING:
            data = struct.pack('>II', 8 + len(value) + 1, tlv['type']) + value + NULL_BYTE
        elif tlv['type'] & TLV_META_TYPE_RAW == TLV_META_TYPE_RAW:
            data = struct.pack('>II', 8 + len(value), tlv['type']) + value
        elif tlv['type'] & TLV_META_TYPE_GROUP == TLV_META_TYPE_GROUP:
            data = struct.pack('>II', 8 + len(value), tlv['type']) + value
        elif tlv['type'] & TLV_META_TYPE_COMPLEX == TLV_META_TYPE_COMPLEX:
            data = struct.pack('>II', 8 + len(value), tlv['type']) + value
    return data
```


Overlapping Code:
```
rt
def tlv_pack(*args):
if len(args) == 2:
tlv = {'type': args[0], 'value': aTA_TYPE_UINT:
data = struct.pack('>III', 12, tlv['type'], tlv['value'])
ETA_TYPE_QWORD:
data = struct.pack('>IIQ', 16, tlv['type'], tlv['value'])
elif E_BOOL:
data = struct.pack('>II', 9, tlv['type']) + bytes(chr(int(bool(tlv['value']))), 'UTF-8')
else:
value = tlv['value']
if sys.version_info[0] < 3 and value.__class__.__name__ == 'unicode':
value = value.encode('UTF-8')
elif not is_bytes(value):
value = bytes(value, 'UTF-8')
i= TLV_META_TYPE_STRING:
data = struct.pack('>II', 8 + len(value) + 1, tlv['type']) + value + NULL_BYTE
ETA_TYPE_RAW:
data = struct.pack('>II', 8 + len(value), tlv['type']) + value
elif _TYPE_GROUP:
data = struct.pack('>II', 8 + len(value), tlv['type']) + value
elif  TLV_META_TYPE_COMPLEX:
data = struct.pack('>II', 8 + len(value), tlv['type']) + valu
```
<Overlap Ratio: 0.7037643207855974>

---

--- 283 --
Question ID: 83e9ee54f5b91fb9bed39ac8b9254bc4e100e0bc_3
Original Code:
```
def vector_valued_monomial_basis_fn(nu, i, n):
    """
    Generate a vector valued monomial basis polynomial :math:`p_{\\nu, i}` in the space
    :math:`\\mathcal{P}_r(\\mathbb{R}^m, \\mathbb{R}^n)`, where :math:`r = |\\nu|` and m is equal to the length of nu.

    The vector valued basis polynomial is generated by specifying a scalar valued basis polynomial and the component
    of the vector valued basis polynomial that should be equal to the scalar valued basis polynomial. All other
    components of the vector valued basis polynomial will be zero, i.e.

    .. math:: p_{\\nu, i}^j (x) = \\begin{cases} p_{\\nu} (x), & i = j \\\\ 0, & \\text{else} \\end{cases}.

    :param nu: Multi-index indicating which scalar valued monomial basis polynomial should be generated for the
        non-zero component.
    :type nu: int or :class:`~polynomials_on_simplices.algebra.multiindex.MultiIndex` or Tuple[int, ...]
    :param int i: Index of the vector component that is non-zero.
    :param int n: Dimension of the target.
    :return: The monomial base polynomial as specified by nu, r, i and n.
    :rtype: :class:`Polynomial`.

    .. rubric:: Examples

    >>> import sympy as sp
    >>> x1, x2 = sp.symbols('x1 x2')
    >>> vector_valued_monomial_basis_fn(0, 0, 2)(x1)
    array([1, 0])
    >>> vector_valued_monomial_basis_fn(1, 1, 2)(x1)
    array([0, x1], dtype=object)
    >>> vector_valued_monomial_basis_fn((1, 0), 0, 2)((x1, x2))
    array([x1, 0], dtype=object)
    >>> vector_valued_monomial_basis_fn((1, 1), 1, 3)((x1, x2))
    array([0, x1*x2, 0], dtype=object)
    """
    if n == 1:
        assert i == 0
        return monomial_basis_fn(nu)
    assert i >= 0
    assert i < n
    try:
        m = len(nu)
    except TypeError:
        m = 1
    if not isinstance(nu, multiindex.MultiIndex):
        nu = multiindex.MultiIndex(nu)
    r = multiindex.norm(nu)
    dim = get_dimension(r, m)
    coeff = np.zeros((dim, n), dtype=int)
    j = multiindex.get_index(nu, r)
    coeff[j][i] = 1
    return Polynomial(coeff, r, m)
```


Overlapping Code:
```
nerate a vector valued monomial basis polynomial :\nu|` and m is equal to the length of nu.
The vector valued basis polynomial is generated by specifying a scalar valued basis polynomial and the component
of the vector valued basis polynomial that should be equal to the scalar valued basis polynomial. All other
components of the vector valued basis polynomial will be zero, i.e.
.. math:: indicating which scalar valued monomial basis polynomial should be generated for the
non-zero component.
:type nu: int or :class:`~polynomials_on_simplices.algebra.multiindex.MultiIndex` or Tuple[int, ...]
:param int i: Index of the vector component that is non-zero.
:param int n: Dimension of the target.
:return: The monomial base polynomial as specified by nu, r, i and n.
:rtype: :class:`Polynomial`.
.. rubric:: Examples
>>> import sympy as sp
>>> x1, x2 = sp.symbols('x1 x2')
>>> vector_valued_monomial_basis_fn(0, 0, 2)(x1)
array([1, 0])
>>> vector_valued_monomial_basis_fn(1, 1, 2)(x1)
array([0, x1], dtype=object)
>>> vector_valued_monomial_basis_fn((1, 0), 0, 2)((x1, x2))
array([x1, 0], dtype=object)
>>> vector_valued_monomial_basis_fn((1, 1), 1, 3)((x1, x2))
array([0, x1*x2, 0], dtype=object)
"""
if n == 1:
assert i == 0
return monomial_basis_fn(nu)
assert i >= 0
assert i < n
try:
m = len(nu)
except TypeError:
m = 1
if not isinstance(nu, multiindex.MultiIndex):
nu = multiindex.MultiIndex(nu)
r = multiindex.norm(nu)
dim = get_dimension(r, m)
coeff = np.zeros((dim, n), dtype=int)
j = multiindex.get_index(nu, r)
coeff[j][i] = 1
return 
```
<Overlap Ratio: 0.8383071079761258>

---

--- 284 --
Question ID: 6bd2ed2c7bff37b5c4b35bd8f9b870bb8d243202_7
Original Code:
```
def main(argv=None):
    """Main entrance into app.  Setup logging, create App, and enter main loop
    """
    global DEBUG
    args = process_command_line(argv)
    if args.debug:
        DEBUG = True
        logLevel = logging.DEBUG
    else:
        logLevel = logging.INFO
    if another_instance_running(args.srcfiles):
        print('Another instance of Marcam is already running.  Exiting.')
        return 1
    if (const.USER_CONFIG_DIR / 'debug').exists():
        DEBUG = True
        logLevel = logging.DEBUG
    logging_setup(logLevel)
    sys.stderr = marcam_extra.StderrToLog()
    log_debug_main()
    LOGGER.info(repr(args))
    sanity_checks()
    myapp = MarcamApp(args.srcfiles)
    myapp.MainLoop()
    return 0
```


Overlapping Code:
```
""Main entrance into app. Setup logging, create ApUSER_CONFIG_DIR / 'debug').exists():
DEBUG = True

```
<Overlap Ratio: 0.16366612111292964>

---

--- 285 --
Question ID: 3ee5df8aa3ce8621360bf2c27434ac72151c3d37_1
Original Code:
```
def context_geo(key, values, dataset, namecount):
    geoname = '"' + key + '"'
    spar2 = '\n    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n    PREFIX gndo: <http://d-nb.info/standards/elementset/gnd#>\n    PREFIX pro: <http://purl.org/hpi/patchr#>\n    PREFIX owl: <http://www.w3.org/2002/07/owl#>\n    PREFIX edm: <http://www.europeana.eu/schemas/edm/>\n    PREFIX dc: <http://purl.org/dc/elements/1.1/>\n    PREFIX foaf: <http://xmlns.com/foaf/0.1/>\n    PREFIX skos: <http://www.w3.org/2004/02/skos/core#>\n    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n    PREFIX dblp: <http://dblp.org/rdf/schema-2015-01-26#>\n    PREFIX dcterms: <http://purl.org/dc/terms/>\n    PREFIX bibtex: <http://data.bibbase.org/ontology/#>\n    PREFIX geo: <http://www.opengis.net/ont/geosparql#>\n\n        select ?x  (group_concat(?alt; SEPARATOR=", ") as ?altname) (group_concat(?sameas; SEPARATOR=", ") as ?same)\n\n        WHERE{{\n\n          graph <http://maral.wisslab.org/graphs/gnd> {{\n\n\n            \t?x (gndo:preferredNameForThePlaceOrGeographicName | gndo:variantNameForThePlaceOrGeographicName){0}.\n                optional {{?x gndo:variantNameForThePlaceOrGeographicName ?alt.}}\n                optional {{?x owl:sameAs ?sameas.}}\n               # ?x geo:hasGeometry ?geo.\n               # optional {{?geo geo:asWKT ?coo}}\n          }}\n          }} group by ?x\n\n        '.format(geoname)
    sparql.setQuery(spar2)
    sparql.setReturnFormat(XML)
    results = sparql.query().convert()
    for i in range(0, len(results.bindings)):
        uri = 'https://data.jhn.ngo/spatial/' + str(dataset) + '/' + str(namecount)
        graph.add((URIRef(uri), RDF.type, edm.Place))
        for z in range(0, len(values)):
            graph.add((URIRef(uri), edm.identifier, Literal(values[z])))
        graph.add((URIRef(uri), skos.prefLabel, Literal(key)))
        if 'altname' in results.bindings[i].keys():
            count1 = results.bindings[i]['altname'].value.count(',')
            if count1 > 0:
                for j in range(0, count1 + 1):
                    graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value.rsplit(', ', count1)[count1 - j])))
            else:
                graph.add((URIRef(uri), skos.altLabel, Literal(results.bindings[i]['altname'].value)))
        if 'same' in results.bindings[i].keys():
            count2 = results.bindings[i]['same'].value.count(',')
            if count2 > 0:
                for j in range(0, count2 + 1):
                    graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value.rsplit(', ', count2)[count2 - j])))
            else:
                graph.add((URIRef(uri), owl.sameAs, Literal(results.bindings[i]['same'].value)))
    graph.serialize(destination=dataset + '_Spatial_01.ttl', format='turtle')
```


Overlapping Code:
```
n PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n PREFIX gndo: <http://d-nb.info/standards/elementset/gnd#>#>\n PREFIX owl: <http://www.w3.org/2002/07/owl#>\PREFIX edm: <http://www.europeana.eu/schemas/edm/>.1/>\n PREFIX skos: <http://www.w3.org/2004/02/skos/core#>\n PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n PREFIX dblp: <http://dblp.org/rdf/schema-2015-01-26#REFIX bibtex: <http://data.bibbase.org/ontology/#>PREFIX geo: <http://www.opengis.net/ont/geosparql#>\nup_concat(?alt; SEPARATOR=", ") as ?altname) (groux (gndo:preferredNameForThePlaceOrGeographicName |optional {{?x gndo:variantNameForThePlaceOrGeograp)
sparql.setQuery(spar2)
sparql.setReturnFormat(XML)
results = sparql.query().convert()
for i in ranin results.bindings[i].keys():
count1 = results.bie' in results.bindings[i].keys():
count2 = results
```
<Overlap Ratio: 0.39436619718309857>

---

--- 286 --
Question ID: 00500ee126bf98712c024187bb2a8536d5e82f46_0
Original Code:
```
@login_required
def productlist(request):
    organization = request.user.info.organization
    if not hasattr(request.user, 'organization'):
        if not hasattr(request.user, 'permissions'):
            return HttpResponseForbidden('<h1>403 Forbidden</h1>')
        if request.user.permissions.product_permissions < 1:
            return HttpResponseForbidden('<h1>403 Forbidden</h1>')
    products = Product.objects.filter(organization=organization).order_by('-id').annotate(earmarked=Sum('salesinvoiceentry__quantity', filter=Q(salesinvoiceentry__invoice__finalized=0)))
    productfilter = ProductFilter(request.GET, queryset=products)
    paginator = Paginator(productfilter.qs, 25)
    page_number = request.GET.get('page')
    pageObj = paginator.get_page(page_number)
    context = {'page_obj': pageObj, 'filter': productfilter}
    return render(request, 'products/product_list.html', context=context)
```


Overlapping Code:
```
roductlist(request):
organization = request.user.iganization'):
if not hasattr(request.user, 'permis):
return HttpResponseForbidden('<h1>403 Forbidden<:
return HttpResponseForbidden('<h1>403 Forbidden<.objects.filter(organization=organization).order_by('-id').annotate(earmarked=ty', filter=Q(salesinvoiceentry__invoice__finalized=0)))
productfilter = ProductFilter(request.GET, queryset=products)
paginator = Paginator(productfilter.qs, 25)
page_number = request.GET.get('page')
pageObj = paginator.get_page(page_number)
context = {'page_obj': pa
return render(request, 'products/product_list.html', co
```
<Overlap Ratio: 0.7204301075268817>

---

--- 287 --
Question ID: 04feed9797eeb64fb97ec419811711f467958210_1
Original Code:
```
def get_marks(cos_scores, max_marks, bias):
    max_cos_score = max(cos_scores)
    marksObtained = max([(max_cos_score - bias[0]) / (1 - bias[0]) * max_marks if max_cos_score < bias[1] else max_marks, 0])
    return marksObtained
```


Overlapping Code:
```
max_marks, bias):
max_cos_score = max(cos_scores)

```
<Overlap Ratio: 0.22935779816513763>

---

--- 288 --
Question ID: 6e4206da9fd80226e539745dda7d6ae8f2010e3a_150
Original Code:
```
@card('Pacifism')
def pacifism(card, abilities):

    def pacifism():
        return AbilityNotImplemented

    def pacifism():
        return AbilityNotImplemented
    return (pacifism, pacifism)
```


Overlapping Code:
```
 pacifism(card, abilities):
def pacifism():
return AbilityNotImplemented
def pacifism():
return Abil
```
<Overlap Ratio: 0.6024096385542169>

---

--- 289 --
Question ID: 58f3964892634b3c801b485b006283a9cc644941_1
Original Code:
```
def test_vertex_merger_vertices():
    merger = MeshVertexMerger()
    merger.add_vertices([(1, 2, 3), (4, 5, 6)])
    merger.add_vertices([(1, 2, 3), (4, 5, 6)])
    assert merger.vertices == [(1, 2, 3), (4, 5, 6)]
```


Overlapping Code:
```
MeshVertexMerger()
merger.add_vertices([(1, 2, 3), (4, 5, 6)])
merger.add_vertices([(1, 2, 3), (4, 5, 6)])
assert merger.vertices == [(1, 2, 3), (4, 5
```
<Overlap Ratio: 0.7537688442211056>

---

--- 290 --
Question ID: 40c216bc802b50376ba5e2720ccd9e0872685eb7_0
Original Code:
```
def parse_args():
    global args
    parser = argparse.ArgumentParser(description='Reset RFID Reader')
    parser.add_argument('host', help='hostname or IP address of RFID reader', nargs='+')
    parser.add_argument('-p', '--port', default=llrp.LLRP_PORT, help='port to connect to (default {})'.format(llrp.LLRP_PORT))
    parser.add_argument('-d', '--debug', action='store_true', help='show debugging output')
    args = parser.parse_args()
```


Overlapping Code:
```
def parse_args():
global args
parser = argparse.ArgumentParser(description='Reset RFID Reader')
parser.add_argument('host', help='hostname or IP address of RFID reader', nargs='+')
parser.add_argument('-p', '--port', default=llrp.LLRP_PORT,ct to (default {})'.format(llrp.LLRP_PORT))
parser.add_argument('-d', '--debug', action='store_true', help='show debug
```
<Overlap Ratio: 0.8564593301435407>

---

--- 291 --
Question ID: 81170dea07b0b06f634847b4f0645d72a042dbbb_7
Original Code:
```
def test_laser_timing_delay(lxt):
    """
    Check basic moves are getting to the fs_tgt_time signal.

    That signal's value is off by 10e9 for the ns to s conversion
    and negative due to the convention that positive lxt means earlier laser.
    """
    logger.debug('test_laser_timing_delay')
    assert lxt.wm() == 0
    assert lxt._fs_tgt_time.get() == -0
    lxt.mv(1e-06)
    assert lxt.wm() == 1e-06
    assert lxt._fs_tgt_time.get() == pytest.approx(-1000)
    lxt.mv(-5e-06)
    assert lxt.wm() == -5e-06
    assert lxt._fs_tgt_time.get() == pytest.approx(5000)
```


Overlapping Code:
```
ef test_laser_timing_delay(lxt):
"""
Check basic moves are getting to the fs_tgt_time signal.
That signal's value is off by 10e9 for the ns to s conversion
and negative due to the convention that positive lxt means earlier laser.
"""
logger.debug('test_laser_timing_delay')
assert lxt.wm() == 0
asser
```
<Overlap Ratio: 0.5791505791505791>

---

--- 292 --
Question ID: 10296073b3cc74d61d9da67e57a17da208e30b41_1
Original Code:
```
def corrSpin2(ra, dec, g1a, g2a, g1b=None, g2b=None, raUnits='degrees', decUnits='degrees', **treecorrKwargs):
    """Function to compute correlations between at most two shear-like fields.
    This is used to compute Rho statistics, given the appropriate spin-2
    (shear-like) fields.
    Parameters
    ----------
    ra : `numpy.array`
        The right ascension values of entries in the catalog.
    dec : `numpy.array`
        The declination values of entries in the catalog.
    g1a : `numpy.array`
        The first component of the primary shear-like field.
    g2a : `numpy.array`
        The second component of the primary shear-like field.
    g1b : `numpy.array`, optional
        The first component of the secondary shear-like field.
        Autocorrelation of the primary field is computed if `None` (default).
    g2b : `numpy.array`, optional
        The second component of the secondary shear-like field.
        Autocorrelation of the primary field is computed if `None` (default).
    raUnits : `str`, optional
        Unit of the right ascension values.
        Valid options are "degrees", "arcmin", "arcsec", "hours" or "radians".
    decUnits : `str`, optional
        Unit of the declination values.
        Valid options are "degrees", "arcmin", "arcsec", "hours" or "radians".
    **treecorrKwargs
        Keyword arguments to be passed to `treecorr.GGCorrelation`.
    Returns
    -------
    xy : `treecorr.GGCorrelation`
        A `treecorr.GGCorrelation` object containing the correlation function.
    """
    xy = treecorr.GGCorrelation(**treecorrKwargs)
    cat_a = treecorr.Catalog(ra=ra, dec=dec, g1=g1a, g2=g2a, ra_units=raUnits, dec_units=decUnits)
    if g1b is None or g2b is None:
        xy.process(cat_a)
    else:
        cat_b = treecorr.Catalog(ra=ra, dec=dec, g1=g1b, g2=g2b, ra_units=raUnits, dec_units=decUnits)
        xy.process(cat_a, cat_b)
    return xy
```


Overlapping Code:
```
ion to compute correlations between at most two shear-like fields.
This is used to compute Rho statistics, given the appropriate spin-2
(shear-like) fields.
Parameters
----------
ra : `numpy.array`
The right ascension values of entries in the catalog.
dec : `numpy.array`
The declination values of entries in the catalog.
g1a : `numpy.array`
The first component of the primary shear-like field.
g2a : `numpy.array`
The second component of the primary shear-like field.
g1b : `numpy.array`, optional
The first component of the secondary shear-like field.
Autocorrelation of the primary field is computed if `None` (default).
g2b : `numpy.array`, optional
The second component of the secondary shear-like field.
Autocorrelation of the primary field is computed if `None` (default).
raUnits : `str`, optional
Unit of the right ascension values.
Valid options are "degrees", "arcmin", "arcsec", "hours" or "radians".
decUnits : `str`, optional
Unit of the declination values.
Valid options are "degrees", "arcmin", "arcsec", "hours" or "radians".
**treecorrKwargs
Keyword arguments to be passed to `treecorr.GGCorrelation`.
Returns
-------
xy : `treecorr.GGCorrelation`
A `treecorr.GGCorrelation` object containing the correlation function.
"""
xy = treecorr.GGCorrera=ra, dec=dec, g1=g1a, g2=g2a, ra_units=raUnits, , dec=dec, g1=g1b, g2=g2b, ra_units=raUnits, dec_units=decUnit
```
<Overlap Ratio: 0.8154302670623146>

---

--- 293 --
Question ID: 7cfa76a0e321448c9b715a43fe2ae910c799972c_1
Original Code:
```
def make_summary_file(filename):
    """
    Given a DLIS file, make a short human readable summary of it.
    Show things like headers, well parameters and which well curves are
    available.

    Args:
    filename: A DLIS file.

    Returns:
    summaryfile: The DLIS file without the extention and the suffix
    _summary.txt.
    """
    summaryfile = open(filename.replace('.DLIS', '_summary.txt'), 'w')
    (f, *f_tail) = dlis.load(filename)
    if len(f_tail):
        print('There are more logical files in tail')
    (origin, *originTail) = f.origins
    if len(originTail):
        print(filename + ' contains multiple origins')
    header = f.fileheader
    parameter_table = summarize(f.parameters, name='Name', long_name='Long name', values='Value(s)')
    mask = ~parameter_table['Name'].isin(['R8', 'RR1', 'WITN', 'ENGI'])
    parameter_table = parameter_table[mask]
    parameter_table.sort_values('Name')
    summaryfile.write(str(f.describe()))
    summaryfile.write(str(origin.describe()))
    summaryfile.write(str(header.describe()))
    summaryfile.write(str(parameter_table))
    for frame in f.frames:
        index_channel = next((ch for ch in frame.channels if ch.name == frame.index))
        summaryfile.write(f'\nFrame {frame.name}:\n')
        summaryfile.write(f'Description      : {frame.description}\n')
        summaryfile.write(f'Indexed by       : {frame.index_type}\n')
        summaryfile.write(f'Interval         : [{frame.index_min}, {frame.index_max}] {index_channel.units}\n')
        summaryfile.write(f'Direction        : {frame.direction}\n')
        summaryfile.write(f'Constant spacing : {frame.spacing} {index_channel.units}\n')
        summaryfile.write(f'Index channel    : {index_channel}\n')
        summaryfile.write(f'No. of channels  : {len(frame.channels)}\n')
    channel_table = summarize(f.channels, name='Name', long_name='Long name', units='Units', dimension='Dimension', frame='Frame')
    channel_table.sort_values('Name')
    summaryfile.write(str(channel_table))
    summaryfile.close()
    return summaryfile
```


Overlapping Code:
```
ble summary of it.
Show things like headers, well parameters and which well curves are
available.
Args:
filename: A DLIS file.
Returns:
summaryfile: The DLIS file without the extention and the suffix
file = open(filename.replace('.DLIS', '_summary.txf_tail):
print('There are more logical files in ta_table = summarize(f.parameters, name='Name', long_name='Long name', values='V ~parameter_table['Name'].isin(['R8', 'RR1', 'WITN', 'ENGI'])
parameter_table = parameter_table[mask]
parameter_table.sort_values('Name')
summaryfile.write(str(f.describe()))
summaryfile.write(str(origin.describe()))
summaryfile.write(str(header.describe()))
summaryfile.write(str(parameter_table))
for frame in f.framesh for ch in frame.channels if ch.name == frame.indFrame {frame.name}:\n')
summaryfile.write(f'Description : {frame.description}\n')
summaryfile.write(f'Indexed by : {frame.index_type}\n')
summaryfile.write(f'Interval : [{frame.index_min}, {frame.index_max}] {index_channel.units}\n')
summaryfile.write(f'Direction : {frame.direction}\n')
summaryfile.write(f'Constant spacing : {frame.spacing} {index_channel.units}\n')
summaryfile.write(f'Index channel : {index_channel}\n')
summaryfile.write(f'No. of channels : {len(frame.channels)}\n')
channel_table = summarize(f.channels, name='Name', long_name='Long name', units=imension='Dimension', frame='Frame')
channel_table.sort_values('Name')
summaryfile.write(str(channel_table))
summaryfile
```
<Overlap Ratio: 0.7826797385620915>

---

--- 294 --
Question ID: 4be3288dc749ae714f5530e0b9af4e86fbcb9c14_2
Original Code:
```
def set_crs(df: GDF, epsg_code: Union[int, str]) -> GDF:
    """Sets dataframe crs in geopandas pipeline.

    TODO: Deprecate with next rasterio version that will integrate set_crs method.
    """
    df.crs = {'init': f'epsg:{str(epsg_code)}'}
    return df
```


Overlapping Code:
```
 GDF, epsg_code: Union[int, str]) -> GDF:
"""Sets dataframe crs in geopandas pipeline.
TODO: Deprecate with next rasterio version that will integrate set_crs method.
"""
df.crs = {'init': f'epsg:{str(
```
<Overlap Ratio: 0.8403361344537815>

---

--- 295 --
Question ID: 28241061cc6276467c762df6e87e9db4f4a59e1b_6
Original Code:
```
def total_lights():
    totalLightsOn = 0
    for (y, _) in enumerate(lights):
        for (x, _) in enumerate(lights[y]):
            if lights[y][x] == 1:
                totalLightsOn += 1
    return totalLightsOn
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 296 --
Question ID: c85e03d56b4d6fc548188cd588d9ea2d6a3b23be_0
Original Code:
```
def argopen(file, mode, encoding=None, errors=None):
    closefd = True
    if file == '-':
        closefd = False
        if 'r' in mode:
            file = sys.stdin.fileno()
        else:
            file = sys.stdout.fileno()
    return io.open(file, mode, encoding=encoding, errors=errors, closefd=closefd)
```


Overlapping Code:
```
osefd = True
if file == '-':
closefd = False
if 'r' in mode:
file = sys.stdin.fileno()
else:
file = sys.stdout.fileno()
return io.open(file, mode, enc
```
<Overlap Ratio: 0.5952380952380952>

---

--- 297 --
Question ID: 96a9ce1af1b9abc8e61b5491562c9ddee1c883c3_1
Original Code:
```
def infer_replicates(target_labels_long):
    """ Infer replicate experiments based on their long form labels.

    In:
        target_labels_long [str]: list of long form target labels
    Out:
        replicate_lists {exp_label -> [target indexes]}
    """
    replicate_lists = {}
    rep_re = []
    rep_re.append(re.compile('rep\\d+'))
    rep_re.append(re.compile('donor\\d+'))
    for ti in range(len(target_labels_long)):
        label = target_labels_long[ti]
        for ri in range(len(rep_re)):
            rep_m = rep_re[ri].search(label)
            if rep_m:
                repStr = rep_m.group(0)
                label = label.replace(repStr, '')
        replicate_lists.setdefault(label, []).append(ti)
    return replicate_lists
```


Overlapping Code:
```
eir long form labels.
In:
target_labels_long [str]: list of long form target labels
Out:
replicate_list_lists = {}
rep_re = []
rep_re.append(re.compile('repr ti in range(len(target_labels_long)):
label = target_labels_long[ti]
for ri in range(len(rep_re)):
re
```
<Overlap Ratio: 0.4245901639344262>

---

--- 298 --
Question ID: eb9320bc73ea082b4d99c1b4dbcaed9bf2e92e33_0
Original Code:
```
def verify_flow_region_func(height: float, boundary_layer_height: float) -> FlowFieldRegion:
    if height < boundary_layer_height:
        return FlowFieldRegion.BOUNDARY_LAYER
    else:
        return FlowFieldRegion.FREE_FLOW
```


Overlapping Code:
```
erify_flow_region_func(height: float, boundary_layer_height: float) -> FlowFieldRegion:
if height < boundary_layer_height:
return FlowFieldRegion.BOUN
```
<Overlap Ratio: 0.7352941176470589>

---

--- 299 --
Question ID: 3f5030776c04f54c1b5b6703282b5954e3f6c54c_0
Original Code:
```
def timeit(method):

    def timed(*args, **kw):
        ts = time.time()
        result = method(*args, **kw)
        te = time.time()
        if 'log_time' in kw:
            name = kw.get('log_name', method.__name__.upper())
            kw['log_time'][name] = int((te - ts) * 1000)
        else:
            print('%r  %2.2f ms' % (method.__name__, (te - ts) * 1000))
        return result
    return timed
```


Overlapping Code:
```
def timeit(method):
def timed(*args, **kw):
ts = time.time()
result = method(*args, **kw)
te = time.time()
if 'log_time' in kw:
name = kw.get('log_name', method.__name__.upper())
kw['log_time'][name] = int((te - ts) * 1000)
else:
print('%r %2.2f ms' % (method.__name__, (te - ts) * 1000))
return result
return timed
```
<Overlap Ratio: 1.0>

---

--- 300 --
Question ID: 89cf74e1d86ffce9e2a638d3306254d23a748771_3
Original Code:
```
def infer_remote_zip_file_directory_name() -> List[str]:
    from ..version import __version__
    remoteZipFileDirectoryName: List[str] = [__version__]
    remoteZipFileDirectoryName.append(f'python_{PYTHON_VERSION}')
    if Env.ON_WINDOWS:
        remoteZipFileDirectoryName.append('windows')
    else:
        remoteZipFileDirectoryName.append('linux')
    return remoteZipFileDirectoryName
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 301 --
Question ID: c8cc0e831e5f48f15a8c98373df38d2e3f24ded3_0
Original Code:
```
def heap_sort(list_item):
    """
    Heap Sort
    Time Complexity of Solution:
    Best - O(nlog(n))
    Average - O(nlog(n))
    Worst - O(nlog(n))

    Approach:
    Heap sort takes place in two steps. In first step, array is
    transformed into a heap.
    In second step, heap is continously reduced to a sorted array.

    """
    end = len(list_item)
    start = end // 2 - 1
    for i in range(start, -1, -1):
        heapify(list_item, end, i)
    for i in range(end - 1, 0, -1):
        swap(list_item, i, 0)
        heapify(list_item, i, 0)
```


Overlapping Code:
```
t(list_item):
"""
Heap Sort
Time Complexity of Solution:
Best - O(nlog(n))
Average - O(nlog(n))
Worst - O(nlog(n))
Approach:
Heap sort takes place in two steps. In first step, array is
transformed into a heap.
In second step, heap is continously reduced to a sorted array.
"""
end = len(list_item)
start = end // 2 - 1
for i in range(start, -1, -1):
heapify(list_item, end, i)
f
```
<Overlap Ratio: 0.8094218415417559>

---

--- 302 --
Question ID: 29dcd0e7194a9a266ef5c8a71033e49f8cc50186_2
Original Code:
```
def a_star(grid, h, start, goal):
    path = []
    path_cost = 0
    queue = PriorityQueue()
    queue.put((0, start))
    visited = set(start)
    branch = {}
    found = False
    while not queue.empty():
        item = queue.get()
        current_node = item[1]
        if current_node == start:
            current_cost = 0.0
        else:
            current_cost = branch[current_node][0]
        if current_node == goal:
            print('Found a path.')
            found = True
            break
        else:
            for action in valid_actions(grid, current_node):
                da = action.delta
                next_node = (current_node[0] + da[0], current_node[1] + da[1])
                branch_cost = current_cost + action.cost
                queueCost = branch_cost + h(next_node, goal)
                if next_node not in visited:
                    visited.add(next_node)
                    branch[next_node] = (branch_cost, current_node, action)
                    queue.put((queueCost, next_node))
    if found:
        n = goal
        path_cost = branch[n][0]
        path.append(goal)
        while branch[n][1] != start:
            path.append(branch[n][1])
            n = branch[n][1]
        path.append(branch[n][1])
    else:
        print('**********************')
        print('Failed to find a path!')
        print('**********************')
    return (path[::-1], path_cost)
```


Overlapping Code:
```
(grid, h, start, goal):
path = []
path_cost = 0
queue = PriorityQueue()
queue.put((0, start))
visited = set(start)
branch = {}
found = False
while not queue.empty():
item = queue.get()
current_node = item[1]
if current_node == start:
current_cost = 0.0
else:
current_cost = branch[current_node][0]
if current_node == goal:
print('Found a path.')
found = True
break
else:
for action in valid_actions(grid, current_nodion.delta
next_node = (current_node[0] + da[0], current_node[1] + da[1])
branch_cost = current_cost + action.cost
queueanch_cost + h(next_node, goal)
if next_node not in visited:
visited.add(next_node)
branch[next_node] = (branch_cost, current_node, action)
queue.put((queue
n = goal
path_cost = branch[n][0]
path.append(goal)
while branch[n][1] != start:
path.append(branch[n][1])
n = branch[n][1]
path.append(branch[n][1])
else:
print('**********************')
print('Failed to find a path!')
print('**********************')
return 
```
<Overlap Ratio: 0.9214354995150339>

---

--- 303 --
Question ID: 7fa31603a252cfd1d536877477d7abb4da4bdef3_0
Original Code:
```
def decimal_to_binary(n: int):
    """
    Function to convert Decimal number to Binary number 
    
    :param n: 
    :return: 
    """
    return int('{0:b}'.format(n))
```


Overlapping Code:
```
ion to convert Decimal number to Binary number 

:
```
<Overlap Ratio: 0.34965034965034963>

---

--- 304 --
Question ID: 66a6d587f9640fe42f4703541334c4465b7b3a16_6
Original Code:
```
def _parse_word(operand):
    value = OP_EVALUATOR.eval_int(operand)
    if 0 <= value < 65536:
        return (value % 256, value // 256)
    raise ValueError
```


Overlapping Code:
```
_word(operand):
value = OP_EVALUATOR.eval_int(operand)
if 0 <= value < 65536:
return (value % 256, v
```
<Overlap Ratio: 0.7194244604316546>

---

--- 305 --
Question ID: f46d4201935576f7c5b0f071b01e8b9a5b4caddc_4
Original Code:
```
def test_proportions_delta_aa(proportions_data_small):
    exp = Experiment(proportions_data_small, name='proportions-test')
    testAa = HypothesisTest(metric='metric', control='A', variation='A', hypothesis='larger', inference_method='proportions_delta')
    results_aa = exp.run_test(testAa)
    assert not results_aa.accept_hypothesis
```


Overlapping Code:
```
lta_aa(proportions_data_small):
exp = Experiment(proportions_data_small, name='proportions-test'pothesis='larger', inference_method='proportions_d
```
<Overlap Ratio: 0.453416149068323>

---

--- 306 --
Question ID: dd575f7aaba2cc90075652902b7b83a55562e8f2_0
Original Code:
```
def _load_cache():
    if not os.path.exists(cache_file_name):
        raise ValueError('No cache file found.')
    else:
        with open(cache_file_name, 'rb') as f:
            datasetStats = pickle.load(f)
    return datasetStats
```


Overlapping Code:
```
_cache():
if not os.path.exists(cache_file_name):
raise ValueError('No cache file found.')
else:
wit
```
<Overlap Ratio: 0.5154639175257731>

---

--- 307 --
Question ID: d4e3e838774528218776e66d0b619c26190040dd_6
Original Code:
```
@api_view(['PUT'])
@permission_classes((IsAuthenticated,))
@allowed_groups(group_names=['admin'])
def updateUser(request: HttpRequest, id):
    user = get_object_or_404(User, id=id)
    groups = request.data.pop('authGroups', [])
    serialised = UserSerializer(user, data=request.data, context={'request': request}, partial=True)
    if serialised.is_valid():
        serialised.save()
        user_group_many.objects.filter(user=user).delete()
        for group in groups:
            user_group_many.objects.create(user=user, group_id=group['id'])
        return Response(status=status.HTTP_200_OK)
    print(serialised.error_messages)
    return Response(status=status.HTTP_400_BAD_REQUEST)
```


Overlapping Code:
```
api_view(['PUT'])
@permission_classes((IsAuthenticated,))equest, id):
user = get_object_or_404(User, id=id)
groupserSerializer(user, data=request.data, context={'request': request}, partial=True)
if serialised.is_valid():
serialised.save()
user_group_many.objects.filter(user=user).delete()
for group in groups:
user_group_many.objects.create(user=user, group(serialised.error_messages)
return Response(status=status.HTTP_400_BAD_REQUEST)
```
<Overlap Ratio: 0.6996805111821086>

---

--- 308 --
Question ID: 7a6ac05f5c406402bdf62d0f733ffe486364b813_2
Original Code:
```
def speak_rank_top_10():
    sql = '\n        select * \n        from(select row_number() over(order by user_speak_total desc) as row_number,* from user_info)\n        where row_number <= 10\n    '
    data = sql_dql(sql)
    msg = f'🙈发言光荣榜🙈\n__________________\n'
    for item in data:
        rank = item[0]
        name = item[1]
        id = item[2]
        num = item[3]
        numEmoji = rank_emoji(rank)
        msg += f'{numEmoji}{name}({id})🗣️:{num}\n'
    msg += f'这些👨都4️⃣大💦👾'
    return msg
```


Overlapping Code:
```
ct row_number() over(order by user_speak_total desc) as row_number,* from use
```
<Overlap Ratio: 0.1896551724137931>

---

--- 309 --
Question ID: 43ee7c52704e9f62de936933b0306b16b4a79105_8
Original Code:
```
def test_model_default_implementations():

    class MyModel(Model):
        pass
    model = MyModel()
    with pytest.raises(NotImplementedError):
        model.__prior__()
    with pytest.raises(NotImplementedError):
        model.__condition__(None, None)
    with pytest.raises(NotImplementedError):
        model.__noiseless__()
    with pytest.raises(NotImplementedError):
        model.logpdf(None, None)
    with pytest.raises(NotImplementedError):
        model.sample(None)

    class MyModel2(Model):

        def __prior__(self):
            pass

        def sample(self, x):
            return 1
    model = MyModel2()
    assert model.predict(None, num_samples=100) == (1, 0)
```


Overlapping Code:
```
ult_implementations():
class MyModel(Model):
pass
model = MyModel()
with pytest.raises(NotImplementedError):
model.__prior__()
with pytest.raises(NotImplementedError):
model.__condition__(None, None)
with pytest.raises(NotImplementedError):
model.__noiseless__()
with pytest.raises(NotImplementedError):
model.logpdf(None, None)
with pytest.raises(NotImplementedError):
model.sample(None)
class MyModel2(Model):
def __prior__(self):
pass
def sample(self, x):
return 1
model = MyModel2()
assert model.
```
<Overlap Ratio: 0.8944543828264758>

---

--- 310 --
Question ID: 7d2d407dbcaa652ae9d9750427e051162ad2d2e3_5
Original Code:
```
def pattern_loader(path_to_rules='patterns.jsonl') -> List:
    """ Loads the patterns from the pattern list. """
    patterns = []
    pattern_dicts = []
    with open(path_to_rules, encoding='utf8') as f:
        try:
            for line in f:
                data = json.loads(line)
                pattern_dicts.append(data)
        except:
            pass
    for pattern_dict in pattern_dicts:
        patterns.append(Pattern(**pattern_dict))
    return patterns
```


Overlapping Code:
```
s the patterns from the pattern list. """
patterns
```
<Overlap Ratio: 0.1366120218579235>

---

--- 311 --
Question ID: 9a23cc6017e673eb9497903c018a6480ea3f8e60_6
Original Code:
```
def readVDAT(fid, address):
    vdat = namedtuple('vdat', [])
    if address != -1:
        fid.seek(address, 0)
    [dum_crc, last_size, last_type, dum_misc] = readARDFpointer(fid, -1)
    vdat.force = struct.unpack('i', fid.read(4))[0]
    vdat.line = struct.unpack('i', fid.read(4))[0]
    vdat.point = struct.unpack('i', fid.read(4))[0]
    vdat.sizeData = struct.unpack('i', fid.read(4))[0]
    vdat.forceType = struct.unpack('i', fid.read(4))[0]
    vdat.pnt0 = struct.unpack('i', fid.read(4))[0]
    vdat.pnt1 = struct.unpack('i', fid.read(4))[0]
    vdat.pnt2 = struct.unpack('i', fid.read(4))[0]
    dum = struct.unpack('i' * 2, fid.read(4 * 2))[0]
    size_data = vdat.sizeData
    vdat.data = struct.unpack('f' * size_data, fid.read(4 * size_data))
    return vdat
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 312 --
Question ID: 4621fba19fcf958d4877519ee2e7db8ca9d513e9_3
Original Code:
```
def search_froms():
    """
    Search for unique "from xxx import yyy" statements, returning a sorted list.
    """
    _froms = []
    _lib_dir_regex = '{}\\.'.format(LIB_DIR)
    _regex = '^[ ]*from '
    print(Fore.GREEN + '\nimport list contents:' + Style.RESET_ALL)
    for _items in _find_in_files('^[ ]*from.*import.*'):
        _item = _items[0]
        _filename = _items[1]
        _library_name = re.sub(' import.*', '', _item)
        _library_name = re.sub(_regex, '', _library_name).strip()
        if IGNORE_LIB and re.match(_lib_dir_regex, _library_name):
            pass
        elif len(_library_name) > 1 and _library_name not in _froms:
            _froms.append(_library_name)
    _froms.sort()
    print(Fore.CYAN + "\n-- complete: {:d} instances of '{}' found.".format(len(_froms), _regex) + Style.RESET_ALL)
    return _froms
```


Overlapping Code:
```
rch for unique "from xxx import yyy" statements, r'
print(Fore.GREEN + '\nimport list contents:' + Style.RESET_ALL)
for _items in _find_in_files('^[ ]*from.*import.*'):
_item = _items[0]
_filename = _items[1]
_library_name = re.sub(' import.*', '', _item)
_library_name = re.sub(_regex, '', _library_len(_library_name) > 1 and _library_name not in _f
```
<Overlap Ratio: 0.47619047619047616>

---

--- 313 --
Question ID: f5243a5a3b358ca43895541eb22f25937e8336f3_5
Original Code:
```
def try_to_get_last_line_as_json(file_location: str, max_tries=3, await_in_seconds_between_tries=1) -> Optional[dict]:
    attempts = 0
    while True:
        line = last_line_from_some_file(file_location)
        lineAsJson = json.loads(line) if line else None
        if lineAsJson:
            return lineAsJson
        if attempts >= max_tries:
            return None
        sleep(await_in_seconds_between_tries)
        attempts += 1
```


Overlapping Code:
```
try_to_get_last_line_as_json(file_location: str, max_tries=3, await_in_seconds_between_tries=1) -> Optional[dict]:
attempts = 0
while True:
line = lasreturn None
sleep(await_in_seconds_between_tries)

```
<Overlap Ratio: 0.554016620498615>

---

--- 314 --
Question ID: b82969bc09d27dd516accba17236411cb1f5adb8_0
Original Code:
```
def test_get_binary_patterns():
    wl = Wordlist(data_path('wichmannmixezoquean.tsv'))
    (pats, characters) = get_binary_patterns(wl, 'cogid')
    etd = wl.get_etymdict(ref='cogid')
    assert len(etd) == len(pats)
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 315 --
Question ID: 1609ca3cfecd7e4bdac13a4eed7e722233b86773_0
Original Code:
```
async def get_prefix(bot_, message):
    """Returns the appropriate prefix for the bot."""
    with open('./data/options.json', 'r') as options_file:
        options_dict = json.load(options_file)
    if message.guild and str(message.guild.id) in options_dict:
        prefixes = options_dict[str(message.guild.id)]['prefix']
    else:
        prefixes = '.'
    return commands.when_mentioned_or(*prefixes)(bot_, message)
```


Overlapping Code:
```
ot_, message):
"""Returns the appropriate prefix for the bot."""
with open('./data/options.json', 'r') as options_file:
options_dict = json.load(options_file)
if message.guild and str(message.guild.id) in options_dict:
prefixes = options_dict[str(message.guild.id)]['prefix']
else:
prefixes = '.'
return commands.when_mentioned_or(*prefixes)(bot_, me
```
<Overlap Ratio: 0.9259259259259259>

---

--- 316 --
Question ID: 9886643486593889d35875fc98bf1b7805dee00d_14
Original Code:
```
@pytest.mark.parametrize('operation', [cirq.CNOT(AspenQubit(0, 1), AspenQubit(0, 2))])
def test_rigetti_qcs_aspen_device_valid_operation(operation: cirq.Operation, qcs_aspen8_isa: InstructionSetArchitecture):
    """test RigettiQCSAspenDevice throws no error when validating 2Q operations on
    adjacent qubits
    """
    device = RigettiQCSAspenDevice(isa=qcs_aspen8_isa)
    device.validate_operation(operation)
```


Overlapping Code:
```
ation: cirq.Operation, qcs_aspen8_isa: InstructionSetArchitecture):
"""test RigettiQCSAspenDevichrows no error when validating 2Q operations on
adjacent qubits
"""
device = RigettiQCSAspenDevice(isa=qcs_aspen8_isa)
device.validate_operation(opera
```
<Overlap Ratio: 0.6227848101265823>

---

--- 317 --
Question ID: 8090bbc869f16bd9ee00e270a16a5e0352ae7028_0
Original Code:
```
def categoryFilter(doc):
    categories = doc.Settings.Categories
    cats = [ElementCategoryFilter(c.Id) for c in categories if c.CategoryType == CategoryType.Model and c.CanAddSubcategory]
    filter = None
    if len(cats):
        try:
            filter = LogicalOrFilter(List[ElementFilter](cats))
        except Exception as ex:
            raise Exception(str(ex) + str(len(cats)))
    return filter
```


Overlapping Code:
```
 doc.Settings.Categories
cats = [ElementCategoryFilter(c.Id) for c in categories if c.CategoryType =ter = None
if len(cats):
try:
filter = LogicalOrFilter(List[ElementFilter](cats))
except Exception a
```
<Overlap Ratio: 0.5763688760806917>

---

--- 318 --
Question ID: 534d6702940b8bc6ddbaba4862587a1683235de5_0
Original Code:
```
def view_form_force(form, force, forcescale=0.5, edge_label=True):
    if edge_label:
        form_edge_label = {uv: index for (index, uv) in enumerate(form.edges())}
        forceEdgeLabel = force_edge_labels
    else:
        form_edge_label = None
        forceEdgeLabel = None
    viewer = Viewer(form, force, delay_setup=False)
    viewer.draw_form(edgelabel=form_edge_label, forces_on=True, forcescale=forcescale, vertexcolor={key: '#000000' for key in form.vertices_where({'is_fixed': True})})
    viewer.draw_force(edgelabel=forceEdgeLabel)
    viewer.show()
```


Overlapping Code:
```
ef view_form_force(form, force, forcescale=0.5, edge_label=True):
if edge_label:
form_edge_label = {uv: force_edge_labels
else:
form_edge_label = None
forceabel = None
viewer = Viewer(form, force, delay_setup=False)
viewer.draw_form(edgelabel=form={key: '#000000' for key in form.vertices_where({'is_fixed': True})})
viewer.draw_force
```
<Overlap Ratio: 0.6549019607843137>

---

--- 319 --
Question ID: b36cd3ac7c6ccf4bb43ebb3004f30af35e47297a_2
Original Code:
```
def generateCoordsForLayersPG(dictDlsLayers, graphviz_layout, isHorizontal):
    the_graph = pyg.AGraph()
    for (kk, vv) in dictDlsLayers.items():
        for ll in vv['cfg']['wires']:
            the_graph.add_edge(kk, ll)
    if isHorizontal:
        p_args = '-Grankdir=LR'
    else:
        p_args = '-Grankdir=TB'
    if graphviz_layout is None:
        graphviz_layout = 'dot'
    the_graph.layout(prog=graphviz_layout, args=p_args)
    the_graph_pos = {}
    for kk in dictDlsLayers.keys():
        tnode = the_graph.get_node(kk)
        tpos = [int(float(xx)) for xx in tnode.attr['pos'].split(',')]
        the_graph_pos[kk] = tuple(tpos)
    return the_graph_pos
```


Overlapping Code:
```
 in dictDlsLayers.items():
for ll in vv['cfg']['wiint(float(xx)) for xx in tnode.attr['pos'].split('
```
<Overlap Ratio: 0.17543859649122806>

---

--- 320 --
Question ID: 3fa1da9767d379e042b89a14701794778faba152_7
Original Code:
```
@numba.njit([types.Long(types.Keys)], cache=True)
def find_depth(tree):
    """
    Return maximum depth of a linear octree.
    """
    levels = morton.find_level(np.unique(tree))
    return np.max(levels)
```


Overlapping Code:
```
mum depth of a linear octree.
"""
levels = morton.
```
<Overlap Ratio: 0.26881720430107525>

---

--- 321 --
Question ID: 52b60b2ec451113de42ad06d277c614499c2007a_5
Original Code:
```
@expose_builtin('del_attrs', unwrap_spec=['obj'])
def impl_del_attrs(engine, heap, attvar):
    if isinstance(attvar, AttVar):
        if attvar.value_list is not None:
            for (name, index) in attvar.attmap.indexes.iteritems():
                heap.add_trail_atts(attvar, name)
            attvar.value_list = None
```


Overlapping Code:
```
f impl_del_attrs(engine, heap, attvar):
if isinstance(attvar, AttVar):
if attvar.attmap.indexes.iteritems():
heap.add_trail_at
```
<Overlap Ratio: 0.46494464944649444>

---

--- 322 --
Question ID: 504b87ddee9917d8fa486f13be56f5b536985c45_0
Original Code:
```
def test_client_with_wrong_credentials(zendesk_credentials):
    """Test check with wrong credentials"""
    client = Client(**zendesk_credentials)
    (alive, error) = client.health_check()
    assert not alive
    assert error
```


Overlapping Code:
```
est_client_with_wrong_credentials(zendesk_credentials):
"""Test check with wrong credentials"""
client = Clientclient.health_check()
assert not alive
assert erro
```
<Overlap Ratio: 0.7740384615384616>

---

--- 323 --
Question ID: 241fb0211e37aae619cf601b0686c40ee27576eb_1
Original Code:
```
def update_doing_card():
    """
    DOING 상태의 카드의 DURATION을 새로 기록합니다.
    DURATION의 값이 없을 경우에는 시작일을 당일로 설정합니다.
    """
    status = notion.CARD_STATUS
    doing = notion.DOING
    duration = notion.CARD_DURATION
    today = date.today()
    for card_id in notion.get_filtered_card_ids(status, doing):
        card = notion.client.get_block(card_id)
        notionDate = card.get_property(duration)
        if not notionDate or notionDate.start == None:
            notionDate = NotionDate(start=today)
        card.set_property(duration, notionDate)
```


Overlapping Code:
```
의 카드의 DURATION을 새로 기록합니다.
DURATION의 값이 없을 경우에는 시작일을 당일로 설정합니다.
"""
status = notion.CARD_STATUS
doing = notion.DOING
duration = notion.CARD_DURATION
today = date.today()
for card_id in notion.get_filtered_card_ids(status, doing):
card = notion.client.
```
<Overlap Ratio: 0.5319148936170213>

---

--- 324 --
Question ID: 7354359d5802ce995119a41c90b85838a4204d5d_4
Original Code:
```
@app.route('/commands_per_day')
@cache(time=datetime.timedelta(minutes=DEFAULT_CACHE_MINUTES))
def commands_per_day():
    commandNames = [row.get('command_name') for row in bigquery_client.query('SELECT DISTINCT command_name FROM analytics.commands').result()]
    print(commandNames)
    commandNames = filter(lambda item: item not in ['list', 'set', 'voices', 'languages', 'property'], commandNames)
    result = {}
    for command_name in commandNames:
        usage = {date: {'text_count': 0, 'slash_count': 0} for date in get_days_in_range(datetime.datetime(2021, 1, 1), datetime.datetime.today())}
        query = 'SELECT DATE(time) as d, COUNTIF(NOT is_slash) as cnt, COUNTIF(is_slash) as slash_cnt FROM analytics.commands WHERE command_name = @command_name GROUP BY d ORDER BY d'
        job_config = bigquery.QueryJobConfig(query_parameters=[bigquery.ScalarQueryParameter('command_name', 'STRING', command_name)])
        for row in bigquery_client.query(query, job_config=job_config).result():
            d = row_to_dict(row)
            usage[d['d']]['text_count'] = d['cnt']
            usage[d['d']]['slash_count'] = d['slash_cnt']
        result[command_name] = [{'date': date, **usage[date]} for date in usage.keys()]
    response = jsonify(result)
    response.headers['Access-Control-Allow-Origin'] = '*'
    return response
```


Overlapping Code:
```
')
@cache(time=datetime.timedelta(minutes=DEFAULT_CACHE_MINUTES))
dgquery_client.query('SELECT DISTINCT command_name t in ['list', 'set', 'voices', 'languages', 'propedate: {'text_count': 0, 'slash_count': 0} for date in get_days_in_range(datetime.datetime(2021, 1, 1), datetime.datetime.today())}
query = 'SELECT DATE(time) as d, COUNTIF(NOT is_slash) as cnt, COUNTIF(is_slash) as slash_cnt FROM analytics.commands WHERE command_name = @command_name GROUP BY d ORDER BY d'
job_config = bigquery.QueryJobConfig(query_parameters=[bigquery.ScalarQueryParameter('commandigquery_client.query(query, job_config=job_config).result():
d = row_to_dict(row)
usage[d['d']]['text_count'] = d['cnt']
usage[d['d']]['slash_count'] = d['slash_cnt']
result[command_name] = [{'date': date, **usage[date]} for date in usage.keys()]
response = jsonify(result)
response.headers['Access-Control-Allow-Origin'] = '*'
return response
```
<Overlap Ratio: 0.7368421052631579>

---

--- 325 --
Question ID: f31065a13878fbae4e2467fa58de8efe0ace1f13_3
Original Code:
```
def test_delete_all_album():
    rq_album.delete_all(token=env.env_var['USER_1_TOKEN'], user_id=env.env_var['USER_1_MAIL'])
    rq_album.delete_all(token=env.env_var['USER_2_TOKEN'], user_id=env.env_var['USER_2_MAIL'])
    rq_album.delete_all(token=env.env_var['USER_3_TOKEN'], user_id=env.env_var['USER_3_MAIL'])
```


Overlapping Code:
```
l_album():
rq_album.delete_all(token=env.env_var['USER_1_TOKEN'], user_id=env.env_var['USER_1_MAIL'])
rq_album.delete_all(token=env.env_var['USER_2_TOKEN'], user_id=env.env_var['USER_2_MAIL'])
rq_album.delete_all(token=env.env_var['USER_3_TOKEN'], user_id=env.env_var['USER_3_M
```
<Overlap Ratio: 0.920265780730897>

---

--- 326 --
Question ID: 1b7e2d214e5eeb85cf50702bb2e69e77348f954c_5
Original Code:
```
def _delete_old(old_ids):
    db = get_db('yahoo')
    for item in ['financial_data', 'key_stats']:
        collection = db[item]
        id_ = old_ids[item]
        if id_:
            result = collection.delete_many({'_id': {'$lte': id_}})
            logger.info(f'删除 {item} 旧数据 {result.deleted_count} 行')
```


Overlapping Code:
```
elete_old(old_ids):
db = get_db('yahoo')
for item in ['financial_data', 'key_stats']:
collection = db[item]
id_ = old_ids[item]
if id_:
result = collection.delete_many({'_id': {'$lte': id_}})
logger.i
```
<Overlap Ratio: 0.7936507936507936>

---

--- 327 --
Question ID: a9df1185d80d2c045bcd42e083755fc20bd784de_0
Original Code:
```
def split_indices(idx, n_total, fractions):
    """
    splits idx containing n_total distinct events into fractions given in fractions list.
    returns the number of events in each split
    """
    numIds = [ceil(n_total * f) for f in fractions]
    if sum(numIds) > n_total:
        numIds[-1] -= sum(numIds) - n_total
    return numIds
```


Overlapping Code:
```
, fractions):
"""
splits idx containing n_total distinct events into fractions given in fractions list.
returns the number of events in each split
"""
```
<Overlap Ratio: 0.4934210526315789>

---

--- 328 --
Question ID: 0e43d54d54e3eafdf583b28f0be4bd0753b4013d_0
Original Code:
```
@app.route('/json-rpc', methods=['GET', 'POST', 'OPTIONS'])
def jsonrpc():
    result = ''
    if request.headers['CONTENT_LENGTH']:
        handler = JSONRPCHandler()
        result = handler.handle(request.data)
    response = make_response(result, 200)
    hdr = 'Access-Control-Allow-%s'
    response.headers[hdr % 'Origin'] = '*'
    response.headers[hdr % 'Headers'] = 'Content-Type, Authentication'
    response.headers[hdr % 'Method'] = 'POST, GET, OPTIONS, PUT, DELETE, TRACE'
    return response
```


Overlapping Code:
```
ET', 'POST', 'OPTIONS'])
def jsonrpc():
result = ''
if request.headeJSONRPCHandler()
result = handler.handle(request.data)
response = mase.headers[hdr % 'Origin'] = '*'
response.headers[
```
<Overlap Ratio: 0.40700218818380746>

---

--- 329 --
Question ID: 6461501746c4c91ad65a43d4651b57d08946bf5f_4
Original Code:
```
def contains_inappropriate_phrases(tweet_text):
    if 'sex' in tweet_text:
        return True
    return False
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 330 --
Question ID: dedf80bf95ac67960c80fd880c96b74b9b20d6cf_9
Original Code:
```
def test_local_missing_url(tmpdir):
    """ Test creating a toolchain from path to a local feed xml """
    full = '<feed>\n<feed />\n</feed>\n'
    with pytest.raises(Exception) as e:
        _generic_test_local(tmpdir, full)
    assert 'not parse' in str(e)
    assert "Non-root 'feed' element must have an 'url' attribute" in str(e)
```


Overlapping Code:
```
cal_missing_url(tmpdir):
""" Test creating a toolchain from path to a local feed xml """
full = '<feed>\n<feed />\n</feed>\n'
with pytest.raises(Exception) as e:
_generic_test_local(tmpdir, full)
asse
```
<Overlap Ratio: 0.6514657980456026>

---

--- 331 --
Question ID: 3ca816c1fdae9c07f862a54969748690cccccdc9_0
Original Code:
```
def get_authorization_token(event) -> str:
    cookie = SimpleCookie()
    cookie.load(', '.join(event['cookies']))
    if COOKIE_TOKEN_KEY in cookie:
        return cookie[COOKIE_TOKEN_KEY].value
    header = event['headers'].get('authorization')
    if header is None:
        return None
    return header.replace('Bearer ', '')
```


Overlapping Code:
```
t_authorization_token(event) -> str:
cookie = SimpleCookie()
cookie.load(', '.join(event['cookies']))
if COOKIE_TOKEN_KEY in cookie:
return cookie[COOKIE_TOKEN_KEY].value
header = event['headers'].get('authorization')
if header is None:
return None
r
```
<Overlap Ratio: 0.8591065292096219>

---

--- 332 --
Question ID: fbbdcaf00a8d9fa8c6f2f80cfad9ef55df7708dc_0
Original Code:
```
def fromList(li: List[int]):
    if len(li) == 0:
        return None
    root = TreeNode(val=li[0])
    queue = [root]
    i = 1
    while i < len(li):
        node = queue[0]
        del queue[0]
        if li[i] is not None:
            node.left = TreeNode(val=li[i])
            queue.append(node.left)
        i += 1
        if i < len(li):
            if li[i]:
                node.right = TreeNode(val=li[i])
                queue.append(node.right)
            i += 1
    return root
```


Overlapping Code:
```
ef fromList(li: List[int]):
if len(li) == 0:
return None
root = TreeNode(val=li[0])
queue = [root]
i = 1
while i < len(li):
node = queue[0]
del queue[0]
if li[i] is not None:
node.left = TreeNode(val=li[i])
queue.append(node.left)
i += 1
if i < len(li):
if li[i]:
node.right = TreeNode(val=li[i])
queue.append(node.right)
i += 1
return root
```
<Overlap Ratio: 0.9970674486803519>

---

--- 333 --
Question ID: 9a9f21e89303399d79c67e75c99b8d626266c51f_7
Original Code:
```
def get_maximum_mutation_frequency(counts, distance_matrix, frequencies):
    """
    # ========================================================================

    GET MAXMIMUM MUTATION FREQUENCY

    PURPOSE
    -------

    Returns the maximum mutation frequency of the haplotypes.


    INPUT
    -----

    [INT LIST] [counts]
        A haplotype counts, from the counts of the most abundant to the counts
        of the least abundant haplotype.

    [FLOAT LIST] [frequencies]
        A list of (relative) frequencies of the Haplotypes.

    [2D ARRAY] [distance_matrix]
        A two dimensional array, representing the distance matrix of distances
        between the sorted haplotypes.

        This is expected to be calculated in a similar manner as:
            haplotype.build_distiance_matrix(haplotypes)


    RETURN
    ------

    [FLOAT] [maximum_mutation_frequency]
        The maximum mutation frequency.

    # ========================================================================
    """
    H = len(counts)
    F = frequencies
    D = distance_matrix
    maximumMutationFrequency = calculate.maximum_mutation_frequency(H, F, D)
    return maximumMutationFrequency
```


Overlapping Code:
```
istance_matrix, frequencies):
"""
# ========================================================================
GET MAXMIMUM MUTATION FREQUENCY
PURPOSE
-------
Returns the maximum mutation frequency of the haplotypes.
INPUT
-----
[INT LIST] [counts]
A haplotype counts, from the counts of the most abundant to the counts
of the least abundant haplotype.
[FLOAT LIST] [frequencies]
A list of (relative) frequencies of the Haplotypes.
[2D ARRAY] [distance_matrix]
A two dimensional array, representing the distance matrix of distances
between the sorted haplotypes.
This is expected to be calculated in a similar manner as:
haplotype.build_distiance_matrix(haplotypes)
RETURN
------
[FLOAT] [maximum_mutation_frequency]
The maximum mutation frequency.
# ========================================================================
"""
H = len(counts)
F = frequencies
D = dise.maximum_mutation_frequency(H, F, D)
return maxim
```
<Overlap Ratio: 0.8918128654970761>

---

--- 334 --
Question ID: e8db797381a8d4f3d0f04952d696026266dfabdc_2
Original Code:
```
def add_zero(lst):
    """ Add pulses for logical zero """
    pulse = 1875
    space = 1875
    lst.extend([pulse, space])
    return lst
```


Overlapping Code:
```
75
space = 1875
lst.extend([pulse, space])
return 
```
<Overlap Ratio: 0.423728813559322>

---

--- 335 --
Question ID: 6e0e15f18889c25b4f39d64ec87555d40f8d8c97_0
Original Code:
```
def apply_mask_criteria(column):
    """Apply simple masking criteria to a single column, and return '-' if the
    column does not meet the criteria, and 'I' if it does.
    """
    mask_char = '-'
    num_seqs = len(column)
    half_num_seqs = num_seqs / 2
    numGapsInCol = column.count('-')
    column_no_gaps = column.replace('-', '')
    if column_no_gaps == '':
        return mask_char
    elif not column_no_gaps == '':
        most_common_residue = collections.Counter(column_no_gaps).most_common(1)[0]
        most_common_residue_count = most_common_residue[1]
        percent_identity = most_common_residue_count * 100 / num_seqs
        if numGapsInCol < num_seqs * 0.3:
            mask_char = 'I'
        if percent_identity >= 50:
            mask_char = 'I'
        return mask_char
```


Overlapping Code:
```
y_mask_criteria(column):
"""Apply simple masking criteria to a single column, and return '-' if the
column does not meet the criteria, and 'I' if it dum_seqs = len(column)
half_num_seqs = num_seqs / 2count('-')
column_no_gaps = column.replace('-', ''o_gaps == '':
return mask_char
elif not column_no_gaps == '':
most_common_residue = collections.Counter(column_no_gaps).most_common(1)[0]
most_common_residue_count = most_common_residue[1]
percent_identity = most_common_residue_count * 100 / num_seqs
```
<Overlap Ratio: 0.7352941176470589>

---

--- 336 --
Question ID: d24a6419f9fcb2d3facd5e3d432818cfe2776fbb_6
Original Code:
```
def get_activity_rawdata(cfg: DictConfig, id: int) -> pd.DataFrame:
    """query rawdata from strava api for a given id

    Args:
        cfg (DictConfig): configuration
        id (int): activity id

    Returns:
        pd.DataFrame: activity rawdata
    """
    with MySession(cfg) as session:
        stream = session.get(cfg.api.BASE_URL + f'/activities/{id}/streams', params={'keys': ','.join(cfg.api.STREAMS)})
    activity = dict()
    found = list()
    for values in stream.json():
        activity[values['type']] = values['data']
        found.append(values['type'])
    resDf = pd.DataFrame(activity)
    try:
        resDf['lat'] = resDf['latlng'].apply(lambda x: x[0])
        resDf['long'] = resDf['latlng'].apply(lambda x: x[-1])
    except KeyError:
        (resDf['lat'], resDf['long']) = (np.nan, np.nan)
    missings = set(cfg.api.STREAMS) - set(found)
    if missings:
        for missing in missings:
            resDf[missing] = np.nan
    resDf['id'] = id
    if 'latlng' in resDf:
        del resDf['latlng']
    if cfg.TO_DB:
        resDf['last_update'] = save_datetime_now()
        with sqlite3.connect(call(cfg.DB)) as con:
            resDf.to_sql('ACTIVITIES_RAW', con=con, if_exists='append', index=False, index_label='id')
    time.sleep(cfg.api.SLEEP)
    return resDf
```


Overlapping Code:
```
nt) -> pd.DataFrame:
"""query rawdata from strava api for a given id
Args:
cfg (DictConfig): configuration
id (int): activity id
Returns:
pd.DataFrame
with MySession(cfg) as session:
stream = session.for values in stream.json():
activity[values['type']] = values['data']
found.append(values['type'])
sDf['lat'], resDf['long']) = (np.nan, np.nan)
misset(found)
if missings:
for missing in missings:
reto_sql('ACTIVITIES_RAW', con=con, if_exists='appen
```
<Overlap Ratio: 0.40797824116047143>

---

--- 337 --
Question ID: 66ec3f6ee6f74fd6f9a9ebdb2510fc97b493104f_0
Original Code:
```
def get_output_dir(outputDir):
    if not outputDir or os.path.isfile(outputDir):
        outputDir = '.'
    elif not os.path.exists(outputDir):
        os.makedirs(outputDir)
    return outputDir
```


Overlapping Code:
```
if not os.path.exists(outputDir):
os.makedirs(outputDir)
r
```
<Overlap Ratio: 0.3431952662721893>

---

--- 338 --
Question ID: 95f32217242b488480e02ece9bfc4b27508cb75d_1
Original Code:
```
def minimal(input_size=2, output_size=2, weight_low=-2, weight_high=2, depth=3):
    """ Builds a minimal genome with specified inputs and
    outputs, weight bounds, depth and one connected node in
    the first layer.

    :param input_size: Number of input nodes
    :param output_size: Number of output nodes
    :param weight_low: Maximum weight on node and edges
    :param weight_high: Minimum weight on node and edges
    :param depth: Number of layers in network.
    :return: Constructed genome.
    """
    genome = Genome(input_size=input_size, output_size=output_size, weight_low=weight_low, weight_high=weight_high, depth=depth)
    genome.layers = [genome.inputs, *[[] for _ in range(depth)], genome.outputs]
    genome.add_node(1)
    for n in genome.inputs:
        genome.add_edge(n, genome.layers[1][0])
    for n in genome.outputs:
        genome.add_edge(genome.layers[1][0], n)
    return genome
```


Overlapping Code:
```
):
""" Builds a minimal genome with specified inputs and
outputs, weight bounds, depth and one connected node in
the first layer.
:param input_size: Number of input nodes
:param output_size: Number of output nodes
:param weight_low: Maximum weight on node and edges
:param weight_high: Minimum weight on node and edges
:param depth: Number of layers in network.
:return: Constructed genome.
"""
genomnome.add_node(1)
for n in genome.inputs:
genome.add_edge(n, genome.layers[1][0])
for n in genome.outputs:
genome.add_edge(genome.layers[1][0], n)
retu
```
<Overlap Ratio: 0.6578947368421053>

---

--- 339 --
Question ID: 5d7651dffd876fa23e9cd979e7ddb5ed364b6b00_4
Original Code:
```
def validate_bool(value):
    """Check that ``value`` is an boolean value."""
    if value not in (0, 1, False, True):
        raise ValidationError(value, INVALID_BOOL)
    return bool(value)
```


Overlapping Code:
```
ck that ``value`` is an boolean value."""
if value not in (0, 1, False, True):
raise ValidationError
```
<Overlap Ratio: 0.5813953488372093>

---

--- 340 --
Question ID: 65836e5e8c8f2024ffb8b16e84f296ad241bb07d_1
Original Code:
```
def run_async(factor, func, *args, **kwargs):
    """
    Asynchronously executes a callable within a :class:`hiro.Timeline`

    :param int factor: scale factor to use for the timeline during execution
    :param function func: the function to invoke
    :param args: the arguments to pass to the function
    :param kwargs: the keyword arguments to pass to the function
    :returns: an instance of :class:`hiro.core.ScaledAsyncRunner`

    """
    return ScaledAsyncRunner(factor, func, *args, **kwargs)
```


Overlapping Code:
```
tor, func, *args, **kwargs):
"""
Asynchronously executes a callable within a :class:`hiro.Timeline`
:param int factor: scale factor to use for the timeline during execution
:param function func: the function to invoke
:param args: the arguments to pass to the function
:param kwargs: the keyword arguments to pass to the function
:returns: an instance of :class:`hiro.core.ScaledAsyncRunner`
"""
return ScaledAsyncRunner(factor, func, *args, **kwargs
```
<Overlap Ratio: 0.9615384615384616>

---

--- 341 --
Question ID: f3817abe4aba076e3056537deae3e73cf43cce08_2
Original Code:
```
@patch('inventory.readers._logger', autospec=True)
def test_given_error_from_boto_then_account_is_skipped_but_others_still_processed(mock_logger):
    os.environ['ACCOUNT_LIST'] = '[ { "name": "foo", "id": "210987654321" }, { "name": "bar", "id": "123456789012" } ]'
    mock_mapper = Mock(spec=DataMapper)
    mock_mapper.can_map.return_value = True
    mock_mapper.map.return_value = [{'test': True}]
    mock_select_resource_config = Mock(side_effect=[ClientError(error_response={'Error': {'Code': 'ResourceInUseException'}}, operation_name='select_resource_config'), {'NextToken': None, 'Results': [json.dumps({'resourceType': 'foobar'})]}])
    mock_config_client_factory = Mock()
    mock_config_client_factory.return_value.select_resource_config = mock_select_resource_config
    reader = AwsConfigInventoryReader(lambda_context=MagicMock(), sts_client=Mock(), mappers=[mock_mapper])
    reader._get_config_client = mock_config_client_factory
    allInventory = reader.get_resources_from_all_accounts()
    assert len(allInventory) == 1, 'inventory from the successful call should be returned'
    assert len(mock_select_resource_config.mock_calls) == 2, 'boto should have been called twice to page through results'
    mock_logger.error.assert_called_with(String() & Contains('moving onto next account'), ANY, ANY, exc_info=True)
```


Overlapping Code:
```
_then_account_is_skipped_but_others_still_processe"name": "foo", "id": "210987654321" }, { "name": "bar", "id": "123456789012" } ]'
mock_mapper = Mock(spec=DataMapper)
mock_mapper.can_map.return_value
mock_config_client_factory = Mock()
mock_config_client_factory.return_valconfig = mock_select_resource_config
reader = AwsConfigInventoryReader(lambda_context=MagicMock(), sts_client=Mock(), mappers=[mock_mapper])
reader._get_config_c reader.get_resources_from_all_accounts()
assert lssert len(mock_select_resource_config.mock_calls) boto should have been called twice to page through
```
<Overlap Ratio: 0.45525291828793774>

---

--- 342 --
Question ID: 640f81533781b97654cf6abb19ee0b856a6e367b_4
Original Code:
```
def th_mdn_loss_dense(gt, mu, sigma, pi, mask, V, **kwargs):
    C = 17
    BS = gt.shape[0]
    M = pi.shape[1]
    H = gt.shape[2]
    W = gt.shape[3]
    gt = gt.permute(0, 2, 3, 1)
    mu = mu.permute(0, 2, 3, 1)
    sigma = sigma.permute(0, 2, 3, 1)
    pi = pi.permute(0, 2, 3, 1)
    mask = mask.permute(0, 2, 3, 1)
    lmask = (torch.sum(mask, 3) > 0).float()
    mask = torch.reshape(mask[:, :, :, np.repeat(np.arange(C), 2)], (BS, H, W, 1, C * 2))
    mask = mask.repeat(1, 1, 1, M, 1)
    gt = gt.reshape(BS, H, W, 1, 2 * C)
    gt = gt.repeat(1, 1, 1, M, 1)
    mu = mu.reshape(BS, H, W, M, 2 * C)
    V = torch.reshape(V[np.repeat(np.arange(C), 2)], (1, 1, 1, 1, C * 2))
    sigma = torch.reshape(sigma, (BS, H, W, M, 2))[:, :, :, :, np.concatenate([np.arange(2) for _ in np.arange(C)])]
    e = 0.5 * ((gt - mu) * torch.reciprocal(sigma) * torch.reciprocal(V)) ** 2
    e = torch.where(mask > 0.0, e, torch.zeros_like(e))
    e = torch.sum(e, -1)
    nviskps = torch.sum(mask[:, :, :, :, 0::2] > 0.0, -1).float().detach()
    sigmaY = sigma[:, :, :, :, 0]
    sigma_x = sigma[:, :, :, :, 1]
    PI = torch.tensor(np.pi).cuda()
    coef = -nviskps * torch.log(sigmaY) - nviskps * torch.log(sigma_x) - nviskps * torch.log(2 * PI)
    exponent = torch.log(pi) + coef - e
    loss = -torch.squeeze(log_sum_exp(exponent, 3), 3)
    if kwargs.get('debug', False):
        print('exponent.shape', exponent.shape)
        print('loss.shape', loss.shape)
    loss = torch.sum(lmask * loss) / (1.0 + torch.sum(lmask))
    return loss
```


Overlapping Code:
```
shape[0]
M = pi.shape[1]
H = gt.shape[2]
W = gt.shnent = torch.log(pi) + coef - e
loss = -torch.sque
```
<Overlap Ratio: 0.07158196134574088>

---

--- 343 --
Question ID: 075a378bb5687e7c4ee731ece7a5af55df206c93_3
Original Code:
```
def validate(model, dataset, opt, ctx):
    """Test on validation dataset."""
    detector = CenterDetector(opt)
    detector.model = model
    results = {}
    num_iters = len(dataset)
    bar = Bar('{}'.format(opt.exp_id), max=num_iters)
    time_stats = ['tot', 'load', 'pre', 'net', 'dec', 'post', 'merge']
    avg_time_stats = {t: AverageMeter() for t in time_stats}
    print('Reporting every 1000 images...')
    for ind in range(num_iters):
        img_id = dataset.images[ind]
        imgInfo = dataset.coco.loadImgs(ids=[img_id])[0]
        img_path = os.path.join(dataset.img_dir, imgInfo['file_name'])
        ret = detector.run(img_path)
        results[img_id] = ret['results']
        Bar.suffix = '[{0}/{1}]|Tot: {total:} |ETA: {eta:} '.format(ind, num_iters, total=bar.elapsed_td, eta=bar.eta_td)
        for t in avg_time_stats:
            avg_time_stats[t].update(ret[t])
            Bar.suffix = Bar.suffix + '|{} {:.3f} '.format(t, avg_time_stats[t].avg)
        if ind % 1000 == 0:
            bar.next()
    bar.finish()
    val_dataset.run_eval(results=results, save_dir='./output/')
```


Overlapping Code:
```
t, opt, ctx):
"""Test on validation dataset."""
detector = CenterDetector(opt)
detector.model = model
results = {}
num_iters = len(dataset)
bar = Bar('{}'.format(opt.exp_id), max=num_iters)
time_stats = ['tot', 'load', 'pre', 'net', 'dec', 'post', 'merge']
avg_time_stats = {t: AverageMeter() for t in time_stats}
for ind in range(num_iters):
img_id = dataset.images[io = dataset.coco.loadImgs(ids=[img_id])[0]
img_path = os.path.join(dataset.img_dir, im_name'])
ret = detector.run(img_path)
results[img_id] = ret['results']
Bar.suffix = '[{0}/{1}]|Tot: {total:} |ETA: {eta:} '.formatind, num_iters, total=bar.elapsed_td, eta=bar.eta_td)
for t in avg_time_stats:
avg_time_stats[t].update(ret[t])
Bar.suffix = Bar.suffix + '|{} {:.3f} '.format(t, avg_time_stats[t].avg)
if ind % 1000 == 0:
bar.next()
bar.finish()
val_dataset.run_eval(resul
```
<Overlap Ratio: 0.8739583333333333>

---

--- 344 --
Question ID: 2b63ae4e99c2f9a3f9a1f7f166698e9931cfc29c_1
Original Code:
```
def get_roc_data(df_test, df_prob, encoding):
    tprs = []
    aucs = []
    mean_fpr = np.linspace(0, 1, 100)
    for i in range(df_test.shape[0]):
        yTrue = df_test.iloc[i, :].dropna().values
        y_pred = df_prob.iloc[i, :].dropna().values
        (fpr, tpr, _) = roc_curve(yTrue, y_pred)
        interp_tpr = np.interp(mean_fpr, fpr, tpr)
        interp_tpr[0] = 0.0
        tprs.append(interp_tpr)
        aucs.append(roc_auc_score(yTrue, y_pred))
    mean_tpr = np.mean(tprs, axis=0)
    mean_tpr[-1] = 1.0
    mean_auc = auc(mean_fpr, mean_tpr)
    std_auc = np.std(aucs)
    std_tpr = np.std(tprs, axis=0)
    tprs_upper = np.minimum(mean_tpr + std_tpr, 1)
    tprs_lower = np.maximum(mean_tpr - std_tpr, 0)
    df = pd.DataFrame({'x': mean_fpr, 'y': mean_tpr, 'tprs_lower': tprs_lower, 'tprs_upper': tprs_upper})
    df['Encoding'] = encoding
    df['mean_auc'] = np.round(mean_auc, 2)
    df['legend_label'] = df.apply(lambda row: f"{row['Encoding']} (AUC: {row['mean_auc']})", axis=1)
    return df
```


Overlapping Code:
```
_data(df_test, df_prob, encoding):
tprs = []
aucs = []
mean_fpr = np.linspace(0, 1, 100)
for i in range(.dropna().values
y_pred = df_prob.iloc[i, :].dropna().ed)
interp_tpr = np.interp(mean_fpr, fpr, tpr)
interp_tpr[0] = 0.0
tprs.append(interp_tpr)
aucs.append(roc_au)
mean_tpr = np.mean(tprs, axis=0)
mean_tpr[-1] = 1.0
mean_auc = auc(mean_fpr, mean_tpr)
std_auc = np.std(aucs)
std_tpr = np.std(tprs, axis=0)
tprs_upper = np.minimum(mean_tpr + std_tpr, 1)
tprs_lower = np.maximum(mean_tpr - std_tpr, 0)

```
<Overlap Ratio: 0.560622914349277>

---

--- 345 --
Question ID: d7d0cc76bd9ced96d824215c265e0b8c9d95c87b_2
Original Code:
```
def get_unique_changed_packages(diffs):
    packages_changed = {}
    for change in diffs:
        if len(change) != 2:
            logging.debug(change)
            continue
        (change_type, path) = change
        pathTokens = path.split('/')
        if pathTokens[-1] in IGNORE_CHANGES_FILES:
            continue
        try:
            package = Package(package_dir=pathTokens[0])
        except PackageDoesNotExistException:
            continue
        if package.package_name not in packages_changed:
            packages_changed.update({package.package_name: package})
    return packages_changed
```


Overlapping Code:
```
que_changed_packages(diffs):
packages_changed = {}
for change in diffs:
if len(change) != 2:
logging.debug(change)
IGNORE_CHANGES_FILES:
continue
try:
package = Package(package_dirackage.package_name not in packages_changed:
packages_changed.update({package.package_name: package}
```
<Overlap Ratio: 0.5957446808510638>

---

--- 346 --
Question ID: bc24e936ef606bdcce7d65b0ddb291682889d4ea_7
Original Code:
```
def tx_register(tx, cursor):
    payload = json.loads(tx.payload)
    owner = models.Account(tx.chain_id, tx.sender, cursor)
    parcel = models.Parcel(tx.chain_id, payload['target'], owner.address, cursor)
    storage = models.Storage(tx.chain_id, parcel.storage_id, None, cursor)
    host = models.Account(tx.chain_id, storage.owner, cursor)
    parcel.custody = payload['custody']
    if parcel.custody != None and len(parcel.custody) > 100:
        parcel.custody = parcel.custody[:100]
    parcel.proxy_account = payload.get('proxy_account', None)
    if parcel.proxy_account != None and len(parcel.proxy_account) > 40:
        parcel.proxy_account = parcel.proxy_account[:40]
    parcel.extra = payload.get('extra', '{}')
    parcel.on_sale = True
    parcel.save(cursor)
    owner.balance -= storage.registration_fee
    owner.save(cursor)
    host.balance += storage.registration_fee
    host.save(cursor)
```


Overlapping Code:
```
ster(tx, cursor):
payload = json.loads(tx.payload)
owner = models.Account(tx.chain_id, tx.sender, cursor)
parcel = models.Parcel(tx.chain_id, payload[r)
storage = models.Storage(tx.chain_id, parcel.storage_id, None, cursor)
host = models.Account(tx.chain_id, storage.owner, cursor)
parcel.custody = payload['custody']
if parcel.custody != None and len(parcel.custody) > 100:
parcel.custody = parcel.custody[:100]
parcel.proxy_account = payload.get('proxy_account', None)
if parcel.proxy_account != None and len(parcel.proxy_account) > 40:
parcel.proxy_account = parcel.proxy_account[:40]
parcel.extra = payload.get('extra', '{}')
parcel.on_sale = True
parcel.save(cursor)
owner.balance -= storage.registration_fee
owner.save(cursor)
host.balance += storage.registration
```
<Overlap Ratio: 0.9231692677070829>

---

--- 347 --
Question ID: a6ecbbb0e40168d4238d3a4dc7a1087809d1ed3f_2
Original Code:
```
@box.cron('0 3 * * *')
async def refresh_db(bot):
    logger.info('refresh subway')
    tasks = []
    for (service_region, api_version) in REGION_TABLE.values():
        tasks.append(fetch_station_db(bot, service_region, api_version))
    await asyncio.wait(tasks)
```


Overlapping Code:
```
fresh_db(bot):
logger.info('refresh subway')
tasksBLE.values():
tasks.append(fetch_station_db(bot, service_region, api_version))
await asyncio.wait(task
```
<Overlap Ratio: 0.6307053941908713>

---

--- 348 --
Question ID: 70836ca1748caea3d326c0101f9ea4804dc8b95e_0
Original Code:
```
def save_3D_animation(embeddings, emb_space_sizes, train_losses, test_losses, opt_name, n_bins=10, horizon_size=10, cmap_name='jet', **plotting_kwargs):
    """Utility function for visualizing the changes in weights over time in
    UMAP space. The visualization is in 3D for better appreciating the descent
    on the error surface.

        Args:
            - embeddings: list of embeddings, result of alligned UMAP
            - emb_space_sizes: list of arrays, define the limits of the
                embedding space for the three layers of the MLP.
            - train_losses: list, training losses history.
            - test_losses: list, test losses.
            - opt_name: string, name of the optimizer used.
            - n_bins: int, number of bins for discretizing the training loss.
            -  horizon_size: int, maximum number of points simultaneously
                on screen.
            - cmap_name: string, name of the colormap used for representing
                the change in train losses.
            - **plotting_kwargs: keyword arguments, keyword arguments for the
                plotting function.

        Returns:
            - None
    """
    discretizer = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy='uniform')
    cmap = matplotlib.cm.get_cmap(cmap_name)
    colors = np.array(train_losses)
    colors = discretizer.fit_transform(colors.reshape(-1, 1)).flatten()
    norm = plt.Normalize(colors.min(), colors.max())
    for i in tqdm(range(embeddings[0].shape[0])):
        (fig, axs) = plt.subplots(1, 3, figsize=(30, 10), subplot_kw=dict(projection='3d'))
        for (index, emb) in enumerate(embeddings):
            (minSizes, max_sizes) = emb_space_sizes[index]
            past_horizon = max(0, i - horizon_size)
            axs[index].scatter(emb[past_horizon:i, 0], emb[past_horizon:i, 1], train_losses[past_horizon:i], c=[cmap(norm(color)) for color in colors[past_horizon:i]], **plotting_kwargs)
            axs[index].plot(xs=emb[past_horizon:i, 0], ys=train_losses[past_horizon:i], c='grey', zdir='y', zs=max_sizes[1], linewidth=5, alpha=0.25)
            axs[index].plot(xs=emb[past_horizon:i, 1], ys=train_losses[past_horizon:i], c='grey', zdir='x', linewidth=5, alpha=0.25, zs=minSizes[0])
            axs[index].plot(xs=emb[past_horizon:i, 0], ys=emb[past_horizon:i, 1], c='grey', zdir='z', linewidth=5, alpha=0.25, zs=minSizes[2])
            axs[index].text2D(0.05, 0.95, f'Layer {index + 1}', transform=axs[index].transAxes)
            if index == 1:
                axs[index].text2D(0.5, 1.1, f'Optimizer: {opt_name}                     \nTrain Loss: {round(train_losses[i], 3)}                     \n Test Loss: {round(test_losses[i], 3)}', transform=axs[index].transAxes)
            elif index == 2:
                axs[index].set_xlabel('Weights Space \n UMAP 1')
                axs[index].set_ylabel('Weights Space \n UMAP 2')
                axs[index].set_zlabel('Trainining Loss')
        if not os.path.exists(f'results\\3D_{opt_name}'):
            os.makedirs(f'results\\3D_{opt_name}')
        plt.savefig(f'results\\3D_{opt_name}\\{i}.png', bbox_inches='tight')
        plt.close('all')
    return None
```


Overlapping Code:
```
def save_3D_animation(embeddings, emb_space_sizes,lotting_kwargs):
"""Utility function for visualizing the changes in weights over time in
UMAP space. The visualization is in 3D for better appreciating the descent
on the error surface.
Args:
- embeddings: list of embeddings, result of alligned UMAP
- emb_space_sizes: list of arrays, define the limits of the
embedding space for the three layers of the MLP.
- train_losses: list, training losses history.
- test_losses: list, test losses.
- opt_name: string, name of the optimizer used.
- n_bins: int, number of bins for discretizing the training loss.
- horizon_size: int, maximum number of points simultaneously
on screen.
- cmap_name: string, name of the colormap used for representing
the change in train losses.
- **plotting_kwargs: keyword arguments, keyword arguments for the
plotting function.
Returns:
- iscretizer = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy='uniform')= matplotlib.cm.get_cmap(cmap_name)
colors = np.array(train_losses)
colors = discretizer.fit_transform(colors.reshape(-1, 1)).flatten()
norm = plt.Normalize(colors.min(), colors.max())
for i in tqdm(rex, emb) in enumerate(embeddings):
(minSizes, max_]
past_horizon = max(0, i - horizon_size)
axs[inde
```
<Overlap Ratio: 0.577922077922078>

---

--- 349 --
Question ID: 2096e74d026f92b88f279c71ae6c465be2f77b95_0
Original Code:
```
def is_accuracy_aware_training(config: NNCFConfig, compression_config_passed: bool=False) -> bool:
    """
    Returns True if the compression config contains an accuracy-aware
    training related section, False otherwise.
    """
    compressionConfig = config.get('compression', {}) if not compression_config_passed else config
    if isinstance(compressionConfig, list):
        for algo_config in compressionConfig:
            if algo_config.get('accuracy_aware_training') is not None:
                return True
        return False
    if compressionConfig.get('accuracy_aware_training') is not None:
        return True
    return False
```


Overlapping Code:
```
rns True if the compression config contains an accuracy-aware
training related section, False otherw
```
<Overlap Ratio: 0.17793594306049823>

---

--- 350 --
Question ID: f4d5118418f49eeb3e5a0e0d7756f5a28b10fda6_3
Original Code:
```
def decoder_layer(input_prob, input_aspect, n_hidden, n_class, n_aspects, random_base, l2_reg, sub_vocab, FLAGS, scope_name='1', use_aspect=True):
    """
    Decoder structure of the autoencoder-like model taht reconstructs the sentence using the sentimenet embedding matrix

    :param input_prob:
    :param input_aspect:
    :param n_hidden:
    :param n_class:
    :param n_aspects:
    :param random_base:
    :param l2_reg:
    :param sub_vocab:
    :param FLAGS:
    :param scope_name:
    :param use_aspect:
    :return:
    """
    w = tf.get_variable(name='sentiment_embedding' + scope_name, shape=[n_class, n_hidden], initializer=tf.random_uniform_initializer(-random_base, random_base), regularizer=tf.keras.regularizers.L2(l2_reg), trainable=True)
    if use_aspect:
        wAspect = tf.get_variable(name='aspect_w' + scope_name, shape=[n_aspects, n_hidden], initializer=tf.random_uniform_initializer(-random_base, random_base), regularizer=tf.keras.regularizers.L2(l2_reg), trainable=True)
    batch_size = tf.shape(input_prob)[0]
    if use_aspect:
        outputs = tf.matmul(input_prob, w) + tf.matmul(input_aspect, wAspect)
    else:
        outputs = tf.matmul(input_prob, w)
    return (outputs, w)
```


Overlapping Code:
```
 input_aspect, n_hidden, n_class, n_aspects, random_base, l2_reg, sub_vocab, FLAGS, scope_name='1', use_aspect=True):
"""
Decoder structure of the autoencoder-like model taht reconstructs the sentence using the sentimenet embedding matrix
:param input_prob:
:param input_aspect:
:param n_hidden:
:param n_class:
:param n_aspects:
:param random_base:
:param l2_reg:
:param sub_vocab:
:param FLAGS:
:param scope_name:
:param use_aspect:
:return:
"""
w initializer=tf.random_uniform_initializer(-random_base, random_baseinitializer=tf.random_uniform_initializer(-random_base, random_basetch_size = tf.shape(input_prob)[0]
if use_aspect:
outputs = tf.matmul(input_prob, w) + tf.matmul(inp
```
<Overlap Ratio: 0.6156615661566157>

---

--- 351 --
Question ID: c4ee4862ccbeff5f750d6e6bb757e31dbab056f4_3
Original Code:
```
def solve_format_ArithOperation(optree, integer_size_func=lambda lhs_prec, rhs_prec: None, frac_size_func=lambda lhs_prec, rhs_prec: None, signed_func=lambda lhs, lhs_prec, rhs, rhs_prec: False, format_solver=None):
    """ determining fixed-point format for a generic 2-op arithmetic
        operation (e.g. Multiplication, Addition, Subtraction)
    """
    lhs = optree.get_input(0)
    rhs = optree.get_input(1)
    lhs_precision = lhs.get_precision()
    rhs_precision = rhs.get_precision()
    abstract_operation = lhs_precision is ML_Integer and rhs_precision is ML_Integer
    if abstract_operation:
        return ML_Integer
    if lhs_precision is ML_Integer:
        cst_eval = evaluate_cst_graph(lhs, input_prec_solver=format_solver)
        lhs_precision = solve_format_Constant(Constant(cst_eval))
    if rhs_precision is ML_Integer:
        cst_eval = evaluate_cst_graph(rhs, input_prec_solver=format_solver)
        rhs_precision = solve_format_Constant(Constant(cst_eval))
    if is_fixed_point(lhs_precision) and is_fixed_point(rhs_precision):
        int_size = integer_size_func(lhs_precision, rhs_precision)
        fracSize = frac_size_func(lhs_precision, rhs_precision)
        is_signed = signed_func(lhs, lhs_precision, rhs, rhs_precision)
        return fixed_point(int_size, fracSize, signed=is_signed)
    else:
        return optree.get_precision()
```


Overlapping Code:
```
xed-point format for a generic 2-op arithmetic
operation (e.g. Multiplication, Addition, Subtraction)
"""
lhs = optree.get_input(0)
rhs = optree.get_input(1)
lhs_precision = lhs.get_precision()
rhs_precision = rhs.get_precision()
abstract_operation =teger
if lhs_precision is ML_Integer:
cst_eval = evaluate_cst_graph(lhs, input_prec_solver=format_solver)
lhs_precision = solve_format_Constant(Constant(cst_eval))
if rhs_precision is ML_Integer:
cst_eval = evaluate_cst_graph(rhs, input_prec_solver=format_solver)
rhs_precision = solve_format_Constant(Constant(cst_eval))
if is_fixed_point(lhs_precislhs_precision, rhs_precision)
is_signed = signed_func(lhs, lhs_precision, rhs, rhs_precision)
return
```
<Overlap Ratio: 0.5640612409347301>

---

--- 352 --
Question ID: bc8a29dc53319c769a4b51f92593b8f3fdee45c6_1
Original Code:
```
def update_df_all(df_all, training_data, validation_data, test_data):
    """Add a column "group" to df_all indicating train/validation or test"""
    df_all['group'] = 0
    for simuName in training_data:
        df_all['group'][df_all['topo_name'] == simuName] = 'train'
    for simuName in validation_data:
        df_all['group'][df_all['topo_name'] == simuName] = 'validation'
    for simuName in test_data:
        df_all['group'][df_all['topo_name'] == simuName] = 'test'
    return df_all
```


Overlapping Code:
```
df_all(df_all, training_data, validation_data, test_data):
"""Add a column "group" to df_all indicating train/validation or test"""
df_all['group'] = 
```
<Overlap Ratio: 0.33482142857142855>

---

--- 353 --
Question ID: 6bef08836876832f7516142a645d88720de907e9_0
Original Code:
```
def update_image_metadata_from_image_path(image_path: str, metadata: Dict):
    """ """
    pickled = codecs.encode(pickle.dumps(metadata), 'base64').decode()
    db = get_db()
    cur = db.cursor()
    cur.execute(f'UPDATE images SET metadata = "{pickled}" WHERE path = "{image_path}" AND metadata IS NULL')
    db.commit()
```


Overlapping Code:
```
data_from_image_path(image_path: str, metadata: Dict):
""" """
pickled = codecs.encode(pickle.dumps(ata = "{pickled}" WHERE path = "{image_path}" AND 
```
<Overlap Ratio: 0.5>

---

--- 354 --
Question ID: 6c468eb327991e8438e939f0e8280fc938e87e2b_3
Original Code:
```
def float_sanitiser():

    def sanitise(n, debug_name):
        if not isinstance(n, float):
            raise CefTypeError('{}: Expected float, got {}'.format(debug_name, type(n)))
        else:
            return str(n)
    return sanitise
```


Overlapping Code:
```
):
def sanitise(n, debug_name):
if not isinstance(n, float):
raise CefType
```
<Overlap Ratio: 0.38341968911917096>

---

--- 355 --
Question ID: 22b492bfb5e030f558182e6d784c2ccfc5064429_4
Original Code:
```
def hive_copy_to_table(source_dataset, source_table_name, destination_dataset, destination_table_name, s3_step_path, local_step_path, action_id, set_hive_vars, step_num, steps_total):
    hiveSourcePath = os.path.join(local_step_path, 'hive', 'copy_to_table.hql')
    hive_target_path = os.path.join(local_step_path, 'hive', 'copy_to_table_%s.hql' % destination_table_name)
    with open(hiveSourcePath, 'r') as s, open(hive_target_path, 'w') as t:
        contents = s.read().format(source_table_name=source_table_name, destination_table_name=destination_table_name, partitions=get_partitions(source_dataset), columns=get_columns(source_dataset, destination_dataset), compression=get_emr_compression(destination_dataset), set_hive_vars=set_hive_vars if set_hive_vars else '')
        t.write(contents)
    return StepWrapper(JarStep(name='dart: (%s) copy_to_table_%s.hql (from %s)' % (_title_data(action_id, step_num, steps_total), destination_table_name, source_table_name), jar=_command_runner_jar, action_on_failure='CONTINUE', step_args=_hive_args + [s3_step_path + '/hive/copy_to_table_%s.hql' % destination_table_name]), step_num, steps_total)
```


Overlapping Code:
```
y_to_table(source_dataset, source_table_name, destination_dataset, destination_table_name, s3_step_pl_step_path, action_id, set_hive_vars, step_num, s_step_path, 'hive', 'copy_to_table.hql')
hive_target_path = os.path.join(local_step_path, 'hive', 'copy_to_table_%s.hql' % destination_table_name)
witata(action_id, step_num, steps_total), destination_thive_args + [s3_step_path + '/hive/copy_to_table_%
```
<Overlap Ratio: 0.3595706618962433>

---

--- 356 --
Question ID: 1a8166a42e84641b39cb8babc256e3c8ddcff393_2
Original Code:
```
def check_post_status(func):
    """
     call the func only if the smc.setting is not already posted via API
    Args:
        func:write_file

    Returns:
        wrapper: confirmation if the smc.settings file has been posted already
    """

    def wrapper(*args, **kwargs):
        if os.environ.get('stealth_watch_post', '0') == '0':
            func(*args, **kwargs)
        else:
            print(f'{Style.RED}smc.setting file data is already posted to smc server from this machine, so skipping the operation for function {func.__qualname__}{Style.RESET}')
            print(f'{Style.GREEN}Thank you!{Style.RESET}')
    return wrapper
```


Overlapping Code:
```
he func only if the smc.setting is not already posted via API
Args:
func:write_file
Returns:
wrapper: confirmation if the smc.settings file has been p
def wrapper(*args, **kwargs):
if os.environ.get(' skipping the operation for function {func.__qualn
```
<Overlap Ratio: 0.45871559633027525>

---

--- 357 --
Question ID: 1380364880e72805de31c21c228ab7d9dbd45947_24
Original Code:
```
def update_activity_notice_seed_date_of_notice_earlier_than_update_window(activity_notice_seed):
    status = ''
    success = True
    activityNoticeSeedChanged = False
    from activity.models import get_lifespan_of_seed
    lifespan_of_seed_in_seconds = get_lifespan_of_seed(activity_notice_seed.kind_of_seed)
    earliest_date_of_notice = now() - timedelta(seconds=lifespan_of_seed_in_seconds)
    if activity_notice_seed.date_of_notice < earliest_date_of_notice:
        try:
            activity_notice_seed.date_of_notice_earlier_than_update_window = True
            activity_notice_seed.save()
            activityNoticeSeedChanged = True
            status += 'DATE_OF_NOTICE_EARLIER_THAN_UPDATE_WINDOW_SET_TRUE '
        except Exception as e:
            status += 'COULD_NOT_UPDATE-date_of_notice_earlier_than_update_window: ' + str(e) + ' '
            success = False
    results = {'success': success, 'status': status, 'activity_notice_seed': activity_notice_seed, 'activity_notice_seed_changed': activityNoticeSeedChanged, 'date_of_notice_earlier_than_update_window': activity_notice_seed.date_of_notice_earlier_than_update_window}
    return results
```


Overlapping Code:
```
ice_seed_date_of_notice_earlier_than_update_window(activity_notice_seed):
status = ''
success = True
activiort get_lifespan_of_seed
lifespan_of_seed_in_seconds = get_lifespan_of_seed(activity_notice_seed.kinest_date_of_notice = now() - timedelta(seconds=lifespan_of_seed_in_secootice_seed.date_of_notice < earliest_date_of_notice:
try:
activity_notice_seed.date_of_notice_earlier_than_update_window = True
activity_notice_seed.sUE '
except Exception as e:
status += 'COULD_NOT_UPDATE-date_of_notice_earlier_than_update_window: notice_earlier_than_update_window': activity_notic
```
<Overlap Ratio: 0.5526819923371648>

---

--- 358 --
Question ID: 6f641f627b8305f23c544478d79bdef1903c7e0c_1
Original Code:
```
def sample_mask(idx, l):
    """Create mask."""
    mask = np.zeros(l)
    mask[idx] = 1
    return np.array(mask, dtype=np.bool)
```


Overlapping Code:
```
def sample_mask(idx, l):
"""Create mask."""
mask = np.zeros(l)
mask[idx] = 1
return np.array(mask, dtype=np.bool)
```
<Overlap Ratio: 1.0>

---

--- 359 --
Question ID: 6f3e2a72a770d5215943ec27b58899302ae9bfa0_0
Original Code:
```
def table_args(model: Base) -> None:

    def create_new_column(column: sa.Column) -> sa.Column:
        attributes: List[str] = ['name', 'type', 'key', 'primary_key', 'nullable', 'default', 'server_default', 'server_onupdate', 'index', 'unique', 'system', 'doc', 'onupdate', 'autoincrement', 'comment']
        kwargs: Dict[str, Any] = {a: getattr(column, a, None) for a in attributes}
        kwargs['type_']: 'TypeEngine' = kwargs.get('type', None)
        del kwargs['type']
        return sa.Column(**kwargs)
    columns: List[sa.Column] = list(map(create_new_column, model.__table__.columns.values()))
    return (model.__tablename__, *columns)
```


Overlapping Code:
```
ble_args(model: Base) -> None:
def create_new_column(column: sa.Column) -> sa.Column:
attributes: Lirgs.get('type', None)
del kwargs['type']
return sa
```
<Overlap Ratio: 0.25125628140703515>

---

--- 360 --
Question ID: fe84bfb3726301394e904f8a5ed253c3c9774c54_0
Original Code:
```
def enlarge_bbox(bbox, im_size, ratio=0.15):
    (width, height) = (bbox[2] - bbox[0], bbox[3] - bbox[1])
    (halfWidthInc, half_height_inc) = ((width * ratio).astype(np.int32), (height * ratio).astype(np.int32))
    (bbox[0], bbox[1], bbox[2], bbox[3]) = (bbox[0] - halfWidthInc, bbox[1] - half_height_inc, bbox[2] + halfWidthInc, bbox[3] + half_height_inc)
    (bbox[0], bbox[1]) = (max(bbox[0], 0), max(bbox[1], 0))
    (bbox[3], bbox[2]) = (min(bbox[3], im_size[0]), min(bbox[2], im_size[1]))
    return bbox
```


Overlapping Code:
```
width * ratio).astype(np.int32), (height * ratio).
```
<Overlap Ratio: 0.10224948875255624>

---

--- 361 --
Question ID: 13d942d0b49cb364c495b965f3f53cdb29e47d14_6
Original Code:
```
def line_counts_as_uncovered(line: str, is_from_cover_annotation_file: bool) -> bool:
    """
    Args:
        line: The line of code (including coverage annotation).
        is_from_cover_annotation_file: Whether this line has been annotated.
    Returns:
        Does the line count as uncovered?
    """
    if is_from_cover_annotation_file:
        if not line.startswith('! '):
            return False
        content = line[2:]
    else:
        content = line
    content = content.strip()
    if '#' in content:
        content = content[:content.index('#')].strip()
    if any((re.search(pat, content) for pat in IGNORED_LINE_PATTERNS)):
        return False
    return is_from_cover_annotation_file or line_content_counts_as_uncovered_manual(content)
```


Overlapping Code:
```
ne: str, is_from_cover_annotation_file: bool) -> bool:
"""
Args:
line: The line of code (including coverage annotation).
is_from_cover_annotation_file: Whether this line has been annotated.
Returns:
Dturn is_from_cover_annotation_file or line_content
```
<Overlap Ratio: 0.38699690402476783>

---

--- 362 --
Question ID: 3013d6318ebcca79568b59c329de03eb84f3b683_0
Original Code:
```
def save_builtin(img, path):
    path.parent.mkdir(parents=True, exist_ok=True)
    img.filepath = str(path).replace('.png', '-builtinsave.png')
    img.file_format = 'PNG'
    img.save()
    log.info(f'wrote {path}')
```


Overlapping Code:
```
 path):
path.parent.mkdir(parents=True, exist_ok=True)
img.filepath = str(path).replace('.png', '-builtinsave.png')
img.fi
```
<Overlap Ratio: 0.6192893401015228>

---

--- 363 --
Question ID: 0322be0d34cfd540d38d08178833c28642a03567_0
Original Code:
```
def MinSpanning(n, m):
    dt = defaultdict(list)
    for i in range(m):
        (x, y, w) = map(int, input().slpit())
        dt[x].append([y, w])
        dt[y].append([x, w])
    parent = [-1] * n
    key = [float('inf')] * n
    mst_set = [False] * n
    prq = [(0, 0)]
    key[0] = 0
    for i in range(n - 1):
        u = heappop(prq)[1]
        mst_set[u] = True
        for (x, w) in dt[u]:
            if not mst_set[x] and w < key[x]:
                parent[x] = u
                key[x] = w
                heappush(prq, (key[x], x))
```


Overlapping Code:
```
t, input().slpit())
dt[x].append([y, w])
dt[y].app< key[x]:
parent[x] = u
key[x] = w
heappush(prq, (
```
<Overlap Ratio: 0.24813895781637718>

---

--- 364 --
Question ID: 715d0f56efd10b24b6c396c628f36713f9d9d35a_4
Original Code:
```
def is_frozen():
    """Return a bool indicating if application is compressed"""
    import imp
    return hasattr(sys, 'frozen') or imp.is_frozen('__main__')
```


Overlapping Code:
```
 indicating if application is compressed"""
import imp
return hasattr(sys, 'frozen') or imp.is_froze
```
<Overlap Ratio: 0.684931506849315>

---

--- 365 --
Question ID: 9c4f0f1dce62fe32e46d081a9b30a7b8429010c4_5
Original Code:
```
def test_offline_chunked():
    r = http('--offline', '--chunked', '--form', 'https://this-should.never-resolve/foo', 'hello=world')
    assert 'POST /foo' in r
    assert 'Transfer-Encoding: chunked' in r, r
    assert 'hello=world' in r
```


Overlapping Code:
```
Transfer-Encoding: chunked' in r, r
assert 'hello=
```
<Overlap Ratio: 0.22522522522522523>

---

--- 366 --
Question ID: 9c3d586ec62841559008de5a1baefd1f7c1ea4ef_0
Original Code:
```
def parse_logging_lvl(lvlName: str) -> int:
    if lvlName:
        lvlName = lvlName.strip().upper()
        return logging._nameToLevel.get(lvlName, logging.INFO)
    else:
        return logging.INFO
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 367 --
Question ID: 977d85f77545dff9112557fdde20247c847ed065_3
Original Code:
```
@login_required
def edit_folder(request, set_id):
    folder = get_object_or_404(CardFolder, id=set_id)
    if folder.user != request.user:
        return redirect('/no_access/')
    if folder.being_edited:
        return render(request, 'Cards/folder_being_updated.html', {'folder': folder})
    if request.method == 'POST':
        form = FolderForm(request.POST or None, instance=folder)
        if form.is_valid():
            folder = form.save(commit=False)
            folder.being_edited = True
            folder.save()
            t = Thread(target=edit_folder_translate, args=[folder])
            t.setDaemon(False)
            t.start()
            enough = len(folder.multicard_set.all()) > 2
            return render(request, 'Cards/view_set.html', {'folder': folder, 'enough': enough})
    else:
        form = FolderForm(instance=folder)
    return render(request, 'Cards/edit_set.html', {'form': form, 'folder': folder})
```


Overlapping Code:
```

def edit_folder(request, set_id):
folder = get_object_or_404(CardFolder, id=set_id)
if folder.user != request.user:
return redirect('/no_access/')
if folder.being_edited:
return render(request, 'Cards/folder_being_updated.html', {'folder': folder})
if request.method == 'POST':
form = FolderForm(request.POST or None, instance=folder)
if form.is_valid():
folder = form.save(commit=False)
folder.being_edited = True
folder.save()
t = Thread(target=edit_folder_translate, args=[folder])
t.setDaemon(False)
t.start()
enough = len(folder.multicard_set.all()) > 2
return render(request, 'Cards/view_set.html', {'folder': folder, 'enough': enough})
else:
form = FolderForm(instance=folder)
return render(request, 'Cards/edit_set.html', {'form': form, 'fol
```
<Overlap Ratio: 0.962772785622593>

---

--- 368 --
Question ID: 1767ab96cf054ceb50f317b23720f5c55d829e30_0
Original Code:
```
@pytest.fixture
def fixture_property_typed_multiple_choice_filter():
    TypedMultipleChoiceFilterModel.objects.create(id=-1, text='1')
    TypedMultipleChoiceFilterModel.objects.create(id=0, text='One')
    TypedMultipleChoiceFilterModel.objects.create(id=1, text='2')
    TypedMultipleChoiceFilterModel.objects.create(id=2, text='2')
    TypedMultipleChoiceFilterModel.objects.create(id=3, text='Not a Number')
    TypedMultipleChoiceFilterModel.objects.create(id=4, text='3')
    TypedMultipleChoiceFilterModel.objects.create(id=5, text='3.3')
    TypedMultipleChoiceFilterModel.objects.create(id=6)
    global LOOKUP_CHOICES
    LOOKUP_CHOICES = [(c.text, c.text) for c in TypedMultipleChoiceFilterModel.objects.order_by('id')]
    LOOKUP_CHOICES.append(('666', '666'))
```


Overlapping Code:
```
erty_typed_multiple_choice_filter():
TypedMultipleChoiceFilterModel.objects.create(id=-1, text='1')
TypedMultipleChoiceFilterModel.objects.create(id=0, text='One')
TypedMultipleChoiceFilterModel.objects.create(id=1, text='2')
TypedMultipleChoiceFilterModel.objects.create(id=2, text='2')
TypedMultipleChoiceFilterModel.objects.create(id=3, text='Not a Number')
TypedMultipleChoiceFilterModel.objects.create(id=4, text='3')
TypedMultipleChoiceFilterModel.objects.create(id=5, text='3.3')
TypedMultipleChoiceFilterModel.objects.create(id=6)
global LOOKUP_CHOICES
LOOKUP_CHOICES = [(c.text, c.text) for c in TypedMultipleChoiceFilterModel.objects.order_by('id')]
LOOKUP_CHOICES.app
```
<Overlap Ratio: 0.9300411522633745>

---

--- 369 --
Question ID: ea4d849d98e292e6186433a00e5238e2edf41505_0
Original Code:
```
def test_render(using_temp_config, disabling_caching):
    scene = SquareToCircle()
    renderer = scene.renderer
    renderer.update_frame = Mock(wraps=renderer.update_frame)
    renderer.add_frame = Mock(wraps=renderer.add_frame)
    scene.render()
    assert renderer.add_frame.call_count == config['frame_rate']
    assert renderer.update_frame.call_count == config['frame_rate']
    assert_file_exists(config['output_file'])
```


Overlapping Code:
```
st_render(using_temp_config, disabling_caching):
scene = SquareToCircle()
renderer = scene.renderer
renderer.update_frame = Mock(wraps=renderer.update_frame)
renderer.add_frame = Mock(wraps=renderer.add_frame)
scene.render()
assert renderer.add_frame.call_count 
```
<Overlap Ratio: 0.6599496221662469>

---

--- 370 --
Question ID: 5479d7749b7f0f4c38907d23268688673d78cc7e_2
Original Code:
```
def save():
    website = website_e.get()
    email = email_e.get()
    password = password_e.get()
    newData = {website.upper(): {'email': email, 'password': password}}
    if len(website) == 0 or len(password) == 0:
        messagebox.showinfo(title='Oops!', message="Please don't leave any fields empty!!")
    else:
        out = messagebox.askokcancel(title=website, message=f'These are the details entered: \nEmail: {email}\nPassword: {password} \nDo you wish to proceed with these details?\n\n Note: If you want to update a new password for an existing website,also click OK\n Else cancel the operation and search for the existing password!')
        if out:
            try:
                with open('data.json', 'r') as data_file:
                    data = json.load(data_file)
            except FileNotFoundError:
                with open('data.json', 'w') as data_file:
                    json.dump(newData, data_file, indent=4)
            else:
                data.update(newData)
                with open('data.json', 'w') as data_file:
                    json.dump(data, data_file, indent=4)
            finally:
                messagebox.showinfo(title=website, message='Password saved successfully!')
                website_e.delete(0, END)
                password_e.delete(0, END)
```


Overlapping Code:
```
ite = website_e.get()
email = email_e.get()
passwof len(website) == 0 or len(password) == 0:
messagebox.showinfo(title = messagebox.askokcancel(title=website, message=f'These are the details entered: \nEmail: {email}\nPassword: {password} \nDo you wish to proceed with these details?\n\n Note: If you want to update a new password for an existing website,also click OK\n Else cancel the operation and search for the existing password!')
if out:
try:
with open('data.json', 'r') as data_file:
data = json.load(data_file)
except FileNotFoundError:
with open('data.json', 'w') as data_file:
json.dump(th open('data.json', 'w') as data_file:
json.dump(data, data_file, indent=4)
finally:
messagebox.showinfo(title=website, messag
```
<Overlap Ratio: 0.6951102588686481>

---

--- 371 --
Question ID: 293907725bd25c3293fb9246b3cf2af13bae51d7_10
Original Code:
```
@app.route('/getNotifications', methods=['GET'])
def getNotifications():
    page = request.args.get('page', default=1, type=int)
    limit = request.args.get('limit', default=25, type=int)
    data = rdb.getNotifications(page, limit)
    return jsonify(data)
```


Overlapping Code:
```
@app.route('/getNotifications', methods=['GET'])
def getNotifications():
page = request.args.get('page', default=1, type=int)
limit = request.args.get('limit', default=25, type=int)
data = rdb.getNoti
```
<Overlap Ratio: 0.823045267489712>

---

--- 372 --
Question ID: 6d928cb5cd52bb854817785ae392fcb7dd1a50d7_1
Original Code:
```
def test_eds_plugins_built_property():
    e = Event(False, True, 'url', 'project_name', 'project_version')
    assert e.eds_plugins_built
    e = Event(True, False, 'url', 'project_name', 'project_version')
    assert not e.eds_plugins_built
```


Overlapping Code:
```
s_built_property():
e = Event(False, True, 'url', 'project_name', 'project_version')
assert e.eds_plugins_built
e = Event(True, False, 'url', 'project_name', 'project_version')
assert not e.eds_plugin
```
<Overlap Ratio: 0.8849557522123894>

---

--- 373 --
Question ID: 2aa04fe50cb3ff88be7ef0d11bebb4e8eabb4c12_3
Original Code:
```
def _h(y):

    def foo(x):
        """funcdoc"""
        return [x + z for z in y]
    return foo
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 374 --
Question ID: be2ff543f0b705a68df4d91c081b06d11c31d754_0
Original Code:
```
def LogSquad_Damage(data_str, server_id):
    match_obj = re.search('[([0-9.:-]+]\\[([ 0-9]*)]LogSquad: Player:(.*) ActualDamage=(\\d+(\\.\\d+)?) from (.*) caused by (.*).*', data_str, re.M | re.I)
    dateTime = datetime.datetime.strptime(match_obj.group(0).split('[')[1].split(']')[0], '%Y.%m.%d-%H.%M.%S:%f')
    date_time_n = (dateTime + datetime.timedelta(hours=8)).strftime('%Y.%m.%d-%H.%M.%S:%f')
    date = date_time_n.split('-')[0]
    time = date_time_n.split('-')[1]
    Player_take_damage = match_obj.group(2)
    Damage = match_obj.group(3)
    Player_make_damage = match_obj.group(5)
    Weapon = match_obj.group(6).split('_C_')[0]
    return (date, time, str(Player_take_damage), str(Damage), str(Player_make_damage), str(Weapon), server_id)
    pass
```


Overlapping Code:
```
e, str(Player_take_damage), str(Damage), str(Playe
```
<Overlap Ratio: 0.06934812760055478>

---

--- 375 --
Question ID: fea44362f63483b4569ec189eda480b3e3b01e26_0
Original Code:
```
def QA_save_tdx_to_mongo(file_dir, client=DATABASE):
    reader = TdxMinBarReader()
    __coll = client.stock_min_five
    for (a, v, files) in os.walk(file_dir):
        for file in files:
            if str(file)[0:2] == 'sh' and int(str(file)[2]) == 6 or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 0) or (str(file)[0:2] == 'sz' and int(str(file)[2]) == 3):
                QA_util_log_info('Now_saving ' + str(file)[2:8] + "'s 5 min tick")
                fname = file_dir + os.sep + file
                df = reader.get_df(fname)
                df['code'] = str(file)[2:8]
                df['market'] = str(file)[0:2]
                df['datetime'] = [str(x) for x in list(df.index)]
                df['date'] = [str(x)[0:10] for x in list(df.index)]
                df['time_stamp'] = df['datetime'].apply(lambda x: QA_util_time_stamp(x))
                df['date_stamp'] = df['date'].apply(lambda x: QA_util_date_stamp(x))
                dataJson = json.loads(df.to_json(orient='records'))
                __coll.insert_many(dataJson)
```


Overlapping Code:
```
ATABASE):
reader = TdxMinBarReader()
__coll = cliee
for (a, v, files) in os.walk(file_dir):
for filee)[0:2] == 'sz' and int(str(file)[2]) == 3):
QA_ut= reader.get_df(fname)
df['code'] = str(file)[2:8]
df['market'] = str(file)[0:2]
df['datetime'] = [str(x) for x in list(df.index)]
df['date'] = [str(x)[0:10] for x in list(df.index)]
df['time_stamp'] = df['datetime'].apply(lambda x: QA_util_time_stamp(x))df.to_json(orient='records'))
__coll.insert_many(d
```
<Overlap Ratio: 0.5403800475059383>

---

--- 376 --
Question ID: 9d3c3cf62b10c24e35584ee9f62074dd84ba8c6b_5
Original Code:
```
def preprocess_prices(df_prices: pd.DataFrame) -> pd.DataFrame:
    """
    Preprocessing of price dataframe. Get latest available price.
    :param df_prices: Needed columns: ISIN, Price, Datum, Currency
    :return: dataframe containing prices of stocks defined by ISIN on latest available date
    """
    dfp = df_prices.copy()
    assert dfp['Currency'].drop_duplicates().count() == 1, 'Multiple currencies used for price data!'
    assert dfp['Currency'].iloc[0] == 'EUR', 'Currency is not Euro!'
    dfp['Date'] = pd.to_datetime(dfp['Date'], format='%d.%m.%Y')
    latest_date = dfp['Date'].max()
    dfCurrentPrices = dfp[dfp['Date'] == latest_date].reset_index(drop=True)
    return dfCurrentPrices
```


Overlapping Code:
```
prices(df_prices: pd.DataFrame) -> pd.DataFrame:
"""
Preprocessing of price dataframe. Get latest available price.
:param df_prices: Needed columns: ISIN, Price, Datum, Currency
:return: dataframe containing prices of stocks defined by ISIN on latest available date
"""
dfp = df_prices.copy()
assert 
```
<Overlap Ratio: 0.4552352048558422>

---

--- 377 --
Question ID: 178e3d96179baff608652d760ff54f1c5c188588_4
Original Code:
```
def get_phonopy_options(postprocess_parameters):
    """Return phonopy command option strings."""
    mesh_opts = []
    if 'mesh' in postprocess_parameters:
        mesh = postprocess_parameters['mesh']
        try:
            length = float(mesh)
            mesh_opts.append('--mesh=%f' % length)
        except TypeError:
            mesh_opts.append('--mesh="%d %d %d"' % tuple(mesh))
        mesh_opts.append('--nowritemesh')
    fcOpts = []
    if 'fc_calculator' in postprocess_parameters:
        if postprocess_parameters['fc_calculator'].lower().strip() == 'alm':
            fcOpts.append('--alm')
    return (mesh_opts, fcOpts)
```


Overlapping Code:
```
_phonopy_options(postprocess_parameters):
"""Return phonopy command option strings."""
mesh_opts = [ypeError:
mesh_opts.append('--mesh="%d %d %d"' % tuple(mesh))
me
```
<Overlap Ratio: 0.31001890359168244>

---

--- 378 --
Question ID: b087ca6dbcea8e5a3be1946bdd709bb2ed25f366_5
Original Code:
```
@pytest.mark.parametrize('factory', [lambda x: list(x), lambda x: MultiDict(x), lambda x: MultiDictProxy(MultiDict(x))])
def test_multi_dict_multidict_less_keys_substitution(factory: Callable):
    with given:
        sch = schema_multi_dict([('id', schema.int), ('name', schema.str)])
    with when:
        res = substitute(sch, factory([('id', 1)]))
    with then:
        assert res == schema_multi_dict([('id', schema.int(1)), ('name', schema.str)])
        assert res != sch
```


Overlapping Code:
```
idict_less_keys_substitution(factory: Callable):
with given:
sch = schema_multi_
```
<Overlap Ratio: 0.1834862385321101>

---

--- 379 --
Question ID: f04872eed07d871c244788341ce7469a3e8c2ec3_3
Original Code:
```
def get_random_vals(mean_vel):
    initV = 20 + np.random.choice(range(-5, 5))
    action_magnitute = np.random.uniform(-3, 3)
    action_freq = np.random.uniform(0.02, 0.06)
    return (initV, action_magnitute, action_freq)
```


Overlapping Code:
```
agnitute = np.random.uniform(-3, 3)
action_freq = np.random.uniform(0
```
<Overlap Ratio: 0.3317307692307692>

---

--- 380 --
Question ID: 539c6e5edfed9d87bb33e2513733ff5fcbd5e916_1
Original Code:
```
def _make_dagster_event(event_type: DagsterEventType, pipeline_name: str, step_key: str):
    eventSpecificData = None
    if event_type == DagsterEventType.STEP_SUCCESS:
        eventSpecificData = StepSuccessData(duration_ms=1.0)
    elif event_type == DagsterEventType.STEP_FAILURE:
        eventSpecificData = StepFailureData(error=None, user_failure_data=None)
    return DagsterEvent(event_type.value, pipeline_name, step_key=step_key, event_specific_data=eventSpecificData)
```


Overlapping Code:
```
 None
if event_type == DagsterEventType.STEP_SUCCE_ms=1.0)
elif event_type == DagsterEventType.STEP_or=None, user_failure_data=None)
return DagsterEve
```
<Overlap Ratio: 0.33482142857142855>

---

--- 381 --
Question ID: 8e050af63a97f4a7f86ee722501d806903d052be_19
Original Code:
```
def test_clip_lines(two_line_gdf, single_rectangle_gdf):
    """Test what happens when you give the clip_extent a line GDF."""
    clipLine = cl.clip_shp(two_line_gdf, single_rectangle_gdf)
    assert len(clipLine.geometry) == 2
```


Overlapping Code:
```
(two_line_gdf, single_rectangle_gdf):
"""Test what happens when you give the clip_extent a line GDF.ine = cl.clip_shp(two_line_gdf, single_rectangle_g
```
<Overlap Ratio: 0.6944444444444444>

---

--- 382 --
Question ID: cab40a1d1240c5bed8edb2cf223d0f234868dfd0_1
Original Code:
```
def daily_mean(data):
    """Calculate the daily mean of a 2D inflammation data array.

    :param data: A 2D data array with inflammation data (each row contains measurements for a single patient across all days).
    :returns: An array of mean values of measurements for each day.
    """
    return np.mean(data, axis=0)
```


Overlapping Code:
```
daily_mean(data):
"""Calculate the daily mean of a 2D inflammation data array.
:param data: A 2D data array with inflammation data (each row contains measurements for a single patient across all days).
:returns: An array of mean values of measurements for each day.
"""
return np.mean(data, axis=0
```
<Overlap Ratio: 0.9834437086092715>

---

--- 383 --
Question ID: bc9cb89c9de7c8845a3f7858c2bf081cca88afc4_0
Original Code:
```
def main():
    parser = argparse.ArgumentParser()
    defaultUrl = 'https://search.api.hubmapconsortium.org/portal/search'
    parser.add_argument('--url', default=defaultUrl, help=f'ES endpoint. Default: {defaultUrl}')
    default_size = 20
    parser.add_argument('--size', type=int, default=default_size, help=f'Number of records to pull. Default: {default_size}')
    default_type = 'Dataset'
    parser.add_argument('--type', default=default_type, help=f'Entity type to query. Default: {default_type}')
    args = parser.parse_args()
    query = {'post_filter': {'term': {'entity_type.keyword': args.type}}, 'size': args.size, '_source': ['metadata.metadata' if args.type == 'Dataset' else 'metadata']}
    response = requests.post(args.url, json=query)
    hits = response.json()['hits']['hits']
    writer = DictWriter(sys.stdout, fieldnames=['uuid', 'assay_type', 'field', 'value'], extrasaction='ignore')
    writer.writeheader()
    for hit in hits:
        uuid = hit['_id']
        if 'metadata' not in hit['_source']:
            continue
        meta = hit['_source']['metadata']
        if 'metadata' in meta:
            meta = meta['metadata']
        for (field, value) in meta.items():
            if not re.search('[A-Za-z]', value):
                continue
            writer.writerow({'uuid': uuid, 'assay_type': meta['assay_type'] if 'assay_type' in meta else 'Sample', 'field': field, 'value': value})
    assert len(hits) < args.size, f'Result truncated at {args.size}'
    return 0
```


Overlapping Code:
```
def main():
parser = argparse.ArgumentParser()
defaul = 'https://search.api.hubmapconsortium.org/portalof records to pull. Default: {default_size}')
defay. Default: {default_type}')
args = parser.parse_aurce': ['metadata.metadata' if args.type == 'Datasgs.url, json=query)
hits = response.json()['hits'], extrasaction='ignore')
writer.writeheader()
for hit in hits:
uuid = hit['_id']
if 'metadata' not in hit['_source']:
continue
meta = hit['_source']['metadata']
if 'metadata' in meta:
meta = meta['metadata'
```
<Overlap Ratio: 0.3795674869500373>

---

