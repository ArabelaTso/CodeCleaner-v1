{"hexsha": "302d1c97374c37ceb08b170405149fa65b1e670a", "ext": "c", "lang": "C", "content": "tb_bool_t tb_oc_number_uint32_set(tb_object_ref_t object, tb_uint32_t value)\n{   \n    // check\n    tb_oc_number_t* number = tb_oc_number_cast(object);\n    tb_assert_and_check_return_val(number, tb_false);\n\n    // init value\n    number->type = TB_OC_NUMBER_TYPE_UINT32;\n    number->v.u32 = value;\n\n    // ok\n    return tb_true;\n}", "item_id": 23, "repo": "0x17de/xmake", "file": "core/src/tbox/src/tbox/object/number.c", "last_update_at": "2021-03-23T19:40:36+00:00", "question_id": "302d1c97374c37ceb08b170405149fa65b1e670a_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["tb_bool_t tb_oc_number_uint32_set(tb_object_ref_t object, tb_uint32_t value)\n{   \n    // check\n    tb_oc_number_t* number = tb_oc_number_cast(object);\n    tb_assert_and_check_return_val(number, tb_false);\n    // init value\n    number->type = TB_OC_NUMBER_TYPE_UINT32;\n    number->v.u32 = value;\n    // ok\n    return tb_true;\n"]]}
{"hexsha": "e1ae4146e0578d082aadc59ebf2c6b28fc2a86f4", "ext": "c", "lang": "C", "content": "void f15(void) {\n    \tuint8_t x383 = 58U;\n\tint32_t x384 = 0;\n\tvolatile int32_t t15 = -230009;\n\n    t15 = (((x381!=x382)!=x383)>>x384);\n\n    if (t15 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 15, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test1271.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "e1ae4146e0578d082aadc59ebf2c6b28fc2a86f4_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f15(void) {\n    \tuint8_t x383 = 58U;\n\tint32_t x384 = 0;\n\tvolatile int32_t t15 = -230009;\n    t15 = (((x381!=x382)!=x383)>>x384);\n    if (t15 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "d90c21722021698727a73342320d99dbf9f6208d", "ext": "c", "lang": "C", "content": "size_t phy_read()\n{\n\t// streaming data and concat to ibuf\n\tint rdlen = read(fd, ibuf.buf + ibuf.len, BUFFER_SIZE - ibuf.len);\n\t\n#ifdef DEBUG\n\tif (rdlen) {\n\t\tprintf(\"\\033[33mrcvd\\t\");\n\t\tfor (int i = 0; i < rdlen; ++i) {\n\t\t\tif (i && i % 16 == 0)\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t\tprintf(\"%02x \", ibuf.buf[ibuf.len + i]);\n\t\t}\n\t\tprintf(\"\\n\\033[0m\");\n\t}\n#endif\n\n\tibuf.len += rdlen;\n\treturn rdlen;\n}", "item_id": 2, "repo": "laziu/2016-KU-DC-ppp", "file": "server/src/physical.c", "last_update_at": "2021-06-13T16:45:46+00:00", "question_id": "d90c21722021698727a73342320d99dbf9f6208d_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["size_t phy_read()\n{\n\t// streaming data and concat to ibuf\n\tint rdlen = read(fd, ibuf.buf + ibuf.len, BUFFER_SIZE - ibuf.len);\n\t\n#ifdef DEBUG\n\tif (rdlen) {\n\t\tprintf(\"\\033[33mrcvd\\t\");\n\t\tfor (int i = 0; i < rdlen; ++i) {\n\t\t\tif (i && i % 16 == 0)\n\t\t\t\tprintf(\"\\n\\t\");\n\t\t\tprintf(\"%02x \", ibuf.buf[ibuf.len + i]);\n\t\t}\n\t\tprintf(\"\\n\\033[0m\");\n\t}\n#endif\n\tibuf.len += rdlen;\n\treturn rdlen;\n"]]}
{"hexsha": "6c6f6e67132f72a6a811000faf20ecb7d95a8b9e", "ext": "c", "lang": "C", "content": "void f57(void) {\n    \tint16_t x281 = INT16_MIN;\n\tint64_t x282 = -254LL;\n\tuint16_t x284 = UINT16_MAX;\n\tstatic volatile int64_t t57 = 488302510169LL;\n\n    t57 = (((x281+x282)-x283)%x284);\n\n    if (t57 != 65281LL) { NG(); } else { ; }\n\t\n}", "item_id": 57, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test19.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "6c6f6e67132f72a6a811000faf20ecb7d95a8b9e_57", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f57(void) {\n    \tint16_t x281 = INT16_MIN;\n\tint64_t x282 = -254LL;\n\tuint16_t x284 = UINT16_MAX;\n\tstatic volatile int64_t t57 = 488302510169LL;\n    t57 = (((x281+x282)-x283)%x284);\n    if (t57 != 65281LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "87dc80c76f655a7caf5ea1044b8e8d4cf9bf54b6", "ext": "c", "lang": "C", "content": "void application_start(void){\n\n    /* Initialise the WICED device without WLAN */\n    wiced_core_init();\n    \n    /* 32 kHz clock also needed for Bluetooth */\n    host_platform_init_wlan_powersave_clock();\n\n    printf(\"BTstack on WICED\\n\");\n\n#if 0\n    // init GPIOs D0-D5 for debugging - not used\n    wiced_gpio_init(D0, OUTPUT_PUSH_PULL);\n    wiced_gpio_init(D1, OUTPUT_PUSH_PULL);\n    wiced_gpio_init(D2, OUTPUT_PUSH_PULL);\n    wiced_gpio_init(D3, OUTPUT_PUSH_PULL);\n    wiced_gpio_init(D4, OUTPUT_PUSH_PULL);\n    wiced_gpio_init(D5, OUTPUT_PUSH_PULL);\n\n    wiced_gpio_output_low(D0);\n    wiced_gpio_output_low(D1);\n    wiced_gpio_output_low(D2);\n    wiced_gpio_output_low(D3);\n    wiced_gpio_output_low(D4);\n    wiced_gpio_output_low(D5);\n#endif\n\n    // start with BTstack init - especially configure HCI Transport\n    btstack_memory_init();\n    btstack_run_loop_init(btstack_run_loop_wiced_get_instance());\n    \n    // enable full log output while porting\n    // hci_dump_open(NULL, HCI_DUMP_STDOUT);\n\n    // setup le device db storage -- not needed if used LE-only (-> start address == 0)\n    le_device_db_wiced_dct_set_start_address(btstack_link_key_db_wiced_dct_get_storage_size());\n    le_device_db_dump();\n    \n    // init HCI\n    const btstack_uart_block_t * uart_driver = btstack_uart_block_wiced_instance();\n    const hci_transport_t * transport = hci_transport_h4_instance(uart_driver);\n    hci_init(transport, (void*) &hci_transport_config_uart);\n    hci_set_link_key_db(btstack_link_key_db_wiced_dct_instance());\n    hci_set_chipset(btstack_chipset_bcm_instance());\n\n    // inform about BTstack state\n    hci_event_callback_registration.callback = &packet_handler;\n    hci_add_event_handler(&hci_event_callback_registration);\n\n    // use WIFI Mac address + 1 for Bluetooth\n    bd_addr_t dummy = { 1,2,3,4,5,6};\n    sscanf_bd_addr(&wifi_mac_address[8], dummy);\n    dummy[5]++;\n    hci_set_bd_addr(dummy);\n    \n    // hand over to btstack embedded code \n    btstack_main();\n\n    // go\n    btstack_run_loop_execute();\n\n    while (1){};\n}", "item_id": 1, "repo": "thiamchi/micropython_custom", "file": "lib/btstack/port/wiced-h4/main.c", "last_update_at": "2021-12-19T18:08:08+00:00", "question_id": "87dc80c76f655a7caf5ea1044b8e8d4cf9bf54b6_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void application_start(void){\n    /* Initialise the WICED device without WLAN */\n    wiced_core_init();\n    /* 32 kHz clock also needed for Bluetooth */\n    host_platform_init_wlan_powersave_clock();\n    printf(\"BTstack on WICED\\n\");\n#if 0\n    // init GPIOs D0-D5 for debugging - not used\n    wiced_gpio_init(D0, OUTPUT_PUSH_PULL);\n    wiced_gpio_init(D1, OUTPUT_PUSH_PULL);\n    wiced_gpio_init(D2, OUTPUT_PUSH_PULL);\n    wiced_gpio_init(D3, OUTPUT_PUSH_PULL);\n    wiced_gpio_init(D4, OUTPUT_PUSH_PULL);\n    wiced_gpio_init(D5, OUTPUT_PUSH_PULL);\n    wiced_gpio_output_low(D0);\n    wiced_gpio_output_low(D1);\n    wiced_gpio_output_low(D2);\n    wiced_gpio_output_low(D3);\n    wiced_gpio_output_low(D4);\n    wiced_gpio_output_low(D5);\n#endif\n    // start with BTstack init - especially configure HCI Transport\n    btstack_memory_init();\n    btstack_run_loop_init(btstack_run_loop_wiced_get_instance());\n    // enable full log output while porting\n    // hci_dump_open(NULL, HCI_DUMP_STDOUT);\n    // setup le device db storage -- not needed if used LE-only (-> start address == 0)\n    le_device_db_wiced_dct_set_start_address(btstack_link_key_db_wiced_dct_get_storage_size());\n    le_device_db_dump();\n    // init HCI\n    const btstack_uart_block_t * uart_driver = btstack_uart_block_wiced_instance();\n    const hci_transport_t * transport = hci_transport_h4_instance(uart_driver);\n    hci_init(transport, (void*) &hci_transport_config_uart);\n    hci_set_link_key_db(btstack_link_key_db_wiced_dct_instance());\n    hci_set_chipset(btstack_chipset_bcm_instance());\n    // inform about BTstack state\n    hci_event_callback_registration.callback = &packet_handler;\n    hci_add_event_handler(&hci_event_callback_registration);\n    // use WIFI Mac address + 1 for Bluetooth\n    bd_addr_t dummy = { 1,2,3,4,5,6};\n    sscanf_bd_addr(&wifi_mac_address[8], dummy);\n    dummy[5]++;\n    hci_set_bd_addr(dummy);\n    // hand over to btstack embedded code \n    btstack_main();\n    // go\n    btstack_run_loop_execute();\n    while (1){};\n"]]}
{"hexsha": "7bf3af4936e843676abba08dcbdf4c3c545e6cf6", "ext": "c", "lang": "C", "content": "void f131(void) {\n    \tint32_t x665 = -1;\n\tuint64_t x666 = 30963550783394755LLU;\n\tint64_t x667 = -1LL;\n\tint32_t t131 = 333812;\n\n    t131 = (x665>((x666-x667)-x668));\n\n    if (t131 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 131, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test219.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "7bf3af4936e843676abba08dcbdf4c3c545e6cf6_131", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f131(void) {\n    \tint32_t x665 = -1;\n\tuint64_t x666 = 30963550783394755LLU;\n\tint64_t x667 = -1LL;\n\tint32_t t131 = 333812;\n    t131 = (x665>((x666-x667)-x668));\n    if (t131 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "5e5023cdb314b16e133140cd748b2da26c5b1f5e", "ext": "c", "lang": "C", "content": "void f0(void) {\n    \tuint8_t x3 = 13U;\n\tint8_t x4 = -1;\n\tvolatile uint32_t t0 = 31U;\n\n    t0 = (((x1|x2)>>x3)/x4);\n\n    if (t0 != 0U) { NG(); } else { ; }\n\t\n}", "item_id": 0, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test2496.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "5e5023cdb314b16e133140cd748b2da26c5b1f5e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f0(void) {\n    \tuint8_t x3 = 13U;\n\tint8_t x4 = -1;\n\tvolatile uint32_t t0 = 31U;\n    t0 = (((x1|x2)>>x3)/x4);\n    if (t0 != 0U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "4cd92617b4a4956d82b08a0654ba97da016ae1c8", "ext": "c", "lang": "C", "content": "void f120(void) {\n    \tstatic uint8_t x549 = 29U;\n\tint8_t x550 = INT8_MIN;\n\tuint16_t x551 = UINT16_MAX;\n\tint32_t x552 = 1660;\n\tint32_t t120 = -5946;\n\n    t120 = (((x549+x550)%x551)!=x552);\n\n    if (t120 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 120, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test63.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "4cd92617b4a4956d82b08a0654ba97da016ae1c8_120", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f120(void) {\n    \tstatic uint8_t x549 = 29U;\n\tint8_t x550 = INT8_MIN;\n\tuint16_t x551 = UINT16_MAX;\n\tint32_t x552 = 1660;\n\tint32_t t120 = -5946;\n    t120 = (((x549+x550)%x551)!=x552);\n    if (t120 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "aa8096589ced8926ff3e52e85256aa5587c4a477", "ext": "c", "lang": "C", "content": "void f128(void) {\n    \tuint16_t x2729 = UINT16_MAX;\n\tuint16_t x2730 = UINT16_MAX;\n\tstatic uint8_t x2731 = 5U;\n\tint8_t x2732 = -3;\n\tvolatile int32_t t128 = -54612815;\n\n    t128 = ((x2729<<(x2730%x2731))==x2732);\n\n    if (t128 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 128, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test862.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "aa8096589ced8926ff3e52e85256aa5587c4a477_128", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f128(void) {\n    \tuint16_t x2729 = UINT16_MAX;\n\tuint16_t x2730 = UINT16_MAX;\n\tstatic uint8_t x2731 = 5U;\n\tint8_t x2732 = -3;\n\tvolatile int32_t t128 = -54612815;\n    t128 = ((x2729<<(x2730%x2731))==x2732);\n    if (t128 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "c2323d6b07e0c084b19c7f277d6dc50084c0e57e", "ext": "c", "lang": "C", "content": "void f132(void) {\n    \tuint16_t x2829 = 13U;\n\tuint32_t x2830 = UINT32_MAX;\n\tvolatile uint8_t x2831 = 0U;\n\tint32_t x2832 = 11150;\n\n    t132 = ((x2829^x2830)<<(x2831&x2832));\n\n    if (t132 != 4294967282U) { NG(); } else { ; }\n\t\n}", "item_id": 132, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test2344.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "c2323d6b07e0c084b19c7f277d6dc50084c0e57e_132", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f132(void) {\n    \tuint16_t x2829 = 13U;\n\tuint32_t x2830 = UINT32_MAX;\n\tvolatile uint8_t x2831 = 0U;\n\tint32_t x2832 = 11150;\n    t132 = ((x2829^x2830)<<(x2831&x2832));\n    if (t132 != 4294967282U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "3255fb0d691712207c9cb4033372c73537e48b6b", "ext": "c", "lang": "C", "content": "int coalition_info(proc_t p, struct coalition_info_args *uap, __unused int32_t *retval)\n{\n\tuser_addr_t cidp = uap->cid;\n\tuser_addr_t buffer = uap->buffer;\n\tuser_addr_t bufsizep = uap->bufsize;\n\tuser_size_t bufsize;\n\tuint32_t flavor = uap->flavor;\n\tint error;\n\tuint64_t cid;\n\tcoalition_t coal;\n\n\terror = copyin(cidp, &cid, sizeof(cid));\n\tif (error) {\n\t\treturn error;\n\t}\n\n\tcoal = coalition_find_by_id(cid);\n\tif (coal == COALITION_NULL) {\n\t\treturn ESRCH;\n\t}\n\t/* TODO: priv check? EPERM or ESRCH? */\n\n\tif (IS_64BIT_PROCESS(p)) {\n\t\tuser64_size_t size64;\n\t\terror = copyin(bufsizep, &size64, sizeof(size64));\n\t\tbufsize = (user_size_t)size64;\n\t} else {\n\t\tuser32_size_t size32;\n\t\terror = copyin(bufsizep, &size32, sizeof(size32));\n\t\tbufsize = (user_size_t)size32;\n\t}\n\tif (error) {\n\t\tgoto bad;\n\t}\n\n\tswitch (flavor) {\n\tcase COALITION_INFO_RESOURCE_USAGE:\n\t\terror = coalition_info_resource_usage(coal, buffer, bufsize);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\nbad:\n\tcoalition_release(coal);\n\treturn error;\n}", "item_id": 5, "repo": "LeeWongSnail/SourceCode_ReadingNote", "file": "xnu-2782.1.97/bsd/kern/sys_coalition.c", "last_update_at": "2021-03-28T02:56:16+00:00", "question_id": "3255fb0d691712207c9cb4033372c73537e48b6b_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int coalition_info(proc_t p, struct coalition_info_args *uap, __unused int32_t *retval)\n{\n\tuser_addr_t cidp = uap->cid;\n\tuser_addr_t buffer = uap->buffer;\n\tuser_addr_t bufsizep = uap->bufsize;\n\tuser_size_t bufsize;\n\tuint32_t flavor = uap->flavor;\n\tint error;\n\tuint64_t cid;\n\tcoalition_t coal;\n\terror = copyin(cidp, &cid, sizeof(cid));\n\tif (error) {\n\t\treturn error;\n\t}\n\tcoal = coalition_find_by_id(cid);\n\tif (coal == COALITION_NULL) {\n\t\treturn ESRCH;\n\t}\n\t/* TODO: priv check? EPERM or ESRCH? */\n\tif (IS_64BIT_PROCESS(p)) {\n\t\tuser64_size_t size64;\n\t\terror = copyin(bufsizep, &size64, sizeof(size64));\n\t\tbufsize = (user_size_t)size64;\n\t} else {\n\t\tuser32_size_t size32;\n\t\terror = copyin(bufsizep, &size32, sizeof(size32));\n\t\tbufsize = (user_size_t)size32;\n\t}\n\tif (error) {\n\t\tgoto bad;\n\t}\n\tswitch (flavor) {\n\tcase COALITION_INFO_RESOURCE_USAGE:\n\t\terror = coalition_info_resource_usage(coal, buffer, bufsize);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t}\nbad:\n\tcoalition_release(coal);\n\treturn error;\n"]]}
{"hexsha": "48673116e7c77ea2910ad80a549d0f0f8c20c299", "ext": "c", "lang": "C", "content": "void * alloc_matrix(\n    int m, int n, size_t elemsize, size_t *ld)\n{\n    *ld = divceil(m, 64/elemsize)*(64/elemsize);\n    void *ptr;\n#ifdef STARNEIG_ENABLE_CUDA\n    if (pinning)\n        cudaHostAlloc(&ptr, n*(*ld)*elemsize, cudaHostRegisterPortable);\n    else\n        ptr = aligned_alloc(64, n*(*ld)*elemsize);\n#else\n    ptr = aligned_alloc(64, n*(*ld)*elemsize);\n#endif\n    return ptr;\n}", "item_id": 0, "repo": "NLAFET/StarNEig", "file": "test/common/common.c", "last_update_at": "2021-12-24T12:30:19+00:00", "question_id": "48673116e7c77ea2910ad80a549d0f0f8c20c299_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void * alloc_matrix(\n    int m, int n, size_t elemsize, size_t *ld)\n{\n    *ld = divceil(m, 64/elemsize)*(64/elemsize);\n    void *ptr;\n#ifdef STARNEIG_ENABLE_CUDA\n    if (pinning)\n        cudaHostAlloc(&ptr, n*(*ld)*elemsize, cudaHostRegisterPortable);\n    else\n        ptr = aligned_alloc(64, n*(*ld)*elemsize);\n#else\n    ptr = aligned_alloc(64, n*(*ld)*elemsize);\n#endif\n    return ptr;\n"]]}
{"hexsha": "1ea354b62734788e7adeecf81c65062941794e35", "ext": "c", "lang": "C", "content": "void f12(void) {\n    \tuint16_t x61 = 30U;\n\tvolatile uint64_t x62 = UINT64_MAX;\n\tuint64_t x63 = 203562LLU;\n\tvolatile uint32_t x64 = UINT32_MAX;\n\tvolatile int32_t t12 = 29;\n\n    t12 = (x61-((x62+x63)!=x64));\n\n    if (t12 != 29) { NG(); } else { ; }\n\t\n}", "item_id": 12, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test86.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "1ea354b62734788e7adeecf81c65062941794e35_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f12(void) {\n    \tuint16_t x61 = 30U;\n\tvolatile uint64_t x62 = UINT64_MAX;\n\tuint64_t x63 = 203562LLU;\n\tvolatile uint32_t x64 = UINT32_MAX;\n\tvolatile int32_t t12 = 29;\n    t12 = (x61-((x62+x63)!=x64));\n    if (t12 != 29) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "28aceb0c75b52c834005703bb775b8b888278acf", "ext": "c", "lang": "C", "content": "void f193(void) {\n    \tint64_t x773 = -21226022998127LL;\n\tint64_t x774 = 1956LL;\n\tvolatile int64_t x775 = INT64_MIN;\n\tint8_t x776 = 26;\n\tstatic volatile int32_t t193 = 34047637;\n\n    t193 = (x773!=((x774^x775)^x776));\n\n    if (t193 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 193, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test2737.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "28aceb0c75b52c834005703bb775b8b888278acf_193", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f193(void) {\n    \tint64_t x773 = -21226022998127LL;\n\tint64_t x774 = 1956LL;\n\tvolatile int64_t x775 = INT64_MIN;\n\tint8_t x776 = 26;\n\tstatic volatile int32_t t193 = 34047637;\n    t193 = (x773!=((x774^x775)^x776));\n    if (t193 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "1b277ac87f71a9704308e7fafb8636cf469b5188", "ext": "c", "lang": "C", "content": "MSList *ms_list_remove_link(MSList *list, MSList *elem){\n    MSList *ret;\n    if (elem==list){\n        ret=elem->next;\n        //[iclai+] useless code\n        //elem->prev=NULL;\n        //elem->next=NULL;\n        //[iclai-]\n        if (ret!=NULL) ret->prev=NULL;\n        ms_free(elem);\n        return ret;\n    }\n    elem->prev->next=elem->next;\n    if (elem->next!=NULL) elem->next->prev=elem->prev;\n    //[iclai+] useless code\n    //elem->next=NULL;\n    //elem->prev=NULL;\n    //[iclai-]\n    ms_free(elem);\n    return list;\n}", "item_id": 8, "repo": "doyaGu/C0501Q_HWJL01", "file": "sdk/sdk/share/mediastreamer2/mscommon.c", "last_update_at": "2021-10-09T08:05:50+00:00", "question_id": "1b277ac87f71a9704308e7fafb8636cf469b5188_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["MSList *ms_list_remove_link(MSList *list, MSList *elem){\n    MSList *ret;\n    if (elem==list){\n        ret=elem->next;\n        //[iclai+] useless code\n        //elem->prev=NULL;\n        //elem->next=NULL;\n        //[iclai-]\n        if (ret!=NULL) ret->prev=NULL;\n        ms_free(elem);\n        return ret;\n    }\n    elem->prev->next=elem->next;\n    if (elem->next!=NULL) elem->next->prev=elem->prev;\n    //[iclai+] useless code\n    //elem->next=NULL;\n    //elem->prev=NULL;\n    //[iclai-]\n    ms_free(elem);\n    return list;\n"]]}
{"hexsha": "cab196bb38cd4c92f6cf2c40d9df180e13789ca3", "ext": "c", "lang": "C", "content": "static void wcn36xx_set_tx_pdu(struct wcn36xx_tx_bd *bd,\n\t\t\t       u32 mpdu_header_len,\n\t\t\t       u32 len,\n\t\t\t       u16 tid)\n{\n\tbd->pdu.mpdu_header_len = mpdu_header_len;\n\tbd->pdu.mpdu_header_off = sizeof(*bd);\n\tbd->pdu.mpdu_data_off = bd->pdu.mpdu_header_len +\n\t\tbd->pdu.mpdu_header_off;\n\tbd->pdu.mpdu_len = len;\n\tbd->pdu.tid = tid;\n\t/* Use seq number generated by mac80211 */\n\tbd->pdu.bd_ssn = WCN36XX_TXBD_SSN_FILL_HOST;\n}", "item_id": 1, "repo": "muddessir/framework", "file": "machine/qemu/sources/linux/drivers/net/wireless/ath/wcn36xx/txrx.c", "last_update_at": "2021-11-21T19:56:29+00:00", "question_id": "cab196bb38cd4c92f6cf2c40d9df180e13789ca3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void wcn36xx_set_tx_pdu(struct wcn36xx_tx_bd *bd,\n\t\t\t       u32 mpdu_header_len,\n\t\t\t       u32 len,\n\t\t\t       u16 tid)\n{\n\tbd->pdu.mpdu_header_len = mpdu_header_len;\n\tbd->pdu.mpdu_header_off = sizeof(*bd);\n\tbd->pdu.mpdu_data_off = bd->pdu.mpdu_header_len +\n\t\tbd->pdu.mpdu_header_off;\n\tbd->pdu.mpdu_len = len;\n\tbd->pdu.tid = tid;\n\t/* Use seq number generated by mac80211 */\n\tbd->pdu.bd_ssn = WCN36XX_TXBD_SSN_FILL_HOST;\n"]]}
{"hexsha": "9bce22c2efbac546b67454accd7f83d4879370fc", "ext": "c", "lang": "C", "content": "void f177(void) {\n    \tuint8_t x877 = 3U;\n\tint32_t x878 = INT32_MIN;\n\tint16_t x879 = -42;\n\tuint16_t x880 = UINT16_MAX;\n\tvolatile int32_t t177 = 7902;\n\n    t177 = (x877/((x878|x879)*x880));\n\n    if (t177 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 177, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test2384.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "9bce22c2efbac546b67454accd7f83d4879370fc_177", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f177(void) {\n    \tuint8_t x877 = 3U;\n\tint32_t x878 = INT32_MIN;\n\tint16_t x879 = -42;\n\tuint16_t x880 = UINT16_MAX;\n\tvolatile int32_t t177 = 7902;\n    t177 = (x877/((x878|x879)*x880));\n    if (t177 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "edc9ece8f5eebcf7719745eeab2ce52a53ecdd54", "ext": "c", "lang": "C", "content": "static int\nloci_validate_of_oxm_vlan_pcp_OF_VERSION_1_3(uint8_t *data, int len, int *out_len)\n{\n    if (len < 5) {\n        return -1;\n    }\n\n    len = 5;\n\n\n\n\n    *out_len = len;\n    return 0;\n}", "item_id": 996, "repo": "samueljero/BEADS", "file": "switch_proxy/loci/src/loci_validator.c", "last_update_at": "2021-09-15T09:37:13+00:00", "question_id": "edc9ece8f5eebcf7719745eeab2ce52a53ecdd54_996", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nloci_validate_of_oxm_vlan_pcp_OF_VERSION_1_3(uint8_t *data, int len, int *out_len)\n{\n    if (len < 5) {\n        return -1;\n    }\n    len = 5;\n    *out_len = len;\n    return 0;\n"]]}
{"hexsha": "0bd2e8bd98182b4d8936bfc698d3ca7ecba1c78d", "ext": "c", "lang": "C", "content": "void f63(void) {\n    \tint32_t x281 = INT32_MIN;\n\tint16_t x283 = -1;\n\tint16_t x284 = INT16_MAX;\n\n    t63 = (x281==(x282-(x283%x284)));\n\n    if (t63 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 63, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test806.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "0bd2e8bd98182b4d8936bfc698d3ca7ecba1c78d_63", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f63(void) {\n    \tint32_t x281 = INT32_MIN;\n\tint16_t x283 = -1;\n\tint16_t x284 = INT16_MAX;\n    t63 = (x281==(x282-(x283%x284)));\n    if (t63 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "76fc558fbbe8cee5cc1ebe6fbd1af78f5fb14663", "ext": "c", "lang": "C", "content": "void f16(void) {\n    \tstatic volatile int32_t x101 = 301;\n\tstatic uint16_t x102 = UINT16_MAX;\n\tint64_t x103 = -147353081581LL;\n\tint64_t x104 = INT64_MIN;\n\n    t16 = ((x101/(x102%x103))%x104);\n\n    if (t16 != 0LL) { NG(); } else { ; }\n\t\n}", "item_id": 16, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test831.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "76fc558fbbe8cee5cc1ebe6fbd1af78f5fb14663_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f16(void) {\n    \tstatic volatile int32_t x101 = 301;\n\tstatic uint16_t x102 = UINT16_MAX;\n\tint64_t x103 = -147353081581LL;\n\tint64_t x104 = INT64_MIN;\n    t16 = ((x101/(x102%x103))%x104);\n    if (t16 != 0LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "8dd55a4a6e04d0a17102c3aa67b57e473c0ce830", "ext": "c", "lang": "C", "content": "void f169(void) {\n    \tuint8_t x710 = 1U;\n\tstatic volatile int16_t x711 = -410;\n\tvolatile int32_t t169 = -750826;\n\n    t169 = (x709!=(x710+(x711%x712)));\n\n    if (t169 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 169, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test791.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "8dd55a4a6e04d0a17102c3aa67b57e473c0ce830_169", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f169(void) {\n    \tuint8_t x710 = 1U;\n\tstatic volatile int16_t x711 = -410;\n\tvolatile int32_t t169 = -750826;\n    t169 = (x709!=(x710+(x711%x712)));\n    if (t169 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "172bb8ebb395e127916e84ac6b36749894a485e7", "ext": "c", "lang": "C", "content": "void f130(void) {\n    \tint16_t x697 = 14;\n\tuint16_t x698 = UINT16_MAX;\n\tstatic int8_t x699 = -1;\n\tvolatile int64_t x700 = INT64_MIN;\n\n    t130 = ((x697*x698)&(x699!=x700));\n\n    if (t130 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 130, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1216.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "172bb8ebb395e127916e84ac6b36749894a485e7_130", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f130(void) {\n    \tint16_t x697 = 14;\n\tuint16_t x698 = UINT16_MAX;\n\tstatic int8_t x699 = -1;\n\tvolatile int64_t x700 = INT64_MIN;\n    t130 = ((x697*x698)&(x699!=x700));\n    if (t130 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "ffc85599bce5d93ad73d49ef0fbfc7995f33621c", "ext": "c", "lang": "C", "content": "void f108(void) {\n    \tvolatile int32_t x6045 = -3231;\n\tuint64_t x6046 = 6129359876919LLU;\n\tstatic volatile int32_t x6048 = -1;\n\tvolatile int32_t t108 = 559652695;\n\n    t108 = ((x6045<=(x6046<<x6047))==x6048);\n\n    if (t108 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 108, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test1114.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "ffc85599bce5d93ad73d49ef0fbfc7995f33621c_108", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f108(void) {\n    \tvolatile int32_t x6045 = -3231;\n\tuint64_t x6046 = 6129359876919LLU;\n\tstatic volatile int32_t x6048 = -1;\n\tvolatile int32_t t108 = 559652695;\n    t108 = ((x6045<=(x6046<<x6047))==x6048);\n    if (t108 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "0b5ebcf79bb7309f00386bea49c54c3585d1f10d", "ext": "h", "lang": "C", "content": "static inline uint8_t\nmsgpack_get_UINT8(msgpack_u *m)\n{\n\tuint8_t x = *(uint8_t *)++m->p;\n\t++m->p;\n\treturn x;\n}", "item_id": 12, "repo": "SeanTBooker/edgefs", "file": "src/ccow/include/msgpackalt.h", "last_update_at": "2021-12-16T02:33:11+00:00", "question_id": "0b5ebcf79bb7309f00386bea49c54c3585d1f10d_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline uint8_t\nmsgpack_get_UINT8(msgpack_u *m)\n{\n\tuint8_t x = *(uint8_t *)++m->p;\n\t++m->p;\n\treturn x;\n"]]}
{"hexsha": "6cd5d744139950bbdbe6c878b7d2c542ae17d46e", "ext": "h", "lang": "C", "content": "static inline void prcm_domain_disable(uint32_t domains)\n{\n  DEBUGASSERT((domains & PRCM_DOMAIN_RFCORE) != 0 ||\n              (domains & PRCM_DOMAIN_VIMS) != 0);\n\n  /* Disable the power domains. */\n \n  if ((domains & PRCM_DOMAIN_RFCORE) != 0)\n    {\n      putreg32(0, TIVA_PRCM_RFCCLKG);\n    }\n\n  if ((domains & PRCM_DOMAIN_VIMS) != 0)\n    {\n      putreg32(0, TIVA_PRCM_VIMSCLKG);\n    }\n}", "item_id": 1, "repo": "bhgv/nuttx", "file": "arch/arm/src/tiva/cc13xx/cc13xx_prcm.h", "last_update_at": "2021-11-16T13:16:17+00:00", "question_id": "6cd5d744139950bbdbe6c878b7d2c542ae17d46e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void prcm_domain_disable(uint32_t domains)\n{\n  DEBUGASSERT((domains & PRCM_DOMAIN_RFCORE) != 0 ||\n              (domains & PRCM_DOMAIN_VIMS) != 0);\n  /* Disable the power domains. */\n  if ((domains & PRCM_DOMAIN_RFCORE) != 0)\n    {\n      putreg32(0, TIVA_PRCM_RFCCLKG);\n    }\n  if ((domains & PRCM_DOMAIN_VIMS) != 0)\n    {\n      putreg32(0, TIVA_PRCM_VIMSCLKG);\n    }\n"]]}
{"hexsha": "acbe28e0552057284b8c25ff311b48fd22db876f", "ext": "c", "lang": "C", "content": "void f42(void) {\n    \tint8_t x249 = 4;\n\tvolatile int8_t x251 = INT8_MIN;\n\tvolatile int32_t t42 = -40;\n\n    t42 = (((x249^x250)*x251)^x252);\n\n    if (t42 != -208385) { NG(); } else { ; }\n\t\n}", "item_id": 42, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test2590.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "acbe28e0552057284b8c25ff311b48fd22db876f_42", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f42(void) {\n    \tint8_t x249 = 4;\n\tvolatile int8_t x251 = INT8_MIN;\n\tvolatile int32_t t42 = -40;\n    t42 = (((x249^x250)*x251)^x252);\n    if (t42 != -208385) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "46c82eef7c8a59345a835d767fd28fec711fcb53", "ext": "c", "lang": "C", "content": "void f148(void) {\n    \tint16_t x617 = INT16_MIN;\n\tint16_t x618 = INT16_MAX;\n\tvolatile int64_t x619 = INT64_MIN;\n\tvolatile int32_t t148 = 855008766;\n\n    t148 = ((x617==(x618&x619))%x620);\n\n    if (t148 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 148, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test2259.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "46c82eef7c8a59345a835d767fd28fec711fcb53_148", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f148(void) {\n    \tint16_t x617 = INT16_MIN;\n\tint16_t x618 = INT16_MAX;\n\tvolatile int64_t x619 = INT64_MIN;\n\tvolatile int32_t t148 = 855008766;\n    t148 = ((x617==(x618&x619))%x620);\n    if (t148 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "888558657dab409afbce5758a694193caf93d83d", "ext": "c", "lang": "C", "content": "int main(int argc, char *argv[])\n{\n   int l;\n   int c;\n\n  for (int k=0; k<sizeof(s)/sizeof(char *);k++) {\n    s1=s[k];\n   l=u8next(s1,&c);\n   dbgchk(l==k+1,\"Wrong length: expected %d, got %d\",k+1,l);\n   dbgchk(c==cp[k],\"Wrong code: expected %06X, got %06X\",cp[k],c);\n   l=u8next_FAST(s1,&c);\n   dbgchk(l==k+1,\"(FAST) Wrong length: expected %d, got %d\",k+1,l);\n   dbgchk(c==cp[k],\"(FAST) Wrong code: expected %06X, got %06X\",cp[k],c);\n  }\n\n}", "item_id": 0, "repo": "rdentato/u8c", "file": "test/test2.c", "last_update_at": "2021-11-14T17:42:24+00:00", "question_id": "888558657dab409afbce5758a694193caf93d83d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char *argv[])\n{\n   int l;\n   int c;\n  for (int k=0; k<sizeof(s)/sizeof(char *);k++) {\n    s1=s[k];\n   l=u8next(s1,&c);\n   dbgchk(l==k+1,\"Wrong length: expected %d, got %d\",k+1,l);\n   dbgchk(c==cp[k],\"Wrong code: expected %06X, got %06X\",cp[k],c);\n   l=u8next_FAST(s1,&c);\n   dbgchk(l==k+1,\"(FAST) Wrong length: expected %d, got %d\",k+1,l);\n   dbgchk(c==cp[k],\"(FAST) Wrong code: expected %06X, got %06X\",cp[k],c);\n  }\n"]]}
{"hexsha": "ba277499802dc58a6f3580679bef7e530f87b74b", "ext": "c", "lang": "C", "content": "MmsNamedVariableList\nmmsServer_getNamedVariableListWithName(LinkedList namedVariableLists, const char* variableListName)\n{\n    MmsNamedVariableList variableList = NULL;\n\n    LinkedList element = LinkedList_getNext(namedVariableLists);\n\n    while (element != NULL) {\n        MmsNamedVariableList varList = (MmsNamedVariableList) element->data;\n\n        if (strcmp(MmsNamedVariableList_getName(varList), variableListName) == 0) {\n            variableList = varList;\n            break;\n        }\n\n        element = LinkedList_getNext(element);\n    }\n\n    return variableList;\n}", "item_id": 3, "repo": "IOT-DSA/dslink-c-iec61850", "file": "libiec61850/src/mms/iso_mms/server/mms_server_common.c", "last_update_at": "2021-05-20T02:22:14+00:00", "question_id": "ba277499802dc58a6f3580679bef7e530f87b74b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["MmsNamedVariableList\nmmsServer_getNamedVariableListWithName(LinkedList namedVariableLists, const char* variableListName)\n{\n    MmsNamedVariableList variableList = NULL;\n    LinkedList element = LinkedList_getNext(namedVariableLists);\n    while (element != NULL) {\n        MmsNamedVariableList varList = (MmsNamedVariableList) element->data;\n        if (strcmp(MmsNamedVariableList_getName(varList), variableListName) == 0) {\n            variableList = varList;\n            break;\n        }\n        element = LinkedList_getNext(element);\n    }\n    return variableList;\n"]]}
{"hexsha": "8422707813c3e82146aad7839d40ce8f0c0f2a6e", "ext": "c", "lang": "C", "content": "void f12(void) {\n    \tint64_t x49 = 640083LL;\n\tuint32_t x51 = UINT32_MAX;\n\tvolatile int64_t x52 = 43763696543LL;\n\tstatic int32_t t12 = 1037;\n\n    t12 = ((x49<=x50)==(x51%x52));\n\n    if (t12 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 12, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test918.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "8422707813c3e82146aad7839d40ce8f0c0f2a6e_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f12(void) {\n    \tint64_t x49 = 640083LL;\n\tuint32_t x51 = UINT32_MAX;\n\tvolatile int64_t x52 = 43763696543LL;\n\tstatic int32_t t12 = 1037;\n    t12 = ((x49<=x50)==(x51%x52));\n    if (t12 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "3e3fe85af3ecd6dca09b407fa96f9436d7ad418e", "ext": "c", "lang": "C", "content": "BOOL CALLBACK fnAbout( HWND hDlg, WORD wMsg, WPARAM wParam, LPARAM lParam ) \r\n{\r\n   char  szTemp [256] ;\r\n\r\n   switch (wMsg)\r\n   {\r\n      case WM_INITDIALOG:\r\n\r\n         wsprintf( szTemp, \"%s %s - %s\",\r\n                   (LPSTR)rglpsz[IDS_VERSION], (LPSTR)szVerNum,\r\n                   (LPSTR)__DATE__ ) ;\r\n         SetDlgItemText (hDlg, IDD_VERSION, szTemp ) ;\r\n         break ;\r\n\r\n      case WM_COMMAND:\r\n         switch ((WORD)wParam)\r\n         {\r\n            case IDOK:\r\n            case IDCANCEL:\r\n               EndDialog (hDlg, 0) ;\r\n            break ;\r\n\r\n            default :\r\n               return FALSE ;\r\n         }\r\n         break ;\r\n\r\n   }\r\n   return FALSE ;\r\n}", "item_id": 5, "repo": "tig/Tigger", "file": "Microsoft/SAMPLES/ttfview/ttview/dbedit/src/subdlgs.c", "last_update_at": "2021-08-02T01:36:43+00:00", "question_id": "3e3fe85af3ecd6dca09b407fa96f9436d7ad418e_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["BOOL CALLBACK fnAbout( HWND hDlg, WORD wMsg, WPARAM wParam, LPARAM lParam ) \r\n{\r\n   char  szTemp [256] ;\r\n\r\n   switch (wMsg)\r\n   {\r\n      case WM_INITDIALOG:\r\n\r\n         wsprintf( szTemp, \"%s %s - %s\",\r\n                   (LPSTR)rglpsz[IDS_VERSION], (LPSTR)szVerNum,\r\n                   (LPSTR)__DATE__ ) ;\r\n         SetDlgItemText (hDlg, IDD_VERSION, szTemp ) ;\r\n         break ;\r\n\r\n      case WM_COMMAND:\r\n         switch ((WORD)wParam)\r\n         {\r\n            case IDOK:\r\n            case IDCANCEL:\r\n               EndDialog (hDlg, 0) ;\r\n            break ;\r\n\r\n            default :\r\n               return FALSE ;\r\n         }\r\n         break ;\r\n\r\n   }\r\n   return FALSE ;\r\n"]]}
{"hexsha": "52088ac6465f21c36a77eb8db8dc18865ce91d54", "ext": "c", "lang": "C", "content": "void *TK_Wad4_GetCacheExpandLumpNumOffs(TK_WadImage *img,\n\tint lump, int ofs, int wsz, int *rrofs, int *rsz)\n{\n\tint\t\tfraga[64];\n\tTK_Wad4Lump\t*w4l;\n\tTK_Wad2Lump\t*w2l;\n\tTK_FILE\t\t*fd;\n\tbyte\t\t*tptr;\n\ts64 offs;\n\tint csz, lmp1, offs1, csz1;\n\tint dsz, sz1;\n\tvoid *ptr;\n\tint cmp;\n\tint i, j, k, n;\n\t\n\tcmp=TK_Wad4_GetLumpEntCmp(img, lump);\n\tif(cmp<0)\n\t\treturn(NULL);\n\t\n\tif(cmp!=TK_W4CMP_FRAG)\n\t{\n\t\t*rrofs=0;\n//\t\tptr=TK_Wad4_GetCacheLumpNum(img, lump, rsz);\n\t\tptr=TK_Wad4_GetCacheExpandLumpNum(img, lump, ofs+wsz, rsz);\n\t\treturn(ptr);\n\t}\n\n\tif(img->w4dir)\n\t{\n\t\tw4l=img->w4dir+lump;\n\t\toffs=(w4l->offs)<<6;\n\t\tcsz=w4l->csize;\n\t\tdsz=w4l->dsize;\n\t\tcmp=w4l->cmp;\n\t}else if(img->w2dir)\n\t{\n\t\tw2l=img->w2dir+lump;\n\t\toffs=w2l->offs;\n\t\tcsz=w2l->csize;\n\t\tdsz=w2l->dsize;\n\t\tcmp=w2l->cmp;\n\t}\n\t\n\tif(ofs>=dsz)\n\t\treturn(NULL);\n\n\tfraga=img->lca_data[lump];\n\tif(!fraga)\n\t{\n\t\tfraga=TK_Wad4_ZMalloc(64*sizeof(int),\n\t\t\tTK_W4PU_CACHE, img->lca_data+lump);\n\t\tTK_Wad4_ZChangeTagEvict(fraga, TK_W4PU_CACHEDIRTY,\n\t\t\tTK_Wad4_LumpEvFunc, img);\n\t\timg->lca_data[lump]=fraga;\n\n\t\tfd=img->img_fd;\n\t\tif(fd)\n\t\t{\n\t\t\ttk_fseek(fd, offs, 0);\n\t\t\ttk_fread(fraga, 1, csz, fd);\n\t\t}else\n\t\t{\n\t\t\tmemset(fraga, 0, 64*sizeof(int));\n\t\t}\n\t}\n\t\n\tn=csz>>2;\n\ti=0; offs1=ofs;\n\twhile(i<n)\n\t{\n\t\tlmp1=fraga[i];\n\t\tif(lmp1<=0)\n\t\t{\n\t\t\tlmp1=TK_Wad4_AllocateNewFragLump(img);\n\t\t\tfraga[i]=lmp1;\n\t\t}\n\t\tsz1=TK_Wad4_GetLumpSize(img, lmp1);\n\t\tif(offs1<sz1)\n\t\t\tbreak;\n\t\tif((offs1<TK_W4_FRAGSZ) && (fraga[i+1]<=0))\n\t\t\tbreak;\n\t\toffs1-=sz1;\n\t\ti++;\n\t}\n\t\n\tif(i>=n)\n\t\treturn(NULL);\n\n\t*rrofs=offs1;\n\t\n\tsz1=offs1+wsz;\n\tif(sz1>TK_W4_FRAGSZ)\n\t\tsz1=TK_W4_FRAGSZ;\n\t\n//\tptr=TK_Wad4_GetCacheLumpNum(img, lmp1, rsz);\n//\tptr=TK_Wad4_GetCacheExpandLumpNum(img, lmp1, ofs1+wsz, rsz);\n\tptr=TK_Wad4_GetCacheExpandLumpNum(img, lmp1, sz1, rsz);\n\treturn(ptr);\n}", "item_id": 30, "repo": "cr88192/bgbtech_btsr1arch", "file": "tk_qsrc/tk_clib/vxcore/tk_core/tk_wad4.c", "last_update_at": "2021-12-01T08:12:17+00:00", "question_id": "52088ac6465f21c36a77eb8db8dc18865ce91d54_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void *TK_Wad4_GetCacheExpandLumpNumOffs(TK_WadImage *img,\n\tint lump, int ofs, int wsz, int *rrofs, int *rsz)\n{\n\tint\t\tfraga[64];\n\tTK_Wad4Lump\t*w4l;\n\tTK_Wad2Lump\t*w2l;\n\tTK_FILE\t\t*fd;\n\tbyte\t\t*tptr;\n\ts64 offs;\n\tint csz, lmp1, offs1, csz1;\n\tint dsz, sz1;\n\tvoid *ptr;\n\tint cmp;\n\tint i, j, k, n;\n\t\n\tcmp=TK_Wad4_GetLumpEntCmp(img, lump);\n\tif(cmp<0)\n\t\treturn(NULL);\n\t\n\tif(cmp!=TK_W4CMP_FRAG)\n\t{\n\t\t*rrofs=0;\n//\t\tptr=TK_Wad4_GetCacheLumpNum(img, lump, rsz);\n\t\tptr=TK_Wad4_GetCacheExpandLumpNum(img, lump, ofs+wsz, rsz);\n\t\treturn(ptr);\n\t}\n\tif(img->w4dir)\n\t{\n\t\tw4l=img->w4dir+lump;\n\t\toffs=(w4l->offs)<<6;\n\t\tcsz=w4l->csize;\n\t\tdsz=w4l->dsize;\n\t\tcmp=w4l->cmp;\n\t}else if(img->w2dir)\n\t{\n\t\tw2l=img->w2dir+lump;\n\t\toffs=w2l->offs;\n\t\tcsz=w2l->csize;\n\t\tdsz=w2l->dsize;\n\t\tcmp=w2l->cmp;\n\t}\n\t\n\tif(ofs>=dsz)\n\t\treturn(NULL);\n\tfraga=img->lca_data[lump];\n\tif(!fraga)\n\t{\n\t\tfraga=TK_Wad4_ZMalloc(64*sizeof(int),\n\t\t\tTK_W4PU_CACHE, img->lca_data+lump);\n\t\tTK_Wad4_ZChangeTagEvict(fraga, TK_W4PU_CACHEDIRTY,\n\t\t\tTK_Wad4_LumpEvFunc, img);\n\t\timg->lca_data[lump]=fraga;\n\t\tfd=img->img_fd;\n\t\tif(fd)\n\t\t{\n\t\t\ttk_fseek(fd, offs, 0);\n\t\t\ttk_fread(fraga, 1, csz, fd);\n\t\t}else\n\t\t{\n\t\t\tmemset(fraga, 0, 64*sizeof(int));\n\t\t}\n\t}\n\t\n\tn=csz>>2;\n\ti=0; offs1=ofs;\n\twhile(i<n)\n\t{\n\t\tlmp1=fraga[i];\n\t\tif(lmp1<=0)\n\t\t{\n\t\t\tlmp1=TK_Wad4_AllocateNewFragLump(img);\n\t\t\tfraga[i]=lmp1;\n\t\t}\n\t\tsz1=TK_Wad4_GetLumpSize(img, lmp1);\n\t\tif(offs1<sz1)\n\t\t\tbreak;\n\t\tif((offs1<TK_W4_FRAGSZ) && (fraga[i+1]<=0))\n\t\t\tbreak;\n\t\toffs1-=sz1;\n\t\ti++;\n\t}\n\t\n\tif(i>=n)\n\t\treturn(NULL);\n\t*rrofs=offs1;\n\t\n\tsz1=offs1+wsz;\n\tif(sz1>TK_W4_FRAGSZ)\n\t\tsz1=TK_W4_FRAGSZ;\n\t\n//\tptr=TK_Wad4_GetCacheLumpNum(img, lmp1, rsz);\n//\tptr=TK_Wad4_GetCacheExpandLumpNum(img, lmp1, ofs1+wsz, rsz);\n\tptr=TK_Wad4_GetCacheExpandLumpNum(img, lmp1, sz1, rsz);\n\treturn(ptr);\n"]]}
{"hexsha": "7f0be8f56cb0ee3fc0ab97b267d248662f960a94", "ext": "c", "lang": "C", "content": "void f51(void) {\n    \tint64_t x242 = -554525LL;\n\tvolatile int8_t x243 = INT8_MIN;\n\tvolatile uint64_t x244 = UINT64_MAX;\n\tuint64_t t51 = 51LLU;\n\n    t51 = (((x241^x242)-x243)^x244);\n\n    if (t51 != 554424LLU) { NG(); } else { ; }\n\t\n}", "item_id": 51, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test2576.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "7f0be8f56cb0ee3fc0ab97b267d248662f960a94_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f51(void) {\n    \tint64_t x242 = -554525LL;\n\tvolatile int8_t x243 = INT8_MIN;\n\tvolatile uint64_t x244 = UINT64_MAX;\n\tuint64_t t51 = 51LLU;\n    t51 = (((x241^x242)-x243)^x244);\n    if (t51 != 554424LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "bae03da8cf60ef82acebc0a855c78f3baca74d0f", "ext": "c", "lang": "C", "content": "void f131(void) {\n    \tuint64_t x556 = UINT64_MAX;\n\tvolatile int32_t t131 = -114;\n\n    t131 = (((x553^x554)-x555)<=x556);\n\n    if (t131 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 131, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test2572.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "bae03da8cf60ef82acebc0a855c78f3baca74d0f_131", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f131(void) {\n    \tuint64_t x556 = UINT64_MAX;\n\tvolatile int32_t t131 = -114;\n    t131 = (((x553^x554)-x555)<=x556);\n    if (t131 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "8985befacafccf376c7213e5c442b2397928db45", "ext": "c", "lang": "C", "content": "void f35(void) {\n    \tstatic int32_t x213 = INT32_MAX;\n\tint32_t x214 = 164;\n\n    t35 = (x213%(x214+(x215*x216)));\n\n    if (t35 != 89) { NG(); } else { ; }\n\t\n}", "item_id": 35, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test397.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "8985befacafccf376c7213e5c442b2397928db45_35", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f35(void) {\n    \tstatic int32_t x213 = INT32_MAX;\n\tint32_t x214 = 164;\n    t35 = (x213%(x214+(x215*x216)));\n    if (t35 != 89) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "71852a42faa57de31b76aff42b7d47fa5ea76831", "ext": "c", "lang": "C", "content": "void f143(void) {\n    \tint8_t x585 = -1;\n\tint8_t x586 = -1;\n\tint32_t t143 = 0;\n\n    t143 = (((x585&x586)>x587)/x588);\n\n    if (t143 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 143, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test2272.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "71852a42faa57de31b76aff42b7d47fa5ea76831_143", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f143(void) {\n    \tint8_t x585 = -1;\n\tint8_t x586 = -1;\n\tint32_t t143 = 0;\n    t143 = (((x585&x586)>x587)/x588);\n    if (t143 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "1e0674ce8c0708221843e5819b044cc0ae204fc4", "ext": "c", "lang": "C", "content": "int main(int argc, char *argv[]) {\n  MazeType maze[N][N];\n  PosType start, end;\n  SElemType_Sq e;\n  char Re = 'Y';\n\n  while (Re == 'Y' || Re == 'y') {\n    InitMaze(maze, &start, &end);  //\u521d\u59cb\u5316\u8ff7\u5bab\uff0c\u5305\u62ec\u51fa\u5165\u53e3\n    ShowMaze(maze);                //\u663e\u793a\u8ff7\u5bab\u7684\u521d\u59cb\u72b6\u6001\n    MazePath(maze, start, end);    //\u8ff7\u5bab\u5bfb\u8def\n\n    printf(\"\u91cd\u7f6e\uff1f\uff08Y/N\uff09\uff1a\");\n    scanf(\"%c\", &Re);\n  }\n\n  return 0;\n}", "item_id": 0, "repo": "Lornatang/data-structure", "file": "03-StackAndQueue/04 Maze/Maze-main.c", "last_update_at": "2021-06-17T13:18:08+00:00", "question_id": "1e0674ce8c0708221843e5819b044cc0ae204fc4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char *argv[]) {\n  MazeType maze[N][N];\n  PosType start, end;\n  SElemType_Sq e;\n  char Re = 'Y';\n  while (Re == 'Y' || Re == 'y') {\n    InitMaze(maze, &start, &end);  //\u521d\u59cb\u5316\u8ff7\u5bab\uff0c\u5305\u62ec\u51fa\u5165\u53e3\n    ShowMaze(maze);                //\u663e\u793a\u8ff7\u5bab\u7684\u521d\u59cb\u72b6\u6001\n    MazePath(maze, start, end);    //\u8ff7\u5bab\u5bfb\u8def\n    printf(\"\u91cd\u7f6e\uff1f\uff08Y/N\uff09\uff1a\");\n    scanf(\"%c\", &Re);\n  }\n  return 0;\n"]]}
{"hexsha": "4339c7a0a7eedd6794e309bb460a8a02e1bf07be", "ext": "c", "lang": "C", "content": "static int uart_dma_tx_init(void)\n{\n\tdma_cfg_init(&dma_tx_cfg, &dma_tx_blk_cfg);\n\tdma_tx_cfg.channel_direction = MEMORY_TO_PERIPHERAL;\n\tdma_tx_cfg.dma_callback = dma_tx_callback;\n\tdma_tx_blk_cfg.dest_address = USART_DR;\n\tuart_dma_tx_enable();\n\n\treturn 0;\n}", "item_id": 7, "repo": "zhuhaijun753/2G_ADAS", "file": "apps/linde/src/netlib/atd.c", "last_update_at": "2021-09-28T04:27:14+00:00", "question_id": "4339c7a0a7eedd6794e309bb460a8a02e1bf07be_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int uart_dma_tx_init(void)\n{\n\tdma_cfg_init(&dma_tx_cfg, &dma_tx_blk_cfg);\n\tdma_tx_cfg.channel_direction = MEMORY_TO_PERIPHERAL;\n\tdma_tx_cfg.dma_callback = dma_tx_callback;\n\tdma_tx_blk_cfg.dest_address = USART_DR;\n\tuart_dma_tx_enable();\n\treturn 0;\n"]]}
{"hexsha": "b5c23f1adff2bfd76eecdcbe0ea620d9d4e41eee", "ext": "c", "lang": "C", "content": "int file_getInfo(id_t fid, size_t *sectors, size_t *filesz, size_t *recordsz, size_t *recordcnt)\n{\n\tmeterfs_i_devctl_t iptr;\n\tmeterfs_o_devctl_t optr;\n\tint err;\n\n\tiptr.type = meterfs_info;\n\tiptr.id = fid;\n\n\tif ((err = hostflashsrv_devctl(&iptr, &optr)) < 0)\n\t\treturn err;\n\n\tif (sectors != NULL)\n\t\t(*sectors) = optr.info.sectors;\n\n\tif (filesz != NULL)\n\t\t(*filesz) = optr.info.filesz;\n\n\tif (recordsz != NULL)\n\t\t(*recordsz) = optr.info.recordsz;\n\n\tif (recordcnt != NULL)\n\t\t(*recordcnt) = optr.info.recordcnt;\n\n\treturn 0;\n}", "item_id": 3, "repo": "gthsajmon/phoenix-rtos-tests", "file": "meterfs/file_pc.c", "last_update_at": "2021-07-06T20:39:28+00:00", "question_id": "b5c23f1adff2bfd76eecdcbe0ea620d9d4e41eee_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int file_getInfo(id_t fid, size_t *sectors, size_t *filesz, size_t *recordsz, size_t *recordcnt)\n{\n\tmeterfs_i_devctl_t iptr;\n\tmeterfs_o_devctl_t optr;\n\tint err;\n\tiptr.type = meterfs_info;\n\tiptr.id = fid;\n\tif ((err = hostflashsrv_devctl(&iptr, &optr)) < 0)\n\t\treturn err;\n\tif (sectors != NULL)\n\t\t(*sectors) = optr.info.sectors;\n\tif (filesz != NULL)\n\t\t(*filesz) = optr.info.filesz;\n\tif (recordsz != NULL)\n\t\t(*recordsz) = optr.info.recordsz;\n\tif (recordcnt != NULL)\n\t\t(*recordcnt) = optr.info.recordcnt;\n\treturn 0;\n"]]}
{"hexsha": "768538b1fd1915b8d19b3800188811bed72de1a5", "ext": "c", "lang": "C", "content": "bool do_ite_lookup_op(chunk_ptr op) {\n    ref_mgr mgr = dmgr->rmgr;\n    dword_t dest = chunk_get_dword(op, OP_HEADER_CNT);\n    ref_t iref = (ref_t) chunk_get_word(op, 0+OPER_SIZE+OP_HEADER_CNT);\n    ref_t tref = (ref_t) chunk_get_word(op, 1+OPER_SIZE+OP_HEADER_CNT);\n    ref_t eref = (ref_t) chunk_get_word(op, 2+OPER_SIZE+OP_HEADER_CNT);\n    bool negate = (bool) chunk_get_word(op, 3+OPER_SIZE+OP_HEADER_CNT);\n#if RPT >= 4\n    char buf1[24], buf2[24], buf3[24];\n    ref_show(iref, buf1); ref_show(tref, buf2); ref_show(eref, buf3);\n    char *ns = negate ? \"!\" : \"\";\n    report(4, \"Computing %sITE(%s, %s, %s)\", ns, buf1, buf2, buf3);\n#endif\n    chunk_ptr ucp = ref3_encode(iref, tref, eref);\n    ref_t rlook = ref_ite_lookup(mgr, ucp);\n    if (!REF_IS_RECURSE(rlook)) {\n\tchunk_free(ucp);\n\tif (negate)\n\t    rlook = REF_NEGATE(rlook);\n#if RPT >= 4\n\tchar buf1[24];\n\tref_show(rlook, buf1);\n\treport(4, \"\\tFound via lookup: %s\", buf1);\n#endif\n\tbool ok = send_ref_as_operand(dest, rlook);\t\n\treturn ok;\n    }\n    /* Check if pending ITE */\n    word_t wk, wv;\n    if (keyvalue_remove(dmgr->deferred_ite_table, (word_t) ucp, &wk, &wv)) {\n\t/* Add to deferred ITE table */\n\tchunk_ptr old_ucp = (chunk_ptr) wk;\n\tilist_ptr ls = (ilist_ptr) wv;\n\tilist_ptr ele = ilist_new(dest, negate);\n\t/* Add to list */\n\tele->next = ls;\n\tkeyvalue_insert(dmgr->deferred_ite_table, (word_t) old_ucp,\n\t\t\t(word_t) ele);\n\tchunk_free(ucp);\n#if RPT >= 4\n\tchar ibuf[24], tbuf[24], ebuf[24];\n\tref_show(iref, ibuf); ref_show(tref, tbuf), ref_show(eref, ebuf);\n\tchar *sn = negate ? \"!\" : \"\";\n\tword_t op_id = msg_get_dest_op_id(dest);\n\tunsigned agent = msg_get_dest_agent(dest);\n\treport(4, \"\\tDeferring %sITE(%s, %s, %s).  Agent %u, Op Id 0x%lx\",\n\t       sn, ibuf, tbuf, ebuf, agent, op_id);\n#endif\t    \n\treturn true;\n    } else {\n\t/* Insert empty list as placeholder */\n\tilist_ptr ls = NULL;\n\tkeyvalue_insert(dmgr->deferred_ite_table, (word_t) ucp, (word_t) ls);\n    }\n    /* Must do recursion */\n    size_t ivar = REF_GET_VAR(iref);\n    size_t tvar = REF_GET_VAR(tref);\n    size_t evar = REF_GET_VAR(eref);\n    size_t var = ivar;\n    if (tvar < var) { var = tvar; }\n    if (evar < var) { var = evar; }\n    ref_t vref = REF_VAR(var);\n#if RPT >= 4\n    ref_show(vref, buf1);\n    report(4, \"\\tSplitting on variable %s\", buf1);\n#endif\n    /* Create next operations */\n    chunk_ptr sop = build_ite_store(dest, iref, tref, eref, negate);\n    dword_t sdest =  msg_new_destination(sop, 3+OPER_SIZE+OP_HEADER_CNT);\n    chunk_ptr rop = build_ite_recurse(sdest, vref);\n    ref_t nvref, nhiref, nloref;\n    bool ok = true;\n    /* Fill in any known fields, and spawn retrieve operations for others */\n    if (ivar == var) {\n\tif (ref_deref_local(iref, &nvref, &nhiref, &nloref)) {\n\t    op_insert_word(rop, (word_t) nhiref, 1+OPER_SIZE+OP_HEADER_CNT);\n\t    op_insert_word(rop, (word_t) nloref, 2+OPER_SIZE+OP_HEADER_CNT);\n\t} else {\n\t    dword_t ndest = msg_new_destination(rop, 1+OPER_SIZE+OP_HEADER_CNT);\n\t    ok = ok && send_retrieve(ndest, iref);\n\t}\n    } else {\n\top_insert_word(rop, (word_t) iref, 1+OPER_SIZE+OP_HEADER_CNT);\n\top_insert_word(rop, (word_t) iref, 2+OPER_SIZE+OP_HEADER_CNT);\n    }\n    if (tvar == var) {\n\tif (ref_deref_local(tref, &nvref, &nhiref, &nloref)) {\n\t    op_insert_word(rop, (word_t) nhiref, 3+OPER_SIZE+OP_HEADER_CNT);\n\t    op_insert_word(rop, (word_t) nloref, 4+OPER_SIZE+OP_HEADER_CNT);\n\t} else {\n\t    dword_t ndest = msg_new_destination(rop, 3+OPER_SIZE+OP_HEADER_CNT);\n\t    ok = ok && send_retrieve(ndest, tref);\n\t}\n    } else {\n\top_insert_word(rop, (word_t) tref, 3+OPER_SIZE+OP_HEADER_CNT);\n\top_insert_word(rop, (word_t) tref, 4+OPER_SIZE+OP_HEADER_CNT);\n    }\n    if (evar == var) {\n\tif (ref_deref_local(eref, &nvref, &nhiref, &nloref)) {\n\t    op_insert_word(rop, (word_t) nhiref, 5+OPER_SIZE+OP_HEADER_CNT);\n\t    op_insert_word(rop, (word_t) nloref, 6+OPER_SIZE+OP_HEADER_CNT);\n\t} else {\n\t    dword_t ndest = msg_new_destination(rop, 5+OPER_SIZE+OP_HEADER_CNT);\n\t    ok = ok && send_retrieve(ndest, eref);\n\t}\n    } else {\n\top_insert_word(rop, (word_t) eref, 5+OPER_SIZE+OP_HEADER_CNT);\n\top_insert_word(rop, (word_t) eref, 6+OPER_SIZE+OP_HEADER_CNT);\n    }\n    ok = ok && send_op(sop);\n    ok = ok && send_op(rop);\n    chunk_free(sop);\n    chunk_free(rop);\n    return ok;\n}", "item_id": 69, "repo": "rebryant/Cloud-BDD", "file": "bdd.c", "last_update_at": "2021-05-21T13:29:43+00:00", "question_id": "768538b1fd1915b8d19b3800188811bed72de1a5_69", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool do_ite_lookup_op(chunk_ptr op) {\n    ref_mgr mgr = dmgr->rmgr;\n    dword_t dest = chunk_get_dword(op, OP_HEADER_CNT);\n    ref_t iref = (ref_t) chunk_get_word(op, 0+OPER_SIZE+OP_HEADER_CNT);\n    ref_t tref = (ref_t) chunk_get_word(op, 1+OPER_SIZE+OP_HEADER_CNT);\n    ref_t eref = (ref_t) chunk_get_word(op, 2+OPER_SIZE+OP_HEADER_CNT);\n    bool negate = (bool) chunk_get_word(op, 3+OPER_SIZE+OP_HEADER_CNT);\n#if RPT >= 4\n    char buf1[24], buf2[24], buf3[24];\n    ref_show(iref, buf1); ref_show(tref, buf2); ref_show(eref, buf3);\n    char *ns = negate ? \"!\" : \"\";\n    report(4, \"Computing %sITE(%s, %s, %s)\", ns, buf1, buf2, buf3);\n#endif\n    chunk_ptr ucp = ref3_encode(iref, tref, eref);\n    ref_t rlook = ref_ite_lookup(mgr, ucp);\n    if (!REF_IS_RECURSE(rlook)) {\n\tchunk_free(ucp);\n\tif (negate)\n\t    rlook = REF_NEGATE(rlook);\n#if RPT >= 4\n\tchar buf1[24];\n\tref_show(rlook, buf1);\n\treport(4, \"\\tFound via lookup: %s\", buf1);\n#endif\n\tbool ok = send_ref_as_operand(dest, rlook);\t\n\treturn ok;\n    }\n    /* Check if pending ITE */\n    word_t wk, wv;\n    if (keyvalue_remove(dmgr->deferred_ite_table, (word_t) ucp, &wk, &wv)) {\n\t/* Add to deferred ITE table */\n\tchunk_ptr old_ucp = (chunk_ptr) wk;\n\tilist_ptr ls = (ilist_ptr) wv;\n\tilist_ptr ele = ilist_new(dest, negate);\n\t/* Add to list */\n\tele->next = ls;\n\tkeyvalue_insert(dmgr->deferred_ite_table, (word_t) old_ucp,\n\t\t\t(word_t) ele);\n\tchunk_free(ucp);\n#if RPT >= 4\n\tchar ibuf[24], tbuf[24], ebuf[24];\n\tref_show(iref, ibuf); ref_show(tref, tbuf), ref_show(eref, ebuf);\n\tchar *sn = negate ? \"!\" : \"\";\n\tword_t op_id = msg_get_dest_op_id(dest);\n\tunsigned agent = msg_get_dest_agent(dest);\n\treport(4, \"\\tDeferring %sITE(%s, %s, %s).  Agent %u, Op Id 0x%lx\",\n\t       sn, ibuf, tbuf, ebuf, agent, op_id);\n#endif\t    \n\treturn true;\n    } else {\n\t/* Insert empty list as placeholder */\n\tilist_ptr ls = NULL;\n\tkeyvalue_insert(dmgr->deferred_ite_table, (word_t) ucp, (word_t) ls);\n    }\n    /* Must do recursion */\n    size_t ivar = REF_GET_VAR(iref);\n    size_t tvar = REF_GET_VAR(tref);\n    size_t evar = REF_GET_VAR(eref);\n    size_t var = ivar;\n    if (tvar < var) { var = tvar; }\n    if (evar < var) { var = evar; }\n    ref_t vref = REF_VAR(var);\n#if RPT >= 4\n    ref_show(vref, buf1);\n    report(4, \"\\tSplitting on variable %s\", buf1);\n#endif\n    /* Create next operations */\n    chunk_ptr sop = build_ite_store(dest, iref, tref, eref, negate);\n    dword_t sdest =  msg_new_destination(sop, 3+OPER_SIZE+OP_HEADER_CNT);\n    chunk_ptr rop = build_ite_recurse(sdest, vref);\n    ref_t nvref, nhiref, nloref;\n    bool ok = true;\n    /* Fill in any known fields, and spawn retrieve operations for others */\n    if (ivar == var) {\n\tif (ref_deref_local(iref, &nvref, &nhiref, &nloref)) {\n\t    op_insert_word(rop, (word_t) nhiref, 1+OPER_SIZE+OP_HEADER_CNT);\n\t    op_insert_word(rop, (word_t) nloref, 2+OPER_SIZE+OP_HEADER_CNT);\n\t} else {\n\t    dword_t ndest = msg_new_destination(rop, 1+OPER_SIZE+OP_HEADER_CNT);\n\t    ok = ok && send_retrieve(ndest, iref);\n\t}\n    } else {\n\top_insert_word(rop, (word_t) iref, 1+OPER_SIZE+OP_HEADER_CNT);\n\top_insert_word(rop, (word_t) iref, 2+OPER_SIZE+OP_HEADER_CNT);\n    }\n    if (tvar == var) {\n\tif (ref_deref_local(tref, &nvref, &nhiref, &nloref)) {\n\t    op_insert_word(rop, (word_t) nhiref, 3+OPER_SIZE+OP_HEADER_CNT);\n\t    op_insert_word(rop, (word_t) nloref, 4+OPER_SIZE+OP_HEADER_CNT);\n\t} else {\n\t    dword_t ndest = msg_new_destination(rop, 3+OPER_SIZE+OP_HEADER_CNT);\n\t    ok = ok && send_retrieve(ndest, tref);\n\t}\n    } else {\n\top_insert_word(rop, (word_t) tref, 3+OPER_SIZE+OP_HEADER_CNT);\n\top_insert_word(rop, (word_t) tref, 4+OPER_SIZE+OP_HEADER_CNT);\n    }\n    if (evar == var) {\n\tif (ref_deref_local(eref, &nvref, &nhiref, &nloref)) {\n\t    op_insert_word(rop, (word_t) nhiref, 5+OPER_SIZE+OP_HEADER_CNT);\n\t    op_insert_word(rop, (word_t) nloref, 6+OPER_SIZE+OP_HEADER_CNT);\n\t} else {\n\t    dword_t ndest = msg_new_destination(rop, 5+OPER_SIZE+OP_HEADER_CNT);\n\t    ok = ok && send_retrieve(ndest, eref);\n\t}\n    } else {\n\top_insert_word(rop, (word_t) eref, 5+OPER_SIZE+OP_HEADER_CNT);\n\top_insert_word(rop, (word_t) eref, 6+OPER_SIZE+OP_HEADER_CNT);\n    }\n    ok = ok && send_op(sop);\n    ok = ok && send_op(rop);\n    chunk_free(sop);\n    chunk_free(rop);\n    return ok;\n"]]}
{"hexsha": "290682cabf58e1966b565e40b753b1458ec5fa37", "ext": "c", "lang": "C", "content": "enum ps_status ps_keyboard_get_scancode_from_key(struct ps_passion *this,\n        enum ps_keycode keycode, enum ps_scancode *scancode\n)\n{\n        PS_CHECK(this && scancode, PS_STATUS_INVALID_ARGUMENT);\n\n        SDL_Keycode sdl_keycode = (SDL_Keycode)keycode;\n        SDL_Scancode sdl_scancode = SDL_GetScancodeFromKey(sdl_keycode);\n        *scancode = (enum ps_scancode)sdl_scancode;\n\n        return PS_STATUS_SUCCESS;\n}", "item_id": 2, "repo": "NeonMercury/passion", "file": "sources/libpassion/source/modules/ps_keyboard.c", "last_update_at": "2021-06-07T10:19:07+00:00", "question_id": "290682cabf58e1966b565e40b753b1458ec5fa37_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["enum ps_status ps_keyboard_get_scancode_from_key(struct ps_passion *this,\n        enum ps_keycode keycode, enum ps_scancode *scancode\n)\n{\n        PS_CHECK(this && scancode, PS_STATUS_INVALID_ARGUMENT);\n        SDL_Keycode sdl_keycode = (SDL_Keycode)keycode;\n        SDL_Scancode sdl_scancode = SDL_GetScancodeFromKey(sdl_keycode);\n        *scancode = (enum ps_scancode)sdl_scancode;\n        return PS_STATUS_SUCCESS;\n"]]}
{"hexsha": "c84d728ac4bad4130b09537549c645d806d003af", "ext": "c", "lang": "C", "content": "void f181(void) {\n    \tint64_t x753 = 43647385928585022LL;\n\tint32_t x754 = INT32_MIN;\n\tstatic volatile int32_t t181 = 82084139;\n\n    t181 = (((x753<=x754)/x755)==x756);\n\n    if (t181 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 181, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test1814.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "c84d728ac4bad4130b09537549c645d806d003af_181", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f181(void) {\n    \tint64_t x753 = 43647385928585022LL;\n\tint32_t x754 = INT32_MIN;\n\tstatic volatile int32_t t181 = 82084139;\n    t181 = (((x753<=x754)/x755)==x756);\n    if (t181 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "9a506ed1e55abb2dfa812f72580f371e758afec2", "ext": "c", "lang": "C", "content": "static unsigned int\ntic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n\t\t  unsigned int num_operands, unsigned int this_line_creg,\n\t\t  unsigned int this_line_z, unsigned int func_unit_side,\n\t\t  unsigned int func_unit_cross,\n\t\t  unsigned int func_unit_data_side, int sploop_ii,\n\t\t  expressionS **fix_exp, int *fix_pcrel,\n\t\t  bfd_reloc_code_real_type *fx_r_type, bfd_boolean *fix_adda,\n\t\t  bfd_boolean *fix_needed, bfd_boolean *ok,\n\t\t  bfd_boolean print_errors, char *str, int opc_len)\n{\n  const tic6x_opcode *opct;\n  const tic6x_insn_format *fmt;\n  unsigned int opcode_value;\n  unsigned int fld;\n\n  opct = &tic6x_opcode_table[id];\n  fmt = &tic6x_insn_format_table[opct->format];\n  opcode_value = fmt->cst_bits;\n\n  for (fld = 0; fld < opct->num_fixed_fields; fld++)\n    {\n      if (opct->fixed_fields[fld].min_val == opct->fixed_fields[fld].max_val)\n\t{\n\t  const tic6x_insn_field *fldd;\n\t  fldd = tic6x_field_from_fmt (fmt, opct->fixed_fields[fld].field_id);\n\t  if (fldd == NULL)\n\t    abort ();\n\t  opcode_value |= opct->fixed_fields[fld].min_val << fldd->bitfields[0].low_pos;\n\t}\n    }\n\n  for (fld = 0; fld < opct->num_variable_fields; fld++)\n    {\n      const tic6x_insn_field *fldd;\n      unsigned int value;\n      unsigned int opno;\n      unsigned int ffld;\n      offsetT sign_value;\n      unsigned int bits;\n      unsigned int fcyc_bits;\n      expressionS *expp;\n      expressionS ucexp;\n      tic6x_mem_ref mem;\n\n      fldd = tic6x_field_from_fmt (fmt, opct->variable_fields[fld].field_id);\n      if (fldd == NULL)\n\tabort ();\n      opno = opct->variable_fields[fld].operand_num;\n      switch (opct->variable_fields[fld].coding_method)\n\t{\n\tcase tic6x_coding_ucst:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op != O_constant)\n\t    abort ();\n\t  ucexp = operands[opno].value.exp;\n\tunsigned_constant:\n\t  if (ucexp.X_add_number < 0\n\t      || ucexp.X_add_number >= (1 << fldd->bitfields[0].width))\n\t    {\n\t      if (print_errors)\n\t\tas_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n\t\t\topc_len, str);\n\t      *ok = FALSE;\n\t      return 0;\n\t    }\n\t  value = ucexp.X_add_number;\n\t  break;\n\n\tcase tic6x_coding_scst:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op != O_constant)\n\t    {\n\t      value = 0;\n\t      /* Opcode table should not permit non-constants without\n\t\t a known relocation for them.  */\n\t      if (fldd->bitfields[0].low_pos != 7 || fldd->bitfields[0].width != 16)\n\t\tabort ();\n\t      *fix_needed = TRUE;\n\t      *fix_exp = &operands[opno].value.exp;\n\t      *fix_pcrel = 0;\n\t      *fx_r_type = BFD_RELOC_C6000_ABS_S16;\n\t      *fix_adda = FALSE;\n\t      break;\n\t    }\n\t  sign_value = SEXT (operands[opno].value.exp.X_add_number);\n\tsigned_constant:\n\t  if (sign_value < -(1 << (fldd->bitfields[0].width - 1))\n\t      || (sign_value >= (1 << (fldd->bitfields[0].width - 1))))\n\t    {\n\t      if (print_errors)\n\t\tas_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n\t\t\topc_len, str);\n\t      *ok = FALSE;\n\t      return 0;\n\t    }\n\t  value = sign_value + (1 << (fldd->bitfields[0].width - 1));\n\t  value ^= (1 << (fldd->bitfields[0].width - 1));\n\t  break;\n\n\tcase tic6x_coding_ucst_minus_one:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op != O_constant)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_add_number <= 0\n\t      || operands[opno].value.exp.X_add_number > (1 << fldd->bitfields[0].width))\n\t    {\n\t      if (print_errors)\n\t\tas_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n\t\t\topc_len, str);\n\t      *ok = FALSE;\n\t      return 0;\n\t    }\n\t  value = operands[opno].value.exp.X_add_number - 1;\n\t  break;\n\n\tcase tic6x_coding_scst_negate:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op != O_constant)\n\t    abort ();\n\t  sign_value = SEXT (-operands[opno].value.exp.X_add_number);\n\t  goto signed_constant;\n\n\tcase tic6x_coding_ulcst_dpr_byte:\n\tcase tic6x_coding_ulcst_dpr_half:\n\tcase tic6x_coding_ulcst_dpr_word:\n\t  bits = tic6x_dpr_shift (opct->variable_fields[fld].coding_method);\n\t  switch (operands[opno].form)\n\t    {\n\t    case TIC6X_OP_EXP:\n\t      if (operands[opno].value.exp.X_op == O_constant)\n\t\t{\n\t\t  ucexp = operands[opno].value.exp;\n\t\t  goto unsigned_constant;\n\t\t}\n\t      expp = &operands[opno].value.exp;\n\t      break;\n\n\t    case TIC6X_OP_MEM_NOUNREG:\n\t      mem = operands[opno].value.mem;\n\t      tic6x_default_mem_ref (&mem);\n\t      if (mem.offset_is_reg)\n\t\tabort ();\n\t      if (mem.offset.exp.X_op == O_constant)\n\t\t{\n\t\t  ucexp = mem.offset.exp;\n\t\t  if (mem.scaled == tic6x_offset_unscaled)\n\t\t    {\n\t\t      if (ucexp.X_add_number & ((1 << bits) - 1))\n\t\t\t{\n\t\t\t  if (print_errors)\n\t\t\t    as_bad (_(\"offset in operand %u of '%.*s' not \"\n\t\t\t\t      \"divisible by %u\"), opno + 1, opc_len,\n\t\t\t\t    str, 1u << bits);\n\t\t\t  *ok = FALSE;\n\t\t\t  return 0;\n\t\t\t}\n\t\t      ucexp.X_add_number >>= bits;\n\t\t    }\n\t\t  goto unsigned_constant;\n\t\t}\n\t      if (mem.scaled != tic6x_offset_unscaled)\n\t\tabort ();\n\t      if (operands[opno].value.mem.mod == tic6x_mem_mod_none\n\t\t  || operands[opno].value.mem.scaled != tic6x_offset_unscaled\n\t\t  || operands[opno].value.mem.offset_is_reg)\n\t\tabort ();\n\t      expp = &operands[opno].value.mem.offset.exp;\n\t      break;\n\n\t    default:\n\t      abort ();\n\t    }\n\t  value = 0;\n\t  /* Opcode table should not use this encoding without a known\n\t     relocation.  */\n\t  if (fldd->bitfields[0].low_pos != 8 || fldd->bitfields[0].width != 15)\n\t    abort ();\n\t  /* We do not check for offset divisibility here; such a\n\t     check is not needed at this point to encode the value,\n\t     and if there is eventually a problem it will be detected\n\t     either in md_apply_fix or at link time.  */\n\t  *fix_needed = TRUE;\n\t  *fix_exp = expp;\n\t  *fix_pcrel = 0;\n\t  *fx_r_type\n\t    = tic6x_dpr_reloc (opct->variable_fields[fld].coding_method);\n\t  if (operands[opno].form == TIC6X_OP_EXP)\n\t    *fix_adda = TRUE;\n\t  else\n\t    *fix_adda = FALSE;\n\t  break;\n\n\tcase tic6x_coding_lcst_low16:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op == O_constant)\n\t    value = operands[opno].value.exp.X_add_number & 0xffff;\n\t  else\n\t    {\n\t      value = 0;\n\t      /* Opcode table should not use this encoding without a\n\t\t known relocation.  */\n\t      if (fldd->bitfields[0].low_pos != 7 || fldd->bitfields[0].width != 16)\n\t\tabort ();\n\t      *fix_needed = TRUE;\n\t      *fix_exp = &operands[opno].value.exp;\n\t      *fix_pcrel = 0;\n\t      *fx_r_type = BFD_RELOC_C6000_ABS_L16;\n\t      *fix_adda = FALSE;\n\t    }\n\t  break;\n\n\tcase tic6x_coding_lcst_high16:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op == O_constant)\n\t    value = (operands[opno].value.exp.X_add_number >> 16) & 0xffff;\n\t  else\n\t    {\n\t      value = 0;\n\t      /* Opcode table should not use this encoding without a\n\t\t known relocation.  */\n\t      if (fldd->bitfields[0].low_pos != 7 || fldd->bitfields[0].width != 16)\n\t\tabort ();\n\t      *fix_needed = TRUE;\n\t      *fix_exp = &operands[opno].value.exp;\n\t      *fix_pcrel = 0;\n\t      *fx_r_type = BFD_RELOC_C6000_ABS_H16;\n\t      *fix_adda = FALSE;\n\t    }\n\t  break;\n\n\tcase tic6x_coding_pcrel:\n\tcase tic6x_coding_pcrel_half:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  value = 0;\n\t  *fix_needed = TRUE;\n\t  *fix_exp = &operands[opno].value.exp;\n\t  *fix_pcrel = 1;\n\t  if (fldd->bitfields[0].low_pos == 7 && fldd->bitfields[0].width == 21)\n\t    *fx_r_type = BFD_RELOC_C6000_PCR_S21;\n\t  else if (fldd->bitfields[0].low_pos == 16 && fldd->bitfields[0].width == 12)\n\t    *fx_r_type = BFD_RELOC_C6000_PCR_S12;\n\t  else if (fldd->bitfields[0].low_pos == 13 && fldd->bitfields[0].width == 10)\n\t    *fx_r_type = BFD_RELOC_C6000_PCR_S10;\n\t  else if (fldd->bitfields[0].low_pos == 16 && fldd->bitfields[0].width == 7)\n\t    *fx_r_type = BFD_RELOC_C6000_PCR_S7;\n\t  else\n\t    /* Opcode table should not use this encoding without a\n\t       known relocation.  */\n\t    abort ();\n\t  *fix_adda = FALSE;\n\t  break;\n\n\tcase tic6x_coding_regpair_lsb:\n\t  switch (operands[opno].form)\n\t    {\n\t    case TIC6X_OP_REGPAIR:\n\t      value = operands[opno].value.reg.num;\n\t      break;\n\n\t    default:\n\t      abort ();\n\t    }\n\t  break;\n\n\tcase tic6x_coding_regpair_msb:\n\t  switch (operands[opno].form)\n\t    {\n\t    case TIC6X_OP_REGPAIR:\n\t      value = operands[opno].value.reg.num + 1;\n\t      break;\n\n\t    default:\n\t      abort ();\n\t    }\n\t  break;\n\n\tcase tic6x_coding_reg:\n\t  switch (operands[opno].form)\n\t    {\n\t    case TIC6X_OP_REG:\n\t    case TIC6X_OP_REGPAIR:\n\t      value = operands[opno].value.reg.num;\n\t      break;\n\n\t    case TIC6X_OP_MEM_NOUNREG:\n\t    case TIC6X_OP_MEM_UNREG:\n\t      value = operands[opno].value.mem.base_reg.num;\n\t      break;\n\n\t    default:\n\t      abort ();\n\t    }\n\t  break;\n\n\tcase tic6x_coding_areg:\n\t  switch (operands[opno].form)\n\t    {\n\t    case TIC6X_OP_REG:\n\t      value = (operands[opno].value.reg.num == 15 ? 1 : 0);\n\t      break;\n\n\t    case TIC6X_OP_MEM_NOUNREG:\n\t      value = (operands[opno].value.mem.base_reg.num == 15 ? 1 : 0);\n\t      break;\n\n\t    default:\n\t      abort ();\n\t    }\n\t  break;\n\n\tcase tic6x_coding_crlo:\n\t  if (operands[opno].form != TIC6X_OP_CTRL)\n\t    abort ();\n\t  value = tic6x_ctrl_table[operands[opno].value.ctrl].crlo;\n\t  break;\n\n\tcase tic6x_coding_crhi:\n\t  if (operands[opno].form != TIC6X_OP_CTRL)\n\t    abort ();\n\t  value = 0;\n\t  break;\n\n\tcase tic6x_coding_reg_shift:\n\t  if (operands[opno].form != TIC6X_OP_REGPAIR)\n\t    abort ();\n\t  value = operands[opno].value.reg.num >> 1;\n\t  break;\n\n\tcase tic6x_coding_mem_offset:\n\t  if (operands[opno].form != TIC6X_OP_MEM_NOUNREG)\n\t    abort ();\n\t  mem = operands[opno].value.mem;\n\t  tic6x_default_mem_ref (&mem);\n\t  if (mem.offset_is_reg)\n\t    {\n\t      if (mem.scaled != tic6x_offset_scaled)\n\t\tabort ();\n\t      value = mem.offset.reg.num;\n\t    }\n\t  else\n\t    {\n\t      int scale;\n\n\t      if (mem.offset.exp.X_op != O_constant)\n\t\tabort ();\n\t      switch (mem.scaled)\n\t\t{\n\t\tcase tic6x_offset_scaled:\n\t\t  scale = 1;\n\t\t  break;\n\n\t\tcase tic6x_offset_unscaled:\n\t\t  scale = opct->operand_info[opno].size;\n\t\t  if (scale != 1 && scale != 2 && scale != 4 && scale != 8)\n\t\t    abort ();\n\t\t  break;\n\n\t\tdefault:\n\t\t  abort ();\n\t\t}\n\t      if (mem.offset.exp.X_add_number < 0\n\t\t  || mem.offset.exp.X_add_number >= (1 << fldd->bitfields[0].width) * scale)\n\t\t{\n\t\t  if (print_errors)\n\t\t    as_bad (_(\"offset in operand %u of '%.*s' out of range\"),\n\t\t\t    opno + 1, opc_len, str);\n\t\t  *ok = FALSE;\n\t\t  return 0;\n\t\t}\n\t      if (mem.offset.exp.X_add_number % scale)\n\t\t{\n\t\t  if (print_errors)\n\t\t    as_bad (_(\"offset in operand %u of '%.*s' not \"\n\t\t\t      \"divisible by %u\"),\n\t\t\t    opno + 1, opc_len, str, scale);\n\t\t  *ok = FALSE;\n\t\t  return 0;\n\t\t}\n\t      value = mem.offset.exp.X_add_number / scale;\n\t    }\n\t  break;\n\n\tcase tic6x_coding_mem_offset_noscale:\n\t  if (operands[opno].form != TIC6X_OP_MEM_UNREG)\n\t    abort ();\n\t  mem = operands[opno].value.mem;\n\t  tic6x_default_mem_ref (&mem);\n\t  if (mem.offset_is_reg)\n\t    value = mem.offset.reg.num;\n\t  else\n\t    {\n\t      if (mem.offset.exp.X_op != O_constant)\n\t\tabort ();\n\t      if (mem.offset.exp.X_add_number < 0\n\t\t  || mem.offset.exp.X_add_number >= (1 << fldd->bitfields[0].width))\n\t\t{\n\t\t  if (print_errors)\n\t\t    as_bad (_(\"offset in operand %u of '%.*s' out of range\"),\n\t\t\t    opno + 1, opc_len, str);\n\t\t  *ok = FALSE;\n\t\t  return 0;\n\t\t}\n\t      value = mem.offset.exp.X_add_number;\n\t    }\n\t  break;\n\n\tcase tic6x_coding_mem_mode:\n\t  if (operands[opno].form != TIC6X_OP_MEM_NOUNREG\n\t      && operands[opno].form != TIC6X_OP_MEM_UNREG)\n\t    abort ();\n\t  mem = operands[opno].value.mem;\n\t  tic6x_default_mem_ref (&mem);\n\t  switch (mem.mod)\n\t    {\n\t    case tic6x_mem_mod_plus:\n\t      value = 1;\n\t      break;\n\n\t    case tic6x_mem_mod_minus:\n\t      value = 0;\n\t      break;\n\n\t    case tic6x_mem_mod_preinc:\n\t      value = 9;\n\t      break;\n\n\t    case tic6x_mem_mod_predec:\n\t      value = 8;\n\t      break;\n\n\t    case tic6x_mem_mod_postinc:\n\t      value = 11;\n\t      break;\n\n\t    case tic6x_mem_mod_postdec:\n\t      value = 10;\n\t      break;\n\n\t    default:\n\t      abort ();\n\t    }\n\t  value += (mem.offset_is_reg ? 4 : 0);\n\t  break;\n\n\tcase tic6x_coding_scaled:\n\t  if (operands[opno].form != TIC6X_OP_MEM_UNREG)\n\t    abort ();\n\t  mem = operands[opno].value.mem;\n\t  tic6x_default_mem_ref (&mem);\n\t  switch (mem.scaled)\n\t    {\n\t    case tic6x_offset_unscaled:\n\t      value = 0;\n\t      break;\n\n\t    case tic6x_offset_scaled:\n\t      value = 1;\n\t      break;\n\n\t    default:\n\t      abort ();\n\t    }\n\t  break;\n\n\tcase tic6x_coding_spmask:\n\t  /* The position of such a field is hardcoded in the handling\n\t     of \"||^\".  */\n\t  if (fldd->bitfields[0].low_pos != 18)\n\t    abort ();\n\t  value = 0;\n\t  for (opno = 0; opno < num_operands; opno++)\n\t    {\n\t      unsigned int v;\n\n\t      v = tic6x_encode_spmask (operands[opno].value.func_unit.base,\n\t\t\t\t       operands[opno].value.func_unit.side);\n\t      if (value & v)\n\t\t{\n\t\t  if (print_errors)\n\t\t    as_bad (_(\"functional unit already masked for operand \"\n\t\t\t      \"%u of '%.*s'\"), opno + 1, opc_len, str);\n\t\t  *ok = FALSE;\n\t\t  return 0;\n\t\t}\n\t      value |= v;\n\t    }\n\t  break;\n\n\tcase tic6x_coding_reg_unused:\n\t  /* This is a placeholder; correct handling goes along with\n\t     resource constraint checks.  */\n\t  value = 0;\n\t  break;\n\n\tcase tic6x_coding_fstg:\n\tcase tic6x_coding_fcyc:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op != O_constant)\n\t    abort ();\n\t  if (!sploop_ii)\n\t    {\n\t      if (print_errors)\n\t\tas_bad (_(\"'%.*s' instruction not in a software \"\n\t\t\t  \"pipelined loop\"),\n\t\t\topc_len, str);\n\t      *ok = FALSE;\n\t      return 0;\n\t    }\n\n\t  if (sploop_ii <= 1)\n\t    fcyc_bits = 0;\n\t  else if (sploop_ii <= 2)\n\t    fcyc_bits = 1;\n\t  else if (sploop_ii <= 4)\n\t    fcyc_bits = 2;\n\t  else if (sploop_ii <= 8)\n\t    fcyc_bits = 3;\n\t  else if (sploop_ii <= 14)\n\t    fcyc_bits = 4;\n\t  else\n\t    abort ();\n\t  if (fcyc_bits > fldd->bitfields[0].width)\n\t    abort ();\n\n\t  if (opct->variable_fields[fld].coding_method == tic6x_coding_fstg)\n\t    {\n\t      int i, t;\n\t      if (operands[opno].value.exp.X_add_number < 0\n\t\t  || (operands[opno].value.exp.X_add_number\n\t\t      >= (1 << (fldd->bitfields[0].width - fcyc_bits))))\n\t\t{\n\t\t  if (print_errors)\n\t\t    as_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n\t\t\t    opc_len, str);\n\t\t  *ok = FALSE;\n\t\t  return 0;\n\t\t}\n\t      value = operands[opno].value.exp.X_add_number;\n\t      for (t = 0, i = fcyc_bits; i < fldd->bitfields[0].width; i++)\n\t\t{\n\t\t  t = (t << 1) | (value & 1);\n\t\t  value >>= 1;\n\t\t}\n\t      value = t << fcyc_bits;\n\t    }\n\t  else\n\t    {\n\t      if (operands[opno].value.exp.X_add_number < 0\n\t\t  || (operands[opno].value.exp.X_add_number >= sploop_ii))\n\t\t{\n\t\t  if (print_errors)\n\t\t    as_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n\t\t\t    opc_len, str);\n\t\t  *ok = FALSE;\n\t\t  return 0;\n\t\t}\n\t      value = operands[opno].value.exp.X_add_number;\n\t    }\n\t  break;\n\n\tcase tic6x_coding_fu:\n\t  value = func_unit_side == 2 ? 1 : 0;\n\t  break;\n\n\tcase tic6x_coding_data_fu:\n\t  value = func_unit_data_side == 2 ? 1 : 0;\n\t  break;\n\n\tcase tic6x_coding_xpath:\n\t  value = func_unit_cross;\n\t  break;\n\n\tdefault:\n\t  abort ();\n\t}\n\n      for (ffld = 0; ffld < opct->num_fixed_fields; ffld++)\n\tif ((opct->fixed_fields[ffld].field_id\n\t     == opct->variable_fields[fld].field_id)\n\t    && (value < opct->fixed_fields[ffld].min_val\n\t\t|| value > opct->fixed_fields[ffld].max_val))\n\t  {\n\t    if (print_errors)\n\t      as_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n\t\t      opc_len, str);\n\t    *ok = FALSE;\n\t    return 0;\n\t  }\n\n      opcode_value |= value << fldd->bitfields[0].low_pos;\n    }\n\n  if (this_line_creg)\n    {\n      const tic6x_insn_field *creg;\n      const tic6x_insn_field *z;\n\n      creg = tic6x_field_from_fmt (fmt, tic6x_field_creg);\n      if (creg == NULL)\n\t{\n\t  if (print_errors)\n\t    as_bad (_(\"instruction '%.*s' cannot be predicated\"),\n\t\t    opc_len, str);\n\t  *ok = FALSE;\n\t  return 0;\n\t}\n      z = tic6x_field_from_fmt (fmt, tic6x_field_z);\n      /* If there is a creg field, there must be a z field; otherwise\n\t there is an error in the format table.  */\n      if (z == NULL)\n\tabort ();\n\n      opcode_value |= this_line_creg << creg->bitfields[0].low_pos;\n      opcode_value |= this_line_z << z->bitfields[0].low_pos;\n    }\n\n  *ok = TRUE;\n  return opcode_value;\n}", "item_id": 24, "repo": "TheSledgeHammer/2.11BSD", "file": "contrib/gnu/binutils/dist/gas/config/tc-tic6x.c", "last_update_at": "2021-10-04T07:19:26+00:00", "question_id": "9a506ed1e55abb2dfa812f72580f371e758afec2_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static unsigned int\ntic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,\n\t\t  unsigned int num_operands, unsigned int this_line_creg,\n\t\t  unsigned int this_line_z, unsigned int func_unit_side,\n\t\t  unsigned int func_unit_cross,\n\t\t  unsigned int func_unit_data_side, int sploop_ii,\n\t\t  expressionS **fix_exp, int *fix_pcrel,\n\t\t  bfd_reloc_code_real_type *fx_r_type, bfd_boolean *fix_adda,\n\t\t  bfd_boolean *fix_needed, bfd_boolean *ok,\n\t\t  bfd_boolean print_errors, char *str, int opc_len)\n{\n  const tic6x_opcode *opct;\n  const tic6x_insn_format *fmt;\n  unsigned int opcode_value;\n  unsigned int fld;\n  opct = &tic6x_opcode_table[id];\n  fmt = &tic6x_insn_format_table[opct->format];\n  opcode_value = fmt->cst_bits;\n  for (fld = 0; fld < opct->num_fixed_fields; fld++)\n    {\n      if (opct->fixed_fields[fld].min_val == opct->fixed_fields[fld].max_val)\n\t{\n\t  const tic6x_insn_field *fldd;\n\t  fldd = tic6x_field_from_fmt (fmt, opct->fixed_fields[fld].field_id);\n\t  if (fldd == NULL)\n\t    abort ();\n\t  opcode_value |= opct->fixed_fields[fld].min_val << fldd->bitfields[0].low_pos;\n\t}\n    }\n  for (fld = 0; fld < opct->num_variable_fields; fld++)\n    {\n      const tic6x_insn_field *fldd;\n      unsigned int value;\n      unsigned int opno;\n      unsigned int ffld;\n      offsetT sign_value;\n      unsigned int bits;\n      unsigned int fcyc_bits;\n      expressionS *expp;\n      expressionS ucexp;\n      tic6x_mem_ref mem;\n      fldd = tic6x_field_from_fmt (fmt, opct->variable_fields[fld].field_id);\n      if (fldd == NULL)\n\tabort ();\n      opno = opct->variable_fields[fld].operand_num;\n      switch (opct->variable_fields[fld].coding_method)\n\t{\n\tcase tic6x_coding_ucst:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op != O_constant)\n\t    abort ();\n\t  ucexp = operands[opno].value.exp;\n\tunsigned_constant:\n\t  if (ucexp.X_add_number < 0\n\t      || ucexp.X_add_number >= (1 << fldd->bitfields[0].width))\n\t    {\n\t      if (print_errors)\n\t\tas_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n\t\t\topc_len, str);\n\t      *ok = FALSE;\n\t      return 0;\n\t    }\n\t  value = ucexp.X_add_number;\n\t  break;\n\tcase tic6x_coding_scst:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op != O_constant)\n\t    {\n\t      value = 0;\n\t      /* Opcode table should not permit non-constants without\n\t\t a known relocation for them.  */\n\t      if (fldd->bitfields[0].low_pos != 7 || fldd->bitfields[0].width != 16)\n\t\tabort ();\n\t      *fix_needed = TRUE;\n\t      *fix_exp = &operands[opno].value.exp;\n\t      *fix_pcrel = 0;\n\t      *fx_r_type = BFD_RELOC_C6000_ABS_S16;\n\t      *fix_adda = FALSE;\n\t      break;\n\t    }\n\t  sign_value = SEXT (operands[opno].value.exp.X_add_number);\n\tsigned_constant:\n\t  if (sign_value < -(1 << (fldd->bitfields[0].width - 1))\n\t      || (sign_value >= (1 << (fldd->bitfields[0].width - 1))))\n\t    {\n\t      if (print_errors)\n\t\tas_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n\t\t\topc_len, str);\n\t      *ok = FALSE;\n\t      return 0;\n\t    }\n\t  value = sign_value + (1 << (fldd->bitfields[0].width - 1));\n\t  value ^= (1 << (fldd->bitfields[0].width - 1));\n\t  break;\n\tcase tic6x_coding_ucst_minus_one:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op != O_constant)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_add_number <= 0\n\t      || operands[opno].value.exp.X_add_number > (1 << fldd->bitfields[0].width))\n\t    {\n\t      if (print_errors)\n\t\tas_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n\t\t\topc_len, str);\n\t      *ok = FALSE;\n\t      return 0;\n\t    }\n\t  value = operands[opno].value.exp.X_add_number - 1;\n\t  break;\n\tcase tic6x_coding_scst_negate:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op != O_constant)\n\t    abort ();\n\t  sign_value = SEXT (-operands[opno].value.exp.X_add_number);\n\t  goto signed_constant;\n\tcase tic6x_coding_ulcst_dpr_byte:\n\tcase tic6x_coding_ulcst_dpr_half:\n\tcase tic6x_coding_ulcst_dpr_word:\n\t  bits = tic6x_dpr_shift (opct->variable_fields[fld].coding_method);\n\t  switch (operands[opno].form)\n\t    {\n\t    case TIC6X_OP_EXP:\n\t      if (operands[opno].value.exp.X_op == O_constant)\n\t\t{\n\t\t  ucexp = operands[opno].value.exp;\n\t\t  goto unsigned_constant;\n\t\t}\n\t      expp = &operands[opno].value.exp;\n\t      break;\n\t    case TIC6X_OP_MEM_NOUNREG:\n\t      mem = operands[opno].value.mem;\n\t      tic6x_default_mem_ref (&mem);\n\t      if (mem.offset_is_reg)\n\t\tabort ();\n\t      if (mem.offset.exp.X_op == O_constant)\n\t\t{\n\t\t  ucexp = mem.offset.exp;\n\t\t  if (mem.scaled == tic6x_offset_unscaled)\n\t\t    {\n\t\t      if (ucexp.X_add_number & ((1 << bits) - 1))\n\t\t\t{\n\t\t\t  if (print_errors)\n\t\t\t    as_bad (_(\"offset in operand %u of '%.*s' not \"\n\t\t\t\t      \"divisible by %u\"), opno + 1, opc_len,\n\t\t\t\t    str, 1u << bits);\n\t\t\t  *ok = FALSE;\n\t\t\t  return 0;\n\t\t\t}\n\t\t      ucexp.X_add_number >>= bits;\n\t\t    }\n\t\t  goto unsigned_constant;\n\t\t}\n\t      if (mem.scaled != tic6x_offset_unscaled)\n\t\tabort ();\n\t      if (operands[opno].value.mem.mod == tic6x_mem_mod_none\n\t\t  || operands[opno].value.mem.scaled != tic6x_offset_unscaled\n\t\t  || operands[opno].value.mem.offset_is_reg)\n\t\tabort ();\n\t      expp = &operands[opno].value.mem.offset.exp;\n\t      break;\n\t    default:\n\t      abort ();\n\t    }\n\t  value = 0;\n\t  /* Opcode table should not use this encoding without a known\n\t     relocation.  */\n\t  if (fldd->bitfields[0].low_pos != 8 || fldd->bitfields[0].width != 15)\n\t    abort ();\n\t  /* We do not check for offset divisibility here; such a\n\t     check is not needed at this point to encode the value,\n\t     and if there is eventually a problem it will be detected\n\t     either in md_apply_fix or at link time.  */\n\t  *fix_needed = TRUE;\n\t  *fix_exp = expp;\n\t  *fix_pcrel = 0;\n\t  *fx_r_type\n\t    = tic6x_dpr_reloc (opct->variable_fields[fld].coding_method);\n\t  if (operands[opno].form == TIC6X_OP_EXP)\n\t    *fix_adda = TRUE;\n\t  else\n\t    *fix_adda = FALSE;\n\t  break;\n\tcase tic6x_coding_lcst_low16:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op == O_constant)\n\t    value = operands[opno].value.exp.X_add_number & 0xffff;\n\t  else\n\t    {\n\t      value = 0;\n\t      /* Opcode table should not use this encoding without a\n\t\t known relocation.  */\n\t      if (fldd->bitfields[0].low_pos != 7 || fldd->bitfields[0].width != 16)\n\t\tabort ();\n\t      *fix_needed = TRUE;\n\t      *fix_exp = &operands[opno].value.exp;\n\t      *fix_pcrel = 0;\n\t      *fx_r_type = BFD_RELOC_C6000_ABS_L16;\n\t      *fix_adda = FALSE;\n\t    }\n\t  break;\n\tcase tic6x_coding_lcst_high16:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op == O_constant)\n\t    value = (operands[opno].value.exp.X_add_number >> 16) & 0xffff;\n\t  else\n\t    {\n\t      value = 0;\n\t      /* Opcode table should not use this encoding without a\n\t\t known relocation.  */\n\t      if (fldd->bitfields[0].low_pos != 7 || fldd->bitfields[0].width != 16)\n\t\tabort ();\n\t      *fix_needed = TRUE;\n\t      *fix_exp = &operands[opno].value.exp;\n\t      *fix_pcrel = 0;\n\t      *fx_r_type = BFD_RELOC_C6000_ABS_H16;\n\t      *fix_adda = FALSE;\n\t    }\n\t  break;\n\tcase tic6x_coding_pcrel:\n\tcase tic6x_coding_pcrel_half:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  value = 0;\n\t  *fix_needed = TRUE;\n\t  *fix_exp = &operands[opno].value.exp;\n\t  *fix_pcrel = 1;\n\t  if (fldd->bitfields[0].low_pos == 7 && fldd->bitfields[0].width == 21)\n\t    *fx_r_type = BFD_RELOC_C6000_PCR_S21;\n\t  else if (fldd->bitfields[0].low_pos == 16 && fldd->bitfields[0].width == 12)\n\t    *fx_r_type = BFD_RELOC_C6000_PCR_S12;\n\t  else if (fldd->bitfields[0].low_pos == 13 && fldd->bitfields[0].width == 10)\n\t    *fx_r_type = BFD_RELOC_C6000_PCR_S10;\n\t  else if (fldd->bitfields[0].low_pos == 16 && fldd->bitfields[0].width == 7)\n\t    *fx_r_type = BFD_RELOC_C6000_PCR_S7;\n\t  else\n\t    /* Opcode table should not use this encoding without a\n\t       known relocation.  */\n\t    abort ();\n\t  *fix_adda = FALSE;\n\t  break;\n\tcase tic6x_coding_regpair_lsb:\n\t  switch (operands[opno].form)\n\t    {\n\t    case TIC6X_OP_REGPAIR:\n\t      value = operands[opno].value.reg.num;\n\t      break;\n\t    default:\n\t      abort ();\n\t    }\n\t  break;\n\tcase tic6x_coding_regpair_msb:\n\t  switch (operands[opno].form)\n\t    {\n\t    case TIC6X_OP_REGPAIR:\n\t      value = operands[opno].value.reg.num + 1;\n\t      break;\n\t    default:\n\t      abort ();\n\t    }\n\t  break;\n\tcase tic6x_coding_reg:\n\t  switch (operands[opno].form)\n\t    {\n\t    case TIC6X_OP_REG:\n\t    case TIC6X_OP_REGPAIR:\n\t      value = operands[opno].value.reg.num;\n\t      break;\n\t    case TIC6X_OP_MEM_NOUNREG:\n\t    case TIC6X_OP_MEM_UNREG:\n\t      value = operands[opno].value.mem.base_reg.num;\n\t      break;\n\t    default:\n\t      abort ();\n\t    }\n\t  break;\n\tcase tic6x_coding_areg:\n\t  switch (operands[opno].form)\n\t    {\n\t    case TIC6X_OP_REG:\n\t      value = (operands[opno].value.reg.num == 15 ? 1 : 0);\n\t      break;\n\t    case TIC6X_OP_MEM_NOUNREG:\n\t      value = (operands[opno].value.mem.base_reg.num == 15 ? 1 : 0);\n\t      break;\n\t    default:\n\t      abort ();\n\t    }\n\t  break;\n\tcase tic6x_coding_crlo:\n\t  if (operands[opno].form != TIC6X_OP_CTRL)\n\t    abort ();\n\t  value = tic6x_ctrl_table[operands[opno].value.ctrl].crlo;\n\t  break;\n\tcase tic6x_coding_crhi:\n\t  if (operands[opno].form != TIC6X_OP_CTRL)\n\t    abort ();\n\t  value = 0;\n\t  break;\n\tcase tic6x_coding_reg_shift:\n\t  if (operands[opno].form != TIC6X_OP_REGPAIR)\n\t    abort ();\n\t  value = operands[opno].value.reg.num >> 1;\n\t  break;\n\tcase tic6x_coding_mem_offset:\n\t  if (operands[opno].form != TIC6X_OP_MEM_NOUNREG)\n\t    abort ();\n\t  mem = operands[opno].value.mem;\n\t  tic6x_default_mem_ref (&mem);\n\t  if (mem.offset_is_reg)\n\t    {\n\t      if (mem.scaled != tic6x_offset_scaled)\n\t\tabort ();\n\t      value = mem.offset.reg.num;\n\t    }\n\t  else\n\t    {\n\t      int scale;\n\t      if (mem.offset.exp.X_op != O_constant)\n\t\tabort ();\n\t      switch (mem.scaled)\n\t\t{\n\t\tcase tic6x_offset_scaled:\n\t\t  scale = 1;\n\t\t  break;\n\t\tcase tic6x_offset_unscaled:\n\t\t  scale = opct->operand_info[opno].size;\n\t\t  if (scale != 1 && scale != 2 && scale != 4 && scale != 8)\n\t\t    abort ();\n\t\t  break;\n\t\tdefault:\n\t\t  abort ();\n\t\t}\n\t      if (mem.offset.exp.X_add_number < 0\n\t\t  || mem.offset.exp.X_add_number >= (1 << fldd->bitfields[0].width) * scale)\n\t\t{\n\t\t  if (print_errors)\n\t\t    as_bad (_(\"offset in operand %u of '%.*s' out of range\"),\n\t\t\t    opno + 1, opc_len, str);\n\t\t  *ok = FALSE;\n\t\t  return 0;\n\t\t}\n\t      if (mem.offset.exp.X_add_number % scale)\n\t\t{\n\t\t  if (print_errors)\n\t\t    as_bad (_(\"offset in operand %u of '%.*s' not \"\n\t\t\t      \"divisible by %u\"),\n\t\t\t    opno + 1, opc_len, str, scale);\n\t\t  *ok = FALSE;\n\t\t  return 0;\n\t\t}\n\t      value = mem.offset.exp.X_add_number / scale;\n\t    }\n\t  break;\n\tcase tic6x_coding_mem_offset_noscale:\n\t  if (operands[opno].form != TIC6X_OP_MEM_UNREG)\n\t    abort ();\n\t  mem = operands[opno].value.mem;\n\t  tic6x_default_mem_ref (&mem);\n\t  if (mem.offset_is_reg)\n\t    value = mem.offset.reg.num;\n\t  else\n\t    {\n\t      if (mem.offset.exp.X_op != O_constant)\n\t\tabort ();\n\t      if (mem.offset.exp.X_add_number < 0\n\t\t  || mem.offset.exp.X_add_number >= (1 << fldd->bitfields[0].width))\n\t\t{\n\t\t  if (print_errors)\n\t\t    as_bad (_(\"offset in operand %u of '%.*s' out of range\"),\n\t\t\t    opno + 1, opc_len, str);\n\t\t  *ok = FALSE;\n\t\t  return 0;\n\t\t}\n\t      value = mem.offset.exp.X_add_number;\n\t    }\n\t  break;\n\tcase tic6x_coding_mem_mode:\n\t  if (operands[opno].form != TIC6X_OP_MEM_NOUNREG\n\t      && operands[opno].form != TIC6X_OP_MEM_UNREG)\n\t    abort ();\n\t  mem = operands[opno].value.mem;\n\t  tic6x_default_mem_ref (&mem);\n\t  switch (mem.mod)\n\t    {\n\t    case tic6x_mem_mod_plus:\n\t      value = 1;\n\t      break;\n\t    case tic6x_mem_mod_minus:\n\t      value = 0;\n\t      break;\n\t    case tic6x_mem_mod_preinc:\n\t      value = 9;\n\t      break;\n\t    case tic6x_mem_mod_predec:\n\t      value = 8;\n\t      break;\n\t    case tic6x_mem_mod_postinc:\n\t      value = 11;\n\t      break;\n\t    case tic6x_mem_mod_postdec:\n\t      value = 10;\n\t      break;\n\t    default:\n\t      abort ();\n\t    }\n\t  value += (mem.offset_is_reg ? 4 : 0);\n\t  break;\n\tcase tic6x_coding_scaled:\n\t  if (operands[opno].form != TIC6X_OP_MEM_UNREG)\n\t    abort ();\n\t  mem = operands[opno].value.mem;\n\t  tic6x_default_mem_ref (&mem);\n\t  switch (mem.scaled)\n\t    {\n\t    case tic6x_offset_unscaled:\n\t      value = 0;\n\t      break;\n\t    case tic6x_offset_scaled:\n\t      value = 1;\n\t      break;\n\t    default:\n\t      abort ();\n\t    }\n\t  break;\n\tcase tic6x_coding_spmask:\n\t  /* The position of such a field is hardcoded in the handling\n\t     of \"||^\".  */\n\t  if (fldd->bitfields[0].low_pos != 18)\n\t    abort ();\n\t  value = 0;\n\t  for (opno = 0; opno < num_operands; opno++)\n\t    {\n\t      unsigned int v;\n\t      v = tic6x_encode_spmask (operands[opno].value.func_unit.base,\n\t\t\t\t       operands[opno].value.func_unit.side);\n\t      if (value & v)\n\t\t{\n\t\t  if (print_errors)\n\t\t    as_bad (_(\"functional unit already masked for operand \"\n\t\t\t      \"%u of '%.*s'\"), opno + 1, opc_len, str);\n\t\t  *ok = FALSE;\n\t\t  return 0;\n\t\t}\n\t      value |= v;\n\t    }\n\t  break;\n\tcase tic6x_coding_reg_unused:\n\t  /* This is a placeholder; correct handling goes along with\n\t     resource constraint checks.  */\n\t  value = 0;\n\t  break;\n\tcase tic6x_coding_fstg:\n\tcase tic6x_coding_fcyc:\n\t  if (operands[opno].form != TIC6X_OP_EXP)\n\t    abort ();\n\t  if (operands[opno].value.exp.X_op != O_constant)\n\t    abort ();\n\t  if (!sploop_ii)\n\t    {\n\t      if (print_errors)\n\t\tas_bad (_(\"'%.*s' instruction not in a software \"\n\t\t\t  \"pipelined loop\"),\n\t\t\topc_len, str);\n\t      *ok = FALSE;\n\t      return 0;\n\t    }\n\t  if (sploop_ii <= 1)\n\t    fcyc_bits = 0;\n\t  else if (sploop_ii <= 2)\n\t    fcyc_bits = 1;\n\t  else if (sploop_ii <= 4)\n\t    fcyc_bits = 2;\n\t  else if (sploop_ii <= 8)\n\t    fcyc_bits = 3;\n\t  else if (sploop_ii <= 14)\n\t    fcyc_bits = 4;\n\t  else\n\t    abort ();\n\t  if (fcyc_bits > fldd->bitfields[0].width)\n\t    abort ();\n\t  if (opct->variable_fields[fld].coding_method == tic6x_coding_fstg)\n\t    {\n\t      int i, t;\n\t      if (operands[opno].value.exp.X_add_number < 0\n\t\t  || (operands[opno].value.exp.X_add_number\n\t\t      >= (1 << (fldd->bitfields[0].width - fcyc_bits))))\n\t\t{\n\t\t  if (print_errors)\n\t\t    as_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n\t\t\t    opc_len, str);\n\t\t  *ok = FALSE;\n\t\t  return 0;\n\t\t}\n\t      value = operands[opno].value.exp.X_add_number;\n\t      for (t = 0, i = fcyc_bits; i < fldd->bitfields[0].width; i++)\n\t\t{\n\t\t  t = (t << 1) | (value & 1);\n\t\t  value >>= 1;\n\t\t}\n\t      value = t << fcyc_bits;\n\t    }\n\t  else\n\t    {\n\t      if (operands[opno].value.exp.X_add_number < 0\n\t\t  || (operands[opno].value.exp.X_add_number >= sploop_ii))\n\t\t{\n\t\t  if (print_errors)\n\t\t    as_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n\t\t\t    opc_len, str);\n\t\t  *ok = FALSE;\n\t\t  return 0;\n\t\t}\n\t      value = operands[opno].value.exp.X_add_number;\n\t    }\n\t  break;\n\tcase tic6x_coding_fu:\n\t  value = func_unit_side == 2 ? 1 : 0;\n\t  break;\n\tcase tic6x_coding_data_fu:\n\t  value = func_unit_data_side == 2 ? 1 : 0;\n\t  break;\n\tcase tic6x_coding_xpath:\n\t  value = func_unit_cross;\n\t  break;\n\tdefault:\n\t  abort ();\n\t}\n      for (ffld = 0; ffld < opct->num_fixed_fields; ffld++)\n\tif ((opct->fixed_fields[ffld].field_id\n\t     == opct->variable_fields[fld].field_id)\n\t    && (value < opct->fixed_fields[ffld].min_val\n\t\t|| value > opct->fixed_fields[ffld].max_val))\n\t  {\n\t    if (print_errors)\n\t      as_bad (_(\"operand %u of '%.*s' out of range\"), opno + 1,\n\t\t      opc_len, str);\n\t    *ok = FALSE;\n\t    return 0;\n\t  }\n      opcode_value |= value << fldd->bitfields[0].low_pos;\n    }\n  if (this_line_creg)\n    {\n      const tic6x_insn_field *creg;\n      const tic6x_insn_field *z;\n      creg = tic6x_field_from_fmt (fmt, tic6x_field_creg);\n      if (creg == NULL)\n\t{\n\t  if (print_errors)\n\t    as_bad (_(\"instruction '%.*s' cannot be predicated\"),\n\t\t    opc_len, str);\n\t  *ok = FALSE;\n\t  return 0;\n\t}\n      z = tic6x_field_from_fmt (fmt, tic6x_field_z);\n      /* If there is a creg field, there must be a z field; otherwise\n\t there is an error in the format table.  */\n      if (z == NULL)\n\tabort ();\n      opcode_value |= this_line_creg << creg->bitfields[0].low_pos;\n      opcode_value |= this_line_z << z->bitfields[0].low_pos;\n    }\n  *ok = TRUE;\n  return opcode_value;\n"]]}
{"hexsha": "8d59c1d96a98f2d0ec7983adbb03d80c68e1e66b", "ext": "c", "lang": "C", "content": "void iom_core_read2 (UNUSED uint iom_unit_idx, word24 addr, word36 *even, word36 *odd, UNUSED const char * ctx)\n  {\n#ifdef THREADZ\n#ifdef lockread\n    lock_mem_rd ();\n#endif\n#endif\n#ifdef LOCKLESS\n    word36 v;\n    LOAD_ACQ_CORE_WORD(v, addr);\n    * even = v & DMASK;\n    addr++;\n    LOAD_ACQ_CORE_WORD(v, addr);\n    * odd = v & DMASK;\n#else\n    * even = M[addr ++] & DMASK;\n    * odd =  M[addr]    & DMASK;\n#endif\n#ifdef THREADZ\n#ifdef lockread\n    unlock_mem ();\n#endif\n#endif\n  }", "item_id": 5, "repo": "LaudateCorpus1/dps8m", "file": "src/dps8/dps8_iom.c", "last_update_at": "2021-08-06T08:30:12+00:00", "question_id": "8d59c1d96a98f2d0ec7983adbb03d80c68e1e66b_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void iom_core_read2 (UNUSED uint iom_unit_idx, word24 addr, word36 *even, word36 *odd, UNUSED const char * ctx)\n  {\n#ifdef THREADZ\n#ifdef lockread\n    lock_mem_rd ();\n#endif\n#endif\n#ifdef LOCKLESS\n    word36 v;\n    LOAD_ACQ_CORE_WORD(v, addr);\n    * even = v & DMASK;\n    addr++;\n    LOAD_ACQ_CORE_WORD(v, addr);\n    * odd = v & DMASK;\n#else\n    * even = M[addr ++] & DMASK;\n    * odd =  M[addr]    & DMASK;\n#endif\n#ifdef THREADZ\n#ifdef lockread\n    unlock_mem ();\n#endif\n#endif\n"]]}
{"hexsha": "4c2762356b241bc72254067c038f4e5cbb76ef84", "ext": "c", "lang": "C", "content": "static int\nCompareISOLatin1(const char *first, const char *second)\n{\n    register const unsigned char *ap, *bp;\n\n    for (ap = (const unsigned char *) first,\n         bp = (const unsigned char *) second; *ap && *bp; ap++, bp++) {\n        register unsigned char a, b;\n\n        if ((a = *ap) != (b = *bp)) {\n            /* try lowercasing and try again */\n\n            if ((a >= XK_A) && (a <= XK_Z))\n                a = (unsigned char) (a + (XK_a - XK_A));\n            else if ((a >= XK_Agrave) && (a <= XK_Odiaeresis))\n                a = (unsigned char) (a + (XK_agrave - XK_Agrave));\n            else if ((a >= XK_Ooblique) && (a <= XK_Thorn))\n                a = (unsigned char) (a + (XK_oslash - XK_Ooblique));\n\n            if ((b >= XK_A) && (b <= XK_Z))\n                b = (unsigned char) (b + (XK_a - XK_A));\n            else if ((b >= XK_Agrave) && (b <= XK_Odiaeresis))\n                b = (unsigned char) (b + (XK_agrave - XK_Agrave));\n            else if ((b >= XK_Ooblique) && (b <= XK_Thorn))\n                b = (unsigned char) (b + (XK_oslash - XK_Ooblique));\n\n            if (a != b)\n                break;\n        }\n    }\n    return (((int) *bp) - ((int) *ap));\n}", "item_id": 25, "repo": "val-verde/xorg-libXt", "file": "src/Converters.c", "last_update_at": "2021-07-13T04:37:57+00:00", "question_id": "4c2762356b241bc72254067c038f4e5cbb76ef84_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nCompareISOLatin1(const char *first, const char *second)\n{\n    register const unsigned char *ap, *bp;\n    for (ap = (const unsigned char *) first,\n         bp = (const unsigned char *) second; *ap && *bp; ap++, bp++) {\n        register unsigned char a, b;\n        if ((a = *ap) != (b = *bp)) {\n            /* try lowercasing and try again */\n            if ((a >= XK_A) && (a <= XK_Z))\n                a = (unsigned char) (a + (XK_a - XK_A));\n            else if ((a >= XK_Agrave) && (a <= XK_Odiaeresis))\n                a = (unsigned char) (a + (XK_agrave - XK_Agrave));\n            else if ((a >= XK_Ooblique) && (a <= XK_Thorn))\n                a = (unsigned char) (a + (XK_oslash - XK_Ooblique));\n            if ((b >= XK_A) && (b <= XK_Z))\n                b = (unsigned char) (b + (XK_a - XK_A));\n            else if ((b >= XK_Agrave) && (b <= XK_Odiaeresis))\n                b = (unsigned char) (b + (XK_agrave - XK_Agrave));\n            else if ((b >= XK_Ooblique) && (b <= XK_Thorn))\n                b = (unsigned char) (b + (XK_oslash - XK_Ooblique));\n            if (a != b)\n                break;\n        }\n    }\n    return (((int) *bp) - ((int) *ap));\n"]]}
{"hexsha": "3ccad519c0c986fa686a06da6b6ee3a164ec9237", "ext": "c", "lang": "C", "content": "int terminal_writeuint64(uint64_t integer, uint8_t base)\n{\n  if (base < 2 || base > 36)\n    return -1;\n\n  if (integer == 0)\n  {\n    terminal_writechar('0');\n    return 0;\n  }\n\n  char string[65];\n  ptrdiff_t position = 64;\n\n  string[position] = '\\0';\n\n  while (integer > 0)\n  {\n    uint8_t digit = integer % base;\n\n    if (digit < 10)\n    {\n      string[--position] = '0' + digit;\n    }\n    else\n    {\n      string[--position] = 'a' + (digit - 10);\n    }\n\n    integer = integer / base;\n  }\n\n  terminal_writestring(string + position);\n\n  return 0;\n}", "item_id": 0, "repo": "devyn/kit", "file": "kernel/terminal.c", "last_update_at": "2021-07-17T06:16:32+00:00", "question_id": "3ccad519c0c986fa686a06da6b6ee3a164ec9237_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int terminal_writeuint64(uint64_t integer, uint8_t base)\n{\n  if (base < 2 || base > 36)\n    return -1;\n  if (integer == 0)\n  {\n    terminal_writechar('0');\n    return 0;\n  }\n  char string[65];\n  ptrdiff_t position = 64;\n  string[position] = '\\0';\n  while (integer > 0)\n  {\n    uint8_t digit = integer % base;\n    if (digit < 10)\n    {\n      string[--position] = '0' + digit;\n    }\n    else\n    {\n      string[--position] = 'a' + (digit - 10);\n    }\n    integer = integer / base;\n  }\n  terminal_writestring(string + position);\n  return 0;\n"]]}
{"hexsha": "52f2f5b70cdc8c08ef85ee01e263c3777a459cf9", "ext": "c", "lang": "C", "content": "static void close_open_fds(list_t *keep_fds)\n{\n    list_t *open_fds = unixkit_get_open_fds();\n    while (!list_empty(open_fds)) {\n        int fd = as_intptr(list_pop_first(open_fds));\n        if (!list_get(keep_fds, as_integer(fd)))\n            close(fd);\n    }\n    destroy_list(open_fds);\n}", "item_id": 2, "repo": "rauhma/unixkit", "file": "src/unixkit.c", "last_update_at": "2021-11-17T18:45:24+00:00", "question_id": "52f2f5b70cdc8c08ef85ee01e263c3777a459cf9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void close_open_fds(list_t *keep_fds)\n{\n    list_t *open_fds = unixkit_get_open_fds();\n    while (!list_empty(open_fds)) {\n        int fd = as_intptr(list_pop_first(open_fds));\n        if (!list_get(keep_fds, as_integer(fd)))\n            close(fd);\n    }\n    destroy_list(open_fds);\n"]]}
{"hexsha": "3c329252e1d27d1b1dea799169afc109510cbd41", "ext": "c", "lang": "C", "content": "int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n{\n  ffi_cif cif;\n  ffi_type *args[MAX_ARGS];\n  void *values[MAX_ARGS];\n  char *s;\n  signed char sc;\n  unsigned char uc;\n  signed short ss;\n  unsigned short us;\n  unsigned long ul;\n  long long ll;\n  float f;\n  double d;\n  long double ld;\n  signed int si1;\n  signed int si2;\n\n  ffi_arg rint;\n  long long rlonglong;\n\n# if FFI_CLOSURES\n  /* The closure must not be an automatic variable on\n     platforms (Solaris) that forbid stack execution by default. */\n  static ffi_closure cl;\n#endif\n\n  ffi_type * cl_arg_types[17];\n\n  ffi_type ts1_type;\n  ffi_type ts2_type;\n  ffi_type ts3_type;\n  ffi_type ts4_type;  \n  ffi_type ts5_type;\n  ffi_type *ts1_type_elements[4];\n  ffi_type *ts2_type_elements[3];\n  ffi_type *ts3_type_elements[2];\n  ffi_type *ts4_type_elements[4];\n  ffi_type *ts5_type_elements[3];\n\n  ts1_type.size = 0;\n  ts1_type.alignment = 0;\n  ts1_type.type = FFI_TYPE_STRUCT;\n\n  ts2_type.size = 0;\n  ts2_type.alignment = 0;\n  ts2_type.type = FFI_TYPE_STRUCT;\n\n  ts3_type.size = 0;\n  ts3_type.alignment = 0;\n  ts3_type.type = FFI_TYPE_STRUCT;\n\n  ts4_type.size = 0;\n  ts4_type.alignment = 0;\n  ts4_type.type = FFI_TYPE_STRUCT;\n\n  ts5_type.size = 0;\n  ts5_type.alignment = 0;\n  ts5_type.type = FFI_TYPE_STRUCT;\n\n  /*@-immediatetrans@*/\n  ts1_type.elements = ts1_type_elements;\n  ts2_type.elements = ts2_type_elements;\n  ts3_type.elements = ts3_type_elements;\n  ts4_type.elements = ts4_type_elements;\n  ts5_type.elements = ts5_type_elements;\n  /*@=immediatetrans@*/\n  \n  ts1_type_elements[0] = &ffi_type_uchar;\n  ts1_type_elements[1] = &ffi_type_double;\n  ts1_type_elements[2] = &ffi_type_uint;\n  ts1_type_elements[3] = NULL;\n  \n  ts2_type_elements[0] = &ffi_type_double;\n  ts2_type_elements[1] = &ffi_type_double;\n  ts2_type_elements[2] = NULL;\n\n  ts3_type_elements[0] = &ffi_type_sint;\n  ts3_type_elements[1] = NULL;\n\n  ts4_type_elements[0] = &ffi_type_uint;\n  ts4_type_elements[1] = &ffi_type_uint;\n  ts4_type_elements[2] = &ffi_type_uint;\n  ts4_type_elements[3] = NULL;\n\n  ts5_type_elements[0] = &ffi_type_schar;\n  ts5_type_elements[1] = &ffi_type_schar;\n  ts5_type_elements[2] = NULL;\n\n  ul = 0;\n\n  /* return value tests */\n  {\n#if defined(MIPS) /* || defined(ARM) */\n    puts (\"long long tests not run. This is a known bug on this architecture.\");\n#else\n    args[0] = &ffi_type_sint64;\n    values[0] = &ll;\n    \n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ffi_type_sint64, args) == FFI_OK);\n\n    for (ll = 0LL; ll < 100LL; ll++)\n      {\n\tul++;\n\tffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);\n\tCHECK(rlonglong == ll);\n      }\n\n    for (ll = 55555555555000LL; ll < 55555555555100LL; ll++)\n      {\n\tul++;\n\tffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);\n\tCHECK(rlonglong == ll);\n      }\n#endif\n\n    args[0] = &ffi_type_schar;\n    values[0] = &sc;\n    \n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ffi_type_schar, args) == FFI_OK);\n\n    for (sc = (signed char) -127; \n\t sc < (signed char) 127; /*@-type@*/ sc++ /*@=type@*/)\n      {\n\tul++;\n\tffi_call(&cif, FFI_FN(return_sc), &rint, values);\n\tCHECK(rint == (int) sc);\n      }\n\n    args[0] = &ffi_type_uchar;\n    values[0] = &uc;\n    \n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ffi_type_uchar, args) == FFI_OK);\n\n    for (uc = (unsigned char) '\\x00'; \n\t uc < (unsigned char) '\\xff'; /*@-type@*/ uc++ /*@=type@*/)\n      {\n\tul++;\n\tffi_call(&cif, FFI_FN(return_uc), &rint, values);\n\tCHECK(rint == (signed int) uc);\n      }\n\n    printf(\"%lu return value tests run\\n\", ul);\n  }\n\n#ifdef BROKEN_LONG_DOUBLE\n  printf (\"This architecture has broken `long double' support. No floating point\\ntests have been run.\\n\");\n#else\n  /* float arg tests */\n  {\n    args[0] = &ffi_type_float;\n    values[0] = &f;\n\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ffi_type_longdouble, args) == FFI_OK);\n\n    f = 3.14159;\n\n#if 0\n  /* This is ifdef'd out for now. long double support under SunOS/gcc\n     is pretty much non-existent.  You'll get the odd bus error in library\n     routines like printf().  */\n    printf (\"%Lf\\n\", ldblit(f));\n#endif\n    ld = 666;\n    ffi_call(&cif, FFI_FN(ldblit), &ld, values);\n\n#if 0\n  /* This is ifdef'd out for now. long double support under SunOS/gcc\n     is pretty much non-existent.  You'll get the odd bus error in library\n     routines like printf().  */\n    printf (\"%Lf, %Lf, %Lf, %Lf\\n\", ld, ldblit(f), ld - ldblit(f), LDBL_EPSILON);\n#endif\n\n    /* These are not always the same!! Check for a reasonable delta */\n    /*@-realcompare@*/\n    if (ld - ldblit(f) < LDBL_EPSILON)\n    /*@=realcompare@*/\n\tputs(\"long double return value tests ok!\");\n    else\n        CHECK(0);\n  }\n\n  /* float arg tests */\n  {\n    args[0] = &ffi_type_sint;\n    values[0] = &si1;\n    args[1] = &ffi_type_float;\n    values[1] = &f;\n    args[2] = &ffi_type_double;\n    values[2] = &d;\n    args[3] = &ffi_type_longdouble;\n    values[3] = &ld;\n    args[4] = &ffi_type_sint;\n    values[4] = &si2;\n    \n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 5,\n\t\t       &ffi_type_sint, args) == FFI_OK);\n\n    si1 = 6;\n    f = 3.14159;\n    d = (double)1.0/(double)3.0;\n    ld = 2.71828182846L;\n    si2 = 10;\n\n    floating (si1, f, d, ld, si2);\n\n    ffi_call(&cif, FFI_FN(floating), &rint, values);\n\n    printf (\"%d vs %d\\n\", rint, floating (si1, f, d, ld, si2));\n\n    CHECK(rint == floating(si1, f, d, ld, si2));\n\n    printf(\"float arg tests ok!\\n\");\n  }\n#endif\n\n  /* strlen tests */\n  {\n    args[0] = &ffi_type_pointer;\n    values[0] = (void*) &s;\n    \n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ffi_type_sint, args) == FFI_OK);\n\n    s = \"a\";\n    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);\n    CHECK(rint == 1);\n\n    s = \"1234567\";\n    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);\n    CHECK(rint == 7);\n\n    s = \"1234567890123456789012345\";\n    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);\n    CHECK(rint == 25);\n\n    printf(\"strlen tests passed\\n\");\n  }\n\n  /* float arg tests */\n  {\n    args[0] = &ffi_type_float;\n    values[0] = &f;\n    \n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ffi_type_double, args) == FFI_OK);\n\n    f = 3.14159;\n\n    ffi_call(&cif, FFI_FN(dblit), &d, values);\n\n    /* These are not always the same!! Check for a reasonable delta */\n    /*@-realcompare@*/\n    CHECK(d - dblit(f) < DBL_EPSILON);\n    /*@=realcompare@*/\n\n    printf(\"double return value tests ok!\\n\");\n  }\n\n  /* many arg tests */\n  {\n    float ff;\n    float fa[13];\n    \n    for (ul = 0; ul < 13; ul++)\n      {\n\targs[ul] = &ffi_type_float;\n\tvalues[ul] = &fa[ul];\n\tfa[ul] = (float) ul;\n      }\n\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 13, \n\t\t       &ffi_type_float, args) == FFI_OK);\n\n    /*@-usedef@*/\n    ff =  many(fa[0], fa[1],\n\t       fa[2], fa[3],\n\t       fa[4], fa[5],\n\t       fa[6], fa[7],\n\t       fa[8], fa[9],\n\t       fa[10],fa[11],fa[12]);\n    /*@=usedef@*/\n\n    ffi_call(&cif, FFI_FN(many), &f, values);\n\n    /*@-realcompare@*/\n    if (f - ff < FLT_EPSILON)\n    /*@=realcompare@*/\n\tprintf(\"many arg tests ok!\\n\");\n    else\n#ifdef POWERPC\n\tprintf(\"many arg tests failed!  This is a gcc bug.\\n\");\n#else\n        CHECK(0);\n#endif\n  }\n\n  /* promotion tests */\n  {\n    args[0] = &ffi_type_schar;\n    args[1] = &ffi_type_sshort;\n    args[2] = &ffi_type_uchar;\n    args[3] = &ffi_type_ushort;\n    values[0] = &sc;\n    values[1] = &ss;\n    values[2] = &uc;\n    values[3] = &us;\n    \n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, \n\t\t       &ffi_type_sint, args) == FFI_OK);\n\n    us = 0;\n    ul = 0;\n\n    for (sc = (signed char) -127; \n\t sc <= (signed char) 120; /*@-type@*/ sc += 1 /*@=type@*/)\n      for (ss = -30000; ss <= 30000; ss += 10000)\n\tfor (uc = (unsigned char) 0; \n\t     uc <= (unsigned char) 200; /*@-type@*/ uc += 20 /*@=type@*/)\n\t  for (us = 0; us <= 60000; us += 10000)\n\t    {\n\t      ul++;\n\t      ffi_call(&cif, FFI_FN(promotion), &rint, values);\n\t      CHECK(rint == (int) sc + (int) ss + (int) uc + (int) us);\n\t    }\n    printf(\"%lu promotion tests run\\n\", ul);\n  }\n\n#ifndef X86_WIN32 /* Structures dont work on Win32 */\n\n  /* struct tests */\n  {\n    test_structure_1 ts1_arg;\n    /* This is a hack to get a properly aligned result buffer */\n    test_structure_1 *ts1_result = \n      (test_structure_1 *) malloc (sizeof(test_structure_1));\n\n    args[0] = &ts1_type;\n    values[0] = &ts1_arg;\n    \n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ts1_type, args) == FFI_OK);\n\n    ts1_arg.uc = '\\x01';\n    ts1_arg.d = 3.14159;\n    ts1_arg.ui = 555;\n\n    ffi_call(&cif, FFI_FN(struct1), ts1_result, values);\n\n    CHECK(ts1_result->ui == 556);\n    CHECK(ts1_result->d == 3.14159 - 1);\n\n    puts (\"structure test 1 ok!\\n\");\n\n    free (ts1_result);\n  }\n\n  /* struct tests */\n  {\n    test_structure_2 ts2_arg;\n\n    /* This is a hack to get a properly aligned result buffer */\n    test_structure_2 *ts2_result = \n      (test_structure_2 *) malloc (sizeof(test_structure_2));\n\n    args[0] = &ts2_type;\n    values[0] = &ts2_arg;\n    \n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ts2_type, args) == FFI_OK);\n\n    ts2_arg.d1 = 5.55;\n    ts2_arg.d2 = 6.66;\n\n    printf (\"%g\\n\", ts2_result->d1);\n    printf (\"%g\\n\", ts2_result->d2);\n\n    ffi_call(&cif, FFI_FN(struct2), ts2_result, values);\n\n    printf (\"%g\\n\", ts2_result->d1);\n    printf (\"%g\\n\", ts2_result->d2);\n    \n    CHECK(ts2_result->d1 == 5.55 - 1);\n    CHECK(ts2_result->d2 == 6.66 - 1);\n\n    printf(\"structure test 2 ok!\\n\");\n\n    free (ts2_result);\n  }\n\n  /* struct tests */\n  {\n    int compare_value;\n    test_structure_3 ts3_arg;\n    test_structure_3 *ts3_result = \n      (test_structure_3 *) malloc (sizeof(test_structure_3));\n\n    args[0] = &ts3_type;\n    values[0] = &ts3_arg;\n    \n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ts3_type, args) == FFI_OK);\n\n    ts3_arg.si = -123;\n    compare_value = ts3_arg.si;\n\n    ffi_call(&cif, FFI_FN(struct3), ts3_result, values);\n\n    printf (\"%d %d\\n\", ts3_result->si, -(compare_value*2));\n\n    if (ts3_result->si == -(ts3_arg.si*2))\n\tputs (\"structure test 3 ok!\");\n    else\n      {\n\tputs (\"Structure test 3 found structure passing bug.\");\n\tputs (\"  Current versions of GCC are not 100% compliant with the\");\n\tputs (\"  n32 ABI.  There is a known problem related to passing\");\n\tputs (\"  small structures.  Send a bug report to the gcc maintainers.\");\n      }\n\n    free (ts3_result);\n  }\n\n  /* struct tests */\n  {\n    test_structure_4 ts4_arg;\n\n    /* This is a hack to get a properly aligned result buffer */\n    test_structure_4 *ts4_result = \n      (test_structure_4 *) malloc (sizeof(test_structure_4));\n\n    args[0] = &ts4_type;\n    values[0] = &ts4_arg;\n    \n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ts4_type, args) == FFI_OK);\n\n    ts4_arg.ui1 = 2;\n    ts4_arg.ui2 = 3;\n    ts4_arg.ui3 = 4;\n\n    ffi_call (&cif, FFI_FN(struct4), ts4_result, values);\n    \n    if (ts4_result->ui3 == 2U * 3U * 4U)\n      puts (\"structure test 4 ok!\");\n    else\n      puts (\"Structure test 4 found GCC's structure passing bug.\");\n\n    free (ts4_result);\n  }\n\n  /* struct tests */\n  {\n    test_structure_5 ts5_arg1, ts5_arg2;\n\n    /* This is a hack to get a properly aligned result buffer */\n    test_structure_5 *ts5_result = \n      (test_structure_5 *) malloc (sizeof(test_structure_5));\n\n    args[0] = &ts5_type;\n    args[1] = &ts5_type;\n    values[0] = &ts5_arg1;\n    values[1] = &ts5_arg2;\n    \n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, \n\t\t       &ts5_type, args) == FFI_OK);\n\n    ts5_arg1.c1 = 2;\n    ts5_arg1.c2 = 6;\n    ts5_arg2.c1 = 5;\n    ts5_arg2.c2 = 3;\n\n    ffi_call (&cif, FFI_FN(struct5), ts5_result, values);\n    \n    if (ts5_result->c1 == 7 \n\t&& ts5_result->c2 == 3)\n      puts (\"structure test 5 ok!\");\n    else\n      puts (\"Structure test 5 found GCC's structure passing bug.\");\n\n    free (ts5_result);\n  }\n\n#else\n  printf(\"Structure passing doesn't work on Win32.\\n\");\n#endif /* X86_WIN32 */\n\n# if FFI_CLOSURES\n  /* A simple closure test */\n    {\n      (void) puts(\"\\nEnter FFI_CLOSURES\\n\");\n\n      cl_arg_types[0] = &ffi_type_uint64;\n      cl_arg_types[1] = &ffi_type_uint;\n      cl_arg_types[2] = &ffi_type_uint64;\n      cl_arg_types[3] = &ffi_type_uint;\n      cl_arg_types[4] = &ffi_type_sshort;\n      cl_arg_types[5] = &ffi_type_uint64;\n      cl_arg_types[6] = &ffi_type_uint;\n      cl_arg_types[7] = &ffi_type_uint;\n      cl_arg_types[8] = &ffi_type_double;\n      cl_arg_types[9] = &ffi_type_uint;\n      cl_arg_types[10] = &ffi_type_uint;\n      cl_arg_types[11] = &ffi_type_float;\n      cl_arg_types[12] = &ffi_type_uint;\n      cl_arg_types[13] = &ffi_type_uint;\n      cl_arg_types[14] = &ffi_type_uint;\n      cl_arg_types[15] = &ffi_type_uint;\n      cl_arg_types[16] = NULL;   \n\n      /* Initialize the cif */\n      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n\n      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn,\n\t\t\t     (void *) 3 /* userdata */) == FFI_OK);\n      \n      CHECK((*((closure_test_type)(&cl)))\n\t    (1LL, 2, 3LL, 4, 127, 429LL, 7, 8, 9.5, 10, 11, 12, 13, \n\t     19, 21, 1) == 680);\n    }\n\n    {\n\n      cl_arg_types[0] = &ffi_type_float;\n      cl_arg_types[1] = &ffi_type_float;\n      cl_arg_types[2] = &ffi_type_float;\n      cl_arg_types[3] = &ffi_type_float;\n      cl_arg_types[4] = &ffi_type_sshort;\n      cl_arg_types[5] = &ffi_type_float;\n      cl_arg_types[6] = &ffi_type_float;\n      cl_arg_types[7] = &ffi_type_uint;\n      cl_arg_types[8] = &ffi_type_double;\n      cl_arg_types[9] = &ffi_type_uint;\n      cl_arg_types[10] = &ffi_type_uint;\n      cl_arg_types[11] = &ffi_type_float;\n      cl_arg_types[12] = &ffi_type_uint;\n      cl_arg_types[13] = &ffi_type_uint;\n      cl_arg_types[14] = &ffi_type_uint;\n      cl_arg_types[15] = &ffi_type_uint;\n      cl_arg_types[16] = NULL;\n      \n      /* Initialize the cif */\n      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n\n      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn1,\n\t\t\t     (void *) 3 /* userdata */)  == FFI_OK);\n      \n      CHECK((*((closure_test_type1)(&cl)))\n\t    (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,\n\t     19, 21, 1) == 255);\n    }\n\n    {\n\n      cl_arg_types[0] = &ffi_type_double;\n      cl_arg_types[1] = &ffi_type_double;\n      cl_arg_types[2] = &ffi_type_double;\n      cl_arg_types[3] = &ffi_type_double;\n      cl_arg_types[4] = &ffi_type_sshort;\n      cl_arg_types[5] = &ffi_type_double;\n      cl_arg_types[6] = &ffi_type_double;\n      cl_arg_types[7] = &ffi_type_uint;\n      cl_arg_types[8] = &ffi_type_double;\n      cl_arg_types[9] = &ffi_type_uint;\n      cl_arg_types[10] = &ffi_type_uint;\n      cl_arg_types[11] = &ffi_type_float;\n      cl_arg_types[12] = &ffi_type_uint;\n      cl_arg_types[13] = &ffi_type_float;\n      cl_arg_types[14] = &ffi_type_uint;\n      cl_arg_types[15] = &ffi_type_uint;\n      cl_arg_types[16] = NULL;\n      \n      /* Initialize the cif */\n      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n\n      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn2,\n\t\t\t     (void *) 3 /* userdata */) == FFI_OK);\n\n      CHECK((*((closure_test_type2)(&cl)))\n\t    (1, 2, 3, 4, 127, 5, 6, 8, 9, 10, 11, 12.0, 13,\n\t     19.0, 21, 1) == 255);\n\n    }\n\n    {\n\n      cl_arg_types[0] = &ffi_type_float;\n      cl_arg_types[1] = &ffi_type_float;\n      cl_arg_types[2] = &ffi_type_float;\n      cl_arg_types[3] = &ffi_type_float;\n      cl_arg_types[4] = &ffi_type_float;\n      cl_arg_types[5] = &ffi_type_float;\n      cl_arg_types[6] = &ffi_type_float;\n      cl_arg_types[7] = &ffi_type_float;\n      cl_arg_types[8] = &ffi_type_double;\n      cl_arg_types[9] = &ffi_type_uint;\n      cl_arg_types[10] = &ffi_type_float;\n      cl_arg_types[11] = &ffi_type_float;\n      cl_arg_types[12] = &ffi_type_uint;\n      cl_arg_types[13] = &ffi_type_float;\n      cl_arg_types[14] = &ffi_type_float;\n      cl_arg_types[15] = &ffi_type_uint;\n      cl_arg_types[16] = NULL;\n      \n      /* Initialize the cif */\n      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n\n      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn3,\n\t\t\t     (void *) 3 /* userdata */)  == FFI_OK);\n      \n      CHECK((*((closure_test_type3)(&cl)))\n\t    (1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9, 10, 11.11, 12.0, 13,\n\t     19.19, 21.21, 1) == 135);\n    }\n\n    (void) puts(\"\\nFinished FFI_CLOSURES\\n\");\n\n# endif\n  /* If we arrived here, all is good */\n  (void) puts(\"\\nLooks good. No surprises.\\n\");\n\n  /*@-compdestroy@*/\n\n  return 0;\n}", "item_id": 5, "repo": "enfoTek/tomato.linksys.e2000.nvram-mod", "file": "tools-src/gnu/gcc/libffi/src/ffitest.c", "last_update_at": "2021-06-07T06:29:49+00:00", "question_id": "3c329252e1d27d1b1dea799169afc109510cbd41_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n{\n  ffi_cif cif;\n  ffi_type *args[MAX_ARGS];\n  void *values[MAX_ARGS];\n  char *s;\n  signed char sc;\n  unsigned char uc;\n  signed short ss;\n  unsigned short us;\n  unsigned long ul;\n  long long ll;\n  float f;\n  double d;\n  long double ld;\n  signed int si1;\n  signed int si2;\n  ffi_arg rint;\n  long long rlonglong;\n# if FFI_CLOSURES\n  /* The closure must not be an automatic variable on\n     platforms (Solaris) that forbid stack execution by default. */\n  static ffi_closure cl;\n#endif\n  ffi_type * cl_arg_types[17];\n  ffi_type ts1_type;\n  ffi_type ts2_type;\n  ffi_type ts3_type;\n  ffi_type ts4_type;  \n  ffi_type ts5_type;\n  ffi_type *ts1_type_elements[4];\n  ffi_type *ts2_type_elements[3];\n  ffi_type *ts3_type_elements[2];\n  ffi_type *ts4_type_elements[4];\n  ffi_type *ts5_type_elements[3];\n  ts1_type.size = 0;\n  ts1_type.alignment = 0;\n  ts1_type.type = FFI_TYPE_STRUCT;\n  ts2_type.size = 0;\n  ts2_type.alignment = 0;\n  ts2_type.type = FFI_TYPE_STRUCT;\n  ts3_type.size = 0;\n  ts3_type.alignment = 0;\n  ts3_type.type = FFI_TYPE_STRUCT;\n  ts4_type.size = 0;\n  ts4_type.alignment = 0;\n  ts4_type.type = FFI_TYPE_STRUCT;\n  ts5_type.size = 0;\n  ts5_type.alignment = 0;\n  ts5_type.type = FFI_TYPE_STRUCT;\n  /*@-immediatetrans@*/\n  ts1_type.elements = ts1_type_elements;\n  ts2_type.elements = ts2_type_elements;\n  ts3_type.elements = ts3_type_elements;\n  ts4_type.elements = ts4_type_elements;\n  ts5_type.elements = ts5_type_elements;\n  /*@=immediatetrans@*/\n  ts1_type_elements[0] = &ffi_type_uchar;\n  ts1_type_elements[1] = &ffi_type_double;\n  ts1_type_elements[2] = &ffi_type_uint;\n  ts1_type_elements[3] = NULL;\n  ts2_type_elements[0] = &ffi_type_double;\n  ts2_type_elements[1] = &ffi_type_double;\n  ts2_type_elements[2] = NULL;\n  ts3_type_elements[0] = &ffi_type_sint;\n  ts3_type_elements[1] = NULL;\n  ts4_type_elements[0] = &ffi_type_uint;\n  ts4_type_elements[1] = &ffi_type_uint;\n  ts4_type_elements[2] = &ffi_type_uint;\n  ts4_type_elements[3] = NULL;\n  ts5_type_elements[0] = &ffi_type_schar;\n  ts5_type_elements[1] = &ffi_type_schar;\n  ts5_type_elements[2] = NULL;\n  ul = 0;\n  /* return value tests */\n  {\n#if defined(MIPS) /* || defined(ARM) */\n    puts (\"long long tests not run. This is a known bug on this architecture.\");\n#else\n    args[0] = &ffi_type_sint64;\n    values[0] = &ll;\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ffi_type_sint64, args) == FFI_OK);\n    for (ll = 0LL; ll < 100LL; ll++)\n      {\n\tul++;\n\tffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);\n\tCHECK(rlonglong == ll);\n      }\n    for (ll = 55555555555000LL; ll < 55555555555100LL; ll++)\n      {\n\tul++;\n\tffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);\n\tCHECK(rlonglong == ll);\n      }\n#endif\n    args[0] = &ffi_type_schar;\n    values[0] = &sc;\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ffi_type_schar, args) == FFI_OK);\n    for (sc = (signed char) -127; \n\t sc < (signed char) 127; /*@-type@*/ sc++ /*@=type@*/)\n      {\n\tul++;\n\tffi_call(&cif, FFI_FN(return_sc), &rint, values);\n\tCHECK(rint == (int) sc);\n      }\n    args[0] = &ffi_type_uchar;\n    values[0] = &uc;\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ffi_type_uchar, args) == FFI_OK);\n    for (uc = (unsigned char) '\\x00'; \n\t uc < (unsigned char) '\\xff'; /*@-type@*/ uc++ /*@=type@*/)\n      {\n\tul++;\n\tffi_call(&cif, FFI_FN(return_uc), &rint, values);\n\tCHECK(rint == (signed int) uc);\n      }\n    printf(\"%lu return value tests run\\n\", ul);\n  }\n#ifdef BROKEN_LONG_DOUBLE\n  printf (\"This architecture has broken `long double' support. No floating point\\ntests have been run.\\n\");\n#else\n  /* float arg tests */\n  {\n    args[0] = &ffi_type_float;\n    values[0] = &f;\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ffi_type_longdouble, args) == FFI_OK);\n    f = 3.14159;\n#if 0\n  /* This is ifdef'd out for now. long double support under SunOS/gcc\n     is pretty much non-existent.  You'll get the odd bus error in library\n     routines like printf().  */\n    printf (\"%Lf\\n\", ldblit(f));\n#endif\n    ld = 666;\n    ffi_call(&cif, FFI_FN(ldblit), &ld, values);\n#if 0\n  /* This is ifdef'd out for now. long double support under SunOS/gcc\n     is pretty much non-existent.  You'll get the odd bus error in library\n     routines like printf().  */\n    printf (\"%Lf, %Lf, %Lf, %Lf\\n\", ld, ldblit(f), ld - ldblit(f), LDBL_EPSILON);\n#endif\n    /* These are not always the same!! Check for a reasonable delta */\n    /*@-realcompare@*/\n    if (ld - ldblit(f) < LDBL_EPSILON)\n    /*@=realcompare@*/\n\tputs(\"long double return value tests ok!\");\n    else\n        CHECK(0);\n  }\n  /* float arg tests */\n  {\n    args[0] = &ffi_type_sint;\n    values[0] = &si1;\n    args[1] = &ffi_type_float;\n    values[1] = &f;\n    args[2] = &ffi_type_double;\n    values[2] = &d;\n    args[3] = &ffi_type_longdouble;\n    values[3] = &ld;\n    args[4] = &ffi_type_sint;\n    values[4] = &si2;\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 5,\n\t\t       &ffi_type_sint, args) == FFI_OK);\n    si1 = 6;\n    f = 3.14159;\n    d = (double)1.0/(double)3.0;\n    ld = 2.71828182846L;\n    si2 = 10;\n    floating (si1, f, d, ld, si2);\n    ffi_call(&cif, FFI_FN(floating), &rint, values);\n    printf (\"%d vs %d\\n\", rint, floating (si1, f, d, ld, si2));\n    CHECK(rint == floating(si1, f, d, ld, si2));\n    printf(\"float arg tests ok!\\n\");\n  }\n#endif\n  /* strlen tests */\n  {\n    args[0] = &ffi_type_pointer;\n    values[0] = (void*) &s;\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ffi_type_sint, args) == FFI_OK);\n    s = \"a\";\n    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);\n    CHECK(rint == 1);\n    s = \"1234567\";\n    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);\n    CHECK(rint == 7);\n    s = \"1234567890123456789012345\";\n    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);\n    CHECK(rint == 25);\n    printf(\"strlen tests passed\\n\");\n  }\n  /* float arg tests */\n  {\n    args[0] = &ffi_type_float;\n    values[0] = &f;\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ffi_type_double, args) == FFI_OK);\n    f = 3.14159;\n    ffi_call(&cif, FFI_FN(dblit), &d, values);\n    /* These are not always the same!! Check for a reasonable delta */\n    /*@-realcompare@*/\n    CHECK(d - dblit(f) < DBL_EPSILON);\n    /*@=realcompare@*/\n    printf(\"double return value tests ok!\\n\");\n  }\n  /* many arg tests */\n  {\n    float ff;\n    float fa[13];\n    for (ul = 0; ul < 13; ul++)\n      {\n\targs[ul] = &ffi_type_float;\n\tvalues[ul] = &fa[ul];\n\tfa[ul] = (float) ul;\n      }\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 13, \n\t\t       &ffi_type_float, args) == FFI_OK);\n    /*@-usedef@*/\n    ff =  many(fa[0], fa[1],\n\t       fa[2], fa[3],\n\t       fa[4], fa[5],\n\t       fa[6], fa[7],\n\t       fa[8], fa[9],\n\t       fa[10],fa[11],fa[12]);\n    /*@=usedef@*/\n    ffi_call(&cif, FFI_FN(many), &f, values);\n    /*@-realcompare@*/\n    if (f - ff < FLT_EPSILON)\n    /*@=realcompare@*/\n\tprintf(\"many arg tests ok!\\n\");\n    else\n#ifdef POWERPC\n\tprintf(\"many arg tests failed!  This is a gcc bug.\\n\");\n#else\n        CHECK(0);\n#endif\n  }\n  /* promotion tests */\n  {\n    args[0] = &ffi_type_schar;\n    args[1] = &ffi_type_sshort;\n    args[2] = &ffi_type_uchar;\n    args[3] = &ffi_type_ushort;\n    values[0] = &sc;\n    values[1] = &ss;\n    values[2] = &uc;\n    values[3] = &us;\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, \n\t\t       &ffi_type_sint, args) == FFI_OK);\n    us = 0;\n    ul = 0;\n    for (sc = (signed char) -127; \n\t sc <= (signed char) 120; /*@-type@*/ sc += 1 /*@=type@*/)\n      for (ss = -30000; ss <= 30000; ss += 10000)\n\tfor (uc = (unsigned char) 0; \n\t     uc <= (unsigned char) 200; /*@-type@*/ uc += 20 /*@=type@*/)\n\t  for (us = 0; us <= 60000; us += 10000)\n\t    {\n\t      ul++;\n\t      ffi_call(&cif, FFI_FN(promotion), &rint, values);\n\t      CHECK(rint == (int) sc + (int) ss + (int) uc + (int) us);\n\t    }\n    printf(\"%lu promotion tests run\\n\", ul);\n  }\n#ifndef X86_WIN32 /* Structures dont work on Win32 */\n  /* struct tests */\n  {\n    test_structure_1 ts1_arg;\n    /* This is a hack to get a properly aligned result buffer */\n    test_structure_1 *ts1_result = \n      (test_structure_1 *) malloc (sizeof(test_structure_1));\n    args[0] = &ts1_type;\n    values[0] = &ts1_arg;\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ts1_type, args) == FFI_OK);\n    ts1_arg.uc = '\\x01';\n    ts1_arg.d = 3.14159;\n    ts1_arg.ui = 555;\n    ffi_call(&cif, FFI_FN(struct1), ts1_result, values);\n    CHECK(ts1_result->ui == 556);\n    CHECK(ts1_result->d == 3.14159 - 1);\n    puts (\"structure test 1 ok!\\n\");\n    free (ts1_result);\n  }\n  /* struct tests */\n  {\n    test_structure_2 ts2_arg;\n    /* This is a hack to get a properly aligned result buffer */\n    test_structure_2 *ts2_result = \n      (test_structure_2 *) malloc (sizeof(test_structure_2));\n    args[0] = &ts2_type;\n    values[0] = &ts2_arg;\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ts2_type, args) == FFI_OK);\n    ts2_arg.d1 = 5.55;\n    ts2_arg.d2 = 6.66;\n    printf (\"%g\\n\", ts2_result->d1);\n    printf (\"%g\\n\", ts2_result->d2);\n    ffi_call(&cif, FFI_FN(struct2), ts2_result, values);\n    printf (\"%g\\n\", ts2_result->d1);\n    printf (\"%g\\n\", ts2_result->d2);\n    CHECK(ts2_result->d1 == 5.55 - 1);\n    CHECK(ts2_result->d2 == 6.66 - 1);\n    printf(\"structure test 2 ok!\\n\");\n    free (ts2_result);\n  }\n  /* struct tests */\n  {\n    int compare_value;\n    test_structure_3 ts3_arg;\n    test_structure_3 *ts3_result = \n      (test_structure_3 *) malloc (sizeof(test_structure_3));\n    args[0] = &ts3_type;\n    values[0] = &ts3_arg;\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ts3_type, args) == FFI_OK);\n    ts3_arg.si = -123;\n    compare_value = ts3_arg.si;\n    ffi_call(&cif, FFI_FN(struct3), ts3_result, values);\n    printf (\"%d %d\\n\", ts3_result->si, -(compare_value*2));\n    if (ts3_result->si == -(ts3_arg.si*2))\n\tputs (\"structure test 3 ok!\");\n    else\n      {\n\tputs (\"Structure test 3 found structure passing bug.\");\n\tputs (\"  Current versions of GCC are not 100% compliant with the\");\n\tputs (\"  n32 ABI.  There is a known problem related to passing\");\n\tputs (\"  small structures.  Send a bug report to the gcc maintainers.\");\n      }\n    free (ts3_result);\n  }\n  /* struct tests */\n  {\n    test_structure_4 ts4_arg;\n    /* This is a hack to get a properly aligned result buffer */\n    test_structure_4 *ts4_result = \n      (test_structure_4 *) malloc (sizeof(test_structure_4));\n    args[0] = &ts4_type;\n    values[0] = &ts4_arg;\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n\t\t       &ts4_type, args) == FFI_OK);\n    ts4_arg.ui1 = 2;\n    ts4_arg.ui2 = 3;\n    ts4_arg.ui3 = 4;\n    ffi_call (&cif, FFI_FN(struct4), ts4_result, values);\n    if (ts4_result->ui3 == 2U * 3U * 4U)\n      puts (\"structure test 4 ok!\");\n    else\n      puts (\"Structure test 4 found GCC's structure passing bug.\");\n    free (ts4_result);\n  }\n  /* struct tests */\n  {\n    test_structure_5 ts5_arg1, ts5_arg2;\n    /* This is a hack to get a properly aligned result buffer */\n    test_structure_5 *ts5_result = \n      (test_structure_5 *) malloc (sizeof(test_structure_5));\n    args[0] = &ts5_type;\n    args[1] = &ts5_type;\n    values[0] = &ts5_arg1;\n    values[1] = &ts5_arg2;\n    /* Initialize the cif */\n    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, \n\t\t       &ts5_type, args) == FFI_OK);\n    ts5_arg1.c1 = 2;\n    ts5_arg1.c2 = 6;\n    ts5_arg2.c1 = 5;\n    ts5_arg2.c2 = 3;\n    ffi_call (&cif, FFI_FN(struct5), ts5_result, values);\n    if (ts5_result->c1 == 7 \n\t&& ts5_result->c2 == 3)\n      puts (\"structure test 5 ok!\");\n    else\n      puts (\"Structure test 5 found GCC's structure passing bug.\");\n    free (ts5_result);\n  }\n#else\n  printf(\"Structure passing doesn't work on Win32.\\n\");\n#endif /* X86_WIN32 */\n# if FFI_CLOSURES\n  /* A simple closure test */\n    {\n      (void) puts(\"\\nEnter FFI_CLOSURES\\n\");\n      cl_arg_types[0] = &ffi_type_uint64;\n      cl_arg_types[1] = &ffi_type_uint;\n      cl_arg_types[2] = &ffi_type_uint64;\n      cl_arg_types[3] = &ffi_type_uint;\n      cl_arg_types[4] = &ffi_type_sshort;\n      cl_arg_types[5] = &ffi_type_uint64;\n      cl_arg_types[6] = &ffi_type_uint;\n      cl_arg_types[7] = &ffi_type_uint;\n      cl_arg_types[8] = &ffi_type_double;\n      cl_arg_types[9] = &ffi_type_uint;\n      cl_arg_types[10] = &ffi_type_uint;\n      cl_arg_types[11] = &ffi_type_float;\n      cl_arg_types[12] = &ffi_type_uint;\n      cl_arg_types[13] = &ffi_type_uint;\n      cl_arg_types[14] = &ffi_type_uint;\n      cl_arg_types[15] = &ffi_type_uint;\n      cl_arg_types[16] = NULL;   \n      /* Initialize the cif */\n      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn,\n\t\t\t     (void *) 3 /* userdata */) == FFI_OK);\n      CHECK((*((closure_test_type)(&cl)))\n\t    (1LL, 2, 3LL, 4, 127, 429LL, 7, 8, 9.5, 10, 11, 12, 13, \n\t     19, 21, 1) == 680);\n    }\n    {\n      cl_arg_types[0] = &ffi_type_float;\n      cl_arg_types[1] = &ffi_type_float;\n      cl_arg_types[2] = &ffi_type_float;\n      cl_arg_types[3] = &ffi_type_float;\n      cl_arg_types[4] = &ffi_type_sshort;\n      cl_arg_types[5] = &ffi_type_float;\n      cl_arg_types[6] = &ffi_type_float;\n      cl_arg_types[7] = &ffi_type_uint;\n      cl_arg_types[8] = &ffi_type_double;\n      cl_arg_types[9] = &ffi_type_uint;\n      cl_arg_types[10] = &ffi_type_uint;\n      cl_arg_types[11] = &ffi_type_float;\n      cl_arg_types[12] = &ffi_type_uint;\n      cl_arg_types[13] = &ffi_type_uint;\n      cl_arg_types[14] = &ffi_type_uint;\n      cl_arg_types[15] = &ffi_type_uint;\n      cl_arg_types[16] = NULL;\n      /* Initialize the cif */\n      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn1,\n\t\t\t     (void *) 3 /* userdata */)  == FFI_OK);\n      CHECK((*((closure_test_type1)(&cl)))\n\t    (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,\n\t     19, 21, 1) == 255);\n    }\n    {\n      cl_arg_types[0] = &ffi_type_double;\n      cl_arg_types[1] = &ffi_type_double;\n      cl_arg_types[2] = &ffi_type_double;\n      cl_arg_types[3] = &ffi_type_double;\n      cl_arg_types[4] = &ffi_type_sshort;\n      cl_arg_types[5] = &ffi_type_double;\n      cl_arg_types[6] = &ffi_type_double;\n      cl_arg_types[7] = &ffi_type_uint;\n      cl_arg_types[8] = &ffi_type_double;\n      cl_arg_types[9] = &ffi_type_uint;\n      cl_arg_types[10] = &ffi_type_uint;\n      cl_arg_types[11] = &ffi_type_float;\n      cl_arg_types[12] = &ffi_type_uint;\n      cl_arg_types[13] = &ffi_type_float;\n      cl_arg_types[14] = &ffi_type_uint;\n      cl_arg_types[15] = &ffi_type_uint;\n      cl_arg_types[16] = NULL;\n      /* Initialize the cif */\n      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn2,\n\t\t\t     (void *) 3 /* userdata */) == FFI_OK);\n      CHECK((*((closure_test_type2)(&cl)))\n\t    (1, 2, 3, 4, 127, 5, 6, 8, 9, 10, 11, 12.0, 13,\n\t     19.0, 21, 1) == 255);\n    }\n    {\n      cl_arg_types[0] = &ffi_type_float;\n      cl_arg_types[1] = &ffi_type_float;\n      cl_arg_types[2] = &ffi_type_float;\n      cl_arg_types[3] = &ffi_type_float;\n      cl_arg_types[4] = &ffi_type_float;\n      cl_arg_types[5] = &ffi_type_float;\n      cl_arg_types[6] = &ffi_type_float;\n      cl_arg_types[7] = &ffi_type_float;\n      cl_arg_types[8] = &ffi_type_double;\n      cl_arg_types[9] = &ffi_type_uint;\n      cl_arg_types[10] = &ffi_type_float;\n      cl_arg_types[11] = &ffi_type_float;\n      cl_arg_types[12] = &ffi_type_uint;\n      cl_arg_types[13] = &ffi_type_float;\n      cl_arg_types[14] = &ffi_type_float;\n      cl_arg_types[15] = &ffi_type_uint;\n      cl_arg_types[16] = NULL;\n      /* Initialize the cif */\n      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn3,\n\t\t\t     (void *) 3 /* userdata */)  == FFI_OK);\n      CHECK((*((closure_test_type3)(&cl)))\n\t    (1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9, 10, 11.11, 12.0, 13,\n\t     19.19, 21.21, 1) == 135);\n    }\n    (void) puts(\"\\nFinished FFI_CLOSURES\\n\");\n# endif\n  /* If we arrived here, all is good */\n  (void) puts(\"\\nLooks good. No surprises.\\n\");\n  /*@-compdestroy@*/\n  return 0;\n"]]}
{"hexsha": "73850f13992820e9083606d110aeed4477976f57", "ext": "c", "lang": "C", "content": "void f180(void) {\n    \tstatic volatile int64_t x761 = -1LL;\n\tvolatile int8_t x762 = -6;\n\tstatic uint8_t x763 = 11U;\n\tstatic volatile int64_t t180 = 256484910072714LL;\n\n    t180 = (x761-((x762<=x763)>x764));\n\n    if (t180 != -2LL) { NG(); } else { ; }\n\t\n}", "item_id": 180, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test1878.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "73850f13992820e9083606d110aeed4477976f57_180", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f180(void) {\n    \tstatic volatile int64_t x761 = -1LL;\n\tvolatile int8_t x762 = -6;\n\tstatic uint8_t x763 = 11U;\n\tstatic volatile int64_t t180 = 256484910072714LL;\n    t180 = (x761-((x762<=x763)>x764));\n    if (t180 != -2LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "338c634080545aabb51aaae8bbc0178dc7c28ed8", "ext": "c", "lang": "C", "content": "void f77(void) {\n    \tuint8_t x365 = 12U;\n\tint32_t x366 = INT32_MAX;\n\tint32_t x367 = -1;\n\tvolatile int16_t x368 = INT16_MAX;\n\tvolatile int32_t t77 = -3242616;\n\n    t77 = (((x365|x366)+x367)/x368);\n\n    if (t77 != 65538) { NG(); } else { ; }\n\t\n}", "item_id": 77, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test2356.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "338c634080545aabb51aaae8bbc0178dc7c28ed8_77", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f77(void) {\n    \tuint8_t x365 = 12U;\n\tint32_t x366 = INT32_MAX;\n\tint32_t x367 = -1;\n\tvolatile int16_t x368 = INT16_MAX;\n\tvolatile int32_t t77 = -3242616;\n    t77 = (((x365|x366)+x367)/x368);\n    if (t77 != 65538) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "629afbef45ed6bd410d3fc664e306cf8ffc93999", "ext": "c", "lang": "C", "content": "DWORD\r\nRemoveBootIniCancelOption (\r\n    DWORD Request\r\n    )\r\n{\r\n    HINF inf = INVALID_HANDLE_VALUE;\r\n    PCTSTR bootIni;\r\n    PCTSTR bootIniTmp;\r\n    DWORD result = ERROR_SUCCESS;\r\n    PINFLINE osLine;\r\n    BOOL changed = FALSE;\r\n    DWORD attribs;\r\n\r\n    if (Request == REQUEST_QUERYTICKS) {\r\n        return 50;\r\n    }\r\n\r\n    if (Request != REQUEST_RUN) {\r\n        return 0;\r\n    }\r\n\r\n    bootIni = JoinPaths (g_BootDrivePath, TEXT(\"boot.ini\"));\r\n\r\n    __try {\r\n        //\r\n        // Open boot.ini for editing\r\n        //\r\n\r\n        inf = OpenInfFile (bootIni);\r\n\r\n        if (inf == INVALID_HANDLE_VALUE) {\r\n            DEBUGMSG ((DBG_ERROR, \"Can't open %s\", bootIni));\r\n            result = GetLastError();\r\n            __leave;\r\n        }\r\n\r\n        //\r\n        // Scan boot.ini for a textmode option that has /rollback. Delete it.\r\n        //\r\n\r\n        osLine = GetFirstLineInSectionStr (inf, TEXT(\"Operating Systems\"));\r\n        if (!osLine) {\r\n            DEBUGMSG ((DBG_ERROR, \"No lines found in [Operating Systems] in %s\", bootIni));\r\n            result = ERROR_FILE_NOT_FOUND;\r\n            __leave;\r\n        }\r\n\r\n        //\r\n        // Loop until all lines with /rollback are gone\r\n        //\r\n\r\n        do {\r\n            do {\r\n                //\r\n                // Check this line for a /rollback option\r\n                //\r\n\r\n                if (_tcsistr (osLine->Data, TEXT(\"/rollback\"))) {\r\n                    DEBUGMSG ((DBG_FILEMIG, \"Found rollback option: %s\", osLine->Data));\r\n                    break;\r\n                }\r\n\r\n            } while (osLine = GetNextLineInSection (osLine));\r\n\r\n            if (osLine) {\r\n                if (!DeleteLineInInfSection (inf, osLine)) {\r\n                    MYASSERT (FALSE);\r\n                    break;\r\n                }\r\n\r\n                DEBUGMSG ((DBG_FILEMIG, \"Line sucessfully removed\"));\r\n                changed = TRUE;\r\n                osLine = GetFirstLineInSectionStr (inf, TEXT(\"Operating Systems\"));\r\n            }\r\n\r\n        } while (osLine);\r\n\r\n        //\r\n        // If we changed the file, then write it to disk. Keep the original\r\n        // boot.ini file in case we fail to save.\r\n        //\r\n\r\n        attribs = GetFileAttributes (bootIni);\r\n        SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);\r\n        MYASSERT (attribs != INVALID_ATTRIBUTES);\r\n\r\n        bootIniTmp = JoinPaths (g_BootDrivePath, TEXT(\"boot.~t\"));\r\n        SetFileAttributes (bootIniTmp, FILE_ATTRIBUTE_NORMAL);\r\n        DeleteFile (bootIniTmp);\r\n\r\n        if (!MoveFile (bootIni, bootIniTmp)) {\r\n            LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_MOVE_FAILED, bootIni, bootIniTmp));\r\n            result = GetLastError();\r\n        } else {\r\n\r\n            DEBUGMSG ((DBG_FILEMIG, \"Moved %s to %s\", bootIni, bootIniTmp));\r\n\r\n            if (!SaveInfFile (inf, bootIni)) {\r\n                LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_SAVE_FAILED, bootIni));\r\n                result = GetLastError();\r\n\r\n                SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);\r\n                DeleteFile (bootIni);\r\n\r\n                if (!MoveFile (bootIniTmp, bootIni)) {\r\n\r\n                    //\r\n                    // This should not happen, because we just successfully\r\n                    // moved the original to the tmp; we should be able to\r\n                    // move the temp back to the original. If we fail, the pc\r\n                    // becomes unbootable. But what can we do?\r\n                    //\r\n\r\n                    LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_MOVE_FAILED, bootIniTmp, bootIni));\r\n                }\r\n            } else {\r\n                //\r\n                // boot.ini was successfully updated. Remove the original copy.\r\n                //\r\n\r\n                DeleteFile (bootIniTmp);\r\n                MYASSERT (result == ERROR_SUCCESS);\r\n\r\n                DEBUGMSG ((DBG_FILEMIG, \"%s was saved\", bootIni));\r\n            }\r\n        }\r\n\r\n        //\r\n        // restore attributes on original if possible.\r\n        //\r\n\r\n        SetFileAttributes (bootIni, attribs);\r\n        FreePathString (bootIniTmp);\r\n\r\n        // result already set above\r\n    }\r\n    __finally {\r\n        if (inf != INVALID_HANDLE_VALUE) {\r\n            CloseInfFile (inf);\r\n        }\r\n\r\n        FreePathString (bootIni);\r\n    }\r\n\r\n    return result;\r\n\r\n}", "item_id": 25, "repo": "npocmaka/Windows-Server-2003", "file": "base/ntsetup/win95upg/w95upgnt/migmain/filemig.c", "last_update_at": "2021-09-16T09:13:13+00:00", "question_id": "629afbef45ed6bd410d3fc664e306cf8ffc93999_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["DWORD\r\nRemoveBootIniCancelOption (\r\n    DWORD Request\r\n    )\r\n{\r\n    HINF inf = INVALID_HANDLE_VALUE;\r\n    PCTSTR bootIni;\r\n    PCTSTR bootIniTmp;\r\n    DWORD result = ERROR_SUCCESS;\r\n    PINFLINE osLine;\r\n    BOOL changed = FALSE;\r\n    DWORD attribs;\r\n\r\n    if (Request == REQUEST_QUERYTICKS) {\r\n        return 50;\r\n    }\r\n\r\n    if (Request != REQUEST_RUN) {\r\n        return 0;\r\n    }\r\n\r\n    bootIni = JoinPaths (g_BootDrivePath, TEXT(\"boot.ini\"));\r\n\r\n    __try {\r\n        //\r\n        // Open boot.ini for editing\r\n        //\r\n\r\n        inf = OpenInfFile (bootIni);\r\n\r\n        if (inf == INVALID_HANDLE_VALUE) {\r\n            DEBUGMSG ((DBG_ERROR, \"Can't open %s\", bootIni));\r\n            result = GetLastError();\r\n            __leave;\r\n        }\r\n\r\n        //\r\n        // Scan boot.ini for a textmode option that has /rollback. Delete it.\r\n        //\r\n\r\n        osLine = GetFirstLineInSectionStr (inf, TEXT(\"Operating Systems\"));\r\n        if (!osLine) {\r\n            DEBUGMSG ((DBG_ERROR, \"No lines found in [Operating Systems] in %s\", bootIni));\r\n            result = ERROR_FILE_NOT_FOUND;\r\n            __leave;\r\n        }\r\n\r\n        //\r\n        // Loop until all lines with /rollback are gone\r\n        //\r\n\r\n        do {\r\n            do {\r\n                //\r\n                // Check this line for a /rollback option\r\n                //\r\n\r\n                if (_tcsistr (osLine->Data, TEXT(\"/rollback\"))) {\r\n                    DEBUGMSG ((DBG_FILEMIG, \"Found rollback option: %s\", osLine->Data));\r\n                    break;\r\n                }\r\n\r\n            } while (osLine = GetNextLineInSection (osLine));\r\n\r\n            if (osLine) {\r\n                if (!DeleteLineInInfSection (inf, osLine)) {\r\n                    MYASSERT (FALSE);\r\n                    break;\r\n                }\r\n\r\n                DEBUGMSG ((DBG_FILEMIG, \"Line sucessfully removed\"));\r\n                changed = TRUE;\r\n                osLine = GetFirstLineInSectionStr (inf, TEXT(\"Operating Systems\"));\r\n            }\r\n\r\n        } while (osLine);\r\n\r\n        //\r\n        // If we changed the file, then write it to disk. Keep the original\r\n        // boot.ini file in case we fail to save.\r\n        //\r\n\r\n        attribs = GetFileAttributes (bootIni);\r\n        SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);\r\n        MYASSERT (attribs != INVALID_ATTRIBUTES);\r\n\r\n        bootIniTmp = JoinPaths (g_BootDrivePath, TEXT(\"boot.~t\"));\r\n        SetFileAttributes (bootIniTmp, FILE_ATTRIBUTE_NORMAL);\r\n        DeleteFile (bootIniTmp);\r\n\r\n        if (!MoveFile (bootIni, bootIniTmp)) {\r\n            LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_MOVE_FAILED, bootIni, bootIniTmp));\r\n            result = GetLastError();\r\n        } else {\r\n\r\n            DEBUGMSG ((DBG_FILEMIG, \"Moved %s to %s\", bootIni, bootIniTmp));\r\n\r\n            if (!SaveInfFile (inf, bootIni)) {\r\n                LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_SAVE_FAILED, bootIni));\r\n                result = GetLastError();\r\n\r\n                SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);\r\n                DeleteFile (bootIni);\r\n\r\n                if (!MoveFile (bootIniTmp, bootIni)) {\r\n\r\n                    //\r\n                    // This should not happen, because we just successfully\r\n                    // moved the original to the tmp; we should be able to\r\n                    // move the temp back to the original. If we fail, the pc\r\n                    // becomes unbootable. But what can we do?\r\n                    //\r\n\r\n                    LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_MOVE_FAILED, bootIniTmp, bootIni));\r\n                }\r\n            } else {\r\n                //\r\n                // boot.ini was successfully updated. Remove the original copy.\r\n                //\r\n\r\n                DeleteFile (bootIniTmp);\r\n                MYASSERT (result == ERROR_SUCCESS);\r\n\r\n                DEBUGMSG ((DBG_FILEMIG, \"%s was saved\", bootIni));\r\n            }\r\n        }\r\n\r\n        //\r\n        // restore attributes on original if possible.\r\n        //\r\n\r\n        SetFileAttributes (bootIni, attribs);\r\n        FreePathString (bootIniTmp);\r\n\r\n        // result already set above\r\n    }\r\n    __finally {\r\n        if (inf != INVALID_HANDLE_VALUE) {\r\n            CloseInfFile (inf);\r\n        }\r\n\r\n        FreePathString (bootIni);\r\n    }\r\n\r\n    return result;\r\n\r\n"]]}
{"hexsha": "3590e15e5d52d9b880b5afbe50ae6091cf5fcc6e", "ext": "c", "lang": "C", "content": "int32_t msm_camera_tz_i2c_read_seq(struct msm_camera_i2c_client *client,\n\tuint32_t addr, uint8_t *data, uint32_t num_byte)\n{\n\tint32_t rc = -EFAULT;\n\tint32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);\n\n\tCDBG(\"Sensor=%d, MS=%d, SID=%d, CID=%d, addr=0x%08X, num=%d\\n\",\n\t\tsensor_id,\n\t\tclient->cci_client->cci_i2c_master,\n\t\tclient->cci_client->sid,\n\t\tclient->cci_client->cid,\n\t\taddr,\n\t\tnum_byte);\n\n\tif (sensor_id >= 0) {\n\t\trc = msm_camera_tz_i2c_ta_cci_generic(\n\t\t\tclient, MSM_CAMERA_TZ_CMD_CCI_READ_SEQ);\n\t\tmsm_camera_tz_i2c_ta_done();\n\t}\n\treturn TZ_I2C_FN_RETURN(rc,\n\t\tmsm_camera_cci_i2c_read_seq, client, addr, data, num_byte);\n}", "item_id": 13, "repo": "clovadevice/clockplus2", "file": "kernel/msm-4.14/drivers/media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c", "last_update_at": "2021-06-29T01:29:23+00:00", "question_id": "3590e15e5d52d9b880b5afbe50ae6091cf5fcc6e_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int32_t msm_camera_tz_i2c_read_seq(struct msm_camera_i2c_client *client,\n\tuint32_t addr, uint8_t *data, uint32_t num_byte)\n{\n\tint32_t rc = -EFAULT;\n\tint32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);\n\tCDBG(\"Sensor=%d, MS=%d, SID=%d, CID=%d, addr=0x%08X, num=%d\\n\",\n\t\tsensor_id,\n\t\tclient->cci_client->cci_i2c_master,\n\t\tclient->cci_client->sid,\n\t\tclient->cci_client->cid,\n\t\taddr,\n\t\tnum_byte);\n\tif (sensor_id >= 0) {\n\t\trc = msm_camera_tz_i2c_ta_cci_generic(\n\t\t\tclient, MSM_CAMERA_TZ_CMD_CCI_READ_SEQ);\n\t\tmsm_camera_tz_i2c_ta_done();\n\t}\n\treturn TZ_I2C_FN_RETURN(rc,\n\t\tmsm_camera_cci_i2c_read_seq, client, addr, data, num_byte);\n"]]}
{"hexsha": "4f535c2894ec852c8c34c6df806220c2408136a2", "ext": "c", "lang": "C", "content": "void f75(void) {\n    \tint16_t x309 = -23;\n\tint32_t x311 = -220;\n\tvolatile int16_t x312 = INT16_MAX;\n\tvolatile int32_t t75 = -1973570;\n\n    t75 = (((x309!=x310)+x311)<=x312);\n\n    if (t75 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 75, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test1186.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "4f535c2894ec852c8c34c6df806220c2408136a2_75", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f75(void) {\n    \tint16_t x309 = -23;\n\tint32_t x311 = -220;\n\tvolatile int16_t x312 = INT16_MAX;\n\tvolatile int32_t t75 = -1973570;\n    t75 = (((x309!=x310)+x311)<=x312);\n    if (t75 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "64f7b09f97859fecef2ad3f944d0fa8f5427ef81", "ext": "c", "lang": "C", "content": "void f170(void) {\n    \tint32_t x693 = INT32_MIN;\n\tuint16_t x694 = UINT16_MAX;\n\tstatic int8_t x695 = INT8_MIN;\n\tvolatile int32_t x696 = 4;\n\tstatic volatile int32_t t170 = 1;\n\n    t170 = ((x693>(x694<=x695))/x696);\n\n    if (t170 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 170, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test1880.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "64f7b09f97859fecef2ad3f944d0fa8f5427ef81_170", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f170(void) {\n    \tint32_t x693 = INT32_MIN;\n\tuint16_t x694 = UINT16_MAX;\n\tstatic int8_t x695 = INT8_MIN;\n\tvolatile int32_t x696 = 4;\n\tstatic volatile int32_t t170 = 1;\n    t170 = ((x693>(x694<=x695))/x696);\n    if (t170 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "b7dee672e781a753187b52cb9c6f6a7af3642966", "ext": "c", "lang": "C", "content": "static int isum( const int n, const int ix[] ) {\n    //int i, sum=0;\n    //for ( i=0; i<n; i++ ) sum += ix[i];\n    //return sum;\n    return ofmo_isum(n, ix);\n}", "item_id": 0, "repo": "JorgeG94/OpenFMO", "file": "worker/ofmo-calc-frag.c", "last_update_at": "2021-06-29T14:40:59+00:00", "question_id": "b7dee672e781a753187b52cb9c6f6a7af3642966_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int isum( const int n, const int ix[] ) {\n    //int i, sum=0;\n    //for ( i=0; i<n; i++ ) sum += ix[i];\n    //return sum;\n    return ofmo_isum(n, ix);\n"]]}
{"hexsha": "4896ac1414bc8d0862f28eb473d2688fb392d8a7", "ext": "c", "lang": "C", "content": "void f16(void) {\n    \tstatic int32_t x65 = INT32_MIN;\n\tstatic uint64_t x66 = 49240951543LLU;\n\tvolatile int8_t x68 = -1;\n\tvolatile uint64_t t16 = UINT64_MAX;\n\n    t16 = (((x65|x66)&x67)|x68);\n\n    if (t16 != UINT64_MAX) { NG(); } else { ; }\n\t\n}", "item_id": 16, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test2519.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "4896ac1414bc8d0862f28eb473d2688fb392d8a7_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f16(void) {\n    \tstatic int32_t x65 = INT32_MIN;\n\tstatic uint64_t x66 = 49240951543LLU;\n\tvolatile int8_t x68 = -1;\n\tvolatile uint64_t t16 = UINT64_MAX;\n    t16 = (((x65|x66)&x67)|x68);\n    if (t16 != UINT64_MAX) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "147a41642a317d1f8393bba00c9d40eb63ac4e49", "ext": "c", "lang": "C", "content": "static int con_write_room(struct tty_struct *tty)\n{\n\tif (tty->stopped)\n\t\treturn 0;\n\treturn 4096;\t\t/* No limit, really; we're not buffering */\n}", "item_id": 31, "repo": "CodeAsm/PS1Linux", "file": "linux/arch/m68knommu/kernel/console.c", "last_update_at": "2021-10-17T21:51:58+00:00", "question_id": "147a41642a317d1f8393bba00c9d40eb63ac4e49_31", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int con_write_room(struct tty_struct *tty)\n{\n\tif (tty->stopped)\n\t\treturn 0;\n\treturn 4096;\t\t/* No limit, really; we're not buffering */\n"]]}
{"hexsha": "04ea4a0702073fd2459c81d9220d06a5c99fac68", "ext": "c", "lang": "C", "content": "void *fetch_freelist(freelist_handle *handle)\n{\n    if(is_freelist_empty(handle))\n        return NULL;\n    void *rt = FL->next;\n    FL->next = FL->next->next;\n    return rt;\n}", "item_id": 1, "repo": "TinyOSOrg/TinyOS", "file": "src/shared/freelist.c", "last_update_at": "2021-09-30T13:05:49+00:00", "question_id": "04ea4a0702073fd2459c81d9220d06a5c99fac68_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void *fetch_freelist(freelist_handle *handle)\n{\n    if(is_freelist_empty(handle))\n        return NULL;\n    void *rt = FL->next;\n    FL->next = FL->next->next;\n    return rt;\n"]]}
{"hexsha": "c194c366472af69f47be7e03b50cd7b34cdf89df", "ext": "c", "lang": "C", "content": "bool\nGSInit(void) {\n\tsize_t i;\n\n\tGSMainLoop = 1;\n\tGSCoreSocket = -1;\n\tGSCoreThreadState = 0;\n\tGSRedirSocket = -1;\n\tGSRedirThreadState = 0;\n\n\tGSPopulateHostName();\n\n\tif (!GSPopulateProductName()) {\n\t\tperror(ANSI_COLOR_RED\"[GSInit] Failed to populate the 'Server' header\"\n\t\t\t   ANSI_COLOR_RESETLN);\n\t\treturn false;\n\t}\n\n\tGSChildThreads = calloc(GSChildSize, sizeof(struct GSThread));\n\tif (GSChildThreads == NULL) {\n\t\tperror(ANSI_COLOR_RED\"[GSInit] Failed to allocate\"ANSI_COLOR_RESETLN);\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < GSChildSize; i++)\n\t\tGSChildThreads[i].sockfd = -1;\n\n\tGSCoreSocket = IOCreateSocket(443, 1);\n\n\tif (GSCoreSocket < 0) {\n\t\tprintf(ANSI_COLOR_RED\"[GSInit] Failed to create GSCoreSocket: %s\"\n\t\t\tANSI_COLOR_RESETLN, IOErrors[-GSCoreSocket]);\n\t\treturn false;\n\t}\n\n\tGSRedirSocket = IOCreateSocket(80, 1);\n\n\tif (GSRedirSocket < 0) {\n\t\tprintf(ANSI_COLOR_RED\"[GSInit] Failed to create GSRedirSocket: %s\"\n\t\t\tANSI_COLOR_RESETLN, IOErrors[-GSRedirSocket]);\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "item_id": 2, "repo": "wooshdev/feather", "file": "base/global_state.c", "last_update_at": "2021-01-05T22:03:02+00:00", "question_id": "c194c366472af69f47be7e03b50cd7b34cdf89df_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool\nGSInit(void) {\n\tsize_t i;\n\tGSMainLoop = 1;\n\tGSCoreSocket = -1;\n\tGSCoreThreadState = 0;\n\tGSRedirSocket = -1;\n\tGSRedirThreadState = 0;\n\tGSPopulateHostName();\n\tif (!GSPopulateProductName()) {\n\t\tperror(ANSI_COLOR_RED\"[GSInit] Failed to populate the 'Server' header\"\n\t\t\t   ANSI_COLOR_RESETLN);\n\t\treturn false;\n\t}\n\tGSChildThreads = calloc(GSChildSize, sizeof(struct GSThread));\n\tif (GSChildThreads == NULL) {\n\t\tperror(ANSI_COLOR_RED\"[GSInit] Failed to allocate\"ANSI_COLOR_RESETLN);\n\t\treturn false;\n\t}\n\tfor (i = 0; i < GSChildSize; i++)\n\t\tGSChildThreads[i].sockfd = -1;\n\tGSCoreSocket = IOCreateSocket(443, 1);\n\tif (GSCoreSocket < 0) {\n\t\tprintf(ANSI_COLOR_RED\"[GSInit] Failed to create GSCoreSocket: %s\"\n\t\t\tANSI_COLOR_RESETLN, IOErrors[-GSCoreSocket]);\n\t\treturn false;\n\t}\n\tGSRedirSocket = IOCreateSocket(80, 1);\n\tif (GSRedirSocket < 0) {\n\t\tprintf(ANSI_COLOR_RED\"[GSInit] Failed to create GSRedirSocket: %s\"\n\t\t\tANSI_COLOR_RESETLN, IOErrors[-GSRedirSocket]);\n\t\treturn false;\n\t}\n\treturn true;\n"]]}
{"hexsha": "9292252b4a76ba14305ba252856b3715acb46019", "ext": "c", "lang": "C", "content": "static VSTRING *make_822_quoted_string(VSTRING *dst, const char *local_part,\n\t\t\t\t               const char *end, int flags)\n{\n    const char *cp;\n    int     ch;\n\n    /*\n     * Put quotes around the result, and prepend a backslash to characters\n     * that need quoting when they occur in a quoted-string.\n     */\n    VSTRING_ADDCH(dst, '\"');\n    for (cp = local_part; cp < end && (ch = *(unsigned char *) cp) != 0; cp++) {\n\tif ((ch > 127 && !(flags & QUOTE_FLAG_8BITCLEAN))\n\t    || ch == '\"' || ch == '\\\\' || ch == '\\r')\n\t    VSTRING_ADDCH(dst, '\\\\');\n\tVSTRING_ADDCH(dst, ch);\n    }\n    VSTRING_ADDCH(dst, '\"');\n    return (dst);\n}", "item_id": 1, "repo": "uninth/UNItools", "file": "src/GaIA/pkgs/postfix/postfix-3.0.2/src/global/quote_822_local.c", "last_update_at": "2021-06-08T15:59:26+00:00", "question_id": "9292252b4a76ba14305ba252856b3715acb46019_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static VSTRING *make_822_quoted_string(VSTRING *dst, const char *local_part,\n\t\t\t\t               const char *end, int flags)\n{\n    const char *cp;\n    int     ch;\n    /*\n     * Put quotes around the result, and prepend a backslash to characters\n     * that need quoting when they occur in a quoted-string.\n     */\n    VSTRING_ADDCH(dst, '\"');\n    for (cp = local_part; cp < end && (ch = *(unsigned char *) cp) != 0; cp++) {\n\tif ((ch > 127 && !(flags & QUOTE_FLAG_8BITCLEAN))\n\t    || ch == '\"' || ch == '\\\\' || ch == '\\r')\n\t    VSTRING_ADDCH(dst, '\\\\');\n\tVSTRING_ADDCH(dst, ch);\n    }\n    VSTRING_ADDCH(dst, '\"');\n    return (dst);\n"]]}
{"hexsha": "6c90306ea1e75f8419771f211e543a6ea235b910", "ext": "c", "lang": "C", "content": "static int\nmodel_crisv32_bcc_w (SIM_CPU *current_cpu, void *sem_arg)\n{\n#define FLD(f) abuf->fields.sfmt_bcc_w.f\n  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);\n  const IDESC * UNUSED idesc = abuf->idesc;\n  int cycles = 0;\n  {\n    int referenced = 0;\n    int UNUSED insn_referenced = abuf->written;\n    cycles += crisv32f_model_crisv32_u_const16 (current_cpu, idesc, 0, referenced);\n  }\n  {\n    int referenced = 0;\n    int UNUSED insn_referenced = abuf->written;\n    cycles += crisv32f_model_crisv32_u_branch (current_cpu, idesc, 1, referenced);\n  }\n  {\n    int referenced = 0;\n    int UNUSED insn_referenced = abuf->written;\n    INT in_Rd = -1;\n    INT in_Rs = -1;\n    INT out_Rd = -1;\n    cycles += crisv32f_model_crisv32_u_exec (current_cpu, idesc, 2, referenced, in_Rd, in_Rs, out_Rd);\n  }\n  return cycles;\n#undef FLD\n}", "item_id": 175, "repo": "pavel-krivanek/opensmalltalk-vm", "file": "processors/ARM/gdb-7.10/sim/cris/modelv32.c", "last_update_at": "2021-08-08T05:06:55+00:00", "question_id": "6c90306ea1e75f8419771f211e543a6ea235b910_175", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nmodel_crisv32_bcc_w (SIM_CPU *current_cpu, void *sem_arg)\n{\n#define FLD(f) abuf->fields.sfmt_bcc_w.f\n  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);\n  const IDESC * UNUSED idesc = abuf->idesc;\n  int cycles = 0;\n  {\n    int referenced = 0;\n    int UNUSED insn_referenced = abuf->written;\n    cycles += crisv32f_model_crisv32_u_const16 (current_cpu, idesc, 0, referenced);\n  }\n  {\n    int referenced = 0;\n    int UNUSED insn_referenced = abuf->written;\n    cycles += crisv32f_model_crisv32_u_branch (current_cpu, idesc, 1, referenced);\n  }\n  {\n    int referenced = 0;\n    int UNUSED insn_referenced = abuf->written;\n    INT in_Rd = -1;\n    INT in_Rs = -1;\n    INT out_Rd = -1;\n    cycles += crisv32f_model_crisv32_u_exec (current_cpu, idesc, 2, referenced, in_Rd, in_Rs, out_Rd);\n  }\n  return cycles;\n#undef FLD\n"]]}
{"hexsha": "3a02f344b5c15fd5cd52ce9fc6cd4195358f934a", "ext": "h", "lang": "C", "content": "__DEFAULT_SVML_FN_ATTRS512\n    _mm512_mask_atan_pd(__m512d param0, __mmask8 param1, __m512d param2) \n{ \n    register __m512d reg0 asm(\"zmm0\");\n    reg0 = _mm512_mask_load_pd(param0,param1, &param2);\n    asm( \n         \"call __vdecl_atan8 \\t\\n\" \n        : \"=v\" (reg0)\n        : \"0\" (reg0)\n        : \"%ymm1\", \"%ymm2\", \"%ymm3\", \"%ymm4\", \"%ymm5\", \"%rax\", \"%rcx\", \"%rdx\", \"%r8\", \"%r9\", \"%r10\", \"%r11\"\n        );\n     param2 = param0;\n    _mm512_mask_store_pd(&param2,param1,reg0);\n    return param2;\n}", "item_id": 47, "repo": "Neumann-A/llvm_svml_intrinsic_generator", "file": "generated_code/avx512_svml_intrin.h", "last_update_at": "2021-11-23T13:30:24+00:00", "question_id": "3a02f344b5c15fd5cd52ce9fc6cd4195358f934a_47", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["__DEFAULT_SVML_FN_ATTRS512\n    _mm512_mask_atan_pd(__m512d param0, __mmask8 param1, __m512d param2) \n{ \n    register __m512d reg0 asm(\"zmm0\");\n    reg0 = _mm512_mask_load_pd(param0,param1, &param2);\n    asm( \n         \"call __vdecl_atan8 \\t\\n\" \n        : \"=v\" (reg0)\n        : \"0\" (reg0)\n        : \"%ymm1\", \"%ymm2\", \"%ymm3\", \"%ymm4\", \"%ymm5\", \"%rax\", \"%rcx\", \"%rdx\", \"%r8\", \"%r9\", \"%r10\", \"%r11\"\n        );\n     param2 = param0;\n    _mm512_mask_store_pd(&param2,param1,reg0);\n    return param2;\n"]]}
{"hexsha": "5983bf2281ed68ee8f05d0ab2bd4253efd4fdbb2", "ext": "c", "lang": "C", "content": "EFI_STATUS\r\nEFIAPI\r\nLibGetTime (\r\n  OUT  EFI_TIME                 *Time,\r\n  OUT  EFI_TIME_CAPABILITIES    *Capabilities\r\n  )\r\n{\r\n  EFI_STATUS                    Status;\r\n  INT16                         TimeZone;\r\n  UINT8                         Daylight;\r\n  RTC_DATETIME                  DateTime;\r\n  UINTN                         Size;\r\n  UINT8                         Val;\r\n  RTC_I2C_REQUEST               Req;\r\n  UINT8                         RtcRegAddr;\r\n\r\n  if (mI2cMaster == NULL) {\r\n    BOOTTIME_DEBUG ((DEBUG_ERROR, \"%a : I2c Master protocol is not yet installed\\n\", __FUNCTION__));\r\n    return EFI_DEVICE_ERROR;\r\n  }\r\n\r\n  if (Time == NULL) {\r\n    BOOTTIME_DEBUG ((DEBUG_ERROR, \"Received NULL parameter\\n\"));\r\n    return EFI_INVALID_PARAMETER;\r\n  }\r\n\r\n  RtcRegAddr = PCF85263_CENTISEC_REG_ADDR;\r\n\r\n  Req.OperationCount = 2;\r\n\r\n  Req.SetAddressOp.Flags = 0;\r\n  Req.SetAddressOp.LengthInBytes = sizeof (RtcRegAddr);\r\n  Req.SetAddressOp.Buffer = &RtcRegAddr;\r\n\r\n  Req.GetSetDateTimeOp.Flags = I2C_FLAG_READ;\r\n  Req.GetSetDateTimeOp.LengthInBytes = sizeof (RTC_DATETIME);\r\n  Req.GetSetDateTimeOp.Buffer = (VOID *)&DateTime;\r\n\r\n  Status = mI2cMaster->StartRequest (mI2cMaster, FixedPcdGet8 (PcdI2cSlaveAddress),\r\n                                     (VOID *)&Req,\r\n                                     NULL,  NULL);\r\n  if (EFI_ERROR (Status)) {\r\n    BOOTTIME_DEBUG ((DEBUG_ERROR, \"RTC read error at Addr:0x%x, Status = %r\\n\", RtcRegAddr, Status));\r\n    return Status;\r\n  }\r\n\r\n  if (DateTime.Seconds & PCF85263_SEC_BIT_OSC) {\r\n    BOOTTIME_DEBUG ((DEBUG_ERROR, \"### Warning: RTC oscillator has stopped\\n\"));\r\n    /* clear the OS flag */\r\n    Val = DateTime.Seconds & ~PCF85263_SEC_BIT_OSC;\r\n    RtcWrite (PCF85263_SEC_REG_ADDR, Val);\r\n\r\n    return EFI_DEVICE_ERROR;\r\n  }\r\n\r\n  Time->Nanosecond = BcdToDecimal8 (DateTime.CentiSeconds) * 10000000;\r\n  Time->Second  = BcdToDecimal8 (DateTime.Seconds & MASK_SEC);\r\n  Time->Minute  = BcdToDecimal8 (DateTime.Minutes & MASK_MIN);\r\n  Time->Hour = BcdToDecimal8 (DateTime.Hours & MASK_HOUR);\r\n  Time->Day = BcdToDecimal8 (DateTime.Days & MASK_DAY);\r\n  Time->Month  = BcdToDecimal8 (DateTime.Months & MASK_MONTH);\r\n  Time->Year = BcdToDecimal8 (DateTime.Years) +\r\n               (BcdToDecimal8 (DateTime.Years) >= 98 ? 1900 : 2000);\r\n\r\n  // Get the current time zone information from non-volatile storage\r\n  Size = sizeof (TimeZone);\r\n  Status = EfiGetVariable (\r\n             (CHAR16 *)mTimeZoneVariableName,\r\n             &gEfiCallerIdGuid,\r\n             NULL,\r\n             &Size,\r\n             (VOID *)&TimeZone\r\n             );\r\n\r\n  if (EFI_ERROR (Status)) {\r\n    ASSERT (Status != EFI_INVALID_PARAMETER);\r\n    ASSERT (Status != EFI_BUFFER_TOO_SMALL);\r\n\r\n    if (Status != EFI_NOT_FOUND) {\r\n      return Status;\r\n    }\r\n\r\n    // The time zone variable does not exist in non-volatile storage, so create it.\r\n    Time->TimeZone = EFI_UNSPECIFIED_TIMEZONE;\r\n    // Store it\r\n    Status = EfiSetVariable (\r\n               (CHAR16 *)mTimeZoneVariableName,\r\n               &gEfiCallerIdGuid,\r\n               EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,\r\n               Size,\r\n               (VOID *)&(Time->TimeZone)\r\n               );\r\n\r\n    if (EFI_ERROR (Status)) {\r\n      BOOTTIME_DEBUG ((DEBUG_ERROR,\r\n        \"LibGetTime: Failed to save %s variable to non-volatile storage, Status = %d\\n\",\r\n        mTimeZoneVariableName,\r\n        Status\r\n        ));\r\n      return Status;\r\n    }\r\n  } else {\r\n    // Got the time zone\r\n    Time->TimeZone = TimeZone;\r\n\r\n    // Check TimeZone bounds:   -1440 to 1440 or 2047\r\n    if (((Time->TimeZone < -1440) || (Time->TimeZone > 1440))\r\n        && (Time->TimeZone != EFI_UNSPECIFIED_TIMEZONE)) {\r\n      Time->TimeZone = EFI_UNSPECIFIED_TIMEZONE;\r\n    }\r\n  }\r\n\r\n  // Get the current daylight information from non-volatile storage\r\n  Size = sizeof (Daylight);\r\n  Status = EfiGetVariable (\r\n             (CHAR16 *)mDaylightVariableName,\r\n             &gEfiCallerIdGuid,\r\n             NULL,\r\n             &Size,\r\n             (VOID *)&Daylight\r\n             );\r\n\r\n  if (EFI_ERROR (Status)) {\r\n    ASSERT (Status != EFI_INVALID_PARAMETER);\r\n    ASSERT (Status != EFI_BUFFER_TOO_SMALL);\r\n\r\n    if (Status != EFI_NOT_FOUND) {\r\n      return Status;\r\n    }\r\n\r\n    // The daylight variable does not exist in non-volatile storage, so create it.\r\n    Time->Daylight = 0;\r\n    // Store it\r\n    Status = EfiSetVariable (\r\n               (CHAR16 *)mDaylightVariableName,\r\n               &gEfiCallerIdGuid,\r\n               EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,\r\n               Size,\r\n               (VOID *)&(Time->Daylight)\r\n               );\r\n    if (EFI_ERROR (Status)) {\r\n      BOOTTIME_DEBUG ((DEBUG_ERROR,\r\n        \"LibGetTime: Failed to save %s variable to non-volatile storage, Status = %d\\n\",\r\n        mDaylightVariableName,\r\n        Status\r\n        ));\r\n      return Status;\r\n    }\r\n  } else {\r\n    // Got the daylight information\r\n    Time->Daylight = Daylight;\r\n  }\r\n\r\n  return Status;\r\n}", "item_id": 4, "repo": "SolidRun/edk2-platforms", "file": "Silicon/NXP/Library/Pcf85263RtcLib/Pcf85263RtcLib.c", "last_update_at": "2021-09-17T08:46:11+00:00", "question_id": "5983bf2281ed68ee8f05d0ab2bd4253efd4fdbb2_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["EFI_STATUS\r\nEFIAPI\r\nLibGetTime (\r\n  OUT  EFI_TIME                 *Time,\r\n  OUT  EFI_TIME_CAPABILITIES    *Capabilities\r\n  )\r\n{\r\n  EFI_STATUS                    Status;\r\n  INT16                         TimeZone;\r\n  UINT8                         Daylight;\r\n  RTC_DATETIME                  DateTime;\r\n  UINTN                         Size;\r\n  UINT8                         Val;\r\n  RTC_I2C_REQUEST               Req;\r\n  UINT8                         RtcRegAddr;\r\n\r\n  if (mI2cMaster == NULL) {\r\n    BOOTTIME_DEBUG ((DEBUG_ERROR, \"%a : I2c Master protocol is not yet installed\\n\", __FUNCTION__));\r\n    return EFI_DEVICE_ERROR;\r\n  }\r\n\r\n  if (Time == NULL) {\r\n    BOOTTIME_DEBUG ((DEBUG_ERROR, \"Received NULL parameter\\n\"));\r\n    return EFI_INVALID_PARAMETER;\r\n  }\r\n\r\n  RtcRegAddr = PCF85263_CENTISEC_REG_ADDR;\r\n\r\n  Req.OperationCount = 2;\r\n\r\n  Req.SetAddressOp.Flags = 0;\r\n  Req.SetAddressOp.LengthInBytes = sizeof (RtcRegAddr);\r\n  Req.SetAddressOp.Buffer = &RtcRegAddr;\r\n\r\n  Req.GetSetDateTimeOp.Flags = I2C_FLAG_READ;\r\n  Req.GetSetDateTimeOp.LengthInBytes = sizeof (RTC_DATETIME);\r\n  Req.GetSetDateTimeOp.Buffer = (VOID *)&DateTime;\r\n\r\n  Status = mI2cMaster->StartRequest (mI2cMaster, FixedPcdGet8 (PcdI2cSlaveAddress),\r\n                                     (VOID *)&Req,\r\n                                     NULL,  NULL);\r\n  if (EFI_ERROR (Status)) {\r\n    BOOTTIME_DEBUG ((DEBUG_ERROR, \"RTC read error at Addr:0x%x, Status = %r\\n\", RtcRegAddr, Status));\r\n    return Status;\r\n  }\r\n\r\n  if (DateTime.Seconds & PCF85263_SEC_BIT_OSC) {\r\n    BOOTTIME_DEBUG ((DEBUG_ERROR, \"### Warning: RTC oscillator has stopped\\n\"));\r\n    /* clear the OS flag */\r\n    Val = DateTime.Seconds & ~PCF85263_SEC_BIT_OSC;\r\n    RtcWrite (PCF85263_SEC_REG_ADDR, Val);\r\n\r\n    return EFI_DEVICE_ERROR;\r\n  }\r\n\r\n  Time->Nanosecond = BcdToDecimal8 (DateTime.CentiSeconds) * 10000000;\r\n  Time->Second  = BcdToDecimal8 (DateTime.Seconds & MASK_SEC);\r\n  Time->Minute  = BcdToDecimal8 (DateTime.Minutes & MASK_MIN);\r\n  Time->Hour = BcdToDecimal8 (DateTime.Hours & MASK_HOUR);\r\n  Time->Day = BcdToDecimal8 (DateTime.Days & MASK_DAY);\r\n  Time->Month  = BcdToDecimal8 (DateTime.Months & MASK_MONTH);\r\n  Time->Year = BcdToDecimal8 (DateTime.Years) +\r\n               (BcdToDecimal8 (DateTime.Years) >= 98 ? 1900 : 2000);\r\n\r\n  // Get the current time zone information from non-volatile storage\r\n  Size = sizeof (TimeZone);\r\n  Status = EfiGetVariable (\r\n             (CHAR16 *)mTimeZoneVariableName,\r\n             &gEfiCallerIdGuid,\r\n             NULL,\r\n             &Size,\r\n             (VOID *)&TimeZone\r\n             );\r\n\r\n  if (EFI_ERROR (Status)) {\r\n    ASSERT (Status != EFI_INVALID_PARAMETER);\r\n    ASSERT (Status != EFI_BUFFER_TOO_SMALL);\r\n\r\n    if (Status != EFI_NOT_FOUND) {\r\n      return Status;\r\n    }\r\n\r\n    // The time zone variable does not exist in non-volatile storage, so create it.\r\n    Time->TimeZone = EFI_UNSPECIFIED_TIMEZONE;\r\n    // Store it\r\n    Status = EfiSetVariable (\r\n               (CHAR16 *)mTimeZoneVariableName,\r\n               &gEfiCallerIdGuid,\r\n               EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,\r\n               Size,\r\n               (VOID *)&(Time->TimeZone)\r\n               );\r\n\r\n    if (EFI_ERROR (Status)) {\r\n      BOOTTIME_DEBUG ((DEBUG_ERROR,\r\n        \"LibGetTime: Failed to save %s variable to non-volatile storage, Status = %d\\n\",\r\n        mTimeZoneVariableName,\r\n        Status\r\n        ));\r\n      return Status;\r\n    }\r\n  } else {\r\n    // Got the time zone\r\n    Time->TimeZone = TimeZone;\r\n\r\n    // Check TimeZone bounds:   -1440 to 1440 or 2047\r\n    if (((Time->TimeZone < -1440) || (Time->TimeZone > 1440))\r\n        && (Time->TimeZone != EFI_UNSPECIFIED_TIMEZONE)) {\r\n      Time->TimeZone = EFI_UNSPECIFIED_TIMEZONE;\r\n    }\r\n  }\r\n\r\n  // Get the current daylight information from non-volatile storage\r\n  Size = sizeof (Daylight);\r\n  Status = EfiGetVariable (\r\n             (CHAR16 *)mDaylightVariableName,\r\n             &gEfiCallerIdGuid,\r\n             NULL,\r\n             &Size,\r\n             (VOID *)&Daylight\r\n             );\r\n\r\n  if (EFI_ERROR (Status)) {\r\n    ASSERT (Status != EFI_INVALID_PARAMETER);\r\n    ASSERT (Status != EFI_BUFFER_TOO_SMALL);\r\n\r\n    if (Status != EFI_NOT_FOUND) {\r\n      return Status;\r\n    }\r\n\r\n    // The daylight variable does not exist in non-volatile storage, so create it.\r\n    Time->Daylight = 0;\r\n    // Store it\r\n    Status = EfiSetVariable (\r\n               (CHAR16 *)mDaylightVariableName,\r\n               &gEfiCallerIdGuid,\r\n               EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,\r\n               Size,\r\n               (VOID *)&(Time->Daylight)\r\n               );\r\n    if (EFI_ERROR (Status)) {\r\n      BOOTTIME_DEBUG ((DEBUG_ERROR,\r\n        \"LibGetTime: Failed to save %s variable to non-volatile storage, Status = %d\\n\",\r\n        mDaylightVariableName,\r\n        Status\r\n        ));\r\n      return Status;\r\n    }\r\n  } else {\r\n    // Got the daylight information\r\n    Time->Daylight = Daylight;\r\n  }\r\n\r\n  return Status;\r\n"]]}
{"hexsha": "c64ce7a39e94680723124982cf780aff71b4ef96", "ext": "h", "lang": "C", "content": "MC_TARGET_FUNC int mc_zlogspace1xnff(const int n, double * x_r, double * x_i, const float x1_r, const float x1_i, const float x2_r, const float x2_i)\n{\n//!# Requires x[n] where 1 < n. Draws a logspace: generates a logarithmically spaced\n//!# vector `x`, i.e n points with spacing between points being (x2-x1)/(n-1).\n\tint i = 1;\n\tdouble stepr, stepi, x1rd, x1id, x2rd, x2id;\n\tif (n > 0) {\n\t\tx1rd = mc_cast(double, x1_r);\n\t\tx1id = mc_cast(double, x1_i);\n\t\tx2rd = mc_cast(double, x2_r);\n\t\tx2id = mc_cast(double, x2_i);\n\t\tif (n < 2) {\n\t\t\tmc_zpow10(&x_r[0], &x_i[0], x2rd, x2id);\n\t\t} else if (n < 3) {\n\t\t\tmc_zpow10(&x_r[0], &x_i[0], x1rd, x1id);\n\t\t\tmc_zpow10(&x_r[1], &x_i[1], x2rd, x2id);\n\t\t} else {\n\t\t\tmc_zsub(&stepr, &stepi, x2rd, x2id, x1rd, x1id);\n\t\t\tmc_zdiv(&stepr, &stepi, stepr, stepi, mc_cast(double, (n - 1)), 0.0);\n\t\t\tmc_zpow10(&x_r[0], &x_i[0], x1rd, x1id);\n\t\t\tmc_zpow10(&x_r[(n - 1)], &x_i[(n - 1)], x2rd, x2id);\n\t\t\tfor (; i < (n - 1); i++) {\n\t\t\t\tmc_zmul(&x_r[i], &x_i[i], mc_cast(double, i), 0.0, stepr, stepi);\n\t\t\t\tmc_zadd(&x_r[i], &x_i[i], x1rd, x1id, x_r[i], x_i[i]);\n\t\t\t\tmc_zpow10(&x_r[i], &x_i[i], x_r[i], x_i[i]);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -1;\n}", "item_id": 1, "repo": "moe123/macadam", "file": "macadam/details/numa/mc_zlogspace1xn.h", "last_update_at": "2021-07-06T01:00:54+00:00", "question_id": "c64ce7a39e94680723124982cf780aff71b4ef96_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["MC_TARGET_FUNC int mc_zlogspace1xnff(const int n, double * x_r, double * x_i, const float x1_r, const float x1_i, const float x2_r, const float x2_i)\n{\n//!# Requires x[n] where 1 < n. Draws a logspace: generates a logarithmically spaced\n//!# vector `x`, i.e n points with spacing between points being (x2-x1)/(n-1).\n\tint i = 1;\n\tdouble stepr, stepi, x1rd, x1id, x2rd, x2id;\n\tif (n > 0) {\n\t\tx1rd = mc_cast(double, x1_r);\n\t\tx1id = mc_cast(double, x1_i);\n\t\tx2rd = mc_cast(double, x2_r);\n\t\tx2id = mc_cast(double, x2_i);\n\t\tif (n < 2) {\n\t\t\tmc_zpow10(&x_r[0], &x_i[0], x2rd, x2id);\n\t\t} else if (n < 3) {\n\t\t\tmc_zpow10(&x_r[0], &x_i[0], x1rd, x1id);\n\t\t\tmc_zpow10(&x_r[1], &x_i[1], x2rd, x2id);\n\t\t} else {\n\t\t\tmc_zsub(&stepr, &stepi, x2rd, x2id, x1rd, x1id);\n\t\t\tmc_zdiv(&stepr, &stepi, stepr, stepi, mc_cast(double, (n - 1)), 0.0);\n\t\t\tmc_zpow10(&x_r[0], &x_i[0], x1rd, x1id);\n\t\t\tmc_zpow10(&x_r[(n - 1)], &x_i[(n - 1)], x2rd, x2id);\n\t\t\tfor (; i < (n - 1); i++) {\n\t\t\t\tmc_zmul(&x_r[i], &x_i[i], mc_cast(double, i), 0.0, stepr, stepi);\n\t\t\t\tmc_zadd(&x_r[i], &x_i[i], x1rd, x1id, x_r[i], x_i[i]);\n\t\t\t\tmc_zpow10(&x_r[i], &x_i[i], x_r[i], x_i[i]);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -1;\n"]]}
{"hexsha": "3c2902c785ceea74459c306984a7302db5229df4", "ext": "c", "lang": "C", "content": "void f140(void) {\n    \tvolatile uint32_t x4513 = UINT32_MAX;\n\tvolatile uint32_t x4514 = 1U;\n\tvolatile uint32_t t140 = 1867U;\n\n    t140 = (x4513>>(x4514+(x4515>x4516)));\n\n    if (t140 != 2147483647U) { NG(); } else { ; }\n\t\n}", "item_id": 140, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test1579.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "3c2902c785ceea74459c306984a7302db5229df4_140", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f140(void) {\n    \tvolatile uint32_t x4513 = UINT32_MAX;\n\tvolatile uint32_t x4514 = 1U;\n\tvolatile uint32_t t140 = 1867U;\n    t140 = (x4513>>(x4514+(x4515>x4516)));\n    if (t140 != 2147483647U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "31bd13fedd8d19cacf5ed6c1034995c0e41f956f", "ext": "c", "lang": "C", "content": "tree_node_t*\ncreate_tree(void)\n{\n  tree_node_t* tree;\n\n  tree = get_node();\n  tree->left = NULL;\n  tree->summand = 0;\n  tree->partial_sum = 0;\n\n  /* need key -infty, use tree as non-NULL object ptr */\n  insert( tree, NEGINFTY, (object_t*) tree );\n\n  return ( tree );\n}", "item_id": 1, "repo": "stanman29/c_lang_project", "file": "src/bin/books/advanced_data_structures/ch4/wsmx_tree.c", "last_update_at": "2021-02-19T09:18:51+00:00", "question_id": "31bd13fedd8d19cacf5ed6c1034995c0e41f956f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["tree_node_t*\ncreate_tree(void)\n{\n  tree_node_t* tree;\n  tree = get_node();\n  tree->left = NULL;\n  tree->summand = 0;\n  tree->partial_sum = 0;\n  /* need key -infty, use tree as non-NULL object ptr */\n  insert( tree, NEGINFTY, (object_t*) tree );\n  return ( tree );\n"]]}
{"hexsha": "59ea005d0c4bd37eff2d51f7e3d9925c14aa3618", "ext": "c", "lang": "C", "content": "int luat_spi_setup(luat_spi_t *spi)\n{\n\t// SPI2_HOST = 1\n\t// SPI3_HOST = 2\n\tif (spi->id == 1)\n\t{\n\t\tspi_bus_config_t spi_config = {};\n\t\tspi_config.miso_io_num = 12;\n\t\tspi_config.mosi_io_num = 13;\n\t\tspi_config.sclk_io_num = 14;\n\t\tspi_config.quadwp_io_num = -1;\n\t\tspi_config.quadhd_io_num = -1;\n\t\tspi_config.max_transfer_sz = 0;\n\t\tESP_ERROR_CHECK(spi_bus_initialize(SPI2_HOST, &spi_config, 0));\n\t} else if (spi->id == 2)\n\t{\n\t\tspi_bus_config_t spi_config = {};\n\t\tspi_config.miso_io_num = 19;\n\t\tspi_config.mosi_io_num = 23;\n\t\tspi_config.sclk_io_num = 18;\n\t\tspi_config.quadwp_io_num = -1;\n\t\tspi_config.quadhd_io_num = -1;\n\t\tspi_config.max_transfer_sz = 0;\n\t\tESP_ERROR_CHECK(spi_bus_initialize(SPI3_HOST, &spi_config, 0));\n\t} else\n\t{\n\t\treturn -1;\n\t}\n\tspi_device_interface_config_t devcfg = {};\n\tmemset(&devcfg,0,sizeof(devcfg));\n\tif (spi->CPHA == 0)\n\t{\n\t\tif (spi->CPOL == 0)\n\t\t{\n\t\t\tdevcfg.mode = 0;\n\t\t} else if (spi->CPOL == 1)\n\t\t{\n\t\t\tdevcfg.mode = 1;\n\t\t}\n\t}\n\tif (spi->CPHA == 1)\n\t{\n\t\tif (spi->CPOL == 0)\n\t\t{\n\t\t\tdevcfg.mode = 2;\n\t\t} else if (spi->CPOL == 1)\n\t\t{\n\t\t\tdevcfg.mode = 3;\n\t\t}\n\t}\n\n\tif (spi->bit_dict == 2)\n\t{\n\t\tdevcfg.flags = SPI_DEVICE_BIT_LSBFIRST;\n\t}\n\tdevcfg.cs_ena_pretrans = 1;\n\tdevcfg.clock_speed_hz = spi->bandrate;\n\tluat_log_log(1, LUAT_LOG_TAG, \"CS:%d\\n\", spi->cs);\n\t//\u9ed8\u8ba4\u65e0 \u503c255\n\tif (spi->cs == 255)\n\t\tspi->cs = spi->id == 1 ? 15 : 5;\n\tdevcfg.spics_io_num = spi->cs;\n\tdevcfg.input_delay_ns = 0;\n\tdevcfg.queue_size = 6;\n\tif (spi_bus_add_device(spi->id, &devcfg, &spi_h) != ESP_OK)\n\t\treturn -1;\n\tgpio_set_level(spi->cs, 1);\n\treturn 0;\n}", "item_id": 1, "repo": "slightc/luatos_esp32_pio", "file": "components/luat/port/luat_spi_esp32.c", "last_update_at": "2021-10-06T09:33:55+00:00", "question_id": "59ea005d0c4bd37eff2d51f7e3d9925c14aa3618_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int luat_spi_setup(luat_spi_t *spi)\n{\n\t// SPI2_HOST = 1\n\t// SPI3_HOST = 2\n\tif (spi->id == 1)\n\t{\n\t\tspi_bus_config_t spi_config = {};\n\t\tspi_config.miso_io_num = 12;\n\t\tspi_config.mosi_io_num = 13;\n\t\tspi_config.sclk_io_num = 14;\n\t\tspi_config.quadwp_io_num = -1;\n\t\tspi_config.quadhd_io_num = -1;\n\t\tspi_config.max_transfer_sz = 0;\n\t\tESP_ERROR_CHECK(spi_bus_initialize(SPI2_HOST, &spi_config, 0));\n\t} else if (spi->id == 2)\n\t{\n\t\tspi_bus_config_t spi_config = {};\n\t\tspi_config.miso_io_num = 19;\n\t\tspi_config.mosi_io_num = 23;\n\t\tspi_config.sclk_io_num = 18;\n\t\tspi_config.quadwp_io_num = -1;\n\t\tspi_config.quadhd_io_num = -1;\n\t\tspi_config.max_transfer_sz = 0;\n\t\tESP_ERROR_CHECK(spi_bus_initialize(SPI3_HOST, &spi_config, 0));\n\t} else\n\t{\n\t\treturn -1;\n\t}\n\tspi_device_interface_config_t devcfg = {};\n\tmemset(&devcfg,0,sizeof(devcfg));\n\tif (spi->CPHA == 0)\n\t{\n\t\tif (spi->CPOL == 0)\n\t\t{\n\t\t\tdevcfg.mode = 0;\n\t\t} else if (spi->CPOL == 1)\n\t\t{\n\t\t\tdevcfg.mode = 1;\n\t\t}\n\t}\n\tif (spi->CPHA == 1)\n\t{\n\t\tif (spi->CPOL == 0)\n\t\t{\n\t\t\tdevcfg.mode = 2;\n\t\t} else if (spi->CPOL == 1)\n\t\t{\n\t\t\tdevcfg.mode = 3;\n\t\t}\n\t}\n\tif (spi->bit_dict == 2)\n\t{\n\t\tdevcfg.flags = SPI_DEVICE_BIT_LSBFIRST;\n\t}\n\tdevcfg.cs_ena_pretrans = 1;\n\tdevcfg.clock_speed_hz = spi->bandrate;\n\tluat_log_log(1, LUAT_LOG_TAG, \"CS:%d\\n\", spi->cs);\n\t//\u9ed8\u8ba4\u65e0 \u503c255\n\tif (spi->cs == 255)\n\t\tspi->cs = spi->id == 1 ? 15 : 5;\n\tdevcfg.spics_io_num = spi->cs;\n\tdevcfg.input_delay_ns = 0;\n\tdevcfg.queue_size = 6;\n\tif (spi_bus_add_device(spi->id, &devcfg, &spi_h) != ESP_OK)\n\t\treturn -1;\n\tgpio_set_level(spi->cs, 1);\n\treturn 0;\n"]]}
{"hexsha": "0499c9a6a1303fbee61a70d5cada12a310d0fe95", "ext": "c", "lang": "C", "content": "void f3(void) {\n    \tvolatile int8_t x365 = INT8_MIN;\n\tuint8_t x366 = 2U;\n\tvolatile int32_t x368 = INT32_MAX;\n\tstatic volatile int32_t t3 = -21;\n\n    t3 = (((x365%x366)<<x367)*x368);\n\n    if (t3 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 3, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test857.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "0499c9a6a1303fbee61a70d5cada12a310d0fe95_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f3(void) {\n    \tvolatile int8_t x365 = INT8_MIN;\n\tuint8_t x366 = 2U;\n\tvolatile int32_t x368 = INT32_MAX;\n\tstatic volatile int32_t t3 = -21;\n    t3 = (((x365%x366)<<x367)*x368);\n    if (t3 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "ca6f582625d30642463fd269eea974b4b8b6e2e9", "ext": "c", "lang": "C", "content": "bool\ngfc_check_atan2 (gfc_expr *y, gfc_expr *x)\n{\n  if (!type_check (y, 0, BT_REAL))\n    return false;\n  if (!same_type_check (y, 0, x, 1))\n    return false;\n\n  return true;\n}", "item_id": 38, "repo": "TheSledgeHammer/2.11BSD", "file": "contrib/gnu/gcc/dist/gcc/fortran/check.c", "last_update_at": "2021-10-04T07:19:26+00:00", "question_id": "ca6f582625d30642463fd269eea974b4b8b6e2e9_38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool\ngfc_check_atan2 (gfc_expr *y, gfc_expr *x)\n{\n  if (!type_check (y, 0, BT_REAL))\n    return false;\n  if (!same_type_check (y, 0, x, 1))\n    return false;\n  return true;\n"]]}
{"hexsha": "f3959a5340971528f9bb6cfdb863b5d1cb2e13ba", "ext": "c", "lang": "C", "content": "void f93(void) {\n    \tvolatile int16_t x385 = -1;\n\tint64_t x386 = -125003901LL;\n\tstatic int32_t t93 = 453;\n\n    t93 = (((x385/x386)|x387)!=x388);\n\n    if (t93 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 93, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test763.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "f3959a5340971528f9bb6cfdb863b5d1cb2e13ba_93", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f93(void) {\n    \tvolatile int16_t x385 = -1;\n\tint64_t x386 = -125003901LL;\n\tstatic int32_t t93 = 453;\n    t93 = (((x385/x386)|x387)!=x388);\n    if (t93 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "5fe1015b037f7bf90e85ccbb1f347a00399c939a", "ext": "c", "lang": "C", "content": "LRESULT\r\nCALLBACK\r\nTextViewProc (\r\n    HWND hwnd,\r\n    UINT uMsg,\r\n    WPARAM wParam,\r\n    LPARAM lParam\r\n    )\r\n{\r\n    PAINTSTRUCT ps;\r\n    HDC hdc;\r\n    TEXTMETRIC tm;\r\n    SCROLLINFO si;\r\n    RECT rect;\r\n    RECT FillRect;\r\n    UINT Pos;\r\n    UINT End;\r\n    INT x, y;\r\n    INT i;\r\n    PCTSTR TrueStart, Start, Last;\r\n    PCTSTR p, q;\r\n    UINT Tchars;\r\n    CHARTYPE Char, Command;\r\n    UINT PrevHangingIndent;\r\n    SIZE Extent;\r\n    PLINEATTRIBS LineAttribs;\r\n    PLINEATTRIBS PrevLineAttribs;\r\n    HPEN OldPen;\r\n    HBRUSH FillBrush;\r\n    HPEN ShadowPen;\r\n    HPEN HighlightPen;\r\n    PTEXTVIEW_STATE s;\r\n    UINT LineHeight;\r\n    PHOTLINK HotLink;\r\n    BOOL Hot;\r\n    RECT HotRect;\r\n    PCTSTR UrlLink;\r\n    PCTSTR BookmarkLink;\r\n    PTSTR CommandBuf;\r\n    PCTSTR Arg;\r\n    TCHAR Href[MAX_URL];\r\n    PTSTR AnchorKey;\r\n    PTSTR AnchorVal;\r\n    UINT Count;\r\n    HKEY TempKey;\r\n    DWORD GrowListSize;\r\n    PCTSTR ShellArgs;\r\n    LONG l;\r\n    BOOL b;\r\n    PTSTR text;\r\n    UINT textSize;\r\n    BOOL printableFound;\r\n    TCHAR oneChar;\r\n\r\n    s = (PTEXTVIEW_STATE) GetWindowLong (hwnd, GWL_USERDATA);\r\n    if (s) {\r\n        LineHeight = s->LineHeight;\r\n    } else {\r\n        LineHeight = 0;\r\n    }\r\n\r\n    switch (uMsg) {\r\n\r\n    case WM_CREATE:\r\n        for (i = 0 ; g_TagList[i].Text ; i++) {\r\n            g_TagList[i].TextLen = TcharCount (g_TagList[i].Text);\r\n        }\r\n\r\n        s = (PTEXTVIEW_STATE) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (TEXTVIEW_STATE));\r\n        SetWindowLong (hwnd, GWL_USERDATA, (LONG) s);\r\n\r\n        TempKey = OpenRegKeyStr (TEXT(\"HKCR\\\\.URL\"));\r\n        if (TempKey) {\r\n            CloseRegKey (TempKey);\r\n        }\r\n\r\n        s->UrlEnabled = (TempKey != NULL);\r\n\r\n        ZeroMemory (&si, sizeof (si));\r\n        si.fMask = SIF_RANGE;\r\n\r\n        s->BookmarkTable = HtAllocWithData (sizeof (DWORD));\r\n        if (!s->BookmarkTable) {\r\n            return -1;\r\n        }\r\n\r\n        // WM_SETFONT does a bunch of work, including populating the text\r\n        SendMessage (\r\n            hwnd,\r\n            WM_SETFONT,\r\n            SendMessage (GetParent (hwnd), WM_GETFONT, 0, 0),\r\n            0\r\n            );\r\n\r\n        return 0;\r\n\r\n    case WM_GETDLGCODE:\r\n        return DLGC_WANTARROWS;\r\n\r\n    case WMX_GOTO:\r\n        //\r\n        // Determine if text is in bookmark table\r\n        //\r\n\r\n        if (!lParam) {\r\n            return 0;\r\n        }\r\n\r\n        if (HtFindStringAndData (s->BookmarkTable, (PCTSTR) lParam, &Pos)) {\r\n\r\n            PostMessage (\r\n                hwnd,\r\n                WM_VSCROLL,\r\n                MAKELPARAM (SB_THUMBPOSITION, (WORD) Pos),\r\n                (LPARAM) hwnd\r\n                );\r\n\r\n        }\r\n\r\n        return 0;\r\n\r\n\r\n    case WMX_ADDLINE:\r\n        //\r\n        // Init\r\n        //\r\n\r\n        l = GetWindowLong (hwnd, GWL_STYLE) & WS_BORDER;\r\n        if (!l) {\r\n            l = GetWindowLong (hwnd, GWL_EXSTYLE) & (WS_EX_DLGMODALFRAME|WS_EX_WINDOWEDGE|WS_EX_CLIENTEDGE|WS_EX_STATICEDGE);\r\n        }\r\n\r\n        if (!s->Margin && l) {\r\n            s->Margin = s->LineHeight / 2;\r\n        }\r\n\r\n        Start = (PCTSTR) lParam;\r\n\r\n        // ignore leading space\r\n        TrueStart = Start;\r\n\r\n        while (_istspace (_tcsnextc (Start))) {\r\n            Start = _tcsinc (Start);\r\n        }\r\n\r\n        PrevLineAttribs = NULL;\r\n        if (s->AttribsList.End) {\r\n            MYASSERT (s->AttribsList.End >= sizeof (LINEATTRIBS));\r\n            PrevLineAttribs = (PLINEATTRIBS) (s->AttribsList.Buf +\r\n                                              s->AttribsList.End -\r\n                                              sizeof (LINEATTRIBS)\r\n                                              );\r\n        }\r\n\r\n        //\r\n        // Copy line attributes (optional) to our Attribs list; ignore errors.\r\n        //\r\n\r\n        LineAttribs = (PLINEATTRIBS) GrowBuffer (&s->AttribsList, sizeof (LINEATTRIBS));\r\n        if (!LineAttribs) {\r\n            return 0;\r\n        }\r\n\r\n        //\r\n        // Copy previous line's attributes\r\n        //\r\n\r\n        ZeroMemory (LineAttribs, sizeof (LINEATTRIBS));\r\n\r\n        if (PrevLineAttribs) {\r\n            LineAttribs->AnchorWrap    = PrevLineAttribs->AnchorWrap;\r\n            LineAttribs->Indent        = PrevLineAttribs->Indent;\r\n            LineAttribs->HangingIndent = PrevLineAttribs->HangingIndent;\r\n            PrevHangingIndent = PrevLineAttribs->HangingIndent;\r\n        } else {\r\n            LineAttribs->Indent = s->Margin;\r\n            LineAttribs->HangingIndent = 0;\r\n            PrevHangingIndent = 0;\r\n        }\r\n\r\n        x = LineAttribs->Indent + PrevHangingIndent;\r\n\r\n        //\r\n        // Find the first character that does not fit on the line\r\n        //\r\n\r\n        Last = pFindFirstCharThatDoesNotFit (\r\n                    s->Margin,\r\n                    &s->List,\r\n                    &s->AttribsList,\r\n                    s->BookmarkTable,\r\n                    hwnd,\r\n                    s->hFontNormal,\r\n                    s->hFontBold,\r\n                    s->hFontUnderlined,\r\n                    Start,\r\n                    (INT) x,\r\n                    &tm,\r\n                    &rect,\r\n                    LineAttribs,\r\n                    &s->ParseState\r\n                    );\r\n\r\n        //\r\n        // Update the vertical scroll bar\r\n        //\r\n\r\n        MYASSERT (LineHeight);\r\n\r\n        ZeroMemory (&si, sizeof (si));\r\n        si.cbSize = sizeof (si);\r\n        si.fMask = SIF_RANGE|SIF_PAGE;\r\n        si.nMin = 0;\r\n        si.nPage = rect.bottom / LineHeight;\r\n        si.nMax = GrowListGetSize (&s->List);\r\n\r\n        SetScrollInfo (hwnd, SB_VERT, &si, TRUE);\r\n\r\n        //\r\n        // Copy the string (or as much that is visible) to our\r\n        // grow list\r\n        //\r\n\r\n        GrowListAppendStringAB (&s->List, Start, Last);\r\n\r\n        //\r\n        // Return the number of bytes copied\r\n        //\r\n\r\n        return Last - TrueStart;\r\n\r\n    case WMX_ALL_LINES_PAINTED:\r\n        //\r\n        // Scan all the lines, returning 0 if at least one has Painted == FALSE\r\n        //\r\n\r\n        LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf;\r\n        if (!LineAttribs) {\r\n            return 1;\r\n        }\r\n\r\n        for (Pos = 0 ; Pos < s->AttribsList.End ; Pos += sizeof (LINEATTRIBS)) {\r\n            LineAttribs = (PLINEATTRIBS) (s->AttribsList.Buf + Pos);\r\n            if (!LineAttribs->Painted) {\r\n                return 0;\r\n            }\r\n        }\r\n\r\n        return 1;\r\n\r\n    case WM_ERASEBKGND:\r\n        return 0;\r\n\r\n    case WM_KEYDOWN:\r\n        switch (wParam) {\r\n        case VK_DOWN:\r\n            PostMessage (hwnd, WM_VSCROLL, SB_LINEDOWN, 0);\r\n            return 0;\r\n\r\n        case VK_UP:\r\n            PostMessage (hwnd, WM_VSCROLL, SB_LINEUP, 0);\r\n            return 0;\r\n\r\n        case VK_NEXT:\r\n            PostMessage (hwnd, WM_VSCROLL, SB_PAGEDOWN, 0);\r\n            return 0;\r\n\r\n        case VK_PRIOR:\r\n            PostMessage (hwnd, WM_VSCROLL, SB_PAGEUP, 0);\r\n            return 0;\r\n\r\n        case VK_HOME:\r\n            PostMessage (hwnd, WM_VSCROLL, SB_TOP, 0);\r\n            return 0;\r\n\r\n        case VK_END:\r\n            PostMessage (hwnd, WM_VSCROLL, SB_BOTTOM, 0);\r\n            return 0;\r\n        }\r\n\r\n        break;\r\n\r\n\r\n    case WM_SETFONT:\r\n        s->hFont = (HFONT) wParam;\r\n\r\n        if (s->hFontNormal) {\r\n            DeleteObject (s->hFontNormal);\r\n            s->hFontNormal = NULL;\r\n        }\r\n\r\n        if (s->hFontBold) {\r\n            DeleteObject (s->hFontBold);\r\n            s->hFontBold = NULL;\r\n        }\r\n\r\n        if (s->hFontUnderlined) {\r\n            DeleteObject (s->hFontUnderlined);\r\n            s->hFontUnderlined = NULL;\r\n        }\r\n\r\n        hdc = CreateDC (TEXT(\"display\"), NULL, NULL, NULL);\r\n        if (hdc) {\r\n            pCreateFontsIfNecessary (hdc, s->hFont, &tm, &s->hFontNormal, &s->hFontBold, &s->hFontUnderlined);\r\n            s->LineHeight = tm.tmHeight;\r\n\r\n            DeleteDC (hdc);\r\n        } else {\r\n            s->LineHeight = 0;\r\n        }\r\n\r\n        if (lParam) {\r\n            InvalidateRect (hwnd, NULL, FALSE);\r\n        }\r\n\r\n        if (s->AttribsList.End == 0) {\r\n            textSize = GetWindowTextLength (hwnd);\r\n            text = (PTSTR) MemAllocUninit ((textSize + 1) * sizeof (TCHAR));\r\n            GetWindowText (hwnd, text, textSize + 1);\r\n            AddStringToTextView (hwnd, text);\r\n            FreeMem (text);\r\n        }\r\n\r\n        return 0;\r\n\r\n\r\n    case WM_MOUSEMOVE:\r\n        //\r\n        // Search array of hit test rectangles\r\n        //\r\n\r\n        x = LOWORD(lParam);\r\n        y = HIWORD(lParam);\r\n\r\n        HotLink = pFindHotLink (&s->HotLinkArray, x, y);\r\n\r\n        if (HotLink) {\r\n            SetCursor (LoadCursor (g_hInst, MAKEINTRESOURCE (IDC_OUR_HAND)));\r\n        } else {\r\n            SetCursor (LoadCursor (NULL, MAKEINTRESOURCE (IDC_ARROW)));\r\n        }\r\n\r\n        break;\r\n\r\n    case WM_LBUTTONDOWN:\r\n        //\r\n        // Search array of hit test rectangles\r\n        //\r\n\r\n        x = LOWORD(lParam);\r\n        y = HIWORD(lParam);\r\n\r\n        HotLink = pFindHotLink (&s->HotLinkArray, x, y);\r\n\r\n        if (HotLink) {\r\n            if (HotLink->Url[0]) {\r\n                if (!StringIMatchTcharCount (TEXT(\"file:\"), HotLink->Url, 5)) {\r\n                    ShellExecute (hwnd, TEXT(\"open\"), HotLink->Url, NULL, NULL, 0);\r\n                } else {\r\n                    ShellArgs = &HotLink->Url[5];\r\n                    if (*ShellArgs == TEXT('/')) {\r\n                        ShellArgs++;\r\n                    }\r\n                    if (*ShellArgs == TEXT('/')) {\r\n                        ShellArgs++;\r\n                    }\r\n\r\n                    ShellArgs = ExtractArgZero (ShellArgs, Href);\r\n                    //\r\n                    // if we're launching the Add/Remove programs applet,\r\n                    // warn users they'll have to restart setup (RAID # 293357)\r\n                    //\r\n                    b = TRUE;\r\n                    if (!UNATTENDED() &&\r\n                        !REPORTONLY() &&\r\n                        !g_UIQuitSetup &&\r\n                        pLaunchedAddRemovePrograms (ShellArgs)\r\n                        ) {\r\n                        if (IDYES == ResourceMessageBox (\r\n                                        hwnd,\r\n                                        MSG_RESTART_IF_CONTINUE_APPWIZCPL,\r\n                                        MB_YESNO | MB_ICONQUESTION,\r\n                                        NULL\r\n                                        )) {\r\n                            LOG ((LOG_INFORMATION, \"User launched Add/Remove Programs applet; setup will terminate\"));\r\n                            PostMessage (GetParent (hwnd), WMX_RESTART_SETUP, FALSE, TRUE);\r\n                        } else {\r\n                            b = FALSE;\r\n                        }\r\n                    }\r\n                    if (b) {\r\n                        ShellExecute (hwnd, TEXT(\"open\"), Href, ShellArgs, NULL, 0);\r\n                    }\r\n                }\r\n            } else if (HotLink->Bookmark) {\r\n                SendMessage (hwnd, WMX_GOTO, 0, (LPARAM) HotLink->Bookmark);\r\n            }\r\n        }\r\n\r\n        break;\r\n\r\n    case WM_SETTEXT:\r\n        SendMessage (hwnd, WMX_CLEANUP, 0, 0);\r\n        DefWindowProc (hwnd, uMsg, wParam, lParam);\r\n        SendMessage (hwnd, WM_CREATE, 0, 0);\r\n        return 0;\r\n\r\n    case WM_PAINT:\r\n        FillBrush = CreateSolidBrush (GetSysColor (COLOR_BTNFACE));\r\n        ShadowPen = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_3DSHADOW));\r\n        HighlightPen = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_3DHILIGHT));\r\n\r\n        hdc = BeginPaint (hwnd, &ps);\r\n        pCreateFontsIfNecessary (hdc, s->hFont, &tm, &s->hFontNormal, &s->hFontBold, &s->hFontUnderlined);\r\n        s->LineHeight = LineHeight = tm.tmHeight;\r\n        GetClientRect (hwnd, &rect);\r\n\r\n        //\r\n        // Select colors\r\n        //\r\n\r\n        SetBkColor (hdc, GetSysColor (COLOR_BTNFACE));\r\n        SetTextColor (hdc, GetSysColor (COLOR_WINDOWTEXT));\r\n\r\n        if (FillBrush) {\r\n            SelectObject (hdc, FillBrush);\r\n        }\r\n\r\n        SelectObject (hdc, GetStockObject (NULL_PEN));\r\n\r\n        //\r\n        // Get scroll position\r\n        //\r\n\r\n        ZeroMemory (&si, sizeof (si));\r\n        si.cbSize = sizeof (si);\r\n        si.fMask = SIF_PAGE|SIF_POS;\r\n        GetScrollInfo (hwnd, SB_VERT, &si);\r\n\r\n        End = (UINT) si.nPos + si.nPage + 1;\r\n        GrowListSize = GrowListGetSize (&s->List);\r\n        End = min (End, GrowListSize);\r\n        y = 0;\r\n\r\n        //\r\n        // Select font of previous line.  Move up if anchor wrap is on.\r\n        //\r\n\r\n        if (si.nPos) {\r\n            do {\r\n                LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf + (si.nPos - 1);\r\n                if (LineAttribs->AnchorWrap) {\r\n                    si.nPos--;\r\n                    y -= LineHeight;\r\n                } else {\r\n                    break;\r\n                }\r\n            } while (si.nPos > 0);\r\n        }\r\n\r\n        if (si.nPos) {\r\n            LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf + (si.nPos - 1);\r\n\r\n            if (LineAttribs->LastCharAttribs == ATTRIB_BOLD) {\r\n                SelectObject (hdc, s->hFontBold);\r\n            } else if (LineAttribs->LastCharAttribs == ATTRIB_UNDERLINED) {\r\n                SelectObject (hdc, s->hFontUnderlined);\r\n            } else {\r\n                SelectObject (hdc, s->hFontNormal);\r\n            }\r\n        } else {\r\n            SelectObject (hdc, s->hFontNormal);\r\n        }\r\n\r\n        //\r\n        // Paint!\r\n        //\r\n\r\n        Hot = FALSE;\r\n        s->HotLinkArray.End = 0;\r\n        BookmarkLink = UrlLink = NULL;\r\n\r\n        for (Pos = (UINT) si.nPos ; Pos < End ; Pos++) {\r\n            p = GrowListGetString (&s->List, Pos);\r\n            printableFound = FALSE;\r\n\r\n            LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf + Pos;\r\n\r\n            //\r\n            // Compute hanging indent using previous line\r\n            //\r\n\r\n            if (Pos > 0) {\r\n                PrevLineAttribs = (PLINEATTRIBS) ((PLINEATTRIBS) s->AttribsList.Buf + Pos - 1);\r\n                PrevHangingIndent = PrevLineAttribs->HangingIndent;\r\n            } else {\r\n                PrevHangingIndent = 0;\r\n            }\r\n\r\n            //\r\n            // Compute starting index\r\n            //\r\n\r\n            if (LineAttribs) {\r\n                x = LineAttribs->Indent + PrevHangingIndent;\r\n                LineAttribs->Painted = TRUE;\r\n            } else {\r\n                x = s->Margin;\r\n            }\r\n\r\n            //\r\n            // Compute blank area\r\n            //\r\n\r\n            if (x > 0) {\r\n                FillRect.left = 0;\r\n                FillRect.right = x;\r\n                FillRect.top = y;\r\n                FillRect.bottom = y + LineHeight;\r\n\r\n                Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);\r\n            }\r\n\r\n            //\r\n            // Multiline hotlink\r\n            //\r\n\r\n            if (Hot) {\r\n                HotRect.left = x;\r\n                HotRect.top = y;\r\n            }\r\n\r\n            //\r\n            // Compute text block\r\n            //\r\n\r\n            Start = p;\r\n\r\n            while (p) {\r\n                q = pGetHtmlCommandOrChar (p, &Command, &Char, &CommandBuf);\r\n\r\n                if (!Char || Command == COMMAND_WHITESPACE || Command == COMMAND_ESCAPED_CHAR) {\r\n                    //\r\n                    // If this is the end of of a block of text, paint it.\r\n                    //\r\n\r\n                    MYASSERT (Start);\r\n\r\n                    Tchars = p - Start;\r\n\r\n                    if (Tchars) {\r\n                        TextOut (hdc, x, y, Start, Tchars);\r\n                        GetTextExtentPoint32 (hdc, Start, Tchars, &Extent);\r\n\r\n                        x += Extent.cx;\r\n                        if (x > rect.right) {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    Start = q;\r\n                    oneChar = 0;\r\n\r\n                    if (printableFound && Command == COMMAND_WHITESPACE) {\r\n                        oneChar = TEXT(' ');\r\n                    } else if (Command == COMMAND_ESCAPED_CHAR) {\r\n                        oneChar = (TCHAR) Char;\r\n                    }\r\n\r\n                    if (oneChar) {\r\n\r\n                        TextOut (hdc, x, y, &oneChar, 1);\r\n                        GetTextExtentPoint32 (hdc, &oneChar, 1, &Extent);\r\n\r\n                        x += Extent.cx;\r\n                        if (x > rect.right) {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                } else {\r\n                    printableFound = TRUE;\r\n                }\r\n\r\n                switch (Command) {\r\n                case 0:\r\n                case COMMAND_WHITESPACE:\r\n                case COMMAND_ESCAPED_CHAR:\r\n                    break;\r\n\r\n                case COMMAND_ANCHOR:\r\n                    //\r\n                    // Does this anchor have an HREF?\r\n                    //\r\n\r\n                    if (CommandBuf) {\r\n                        Arg = CommandBuf;\r\n\r\n                        Href[0] = 0;\r\n\r\n                        while (Href[0] == 0 && *Arg) {\r\n                            //\r\n                            // Search for a HREF arg\r\n                            //\r\n\r\n                            Count = TcharCount (Arg);\r\n                            AnchorKey = AllocText (Count);\r\n                            AnchorVal = AllocText (Count);\r\n\r\n                            if (!AnchorKey || !AnchorVal) {\r\n                                FreeText (AnchorKey);\r\n                                FreeText (AnchorVal);\r\n                                break;\r\n                            }\r\n\r\n                            pGetHtmlKeyAndValue (Arg, AnchorKey, AnchorVal);\r\n\r\n                            if (StringIMatch (TEXT(\"HREF\"), AnchorKey)) {\r\n                                _tcssafecpy (Href, AnchorVal, MAX_URL);\r\n                            }\r\n\r\n                            FreeText (AnchorKey);\r\n                            FreeText (AnchorVal);\r\n\r\n                            Arg += Count + 1;\r\n                        }\r\n\r\n                        if (Href[0]) {\r\n                            //\r\n                            // Does HREF point to a bookmark?\r\n                            //\r\n\r\n                            BookmarkLink = UrlLink = NULL;\r\n\r\n                            if (_tcsnextc (Href) == TEXT('#')) {\r\n                                BookmarkLink = SkipSpace (_tcsinc (Href));\r\n                            } else {\r\n                                if (s->UrlEnabled) {\r\n                                    UrlLink = Href;\r\n                                }\r\n                            }\r\n\r\n                            //\r\n                            // If either BookmarkLink or Url is non-NULL, then turn on\r\n                            // link font and color\r\n                            //\r\n\r\n                            if (BookmarkLink || UrlLink) {\r\n                                HotRect.left = x;\r\n                                HotRect.top = y;\r\n                                Hot = TRUE;\r\n\r\n                                SelectObject (hdc, s->hFontUnderlined);\r\n                                SetTextColor (hdc, GetSysColor (COLOR_HIGHLIGHT));\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    break;\r\n\r\n                case COMMAND_BOLD:\r\n                    SelectObject (hdc, s->hFontBold);\r\n                    break;\r\n\r\n                case COMMAND_UNDERLINE:\r\n                    SelectObject (hdc, s->hFontUnderlined);\r\n                    break;\r\n\r\n                case COMMAND_HORZ_RULE:\r\n                    FillRect.left = rect.left;\r\n                    FillRect.right = rect.right;\r\n                    FillRect.top = y;\r\n                    FillRect.bottom = y + LineHeight;\r\n\r\n                    Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);\r\n\r\n                    OldPen = (HPEN) SelectObject (hdc, ShadowPen);\r\n                    MoveToEx (hdc, rect.left + 3, y + LineHeight / 2, NULL);\r\n                    LineTo (hdc, rect.right - 3, y + LineHeight / 2);\r\n                    SelectObject (hdc, HighlightPen);\r\n                    MoveToEx (hdc, rect.left + 3, y + LineHeight / 2 + 1, NULL);\r\n                    LineTo (hdc, rect.right - 3, y + LineHeight / 2 + 1);\r\n                    SelectObject (hdc, OldPen);\r\n\r\n                    x = rect.right;\r\n                    break;\r\n\r\n                case COMMAND_ANCHOR_END:\r\n                    SelectObject (hdc, s->hFontNormal);\r\n                    SetTextColor (hdc, GetSysColor (COLOR_WINDOWTEXT));\r\n\r\n                    if (Hot) {\r\n                        Hot = FALSE;\r\n                        HotRect.right = x;\r\n                        HotRect.bottom = y + LineHeight;\r\n\r\n                        pRegisterHotLink (&s->HotLinkArray, &HotRect, UrlLink, BookmarkLink);\r\n                    }\r\n                    break;\r\n\r\n                case COMMAND_BOLD_END:\r\n                case COMMAND_UNDERLINE_END:\r\n                    SelectObject (hdc, s->hFontNormal);\r\n                    break;\r\n                }\r\n\r\n                FreePathString (CommandBuf);\r\n\r\n                p = q;\r\n            }\r\n\r\n            //\r\n            // Hot link that extends to multiple lines\r\n            //\r\n\r\n            if (Hot) {\r\n                HotRect.right = x;\r\n                HotRect.bottom = y + LineHeight;\r\n                pRegisterHotLink (&s->HotLinkArray, &HotRect, UrlLink, BookmarkLink);\r\n            }\r\n\r\n            //\r\n            // Fill blank area to end of line\r\n            //\r\n\r\n            if (x < rect.right) {\r\n                FillRect.left = x;\r\n                FillRect.right = rect.right;\r\n                FillRect.top = y;\r\n                FillRect.bottom = y + LineHeight;\r\n\r\n                Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);\r\n            }\r\n\r\n            y += LineHeight;\r\n        }\r\n\r\n        //\r\n        // Fill blank area to bottom of window\r\n        //\r\n\r\n        if (y < rect.bottom) {\r\n             FillRect.left = 0;\r\n             FillRect.right = rect.right;\r\n             FillRect.top = y;\r\n             FillRect.bottom = rect.bottom;\r\n\r\n             Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);\r\n        }\r\n\r\n        //\r\n        // Cleanup\r\n        //\r\n\r\n        if (FillBrush) {\r\n            DeleteObject (FillBrush);\r\n        }\r\n\r\n        if (ShadowPen) {\r\n            DeleteObject (ShadowPen);\r\n            ShadowPen = NULL;\r\n        }\r\n\r\n        if (HighlightPen) {\r\n            DeleteObject (HighlightPen);\r\n            HighlightPen = NULL;\r\n        }\r\n\r\n        EndPaint (hwnd, &ps);\r\n        return 0;\r\n\r\n    case WM_VSCROLL:\r\n        Pos = HIWORD (wParam);\r\n\r\n        ZeroMemory (&si, sizeof (si));\r\n        si.cbSize = sizeof (si);\r\n        si.fMask = SIF_ALL;\r\n        GetScrollInfo (hwnd, SB_VERT, &si);\r\n        i = si.nMax - (INT) si.nPage + 1;\r\n\r\n        si.fMask = 0;\r\n\r\n        switch (LOWORD (wParam)) {\r\n        case SB_PAGEDOWN:\r\n            if (si.nPos + (INT) si.nPage < i) {\r\n                si.nPos += si.nPage;\r\n                ScrollWindow (hwnd, 0, -((INT) LineHeight * (INT) si.nPage), NULL, NULL);\r\n                si.fMask = SIF_POS;\r\n                break;\r\n            }\r\n\r\n            // fall through!\r\n\r\n        case SB_BOTTOM:\r\n            if (si.nPos < i) {\r\n                InvalidateRect (hwnd, NULL, FALSE);\r\n                si.nPos = i;\r\n                si.fMask = SIF_POS;\r\n            }\r\n            break;\r\n\r\n        case SB_LINEDOWN:\r\n            if (si.nPos < i) {\r\n                si.nPos += 1;\r\n                ScrollWindow (hwnd, 0, -((INT) LineHeight), NULL, NULL);\r\n                si.fMask = SIF_POS;\r\n            }\r\n\r\n            break;\r\n\r\n        case SB_LINEUP:\r\n            if (si.nPos > si.nMin) {\r\n                si.nPos -= 1;\r\n                ScrollWindow (hwnd, 0, (INT) LineHeight, NULL, NULL);\r\n                si.fMask = SIF_POS;\r\n            }\r\n\r\n            break;\r\n\r\n        case SB_THUMBTRACK:\r\n        case SB_THUMBPOSITION:\r\n            if ((INT) Pos != si.nPos) {\r\n                InvalidateRect (hwnd, NULL, FALSE);\r\n                si.nPos = (INT) Pos;\r\n                si.fMask = SIF_POS;\r\n            }\r\n            break;\r\n\r\n        case SB_PAGEUP:\r\n            if (si.nPos >= si.nMin + (INT) si.nPage) {\r\n                si.nPos -= si.nPage;\r\n                ScrollWindow (hwnd, 0, (INT) LineHeight * si.nPage, NULL, NULL);\r\n                si.fMask = SIF_POS;\r\n                break;\r\n            }\r\n\r\n            // fall through\r\n\r\n        case SB_TOP:\r\n            if (si.nPos > si.nMin) {\r\n                ScrollWindow (hwnd, 0, (INT) LineHeight * si.nPos, NULL, NULL);\r\n                si.nPos = si.nMin;\r\n                si.fMask = SIF_POS;\r\n            }\r\n            break;\r\n        }\r\n\r\n        if (si.fMask) {\r\n            SetScrollInfo (hwnd, SB_VERT, &si, TRUE);\r\n        }\r\n        break;\r\n\r\n    case WM_DESTROY:\r\n    case WMX_CLEANUP:\r\n        if (!g_Terminated) {\r\n            if (s) {\r\n                if (s->hFontNormal) {\r\n                    DeleteObject (s->hFontNormal);\r\n                    s->hFontNormal = NULL;\r\n                }\r\n\r\n                if (s->hFontBold) {\r\n                    DeleteObject (s->hFontBold);\r\n                    s->hFontBold = NULL;\r\n                }\r\n\r\n                if (s->hFontUnderlined) {\r\n                    DeleteObject (s->hFontUnderlined);\r\n                    s->hFontUnderlined = NULL;\r\n                }\r\n\r\n                FreeGrowBuffer (&s->AttribsList);\r\n                FreeGrowBuffer (&s->HotLinkArray);\r\n                FreeGrowList (&s->List);\r\n\r\n                if (s->BookmarkTable) {\r\n                    HtFree (s->BookmarkTable);\r\n                    s->BookmarkTable = NULL;\r\n                }\r\n\r\n                MemFree (g_hHeap, 0, s);\r\n                SetWindowLong (hwnd, GWL_USERDATA, 0);\r\n            }\r\n        }\r\n        break;\r\n\r\n    }\r\n\r\n    return DefWindowProc (hwnd, uMsg, wParam, lParam);\r\n}", "item_id": 9, "repo": "npocmaka/Windows-Server-2003", "file": "base/ntsetup/win95upg/w95upg/ui/textview.c", "last_update_at": "2021-09-16T09:13:13+00:00", "question_id": "5fe1015b037f7bf90e85ccbb1f347a00399c939a_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["LRESULT\r\nCALLBACK\r\nTextViewProc (\r\n    HWND hwnd,\r\n    UINT uMsg,\r\n    WPARAM wParam,\r\n    LPARAM lParam\r\n    )\r\n{\r\n    PAINTSTRUCT ps;\r\n    HDC hdc;\r\n    TEXTMETRIC tm;\r\n    SCROLLINFO si;\r\n    RECT rect;\r\n    RECT FillRect;\r\n    UINT Pos;\r\n    UINT End;\r\n    INT x, y;\r\n    INT i;\r\n    PCTSTR TrueStart, Start, Last;\r\n    PCTSTR p, q;\r\n    UINT Tchars;\r\n    CHARTYPE Char, Command;\r\n    UINT PrevHangingIndent;\r\n    SIZE Extent;\r\n    PLINEATTRIBS LineAttribs;\r\n    PLINEATTRIBS PrevLineAttribs;\r\n    HPEN OldPen;\r\n    HBRUSH FillBrush;\r\n    HPEN ShadowPen;\r\n    HPEN HighlightPen;\r\n    PTEXTVIEW_STATE s;\r\n    UINT LineHeight;\r\n    PHOTLINK HotLink;\r\n    BOOL Hot;\r\n    RECT HotRect;\r\n    PCTSTR UrlLink;\r\n    PCTSTR BookmarkLink;\r\n    PTSTR CommandBuf;\r\n    PCTSTR Arg;\r\n    TCHAR Href[MAX_URL];\r\n    PTSTR AnchorKey;\r\n    PTSTR AnchorVal;\r\n    UINT Count;\r\n    HKEY TempKey;\r\n    DWORD GrowListSize;\r\n    PCTSTR ShellArgs;\r\n    LONG l;\r\n    BOOL b;\r\n    PTSTR text;\r\n    UINT textSize;\r\n    BOOL printableFound;\r\n    TCHAR oneChar;\r\n\r\n    s = (PTEXTVIEW_STATE) GetWindowLong (hwnd, GWL_USERDATA);\r\n    if (s) {\r\n        LineHeight = s->LineHeight;\r\n    } else {\r\n        LineHeight = 0;\r\n    }\r\n\r\n    switch (uMsg) {\r\n\r\n    case WM_CREATE:\r\n        for (i = 0 ; g_TagList[i].Text ; i++) {\r\n            g_TagList[i].TextLen = TcharCount (g_TagList[i].Text);\r\n        }\r\n\r\n        s = (PTEXTVIEW_STATE) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (TEXTVIEW_STATE));\r\n        SetWindowLong (hwnd, GWL_USERDATA, (LONG) s);\r\n\r\n        TempKey = OpenRegKeyStr (TEXT(\"HKCR\\\\.URL\"));\r\n        if (TempKey) {\r\n            CloseRegKey (TempKey);\r\n        }\r\n\r\n        s->UrlEnabled = (TempKey != NULL);\r\n\r\n        ZeroMemory (&si, sizeof (si));\r\n        si.fMask = SIF_RANGE;\r\n\r\n        s->BookmarkTable = HtAllocWithData (sizeof (DWORD));\r\n        if (!s->BookmarkTable) {\r\n            return -1;\r\n        }\r\n\r\n        // WM_SETFONT does a bunch of work, including populating the text\r\n        SendMessage (\r\n            hwnd,\r\n            WM_SETFONT,\r\n            SendMessage (GetParent (hwnd), WM_GETFONT, 0, 0),\r\n            0\r\n            );\r\n\r\n        return 0;\r\n\r\n    case WM_GETDLGCODE:\r\n        return DLGC_WANTARROWS;\r\n\r\n    case WMX_GOTO:\r\n        //\r\n        // Determine if text is in bookmark table\r\n        //\r\n\r\n        if (!lParam) {\r\n            return 0;\r\n        }\r\n\r\n        if (HtFindStringAndData (s->BookmarkTable, (PCTSTR) lParam, &Pos)) {\r\n\r\n            PostMessage (\r\n                hwnd,\r\n                WM_VSCROLL,\r\n                MAKELPARAM (SB_THUMBPOSITION, (WORD) Pos),\r\n                (LPARAM) hwnd\r\n                );\r\n\r\n        }\r\n\r\n        return 0;\r\n\r\n\r\n    case WMX_ADDLINE:\r\n        //\r\n        // Init\r\n        //\r\n\r\n        l = GetWindowLong (hwnd, GWL_STYLE) & WS_BORDER;\r\n        if (!l) {\r\n            l = GetWindowLong (hwnd, GWL_EXSTYLE) & (WS_EX_DLGMODALFRAME|WS_EX_WINDOWEDGE|WS_EX_CLIENTEDGE|WS_EX_STATICEDGE);\r\n        }\r\n\r\n        if (!s->Margin && l) {\r\n            s->Margin = s->LineHeight / 2;\r\n        }\r\n\r\n        Start = (PCTSTR) lParam;\r\n\r\n        // ignore leading space\r\n        TrueStart = Start;\r\n\r\n        while (_istspace (_tcsnextc (Start))) {\r\n            Start = _tcsinc (Start);\r\n        }\r\n\r\n        PrevLineAttribs = NULL;\r\n        if (s->AttribsList.End) {\r\n            MYASSERT (s->AttribsList.End >= sizeof (LINEATTRIBS));\r\n            PrevLineAttribs = (PLINEATTRIBS) (s->AttribsList.Buf +\r\n                                              s->AttribsList.End -\r\n                                              sizeof (LINEATTRIBS)\r\n                                              );\r\n        }\r\n\r\n        //\r\n        // Copy line attributes (optional) to our Attribs list; ignore errors.\r\n        //\r\n\r\n        LineAttribs = (PLINEATTRIBS) GrowBuffer (&s->AttribsList, sizeof (LINEATTRIBS));\r\n        if (!LineAttribs) {\r\n            return 0;\r\n        }\r\n\r\n        //\r\n        // Copy previous line's attributes\r\n        //\r\n\r\n        ZeroMemory (LineAttribs, sizeof (LINEATTRIBS));\r\n\r\n        if (PrevLineAttribs) {\r\n            LineAttribs->AnchorWrap    = PrevLineAttribs->AnchorWrap;\r\n            LineAttribs->Indent        = PrevLineAttribs->Indent;\r\n            LineAttribs->HangingIndent = PrevLineAttribs->HangingIndent;\r\n            PrevHangingIndent = PrevLineAttribs->HangingIndent;\r\n        } else {\r\n            LineAttribs->Indent = s->Margin;\r\n            LineAttribs->HangingIndent = 0;\r\n            PrevHangingIndent = 0;\r\n        }\r\n\r\n        x = LineAttribs->Indent + PrevHangingIndent;\r\n\r\n        //\r\n        // Find the first character that does not fit on the line\r\n        //\r\n\r\n        Last = pFindFirstCharThatDoesNotFit (\r\n                    s->Margin,\r\n                    &s->List,\r\n                    &s->AttribsList,\r\n                    s->BookmarkTable,\r\n                    hwnd,\r\n                    s->hFontNormal,\r\n                    s->hFontBold,\r\n                    s->hFontUnderlined,\r\n                    Start,\r\n                    (INT) x,\r\n                    &tm,\r\n                    &rect,\r\n                    LineAttribs,\r\n                    &s->ParseState\r\n                    );\r\n\r\n        //\r\n        // Update the vertical scroll bar\r\n        //\r\n\r\n        MYASSERT (LineHeight);\r\n\r\n        ZeroMemory (&si, sizeof (si));\r\n        si.cbSize = sizeof (si);\r\n        si.fMask = SIF_RANGE|SIF_PAGE;\r\n        si.nMin = 0;\r\n        si.nPage = rect.bottom / LineHeight;\r\n        si.nMax = GrowListGetSize (&s->List);\r\n\r\n        SetScrollInfo (hwnd, SB_VERT, &si, TRUE);\r\n\r\n        //\r\n        // Copy the string (or as much that is visible) to our\r\n        // grow list\r\n        //\r\n\r\n        GrowListAppendStringAB (&s->List, Start, Last);\r\n\r\n        //\r\n        // Return the number of bytes copied\r\n        //\r\n\r\n        return Last - TrueStart;\r\n\r\n    case WMX_ALL_LINES_PAINTED:\r\n        //\r\n        // Scan all the lines, returning 0 if at least one has Painted == FALSE\r\n        //\r\n\r\n        LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf;\r\n        if (!LineAttribs) {\r\n            return 1;\r\n        }\r\n\r\n        for (Pos = 0 ; Pos < s->AttribsList.End ; Pos += sizeof (LINEATTRIBS)) {\r\n            LineAttribs = (PLINEATTRIBS) (s->AttribsList.Buf + Pos);\r\n            if (!LineAttribs->Painted) {\r\n                return 0;\r\n            }\r\n        }\r\n\r\n        return 1;\r\n\r\n    case WM_ERASEBKGND:\r\n        return 0;\r\n\r\n    case WM_KEYDOWN:\r\n        switch (wParam) {\r\n        case VK_DOWN:\r\n            PostMessage (hwnd, WM_VSCROLL, SB_LINEDOWN, 0);\r\n            return 0;\r\n\r\n        case VK_UP:\r\n            PostMessage (hwnd, WM_VSCROLL, SB_LINEUP, 0);\r\n            return 0;\r\n\r\n        case VK_NEXT:\r\n            PostMessage (hwnd, WM_VSCROLL, SB_PAGEDOWN, 0);\r\n            return 0;\r\n\r\n        case VK_PRIOR:\r\n            PostMessage (hwnd, WM_VSCROLL, SB_PAGEUP, 0);\r\n            return 0;\r\n\r\n        case VK_HOME:\r\n            PostMessage (hwnd, WM_VSCROLL, SB_TOP, 0);\r\n            return 0;\r\n\r\n        case VK_END:\r\n            PostMessage (hwnd, WM_VSCROLL, SB_BOTTOM, 0);\r\n            return 0;\r\n        }\r\n\r\n        break;\r\n\r\n\r\n    case WM_SETFONT:\r\n        s->hFont = (HFONT) wParam;\r\n\r\n        if (s->hFontNormal) {\r\n            DeleteObject (s->hFontNormal);\r\n            s->hFontNormal = NULL;\r\n        }\r\n\r\n        if (s->hFontBold) {\r\n            DeleteObject (s->hFontBold);\r\n            s->hFontBold = NULL;\r\n        }\r\n\r\n        if (s->hFontUnderlined) {\r\n            DeleteObject (s->hFontUnderlined);\r\n            s->hFontUnderlined = NULL;\r\n        }\r\n\r\n        hdc = CreateDC (TEXT(\"display\"), NULL, NULL, NULL);\r\n        if (hdc) {\r\n            pCreateFontsIfNecessary (hdc, s->hFont, &tm, &s->hFontNormal, &s->hFontBold, &s->hFontUnderlined);\r\n            s->LineHeight = tm.tmHeight;\r\n\r\n            DeleteDC (hdc);\r\n        } else {\r\n            s->LineHeight = 0;\r\n        }\r\n\r\n        if (lParam) {\r\n            InvalidateRect (hwnd, NULL, FALSE);\r\n        }\r\n\r\n        if (s->AttribsList.End == 0) {\r\n            textSize = GetWindowTextLength (hwnd);\r\n            text = (PTSTR) MemAllocUninit ((textSize + 1) * sizeof (TCHAR));\r\n            GetWindowText (hwnd, text, textSize + 1);\r\n            AddStringToTextView (hwnd, text);\r\n            FreeMem (text);\r\n        }\r\n\r\n        return 0;\r\n\r\n\r\n    case WM_MOUSEMOVE:\r\n        //\r\n        // Search array of hit test rectangles\r\n        //\r\n\r\n        x = LOWORD(lParam);\r\n        y = HIWORD(lParam);\r\n\r\n        HotLink = pFindHotLink (&s->HotLinkArray, x, y);\r\n\r\n        if (HotLink) {\r\n            SetCursor (LoadCursor (g_hInst, MAKEINTRESOURCE (IDC_OUR_HAND)));\r\n        } else {\r\n            SetCursor (LoadCursor (NULL, MAKEINTRESOURCE (IDC_ARROW)));\r\n        }\r\n\r\n        break;\r\n\r\n    case WM_LBUTTONDOWN:\r\n        //\r\n        // Search array of hit test rectangles\r\n        //\r\n\r\n        x = LOWORD(lParam);\r\n        y = HIWORD(lParam);\r\n\r\n        HotLink = pFindHotLink (&s->HotLinkArray, x, y);\r\n\r\n        if (HotLink) {\r\n            if (HotLink->Url[0]) {\r\n                if (!StringIMatchTcharCount (TEXT(\"file:\"), HotLink->Url, 5)) {\r\n                    ShellExecute (hwnd, TEXT(\"open\"), HotLink->Url, NULL, NULL, 0);\r\n                } else {\r\n                    ShellArgs = &HotLink->Url[5];\r\n                    if (*ShellArgs == TEXT('/')) {\r\n                        ShellArgs++;\r\n                    }\r\n                    if (*ShellArgs == TEXT('/')) {\r\n                        ShellArgs++;\r\n                    }\r\n\r\n                    ShellArgs = ExtractArgZero (ShellArgs, Href);\r\n                    //\r\n                    // if we're launching the Add/Remove programs applet,\r\n                    // warn users they'll have to restart setup (RAID # 293357)\r\n                    //\r\n                    b = TRUE;\r\n                    if (!UNATTENDED() &&\r\n                        !REPORTONLY() &&\r\n                        !g_UIQuitSetup &&\r\n                        pLaunchedAddRemovePrograms (ShellArgs)\r\n                        ) {\r\n                        if (IDYES == ResourceMessageBox (\r\n                                        hwnd,\r\n                                        MSG_RESTART_IF_CONTINUE_APPWIZCPL,\r\n                                        MB_YESNO | MB_ICONQUESTION,\r\n                                        NULL\r\n                                        )) {\r\n                            LOG ((LOG_INFORMATION, \"User launched Add/Remove Programs applet; setup will terminate\"));\r\n                            PostMessage (GetParent (hwnd), WMX_RESTART_SETUP, FALSE, TRUE);\r\n                        } else {\r\n                            b = FALSE;\r\n                        }\r\n                    }\r\n                    if (b) {\r\n                        ShellExecute (hwnd, TEXT(\"open\"), Href, ShellArgs, NULL, 0);\r\n                    }\r\n                }\r\n            } else if (HotLink->Bookmark) {\r\n                SendMessage (hwnd, WMX_GOTO, 0, (LPARAM) HotLink->Bookmark);\r\n            }\r\n        }\r\n\r\n        break;\r\n\r\n    case WM_SETTEXT:\r\n        SendMessage (hwnd, WMX_CLEANUP, 0, 0);\r\n        DefWindowProc (hwnd, uMsg, wParam, lParam);\r\n        SendMessage (hwnd, WM_CREATE, 0, 0);\r\n        return 0;\r\n\r\n    case WM_PAINT:\r\n        FillBrush = CreateSolidBrush (GetSysColor (COLOR_BTNFACE));\r\n        ShadowPen = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_3DSHADOW));\r\n        HighlightPen = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_3DHILIGHT));\r\n\r\n        hdc = BeginPaint (hwnd, &ps);\r\n        pCreateFontsIfNecessary (hdc, s->hFont, &tm, &s->hFontNormal, &s->hFontBold, &s->hFontUnderlined);\r\n        s->LineHeight = LineHeight = tm.tmHeight;\r\n        GetClientRect (hwnd, &rect);\r\n\r\n        //\r\n        // Select colors\r\n        //\r\n\r\n        SetBkColor (hdc, GetSysColor (COLOR_BTNFACE));\r\n        SetTextColor (hdc, GetSysColor (COLOR_WINDOWTEXT));\r\n\r\n        if (FillBrush) {\r\n            SelectObject (hdc, FillBrush);\r\n        }\r\n\r\n        SelectObject (hdc, GetStockObject (NULL_PEN));\r\n\r\n        //\r\n        // Get scroll position\r\n        //\r\n\r\n        ZeroMemory (&si, sizeof (si));\r\n        si.cbSize = sizeof (si);\r\n        si.fMask = SIF_PAGE|SIF_POS;\r\n        GetScrollInfo (hwnd, SB_VERT, &si);\r\n\r\n        End = (UINT) si.nPos + si.nPage + 1;\r\n        GrowListSize = GrowListGetSize (&s->List);\r\n        End = min (End, GrowListSize);\r\n        y = 0;\r\n\r\n        //\r\n        // Select font of previous line.  Move up if anchor wrap is on.\r\n        //\r\n\r\n        if (si.nPos) {\r\n            do {\r\n                LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf + (si.nPos - 1);\r\n                if (LineAttribs->AnchorWrap) {\r\n                    si.nPos--;\r\n                    y -= LineHeight;\r\n                } else {\r\n                    break;\r\n                }\r\n            } while (si.nPos > 0);\r\n        }\r\n\r\n        if (si.nPos) {\r\n            LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf + (si.nPos - 1);\r\n\r\n            if (LineAttribs->LastCharAttribs == ATTRIB_BOLD) {\r\n                SelectObject (hdc, s->hFontBold);\r\n            } else if (LineAttribs->LastCharAttribs == ATTRIB_UNDERLINED) {\r\n                SelectObject (hdc, s->hFontUnderlined);\r\n            } else {\r\n                SelectObject (hdc, s->hFontNormal);\r\n            }\r\n        } else {\r\n            SelectObject (hdc, s->hFontNormal);\r\n        }\r\n\r\n        //\r\n        // Paint!\r\n        //\r\n\r\n        Hot = FALSE;\r\n        s->HotLinkArray.End = 0;\r\n        BookmarkLink = UrlLink = NULL;\r\n\r\n        for (Pos = (UINT) si.nPos ; Pos < End ; Pos++) {\r\n            p = GrowListGetString (&s->List, Pos);\r\n            printableFound = FALSE;\r\n\r\n            LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf + Pos;\r\n\r\n            //\r\n            // Compute hanging indent using previous line\r\n            //\r\n\r\n            if (Pos > 0) {\r\n                PrevLineAttribs = (PLINEATTRIBS) ((PLINEATTRIBS) s->AttribsList.Buf + Pos - 1);\r\n                PrevHangingIndent = PrevLineAttribs->HangingIndent;\r\n            } else {\r\n                PrevHangingIndent = 0;\r\n            }\r\n\r\n            //\r\n            // Compute starting index\r\n            //\r\n\r\n            if (LineAttribs) {\r\n                x = LineAttribs->Indent + PrevHangingIndent;\r\n                LineAttribs->Painted = TRUE;\r\n            } else {\r\n                x = s->Margin;\r\n            }\r\n\r\n            //\r\n            // Compute blank area\r\n            //\r\n\r\n            if (x > 0) {\r\n                FillRect.left = 0;\r\n                FillRect.right = x;\r\n                FillRect.top = y;\r\n                FillRect.bottom = y + LineHeight;\r\n\r\n                Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);\r\n            }\r\n\r\n            //\r\n            // Multiline hotlink\r\n            //\r\n\r\n            if (Hot) {\r\n                HotRect.left = x;\r\n                HotRect.top = y;\r\n            }\r\n\r\n            //\r\n            // Compute text block\r\n            //\r\n\r\n            Start = p;\r\n\r\n            while (p) {\r\n                q = pGetHtmlCommandOrChar (p, &Command, &Char, &CommandBuf);\r\n\r\n                if (!Char || Command == COMMAND_WHITESPACE || Command == COMMAND_ESCAPED_CHAR) {\r\n                    //\r\n                    // If this is the end of of a block of text, paint it.\r\n                    //\r\n\r\n                    MYASSERT (Start);\r\n\r\n                    Tchars = p - Start;\r\n\r\n                    if (Tchars) {\r\n                        TextOut (hdc, x, y, Start, Tchars);\r\n                        GetTextExtentPoint32 (hdc, Start, Tchars, &Extent);\r\n\r\n                        x += Extent.cx;\r\n                        if (x > rect.right) {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    Start = q;\r\n                    oneChar = 0;\r\n\r\n                    if (printableFound && Command == COMMAND_WHITESPACE) {\r\n                        oneChar = TEXT(' ');\r\n                    } else if (Command == COMMAND_ESCAPED_CHAR) {\r\n                        oneChar = (TCHAR) Char;\r\n                    }\r\n\r\n                    if (oneChar) {\r\n\r\n                        TextOut (hdc, x, y, &oneChar, 1);\r\n                        GetTextExtentPoint32 (hdc, &oneChar, 1, &Extent);\r\n\r\n                        x += Extent.cx;\r\n                        if (x > rect.right) {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                } else {\r\n                    printableFound = TRUE;\r\n                }\r\n\r\n                switch (Command) {\r\n                case 0:\r\n                case COMMAND_WHITESPACE:\r\n                case COMMAND_ESCAPED_CHAR:\r\n                    break;\r\n\r\n                case COMMAND_ANCHOR:\r\n                    //\r\n                    // Does this anchor have an HREF?\r\n                    //\r\n\r\n                    if (CommandBuf) {\r\n                        Arg = CommandBuf;\r\n\r\n                        Href[0] = 0;\r\n\r\n                        while (Href[0] == 0 && *Arg) {\r\n                            //\r\n                            // Search for a HREF arg\r\n                            //\r\n\r\n                            Count = TcharCount (Arg);\r\n                            AnchorKey = AllocText (Count);\r\n                            AnchorVal = AllocText (Count);\r\n\r\n                            if (!AnchorKey || !AnchorVal) {\r\n                                FreeText (AnchorKey);\r\n                                FreeText (AnchorVal);\r\n                                break;\r\n                            }\r\n\r\n                            pGetHtmlKeyAndValue (Arg, AnchorKey, AnchorVal);\r\n\r\n                            if (StringIMatch (TEXT(\"HREF\"), AnchorKey)) {\r\n                                _tcssafecpy (Href, AnchorVal, MAX_URL);\r\n                            }\r\n\r\n                            FreeText (AnchorKey);\r\n                            FreeText (AnchorVal);\r\n\r\n                            Arg += Count + 1;\r\n                        }\r\n\r\n                        if (Href[0]) {\r\n                            //\r\n                            // Does HREF point to a bookmark?\r\n                            //\r\n\r\n                            BookmarkLink = UrlLink = NULL;\r\n\r\n                            if (_tcsnextc (Href) == TEXT('#')) {\r\n                                BookmarkLink = SkipSpace (_tcsinc (Href));\r\n                            } else {\r\n                                if (s->UrlEnabled) {\r\n                                    UrlLink = Href;\r\n                                }\r\n                            }\r\n\r\n                            //\r\n                            // If either BookmarkLink or Url is non-NULL, then turn on\r\n                            // link font and color\r\n                            //\r\n\r\n                            if (BookmarkLink || UrlLink) {\r\n                                HotRect.left = x;\r\n                                HotRect.top = y;\r\n                                Hot = TRUE;\r\n\r\n                                SelectObject (hdc, s->hFontUnderlined);\r\n                                SetTextColor (hdc, GetSysColor (COLOR_HIGHLIGHT));\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    break;\r\n\r\n                case COMMAND_BOLD:\r\n                    SelectObject (hdc, s->hFontBold);\r\n                    break;\r\n\r\n                case COMMAND_UNDERLINE:\r\n                    SelectObject (hdc, s->hFontUnderlined);\r\n                    break;\r\n\r\n                case COMMAND_HORZ_RULE:\r\n                    FillRect.left = rect.left;\r\n                    FillRect.right = rect.right;\r\n                    FillRect.top = y;\r\n                    FillRect.bottom = y + LineHeight;\r\n\r\n                    Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);\r\n\r\n                    OldPen = (HPEN) SelectObject (hdc, ShadowPen);\r\n                    MoveToEx (hdc, rect.left + 3, y + LineHeight / 2, NULL);\r\n                    LineTo (hdc, rect.right - 3, y + LineHeight / 2);\r\n                    SelectObject (hdc, HighlightPen);\r\n                    MoveToEx (hdc, rect.left + 3, y + LineHeight / 2 + 1, NULL);\r\n                    LineTo (hdc, rect.right - 3, y + LineHeight / 2 + 1);\r\n                    SelectObject (hdc, OldPen);\r\n\r\n                    x = rect.right;\r\n                    break;\r\n\r\n                case COMMAND_ANCHOR_END:\r\n                    SelectObject (hdc, s->hFontNormal);\r\n                    SetTextColor (hdc, GetSysColor (COLOR_WINDOWTEXT));\r\n\r\n                    if (Hot) {\r\n                        Hot = FALSE;\r\n                        HotRect.right = x;\r\n                        HotRect.bottom = y + LineHeight;\r\n\r\n                        pRegisterHotLink (&s->HotLinkArray, &HotRect, UrlLink, BookmarkLink);\r\n                    }\r\n                    break;\r\n\r\n                case COMMAND_BOLD_END:\r\n                case COMMAND_UNDERLINE_END:\r\n                    SelectObject (hdc, s->hFontNormal);\r\n                    break;\r\n                }\r\n\r\n                FreePathString (CommandBuf);\r\n\r\n                p = q;\r\n            }\r\n\r\n            //\r\n            // Hot link that extends to multiple lines\r\n            //\r\n\r\n            if (Hot) {\r\n                HotRect.right = x;\r\n                HotRect.bottom = y + LineHeight;\r\n                pRegisterHotLink (&s->HotLinkArray, &HotRect, UrlLink, BookmarkLink);\r\n            }\r\n\r\n            //\r\n            // Fill blank area to end of line\r\n            //\r\n\r\n            if (x < rect.right) {\r\n                FillRect.left = x;\r\n                FillRect.right = rect.right;\r\n                FillRect.top = y;\r\n                FillRect.bottom = y + LineHeight;\r\n\r\n                Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);\r\n            }\r\n\r\n            y += LineHeight;\r\n        }\r\n\r\n        //\r\n        // Fill blank area to bottom of window\r\n        //\r\n\r\n        if (y < rect.bottom) {\r\n             FillRect.left = 0;\r\n             FillRect.right = rect.right;\r\n             FillRect.top = y;\r\n             FillRect.bottom = rect.bottom;\r\n\r\n             Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);\r\n        }\r\n\r\n        //\r\n        // Cleanup\r\n        //\r\n\r\n        if (FillBrush) {\r\n            DeleteObject (FillBrush);\r\n        }\r\n\r\n        if (ShadowPen) {\r\n            DeleteObject (ShadowPen);\r\n            ShadowPen = NULL;\r\n        }\r\n\r\n        if (HighlightPen) {\r\n            DeleteObject (HighlightPen);\r\n            HighlightPen = NULL;\r\n        }\r\n\r\n        EndPaint (hwnd, &ps);\r\n        return 0;\r\n\r\n    case WM_VSCROLL:\r\n        Pos = HIWORD (wParam);\r\n\r\n        ZeroMemory (&si, sizeof (si));\r\n        si.cbSize = sizeof (si);\r\n        si.fMask = SIF_ALL;\r\n        GetScrollInfo (hwnd, SB_VERT, &si);\r\n        i = si.nMax - (INT) si.nPage + 1;\r\n\r\n        si.fMask = 0;\r\n\r\n        switch (LOWORD (wParam)) {\r\n        case SB_PAGEDOWN:\r\n            if (si.nPos + (INT) si.nPage < i) {\r\n                si.nPos += si.nPage;\r\n                ScrollWindow (hwnd, 0, -((INT) LineHeight * (INT) si.nPage), NULL, NULL);\r\n                si.fMask = SIF_POS;\r\n                break;\r\n            }\r\n\r\n            // fall through!\r\n\r\n        case SB_BOTTOM:\r\n            if (si.nPos < i) {\r\n                InvalidateRect (hwnd, NULL, FALSE);\r\n                si.nPos = i;\r\n                si.fMask = SIF_POS;\r\n            }\r\n            break;\r\n\r\n        case SB_LINEDOWN:\r\n            if (si.nPos < i) {\r\n                si.nPos += 1;\r\n                ScrollWindow (hwnd, 0, -((INT) LineHeight), NULL, NULL);\r\n                si.fMask = SIF_POS;\r\n            }\r\n\r\n            break;\r\n\r\n        case SB_LINEUP:\r\n            if (si.nPos > si.nMin) {\r\n                si.nPos -= 1;\r\n                ScrollWindow (hwnd, 0, (INT) LineHeight, NULL, NULL);\r\n                si.fMask = SIF_POS;\r\n            }\r\n\r\n            break;\r\n\r\n        case SB_THUMBTRACK:\r\n        case SB_THUMBPOSITION:\r\n            if ((INT) Pos != si.nPos) {\r\n                InvalidateRect (hwnd, NULL, FALSE);\r\n                si.nPos = (INT) Pos;\r\n                si.fMask = SIF_POS;\r\n            }\r\n            break;\r\n\r\n        case SB_PAGEUP:\r\n            if (si.nPos >= si.nMin + (INT) si.nPage) {\r\n                si.nPos -= si.nPage;\r\n                ScrollWindow (hwnd, 0, (INT) LineHeight * si.nPage, NULL, NULL);\r\n                si.fMask = SIF_POS;\r\n                break;\r\n            }\r\n\r\n            // fall through\r\n\r\n        case SB_TOP:\r\n            if (si.nPos > si.nMin) {\r\n                ScrollWindow (hwnd, 0, (INT) LineHeight * si.nPos, NULL, NULL);\r\n                si.nPos = si.nMin;\r\n                si.fMask = SIF_POS;\r\n            }\r\n            break;\r\n        }\r\n\r\n        if (si.fMask) {\r\n            SetScrollInfo (hwnd, SB_VERT, &si, TRUE);\r\n        }\r\n        break;\r\n\r\n    case WM_DESTROY:\r\n    case WMX_CLEANUP:\r\n        if (!g_Terminated) {\r\n            if (s) {\r\n                if (s->hFontNormal) {\r\n                    DeleteObject (s->hFontNormal);\r\n                    s->hFontNormal = NULL;\r\n                }\r\n\r\n                if (s->hFontBold) {\r\n                    DeleteObject (s->hFontBold);\r\n                    s->hFontBold = NULL;\r\n                }\r\n\r\n                if (s->hFontUnderlined) {\r\n                    DeleteObject (s->hFontUnderlined);\r\n                    s->hFontUnderlined = NULL;\r\n                }\r\n\r\n                FreeGrowBuffer (&s->AttribsList);\r\n                FreeGrowBuffer (&s->HotLinkArray);\r\n                FreeGrowList (&s->List);\r\n\r\n                if (s->BookmarkTable) {\r\n                    HtFree (s->BookmarkTable);\r\n                    s->BookmarkTable = NULL;\r\n                }\r\n\r\n                MemFree (g_hHeap, 0, s);\r\n                SetWindowLong (hwnd, GWL_USERDATA, 0);\r\n            }\r\n        }\r\n        break;\r\n\r\n    }\r\n\r\n    return DefWindowProc (hwnd, uMsg, wParam, lParam);\r\n"]]}
{"hexsha": "0e1063164babe9c8bf9ee3421779b3dbf8061c42", "ext": "c", "lang": "C", "content": "static PyObject *__pyx_f_4pymc_12LazyFunction_7Counter_unclick(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_r;\n  static char *__pyx_argnames[] = {0};\n  if (!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, \"\", __pyx_argnames)) return 0;\n  Py_INCREF(__pyx_v_self);\n  ((struct __pyx_obj_4pymc_12LazyFunction_Counter *)__pyx_v_self)->count = ((struct __pyx_obj_4pymc_12LazyFunction_Counter *)__pyx_v_self)->lastcount;\n\n  __pyx_r = Py_None; Py_INCREF(Py_None);\n  Py_DECREF(__pyx_v_self);\n  return __pyx_r;\n}", "item_id": 6, "repo": "matthew-brett/pymc", "file": "pymc/LazyFunction.c", "last_update_at": "2021-06-06T19:23:29+00:00", "question_id": "0e1063164babe9c8bf9ee3421779b3dbf8061c42_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject *__pyx_f_4pymc_12LazyFunction_7Counter_unclick(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {\n  PyObject *__pyx_r;\n  static char *__pyx_argnames[] = {0};\n  if (!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, \"\", __pyx_argnames)) return 0;\n  Py_INCREF(__pyx_v_self);\n  ((struct __pyx_obj_4pymc_12LazyFunction_Counter *)__pyx_v_self)->count = ((struct __pyx_obj_4pymc_12LazyFunction_Counter *)__pyx_v_self)->lastcount;\n  __pyx_r = Py_None; Py_INCREF(Py_None);\n  Py_DECREF(__pyx_v_self);\n  return __pyx_r;\n"]]}
{"hexsha": "ca1e5d348e65a5126ac5886709aca81a0c75db6b", "ext": "c", "lang": "C", "content": "void f19(void) {\n    \tint32_t x193 = INT32_MIN;\n\tint8_t x195 = -1;\n\tvolatile uint32_t t19 = 79543459U;\n\n    t19 = ((x193|x194)>>(x195!=x196));\n\n    if (t19 != 1573719099U) { NG(); } else { ; }\n\t\n}", "item_id": 19, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1355.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "ca1e5d348e65a5126ac5886709aca81a0c75db6b_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f19(void) {\n    \tint32_t x193 = INT32_MIN;\n\tint8_t x195 = -1;\n\tvolatile uint32_t t19 = 79543459U;\n    t19 = ((x193|x194)>>(x195!=x196));\n    if (t19 != 1573719099U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "b10c0f85ac043f2e2514d2042e13aba1b4621f1f", "ext": "c", "lang": "C", "content": "static sds getDotfilePath(char *envoverride, char *dotfilename) {\n    char *path = NULL;\n    sds dotPath = NULL;\n\n    /* Check the env for a dotfile override. */\n    path = getenv(envoverride);\n    if (path != NULL && *path != '\\0') {\n        if (!strcmp(\"/dev/null\", path)) {\n            return NULL;\n        }\n\n        /* If the env is set, return it. */\n        dotPath = sdsnew(path);\n    } else {\n        char *home = getenv(\"HOME\");\n        if (home != NULL && *home != '\\0') {\n            /* If no override is set use $HOME/<dotfilename>. */\n            dotPath = sdscatprintf(sdsempty(), \"%s/%s\", home, dotfilename);\n        }\n    }\n    return dotPath;\n}", "item_id": 2, "repo": "hihaoki/redis", "file": "src/redis-cli.c", "last_update_at": "2021-06-25T12:37:55+00:00", "question_id": "b10c0f85ac043f2e2514d2042e13aba1b4621f1f_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static sds getDotfilePath(char *envoverride, char *dotfilename) {\n    char *path = NULL;\n    sds dotPath = NULL;\n    /* Check the env for a dotfile override. */\n    path = getenv(envoverride);\n    if (path != NULL && *path != '\\0') {\n        if (!strcmp(\"/dev/null\", path)) {\n            return NULL;\n        }\n        /* If the env is set, return it. */\n        dotPath = sdsnew(path);\n    } else {\n        char *home = getenv(\"HOME\");\n        if (home != NULL && *home != '\\0') {\n            /* If no override is set use $HOME/<dotfilename>. */\n            dotPath = sdscatprintf(sdsempty(), \"%s/%s\", home, dotfilename);\n        }\n    }\n    return dotPath;\n"]]}
{"hexsha": "838ec3b80c3d5772f611b184063e2f3a6e0f92b6", "ext": "c", "lang": "C", "content": "void f177(void) {\n    \tint64_t x1369 = -1LL;\n\tint8_t x1370 = -1;\n\tint16_t x1371 = INT16_MIN;\n\tvolatile uint64_t x1372 = UINT64_MAX;\n\tstatic int32_t t177 = -168839919;\n\n    t177 = ((x1369==x1370)%(x1371<=x1372));\n\n    if (t177 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 177, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1867.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "838ec3b80c3d5772f611b184063e2f3a6e0f92b6_177", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f177(void) {\n    \tint64_t x1369 = -1LL;\n\tint8_t x1370 = -1;\n\tint16_t x1371 = INT16_MIN;\n\tvolatile uint64_t x1372 = UINT64_MAX;\n\tstatic int32_t t177 = -168839919;\n    t177 = ((x1369==x1370)%(x1371<=x1372));\n    if (t177 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "df1ab562a5420312461d414544121de638f34310", "ext": "c", "lang": "C", "content": "void f39(void) {\n    \tint8_t x2138 = 1;\n\tint16_t x2139 = -3;\n\tint32_t t39 = 61609;\n\n    t39 = ((x2137>>x2138)>>(x2139!=x2140));\n\n    if (t39 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 39, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1327.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "df1ab562a5420312461d414544121de638f34310_39", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f39(void) {\n    \tint8_t x2138 = 1;\n\tint16_t x2139 = -3;\n\tint32_t t39 = 61609;\n    t39 = ((x2137>>x2138)>>(x2139!=x2140));\n    if (t39 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "a101f91aab6e417aafd80461d16cb1beda8bb81f", "ext": "c", "lang": "C", "content": "static int\nmemb_gpsBitNumber_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,\n\t\t\tasn_app_constraint_failed_f *ctfailcb, void *app_key) {\n\tlong value;\n\t\n\tif(!sptr) {\n\t\tASN__CTFAIL(app_key, td, sptr,\n\t\t\t\"%s: value not given (%s:%d)\",\n\t\t\ttd->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\t\n\tvalue = *(const long *)sptr;\n\t\n\tif((value >= 0 && value <= 3)) {\n\t\t/* Constraint check succeeded */\n\t\treturn 0;\n\t} else {\n\t\tASN__CTFAIL(app_key, td, sptr,\n\t\t\t\"%s: constraint failed (%s:%d)\",\n\t\t\ttd->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n}", "item_id": 3, "repo": "zxcwhale/android_gpsbd", "file": "hardware/libgps/asn-rrlp/AcquisElement.c", "last_update_at": "2021-12-16T08:12:56+00:00", "question_id": "a101f91aab6e417aafd80461d16cb1beda8bb81f_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nmemb_gpsBitNumber_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,\n\t\t\tasn_app_constraint_failed_f *ctfailcb, void *app_key) {\n\tlong value;\n\t\n\tif(!sptr) {\n\t\tASN__CTFAIL(app_key, td, sptr,\n\t\t\t\"%s: value not given (%s:%d)\",\n\t\t\ttd->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\t\n\tvalue = *(const long *)sptr;\n\t\n\tif((value >= 0 && value <= 3)) {\n\t\t/* Constraint check succeeded */\n\t\treturn 0;\n\t} else {\n\t\tASN__CTFAIL(app_key, td, sptr,\n\t\t\t\"%s: constraint failed (%s:%d)\",\n\t\t\ttd->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n"]]}
{"hexsha": "b127f8858dc0efbc437a424036dcd18ac998af9c", "ext": "c", "lang": "C", "content": "INT32 __stdcall ListViewCompareProc(\n    LONG lParam1,\n    LONG lParam2,\n    LONG lParamSort)\n{\n    unsigned long iBytes1   = (unsigned long) lParam1;\n    unsigned long iBytes2   = (unsigned long) lParam2;\n    int iResult             = iBytes1 - iBytes2;\n\n    return(-iResult);\n}", "item_id": 0, "repo": "fengjixuchui/Push", "file": "source/push[exe]/GUI/gui.c", "last_update_at": "2021-10-31T10:45:16+00:00", "question_id": "b127f8858dc0efbc437a424036dcd18ac998af9c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["INT32 __stdcall ListViewCompareProc(\n    LONG lParam1,\n    LONG lParam2,\n    LONG lParamSort)\n{\n    unsigned long iBytes1   = (unsigned long) lParam1;\n    unsigned long iBytes2   = (unsigned long) lParam2;\n    int iResult             = iBytes1 - iBytes2;\n    return(-iResult);\n"]]}
{"hexsha": "2ce3d15eba4c70d2282b8bc98e7c926ee6a02a29", "ext": "c", "lang": "C", "content": "void f132(void) {\n    \tint64_t x1055 = -7098LL;\n\tint32_t t132 = -792099;\n\n    t132 = ((x1053%(x1054>x1055))+x1056);\n\n    if (t132 != 1101) { NG(); } else { ; }\n\t\n}", "item_id": 132, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test1625.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "2ce3d15eba4c70d2282b8bc98e7c926ee6a02a29_132", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f132(void) {\n    \tint64_t x1055 = -7098LL;\n\tint32_t t132 = -792099;\n    t132 = ((x1053%(x1054>x1055))+x1056);\n    if (t132 != 1101) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "1de4dc385140fb4867d7d7d29ac0216b23cfd6d2", "ext": "c", "lang": "C", "content": "void CFireWorkDraw::stage3(void)\n{\n\tint i,j,numdrawn= 0,c;\n\n\tfor(i = 0; i < numactive; i++) {\n\t\tif(!scount[i]) continue;\n\t\tnumdrawn++;\n\n\t\tGUGDrawPoint(SET,SMOKECOLOR,x[i],y[i]);\n\t\tx[i] += xm[i];\n\t\ty[i] += ym[i];\n\t\txm[i] *= AIRRESISTANCE;\n\t\tym[i] *= AIRRESISTANCE;\n\t\tym[i] += GRAVITY;\n\n\n\t\tswitch(type) {\n\t\tcase 0:                          // Standard\n\t\t\tj = (1000-scount[i])/10;\n\t\t\tif(j < 0) j = 0;\n\t\t\tif(j > 99) j = 99;\n\n\t\t\tc = giFWColor[scolor[i]][j];\n\t\t\tGUGDrawPoint(SET,c,x[i],y[i]);\n\t\t\tscount[i]-= 6;\n\t\t\tif(scount[i] < 0) scount[i] = 0;\n\t\t\tbreak;\n\t\tcase 1:                          // Oooo-Ahhh.\n\t\t\tj = (1000-scount[i])/10;\n\t\t\tif(j < 0) j = 0;\n\t\t\tif(j > 99) j = 99;\n\n\t\t\tc = giFWColor[scolor[i]][j];\n\t\t\tGUGDrawPoint(SET,c,x[i],y[i]);\n\t\t\tscount[i]-= 12;\n\t\t\tif(scount[i] < 0) {\n\t\t\t\tsswitch[i]++;\n\t\t\t\tif(sswitch[i] == 2) scount[i] = 0;\n\t\t\t\telse {\n\t\t\t\t\tscolor[i] = nextcolor[0];\n\t\t\t\t\tscount[i] = 940;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:                          // Twinkler.\n\t\t\tj = (1000-scount[i])/10;\n\t\t\tif(j < 0) j = 0;\n\t\t\tif(j > 99) j = 99;\n\n\t\t\tc = giFWColor[scolor[i]][j];\n\t\t\tGUGDrawPoint(SET,c,x[i],y[i]);\n\n\t\t\tif(sswitch[i]== 0) scount[i]-= 15;\n\t\t\telse {\n\t\t\t\tscount[i] -= 80;\n\t\t\t\tif(!random(10)) scount[i] = 1;\n\t\t\t}\n\n\t\t\tif(scount[i] < 0) {\n\t\t\t\tsswitch[i]++;\n\t\t\t\tif(sswitch[i] == 10) scount[i] = 0;\n\t\t\t\telse {\n\t\t\t\t\tif(scolor[i] == 6) scolor[i] = nextcolor[0];\n\t\t\t\t\telse scolor[i] = 6;\n\t\t\t\t\tscount[i] = 940;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(!numdrawn) stage++;\n}", "item_id": 6, "repo": "nebosite/groundup", "file": "WATCOM_32bit/flabber/routine.c", "last_update_at": "2021-10-09T23:44:03+00:00", "question_id": "1de4dc385140fb4867d7d7d29ac0216b23cfd6d2_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void CFireWorkDraw::stage3(void)\n{\n\tint i,j,numdrawn= 0,c;\n\tfor(i = 0; i < numactive; i++) {\n\t\tif(!scount[i]) continue;\n\t\tnumdrawn++;\n\t\tGUGDrawPoint(SET,SMOKECOLOR,x[i],y[i]);\n\t\tx[i] += xm[i];\n\t\ty[i] += ym[i];\n\t\txm[i] *= AIRRESISTANCE;\n\t\tym[i] *= AIRRESISTANCE;\n\t\tym[i] += GRAVITY;\n\t\tswitch(type) {\n\t\tcase 0:                          // Standard\n\t\t\tj = (1000-scount[i])/10;\n\t\t\tif(j < 0) j = 0;\n\t\t\tif(j > 99) j = 99;\n\t\t\tc = giFWColor[scolor[i]][j];\n\t\t\tGUGDrawPoint(SET,c,x[i],y[i]);\n\t\t\tscount[i]-= 6;\n\t\t\tif(scount[i] < 0) scount[i] = 0;\n\t\t\tbreak;\n\t\tcase 1:                          // Oooo-Ahhh.\n\t\t\tj = (1000-scount[i])/10;\n\t\t\tif(j < 0) j = 0;\n\t\t\tif(j > 99) j = 99;\n\t\t\tc = giFWColor[scolor[i]][j];\n\t\t\tGUGDrawPoint(SET,c,x[i],y[i]);\n\t\t\tscount[i]-= 12;\n\t\t\tif(scount[i] < 0) {\n\t\t\t\tsswitch[i]++;\n\t\t\t\tif(sswitch[i] == 2) scount[i] = 0;\n\t\t\t\telse {\n\t\t\t\t\tscolor[i] = nextcolor[0];\n\t\t\t\t\tscount[i] = 940;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:                          // Twinkler.\n\t\t\tj = (1000-scount[i])/10;\n\t\t\tif(j < 0) j = 0;\n\t\t\tif(j > 99) j = 99;\n\t\t\tc = giFWColor[scolor[i]][j];\n\t\t\tGUGDrawPoint(SET,c,x[i],y[i]);\n\t\t\tif(sswitch[i]== 0) scount[i]-= 15;\n\t\t\telse {\n\t\t\t\tscount[i] -= 80;\n\t\t\t\tif(!random(10)) scount[i] = 1;\n\t\t\t}\n\t\t\tif(scount[i] < 0) {\n\t\t\t\tsswitch[i]++;\n\t\t\t\tif(sswitch[i] == 10) scount[i] = 0;\n\t\t\t\telse {\n\t\t\t\t\tif(scolor[i] == 6) scolor[i] = nextcolor[0];\n\t\t\t\t\telse scolor[i] = 6;\n\t\t\t\t\tscount[i] = 940;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!numdrawn) stage++;\n"]]}
{"hexsha": "8a64c86df4ae1707a9905fc20386518cbfb2e3f9", "ext": "c", "lang": "C", "content": "void destroy_winIVRCompositor_IVRCompositor_022(void *object)\n{\n    TRACE(\"%p\\n\", object);\n    struct __winIVRCompositor_IVRCompositor_022 *win_object = object;\n    destroy_compositor_data(&win_object->user_data);\n    HeapFree(GetProcessHeap(), 0, object);\n}", "item_id": 11, "repo": "mcoffin/Proton", "file": "vrclient_x64/vrclient_x64/winIVRCompositor.c", "last_update_at": "2021-05-25T04:09:19+00:00", "question_id": "8a64c86df4ae1707a9905fc20386518cbfb2e3f9_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void destroy_winIVRCompositor_IVRCompositor_022(void *object)\n{\n    TRACE(\"%p\\n\", object);\n    struct __winIVRCompositor_IVRCompositor_022 *win_object = object;\n    destroy_compositor_data(&win_object->user_data);\n    HeapFree(GetProcessHeap(), 0, object);\n"]]}
{"hexsha": "6f3693ab432dc462d62231142a71fbb5dce1433c", "ext": "c", "lang": "C", "content": "static\ncorto_subscriber corto_subscribeCallback(\n    void (*callback)(corto_subscriber_event*))\n{\n    corto_subscriber result = NULL;\n\n    corto_subscribeRequest *request = ut_tls_get(CORTO_KEY_FLUENT);\n    if (request) {\n        request->callback = callback;\n        ut_tls_set(CORTO_KEY_FLUENT, NULL);\n        result = corto_subscribeSubscribe(request);\n        corto_dealloc(request);\n    }\n\n    return result;\n}", "item_id": 20, "repo": "uhayat/corto", "file": "src/vstore/subscriber.c", "last_update_at": "2021-01-27T05:15:12+00:00", "question_id": "6f3693ab432dc462d62231142a71fbb5dce1433c_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static\ncorto_subscriber corto_subscribeCallback(\n    void (*callback)(corto_subscriber_event*))\n{\n    corto_subscriber result = NULL;\n    corto_subscribeRequest *request = ut_tls_get(CORTO_KEY_FLUENT);\n    if (request) {\n        request->callback = callback;\n        ut_tls_set(CORTO_KEY_FLUENT, NULL);\n        result = corto_subscribeSubscribe(request);\n        corto_dealloc(request);\n    }\n    return result;\n"]]}
{"hexsha": "a205d5b5c2656ef0d967f1b314899f437e8b351b", "ext": "c", "lang": "C", "content": "char ** rht_keys (rht_t * ht)\n{\n  char ** keys = calloc (rht_count (ht) + 1, sizeof (char *));\n  unsigned i = 0;\n  Tcl_HashSearch search;\n  Tcl_HashEntry * he;\n  for (he = Tcl_FirstHashEntry (ht, & search); he; he = Tcl_NextHashEntry (& search))\n    keys [i ++] = Tcl_GetHashKey (ht, he);\n  return keys;\n}", "item_id": 4, "repo": "rcarbone/rperf", "file": "src/hashtables/implementations/sys/tcl/glue.c", "last_update_at": "2021-02-24T14:48:35+00:00", "question_id": "a205d5b5c2656ef0d967f1b314899f437e8b351b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char ** rht_keys (rht_t * ht)\n{\n  char ** keys = calloc (rht_count (ht) + 1, sizeof (char *));\n  unsigned i = 0;\n  Tcl_HashSearch search;\n  Tcl_HashEntry * he;\n  for (he = Tcl_FirstHashEntry (ht, & search); he; he = Tcl_NextHashEntry (& search))\n    keys [i ++] = Tcl_GetHashKey (ht, he);\n  return keys;\n"]]}
{"hexsha": "7a21fae4e4d2b2dec4ee350161c1dd2fcc81ae45", "ext": "c", "lang": "C", "content": "void f13(void) {\n    \tvolatile int16_t x57 = INT16_MIN;\n\tint8_t x58 = INT8_MIN;\n\tvolatile int8_t x60 = -1;\n\tvolatile int32_t t13 = 729838;\n\n    t13 = (((x57&x58)>x59)-x60);\n\n    if (t13 != 2) { NG(); } else { ; }\n\t\n}", "item_id": 13, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test2270.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "7a21fae4e4d2b2dec4ee350161c1dd2fcc81ae45_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f13(void) {\n    \tvolatile int16_t x57 = INT16_MIN;\n\tint8_t x58 = INT8_MIN;\n\tvolatile int8_t x60 = -1;\n\tvolatile int32_t t13 = 729838;\n    t13 = (((x57&x58)>x59)-x60);\n    if (t13 != 2) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "295c0737eb9f93ba1c356c7fe6726f397fad6c76", "ext": "c", "lang": "C", "content": "void f145(void) {\n    \tint64_t x679 = -36932516734LL;\n\tstatic uint16_t x680 = 227U;\n\tvolatile int64_t t145 = -106065LL;\n\n    t145 = (x677+(x678|(x679+x680)));\n\n    if (t145 != -36932516503LL) { NG(); } else { ; }\n\t\n}", "item_id": 145, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test169.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "295c0737eb9f93ba1c356c7fe6726f397fad6c76_145", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f145(void) {\n    \tint64_t x679 = -36932516734LL;\n\tstatic uint16_t x680 = 227U;\n\tvolatile int64_t t145 = -106065LL;\n    t145 = (x677+(x678|(x679+x680)));\n    if (t145 != -36932516503LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "b2e0d8c2493e8ed55706dacd14ca4eccae1e0e53", "ext": "c", "lang": "C", "content": "static int\nmake_enum(struct enum_s *restrict tgt, echs_instant_t proto, rrulsp_t rr)\n{\n\tsize_t nH = 0U;\n\tsize_t nM = 0U;\n\tsize_t nS = 0U;\n\tunsigned int tmp;\n\n\t/* get all hours */\n\tfor (bitint_iter_t Hi = 0UL;\n\t     (tmp = bui31_next(&Hi, rr->H), Hi);) {\n\t\ttgt->H[nH++] = (uint8_t)tmp;\n\t}\n\tif (!nH) {\n\t\ttgt->H[nH++] = (uint8_t)proto.H;\n\t}\n\t/* get all minutes */\n\tfor (bitint_iter_t Mi = 0UL;\n\t     (tmp = bui63_next(&Mi, rr->M), Mi);) {\n\t\ttgt->M[nM++] = (uint8_t)tmp;\n\t}\n\tif (!nM) {\n\t\ttgt->M[nM++] = (uint8_t)proto.M;\n\t}\n\t/* get all them seconds */\n\tfor (bitint_iter_t Si = 0UL;\n\t     (tmp = bui63_next(&Si, rr->S), Si);) {\n\t\ttgt->S[nS++] = (uint8_t)tmp;\n\t}\n\tif (!nS) {\n\t\ttgt->S[nS++] = (uint8_t)proto.S;\n\t}\n\ttgt->nH = nH;\n\ttgt->nM = nM;\n\ttgt->nS = nS;\n\treturn 0;\n}", "item_id": 11, "repo": "hroptatyr/echse", "file": "src/evrrul.c", "last_update_at": "2021-07-11T20:23:36+00:00", "question_id": "b2e0d8c2493e8ed55706dacd14ca4eccae1e0e53_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nmake_enum(struct enum_s *restrict tgt, echs_instant_t proto, rrulsp_t rr)\n{\n\tsize_t nH = 0U;\n\tsize_t nM = 0U;\n\tsize_t nS = 0U;\n\tunsigned int tmp;\n\t/* get all hours */\n\tfor (bitint_iter_t Hi = 0UL;\n\t     (tmp = bui31_next(&Hi, rr->H), Hi);) {\n\t\ttgt->H[nH++] = (uint8_t)tmp;\n\t}\n\tif (!nH) {\n\t\ttgt->H[nH++] = (uint8_t)proto.H;\n\t}\n\t/* get all minutes */\n\tfor (bitint_iter_t Mi = 0UL;\n\t     (tmp = bui63_next(&Mi, rr->M), Mi);) {\n\t\ttgt->M[nM++] = (uint8_t)tmp;\n\t}\n\tif (!nM) {\n\t\ttgt->M[nM++] = (uint8_t)proto.M;\n\t}\n\t/* get all them seconds */\n\tfor (bitint_iter_t Si = 0UL;\n\t     (tmp = bui63_next(&Si, rr->S), Si);) {\n\t\ttgt->S[nS++] = (uint8_t)tmp;\n\t}\n\tif (!nS) {\n\t\ttgt->S[nS++] = (uint8_t)proto.S;\n\t}\n\ttgt->nH = nH;\n\ttgt->nM = nM;\n\ttgt->nS = nS;\n\treturn 0;\n"]]}
{"hexsha": "e3335b8a6861fbf799576a43725fcc2ebf3aefcc", "ext": "c", "lang": "C", "content": "void f59(void) {\n    \tstatic uint16_t x253 = 126U;\n\tuint16_t x254 = UINT16_MAX;\n\tvolatile int16_t x255 = 1;\n\tstatic uint32_t x256 = 158329U;\n\tuint32_t t59 = 56350816U;\n\n    t59 = (((x253/x254)+x255)|x256);\n\n    if (t59 != 158329U) { NG(); } else { ; }\n\t\n}", "item_id": 59, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test601.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "e3335b8a6861fbf799576a43725fcc2ebf3aefcc_59", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f59(void) {\n    \tstatic uint16_t x253 = 126U;\n\tuint16_t x254 = UINT16_MAX;\n\tvolatile int16_t x255 = 1;\n\tstatic uint32_t x256 = 158329U;\n\tuint32_t t59 = 56350816U;\n    t59 = (((x253/x254)+x255)|x256);\n    if (t59 != 158329U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "4bf8f8c6f86b0a0b04f191d42e59e8a9adcf2bcb", "ext": "c", "lang": "C", "content": "char *neigh_strdup(const char *src) {\n    char *dst = NULL;\n\n    if (src != NULL) {\n        size_t length = strlen(src);\n\n        dst = malloc(length + 1);\n\n        if (dst != NULL) {\n            strcpy(dst, src);\n        }\n    }\n\n    return dst;\n}", "item_id": 0, "repo": "GiorgiaAuroraAdorni/neigh", "file": "src/utilities.c", "last_update_at": "2021-05-06T12:43:18+00:00", "question_id": "4bf8f8c6f86b0a0b04f191d42e59e8a9adcf2bcb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["char *neigh_strdup(const char *src) {\n    char *dst = NULL;\n    if (src != NULL) {\n        size_t length = strlen(src);\n        dst = malloc(length + 1);\n        if (dst != NULL) {\n            strcpy(dst, src);\n        }\n    }\n    return dst;\n"]]}
{"hexsha": "a4e3219456396ac5879c15765b7d6a39a9cc1de8", "ext": "c", "lang": "C", "content": "void mrb_SQLite_Sqlite3Vtab_init(mrb_state* mrb) {\n  static int initialized = 0;\n  if (initialized) return;\n  else initialized = 1;\n\n/* MRUBY_BINDING: pre_class_definition */\n/* sha: user_defined */\n\n/* MRUBY_BINDING_END */\n\n/* MRUBY_BINDING: Sqlite3Vtab::class_definition */\n/* sha: 008ff32534793c07965e6f477d3690e1b0019cdaed764ebdcc40993b87d388ac */\n  struct RClass* Sqlite3Vtab_class = mrb_define_class_under(mrb, SQLite_module(mrb), \"Sqlite3Vtab\", mrb->object_class);\n  MRB_SET_INSTANCE_TT(Sqlite3Vtab_class, MRB_TT_DATA);\n/* MRUBY_BINDING_END */\n\n/* MRUBY_BINDING: Sqlite3Vtab::pre_class_method_definitions */\n/* sha: user_defined */\n\n/* MRUBY_BINDING_END */\n\n/* MRUBY_BINDING: Sqlite3Vtab::class_method_definitions */\n/* sha: 380df65e514f34d8365c215c81db694b054006a5657ed801c53561069a784d42 */\n#if BIND_Sqlite3Vtab_INITIALIZE\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"initialize\", mrb_SQLite_Sqlite3Vtab_initialize, MRB_ARGS_NONE());\n#endif\n/* MRUBY_BINDING_END */\n\n/* MRUBY_BINDING: Sqlite3Vtab::pre_attr_definitions */\n/* sha: user_defined */\n\n/* MRUBY_BINDING_END */\n\n/* MRUBY_BINDING: Sqlite3Vtab::attr_definitions */\n/* sha: cc4169a83f64667251676efae32065fc7fd7d3139b0a31f202486f1ea2de3220 */\n  /*\n   * Fields\n   */\n#if BIND_Sqlite3Vtab_pModule_FIELD_READER\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"pModule\", mrb_SQLite_Sqlite3Vtab_get_pModule, MRB_ARGS_ARG(0, 0));\n#endif\n#if BIND_Sqlite3Vtab_pModule_FIELD_WRITER\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"pModule=\", mrb_SQLite_Sqlite3Vtab_set_pModule, MRB_ARGS_ARG(1, 0));\n#endif\n#if BIND_Sqlite3Vtab_nRef_FIELD_READER\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"nRef\", mrb_SQLite_Sqlite3Vtab_get_nRef, MRB_ARGS_ARG(0, 0));\n#endif\n#if BIND_Sqlite3Vtab_nRef_FIELD_WRITER\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"nRef=\", mrb_SQLite_Sqlite3Vtab_set_nRef, MRB_ARGS_ARG(1, 0));\n#endif\n#if BIND_Sqlite3Vtab_zErrMsg_FIELD_READER\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"zErrMsg\", mrb_SQLite_Sqlite3Vtab_get_zErrMsg, MRB_ARGS_ARG(0, 0));\n#endif\n#if BIND_Sqlite3Vtab_zErrMsg_FIELD_WRITER\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"zErrMsg=\", mrb_SQLite_Sqlite3Vtab_set_zErrMsg, MRB_ARGS_ARG(1, 0));\n#endif\n/* MRUBY_BINDING_END */\n\n\n/* MRUBY_BINDING: Sqlite3Vtab::post_class_definition */\n/* sha: user_defined */\n\n/* MRUBY_BINDING_END */\n}", "item_id": 6, "repo": "asfluido/mruby-sqlite", "file": "src/mruby_sqlite3_vtab.c", "last_update_at": "2021-02-09T03:30:49+00:00", "question_id": "a4e3219456396ac5879c15765b7d6a39a9cc1de8_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void mrb_SQLite_Sqlite3Vtab_init(mrb_state* mrb) {\n  static int initialized = 0;\n  if (initialized) return;\n  else initialized = 1;\n/* MRUBY_BINDING: pre_class_definition */\n/* sha: user_defined */\n/* MRUBY_BINDING_END */\n/* MRUBY_BINDING: Sqlite3Vtab::class_definition */\n/* sha: 008ff32534793c07965e6f477d3690e1b0019cdaed764ebdcc40993b87d388ac */\n  struct RClass* Sqlite3Vtab_class = mrb_define_class_under(mrb, SQLite_module(mrb), \"Sqlite3Vtab\", mrb->object_class);\n  MRB_SET_INSTANCE_TT(Sqlite3Vtab_class, MRB_TT_DATA);\n/* MRUBY_BINDING_END */\n/* MRUBY_BINDING: Sqlite3Vtab::pre_class_method_definitions */\n/* sha: user_defined */\n/* MRUBY_BINDING_END */\n/* MRUBY_BINDING: Sqlite3Vtab::class_method_definitions */\n/* sha: 380df65e514f34d8365c215c81db694b054006a5657ed801c53561069a784d42 */\n#if BIND_Sqlite3Vtab_INITIALIZE\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"initialize\", mrb_SQLite_Sqlite3Vtab_initialize, MRB_ARGS_NONE());\n#endif\n/* MRUBY_BINDING_END */\n/* MRUBY_BINDING: Sqlite3Vtab::pre_attr_definitions */\n/* sha: user_defined */\n/* MRUBY_BINDING_END */\n/* MRUBY_BINDING: Sqlite3Vtab::attr_definitions */\n/* sha: cc4169a83f64667251676efae32065fc7fd7d3139b0a31f202486f1ea2de3220 */\n  /*\n   * Fields\n   */\n#if BIND_Sqlite3Vtab_pModule_FIELD_READER\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"pModule\", mrb_SQLite_Sqlite3Vtab_get_pModule, MRB_ARGS_ARG(0, 0));\n#endif\n#if BIND_Sqlite3Vtab_pModule_FIELD_WRITER\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"pModule=\", mrb_SQLite_Sqlite3Vtab_set_pModule, MRB_ARGS_ARG(1, 0));\n#endif\n#if BIND_Sqlite3Vtab_nRef_FIELD_READER\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"nRef\", mrb_SQLite_Sqlite3Vtab_get_nRef, MRB_ARGS_ARG(0, 0));\n#endif\n#if BIND_Sqlite3Vtab_nRef_FIELD_WRITER\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"nRef=\", mrb_SQLite_Sqlite3Vtab_set_nRef, MRB_ARGS_ARG(1, 0));\n#endif\n#if BIND_Sqlite3Vtab_zErrMsg_FIELD_READER\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"zErrMsg\", mrb_SQLite_Sqlite3Vtab_get_zErrMsg, MRB_ARGS_ARG(0, 0));\n#endif\n#if BIND_Sqlite3Vtab_zErrMsg_FIELD_WRITER\n  mrb_define_method(mrb, Sqlite3Vtab_class, \"zErrMsg=\", mrb_SQLite_Sqlite3Vtab_set_zErrMsg, MRB_ARGS_ARG(1, 0));\n#endif\n/* MRUBY_BINDING_END */\n/* MRUBY_BINDING: Sqlite3Vtab::post_class_definition */\n/* sha: user_defined */\n/* MRUBY_BINDING_END */\n"]]}
{"hexsha": "b41900f160f07ac0a8d147d3552758d97d00eff9", "ext": "c", "lang": "C", "content": "int fs_getSize(lua_State *L) {\n    struct stat st;\n    char * path = fixpath(lua_tostring(L, 1));\n    if (stat(path, &st) != 0) err(L, path, \"No such file\");\n    lua_pushinteger(L, st.st_size);\n    free(path);\n    return 1;\n}", "item_id": 10, "repo": "MCJack123/CraftOS-DOS", "file": "fs.c", "last_update_at": "2021-12-20T23:37:19+00:00", "question_id": "b41900f160f07ac0a8d147d3552758d97d00eff9_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int fs_getSize(lua_State *L) {\n    struct stat st;\n    char * path = fixpath(lua_tostring(L, 1));\n    if (stat(path, &st) != 0) err(L, path, \"No such file\");\n    lua_pushinteger(L, st.st_size);\n    free(path);\n    return 1;\n"]]}
{"hexsha": "8edd64c20751668ddbe3a913ea99024a33ab8d4e", "ext": "c", "lang": "C", "content": "void f51(void) {\n    \tuint32_t x1929 = 3U;\n\tstatic int64_t x1930 = INT64_MAX;\n\tint16_t x1932 = -12;\n\tint64_t t51 = 133127116044LL;\n\n    t51 = (((x1929/x1930)<<x1931)+x1932);\n\n    if (t51 != -12LL) { NG(); } else { ; }\n\t\n}", "item_id": 51, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test659.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "8edd64c20751668ddbe3a913ea99024a33ab8d4e_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f51(void) {\n    \tuint32_t x1929 = 3U;\n\tstatic int64_t x1930 = INT64_MAX;\n\tint16_t x1932 = -12;\n\tint64_t t51 = 133127116044LL;\n    t51 = (((x1929/x1930)<<x1931)+x1932);\n    if (t51 != -12LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "ba858de6f2a0c731bc94a14a97ed27f186e6591c", "ext": "c", "lang": "C", "content": "static grn_obj *\nproc_table_tokenize(grn_ctx *ctx, int nargs, grn_obj **args, grn_user_data *user_data)\n{\n  grn_obj *table_name;\n  grn_obj *string;\n  grn_obj *flag_names;\n  grn_obj *mode_name;\n\n  table_name = VAR(0);\n  string = VAR(1);\n  flag_names = VAR(2);\n  mode_name = VAR(3);\n\n  if (GRN_TEXT_LEN(table_name) == 0) {\n    ERR(GRN_INVALID_ARGUMENT, \"[table_tokenize] table name is missing\");\n    return NULL;\n  }\n\n  if (GRN_TEXT_LEN(string) == 0) {\n    ERR(GRN_INVALID_ARGUMENT, \"[table_tokenize] string is missing\");\n    return NULL;\n  }\n\n  {\n    unsigned int flags;\n    grn_obj *lexicon;\n\n    flags = parse_tokenize_flags(ctx, flag_names);\n    if (ctx->rc != GRN_SUCCESS) {\n      return NULL;\n    }\n\n    lexicon = grn_ctx_get(ctx, GRN_TEXT_VALUE(table_name), GRN_TEXT_LEN(table_name));\n\n    if (!lexicon) {\n      return NULL;\n    }\n\n#define MODE_NAME_EQUAL(name)\\\n    (GRN_TEXT_LEN(mode_name) == strlen(name) &&\\\n     memcmp(GRN_TEXT_VALUE(mode_name), name, strlen(name)) == 0)\n\n    {\n      grn_obj tokens;\n      GRN_VALUE_FIX_SIZE_INIT(&tokens, GRN_OBJ_VECTOR, GRN_ID_NIL);\n    if (GRN_TEXT_LEN(mode_name) == 0 || MODE_NAME_EQUAL(\"GET\")) {\n      tokenize(ctx, lexicon, string, GRN_TOKEN_GET, flags, &tokens);\n      output_tokens(ctx, &tokens, lexicon);\n    } else if (MODE_NAME_EQUAL(\"ADD\")) {\n      tokenize(ctx, lexicon, string, GRN_TOKEN_ADD, flags, &tokens);\n      output_tokens(ctx, &tokens, lexicon);\n    } else {\n      ERR(GRN_INVALID_ARGUMENT, \"[table_tokenize] invalid mode: <%.*s>\",\n          (int)GRN_TEXT_LEN(mode_name), GRN_TEXT_VALUE(mode_name));\n    }\n      GRN_OBJ_FIN(ctx, &tokens);\n    }\n#undef MODE_NAME_EQUAL\n\n    grn_obj_unlink(ctx, lexicon);\n  }\n\n  return NULL;\n}", "item_id": 82, "repo": "jiunbae/ITE4065", "file": "project4/mariadb/server/storage/mroonga/vendor/groonga/lib/proc.c", "last_update_at": "2021-06-24T07:24:21+00:00", "question_id": "ba858de6f2a0c731bc94a14a97ed27f186e6591c_82", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static grn_obj *\nproc_table_tokenize(grn_ctx *ctx, int nargs, grn_obj **args, grn_user_data *user_data)\n{\n  grn_obj *table_name;\n  grn_obj *string;\n  grn_obj *flag_names;\n  grn_obj *mode_name;\n  table_name = VAR(0);\n  string = VAR(1);\n  flag_names = VAR(2);\n  mode_name = VAR(3);\n  if (GRN_TEXT_LEN(table_name) == 0) {\n    ERR(GRN_INVALID_ARGUMENT, \"[table_tokenize] table name is missing\");\n    return NULL;\n  }\n  if (GRN_TEXT_LEN(string) == 0) {\n    ERR(GRN_INVALID_ARGUMENT, \"[table_tokenize] string is missing\");\n    return NULL;\n  }\n  {\n    unsigned int flags;\n    grn_obj *lexicon;\n    flags = parse_tokenize_flags(ctx, flag_names);\n    if (ctx->rc != GRN_SUCCESS) {\n      return NULL;\n    }\n    lexicon = grn_ctx_get(ctx, GRN_TEXT_VALUE(table_name), GRN_TEXT_LEN(table_name));\n    if (!lexicon) {\n      return NULL;\n    }\n#define MODE_NAME_EQUAL(name)\\\n    (GRN_TEXT_LEN(mode_name) == strlen(name) &&\\\n     memcmp(GRN_TEXT_VALUE(mode_name), name, strlen(name)) == 0)\n    {\n      grn_obj tokens;\n      GRN_VALUE_FIX_SIZE_INIT(&tokens, GRN_OBJ_VECTOR, GRN_ID_NIL);\n    if (GRN_TEXT_LEN(mode_name) == 0 || MODE_NAME_EQUAL(\"GET\")) {\n      tokenize(ctx, lexicon, string, GRN_TOKEN_GET, flags, &tokens);\n      output_tokens(ctx, &tokens, lexicon);\n    } else if (MODE_NAME_EQUAL(\"ADD\")) {\n      tokenize(ctx, lexicon, string, GRN_TOKEN_ADD, flags, &tokens);\n      output_tokens(ctx, &tokens, lexicon);\n    } else {\n      ERR(GRN_INVALID_ARGUMENT, \"[table_tokenize] invalid mode: <%.*s>\",\n          (int)GRN_TEXT_LEN(mode_name), GRN_TEXT_VALUE(mode_name));\n    }\n      GRN_OBJ_FIN(ctx, &tokens);\n    }\n#undef MODE_NAME_EQUAL\n    grn_obj_unlink(ctx, lexicon);\n  }\n  return NULL;\n"]]}
{"hexsha": "06f37f40689bcdce12f9fbe1bd269371b28841c8", "ext": "c", "lang": "C", "content": "void SetAbsTol(double hydrol_tol, double sminn_tol, N_Vector abstol)\n{\n    int             i;\n\n    /* Set absolute errors for hydrologic state variables */\n#if defined(_OPENMP)\n# pragma omp parallel for\n#endif\n    for (i = 0; i < 3 * nelem + 2 * nriver; i++)\n    {\n        NV_Ith(abstol, i) = (realtype)hydrol_tol;\n    }\n\n    /* Set absolute errors for nitrogen state variables */\n#if defined(_OPENMP)\n# pragma omp parallel for\n#endif\n    for (i = 3 * nelem + 2 * nriver; i < NumStateVar(); i++)\n    {\n        NV_Ith(abstol, i) = (realtype)sminn_tol;\n    }\n}", "item_id": 3, "repo": "Wei-PSU/MM-PIHM", "file": "src/ode.c", "last_update_at": "2021-02-01T13:01:41+00:00", "question_id": "06f37f40689bcdce12f9fbe1bd269371b28841c8_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void SetAbsTol(double hydrol_tol, double sminn_tol, N_Vector abstol)\n{\n    int             i;\n    /* Set absolute errors for hydrologic state variables */\n#if defined(_OPENMP)\n# pragma omp parallel for\n#endif\n    for (i = 0; i < 3 * nelem + 2 * nriver; i++)\n    {\n        NV_Ith(abstol, i) = (realtype)hydrol_tol;\n    }\n    /* Set absolute errors for nitrogen state variables */\n#if defined(_OPENMP)\n# pragma omp parallel for\n#endif\n    for (i = 3 * nelem + 2 * nriver; i < NumStateVar(); i++)\n    {\n        NV_Ith(abstol, i) = (realtype)sminn_tol;\n    }\n"]]}
{"hexsha": "f7c43a999f32ac4c66962dad8fac5398365f4640", "ext": "c", "lang": "C", "content": "void f59(void) {\n    \tint32_t x305 = 13;\n\tint32_t x306 = 64981;\n\tstatic volatile int32_t x307 = INT32_MIN;\n\tvolatile int64_t x308 = 176824918832LL;\n\n    t59 = ((x305-x306)-(x307+x308));\n\n    if (t59 != -174677500152LL) { NG(); } else { ; }\n\t\n}", "item_id": 59, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test16.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "f7c43a999f32ac4c66962dad8fac5398365f4640_59", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f59(void) {\n    \tint32_t x305 = 13;\n\tint32_t x306 = 64981;\n\tstatic volatile int32_t x307 = INT32_MIN;\n\tvolatile int64_t x308 = 176824918832LL;\n    t59 = ((x305-x306)-(x307+x308));\n    if (t59 != -174677500152LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "c71f6e3ca8c5b140d1cba6627962b09b758658dc", "ext": "c", "lang": "C", "content": "int fly_listen_connected(fly_event_t *e)\n{\n#ifdef DEBUG\n\tprintf(\"WORKER: Listen socket is connected\\n\");\n#endif\n\tfly_connect_t *conn;\n\tfly_request_t *req;\n\n\t//conn = (fly_connect_t *) e->event_data;\n\tconn = (fly_connect_t *) fly_event_data_get(e, __p);\n\te->read_or_write = FLY_READ;\n\t/* event only modify (no add, no delete) */\n\te->flag = FLY_MODIFY;\n\te->tflag = FLY_INHERIT;\n\te->eflag = 0;\n\t//e->event_state = (void *) EFLY_REQUEST_STATE_INIT;\n\t//e->event_fase = (void *) EFLY_REQUEST_FASE_INIT;\n\tfly_event_state_set(e, __e, EFLY_REQUEST_STATE_INIT);\n\tfly_event_fase_set(e, __e, EFLY_REQUEST_FASE_INIT);\n\tfly_event_socket(e);\n\n\tswitch(FLY_CONNECT_HTTP_VERSION(conn)){\n\tcase V1_1:\n#ifdef DEBUG\n\tprintf(\"WORKER: Start HTTP1.1 communication\\n\");\n#endif\n\t\treq = fly_request_init(conn);\n\t\tif (fly_unlikely_null(req)){\n\t\t\tstruct fly_err *__err;\n\t\t\t__err = fly_event_err_init(\n\t\t\t\te, errno, FLY_ERR_ERR,\n\t\t\t\t\"request init error.\"\n\t\t\t);\n\t\t\tfly_event_error_add(e, __err);\n\t\t\treturn -1;\n\t\t}\n\t\tfly_event_data_set(e, __p, (void *) req);\n\t\t//e->event_data = (void *) req;\n\n\t\te->fail_close = fly_request_fail_close_handler;\n\t\tFLY_EVENT_EXPIRED_END_HANDLER(e, fly_request_timeout_handler, req);\n\t\treturn fly_request_event_handler(e);\n\tcase V2:\n#ifdef DEBUG\n\tprintf(\"WORKER: Start HTTP2 communication\\n\");\n#endif\n\t\t//e->event_data = (void *) conn;\n\t\tfly_event_data_set(e, __p, conn);\n\t\tFLY_EVENT_END_HANDLER(e, fly_hv2_end_handle, conn);\n\t\tFLY_EVENT_EXPIRED_HANDLER(e, fly_hv2_timeout_handle, conn);\n\t\treturn fly_hv2_init_handler(e);\n\tdefault:\n\t\tFLY_NOT_COME_HERE\n\t}\n}", "item_id": 4, "repo": "tatsuya4649/fly", "file": "src/connect.c", "last_update_at": "2021-12-07T07:25:17+00:00", "question_id": "c71f6e3ca8c5b140d1cba6627962b09b758658dc_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int fly_listen_connected(fly_event_t *e)\n{\n#ifdef DEBUG\n\tprintf(\"WORKER: Listen socket is connected\\n\");\n#endif\n\tfly_connect_t *conn;\n\tfly_request_t *req;\n\t//conn = (fly_connect_t *) e->event_data;\n\tconn = (fly_connect_t *) fly_event_data_get(e, __p);\n\te->read_or_write = FLY_READ;\n\t/* event only modify (no add, no delete) */\n\te->flag = FLY_MODIFY;\n\te->tflag = FLY_INHERIT;\n\te->eflag = 0;\n\t//e->event_state = (void *) EFLY_REQUEST_STATE_INIT;\n\t//e->event_fase = (void *) EFLY_REQUEST_FASE_INIT;\n\tfly_event_state_set(e, __e, EFLY_REQUEST_STATE_INIT);\n\tfly_event_fase_set(e, __e, EFLY_REQUEST_FASE_INIT);\n\tfly_event_socket(e);\n\tswitch(FLY_CONNECT_HTTP_VERSION(conn)){\n\tcase V1_1:\n#ifdef DEBUG\n\tprintf(\"WORKER: Start HTTP1.1 communication\\n\");\n#endif\n\t\treq = fly_request_init(conn);\n\t\tif (fly_unlikely_null(req)){\n\t\t\tstruct fly_err *__err;\n\t\t\t__err = fly_event_err_init(\n\t\t\t\te, errno, FLY_ERR_ERR,\n\t\t\t\t\"request init error.\"\n\t\t\t);\n\t\t\tfly_event_error_add(e, __err);\n\t\t\treturn -1;\n\t\t}\n\t\tfly_event_data_set(e, __p, (void *) req);\n\t\t//e->event_data = (void *) req;\n\t\te->fail_close = fly_request_fail_close_handler;\n\t\tFLY_EVENT_EXPIRED_END_HANDLER(e, fly_request_timeout_handler, req);\n\t\treturn fly_request_event_handler(e);\n\tcase V2:\n#ifdef DEBUG\n\tprintf(\"WORKER: Start HTTP2 communication\\n\");\n#endif\n\t\t//e->event_data = (void *) conn;\n\t\tfly_event_data_set(e, __p, conn);\n\t\tFLY_EVENT_END_HANDLER(e, fly_hv2_end_handle, conn);\n\t\tFLY_EVENT_EXPIRED_HANDLER(e, fly_hv2_timeout_handle, conn);\n\t\treturn fly_hv2_init_handler(e);\n\tdefault:\n\t\tFLY_NOT_COME_HERE\n\t}\n"]]}
{"hexsha": "ee1ce9ea03c55025da3a88c1bcfb6b9b69edf3f1", "ext": "c", "lang": "C", "content": "void grab(string str) {\n   if(str != \"kit\" && str != \"makeup\") {\n      tell_object(TP,\"No grabbing that! Go for the kit.\");\n      return 1;\n   }\n   new(\"/realms/crystal/obj/makeup\")->move(TP);\n   return 1;\n}", "item_id": 3, "repo": "Dbevan/SunderingShadows", "file": "d/dagger/avaboard2.c", "last_update_at": "2021-11-18T04:08:19+00:00", "question_id": "ee1ce9ea03c55025da3a88c1bcfb6b9b69edf3f1_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void grab(string str) {\n   if(str != \"kit\" && str != \"makeup\") {\n      tell_object(TP,\"No grabbing that! Go for the kit.\");\n      return 1;\n   }\n   new(\"/realms/crystal/obj/makeup\")->move(TP);\n   return 1;\n"]]}
{"hexsha": "0023cda653568aee28944d42bb5c4d2a61260819", "ext": "c", "lang": "C", "content": "void\r\nputu(FILE*pf, TCHAR c)\r\n{\r\n    TCHAR chr=c;\r\n\r\n    if( REVERSE )\r\n        chr= ( c<<8 ) + ( ( c>>8 ) &0xFF);\r\n\r\n\r\n\tfwrite((void*)&chr, 1, sizeof(TCHAR), pf);\r\n}", "item_id": 0, "repo": "King0987654/windows2000", "file": "private/windows/shell/accesory/notepad/mkuni/mkuni.c", "last_update_at": "2021-09-16T09:13:13+00:00", "question_id": "0023cda653568aee28944d42bb5c4d2a61260819_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\r\nputu(FILE*pf, TCHAR c)\r\n{\r\n    TCHAR chr=c;\r\n\r\n    if( REVERSE )\r\n        chr= ( c<<8 ) + ( ( c>>8 ) &0xFF);\r\n\r\n\r\n\tfwrite((void*)&chr, 1, sizeof(TCHAR), pf);\r\n"]]}
{"hexsha": "8ad70c405bd6ec2824dc6b0d8ce4d00532543551", "ext": "c", "lang": "C", "content": "double binomial(int n, int k) {\r\n\tif(n==0&&k==0) return 1;\r\n\telse if(k<0) return 0;\r\n\telse if(n<0) return 1;\r\n\telse if(n==0&&k!=0) return 0;\r\n\r\n  double numerator;\r\n  double denominator;\r\n  int i;\r\n  if(k>n) return 0;\r\n  if(k > n/2) k = n-k;\r\n  numerator = 1.0;\r\n  denominator = 1.0;\r\n  for(i = n-k+1; i <= n; i++) numerator *= (double)i;\r\n  for(i = 2; i <= k; i++) denominator *= (double)i;\r\n  return numerator/denominator;\r\n}", "item_id": 11, "repo": "jbringewatt/PolyTimeAlgorithmsforAQC", "file": "Codes/TBSolver_GroverWithPriorsFinal.c", "last_update_at": "2021-05-18T04:26:55+00:00", "question_id": "8ad70c405bd6ec2824dc6b0d8ce4d00532543551_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["double binomial(int n, int k) {\r\n\tif(n==0&&k==0) return 1;\r\n\telse if(k<0) return 0;\r\n\telse if(n<0) return 1;\r\n\telse if(n==0&&k!=0) return 0;\r\n\r\n  double numerator;\r\n  double denominator;\r\n  int i;\r\n  if(k>n) return 0;\r\n  if(k > n/2) k = n-k;\r\n  numerator = 1.0;\r\n  denominator = 1.0;\r\n  for(i = n-k+1; i <= n; i++) numerator *= (double)i;\r\n  for(i = 2; i <= k; i++) denominator *= (double)i;\r\n  return numerator/denominator;\r\n"]]}
{"hexsha": "8422707813c3e82146aad7839d40ce8f0c0f2a6e", "ext": "c", "lang": "C", "content": "void f29(void) {\n    \tint64_t x121 = -1LL;\n\tint16_t x122 = INT16_MIN;\n\tuint64_t x123 = 116579606282272LLU;\n\tint8_t x124 = INT8_MAX;\n\tstatic volatile int32_t t29 = -603360940;\n\n    t29 = ((x121<=x122)==(x123%x124));\n\n    if (t29 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 29, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test918.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "8422707813c3e82146aad7839d40ce8f0c0f2a6e_29", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f29(void) {\n    \tint64_t x121 = -1LL;\n\tint16_t x122 = INT16_MIN;\n\tuint64_t x123 = 116579606282272LLU;\n\tint8_t x124 = INT8_MAX;\n\tstatic volatile int32_t t29 = -603360940;\n    t29 = ((x121<=x122)==(x123%x124));\n    if (t29 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "76a544a06c0e07eef278720c044c9780ad998764", "ext": "c", "lang": "C", "content": "static void LOADBUFF(struct hle_t* hle, uint32_t UNUSED(w1), uint32_t w2)\n{\n    uint32_t address = get_address(hle, w2);\n\n    if (hle->alist_audio.count == 0)\n        return;\n\n    alist_load(hle, hle->alist_audio.in, address, hle->alist_audio.count);\n}", "item_id": 5, "repo": "aybe/lazyusf", "file": "rsp_hle/alist_audio.c", "last_update_at": "2021-06-04T01:49:19+00:00", "question_id": "76a544a06c0e07eef278720c044c9780ad998764_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void LOADBUFF(struct hle_t* hle, uint32_t UNUSED(w1), uint32_t w2)\n{\n    uint32_t address = get_address(hle, w2);\n    if (hle->alist_audio.count == 0)\n        return;\n    alist_load(hle, hle->alist_audio.in, address, hle->alist_audio.count);\n"]]}
{"hexsha": "643064d04fcda863d3abe77f82ddb98e1fc66f3b", "ext": "c", "lang": "C", "content": "int main(int argc, char** argv) {\n    // input\n    int iat, nat = 8;\n    int atomic_number[8] = { 1, 6, 7, 8, 1, 6, 8, 7 };\n    int atom_basis[8]    = { 0, 0, 0, 0, 1, 1, 1, 1 };\n    int ibs, nsbs = 2;\n    char *basis_name[] = {\"STO-3G\", \"6-31G*\" };\n    // output\n    int ncs, nao, nps, maxlqn;\n    int *ushel_lqn, *ushel_tem, *ushel_atm;\n    int *ushel_add, *ushel_ini;\n    double *uprim_exp, *uprim_coe;\n\n    printf(\"------------------- INPUT DATA ------------------------\\n\");\n    printf(\"# of kind of basis set = %d\\n\", nsbs );\n    printf(\"basis name list = \");\n    for ( ibs=0; ibs<nsbs; ibs++ ) printf(\" %s\", basis_name[ibs] );\n    printf(\"\\n\");\n    printf(\"# of atom = %d\\n\", nat);\n    printf(\"atomic_number[] =\");\n    for (iat=0; iat<nat; iat++ )\n\tprintf(\"%s%2d\", ( (iat%10)==0 ? \"\\n  \" : \" \" ),\n\t\tatomic_number[iat] );\n    if ( (nat%10) != 0 ) printf(\"\\n\");\n    printf(\"atom_basis[] =\");\n    for (iat=0; iat<nat; iat++ )\n\tprintf(\"%s%2d\", ( (iat%10)==0 ? \"\\n  \" : \" \" ),\n\t\tatom_basis[iat] );\n    if ( (nat%10) != 0 ) printf(\"\\n\");\n    printf(\"-------------------------------------------------------\\n\");\n\n    if ( ofmo_get_basis_size(\n\t\tnat, nsbs, basis_name, atomic_number, atom_basis,\n\t\t&maxlqn, &ncs, &nao, &nps ) != 0 ) {\n\tdbg(\"error: Failure in ofmo_get_basis_size\\n\");\n\treturn -1;\n    }\n    if ( ofmo_alloc_unsorted_basis(ncs, nps, &ushel_lqn, &ushel_tem,\n\t\t&ushel_atm, &ushel_add, &ushel_ini, &uprim_exp, &uprim_coe)\n\t    != 0 ) {\n\tdbg(\"error: Failure in memory allocation for unsorted basis\\n\");\n\treturn -1;\n    }\n    if ( ofmo_assign_basis(\n\t\tnat, nsbs, basis_name, atomic_number, atom_basis,\n\t\tushel_lqn, ushel_tem, ushel_atm, ushel_add, ushel_ini,\n\t\tuprim_exp, uprim_coe ) != 0 ) {\n\tdbg(\"error: Failure in assignment basis parameters\\n\");\n\treturn -1;\n    }\n    ofmo_show_unsorted_basis_params( stdout, ncs,\n\t    ushel_lqn, ushel_tem, ushel_atm, ushel_add, ushel_ini,\n\t    uprim_exp, uprim_coe );\n    int *shel_tem, *shel_atm, *shel_add, *shel_ini, *leading_cs, *s2u;\n    double *prim_exp, *prim_coe;\n    if ( ofmo_alloc_sorted_basis(maxlqn, ncs, nao, nps,\n\t\t&leading_cs, &shel_tem, &shel_atm, &shel_add, &shel_ini,\n\t\t&prim_exp, &prim_coe, &s2u ) != 0 ) {\n\tdbg(\"error: Failure in memory allocation for sorted basis\\n\");\n\treturn -1;\n    }\n    if ( ofmo_sort_basis( maxlqn, ncs,\n\t\tushel_lqn, ushel_tem, ushel_atm, ushel_add, ushel_ini,\n\t\tuprim_exp, uprim_coe,\n\t\tleading_cs, shel_tem, shel_atm, shel_add, shel_ini,\n\t\tprim_exp, prim_coe, s2u ) != 0 ) {\n\tdbg(\"error: failure in sort basis parameters\\n\");\n\treturn -1;\n    }\n    ofmo_show_sorted_basis_params( stdout, maxlqn, nao,\n\t    leading_cs, shel_tem, shel_atm, shel_add, shel_ini,\n\t    prim_exp, prim_coe, s2u );\n    return 0;\n}", "item_id": 14, "repo": "JorgeG94/OpenFMO", "file": "basis/ofmo-basis.c", "last_update_at": "2021-06-29T14:40:59+00:00", "question_id": "643064d04fcda863d3abe77f82ddb98e1fc66f3b_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char** argv) {\n    // input\n    int iat, nat = 8;\n    int atomic_number[8] = { 1, 6, 7, 8, 1, 6, 8, 7 };\n    int atom_basis[8]    = { 0, 0, 0, 0, 1, 1, 1, 1 };\n    int ibs, nsbs = 2;\n    char *basis_name[] = {\"STO-3G\", \"6-31G*\" };\n    // output\n    int ncs, nao, nps, maxlqn;\n    int *ushel_lqn, *ushel_tem, *ushel_atm;\n    int *ushel_add, *ushel_ini;\n    double *uprim_exp, *uprim_coe;\n    printf(\"------------------- INPUT DATA ------------------------\\n\");\n    printf(\"# of kind of basis set = %d\\n\", nsbs );\n    printf(\"basis name list = \");\n    for ( ibs=0; ibs<nsbs; ibs++ ) printf(\" %s\", basis_name[ibs] );\n    printf(\"\\n\");\n    printf(\"# of atom = %d\\n\", nat);\n    printf(\"atomic_number[] =\");\n    for (iat=0; iat<nat; iat++ )\n\tprintf(\"%s%2d\", ( (iat%10)==0 ? \"\\n  \" : \" \" ),\n\t\tatomic_number[iat] );\n    if ( (nat%10) != 0 ) printf(\"\\n\");\n    printf(\"atom_basis[] =\");\n    for (iat=0; iat<nat; iat++ )\n\tprintf(\"%s%2d\", ( (iat%10)==0 ? \"\\n  \" : \" \" ),\n\t\tatom_basis[iat] );\n    if ( (nat%10) != 0 ) printf(\"\\n\");\n    printf(\"-------------------------------------------------------\\n\");\n    if ( ofmo_get_basis_size(\n\t\tnat, nsbs, basis_name, atomic_number, atom_basis,\n\t\t&maxlqn, &ncs, &nao, &nps ) != 0 ) {\n\tdbg(\"error: Failure in ofmo_get_basis_size\\n\");\n\treturn -1;\n    }\n    if ( ofmo_alloc_unsorted_basis(ncs, nps, &ushel_lqn, &ushel_tem,\n\t\t&ushel_atm, &ushel_add, &ushel_ini, &uprim_exp, &uprim_coe)\n\t    != 0 ) {\n\tdbg(\"error: Failure in memory allocation for unsorted basis\\n\");\n\treturn -1;\n    }\n    if ( ofmo_assign_basis(\n\t\tnat, nsbs, basis_name, atomic_number, atom_basis,\n\t\tushel_lqn, ushel_tem, ushel_atm, ushel_add, ushel_ini,\n\t\tuprim_exp, uprim_coe ) != 0 ) {\n\tdbg(\"error: Failure in assignment basis parameters\\n\");\n\treturn -1;\n    }\n    ofmo_show_unsorted_basis_params( stdout, ncs,\n\t    ushel_lqn, ushel_tem, ushel_atm, ushel_add, ushel_ini,\n\t    uprim_exp, uprim_coe );\n    int *shel_tem, *shel_atm, *shel_add, *shel_ini, *leading_cs, *s2u;\n    double *prim_exp, *prim_coe;\n    if ( ofmo_alloc_sorted_basis(maxlqn, ncs, nao, nps,\n\t\t&leading_cs, &shel_tem, &shel_atm, &shel_add, &shel_ini,\n\t\t&prim_exp, &prim_coe, &s2u ) != 0 ) {\n\tdbg(\"error: Failure in memory allocation for sorted basis\\n\");\n\treturn -1;\n    }\n    if ( ofmo_sort_basis( maxlqn, ncs,\n\t\tushel_lqn, ushel_tem, ushel_atm, ushel_add, ushel_ini,\n\t\tuprim_exp, uprim_coe,\n\t\tleading_cs, shel_tem, shel_atm, shel_add, shel_ini,\n\t\tprim_exp, prim_coe, s2u ) != 0 ) {\n\tdbg(\"error: failure in sort basis parameters\\n\");\n\treturn -1;\n    }\n    ofmo_show_sorted_basis_params( stdout, maxlqn, nao,\n\t    leading_cs, shel_tem, shel_atm, shel_add, shel_ini,\n\t    prim_exp, prim_coe, s2u );\n    return 0;\n"]]}
{"hexsha": "44e6bf14415ca519369ab1bab2934a2ce10e7d40", "ext": "c", "lang": "C", "content": "void f139(void) {\n    \tuint8_t x557 = 1U;\n\tuint64_t x558 = 261236344424517LLU;\n\tuint8_t x559 = UINT8_MAX;\n\tuint8_t x560 = 93U;\n\n    t139 = (x557&(x558<=(x559<=x560)));\n\n    if (t139 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 139, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test1902.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "44e6bf14415ca519369ab1bab2934a2ce10e7d40_139", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f139(void) {\n    \tuint8_t x557 = 1U;\n\tuint64_t x558 = 261236344424517LLU;\n\tuint8_t x559 = UINT8_MAX;\n\tuint8_t x560 = 93U;\n    t139 = (x557&(x558<=(x559<=x560)));\n    if (t139 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "83f3f9f5bd51ab59c6e46215b4f7f280a9d12828", "ext": "c", "lang": "C", "content": "void setBndCnd(double* q, int cndL, int cndH, int np, int nt){\n  int i;\n  int pI,tI;\n  int wInd, rInd;\n\n\n  //printf(\"Running bnd cnds for %dx%d prims\\n\",np,nt);\n#pragma omp parallel for private(i,pI,tI,wInd,rInd) shared(q,cndL,cndH,np,nt,Hp,Ha)\n  for(i=0;i<2*nt;i++){\n    pI=i%2;\n    tI=i/2;\n    wInd=pI+(np+4)*tI;\n    rInd=3-pI+(np+4)*tI;\n    //printf(\"BND: %d refs %d\\n\",wInd,rInd);\n    if(cndL==BND_REFL){\n      q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];\n      q[wInd+(np+4)*nt*VARVX ]=-q[rInd+(np+4)*nt*VARVX ];\n      q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];\n      q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];\n    }else if(cndL==BND_PERM){\n      q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];\n      q[wInd+(np+4)*nt*VARVX ]= q[rInd+(np+4)*nt*VARVX ];\n      q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];\n      q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];\n    }\n    wInd=np+2+pI+(np+4)*tI;\n    rInd=np+1-pI+(np+4)*tI;\n    //printf(\"BND: %d refs %d\\n\",wInd,rInd);\n    if(cndH==BND_REFL){\n      q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];\n      q[wInd+(np+4)*nt*VARVX ]=-q[rInd+(np+4)*nt*VARVX ];\n      q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];\n      q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];\n    }else if(cndH==BND_PERM){\n      q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];\n      q[wInd+(np+4)*nt*VARVX ]= q[rInd+(np+4)*nt*VARVX ];\n      q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];\n      q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];\n    }\n  }\n}", "item_id": 4, "repo": "samuelkgutierrez/CODY", "file": "MISH/hydro_c_omp/hydro.c", "last_update_at": "2021-09-02T14:58:12+00:00", "question_id": "83f3f9f5bd51ab59c6e46215b4f7f280a9d12828_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void setBndCnd(double* q, int cndL, int cndH, int np, int nt){\n  int i;\n  int pI,tI;\n  int wInd, rInd;\n  //printf(\"Running bnd cnds for %dx%d prims\\n\",np,nt);\n#pragma omp parallel for private(i,pI,tI,wInd,rInd) shared(q,cndL,cndH,np,nt,Hp,Ha)\n  for(i=0;i<2*nt;i++){\n    pI=i%2;\n    tI=i/2;\n    wInd=pI+(np+4)*tI;\n    rInd=3-pI+(np+4)*tI;\n    //printf(\"BND: %d refs %d\\n\",wInd,rInd);\n    if(cndL==BND_REFL){\n      q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];\n      q[wInd+(np+4)*nt*VARVX ]=-q[rInd+(np+4)*nt*VARVX ];\n      q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];\n      q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];\n    }else if(cndL==BND_PERM){\n      q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];\n      q[wInd+(np+4)*nt*VARVX ]= q[rInd+(np+4)*nt*VARVX ];\n      q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];\n      q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];\n    }\n    wInd=np+2+pI+(np+4)*tI;\n    rInd=np+1-pI+(np+4)*tI;\n    //printf(\"BND: %d refs %d\\n\",wInd,rInd);\n    if(cndH==BND_REFL){\n      q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];\n      q[wInd+(np+4)*nt*VARVX ]=-q[rInd+(np+4)*nt*VARVX ];\n      q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];\n      q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];\n    }else if(cndH==BND_PERM){\n      q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];\n      q[wInd+(np+4)*nt*VARVX ]= q[rInd+(np+4)*nt*VARVX ];\n      q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];\n      q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];\n    }\n  }\n"]]}
{"hexsha": "150218f8637bc265e15d3ada3ee02067f51b2ebf", "ext": "c", "lang": "C", "content": "void f105(void) {\n    \tint64_t x421 = 38524824230670LL;\n\tint64_t x422 = INT64_MIN;\n\tstatic volatile uint16_t x423 = UINT16_MAX;\n\tstatic int8_t x424 = -1;\n\tint64_t t105 = 14829LL;\n\n    t105 = ((x421^x422)*(x423<=x424));\n\n    if (t105 != 0LL) { NG(); } else { ; }\n\t\n}", "item_id": 105, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1949.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "150218f8637bc265e15d3ada3ee02067f51b2ebf_105", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f105(void) {\n    \tint64_t x421 = 38524824230670LL;\n\tint64_t x422 = INT64_MIN;\n\tstatic volatile uint16_t x423 = UINT16_MAX;\n\tstatic int8_t x424 = -1;\n\tint64_t t105 = 14829LL;\n    t105 = ((x421^x422)*(x423<=x424));\n    if (t105 != 0LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "9db809e035b9fea03516680bb20c66db99b53912", "ext": "c", "lang": "C", "content": "static ssize_t procfile_read(struct file *filePointer, char __user *buffer,\n                             size_t buffer_length, loff_t *offset)\n{\n    char s[13] = \"HelloWorld!\\n\";\n    int len = sizeof(s);\n    ssize_t ret = len;\n\n    if (*offset >= len || copy_to_user(buffer, s, len)) {\n        pr_info(\"copy_to_user failed\\n\");\n        ret = 0;\n    } else {\n        pr_info(\"procfile read %s\\n\", filePointer->f_path.dentry->d_name.name);\n        *offset += len;\n    }\n\n    return ret;\n}", "item_id": 0, "repo": "yifengyou/lkd", "file": "procfs-read/src/procfs1.c", "last_update_at": "2021-09-29T01:24:09+00:00", "question_id": "9db809e035b9fea03516680bb20c66db99b53912_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static ssize_t procfile_read(struct file *filePointer, char __user *buffer,\n                             size_t buffer_length, loff_t *offset)\n{\n    char s[13] = \"HelloWorld!\\n\";\n    int len = sizeof(s);\n    ssize_t ret = len;\n    if (*offset >= len || copy_to_user(buffer, s, len)) {\n        pr_info(\"copy_to_user failed\\n\");\n        ret = 0;\n    } else {\n        pr_info(\"procfile read %s\\n\", filePointer->f_path.dentry->d_name.name);\n        *offset += len;\n    }\n    return ret;\n"]]}
{"hexsha": "c8dbe11528158bacebf8a227652268657c881625", "ext": "c", "lang": "C", "content": "void bkgndBLEMeshStack_app(void)\r\n{\r\n  struct gecko_msg_mesh_prov_create_network_rsp_t *new_netkey_rsp;\r\n  struct gecko_msg_mesh_prov_create_appkey_rsp_t *new_appkey_rsp;\r\n  struct gecko_msg_mesh_prov_device_provisioned_evt_t *prov_evt;\r\n  struct gecko_msg_mesh_config_client_get_dcd_rsp_t* get_dcd_result;\r\n  struct gecko_msg_mesh_config_client_dcd_data_evt_t *pDCD;\r\n  struct gecko_msg_mesh_config_client_add_appkey_rsp_t *appkey_deploy_evt;\r\n  struct gecko_msg_mesh_config_client_bind_model_rsp_t *model_app_bind_result;\r\n  struct gecko_msg_mesh_config_client_set_model_pub_rsp_t *model_pub_set_result;\r\n  struct gecko_msg_mesh_config_client_add_model_sub_rsp_t *model_sub_add_result;\r\n  uint16 result;\r\n  uint8 idx; /* j short array index */\r\n  int8 dev_idx; /* device */\r\n  uint16 vendor_id;\r\n  uint16 model_id;\r\n  uint16 pub_address;\r\n\r\n  /* Init local variables */\r\n  result=0;\r\n\r\n  /* event handling */\r\n  struct gecko_cmd_packet *evt = gecko_wait_event();\r\n  bool pass = mesh_bgapi_listener(evt);\r\n  if (pass /*&& event_is_not_deprecated(evt)*/) {\r\n    switch (BGLIB_MSG_ID(evt->header)) {\r\n      case gecko_evt_system_boot_id:\r\n        /* Initialize Mesh stack in Node operation mode, wait for initialized event */\r\n        if(0 != gecko_cmd_mesh_prov_init()->result)\r\n        {\r\n          /* Something went wrong */\r\n          printf(\"gecko_cmd_mesh_prov_init failed\\n\\r\");\r\n        }\r\n\r\n        break;\r\n      case gecko_evt_mesh_prov_initialized_id:\r\n        new_netkey_rsp = gecko_cmd_mesh_prov_create_network(16, fixed_netkey);\r\n        if(0 != new_netkey_rsp->result)\r\n        {\r\n          /* Something went wrong */\r\n          printf(\"gecko_cmd_mesh_prov_create_network: failed 0x%.2x\\n\\r\",new_netkey_rsp->result);\r\n        }\r\n        else\r\n        {\r\n          network_id=new_netkey_rsp->network_id;\r\n          printf(\"Success, netkey id = %x\\r\\n\", new_netkey_rsp->network_id);\r\n        }\r\n        new_appkey_rsp = gecko_cmd_mesh_prov_create_appkey(new_netkey_rsp->network_id, 16, &fixed_appkey[0]);\r\n\r\n        if(0 != new_appkey_rsp->result)\r\n        {\r\n          /* Something went wrong */\r\n          printf(\"gecko_cmd_mesh_prov_create_appkey: failed 0x%.2x\\n\\r\",new_appkey_rsp->result);\r\n        }\r\n        else\r\n        {\r\n          appkey_index=new_appkey_rsp->appkey_index;\r\n          printf(\"Success, appkey id = %x\\r\\n\", new_appkey_rsp->appkey_index);\r\n        }\r\n\r\n        /* Networks  */\r\n        printf(\"networks: 0x%x \",evt->data.evt_mesh_prov_initialized.networks);\r\n\r\n        /* address */\r\n        printf(\"address: 0x%x \",evt->data.evt_mesh_prov_initialized.address);\r\n\r\n        /* ivi  */\r\n        printf(\"ivi: 0x%lx\",evt->data.evt_mesh_prov_initialized.ivi);\r\n        printf(\"\\n\\r\");\r\n\r\n        /* Scan for unprovisioned beacons */\r\n        result=gecko_cmd_mesh_prov_scan_unprov_beacons()->result;\r\n\r\n        break;\r\n      case gecko_evt_mesh_prov_unprov_beacon_id:\r\n\r\n        /* PB-ADV only */\r\n        if(0 == evt->data.evt_mesh_prov_unprov_beacon.bearer)\r\n        {\r\n          /* Get BT mesh device index */\r\n          dev_idx = IsDevPresent( &evt->data.evt_mesh_prov_unprov_beacon.address.addr[0]);\r\n\r\n          /* fill up btmesh device struct */\r\n          if( 0 > dev_idx )\r\n          {\r\n            /* Device is not present */\r\n            for(idx=0;idx<MAX_NUM_BTMESH_DEV;idx++)\r\n            {\r\n              if(   ( 0x00 == bluetooth_device_table[idx].address[0] )\r\n                 && ( 0x00 == bluetooth_device_table[idx].address[1] )\r\n                 && ( 0x00 == bluetooth_device_table[idx].address[2] )\r\n                 && ( 0x00 == bluetooth_device_table[idx].address[3] )\r\n                 && ( 0x00 == bluetooth_device_table[idx].address[4] )\r\n                 && ( 0x00 == bluetooth_device_table[idx].address[5] )\r\n                )\r\n              {\r\n                memcpy(&bluetooth_device_table[idx].address[0],&evt->data.evt_mesh_prov_unprov_beacon.address.addr[0],BLE_ADDR_LEN_BYTE);\r\n                memcpy(&bluetooth_device_table[idx].uuid[0],&evt->data.evt_mesh_prov_unprov_beacon.uuid.data[0],BLE_MESH_UUID_LEN_BYTE);\r\n\r\n                /* Display info banner */\r\n                printf(\"URI hash: 0x%lx \",evt->data.evt_mesh_prov_unprov_beacon.uri_hash);\r\n                printf(\"bearer: 0x%x \",evt->data.evt_mesh_prov_unprov_beacon.bearer);\r\n                printf(\"address: 0x%x:0x%x:0x%x:0x%x:0x%x:0x%x \",bluetooth_device_table[idx].address[0],\r\n                                                                 bluetooth_device_table[idx].address[1],\r\n                                                                 bluetooth_device_table[idx].address[2],\r\n                                                                 bluetooth_device_table[idx].address[3],\r\n                                                                 bluetooth_device_table[idx].address[4],\r\n                                                                 bluetooth_device_table[idx].address[5]);\r\n                printf(\"UUID: 0x%x:0x%x:0x%x:0x%x:0x%x:0x%x \",bluetooth_device_table[idx].uuid[0],\r\n                                                              bluetooth_device_table[idx].uuid[1],\r\n                                                              bluetooth_device_table[idx].uuid[2],\r\n                                                              bluetooth_device_table[idx].uuid[3],\r\n                                                              bluetooth_device_table[idx].uuid[4],\r\n                                                              bluetooth_device_table[idx].uuid[5]);\r\n                printf(\"address type: 0x%x\",evt->data.evt_mesh_prov_unprov_beacon.address_type);\r\n                printf(\"\\n\\r\");\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        break;\r\n      /* Provisioning */\r\n      case gecko_evt_mesh_prov_provisioning_failed_id:\r\n        printf(\"provisioning failed\\n\\r\");\r\n        break;\r\n      case gecko_evt_mesh_prov_device_provisioned_id:\r\n\r\n        prov_evt = (struct gecko_msg_mesh_prov_device_provisioned_evt_t*)&(evt->data);\r\n\r\n        provisionee_addr = prov_evt->address;\r\n        printf(\"Node successfully provisioned. Address: %4.4x, \", provisionee_addr);\r\n\r\n        printf(\"uuid 0x\");\r\n        for (uint8_t i = 0; i < prov_evt->uuid.len; i++) printf(\"%02X\", prov_evt->uuid.data[i]);\r\n        printf(\"\\r\\n\");\r\n\r\n        printf(\" getting dcd ...\\n\\r\");\r\n\r\n        get_dcd_result = gecko_cmd_mesh_config_client_get_dcd(network_id, provisionee_addr, 0);\r\n        if (get_dcd_result->result == 0x0181) {\r\n          printf(\".\"); fflush(stdout);\r\n        } else if(get_dcd_result->result != 0x0){\r\n          printf(\"gecko_cmd_mesh_config_client_get_dcd failed with result 0x%X (%d) addr %x\\r\\n\", get_dcd_result->result, get_dcd_result->result, prov_evt->address);\r\n        }\r\n        else\r\n        {\r\n          printf(\"requesting DCD from the node...\\r\\n\");\r\n        }\r\n\r\n        break;\r\n\r\n      /* Config events */\r\n      case gecko_evt_mesh_config_client_dcd_data_id:\r\n        pDCD = (struct gecko_msg_mesh_config_client_dcd_data_evt_t *)&(evt->data);\r\n        printf(\"DCD data event, received %u bytes\\r\\n\", pDCD->data.len);\r\n\r\n        // copy the data into one large array. the data may come in multiple smaller pieces.\r\n        // the data is not decoded until all DCD events have been received (see below)\r\n        if((_dcd_raw_len + pDCD->data.len) <= 256)\r\n        {\r\n          memcpy(&(_dcd_raw[_dcd_raw_len]), pDCD->data.data, pDCD->data.len);\r\n          _dcd_raw_len += pDCD->data.len;\r\n        }\r\n\r\n        break;\r\n      case gecko_evt_le_connection_opened_id:\r\n        printf(\"LE connection opened\\r\\n\");\r\n        break;\r\n\r\n      case gecko_evt_mesh_config_client_dcd_data_end_id:\r\n        printf(\"DCD data end event. Decoding the data.\\r\\n\");\r\n        // decode the DCD content\r\n        DCD_decode();\r\n\r\n        // check the desired configuration settings depending on what's in the DCD\r\n        config_check();\r\n\r\n        appkey_deploy_evt = gecko_cmd_mesh_config_client_add_appkey(network_id, provisionee_addr, appkey_index, network_id);\r\n        if (appkey_deploy_evt->result == 0) {\r\n          printf(\"Deploying appkey to node 0x%4.4x\\r\\n\", provisionee_addr);\r\n        }else{\r\n          printf(\"Appkey deployment failed. addr %x, error: %x\\r\\n\", provisionee_addr, appkey_deploy_evt->result);\r\n        }\r\n\r\n        break;\r\n      case gecko_evt_mesh_config_client_appkey_status_id:\r\n        result = evt->data.evt_mesh_config_client_appkey_status.result;\r\n        if(result == 0)\r\n        {\r\n          printf(\" appkey added\\r\\n\");\r\n          /* move to next step which is binding appkey to models */\r\n\r\n          // take the next model from the list of models to be bound with application key.\r\n          // for simplicity, the same appkey is used for all models but it is possible to also use several appkeys\r\n          model_id = _sConfig.bind_model[_sConfig.num_bind_done].model_id;\r\n          vendor_id = _sConfig.bind_model[_sConfig.num_bind_done].vendor_id;\r\n\r\n          printf(\"APP BIND, config %d/%d:: model %4.4x key index %x\\r\\n\", _sConfig.num_bind_done+1, _sConfig.num_bind, model_id, appkey_index);\r\n\r\n          model_app_bind_result = gecko_cmd_mesh_config_client_bind_model( network_id, provisionee_addr, 0, // element index\r\n                                                                           appkey_index, vendor_id, model_id );\r\n        }\r\n        break;\r\n      case gecko_evt_mesh_config_client_binding_status_id:\r\n        result = evt->data.evt_mesh_config_client_appkey_status.result;\r\n        if(result == bg_err_success)\r\n        {\r\n          printf(\" bind complete\\r\\n\");\r\n          _sConfig.num_bind_done++;\r\n\r\n          if(_sConfig.num_bind_done < _sConfig.num_bind)\r\n          {\r\n            // take the next model from the list of models to be bound with application key.\r\n            // for simplicity, the same appkey is used for all models but it is possible to also use several appkeys\r\n            model_id = _sConfig.bind_model[_sConfig.num_bind_done].model_id;\r\n            vendor_id = _sConfig.bind_model[_sConfig.num_bind_done].vendor_id;\r\n\r\n            printf(\"APP BIND, config %d/%d:: model %4.4x key index %x\\r\\n\", _sConfig.num_bind_done+1, _sConfig.num_bind, model_id, appkey_index);\r\n\r\n            model_app_bind_result = gecko_cmd_mesh_config_client_bind_model( network_id, provisionee_addr, 0, // element index\r\n                                                                             appkey_index, vendor_id, model_id );\r\n          }\r\n          else\r\n          {\r\n            // get the next model/address pair from the configuration list:\r\n            model_id = _sConfig.pub_model[_sConfig.num_pub_done].model_id;\r\n            vendor_id = _sConfig.pub_model[_sConfig.num_pub_done].vendor_id;\r\n            pub_address = _sConfig.pub_address[_sConfig.num_pub_done];\r\n\r\n            printf(\"PUB SET, config %d/%d: model %4.4x -> address %4.4x\\r\\n\", _sConfig.num_pub_done+1, _sConfig.num_pub, model_id, pub_address);\r\n\r\n            model_pub_set_result = gecko_cmd_mesh_config_client_set_model_pub(network_id, provisionee_addr,\r\n              0, /* element index */\r\n              vendor_id,\r\n              model_id,\r\n              pub_address,\r\n              appkey_index,\r\n              0, /* friendship credential flag */\r\n              3, /* Publication time-to-live value */\r\n              0, /* period = NONE */\r\n              0, /* Publication retransmission count */\r\n              50  /* Publication retransmission interval */ );\r\n\r\n            if (model_pub_set_result->result == 0)\r\n            {\r\n              printf(\" waiting pub ack\\r\\n\");\r\n            }\r\n          }\r\n        }\r\n        else\r\n        {\r\n          printf(\" appkey bind failed with code \\r\\n\");\r\n        }\r\n        break;\r\n      case gecko_evt_mesh_config_client_model_pub_status_id:\r\n        result = evt->data.evt_mesh_config_client_model_pub_status.result;\r\n        if(result == bg_err_success)\r\n        {\r\n          printf(\" pub set OK\\r\\n\");\r\n          _sConfig.num_pub_done++;\r\n\r\n          if(_sConfig.num_pub_done < _sConfig.num_pub)\r\n          {\r\n            /* more publication settings to be done\r\n            ** get the next model/address pair from the configuration list: */\r\n            model_id = _sConfig.pub_model[_sConfig.num_pub_done].model_id;\r\n            vendor_id = _sConfig.pub_model[_sConfig.num_pub_done].vendor_id;\r\n            pub_address = _sConfig.pub_address[_sConfig.num_pub_done];\r\n\r\n            printf(\"PUB SET, config %d/%d: model %4.4x -> address %4.4x\\r\\n\", _sConfig.num_pub_done+1, _sConfig.num_pub, model_id, pub_address);\r\n\r\n            model_pub_set_result = gecko_cmd_mesh_config_client_set_model_pub(network_id, provisionee_addr,\r\n              0, /* element index */\r\n              vendor_id,\r\n              model_id,\r\n              pub_address,\r\n              appkey_index,\r\n              0, /* friendship credential flag */\r\n              3, /* Publication time-to-live value */\r\n              0, /* period = NONE */\r\n              0, /* Publication retransmission count */\r\n              50  /* Publication retransmission interval */ );\r\n          }\r\n          else\r\n          {\r\n            // move to next step which is configuring subscription settings\r\n            // get the next model/address pair from the configuration list:\r\n            model_id = _sConfig.sub_model[_sConfig.num_sub_done].model_id;\r\n            vendor_id = _sConfig.sub_model[_sConfig.num_sub_done].vendor_id;\r\n            sub_address = _sConfig.sub_address[_sConfig.num_sub_done];\r\n\r\n            printf(\"SUB ADD, config %d/%d: model %4.4x -> address %4.4x\\r\\n\", _sConfig.num_sub_done+1, _sConfig.num_sub, model_id, sub_address);\r\n\r\n            model_sub_add_result = gecko_cmd_mesh_config_client_add_model_sub(network_id, provisionee_addr, 0, vendor_id, model_id, sub_address);\r\n\r\n            if (model_sub_add_result->result == 0x00)\r\n            {\r\n              printf(\" waiting sub ack\\r\\n\");\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case gecko_evt_mesh_config_client_model_sub_status_id:\r\n        result = evt->data.evt_mesh_config_client_model_sub_status.result;\r\n        if(result == bg_err_success)\r\n        {\r\n          printf(\" sub add OK\\r\\n\");\r\n          _sConfig.num_sub_done++;\r\n          if(_sConfig.num_sub_done < _sConfig.num_sub)\r\n          {\r\n            // move to next step which is configuring subscription settings\r\n            // get the next model/address pair from the configuration list:\r\n            model_id = _sConfig.sub_model[_sConfig.num_sub_done].model_id;\r\n            vendor_id = _sConfig.sub_model[_sConfig.num_sub_done].vendor_id;\r\n            sub_address = _sConfig.sub_address[_sConfig.num_sub_done];\r\n\r\n            printf(\"SUB ADD, config %d/%d: model %4.4x -> address %4.4x\\r\\n\", _sConfig.num_sub_done+1, _sConfig.num_sub, model_id, sub_address);\r\n\r\n            model_sub_add_result = gecko_cmd_mesh_config_client_add_model_sub(network_id, provisionee_addr, 0, vendor_id, model_id, sub_address);\r\n\r\n            if (model_sub_add_result->result == 0x00)\r\n            {\r\n              printf(\" waiting sub ack\\r\\n\");\r\n            }\r\n          }\r\n          else\r\n          {\r\n            printf(\"***\\r\\nconfiguration complete\\r\\n***\\r\\n\");\r\n          }\r\n        }\r\n\r\n        break;\r\n      case gecko_evt_mesh_prov_dcd_status_id:\r\n        printf(\"dcd status received\\n\\r\");\r\n        break;\r\n      case gecko_evt_mesh_prov_config_status_id:\r\n        printf(\"prov config status\\n\\r\");\r\n        break;\r\n      case gecko_evt_le_gap_adv_timeout_id:\r\n        /* adv timeout events silently discarded */\r\n        break;\r\n      default:\r\n        printf(\"unhandled evt: %8.8x class %2.2x method %2.2x\\r\\n\", (unsigned int)BGLIB_MSG_ID(evt->header),\r\n                                                                    (unsigned int)((BGLIB_MSG_ID(evt->header) >> 16) & 0xFF),\r\n                                                                    (unsigned int)((BGLIB_MSG_ID(evt->header) >> 24) & 0xFF) );\r\n\r\n        if(model_app_bind_result->result  == 0x0000)\r\n        {\r\n          printf(\" waiting bind ack\\r\\n\");\r\n        }\r\n\r\n        break;\r\n    }\r\n  }\r\n\r\n  return;\r\n}", "item_id": 4, "repo": "forrestan/bluetooth_mesh_stack_features", "file": "provisioning/embedded_provisioner/app.c", "last_update_at": "2021-08-25T11:10:08+00:00", "question_id": "c8dbe11528158bacebf8a227652268657c881625_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void bkgndBLEMeshStack_app(void)\r\n{\r\n  struct gecko_msg_mesh_prov_create_network_rsp_t *new_netkey_rsp;\r\n  struct gecko_msg_mesh_prov_create_appkey_rsp_t *new_appkey_rsp;\r\n  struct gecko_msg_mesh_prov_device_provisioned_evt_t *prov_evt;\r\n  struct gecko_msg_mesh_config_client_get_dcd_rsp_t* get_dcd_result;\r\n  struct gecko_msg_mesh_config_client_dcd_data_evt_t *pDCD;\r\n  struct gecko_msg_mesh_config_client_add_appkey_rsp_t *appkey_deploy_evt;\r\n  struct gecko_msg_mesh_config_client_bind_model_rsp_t *model_app_bind_result;\r\n  struct gecko_msg_mesh_config_client_set_model_pub_rsp_t *model_pub_set_result;\r\n  struct gecko_msg_mesh_config_client_add_model_sub_rsp_t *model_sub_add_result;\r\n  uint16 result;\r\n  uint8 idx; /* j short array index */\r\n  int8 dev_idx; /* device */\r\n  uint16 vendor_id;\r\n  uint16 model_id;\r\n  uint16 pub_address;\r\n\r\n  /* Init local variables */\r\n  result=0;\r\n\r\n  /* event handling */\r\n  struct gecko_cmd_packet *evt = gecko_wait_event();\r\n  bool pass = mesh_bgapi_listener(evt);\r\n  if (pass /*&& event_is_not_deprecated(evt)*/) {\r\n    switch (BGLIB_MSG_ID(evt->header)) {\r\n      case gecko_evt_system_boot_id:\r\n        /* Initialize Mesh stack in Node operation mode, wait for initialized event */\r\n        if(0 != gecko_cmd_mesh_prov_init()->result)\r\n        {\r\n          /* Something went wrong */\r\n          printf(\"gecko_cmd_mesh_prov_init failed\\n\\r\");\r\n        }\r\n\r\n        break;\r\n      case gecko_evt_mesh_prov_initialized_id:\r\n        new_netkey_rsp = gecko_cmd_mesh_prov_create_network(16, fixed_netkey);\r\n        if(0 != new_netkey_rsp->result)\r\n        {\r\n          /* Something went wrong */\r\n          printf(\"gecko_cmd_mesh_prov_create_network: failed 0x%.2x\\n\\r\",new_netkey_rsp->result);\r\n        }\r\n        else\r\n        {\r\n          network_id=new_netkey_rsp->network_id;\r\n          printf(\"Success, netkey id = %x\\r\\n\", new_netkey_rsp->network_id);\r\n        }\r\n        new_appkey_rsp = gecko_cmd_mesh_prov_create_appkey(new_netkey_rsp->network_id, 16, &fixed_appkey[0]);\r\n\r\n        if(0 != new_appkey_rsp->result)\r\n        {\r\n          /* Something went wrong */\r\n          printf(\"gecko_cmd_mesh_prov_create_appkey: failed 0x%.2x\\n\\r\",new_appkey_rsp->result);\r\n        }\r\n        else\r\n        {\r\n          appkey_index=new_appkey_rsp->appkey_index;\r\n          printf(\"Success, appkey id = %x\\r\\n\", new_appkey_rsp->appkey_index);\r\n        }\r\n\r\n        /* Networks  */\r\n        printf(\"networks: 0x%x \",evt->data.evt_mesh_prov_initialized.networks);\r\n\r\n        /* address */\r\n        printf(\"address: 0x%x \",evt->data.evt_mesh_prov_initialized.address);\r\n\r\n        /* ivi  */\r\n        printf(\"ivi: 0x%lx\",evt->data.evt_mesh_prov_initialized.ivi);\r\n        printf(\"\\n\\r\");\r\n\r\n        /* Scan for unprovisioned beacons */\r\n        result=gecko_cmd_mesh_prov_scan_unprov_beacons()->result;\r\n\r\n        break;\r\n      case gecko_evt_mesh_prov_unprov_beacon_id:\r\n\r\n        /* PB-ADV only */\r\n        if(0 == evt->data.evt_mesh_prov_unprov_beacon.bearer)\r\n        {\r\n          /* Get BT mesh device index */\r\n          dev_idx = IsDevPresent( &evt->data.evt_mesh_prov_unprov_beacon.address.addr[0]);\r\n\r\n          /* fill up btmesh device struct */\r\n          if( 0 > dev_idx )\r\n          {\r\n            /* Device is not present */\r\n            for(idx=0;idx<MAX_NUM_BTMESH_DEV;idx++)\r\n            {\r\n              if(   ( 0x00 == bluetooth_device_table[idx].address[0] )\r\n                 && ( 0x00 == bluetooth_device_table[idx].address[1] )\r\n                 && ( 0x00 == bluetooth_device_table[idx].address[2] )\r\n                 && ( 0x00 == bluetooth_device_table[idx].address[3] )\r\n                 && ( 0x00 == bluetooth_device_table[idx].address[4] )\r\n                 && ( 0x00 == bluetooth_device_table[idx].address[5] )\r\n                )\r\n              {\r\n                memcpy(&bluetooth_device_table[idx].address[0],&evt->data.evt_mesh_prov_unprov_beacon.address.addr[0],BLE_ADDR_LEN_BYTE);\r\n                memcpy(&bluetooth_device_table[idx].uuid[0],&evt->data.evt_mesh_prov_unprov_beacon.uuid.data[0],BLE_MESH_UUID_LEN_BYTE);\r\n\r\n                /* Display info banner */\r\n                printf(\"URI hash: 0x%lx \",evt->data.evt_mesh_prov_unprov_beacon.uri_hash);\r\n                printf(\"bearer: 0x%x \",evt->data.evt_mesh_prov_unprov_beacon.bearer);\r\n                printf(\"address: 0x%x:0x%x:0x%x:0x%x:0x%x:0x%x \",bluetooth_device_table[idx].address[0],\r\n                                                                 bluetooth_device_table[idx].address[1],\r\n                                                                 bluetooth_device_table[idx].address[2],\r\n                                                                 bluetooth_device_table[idx].address[3],\r\n                                                                 bluetooth_device_table[idx].address[4],\r\n                                                                 bluetooth_device_table[idx].address[5]);\r\n                printf(\"UUID: 0x%x:0x%x:0x%x:0x%x:0x%x:0x%x \",bluetooth_device_table[idx].uuid[0],\r\n                                                              bluetooth_device_table[idx].uuid[1],\r\n                                                              bluetooth_device_table[idx].uuid[2],\r\n                                                              bluetooth_device_table[idx].uuid[3],\r\n                                                              bluetooth_device_table[idx].uuid[4],\r\n                                                              bluetooth_device_table[idx].uuid[5]);\r\n                printf(\"address type: 0x%x\",evt->data.evt_mesh_prov_unprov_beacon.address_type);\r\n                printf(\"\\n\\r\");\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        break;\r\n      /* Provisioning */\r\n      case gecko_evt_mesh_prov_provisioning_failed_id:\r\n        printf(\"provisioning failed\\n\\r\");\r\n        break;\r\n      case gecko_evt_mesh_prov_device_provisioned_id:\r\n\r\n        prov_evt = (struct gecko_msg_mesh_prov_device_provisioned_evt_t*)&(evt->data);\r\n\r\n        provisionee_addr = prov_evt->address;\r\n        printf(\"Node successfully provisioned. Address: %4.4x, \", provisionee_addr);\r\n\r\n        printf(\"uuid 0x\");\r\n        for (uint8_t i = 0; i < prov_evt->uuid.len; i++) printf(\"%02X\", prov_evt->uuid.data[i]);\r\n        printf(\"\\r\\n\");\r\n\r\n        printf(\" getting dcd ...\\n\\r\");\r\n\r\n        get_dcd_result = gecko_cmd_mesh_config_client_get_dcd(network_id, provisionee_addr, 0);\r\n        if (get_dcd_result->result == 0x0181) {\r\n          printf(\".\"); fflush(stdout);\r\n        } else if(get_dcd_result->result != 0x0){\r\n          printf(\"gecko_cmd_mesh_config_client_get_dcd failed with result 0x%X (%d) addr %x\\r\\n\", get_dcd_result->result, get_dcd_result->result, prov_evt->address);\r\n        }\r\n        else\r\n        {\r\n          printf(\"requesting DCD from the node...\\r\\n\");\r\n        }\r\n\r\n        break;\r\n\r\n      /* Config events */\r\n      case gecko_evt_mesh_config_client_dcd_data_id:\r\n        pDCD = (struct gecko_msg_mesh_config_client_dcd_data_evt_t *)&(evt->data);\r\n        printf(\"DCD data event, received %u bytes\\r\\n\", pDCD->data.len);\r\n\r\n        // copy the data into one large array. the data may come in multiple smaller pieces.\r\n        // the data is not decoded until all DCD events have been received (see below)\r\n        if((_dcd_raw_len + pDCD->data.len) <= 256)\r\n        {\r\n          memcpy(&(_dcd_raw[_dcd_raw_len]), pDCD->data.data, pDCD->data.len);\r\n          _dcd_raw_len += pDCD->data.len;\r\n        }\r\n\r\n        break;\r\n      case gecko_evt_le_connection_opened_id:\r\n        printf(\"LE connection opened\\r\\n\");\r\n        break;\r\n\r\n      case gecko_evt_mesh_config_client_dcd_data_end_id:\r\n        printf(\"DCD data end event. Decoding the data.\\r\\n\");\r\n        // decode the DCD content\r\n        DCD_decode();\r\n\r\n        // check the desired configuration settings depending on what's in the DCD\r\n        config_check();\r\n\r\n        appkey_deploy_evt = gecko_cmd_mesh_config_client_add_appkey(network_id, provisionee_addr, appkey_index, network_id);\r\n        if (appkey_deploy_evt->result == 0) {\r\n          printf(\"Deploying appkey to node 0x%4.4x\\r\\n\", provisionee_addr);\r\n        }else{\r\n          printf(\"Appkey deployment failed. addr %x, error: %x\\r\\n\", provisionee_addr, appkey_deploy_evt->result);\r\n        }\r\n\r\n        break;\r\n      case gecko_evt_mesh_config_client_appkey_status_id:\r\n        result = evt->data.evt_mesh_config_client_appkey_status.result;\r\n        if(result == 0)\r\n        {\r\n          printf(\" appkey added\\r\\n\");\r\n          /* move to next step which is binding appkey to models */\r\n\r\n          // take the next model from the list of models to be bound with application key.\r\n          // for simplicity, the same appkey is used for all models but it is possible to also use several appkeys\r\n          model_id = _sConfig.bind_model[_sConfig.num_bind_done].model_id;\r\n          vendor_id = _sConfig.bind_model[_sConfig.num_bind_done].vendor_id;\r\n\r\n          printf(\"APP BIND, config %d/%d:: model %4.4x key index %x\\r\\n\", _sConfig.num_bind_done+1, _sConfig.num_bind, model_id, appkey_index);\r\n\r\n          model_app_bind_result = gecko_cmd_mesh_config_client_bind_model( network_id, provisionee_addr, 0, // element index\r\n                                                                           appkey_index, vendor_id, model_id );\r\n        }\r\n        break;\r\n      case gecko_evt_mesh_config_client_binding_status_id:\r\n        result = evt->data.evt_mesh_config_client_appkey_status.result;\r\n        if(result == bg_err_success)\r\n        {\r\n          printf(\" bind complete\\r\\n\");\r\n          _sConfig.num_bind_done++;\r\n\r\n          if(_sConfig.num_bind_done < _sConfig.num_bind)\r\n          {\r\n            // take the next model from the list of models to be bound with application key.\r\n            // for simplicity, the same appkey is used for all models but it is possible to also use several appkeys\r\n            model_id = _sConfig.bind_model[_sConfig.num_bind_done].model_id;\r\n            vendor_id = _sConfig.bind_model[_sConfig.num_bind_done].vendor_id;\r\n\r\n            printf(\"APP BIND, config %d/%d:: model %4.4x key index %x\\r\\n\", _sConfig.num_bind_done+1, _sConfig.num_bind, model_id, appkey_index);\r\n\r\n            model_app_bind_result = gecko_cmd_mesh_config_client_bind_model( network_id, provisionee_addr, 0, // element index\r\n                                                                             appkey_index, vendor_id, model_id );\r\n          }\r\n          else\r\n          {\r\n            // get the next model/address pair from the configuration list:\r\n            model_id = _sConfig.pub_model[_sConfig.num_pub_done].model_id;\r\n            vendor_id = _sConfig.pub_model[_sConfig.num_pub_done].vendor_id;\r\n            pub_address = _sConfig.pub_address[_sConfig.num_pub_done];\r\n\r\n            printf(\"PUB SET, config %d/%d: model %4.4x -> address %4.4x\\r\\n\", _sConfig.num_pub_done+1, _sConfig.num_pub, model_id, pub_address);\r\n\r\n            model_pub_set_result = gecko_cmd_mesh_config_client_set_model_pub(network_id, provisionee_addr,\r\n              0, /* element index */\r\n              vendor_id,\r\n              model_id,\r\n              pub_address,\r\n              appkey_index,\r\n              0, /* friendship credential flag */\r\n              3, /* Publication time-to-live value */\r\n              0, /* period = NONE */\r\n              0, /* Publication retransmission count */\r\n              50  /* Publication retransmission interval */ );\r\n\r\n            if (model_pub_set_result->result == 0)\r\n            {\r\n              printf(\" waiting pub ack\\r\\n\");\r\n            }\r\n          }\r\n        }\r\n        else\r\n        {\r\n          printf(\" appkey bind failed with code \\r\\n\");\r\n        }\r\n        break;\r\n      case gecko_evt_mesh_config_client_model_pub_status_id:\r\n        result = evt->data.evt_mesh_config_client_model_pub_status.result;\r\n        if(result == bg_err_success)\r\n        {\r\n          printf(\" pub set OK\\r\\n\");\r\n          _sConfig.num_pub_done++;\r\n\r\n          if(_sConfig.num_pub_done < _sConfig.num_pub)\r\n          {\r\n            /* more publication settings to be done\r\n            ** get the next model/address pair from the configuration list: */\r\n            model_id = _sConfig.pub_model[_sConfig.num_pub_done].model_id;\r\n            vendor_id = _sConfig.pub_model[_sConfig.num_pub_done].vendor_id;\r\n            pub_address = _sConfig.pub_address[_sConfig.num_pub_done];\r\n\r\n            printf(\"PUB SET, config %d/%d: model %4.4x -> address %4.4x\\r\\n\", _sConfig.num_pub_done+1, _sConfig.num_pub, model_id, pub_address);\r\n\r\n            model_pub_set_result = gecko_cmd_mesh_config_client_set_model_pub(network_id, provisionee_addr,\r\n              0, /* element index */\r\n              vendor_id,\r\n              model_id,\r\n              pub_address,\r\n              appkey_index,\r\n              0, /* friendship credential flag */\r\n              3, /* Publication time-to-live value */\r\n              0, /* period = NONE */\r\n              0, /* Publication retransmission count */\r\n              50  /* Publication retransmission interval */ );\r\n          }\r\n          else\r\n          {\r\n            // move to next step which is configuring subscription settings\r\n            // get the next model/address pair from the configuration list:\r\n            model_id = _sConfig.sub_model[_sConfig.num_sub_done].model_id;\r\n            vendor_id = _sConfig.sub_model[_sConfig.num_sub_done].vendor_id;\r\n            sub_address = _sConfig.sub_address[_sConfig.num_sub_done];\r\n\r\n            printf(\"SUB ADD, config %d/%d: model %4.4x -> address %4.4x\\r\\n\", _sConfig.num_sub_done+1, _sConfig.num_sub, model_id, sub_address);\r\n\r\n            model_sub_add_result = gecko_cmd_mesh_config_client_add_model_sub(network_id, provisionee_addr, 0, vendor_id, model_id, sub_address);\r\n\r\n            if (model_sub_add_result->result == 0x00)\r\n            {\r\n              printf(\" waiting sub ack\\r\\n\");\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case gecko_evt_mesh_config_client_model_sub_status_id:\r\n        result = evt->data.evt_mesh_config_client_model_sub_status.result;\r\n        if(result == bg_err_success)\r\n        {\r\n          printf(\" sub add OK\\r\\n\");\r\n          _sConfig.num_sub_done++;\r\n          if(_sConfig.num_sub_done < _sConfig.num_sub)\r\n          {\r\n            // move to next step which is configuring subscription settings\r\n            // get the next model/address pair from the configuration list:\r\n            model_id = _sConfig.sub_model[_sConfig.num_sub_done].model_id;\r\n            vendor_id = _sConfig.sub_model[_sConfig.num_sub_done].vendor_id;\r\n            sub_address = _sConfig.sub_address[_sConfig.num_sub_done];\r\n\r\n            printf(\"SUB ADD, config %d/%d: model %4.4x -> address %4.4x\\r\\n\", _sConfig.num_sub_done+1, _sConfig.num_sub, model_id, sub_address);\r\n\r\n            model_sub_add_result = gecko_cmd_mesh_config_client_add_model_sub(network_id, provisionee_addr, 0, vendor_id, model_id, sub_address);\r\n\r\n            if (model_sub_add_result->result == 0x00)\r\n            {\r\n              printf(\" waiting sub ack\\r\\n\");\r\n            }\r\n          }\r\n          else\r\n          {\r\n            printf(\"***\\r\\nconfiguration complete\\r\\n***\\r\\n\");\r\n          }\r\n        }\r\n\r\n        break;\r\n      case gecko_evt_mesh_prov_dcd_status_id:\r\n        printf(\"dcd status received\\n\\r\");\r\n        break;\r\n      case gecko_evt_mesh_prov_config_status_id:\r\n        printf(\"prov config status\\n\\r\");\r\n        break;\r\n      case gecko_evt_le_gap_adv_timeout_id:\r\n        /* adv timeout events silently discarded */\r\n        break;\r\n      default:\r\n        printf(\"unhandled evt: %8.8x class %2.2x method %2.2x\\r\\n\", (unsigned int)BGLIB_MSG_ID(evt->header),\r\n                                                                    (unsigned int)((BGLIB_MSG_ID(evt->header) >> 16) & 0xFF),\r\n                                                                    (unsigned int)((BGLIB_MSG_ID(evt->header) >> 24) & 0xFF) );\r\n\r\n        if(model_app_bind_result->result  == 0x0000)\r\n        {\r\n          printf(\" waiting bind ack\\r\\n\");\r\n        }\r\n\r\n        break;\r\n    }\r\n  }\r\n\r\n  return;\r\n"]]}
{"hexsha": "37c7c99b9691194017f54de12c4696940bdc515a", "ext": "c", "lang": "C", "content": "void f191(void) {\n    \tstatic uint16_t x886 = UINT16_MAX;\n\tstatic int64_t x887 = -1LL;\n\tvolatile int32_t x888 = INT32_MIN;\n\tint32_t t191 = 1898666;\n\n    t191 = ((x885-x886)!=(x887==x888));\n\n    if (t191 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 191, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1393.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "37c7c99b9691194017f54de12c4696940bdc515a_191", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f191(void) {\n    \tstatic uint16_t x886 = UINT16_MAX;\n\tstatic int64_t x887 = -1LL;\n\tvolatile int32_t x888 = INT32_MIN;\n\tint32_t t191 = 1898666;\n    t191 = ((x885-x886)!=(x887==x888));\n    if (t191 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "836de5e1a29388f5934010096dea7609c6c4a70e", "ext": "c", "lang": "C", "content": "void f199(void) {\n    \tint8_t x1065 = 0;\n\tint8_t x1066 = -1;\n\tstatic uint32_t x1067 = 921U;\n\tuint32_t t199 = 199U;\n\n    t199 = ((x1065+x1066)+(x1067+x1068));\n\n    if (t199 != 927U) { NG(); } else { ; }\n\t\n}", "item_id": 198, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "836de5e1a29388f5934010096dea7609c6c4a70e_198", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f199(void) {\n    \tint8_t x1065 = 0;\n\tint8_t x1066 = -1;\n\tstatic uint32_t x1067 = 921U;\n\tuint32_t t199 = 199U;\n    t199 = ((x1065+x1066)+(x1067+x1068));\n    if (t199 != 927U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "52d8a159ac3e4210b24279cd50ff620fe49964a5", "ext": "c", "lang": "C", "content": "void f8(void) {\n    \tint8_t x37 = INT8_MAX;\n\tuint8_t x38 = 90U;\n\tint16_t x39 = 1;\n\tstatic uint32_t x40 = 23234U;\n\tstatic volatile int32_t t8 = -2106395;\n\n    t8 = ((x37/x38)==(x39/x40));\n\n    if (t8 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 8, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test638.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "52d8a159ac3e4210b24279cd50ff620fe49964a5_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f8(void) {\n    \tint8_t x37 = INT8_MAX;\n\tuint8_t x38 = 90U;\n\tint16_t x39 = 1;\n\tstatic uint32_t x40 = 23234U;\n\tstatic volatile int32_t t8 = -2106395;\n    t8 = ((x37/x38)==(x39/x40));\n    if (t8 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "46bf839170f127b37e606c0371ba33dca5af6686", "ext": "c", "lang": "C", "content": "bool\ntest_msgs__msg__Defaults__Sequence__init(test_msgs__msg__Defaults__Sequence * array, size_t size)\n{\n  if (!array) {\n    return false;\n  }\n  test_msgs__msg__Defaults * data = NULL;\n  if (size) {\n    data = (test_msgs__msg__Defaults *)calloc(size, sizeof(test_msgs__msg__Defaults));\n    if (!data) {\n      return false;\n    }\n    // initialize all array elements\n    size_t i;\n    for (i = 0; i < size; ++i) {\n      bool success = test_msgs__msg__Defaults__init(&data[i]);\n      if (!success) {\n        break;\n      }\n    }\n    if (i < size) {\n      // if initialization failed finalize the already initialized array elements\n      for (; i > 0; --i) {\n        test_msgs__msg__Defaults__fini(&data[i - 1]);\n      }\n      free(data);\n      return false;\n    }\n  }\n  array->data = data;\n  array->size = size;\n  array->capacity = size;\n  return true;\n}", "item_id": 3, "repo": "artivis/micro_ros_raspberrypi_pico_sdk", "file": "uros_ws/firmware/build/include/test_msgs/msg/detail/defaults__functions.c", "last_update_at": "2021-11-25T19:07:52+00:00", "question_id": "46bf839170f127b37e606c0371ba33dca5af6686_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool\ntest_msgs__msg__Defaults__Sequence__init(test_msgs__msg__Defaults__Sequence * array, size_t size)\n{\n  if (!array) {\n    return false;\n  }\n  test_msgs__msg__Defaults * data = NULL;\n  if (size) {\n    data = (test_msgs__msg__Defaults *)calloc(size, sizeof(test_msgs__msg__Defaults));\n    if (!data) {\n      return false;\n    }\n    // initialize all array elements\n    size_t i;\n    for (i = 0; i < size; ++i) {\n      bool success = test_msgs__msg__Defaults__init(&data[i]);\n      if (!success) {\n        break;\n      }\n    }\n    if (i < size) {\n      // if initialization failed finalize the already initialized array elements\n      for (; i > 0; --i) {\n        test_msgs__msg__Defaults__fini(&data[i - 1]);\n      }\n      free(data);\n      return false;\n    }\n  }\n  array->data = data;\n  array->size = size;\n  array->capacity = size;\n  return true;\n"]]}
{"hexsha": "569537e6d878d25bb7c54ab5989c049f1f8494ee", "ext": "c", "lang": "C", "content": "void f158(void) {\n    \tuint8_t x633 = 3U;\n\tint16_t x634 = INT16_MIN;\n\tuint64_t x636 = 35969LLU;\n\tint32_t t158 = -4;\n\n    t158 = (x633^((x634<=x635)==x636));\n\n    if (t158 != 3) { NG(); } else { ; }\n\t\n}", "item_id": 157, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test1876.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "569537e6d878d25bb7c54ab5989c049f1f8494ee_157", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f158(void) {\n    \tuint8_t x633 = 3U;\n\tint16_t x634 = INT16_MIN;\n\tuint64_t x636 = 35969LLU;\n\tint32_t t158 = -4;\n    t158 = (x633^((x634<=x635)==x636));\n    if (t158 != 3) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "02b2128a0726c631b38b7599bac3f72ffe5f8cd0", "ext": "c", "lang": "C", "content": "void f27(void) {\n    \tstatic int8_t x185 = INT8_MAX;\n\tvolatile int16_t x186 = INT16_MAX;\n\tuint64_t x187 = UINT64_MAX;\n\tint32_t x188 = INT32_MIN;\n\tstatic volatile int32_t t27 = 1;\n\n    t27 = (x185<<(x186!=(x187==x188)));\n\n    if (t27 != 254) { NG(); } else { ; }\n\t\n}", "item_id": 27, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test1462.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "02b2128a0726c631b38b7599bac3f72ffe5f8cd0_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f27(void) {\n    \tstatic int8_t x185 = INT8_MAX;\n\tvolatile int16_t x186 = INT16_MAX;\n\tuint64_t x187 = UINT64_MAX;\n\tint32_t x188 = INT32_MIN;\n\tstatic volatile int32_t t27 = 1;\n    t27 = (x185<<(x186!=(x187==x188)));\n    if (t27 != 254) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "838ec3b80c3d5772f611b184063e2f3a6e0f92b6", "ext": "c", "lang": "C", "content": "void f150(void) {\n    \tint32_t x1186 = -1;\n\tvolatile int16_t x1187 = -2;\n\n    t150 = ((x1185==x1186)%(x1187<=x1188));\n\n    if (t150 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 150, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1867.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "838ec3b80c3d5772f611b184063e2f3a6e0f92b6_150", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f150(void) {\n    \tint32_t x1186 = -1;\n\tvolatile int16_t x1187 = -2;\n    t150 = ((x1185==x1186)%(x1187<=x1188));\n    if (t150 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "0acdfd64cd446cd17239fc74a012b0ac454e55e1", "ext": "c", "lang": "C", "content": "void f122(void) {\n    \tint64_t x505 = -807LL;\n\tstatic uint16_t x506 = 5313U;\n\tvolatile int8_t x508 = -1;\n\tint64_t t122 = 518175566126565LL;\n\n    t122 = (x505+((x506<=x507)/x508));\n\n    if (t122 != -808LL) { NG(); } else { ; }\n\t\n}", "item_id": 122, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test1807.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "0acdfd64cd446cd17239fc74a012b0ac454e55e1_122", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f122(void) {\n    \tint64_t x505 = -807LL;\n\tstatic uint16_t x506 = 5313U;\n\tvolatile int8_t x508 = -1;\n\tint64_t t122 = 518175566126565LL;\n    t122 = (x505+((x506<=x507)/x508));\n    if (t122 != -808LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "68def6e38813550c381ab3113850826bcdf827cc", "ext": "c", "lang": "C", "content": "void f114(void) {\n    \tint8_t x517 = INT8_MIN;\n\tuint8_t x518 = 31U;\n\tint32_t x520 = INT32_MIN;\n\n    t114 = (x517-(x518>(x519%x520)));\n\n    if (t114 != -128) { NG(); } else { ; }\n\t\n}", "item_id": 114, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test898.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "68def6e38813550c381ab3113850826bcdf827cc_114", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f114(void) {\n    \tint8_t x517 = INT8_MIN;\n\tuint8_t x518 = 31U;\n\tint32_t x520 = INT32_MIN;\n    t114 = (x517-(x518>(x519%x520)));\n    if (t114 != -128) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "be1f22e3cef7a4ead5581ec5da7a693fd94222c3", "ext": "c", "lang": "C", "content": "void console_init(void)\n{\n    /* Turn on the clocks. */\n    rcc->apb2enr |= RCC_APB2ENR_USART1EN;\n\n    /* Enable TX pin (PA9) for USART output, RX pin (PA10) as input. */\n    gpio_configure_pin(gpioa, 9, AFO_pushpull(_10MHz));\n    gpio_configure_pin(gpioa, 10, GPI_pull_up);\n\n    /* BAUD, 8n1. */\n    usart1->brr = SYSCLK / BAUD;\n    usart1->cr1 = (USART_CR1_UE | USART_CR1_TE | USART_CR1_RE);\n    usart1->cr3 = USART_CR3_DMAT;\n\n    /* Initialise DMA1 channel 4 and its completion interrupt. */\n    dma1->ch4.cpar = (uint32_t)(unsigned long)&usart1->dr;\n    dma1->ifcr = DMA_IFCR_CGIF(4);\n    IRQx_set_prio(DMA1_CH4_IRQ, CONSOLE_IRQ_PRI);\n    IRQx_enable(DMA1_CH4_IRQ);\n}", "item_id": 4, "repo": "arananet/FlashFloppy", "file": "src/console.c", "last_update_at": "2021-02-23T21:11:20+00:00", "question_id": "be1f22e3cef7a4ead5581ec5da7a693fd94222c3_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void console_init(void)\n{\n    /* Turn on the clocks. */\n    rcc->apb2enr |= RCC_APB2ENR_USART1EN;\n    /* Enable TX pin (PA9) for USART output, RX pin (PA10) as input. */\n    gpio_configure_pin(gpioa, 9, AFO_pushpull(_10MHz));\n    gpio_configure_pin(gpioa, 10, GPI_pull_up);\n    /* BAUD, 8n1. */\n    usart1->brr = SYSCLK / BAUD;\n    usart1->cr1 = (USART_CR1_UE | USART_CR1_TE | USART_CR1_RE);\n    usart1->cr3 = USART_CR3_DMAT;\n    /* Initialise DMA1 channel 4 and its completion interrupt. */\n    dma1->ch4.cpar = (uint32_t)(unsigned long)&usart1->dr;\n    dma1->ifcr = DMA_IFCR_CGIF(4);\n    IRQx_set_prio(DMA1_CH4_IRQ, CONSOLE_IRQ_PRI);\n    IRQx_enable(DMA1_CH4_IRQ);\n"]]}
{"hexsha": "499c48e7637b3a6826545fe9e89a8b61ec996cf1", "ext": "h", "lang": "C", "content": "struct UAkTVOSInitializationSettings : public UObject {\n\tstruct FAkCommonInitializationSettingsWithSampleRate CommonSettings; // 0x28(0x68)\n\tstruct FAkAudioSession AudioSession; // 0x90(0x0c)\n\tchar UnknownData_9C[0x4]; // 0x9c(0x04)\n\tstruct FAkCommunicationSettingsWithSystemInitialization CommunicationSettings; // 0xa0(0x28)\n\tstruct FAkAdvancedInitializationSettings AdvancedSettings; // 0xc8(0x34)\n\tchar UnknownData_FC[0x4]; // 0xfc(0x04)\n}", "item_id": 44, "repo": "patrickcjk/RogueCompanyDump", "file": "Dump/AkAudio_classes.h", "last_update_at": "2021-02-25T00:48:25+00:00", "question_id": "499c48e7637b3a6826545fe9e89a8b61ec996cf1_44", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct UAkTVOSInitializationSettings : public UObject {\n\tstruct FAkCommonInitializationSettingsWithSampleRate CommonSettings; // 0x28(0x68)\n\tstruct FAkAudioSession AudioSession; // 0x90(0x0c)\n\tchar UnknownData_9C[0x4]; // 0x9c(0x04)\n\tstruct FAkCommunicationSettingsWithSystemInitialization CommunicationSettings; // 0xa0(0x28)\n\tstruct FAkAdvancedInitializationSettings AdvancedSettings; // 0xc8(0x34)\n\tchar UnknownData_FC[0x4]; // 0xfc(0x04)\n"]]}
{"hexsha": "bc2eb6d78305c5bcc3610f54f305dbef70e15a44", "ext": "c", "lang": "C", "content": "static inline void\npango_span_markup_init (cea708PangoSpanControl * span_control)\n{\n  memset (span_control, 0, sizeof (cea708PangoSpanControl));\n  span_control->size = PEN_SIZE_STANDARD;\n  span_control->fg_color = CEA708_COLOR_WHITE;\n  span_control->bg_color = CEA708_COLOR_INVALID;\n  span_control->size = PEN_SIZE_STANDARD;\n  span_control->font_style = FONT_STYLE_DEFAULT;\n}", "item_id": 17, "repo": "isabella232/aistreams", "file": "third_party/gst-plugins-bad/ext/closedcaption/gstcea708decoder.c", "last_update_at": "2021-10-21T01:34:04+00:00", "question_id": "bc2eb6d78305c5bcc3610f54f305dbef70e15a44_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void\npango_span_markup_init (cea708PangoSpanControl * span_control)\n{\n  memset (span_control, 0, sizeof (cea708PangoSpanControl));\n  span_control->size = PEN_SIZE_STANDARD;\n  span_control->fg_color = CEA708_COLOR_WHITE;\n  span_control->bg_color = CEA708_COLOR_INVALID;\n  span_control->size = PEN_SIZE_STANDARD;\n  span_control->font_style = FONT_STYLE_DEFAULT;\n"]]}
{"hexsha": "cff544bc8f3c838531d129f7aa2f9de0588eaf8b", "ext": "c", "lang": "C", "content": "void f159(void) {\n    \tuint64_t x637 = UINT64_MAX;\n\tint16_t x638 = 4010;\n\tint32_t x639 = -1;\n\tuint16_t x640 = 3097U;\n\tint32_t t159 = 172446755;\n\n    t159 = (x637<=((x638<=x639)^x640));\n\n    if (t159 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 159, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test1956.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "cff544bc8f3c838531d129f7aa2f9de0588eaf8b_159", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f159(void) {\n    \tuint64_t x637 = UINT64_MAX;\n\tint16_t x638 = 4010;\n\tint32_t x639 = -1;\n\tuint16_t x640 = 3097U;\n\tint32_t t159 = 172446755;\n    t159 = (x637<=((x638<=x639)^x640));\n    if (t159 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "cfed1d97ffdd388f2448e8c1d79f9ebc28bddc3f", "ext": "c", "lang": "C", "content": "void f128(void) {\n    \tvolatile uint16_t x749 = 85U;\n\tint16_t x750 = -2015;\n\tstatic volatile int64_t x751 = -1LL;\n\tuint8_t x752 = 14U;\n\tint32_t t128 = -169545;\n\n    t128 = (((x749*x750)!=x751)-x752);\n\n    if (t128 != -13) { NG(); } else { ; }\n\t\n}", "item_id": 128, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test478.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "cfed1d97ffdd388f2448e8c1d79f9ebc28bddc3f_128", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f128(void) {\n    \tvolatile uint16_t x749 = 85U;\n\tint16_t x750 = -2015;\n\tstatic volatile int64_t x751 = -1LL;\n\tuint8_t x752 = 14U;\n\tint32_t t128 = -169545;\n    t128 = (((x749*x750)!=x751)-x752);\n    if (t128 != -13) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "d657f07b5f90dac51efe3a4271eae218acb23a24", "ext": "c", "lang": "C", "content": "static void\nsendtopic(char buf[])\n{\n\tchar \t\tmsg[MSGMAX];\n\tunsigned int \ti;\n\tint \t\tj = 0;\n\n\tif (strncmp(buf, \"/topic \", 7) == 0) {\n\t\tfor (i = 7; i < strlen(buf); i++)\n\t\t\tmsg[j++] = buf[i];\n\t\tmsg[j] = '\\0';\n\t} else if (strncmp(buf, \"/t \", 3) == 0) {\n\t\tfor (i = 3; i < strlen(buf); i++)\n\t\t\tmsg[j++] = buf[i];\n\t\tmsg[j] = '\\0';\n\t} else if (strncmp(buf, \"/topic\", 5) == 0 || strncmp(buf, \"/t\", 2) == 0) {\n\t\tmsg[0] = '\\0';\n\t} else {\n\t\tsuccess = 0;\n\t}\n\tif (success) {\n\t\tsnprintf(packet, sizeof(packet), \"%chtopic\\001%s\",\n\t\t\t (int) sizeof(packet) - 1, msg);\n\t}\n}", "item_id": 10, "repo": "ibara/LiteBSD-Ports", "file": "net/icb/icb.c", "last_update_at": "2021-07-31T00:02:26+00:00", "question_id": "d657f07b5f90dac51efe3a4271eae218acb23a24_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nsendtopic(char buf[])\n{\n\tchar \t\tmsg[MSGMAX];\n\tunsigned int \ti;\n\tint \t\tj = 0;\n\tif (strncmp(buf, \"/topic \", 7) == 0) {\n\t\tfor (i = 7; i < strlen(buf); i++)\n\t\t\tmsg[j++] = buf[i];\n\t\tmsg[j] = '\\0';\n\t} else if (strncmp(buf, \"/t \", 3) == 0) {\n\t\tfor (i = 3; i < strlen(buf); i++)\n\t\t\tmsg[j++] = buf[i];\n\t\tmsg[j] = '\\0';\n\t} else if (strncmp(buf, \"/topic\", 5) == 0 || strncmp(buf, \"/t\", 2) == 0) {\n\t\tmsg[0] = '\\0';\n\t} else {\n\t\tsuccess = 0;\n\t}\n\tif (success) {\n\t\tsnprintf(packet, sizeof(packet), \"%chtopic\\001%s\",\n\t\t\t (int) sizeof(packet) - 1, msg);\n\t}\n"]]}
{"hexsha": "026ca8754e70a304ada197ae525631d1da03ee1b", "ext": "c", "lang": "C", "content": "VOID\r\nUSBPORT_FreeBandwidthUSB11(\r\n    PDEVICE_OBJECT FdoDeviceObject,\r\n    PHCD_ENDPOINT Endpoint\r\n    )\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    Frees the bw reserved for a give endpoint\r\n\r\nArguments:\r\n\r\nReturn Value:\r\n\r\n    FALSE if no bandwidth availble\r\n\r\n--*/\r\n{\r\n    PDEVICE_EXTENSION devExt;\r\n    ULONG period, bandwidth, scheduleOffset, i, n;\r\n\r\n    PAGED_CODE();\r\n\r\n    GET_DEVICE_EXT(devExt, FdoDeviceObject);\r\n    ASSERT_FDOEXT(devExt);\r\n\r\n    ASSERT_ENDPOINT(Endpoint);\r\n\r\n    if (Endpoint->Parameters.TransferType == Bulk ||\r\n        Endpoint->Parameters.TransferType == Control ||\r\n        TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {\r\n        // these come out of our standard 10%\r\n        return;\r\n    }\r\n\r\n    scheduleOffset = Endpoint->Parameters.ScheduleOffset;\r\n    bandwidth = Endpoint->Parameters.Bandwidth;\r\n    period = Endpoint->Parameters.Period;\r\n\r\n    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'frBW', scheduleOffset, bandwidth, period);\r\n\r\n    n = USBPORT_MAX_INTEP_POLLING_INTERVAL/period;\r\n\r\n    for (i=0; i<n; i++) {\r\n\r\n        USBPORT_ASSERT(n*scheduleOffset+i < USBPORT_MAX_INTEP_POLLING_INTERVAL);\r\n        devExt->Fdo.BandwidthTable[n*scheduleOffset+i] += bandwidth;\r\n\r\n    }\r\n    //for (i=sheduleOffset; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i+=period) {\r\n    //    USBPORT_ASSERT(i < USBPORT_MAX_INTEP_POLLING_INTERVAL);\r\n    //    devExt->Fdo.BandwidthTable[i] += bandwidth;\r\n    //}\r\n\r\n    // update our bw tracking info\r\n    if (Endpoint->Parameters.TransferType == Isochronous) {\r\n        devExt->Fdo.AllocedIsoBW -= bandwidth;\r\n    } else {\r\n        USBPORT_GET_BIT_SET(period, n);\r\n        USBPORT_ASSERT(n<6);\r\n        devExt->Fdo.AllocedInterruptBW[n] -= bandwidth;\r\n    }\r\n\r\n    // update max allocated BW\r\n    USBPORT_UpdateAllocatedBw(FdoDeviceObject);\r\n\r\n    return;\r\n}", "item_id": 15, "repo": "npocmaka/Windows-Server-2003", "file": "drivers/wdm/usb/hcd/usbport/usbport.c", "last_update_at": "2021-09-16T09:13:13+00:00", "question_id": "026ca8754e70a304ada197ae525631d1da03ee1b_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["VOID\r\nUSBPORT_FreeBandwidthUSB11(\r\n    PDEVICE_OBJECT FdoDeviceObject,\r\n    PHCD_ENDPOINT Endpoint\r\n    )\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    Frees the bw reserved for a give endpoint\r\n\r\nArguments:\r\n\r\nReturn Value:\r\n\r\n    FALSE if no bandwidth availble\r\n\r\n--*/\r\n{\r\n    PDEVICE_EXTENSION devExt;\r\n    ULONG period, bandwidth, scheduleOffset, i, n;\r\n\r\n    PAGED_CODE();\r\n\r\n    GET_DEVICE_EXT(devExt, FdoDeviceObject);\r\n    ASSERT_FDOEXT(devExt);\r\n\r\n    ASSERT_ENDPOINT(Endpoint);\r\n\r\n    if (Endpoint->Parameters.TransferType == Bulk ||\r\n        Endpoint->Parameters.TransferType == Control ||\r\n        TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {\r\n        // these come out of our standard 10%\r\n        return;\r\n    }\r\n\r\n    scheduleOffset = Endpoint->Parameters.ScheduleOffset;\r\n    bandwidth = Endpoint->Parameters.Bandwidth;\r\n    period = Endpoint->Parameters.Period;\r\n\r\n    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'frBW', scheduleOffset, bandwidth, period);\r\n\r\n    n = USBPORT_MAX_INTEP_POLLING_INTERVAL/period;\r\n\r\n    for (i=0; i<n; i++) {\r\n\r\n        USBPORT_ASSERT(n*scheduleOffset+i < USBPORT_MAX_INTEP_POLLING_INTERVAL);\r\n        devExt->Fdo.BandwidthTable[n*scheduleOffset+i] += bandwidth;\r\n\r\n    }\r\n    //for (i=sheduleOffset; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i+=period) {\r\n    //    USBPORT_ASSERT(i < USBPORT_MAX_INTEP_POLLING_INTERVAL);\r\n    //    devExt->Fdo.BandwidthTable[i] += bandwidth;\r\n    //}\r\n\r\n    // update our bw tracking info\r\n    if (Endpoint->Parameters.TransferType == Isochronous) {\r\n        devExt->Fdo.AllocedIsoBW -= bandwidth;\r\n    } else {\r\n        USBPORT_GET_BIT_SET(period, n);\r\n        USBPORT_ASSERT(n<6);\r\n        devExt->Fdo.AllocedInterruptBW[n] -= bandwidth;\r\n    }\r\n\r\n    // update max allocated BW\r\n    USBPORT_UpdateAllocatedBw(FdoDeviceObject);\r\n\r\n    return;\r\n"]]}
{"hexsha": "daa846f1b7ac7192372928f1cf5a457fb76c1f4b", "ext": "h", "lang": "C", "content": "interface RKOrbBasicProgram : NSObject {\n    NSString                    *program;\n    NSString                    *path;\n    NSString                    *name;\n    NSInteger                   startLineNumber;\n    \n    RKOrbBasicProgramLoadState  loadState;\n    BOOL                        executeAfterLoading;\n    BOOL                        aborting;\n    \n    NSMutableArray              *fragments;\n}", "item_id": 0, "repo": "Ramzawulf/Bebocho", "file": "Bebocho/Assets/Plugins/iOS/RobotKit.framework/Headers/RKOrbBasicProgram.h", "last_update_at": "2021-07-22T12:49:06+00:00", "question_id": "daa846f1b7ac7192372928f1cf5a457fb76c1f4b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface RKOrbBasicProgram : NSObject {\n    NSString                    *program;\n    NSString                    *path;\n    NSString                    *name;\n    NSInteger                   startLineNumber;\n    RKOrbBasicProgramLoadState  loadState;\n    BOOL                        executeAfterLoading;\n    BOOL                        aborting;\n    NSMutableArray              *fragments;\n"]]}
{"hexsha": "11d763ae1d3315f8b8573c13bee3827f242a838d", "ext": "c", "lang": "C", "content": "extern void redirect_to(Router *router) {\n    RouterStackFrame *frame = top_stack;\n    do {\n        PopupAndPopRouter *_router = frame->router;\n        gtk_widget_destroy(_router->widget);\n        gtk_widget_destroy(_router->headerBar);\n        X_FREE(_router->router);\n        frame = frame->pre;\n    } while (frame != NULL);\n    //\u91cd\u5b9a\u5411\u9875\u9762\n    navigate_to(router);\n}", "item_id": 3, "repo": "GZYangKui/x-player", "file": "gtk/router.c", "last_update_at": "2021-06-25T15:34:02+00:00", "question_id": "11d763ae1d3315f8b8573c13bee3827f242a838d_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["extern void redirect_to(Router *router) {\n    RouterStackFrame *frame = top_stack;\n    do {\n        PopupAndPopRouter *_router = frame->router;\n        gtk_widget_destroy(_router->widget);\n        gtk_widget_destroy(_router->headerBar);\n        X_FREE(_router->router);\n        frame = frame->pre;\n    } while (frame != NULL);\n    //\u91cd\u5b9a\u5411\u9875\u9762\n    navigate_to(router);\n"]]}
{"hexsha": "43edf436e6a7bdb9f04275753393fe42f0ef416d", "ext": "c", "lang": "C", "content": "static cJSONZJ *create_reference(cJSONZJ *item)\n{\n    cJSONZJ *ref = cJSONZJ_New_Item();\n    if (!ref)\n        return 0;\n    memcpy(ref, item, sizeof(cJSONZJ));\n    ref->string = 0;\n    ref->type |= cJSONZJ_IsReference;\n    ref->next = ref->prev = 0;\n    return ref;\n}", "item_id": 19, "repo": "Eafy/ZJCrossCpp", "file": "Cpp/CJsonObject/cJSONZJ.c", "last_update_at": "2021-08-18T00:56:10+00:00", "question_id": "43edf436e6a7bdb9f04275753393fe42f0ef416d_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static cJSONZJ *create_reference(cJSONZJ *item)\n{\n    cJSONZJ *ref = cJSONZJ_New_Item();\n    if (!ref)\n        return 0;\n    memcpy(ref, item, sizeof(cJSONZJ));\n    ref->string = 0;\n    ref->type |= cJSONZJ_IsReference;\n    ref->next = ref->prev = 0;\n    return ref;\n"]]}
{"hexsha": "a468ff3bcb6141c4c585863134e8a8eabe3b6293", "ext": "c", "lang": "C", "content": "void f72(void) {\n    \tint64_t x373 = INT64_MIN;\n\tint16_t x374 = INT16_MIN;\n\tvolatile int8_t x376 = 1;\n\tstatic int64_t t72 = 270501554721197LL;\n\n    t72 = (x373&(x374*(x375&x376)));\n\n    if (t72 != 0LL) { NG(); } else { ; }\n\t\n}", "item_id": 72, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test2196.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "a468ff3bcb6141c4c585863134e8a8eabe3b6293_72", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f72(void) {\n    \tint64_t x373 = INT64_MIN;\n\tint16_t x374 = INT16_MIN;\n\tvolatile int8_t x376 = 1;\n\tstatic int64_t t72 = 270501554721197LL;\n    t72 = (x373&(x374*(x375&x376)));\n    if (t72 != 0LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "e3118cedc98c235eb773405f91b4efd7ad51e3e2", "ext": "c", "lang": "C", "content": "void f46(void) {\n    \tvolatile int32_t x3765 = 157068692;\n\tvolatile int32_t x3766 = INT32_MAX;\n\tstatic uint64_t x3767 = UINT64_MAX;\n\tint8_t x3768 = 2;\n\tint32_t t46 = -121912;\n\n    t46 = ((x3765<=x3766)<<(x3767+x3768));\n\n    if (t46 != 2) { NG(); } else { ; }\n\t\n}", "item_id": 46, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test132.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "e3118cedc98c235eb773405f91b4efd7ad51e3e2_46", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f46(void) {\n    \tvolatile int32_t x3765 = 157068692;\n\tvolatile int32_t x3766 = INT32_MAX;\n\tstatic uint64_t x3767 = UINT64_MAX;\n\tint8_t x3768 = 2;\n\tint32_t t46 = -121912;\n    t46 = ((x3765<=x3766)<<(x3767+x3768));\n    if (t46 != 2) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "fa974ae98315e5e55fd9b3b4850a7fd60135ad47", "ext": "c", "lang": "C", "content": "TaggedString *luaS_newfixedstring (char *str) {\n  TaggedString *ts = luaS_new(str);\n  if (ts->head.marked == 0)\n    ts->head.marked = 2;  /* avoid GC */\n  return ts;\n}", "item_id": 8, "repo": "arkiny/OSwithMSVC", "file": "Chapter/08_Device/ThirdParty/LUA/lstring.c", "last_update_at": "2021-05-09T01:24:05+00:00", "question_id": "fa974ae98315e5e55fd9b3b4850a7fd60135ad47_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["TaggedString *luaS_newfixedstring (char *str) {\n  TaggedString *ts = luaS_new(str);\n  if (ts->head.marked == 0)\n    ts->head.marked = 2;  /* avoid GC */\n  return ts;\n"]]}
{"hexsha": "8cfe1c2e4145f05ec6dba921ac0fa317a81a375b", "ext": "c", "lang": "C", "content": "void f6(void) {\n    \tint8_t x26 = 0;\n\tvolatile int64_t x27 = INT64_MIN;\n\tvolatile uint16_t x28 = UINT16_MAX;\n\tvolatile int32_t t6 = 35688305;\n\n    t6 = ((x25-x26)!=(x27^x28));\n\n    if (t6 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 6, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test2569.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "8cfe1c2e4145f05ec6dba921ac0fa317a81a375b_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f6(void) {\n    \tint8_t x26 = 0;\n\tvolatile int64_t x27 = INT64_MIN;\n\tvolatile uint16_t x28 = UINT16_MAX;\n\tvolatile int32_t t6 = 35688305;\n    t6 = ((x25-x26)!=(x27^x28));\n    if (t6 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "e3156152d5c8cc8a9c55186203e82f2e2b40d0ab", "ext": "c", "lang": "C", "content": "void *ts__arrayGrow(\n    TsCompiler *compiler, void *ptr, size_t *cap, size_t wanted_cap, size_t item_size)\n{\n    size_t desired_cap = TS__MAX(wanted_cap, ARRAY_INITIAL_CAPACITY);\n    desired_cap = TS__MAX(desired_cap, (*cap) * 2);\n    TS_ASSERT(desired_cap > 0);\n    TS_ASSERT(desired_cap > (*cap));\n    TS_ASSERT(desired_cap >= wanted_cap);\n\n    void* new_arr = ts__bumpAlloc(&compiler->alloc, item_size * desired_cap);\n\n    if (ptr)\n    {\n        memcpy(new_arr, ptr, (*cap) * item_size);\n    }\n\n    *cap = desired_cap;\n    return new_arr;\n}", "item_id": 0, "repo": "felipeagc/tinyshader", "file": "tinyshader/tinyshader_misc.c", "last_update_at": "2021-12-20T12:14:30+00:00", "question_id": "e3156152d5c8cc8a9c55186203e82f2e2b40d0ab_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void *ts__arrayGrow(\n    TsCompiler *compiler, void *ptr, size_t *cap, size_t wanted_cap, size_t item_size)\n{\n    size_t desired_cap = TS__MAX(wanted_cap, ARRAY_INITIAL_CAPACITY);\n    desired_cap = TS__MAX(desired_cap, (*cap) * 2);\n    TS_ASSERT(desired_cap > 0);\n    TS_ASSERT(desired_cap > (*cap));\n    TS_ASSERT(desired_cap >= wanted_cap);\n    void* new_arr = ts__bumpAlloc(&compiler->alloc, item_size * desired_cap);\n    if (ptr)\n    {\n        memcpy(new_arr, ptr, (*cap) * item_size);\n    }\n    *cap = desired_cap;\n    return new_arr;\n"]]}
{"hexsha": "f8b632edcfebc56c54a8b7517eb0495a396abc56", "ext": "c", "lang": "C", "content": "SEXP text_tokens(SEXP sx)\n{\n\tSEXP ans, names;\n\tconst struct utf8lite_text *text;\n\tstruct corpus_filter *filter;\n\tstruct tokens ctx;\n\tR_xlen_t i, n;\n\tint nprot, type_id, ntype;\n\n\tnprot = 0;\n\n\tPROTECT(sx = coerce_text(sx)); nprot++;\n\ttext = as_text(sx, &n);\n\tfilter = text_filter(sx);\n\n\tPROTECT(ans = allocVector(VECSXP, n)); nprot++;\n\tnames = names_text(sx);\n\tsetAttrib(ans, R_NamesSymbol, names);\n\n\ttokens_init(&ctx, filter);\n\n\t// add the existing types in the filter\n\tntype = ctx.filter->symtab.ntype;\n\tfor (type_id = 0; type_id < ntype; type_id++) {\n\t\tRCORPUS_CHECK_INTERRUPT(type_id);\n\t\tPROTECT(tokens_add_type(&ctx, type_id)); nprot++;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tRCORPUS_CHECK_INTERRUPT(i);\n\t\tSET_VECTOR_ELT(ans, i, tokens_scan(&ctx, &text[i]));\n\t}\n\n\tUNPROTECT(nprot);\n\treturn ans;\n}", "item_id": 4, "repo": "cran/corpus", "file": "src/text_tokens.c", "last_update_at": "2021-08-24T00:20:40+00:00", "question_id": "f8b632edcfebc56c54a8b7517eb0495a396abc56_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SEXP text_tokens(SEXP sx)\n{\n\tSEXP ans, names;\n\tconst struct utf8lite_text *text;\n\tstruct corpus_filter *filter;\n\tstruct tokens ctx;\n\tR_xlen_t i, n;\n\tint nprot, type_id, ntype;\n\tnprot = 0;\n\tPROTECT(sx = coerce_text(sx)); nprot++;\n\ttext = as_text(sx, &n);\n\tfilter = text_filter(sx);\n\tPROTECT(ans = allocVector(VECSXP, n)); nprot++;\n\tnames = names_text(sx);\n\tsetAttrib(ans, R_NamesSymbol, names);\n\ttokens_init(&ctx, filter);\n\t// add the existing types in the filter\n\tntype = ctx.filter->symtab.ntype;\n\tfor (type_id = 0; type_id < ntype; type_id++) {\n\t\tRCORPUS_CHECK_INTERRUPT(type_id);\n\t\tPROTECT(tokens_add_type(&ctx, type_id)); nprot++;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tRCORPUS_CHECK_INTERRUPT(i);\n\t\tSET_VECTOR_ELT(ans, i, tokens_scan(&ctx, &text[i]));\n\t}\n\tUNPROTECT(nprot);\n\treturn ans;\n"]]}
{"hexsha": "6b2208e1051da968f7b94f9b07205b225f32c282", "ext": "c", "lang": "C", "content": "static\r\nVOID\r\nEmitJobSetup(\r\n    PDEVOBJ pdevobj,\r\n    PMYPDEV pOEM\r\n) {\r\n    BYTE cmdbuf[CCHMAXCMDLEN];\r\n    WORD wlen = 0;\r\n    BYTE jOutput[64];\r\n    DWORD dwNeeded;\r\n    DWORD dwOptionsReturned;\r\n\r\n    if (pOEM->dwGeneral & FG_HAS_EMUL) {\r\n        // Alster emulation mode setting\r\n        cmdbuf[wlen++] = 0x1B;\r\n        cmdbuf[wlen++] = 'i';\r\n        cmdbuf[wlen++] = 'w';\r\n        cmdbuf[wlen++] = '0';\r\n    }\r\n\r\n    WRITESPOOLBUF(pdevobj, cmdbuf, wlen);\r\n\r\n    if (!DRVGETDRIVERSETTING(\r\n            pdevobj, \"MPFSetting\", jOutput,\r\n            sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {\r\n        WARNING((\"DrvGetDriverSetting(1) Failed\\n\"));\r\n        pOEM->jMPFSetting = MPF_NOSET;\r\n    } else {\r\n        if (!strcmp(jOutput, OPT_A3)) {\r\n            pOEM->jMPFSetting = MPF_A3;\r\n            VERBOSE((\"MPF_A3\\n\"));\r\n        } else if (!strcmp(jOutput, OPT_B4)) {\r\n            pOEM->jMPFSetting = MPF_B4;\r\n            VERBOSE((\"MPF_B4\\n\"));\r\n        } else if (!strcmp(jOutput, OPT_A4)) {\r\n            pOEM->jMPFSetting = MPF_A4;\r\n            VERBOSE((\"MPF_A4\\n\"));\r\n        } else if (!strcmp(jOutput, OPT_B5)) {\r\n            pOEM->jMPFSetting = MPF_B5;\r\n            VERBOSE((\"MPF_B5\\n\"));\r\n        } else if (!strcmp(jOutput, OPT_A5)) {\r\n            pOEM->jMPFSetting = MPF_A5;\r\n            VERBOSE((\"MPF_A5\\n\"));\r\n        } else if (!strcmp(jOutput, OPT_LETTER)) {\r\n            pOEM->jMPFSetting = MPF_LETTER;\r\n            VERBOSE((\"MPF_LETTER\\n\"));\r\n        } else if (!strcmp(jOutput, OPT_POSTCARD)) {\r\n            pOEM->jMPFSetting = MPF_POSTCARD;\r\n            VERBOSE((\"MPF_POSTCARD\\n\"));\r\n        } else {\r\n            pOEM->jMPFSetting = MPF_NOSET;\r\n            VERBOSE((\"MPF_NOSET\\n\"));\r\n        }\r\n    }\r\n}", "item_id": 4, "repo": "npocmaka/Windows-Server-2003", "file": "printscan/print/drivers/usermode/gpdres/capplres/capplres.c", "last_update_at": "2021-09-16T09:13:13+00:00", "question_id": "6b2208e1051da968f7b94f9b07205b225f32c282_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static\r\nVOID\r\nEmitJobSetup(\r\n    PDEVOBJ pdevobj,\r\n    PMYPDEV pOEM\r\n) {\r\n    BYTE cmdbuf[CCHMAXCMDLEN];\r\n    WORD wlen = 0;\r\n    BYTE jOutput[64];\r\n    DWORD dwNeeded;\r\n    DWORD dwOptionsReturned;\r\n\r\n    if (pOEM->dwGeneral & FG_HAS_EMUL) {\r\n        // Alster emulation mode setting\r\n        cmdbuf[wlen++] = 0x1B;\r\n        cmdbuf[wlen++] = 'i';\r\n        cmdbuf[wlen++] = 'w';\r\n        cmdbuf[wlen++] = '0';\r\n    }\r\n\r\n    WRITESPOOLBUF(pdevobj, cmdbuf, wlen);\r\n\r\n    if (!DRVGETDRIVERSETTING(\r\n            pdevobj, \"MPFSetting\", jOutput,\r\n            sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {\r\n        WARNING((\"DrvGetDriverSetting(1) Failed\\n\"));\r\n        pOEM->jMPFSetting = MPF_NOSET;\r\n    } else {\r\n        if (!strcmp(jOutput, OPT_A3)) {\r\n            pOEM->jMPFSetting = MPF_A3;\r\n            VERBOSE((\"MPF_A3\\n\"));\r\n        } else if (!strcmp(jOutput, OPT_B4)) {\r\n            pOEM->jMPFSetting = MPF_B4;\r\n            VERBOSE((\"MPF_B4\\n\"));\r\n        } else if (!strcmp(jOutput, OPT_A4)) {\r\n            pOEM->jMPFSetting = MPF_A4;\r\n            VERBOSE((\"MPF_A4\\n\"));\r\n        } else if (!strcmp(jOutput, OPT_B5)) {\r\n            pOEM->jMPFSetting = MPF_B5;\r\n            VERBOSE((\"MPF_B5\\n\"));\r\n        } else if (!strcmp(jOutput, OPT_A5)) {\r\n            pOEM->jMPFSetting = MPF_A5;\r\n            VERBOSE((\"MPF_A5\\n\"));\r\n        } else if (!strcmp(jOutput, OPT_LETTER)) {\r\n            pOEM->jMPFSetting = MPF_LETTER;\r\n            VERBOSE((\"MPF_LETTER\\n\"));\r\n        } else if (!strcmp(jOutput, OPT_POSTCARD)) {\r\n            pOEM->jMPFSetting = MPF_POSTCARD;\r\n            VERBOSE((\"MPF_POSTCARD\\n\"));\r\n        } else {\r\n            pOEM->jMPFSetting = MPF_NOSET;\r\n            VERBOSE((\"MPF_NOSET\\n\"));\r\n        }\r\n    }\r\n"]]}
{"hexsha": "369d385cd5269f3896bc976c05c341dc956f78a8", "ext": "c", "lang": "C", "content": "static double\nbddCorrelationWeightsAux(\n  DdManager * dd,\n  DdNode * f,\n  DdNode * g,\n  double * prob,\n  st_table * table)\n{\n    DdNode\t*Fv, *Fnv, *G, *Gv, *Gnv;\n    double\tmin, *pmin, min1, min2, *dummy;\n    HashEntry\t*entry;\n    int\t\ttopF, topG, index;\n\n    statLine(dd);\n#ifdef CORREL_STATS\n    num_calls++;\n#endif\n\n    /* Terminal cases: only work for BDDs. */\n    if (f == g) return(1.0);\n    if (f == Cudd_Not(g)) return(0.0);\n\n    /* Standardize call using the following properties:\n    **     (f EXNOR g)   = (g EXNOR f)\n    **     (f' EXNOR g') = (f EXNOR g).\n    */\n    if (f > g) {\n\tDdNode *tmp = f;\n\tf = g; g = tmp;\n    }\n    if (Cudd_IsComplement(f)) {\n\tf = Cudd_Not(f);\n\tg = Cudd_Not(g);\n    }\n    /* From now on, f is regular. */\n    \n    entry = ALLOC(HashEntry,1);\n    if (entry == NULL) {\n\tdd->errorCode = CUDD_MEMORY_OUT;\n\treturn((double)CUDD_OUT_OF_MEM);\n    }\n    entry->f = f; entry->g = g;\n\n    /* We do not use the fact that\n    ** correlation(f,g') = 1 - correlation(f,g)\n    ** to minimize the risk of cancellation.\n    */\n    if (st_lookup(table, entry, &dummy)) {\n\tmin = *dummy;\n\tFREE(entry);\n\treturn(min);\n    }\n\n    G = Cudd_Regular(g);\n    topF = cuddI(dd,f->index); topG = cuddI(dd,G->index);\n    if (topF <= topG) {\n\tFv = cuddT(f); Fnv = cuddE(f);\n\tindex = f->index;\n    } else {\n\tFv = Fnv = f;\n\tindex = G->index;\n    }\n    if (topG <= topF) { Gv = cuddT(G); Gnv = cuddE(G); } else { Gv = Gnv = G; }\n\n    if (g != G) {\n\tGv = Cudd_Not(Gv);\n\tGnv = Cudd_Not(Gnv);\n    }\n\n    min1 = bddCorrelationWeightsAux(dd, Fv, Gv, prob, table) * prob[index];\n    if (min1 == (double)CUDD_OUT_OF_MEM) {\n\tFREE(entry);\n\treturn((double)CUDD_OUT_OF_MEM);\n    }\n    min2 = bddCorrelationWeightsAux(dd, Fnv, Gnv, prob, table) * (1.0 - prob[index]); \n    if (min2 == (double)CUDD_OUT_OF_MEM) {\n\tFREE(entry);\n\treturn((double)CUDD_OUT_OF_MEM);\n    }\n    min = (min1+min2);\n    \n    pmin = ALLOC(double,1);\n    if (pmin == NULL) {\n\tdd->errorCode = CUDD_MEMORY_OUT;\n\treturn((double)CUDD_OUT_OF_MEM);\n    }\n    *pmin = min;\n\n    if (st_insert(table,(char *)entry, (char *)pmin) == ST_OUT_OF_MEM) {\n\tFREE(entry);\n\tFREE(pmin);\n\treturn((double)CUDD_OUT_OF_MEM);\n    }\n    return(min);\n\n}", "item_id": 3, "repo": "kushgrover/apt-vs-dift", "file": "src/prism-games/cudd/cudd/cuddBddCorr.c", "last_update_at": "2021-09-08T08:42:42+00:00", "question_id": "369d385cd5269f3896bc976c05c341dc956f78a8_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static double\nbddCorrelationWeightsAux(\n  DdManager * dd,\n  DdNode * f,\n  DdNode * g,\n  double * prob,\n  st_table * table)\n{\n    DdNode\t*Fv, *Fnv, *G, *Gv, *Gnv;\n    double\tmin, *pmin, min1, min2, *dummy;\n    HashEntry\t*entry;\n    int\t\ttopF, topG, index;\n    statLine(dd);\n#ifdef CORREL_STATS\n    num_calls++;\n#endif\n    /* Terminal cases: only work for BDDs. */\n    if (f == g) return(1.0);\n    if (f == Cudd_Not(g)) return(0.0);\n    /* Standardize call using the following properties:\n    **     (f EXNOR g)   = (g EXNOR f)\n    **     (f' EXNOR g') = (f EXNOR g).\n    */\n    if (f > g) {\n\tDdNode *tmp = f;\n\tf = g; g = tmp;\n    }\n    if (Cudd_IsComplement(f)) {\n\tf = Cudd_Not(f);\n\tg = Cudd_Not(g);\n    }\n    /* From now on, f is regular. */\n    entry = ALLOC(HashEntry,1);\n    if (entry == NULL) {\n\tdd->errorCode = CUDD_MEMORY_OUT;\n\treturn((double)CUDD_OUT_OF_MEM);\n    }\n    entry->f = f; entry->g = g;\n    /* We do not use the fact that\n    ** correlation(f,g') = 1 - correlation(f,g)\n    ** to minimize the risk of cancellation.\n    */\n    if (st_lookup(table, entry, &dummy)) {\n\tmin = *dummy;\n\tFREE(entry);\n\treturn(min);\n    }\n    G = Cudd_Regular(g);\n    topF = cuddI(dd,f->index); topG = cuddI(dd,G->index);\n    if (topF <= topG) {\n\tFv = cuddT(f); Fnv = cuddE(f);\n\tindex = f->index;\n    } else {\n\tFv = Fnv = f;\n\tindex = G->index;\n    }\n    if (topG <= topF) { Gv = cuddT(G); Gnv = cuddE(G); } else { Gv = Gnv = G; }\n    if (g != G) {\n\tGv = Cudd_Not(Gv);\n\tGnv = Cudd_Not(Gnv);\n    }\n    min1 = bddCorrelationWeightsAux(dd, Fv, Gv, prob, table) * prob[index];\n    if (min1 == (double)CUDD_OUT_OF_MEM) {\n\tFREE(entry);\n\treturn((double)CUDD_OUT_OF_MEM);\n    }\n    min2 = bddCorrelationWeightsAux(dd, Fnv, Gnv, prob, table) * (1.0 - prob[index]); \n    if (min2 == (double)CUDD_OUT_OF_MEM) {\n\tFREE(entry);\n\treturn((double)CUDD_OUT_OF_MEM);\n    }\n    min = (min1+min2);\n    pmin = ALLOC(double,1);\n    if (pmin == NULL) {\n\tdd->errorCode = CUDD_MEMORY_OUT;\n\treturn((double)CUDD_OUT_OF_MEM);\n    }\n    *pmin = min;\n    if (st_insert(table,(char *)entry, (char *)pmin) == ST_OUT_OF_MEM) {\n\tFREE(entry);\n\tFREE(pmin);\n\treturn((double)CUDD_OUT_OF_MEM);\n    }\n    return(min);\n"]]}
{"hexsha": "c2d8c23e1a5e62cf6a349d3c0d100f28a71db008", "ext": "c", "lang": "C", "content": "void f64(void) {\n    \tint32_t x2001 = -1;\n\tstatic volatile int64_t x2002 = INT64_MIN;\n\tvolatile uint8_t x2003 = 8U;\n\tvolatile int8_t x2004 = 0;\n\tvolatile int32_t t64 = -5;\n\n    t64 = ((x2001>(x2002!=x2003))<<x2004);\n\n    if (t64 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 64, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test1294.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "c2d8c23e1a5e62cf6a349d3c0d100f28a71db008_64", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f64(void) {\n    \tint32_t x2001 = -1;\n\tstatic volatile int64_t x2002 = INT64_MIN;\n\tvolatile uint8_t x2003 = 8U;\n\tvolatile int8_t x2004 = 0;\n\tvolatile int32_t t64 = -5;\n    t64 = ((x2001>(x2002!=x2003))<<x2004);\n    if (t64 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "783489be72fd659762793306aeeebc837500ed75", "ext": "c", "lang": "C", "content": "void viulite_sw_reset(VIU_Registers_t *const reg_base)\n{\n  uint32_t  reg_value;\n  reg_value = reg_base->SCR;\n\n  reg_value &= ~SCR_SWRESET_MASK;\n  reg_base->SCR = reg_value;\n\n  reg_value |= SCR_SWRESET_MASK;\n  reg_base->SCR = reg_value;\n\n  reg_value &= ~SCR_SWRESET_MASK;\n  reg_base->SCR = reg_value;\n}", "item_id": 8, "repo": "intesight/Panorama4AIWAYS", "file": "s32v234_sdk/libs/isp/viu/kernel/src/viulite_core.c", "last_update_at": "2021-01-28T10:47:37+00:00", "question_id": "783489be72fd659762793306aeeebc837500ed75_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void viulite_sw_reset(VIU_Registers_t *const reg_base)\n{\n  uint32_t  reg_value;\n  reg_value = reg_base->SCR;\n  reg_value &= ~SCR_SWRESET_MASK;\n  reg_base->SCR = reg_value;\n  reg_value |= SCR_SWRESET_MASK;\n  reg_base->SCR = reg_value;\n  reg_value &= ~SCR_SWRESET_MASK;\n  reg_base->SCR = reg_value;\n"]]}
{"hexsha": "14a546faa900cd2b44734f5699152ab55a526473", "ext": "c", "lang": "C", "content": "static void hal_entry_mp()\n{\n    // Switch to CPU-private stack\n    ulong sp = get_my_cpu_init_stack_top_vaddr();\n    ulong pc = (ulong)&hal_mp;\n\n    __asm__ __volatile__ (\n        // Set up stack top\n        \"ori    $29, %[sp], 0;\"\n\n        // Jump to target\n        \"jr     %[pc];\"\n        \"nop;\"\n        :\n        : [pc] \"r\" (pc), [sp] \"r\" (sp - 16)\n        : \"memory\"\n    );\n\n    unreachable();\n}", "item_id": 15, "repo": "zhengruohuang/toddler-ng", "file": "src/arch/mips/hal/setup.c", "last_update_at": "2021-08-02T08:03:51+00:00", "question_id": "14a546faa900cd2b44734f5699152ab55a526473_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void hal_entry_mp()\n{\n    // Switch to CPU-private stack\n    ulong sp = get_my_cpu_init_stack_top_vaddr();\n    ulong pc = (ulong)&hal_mp;\n    __asm__ __volatile__ (\n        // Set up stack top\n        \"ori    $29, %[sp], 0;\"\n        // Jump to target\n        \"jr     %[pc];\"\n        \"nop;\"\n        :\n        : [pc] \"r\" (pc), [sp] \"r\" (sp - 16)\n        : \"memory\"\n    );\n    unreachable();\n"]]}
{"hexsha": "9ac859409b2ae871a73d916ba9e0b127adcddc6e", "ext": "h", "lang": "C", "content": "interface LinkChargerCC : ComponentControl <tGraphDataSource>\n{\n    unsigned int pmuPowerService;\t// 128 = 0x80\n    double _targetTimeCloaking;\t// 136 = 0x88\n    double _targetTimeCharging;\t// 144 = 0x90\n    double _defaultTargetTimeCloaking;\t// 152 = 0x98\n    double _defaultTargetTimeCharging;\t// 160 = 0xa0\n    double _targetTimeWirelessMatCloaking;\t// 168 = 0xa8\n    double _targetTimeWirelessMatCharging;\t// 176 = 0xb0\n    double _remainingTimeInterval;\t// 184 = 0xb8\n    double _remainingInitialNoCloakTime;\t// 192 = 0xc0\n    int _skipFirstChargeThreshold;\t// 200 = 0xc8\n    int _chargerType;\t// 204 = 0xcc\n    _Bool _currentlyCloaked;\t// 208 = 0xd0\n    _Bool _isOnCharger;\t// 209 = 0xd1\n    AggDThermalMonitor *_aggdController;\t// 216 = 0xd8\n    double _previousTimeStamp;\t// 224 = 0xe0\n}", "item_id": 0, "repo": "lechium/tvOS144Headers", "file": "usr/sbin/usr/libexec/thermalmonitord/LinkChargerCC.h", "last_update_at": "2021-08-19T19:00:09+00:00", "question_id": "9ac859409b2ae871a73d916ba9e0b127adcddc6e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface LinkChargerCC : ComponentControl <tGraphDataSource>\n{\n    unsigned int pmuPowerService;\t// 128 = 0x80\n    double _targetTimeCloaking;\t// 136 = 0x88\n    double _targetTimeCharging;\t// 144 = 0x90\n    double _defaultTargetTimeCloaking;\t// 152 = 0x98\n    double _defaultTargetTimeCharging;\t// 160 = 0xa0\n    double _targetTimeWirelessMatCloaking;\t// 168 = 0xa8\n    double _targetTimeWirelessMatCharging;\t// 176 = 0xb0\n    double _remainingTimeInterval;\t// 184 = 0xb8\n    double _remainingInitialNoCloakTime;\t// 192 = 0xc0\n    int _skipFirstChargeThreshold;\t// 200 = 0xc8\n    int _chargerType;\t// 204 = 0xcc\n    _Bool _currentlyCloaked;\t// 208 = 0xd0\n    _Bool _isOnCharger;\t// 209 = 0xd1\n    AggDThermalMonitor *_aggdController;\t// 216 = 0xd8\n    double _previousTimeStamp;\t// 224 = 0xe0\n"]]}
{"hexsha": "e733bb8c00c20bb7f75a17185eca4412998b6a9b", "ext": "c", "lang": "C", "content": "static uMToken *\nget_dimension (sMSCtx *c, int fSigned, int fNegate)\n{\n  const char *non_tt_param=NULL;\n  uint64_t v_r = 0ULL, v1;\n  \n  if (GET_CHAR (c) == 'Q')\n    {\n      INC_CHAR (c);\n      non_tt_param=\"'non-type-template-parameter\";\n    }\n  if (GET_CHAR (c) == 0)\n    {\n      c->err = 2;\n      return NULL;\n    }\n  if (GET_CHAR (c) >= '0' && GET_CHAR (c) <= '9')\n    {\n      uint64_t v = (uint64_t) ((GET_CHAR (c)-'0') + 1);\n      INC_CHAR (c);\n      return gen_dim (c->gc, eMST_dim,v, non_tt_param, fSigned, fNegate);\n    }\n\n  while (GET_CHAR (c) != '@')\n    {\n      if (GET_CHAR (c) == 0)\n        {\n          c->err = 2;\n          return NULL;\n        }\n      if (GET_CHAR (c) < 'A' || GET_CHAR (c) > 'P')\n        {\n          c->err = 1;\n          return NULL;\n        }\n      v1=(uint64_t) (GET_CHAR (c) - 'A');\n      v_r = v_r*10ULL + v1;\n      INC_CHAR (c);\n    }\n  if (GET_CHAR (c) !='@')\n    {\n      c->err = 1;\n      return NULL;\n    }\n  INC_CHAR (c);\n  return gen_dim (c->gc, eMST_dim,v_r, non_tt_param, fSigned, fNegate);\n}", "item_id": 5, "repo": "openharmony-gitee-mirror/third_party_mingw-w64", "file": "mingw-w64-libraries/libmangle/src/m_ms.c", "last_update_at": "2021-09-13T11:19:44+00:00", "question_id": "e733bb8c00c20bb7f75a17185eca4412998b6a9b_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static uMToken *\nget_dimension (sMSCtx *c, int fSigned, int fNegate)\n{\n  const char *non_tt_param=NULL;\n  uint64_t v_r = 0ULL, v1;\n  if (GET_CHAR (c) == 'Q')\n    {\n      INC_CHAR (c);\n      non_tt_param=\"'non-type-template-parameter\";\n    }\n  if (GET_CHAR (c) == 0)\n    {\n      c->err = 2;\n      return NULL;\n    }\n  if (GET_CHAR (c) >= '0' && GET_CHAR (c) <= '9')\n    {\n      uint64_t v = (uint64_t) ((GET_CHAR (c)-'0') + 1);\n      INC_CHAR (c);\n      return gen_dim (c->gc, eMST_dim,v, non_tt_param, fSigned, fNegate);\n    }\n  while (GET_CHAR (c) != '@')\n    {\n      if (GET_CHAR (c) == 0)\n        {\n          c->err = 2;\n          return NULL;\n        }\n      if (GET_CHAR (c) < 'A' || GET_CHAR (c) > 'P')\n        {\n          c->err = 1;\n          return NULL;\n        }\n      v1=(uint64_t) (GET_CHAR (c) - 'A');\n      v_r = v_r*10ULL + v1;\n      INC_CHAR (c);\n    }\n  if (GET_CHAR (c) !='@')\n    {\n      c->err = 1;\n      return NULL;\n    }\n  INC_CHAR (c);\n  return gen_dim (c->gc, eMST_dim,v_r, non_tt_param, fSigned, fNegate);\n"]]}
{"hexsha": "0083de05ce6030c3589f1277b395907b8cc8bc4a", "ext": "c", "lang": "C", "content": "void f34(void) {\n    \tint8_t x137 = -50;\n\tvolatile uint32_t x138 = 8045658U;\n\tint16_t x139 = -3;\n\tvolatile int32_t x140 = -1;\n\tvolatile uint32_t t34 = 1005U;\n\n    t34 = (x137|(x138&(x139>x140)));\n\n    if (t34 != 4294967246U) { NG(); } else { ; }\n\t\n}", "item_id": 34, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test1735.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "0083de05ce6030c3589f1277b395907b8cc8bc4a_34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f34(void) {\n    \tint8_t x137 = -50;\n\tvolatile uint32_t x138 = 8045658U;\n\tint16_t x139 = -3;\n\tvolatile int32_t x140 = -1;\n\tvolatile uint32_t t34 = 1005U;\n    t34 = (x137|(x138&(x139>x140)));\n    if (t34 != 4294967246U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "9ecec34dbb5588ba5e11f7befd5c9ec0a6cff329", "ext": "c", "lang": "C", "content": "void f195(void) {\n    \tint8_t x929 = -3;\n\tint32_t x931 = INT32_MIN;\n\tstatic int16_t x932 = INT16_MAX;\n\tint32_t t195 = 0;\n\n    t195 = (((x929|x930)*x931)!=x932);\n\n    if (t195 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 195, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test2387.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "9ecec34dbb5588ba5e11f7befd5c9ec0a6cff329_195", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f195(void) {\n    \tint8_t x929 = -3;\n\tint32_t x931 = INT32_MIN;\n\tstatic int16_t x932 = INT16_MAX;\n\tint32_t t195 = 0;\n    t195 = (((x929|x930)*x931)!=x932);\n    if (t195 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "68e666db7f84d65a85239c7ad12aa1cb8c8e270e", "ext": "c", "lang": "C", "content": "static void heap_push(heap *h, void *e) {\n    if (h->size >= h->capacity) {\n        h->capacity *= 2;\n        h->data = (void **) realloc(h->data, (h->capacity) * sizeof(void *));\n    }\n    int i = h->size;\n    h->data[h->size++] = e;\n    if (i == 0)\n        return;\n\n    void **data = h->data;\n    for (int parent; i > 0; i = parent) {\n        parent = (i - 1) / 2;\n        void *p = data[parent];\n        if (h->compare(p, e) <= 0)\n            break;\n        data[i] = p;\n    }\n    data[i] = e;\n}", "item_id": 3, "repo": "qianbinbin/leetcode", "file": "c/src/merge_k_sorted_lists.c", "last_update_at": "2021-03-15T14:19:44+00:00", "question_id": "68e666db7f84d65a85239c7ad12aa1cb8c8e270e_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void heap_push(heap *h, void *e) {\n    if (h->size >= h->capacity) {\n        h->capacity *= 2;\n        h->data = (void **) realloc(h->data, (h->capacity) * sizeof(void *));\n    }\n    int i = h->size;\n    h->data[h->size++] = e;\n    if (i == 0)\n        return;\n    void **data = h->data;\n    for (int parent; i > 0; i = parent) {\n        parent = (i - 1) / 2;\n        void *p = data[parent];\n        if (h->compare(p, e) <= 0)\n            break;\n        data[i] = p;\n    }\n    data[i] = e;\n"]]}
{"hexsha": "6c1c1a1bd751ff295e491b9dcc03355c7043cc27", "ext": "c", "lang": "C", "content": "static KMETHOD cevhttp_uri_parse_query_str(KonohaContext *kctx, KonohaStack *sfp)\n{\n\tkString *uri = sfp[1].asString;\n\tkcevkeyvalq *headers = (kcevkeyvalq *)sfp[2].asObject;\n\tKReturnUnboxValue(evhttp_parse_query_str(kString_text(uri), headers->keyvalq));\n}", "item_id": 203, "repo": "konoha-project/konoha3", "file": "src/package-devel/Lib.Libevent/Libevent_glue.c", "last_update_at": "2021-08-10T05:32:16+00:00", "question_id": "6c1c1a1bd751ff295e491b9dcc03355c7043cc27_203", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static KMETHOD cevhttp_uri_parse_query_str(KonohaContext *kctx, KonohaStack *sfp)\n{\n\tkString *uri = sfp[1].asString;\n\tkcevkeyvalq *headers = (kcevkeyvalq *)sfp[2].asObject;\n\tKReturnUnboxValue(evhttp_parse_query_str(kString_text(uri), headers->keyvalq));\n"]]}
{"hexsha": "6b24bdf3ea388ad692b56a3dd57c7bbcbadbbda4", "ext": "c", "lang": "C", "content": "void f135(void) {\n    \tint32_t x541 = INT32_MAX;\n\tstatic uint64_t x542 = 647LLU;\n\tvolatile uint16_t x543 = UINT16_MAX;\n\tvolatile uint32_t x544 = 126011647U;\n\tuint64_t t135 = 86LLU;\n\n    t135 = (x541&(x542&(x543^x544)));\n\n    if (t135 != 512LLU) { NG(); } else { ; }\n\t\n}", "item_id": 135, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test2714.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "6b24bdf3ea388ad692b56a3dd57c7bbcbadbbda4_135", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f135(void) {\n    \tint32_t x541 = INT32_MAX;\n\tstatic uint64_t x542 = 647LLU;\n\tvolatile uint16_t x543 = UINT16_MAX;\n\tvolatile uint32_t x544 = 126011647U;\n\tuint64_t t135 = 86LLU;\n    t135 = (x541&(x542&(x543^x544)));\n    if (t135 != 512LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "05e5e41e314363d8dba2cefad8b5292443adc6be", "ext": "c", "lang": "C", "content": "hferr_t\nhandle_HFCUDA_cusparseCnnz ( void )\n{\n  hfinf( \"[daemon] cusparseCnnz() [CALL]\\n\" );\n  \n  struct __attribute__((packed)) {\n    uint8_t ____CAT2_BITMAP;\n    cusparseHandle_t handle;\n    cusparseDirection_t dirA;\n    int m;\n    int n;\n    cusparseMatDescr_t descrA;\n    const cuComplex * A;\n    int lda;\n    int * nnzPerRowCol;\n    int * nnzTotalDevHostPtr;\n  } t2d_msg_data;\n  \n  hfcheck( hfcuda_comm_recv( &t2d_msg_data, sizeof(t2d_msg_data) ));\n  struct {\n    cusparseStatus_t ____RETVAL;\n    int nnzTotalDevHostPtr;\n  } d2t_msg;\n  d2t_msg.____RETVAL = cusparseCnnz( t2d_msg_data.handle, t2d_msg_data.dirA, t2d_msg_data.m, t2d_msg_data.n, t2d_msg_data.descrA, t2d_msg_data.A, t2d_msg_data.lda, t2d_msg_data.nnzPerRowCol, (((t2d_msg_data.____CAT2_BITMAP >> 0) & 0x1) ? &d2t_msg.nnzTotalDevHostPtr : t2d_msg_data.nnzTotalDevHostPtr) );\n  \n  hfcheck( hfcuda_comm_send( &d2t_msg, sizeof(d2t_msg) ));\n  hfinf( \"[daemon] cusparseCnnz() [DONE] status=%d\\n\", d2t_msg.____RETVAL );\n  \n  return HFOK;\n}", "item_id": 486, "repo": "IBM/hf", "file": "hfcuda/wrappers/daemon_fnc_auto.c", "last_update_at": "2021-11-01T12:54:28+00:00", "question_id": "05e5e41e314363d8dba2cefad8b5292443adc6be_486", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["hferr_t\nhandle_HFCUDA_cusparseCnnz ( void )\n{\n  hfinf( \"[daemon] cusparseCnnz() [CALL]\\n\" );\n  struct __attribute__((packed)) {\n    uint8_t ____CAT2_BITMAP;\n    cusparseHandle_t handle;\n    cusparseDirection_t dirA;\n    int m;\n    int n;\n    cusparseMatDescr_t descrA;\n    const cuComplex * A;\n    int lda;\n    int * nnzPerRowCol;\n    int * nnzTotalDevHostPtr;\n  } t2d_msg_data;\n  hfcheck( hfcuda_comm_recv( &t2d_msg_data, sizeof(t2d_msg_data) ));\n  struct {\n    cusparseStatus_t ____RETVAL;\n    int nnzTotalDevHostPtr;\n  } d2t_msg;\n  d2t_msg.____RETVAL = cusparseCnnz( t2d_msg_data.handle, t2d_msg_data.dirA, t2d_msg_data.m, t2d_msg_data.n, t2d_msg_data.descrA, t2d_msg_data.A, t2d_msg_data.lda, t2d_msg_data.nnzPerRowCol, (((t2d_msg_data.____CAT2_BITMAP >> 0) & 0x1) ? &d2t_msg.nnzTotalDevHostPtr : t2d_msg_data.nnzTotalDevHostPtr) );\n  hfcheck( hfcuda_comm_send( &d2t_msg, sizeof(d2t_msg) ));\n  hfinf( \"[daemon] cusparseCnnz() [DONE] status=%d\\n\", d2t_msg.____RETVAL );\n  return HFOK;\n"]]}
{"hexsha": "85c045f85f1cbbcc1e1177e6d31d0b20f16045be", "ext": "c", "lang": "C", "content": "void UBLEBcastScan_createTask(void)\n{\n    Task_Params taskParams;\n\n    // Configure task\n    Task_Params_init(&taskParams);\n    taskParams.stack = ubsTaskStack;\n    taskParams.stackSize = UBS_TASK_STACK_SIZE;\n    taskParams.priority = UBS_TASK_PRIORITY;\n\n    Task_construct(&ubsTask, UBLEBcastScan_taskFxn, &taskParams, NULL);\n\n#ifdef USE_RCOSC\n    RCOSC_enableCalibration();\n#endif // USE_RCOSC\n}", "item_id": 0, "repo": "duplico/badge.lgbt", "file": "ccs_workspace/badge.lgbt/ble/uble_bcast_scan.c", "last_update_at": "2021-08-14T16:26:45+00:00", "question_id": "85c045f85f1cbbcc1e1177e6d31d0b20f16045be_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void UBLEBcastScan_createTask(void)\n{\n    Task_Params taskParams;\n    // Configure task\n    Task_Params_init(&taskParams);\n    taskParams.stack = ubsTaskStack;\n    taskParams.stackSize = UBS_TASK_STACK_SIZE;\n    taskParams.priority = UBS_TASK_PRIORITY;\n    Task_construct(&ubsTask, UBLEBcastScan_taskFxn, &taskParams, NULL);\n#ifdef USE_RCOSC\n    RCOSC_enableCalibration();\n#endif // USE_RCOSC\n"]]}
{"hexsha": "18c2660c74ebf9052793955cfb8fe4525f71099e", "ext": "c", "lang": "C", "content": "HANDLE LoadAcc(\r\n    HINSTANCE hmod,\r\n    HANDLE    hrl)\r\n{\r\n    PACCELCACHE * ppacNext;\r\n    HANDLE handle = NULL;\r\n\r\n    if (hrl != NULL) {\r\n\r\n        if (hrl = LOADRESOURCE(hmod, hrl)) {\r\n\r\n            PRESOURCE_ACCEL paccel;\r\n\r\n            if ((paccel = (PRESOURCE_ACCEL)LOCKRESOURCE(hrl, hmod)) != NULL) {\r\n\r\n                int nAccel = 0;\r\n                int i;\r\n                LPACCEL paccelT;\r\n\r\n                /*\r\n                 * Check if we've already loaded accelerators from this\r\n                 *  same address\r\n                 */\r\n                RtlEnterCriticalSection(&gcsAccelCache);\r\n                    ppacNext = FindAccResource(NULL, paccel);\r\n                    if (*ppacNext != NULL) {\r\n                        (*ppacNext)->dwLockCount++;\r\n                        handle = (*ppacNext)->hAccel;\r\n                    }\r\n                RtlLeaveCriticalSection(&gcsAccelCache);\r\n                /*\r\n                 * If we found this table on the global list,\r\n                 *  return the same handle (Win95 compat)\r\n                 */\r\n                if (handle != NULL) {\r\n                    goto UnlockAndFree;\r\n                }\r\n\r\n                while (!((paccel[nAccel].accel.fVirt) & FLASTKEY)) {\r\n\r\n                    if (paccel[nAccel].accel.fVirt & ~FACCEL_VALID) {\r\n                        RIPMSG0(RIP_WARNING, \"LoadAcc: Invalid Parameter\");\r\n                        goto UnlockAndFree;\r\n                    }\r\n\r\n                    nAccel++;\r\n                }\r\n\r\n                if (paccel[nAccel].accel.fVirt & ~FACCEL_VALID) {\r\n                    RIPMSG0(RIP_WARNING, \"LoadAcc: Invalid Parameter\");\r\n                    goto UnlockAndFree;\r\n                }\r\n\r\n                /*\r\n                 * Since the accelerator table is coming from a resource, each\r\n                 * element has an extra WORD of padding which we strip here\r\n                 * to conform with the public (and internal) ACCEL structure.\r\n                 */\r\n                paccelT = UserLocalAlloc(0, sizeof(ACCEL) * (nAccel + 1));\r\n                if (paccelT == NULL) {\r\n                    goto UnlockAndFree;\r\n                }\r\n                for (i = 0; i < nAccel + 1; i++) {\r\n                    paccelT[i] = paccel[i].accel;\r\n                }\r\n\r\n                handle = NtUserCreateAcceleratorTable(paccelT,\r\n                                                      nAccel + 1);\r\n\r\n                UserLocalFree(paccelT);\r\n\r\n                /*\r\n                 * Add this handle/address to the global table so\r\n                 *  we won't load it twice.\r\n                 */\r\n                if (handle != NULL) {\r\n                    AddAccResource(handle, paccel);\r\n                }\r\nUnlockAndFree:\r\n\r\n                UNLOCKRESOURCE(hrl, hmod);\r\n            }\r\n\r\n            FREERESOURCE(hrl, hmod);\r\n        }\r\n    }\r\n\r\n    return handle;\r\n}", "item_id": 6, "repo": "npocmaka/Windows-Server-2003", "file": "windows/core/ntuser/client/clres.c", "last_update_at": "2021-09-16T09:13:13+00:00", "question_id": "18c2660c74ebf9052793955cfb8fe4525f71099e_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["HANDLE LoadAcc(\r\n    HINSTANCE hmod,\r\n    HANDLE    hrl)\r\n{\r\n    PACCELCACHE * ppacNext;\r\n    HANDLE handle = NULL;\r\n\r\n    if (hrl != NULL) {\r\n\r\n        if (hrl = LOADRESOURCE(hmod, hrl)) {\r\n\r\n            PRESOURCE_ACCEL paccel;\r\n\r\n            if ((paccel = (PRESOURCE_ACCEL)LOCKRESOURCE(hrl, hmod)) != NULL) {\r\n\r\n                int nAccel = 0;\r\n                int i;\r\n                LPACCEL paccelT;\r\n\r\n                /*\r\n                 * Check if we've already loaded accelerators from this\r\n                 *  same address\r\n                 */\r\n                RtlEnterCriticalSection(&gcsAccelCache);\r\n                    ppacNext = FindAccResource(NULL, paccel);\r\n                    if (*ppacNext != NULL) {\r\n                        (*ppacNext)->dwLockCount++;\r\n                        handle = (*ppacNext)->hAccel;\r\n                    }\r\n                RtlLeaveCriticalSection(&gcsAccelCache);\r\n                /*\r\n                 * If we found this table on the global list,\r\n                 *  return the same handle (Win95 compat)\r\n                 */\r\n                if (handle != NULL) {\r\n                    goto UnlockAndFree;\r\n                }\r\n\r\n                while (!((paccel[nAccel].accel.fVirt) & FLASTKEY)) {\r\n\r\n                    if (paccel[nAccel].accel.fVirt & ~FACCEL_VALID) {\r\n                        RIPMSG0(RIP_WARNING, \"LoadAcc: Invalid Parameter\");\r\n                        goto UnlockAndFree;\r\n                    }\r\n\r\n                    nAccel++;\r\n                }\r\n\r\n                if (paccel[nAccel].accel.fVirt & ~FACCEL_VALID) {\r\n                    RIPMSG0(RIP_WARNING, \"LoadAcc: Invalid Parameter\");\r\n                    goto UnlockAndFree;\r\n                }\r\n\r\n                /*\r\n                 * Since the accelerator table is coming from a resource, each\r\n                 * element has an extra WORD of padding which we strip here\r\n                 * to conform with the public (and internal) ACCEL structure.\r\n                 */\r\n                paccelT = UserLocalAlloc(0, sizeof(ACCEL) * (nAccel + 1));\r\n                if (paccelT == NULL) {\r\n                    goto UnlockAndFree;\r\n                }\r\n                for (i = 0; i < nAccel + 1; i++) {\r\n                    paccelT[i] = paccel[i].accel;\r\n                }\r\n\r\n                handle = NtUserCreateAcceleratorTable(paccelT,\r\n                                                      nAccel + 1);\r\n\r\n                UserLocalFree(paccelT);\r\n\r\n                /*\r\n                 * Add this handle/address to the global table so\r\n                 *  we won't load it twice.\r\n                 */\r\n                if (handle != NULL) {\r\n                    AddAccResource(handle, paccel);\r\n                }\r\nUnlockAndFree:\r\n\r\n                UNLOCKRESOURCE(hrl, hmod);\r\n            }\r\n\r\n            FREERESOURCE(hrl, hmod);\r\n        }\r\n    }\r\n\r\n    return handle;\r\n"]]}
{"hexsha": "0d487ba257d795ee1fbb663515bea5ca4c82656e", "ext": "h", "lang": "C", "content": "interface HMDCentralMessageDispatcher : HMFMessageDispatcher {\n\n\tHMDMessageFilterChain* _messageFilterChain;\n\tHMDAdminEnforcementMessageFilter* _adminMsgFilter;\n\tHMFMessageDispatcher* _recvDispatcher;\n\tNSMutableDictionary* _remoteGateways;\n\tHMDSecureRemoteMessageFilter* _secureRemoteMessageFilter;\n\tHMFMessageDispatcher* _notificationDispatcher;\n\tHMDHomeManager* _homeManager;\n\tNSMutableArray* _relayedMessages;\n\n}", "item_id": 0, "repo": "lechium/iPhoneOS_12.1.1_Headers", "file": "System/Library/PrivateFrameworks/HomeKitDaemon.framework/HMDCentralMessageDispatcher.h", "last_update_at": "2021-04-13T07:22:20+00:00", "question_id": "0d487ba257d795ee1fbb663515bea5ca4c82656e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface HMDCentralMessageDispatcher : HMFMessageDispatcher {\n\tHMDMessageFilterChain* _messageFilterChain;\n\tHMDAdminEnforcementMessageFilter* _adminMsgFilter;\n\tHMFMessageDispatcher* _recvDispatcher;\n\tNSMutableDictionary* _remoteGateways;\n\tHMDSecureRemoteMessageFilter* _secureRemoteMessageFilter;\n\tHMFMessageDispatcher* _notificationDispatcher;\n\tHMDHomeManager* _homeManager;\n\tNSMutableArray* _relayedMessages;\n"]]}
{"hexsha": "da821485f0bb9d75336361b21ad5296793fd7c9f", "ext": "c", "lang": "C", "content": "x_int x_async_block(x_int fd, x_int timeout) {\n  x_async_entry entry = x_async_get(fd);\n  x_status status;\n  if(entry) {\n\n    /*\n    ** Check if we received data before we entered the call.\n    */ \n\n    if(entry->flags) {\n      entry->flags = 0;\n      entry->count--;\n      return 0;\n    }\n   \n    /*\n    ** Enter the monitor.\n    */\n    \n    status = x_monitor_eternal(&entry->monitor);\n\n    /*\n    ** Check once again if something changed while we \n    ** acquired the monitor.\n    */\n    \n    if(entry->flags) {\n      entry->flags = 0;\n      x_monitor_exit(&entry->monitor);\n      entry->count--;\n      return 0;\n    }\n   \n    /*\n    ** Wait until we are notified by the signal handler.\n    */\n    \n    status = x_monitor_wait(&entry->monitor, timeout);\n\n    /*\n    ** We've been notified (or a timeout has occured). \n    */\n\n    if(status == xs_success) {\n      x_monitor_exit(&entry->monitor);\n    }\n\n    if(entry->flags == 1) {\n      \n      /*\n      ** There's new data.\n      */\n\n      loempa(LEVEL, \"New data on %d\\n\", fd);\n      \n      entry->flags = 0;\n\n      entry->count--;\n      return 0;\n    }\n    else {\n\n      /*\n      ** Timeout.\n      */\n      \n      loempa(LEVEL, \"Timeout on %d\\n\", fd);\n      entry->count--;\n      return -1;\n    }\n    entry->count--;\n  }\n  else {\n    loempa(9, \"No entry for fd %d\\n\", fd);\n    x_thread_sleep(2);\n  }\n  return xs_success;\n}", "item_id": 6, "repo": "kifferltd/open-mika", "file": "vm-cmp/kernel/oswald/hal/host/linux/src/asyncio.c", "last_update_at": "2021-11-28T20:18:59+00:00", "question_id": "da821485f0bb9d75336361b21ad5296793fd7c9f_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["x_int x_async_block(x_int fd, x_int timeout) {\n  x_async_entry entry = x_async_get(fd);\n  x_status status;\n  if(entry) {\n    /*\n    ** Check if we received data before we entered the call.\n    */ \n    if(entry->flags) {\n      entry->flags = 0;\n      entry->count--;\n      return 0;\n    }\n    /*\n    ** Enter the monitor.\n    */\n    status = x_monitor_eternal(&entry->monitor);\n    /*\n    ** Check once again if something changed while we \n    ** acquired the monitor.\n    */\n    if(entry->flags) {\n      entry->flags = 0;\n      x_monitor_exit(&entry->monitor);\n      entry->count--;\n      return 0;\n    }\n    /*\n    ** Wait until we are notified by the signal handler.\n    */\n    status = x_monitor_wait(&entry->monitor, timeout);\n    /*\n    ** We've been notified (or a timeout has occured). \n    */\n    if(status == xs_success) {\n      x_monitor_exit(&entry->monitor);\n    }\n    if(entry->flags == 1) {\n      /*\n      ** There's new data.\n      */\n      loempa(LEVEL, \"New data on %d\\n\", fd);\n      entry->flags = 0;\n      entry->count--;\n      return 0;\n    }\n    else {\n      /*\n      ** Timeout.\n      */\n      loempa(LEVEL, \"Timeout on %d\\n\", fd);\n      entry->count--;\n      return -1;\n    }\n    entry->count--;\n  }\n  else {\n    loempa(9, \"No entry for fd %d\\n\", fd);\n    x_thread_sleep(2);\n  }\n  return xs_success;\n"]]}
{"hexsha": "c39c08f483f1ceba4cbcd9602bbf4a06e950d049", "ext": "c", "lang": "C", "content": "void f11(void) {\n    \tvolatile int8_t x46 = -1;\n\tint8_t x47 = -24;\n\tvolatile int32_t x48 = INT32_MIN;\n\tint32_t t11 = -842;\n\n    t11 = (((x45%x46)+x47)>x48);\n\n    if (t11 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 11, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test793.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "c39c08f483f1ceba4cbcd9602bbf4a06e950d049_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f11(void) {\n    \tvolatile int8_t x46 = -1;\n\tint8_t x47 = -24;\n\tvolatile int32_t x48 = INT32_MIN;\n\tint32_t t11 = -842;\n    t11 = (((x45%x46)+x47)>x48);\n    if (t11 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "9ecaf6a1e8475de4743f551784c667b1b5e7873e", "ext": "c", "lang": "C", "content": "static int skl_platform_soc_open(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai_link *dai_link = rtd->dai_link;\n\n\tdev_dbg(asoc_rtd_to_cpu(rtd, 0)->dev, \"In %s:%s\\n\", __func__,\n\t\t\t\t\tdai_link->cpus->dai_name);\n\n\tsnd_soc_set_runtime_hwparams(substream, &azx_pcm_hw);\n\n\treturn 0;\n}", "item_id": 18, "repo": "jainsakshi2395/linux", "file": "sound/soc/intel/skylake/skl-pcm.c", "last_update_at": "2021-01-27T01:29:47+00:00", "question_id": "9ecaf6a1e8475de4743f551784c667b1b5e7873e_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int skl_platform_soc_open(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai_link *dai_link = rtd->dai_link;\n\tdev_dbg(asoc_rtd_to_cpu(rtd, 0)->dev, \"In %s:%s\\n\", __func__,\n\t\t\t\t\tdai_link->cpus->dai_name);\n\tsnd_soc_set_runtime_hwparams(substream, &azx_pcm_hw);\n\treturn 0;\n"]]}
{"hexsha": "6cb2c68a2fb2881cf2de7ffc914ea39c4767fb32", "ext": "h", "lang": "C", "content": "int GetDirection16__Fiiii(int x1, int y1, int x2, int y2) {\n\t// address: 0xFFFFFEB8\n\t// size: 0x100\n\tauto unsigned char Dirs[16][16];\n\t// address: 0xFFFFFFB8\n\t// size: 0x5\n\tauto unsigned char lrtoul[5];\n\t// address: 0xFFFFFFC0\n\t// size: 0x5\n\tauto unsigned char urtoll[5];\n\t// address: 0xFFFFFFC8\n\t// size: 0x5\n\tauto unsigned char lltour[5];\n\t// address: 0xFFFFFFD0\n\t// size: 0x5\n\tauto unsigned char ultolr[5];\n\t// register: 16\n\tregister int mx;\n\t// register: 3\n\tregister int my;\n\t// register: 3\n\tregister int md;\n}", "item_id": 4, "repo": "maoa3/scalpel", "file": "psx/_dump_/29/_dump_c_/overlay_c.h", "last_update_at": "2021-09-27T15:57:18+00:00", "question_id": "6cb2c68a2fb2881cf2de7ffc914ea39c4767fb32_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int GetDirection16__Fiiii(int x1, int y1, int x2, int y2) {\n\t// address: 0xFFFFFEB8\n\t// size: 0x100\n\tauto unsigned char Dirs[16][16];\n\t// address: 0xFFFFFFB8\n\t// size: 0x5\n\tauto unsigned char lrtoul[5];\n\t// address: 0xFFFFFFC0\n\t// size: 0x5\n\tauto unsigned char urtoll[5];\n\t// address: 0xFFFFFFC8\n\t// size: 0x5\n\tauto unsigned char lltour[5];\n\t// address: 0xFFFFFFD0\n\t// size: 0x5\n\tauto unsigned char ultolr[5];\n\t// register: 16\n\tregister int mx;\n\t// register: 3\n\tregister int my;\n\t// register: 3\n\tregister int md;\n"]]}
{"hexsha": "cdcd88d68640783c52bd131ff69779f1d68e99b0", "ext": "c", "lang": "C", "content": "void f5(void) {\n    \tstatic volatile uint32_t x41 = 4000289U;\n\tvolatile int16_t x42 = INT16_MAX;\n\tuint8_t x43 = 2U;\n\tint64_t x44 = -1LL;\n\tuint32_t t5 = 89393U;\n\n    t5 = ((x41*x42)<<(x43==x44));\n\n    if (t5 != 2228450783U) { NG(); } else { ; }\n\t\n}", "item_id": 5, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1406.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "cdcd88d68640783c52bd131ff69779f1d68e99b0_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f5(void) {\n    \tstatic volatile uint32_t x41 = 4000289U;\n\tvolatile int16_t x42 = INT16_MAX;\n\tuint8_t x43 = 2U;\n\tint64_t x44 = -1LL;\n\tuint32_t t5 = 89393U;\n    t5 = ((x41*x42)<<(x43==x44));\n    if (t5 != 2228450783U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "047afa7b734b5260f071edea92bda562f2e7a872", "ext": "c", "lang": "C", "content": "struct anon_struct.conflictfa2 { // DWARF DIE: fa2\n    uint32_t notch_en;\n    int32_t spur_freq;\n}", "item_id": 3, "repo": "BraveHeartFLOSSDev/bl602nutcracker1", "file": "libwifi2/rfc_bl602.o.c", "last_update_at": "2021-08-10T04:58:20+00:00", "question_id": "047afa7b734b5260f071edea92bda562f2e7a872_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct anon_struct.conflictfa2 { // DWARF DIE: fa2\n    uint32_t notch_en;\n    int32_t spur_freq;\n"]]}
{"hexsha": "eeb2e88cca24f612348ecc88781f6f5d8e741b09", "ext": "c", "lang": "C", "content": "void f103(void) {\n    \tint16_t x421 = INT16_MIN;\n\tuint16_t x422 = UINT16_MAX;\n\tint32_t x423 = INT32_MIN;\n\tstatic uint8_t x424 = UINT8_MAX;\n\n    t103 = (((x421%x422)==x423)>x424);\n\n    if (t103 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 103, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test891.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "eeb2e88cca24f612348ecc88781f6f5d8e741b09_103", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f103(void) {\n    \tint16_t x421 = INT16_MIN;\n\tuint16_t x422 = UINT16_MAX;\n\tint32_t x423 = INT32_MIN;\n\tstatic uint8_t x424 = UINT8_MAX;\n    t103 = (((x421%x422)==x423)>x424);\n    if (t103 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "40546866bac9817b0beb32f25d3e9fe197eee232", "ext": "c", "lang": "C", "content": "void f169(void) {\n    \tuint16_t x885 = UINT16_MAX;\n\tstatic int8_t x886 = -1;\n\tint16_t x887 = INT16_MIN;\n\tint8_t x888 = -1;\n\tint32_t t169 = -1971;\n\n    t169 = ((x885&x886)==(x887*x888));\n\n    if (t169 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 169, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test554.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "40546866bac9817b0beb32f25d3e9fe197eee232_169", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f169(void) {\n    \tuint16_t x885 = UINT16_MAX;\n\tstatic int8_t x886 = -1;\n\tint16_t x887 = INT16_MIN;\n\tint8_t x888 = -1;\n\tint32_t t169 = -1971;\n    t169 = ((x885&x886)==(x887*x888));\n    if (t169 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "805aafd11e5e9d939f33694147e5379390592157", "ext": "c", "lang": "C", "content": "void ADC_initCustom(ADC_referenceSelect reference,\n        ADC_precisionSelect precision, ADC_inputSelect channel) {\n    // Set registers to their reset conditions..\n    ADC12CTL0 = 0;\n    ADC12CTL1 = 0;\n    ADC12CTL2 = 0;\n    ADC12MCTL0 = 0;\n    ADC12IER0 = 0;\n\n    // Select reference voltage.\n    ADC_setReference(reference);\n\n    // Turn on ADC.\n    ADC_enable();\n\n    // Enable using sample and hold pulse mode and use clock as source.\n    ADC_setSampleHold();\n\n    // Set resolution to 10 bits. (see user guide 25.3.3)\n    ADC_setPrecision(precision);\n\n    // enable interrupt\n    ADC_enableInterrupts();\n\n    // Select analog input channel.\n    ADC_setInputChannel(channel);\n\n    // Enable ADC conversions\n    ADC_enableConversion();\n}", "item_id": 0, "repo": "amjadmajid/stork", "file": "CRFID_firmware/STORKfull/wisp-base/Sensors/adc.c", "last_update_at": "2021-11-21T08:23:03+00:00", "question_id": "805aafd11e5e9d939f33694147e5379390592157_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void ADC_initCustom(ADC_referenceSelect reference,\n        ADC_precisionSelect precision, ADC_inputSelect channel) {\n    // Set registers to their reset conditions..\n    ADC12CTL0 = 0;\n    ADC12CTL1 = 0;\n    ADC12CTL2 = 0;\n    ADC12MCTL0 = 0;\n    ADC12IER0 = 0;\n    // Select reference voltage.\n    ADC_setReference(reference);\n    // Turn on ADC.\n    ADC_enable();\n    // Enable using sample and hold pulse mode and use clock as source.\n    ADC_setSampleHold();\n    // Set resolution to 10 bits. (see user guide 25.3.3)\n    ADC_setPrecision(precision);\n    // enable interrupt\n    ADC_enableInterrupts();\n    // Select analog input channel.\n    ADC_setInputChannel(channel);\n    // Enable ADC conversions\n    ADC_enableConversion();\n"]]}
{"hexsha": "63dc8800ac98af9f51a9579a03561dc2f1ff00b5", "ext": "c", "lang": "C", "content": "static struct enet_statistics *if_stats(netdevice_t *dev)\n#endif\n{\n\n\tppp_private_area_t *ppp_priv_area = dev->priv;\n\tsdla_t* card;\n\t\n\tif( ppp_priv_area == NULL )\n\t\treturn NULL;\n\n\tcard = ppp_priv_area->card;\n\treturn &card->wandev.stats;\n}", "item_id": 14, "repo": "enfoTek/tomato.linksys.e2000.nvram-mod", "file": "release/src/linux/linux/drivers/net/wan/sdla_ppp.c", "last_update_at": "2021-06-07T06:29:49+00:00", "question_id": "63dc8800ac98af9f51a9579a03561dc2f1ff00b5_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static struct enet_statistics *if_stats(netdevice_t *dev)\n#endif\n{\n\tppp_private_area_t *ppp_priv_area = dev->priv;\n\tsdla_t* card;\n\t\n\tif( ppp_priv_area == NULL )\n\t\treturn NULL;\n\tcard = ppp_priv_area->card;\n\treturn &card->wandev.stats;\n"]]}
{"hexsha": "0ff6af2bfda58d1ba6a149b42897197309a137b8", "ext": "c", "lang": "C", "content": "void f87(void) {\n    \tvolatile int16_t x390 = INT16_MIN;\n\tint64_t x391 = INT64_MAX;\n\tint32_t x392 = INT32_MIN;\n\tvolatile int32_t t87 = 454;\n\n    t87 = (((x389-x390)%x391)==x392);\n\n    if (t87 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 87, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test260.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "0ff6af2bfda58d1ba6a149b42897197309a137b8_87", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f87(void) {\n    \tvolatile int16_t x390 = INT16_MIN;\n\tint64_t x391 = INT64_MAX;\n\tint32_t x392 = INT32_MIN;\n\tvolatile int32_t t87 = 454;\n    t87 = (((x389-x390)%x391)==x392);\n    if (t87 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "ccc7532690e9eb12d04315c1484649a8834cf61d", "ext": "c", "lang": "C", "content": "int\nsockets_open(void)\n{\n\tint ipx_sock = -1;\t\t/* IPX socket\t\t\t*/\n\tint ax25_sock = -1;\t\t/* AX.25 socket\t\t\t*/\n\tint inet_sock = -1;\t\t/* INET socket\t\t\t*/\n\tint ddp_sock = -1;\t\t/* Appletalk DDP socket\t\t*/\n\n\tinet_sock=socket(AF_INET, SOCK_DGRAM, 0);\n\tipx_sock=socket(AF_IPX, SOCK_DGRAM, 0);\n\tax25_sock=socket(AF_AX25, SOCK_DGRAM, 0);\n\tddp_sock=socket(AF_APPLETALK, SOCK_DGRAM, 0);\n\t/*\n\t * Now pick any (exisiting) useful socket family for generic queries\n\t */\n\tif(inet_sock!=-1)\n\t\treturn inet_sock;\n\tif(ipx_sock!=-1)\n\t\treturn ipx_sock;\n\tif(ax25_sock!=-1)\n\t\treturn ax25_sock;\n\t/*\n\t * If this is -1 we have no known network layers and its time to jump.\n\t */\n\t \n\treturn ddp_sock;\n}", "item_id": 1, "repo": "y33988979/testhelper", "file": "src/driver/driver_stdver/ysip/iwcommon.c", "last_update_at": "2021-12-03T18:41:23+00:00", "question_id": "ccc7532690e9eb12d04315c1484649a8834cf61d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\nsockets_open(void)\n{\n\tint ipx_sock = -1;\t\t/* IPX socket\t\t\t*/\n\tint ax25_sock = -1;\t\t/* AX.25 socket\t\t\t*/\n\tint inet_sock = -1;\t\t/* INET socket\t\t\t*/\n\tint ddp_sock = -1;\t\t/* Appletalk DDP socket\t\t*/\n\tinet_sock=socket(AF_INET, SOCK_DGRAM, 0);\n\tipx_sock=socket(AF_IPX, SOCK_DGRAM, 0);\n\tax25_sock=socket(AF_AX25, SOCK_DGRAM, 0);\n\tddp_sock=socket(AF_APPLETALK, SOCK_DGRAM, 0);\n\t/*\n\t * Now pick any (exisiting) useful socket family for generic queries\n\t */\n\tif(inet_sock!=-1)\n\t\treturn inet_sock;\n\tif(ipx_sock!=-1)\n\t\treturn ipx_sock;\n\tif(ax25_sock!=-1)\n\t\treturn ax25_sock;\n\t/*\n\t * If this is -1 we have no known network layers and its time to jump.\n\t */\n\t \n\treturn ddp_sock;\n"]]}
{"hexsha": "d2c576268eed60813a04199beddb3f3569d9bfbc", "ext": "c", "lang": "C", "content": "static void\nviaDumpDMA(ViaCommandBuffer *cb)\n{\n    register CARD32 *bp = cb->buf;\n    CARD32 *endp = bp + cb->pos;\n\n    while (bp != endp) {\n        if (((bp - cb->buf) & 3) == 0) {\n            ErrorF(\"\\n %04lx: \", (unsigned long)(bp - cb->buf));\n        }\n        ErrorF(\"0x%08x \", (unsigned)*bp++);\n    }\n    ErrorF(\"\\n\");\n}", "item_id": 0, "repo": "freedesktop/openchrome-xf86-video-openchrome", "file": "src/via_exa.c", "last_update_at": "2021-09-24T05:29:38+00:00", "question_id": "d2c576268eed60813a04199beddb3f3569d9bfbc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nviaDumpDMA(ViaCommandBuffer *cb)\n{\n    register CARD32 *bp = cb->buf;\n    CARD32 *endp = bp + cb->pos;\n    while (bp != endp) {\n        if (((bp - cb->buf) & 3) == 0) {\n            ErrorF(\"\\n %04lx: \", (unsigned long)(bp - cb->buf));\n        }\n        ErrorF(\"0x%08x \", (unsigned)*bp++);\n    }\n    ErrorF(\"\\n\");\n"]]}
{"hexsha": "003249075a400561ec34b8132e96b04f03eaba68", "ext": "c", "lang": "C", "content": "void f32(void) {\n    \tint16_t x137 = -101;\n\tvolatile int64_t x138 = INT64_MAX;\n\tuint32_t x139 = UINT32_MAX;\n\tvolatile int8_t x140 = INT8_MAX;\n\tstatic volatile int32_t t32 = -7032;\n\n    t32 = ((x137%x138)==(x139%x140));\n\n    if (t32 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 32, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test848.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "003249075a400561ec34b8132e96b04f03eaba68_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f32(void) {\n    \tint16_t x137 = -101;\n\tvolatile int64_t x138 = INT64_MAX;\n\tuint32_t x139 = UINT32_MAX;\n\tvolatile int8_t x140 = INT8_MAX;\n\tstatic volatile int32_t t32 = -7032;\n    t32 = ((x137%x138)==(x139%x140));\n    if (t32 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "aa5477d5e34de2413d583f4adff74395d3baafaf", "ext": "c", "lang": "C", "content": "void f85(void) {\n    \tint64_t x341 = -544139046299LL;\n\tvolatile int64_t x342 = -1LL;\n\tint64_t x343 = INT64_MIN;\n\tint16_t x344 = INT16_MIN;\n\tint32_t t85 = -1347;\n\n    t85 = (((x341>x342)^x343)!=x344);\n\n    if (t85 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 85, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test1757.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "aa5477d5e34de2413d583f4adff74395d3baafaf_85", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f85(void) {\n    \tint64_t x341 = -544139046299LL;\n\tvolatile int64_t x342 = -1LL;\n\tint64_t x343 = INT64_MIN;\n\tint16_t x344 = INT16_MIN;\n\tint32_t t85 = -1347;\n    t85 = (((x341>x342)^x343)!=x344);\n    if (t85 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "3677bdd480e24f71a24755423a5d1fc5d8b816ef", "ext": "c", "lang": "C", "content": "static char *ucfg_string_escape(char *str)\n{\n\tchar *tmp, *res, *old_pos;\n\n\ttmp = old_pos = str;\n\tres = ucfg_xmalloc(1);\n\t*res = '\\0';\n\n\twhile ((tmp = strchr(tmp, '\"')) != NULL) {\n\t\tint res_old_len = strlen(res) + 1;\n\t\tchar *res_old_end;\n\t\tint new_len = res_old_len + (tmp - old_pos + 1) + 1;\n\t\tres = ucfg_xrealloc(res, new_len);\n\t\tres_old_end = res + strlen(res);\n\t\tstrncpy(res_old_end, old_pos, tmp - old_pos + 1);\n\t\t*(res + new_len - 2) = '\"';\n\t\t*(res + new_len - 1) = '\\0';\n\n\t\t++tmp;\n\t\told_pos = tmp;\n\t}\n\n\t{\n\t\tchar *res_old_end;\n\t\tint new_len = strlen(res) + strlen(old_pos) + 1;\n\t\tres = ucfg_xrealloc(res, new_len);\n\t\tres_old_end = res + strlen(res);\n\t\tstrcpy(res_old_end, old_pos);\n\t}\n\n\treturn res;\n}", "item_id": 6, "repo": "tobbez/libucfg", "file": "ucfg.c", "last_update_at": "2021-11-08T11:20:18+00:00", "question_id": "3677bdd480e24f71a24755423a5d1fc5d8b816ef_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static char *ucfg_string_escape(char *str)\n{\n\tchar *tmp, *res, *old_pos;\n\ttmp = old_pos = str;\n\tres = ucfg_xmalloc(1);\n\t*res = '\\0';\n\twhile ((tmp = strchr(tmp, '\"')) != NULL) {\n\t\tint res_old_len = strlen(res) + 1;\n\t\tchar *res_old_end;\n\t\tint new_len = res_old_len + (tmp - old_pos + 1) + 1;\n\t\tres = ucfg_xrealloc(res, new_len);\n\t\tres_old_end = res + strlen(res);\n\t\tstrncpy(res_old_end, old_pos, tmp - old_pos + 1);\n\t\t*(res + new_len - 2) = '\"';\n\t\t*(res + new_len - 1) = '\\0';\n\t\t++tmp;\n\t\told_pos = tmp;\n\t}\n\t{\n\t\tchar *res_old_end;\n\t\tint new_len = strlen(res) + strlen(old_pos) + 1;\n\t\tres = ucfg_xrealloc(res, new_len);\n\t\tres_old_end = res + strlen(res);\n\t\tstrcpy(res_old_end, old_pos);\n\t}\n\treturn res;\n"]]}
{"hexsha": "ee86086fd2bd422ccc3f8c8a02b18cc3e4b86548", "ext": "c", "lang": "C", "content": "void f32(void) {\n    \tstatic int64_t x141 = INT64_MAX;\n\tstatic volatile uint16_t x142 = 319U;\n\tvolatile uint8_t x143 = UINT8_MAX;\n\tint8_t x144 = INT8_MAX;\n\n    t32 = ((x141^x142)>(x143-x144));\n\n    if (t32 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 32, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test387.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "ee86086fd2bd422ccc3f8c8a02b18cc3e4b86548_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f32(void) {\n    \tstatic int64_t x141 = INT64_MAX;\n\tstatic volatile uint16_t x142 = 319U;\n\tvolatile uint8_t x143 = UINT8_MAX;\n\tint8_t x144 = INT8_MAX;\n    t32 = ((x141^x142)>(x143-x144));\n    if (t32 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "6e83aeecd928e747ee4ba95b31cf6399f66786ef", "ext": "c", "lang": "C", "content": "static int dm_test_child_ofdata(struct unit_test_state *uts)\n{\n\tstruct udevice *bus, *dev;\n\tint count;\n\n\tut_assertok(uclass_first_device_err(UCLASS_TEST_BUS, &bus));\n\tcount = 0;\n\tdevice_foreach_child_of_to_plat(dev, bus) {\n\t\tut_assert(dev_get_flags(dev) & DM_FLAG_PLATDATA_VALID);\n\t\tut_assert(!(dev_get_flags(dev) & DM_FLAG_ACTIVATED));\n\t\tcount++;\n\t}\n\tut_asserteq(3, count);\n\n\treturn 0;\n}", "item_id": 33, "repo": "muddessir/framework", "file": "machine/qemu/sources/u-boot/test/dm/test-fdt.c", "last_update_at": "2021-11-21T19:56:29+00:00", "question_id": "6e83aeecd928e747ee4ba95b31cf6399f66786ef_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int dm_test_child_ofdata(struct unit_test_state *uts)\n{\n\tstruct udevice *bus, *dev;\n\tint count;\n\tut_assertok(uclass_first_device_err(UCLASS_TEST_BUS, &bus));\n\tcount = 0;\n\tdevice_foreach_child_of_to_plat(dev, bus) {\n\t\tut_assert(dev_get_flags(dev) & DM_FLAG_PLATDATA_VALID);\n\t\tut_assert(!(dev_get_flags(dev) & DM_FLAG_ACTIVATED));\n\t\tcount++;\n\t}\n\tut_asserteq(3, count);\n\treturn 0;\n"]]}
{"hexsha": "1150f92a15ed6b941499c95f9cae15b7315beb99", "ext": "c", "lang": "C", "content": "static void\ncm_session_neg_test(void **state) {\n    Sr__Msg *msg = NULL;\n    uint8_t *msg_buf = NULL;\n    size_t msg_size = 0;\n    int fd1 = 0, fd2 = 0;\n    uint32_t session_id1 = 0, session_id2 = 0;\n\n    fd1 = cm_connect_to_server(0);\n\n    /* try invalid version  */\n    cm_version_verify_generate(\"invalid\", &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    msg = cm_message_recv(fd1);\n    assert_non_null(msg);\n    assert_int_equal(msg->type, SR__MSG__MSG_TYPE__RESPONSE);\n    assert_non_null(msg->response);\n    assert_int_equal(msg->response->result, SR_ERR_VERSION_MISMATCH);\n    assert_int_equal(msg->response->operation, SR__OPERATION__VERSION_VERIFY);\n    assert_non_null(msg->response->version_verify_resp);\n    assert_string_equal_bt(msg->response->version_verify_resp->soname, SR_COMPAT_VERSION);\n    sr__msg__free_unpacked(msg, NULL);\n\n    /* disconnect expected */\n    msg = cm_message_recv(fd1);\n    assert_null(msg);\n    close(fd1);\n\n    fd1 = cm_connect_to_server(1);\n\n    /* try a message with NULL request  */\n    msg = calloc(1, sizeof(*msg));\n    assert_non_null(msg);\n    sr__msg__init(msg);\n    msg->type = SR__MSG__MSG_TYPE__REQUEST;\n    /* send the message */\n    cm_msg_pack_to_buff(msg, &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd1);\n    /* disconnect expected */\n    assert_null(msg);\n    close(fd1);\n\n    fd1 = cm_connect_to_server(1);\n\n    /* try a message with bad session id */\n    cm_session_stop_generate(999, &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd1);\n    /* disconnect expected */\n    assert_null(msg);\n    close(fd1);\n\n    fd1 = cm_connect_to_server(1);\n\n    /* try a session_start request with non-existing username */\n    cm_session_start_generate(\"non-existing-username\", &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd1);\n    assert_non_null(msg);\n    assert_non_null(msg->response);\n    assert_non_null(msg->response->session_start_resp);\n    /* expect invalid user error */\n    assert_int_equal(msg->response->result, SR_ERR_INVAL_USER);\n    sr__msg__free_unpacked(msg, NULL);\n    close(fd1);\n\n    fd1 = cm_connect_to_server(1);\n    fd2 = cm_connect_to_server(1);\n\n    /* try to stop session via another connection */\n    /* session_start request */\n    cm_session_start_generate(\"nobody\", &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd1);\n    assert_non_null(msg);\n    assert_non_null(msg->response);\n    assert_non_null(msg->response->session_start_resp);\n    session_id1 = msg->response->session_start_resp->session_id;\n    sr__msg__free_unpacked(msg, NULL);\n    /* stop via another connection */\n    cm_session_stop_generate(session_id1, &msg_buf, &msg_size);\n    cm_message_send(fd2, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd2);\n    /* disconnect expected */\n    assert_null(msg);\n    close(fd2);\n\n    fd2 = cm_connect_to_server(1);\n\n    /* try sending a response */\n    /* session_start request */\n    cm_session_start_generate(\"nobody\", &msg_buf, &msg_size);\n    cm_message_send(fd2, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd2);\n    assert_non_null(msg);\n    assert_non_null(msg->response);\n    assert_non_null(msg->response->session_start_resp);\n    session_id2 = msg->response->session_start_resp->session_id;\n    sr__msg__free_unpacked(msg, NULL);\n    /* send BAD response */\n    sr_gpb_resp_alloc(NULL, SR__OPERATION__SESSION_STOP, session_id2, &msg);\n    cm_msg_pack_to_buff(msg, &msg_buf, &msg_size);\n    cm_message_send(fd2, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd2);\n    /* disconnect expected */\n    assert_null(msg);\n    close(fd2);\n\n    /* try to stop another session id */\n    sr_gpb_req_alloc(NULL, SR__OPERATION__SESSION_STOP, session_id1, &msg);\n    assert_non_null(msg);\n    assert_non_null(msg->request);\n    assert_non_null(msg->request->session_stop_req);\n    msg->request->session_stop_req->session_id = 0; /* should be invalid */\n    cm_msg_pack_to_buff(msg, &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response - error is expected */\n    msg = cm_message_recv(fd1);\n    assert_non_null(msg);\n    assert_non_null(msg->response);\n    assert_int_not_equal(msg->response->result, SR_ERR_OK);\n    assert_non_null(sr_strerror(msg->response->result));\n    assert_non_null(msg->response->error);\n    assert_non_null(msg->response->error->message);\n    sr__msg__free_unpacked(msg, NULL);\n\n    /* try sending a message with invalid type */\n    sr_gpb_resp_alloc(NULL, SR__OPERATION__SESSION_STOP, session_id1, &msg);\n    msg->type = 53;\n    cm_msg_pack_to_buff(msg, &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd1);\n    /* disconnect expected */\n    assert_null(msg);\n    close(fd1);\n\n    fd2 = cm_connect_to_server(1);\n\n    /* try not closing a connection with an open session (auto cleanup) */\n    /* session_start request */\n    cm_session_start_generate(NULL, &msg_buf, &msg_size);\n    cm_message_send(fd2, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd2);\n    assert_non_null(msg);\n    assert_non_null(msg->response);\n    assert_non_null(msg->response->session_start_resp);\n    session_id2 = msg->response->session_start_resp->session_id;\n    sr__msg__free_unpacked(msg, NULL);\n\n    cm_teardown(state);\n    close(fd2);\n}", "item_id": 11, "repo": "dchechel/sysrepo", "file": "tests/cm_test.c", "last_update_at": "2021-12-20T10:08:54+00:00", "question_id": "1150f92a15ed6b941499c95f9cae15b7315beb99_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\ncm_session_neg_test(void **state) {\n    Sr__Msg *msg = NULL;\n    uint8_t *msg_buf = NULL;\n    size_t msg_size = 0;\n    int fd1 = 0, fd2 = 0;\n    uint32_t session_id1 = 0, session_id2 = 0;\n    fd1 = cm_connect_to_server(0);\n    /* try invalid version  */\n    cm_version_verify_generate(\"invalid\", &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    msg = cm_message_recv(fd1);\n    assert_non_null(msg);\n    assert_int_equal(msg->type, SR__MSG__MSG_TYPE__RESPONSE);\n    assert_non_null(msg->response);\n    assert_int_equal(msg->response->result, SR_ERR_VERSION_MISMATCH);\n    assert_int_equal(msg->response->operation, SR__OPERATION__VERSION_VERIFY);\n    assert_non_null(msg->response->version_verify_resp);\n    assert_string_equal_bt(msg->response->version_verify_resp->soname, SR_COMPAT_VERSION);\n    sr__msg__free_unpacked(msg, NULL);\n    /* disconnect expected */\n    msg = cm_message_recv(fd1);\n    assert_null(msg);\n    close(fd1);\n    fd1 = cm_connect_to_server(1);\n    /* try a message with NULL request  */\n    msg = calloc(1, sizeof(*msg));\n    assert_non_null(msg);\n    sr__msg__init(msg);\n    msg->type = SR__MSG__MSG_TYPE__REQUEST;\n    /* send the message */\n    cm_msg_pack_to_buff(msg, &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd1);\n    /* disconnect expected */\n    assert_null(msg);\n    close(fd1);\n    fd1 = cm_connect_to_server(1);\n    /* try a message with bad session id */\n    cm_session_stop_generate(999, &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd1);\n    /* disconnect expected */\n    assert_null(msg);\n    close(fd1);\n    fd1 = cm_connect_to_server(1);\n    /* try a session_start request with non-existing username */\n    cm_session_start_generate(\"non-existing-username\", &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd1);\n    assert_non_null(msg);\n    assert_non_null(msg->response);\n    assert_non_null(msg->response->session_start_resp);\n    /* expect invalid user error */\n    assert_int_equal(msg->response->result, SR_ERR_INVAL_USER);\n    sr__msg__free_unpacked(msg, NULL);\n    close(fd1);\n    fd1 = cm_connect_to_server(1);\n    fd2 = cm_connect_to_server(1);\n    /* try to stop session via another connection */\n    /* session_start request */\n    cm_session_start_generate(\"nobody\", &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd1);\n    assert_non_null(msg);\n    assert_non_null(msg->response);\n    assert_non_null(msg->response->session_start_resp);\n    session_id1 = msg->response->session_start_resp->session_id;\n    sr__msg__free_unpacked(msg, NULL);\n    /* stop via another connection */\n    cm_session_stop_generate(session_id1, &msg_buf, &msg_size);\n    cm_message_send(fd2, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd2);\n    /* disconnect expected */\n    assert_null(msg);\n    close(fd2);\n    fd2 = cm_connect_to_server(1);\n    /* try sending a response */\n    /* session_start request */\n    cm_session_start_generate(\"nobody\", &msg_buf, &msg_size);\n    cm_message_send(fd2, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd2);\n    assert_non_null(msg);\n    assert_non_null(msg->response);\n    assert_non_null(msg->response->session_start_resp);\n    session_id2 = msg->response->session_start_resp->session_id;\n    sr__msg__free_unpacked(msg, NULL);\n    /* send BAD response */\n    sr_gpb_resp_alloc(NULL, SR__OPERATION__SESSION_STOP, session_id2, &msg);\n    cm_msg_pack_to_buff(msg, &msg_buf, &msg_size);\n    cm_message_send(fd2, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd2);\n    /* disconnect expected */\n    assert_null(msg);\n    close(fd2);\n    /* try to stop another session id */\n    sr_gpb_req_alloc(NULL, SR__OPERATION__SESSION_STOP, session_id1, &msg);\n    assert_non_null(msg);\n    assert_non_null(msg->request);\n    assert_non_null(msg->request->session_stop_req);\n    msg->request->session_stop_req->session_id = 0; /* should be invalid */\n    cm_msg_pack_to_buff(msg, &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response - error is expected */\n    msg = cm_message_recv(fd1);\n    assert_non_null(msg);\n    assert_non_null(msg->response);\n    assert_int_not_equal(msg->response->result, SR_ERR_OK);\n    assert_non_null(sr_strerror(msg->response->result));\n    assert_non_null(msg->response->error);\n    assert_non_null(msg->response->error->message);\n    sr__msg__free_unpacked(msg, NULL);\n    /* try sending a message with invalid type */\n    sr_gpb_resp_alloc(NULL, SR__OPERATION__SESSION_STOP, session_id1, &msg);\n    msg->type = 53;\n    cm_msg_pack_to_buff(msg, &msg_buf, &msg_size);\n    cm_message_send(fd1, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd1);\n    /* disconnect expected */\n    assert_null(msg);\n    close(fd1);\n    fd2 = cm_connect_to_server(1);\n    /* try not closing a connection with an open session (auto cleanup) */\n    /* session_start request */\n    cm_session_start_generate(NULL, &msg_buf, &msg_size);\n    cm_message_send(fd2, msg_buf, msg_size);\n    free(msg_buf);\n    /* receive the response */\n    msg = cm_message_recv(fd2);\n    assert_non_null(msg);\n    assert_non_null(msg->response);\n    assert_non_null(msg->response->session_start_resp);\n    session_id2 = msg->response->session_start_resp->session_id;\n    sr__msg__free_unpacked(msg, NULL);\n    cm_teardown(state);\n    close(fd2);\n"]]}
{"hexsha": "2eb030d8336b1b0892517afcd47a821f68997a5e", "ext": "c", "lang": "C", "content": "static inline void rv40_weak_loop_filter(uint8_t *src, const int step,\n                                         const int filter_p1, const int filter_q1,\n                                         const int alpha, const int beta,\n                                         const int lim_p0q0,\n                                         const int lim_q1, const int lim_p1,\n                                         const int diff_p1p0, const int diff_q1q0,\n                                         const int diff_p1p2, const int diff_q1q2)\n{\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n    int t, u, diff;\n\n    t = src[0*step] - src[-1*step];\n    if(!t)\n        return;\n    u = (alpha * FFABS(t)) >> 7;\n    if(u > 3 - (filter_p1 && filter_q1))\n        return;\n\n    t <<= 2;\n    if(filter_p1 && filter_q1)\n        t += src[-2*step] - src[1*step];\n    diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0);\n    src[-1*step] = cm[src[-1*step] + diff];\n    src[ 0*step] = cm[src[ 0*step] - diff];\n    if(FFABS(diff_p1p2) <= beta && filter_p1){\n        t = (diff_p1p0 + diff_p1p2 - diff) >> 1;\n        src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)];\n    }\n    if(FFABS(diff_q1q2) <= beta && filter_q1){\n        t = (diff_q1q0 + diff_q1q2 + diff) >> 1;\n        src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)];\n    }\n}", "item_id": 5, "repo": "MacgyverLin/MagnumEngine", "file": "EpicForceEngine/MagnumEngineLib/SDK/testffmpeg/jni/ffmpeg/libavcodec/rv40.c", "last_update_at": "2021-03-30T06:28:32+00:00", "question_id": "2eb030d8336b1b0892517afcd47a821f68997a5e_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void rv40_weak_loop_filter(uint8_t *src, const int step,\n                                         const int filter_p1, const int filter_q1,\n                                         const int alpha, const int beta,\n                                         const int lim_p0q0,\n                                         const int lim_q1, const int lim_p1,\n                                         const int diff_p1p0, const int diff_q1q0,\n                                         const int diff_p1p2, const int diff_q1q2)\n{\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n    int t, u, diff;\n    t = src[0*step] - src[-1*step];\n    if(!t)\n        return;\n    u = (alpha * FFABS(t)) >> 7;\n    if(u > 3 - (filter_p1 && filter_q1))\n        return;\n    t <<= 2;\n    if(filter_p1 && filter_q1)\n        t += src[-2*step] - src[1*step];\n    diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0);\n    src[-1*step] = cm[src[-1*step] + diff];\n    src[ 0*step] = cm[src[ 0*step] - diff];\n    if(FFABS(diff_p1p2) <= beta && filter_p1){\n        t = (diff_p1p0 + diff_p1p2 - diff) >> 1;\n        src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)];\n    }\n    if(FFABS(diff_q1q2) <= beta && filter_q1){\n        t = (diff_q1q0 + diff_q1q2 + diff) >> 1;\n        src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)];\n    }\n"]]}
{"hexsha": "e1e4fefdc4c7aa59b452aa31c64b3b1dc2a02c69", "ext": "c", "lang": "C", "content": "static int\nglobus_l_gass_cache_linktest(globus_i_gass_cache_t  *cache)\n{\n    char         dir[PATH_MAX];\n    char         file[PATH_MAX];\n    char         link1[PATH_MAX];\n    char         link2[PATH_MAX];\n    int          fd;\n    int          rc;\n    struct stat  stx;\n    globus_thread_t t = globus_thread_self();\n\n    rc = DIRECTORY_TYPE_NOLINK;\n\n    sprintf(dir, \"%s/dir-%ld-%ld\",\n                        cache->cache_directory_path,\n                        (long) globus_libc_getpid(),\n                        (long) t.dummy );\n    \n    sprintf(file, \"%s/file\", dir );\n    sprintf(link1, \"%s/link\", dir );\n\n    sprintf(link2, \"%s/link-%ld-%ld\",\n            cache->cache_directory_path,\n            (long) globus_libc_getpid(),\n            (long) t.dummy );\n\n    /* create test dir and file */\n    rmdir(dir);\n    if (mkdir( dir, GLOBUS_L_GASS_CACHE_DIR_MODE ))\n       goto cleanup;\n\n    fd = open(file, O_RDWR|O_CREAT|O_TRUNC, GLOBUS_L_GASS_CACHE_MODE_RW);\n    if (fd < 0)\n       goto cleanup;\n\n    close(fd);\n\n    /* verify n_link returns correct value */\n    stx.st_nlink = 0;\n    if (stat(file, &stx) || (stx.st_nlink != 1))\n        goto cleanup;\n\n    /* test (a): link in same directory */\n    stx.st_nlink = 0;\n    if (link(file,link1) || stat(file,&stx) || stx.st_nlink!=2)\n        goto cleanup;\n\n    rc = DIRECTORY_TYPE_FLAT;\n\n    /* test (b): link from another directory */\n    stx.st_nlink = 0;\n    if (link(file,link2) || stat(file,&stx) || stx.st_nlink!=3)\n        goto cleanup;\n\n    rc = DIRECTORY_TYPE_NORMAL;\n    \n cleanup:\n    remove(link1);\n    remove(link2);\n    remove(file);\n    rmdir(dir);\n\n    return rc;\n}", "item_id": 4, "repo": "ezeeyahoo/gct", "file": "gass/cache/source/globus_gass_cache.c", "last_update_at": "2021-01-27T21:18:47+00:00", "question_id": "e1e4fefdc4c7aa59b452aa31c64b3b1dc2a02c69_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\nglobus_l_gass_cache_linktest(globus_i_gass_cache_t  *cache)\n{\n    char         dir[PATH_MAX];\n    char         file[PATH_MAX];\n    char         link1[PATH_MAX];\n    char         link2[PATH_MAX];\n    int          fd;\n    int          rc;\n    struct stat  stx;\n    globus_thread_t t = globus_thread_self();\n    rc = DIRECTORY_TYPE_NOLINK;\n    sprintf(dir, \"%s/dir-%ld-%ld\",\n                        cache->cache_directory_path,\n                        (long) globus_libc_getpid(),\n                        (long) t.dummy );\n    sprintf(file, \"%s/file\", dir );\n    sprintf(link1, \"%s/link\", dir );\n    sprintf(link2, \"%s/link-%ld-%ld\",\n            cache->cache_directory_path,\n            (long) globus_libc_getpid(),\n            (long) t.dummy );\n    /* create test dir and file */\n    rmdir(dir);\n    if (mkdir( dir, GLOBUS_L_GASS_CACHE_DIR_MODE ))\n       goto cleanup;\n    fd = open(file, O_RDWR|O_CREAT|O_TRUNC, GLOBUS_L_GASS_CACHE_MODE_RW);\n    if (fd < 0)\n       goto cleanup;\n    close(fd);\n    /* verify n_link returns correct value */\n    stx.st_nlink = 0;\n    if (stat(file, &stx) || (stx.st_nlink != 1))\n        goto cleanup;\n    /* test (a): link in same directory */\n    stx.st_nlink = 0;\n    if (link(file,link1) || stat(file,&stx) || stx.st_nlink!=2)\n        goto cleanup;\n    rc = DIRECTORY_TYPE_FLAT;\n    /* test (b): link from another directory */\n    stx.st_nlink = 0;\n    if (link(file,link2) || stat(file,&stx) || stx.st_nlink!=3)\n        goto cleanup;\n    rc = DIRECTORY_TYPE_NORMAL;\n cleanup:\n    remove(link1);\n    remove(link2);\n    remove(file);\n    rmdir(dir);\n    return rc;\n"]]}
{"hexsha": "ceb9e796ef6127bcf2e99f16ea67bcc884aa01db", "ext": "c", "lang": "C", "content": "int main (int argc, char *argv[])\n{\n    int  i;\n    void sig_handler ();\n    void (*istat) ();\n\n    argv0 = \"dali\";\n    DisplayName = NULL;\n    geometry = NULL;\n\n    for (i = 1; i < argc; ++i) {\n\tif (argv[i][0] == '-') {\n\t    switch (argv[i][1]) {\n\t\tcase 'f':\n\t\t    fmode = 1;\t/* read dali_drc from CWD */\n\t\t    break;\n\t\tcase 'o':\n\t\t    omode = 1;\t/* animate output mode */\n\t\t    break;\n\t\tcase 'r':\n\t\t    rmode = 1;\t/* read only mode */\n\t\t    break;\n\t\tcase 'A':\n\t\t    d_apollo = 1;/* Apollo mode */\n\t\t    break;\n\t\tcase 'C':\n\t\t    colormap = 0;/* don't use Colormap */\n\t\t    break;\n\t\tcase 'h':\n\t\t    DisplayName = argv[++i];\n\t\t    if (!DisplayName) usage ();\n\t\t    break;\n\t\tdefault:\n\t\t    usage ();\n\t    }\n\t}\n\telse {\n\t    if (argv[i][0] == '=') {\n\t\tgeometry = argv[i];\n\t    }\n\t    else {\n\t\tInput_cell_name = argv[i];\n\t    }\n\t}\n    }\n\n    if (Input_cell_name) {\n\tif (strlen (Input_cell_name) > DM_MAXNAME) {\n\t    PE \"input name '%s' is too long\\n\", Input_cell_name);\n\t    usage ();\n\t}\n    }\n\n    get_gterm ();\n\n    signal (SIGHUP, SIG_IGN);\n    signal (SIGINT, SIG_IGN);\n    istat = signal (SIGQUIT, SIG_IGN);\n    signal (SIGTERM, sig_handler);\n\n    if (dmInit (argv0)) exit (1);\n\n    dmproject = dmOpenProject (DEFAULT_PROJECT, rmode ? PROJ_READ : (PROJ_READ | PROJ_WRITE));\n\n    if (!dmproject) stop_show (1);\n    if (!dmGetMetaDesignData (PROCESS, dmproject)\n        || dmproject -> maskdata == NULL\n        || dmproject -> maskdata -> nomasks == 0) stop_show (1);\n\n    if (!rmode) {\n\tchar old_path[MAXCHAR], new_path[MAXCHAR];\n\tsprintf (old_path, \"%s/.dmrc\", dmproject -> dmpath);\n\tsprintf (new_path, \"%s/.dmrc%d\", dmproject -> dmpath, (int)getpid ());\n\tif (link (old_path, new_path) == -1) {\n\t    PE \"%s: no write permission: read only mode!\\n\", argv0);\n\t    rmode = 1;\n\t}\n\tunlink (new_path);\n    }\n\n    graphic_mode = 1;\n\n    open_dalirc ();\n    init_graph ();\n    initwindow ();\n    save_oldw (); /* there is no prev_w */\n    init_txtwdw (\"Starting...\");\n    init_colmenu ();\n    init_mem ();\n\n /* enable interrupt catching, if not ignored */\n    if (istat != SIG_IGN) signal (SIGQUIT, sig_handler);\n    signal (SIGSEGV, sig_handler);\n\n    command ();\t\t\t/* let's work */\n /* function command does not return */\n\n    return (0);\n}", "item_id": 0, "repo": "yrrapt/cacd", "file": "src/dali/main.c", "last_update_at": "2021-09-28T19:46:12+00:00", "question_id": "ceb9e796ef6127bcf2e99f16ea67bcc884aa01db_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main (int argc, char *argv[])\n{\n    int  i;\n    void sig_handler ();\n    void (*istat) ();\n    argv0 = \"dali\";\n    DisplayName = NULL;\n    geometry = NULL;\n    for (i = 1; i < argc; ++i) {\n\tif (argv[i][0] == '-') {\n\t    switch (argv[i][1]) {\n\t\tcase 'f':\n\t\t    fmode = 1;\t/* read dali_drc from CWD */\n\t\t    break;\n\t\tcase 'o':\n\t\t    omode = 1;\t/* animate output mode */\n\t\t    break;\n\t\tcase 'r':\n\t\t    rmode = 1;\t/* read only mode */\n\t\t    break;\n\t\tcase 'A':\n\t\t    d_apollo = 1;/* Apollo mode */\n\t\t    break;\n\t\tcase 'C':\n\t\t    colormap = 0;/* don't use Colormap */\n\t\t    break;\n\t\tcase 'h':\n\t\t    DisplayName = argv[++i];\n\t\t    if (!DisplayName) usage ();\n\t\t    break;\n\t\tdefault:\n\t\t    usage ();\n\t    }\n\t}\n\telse {\n\t    if (argv[i][0] == '=') {\n\t\tgeometry = argv[i];\n\t    }\n\t    else {\n\t\tInput_cell_name = argv[i];\n\t    }\n\t}\n    }\n    if (Input_cell_name) {\n\tif (strlen (Input_cell_name) > DM_MAXNAME) {\n\t    PE \"input name '%s' is too long\\n\", Input_cell_name);\n\t    usage ();\n\t}\n    }\n    get_gterm ();\n    signal (SIGHUP, SIG_IGN);\n    signal (SIGINT, SIG_IGN);\n    istat = signal (SIGQUIT, SIG_IGN);\n    signal (SIGTERM, sig_handler);\n    if (dmInit (argv0)) exit (1);\n    dmproject = dmOpenProject (DEFAULT_PROJECT, rmode ? PROJ_READ : (PROJ_READ | PROJ_WRITE));\n    if (!dmproject) stop_show (1);\n    if (!dmGetMetaDesignData (PROCESS, dmproject)\n        || dmproject -> maskdata == NULL\n        || dmproject -> maskdata -> nomasks == 0) stop_show (1);\n    if (!rmode) {\n\tchar old_path[MAXCHAR], new_path[MAXCHAR];\n\tsprintf (old_path, \"%s/.dmrc\", dmproject -> dmpath);\n\tsprintf (new_path, \"%s/.dmrc%d\", dmproject -> dmpath, (int)getpid ());\n\tif (link (old_path, new_path) == -1) {\n\t    PE \"%s: no write permission: read only mode!\\n\", argv0);\n\t    rmode = 1;\n\t}\n\tunlink (new_path);\n    }\n    graphic_mode = 1;\n    open_dalirc ();\n    init_graph ();\n    initwindow ();\n    save_oldw (); /* there is no prev_w */\n    init_txtwdw (\"Starting...\");\n    init_colmenu ();\n    init_mem ();\n /* enable interrupt catching, if not ignored */\n    if (istat != SIG_IGN) signal (SIGQUIT, sig_handler);\n    signal (SIGSEGV, sig_handler);\n    command ();\t\t\t/* let's work */\n /* function command does not return */\n    return (0);\n"]]}
{"hexsha": "9e0c90da99d3036de4a4b866aaaca11f0ad99fc5", "ext": "c", "lang": "C", "content": "static inline void htt_print_tx_tid_stats_v1_tlv(const void *tag_buf,\n\t\t\t\t\t\t struct debug_htt_stats_req *stats_req)\n{\n\tconst struct htt_tx_tid_stats_v1_tlv *htt_stats_buf = tag_buf;\n\tu8 *buf = stats_req->buf;\n\tu32 len = stats_req->buf_len;\n\tu32 buf_len = ATH11K_HTT_STATS_BUF_SIZE;\n\tchar tid_name[MAX_HTT_TID_NAME + 1] = {0};\n\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"HTT_TX_TID_STATS_V1_TLV:\");\n\tmemcpy(tid_name, &(htt_stats_buf->tid_name[0]), MAX_HTT_TID_NAME);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"tid_name = %s \", tid_name);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"sw_peer_id = %u\",\n\t\t\t   htt_stats_buf->sw_peer_id__tid_num & 0xFFFF);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"tid_num = %u\",\n\t\t\t   (htt_stats_buf->sw_peer_id__tid_num & 0xFFFF0000) >> 16);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"num_sched_pending = %u\",\n\t\t\t   htt_stats_buf->num_sched_pending__num_ppdu_in_hwq & 0xFF);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"num_ppdu_in_hwq = %u\",\n\t\t\t   (htt_stats_buf->num_sched_pending__num_ppdu_in_hwq &\n\t\t\t   0xFF00) >> 8);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"tid_flags = 0x%x\",\n\t\t\t   htt_stats_buf->tid_flags);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"max_qdepth_bytes = %u\",\n\t\t\t   htt_stats_buf->max_qdepth_bytes);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"max_qdepth_n_msdus = %u\",\n\t\t\t   htt_stats_buf->max_qdepth_n_msdus);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"rsvd = %u\",\n\t\t\t   htt_stats_buf->rsvd);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"qdepth_bytes = %u\",\n\t\t\t   htt_stats_buf->qdepth_bytes);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"qdepth_num_msdu = %u\",\n\t\t\t   htt_stats_buf->qdepth_num_msdu);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"qdepth_num_mpdu = %u\",\n\t\t\t   htt_stats_buf->qdepth_num_mpdu);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"last_scheduled_tsmp = %u\",\n\t\t\t   htt_stats_buf->last_scheduled_tsmp);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"pause_module_id = %u\",\n\t\t\t   htt_stats_buf->pause_module_id);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"block_module_id = %u\",\n\t\t\t   htt_stats_buf->block_module_id);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"allow_n_flags = 0x%x\",\n\t\t\t   htt_stats_buf->allow_n_flags);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"sendn_frms_allowed = %u\\n\",\n\t\t\t   htt_stats_buf->sendn_frms_allowed);\n\n\tif (len >= buf_len)\n\t\tbuf[buf_len - 1] = 0;\n\telse\n\t\tbuf[len] = 0;\n\n\tstats_req->buf_len = len;\n}", "item_id": 14, "repo": "SunOS-Linux/kernel", "file": "drivers/net/wireless/ath/ath11k/debugfs_htt_stats.c", "last_update_at": "2021-01-27T01:29:47+00:00", "question_id": "9e0c90da99d3036de4a4b866aaaca11f0ad99fc5_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void htt_print_tx_tid_stats_v1_tlv(const void *tag_buf,\n\t\t\t\t\t\t struct debug_htt_stats_req *stats_req)\n{\n\tconst struct htt_tx_tid_stats_v1_tlv *htt_stats_buf = tag_buf;\n\tu8 *buf = stats_req->buf;\n\tu32 len = stats_req->buf_len;\n\tu32 buf_len = ATH11K_HTT_STATS_BUF_SIZE;\n\tchar tid_name[MAX_HTT_TID_NAME + 1] = {0};\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"HTT_TX_TID_STATS_V1_TLV:\");\n\tmemcpy(tid_name, &(htt_stats_buf->tid_name[0]), MAX_HTT_TID_NAME);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"tid_name = %s \", tid_name);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"sw_peer_id = %u\",\n\t\t\t   htt_stats_buf->sw_peer_id__tid_num & 0xFFFF);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"tid_num = %u\",\n\t\t\t   (htt_stats_buf->sw_peer_id__tid_num & 0xFFFF0000) >> 16);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"num_sched_pending = %u\",\n\t\t\t   htt_stats_buf->num_sched_pending__num_ppdu_in_hwq & 0xFF);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"num_ppdu_in_hwq = %u\",\n\t\t\t   (htt_stats_buf->num_sched_pending__num_ppdu_in_hwq &\n\t\t\t   0xFF00) >> 8);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"tid_flags = 0x%x\",\n\t\t\t   htt_stats_buf->tid_flags);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"max_qdepth_bytes = %u\",\n\t\t\t   htt_stats_buf->max_qdepth_bytes);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"max_qdepth_n_msdus = %u\",\n\t\t\t   htt_stats_buf->max_qdepth_n_msdus);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"rsvd = %u\",\n\t\t\t   htt_stats_buf->rsvd);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"qdepth_bytes = %u\",\n\t\t\t   htt_stats_buf->qdepth_bytes);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"qdepth_num_msdu = %u\",\n\t\t\t   htt_stats_buf->qdepth_num_msdu);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"qdepth_num_mpdu = %u\",\n\t\t\t   htt_stats_buf->qdepth_num_mpdu);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"last_scheduled_tsmp = %u\",\n\t\t\t   htt_stats_buf->last_scheduled_tsmp);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"pause_module_id = %u\",\n\t\t\t   htt_stats_buf->pause_module_id);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"block_module_id = %u\",\n\t\t\t   htt_stats_buf->block_module_id);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"allow_n_flags = 0x%x\",\n\t\t\t   htt_stats_buf->allow_n_flags);\n\tlen += HTT_DBG_OUT(buf + len, buf_len - len, \"sendn_frms_allowed = %u\\n\",\n\t\t\t   htt_stats_buf->sendn_frms_allowed);\n\tif (len >= buf_len)\n\t\tbuf[buf_len - 1] = 0;\n\telse\n\t\tbuf[len] = 0;\n\tstats_req->buf_len = len;\n"]]}
{"hexsha": "f5115da34d03b0bdff89113c9a4ce5a24528b7b8", "ext": "c", "lang": "C", "content": "void knapsack(item_t list[], int n, int w){\n    int maxCost[BPackSIZE + 1] = {0};\n    for(int i = 0; i < n; i++){\n        int weight = list[i].weight;\n        int cost = list[i].value;\n        for(int j = w; j - weight >= 0; --j)\n            if(maxCost[j] < maxCost[j - weight] + cost)maxCost[j] = maxCost[j - weight] + cost;\n    }\n    printf(\"%d\\n\", maxCost[BPackSIZE]);\n}", "item_id": 0, "repo": "doyansu/zerojugde", "file": "C/b184(backpack problem - Knapsack).c", "last_update_at": "2021-09-17T00:24:40+00:00", "question_id": "f5115da34d03b0bdff89113c9a4ce5a24528b7b8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void knapsack(item_t list[], int n, int w){\n    int maxCost[BPackSIZE + 1] = {0};\n    for(int i = 0; i < n; i++){\n        int weight = list[i].weight;\n        int cost = list[i].value;\n        for(int j = w; j - weight >= 0; --j)\n            if(maxCost[j] < maxCost[j - weight] + cost)maxCost[j] = maxCost[j - weight] + cost;\n    }\n    printf(\"%d\\n\", maxCost[BPackSIZE]);\n"]]}
{"hexsha": "bc9d0eda795251ad05e3734e3fcd0d720df0ccc9", "ext": "c", "lang": "C", "content": "static void MX_USART1_UART_Init(void)\n{\n    huart1.Instance = USART1;\n    huart1.Init.BaudRate = 115200;\n    huart1.Init.WordLength = UART_WORDLENGTH_8B;\n    huart1.Init.StopBits = UART_STOPBITS_1;\n    huart1.Init.Parity = UART_PARITY_NONE;\n    huart1.Init.Mode = UART_MODE_TX_RX;\n    huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;\n    huart1.Init.OverSampling = UART_OVERSAMPLING_16;\n    huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;\n    huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT|UART_ADVFEATURE_DMADISABLEONERROR_INIT;\n    huart1.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;\n    huart1.AdvancedInit.DMADisableonRxError = UART_ADVFEATURE_DMA_DISABLEONRXERROR;\n\n    if (HAL_UART_Init(&huart1) != HAL_OK) {\n        Error_Handler();\n    }\n}", "item_id": 3, "repo": "nug-/amk", "file": "main/porting/stm32/stm32l072xx.c", "last_update_at": "2021-06-22T07:18:37+00:00", "question_id": "bc9d0eda795251ad05e3734e3fcd0d720df0ccc9_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void MX_USART1_UART_Init(void)\n{\n    huart1.Instance = USART1;\n    huart1.Init.BaudRate = 115200;\n    huart1.Init.WordLength = UART_WORDLENGTH_8B;\n    huart1.Init.StopBits = UART_STOPBITS_1;\n    huart1.Init.Parity = UART_PARITY_NONE;\n    huart1.Init.Mode = UART_MODE_TX_RX;\n    huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;\n    huart1.Init.OverSampling = UART_OVERSAMPLING_16;\n    huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;\n    huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT|UART_ADVFEATURE_DMADISABLEONERROR_INIT;\n    huart1.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;\n    huart1.AdvancedInit.DMADisableonRxError = UART_ADVFEATURE_DMA_DISABLEONRXERROR;\n    if (HAL_UART_Init(&huart1) != HAL_OK) {\n        Error_Handler();\n    }\n"]]}
{"hexsha": "2a69400be793d0838b4a2ea75ead42cd7b700900", "ext": "c", "lang": "C", "content": "void f51(void) {\n    \tuint16_t x265 = 0U;\n\tvolatile uint64_t x266 = 1062LLU;\n\tint64_t x267 = INT64_MIN;\n\tint64_t x268 = INT64_MIN;\n\tuint64_t t51 = 56770405LLU;\n\n    t51 = (x265|((x266&x267)*x268));\n\n    if (t51 != 0LLU) { NG(); } else { ; }\n\t\n}", "item_id": 51, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test2197.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "2a69400be793d0838b4a2ea75ead42cd7b700900_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f51(void) {\n    \tuint16_t x265 = 0U;\n\tvolatile uint64_t x266 = 1062LLU;\n\tint64_t x267 = INT64_MIN;\n\tint64_t x268 = INT64_MIN;\n\tuint64_t t51 = 56770405LLU;\n    t51 = (x265|((x266&x267)*x268));\n    if (t51 != 0LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "3b9bb93001bde927df464b4624379ef6a52c9d6e", "ext": "h", "lang": "C", "content": "NTSTRSAFEWORKERDDI\n    RtlStringExValidateDestA(\n            _In_reads_opt_(cchDest) STRSAFE_PCNZCH pszDest,\n            _In_ size_t cchDest,\n            _In_ const size_t cchMax,\n            _In_ DWORD dwFlags)\n{\n    NTSTATUS status = STATUS_SUCCESS;\n\n    if (dwFlags & STRSAFE_IGNORE_NULLS)\n    {\n        if (((pszDest == NULL) && (cchDest != 0))   ||\n                (cchDest > cchMax))\n        {\n            status = STATUS_INVALID_PARAMETER;\n        }\n    }\n    else\n    {\n        status = RtlStringValidateDestA(pszDest, cchDest, cchMax);\n    }\n\n    return status;\n}", "item_id": 89, "repo": "sezero/windows-sdk-headers", "file": "Include/10.0.19041.0/km/ntstrsafe.h", "last_update_at": "2021-11-28T08:21:38+00:00", "question_id": "3b9bb93001bde927df464b4624379ef6a52c9d6e_89", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["NTSTRSAFEWORKERDDI\n    RtlStringExValidateDestA(\n            _In_reads_opt_(cchDest) STRSAFE_PCNZCH pszDest,\n            _In_ size_t cchDest,\n            _In_ const size_t cchMax,\n            _In_ DWORD dwFlags)\n{\n    NTSTATUS status = STATUS_SUCCESS;\n    if (dwFlags & STRSAFE_IGNORE_NULLS)\n    {\n        if (((pszDest == NULL) && (cchDest != 0))   ||\n                (cchDest > cchMax))\n        {\n            status = STATUS_INVALID_PARAMETER;\n        }\n    }\n    else\n    {\n        status = RtlStringValidateDestA(pszDest, cchDest, cchMax);\n    }\n    return status;\n"]]}
{"hexsha": "63f36ed39e33e08503e1810e61c42129bf517b6b", "ext": "c", "lang": "C", "content": "static int mhi_arch_set_bus_request(struct mhi_controller *mhi_cntrl, int index)\n{\n\tstruct mhi_dev *mhi_dev = mhi_controller_get_devdata(mhi_cntrl);\n\tstruct arch_info *arch_info = mhi_dev->arch_info;\n\n\tMHI_LOG(\"Setting bus request to index %d\\n\", index);\n\n\tif (arch_info->bus_client)\n\t\treturn msm_bus_scale_client_update_request(\n\t\t\t\t\t\t\tarch_info->bus_client,\n\t\t\t\t\t\t\tindex);\n\n\t/* default return success */\n\treturn 0;\n}", "item_id": 2, "repo": "clovadevice/clockplus", "file": "kernel/msm-4.14_1/drivers/bus/mhi/controllers/mhi_arch_qcom.c", "last_update_at": "2021-06-29T01:29:23+00:00", "question_id": "63f36ed39e33e08503e1810e61c42129bf517b6b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int mhi_arch_set_bus_request(struct mhi_controller *mhi_cntrl, int index)\n{\n\tstruct mhi_dev *mhi_dev = mhi_controller_get_devdata(mhi_cntrl);\n\tstruct arch_info *arch_info = mhi_dev->arch_info;\n\tMHI_LOG(\"Setting bus request to index %d\\n\", index);\n\tif (arch_info->bus_client)\n\t\treturn msm_bus_scale_client_update_request(\n\t\t\t\t\t\t\tarch_info->bus_client,\n\t\t\t\t\t\t\tindex);\n\t/* default return success */\n\treturn 0;\n"]]}
{"hexsha": "9b021edbeb9054f5dc5c00ece4759f2599ec6942", "ext": "c", "lang": "C", "content": "ACMD(do_mecho) {\n\tchar *p;\n\n\tif (!MOB_OR_IMPL(ch)) {\n\t\tsend_config_msg(ch, \"huh_string\");\n\t\treturn;\n\t}\n\n\tif (AFF_FLAGGED(ch, AFF_ORDERED))\n\t\treturn;\n\n\tif (!*argument) {\n\t\tmob_log(ch, \"mecho called with no arguments\");\n\t\treturn;\n\t}\n\tp = argument;\n\tskip_spaces(&p);\n\n\tsub_write(p, ch, TRUE, TO_ROOM);\n}", "item_id": 10, "repo": "EmpireMUD/EmpireMUD-2.0-Beta", "file": "src/dg_mobcmd.c", "last_update_at": "2021-12-29T16:24:34+00:00", "question_id": "9b021edbeb9054f5dc5c00ece4759f2599ec6942_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["ACMD(do_mecho) {\n\tchar *p;\n\tif (!MOB_OR_IMPL(ch)) {\n\t\tsend_config_msg(ch, \"huh_string\");\n\t\treturn;\n\t}\n\tif (AFF_FLAGGED(ch, AFF_ORDERED))\n\t\treturn;\n\tif (!*argument) {\n\t\tmob_log(ch, \"mecho called with no arguments\");\n\t\treturn;\n\t}\n\tp = argument;\n\tskip_spaces(&p);\n\tsub_write(p, ch, TRUE, TO_ROOM);\n"]]}
{"hexsha": "ac4d51d5a9ea7d98040b47296fca49126879173d", "ext": "h", "lang": "C", "content": "vec4 add_vec4(vec4 vector, vec4 vector_)\n{\n\tvector.x += vector_.x;\n\tvector.y += vector_.y;\n\tvector.z += vector_.z;\n\tvector.w += vector_.w;\n\treturn vector;\n}", "item_id": 2, "repo": "nem64/Particle-Simulation", "file": "vector-math-old/vector-math/vec4.h", "last_update_at": "2021-09-18T23:56:58+00:00", "question_id": "ac4d51d5a9ea7d98040b47296fca49126879173d_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["vec4 add_vec4(vec4 vector, vec4 vector_)\n{\n\tvector.x += vector_.x;\n\tvector.y += vector_.y;\n\tvector.z += vector_.z;\n\tvector.w += vector_.w;\n\treturn vector;\n"]]}
{"hexsha": "c5f04497aaced232a18bd02f1b9628eefa3eb069", "ext": "c", "lang": "C", "content": "void create(){\n\t::create();\n\tset_name(\"Sturdy Boots\");\n\tset_id(({ \"boots\", \"leather boots\", \"sturdy leather boots\", \"sturdy boots\" }));\n\tset_short(\"%^RESET%^%^ORANGE%^Mi%^BOLD%^%^BLACK%^n%^RESET%^%^ORANGE%^er's Foo%^BOLD%^%^BLACK%^t%^RESET%^%^ORANGE%^gear%^RESET%^\");\n\tset_obvious_short(\"%^RESET%^%^ORANGE%^Sturdy Leather Boots%^RESET%^\");\n\tset_long(\n@AVATAR\n%^RESET%^%^ORANGE%^This is a pair of sturdy and heavy leather boots.  They seem to be shaped in a squarish manner, and have a thick sole to match.  They appear to be made of a very thick leather which seems rather stiff, but quite protective.  Faint scuffmarks mar the leather in places, but any aging doesn't appear to have damaged the boots severely.%^RESET%^\n\nAVATAR\n\t);\n\tset_weight(10);\n\tset_value(150);\n\tset_type(\"clothing\");\n\tset_limbs(({ \"right foot\", \"left foot\" }));\n\tset_size(1);\n\tset_property(\"enchantment\",1);\n}", "item_id": 0, "repo": "gesslar/shadowgate", "file": "d/avatars/mask/leatherboots.c", "last_update_at": "2021-11-18T04:08:19+00:00", "question_id": "c5f04497aaced232a18bd02f1b9628eefa3eb069_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void create(){\n\t::create();\n\tset_name(\"Sturdy Boots\");\n\tset_id(({ \"boots\", \"leather boots\", \"sturdy leather boots\", \"sturdy boots\" }));\n\tset_short(\"%^RESET%^%^ORANGE%^Mi%^BOLD%^%^BLACK%^n%^RESET%^%^ORANGE%^er's Foo%^BOLD%^%^BLACK%^t%^RESET%^%^ORANGE%^gear%^RESET%^\");\n\tset_obvious_short(\"%^RESET%^%^ORANGE%^Sturdy Leather Boots%^RESET%^\");\n\tset_long(\n@AVATAR\n%^RESET%^%^ORANGE%^This is a pair of sturdy and heavy leather boots.  They seem to be shaped in a squarish manner, and have a thick sole to match.  They appear to be made of a very thick leather which seems rather stiff, but quite protective.  Faint scuffmarks mar the leather in places, but any aging doesn't appear to have damaged the boots severely.%^RESET%^\nAVATAR\n\t);\n\tset_weight(10);\n\tset_value(150);\n\tset_type(\"clothing\");\n\tset_limbs(({ \"right foot\", \"left foot\" }));\n\tset_size(1);\n\tset_property(\"enchantment\",1);\n"]]}
{"hexsha": "ba5f954d126e2b144e5efdd1cfe8ab03befeccd4", "ext": "c", "lang": "C", "content": "void f189(void) {\n    \tint32_t x985 = INT32_MAX;\n\tstatic volatile uint16_t x986 = UINT16_MAX;\n\tuint32_t x987 = 2U;\n\tvolatile uint32_t t189 = 13U;\n\n    t189 = (x985*(x986%(x987-x988)));\n\n    if (t189 != 0U) { NG(); } else { ; }\n\t\n}", "item_id": 189, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test255.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "ba5f954d126e2b144e5efdd1cfe8ab03befeccd4_189", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f189(void) {\n    \tint32_t x985 = INT32_MAX;\n\tstatic volatile uint16_t x986 = UINT16_MAX;\n\tuint32_t x987 = 2U;\n\tvolatile uint32_t t189 = 13U;\n    t189 = (x985*(x986%(x987-x988)));\n    if (t189 != 0U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "f69ba559dcacae05cdc2e510ec11c295eaaac7bc", "ext": "c", "lang": "C", "content": "static Uint32\nAutoHideTimeout(void *obj, Uint32 ival, void *arg)\n{\n\tAG_Scrollbar *sb = obj;\n\tint x, len;\n\n\tif ((GetPxCoords(sb, &x, &len) == -1 ||\n\t    len == sb->length)) {\n\t\tif (AG_WidgetVisible(sb))\n\t\t\tAG_WidgetHide(sb);\n\t} else {\n\t\tif (!AG_WidgetVisible(sb))\n\t\t\tAG_WidgetShow(sb);\n\t}\n\treturn (ival);\n}", "item_id": 28, "repo": "adsr/agar", "file": "gui/scrollbar.c", "last_update_at": "2021-10-05T04:50:03+00:00", "question_id": "f69ba559dcacae05cdc2e510ec11c295eaaac7bc_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static Uint32\nAutoHideTimeout(void *obj, Uint32 ival, void *arg)\n{\n\tAG_Scrollbar *sb = obj;\n\tint x, len;\n\tif ((GetPxCoords(sb, &x, &len) == -1 ||\n\t    len == sb->length)) {\n\t\tif (AG_WidgetVisible(sb))\n\t\t\tAG_WidgetHide(sb);\n\t} else {\n\t\tif (!AG_WidgetVisible(sb))\n\t\t\tAG_WidgetShow(sb);\n\t}\n\treturn (ival);\n"]]}
{"hexsha": "d3854fcc03c85c901cef0586e920f5cebffffbd2", "ext": "c", "lang": "C", "content": "void f147(void) {\n    \tuint64_t x8058 = 33421391037LLU;\n\tuint32_t x8059 = UINT32_MAX;\n\tstatic uint32_t x8060 = UINT32_MAX;\n\tvolatile uint64_t t147 = 172901721823295615LLU;\n\n    t147 = ((x8057-x8058)>>(x8059*x8060));\n\n    if (t147 != 9223372022291563937LLU) { NG(); } else { ; }\n\t\n}", "item_id": 147, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test417.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "d3854fcc03c85c901cef0586e920f5cebffffbd2_147", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f147(void) {\n    \tuint64_t x8058 = 33421391037LLU;\n\tuint32_t x8059 = UINT32_MAX;\n\tstatic uint32_t x8060 = UINT32_MAX;\n\tvolatile uint64_t t147 = 172901721823295615LLU;\n    t147 = ((x8057-x8058)>>(x8059*x8060));\n    if (t147 != 9223372022291563937LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "055708b57380a63daa68eaff1e5bb47159ae1d83", "ext": "c", "lang": "C", "content": "void f125(void) {\n    \tint16_t x501 = INT16_MIN;\n\tvolatile int64_t x502 = -12670LL;\n\tvolatile uint8_t x503 = UINT8_MAX;\n\tint32_t x504 = 62286732;\n\tvolatile int32_t t125 = -1963498;\n\n    t125 = ((x501>x502)==(x503^x504));\n\n    if (t125 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 125, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test2668.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "055708b57380a63daa68eaff1e5bb47159ae1d83_125", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f125(void) {\n    \tint16_t x501 = INT16_MIN;\n\tvolatile int64_t x502 = -12670LL;\n\tvolatile uint8_t x503 = UINT8_MAX;\n\tint32_t x504 = 62286732;\n\tvolatile int32_t t125 = -1963498;\n    t125 = ((x501>x502)==(x503^x504));\n    if (t125 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "9080c3ab4cf94f67546cd04f0d55868d9d020151", "ext": "c", "lang": "C", "content": "static qboolean CG_ParseCharacterFile(const char *filename, clientInfo_t * ci)\n{\n\tchar           *text_p, *prev;\n\tint             len;\n\tint             i;\n\tchar           *token;\n\tfloat           fps;\n\tint             skip;\n\tchar            text[20000];\n\tfileHandle_t    f;\n\n\t// load the file\n\tlen = trap_FS_FOpenFile(filename, &f, FS_READ);\n\tif(len <= 0)\n\t{\n\t\treturn qfalse;\n\t}\n\tif(len >= sizeof(text) - 1)\n\t{\n\t\tCG_Printf(\"File %s too long\\n\", filename);\n\t\ttrap_FS_FCloseFile(f);\n\t\treturn qfalse;\n\t}\n\ttrap_FS_Read(text, len, f);\n\ttext[len] = 0;\n\ttrap_FS_FCloseFile(f);\n\n\t// parse the text\n\ttext_p = text;\n\tskip = 0;\t\t\t\t\t// quite the compiler warning\n\n\tci->footsteps = FOOTSTEP_STONE;\n\tVectorClear(ci->headOffset);\n\tci->gender = GENDER_MALE;\n\tci->fixedlegs = qfalse;\n\tci->fixedtorso = qfalse;\n\tci->firstTorsoBoneName[0] = '\\0';\n\tci->lastTorsoBoneName[0] = '\\0';\n\tci->torsoControlBoneName[0] = '\\0';\n\tci->neckControlBoneName[0] = '\\0';\n\tci->modelScale[0] = 1;\n\tci->modelScale[1] = 1;\n\tci->modelScale[2] = 1;\n\n\t// read optional parameters\n\twhile(1)\n\t{\n\t\tprev = text_p;\t\t\t// so we can unget\n\t\ttoken = Com_Parse(&text_p);\n\t\tif(!token[0])\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(!Q_stricmp(token, \"footsteps\"))\n\t\t{\n\t\t\ttoken = Com_Parse(&text_p);\n\t\t\tif(!token)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!Q_stricmp(token, \"default\") || !Q_stricmp(token, \"normal\") || !Q_stricmp(token, \"stone\"))\n\t\t\t{\n\t\t\t\tci->footsteps = FOOTSTEP_STONE;\n\t\t\t}\n\t\t\telse if(!Q_stricmp(token, \"boot\"))\n\t\t\t{\n\t\t\t\tci->footsteps = FOOTSTEP_BOOT;\n\t\t\t}\n\t\t\telse if(!Q_stricmp(token, \"flesh\"))\n\t\t\t{\n\t\t\t\tci->footsteps = FOOTSTEP_FLESH;\n\t\t\t}\n\t\t\telse if(!Q_stricmp(token, \"mech\"))\n\t\t\t{\n\t\t\t\tci->footsteps = FOOTSTEP_MECH;\n\t\t\t}\n\t\t\telse if(!Q_stricmp(token, \"energy\"))\n\t\t\t{\n\t\t\t\tci->footsteps = FOOTSTEP_ENERGY;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCG_Printf(\"Bad footsteps parm in %s: %s\\n\", filename, token);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"headoffset\"))\n\t\t{\n\t\t\tfor(i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\ttoken = Com_Parse(&text_p);\n\t\t\t\tif(!token)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tci->headOffset[i] = atof(token);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"sex\"))\n\t\t{\n\t\t\ttoken = Com_Parse(&text_p);\n\t\t\tif(!token)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(token[0] == 'f' || token[0] == 'F')\n\t\t\t{\n\t\t\t\tci->gender = GENDER_FEMALE;\n\t\t\t}\n\t\t\telse if(token[0] == 'n' || token[0] == 'N')\n\t\t\t{\n\t\t\t\tci->gender = GENDER_NEUTER;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tci->gender = GENDER_MALE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"fixedlegs\"))\n\t\t{\n\t\t\tci->fixedlegs = qtrue;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"fixedtorso\"))\n\t\t{\n\t\t\tci->fixedtorso = qtrue;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"firstTorsoBoneName\"))\n\t\t{\n\t\t\ttoken = Com_Parse(&text_p);\n\t\t\tQ_strncpyz(ci->firstTorsoBoneName, token, sizeof(ci->firstTorsoBoneName));\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"lastTorsoBoneName\"))\n\t\t{\n\t\t\ttoken = Com_Parse(&text_p);\n\t\t\tQ_strncpyz(ci->lastTorsoBoneName, token, sizeof(ci->lastTorsoBoneName));\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"torsoControlBoneName\"))\n\t\t{\n\t\t\ttoken = Com_Parse(&text_p);\n\t\t\tQ_strncpyz(ci->torsoControlBoneName, token, sizeof(ci->torsoControlBoneName));\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"neckControlBoneName\"))\n\t\t{\n\t\t\ttoken = Com_Parse(&text_p);\n\t\t\tQ_strncpyz(ci->neckControlBoneName, token, sizeof(ci->neckControlBoneName));\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"modelScale\"))\n\t\t{\n\t\t\tfor(i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\ttoken = Com_ParseExt(&text_p, qfalse);\n\t\t\t\tif(!token)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tci->modelScale[i] = atof(token);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tCom_Printf(\"unknown token '%s' is %s\\n\", token, filename);\n\t}\n\t\n\treturn qtrue;\n}", "item_id": 0, "repo": "raynorpat/xreal", "file": "code/cgame/cg_xppm.c", "last_update_at": "2021-09-09T19:35:32+00:00", "question_id": "9080c3ab4cf94f67546cd04f0d55868d9d020151_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static qboolean CG_ParseCharacterFile(const char *filename, clientInfo_t * ci)\n{\n\tchar           *text_p, *prev;\n\tint             len;\n\tint             i;\n\tchar           *token;\n\tfloat           fps;\n\tint             skip;\n\tchar            text[20000];\n\tfileHandle_t    f;\n\t// load the file\n\tlen = trap_FS_FOpenFile(filename, &f, FS_READ);\n\tif(len <= 0)\n\t{\n\t\treturn qfalse;\n\t}\n\tif(len >= sizeof(text) - 1)\n\t{\n\t\tCG_Printf(\"File %s too long\\n\", filename);\n\t\ttrap_FS_FCloseFile(f);\n\t\treturn qfalse;\n\t}\n\ttrap_FS_Read(text, len, f);\n\ttext[len] = 0;\n\ttrap_FS_FCloseFile(f);\n\t// parse the text\n\ttext_p = text;\n\tskip = 0;\t\t\t\t\t// quite the compiler warning\n\tci->footsteps = FOOTSTEP_STONE;\n\tVectorClear(ci->headOffset);\n\tci->gender = GENDER_MALE;\n\tci->fixedlegs = qfalse;\n\tci->fixedtorso = qfalse;\n\tci->firstTorsoBoneName[0] = '\\0';\n\tci->lastTorsoBoneName[0] = '\\0';\n\tci->torsoControlBoneName[0] = '\\0';\n\tci->neckControlBoneName[0] = '\\0';\n\tci->modelScale[0] = 1;\n\tci->modelScale[1] = 1;\n\tci->modelScale[2] = 1;\n\t// read optional parameters\n\twhile(1)\n\t{\n\t\tprev = text_p;\t\t\t// so we can unget\n\t\ttoken = Com_Parse(&text_p);\n\t\tif(!token[0])\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(!Q_stricmp(token, \"footsteps\"))\n\t\t{\n\t\t\ttoken = Com_Parse(&text_p);\n\t\t\tif(!token)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!Q_stricmp(token, \"default\") || !Q_stricmp(token, \"normal\") || !Q_stricmp(token, \"stone\"))\n\t\t\t{\n\t\t\t\tci->footsteps = FOOTSTEP_STONE;\n\t\t\t}\n\t\t\telse if(!Q_stricmp(token, \"boot\"))\n\t\t\t{\n\t\t\t\tci->footsteps = FOOTSTEP_BOOT;\n\t\t\t}\n\t\t\telse if(!Q_stricmp(token, \"flesh\"))\n\t\t\t{\n\t\t\t\tci->footsteps = FOOTSTEP_FLESH;\n\t\t\t}\n\t\t\telse if(!Q_stricmp(token, \"mech\"))\n\t\t\t{\n\t\t\t\tci->footsteps = FOOTSTEP_MECH;\n\t\t\t}\n\t\t\telse if(!Q_stricmp(token, \"energy\"))\n\t\t\t{\n\t\t\t\tci->footsteps = FOOTSTEP_ENERGY;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCG_Printf(\"Bad footsteps parm in %s: %s\\n\", filename, token);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"headoffset\"))\n\t\t{\n\t\t\tfor(i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\ttoken = Com_Parse(&text_p);\n\t\t\t\tif(!token)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tci->headOffset[i] = atof(token);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"sex\"))\n\t\t{\n\t\t\ttoken = Com_Parse(&text_p);\n\t\t\tif(!token)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(token[0] == 'f' || token[0] == 'F')\n\t\t\t{\n\t\t\t\tci->gender = GENDER_FEMALE;\n\t\t\t}\n\t\t\telse if(token[0] == 'n' || token[0] == 'N')\n\t\t\t{\n\t\t\t\tci->gender = GENDER_NEUTER;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tci->gender = GENDER_MALE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"fixedlegs\"))\n\t\t{\n\t\t\tci->fixedlegs = qtrue;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"fixedtorso\"))\n\t\t{\n\t\t\tci->fixedtorso = qtrue;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"firstTorsoBoneName\"))\n\t\t{\n\t\t\ttoken = Com_Parse(&text_p);\n\t\t\tQ_strncpyz(ci->firstTorsoBoneName, token, sizeof(ci->firstTorsoBoneName));\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"lastTorsoBoneName\"))\n\t\t{\n\t\t\ttoken = Com_Parse(&text_p);\n\t\t\tQ_strncpyz(ci->lastTorsoBoneName, token, sizeof(ci->lastTorsoBoneName));\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"torsoControlBoneName\"))\n\t\t{\n\t\t\ttoken = Com_Parse(&text_p);\n\t\t\tQ_strncpyz(ci->torsoControlBoneName, token, sizeof(ci->torsoControlBoneName));\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"neckControlBoneName\"))\n\t\t{\n\t\t\ttoken = Com_Parse(&text_p);\n\t\t\tQ_strncpyz(ci->neckControlBoneName, token, sizeof(ci->neckControlBoneName));\n\t\t\tcontinue;\n\t\t}\n\t\telse if(!Q_stricmp(token, \"modelScale\"))\n\t\t{\n\t\t\tfor(i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\ttoken = Com_ParseExt(&text_p, qfalse);\n\t\t\t\tif(!token)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tci->modelScale[i] = atof(token);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tCom_Printf(\"unknown token '%s' is %s\\n\", token, filename);\n\t}\n\t\n\treturn qtrue;\n"]]}
{"hexsha": "030b0c280f188ad3d3ce6807c485dc62b9066d03", "ext": "c", "lang": "C", "content": "void gp2x_video_RGB_setscaling(int W, int H)\r\n{\r\n float escalaw,escalah;\r\n int bpp=(gp2x_memregs[0x28DA>>1]>>9)&0x3;\r\n\r\n if(gp2x_memregs[0x2800>>1]&0x100) //TV-Out\r\n {\r\n   escalaw=489.0; //RGB Horiz TV (PAL, NTSC)\r\n   if (gp2x_memregs[0x2818>>1]  == 287) //PAL\r\n     escalah=274.0; //RGB Vert TV PAL\r\n   else if (gp2x_memregs[0x2818>>1]  == 239) //NTSC\r\n     escalah=331.0; //RGB Vert TV NTSC\r\n }\r\n else //LCD\r\n {\r\n   escalaw=1024.0; //RGB Horiz LCD\r\n   escalah=320.0; //RGB Vert LCD\r\n }\r\n\r\n // scale horizontal\r\n gp2x_memregs[0x2906>>1]=(unsigned short)((float)escalaw *(W/320.0));\r\n // scale vertical\r\n gp2x_memregl[0x2908>>2]=(unsigned long)((float)escalah *bpp *(H/240.0));\r\n}", "item_id": 15, "repo": "Pretz/SNesoid", "file": "SNesoid/sneslib/gp2x_sdk.c", "last_update_at": "2021-10-05T23:24:33+00:00", "question_id": "030b0c280f188ad3d3ce6807c485dc62b9066d03_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void gp2x_video_RGB_setscaling(int W, int H)\r\n{\r\n float escalaw,escalah;\r\n int bpp=(gp2x_memregs[0x28DA>>1]>>9)&0x3;\r\n\r\n if(gp2x_memregs[0x2800>>1]&0x100) //TV-Out\r\n {\r\n   escalaw=489.0; //RGB Horiz TV (PAL, NTSC)\r\n   if (gp2x_memregs[0x2818>>1]  == 287) //PAL\r\n     escalah=274.0; //RGB Vert TV PAL\r\n   else if (gp2x_memregs[0x2818>>1]  == 239) //NTSC\r\n     escalah=331.0; //RGB Vert TV NTSC\r\n }\r\n else //LCD\r\n {\r\n   escalaw=1024.0; //RGB Horiz LCD\r\n   escalah=320.0; //RGB Vert LCD\r\n }\r\n\r\n // scale horizontal\r\n gp2x_memregs[0x2906>>1]=(unsigned short)((float)escalaw *(W/320.0));\r\n // scale vertical\r\n gp2x_memregl[0x2908>>2]=(unsigned long)((float)escalah *bpp *(H/240.0));\r\n"]]}
{"hexsha": "eb348c91071718d9740114ba881b47eee4c0d6c6", "ext": "c", "lang": "C", "content": "static int route4_change(struct tcf_proto *tp, unsigned long base,\n\t\t       u32 handle,\n\t\t       struct rtattr **tca,\n\t\t       unsigned long *arg)\n{\n\tstruct route4_head *head = tp->root;\n\tstruct route4_filter *f, *f1, **ins_f;\n\tstruct route4_bucket *b;\n\tstruct rtattr *opt = tca[TCA_OPTIONS-1];\n\tstruct rtattr *tb[TCA_ROUTE4_MAX];\n\tunsigned h1, h2;\n\tint err;\n\n\tif (opt == NULL)\n\t\treturn handle ? -EINVAL : 0;\n\n\tif (rtattr_parse(tb, TCA_ROUTE4_MAX, RTA_DATA(opt), RTA_PAYLOAD(opt)) < 0)\n\t\treturn -EINVAL;\n\n\tif ((f = (struct route4_filter*)*arg) != NULL) {\n\t\t/* Node exists: adjust only classid */\n\n\t\tif (f->handle != handle && handle)\n\t\t\treturn -EINVAL;\n\t\tif (tb[TCA_ROUTE4_CLASSID-1]) {\n\t\t\tunsigned long cl;\n\n\t\t\tf->res.classid = *(u32*)RTA_DATA(tb[TCA_ROUTE4_CLASSID-1]);\n\t\t\tcl = cls_set_class(tp, &f->res.class, tp->q->ops->cl_ops->bind_tcf(tp->q, base, f->res.classid));\n\t\t\tif (cl)\n\t\t\t\ttp->q->ops->cl_ops->unbind_tcf(tp->q, cl);\n\t\t}\n#ifdef CONFIG_NET_CLS_POLICE\n\t\tif (tb[TCA_ROUTE4_POLICE-1]) {\n\t\t\tstruct tcf_police *police = tcf_police_locate(tb[TCA_ROUTE4_POLICE-1], tca[TCA_RATE-1]);\n\n\t\t\ttcf_tree_lock(tp);\n\t\t\tpolice = xchg(&f->police, police);\n\t\t\ttcf_tree_unlock(tp);\n\n\t\t\ttcf_police_release(police);\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\n\t/* Now more serious part... */\n\n\tif (head == NULL) {\n\t\thead = kmalloc(sizeof(struct route4_head), GFP_KERNEL);\n\t\tif (head == NULL)\n\t\t\treturn -ENOBUFS;\n\t\tmemset(head, 0, sizeof(struct route4_head));\n\n\t\ttcf_tree_lock(tp);\n\t\ttp->root = head;\n\t\ttcf_tree_unlock(tp);\n\t}\n\n\tf = kmalloc(sizeof(struct route4_filter), GFP_KERNEL);\n\tif (f == NULL)\n\t\treturn -ENOBUFS;\n\n\tmemset(f, 0, sizeof(*f));\n\n\terr = -EINVAL;\n\tf->handle = 0x8000;\n\tif (tb[TCA_ROUTE4_TO-1]) {\n\t\tif (handle&0x8000)\n\t\t\tgoto errout;\n\t\tif (RTA_PAYLOAD(tb[TCA_ROUTE4_TO-1]) < 4)\n\t\t\tgoto errout;\n\t\tf->id = *(u32*)RTA_DATA(tb[TCA_ROUTE4_TO-1]);\n\t\tif (f->id > 0xFF)\n\t\t\tgoto errout;\n\t\tf->handle = f->id;\n\t}\n\tif (tb[TCA_ROUTE4_FROM-1]) {\n\t\tu32 sid;\n\t\tif (tb[TCA_ROUTE4_IIF-1])\n\t\t\tgoto errout;\n\t\tif (RTA_PAYLOAD(tb[TCA_ROUTE4_FROM-1]) < 4)\n\t\t\tgoto errout;\n\t\tsid = (*(u32*)RTA_DATA(tb[TCA_ROUTE4_FROM-1]));\n\t\tif (sid > 0xFF)\n\t\t\tgoto errout;\n\t\tf->handle |= sid<<16;\n\t\tf->id |= sid<<16;\n\t} else if (tb[TCA_ROUTE4_IIF-1]) {\n\t\tif (RTA_PAYLOAD(tb[TCA_ROUTE4_IIF-1]) < 4)\n\t\t\tgoto errout;\n\t\tf->iif = *(u32*)RTA_DATA(tb[TCA_ROUTE4_IIF-1]);\n\t\tif (f->iif > 0x7FFF)\n\t\t\tgoto errout;\n\t\tf->handle |= (f->iif|0x8000)<<16;\n\t} else\n\t\tf->handle |= 0xFFFF<<16;\n\n\tif (handle) {\n\t\tf->handle |= handle&0x7F00;\n\t\tif (f->handle != handle)\n\t\t\tgoto errout;\n\t}\n\n\tif (tb[TCA_ROUTE4_CLASSID-1]) {\n\t\tif (RTA_PAYLOAD(tb[TCA_ROUTE4_CLASSID-1]) < 4)\n\t\t\tgoto errout;\n\t\tf->res.classid = *(u32*)RTA_DATA(tb[TCA_ROUTE4_CLASSID-1]);\n\t}\n\n\th1 = to_hash(f->handle);\n\tif ((b = head->table[h1]) == NULL) {\n\t\terr = -ENOBUFS;\n\t\tb = kmalloc(sizeof(struct route4_bucket), GFP_KERNEL);\n\t\tif (b == NULL)\n\t\t\tgoto errout;\n\t\tmemset(b, 0, sizeof(*b));\n\n\t\ttcf_tree_lock(tp);\n\t\thead->table[h1] = b;\n\t\ttcf_tree_unlock(tp);\n\t}\n\tf->bkt = b;\n\n\terr = -EEXIST;\n\th2 = from_hash(f->handle>>16);\n\tfor (ins_f = &b->ht[h2]; (f1=*ins_f) != NULL; ins_f = &f1->next) {\n\t\tif (f->handle < f1->handle)\n\t\t\tbreak;\n\t\tif (f1->handle == f->handle)\n\t\t\tgoto errout;\n\t}\n\n\tcls_set_class(tp, &f->res.class, tp->q->ops->cl_ops->bind_tcf(tp->q, base, f->res.classid));\n#ifdef CONFIG_NET_CLS_POLICE\n\tif (tb[TCA_ROUTE4_POLICE-1])\n\t\tf->police = tcf_police_locate(tb[TCA_ROUTE4_POLICE-1], tca[TCA_RATE-1]);\n#endif\n\n\tf->next = f1;\n\ttcf_tree_lock(tp);\n\t*ins_f = f;\n\ttcf_tree_unlock(tp);\n\n\troute4_reset_fastmap(tp->q->dev, head, f->id);\n\t*arg = (unsigned long)f;\n\treturn 0;\n\nerrout:\n\tif (f)\n\t\tkfree(f);\n\treturn err;\n}", "item_id": 8, "repo": "enfoTek/tomato.linksys.e2000.nvram-mod", "file": "release/src/linux/linux/net/sched/cls_route.c", "last_update_at": "2021-06-07T06:29:49+00:00", "question_id": "eb348c91071718d9740114ba881b47eee4c0d6c6_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int route4_change(struct tcf_proto *tp, unsigned long base,\n\t\t       u32 handle,\n\t\t       struct rtattr **tca,\n\t\t       unsigned long *arg)\n{\n\tstruct route4_head *head = tp->root;\n\tstruct route4_filter *f, *f1, **ins_f;\n\tstruct route4_bucket *b;\n\tstruct rtattr *opt = tca[TCA_OPTIONS-1];\n\tstruct rtattr *tb[TCA_ROUTE4_MAX];\n\tunsigned h1, h2;\n\tint err;\n\tif (opt == NULL)\n\t\treturn handle ? -EINVAL : 0;\n\tif (rtattr_parse(tb, TCA_ROUTE4_MAX, RTA_DATA(opt), RTA_PAYLOAD(opt)) < 0)\n\t\treturn -EINVAL;\n\tif ((f = (struct route4_filter*)*arg) != NULL) {\n\t\t/* Node exists: adjust only classid */\n\t\tif (f->handle != handle && handle)\n\t\t\treturn -EINVAL;\n\t\tif (tb[TCA_ROUTE4_CLASSID-1]) {\n\t\t\tunsigned long cl;\n\t\t\tf->res.classid = *(u32*)RTA_DATA(tb[TCA_ROUTE4_CLASSID-1]);\n\t\t\tcl = cls_set_class(tp, &f->res.class, tp->q->ops->cl_ops->bind_tcf(tp->q, base, f->res.classid));\n\t\t\tif (cl)\n\t\t\t\ttp->q->ops->cl_ops->unbind_tcf(tp->q, cl);\n\t\t}\n#ifdef CONFIG_NET_CLS_POLICE\n\t\tif (tb[TCA_ROUTE4_POLICE-1]) {\n\t\t\tstruct tcf_police *police = tcf_police_locate(tb[TCA_ROUTE4_POLICE-1], tca[TCA_RATE-1]);\n\t\t\ttcf_tree_lock(tp);\n\t\t\tpolice = xchg(&f->police, police);\n\t\t\ttcf_tree_unlock(tp);\n\t\t\ttcf_police_release(police);\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\t/* Now more serious part... */\n\tif (head == NULL) {\n\t\thead = kmalloc(sizeof(struct route4_head), GFP_KERNEL);\n\t\tif (head == NULL)\n\t\t\treturn -ENOBUFS;\n\t\tmemset(head, 0, sizeof(struct route4_head));\n\t\ttcf_tree_lock(tp);\n\t\ttp->root = head;\n\t\ttcf_tree_unlock(tp);\n\t}\n\tf = kmalloc(sizeof(struct route4_filter), GFP_KERNEL);\n\tif (f == NULL)\n\t\treturn -ENOBUFS;\n\tmemset(f, 0, sizeof(*f));\n\terr = -EINVAL;\n\tf->handle = 0x8000;\n\tif (tb[TCA_ROUTE4_TO-1]) {\n\t\tif (handle&0x8000)\n\t\t\tgoto errout;\n\t\tif (RTA_PAYLOAD(tb[TCA_ROUTE4_TO-1]) < 4)\n\t\t\tgoto errout;\n\t\tf->id = *(u32*)RTA_DATA(tb[TCA_ROUTE4_TO-1]);\n\t\tif (f->id > 0xFF)\n\t\t\tgoto errout;\n\t\tf->handle = f->id;\n\t}\n\tif (tb[TCA_ROUTE4_FROM-1]) {\n\t\tu32 sid;\n\t\tif (tb[TCA_ROUTE4_IIF-1])\n\t\t\tgoto errout;\n\t\tif (RTA_PAYLOAD(tb[TCA_ROUTE4_FROM-1]) < 4)\n\t\t\tgoto errout;\n\t\tsid = (*(u32*)RTA_DATA(tb[TCA_ROUTE4_FROM-1]));\n\t\tif (sid > 0xFF)\n\t\t\tgoto errout;\n\t\tf->handle |= sid<<16;\n\t\tf->id |= sid<<16;\n\t} else if (tb[TCA_ROUTE4_IIF-1]) {\n\t\tif (RTA_PAYLOAD(tb[TCA_ROUTE4_IIF-1]) < 4)\n\t\t\tgoto errout;\n\t\tf->iif = *(u32*)RTA_DATA(tb[TCA_ROUTE4_IIF-1]);\n\t\tif (f->iif > 0x7FFF)\n\t\t\tgoto errout;\n\t\tf->handle |= (f->iif|0x8000)<<16;\n\t} else\n\t\tf->handle |= 0xFFFF<<16;\n\tif (handle) {\n\t\tf->handle |= handle&0x7F00;\n\t\tif (f->handle != handle)\n\t\t\tgoto errout;\n\t}\n\tif (tb[TCA_ROUTE4_CLASSID-1]) {\n\t\tif (RTA_PAYLOAD(tb[TCA_ROUTE4_CLASSID-1]) < 4)\n\t\t\tgoto errout;\n\t\tf->res.classid = *(u32*)RTA_DATA(tb[TCA_ROUTE4_CLASSID-1]);\n\t}\n\th1 = to_hash(f->handle);\n\tif ((b = head->table[h1]) == NULL) {\n\t\terr = -ENOBUFS;\n\t\tb = kmalloc(sizeof(struct route4_bucket), GFP_KERNEL);\n\t\tif (b == NULL)\n\t\t\tgoto errout;\n\t\tmemset(b, 0, sizeof(*b));\n\t\ttcf_tree_lock(tp);\n\t\thead->table[h1] = b;\n\t\ttcf_tree_unlock(tp);\n\t}\n\tf->bkt = b;\n\terr = -EEXIST;\n\th2 = from_hash(f->handle>>16);\n\tfor (ins_f = &b->ht[h2]; (f1=*ins_f) != NULL; ins_f = &f1->next) {\n\t\tif (f->handle < f1->handle)\n\t\t\tbreak;\n\t\tif (f1->handle == f->handle)\n\t\t\tgoto errout;\n\t}\n\tcls_set_class(tp, &f->res.class, tp->q->ops->cl_ops->bind_tcf(tp->q, base, f->res.classid));\n#ifdef CONFIG_NET_CLS_POLICE\n\tif (tb[TCA_ROUTE4_POLICE-1])\n\t\tf->police = tcf_police_locate(tb[TCA_ROUTE4_POLICE-1], tca[TCA_RATE-1]);\n#endif\n\tf->next = f1;\n\ttcf_tree_lock(tp);\n\t*ins_f = f;\n\ttcf_tree_unlock(tp);\n\troute4_reset_fastmap(tp->q->dev, head, f->id);\n\t*arg = (unsigned long)f;\n\treturn 0;\nerrout:\n\tif (f)\n\t\tkfree(f);\n\treturn err;\n"]]}
{"hexsha": "14870111e8e9f65582c77c640e400bc4faaa0c34", "ext": "c", "lang": "C", "content": "int codec_gzip_create(int op, codec_t **piz)\n{\n    codec_gzip_t *iz = NULL;\n\n    dbg_return_if (piz == NULL, ~0);\n\n    iz = u_zalloc(sizeof(codec_gzip_t));\n    dbg_err_if(iz == NULL);\n\n    iz->codec.transform = gzip_transform;\n    iz->codec.flush = gzip_flush;\n    iz->codec.free = gzip_free;\n    iz->action = op; \n\n    switch(op)\n    {\n    case GZIP_COMPRESS:\n        iz->op = deflate;\n        iz->opEnd = deflateEnd;\n        dbg_err_if(deflateInit2(&iz->zstr, Z_DEFAULT_COMPRESSION, Z_DEFLATED,\n                    -MAX_WBITS, 8, Z_DEFAULT_STRATEGY));\n        break;\n    case GZIP_UNCOMPRESS:\n        iz->op = inflate;\n        iz->opEnd = inflateEnd;\n        dbg_err_if(inflateInit2(&iz->zstr, -MAX_WBITS) != Z_OK);\n        break;\n    default:\n        dbg_err_if(\"bad gzip op\");\n    }\n\n    *piz = (codec_t*)iz;\n\n    return 0;\nerr:\n    U_FREE(iz);\n    return ~0;\n}", "item_id": 3, "repo": "rajeevvats/klone_webServer", "file": "src/libcodec/gzip.c", "last_update_at": "2021-09-11T15:03:04+00:00", "question_id": "14870111e8e9f65582c77c640e400bc4faaa0c34_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int codec_gzip_create(int op, codec_t **piz)\n{\n    codec_gzip_t *iz = NULL;\n    dbg_return_if (piz == NULL, ~0);\n    iz = u_zalloc(sizeof(codec_gzip_t));\n    dbg_err_if(iz == NULL);\n    iz->codec.transform = gzip_transform;\n    iz->codec.flush = gzip_flush;\n    iz->codec.free = gzip_free;\n    iz->action = op; \n    switch(op)\n    {\n    case GZIP_COMPRESS:\n        iz->op = deflate;\n        iz->opEnd = deflateEnd;\n        dbg_err_if(deflateInit2(&iz->zstr, Z_DEFAULT_COMPRESSION, Z_DEFLATED,\n                    -MAX_WBITS, 8, Z_DEFAULT_STRATEGY));\n        break;\n    case GZIP_UNCOMPRESS:\n        iz->op = inflate;\n        iz->opEnd = inflateEnd;\n        dbg_err_if(inflateInit2(&iz->zstr, -MAX_WBITS) != Z_OK);\n        break;\n    default:\n        dbg_err_if(\"bad gzip op\");\n    }\n    *piz = (codec_t*)iz;\n    return 0;\nerr:\n    U_FREE(iz);\n    return ~0;\n"]]}
{"hexsha": "f883de602315e1de39d913ae15afce202ca8d6be", "ext": "c", "lang": "C", "content": "void f22(void) {\n    \tstatic uint64_t x149 = 152LLU;\n\tint32_t x150 = INT32_MAX;\n\tstatic uint64_t x151 = 479090467LLU;\n\tstatic volatile uint64_t t22 = 7246107089468116LLU;\n\n    t22 = ((x149==x150)/(x151/x152));\n\n    if (t22 != 0LLU) { NG(); } else { ; }\n\t\n}", "item_id": 22, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test690.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "f883de602315e1de39d913ae15afce202ca8d6be_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f22(void) {\n    \tstatic uint64_t x149 = 152LLU;\n\tint32_t x150 = INT32_MAX;\n\tstatic uint64_t x151 = 479090467LLU;\n\tstatic volatile uint64_t t22 = 7246107089468116LLU;\n    t22 = ((x149==x150)/(x151/x152));\n    if (t22 != 0LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "6a50b4c23d3e5a6502326cce3dca351a9f1ef36c", "ext": "c", "lang": "C", "content": "void f197(void) {\n    \tuint8_t x5065 = 1U;\n\tint8_t x5068 = -1;\n\tvolatile uint32_t t197 = 11U;\n\n    t197 = ((x5065|x5066)<<(x5067%x5068));\n\n    if (t197 != 29U) { NG(); } else { ; }\n\t\n}", "item_id": 197, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test958.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "6a50b4c23d3e5a6502326cce3dca351a9f1ef36c_197", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f197(void) {\n    \tuint8_t x5065 = 1U;\n\tint8_t x5068 = -1;\n\tvolatile uint32_t t197 = 11U;\n    t197 = ((x5065|x5066)<<(x5067%x5068));\n    if (t197 != 29U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "8cb4338e5aa71a4131d28cce9d2c921b2c0783cc", "ext": "c", "lang": "C", "content": "INT_PTR CALLBACK Appletalk_PropertiesDlgProc(\r\n    IN HWND     hwnd,\r\n    IN UINT     uMsg,\r\n    IN WPARAM   wParam,\r\n    IN LPARAM   lParam)\r\n{\r\n\r\n    BOOL bStatus = TRUE;\r\n\r\n    switch( uMsg ) {\r\n\r\n        case WM_INITDIALOG: {\r\n\r\n            OnAppleTalkInitDialog( hwnd );\r\n\r\n            break;\r\n        }\r\n\r\n        case WM_NOTIFY: {\r\n\r\n            LPNMHDR pnmh = (LPNMHDR) lParam;\r\n\r\n            switch( pnmh->code ) {\r\n\r\n                case PSN_APPLY: {\r\n\r\n                    OnAppleTalkApply( hwnd );\r\n\r\n\r\n                }\r\n\r\n            }\r\n\r\n            break;\r\n\r\n        }    // end case WM_NOTIFY\r\n\r\n        case WM_COMMAND: {\r\n\r\n            WORD wNotifyCode = HIWORD( wParam ) ;\r\n            WORD wButtonId   = LOWORD( wParam ) ;\r\n\r\n\r\n            break;\r\n\r\n        }\r\n\r\n        default:\r\n\r\n            bStatus = FALSE;\r\n            break;\r\n\r\n    }\r\n\r\n    return( bStatus );\r\n\r\n}", "item_id": 3, "repo": "npocmaka/Windows-Server-2003", "file": "base/ntsetup/opktools/setupmgr/net/appletlk.c", "last_update_at": "2021-09-16T09:13:13+00:00", "question_id": "8cb4338e5aa71a4131d28cce9d2c921b2c0783cc_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["INT_PTR CALLBACK Appletalk_PropertiesDlgProc(\r\n    IN HWND     hwnd,\r\n    IN UINT     uMsg,\r\n    IN WPARAM   wParam,\r\n    IN LPARAM   lParam)\r\n{\r\n\r\n    BOOL bStatus = TRUE;\r\n\r\n    switch( uMsg ) {\r\n\r\n        case WM_INITDIALOG: {\r\n\r\n            OnAppleTalkInitDialog( hwnd );\r\n\r\n            break;\r\n        }\r\n\r\n        case WM_NOTIFY: {\r\n\r\n            LPNMHDR pnmh = (LPNMHDR) lParam;\r\n\r\n            switch( pnmh->code ) {\r\n\r\n                case PSN_APPLY: {\r\n\r\n                    OnAppleTalkApply( hwnd );\r\n\r\n\r\n                }\r\n\r\n            }\r\n\r\n            break;\r\n\r\n        }    // end case WM_NOTIFY\r\n\r\n        case WM_COMMAND: {\r\n\r\n            WORD wNotifyCode = HIWORD( wParam ) ;\r\n            WORD wButtonId   = LOWORD( wParam ) ;\r\n\r\n\r\n            break;\r\n\r\n        }\r\n\r\n        default:\r\n\r\n            bStatus = FALSE;\r\n            break;\r\n\r\n    }\r\n\r\n    return( bStatus );\r\n\r\n"]]}
{"hexsha": "6c31bfff23ebb07b2c0d627fa91b595afe5f3532", "ext": "c", "lang": "C", "content": "void f188(void) {\n    \tint16_t x761 = -1;\n\tstatic int8_t x763 = 63;\n\tuint64_t x764 = 11114862LLU;\n\tvolatile uint64_t t188 = 440311027LLU;\n\n    t188 = (((x761==x762)%x763)+x764);\n\n    if (t188 != 11114862LLU) { NG(); } else { ; }\n\t\n}", "item_id": 188, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test1429.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "6c31bfff23ebb07b2c0d627fa91b595afe5f3532_188", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f188(void) {\n    \tint16_t x761 = -1;\n\tstatic int8_t x763 = 63;\n\tuint64_t x764 = 11114862LLU;\n\tvolatile uint64_t t188 = 440311027LLU;\n    t188 = (((x761==x762)%x763)+x764);\n    if (t188 != 11114862LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "ae9859e0e72db0fbad569a9c9acafad091e649c0", "ext": "c", "lang": "C", "content": "void f187(void) {\n    \tint32_t x785 = -467568;\n\tuint8_t x786 = 28U;\n\tstatic int64_t x787 = INT64_MAX;\n\tint64_t x788 = -1LL;\n\tint64_t t187 = 13750736887277LL;\n\n    t187 = (x785%(x786|(x787%x788)));\n\n    if (t187 != -24LL) { NG(); } else { ; }\n\t\n}", "item_id": 187, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test957.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "ae9859e0e72db0fbad569a9c9acafad091e649c0_187", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f187(void) {\n    \tint32_t x785 = -467568;\n\tuint8_t x786 = 28U;\n\tstatic int64_t x787 = INT64_MAX;\n\tint64_t x788 = -1LL;\n\tint64_t t187 = 13750736887277LL;\n    t187 = (x785%(x786|(x787%x788)));\n    if (t187 != -24LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "ec1ab9a29b7db682d9e9afcb47e5c397873f8026", "ext": "c", "lang": "C", "content": "void FP_YYY_cswap(FP_YYY *a,FP_YYY *b,int d)\n{\n    sign32 t,c=d;\n    BIG_XXX_cswap(a->g,b->g,d);\n\n    c=~(c-1);\n    t=c&((a->XES)^(b->XES));\n    a->XES^=t;\n    b->XES^=t;\n\n}", "item_id": 10, "repo": "kirk-baird/amcl", "file": "version3/c/fp.c", "last_update_at": "2021-12-17T16:34:32+00:00", "question_id": "ec1ab9a29b7db682d9e9afcb47e5c397873f8026_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void FP_YYY_cswap(FP_YYY *a,FP_YYY *b,int d)\n{\n    sign32 t,c=d;\n    BIG_XXX_cswap(a->g,b->g,d);\n    c=~(c-1);\n    t=c&((a->XES)^(b->XES));\n    a->XES^=t;\n    b->XES^=t;\n"]]}
{"hexsha": "7d8b4c9c085d8a496fdc66bd3dab6200e2dff6be", "ext": "c", "lang": "C", "content": "void f44(void) {\n    \tint64_t x197 = 397LL;\n\tint8_t x198 = 0;\n\n    t44 = (x197&((x198/x199)/x200));\n\n    if (t44 != 0LL) { NG(); } else { ; }\n\t\n}", "item_id": 44, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test642.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "7d8b4c9c085d8a496fdc66bd3dab6200e2dff6be_44", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f44(void) {\n    \tint64_t x197 = 397LL;\n\tint8_t x198 = 0;\n    t44 = (x197&((x198/x199)/x200));\n    if (t44 != 0LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "9f8bc1777700dc35f69ca8c66774581ac4e17945", "ext": "c", "lang": "C", "content": "void* ww_filesys_read_all(char const* file_path, size_t* const size) {\n    ww_filesys_entry_t key;\n    key.mp_path = file_path;\n\n    ww_filesys_entry_t const* const elements = ww_filesys_entries.elements;\n    size_t const count = ww_filesys_entries.count;\n    ww_filesys_entry_t* const found = bsearch(&key, elements, count, sizeof(ww_filesys_entry_t), ww_filesys_compare);\n\n    if (found == NULL) {\n        return NULL;\n    }\n\n    if (found->size == 0) {\n        // File system\n        struct stat stbuf;\n\n        if (stat(found->u.fs_path, &stbuf) != 0) {\n            return NULL;\n        }\n\n        void* const buffer = malloc(stbuf.st_size);\n\n        if (buffer == NULL) {\n            return NULL;\n        }\n\n        FILE* const fp = fopen(found->u.fs_path, \"rb\");\n\n        if (fp == NULL) {\n            free(buffer);\n            return NULL;\n        }\n\n        if (fread(buffer, 1, stbuf.st_size, fp) != stbuf.st_size) {\n            fclose(fp);\n            free(buffer);\n            return NULL;\n        }\n\n        fclose(fp);\n        *size = stbuf.st_size;\n        return buffer;\n    }\n    else {\n        // TAR entry.\n        if (fseek(found->u.tar, found->offset, SEEK_SET) != 0) {\n            return NULL;\n        }\n\n        void* const buffer = malloc(found->size);\n\n        if (buffer == NULL) {\n            return NULL;\n        }\n\n        if (fread(buffer, 1, found->size, found->u.tar) != found->size) {\n            free(buffer);\n            return NULL;\n        }\n\n        *size = found->size;\n        return buffer;\n    }\n}", "item_id": 10, "repo": "leiradel/ww-libretro", "file": "src/ww_filesys.c", "last_update_at": "2021-07-09T18:39:49+00:00", "question_id": "9f8bc1777700dc35f69ca8c66774581ac4e17945_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void* ww_filesys_read_all(char const* file_path, size_t* const size) {\n    ww_filesys_entry_t key;\n    key.mp_path = file_path;\n    ww_filesys_entry_t const* const elements = ww_filesys_entries.elements;\n    size_t const count = ww_filesys_entries.count;\n    ww_filesys_entry_t* const found = bsearch(&key, elements, count, sizeof(ww_filesys_entry_t), ww_filesys_compare);\n    if (found == NULL) {\n        return NULL;\n    }\n    if (found->size == 0) {\n        // File system\n        struct stat stbuf;\n        if (stat(found->u.fs_path, &stbuf) != 0) {\n            return NULL;\n        }\n        void* const buffer = malloc(stbuf.st_size);\n        if (buffer == NULL) {\n            return NULL;\n        }\n        FILE* const fp = fopen(found->u.fs_path, \"rb\");\n        if (fp == NULL) {\n            free(buffer);\n            return NULL;\n        }\n        if (fread(buffer, 1, stbuf.st_size, fp) != stbuf.st_size) {\n            fclose(fp);\n            free(buffer);\n            return NULL;\n        }\n        fclose(fp);\n        *size = stbuf.st_size;\n        return buffer;\n    }\n    else {\n        // TAR entry.\n        if (fseek(found->u.tar, found->offset, SEEK_SET) != 0) {\n            return NULL;\n        }\n        void* const buffer = malloc(found->size);\n        if (buffer == NULL) {\n            return NULL;\n        }\n        if (fread(buffer, 1, found->size, found->u.tar) != found->size) {\n            free(buffer);\n            return NULL;\n        }\n        *size = found->size;\n        return buffer;\n    }\n"]]}
{"hexsha": "fba7f8d0d146271bcb17e20d0a4ced35305bc130", "ext": "c", "lang": "C", "content": "static bool GetStackTrace(JNIEnv* env, jthrowable thrown, struct ExpandableString* dst) {\n    // This function is equivalent to the following Java snippet:\n    //   StringWriter sw = new StringWriter();\n    //   PrintWriter pw = new PrintWriter(sw);\n    //   thrown.printStackTrace(pw);\n    //   String trace = sw.toString();\n    //   return trace;\n    jobject sw = NewStringWriter(env);\n    if (sw == NULL) {\n        return false;\n    }\n\n    jobject pw = NewPrintWriter(env, sw);\n    if (pw == NULL) {\n        (*env)->DeleteLocalRef(env, sw);\n        return false;\n    }\n\n    jmethodID printStackTrace =\n        FindMethod(env, \"java/lang/Throwable\", \"printStackTrace\", \"(Ljava/io/PrintWriter;)V\");\n    (*env)->CallVoidMethod(env, thrown, printStackTrace, pw);\n\n    jstring trace = StringWriterToString(env, sw);\n\n    (*env)->DeleteLocalRef(env, pw);\n    pw = NULL;\n    (*env)->DeleteLocalRef(env, sw);\n    sw = NULL;\n\n    if (trace == NULL) {\n        return false;\n    }\n\n    bool success = AppendJString(env, trace, dst);\n    (*env)->DeleteLocalRef(env, trace);\n    return success;\n}", "item_id": 5, "repo": "gkpln3/serial-android", "file": "libserial/src/main/jni/libs/nativehelper/JNIHelp.c", "last_update_at": "2021-09-20T11:30:18+00:00", "question_id": "fba7f8d0d146271bcb17e20d0a4ced35305bc130_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static bool GetStackTrace(JNIEnv* env, jthrowable thrown, struct ExpandableString* dst) {\n    // This function is equivalent to the following Java snippet:\n    //   StringWriter sw = new StringWriter();\n    //   PrintWriter pw = new PrintWriter(sw);\n    //   thrown.printStackTrace(pw);\n    //   String trace = sw.toString();\n    //   return trace;\n    jobject sw = NewStringWriter(env);\n    if (sw == NULL) {\n        return false;\n    }\n    jobject pw = NewPrintWriter(env, sw);\n    if (pw == NULL) {\n        (*env)->DeleteLocalRef(env, sw);\n        return false;\n    }\n    jmethodID printStackTrace =\n        FindMethod(env, \"java/lang/Throwable\", \"printStackTrace\", \"(Ljava/io/PrintWriter;)V\");\n    (*env)->CallVoidMethod(env, thrown, printStackTrace, pw);\n    jstring trace = StringWriterToString(env, sw);\n    (*env)->DeleteLocalRef(env, pw);\n    pw = NULL;\n    (*env)->DeleteLocalRef(env, sw);\n    sw = NULL;\n    if (trace == NULL) {\n        return false;\n    }\n    bool success = AppendJString(env, trace, dst);\n    (*env)->DeleteLocalRef(env, trace);\n    return success;\n"]]}
{"hexsha": "176dccadf239629710c950fd2ddc688bdd1cd21e", "ext": "c", "lang": "C", "content": "void f25(void) {\n    \tint8_t x121 = -1;\n\tuint8_t x123 = 0U;\n\tuint16_t x124 = 2U;\n\tvolatile int32_t t25 = -37;\n\n    t25 = ((x121-(x122!=x123))-x124);\n\n    if (t25 != -4) { NG(); } else { ; }\n\t\n}", "item_id": 25, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test1192.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "176dccadf239629710c950fd2ddc688bdd1cd21e_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f25(void) {\n    \tint8_t x121 = -1;\n\tuint8_t x123 = 0U;\n\tuint16_t x124 = 2U;\n\tvolatile int32_t t25 = -37;\n    t25 = ((x121-(x122!=x123))-x124);\n    if (t25 != -4) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "ee3f0cfb695788ff0a492dcb5377e5368bd16051", "ext": "c", "lang": "C", "content": "void f128(void) {\n    \tint8_t x617 = -1;\n\tuint8_t x618 = 4U;\n\tint32_t x619 = INT32_MIN;\n\tstatic int32_t t128 = 188;\n\n    t128 = (((x617-x618)-x619)<=x620);\n\n    if (t128 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 128, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test220.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "ee3f0cfb695788ff0a492dcb5377e5368bd16051_128", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f128(void) {\n    \tint8_t x617 = -1;\n\tuint8_t x618 = 4U;\n\tint32_t x619 = INT32_MIN;\n\tstatic int32_t t128 = 188;\n    t128 = (((x617-x618)-x619)<=x620);\n    if (t128 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "4f6f87b39e652378e664b40f7feb12d364d66d2f", "ext": "c", "lang": "C", "content": "void f99(void) {\n    \tint32_t x397 = -5941127;\n\tint64_t x398 = INT64_MIN;\n\tint32_t x400 = INT32_MAX;\n\tint32_t t99 = 5811;\n\n    t99 = (((x397<=x398)<=x399)!=x400);\n\n    if (t99 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 99, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test1897.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "4f6f87b39e652378e664b40f7feb12d364d66d2f_99", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f99(void) {\n    \tint32_t x397 = -5941127;\n\tint64_t x398 = INT64_MIN;\n\tint32_t x400 = INT32_MAX;\n\tint32_t t99 = 5811;\n    t99 = (((x397<=x398)<=x399)!=x400);\n    if (t99 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "04c387bc69ea45f11abe30b99cd924e05ec74140", "ext": "c", "lang": "C", "content": "static void\nerror_test1(void)\n{\n\tvoid *env = sp_env();\n\tt( env != NULL );\n\tint rc = sp_error(env);\n\tt( rc == 0 );\n\tt( sp_destroy(env) == 0 );\n}", "item_id": 1, "repo": "clibs/sophia", "file": "test/generic/error.test.c", "last_update_at": "2021-12-07T05:25:36+00:00", "question_id": "04c387bc69ea45f11abe30b99cd924e05ec74140_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void\nerror_test1(void)\n{\n\tvoid *env = sp_env();\n\tt( env != NULL );\n\tint rc = sp_error(env);\n\tt( rc == 0 );\n\tt( sp_destroy(env) == 0 );\n"]]}
{"hexsha": "99d96e14d14b21486675ed674b1fadc86a4fa967", "ext": "c", "lang": "C", "content": "mat4 mat4Mul(mat4 *m0, mat4 *m1) // mat4 x mat4\n{\n\tmat4 r;\n\n\t// loops unrolled\n\n\t// row 0\n\tr.m[0][0] = m0->m[0][0] * m1->m[0][0]; // m0 row 0 dot m1 col 0\n\tr.m[0][0] += m0->m[0][1] * m1->m[1][0];\n\tr.m[0][0] += m0->m[0][2] * m1->m[2][0];\n\tr.m[0][0] += m0->m[0][3] * m1->m[3][0];\n\n\tr.m[0][1] = m0->m[0][0] * m1->m[0][1];\n\tr.m[0][1] += m0->m[0][1] * m1->m[1][1];\n\tr.m[0][1] += m0->m[0][2] * m1->m[2][1];\n\tr.m[0][1] += m0->m[0][3] * m1->m[3][1];\n\n\tr.m[0][2] = m0->m[0][0] * m1->m[0][2];\n\tr.m[0][2] += m0->m[0][1] * m1->m[1][2];\n\tr.m[0][2] += m0->m[0][2] * m1->m[2][2];\n\tr.m[0][2] += m0->m[0][3] * m1->m[3][2];\n\n\tr.m[0][3] = m0->m[0][0] * m1->m[0][3];\n\tr.m[0][3] += m0->m[0][1] * m1->m[1][3];\n\tr.m[0][3] += m0->m[0][2] * m1->m[2][3];\n\tr.m[0][3] += m0->m[0][3] * m1->m[3][3];\n\n\t// row 1\n\tr.m[1][0] = m0->m[1][0] * m1->m[0][0];\n\tr.m[1][0] += m0->m[1][1] * m1->m[1][0];\n\tr.m[1][0] += m0->m[1][2] * m1->m[2][0];\n\tr.m[1][0] += m0->m[1][3] * m1->m[3][0];\n\n\tr.m[1][1] = m0->m[1][0] * m1->m[0][1];\n\tr.m[1][1] += m0->m[1][1] * m1->m[1][1];\n\tr.m[1][1] += m0->m[1][2] * m1->m[2][1];\n\tr.m[1][1] += m0->m[1][3] * m1->m[3][1];\n\n\tr.m[1][2] = m0->m[1][0] * m1->m[0][2];\n\tr.m[1][2] += m0->m[1][1] * m1->m[1][2];\n\tr.m[1][2] += m0->m[1][2] * m1->m[2][2];\n\tr.m[1][2] += m0->m[1][3] * m1->m[3][2];\n\n\tr.m[1][3] = m0->m[1][0] * m1->m[0][3];\n\tr.m[1][3] += m0->m[1][1] * m1->m[1][3];\n\tr.m[1][3] += m0->m[1][2] * m1->m[2][3];\n\tr.m[1][3] += m0->m[1][3] * m1->m[3][3];\n\n\t// row 2\n\tr.m[2][0] = m0->m[2][0] * m1->m[0][0];\n\tr.m[2][0] += m0->m[2][1] * m1->m[1][0];\n\tr.m[2][0] += m0->m[2][2] * m1->m[2][0];\n\tr.m[2][0] += m0->m[2][3] * m1->m[3][0];\n\n\tr.m[2][1] = m0->m[2][0] * m1->m[0][1];\n\tr.m[2][1] += m0->m[2][1] * m1->m[1][1];\n\tr.m[2][1] += m0->m[2][2] * m1->m[2][1];\n\tr.m[2][1] += m0->m[2][3] * m1->m[3][1];\n\n\tr.m[2][2] = m0->m[2][0] * m1->m[0][2];\n\tr.m[2][2] += m0->m[2][1] * m1->m[1][2];\n\tr.m[2][2] += m0->m[2][2] * m1->m[2][2];\n\tr.m[2][2] += m0->m[2][3] * m1->m[3][2];\n\n\tr.m[2][3] = m0->m[2][0] * m1->m[0][3];\n\tr.m[2][3] += m0->m[2][1] * m1->m[1][3];\n\tr.m[2][3] += m0->m[2][2] * m1->m[2][3];\n\tr.m[2][3] += m0->m[2][3] * m1->m[3][3];\n\n\t// row 3\n\tr.m[3][0] = m0->m[3][0] * m1->m[0][0];\n\tr.m[3][0] += m0->m[3][1] * m1->m[1][0];\n\tr.m[3][0] += m0->m[3][2] * m1->m[2][0];\n\tr.m[3][0] += m0->m[3][3] * m1->m[3][0];\n\n\tr.m[3][1] = m0->m[3][0] * m1->m[0][1];\n\tr.m[3][1] += m0->m[3][1] * m1->m[1][1];\n\tr.m[3][1] += m0->m[3][2] * m1->m[2][1];\n\tr.m[3][1] += m0->m[3][3] * m1->m[3][1];\n\n\tr.m[3][2] = m0->m[3][0] * m1->m[0][2];\n\tr.m[3][2] += m0->m[3][1] * m1->m[1][2];\n\tr.m[3][2] += m0->m[3][2] * m1->m[2][2];\n\tr.m[3][2] += m0->m[3][3] * m1->m[3][2];\n\n\tr.m[3][3] = m0->m[3][0] * m1->m[0][3];\n\tr.m[3][3] += m0->m[3][1] * m1->m[1][3];\n\tr.m[3][3] += m0->m[3][2] * m1->m[2][3];\n\tr.m[3][3] += m0->m[3][3] * m1->m[3][3];\n\n\treturn r;\n}", "item_id": 30, "repo": "Roninkoi/Vortexy", "file": "src/util/mat.c", "last_update_at": "2021-11-11T00:25:45+00:00", "question_id": "99d96e14d14b21486675ed674b1fadc86a4fa967_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["mat4 mat4Mul(mat4 *m0, mat4 *m1) // mat4 x mat4\n{\n\tmat4 r;\n\t// loops unrolled\n\t// row 0\n\tr.m[0][0] = m0->m[0][0] * m1->m[0][0]; // m0 row 0 dot m1 col 0\n\tr.m[0][0] += m0->m[0][1] * m1->m[1][0];\n\tr.m[0][0] += m0->m[0][2] * m1->m[2][0];\n\tr.m[0][0] += m0->m[0][3] * m1->m[3][0];\n\tr.m[0][1] = m0->m[0][0] * m1->m[0][1];\n\tr.m[0][1] += m0->m[0][1] * m1->m[1][1];\n\tr.m[0][1] += m0->m[0][2] * m1->m[2][1];\n\tr.m[0][1] += m0->m[0][3] * m1->m[3][1];\n\tr.m[0][2] = m0->m[0][0] * m1->m[0][2];\n\tr.m[0][2] += m0->m[0][1] * m1->m[1][2];\n\tr.m[0][2] += m0->m[0][2] * m1->m[2][2];\n\tr.m[0][2] += m0->m[0][3] * m1->m[3][2];\n\tr.m[0][3] = m0->m[0][0] * m1->m[0][3];\n\tr.m[0][3] += m0->m[0][1] * m1->m[1][3];\n\tr.m[0][3] += m0->m[0][2] * m1->m[2][3];\n\tr.m[0][3] += m0->m[0][3] * m1->m[3][3];\n\t// row 1\n\tr.m[1][0] = m0->m[1][0] * m1->m[0][0];\n\tr.m[1][0] += m0->m[1][1] * m1->m[1][0];\n\tr.m[1][0] += m0->m[1][2] * m1->m[2][0];\n\tr.m[1][0] += m0->m[1][3] * m1->m[3][0];\n\tr.m[1][1] = m0->m[1][0] * m1->m[0][1];\n\tr.m[1][1] += m0->m[1][1] * m1->m[1][1];\n\tr.m[1][1] += m0->m[1][2] * m1->m[2][1];\n\tr.m[1][1] += m0->m[1][3] * m1->m[3][1];\n\tr.m[1][2] = m0->m[1][0] * m1->m[0][2];\n\tr.m[1][2] += m0->m[1][1] * m1->m[1][2];\n\tr.m[1][2] += m0->m[1][2] * m1->m[2][2];\n\tr.m[1][2] += m0->m[1][3] * m1->m[3][2];\n\tr.m[1][3] = m0->m[1][0] * m1->m[0][3];\n\tr.m[1][3] += m0->m[1][1] * m1->m[1][3];\n\tr.m[1][3] += m0->m[1][2] * m1->m[2][3];\n\tr.m[1][3] += m0->m[1][3] * m1->m[3][3];\n\t// row 2\n\tr.m[2][0] = m0->m[2][0] * m1->m[0][0];\n\tr.m[2][0] += m0->m[2][1] * m1->m[1][0];\n\tr.m[2][0] += m0->m[2][2] * m1->m[2][0];\n\tr.m[2][0] += m0->m[2][3] * m1->m[3][0];\n\tr.m[2][1] = m0->m[2][0] * m1->m[0][1];\n\tr.m[2][1] += m0->m[2][1] * m1->m[1][1];\n\tr.m[2][1] += m0->m[2][2] * m1->m[2][1];\n\tr.m[2][1] += m0->m[2][3] * m1->m[3][1];\n\tr.m[2][2] = m0->m[2][0] * m1->m[0][2];\n\tr.m[2][2] += m0->m[2][1] * m1->m[1][2];\n\tr.m[2][2] += m0->m[2][2] * m1->m[2][2];\n\tr.m[2][2] += m0->m[2][3] * m1->m[3][2];\n\tr.m[2][3] = m0->m[2][0] * m1->m[0][3];\n\tr.m[2][3] += m0->m[2][1] * m1->m[1][3];\n\tr.m[2][3] += m0->m[2][2] * m1->m[2][3];\n\tr.m[2][3] += m0->m[2][3] * m1->m[3][3];\n\t// row 3\n\tr.m[3][0] = m0->m[3][0] * m1->m[0][0];\n\tr.m[3][0] += m0->m[3][1] * m1->m[1][0];\n\tr.m[3][0] += m0->m[3][2] * m1->m[2][0];\n\tr.m[3][0] += m0->m[3][3] * m1->m[3][0];\n\tr.m[3][1] = m0->m[3][0] * m1->m[0][1];\n\tr.m[3][1] += m0->m[3][1] * m1->m[1][1];\n\tr.m[3][1] += m0->m[3][2] * m1->m[2][1];\n\tr.m[3][1] += m0->m[3][3] * m1->m[3][1];\n\tr.m[3][2] = m0->m[3][0] * m1->m[0][2];\n\tr.m[3][2] += m0->m[3][1] * m1->m[1][2];\n\tr.m[3][2] += m0->m[3][2] * m1->m[2][2];\n\tr.m[3][2] += m0->m[3][3] * m1->m[3][2];\n\tr.m[3][3] = m0->m[3][0] * m1->m[0][3];\n\tr.m[3][3] += m0->m[3][1] * m1->m[1][3];\n\tr.m[3][3] += m0->m[3][2] * m1->m[2][3];\n\tr.m[3][3] += m0->m[3][3] * m1->m[3][3];\n\treturn r;\n"]]}
{"hexsha": "c5814a405c20331531e44eee8d7eedfd7c5a0dc0", "ext": "c", "lang": "C", "content": "GST_START_TEST (test_default_vertex)\n{\n  GstGLSLStage *stage;\n  GError *error = NULL;\n\n  stage = gst_glsl_stage_new_default_vertex (context);\n  fail_unless (stage != NULL);\n  fail_unless (GL_VERTEX_SHADER == gst_glsl_stage_get_shader_type (stage));\n\n  fail_unless (gst_glsl_stage_compile (stage, &error));\n\n  gst_object_unref (stage);\n}", "item_id": 1, "repo": "isabella232/aistreams", "file": "third_party/gst-plugins-base/tests/check/libs/gstglslstage.c", "last_update_at": "2021-10-21T01:34:04+00:00", "question_id": "c5814a405c20331531e44eee8d7eedfd7c5a0dc0_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["GST_START_TEST (test_default_vertex)\n{\n  GstGLSLStage *stage;\n  GError *error = NULL;\n  stage = gst_glsl_stage_new_default_vertex (context);\n  fail_unless (stage != NULL);\n  fail_unless (GL_VERTEX_SHADER == gst_glsl_stage_get_shader_type (stage));\n  fail_unless (gst_glsl_stage_compile (stage, &error));\n  gst_object_unref (stage);\n"]]}
{"hexsha": "3036da0ca4b420c029bf83a29617a32a9fb17650", "ext": "c", "lang": "C", "content": "void f106(void) {\n    \tstatic int16_t x467 = -1;\n\tuint16_t x468 = 53U;\n\tvolatile int32_t t106 = 1;\n\n    t106 = ((x465+(x466/x467))>x468);\n\n    if (t106 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 106, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test597.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "3036da0ca4b420c029bf83a29617a32a9fb17650_106", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f106(void) {\n    \tstatic int16_t x467 = -1;\n\tuint16_t x468 = 53U;\n\tvolatile int32_t t106 = 1;\n    t106 = ((x465+(x466/x467))>x468);\n    if (t106 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "95196c93dfa00c3ab62982220cc8bcec84292d8f", "ext": "c", "lang": "C", "content": "void f11(void) {\n    \tstatic volatile uint64_t x45 = 749507480118404436LLU;\n\tuint32_t x46 = 11803U;\n\tstatic int32_t x47 = INT32_MAX;\n\tstatic int8_t x48 = -1;\n\tstatic volatile uint64_t t11 = 121323075143682LLU;\n\n    t11 = (x45^(x46!=(x47<=x48)));\n\n    if (t11 != 749507480118404437LLU) { NG(); } else { ; }\n\t\n}", "item_id": 11, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test1862.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "95196c93dfa00c3ab62982220cc8bcec84292d8f_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f11(void) {\n    \tstatic volatile uint64_t x45 = 749507480118404436LLU;\n\tuint32_t x46 = 11803U;\n\tstatic int32_t x47 = INT32_MAX;\n\tstatic int8_t x48 = -1;\n\tstatic volatile uint64_t t11 = 121323075143682LLU;\n    t11 = (x45^(x46!=(x47<=x48)));\n    if (t11 != 749507480118404437LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "4d1bc463ccc6349ae51c4105ffb8ece5f0a297fa", "ext": "c", "lang": "C", "content": "BOOLEAN\nQuicHashTableExpand(\n    _Inout_ QUIC_HASHTABLE* HashTable\n    )\n{\n    //\n    // Can't expand if we've reached the maximum.\n    //\n    if (HashTable->TableSize == MAX_HASH_TABLE_SIZE) {\n        return FALSE;\n    }\n\n    if (HashTable->NumEnumerators > 0) {\n        return FALSE;\n    }\n\n    QUIC_DBG_ASSERT(HashTable->TableSize < MAX_HASH_TABLE_SIZE);\n\n    //\n    // First see if increasing the table size will mean new allocations. After\n    // the hash table is increased by one, the highest bucket index will be the\n    // current table size, which is what we use in the calculations below\n    //\n    uint32_t FirstLevelIndex, SecondLevelIndex;\n    QuicComputeDirIndices(\n        HashTable->TableSize, &FirstLevelIndex, &SecondLevelIndex);\n\n    //\n    // Switch to the multi-dir mode in case of the only second-level directory\n    // is about to be expanded.\n    //\n\n    QUIC_LIST_ENTRY* SecondLevelDir;\n    QUIC_LIST_ENTRY** FirstLevelDir;\n    if (HT_SECOND_LEVEL_DIR_MIN_SIZE == HashTable->TableSize) {\n\n        SecondLevelDir = (QUIC_LIST_ENTRY*)HashTable->SecondLevelDir;\n        FirstLevelDir = QUIC_ALLOC_NONPAGED(sizeof(QUIC_LIST_ENTRY*) * HT_FIRST_LEVEL_DIR_SIZE);\n\n        if (FirstLevelDir == NULL) {\n            return FALSE;\n        }\n\n        QuicZeroMemory(FirstLevelDir,\n                      sizeof(QUIC_LIST_ENTRY*) * HT_FIRST_LEVEL_DIR_SIZE);\n\n        FirstLevelDir[0] = SecondLevelDir;\n\n        HashTable->FirstLevelDir = FirstLevelDir;\n    }\n\n    QUIC_DBG_ASSERT(HashTable->FirstLevelDir != NULL);\n    FirstLevelDir = HashTable->FirstLevelDir;\n    SecondLevelDir = FirstLevelDir[FirstLevelIndex];\n\n    if (SecondLevelDir == NULL) {\n\n        //\n        // Allocate second level directory.\n        //\n        SecondLevelDir =\n            QUIC_ALLOC_NONPAGED(\n                QuicComputeSecondLevelDirSize(FirstLevelIndex) * sizeof(QUIC_LIST_ENTRY));\n        if (NULL == SecondLevelDir) {\n\n            //\n            // If allocation failure happened on attempt to restructure the\n            // table, switch it back to direct mode.\n            //\n\n            if (HT_SECOND_LEVEL_DIR_MIN_SIZE == HashTable->TableSize) {\n\n                QUIC_DBG_ASSERT(FirstLevelIndex == 1);\n\n                HashTable->SecondLevelDir = FirstLevelDir[0];\n                QUIC_FREE(FirstLevelDir);\n            }\n\n            return FALSE;\n        }\n\n        FirstLevelDir[FirstLevelIndex] = SecondLevelDir;\n    }\n\n    HashTable->TableSize++;\n\n    //\n    // The allocations are out of the way. Now actually increase\n    // the Table size and split the pivot bucket.\n    //\n    QUIC_LIST_ENTRY* ChainToBeSplit =\n        QuicGetChainHead(HashTable, HashTable->Pivot);\n    HashTable->Pivot++;\n\n    QUIC_LIST_ENTRY* NewChain = &(SecondLevelDir[SecondLevelIndex]);\n    QuicListInitializeHead(NewChain);\n\n    if (!QuicListIsEmpty(ChainToBeSplit)) {\n\n        QUIC_LIST_ENTRY* CurEntry = ChainToBeSplit;\n        while (CurEntry->Flink != ChainToBeSplit) {\n\n            QUIC_LIST_ENTRY* NextEntry = CurEntry->Flink;\n            QUIC_HASHTABLE_ENTRY* NextHashEntry =\n                QuicFlinkToHashEntry(&NextEntry->Flink);\n\n            uint32_t BucketIndex =\n                ((uint32_t)NextHashEntry->Signature) &\n                ((HashTable->DivisorMask << 1) | 1);\n\n            QUIC_DBG_ASSERT((BucketIndex == (HashTable->Pivot - 1)) ||\n                   (BucketIndex == (HashTable->TableSize - 1)));\n\n            if (BucketIndex == (HashTable->TableSize - 1)) {\n                QuicListEntryRemove(NextEntry);\n                QuicListInsertTail(NewChain, NextEntry);\n                continue;\n            }\n\n            //\n            // If the NextEntry falls in the same bucket, move on.\n            //\n            CurEntry = NextEntry;\n        }\n\n        if (!QuicListIsEmpty(NewChain)) {\n            HashTable->NonEmptyBuckets++;\n        }\n\n        if (QuicListIsEmpty(ChainToBeSplit)) {\n            QUIC_DBG_ASSERT(HashTable->NonEmptyBuckets > 0);\n            HashTable->NonEmptyBuckets--;\n        }\n    }\n\n    if (HashTable->Pivot == (HashTable->DivisorMask + 1)) {\n        HashTable->DivisorMask = (HashTable->DivisorMask << 1) | 1;\n        HashTable->Pivot = 0;\n\n        //\n        // Assert that at this point, TableSize is a power of 2.\n        //\n        QUIC_DBG_ASSERT(0 == (HashTable->TableSize & (HashTable->TableSize - 1)));\n    }\n\n    return TRUE;\n}", "item_id": 13, "repo": "hnyunzhiyi/ymsquic", "file": "src/platform/hashtable.c", "last_update_at": "2021-08-18T19:00:41+00:00", "question_id": "4d1bc463ccc6349ae51c4105ffb8ece5f0a297fa_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["BOOLEAN\nQuicHashTableExpand(\n    _Inout_ QUIC_HASHTABLE* HashTable\n    )\n{\n    //\n    // Can't expand if we've reached the maximum.\n    //\n    if (HashTable->TableSize == MAX_HASH_TABLE_SIZE) {\n        return FALSE;\n    }\n    if (HashTable->NumEnumerators > 0) {\n        return FALSE;\n    }\n    QUIC_DBG_ASSERT(HashTable->TableSize < MAX_HASH_TABLE_SIZE);\n    //\n    // First see if increasing the table size will mean new allocations. After\n    // the hash table is increased by one, the highest bucket index will be the\n    // current table size, which is what we use in the calculations below\n    //\n    uint32_t FirstLevelIndex, SecondLevelIndex;\n    QuicComputeDirIndices(\n        HashTable->TableSize, &FirstLevelIndex, &SecondLevelIndex);\n    //\n    // Switch to the multi-dir mode in case of the only second-level directory\n    // is about to be expanded.\n    //\n    QUIC_LIST_ENTRY* SecondLevelDir;\n    QUIC_LIST_ENTRY** FirstLevelDir;\n    if (HT_SECOND_LEVEL_DIR_MIN_SIZE == HashTable->TableSize) {\n        SecondLevelDir = (QUIC_LIST_ENTRY*)HashTable->SecondLevelDir;\n        FirstLevelDir = QUIC_ALLOC_NONPAGED(sizeof(QUIC_LIST_ENTRY*) * HT_FIRST_LEVEL_DIR_SIZE);\n        if (FirstLevelDir == NULL) {\n            return FALSE;\n        }\n        QuicZeroMemory(FirstLevelDir,\n                      sizeof(QUIC_LIST_ENTRY*) * HT_FIRST_LEVEL_DIR_SIZE);\n        FirstLevelDir[0] = SecondLevelDir;\n        HashTable->FirstLevelDir = FirstLevelDir;\n    }\n    QUIC_DBG_ASSERT(HashTable->FirstLevelDir != NULL);\n    FirstLevelDir = HashTable->FirstLevelDir;\n    SecondLevelDir = FirstLevelDir[FirstLevelIndex];\n    if (SecondLevelDir == NULL) {\n        //\n        // Allocate second level directory.\n        //\n        SecondLevelDir =\n            QUIC_ALLOC_NONPAGED(\n                QuicComputeSecondLevelDirSize(FirstLevelIndex) * sizeof(QUIC_LIST_ENTRY));\n        if (NULL == SecondLevelDir) {\n            //\n            // If allocation failure happened on attempt to restructure the\n            // table, switch it back to direct mode.\n            //\n            if (HT_SECOND_LEVEL_DIR_MIN_SIZE == HashTable->TableSize) {\n                QUIC_DBG_ASSERT(FirstLevelIndex == 1);\n                HashTable->SecondLevelDir = FirstLevelDir[0];\n                QUIC_FREE(FirstLevelDir);\n            }\n            return FALSE;\n        }\n        FirstLevelDir[FirstLevelIndex] = SecondLevelDir;\n    }\n    HashTable->TableSize++;\n    //\n    // The allocations are out of the way. Now actually increase\n    // the Table size and split the pivot bucket.\n    //\n    QUIC_LIST_ENTRY* ChainToBeSplit =\n        QuicGetChainHead(HashTable, HashTable->Pivot);\n    HashTable->Pivot++;\n    QUIC_LIST_ENTRY* NewChain = &(SecondLevelDir[SecondLevelIndex]);\n    QuicListInitializeHead(NewChain);\n    if (!QuicListIsEmpty(ChainToBeSplit)) {\n        QUIC_LIST_ENTRY* CurEntry = ChainToBeSplit;\n        while (CurEntry->Flink != ChainToBeSplit) {\n            QUIC_LIST_ENTRY* NextEntry = CurEntry->Flink;\n            QUIC_HASHTABLE_ENTRY* NextHashEntry =\n                QuicFlinkToHashEntry(&NextEntry->Flink);\n            uint32_t BucketIndex =\n                ((uint32_t)NextHashEntry->Signature) &\n                ((HashTable->DivisorMask << 1) | 1);\n            QUIC_DBG_ASSERT((BucketIndex == (HashTable->Pivot - 1)) ||\n                   (BucketIndex == (HashTable->TableSize - 1)));\n            if (BucketIndex == (HashTable->TableSize - 1)) {\n                QuicListEntryRemove(NextEntry);\n                QuicListInsertTail(NewChain, NextEntry);\n                continue;\n            }\n            //\n            // If the NextEntry falls in the same bucket, move on.\n            //\n            CurEntry = NextEntry;\n        }\n        if (!QuicListIsEmpty(NewChain)) {\n            HashTable->NonEmptyBuckets++;\n        }\n        if (QuicListIsEmpty(ChainToBeSplit)) {\n            QUIC_DBG_ASSERT(HashTable->NonEmptyBuckets > 0);\n            HashTable->NonEmptyBuckets--;\n        }\n    }\n    if (HashTable->Pivot == (HashTable->DivisorMask + 1)) {\n        HashTable->DivisorMask = (HashTable->DivisorMask << 1) | 1;\n        HashTable->Pivot = 0;\n        //\n        // Assert that at this point, TableSize is a power of 2.\n        //\n        QUIC_DBG_ASSERT(0 == (HashTable->TableSize & (HashTable->TableSize - 1)));\n    }\n    return TRUE;\n"]]}
{"hexsha": "06b5402a2847254100fb1e1f103ec6702850f597", "ext": "c", "lang": "C", "content": "void cat9554_vddpix_en(fmc_iic_t *pInstance) {\n\tu8 status = 0;\n\n\tif ( !cat9554_iic_address )\t{ cat9554_detect(pInstance); }\n\n\tpInstance->fpIicRead( pInstance, cat9554_iic_address, 0x01, &status, 1);\n\tstatus |= 0x04;\n\tpInstance->fpIicWrite( pInstance, cat9554_iic_address, 0x01, &status, 1);\n\n}", "item_id": 6, "repo": "alexvonduar/fpga_embedded_vision", "file": "avnet/Projects/fmchc_python1300c/software/fmchc_python1300c_app/src/cat9554.c", "last_update_at": "2021-05-12T21:10:06+00:00", "question_id": "06b5402a2847254100fb1e1f103ec6702850f597_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void cat9554_vddpix_en(fmc_iic_t *pInstance) {\n\tu8 status = 0;\n\tif ( !cat9554_iic_address )\t{ cat9554_detect(pInstance); }\n\tpInstance->fpIicRead( pInstance, cat9554_iic_address, 0x01, &status, 1);\n\tstatus |= 0x04;\n\tpInstance->fpIicWrite( pInstance, cat9554_iic_address, 0x01, &status, 1);\n"]]}
{"hexsha": "667c848332fcec8dbe3b9492aebabd5d206d24cd", "ext": "c", "lang": "C", "content": "void f70(void) {\n    \tint8_t x281 = INT8_MAX;\n\tvolatile int64_t x282 = -1LL;\n\tint8_t x283 = INT8_MIN;\n\tuint64_t x284 = 10282204213LLU;\n\n    t70 = (((x281&x282)>x283)!=x284);\n\n    if (t70 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 70, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test2275.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "667c848332fcec8dbe3b9492aebabd5d206d24cd_70", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f70(void) {\n    \tint8_t x281 = INT8_MAX;\n\tvolatile int64_t x282 = -1LL;\n\tint8_t x283 = INT8_MIN;\n\tuint64_t x284 = 10282204213LLU;\n    t70 = (((x281&x282)>x283)!=x284);\n    if (t70 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "69273b5eb71da5ae2bc863b6cab123805a2d274a", "ext": "c", "lang": "C", "content": "void\ncairo_surface_set_device_scale (cairo_surface_t *surface,\n\t\t\t\tdouble\t\t x_scale,\n\t\t\t\tdouble\t\t y_scale)\n{\n    cairo_status_t status;\n\n    if (unlikely (surface->status))\n\treturn;\n\n    assert (surface->snapshot_of == NULL);\n\n    if (unlikely (surface->finished)) {\n\t_cairo_surface_set_error (surface, _cairo_error (CAIRO_STATUS_SURFACE_FINISHED));\n\treturn;\n    }\n\n    status = _cairo_surface_begin_modification (surface);\n    if (unlikely (status)) {\n\t_cairo_surface_set_error (surface, status);\n\treturn;\n    }\n\n    surface->device_transform.xx = x_scale;\n    surface->device_transform.yy = y_scale;\n    surface->device_transform.xy = 0.0;\n    surface->device_transform.yx = 0.0;\n\n    surface->device_transform_inverse = surface->device_transform;\n    status = cairo_matrix_invert (&surface->device_transform_inverse);\n    /* should always be invertible unless given pathological input */\n    assert (status == CAIRO_STATUS_SUCCESS);\n\n    _cairo_observers_notify (&surface->device_transform_observers, surface);\n}", "item_id": 12, "repo": "coolbutuseless/cairocore", "file": "data-raw/cairo/cairo-surface.c", "last_update_at": "2021-11-15T11:22:45+00:00", "question_id": "69273b5eb71da5ae2bc863b6cab123805a2d274a_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\ncairo_surface_set_device_scale (cairo_surface_t *surface,\n\t\t\t\tdouble\t\t x_scale,\n\t\t\t\tdouble\t\t y_scale)\n{\n    cairo_status_t status;\n    if (unlikely (surface->status))\n\treturn;\n    assert (surface->snapshot_of == NULL);\n    if (unlikely (surface->finished)) {\n\t_cairo_surface_set_error (surface, _cairo_error (CAIRO_STATUS_SURFACE_FINISHED));\n\treturn;\n    }\n    status = _cairo_surface_begin_modification (surface);\n    if (unlikely (status)) {\n\t_cairo_surface_set_error (surface, status);\n\treturn;\n    }\n    surface->device_transform.xx = x_scale;\n    surface->device_transform.yy = y_scale;\n    surface->device_transform.xy = 0.0;\n    surface->device_transform.yx = 0.0;\n    surface->device_transform_inverse = surface->device_transform;\n    status = cairo_matrix_invert (&surface->device_transform_inverse);\n    /* should always be invertible unless given pathological input */\n    assert (status == CAIRO_STATUS_SUCCESS);\n    _cairo_observers_notify (&surface->device_transform_observers, surface);\n"]]}
{"hexsha": "3769732de566494ff755e7a7c10d62f1bcccf46a", "ext": "c", "lang": "C", "content": "static void update_crc(unsigned short *crc, unsigned char ch)\n{\n\tunsigned char v;\n\tunsigned int i;\n\tunsigned short flag;\n\n\tv = 1;\n\tfor (i = 0; i < 8; i++) {\n\t\tflag = (*crc & 0x8000);\n\t\t*crc = *crc << 1;\n\n\t\tif (ch & v)\n\t\t\t*crc = *crc + 1;\n\n\t\tif (flag != 0)\n\t\t\t*crc = *crc ^ POLY;\n\n\t\tv = v << 1;\n\t}\n}", "item_id": 0, "repo": "bluetailtech/BTConfig", "file": "decoders/acars/acars_getmesg.c", "last_update_at": "2021-03-30T16:51:00+00:00", "question_id": "3769732de566494ff755e7a7c10d62f1bcccf46a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void update_crc(unsigned short *crc, unsigned char ch)\n{\n\tunsigned char v;\n\tunsigned int i;\n\tunsigned short flag;\n\tv = 1;\n\tfor (i = 0; i < 8; i++) {\n\t\tflag = (*crc & 0x8000);\n\t\t*crc = *crc << 1;\n\t\tif (ch & v)\n\t\t\t*crc = *crc + 1;\n\t\tif (flag != 0)\n\t\t\t*crc = *crc ^ POLY;\n\t\tv = v << 1;\n\t}\n"]]}
{"hexsha": "5e3f7f09e6e992c0991336c7567b26287abe86ca", "ext": "c", "lang": "C", "content": "void max_rez (vec_p dst_v, vec_p src_v, vec_p segd_v, int nelts,\n\t       int nsegs, vec_p scratch_v)\n{\n  int *dst, *src;\n  int *segd, *segment;\n  int accum;\n  int nelts_here, nsegs_here, current_seg, i;\n\n  LOG_START (max_rez, nelts);\n  nelts_here = _num_here (nelts);\n  dst = (int *) (Mem + dst_v);\n  src = (int *) (Mem + src_v);\n\n  if (nsegs == 1) {\n    accum = INT_MIN;\n    for (i = 0; i < nelts_here; i++) {\n      accum = max (accum, src[i]);\n    }\n    MPI_Reduce (&accum, &dst[0], 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  } else {\n    /* Initialize destination vector (segment reductions) to identity */\n    nsegs_here = _num_here (nsegs);\n    segd = (int *) (Mem + segd_v);\n    segment = SegdSegment (segd, nelts, nsegs);\n    for (i = 0; i < nsegs_here; i++) {\n      dst[i] = INT_MIN;\n    }\n\n    /* Initialize an accumulator for the section of segment we have\n     * seen so far, and the number of that segment */\n    accum = INT_MIN;\n    current_seg = 0;\n    /* Iterate over the segmented source vector */\n    {\n      /* Normally, update accum with src[x].  If we hit a segment\n       * boundary, send accum to the processor/offset pair that should\n       * hold the reduction of the current segment, and combine it with\n       * whatever is there using OP.  If accum is the identity, do not\n       * bother: this saves time, and handles the special case of the\n       * first element on each processor. */\n      int n_sent = 0, n_rcvd = 0;\n      int space = SpaceFor (nsegs);\n      int x, y, loopbound;\n\n      for (y = 0; y < nelts_here; y += RCV_EVERY) {\n\tloopbound = min (nelts_here, y + RCV_EVERY);\n\tfor (x = y; x < loopbound; x++) {\n\t  if (segment[x] == current_seg) {\n\t    accum = max (accum, src[x]);\n\t  } else {\n\t    if (accum != INT_MIN) {\n\t      int proc = current_seg / space;\n\t      int offset = current_seg - (proc * space);\n\n\t      if (proc == Self) {\n\t\tdst[offset] = max (dst[offset], accum);\n\t      } else {\n\t\tint posn = Send_ctr[proc]++;\n\t\tintx *buf = (intx *) Usr_send[proc];\n\n\t\tbuf[posn].value = accum;\n\t\tbuf[posn].index = offset;\n\t      }\n\t    }\n\t    accum = src[x];\n\t    current_seg = segment[x];\n\t  }\n\t}\n\tn_rcvd += _recv_simple (dst, max_rez_tag, _unpack_max_intx);\n\tfor (x = 0; x < NumProcs; x++) {\n\t  if (Send_ctr[x] >= ((BUF_SIZE / sizeof (intx)) - RCV_EVERY)) {\n\t    _send_buffer (x, max_rez_tag, (Send_ctr[x] * sizeof (intx)));\n\t    n_sent++;\n\t  }\n\t}\n      }\n\n      /* Send out the final result from each processor */\n      if (accum != INT_MIN) {\n\tint proc = current_seg / space;\n\tint offset = current_seg - (proc * space);\n\n\tif (proc == Self) {\n\t  dst[offset] = max (dst[offset], accum);\n\t} else {\n\t  int posn = Send_ctr[proc]++;\n\t  intx *buf = (intx *) Usr_send[proc];\n\n\t  buf[posn].value = accum;\n\t  buf[posn].index = offset;\n\t}\n      }\n      _finish_simple (dst, max_rez_tag, n_sent, n_rcvd,\n\t\t      sizeof (intx), _unpack_max_intx);\n    }\n  }\n  LOG_STOP (max_rez, nelts);\n}", "item_id": 16, "repo": "gblelloch/nesl", "file": "nesl/cvl/mpi/reduce.c", "last_update_at": "2021-02-05T01:02:06+00:00", "question_id": "5e3f7f09e6e992c0991336c7567b26287abe86ca_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void max_rez (vec_p dst_v, vec_p src_v, vec_p segd_v, int nelts,\n\t       int nsegs, vec_p scratch_v)\n{\n  int *dst, *src;\n  int *segd, *segment;\n  int accum;\n  int nelts_here, nsegs_here, current_seg, i;\n  LOG_START (max_rez, nelts);\n  nelts_here = _num_here (nelts);\n  dst = (int *) (Mem + dst_v);\n  src = (int *) (Mem + src_v);\n  if (nsegs == 1) {\n    accum = INT_MIN;\n    for (i = 0; i < nelts_here; i++) {\n      accum = max (accum, src[i]);\n    }\n    MPI_Reduce (&accum, &dst[0], 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);\n  } else {\n    /* Initialize destination vector (segment reductions) to identity */\n    nsegs_here = _num_here (nsegs);\n    segd = (int *) (Mem + segd_v);\n    segment = SegdSegment (segd, nelts, nsegs);\n    for (i = 0; i < nsegs_here; i++) {\n      dst[i] = INT_MIN;\n    }\n    /* Initialize an accumulator for the section of segment we have\n     * seen so far, and the number of that segment */\n    accum = INT_MIN;\n    current_seg = 0;\n    /* Iterate over the segmented source vector */\n    {\n      /* Normally, update accum with src[x].  If we hit a segment\n       * boundary, send accum to the processor/offset pair that should\n       * hold the reduction of the current segment, and combine it with\n       * whatever is there using OP.  If accum is the identity, do not\n       * bother: this saves time, and handles the special case of the\n       * first element on each processor. */\n      int n_sent = 0, n_rcvd = 0;\n      int space = SpaceFor (nsegs);\n      int x, y, loopbound;\n      for (y = 0; y < nelts_here; y += RCV_EVERY) {\n\tloopbound = min (nelts_here, y + RCV_EVERY);\n\tfor (x = y; x < loopbound; x++) {\n\t  if (segment[x] == current_seg) {\n\t    accum = max (accum, src[x]);\n\t  } else {\n\t    if (accum != INT_MIN) {\n\t      int proc = current_seg / space;\n\t      int offset = current_seg - (proc * space);\n\t      if (proc == Self) {\n\t\tdst[offset] = max (dst[offset], accum);\n\t      } else {\n\t\tint posn = Send_ctr[proc]++;\n\t\tintx *buf = (intx *) Usr_send[proc];\n\t\tbuf[posn].value = accum;\n\t\tbuf[posn].index = offset;\n\t      }\n\t    }\n\t    accum = src[x];\n\t    current_seg = segment[x];\n\t  }\n\t}\n\tn_rcvd += _recv_simple (dst, max_rez_tag, _unpack_max_intx);\n\tfor (x = 0; x < NumProcs; x++) {\n\t  if (Send_ctr[x] >= ((BUF_SIZE / sizeof (intx)) - RCV_EVERY)) {\n\t    _send_buffer (x, max_rez_tag, (Send_ctr[x] * sizeof (intx)));\n\t    n_sent++;\n\t  }\n\t}\n      }\n      /* Send out the final result from each processor */\n      if (accum != INT_MIN) {\n\tint proc = current_seg / space;\n\tint offset = current_seg - (proc * space);\n\tif (proc == Self) {\n\t  dst[offset] = max (dst[offset], accum);\n\t} else {\n\t  int posn = Send_ctr[proc]++;\n\t  intx *buf = (intx *) Usr_send[proc];\n\t  buf[posn].value = accum;\n\t  buf[posn].index = offset;\n\t}\n      }\n      _finish_simple (dst, max_rez_tag, n_sent, n_rcvd,\n\t\t      sizeof (intx), _unpack_max_intx);\n    }\n  }\n  LOG_STOP (max_rez, nelts);\n"]]}
{"hexsha": "b8c4244af7bfcdb44dc37b8e4eaa4972b177f904", "ext": "c", "lang": "C", "content": "void f110(void) {\n    \tvolatile uint8_t x442 = UINT8_MAX;\n\tint16_t x443 = -1;\n\tint32_t x444 = INT32_MAX;\n\tuint64_t t110 = 17514639058404LLU;\n\n    t110 = ((x441|x442)|(x443==x444));\n\n    if (t110 != 493039916173690111LLU) { NG(); } else { ; }\n\t\n}", "item_id": 110, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1553.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "b8c4244af7bfcdb44dc37b8e4eaa4972b177f904_110", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f110(void) {\n    \tvolatile uint8_t x442 = UINT8_MAX;\n\tint16_t x443 = -1;\n\tint32_t x444 = INT32_MAX;\n\tuint64_t t110 = 17514639058404LLU;\n    t110 = ((x441|x442)|(x443==x444));\n    if (t110 != 493039916173690111LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "6ead483290db2422dd12b640cf484c57243731e6", "ext": "c", "lang": "C", "content": "static int\n_tool_body(pri *proci, dident *pdid, int *parity, dident *pmodule)\n{\n    pri\t\t*procb;\n    int\t\tflags;\n    vmcode\t*code;\n\n    flags = proci->flags;\n    code = proci->code.vmc;\n\n    if (!(flags & CODE_DEFINED))\n    {\n\tif (flags & AUTOLOAD)\n\t    { Set_Bip_Error(NOT_LOADED); }\n\telse\n\t    { Set_Bip_Error(NOENTRY); }\n\treturn 0;\n    }\n    if (!(flags & TOOL))\n    {\n\tSet_Bip_Error(NO_TOOL);\n\treturn 0;\n    }\n    if (PriCodeType(proci) == VMCODE)\n    {\n\tif (DebugProc(proci))\n\t    procb = (pri *) *(code + DEBUG_LENGTH + 1);\n\telse\n\t    procb = (pri *) *(code + 1);\n\t*pdid = procb->did;\n\t*parity = DidArity(procb->did);\n\t*pmodule = procb->module_def;\n    }\n    else /* don't know how to get the tool body */\n    {\n\tSet_Bip_Error(NO_TOOL);\n\treturn 0;\n    }\n    return 1;\n}", "item_id": 1, "repo": "mslovy/barrelfish", "file": "usr/skb/eclipse_kernel/src/bip_module.c", "last_update_at": "2021-12-26T23:04:47+00:00", "question_id": "6ead483290db2422dd12b640cf484c57243731e6_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\n_tool_body(pri *proci, dident *pdid, int *parity, dident *pmodule)\n{\n    pri\t\t*procb;\n    int\t\tflags;\n    vmcode\t*code;\n    flags = proci->flags;\n    code = proci->code.vmc;\n    if (!(flags & CODE_DEFINED))\n    {\n\tif (flags & AUTOLOAD)\n\t    { Set_Bip_Error(NOT_LOADED); }\n\telse\n\t    { Set_Bip_Error(NOENTRY); }\n\treturn 0;\n    }\n    if (!(flags & TOOL))\n    {\n\tSet_Bip_Error(NO_TOOL);\n\treturn 0;\n    }\n    if (PriCodeType(proci) == VMCODE)\n    {\n\tif (DebugProc(proci))\n\t    procb = (pri *) *(code + DEBUG_LENGTH + 1);\n\telse\n\t    procb = (pri *) *(code + 1);\n\t*pdid = procb->did;\n\t*parity = DidArity(procb->did);\n\t*pmodule = procb->module_def;\n    }\n    else /* don't know how to get the tool body */\n    {\n\tSet_Bip_Error(NO_TOOL);\n\treturn 0;\n    }\n    return 1;\n"]]}
{"hexsha": "a102ecc7b281740e157675d9d8e2c88401bbb648", "ext": "c", "lang": "C", "content": "N_LIB_PRIVATE N_NIMCALL(NIM_BOOL, modeIsDir__L1LOhUxShkaoXfurkKTXPA)(mode_t m) {\n\tNIM_BOOL result;\n\tresult = (NIM_BOOL)0;\n\tresult = ((NI32)(m & ((NI32) 61440)) == ((NI32) 16384));\n\treturn result;\n}", "item_id": 3, "repo": "juancarlospaco/nim4py", "file": "dist/lin/stdlib_io.nim.c", "last_update_at": "2021-12-21T09:01:45+00:00", "question_id": "a102ecc7b281740e157675d9d8e2c88401bbb648_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["N_LIB_PRIVATE N_NIMCALL(NIM_BOOL, modeIsDir__L1LOhUxShkaoXfurkKTXPA)(mode_t m) {\n\tNIM_BOOL result;\n\tresult = (NIM_BOOL)0;\n\tresult = ((NI32)(m & ((NI32) 61440)) == ((NI32) 16384));\n\treturn result;\n"]]}
{"hexsha": "3f8db5415c0c625f2df0150f66ba9b2df8f1884e", "ext": "c", "lang": "C", "content": "struct Mat_t Mat_transl(const double x, const double y, const double z) {\n\tstruct Mat_t matTemp;\n\tMat_SetEye(&matTemp);\n\tMat_SetPos(&matTemp, x, y, z);\n\treturn matTemp;\n}", "item_id": 93, "repo": "OxideDevX/RoboDK-API", "file": "C/RoboDK C API/RoboDK_C_API/robodk_api_c.c", "last_update_at": "2021-04-07T09:33:48+00:00", "question_id": "3f8db5415c0c625f2df0150f66ba9b2df8f1884e_93", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct Mat_t Mat_transl(const double x, const double y, const double z) {\n\tstruct Mat_t matTemp;\n\tMat_SetEye(&matTemp);\n\tMat_SetPos(&matTemp, x, y, z);\n\treturn matTemp;\n"]]}
{"hexsha": "a849a5bb14f09673817badc76f73d10acac97793", "ext": "c", "lang": "C", "content": "int get_VmRSS()\n{\n    char procinfo_buf[255];\n    char *l;\n    int rss = -1;\n\n    rewind(procinfo_fh);\n\n    while ((l = fgets(procinfo_buf, 254, procinfo_fh)) != NULL) {\n\tif (strstr(l, \"VmRSS:\") != NULL) {\n\t    l[16] = '\\0';\n\t    l += 8;\n\t    rss = atoi(l);\n\t}\n    }\n\n    return rss;\n}", "item_id": 0, "repo": "RWTH-OS/MP-MPICH", "file": "examples/test/resources/isendirecv.c", "last_update_at": "2021-01-23T11:01:01+00:00", "question_id": "a849a5bb14f09673817badc76f73d10acac97793_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int get_VmRSS()\n{\n    char procinfo_buf[255];\n    char *l;\n    int rss = -1;\n    rewind(procinfo_fh);\n    while ((l = fgets(procinfo_buf, 254, procinfo_fh)) != NULL) {\n\tif (strstr(l, \"VmRSS:\") != NULL) {\n\t    l[16] = '\\0';\n\t    l += 8;\n\t    rss = atoi(l);\n\t}\n    }\n    return rss;\n"]]}
{"hexsha": "82b71c98128e90496f7ee5ec0b99d98b1974f43c", "ext": "c", "lang": "C", "content": "int\ngx_pattern_cache_add_entry(gs_state *pgs, gx_device_pattern_accum *padev,\n  gx_color_tile **pctile)\n{\tconst gx_device_memory *mbits = padev->bits;\n\tconst gx_device_memory *mmask = padev->mask;\n\tconst gs_pattern_instance *pinst = padev->instance;\n\tgx_pattern_cache *pcache;\n\tulong used = 0;\n\tgx_bitmap_id id = pinst->id;\n\tgx_color_tile *ctile;\n\tint code = ensure_pattern_cache(pgs);\n\tif ( code < 0 )\n\t  return code;\n\tpcache = pgs->pattern_cache;\n\t/*\n\t * Check whether the pattern completely fills its box.\n\t * If so, we can avoid the expensive masking operations\n\t * when using the pattern.\n\t */\n\t{\tint y;\n\t\tfor ( y = 0; y < mmask->height; y++ )\n\t\t  { const byte *row = scan_line_base(mmask, y);\n\t\t    int w;\n\t\t    for ( w = mmask->width; w > 8; w -= 8 )\n\t\t      if ( *row++ != 0xff )\n\t\t\tgoto keep;\n\t\t    if ( (*row | (0xff >> w)) != 0xff )\n\t\t      goto keep;\n\t\t  }\n\t\t/* We don't need a mask. */\n\t\tmmask = 0;\nkeep:\t\t;\n\t}\n\tif ( mbits != 0 )\n\t  used += gdev_mem_bitmap_size(mbits);\n\tif ( mmask != 0 )\n\t  used += gdev_mem_bitmap_size(mmask);\n\tctile = &pcache->tiles[id % pcache->num_tiles];\n\tgx_pattern_cache_free_entry(pcache, ctile);\n\twhile ( pcache->bits_used + used > pcache->max_bits &&\n\t\tpcache->bits_used != 0\t /* allow 1 oversized entry (?) */\n\t      )\n\t  { pcache->next = (pcache->next + 1) % pcache->num_tiles;\n\t    gx_pattern_cache_free_entry(pcache, &pcache->tiles[pcache->next]);\n\t  }\n\tctile->id = id;\n\tctile->depth = padev->color_info.depth;\n\tctile->tiling_type = pinst->template.TilingType;\n\tctile->xstep = pinst->xstep;\n\tctile->ystep = pinst->ystep;\n\tif ( mbits != 0 )\n\t  make_bitmap(&ctile->bits, mbits, gs_next_ids(1));\n\telse\n\t  ctile->bits.data = 0;\n\tif ( mmask != 0 )\n\t  make_bitmap(&ctile->mask, mmask, id);\n\telse\n\t  ctile->mask.data = 0;\n\tctile->is_simple = (ctile->xstep.x == int2fixed(pinst->size.x) &&\n\t\t\t    ctile->xstep.y == 0 &&\n\t\t\t    ctile->ystep.x == 0 &&\n\t\t\t    ctile->ystep.y == int2fixed(pinst->size.y));\n\tif_debug6('t',\n\t\t  \"[t]is_simple? xstep=(%g,%g) ystep=(%g,%g) size=(%d,%d)\\n\",\n\t\t  fixed2float(ctile->xstep.x), fixed2float(ctile->xstep.y),\n\t\t  fixed2float(ctile->ystep.x), fixed2float(ctile->ystep.y),\n\t\t  pinst->size.x, pinst->size.y);\n\tpcache->bits_used += used;\n\t*pctile = ctile;\n\treturn 0;\n}", "item_id": 5, "repo": "Plan9-Archive/plan9-2e", "file": "sys/src/cmd/gs/gxpcmap.c", "last_update_at": "2021-03-23T22:40:43+00:00", "question_id": "82b71c98128e90496f7ee5ec0b99d98b1974f43c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\ngx_pattern_cache_add_entry(gs_state *pgs, gx_device_pattern_accum *padev,\n  gx_color_tile **pctile)\n{\tconst gx_device_memory *mbits = padev->bits;\n\tconst gx_device_memory *mmask = padev->mask;\n\tconst gs_pattern_instance *pinst = padev->instance;\n\tgx_pattern_cache *pcache;\n\tulong used = 0;\n\tgx_bitmap_id id = pinst->id;\n\tgx_color_tile *ctile;\n\tint code = ensure_pattern_cache(pgs);\n\tif ( code < 0 )\n\t  return code;\n\tpcache = pgs->pattern_cache;\n\t/*\n\t * Check whether the pattern completely fills its box.\n\t * If so, we can avoid the expensive masking operations\n\t * when using the pattern.\n\t */\n\t{\tint y;\n\t\tfor ( y = 0; y < mmask->height; y++ )\n\t\t  { const byte *row = scan_line_base(mmask, y);\n\t\t    int w;\n\t\t    for ( w = mmask->width; w > 8; w -= 8 )\n\t\t      if ( *row++ != 0xff )\n\t\t\tgoto keep;\n\t\t    if ( (*row | (0xff >> w)) != 0xff )\n\t\t      goto keep;\n\t\t  }\n\t\t/* We don't need a mask. */\n\t\tmmask = 0;\nkeep:\t\t;\n\t}\n\tif ( mbits != 0 )\n\t  used += gdev_mem_bitmap_size(mbits);\n\tif ( mmask != 0 )\n\t  used += gdev_mem_bitmap_size(mmask);\n\tctile = &pcache->tiles[id % pcache->num_tiles];\n\tgx_pattern_cache_free_entry(pcache, ctile);\n\twhile ( pcache->bits_used + used > pcache->max_bits &&\n\t\tpcache->bits_used != 0\t /* allow 1 oversized entry (?) */\n\t      )\n\t  { pcache->next = (pcache->next + 1) % pcache->num_tiles;\n\t    gx_pattern_cache_free_entry(pcache, &pcache->tiles[pcache->next]);\n\t  }\n\tctile->id = id;\n\tctile->depth = padev->color_info.depth;\n\tctile->tiling_type = pinst->template.TilingType;\n\tctile->xstep = pinst->xstep;\n\tctile->ystep = pinst->ystep;\n\tif ( mbits != 0 )\n\t  make_bitmap(&ctile->bits, mbits, gs_next_ids(1));\n\telse\n\t  ctile->bits.data = 0;\n\tif ( mmask != 0 )\n\t  make_bitmap(&ctile->mask, mmask, id);\n\telse\n\t  ctile->mask.data = 0;\n\tctile->is_simple = (ctile->xstep.x == int2fixed(pinst->size.x) &&\n\t\t\t    ctile->xstep.y == 0 &&\n\t\t\t    ctile->ystep.x == 0 &&\n\t\t\t    ctile->ystep.y == int2fixed(pinst->size.y));\n\tif_debug6('t',\n\t\t  \"[t]is_simple? xstep=(%g,%g) ystep=(%g,%g) size=(%d,%d)\\n\",\n\t\t  fixed2float(ctile->xstep.x), fixed2float(ctile->xstep.y),\n\t\t  fixed2float(ctile->ystep.x), fixed2float(ctile->ystep.y),\n\t\t  pinst->size.x, pinst->size.y);\n\tpcache->bits_used += used;\n\t*pctile = ctile;\n\treturn 0;\n"]]}
{"hexsha": "61149dfe793f6210203e86e9722ccf0cd1c4cd5e", "ext": "c", "lang": "C", "content": "void f194(void) {\n    \tvolatile int64_t x1029 = -115933LL;\n\tstatic uint32_t x1030 = 21U;\n\tstatic uint32_t x1031 = UINT32_MAX;\n\tstatic volatile uint8_t x1032 = UINT8_MAX;\n\tint64_t t194 = 133366559822157445LL;\n\n    t194 = ((x1029+x1030)^(x1031+x1032));\n\n    if (t194 != -115770LL) { NG(); } else { ; }\n\t\n}", "item_id": 194, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test14.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "61149dfe793f6210203e86e9722ccf0cd1c4cd5e_194", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f194(void) {\n    \tvolatile int64_t x1029 = -115933LL;\n\tstatic uint32_t x1030 = 21U;\n\tstatic uint32_t x1031 = UINT32_MAX;\n\tstatic volatile uint8_t x1032 = UINT8_MAX;\n\tint64_t t194 = 133366559822157445LL;\n    t194 = ((x1029+x1030)^(x1031+x1032));\n    if (t194 != -115770LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "b96e028e002a6c23a4e6f55f6335006e86e10c89", "ext": "c", "lang": "C", "content": "int\ne2_trace_GrowIndexTo(E2_TRACE *tr, int ndom)\n{\n  void *p;\n  int   status;\n\n  if (ndom < tr->ndomalloc) return eslOK;\n\n  ESL_RALLOC(tr->tfrom,   p, sizeof(int)*ndom);\n  ESL_RALLOC(tr->tto,     p, sizeof(int)*ndom);\n  ESL_RALLOC(tr->sqfrom,  p, sizeof(int)*ndom);\n  ESL_RALLOC(tr->sqto,    p, sizeof(int)*ndom);\n  ESL_RALLOC(tr->anfrom,  p, sizeof(int)*ndom);\n  ESL_RALLOC(tr->anto,    p, sizeof(int)*ndom);\n  tr->ndomalloc = ndom;\n  return eslOK;\n  \n ERROR:\n  return status;\n}", "item_id": 7, "repo": "EddyRivasLab/R-scape", "file": "src/e2_trace.c", "last_update_at": "2021-03-19T21:55:49+00:00", "question_id": "b96e028e002a6c23a4e6f55f6335006e86e10c89_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\ne2_trace_GrowIndexTo(E2_TRACE *tr, int ndom)\n{\n  void *p;\n  int   status;\n  if (ndom < tr->ndomalloc) return eslOK;\n  ESL_RALLOC(tr->tfrom,   p, sizeof(int)*ndom);\n  ESL_RALLOC(tr->tto,     p, sizeof(int)*ndom);\n  ESL_RALLOC(tr->sqfrom,  p, sizeof(int)*ndom);\n  ESL_RALLOC(tr->sqto,    p, sizeof(int)*ndom);\n  ESL_RALLOC(tr->anfrom,  p, sizeof(int)*ndom);\n  ESL_RALLOC(tr->anto,    p, sizeof(int)*ndom);\n  tr->ndomalloc = ndom;\n  return eslOK;\n ERROR:\n  return status;\n"]]}
{"hexsha": "14a2462f6ab25a6701cdb2bd5a973c62c31cc466", "ext": "h", "lang": "C", "content": "class CSpikeProfilerModule : public ATL::CAtlDllModuleT< CSpikeProfilerModule >\n{\npublic :\n\tDECLARE_LIBID(LIBID_SpikeProfilerLib)\n\tDECLARE_REGISTRY_APPID_RESOURCEID(IDR_SPIKEPROFILER, \"{15FA5249-D5F2-453A-A8EF-F75DFFE960FD}\")\n};\n\nextern class CSpikeProfilerModule _AtlModule;", "item_id": 0, "repo": "sawilde/fakesinvestigation", "file": "FakesInvestigation/SpikeProfiler/dllmain.h", "last_update_at": "2021-12-01T06:37:48+00:00", "question_id": "14a2462f6ab25a6701cdb2bd5a973c62c31cc466_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class CSpikeProfilerModule : public ATL::CAtlDllModuleT< CSpikeProfilerModule >\n{\npublic :\n\tDECLARE_LIBID(LIBID_SpikeProfilerLib)\n\tDECLARE_REGISTRY_APPID_RESOURCEID(IDR_SPIKEPROFILER, \"{15FA5249-D5F2-453A-A8EF-F75DFFE960FD}\")\n};\n"]]}
{"hexsha": "8e4ff03533d6ae23e6a41c43956fb1474045ccaa", "ext": "c", "lang": "C", "content": "uint32_t r_strcat(void) {\n\tchar* arg1 = (char*)GetLinearAddress(CPU, GetArgument(CPU, 1,2));\n\tchar* arg2 = (char*)GetLinearAddress(CPU, GetArgument(CPU, 2,2));\n\tstrcat(arg2, arg1);\n\treturn 0;\n}", "item_id": 3, "repo": "Benderx2/R3X", "file": "src/lib/rstdlib/rstdlib.c", "last_update_at": "2021-04-19T18:52:18+00:00", "question_id": "8e4ff03533d6ae23e6a41c43956fb1474045ccaa_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint32_t r_strcat(void) {\n\tchar* arg1 = (char*)GetLinearAddress(CPU, GetArgument(CPU, 1,2));\n\tchar* arg2 = (char*)GetLinearAddress(CPU, GetArgument(CPU, 2,2));\n\tstrcat(arg2, arg1);\n\treturn 0;\n"]]}
{"hexsha": "53596e8d41e7052fae0cfc2f4fba5abc98ae2fa4", "ext": "c", "lang": "C", "content": "void f84(void) {\n    \tstatic int8_t x5169 = INT8_MAX;\n\tstatic uint64_t x5170 = UINT64_MAX;\n\tuint16_t x5171 = 4U;\n\tuint64_t t84 = 3159700689LLU;\n\n    t84 = (((x5169+x5170)<<x5171)-x5172);\n\n    if (t84 != 18446744069414586337LLU) { NG(); } else { ; }\n\t\n}", "item_id": 84, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test72.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "53596e8d41e7052fae0cfc2f4fba5abc98ae2fa4_84", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f84(void) {\n    \tstatic int8_t x5169 = INT8_MAX;\n\tstatic uint64_t x5170 = UINT64_MAX;\n\tuint16_t x5171 = 4U;\n\tuint64_t t84 = 3159700689LLU;\n    t84 = (((x5169+x5170)<<x5171)-x5172);\n    if (t84 != 18446744069414586337LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "d69457997e55a2fae4f42ced590aba9e41589e98", "ext": "c", "lang": "C", "content": "void f129(void) {\n    \tuint8_t x1373 = UINT8_MAX;\n\tvolatile int16_t x1374 = INT16_MAX;\n\tuint16_t x1375 = 493U;\n\tstatic uint8_t x1376 = 78U;\n\tstatic volatile int32_t t129 = 0;\n\n    t129 = (x1373<<(x1374&(x1375/x1376)));\n\n    if (t129 != 16320) { NG(); } else { ; }\n\t\n}", "item_id": 129, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test748.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "d69457997e55a2fae4f42ced590aba9e41589e98_129", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f129(void) {\n    \tuint8_t x1373 = UINT8_MAX;\n\tvolatile int16_t x1374 = INT16_MAX;\n\tuint16_t x1375 = 493U;\n\tstatic uint8_t x1376 = 78U;\n\tstatic volatile int32_t t129 = 0;\n    t129 = (x1373<<(x1374&(x1375/x1376)));\n    if (t129 != 16320) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "94e83d28da7a424ea28a59dd63bda175ae3b5f31", "ext": "c", "lang": "C", "content": "void f48(void) {\n    \tstatic uint32_t x233 = 3U;\n\tint8_t x234 = 0;\n\tint32_t x235 = -738526;\n\tstatic int64_t x236 = -473228154727660LL;\n\n    t48 = ((x233*(x234^x235))==x236);\n\n    if (t48 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 48, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test2584.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "94e83d28da7a424ea28a59dd63bda175ae3b5f31_48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f48(void) {\n    \tstatic uint32_t x233 = 3U;\n\tint8_t x234 = 0;\n\tint32_t x235 = -738526;\n\tstatic int64_t x236 = -473228154727660LL;\n    t48 = ((x233*(x234^x235))==x236);\n    if (t48 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "f5012e1986505ca8ce82310302152eeadde7147a", "ext": "c", "lang": "C", "content": "static void centaur_get_mcr (unsigned int reg, unsigned long *base,\n\t\t\t     unsigned long *size, mtrr_type *type)\n{\n    *base = centaur_mcr[reg].high >> PAGE_SHIFT;\n    *size = -(centaur_mcr[reg].low & 0xfffff000) >> PAGE_SHIFT;\n    *type = MTRR_TYPE_WRCOMB;\t/*  If it is there, it is write-combining  */\n    if(centaur_mcr_type==1 && ((centaur_mcr[reg].low&31)&2))\n    \t*type = MTRR_TYPE_UNCACHABLE;\n    if(centaur_mcr_type==1 && (centaur_mcr[reg].low&31)==25)\n    \t*type = MTRR_TYPE_WRBACK;\n    if(centaur_mcr_type==0 && (centaur_mcr[reg].low&31)==31)\n    \t*type = MTRR_TYPE_WRBACK;\n    \n}", "item_id": 6, "repo": "enfoTek/tomato.linksys.e2000.nvram-mod", "file": "release/src/linux/linux/arch/i386/kernel/mtrr.c", "last_update_at": "2021-06-07T06:29:49+00:00", "question_id": "f5012e1986505ca8ce82310302152eeadde7147a_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void centaur_get_mcr (unsigned int reg, unsigned long *base,\n\t\t\t     unsigned long *size, mtrr_type *type)\n{\n    *base = centaur_mcr[reg].high >> PAGE_SHIFT;\n    *size = -(centaur_mcr[reg].low & 0xfffff000) >> PAGE_SHIFT;\n    *type = MTRR_TYPE_WRCOMB;\t/*  If it is there, it is write-combining  */\n    if(centaur_mcr_type==1 && ((centaur_mcr[reg].low&31)&2))\n    \t*type = MTRR_TYPE_UNCACHABLE;\n    if(centaur_mcr_type==1 && (centaur_mcr[reg].low&31)==25)\n    \t*type = MTRR_TYPE_WRBACK;\n    if(centaur_mcr_type==0 && (centaur_mcr[reg].low&31)==31)\n    \t*type = MTRR_TYPE_WRBACK;\n"]]}
{"hexsha": "51a30f9e4d2f913604d7c21896e45a12eefb3298", "ext": "c", "lang": "C", "content": "int main(int argc, char *argv[])\r\n{\r\n\tif (argc < 2)\r\n\t{\r\n\t\tprintf(\"Please provide a hostname to resolve\");\r\n\t\texit(1);\r\n\t}\r\n\r\n\tchar *hostname = argv[1];\r\n\tchar ip[100];\r\n\r\n\thostname_to_ip(hostname, ip);\r\n\tprintf(\"%s resolved to %s\", hostname, ip);\r\n\r\n\tprintf(\"\\n\");\r\n}", "item_id": 0, "repo": "wurui1994/test", "file": "Sources/Network/BasicSocket/GetIpByHost/getaddrinfo.c", "last_update_at": "2021-07-30T13:02:00+00:00", "question_id": "51a30f9e4d2f913604d7c21896e45a12eefb3298_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(int argc, char *argv[])\r\n{\r\n\tif (argc < 2)\r\n\t{\r\n\t\tprintf(\"Please provide a hostname to resolve\");\r\n\t\texit(1);\r\n\t}\r\n\r\n\tchar *hostname = argv[1];\r\n\tchar ip[100];\r\n\r\n\thostname_to_ip(hostname, ip);\r\n\tprintf(\"%s resolved to %s\", hostname, ip);\r\n\r\n\tprintf(\"\\n\");\r\n"]]}
{"hexsha": "6919b3afee9eeccb5e6e7811a76a30d72b95aad0", "ext": "c", "lang": "C", "content": "void f45(void) {\n    \tuint16_t x197 = UINT16_MAX;\n\tvolatile int16_t x198 = INT16_MAX;\n\tint16_t x199 = -13942;\n\tint8_t x200 = -1;\n\tvolatile int32_t t45 = -4;\n\n    t45 = (x197|(x198*(x199/x200)));\n\n    if (t45 != 456851455) { NG(); } else { ; }\n\t\n}", "item_id": 45, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test629.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "6919b3afee9eeccb5e6e7811a76a30d72b95aad0_45", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f45(void) {\n    \tuint16_t x197 = UINT16_MAX;\n\tvolatile int16_t x198 = INT16_MAX;\n\tint16_t x199 = -13942;\n\tint8_t x200 = -1;\n\tvolatile int32_t t45 = -4;\n    t45 = (x197|(x198*(x199/x200)));\n    if (t45 != 456851455) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "cbd6a173daa360208486811af65ec2c31fccd1ed", "ext": "c", "lang": "C", "content": "void f98(void) {\n    \tint16_t x409 = INT16_MIN;\n\tvolatile int16_t x410 = -1;\n\tstatic volatile int16_t x411 = INT16_MIN;\n\tint32_t x412 = INT32_MIN;\n\tvolatile int32_t t98 = -7;\n\n    t98 = (x409>(x410+(x411/x412)));\n\n    if (t98 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 98, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test597.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "cbd6a173daa360208486811af65ec2c31fccd1ed_98", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f98(void) {\n    \tint16_t x409 = INT16_MIN;\n\tvolatile int16_t x410 = -1;\n\tstatic volatile int16_t x411 = INT16_MIN;\n\tint32_t x412 = INT32_MIN;\n\tvolatile int32_t t98 = -7;\n    t98 = (x409>(x410+(x411/x412)));\n    if (t98 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "264a396dca1b26e625c8c5459c7c5da151d4fafa", "ext": "c", "lang": "C", "content": "void f13(void) {\n    \tuint16_t x769 = 0U;\n\tstatic int64_t x770 = -3LL;\n\tint16_t x771 = 5;\n\tuint16_t x772 = 20U;\n\tint64_t t13 = 52116345861LL;\n\n    t13 = (((x769%x770)^x771)<<x772);\n\n    if (t13 != 5242880LL) { NG(); } else { ; }\n\t\n}", "item_id": 13, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test972.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "264a396dca1b26e625c8c5459c7c5da151d4fafa_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f13(void) {\n    \tuint16_t x769 = 0U;\n\tstatic int64_t x770 = -3LL;\n\tint16_t x771 = 5;\n\tuint16_t x772 = 20U;\n\tint64_t t13 = 52116345861LL;\n    t13 = (((x769%x770)^x771)<<x772);\n    if (t13 != 5242880LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "0ae14efbb8577eadb35835402c6fd84988df5651", "ext": "c", "lang": "C", "content": "void f169(void) {\n    \tuint32_t x1385 = 550U;\n\tint16_t x1386 = -1;\n\tvolatile uint32_t t169 = 415203289U;\n\n    t169 = (x1385<<(x1386>(x1387-x1388)));\n\n    if (t169 != 550U) { NG(); } else { ; }\n\t\n}", "item_id": 169, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test314.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "0ae14efbb8577eadb35835402c6fd84988df5651_169", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f169(void) {\n    \tuint32_t x1385 = 550U;\n\tint16_t x1386 = -1;\n\tvolatile uint32_t t169 = 415203289U;\n    t169 = (x1385<<(x1386>(x1387-x1388)));\n    if (t169 != 550U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "b186697b933688c000ae152e7e7f3c125801a582", "ext": "c", "lang": "C", "content": "static void SDSPI_DecodeCid(sdspi_card_t *card, uint8_t *rawCid)\n{\n    assert(card != NULL);\n    assert(rawCid != NULL);\n\n    sd_cid_t *cid       = &(card->cid);\n    cid->manufacturerID = rawCid[0U];\n    cid->applicationID  = (uint16_t)(((uint32_t)rawCid[1U] << 8U) | (uint32_t)(rawCid[2U]));\n    (void)memcpy(cid->productName, &rawCid[3U], SD_PRODUCT_NAME_BYTES);\n    cid->productVersion      = rawCid[8U];\n    cid->productSerialNumber = (((uint32_t)rawCid[9U] << 24U) | ((uint32_t)rawCid[10U] << 16U) |\n                                ((uint32_t)rawCid[11U] << 8U) | ((uint32_t)rawCid[12U]));\n    cid->manufacturerData    = (uint16_t)((((uint32_t)rawCid[13U] & 0x0FU) << 8U) | ((uint32_t)rawCid[14U]));\n}", "item_id": 12, "repo": "stephendpmurphy/K64F_sandbox", "file": "KSDK/middleware/sdmmc/sdspi/fsl_sdspi.c", "last_update_at": "2021-08-10T02:11:04+00:00", "question_id": "b186697b933688c000ae152e7e7f3c125801a582_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void SDSPI_DecodeCid(sdspi_card_t *card, uint8_t *rawCid)\n{\n    assert(card != NULL);\n    assert(rawCid != NULL);\n    sd_cid_t *cid       = &(card->cid);\n    cid->manufacturerID = rawCid[0U];\n    cid->applicationID  = (uint16_t)(((uint32_t)rawCid[1U] << 8U) | (uint32_t)(rawCid[2U]));\n    (void)memcpy(cid->productName, &rawCid[3U], SD_PRODUCT_NAME_BYTES);\n    cid->productVersion      = rawCid[8U];\n    cid->productSerialNumber = (((uint32_t)rawCid[9U] << 24U) | ((uint32_t)rawCid[10U] << 16U) |\n                                ((uint32_t)rawCid[11U] << 8U) | ((uint32_t)rawCid[12U]));\n    cid->manufacturerData    = (uint16_t)((((uint32_t)rawCid[13U] & 0x0FU) << 8U) | ((uint32_t)rawCid[14U]));\n"]]}
{"hexsha": "2d4dc4d554dbafc31c9a5aea9f7dac0d968755f4", "ext": "c", "lang": "C", "content": "void xxxLBoxCtlHScrollMultiColumn(\r\n    PLBIV plb,\r\n    INT cmd,\r\n    INT xAmt)\r\n{\r\n    INT iTop = plb->iTop;\r\n\r\n    CheckLock(plb->spwnd);\r\n\r\n    if (!plb->cMac)  return;\r\n\r\n    switch (cmd) {\r\n    case SB_LINEUP:\r\n        if (plb->fRightAlign)\r\n            goto ReallyLineDown;\r\nReallyLineUp:\r\n        iTop -= plb->itemsPerColumn;\r\n        break;\r\n    case SB_LINEDOWN:\r\n        if (plb->fRightAlign)\r\n            goto ReallyLineUp;\r\nReallyLineDown:\r\n        iTop += plb->itemsPerColumn;\r\n        break;\r\n    case SB_PAGEUP:\r\n        if (plb->fRightAlign)\r\n            goto ReallyPageDown;\r\nReallyPageUp:\r\n        iTop -= plb->itemsPerColumn * plb->numberOfColumns;\r\n        break;\r\n    case SB_PAGEDOWN:\r\n        if (plb->fRightAlign)\r\n            goto ReallyPageUp;\r\nReallyPageDown:\r\n        iTop += plb->itemsPerColumn * plb->numberOfColumns;\r\n        break;\r\n    case SB_THUMBTRACK:\r\n    case SB_THUMBPOSITION:\r\n        if (plb->fRightAlign) {\r\n            int  iCols = plb->cMac ? ((plb->cMac-1) / plb->itemsPerColumn) + 1 : 0;\r\n\r\n            xAmt = iCols - (xAmt + plb->numberOfColumns);\r\n            if (xAmt<0)\r\n                xAmt=0;\r\n        }\r\n        iTop = xAmt * plb->itemsPerColumn;\r\n        break;\r\n    case SB_TOP:\r\n        if (plb->fRightAlign)\r\n            goto ReallyBottom;\r\nReallyTop:\r\n        iTop = 0;\r\n        break;\r\n    case SB_BOTTOM:\r\n        if (plb->fRightAlign)\r\n            goto ReallyTop;\r\nReallyBottom:\r\n        iTop = plb->cMac - 1 - ((plb->cMac - 1) % plb->itemsPerColumn);\r\n        break;\r\n    case SB_ENDSCROLL:\r\n        plb->fSmoothScroll = TRUE;\r\n        xxxLBShowHideScrollBars(plb);\r\n        break;\r\n    }\r\n\r\n    xxxNewITop(plb, iTop);\r\n}", "item_id": 1, "repo": "King0987654/windows2000", "file": "private/ntos/w32/ntuser/client/lboxmult.c", "last_update_at": "2021-09-16T09:13:13+00:00", "question_id": "2d4dc4d554dbafc31c9a5aea9f7dac0d968755f4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void xxxLBoxCtlHScrollMultiColumn(\r\n    PLBIV plb,\r\n    INT cmd,\r\n    INT xAmt)\r\n{\r\n    INT iTop = plb->iTop;\r\n\r\n    CheckLock(plb->spwnd);\r\n\r\n    if (!plb->cMac)  return;\r\n\r\n    switch (cmd) {\r\n    case SB_LINEUP:\r\n        if (plb->fRightAlign)\r\n            goto ReallyLineDown;\r\nReallyLineUp:\r\n        iTop -= plb->itemsPerColumn;\r\n        break;\r\n    case SB_LINEDOWN:\r\n        if (plb->fRightAlign)\r\n            goto ReallyLineUp;\r\nReallyLineDown:\r\n        iTop += plb->itemsPerColumn;\r\n        break;\r\n    case SB_PAGEUP:\r\n        if (plb->fRightAlign)\r\n            goto ReallyPageDown;\r\nReallyPageUp:\r\n        iTop -= plb->itemsPerColumn * plb->numberOfColumns;\r\n        break;\r\n    case SB_PAGEDOWN:\r\n        if (plb->fRightAlign)\r\n            goto ReallyPageUp;\r\nReallyPageDown:\r\n        iTop += plb->itemsPerColumn * plb->numberOfColumns;\r\n        break;\r\n    case SB_THUMBTRACK:\r\n    case SB_THUMBPOSITION:\r\n        if (plb->fRightAlign) {\r\n            int  iCols = plb->cMac ? ((plb->cMac-1) / plb->itemsPerColumn) + 1 : 0;\r\n\r\n            xAmt = iCols - (xAmt + plb->numberOfColumns);\r\n            if (xAmt<0)\r\n                xAmt=0;\r\n        }\r\n        iTop = xAmt * plb->itemsPerColumn;\r\n        break;\r\n    case SB_TOP:\r\n        if (plb->fRightAlign)\r\n            goto ReallyBottom;\r\nReallyTop:\r\n        iTop = 0;\r\n        break;\r\n    case SB_BOTTOM:\r\n        if (plb->fRightAlign)\r\n            goto ReallyTop;\r\nReallyBottom:\r\n        iTop = plb->cMac - 1 - ((plb->cMac - 1) % plb->itemsPerColumn);\r\n        break;\r\n    case SB_ENDSCROLL:\r\n        plb->fSmoothScroll = TRUE;\r\n        xxxLBShowHideScrollBars(plb);\r\n        break;\r\n    }\r\n\r\n    xxxNewITop(plb, iTop);\r\n"]]}
{"hexsha": "8ce91f3311317a9f4d447921b05bbe5a370bf164", "ext": "c", "lang": "C", "content": "void DM_ENG_deleteAllSetParameterValuesFault(DM_ENG_SetParameterValuesFault** pFault)\r\n{\r\n   DM_ENG_SetParameterValuesFault* fault = *pFault;\r\n   while (fault != NULL)\r\n   {\r\n      DM_ENG_SetParameterValuesFault* fa = fault;\r\n      fault = fault->next;\r\n      DM_ENG_deleteSetParameterValuesFault(fa);\r\n   }\r\n   *pFault = NULL;\r\n}", "item_id": 1, "repo": "Orange-OpenSource/tr069agen", "file": "dm_engine/src/DM_ENG_SetParameterValuesFault.c", "last_update_at": "2021-08-25T11:36:01+00:00", "question_id": "8ce91f3311317a9f4d447921b05bbe5a370bf164_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void DM_ENG_deleteAllSetParameterValuesFault(DM_ENG_SetParameterValuesFault** pFault)\r\n{\r\n   DM_ENG_SetParameterValuesFault* fault = *pFault;\r\n   while (fault != NULL)\r\n   {\r\n      DM_ENG_SetParameterValuesFault* fa = fault;\r\n      fault = fault->next;\r\n      DM_ENG_deleteSetParameterValuesFault(fa);\r\n   }\r\n   *pFault = NULL;\r\n"]]}
{"hexsha": "a77418c12770cabb92fd8d371993cb011592e5df", "ext": "c", "lang": "C", "content": "static void decompress_bwlzh_block(unsigned char** ptr, const int nvals, unsigned int** vals)\n{\n    int bwlzh_buf_len = (int)(((unsigned int)(*ptr)[0]) | (((unsigned int)(*ptr)[1]) << 8)\n                              | (((unsigned int)(*ptr)[2]) << 16) | (((unsigned int)(*ptr)[3]) << 24));\n    (*ptr) += 4;\n    *vals = warnmalloc(nvals * sizeof(**vals));\n    bwlzh_decompress(*ptr, nvals, *vals);\n    (*ptr) += bwlzh_buf_len;\n}", "item_id": 19, "repo": "ezavod/tng", "file": "src/compression/xtc3.c", "last_update_at": "2021-04-20T02:28:15+00:00", "question_id": "a77418c12770cabb92fd8d371993cb011592e5df_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void decompress_bwlzh_block(unsigned char** ptr, const int nvals, unsigned int** vals)\n{\n    int bwlzh_buf_len = (int)(((unsigned int)(*ptr)[0]) | (((unsigned int)(*ptr)[1]) << 8)\n                              | (((unsigned int)(*ptr)[2]) << 16) | (((unsigned int)(*ptr)[3]) << 24));\n    (*ptr) += 4;\n    *vals = warnmalloc(nvals * sizeof(**vals));\n    bwlzh_decompress(*ptr, nvals, *vals);\n    (*ptr) += bwlzh_buf_len;\n"]]}
{"hexsha": "2455756242f54d5032a2691aa6fc1b9a94ef8d0f", "ext": "c", "lang": "C", "content": "XrResult\noxr_space_ref_relation(struct oxr_logger *log,\n                       struct oxr_session *sess,\n                       XrReferenceSpaceType space,\n                       XrReferenceSpaceType baseSpc,\n                       XrTime time,\n                       struct xrt_space_relation *out_relation)\n{\n\t// Treat stage space as the local space.\n\tif (space == XR_REFERENCE_SPACE_TYPE_STAGE) {\n\t\tspace = XR_REFERENCE_SPACE_TYPE_LOCAL;\n\t}\n\n\t// Treat stage space as the local space.\n\tif (baseSpc == XR_REFERENCE_SPACE_TYPE_STAGE) {\n\t\tbaseSpc = XR_REFERENCE_SPACE_TYPE_LOCAL;\n\t}\n\n\tmath_relation_reset(out_relation);\n\n\tif (space == XR_REFERENCE_SPACE_TYPE_VIEW &&\n\t    baseSpc == XR_REFERENCE_SPACE_TYPE_LOCAL) {\n\t\toxr_session_get_view_pose_at(log, sess, time,\n\t\t                             &out_relation->pose);\n\n\t\tout_relation->relation_flags = (enum xrt_space_relation_flags)(\n\t\t    XRT_SPACE_RELATION_POSITION_VALID_BIT |\n\t\t    XRT_SPACE_RELATION_POSITION_TRACKED_BIT |\n\t\t    XRT_SPACE_RELATION_ORIENTATION_VALID_BIT |\n\t\t    XRT_SPACE_RELATION_ORIENTATION_TRACKED_BIT);\n\n\t} else if (space == XR_REFERENCE_SPACE_TYPE_LOCAL &&\n\t           baseSpc == XR_REFERENCE_SPACE_TYPE_VIEW) {\n\t\toxr_session_get_view_pose_at(log, sess, time,\n\t\t                             &out_relation->pose);\n\t\tmath_pose_invert(&out_relation->pose, &out_relation->pose);\n\n\t\tout_relation->relation_flags = (enum xrt_space_relation_flags)(\n\t\t    XRT_SPACE_RELATION_POSITION_VALID_BIT |\n\t\t    XRT_SPACE_RELATION_POSITION_TRACKED_BIT |\n\t\t    XRT_SPACE_RELATION_ORIENTATION_VALID_BIT |\n\t\t    XRT_SPACE_RELATION_ORIENTATION_TRACKED_BIT);\n\n\t} else if (space == baseSpc) {\n\t\t// math_relation_reset() sets to identity.\n\n\t} else {\n\t\tout_relation->relation_flags = XRT_SPACE_RELATION_BITMASK_NONE;\n\t\treturn XR_SUCCESS;\n\t}\n\n\treturn XR_SUCCESS;\n}", "item_id": 3, "repo": "ltstein/monado_integration", "file": "src/xrt/state_trackers/oxr/oxr_space.c", "last_update_at": "2021-10-31T14:32:59+00:00", "question_id": "2455756242f54d5032a2691aa6fc1b9a94ef8d0f_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["XrResult\noxr_space_ref_relation(struct oxr_logger *log,\n                       struct oxr_session *sess,\n                       XrReferenceSpaceType space,\n                       XrReferenceSpaceType baseSpc,\n                       XrTime time,\n                       struct xrt_space_relation *out_relation)\n{\n\t// Treat stage space as the local space.\n\tif (space == XR_REFERENCE_SPACE_TYPE_STAGE) {\n\t\tspace = XR_REFERENCE_SPACE_TYPE_LOCAL;\n\t}\n\t// Treat stage space as the local space.\n\tif (baseSpc == XR_REFERENCE_SPACE_TYPE_STAGE) {\n\t\tbaseSpc = XR_REFERENCE_SPACE_TYPE_LOCAL;\n\t}\n\tmath_relation_reset(out_relation);\n\tif (space == XR_REFERENCE_SPACE_TYPE_VIEW &&\n\t    baseSpc == XR_REFERENCE_SPACE_TYPE_LOCAL) {\n\t\toxr_session_get_view_pose_at(log, sess, time,\n\t\t                             &out_relation->pose);\n\t\tout_relation->relation_flags = (enum xrt_space_relation_flags)(\n\t\t    XRT_SPACE_RELATION_POSITION_VALID_BIT |\n\t\t    XRT_SPACE_RELATION_POSITION_TRACKED_BIT |\n\t\t    XRT_SPACE_RELATION_ORIENTATION_VALID_BIT |\n\t\t    XRT_SPACE_RELATION_ORIENTATION_TRACKED_BIT);\n\t} else if (space == XR_REFERENCE_SPACE_TYPE_LOCAL &&\n\t           baseSpc == XR_REFERENCE_SPACE_TYPE_VIEW) {\n\t\toxr_session_get_view_pose_at(log, sess, time,\n\t\t                             &out_relation->pose);\n\t\tmath_pose_invert(&out_relation->pose, &out_relation->pose);\n\t\tout_relation->relation_flags = (enum xrt_space_relation_flags)(\n\t\t    XRT_SPACE_RELATION_POSITION_VALID_BIT |\n\t\t    XRT_SPACE_RELATION_POSITION_TRACKED_BIT |\n\t\t    XRT_SPACE_RELATION_ORIENTATION_VALID_BIT |\n\t\t    XRT_SPACE_RELATION_ORIENTATION_TRACKED_BIT);\n\t} else if (space == baseSpc) {\n\t\t// math_relation_reset() sets to identity.\n\t} else {\n\t\tout_relation->relation_flags = XRT_SPACE_RELATION_BITMASK_NONE;\n\t\treturn XR_SUCCESS;\n\t}\n\treturn XR_SUCCESS;\n"]]}
{"hexsha": "f62d365b8c33794fd508c3956ba5969f710ae0e6", "ext": "h", "lang": "C", "content": "LFRTM_API int\nlfrtm_free(lfrtm_t *lfrtm)\n{\n\tif(!lfrtm)\n\t{\n\t\treturn -1;\n\t}\n\n\tfor(unsigned idx = 0; idx < lfrtm->num; idx++)\n\t{\n\t\tuintptr_t pool = atomic_exchange(&lfrtm->pools[idx], 0);\n\t\tif( (pool != 0) && (pool != UINTPTR_MAX) )\n\t\t{\n\t\t\tfree((void *)pool);\n\t\t}\n\t}\n\n\tfree(lfrtm);\n\treturn 0;\n}", "item_id": 1, "repo": "OpenMusicKontrollers/synthpod", "file": "lfrtm/lfrtm/lfrtm.h", "last_update_at": "2021-10-29T22:47:57+00:00", "question_id": "f62d365b8c33794fd508c3956ba5969f710ae0e6_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["LFRTM_API int\nlfrtm_free(lfrtm_t *lfrtm)\n{\n\tif(!lfrtm)\n\t{\n\t\treturn -1;\n\t}\n\tfor(unsigned idx = 0; idx < lfrtm->num; idx++)\n\t{\n\t\tuintptr_t pool = atomic_exchange(&lfrtm->pools[idx], 0);\n\t\tif( (pool != 0) && (pool != UINTPTR_MAX) )\n\t\t{\n\t\t\tfree((void *)pool);\n\t\t}\n\t}\n\tfree(lfrtm);\n\treturn 0;\n"]]}
{"hexsha": "236b0c4fe6ec5cf9e4606c0c97d142e17a72a0cf", "ext": "h", "lang": "C", "content": "static __INLINE mtlk_dlist_entry_t *\nmtlk_dlist_pop_front (mtlk_dlist_t *dlist)\n{\n  mtlk_dlist_entry_t *entry;\n\n  ASSERT(dlist != NULL);\n\n  if (mtlk_dlist_is_empty(dlist))\n    return NULL;\n\n  entry = dlist->head.next;\n\n  mtlk_dlist_remove(dlist, entry);\n\n  return entry;\n}", "item_id": 15, "repo": "Mandrake-Lee/wave300-openwrt", "file": "tools/shared/linux/mtlklist_osdep_defs.h", "last_update_at": "2021-12-26T12:47:37+00:00", "question_id": "236b0c4fe6ec5cf9e4606c0c97d142e17a72a0cf_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static __INLINE mtlk_dlist_entry_t *\nmtlk_dlist_pop_front (mtlk_dlist_t *dlist)\n{\n  mtlk_dlist_entry_t *entry;\n  ASSERT(dlist != NULL);\n  if (mtlk_dlist_is_empty(dlist))\n    return NULL;\n  entry = dlist->head.next;\n  mtlk_dlist_remove(dlist, entry);\n  return entry;\n"]]}
{"hexsha": "a5705a56b9234c5d31d71683e7fd7702d17624a9", "ext": "c", "lang": "C", "content": "VOID tim5_capture_ISR(u32 channel)\r\n{\t\r\n\ttimout_cnt++;\r\n\tif(timout_cnt % 2){\r\n\t\tvalue1 = RTIM_CCRxGet(TIM5, channel) & 0xffff;\r\n\t}\r\n\telse{\r\n\t\tvalue2 = RTIM_CCRxGet(TIM5, channel) & 0xffff;\r\n\t\ttimout_cnt = 0;\r\n\r\n\t\tif(value2 > value1)\r\n\t\t\tDBG_8195A(\"frequency: %d\\n\", 40000000/(value2 - value1));\r\n\t\telse\r\n\t\t\tDBG_8195A(\"frequency: %d\\n\", 40000000/(PWM_PERIOD + 1 - value1 + value2));\r\n\t}\r\n\r\n\tRTIM_INTClear(TIM5);\r\n}", "item_id": 0, "repo": "AdamZhang0124/ambd_sdk_with_chip_non_NDA", "file": "project/realtek_amebaD_va0_example/example_sources/TIMER/raw/tim5_capture_pwm_32k/src/main.c", "last_update_at": "2021-09-29T02:32:03+00:00", "question_id": "a5705a56b9234c5d31d71683e7fd7702d17624a9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["VOID tim5_capture_ISR(u32 channel)\r\n{\t\r\n\ttimout_cnt++;\r\n\tif(timout_cnt % 2){\r\n\t\tvalue1 = RTIM_CCRxGet(TIM5, channel) & 0xffff;\r\n\t}\r\n\telse{\r\n\t\tvalue2 = RTIM_CCRxGet(TIM5, channel) & 0xffff;\r\n\t\ttimout_cnt = 0;\r\n\r\n\t\tif(value2 > value1)\r\n\t\t\tDBG_8195A(\"frequency: %d\\n\", 40000000/(value2 - value1));\r\n\t\telse\r\n\t\t\tDBG_8195A(\"frequency: %d\\n\", 40000000/(PWM_PERIOD + 1 - value1 + value2));\r\n\t}\r\n\r\n\tRTIM_INTClear(TIM5);\r\n"]]}
{"hexsha": "b347f0d8a681f2050651b61e44923db8baee9640", "ext": "c", "lang": "C", "content": "void BOARD_InitDEBUG_UARTPins(void)\n{\n    /* Enables clock for IOCON.: enable */\n    CLOCK_EnableClock(kCLOCK_Iocon);\n    /* Enables clock for switch matrix.: enable */\n    CLOCK_EnableClock(kCLOCK_Swm);\n\n    const uint32_t IOCON_INDEX_PIO0_0_config = (/* Selects pull-up function */\n                                                IOCON_PIO_MODE_PULLUP |\n                                                /* Enable hysteresis */\n                                                IOCON_PIO_HYS_EN |\n                                                /* Input not invert */\n                                                IOCON_PIO_INV_DI |\n                                                /* Disables Open-drain function */\n                                                IOCON_PIO_OD_DI);\n    /* PORT1 PIN7 (coords: ) is configured as  */\n    IOCON_PinMuxSet(IOCON, IOCON_INDEX_PIO0_0, IOCON_INDEX_PIO0_0_config);\n\n    const uint32_t IOCON_INDEX_PIO0_4_config = (/* Selects pull-up function */\n                                                IOCON_PIO_MODE_PULLUP |\n                                                /* Enable hysteresis */\n                                                IOCON_PIO_HYS_EN |\n                                                /* Input not invert */\n                                                IOCON_PIO_INV_DI |\n                                                /* Disables Open-drain function */\n                                                IOCON_PIO_OD_DI);\n    /* PORT4 PIN (coords: ) is configured as  */\n    IOCON_PinMuxSet(IOCON, IOCON_INDEX_PIO0_4, IOCON_INDEX_PIO0_4_config);\n\n    /* USART0_TXD connect to P0_4 */\n    SWM_SetMovablePinSelect(SWM0, kSWM_USART0_TXD, kSWM_PortPin_P0_4);\n\n    /* USART0_RXD connect to P0_0 */\n    SWM_SetMovablePinSelect(SWM0, kSWM_USART0_RXD, kSWM_PortPin_P0_0);\n\n    /* Disable clock for switch matrix. */\n    CLOCK_DisableClock(kCLOCK_Swm);\n}", "item_id": 1, "repo": "bm16ton/portenta-tinyusb", "file": "hw/mcu/nxp/mcux-sdk/boards/lpcxpresso802/project_template/pin_mux.c", "last_update_at": "2021-02-03T14:27:54+00:00", "question_id": "b347f0d8a681f2050651b61e44923db8baee9640_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void BOARD_InitDEBUG_UARTPins(void)\n{\n    /* Enables clock for IOCON.: enable */\n    CLOCK_EnableClock(kCLOCK_Iocon);\n    /* Enables clock for switch matrix.: enable */\n    CLOCK_EnableClock(kCLOCK_Swm);\n    const uint32_t IOCON_INDEX_PIO0_0_config = (/* Selects pull-up function */\n                                                IOCON_PIO_MODE_PULLUP |\n                                                /* Enable hysteresis */\n                                                IOCON_PIO_HYS_EN |\n                                                /* Input not invert */\n                                                IOCON_PIO_INV_DI |\n                                                /* Disables Open-drain function */\n                                                IOCON_PIO_OD_DI);\n    /* PORT1 PIN7 (coords: ) is configured as  */\n    IOCON_PinMuxSet(IOCON, IOCON_INDEX_PIO0_0, IOCON_INDEX_PIO0_0_config);\n    const uint32_t IOCON_INDEX_PIO0_4_config = (/* Selects pull-up function */\n                                                IOCON_PIO_MODE_PULLUP |\n                                                /* Enable hysteresis */\n                                                IOCON_PIO_HYS_EN |\n                                                /* Input not invert */\n                                                IOCON_PIO_INV_DI |\n                                                /* Disables Open-drain function */\n                                                IOCON_PIO_OD_DI);\n    /* PORT4 PIN (coords: ) is configured as  */\n    IOCON_PinMuxSet(IOCON, IOCON_INDEX_PIO0_4, IOCON_INDEX_PIO0_4_config);\n    /* USART0_TXD connect to P0_4 */\n    SWM_SetMovablePinSelect(SWM0, kSWM_USART0_TXD, kSWM_PortPin_P0_4);\n    /* USART0_RXD connect to P0_0 */\n    SWM_SetMovablePinSelect(SWM0, kSWM_USART0_RXD, kSWM_PortPin_P0_0);\n    /* Disable clock for switch matrix. */\n    CLOCK_DisableClock(kCLOCK_Swm);\n"]]}
{"hexsha": "63ade1971ca876f75261f245770ec419e0a92293", "ext": "c", "lang": "C", "content": "Datum\nsemver_gt(PG_FUNCTION_ARGS)\n{\n    semver* a = PG_GETARG_SEMVER_P(0);\n    semver* b = PG_GETARG_SEMVER_P(1);\n    int diff = _semver_cmp(a, b);\n    PG_RETURN_BOOL(diff > 0);\n}", "item_id": 15, "repo": "mgit-at/pg-semver-debian", "file": "src/semver.c", "last_update_at": "2021-03-31T18:39:24+00:00", "question_id": "63ade1971ca876f75261f245770ec419e0a92293_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["Datum\nsemver_gt(PG_FUNCTION_ARGS)\n{\n    semver* a = PG_GETARG_SEMVER_P(0);\n    semver* b = PG_GETARG_SEMVER_P(1);\n    int diff = _semver_cmp(a, b);\n    PG_RETURN_BOOL(diff > 0);\n"]]}
{"hexsha": "5bb15aa79d02c6f024cb4959fe3f2a91bc24ef31", "ext": "c", "lang": "C", "content": "void f1(void) {\n    \tstatic volatile int8_t x6 = -1;\n\tstatic int32_t x7 = INT32_MAX;\n\tuint8_t x8 = 49U;\n\n    t1 = ((x5^(x6>x7))+x8);\n\n    if (t1 != 32816) { NG(); } else { ; }\n\t\n}", "item_id": 1, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test1751.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "5bb15aa79d02c6f024cb4959fe3f2a91bc24ef31_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f1(void) {\n    \tstatic volatile int8_t x6 = -1;\n\tstatic int32_t x7 = INT32_MAX;\n\tuint8_t x8 = 49U;\n    t1 = ((x5^(x6>x7))+x8);\n    if (t1 != 32816) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "a9adc5016e99008c315407c66ec6c9e44808d396", "ext": "c", "lang": "C", "content": "void f176(void) {\n    \tint64_t x789 = 6798025LL;\n\tint16_t x790 = INT16_MIN;\n\tint8_t x791 = -28;\n\tuint64_t x792 = 3351480416874751LLU;\n\n    t176 = (((x789+x790)>x791)==x792);\n\n    if (t176 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 176, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test120.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "a9adc5016e99008c315407c66ec6c9e44808d396_176", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f176(void) {\n    \tint64_t x789 = 6798025LL;\n\tint16_t x790 = INT16_MIN;\n\tint8_t x791 = -28;\n\tuint64_t x792 = 3351480416874751LLU;\n    t176 = (((x789+x790)>x791)==x792);\n    if (t176 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "d0b1659a157603fbb1de9e19593096df15765aa3", "ext": "c", "lang": "C", "content": "static void preprocess_signed(struct aec_stream *strm)\n{\n    /**\n       Preprocess RSI of signed samples.\n    */\n\n    uint32_t D;\n    struct internal_state *state = strm->state;\n    int32_t *restrict x = (int32_t *)state->data_raw;\n    uint32_t *restrict d = state->data_pp;\n    int32_t xmax = (int32_t)state->xmax;\n    int32_t xmin = (int32_t)state->xmin;\n    uint32_t rsi = strm->rsi * strm->block_size - 1;\n    uint32_t m = UINT64_C(1) << (strm->bits_per_sample - 1);\n    size_t i;\n\n    state->ref = 1;\n    state->ref_sample = x[0];\n    d[0] = 0;\n    x[0] = (x[0] ^ m) - m;\n\n    for (i = 0; i < rsi; i++) {\n        x[i + 1] = (x[i + 1] ^ m) - m;\n        if (x[i + 1] < x[i]) {\n            D = (uint32_t)(x[i] - x[i + 1]);\n            if (D <= (uint32_t)(xmax - x[i]))\n                d[i + 1] = 2 * D - 1;\n            else\n                d[i + 1] = xmax - x[i + 1];\n        } else {\n            D = (uint32_t)(x[i + 1] - x[i]);\n            if (D <= (uint32_t)(x[i] - xmin))\n                d[i + 1] = 2 * D;\n            else\n                d[i + 1] = x[i + 1] - xmin;\n        }\n    }\n    state->uncomp_len = (strm->block_size - 1) * strm->bits_per_sample;\n}", "item_id": 4, "repo": "erget/libaec", "file": "src/encode.c", "last_update_at": "2021-12-18T07:24:33+00:00", "question_id": "d0b1659a157603fbb1de9e19593096df15765aa3_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void preprocess_signed(struct aec_stream *strm)\n{\n    /**\n       Preprocess RSI of signed samples.\n    */\n    uint32_t D;\n    struct internal_state *state = strm->state;\n    int32_t *restrict x = (int32_t *)state->data_raw;\n    uint32_t *restrict d = state->data_pp;\n    int32_t xmax = (int32_t)state->xmax;\n    int32_t xmin = (int32_t)state->xmin;\n    uint32_t rsi = strm->rsi * strm->block_size - 1;\n    uint32_t m = UINT64_C(1) << (strm->bits_per_sample - 1);\n    size_t i;\n    state->ref = 1;\n    state->ref_sample = x[0];\n    d[0] = 0;\n    x[0] = (x[0] ^ m) - m;\n    for (i = 0; i < rsi; i++) {\n        x[i + 1] = (x[i + 1] ^ m) - m;\n        if (x[i + 1] < x[i]) {\n            D = (uint32_t)(x[i] - x[i + 1]);\n            if (D <= (uint32_t)(xmax - x[i]))\n                d[i + 1] = 2 * D - 1;\n            else\n                d[i + 1] = xmax - x[i + 1];\n        } else {\n            D = (uint32_t)(x[i + 1] - x[i]);\n            if (D <= (uint32_t)(x[i] - xmin))\n                d[i + 1] = 2 * D;\n            else\n                d[i + 1] = x[i + 1] - xmin;\n        }\n    }\n    state->uncomp_len = (strm->block_size - 1) * strm->bits_per_sample;\n"]]}
{"hexsha": "3fc0dd8425d900946344e79cc30b7ed6224b10da", "ext": "c", "lang": "C", "content": "void f90(void) {\n    \tint32_t x361 = 3;\n\tint8_t x362 = INT8_MIN;\n\tstatic uint16_t x363 = 44U;\n\tvolatile uint8_t x364 = 10U;\n\tint32_t t90 = 1109;\n\n    t90 = ((x361==x362)<=(x363==x364));\n\n    if (t90 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 90, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1480.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "3fc0dd8425d900946344e79cc30b7ed6224b10da_90", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f90(void) {\n    \tint32_t x361 = 3;\n\tint8_t x362 = INT8_MIN;\n\tstatic uint16_t x363 = 44U;\n\tvolatile uint8_t x364 = 10U;\n\tint32_t t90 = 1109;\n    t90 = ((x361==x362)<=(x363==x364));\n    if (t90 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "51e1d0f91d36845f6a43cf01f31a06532ee6da74", "ext": "c", "lang": "C", "content": "int LHGetMatchedVtx( LHGRAPH graph, int lhsVtx ) {\r\n    Graph     *g;\r\n    Vertex    *lv,*rv;\r\n\r\n    /* Check parameters */\r\n    g = CheckGraph(graph);\r\n    if( NULL==g ) {\r\n        return LH_PARAM_ERR;\r\n    }\r\n    if( lhsVtx<0 || lhsVtx>=g->numLHSVtx ) {\r\n        return LH_PARAM_ERR;\r\n    }\r\n    \r\n    /* Get pointer to left-hand vertex */\r\n    lv = &(g->lVtx[lhsVtx]);\r\n\r\n    /* Find matching partner */\r\n    rv = lv->matchedWith;\r\n    if( rv==NULL ) {\r\n        return LH_MATCHING_ERR;\r\n    }\r\n    \r\n    /* Transform internal ID to external ID */\r\n    return (rv->id - g->numLHSVtx);\r\n}", "item_id": 20, "repo": "npocmaka/Windows-Server-2003", "file": "ds/lhmatch/lhmain.c", "last_update_at": "2021-09-16T09:13:13+00:00", "question_id": "51e1d0f91d36845f6a43cf01f31a06532ee6da74_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int LHGetMatchedVtx( LHGRAPH graph, int lhsVtx ) {\r\n    Graph     *g;\r\n    Vertex    *lv,*rv;\r\n\r\n    /* Check parameters */\r\n    g = CheckGraph(graph);\r\n    if( NULL==g ) {\r\n        return LH_PARAM_ERR;\r\n    }\r\n    if( lhsVtx<0 || lhsVtx>=g->numLHSVtx ) {\r\n        return LH_PARAM_ERR;\r\n    }\r\n    \r\n    /* Get pointer to left-hand vertex */\r\n    lv = &(g->lVtx[lhsVtx]);\r\n\r\n    /* Find matching partner */\r\n    rv = lv->matchedWith;\r\n    if( rv==NULL ) {\r\n        return LH_MATCHING_ERR;\r\n    }\r\n    \r\n    /* Transform internal ID to external ID */\r\n    return (rv->id - g->numLHSVtx);\r\n"]]}
{"hexsha": "79738e013b3e5e9d509bb5ea23217bdc372ecd15", "ext": "c", "lang": "C", "content": "void f179(void) {\n    \tstatic int64_t x717 = 4040370LL;\n\tint16_t x719 = INT16_MIN;\n\tint32_t t179 = -636544292;\n\n    t179 = ((x717<=(x718>x719))!=x720);\n\n    if (t179 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 179, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test1701.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "79738e013b3e5e9d509bb5ea23217bdc372ecd15_179", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f179(void) {\n    \tstatic int64_t x717 = 4040370LL;\n\tint16_t x719 = INT16_MIN;\n\tint32_t t179 = -636544292;\n    t179 = ((x717<=(x718>x719))!=x720);\n    if (t179 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "ac980cb9aa3ea9ad14e39b883edfc98bdba3ac48", "ext": "c", "lang": "C", "content": "void f27(void) {\n    \tuint32_t x109 = UINT32_MAX;\n\tuint32_t x110 = 453942U;\n\tvolatile uint32_t x111 = UINT32_MAX;\n\tstatic int8_t x112 = -1;\n\tstatic volatile int32_t t27 = 1;\n\n    t27 = ((x109&(x110+x111))<=x112);\n\n    if (t27 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 27, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test164.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "ac980cb9aa3ea9ad14e39b883edfc98bdba3ac48_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f27(void) {\n    \tuint32_t x109 = UINT32_MAX;\n\tuint32_t x110 = 453942U;\n\tvolatile uint32_t x111 = UINT32_MAX;\n\tstatic int8_t x112 = -1;\n\tstatic volatile int32_t t27 = 1;\n    t27 = ((x109&(x110+x111))<=x112);\n    if (t27 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "1f791e41e52acaee2d311ea3bd6aef9b0bce1198", "ext": "c", "lang": "C", "content": "void f150(void) {\n    \tvolatile int32_t x797 = 696224;\n\tvolatile uint8_t x799 = UINT8_MAX;\n\tint16_t x800 = 1;\n\tvolatile int32_t t150 = -4388;\n\n    t150 = ((x797&x798)%(x799&x800));\n\n    if (t150 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 150, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test2315.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "1f791e41e52acaee2d311ea3bd6aef9b0bce1198_150", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f150(void) {\n    \tvolatile int32_t x797 = 696224;\n\tvolatile uint8_t x799 = UINT8_MAX;\n\tint16_t x800 = 1;\n\tvolatile int32_t t150 = -4388;\n    t150 = ((x797&x798)%(x799&x800));\n    if (t150 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "5d3b1c533c1f4280e2ef0ae4b119664eb85074cd", "ext": "c", "lang": "C", "content": "void f65(void) {\n    \tint32_t x395 = INT32_MIN;\n\tstatic int16_t x396 = INT16_MAX;\n\tvolatile uint64_t t65 = 1LLU;\n\n    t65 = ((x393%(x394*x395))*x396);\n\n    if (t65 != 11261468142041563256LLU) { NG(); } else { ; }\n\t\n}", "item_id": 65, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test451.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "5d3b1c533c1f4280e2ef0ae4b119664eb85074cd_65", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f65(void) {\n    \tint32_t x395 = INT32_MIN;\n\tstatic int16_t x396 = INT16_MAX;\n\tvolatile uint64_t t65 = 1LLU;\n    t65 = ((x393%(x394*x395))*x396);\n    if (t65 != 11261468142041563256LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "da9d7b46e429fc9f0d6e6953d1a45a4b659f4f09", "ext": "c", "lang": "C", "content": "void f172(void) {\n    \tvolatile uint64_t x721 = UINT64_MAX;\n\tint64_t x722 = INT64_MIN;\n\tstatic int64_t x724 = INT64_MIN;\n\tvolatile uint64_t t172 = UINT64_MAX;\n\n    t172 = (x721+(x722!=(x723&x724)));\n\n    if (t172 != UINT64_MAX) { NG(); } else { ; }\n\t\n}", "item_id": 172, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test2241.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "da9d7b46e429fc9f0d6e6953d1a45a4b659f4f09_172", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f172(void) {\n    \tvolatile uint64_t x721 = UINT64_MAX;\n\tint64_t x722 = INT64_MIN;\n\tstatic int64_t x724 = INT64_MIN;\n\tvolatile uint64_t t172 = UINT64_MAX;\n    t172 = (x721+(x722!=(x723&x724)));\n    if (t172 != UINT64_MAX) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "8ae79584d0ab9413ec98b980b1b45613ae5f14ab", "ext": "c", "lang": "C", "content": "void f161(void) {\n    \tint8_t x1005 = 1;\n\tuint16_t x1006 = UINT16_MAX;\n\tuint16_t x1007 = 5962U;\n\tvolatile int64_t x1008 = INT64_MIN;\n\tint64_t t161 = -8105LL;\n\n    t161 = ((x1005/(x1006%x1007))*x1008);\n\n    if (t161 != 0LL) { NG(); } else { ; }\n\t\n}", "item_id": 161, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test829.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "8ae79584d0ab9413ec98b980b1b45613ae5f14ab_161", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f161(void) {\n    \tint8_t x1005 = 1;\n\tuint16_t x1006 = UINT16_MAX;\n\tuint16_t x1007 = 5962U;\n\tvolatile int64_t x1008 = INT64_MIN;\n\tint64_t t161 = -8105LL;\n    t161 = ((x1005/(x1006%x1007))*x1008);\n    if (t161 != 0LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "434a171f2f7d3fe4293bd9c865b635ce67dbf438", "ext": "c", "lang": "C", "content": "static void destroy(Actor* _actor) {\n  PlayerData* data = (PlayerData*)getActorData(_actor);\n\n  SPR_releaseSprite(data->sprite);\n  free(data);\n}", "item_id": 5, "repo": "devpow112/quantum-burst", "file": "game/src/actors/player.c", "last_update_at": "2021-05-11T13:06:58+00:00", "question_id": "434a171f2f7d3fe4293bd9c865b635ce67dbf438_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void destroy(Actor* _actor) {\n  PlayerData* data = (PlayerData*)getActorData(_actor);\n  SPR_releaseSprite(data->sprite);\n  free(data);\n"]]}
{"hexsha": "4d56aa6bcfa96abea99b9d6ed0e5178a1ec6adbe", "ext": "h", "lang": "C", "content": "class boyerMoore {\n    private:\n        string needle;\n        vector<int> gsv;\n\n        void goodSuffixVec(const string& s, vector<int> &v);\n\n        ssize_t crfind(const string& str, const char c, size_t pos);\n\n    public:\n        boyerMoore(const string& needle);\n\n        bool bmC(const string& haystack);\n}", "item_id": 0, "repo": "njuzpw/Boyer-Moore", "file": "bm.h", "last_update_at": "2021-03-01T09:19:24+00:00", "question_id": "4d56aa6bcfa96abea99b9d6ed0e5178a1ec6adbe_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class boyerMoore {\n    private:\n        string needle;\n        vector<int> gsv;\n        void goodSuffixVec(const string& s, vector<int> &v);\n        ssize_t crfind(const string& str, const char c, size_t pos);\n    public:\n        boyerMoore(const string& needle);\n        bool bmC(const string& haystack);\n"]]}
{"hexsha": "13aa3457ff24c0a178978581cd2d03d52f019076", "ext": "c", "lang": "C", "content": "void WDT_Handler(void)\n {\n\t printf(\"Enter watchdog interrupt.\\r\");\n\t /* Clear status bit to acknowledge interrupt by dummy read. */\n\t wdt_get_status(WDT);\n\t /* Restart the WDT counter. */\n\t wdt_restart(WDT);\n\t printf(\"The watchdog timer was restarted.\\r\");\n\t g_b_systick_event = true;\n }", "item_id": 2, "repo": "PhillyNJ/SAM4S", "file": "wdt/conf_wdt.c", "last_update_at": "2021-02-17T10:04:15+00:00", "question_id": "13aa3457ff24c0a178978581cd2d03d52f019076_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void WDT_Handler(void)\n {\n\t printf(\"Enter watchdog interrupt.\\r\");\n\t /* Clear status bit to acknowledge interrupt by dummy read. */\n\t wdt_get_status(WDT);\n\t /* Restart the WDT counter. */\n\t wdt_restart(WDT);\n\t printf(\"The watchdog timer was restarted.\\r\");\n\t g_b_systick_event = true;\n"]]}
{"hexsha": "cfe5dc9c36758b6bac2ae509a37f90073dda6552", "ext": "c", "lang": "C", "content": "uint32_t coap_message_decode(coap_message_t *       p_message,\r\n                             const uint8_t *        p_raw_message,\r\n                             uint16_t               message_len)\r\n{\r\n    NULL_PARAM_CHECK(p_message);\r\n    NULL_PARAM_CHECK(p_raw_message);\r\n\r\n    // Check that the raw message contains the mandatory header.\r\n    if (message_len < 4)\r\n    {\r\n        return (NRF_ERROR_INVALID_LENGTH | IOT_COAP_ERR_BASE);\r\n    }\r\n\r\n    // Parse the content of the raw message buffer.\r\n    uint16_t byte_index = 0;\r\n\r\n    // Parse the 4 byte CoAP header.\r\n    p_message->header.version   = (p_raw_message[byte_index] >> 6);\r\n    p_message->header.type      = (coap_msg_type_t)((p_raw_message[byte_index] >> 4) & 0x03);\r\n    p_message->header.token_len = (p_raw_message[byte_index] & 0x0F);\r\n    byte_index++;\r\n\r\n    p_message->header.code      = (coap_msg_code_t)p_raw_message[byte_index];\r\n    byte_index++;\r\n\r\n    p_message->header.id        = p_raw_message[byte_index++] << 8;\r\n    p_message->header.id       += p_raw_message[byte_index++];\r\n\r\n    // Parse the token, if any.\r\n    for (uint8_t index = 0; (byte_index < message_len) && (index < p_message->header.token_len); index++)\r\n    {\r\n        p_message->token[index]  = p_raw_message[byte_index++];\r\n    }\r\n\r\n    p_message->options_count = 0;\r\n    p_message->options_delta = 0;\r\n\r\n    // Parse the options if any.\r\n    while ((byte_index < message_len) && (p_raw_message[byte_index] != COAP_PAYLOAD_MARKER))\r\n    {\r\n\r\n        uint32_t err_code;\r\n        uint16_t byte_count = 0;\r\n\r\n        err_code = decode_option(&p_raw_message[byte_index], p_message, &byte_count);\r\n        if (err_code != NRF_SUCCESS)\r\n        {\r\n            return err_code;\r\n        }\r\n\r\n        p_message->options_count += 1;\r\n\r\n        byte_index += byte_count;\r\n    }\r\n\r\n    // If there any more bytes to parse this would be the payload.\r\n    if (byte_index < message_len)\r\n    {\r\n        // Verify that we have a payload marker.\r\n        if (p_raw_message[byte_index] == COAP_PAYLOAD_MARKER)\r\n        {\r\n            byte_index++;\r\n        }\r\n        else\r\n        {\r\n            return COAP_MESSAGE_INVALID_CONTENT;\r\n        }\r\n\r\n        p_message->payload_len = message_len - byte_index;\r\n        p_message->p_payload = (uint8_t *)&p_raw_message[byte_index];\r\n    }\r\n\r\n    return NRF_SUCCESS;\r\n}", "item_id": 4, "repo": "jinlongliu/AliOS-Things", "file": "platform/mcu/nrf52xxx/Drivers/iot/coap/coap_message.c", "last_update_at": "2021-09-20T14:45:49+00:00", "question_id": "cfe5dc9c36758b6bac2ae509a37f90073dda6552_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint32_t coap_message_decode(coap_message_t *       p_message,\r\n                             const uint8_t *        p_raw_message,\r\n                             uint16_t               message_len)\r\n{\r\n    NULL_PARAM_CHECK(p_message);\r\n    NULL_PARAM_CHECK(p_raw_message);\r\n\r\n    // Check that the raw message contains the mandatory header.\r\n    if (message_len < 4)\r\n    {\r\n        return (NRF_ERROR_INVALID_LENGTH | IOT_COAP_ERR_BASE);\r\n    }\r\n\r\n    // Parse the content of the raw message buffer.\r\n    uint16_t byte_index = 0;\r\n\r\n    // Parse the 4 byte CoAP header.\r\n    p_message->header.version   = (p_raw_message[byte_index] >> 6);\r\n    p_message->header.type      = (coap_msg_type_t)((p_raw_message[byte_index] >> 4) & 0x03);\r\n    p_message->header.token_len = (p_raw_message[byte_index] & 0x0F);\r\n    byte_index++;\r\n\r\n    p_message->header.code      = (coap_msg_code_t)p_raw_message[byte_index];\r\n    byte_index++;\r\n\r\n    p_message->header.id        = p_raw_message[byte_index++] << 8;\r\n    p_message->header.id       += p_raw_message[byte_index++];\r\n\r\n    // Parse the token, if any.\r\n    for (uint8_t index = 0; (byte_index < message_len) && (index < p_message->header.token_len); index++)\r\n    {\r\n        p_message->token[index]  = p_raw_message[byte_index++];\r\n    }\r\n\r\n    p_message->options_count = 0;\r\n    p_message->options_delta = 0;\r\n\r\n    // Parse the options if any.\r\n    while ((byte_index < message_len) && (p_raw_message[byte_index] != COAP_PAYLOAD_MARKER))\r\n    {\r\n\r\n        uint32_t err_code;\r\n        uint16_t byte_count = 0;\r\n\r\n        err_code = decode_option(&p_raw_message[byte_index], p_message, &byte_count);\r\n        if (err_code != NRF_SUCCESS)\r\n        {\r\n            return err_code;\r\n        }\r\n\r\n        p_message->options_count += 1;\r\n\r\n        byte_index += byte_count;\r\n    }\r\n\r\n    // If there any more bytes to parse this would be the payload.\r\n    if (byte_index < message_len)\r\n    {\r\n        // Verify that we have a payload marker.\r\n        if (p_raw_message[byte_index] == COAP_PAYLOAD_MARKER)\r\n        {\r\n            byte_index++;\r\n        }\r\n        else\r\n        {\r\n            return COAP_MESSAGE_INVALID_CONTENT;\r\n        }\r\n\r\n        p_message->payload_len = message_len - byte_index;\r\n        p_message->p_payload = (uint8_t *)&p_raw_message[byte_index];\r\n    }\r\n\r\n    return NRF_SUCCESS;\r\n"]]}
{"hexsha": "42713b967ecb3329dce6b549faeaca87bfe0df9e", "ext": "c", "lang": "C", "content": "void f180(void) {\n    \tstatic int8_t x721 = INT8_MIN;\n\tint16_t x722 = INT16_MIN;\n\tint64_t x723 = -370LL;\n\tstatic uint64_t x724 = 756676372819220LLU;\n\tint32_t t180 = 1;\n\n    t180 = (x721>(x722==(x723^x724)));\n\n    if (t180 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 180, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test2655.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "42713b967ecb3329dce6b549faeaca87bfe0df9e_180", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f180(void) {\n    \tstatic int8_t x721 = INT8_MIN;\n\tint16_t x722 = INT16_MIN;\n\tint64_t x723 = -370LL;\n\tstatic uint64_t x724 = 756676372819220LLU;\n\tint32_t t180 = 1;\n    t180 = (x721>(x722==(x723^x724)));\n    if (t180 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "c039a541a9582a3da5aa1355c493c1cb638b5df2", "ext": "c", "lang": "C", "content": "void f150(void) {\n    \tstatic int16_t x621 = -1;\n\tvolatile uint64_t x622 = UINT64_MAX;\n\tstatic int16_t x623 = INT16_MAX;\n\tuint32_t x624 = UINT32_MAX;\n\tuint64_t t150 = 117257589722LLU;\n\n    t150 = (x621^((x622/x623)&x624));\n\n    if (t150 != 18446744073709027311LLU) { NG(); } else { ; }\n\t\n}", "item_id": 150, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test756.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "c039a541a9582a3da5aa1355c493c1cb638b5df2_150", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f150(void) {\n    \tstatic int16_t x621 = -1;\n\tvolatile uint64_t x622 = UINT64_MAX;\n\tstatic int16_t x623 = INT16_MAX;\n\tuint32_t x624 = UINT32_MAX;\n\tuint64_t t150 = 117257589722LLU;\n    t150 = (x621^((x622/x623)&x624));\n    if (t150 != 18446744073709027311LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "1763d91900b88518dd189b5baa83354292b1a1ed", "ext": "c", "lang": "C", "content": "void f183(void) {\n    \tuint32_t x734 = 44975U;\n\tstatic int16_t x735 = -566;\n\tvolatile int16_t x736 = INT16_MAX;\n\tstatic uint32_t t183 = 378073U;\n\n    t183 = (x733&(x734*(x735>x736)));\n\n    if (t183 != 0U) { NG(); } else { ; }\n\t\n}", "item_id": 183, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test1608.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "1763d91900b88518dd189b5baa83354292b1a1ed_183", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f183(void) {\n    \tuint32_t x734 = 44975U;\n\tstatic int16_t x735 = -566;\n\tvolatile int16_t x736 = INT16_MAX;\n\tstatic uint32_t t183 = 378073U;\n    t183 = (x733&(x734*(x735>x736)));\n    if (t183 != 0U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "4e30af2a07eb0f3b22537b50180f87d7a0ddca82", "ext": "c", "lang": "C", "content": "int HelloHCopy_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n\n    if (argc != 4) return RedisModule_WrongArity(ctx);\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    int type = RedisModule_KeyType(key);\n    if (type != REDISMODULE_KEYTYPE_HASH &&\n        type != REDISMODULE_KEYTYPE_EMPTY)\n    {\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n    }\n\n    /* Get the old field value. */\n    RedisModuleString *oldval;\n    RedisModule_HashGet(key,REDISMODULE_HASH_NONE,argv[2],&oldval,NULL);\n    if (oldval) {\n        RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[3],oldval,NULL);\n    }\n    RedisModule_ReplyWithLongLong(ctx,oldval != NULL);\n    return REDISMODULE_OK;\n}", "item_id": 14, "repo": "zearom32/redis", "file": "src/modules/helloworld.c", "last_update_at": "2021-11-14T17:28:38+00:00", "question_id": "4e30af2a07eb0f3b22537b50180f87d7a0ddca82_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int HelloHCopy_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n    if (argc != 4) return RedisModule_WrongArity(ctx);\n    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n        REDISMODULE_READ|REDISMODULE_WRITE);\n    int type = RedisModule_KeyType(key);\n    if (type != REDISMODULE_KEYTYPE_HASH &&\n        type != REDISMODULE_KEYTYPE_EMPTY)\n    {\n        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n    }\n    /* Get the old field value. */\n    RedisModuleString *oldval;\n    RedisModule_HashGet(key,REDISMODULE_HASH_NONE,argv[2],&oldval,NULL);\n    if (oldval) {\n        RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[3],oldval,NULL);\n    }\n    RedisModule_ReplyWithLongLong(ctx,oldval != NULL);\n    return REDISMODULE_OK;\n"]]}
{"hexsha": "040be8b9ab2ead6709dc8234134b7803e0c30e6a", "ext": "c", "lang": "C", "content": "bool\nnav_msgs__srv__GetMap_Request__Sequence__init(nav_msgs__srv__GetMap_Request__Sequence * array, size_t size)\n{\n  if (!array) {\n    return false;\n  }\n  nav_msgs__srv__GetMap_Request * data = NULL;\n  if (size) {\n    data = (nav_msgs__srv__GetMap_Request *)calloc(size, sizeof(nav_msgs__srv__GetMap_Request));\n    if (!data) {\n      return false;\n    }\n    // initialize all array elements\n    size_t i;\n    for (i = 0; i < size; ++i) {\n      bool success = nav_msgs__srv__GetMap_Request__init(&data[i]);\n      if (!success) {\n        break;\n      }\n    }\n    if (i < size) {\n      // if initialization failed finalize the already initialized array elements\n      for (; i > 0; --i) {\n        nav_msgs__srv__GetMap_Request__fini(&data[i - 1]);\n      }\n      free(data);\n      return false;\n    }\n  }\n  array->data = data;\n  array->size = size;\n  array->capacity = size;\n  return true;\n}", "item_id": 2, "repo": "artivis/micro_ros_raspberrypi_pico_sdk", "file": "uros_ws/firmware/build/include/nav_msgs/srv/detail/get_map__functions.c", "last_update_at": "2021-11-25T19:07:52+00:00", "question_id": "040be8b9ab2ead6709dc8234134b7803e0c30e6a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool\nnav_msgs__srv__GetMap_Request__Sequence__init(nav_msgs__srv__GetMap_Request__Sequence * array, size_t size)\n{\n  if (!array) {\n    return false;\n  }\n  nav_msgs__srv__GetMap_Request * data = NULL;\n  if (size) {\n    data = (nav_msgs__srv__GetMap_Request *)calloc(size, sizeof(nav_msgs__srv__GetMap_Request));\n    if (!data) {\n      return false;\n    }\n    // initialize all array elements\n    size_t i;\n    for (i = 0; i < size; ++i) {\n      bool success = nav_msgs__srv__GetMap_Request__init(&data[i]);\n      if (!success) {\n        break;\n      }\n    }\n    if (i < size) {\n      // if initialization failed finalize the already initialized array elements\n      for (; i > 0; --i) {\n        nav_msgs__srv__GetMap_Request__fini(&data[i - 1]);\n      }\n      free(data);\n      return false;\n    }\n  }\n  array->data = data;\n  array->size = size;\n  array->capacity = size;\n  return true;\n"]]}
{"hexsha": "44eb386b1926771041b54c520fca6dc8c41b3f2e", "ext": "c", "lang": "C", "content": "int chandev_add_schib_info(int irq,chandev_subchannel_info *sch)\n{\n\tschib_t *new_schib;\n\t\n\tif((new_schib=s390_get_schib(irq)))\n\t{\n\t\tsch->pim=new_schib->pmcw.pim;\n\t\tmemcpy(&sch->chpid,&new_schib->pmcw.chpid,sizeof(sch->chpid));\n\t\treturn(0);\n\t}\n\treturn(-ENODEV);\n}", "item_id": 22, "repo": "enfoTek/tomato.linksys.e2000.nvram-mod", "file": "release/src/linux/linux/drivers/s390/misc/chandev.c", "last_update_at": "2021-06-07T06:29:49+00:00", "question_id": "44eb386b1926771041b54c520fca6dc8c41b3f2e_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int chandev_add_schib_info(int irq,chandev_subchannel_info *sch)\n{\n\tschib_t *new_schib;\n\t\n\tif((new_schib=s390_get_schib(irq)))\n\t{\n\t\tsch->pim=new_schib->pmcw.pim;\n\t\tmemcpy(&sch->chpid,&new_schib->pmcw.chpid,sizeof(sch->chpid));\n\t\treturn(0);\n\t}\n\treturn(-ENODEV);\n"]]}
{"hexsha": "7be8d72bc0671ffd53cc26b00809b66a0c288b11", "ext": "c", "lang": "C", "content": "void f49(void) {\n    \tuint32_t x421 = 1587U;\n\tint8_t x422 = INT8_MIN;\n\tuint16_t x423 = 3576U;\n\tuint32_t t49 = 3U;\n\n    t49 = (x421>>(x422!=(x423%x424)));\n\n    if (t49 != 793U) { NG(); } else { ; }\n\t\n}", "item_id": 49, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test879.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "7be8d72bc0671ffd53cc26b00809b66a0c288b11_49", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f49(void) {\n    \tuint32_t x421 = 1587U;\n\tint8_t x422 = INT8_MIN;\n\tuint16_t x423 = 3576U;\n\tuint32_t t49 = 3U;\n    t49 = (x421>>(x422!=(x423%x424)));\n    if (t49 != 793U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "9ad7cdaac9b2326c83825023a0287f7f465e4115", "ext": "c", "lang": "C", "content": "static int8_t get_wrist_gest_config(struct bmi2_wrist_gest_config *config, struct bmi2_dev *dev)\r\n{\r\n    /* Variable to define error */\r\n    int8_t rslt;\r\n\r\n    /* Array to define the feature configuration */\r\n    uint8_t feat_config[BMI2_FEAT_SIZE_IN_BYTES] = { 0 };\r\n\r\n    /* Variable to define the array offset */\r\n    uint8_t idx = 0;\r\n\r\n    /* Variable to set flag */\r\n    uint8_t feat_found;\r\n\r\n    /* Initialize feature configuration for wrist gesture */\r\n    struct bmi2_feature_config wrist_gest_config = { 0, 0, 0 };\r\n\r\n    /* Copy the feature configuration address to a local pointer */\r\n    uint16_t *data_p = (uint16_t *) (void *)feat_config;\r\n\r\n    /* Search for wrist gesture feature and extract its configuration details */\r\n    feat_found = bmi2_extract_input_feat_config(&wrist_gest_config, BMI2_WRIST_GESTURE, dev);\r\n    if (feat_found)\r\n    {\r\n        /* Get the configuration from the page where wrist gesture feature  resides */\r\n        rslt = bmi2_get_feat_config(wrist_gest_config.page, feat_config, dev);\r\n        if (rslt == BMI2_OK)\r\n        {\r\n            /* Define the offset in bytes for wrist gesture select */\r\n            idx = wrist_gest_config.start_addr;\r\n\r\n            /* Get offset in words since all the features are set in words length */\r\n            idx = idx / 2;\r\n\r\n            /* Get wearable arm */\r\n            config->wearable_arm = (*(data_p + idx) & BMI2_WRIST_GEST_WEAR_ARM_MASK) >> BMI2_WRIST_GEST_WEAR_ARM_POS;\r\n\r\n            /* Increment the offset by 1 word to get min_flick_peak */\r\n            idx++;\r\n            config->min_flick_peak = *(data_p + idx);\r\n\r\n            /* Increment the offset by 1 word to get min_flick_samples */\r\n            idx++;\r\n            config->min_flick_samples = *(data_p + idx);\r\n\r\n            /* Increment the offset by 1 word to get max_duration */\r\n            idx++;\r\n            config->max_duration = *(data_p + idx);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        rslt = BMI2_E_INVALID_SENSOR;\r\n    }\r\n\r\n    return rslt;\r\n}", "item_id": 35, "repo": "halter-corp/BMI270-Sensor-API", "file": "bmi270.c", "last_update_at": "2021-11-03T21:59:49+00:00", "question_id": "9ad7cdaac9b2326c83825023a0287f7f465e4115_35", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int8_t get_wrist_gest_config(struct bmi2_wrist_gest_config *config, struct bmi2_dev *dev)\r\n{\r\n    /* Variable to define error */\r\n    int8_t rslt;\r\n\r\n    /* Array to define the feature configuration */\r\n    uint8_t feat_config[BMI2_FEAT_SIZE_IN_BYTES] = { 0 };\r\n\r\n    /* Variable to define the array offset */\r\n    uint8_t idx = 0;\r\n\r\n    /* Variable to set flag */\r\n    uint8_t feat_found;\r\n\r\n    /* Initialize feature configuration for wrist gesture */\r\n    struct bmi2_feature_config wrist_gest_config = { 0, 0, 0 };\r\n\r\n    /* Copy the feature configuration address to a local pointer */\r\n    uint16_t *data_p = (uint16_t *) (void *)feat_config;\r\n\r\n    /* Search for wrist gesture feature and extract its configuration details */\r\n    feat_found = bmi2_extract_input_feat_config(&wrist_gest_config, BMI2_WRIST_GESTURE, dev);\r\n    if (feat_found)\r\n    {\r\n        /* Get the configuration from the page where wrist gesture feature  resides */\r\n        rslt = bmi2_get_feat_config(wrist_gest_config.page, feat_config, dev);\r\n        if (rslt == BMI2_OK)\r\n        {\r\n            /* Define the offset in bytes for wrist gesture select */\r\n            idx = wrist_gest_config.start_addr;\r\n\r\n            /* Get offset in words since all the features are set in words length */\r\n            idx = idx / 2;\r\n\r\n            /* Get wearable arm */\r\n            config->wearable_arm = (*(data_p + idx) & BMI2_WRIST_GEST_WEAR_ARM_MASK) >> BMI2_WRIST_GEST_WEAR_ARM_POS;\r\n\r\n            /* Increment the offset by 1 word to get min_flick_peak */\r\n            idx++;\r\n            config->min_flick_peak = *(data_p + idx);\r\n\r\n            /* Increment the offset by 1 word to get min_flick_samples */\r\n            idx++;\r\n            config->min_flick_samples = *(data_p + idx);\r\n\r\n            /* Increment the offset by 1 word to get max_duration */\r\n            idx++;\r\n            config->max_duration = *(data_p + idx);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        rslt = BMI2_E_INVALID_SENSOR;\r\n    }\r\n\r\n    return rslt;\r\n"]]}
{"hexsha": "d184469f515af0f3aca312179aea8b27a1819102", "ext": "c", "lang": "C", "content": "void f186(void) {\n    \tstatic volatile int16_t x777 = -1;\n\tint16_t x778 = INT16_MIN;\n\tint32_t x780 = -1;\n\tint32_t t186 = 563;\n\n    t186 = ((x777^x778)|(x779%x780));\n\n    if (t186 != 32767) { NG(); } else { ; }\n\t\n}", "item_id": 186, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test979.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "d184469f515af0f3aca312179aea8b27a1819102_186", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f186(void) {\n    \tstatic volatile int16_t x777 = -1;\n\tint16_t x778 = INT16_MIN;\n\tint32_t x780 = -1;\n\tint32_t t186 = 563;\n    t186 = ((x777^x778)|(x779%x780));\n    if (t186 != 32767) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "79c93f34211665714c2c2d5dee58cb1d3e4b02b0", "ext": "c", "lang": "C", "content": "extern void ora_instr(sqlite3_context  *context,\n                      int               argc,\n                      sqlite3_value   **argv) {\n   int start = 1;\n   int occ = 1;\n\n   // checks for correct number of arguments\n   _ksu_check_arg_cnt(argc, 2, 4, \"instr\");\n   if (ksu_prm_ok(context, argc, argv, \"instr\",\n                  KSU_PRM_TEXT, KSU_PRM_TEXT,\n                  KSU_PRM_INT_NOT_0, KSU_PRM_INT_GT_0)) {\n      if (argc >= 3) {\n         start = sqlite3_value_int(argv[2]);\n      }\n      if (argc == 4) {\n         occ = sqlite3_value_int(argv[3]);\n      }\n\n      //VARIABLES!!!!\n      int            pos;\n      int            count = 0;\n      int            i;\n      unsigned char *line = (unsigned char *)sqlite3_value_text(argv[0]);\n      unsigned char *comp = (unsigned char *)sqlite3_value_text(argv[1]);\n      int            len = strlen((char *)comp);\n      //end variables...\n      // Goes character by character and checks whether it matches\n      // the string to match. if it does, it increments count, if\n      // count=the occurrence variable, it returns position\n      if (start > 0) {\n         int comp2;\n         int startbyte;\n\n         startbyte = ksu_charpos_to_bytes(line, start - 1);\n         if (startbyte == -1) {\n            ksu_err_msg(context, KSU_ERR_INV_UTF8, \"instr\");\n            return;\n         }\n         line = &(line[startbyte]);\n         pos = start;\n         for (i = 0; i < strlen((char *)line); i++) {\n            comp2 = strncmp((char *)&(line[i]), (char *)comp, len);\n            if (comp2 == 0) {\n               count++;\n               if (count == occ) {\n                  pos = ksu_charpos_to_bytes((unsigned char *)line, pos);\n                  sqlite3_result_int(context, pos);\n                  return;\n               }\n            }\n            pos++;\n         }\n      } else {\n         unsigned char *p = &(line[strlen((char *)line) - 1 ]);\n         i = 0;\n         start = -1 * start;\n         while ((p > line) && (i < start)) {\n            _ksu_utf8_decr(p);\n            i++;\n         }\n         if (i == start) {\n            pos = p - line;\n            for (i = p - line; i > 0; i--) {\n               if (!strncmp((char *)&(line[i]), (char *)comp, len)) {\n                  count++;\n                  if (count == occ) {\n                     pos = ksu_charpos_to_bytes((unsigned char *)line, pos);\n                     pos++;\n                     sqlite3_result_int(context, pos);\n                     return;\n                  }\n               }\n               pos--;\n            }\n         }\n      }\n      sqlite3_result_int(context, 0);\n    }\n}", "item_id": 0, "repo": "sfaroult/sqlite_libs", "file": "ora/CHAR_RETURNING_NUM/ora_instr.c", "last_update_at": "2021-04-04T00:18:44+00:00", "question_id": "79c93f34211665714c2c2d5dee58cb1d3e4b02b0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["extern void ora_instr(sqlite3_context  *context,\n                      int               argc,\n                      sqlite3_value   **argv) {\n   int start = 1;\n   int occ = 1;\n   // checks for correct number of arguments\n   _ksu_check_arg_cnt(argc, 2, 4, \"instr\");\n   if (ksu_prm_ok(context, argc, argv, \"instr\",\n                  KSU_PRM_TEXT, KSU_PRM_TEXT,\n                  KSU_PRM_INT_NOT_0, KSU_PRM_INT_GT_0)) {\n      if (argc >= 3) {\n         start = sqlite3_value_int(argv[2]);\n      }\n      if (argc == 4) {\n         occ = sqlite3_value_int(argv[3]);\n      }\n      //VARIABLES!!!!\n      int            pos;\n      int            count = 0;\n      int            i;\n      unsigned char *line = (unsigned char *)sqlite3_value_text(argv[0]);\n      unsigned char *comp = (unsigned char *)sqlite3_value_text(argv[1]);\n      int            len = strlen((char *)comp);\n      //end variables...\n      // Goes character by character and checks whether it matches\n      // the string to match. if it does, it increments count, if\n      // count=the occurrence variable, it returns position\n      if (start > 0) {\n         int comp2;\n         int startbyte;\n         startbyte = ksu_charpos_to_bytes(line, start - 1);\n         if (startbyte == -1) {\n            ksu_err_msg(context, KSU_ERR_INV_UTF8, \"instr\");\n            return;\n         }\n         line = &(line[startbyte]);\n         pos = start;\n         for (i = 0; i < strlen((char *)line); i++) {\n            comp2 = strncmp((char *)&(line[i]), (char *)comp, len);\n            if (comp2 == 0) {\n               count++;\n               if (count == occ) {\n                  pos = ksu_charpos_to_bytes((unsigned char *)line, pos);\n                  sqlite3_result_int(context, pos);\n                  return;\n               }\n            }\n            pos++;\n         }\n      } else {\n         unsigned char *p = &(line[strlen((char *)line) - 1 ]);\n         i = 0;\n         start = -1 * start;\n         while ((p > line) && (i < start)) {\n            _ksu_utf8_decr(p);\n            i++;\n         }\n         if (i == start) {\n            pos = p - line;\n            for (i = p - line; i > 0; i--) {\n               if (!strncmp((char *)&(line[i]), (char *)comp, len)) {\n                  count++;\n                  if (count == occ) {\n                     pos = ksu_charpos_to_bytes((unsigned char *)line, pos);\n                     pos++;\n                     sqlite3_result_int(context, pos);\n                     return;\n                  }\n               }\n               pos--;\n            }\n         }\n      }\n      sqlite3_result_int(context, 0);\n    }\n"]]}
{"hexsha": "3c0d6f29140e92193dffb1b517eaca6b8017d1e3", "ext": "c", "lang": "C", "content": "libnet_ptag_t\nlibnet_build_ethernet(u_int8_t *dst, u_int8_t *src, u_int16_t type, \nu_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)\n{\n    u_int32_t n, h;\n    libnet_pblock_t *p;\n    struct libnet_ethernet_hdr eth_hdr;\n\n    if (l == NULL)\n    { \n        return (-1);\n    } \n\n    /* sanity check injection type if we're not in advanced mode */\n    if (l->injection_type != LIBNET_LINK &&\n            !(((l->injection_type) & LIBNET_ADV_MASK)))\n    {\n         snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n            \"%s(): called with non-link layer wire injection primitive\",\n                    __func__);\n        p = NULL;\n        goto bad;\n    }\n\n    n = LIBNET_ETH_H + payload_s;\n    h = 0;\n \n    /*\n     *  Find the existing protocol block if a ptag is specified, or create\n     *  a new one.\n     */\n    p = libnet_pblock_probe(l, ptag, n, LIBNET_PBLOCK_ETH_H);\n    if (p == NULL)\n    {\n        return (-1);\n    }\n\n    memset(&eth_hdr, 0, sizeof(eth_hdr));\n    memcpy(eth_hdr.ether_dhost, dst, ETHER_ADDR_LEN);  /* destination address */\n    memcpy(eth_hdr.ether_shost, src, ETHER_ADDR_LEN);  /* source address */\n    eth_hdr.ether_type = htons(type);                  /* packet type */\n\n    n = libnet_pblock_append(l, p, (u_int8_t *)&eth_hdr, LIBNET_ETH_H);\n    if (n == -1)\n    {\n        goto bad;\n    }\n\n    /* boilerplate payload sanity check / append macro */\n    LIBNET_DO_PAYLOAD(l, p);\n \n    return (ptag ? ptag : libnet_pblock_update(l, p, h, LIBNET_PBLOCK_ETH_H));\nbad:\n    libnet_pblock_delete(l, p);\n    return (-1);\n}", "item_id": 0, "repo": "mschiffm/libnet", "file": "src/libnet_build_ethernet.c", "last_update_at": "2021-12-07T19:47:01+00:00", "question_id": "3c0d6f29140e92193dffb1b517eaca6b8017d1e3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["libnet_ptag_t\nlibnet_build_ethernet(u_int8_t *dst, u_int8_t *src, u_int16_t type, \nu_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)\n{\n    u_int32_t n, h;\n    libnet_pblock_t *p;\n    struct libnet_ethernet_hdr eth_hdr;\n    if (l == NULL)\n    { \n        return (-1);\n    } \n    /* sanity check injection type if we're not in advanced mode */\n    if (l->injection_type != LIBNET_LINK &&\n            !(((l->injection_type) & LIBNET_ADV_MASK)))\n    {\n         snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,\n            \"%s(): called with non-link layer wire injection primitive\",\n                    __func__);\n        p = NULL;\n        goto bad;\n    }\n    n = LIBNET_ETH_H + payload_s;\n    h = 0;\n    /*\n     *  Find the existing protocol block if a ptag is specified, or create\n     *  a new one.\n     */\n    p = libnet_pblock_probe(l, ptag, n, LIBNET_PBLOCK_ETH_H);\n    if (p == NULL)\n    {\n        return (-1);\n    }\n    memset(&eth_hdr, 0, sizeof(eth_hdr));\n    memcpy(eth_hdr.ether_dhost, dst, ETHER_ADDR_LEN);  /* destination address */\n    memcpy(eth_hdr.ether_shost, src, ETHER_ADDR_LEN);  /* source address */\n    eth_hdr.ether_type = htons(type);                  /* packet type */\n    n = libnet_pblock_append(l, p, (u_int8_t *)&eth_hdr, LIBNET_ETH_H);\n    if (n == -1)\n    {\n        goto bad;\n    }\n    /* boilerplate payload sanity check / append macro */\n    LIBNET_DO_PAYLOAD(l, p);\n    return (ptag ? ptag : libnet_pblock_update(l, p, h, LIBNET_PBLOCK_ETH_H));\nbad:\n    libnet_pblock_delete(l, p);\n    return (-1);\n"]]}
{"hexsha": "cfc9e595b7c4e9ba56fec4034c360bf0a9320619", "ext": "c", "lang": "C", "content": "static UShort get_UShort ( Cursor* c ) {\n   UShort r;\n   vg_assert(is_sane_Cursor(c));\n   if (c->sli_next + sizeof(UShort) > c->sli.ioff + c->sli.szB) {\n      c->barf(c->barfstr);\n      /*NOTREACHED*/\n      vg_assert(0);\n   }\n   r = ML_(img_get_UShort)(c->sli.img, c->sli_next);\n   c->sli_next += sizeof(UShort);\n   return r;\n}", "item_id": 3, "repo": "ambadhan/OnlinePythonTutor", "file": "v4-cokapi/backends/c_cpp/valgrind-3.11.0/coregrind/m_debuginfo/readdwarf3.c", "last_update_at": "2021-12-29T03:07:14+00:00", "question_id": "cfc9e595b7c4e9ba56fec4034c360bf0a9320619_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static UShort get_UShort ( Cursor* c ) {\n   UShort r;\n   vg_assert(is_sane_Cursor(c));\n   if (c->sli_next + sizeof(UShort) > c->sli.ioff + c->sli.szB) {\n      c->barf(c->barfstr);\n      /*NOTREACHED*/\n      vg_assert(0);\n   }\n   r = ML_(img_get_UShort)(c->sli.img, c->sli_next);\n   c->sli_next += sizeof(UShort);\n   return r;\n"]]}
{"hexsha": "8d6c65a25dd54e15a2b783ace79a40bd426e7351", "ext": "c", "lang": "C", "content": "psd_int64_t\npsdDescriptorValueGetInt64(const psd_descriptor_value_t *value)\n{\n    psd_descriptor_key_t key;\n    if (psd_is_not_null(value)) {\n        key = value->key;\n        if (psd_likely(key == PSD_DESCRIPTOR_LARGE_INT)) {\n            return value->u.lval;\n        }\n        else if (key == PSD_DESCRIPTOR_INT) {\n            return value->u.ival;\n        }\n        else if (key == PSD_DESCRIPTOR_BOOL) {\n            return value->u.bval ? 1 : 0;\n        }\n        else if (key == PSD_DESCRIPTOR_DOUBLE) {\n            return (psd_int64_t) value->u.dval;\n        }\n        else if (key == PSD_DESCRIPTOR_UNIT_DOUBLE || key == PSD_DESCRIPTOR_UNIT_FLOAT) {\n            return (psd_int64_t) value->u.uval.value;\n        }\n        else if (key == PSD_DESCRIPTOR_UNICODE_TEXT) {\n            return (psd_int64_t) strtoll(value->u.text, 0, 10);\n        }\n    }\n    return 0;\n}", "item_id": 15, "repo": "hkrn/psd.c", "file": "psd.c", "last_update_at": "2021-03-10T03:45:37+00:00", "question_id": "8d6c65a25dd54e15a2b783ace79a40bd426e7351_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["psd_int64_t\npsdDescriptorValueGetInt64(const psd_descriptor_value_t *value)\n{\n    psd_descriptor_key_t key;\n    if (psd_is_not_null(value)) {\n        key = value->key;\n        if (psd_likely(key == PSD_DESCRIPTOR_LARGE_INT)) {\n            return value->u.lval;\n        }\n        else if (key == PSD_DESCRIPTOR_INT) {\n            return value->u.ival;\n        }\n        else if (key == PSD_DESCRIPTOR_BOOL) {\n            return value->u.bval ? 1 : 0;\n        }\n        else if (key == PSD_DESCRIPTOR_DOUBLE) {\n            return (psd_int64_t) value->u.dval;\n        }\n        else if (key == PSD_DESCRIPTOR_UNIT_DOUBLE || key == PSD_DESCRIPTOR_UNIT_FLOAT) {\n            return (psd_int64_t) value->u.uval.value;\n        }\n        else if (key == PSD_DESCRIPTOR_UNICODE_TEXT) {\n            return (psd_int64_t) strtoll(value->u.text, 0, 10);\n        }\n    }\n    return 0;\n"]]}
{"hexsha": "eb21b8a509d7abce736cd56822826858fe5939c9", "ext": "c", "lang": "C", "content": "FT_LOCAL_DEF(FT_Error)\ncff_index_access_element(CFF_Index idx,\n                         FT_UInt element,\n                         FT_Byte **pbytes,\n                         FT_ULong *pbyte_len) {\n    FT_Error error = FT_Err_Ok;\n\n\n    if (idx && idx->count > element) {\n        /* compute start and end offsets */\n        FT_Stream stream = idx->stream;\n        FT_ULong off1, off2 = 0;\n\n\n        /* load offsets from file or the offset table */\n        if (!idx->offsets) {\n            FT_ULong pos = element * idx->off_size;\n\n\n            if (FT_STREAM_SEEK(idx->start + 3 + pos))\n                goto Exit;\n\n            off1 = cff_index_read_offset(idx, &error);\n            if (error)\n                goto Exit;\n\n            if (off1 != 0) {\n                do {\n                    element++;\n                    off2 = cff_index_read_offset(idx, &error);\n                } while (off2 == 0 && element < idx->count);\n            }\n        } else   /* use offsets table */\n        {\n            off1 = idx->offsets[element];\n            if (off1) {\n                do {\n                    element++;\n                    off2 = idx->offsets[element];\n\n                } while (off2 == 0 && element < idx->count);\n            }\n        }\n\n        /* XXX: should check off2 does not exceed the end of this entry; */\n        /*      at present, only truncate off2 at the end of this stream */\n        if (off2 > stream->size + 1 ||\n            idx->data_offset > stream->size - off2 + 1) {\n            FT_ERROR((\"cff_index_access_element:\"\n                      \" offset to next entry (%d)\"\n                      \" exceeds the end of stream (%d)\\n\",\n                    off2, stream->size - idx->data_offset + 1));\n            off2 = stream->size - idx->data_offset + 1;\n        }\n\n        /* access element */\n        if (off1 && off2 > off1) {\n            *pbyte_len = off2 - off1;\n\n            if (idx->bytes) {\n                /* this index was completely loaded in memory, that's easy */\n                *pbytes = idx->bytes + off1 - 1;\n            } else {\n                /* this index is still on disk/file, access it through a frame */\n                if (FT_STREAM_SEEK(idx->data_offset + off1 - 1) ||\n                    FT_FRAME_EXTRACT(off2 - off1, *pbytes))\n                    goto Exit;\n            }\n        } else {\n            /* empty index element */\n            *pbytes = 0;\n            *pbyte_len = 0;\n        }\n    } else\n        error = FT_THROW(Invalid_Argument);\n\n    Exit:\n    return error;\n}", "item_id": 4, "repo": "fenollp/wex", "file": "src/freetype/src/cff/cffload.c", "last_update_at": "2021-11-15T07:14:20+00:00", "question_id": "eb21b8a509d7abce736cd56822826858fe5939c9_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["FT_LOCAL_DEF(FT_Error)\ncff_index_access_element(CFF_Index idx,\n                         FT_UInt element,\n                         FT_Byte **pbytes,\n                         FT_ULong *pbyte_len) {\n    FT_Error error = FT_Err_Ok;\n    if (idx && idx->count > element) {\n        /* compute start and end offsets */\n        FT_Stream stream = idx->stream;\n        FT_ULong off1, off2 = 0;\n        /* load offsets from file or the offset table */\n        if (!idx->offsets) {\n            FT_ULong pos = element * idx->off_size;\n            if (FT_STREAM_SEEK(idx->start + 3 + pos))\n                goto Exit;\n            off1 = cff_index_read_offset(idx, &error);\n            if (error)\n                goto Exit;\n            if (off1 != 0) {\n                do {\n                    element++;\n                    off2 = cff_index_read_offset(idx, &error);\n                } while (off2 == 0 && element < idx->count);\n            }\n        } else   /* use offsets table */\n        {\n            off1 = idx->offsets[element];\n            if (off1) {\n                do {\n                    element++;\n                    off2 = idx->offsets[element];\n                } while (off2 == 0 && element < idx->count);\n            }\n        }\n        /* XXX: should check off2 does not exceed the end of this entry; */\n        /*      at present, only truncate off2 at the end of this stream */\n        if (off2 > stream->size + 1 ||\n            idx->data_offset > stream->size - off2 + 1) {\n            FT_ERROR((\"cff_index_access_element:\"\n                      \" offset to next entry (%d)\"\n                      \" exceeds the end of stream (%d)\\n\",\n                    off2, stream->size - idx->data_offset + 1));\n            off2 = stream->size - idx->data_offset + 1;\n        }\n        /* access element */\n        if (off1 && off2 > off1) {\n            *pbyte_len = off2 - off1;\n            if (idx->bytes) {\n                /* this index was completely loaded in memory, that's easy */\n                *pbytes = idx->bytes + off1 - 1;\n            } else {\n                /* this index is still on disk/file, access it through a frame */\n                if (FT_STREAM_SEEK(idx->data_offset + off1 - 1) ||\n                    FT_FRAME_EXTRACT(off2 - off1, *pbytes))\n                    goto Exit;\n            }\n        } else {\n            /* empty index element */\n            *pbytes = 0;\n            *pbyte_len = 0;\n        }\n    } else\n        error = FT_THROW(Invalid_Argument);\n    Exit:\n    return error;\n"]]}
{"hexsha": "49470297bb39a37f2c1ed6f5a11405a0489eda14", "ext": "h", "lang": "C", "content": "static inline void hri_rtcmode1_set_EVCTRL_CMPEO2_bit(const void *const hw)\n{\n\tRTC_CRITICAL_SECTION_ENTER();\n\t((Rtc *)hw)->MODE1.EVCTRL.reg |= RTC_MODE1_EVCTRL_CMPEO2;\n\tRTC_CRITICAL_SECTION_LEAVE();\n}", "item_id": 509, "repo": "lwIoT/lwiot-samd51", "file": "samd51/hri/hri_rtc_d51.h", "last_update_at": "2021-07-03T07:21:38+00:00", "question_id": "49470297bb39a37f2c1ed6f5a11405a0489eda14_509", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void hri_rtcmode1_set_EVCTRL_CMPEO2_bit(const void *const hw)\n{\n\tRTC_CRITICAL_SECTION_ENTER();\n\t((Rtc *)hw)->MODE1.EVCTRL.reg |= RTC_MODE1_EVCTRL_CMPEO2;\n\tRTC_CRITICAL_SECTION_LEAVE();\n"]]}
{"hexsha": "acaf6932b2e116454cd88e749411240c32bda844", "ext": "c", "lang": "C", "content": "void f185(void) {\n    \tint64_t x1641 = INT64_MIN;\n\tstatic int16_t x1642 = INT16_MIN;\n\tvolatile uint64_t x1643 = 14760241621939LLU;\n\tint32_t x1644 = INT32_MAX;\n\n    t185 = ((x1641%x1642)%(x1643>x1644));\n\n    if (t185 != 0LL) { NG(); } else { ; }\n\t\n}", "item_id": 185, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1629.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "acaf6932b2e116454cd88e749411240c32bda844_185", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f185(void) {\n    \tint64_t x1641 = INT64_MIN;\n\tstatic int16_t x1642 = INT16_MIN;\n\tvolatile uint64_t x1643 = 14760241621939LLU;\n\tint32_t x1644 = INT32_MAX;\n    t185 = ((x1641%x1642)%(x1643>x1644));\n    if (t185 != 0LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "52eb074f39278057edcf9a4fd57314e6a3907c3c", "ext": "c", "lang": "C", "content": "void kettle_gpio_init()\r\n{\r\n    //led pin init\r\n    tuya_pin_init(led1_pin, TUYA_PIN_MODE_OUT_PP_HIGH);\r\n    tuya_pin_init(led2_pin, TUYA_PIN_MODE_OUT_PP_HIGH);\r\n    //buzzer pin init\r\n    tuya_pin_init(buzzer_pin, TUYA_PIN_MODE_OUT_PP_LOW);\r\n    //relay pin init\r\n    tuya_pin_init(relay_pin, TUYA_PIN_MODE_OUT_PP_LOW);\r\n}", "item_id": 0, "repo": "tuya/tuya-iotos-embeded-demo-wifi-ble-smart-kettle", "file": "bk7231n_smart_kettle_demo/src/tuya_drive/gpio_control/gpio_control.c", "last_update_at": "2021-11-18T04:49:38+00:00", "question_id": "52eb074f39278057edcf9a4fd57314e6a3907c3c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void kettle_gpio_init()\r\n{\r\n    //led pin init\r\n    tuya_pin_init(led1_pin, TUYA_PIN_MODE_OUT_PP_HIGH);\r\n    tuya_pin_init(led2_pin, TUYA_PIN_MODE_OUT_PP_HIGH);\r\n    //buzzer pin init\r\n    tuya_pin_init(buzzer_pin, TUYA_PIN_MODE_OUT_PP_LOW);\r\n    //relay pin init\r\n    tuya_pin_init(relay_pin, TUYA_PIN_MODE_OUT_PP_LOW);\r\n"]]}
{"hexsha": "7f98ae47c6f73ea64fe01a3cc3ce0a77de5aa55d", "ext": "c", "lang": "C", "content": "static void rna_Itasc_update(Main *UNUSED(bmain), Scene *UNUSED(scene), PointerRNA *ptr)\n{\n  Object *ob = (Object *)ptr->owner_id;\n  bItasc *itasc = ptr->data;\n\n  /* verify values */\n  if (itasc->precision < 0.0001f) {\n    itasc->precision = 0.0001f;\n  }\n  if (itasc->minstep < 0.001f) {\n    itasc->minstep = 0.001f;\n  }\n  if (itasc->maxstep < itasc->minstep) {\n    itasc->maxstep = itasc->minstep;\n  }\n  if (itasc->feedback < 0.01f) {\n    itasc->feedback = 0.01f;\n  }\n  if (itasc->feedback > 100.0f) {\n    itasc->feedback = 100.0f;\n  }\n  if (itasc->maxvel < 0.01f) {\n    itasc->maxvel = 0.01f;\n  }\n  if (itasc->maxvel > 100.0f) {\n    itasc->maxvel = 100.0f;\n  }\n  BIK_update_param(ob->pose);\n\n  DEG_id_tag_update(&ob->id, ID_RECALC_GEOMETRY);\n}", "item_id": 17, "repo": "pkassotis/blender", "file": "source/blender/makesrna/intern/rna_pose.c", "last_update_at": "2021-09-29T06:25:03+00:00", "question_id": "7f98ae47c6f73ea64fe01a3cc3ce0a77de5aa55d_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void rna_Itasc_update(Main *UNUSED(bmain), Scene *UNUSED(scene), PointerRNA *ptr)\n{\n  Object *ob = (Object *)ptr->owner_id;\n  bItasc *itasc = ptr->data;\n  /* verify values */\n  if (itasc->precision < 0.0001f) {\n    itasc->precision = 0.0001f;\n  }\n  if (itasc->minstep < 0.001f) {\n    itasc->minstep = 0.001f;\n  }\n  if (itasc->maxstep < itasc->minstep) {\n    itasc->maxstep = itasc->minstep;\n  }\n  if (itasc->feedback < 0.01f) {\n    itasc->feedback = 0.01f;\n  }\n  if (itasc->feedback > 100.0f) {\n    itasc->feedback = 100.0f;\n  }\n  if (itasc->maxvel < 0.01f) {\n    itasc->maxvel = 0.01f;\n  }\n  if (itasc->maxvel > 100.0f) {\n    itasc->maxvel = 100.0f;\n  }\n  BIK_update_param(ob->pose);\n  DEG_id_tag_update(&ob->id, ID_RECALC_GEOMETRY);\n"]]}
{"hexsha": "be1171e30e96695f959cb06727516c2e6effca2a", "ext": "c", "lang": "C", "content": "static int Flush(lua_State *L)\n    {\n    cl_queue queue = checkqueue(L, 1, NULL);\n    cl_int ec = cl.Flush(queue);\n    CheckError(L, ec);\n    return 0;\n    }", "item_id": 0, "repo": "stetre/mooncl", "file": "src/enqueue.c", "last_update_at": "2021-03-07T08:15:55+00:00", "question_id": "be1171e30e96695f959cb06727516c2e6effca2a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int Flush(lua_State *L)\n    {\n    cl_queue queue = checkqueue(L, 1, NULL);\n    cl_int ec = cl.Flush(queue);\n    CheckError(L, ec);\n    return 0;\n"]]}
{"hexsha": "0b179d1fa0c6861ab61175502d97ad6e58c36e4b", "ext": "c", "lang": "C", "content": "void f79(void) {\n    \tuint8_t x449 = 44U;\n\tint8_t x451 = INT8_MIN;\n\tvolatile int32_t x452 = INT32_MAX;\n\tstatic volatile uint32_t t79 = 17561U;\n\n    t79 = ((x449/x450)>>(x451>x452));\n\n    if (t79 != 1U) { NG(); } else { ; }\n\t\n}", "item_id": 79, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1621.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "0b179d1fa0c6861ab61175502d97ad6e58c36e4b_79", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f79(void) {\n    \tuint8_t x449 = 44U;\n\tint8_t x451 = INT8_MIN;\n\tvolatile int32_t x452 = INT32_MAX;\n\tstatic volatile uint32_t t79 = 17561U;\n    t79 = ((x449/x450)>>(x451>x452));\n    if (t79 != 1U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "797023ac9325f29a84b628dedc8af202f5ac26d2", "ext": "c", "lang": "C", "content": "void f106(void) {\n    \tstatic volatile int8_t x5593 = INT8_MAX;\n\tstatic uint8_t x5594 = 3U;\n\tuint64_t x5595 = 2206789LLU;\n\tvolatile int32_t t106 = 1786383;\n\n    t106 = (x5593<=((x5594*x5595)>>x5596));\n\n    if (t106 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 106, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test542.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "797023ac9325f29a84b628dedc8af202f5ac26d2_106", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f106(void) {\n    \tstatic volatile int8_t x5593 = INT8_MAX;\n\tstatic uint8_t x5594 = 3U;\n\tuint64_t x5595 = 2206789LLU;\n\tvolatile int32_t t106 = 1786383;\n    t106 = (x5593<=((x5594*x5595)>>x5596));\n    if (t106 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "bddf22711ad1d678030f8ead80871332a199bd8c", "ext": "c", "lang": "C", "content": "int main(void){\n    setgid(0);\n    setuid(0);\n    execl(\"/bin/sh\",\"sh\",0, (char *)0);\n    return 0;\n}", "item_id": 0, "repo": "nand-nor/dedelf", "file": "tests/code/exec_shell.c", "last_update_at": "2021-12-28T04:09:47+00:00", "question_id": "bddf22711ad1d678030f8ead80871332a199bd8c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int main(void){\n    setgid(0);\n    setuid(0);\n    execl(\"/bin/sh\",\"sh\",0, (char *)0);\n    return 0;\n"]]}
{"hexsha": "a0b8c47d8f4939b91917e2e5140fbf603a8f36ad", "ext": "h", "lang": "C", "content": "void build_hyper_graph_r(unsigned int R)\n    {\n        if( R > INT_MAX ){\n            cout<<\"Error:R too large\"<<endl;\n            exit(1);\n        }    \n\t\t//every time starts from scratch\n\t\tauto counter = hyperGT.size();\n\t\twhile (counter < R)BuildHypergraphNode(counter++);\t\t\n    }", "item_id": 4, "repo": "kevin811/AdaptiveIM", "file": "worstepic/infgraph.h", "last_update_at": "2021-09-02T05:55:14+00:00", "question_id": "a0b8c47d8f4939b91917e2e5140fbf603a8f36ad_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void build_hyper_graph_r(unsigned int R)\n    {\n        if( R > INT_MAX ){\n            cout<<\"Error:R too large\"<<endl;\n            exit(1);\n        }    \n\t\t//every time starts from scratch\n\t\tauto counter = hyperGT.size();\n\t\twhile (counter < R)BuildHypergraphNode(counter++);\t\t\n"]]}
{"hexsha": "9baa7a16d1be2d6e29f3e865a79755b6ed722665", "ext": "c", "lang": "C", "content": "void\nMachineCheckException(struct pt_regs *regs)\n{\n\tunsigned long fixup, val;\n#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)\n\tu32 value2;\n\tint corr_ecc = 0;\n\tint uncorr_ecc = 0;\n#endif\n\n\tif ((fixup = search_exception_table(regs->nip)) != 0) {\n\t\tregs->nip = fixup;\n\t\tval = mfspr(MCSR);\n\t\t/* Clear MCSR */\n\t\tmtspr(SPRN_MCSR, val);\n\t\treturn;\n\t}\n\n#if defined(CONFIG_CMD_KGDB)\n\tif (debugger_exception_handler && (*debugger_exception_handler)(regs))\n\t\treturn;\n#endif\n\n\tprintf(\"Machine Check Exception.\\n\");\n\tprintf(\"Caused by (from msr): \");\n\tprintf(\"regs %p \", regs);\n\n\tval = get_esr();\n\n#if !defined(CONFIG_440) && !defined(CONFIG_405EX)\n\tif (val& ESR_IMCP) {\n\t\tprintf(\"Instruction\");\n\t\tmtspr(ESR, val & ~ESR_IMCP);\n\t} else {\n\t\tprintf(\"Data\");\n\t}\n\tprintf(\" machine check.\\n\");\n\n#elif defined(CONFIG_440) || defined(CONFIG_405EX)\n\tif (val& ESR_IMCP){\n\t\tprintf(\"Instruction Synchronous Machine Check exception\\n\");\n\t\tmtspr(SPRN_ESR, val & ~ESR_IMCP);\n\t} else {\n\t\tval = mfspr(MCSR);\n\t\tif (val & MCSR_IB)\n\t\t\tprintf(\"Instruction Read PLB Error\\n\");\n#if defined(CONFIG_440)\n\t\tif (val & MCSR_DRB)\n\t\t\tprintf(\"Data Read PLB Error\\n\");\n\t\tif (val & MCSR_DWB)\n\t\t\tprintf(\"Data Write PLB Error\\n\");\n#else\n\t\tif (val & MCSR_DB)\n\t\t\tprintf(\"Data PLB Error\\n\");\n#endif\n\t\tif (val & MCSR_TLBP)\n\t\t\tprintf(\"TLB Parity Error\\n\");\n\t\tif (val & MCSR_ICP){\n\t\t\t/*flush_instruction_cache(); */\n\t\t\tprintf(\"I-Cache Parity Error\\n\");\n\t\t}\n\t\tif (val & MCSR_DCSP)\n\t\t\tprintf(\"D-Cache Search Parity Error\\n\");\n\t\tif (val & MCSR_DCFP)\n\t\t\tprintf(\"D-Cache Flush Parity Error\\n\");\n\t\tif (val & MCSR_IMPE)\n\t\t\tprintf(\"Machine Check exception is imprecise\\n\");\n\n\t\t/* Clear MCSR */\n\t\tmtspr(SPRN_MCSR, val);\n\t}\n\n#if defined(CONFIG_DDR_ECC) && defined(CONFIG_SDRAM_PPC4xx_IBM_DDR2)\n\t/*\n\t * Read and print ECC status register/info:\n\t * The faulting address is only known upon uncorrectable ECC\n\t * errors.\n\t */\n\tmfsdram(SDRAM_ECCES, val);\n\tif (val & SDRAM_ECCES_CE)\n\t\tprintf(\"ECC: Correctable error\\n\");\n\tif (val & SDRAM_ECCES_UE) {\n\t\tprintf(\"ECC: Uncorrectable error at 0x%02x%08x\\n\",\n\t\t       mfdcr(SDRAM_ERRADDULL), mfdcr(SDRAM_ERRADDLLL));\n\t}\n#endif /* CONFIG_DDR_ECC ... */\n\n#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)\n\tmfsdram(DDR0_00, val) ;\n\tprintf(\"DDR0: DDR0_00 %lx\\n\", val);\n\tval = (val >> 16) & 0xff;\n\tif (val & 0x80)\n\t\tprintf(\"DDR0: At least one interrupt active\\n\");\n\tif (val & 0x40)\n\t\tprintf(\"DDR0: DRAM initialization complete.\\n\");\n\tif (val & 0x20) {\n\t\tprintf(\"DDR0: Multiple uncorrectable ECC events.\\n\");\n\t\tuncorr_ecc = 1;\n\t}\n\tif (val & 0x10) {\n\t\tprintf(\"DDR0: Single uncorrectable ECC event.\\n\");\n\t\tuncorr_ecc = 1;\n\t}\n\tif (val & 0x08) {\n\t\tprintf(\"DDR0: Multiple correctable ECC events.\\n\");\n\t\tcorr_ecc = 1;\n\t}\n\tif (val & 0x04) {\n\t\tprintf(\"DDR0: Single correctable ECC event.\\n\");\n\t\tcorr_ecc = 1;\n\t}\n\tif (val & 0x02)\n\t\tprintf(\"Multiple accesses outside the defined\"\n\t\t       \" physical memory space detected\\n\");\n\tif (val & 0x01)\n\t\tprintf(\"DDR0: Single access outside the defined\"\n\t\t       \" physical memory space detected.\\n\");\n\n\tmfsdram(DDR0_01, val);\n\tval = (val >> 8) & 0x7;\n\tswitch (val ) {\n\tcase 0:\n\t\tprintf(\"DDR0: Write Out-of-Range command\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tprintf(\"DDR0: Read Out-of-Range command\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tprintf(\"DDR0: Masked write Out-of-Range command\\n\");\n\t\tbreak;\n\tcase 4:\n\t\tprintf(\"DDR0: Wrap write Out-of-Range command\\n\");\n\t\tbreak;\n\tcase 5:\n\t\tprintf(\"DDR0: Wrap read Out-of-Range command\\n\");\n\t\tbreak;\n\tdefault:\n\t\tmfsdram(DDR0_01, value2);\n\t\tprintf(\"DDR0: No DDR0 error know 0x%lx %x\\n\", val, value2);\n\t}\n\tmfsdram(DDR0_23, val);\n\tif (((val >> 16) & 0xff) && corr_ecc)\n\t\tprintf(\"DDR0: Syndrome for correctable ECC event 0x%lx\\n\",\n\t\t       (val >> 16) & 0xff);\n\tmfsdram(DDR0_23, val);\n\tif (((val >> 8) & 0xff) && uncorr_ecc)\n\t\tprintf(\"DDR0: Syndrome for uncorrectable ECC event 0x%lx\\n\",\n\t\t       (val >> 8) & 0xff);\n\tmfsdram(DDR0_33, val);\n\tif (val)\n\t\tprintf(\"DDR0: Address of command that caused an \"\n\t\t       \"Out-of-Range interrupt %lx\\n\", val);\n\tmfsdram(DDR0_34, val);\n\tif (val && uncorr_ecc)\n\t\tprintf(\"DDR0: Address of uncorrectable ECC event %lx\\n\", val);\n\tmfsdram(DDR0_35, val);\n\tif (val && uncorr_ecc)\n\t\tprintf(\"DDR0: Address of uncorrectable ECC event %lx\\n\", val);\n\tmfsdram(DDR0_36, val);\n\tif (val && uncorr_ecc)\n\t\tprintf(\"DDR0: Data of uncorrectable ECC event 0x%08lx\\n\", val);\n\tmfsdram(DDR0_37, val);\n\tif (val && uncorr_ecc)\n\t\tprintf(\"DDR0: Data of uncorrectable ECC event 0x%08lx\\n\", val);\n\tmfsdram(DDR0_38, val);\n\tif (val && corr_ecc)\n\t\tprintf(\"DDR0: Address of correctable ECC event %lx\\n\", val);\n\tmfsdram(DDR0_39, val);\n\tif (val && corr_ecc)\n\t\tprintf(\"DDR0: Address of correctable ECC event %lx\\n\", val);\n\tmfsdram(DDR0_40, val);\n\tif (val && corr_ecc)\n\t\tprintf(\"DDR0: Data of correctable ECC event 0x%08lx\\n\", val);\n\tmfsdram(DDR0_41, val);\n\tif (val && corr_ecc)\n\t\tprintf(\"DDR0: Data of correctable ECC event 0x%08lx\\n\", val);\n#endif /* CONFIG_440EPX */\n#endif /* CONFIG_440 */\n\tshow_regs(regs);\n\tprint_backtrace((unsigned long *)regs->gpr[1]);\n\tpanic(\"machine check\");\n}", "item_id": 4, "repo": "WA2301/uboot-2011.06", "file": "arch/powerpc/cpu/ppc4xx/traps.c", "last_update_at": "2021-11-14T21:29:42+00:00", "question_id": "9baa7a16d1be2d6e29f3e865a79755b6ed722665_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void\nMachineCheckException(struct pt_regs *regs)\n{\n\tunsigned long fixup, val;\n#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)\n\tu32 value2;\n\tint corr_ecc = 0;\n\tint uncorr_ecc = 0;\n#endif\n\tif ((fixup = search_exception_table(regs->nip)) != 0) {\n\t\tregs->nip = fixup;\n\t\tval = mfspr(MCSR);\n\t\t/* Clear MCSR */\n\t\tmtspr(SPRN_MCSR, val);\n\t\treturn;\n\t}\n#if defined(CONFIG_CMD_KGDB)\n\tif (debugger_exception_handler && (*debugger_exception_handler)(regs))\n\t\treturn;\n#endif\n\tprintf(\"Machine Check Exception.\\n\");\n\tprintf(\"Caused by (from msr): \");\n\tprintf(\"regs %p \", regs);\n\tval = get_esr();\n#if !defined(CONFIG_440) && !defined(CONFIG_405EX)\n\tif (val& ESR_IMCP) {\n\t\tprintf(\"Instruction\");\n\t\tmtspr(ESR, val & ~ESR_IMCP);\n\t} else {\n\t\tprintf(\"Data\");\n\t}\n\tprintf(\" machine check.\\n\");\n#elif defined(CONFIG_440) || defined(CONFIG_405EX)\n\tif (val& ESR_IMCP){\n\t\tprintf(\"Instruction Synchronous Machine Check exception\\n\");\n\t\tmtspr(SPRN_ESR, val & ~ESR_IMCP);\n\t} else {\n\t\tval = mfspr(MCSR);\n\t\tif (val & MCSR_IB)\n\t\t\tprintf(\"Instruction Read PLB Error\\n\");\n#if defined(CONFIG_440)\n\t\tif (val & MCSR_DRB)\n\t\t\tprintf(\"Data Read PLB Error\\n\");\n\t\tif (val & MCSR_DWB)\n\t\t\tprintf(\"Data Write PLB Error\\n\");\n#else\n\t\tif (val & MCSR_DB)\n\t\t\tprintf(\"Data PLB Error\\n\");\n#endif\n\t\tif (val & MCSR_TLBP)\n\t\t\tprintf(\"TLB Parity Error\\n\");\n\t\tif (val & MCSR_ICP){\n\t\t\t/*flush_instruction_cache(); */\n\t\t\tprintf(\"I-Cache Parity Error\\n\");\n\t\t}\n\t\tif (val & MCSR_DCSP)\n\t\t\tprintf(\"D-Cache Search Parity Error\\n\");\n\t\tif (val & MCSR_DCFP)\n\t\t\tprintf(\"D-Cache Flush Parity Error\\n\");\n\t\tif (val & MCSR_IMPE)\n\t\t\tprintf(\"Machine Check exception is imprecise\\n\");\n\t\t/* Clear MCSR */\n\t\tmtspr(SPRN_MCSR, val);\n\t}\n#if defined(CONFIG_DDR_ECC) && defined(CONFIG_SDRAM_PPC4xx_IBM_DDR2)\n\t/*\n\t * Read and print ECC status register/info:\n\t * The faulting address is only known upon uncorrectable ECC\n\t * errors.\n\t */\n\tmfsdram(SDRAM_ECCES, val);\n\tif (val & SDRAM_ECCES_CE)\n\t\tprintf(\"ECC: Correctable error\\n\");\n\tif (val & SDRAM_ECCES_UE) {\n\t\tprintf(\"ECC: Uncorrectable error at 0x%02x%08x\\n\",\n\t\t       mfdcr(SDRAM_ERRADDULL), mfdcr(SDRAM_ERRADDLLL));\n\t}\n#endif /* CONFIG_DDR_ECC ... */\n#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)\n\tmfsdram(DDR0_00, val) ;\n\tprintf(\"DDR0: DDR0_00 %lx\\n\", val);\n\tval = (val >> 16) & 0xff;\n\tif (val & 0x80)\n\t\tprintf(\"DDR0: At least one interrupt active\\n\");\n\tif (val & 0x40)\n\t\tprintf(\"DDR0: DRAM initialization complete.\\n\");\n\tif (val & 0x20) {\n\t\tprintf(\"DDR0: Multiple uncorrectable ECC events.\\n\");\n\t\tuncorr_ecc = 1;\n\t}\n\tif (val & 0x10) {\n\t\tprintf(\"DDR0: Single uncorrectable ECC event.\\n\");\n\t\tuncorr_ecc = 1;\n\t}\n\tif (val & 0x08) {\n\t\tprintf(\"DDR0: Multiple correctable ECC events.\\n\");\n\t\tcorr_ecc = 1;\n\t}\n\tif (val & 0x04) {\n\t\tprintf(\"DDR0: Single correctable ECC event.\\n\");\n\t\tcorr_ecc = 1;\n\t}\n\tif (val & 0x02)\n\t\tprintf(\"Multiple accesses outside the defined\"\n\t\t       \" physical memory space detected\\n\");\n\tif (val & 0x01)\n\t\tprintf(\"DDR0: Single access outside the defined\"\n\t\t       \" physical memory space detected.\\n\");\n\tmfsdram(DDR0_01, val);\n\tval = (val >> 8) & 0x7;\n\tswitch (val ) {\n\tcase 0:\n\t\tprintf(\"DDR0: Write Out-of-Range command\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tprintf(\"DDR0: Read Out-of-Range command\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tprintf(\"DDR0: Masked write Out-of-Range command\\n\");\n\t\tbreak;\n\tcase 4:\n\t\tprintf(\"DDR0: Wrap write Out-of-Range command\\n\");\n\t\tbreak;\n\tcase 5:\n\t\tprintf(\"DDR0: Wrap read Out-of-Range command\\n\");\n\t\tbreak;\n\tdefault:\n\t\tmfsdram(DDR0_01, value2);\n\t\tprintf(\"DDR0: No DDR0 error know 0x%lx %x\\n\", val, value2);\n\t}\n\tmfsdram(DDR0_23, val);\n\tif (((val >> 16) & 0xff) && corr_ecc)\n\t\tprintf(\"DDR0: Syndrome for correctable ECC event 0x%lx\\n\",\n\t\t       (val >> 16) & 0xff);\n\tmfsdram(DDR0_23, val);\n\tif (((val >> 8) & 0xff) && uncorr_ecc)\n\t\tprintf(\"DDR0: Syndrome for uncorrectable ECC event 0x%lx\\n\",\n\t\t       (val >> 8) & 0xff);\n\tmfsdram(DDR0_33, val);\n\tif (val)\n\t\tprintf(\"DDR0: Address of command that caused an \"\n\t\t       \"Out-of-Range interrupt %lx\\n\", val);\n\tmfsdram(DDR0_34, val);\n\tif (val && uncorr_ecc)\n\t\tprintf(\"DDR0: Address of uncorrectable ECC event %lx\\n\", val);\n\tmfsdram(DDR0_35, val);\n\tif (val && uncorr_ecc)\n\t\tprintf(\"DDR0: Address of uncorrectable ECC event %lx\\n\", val);\n\tmfsdram(DDR0_36, val);\n\tif (val && uncorr_ecc)\n\t\tprintf(\"DDR0: Data of uncorrectable ECC event 0x%08lx\\n\", val);\n\tmfsdram(DDR0_37, val);\n\tif (val && uncorr_ecc)\n\t\tprintf(\"DDR0: Data of uncorrectable ECC event 0x%08lx\\n\", val);\n\tmfsdram(DDR0_38, val);\n\tif (val && corr_ecc)\n\t\tprintf(\"DDR0: Address of correctable ECC event %lx\\n\", val);\n\tmfsdram(DDR0_39, val);\n\tif (val && corr_ecc)\n\t\tprintf(\"DDR0: Address of correctable ECC event %lx\\n\", val);\n\tmfsdram(DDR0_40, val);\n\tif (val && corr_ecc)\n\t\tprintf(\"DDR0: Data of correctable ECC event 0x%08lx\\n\", val);\n\tmfsdram(DDR0_41, val);\n\tif (val && corr_ecc)\n\t\tprintf(\"DDR0: Data of correctable ECC event 0x%08lx\\n\", val);\n#endif /* CONFIG_440EPX */\n#endif /* CONFIG_440 */\n\tshow_regs(regs);\n\tprint_backtrace((unsigned long *)regs->gpr[1]);\n\tpanic(\"machine check\");\n"]]}
{"hexsha": "f20091ceb9d4c513b8a09423abbf54a354e1510e", "ext": "c", "lang": "C", "content": "void f165(void) {\n    \tint8_t x1769 = INT8_MAX;\n\tstatic volatile uint8_t x1770 = 32U;\n\tvolatile int32_t t165 = -36401783;\n\n    t165 = ((x1769*x1770)%(x1771/x1772));\n\n    if (t165 != 4064) { NG(); } else { ; }\n\t\n}", "item_id": 165, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test621.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "f20091ceb9d4c513b8a09423abbf54a354e1510e_165", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f165(void) {\n    \tint8_t x1769 = INT8_MAX;\n\tstatic volatile uint8_t x1770 = 32U;\n\tvolatile int32_t t165 = -36401783;\n    t165 = ((x1769*x1770)%(x1771/x1772));\n    if (t165 != 4064) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "0206466cdfea6aa10391b9f97dcf84e24341b737", "ext": "c", "lang": "C", "content": "int eloop_register_timeout(unsigned int secs, unsigned int usecs,\n\t\t\t   void (*handler)(void *eloop_ctx, void *timeout_ctx),\n\t\t\t   void *eloop_data, void *user_data)\n{\n\tstruct eloop_timeout *timeout, *tmp, *prev;\n\n\ttimeout = (struct eloop_timeout *) malloc(sizeof(*timeout));\n\tif (timeout == NULL)\n\t\treturn -1;\n\tos_get_time(&timeout->time);\n\ttimeout->time.sec += secs;\n\ttimeout->time.usec += usecs;\n\twhile (timeout->time.usec >= 1000000) {\n\t\ttimeout->time.sec++;\n\t\ttimeout->time.usec -= 1000000;\n\t}\n\ttimeout->eloop_data = eloop_data;\n\ttimeout->user_data = user_data;\n\ttimeout->handler = handler;\n\ttimeout->next = NULL;\n\n\tif (eloop.timeout == NULL) {\n\t\teloop.timeout = timeout;\n\t\treturn 0;\n\t}\n\n\tprev = NULL;\n\ttmp = eloop.timeout;\n\twhile (tmp != NULL) {\n\t\tif (os_time_before(&timeout->time, &tmp->time))\n\t\t\tbreak;\n\t\tprev = tmp;\n\t\ttmp = tmp->next;\n\t}\n\n\tif (prev == NULL) {\n\t\ttimeout->next = eloop.timeout;\n\t\teloop.timeout = timeout;\n\t} else {\n\t\ttimeout->next = prev->next;\n\t\tprev->next = timeout;\n\t}\n\n\treturn 0;\n}", "item_id": 2, "repo": "doyaGu/C0501Q_HWJL01", "file": "sdk/sdk/share/wifi_hostapd/src/utils/eloop_none.c", "last_update_at": "2021-10-09T08:05:50+00:00", "question_id": "0206466cdfea6aa10391b9f97dcf84e24341b737_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int eloop_register_timeout(unsigned int secs, unsigned int usecs,\n\t\t\t   void (*handler)(void *eloop_ctx, void *timeout_ctx),\n\t\t\t   void *eloop_data, void *user_data)\n{\n\tstruct eloop_timeout *timeout, *tmp, *prev;\n\ttimeout = (struct eloop_timeout *) malloc(sizeof(*timeout));\n\tif (timeout == NULL)\n\t\treturn -1;\n\tos_get_time(&timeout->time);\n\ttimeout->time.sec += secs;\n\ttimeout->time.usec += usecs;\n\twhile (timeout->time.usec >= 1000000) {\n\t\ttimeout->time.sec++;\n\t\ttimeout->time.usec -= 1000000;\n\t}\n\ttimeout->eloop_data = eloop_data;\n\ttimeout->user_data = user_data;\n\ttimeout->handler = handler;\n\ttimeout->next = NULL;\n\tif (eloop.timeout == NULL) {\n\t\teloop.timeout = timeout;\n\t\treturn 0;\n\t}\n\tprev = NULL;\n\ttmp = eloop.timeout;\n\twhile (tmp != NULL) {\n\t\tif (os_time_before(&timeout->time, &tmp->time))\n\t\t\tbreak;\n\t\tprev = tmp;\n\t\ttmp = tmp->next;\n\t}\n\tif (prev == NULL) {\n\t\ttimeout->next = eloop.timeout;\n\t\teloop.timeout = timeout;\n\t} else {\n\t\ttimeout->next = prev->next;\n\t\tprev->next = timeout;\n\t}\n\treturn 0;\n"]]}
{"hexsha": "e7851b7b24431c7eaa820af86e892de4ff563b84", "ext": "c", "lang": "C", "content": "void f124(void) {\n    \tint8_t x681 = INT8_MIN;\n\tvolatile int64_t x683 = INT64_MIN;\n\tstatic uint16_t x684 = UINT16_MAX;\n\tvolatile int32_t t124 = -991571;\n\n    t124 = ((x681^(x682<=x683))*x684);\n\n    if (t124 != -8388480) { NG(); } else { ; }\n\t\n}", "item_id": 124, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test1949.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "e7851b7b24431c7eaa820af86e892de4ff563b84_124", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f124(void) {\n    \tint8_t x681 = INT8_MIN;\n\tvolatile int64_t x683 = INT64_MIN;\n\tstatic uint16_t x684 = UINT16_MAX;\n\tvolatile int32_t t124 = -991571;\n    t124 = ((x681^(x682<=x683))*x684);\n    if (t124 != -8388480) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "5e0a8d109307c4a0433fddd54eb58885b02a70c5", "ext": "c", "lang": "C", "content": "BYTE GetHotkeyMod(DWORD dwHotkey)\n{\n  //Convert modifier from HKM_GETHOTKEY to WM_HOTKEY.\n  BYTE nHotkeyMod=HIBYTE(dwHotkey);\n  BYTE nResultMod=0;\n\n  if (nHotkeyMod & HOTKEYF_SHIFT)\n    nResultMod|=MOD_SHIFT;\n  if (nHotkeyMod & HOTKEYF_CONTROL)\n    nResultMod|=MOD_CONTROL;\n  if (nHotkeyMod & HOTKEYF_ALT)\n    nResultMod|=MOD_ALT;\n  return nResultMod;\n}", "item_id": 15, "repo": "leeonix/AkelPad", "file": "AkelFiles/Plugs/Clipboard/Source/Clipboard.c", "last_update_at": "2021-09-14T21:17:07+00:00", "question_id": "5e0a8d109307c4a0433fddd54eb58885b02a70c5_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["BYTE GetHotkeyMod(DWORD dwHotkey)\n{\n  //Convert modifier from HKM_GETHOTKEY to WM_HOTKEY.\n  BYTE nHotkeyMod=HIBYTE(dwHotkey);\n  BYTE nResultMod=0;\n  if (nHotkeyMod & HOTKEYF_SHIFT)\n    nResultMod|=MOD_SHIFT;\n  if (nHotkeyMod & HOTKEYF_CONTROL)\n    nResultMod|=MOD_CONTROL;\n  if (nHotkeyMod & HOTKEYF_ALT)\n    nResultMod|=MOD_ALT;\n  return nResultMod;\n"]]}
{"hexsha": "2cd667986665007d48ac9cb503313e651e5e9e7b", "ext": "c", "lang": "C", "content": "static void func_die (void *vo)\n{\n    struct instance *o = vo;\n    ASSERT(!o->dying)\n    \n    // if we're finished, die immediately\n    if (o->state == STATE_FINISHED) {\n        instance_free(o);\n        return;\n    }\n    \n    // set dying\n    o->dying = 1;\n    \n    // start terminating if not already\n    if (o->state == STATE_INIT) {\n        start_terminating(o);\n    }\n}", "item_id": 4, "repo": "offlinehacker/NCD", "file": "ncd/modules/try.c", "last_update_at": "2021-01-03T22:30:00+00:00", "question_id": "2cd667986665007d48ac9cb503313e651e5e9e7b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void func_die (void *vo)\n{\n    struct instance *o = vo;\n    ASSERT(!o->dying)\n    // if we're finished, die immediately\n    if (o->state == STATE_FINISHED) {\n        instance_free(o);\n        return;\n    }\n    // set dying\n    o->dying = 1;\n    // start terminating if not already\n    if (o->state == STATE_INIT) {\n        start_terminating(o);\n    }\n"]]}
{"hexsha": "be720f373411f7413183de86811b22c6ecb16f06", "ext": "c", "lang": "C", "content": "void f61(void) {\n    \tint32_t x253 = -1;\n\tint64_t x254 = -25563609609LL;\n\tint8_t x255 = 7;\n\tint8_t x256 = -5;\n\tstatic volatile int64_t t61 = 27261515099400519LL;\n\n    t61 = (x253*(x254*(x255>x256)));\n\n    if (t61 != 25563609609LL) { NG(); } else { ; }\n\t\n}", "item_id": 61, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test1599.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "be720f373411f7413183de86811b22c6ecb16f06_61", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f61(void) {\n    \tint32_t x253 = -1;\n\tint64_t x254 = -25563609609LL;\n\tint8_t x255 = 7;\n\tint8_t x256 = -5;\n\tstatic volatile int64_t t61 = 27261515099400519LL;\n    t61 = (x253*(x254*(x255>x256)));\n    if (t61 != 25563609609LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "390c5db5150a1ee029a10905c402b2c13ee0c7c9", "ext": "c", "lang": "C", "content": "void uartInit()\n{\n\tUCSR0B |= (1 << TXEN0 )|(1 << RXEN0 );\t// UART Senden und empfangen einschalten\n\tUBRR0 = UBRR_VAL;\t\t\t\t//Baudrate einstellen, die im Header-File definiert wurde\n}", "item_id": 0, "repo": "dotlambda/metro-hd", "file": "master/uart.c", "last_update_at": "2021-04-09T11:17:27+00:00", "question_id": "390c5db5150a1ee029a10905c402b2c13ee0c7c9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void uartInit()\n{\n\tUCSR0B |= (1 << TXEN0 )|(1 << RXEN0 );\t// UART Senden und empfangen einschalten\n\tUBRR0 = UBRR_VAL;\t\t\t\t//Baudrate einstellen, die im Header-File definiert wurde\n"]]}
{"hexsha": "f76e9fcf36fac72b98ff7595c79cb660d345f095", "ext": "c", "lang": "C", "content": "void f26(void) {\n    \tvolatile uint32_t x1677 = UINT32_MAX;\n\tuint32_t x1679 = UINT32_MAX;\n\tuint64_t x1680 = 5LLU;\n\tvolatile uint32_t t26 = 1U;\n\n    t26 = ((x1677<<(x1678>x1679))>>x1680);\n\n    if (t26 != 134217727U) { NG(); } else { ; }\n\t\n}", "item_id": 26, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test1649.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "f76e9fcf36fac72b98ff7595c79cb660d345f095_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f26(void) {\n    \tvolatile uint32_t x1677 = UINT32_MAX;\n\tuint32_t x1679 = UINT32_MAX;\n\tuint64_t x1680 = 5LLU;\n\tvolatile uint32_t t26 = 1U;\n    t26 = ((x1677<<(x1678>x1679))>>x1680);\n    if (t26 != 134217727U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "e253ffd55a5995414c71910bea205b39dddf0eb7", "ext": "c", "lang": "C", "content": "static FT_Error\nskip_literal_string(FT_Byte **acur,\n                    FT_Byte *limit) {\n    FT_Byte *cur = *acur;\n    FT_Int embed = 0;\n    FT_Error error = FT_ERR(Invalid_File_Format);\n    unsigned int i;\n\n\n    while (cur < limit) {\n        FT_Byte c = *cur;\n\n\n        ++cur;\n\n        if (c == '\\\\') {\n            /* Red Book 3rd ed., section `Literal Text Strings', p. 29:     */\n            /* A backslash can introduce three different types              */\n            /* of escape sequences:                                         */\n            /*   - a special escaped char like \\r, \\n, etc.                 */\n            /*   - a one-, two-, or three-digit octal number                */\n            /*   - none of the above in which case the backslash is ignored */\n\n            if (cur == limit)\n                /* error (or to be ignored?) */\n                break;\n\n            switch (*cur) {\n                /* skip `special' escape */\n                case 'n':\n                case 'r':\n                case 't':\n                case 'b':\n                case 'f':\n                case '\\\\':\n                case '(':\n                case ')':\n                    ++cur;\n                    break;\n\n                default:\n                    /* skip octal escape or ignore backslash */\n                    for (i = 0; i < 3 && cur < limit; ++i) {\n                        if (!IS_OCTAL_DIGIT(*cur))\n                            break;\n\n                        ++cur;\n                    }\n            }\n        } else if (c == '(')\n            embed++;\n        else if (c == ')') {\n            embed--;\n            if (embed == 0) {\n                error = FT_Err_Ok;\n                break;\n            }\n        }\n    }\n\n    *acur = cur;\n\n    return error;\n}", "item_id": 7, "repo": "fenollp/wex", "file": "src/freetype/src/psaux/psobjs.c", "last_update_at": "2021-11-15T07:14:20+00:00", "question_id": "e253ffd55a5995414c71910bea205b39dddf0eb7_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static FT_Error\nskip_literal_string(FT_Byte **acur,\n                    FT_Byte *limit) {\n    FT_Byte *cur = *acur;\n    FT_Int embed = 0;\n    FT_Error error = FT_ERR(Invalid_File_Format);\n    unsigned int i;\n    while (cur < limit) {\n        FT_Byte c = *cur;\n        ++cur;\n        if (c == '\\\\') {\n            /* Red Book 3rd ed., section `Literal Text Strings', p. 29:     */\n            /* A backslash can introduce three different types              */\n            /* of escape sequences:                                         */\n            /*   - a special escaped char like \\r, \\n, etc.                 */\n            /*   - a one-, two-, or three-digit octal number                */\n            /*   - none of the above in which case the backslash is ignored */\n            if (cur == limit)\n                /* error (or to be ignored?) */\n                break;\n            switch (*cur) {\n                /* skip `special' escape */\n                case 'n':\n                case 'r':\n                case 't':\n                case 'b':\n                case 'f':\n                case '\\\\':\n                case '(':\n                case ')':\n                    ++cur;\n                    break;\n                default:\n                    /* skip octal escape or ignore backslash */\n                    for (i = 0; i < 3 && cur < limit; ++i) {\n                        if (!IS_OCTAL_DIGIT(*cur))\n                            break;\n                        ++cur;\n                    }\n            }\n        } else if (c == '(')\n            embed++;\n        else if (c == ')') {\n            embed--;\n            if (embed == 0) {\n                error = FT_Err_Ok;\n                break;\n            }\n        }\n    }\n    *acur = cur;\n    return error;\n"]]}
{"hexsha": "24eb4d26ffa59affc775fe27a637ab2b4d86abe5", "ext": "h", "lang": "C", "content": "class AutoShapeTransformAction : public TransformAction {\n public:\n\t\t\t\t\t\t\t\tAutoShapeTransformAction(AutoShapeState* state,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ShapeStroke* object,\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t const control_point* points,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t int32 count,\n\t\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t BPoint translation,\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t double rotation,\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t double xScale,\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t double yScale,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t const Transformable& t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t BPoint centerOffset,\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t const char* actionName,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t uint32 nameIndex);\n\n\tvirtual\t\t\t\t\t\t~AutoShapeTransformAction();\n\t\n\tvirtual\tstatus_t\t\t\tInitCheck();\n\n protected:\n\tvirtual\tstatus_t\t\t\t_SetTransformation(CanvasView* view,\n//\t\t\t\t\t\t\t\t\t\t\t\t   BPoint translation,\n//\t\t\t\t\t\t\t\t\t\t\t\t   double rotation,\n//\t\t\t\t\t\t\t\t\t\t\t\t   double xScale,\n//\t\t\t\t\t\t\t\t\t\t\t\t   double yScale,\n\t\t\t\t\t\t\t\t\t\t\t\t   const Transformable& t,\n\t\t\t\t\t\t\t\t\t\t\t\t   BPoint centerOffset) const;\n\n\t\t\tAutoShapeState*\t\tfState;\n\t\t\tShapeStroke*\t\tfShape;\n\n\t\t\tcontrol_point*\t\tfPoints;\n\t\t\tint32\t\t\t\tfCount;\n}", "item_id": 0, "repo": "waddlesplash/WonderBrush-v2", "file": "WonderBrush/src/tools/auto_shape/history/AutoShapeTransformAction.h", "last_update_at": "2021-12-27T17:17:08+00:00", "question_id": "24eb4d26ffa59affc775fe27a637ab2b4d86abe5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class AutoShapeTransformAction : public TransformAction {\n public:\n\t\t\t\t\t\t\t\tAutoShapeTransformAction(AutoShapeState* state,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ShapeStroke* object,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t const control_point* points,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t int32 count,\n\t\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t BPoint translation,\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t double rotation,\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t double xScale,\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t double yScale,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t const Transformable& t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t BPoint centerOffset,\n\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t const char* actionName,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t uint32 nameIndex);\n\tvirtual\t\t\t\t\t\t~AutoShapeTransformAction();\n\t\n\tvirtual\tstatus_t\t\t\tInitCheck();\n protected:\n\tvirtual\tstatus_t\t\t\t_SetTransformation(CanvasView* view,\n//\t\t\t\t\t\t\t\t\t\t\t\t   BPoint translation,\n//\t\t\t\t\t\t\t\t\t\t\t\t   double rotation,\n//\t\t\t\t\t\t\t\t\t\t\t\t   double xScale,\n//\t\t\t\t\t\t\t\t\t\t\t\t   double yScale,\n\t\t\t\t\t\t\t\t\t\t\t\t   const Transformable& t,\n\t\t\t\t\t\t\t\t\t\t\t\t   BPoint centerOffset) const;\n\t\t\tAutoShapeState*\t\tfState;\n\t\t\tShapeStroke*\t\tfShape;\n\t\t\tcontrol_point*\t\tfPoints;\n\t\t\tint32\t\t\t\tfCount;\n"]]}
{"hexsha": "2f896fc6863ae9e347d35e8ddc59da2799ea1987", "ext": "c", "lang": "C", "content": "int add_item( char* packet, int client_fd )\n{\n\tchar* ptr = strtok( packet, \"|\" );\n\n\t// check free space\n\tint free_space = MARKET_MAX_SIZE - ( g_market->count_of_items * sizeof( market_item ) );\n\n\tif ( free_space <= 0 )\n\t{\n\t\tprintf( \"[-] No available space to add item!\" );\n\t\tchar* packet = (char*) malloc( 64 );\n\t\tmemset( packet, 0, 64 );\n\n\t\tstrcpy( packet, \"item_not_added\" );\n\t\tint packet_size = strlen( packet );\n\n\t\tint nbytes = send( client_fd, packet, packet_size, 0 );\n\n\t\tif ( nbytes != packet_size )\n\t\t{\n\t\t\tprintf( \"[-] Some error in clinet send!\" );\n\t\t\treturn SENDING_ERROR;\n\t\t}\n\n\t\treturn NO_FREE_SPACE;\n\t}\n\n\t// find first free entry\n\tint new_item_idx = find_free_entry();\n\n\tif ( new_item_idx == -1 )\n\t{\t\n\t\tchar* packet = (char*) malloc( 64 );\n\t\tmemset( packet, 0, 64 );\n\n\t\tstrcpy( packet, \"item_not_added\" );\n\t\tint packet_size = strlen( packet );\n\n\t\tint nbytes = send( client_fd, packet, packet_size, 0 );\n\n\t\tif ( nbytes != packet_size )\n\t\t{\n\t\t\tprintf( \"[-] Some error in clinet send!\" );\n\t\t\treturn SENDING_ERROR;\n\t\t}\n\n\t\tprintf( \"[-] Cant find any free entry!\" );\n\t\treturn NO_FREE_SPACE;\n\t}\n\n\tif ( new_item_idx > g_market->max_item_id )\n\t{\n\t\tg_market->max_item_id = new_item_idx;\n\t}\n\n\tg_market->count_of_items += 1;\n\tg_market->chunks[ new_item_idx ].used = TRUE;\n\n\t// copy name to struct\n\tptr = strtok( NULL, \"|\" );\n\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\n\t}\n\n\tstrcpy( g_market->chunks[ new_item_idx ].name, ptr );\n\n\t// copy description to struct\n\tptr = strtok( NULL, \"|\" );\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\n\t}\n\n\tstrcpy( g_market->chunks[ new_item_idx ].description, ptr );\n\n\t// copy cost to struct\n\tptr = strtok( NULL, \"|\" );\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\n\t}\n\n\tg_market->chunks[ new_item_idx ].cost = atoi( ptr );\n\n\t// copy quality to struct\n\tptr = strtok( NULL, \"|\" );\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\n\t}\n\n\tg_market->chunks[ new_item_idx ].quality = atoi( ptr );\n\n\t// copy owner to struct\n\tptr = strtok( NULL, \"|\" );\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\n\t}\n\n\tstrcpy( g_market->chunks[ new_item_idx ].owner, ptr );\n\n\t// set is archived\n\tptr = strtok( NULL, \"|\" );\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\n\t}\n\n\tif ( atoi( ptr ) == 1 )\n\t\tg_market->chunks[ new_item_idx ].is_archived = TRUE;\n\telse\n\t\tg_market->chunks[ new_item_idx ].is_archived = FALSE;\n\n\t// set token\n\tptr = strtok( NULL, \"|\" );\n\tg_market->chunks[ new_item_idx ].token = atoi( ptr );\n\n\t// copy password\n\tptr = strtok( NULL, \"|\" );\n\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\t\n\t}\n\n\tstrcpy( g_market->chunks[ new_item_idx ].password, ptr );\n\n\t// update file on FS\n\tmsync( (void*)g_market, MARKET_MAX_SIZE, MS_SYNC );\n\n\t// send correct code\n\tchar* s_packet = (char*) malloc( 64 );\n\tmemset( s_packet, 0, 64 );\n\n\tstrcpy( s_packet, \"item_added\" );\n\tint packet_size = strlen( s_packet );\n\n\tint nbytes = send( client_fd, s_packet, packet_size, 0 );\n\n\tif ( nbytes != packet_size )\n\t{\n\t\tprintf( \"[-] Some error in clinet send!\" );\n\t\tfree( s_packet );\n\t\treturn SENDING_ERROR;\n\t}\n\n\tfree( s_packet );\n\n\treturn ITEM_ADDED;\n}", "item_id": 8, "repo": "C4T-BuT-S4D/training-18-10-2020", "file": "internal/sijang/market/market.c", "last_update_at": "2021-11-18T21:42:28+00:00", "question_id": "2f896fc6863ae9e347d35e8ddc59da2799ea1987_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int add_item( char* packet, int client_fd )\n{\n\tchar* ptr = strtok( packet, \"|\" );\n\t// check free space\n\tint free_space = MARKET_MAX_SIZE - ( g_market->count_of_items * sizeof( market_item ) );\n\tif ( free_space <= 0 )\n\t{\n\t\tprintf( \"[-] No available space to add item!\" );\n\t\tchar* packet = (char*) malloc( 64 );\n\t\tmemset( packet, 0, 64 );\n\t\tstrcpy( packet, \"item_not_added\" );\n\t\tint packet_size = strlen( packet );\n\t\tint nbytes = send( client_fd, packet, packet_size, 0 );\n\t\tif ( nbytes != packet_size )\n\t\t{\n\t\t\tprintf( \"[-] Some error in clinet send!\" );\n\t\t\treturn SENDING_ERROR;\n\t\t}\n\t\treturn NO_FREE_SPACE;\n\t}\n\t// find first free entry\n\tint new_item_idx = find_free_entry();\n\tif ( new_item_idx == -1 )\n\t{\t\n\t\tchar* packet = (char*) malloc( 64 );\n\t\tmemset( packet, 0, 64 );\n\t\tstrcpy( packet, \"item_not_added\" );\n\t\tint packet_size = strlen( packet );\n\t\tint nbytes = send( client_fd, packet, packet_size, 0 );\n\t\tif ( nbytes != packet_size )\n\t\t{\n\t\t\tprintf( \"[-] Some error in clinet send!\" );\n\t\t\treturn SENDING_ERROR;\n\t\t}\n\t\tprintf( \"[-] Cant find any free entry!\" );\n\t\treturn NO_FREE_SPACE;\n\t}\n\tif ( new_item_idx > g_market->max_item_id )\n\t{\n\t\tg_market->max_item_id = new_item_idx;\n\t}\n\tg_market->count_of_items += 1;\n\tg_market->chunks[ new_item_idx ].used = TRUE;\n\t// copy name to struct\n\tptr = strtok( NULL, \"|\" );\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\n\t}\n\tstrcpy( g_market->chunks[ new_item_idx ].name, ptr );\n\t// copy description to struct\n\tptr = strtok( NULL, \"|\" );\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\n\t}\n\tstrcpy( g_market->chunks[ new_item_idx ].description, ptr );\n\t// copy cost to struct\n\tptr = strtok( NULL, \"|\" );\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\n\t}\n\tg_market->chunks[ new_item_idx ].cost = atoi( ptr );\n\t// copy quality to struct\n\tptr = strtok( NULL, \"|\" );\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\n\t}\n\tg_market->chunks[ new_item_idx ].quality = atoi( ptr );\n\t// copy owner to struct\n\tptr = strtok( NULL, \"|\" );\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\n\t}\n\tstrcpy( g_market->chunks[ new_item_idx ].owner, ptr );\n\t// set is archived\n\tptr = strtok( NULL, \"|\" );\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\n\t}\n\tif ( atoi( ptr ) == 1 )\n\t\tg_market->chunks[ new_item_idx ].is_archived = TRUE;\n\telse\n\t\tg_market->chunks[ new_item_idx ].is_archived = FALSE;\n\t// set token\n\tptr = strtok( NULL, \"|\" );\n\tg_market->chunks[ new_item_idx ].token = atoi( ptr );\n\t// copy password\n\tptr = strtok( NULL, \"|\" );\n\tif ( ptr == NULL )\n\t{\n\t\t//printf( \"SISGEV!!!, PACKET: %s\\n\", packet );\n\t\treturn SENDING_ERROR;\t\n\t}\n\tstrcpy( g_market->chunks[ new_item_idx ].password, ptr );\n\t// update file on FS\n\tmsync( (void*)g_market, MARKET_MAX_SIZE, MS_SYNC );\n\t// send correct code\n\tchar* s_packet = (char*) malloc( 64 );\n\tmemset( s_packet, 0, 64 );\n\tstrcpy( s_packet, \"item_added\" );\n\tint packet_size = strlen( s_packet );\n\tint nbytes = send( client_fd, s_packet, packet_size, 0 );\n\tif ( nbytes != packet_size )\n\t{\n\t\tprintf( \"[-] Some error in clinet send!\" );\n\t\tfree( s_packet );\n\t\treturn SENDING_ERROR;\n\t}\n\tfree( s_packet );\n\treturn ITEM_ADDED;\n"]]}
{"hexsha": "8fb58292157a5d64f8c3c046435ac92ba7bbb98e", "ext": "c", "lang": "C", "content": "static\nglobus_result_t\nglobus_l_xio_rate_write(\n    void *                              driver_specific_handle,\n    const globus_xio_iovec_t *          iovec,\n    int                                 iovec_count,\n    globus_xio_operation_t              op)\n{\n    globus_result_t                     res;\n    l_xio_rate_handle_t *       handle;\n    l_xio_rate_data_t *         data;\n    GlobusXIOName(globus_l_xio_rate_write);\n\n    GlobusXIORateDebugEnter();\n    handle = (l_xio_rate_handle_t *) driver_specific_handle;\n\n    if(handle->write_handle == NULL)\n    {\n        globus_size_t wait_for = globus_xio_operation_get_wait_for(op);\n        res = globus_xio_driver_pass_write(\n            op,\n            (globus_xio_iovec_t *)iovec,\n            iovec_count,\n            wait_for,\n            NULL,\n            NULL);\n        if(res != GLOBUS_SUCCESS)\n        {\n            goto error;\n        }\n    }\n    else\n    {\n        data = (l_xio_rate_data_t *) globus_calloc(\n            1, sizeof(l_xio_rate_data_t));\n        data->op = op;\n        data->iovc = iovec_count;\n        data->iov = (globus_xio_iovec_t *)\n            globus_calloc(iovec_count, sizeof(globus_xio_iovec_t));\n        data->op_handle = handle->write_handle;\n        data->op_handle->data = data;\n    \n        GlobusIXIOUtilTransferIovec(data->iov, iovec, iovec_count);\n\n        globus_mutex_lock(&data->op_handle->mutex);\n        {\n            l_xio_rate_net_ops(data->op_handle);\n        }\n        globus_mutex_unlock(&data->op_handle->mutex);\n    }\n    GlobusXIORateDebugExit();\n\n    return GLOBUS_SUCCESS;\nerror:\n    return res;\n}", "item_id": 16, "repo": "chrisburr/gct", "file": "xio/drivers/rate/source/globus_xio_rate_driver.c", "last_update_at": "2021-01-27T21:18:47+00:00", "question_id": "8fb58292157a5d64f8c3c046435ac92ba7bbb98e_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static\nglobus_result_t\nglobus_l_xio_rate_write(\n    void *                              driver_specific_handle,\n    const globus_xio_iovec_t *          iovec,\n    int                                 iovec_count,\n    globus_xio_operation_t              op)\n{\n    globus_result_t                     res;\n    l_xio_rate_handle_t *       handle;\n    l_xio_rate_data_t *         data;\n    GlobusXIOName(globus_l_xio_rate_write);\n    GlobusXIORateDebugEnter();\n    handle = (l_xio_rate_handle_t *) driver_specific_handle;\n    if(handle->write_handle == NULL)\n    {\n        globus_size_t wait_for = globus_xio_operation_get_wait_for(op);\n        res = globus_xio_driver_pass_write(\n            op,\n            (globus_xio_iovec_t *)iovec,\n            iovec_count,\n            wait_for,\n            NULL,\n            NULL);\n        if(res != GLOBUS_SUCCESS)\n        {\n            goto error;\n        }\n    }\n    else\n    {\n        data = (l_xio_rate_data_t *) globus_calloc(\n            1, sizeof(l_xio_rate_data_t));\n        data->op = op;\n        data->iovc = iovec_count;\n        data->iov = (globus_xio_iovec_t *)\n            globus_calloc(iovec_count, sizeof(globus_xio_iovec_t));\n        data->op_handle = handle->write_handle;\n        data->op_handle->data = data;\n        GlobusIXIOUtilTransferIovec(data->iov, iovec, iovec_count);\n        globus_mutex_lock(&data->op_handle->mutex);\n        {\n            l_xio_rate_net_ops(data->op_handle);\n        }\n        globus_mutex_unlock(&data->op_handle->mutex);\n    }\n    GlobusXIORateDebugExit();\n    return GLOBUS_SUCCESS;\nerror:\n    return res;\n"]]}
{"hexsha": "ea12ecf3841f580078395ffdce36a36aa667e729", "ext": "c", "lang": "C", "content": "void tls_os_timer_stop(tls_os_timer_t *timer)\n{\n//    rt_kprintf(\"%s %d %p\\r\\n\", __FUNCTION__, __LINE__, timer);\n    rt_err_t err = rt_timer_stop(timer);\n//    if(err != RT_EOK)\n//        rt_kprintf(\"rt_timer_stop error:%d...\\r\\n\", err);\n}", "item_id": 5, "repo": "flyingcys/w600", "file": "Libraries/rtthread/rtthread_patch.c", "last_update_at": "2021-07-04T17:16:39+00:00", "question_id": "ea12ecf3841f580078395ffdce36a36aa667e729_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void tls_os_timer_stop(tls_os_timer_t *timer)\n{\n//    rt_kprintf(\"%s %d %p\\r\\n\", __FUNCTION__, __LINE__, timer);\n    rt_err_t err = rt_timer_stop(timer);\n//    if(err != RT_EOK)\n//        rt_kprintf(\"rt_timer_stop error:%d...\\r\\n\", err);\n"]]}
{"hexsha": "7e3713f218a79f0cbd8c1fac34f82de256dbfd3c", "ext": "c", "lang": "C", "content": "void f193(void) {\n    \tint8_t x841 = INT8_MAX;\n\tstatic int32_t x843 = INT32_MAX;\n\tuint8_t x844 = 20U;\n\tvolatile int32_t t193 = 3;\n\n    t193 = ((x841*(x842<=x843))+x844);\n\n    if (t193 != 147) { NG(); } else { ; }\n\t\n}", "item_id": 193, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test1793.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "7e3713f218a79f0cbd8c1fac34f82de256dbfd3c_193", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f193(void) {\n    \tint8_t x841 = INT8_MAX;\n\tstatic int32_t x843 = INT32_MAX;\n\tuint8_t x844 = 20U;\n\tvolatile int32_t t193 = 3;\n    t193 = ((x841*(x842<=x843))+x844);\n    if (t193 != 147) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "ab78fb58a5325ef8ba9f736bcf800186886c4f7c", "ext": "c", "lang": "C", "content": "void f185(void) {\n    \tint8_t x6213 = -1;\n\tstatic int32_t x6214 = INT32_MIN;\n\tuint32_t x6215 = UINT32_MAX;\n\tuint16_t x6216 = 11U;\n\n    t185 = ((x6213<=(x6214!=x6215))>>x6216);\n\n    if (t185 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 185, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test1313.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "ab78fb58a5325ef8ba9f736bcf800186886c4f7c_185", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f185(void) {\n    \tint8_t x6213 = -1;\n\tstatic int32_t x6214 = INT32_MIN;\n\tuint32_t x6215 = UINT32_MAX;\n\tuint16_t x6216 = 11U;\n    t185 = ((x6213<=(x6214!=x6215))>>x6216);\n    if (t185 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "9d4a3fd63781bf437ae81bbbb9e1dfe869ec54b6", "ext": "h", "lang": "C", "content": "void MidLine(int x1, int y1, int x2, int y2)\n{\n\t//\u4ea4\u6362\u4e24\u70b9\u7684\u5750\u6807\n\tif ((x1 - x2) > 0 && (y1 - y2) > 0)\n\t{\n\t\tint c = x1;\n\t\tx1 = x2;\n\t\tx2 = c;\n\t\tc = y1;\n\t\ty1 = y2;\n\t\ty2 = c;\n\t}\n\tif ((x1 - x2) < 0 && (y1 - y2) > 0)\n\t{\n\t\tint c = x1;\n\t\tx1 = x2;\n\t\tx2 = c;\n\t\tc = y1;\n\t\ty1 = y2;\n\t\ty2 = c;\n\t}\n\tfloat a = y1 - y2, b = x2 - x1;\n\tfloat m = -(a / b); //\u659c\u7387\uff0c\u7528\u4e8e\u5224\u65ad\u76f4\u7ebf\u4e0d\u540c\u7684\u60c5\u51b5\n\n\t//\u5f53\u659c\u7387\u5927\u4e8e0\uff0c\u5c0f\u4e8e1\u7684\u60c5\u51b5\n\tif (0 <= m && m <= 1)\n\t{\n\t\tfloat d = 2 * a + b, deta1 = 2 * a, deta2 = 2 * (a + b), x = x1, y = y1;\n\t\twhile (x < x2)\n\t\t{\n\t\t\tSetPixel(x, y); //\u753b\u5750\u6807\u70b9\n\t\t\tif (d < 0)\n\t\t\t{\n\t\t\t\tx++, y++, d += deta2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx++, d += deta1;\n\t\t\t}\n\t\t}\n\t}\n\t//\u5f53\u659c\u7387\u5927\u4e8e1\u7684\u60c5\u51b5\n\tif (m > 1)\n\t{\n\t\tint d = a + 2 * b, deta1 = 2 * b, deta2 = 2 * (a + b), x = x1, y = y1;\n\t\twhile (y < y2)\n\t\t{\n\t\t\tSetPixel(x, y); //\u753b\u5750\u6807\u70b9\n\t\t\tif (d > 0)\n\t\t\t{\n\t\t\t\ty++, x++, d += deta2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ty++, d += deta1;\n\t\t\t}\n\t\t}\n\t}\n\t//\u5f53\u659c\u7387\u5c0f\u4e8e-1\u7684\u60c5\u51b5\n\tif (m <= -1)\n\t{\n\t\tint d = -a + 2 * b, deta1 = 2 * b, deta2 = 2 * (b - a), x = x1, y = y1;\n\t\twhile (y < y2)\n\t\t{\n\t\t\tSetPixel(x, y); //\u753b\u5750\u6807\u70b9\n\t\t\tif (d < 0)\n\t\t\t{\n\t\t\t\tx--, y++, d += deta2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ty++, d += deta1;\n\t\t\t}\n\t\t}\n\t}\n\t//\u5f53\u659c\u7387\u5c0f\u4e8e0\u5927\u4e8e-1\u7684\u60c5\u51b5\n\tif (m > -1 && m < 0)\n\t{\n\t\tint a = y1 - y2, b = x2 - x1;\n\t\tint d = -2 * a + b, deta1 = -2 * a, deta2 = 2 * (b - a), x = x1, y = y1;\n\t\twhile (x > x2)\n\t\t{\n\t\t\tSetPixel(x, y); //\u753b\u5750\u6807\u70b9\n\t\t\tif (d > 0)\n\t\t\t{\n\t\t\t\tx--, y++, d += deta2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx--, d += deta1;\n\t\t\t}\n\t\t}\n\t}\n}", "item_id": 7, "repo": "wurui1994/test", "file": "Sources/Graphics/DrawBMP/include/drawbmp.h", "last_update_at": "2021-07-30T13:02:00+00:00", "question_id": "9d4a3fd63781bf437ae81bbbb9e1dfe869ec54b6_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void MidLine(int x1, int y1, int x2, int y2)\n{\n\t//\u4ea4\u6362\u4e24\u70b9\u7684\u5750\u6807\n\tif ((x1 - x2) > 0 && (y1 - y2) > 0)\n\t{\n\t\tint c = x1;\n\t\tx1 = x2;\n\t\tx2 = c;\n\t\tc = y1;\n\t\ty1 = y2;\n\t\ty2 = c;\n\t}\n\tif ((x1 - x2) < 0 && (y1 - y2) > 0)\n\t{\n\t\tint c = x1;\n\t\tx1 = x2;\n\t\tx2 = c;\n\t\tc = y1;\n\t\ty1 = y2;\n\t\ty2 = c;\n\t}\n\tfloat a = y1 - y2, b = x2 - x1;\n\tfloat m = -(a / b); //\u659c\u7387\uff0c\u7528\u4e8e\u5224\u65ad\u76f4\u7ebf\u4e0d\u540c\u7684\u60c5\u51b5\n\t//\u5f53\u659c\u7387\u5927\u4e8e0\uff0c\u5c0f\u4e8e1\u7684\u60c5\u51b5\n\tif (0 <= m && m <= 1)\n\t{\n\t\tfloat d = 2 * a + b, deta1 = 2 * a, deta2 = 2 * (a + b), x = x1, y = y1;\n\t\twhile (x < x2)\n\t\t{\n\t\t\tSetPixel(x, y); //\u753b\u5750\u6807\u70b9\n\t\t\tif (d < 0)\n\t\t\t{\n\t\t\t\tx++, y++, d += deta2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx++, d += deta1;\n\t\t\t}\n\t\t}\n\t}\n\t//\u5f53\u659c\u7387\u5927\u4e8e1\u7684\u60c5\u51b5\n\tif (m > 1)\n\t{\n\t\tint d = a + 2 * b, deta1 = 2 * b, deta2 = 2 * (a + b), x = x1, y = y1;\n\t\twhile (y < y2)\n\t\t{\n\t\t\tSetPixel(x, y); //\u753b\u5750\u6807\u70b9\n\t\t\tif (d > 0)\n\t\t\t{\n\t\t\t\ty++, x++, d += deta2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ty++, d += deta1;\n\t\t\t}\n\t\t}\n\t}\n\t//\u5f53\u659c\u7387\u5c0f\u4e8e-1\u7684\u60c5\u51b5\n\tif (m <= -1)\n\t{\n\t\tint d = -a + 2 * b, deta1 = 2 * b, deta2 = 2 * (b - a), x = x1, y = y1;\n\t\twhile (y < y2)\n\t\t{\n\t\t\tSetPixel(x, y); //\u753b\u5750\u6807\u70b9\n\t\t\tif (d < 0)\n\t\t\t{\n\t\t\t\tx--, y++, d += deta2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ty++, d += deta1;\n\t\t\t}\n\t\t}\n\t}\n\t//\u5f53\u659c\u7387\u5c0f\u4e8e0\u5927\u4e8e-1\u7684\u60c5\u51b5\n\tif (m > -1 && m < 0)\n\t{\n\t\tint a = y1 - y2, b = x2 - x1;\n\t\tint d = -2 * a + b, deta1 = -2 * a, deta2 = 2 * (b - a), x = x1, y = y1;\n\t\twhile (x > x2)\n\t\t{\n\t\t\tSetPixel(x, y); //\u753b\u5750\u6807\u70b9\n\t\t\tif (d > 0)\n\t\t\t{\n\t\t\t\tx--, y++, d += deta2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx--, d += deta1;\n\t\t\t}\n\t\t}\n\t}\n"]]}
{"hexsha": "ec120dc2eab18b1b8efe4ef74abb6693528717ad", "ext": "c", "lang": "C", "content": "static PyObject *__pyx_pf_6_loess_11loess_model_update(struct __pyx_obj_6_loess_loess_model *__pyx_v_self, PyObject *__pyx_v_modelargs) {\n  PyObject *__pyx_v_family = NULL;\n  PyObject *__pyx_v_span = NULL;\n  PyObject *__pyx_v_degree = NULL;\n  PyObject *__pyx_v_normalize = NULL;\n  PyObject *__pyx_v_parametric = NULL;\n  PyObject *__pyx_v_drop_square = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  int __pyx_t_2;\n  int __pyx_t_3;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"update\", 0);\n\n  /* \"_loess.pyx\":393\n *     #........\n *     def update(self, **modelargs):\n *         family = modelargs.get('family', None)             # <<<<<<<<<<<<<<\n *         if family is not None:\n *             self.family = family\n */\n  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_family, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 393; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_family = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"_loess.pyx\":394\n *     def update(self, **modelargs):\n *         family = modelargs.get('family', None)\n *         if family is not None:             # <<<<<<<<<<<<<<\n *             self.family = family\n *         #\n */\n  __pyx_t_2 = (__pyx_v_family != Py_None);\n  __pyx_t_3 = (__pyx_t_2 != 0);\n  if (__pyx_t_3) {\n\n    /* \"_loess.pyx\":395\n *         family = modelargs.get('family', None)\n *         if family is not None:\n *             self.family = family             # <<<<<<<<<<<<<<\n *         #\n *         span = modelargs.get('span', None)\n */\n    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_family, __pyx_v_family) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 395; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L3;\n  }\n  __pyx_L3:;\n\n  /* \"_loess.pyx\":397\n *             self.family = family\n *         #\n *         span = modelargs.get('span', None)             # <<<<<<<<<<<<<<\n *         if span is not None:\n *             self.span = span\n */\n  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_span, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_span = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"_loess.pyx\":398\n *         #\n *         span = modelargs.get('span', None)\n *         if span is not None:             # <<<<<<<<<<<<<<\n *             self.span = span\n *         #\n */\n  __pyx_t_3 = (__pyx_v_span != Py_None);\n  __pyx_t_2 = (__pyx_t_3 != 0);\n  if (__pyx_t_2) {\n\n    /* \"_loess.pyx\":399\n *         span = modelargs.get('span', None)\n *         if span is not None:\n *             self.span = span             # <<<<<<<<<<<<<<\n *         #\n *         degree = modelargs.get('degree', None)\n */\n    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_span, __pyx_v_span) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 399; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L4;\n  }\n  __pyx_L4:;\n\n  /* \"_loess.pyx\":401\n *             self.span = span\n *         #\n *         degree = modelargs.get('degree', None)             # <<<<<<<<<<<<<<\n *         if degree is not None:\n *             self.degree = degree\n */\n  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_degree, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_degree = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"_loess.pyx\":402\n *         #\n *         degree = modelargs.get('degree', None)\n *         if degree is not None:             # <<<<<<<<<<<<<<\n *             self.degree = degree\n *         #\n */\n  __pyx_t_2 = (__pyx_v_degree != Py_None);\n  __pyx_t_3 = (__pyx_t_2 != 0);\n  if (__pyx_t_3) {\n\n    /* \"_loess.pyx\":403\n *         degree = modelargs.get('degree', None)\n *         if degree is not None:\n *             self.degree = degree             # <<<<<<<<<<<<<<\n *         #\n *         normalize = modelargs.get('normalize', None)\n */\n    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_degree, __pyx_v_degree) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 403; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L5;\n  }\n  __pyx_L5:;\n\n  /* \"_loess.pyx\":405\n *             self.degree = degree\n *         #\n *         normalize = modelargs.get('normalize', None)             # <<<<<<<<<<<<<<\n *         if normalize is not None:\n *             self.normalize = normalize\n */\n  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_normalize, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_normalize = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"_loess.pyx\":406\n *         #\n *         normalize = modelargs.get('normalize', None)\n *         if normalize is not None:             # <<<<<<<<<<<<<<\n *             self.normalize = normalize\n *         #\n */\n  __pyx_t_3 = (__pyx_v_normalize != Py_None);\n  __pyx_t_2 = (__pyx_t_3 != 0);\n  if (__pyx_t_2) {\n\n    /* \"_loess.pyx\":407\n *         normalize = modelargs.get('normalize', None)\n *         if normalize is not None:\n *             self.normalize = normalize             # <<<<<<<<<<<<<<\n *         #\n *         parametric = modelargs.get('parametric', None)\n */\n    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_normalize, __pyx_v_normalize) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L6;\n  }\n  __pyx_L6:;\n\n  /* \"_loess.pyx\":409\n *             self.normalize = normalize\n *         #\n *         parametric = modelargs.get('parametric', None)             # <<<<<<<<<<<<<<\n *         if parametric is not None:\n *             self.parametric_flags = parametric\n */\n  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_parametric, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_parametric = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"_loess.pyx\":410\n *         #\n *         parametric = modelargs.get('parametric', None)\n *         if parametric is not None:             # <<<<<<<<<<<<<<\n *             self.parametric_flags = parametric\n *         #\n */\n  __pyx_t_2 = (__pyx_v_parametric != Py_None);\n  __pyx_t_3 = (__pyx_t_2 != 0);\n  if (__pyx_t_3) {\n\n    /* \"_loess.pyx\":411\n *         parametric = modelargs.get('parametric', None)\n *         if parametric is not None:\n *             self.parametric_flags = parametric             # <<<<<<<<<<<<<<\n *         #\n *         drop_square = modelargs.get('drop_square', None)\n */\n    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_parametric_flags, __pyx_v_parametric) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L7;\n  }\n  __pyx_L7:;\n\n  /* \"_loess.pyx\":413\n *             self.parametric_flags = parametric\n *         #\n *         drop_square = modelargs.get('drop_square', None)             # <<<<<<<<<<<<<<\n *         if drop_square is not None:\n *             self.drop_square_flags = drop_square\n */\n  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_drop_square, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_drop_square = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"_loess.pyx\":414\n *         #\n *         drop_square = modelargs.get('drop_square', None)\n *         if drop_square is not None:             # <<<<<<<<<<<<<<\n *             self.drop_square_flags = drop_square\n *     #.........\n */\n  __pyx_t_3 = (__pyx_v_drop_square != Py_None);\n  __pyx_t_2 = (__pyx_t_3 != 0);\n  if (__pyx_t_2) {\n\n    /* \"_loess.pyx\":415\n *         drop_square = modelargs.get('drop_square', None)\n *         if drop_square is not None:\n *             self.drop_square_flags = drop_square             # <<<<<<<<<<<<<<\n *     #.........\n *     def __repr__(self):\n */\n    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_drop_square_flags, __pyx_v_drop_square) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L8;\n  }\n  __pyx_L8:;\n\n  /* \"_loess.pyx\":392\n *                 self._base.drop_square[i] = d_ndr[i]\n *     #........\n *     def update(self, **modelargs):             # <<<<<<<<<<<<<<\n *         family = modelargs.get('family', None)\n *         if family is not None:\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"_loess.loess_model.update\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_family);\n  __Pyx_XDECREF(__pyx_v_span);\n  __Pyx_XDECREF(__pyx_v_degree);\n  __Pyx_XDECREF(__pyx_v_normalize);\n  __Pyx_XDECREF(__pyx_v_parametric);\n  __Pyx_XDECREF(__pyx_v_drop_square);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}", "item_id": 78, "repo": "jcrotinger/pyloess", "file": "src/_loess.c", "last_update_at": "2021-06-08T06:13:19+00:00", "question_id": "ec120dc2eab18b1b8efe4ef74abb6693528717ad_78", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject *__pyx_pf_6_loess_11loess_model_update(struct __pyx_obj_6_loess_loess_model *__pyx_v_self, PyObject *__pyx_v_modelargs) {\n  PyObject *__pyx_v_family = NULL;\n  PyObject *__pyx_v_span = NULL;\n  PyObject *__pyx_v_degree = NULL;\n  PyObject *__pyx_v_normalize = NULL;\n  PyObject *__pyx_v_parametric = NULL;\n  PyObject *__pyx_v_drop_square = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  int __pyx_t_2;\n  int __pyx_t_3;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"update\", 0);\n  /* \"_loess.pyx\":393\n *     #........\n *     def update(self, **modelargs):\n *         family = modelargs.get('family', None)             # <<<<<<<<<<<<<<\n *         if family is not None:\n *             self.family = family\n */\n  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_family, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 393; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_family = __pyx_t_1;\n  __pyx_t_1 = 0;\n  /* \"_loess.pyx\":394\n *     def update(self, **modelargs):\n *         family = modelargs.get('family', None)\n *         if family is not None:             # <<<<<<<<<<<<<<\n *             self.family = family\n *         #\n */\n  __pyx_t_2 = (__pyx_v_family != Py_None);\n  __pyx_t_3 = (__pyx_t_2 != 0);\n  if (__pyx_t_3) {\n    /* \"_loess.pyx\":395\n *         family = modelargs.get('family', None)\n *         if family is not None:\n *             self.family = family             # <<<<<<<<<<<<<<\n *         #\n *         span = modelargs.get('span', None)\n */\n    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_family, __pyx_v_family) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 395; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L3;\n  }\n  __pyx_L3:;\n  /* \"_loess.pyx\":397\n *             self.family = family\n *         #\n *         span = modelargs.get('span', None)             # <<<<<<<<<<<<<<\n *         if span is not None:\n *             self.span = span\n */\n  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_span, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_span = __pyx_t_1;\n  __pyx_t_1 = 0;\n  /* \"_loess.pyx\":398\n *         #\n *         span = modelargs.get('span', None)\n *         if span is not None:             # <<<<<<<<<<<<<<\n *             self.span = span\n *         #\n */\n  __pyx_t_3 = (__pyx_v_span != Py_None);\n  __pyx_t_2 = (__pyx_t_3 != 0);\n  if (__pyx_t_2) {\n    /* \"_loess.pyx\":399\n *         span = modelargs.get('span', None)\n *         if span is not None:\n *             self.span = span             # <<<<<<<<<<<<<<\n *         #\n *         degree = modelargs.get('degree', None)\n */\n    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_span, __pyx_v_span) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 399; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L4;\n  }\n  __pyx_L4:;\n  /* \"_loess.pyx\":401\n *             self.span = span\n *         #\n *         degree = modelargs.get('degree', None)             # <<<<<<<<<<<<<<\n *         if degree is not None:\n *             self.degree = degree\n */\n  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_degree, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_degree = __pyx_t_1;\n  __pyx_t_1 = 0;\n  /* \"_loess.pyx\":402\n *         #\n *         degree = modelargs.get('degree', None)\n *         if degree is not None:             # <<<<<<<<<<<<<<\n *             self.degree = degree\n *         #\n */\n  __pyx_t_2 = (__pyx_v_degree != Py_None);\n  __pyx_t_3 = (__pyx_t_2 != 0);\n  if (__pyx_t_3) {\n    /* \"_loess.pyx\":403\n *         degree = modelargs.get('degree', None)\n *         if degree is not None:\n *             self.degree = degree             # <<<<<<<<<<<<<<\n *         #\n *         normalize = modelargs.get('normalize', None)\n */\n    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_degree, __pyx_v_degree) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 403; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L5;\n  }\n  __pyx_L5:;\n  /* \"_loess.pyx\":405\n *             self.degree = degree\n *         #\n *         normalize = modelargs.get('normalize', None)             # <<<<<<<<<<<<<<\n *         if normalize is not None:\n *             self.normalize = normalize\n */\n  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_normalize, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_normalize = __pyx_t_1;\n  __pyx_t_1 = 0;\n  /* \"_loess.pyx\":406\n *         #\n *         normalize = modelargs.get('normalize', None)\n *         if normalize is not None:             # <<<<<<<<<<<<<<\n *             self.normalize = normalize\n *         #\n */\n  __pyx_t_3 = (__pyx_v_normalize != Py_None);\n  __pyx_t_2 = (__pyx_t_3 != 0);\n  if (__pyx_t_2) {\n    /* \"_loess.pyx\":407\n *         normalize = modelargs.get('normalize', None)\n *         if normalize is not None:\n *             self.normalize = normalize             # <<<<<<<<<<<<<<\n *         #\n *         parametric = modelargs.get('parametric', None)\n */\n    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_normalize, __pyx_v_normalize) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L6;\n  }\n  __pyx_L6:;\n  /* \"_loess.pyx\":409\n *             self.normalize = normalize\n *         #\n *         parametric = modelargs.get('parametric', None)             # <<<<<<<<<<<<<<\n *         if parametric is not None:\n *             self.parametric_flags = parametric\n */\n  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_parametric, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_parametric = __pyx_t_1;\n  __pyx_t_1 = 0;\n  /* \"_loess.pyx\":410\n *         #\n *         parametric = modelargs.get('parametric', None)\n *         if parametric is not None:             # <<<<<<<<<<<<<<\n *             self.parametric_flags = parametric\n *         #\n */\n  __pyx_t_2 = (__pyx_v_parametric != Py_None);\n  __pyx_t_3 = (__pyx_t_2 != 0);\n  if (__pyx_t_3) {\n    /* \"_loess.pyx\":411\n *         parametric = modelargs.get('parametric', None)\n *         if parametric is not None:\n *             self.parametric_flags = parametric             # <<<<<<<<<<<<<<\n *         #\n *         drop_square = modelargs.get('drop_square', None)\n */\n    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_parametric_flags, __pyx_v_parametric) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L7;\n  }\n  __pyx_L7:;\n  /* \"_loess.pyx\":413\n *             self.parametric_flags = parametric\n *         #\n *         drop_square = modelargs.get('drop_square', None)             # <<<<<<<<<<<<<<\n *         if drop_square is not None:\n *             self.drop_square_flags = drop_square\n */\n  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_drop_square, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_drop_square = __pyx_t_1;\n  __pyx_t_1 = 0;\n  /* \"_loess.pyx\":414\n *         #\n *         drop_square = modelargs.get('drop_square', None)\n *         if drop_square is not None:             # <<<<<<<<<<<<<<\n *             self.drop_square_flags = drop_square\n *     #.........\n */\n  __pyx_t_3 = (__pyx_v_drop_square != Py_None);\n  __pyx_t_2 = (__pyx_t_3 != 0);\n  if (__pyx_t_2) {\n    /* \"_loess.pyx\":415\n *         drop_square = modelargs.get('drop_square', None)\n *         if drop_square is not None:\n *             self.drop_square_flags = drop_square             # <<<<<<<<<<<<<<\n *     #.........\n *     def __repr__(self):\n */\n    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_drop_square_flags, __pyx_v_drop_square) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n    goto __pyx_L8;\n  }\n  __pyx_L8:;\n  /* \"_loess.pyx\":392\n *                 self._base.drop_square[i] = d_ndr[i]\n *     #........\n *     def update(self, **modelargs):             # <<<<<<<<<<<<<<\n *         family = modelargs.get('family', None)\n *         if family is not None:\n */\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"_loess.loess_model.update\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XDECREF(__pyx_v_family);\n  __Pyx_XDECREF(__pyx_v_span);\n  __Pyx_XDECREF(__pyx_v_degree);\n  __Pyx_XDECREF(__pyx_v_normalize);\n  __Pyx_XDECREF(__pyx_v_parametric);\n  __Pyx_XDECREF(__pyx_v_drop_square);\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n"]]}
{"hexsha": "dec7331b40de319bbde7bb6d35dbbf2d7c7a120a", "ext": "c", "lang": "C", "content": "static void test_decode(dAT)\n{\n    apr_size_t elen;\n    char src1[] = \"%C3%80%E3%82%a2\"; /* A_GRAVE KATAKANA_A as utf8 */\n    unsigned char expect[6];\n\n    AT_int_eq(apreq_decode((char *)expect, &elen, src1, sizeof(src1) -1), \n              APR_SUCCESS + APREQ_CHARSET_UTF8);\n    AT_int_eq(elen, 5);\n    AT_int_eq(expect[0], 0xC3);\n    AT_int_eq(expect[1], 0x80);\n    AT_int_eq(expect[2], 0xE3);\n    AT_int_eq(expect[3], 0x82);\n    AT_int_eq(expect[4], 0xA2);\n}", "item_id": 3, "repo": "brianbolt/rapache", "file": "libapreq2/library/t/util.c", "last_update_at": "2021-11-26T10:35:10+00:00", "question_id": "dec7331b40de319bbde7bb6d35dbbf2d7c7a120a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void test_decode(dAT)\n{\n    apr_size_t elen;\n    char src1[] = \"%C3%80%E3%82%a2\"; /* A_GRAVE KATAKANA_A as utf8 */\n    unsigned char expect[6];\n    AT_int_eq(apreq_decode((char *)expect, &elen, src1, sizeof(src1) -1), \n              APR_SUCCESS + APREQ_CHARSET_UTF8);\n    AT_int_eq(elen, 5);\n    AT_int_eq(expect[0], 0xC3);\n    AT_int_eq(expect[1], 0x80);\n    AT_int_eq(expect[2], 0xE3);\n    AT_int_eq(expect[3], 0x82);\n    AT_int_eq(expect[4], 0xA2);\n"]]}
{"hexsha": "4a645f0b0ce7a13c04d46eb9c62cf4acfdc63656", "ext": "c", "lang": "C", "content": "void f143(void) {\n    \tint16_t x601 = -1919;\n\tint8_t x602 = -3;\n\tuint64_t x603 = UINT64_MAX;\n\tstatic int8_t x604 = -42;\n\n    t143 = ((x601-(x602==x603))/x604);\n\n    if (t143 != 45) { NG(); } else { ; }\n\t\n}", "item_id": 143, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test1390.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "4a645f0b0ce7a13c04d46eb9c62cf4acfdc63656_143", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f143(void) {\n    \tint16_t x601 = -1919;\n\tint8_t x602 = -3;\n\tuint64_t x603 = UINT64_MAX;\n\tstatic int8_t x604 = -42;\n    t143 = ((x601-(x602==x603))/x604);\n    if (t143 != 45) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "d7f0978c56ffd36dc7f5c28d3f889bcc4c08f2f0", "ext": "c", "lang": "C", "content": "static void \ndslash_fn_field_F( su3_vector *src, su3_vector *dest, \n\t\t   int parity, fn_links_qop_t *fn){\n\n  QOP_info_t info = {0., 0., 0, 0, 0};\n  int otherparity = opposite_parity(parity);\n  QOP_F3_FermionLinksAsqtad *al_F = get_F_asqtad_links(fn);\n  QOP_F3_ColorVector *in = create_F_V_from_field( src, otherparity);\n  QOP_F3_ColorVector *out = create_F_V_from_field( dest, parity);\n  QOP_evenodd_t eo_out, eo_in;\n\n  eo_out = milc2qop_parity(parity);\n  eo_in = milc2qop_parity(otherparity);\n\n  /* We want just dslash so we use zero mass */\n  QOP_F3_asqtad_dslash(&info, al_F, 0.0, out, in, eo_out, eo_in);\n\n  unload_F_V_to_field( dest, out, parity);\n\n  /* Fix the normalization */\n  qop_to_milc_dslash_normalization(dest, parity);\n\n  QOP_F3_destroy_V(out);\n  QOP_F3_destroy_V(in);\n}", "item_id": 2, "repo": "mcopik/perf-taint", "file": "benchmarks/milc/milc_qcd-7.8.1/generic_ks/dslash_fn_qop.c", "last_update_at": "2021-03-22T05:10:24+00:00", "question_id": "d7f0978c56ffd36dc7f5c28d3f889bcc4c08f2f0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void \ndslash_fn_field_F( su3_vector *src, su3_vector *dest, \n\t\t   int parity, fn_links_qop_t *fn){\n  QOP_info_t info = {0., 0., 0, 0, 0};\n  int otherparity = opposite_parity(parity);\n  QOP_F3_FermionLinksAsqtad *al_F = get_F_asqtad_links(fn);\n  QOP_F3_ColorVector *in = create_F_V_from_field( src, otherparity);\n  QOP_F3_ColorVector *out = create_F_V_from_field( dest, parity);\n  QOP_evenodd_t eo_out, eo_in;\n  eo_out = milc2qop_parity(parity);\n  eo_in = milc2qop_parity(otherparity);\n  /* We want just dslash so we use zero mass */\n  QOP_F3_asqtad_dslash(&info, al_F, 0.0, out, in, eo_out, eo_in);\n  unload_F_V_to_field( dest, out, parity);\n  /* Fix the normalization */\n  qop_to_milc_dslash_normalization(dest, parity);\n  QOP_F3_destroy_V(out);\n  QOP_F3_destroy_V(in);\n"]]}
{"hexsha": "c044c40bfeb766a45fce4fc17fada733269255f8", "ext": "c", "lang": "C", "content": "const char *get_tle_info(const char *tle_filename, const char *satellite)\n{\n    sat_t sat;\n    read_tle(satellite, &sat);\n\n    static char tle_info[256];\n    sprintf(tle_info,\n            \"Satellite: %s\\n\"\n            \"Date: %s\",\n            satellite, date_str_long(time_to_secs(sat.tle.epoch_year,\n                                                  sat.tle.epoch_day,\n                                                  sat.tle.epoch_fod)));\n\n    return tle_info;\n}", "item_id": 5, "repo": "glshort/MapReady", "file": "src/sst/tle.c", "last_update_at": "2021-07-28T01:51:22+00:00", "question_id": "c044c40bfeb766a45fce4fc17fada733269255f8_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["const char *get_tle_info(const char *tle_filename, const char *satellite)\n{\n    sat_t sat;\n    read_tle(satellite, &sat);\n    static char tle_info[256];\n    sprintf(tle_info,\n            \"Satellite: %s\\n\"\n            \"Date: %s\",\n            satellite, date_str_long(time_to_secs(sat.tle.epoch_year,\n                                                  sat.tle.epoch_day,\n                                                  sat.tle.epoch_fod)));\n    return tle_info;\n"]]}
{"hexsha": "275a856b61fc9138aeff88662fb16fd638aaef95", "ext": "c", "lang": "C", "content": "void app_qspi_std_write(periph_inst_handle_t hdl,uint8_t cs_sel_mask,uint8_t *data,uint32_t length)\n{\n    app_qspi_inst_t *inst = CONTAINER_OF(hdl, app_qspi_inst_t, inst);\n    uint16_t fifo_depth = qspi_get_fifo_depth(inst);\n    reg_ssi_t *reg = inst->reg;\n    qspi_universal_func.clk_gate_func(inst,SET_CLK);\n    qspi_universal_func.sys_stat_func(inst,QSPI_OP_START);\n    qspi_std_byte_write_dma_config(reg,fifo_depth);\n    qspi_std_byte_write_dma_start(reg,cs_sel_mask,data,length);\n    qspi_universal_func.sys_stat_func(inst,QSPI_OP_DONE);\n    qspi_universal_func.clk_gate_func(inst,CLR_CLK);\n}", "item_id": 4, "repo": "HESUPING/JmeshBLE-StaticLib", "file": "trunk/plf/peripheral/ssi/app_qspi/app_qspi.c", "last_update_at": "2021-02-04T06:38:35+00:00", "question_id": "275a856b61fc9138aeff88662fb16fd638aaef95_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void app_qspi_std_write(periph_inst_handle_t hdl,uint8_t cs_sel_mask,uint8_t *data,uint32_t length)\n{\n    app_qspi_inst_t *inst = CONTAINER_OF(hdl, app_qspi_inst_t, inst);\n    uint16_t fifo_depth = qspi_get_fifo_depth(inst);\n    reg_ssi_t *reg = inst->reg;\n    qspi_universal_func.clk_gate_func(inst,SET_CLK);\n    qspi_universal_func.sys_stat_func(inst,QSPI_OP_START);\n    qspi_std_byte_write_dma_config(reg,fifo_depth);\n    qspi_std_byte_write_dma_start(reg,cs_sel_mask,data,length);\n    qspi_universal_func.sys_stat_func(inst,QSPI_OP_DONE);\n    qspi_universal_func.clk_gate_func(inst,CLR_CLK);\n"]]}
{"hexsha": "b802ae201b00a8bc6920f60e8bca922874717f44", "ext": "h", "lang": "C", "content": "interface SASourceInfo : NSObject {\n\n\tunsigned _lineNum;\n\tunsigned _columnNum;\n\tunsigned long long _offsetIntoSegment;\n\tunsigned long long _length;\n\tNSString* _filePath;\n\n}", "item_id": 0, "repo": "lechium/tvOS144Headers", "file": "System/Library/PrivateFrameworks/SampleAnalysis.framework/SASourceInfo.h", "last_update_at": "2021-08-19T19:00:09+00:00", "question_id": "b802ae201b00a8bc6920f60e8bca922874717f44_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface SASourceInfo : NSObject {\n\tunsigned _lineNum;\n\tunsigned _columnNum;\n\tunsigned long long _offsetIntoSegment;\n\tunsigned long long _length;\n\tNSString* _filePath;\n"]]}
{"hexsha": "112a0283d3219861dee15da0023cf483a7ab8544", "ext": "c", "lang": "C", "content": "void ds3_head_object_response_free(ds3_head_object_response* response) {\n    if (response == NULL) {\n        return;\n    }\n    if (response->blob_checksum_type != NULL) {\n        g_free(response->blob_checksum_type);\n    }\n    if (response->metadata != NULL) {\n        ds3_metadata_free(response->metadata);\n    }\n    if (response->blob_checksums != NULL) {\n        ds3_uint64_string_map_free(response->blob_checksums);\n    }\n\n    g_free(response);\n}", "item_id": 19, "repo": "RachelTucker/ds3_c_sdk", "file": "src/ds3.c", "last_update_at": "2021-07-21T00:36:20+00:00", "question_id": "112a0283d3219861dee15da0023cf483a7ab8544_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void ds3_head_object_response_free(ds3_head_object_response* response) {\n    if (response == NULL) {\n        return;\n    }\n    if (response->blob_checksum_type != NULL) {\n        g_free(response->blob_checksum_type);\n    }\n    if (response->metadata != NULL) {\n        ds3_metadata_free(response->metadata);\n    }\n    if (response->blob_checksums != NULL) {\n        ds3_uint64_string_map_free(response->blob_checksums);\n    }\n    g_free(response);\n"]]}
{"hexsha": "190cfedd460e25657c7f806f0b11cceffb3daba4", "ext": "c", "lang": "C", "content": "void f158(void) {\n    \tint8_t x742 = INT8_MIN;\n\tint64_t x743 = 191373816114459836LL;\n\tint8_t x744 = INT8_MAX;\n\tvolatile int32_t t158 = 17115;\n\n    t158 = (x741>((x742-x743)/x744));\n\n    if (t158 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 158, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test247.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "190cfedd460e25657c7f806f0b11cceffb3daba4_158", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f158(void) {\n    \tint8_t x742 = INT8_MIN;\n\tint64_t x743 = 191373816114459836LL;\n\tint8_t x744 = INT8_MAX;\n\tvolatile int32_t t158 = 17115;\n    t158 = (x741>((x742-x743)/x744));\n    if (t158 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "8448dab5125c6241fb5100dabb4238e4545d6072", "ext": "c", "lang": "C", "content": "void f114(void) {\n    \tstatic int16_t x494 = INT16_MIN;\n\tstatic int64_t x495 = INT64_MIN;\n\tvolatile int32_t x496 = INT32_MIN;\n\tint64_t t114 = -320099786895396LL;\n\n    t114 = ((x493/(x494^x495))*x496);\n\n    if (t114 != 0LL) { NG(); } else { ; }\n\t\n}", "item_id": 114, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test2593.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "8448dab5125c6241fb5100dabb4238e4545d6072_114", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f114(void) {\n    \tstatic int16_t x494 = INT16_MIN;\n\tstatic int64_t x495 = INT64_MIN;\n\tvolatile int32_t x496 = INT32_MIN;\n\tint64_t t114 = -320099786895396LL;\n    t114 = ((x493/(x494^x495))*x496);\n    if (t114 != 0LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "7f94e42d49a624afdd9d5e14854d8df81b5a3616", "ext": "c", "lang": "C", "content": "void u8g2_Setup_max7219_32x8_1(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)\n{\n  uint8_t tile_buf_height;\n  uint8_t *buf;\n  u8g2_SetupDisplay(u8g2, u8x8_d_max7219_32x8, u8x8_cad_empty, byte_cb, gpio_and_delay_cb);\n  buf = u8g2_m_4_1_1(&tile_buf_height);\n  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_horizontal_right_lsb, rotation);\n}", "item_id": 678, "repo": "wuhanstudio/u8g2", "file": "csrc/u8g2_d_setup.c", "last_update_at": "2021-09-17T16:29:21+00:00", "question_id": "7f94e42d49a624afdd9d5e14854d8df81b5a3616_678", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void u8g2_Setup_max7219_32x8_1(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)\n{\n  uint8_t tile_buf_height;\n  uint8_t *buf;\n  u8g2_SetupDisplay(u8g2, u8x8_d_max7219_32x8, u8x8_cad_empty, byte_cb, gpio_and_delay_cb);\n  buf = u8g2_m_4_1_1(&tile_buf_height);\n  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_horizontal_right_lsb, rotation);\n"]]}
{"hexsha": "e3e87daf90170ccb4d9d5284834ca0a95cbe4c81", "ext": "c", "lang": "C", "content": "static int LUBoundsDestroy(void *dcone){\n  int info;\n  LUBounds lucone=(LUBounds)dcone;\n  DSDPFunctionBegin;\n  LUConeValid(lucone);\n  info=DSDPVecDestroy(&lucone->DYD);DSDPCHKERR(info);\n  info=DSDPVecDestroy(&lucone->YD);DSDPCHKERR(info);\n  info=DSDPVecDestroy(&lucone->YP);DSDPCHKERR(info);\n  DSDPFREE(&dcone,&info);DSDPCHKERR(info);\n  DSDPFunctionReturn(0);\n}", "item_id": 1, "repo": "dbdxnuliba/mit-biomimetics_Cheetah", "file": "third-party/casadi/external_packages/DSDP/src/bounds/allbounds.c", "last_update_at": "2021-12-25T05:40:02+00:00", "question_id": "e3e87daf90170ccb4d9d5284834ca0a95cbe4c81_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int LUBoundsDestroy(void *dcone){\n  int info;\n  LUBounds lucone=(LUBounds)dcone;\n  DSDPFunctionBegin;\n  LUConeValid(lucone);\n  info=DSDPVecDestroy(&lucone->DYD);DSDPCHKERR(info);\n  info=DSDPVecDestroy(&lucone->YD);DSDPCHKERR(info);\n  info=DSDPVecDestroy(&lucone->YP);DSDPCHKERR(info);\n  DSDPFREE(&dcone,&info);DSDPCHKERR(info);\n  DSDPFunctionReturn(0);\n"]]}
{"hexsha": "62ec30c92f6f1d904d30fce341741bdba799dbda", "ext": "c", "lang": "C", "content": "void f112(void) {\n    \tint32_t x449 = -47238040;\n\tint32_t x450 = INT32_MIN;\n\tvolatile uint32_t x452 = 116179890U;\n\tvolatile int32_t t112 = -17;\n\n    t112 = ((x449>(x450&x451))==x452);\n\n    if (t112 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 112, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test2276.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "62ec30c92f6f1d904d30fce341741bdba799dbda_112", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f112(void) {\n    \tint32_t x449 = -47238040;\n\tint32_t x450 = INT32_MIN;\n\tvolatile uint32_t x452 = 116179890U;\n\tvolatile int32_t t112 = -17;\n    t112 = ((x449>(x450&x451))==x452);\n    if (t112 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "d8e46f52daed3d797ce1ea3717fe89ea5ce5dae1", "ext": "c", "lang": "C", "content": "void f187(void) {\n    \tint8_t x751 = -1;\n\tvolatile int16_t x752 = INT16_MIN;\n\tuint32_t t187 = 9991063U;\n\n    t187 = (x749&((x750|x751)^x752));\n\n    if (t187 != 32767U) { NG(); } else { ; }\n\t\n}", "item_id": 187, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test2546.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "d8e46f52daed3d797ce1ea3717fe89ea5ce5dae1_187", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f187(void) {\n    \tint8_t x751 = -1;\n\tvolatile int16_t x752 = INT16_MIN;\n\tuint32_t t187 = 9991063U;\n    t187 = (x749&((x750|x751)^x752));\n    if (t187 != 32767U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "a921c39112856d45ce1beae5f631cf20114fe35a", "ext": "h", "lang": "C", "content": "interface BYFlowSkipController : NSObject {\n\n\tBOOL _basicFunctionalityEnabled_doNotAccessDirectly;\n\tFLFollowUpController* _followUpController_doNotAccessDirectly;\n\tid<NSObject> _wfNetworkChangeObserver;\n\n}", "item_id": 0, "repo": "lechium/iPhoneOS_12.1.1_Headers", "file": "System/Library/PrivateFrameworks/SetupAssistant.framework/BYFlowSkipController.h", "last_update_at": "2021-04-13T07:22:20+00:00", "question_id": "a921c39112856d45ce1beae5f631cf20114fe35a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["interface BYFlowSkipController : NSObject {\n\tBOOL _basicFunctionalityEnabled_doNotAccessDirectly;\n\tFLFollowUpController* _followUpController_doNotAccessDirectly;\n\tid<NSObject> _wfNetworkChangeObserver;\n"]]}
{"hexsha": "1015a3c9f55fd05f99b28f5395b858710d6667ec", "ext": "c", "lang": "C", "content": "void FreeSeverResources(void)\n{\n    FreeArguments();\n    FreeLocalConfig();\n    FreeServerContext(g_dhcpServer);\n}", "item_id": 11, "repo": "openharmony-gitee-mirror/communication_wifi", "file": "services/wifi_standard/wifi_framework/dhcp_manage/dhcp_server/src/dhcp_dhcpd.c", "last_update_at": "2021-12-03T14:28:10+00:00", "question_id": "1015a3c9f55fd05f99b28f5395b858710d6667ec_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void FreeSeverResources(void)\n{\n    FreeArguments();\n    FreeLocalConfig();\n    FreeServerContext(g_dhcpServer);\n"]]}
{"hexsha": "a52bc6b258bf5b96cdb67e9dfb3db7fb20f378df", "ext": "h", "lang": "C", "content": "inline DSCC_CRect::DSCC_CRect(\n\t\tDSCC_POINT topLeft,\n\t\tDSCC_POINT bottomRight) throw() {\n\t\tleft = topLeft.x;\n\t\ttop = topLeft.y;\n\t\tright = bottomRight.x;\n\t\tbottom = bottomRight.y;\n\t}", "item_id": 3, "repo": "oaup/imgprocess", "file": "app/src/main/jni/convertMFC.h", "last_update_at": "2021-07-29T01:44:59+00:00", "question_id": "a52bc6b258bf5b96cdb67e9dfb3db7fb20f378df_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["inline DSCC_CRect::DSCC_CRect(\n\t\tDSCC_POINT topLeft,\n\t\tDSCC_POINT bottomRight) throw() {\n\t\tleft = topLeft.x;\n\t\ttop = topLeft.y;\n\t\tright = bottomRight.x;\n\t\tbottom = bottomRight.y;\n"]]}
{"hexsha": "40f88bc2041db88ee4bccc6c7f9ccc2f134a62fb", "ext": "c", "lang": "C", "content": "uint32_t\nvalidate_jwt(\n    PJWT pJWT,\n    PJWT_ERROR *ppError\n    )\n{\n    uint32_t dwError = 0;\n    time_t dwTime = 0;\n    char *pszLWAdminGroup = NULL;\n    PJWT_ERROR pError = NULL;\n\n    if(!pJWT)\n    {\n        dwError = ERROR_PMD_INVALID_PARAMETER;\n        BAIL_ON_PMD_ERROR(dwError);\n    }\n\n    dwError = PMDAllocateMemory(sizeof(JWT_ERROR), (void **)&pError);\n    BAIL_ON_PMD_ERROR(dwError);\n\n//flag to do quick tests with token reuse.\n#ifndef PMD_TIME_INSENSITIVE\n    //validate expiry date\n    dwTime = time(NULL);\n    if(dwTime > pJWT->pClaims->dwExpiry)\n    {\n        pError->nStatus= HTTP_FORBIDDEN;\n        dwError = PMDAllocateStringPrintf(\n                      &pError->pszError,\n                      \"Token expired.\");\n        BAIL_ON_PMD_ERROR(dwError);\n\n        dwError = ERROR_PMD_INVALID_PARAMETER;\n        BAIL_ON_PMD_ERROR(dwError);\n    }\n    //issued at must not be in the future\n    if(dwTime > pJWT->pClaims->dwIssuedAt)\n    {\n        pError->nStatus = HTTP_FORBIDDEN;\n        dwError = PMDAllocateStringPrintf(\n                      &pError->pszError,\n                      \"Token issued at date is in the future.\");\n        BAIL_ON_PMD_ERROR(dwError);\n\n        dwError = ERROR_PMD_INVALID_PARAMETER;\n        BAIL_ON_PMD_ERROR(dwError);\n    }\n#endif\n\n    //this server should be in audience\n    dwError = find_in_array(pJWT->pClaims->pAudienceArray->ppszValues,\n                     pJWT->pClaims->pAudienceArray->nCount,\n                     JAVELIN_OAUTH_AUD);\n    if(dwError == ENOENT)\n    {\n        pError->nStatus = HTTP_FORBIDDEN;\n        dwError = PMDAllocateStringPrintf(\n                      &pError->pszError,\n                      \"Audience does not have expected entries.\");\n        BAIL_ON_PMD_ERROR(dwError);\n\n        dwError = ERROR_PMD_INVALID_PARAMETER;\n    }\n    BAIL_ON_PMD_ERROR(dwError);\n    //must be in administrators group\n    dwError = PMDAllocateStringPrintf(&pszLWAdminGroup,\n                                      \"%s\\\\%s\",\n                                      pJWT->pClaims->pszTenant,\n                                      LW_ADMIN_GROUP_NAME);\n    BAIL_ON_PMD_ERROR(dwError);\n    dwError = find_in_array(pJWT->pClaims->pGroupsArray->ppszValues,\n                     pJWT->pClaims->pGroupsArray->nCount,\n                     pszLWAdminGroup);\n    if(dwError == ENOENT)\n    {\n        pError->nStatus = HTTP_FORBIDDEN;\n        dwError = PMDAllocateStringPrintf(\n                      &pError->pszError,\n                      \"Not an administrators group member.\");\n        BAIL_ON_PMD_ERROR(dwError);\n\n        dwError = ERROR_PMD_INVALID_PARAMETER;\n    }\n    BAIL_ON_PMD_ERROR(dwError);\n\n\ncleanup:\n    free_jwt_error(pError);\n    PMD_SAFE_FREE_MEMORY(pszLWAdminGroup);\n    return dwError;\n\nerror:\n    if(ppError)\n    {\n        *ppError = pError;\n        pError = NULL;\n    }\n    goto cleanup;\n}", "item_id": 9, "repo": "ssahani/pmd", "file": "server/restutils/openidconnect.c", "last_update_at": "2021-12-06T22:56:17+00:00", "question_id": "40f88bc2041db88ee4bccc6c7f9ccc2f134a62fb_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint32_t\nvalidate_jwt(\n    PJWT pJWT,\n    PJWT_ERROR *ppError\n    )\n{\n    uint32_t dwError = 0;\n    time_t dwTime = 0;\n    char *pszLWAdminGroup = NULL;\n    PJWT_ERROR pError = NULL;\n    if(!pJWT)\n    {\n        dwError = ERROR_PMD_INVALID_PARAMETER;\n        BAIL_ON_PMD_ERROR(dwError);\n    }\n    dwError = PMDAllocateMemory(sizeof(JWT_ERROR), (void **)&pError);\n    BAIL_ON_PMD_ERROR(dwError);\n//flag to do quick tests with token reuse.\n#ifndef PMD_TIME_INSENSITIVE\n    //validate expiry date\n    dwTime = time(NULL);\n    if(dwTime > pJWT->pClaims->dwExpiry)\n    {\n        pError->nStatus= HTTP_FORBIDDEN;\n        dwError = PMDAllocateStringPrintf(\n                      &pError->pszError,\n                      \"Token expired.\");\n        BAIL_ON_PMD_ERROR(dwError);\n        dwError = ERROR_PMD_INVALID_PARAMETER;\n        BAIL_ON_PMD_ERROR(dwError);\n    }\n    //issued at must not be in the future\n    if(dwTime > pJWT->pClaims->dwIssuedAt)\n    {\n        pError->nStatus = HTTP_FORBIDDEN;\n        dwError = PMDAllocateStringPrintf(\n                      &pError->pszError,\n                      \"Token issued at date is in the future.\");\n        BAIL_ON_PMD_ERROR(dwError);\n        dwError = ERROR_PMD_INVALID_PARAMETER;\n        BAIL_ON_PMD_ERROR(dwError);\n    }\n#endif\n    //this server should be in audience\n    dwError = find_in_array(pJWT->pClaims->pAudienceArray->ppszValues,\n                     pJWT->pClaims->pAudienceArray->nCount,\n                     JAVELIN_OAUTH_AUD);\n    if(dwError == ENOENT)\n    {\n        pError->nStatus = HTTP_FORBIDDEN;\n        dwError = PMDAllocateStringPrintf(\n                      &pError->pszError,\n                      \"Audience does not have expected entries.\");\n        BAIL_ON_PMD_ERROR(dwError);\n        dwError = ERROR_PMD_INVALID_PARAMETER;\n    }\n    BAIL_ON_PMD_ERROR(dwError);\n    //must be in administrators group\n    dwError = PMDAllocateStringPrintf(&pszLWAdminGroup,\n                                      \"%s\\\\%s\",\n                                      pJWT->pClaims->pszTenant,\n                                      LW_ADMIN_GROUP_NAME);\n    BAIL_ON_PMD_ERROR(dwError);\n    dwError = find_in_array(pJWT->pClaims->pGroupsArray->ppszValues,\n                     pJWT->pClaims->pGroupsArray->nCount,\n                     pszLWAdminGroup);\n    if(dwError == ENOENT)\n    {\n        pError->nStatus = HTTP_FORBIDDEN;\n        dwError = PMDAllocateStringPrintf(\n                      &pError->pszError,\n                      \"Not an administrators group member.\");\n        BAIL_ON_PMD_ERROR(dwError);\n        dwError = ERROR_PMD_INVALID_PARAMETER;\n    }\n    BAIL_ON_PMD_ERROR(dwError);\ncleanup:\n    free_jwt_error(pError);\n    PMD_SAFE_FREE_MEMORY(pszLWAdminGroup);\n    return dwError;\nerror:\n    if(ppError)\n    {\n        *ppError = pError;\n        pError = NULL;\n    }\n    goto cleanup;\n"]]}
{"hexsha": "e1fca168d0dcdc24260aa83608473b16aabcc58e", "ext": "c", "lang": "C", "content": "void f128(void) {\n    \tstatic int32_t x513 = -1004604;\n\tuint32_t x515 = UINT32_MAX;\n\tuint64_t x516 = 16178658281212569LLU;\n\tvolatile uint64_t t128 = 121078591799929LLU;\n\n    t128 = (x513|((x514<=x515)*x516));\n\n    if (t128 != 18446744073709284317LLU) { NG(); } else { ; }\n\t\n}", "item_id": 128, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test1805.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "e1fca168d0dcdc24260aa83608473b16aabcc58e_128", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f128(void) {\n    \tstatic int32_t x513 = -1004604;\n\tuint32_t x515 = UINT32_MAX;\n\tuint64_t x516 = 16178658281212569LLU;\n\tvolatile uint64_t t128 = 121078591799929LLU;\n    t128 = (x513|((x514<=x515)*x516));\n    if (t128 != 18446744073709284317LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "75243bab0778efbcb246da2cb7727137ecbcfe48", "ext": "c", "lang": "C", "content": "static int __init rtl83xx_sw_probe(struct platform_device *pdev)\n{\n\tint err = 0, i;\n\tstruct rtl838x_switch_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tu64 bpdu_mask;\n\n\tpr_debug(\"Probing RTL838X switch device\\n\");\n\tif (!pdev->dev.of_node) {\n\t\tdev_err(dev, \"No DT found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t// Initialize access to RTL switch tables\n\trtl_table_init();\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->ds = devm_kzalloc(dev, sizeof(*priv->ds), GFP_KERNEL);\n\n\tif (!priv->ds)\n\t\treturn -ENOMEM;\n\tpriv->ds->dev = dev;\n\tpriv->ds->priv = priv;\n\tpriv->ds->ops = &rtl83xx_switch_ops;\n\tpriv->dev = dev;\n\n\tmutex_init(&priv->reg_mutex);\n\n\tpriv->family_id = soc_info.family;\n\tpriv->id = soc_info.id;\n\tswitch(soc_info.family) {\n\tcase RTL8380_FAMILY_ID:\n\t\tpriv->ds->ops = &rtl83xx_switch_ops;\n\t\tpriv->cpu_port = RTL838X_CPU_PORT;\n\t\tpriv->port_mask = 0x1f;\n\t\tpriv->port_width = 1;\n\t\tpriv->irq_mask = 0x0FFFFFFF;\n\t\tpriv->r = &rtl838x_reg;\n\t\tpriv->ds->num_ports = 29;\n\t\tpriv->fib_entries = 8192;\n\t\trtl8380_get_version(priv);\n\t\tpriv->n_lags = 8;\n\t\tpriv->l2_bucket_size = 4;\n\t\tpriv->n_pie_blocks = 12;\n\t\tpriv->port_ignore = 0x1f;\n\t\tpriv->n_counters = 128;\n\t\tbreak;\n\tcase RTL8390_FAMILY_ID:\n\t\tpriv->ds->ops = &rtl83xx_switch_ops;\n\t\tpriv->cpu_port = RTL839X_CPU_PORT;\n\t\tpriv->port_mask = 0x3f;\n\t\tpriv->port_width = 2;\n\t\tpriv->irq_mask = 0xFFFFFFFFFFFFFULL;\n\t\tpriv->r = &rtl839x_reg;\n\t\tpriv->ds->num_ports = 53;\n\t\tpriv->fib_entries = 16384;\n\t\trtl8390_get_version(priv);\n\t\tpriv->n_lags = 16;\n\t\tpriv->l2_bucket_size = 4;\n\t\tpriv->n_pie_blocks = 18;\n\t\tpriv->port_ignore = 0x3f;\n\t\tpriv->n_counters = 1024;\n\t\tbreak;\n\tcase RTL9300_FAMILY_ID:\n\t\tpriv->ds->ops = &rtl930x_switch_ops;\n\t\tpriv->cpu_port = RTL930X_CPU_PORT;\n\t\tpriv->port_mask = 0x1f;\n\t\tpriv->port_width = 1;\n\t\tpriv->irq_mask = 0x0FFFFFFF;\n\t\tpriv->r = &rtl930x_reg;\n\t\tpriv->ds->num_ports = 29;\n\t\tpriv->fib_entries = 16384;\n\t\tpriv->version = RTL8390_VERSION_A;\n\t\tpriv->n_lags = 16;\n\t\tsw_w32(1, RTL930X_ST_CTRL);\n\t\tpriv->l2_bucket_size = 8;\n\t\tpriv->n_pie_blocks = 16;\n\t\tpriv->port_ignore = 0x3f;\n\t\tpriv->n_counters = 2048;\n\t\tbreak;\n\tcase RTL9310_FAMILY_ID:\n\t\tpriv->ds->ops = &rtl930x_switch_ops;\n\t\tpriv->cpu_port = RTL931X_CPU_PORT;\n\t\tpriv->port_mask = 0x3f;\n\t\tpriv->port_width = 2;\n\t\tpriv->irq_mask = 0xFFFFFFFFFFFFFULL;\n\t\tpriv->r = &rtl931x_reg;\n\t\tpriv->ds->num_ports = 57;\n\t\tpriv->fib_entries = 16384;\n\t\tpriv->version = RTL8390_VERSION_A;\n\t\tpriv->n_lags = 16;\n\t\tpriv->l2_bucket_size = 8;\n\t\tbreak;\n\t}\n\tpr_debug(\"Chip version %c\\n\", priv->version);\n\n\terr = rtl83xx_mdio_probe(priv);\n\tif (err) {\n\t\t/* Probing fails the 1st time because of missing ethernet driver\n\t\t * initialization. Use this to disable traffic in case the bootloader left if on\n\t\t */\n\t\treturn err;\n\t}\n\terr = dsa_register_switch(priv->ds);\n\tif (err) {\n\t\tdev_err(dev, \"Error registering switch: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t/*\n\t * dsa_to_port returns dsa_port from the port list in\n\t * dsa_switch_tree, the tree is built when the switch\n\t * is registered by dsa_register_switch\n\t */\n\tfor (i = 0; i <= priv->cpu_port; i++)\n\t\tpriv->ports[i].dp = dsa_to_port(priv->ds, i);\n\n\t/* Enable link and media change interrupts. Are the SERDES masks needed? */\n\tsw_w32_mask(0, 3, priv->r->isr_glb_src);\n\n\tpriv->r->set_port_reg_le(priv->irq_mask, priv->r->isr_port_link_sts_chg);\n\tpriv->r->set_port_reg_le(priv->irq_mask, priv->r->imr_port_link_sts_chg);\n\n\tpriv->link_state_irq = platform_get_irq(pdev, 0);\n\tpr_info(\"LINK state irq: %d\\n\", priv->link_state_irq);\n\tswitch (priv->family_id) {\n\tcase RTL8380_FAMILY_ID:\n\t\terr = request_irq(priv->link_state_irq, rtl838x_switch_irq,\n\t\t\t\tIRQF_SHARED, \"rtl838x-link-state\", priv->ds);\n\t\tbreak;\n\tcase RTL8390_FAMILY_ID:\n\t\terr = request_irq(priv->link_state_irq, rtl839x_switch_irq,\n\t\t\t\tIRQF_SHARED, \"rtl839x-link-state\", priv->ds);\n\t\tbreak;\n\tcase RTL9300_FAMILY_ID:\n\t\terr = request_irq(priv->link_state_irq, rtl930x_switch_irq,\n\t\t\t\tIRQF_SHARED, \"rtl930x-link-state\", priv->ds);\n\t\tbreak;\n\tcase RTL9310_FAMILY_ID:\n\t\terr = request_irq(priv->link_state_irq, rtl931x_switch_irq,\n\t\t\t\tIRQF_SHARED, \"rtl931x-link-state\", priv->ds);\n\t\tbreak;\n\t}\n\tif (err) {\n\t\tdev_err(dev, \"Error setting up switch interrupt.\\n\");\n\t\t/* Need to free allocated switch here */\n\t}\n\n\t/* Enable interrupts for switch, on RTL931x, the IRQ is always on globally */\n\tif (soc_info.family != RTL9310_FAMILY_ID)\n\t\tsw_w32(0x1, priv->r->imr_glb);\n\n\trtl83xx_get_l2aging(priv);\n\n\trtl83xx_setup_qos(priv);\n\n\tpriv->r->l3_setup(priv);\n\n\t/* Clear all destination ports for mirror groups */\n\tfor (i = 0; i < 4; i++)\n\t\tpriv->mirror_group_ports[i] = -1;\n\n\t/*\n\t * Register netdevice event callback to catch changes in link aggregation groups\n\t */\n\tpriv->nb.notifier_call = rtl83xx_netdevice_event;\n\tif (register_netdevice_notifier(&priv->nb)) {\n\t\tpriv->nb.notifier_call = NULL;\n\t\tdev_err(dev, \"Failed to register LAG netdev notifier\\n\");\n\t\tgoto err_register_nb;\n\t}\n\n\t// Initialize hash table for L3 routing\n\trhltable_init(&priv->routes, &route_ht_params);\n\n\t/*\n\t * Register netevent notifier callback to catch notifications about neighboring\n\t * changes to update nexthop entries for L3 routing.\n\t */\n\tpriv->ne_nb.notifier_call = rtl83xx_netevent_event;\n\tif (register_netevent_notifier(&priv->ne_nb)) {\n\t\tpriv->ne_nb.notifier_call = NULL;\n\t\tdev_err(dev, \"Failed to register netevent notifier\\n\");\n\t\tgoto err_register_ne_nb;\n\t}\n\n\tpriv->fib_nb.notifier_call = rtl83xx_fib_event;\n\n\t/*\n\t * Register Forwarding Information Base notifier to offload routes where\n\t * where possible\n\t * Only FIBs pointing to our own netdevs are programmed into\n\t * the device, so no need to pass a callback.\n\t */\n\terr = register_fib_notifier(&init_net, &priv->fib_nb, NULL, NULL);\n\tif (err)\n\t\tgoto err_register_fib_nb;\n\n\t// TODO: put this into l2_setup()\n\t// Flood BPDUs to all ports including cpu-port\n\tif (soc_info.family != RTL9300_FAMILY_ID) {\n\t\tbpdu_mask = soc_info.family == RTL8380_FAMILY_ID ? 0x1FFFFFFF : 0x1FFFFFFFFFFFFF;\n\t\tpriv->r->set_port_reg_be(bpdu_mask, priv->r->rma_bpdu_fld_pmask);\n\n\t\t// TRAP 802.1X frames (EAPOL) to the CPU-Port, bypass STP and VLANs\n\t\tsw_w32(7, priv->r->spcl_trap_eapol_ctrl);\n\n\t\trtl838x_dbgfs_init(priv);\n\t} else {\n\t\trtl930x_dbgfs_init(priv);\n\t}\n\n\treturn 0;\n\nerr_register_fib_nb:\n\tunregister_netevent_notifier(&priv->ne_nb);\nerr_register_ne_nb:\n\tunregister_netdevice_notifier(&priv->nb);\nerr_register_nb:\n\treturn err;\n}", "item_id": 34, "repo": "andrewlsa/OpenWrt", "file": "target/linux/realtek/files-5.10/drivers/net/dsa/rtl83xx/common.c", "last_update_at": "2021-11-20T13:44:32+00:00", "question_id": "75243bab0778efbcb246da2cb7727137ecbcfe48_34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int __init rtl83xx_sw_probe(struct platform_device *pdev)\n{\n\tint err = 0, i;\n\tstruct rtl838x_switch_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tu64 bpdu_mask;\n\tpr_debug(\"Probing RTL838X switch device\\n\");\n\tif (!pdev->dev.of_node) {\n\t\tdev_err(dev, \"No DT found\\n\");\n\t\treturn -EINVAL;\n\t}\n\t// Initialize access to RTL switch tables\n\trtl_table_init();\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->ds = devm_kzalloc(dev, sizeof(*priv->ds), GFP_KERNEL);\n\tif (!priv->ds)\n\t\treturn -ENOMEM;\n\tpriv->ds->dev = dev;\n\tpriv->ds->priv = priv;\n\tpriv->ds->ops = &rtl83xx_switch_ops;\n\tpriv->dev = dev;\n\tmutex_init(&priv->reg_mutex);\n\tpriv->family_id = soc_info.family;\n\tpriv->id = soc_info.id;\n\tswitch(soc_info.family) {\n\tcase RTL8380_FAMILY_ID:\n\t\tpriv->ds->ops = &rtl83xx_switch_ops;\n\t\tpriv->cpu_port = RTL838X_CPU_PORT;\n\t\tpriv->port_mask = 0x1f;\n\t\tpriv->port_width = 1;\n\t\tpriv->irq_mask = 0x0FFFFFFF;\n\t\tpriv->r = &rtl838x_reg;\n\t\tpriv->ds->num_ports = 29;\n\t\tpriv->fib_entries = 8192;\n\t\trtl8380_get_version(priv);\n\t\tpriv->n_lags = 8;\n\t\tpriv->l2_bucket_size = 4;\n\t\tpriv->n_pie_blocks = 12;\n\t\tpriv->port_ignore = 0x1f;\n\t\tpriv->n_counters = 128;\n\t\tbreak;\n\tcase RTL8390_FAMILY_ID:\n\t\tpriv->ds->ops = &rtl83xx_switch_ops;\n\t\tpriv->cpu_port = RTL839X_CPU_PORT;\n\t\tpriv->port_mask = 0x3f;\n\t\tpriv->port_width = 2;\n\t\tpriv->irq_mask = 0xFFFFFFFFFFFFFULL;\n\t\tpriv->r = &rtl839x_reg;\n\t\tpriv->ds->num_ports = 53;\n\t\tpriv->fib_entries = 16384;\n\t\trtl8390_get_version(priv);\n\t\tpriv->n_lags = 16;\n\t\tpriv->l2_bucket_size = 4;\n\t\tpriv->n_pie_blocks = 18;\n\t\tpriv->port_ignore = 0x3f;\n\t\tpriv->n_counters = 1024;\n\t\tbreak;\n\tcase RTL9300_FAMILY_ID:\n\t\tpriv->ds->ops = &rtl930x_switch_ops;\n\t\tpriv->cpu_port = RTL930X_CPU_PORT;\n\t\tpriv->port_mask = 0x1f;\n\t\tpriv->port_width = 1;\n\t\tpriv->irq_mask = 0x0FFFFFFF;\n\t\tpriv->r = &rtl930x_reg;\n\t\tpriv->ds->num_ports = 29;\n\t\tpriv->fib_entries = 16384;\n\t\tpriv->version = RTL8390_VERSION_A;\n\t\tpriv->n_lags = 16;\n\t\tsw_w32(1, RTL930X_ST_CTRL);\n\t\tpriv->l2_bucket_size = 8;\n\t\tpriv->n_pie_blocks = 16;\n\t\tpriv->port_ignore = 0x3f;\n\t\tpriv->n_counters = 2048;\n\t\tbreak;\n\tcase RTL9310_FAMILY_ID:\n\t\tpriv->ds->ops = &rtl930x_switch_ops;\n\t\tpriv->cpu_port = RTL931X_CPU_PORT;\n\t\tpriv->port_mask = 0x3f;\n\t\tpriv->port_width = 2;\n\t\tpriv->irq_mask = 0xFFFFFFFFFFFFFULL;\n\t\tpriv->r = &rtl931x_reg;\n\t\tpriv->ds->num_ports = 57;\n\t\tpriv->fib_entries = 16384;\n\t\tpriv->version = RTL8390_VERSION_A;\n\t\tpriv->n_lags = 16;\n\t\tpriv->l2_bucket_size = 8;\n\t\tbreak;\n\t}\n\tpr_debug(\"Chip version %c\\n\", priv->version);\n\terr = rtl83xx_mdio_probe(priv);\n\tif (err) {\n\t\t/* Probing fails the 1st time because of missing ethernet driver\n\t\t * initialization. Use this to disable traffic in case the bootloader left if on\n\t\t */\n\t\treturn err;\n\t}\n\terr = dsa_register_switch(priv->ds);\n\tif (err) {\n\t\tdev_err(dev, \"Error registering switch: %d\\n\", err);\n\t\treturn err;\n\t}\n\t/*\n\t * dsa_to_port returns dsa_port from the port list in\n\t * dsa_switch_tree, the tree is built when the switch\n\t * is registered by dsa_register_switch\n\t */\n\tfor (i = 0; i <= priv->cpu_port; i++)\n\t\tpriv->ports[i].dp = dsa_to_port(priv->ds, i);\n\t/* Enable link and media change interrupts. Are the SERDES masks needed? */\n\tsw_w32_mask(0, 3, priv->r->isr_glb_src);\n\tpriv->r->set_port_reg_le(priv->irq_mask, priv->r->isr_port_link_sts_chg);\n\tpriv->r->set_port_reg_le(priv->irq_mask, priv->r->imr_port_link_sts_chg);\n\tpriv->link_state_irq = platform_get_irq(pdev, 0);\n\tpr_info(\"LINK state irq: %d\\n\", priv->link_state_irq);\n\tswitch (priv->family_id) {\n\tcase RTL8380_FAMILY_ID:\n\t\terr = request_irq(priv->link_state_irq, rtl838x_switch_irq,\n\t\t\t\tIRQF_SHARED, \"rtl838x-link-state\", priv->ds);\n\t\tbreak;\n\tcase RTL8390_FAMILY_ID:\n\t\terr = request_irq(priv->link_state_irq, rtl839x_switch_irq,\n\t\t\t\tIRQF_SHARED, \"rtl839x-link-state\", priv->ds);\n\t\tbreak;\n\tcase RTL9300_FAMILY_ID:\n\t\terr = request_irq(priv->link_state_irq, rtl930x_switch_irq,\n\t\t\t\tIRQF_SHARED, \"rtl930x-link-state\", priv->ds);\n\t\tbreak;\n\tcase RTL9310_FAMILY_ID:\n\t\terr = request_irq(priv->link_state_irq, rtl931x_switch_irq,\n\t\t\t\tIRQF_SHARED, \"rtl931x-link-state\", priv->ds);\n\t\tbreak;\n\t}\n\tif (err) {\n\t\tdev_err(dev, \"Error setting up switch interrupt.\\n\");\n\t\t/* Need to free allocated switch here */\n\t}\n\t/* Enable interrupts for switch, on RTL931x, the IRQ is always on globally */\n\tif (soc_info.family != RTL9310_FAMILY_ID)\n\t\tsw_w32(0x1, priv->r->imr_glb);\n\trtl83xx_get_l2aging(priv);\n\trtl83xx_setup_qos(priv);\n\tpriv->r->l3_setup(priv);\n\t/* Clear all destination ports for mirror groups */\n\tfor (i = 0; i < 4; i++)\n\t\tpriv->mirror_group_ports[i] = -1;\n\t/*\n\t * Register netdevice event callback to catch changes in link aggregation groups\n\t */\n\tpriv->nb.notifier_call = rtl83xx_netdevice_event;\n\tif (register_netdevice_notifier(&priv->nb)) {\n\t\tpriv->nb.notifier_call = NULL;\n\t\tdev_err(dev, \"Failed to register LAG netdev notifier\\n\");\n\t\tgoto err_register_nb;\n\t}\n\t// Initialize hash table for L3 routing\n\trhltable_init(&priv->routes, &route_ht_params);\n\t/*\n\t * Register netevent notifier callback to catch notifications about neighboring\n\t * changes to update nexthop entries for L3 routing.\n\t */\n\tpriv->ne_nb.notifier_call = rtl83xx_netevent_event;\n\tif (register_netevent_notifier(&priv->ne_nb)) {\n\t\tpriv->ne_nb.notifier_call = NULL;\n\t\tdev_err(dev, \"Failed to register netevent notifier\\n\");\n\t\tgoto err_register_ne_nb;\n\t}\n\tpriv->fib_nb.notifier_call = rtl83xx_fib_event;\n\t/*\n\t * Register Forwarding Information Base notifier to offload routes where\n\t * where possible\n\t * Only FIBs pointing to our own netdevs are programmed into\n\t * the device, so no need to pass a callback.\n\t */\n\terr = register_fib_notifier(&init_net, &priv->fib_nb, NULL, NULL);\n\tif (err)\n\t\tgoto err_register_fib_nb;\n\t// TODO: put this into l2_setup()\n\t// Flood BPDUs to all ports including cpu-port\n\tif (soc_info.family != RTL9300_FAMILY_ID) {\n\t\tbpdu_mask = soc_info.family == RTL8380_FAMILY_ID ? 0x1FFFFFFF : 0x1FFFFFFFFFFFFF;\n\t\tpriv->r->set_port_reg_be(bpdu_mask, priv->r->rma_bpdu_fld_pmask);\n\t\t// TRAP 802.1X frames (EAPOL) to the CPU-Port, bypass STP and VLANs\n\t\tsw_w32(7, priv->r->spcl_trap_eapol_ctrl);\n\t\trtl838x_dbgfs_init(priv);\n\t} else {\n\t\trtl930x_dbgfs_init(priv);\n\t}\n\treturn 0;\nerr_register_fib_nb:\n\tunregister_netevent_notifier(&priv->ne_nb);\nerr_register_ne_nb:\n\tunregister_netdevice_notifier(&priv->nb);\nerr_register_nb:\n\treturn err;\n"]]}
{"hexsha": "c474992d1e3ffb771d77bd73dceca31452a7a42c", "ext": "c", "lang": "C", "content": "void f123(void) {\n    \tstatic volatile uint64_t x721 = UINT64_MAX;\n\tint8_t x722 = -17;\n\tuint8_t x723 = 6U;\n\tuint8_t x724 = 1U;\n\tvolatile uint64_t t123 = 1028967006146LLU;\n\n    t123 = ((x721-x722)%(x723*x724));\n\n    if (t123 != 4LLU) { NG(); } else { ; }\n\t\n}", "item_id": 123, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test411.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "c474992d1e3ffb771d77bd73dceca31452a7a42c_123", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f123(void) {\n    \tstatic volatile uint64_t x721 = UINT64_MAX;\n\tint8_t x722 = -17;\n\tuint8_t x723 = 6U;\n\tuint8_t x724 = 1U;\n\tvolatile uint64_t t123 = 1028967006146LLU;\n    t123 = ((x721-x722)%(x723*x724));\n    if (t123 != 4LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "cbcc06a55ae0651917694020a14fe6daeee8e92f", "ext": "h", "lang": "C", "content": "class SettingsForm : public QWidget\n{\n    Q_OBJECT\n\npublic:\n    explicit SettingsForm(QWidget *parent = 0);\n    ~SettingsForm();\n\n    void setText(QString &text);\n\nprivate:\n    Ui::SettingsForm *ui;\n}", "item_id": 0, "repo": "Tsukihime/Easy-Text-Hooker", "file": "CPPPlugin/LoremIpsum/settingsform.h", "last_update_at": "2021-06-22T04:04:25+00:00", "question_id": "cbcc06a55ae0651917694020a14fe6daeee8e92f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class SettingsForm : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit SettingsForm(QWidget *parent = 0);\n    ~SettingsForm();\n    void setText(QString &text);\nprivate:\n    Ui::SettingsForm *ui;\n"]]}
{"hexsha": "55cb8d41d2797300c1561d13916513fa734f5b5a", "ext": "c", "lang": "C", "content": "void f176(void) {\n    \tvolatile int64_t x705 = INT64_MAX;\n\tint8_t x706 = INT8_MAX;\n\tstatic uint32_t x707 = 427U;\n\tstatic uint64_t x708 = 7271LLU;\n\tstatic int32_t t176 = 152521;\n\n    t176 = ((x705<=x706)>>(x707==x708));\n\n    if (t176 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 176, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1509.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "55cb8d41d2797300c1561d13916513fa734f5b5a_176", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f176(void) {\n    \tvolatile int64_t x705 = INT64_MAX;\n\tint8_t x706 = INT8_MAX;\n\tstatic uint32_t x707 = 427U;\n\tstatic uint64_t x708 = 7271LLU;\n\tstatic int32_t t176 = 152521;\n    t176 = ((x705<=x706)>>(x707==x708));\n    if (t176 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "cd46a2f923125ee6c10d43af617b392edafd7962", "ext": "c", "lang": "C", "content": "static PyObject *__Pyx_GetBuiltinName(PyObject *name) {\n    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);\n    if (unlikely(!result)) {\n        PyErr_Format(PyExc_NameError,\n#if PY_MAJOR_VERSION >= 3\n            \"name '%U' is not defined\", name);\n#else\n            \"name '%.200s' is not defined\", PyString_AS_STRING(name));\n#endif\n    }\n    return result;\n}", "item_id": 31, "repo": "ETRobocon2017-TeamD/balanc3r-for-ev3way", "file": "src/runner.c", "last_update_at": "2021-02-19T09:51:20+00:00", "question_id": "cd46a2f923125ee6c10d43af617b392edafd7962_31", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static PyObject *__Pyx_GetBuiltinName(PyObject *name) {\n    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);\n    if (unlikely(!result)) {\n        PyErr_Format(PyExc_NameError,\n#if PY_MAJOR_VERSION >= 3\n            \"name '%U' is not defined\", name);\n#else\n            \"name '%.200s' is not defined\", PyString_AS_STRING(name));\n#endif\n    }\n    return result;\n"]]}
{"hexsha": "cd5e5c292d6efeb17abfcc6d774970b8926e668a", "ext": "c", "lang": "C", "content": "void f186(void) {\n    \tint8_t x6377 = -2;\n\tuint8_t x6379 = 48U;\n\tint8_t x6380 = 1;\n\tint32_t t186 = 410131170;\n\n    t186 = (x6377<=((x6378&x6379)>>x6380));\n\n    if (t186 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 185, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test2306.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "cd5e5c292d6efeb17abfcc6d774970b8926e668a_185", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f186(void) {\n    \tint8_t x6377 = -2;\n\tuint8_t x6379 = 48U;\n\tint8_t x6380 = 1;\n\tint32_t t186 = 410131170;\n    t186 = (x6377<=((x6378&x6379)>>x6380));\n    if (t186 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "f0cae0a08c85ed87f0e16bb3baa8b2467705e5b2", "ext": "c", "lang": "C", "content": "bool dsController_startRumble(dsController* controller, float strength, float duration)\n{\n\tif (!controller || !controller->rumbleSupported || !controller->application ||\n\t\t!controller->application->startControllerRumbleFunc)\n\t{\n\t\terrno = EINVAL;\n\t\treturn false;\n\t}\n\n\tdsApplication* application = controller->application;\n\treturn application->startControllerRumbleFunc(application, controller, strength, duration);\n}", "item_id": 3, "repo": "akb825/DeepSea", "file": "modules/Application/Application/src/Controller.c", "last_update_at": "2021-09-30T13:37:04+00:00", "question_id": "f0cae0a08c85ed87f0e16bb3baa8b2467705e5b2_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool dsController_startRumble(dsController* controller, float strength, float duration)\n{\n\tif (!controller || !controller->rumbleSupported || !controller->application ||\n\t\t!controller->application->startControllerRumbleFunc)\n\t{\n\t\terrno = EINVAL;\n\t\treturn false;\n\t}\n\tdsApplication* application = controller->application;\n\treturn application->startControllerRumbleFunc(application, controller, strength, duration);\n"]]}
{"hexsha": "2b9b790d125b11425e3f1a4c440ad318c8b3f60f", "ext": "c", "lang": "C", "content": "void f130(void) {\n    \tuint8_t x685 = UINT8_MAX;\n\tuint16_t x686 = UINT16_MAX;\n\tvolatile int16_t x687 = -1;\n\tint16_t x688 = INT16_MAX;\n\tvolatile int32_t t130 = 408392;\n\n    t130 = (x685-(x686/(x687&x688)));\n\n    if (t130 != 253) { NG(); } else { ; }\n\t\n}", "item_id": 130, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test2200.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "2b9b790d125b11425e3f1a4c440ad318c8b3f60f_130", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f130(void) {\n    \tuint8_t x685 = UINT8_MAX;\n\tuint16_t x686 = UINT16_MAX;\n\tvolatile int16_t x687 = -1;\n\tint16_t x688 = INT16_MAX;\n\tvolatile int32_t t130 = 408392;\n    t130 = (x685-(x686/(x687&x688)));\n    if (t130 != 253) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "1579c76f9da9718851b50c74265cba46855a50a1", "ext": "c", "lang": "C", "content": "void f37(void) {\n    \tuint16_t x161 = 10896U;\n\tstatic volatile int16_t x162 = INT16_MAX;\n\tvolatile int64_t x163 = INT64_MIN;\n\tuint64_t x164 = UINT64_MAX;\n\tuint64_t t37 = 13LLU;\n\n    t37 = (x161/(x162+(x163|x164)));\n\n    if (t37 != 0LLU) { NG(); } else { ; }\n\t\n}", "item_id": 37, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test2356.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "1579c76f9da9718851b50c74265cba46855a50a1_37", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f37(void) {\n    \tuint16_t x161 = 10896U;\n\tstatic volatile int16_t x162 = INT16_MAX;\n\tvolatile int64_t x163 = INT64_MIN;\n\tuint64_t x164 = UINT64_MAX;\n\tuint64_t t37 = 13LLU;\n    t37 = (x161/(x162+(x163|x164)));\n    if (t37 != 0LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "8ae5bfef6ce9d4f3765a9df958d4f94e40e91c88", "ext": "c", "lang": "C", "content": "void f80(void) {\n    \tuint8_t x429 = 11U;\n\tint16_t x430 = 6;\n\tvolatile int32_t t80 = 41;\n\n    t80 = ((x429*x430)!=(x431%x432));\n\n    if (t80 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 80, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test819.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "8ae5bfef6ce9d4f3765a9df958d4f94e40e91c88_80", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f80(void) {\n    \tuint8_t x429 = 11U;\n\tint16_t x430 = 6;\n\tvolatile int32_t t80 = 41;\n    t80 = ((x429*x430)!=(x431%x432));\n    if (t80 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "cdca576401bf81fa2f1fdea0f5edc7685d3952fc", "ext": "c", "lang": "C", "content": "int func_391(int iParam0)\r\n{\r\n\tint iVar0;\r\n\t\r\n\tif (PED::IS_PED_IN_ANY_VEHICLE(iParam0, true))\r\n\t{\r\n\t\treturn 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tiVar0 = TASK::GET_SCRIPT_TASK_STATUS(iParam0, -1794415470);\r\n\t\tif (iVar0 == 0)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}", "item_id": 168, "repo": "SkOODaT/GTA-V-Decompiled-Scripts", "file": "decompiled_scripts/appimportexport.c", "last_update_at": "2021-12-06T08:15:51+00:00", "question_id": "cdca576401bf81fa2f1fdea0f5edc7685d3952fc_168", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int func_391(int iParam0)\r\n{\r\n\tint iVar0;\r\n\t\r\n\tif (PED::IS_PED_IN_ANY_VEHICLE(iParam0, true))\r\n\t{\r\n\t\treturn 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tiVar0 = TASK::GET_SCRIPT_TASK_STATUS(iParam0, -1794415470);\r\n\t\tif (iVar0 == 0)\r\n\t\t{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n"]]}
{"hexsha": "87f600a67be5b04a85d5833828315bcc8f980033", "ext": "c", "lang": "C", "content": "void f197(void) {\n    \tint8_t x878 = -50;\n\tint64_t x879 = -1LL;\n\tuint64_t x880 = UINT64_MAX;\n\tuint64_t t197 = 18364001LLU;\n\n    t197 = (x877|((x878/x879)-x880));\n\n    if (t197 != 51LLU) { NG(); } else { ; }\n\t\n}", "item_id": 197, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test615.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "87f600a67be5b04a85d5833828315bcc8f980033_197", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f197(void) {\n    \tint8_t x878 = -50;\n\tint64_t x879 = -1LL;\n\tuint64_t x880 = UINT64_MAX;\n\tuint64_t t197 = 18364001LLU;\n    t197 = (x877|((x878/x879)-x880));\n    if (t197 != 51LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "1d7365dda71cafe8618a336c2ef8d9501b54be5c", "ext": "c", "lang": "C", "content": "void f156(void) {\n    \tint16_t x905 = INT16_MAX;\n\tstatic volatile int64_t x906 = INT64_MIN;\n\tuint64_t x907 = 4LLU;\n\tint16_t x908 = -1;\n\tvolatile uint64_t t156 = 29206710776471LLU;\n\n    t156 = (x905&((x906*x907)-x908));\n\n    if (t156 != 1LLU) { NG(); } else { ; }\n\t\n}", "item_id": 156, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test418.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "1d7365dda71cafe8618a336c2ef8d9501b54be5c_156", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f156(void) {\n    \tint16_t x905 = INT16_MAX;\n\tstatic volatile int64_t x906 = INT64_MIN;\n\tuint64_t x907 = 4LLU;\n\tint16_t x908 = -1;\n\tvolatile uint64_t t156 = 29206710776471LLU;\n    t156 = (x905&((x906*x907)-x908));\n    if (t156 != 1LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "0cb7e05c5c5aae3161e867582e8a4f227e5eb050", "ext": "c", "lang": "C", "content": "static int JSPROMISE_CREATE(\n    __dbExecAsync,\n    env,\n    data\n) {\n// This function will run <bufin[1]> in <db> and save any result\n// (list of tables containing rows from SELECT/pragma/etc) as serialized\n// json-string in <pResult>.\n/* *INDENT-OFF* */\nSQLMATH_API int dbExec(sqlite3 *, Jsbaton *);\n/* *INDENT-ON* */\n    // init baton\n    Jsbaton *baton = (Jsbaton *) data;\n    // declare var\n    int errcode = 0;\n    sqlite3 *db = (sqlite3 *) (intptr_t) baton->argint64[0];\n    // call c-function\n    errcode = dbExec(db, baton);\n    ASSERT_SQLITE_OK(baton, db, errcode);\n  catch_error:\n    return 0;\n}", "item_id": 33, "repo": "sqlmljs/sqlmljs", "file": "sqlmath_base.c", "last_update_at": "2021-08-25T13:59:23+00:00", "question_id": "0cb7e05c5c5aae3161e867582e8a4f227e5eb050_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int JSPROMISE_CREATE(\n    __dbExecAsync,\n    env,\n    data\n) {\n// This function will run <bufin[1]> in <db> and save any result\n// (list of tables containing rows from SELECT/pragma/etc) as serialized\n// json-string in <pResult>.\n/* *INDENT-OFF* */\nSQLMATH_API int dbExec(sqlite3 *, Jsbaton *);\n/* *INDENT-ON* */\n    // init baton\n    Jsbaton *baton = (Jsbaton *) data;\n    // declare var\n    int errcode = 0;\n    sqlite3 *db = (sqlite3 *) (intptr_t) baton->argint64[0];\n    // call c-function\n    errcode = dbExec(db, baton);\n    ASSERT_SQLITE_OK(baton, db, errcode);\n  catch_error:\n    return 0;\n"]]}
{"hexsha": "9740c80324cc0922e837eedbde165d8412b22328", "ext": "c", "lang": "C", "content": "void f108(void) {\n    \tint8_t x469 = -1;\n\tuint8_t x470 = 109U;\n\tint8_t x471 = INT8_MAX;\n\tuint32_t x472 = UINT32_MAX;\n\tuint32_t t108 = 313407U;\n\n    t108 = (((x469==x470)+x471)-x472);\n\n    if (t108 != 128U) { NG(); } else { ; }\n\t\n}", "item_id": 107, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test1374.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "9740c80324cc0922e837eedbde165d8412b22328_107", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f108(void) {\n    \tint8_t x469 = -1;\n\tuint8_t x470 = 109U;\n\tint8_t x471 = INT8_MAX;\n\tuint32_t x472 = UINT32_MAX;\n\tuint32_t t108 = 313407U;\n    t108 = (((x469==x470)+x471)-x472);\n    if (t108 != 128U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "e4a4ac8131e6933c65f36678aa30d2c45e03f41d", "ext": "c", "lang": "C", "content": "void f188(void) {\n    \tuint64_t x3954 = UINT64_MAX;\n\tstatic volatile int32_t t188 = -134670370;\n\n    t188 = (x3953<=(x3954<<(x3955%x3956)));\n\n    if (t188 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 188, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test864.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "e4a4ac8131e6933c65f36678aa30d2c45e03f41d_188", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f188(void) {\n    \tuint64_t x3954 = UINT64_MAX;\n\tstatic volatile int32_t t188 = -134670370;\n    t188 = (x3953<=(x3954<<(x3955%x3956)));\n    if (t188 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "654b30b483b87d4b0ff12bcaca24f9dff393fc5b", "ext": "h", "lang": "C", "content": "void NetSendCmd__FUcUc(unsigned char bHiPri, unsigned char bCmd) {\n\t// address: 0xFFFFFFF0\n\t// size: 0x1\n\tauto struct TCmd cmd;\n}", "item_id": 322, "repo": "maoa3/scalpel", "file": "psx/_dump_/44/_dump_c_/decls.h", "last_update_at": "2021-09-27T15:57:18+00:00", "question_id": "654b30b483b87d4b0ff12bcaca24f9dff393fc5b_322", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void NetSendCmd__FUcUc(unsigned char bHiPri, unsigned char bCmd) {\n\t// address: 0xFFFFFFF0\n\t// size: 0x1\n\tauto struct TCmd cmd;\n"]]}
{"hexsha": "ecac46b9f86228ed04777ba1d859c21ec8156178", "ext": "c", "lang": "C", "content": "void f56(void) {\n    \tuint64_t x225 = 8541349LLU;\n\tstatic int64_t x226 = INT64_MAX;\n\tvolatile uint32_t x228 = 32U;\n\n    t56 = (x225&(x226!=(x227!=x228)));\n\n    if (t56 != 1LLU) { NG(); } else { ; }\n\t\n}", "item_id": 56, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test1272.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "ecac46b9f86228ed04777ba1d859c21ec8156178_56", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f56(void) {\n    \tuint64_t x225 = 8541349LLU;\n\tstatic int64_t x226 = INT64_MAX;\n\tvolatile uint32_t x228 = 32U;\n    t56 = (x225&(x226!=(x227!=x228)));\n    if (t56 != 1LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "68f2dde6ea755195ed267c4e99875933248e1028", "ext": "c", "lang": "C", "content": "void f45(void) {\n    \tvolatile int8_t x193 = INT8_MAX;\n\tstatic int16_t x194 = INT16_MIN;\n\tuint32_t x195 = UINT32_MAX;\n\tint16_t x196 = -1;\n\tvolatile int32_t t45 = 207705838;\n\n    t45 = (((x193|x194)==x195)-x196);\n\n    if (t45 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 45, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test2452.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "68f2dde6ea755195ed267c4e99875933248e1028_45", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f45(void) {\n    \tvolatile int8_t x193 = INT8_MAX;\n\tstatic int16_t x194 = INT16_MIN;\n\tuint32_t x195 = UINT32_MAX;\n\tint16_t x196 = -1;\n\tvolatile int32_t t45 = 207705838;\n    t45 = (((x193|x194)==x195)-x196);\n    if (t45 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "275a9987f4d51217f727cce21cac126d2cdee6b8", "ext": "c", "lang": "C", "content": "void f48(void) {\n    \tstatic int32_t x233 = INT32_MIN;\n\tstatic uint8_t x235 = 1U;\n\tint32_t t48 = 7029094;\n\n    t48 = (x233!=((x234!=x235)-x236));\n\n    if (t48 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 48, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test1197.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "275a9987f4d51217f727cce21cac126d2cdee6b8_48", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f48(void) {\n    \tstatic int32_t x233 = INT32_MIN;\n\tstatic uint8_t x235 = 1U;\n\tint32_t t48 = 7029094;\n    t48 = (x233!=((x234!=x235)-x236));\n    if (t48 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "f9efc9637582639099c097b544d08428b5e0fd40", "ext": "c", "lang": "C", "content": "int ls_gui(void)\n{\n\tint file_num;\n\tstruct RECT t;\n\tint idx;\n\n\tST->ConOut->ClearScreen(ST->ConOut);\n\n\tfile_num = ls();\n\n\tt.x = 0;\n\tt.y = 0;\n\tt.w = (MAX_FILE_NAME_LEN - 1) * WIDTH_PER_CH;\n\tt.h = HEIGHT_PER_CH;\n\tfor (idx = 0; idx < file_num; idx++) {\n\t\tfile_list[idx].rect.x = t.x;\n\t\tfile_list[idx].rect.y = t.y;\n\t\tfile_list[idx].rect.w = t.w;\n\t\tfile_list[idx].rect.h = t.h;\n\t\tdraw_rect(file_list[idx].rect, white);\n\t\tt.x += file_list[idx].rect.w + WIDTH_PER_CH;\n\n\t\tfile_list[idx].is_highlight = FALSE;\n\t}\n\n\treturn file_num;\n}", "item_id": 3, "repo": "cupnes/bare_metal_uefi", "file": "064_fs_get_file_info/libuefi/gui.c", "last_update_at": "2021-11-30T04:34:31+00:00", "question_id": "f9efc9637582639099c097b544d08428b5e0fd40_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int ls_gui(void)\n{\n\tint file_num;\n\tstruct RECT t;\n\tint idx;\n\tST->ConOut->ClearScreen(ST->ConOut);\n\tfile_num = ls();\n\tt.x = 0;\n\tt.y = 0;\n\tt.w = (MAX_FILE_NAME_LEN - 1) * WIDTH_PER_CH;\n\tt.h = HEIGHT_PER_CH;\n\tfor (idx = 0; idx < file_num; idx++) {\n\t\tfile_list[idx].rect.x = t.x;\n\t\tfile_list[idx].rect.y = t.y;\n\t\tfile_list[idx].rect.w = t.w;\n\t\tfile_list[idx].rect.h = t.h;\n\t\tdraw_rect(file_list[idx].rect, white);\n\t\tt.x += file_list[idx].rect.w + WIDTH_PER_CH;\n\t\tfile_list[idx].is_highlight = FALSE;\n\t}\n\treturn file_num;\n"]]}
{"hexsha": "b35e0edfaa1a3932fe5b7253296c693bed3ca04f", "ext": "c", "lang": "C", "content": "void f26(void) {\n    \tint32_t x141 = -1;\n\tint16_t x142 = 3707;\n\tstatic volatile int8_t x144 = INT8_MIN;\n\tvolatile int32_t t26 = 169;\n\n    t26 = ((x141*x142)|(x143/x144));\n\n    if (t26 != -3707) { NG(); } else { ; }\n\t\n}", "item_id": 26, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test629.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "b35e0edfaa1a3932fe5b7253296c693bed3ca04f_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f26(void) {\n    \tint32_t x141 = -1;\n\tint16_t x142 = 3707;\n\tstatic volatile int8_t x144 = INT8_MIN;\n\tvolatile int32_t t26 = 169;\n    t26 = ((x141*x142)|(x143/x144));\n    if (t26 != -3707) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "25f5c53716e976530f08daa66c969d715bcb0cec", "ext": "c", "lang": "C", "content": "static inline void\nfirst_init (void)\n{\n  /* Initialize data structures so we can do RPCs.  */\n  __mach_init ();\n\n  RUN_HOOK (_hurd_preinit_hook, ());\n}", "item_id": 3, "repo": "enfoTek/tomato.linksys.e2000.nvram-mod", "file": "tools-src/gnu/glibc/sysdeps/mach/hurd/powerpc/init-first.c", "last_update_at": "2021-06-07T06:29:49+00:00", "question_id": "25f5c53716e976530f08daa66c969d715bcb0cec_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void\nfirst_init (void)\n{\n  /* Initialize data structures so we can do RPCs.  */\n  __mach_init ();\n  RUN_HOOK (_hurd_preinit_hook, ());\n"]]}
{"hexsha": "2c40a6f97da2dcce1492714e4cc690c16714bba2", "ext": "c", "lang": "C", "content": "void f101(void) {\n    \tvolatile int64_t x457 = -1LL;\n\tint32_t x458 = 22140;\n\tint16_t x459 = -1;\n\tvolatile int64_t t101 = 0LL;\n\n    t101 = ((x457+x458)*(x459!=x460));\n\n    if (t101 != 22139LL) { NG(); } else { ; }\n\t\n}", "item_id": 101, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1179.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "2c40a6f97da2dcce1492714e4cc690c16714bba2_101", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f101(void) {\n    \tvolatile int64_t x457 = -1LL;\n\tint32_t x458 = 22140;\n\tint16_t x459 = -1;\n\tvolatile int64_t t101 = 0LL;\n    t101 = ((x457+x458)*(x459!=x460));\n    if (t101 != 22139LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "032ecb82cb6ac2ef5b5f96ec800e4050c92ede8e", "ext": "c", "lang": "C", "content": "void f193(void) {\n    \tvolatile int32_t x789 = -1;\n\tvolatile int64_t x790 = INT64_MIN;\n\tint16_t x791 = INT16_MAX;\n\tint16_t x792 = INT16_MIN;\n\n    t193 = (x789|((x790^x791)%x792));\n\n    if (t193 != -1LL) { NG(); } else { ; }\n\t\n}", "item_id": 193, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_5/test2617.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "032ecb82cb6ac2ef5b5f96ec800e4050c92ede8e_193", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f193(void) {\n    \tvolatile int32_t x789 = -1;\n\tvolatile int64_t x790 = INT64_MIN;\n\tint16_t x791 = INT16_MAX;\n\tint16_t x792 = INT16_MIN;\n    t193 = (x789|((x790^x791)%x792));\n    if (t193 != -1LL) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "aafb03f076134e8bdad23b65e7838e6efd3a264b", "ext": "c", "lang": "C", "content": "void GrDestroyPath(GrPath *gp)\n{\n    if (gp == NULL) return;\n    free(gp->pp);\n    free(gp);\n}", "item_id": 3, "repo": "irishpatrick/libmsvg", "file": "mgrx/pathmgrx.c", "last_update_at": "2021-12-17T12:14:46+00:00", "question_id": "aafb03f076134e8bdad23b65e7838e6efd3a264b_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void GrDestroyPath(GrPath *gp)\n{\n    if (gp == NULL) return;\n    free(gp->pp);\n    free(gp);\n"]]}
{"hexsha": "340ff423ac0af3760594263b5f5ab400a7fe2457", "ext": "c", "lang": "C", "content": "void init(){\n  ::init();\n  add_action(\"touch_fun\",\"touch\");\n  return;\n}", "item_id": 1, "repo": "Dbevan/SunderingShadows", "file": "d/islands/elf/obj/stone1.c", "last_update_at": "2021-11-18T04:08:19+00:00", "question_id": "340ff423ac0af3760594263b5f5ab400a7fe2457_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void init(){\n  ::init();\n  add_action(\"touch_fun\",\"touch\");\n  return;\n"]]}
{"hexsha": "854c3bcc997b07b4231b088a2eabd9215d8e6f42", "ext": "c", "lang": "C", "content": "void oai_nw_drv_timer(unsigned long data)\n{\n  //---------------------------------------------------------------------------\n  struct oai_nw_drv_priv *priv=(struct oai_nw_drv_priv *)data;\n  spin_lock(&priv->lock);\n  (priv->timer).function=oai_nw_drv_timer;\n  (priv->timer).expires=jiffies+OAI_NW_DRV_TIMER_TICK;\n  (priv->timer).data=data;\n  add_timer(&priv->timer);\n  spin_unlock(&priv->lock);\n  return;\n  //  add_timer(&gpriv->timer);\n  //  spin_unlock(&gpriv->lock);\n}", "item_id": 2, "repo": "shadansari/onos-cu-cp", "file": "openair2/NETWORK_DRIVER/LITE/device.c", "last_update_at": "2021-01-24T07:04:29+00:00", "question_id": "854c3bcc997b07b4231b088a2eabd9215d8e6f42_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void oai_nw_drv_timer(unsigned long data)\n{\n  //---------------------------------------------------------------------------\n  struct oai_nw_drv_priv *priv=(struct oai_nw_drv_priv *)data;\n  spin_lock(&priv->lock);\n  (priv->timer).function=oai_nw_drv_timer;\n  (priv->timer).expires=jiffies+OAI_NW_DRV_TIMER_TICK;\n  (priv->timer).data=data;\n  add_timer(&priv->timer);\n  spin_unlock(&priv->lock);\n  return;\n  //  add_timer(&gpriv->timer);\n  //  spin_unlock(&gpriv->lock);\n"]]}
{"hexsha": "0347a96adfe6f601378e47b58790e10998759cdd", "ext": "c", "lang": "C", "content": "void f194(void) {\n    \tstatic int16_t x809 = INT16_MIN;\n\tstatic volatile uint32_t x810 = 2092U;\n\tstatic int32_t x811 = -1;\n\tint8_t x812 = INT8_MIN;\n\tvolatile uint32_t t194 = 75247U;\n\n    t194 = ((x809/(x810^x811))^x812);\n\n    if (t194 != 4294967168U) { NG(); } else { ; }\n\t\n}", "item_id": 194, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test2604.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "0347a96adfe6f601378e47b58790e10998759cdd_194", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f194(void) {\n    \tstatic int16_t x809 = INT16_MIN;\n\tstatic volatile uint32_t x810 = 2092U;\n\tstatic int32_t x811 = -1;\n\tint8_t x812 = INT8_MIN;\n\tvolatile uint32_t t194 = 75247U;\n    t194 = ((x809/(x810^x811))^x812);\n    if (t194 != 4294967168U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "bde5180f70e7ad6ff0a98a6f9e3d62f505f3462c", "ext": "c", "lang": "C", "content": "void f33(void) {\n    \tuint16_t x149 = 2U;\n\tint8_t x150 = INT8_MIN;\n\tvolatile int16_t x151 = INT16_MAX;\n\tint16_t x152 = INT16_MIN;\n\tint32_t t33 = -1365658;\n\n    t33 = ((x149/x150)/(x151^x152));\n\n    if (t33 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 33, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test2594.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "bde5180f70e7ad6ff0a98a6f9e3d62f505f3462c_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f33(void) {\n    \tuint16_t x149 = 2U;\n\tint8_t x150 = INT8_MIN;\n\tvolatile int16_t x151 = INT16_MAX;\n\tint16_t x152 = INT16_MIN;\n\tint32_t t33 = -1365658;\n    t33 = ((x149/x150)/(x151^x152));\n    if (t33 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "28c515b3dc20636156fe90b4a79c3e7642e8114d", "ext": "c", "lang": "C", "content": "RK_S32 PPContinuousCheck(RK_U32 value)\r\n{\r\n\r\n    RK_S32 ret = (RK_S32) PP_OK;\r\n    RK_U32 first = 0;\r\n    RK_U32 tmp = 0;\r\n\r\n    if(value)\r\n    {\r\n        do\r\n        {\r\n            tmp = value & 1;\r\n            if(tmp)\r\n                ret = (RK_S32) PP_OK;\r\n            else\r\n                ret = (RK_S32) PP_PARAM_ERROR;\r\n\r\n            first |= tmp;\r\n\r\n            value = value >> 1;\r\n            if(!tmp && !tmp && first)\r\n                break;\r\n\r\n        }\r\n        while(value);\r\n    }\r\n\r\n    return ret;\r\n}", "item_id": 16, "repo": "zhangximin/rk_jpeg", "file": "vpu_linux_dec_enc_user/jpeghw/src_dec/pp/ppinternal.c", "last_update_at": "2021-06-09T00:06:29+00:00", "question_id": "28c515b3dc20636156fe90b4a79c3e7642e8114d_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["RK_S32 PPContinuousCheck(RK_U32 value)\r\n{\r\n\r\n    RK_S32 ret = (RK_S32) PP_OK;\r\n    RK_U32 first = 0;\r\n    RK_U32 tmp = 0;\r\n\r\n    if(value)\r\n    {\r\n        do\r\n        {\r\n            tmp = value & 1;\r\n            if(tmp)\r\n                ret = (RK_S32) PP_OK;\r\n            else\r\n                ret = (RK_S32) PP_PARAM_ERROR;\r\n\r\n            first |= tmp;\r\n\r\n            value = value >> 1;\r\n            if(!tmp && !tmp && first)\r\n                break;\r\n\r\n        }\r\n        while(value);\r\n    }\r\n\r\n    return ret;\r\n"]]}
{"hexsha": "d69e8d9a3773ccdca45931172c28a8b7c7c43e5d", "ext": "h", "lang": "C", "content": "class GestureRecognition\r\n{\r\npublic:\r\n\t//skeleton allBoneJoints[2500];\r\n\tstatic bool _StartScan;\r\n\tstatic bool recordData;\r\n\tstatic bool initCalib;\r\n\tstatic bool isCalib;\r\n\tstatic bool readFile;\r\n\r\n\tstatic char* fileName;\r\n\r\n\tstatic int tFrameIndex;\r\n\r\n\r\npublic:\r\n\tvoid gesturerecog(JointPosition &jpos);\r\n\r\n\r\n\r\n}", "item_id": 0, "repo": "younghochai/motion-matrix", "file": "OpenIA/include/iaGesture.h", "last_update_at": "2021-12-23T00:52:31+00:00", "question_id": "d69e8d9a3773ccdca45931172c28a8b7c7c43e5d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["class GestureRecognition\r\n{\r\npublic:\r\n\t//skeleton allBoneJoints[2500];\r\n\tstatic bool _StartScan;\r\n\tstatic bool recordData;\r\n\tstatic bool initCalib;\r\n\tstatic bool isCalib;\r\n\tstatic bool readFile;\r\n\r\n\tstatic char* fileName;\r\n\r\n\tstatic int tFrameIndex;\r\n\r\n\r\npublic:\r\n\tvoid gesturerecog(JointPosition &jpos);\r\n\r\n\r\n\r\n"]]}
{"hexsha": "156d65351bdaa2294012bb59dc2b1d417be421b5", "ext": "h", "lang": "C", "content": "enum class RedirectState {\n    kNone,\n\n    // The redirect decision is pending from the underlying decider.\n    kRedirectDecisionPending,\n\n    // Redirect was disallowed by the underlying decider e.g., robots rules\n    // decider.\n    kRedirectNotAllowedByDecider,\n\n    // The subresource request was redirected to attempt to compress it.\n    kRedirectAttempted,\n\n    // Failed due to http response codes, net errors, and the subresource was\n    // fetched from original origin.\n    kRedirectFailed\n  };\n\n  static std::unique_ptr<SubresourceRedirectURLLoaderThrottle>\n  MaybeCreateThrottle(const blink::WebURLRequest& request, int render_frame_id);\n\n  SubresourceRedirectURLLoaderThrottle(int render_frame_id,\n                                       bool allowed_to_redirect);\n  ~SubresourceRedirectURLLoaderThrottle() override;\n\n  SubresourceRedirectURLLoaderThrottle(\n      const SubresourceRedirectURLLoaderThrottle&) = delete;\n  SubresourceRedirectURLLoaderThrottle& operator=(\n      const SubresourceRedirectURLLoaderThrottle&) = delete;\n\n  // blink::URLLoaderThrottle:\n  void WillStartRequest(network::ResourceRequest* request,\n                        bool* defer) override;\n  void WillRedirectRequest(\n      net::RedirectInfo* redirect_info,\n      const network::mojom::URLResponseHead& response_head,\n      bool* defer,\n      std::vector<std::string>* to_be_removed_request_headers,\n      net::HttpRequestHeaders* modified_request_headers,\n      net::HttpRequestHeaders* modified_cors_exempt_request_headers) override;\n  void BeforeWillProcessResponse(\n      const GURL& response_url,\n      const network::mojom::URLResponseHead& response_head,\n      bool* defer) override;\n  void WillProcessResponse(const GURL& response_url,\n                           network::mojom::URLResponseHead* response_head,\n                           bool* defer) override;\n  void WillOnCompleteWithError(const network::URLLoaderCompletionStatus& status,\n                               bool* defer) override;\n  // Overridden to do nothing as the default implementation is NOT_REACHED()\n  void DetachFromCurrentSequence() override;\n\n private:\n  friend class SubresourceRedirectPublicImageHintsDeciderAgentTest;\n\n  // Callback to notify the decision of decider subclasses.\n  void NotifyRedirectDeciderDecision(RedirectResult);\n\n  // Start the timer for redirect fetch timeout.\n  void StartRedirectTimeoutTimer();\n\n  // Callback invoked when the redirect fetch times out.\n  void OnRedirectTimeout();\n\n  // Render frame id to get the hints agent of the render frame.\n  const int render_frame_id_;\n\n  // The current state of redirect.\n  RedirectState redirect_state_ = RedirectState::kNone;\n\n  // Timer to detect whether the response from compression server has timed out.\n  std::unique_ptr<base::OneShotTimer> redirect_timeout_timer_;\n\n  // Whether the subresource can be redirected or not and what was the reason if\n  // its not eligible.\n  RedirectResult redirect_result_ = RedirectResult::kUnknown;\n\n  // Used to record the image load and compression metrics.\n  base::Optional<LoginRobotsCompressionMetrics>\n      login_robots_compression_metrics_;\n\n  // Used to get a weak pointer to |this|.\n  base::WeakPtrFactory<SubresourceRedirectURLLoaderThrottle> weak_ptr_factory_{\n      this};\n};\n\n}", "item_id": 0, "repo": "Ron423c/chromium", "file": "chrome/renderer/subresource_redirect/subresource_redirect_url_loader_throttle.h", "last_update_at": "2021-03-07T14:20:02+00:00", "question_id": "156d65351bdaa2294012bb59dc2b1d417be421b5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["enum class RedirectState {\n    kNone,\n    // The redirect decision is pending from the underlying decider.\n    kRedirectDecisionPending,\n    // Redirect was disallowed by the underlying decider e.g., robots rules\n    // decider.\n    kRedirectNotAllowedByDecider,\n    // The subresource request was redirected to attempt to compress it.\n    kRedirectAttempted,\n    // Failed due to http response codes, net errors, and the subresource was\n    // fetched from original origin.\n    kRedirectFailed\n  };\n  static std::unique_ptr<SubresourceRedirectURLLoaderThrottle>\n  MaybeCreateThrottle(const blink::WebURLRequest& request, int render_frame_id);\n  SubresourceRedirectURLLoaderThrottle(int render_frame_id,\n                                       bool allowed_to_redirect);\n  ~SubresourceRedirectURLLoaderThrottle() override;\n  SubresourceRedirectURLLoaderThrottle(\n      const SubresourceRedirectURLLoaderThrottle&) = delete;\n  SubresourceRedirectURLLoaderThrottle& operator=(\n      const SubresourceRedirectURLLoaderThrottle&) = delete;\n  // blink::URLLoaderThrottle:\n  void WillStartRequest(network::ResourceRequest* request,\n                        bool* defer) override;\n  void WillRedirectRequest(\n      net::RedirectInfo* redirect_info,\n      const network::mojom::URLResponseHead& response_head,\n      bool* defer,\n      std::vector<std::string>* to_be_removed_request_headers,\n      net::HttpRequestHeaders* modified_request_headers,\n      net::HttpRequestHeaders* modified_cors_exempt_request_headers) override;\n  void BeforeWillProcessResponse(\n      const GURL& response_url,\n      const network::mojom::URLResponseHead& response_head,\n      bool* defer) override;\n  void WillProcessResponse(const GURL& response_url,\n                           network::mojom::URLResponseHead* response_head,\n                           bool* defer) override;\n  void WillOnCompleteWithError(const network::URLLoaderCompletionStatus& status,\n                               bool* defer) override;\n  // Overridden to do nothing as the default implementation is NOT_REACHED()\n  void DetachFromCurrentSequence() override;\n private:\n  friend class SubresourceRedirectPublicImageHintsDeciderAgentTest;\n  // Callback to notify the decision of decider subclasses.\n  void NotifyRedirectDeciderDecision(RedirectResult);\n  // Start the timer for redirect fetch timeout.\n  void StartRedirectTimeoutTimer();\n  // Callback invoked when the redirect fetch times out.\n  void OnRedirectTimeout();\n  // Render frame id to get the hints agent of the render frame.\n  const int render_frame_id_;\n  // The current state of redirect.\n  RedirectState redirect_state_ = RedirectState::kNone;\n  // Timer to detect whether the response from compression server has timed out.\n  std::unique_ptr<base::OneShotTimer> redirect_timeout_timer_;\n  // Whether the subresource can be redirected or not and what was the reason if\n  // its not eligible.\n  RedirectResult redirect_result_ = RedirectResult::kUnknown;\n  // Used to record the image load and compression metrics.\n  base::Optional<LoginRobotsCompressionMetrics>\n      login_robots_compression_metrics_;\n  // Used to get a weak pointer to |this|.\n  base::WeakPtrFactory<SubresourceRedirectURLLoaderThrottle> weak_ptr_factory_{\n      this};\n};\n"]]}
{"hexsha": "7a777a2d33b2079c58f60afd1b107de41ca577e2", "ext": "c", "lang": "C", "content": "void f66(void) {\n    \tint32_t x389 = -602;\n\tvolatile int32_t x390 = INT32_MIN;\n\tuint8_t x391 = 59U;\n\tstatic volatile int32_t t66 = 1635999;\n\n    t66 = (x389^(x390|(x391*x392)));\n\n    if (t66 != 745) { NG(); } else { ; }\n\t\n}", "item_id": 66, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test574.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "7a777a2d33b2079c58f60afd1b107de41ca577e2_66", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f66(void) {\n    \tint32_t x389 = -602;\n\tvolatile int32_t x390 = INT32_MIN;\n\tuint8_t x391 = 59U;\n\tstatic volatile int32_t t66 = 1635999;\n    t66 = (x389^(x390|(x391*x392)));\n    if (t66 != 745) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "a934582750652266faeeb771f39732d6e881669d", "ext": "h", "lang": "C", "content": "UPB_INLINE envoy_config_cluster_v3_Cluster_EdsClusterConfig* envoy_config_cluster_v3_Cluster_EdsClusterConfig_parse_ex(const char* buf, size_t size,\n                           const upb_ExtensionRegistry* extreg,\n                           int options, upb_Arena* arena) {\n  envoy_config_cluster_v3_Cluster_EdsClusterConfig* ret = envoy_config_cluster_v3_Cluster_EdsClusterConfig_new(arena);\n  if (!ret) return NULL;\n  if (upb_Decode(buf, size, ret, &envoy_config_cluster_v3_Cluster_EdsClusterConfig_msginit, extreg, options, arena) !=\n      kUpb_DecodeStatus_Ok) {\n    return NULL;\n  }\n  return ret;\n}", "item_id": 51, "repo": "lishengze/grpc", "file": "src/core/ext/upb-generated/envoy/config/cluster/v3/cluster.upb.h", "last_update_at": "2021-12-01T03:10:14+00:00", "question_id": "a934582750652266faeeb771f39732d6e881669d_51", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["UPB_INLINE envoy_config_cluster_v3_Cluster_EdsClusterConfig* envoy_config_cluster_v3_Cluster_EdsClusterConfig_parse_ex(const char* buf, size_t size,\n                           const upb_ExtensionRegistry* extreg,\n                           int options, upb_Arena* arena) {\n  envoy_config_cluster_v3_Cluster_EdsClusterConfig* ret = envoy_config_cluster_v3_Cluster_EdsClusterConfig_new(arena);\n  if (!ret) return NULL;\n  if (upb_Decode(buf, size, ret, &envoy_config_cluster_v3_Cluster_EdsClusterConfig_msginit, extreg, options, arena) !=\n      kUpb_DecodeStatus_Ok) {\n    return NULL;\n  }\n  return ret;\n"]]}
{"hexsha": "cee00d736b2161c3a3e6097f660b354dbbab46fb", "ext": "c", "lang": "C", "content": "static status_t POWER_DRV_UpdateInitClk(const sys_clk_config_t * const sysClk)\n{\n    status_t retCode = STATUS_SUCCESS;\n    \n    retCode = CLOCK_DRV_SetSystemClock(NULL,sysClk);\n\n    return retCode;\n}", "item_id": 6, "repo": "migsantiago/s32k1_st7735", "file": "s32k1_st7735/SDK/platform/drivers/src/power/S32K1xx/power_manager_S32K1xx.c", "last_update_at": "2021-01-17T01:44:41+00:00", "question_id": "cee00d736b2161c3a3e6097f660b354dbbab46fb_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static status_t POWER_DRV_UpdateInitClk(const sys_clk_config_t * const sysClk)\n{\n    status_t retCode = STATUS_SUCCESS;\n    retCode = CLOCK_DRV_SetSystemClock(NULL,sysClk);\n    return retCode;\n"]]}
{"hexsha": "0b378362d3ce18aea692db8dd36aaa76b74fe43a", "ext": "c", "lang": "C", "content": "int update_size (app_t *app) {\n\n    int width, height;\n    SDL_GetWindowSize (app->window, &width, &height);\n\n    if (app->texture)\n        SDL_DestroyTexture (app->texture);\n\n    if (!(app->texture = SDL_CreateTexture (app->renderer,\n                                            SDL_PIXELFORMAT_RGBA8888,\n                                            SDL_TEXTUREACCESS_STREAMING,\n                                            width,\n                                            height))) {\n\n        fprintf (stderr, \"Could not create texture: %s\\n\", SDL_GetError ());\n        return EXIT_FAILURE;\n    }\n\n    if (app->display.buffer_output)\n        display_deinit (&app->display);\n\n    display_init (&app->display, width, height, callback, app);\n\n    app->time_init = SDL_GetTicks () / 1000.0;\n\n    return EXIT_FAILURE;\n}", "item_id": 1, "repo": "negativefnnancy/Sound-Chip", "file": "src/tests/display.c", "last_update_at": "2021-02-28T07:47:40+00:00", "question_id": "0b378362d3ce18aea692db8dd36aaa76b74fe43a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int update_size (app_t *app) {\n    int width, height;\n    SDL_GetWindowSize (app->window, &width, &height);\n    if (app->texture)\n        SDL_DestroyTexture (app->texture);\n    if (!(app->texture = SDL_CreateTexture (app->renderer,\n                                            SDL_PIXELFORMAT_RGBA8888,\n                                            SDL_TEXTUREACCESS_STREAMING,\n                                            width,\n                                            height))) {\n        fprintf (stderr, \"Could not create texture: %s\\n\", SDL_GetError ());\n        return EXIT_FAILURE;\n    }\n    if (app->display.buffer_output)\n        display_deinit (&app->display);\n    display_init (&app->display, width, height, callback, app);\n    app->time_init = SDL_GetTicks () / 1000.0;\n    return EXIT_FAILURE;\n"]]}
{"hexsha": "8f2da2cb12af233b0eddba9d5ca666c704883cd4", "ext": "c", "lang": "C", "content": "void f18(void) {\n    \tvolatile int8_t x173 = INT8_MAX;\n\tint32_t x174 = -6;\n\tint16_t x175 = INT16_MAX;\n\tint64_t x176 = INT64_MIN;\n\tvolatile int32_t t18 = 924068;\n\n    t18 = ((x173+x174)>>(x175/x176));\n\n    if (t18 != 121) { NG(); } else { ; }\n\t\n}", "item_id": 18, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test599.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "8f2da2cb12af233b0eddba9d5ca666c704883cd4_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f18(void) {\n    \tvolatile int8_t x173 = INT8_MAX;\n\tint32_t x174 = -6;\n\tint16_t x175 = INT16_MAX;\n\tint64_t x176 = INT64_MIN;\n\tvolatile int32_t t18 = 924068;\n    t18 = ((x173+x174)>>(x175/x176));\n    if (t18 != 121) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "f11be71af12f9083a6a63cb6e143b1243b7ff072", "ext": "c", "lang": "C", "content": "void f120(void) {\n    \tuint32_t x1001 = 24041976U;\n\tuint16_t x1002 = 1U;\n\tuint32_t x1003 = 29597U;\n\tint32_t x1004 = 711;\n\tvolatile int32_t t120 = -31;\n\n    t120 = (x1001<=(x1002%(x1003/x1004)));\n\n    if (t120 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 120, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test654.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "f11be71af12f9083a6a63cb6e143b1243b7ff072_120", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f120(void) {\n    \tuint32_t x1001 = 24041976U;\n\tuint16_t x1002 = 1U;\n\tuint32_t x1003 = 29597U;\n\tint32_t x1004 = 711;\n\tvolatile int32_t t120 = -31;\n    t120 = (x1001<=(x1002%(x1003/x1004)));\n    if (t120 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "d19efff28fff0d0cef4b778f4e2c4e9473886f84", "ext": "h", "lang": "C", "content": "void AGameCrowdAgentSkeletal::SetLighting ( )\r\n{\r\n\tstatic UFunction* pFnSetLighting = NULL;\r\n\r\n\tif ( ! pFnSetLighting )\r\n\t\tpFnSetLighting = (UFunction*) UObject::GObjObjects()->Data[ 43301 ];\r\n\r\n\tAGameCrowdAgentSkeletal_execSetLighting_Parms SetLighting_Parms;\r\n\r\n\tthis->ProcessEvent ( pFnSetLighting, &SetLighting_Parms, NULL );\r\n}", "item_id": 116, "repo": "HOOSIER0x007/UE3-Hook", "file": "KF2-UE3-Hook/SDK_HEADERS/GameFramework_functions.h", "last_update_at": "2021-11-23T21:47:43+00:00", "question_id": "d19efff28fff0d0cef4b778f4e2c4e9473886f84_116", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void AGameCrowdAgentSkeletal::SetLighting ( )\r\n{\r\n\tstatic UFunction* pFnSetLighting = NULL;\r\n\r\n\tif ( ! pFnSetLighting )\r\n\t\tpFnSetLighting = (UFunction*) UObject::GObjObjects()->Data[ 43301 ];\r\n\r\n\tAGameCrowdAgentSkeletal_execSetLighting_Parms SetLighting_Parms;\r\n\r\n\tthis->ProcessEvent ( pFnSetLighting, &SetLighting_Parms, NULL );\r\n"]]}
{"hexsha": "a8aa990e49488492f795b70ff90474d7dd862414", "ext": "c", "lang": "C", "content": "void f62(void) {\n    \tvolatile uint16_t x250 = 130U;\n\tint8_t x251 = INT8_MIN;\n\tvolatile int64_t x252 = INT64_MAX;\n\tvolatile int32_t t62 = -217;\n\n    t62 = ((x249!=x250)|(x251<=x252));\n\n    if (t62 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 62, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1861.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "a8aa990e49488492f795b70ff90474d7dd862414_62", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f62(void) {\n    \tvolatile uint16_t x250 = 130U;\n\tint8_t x251 = INT8_MIN;\n\tvolatile int64_t x252 = INT64_MAX;\n\tvolatile int32_t t62 = -217;\n    t62 = ((x249!=x250)|(x251<=x252));\n    if (t62 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "4de480d5486cbb2d0ee75b5b031842fb17a3e971", "ext": "c", "lang": "C", "content": "DWORD\r\nDmSetValue(\r\n    IN HDMKEY hKey,\r\n    IN LPCWSTR lpValueName,\r\n    IN DWORD dwType,\r\n    IN CONST BYTE *lpData,\r\n    IN DWORD cbData\r\n    )\r\n\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    This routine sets the named value for the specified\r\n    cluster registry key.\r\n\r\nArguments:\r\n\r\n    hKey - Supplies the cluster registry subkey whose value is to be set\r\n\r\n    lpValueName - Supplies the name of the value to be set.\r\n\r\n    dwType - Supplies the value data type\r\n\r\n    lpData - Supplies a pointer to the value data\r\n\r\n    cbData - Supplies the length of the value data.\r\n\r\nReturn Value:\r\n\r\n    ERROR_SUCCESS if successful\r\n\r\n    Win32 error code otherwise\r\n\r\n--*/\r\n\r\n{\r\n\r\n    DWORD Status= ERROR_SUCCESS;        //initialize to success\r\n    PDMKEY Key;\r\n    DWORD NameLength;\r\n    DWORD ValueNameLength;\r\n    DWORD UpdateLength;\r\n    PDM_SET_VALUE_UPDATE Update;\r\n    PUCHAR Dest;\r\n\r\n\r\n    Key = (PDMKEY)hKey;\r\n\r\n    if (ISKEYDELETED(Key))\r\n        return(ERROR_KEY_DELETED);\r\n\r\n    //\r\n    // round lengths such that pointers to the data trailing the structure are\r\n    // aligned on the architecture's natural boundary\r\n    //\r\n    NameLength = (lstrlenW(Key->Name)+1)*sizeof(WCHAR);\r\n    NameLength = ROUND_UP_COUNT( NameLength, sizeof( DWORD_PTR ));\r\n\r\n    ValueNameLength = (lstrlenW(lpValueName)+1)*sizeof(WCHAR);\r\n    ValueNameLength = ROUND_UP_COUNT( ValueNameLength, sizeof( DWORD_PTR ));\r\n\r\n    UpdateLength = sizeof(DM_SET_VALUE_UPDATE) +\r\n                   NameLength +\r\n                   ValueNameLength +\r\n                   cbData;\r\n\r\n\r\n    Update = (PDM_SET_VALUE_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);\r\n    if (Update == NULL) {\r\n        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);\r\n        return(ERROR_NOT_ENOUGH_MEMORY);\r\n    }\r\n\r\n\r\n    Update->lpStatus = &Status;\r\n    Update->NameOffset = FIELD_OFFSET(DM_SET_VALUE_UPDATE, KeyName)+NameLength;\r\n    Update->DataOffset = Update->NameOffset + ValueNameLength;\r\n    Update->DataLength = cbData;\r\n    Update->Type = dwType;\r\n    CopyMemory(Update->KeyName, Key->Name, NameLength);\r\n\r\n    Dest = (PUCHAR)Update + Update->NameOffset;\r\n    CopyMemory(Dest, lpValueName, ValueNameLength);\r\n\r\n    Dest = (PUCHAR)Update + Update->DataOffset;\r\n    CopyMemory(Dest, lpData, cbData);\r\n\r\n    Status = GumSendUpdate(GumUpdateRegistry,\r\n                  DmUpdateSetValue,\r\n                  UpdateLength,\r\n                  Update);\r\n\r\n\r\n    LocalFree(Update);\r\n\r\n    return(Status);\r\n\r\n}", "item_id": 5, "repo": "npocmaka/Windows-Server-2003", "file": "base/cluster/service/dm/dmreg.c", "last_update_at": "2021-09-16T09:13:13+00:00", "question_id": "4de480d5486cbb2d0ee75b5b031842fb17a3e971_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["DWORD\r\nDmSetValue(\r\n    IN HDMKEY hKey,\r\n    IN LPCWSTR lpValueName,\r\n    IN DWORD dwType,\r\n    IN CONST BYTE *lpData,\r\n    IN DWORD cbData\r\n    )\r\n\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    This routine sets the named value for the specified\r\n    cluster registry key.\r\n\r\nArguments:\r\n\r\n    hKey - Supplies the cluster registry subkey whose value is to be set\r\n\r\n    lpValueName - Supplies the name of the value to be set.\r\n\r\n    dwType - Supplies the value data type\r\n\r\n    lpData - Supplies a pointer to the value data\r\n\r\n    cbData - Supplies the length of the value data.\r\n\r\nReturn Value:\r\n\r\n    ERROR_SUCCESS if successful\r\n\r\n    Win32 error code otherwise\r\n\r\n--*/\r\n\r\n{\r\n\r\n    DWORD Status= ERROR_SUCCESS;        //initialize to success\r\n    PDMKEY Key;\r\n    DWORD NameLength;\r\n    DWORD ValueNameLength;\r\n    DWORD UpdateLength;\r\n    PDM_SET_VALUE_UPDATE Update;\r\n    PUCHAR Dest;\r\n\r\n\r\n    Key = (PDMKEY)hKey;\r\n\r\n    if (ISKEYDELETED(Key))\r\n        return(ERROR_KEY_DELETED);\r\n\r\n    //\r\n    // round lengths such that pointers to the data trailing the structure are\r\n    // aligned on the architecture's natural boundary\r\n    //\r\n    NameLength = (lstrlenW(Key->Name)+1)*sizeof(WCHAR);\r\n    NameLength = ROUND_UP_COUNT( NameLength, sizeof( DWORD_PTR ));\r\n\r\n    ValueNameLength = (lstrlenW(lpValueName)+1)*sizeof(WCHAR);\r\n    ValueNameLength = ROUND_UP_COUNT( ValueNameLength, sizeof( DWORD_PTR ));\r\n\r\n    UpdateLength = sizeof(DM_SET_VALUE_UPDATE) +\r\n                   NameLength +\r\n                   ValueNameLength +\r\n                   cbData;\r\n\r\n\r\n    Update = (PDM_SET_VALUE_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);\r\n    if (Update == NULL) {\r\n        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);\r\n        return(ERROR_NOT_ENOUGH_MEMORY);\r\n    }\r\n\r\n\r\n    Update->lpStatus = &Status;\r\n    Update->NameOffset = FIELD_OFFSET(DM_SET_VALUE_UPDATE, KeyName)+NameLength;\r\n    Update->DataOffset = Update->NameOffset + ValueNameLength;\r\n    Update->DataLength = cbData;\r\n    Update->Type = dwType;\r\n    CopyMemory(Update->KeyName, Key->Name, NameLength);\r\n\r\n    Dest = (PUCHAR)Update + Update->NameOffset;\r\n    CopyMemory(Dest, lpValueName, ValueNameLength);\r\n\r\n    Dest = (PUCHAR)Update + Update->DataOffset;\r\n    CopyMemory(Dest, lpData, cbData);\r\n\r\n    Status = GumSendUpdate(GumUpdateRegistry,\r\n                  DmUpdateSetValue,\r\n                  UpdateLength,\r\n                  Update);\r\n\r\n\r\n    LocalFree(Update);\r\n\r\n    return(Status);\r\n\r\n"]]}
{"hexsha": "c18c4172332b1c862bed2690fc5bbe36c0770cd4", "ext": "h", "lang": "C", "content": "SCRIPTS_FUNCTION HUBShopMenuManager* CreateHUBShopMenuManager() {\n\tHUBShopMenuManager* script = new HUBShopMenuManager();\n\n\tINSPECTOR_STRING(script->mandoName);\n\tINSPECTOR_STRING(script->exitButtonName);\n\tINSPECTOR_STRING(script->buyButtonName);\n\treturn script;\n}", "item_id": 0, "repo": "MissclickStudios/The-Mandalorian-Sands-of-Arvala", "file": "Resources/Assets/Scripts/HUBShopMenuManager.h", "last_update_at": "2021-05-14T13:08:40+00:00", "question_id": "c18c4172332b1c862bed2690fc5bbe36c0770cd4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SCRIPTS_FUNCTION HUBShopMenuManager* CreateHUBShopMenuManager() {\n\tHUBShopMenuManager* script = new HUBShopMenuManager();\n\tINSPECTOR_STRING(script->mandoName);\n\tINSPECTOR_STRING(script->exitButtonName);\n\tINSPECTOR_STRING(script->buyButtonName);\n\treturn script;\n"]]}
{"hexsha": "650d66eeb7d39efb1a846c16b7405e62ea1f2c49", "ext": "c", "lang": "C", "content": "int file_size(FILE *f, size_t *size) {\n    long off = ftell(f);\n    if (off == -1) return -1;\n    if (fseek(f, 0, SEEK_END) == -1) return -1;\n    long len = ftell(f);\n    if (len == -1) return -1;\n    if (fseek(f, off, SEEK_SET) == -1) return -1;\n    *size = (size_t) len;\n    return 0;\n}", "item_id": 0, "repo": "NoXLaw/RaRCTF2021-Challenges-Public", "file": "rev/rev-boring-flag-checker/src/boring-flag-checker.c", "last_update_at": "2021-08-09T17:08:17+00:00", "question_id": "650d66eeb7d39efb1a846c16b7405e62ea1f2c49_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int file_size(FILE *f, size_t *size) {\n    long off = ftell(f);\n    if (off == -1) return -1;\n    if (fseek(f, 0, SEEK_END) == -1) return -1;\n    long len = ftell(f);\n    if (len == -1) return -1;\n    if (fseek(f, off, SEEK_SET) == -1) return -1;\n    *size = (size_t) len;\n    return 0;\n"]]}
{"hexsha": "6fb529986b88ec394adb59f08b3f73c56e47a052", "ext": "c", "lang": "C", "content": "void f106(void) {\n    \tint32_t x521 = -1;\n\tvolatile int32_t x522 = INT32_MAX;\n\tuint16_t x523 = 1946U;\n\tuint32_t x524 = 63227U;\n\tstatic volatile uint32_t t106 = 53U;\n\n    t106 = ((x521*(x522|x523))^x524);\n\n    if (t106 != 2147546874U) { NG(); } else { ; }\n\t\n}", "item_id": 106, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test2394.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "6fb529986b88ec394adb59f08b3f73c56e47a052_106", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f106(void) {\n    \tint32_t x521 = -1;\n\tvolatile int32_t x522 = INT32_MAX;\n\tuint16_t x523 = 1946U;\n\tuint32_t x524 = 63227U;\n\tstatic volatile uint32_t t106 = 53U;\n    t106 = ((x521*(x522|x523))^x524);\n    if (t106 != 2147546874U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "d3896fe8b7f43353afe2d19f4602ac324dcd0bf7", "ext": "c", "lang": "C", "content": "void f63(void) {\n    \tvolatile int8_t x325 = INT8_MIN;\n\tint16_t x326 = -1;\n\tint8_t x327 = INT8_MAX;\n\tstatic int32_t t63 = -1393427;\n\n    t63 = (x325==(x326|(x327*x328)));\n\n    if (t63 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 63, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test568.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "d3896fe8b7f43353afe2d19f4602ac324dcd0bf7_63", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f63(void) {\n    \tvolatile int8_t x325 = INT8_MIN;\n\tint16_t x326 = -1;\n\tint8_t x327 = INT8_MAX;\n\tstatic int32_t t63 = -1393427;\n    t63 = (x325==(x326|(x327*x328)));\n    if (t63 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "b538b99826394eb32a6f5bc27b0382779cc1eed7", "ext": "c", "lang": "C", "content": "static void biquad_init_band(struct iir_filter *filter, double fs,\n    double f1, double f2, int stop)\n{\n    double ts = 1.0 / fs;\n    double bw, f;\n    double w;\n    complex_d p, q;\n    complex_d z, s;\n    double phi;\n    complex_d _z, p_lp, p_bp;\n    double k, x, y;\n    double wa1, wa2, wa;\n    double *a = filter->a;\n    double *b = filter->b;\n    int n, i;\n\n    f = sqrt(f1 * f2);\n    w = 2 * M_PI * f / fs;\n\n    /* Map to continuous-time frequencies (pre-warp) */\n\n    wa1 = 2 * fs * tan(M_PI * f1 * ts);\n    wa2 = 2 * fs * tan(M_PI * f2 * ts);\n\n    bw = wa2 - wa1;\n    wa = sqrt(wa1 * wa2);\n\n    n = filter->sections;\n\n    for (i = 0; i < n; i += 1) {\n        phi = M_PI / 2 + M_PI * (2 * i + 1) / (n * 2);\n        x = cos(phi);\n        y = sin(phi);\n\n        p_lp.re = x * bw / (wa * 2);\n        p_lp.im = y * bw / (wa * 2);\n\n        /*\n         *  Map every low-pass pole to a complex conjugate\n         *  pair of band-bass poles\n         */\n\n        s = p_lp;\n        complex_square(&s);\n        s.re = 1 - s.re;\n        s.im = 0 - s.im;\n        complex_sqrt(&s);\n        x = p_lp.re - s.im;\n        y = p_lp.im + s.re;\n        p_bp.re = x * wa;\n        p_bp.im = y * wa;\n\n        /*\n         *  Convert every pair from continuous (s)\n         *  to discrete (z) using bilinear transform\n         */\n\n        bilinear_transform(&z, &p_bp, ts);\n\n        x = z.re;\n        y = z.im;\n\n        /*\n         *  Find denominator coefficients from\n         *  the complex conjugate pair of poles\n         */\n\n        a[0] = 1;\n        a[1] = -2 * x;\n        a[2] = x * x + y * y;\n\n        if (stop) {\n            /* Band-stop: zeros at \u03c9 and ~\u03c9 */\n            s.re = 0;\n            s.im = wa;\n            bilinear_transform(&z, &s, ts);\n            x = z.re;\n            y = z.im;\n\n            b[0] = 1;\n            b[1] = -2 * x;\n            b[2] = x * x + y * y;\n        } else {\n            /* Band-pass: zeros at \u00b11 */\n            b[0] = 1;\n            b[1] = 0;\n            b[2] = -1;\n        }\n\n        /* Scale the parameters to get unity gain in the bassband */\n\n        if (stop) {\n            /* Band-stop: unity gain at zero frequency */\n            _z.re = 1;\n            _z.im = 0;\n        } else {\n            /* Band-pass: unity gain at \u03c9 */\n            _z.re = cos(w);\n            _z.im = -sin(w);\n        }\n\n        p.re = b[2];\n        p.im = 0;\n        complex_mul(&p, &_z);\n        p.re += b[1];\n        complex_mul(&p, &_z);\n        p.re += b[0];\n\n        q.re = a[2];\n        q.im = 0;\n        complex_mul(&q, &_z);\n        q.re += a[1];\n        complex_mul(&q, &_z);\n        q.re += 1;\n\n        complex_div(&p, &q);\n\n        x = p.re;\n        y = p.im;\n        k = 1.0 / sqrt(x * x + y * y);\n\n        b[0] *= k;\n        b[1] *= k;\n        b[2] *= k;\n\n        a += filter->sect_ord + 1;\n        b += filter->sect_ord + 1;\n    }\n\n    for (i = 0; i < (n + 1) * 2; i += 1)\n        filter->d[i] = 0;\n}", "item_id": 12, "repo": "igorinov/biquad", "file": "biquad.c", "last_update_at": "2021-03-26T00:56:53+00:00", "question_id": "b538b99826394eb32a6f5bc27b0382779cc1eed7_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static void biquad_init_band(struct iir_filter *filter, double fs,\n    double f1, double f2, int stop)\n{\n    double ts = 1.0 / fs;\n    double bw, f;\n    double w;\n    complex_d p, q;\n    complex_d z, s;\n    double phi;\n    complex_d _z, p_lp, p_bp;\n    double k, x, y;\n    double wa1, wa2, wa;\n    double *a = filter->a;\n    double *b = filter->b;\n    int n, i;\n    f = sqrt(f1 * f2);\n    w = 2 * M_PI * f / fs;\n    /* Map to continuous-time frequencies (pre-warp) */\n    wa1 = 2 * fs * tan(M_PI * f1 * ts);\n    wa2 = 2 * fs * tan(M_PI * f2 * ts);\n    bw = wa2 - wa1;\n    wa = sqrt(wa1 * wa2);\n    n = filter->sections;\n    for (i = 0; i < n; i += 1) {\n        phi = M_PI / 2 + M_PI * (2 * i + 1) / (n * 2);\n        x = cos(phi);\n        y = sin(phi);\n        p_lp.re = x * bw / (wa * 2);\n        p_lp.im = y * bw / (wa * 2);\n        /*\n         *  Map every low-pass pole to a complex conjugate\n         *  pair of band-bass poles\n         */\n        s = p_lp;\n        complex_square(&s);\n        s.re = 1 - s.re;\n        s.im = 0 - s.im;\n        complex_sqrt(&s);\n        x = p_lp.re - s.im;\n        y = p_lp.im + s.re;\n        p_bp.re = x * wa;\n        p_bp.im = y * wa;\n        /*\n         *  Convert every pair from continuous (s)\n         *  to discrete (z) using bilinear transform\n         */\n        bilinear_transform(&z, &p_bp, ts);\n        x = z.re;\n        y = z.im;\n        /*\n         *  Find denominator coefficients from\n         *  the complex conjugate pair of poles\n         */\n        a[0] = 1;\n        a[1] = -2 * x;\n        a[2] = x * x + y * y;\n        if (stop) {\n            /* Band-stop: zeros at \u03c9 and ~\u03c9 */\n            s.re = 0;\n            s.im = wa;\n            bilinear_transform(&z, &s, ts);\n            x = z.re;\n            y = z.im;\n            b[0] = 1;\n            b[1] = -2 * x;\n            b[2] = x * x + y * y;\n        } else {\n            /* Band-pass: zeros at \u00b11 */\n            b[0] = 1;\n            b[1] = 0;\n            b[2] = -1;\n        }\n        /* Scale the parameters to get unity gain in the bassband */\n        if (stop) {\n            /* Band-stop: unity gain at zero frequency */\n            _z.re = 1;\n            _z.im = 0;\n        } else {\n            /* Band-pass: unity gain at \u03c9 */\n            _z.re = cos(w);\n            _z.im = -sin(w);\n        }\n        p.re = b[2];\n        p.im = 0;\n        complex_mul(&p, &_z);\n        p.re += b[1];\n        complex_mul(&p, &_z);\n        p.re += b[0];\n        q.re = a[2];\n        q.im = 0;\n        complex_mul(&q, &_z);\n        q.re += a[1];\n        complex_mul(&q, &_z);\n        q.re += 1;\n        complex_div(&p, &q);\n        x = p.re;\n        y = p.im;\n        k = 1.0 / sqrt(x * x + y * y);\n        b[0] *= k;\n        b[1] *= k;\n        b[2] *= k;\n        a += filter->sect_ord + 1;\n        b += filter->sect_ord + 1;\n    }\n    for (i = 0; i < (n + 1) * 2; i += 1)\n        filter->d[i] = 0;\n"]]}
{"hexsha": "3fd3bcc038bceef9b011769072333cc8288f75d7", "ext": "c", "lang": "C", "content": "void    ft_gui_int_label_scroll(t_tts_gui *env, t_gui_component *field)\n{\n    t_gui_int_label *data;\n    t_list_node     *current_node;\n\n    (void)env;\n    current_node = NULL;\n    data = field->data;\n    if (!(*data->sector))\n        *(data->sector) = data->env->data.sectors.first->content;\n    else\n    {\n        data->env->data.sectors.iterator = data->env->data.sectors.first;\n        while ((current_node = ttslist_iter(&(data->env->data.sectors))))\n        {\n            if (current_node->content == *(data->sector))\n                break;\n        }\n        if (current_node)\n        {\n            if (field->event.e.wheel.y > 0)\n            {\n                current_node = current_node->next;\n                if (!current_node)\n                    current_node = data->env->data.sectors.first;\n            }\n            else\n            {\n                current_node = current_node->prev;\n                if (!current_node)\n                    current_node = data->env->data.sectors.last;\n            }\n            if (current_node)\n                *(data->sector) = current_node->content;\n        }\n    }\n}", "item_id": 1, "repo": "KernelOverseer/KSICARDOOM", "file": "editor/sources/int_label_addon.c", "last_update_at": "2021-04-19T18:28:15+00:00", "question_id": "3fd3bcc038bceef9b011769072333cc8288f75d7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void    ft_gui_int_label_scroll(t_tts_gui *env, t_gui_component *field)\n{\n    t_gui_int_label *data;\n    t_list_node     *current_node;\n    (void)env;\n    current_node = NULL;\n    data = field->data;\n    if (!(*data->sector))\n        *(data->sector) = data->env->data.sectors.first->content;\n    else\n    {\n        data->env->data.sectors.iterator = data->env->data.sectors.first;\n        while ((current_node = ttslist_iter(&(data->env->data.sectors))))\n        {\n            if (current_node->content == *(data->sector))\n                break;\n        }\n        if (current_node)\n        {\n            if (field->event.e.wheel.y > 0)\n            {\n                current_node = current_node->next;\n                if (!current_node)\n                    current_node = data->env->data.sectors.first;\n            }\n            else\n            {\n                current_node = current_node->prev;\n                if (!current_node)\n                    current_node = data->env->data.sectors.last;\n            }\n            if (current_node)\n                *(data->sector) = current_node->content;\n        }\n    }\n"]]}
{"hexsha": "ed598a0f9ace4c24b6589715fc8aeea10d02e443", "ext": "c", "lang": "C", "content": "void f3(void) {\n    \tstatic volatile int16_t x17 = -1;\n\tuint32_t x18 = 66520U;\n\tstatic uint16_t x19 = 3118U;\n\tstatic volatile int8_t x20 = INT8_MIN;\n\n    t3 = ((x17<=x18)^(x19+x20));\n\n    if (t3 != 2990) { NG(); } else { ; }\n\t\n}", "item_id": 3, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test140.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "ed598a0f9ace4c24b6589715fc8aeea10d02e443_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f3(void) {\n    \tstatic volatile int16_t x17 = -1;\n\tuint32_t x18 = 66520U;\n\tstatic uint16_t x19 = 3118U;\n\tstatic volatile int8_t x20 = INT8_MIN;\n    t3 = ((x17<=x18)^(x19+x20));\n    if (t3 != 2990) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "8b053aa46ec881629c7ff8d559e3ae80279b6c0a", "ext": "c", "lang": "C", "content": "void f7(void) {\n    \tstatic uint8_t x33 = 3U;\n\tstatic uint32_t x35 = 18044967U;\n\tint32_t t7 = -924723;\n\n    t7 = ((x33-x34)==(x35*x36));\n\n    if (t7 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 7, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test414.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "8b053aa46ec881629c7ff8d559e3ae80279b6c0a_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f7(void) {\n    \tstatic uint8_t x33 = 3U;\n\tstatic uint32_t x35 = 18044967U;\n\tint32_t t7 = -924723;\n    t7 = ((x33-x34)==(x35*x36));\n    if (t7 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "43dfe59a94f19be2a2394af9d9293bc2a3fb6c4b", "ext": "c", "lang": "C", "content": "static int\n_sort_fonts(const void *data1, const void *data2)\n{\n   if (!data1) return 1;\n   if (!data2) return -1;\n   return e_util_strcmp(data1, data2);\n}", "item_id": 21, "repo": "Elive/enlightenment", "file": "src/modules/conf_theme/e_int_config_fonts.c", "last_update_at": "2021-03-23T17:10:52+00:00", "question_id": "43dfe59a94f19be2a2394af9d9293bc2a3fb6c4b_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int\n_sort_fonts(const void *data1, const void *data2)\n{\n   if (!data1) return 1;\n   if (!data2) return -1;\n   return e_util_strcmp(data1, data2);\n"]]}
{"hexsha": "34d017801f19ea9486a2cf694166a9ba6c762d04", "ext": "c", "lang": "C", "content": "void BitImgImgCmd(\r\n    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure\r\n    WORD           Width,                                   // dot\r\n    WORD           Height,                                  // dot\r\n    WORD           WidthByte,                               // byte\r\n    WORD           Rotation,                                // rotare(0fixed)\r\n    WORD           InvLeft,                                 // Invalid size from the left edge\r\n    WORD           InvRight,                                // Invalid size from the right edge\r\n    LPBYTE         lpBit                                    // Bitmap data\r\n)\r\n{\r\n    int            pam[10];\r\n    WORD           siz;\r\n    WORD           widByt;\r\n    WORD           linCnt;\r\n\r\n    if (InvLeft == 0 && InvRight == 0) {                    // There are no invalid size\r\n        pam[0] = WidthByte * Height;                        // Number of Data byte\r\n        pam[1] = Width;\r\n        pam[2] = Height;\r\n        pam[3] = Rotation;\r\n        siz = CmdStore(CmdBuf, &ImgDrw, pam);\r\n        WRITESPOOLBUF(pdevobj, CmdBuf, siz);\r\n        WRITESPOOLBUF(pdevobj, lpBit, pam[0]);\r\n    } else {                                                // There are invalid size\r\n        widByt = WidthByte - InvLeft - InvRight;            // Width byte\r\n        pam[0] = widByt * Height;\r\n        if (InvRight == 0) {                                // There are no invalid size from the right edge\r\n            pam[1] = Width - InvLeft * 8;                   // Width bit image\r\n        } else {\r\n            pam[1] = widByt * 8;                            // Width bit image\r\n        }\r\n        pam[2] = Height;                                    // Height bit image\r\n        pam[3] = Rotation;\r\n        siz = CmdStore(CmdBuf, &ImgDrw, pam);\r\n        WRITESPOOLBUF(pdevobj, CmdBuf, siz);\r\n        for (linCnt = 0; linCnt < Height; linCnt++) {       // Spool bitmap data by 1 line\r\n            lpBit += InvLeft;\r\n            WRITESPOOLBUF(pdevobj, lpBit, widByt);\r\n            lpBit += widByt;\r\n            lpBit += InvRight;\r\n        }\r\n    }\r\n    return;\r\n}", "item_id": 3, "repo": "npocmaka/Windows-Server-2003", "file": "printscan/print/drivers/usermode/gpdres/csn5res/prnctl.c", "last_update_at": "2021-09-16T09:13:13+00:00", "question_id": "34d017801f19ea9486a2cf694166a9ba6c762d04_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void BitImgImgCmd(\r\n    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure\r\n    WORD           Width,                                   // dot\r\n    WORD           Height,                                  // dot\r\n    WORD           WidthByte,                               // byte\r\n    WORD           Rotation,                                // rotare(0fixed)\r\n    WORD           InvLeft,                                 // Invalid size from the left edge\r\n    WORD           InvRight,                                // Invalid size from the right edge\r\n    LPBYTE         lpBit                                    // Bitmap data\r\n)\r\n{\r\n    int            pam[10];\r\n    WORD           siz;\r\n    WORD           widByt;\r\n    WORD           linCnt;\r\n\r\n    if (InvLeft == 0 && InvRight == 0) {                    // There are no invalid size\r\n        pam[0] = WidthByte * Height;                        // Number of Data byte\r\n        pam[1] = Width;\r\n        pam[2] = Height;\r\n        pam[3] = Rotation;\r\n        siz = CmdStore(CmdBuf, &ImgDrw, pam);\r\n        WRITESPOOLBUF(pdevobj, CmdBuf, siz);\r\n        WRITESPOOLBUF(pdevobj, lpBit, pam[0]);\r\n    } else {                                                // There are invalid size\r\n        widByt = WidthByte - InvLeft - InvRight;            // Width byte\r\n        pam[0] = widByt * Height;\r\n        if (InvRight == 0) {                                // There are no invalid size from the right edge\r\n            pam[1] = Width - InvLeft * 8;                   // Width bit image\r\n        } else {\r\n            pam[1] = widByt * 8;                            // Width bit image\r\n        }\r\n        pam[2] = Height;                                    // Height bit image\r\n        pam[3] = Rotation;\r\n        siz = CmdStore(CmdBuf, &ImgDrw, pam);\r\n        WRITESPOOLBUF(pdevobj, CmdBuf, siz);\r\n        for (linCnt = 0; linCnt < Height; linCnt++) {       // Spool bitmap data by 1 line\r\n            lpBit += InvLeft;\r\n            WRITESPOOLBUF(pdevobj, lpBit, widByt);\r\n            lpBit += widByt;\r\n            lpBit += InvRight;\r\n        }\r\n    }\r\n    return;\r\n"]]}
{"hexsha": "43c68f51c5ce07822b58b44de9efe7749e1c3cf9", "ext": "c", "lang": "C", "content": "int m5mols_enable_interrupt(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct m5mols_info *info = to_m5mols(sd);\n\tu8 mask = is_available_af(info) ? REG_INT_AF : 0;\n\tu8 dummy;\n\tint ret;\n\n\tret = m5mols_read_u8(sd, SYSTEM_INT_FACTOR, &dummy);\n\tif (!ret)\n\t\tret = m5mols_write(sd, SYSTEM_INT_ENABLE, reg & ~mask);\n\treturn ret;\n}", "item_id": 5, "repo": "tuxafgmur/OLD_Dhollmen_Kernel", "file": "drivers/media/video/m5mols/m5mols_core.c", "last_update_at": "2021-11-14T21:29:42+00:00", "question_id": "43c68f51c5ce07822b58b44de9efe7749e1c3cf9_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int m5mols_enable_interrupt(struct v4l2_subdev *sd, u8 reg)\n{\n\tstruct m5mols_info *info = to_m5mols(sd);\n\tu8 mask = is_available_af(info) ? REG_INT_AF : 0;\n\tu8 dummy;\n\tint ret;\n\tret = m5mols_read_u8(sd, SYSTEM_INT_FACTOR, &dummy);\n\tif (!ret)\n\t\tret = m5mols_write(sd, SYSTEM_INT_ENABLE, reg & ~mask);\n\treturn ret;\n"]]}
{"hexsha": "de7dfa2345c66832f12ffb289dd466db7a57b058", "ext": "c", "lang": "C", "content": "void f22(void) {\n    \tvolatile int16_t x90 = INT16_MIN;\n\tuint16_t x92 = 112U;\n\tint32_t t22 = 0;\n\n    t22 = ((x89/x90)>(x91==x92));\n\n    if (t22 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 22, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test1423.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "de7dfa2345c66832f12ffb289dd466db7a57b058_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f22(void) {\n    \tvolatile int16_t x90 = INT16_MIN;\n\tuint16_t x92 = 112U;\n\tint32_t t22 = 0;\n    t22 = ((x89/x90)>(x91==x92));\n    if (t22 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "0b77f1f02d285e0d05661bd3c096a8506569d09b", "ext": "c", "lang": "C", "content": "static int matchpattern(regex_t* pattern, const char* text, int* matchlength)\n{\n  int pre = *matchlength;\n  while (1)\n  {\n    if (pattern->type == UNUSED)\n    {\n      return 1;\n    }\n    regex_t* next_pattern = getnext(pattern);\n    if (next_pattern->type == QUESTIONMARK)\n    {\n      return matchquestion(pattern, getnext(next_pattern), text, matchlength);\n    }\n    else if (next_pattern->type == STAR)\n    {\n      return matchstar(pattern, getnext(next_pattern), text, matchlength);\n    }\n    else if (next_pattern->type == PLUS)\n    {\n      return matchplus(pattern, getnext(next_pattern), text, matchlength);\n    }\n    else if ((pattern->type == END) && next_pattern->type == UNUSED)\n    {\n      return (text[0] == '\\0');\n    }\n/*  Branching is not working properly\n    else if (pattern->type == BRANCH)\n    {\n      return (matchpattern(pattern, text) || matchpattern(getnext(next_pattern), text));\n    }\n*/\n  (*matchlength)++;\n    if (text[0] == '\\0')\n      break;\n    if (!matchone(pattern, *text++))\n      break;\n    pattern = next_pattern;\n  }\n\n  *matchlength = pre;\n  return 0;\n}", "item_id": 6, "repo": "dgcor/Columns", "file": "DGEngine.core/src/Utils/re.c", "last_update_at": "2021-04-19T12:41:43+00:00", "question_id": "0b77f1f02d285e0d05661bd3c096a8506569d09b_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int matchpattern(regex_t* pattern, const char* text, int* matchlength)\n{\n  int pre = *matchlength;\n  while (1)\n  {\n    if (pattern->type == UNUSED)\n    {\n      return 1;\n    }\n    regex_t* next_pattern = getnext(pattern);\n    if (next_pattern->type == QUESTIONMARK)\n    {\n      return matchquestion(pattern, getnext(next_pattern), text, matchlength);\n    }\n    else if (next_pattern->type == STAR)\n    {\n      return matchstar(pattern, getnext(next_pattern), text, matchlength);\n    }\n    else if (next_pattern->type == PLUS)\n    {\n      return matchplus(pattern, getnext(next_pattern), text, matchlength);\n    }\n    else if ((pattern->type == END) && next_pattern->type == UNUSED)\n    {\n      return (text[0] == '\\0');\n    }\n/*  Branching is not working properly\n    else if (pattern->type == BRANCH)\n    {\n      return (matchpattern(pattern, text) || matchpattern(getnext(next_pattern), text));\n    }\n*/\n  (*matchlength)++;\n    if (text[0] == '\\0')\n      break;\n    if (!matchone(pattern, *text++))\n      break;\n    pattern = next_pattern;\n  }\n  *matchlength = pre;\n  return 0;\n"]]}
{"hexsha": "ea4eb5b6bf6cab9078b7828a55cede351bb4c19c", "ext": "c", "lang": "C", "content": "NTSTATUS\r\nIsoUsb_IsoIrp_Complete(\r\n    IN PDEVICE_OBJECT DeviceObject,\r\n    IN PIRP           Irp,\r\n    IN PVOID          Context\r\n    )\r\n/*++\r\n \r\nRoutine Description:\r\n\r\n    This is the completion routine of the irp in the irp/urb pair\r\n    passed down the stack for stream transfers.\r\n\r\n    If the transfer was cancelled or the device yanked out, then we\r\n    release resources, dump the statistics and return \r\n    STATUS_MORE_PROCESSING_REQUIRED, so that the cleanup module can\r\n    free the irp.\r\n\r\n    otherwise, we reinitialize the transfers and continue recirculaiton \r\n    of the irps.\r\n\r\nArguments:\r\n\r\n    DeviceObject - pointer to device object below us.\r\n    Irp - I/O completion routine.\r\n    Context - context passed to the completion routine\r\n\r\nReturn Value:\r\n\r\n--*/\r\n{\r\n    NTSTATUS                ntStatus;\r\n    PDEVICE_OBJECT          deviceObject;\r\n    PDEVICE_EXTENSION       deviceExtension;\r\n    PIO_STACK_LOCATION      nextStack;\r\n    PISOUSB_STREAM_OBJECT   streamObject;\r\n    PISOUSB_TRANSFER_OBJECT transferObject;\r\n\r\n    transferObject = (PISOUSB_TRANSFER_OBJECT) Context;\r\n    streamObject = transferObject->StreamObject;\r\n    deviceObject = streamObject->DeviceObject;\r\n    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;\r\n\r\n    IsoUsb_DbgPrint(3, (\"IsoUsb_IsoIrp_Complete - begins\\n\"));\r\n\r\n    ntStatus = IsoUsb_ProcessTransfer(transferObject);\r\n\r\n    if((ntStatus == STATUS_CANCELLED) ||\r\n       (ntStatus == STATUS_DEVICE_NOT_CONNECTED)) {\r\n    \r\n        IsoUsb_DbgPrint(3, (\"Isoch irp cancelled/device removed\\n\"));\r\n\r\n        //\r\n        // this is the last irp to complete with this erroneous value\r\n        // signal an event and return STATUS_MORE_PROCESSING_REQUIRED\r\n        //\r\n        if(InterlockedDecrement(&streamObject->PendingIrps) == 0) {\r\n\r\n            KeSetEvent(&streamObject->NoPendingIrpEvent,\r\n                       1,\r\n                       FALSE);\r\n\r\n            IsoUsb_DbgPrint(3, (\"-----------------------------\\n\"));\r\n        }\r\n\r\n        IsoUsb_DbgPrint(3, (\"IsoUsb_IsoIrp_Complete::\"));\r\n        IsoUsb_IoDecrement(deviceExtension);\r\n\r\n        transferObject->Irp = NULL;\r\n        IoFreeIrp(Irp);\r\n\r\n        return STATUS_MORE_PROCESSING_REQUIRED;\r\n    }\r\n\r\n    //\r\n    // otherwise circulate the irps.\r\n    //\r\n\r\n    IsoUsb_InitializeStreamUrb(deviceObject, transferObject);\r\n\r\n    nextStack = IoGetNextIrpStackLocation(Irp);\r\n    nextStack->Parameters.Others.Argument1 = transferObject->Urb;\r\n    nextStack->Parameters.DeviceIoControl.IoControlCode = \r\n                                                IOCTL_INTERNAL_USB_SUBMIT_URB;\r\n    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;\r\n\r\n    IoSetCompletionRoutine(Irp,\r\n                           IsoUsb_IsoIrp_Complete,\r\n                           transferObject,\r\n                           TRUE,\r\n                           TRUE,\r\n                           TRUE);\r\n\r\n    transferObject->TimesRecycled++;\r\n\r\n    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,\r\n                            Irp);\r\n\r\n    IsoUsb_DbgPrint(3, (\"IsoUsb_IsoIrp_Complete - ends\\n\"));\r\n    IsoUsb_DbgPrint(3, (\"-----------------------------\\n\"));\r\n\r\n    return STATUS_MORE_PROCESSING_REQUIRED;\r\n}", "item_id": 3, "repo": "npocmaka/Windows-Server-2003", "file": "drivers/wdm/usb/driver/isousb/sys/isostrm.c", "last_update_at": "2021-09-16T09:13:13+00:00", "question_id": "ea4eb5b6bf6cab9078b7828a55cede351bb4c19c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["NTSTATUS\r\nIsoUsb_IsoIrp_Complete(\r\n    IN PDEVICE_OBJECT DeviceObject,\r\n    IN PIRP           Irp,\r\n    IN PVOID          Context\r\n    )\r\n/*++\r\n \r\nRoutine Description:\r\n\r\n    This is the completion routine of the irp in the irp/urb pair\r\n    passed down the stack for stream transfers.\r\n\r\n    If the transfer was cancelled or the device yanked out, then we\r\n    release resources, dump the statistics and return \r\n    STATUS_MORE_PROCESSING_REQUIRED, so that the cleanup module can\r\n    free the irp.\r\n\r\n    otherwise, we reinitialize the transfers and continue recirculaiton \r\n    of the irps.\r\n\r\nArguments:\r\n\r\n    DeviceObject - pointer to device object below us.\r\n    Irp - I/O completion routine.\r\n    Context - context passed to the completion routine\r\n\r\nReturn Value:\r\n\r\n--*/\r\n{\r\n    NTSTATUS                ntStatus;\r\n    PDEVICE_OBJECT          deviceObject;\r\n    PDEVICE_EXTENSION       deviceExtension;\r\n    PIO_STACK_LOCATION      nextStack;\r\n    PISOUSB_STREAM_OBJECT   streamObject;\r\n    PISOUSB_TRANSFER_OBJECT transferObject;\r\n\r\n    transferObject = (PISOUSB_TRANSFER_OBJECT) Context;\r\n    streamObject = transferObject->StreamObject;\r\n    deviceObject = streamObject->DeviceObject;\r\n    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;\r\n\r\n    IsoUsb_DbgPrint(3, (\"IsoUsb_IsoIrp_Complete - begins\\n\"));\r\n\r\n    ntStatus = IsoUsb_ProcessTransfer(transferObject);\r\n\r\n    if((ntStatus == STATUS_CANCELLED) ||\r\n       (ntStatus == STATUS_DEVICE_NOT_CONNECTED)) {\r\n    \r\n        IsoUsb_DbgPrint(3, (\"Isoch irp cancelled/device removed\\n\"));\r\n\r\n        //\r\n        // this is the last irp to complete with this erroneous value\r\n        // signal an event and return STATUS_MORE_PROCESSING_REQUIRED\r\n        //\r\n        if(InterlockedDecrement(&streamObject->PendingIrps) == 0) {\r\n\r\n            KeSetEvent(&streamObject->NoPendingIrpEvent,\r\n                       1,\r\n                       FALSE);\r\n\r\n            IsoUsb_DbgPrint(3, (\"-----------------------------\\n\"));\r\n        }\r\n\r\n        IsoUsb_DbgPrint(3, (\"IsoUsb_IsoIrp_Complete::\"));\r\n        IsoUsb_IoDecrement(deviceExtension);\r\n\r\n        transferObject->Irp = NULL;\r\n        IoFreeIrp(Irp);\r\n\r\n        return STATUS_MORE_PROCESSING_REQUIRED;\r\n    }\r\n\r\n    //\r\n    // otherwise circulate the irps.\r\n    //\r\n\r\n    IsoUsb_InitializeStreamUrb(deviceObject, transferObject);\r\n\r\n    nextStack = IoGetNextIrpStackLocation(Irp);\r\n    nextStack->Parameters.Others.Argument1 = transferObject->Urb;\r\n    nextStack->Parameters.DeviceIoControl.IoControlCode = \r\n                                                IOCTL_INTERNAL_USB_SUBMIT_URB;\r\n    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;\r\n\r\n    IoSetCompletionRoutine(Irp,\r\n                           IsoUsb_IsoIrp_Complete,\r\n                           transferObject,\r\n                           TRUE,\r\n                           TRUE,\r\n                           TRUE);\r\n\r\n    transferObject->TimesRecycled++;\r\n\r\n    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,\r\n                            Irp);\r\n\r\n    IsoUsb_DbgPrint(3, (\"IsoUsb_IsoIrp_Complete - ends\\n\"));\r\n    IsoUsb_DbgPrint(3, (\"-----------------------------\\n\"));\r\n\r\n    return STATUS_MORE_PROCESSING_REQUIRED;\r\n"]]}
{"hexsha": "7b4c618cc4311ae6150fe898dc911af42a3c927b", "ext": "h", "lang": "C", "content": "int FindItemByPoint(int x, int y)\n    {\n      int l=GetCount();\n      for(int i=0;i<l;i++)\n      {\n        RECT r;\n        GetItemRect(i, &r);\n        if(r.left<=x && r.right>=x && r.top<=y && r.bottom>=y) return i;\n      }\n      return -1;\n    }", "item_id": 1, "repo": "noahwilliamsson/openspotify", "file": "examples/winamp/ml_openspotify/listview.h", "last_update_at": "2021-01-09T18:14:54+00:00", "question_id": "7b4c618cc4311ae6150fe898dc911af42a3c927b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int FindItemByPoint(int x, int y)\n    {\n      int l=GetCount();\n      for(int i=0;i<l;i++)\n      {\n        RECT r;\n        GetItemRect(i, &r);\n        if(r.left<=x && r.right>=x && r.top<=y && r.bottom>=y) return i;\n      }\n      return -1;\n"]]}
{"hexsha": "a2aaeb7673f00d864e86619408f93e036da9d8f7", "ext": "c", "lang": "C", "content": "int\n__wt_update_alloc(WT_SESSION_IMPL *session, const WT_ITEM *value,\n    WT_UPDATE **updp, size_t *sizep, u_int modify_type)\n{\n\tWT_UPDATE *upd;\n\n\t*updp = NULL;\n\n\t/*\n\t * The code paths leading here are convoluted: assert we never attempt\n\t * to allocate an update structure if only intending to insert one we\n\t * already have.\n\t */\n\tWT_ASSERT(session, modify_type != WT_UPDATE_INVALID);\n\n\t/*\n\t * Allocate the WT_UPDATE structure and room for the value, then copy\n\t * the value into place.\n\t */\n\tif (modify_type == WT_UPDATE_DELETED ||\n\t    modify_type == WT_UPDATE_RESERVED)\n\t\tWT_RET(__wt_calloc(session, 1, WT_UPDATE_SIZE, &upd));\n\telse {\n\t\tWT_RET(__wt_calloc(\n\t\t    session, 1, WT_UPDATE_SIZE + value->size, &upd));\n\t\tif (value->size != 0) {\n\t\t\tupd->size = WT_STORE_SIZE(value->size);\n\t\t\tmemcpy(upd->data, value->data, value->size);\n\t\t}\n\t}\n\tupd->type = (uint8_t)modify_type;\n\n\t*updp = upd;\n\t*sizep = WT_UPDATE_MEMSIZE(upd);\n\treturn (0);\n}", "item_id": 3, "repo": "coutamg/mongodb", "file": "mongo/src/third_party/wiredtiger/src/btree/row_modify.c", "last_update_at": "2021-06-02T05:13:29+00:00", "question_id": "a2aaeb7673f00d864e86619408f93e036da9d8f7_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["int\n__wt_update_alloc(WT_SESSION_IMPL *session, const WT_ITEM *value,\n    WT_UPDATE **updp, size_t *sizep, u_int modify_type)\n{\n\tWT_UPDATE *upd;\n\t*updp = NULL;\n\t/*\n\t * The code paths leading here are convoluted: assert we never attempt\n\t * to allocate an update structure if only intending to insert one we\n\t * already have.\n\t */\n\tWT_ASSERT(session, modify_type != WT_UPDATE_INVALID);\n\t/*\n\t * Allocate the WT_UPDATE structure and room for the value, then copy\n\t * the value into place.\n\t */\n\tif (modify_type == WT_UPDATE_DELETED ||\n\t    modify_type == WT_UPDATE_RESERVED)\n\t\tWT_RET(__wt_calloc(session, 1, WT_UPDATE_SIZE, &upd));\n\telse {\n\t\tWT_RET(__wt_calloc(\n\t\t    session, 1, WT_UPDATE_SIZE + value->size, &upd));\n\t\tif (value->size != 0) {\n\t\t\tupd->size = WT_STORE_SIZE(value->size);\n\t\t\tmemcpy(upd->data, value->data, value->size);\n\t\t}\n\t}\n\tupd->type = (uint8_t)modify_type;\n\t*updp = upd;\n\t*sizep = WT_UPDATE_MEMSIZE(upd);\n\treturn (0);\n"]]}
{"hexsha": "000092fdf96263dc7cfeeef26d2c66e14e763a47", "ext": "c", "lang": "C", "content": "bool\nsb_iscoreup(void *sbh)\n{\n\tsb_info_t *si;\n\tsbconfig_t *sb;\n\n\tsi = SB_INFO(sbh);\n\tsb = REGS2SB(si->curmap);\n\n\treturn ((R_SBREG(sbh, &(sb)->sbtmstatelow) & (SBTML_RESET | SBTML_REJ | SBTML_CLK)) == SBTML_CLK);\n}", "item_id": 13, "repo": "enfoTek/tomato.linksys.e2000.nvram-mod", "file": "release/src/shared/sbutils.c", "last_update_at": "2021-06-07T06:29:49+00:00", "question_id": "000092fdf96263dc7cfeeef26d2c66e14e763a47_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["bool\nsb_iscoreup(void *sbh)\n{\n\tsb_info_t *si;\n\tsbconfig_t *sb;\n\tsi = SB_INFO(sbh);\n\tsb = REGS2SB(si->curmap);\n\treturn ((R_SBREG(sbh, &(sb)->sbtmstatelow) & (SBTML_RESET | SBTML_REJ | SBTML_CLK)) == SBTML_CLK);\n"]]}
{"hexsha": "83cf860a92ffa3454a3d1708425f3a6dd77b570c", "ext": "c", "lang": "C", "content": "void f183(void) {\n    \tint16_t x734 = -1;\n\tstatic volatile uint64_t x736 = 0LLU;\n\tuint64_t t183 = 14794848565LLU;\n\n    t183 = ((x733*(x734==x735))^x736);\n\n    if (t183 != 0LLU) { NG(); } else { ; }\n\t\n}", "item_id": 183, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_2/test1414.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "83cf860a92ffa3454a3d1708425f3a6dd77b570c_183", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f183(void) {\n    \tint16_t x734 = -1;\n\tstatic volatile uint64_t x736 = 0LLU;\n\tuint64_t t183 = 14794848565LLU;\n    t183 = ((x733*(x734==x735))^x736);\n    if (t183 != 0LLU) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "4c48e218be9ae138578e33a693d6a92a2dbd68f4", "ext": "c", "lang": "C", "content": "void f94(void) {\n    \tuint16_t x485 = 3U;\n\tint16_t x487 = -1;\n\tuint32_t x488 = 9430U;\n\n    t94 = ((x485==x486)!=(x487*x488));\n\n    if (t94 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 94, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test497.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "4c48e218be9ae138578e33a693d6a92a2dbd68f4_94", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f94(void) {\n    \tuint16_t x485 = 3U;\n\tint16_t x487 = -1;\n\tuint32_t x488 = 9430U;\n    t94 = ((x485==x486)!=(x487*x488));\n    if (t94 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "60f2f7b00a203593b4cd14e90f7d837e2e987230", "ext": "c", "lang": "C", "content": "SWIGSTDCALL\n  Ada_xcb_glx_get_tex_level_parameteriv_unchecked (void *jarg1,\n\n                                                   uint32_t jarg2,\n\n                                                   uint32_t jarg3,\n\n                                                   int32_t jarg4,\n\n                                                   uint32_t jarg5)\n  {\n    xcb_glx_get_tex_level_parameteriv_cookie_t jresult;\n    xcb_connection_t *arg1 = (xcb_connection_t *)0;\n    xcb_glx_context_tag_t arg2;\n    uint32_t arg3;\n    int32_t arg4;\n    uint32_t arg5;\n    xcb_glx_get_tex_level_parameteriv_cookie_t result;\n\n    arg1 = (xcb_connection_t *)jarg1;\n\n    arg2 = (xcb_glx_context_tag_t)jarg2;\n\n    arg3 = (uint32_t)jarg3;\n\n    arg4 = (int32_t)jarg4;\n\n    arg5 = (uint32_t)jarg5;\n\n    result = xcb_glx_get_tex_level_parameteriv_unchecked (arg1, arg2, arg3,\n                                                          arg4, arg5);\n    {\n      jresult = result;\n    }\n\n    return jresult;\n  }", "item_id": 1323, "repo": "charlie5/cBound", "file": "tier-1/xcb/source/thin/xcb_wrap.c", "last_update_at": "2021-08-24T22:32:04+00:00", "question_id": "60f2f7b00a203593b4cd14e90f7d837e2e987230_1323", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["SWIGSTDCALL\n  Ada_xcb_glx_get_tex_level_parameteriv_unchecked (void *jarg1,\n                                                   uint32_t jarg2,\n                                                   uint32_t jarg3,\n                                                   int32_t jarg4,\n                                                   uint32_t jarg5)\n  {\n    xcb_glx_get_tex_level_parameteriv_cookie_t jresult;\n    xcb_connection_t *arg1 = (xcb_connection_t *)0;\n    xcb_glx_context_tag_t arg2;\n    uint32_t arg3;\n    int32_t arg4;\n    uint32_t arg5;\n    xcb_glx_get_tex_level_parameteriv_cookie_t result;\n    arg1 = (xcb_connection_t *)jarg1;\n    arg2 = (xcb_glx_context_tag_t)jarg2;\n    arg3 = (uint32_t)jarg3;\n    arg4 = (int32_t)jarg4;\n    arg5 = (uint32_t)jarg5;\n    result = xcb_glx_get_tex_level_parameteriv_unchecked (arg1, arg2, arg3,\n                                                          arg4, arg5);\n    {\n      jresult = result;\n    }\n    return jresult;\n"]]}
{"hexsha": "0dd11fb7c8d89b09a4748e94a8dac2496fb1f17b", "ext": "c", "lang": "C", "content": "u_int64_t\thash_sdbm(const char *str)\n{\n\tu_int64_t\t\thash;\n\tu_int32_t\t\tc;\n\n\thash = 0;\n\twhile ((c = (u_int32_t)(*str++)))\n\t\thash = c + (hash << 6) + (hash << 16) - hash;\n\treturn (hash);\n}", "item_id": 0, "repo": "Hoommus/42-shell", "file": "src/string_hash.c", "last_update_at": "2021-12-12T15:04:41+00:00", "question_id": "0dd11fb7c8d89b09a4748e94a8dac2496fb1f17b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["u_int64_t\thash_sdbm(const char *str)\n{\n\tu_int64_t\t\thash;\n\tu_int32_t\t\tc;\n\thash = 0;\n\twhile ((c = (u_int32_t)(*str++)))\n\t\thash = c + (hash << 6) + (hash << 16) - hash;\n\treturn (hash);\n"]]}
{"hexsha": "ebb5cd8b6969f6bd409b7aeab708a61d3c0b4938", "ext": "h", "lang": "C", "content": "static inline void e2fs_lock(void) {\n  x_mutex_lock(mutex_e2fs_lock, x_eternal);\n  if(e2fs_lock_thread != x_thread_current()) {\n    x_mutex_unlock(mutex_e2fs_lock);\n    x_mutex_lock(mutex_e2fs, x_eternal);\n    x_mutex_lock(mutex_e2fs_lock, x_eternal);\n    e2fs_lock_thread = x_thread_current();\n  } \n  e2fs_lock_count++;\n  x_mutex_unlock(mutex_e2fs_lock);\n}", "item_id": 0, "repo": "kifferltd/open-mika", "file": "vm-cmp/fs/vfs.save/include/e2fs.h", "last_update_at": "2021-11-28T20:18:59+00:00", "question_id": "ebb5cd8b6969f6bd409b7aeab708a61d3c0b4938_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static inline void e2fs_lock(void) {\n  x_mutex_lock(mutex_e2fs_lock, x_eternal);\n  if(e2fs_lock_thread != x_thread_current()) {\n    x_mutex_unlock(mutex_e2fs_lock);\n    x_mutex_lock(mutex_e2fs, x_eternal);\n    x_mutex_lock(mutex_e2fs_lock, x_eternal);\n    e2fs_lock_thread = x_thread_current();\n  } \n  e2fs_lock_count++;\n  x_mutex_unlock(mutex_e2fs_lock);\n"]]}
{"hexsha": "a9bea9522cdf221002ff056494da01bb2ad4aa22", "ext": "c", "lang": "C", "content": "struct dentry *msm_vidc_debugfs_init_inst(struct msm_vidc_inst *inst,\n\t\tstruct dentry *parent)\n{\n\tstruct dentry *dir = NULL, *info = NULL;\n\tchar debugfs_name[MAX_DEBUGFS_NAME];\n\tstruct core_inst_pair *idata = NULL;\n\n\tif (!inst) {\n\t\tdprintk(VIDC_ERR, \"Invalid params, inst: %pK\\n\", inst);\n\t\tgoto exit;\n\t}\n\tsnprintf(debugfs_name, MAX_DEBUGFS_NAME, \"inst_%p\", inst);\n\n\tidata = kzalloc(sizeof(struct core_inst_pair), GFP_KERNEL);\n\tif (!idata) {\n\t\tdprintk(VIDC_ERR, \"%s: Allocation failed!\\n\", __func__);\n\t\tgoto exit;\n\t}\n\n\tidata->core = inst->core;\n\tidata->inst = inst;\n\n\tdir = debugfs_create_dir(debugfs_name, parent);\n\tif (!dir) {\n\t\tdprintk(VIDC_ERR, \"Failed to create debugfs for msm_vidc\\n\");\n\t\tgoto failed_create_dir;\n\t}\n\n\tinfo = debugfs_create_file(\"info\", 0444, dir,\n\t\t\tidata, &inst_info_fops);\n\tif (!info) {\n\t\tdprintk(VIDC_ERR, \"debugfs_create_file: fail\\n\");\n\t\tgoto failed_create_file;\n\t}\n\n\tdir->d_inode->i_private = info->d_inode->i_private;\n\tinst->debug.pdata[FRAME_PROCESSING].sampling = true;\n\treturn dir;\n\nfailed_create_file:\n\tdebugfs_remove_recursive(dir);\n\tdir = NULL;\nfailed_create_dir:\n\tkfree(idata);\nexit:\n\treturn dir;\n}", "item_id": 9, "repo": "clovadevice/clockplus2", "file": "kernel/msm-4.14/drivers/media/platform/msm/vidc/msm_vidc_debug.c", "last_update_at": "2021-06-29T01:29:23+00:00", "question_id": "a9bea9522cdf221002ff056494da01bb2ad4aa22_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["struct dentry *msm_vidc_debugfs_init_inst(struct msm_vidc_inst *inst,\n\t\tstruct dentry *parent)\n{\n\tstruct dentry *dir = NULL, *info = NULL;\n\tchar debugfs_name[MAX_DEBUGFS_NAME];\n\tstruct core_inst_pair *idata = NULL;\n\tif (!inst) {\n\t\tdprintk(VIDC_ERR, \"Invalid params, inst: %pK\\n\", inst);\n\t\tgoto exit;\n\t}\n\tsnprintf(debugfs_name, MAX_DEBUGFS_NAME, \"inst_%p\", inst);\n\tidata = kzalloc(sizeof(struct core_inst_pair), GFP_KERNEL);\n\tif (!idata) {\n\t\tdprintk(VIDC_ERR, \"%s: Allocation failed!\\n\", __func__);\n\t\tgoto exit;\n\t}\n\tidata->core = inst->core;\n\tidata->inst = inst;\n\tdir = debugfs_create_dir(debugfs_name, parent);\n\tif (!dir) {\n\t\tdprintk(VIDC_ERR, \"Failed to create debugfs for msm_vidc\\n\");\n\t\tgoto failed_create_dir;\n\t}\n\tinfo = debugfs_create_file(\"info\", 0444, dir,\n\t\t\tidata, &inst_info_fops);\n\tif (!info) {\n\t\tdprintk(VIDC_ERR, \"debugfs_create_file: fail\\n\");\n\t\tgoto failed_create_file;\n\t}\n\tdir->d_inode->i_private = info->d_inode->i_private;\n\tinst->debug.pdata[FRAME_PROCESSING].sampling = true;\n\treturn dir;\nfailed_create_file:\n\tdebugfs_remove_recursive(dir);\n\tdir = NULL;\nfailed_create_dir:\n\tkfree(idata);\nexit:\n\treturn dir;\n"]]}
{"hexsha": "2b591f1cc2fd7198794e3c11d60d3473d6d72ff1", "ext": "c", "lang": "C", "content": "void f185(void) {\n    \tuint32_t x1325 = 68U;\n\tint16_t x1326 = 39;\n\tstatic int8_t x1327 = INT8_MIN;\n\tuint32_t x1328 = UINT32_MAX;\n\tvolatile int32_t t185 = -1;\n\n    t185 = (x1325<=(x1326>>(x1327!=x1328)));\n\n    if (t185 != 0) { NG(); } else { ; }\n\t\n}", "item_id": 185, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test1326.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "2b591f1cc2fd7198794e3c11d60d3473d6d72ff1_185", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f185(void) {\n    \tuint32_t x1325 = 68U;\n\tint16_t x1326 = 39;\n\tstatic int8_t x1327 = INT8_MIN;\n\tuint32_t x1328 = UINT32_MAX;\n\tvolatile int32_t t185 = -1;\n    t185 = (x1325<=(x1326>>(x1327!=x1328)));\n    if (t185 != 0) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "3015d5b618cbe8ef0eaefd0ca6d542abeb73b70c", "ext": "c", "lang": "C", "content": "void f189(void) {\n    \tint8_t x1565 = INT8_MAX;\n\tvolatile int8_t x1567 = INT8_MIN;\n\tstatic int8_t x1568 = -1;\n\tint32_t t189 = -106873853;\n\n    t189 = (x1565%(x1566*(x1567*x1568)));\n\n    if (t189 != 127) { NG(); } else { ; }\n\t\n}", "item_id": 189, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test425.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "3015d5b618cbe8ef0eaefd0ca6d542abeb73b70c_189", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f189(void) {\n    \tint8_t x1565 = INT8_MAX;\n\tvolatile int8_t x1567 = INT8_MIN;\n\tstatic int8_t x1568 = -1;\n\tint32_t t189 = -106873853;\n    t189 = (x1565%(x1566*(x1567*x1568)));\n    if (t189 != 127) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "19f503e3b8a36c1bad4d3337128dad3a18074946", "ext": "c", "lang": "C", "content": "void f26(void) {\n    \tstatic uint8_t x710 = UINT8_MAX;\n\tvolatile uint32_t t26 = 1539U;\n\n    t26 = (((x709==x710)>>x711)-x712);\n\n    if (t26 != 4294967127U) { NG(); } else { ; }\n\t\n}", "item_id": 26, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_1/test1514.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "19f503e3b8a36c1bad4d3337128dad3a18074946_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f26(void) {\n    \tstatic uint8_t x710 = UINT8_MAX;\n\tvolatile uint32_t t26 = 1539U;\n    t26 = (((x709==x710)>>x711)-x712);\n    if (t26 != 4294967127U) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "4c7aef6500104da44c4134a5b978b082b2f0450d", "ext": "c", "lang": "C", "content": "void f27(void) {\n    \tuint64_t x137 = 1008318355LLU;\n\tint32_t x138 = INT32_MIN;\n\tvolatile uint16_t x140 = 14973U;\n\tvolatile int32_t t27 = 7169;\n\n    t27 = ((x137%x138)>(x139+x140));\n\n    if (t27 != 1) { NG(); } else { ; }\n\t\n}", "item_id": 27, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_3/test65.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "4c7aef6500104da44c4134a5b978b082b2f0450d_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f27(void) {\n    \tuint64_t x137 = 1008318355LLU;\n\tint32_t x138 = INT32_MIN;\n\tvolatile uint16_t x140 = 14973U;\n\tvolatile int32_t t27 = 7169;\n    t27 = ((x137%x138)>(x139+x140));\n    if (t27 != 1) { NG(); } else { ; }\n\t\n"]]}
{"hexsha": "ecf0d208ddc4b0234ec844d2720779ca2f143e93", "ext": "c", "lang": "C", "content": "uint32_t* xnu_pf_imm64_load_emit(uint32_t* insn_stream, uint8_t reg, uint64_t value) {\n\n    *insn_stream++ = ((0x6940000 | (value & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));\n\n    if ((value >> 16) & 0xFFFF) {\n        *insn_stream++ = ((0x7950000 | ((value >> 16) & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));\n    }\n    if ((value >> 32) & 0xFFFF) {\n        *insn_stream++ = ((0x7960000 | ((value >> 32) & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));\n    }\n    if ((value >> 48) & 0xFFFF) {\n        *insn_stream++ = ((0x7970000 | ((value >> 48) & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));\n    }\n\n    return insn_stream;\n}", "item_id": 29, "repo": "geekwish/pongoOS", "file": "src/drivers/xnu/xnu.c", "last_update_at": "2021-11-05T04:45:23+00:00", "question_id": "ecf0d208ddc4b0234ec844d2720779ca2f143e93_29", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["uint32_t* xnu_pf_imm64_load_emit(uint32_t* insn_stream, uint8_t reg, uint64_t value) {\n    *insn_stream++ = ((0x6940000 | (value & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));\n    if ((value >> 16) & 0xFFFF) {\n        *insn_stream++ = ((0x7950000 | ((value >> 16) & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));\n    }\n    if ((value >> 32) & 0xFFFF) {\n        *insn_stream++ = ((0x7960000 | ((value >> 32) & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));\n    }\n    if ((value >> 48) & 0xFFFF) {\n        *insn_stream++ = ((0x7970000 | ((value >> 48) & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));\n    }\n    return insn_stream;\n"]]}
{"hexsha": "3f84796cc15b02e394117d9e739887488ed4300b", "ext": "c", "lang": "C", "content": "static int l_graphics_gcShader(lua_State* state) {\n  l_graphics_Shader *shader = l_graphics_toShader(state, 1);\n  free(shader->referencedTextures);\n\n  // Unref textures to allow gc'ing them\n  for(int i = 0; i < shader->shader.textureUnitCount; ++i) {\n    luaL_unref(state, LUA_REGISTRYINDEX, shader->referencedTextures[i]);\n  }\n  \n  graphics_Shader_free(&shader->shader);\n  return 0;\n}", "item_id": 1, "repo": "ifzz/Love", "file": "src/luaapi/graphics_shader.c", "last_update_at": "2021-11-14T20:26:32+00:00", "question_id": "3f84796cc15b02e394117d9e739887488ed4300b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["static int l_graphics_gcShader(lua_State* state) {\n  l_graphics_Shader *shader = l_graphics_toShader(state, 1);\n  free(shader->referencedTextures);\n  // Unref textures to allow gc'ing them\n  for(int i = 0; i < shader->shader.textureUnitCount; ++i) {\n    luaL_unref(state, LUA_REGISTRYINDEX, shader->referencedTextures[i]);\n  }\n  graphics_Shader_free(&shader->shader);\n  return 0;\n"]]}
{"hexsha": "e06e1fcbc1de7c2ec1e14ac9875056f668698c74", "ext": "c", "lang": "C", "content": "void f166(void) {\n    \tuint16_t x765 = 449U;\n\tint16_t x766 = INT16_MIN;\n\tuint64_t x767 = 121163371584LLU;\n\tint8_t x768 = INT8_MIN;\n\tvolatile int32_t t166 = 17917;\n\n    t166 = (x765-(x766+(x767>x768)));\n\n    if (t166 != 33217) { NG(); } else { ; }\n\t\n}", "item_id": 166, "repo": "ishiura-compiler/CF3", "file": "testsuite/EXP_4/test1570.c", "last_update_at": "2021-04-22T21:04:43+00:00", "question_id": "e06e1fcbc1de7c2ec1e14ac9875056f668698c74_166", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["void f166(void) {\n    \tuint16_t x765 = 449U;\n\tint16_t x766 = INT16_MIN;\n\tuint64_t x767 = 121163371584LLU;\n\tint8_t x768 = INT8_MIN;\n\tvolatile int32_t t166 = 17917;\n    t166 = (x765-(x766+(x767>x768)));\n    if (t166 != 33217) { NG(); } else { ; }\n\t\n"]]}
