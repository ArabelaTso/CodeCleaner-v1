{"hexsha": "6b05a737ab80d77ea0ef4de1fc466367d251d8c4", "ext": "rs", "lang": "Rust", "content": "fn make_moon(day: f64, earth_coords: &Array3d) -> PlanetPS {\n    let solar_trait = Solarobj::Moon {\n        attr: Some(SolarAttr {\n            radius: 1.7381e6,\n            mass: 0.07346e24,\n        }),\n    };\n\n    let mut moon_body = PlanetPS {\n        solartype: solar_trait,\n        coords: SolarobjCoords::default(),\n        velocity: Array3d::default(), // Zero until sim update\n        n0: 125.1228,\n        nc: -0.0529538083,\n        i0: 5.1454,\n        ic: 0.0,\n        w0: 318.0634,\n        wc: 0.1643573223,\n        a0: 60.2666 / EARTH_RADII_PER_ASTRONOMICAL_UNIT,\n        ac: 0.0,\n        e0: 0.054900,\n        ec: 0.0,\n        m0: 115.3654,\n        mc: 13.0649929509,\n        mag_base: 0.23,\n        mag_phase_factor: 0.026,\n        mag_nonlinear_factor: 4.0e-9,\n        mag_nonlinear_exponent: 4f64,\n    };\n\n    // Calculate the location of the moon and convert to heliocentric coords\n    let initial_coords = moon_body.ecliptic_cartesian_coords(day) + earth_coords;\n    moon_body.coords.ahead_coords = initial_coords;\n    moon_body.coords.current_coords = initial_coords;\n    moon_body.coords.behind_coords = initial_coords;\n\n    moon_body\n}", "item_id": 3, "repo": "wagnerdylan/POSE", "file": "src/bodies.rs", "last_update_at": "2019-04-22T16:47:35+00:00", "question_id": "6b05a737ab80d77ea0ef4de1fc466367d251d8c4_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn make_moon(day: f64, earth_coords: &Array3d) -> PlanetPS {\n    let solar_trait = Solarobj::Moon {\n        attr: Some(SolarAttr {\n            radius: 1.7381e6,\n            mass: 0.07346e24,\n        }),\n    };\n    let mut moon_body = PlanetPS {\n        solartype: solar_trait,\n        coords: SolarobjCoords::default(),\n        velocity: Array3d::default(), // Zero until sim update\n        n0: 125.1228,\n        nc: -0.0529538083,\n        i0: 5.1454,\n        ic: 0.0,\n        w0: 318.0634,\n        wc: 0.1643573223,\n        a0: 60.2666 / EARTH_RADII_PER_ASTRONOMICAL_UNIT,\n        ac: 0.0,\n        e0: 0.054900,\n        ec: 0.0,\n        m0: 115.3654,\n        mc: 13.0649929509,\n        mag_base: 0.23,\n        mag_phase_factor: 0.026,\n        mag_nonlinear_factor: 4.0e-9,\n        mag_nonlinear_exponent: 4f64,\n    };\n    // Calculate the location of the moon and convert to heliocentric coords\n    let initial_coords = moon_body.ecliptic_cartesian_coords(day) + earth_coords;\n    moon_body.coords.ahead_coords = initial_coords;\n    moon_body.coords.current_coords = initial_coords;\n    moon_body.coords.behind_coords = initial_coords;\n    moon_body\n"]], "pred": {"ppl": 3.277045965194702, "ppl_lower": 3.411905527114868, "ppl/lowercase_ppl": -1.033976833862426, "ppl/zlib": 0.0021939785512502643, "Min_5.0% Prob": 8.152001399993896, "Min_10.0% Prob": 6.57981471454396, "Min_20.0% Prob": 4.731084206525018, "Min_30.0% Prob": 3.604190771486245, "Min_40.0% Prob": 2.8513804940032026, "Min_50.0% Prob": 2.337141695852373, "Min_60.0% Prob": 1.9686814887704802}}
{"hexsha": "7a5406638910b7fd1cbce133805b4516bb853406", "ext": "rs", "lang": "Rust", "content": "fn test_initialize_vertices() {\n        let left_image = [[1, 1].to_vec()].to_vec();\n        let right_image = [[1, 0].to_vec()].to_vec();\n        let max_disparity: usize = 2;\n        let mut diffusion_graph = DiffusionGraph::initialize(left_image, right_image, max_disparity, 1.);\n        diffusion_graph.potentials[0][0][2][0] = 0.6;\n        diffusion_graph.potentials[0][1][0][0] = -13.7;\n        diffusion_graph.potentials[0][1][0][1] = 80.;\n        let vertices = vec![vec![vec![false; max_disparity]; 2]; 1];\n        let edges = vec![vec![vec![vec![vec![false; max_disparity]; 4]; max_disparity]; 2]; 1];\n        let mut crossing_out_graph = CrossingOutGraph::initialize(diffusion_graph, vertices, edges);\n        crossing_out_graph.initialize_vertices(1.);\n        assert!(crossing_out_graph.vertices[0][0][0]);\n        assert!(!crossing_out_graph.vertices[0][1][0]);\n        assert!(crossing_out_graph.vertices[0][1][1]);\n    }", "item_id": 3, "repo": "Helga-Helga/stereo-vision", "file": "diffusion_stereo/src/crossing_out_graph.rs", "last_update_at": "2019-09-29T09:16:29+00:00", "question_id": "7a5406638910b7fd1cbce133805b4516bb853406_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_initialize_vertices() {\n        let left_image = [[1, 1].to_vec()].to_vec();\n        let right_image = [[1, 0].to_vec()].to_vec();\n        let max_disparity: usize = 2;\n        let mut diffusion_graph = DiffusionGraph::initialize(left_image, right_image, max_disparity, 1.);\n        diffusion_graph.potentials[0][0][2][0] = 0.6;\n        diffusion_graph.potentials[0][1][0][0] = -13.7;\n        diffusion_graph.potentials[0][1][0][1] = 80.;\n        let vertices = vec![vec![vec![false; max_disparity]; 2]; 1];\n        let edges = vec![vec![vec![vec![vec![false; max_disparity]; 4]; max_disparity]; 2]; 1];\n        let mut crossing_out_graph = CrossingOutGraph::initialize(diffusion_graph, vertices, edges);\n        crossing_out_graph.initialize_vertices(1.);\n        assert!(crossing_out_graph.vertices[0][0][0]);\n        assert!(!crossing_out_graph.vertices[0][1][0]);\n        assert!(crossing_out_graph.vertices[0][1][1]);\n"]], "pred": {"ppl": 2.287949323654175, "ppl_lower": 2.3882455825805664, "ppl/lowercase_ppl": -1.0518368862331942, "ppl/zlib": 0.0027961348801341834, "Min_5.0% Prob": 7.448677659034729, "Min_10.0% Prob": 5.310115561340794, "Min_20.0% Prob": 3.5424414232595645, "Min_30.0% Prob": 2.6025031515867405, "Min_40.0% Prob": 2.0288011002319832, "Min_50.0% Prob": 1.6453478929735499, "Min_60.0% Prob": 1.379193478121693}}
{"hexsha": "a28196ca355d1ed4bddbae5254b02a442b8003f0", "ext": "rs", "lang": "Rust", "content": "pub fn daily_temperatures(t: Vec<i32>) -> Vec<i32> {\n    let mut stack: Vec<usize> = vec![];\n    let mut res = vec![];\n    res.resize(t.len(), 0);\n\n    let mut count = 0;\n    for i in 0..t.len() {\n        while !stack.is_empty() && t[stack[stack.len() - 1]] < t[i] {\n            let cur = stack.pop().unwrap();\n            let days = count - cur;\n            res[cur] = days as i32;\n        }\n        stack.push(count);\n        count += 1;\n    }\n    res\n}", "item_id": 0, "repo": "yjhmelody/leetcode-rust", "file": "src/daily_temperatures.rs", "last_update_at": "2019-06-05T06:51:56+00:00", "question_id": "a28196ca355d1ed4bddbae5254b02a442b8003f0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn daily_temperatures(t: Vec<i32>) -> Vec<i32> {\n    let mut stack: Vec<usize> = vec![];\n    let mut res = vec![];\n    res.resize(t.len(), 0);\n    let mut count = 0;\n    for i in 0..t.len() {\n        while !stack.is_empty() && t[stack[stack.len() - 1]] < t[i] {\n            let cur = stack.pop().unwrap();\n            let days = count - cur;\n            res[cur] = days as i32;\n        }\n        stack.push(count);\n        count += 1;\n    }\n    res\n"]], "pred": {"ppl": 1.7561613321304321, "ppl_lower": 1.9024765491485596, "ppl/lowercase_ppl": -1.1421094002803556, "ppl/zlib": 0.002298491288907081, "Min_5.0% Prob": 7.05745804309845, "Min_10.0% Prob": 4.508135767544017, "Min_20.0% Prob": 2.6138493655359043, "Min_30.0% Prob": 1.8442465513944626, "Min_40.0% Prob": 1.4030292778111555, "Min_50.0% Prob": 1.1284605231574354, "Min_60.0% Prob": 0.9425704298613995}}
{"hexsha": "3784db95164066da6e55327253379eabe8e2a952", "ext": "rs", "lang": "Rust", "content": "fn test_divsd_rr() {\n        assert_emit!(0xf2, 0x0f, 0x5e, 0xc1; divsd_rr(XMM0, XMM1));\n        assert_emit!(0xf2, 0x41, 0x0f, 0x5e, 0xdf; divsd_rr(XMM3, XMM15));\n        assert_emit!(0xf2, 0x44, 0x0f, 0x5e, 0xc4; divsd_rr(XMM8, XMM4));\n    }", "item_id": 55, "repo": "ashwanidausodia/dora", "file": "dora/src/asm/x64.rs", "last_update_at": "2019-03-22T22:25:17+00:00", "question_id": "3784db95164066da6e55327253379eabe8e2a952_55", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_divsd_rr() {\n        assert_emit!(0xf2, 0x0f, 0x5e, 0xc1; divsd_rr(XMM0, XMM1));\n        assert_emit!(0xf2, 0x41, 0x0f, 0x5e, 0xdf; divsd_rr(XMM3, XMM15));\n        assert_emit!(0xf2, 0x44, 0x0f, 0x5e, 0xc4; divsd_rr(XMM8, XMM4));\n"]], "pred": {"ppl": 2.3268673419952393, "ppl_lower": 2.327688694000244, "ppl/lowercase_ppl": -1.0004178973733406, "ppl/zlib": 0.007819656245630205, "Min_5.0% Prob": 7.800658566611154, "Min_10.0% Prob": 5.995682460921151, "Min_20.0% Prob": 3.973631583411118, "Min_30.0% Prob": 2.812614791268526, "Min_40.0% Prob": 2.105662450001671, "Min_50.0% Prob": 1.699567421248907, "Min_60.0% Prob": 1.407216631357783}}
{"hexsha": "76e0b99ebf5020cb073dd1bfcba07a6ba4d25e3d", "ext": "rs", "lang": "Rust", "content": "fn test_check_answer_1() {\n    let answer = \"1 2 ABC 3.449999999993847\";\n    let expected = \"1 2 ABC 3.45\";\n    assert!(check_answer(answer, expected).is_ok());\n}", "item_id": 1, "repo": "mouri111/kunai", "file": "src/judge.rs", "last_update_at": "2019-12-19T07:54:16+00:00", "question_id": "76e0b99ebf5020cb073dd1bfcba07a6ba4d25e3d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_check_answer_1() {\n    let answer = \"1 2 ABC 3.449999999993847\";\n    let expected = \"1 2 ABC 3.45\";\n    assert!(check_answer(answer, expected).is_ok());\n"]], "pred": {"ppl": 4.482542991638184, "ppl_lower": 4.348290920257568, "ppl/lowercase_ppl": -0.9797308134602394, "ppl/zlib": 0.013394558191489717, "Min_5.0% Prob": 9.235371589660645, "Min_10.0% Prob": 7.32064996446882, "Min_20.0% Prob": 5.498179503849575, "Min_30.0% Prob": 4.333259196508498, "Min_40.0% Prob": 3.471334060718273, "Min_50.0% Prob": 2.8942991668979325, "Min_60.0% Prob": 2.4845071164674537}}
{"hexsha": "89cbaf2d12ed958d64b971f50820c779d053f628", "ext": "rs", "lang": "Rust", "content": "fn test_parse_duration() {\n    assert_eq!(None, parse_duration(\"\"));\n    assert_eq!(None, parse_duration(\"X\"));\n    assert_eq!(None, parse_duration(\"S\"));\n    assert_eq!(Duration::from_millis(1), parse_duration(\"1\").unwrap());\n    assert_eq!(Duration::from_millis(100), parse_duration(\"100\").unwrap());\n    assert_eq!(Duration::from_millis(1000), parse_duration(\"1s\").unwrap());\n    assert_eq!(Duration::from_millis(2000), parse_duration(\"2S\").unwrap());\n    assert_eq!(Duration::from_millis(1500), parse_duration(\"1.5s\").unwrap());\n    assert_eq!(Duration::from_millis(60000), parse_duration(\"1m\").unwrap());\n    assert_eq!(Duration::from_millis(3600000), parse_duration(\"1h\").unwrap());\n    assert_eq!(Duration::from_millis(1800000), parse_duration(\"0.5h\").unwrap());\n    assert_eq!(Duration::from_millis(24 * 3600000), parse_duration(\"1d\").unwrap());\n}", "item_id": 1, "repo": "jht5945/rust_util", "file": "src/util_time.rs", "last_update_at": "2019-08-11T05:31:28+00:00", "question_id": "89cbaf2d12ed958d64b971f50820c779d053f628_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_parse_duration() {\n    assert_eq!(None, parse_duration(\"\"));\n    assert_eq!(None, parse_duration(\"X\"));\n    assert_eq!(None, parse_duration(\"S\"));\n    assert_eq!(Duration::from_millis(1), parse_duration(\"1\").unwrap());\n    assert_eq!(Duration::from_millis(100), parse_duration(\"100\").unwrap());\n    assert_eq!(Duration::from_millis(1000), parse_duration(\"1s\").unwrap());\n    assert_eq!(Duration::from_millis(2000), parse_duration(\"2S\").unwrap());\n    assert_eq!(Duration::from_millis(1500), parse_duration(\"1.5s\").unwrap());\n    assert_eq!(Duration::from_millis(60000), parse_duration(\"1m\").unwrap());\n    assert_eq!(Duration::from_millis(3600000), parse_duration(\"1h\").unwrap());\n    assert_eq!(Duration::from_millis(1800000), parse_duration(\"0.5h\").unwrap());\n    assert_eq!(Duration::from_millis(24 * 3600000), parse_duration(\"1d\").unwrap());\n"]], "pred": {"ppl": 1.3805760145187378, "ppl_lower": 1.4133009910583496, "ppl/lowercase_ppl": -1.072642553792796, "ppl/zlib": 0.0018750047320138183, "Min_5.0% Prob": 4.345528348286947, "Min_10.0% Prob": 2.817181287209193, "Min_20.0% Prob": 1.5520050608720937, "Min_30.0% Prob": 1.0664378313104743, "Min_40.0% Prob": 0.8046669625957322, "Min_50.0% Prob": 0.6443015180192525, "Min_60.0% Prob": 0.5396163796730157}}
{"hexsha": "ca916874d99d1804e8d632c564046b2689a8f57d", "ext": "rs", "lang": "Rust", "content": "fn test_fn(dir_name: &str, fn_name: &str) -> Result<(), Error> {\n    do catch {\n        let facts_dir = Path::new(env!(\"CARGO_MANIFEST_DIR\"))\n            .join(\"inputs\")\n            .join(dir_name)\n            .join(\"nll-facts\")\n            .join(fn_name);\n        println!(\"facts_dir = {:?}\", facts_dir);\n        let tables = &mut intern::InternerTables::new();\n        let all_facts = tab_delim::load_tab_delimited_facts(tables, &facts_dir)?;\n        let naive = Output::compute(&all_facts, Algorithm::Naive, false);\n        let opt = Output::compute(&all_facts, Algorithm::DatafrogOpt, true);\n        assert_eq!(naive.borrow_live_at, opt.borrow_live_at);\n    }", "item_id": 0, "repo": "nikomatsakis/borrow-check", "file": "src/test.rs", "last_update_at": "2019-01-28T10:31:16+00:00", "question_id": "ca916874d99d1804e8d632c564046b2689a8f57d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_fn(dir_name: &str, fn_name: &str) -> Result<(), Error> {\n    do catch {\n        let facts_dir = Path::new(env!(\"CARGO_MANIFEST_DIR\"))\n            .join(\"inputs\")\n            .join(dir_name)\n            .join(\"nll-facts\")\n            .join(fn_name);\n        println!(\"facts_dir = {:?}\", facts_dir);\n        let tables = &mut intern::InternerTables::new();\n        let all_facts = tab_delim::load_tab_delimited_facts(tables, &facts_dir)?;\n        let naive = Output::compute(&all_facts, Algorithm::Naive, false);\n        let opt = Output::compute(&all_facts, Algorithm::DatafrogOpt, true);\n        assert_eq!(naive.borrow_live_at, opt.borrow_live_at);\n"]], "pred": {"ppl": 3.3196465969085693, "ppl_lower": 4.4159650802612305, "ppl/lowercase_ppl": -1.2378348039766804, "ppl/zlib": 0.0036692915307286154, "Min_5.0% Prob": 9.620094472711736, "Min_10.0% Prob": 7.766765984621915, "Min_20.0% Prob": 5.115540019671122, "Min_30.0% Prob": 3.7660173440680786, "Min_40.0% Prob": 2.941138986702804, "Min_50.0% Prob": 2.3885625502780865, "Min_60.0% Prob": 2.001164534965353}}
{"hexsha": "29e13d4dd0da6fa3c93f41a5bf4533c7c4e334cd", "ext": "rs", "lang": "Rust", "content": "fn eat_string(chars: &mut Peekable<Chars>) -> Option<String> {\n    let mut s = String::with_capacity(15);\n\n    while let Some(c) = chars.next() {\n        match c {\n            '\"' => return Some(s.to_owned()),\n            '\\\\' => match chars.next()? {\n                '\\\\' => s.push('\\\\'),\n                '/' => s.push('/'),\n                '\"' => s.push('\"'),\n                'n' => s.push('\\n'),\n                't' => s.push('\\t'),\n                'b' => s.push(8 as char),\n                'f' => s.push(12 as char),\n                'r' => s.push(13 as char),\n                'u' => {\n                    if let Ok(num) = u8::from_str_radix(&chars.take(4).collect::<String>(), 16) {\n                        s.push(num as char);\n                    }\n                }\n                _ => {}\n            },\n            _ => s.push(c),\n        }\n    }\n\n    Some(s.to_owned())\n}", "item_id": 0, "repo": "mlvzk/json-to-sh", "file": "src/lexer.rs", "last_update_at": "2019-07-30T09:08:49+00:00", "question_id": "29e13d4dd0da6fa3c93f41a5bf4533c7c4e334cd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn eat_string(chars: &mut Peekable<Chars>) -> Option<String> {\n    let mut s = String::with_capacity(15);\n    while let Some(c) = chars.next() {\n        match c {\n            '\"' => return Some(s.to_owned()),\n            '\\\\' => match chars.next()? {\n                '\\\\' => s.push('\\\\'),\n                '/' => s.push('/'),\n                '\"' => s.push('\"'),\n                'n' => s.push('\\n'),\n                't' => s.push('\\t'),\n                'b' => s.push(8 as char),\n                'f' => s.push(12 as char),\n                'r' => s.push(13 as char),\n                'u' => {\n                    if let Ok(num) = u8::from_str_radix(&chars.take(4).collect::<String>(), 16) {\n                        s.push(num as char);\n                    }\n                }\n                _ => {}\n            },\n            _ => s.push(c),\n        }\n    }\n    Some(s.to_owned())\n"]], "pred": {"ppl": 1.5186859369277954, "ppl_lower": 1.7698419094085693, "ppl/lowercase_ppl": -1.3662712652663858, "ppl/zlib": 0.0012817344962280375, "Min_5.0% Prob": 4.794761947223118, "Min_10.0% Prob": 3.3294924242155894, "Min_20.0% Prob": 1.990264516127737, "Min_30.0% Prob": 1.379588211215166, "Min_40.0% Prob": 1.0478980643674731, "Min_50.0% Prob": 0.8375051418723135, "Min_60.0% Prob": 0.6968823454997957}}
{"hexsha": "2791ab82c02c885f427c58931d2c5ec2e77eb458", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let n: usize = {\n        let mut line: String = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n        line.trim().parse().unwrap()\n    };\n    let a: Vec<i64> = {\n        let mut line: String = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|x| x.parse().unwrap())\n            .collect()\n    };\n\n    let ans = (0..n)\n        .map(|i| if i < (n + 1) / 2 { a[n - 2 * i - 1] } else { a[2 * (i - (n + 1) / 2) + n % 2] })\n        .map(|x| x.to_string())\n        .collect::<Vec<_>>()\n        .join(\" \");\n\n    println!(\"{}\", ans);\n}", "item_id": 0, "repo": "wotsushi/competitive-programming", "file": "arc/077/c.rs", "last_update_at": "2019-07-13T15:18:51+00:00", "question_id": "2791ab82c02c885f427c58931d2c5ec2e77eb458_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let n: usize = {\n        let mut line: String = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n        line.trim().parse().unwrap()\n    };\n    let a: Vec<i64> = {\n        let mut line: String = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|x| x.parse().unwrap())\n            .collect()\n    };\n    let ans = (0..n)\n        .map(|i| if i < (n + 1) / 2 { a[n - 2 * i - 1] } else { a[2 * (i - (n + 1) / 2) + n % 2] })\n        .map(|x| x.to_string())\n        .collect::<Vec<_>>()\n        .join(\" \");\n    println!(\"{}\", ans);\n"]], "pred": {"ppl": 1.408551812171936, "ppl_lower": 1.5901081562042236, "ppl/lowercase_ppl": -1.353921073432891, "ppl/zlib": 0.0012104667597608227, "Min_5.0% Prob": 4.157704174518585, "Min_10.0% Prob": 2.7824384197592735, "Min_20.0% Prob": 1.6455879844725132, "Min_30.0% Prob": 1.1367333528275292, "Min_40.0% Prob": 0.8577280598983634, "Min_50.0% Prob": 0.6874010836317515, "Min_60.0% Prob": 0.5731449803934083}}
{"hexsha": "53d4b0e15843bcbffd0d575e9f2fec82e4f3dd91", "ext": "rs", "lang": "Rust", "content": "fn overflow_flag_hi_under() {\n    let mut flags = StatusFlags::empty();\n    flags.set_overflow(-129i16 as u16);\n\n    assert!(flags.contains(StatusFlags::V_FLAG));\n  }", "item_id": 5, "repo": "WeAreRust/Nes", "file": "nes/src/cpu/register.rs", "last_update_at": "2019-07-12T01:31:25+00:00", "question_id": "53d4b0e15843bcbffd0d575e9f2fec82e4f3dd91_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn overflow_flag_hi_under() {\n    let mut flags = StatusFlags::empty();\n    flags.set_overflow(-129i16 as u16);\n    assert!(flags.contains(StatusFlags::V_FLAG));\n"]], "pred": {"ppl": 6.649407863616943, "ppl_lower": 8.670832633972168, "ppl/lowercase_ppl": -1.1401072149411988, "ppl/zlib": 0.014138267221179645, "Min_5.0% Prob": 9.911221981048584, "Min_10.0% Prob": 9.39981803894043, "Min_20.0% Prob": 7.159485730257901, "Min_30.0% Prob": 5.480573710273294, "Min_40.0% Prob": 4.499119069265283, "Min_50.0% Prob": 3.7198511341522478, "Min_60.0% Prob": 3.158114542279925}}
{"hexsha": "3c49efe78c33a7ba0a4c81366ec0a1ce02b21082", "ext": "rs", "lang": "Rust", "content": "pub fn get_doc(attrs: &[syn::Attribute], null_terminated: bool) -> syn::Lit {\n    let mut doc = Vec::new();\n\n    // TODO(althonos): set span on produced doc str literal\n    // let mut span = None;\n\n    for attr in attrs.iter() {\n        if let Some(syn::Meta::NameValue(ref metanv)) = attr.interpret_meta() {\n            if metanv.ident == \"doc\" {\n                // span = Some(metanv.span());\n                if let syn::Lit::Str(ref litstr) = metanv.lit {\n                    let d = litstr.value();\n                    doc.push(if d.starts_with(' ') {\n                        d[1..d.len()].to_string()\n                    } else {\n                        d\n                    });\n                } else {\n                    panic!(\"Invalid doc comment\");\n                }\n            }\n        }\n    }\n\n    let doc = doc.join(\"\\n\");\n\n    // FIXME: add span\n    syn::parse_str(&if null_terminated {\n        format!(\"\\\"{}\\0\\\"\", doc)\n    } else {\n        format!(\"\\\"{}\\\"\", doc)\n    })\n    .unwrap()\n}", "item_id": 0, "repo": "milesgranger/pyo3", "file": "pyo3-derive-backend/src/utils.rs", "last_update_at": "2019-10-06T11:46:45+00:00", "question_id": "3c49efe78c33a7ba0a4c81366ec0a1ce02b21082_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_doc(attrs: &[syn::Attribute], null_terminated: bool) -> syn::Lit {\n    let mut doc = Vec::new();\n    // TODO(althonos): set span on produced doc str literal\n    // let mut span = None;\n    for attr in attrs.iter() {\n        if let Some(syn::Meta::NameValue(ref metanv)) = attr.interpret_meta() {\n            if metanv.ident == \"doc\" {\n                // span = Some(metanv.span());\n                if let syn::Lit::Str(ref litstr) = metanv.lit {\n                    let d = litstr.value();\n                    doc.push(if d.starts_with(' ') {\n                        d[1..d.len()].to_string()\n                    } else {\n                        d\n                    });\n                } else {\n                    panic!(\"Invalid doc comment\");\n                }\n            }\n        }\n    }\n    let doc = doc.join(\"\\n\");\n    // FIXME: add span\n    syn::parse_str(&if null_terminated {\n        format!(\"\\\"{}\\0\\\"\", doc)\n    } else {\n        format!(\"\\\"{}\\\"\", doc)\n    })\n    .unwrap()\n"]], "pred": {"ppl": 2.2330310344696045, "ppl_lower": 2.8246660232543945, "ppl/lowercase_ppl": -1.292559129985183, "ppl/zlib": 0.00176562608981748, "Min_5.0% Prob": 7.138744068145752, "Min_10.0% Prob": 5.260490226745605, "Min_20.0% Prob": 3.469123085991281, "Min_30.0% Prob": 2.5591735768577326, "Min_40.0% Prob": 1.9869535587182858, "Min_50.0% Prob": 1.603876027871262, "Min_60.0% Prob": 1.3402597096924846}}
{"hexsha": "6284d1836ef46c50637504ab98bc58c982d91ef0", "ext": "rs", "lang": "Rust", "content": "pub fn vmresume() -> Result<(), u32> {\n    let ret: u32;\n    unsafe {\n        asm!(\n            \"xor %eax, %eax; \\\n             vmresume; \\\n             setc %ah; \\\n             setz %al;\"\n             : \"={eax}\"(ret)\n             :\n             :\n            );\n    }\n    if ret == 0 { Ok(()) } else { Err(ret) }\n}", "item_id": 10, "repo": "colonelpopcorn/rustyvisor", "file": "src/vmx.rs", "last_update_at": "2019-04-11T21:37:17+00:00", "question_id": "6284d1836ef46c50637504ab98bc58c982d91ef0_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn vmresume() -> Result<(), u32> {\n    let ret: u32;\n    unsafe {\n        asm!(\n            \"xor %eax, %eax; \\\n             vmresume; \\\n             setc %ah; \\\n             setz %al;\"\n             : \"={eax}\"(ret)\n             :\n             :\n            );\n    }\n    if ret == 0 { Ok(()) } else { Err(ret) }\n"]], "pred": {"ppl": 2.667703151702881, "ppl_lower": 3.0425429344177246, "ppl/lowercase_ppl": -1.1339924632419534, "ppl/zlib": 0.005771869761076876, "Min_5.0% Prob": 8.69831485748291, "Min_10.0% Prob": 6.154128638180819, "Min_20.0% Prob": 4.124580708417025, "Min_30.0% Prob": 3.102143535108277, "Min_40.0% Prob": 2.402145443360011, "Min_50.0% Prob": 1.9578659475914069, "Min_60.0% Prob": 1.6465361522538449}}
{"hexsha": "e9bdfb8b405be3498686f9dabb15f50e1ef6e656", "ext": "rs", "lang": "Rust", "content": "fn test_move_c_e() {\n        let mut cpu: CPU = CPU::new();\n\n        cpu = cpu.set_c(Register { value: 0 });\n        cpu = cpu.set_e(Register { value: 10 });\n\n        cpu = execute_move(cpu, 0b010, 0b100);\n\n        assert_eq!(cpu.pc.value, 0);\n        assert_eq!(cpu.f.value, 0);\n        assert_eq!(cpu.c.value, 10);\n    }", "item_id": 21, "repo": "TheLocust3/simple-virtual-machine", "file": "emu/tests/executor_register_tests.rs", "last_update_at": "2019-02-18T04:28:41+00:00", "question_id": "e9bdfb8b405be3498686f9dabb15f50e1ef6e656_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_move_c_e() {\n        let mut cpu: CPU = CPU::new();\n        cpu = cpu.set_c(Register { value: 0 });\n        cpu = cpu.set_e(Register { value: 10 });\n        cpu = execute_move(cpu, 0b010, 0b100);\n        assert_eq!(cpu.pc.value, 0);\n        assert_eq!(cpu.f.value, 0);\n        assert_eq!(cpu.c.value, 10);\n"]], "pred": {"ppl": 2.5891149044036865, "ppl_lower": 2.8879106044769287, "ppl/lowercase_ppl": -1.1148064108087747, "ppl/zlib": 0.005872321491080282, "Min_5.0% Prob": 7.095615943272908, "Min_10.0% Prob": 5.5198579751528225, "Min_20.0% Prob": 3.9512124244983378, "Min_30.0% Prob": 2.983802732748863, "Min_40.0% Prob": 2.3213943945911697, "Min_50.0% Prob": 1.8972062527230291, "Min_60.0% Prob": 1.5952085871956772}}
{"hexsha": "1d7205e2c4cf31cc23d270feb49066850ba1639e", "ext": "rs", "lang": "Rust", "content": "fn crypto_encrypt_decypt_success() {\n    // arrange\n    let crypto = Crypto::new().unwrap();\n\n    let client_id = b\"module1\";\n    let plaintext = b\"plaintext\";\n    let iv = b\"initialization vector\";\n\n    match crypto.create_key() {\n        Ok(_result) => assert!(true),\n        Err(_) => panic!(\"Create master key function returned error\"),\n    };\n\n    //act\n    let ciphertext = match crypto.encrypt(client_id, plaintext, iv) {\n        //assert\n        Ok(result) => result,\n        Err(_) => panic!(\"Encrypt function returned error\"),\n    };\n    assert_ne!(ciphertext.as_ref().len(), 0);\n\n    //act\n    let plaintext_result = match crypto.decrypt(client_id, ciphertext.as_ref(), iv) {\n        //assert\n        Ok(result) => result,\n        Err(_) => panic!(\"Decrypt function returned error\"),\n    };\n    assert_eq!(\n        plaintext,\n        plaintext_result.as_ref(),\n        \"Failure plaintext after decrypt did not match {:?} and {:?}\",\n        plaintext,\n        plaintext_result.as_ref()\n    );\n\n    let bad_client_id = b\"module2\";\n    match crypto.decrypt(bad_client_id, ciphertext.as_ref(), iv) {\n        //assert\n        Ok(_result) => panic!(\"Decrypt function returned unexpected success\"),\n        Err(_) => (),\n    };\n\n    let bad_iv = b\"inconsistent_iv\";\n    match crypto.decrypt(client_id, ciphertext.as_ref(), bad_iv) {\n        //assert\n        Ok(_result) => panic!(\"Decrypt function returned unexpected success\"),\n        Err(_) => (),\n    };\n\n    // cleanup\n    match crypto.destroy_key() {\n        Ok(_result) => assert!(true),\n        Err(_) => panic!(\"Destroy master key function returned error\"),\n    };\n}", "item_id": 0, "repo": "ngi644/iotedge", "file": "edgelet/edgelet-hsm/tests/crypto_encrypt_decrypt_success.rs", "last_update_at": "2019-03-22T13:38:47+00:00", "question_id": "1d7205e2c4cf31cc23d270feb49066850ba1639e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn crypto_encrypt_decypt_success() {\n    // arrange\n    let crypto = Crypto::new().unwrap();\n    let client_id = b\"module1\";\n    let plaintext = b\"plaintext\";\n    let iv = b\"initialization vector\";\n    match crypto.create_key() {\n        Ok(_result) => assert!(true),\n        Err(_) => panic!(\"Create master key function returned error\"),\n    };\n    //act\n    let ciphertext = match crypto.encrypt(client_id, plaintext, iv) {\n        //assert\n        Ok(result) => result,\n        Err(_) => panic!(\"Encrypt function returned error\"),\n    };\n    assert_ne!(ciphertext.as_ref().len(), 0);\n    //act\n    let plaintext_result = match crypto.decrypt(client_id, ciphertext.as_ref(), iv) {\n        //assert\n        Ok(result) => result,\n        Err(_) => panic!(\"Decrypt function returned error\"),\n    };\n    assert_eq!(\n        plaintext,\n        plaintext_result.as_ref(),\n        \"Failure plaintext after decrypt did not match {:?} and {:?}\",\n        plaintext,\n        plaintext_result.as_ref()\n    );\n    let bad_client_id = b\"module2\";\n    match crypto.decrypt(bad_client_id, ciphertext.as_ref(), iv) {\n        //assert\n        Ok(_result) => panic!(\"Decrypt function returned unexpected success\"),\n        Err(_) => (),\n    };\n    let bad_iv = b\"inconsistent_iv\";\n    match crypto.decrypt(client_id, ciphertext.as_ref(), bad_iv) {\n        //assert\n        Ok(_result) => panic!(\"Decrypt function returned unexpected success\"),\n        Err(_) => (),\n    };\n    // cleanup\n    match crypto.destroy_key() {\n        Ok(_result) => assert!(true),\n        Err(_) => panic!(\"Destroy master key function returned error\"),\n    };\n"]], "pred": {"ppl": 1.8589282035827637, "ppl_lower": 1.920814871788025, "ppl/lowercase_ppl": -1.0528216399852588, "ppl/zlib": 0.0013626375538575925, "Min_5.0% Prob": 6.443313426971436, "Min_10.0% Prob": 4.718988900091134, "Min_20.0% Prob": 2.894144058227539, "Min_30.0% Prob": 2.022928605379622, "Min_40.0% Prob": 1.5391572661076982, "Min_50.0% Prob": 1.2372980453293114, "Min_60.0% Prob": 1.0326400634808333}}
{"hexsha": "893e26f9cd6149860f4273adaa5bdb87a286db0a", "ext": "rs", "lang": "Rust", "content": "fn router(logger: slog::Logger, cfg: config::Config, irc: Box<irc::IrcWriter + Send>) -> Router {\n    let state = AppState {\n        logger: Arc::new(logger),\n        cfg: Arc::new(RwLock::new(cfg)),\n        irc: Arc::new(Mutex::new(irc)),\n    };\n\n    let middleware = StateMiddleware::new(state);\n\n    // create a middleware pipeline from our middleware\n    let pipeline = single_middleware(middleware);\n\n    // construct a basic chain from our pipeline\n    let (chain, pipelines) = single_pipeline(pipeline);\n\n    // build a router with the chain & pipeline\n    build_router(chain, pipelines, |route| {\n        route.post(\"/gitlab\").to(handle_gitlab);\n    })\n}", "item_id": 0, "repo": "abbec/raccoon", "file": "src/main.rs", "last_update_at": "2019-07-31T01:41:04+00:00", "question_id": "893e26f9cd6149860f4273adaa5bdb87a286db0a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn router(logger: slog::Logger, cfg: config::Config, irc: Box<irc::IrcWriter + Send>) -> Router {\n    let state = AppState {\n        logger: Arc::new(logger),\n        cfg: Arc::new(RwLock::new(cfg)),\n        irc: Arc::new(Mutex::new(irc)),\n    };\n    let middleware = StateMiddleware::new(state);\n    // create a middleware pipeline from our middleware\n    let pipeline = single_middleware(middleware);\n    // construct a basic chain from our pipeline\n    let (chain, pipelines) = single_pipeline(pipeline);\n    // build a router with the chain & pipeline\n    build_router(chain, pipelines, |route| {\n        route.post(\"/gitlab\").to(handle_gitlab);\n    })\n"]], "pred": {"ppl": 2.924726724624634, "ppl_lower": 4.271599292755127, "ppl/lowercase_ppl": -1.3529508756211006, "ppl/zlib": 0.0033962058507608964, "Min_5.0% Prob": 8.061639451980591, "Min_10.0% Prob": 6.640441155433654, "Min_20.0% Prob": 4.533408545866245, "Min_30.0% Prob": 3.36069608614093, "Min_40.0% Prob": 2.615599626811539, "Min_50.0% Prob": 2.124686981144461, "Min_60.0% Prob": 1.792191683276882}}
{"hexsha": "0b458401e1b7d5cf9a66d03576d5655663a69e37", "ext": "rs", "lang": "Rust", "content": "fn test_normalization() {\n    assert_eq!(huifier::huify(\"\"), \"\u0425\u0443\u0439\");\n    assert_eq!(huifier::huify(\" \"), \"\u0425\u0443\u0439\");\n    assert_eq!(huifier::huify(\"   \"), \"\u0425\u0443\u0439\");\n    assert_eq!(huifier::huify(\"  \u0412\u0438\u043b\u043a\u0430  \"), \"\u0425\u0443\u0438\u043b\u043a\u0430\");\n    assert_eq!(huifier::huify(\"\u0419\"), \"\u0425\u0443\u0439\");\n    assert_eq!(huifier::huify(\"\u041e\"), \"\u0425\u0443\u0451\");\n}", "item_id": 3, "repo": "kefir500/huifier", "file": "rust/tests/huifier_test.rs", "last_update_at": "2019-11-04T13:04:17+00:00", "question_id": "0b458401e1b7d5cf9a66d03576d5655663a69e37_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_normalization() {\n    assert_eq!(huifier::huify(\"\"), \"\u0425\u0443\u0439\");\n    assert_eq!(huifier::huify(\" \"), \"\u0425\u0443\u0439\");\n    assert_eq!(huifier::huify(\"   \"), \"\u0425\u0443\u0439\");\n    assert_eq!(huifier::huify(\"  \u0412\u0438\u043b\u043a\u0430  \"), \"\u0425\u0443\u0438\u043b\u043a\u0430\");\n    assert_eq!(huifier::huify(\"\u0419\"), \"\u0425\u0443\u0439\");\n    assert_eq!(huifier::huify(\"\u041e\"), \"\u0425\u0443\u0451\");\n"]], "pred": {"ppl": 2.689410448074341, "ppl_lower": 2.5675365924835205, "ppl/lowercase_ppl": -0.9531243718861978, "ppl/zlib": 0.008455743635120638, "Min_5.0% Prob": 10.067970832188925, "Min_10.0% Prob": 7.781998952229817, "Min_20.0% Prob": 4.790027310848236, "Min_30.0% Prob": 3.283808403893521, "Min_40.0% Prob": 2.4753989863629435, "Min_50.0% Prob": 1.977302468076232, "Min_60.0% Prob": 1.665883218247664}}
{"hexsha": "0db53506213438afcfd9c2bded69626c73d1403b", "ext": "rs", "lang": "Rust", "content": "fn test_dual_convergence() {\n        let c1 = FnResidual::new(1e-4);\n        let c2 = DeltaX::new(1e-9);\n        let c = DualCriteria::new(&c1, &c2);\n\n        // neither c1 nor c2\n        let x_0 = -3.7;\n        assert_eq!(false, c.is_converged(x_0, x_0 + 1.0, 113456.987));\n\n        // c1 but not c2\n        assert_eq!(false, c.is_converged(x_0, x_0 + 5e-10, 113456.987));\n\n        // c2 but not c1\n        assert_eq!(false, c.is_converged(x_0, x_0 + 1.0, 0.00008));\n\n        // both c1 and c2\n        assert_eq!(true, c.is_converged(0.0, 1e-10, 0.00008));\n    }", "item_id": 2, "repo": "nieksand/rootfind", "file": "src/convergence.rs", "last_update_at": "2019-08-27T11:01:10+00:00", "question_id": "0db53506213438afcfd9c2bded69626c73d1403b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_dual_convergence() {\n        let c1 = FnResidual::new(1e-4);\n        let c2 = DeltaX::new(1e-9);\n        let c = DualCriteria::new(&c1, &c2);\n        // neither c1 nor c2\n        let x_0 = -3.7;\n        assert_eq!(false, c.is_converged(x_0, x_0 + 1.0, 113456.987));\n        // c1 but not c2\n        assert_eq!(false, c.is_converged(x_0, x_0 + 5e-10, 113456.987));\n        // c2 but not c1\n        assert_eq!(false, c.is_converged(x_0, x_0 + 1.0, 0.00008));\n        // both c1 and c2\n        assert_eq!(true, c.is_converged(0.0, 1e-10, 0.00008));\n"]], "pred": {"ppl": 2.372176170349121, "ppl_lower": 2.5115745067596436, "ppl/lowercase_ppl": -1.0661051036862506, "ppl/zlib": 0.0036142583647799016, "Min_5.0% Prob": 6.92152580848107, "Min_10.0% Prob": 5.413645479414198, "Min_20.0% Prob": 3.690029892054471, "Min_30.0% Prob": 2.7324979039559882, "Min_40.0% Prob": 2.1306194747621947, "Min_50.0% Prob": 1.7233667541161286, "Min_60.0% Prob": 1.4402975397976394}}
{"hexsha": "8494e71f88ab6613fb56f6f14e886aa65e4aefe3", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn environment_set_decimal(env: *mut ASTEnvironment,\n                                          name: *const c_char,\n                                          value: f64) {\n    let environment = unsafe { &mut *env };\n    let key: String = unsafe { CStr::from_ptr(name).to_string_lossy().into_owned() };\n\n    environment.set(key.as_str(), Lit::Decimal(value));\n}", "item_id": 2, "repo": "DarinM223/yamlate", "file": "src/ffi/environment.rs", "last_update_at": "2019-01-13T11:36:37+00:00", "question_id": "8494e71f88ab6613fb56f6f14e886aa65e4aefe3_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub extern \"C\" fn environment_set_decimal(env: *mut ASTEnvironment,\n                                          name: *const c_char,\n                                          value: f64) {\n    let environment = unsafe { &mut *env };\n    let key: String = unsafe { CStr::from_ptr(name).to_string_lossy().into_owned() };\n    environment.set(key.as_str(), Lit::Decimal(value));\n"]], "pred": {"ppl": 2.9006717205047607, "ppl_lower": 4.055734157562256, "ppl/lowercase_ppl": -1.3147488565940255, "ppl/zlib": 0.005220305578093738, "Min_5.0% Prob": 9.53404655456543, "Min_10.0% Prob": 7.007563042640686, "Min_20.0% Prob": 4.520440754436311, "Min_30.0% Prob": 3.261258466169238, "Min_40.0% Prob": 2.6068823685248694, "Min_50.0% Prob": 2.118639557710234, "Min_60.0% Prob": 1.7728867758414708}}
{"hexsha": "51cf295daa4895d161c50a095a69e7784e638f6f", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn handle_device_removed(mut backend:\n                                               *mut wlr_libinput_backend,\n                                           mut libinput_dev:\n                                               *mut libinput_device) {\n    let mut wlr_devices: *mut wl_list =\n        libinput_device_get_user_data(libinput_dev) as *mut wl_list;\n    let mut vendor: libc::c_int =\n        libinput_device_get_id_vendor(libinput_dev) as libc::c_int;\n    let mut product: libc::c_int =\n        libinput_device_get_id_product(libinput_dev) as libc::c_int;\n    let mut name: *const libc::c_char =\n        libinput_device_get_name(libinput_dev);\n    _wlr_log(WLR_DEBUG,\n             b\"[%s:%d] Removing %s [%d:%d]\\x00\" as *const u8 as\n                 *const libc::c_char,\n             b\"../backend/libinput/events.c\\x00\" as *const u8 as\n                 *const libc::c_char, 208i32, name, vendor, product);\n    if wlr_devices.is_null() { return }\n    let mut dev: *mut wlr_input_device = 0 as *mut wlr_input_device;\n    let mut tmp_dev: *mut wlr_input_device = 0 as *mut wlr_input_device;\n    dev =\n        ((*wlr_devices).next as *mut libc::c_char).offset(-88) as\n            *mut wlr_input_device;\n    tmp_dev =\n        ((*dev).link.next as *mut libc::c_char).offset(-88) as\n            *mut wlr_input_device;\n    while &mut (*dev).link as *mut wl_list != wlr_devices {\n        wlr_input_device_destroy(dev);\n        dev = tmp_dev;\n        tmp_dev =\n            ((*dev).link.next as *mut libc::c_char).offset(-88) as\n                *mut wlr_input_device\n    }\n    let mut i: size_t = 0i32 as size_t;\n    while i < (*backend).wlr_device_lists.length {\n        if *(*backend).wlr_device_lists.items.offset(i as isize) ==\n               wlr_devices as *mut libc::c_void {\n            wlr_list_del(&mut (*backend).wlr_device_lists, i);\n            break ;\n        } else { i = i.wrapping_add(1) }\n    }\n    free(wlr_devices as *mut libc::c_void);\n}", "item_id": 5, "repo": "RoastVeg/wlrusts", "file": "src/backend/libinput/events.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "51cf295daa4895d161c50a095a69e7784e638f6f_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe extern \"C\" fn handle_device_removed(mut backend:\n                                               *mut wlr_libinput_backend,\n                                           mut libinput_dev:\n                                               *mut libinput_device) {\n    let mut wlr_devices: *mut wl_list =\n        libinput_device_get_user_data(libinput_dev) as *mut wl_list;\n    let mut vendor: libc::c_int =\n        libinput_device_get_id_vendor(libinput_dev) as libc::c_int;\n    let mut product: libc::c_int =\n        libinput_device_get_id_product(libinput_dev) as libc::c_int;\n    let mut name: *const libc::c_char =\n        libinput_device_get_name(libinput_dev);\n    _wlr_log(WLR_DEBUG,\n             b\"[%s:%d] Removing %s [%d:%d]\\x00\" as *const u8 as\n                 *const libc::c_char,\n             b\"../backend/libinput/events.c\\x00\" as *const u8 as\n                 *const libc::c_char, 208i32, name, vendor, product);\n    if wlr_devices.is_null() { return }\n    let mut dev: *mut wlr_input_device = 0 as *mut wlr_input_device;\n    let mut tmp_dev: *mut wlr_input_device = 0 as *mut wlr_input_device;\n    dev =\n        ((*wlr_devices).next as *mut libc::c_char).offset(-88) as\n            *mut wlr_input_device;\n    tmp_dev =\n        ((*dev).link.next as *mut libc::c_char).offset(-88) as\n            *mut wlr_input_device;\n    while &mut (*dev).link as *mut wl_list != wlr_devices {\n        wlr_input_device_destroy(dev);\n        dev = tmp_dev;\n        tmp_dev =\n            ((*dev).link.next as *mut libc::c_char).offset(-88) as\n                *mut wlr_input_device\n    }\n    let mut i: size_t = 0i32 as size_t;\n    while i < (*backend).wlr_device_lists.length {\n        if *(*backend).wlr_device_lists.items.offset(i as isize) ==\n               wlr_devices as *mut libc::c_void {\n            wlr_list_del(&mut (*backend).wlr_device_lists, i);\n            break ;\n        } else { i = i.wrapping_add(1) }\n    }\n    free(wlr_devices as *mut libc::c_void);\n"]], "pred": {"ppl": 1.3303887844085693, "ppl_lower": 1.3711100816726685, "ppl/lowercase_ppl": -1.1056129996552584, "ppl/zlib": 0.000504366110637712, "Min_5.0% Prob": 4.234239991973428, "Min_10.0% Prob": 2.6190559466679892, "Min_20.0% Prob": 1.4094772628850216, "Min_30.0% Prob": 0.948883308191298, "Min_40.0% Prob": 0.7150887889919882, "Min_50.0% Prob": 0.5716363259329562, "Min_60.0% Prob": 0.47598947691585636}}
{"hexsha": "862f0f0cb9bd34f3b4ddb8afdc7dcc3abdec80c9", "ext": "rs", "lang": "Rust", "content": "fn run_import_command<'a>(args: &ArgMatches<'a>) -> Result<(), CliError> {\n    let ctx = create_context()?;\n    let blockstore = open_blockstore(&ctx)?;\n\n    let filepath = args\n        .value_of(\"blockfile\")\n        .ok_or_else(|| CliError::ArgumentError(\"No file\".into()))?;\n    let mut file = File::open(filepath)\n        .map_err(|err| CliError::EnvironmentError(format!(\"Failed to open file: {}\", err)))?;\n    let mut packed = Vec::new();\n    file.read_to_end(&mut packed)\n        .map_err(|err| CliError::EnvironmentError(format!(\"Failed to read file: {}\", err)))?;\n\n    let block: Block = protobuf::parse_from_bytes(&packed)\n        .map_err(|err| CliError::ParseError(format!(\"{}\", err)))?;\n    let block_header: BlockHeader = protobuf::parse_from_bytes(&block.header)\n        .map_err(|err| CliError::ParseError(format!(\"{}\", err)))?;\n    let block_id = block.header_signature.clone();\n\n    // Ensure this block is an immediate child of the current chain head\n    match blockstore.get_chain_head() {\n        Ok(chain_head) => {\n            if block_header.previous_block_id != chain_head {\n                return Err(CliError::ArgumentError(format!(\n                    \"New block must be an immediate child of the current chain head: {}\",\n                    chain_head\n                )));\n            }\n        }\n        Err(DatabaseError::NotFoundError(_)) => (),\n        Err(err) => {\n            return Err(CliError::EnvironmentError(format!(\"{}\", err)));\n        }\n    }\n\n    blockstore.put(&block).map_err(|err| {\n        CliError::ArgumentError(format!(\"Failed to put block into database: {}\", err))\n    })?;\n\n    println!(\"Block {} added\", block_id);\n    Ok(())\n}", "item_id": 6, "repo": "Capco-JayPanicker123/Sawtooth", "file": "adm/src/commands/blockstore.rs", "last_update_at": "2019-10-23T14:32:31+00:00", "question_id": "862f0f0cb9bd34f3b4ddb8afdc7dcc3abdec80c9_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn run_import_command<'a>(args: &ArgMatches<'a>) -> Result<(), CliError> {\n    let ctx = create_context()?;\n    let blockstore = open_blockstore(&ctx)?;\n    let filepath = args\n        .value_of(\"blockfile\")\n        .ok_or_else(|| CliError::ArgumentError(\"No file\".into()))?;\n    let mut file = File::open(filepath)\n        .map_err(|err| CliError::EnvironmentError(format!(\"Failed to open file: {}\", err)))?;\n    let mut packed = Vec::new();\n    file.read_to_end(&mut packed)\n        .map_err(|err| CliError::EnvironmentError(format!(\"Failed to read file: {}\", err)))?;\n    let block: Block = protobuf::parse_from_bytes(&packed)\n        .map_err(|err| CliError::ParseError(format!(\"{}\", err)))?;\n    let block_header: BlockHeader = protobuf::parse_from_bytes(&block.header)\n        .map_err(|err| CliError::ParseError(format!(\"{}\", err)))?;\n    let block_id = block.header_signature.clone();\n    // Ensure this block is an immediate child of the current chain head\n    match blockstore.get_chain_head() {\n        Ok(chain_head) => {\n            if block_header.previous_block_id != chain_head {\n                return Err(CliError::ArgumentError(format!(\n                    \"New block must be an immediate child of the current chain head: {}\",\n                    chain_head\n                )));\n            }\n        }\n        Err(DatabaseError::NotFoundError(_)) => (),\n        Err(err) => {\n            return Err(CliError::EnvironmentError(format!(\"{}\", err)));\n        }\n    }\n    blockstore.put(&block).map_err(|err| {\n        CliError::ArgumentError(format!(\"Failed to put block into database: {}\", err))\n    })?;\n    println!(\"Block {} added\", block_id);\n    Ok(())\n"]], "pred": {"ppl": 1.7522542476654053, "ppl_lower": 2.106525421142578, "ppl/lowercase_ppl": -1.3282862398719397, "ppl/zlib": 0.0009061439426752937, "Min_5.0% Prob": 5.525914993286133, "Min_10.0% Prob": 3.994212463790295, "Min_20.0% Prob": 2.5721161207732033, "Min_30.0% Prob": 1.8257790088069206, "Min_40.0% Prob": 1.397714229044961, "Min_50.0% Prob": 1.120064164766518, "Min_60.0% Prob": 0.9351844556003215}}
{"hexsha": "ff59c7ea7617a563fc51b5b5692cc80137be391a", "ext": "rs", "lang": "Rust", "content": "fn test_minus_equals() {\n        let s = to_chars(\"-=\");\n        let cur = &mut 0;\n        expect_next_token(&s, cur, Token::MinusEquals);\n    }", "item_id": 18, "repo": "jalextowle/solfix", "file": "src/lex_4_25.rs", "last_update_at": "2019-06-12T10:41:50+00:00", "question_id": "ff59c7ea7617a563fc51b5b5692cc80137be391a_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_minus_equals() {\n        let s = to_chars(\"-=\");\n        let cur = &mut 0;\n        expect_next_token(&s, cur, Token::MinusEquals);\n"]], "pred": {"ppl": 5.8324480056762695, "ppl_lower": 7.718782424926758, "ppl/lowercase_ppl": -1.1589055092291052, "ppl/zlib": 0.01574497152042465, "Min_5.0% Prob": 9.623868942260742, "Min_10.0% Prob": 8.38843650817871, "Min_20.0% Prob": 6.698739814758301, "Min_30.0% Prob": 5.195290072758993, "Min_40.0% Prob": 4.147501069307327, "Min_50.0% Prob": 3.3365158324058237, "Min_60.0% Prob": 2.8733369246605904}}
{"hexsha": "a50ac8eaf12cd8bc570c3cd645e26d649f1a20f1", "ext": "rs", "lang": "Rust", "content": "fn test_links() {\n        let mut i = 3usize;\n        while i < 512 {\n            dbg!(i, format!(\"{:032b}\", i));\n            i = next_fwd(i);\n        }\n\n        let mut i = 7usize;\n        while i > 0 {\n            dbg!(i, format!(\"{:032b}\", i));\n            i = next_bwd(i);\n        }\n    }", "item_id": 1, "repo": "feb29/cwt", "file": "src/fenwick.rs", "last_update_at": "2019-08-06T00:42:06+00:00", "question_id": "a50ac8eaf12cd8bc570c3cd645e26d649f1a20f1_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_links() {\n        let mut i = 3usize;\n        while i < 512 {\n            dbg!(i, format!(\"{:032b}\", i));\n            i = next_fwd(i);\n        }\n        let mut i = 7usize;\n        while i > 0 {\n            dbg!(i, format!(\"{:032b}\", i));\n            i = next_bwd(i);\n        }\n"]], "pred": {"ppl": 2.6321775913238525, "ppl_lower": 2.6321775913238525, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.007387873932015633, "Min_5.0% Prob": 7.714033126831055, "Min_10.0% Prob": 6.054343093525279, "Min_20.0% Prob": 4.200598164038225, "Min_30.0% Prob": 3.110367266517697, "Min_40.0% Prob": 2.408110834319483, "Min_50.0% Prob": 1.9211196682548948, "Min_60.0% Prob": 1.6131509442104777}}
{"hexsha": "ae40e35935b9c79c3de52a08d8bab950d2c150bd", "ext": "rs", "lang": "Rust", "content": "fn import_donorbox(ledger: &mut Ledger, data: &PathBuf) {\n    let stripe = ledger\n        .get_account(\"Stripe\")\n        .expect(\"Account for Stripe not found\");\n\n    let paypal = ledger\n        .get_account(\"PayPal\")\n        .expect(\"Account for PayPal not found\");\n\n    let known_donations: Vec<DonationID> = stripe\n        .transactions\n        .iter()\n        .chain(&paypal.transactions)\n        .filter_map(|x| match &x.meta {\n            TransactionMetadata::Income {\n                kind: IncomeKind::Donation(x),\n                ..\n            } => Some(x),\n            _ => None,\n        })\n        .map(Clone::clone)\n        .collect();\n\n    let mut donations_stripe: Vec<Transaction> = Vec::new();\n    let mut donations_paypal: Vec<Transaction> = Vec::new();\n\n    let mut reader = csv::Reader::from_path(data).expect(\"Could not read the CSV file\");\n\n    let records = reader.deserialize();\n    for (i, x) in records.enumerate() {\n        let x: DonorBoxRow =\n            x.unwrap_or_else(|e| panic!(\"Could not deserialize entry on entry {}!\\n{}\", i, e));\n        let mut amount = currency::Currency::from_str(&x.amount)\n            .unwrap_or_else(|e| panic!(\"Could not parse transaction amount on entry {}!\\n{}\", i, e));\n        let mut fee = currency::Currency::from_str(&x.fee)\n            .unwrap_or_else(|e| panic!(\"Could not parse fee on entry {}!\\n{}\", i, e));\n        let date = chrono::Utc\n            .datetime_from_str(&x.date.trim_end_matches(\" UTC\"), \"%Y-%m-%d %H:%M:%S\")\n            .unwrap_or_else(|e| panic!(\"Could not parse transaction date on entry {}!\\n{}\", i, e));\n\n        amount.set_symbol('$');\n        fee.set_symbol('$');\n\n        let mut hasher = crypto::sha2::Sha256::new();\n        hasher.input_str(\"DonorBox\");\n        hasher.input_str(&x.name);\n        hasher.input_str(&x.date);\n        hasher.input_str(&x.amount);\n        hasher.input_str(&x.receipt);\n\n        let mut hash = vec![0; 32];\n        hasher.result(&mut hash);\n\n        if !known_donations.contains(&hash) {\n            let meta = TransactionMetadata::Income {\n                kind: IncomeKind::Donation(hash),\n                from: x.name.to_owned(),\n            };\n\n            match x.processor.as_ref() {\n                \"stripe\" => {\n                    donations_stripe.push(Transaction {\n                        amount,\n                        date,\n                        meta,\n                        description: \"Donation made through the DonorBox platform\".to_owned(),\n                        fees: vec![Fee {\n                            amount: fee,\n                            towards: \"DonorBox Processing\".to_owned(),\n                        }],\n                    });\n                }\n                \"paypal\" | \"paypal_express\" => {\n                    donations_paypal.push(Transaction {\n                        amount,\n                        date,\n                        meta,\n                        description: \"Donation made through the DonorBox platform\".to_owned(),\n                        fees: vec![Fee {\n                            amount: fee,\n                            towards: \"DonorBox Processing\".to_owned(),\n                        }],\n                    });\n                }\n                mtd => println!(\"WARNING: Unknown donation method `{}` for donation from `{}` on {} (entry {}).\", mtd, x.name, x.date, i),\n            }\n        } else {\n            println!(\n                \"WARNING: Donation from `{}` on {} (entry {}) is already in the ledger.\",\n                x.name, x.date, i\n            );\n        }\n    }\n\n    donations_stripe.sort_by(|x, y| x.date.cmp(&y.date));\n    ledger\n        .get_account_mut(\"Stripe\")\n        .expect(\"Account for Stripe not found\")\n        .transactions\n        .append(&mut donations_stripe);\n\n    donations_paypal.sort_by(|x, y| x.date.cmp(&y.date));\n    ledger\n        .get_account_mut(\"PayPal\")\n        .expect(\"Account for PayPal not found\")\n        .transactions\n        .append(&mut donations_paypal);\n}", "item_id": 2, "repo": "fhaynes/backertrack", "file": "src/ledger/donations.rs", "last_update_at": "2019-02-21T17:20:19+00:00", "question_id": "ae40e35935b9c79c3de52a08d8bab950d2c150bd_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn import_donorbox(ledger: &mut Ledger, data: &PathBuf) {\n    let stripe = ledger\n        .get_account(\"Stripe\")\n        .expect(\"Account for Stripe not found\");\n    let paypal = ledger\n        .get_account(\"PayPal\")\n        .expect(\"Account for PayPal not found\");\n    let known_donations: Vec<DonationID> = stripe\n        .transactions\n        .iter()\n        .chain(&paypal.transactions)\n        .filter_map(|x| match &x.meta {\n            TransactionMetadata::Income {\n                kind: IncomeKind::Donation(x),\n                ..\n            } => Some(x),\n            _ => None,\n        })\n        .map(Clone::clone)\n        .collect();\n    let mut donations_stripe: Vec<Transaction> = Vec::new();\n    let mut donations_paypal: Vec<Transaction> = Vec::new();\n    let mut reader = csv::Reader::from_path(data).expect(\"Could not read the CSV file\");\n    let records = reader.deserialize();\n    for (i, x) in records.enumerate() {\n        let x: DonorBoxRow =\n            x.unwrap_or_else(|e| panic!(\"Could not deserialize entry on entry {}!\\n{}\", i, e));\n        let mut amount = currency::Currency::from_str(&x.amount)\n            .unwrap_or_else(|e| panic!(\"Could not parse transaction amount on entry {}!\\n{}\", i, e));\n        let mut fee = currency::Currency::from_str(&x.fee)\n            .unwrap_or_else(|e| panic!(\"Could not parse fee on entry {}!\\n{}\", i, e));\n        let date = chrono::Utc\n            .datetime_from_str(&x.date.trim_end_matches(\" UTC\"), \"%Y-%m-%d %H:%M:%S\")\n            .unwrap_or_else(|e| panic!(\"Could not parse transaction date on entry {}!\\n{}\", i, e));\n        amount.set_symbol('$');\n        fee.set_symbol('$');\n        let mut hasher = crypto::sha2::Sha256::new();\n        hasher.input_str(\"DonorBox\");\n        hasher.input_str(&x.name);\n        hasher.input_str(&x.date);\n        hasher.input_str(&x.amount);\n        hasher.input_str(&x.receipt);\n        let mut hash = vec![0; 32];\n        hasher.result(&mut hash);\n        if !known_donations.contains(&hash) {\n            let meta = TransactionMetadata::Income {\n                kind: IncomeKind::Donation(hash),\n                from: x.name.to_owned(),\n            };\n            match x.processor.as_ref() {\n                \"stripe\" => {\n                    donations_stripe.push(Transaction {\n                        amount,\n                        date,\n                        meta,\n                        description: \"Donation made through the DonorBox platform\".to_owned(),\n                        fees: vec![Fee {\n                            amount: fee,\n                            towards: \"DonorBox Processing\".to_owned(),\n                        }],\n                    });\n                }\n                \"paypal\" | \"paypal_express\" => {\n                    donations_paypal.push(Transaction {\n                        amount,\n                        date,\n                        meta,\n                        description: \"Donation made through the DonorBox platform\".to_owned(),\n                        fees: vec![Fee {\n                            amount: fee,\n                            towards: \"DonorBox Processing\".to_owned(),\n                        }],\n                    });\n                }\n                mtd => println!(\"WARNING: Unknown donation method `{}` for donation from `{}` on {} (entry {}).\", mtd, x.name, x.date, i),\n            }\n        } else {\n            println!(\n                \"WARNING: Donation from `{}` on {} (entry {}) is already in the ledger.\",\n                x.name, x.date, i\n            );\n        }\n    }\n    donations_stripe.sort_by(|x, y| x.date.cmp(&y.date));\n    ledger\n        .get_account_mut(\"Stripe\")\n        .expect(\"Account for Stripe not found\")\n        .transactions\n        .append(&mut donations_stripe);\n    donations_paypal.sort_by(|x, y| x.date.cmp(&y.date));\n    ledger\n        .get_account_mut(\"PayPal\")\n        .expect(\"Account for PayPal not found\")\n        .transactions\n        .append(&mut donations_paypal);\n"]], "pred": {"ppl": 1.8213011026382446, "ppl_lower": 2.042276382446289, "ppl/lowercase_ppl": -1.1909994246248246, "ppl/zlib": 0.0005401361596711076, "Min_5.0% Prob": 5.839141710131776, "Min_10.0% Prob": 4.226374387741089, "Min_20.0% Prob": 2.7110048272446092, "Min_30.0% Prob": 1.9483438496009198, "Min_40.0% Prob": 1.4888132942116348, "Min_50.0% Prob": 1.198171536753468, "Min_60.0% Prob": 1.0001399271219793}}
{"hexsha": "8da5c467b3fa5aa2cbcfc9d5127dc5dc89fc64d9", "ext": "rs", "lang": "Rust", "content": "fn empty_read() {\n        let mut recv = RecvBuf::new(std::usize::MAX);\n        assert_eq!(recv.len(), 0);\n\n        let mut buf = [0; 32];\n\n        assert_eq!(recv.pop(&mut buf), Err(Error::Done));\n    }", "item_id": 0, "repo": "quininer/quiche", "file": "src/stream.rs", "last_update_at": "2019-10-21T21:04:57+00:00", "question_id": "8da5c467b3fa5aa2cbcfc9d5127dc5dc89fc64d9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn empty_read() {\n        let mut recv = RecvBuf::new(std::usize::MAX);\n        assert_eq!(recv.len(), 0);\n        let mut buf = [0; 32];\n        assert_eq!(recv.pop(&mut buf), Err(Error::Done));\n"]], "pred": {"ppl": 2.9853274822235107, "ppl_lower": 5.072720050811768, "ppl/lowercase_ppl": -1.4847427465701284, "ppl/zlib": 0.0076483178329688805, "Min_5.0% Prob": 8.231747468312582, "Min_10.0% Prob": 6.594854116439819, "Min_20.0% Prob": 4.404265880584717, "Min_30.0% Prob": 3.326898320861485, "Min_40.0% Prob": 2.650103284466651, "Min_50.0% Prob": 2.1769040505855513, "Min_60.0% Prob": 1.8290561393220375}}
{"hexsha": "7810d7c3173239d6be3550ae2aa616701babc34b", "ext": "rs", "lang": "Rust", "content": "async fn backpressure_basic()\n{\n\tCOUNTER.with( |c| c.store( 0, Ordering::SeqCst ) );\n\n\tlet (server, client) = Endpoint::pair( 64, 64 );\n\n\tlet peera = async move\n\t{\n\t\t// Create mailbox for our handler\n\t\t//\n\t\tlet slow  = Addr::builder().spawn_local( Slow , &AsyncStd ).expect( \"spawn actor mailbox\" );\n\t\tlet slow2 = Addr::builder().spawn_local( Slow , &AsyncStd ).expect( \"spawn actor mailbox\" );\n\t\tlet after = Addr::builder().spawn_local( After, &AsyncStd ).expect( \"spawn actor mailbox\" );\n\n\t\t// Create a service map\n\t\t//\n\t\tlet mut sm = bpsm::Services::new();\n\n\t\t// Register our handlers\n\t\t//\n\t\tsm.register_handler::<Add >( slow .clone_box() );\n\t\tsm.register_handler::<Add2>( slow2.clone_box() );\n\t\tsm.register_handler::<Show>( after.clone_box() );\n\n\t\t// create peer with stream/sink\n\t\t//\n\t\tlet (mut peer, peer_mb, _peer_addr) = CborWF::create_peer\n\t\t(\n\t\t\t\"server\", server,\n\t\t\t1024, 1024,\n\t\t\tAsyncStd,\n\t\t\tSome(Arc::new( Semaphore::new(2) )),\n\t\t\tNone\n\n\t\t).expect( \"spawn peer\" );\n\n\n\t\t// register service map with peer\n\t\t//\n\t\tpeer.register_services( Arc::new( sm ) );\n\n\t\tlet handle = AsyncStd.spawn_handle_local( peer_mb.start(peer) ).expect( \"start mailbox of Peer\" );\n\t\thandle.await;\n\n\t\ttrace!( \"end of peera\" );\n\t};\n\n\n\tlet peerb = async move\n\t{\n\t\tlet (mut peera, _)  = peer_connect( client, AsyncStd, \"peer_b_to_peera\" ).await;\n\n\t\t// Call the service and receive the response\n\t\t//\n\t\tlet mut addr  = bpsm::RemoteAddr::new( peera.clone() );\n\t\tlet mut addr2 = addr.clone();\n\t\tlet mut addr3 = addr.clone();\n\n\t\tlet add1 = async move { addr .call( Add (1) ).await.expect( \"call add1\"  ) };\n\t\tlet add2 = async move { addr2.call( Add2(1) ).await.expect( \"call add2\"  ) };\n\t\tlet show = async move { addr3.call( Show    ).await.expect( \"call check\" ) };\n\n\t\tlet add1_handle = AsyncStd.spawn_handle_local( add1 ).expect( \"spawn add1\"  );\n\t\tlet add2_handle = AsyncStd.spawn_handle_local( add2 ).expect( \"spawn add2\"  );\n\n\t\t// We must make sure the adds are send before the show, but spawning is not deterministic.\n\t\t//\n\t\tDelay::new( Duration::from_millis(20) ).await;\n\t\tlet show_handle = AsyncStd.spawn_handle_local( show ).expect( \"spawn check\" );\n\n\t\tadd1_handle.await;\n\t\tadd2_handle.await;\n\n\t\t// Add1 should be guaranteed to have finished and updated the counter to 1 before\n\t\t// show can run due to back pressure. As add2 has a longer timeout, it shouldn't have\n\t\t// run yet.\n\t\t//\n\t\tassert_eq!( show_handle.await, 1 );\n\n\t\tpeera.send( CloseConnection{ remote: false, reason: \"Program end.\".to_string() } ).await.expect( \"close connection to peera\" );\n\t};\n\n\n\t// As far as I can tell, execution order is not defined, so hmm, there is no\n\t// guarantee that a is listening before b tries to connect, but it seems to work for now.\n\t//\n\tjoin( peera, peerb ).await;\n}", "item_id": 0, "repo": "thespis-rs/thespis_impl_remote", "file": "tests/backpressure.rs", "last_update_at": "2019-06-19T20:00:34+00:00", "question_id": "7810d7c3173239d6be3550ae2aa616701babc34b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn backpressure_basic()\n{\n\tCOUNTER.with( |c| c.store( 0, Ordering::SeqCst ) );\n\tlet (server, client) = Endpoint::pair( 64, 64 );\n\tlet peera = async move\n\t{\n\t\t// Create mailbox for our handler\n\t\t//\n\t\tlet slow  = Addr::builder().spawn_local( Slow , &AsyncStd ).expect( \"spawn actor mailbox\" );\n\t\tlet slow2 = Addr::builder().spawn_local( Slow , &AsyncStd ).expect( \"spawn actor mailbox\" );\n\t\tlet after = Addr::builder().spawn_local( After, &AsyncStd ).expect( \"spawn actor mailbox\" );\n\t\t// Create a service map\n\t\t//\n\t\tlet mut sm = bpsm::Services::new();\n\t\t// Register our handlers\n\t\t//\n\t\tsm.register_handler::<Add >( slow .clone_box() );\n\t\tsm.register_handler::<Add2>( slow2.clone_box() );\n\t\tsm.register_handler::<Show>( after.clone_box() );\n\t\t// create peer with stream/sink\n\t\t//\n\t\tlet (mut peer, peer_mb, _peer_addr) = CborWF::create_peer\n\t\t(\n\t\t\t\"server\", server,\n\t\t\t1024, 1024,\n\t\t\tAsyncStd,\n\t\t\tSome(Arc::new( Semaphore::new(2) )),\n\t\t\tNone\n\t\t).expect( \"spawn peer\" );\n\t\t// register service map with peer\n\t\t//\n\t\tpeer.register_services( Arc::new( sm ) );\n\t\tlet handle = AsyncStd.spawn_handle_local( peer_mb.start(peer) ).expect( \"start mailbox of Peer\" );\n\t\thandle.await;\n\t\ttrace!( \"end of peera\" );\n\t};\n\tlet peerb = async move\n\t{\n\t\tlet (mut peera, _)  = peer_connect( client, AsyncStd, \"peer_b_to_peera\" ).await;\n\t\t// Call the service and receive the response\n\t\t//\n\t\tlet mut addr  = bpsm::RemoteAddr::new( peera.clone() );\n\t\tlet mut addr2 = addr.clone();\n\t\tlet mut addr3 = addr.clone();\n\t\tlet add1 = async move { addr .call( Add (1) ).await.expect( \"call add1\"  ) };\n\t\tlet add2 = async move { addr2.call( Add2(1) ).await.expect( \"call add2\"  ) };\n\t\tlet show = async move { addr3.call( Show    ).await.expect( \"call check\" ) };\n\t\tlet add1_handle = AsyncStd.spawn_handle_local( add1 ).expect( \"spawn add1\"  );\n\t\tlet add2_handle = AsyncStd.spawn_handle_local( add2 ).expect( \"spawn add2\"  );\n\t\t// We must make sure the adds are send before the show, but spawning is not deterministic.\n\t\t//\n\t\tDelay::new( Duration::from_millis(20) ).await;\n\t\tlet show_handle = AsyncStd.spawn_handle_local( show ).expect( \"spawn check\" );\n\t\tadd1_handle.await;\n\t\tadd2_handle.await;\n\t\t// Add1 should be guaranteed to have finished and updated the counter to 1 before\n\t\t// show can run due to back pressure. As add2 has a longer timeout, it shouldn't have\n\t\t// run yet.\n\t\t//\n\t\tassert_eq!( show_handle.await, 1 );\n\t\tpeera.send( CloseConnection{ remote: false, reason: \"Program end.\".to_string() } ).await.expect( \"close connection to peera\" );\n\t};\n\t// As far as I can tell, execution order is not defined, so hmm, there is no\n\t// guarantee that a is listening before b tries to connect, but it seems to work for now.\n\t//\n\tjoin( peera, peerb ).await;\n"]], "pred": {"ppl": 3.290888786315918, "ppl_lower": 3.551771879196167, "ppl/lowercase_ppl": -1.0640460329375108, "ppl/zlib": 0.001081887080935802, "Min_5.0% Prob": 8.491270196204091, "Min_10.0% Prob": 6.73034099036572, "Min_20.0% Prob": 4.843327345801335, "Min_30.0% Prob": 3.6983014477623835, "Min_40.0% Prob": 2.9084159397408547, "Min_50.0% Prob": 2.368512776456117, "Min_60.0% Prob": 1.9844953937768985}}
{"hexsha": "4ce4fa3770f043bf602d3076f9b8b92b67fad2ea", "ext": "rs", "lang": "Rust", "content": "fn run_meal_server(listen_address: &str,\n                   i_transport_factory: Box<TTransportFactory>,\n                   i_protocol_factory: Box<TInputProtocolFactory>,\n                   o_transport_factory: Box<TTransportFactory>,\n                   o_protocol_factory: Box<TOutputProtocolFactory>)\n                   -> thrift::Result<()> {\n    let processor = MealServiceSyncProcessor::new(PartHandler {});\n    let mut server = TSimpleServer::new(i_transport_factory,\n                                        i_protocol_factory,\n                                        o_transport_factory,\n                                        o_protocol_factory,\n                                        processor);\n\n    server.listen(listen_address)\n}", "item_id": 1, "repo": "przygienda/thrift-rust-thrift-include-and-custom-trait-support", "file": "lib/rs/test/src/bin/kitchen_sink_server.rs", "last_update_at": "2019-03-19T15:47:42+00:00", "question_id": "4ce4fa3770f043bf602d3076f9b8b92b67fad2ea_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn run_meal_server(listen_address: &str,\n                   i_transport_factory: Box<TTransportFactory>,\n                   i_protocol_factory: Box<TInputProtocolFactory>,\n                   o_transport_factory: Box<TTransportFactory>,\n                   o_protocol_factory: Box<TOutputProtocolFactory>)\n                   -> thrift::Result<()> {\n    let processor = MealServiceSyncProcessor::new(PartHandler {});\n    let mut server = TSimpleServer::new(i_transport_factory,\n                                        i_protocol_factory,\n                                        o_transport_factory,\n                                        o_protocol_factory,\n                                        processor);\n    server.listen(listen_address)\n"]], "pred": {"ppl": 2.3458938598632812, "ppl_lower": 3.4134747982025146, "ppl/lowercase_ppl": -1.4398721727286725, "ppl/zlib": 0.0034945348614047454, "Min_5.0% Prob": 8.722035884857178, "Min_10.0% Prob": 6.398141398149378, "Min_20.0% Prob": 3.9594785255544327, "Min_30.0% Prob": 2.8329543272654214, "Min_40.0% Prob": 2.1281550057988237, "Min_50.0% Prob": 1.7133879153122908, "Min_60.0% Prob": 1.4316938600719915}}
{"hexsha": "9aacdbe51d873bcdceab2a7cc16e8a62fda74071", "ext": "rs", "lang": "Rust", "content": "fn slice_x1000(b: &mut Bencher) {\n    let buf = HeapRb::<u64>::new(RB_SIZE);\n    let (mut prod, mut cons) = buf.split();\n    prod.push_slice(&[1; 12]);\n    let mut data = [1; 1000];\n    b.iter(|| {\n        prod.push_slice(&data);\n        cons.pop_slice(&mut data);\n    });\n    black_box(data);\n}", "item_id": 2, "repo": "nthend/ringbuf", "file": "src/benchmarks/slice.rs", "last_update_at": "2019-08-14T13:35:13+00:00", "question_id": "9aacdbe51d873bcdceab2a7cc16e8a62fda74071_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn slice_x1000(b: &mut Bencher) {\n    let buf = HeapRb::<u64>::new(RB_SIZE);\n    let (mut prod, mut cons) = buf.split();\n    prod.push_slice(&[1; 12]);\n    let mut data = [1; 1000];\n    b.iter(|| {\n        prod.push_slice(&data);\n        cons.pop_slice(&mut data);\n    });\n    black_box(data);\n"]], "pred": {"ppl": 3.045133590698242, "ppl_lower": 3.9145073890686035, "ppl/lowercase_ppl": -1.225536259398861, "ppl/zlib": 0.005830077342146575, "Min_5.0% Prob": 7.975805362065633, "Min_10.0% Prob": 6.155546148618062, "Min_20.0% Prob": 4.314219083786011, "Min_30.0% Prob": 3.3251758395014583, "Min_40.0% Prob": 2.6283724665641786, "Min_50.0% Prob": 2.15668810123489, "Min_60.0% Prob": 1.8418161118030547}}
{"hexsha": "927c269aa7f041cc059ea7bae05a9da3f8a70ad7", "ext": "rs", "lang": "Rust", "content": "fn test_eval_int(){\n        use std::fs;\n        let unparsed_query = fs::read_to_string(\"tests/data/qfuflia.smt2\").expect(\"cannot read file\");\n        let mut query = Query::new();\n        query.parse_query(&unparsed_query).expect(\"cannot parse file\");\n        \n        let unparsed_answer = fs::read_to_string(\"tests/data/qfuflia_result.smt2\").expect(\"cannot read file\");\n        let s = query.parse_answer(&unparsed_answer).expect(\"cannot parse file\");\n        assert!(query.eval(&s).unwrap());\n    }", "item_id": 0, "repo": "FedericoAureliano/llama", "file": "src/evl/mod.rs", "last_update_at": "2019-12-15T06:32:59+00:00", "question_id": "927c269aa7f041cc059ea7bae05a9da3f8a70ad7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_eval_int(){\n        use std::fs;\n        let unparsed_query = fs::read_to_string(\"tests/data/qfuflia.smt2\").expect(\"cannot read file\");\n        let mut query = Query::new();\n        query.parse_query(&unparsed_query).expect(\"cannot parse file\");\n        let unparsed_answer = fs::read_to_string(\"tests/data/qfuflia_result.smt2\").expect(\"cannot read file\");\n        let s = query.parse_answer(&unparsed_answer).expect(\"cannot parse file\");\n        assert!(query.eval(&s).unwrap());\n"]], "pred": {"ppl": 2.9521899223327637, "ppl_lower": 3.104520797729492, "ppl/lowercase_ppl": -1.0464756895491976, "ppl/zlib": 0.005229696818851656, "Min_5.0% Prob": 8.233741521835327, "Min_10.0% Prob": 6.364287346601486, "Min_20.0% Prob": 4.466231808066368, "Min_30.0% Prob": 3.3688075145085654, "Min_40.0% Prob": 2.667775840498507, "Min_50.0% Prob": 2.147451805939645, "Min_60.0% Prob": 1.802885265502426}}
{"hexsha": "0666d72748aed0aa7b92794f5c4831a43dcbd431", "ext": "rs", "lang": "Rust", "content": "pub fn keygen() -> [u8; KEY] {\n    let mut k = [0u8; KEY];\n    crypto_random(&mut k);\n    k\n}", "item_id": 3, "repo": "oniproject/tto", "file": "src/crypto/mod.rs", "last_update_at": "2019-12-04T21:29:43+00:00", "question_id": "0666d72748aed0aa7b92794f5c4831a43dcbd431_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn keygen() -> [u8; KEY] {\n    let mut k = [0u8; KEY];\n    crypto_random(&mut k);\n    k\n"]], "pred": {"ppl": 4.5074005126953125, "ppl_lower": 4.926723480224609, "ppl/lowercase_ppl": -1.0590770651781358, "ppl/zlib": 0.018141212100574285, "Min_5.0% Prob": 10.028007507324219, "Min_10.0% Prob": 8.413847804069519, "Min_20.0% Prob": 6.066770076751709, "Min_30.0% Prob": 4.751775453488032, "Min_40.0% Prob": 3.7312525864690542, "Min_50.0% Prob": 3.0443319730460643, "Min_60.0% Prob": 2.555648027919233}}
{"hexsha": "3a7845b9ce83d59a7ac3a5d0a07ef9559b8e0d9f", "ext": "rs", "lang": "Rust", "content": "pub fn is_lambda() -> bool {\n    #[cfg(feature = \"local\")]\n    {\n        std::env::var_os(\"AWS_LAMBDA_RUNTIME_API\").is_some()\n    }\n\n    #[cfg(not(feature = \"local\"))]\n    {\n        true\n    }\n}", "item_id": 1, "repo": "Skirmisher/lambda-http-local", "file": "src/lib.rs", "last_update_at": "2019-05-26T23:10:33+00:00", "question_id": "3a7845b9ce83d59a7ac3a5d0a07ef9559b8e0d9f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn is_lambda() -> bool {\n    #[cfg(feature = \"local\")]\n    {\n        std::env::var_os(\"AWS_LAMBDA_RUNTIME_API\").is_some()\n    }\n    #[cfg(not(feature = \"local\"))]\n    {\n        true\n    }\n"]], "pred": {"ppl": 2.406998634338379, "ppl_lower": 2.813105344772339, "ppl/lowercase_ppl": -1.1774952545162514, "ppl/zlib": 0.006185778812886832, "Min_5.0% Prob": 9.880714098612467, "Min_10.0% Prob": 7.018990652901786, "Min_20.0% Prob": 4.234538471698761, "Min_30.0% Prob": 2.9021317615457205, "Min_40.0% Prob": 2.2461163378010194, "Min_50.0% Prob": 1.7779005023307706, "Min_60.0% Prob": 1.4698122482463394}}
{"hexsha": "56c98fa0761a4f26afa8494785b0973862ea2945", "ext": "rs", "lang": "Rust", "content": "pub fn load_block_report(path: &str) -> Result<BlockReport> {\n    println!(\"Reading BlockReport from blocks.json\");\n    let block_report = read_to_string(path).context(\"blocks report `blocks.json` not found\")?;\n    serde_json::from_str::<BlockReport>(&block_report).map_err(|err| err.into())\n}", "item_id": 0, "repo": "fredsterorg/feather", "file": "libcraft/generators/src/common.rs", "last_update_at": "2019-11-01T20:06:33+00:00", "question_id": "56c98fa0761a4f26afa8494785b0973862ea2945_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn load_block_report(path: &str) -> Result<BlockReport> {\n    println!(\"Reading BlockReport from blocks.json\");\n    let block_report = read_to_string(path).context(\"blocks report `blocks.json` not found\")?;\n    serde_json::from_str::<BlockReport>(&block_report).map_err(|err| err.into())\n"]], "pred": {"ppl": 3.530608892440796, "ppl_lower": 4.487224578857422, "ppl/lowercase_ppl": -1.190067115329658, "ppl/zlib": 0.006604556789773882, "Min_5.0% Prob": 10.216754913330078, "Min_10.0% Prob": 7.978420681423611, "Min_20.0% Prob": 5.159000384180169, "Min_30.0% Prob": 3.927058164562498, "Min_40.0% Prob": 3.0773806681758478, "Min_50.0% Prob": 2.4954165775949755, "Min_60.0% Prob": 2.1175671234204057}}
{"hexsha": "a50fef61e9c80433c5337e43ef2b50fa0e7fad72", "ext": "rs", "lang": "Rust", "content": "fn knights_in_corners() {\n    let knights = Square::from_pos(Rank::A, File::First).as_bb()\n        | Square::from_pos(Rank::H, File::Eighth).as_bb();\n    let attacks = attack_targets(knights);\n    assert_eq!(0x0020400000020400, attacks.0);\n}", "item_id": 1, "repo": "nagyf/rs-chess", "file": "src/engine/board/piece/knight/tests.rs", "last_update_at": "2019-03-23T10:31:21+00:00", "question_id": "a50fef61e9c80433c5337e43ef2b50fa0e7fad72_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn knights_in_corners() {\n    let knights = Square::from_pos(Rank::A, File::First).as_bb()\n        | Square::from_pos(Rank::H, File::Eighth).as_bb();\n    let attacks = attack_targets(knights);\n    assert_eq!(0x0020400000020400, attacks.0);\n"]], "pred": {"ppl": 4.048541069030762, "ppl_lower": 4.86607027053833, "ppl/lowercase_ppl": -1.131533044454576, "ppl/zlib": 0.008906729849370285, "Min_5.0% Prob": 7.834725666046142, "Min_10.0% Prob": 6.406542253494263, "Min_20.0% Prob": 5.078451204299927, "Min_30.0% Prob": 4.077605668703715, "Min_40.0% Prob": 3.2336565343345085, "Min_50.0% Prob": 2.7133093359423617, "Min_60.0% Prob": 2.323496080324298}}
{"hexsha": "8575b68d0fa746beecb98c7add4a8f904d5f4f05", "ext": "rs", "lang": "Rust", "content": "pub fn get_last_segid_stakes(\n    SomeUser: komodorpcutil::KomodoRPC,\n    depth: u32,\n) -> Result<String, reqwest::Error> {\n    let method_name: String = String::from(\"getlastsegidstakes\");\n    let method_body: String = String::from(format!(\"[{}]\", depth));\n    let data: String = String::from(komodorpcutil::generate_body(\n        SomeUser.clone(),\n        method_name,\n        method_body,\n    ));\n    komodorpcutil::request(SomeUser.clone(), data)\n}", "item_id": 11, "repo": "sudipghale/Komodo-RPC-API-Rust", "file": "src/komodo/blockchain.rs", "last_update_at": "2019-12-07T03:17:44+00:00", "question_id": "8575b68d0fa746beecb98c7add4a8f904d5f4f05_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_last_segid_stakes(\n    SomeUser: komodorpcutil::KomodoRPC,\n    depth: u32,\n) -> Result<String, reqwest::Error> {\n    let method_name: String = String::from(\"getlastsegidstakes\");\n    let method_body: String = String::from(format!(\"[{}]\", depth));\n    let data: String = String::from(komodorpcutil::generate_body(\n        SomeUser.clone(),\n        method_name,\n        method_body,\n    ));\n    komodorpcutil::request(SomeUser.clone(), data)\n"]], "pred": {"ppl": 2.8615047931671143, "ppl_lower": 3.779986619949341, "ppl/lowercase_ppl": -1.2647771507438488, "ppl/zlib": 0.004398944091714015, "Min_5.0% Prob": 10.785460335867745, "Min_10.0% Prob": 7.607165145874023, "Min_20.0% Prob": 4.678402288754781, "Min_30.0% Prob": 3.3217622174157038, "Min_40.0% Prob": 2.5715384423732757, "Min_50.0% Prob": 2.0857009477416675, "Min_60.0% Prob": 1.7480490166280005}}
{"hexsha": "793c4bcf09ef5b7b6fc9e715a78847c15658f9b5", "ext": "rs", "lang": "Rust", "content": "fn relay_addr(\n    json_cfg: &str,\n) -> Result<String, Error> {\n    let config = MobileWalletCfg::from_str(json_cfg)?;\n    let wallet = get_wallet_instance(config.clone())?;\n    Ok(grinrelay_address(\n        wallet.clone(),\n        config.grinrelay_config.clone().unwrap_or_default(),\n    )?)\n}", "item_id": 28, "repo": "garyyu/grinwallet-nodejs", "file": "native/src/lib.rs", "last_update_at": "2019-11-09T09:19:19+00:00", "question_id": "793c4bcf09ef5b7b6fc9e715a78847c15658f9b5_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn relay_addr(\n    json_cfg: &str,\n) -> Result<String, Error> {\n    let config = MobileWalletCfg::from_str(json_cfg)?;\n    let wallet = get_wallet_instance(config.clone())?;\n    Ok(grinrelay_address(\n        wallet.clone(),\n        config.grinrelay_config.clone().unwrap_or_default(),\n    )?)\n"]], "pred": {"ppl": 3.4366931915283203, "ppl_lower": 5.10383939743042, "ppl/lowercase_ppl": -1.3203566105501958, "ppl/zlib": 0.0066730255541915745, "Min_5.0% Prob": 9.272310733795166, "Min_10.0% Prob": 7.242587161064148, "Min_20.0% Prob": 4.851211286726452, "Min_30.0% Prob": 3.6569057777523994, "Min_40.0% Prob": 2.9639988342920938, "Min_50.0% Prob": 2.423408914849443, "Min_60.0% Prob": 2.0464517305372283}}
{"hexsha": "332f83b92e5efc550367fadde9ff23955e525dd6", "ext": "rs", "lang": "Rust", "content": "fn test_generate_continuous() {\n        let grad_desc = color::GradientDescriptor::new(vec![\n            Lch::from_color(color::ColorType::new(0., 0., 0., 1.)),\n            Lch::from_color(color::ColorType::new(0.5, 0.5, 0.5, 1.)),\n            Lch::from_color(color::ColorType::new(1., 1., 1., 1.)),\n        ]);\n\n        let colors = grad_desc.generate(12, color::GradientGeneratorType::Continuous);\n        assert_eq!(colors.len(), 12);\n\n        assert_eq!(colors[0].chroma, 0.0);\n        assert_eq!(colors[4].chroma, 0.0);\n        assert_eq!(colors[8].chroma, 0.0);\n    }", "item_id": 3, "repo": "jwoos/go_rainbowgif", "file": "src/color.rs", "last_update_at": "2019-04-23T05:10:19+00:00", "question_id": "332f83b92e5efc550367fadde9ff23955e525dd6_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_generate_continuous() {\n        let grad_desc = color::GradientDescriptor::new(vec![\n            Lch::from_color(color::ColorType::new(0., 0., 0., 1.)),\n            Lch::from_color(color::ColorType::new(0.5, 0.5, 0.5, 1.)),\n            Lch::from_color(color::ColorType::new(1., 1., 1., 1.)),\n        ]);\n        let colors = grad_desc.generate(12, color::GradientGeneratorType::Continuous);\n        assert_eq!(colors.len(), 12);\n        assert_eq!(colors[0].chroma, 0.0);\n        assert_eq!(colors[4].chroma, 0.0);\n        assert_eq!(colors[8].chroma, 0.0);\n"]], "pred": {"ppl": 2.194856882095337, "ppl_lower": 2.362070322036743, "ppl/lowercase_ppl": -1.0933978805326374, "ppl/zlib": 0.003525187635078549, "Min_5.0% Prob": 7.765062999725342, "Min_10.0% Prob": 5.544991867882865, "Min_20.0% Prob": 3.529062409733617, "Min_30.0% Prob": 2.532162035887058, "Min_40.0% Prob": 1.941399692718325, "Min_50.0% Prob": 1.5653914716949158, "Min_60.0% Prob": 1.316366953538874}}
{"hexsha": "0bb0cd84432a73281ff4d9a3f145225979d07bcb", "ext": "rs", "lang": "Rust", "content": "async fn newterm(item: web::Json<Term>) -> Result<HttpResponse> {\n    let Term { word, lambda: _ } = item.into_inner();\n    let lambda = match lightblue(&word) {\n        Ok(lambda) => lambda,\n        Err(error) => {\n            let error_msg = format!(\"{:?}\", error);\n            return Ok(HttpResponse::InternalServerError().body(error_msg));\n        }\n    };\n    let ret_term = Term { word, lambda };\n    Ok(HttpResponse::Ok().json(ret_term))\n}", "item_id": 0, "repo": "denjiry/pindilogji", "file": "pindilogji-server/src/main.rs", "last_update_at": "2019-08-03T16:54:25+00:00", "question_id": "0bb0cd84432a73281ff4d9a3f145225979d07bcb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn newterm(item: web::Json<Term>) -> Result<HttpResponse> {\n    let Term { word, lambda: _ } = item.into_inner();\n    let lambda = match lightblue(&word) {\n        Ok(lambda) => lambda,\n        Err(error) => {\n            let error_msg = format!(\"{:?}\", error);\n            return Ok(HttpResponse::InternalServerError().body(error_msg));\n        }\n    };\n    let ret_term = Term { word, lambda };\n    Ok(HttpResponse::Ok().json(ret_term))\n"]], "pred": {"ppl": 3.187548875808716, "ppl_lower": 4.854423522949219, "ppl/lowercase_ppl": -1.3628529632757878, "ppl/zlib": 0.004582024679660215, "Min_5.0% Prob": 10.095268408457438, "Min_10.0% Prob": 7.798109879860511, "Min_20.0% Prob": 5.0336734718746605, "Min_30.0% Prob": 3.68713783621788, "Min_40.0% Prob": 2.8367463129538075, "Min_50.0% Prob": 2.319482847825805, "Min_60.0% Prob": 1.92758893640137}}
{"hexsha": "470b6e8f11f1eb1b64b8a5753f071a6be0cc57b7", "ext": "rs", "lang": "Rust", "content": "pub unsafe fn list_node_at(l: *const list, mut index: libc::c_uint) -> *mut node {\n    /* if there's no data in the list, fail */\n    if (*l).list.is_null() {\n        return 0 as *mut node;\n    } else {\n        let mut current: *mut node = (*l).list;\n        while index > 0i32 as libc::c_uint {\n            if (*current).next.is_null() {\n                return 0 as *mut node;\n            } else {\n                current = (*current).next;\n                index = index.wrapping_sub(1)\n            }\n        }\n        return current;\n    };\n}", "item_id": 2, "repo": "palfrey/ashuffle-rs", "file": "src/list.rs", "last_update_at": "2019-05-03T14:43:08+00:00", "question_id": "470b6e8f11f1eb1b64b8a5753f071a6be0cc57b7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe fn list_node_at(l: *const list, mut index: libc::c_uint) -> *mut node {\n    /* if there's no data in the list, fail */\n    if (*l).list.is_null() {\n        return 0 as *mut node;\n    } else {\n        let mut current: *mut node = (*l).list;\n        while index > 0i32 as libc::c_uint {\n            if (*current).next.is_null() {\n                return 0 as *mut node;\n            } else {\n                current = (*current).next;\n                index = index.wrapping_sub(1)\n            }\n        }\n        return current;\n    };\n"]], "pred": {"ppl": 2.250028371810913, "ppl_lower": 2.250028371810913, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.003337213275022907, "Min_5.0% Prob": 6.994732081890106, "Min_10.0% Prob": 5.494107597014484, "Min_20.0% Prob": 3.636219690827762, "Min_30.0% Prob": 2.6248421692380717, "Min_40.0% Prob": 1.9968255201111669, "Min_50.0% Prob": 1.6205293602461732, "Min_60.0% Prob": 1.3589687870399465}}
{"hexsha": "e62053eb29d1ca24129f50b429669912dabb72ac", "ext": "rs", "lang": "Rust", "content": "fn put_var_uint(&mut self, uint: u64) {\n        let size = predict_var_uint_size(uint);\n        self.put_var_octet_string_length(size);\n        self.put_uint_be(uint, size);\n    }", "item_id": 2, "repo": "pensivej/interledger-rs", "file": "crates/interledger-packet/src/oer.rs", "last_update_at": "2019-08-06T07:59:44+00:00", "question_id": "e62053eb29d1ca24129f50b429669912dabb72ac_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn put_var_uint(&mut self, uint: u64) {\n        let size = predict_var_uint_size(uint);\n        self.put_var_octet_string_length(size);\n        self.put_uint_be(uint, size);\n"]], "pred": {"ppl": 3.7620017528533936, "ppl_lower": 3.7620017528533936, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.011622378919432498, "Min_5.0% Prob": 9.598846753438314, "Min_10.0% Prob": 7.9506105581919355, "Min_20.0% Prob": 5.635321011910071, "Min_30.0% Prob": 4.263030748618276, "Min_40.0% Prob": 3.2553342007673702, "Min_50.0% Prob": 2.61022367531603, "Min_60.0% Prob": 2.2266150957498794}}
{"hexsha": "8a18ef3dfa3e641a7a4affec16f2333c7cb41eaa", "ext": "rs", "lang": "Rust", "content": "fn assign(\n    context: &mut Context,\n    result: &mut Block,\n    sp!(loc, ta_): T::Assign,\n    rvalue_ty: &H::SingleType,\n) -> ReachableResult<(H::LValue, Block)> {\n    use H::{LValue_ as L, UnannotatedExp_ as E};\n    use T::Assign_ as A;\n    let mut after = Block::new();\n    let l_ = match ta_ {\n        A::Ignore => L::Ignore,\n        A::Var(v, st) => L::Var(\n            context.remapped_local(v),\n            Box::new(single_type(context, st)),\n        ),\n        A::Unpack(_m, s, tbs, tfields) => {\n            let bs = base_types(context, tbs);\n\n            let mut fields = vec![];\n            for (decl_idx, f, bt, tfa) in assign_fields(context, &s, tfields) {\n                assert!(fields.len() == decl_idx);\n                let st = &H::SingleType_::base(bt);\n                let (fa, mut fafter) = match assign(context, result, tfa, st) {\n                    Unreachable { report, loc } => return Unreachable { report, loc },\n                    Reachable(res) => res,\n                };\n                after.append(&mut fafter);\n                fields.push((f, fa))\n            }\n            L::Unpack(s, bs, fields)\n        }\n        A::BorrowUnpack(mut_, _m, s, _tss, tfields) => {\n            let tmp = context.new_temp(loc, rvalue_ty.clone());\n            let copy_tmp = || {\n                let copy_tmp_ = E::Copy {\n                    from_user: false,\n                    var: tmp.clone(),\n                };\n                H::exp(H::Type_::single(rvalue_ty.clone()), sp(loc, copy_tmp_))\n            };\n            let fields = assign_fields(context, &s, tfields).into_iter().enumerate();\n            for (idx, (decl_idx, f, bt, tfa)) in fields {\n                assert!(idx == decl_idx);\n                let floc = tfa.loc;\n                let borrow_ = E::Borrow(mut_, Box::new(copy_tmp()), f);\n                let borrow = H::exp(H::Type_::base(bt), sp(floc, borrow_));\n                match assign_command(context, &mut after, floc, sp(floc, vec![tfa]), borrow) {\n                    Unreachable { report, loc } => return Unreachable { report, loc },\n                    Reachable(()) => (),\n                };\n            }\n            L::Var(tmp, Box::new(rvalue_ty.clone()))\n        }\n    };\n    Reachable((sp(loc, l_), after))\n}", "item_id": 15, "repo": "marciseli/libra", "file": "language/move-lang/src/hlir/translate.rs", "last_update_at": "2019-07-11T21:59:32+00:00", "question_id": "8a18ef3dfa3e641a7a4affec16f2333c7cb41eaa_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn assign(\n    context: &mut Context,\n    result: &mut Block,\n    sp!(loc, ta_): T::Assign,\n    rvalue_ty: &H::SingleType,\n) -> ReachableResult<(H::LValue, Block)> {\n    use H::{LValue_ as L, UnannotatedExp_ as E};\n    use T::Assign_ as A;\n    let mut after = Block::new();\n    let l_ = match ta_ {\n        A::Ignore => L::Ignore,\n        A::Var(v, st) => L::Var(\n            context.remapped_local(v),\n            Box::new(single_type(context, st)),\n        ),\n        A::Unpack(_m, s, tbs, tfields) => {\n            let bs = base_types(context, tbs);\n            let mut fields = vec![];\n            for (decl_idx, f, bt, tfa) in assign_fields(context, &s, tfields) {\n                assert!(fields.len() == decl_idx);\n                let st = &H::SingleType_::base(bt);\n                let (fa, mut fafter) = match assign(context, result, tfa, st) {\n                    Unreachable { report, loc } => return Unreachable { report, loc },\n                    Reachable(res) => res,\n                };\n                after.append(&mut fafter);\n                fields.push((f, fa))\n            }\n            L::Unpack(s, bs, fields)\n        }\n        A::BorrowUnpack(mut_, _m, s, _tss, tfields) => {\n            let tmp = context.new_temp(loc, rvalue_ty.clone());\n            let copy_tmp = || {\n                let copy_tmp_ = E::Copy {\n                    from_user: false,\n                    var: tmp.clone(),\n                };\n                H::exp(H::Type_::single(rvalue_ty.clone()), sp(loc, copy_tmp_))\n            };\n            let fields = assign_fields(context, &s, tfields).into_iter().enumerate();\n            for (idx, (decl_idx, f, bt, tfa)) in fields {\n                assert!(idx == decl_idx);\n                let floc = tfa.loc;\n                let borrow_ = E::Borrow(mut_, Box::new(copy_tmp()), f);\n                let borrow = H::exp(H::Type_::base(bt), sp(floc, borrow_));\n                match assign_command(context, &mut after, floc, sp(floc, vec![tfa]), borrow) {\n                    Unreachable { report, loc } => return Unreachable { report, loc },\n                    Reachable(()) => (),\n                };\n            }\n            L::Var(tmp, Box::new(rvalue_ty.clone()))\n        }\n    };\n    Reachable((sp(loc, l_), after))\n"]], "pred": {"ppl": 2.46138858795166, "ppl_lower": 2.8800048828125, "ppl/lowercase_ppl": -1.174377548754821, "ppl/zlib": 0.0011805054486761666, "Min_5.0% Prob": 7.1412018775939945, "Min_10.0% Prob": 5.565175845589437, "Min_20.0% Prob": 3.844384716107295, "Min_30.0% Prob": 2.8498608425398855, "Min_40.0% Prob": 2.2140234467553928, "Min_50.0% Prob": 1.7915100647167788, "Min_60.0% Prob": 1.5013911218962053}}
{"hexsha": "ad88834532221493e9aed8fbbd37c0207d11156b", "ext": "rs", "lang": "Rust", "content": "fn ind_mut() {\n    let mut x = RwLockStorage::new();\n    x.allocate_for::<usize>();\n    x.insert(0usize).unwrap();\n    x.insert(1usize).unwrap();\n    {\n        let y = x.get::<&mut [usize]>();\n        ok!(y, 0, [0])[0] = 10;\n    }\n    {\n        let y = x.get::<&mut [usize]>();\n        ok!(y, 1, [1]);\n    }\n    {\n        let y = x.get::<&mut [usize]>();\n        let z = x.get::<&mut [usize]>();\n        err!(z, ErrorDesc::BorrowedIncompatibly);\n        ok!(y, 10, [0]);\n    }\n}", "item_id": 8, "repo": "OptimisticPeach/restor", "file": "tests/rwlock.rs", "last_update_at": "2019-08-08T12:08:36+00:00", "question_id": "ad88834532221493e9aed8fbbd37c0207d11156b_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn ind_mut() {\n    let mut x = RwLockStorage::new();\n    x.allocate_for::<usize>();\n    x.insert(0usize).unwrap();\n    x.insert(1usize).unwrap();\n    {\n        let y = x.get::<&mut [usize]>();\n        ok!(y, 0, [0])[0] = 10;\n    }\n    {\n        let y = x.get::<&mut [usize]>();\n        ok!(y, 1, [1]);\n    }\n    {\n        let y = x.get::<&mut [usize]>();\n        let z = x.get::<&mut [usize]>();\n        err!(z, ErrorDesc::BorrowedIncompatibly);\n        ok!(y, 10, [0]);\n    }\n"]], "pred": {"ppl": 3.266549825668335, "ppl_lower": 3.573681116104126, "ppl/lowercase_ppl": -1.0759138757830664, "ppl/zlib": 0.005610115301972456, "Min_5.0% Prob": 9.291338920593262, "Min_10.0% Prob": 7.325037932395935, "Min_20.0% Prob": 4.927304189379623, "Min_30.0% Prob": 3.7059994222687895, "Min_40.0% Prob": 2.8857184503136613, "Min_50.0% Prob": 2.356767993858632, "Min_60.0% Prob": 1.9656106762709171}}
{"hexsha": "35cb44c1572d5b6f29c6b4f71d50258804b87694", "ext": "rs", "lang": "Rust", "content": "fn observables_csv(observables: &ObservablesOutput, project: &str) -> Result<()> {\n    let filename = format!(\n        \"{}/observables_{}.csv\",\n        get_project_dir(project),\n        observables.state\n    );\n    let mut buffer = csv::Writer::from_path(&filename)\n        .chain_err(|| ErrorKind::CreateFile(filename.to_string()))?;\n    buffer\n        .serialize(observables)\n        .chain_err(|| ErrorKind::Serialize)?;\n    buffer.flush().chain_err(|| ErrorKind::Flush)?;\n    Ok(())\n}", "item_id": 18, "repo": "Libbum/Wafer", "file": "src/output.rs", "last_update_at": "2019-11-29T12:45:29+00:00", "question_id": "35cb44c1572d5b6f29c6b4f71d50258804b87694_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn observables_csv(observables: &ObservablesOutput, project: &str) -> Result<()> {\n    let filename = format!(\n        \"{}/observables_{}.csv\",\n        get_project_dir(project),\n        observables.state\n    );\n    let mut buffer = csv::Writer::from_path(&filename)\n        .chain_err(|| ErrorKind::CreateFile(filename.to_string()))?;\n    buffer\n        .serialize(observables)\n        .chain_err(|| ErrorKind::Serialize)?;\n    buffer.flush().chain_err(|| ErrorKind::Flush)?;\n    Ok(())\n"]], "pred": {"ppl": 2.4595212936401367, "ppl_lower": 3.5719387531280518, "ppl/lowercase_ppl": -1.4146173042608567, "ppl/zlib": 0.0035018160892091523, "Min_5.0% Prob": 8.245190347943987, "Min_10.0% Prob": 5.825687948862711, "Min_20.0% Prob": 3.786696362495422, "Min_30.0% Prob": 2.830465825398763, "Min_40.0% Prob": 2.2332741330067316, "Min_50.0% Prob": 1.7941648718459826, "Min_60.0% Prob": 1.5021113800498975}}
{"hexsha": "3cbe789fd0fb7cd7d9ee871974f5002a9a73c56c", "ext": "rs", "lang": "Rust", "content": "fn null_key() {\n        let mut hm = BTreeMap::new();\n        let lol: Option<i32> = None;\n        hm.insert(lol, 1337);\n        let tr = to_transit_json(hm);\n\n        assert_eq!(json!([\"^\", \"~_\", 1337]), tr);\n    }", "item_id": 5, "repo": "fominok/transit-rs", "file": "src/ser/json.rs", "last_update_at": "2019-06-23T09:38:53+00:00", "question_id": "3cbe789fd0fb7cd7d9ee871974f5002a9a73c56c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn null_key() {\n        let mut hm = BTreeMap::new();\n        let lol: Option<i32> = None;\n        hm.insert(lol, 1337);\n        let tr = to_transit_json(hm);\n        assert_eq!(json!([\"^\", \"~_\", 1337]), tr);\n"]], "pred": {"ppl": 5.2136149406433105, "ppl_lower": 6.007122039794922, "ppl/lowercase_ppl": -1.0857957894136085, "ppl/zlib": 0.01058508629319001, "Min_5.0% Prob": 9.062771797180176, "Min_10.0% Prob": 7.539573351542155, "Min_20.0% Prob": 6.20798921585083, "Min_30.0% Prob": 4.963892548172562, "Min_40.0% Prob": 3.975366496377521, "Min_50.0% Prob": 3.2803483731216856, "Min_60.0% Prob": 2.7643529549241066}}
{"hexsha": "531b10ba9ca02ffba834fe974f8d3154387ef543", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let s = [120, 0].into();\n    println!(\"{}\", s);\n    // let four_k_bytes = 1024 * 4;\n    // let f = File::open(\"aidans_theme-inst.wav\").unwrap();\n    // let mut buf: Vec<u8> = Vec::<u8>::with_capacity(four_k_bytes);\n\n    // let mut i = 0;\n\n    // for byte in f.bytes() {\n    //     buf.push(byte.unwrap());\n    //     i += 1;\n    //     if i % four_k_bytes == 0 {\n    //         println!(\"{}K bytes read\", i / four_k_bytes);\n    //     }\n    // }\n\n    // println!(\"Length: {}\", buf.len());\n    // let mut reader = BufReader::with_capacity(4, f);\n\n    // loop {\n    //     match reader.fill_buf() {\n    //         Ok(_) => println!(\"{:?}\", reader.buffer()),\n    //         _ => break\n    //     }\n    // }\n}", "item_id": 0, "repo": "bnert/monorepo", "file": "projects/learning-rust/filereader.rs", "last_update_at": "2019-10-28T22:48:39+00:00", "question_id": "531b10ba9ca02ffba834fe974f8d3154387ef543_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let s = [120, 0].into();\n    println!(\"{}\", s);\n    // let four_k_bytes = 1024 * 4;\n    // let f = File::open(\"aidans_theme-inst.wav\").unwrap();\n    // let mut buf: Vec<u8> = Vec::<u8>::with_capacity(four_k_bytes);\n    // let mut i = 0;\n    // for byte in f.bytes() {\n    //     buf.push(byte.unwrap());\n    //     i += 1;\n    //     if i % four_k_bytes == 0 {\n    //         println!(\"{}K bytes read\", i / four_k_bytes);\n    //     }\n    // }\n    // println!(\"Length: {}\", buf.len());\n    // let mut reader = BufReader::with_capacity(4, f);\n    // loop {\n    //     match reader.fill_buf() {\n    //         Ok(_) => println!(\"{:?}\", reader.buffer()),\n    //         _ => break\n    //     }\n    // }\n"]], "pred": {"ppl": 2.4555671215057373, "ppl_lower": 2.8319780826568604, "ppl/lowercase_ppl": -1.1587537890303565, "ppl/zlib": 0.0026500228356691855, "Min_5.0% Prob": 7.113964190849891, "Min_10.0% Prob": 5.404175855495311, "Min_20.0% Prob": 3.7767635407271207, "Min_30.0% Prob": 2.808868036037538, "Min_40.0% Prob": 2.198538120186657, "Min_50.0% Prob": 1.7799304588323963, "Min_60.0% Prob": 1.4951934058037473}}
{"hexsha": "8963703e3db3eddc9448e90979b0bb9fc667cf3a", "ext": "rs", "lang": "Rust", "content": "fn parsing() {\n        use super::ParseAmountError as E;\n        let tpc = Denomination::TPC;\n        let tap = Denomination::Tapyrus;\n        let p = Amount::from_str_in;\n        let sp = SignedAmount::from_str_in;\n\n        assert_eq!(p(\"x\", tpc), Err(E::InvalidCharacter('x')));\n        assert_eq!(p(\"-\", tpc), Err(E::InvalidFormat));\n        assert_eq!(sp(\"-\", tpc), Err(E::InvalidFormat));\n        assert_eq!(p(\"-1.0x\", tpc), Err(E::InvalidCharacter('x')));\n        assert_eq!(p(\"0.0 \", tpc), Err(ParseAmountError::InvalidCharacter(' ')));\n        assert_eq!(p(\"0.000.000\", tpc), Err(E::InvalidFormat));\n        let more_than_max = format!(\"1{}\", Amount::max_value());\n        assert_eq!(p(&more_than_max, tpc), Err(E::TooBig));\n        assert_eq!(p(\"0.000000042\", tpc), Err(E::TooPrecise));\n\n        assert_eq!(p(\"1\", tpc), Ok(Amount::from_tap(1_000_000_00)));\n        assert_eq!(sp(\"-.5\", tpc), Ok(SignedAmount::from_tap(-500_000_00)));\n        assert_eq!(p(\"1.1\", tpc), Ok(Amount::from_tap(1_100_000_00)));\n        assert_eq!(p(\"100\", tap), Ok(Amount::from_tap(100)));\n        assert_eq!(p(\"55\", tap), Ok(Amount::from_tap(55)));\n        assert_eq!(p(\"5500000000000000000\", tap), Ok(Amount::from_tap(5_500_000_000_000_000_000)));\n        // Should this even pass?\n        assert_eq!(p(\"5500000000000000000.\", tap), Ok(Amount::from_tap(5_500_000_000_000_000_000)));\n        assert_eq!(\n            p(\"12345678901.12345678\", tpc),\n            Ok(Amount::from_tap(12_345_678_901__123_456_78))\n        );\n\n        // make sure tapyrus > i64::max_value() is checked.\n        let amount = Amount::from_tap(i64::max_value() as u64);\n        assert_eq!(Amount::from_str_in(&amount.to_string_in(tap), tap), Ok(amount));\n        assert_eq!(Amount::from_str_in(&(amount+Amount(1)).to_string_in(tap), tap), Err(E::TooBig));\n\n        assert_eq!(p(\"12.000\", Denomination::MilliTapyrus), Err(E::TooPrecise));\n        // exactly 50 chars.\n        assert_eq!(p(\"100000000000000.0000000000000000000000000000000000\", Denomination::TPC), Err(E::TooBig));\n        // more than 50 chars.\n        assert_eq!(p(\"100000000000000.00000000000000000000000000000000000\", Denomination::TPC), Err(E::InputTooLarge));\n    }", "item_id": 5, "repo": "Yamaguchi/rust-tapyrus", "file": "src/util/amount.rs", "last_update_at": "2019-11-14T06:46:14+00:00", "question_id": "8963703e3db3eddc9448e90979b0bb9fc667cf3a_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parsing() {\n        use super::ParseAmountError as E;\n        let tpc = Denomination::TPC;\n        let tap = Denomination::Tapyrus;\n        let p = Amount::from_str_in;\n        let sp = SignedAmount::from_str_in;\n        assert_eq!(p(\"x\", tpc), Err(E::InvalidCharacter('x')));\n        assert_eq!(p(\"-\", tpc), Err(E::InvalidFormat));\n        assert_eq!(sp(\"-\", tpc), Err(E::InvalidFormat));\n        assert_eq!(p(\"-1.0x\", tpc), Err(E::InvalidCharacter('x')));\n        assert_eq!(p(\"0.0 \", tpc), Err(ParseAmountError::InvalidCharacter(' ')));\n        assert_eq!(p(\"0.000.000\", tpc), Err(E::InvalidFormat));\n        let more_than_max = format!(\"1{}\", Amount::max_value());\n        assert_eq!(p(&more_than_max, tpc), Err(E::TooBig));\n        assert_eq!(p(\"0.000000042\", tpc), Err(E::TooPrecise));\n        assert_eq!(p(\"1\", tpc), Ok(Amount::from_tap(1_000_000_00)));\n        assert_eq!(sp(\"-.5\", tpc), Ok(SignedAmount::from_tap(-500_000_00)));\n        assert_eq!(p(\"1.1\", tpc), Ok(Amount::from_tap(1_100_000_00)));\n        assert_eq!(p(\"100\", tap), Ok(Amount::from_tap(100)));\n        assert_eq!(p(\"55\", tap), Ok(Amount::from_tap(55)));\n        assert_eq!(p(\"5500000000000000000\", tap), Ok(Amount::from_tap(5_500_000_000_000_000_000)));\n        // Should this even pass?\n        assert_eq!(p(\"5500000000000000000.\", tap), Ok(Amount::from_tap(5_500_000_000_000_000_000)));\n        assert_eq!(\n            p(\"12345678901.12345678\", tpc),\n            Ok(Amount::from_tap(12_345_678_901__123_456_78))\n        );\n        // make sure tapyrus > i64::max_value() is checked.\n        let amount = Amount::from_tap(i64::max_value() as u64);\n        assert_eq!(Amount::from_str_in(&amount.to_string_in(tap), tap), Ok(amount));\n        assert_eq!(Amount::from_str_in(&(amount+Amount(1)).to_string_in(tap), tap), Err(E::TooBig));\n        assert_eq!(p(\"12.000\", Denomination::MilliTapyrus), Err(E::TooPrecise));\n        // exactly 50 chars.\n        assert_eq!(p(\"100000000000000.0000000000000000000000000000000000\", Denomination::TPC), Err(E::TooBig));\n        // more than 50 chars.\n        assert_eq!(p(\"100000000000000.00000000000000000000000000000000000\", Denomination::TPC), Err(E::InputTooLarge));\n"]], "pred": {"ppl": 1.8299907445907593, "ppl_lower": 1.9688640832901, "ppl/lowercase_ppl": -1.1210401113444606, "ppl/zlib": 0.0010383348956011372, "Min_5.0% Prob": 6.336995820609891, "Min_10.0% Prob": 4.4470994990281385, "Min_20.0% Prob": 2.7580199843705304, "Min_30.0% Prob": 1.9475097784189264, "Min_40.0% Prob": 1.490034199556716, "Min_50.0% Prob": 1.2040577898170017, "Min_60.0% Prob": 1.0068245196699346}}
{"hexsha": "f247a6157004da3df73791c1bd17952df4a42af9", "ext": "rs", "lang": "Rust", "content": "fn test_case_insensitive() {\n        let a = Ascii(\"foobar\");\n        let b = Ascii(\"FOOBAR\");\n\n        assert_eq!(a, b);\n        assert_eq!(hash(&a), hash(&b));\n\n        assert_eq!(a, \"fooBar\");\n        assert_eq!(\"fooBar\", a);\n        assert_eq!(String::from(\"fooBar\"), a);\n        assert_eq!(a, String::from(\"fooBar\"));\n    }", "item_id": 1, "repo": "green-element-chain/rust-sgx-sdk", "file": "third_party/unicase/src/ascii.rs", "last_update_at": "2019-07-30T08:59:45+00:00", "question_id": "f247a6157004da3df73791c1bd17952df4a42af9_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_case_insensitive() {\n        let a = Ascii(\"foobar\");\n        let b = Ascii(\"FOOBAR\");\n        assert_eq!(a, b);\n        assert_eq!(hash(&a), hash(&b));\n        assert_eq!(a, \"fooBar\");\n        assert_eq!(\"fooBar\", a);\n        assert_eq!(String::from(\"fooBar\"), a);\n        assert_eq!(a, String::from(\"fooBar\"));\n"]], "pred": {"ppl": 2.1377861499786377, "ppl_lower": 2.340487241744995, "ppl/lowercase_ppl": -1.1192311527920145, "ppl/zlib": 0.005031594597376463, "Min_5.0% Prob": 6.9519048690795895, "Min_10.0% Prob": 5.377193234183571, "Min_20.0% Prob": 3.3437392893044846, "Min_30.0% Prob": 2.4184558400336433, "Min_40.0% Prob": 1.8526982172675754, "Min_50.0% Prob": 1.517739590714898, "Min_60.0% Prob": 1.2609870922414288}}
{"hexsha": "d6af236d4b20131e6524b3a278bba79785a70345", "ext": "rs", "lang": "Rust", "content": "pub fn prepare_share_change_session_plan(cluster_nodes: &BTreeSet<NodeId>, threshold: usize, key_id: &ServerKeyId, key_version: H256, master: &NodeId, old_key_version_owners: &BTreeSet<NodeId>, new_nodes_set: &BTreeSet<NodeId>) -> Result<ShareChangeSessionPlan, Error> {\n\t// we can't do anything if there are no enought shares\n\tif old_key_version_owners.len() < threshold + 1 {\n\t\twarn!(\"cannot add shares to key {} with threshold {}: only {} shares owners are available\",\n\t\t\tkey_id, threshold, old_key_version_owners.len());\n\t\treturn Ok(ShareChangeSessionPlan {\n\t\t\tkey_version: key_version,\n\t\t\tversion_holders: Default::default(),\n\t\t\tconsensus_group: Default::default(),\n\t\t\tnew_nodes_map: Default::default(),\n\t\t});\n\t}\n\n\t// warn if we're loosing the key\n\tif new_nodes_set.len() < threshold + 1 {\n\t\twarn!(\"losing key {} with threshold {}: only {} nodes left after servers set change session\",\n\t\t\tkey_id, threshold, new_nodes_set.len());\n\t}\n\n\t// make new nodes map, so that:\n\t// all non-isolated old nodes will have their id number preserved\n\t// all new nodes will have new id number\n\tlet mut new_nodes_map = new_nodes_set.difference(&old_key_version_owners)\n\t\t.map(|n| math::generate_random_scalar().map(|id| (n.clone(), Some(id))))\n\t\t.collect::<Result<BTreeMap<_, _>, _>>()?;\n\tif !new_nodes_map.is_empty() {\n\t\tfor old_node in old_key_version_owners.iter().filter(|n| cluster_nodes.contains(n)) {\n\t\t\tnew_nodes_map.insert(old_node.clone(), None);\n\t\t}\n\t}\n\n\t// select consensus group if there are some nodes to add\n\tlet consensus_group = if !new_nodes_map.is_empty() {\n\t\t\t::std::iter::once(master.clone())\n\t\t\t\t.chain(old_key_version_owners.iter()\n\t\t\t\t\t.filter(|n| *n != master && cluster_nodes.contains(*n))\n\t\t\t\t\t.take(threshold)\n\t\t\t\t\t.cloned())\n\t\t\t\t.collect()\n\t\t} else {\n\t\t\tBTreeSet::new()\n\t\t};\n\n\tOk(ShareChangeSessionPlan {\n\t\tkey_version: key_version,\n\t\tversion_holders: old_key_version_owners.clone(),\n\t\tconsensus_group: consensus_group,\n\t\tnew_nodes_map: new_nodes_map,\n\t})\n}", "item_id": 0, "repo": "altice-io/Daqiao", "file": "bridge/parity-ethereum/secret-store/src/key_server_cluster/admin_sessions/share_change_session.rs", "last_update_at": "2019-09-11T12:07:35+00:00", "question_id": "d6af236d4b20131e6524b3a278bba79785a70345_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn prepare_share_change_session_plan(cluster_nodes: &BTreeSet<NodeId>, threshold: usize, key_id: &ServerKeyId, key_version: H256, master: &NodeId, old_key_version_owners: &BTreeSet<NodeId>, new_nodes_set: &BTreeSet<NodeId>) -> Result<ShareChangeSessionPlan, Error> {\n\t// we can't do anything if there are no enought shares\n\tif old_key_version_owners.len() < threshold + 1 {\n\t\twarn!(\"cannot add shares to key {} with threshold {}: only {} shares owners are available\",\n\t\t\tkey_id, threshold, old_key_version_owners.len());\n\t\treturn Ok(ShareChangeSessionPlan {\n\t\t\tkey_version: key_version,\n\t\t\tversion_holders: Default::default(),\n\t\t\tconsensus_group: Default::default(),\n\t\t\tnew_nodes_map: Default::default(),\n\t\t});\n\t}\n\t// warn if we're loosing the key\n\tif new_nodes_set.len() < threshold + 1 {\n\t\twarn!(\"losing key {} with threshold {}: only {} nodes left after servers set change session\",\n\t\t\tkey_id, threshold, new_nodes_set.len());\n\t}\n\t// make new nodes map, so that:\n\t// all non-isolated old nodes will have their id number preserved\n\t// all new nodes will have new id number\n\tlet mut new_nodes_map = new_nodes_set.difference(&old_key_version_owners)\n\t\t.map(|n| math::generate_random_scalar().map(|id| (n.clone(), Some(id))))\n\t\t.collect::<Result<BTreeMap<_, _>, _>>()?;\n\tif !new_nodes_map.is_empty() {\n\t\tfor old_node in old_key_version_owners.iter().filter(|n| cluster_nodes.contains(n)) {\n\t\t\tnew_nodes_map.insert(old_node.clone(), None);\n\t\t}\n\t}\n\t// select consensus group if there are some nodes to add\n\tlet consensus_group = if !new_nodes_map.is_empty() {\n\t\t\t::std::iter::once(master.clone())\n\t\t\t\t.chain(old_key_version_owners.iter()\n\t\t\t\t\t.filter(|n| *n != master && cluster_nodes.contains(*n))\n\t\t\t\t\t.take(threshold)\n\t\t\t\t\t.cloned())\n\t\t\t\t.collect()\n\t\t} else {\n\t\t\tBTreeSet::new()\n\t\t};\n\tOk(ShareChangeSessionPlan {\n\t\tkey_version: key_version,\n\t\tversion_holders: old_key_version_owners.clone(),\n\t\tconsensus_group: consensus_group,\n\t\tnew_nodes_map: new_nodes_map,\n\t})\n"]], "pred": {"ppl": 2.420767307281494, "ppl_lower": 2.6023831367492676, "ppl/lowercase_ppl": -1.0818282103163945, "ppl/zlib": 0.0011190943785283384, "Min_5.0% Prob": 7.623492439587911, "Min_10.0% Prob": 5.787848299496795, "Min_20.0% Prob": 3.8707818805354917, "Min_30.0% Prob": 2.818941505804454, "Min_40.0% Prob": 2.182831520259177, "Min_50.0% Prob": 1.7649678484093947, "Min_60.0% Prob": 1.475072538395304}}
{"hexsha": "2533ac14e5a017e1a719eccfdaa05e7c6ee94ede", "ext": "rs", "lang": "Rust", "content": "fn append_vec_concurrent_get_append(bencher: &mut Bencher) {\n    let path = get_append_vec_bench_path(\"bench_get_append\");\n    let vec = Arc::new(RwLock::new(AppendVec::<AtomicUsize>::new(\n        &path, true, START_SIZE, INC_SIZE,\n    )));\n    let vec1 = vec.clone();\n    let size = 1_000_000;\n    let count = Arc::new(AtomicUsize::new(0));\n    let count1 = count.clone();\n    spawn(move || loop {\n        let mut len = count.load(Ordering::Relaxed);\n        {\n            let rlock = vec1.read().unwrap();\n            loop {\n                if rlock.append(AtomicUsize::new(0)).is_none() {\n                    break;\n                }\n                len = count.fetch_add(1, Ordering::Relaxed);\n            }\n            if len >= size {\n                break;\n            }\n        }\n        {\n            let mut wlock = vec1.write().unwrap();\n            if len >= size {\n                break;\n            }\n            assert!(wlock.grow_file().is_ok());\n        }\n    });\n    bencher.iter(|| {\n        let rlock = vec.read().unwrap();\n        let len = count1.load(Ordering::Relaxed);\n        if len > 0 {\n            let index = thread_rng().gen_range(0, len);\n            rlock.get((index * std::mem::size_of::<AtomicUsize>()) as u64);\n        }\n    });\n    std::fs::remove_file(path).unwrap();\n}", "item_id": 6, "repo": "abalaki6/solana", "file": "runtime/benches/append_vec.rs", "last_update_at": "2019-03-10T22:29:28+00:00", "question_id": "2533ac14e5a017e1a719eccfdaa05e7c6ee94ede_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn append_vec_concurrent_get_append(bencher: &mut Bencher) {\n    let path = get_append_vec_bench_path(\"bench_get_append\");\n    let vec = Arc::new(RwLock::new(AppendVec::<AtomicUsize>::new(\n        &path, true, START_SIZE, INC_SIZE,\n    )));\n    let vec1 = vec.clone();\n    let size = 1_000_000;\n    let count = Arc::new(AtomicUsize::new(0));\n    let count1 = count.clone();\n    spawn(move || loop {\n        let mut len = count.load(Ordering::Relaxed);\n        {\n            let rlock = vec1.read().unwrap();\n            loop {\n                if rlock.append(AtomicUsize::new(0)).is_none() {\n                    break;\n                }\n                len = count.fetch_add(1, Ordering::Relaxed);\n            }\n            if len >= size {\n                break;\n            }\n        }\n        {\n            let mut wlock = vec1.write().unwrap();\n            if len >= size {\n                break;\n            }\n            assert!(wlock.grow_file().is_ok());\n        }\n    });\n    bencher.iter(|| {\n        let rlock = vec.read().unwrap();\n        let len = count1.load(Ordering::Relaxed);\n        if len > 0 {\n            let index = thread_rng().gen_range(0, len);\n            rlock.get((index * std::mem::size_of::<AtomicUsize>()) as u64);\n        }\n    });\n    std::fs::remove_file(path).unwrap();\n"]], "pred": {"ppl": 2.0638587474823, "ppl_lower": 2.5661520957946777, "ppl/lowercase_ppl": -1.3006305830882523, "ppl/zlib": 0.0014491548179602213, "Min_5.0% Prob": 6.338748432341076, "Min_10.0% Prob": 4.935335556666057, "Min_20.0% Prob": 3.2250634929713082, "Min_30.0% Prob": 2.3360633810204785, "Min_40.0% Prob": 1.7915810987353324, "Min_50.0% Prob": 1.4474363471469227, "Min_60.0% Prob": 1.2064692869307656}}
{"hexsha": "77efe572845f43de1875230da2a8de1297689d34", "ext": "rs", "lang": "Rust", "content": "fn test_thermal_parser() {\n    let test_data = include_str!(\"../tests/chassis-thermal.json\");\n    let result: Thermal = serde_json::from_str(&test_data).unwrap();\n    println!(\"result: {:#?}\", result);\n}", "item_id": 0, "repo": "cholcombe973/libredfish", "file": "src/thermal.rs", "last_update_at": "2019-09-17T03:56:17+00:00", "question_id": "77efe572845f43de1875230da2a8de1297689d34_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_thermal_parser() {\n    let test_data = include_str!(\"../tests/chassis-thermal.json\");\n    let result: Thermal = serde_json::from_str(&test_data).unwrap();\n    println!(\"result: {:#?}\", result);\n"]], "pred": {"ppl": 3.2043941020965576, "ppl_lower": 3.6915171146392822, "ppl/lowercase_ppl": -1.1215214194389853, "ppl/zlib": 0.00803119327443504, "Min_5.0% Prob": 9.821872075398764, "Min_10.0% Prob": 6.9836216654096335, "Min_20.0% Prob": 4.625153252056667, "Min_30.0% Prob": 3.5653833207629977, "Min_40.0% Prob": 2.8190862983465195, "Min_50.0% Prob": 2.305622204712459, "Min_60.0% Prob": 1.9352893874581372}}
{"hexsha": "6fb4663bd5897e58b347d5e9d64c66d596d2a8fc", "ext": "rs", "lang": "Rust", "content": "fn process_overspecified_remap() {\n        let mut mode_map = ModeMap::<u8, TestOp>::new();\n        assert_eq!(\n            InsertionResult::Create,\n            mode_map.insert_remap(vec![1u8, 1u8, 1u8], vec![2u8])\n        );\n\n        let mut typeahead = Typeahead::<u8>::new();\n        typeahead.push_back(1u8, RemapType::Remap);\n        typeahead.push_back(1u8, RemapType::Remap);\n\n        assert_eq!(Err(MapErr::NoMatch), mode_map.process(&mut typeahead));\n        assert_eq!(Some((1u8, RemapType::Remap)), typeahead.pop_front());\n        assert_eq!(Some((1u8, RemapType::Remap)), typeahead.pop_front());\n        assert_eq!(None, typeahead.pop_front());\n    }", "item_id": 7, "repo": "jakalope/vixi", "file": "src/mode_map.rs", "last_update_at": "2019-05-19T15:40:10+00:00", "question_id": "6fb4663bd5897e58b347d5e9d64c66d596d2a8fc_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn process_overspecified_remap() {\n        let mut mode_map = ModeMap::<u8, TestOp>::new();\n        assert_eq!(\n            InsertionResult::Create,\n            mode_map.insert_remap(vec![1u8, 1u8, 1u8], vec![2u8])\n        );\n        let mut typeahead = Typeahead::<u8>::new();\n        typeahead.push_back(1u8, RemapType::Remap);\n        typeahead.push_back(1u8, RemapType::Remap);\n        assert_eq!(Err(MapErr::NoMatch), mode_map.process(&mut typeahead));\n        assert_eq!(Some((1u8, RemapType::Remap)), typeahead.pop_front());\n        assert_eq!(Some((1u8, RemapType::Remap)), typeahead.pop_front());\n        assert_eq!(None, typeahead.pop_front());\n"]], "pred": {"ppl": 2.5515248775482178, "ppl_lower": 2.991896867752075, "ppl/lowercase_ppl": -1.1699774945726473, "ppl/zlib": 0.0036026583524624107, "Min_5.0% Prob": 7.852253556251526, "Min_10.0% Prob": 5.796853552261989, "Min_20.0% Prob": 3.898759422202905, "Min_30.0% Prob": 2.953358811636766, "Min_40.0% Prob": 2.3141608219593763, "Min_50.0% Prob": 1.8633085293464424, "Min_60.0% Prob": 1.5615161516157718}}
{"hexsha": "0ec973067cd91f723406dbffdd0912d59865edc6", "ext": "rs", "lang": "Rust", "content": "fn compare(a: &str, b: &str, operator: &CompOp) {\n        // Get both versions\n        let version_a: Version = a.parse().unwrap();\n        let version_b: Version = b.parse().unwrap();\n\n        // Compare them\n        assert_eq!(version_a.compare_version(&version_b), operator.clone(),);\n\n        // Compare them\n        assert_eq!(version_a.compare_str(b), operator.clone(),);\n    }", "item_id": 5, "repo": "msarahan/libronda", "file": "core/src/version/version.rs", "last_update_at": "2019-10-15T14:12:12+00:00", "question_id": "0ec973067cd91f723406dbffdd0912d59865edc6_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn compare(a: &str, b: &str, operator: &CompOp) {\n        // Get both versions\n        let version_a: Version = a.parse().unwrap();\n        let version_b: Version = b.parse().unwrap();\n        // Compare them\n        assert_eq!(version_a.compare_version(&version_b), operator.clone(),);\n        // Compare them\n        assert_eq!(version_a.compare_str(b), operator.clone(),);\n"]], "pred": {"ppl": 3.0501954555511475, "ppl_lower": 3.3579788208007812, "ppl/lowercase_ppl": -1.0862025557958073, "ppl/zlib": 0.006638129002102997, "Min_5.0% Prob": 7.335707664489746, "Min_10.0% Prob": 5.90407844023271, "Min_20.0% Prob": 4.335778070532757, "Min_30.0% Prob": 3.3451890911374775, "Min_40.0% Prob": 2.7413571140040522, "Min_50.0% Prob": 2.2252164174770486, "Min_60.0% Prob": 1.8574849839189223}}
{"hexsha": "918dbc84e6d0449f3662fd1404138c56c47f1969", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // Compute the totient of the first 25 natural integers\n    println!(\"N\\t phi(n)\\t Prime\");\n    for n in 1..26 {\n        let phi_n = phi(n);\n        println!(\"{}\\t {}\\t {:?}\", n, phi_n, phi_n == n - 1);\n    }\n\n    // Compute the number of prime numbers for various steps\n    [1, 100, 1000, 10000, 100000]\n        .windows(2)\n        .scan(0, |acc, window| {\n            let (lower, upper) = (window[0], window[1]);\n            *acc += (lower..=upper).filter(is_prime).count();\n            Some((upper, *acc))\n        })\n        .for_each(|x| println!(\"Until {}: {} prime numbers\", x.0, x.1));\n}", "item_id": 0, "repo": "kaiuri/rust-rosetta", "file": "tasks/totient-function/src/main.rs", "last_update_at": "2019-09-05T06:56:04+00:00", "question_id": "918dbc84e6d0449f3662fd1404138c56c47f1969_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    // Compute the totient of the first 25 natural integers\n    println!(\"N\\t phi(n)\\t Prime\");\n    for n in 1..26 {\n        let phi_n = phi(n);\n        println!(\"{}\\t {}\\t {:?}\", n, phi_n, phi_n == n - 1);\n    }\n    // Compute the number of prime numbers for various steps\n    [1, 100, 1000, 10000, 100000]\n        .windows(2)\n        .scan(0, |acc, window| {\n            let (lower, upper) = (window[0], window[1]);\n            *acc += (lower..=upper).filter(is_prime).count();\n            Some((upper, *acc))\n        })\n        .for_each(|x| println!(\"Until {}: {} prime numbers\", x.0, x.1));\n"]], "pred": {"ppl": 2.6205239295959473, "ppl_lower": 2.6957247257232666, "ppl/lowercase_ppl": -1.029368453237801, "ppl/zlib": 0.0029281892732804524, "Min_5.0% Prob": 8.110242973674428, "Min_10.0% Prob": 6.252745203349901, "Min_20.0% Prob": 4.111031243141661, "Min_30.0% Prob": 3.072210852163179, "Min_40.0% Prob": 2.3627214277995394, "Min_50.0% Prob": 1.9204834368493822, "Min_60.0% Prob": 1.6015451415607058}}
{"hexsha": "28a61e0ae694670963b9349442b4f33323959f7e", "ext": "rs", "lang": "Rust", "content": "fn _null_chunk_slow<R>(mut rdr: R, max: Option<usize>) -> io::Result<Vec<u8>>\nwhere\n    R: io::Read,\n{\n    let mut buf = Vec::new();\n    let mut count = 0;\n    loop {\n        if let Some(max) = max {\n            if count > max {\n                break Err(io::ErrorKind::UnexpectedEof.into());\n            }\n        }\n\n        let byte = rdr.read_u8()?;\n        if byte != 0x00 {\n            buf.push(byte);\n            count += 1;\n        } else {\n            break Ok(buf);\n        }\n    }\n}", "item_id": 0, "repo": "viriuwu/minio", "file": "src/lib.rs", "last_update_at": "2019-10-29T20:31:47+00:00", "question_id": "28a61e0ae694670963b9349442b4f33323959f7e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn _null_chunk_slow<R>(mut rdr: R, max: Option<usize>) -> io::Result<Vec<u8>>\nwhere\n    R: io::Read,\n{\n    let mut buf = Vec::new();\n    let mut count = 0;\n    loop {\n        if let Some(max) = max {\n            if count > max {\n                break Err(io::ErrorKind::UnexpectedEof.into());\n            }\n        }\n        let byte = rdr.read_u8()?;\n        if byte != 0x00 {\n            buf.push(byte);\n            count += 1;\n        } else {\n            break Ok(buf);\n        }\n    }\n"]], "pred": {"ppl": 1.907851219177246, "ppl_lower": 3.394566535949707, "ppl/lowercase_ppl": -1.8919790556883591, "ppl/zlib": 0.002366218287968079, "Min_5.0% Prob": 6.940430462360382, "Min_10.0% Prob": 4.611725786153008, "Min_20.0% Prob": 2.971934159012402, "Min_30.0% Prob": 2.1208544542976453, "Min_40.0% Prob": 1.6213844388942509, "Min_50.0% Prob": 1.2890922614091704, "Min_60.0% Prob": 1.0779646672172816}}
{"hexsha": "139212fac6270a44a498f6036ea8c3fbb049d001", "ext": "rs", "lang": "Rust", "content": "fn test_lexer06() {\n        let input = \"t = {x = 3}\";\n        let tokens = &[\n            (Identifier, 0, 1),\n            (Assign, 2, 1),\n            (LCurly, 4, 1),\n            (Identifier, 5, 1),\n            (Assign, 7, 1),\n            (LiteralNumber, 9, 1),\n            (RCurly, 10, 1),\n        ];\n        check_line(input, tokens);\n    }", "item_id": 5, "repo": "OrangeChris/lua-in-rust", "file": "src/compiler/lexer.rs", "last_update_at": "2019-07-18T15:18:12+00:00", "question_id": "139212fac6270a44a498f6036ea8c3fbb049d001_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_lexer06() {\n        let input = \"t = {x = 3}\";\n        let tokens = &[\n            (Identifier, 0, 1),\n            (Assign, 2, 1),\n            (LCurly, 4, 1),\n            (Identifier, 5, 1),\n            (Assign, 7, 1),\n            (LiteralNumber, 9, 1),\n            (RCurly, 10, 1),\n        ];\n        check_line(input, tokens);\n"]], "pred": {"ppl": 2.382403612136841, "ppl_lower": 2.554013967514038, "ppl/lowercase_ppl": -1.0801238730505107, "ppl/zlib": 0.005229577705554798, "Min_5.0% Prob": 7.275634845097859, "Min_10.0% Prob": 5.631161066202017, "Min_20.0% Prob": 3.964355523769672, "Min_30.0% Prob": 2.8259794964240146, "Min_40.0% Prob": 2.1472220364606605, "Min_50.0% Prob": 1.7423608387735756, "Min_60.0% Prob": 1.4601237731337358}}
{"hexsha": "988c2c115995c18a31b43e2398f81c6df358924f", "ext": "rs", "lang": "Rust", "content": "fn test_VSMT_4_Verif() {\n        let width = 5;\n\n        let mut db = InMemoryHashDb::<DBVal_4_ary>::new();\n\n        #[cfg(feature = \"bls381\")]\n        let (full_b, full_e, partial_rounds) = (4, 4, 56);\n\n        #[cfg(feature = \"bn254\")]\n        let (full_b, full_e, partial_rounds) = (4, 4, 56);\n\n        #[cfg(feature = \"secp256k1\")]\n        let (full_b, full_e, partial_rounds) = (4, 4, 56);\n\n        #[cfg(feature = \"ed25519\")]\n        let (full_b, full_e, partial_rounds) = (4, 4, 56);\n\n        let total_rounds = full_b + partial_rounds + full_e;\n        let hash_params = PoseidonParams::new(width, full_b, full_e, partial_rounds);\n        let tree_depth = 12;\n        let mut tree = VanillaSparseMerkleTree_4::new(&hash_params, tree_depth, &mut db);\n\n        for i in 1..=10 {\n            let s = FieldElement::from(i as u32);\n            tree.update(&s, s.clone(), &mut db).unwrap();\n        }\n\n        // TODO: Use iterators. Generating so many generators at once is very slow. In practice, generators will be persisted.\n        let G: G1Vector = get_generators(\"G\", 8192).into();\n        let H: G1Vector = get_generators(\"H\", 8192).into();\n\n        let g = G1::from_msg_hash(\"g\".as_bytes());\n        let h = G1::from_msg_hash(\"h\".as_bytes());\n\n        for i in vec![3u32, 4u32, 7u32, 8u32, 9u32] {\n            let mut merkle_proof_vec = Vec::<ProofNode_4_ary>::new();\n            let mut merkle_proof = Some(merkle_proof_vec);\n            let k = FieldElement::from(i);\n            assert_eq!(k, tree.get(&k, &mut merkle_proof, &db).unwrap());\n            merkle_proof_vec = merkle_proof.unwrap();\n            assert!(tree.verify_proof(&k, &k, &merkle_proof_vec, Some(&tree.root)));\n\n            let mut rng = rand::thread_rng();\n\n            let sbox_type = &SboxType::Quint;\n\n            let label = b\"4-aryMerkleTree\";\n\n            let (proof, commitments) = gen_proof_of_leaf_inclusion_4_ary_merkle_tree(\n                k.clone(),\n                k.clone(),\n                None,\n                merkle_proof_vec,\n                &tree.root,\n                tree.depth,\n                &hash_params,\n                sbox_type,\n                Some(&mut rng),\n                label,\n                &g,\n                &h,\n                &G,\n                &H,\n            )\n            .unwrap();\n\n            verify_proof_of_leaf_inclusion_4_ary_merkle_tree(\n                &tree.root,\n                tree.depth,\n                &hash_params,\n                sbox_type,\n                proof,\n                commitments,\n                label,\n                &g,\n                &h,\n                &G,\n                &H,\n            )\n            .unwrap();\n        }\n    }", "item_id": 4, "repo": "lovesh/bulletproofs-amcl", "file": "src/r1cs/gadgets/sparse_merkle_tree_4_ary.rs", "last_update_at": "2019-04-03T21:19:03+00:00", "question_id": "988c2c115995c18a31b43e2398f81c6df358924f_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_VSMT_4_Verif() {\n        let width = 5;\n        let mut db = InMemoryHashDb::<DBVal_4_ary>::new();\n        #[cfg(feature = \"bls381\")]\n        let (full_b, full_e, partial_rounds) = (4, 4, 56);\n        #[cfg(feature = \"bn254\")]\n        let (full_b, full_e, partial_rounds) = (4, 4, 56);\n        #[cfg(feature = \"secp256k1\")]\n        let (full_b, full_e, partial_rounds) = (4, 4, 56);\n        #[cfg(feature = \"ed25519\")]\n        let (full_b, full_e, partial_rounds) = (4, 4, 56);\n        let total_rounds = full_b + partial_rounds + full_e;\n        let hash_params = PoseidonParams::new(width, full_b, full_e, partial_rounds);\n        let tree_depth = 12;\n        let mut tree = VanillaSparseMerkleTree_4::new(&hash_params, tree_depth, &mut db);\n        for i in 1..=10 {\n            let s = FieldElement::from(i as u32);\n            tree.update(&s, s.clone(), &mut db).unwrap();\n        }\n        // TODO: Use iterators. Generating so many generators at once is very slow. In practice, generators will be persisted.\n        let G: G1Vector = get_generators(\"G\", 8192).into();\n        let H: G1Vector = get_generators(\"H\", 8192).into();\n        let g = G1::from_msg_hash(\"g\".as_bytes());\n        let h = G1::from_msg_hash(\"h\".as_bytes());\n        for i in vec![3u32, 4u32, 7u32, 8u32, 9u32] {\n            let mut merkle_proof_vec = Vec::<ProofNode_4_ary>::new();\n            let mut merkle_proof = Some(merkle_proof_vec);\n            let k = FieldElement::from(i);\n            assert_eq!(k, tree.get(&k, &mut merkle_proof, &db).unwrap());\n            merkle_proof_vec = merkle_proof.unwrap();\n            assert!(tree.verify_proof(&k, &k, &merkle_proof_vec, Some(&tree.root)));\n            let mut rng = rand::thread_rng();\n            let sbox_type = &SboxType::Quint;\n            let label = b\"4-aryMerkleTree\";\n            let (proof, commitments) = gen_proof_of_leaf_inclusion_4_ary_merkle_tree(\n                k.clone(),\n                k.clone(),\n                None,\n                merkle_proof_vec,\n                &tree.root,\n                tree.depth,\n                &hash_params,\n                sbox_type,\n                Some(&mut rng),\n                label,\n                &g,\n                &h,\n                &G,\n                &H,\n            )\n            .unwrap();\n            verify_proof_of_leaf_inclusion_4_ary_merkle_tree(\n                &tree.root,\n                tree.depth,\n                &hash_params,\n                sbox_type,\n                proof,\n                commitments,\n                label,\n                &g,\n                &h,\n                &G,\n                &H,\n            )\n            .unwrap();\n        }\n"]], "pred": {"ppl": 2.5316996574401855, "ppl_lower": 2.7794852256774902, "ppl/lowercase_ppl": -1.1005229608257876, "ppl/zlib": 0.0011397434092535789, "Min_5.0% Prob": 7.17685866885715, "Min_10.0% Prob": 5.649043271829794, "Min_20.0% Prob": 3.875703067727428, "Min_30.0% Prob": 2.8930205603079364, "Min_40.0% Prob": 2.2782728234764007, "Min_50.0% Prob": 1.8496373286348764, "Min_60.0% Prob": 1.5464958841082725}}
{"hexsha": "42b615fb9dd49aedd97eda953019ec7cea74fcaf", "ext": "rs", "lang": "Rust", "content": "fn returns_no_objects_when_empty() {\n        let world = box WorldMock::new();\n        let simulation = SimulationImpl::new(\n            world,\n            box world_interactor_factory_fn,\n            box instant_wrapper_factory_fn,\n        );\n        let objects = simulation.objects();\n        assert!(objects.is_empty())\n    }", "item_id": 4, "repo": "myelin-ai/engine", "file": "src/simulation/simulation_impl.rs", "last_update_at": "2019-12-14T11:25:28+00:00", "question_id": "42b615fb9dd49aedd97eda953019ec7cea74fcaf_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn returns_no_objects_when_empty() {\n        let world = box WorldMock::new();\n        let simulation = SimulationImpl::new(\n            world,\n            box world_interactor_factory_fn,\n            box instant_wrapper_factory_fn,\n        );\n        let objects = simulation.objects();\n        assert!(objects.is_empty())\n"]], "pred": {"ppl": 5.892104148864746, "ppl_lower": 7.15822696685791, "ppl/lowercase_ppl": -1.1097472368765577, "ppl/zlib": 0.010134932427211458, "Min_5.0% Prob": 9.89504861831665, "Min_10.0% Prob": 8.790255427360535, "Min_20.0% Prob": 6.788718966876759, "Min_30.0% Prob": 5.378447184562683, "Min_40.0% Prob": 4.242386462057338, "Min_50.0% Prob": 3.4586608603943225, "Min_60.0% Prob": 2.954841165565977}}
{"hexsha": "22153c435cc54c6faae68c0d8688a6746167fa41", "ext": "rs", "lang": "Rust", "content": "pub fn load_summary<P: AsRef<Path>>(path: P) -> Result<Vec<PartialTxnLookup>, Box<Error>> {\n    let mut res = Vec::new();\n    let mut reader = Reader::from_path(path)?;\n    for row in reader.records() {\n        TxnSummary::from_row(&row?)?\n            .partial_txns()\n            .into_iter()\n            .for_each(|partial_txn| res.push(partial_txn));\n    }\n    Ok(res)\n}", "item_id": 0, "repo": "mplanchard/rust-intro", "file": "src/implementations/owned.rs", "last_update_at": "2019-06-02T17:32:17+00:00", "question_id": "22153c435cc54c6faae68c0d8688a6746167fa41_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn load_summary<P: AsRef<Path>>(path: P) -> Result<Vec<PartialTxnLookup>, Box<Error>> {\n    let mut res = Vec::new();\n    let mut reader = Reader::from_path(path)?;\n    for row in reader.records() {\n        TxnSummary::from_row(&row?)?\n            .partial_txns()\n            .into_iter()\n            .for_each(|partial_txn| res.push(partial_txn));\n    }\n    Ok(res)\n"]], "pred": {"ppl": 2.851602792739868, "ppl_lower": 5.007838726043701, "ppl/lowercase_ppl": -1.5373922156919602, "ppl/zlib": 0.004497344290213591, "Min_5.0% Prob": 10.009246826171875, "Min_10.0% Prob": 6.757289794775156, "Min_20.0% Prob": 4.5002401471138, "Min_30.0% Prob": 3.315957082808018, "Min_40.0% Prob": 2.5880209432457977, "Min_50.0% Prob": 2.080456778740705, "Min_60.0% Prob": 1.7511864006053657}}
{"hexsha": "c07c906f4e2d89e2c628ffb8b0d12fd5c80dc16d", "ext": "rs", "lang": "Rust", "content": "fn clear(mut cx: FunctionContext) -> JsResult<JsUndefined> {\n    let x = cx.argument::<JsNumber>(0)?.value();\n    terminal().clear(map_js_clear_type(x as u16));\n    Ok(cx.undefined())\n}", "item_id": 7, "repo": "sdgluck/node-crossterm", "file": "native/src/lib.rs", "last_update_at": "2019-05-28T22:02:17+00:00", "question_id": "c07c906f4e2d89e2c628ffb8b0d12fd5c80dc16d_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn clear(mut cx: FunctionContext) -> JsResult<JsUndefined> {\n    let x = cx.argument::<JsNumber>(0)?.value();\n    terminal().clear(map_js_clear_type(x as u16));\n    Ok(cx.undefined())\n"]], "pred": {"ppl": 3.4531142711639404, "ppl_lower": 7.116096496582031, "ppl/lowercase_ppl": -1.5834717373799065, "ppl/zlib": 0.007944080199743629, "Min_5.0% Prob": 9.829265594482422, "Min_10.0% Prob": 8.456950267155966, "Min_20.0% Prob": 5.70093388740833, "Min_30.0% Prob": 3.996306885778904, "Min_40.0% Prob": 3.1445066292698565, "Min_50.0% Prob": 2.505300558877714, "Min_60.0% Prob": 2.07382690301165}}
{"hexsha": "70ebb8340de8eb4f2864aff55a425b894d26f778", "ext": "rs", "lang": "Rust", "content": "fn cic() {\n        init();\n\n        let refe = b\"GGATAACTCT\";\n        //           |||||\n        let read = b\"GGATATACTCT\";\n\n        let mut data: pcon::solid::Solid = pcon::solid::Solid::new(5);\n\n        for kmer in cocktail::tokenizer::Tokenizer::new(refe, 5) {\n            data.set(kmer, true);\n        }\n\n        let set: set::BoxKmerSet = Box::new(set::Pcon::new(data));\n\n        let corrector = GapSize::new(&set, 2);\n\n        assert_eq!(refe, corrector.correct(read).as_slice()); // test correction work\n        assert_eq!(refe, corrector.correct(refe).as_slice()); // test not overcorrection\n    }", "item_id": 6, "repo": "natir/br", "file": "src/correct/gap_size.rs", "last_update_at": "2019-10-19T01:35:14+00:00", "question_id": "70ebb8340de8eb4f2864aff55a425b894d26f778_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn cic() {\n        init();\n        let refe = b\"GGATAACTCT\";\n        //           |||||\n        let read = b\"GGATATACTCT\";\n        let mut data: pcon::solid::Solid = pcon::solid::Solid::new(5);\n        for kmer in cocktail::tokenizer::Tokenizer::new(refe, 5) {\n            data.set(kmer, true);\n        }\n        let set: set::BoxKmerSet = Box::new(set::Pcon::new(data));\n        let corrector = GapSize::new(&set, 2);\n        assert_eq!(refe, corrector.correct(read).as_slice()); // test correction work\n        assert_eq!(refe, corrector.correct(refe).as_slice()); // test not overcorrection\n"]], "pred": {"ppl": 5.533475875854492, "ppl_lower": 6.360057830810547, "ppl/lowercase_ppl": -1.0813771262084602, "ppl/zlib": 0.006024000588236556, "Min_5.0% Prob": 9.210258197784423, "Min_10.0% Prob": 8.042450155530657, "Min_20.0% Prob": 6.333575753938584, "Min_30.0% Prob": 4.979599886470371, "Min_40.0% Prob": 4.028385133970351, "Min_50.0% Prob": 3.311398932393992, "Min_60.0% Prob": 2.8160360348740903}}
{"hexsha": "ce0bf3a6d09ddbb303c5b95108ef08990609a305", "ext": "rs", "lang": "Rust", "content": "fn should_add_entry() {\n    let tmp_dir = TempDir::new(\"emerald\").unwrap();\n    let a = AddressbookStorage::new(tmp_dir.into_path());\n    let act = a.list();\n    assert_eq!(act.len(), 0);\n\n    let json = serde_json::from_str::<Value>(\n        \"{\\\"address\\\":\\\"0x000000000031eaedbc2b611aa528f22343eb52db\\\", \\\"name\\\":\\\"elaine\\\", \\\n         \\\"description\\\":\\\"drug money\\\"}\",\n    ).unwrap();\n    a.add(&json).ok();\n    let act = a.list();\n    assert_eq!(act.len(), 1);\n}", "item_id": 1, "repo": "driconrikus/webchain-rs", "file": "tests/addressbook_test.rs", "last_update_at": "2019-04-07T19:16:55+00:00", "question_id": "ce0bf3a6d09ddbb303c5b95108ef08990609a305_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn should_add_entry() {\n    let tmp_dir = TempDir::new(\"emerald\").unwrap();\n    let a = AddressbookStorage::new(tmp_dir.into_path());\n    let act = a.list();\n    assert_eq!(act.len(), 0);\n    let json = serde_json::from_str::<Value>(\n        \"{\\\"address\\\":\\\"0x000000000031eaedbc2b611aa528f22343eb52db\\\", \\\"name\\\":\\\"elaine\\\", \\\n         \\\"description\\\":\\\"drug money\\\"}\",\n    ).unwrap();\n    a.add(&json).ok();\n    let act = a.list();\n    assert_eq!(act.len(), 1);\n"]], "pred": {"ppl": 4.2154951095581055, "ppl_lower": 4.910048007965088, "ppl/lowercase_ppl": -1.1060051182443063, "ppl/zlib": 0.0051754210369437045, "Min_5.0% Prob": 8.617591487036812, "Min_10.0% Prob": 7.173380692799886, "Min_20.0% Prob": 5.338578056644749, "Min_30.0% Prob": 4.24481692484447, "Min_40.0% Prob": 3.446853703743703, "Min_50.0% Prob": 2.8327734044162174, "Min_60.0% Prob": 2.387429673756872}}
{"hexsha": "7ffb78845294a56637418f2b0eb1e09c6cf0b4b7", "ext": "rs", "lang": "Rust", "content": "fn is_prime_number3(v: usize, prime_numbers: &[usize]) -> bool {\n    if v < 10000 {\n        let r = prime_numbers.binary_search(&v);\n        return r.is_ok();\n    }\n\n    for n in prime_numbers {\n        if v % n == 0 {\n            return false;\n        }\n    }\n\n    true\n}", "item_id": 2, "repo": "tikv/rp-prof", "file": "examples/profile_proto.rs", "last_update_at": "2019-10-23T12:50:34+00:00", "question_id": "7ffb78845294a56637418f2b0eb1e09c6cf0b4b7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn is_prime_number3(v: usize, prime_numbers: &[usize]) -> bool {\n    if v < 10000 {\n        let r = prime_numbers.binary_search(&v);\n        return r.is_ok();\n    }\n    for n in prime_numbers {\n        if v % n == 0 {\n            return false;\n        }\n    }\n    true\n"]], "pred": {"ppl": 2.1851625442504883, "ppl_lower": 2.1851625442504883, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.004947406435075981, "Min_5.0% Prob": 6.398379802703857, "Min_10.0% Prob": 4.6779529571533205, "Min_20.0% Prob": 3.2477477133274077, "Min_30.0% Prob": 2.438130962848663, "Min_40.0% Prob": 1.913574741408229, "Min_50.0% Prob": 1.5581155867874623, "Min_60.0% Prob": 1.3094856625422835}}
{"hexsha": "a94f445f7cafef35db84cf97b3855cc7ca506211", "ext": "rs", "lang": "Rust", "content": "pub fn next_input(player: &PlayerState, bot: &mut BotState) -> rlbot::ControllerState {\n    if let Some(ref plan) = bot.plan {\n        // we need to take into account the inputs previously sent that will be processed\n        // prior to finding where we are. instead of passing the current player, apply\n        // LAG_FRAMES inputs that are not yet applied\n        let player = player.lag_compensated_player(&bot.controller_history, LAG_FRAMES);\n        let index = closest_plan_index(&player, &plan);\n\n        // we need to look one past closest index to see the controller to reach next position\n        if index < plan.len() - 1 {\n            let current_heading = player.rotation.to_rotation_matrix() * Vector3::new(-1.0, 0.0, 0.0);\n            let (closest_player, _, _) = &plan[index];\n            let (_next_player, controller, _) = &plan[index + 1];\n            //println!(\"index: {}, controller.steer: {:?}\", index, controller.steer);\n\n            // FIXME we should account for differences in the tick and interpolate between the two\n            // closest indices to get the real closet delta/distance\n            let closest_delta = player.position - closest_player.position;\n            let closest_distance = closest_delta.norm();\n            let clockwise_90_rotation = Rotation3::from_euler_angles(0.0, 0.0, PI / 2.0);\n            let relative_right = clockwise_90_rotation * current_heading;\n\n            if closest_distance == 0.0 {\n                bot.turn_errors.push_back(0.0);\n            } else {\n                // NOTE positive for right, negative for left\n                let projection = na::Matrix::dot(&Unit::new_normalize(closest_delta).into_inner(), &relative_right);\n                //println!(\"projection: {}, distance: {}\", projection, closest_distance);\n                let error = projection * closest_distance;\n                bot.turn_errors.push_back(error);\n            }\n\n            if bot.turn_errors.len() > 1000 {\n                // keep last 100\n                bot.turn_errors = bot.turn_errors.split_off(900);\n            }\n\n            //println!(\"controller: {:?}\", controller);\n            let mut input = controller.into();\n            //println!(\"input before: {:?}\", input);\n            pd_adjust(&mut input, &bot.turn_errors);\n            //println!(\"input after: {:?}\", input);\n\n            return input;\n        }\n    }\n\n    // fallback\n    let mut input = rlbot::ControllerState::default();\n    input.throttle = 1.0;\n    if player.position.z > 150.0 && (player.position.z as i32 % 2) == 0 {\n        input.jump = true;\n    }\n    input\n}", "item_id": 6, "repo": "ehsanul/brick", "file": "brain/src/play.rs", "last_update_at": "2019-05-14T15:30:02+00:00", "question_id": "a94f445f7cafef35db84cf97b3855cc7ca506211_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn next_input(player: &PlayerState, bot: &mut BotState) -> rlbot::ControllerState {\n    if let Some(ref plan) = bot.plan {\n        // we need to take into account the inputs previously sent that will be processed\n        // prior to finding where we are. instead of passing the current player, apply\n        // LAG_FRAMES inputs that are not yet applied\n        let player = player.lag_compensated_player(&bot.controller_history, LAG_FRAMES);\n        let index = closest_plan_index(&player, &plan);\n        // we need to look one past closest index to see the controller to reach next position\n        if index < plan.len() - 1 {\n            let current_heading = player.rotation.to_rotation_matrix() * Vector3::new(-1.0, 0.0, 0.0);\n            let (closest_player, _, _) = &plan[index];\n            let (_next_player, controller, _) = &plan[index + 1];\n            //println!(\"index: {}, controller.steer: {:?}\", index, controller.steer);\n            // FIXME we should account for differences in the tick and interpolate between the two\n            // closest indices to get the real closet delta/distance\n            let closest_delta = player.position - closest_player.position;\n            let closest_distance = closest_delta.norm();\n            let clockwise_90_rotation = Rotation3::from_euler_angles(0.0, 0.0, PI / 2.0);\n            let relative_right = clockwise_90_rotation * current_heading;\n            if closest_distance == 0.0 {\n                bot.turn_errors.push_back(0.0);\n            } else {\n                // NOTE positive for right, negative for left\n                let projection = na::Matrix::dot(&Unit::new_normalize(closest_delta).into_inner(), &relative_right);\n                //println!(\"projection: {}, distance: {}\", projection, closest_distance);\n                let error = projection * closest_distance;\n                bot.turn_errors.push_back(error);\n            }\n            if bot.turn_errors.len() > 1000 {\n                // keep last 100\n                bot.turn_errors = bot.turn_errors.split_off(900);\n            }\n            //println!(\"controller: {:?}\", controller);\n            let mut input = controller.into();\n            //println!(\"input before: {:?}\", input);\n            pd_adjust(&mut input, &bot.turn_errors);\n            //println!(\"input after: {:?}\", input);\n            return input;\n        }\n    }\n    // fallback\n    let mut input = rlbot::ControllerState::default();\n    input.throttle = 1.0;\n    if player.position.z > 150.0 && (player.position.z as i32 % 2) == 0 {\n        input.jump = true;\n    }\n    input\n"]], "pred": {"ppl": 3.2996418476104736, "ppl_lower": 3.636396646499634, "ppl/lowercase_ppl": -1.0814024069728878, "ppl/zlib": 0.0011843392178128842, "Min_5.0% Prob": 8.478994833098518, "Min_10.0% Prob": 6.61639709342016, "Min_20.0% Prob": 4.775098847694138, "Min_30.0% Prob": 3.627221344552968, "Min_40.0% Prob": 2.882929627587195, "Min_50.0% Prob": 2.359680650634286, "Min_60.0% Prob": 1.982063125599833}}
{"hexsha": "bf8e6ec5bd774f4b8dc104e6b26e1bc0825fc19d", "ext": "rs", "lang": "Rust", "content": "pub fn purge_handled_balls_from_hash_tree(db: &Connection) -> Result<()> {\n    let mut stmt = db.prepare_cached(\n        \"SELECT ball FROM hash_tree_balls \\\n         CROSS JOIN balls USING(ball)\",\n    )?;\n    let balls = stmt.query_map(&[], |row| row.get::<_, String>(0))?;\n\n    let mut stmt = db.prepare_cached(\"DELETE FROM hash_tree_balls WHERE ball=?\")?;\n    for ball in balls {\n        stmt.execute(&[&ball?])?;\n    }\n    Ok(())\n}", "item_id": 4, "repo": "ringringringring/rust-trustnote", "file": "src/catchup.rs", "last_update_at": "2019-05-28T10:59:27+00:00", "question_id": "bf8e6ec5bd774f4b8dc104e6b26e1bc0825fc19d_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn purge_handled_balls_from_hash_tree(db: &Connection) -> Result<()> {\n    let mut stmt = db.prepare_cached(\n        \"SELECT ball FROM hash_tree_balls \\\n         CROSS JOIN balls USING(ball)\",\n    )?;\n    let balls = stmt.query_map(&[], |row| row.get::<_, String>(0))?;\n    let mut stmt = db.prepare_cached(\"DELETE FROM hash_tree_balls WHERE ball=?\")?;\n    for ball in balls {\n        stmt.execute(&[&ball?])?;\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.4661448001861572, "ppl_lower": 3.221921443939209, "ppl/lowercase_ppl": -1.2961501896747878, "ppl/zlib": 0.003318588682596901, "Min_5.0% Prob": 8.059151232242584, "Min_10.0% Prob": 5.78517909348011, "Min_20.0% Prob": 3.8874878846108913, "Min_30.0% Prob": 2.884422163789471, "Min_40.0% Prob": 2.213904279928941, "Min_50.0% Prob": 1.8045895335115032, "Min_60.0% Prob": 1.5136299749125832}}
{"hexsha": "045bda0b25736e784dac7151320cf5230548722d", "ext": "rs", "lang": "Rust", "content": "fn can_apply_simple_change_tagged() {\n        let initial_tree    = tree!(\"test\", (\"one\", 1), (\"two\", 2), (\"three\", 3));\n        let change_two      = TreeChange::new(&(\"two\"), &(\"replaced\", 4));\n        let changed_tree    = change_two.apply(&initial_tree);\n\n        assert!(changed_tree.get_child_ref_at(\"one\").unwrap().get_value().to_int(0) == 1);\n        assert!(changed_tree.get_child_ref_at(\"replaced\").unwrap().get_value().to_int(0) == 4);\n        assert!(!changed_tree.get_child_ref_at(\"replaced\").unwrap().get_sibling_ref().is_none());\n        assert!(changed_tree.get_child_ref_at(\"two\").is_none());\n        assert!(!changed_tree.get_child_ref_at(\"three\").is_none());\n    }", "item_id": 0, "repo": "Logicalshift/tame-tree", "file": "src/tree/change.rs", "last_update_at": "2019-04-30T08:19:14+00:00", "question_id": "045bda0b25736e784dac7151320cf5230548722d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn can_apply_simple_change_tagged() {\n        let initial_tree    = tree!(\"test\", (\"one\", 1), (\"two\", 2), (\"three\", 3));\n        let change_two      = TreeChange::new(&(\"two\"), &(\"replaced\", 4));\n        let changed_tree    = change_two.apply(&initial_tree);\n        assert!(changed_tree.get_child_ref_at(\"one\").unwrap().get_value().to_int(0) == 1);\n        assert!(changed_tree.get_child_ref_at(\"replaced\").unwrap().get_value().to_int(0) == 4);\n        assert!(!changed_tree.get_child_ref_at(\"replaced\").unwrap().get_sibling_ref().is_none());\n        assert!(changed_tree.get_child_ref_at(\"two\").is_none());\n        assert!(!changed_tree.get_child_ref_at(\"three\").is_none());\n"]], "pred": {"ppl": 2.6770052909851074, "ppl_lower": 2.8134469985961914, "ppl/lowercase_ppl": -1.0504841515497432, "ppl/zlib": 0.0038920898853632116, "Min_5.0% Prob": 7.163341959317525, "Min_10.0% Prob": 5.8458245893319445, "Min_20.0% Prob": 4.2176373898983, "Min_30.0% Prob": 3.140097522901164, "Min_40.0% Prob": 2.4340922312500575, "Min_50.0% Prob": 1.9633320009956756, "Min_60.0% Prob": 1.639222426152426}}
{"hexsha": "13450344a708155aea510fca40876281dc394e86", "ext": "rs", "lang": "Rust", "content": "pub fn secret_2_address(secret: &str) -> Address {\n    let a = hex::decode(clean_0x(secret)).unwrap();\n    let secret_key = secp256k1::SecretKey::parse_slice(a.as_slice()).unwrap();\n    let public_key = secp256k1::PublicKey::from_secret_key(&secret_key);\n    let serialized = public_key.serialize();\n    let mut public = Public::default();\n    public.copy_from_slice(&serialized[1..65]);\n    public_2_address(&public)\n}", "item_id": 4, "repo": "baajur/cita", "file": "tests/json-test/src/helper.rs", "last_update_at": "2019-11-26T10:07:48+00:00", "question_id": "13450344a708155aea510fca40876281dc394e86_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn secret_2_address(secret: &str) -> Address {\n    let a = hex::decode(clean_0x(secret)).unwrap();\n    let secret_key = secp256k1::SecretKey::parse_slice(a.as_slice()).unwrap();\n    let public_key = secp256k1::PublicKey::from_secret_key(&secret_key);\n    let serialized = public_key.serialize();\n    let mut public = Public::default();\n    public.copy_from_slice(&serialized[1..65]);\n    public_2_address(&public)\n"]], "pred": {"ppl": 2.524487257003784, "ppl_lower": 3.128732442855835, "ppl/lowercase_ppl": -1.2317291323712698, "ppl/zlib": 0.004152636661763983, "Min_5.0% Prob": 8.289449283054896, "Min_10.0% Prob": 6.227658782686506, "Min_20.0% Prob": 4.07153543521618, "Min_30.0% Prob": 2.957362954006639, "Min_40.0% Prob": 2.271496352964434, "Min_50.0% Prob": 1.8533677243524127, "Min_60.0% Prob": 1.5409067117705428}}
{"hexsha": "fb2806f592d4ef9064be9b3733dc3d197c377900", "ext": "rs", "lang": "Rust", "content": "fn slti_imm() {\n    let program = vec![\n        0x13, 0xa1, 0x10, 0x00, // slti sp, ra, 1\n        0x93, 0xa1, 0xf0, 0xff, // slti gp, ra -1\n        0x73, 0x00, 0x50, 0x10, // wfi\n    ];\n\n    let riscv = execute_program(program);\n\n    assert_eq!(riscv.get_gpr(sp), 1);\n    assert_eq!(riscv.get_gpr(gp), 0);\n}", "item_id": 1, "repo": "tomoyuki-nakabayashi/Rustemu86", "file": "arch/riscv/src/instruction_level_tests/rv32i.rs", "last_update_at": "2019-02-07T05:27:30+00:00", "question_id": "fb2806f592d4ef9064be9b3733dc3d197c377900_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn slti_imm() {\n    let program = vec![\n        0x13, 0xa1, 0x10, 0x00, // slti sp, ra, 1\n        0x93, 0xa1, 0xf0, 0xff, // slti gp, ra -1\n        0x73, 0x00, 0x50, 0x10, // wfi\n    ];\n    let riscv = execute_program(program);\n    assert_eq!(riscv.get_gpr(sp), 1);\n    assert_eq!(riscv.get_gpr(gp), 0);\n"]], "pred": {"ppl": 2.663623571395874, "ppl_lower": 2.663623571395874, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005695857213171481, "Min_5.0% Prob": 8.01927250623703, "Min_10.0% Prob": 6.133078172802925, "Min_20.0% Prob": 4.113635251016328, "Min_30.0% Prob": 3.0403914844989774, "Min_40.0% Prob": 2.4174944248163337, "Min_50.0% Prob": 1.957291821578899, "Min_60.0% Prob": 1.6328047441504896}}
{"hexsha": "f4200d5b69463191ec55095c12534810cdc02eea", "ext": "rs", "lang": "Rust", "content": "pub async fn get_block_operations(\n    _req: Request<Body>,\n    params: Params,\n    _: Query,\n    env: Arc<RpcServiceEnvironment>,\n) -> ServiceResult {\n    let chain_id = parse_chain_id(required_param!(params, \"chain_id\")?, &env)?;\n    let block_hash =\n        parse_block_hash_or_fail!(&chain_id, required_param!(params, \"block_id\")?, &env);\n\n    result_to_json_response(\n        base_services::get_block_operations_metadata(chain_id, &block_hash, &env).await,\n        env.log(),\n    )\n}", "item_id": 22, "repo": "simplestaking/tezos-rs", "file": "rpc/src/server/shell_handler.rs", "last_update_at": "2019-10-25T18:40:15+00:00", "question_id": "f4200d5b69463191ec55095c12534810cdc02eea_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn get_block_operations(\n    _req: Request<Body>,\n    params: Params,\n    _: Query,\n    env: Arc<RpcServiceEnvironment>,\n) -> ServiceResult {\n    let chain_id = parse_chain_id(required_param!(params, \"chain_id\")?, &env)?;\n    let block_hash =\n        parse_block_hash_or_fail!(&chain_id, required_param!(params, \"block_id\")?, &env);\n    result_to_json_response(\n        base_services::get_block_operations_metadata(chain_id, &block_hash, &env).await,\n        env.log(),\n    )\n"]], "pred": {"ppl": 2.9193031787872314, "ppl_lower": 4.248105525970459, "ppl/lowercase_ppl": -1.3501469572624758, "ppl/zlib": 0.003938768200000448, "Min_5.0% Prob": 8.960169911384583, "Min_10.0% Prob": 6.589032858610153, "Min_20.0% Prob": 4.368905139691902, "Min_30.0% Prob": 3.30783725976944, "Min_40.0% Prob": 2.606838912216585, "Min_50.0% Prob": 2.1192886811636744, "Min_60.0% Prob": 1.7934444255754352}}
{"hexsha": "2a33af9047576b2894497c5d67f427b2828214e5", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn reload_trampoline<P>(this: *mut ffi::GResolver, f: glib_ffi::gpointer)\nwhere P: IsA<Resolver> {\n    callback_guard!();\n    let f: &&(Fn(&P) + 'static) = transmute(f);\n    f(&Resolver::from_glib_borrow(this).downcast_unchecked())\n}", "item_id": 0, "repo": "ystreet/gio", "file": "src/auto/resolver.rs", "last_update_at": "2019-08-16T16:25:27+00:00", "question_id": "2a33af9047576b2894497c5d67f427b2828214e5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe extern \"C\" fn reload_trampoline<P>(this: *mut ffi::GResolver, f: glib_ffi::gpointer)\nwhere P: IsA<Resolver> {\n    callback_guard!();\n    let f: &&(Fn(&P) + 'static) = transmute(f);\n    f(&Resolver::from_glib_borrow(this).downcast_unchecked())\n"]], "pred": {"ppl": 2.103778839111328, "ppl_lower": 4.499881267547607, "ppl/lowercase_ppl": -2.022293771062289, "ppl/zlib": 0.003756238256867346, "Min_5.0% Prob": 10.875768184661865, "Min_10.0% Prob": 6.834924591912164, "Min_20.0% Prob": 3.7298540645524074, "Min_30.0% Prob": 2.477265941300269, "Min_40.0% Prob": 1.8953675481882926, "Min_50.0% Prob": 1.502359192527365, "Min_60.0% Prob": 1.2436985964445268}}
{"hexsha": "9b22243f15d784a38d414df180b98694caf0a46a", "ext": "rs", "lang": "Rust", "content": "fn process_table(table: &Table) -> ProcessedTable {\n    let mut processed_data = vec![];\n    for row in &table.data {\n        let mut out_row = vec![];\n        for column in row {\n            let cleaned = clean(&column.contents);\n            out_row.push(ProcessedCell {\n                contents: split_sublines(&cleaned),\n                style: column.style,\n            });\n        }\n        processed_data.push(out_row);\n    }\n\n    let mut processed_headers = vec![];\n    for header in &table.headers {\n        let cleaned = clean(&header.contents);\n        processed_headers.push(ProcessedCell {\n            contents: split_sublines(&cleaned),\n            style: header.style,\n        });\n    }\n\n    ProcessedTable {\n        headers: processed_headers,\n        data: processed_data,\n        theme: table.theme.clone(),\n    }\n}", "item_id": 0, "repo": "hustcer/nushell", "file": "crates/nu-table/src/table.rs", "last_update_at": "2019-06-13T10:16:43+00:00", "question_id": "9b22243f15d784a38d414df180b98694caf0a46a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn process_table(table: &Table) -> ProcessedTable {\n    let mut processed_data = vec![];\n    for row in &table.data {\n        let mut out_row = vec![];\n        for column in row {\n            let cleaned = clean(&column.contents);\n            out_row.push(ProcessedCell {\n                contents: split_sublines(&cleaned),\n                style: column.style,\n            });\n        }\n        processed_data.push(out_row);\n    }\n    let mut processed_headers = vec![];\n    for header in &table.headers {\n        let cleaned = clean(&header.contents);\n        processed_headers.push(ProcessedCell {\n            contents: split_sublines(&cleaned),\n            style: header.style,\n        });\n    }\n    ProcessedTable {\n        headers: processed_headers,\n        data: processed_data,\n        theme: table.theme.clone(),\n    }\n"]], "pred": {"ppl": 1.8159288167953491, "ppl_lower": 1.9559144973754883, "ppl/lowercase_ppl": -1.1244739177193415, "ppl/zlib": 0.002078735475996271, "Min_5.0% Prob": 6.726008718663996, "Min_10.0% Prob": 4.64525918527083, "Min_20.0% Prob": 2.793284778462516, "Min_30.0% Prob": 1.95707192556823, "Min_40.0% Prob": 1.4903841417815005, "Min_50.0% Prob": 1.196328864310329, "Min_60.0% Prob": 0.9968548157408724}}
{"hexsha": "57a011a843d4347ef4ad4b0efc200225090cdd5e", "ext": "rs", "lang": "Rust", "content": "fn test_fft2() -> Result<()> {\n        let input = parse_signal(\"80871224585914546619083218645595\")?;\n        assert_eq!([2, 4, 1, 7, 6, 1, 7, 6], apply_fft(100, &input)[0..8]);\n        Ok(())\n    }", "item_id": 5, "repo": "HaronK/aoc2019", "file": "task16_1/src/main.rs", "last_update_at": "2019-12-12T13:11:51+00:00", "question_id": "57a011a843d4347ef4ad4b0efc200225090cdd5e_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_fft2() -> Result<()> {\n        let input = parse_signal(\"80871224585914546619083218645595\")?;\n        assert_eq!([2, 4, 1, 7, 6, 1, 7, 6], apply_fft(100, &input)[0..8]);\n        Ok(())\n"]], "pred": {"ppl": 3.0766448974609375, "ppl_lower": 3.581198215484619, "ppl/lowercase_ppl": -1.1351240389231643, "ppl/zlib": 0.006980370709565995, "Min_5.0% Prob": 7.847529697418213, "Min_10.0% Prob": 6.070993510159579, "Min_20.0% Prob": 4.519898414611816, "Min_30.0% Prob": 3.482463684949008, "Min_40.0% Prob": 2.76968098228628, "Min_50.0% Prob": 2.2536303438923575, "Min_60.0% Prob": 1.8861547597881518}}
{"hexsha": "3a4b0708fe96dfc325bf1d4d3549e1c2eb5bca86", "ext": "rs", "lang": "Rust", "content": "fn test_insert_batch_error() {\n        let db = MemoryDB::open();\n\n        let data = b\"test\".to_vec();\n\n        match db.insert_batch(None, vec![data], vec![]) {\n            Err(DatabaseError::InvalidData) => (), // pass\n            _ => panic!(\"should return error DatabaseError::InvalidData\"),\n        }\n    }", "item_id": 1, "repo": "citahub/cita-database", "file": "src/memorydb.rs", "last_update_at": "2019-07-17T11:21:05+00:00", "question_id": "3a4b0708fe96dfc325bf1d4d3549e1c2eb5bca86_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_insert_batch_error() {\n        let db = MemoryDB::open();\n        let data = b\"test\".to_vec();\n        match db.insert_batch(None, vec![data], vec![]) {\n            Err(DatabaseError::InvalidData) => (), // pass\n            _ => panic!(\"should return error DatabaseError::InvalidData\"),\n        }\n"]], "pred": {"ppl": 3.6798949241638184, "ppl_lower": 6.154587268829346, "ppl/lowercase_ppl": -1.3947499732967175, "ppl/zlib": 0.006967295179448315, "Min_5.0% Prob": 6.943180441856384, "Min_10.0% Prob": 5.58113267686632, "Min_20.0% Prob": 4.422282165951199, "Min_30.0% Prob": 3.7381932735443115, "Min_40.0% Prob": 3.0895213070842953, "Min_50.0% Prob": 2.5730849742889403, "Min_60.0% Prob": 2.1785193209846816}}
{"hexsha": "9d7144822e067d0fd0a9ac28041188ee73d2dd65", "ext": "rs", "lang": "Rust", "content": "fn notice_with_add_environment() {\n        let notice = Notice::builder().add_environment(\"foo\", \"bar\").build();\n        let expected_json = r#\"\n        {\n            \"errors\": [],\n            \"environment\": {\n                \"foo\": \"bar\"\n            }\n        }\n        \"#;\n        assert_eq!(Value::from_str(expected_json).unwrap(), Value::from(notice));\n    }", "item_id": 1, "repo": "kyrylo/airbrake-rust", "file": "src/notice/notice.rs", "last_update_at": "2019-09-16T21:29:44+00:00", "question_id": "9d7144822e067d0fd0a9ac28041188ee73d2dd65_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn notice_with_add_environment() {\n        let notice = Notice::builder().add_environment(\"foo\", \"bar\").build();\n        let expected_json = r#\"\n        {\n            \"errors\": [],\n            \"environment\": {\n                \"foo\": \"bar\"\n            }\n        }\n        \"#;\n        assert_eq!(Value::from_str(expected_json).unwrap(), Value::from(notice));\n"]], "pred": {"ppl": 2.8856539726257324, "ppl_lower": 3.043738842010498, "ppl/lowercase_ppl": -1.0503279161848968, "ppl/zlib": 0.005607151082318436, "Min_5.0% Prob": 9.509319496154784, "Min_10.0% Prob": 7.097214579582214, "Min_20.0% Prob": 4.465468430519104, "Min_30.0% Prob": 3.3278734227021536, "Min_40.0% Prob": 2.590771449357271, "Min_50.0% Prob": 2.112222620546818, "Min_60.0% Prob": 1.775553702438871}}
{"hexsha": "72c9a7eba86ad12532b8101b9ba38d094b9dc8fa", "ext": "rs", "lang": "Rust", "content": "fn escape<T: AsRef<CStr>>(s: T) -> String {\n    let mut res = String::new();\n    s.as_ref().to_bytes().iter().for_each(|c| match c {\n        b'\\n' => {\n            res.push_str(\"\\\\n\");\n        }\n        b'\\t' => {\n            res.push_str(\"\\\\t\");\n        }\n        _ => {\n            if *c >= 0x20 && *c < 0x7f {\n                res.push(*c as char);\n            } else {\n                res.push_str(&format!(\"\\\\{:o}\", c));\n            }\n        }\n    });\n    res\n}", "item_id": 2, "repo": "iu-parfunc/systrace", "file": "examples/hostecho/src/show/args.rs", "last_update_at": "2019-06-14T23:39:19+00:00", "question_id": "72c9a7eba86ad12532b8101b9ba38d094b9dc8fa_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn escape<T: AsRef<CStr>>(s: T) -> String {\n    let mut res = String::new();\n    s.as_ref().to_bytes().iter().for_each(|c| match c {\n        b'\\n' => {\n            res.push_str(\"\\\\n\");\n        }\n        b'\\t' => {\n            res.push_str(\"\\\\t\");\n        }\n        _ => {\n            if *c >= 0x20 && *c < 0x7f {\n                res.push(*c as char);\n            } else {\n                res.push_str(&format!(\"\\\\{:o}\", c));\n            }\n        }\n    });\n    res\n"]], "pred": {"ppl": 1.6583645343780518, "ppl_lower": 2.2772302627563477, "ppl/lowercase_ppl": -1.6269434830337735, "ppl/zlib": 0.0021616747712213027, "Min_5.0% Prob": 5.401938557624817, "Min_10.0% Prob": 3.8689754232764244, "Min_20.0% Prob": 2.3622881508234777, "Min_30.0% Prob": 1.637900441288948, "Min_40.0% Prob": 1.2649236999903664, "Min_50.0% Prob": 1.014129025816738, "Min_60.0% Prob": 0.8438189327530563}}
{"hexsha": "48fdd719daff0a3ee010653b00f98ae7e12f3a36", "ext": "rs", "lang": "Rust", "content": "pub fn permute_vector_into_buffer() {\n    let x = vector![ 0, 1, 2, 3];\n    let p = PermutationMatrix::from_array(vec![2, 1, 3, 0]).unwrap();\n    let mut output = Vector::zeros(4);\n    p.permute_vector_into_buffer(&x, &mut output);\n    assert_vector_eq!(output, vector![ 3, 1, 0, 2]);\n}", "item_id": 18, "repo": "mesalock-linux/rulinalg-sgx", "file": "sgx/rulinalg-sgx-test/enclave/src/matrix/permutation_matrix.rs", "last_update_at": "2019-08-22T16:34:34+00:00", "question_id": "48fdd719daff0a3ee010653b00f98ae7e12f3a36_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn permute_vector_into_buffer() {\n    let x = vector![ 0, 1, 2, 3];\n    let p = PermutationMatrix::from_array(vec![2, 1, 3, 0]).unwrap();\n    let mut output = Vector::zeros(4);\n    p.permute_vector_into_buffer(&x, &mut output);\n    assert_vector_eq!(output, vector![ 3, 1, 0, 2]);\n"]], "pred": {"ppl": 2.918327808380127, "ppl_lower": 3.4447696208953857, "ppl/lowercase_ppl": -1.1548502100776838, "ppl/zlib": 0.0058207107819568706, "Min_5.0% Prob": 8.189201927185058, "Min_10.0% Prob": 6.472231258045543, "Min_20.0% Prob": 4.420131750728773, "Min_30.0% Prob": 3.2838697825159344, "Min_40.0% Prob": 2.5720769357174, "Min_50.0% Prob": 2.09588568089372, "Min_60.0% Prob": 1.78851591487016}}
{"hexsha": "cf28a84a0251ce76297200a96cf7eb2b418bdb3b", "ext": "rs", "lang": "Rust", "content": "fn as_unix_millis() {\n        assert_eq!(Some(100),\n                   (UNIX_EPOCH + Duration::from_millis(100)).as_unix_millis());\n        assert_eq!(Some(-100),\n                   (UNIX_EPOCH - Duration::from_millis(100)).as_unix_millis());\n        assert_eq!(None,\n                   (UNIX_EPOCH - Duration::from_secs(1 << 60)).as_unix_millis());\n    }", "item_id": 0, "repo": "sfackler/time2", "file": "src/system_time.rs", "last_update_at": "2019-08-26T09:46:47+00:00", "question_id": "cf28a84a0251ce76297200a96cf7eb2b418bdb3b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn as_unix_millis() {\n        assert_eq!(Some(100),\n                   (UNIX_EPOCH + Duration::from_millis(100)).as_unix_millis());\n        assert_eq!(Some(-100),\n                   (UNIX_EPOCH - Duration::from_millis(100)).as_unix_millis());\n        assert_eq!(None,\n                   (UNIX_EPOCH - Duration::from_secs(1 << 60)).as_unix_millis());\n"]], "pred": {"ppl": 1.962932825088501, "ppl_lower": 2.3802568912506104, "ppl/lowercase_ppl": -1.285820551268138, "ppl/zlib": 0.005395517553385031, "Min_5.0% Prob": 6.709210952123006, "Min_10.0% Prob": 5.34717922944289, "Min_20.0% Prob": 3.2610937699123665, "Min_30.0% Prob": 2.262700403109193, "Min_40.0% Prob": 1.6922289394532088, "Min_50.0% Prob": 1.3474541413460803, "Min_60.0% Prob": 1.1320658599279454}}
{"hexsha": "eaa111470141c108d7893ca634be26134ec228b4", "ext": "rs", "lang": "Rust", "content": "fn when_connected<T, S, R>(\n    params: T::Params,\n    sender: S,\n    receiver: R,\n    handle: &Handle,\n    client_event_sender: mpsc::Sender<ClientEvent>,\n) -> T\nwhere\n    T: ClientState + Clone + 'static,\n    S: Sink<SinkItem = T::Send, SinkError = ()> + 'static,\n    R: Stream<Item = T::Receive, Error = Error> + 'static,\n{\n    let (from_socket, to_socket) = mpsc::channel(20);\n    let client = T::new(params, from_socket);\n    let connect_event_f = client_event_sender\n        .clone()\n        .send(client.connected_event())\n        .map(|_| ())\n        .map_err(|_| ());\n    handle.spawn(connect_event_f);\n\n    let client_id = client.id();\n    let recv_client = client.clone();\n    let from_socket_stream = receiver\n        .map(move |message| recv_client.on_receive(message))\n        .map_err(move |err| error!(\"[{}] Recv error: {}\", client_id, err));\n    let socket_read_stream = client_event_sender\n        .clone()\n        .sink_map_err(|_| ())\n        .send_all(from_socket_stream);\n    let send_stream = sender.send_all(to_socket);\n    let disconnect_message = client.disconnected_event();\n    let connection = send_stream\n        .map(|_| ())\n        .select(socket_read_stream.map(|_| ()))\n        .then(move |_| {\n            client_event_sender\n                .clone()\n                .send(disconnect_message)\n                .map(|_| ())\n                .map_err(|_| ())\n        });\n\n    handle.spawn(connection);\n    client\n}", "item_id": 2, "repo": "kphelps/akio", "file": "akio-net/src/protocol.rs", "last_update_at": "2019-01-06T23:05:12+00:00", "question_id": "eaa111470141c108d7893ca634be26134ec228b4_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn when_connected<T, S, R>(\n    params: T::Params,\n    sender: S,\n    receiver: R,\n    handle: &Handle,\n    client_event_sender: mpsc::Sender<ClientEvent>,\n) -> T\nwhere\n    T: ClientState + Clone + 'static,\n    S: Sink<SinkItem = T::Send, SinkError = ()> + 'static,\n    R: Stream<Item = T::Receive, Error = Error> + 'static,\n{\n    let (from_socket, to_socket) = mpsc::channel(20);\n    let client = T::new(params, from_socket);\n    let connect_event_f = client_event_sender\n        .clone()\n        .send(client.connected_event())\n        .map(|_| ())\n        .map_err(|_| ());\n    handle.spawn(connect_event_f);\n    let client_id = client.id();\n    let recv_client = client.clone();\n    let from_socket_stream = receiver\n        .map(move |message| recv_client.on_receive(message))\n        .map_err(move |err| error!(\"[{}] Recv error: {}\", client_id, err));\n    let socket_read_stream = client_event_sender\n        .clone()\n        .sink_map_err(|_| ())\n        .send_all(from_socket_stream);\n    let send_stream = sender.send_all(to_socket);\n    let disconnect_message = client.disconnected_event();\n    let connection = send_stream\n        .map(|_| ())\n        .select(socket_read_stream.map(|_| ()))\n        .then(move |_| {\n            client_event_sender\n                .clone()\n                .send(disconnect_message)\n                .map(|_| ())\n                .map_err(|_| ())\n        });\n    handle.spawn(connection);\n    client\n"]], "pred": {"ppl": 2.044290065765381, "ppl_lower": 2.2961745262145996, "ppl/lowercase_ppl": -1.162497479170478, "ppl/zlib": 0.0014020599472886008, "Min_5.0% Prob": 5.812247673670451, "Min_10.0% Prob": 4.57884315152963, "Min_20.0% Prob": 3.027149235464863, "Min_30.0% Prob": 2.2393858956879584, "Min_40.0% Prob": 1.7459341238454444, "Min_50.0% Prob": 1.4238354646223637, "Min_60.0% Prob": 1.189875808672474}}
{"hexsha": "3fec523dcb6d96ef2d6f29f70124ebe3f1578bf2", "ext": "rs", "lang": "Rust", "content": "pub fn light_block_import<B, E, Block: BlockT<Hash=H256>, RA, PRA>(\n\tclient: Arc<Client<B, E, Block, RA>>,\n\tauthority_set_provider: Arc<dyn AuthoritySetForFinalityChecker<Block>>,\n\tapi: Arc<PRA>,\n) -> Result<GrandpaLightBlockImport<B, E, Block, RA>, ClientError>\n\twhere\n\t\tB: Backend<Block, Blake2Hasher> + 'static,\n\t\tE: CallExecutor<Block, Blake2Hasher> + 'static + Clone + Send + Sync,\n\t\tRA: Send + Sync,\n\t\tPRA: ProvideRuntimeApi,\n\t\tPRA::Api: GrandpaApi<Block>,\n{\n\tlet info = client.info();\n\t#[allow(deprecated)]\n\tlet import_data = load_aux_import_data(info.chain.finalized_hash, &**client.backend(), api)?;\n\tOk(GrandpaLightBlockImport {\n\t\tclient,\n\t\tauthority_set_provider,\n\t\tdata: Arc::new(RwLock::new(import_data)),\n\t})\n}", "item_id": 0, "repo": "HPIPS/HPIPS_Chain", "file": "core/finality-grandpa/src/light_import.rs", "last_update_at": "2019-08-07T10:22:08+00:00", "question_id": "3fec523dcb6d96ef2d6f29f70124ebe3f1578bf2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn light_block_import<B, E, Block: BlockT<Hash=H256>, RA, PRA>(\n\tclient: Arc<Client<B, E, Block, RA>>,\n\tauthority_set_provider: Arc<dyn AuthoritySetForFinalityChecker<Block>>,\n\tapi: Arc<PRA>,\n) -> Result<GrandpaLightBlockImport<B, E, Block, RA>, ClientError>\n\twhere\n\t\tB: Backend<Block, Blake2Hasher> + 'static,\n\t\tE: CallExecutor<Block, Blake2Hasher> + 'static + Clone + Send + Sync,\n\t\tRA: Send + Sync,\n\t\tPRA: ProvideRuntimeApi,\n\t\tPRA::Api: GrandpaApi<Block>,\n{\n\tlet info = client.info();\n\t#[allow(deprecated)]\n\tlet import_data = load_aux_import_data(info.chain.finalized_hash, &**client.backend(), api)?;\n\tOk(GrandpaLightBlockImport {\n\t\tclient,\n\t\tauthority_set_provider,\n\t\tdata: Arc::new(RwLock::new(import_data)),\n\t})\n"]], "pred": {"ppl": 3.0225677490234375, "ppl_lower": 5.72475528717041, "ppl/lowercase_ppl": -1.577424470256575, "ppl/zlib": 0.0026978212637846157, "Min_5.0% Prob": 8.539945125579834, "Min_10.0% Prob": 6.716526574101941, "Min_20.0% Prob": 4.567574357164317, "Min_30.0% Prob": 3.4158502207405266, "Min_40.0% Prob": 2.6961155526148968, "Min_50.0% Prob": 2.2024260929798425, "Min_60.0% Prob": 1.848709718904325}}
{"hexsha": "3f36e0b1faaea8f1d4fec66a2bea1c6bacda2743", "ext": "rs", "lang": "Rust", "content": "fn valid_system_is_parsed() {\n        let input = r##\"config:\n        step = 8\n        angle = 45\n        rules:\n        axiom = A\n        A => BA\n        B => A\n        \"##;\n\n        let (actual, _rem) = system().parse(input).expect(\"to parse a system\");\n\n        let expected = LSystem {\n            render_config: RenderConfig { step: 8, angle: 45 },\n            axiom: vec!['A'],\n            rules: LSystemRules::from_rules(vec![Rule::new('A', vec!['B', 'A']), Rule::new('B', vec!['A'])])\n        };\n        assert_eq!(actual, expected);\n    }", "item_id": 5, "repo": "jacobmischka/workshop", "file": "code/examplar-parser/src/lib.rs", "last_update_at": "2019-11-10T13:34:47+00:00", "question_id": "3f36e0b1faaea8f1d4fec66a2bea1c6bacda2743_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn valid_system_is_parsed() {\n        let input = r##\"config:\n        step = 8\n        angle = 45\n        rules:\n        axiom = A\n        A => BA\n        B => A\n        \"##;\n        let (actual, _rem) = system().parse(input).expect(\"to parse a system\");\n        let expected = LSystem {\n            render_config: RenderConfig { step: 8, angle: 45 },\n            axiom: vec!['A'],\n            rules: LSystemRules::from_rules(vec![Rule::new('A', vec!['B', 'A']), Rule::new('B', vec!['A'])])\n        };\n        assert_eq!(actual, expected);\n"]], "pred": {"ppl": 3.6839280128479004, "ppl_lower": 4.290438175201416, "ppl/lowercase_ppl": -1.1168801194087803, "ppl/zlib": 0.004707507500778656, "Min_5.0% Prob": 8.716583516862658, "Min_10.0% Prob": 7.2101062933603925, "Min_20.0% Prob": 5.152193592654334, "Min_30.0% Prob": 3.9450201612931712, "Min_40.0% Prob": 3.1274379334515996, "Min_50.0% Prob": 2.5690905196799174, "Min_60.0% Prob": 2.1710334080788822}}
{"hexsha": "eb9b23205a19504ec56baccd162346bee27f35ac", "ext": "rs", "lang": "Rust", "content": "fn test_scope() {\n        /*\n        Scope (_SB.MBRD)\n        {\n            Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings\n            {\n                Memory32Fixed (ReadWrite,\n                    0xE8000000,         // Address Base\n                    0x10000000,         // Address Length\n                    )\n            })\n        }\n        */\n\n        let mbrd_scope = [\n            0x10, 0x21, 0x2E, 0x5F, 0x53, 0x42, 0x5F, 0x4D, 0x42, 0x52, 0x44, 0x08, 0x5F, 0x43,\n            0x52, 0x53, 0x11, 0x11, 0x0A, 0x0E, 0x86, 0x09, 0x00, 0x01, 0x00, 0x00, 0x00, 0xE8,\n            0x00, 0x00, 0x00, 0x10, 0x79, 0x00,\n        ];\n\n        assert_eq!(\n            Scope::new(\n                \"_SB_.MBRD\".into(),\n                vec![&Name::new(\n                    \"_CRS\".into(),\n                    &ResourceTemplate::new(vec![&Memory32Fixed::new(\n                        true,\n                        0xE800_0000,\n                        0x1000_0000\n                    )])\n                )]\n            )\n            .to_aml_bytes(),\n            &mbrd_scope[..]\n        );\n    }", "item_id": 3, "repo": "drmint80/cloud-hypervisor", "file": "acpi_tables/src/aml.rs", "last_update_at": "2019-11-15T20:21:47+00:00", "question_id": "eb9b23205a19504ec56baccd162346bee27f35ac_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_scope() {\n        /*\n        Scope (_SB.MBRD)\n        {\n            Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings\n            {\n                Memory32Fixed (ReadWrite,\n                    0xE8000000,         // Address Base\n                    0x10000000,         // Address Length\n                    )\n            })\n        }\n        */\n        let mbrd_scope = [\n            0x10, 0x21, 0x2E, 0x5F, 0x53, 0x42, 0x5F, 0x4D, 0x42, 0x52, 0x44, 0x08, 0x5F, 0x43,\n            0x52, 0x53, 0x11, 0x11, 0x0A, 0x0E, 0x86, 0x09, 0x00, 0x01, 0x00, 0x00, 0x00, 0xE8,\n            0x00, 0x00, 0x00, 0x10, 0x79, 0x00,\n        ];\n        assert_eq!(\n            Scope::new(\n                \"_SB_.MBRD\".into(),\n                vec![&Name::new(\n                    \"_CRS\".into(),\n                    &ResourceTemplate::new(vec![&Memory32Fixed::new(\n                        true,\n                        0xE800_0000,\n                        0x1000_0000\n                    )])\n                )]\n            )\n            .to_aml_bytes(),\n            &mbrd_scope[..]\n        );\n"]], "pred": {"ppl": 1.9285105466842651, "ppl_lower": 2.4394373893737793, "ppl/lowercase_ppl": -1.3578533603696499, "ppl/zlib": 0.0016668730139716799, "Min_5.0% Prob": 6.171137944511745, "Min_10.0% Prob": 4.5707720051641045, "Min_20.0% Prob": 2.9710789711579033, "Min_30.0% Prob": 2.121534304882305, "Min_40.0% Prob": 1.624632435283907, "Min_50.0% Prob": 1.3086521811216423, "Min_60.0% Prob": 1.0935012942848161}}
{"hexsha": "887725c01c78a4d7a28c624bd2bc986b7a9779ce", "ext": "rs", "lang": "Rust", "content": "fn fails_on_duplicate_http_incoming_auth() {\n    let mut account = ACCOUNT_DETAILS_2.clone();\n    account.http_incoming_token = Some(\"incoming_auth_token\".to_string());\n    let result = block_on(test_store().and_then(|(store, context)| {\n        store.insert_account(account).then(move |result| {\n            let _ = context;\n            result\n        })\n    }));\n    assert!(result.is_err());\n}", "item_id": 0, "repo": "pensivej/interledger-rs", "file": "crates/interledger-store-redis/tests/accounts_test.rs", "last_update_at": "2019-08-06T07:59:44+00:00", "question_id": "887725c01c78a4d7a28c624bd2bc986b7a9779ce_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn fails_on_duplicate_http_incoming_auth() {\n    let mut account = ACCOUNT_DETAILS_2.clone();\n    account.http_incoming_token = Some(\"incoming_auth_token\".to_string());\n    let result = block_on(test_store().and_then(|(store, context)| {\n        store.insert_account(account).then(move |result| {\n            let _ = context;\n            result\n        })\n    }));\n    assert!(result.is_err());\n"]], "pred": {"ppl": 3.2820053100585938, "ppl_lower": 4.023092746734619, "ppl/lowercase_ppl": -1.1713118316913798, "ppl/zlib": 0.005057253662129142, "Min_5.0% Prob": 9.178464968999227, "Min_10.0% Prob": 7.169502139091492, "Min_20.0% Prob": 4.883539295196533, "Min_30.0% Prob": 3.618747751963766, "Min_40.0% Prob": 2.866330440044403, "Min_50.0% Prob": 2.333506712364772, "Min_60.0% Prob": 1.9651673898885125}}
{"hexsha": "2a51ba000b3fd5f005f0dd637b2db64af7406eea", "ext": "rs", "lang": "Rust", "content": "fn test_send_message() {\n        init!(\"true\");\n\n        let msg = CString::new(\"MESSAGE\").unwrap().into_raw();\n        let msg_type = CString::new(\"TYPE\").unwrap().into_raw();\n        let msg_title = CString::new(\"TITLE\").unwrap().into_raw();\n        let connection_handle = ::connection::tests::build_test_connection();\n        ::connection::set_state(connection_handle, VcxStateType::VcxStateAccepted).unwrap();\n        let cb = return_types_u32::Return_U32_STR::new().unwrap();\n        assert_eq!(vcx_connection_send_message(cb.command_handle, connection_handle, msg, msg_type, msg_title, Some(cb.get_callback())), error::SUCCESS.code_num);\n        cb.receive(Some(Duration::from_secs(10))).unwrap();\n    }", "item_id": 23, "repo": "cobear25/indy-sdk", "file": "vcx/libvcx/src/api/connection.rs", "last_update_at": "2019-05-22T08:47:56+00:00", "question_id": "2a51ba000b3fd5f005f0dd637b2db64af7406eea_23", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_send_message() {\n        init!(\"true\");\n        let msg = CString::new(\"MESSAGE\").unwrap().into_raw();\n        let msg_type = CString::new(\"TYPE\").unwrap().into_raw();\n        let msg_title = CString::new(\"TITLE\").unwrap().into_raw();\n        let connection_handle = ::connection::tests::build_test_connection();\n        ::connection::set_state(connection_handle, VcxStateType::VcxStateAccepted).unwrap();\n        let cb = return_types_u32::Return_U32_STR::new().unwrap();\n        assert_eq!(vcx_connection_send_message(cb.command_handle, connection_handle, msg, msg_type, msg_title, Some(cb.get_callback())), error::SUCCESS.code_num);\n        cb.receive(Some(Duration::from_secs(10))).unwrap();\n"]], "pred": {"ppl": 2.0582871437072754, "ppl_lower": 3.587797164916992, "ppl/lowercase_ppl": -1.769752255651653, "ppl/zlib": 0.002180888680634399, "Min_5.0% Prob": 6.816127083518288, "Min_10.0% Prob": 5.195668654008345, "Min_20.0% Prob": 3.39050368829207, "Min_30.0% Prob": 2.373343028906566, "Min_40.0% Prob": 1.8096795588982908, "Min_50.0% Prob": 1.4422493602282234, "Min_60.0% Prob": 1.206371506007124}}
{"hexsha": "9b4bb4dc17494c29ed047aad5e066b77167628b6", "ext": "rs", "lang": "Rust", "content": "pub fn end_of_word(buffer: &Buffer, mut point: Point) -> Point {\n    // TODO: remove this once the iterator returns char instances.\n    let mut iter = decode_utf16(buffer.iter_starting_at_point(point)).map(|c| c.unwrap());\n    let skip_alphanumeric = iter.next().map_or(false, |c| c.is_alphanumeric());\n    point = right(buffer, point);\n    for character in iter {\n        if skip_alphanumeric == character.is_alphanumeric() {\n            point = right(buffer, point);\n        } else {\n            break;\n        }\n    }\n    point\n}", "item_id": 4, "repo": "Mattlk13/xray", "file": "xray_core/src/movement.rs", "last_update_at": "2019-07-21T10:37:29+00:00", "question_id": "9b4bb4dc17494c29ed047aad5e066b77167628b6_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn end_of_word(buffer: &Buffer, mut point: Point) -> Point {\n    // TODO: remove this once the iterator returns char instances.\n    let mut iter = decode_utf16(buffer.iter_starting_at_point(point)).map(|c| c.unwrap());\n    let skip_alphanumeric = iter.next().map_or(false, |c| c.is_alphanumeric());\n    point = right(buffer, point);\n    for character in iter {\n        if skip_alphanumeric == character.is_alphanumeric() {\n            point = right(buffer, point);\n        } else {\n            break;\n        }\n    }\n    point\n"]], "pred": {"ppl": 3.301635980606079, "ppl_lower": 3.6029558181762695, "ppl/lowercase_ppl": -1.0731205195644618, "ppl/zlib": 0.004343338535734442, "Min_5.0% Prob": 8.817584335803986, "Min_10.0% Prob": 7.070983648300171, "Min_20.0% Prob": 4.996077850461006, "Min_30.0% Prob": 3.7208539669712386, "Min_40.0% Prob": 2.9033277502426733, "Min_50.0% Prob": 2.378412675710372, "Min_60.0% Prob": 2.0017001637708893}}
{"hexsha": "5f1380e6c1debec737ab1239768457e2ae4edaea", "ext": "rs", "lang": "Rust", "content": "async fn nexus_create_grpc(\n    compose: &Arc<ComposeTest>,\n    nr_children: usize,\n) -> GrpcNexus {\n    let children = get_children(compose.clone())\n        .await\n        .iter()\n        .take(nr_children)\n        .cloned();\n    let mut hdls = compose.grpc_handles().await.unwrap();\n\n    let nexus_hdl = &mut hdls.last_mut().unwrap();\n    let nexus = nexus_hdl\n        .mayastor\n        .create_nexus(rpc::mayastor::CreateNexusRequest {\n            uuid: uuid::Uuid::new_v4().to_string(),\n            size: 10 * 1024 * 1024,\n            children: children.collect::<Vec<_>>(),\n        })\n        .await\n        .unwrap();\n    GrpcNexus(compose.clone(), nexus.into_inner())\n}", "item_id": 3, "repo": "openebs/MayaStor", "file": "io-engine-bench/src/nexus.rs", "last_update_at": "2019-12-06T14:10:56+00:00", "question_id": "5f1380e6c1debec737ab1239768457e2ae4edaea_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn nexus_create_grpc(\n    compose: &Arc<ComposeTest>,\n    nr_children: usize,\n) -> GrpcNexus {\n    let children = get_children(compose.clone())\n        .await\n        .iter()\n        .take(nr_children)\n        .cloned();\n    let mut hdls = compose.grpc_handles().await.unwrap();\n    let nexus_hdl = &mut hdls.last_mut().unwrap();\n    let nexus = nexus_hdl\n        .mayastor\n        .create_nexus(rpc::mayastor::CreateNexusRequest {\n            uuid: uuid::Uuid::new_v4().to_string(),\n            size: 10 * 1024 * 1024,\n            children: children.collect::<Vec<_>>(),\n        })\n        .await\n        .unwrap();\n    GrpcNexus(compose.clone(), nexus.into_inner())\n"]], "pred": {"ppl": 2.631459951400757, "ppl_lower": 3.34525728225708, "ppl/lowercase_ppl": -1.248057026388983, "ppl/zlib": 0.0029770424823741767, "Min_5.0% Prob": 8.033512592315674, "Min_10.0% Prob": 6.326277285814285, "Min_20.0% Prob": 4.202523012550509, "Min_30.0% Prob": 3.0868435759802124, "Min_40.0% Prob": 2.399747590374465, "Min_50.0% Prob": 1.9366439256757018, "Min_60.0% Prob": 1.615775144227699}}
{"hexsha": "6284d1836ef46c50637504ab98bc58c982d91ef0", "ext": "rs", "lang": "Rust", "content": "pub fn read_ss() -> u16 {\n    let ret: u16;\n    unsafe {\n        asm!(\n            \"mov %ss, $0\"\n            : \"=r\"(ret)\n            :\n            :\n            );\n    }\n    ret\n}", "item_id": 12, "repo": "colonelpopcorn/rustyvisor", "file": "src/vmx.rs", "last_update_at": "2019-04-11T21:37:17+00:00", "question_id": "6284d1836ef46c50637504ab98bc58c982d91ef0_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn read_ss() -> u16 {\n    let ret: u16;\n    unsafe {\n        asm!(\n            \"mov %ss, $0\"\n            : \"=r\"(ret)\n            :\n            :\n            );\n    }\n    ret\n"]], "pred": {"ppl": 3.165018081665039, "ppl_lower": 3.165018081665039, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.011078449697943768, "Min_5.0% Prob": 9.407920519510904, "Min_10.0% Prob": 7.537760098775228, "Min_20.0% Prob": 5.055339694023132, "Min_30.0% Prob": 3.7388752793010913, "Min_40.0% Prob": 2.8353819136436167, "Min_50.0% Prob": 2.2686888239148892, "Min_60.0% Prob": 1.9330011543173056}}
{"hexsha": "40d2f61e590f789ef9bffeb853ea99e094d762c9", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn okclient(mut ip: *mut u8) -> i32 {\n    let mut _currentBlock;\n    let mut st: stat;\n    let mut i: i32;\n    filename[0usize] = b'i';\n    filename[1usize] = b'p';\n    filename[2usize] = b'/';\n    filename[3u32.wrapping_add(ip4::fmt(filename.as_mut_ptr().offset(3isize), ip as (*const u8))) as\n            (usize)] = 0u8;\n    'loop1: loop {\n        if stat(filename.as_mut_ptr() as (*const u8), &mut st as (*mut stat)) == 0i32 {\n            _currentBlock = 5;\n            break;\n        }\n        i = string::rchr(filename.as_mut_ptr() as (*const u8), b'.' as (i32)) as (i32);\n        if filename[i as (usize)] == 0 {\n            _currentBlock = 4;\n            break;\n        }\n        filename[i as (usize)] = 0u8;\n    }\n    if _currentBlock == 4 { 0i32 } else { 1i32 }\n}", "item_id": 0, "repo": "oxidizers/drdns", "file": "src/okclient.rs", "last_update_at": "2019-09-13T11:39:33+00:00", "question_id": "40d2f61e590f789ef9bffeb853ea99e094d762c9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn okclient(mut ip: *mut u8) -> i32 {\n    let mut _currentBlock;\n    let mut st: stat;\n    let mut i: i32;\n    filename[0usize] = b'i';\n    filename[1usize] = b'p';\n    filename[2usize] = b'/';\n    filename[3u32.wrapping_add(ip4::fmt(filename.as_mut_ptr().offset(3isize), ip as (*const u8))) as\n            (usize)] = 0u8;\n    'loop1: loop {\n        if stat(filename.as_mut_ptr() as (*const u8), &mut st as (*mut stat)) == 0i32 {\n            _currentBlock = 5;\n            break;\n        }\n        i = string::rchr(filename.as_mut_ptr() as (*const u8), b'.' as (i32)) as (i32);\n        if filename[i as (usize)] == 0 {\n            _currentBlock = 4;\n            break;\n        }\n        filename[i as (usize)] = 0u8;\n    }\n    if _currentBlock == 4 { 0i32 } else { 1i32 }\n"]], "pred": {"ppl": 2.416402816772461, "ppl_lower": 2.5639805793762207, "ppl/lowercase_ppl": -1.0671906538173237, "ppl/zlib": 0.002681702112375124, "Min_5.0% Prob": 8.396940358479817, "Min_10.0% Prob": 6.147097487603465, "Min_20.0% Prob": 3.9655923208882733, "Min_30.0% Prob": 2.8350666644091302, "Min_40.0% Prob": 2.1863594764471053, "Min_50.0% Prob": 1.7561340869232347, "Min_60.0% Prob": 1.470759223978174}}
{"hexsha": "6c8088375c4b0548fc7d84f0b41a77827e137224", "ext": "rs", "lang": "Rust", "content": "pub fn set_frame_pointer_elimination(cx: &CodegenCx, llfn: ValueRef) {\n    // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a\n    // parameter.\n    if cx.sess().must_not_eliminate_frame_pointers() {\n        llvm::AddFunctionAttrStringValue(\n            llfn, llvm::AttributePlace::Function,\n            cstr(\"no-frame-pointer-elim\\0\"), cstr(\"true\\0\"));\n    }\n}", "item_id": 1, "repo": "mrhota/rust", "file": "src/librustc_trans/attributes.rs", "last_update_at": "2019-01-07T03:31:05+00:00", "question_id": "6c8088375c4b0548fc7d84f0b41a77827e137224_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn set_frame_pointer_elimination(cx: &CodegenCx, llfn: ValueRef) {\n    // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a\n    // parameter.\n    if cx.sess().must_not_eliminate_frame_pointers() {\n        llvm::AddFunctionAttrStringValue(\n            llfn, llvm::AttributePlace::Function,\n            cstr(\"no-frame-pointer-elim\\0\"), cstr(\"true\\0\"));\n    }\n"]], "pred": {"ppl": 5.911043167114258, "ppl_lower": 8.837223052978516, "ppl/lowercase_ppl": -1.2263312221931812, "ppl/zlib": 0.007078973405020468, "Min_5.0% Prob": 10.04011599222819, "Min_10.0% Prob": 8.142978228055513, "Min_20.0% Prob": 6.301047893670889, "Min_30.0% Prob": 5.019953611569527, "Min_40.0% Prob": 4.178542368687117, "Min_50.0% Prob": 3.501254772222959, "Min_60.0% Prob": 2.968014463973351}}
{"hexsha": "93f71f55ff58446c73eaee318546064439cbdfde", "ext": "rs", "lang": "Rust", "content": "fn create_task() {\n        let domain = \"atcoder.jp\".to_string();\n        let path = \"/contests/abc125/tasks\".to_string();\n\n        let result = atcoder::get_tasks(&domain, &path);\n        let lang_ja = atcoder::Lang::Ja;\n\n        let mut task_result = vec![];\n        if let Some(tasks) = result {\n            for task in tasks {\n                task_result.push(Task::new(task.title, task.link, lang_ja));\n            }\n        } else {\n            assert!(false);\n        }\n\n        let answer = vec![\n            Task::new(\n                \"A: Biscuit Generator\".to_string(),\n                \"https://atcoder.jp/contests/abc125/tasks/abc125_a\".to_string(),\n                atcoder::Lang::Ja,\n            ),\n            Task::new(\n                \"B: Resale\".to_string(),\n                \"https://atcoder.jp/contests/abc125/tasks/abc125_b\".to_string(),\n                atcoder::Lang::Ja,\n            ),\n            Task::new(\n                \"C: GCD on Blackboard\".to_string(),\n                \"https://atcoder.jp/contests/abc125/tasks/abc125_c\".to_string(),\n                atcoder::Lang::Ja,\n            ),\n            Task::new(\n                \"D: Flipping Signs\".to_string(),\n                \"https://atcoder.jp/contests/abc125/tasks/abc125_d\".to_string(),\n                atcoder::Lang::Ja,\n            ),\n        ];\n        assert_eq!(answer.len(), task_result.len());\n        for i in 0..answer.len() {\n            assert_eq!(answer[i], task_result[i]);\n        }\n    }", "item_id": 0, "repo": "sux2mfgj/abc_utils", "file": "src/task.rs", "last_update_at": "2019-05-18T15:47:54+00:00", "question_id": "93f71f55ff58446c73eaee318546064439cbdfde_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn create_task() {\n        let domain = \"atcoder.jp\".to_string();\n        let path = \"/contests/abc125/tasks\".to_string();\n        let result = atcoder::get_tasks(&domain, &path);\n        let lang_ja = atcoder::Lang::Ja;\n        let mut task_result = vec![];\n        if let Some(tasks) = result {\n            for task in tasks {\n                task_result.push(Task::new(task.title, task.link, lang_ja));\n            }\n        } else {\n            assert!(false);\n        }\n        let answer = vec![\n            Task::new(\n                \"A: Biscuit Generator\".to_string(),\n                \"https://atcoder.jp/contests/abc125/tasks/abc125_a\".to_string(),\n                atcoder::Lang::Ja,\n            ),\n            Task::new(\n                \"B: Resale\".to_string(),\n                \"https://atcoder.jp/contests/abc125/tasks/abc125_b\".to_string(),\n                atcoder::Lang::Ja,\n            ),\n            Task::new(\n                \"C: GCD on Blackboard\".to_string(),\n                \"https://atcoder.jp/contests/abc125/tasks/abc125_c\".to_string(),\n                atcoder::Lang::Ja,\n            ),\n            Task::new(\n                \"D: Flipping Signs\".to_string(),\n                \"https://atcoder.jp/contests/abc125/tasks/abc125_d\".to_string(),\n                atcoder::Lang::Ja,\n            ),\n        ];\n        assert_eq!(answer.len(), task_result.len());\n        for i in 0..answer.len() {\n            assert_eq!(answer[i], task_result[i]);\n        }\n"]], "pred": {"ppl": 1.7553364038467407, "ppl_lower": 1.8620622158050537, "ppl/lowercase_ppl": -1.1049017441279108, "ppl/zlib": 0.001379069906011094, "Min_5.0% Prob": 6.6857945919036865, "Min_10.0% Prob": 4.6401905963818235, "Min_20.0% Prob": 2.7307085391754904, "Min_30.0% Prob": 1.8672606143583026, "Min_40.0% Prob": 1.4054625963957126, "Min_50.0% Prob": 1.1250956057522368, "Min_60.0% Prob": 0.9377295416169444}}
{"hexsha": "86b8655d7cb8d82dc2fe9d1d35390277ad99bcea", "ext": "rs", "lang": "Rust", "content": "pub fn build_index(lang: &str, library: &Library) -> Result<String> {\n    let language = match Language::from_code(lang) {\n        Some(l) => l,\n        None => {\n            bail!(\"Tried to build search index for language {} which is not supported\", lang);\n        }\n    };\n\n    let mut index = Index::with_language(language, &[\"title\", \"body\"]);\n\n    for section in library.sections_values() {\n        if section.lang == lang {\n            add_section_to_index(&mut index, section, library);\n        }\n    }\n\n    Ok(index.to_json())\n}", "item_id": 0, "repo": "pheki/zola", "file": "components/search/src/lib.rs", "last_update_at": "2019-12-23T02:07:39+00:00", "question_id": "86b8655d7cb8d82dc2fe9d1d35390277ad99bcea_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn build_index(lang: &str, library: &Library) -> Result<String> {\n    let language = match Language::from_code(lang) {\n        Some(l) => l,\n        None => {\n            bail!(\"Tried to build search index for language {} which is not supported\", lang);\n        }\n    };\n    let mut index = Index::with_language(language, &[\"title\", \"body\"]);\n    for section in library.sections_values() {\n        if section.lang == lang {\n            add_section_to_index(&mut index, section, library);\n        }\n    }\n    Ok(index.to_json())\n"]], "pred": {"ppl": 2.936504602432251, "ppl_lower": 3.6730427742004395, "ppl/lowercase_ppl": -1.207757428076458, "ppl/zlib": 0.003614832091604736, "Min_5.0% Prob": 7.699407849993024, "Min_10.0% Prob": 6.2279986381530765, "Min_20.0% Prob": 4.392615898962943, "Min_30.0% Prob": 3.290036954778306, "Min_40.0% Prob": 2.5931350385385845, "Min_50.0% Prob": 2.1331517843506003, "Min_60.0% Prob": 1.7958300631297262}}
{"hexsha": "290052921f5b8d0d6ea234711eae018ccb14fae3", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let log_config = Config {\n        filter: Some(\"info\".to_owned()),\n        ..Default::default()\n    };\n    let _logger_guard = ckb_logger::init(log_config).expect(\"init Logger\");\n\n    let binary = env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"../target/release/ckb\".to_string());\n    let start_port = env::args()\n        .nth(2)\n        .unwrap_or_else(|| \"9000\".to_string())\n        .parse()\n        .expect(\"invalid port number\");\n    let mut specs: HashMap<&str, Box<dyn Spec>> = HashMap::new();\n    specs.insert(\"block_relay_basic\", Box::new(BlockRelayBasic));\n    specs.insert(\"block_sync_from_one\", Box::new(BlockSyncFromOne));\n    specs.insert(\"block_sync_forks\", Box::new(BlockSyncForks));\n    specs.insert(\n        \"block_sync_duplicated_and_reconnect\",\n        Box::new(BlockSyncDuplicatedAndReconnect),\n    );\n    specs.insert(\"block_sync_orphan_blocks\", Box::new(BlockSyncOrphanBlocks));\n    specs.insert(\"sync_timeout\", Box::new(SyncTimeout));\n    specs.insert(\"chain_fork_1\", Box::new(ChainFork1));\n    specs.insert(\"chain_fork_2\", Box::new(ChainFork2));\n    specs.insert(\"chain_fork_3\", Box::new(ChainFork3));\n    specs.insert(\"chain_fork_4\", Box::new(ChainFork4));\n    specs.insert(\"chain_fork_5\", Box::new(ChainFork5));\n    specs.insert(\"chain_fork_6\", Box::new(ChainFork6));\n    specs.insert(\"chain_fork_7\", Box::new(ChainFork7));\n    specs.insert(\"mining_basic\", Box::new(MiningBasic));\n    specs.insert(\"mining_bootstrap_cellbase\", Box::new(BootstrapCellbase));\n    specs.insert(\"mining_template_size_limit\", Box::new(TemplateSizeLimit));\n    specs.insert(\"pool_reconcile\", Box::new(PoolReconcile));\n    specs.insert(\"pool_resurrect\", Box::new(PoolResurrect));\n    specs.insert(\"transaction_relay_basic\", Box::new(TransactionRelayBasic));\n    // FIXME: There is a probability of failure on low resouce CI server\n    // specs.insert(\n    //     \"transaction_relay_multiple\",\n    //     Box::new(TransactionRelayMultiple),\n    // );\n    specs.insert(\"discovery\", Box::new(Discovery));\n    // TODO enable this after p2p lib resolve close timeout issue\n    // specs.insert(\"disconnect\", Box::new(Disconnect));\n    specs.insert(\"malformed_message\", Box::new(MalformedMessage));\n    specs.insert(\"depent_tx_in_same_block\", Box::new(DepentTxInSameBlock));\n    // TODO enable these after proposed/pending pool tip verfiry logic changing\n    // specs.insert(\"cellbase_maturity\", Box::new(CellbaseMaturity));\n    specs.insert(\"valid_since\", Box::new(ValidSince));\n    specs.insert(\n        \"different_txs_with_same_input\",\n        Box::new(DifferentTxsWithSameInput),\n    );\n    specs.insert(\"compact_block_empty\", Box::new(CompactBlockEmpty));\n    specs.insert(\n        \"compact_block_empty_parent_unknown\",\n        Box::new(CompactBlockEmptyParentUnknown),\n    );\n    specs.insert(\"compact_block_prefilled\", Box::new(CompactBlockPrefilled));\n    specs.insert(\n        \"compact_block_missing_txs\",\n        Box::new(CompactBlockMissingTxs),\n    );\n    specs.insert(\n        \"compact_block_lose_get_block_transactions\",\n        Box::new(CompactBlockLoseGetBlockTransactions),\n    );\n    specs.insert(\n        \"compact_block_relay_parent_of_orphan_block\",\n        Box::new(CompactBlockRelayParentOfOrphanBlock),\n    );\n    specs.insert(\"invalid_locator_size\", Box::new(InvalidLocatorSize));\n    specs.insert(\"tx_pool_size_limit\", Box::new(SizeLimit));\n    specs.insert(\"tx_pool_cycles_limit\", Box::new(CyclesLimit));\n    specs.insert(\"alert_propagation\", Box::new(AlertPropagation::default()));\n    specs.insert(\"indexer_basic\", Box::new(IndexerBasic));\n    specs.insert(\"genesis_issued_cells\", Box::new(GenesisIssuedCells));\n\n    if let Some(spec_name) = env::args().nth(3) {\n        if let Some(spec) = specs.get(spec_name.as_str()) {\n            let net = spec.setup_net(&binary, start_port);\n            spec.run(net);\n        }\n    } else {\n        specs.iter().for_each(|(spec_name, spec)| {\n            info!(\"Running {}\", spec_name);\n            let net = spec.setup_net(&binary, start_port);\n            spec.run(net);\n        })\n    }\n}", "item_id": 0, "repo": "Tresdin-commander/blockchain", "file": "test/src/main.rs", "last_update_at": "2019-07-05T05:50:43+00:00", "question_id": "290052921f5b8d0d6ea234711eae018ccb14fae3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let log_config = Config {\n        filter: Some(\"info\".to_owned()),\n        ..Default::default()\n    };\n    let _logger_guard = ckb_logger::init(log_config).expect(\"init Logger\");\n    let binary = env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"../target/release/ckb\".to_string());\n    let start_port = env::args()\n        .nth(2)\n        .unwrap_or_else(|| \"9000\".to_string())\n        .parse()\n        .expect(\"invalid port number\");\n    let mut specs: HashMap<&str, Box<dyn Spec>> = HashMap::new();\n    specs.insert(\"block_relay_basic\", Box::new(BlockRelayBasic));\n    specs.insert(\"block_sync_from_one\", Box::new(BlockSyncFromOne));\n    specs.insert(\"block_sync_forks\", Box::new(BlockSyncForks));\n    specs.insert(\n        \"block_sync_duplicated_and_reconnect\",\n        Box::new(BlockSyncDuplicatedAndReconnect),\n    );\n    specs.insert(\"block_sync_orphan_blocks\", Box::new(BlockSyncOrphanBlocks));\n    specs.insert(\"sync_timeout\", Box::new(SyncTimeout));\n    specs.insert(\"chain_fork_1\", Box::new(ChainFork1));\n    specs.insert(\"chain_fork_2\", Box::new(ChainFork2));\n    specs.insert(\"chain_fork_3\", Box::new(ChainFork3));\n    specs.insert(\"chain_fork_4\", Box::new(ChainFork4));\n    specs.insert(\"chain_fork_5\", Box::new(ChainFork5));\n    specs.insert(\"chain_fork_6\", Box::new(ChainFork6));\n    specs.insert(\"chain_fork_7\", Box::new(ChainFork7));\n    specs.insert(\"mining_basic\", Box::new(MiningBasic));\n    specs.insert(\"mining_bootstrap_cellbase\", Box::new(BootstrapCellbase));\n    specs.insert(\"mining_template_size_limit\", Box::new(TemplateSizeLimit));\n    specs.insert(\"pool_reconcile\", Box::new(PoolReconcile));\n    specs.insert(\"pool_resurrect\", Box::new(PoolResurrect));\n    specs.insert(\"transaction_relay_basic\", Box::new(TransactionRelayBasic));\n    // FIXME: There is a probability of failure on low resouce CI server\n    // specs.insert(\n    //     \"transaction_relay_multiple\",\n    //     Box::new(TransactionRelayMultiple),\n    // );\n    specs.insert(\"discovery\", Box::new(Discovery));\n    // TODO enable this after p2p lib resolve close timeout issue\n    // specs.insert(\"disconnect\", Box::new(Disconnect));\n    specs.insert(\"malformed_message\", Box::new(MalformedMessage));\n    specs.insert(\"depent_tx_in_same_block\", Box::new(DepentTxInSameBlock));\n    // TODO enable these after proposed/pending pool tip verfiry logic changing\n    // specs.insert(\"cellbase_maturity\", Box::new(CellbaseMaturity));\n    specs.insert(\"valid_since\", Box::new(ValidSince));\n    specs.insert(\n        \"different_txs_with_same_input\",\n        Box::new(DifferentTxsWithSameInput),\n    );\n    specs.insert(\"compact_block_empty\", Box::new(CompactBlockEmpty));\n    specs.insert(\n        \"compact_block_empty_parent_unknown\",\n        Box::new(CompactBlockEmptyParentUnknown),\n    );\n    specs.insert(\"compact_block_prefilled\", Box::new(CompactBlockPrefilled));\n    specs.insert(\n        \"compact_block_missing_txs\",\n        Box::new(CompactBlockMissingTxs),\n    );\n    specs.insert(\n        \"compact_block_lose_get_block_transactions\",\n        Box::new(CompactBlockLoseGetBlockTransactions),\n    );\n    specs.insert(\n        \"compact_block_relay_parent_of_orphan_block\",\n        Box::new(CompactBlockRelayParentOfOrphanBlock),\n    );\n    specs.insert(\"invalid_locator_size\", Box::new(InvalidLocatorSize));\n    specs.insert(\"tx_pool_size_limit\", Box::new(SizeLimit));\n    specs.insert(\"tx_pool_cycles_limit\", Box::new(CyclesLimit));\n    specs.insert(\"alert_propagation\", Box::new(AlertPropagation::default()));\n    specs.insert(\"indexer_basic\", Box::new(IndexerBasic));\n    specs.insert(\"genesis_issued_cells\", Box::new(GenesisIssuedCells));\n    if let Some(spec_name) = env::args().nth(3) {\n        if let Some(spec) = specs.get(spec_name.as_str()) {\n            let net = spec.setup_net(&binary, start_port);\n            spec.run(net);\n        }\n    } else {\n        specs.iter().for_each(|(spec_name, spec)| {\n            info!(\"Running {}\", spec_name);\n            let net = spec.setup_net(&binary, start_port);\n            spec.run(net);\n        })\n    }\n"]], "pred": {"ppl": 1.8345839977264404, "ppl_lower": 1.9765397310256958, "ppl/lowercase_ppl": -1.1228209845522947, "ppl/zlib": 0.0004893691544911061, "Min_5.0% Prob": 6.653195156770594, "Min_10.0% Prob": 4.811851665085437, "Min_20.0% Prob": 2.892499527948744, "Min_30.0% Prob": 2.0038903035905236, "Min_40.0% Prob": 1.513503349679898, "Min_50.0% Prob": 1.21408769352008, "Min_60.0% Prob": 1.012531383057257}}
{"hexsha": "c385df2d912b71e555df414919d72c181b8dfd50", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn frame_handle_copy_with_damage(mut wl_client:\n                                                       *mut wl_client,\n                                                   mut frame_resource:\n                                                       *mut wl_resource,\n                                                   mut buffer_resource:\n                                                       *mut wl_resource) {\n    let mut frame: *mut wlr_screencopy_frame_v1 =\n        frame_from_resource(frame_resource);\n    if frame.is_null() { return }\n    (*frame).with_damage = 1i32 != 0;\n    frame_handle_copy(wl_client, frame_resource, buffer_resource);\n}", "item_id": 12, "repo": "RoastVeg/wlrusts", "file": "src/types/wlr_screencopy_v1.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "c385df2d912b71e555df414919d72c181b8dfd50_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe extern \"C\" fn frame_handle_copy_with_damage(mut wl_client:\n                                                       *mut wl_client,\n                                                   mut frame_resource:\n                                                       *mut wl_resource,\n                                                   mut buffer_resource:\n                                                       *mut wl_resource) {\n    let mut frame: *mut wlr_screencopy_frame_v1 =\n        frame_from_resource(frame_resource);\n    if frame.is_null() { return }\n    (*frame).with_damage = 1i32 != 0;\n    frame_handle_copy(wl_client, frame_resource, buffer_resource);\n"]], "pred": {"ppl": 1.9564571380615234, "ppl_lower": 2.016005039215088, "ppl/lowercase_ppl": -1.0446744447152718, "ppl/zlib": 0.0032421992993813668, "Min_5.0% Prob": 7.563828468322754, "Min_10.0% Prob": 5.600215941667557, "Min_20.0% Prob": 3.254330485156088, "Min_30.0% Prob": 2.2124911464750765, "Min_40.0% Prob": 1.6904595327761136, "Min_50.0% Prob": 1.3481426825522478, "Min_60.0% Prob": 1.1202617640281096}}
{"hexsha": "2867a1f3feefae55b4fc230de6519892c66e499b", "ext": "rs", "lang": "Rust", "content": "unsafe fn last_row(buf: &mut [u8], data: &[u8], x: usize, w: usize, h: usize) {\n    debug_assert!(buf.len() == 3*w*h);\n    debug_assert!(data.len() == w*h);\n    debug_assert!(x < w);\n\n    let y = h - 2;\n\n    let g1 = get(data, x  , y-1, w);\n    let g3 = get(data, x-1, y, w);\n    let g5 = get(data, x+1, y, w);\n    let g8 = get(data, x  , y+1, w);\n    let g10 = get(data, x+2, y+1, w);\n\n    set(buf, x, y, 1, w, (g1+g3+g5+g8)/4);\n    set(buf, x+1, y, 1, w, g5);\n    set(buf, x, y+1, 1, w, g8);\n    set(buf, x+1, y+1, 1, w, (g5+g8+g10)/3);\n\n    let r0 = get(data, x-1, y-1, w);\n    let r2 = get(data, x+1, y-1, w);\n    let r7 = get(data, x-1, y+1, w);\n    let r9 = get(data, x+1, y+1, w);\n\n    set(buf, x, y, 2, w, (r0+r2+r7+r9)/4);\n    set(buf, x+1, y, 2, w, (r2+r9)/2);\n    set(buf, x, y+1, 2, w, (r7+r9)/2);\n    set(buf, x+1, y+1, 2, w, r9);\n\n    let b4 = get(data, x  , y, w);\n    let b6 = get(data, x+2, y, w);\n\n    set(buf, x, y, 0, w, b4);\n    set(buf, x+1, y, 0, w, (b4+b6)/2);\n    set(buf, x, y+1, 0, w, b4);\n    set(buf, x+1, y+1, 0, w, (b4+b6)/2);\n}", "item_id": 5, "repo": "SkoltechRobotics/cam-vis", "file": "src/rggb.rs", "last_update_at": "2019-09-17T17:02:57+00:00", "question_id": "2867a1f3feefae55b4fc230de6519892c66e499b_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn last_row(buf: &mut [u8], data: &[u8], x: usize, w: usize, h: usize) {\n    debug_assert!(buf.len() == 3*w*h);\n    debug_assert!(data.len() == w*h);\n    debug_assert!(x < w);\n    let y = h - 2;\n    let g1 = get(data, x  , y-1, w);\n    let g3 = get(data, x-1, y, w);\n    let g5 = get(data, x+1, y, w);\n    let g8 = get(data, x  , y+1, w);\n    let g10 = get(data, x+2, y+1, w);\n    set(buf, x, y, 1, w, (g1+g3+g5+g8)/4);\n    set(buf, x+1, y, 1, w, g5);\n    set(buf, x, y+1, 1, w, g8);\n    set(buf, x+1, y+1, 1, w, (g5+g8+g10)/3);\n    let r0 = get(data, x-1, y-1, w);\n    let r2 = get(data, x+1, y-1, w);\n    let r7 = get(data, x-1, y+1, w);\n    let r9 = get(data, x+1, y+1, w);\n    set(buf, x, y, 2, w, (r0+r2+r7+r9)/4);\n    set(buf, x+1, y, 2, w, (r2+r9)/2);\n    set(buf, x, y+1, 2, w, (r7+r9)/2);\n    set(buf, x+1, y+1, 2, w, r9);\n    let b4 = get(data, x  , y, w);\n    let b6 = get(data, x+2, y, w);\n    set(buf, x, y, 0, w, b4);\n    set(buf, x+1, y, 0, w, (b4+b6)/2);\n    set(buf, x, y+1, 0, w, b4);\n    set(buf, x+1, y+1, 0, w, (b4+b6)/2);\n"]], "pred": {"ppl": 1.4914746284484863, "ppl_lower": 1.4914746284484863, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0012415071865403346, "Min_5.0% Prob": 4.439553038279215, "Min_10.0% Prob": 3.0409634908040366, "Min_20.0% Prob": 1.8606139835247324, "Min_30.0% Prob": 1.3070157336910346, "Min_40.0% Prob": 0.9975215111251089, "Min_50.0% Prob": 0.799749801708416, "Min_60.0% Prob": 0.6663615502763135}}
{"hexsha": "6a486030df4a2fcec1c8152076ec128bf46681ee", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), Error> {\n    // Lets get some logs out\n    TermLogger::init(LevelFilter::Info, Config::default())?;\n\n    let starstruck = StarstruckBuilder::new().init()?;\n    starstruck.run()?;\n\n    Ok(())\n}", "item_id": 0, "repo": "Joatin/starstruck", "file": "examples/01_window.rs", "last_update_at": "2019-03-28T15:24:56+00:00", "question_id": "6a486030df4a2fcec1c8152076ec128bf46681ee_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), Error> {\n    // Lets get some logs out\n    TermLogger::init(LevelFilter::Info, Config::default())?;\n    let starstruck = StarstruckBuilder::new().init()?;\n    starstruck.run()?;\n    Ok(())\n"]], "pred": {"ppl": 3.6347999572753906, "ppl_lower": 7.642406940460205, "ppl/lowercase_ppl": -1.5758445416864462, "ppl/zlib": 0.007869232177345932, "Min_5.0% Prob": 9.553616205851236, "Min_10.0% Prob": 7.593598774501255, "Min_20.0% Prob": 5.330170937946865, "Min_30.0% Prob": 3.988832240754908, "Min_40.0% Prob": 3.193374851654316, "Min_50.0% Prob": 2.5670547918290705, "Min_60.0% Prob": 2.167737835594876}}
{"hexsha": "c44da432c27616a0c513aa4feb48d085fcb4d125", "ext": "rs", "lang": "Rust", "content": "fn read_known_repos_table() -> Result<Vec<(String, String)>, KRTError> {\n    let mut file = File::open(known_repos_table_filepath())?;\n    let mut buffer = String::new();\n    file.read_to_string(&mut buffer)?;\n    let mut v: Vec<(String, String)> = serde_json::from_str(&buffer)?;\n    // Prune any repos that no longer exist.\n    let mut pruned = vec![];\n    for item in v.drain(..) {\n        if is_repo_workdir(&item.1) {\n            pruned.push(item);\n        }\n    }\n    Ok(pruned)\n}", "item_id": 2, "repo": "pwil3058/gwsm_git", "file": "rgwsm_git/src/repos.rs", "last_update_at": "2019-07-09T06:01:40+00:00", "question_id": "c44da432c27616a0c513aa4feb48d085fcb4d125_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_known_repos_table() -> Result<Vec<(String, String)>, KRTError> {\n    let mut file = File::open(known_repos_table_filepath())?;\n    let mut buffer = String::new();\n    file.read_to_string(&mut buffer)?;\n    let mut v: Vec<(String, String)> = serde_json::from_str(&buffer)?;\n    // Prune any repos that no longer exist.\n    let mut pruned = vec![];\n    for item in v.drain(..) {\n        if is_repo_workdir(&item.1) {\n            pruned.push(item);\n        }\n    }\n    Ok(pruned)\n"]], "pred": {"ppl": 2.379678964614868, "ppl_lower": 2.9644672870635986, "ppl/lowercase_ppl": -1.2534492280181304, "ppl/zlib": 0.0031411796730716895, "Min_5.0% Prob": 8.31827861070633, "Min_10.0% Prob": 5.965200115652645, "Min_20.0% Prob": 3.801193642616272, "Min_30.0% Prob": 2.799669333948539, "Min_40.0% Prob": 2.137091704564435, "Min_50.0% Prob": 1.736740208648402, "Min_60.0% Prob": 1.4437203119996758}}
{"hexsha": "862e1bcb28fb7e5e9044737f10b3949d9c2b6d3e", "ext": "rs", "lang": "Rust", "content": "fn lockfile_locks_transitively() {\n    let p = project(\"foo\")\n        .file(\"Cargo.toml\", r#\"\n            [project]\n            name = \"foo\"\n            version = \"0.0.1\"\n            authors = []\n\n            [dependencies]\n            bar = \"*\"\n        \"#)\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"baz\", \"0.0.1\").publish();\n    Package::new(\"bar\", \"0.0.1\").dep(\"baz\", \"*\").publish();\n\n    assert_that(p.cargo(\"build\"),\n                execs().with_status(0).with_stderr(&format!(\"\\\n[UPDATING] registry `[..]`\n[DOWNLOADING] [..] v0.0.1 (registry `file://[..]`)\n[DOWNLOADING] [..] v0.0.1 (registry `file://[..]`)\n[COMPILING] baz v0.0.1\n[COMPILING] bar v0.0.1\n[COMPILING] foo v0.0.1 ({dir})\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..] secs\n\",\n   dir = p.url())));\n\n    p.root().move_into_the_past();\n    Package::new(\"baz\", \"0.0.2\").publish();\n    Package::new(\"bar\", \"0.0.2\").dep(\"baz\", \"*\").publish();\n\n    assert_that(p.cargo(\"build\"),\n                execs().with_status(0).with_stdout(\"\"));\n}", "item_id": 8, "repo": "cnmade/cargo", "file": "tests/registry.rs", "last_update_at": "2019-07-19T20:12:12+00:00", "question_id": "862e1bcb28fb7e5e9044737f10b3949d9c2b6d3e_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn lockfile_locks_transitively() {\n    let p = project(\"foo\")\n        .file(\"Cargo.toml\", r#\"\n            [project]\n            name = \"foo\"\n            version = \"0.0.1\"\n            authors = []\n            [dependencies]\n            bar = \"*\"\n        \"#)\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n    Package::new(\"baz\", \"0.0.1\").publish();\n    Package::new(\"bar\", \"0.0.1\").dep(\"baz\", \"*\").publish();\n    assert_that(p.cargo(\"build\"),\n                execs().with_status(0).with_stderr(&format!(\"\\\n[UPDATING] registry `[..]`\n[DOWNLOADING] [..] v0.0.1 (registry `file://[..]`)\n[DOWNLOADING] [..] v0.0.1 (registry `file://[..]`)\n[COMPILING] baz v0.0.1\n[COMPILING] bar v0.0.1\n[COMPILING] foo v0.0.1 ({dir})\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..] secs\n\",\n   dir = p.url())));\n    p.root().move_into_the_past();\n    Package::new(\"baz\", \"0.0.2\").publish();\n    Package::new(\"bar\", \"0.0.2\").dep(\"baz\", \"*\").publish();\n    assert_that(p.cargo(\"build\"),\n                execs().with_status(0).with_stdout(\"\"));\n"]], "pred": {"ppl": 1.352194905281067, "ppl_lower": 1.5685226917266846, "ppl/lowercase_ppl": -1.4918487279176176, "ppl/zlib": 0.0006530933505226492, "Min_5.0% Prob": 4.2660633563995365, "Min_10.0% Prob": 2.606984966993332, "Min_20.0% Prob": 1.4681064595042923, "Min_30.0% Prob": 1.002794955567014, "Min_40.0% Prob": 0.7554219729364192, "Min_50.0% Prob": 0.604547429246618, "Min_60.0% Prob": 0.5036067901091289}}
{"hexsha": "e6acd81b8f398cb45de21fb4e0325b8f492db280", "ext": "rs", "lang": "Rust", "content": "fn get_one() {\n    consul_put(\"tower-consul/test-key\", \"test-value\");\n\n    let mut rt = Runtime::new().unwrap();\n\n    let response = rt.block_on(future::lazy(|| {\n        let mut client = client(hyper);\n        client.get(\"tower-consul/test-key\")\n    }));\n\n    let mut values = response.unwrap();\n    let value = values.pop().unwrap();\n    assert_eq!(value.key, \"tower-consul/test-key\");\n\n    consul_del(\"tower-consul/test-key\");\n}", "item_id": 1, "repo": "LucioFranco/tower-consul", "file": "tests/kv.rs", "last_update_at": "2019-01-18T17:50:03+00:00", "question_id": "e6acd81b8f398cb45de21fb4e0325b8f492db280_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_one() {\n    consul_put(\"tower-consul/test-key\", \"test-value\");\n    let mut rt = Runtime::new().unwrap();\n    let response = rt.block_on(future::lazy(|| {\n        let mut client = client(hyper);\n        client.get(\"tower-consul/test-key\")\n    }));\n    let mut values = response.unwrap();\n    let value = values.pop().unwrap();\n    assert_eq!(value.key, \"tower-consul/test-key\");\n    consul_del(\"tower-consul/test-key\");\n"]], "pred": {"ppl": 2.815950632095337, "ppl_lower": 2.8856611251831055, "ppl/lowercase_ppl": -1.0236203308107505, "ppl/zlib": 0.004837850032364382, "Min_5.0% Prob": 7.984948294503348, "Min_10.0% Prob": 6.139681752522787, "Min_20.0% Prob": 4.220713423144433, "Min_30.0% Prob": 3.214042304650597, "Min_40.0% Prob": 2.526025979749618, "Min_50.0% Prob": 2.0477007979001756, "Min_60.0% Prob": 1.7308994556066168}}
{"hexsha": "3d55062c5244f88dcd462a368f5ca932bdf94007", "ext": "rs", "lang": "Rust", "content": "fn spec_test_595() {\n    let original = r##\"<made-up-scheme://foo,bar>\n\"##;\n    let expected = r##\"<p><a href=\"made-up-scheme://foo,bar\">made-up-scheme://foo,bar</a></p>\n\"##;\n\n    test_markdown_html(original, expected);\n}", "item_id": 594, "repo": "NaokiM03/pulldown-cmark", "file": "tests/suite/spec.rs", "last_update_at": "2019-07-11T13:20:46+00:00", "question_id": "3d55062c5244f88dcd462a368f5ca932bdf94007_594", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn spec_test_595() {\n    let original = r##\"<made-up-scheme://foo,bar>\n\"##;\n    let expected = r##\"<p><a href=\"made-up-scheme://foo,bar\">made-up-scheme://foo,bar</a></p>\n\"##;\n    test_markdown_html(original, expected);\n"]], "pred": {"ppl": 3.7048964500427246, "ppl_lower": 3.7048964500427246, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.00922292471585254, "Min_5.0% Prob": 10.737722158432007, "Min_10.0% Prob": 8.084515147738987, "Min_20.0% Prob": 5.746533777978685, "Min_30.0% Prob": 4.159643916147096, "Min_40.0% Prob": 3.2630492944169687, "Min_50.0% Prob": 2.599069831377648, "Min_60.0% Prob": 2.1936207582641924}}
{"hexsha": "af2a630995c0e2d564b4d37c8a10b3b0b3deee7d", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    pretty_env_logger::init();\n\n    let addr = \"127.0.0.1:1337\".parse().unwrap();\n\n    hyper::rt::run(future::lazy(move || {\n        // Share a `Client` with all `Service`s\n        let client = Client::new();\n\n        let new_service = move || {\n            // Move a clone of `client` into the `service_fn`.\n            let client = client.clone();\n            service_fn(move |req| {\n                response_examples(req, &client)\n            })\n        };\n\n        let server = Server::bind(&addr)\n            .serve(new_service)\n            .map_err(|e| eprintln!(\"server error: {}\", e));\n\n        println!(\"Listening on http://{}\", addr);\n\n        server\n    }));\n}", "item_id": 1, "repo": "jxs/hyper", "file": "examples/web_api.rs", "last_update_at": "2019-11-19T09:28:31+00:00", "question_id": "af2a630995c0e2d564b4d37c8a10b3b0b3deee7d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    pretty_env_logger::init();\n    let addr = \"127.0.0.1:1337\".parse().unwrap();\n    hyper::rt::run(future::lazy(move || {\n        // Share a `Client` with all `Service`s\n        let client = Client::new();\n        let new_service = move || {\n            // Move a clone of `client` into the `service_fn`.\n            let client = client.clone();\n            service_fn(move |req| {\n                response_examples(req, &client)\n            })\n        };\n        let server = Server::bind(&addr)\n            .serve(new_service)\n            .map_err(|e| eprintln!(\"server error: {}\", e));\n        println!(\"Listening on http://{}\", addr);\n        server\n    }));\n"]], "pred": {"ppl": 1.725775957107544, "ppl_lower": 1.9515089988708496, "ppl/lowercase_ppl": -1.2252728060757914, "ppl/zlib": 0.0015955461390272446, "Min_5.0% Prob": 6.423476529121399, "Min_10.0% Prob": 4.150825670787266, "Min_20.0% Prob": 2.504313133302189, "Min_30.0% Prob": 1.7638340514330637, "Min_40.0% Prob": 1.3498205290220322, "Min_50.0% Prob": 1.0872079029501904, "Min_60.0% Prob": 0.9083829827806247}}
{"hexsha": "c3a2f978e1a8a4945f39ed8c091edbe5857ef762", "ext": "rs", "lang": "Rust", "content": "fn mubs_scc_2() {\n    //      +----+\n    //      v    |\n    // a -> c -> d\n    //      ^    ^\n    //      |    |\n    //      +--- b\n\n    // \"digraph { a -> c -> d; d -> c; b -> d; b -> c; }\",\n    let mut relation = TransitiveRelation::new();\n    relation.add(\"a\", \"c\");\n    relation.add(\"c\", \"d\");\n    relation.add(\"d\", \"c\");\n    relation.add(\"b\", \"d\");\n    relation.add(\"b\", \"c\");\n\n    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n}", "item_id": 12, "repo": "canaltinova/rust", "file": "src/librustc_data_structures/transitive_relation.rs", "last_update_at": "2019-09-24T02:31:48+00:00", "question_id": "c3a2f978e1a8a4945f39ed8c091edbe5857ef762_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn mubs_scc_2() {\n    //      +----+\n    //      v    |\n    // a -> c -> d\n    //      ^    ^\n    //      |    |\n    //      +--- b\n    // \"digraph { a -> c -> d; d -> c; b -> d; b -> c; }\",\n    let mut relation = TransitiveRelation::new();\n    relation.add(\"a\", \"c\");\n    relation.add(\"c\", \"d\");\n    relation.add(\"d\", \"c\");\n    relation.add(\"b\", \"d\");\n    relation.add(\"b\", \"c\");\n    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n"]], "pred": {"ppl": 3.1581239700317383, "ppl_lower": 3.4283487796783447, "ppl/lowercase_ppl": -1.0713931542942938, "ppl/zlib": 0.005398958548972522, "Min_5.0% Prob": 8.952763345506456, "Min_10.0% Prob": 7.014628092447917, "Min_20.0% Prob": 4.69364846083853, "Min_30.0% Prob": 3.5243397377155445, "Min_40.0% Prob": 2.7743682910998664, "Min_50.0% Prob": 2.271021731528971, "Min_60.0% Prob": 1.9101076540019777}}
{"hexsha": "646397b3942e04431f6ddb56afcd819a544cc158", "ext": "rs", "lang": "Rust", "content": "pub fn iter(x0: f64, y0: f64, maxi: Uint) -> Uint {\n    let (mut x, mut y) = (x0, y0);\n\n    for i in 1..maxi+1 {\n        let (xx, yy) = (x*x, y*y);\n        if xx+yy >= 4.0 {\n            return i;\n        }\n        y = 2.0*x*y+y0;\n        x = xx-yy+x0;\n    }\n\n    maxi\n}", "item_id": 0, "repo": "royaltm/rust-fractx", "file": "src/iter.rs", "last_update_at": "2019-03-19T11:07:59+00:00", "question_id": "646397b3942e04431f6ddb56afcd819a544cc158_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn iter(x0: f64, y0: f64, maxi: Uint) -> Uint {\n    let (mut x, mut y) = (x0, y0);\n    for i in 1..maxi+1 {\n        let (xx, yy) = (x*x, y*y);\n        if xx+yy >= 4.0 {\n            return i;\n        }\n        y = 2.0*x*y+y0;\n        x = xx-yy+x0;\n    }\n    maxi\n"]], "pred": {"ppl": 2.199106454849243, "ppl_lower": 2.1213724613189697, "ppl/lowercase_ppl": -0.9543330966963655, "ppl/zlib": 0.00480518976203362, "Min_5.0% Prob": 7.901384194691976, "Min_10.0% Prob": 5.60791696034945, "Min_20.0% Prob": 3.5004175967640347, "Min_30.0% Prob": 2.5380948022007943, "Min_40.0% Prob": 1.9495604192769085, "Min_50.0% Prob": 1.5659152107203709, "Min_60.0% Prob": 1.320016433507848}}
{"hexsha": "eef249cf3016daced42d7e087b6e3db5dc2eb890", "ext": "rs", "lang": "Rust", "content": "fn test_lookup_index_not_exists_array() {\n        let _ = env_logger::builder().is_test(true).try_init();\n\n        let sample = array![array![\"test\"]];\n\n        let found = lookup::<_, _, DefaultTokenizer>(&sample, \"[1]\");\n\n        assert!(found.is_err());\n\n        assert_eq!(found, Err(Error::IndexNotExist(1)),);\n    }", "item_id": 3, "repo": "zerosign/querable", "file": "src/lib.rs", "last_update_at": "2019-10-26T11:35:38+00:00", "question_id": "eef249cf3016daced42d7e087b6e3db5dc2eb890_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_lookup_index_not_exists_array() {\n        let _ = env_logger::builder().is_test(true).try_init();\n        let sample = array![array![\"test\"]];\n        let found = lookup::<_, _, DefaultTokenizer>(&sample, \"[1]\");\n        assert!(found.is_err());\n        assert_eq!(found, Err(Error::IndexNotExist(1)),);\n"]], "pred": {"ppl": 4.362917900085449, "ppl_lower": 6.141091346740723, "ppl/lowercase_ppl": -1.2320629021171345, "ppl/zlib": 0.0069487786634739755, "Min_5.0% Prob": 7.987060165405273, "Min_10.0% Prob": 6.905386209487915, "Min_20.0% Prob": 5.328241098494757, "Min_30.0% Prob": 4.272056260416584, "Min_40.0% Prob": 3.4839703894796825, "Min_50.0% Prob": 2.8813968323311716, "Min_60.0% Prob": 2.4619052077806187}}
{"hexsha": "9ecff8a3f9b50a3fe4c595109bb5cffdf777d1f8", "ext": "rs", "lang": "Rust", "content": "fn CalculateDeltaWeight1(number: i32, I2HWeight: [[f64;4];3], H2OWeight: [[f64;3];4], InputBias: [f64;4], HiddenBias: [f64;3], OutputBias: [f64;4], TeacherSignal: [f64;4]) -> [[f64;4];3] {\n    let mut NeuralNetwork = NeuronAndWeight::new(number, I2HWeight, H2OWeight, InputBias, HiddenBias, OutputBias, TeacherSignal);\n    let mut inputlayer = NeuralNetwork.inputlayer();\n    let mut Hiddenlayer = NeuralNetwork.Hiddenlayer(inputlayer);\n    let mut Outputlayer = NeuralNetwork.Outputlayer(Hiddenlayer);\n    let mut DeltaWeight: [[f64;4];3] = [[0.0;4];3];\n    for i in 0..3{\n        for j in 0..4{\n            DeltaWeight[i][j] = -0.19 * (Outputlayer[j] - TeacherSignal[j]) * Outputlayer[j] * (1.0 - Outputlayer[j]) * Hiddenlayer[i];\n        }\n    }\n    DeltaWeight\n}", "item_id": 1, "repo": "hota1024/Rust-NeuralNetwork", "file": "NeuralNetwork/NN/src/main.rs", "last_update_at": "2019-10-06T09:45:24+00:00", "question_id": "9ecff8a3f9b50a3fe4c595109bb5cffdf777d1f8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn CalculateDeltaWeight1(number: i32, I2HWeight: [[f64;4];3], H2OWeight: [[f64;3];4], InputBias: [f64;4], HiddenBias: [f64;3], OutputBias: [f64;4], TeacherSignal: [f64;4]) -> [[f64;4];3] {\n    let mut NeuralNetwork = NeuronAndWeight::new(number, I2HWeight, H2OWeight, InputBias, HiddenBias, OutputBias, TeacherSignal);\n    let mut inputlayer = NeuralNetwork.inputlayer();\n    let mut Hiddenlayer = NeuralNetwork.Hiddenlayer(inputlayer);\n    let mut Outputlayer = NeuralNetwork.Outputlayer(Hiddenlayer);\n    let mut DeltaWeight: [[f64;4];3] = [[0.0;4];3];\n    for i in 0..3{\n        for j in 0..4{\n            DeltaWeight[i][j] = -0.19 * (Outputlayer[j] - TeacherSignal[j]) * Outputlayer[j] * (1.0 - Outputlayer[j]) * Hiddenlayer[i];\n        }\n    }\n    DeltaWeight\n"]], "pred": {"ppl": 2.21724009513855, "ppl_lower": 2.301077365875244, "ppl/lowercase_ppl": -1.04661048017262, "ppl/zlib": 0.002593691277138346, "Min_5.0% Prob": 7.554451783498128, "Min_10.0% Prob": 5.727942093213399, "Min_20.0% Prob": 3.546114511177188, "Min_30.0% Prob": 2.5507728917443235, "Min_40.0% Prob": 1.9596299586015018, "Min_50.0% Prob": 1.5810499108311804, "Min_60.0% Prob": 1.3292513393554026}}
{"hexsha": "22c5e8c32a3eb4f8b9d2b68f1e265dcc1e8369a3", "ext": "rs", "lang": "Rust", "content": "fn update_maze(\n    maze: &mut HashMap<String, Coordinates>,\n    drone_coordinates: &Coordinates,\n    current_direction: &Direction,\n    kind: &CoordinatesKind,\n) -> () {\n    let coordinates = match current_direction {\n        Direction::North => Coordinates::new(\n            drone_coordinates.x,\n            drone_coordinates.y + 1,\n            Some(drone_coordinates.distance + 1),\n            Some(kind.clone()),\n        ),\n        Direction::East => Coordinates::new(\n            drone_coordinates.x + 1,\n            drone_coordinates.y,\n            Some(drone_coordinates.distance + 1),\n            Some(kind.clone()),\n        ),\n        Direction::South => Coordinates::new(\n            drone_coordinates.x,\n            drone_coordinates.y - 1,\n            Some(drone_coordinates.distance + 1),\n            Some(kind.clone()),\n        ),\n        Direction::West => Coordinates::new(\n            drone_coordinates.x - 1,\n            drone_coordinates.y,\n            Some(drone_coordinates.distance + 1),\n            Some(kind.clone()),\n        ),\n    };\n\n    let key = coordinates.to_maze_key();\n    if !maze.contains_key(&key) {\n        maze.insert(coordinates.to_maze_key(), coordinates.clone());\n    } else {\n        if maze.get(&key).unwrap().distance > coordinates.distance {\n            maze.insert(coordinates.to_maze_key(), coordinates.clone());\n        }\n    }\n}", "item_id": 3, "repo": "paulsouche/adventofcode2019", "file": "src/bin/day15-oxygen-system/main.rs", "last_update_at": "2019-12-01T11:34:37+00:00", "question_id": "22c5e8c32a3eb4f8b9d2b68f1e265dcc1e8369a3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn update_maze(\n    maze: &mut HashMap<String, Coordinates>,\n    drone_coordinates: &Coordinates,\n    current_direction: &Direction,\n    kind: &CoordinatesKind,\n) -> () {\n    let coordinates = match current_direction {\n        Direction::North => Coordinates::new(\n            drone_coordinates.x,\n            drone_coordinates.y + 1,\n            Some(drone_coordinates.distance + 1),\n            Some(kind.clone()),\n        ),\n        Direction::East => Coordinates::new(\n            drone_coordinates.x + 1,\n            drone_coordinates.y,\n            Some(drone_coordinates.distance + 1),\n            Some(kind.clone()),\n        ),\n        Direction::South => Coordinates::new(\n            drone_coordinates.x,\n            drone_coordinates.y - 1,\n            Some(drone_coordinates.distance + 1),\n            Some(kind.clone()),\n        ),\n        Direction::West => Coordinates::new(\n            drone_coordinates.x - 1,\n            drone_coordinates.y,\n            Some(drone_coordinates.distance + 1),\n            Some(kind.clone()),\n        ),\n    };\n    let key = coordinates.to_maze_key();\n    if !maze.contains_key(&key) {\n        maze.insert(coordinates.to_maze_key(), coordinates.clone());\n    } else {\n        if maze.get(&key).unwrap().distance > coordinates.distance {\n            maze.insert(coordinates.to_maze_key(), coordinates.clone());\n        }\n    }\n"]], "pred": {"ppl": 1.4756228923797607, "ppl_lower": 1.6148314476013184, "ppl/lowercase_ppl": -1.2317012886279717, "ppl/zlib": 0.001154540654500743, "Min_5.0% Prob": 5.405312478542328, "Min_10.0% Prob": 3.445226294238393, "Min_20.0% Prob": 1.9192508877400893, "Min_30.0% Prob": 1.2946932110190392, "Min_40.0% Prob": 0.9769994513431833, "Min_50.0% Prob": 0.7799439951771862, "Min_60.0% Prob": 0.648965177842183}}
{"hexsha": "97e8ae8f274d578a2fd82dbffc5c7a07a411b24f", "ext": "rs", "lang": "Rust", "content": "fn test_boundary_to_difficulty() {\n        let h1 = h256!(\"0x1000\");\n        let h2: U256 = target_to_difficulty(&h1);\n\n        assert_eq!(target_to_difficulty(&h2.into()), u256!(\"4096\"));\n    }", "item_id": 0, "repo": "LeastAuthority/nervos-ckb", "file": "util/types/src/utilities.rs", "last_update_at": "2019-08-09T07:30:56+00:00", "question_id": "97e8ae8f274d578a2fd82dbffc5c7a07a411b24f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_boundary_to_difficulty() {\n        let h1 = h256!(\"0x1000\");\n        let h2: U256 = target_to_difficulty(&h1);\n        assert_eq!(target_to_difficulty(&h2.into()), u256!(\"4096\"));\n"]], "pred": {"ppl": 4.2978835105896, "ppl_lower": 4.373385906219482, "ppl/lowercase_ppl": -1.0119433168360341, "ppl/zlib": 0.011046384050654084, "Min_5.0% Prob": 9.665800094604492, "Min_10.0% Prob": 8.108808755874634, "Min_20.0% Prob": 5.748498481862685, "Min_30.0% Prob": 4.48366497039795, "Min_40.0% Prob": 3.5223467192229103, "Min_50.0% Prob": 2.8624941976957543, "Min_60.0% Prob": 2.4409413136103573}}
{"hexsha": "aaa343b9c3f6dc86d8dafd26820f0757fa9a7f13", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let input = {\n        let fname = std::env::args()\n            .nth(1)\n            .expect(\"Please give input as first argument!\");\n        std::fs::read_to_string(fname).unwrap()\n    };\n\n    // part one\n    let module_fuel: i32 = input\n        .lines()\n        .map(|mass| mass.parse::<i32>().unwrap())\n        .map(|mass| mass / 3 - 2)\n        .sum();\n    println!(\"Module fuel required: {}\", module_fuel);\n\n    // part one\n    let total_fuel: i32 = input\n        .lines()\n        .map(|mass| mass.parse::<i32>().unwrap())\n        .map(|mut mass| {\n            let mut total = 0;\n            loop {\n                mass = mass / 3 - 2;\n                if mass < 0 {\n                    break;\n                }\n                total += mass;\n            }\n            total\n        })\n        .sum();\n    println!(\"Total fuel required: {}\", total_fuel);\n}", "item_id": 0, "repo": "johannst/aoc2019", "file": "src/bin/day1.rs", "last_update_at": "2019-12-01T16:26:58+00:00", "question_id": "aaa343b9c3f6dc86d8dafd26820f0757fa9a7f13_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let input = {\n        let fname = std::env::args()\n            .nth(1)\n            .expect(\"Please give input as first argument!\");\n        std::fs::read_to_string(fname).unwrap()\n    };\n    // part one\n    let module_fuel: i32 = input\n        .lines()\n        .map(|mass| mass.parse::<i32>().unwrap())\n        .map(|mass| mass / 3 - 2)\n        .sum();\n    println!(\"Module fuel required: {}\", module_fuel);\n    // part one\n    let total_fuel: i32 = input\n        .lines()\n        .map(|mass| mass.parse::<i32>().unwrap())\n        .map(|mut mass| {\n            let mut total = 0;\n            loop {\n                mass = mass / 3 - 2;\n                if mass < 0 {\n                    break;\n                }\n                total += mass;\n            }\n            total\n        })\n        .sum();\n    println!(\"Total fuel required: {}\", total_fuel);\n"]], "pred": {"ppl": 1.5727232694625854, "ppl_lower": 1.5817248821258545, "ppl/lowercase_ppl": -1.0126041439918654, "ppl/zlib": 0.0013805142782735036, "Min_5.0% Prob": 5.141775076205914, "Min_10.0% Prob": 3.727752208709717, "Min_20.0% Prob": 2.1824639619521373, "Min_30.0% Prob": 1.4997850887477397, "Min_40.0% Prob": 1.1318069009510714, "Min_50.0% Prob": 0.9070852555112162, "Min_60.0% Prob": 0.7559746642487112}}
{"hexsha": "79fe1bf2f4d04b57afd3610546532d7a6b279df5", "ext": "rs", "lang": "Rust", "content": "fn main() {\n  let mut argv = std::env::args();\n  let argc = argv.len();\n  if argc == 0 || argc > 2 {\n    panic!(\"restart test binary expect either no arguments or `restart`.\")\n  }\n\n  println!(\n    \"{}\",\n    tauri::api::process::current_binary(&Default::default())\n      .expect(\"tauri::api::process::current_binary could not resolve\")\n      .display()\n  );\n\n  match argv.nth(1).as_deref() {\n    Some(\"restart\") => tauri::api::process::restart(&Default::default()),\n    Some(invalid) => panic!(\"only argument `restart` is allowed, {} is invalid\", invalid),\n    None => {}\n  };\n}", "item_id": 0, "repo": "Brooooooklyn/tauri", "file": "core/tauri/tests/restart/src/main.rs", "last_update_at": "2019-08-14T10:10:32+00:00", "question_id": "79fe1bf2f4d04b57afd3610546532d7a6b279df5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n  let mut argv = std::env::args();\n  let argc = argv.len();\n  if argc == 0 || argc > 2 {\n    panic!(\"restart test binary expect either no arguments or `restart`.\")\n  }\n  println!(\n    \"{}\",\n    tauri::api::process::current_binary(&Default::default())\n      .expect(\"tauri::api::process::current_binary could not resolve\")\n      .display()\n  );\n  match argv.nth(1).as_deref() {\n    Some(\"restart\") => tauri::api::process::restart(&Default::default()),\n    Some(invalid) => panic!(\"only argument `restart` is allowed, {} is invalid\", invalid),\n    None => {}\n  };\n"]], "pred": {"ppl": 2.964557647705078, "ppl_lower": 3.3105077743530273, "ppl/lowercase_ppl": -1.1015652224388648, "ppl/zlib": 0.0034943017041448835, "Min_5.0% Prob": 8.293868064880371, "Min_10.0% Prob": 6.368622579072651, "Min_20.0% Prob": 4.514360456090224, "Min_30.0% Prob": 3.3756611234155196, "Min_40.0% Prob": 2.6674663877332367, "Min_50.0% Prob": 2.1571552848693023, "Min_60.0% Prob": 1.8135349747628486}}
{"hexsha": "871acf8c0c281eda48b914b078dfe4caf16b4b4c", "ext": "rs", "lang": "Rust", "content": "pub fn do_write(fd: FileDesc, buf: &[u8]) -> Result<usize, Error> {\n    let current_ref = process::get_current();\n    let current_process = current_ref.lock().unwrap();\n    let file_ref = current_process.get_files().get(fd)?;\n    file_ref.write(buf)\n}", "item_id": 1, "repo": "wangrunji0408/libos", "file": "src/libos/src/fs/mod.rs", "last_update_at": "2019-12-23T03:12:24+00:00", "question_id": "871acf8c0c281eda48b914b078dfe4caf16b4b4c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn do_write(fd: FileDesc, buf: &[u8]) -> Result<usize, Error> {\n    let current_ref = process::get_current();\n    let current_process = current_ref.lock().unwrap();\n    let file_ref = current_process.get_files().get(fd)?;\n    file_ref.write(buf)\n"]], "pred": {"ppl": 2.713489294052124, "ppl_lower": 3.464559316635132, "ppl/lowercase_ppl": -1.2447820240620786, "ppl/zlib": 0.006086801030944224, "Min_5.0% Prob": 7.697226405143738, "Min_10.0% Prob": 5.968560576438904, "Min_20.0% Prob": 4.113882289213293, "Min_30.0% Prob": 3.064007974587954, "Min_40.0% Prob": 2.445100157576449, "Min_50.0% Prob": 1.9815057911152063, "Min_60.0% Prob": 1.6579378357586951}}
{"hexsha": "e576b0a0a4abab1238ee2fe01221f68906adc664", "ext": "rs", "lang": "Rust", "content": "fn test_version_to_string() {\n    let valid_version = \"1.10.1947-abcd-EFG+1A-bc-2\";\n\n    let version_a = Version::parse(valid_version).unwrap();\n    let version_a_str = version_a.to_string();\n\n    let version_b = Version::parse(&version_a_str).unwrap();\n    assert_eq!(version_a, version_b);\n}", "item_id": 7, "repo": "alsacoin/alsacoin", "file": "models/src/version.rs", "last_update_at": "2019-07-14T22:18:10+00:00", "question_id": "e576b0a0a4abab1238ee2fe01221f68906adc664_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_version_to_string() {\n    let valid_version = \"1.10.1947-abcd-EFG+1A-bc-2\";\n    let version_a = Version::parse(valid_version).unwrap();\n    let version_a_str = version_a.to_string();\n    let version_b = Version::parse(&version_a_str).unwrap();\n    assert_eq!(version_a, version_b);\n"]], "pred": {"ppl": 3.371654748916626, "ppl_lower": 3.410966396331787, "ppl/lowercase_ppl": -1.0095375759203746, "ppl/zlib": 0.007741424504898831, "Min_5.0% Prob": 7.661105918884277, "Min_10.0% Prob": 6.4223572557622735, "Min_20.0% Prob": 4.67883254181255, "Min_30.0% Prob": 3.7104188456679834, "Min_40.0% Prob": 2.962557705965909, "Min_50.0% Prob": 2.392616984833564, "Min_60.0% Prob": 2.02383038579528}}
{"hexsha": "141117cc909f026ccff6c9b0051d5dace3ad9055", "ext": "rs", "lang": "Rust", "content": "fn alu2_bic(arm: &mut Arm7TDMI, op: ThumbOp) {\n    let (rd_index, rd, rs) = decode_alu2_reg(arm, op);\n    let result = rd & !rs;\n    set_zn(arm, result);\n    arm.regs[rd_index] = result;\n}", "item_id": 17, "repo": "angusholder/gba-emulator", "file": "src/arm7tdmi/core_thumb.rs", "last_update_at": "2019-09-29T05:10:36+00:00", "question_id": "141117cc909f026ccff6c9b0051d5dace3ad9055_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn alu2_bic(arm: &mut Arm7TDMI, op: ThumbOp) {\n    let (rd_index, rd, rs) = decode_alu2_reg(arm, op);\n    let result = rd & !rs;\n    set_zn(arm, result);\n    arm.regs[rd_index] = result;\n"]], "pred": {"ppl": 4.804666042327881, "ppl_lower": 5.701112270355225, "ppl/lowercase_ppl": -1.108992807941288, "ppl/zlib": 0.010605321201958685, "Min_5.0% Prob": 8.830982446670532, "Min_10.0% Prob": 7.260271906852722, "Min_20.0% Prob": 5.27630194495706, "Min_30.0% Prob": 4.329665040969848, "Min_40.0% Prob": 3.6246386345695045, "Min_50.0% Prob": 3.0422350390012873, "Min_60.0% Prob": 2.619925257037668}}
{"hexsha": "5652327da33a0f6fc607804ae111f4a5fc642430", "ext": "rs", "lang": "Rust", "content": "fn test_example2() {\n        // 2,3,0,3,99 becomes 2,3,0,6,99 (3 * 2 = 6).\n        let prog = vec![2, 3, 0, 3, 99];\n        assert_eq!(eval(&prog, 3), 6);\n    }", "item_id": 3, "repo": "johannst/aoc2019", "file": "src/bin/day5.rs", "last_update_at": "2019-12-01T16:26:58+00:00", "question_id": "5652327da33a0f6fc607804ae111f4a5fc642430_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_example2() {\n        // 2,3,0,3,99 becomes 2,3,0,6,99 (3 * 2 = 6).\n        let prog = vec![2, 3, 0, 3, 99];\n        assert_eq!(eval(&prog, 3), 6);\n"]], "pred": {"ppl": 2.963852882385254, "ppl_lower": 2.963852882385254, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.008622937074438118, "Min_5.0% Prob": 6.81016731262207, "Min_10.0% Prob": 5.581088066101074, "Min_20.0% Prob": 4.257787391543388, "Min_30.0% Prob": 3.2809522581100463, "Min_40.0% Prob": 2.6580886768572256, "Min_50.0% Prob": 2.15197736486083, "Min_60.0% Prob": 1.8200064357370138}}
{"hexsha": "c2cbdf536ea85ec0bf04276863059a2f52bd05c1", "ext": "rs", "lang": "Rust", "content": "pub fn derive_enum_signingkey(input: TokenStream) -> TokenStream {\n    let ast = parse_macro_input!(input as DeriveInput);\n\n    let name = &ast.ident;\n    let public_key_type = get_type_from_attrs(&ast.attrs, \"PublicKeyType\").unwrap();\n    let signature_type = get_type_from_attrs(&ast.attrs, \"SignatureType\").unwrap();\n    match ast.data {\n        Data::Enum(ref variants) => {\n            impl_enum_signingkey(name, public_key_type, signature_type, variants)\n        }\n        Data::Struct(_) | Data::Union(_) => {\n            panic!(\"#[derive(PrivateKey)] is only defined for enums\")\n        }\n    }\n}", "item_id": 12, "repo": "prz23/libra", "file": "crypto/crypto_derive/src/lib.rs", "last_update_at": "2019-09-04T22:10:07+00:00", "question_id": "c2cbdf536ea85ec0bf04276863059a2f52bd05c1_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn derive_enum_signingkey(input: TokenStream) -> TokenStream {\n    let ast = parse_macro_input!(input as DeriveInput);\n    let name = &ast.ident;\n    let public_key_type = get_type_from_attrs(&ast.attrs, \"PublicKeyType\").unwrap();\n    let signature_type = get_type_from_attrs(&ast.attrs, \"SignatureType\").unwrap();\n    match ast.data {\n        Data::Enum(ref variants) => {\n            impl_enum_signingkey(name, public_key_type, signature_type, variants)\n        }\n        Data::Struct(_) | Data::Union(_) => {\n            panic!(\"#[derive(PrivateKey)] is only defined for enums\")\n        }\n    }\n"]], "pred": {"ppl": 2.100202798843384, "ppl_lower": 2.887805700302124, "ppl/lowercase_ppl": -1.4291758433636572, "ppl/zlib": 0.002417048569851831, "Min_5.0% Prob": 7.640695412953694, "Min_10.0% Prob": 5.423574786437185, "Min_20.0% Prob": 3.3690703166158578, "Min_30.0% Prob": 2.4054251104070428, "Min_40.0% Prob": 1.8402279028064246, "Min_50.0% Prob": 1.4872029022274849, "Min_60.0% Prob": 1.2442536310130812}}
{"hexsha": "8a352e4719ceb70abd5709261c76807c8aee0b69", "ext": "rs", "lang": "Rust", "content": "fn test_matrix_sub_move_ref() {\n        let (m, n) = (2, 4);\n        let a = Matrix::from_vec(vec![40.0, 90.0, 50.0, 100.0, 50.0, 120.0, 60.0, 130.0], m, n);\n        let b = Matrix::from_vec(vec![38.0, 83.0, 44.0, 98.0, 50.0, 113.0, 56.0, 128.0], m, n);\n\n        let out = a - &b;\n\n        let out_data = out.data();\n        assert_eq!(*out_data.values(), vec![2.0, 7.0, 6.0, 2.0, 0.0, 7.0, 4.0, 2.0]);\n    }", "item_id": 20, "repo": "jblondin/matrix", "file": "src/ops.rs", "last_update_at": "2019-06-29T15:43:58+00:00", "question_id": "8a352e4719ceb70abd5709261c76807c8aee0b69_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_matrix_sub_move_ref() {\n        let (m, n) = (2, 4);\n        let a = Matrix::from_vec(vec![40.0, 90.0, 50.0, 100.0, 50.0, 120.0, 60.0, 130.0], m, n);\n        let b = Matrix::from_vec(vec![38.0, 83.0, 44.0, 98.0, 50.0, 113.0, 56.0, 128.0], m, n);\n        let out = a - &b;\n        let out_data = out.data();\n        assert_eq!(*out_data.values(), vec![2.0, 7.0, 6.0, 2.0, 0.0, 7.0, 4.0, 2.0]);\n"]], "pred": {"ppl": 2.320333957672119, "ppl_lower": 2.388336420059204, "ppl/lowercase_ppl": -1.0343181189638584, "ppl/zlib": 0.004066237307204199, "Min_5.0% Prob": 6.258071621259053, "Min_10.0% Prob": 4.7236689527829485, "Min_20.0% Prob": 3.392623968422413, "Min_30.0% Prob": 2.596043273806572, "Min_40.0% Prob": 2.0507407911742725, "Min_50.0% Prob": 1.6692447454979022, "Min_60.0% Prob": 1.3993363253280728}}
{"hexsha": "4b08a39dbd37f75e9e839e81b665a09333063dda", "ext": "rs", "lang": "Rust", "content": "fn assert_reverse_seek(engine: &Engine, key: &[u8], pair: (&[u8], &[u8])) {\n        let snapshot = engine.snapshot(&Context::new()).unwrap();\n        let mut iter = snapshot.iter(None, true, ScanMode::Mixed).unwrap();\n        iter.reverse_seek(&make_key(key)).unwrap();\n        assert_eq!((iter.key(), iter.value()),\n                   (&*bytes::encode_bytes(pair.0), pair.1));\n    }", "item_id": 3, "repo": "Caoming/tikv", "file": "src/storage/engine/mod.rs", "last_update_at": "2019-09-07T01:44:36+00:00", "question_id": "4b08a39dbd37f75e9e839e81b665a09333063dda_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn assert_reverse_seek(engine: &Engine, key: &[u8], pair: (&[u8], &[u8])) {\n        let snapshot = engine.snapshot(&Context::new()).unwrap();\n        let mut iter = snapshot.iter(None, true, ScanMode::Mixed).unwrap();\n        iter.reverse_seek(&make_key(key)).unwrap();\n        assert_eq!((iter.key(), iter.value()),\n                   (&*bytes::encode_bytes(pair.0), pair.1));\n"]], "pred": {"ppl": 2.368929624557495, "ppl_lower": 3.434364080429077, "ppl/lowercase_ppl": -1.430632077142526, "ppl/zlib": 0.0038501706157202395, "Min_5.0% Prob": 8.043346325556437, "Min_10.0% Prob": 6.01031510035197, "Min_20.0% Prob": 3.777395553588867, "Min_30.0% Prob": 2.7497681034238717, "Min_40.0% Prob": 2.116590143710959, "Min_50.0% Prob": 1.7091422310331836, "Min_60.0% Prob": 1.4478380704592717}}
{"hexsha": "99ddf068c2e6c5ae1bfed4b3eb160e784bc0d71b", "ext": "rs", "lang": "Rust", "content": "pub unsafe fn mailimf_comments_new(mut cm_value: *mut libc::c_char) -> *mut mailimf_comments {\n    let mut comments: *mut mailimf_comments = 0 as *mut mailimf_comments;\n    comments =\n        malloc(::std::mem::size_of::<mailimf_comments>() as libc::size_t) as *mut mailimf_comments;\n    if comments.is_null() {\n        return 0 as *mut mailimf_comments;\n    }\n    (*comments).cm_value = cm_value;\n    return comments;\n}", "item_id": 30, "repo": "KAction/mmime", "file": "src/mailimf_types.rs", "last_update_at": "2019-09-16T15:25:05+00:00", "question_id": "99ddf068c2e6c5ae1bfed4b3eb160e784bc0d71b_30", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe fn mailimf_comments_new(mut cm_value: *mut libc::c_char) -> *mut mailimf_comments {\n    let mut comments: *mut mailimf_comments = 0 as *mut mailimf_comments;\n    comments =\n        malloc(::std::mem::size_of::<mailimf_comments>() as libc::size_t) as *mut mailimf_comments;\n    if comments.is_null() {\n        return 0 as *mut mailimf_comments;\n    }\n    (*comments).cm_value = cm_value;\n    return comments;\n"]], "pred": {"ppl": 1.927017092704773, "ppl_lower": 1.927017092704773, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.003526737954324434, "Min_5.0% Prob": 8.483571938105992, "Min_10.0% Prob": 5.797211834362575, "Min_20.0% Prob": 3.2563395145638236, "Min_30.0% Prob": 2.1820847271856936, "Min_40.0% Prob": 1.6606071829827953, "Min_50.0% Prob": 1.3205398833123994, "Min_60.0% Prob": 1.0956813869667135}}
{"hexsha": "4b05c21a539d186db17926df1a3431106bdd680b", "ext": "rs", "lang": "Rust", "content": "fn load_asset_to_vmo(path: &Path) -> Result<mem::Buffer, Error> {\n    let file = File::open(path)?;\n    let vmo = fdio::get_vmo_copy_from_file(&file)?;\n    let size = file.metadata()?.len();\n    Ok(mem::Buffer { vmo, size })\n}", "item_id": 1, "repo": "bootingman/fuchsia2", "file": "garnet/bin/fonts/src/font_service.rs", "last_update_at": "2019-10-09T10:50:57+00:00", "question_id": "4b05c21a539d186db17926df1a3431106bdd680b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn load_asset_to_vmo(path: &Path) -> Result<mem::Buffer, Error> {\n    let file = File::open(path)?;\n    let vmo = fdio::get_vmo_copy_from_file(&file)?;\n    let size = file.metadata()?.len();\n    Ok(mem::Buffer { vmo, size })\n"]], "pred": {"ppl": 2.1180412769317627, "ppl_lower": 3.061753988265991, "ppl/lowercase_ppl": -1.4910063594444565, "ppl/zlib": 0.004467212712057448, "Min_5.0% Prob": 7.0474594831466675, "Min_10.0% Prob": 5.1454116106033325, "Min_20.0% Prob": 3.330607789404252, "Min_30.0% Prob": 2.417914722974484, "Min_40.0% Prob": 1.8586575559207372, "Min_50.0% Prob": 1.4926542295989664, "Min_60.0% Prob": 1.2675264308300729}}
{"hexsha": "e049f4062c0057693c0c90e18fb5d6b5ec44bb92", "ext": "rs", "lang": "Rust", "content": "fn problem_2021_19_1() {\n    #![allow(clippy::unwrap_used)]\n    let input = read_to_string(\"src/year2021/day19_input.txt\").unwrap();\n    solve(2021, 19, 1, &input).unwrap();\n}", "item_id": 336, "repo": "fornwall/advent-of-code-2019-rs", "file": "crates/core/benches/iai.rs", "last_update_at": "2019-12-10T00:08:49+00:00", "question_id": "e049f4062c0057693c0c90e18fb5d6b5ec44bb92_336", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn problem_2021_19_1() {\n    #![allow(clippy::unwrap_used)]\n    let input = read_to_string(\"src/year2021/day19_input.txt\").unwrap();\n    solve(2021, 19, 1, &input).unwrap();\n"]], "pred": {"ppl": 3.554269790649414, "ppl_lower": 3.554269790649414, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.008868179291488646, "Min_5.0% Prob": 9.078162829081217, "Min_10.0% Prob": 7.221738883427212, "Min_20.0% Prob": 5.086143159866333, "Min_30.0% Prob": 3.8895930984745855, "Min_40.0% Prob": 3.1086303649410123, "Min_50.0% Prob": 2.5292882865820174, "Min_60.0% Prob": 2.122035561565389}}
{"hexsha": "66865861197b2155e1c09f6108e6ff6943ea3ca2", "ext": "rs", "lang": "Rust", "content": "pub fn generate_key()->[u8;32]{\n    let mut rng = rand::thread_rng();\n    let random:[u8;32] = rng.gen();\n    let secret = key::SecretKey::from_slice(&random).unwrap();\n    let mut return_slice:[u8;32] = [0;32];\n    (0..32).for_each(|i|{\n        return_slice[i] = secret[i];\n    });\n    return_slice\n}", "item_id": 1, "repo": "Vreath-core/rust-vreath-core", "file": "src/crypto.rs", "last_update_at": "2019-06-08T06:37:57+00:00", "question_id": "66865861197b2155e1c09f6108e6ff6943ea3ca2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn generate_key()->[u8;32]{\n    let mut rng = rand::thread_rng();\n    let random:[u8;32] = rng.gen();\n    let secret = key::SecretKey::from_slice(&random).unwrap();\n    let mut return_slice:[u8;32] = [0;32];\n    (0..32).for_each(|i|{\n        return_slice[i] = secret[i];\n    });\n    return_slice\n"]], "pred": {"ppl": 2.426959276199341, "ppl_lower": 2.6100120544433594, "ppl/lowercase_ppl": -1.082012725242305, "ppl/zlib": 0.0047926440385004055, "Min_5.0% Prob": 7.721643845240275, "Min_10.0% Prob": 6.118466158707936, "Min_20.0% Prob": 4.007177782555421, "Min_30.0% Prob": 2.8298018268413014, "Min_40.0% Prob": 2.1788417482748628, "Min_50.0% Prob": 1.7675780780613422, "Min_60.0% Prob": 1.4831671422450907}}
{"hexsha": "299aaaf5554c5d755825149a0e5f45c45387e24f", "ext": "rs", "lang": "Rust", "content": "fn test_align_baseline_multiline_column() {\n\tlet mut root = Node::new();\n\n\tstyle!(root,\n\t\tAlignItems(Align::Baseline),\n\t\tFlexWrap(Wrap::Wrap),\n\t\tWidth(100 pt),\n\t\tHeight(100 pt)\n\t);\n\n\tlet mut root_child_0 = Node::new();\n\n\tstyle!(root_child_0,\n\t\tWidth(50 pt),\n\t\tHeight(50 pt)\n\t);\n\n\tlet mut root_child_1 = Node::new();\n\n\tstyle!(root_child_1,\n\t\tWidth(30 pt),\n\t\tHeight(50 pt)\n\t);\n\n\tlet mut root_child_1_child_0 = Node::new();\n\n\tstyle!(root_child_1_child_0,\n\t\tWidth(20 pt),\n\t\tHeight(20 pt)\n\t);\n\n\tlet mut root_child_2 = Node::new();\n\n\tstyle!(root_child_2,\n\t\tWidth(40 pt),\n\t\tHeight(70 pt)\n\t);\n\n\tlet mut root_child_2_child_0 = Node::new();\n\n\tstyle!(root_child_2_child_0,\n\t\tWidth(10 pt),\n\t\tHeight(10 pt)\n\t);\n\n\tlet mut root_child_3 = Node::new();\n\n\tstyle!(root_child_3,\n\t\tWidth(50 pt),\n\t\tHeight(20 pt)\n\t);\n\n\troot.insert_child(&mut root_child_0, 0);\n\troot.insert_child(&mut root_child_1, 1);\n\troot.insert_child(&mut root_child_2, 2);\n\troot.insert_child(&mut root_child_3, 3);\n\n\troot_child_1.insert_child(&mut root_child_1_child_0, 0);\n\troot_child_2.insert_child(&mut root_child_2_child_0, 0);\n\troot.calculate_layout(Undefined, Undefined, Direction::LTR);\n\n\tlet root_layout = root.get_layout();\n\tlet child_0_layout = root_child_0.get_layout();\n\tlet child_1_layout = root_child_1.get_layout();\n\tlet child_1_child_0_layout = root_child_1_child_0.get_layout();\n\tlet child_2_layout = root_child_2.get_layout();\n\tlet child_2_child_0_layout = root_child_2_child_0.get_layout();\n\tlet child_3_layout = root_child_3.get_layout();\n\n\tassert_eq!(0.0, root_layout.left());\n\tassert_eq!(0.0, root_layout.top());\n\tassert_eq!(100.0, root_layout.width());\n\tassert_eq!(100.0, root_layout.height());\n\n\tassert_eq!(0.0, child_0_layout.left());\n\tassert_eq!(0.0, child_0_layout.top());\n\tassert_eq!(50.0, child_0_layout.width());\n\tassert_eq!(50.0, child_0_layout.height());\n\n\tassert_eq!(0.0, child_1_layout.left());\n\tassert_eq!(50.0, child_1_layout.top());\n\tassert_eq!(30.0, child_1_layout.width());\n\tassert_eq!(50.0, child_1_layout.height());\n\n\tassert_eq!(0.0, child_1_child_0_layout.left());\n\tassert_eq!(0.0, child_1_child_0_layout.top());\n\tassert_eq!(20.0, child_1_child_0_layout.width());\n\tassert_eq!(20.0, child_1_child_0_layout.height());\n\n\tassert_eq!(50.0, child_2_layout.left());\n\tassert_eq!(0.0, child_2_layout.top());\n\tassert_eq!(40.0, child_2_layout.width());\n\tassert_eq!(70.0, child_2_layout.height());\n\n\tassert_eq!(0.0, child_2_child_0_layout.left());\n\tassert_eq!(0.0, child_2_child_0_layout.top());\n\tassert_eq!(10.0, child_2_child_0_layout.width());\n\tassert_eq!(10.0, child_2_child_0_layout.height());\n\n\tassert_eq!(50.0, child_3_layout.left());\n\tassert_eq!(70.0, child_3_layout.top());\n\tassert_eq!(50.0, child_3_layout.width());\n\tassert_eq!(20.0, child_3_layout.height());\n\n\troot.calculate_layout(Undefined, Undefined, Direction::RTL);\n\n\tlet root_layout = root.get_layout();\n\tlet child_0_layout = root_child_0.get_layout();\n\tlet child_1_layout = root_child_1.get_layout();\n\tlet child_1_child_0_layout = root_child_1_child_0.get_layout();\n\tlet child_2_layout = root_child_2.get_layout();\n\tlet child_2_child_0_layout = root_child_2_child_0.get_layout();\n\tlet child_3_layout = root_child_3.get_layout();\n\n\tassert_eq!(0.0, root_layout.left());\n\tassert_eq!(0.0, root_layout.top());\n\tassert_eq!(100.0, root_layout.width());\n\tassert_eq!(100.0, root_layout.height());\n\n\tassert_eq!(50.0, child_0_layout.left());\n\tassert_eq!(0.0, child_0_layout.top());\n\tassert_eq!(50.0, child_0_layout.width());\n\tassert_eq!(50.0, child_0_layout.height());\n\n\tassert_eq!(70.0, child_1_layout.left());\n\tassert_eq!(50.0, child_1_layout.top());\n\tassert_eq!(30.0, child_1_layout.width());\n\tassert_eq!(50.0, child_1_layout.height());\n\n\tassert_eq!(10.0, child_1_child_0_layout.left());\n\tassert_eq!(0.0, child_1_child_0_layout.top());\n\tassert_eq!(20.0, child_1_child_0_layout.width());\n\tassert_eq!(20.0, child_1_child_0_layout.height());\n\n\tassert_eq!(10.0, child_2_layout.left());\n\tassert_eq!(0.0, child_2_layout.top());\n\tassert_eq!(40.0, child_2_layout.width());\n\tassert_eq!(70.0, child_2_layout.height());\n\n\tassert_eq!(30.0, child_2_child_0_layout.left());\n\tassert_eq!(0.0, child_2_child_0_layout.top());\n\tassert_eq!(10.0, child_2_child_0_layout.width());\n\tassert_eq!(10.0, child_2_child_0_layout.height());\n\n\tassert_eq!(0.0, child_3_layout.left());\n\tassert_eq!(70.0, child_3_layout.top());\n\tassert_eq!(50.0, child_3_layout.width());\n\tassert_eq!(20.0, child_3_layout.height());\n}", "item_id": 16, "repo": "mehcode/yoga-rs", "file": "tests/align_items_test.rs", "last_update_at": "2019-04-11T14:07:42+00:00", "question_id": "299aaaf5554c5d755825149a0e5f45c45387e24f_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_align_baseline_multiline_column() {\n\tlet mut root = Node::new();\n\tstyle!(root,\n\t\tAlignItems(Align::Baseline),\n\t\tFlexWrap(Wrap::Wrap),\n\t\tWidth(100 pt),\n\t\tHeight(100 pt)\n\t);\n\tlet mut root_child_0 = Node::new();\n\tstyle!(root_child_0,\n\t\tWidth(50 pt),\n\t\tHeight(50 pt)\n\t);\n\tlet mut root_child_1 = Node::new();\n\tstyle!(root_child_1,\n\t\tWidth(30 pt),\n\t\tHeight(50 pt)\n\t);\n\tlet mut root_child_1_child_0 = Node::new();\n\tstyle!(root_child_1_child_0,\n\t\tWidth(20 pt),\n\t\tHeight(20 pt)\n\t);\n\tlet mut root_child_2 = Node::new();\n\tstyle!(root_child_2,\n\t\tWidth(40 pt),\n\t\tHeight(70 pt)\n\t);\n\tlet mut root_child_2_child_0 = Node::new();\n\tstyle!(root_child_2_child_0,\n\t\tWidth(10 pt),\n\t\tHeight(10 pt)\n\t);\n\tlet mut root_child_3 = Node::new();\n\tstyle!(root_child_3,\n\t\tWidth(50 pt),\n\t\tHeight(20 pt)\n\t);\n\troot.insert_child(&mut root_child_0, 0);\n\troot.insert_child(&mut root_child_1, 1);\n\troot.insert_child(&mut root_child_2, 2);\n\troot.insert_child(&mut root_child_3, 3);\n\troot_child_1.insert_child(&mut root_child_1_child_0, 0);\n\troot_child_2.insert_child(&mut root_child_2_child_0, 0);\n\troot.calculate_layout(Undefined, Undefined, Direction::LTR);\n\tlet root_layout = root.get_layout();\n\tlet child_0_layout = root_child_0.get_layout();\n\tlet child_1_layout = root_child_1.get_layout();\n\tlet child_1_child_0_layout = root_child_1_child_0.get_layout();\n\tlet child_2_layout = root_child_2.get_layout();\n\tlet child_2_child_0_layout = root_child_2_child_0.get_layout();\n\tlet child_3_layout = root_child_3.get_layout();\n\tassert_eq!(0.0, root_layout.left());\n\tassert_eq!(0.0, root_layout.top());\n\tassert_eq!(100.0, root_layout.width());\n\tassert_eq!(100.0, root_layout.height());\n\tassert_eq!(0.0, child_0_layout.left());\n\tassert_eq!(0.0, child_0_layout.top());\n\tassert_eq!(50.0, child_0_layout.width());\n\tassert_eq!(50.0, child_0_layout.height());\n\tassert_eq!(0.0, child_1_layout.left());\n\tassert_eq!(50.0, child_1_layout.top());\n\tassert_eq!(30.0, child_1_layout.width());\n\tassert_eq!(50.0, child_1_layout.height());\n\tassert_eq!(0.0, child_1_child_0_layout.left());\n\tassert_eq!(0.0, child_1_child_0_layout.top());\n\tassert_eq!(20.0, child_1_child_0_layout.width());\n\tassert_eq!(20.0, child_1_child_0_layout.height());\n\tassert_eq!(50.0, child_2_layout.left());\n\tassert_eq!(0.0, child_2_layout.top());\n\tassert_eq!(40.0, child_2_layout.width());\n\tassert_eq!(70.0, child_2_layout.height());\n\tassert_eq!(0.0, child_2_child_0_layout.left());\n\tassert_eq!(0.0, child_2_child_0_layout.top());\n\tassert_eq!(10.0, child_2_child_0_layout.width());\n\tassert_eq!(10.0, child_2_child_0_layout.height());\n\tassert_eq!(50.0, child_3_layout.left());\n\tassert_eq!(70.0, child_3_layout.top());\n\tassert_eq!(50.0, child_3_layout.width());\n\tassert_eq!(20.0, child_3_layout.height());\n\troot.calculate_layout(Undefined, Undefined, Direction::RTL);\n\tlet root_layout = root.get_layout();\n\tlet child_0_layout = root_child_0.get_layout();\n\tlet child_1_layout = root_child_1.get_layout();\n\tlet child_1_child_0_layout = root_child_1_child_0.get_layout();\n\tlet child_2_layout = root_child_2.get_layout();\n\tlet child_2_child_0_layout = root_child_2_child_0.get_layout();\n\tlet child_3_layout = root_child_3.get_layout();\n\tassert_eq!(0.0, root_layout.left());\n\tassert_eq!(0.0, root_layout.top());\n\tassert_eq!(100.0, root_layout.width());\n\tassert_eq!(100.0, root_layout.height());\n\tassert_eq!(50.0, child_0_layout.left());\n\tassert_eq!(0.0, child_0_layout.top());\n\tassert_eq!(50.0, child_0_layout.width());\n\tassert_eq!(50.0, child_0_layout.height());\n\tassert_eq!(70.0, child_1_layout.left());\n\tassert_eq!(50.0, child_1_layout.top());\n\tassert_eq!(30.0, child_1_layout.width());\n\tassert_eq!(50.0, child_1_layout.height());\n\tassert_eq!(10.0, child_1_child_0_layout.left());\n\tassert_eq!(0.0, child_1_child_0_layout.top());\n\tassert_eq!(20.0, child_1_child_0_layout.width());\n\tassert_eq!(20.0, child_1_child_0_layout.height());\n\tassert_eq!(10.0, child_2_layout.left());\n\tassert_eq!(0.0, child_2_layout.top());\n\tassert_eq!(40.0, child_2_layout.width());\n\tassert_eq!(70.0, child_2_layout.height());\n\tassert_eq!(30.0, child_2_child_0_layout.left());\n\tassert_eq!(0.0, child_2_child_0_layout.top());\n\tassert_eq!(10.0, child_2_child_0_layout.width());\n\tassert_eq!(10.0, child_2_child_0_layout.height());\n\tassert_eq!(0.0, child_3_layout.left());\n\tassert_eq!(70.0, child_3_layout.top());\n\tassert_eq!(50.0, child_3_layout.width());\n\tassert_eq!(20.0, child_3_layout.height());\n"]], "pred": {"ppl": 1.143164038658142, "ppl_lower": 1.187145471572876, "ppl/lowercase_ppl": -1.2821509911725135, "ppl/zlib": 0.0002468632664236947, "Min_5.0% Prob": 2.347922136970595, "Min_10.0% Prob": 1.3046735929069566, "Min_20.0% Prob": 0.6690497451448155, "Min_30.0% Prob": 0.4470396808514469, "Min_40.0% Prob": 0.3345951381520013, "Min_50.0% Prob": 0.26784020167938455, "Min_60.0% Prob": 0.22328399082037917}}
{"hexsha": "64bd06241455d09a190e768da6e96ebf6504eb3f", "ext": "rs", "lang": "Rust", "content": "fn calculate_intersections(horizontals: Segments, verticals: Segments) -> Intersections {\n    let mut intersections: Intersections = vec![];\n    for h in horizontals.iter() {\n        for v in verticals.iter() {\n            let (x1, x2, xv) = (h.p1.x, h.p2.x, v.p1.x);\n            let (y1, y2, yh) = (v.p1.y, v.p2.y, h.p1.y);\n\n            if route(x1, x2).contains(&xv) && route(y1, y2).contains(&yh) {\n                let h_steps = if x1 > xv { x1 - xv } else { xv - x1 };\n                let v_steps = if y1 > yh { y1 - yh } else { yh - y1 };\n                let steps = h_steps.abs() + v_steps.abs();\n\n                let point = Point { x: xv, y: yh };\n                let cost = h.last_steps + v.last_steps + steps;\n                intersections.push(Intersection { point, cost })\n            }\n        }\n    }\n    intersections\n}", "item_id": 4, "repo": "asaaki/advent-of-code-2019", "file": "day_3/src/main.rs", "last_update_at": "2019-12-04T08:04:47+00:00", "question_id": "64bd06241455d09a190e768da6e96ebf6504eb3f_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn calculate_intersections(horizontals: Segments, verticals: Segments) -> Intersections {\n    let mut intersections: Intersections = vec![];\n    for h in horizontals.iter() {\n        for v in verticals.iter() {\n            let (x1, x2, xv) = (h.p1.x, h.p2.x, v.p1.x);\n            let (y1, y2, yh) = (v.p1.y, v.p2.y, h.p1.y);\n            if route(x1, x2).contains(&xv) && route(y1, y2).contains(&yh) {\n                let h_steps = if x1 > xv { x1 - xv } else { xv - x1 };\n                let v_steps = if y1 > yh { y1 - yh } else { yh - y1 };\n                let steps = h_steps.abs() + v_steps.abs();\n                let point = Point { x: xv, y: yh };\n                let cost = h.last_steps + v.last_steps + steps;\n                intersections.push(Intersection { point, cost })\n            }\n        }\n    }\n    intersections\n"]], "pred": {"ppl": 1.922271728515625, "ppl_lower": 1.990777611732483, "ppl/lowercase_ppl": -1.0535841347675405, "ppl/zlib": 0.0019108411653654329, "Min_5.0% Prob": 7.522352790832519, "Min_10.0% Prob": 5.076651632785797, "Min_20.0% Prob": 3.0796414643526075, "Min_30.0% Prob": 2.1578840576940115, "Min_40.0% Prob": 1.6266435919221767, "Min_50.0% Prob": 1.3089098523599128, "Min_60.0% Prob": 1.0931553902536713}}
{"hexsha": "361786427b43e63c96e1572d6ae73b7ec03b5555", "ext": "rs", "lang": "Rust", "content": "fn menu_loop() {\n    let mut keep_playing = true;\n    while keep_playing {\n        game_loop();\n        keep_playing = play_again();\n    }\n    println!(\"Bye.\");\n}", "item_id": 4, "repo": "OMerkel/hangman", "file": "rust/src/main.rs", "last_update_at": "2019-04-16T04:09:41+00:00", "question_id": "361786427b43e63c96e1572d6ae73b7ec03b5555_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn menu_loop() {\n    let mut keep_playing = true;\n    while keep_playing {\n        game_loop();\n        keep_playing = play_again();\n    }\n    println!(\"Bye.\");\n"]], "pred": {"ppl": 2.76020884513855, "ppl_lower": 2.9249539375305176, "ppl/lowercase_ppl": -1.0570984191866388, "ppl/zlib": 0.00931473711371376, "Min_5.0% Prob": 9.410114288330078, "Min_10.0% Prob": 6.167317962646484, "Min_20.0% Prob": 4.270726398988203, "Min_30.0% Prob": 3.2352641336619854, "Min_40.0% Prob": 2.4726964750073175, "Min_50.0% Prob": 2.054228480767321, "Min_60.0% Prob": 1.688682513706612}}
{"hexsha": "8dccec5f395287c0afb837916967123e68a704f1", "ext": "rs", "lang": "Rust", "content": "fn greet(_: &Request, res: Response<Fresh>, cap: Captures) {\n    let mut r = res.start().unwrap();\n    r.write_all(format!(\"Hello, {}\", cap.at(1).unwrap()).as_bytes()).unwrap();\n    r.end().unwrap();\n}", "item_id": 2, "repo": "kpp/rust_vs_go_habr_273341", "file": "rust/src/main.rs", "last_update_at": "2019-09-04T01:32:36+00:00", "question_id": "8dccec5f395287c0afb837916967123e68a704f1_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn greet(_: &Request, res: Response<Fresh>, cap: Captures) {\n    let mut r = res.start().unwrap();\n    r.write_all(format!(\"Hello, {}\", cap.at(1).unwrap()).as_bytes()).unwrap();\n    r.end().unwrap();\n"]], "pred": {"ppl": 3.5778470039367676, "ppl_lower": 4.846383094787598, "ppl/lowercase_ppl": -1.2380614058766548, "ppl/zlib": 0.008442127310949543, "Min_5.0% Prob": 8.706496874491373, "Min_10.0% Prob": 6.473038945879255, "Min_20.0% Prob": 4.874945214816502, "Min_30.0% Prob": 3.7096547456014726, "Min_40.0% Prob": 2.97850473012243, "Min_50.0% Prob": 2.4857278193746293, "Min_60.0% Prob": 2.120862871763252}}
{"hexsha": "debf0e957e9532c37cfb48e0ca38a957ebc75263", "ext": "rs", "lang": "Rust", "content": "fn is_range_empty(engine: &DB, cf: &str, start_key: &[u8], end_key: &[u8]) -> Result<bool> {\n    let mut count: u32 = 0;\n    engine.scan_cf(cf, start_key, end_key, false, |_, _| {\n        count += 1;\n        Ok(false)\n    })?;\n\n    Ok(count == 0)\n}", "item_id": 0, "repo": "gregwebs/tikv", "file": "src/raftstore/store/bootstrap.rs", "last_update_at": "2019-03-06T07:07:25+00:00", "question_id": "debf0e957e9532c37cfb48e0ca38a957ebc75263_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn is_range_empty(engine: &DB, cf: &str, start_key: &[u8], end_key: &[u8]) -> Result<bool> {\n    let mut count: u32 = 0;\n    engine.scan_cf(cf, start_key, end_key, false, |_, _| {\n        count += 1;\n        Ok(false)\n    })?;\n    Ok(count == 0)\n"]], "pred": {"ppl": 1.8973958492279053, "ppl_lower": 2.400559186935425, "ppl/lowercase_ppl": -1.3672534738021473, "ppl/zlib": 0.0036598990877930422, "Min_5.0% Prob": 8.042224407196045, "Min_10.0% Prob": 5.182232206518, "Min_20.0% Prob": 3.0080474506724966, "Min_30.0% Prob": 2.0886480250593387, "Min_40.0% Prob": 1.587490745820105, "Min_50.0% Prob": 1.2772904602641408, "Min_60.0% Prob": 1.0665239730751086}}
{"hexsha": "026a03dfe1d252c9b6a778c7eca0317b6a75f042", "ext": "rs", "lang": "Rust", "content": "pub fn report_errors(files: Files, errors: Errors) -> ! {\n    assert!(!errors.is_empty());\n    let mut codemap = CodeMap::new();\n    let mut file_mapping = HashMap::new();\n    let mut current_end = 1;\n    for (fname, filemap) in files.into_iter() {\n        file_mapping.insert(fname, current_end);\n        let added_fmap = codemap.add_filemap(FileName::real(fname), filemap.src().to_string());\n        current_end = added_fmap.span().end().to_usize() + 1;\n    }\n    render_errors(&codemap, file_mapping, errors);\n    std::process::exit(1)\n}", "item_id": 0, "repo": "iqlusioninc/libra", "file": "language/move-lang/src/errors/mod.rs", "last_update_at": "2019-06-19T01:34:22+00:00", "question_id": "026a03dfe1d252c9b6a778c7eca0317b6a75f042_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn report_errors(files: Files, errors: Errors) -> ! {\n    assert!(!errors.is_empty());\n    let mut codemap = CodeMap::new();\n    let mut file_mapping = HashMap::new();\n    let mut current_end = 1;\n    for (fname, filemap) in files.into_iter() {\n        file_mapping.insert(fname, current_end);\n        let added_fmap = codemap.add_filemap(FileName::real(fname), filemap.src().to_string());\n        current_end = added_fmap.span().end().to_usize() + 1;\n    }\n    render_errors(&codemap, file_mapping, errors);\n    std::process::exit(1)\n"]], "pred": {"ppl": 3.0265650749206543, "ppl_lower": 3.673466205596924, "ppl/lowercase_ppl": -1.1749163734406878, "ppl/zlib": 0.003927050843357824, "Min_5.0% Prob": 8.279245429568821, "Min_10.0% Prob": 6.761050091849433, "Min_20.0% Prob": 4.650512049595515, "Min_30.0% Prob": 3.44510801743578, "Min_40.0% Prob": 2.689797616576495, "Min_50.0% Prob": 2.2047965303882138, "Min_60.0% Prob": 1.8540678985690304}}
{"hexsha": "5e6c54232d0ab5769881565b62e2e5745ca9b290", "ext": "rs", "lang": "Rust", "content": "pub fn runner() {\n    let mut console = ConsoleHandle::init_default();\n    console.clear();\n\n    println!(\"Setting up sterr file hooks.\");\n    console.update();\n    let mut error_file = match redirect_stderr(\"nx_fatdrive_sterr.txt\") {\n        Ok(fl) => fl,\n        Err(e) => {\n            println!(\"Error setting stderr output: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    console.update();\n    \n    \n    multprint!(console,error_file,\"Setting up HID context.\");\n    let mut hid_ctx = HidContext::new();\n    let controller = hid_ctx.get_controller(HidControllerID::CONTROLLER_P1_AUTO);\n\n    multprint!(console,error_file,\"Setting up usb:hs context\");\n    let mut usbhs_ctx = match UsbHsContext::initialize() {\n        Ok(ctx) => ctx, \n        Err(e) => {\n            multprint!(console, error_file, \"Failed setting up usb:hs context: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    let filter : InterfaceFilter = InterfaceFilter::new()\n        .with_interface_class(8)\n        .with_interface_subclass(6)\n        .with_interface_protocol(80);\n    \n    multprint!(console, error_file, \"Waiting for usb event.\");\n    let evt = match InterfaceAvailableEvent::create(true, 0, filter) {\n        Ok(ev) => ev, \n        Err(e) => {\n            multprint!(console, error_file, \"Failed building iface available event: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n\n        }\n    };\n    if let Err(e) = evt.wait(u64::max_value()) {\n        multprint!(console, error_file, \"Failed waiting for event: {:?}\", e);\n        let delay_start = Instant::now();\n        while delay_start.elapsed() < Duration::from_secs(5) {\n            console.update();\n        }\n        return;\n    }\n    multprint!(console,error_file,\"Looking for usb devices.\");\n\n    let mut interfaces = match usbhs_ctx.query_available_interfaces(filter, 3) {\n        Ok(ifaces) => ifaces, \n        Err(e) => {\n            multprint!(console, error_file, \"Failed querying available interfaces: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    multprint!(console, error_file, \"Got interfaces: {:?}\", interfaces);\n\n    let mut iface = match interfaces.pop() {\n        Some(iface) => iface, \n        None => {\n            multprint!(console, error_file, \"Failed finding any matching interfaces.\");\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    multprint!(console, error_file, \"\\nSuccess! Using iface: {:?}\", iface);\n\n    console.update();\n\n    let (read_ep, write_ep) = match UsbClient::retrieve_iface_endpoints(&iface) {\n        Ok(p) => p,\n        Err(e) => {\n            multprint!(console, error_file, \"Failed getting eps: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    let mut session = match usbhs_ctx.acquire_interface(&iface) {\n        Ok(s) => s,\n        Err(e) => {\n            multprint!(console, error_file, \"Failed acquiring iface: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    let client = match UsbClient::new(session, read_ep, write_ep) {\n        Ok(c) => c, \n        Err(e) => {\n            multprint!(console, error_file, \"Got error on usbclient::new of {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n\n        }\n    };\n    \n    multprint!(console,error_file,\"Making SCSI wrapper object.\");\n    console.update();\n\n    let mut scsi_wrapper = match scsi::scsi::ScsiBlockDevice::new(client, VecNewtype::new(), VecNewtype::new(), VecNewtype::new()) {\n        Ok(c) => c,\n        Err(e) => {\n            multprint!(console, error_file, \"Failed creating SCSI wrapper object: {:?}\", e);\n\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    multprint!(console,error_file,\"SCSI device found with block size {}.\", scsi_wrapper.block_size());\n    multprint!(console,error_file,\"Trying to get MBR.\");\n    console.update();\n\n    let mut mbr_buff = VecNewtype::with_fake_capacity(512.max(scsi_wrapper.block_size() as usize));\n    let mut mbr_read_count = 0;\n    while mbr_buff.inner.len() < 512 {\n        multprint!(console, error_file, \"MBR Parse pre-status {}: {}/512.\", mbr_read_count, mbr_buff.inner.len());\n        let _bt = match scsi_wrapper.read(mbr_buff.inner.len() as u32, &mut mbr_buff) {\n            Ok(bt) => {\n                multprint!(console, error_file, \"Got {} bytes on read {}.\", mbr_buff.inner.len(), bt);\n                multprint!(console, error_file, \"Ended with bytes: {:X?}\", mbr_buff.inner);\n                bt\n            }, \n            Err(e) => {\n                multprint!(console, error_file, \"Failed reading MBR on read number {} after already getting {} bytes: {:?}.\", mbr_read_count, mbr_buff.inner.len(), e);\n                multprint!(console, error_file, \"Ended with bytes: {:X?}\", mbr_buff.inner);\n\n                let delay_start = Instant::now();\n                while delay_start.elapsed() < Duration::from_secs(5) {\n                    console.update();\n                }\n                return;\n            }\n        };\n        mbr_read_count += 1;\n    }\n\n    multprint!(console,error_file,\"Parsing MBR.\");\n    console.update();\n\n    let mbr_entry = match mbr_nostd::MasterBootRecord::from_bytes(&mut mbr_buff.inner) {\n        Ok(mbr) => mbr, \n        Err(e) => {\n            multprint!(console, error_file, \"Failed parsing mbr: {:?}\", e);\n\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n\n    multprint!(console,error_file,\"Partitions:\");\n    for ent in mbr_entry.partition_table_entries() {\n        multprint!(console,error_file,\"    {:?}\", ent);\n    }\n\n\n    let first_ent : &PartitionTableEntry = &mbr_entry.partition_table_entries()[0];\n    let raw_offset : usize = (first_ent.logical_block_address * scsi_wrapper.block_size()) as usize; \n    multprint!(console, error_file, \"Creating FATFS wrapper starting at offset block {}, raw {}.\", first_ent.logical_block_address, raw_offset);\n\n    let mut partition = OffsetScsiDevice::new(scsi_wrapper, raw_offset);\n    let mut fs : fatfs::FileSystem<OffsetScsiDevice> = match fatfs::FileSystem::new(partition, fatfs::FsOptions::new()) {\n        Ok(fs) => fs, \n        Err(e) => {\n            multprint!(console, error_file, \"Error mounting FAT32 file system: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    multprint!(console, error_file, \"Scanning filesystem.\");\n    let mut root_dir = fs.root_dir();\n    let all_dirs = root_dir.iter().filter_map(|ent_res| {\n        match ent_res {\n            Ok(ent) => {\n                multprint!(console, error_file, \"FAT: Found itm. Short name: {}, long name: {}, attr: {:?}\", ent.short_file_name(), ent.file_name(), ent.attributes());\n                Some(ent)\n            },\n            Err(e) => {\n                multprint!(console, error_file, \"Error reading dirent: {:?}\", e);\n                None\n            }\n        }\n\n    }).collect::<Vec<_>>();\n\n    multprint!(console, error_file, \"Getting handle to test_folder directory.\");\n    let subdir_opt = all_dirs.iter().find_map(|fl| {\n        if fl.is_dir() && fl.file_name() == \"test_folder\".to_owned() {\n            multprint!(console, error_file,\"FAT: Using existing subdir: Short name: {}, long name: {}, attr: {:?}\", fl.short_file_name(), fl.file_name(), fl.attributes());\n            Some(fl.to_dir())\n        }\n        else {\n            None\n        }\n    });\n\n    let mut subdir_res = subdir_opt.ok_or(\"Could not find existing subdir.\").or_else(|_| {\n        root_dir.create_dir(\"test_folder\")\n    });\n    let mut subdir = match subdir_res {\n        Ok(s) => s, \n        Err(e) => {\n            multprint!(console, error_file, \"Error getting handle to test_folder: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n\n    let now = Instant::now();\n    let fl_name = format!(\"{:?}.txt\", now).replace(\" \", \"s\").replace(\":\", \"o\").replace(\"{\", \"q\").replace(\"}\", \"p\");\n    multprint!(console, error_file, \"Creating test file {} in the folder.\", fl_name);\n    let mut fl = match subdir.create_file(&fl_name) {\n        Ok(f) => f, \n        Err(e) => {\n            multprint!(console, error_file, \"Error creating test file: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    multprint!(console, error_file,\"Now writing to file.\");\n    if let Err(e) = fl.write_fmt(format_args!(\"Hello world at time {:?}\", now)) {\n        multprint!(console, error_file, \"Error writing to test file: {:?}\", e);\n        let delay_start = Instant::now();\n        while delay_start.elapsed() < Duration::from_secs(5) {\n            console.update();\n        }\n        return;\n    }\n\n    let next_dir_name = format!(\"{:?}_next_dir\", now).replace(\" \", \"s\").replace(\":\", \"o\").replace(\"{\", \"q\").replace(\"}\", \"p\");\n    multprint!(console, error_file, \"Now trying directory {}.\", next_dir_name);\n    let mut next_dir = match root_dir.create_dir(&next_dir_name) {\n        Ok(s) => s, \n        Err(e) => {\n            multprint!(console, error_file, \"Error getting handle to next_dir: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    let mut outfile = match next_dir.create_file(\"for_seuth.txt\") {\n        Ok(f) => f, \n        Err(e) => {\n            multprint!(console, error_file, \"Error creating for_seuth.txt: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    if let Err(e) = outfile.write(\"To be or not to be and all that jazz!.\".to_owned().into_bytes().as_slice()) {\n        multprint!(console, error_file, \"Error writing to for_seuth.txt: {:?}\", e);\n        let delay_start = Instant::now();\n        while delay_start.elapsed() < Duration::from_secs(5) {\n            console.update();\n        }\n        return;\n\n    }\n\n    multprint!(console, error_file, \"Done.\");\n\n    loop {\n        hid_ctx.scan_input();\n        if controller.keys_down_raw() & HidControllerKeys::KEY_PLUS.0 as u64 != 0 {\n            break;\n        }\n    }\n}", "item_id": 2, "repo": "tiliarou/nx-fatdrive", "file": "src/main.rs", "last_update_at": "2019-06-03T03:09:36+00:00", "question_id": "5e6c54232d0ab5769881565b62e2e5745ca9b290_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn runner() {\n    let mut console = ConsoleHandle::init_default();\n    console.clear();\n    println!(\"Setting up sterr file hooks.\");\n    console.update();\n    let mut error_file = match redirect_stderr(\"nx_fatdrive_sterr.txt\") {\n        Ok(fl) => fl,\n        Err(e) => {\n            println!(\"Error setting stderr output: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    console.update();\n    multprint!(console,error_file,\"Setting up HID context.\");\n    let mut hid_ctx = HidContext::new();\n    let controller = hid_ctx.get_controller(HidControllerID::CONTROLLER_P1_AUTO);\n    multprint!(console,error_file,\"Setting up usb:hs context\");\n    let mut usbhs_ctx = match UsbHsContext::initialize() {\n        Ok(ctx) => ctx, \n        Err(e) => {\n            multprint!(console, error_file, \"Failed setting up usb:hs context: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    let filter : InterfaceFilter = InterfaceFilter::new()\n        .with_interface_class(8)\n        .with_interface_subclass(6)\n        .with_interface_protocol(80);\n    multprint!(console, error_file, \"Waiting for usb event.\");\n    let evt = match InterfaceAvailableEvent::create(true, 0, filter) {\n        Ok(ev) => ev, \n        Err(e) => {\n            multprint!(console, error_file, \"Failed building iface available event: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    if let Err(e) = evt.wait(u64::max_value()) {\n        multprint!(console, error_file, \"Failed waiting for event: {:?}\", e);\n        let delay_start = Instant::now();\n        while delay_start.elapsed() < Duration::from_secs(5) {\n            console.update();\n        }\n        return;\n    }\n    multprint!(console,error_file,\"Looking for usb devices.\");\n    let mut interfaces = match usbhs_ctx.query_available_interfaces(filter, 3) {\n        Ok(ifaces) => ifaces, \n        Err(e) => {\n            multprint!(console, error_file, \"Failed querying available interfaces: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    multprint!(console, error_file, \"Got interfaces: {:?}\", interfaces);\n    let mut iface = match interfaces.pop() {\n        Some(iface) => iface, \n        None => {\n            multprint!(console, error_file, \"Failed finding any matching interfaces.\");\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    multprint!(console, error_file, \"\\nSuccess! Using iface: {:?}\", iface);\n    console.update();\n    let (read_ep, write_ep) = match UsbClient::retrieve_iface_endpoints(&iface) {\n        Ok(p) => p,\n        Err(e) => {\n            multprint!(console, error_file, \"Failed getting eps: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    let mut session = match usbhs_ctx.acquire_interface(&iface) {\n        Ok(s) => s,\n        Err(e) => {\n            multprint!(console, error_file, \"Failed acquiring iface: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    let client = match UsbClient::new(session, read_ep, write_ep) {\n        Ok(c) => c, \n        Err(e) => {\n            multprint!(console, error_file, \"Got error on usbclient::new of {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    multprint!(console,error_file,\"Making SCSI wrapper object.\");\n    console.update();\n    let mut scsi_wrapper = match scsi::scsi::ScsiBlockDevice::new(client, VecNewtype::new(), VecNewtype::new(), VecNewtype::new()) {\n        Ok(c) => c,\n        Err(e) => {\n            multprint!(console, error_file, \"Failed creating SCSI wrapper object: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    multprint!(console,error_file,\"SCSI device found with block size {}.\", scsi_wrapper.block_size());\n    multprint!(console,error_file,\"Trying to get MBR.\");\n    console.update();\n    let mut mbr_buff = VecNewtype::with_fake_capacity(512.max(scsi_wrapper.block_size() as usize));\n    let mut mbr_read_count = 0;\n    while mbr_buff.inner.len() < 512 {\n        multprint!(console, error_file, \"MBR Parse pre-status {}: {}/512.\", mbr_read_count, mbr_buff.inner.len());\n        let _bt = match scsi_wrapper.read(mbr_buff.inner.len() as u32, &mut mbr_buff) {\n            Ok(bt) => {\n                multprint!(console, error_file, \"Got {} bytes on read {}.\", mbr_buff.inner.len(), bt);\n                multprint!(console, error_file, \"Ended with bytes: {:X?}\", mbr_buff.inner);\n                bt\n            }, \n            Err(e) => {\n                multprint!(console, error_file, \"Failed reading MBR on read number {} after already getting {} bytes: {:?}.\", mbr_read_count, mbr_buff.inner.len(), e);\n                multprint!(console, error_file, \"Ended with bytes: {:X?}\", mbr_buff.inner);\n                let delay_start = Instant::now();\n                while delay_start.elapsed() < Duration::from_secs(5) {\n                    console.update();\n                }\n                return;\n            }\n        };\n        mbr_read_count += 1;\n    }\n    multprint!(console,error_file,\"Parsing MBR.\");\n    console.update();\n    let mbr_entry = match mbr_nostd::MasterBootRecord::from_bytes(&mut mbr_buff.inner) {\n        Ok(mbr) => mbr, \n        Err(e) => {\n            multprint!(console, error_file, \"Failed parsing mbr: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    multprint!(console,error_file,\"Partitions:\");\n    for ent in mbr_entry.partition_table_entries() {\n        multprint!(console,error_file,\"    {:?}\", ent);\n    }\n    let first_ent : &PartitionTableEntry = &mbr_entry.partition_table_entries()[0];\n    let raw_offset : usize = (first_ent.logical_block_address * scsi_wrapper.block_size()) as usize; \n    multprint!(console, error_file, \"Creating FATFS wrapper starting at offset block {}, raw {}.\", first_ent.logical_block_address, raw_offset);\n    let mut partition = OffsetScsiDevice::new(scsi_wrapper, raw_offset);\n    let mut fs : fatfs::FileSystem<OffsetScsiDevice> = match fatfs::FileSystem::new(partition, fatfs::FsOptions::new()) {\n        Ok(fs) => fs, \n        Err(e) => {\n            multprint!(console, error_file, \"Error mounting FAT32 file system: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    multprint!(console, error_file, \"Scanning filesystem.\");\n    let mut root_dir = fs.root_dir();\n    let all_dirs = root_dir.iter().filter_map(|ent_res| {\n        match ent_res {\n            Ok(ent) => {\n                multprint!(console, error_file, \"FAT: Found itm. Short name: {}, long name: {}, attr: {:?}\", ent.short_file_name(), ent.file_name(), ent.attributes());\n                Some(ent)\n            },\n            Err(e) => {\n                multprint!(console, error_file, \"Error reading dirent: {:?}\", e);\n                None\n            }\n        }\n    }).collect::<Vec<_>>();\n    multprint!(console, error_file, \"Getting handle to test_folder directory.\");\n    let subdir_opt = all_dirs.iter().find_map(|fl| {\n        if fl.is_dir() && fl.file_name() == \"test_folder\".to_owned() {\n            multprint!(console, error_file,\"FAT: Using existing subdir: Short name: {}, long name: {}, attr: {:?}\", fl.short_file_name(), fl.file_name(), fl.attributes());\n            Some(fl.to_dir())\n        }\n        else {\n            None\n        }\n    });\n    let mut subdir_res = subdir_opt.ok_or(\"Could not find existing subdir.\").or_else(|_| {\n        root_dir.create_dir(\"test_folder\")\n    });\n    let mut subdir = match subdir_res {\n        Ok(s) => s, \n        Err(e) => {\n            multprint!(console, error_file, \"Error getting handle to test_folder: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    let now = Instant::now();\n    let fl_name = format!(\"{:?}.txt\", now).replace(\" \", \"s\").replace(\":\", \"o\").replace(\"{\", \"q\").replace(\"}\", \"p\");\n    multprint!(console, error_file, \"Creating test file {} in the folder.\", fl_name);\n    let mut fl = match subdir.create_file(&fl_name) {\n        Ok(f) => f, \n        Err(e) => {\n            multprint!(console, error_file, \"Error creating test file: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    multprint!(console, error_file,\"Now writing to file.\");\n    if let Err(e) = fl.write_fmt(format_args!(\"Hello world at time {:?}\", now)) {\n        multprint!(console, error_file, \"Error writing to test file: {:?}\", e);\n        let delay_start = Instant::now();\n        while delay_start.elapsed() < Duration::from_secs(5) {\n            console.update();\n        }\n        return;\n    }\n    let next_dir_name = format!(\"{:?}_next_dir\", now).replace(\" \", \"s\").replace(\":\", \"o\").replace(\"{\", \"q\").replace(\"}\", \"p\");\n    multprint!(console, error_file, \"Now trying directory {}.\", next_dir_name);\n    let mut next_dir = match root_dir.create_dir(&next_dir_name) {\n        Ok(s) => s, \n        Err(e) => {\n            multprint!(console, error_file, \"Error getting handle to next_dir: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    let mut outfile = match next_dir.create_file(\"for_seuth.txt\") {\n        Ok(f) => f, \n        Err(e) => {\n            multprint!(console, error_file, \"Error creating for_seuth.txt: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    if let Err(e) = outfile.write(\"To be or not to be and all that jazz!.\".to_owned().into_bytes().as_slice()) {\n        multprint!(console, error_file, \"Error writing to for_seuth.txt: {:?}\", e);\n        let delay_start = Instant::now();\n        while delay_start.elapsed() < Duration::from_secs(5) {\n            console.update();\n        }\n        return;\n    }\n    multprint!(console, error_file, \"Done.\");\n    loop {\n        hid_ctx.scan_input();\n        if controller.keys_down_raw() & HidControllerKeys::KEY_PLUS.0 as u64 != 0 {\n            break;\n        }\n    }\n"]], "pred": {"ppl": 2.0486650466918945, "ppl_lower": 2.186760187149048, "ppl/lowercase_ppl": -1.0909561546466973, "ppl/zlib": 0.0002992024965765407, "Min_5.0% Prob": 7.431545042524151, "Min_10.0% Prob": 5.378617090337417, "Min_20.0% Prob": 3.32040469056251, "Min_30.0% Prob": 2.3506364701620113, "Min_40.0% Prob": 1.7834247208512355, "Min_50.0% Prob": 1.4328636549770424, "Min_60.0% Prob": 1.1959072960408474}}
{"hexsha": "103bb289955d9d19e1c77ea529c987c8fd24466b", "ext": "rs", "lang": "Rust", "content": "fn _left(state: State) -> State {\n    let (s1, s2, s3, s4) = state.coords;\n    let coords = (\n        Coord {\n            x: s1.x - 1,\n            y: s1.y,\n        },\n        Coord {\n            x: s2.x - 1,\n            y: s2.y,\n        },\n        Coord {\n            x: s3.x - 1,\n            y: s3.y,\n        },\n        Coord {\n            x: s4.x - 1,\n            y: s4.y,\n        },\n    );\n    State {\n        coords: coords,\n        position: state.position,\n    }\n}", "item_id": 7, "repo": "patrickgombert/tetris", "file": "src/tetris/piece.rs", "last_update_at": "2019-02-13T22:55:12+00:00", "question_id": "103bb289955d9d19e1c77ea529c987c8fd24466b_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn _left(state: State) -> State {\n    let (s1, s2, s3, s4) = state.coords;\n    let coords = (\n        Coord {\n            x: s1.x - 1,\n            y: s1.y,\n        },\n        Coord {\n            x: s2.x - 1,\n            y: s2.y,\n        },\n        Coord {\n            x: s3.x - 1,\n            y: s3.y,\n        },\n        Coord {\n            x: s4.x - 1,\n            y: s4.y,\n        },\n    );\n    State {\n        coords: coords,\n        position: state.position,\n    }\n"]], "pred": {"ppl": 1.5829601287841797, "ppl_lower": 1.6880362033843994, "ppl/lowercase_ppl": -1.1399297336472973, "ppl/zlib": 0.0028527738724136885, "Min_5.0% Prob": 5.625901116265191, "Min_10.0% Prob": 3.8084005845917597, "Min_20.0% Prob": 2.2242923312717013, "Min_30.0% Prob": 1.521369373121045, "Min_40.0% Prob": 1.1553274263589555, "Min_50.0% Prob": 0.9181766399263364, "Min_60.0% Prob": 0.7681830506343182}}
{"hexsha": "e0e2dc5d343e738004eb2cfde6a1c8daa851ffd6", "ext": "rs", "lang": "Rust", "content": "fn test_trace_estimator() {\n        let n = 1000;\n        let num_random_vecs = 40;\n        let x = Array::random((n, n), StandardNormal).mapv(|e| e as i32 as f32);\n        // want to estimate the trace of x.t().dot(&x)\n        let true_trace = sum_of_squares(x.iter());\n        println!(\"true trace: {}\", true_trace);\n\n        let rand_mat =\n            generate_plus_minus_one_bernoulli_matrix(n, num_random_vecs);\n\n        let trace_est =\n            sum_of_squares(x.dot(&rand_mat).iter()) / num_random_vecs as f64;\n        println!(\"trace_est: {}\", trace_est);\n    }", "item_id": 1, "repo": "sriramlab/saber", "file": "src/bin/estimate_heritability.rs", "last_update_at": "2019-09-05T08:34:59+00:00", "question_id": "e0e2dc5d343e738004eb2cfde6a1c8daa851ffd6_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_trace_estimator() {\n        let n = 1000;\n        let num_random_vecs = 40;\n        let x = Array::random((n, n), StandardNormal).mapv(|e| e as i32 as f32);\n        // want to estimate the trace of x.t().dot(&x)\n        let true_trace = sum_of_squares(x.iter());\n        println!(\"true trace: {}\", true_trace);\n        let rand_mat =\n            generate_plus_minus_one_bernoulli_matrix(n, num_random_vecs);\n        let trace_est =\n            sum_of_squares(x.dot(&rand_mat).iter()) / num_random_vecs as f64;\n        println!(\"trace_est: {}\", trace_est);\n"]], "pred": {"ppl": 3.337522268295288, "ppl_lower": 3.7501819133758545, "ppl/lowercase_ppl": -1.0967249233178338, "ppl/zlib": 0.004243763013565177, "Min_5.0% Prob": 7.766926002502442, "Min_10.0% Prob": 6.269056677818298, "Min_20.0% Prob": 4.622813519835472, "Min_30.0% Prob": 3.5825333813826243, "Min_40.0% Prob": 2.8464790266237143, "Min_50.0% Prob": 2.361308703623196, "Min_60.0% Prob": 2.0030898012775036}}
{"hexsha": "48f231d013221c6e8c0d645a2ded48f68932b7cc", "ext": "rs", "lang": "Rust", "content": "fn parse_int(rem: &mut &str) -> u64 {\n    let end = rem\n        .char_indices()\n        .skip_while(|&(_, c)| c.is_ascii_digit())\n        .map(|(i, _)| i)\n        .next()\n        .unwrap_or(rem.len());\n\n    let int = rem[..end].parse().unwrap();\n    *rem = &rem[end..];\n    int\n}", "item_id": 2, "repo": "agausmann/puzzles", "file": "adventofcode/2020/day18b.rs", "last_update_at": "2019-08-10T12:12:04+00:00", "question_id": "48f231d013221c6e8c0d645a2ded48f68932b7cc_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_int(rem: &mut &str) -> u64 {\n    let end = rem\n        .char_indices()\n        .skip_while(|&(_, c)| c.is_ascii_digit())\n        .map(|(i, _)| i)\n        .next()\n        .unwrap_or(rem.len());\n    let int = rem[..end].parse().unwrap();\n    *rem = &rem[end..];\n    int\n"]], "pred": {"ppl": 1.869079351425171, "ppl_lower": 1.869079351425171, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0034365163966672977, "Min_5.0% Prob": 6.588831806182862, "Min_10.0% Prob": 4.675711111588911, "Min_20.0% Prob": 2.9013622619889, "Min_30.0% Prob": 2.029740107330409, "Min_40.0% Prob": 1.5607681978832593, "Min_50.0% Prob": 1.2586979243227028, "Min_60.0% Prob": 1.0511079384860667}}
{"hexsha": "42a292c6fe6822a497a65fcea755d5270bfc7dbc", "ext": "rs", "lang": "Rust", "content": "fn multiword_to_multiword_synonyms() {\n        let mut store = TempDatabase::from_iter(vec![\n            (\"NY\", &[doc_char_index(0, 0, 0)][..]),\n            (\"subway\", &[doc_char_index(0, 1, 1)][..]),\n            (\"NYC\", &[doc_char_index(1, 0, 0)][..]),\n            (\"blue\", &[doc_char_index(1, 1, 1)][..]),\n            (\"subway\", &[doc_char_index(1, 2, 2)][..]),\n            (\"broken\", &[doc_char_index(1, 3, 3)][..]),\n            (\"new\", &[doc_char_index(2, 0, 0)][..]),\n            (\"york\", &[doc_char_index(2, 1, 1)][..]),\n            (\"underground\", &[doc_char_index(2, 2, 2)][..]),\n            (\"train\", &[doc_char_index(2, 3, 3)][..]),\n            (\"broken\", &[doc_char_index(2, 4, 4)][..]),\n        ]);\n\n        store.add_synonym(\n            \"new york\",\n            SetBuf::from_dirty(vec![\"NYC\", \"NY\", \"new york city\"]),\n        );\n        store.add_synonym(\n            \"new york city\",\n            SetBuf::from_dirty(vec![\"NYC\", \"NY\", \"new york\"]),\n        );\n        store.add_synonym(\"underground train\", SetBuf::from_dirty(vec![\"subway\"]));\n\n        let env = &store.database.env;\n        let reader = env.read_txn().unwrap();\n\n        let builder = store.query_builder();\n        let results = builder\n            .query(&reader, \"new york underground train broken\", 0..20)\n            .unwrap();\n        let mut iter = results.into_iter();\n\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(2), matches, .. }) => {\n            let mut matches = matches.into_iter();\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: false, .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: false, .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // city\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // underground\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // train\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 5, word_index: 5, is_exact: true,  .. })); // broken\n            assert_matches!(matches.next(), None);\n        });\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(1), matches, .. }) => {\n            let mut iter = matches.into_iter();\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NYC = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NYC = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // NYC = city\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 4, is_exact: true,  .. })); // subway = underground\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 5, is_exact: true,  .. })); // subway = train\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 5, word_index: 6, is_exact: true,  .. })); // broken\n            assert_matches!(iter.next(), None);\n        });\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(0), matches, .. }) => {\n            let mut iter = matches.into_iter();\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NY = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NY = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // NY = city\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // subway = underground\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // subway = train\n            assert_matches!(iter.next(), None);\n        });\n        assert_matches!(iter.next(), None);\n\n        let builder = store.query_builder();\n        let results = builder\n            .query(&reader, \"new york city underground train broken\", 0..20)\n            .unwrap();\n        let mut iter = results.into_iter();\n\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(2), matches, .. }) => {\n            let mut matches = matches.into_iter();\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: false, .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: false, .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: false, .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: false, .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: false, .. })); // city\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // underground\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // train\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 5, word_index: 5, is_exact: true,  .. })); // broken\n            assert_matches!(matches.next(), None);\n        });\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(1), matches, .. }) => {\n            let mut iter = matches.into_iter();\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true, .. })); // NYC = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true, .. })); // NYC = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true, .. })); // NYC = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true, .. })); // NYC = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true, .. })); // NYC = city\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 4, is_exact: true, .. })); // subway = underground\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 5, is_exact: true, .. })); // subway = train\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 5, word_index: 6, is_exact: true, .. })); // broken\n            assert_matches!(iter.next(), None);\n        });\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(0), matches, .. }) => {\n            let mut iter = matches.into_iter();\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NY = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NY = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NY = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NY = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // NY = city\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // subway = underground\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // subway = train\n            assert_matches!(iter.next(), None);\n        });\n        assert_matches!(iter.next(), None);\n    }", "item_id": 17, "repo": "bidoubiwa/MeiliDB", "file": "meilidb-core/src/query_builder.rs", "last_update_at": "2019-11-07T16:51:03+00:00", "question_id": "42a292c6fe6822a497a65fcea755d5270bfc7dbc_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn multiword_to_multiword_synonyms() {\n        let mut store = TempDatabase::from_iter(vec![\n            (\"NY\", &[doc_char_index(0, 0, 0)][..]),\n            (\"subway\", &[doc_char_index(0, 1, 1)][..]),\n            (\"NYC\", &[doc_char_index(1, 0, 0)][..]),\n            (\"blue\", &[doc_char_index(1, 1, 1)][..]),\n            (\"subway\", &[doc_char_index(1, 2, 2)][..]),\n            (\"broken\", &[doc_char_index(1, 3, 3)][..]),\n            (\"new\", &[doc_char_index(2, 0, 0)][..]),\n            (\"york\", &[doc_char_index(2, 1, 1)][..]),\n            (\"underground\", &[doc_char_index(2, 2, 2)][..]),\n            (\"train\", &[doc_char_index(2, 3, 3)][..]),\n            (\"broken\", &[doc_char_index(2, 4, 4)][..]),\n        ]);\n        store.add_synonym(\n            \"new york\",\n            SetBuf::from_dirty(vec![\"NYC\", \"NY\", \"new york city\"]),\n        );\n        store.add_synonym(\n            \"new york city\",\n            SetBuf::from_dirty(vec![\"NYC\", \"NY\", \"new york\"]),\n        );\n        store.add_synonym(\"underground train\", SetBuf::from_dirty(vec![\"subway\"]));\n        let env = &store.database.env;\n        let reader = env.read_txn().unwrap();\n        let builder = store.query_builder();\n        let results = builder\n            .query(&reader, \"new york underground train broken\", 0..20)\n            .unwrap();\n        let mut iter = results.into_iter();\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(2), matches, .. }) => {\n            let mut matches = matches.into_iter();\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: false, .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: false, .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // city\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // underground\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // train\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 5, word_index: 5, is_exact: true,  .. })); // broken\n            assert_matches!(matches.next(), None);\n        });\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(1), matches, .. }) => {\n            let mut iter = matches.into_iter();\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NYC = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NYC = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // NYC = city\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 4, is_exact: true,  .. })); // subway = underground\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 5, is_exact: true,  .. })); // subway = train\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 5, word_index: 6, is_exact: true,  .. })); // broken\n            assert_matches!(iter.next(), None);\n        });\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(0), matches, .. }) => {\n            let mut iter = matches.into_iter();\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NY = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NY = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // NY = city\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // subway = underground\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // subway = train\n            assert_matches!(iter.next(), None);\n        });\n        assert_matches!(iter.next(), None);\n        let builder = store.query_builder();\n        let results = builder\n            .query(&reader, \"new york city underground train broken\", 0..20)\n            .unwrap();\n        let mut iter = results.into_iter();\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(2), matches, .. }) => {\n            let mut matches = matches.into_iter();\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: false, .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: false, .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: false, .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: false, .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: false, .. })); // city\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // underground\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // train\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 5, word_index: 5, is_exact: true,  .. })); // broken\n            assert_matches!(matches.next(), None);\n        });\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(1), matches, .. }) => {\n            let mut iter = matches.into_iter();\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true, .. })); // NYC = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true, .. })); // NYC = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true, .. })); // NYC = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true, .. })); // NYC = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true, .. })); // NYC = city\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 4, is_exact: true, .. })); // subway = underground\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 5, is_exact: true, .. })); // subway = train\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 5, word_index: 6, is_exact: true, .. })); // broken\n            assert_matches!(iter.next(), None);\n        });\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(0), matches, .. }) => {\n            let mut iter = matches.into_iter();\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NY = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NY = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NY = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NY = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // NY = city\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // subway = underground\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // subway = train\n            assert_matches!(iter.next(), None);\n        });\n        assert_matches!(iter.next(), None);\n"]], "pred": {"ppl": 1.512941598892212, "ppl_lower": 1.6318755149841309, "ppl/lowercase_ppl": -1.182763132944589, "ppl/zlib": 0.0005294831643462237, "Min_5.0% Prob": 5.157646581238391, "Min_10.0% Prob": 3.4410496482662127, "Min_20.0% Prob": 1.9948575110996472, "Min_30.0% Prob": 1.3734146084125136, "Min_40.0% Prob": 1.0335313194205935, "Min_50.0% Prob": 0.82845806295814, "Min_60.0% Prob": 0.6908784775387383}}
{"hexsha": "e24c2a009f438fb0d893e36b3e90c9d67639c771", "ext": "rs", "lang": "Rust", "content": "pub unsafe fn mailmime_set_epilogue_text(\n    mut build_info: *mut mailmime,\n    mut data_str: *mut libc::c_char,\n    mut length: size_t,\n) -> libc::c_int {\n    let mut data: *mut mailmime_data = 0 as *mut mailmime_data;\n    data = mailmime_data_new(\n        MAILMIME_DATA_TEXT as libc::c_int,\n        MAILMIME_MECHANISM_8BIT as libc::c_int,\n        0i32,\n        data_str,\n        length,\n        0 as *mut libc::c_char,\n    );\n    if data.is_null() {\n        return MAILIMF_ERROR_MEMORY as libc::c_int;\n    }\n    (*build_info).mm_data.mm_multipart.mm_epilogue = data;\n    return MAILIMF_NO_ERROR as libc::c_int;\n}", "item_id": 15, "repo": "KAction/mmime", "file": "src/mailmime_types_helper.rs", "last_update_at": "2019-09-16T15:25:05+00:00", "question_id": "e24c2a009f438fb0d893e36b3e90c9d67639c771_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe fn mailmime_set_epilogue_text(\n    mut build_info: *mut mailmime,\n    mut data_str: *mut libc::c_char,\n    mut length: size_t,\n) -> libc::c_int {\n    let mut data: *mut mailmime_data = 0 as *mut mailmime_data;\n    data = mailmime_data_new(\n        MAILMIME_DATA_TEXT as libc::c_int,\n        MAILMIME_MECHANISM_8BIT as libc::c_int,\n        0i32,\n        data_str,\n        length,\n        0 as *mut libc::c_char,\n    );\n    if data.is_null() {\n        return MAILIMF_ERROR_MEMORY as libc::c_int;\n    }\n    (*build_info).mm_data.mm_multipart.mm_epilogue = data;\n    return MAILIMF_NO_ERROR as libc::c_int;\n"]], "pred": {"ppl": 1.7954699993133545, "ppl_lower": 2.173471212387085, "ppl/lowercase_ppl": -1.3264471731844714, "ppl/zlib": 0.0019907034888578903, "Min_5.0% Prob": 6.6099960009257, "Min_10.0% Prob": 4.511484761238098, "Min_20.0% Prob": 2.749922560710533, "Min_30.0% Prob": 1.9313753545284271, "Min_40.0% Prob": 1.4572938923888348, "Min_50.0% Prob": 1.1736412306360196, "Min_60.0% Prob": 0.975064380957252}}
{"hexsha": "8d5fbe44f15a13bf82e8b3d2c7dd5a9f213e3057", "ext": "rs", "lang": "Rust", "content": "fn get_nugetpkg_version<P: AsRef<Path>>(nuget_path: P) -> String {\n    let version_path = {\n        let mut version_path = nuget_path.as_ref().to_owned();\n        version_path.push(\"VERSION\");\n        version_path\n    };\n    let mut version_file = File::open(version_path)\n                                .expect(\"Failed to open VERSION file\");\n\n    let mut version_string = String::new();\n    version_file.read_to_string(&mut version_string).unwrap();\n\n    version_string\n}", "item_id": 7, "repo": "robmikh/nuget_cpp", "file": "src/main.rs", "last_update_at": "2019-07-29T19:34:48+00:00", "question_id": "8d5fbe44f15a13bf82e8b3d2c7dd5a9f213e3057_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_nugetpkg_version<P: AsRef<Path>>(nuget_path: P) -> String {\n    let version_path = {\n        let mut version_path = nuget_path.as_ref().to_owned();\n        version_path.push(\"VERSION\");\n        version_path\n    };\n    let mut version_file = File::open(version_path)\n                                .expect(\"Failed to open VERSION file\");\n    let mut version_string = String::new();\n    version_file.read_to_string(&mut version_string).unwrap();\n    version_string\n"]], "pred": {"ppl": 1.939847469329834, "ppl_lower": 2.538347005844116, "ppl/lowercase_ppl": -1.405825453266698, "ppl/zlib": 0.0028934905935695063, "Min_5.0% Prob": 6.709336280822754, "Min_10.0% Prob": 4.556978830269405, "Min_20.0% Prob": 2.940153794629233, "Min_30.0% Prob": 2.1276740431785583, "Min_40.0% Prob": 1.6532941508972854, "Min_50.0% Prob": 1.3203084448662896, "Min_60.0% Prob": 1.1085042889489858}}
{"hexsha": "487997dd54a7c4c3dce18928fcf3135a4cfc70d7", "ext": "rs", "lang": "Rust", "content": "fn test_run() {\n    let man = ProcessManager::new();\n    let inner = man.clone();\n    let flag: Arc<RwLock<Option<Vec<u8>>>> = Default::default();\n    let inner_flag = flag.clone();\n\n    thread::spawn(move || {\n        inner.run_process_with_intercept(\n            \"foo\".to_string(),\n            Command::new(\"echo\").arg(\"hello\"),\n            move |ev: ProcessEvent, k: &dyn Fn(ProcessEvent) -> Result<()>| {\n                println!(\"event: {}\", ev);\n                if let ProcessEvent::Output(_handle, bytes, len) = &ev {\n                    if *len > 0 {\n                        *inner_flag.write().unwrap() = Some({\n                            let mut b = bytes.clone();\n                            b.truncate(*len);\n                            b\n                        })\n                    }\n                };\n                k(ev)\n            },\n        )\n    });\n\n    println!(\"running the directory\");\n    man.run_director().expect(\"run_director failed\");\n\n    let mv = flag.read().unwrap();\n    let v = mv.as_ref().unwrap();\n    assert_eq!(&v[..v.len()], \"hello\\n\".as_bytes());\n}", "item_id": 0, "repo": "jwiegley/procman", "file": "tests/simple.rs", "last_update_at": "2019-08-28T14:34:57+00:00", "question_id": "487997dd54a7c4c3dce18928fcf3135a4cfc70d7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_run() {\n    let man = ProcessManager::new();\n    let inner = man.clone();\n    let flag: Arc<RwLock<Option<Vec<u8>>>> = Default::default();\n    let inner_flag = flag.clone();\n    thread::spawn(move || {\n        inner.run_process_with_intercept(\n            \"foo\".to_string(),\n            Command::new(\"echo\").arg(\"hello\"),\n            move |ev: ProcessEvent, k: &dyn Fn(ProcessEvent) -> Result<()>| {\n                println!(\"event: {}\", ev);\n                if let ProcessEvent::Output(_handle, bytes, len) = &ev {\n                    if *len > 0 {\n                        *inner_flag.write().unwrap() = Some({\n                            let mut b = bytes.clone();\n                            b.truncate(*len);\n                            b\n                        })\n                    }\n                };\n                k(ev)\n            },\n        )\n    });\n    println!(\"running the directory\");\n    man.run_director().expect(\"run_director failed\");\n    let mv = flag.read().unwrap();\n    let v = mv.as_ref().unwrap();\n    assert_eq!(&v[..v.len()], \"hello\\n\".as_bytes());\n"]], "pred": {"ppl": 2.8211240768432617, "ppl_lower": 3.4371044635772705, "ppl/lowercase_ppl": -1.1904225563651305, "ppl/zlib": 0.0021166028864006187, "Min_5.0% Prob": 7.985575803120931, "Min_10.0% Prob": 6.031057188587804, "Min_20.0% Prob": 4.240368001044742, "Min_30.0% Prob": 3.231696627875592, "Min_40.0% Prob": 2.5235202161092607, "Min_50.0% Prob": 2.0599120794587833, "Min_60.0% Prob": 1.7236551055241198}}
{"hexsha": "f66bb2399630427c8a60fab70536952f6fd70fe8", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    env_logger::init();\n    let server = Server::http(\"127.0.0.1:1337\").unwrap();\n    let _guard = server.handle(echo);\n    println!(\"Listening on http://127.0.0.1:1337\");\n}", "item_id": 1, "repo": "khvzak/hyper-sync", "file": "examples/server.rs", "last_update_at": "2019-04-22T10:04:57+00:00", "question_id": "f66bb2399630427c8a60fab70536952f6fd70fe8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    env_logger::init();\n    let server = Server::http(\"127.0.0.1:1337\").unwrap();\n    let _guard = server.handle(echo);\n    println!(\"Listening on http://127.0.0.1:1337\");\n"]], "pred": {"ppl": 1.9889776706695557, "ppl_lower": 2.2983310222625732, "ppl/lowercase_ppl": -1.2102357130978336, "ppl/zlib": 0.00480853687691146, "Min_5.0% Prob": 6.548345883687337, "Min_10.0% Prob": 4.778507573263986, "Min_20.0% Prob": 2.9219927827517194, "Min_30.0% Prob": 2.1890883472832767, "Min_40.0% Prob": 1.6948299884796143, "Min_50.0% Prob": 1.369151530493247, "Min_60.0% Prob": 1.1603093989814321}}
{"hexsha": "4b1c925c4ddbff08468c073c2584476e28efd091", "ext": "rs", "lang": "Rust", "content": "pub fn cli_command(arg: &[String]) -> Result<(), UnameError> {\n    let mut buf: utsname = utsname {\n        sysname: [0; 65],\n        nodename: [0; 65],\n        release: [0; 65],\n        version: [0; 65],\n        machine: [0; 65],\n        domainname: [0; 65],\n    };\n\n    unsafe {\n        uname(&mut buf as *mut libc::utsname);\n    };\n\n    let opts = Opts::parse_from(arg);\n\n    if opts.kernel_name\n        || opts.all\n        || (!opts.nodename && !opts.kernel_release && !opts.kernel_version && !opts.machine)\n    {\n        print_c_char(&buf.sysname);\n        print!(\" \");\n    }\n\n    if opts.nodename || opts.all {\n        print_c_char(&buf.nodename);\n        print!(\" \");\n    }\n\n    if opts.kernel_release || opts.all {\n        print_c_char(&buf.release);\n        print!(\" \");\n    }\n\n    if opts.kernel_version || opts.all {\n        print_c_char(&buf.version);\n        print!(\" \");\n    }\n\n    if opts.machine || opts.all {\n        print_c_char(&buf.machine);\n        print!(\" \");\n    }\n\n    println!();\n\n    Ok(())\n}", "item_id": 0, "repo": "rarewin/rust-coreutils", "file": "src/uname.rs", "last_update_at": "2019-10-25T13:17:58+00:00", "question_id": "4b1c925c4ddbff08468c073c2584476e28efd091_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn cli_command(arg: &[String]) -> Result<(), UnameError> {\n    let mut buf: utsname = utsname {\n        sysname: [0; 65],\n        nodename: [0; 65],\n        release: [0; 65],\n        version: [0; 65],\n        machine: [0; 65],\n        domainname: [0; 65],\n    };\n    unsafe {\n        uname(&mut buf as *mut libc::utsname);\n    };\n    let opts = Opts::parse_from(arg);\n    if opts.kernel_name\n        || opts.all\n        || (!opts.nodename && !opts.kernel_release && !opts.kernel_version && !opts.machine)\n    {\n        print_c_char(&buf.sysname);\n        print!(\" \");\n    }\n    if opts.nodename || opts.all {\n        print_c_char(&buf.nodename);\n        print!(\" \");\n    }\n    if opts.kernel_release || opts.all {\n        print_c_char(&buf.release);\n        print!(\" \");\n    }\n    if opts.kernel_version || opts.all {\n        print_c_char(&buf.version);\n        print!(\" \");\n    }\n    if opts.machine || opts.all {\n        print_c_char(&buf.machine);\n        print!(\" \");\n    }\n    println!();\n    Ok(())\n"]], "pred": {"ppl": 1.6338669061660767, "ppl_lower": 1.769505262374878, "ppl/lowercase_ppl": -1.1624412446347288, "ppl/zlib": 0.0014787636757398036, "Min_5.0% Prob": 6.214342567655775, "Min_10.0% Prob": 4.14488301674525, "Min_20.0% Prob": 2.4061859481864505, "Min_30.0% Prob": 1.6299603133710152, "Min_40.0% Prob": 1.230079421831359, "Min_50.0% Prob": 0.9811784574022557, "Min_60.0% Prob": 0.8194608211703172}}
{"hexsha": "3047fd74874230e1c025c791fdfd2f52903a61cc", "ext": "rs", "lang": "Rust", "content": "pub fn lba_to_cls(\n    disk_lba: u64,\n    head_count: u64,\n    sector_count: u64,\n) -> (u8, u8, u8)\n{\n    let mut sector_number = (disk_lba % sector_count) + 1;;\n    let tmp = disk_lba / sector_count;\n    let mut head_number = tmp % head_count;\n    let mut cylinder_number = tmp / head_count;\n\n    if cylinder_number > 0x400 {\n        cylinder_number = 0x3FF;\n        head_number = head_count;\n        sector_number = sector_count;\n    }\n\n    sector_number |= (cylinder_number & 0x300) >> 2;\n    cylinder_number &= 0xFF;\n\n    (head_number as u8, sector_number as u8, cylinder_number as u8)\n}", "item_id": 1, "repo": "tiliarou/KFS", "file": "fs/src/detail/utils.rs", "last_update_at": "2019-07-27T12:48:13+00:00", "question_id": "3047fd74874230e1c025c791fdfd2f52903a61cc_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn lba_to_cls(\n    disk_lba: u64,\n    head_count: u64,\n    sector_count: u64,\n) -> (u8, u8, u8)\n{\n    let mut sector_number = (disk_lba % sector_count) + 1;;\n    let tmp = disk_lba / sector_count;\n    let mut head_number = tmp % head_count;\n    let mut cylinder_number = tmp / head_count;\n    if cylinder_number > 0x400 {\n        cylinder_number = 0x3FF;\n        head_number = head_count;\n        sector_number = sector_count;\n    }\n    sector_number |= (cylinder_number & 0x300) >> 2;\n    cylinder_number &= 0xFF;\n    (head_number as u8, sector_number as u8, cylinder_number as u8)\n"]], "pred": {"ppl": 2.0875277519226074, "ppl_lower": 2.090366840362549, "ppl/lowercase_ppl": -1.0018466526520686, "ppl/zlib": 0.0032279845262661745, "Min_5.0% Prob": 7.551245559345592, "Min_10.0% Prob": 5.225680299427198, "Min_20.0% Prob": 3.285041366485839, "Min_30.0% Prob": 2.357892542657718, "Min_40.0% Prob": 1.8184543785295988, "Min_50.0% Prob": 1.465147072887596, "Min_60.0% Prob": 1.2314469360838263}}
{"hexsha": "6d6ccdb6ad23839ab86b70aa322f7b95e988d44d", "ext": "rs", "lang": "Rust", "content": "fn test_cvc4_qfuflia() {\n        use std::fs;\n        let unparsed_file = fs::read_to_string(\"tests/data/qfuflia.smt2\").expect(\"cannot read file\");\n        let mut q = Query::new();\n        q.parse_query(&unparsed_file).unwrap();\n\n        let sol_cvc4 = q.check_cvc4().expect(\"could not parse\");\n        assert!(q.eval(&sol_cvc4).unwrap());\n    }", "item_id": 0, "repo": "FedericoAureliano/llama", "file": "src/smt/mod.rs", "last_update_at": "2019-12-15T06:32:59+00:00", "question_id": "6d6ccdb6ad23839ab86b70aa322f7b95e988d44d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_cvc4_qfuflia() {\n        use std::fs;\n        let unparsed_file = fs::read_to_string(\"tests/data/qfuflia.smt2\").expect(\"cannot read file\");\n        let mut q = Query::new();\n        q.parse_query(&unparsed_file).unwrap();\n        let sol_cvc4 = q.check_cvc4().expect(\"could not parse\");\n        assert!(q.eval(&sol_cvc4).unwrap());\n"]], "pred": {"ppl": 3.5774166584014893, "ppl_lower": 3.757659435272217, "ppl/lowercase_ppl": -1.03856406571353, "ppl/zlib": 0.006248239883003942, "Min_5.0% Prob": 7.780781904856364, "Min_10.0% Prob": 6.284072240193685, "Min_20.0% Prob": 4.58410117149353, "Min_30.0% Prob": 3.70113590279141, "Min_40.0% Prob": 2.9899584472179415, "Min_50.0% Prob": 2.4788197860831307, "Min_60.0% Prob": 2.1205761019388834}}
{"hexsha": "7b88f28c36d15e7bf13ac1132acc18ea157450c6", "ext": "rs", "lang": "Rust", "content": "pub fn parse(input_string: String) -> ParseTree {\n    let mut tree = NonTerminal::SourceUnit.to_leaf();\n    let current_ptr = &mut 0;\n    let input = &mut input_string.chars().collect::<Vec<char>>();\n    while *current_ptr < input.len() {\n        match lex_4_25::peek_token(input, current_ptr) {\n            lex_4_25::Token::Pragma => {\n                tree.add_tree(parse_pragma_directive(input, current_ptr));\n            }\n            lex_4_25::Token::Import => {\n                tree.add_tree(parse_import_directive(input, current_ptr));\n            }\n            lex_4_25::Token::Contract  |\n            lex_4_25::Token::Library   |\n            lex_4_25::Token::Interface => {\n                tree.add_tree(parse_contract_definition(input, current_ptr));\n            }\n            lex_4_25::Token::EOF => {\n                lex_4_25::next_token(input, current_ptr);\n            }\n            actual => {\n                lex_4_25::next_token(input, current_ptr);\n                tree.root = NonTerminal::SourceUnit.to_invalid_token_pair(actual);\n            }\n        }\n    }\n    tree\n}", "item_id": 0, "repo": "jalextowle/solfix", "file": "src/parse_4_25.rs", "last_update_at": "2019-06-12T10:41:50+00:00", "question_id": "7b88f28c36d15e7bf13ac1132acc18ea157450c6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse(input_string: String) -> ParseTree {\n    let mut tree = NonTerminal::SourceUnit.to_leaf();\n    let current_ptr = &mut 0;\n    let input = &mut input_string.chars().collect::<Vec<char>>();\n    while *current_ptr < input.len() {\n        match lex_4_25::peek_token(input, current_ptr) {\n            lex_4_25::Token::Pragma => {\n                tree.add_tree(parse_pragma_directive(input, current_ptr));\n            }\n            lex_4_25::Token::Import => {\n                tree.add_tree(parse_import_directive(input, current_ptr));\n            }\n            lex_4_25::Token::Contract  |\n            lex_4_25::Token::Library   |\n            lex_4_25::Token::Interface => {\n                tree.add_tree(parse_contract_definition(input, current_ptr));\n            }\n            lex_4_25::Token::EOF => {\n                lex_4_25::next_token(input, current_ptr);\n            }\n            actual => {\n                lex_4_25::next_token(input, current_ptr);\n                tree.root = NonTerminal::SourceUnit.to_invalid_token_pair(actual);\n            }\n        }\n    }\n    tree\n"]], "pred": {"ppl": 2.209397554397583, "ppl_lower": 2.449625015258789, "ppl/lowercase_ppl": -1.1302037227674382, "ppl/zlib": 0.00222674123187494, "Min_5.0% Prob": 7.613928682663861, "Min_10.0% Prob": 5.560142510077533, "Min_20.0% Prob": 3.5731126613476696, "Min_30.0% Prob": 2.573835564594643, "Min_40.0% Prob": 1.971820485065965, "Min_50.0% Prob": 1.5864330487435354, "Min_60.0% Prob": 1.3241744418400248}}
{"hexsha": "183e5b808be51086657173d38d4150c4720d81d0", "ext": "rs", "lang": "Rust", "content": "fn test_div() {\n        let one: ModInt = ModInt::from_value_modulus(\n            BigInt::from(23),\n            BigInt::from(11),\n        );\n\n        let two: ModInt = ModInt::from_value_modulus(\n            BigInt::from(2),\n            BigInt::from(0),\n        );\n\n        let div = one / two;\n        assert_eq!(BigInt::from(6), div.value);\n        assert_eq!(BigInt::from(11), div.modulus);\n\n\n        let one2: ModInt = ModInt::from_value_modulus(\n            BigInt::from(23),\n            BigInt::from(11),\n        );\n        let two2: ModInt = ModInt::from_value_modulus(\n            BigInt::from(2),\n            BigInt::from(0),\n        );\n\n        let zero: ModInt = one2 - ModInt::one();\n        let zero_res: ModInt = zero / two2;\n        assert_eq!(BigInt::from(0), zero_res.value);\n        assert_eq!(BigInt::from(11), zero_res.modulus);\n    }", "item_id": 12, "repo": "provotum/rust-crypto", "file": "src/arithmetic/mod_int.rs", "last_update_at": "2019-03-15T15:46:46+00:00", "question_id": "183e5b808be51086657173d38d4150c4720d81d0_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_div() {\n        let one: ModInt = ModInt::from_value_modulus(\n            BigInt::from(23),\n            BigInt::from(11),\n        );\n        let two: ModInt = ModInt::from_value_modulus(\n            BigInt::from(2),\n            BigInt::from(0),\n        );\n        let div = one / two;\n        assert_eq!(BigInt::from(6), div.value);\n        assert_eq!(BigInt::from(11), div.modulus);\n        let one2: ModInt = ModInt::from_value_modulus(\n            BigInt::from(23),\n            BigInt::from(11),\n        );\n        let two2: ModInt = ModInt::from_value_modulus(\n            BigInt::from(2),\n            BigInt::from(0),\n        );\n        let zero: ModInt = one2 - ModInt::one();\n        let zero_res: ModInt = zero / two2;\n        assert_eq!(BigInt::from(0), zero_res.value);\n        assert_eq!(BigInt::from(11), zero_res.modulus);\n"]], "pred": {"ppl": 1.8079994916915894, "ppl_lower": 1.9027951955795288, "ppl/lowercase_ppl": -1.0862903907156485, "ppl/zlib": 0.002820099908694823, "Min_5.0% Prob": 5.7901076929909845, "Min_10.0% Prob": 4.2869833173422975, "Min_20.0% Prob": 2.7339139272426736, "Min_30.0% Prob": 1.9458452747471031, "Min_40.0% Prob": 1.4798193141368443, "Min_50.0% Prob": 1.1809701033332065, "Min_60.0% Prob": 0.9868532431977136}}
{"hexsha": "2a744d18cddede60664e7d18cf64ed3cb4a32db7", "ext": "rs", "lang": "Rust", "content": "fn eval_pr(expression: &str) -> Result<bool> {\n        let mut map = HashMap::new();\n        map.insert(\n            String::from(\"commits\"),\n            Value::List(vec![\n                Expr::Value(Value::Dictionary(HashMap::new())),\n                Expr::Value(Value::Dictionary(HashMap::new())),\n            ]),\n        );\n        eval(expression, &Value::Dictionary(map))\n    }", "item_id": 2, "repo": "crawford/tailor", "file": "src/expr/mod.rs", "last_update_at": "2019-12-07T22:57:49+00:00", "question_id": "2a744d18cddede60664e7d18cf64ed3cb4a32db7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn eval_pr(expression: &str) -> Result<bool> {\n        let mut map = HashMap::new();\n        map.insert(\n            String::from(\"commits\"),\n            Value::List(vec![\n                Expr::Value(Value::Dictionary(HashMap::new())),\n                Expr::Value(Value::Dictionary(HashMap::new())),\n            ]),\n        );\n        eval(expression, &Value::Dictionary(map))\n"]], "pred": {"ppl": 2.977411985397339, "ppl_lower": 3.6957030296325684, "ppl/lowercase_ppl": -1.1980802490255351, "ppl/zlib": 0.00571232702570826, "Min_5.0% Prob": 9.681040382385254, "Min_10.0% Prob": 7.561798906326294, "Min_20.0% Prob": 4.919845283031464, "Min_30.0% Prob": 3.4868643726072004, "Min_40.0% Prob": 2.7157321459636456, "Min_50.0% Prob": 2.1723975095038233, "Min_60.0% Prob": 1.8272592065435262}}
{"hexsha": "89a4cdc445e3fa9af21cef3c43502fa26f8bcfe9", "ext": "rs", "lang": "Rust", "content": "fn following_sibling_selects_in_document_order() {\n        let package = Package::new();\n        let doc = package.as_document();\n\n        let root = doc.root();\n        let child1 = doc.create_element(\"a\");\n        let child2 = doc.create_comment(\"b\");\n        let child3 = doc.create_processing_instruction(\"c\", None);\n\n        root.append_child(child1);\n        root.append_child(child2);\n        root.append_child(child3);\n\n        let result = execute(FollowingSibling, child1);\n\n        assert_eq!(result, ordered_nodes![child2, child3]);\n    }", "item_id": 7, "repo": "Acidburn0zzz/sxd-xpath", "file": "src/axis.rs", "last_update_at": "2019-02-26T08:49:41+00:00", "question_id": "89a4cdc445e3fa9af21cef3c43502fa26f8bcfe9_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn following_sibling_selects_in_document_order() {\n        let package = Package::new();\n        let doc = package.as_document();\n        let root = doc.root();\n        let child1 = doc.create_element(\"a\");\n        let child2 = doc.create_comment(\"b\");\n        let child3 = doc.create_processing_instruction(\"c\", None);\n        root.append_child(child1);\n        root.append_child(child2);\n        root.append_child(child3);\n        let result = execute(FollowingSibling, child1);\n        assert_eq!(result, ordered_nodes![child2, child3]);\n"]], "pred": {"ppl": 2.506920576095581, "ppl_lower": 2.872040033340454, "ppl/lowercase_ppl": -1.1479426498588114, "ppl/zlib": 0.00369098448923267, "Min_5.0% Prob": 8.427154242992401, "Min_10.0% Prob": 6.241407722234726, "Min_20.0% Prob": 3.9844482306278115, "Min_30.0% Prob": 2.9308675491809844, "Min_40.0% Prob": 2.2643940037311014, "Min_50.0% Prob": 1.827162132421065, "Min_60.0% Prob": 1.540838627833873}}
{"hexsha": "e4e9c39ce892196e7b4e05ec3c4238d0b15599e5", "ext": "rs", "lang": "Rust", "content": "pub fn build_ssh_command_to_instance(\n        instance_id: &str,\n        ip_addr: &IpAddr,\n        login_name: Option<&String>,\n        ssh_opts: &[&str],\n        remote_command_args: &[&str],\n        timeout: Duration,\n    ) -> Result<Command> {\n        let mut ssh_opts: Vec<String> = ssh_opts.iter().map(|&s| s.to_string()).collect();\n        if let Some(login_name) = login_name {\n            ssh_opts.insert(0, \"-l\".to_owned());\n            ssh_opts.insert(1, login_name.to_owned());\n        };\n\n        let mut remote_command_args: Vec<String> = remote_command_args.iter().map(|&s| s.to_string()).collect();\n\n        let ssh_args = build_ssh_arguments(&ip_addr, &mut ssh_opts, &mut remote_command_args);\n\n        let log_path = tempfile::NamedTempFile::new()\n            .chain_err(|| ErrorKind::FailedToBuildSshCommand)?\n            .path()\n            .to_path_buf();\n        let c = Command {\n            id:      instance_id.to_owned(),\n            cmd:     \"ssh\".to_owned(),\n            args:    Some(ssh_args),\n            cwd:     None,\n            log:     log_path,\n            timeout: Some(timeout),\n        };\n        Ok(c)\n    }", "item_id": 5, "repo": "lukaspustina/ceres", "file": "src/utils/mod.rs", "last_update_at": "2019-05-20T08:36:46+00:00", "question_id": "e4e9c39ce892196e7b4e05ec3c4238d0b15599e5_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn build_ssh_command_to_instance(\n        instance_id: &str,\n        ip_addr: &IpAddr,\n        login_name: Option<&String>,\n        ssh_opts: &[&str],\n        remote_command_args: &[&str],\n        timeout: Duration,\n    ) -> Result<Command> {\n        let mut ssh_opts: Vec<String> = ssh_opts.iter().map(|&s| s.to_string()).collect();\n        if let Some(login_name) = login_name {\n            ssh_opts.insert(0, \"-l\".to_owned());\n            ssh_opts.insert(1, login_name.to_owned());\n        };\n        let mut remote_command_args: Vec<String> = remote_command_args.iter().map(|&s| s.to_string()).collect();\n        let ssh_args = build_ssh_arguments(&ip_addr, &mut ssh_opts, &mut remote_command_args);\n        let log_path = tempfile::NamedTempFile::new()\n            .chain_err(|| ErrorKind::FailedToBuildSshCommand)?\n            .path()\n            .to_path_buf();\n        let c = Command {\n            id:      instance_id.to_owned(),\n            cmd:     \"ssh\".to_owned(),\n            args:    Some(ssh_args),\n            cwd:     None,\n            log:     log_path,\n            timeout: Some(timeout),\n        };\n        Ok(c)\n"]], "pred": {"ppl": 2.0920989513397217, "ppl_lower": 2.6323189735412598, "ppl/lowercase_ppl": -1.3111722534163972, "ppl/zlib": 0.0016295095915224208, "Min_5.0% Prob": 6.340433253182305, "Min_10.0% Prob": 4.7708103391859265, "Min_20.0% Prob": 3.184527188947756, "Min_30.0% Prob": 2.3325778608972376, "Min_40.0% Prob": 1.8264240021370861, "Min_50.0% Prob": 1.4756620721942415, "Min_60.0% Prob": 1.2302865378219974}}
{"hexsha": "cf4f3c0e7f482173044e709d3b612eb2d50eea60", "ext": "rs", "lang": "Rust", "content": "fn blockchain_will_not_add_block_with_unacceptable_proof_of_work() {\n        let mut chain = BlockChain::new();\n        let block = Block {\n            block_num: 1,\n            timestamp: util::millis_since_unix_epoch(),\n            nonce: 0,\n            data: String::from(\"hello\"),\n            prev_hash: chain.genesis_hash.clone(),\n        };\n        let hash = block.hash().unwrap();\n        assert!(!is_acceptable_proof_of_work(&hash));\n        let result = chain.add(block);\n        assert!(result.is_err());\n        let err = result.unwrap_err();\n        assert_eq!(err, Error::UnacceptableProofOfWork { hash });\n    }", "item_id": 4, "repo": "dan-f/blockchain", "file": "src/blockchain.rs", "last_update_at": "2019-08-08T00:55:12+00:00", "question_id": "cf4f3c0e7f482173044e709d3b612eb2d50eea60_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn blockchain_will_not_add_block_with_unacceptable_proof_of_work() {\n        let mut chain = BlockChain::new();\n        let block = Block {\n            block_num: 1,\n            timestamp: util::millis_since_unix_epoch(),\n            nonce: 0,\n            data: String::from(\"hello\"),\n            prev_hash: chain.genesis_hash.clone(),\n        };\n        let hash = block.hash().unwrap();\n        assert!(!is_acceptable_proof_of_work(&hash));\n        let result = chain.add(block);\n        assert!(result.is_err());\n        let err = result.unwrap_err();\n        assert_eq!(err, Error::UnacceptableProofOfWork { hash });\n"]], "pred": {"ppl": 2.503108501434326, "ppl_lower": 2.9549083709716797, "ppl/lowercase_ppl": -1.1808482278709176, "ppl/zlib": 0.0029790044157973366, "Min_5.0% Prob": 6.782450887891981, "Min_10.0% Prob": 5.245994713571337, "Min_20.0% Prob": 3.7131267109432735, "Min_30.0% Prob": 2.7931867273790494, "Min_40.0% Prob": 2.226180953351227, "Min_50.0% Prob": 1.815627077253916, "Min_60.0% Prob": 1.52370126409057}}
{"hexsha": "8375521a70210c4c52d2caa4043e490a84754f40", "ext": "rs", "lang": "Rust", "content": "pub fn sync<F, B, E>(spec: FactoryChainSpec<F>, mut block_factory: B, mut extrinsic_factory: E) where\n\tF: ServiceFactory,\n\tF::FullService: Future<Item=(), Error=()>,\n\tF::LightService: Future<Item=(), Error=()>,\n\tB: FnMut(&SyncService<F::FullService>) -> BlockImportParams<F::Block>,\n\tE: FnMut(&SyncService<F::FullService>) -> FactoryExtrinsic<F>,\n{\n\tconst NUM_FULL_NODES: usize = 10;\n\t// FIXME: BABE light client support is currently not working.\n\tconst NUM_LIGHT_NODES: usize = 0;\n\tconst NUM_BLOCKS: usize = 512;\n\tlet temp = TempDir::new(\"substrate-sync-test\").expect(\"Error creating test dir\");\n\tlet mut network = TestNet::<F>::new(\n\t\t&temp,\n\t\tspec.clone(),\n\t\tNUM_FULL_NODES,\n\t\tNUM_LIGHT_NODES,\n\t\tvec![],\n\t\t30500,\n\t);\n\tinfo!(\"Checking block sync\");\n\tlet first_address = {\n\t\tlet first_service = &network.full_nodes[0].1;\n\t\tlet mut client = first_service.get().client();\n\t\tfor i in 0 .. NUM_BLOCKS {\n\t\t\tif i % 128 == 0 {\n\t\t\t\tinfo!(\"Generating #{}\", i);\n\t\t\t}\n\t\t\tlet import_data = block_factory(&first_service);\n\t\t\tclient.import_block(import_data, HashMap::new()).expect(\"Error importing test block\");\n\t\t}\n\t\tnetwork.full_nodes[0].2.clone()\n\t};\n\n\tinfo!(\"Running sync\");\n\tfor (_, service, _) in network.full_nodes.iter().skip(1) {\n\t\tservice.get().network().add_reserved_peer(first_address.to_string()).expect(\"Error adding reserved peer\");\n\t}\n\tfor (_, service, _) in network.light_nodes.iter() {\n\t\tservice.get().network().add_reserved_peer(first_address.to_string()).expect(\"Error adding reserved peer\");\n\t}\n\tnetwork.run_until_all_full(\n\t\t|_index, service|\n\t\t\tservice.get().client().info().chain.best_number == (NUM_BLOCKS as u32).into(),\n\t\t|_index, service|\n\t\t\tservice.get().client().info().chain.best_number == (NUM_BLOCKS as u32).into(),\n\t);\n\n\tinfo!(\"Checking extrinsic propagation\");\n\tlet first_service = network.full_nodes[0].1.clone();\n\tlet best_block = BlockId::number(first_service.get().client().info().chain.best_number);\n\tlet extrinsic = extrinsic_factory(&first_service);\n\tfirst_service.get().transaction_pool().submit_one(&best_block, extrinsic).unwrap();\n\tnetwork.run_until_all_full(\n\t\t|_index, service| service.get().transaction_pool().ready().count() == 1,\n\t\t|_index, _service| true,\n\t);\n}", "item_id": 2, "repo": "HPIPS/HPIPS_Chain", "file": "core/service/test/src/lib.rs", "last_update_at": "2019-08-07T10:22:08+00:00", "question_id": "8375521a70210c4c52d2caa4043e490a84754f40_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn sync<F, B, E>(spec: FactoryChainSpec<F>, mut block_factory: B, mut extrinsic_factory: E) where\n\tF: ServiceFactory,\n\tF::FullService: Future<Item=(), Error=()>,\n\tF::LightService: Future<Item=(), Error=()>,\n\tB: FnMut(&SyncService<F::FullService>) -> BlockImportParams<F::Block>,\n\tE: FnMut(&SyncService<F::FullService>) -> FactoryExtrinsic<F>,\n{\n\tconst NUM_FULL_NODES: usize = 10;\n\t// FIXME: BABE light client support is currently not working.\n\tconst NUM_LIGHT_NODES: usize = 0;\n\tconst NUM_BLOCKS: usize = 512;\n\tlet temp = TempDir::new(\"substrate-sync-test\").expect(\"Error creating test dir\");\n\tlet mut network = TestNet::<F>::new(\n\t\t&temp,\n\t\tspec.clone(),\n\t\tNUM_FULL_NODES,\n\t\tNUM_LIGHT_NODES,\n\t\tvec![],\n\t\t30500,\n\t);\n\tinfo!(\"Checking block sync\");\n\tlet first_address = {\n\t\tlet first_service = &network.full_nodes[0].1;\n\t\tlet mut client = first_service.get().client();\n\t\tfor i in 0 .. NUM_BLOCKS {\n\t\t\tif i % 128 == 0 {\n\t\t\t\tinfo!(\"Generating #{}\", i);\n\t\t\t}\n\t\t\tlet import_data = block_factory(&first_service);\n\t\t\tclient.import_block(import_data, HashMap::new()).expect(\"Error importing test block\");\n\t\t}\n\t\tnetwork.full_nodes[0].2.clone()\n\t};\n\tinfo!(\"Running sync\");\n\tfor (_, service, _) in network.full_nodes.iter().skip(1) {\n\t\tservice.get().network().add_reserved_peer(first_address.to_string()).expect(\"Error adding reserved peer\");\n\t}\n\tfor (_, service, _) in network.light_nodes.iter() {\n\t\tservice.get().network().add_reserved_peer(first_address.to_string()).expect(\"Error adding reserved peer\");\n\t}\n\tnetwork.run_until_all_full(\n\t\t|_index, service|\n\t\t\tservice.get().client().info().chain.best_number == (NUM_BLOCKS as u32).into(),\n\t\t|_index, service|\n\t\t\tservice.get().client().info().chain.best_number == (NUM_BLOCKS as u32).into(),\n\t);\n\tinfo!(\"Checking extrinsic propagation\");\n\tlet first_service = network.full_nodes[0].1.clone();\n\tlet best_block = BlockId::number(first_service.get().client().info().chain.best_number);\n\tlet extrinsic = extrinsic_factory(&first_service);\n\tfirst_service.get().transaction_pool().submit_one(&best_block, extrinsic).unwrap();\n\tnetwork.run_until_all_full(\n\t\t|_index, service| service.get().transaction_pool().ready().count() == 1,\n\t\t|_index, _service| true,\n\t);\n"]], "pred": {"ppl": 2.198598623275757, "ppl_lower": 2.571488380432129, "ppl/lowercase_ppl": -1.1988584527465862, "ppl/zlib": 0.000912885478540213, "Min_5.0% Prob": 6.681941497616652, "Min_10.0% Prob": 5.018986998534784, "Min_20.0% Prob": 3.3468656816133637, "Min_30.0% Prob": 2.4747342080847035, "Min_40.0% Prob": 1.9278487163202378, "Min_50.0% Prob": 1.5668999071430116, "Min_60.0% Prob": 1.3128605522442058}}
{"hexsha": "73afd4d81a04d3d999cd95dbbd4bbb68b04e2778", "ext": "rs", "lang": "Rust", "content": "pub fn test_deserialize_vehicle_status() {\n        let msg_data = test_shared::get_vehicle_status();\n        let encoded:Vec<u8> = msg_data.ser();\n        let decoded = VehicleStatusData::deser(encoded.as_slice()).unwrap();\n        assert_eq!(msg_data.onboard_control_sensors_health, decoded.onboard_control_sensors_health);\n    }", "item_id": 1, "repo": "tstellanova/uorb-codec", "file": "tests/serialization_tests.rs", "last_update_at": "2019-02-24T02:42:58+00:00", "question_id": "73afd4d81a04d3d999cd95dbbd4bbb68b04e2778_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn test_deserialize_vehicle_status() {\n        let msg_data = test_shared::get_vehicle_status();\n        let encoded:Vec<u8> = msg_data.ser();\n        let decoded = VehicleStatusData::deser(encoded.as_slice()).unwrap();\n        assert_eq!(msg_data.onboard_control_sensors_health, decoded.onboard_control_sensors_health);\n"]], "pred": {"ppl": 3.464836359024048, "ppl_lower": 4.166701316833496, "ppl/lowercase_ppl": -1.148438402047015, "ppl/zlib": 0.006865554722064961, "Min_5.0% Prob": 8.843796825408935, "Min_10.0% Prob": 7.307894273237749, "Min_20.0% Prob": 5.169498779556968, "Min_30.0% Prob": 3.90505853024396, "Min_40.0% Prob": 3.070208790627393, "Min_50.0% Prob": 2.463212687256081, "Min_60.0% Prob": 2.0708423931318434}}
{"hexsha": "317cd575022f054f10b312acd977441a6c51fefc", "ext": "rs", "lang": "Rust", "content": "fn dns_san_server() {\n    const MODULE_ID: &str = \"m1\";\n    const GENERATION_ID: &str = \"g1\";\n\n    let (mut service, identity, home_dir, crypto) = init_test(MODULE_ID, GENERATION_ID);\n\n    // start up a simple Echo server using this server cert\n    let port = get_unused_tcp_port();\n    println!(\"Test server listening on port {}\", port);\n    let server = run_echo_server(identity, port);\n    let mut runtime = tokio::runtime::Runtime::new().unwrap();\n    runtime.spawn(server);\n\n    // run a test client that uses the module id for TLS domain name\n    let client1 = run_echo_client(&mut service, port, MODULE_ID);\n    runtime.block_on(client1).unwrap();\n\n    // run a test client that uses the CN for TLS domain name\n    // NOTE: Ideally, this should be a separate test, but there's some global\n    // state in the HSM C library that does not get reset between multiple\n    // tests in the same run and causes the test to fail.\n    let client2 = run_echo_client(&mut service, port, COMMON_NAME);\n    runtime.block_on(client2).unwrap();\n\n    // cleanup\n    crypto\n        .destroy_certificate(IOTEDGED_CA_ALIAS.to_string())\n        .unwrap();\n    home_dir.close().unwrap();\n}", "item_id": 6, "repo": "CIPop/iotedge", "file": "edgelet/edgelet-http-workload/tests/dns-san.rs", "last_update_at": "2019-11-27T22:42:12+00:00", "question_id": "317cd575022f054f10b312acd977441a6c51fefc_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn dns_san_server() {\n    const MODULE_ID: &str = \"m1\";\n    const GENERATION_ID: &str = \"g1\";\n    let (mut service, identity, home_dir, crypto) = init_test(MODULE_ID, GENERATION_ID);\n    // start up a simple Echo server using this server cert\n    let port = get_unused_tcp_port();\n    println!(\"Test server listening on port {}\", port);\n    let server = run_echo_server(identity, port);\n    let mut runtime = tokio::runtime::Runtime::new().unwrap();\n    runtime.spawn(server);\n    // run a test client that uses the module id for TLS domain name\n    let client1 = run_echo_client(&mut service, port, MODULE_ID);\n    runtime.block_on(client1).unwrap();\n    // run a test client that uses the CN for TLS domain name\n    // NOTE: Ideally, this should be a separate test, but there's some global\n    // state in the HSM C library that does not get reset between multiple\n    // tests in the same run and causes the test to fail.\n    let client2 = run_echo_client(&mut service, port, COMMON_NAME);\n    runtime.block_on(client2).unwrap();\n    // cleanup\n    crypto\n        .destroy_certificate(IOTEDGED_CA_ALIAS.to_string())\n        .unwrap();\n    home_dir.close().unwrap();\n"]], "pred": {"ppl": 3.2614874839782715, "ppl_lower": 3.890071153640747, "ppl/lowercase_ppl": -1.1490835329874256, "ppl/zlib": 0.00212241180384543, "Min_5.0% Prob": 7.118349737591213, "Min_10.0% Prob": 6.055273236455144, "Min_20.0% Prob": 4.530881643295288, "Min_30.0% Prob": 3.4952484273484776, "Min_40.0% Prob": 2.82640294380636, "Min_50.0% Prob": 2.3297590678707163, "Min_60.0% Prob": 1.9679696551590626}}
{"hexsha": "e20fb5cff0b8d96462bc1af6489b1709a0e61066", "ext": "rs", "lang": "Rust", "content": "fn for_in() {\n        let mut out = Cursor::new(Vec::new());\n        let mut rt = Runtime::new(Program::empty(), &mut out).unwrap();\n        let stmt = get_stmt(\n            r#\"{\n            a[0] = 5;\n            a[1] = 10;\n            a[2] = 15;\n            a[3] = 20;\n            for (i in a) {\n                a[i] *= 2;\n            }\n        }\"#,\n        );\n        eval_stmt(&stmt, &mut rt).unwrap();\n        assert_eq!(\n            rt.vars.get(\"a\", Some(\"0\")).unwrap(),\n            Value::from(10.0),\n            \"{:?}\",\n            stmt\n        );\n        assert_eq!(\n            rt.vars.get(\"a\", Some(\"1\")).unwrap(),\n            Value::from(20.0),\n            \"{:?}\",\n            stmt\n        );\n        assert_eq!(\n            rt.vars.get(\"a\", Some(\"2\")).unwrap(),\n            Value::from(30.0),\n            \"{:?}\",\n            stmt\n        );\n        assert_eq!(\n            rt.vars.get(\"a\", Some(\"3\")).unwrap(),\n            Value::from(40.0),\n            \"{:?}\",\n            stmt\n        );\n    }", "item_id": 6, "repo": "scampi/falcon", "file": "src/interpreter/stmt.rs", "last_update_at": "2019-12-15T09:53:00+00:00", "question_id": "e20fb5cff0b8d96462bc1af6489b1709a0e61066_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn for_in() {\n        let mut out = Cursor::new(Vec::new());\n        let mut rt = Runtime::new(Program::empty(), &mut out).unwrap();\n        let stmt = get_stmt(\n            r#\"{\n            a[0] = 5;\n            a[1] = 10;\n            a[2] = 15;\n            a[3] = 20;\n            for (i in a) {\n                a[i] *= 2;\n            }\n        }\"#,\n        );\n        eval_stmt(&stmt, &mut rt).unwrap();\n        assert_eq!(\n            rt.vars.get(\"a\", Some(\"0\")).unwrap(),\n            Value::from(10.0),\n            \"{:?}\",\n            stmt\n        );\n        assert_eq!(\n            rt.vars.get(\"a\", Some(\"1\")).unwrap(),\n            Value::from(20.0),\n            \"{:?}\",\n            stmt\n        );\n        assert_eq!(\n            rt.vars.get(\"a\", Some(\"2\")).unwrap(),\n            Value::from(30.0),\n            \"{:?}\",\n            stmt\n        );\n        assert_eq!(\n            rt.vars.get(\"a\", Some(\"3\")).unwrap(),\n            Value::from(40.0),\n            \"{:?}\",\n            stmt\n        );\n"]], "pred": {"ppl": 1.7432801723480225, "ppl_lower": 1.9688507318496704, "ppl/lowercase_ppl": -1.2189427678526932, "ppl/zlib": 0.001963846272334795, "Min_5.0% Prob": 5.927608293645522, "Min_10.0% Prob": 4.285531492794261, "Min_20.0% Prob": 2.612565485870137, "Min_30.0% Prob": 1.8287111365912008, "Min_40.0% Prob": 1.3900315427111791, "Min_50.0% Prob": 1.1102652931967152, "Min_60.0% Prob": 0.9269441508233729}}
{"hexsha": "f2372cd5c8d2fa1010f169daaea859147731d6f4", "ext": "rs", "lang": "Rust", "content": "fn test_pool_serialize_toml() {\n    let config_a = PoolConfig::default();\n\n    let res = config_a.to_toml();\n    assert!(res.is_ok());\n    let toml = res.unwrap();\n\n    let res = PoolConfig::from_toml(&toml);\n    assert!(res.is_ok());\n    let config_b = res.unwrap();\n\n    assert_eq!(config_a, config_b)\n}", "item_id": 2, "repo": "alsacoin/alsacoin", "file": "config/src/pool.rs", "last_update_at": "2019-07-14T22:18:10+00:00", "question_id": "f2372cd5c8d2fa1010f169daaea859147731d6f4_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_pool_serialize_toml() {\n    let config_a = PoolConfig::default();\n    let res = config_a.to_toml();\n    assert!(res.is_ok());\n    let toml = res.unwrap();\n    let res = PoolConfig::from_toml(&toml);\n    assert!(res.is_ok());\n    let config_b = res.unwrap();\n    assert_eq!(config_a, config_b)\n"]], "pred": {"ppl": 2.075124740600586, "ppl_lower": 2.364792585372925, "ppl/lowercase_ppl": -1.1789934818114944, "ppl/zlib": 0.0045626329239241235, "Min_5.0% Prob": 8.30667839050293, "Min_10.0% Prob": 5.657663475383412, "Min_20.0% Prob": 3.3884431503035803, "Min_30.0% Prob": 2.3509338314042374, "Min_40.0% Prob": 1.8268123562137286, "Min_50.0% Prob": 1.4555542095515288, "Min_60.0% Prob": 1.2229083414901705}}
{"hexsha": "44707d76fcae4b9d0b451a68e7256373916d4b9f", "ext": "rs", "lang": "Rust", "content": "fn test_wrap_nodes_with_content_sizing_overflowing_margin() {\n\tlet mut root = Node::new();\n\troot.set_width(StyleUnit::Point(500.0.into()));\n\troot.set_height(StyleUnit::Point(500.0.into()));\n\n\tlet mut root_child0 = Node::new();\n\troot_child0.set_flex_direction(FlexDirection::Row);\n\troot_child0.set_flex_wrap(Wrap::Wrap);\n\troot_child0.set_width(StyleUnit::Point(85.0.into()));\n\troot.insert_child(&mut root_child0, 0);\n\n\tlet mut root_child0_child0 = Node::new();\n\troot_child0.insert_child(&mut root_child0_child0, 0);\n\n\tlet mut root_child0_child0_child0 = Node::new();\n\troot_child0_child0_child0.set_width(StyleUnit::Point(40.0.into()));\n\troot_child0_child0_child0.set_height(StyleUnit::Point(40.0.into()));\n\troot_child0_child0.insert_child(&mut root_child0_child0_child0, 0);\n\n\tlet mut root_child0_child1 = Node::new();\n\troot_child0_child1.set_margin(Edge::Right, StyleUnit::Point(10.0.into()));\n\troot_child0.insert_child(&mut root_child0_child1, 1);\n\n\tlet mut root_child0_child1_child0 = Node::new();\n\troot_child0_child1_child0.set_width(StyleUnit::Point(40.0.into()));\n\troot_child0_child1_child0.set_height(StyleUnit::Point(40.0.into()));\n\troot_child0_child1.insert_child(&mut root_child0_child1_child0, 0);\n\troot.calculate_layout(Undefined, Undefined, Direction::LTR);\n\n\tassert_eq!(0, root.get_layout_left() as i32);\n\tassert_eq!(0, root.get_layout_top() as i32);\n\tassert_eq!(500, root.get_layout_width() as i32);\n\tassert_eq!(500, root.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0.get_layout_top() as i32);\n\tassert_eq!(85, root_child0.get_layout_width() as i32);\n\tassert_eq!(80, root_child0.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child0.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0_child0_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child0_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child0_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child0_child0.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0_child1.get_layout_left() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0_child1_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child1_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child1_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child1_child0.get_layout_height() as i32);\n\n\troot.calculate_layout(Undefined, Undefined, Direction::RTL);\n\n\tassert_eq!(0, root.get_layout_left() as i32);\n\tassert_eq!(0, root.get_layout_top() as i32);\n\tassert_eq!(500, root.get_layout_width() as i32);\n\tassert_eq!(500, root.get_layout_height() as i32);\n\n\tassert_eq!(415, root_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0.get_layout_top() as i32);\n\tassert_eq!(85, root_child0.get_layout_width() as i32);\n\tassert_eq!(80, root_child0.get_layout_height() as i32);\n\n\tassert_eq!(45, root_child0_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child0.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0_child0_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child0_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child0_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child0_child0.get_layout_height() as i32);\n\n\tassert_eq!(35, root_child0_child1.get_layout_left() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0_child1_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child1_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child1_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child1_child0.get_layout_height() as i32);\n}", "item_id": 18, "repo": "mehcode/yoga-rs", "file": "tests/flex_wrap_test.rs", "last_update_at": "2019-04-11T14:07:42+00:00", "question_id": "44707d76fcae4b9d0b451a68e7256373916d4b9f_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_wrap_nodes_with_content_sizing_overflowing_margin() {\n\tlet mut root = Node::new();\n\troot.set_width(StyleUnit::Point(500.0.into()));\n\troot.set_height(StyleUnit::Point(500.0.into()));\n\tlet mut root_child0 = Node::new();\n\troot_child0.set_flex_direction(FlexDirection::Row);\n\troot_child0.set_flex_wrap(Wrap::Wrap);\n\troot_child0.set_width(StyleUnit::Point(85.0.into()));\n\troot.insert_child(&mut root_child0, 0);\n\tlet mut root_child0_child0 = Node::new();\n\troot_child0.insert_child(&mut root_child0_child0, 0);\n\tlet mut root_child0_child0_child0 = Node::new();\n\troot_child0_child0_child0.set_width(StyleUnit::Point(40.0.into()));\n\troot_child0_child0_child0.set_height(StyleUnit::Point(40.0.into()));\n\troot_child0_child0.insert_child(&mut root_child0_child0_child0, 0);\n\tlet mut root_child0_child1 = Node::new();\n\troot_child0_child1.set_margin(Edge::Right, StyleUnit::Point(10.0.into()));\n\troot_child0.insert_child(&mut root_child0_child1, 1);\n\tlet mut root_child0_child1_child0 = Node::new();\n\troot_child0_child1_child0.set_width(StyleUnit::Point(40.0.into()));\n\troot_child0_child1_child0.set_height(StyleUnit::Point(40.0.into()));\n\troot_child0_child1.insert_child(&mut root_child0_child1_child0, 0);\n\troot.calculate_layout(Undefined, Undefined, Direction::LTR);\n\tassert_eq!(0, root.get_layout_left() as i32);\n\tassert_eq!(0, root.get_layout_top() as i32);\n\tassert_eq!(500, root.get_layout_width() as i32);\n\tassert_eq!(500, root.get_layout_height() as i32);\n\tassert_eq!(0, root_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0.get_layout_top() as i32);\n\tassert_eq!(85, root_child0.get_layout_width() as i32);\n\tassert_eq!(80, root_child0.get_layout_height() as i32);\n\tassert_eq!(0, root_child0_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child0.get_layout_height() as i32);\n\tassert_eq!(0, root_child0_child0_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child0_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child0_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child0_child0.get_layout_height() as i32);\n\tassert_eq!(0, root_child0_child1.get_layout_left() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_height() as i32);\n\tassert_eq!(0, root_child0_child1_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child1_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child1_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child1_child0.get_layout_height() as i32);\n\troot.calculate_layout(Undefined, Undefined, Direction::RTL);\n\tassert_eq!(0, root.get_layout_left() as i32);\n\tassert_eq!(0, root.get_layout_top() as i32);\n\tassert_eq!(500, root.get_layout_width() as i32);\n\tassert_eq!(500, root.get_layout_height() as i32);\n\tassert_eq!(415, root_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0.get_layout_top() as i32);\n\tassert_eq!(85, root_child0.get_layout_width() as i32);\n\tassert_eq!(80, root_child0.get_layout_height() as i32);\n\tassert_eq!(45, root_child0_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child0.get_layout_height() as i32);\n\tassert_eq!(0, root_child0_child0_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child0_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child0_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child0_child0.get_layout_height() as i32);\n\tassert_eq!(35, root_child0_child1.get_layout_left() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_height() as i32);\n\tassert_eq!(0, root_child0_child1_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child1_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child1_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child1_child0.get_layout_height() as i32);\n"]], "pred": {"ppl": 1.143591284751892, "ppl_lower": 1.2022173404693604, "ppl/lowercase_ppl": -1.3726074996691262, "ppl/zlib": 0.0002760772850791434, "Min_5.0% Prob": 2.4829567799381183, "Min_10.0% Prob": 1.333072299174234, "Min_20.0% Prob": 0.6723251547983975, "Min_30.0% Prob": 0.44849012056182996, "Min_40.0% Prob": 0.33558420751882195, "Min_50.0% Prob": 0.2686059623854411, "Min_60.0% Prob": 0.22391339864447335}}
{"hexsha": "a76a0e9010de0f7000b8fb8aad7bc8a5990bf20d", "ext": "rs", "lang": "Rust", "content": "fn get() {\n        let mut buf = new(String::from(\"123\"));\n        assert_eq!(buf.get().unwrap(), '1');\n        assert_eq!(buf.get().unwrap(), '2');\n        assert_eq!(buf.get().unwrap(), '3');\n        assert_eq!(buf.get().is_none(), true);\n    }", "item_id": 3, "repo": "gaswelder/che", "file": "src/buf.rs", "last_update_at": "2019-11-17T04:12:08+00:00", "question_id": "a76a0e9010de0f7000b8fb8aad7bc8a5990bf20d_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get() {\n        let mut buf = new(String::from(\"123\"));\n        assert_eq!(buf.get().unwrap(), '1');\n        assert_eq!(buf.get().unwrap(), '2');\n        assert_eq!(buf.get().unwrap(), '3');\n        assert_eq!(buf.get().is_none(), true);\n"]], "pred": {"ppl": 2.341531276702881, "ppl_lower": 2.5764238834381104, "ppl/lowercase_ppl": -1.1123609130094911, "ppl/zlib": 0.007271838522239816, "Min_5.0% Prob": 7.080270290374756, "Min_10.0% Prob": 5.402119696140289, "Min_20.0% Prob": 3.758356489241123, "Min_30.0% Prob": 2.707746396064758, "Min_40.0% Prob": 2.120690979289286, "Min_50.0% Prob": 1.6922230954681123, "Min_60.0% Prob": 1.4269419659487903}}
{"hexsha": "f5319d4e9ef5c4e40c952921c46d11eeb9384e47", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn namei(path: *const u8) -> *mut Inode {\n    check_it(\"namei (1)\");\n    let mut name = [0u8; DIRSIZ];\n    // cprintf(\"namei: namex start\\n\", &[]);\n    let res = namex(path, 0, name.as_mut_ptr());\n    // cprintf(\"namei:  namex end\\n\", &[]);\n    res\n}", "item_id": 18, "repo": "ogiekako/rx6", "file": "kern/src/fs.rs", "last_update_at": "2019-06-20T09:35:01+00:00", "question_id": "f5319d4e9ef5c4e40c952921c46d11eeb9384e47_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn namei(path: *const u8) -> *mut Inode {\n    check_it(\"namei (1)\");\n    let mut name = [0u8; DIRSIZ];\n    // cprintf(\"namei: namex start\\n\", &[]);\n    let res = namex(path, 0, name.as_mut_ptr());\n    // cprintf(\"namei:  namex end\\n\", &[]);\n    res\n"]], "pred": {"ppl": 4.478884696960449, "ppl_lower": 5.104879856109619, "ppl/lowercase_ppl": -1.0872516445884557, "ppl/zlib": 0.008238319032208676, "Min_5.0% Prob": 9.381805610656738, "Min_10.0% Prob": 8.106279763308438, "Min_20.0% Prob": 6.150779702446678, "Min_30.0% Prob": 4.638883902746088, "Min_40.0% Prob": 3.6735800584157308, "Min_50.0% Prob": 2.9617738545986643, "Min_60.0% Prob": 2.4992281006758703}}
{"hexsha": "a8ddd4f503630a268882e3e17ed4c9b7f3befe9e", "ext": "rs", "lang": "Rust", "content": "pub fn init() -> Result<(), SalmiakError> {\n    // Disable UART0\n    unsafe {\n        UART0_CR.write_volatile(0x0);\n    }\n\n    // we want consistent divisor values and\n    // therefore set the clock rate of the UART\n    let res = MailboxPropertyBufferBuilder::new()\n        .set_clock_rate(\n            mailbox::clock::UART,\n            4_000_000, // 4 MHz\n            0,         // skip turbo\n            None,\n        )\n        .submit();\n\n    if !res {\n        return Err(\n            SalmiakErrorKind::InitSerialError(\"Failed to set serial clockrate\".to_owned()).into(),\n        );\n    }\n\n    unsafe {\n        let mut ra = GPFSEL1.read_volatile();\n        ra &= !((7 << 12) | (7 << 15)); //gpio14, gpio15\n        ra |= (4 << 12) | (4 << 15); //alt0\n        GPFSEL1.write_volatile(ra);\n\n        // Disable pull up/down for all GPIO pins and delay for 150 cycles\n        GPPUD.write_volatile(0x0);\n        delay(150);\n\n        // Disable pull up/down for pin 14,15 & delay for 150 cycles.\n        GPPUDCLK0.write_volatile((1 << 14) | (1 << 15));\n        delay(150);\n\n        // Write 0 to GPPUDCLK0 to make it take effect.\n        GPPUDCLK0.write_volatile(0x0);\n\n        // Clear pending interrupts.\n        UART0_ICR.write_volatile(0x7ff);\n\n        // Set integer & fractional part of baud rate.\n        // Divider = UART_CLOCK/(16 * Baud)\n        // Fraction part register = (Fractional part * 64) + 0.5\n        // UART_CLOCK = 3000000; Baud = 115200.\n\n        UART0_IBRD.write_volatile(2);\n        UART0_FBRD.write_volatile(0xb);\n\n        // Enable FIFO & 8 bit data transmissio (1 stop bit, no parity).\n        UART0_LCRH.write_volatile(0b11 << 5);\n\n        // Enable UART0, receive & transfer part of UART.\n        UART0_CR.write_volatile((1) | (1 << 8) | (1 << 9));\n        Ok(())\n    }\n}", "item_id": 0, "repo": "abbec/salmiak", "file": "salmiak/src/serial.rs", "last_update_at": "2019-05-28T20:18:51+00:00", "question_id": "a8ddd4f503630a268882e3e17ed4c9b7f3befe9e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn init() -> Result<(), SalmiakError> {\n    // Disable UART0\n    unsafe {\n        UART0_CR.write_volatile(0x0);\n    }\n    // we want consistent divisor values and\n    // therefore set the clock rate of the UART\n    let res = MailboxPropertyBufferBuilder::new()\n        .set_clock_rate(\n            mailbox::clock::UART,\n            4_000_000, // 4 MHz\n            0,         // skip turbo\n            None,\n        )\n        .submit();\n    if !res {\n        return Err(\n            SalmiakErrorKind::InitSerialError(\"Failed to set serial clockrate\".to_owned()).into(),\n        );\n    }\n    unsafe {\n        let mut ra = GPFSEL1.read_volatile();\n        ra &= !((7 << 12) | (7 << 15)); //gpio14, gpio15\n        ra |= (4 << 12) | (4 << 15); //alt0\n        GPFSEL1.write_volatile(ra);\n        // Disable pull up/down for all GPIO pins and delay for 150 cycles\n        GPPUD.write_volatile(0x0);\n        delay(150);\n        // Disable pull up/down for pin 14,15 & delay for 150 cycles.\n        GPPUDCLK0.write_volatile((1 << 14) | (1 << 15));\n        delay(150);\n        // Write 0 to GPPUDCLK0 to make it take effect.\n        GPPUDCLK0.write_volatile(0x0);\n        // Clear pending interrupts.\n        UART0_ICR.write_volatile(0x7ff);\n        // Set integer & fractional part of baud rate.\n        // Divider = UART_CLOCK/(16 * Baud)\n        // Fraction part register = (Fractional part * 64) + 0.5\n        // UART_CLOCK = 3000000; Baud = 115200.\n        UART0_IBRD.write_volatile(2);\n        UART0_FBRD.write_volatile(0xb);\n        // Enable FIFO & 8 bit data transmissio (1 stop bit, no parity).\n        UART0_LCRH.write_volatile(0b11 << 5);\n        // Enable UART0, receive & transfer part of UART.\n        UART0_CR.write_volatile((1) | (1 << 8) | (1 << 9));\n        Ok(())\n    }\n"]], "pred": {"ppl": 1.9060171842575073, "ppl_lower": 2.2793056964874268, "ppl/lowercase_ppl": -1.27728785961349, "ppl/zlib": 0.0008206308156059037, "Min_5.0% Prob": 7.013263659043745, "Min_10.0% Prob": 4.92860022231714, "Min_20.0% Prob": 3.0472462573158206, "Min_30.0% Prob": 2.1203215480735986, "Min_40.0% Prob": 1.609155045053662, "Min_50.0% Prob": 1.2881371348527002, "Min_60.0% Prob": 1.0755579712250878}}
{"hexsha": "635995e22d6a3512849e9d3b51640804889b1f65", "ext": "rs", "lang": "Rust", "content": "fn write(fmt: DefaultFormat) -> String {\n        let buf = fmt.buf.buf.clone();\n\n        let record = Record::builder()\n            .args(format_args!(\"log message\"))\n            .level(Level::Info)\n            .file(Some(\"test.rs\"))\n            .line(Some(144))\n            .module_path(Some(\"test::path\"))\n            .build();\n\n        fmt.write(&record).expect(\"failed to write record\");\n\n        let buf = buf.borrow();\n        String::from_utf8(buf.bytes().to_vec()).expect(\"failed to read record\")\n    }", "item_id": 0, "repo": "hcpl/env_logger", "file": "src/fmt/mod.rs", "last_update_at": "2019-04-24T23:46:26+00:00", "question_id": "635995e22d6a3512849e9d3b51640804889b1f65_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn write(fmt: DefaultFormat) -> String {\n        let buf = fmt.buf.buf.clone();\n        let record = Record::builder()\n            .args(format_args!(\"log message\"))\n            .level(Level::Info)\n            .file(Some(\"test.rs\"))\n            .line(Some(144))\n            .module_path(Some(\"test::path\"))\n            .build();\n        fmt.write(&record).expect(\"failed to write record\");\n        let buf = buf.borrow();\n        String::from_utf8(buf.bytes().to_vec()).expect(\"failed to read record\")\n"]], "pred": {"ppl": 2.972062587738037, "ppl_lower": 3.8430638313293457, "ppl/lowercase_ppl": -1.2359534320797891, "ppl/zlib": 0.004125970400625036, "Min_5.0% Prob": 8.144025121416364, "Min_10.0% Prob": 5.998061452593122, "Min_20.0% Prob": 4.12308775145432, "Min_30.0% Prob": 3.2205748476765375, "Min_40.0% Prob": 2.636221398741512, "Min_50.0% Prob": 2.1622315212278753, "Min_60.0% Prob": 1.8173513532187162}}
{"hexsha": "889207f29fb47fe1b3a16b4c1b4abbccb6704f1d", "ext": "rs", "lang": "Rust", "content": "fn finish_epoch(\n    storage: &mut Storage,\n    genesis_data: &GenesisData,\n    epoch_writer_state: EpochWriterState,\n    chain_state: &ChainState,\n    is_epoch_with_ebb: bool,\n) -> Result<()> {\n    let epoch_id = epoch_writer_state.epoch_id;\n    let (packhash, index) = pack::packwriter_finalize(&storage.config, epoch_writer_state.writer);\n    let (lookup, tmpfile) = pack::create_index(&storage, &index);\n    tmpfile.render_permanent(&storage.config.get_index_filepath(&packhash))?;\n    storage.add_lookup(packhash, lookup);\n    let epoch_time_elapsed = epoch_writer_state.write_start_time.elapsed().unwrap();\n\n    if epoch_id > 0 {\n        assert!(\n            epoch_exists(&storage.config, epoch_id - 1)?,\n            \"Attempted finish_epoch() with non-existent previous epoch (ID {}, previous' ID {})\",\n            epoch_id,\n            epoch_id - 1\n        );\n    }\n\n    assert_eq!(chain_state.last_date.unwrap().get_epochid(), epoch_id);\n\n    let epoch_flags = EpochFlags {\n        is_ebb: is_epoch_with_ebb,\n    };\n\n    epoch::epoch_create(\n        storage,\n        &packhash,\n        epoch_id,\n        index,\n        Some((chain_state, genesis_data)),\n        &epoch_flags,\n    );\n\n    info!(\n        \"=> pack {} written for epoch {} in {}\",\n        hex::encode(&packhash[..]),\n        epoch_id,\n        duration_print(epoch_time_elapsed)\n    );\n\n    for hash in &epoch_writer_state.blobs_to_delete {\n        debug!(\"removing blob {}\", hash);\n        blob::remove(&storage, &hash.clone().into());\n    }\n\n    let diff = storage\n        .read_block(&types::header_to_blockhash(&chain_state.last_block))?\n        .decode()?\n        .header()\n        .difficulty();\n\n    // Drop this epoch from loose index\n    storage.drop_loose_index_before(diff);\n\n    Ok(())\n}", "item_id": 4, "repo": "Emurgo/rust-cardano", "file": "exe-common/src/sync.rs", "last_update_at": "2019-07-30T11:25:14+00:00", "question_id": "889207f29fb47fe1b3a16b4c1b4abbccb6704f1d_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn finish_epoch(\n    storage: &mut Storage,\n    genesis_data: &GenesisData,\n    epoch_writer_state: EpochWriterState,\n    chain_state: &ChainState,\n    is_epoch_with_ebb: bool,\n) -> Result<()> {\n    let epoch_id = epoch_writer_state.epoch_id;\n    let (packhash, index) = pack::packwriter_finalize(&storage.config, epoch_writer_state.writer);\n    let (lookup, tmpfile) = pack::create_index(&storage, &index);\n    tmpfile.render_permanent(&storage.config.get_index_filepath(&packhash))?;\n    storage.add_lookup(packhash, lookup);\n    let epoch_time_elapsed = epoch_writer_state.write_start_time.elapsed().unwrap();\n    if epoch_id > 0 {\n        assert!(\n            epoch_exists(&storage.config, epoch_id - 1)?,\n            \"Attempted finish_epoch() with non-existent previous epoch (ID {}, previous' ID {})\",\n            epoch_id,\n            epoch_id - 1\n        );\n    }\n    assert_eq!(chain_state.last_date.unwrap().get_epochid(), epoch_id);\n    let epoch_flags = EpochFlags {\n        is_ebb: is_epoch_with_ebb,\n    };\n    epoch::epoch_create(\n        storage,\n        &packhash,\n        epoch_id,\n        index,\n        Some((chain_state, genesis_data)),\n        &epoch_flags,\n    );\n    info!(\n        \"=> pack {} written for epoch {} in {}\",\n        hex::encode(&packhash[..]),\n        epoch_id,\n        duration_print(epoch_time_elapsed)\n    );\n    for hash in &epoch_writer_state.blobs_to_delete {\n        debug!(\"removing blob {}\", hash);\n        blob::remove(&storage, &hash.clone().into());\n    }\n    let diff = storage\n        .read_block(&types::header_to_blockhash(&chain_state.last_block))?\n        .decode()?\n        .header()\n        .difficulty();\n    // Drop this epoch from loose index\n    storage.drop_loose_index_before(diff);\n    Ok(())\n"]], "pred": {"ppl": 3.3117520809173584, "ppl_lower": 3.479365110397339, "ppl/lowercase_ppl": -1.041230389437329, "ppl/zlib": 0.0016471490769267806, "Min_5.0% Prob": 8.089521169662476, "Min_10.0% Prob": 6.393844179312388, "Min_20.0% Prob": 4.657096316417058, "Min_30.0% Prob": 3.6376423272821636, "Min_40.0% Prob": 2.893203890298907, "Min_50.0% Prob": 2.376802235148674, "Min_60.0% Prob": 1.9972651617142303}}
{"hexsha": "5c830e32a8a58663d500f834aa864852764f4773", "ext": "rs", "lang": "Rust", "content": "fn convert_duration_to_string() {\n        assert_eq!(duration_to_string(Duration::milliseconds(1002)), \"0:0:1.2\");\n        assert_eq!(\n            duration_to_string(Duration::milliseconds(65125)),\n            \"0:1:5.125\"\n        );\n        assert_eq!(\n            duration_to_string(Duration::milliseconds(6065125)),\n            \"1:41:5.125\"\n        );\n        assert_eq!(duration_to_string(Duration::seconds(128)), \"0:2:8.0\");\n    }", "item_id": 0, "repo": "CBenoit/media-cutter", "file": "src/lib.rs", "last_update_at": "2019-12-06T05:19:23+00:00", "question_id": "5c830e32a8a58663d500f834aa864852764f4773_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn convert_duration_to_string() {\n        assert_eq!(duration_to_string(Duration::milliseconds(1002)), \"0:0:1.2\");\n        assert_eq!(\n            duration_to_string(Duration::milliseconds(65125)),\n            \"0:1:5.125\"\n        );\n        assert_eq!(\n            duration_to_string(Duration::milliseconds(6065125)),\n            \"1:41:5.125\"\n        );\n        assert_eq!(duration_to_string(Duration::seconds(128)), \"0:2:8.0\");\n"]], "pred": {"ppl": 2.2330451011657715, "ppl_lower": 2.38944411277771, "ppl/lowercase_ppl": -1.0842636675321842, "ppl/zlib": 0.005391719263224516, "Min_5.0% Prob": 6.536349024091448, "Min_10.0% Prob": 4.9427683035532635, "Min_20.0% Prob": 3.499328274880686, "Min_30.0% Prob": 2.5919867132572416, "Min_40.0% Prob": 1.9923442964042937, "Min_50.0% Prob": 1.6035276507793725, "Min_60.0% Prob": 1.3497024254150134}}
{"hexsha": "8adbe438799bd65136cc48972950cd5e0682d8cb", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn say_something(some_string: *const u8, some_len: usize) -> sgx_status_t {\n    let person_slice = unsafe { slice::from_raw_parts(some_string, some_len) };\n\n    let the_one: person::Person = person::Person::decode(person_slice).unwrap();\n    println!(\"name: {}, id: 0x{:08X}, email at: {}\",\n        the_one.name,\n        the_one.id,\n        the_one.email);\n    println!(\"{:?}\", the_one);\n\n    let ts = Timestamp { seconds: 0x1234, nanos: 0x5678 };\n    println!(\"well known types ts = {:?}\", ts);\n\n    sgx_status_t::SGX_SUCCESS\n}", "item_id": 0, "repo": "veracruz-project/incubator-teaclave-sgx-sdk", "file": "samplecode/prost-protobuf/enclave/src/lib.rs", "last_update_at": "2019-10-30T10:05:21+00:00", "question_id": "8adbe438799bd65136cc48972950cd5e0682d8cb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub extern \"C\" fn say_something(some_string: *const u8, some_len: usize) -> sgx_status_t {\n    let person_slice = unsafe { slice::from_raw_parts(some_string, some_len) };\n    let the_one: person::Person = person::Person::decode(person_slice).unwrap();\n    println!(\"name: {}, id: 0x{:08X}, email at: {}\",\n        the_one.name,\n        the_one.id,\n        the_one.email);\n    println!(\"{:?}\", the_one);\n    let ts = Timestamp { seconds: 0x1234, nanos: 0x5678 };\n    println!(\"well known types ts = {:?}\", ts);\n    sgx_status_t::SGX_SUCCESS\n"]], "pred": {"ppl": 3.0000832080841064, "ppl_lower": 3.318852186203003, "ppl/lowercase_ppl": -1.0919127007551974, "ppl/zlib": 0.003578632001014686, "Min_5.0% Prob": 8.962904453277588, "Min_10.0% Prob": 6.806773149967194, "Min_20.0% Prob": 4.585544812679291, "Min_30.0% Prob": 3.401886585305949, "Min_40.0% Prob": 2.6847052441702948, "Min_50.0% Prob": 2.1776396120880164, "Min_60.0% Prob": 1.8323055766828236}}
{"hexsha": "936467b7824d9d53a9506197ec628a29f8a8b998", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let input_file = match env::args().nth(1) {\n        Some(input_file) => input_file,\n        None => {\n            println!(\"Please supply input file!\");\n            std::process::exit(1);\n        }\n    };\n\n    let orbits: Vec<Orbit> = match FileReader::new().split_lines().read_from_file(input_file) {\n        Ok(input) => input,\n        Err(e) => {\n            println!(\"Error reading input: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    let graph = Graph::construct_graph(&orbits);\n    let number_of_orbits = graph.count_orbits();\n    println!(\"Number of orbits: {}\", number_of_orbits);\n\n    let minimal_distance = graph.minimal_distance(\"YOU\", \"SAN\");\n    println!(\"Minimal distance: {}\", minimal_distance - 2);\n}", "item_id": 0, "repo": "df5602/aoc2019", "file": "06-universal-orbit-map/src/main.rs", "last_update_at": "2019-12-03T21:30:12+00:00", "question_id": "936467b7824d9d53a9506197ec628a29f8a8b998_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let input_file = match env::args().nth(1) {\n        Some(input_file) => input_file,\n        None => {\n            println!(\"Please supply input file!\");\n            std::process::exit(1);\n        }\n    };\n    let orbits: Vec<Orbit> = match FileReader::new().split_lines().read_from_file(input_file) {\n        Ok(input) => input,\n        Err(e) => {\n            println!(\"Error reading input: {}\", e);\n            std::process::exit(1);\n        }\n    };\n    let graph = Graph::construct_graph(&orbits);\n    let number_of_orbits = graph.count_orbits();\n    println!(\"Number of orbits: {}\", number_of_orbits);\n    let minimal_distance = graph.minimal_distance(\"YOU\", \"SAN\");\n    println!(\"Minimal distance: {}\", minimal_distance - 2);\n"]], "pred": {"ppl": 1.760628342628479, "ppl_lower": 2.247781276702881, "ppl/lowercase_ppl": -1.4318287072933333, "ppl/zlib": 0.0016686453044047925, "Min_5.0% Prob": 6.2988741831346, "Min_10.0% Prob": 4.186780691146851, "Min_20.0% Prob": 2.561758078958677, "Min_30.0% Prob": 1.8075717274631773, "Min_40.0% Prob": 1.4022624485435025, "Min_50.0% Prob": 1.126412376299755, "Min_60.0% Prob": 0.9442458108932312}}
{"hexsha": "8fe71bc79ab690e4d10c32b6e8d596c010446e03", "ext": "rs", "lang": "Rust", "content": "fn extract_trait_param_type<'a>(\n    sess: &'a ParseSess,\n    trait_ref: &ast::TraitRef,\n) -> PResult<'a, ast::Ty> {\n    assert_eq!(1, trait_ref.path.segments.len());\n    let seg = &trait_ref.path.segments[0];\n    let param = seg\n        .parameters\n        .as_ref()\n        .ok_or_else(|| fatal_error(sess, trait_ref.path.span, \"No type param\"))?;\n    match **param {\n        ast::PathParameters::AngleBracketed(ref p) => {\n            if p.types.len() != 1 {\n                return Err(fatal_error(\n                    sess,\n                    trait_ref.path.span,\n                    \"Expect one type parameter\",\n                ));\n            }\n            let pty: &P<ast::Ty> = &p.types[0];\n            Ok((**pty).clone())\n        }\n        _ => Err(fatal_error(\n            sess,\n            trait_ref.path.span,\n            \"Expect type params in <>\",\n        )),\n    }\n}", "item_id": 4, "repo": "rubdos/rust_swig", "file": "macroslib/src/types_conv_map/parsing.rs", "last_update_at": "2019-04-21T12:35:26+00:00", "question_id": "8fe71bc79ab690e4d10c32b6e8d596c010446e03_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn extract_trait_param_type<'a>(\n    sess: &'a ParseSess,\n    trait_ref: &ast::TraitRef,\n) -> PResult<'a, ast::Ty> {\n    assert_eq!(1, trait_ref.path.segments.len());\n    let seg = &trait_ref.path.segments[0];\n    let param = seg\n        .parameters\n        .as_ref()\n        .ok_or_else(|| fatal_error(sess, trait_ref.path.span, \"No type param\"))?;\n    match **param {\n        ast::PathParameters::AngleBracketed(ref p) => {\n            if p.types.len() != 1 {\n                return Err(fatal_error(\n                    sess,\n                    trait_ref.path.span,\n                    \"Expect one type parameter\",\n                ));\n            }\n            let pty: &P<ast::Ty> = &p.types[0];\n            Ok((**pty).clone())\n        }\n        _ => Err(fatal_error(\n            sess,\n            trait_ref.path.span,\n            \"Expect type params in <>\",\n        )),\n    }\n"]], "pred": {"ppl": 1.8130881786346436, "ppl_lower": 2.372746229171753, "ppl/lowercase_ppl": -1.4521045236328942, "ppl/zlib": 0.0015783330701700181, "Min_5.0% Prob": 5.6812812600816995, "Min_10.0% Prob": 4.20969532276022, "Min_20.0% Prob": 2.773980353412957, "Min_30.0% Prob": 1.9596451538047572, "Min_40.0% Prob": 1.4885993692702775, "Min_50.0% Prob": 1.1933932135234875, "Min_60.0% Prob": 0.9949683451559395}}
{"hexsha": "18137537ca9c54fa3de54068d587a43481df8875", "ext": "rs", "lang": "Rust", "content": "fn read_line() -> String {\n    let mut return_ = format!(\"\");\n    std::io::stdin().read_line(&mut return_).ok();\n    return_\n}", "item_id": 0, "repo": "andraantariksa/code-exercise-answer", "file": "aizuonlinejudge/0101.rs", "last_update_at": "2019-11-06T15:17:48+00:00", "question_id": "18137537ca9c54fa3de54068d587a43481df8875_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_line() -> String {\n    let mut return_ = format!(\"\");\n    std::io::stdin().read_line(&mut return_).ok();\n    return_\n"]], "pred": {"ppl": 1.7883902788162231, "ppl_lower": 2.241870880126953, "ppl/lowercase_ppl": -1.3887641648886102, "ppl/zlib": 0.005813159296752742, "Min_5.0% Prob": 7.550392150878906, "Min_10.0% Prob": 5.71723473072052, "Min_20.0% Prob": 3.0497106928378344, "Min_30.0% Prob": 2.0737349900106588, "Min_40.0% Prob": 1.46858531987185, "Min_50.0% Prob": 1.189829316843922, "Min_60.0% Prob": 0.9997429022705182}}
{"hexsha": "a8d1fde9c77cd0725b89297c76fc56632d95b453", "ext": "rs", "lang": "Rust", "content": "fn test_apply_without_bias() {\n        let weights: Array2<f64> = array![[0.0, 1.0, 0.0], [1.0, 0.0, 1.0]];\n        let input: Array2<f64> = array![[2.0, 5.0], [7.0, 1.0], [4.0, 3.0]];\n        let expected_output: Array2<f64> =\n            array![[5.0, 2.0, 5.0], [1.0, 7.0, 1.0], [3.0, 4.0, 3.0]];\n        let layer: DenseLayer<NdArrayBackend<_>> =\n            DenseLayer::new(String::from(\"layer_1\"), weights, None);\n        let output = layer.apply(input.try_into().unwrap());\n        assert!(output.is_ok());\n        let output: Array2<f64> = output.unwrap().try_into().unwrap();\n        assert_eq!(output, expected_output);\n    }", "item_id": 2, "repo": "andrei-papou/horn", "file": "rust/src/backends/ndarray/tests.rs", "last_update_at": "2019-10-23T12:54:37+00:00", "question_id": "a8d1fde9c77cd0725b89297c76fc56632d95b453_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_apply_without_bias() {\n        let weights: Array2<f64> = array![[0.0, 1.0, 0.0], [1.0, 0.0, 1.0]];\n        let input: Array2<f64> = array![[2.0, 5.0], [7.0, 1.0], [4.0, 3.0]];\n        let expected_output: Array2<f64> =\n            array![[5.0, 2.0, 5.0], [1.0, 7.0, 1.0], [3.0, 4.0, 3.0]];\n        let layer: DenseLayer<NdArrayBackend<_>> =\n            DenseLayer::new(String::from(\"layer_1\"), weights, None);\n        let output = layer.apply(input.try_into().unwrap());\n        assert!(output.is_ok());\n        let output: Array2<f64> = output.unwrap().try_into().unwrap();\n        assert_eq!(output, expected_output);\n"]], "pred": {"ppl": 1.965125322341919, "ppl_lower": 2.281130313873291, "ppl/lowercase_ppl": -1.2207293647332509, "ppl/zlib": 0.002378718382256274, "Min_5.0% Prob": 5.8054767205164985, "Min_10.0% Prob": 4.292115880892827, "Min_20.0% Prob": 2.839408240228329, "Min_30.0% Prob": 2.1291665017604826, "Min_40.0% Prob": 1.6589083365190809, "Min_50.0% Prob": 1.3406596606069092, "Min_60.0% Prob": 1.1285544232930989}}
{"hexsha": "b3de16a792060052320e753a449a25b234163faa", "ext": "rs", "lang": "Rust", "content": "fn test_is_shifted_mask() {\n        assert_eq!(true, is_shifted_mask(8));\n        assert_eq!(true, is_shifted_mask(6));\n        assert_eq!(true, is_shifted_mask(7));\n        assert_eq!(true, is_shifted_mask(3));\n        assert_eq!(true, is_shifted_mask(1));\n        assert_eq!(true, is_shifted_mask(!0));\n\n        assert_eq!(false, is_shifted_mask(0));\n        assert_eq!(false, is_shifted_mask(9));\n        assert_eq!(false, is_shifted_mask(1 << 63 | 1));\n    }", "item_id": 83, "repo": "rodrigo-bruno/dora", "file": "src/cpu/arm64/asm.rs", "last_update_at": "2019-04-21T12:35:18+00:00", "question_id": "b3de16a792060052320e753a449a25b234163faa_83", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_is_shifted_mask() {\n        assert_eq!(true, is_shifted_mask(8));\n        assert_eq!(true, is_shifted_mask(6));\n        assert_eq!(true, is_shifted_mask(7));\n        assert_eq!(true, is_shifted_mask(3));\n        assert_eq!(true, is_shifted_mask(1));\n        assert_eq!(true, is_shifted_mask(!0));\n        assert_eq!(false, is_shifted_mask(0));\n        assert_eq!(false, is_shifted_mask(9));\n        assert_eq!(false, is_shifted_mask(1 << 63 | 1));\n"]], "pred": {"ppl": 1.756551742553711, "ppl_lower": 1.756551742553711, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005029934375436509, "Min_5.0% Prob": 6.4664366245269775, "Min_10.0% Prob": 4.5420658798778755, "Min_20.0% Prob": 2.6907049792153495, "Min_30.0% Prob": 1.882744529356177, "Min_40.0% Prob": 1.4067895786836744, "Min_50.0% Prob": 1.1327681591166934, "Min_60.0% Prob": 0.9388360754836218}}
{"hexsha": "be1d9f4b464389a8dd70f58b26b8dd892ece02e2", "ext": "rs", "lang": "Rust", "content": "fn set_command() {\n    assert_setting!(\"option1\", \"42\", Set(\"option1\".to_string(), Int(42)));\n    assert_setting!(\"option1\", \"12.345\", Set(\"option1\".to_string(), Float(12.345)));\n    assert_setting!(\"option1\", \"false\", Set(\"option1\".to_string(), Bool(false)));\n    assert_setting!(\"option1\", \"true\", Set(\"option1\".to_string(), Bool(true)));\n    assert_setting!(\"option1\", \"value\", Set(\"option1\".to_string(), Str(\"value\".to_string())));\n    assert_setting!(\"option1\", \"value with spaces\", Set(\"option1\".to_string(), Str(\"value with spaces\".to_string())));\n    assert_eq!(parse_string(\"set option1 = 42\\nset option2 = 12.345\"), vec![Set(\"option1\".to_string(), Int(42)), Set(\"option2\".to_string(), Float(12.345))]);\n    assert_eq!(parse_string(\"set option1 = 42\\nset option2 = 12.345\\n\"), vec![Set(\"option1\".to_string(), Int(42)), Set(\"option2\".to_string(), Float(12.345))]);\n    assert_eq!(parse_string(\"set option1 = 42\\n\\nset option2 = 12.345\\n\"), vec![Set(\"option1\".to_string(), Int(42)), Set(\"option2\".to_string(), Float(12.345))]);\n    assert_eq!(parse_string(\"  set    option1    =    42    \"), vec![Set(\"option1\".to_string(), Int(42))]);\n}", "item_id": 7, "repo": "antoyo/mg-settings", "file": "tests/lib.rs", "last_update_at": "2019-02-19T14:30:14+00:00", "question_id": "be1d9f4b464389a8dd70f58b26b8dd892ece02e2_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn set_command() {\n    assert_setting!(\"option1\", \"42\", Set(\"option1\".to_string(), Int(42)));\n    assert_setting!(\"option1\", \"12.345\", Set(\"option1\".to_string(), Float(12.345)));\n    assert_setting!(\"option1\", \"false\", Set(\"option1\".to_string(), Bool(false)));\n    assert_setting!(\"option1\", \"true\", Set(\"option1\".to_string(), Bool(true)));\n    assert_setting!(\"option1\", \"value\", Set(\"option1\".to_string(), Str(\"value\".to_string())));\n    assert_setting!(\"option1\", \"value with spaces\", Set(\"option1\".to_string(), Str(\"value with spaces\".to_string())));\n    assert_eq!(parse_string(\"set option1 = 42\\nset option2 = 12.345\"), vec![Set(\"option1\".to_string(), Int(42)), Set(\"option2\".to_string(), Float(12.345))]);\n    assert_eq!(parse_string(\"set option1 = 42\\nset option2 = 12.345\\n\"), vec![Set(\"option1\".to_string(), Int(42)), Set(\"option2\".to_string(), Float(12.345))]);\n    assert_eq!(parse_string(\"set option1 = 42\\n\\nset option2 = 12.345\\n\"), vec![Set(\"option1\".to_string(), Int(42)), Set(\"option2\".to_string(), Float(12.345))]);\n    assert_eq!(parse_string(\"  set    option1    =    42    \"), vec![Set(\"option1\".to_string(), Int(42))]);\n"]], "pred": {"ppl": 1.547815203666687, "ppl_lower": 1.5594041347503662, "ppl/lowercase_ppl": -1.0170756291864744, "ppl/zlib": 0.0018354806326267938, "Min_5.0% Prob": 5.689290421349662, "Min_10.0% Prob": 3.8235882009778703, "Min_20.0% Prob": 2.124830428817693, "Min_30.0% Prob": 1.4471626751474105, "Min_40.0% Prob": 1.090520037376262, "Min_50.0% Prob": 0.8729587677544174, "Min_60.0% Prob": 0.7301869776383683}}
{"hexsha": "99567ce850ec5f85c9892be34b275a1bd667c349", "ext": "rs", "lang": "Rust", "content": "fn test_inverse() {\n        let perm1 = Permutation::new(0..9).unwrap();\n        let mut perm2 = perm1.clone();\n        perm2.invert();\n        assert_eq!(perm1, perm2);\n\n        let mut perm1 = Permutation::new(vec![3, 0, 1, 2, 4]).unwrap();\n        let mut perm2 = perm1.clone();\n        perm2.invert();\n        perm1.compose_with(&perm2);\n        assert!(perm1.is_identity());\n    }", "item_id": 1, "repo": "k7f/aces", "file": "src/symmetry.rs", "last_update_at": "2019-06-27T21:56:02+00:00", "question_id": "99567ce850ec5f85c9892be34b275a1bd667c349_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_inverse() {\n        let perm1 = Permutation::new(0..9).unwrap();\n        let mut perm2 = perm1.clone();\n        perm2.invert();\n        assert_eq!(perm1, perm2);\n        let mut perm1 = Permutation::new(vec![3, 0, 1, 2, 4]).unwrap();\n        let mut perm2 = perm1.clone();\n        perm2.invert();\n        perm1.compose_with(&perm2);\n        assert!(perm1.is_identity());\n"]], "pred": {"ppl": 2.1314775943756104, "ppl_lower": 2.323920488357544, "ppl/lowercase_ppl": -1.1142156653241118, "ppl/zlib": 0.004349514054586097, "Min_5.0% Prob": 6.79796560605367, "Min_10.0% Prob": 4.8922912157498875, "Min_20.0% Prob": 3.202751636505127, "Min_30.0% Prob": 2.349224831163883, "Min_40.0% Prob": 1.81818892530821, "Min_50.0% Prob": 1.4980783660465211, "Min_60.0% Prob": 1.2537363837990496}}
{"hexsha": "6b663401101c386b1b9edf492dc35440f49edf40", "ext": "rs", "lang": "Rust", "content": "fn parse_rpc_attr(attr: &Attribute) -> Vec<(AttrKey, AttrValue)> {\n    let meta = match attr.parse_meta() {\n        Ok(m) => m,\n        Err(_) => return Vec::new(),\n    };\n\n    if &format!(\"{}\", meta.name()) != \"rpc\" {\n        return Vec::new();\n    }\n\n    match meta {\n        Meta::List(list) => list\n            .nested\n            .iter()\n            .flat_map(|met| match met {\n                NestedMeta::Meta(m) => parse_rpc_attr_meta(m),\n                _ => Vec::new(),\n            })\n            .collect(),\n        _ => Vec::new(),\n    }\n}", "item_id": 0, "repo": "passcod/rpc-impl-macro", "file": "src/lib.rs", "last_update_at": "2019-02-25T06:17:45+00:00", "question_id": "6b663401101c386b1b9edf492dc35440f49edf40_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_rpc_attr(attr: &Attribute) -> Vec<(AttrKey, AttrValue)> {\n    let meta = match attr.parse_meta() {\n        Ok(m) => m,\n        Err(_) => return Vec::new(),\n    };\n    if &format!(\"{}\", meta.name()) != \"rpc\" {\n        return Vec::new();\n    }\n    match meta {\n        Meta::List(list) => list\n            .nested\n            .iter()\n            .flat_map(|met| match met {\n                NestedMeta::Meta(m) => parse_rpc_attr_meta(m),\n                _ => Vec::new(),\n            })\n            .collect(),\n        _ => Vec::new(),\n    }\n"]], "pred": {"ppl": 1.8205803632736206, "ppl_lower": 2.6184582710266113, "ppl/lowercase_ppl": -1.6065711983357098, "ppl/zlib": 0.002269527769608186, "Min_5.0% Prob": 6.909650146961212, "Min_10.0% Prob": 4.569499857285443, "Min_20.0% Prob": 2.8112982596669878, "Min_30.0% Prob": 1.9722833245430353, "Min_40.0% Prob": 1.492746255137551, "Min_50.0% Prob": 1.196529836791536, "Min_60.0% Prob": 1.0056959890545223}}
{"hexsha": "4a1d151e963f3e9b73fe97636c1f3ce2c5443df7", "ext": "rs", "lang": "Rust", "content": "fn it_correctly_detects_no_intersection_for_parallel_lines() {\n            let l1 = WireSegment::new(Point::new(0, 0), Point::new(1, 1));\n            let l2 = WireSegment::new(Point::new(0, 1), Point::new(1, 2));\n            assert_eq!(None, l1.intersection(&l2))\n        }", "item_id": 11, "repo": "jstuczyn/AoC19", "file": "day3/src/main.rs", "last_update_at": "2019-12-02T20:03:22+00:00", "question_id": "4a1d151e963f3e9b73fe97636c1f3ce2c5443df7_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_correctly_detects_no_intersection_for_parallel_lines() {\n            let l1 = WireSegment::new(Point::new(0, 0), Point::new(1, 1));\n            let l2 = WireSegment::new(Point::new(0, 1), Point::new(1, 2));\n            assert_eq!(None, l1.intersection(&l2))\n"]], "pred": {"ppl": 2.426900863647461, "ppl_lower": 2.9258031845092773, "ppl/lowercase_ppl": -1.2108625962523933, "ppl/zlib": 0.005871623037275178, "Min_5.0% Prob": 8.344775104522705, "Min_10.0% Prob": 6.228997230529785, "Min_20.0% Prob": 4.015464115142822, "Min_30.0% Prob": 2.8343350483525183, "Min_40.0% Prob": 2.2149943313220652, "Min_50.0% Prob": 1.7660079033902059, "Min_60.0% Prob": 1.4854880596150555}}
{"hexsha": "02d33f5dbee2c24643a69a08e136740bbaa188d6", "ext": "rs", "lang": "Rust", "content": "fn fails_to_complete_initialization_if_not_waiting_for_it() {\n\t\tlet ml = MessageLoop::new(2).init(0).unwrap();\n\t\tml.0.take_and_process_message();\n\t\tassert_eq!(ml.session_at(0).on_complete_initialization(ml.0.node(1), &message::CompleteInitialization {\n\t\t\tsession: Default::default(),\n\t\t\tsession_nonce: 0,\n\t\t\tderived_point: math::generate_random_point().unwrap().into(),\n\t\t}), Err(Error::InvalidStateForRequest));\n\t}", "item_id": 6, "repo": "altice-io/Daqiao", "file": "bridge/parity-ethereum/secret-store/src/key_server_cluster/client_sessions/generation_session.rs", "last_update_at": "2019-09-11T12:07:35+00:00", "question_id": "02d33f5dbee2c24643a69a08e136740bbaa188d6_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn fails_to_complete_initialization_if_not_waiting_for_it() {\n\t\tlet ml = MessageLoop::new(2).init(0).unwrap();\n\t\tml.0.take_and_process_message();\n\t\tassert_eq!(ml.session_at(0).on_complete_initialization(ml.0.node(1), &message::CompleteInitialization {\n\t\t\tsession: Default::default(),\n\t\t\tsession_nonce: 0,\n\t\t\tderived_point: math::generate_random_point().unwrap().into(),\n\t\t}), Err(Error::InvalidStateForRequest));\n"]], "pred": {"ppl": 7.406344413757324, "ppl_lower": 9.39451789855957, "ppl/lowercase_ppl": -1.1187558999376936, "ppl/zlib": 0.007555988626804686, "Min_5.0% Prob": 10.284083366394043, "Min_10.0% Prob": 8.7066343943278, "Min_20.0% Prob": 6.718194135030111, "Min_30.0% Prob": 5.492846949895223, "Min_40.0% Prob": 4.545662700152788, "Min_50.0% Prob": 3.856148081390481, "Min_60.0% Prob": 3.3136448627644843}}
{"hexsha": "55fd51ac5eb0db8c567c311373a2941b8af58c04", "ext": "rs", "lang": "Rust", "content": "fn test_cross_at_point() {\r\n    let ind1 = Ind(vec!(0xF, 0xF, 0xF, 0xF, 0xF));\r\n    let ind2 = Ind(vec!(0x0, 0x0, 0x0, 0x0, 0x0));\r\n    let mut pair = [ind1, ind2];\r\n\r\n    cross_at_point(&mut pair, 4, 10);\r\n    assert!(pair[0] == Ind(vec!(0, 0, 3, 0xF, 0xF)));\r\n    assert!(pair[1] == Ind(vec!(0xF, 0xF, 0xC, 0x0, 0x0)));\r\n}", "item_id": 2, "repo": "nsmryan/rgep", "file": "src/crossover.rs", "last_update_at": "2019-04-12T16:06:04+00:00", "question_id": "55fd51ac5eb0db8c567c311373a2941b8af58c04_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_cross_at_point() {\r\n    let ind1 = Ind(vec!(0xF, 0xF, 0xF, 0xF, 0xF));\r\n    let ind2 = Ind(vec!(0x0, 0x0, 0x0, 0x0, 0x0));\r\n    let mut pair = [ind1, ind2];\r\n\r\n    cross_at_point(&mut pair, 4, 10);\r\n    assert!(pair[0] == Ind(vec!(0, 0, 3, 0xF, 0xF)));\r\n    assert!(pair[1] == Ind(vec!(0xF, 0xF, 0xC, 0x0, 0x0)));\r\n"]], "pred": {"ppl": 2.3425443172454834, "ppl_lower": 2.413635015487671, "ppl/lowercase_ppl": -1.0351209353467847, "ppl/zlib": 0.005491855830534873, "Min_5.0% Prob": 7.9966337945726185, "Min_10.0% Prob": 6.095764848921034, "Min_20.0% Prob": 3.8432877224844857, "Min_30.0% Prob": 2.7484720479358327, "Min_40.0% Prob": 2.0985703061561325, "Min_50.0% Prob": 1.689624517675369, "Min_60.0% Prob": 1.4231783367089323}}
{"hexsha": "a68a9b4e66ec30f339f46729943cc9414da5a1f2", "ext": "rs", "lang": "Rust", "content": "fn parse_instructions(input: &str) -> (Vec<Step>, BTreeMap<Step, Vec<Step>>) {\n    let matcher = Regex::new(\"Step (.) must be finished before step (.) can begin.\").unwrap();\n    let mut instruction_map = BTreeMap::new();\n\n    matcher.captures_iter(input).for_each(|capture| {\n        let prerequisite = capture[1].chars().next().unwrap();\n        let step = capture[2].chars().next().unwrap();\n\n        let entry = instruction_map.entry(step).or_insert_with(Vec::new);\n\n        entry.push(prerequisite);\n\n        instruction_map.entry(prerequisite).or_insert_with(Vec::new);\n    });\n\n    let all_steps = instruction_map.keys().cloned().collect::<Vec<char>>();\n\n    (all_steps, instruction_map)\n}", "item_id": 0, "repo": "mEEksIsu/rust-aoc-2018", "file": "src/days/day7.rs", "last_update_at": "2019-05-23T15:47:24+00:00", "question_id": "a68a9b4e66ec30f339f46729943cc9414da5a1f2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_instructions(input: &str) -> (Vec<Step>, BTreeMap<Step, Vec<Step>>) {\n    let matcher = Regex::new(\"Step (.) must be finished before step (.) can begin.\").unwrap();\n    let mut instruction_map = BTreeMap::new();\n    matcher.captures_iter(input).for_each(|capture| {\n        let prerequisite = capture[1].chars().next().unwrap();\n        let step = capture[2].chars().next().unwrap();\n        let entry = instruction_map.entry(step).or_insert_with(Vec::new);\n        entry.push(prerequisite);\n        instruction_map.entry(prerequisite).or_insert_with(Vec::new);\n    });\n    let all_steps = instruction_map.keys().cloned().collect::<Vec<char>>();\n    (all_steps, instruction_map)\n"]], "pred": {"ppl": 1.7508964538574219, "ppl_lower": 2.0157523155212402, "ppl/lowercase_ppl": -1.251486425010696, "ppl/zlib": 0.0017287898645755913, "Min_5.0% Prob": 6.27400016784668, "Min_10.0% Prob": 4.373104214668274, "Min_20.0% Prob": 2.617923272980584, "Min_30.0% Prob": 1.8329436445937437, "Min_40.0% Prob": 1.3924996900771345, "Min_50.0% Prob": 1.1179367095526112, "Min_60.0% Prob": 0.9384852783370983}}
{"hexsha": "eaa111470141c108d7893ca634be26134ec228b4", "ext": "rs", "lang": "Rust", "content": "fn bind_client<C: ClientState, T: AsyncRead + AsyncWrite>(\n    io: T,\n) -> (\n    impl Sink<SinkItem = C::Send, SinkError = ()>,\n    impl Stream<Item = C::Receive, Error = Error>,\n) {\n    let (raw_sender, raw_receiver) = bind_transport(io);\n    let sender = raw_sender\n        .with(|msg| serialize_message(&msg))\n        .sink_map_err(|_| ());\n    let receiver = raw_receiver.and_then(parse_message::<C::Receive>);\n    (sender, receiver)\n}", "item_id": 0, "repo": "kphelps/akio", "file": "akio-net/src/protocol.rs", "last_update_at": "2019-01-06T23:05:12+00:00", "question_id": "eaa111470141c108d7893ca634be26134ec228b4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bind_client<C: ClientState, T: AsyncRead + AsyncWrite>(\n    io: T,\n) -> (\n    impl Sink<SinkItem = C::Send, SinkError = ()>,\n    impl Stream<Item = C::Receive, Error = Error>,\n) {\n    let (raw_sender, raw_receiver) = bind_transport(io);\n    let sender = raw_sender\n        .with(|msg| serialize_message(&msg))\n        .sink_map_err(|_| ());\n    let receiver = raw_receiver.and_then(parse_message::<C::Receive>);\n    (sender, receiver)\n"]], "pred": {"ppl": 2.518742084503174, "ppl_lower": 3.4079861640930176, "ppl/lowercase_ppl": -1.327316699835074, "ppl/zlib": 0.0036512237315371745, "Min_5.0% Prob": 7.013575077056885, "Min_10.0% Prob": 5.343969821929932, "Min_20.0% Prob": 3.8160987774531048, "Min_30.0% Prob": 2.8893178442250127, "Min_40.0% Prob": 2.2824863427486575, "Min_50.0% Prob": 1.8351059328619537, "Min_60.0% Prob": 1.5430742517599594}}
{"hexsha": "e2f89e943d304541c8ccd8a980ecf9d1ce9c654c", "ext": "rs", "lang": "Rust", "content": "fn update_velocities_1d(moons: &mut Vec<&mut Moon1D>) {\n    let mut moons_clone: Vec<Moon1D> = vec![];\n\n    for moon in moons.iter() {\n        moons_clone.push(**moon.clone());\n    }\n\n    for moon_update in moons.iter_mut() {\n        for moon in moons_clone.iter() {\n            moon_update.update_velocity(*moon);\n        }\n    }\n}", "item_id": 4, "repo": "gentoid/aoc-2019-rust", "file": "src/aoc_12.rs", "last_update_at": "2019-12-06T13:12:12+00:00", "question_id": "e2f89e943d304541c8ccd8a980ecf9d1ce9c654c_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn update_velocities_1d(moons: &mut Vec<&mut Moon1D>) {\n    let mut moons_clone: Vec<Moon1D> = vec![];\n    for moon in moons.iter() {\n        moons_clone.push(**moon.clone());\n    }\n    for moon_update in moons.iter_mut() {\n        for moon in moons_clone.iter() {\n            moon_update.update_velocity(*moon);\n        }\n    }\n"]], "pred": {"ppl": 2.3676276206970215, "ppl_lower": 2.7222537994384766, "ppl/lowercase_ppl": -1.16193706978808, "ppl/zlib": 0.005010979359783219, "Min_5.0% Prob": 7.678849935531616, "Min_10.0% Prob": 5.757856667041779, "Min_20.0% Prob": 3.809359784126282, "Min_30.0% Prob": 2.779524316658845, "Min_40.0% Prob": 2.120235260725021, "Min_50.0% Prob": 1.7282469586258935, "Min_60.0% Prob": 1.4349183673287431}}
{"hexsha": "e9709670122c32fae206b2a80ebfa4321dfcdf7b", "ext": "rs", "lang": "Rust", "content": "pub fn render_chars_entity_references_to_chars(\n    text: &Vec<char>,\n    entities: &Vec<&DecodedEntity>,\n) -> Vec<char> {\n    let mut my_entities: Vec<&DecodedEntity> = Vec::with_capacity(entities.len());\n    for e in entities {\n        my_entities.push(e);\n    }\n    my_entities.sort_unstable();\n\n    let mut sb: Vec<char> = Vec::with_capacity(text.len() * 2);\n    let mut pos = 0 as usize;\n    my_entities.iter().for_each(|entity| {\n        sb.extend_from_slice(&text[pos..entity.start]);\n        sb.extend_from_slice(&entity.html);\n        pos = entity.end;\n    });\n    sb.extend_from_slice(&text[pos..text.len()]);\n    sb\n}", "item_id": 4, "repo": "spullara/interviewcode", "file": "rust/unicode_test/src/lib.rs", "last_update_at": "2019-11-13T17:40:28+00:00", "question_id": "e9709670122c32fae206b2a80ebfa4321dfcdf7b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn render_chars_entity_references_to_chars(\n    text: &Vec<char>,\n    entities: &Vec<&DecodedEntity>,\n) -> Vec<char> {\n    let mut my_entities: Vec<&DecodedEntity> = Vec::with_capacity(entities.len());\n    for e in entities {\n        my_entities.push(e);\n    }\n    my_entities.sort_unstable();\n    let mut sb: Vec<char> = Vec::with_capacity(text.len() * 2);\n    let mut pos = 0 as usize;\n    my_entities.iter().for_each(|entity| {\n        sb.extend_from_slice(&text[pos..entity.start]);\n        sb.extend_from_slice(&entity.html);\n        pos = entity.end;\n    });\n    sb.extend_from_slice(&text[pos..text.len()]);\n    sb\n"]], "pred": {"ppl": 2.1486480236053467, "ppl_lower": 2.409263849258423, "ppl/lowercase_ppl": -1.1496817672887478, "ppl/zlib": 0.002674261601801969, "Min_5.0% Prob": 8.064385804263027, "Min_10.0% Prob": 5.590853027675463, "Min_20.0% Prob": 3.479075794634612, "Min_30.0% Prob": 2.4664326284242715, "Min_40.0% Prob": 1.8915034301740967, "Min_50.0% Prob": 1.5249371595194807, "Min_60.0% Prob": 1.2732893394819205}}
{"hexsha": "debb9911930aebf69268ceb52a490f921caa45cf", "ext": "rs", "lang": "Rust", "content": "fn ansi_rgb_colors() {\n        use super::ColorExt;\n        assert_eq!(Color::Rgb(0x12, 0x89, 0xef).to_rgb(), (0x12, 0x89, 0xef));\n        assert_eq!(Color::Rgb(0xff, 0xff, 0xff).to_rgb(), (0xff, 0xff, 0xff));\n        assert_eq!(Color::Rgb(0, 0, 0).to_rgb(), (0, 0, 0));\n    }", "item_id": 1, "repo": "rhysd/termcolor2rgb", "file": "src/lib.rs", "last_update_at": "2019-01-12T12:37:16+00:00", "question_id": "debb9911930aebf69268ceb52a490f921caa45cf_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn ansi_rgb_colors() {\n        use super::ColorExt;\n        assert_eq!(Color::Rgb(0x12, 0x89, 0xef).to_rgb(), (0x12, 0x89, 0xef));\n        assert_eq!(Color::Rgb(0xff, 0xff, 0xff).to_rgb(), (0xff, 0xff, 0xff));\n        assert_eq!(Color::Rgb(0, 0, 0).to_rgb(), (0, 0, 0));\n"]], "pred": {"ppl": 1.9034919738769531, "ppl_lower": 2.138267993927002, "ppl/lowercase_ppl": -1.1806864451292258, "ppl/zlib": 0.0051910490348668495, "Min_5.0% Prob": 7.012448276792254, "Min_10.0% Prob": 4.888569678579058, "Min_20.0% Prob": 3.102702349424362, "Min_30.0% Prob": 2.1272682078009426, "Min_40.0% Prob": 1.618727051571273, "Min_50.0% Prob": 1.2851316967668633, "Min_60.0% Prob": 1.0771829900223502}}
{"hexsha": "a4d9a79eb9bbafb3fe8f46e3f83c8a2712f51b1b", "ext": "rs", "lang": "Rust", "content": "fn test_game_id() {\n        assert_parsed!(\n            Event::GameId {\n                id: \"CHN201604110\".into()\n            },\n            game_id(\"id,CHN201604110\")\n        );\n        assert!(game_id(\"asdlfk,3,5\").is_err());\n        assert!(game_id(\"id,3455\").is_err());\n    }", "item_id": 33, "repo": "eugene-bulkin/retrosheet-rs", "file": "src/parsers.rs", "last_update_at": "2019-11-27T04:32:55+00:00", "question_id": "a4d9a79eb9bbafb3fe8f46e3f83c8a2712f51b1b_33", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_game_id() {\n        assert_parsed!(\n            Event::GameId {\n                id: \"CHN201604110\".into()\n            },\n            game_id(\"id,CHN201604110\")\n        );\n        assert!(game_id(\"asdlfk,3,5\").is_err());\n        assert!(game_id(\"id,3455\").is_err());\n"]], "pred": {"ppl": 5.063754081726074, "ppl_lower": 6.251357555389404, "ppl/lowercase_ppl": -1.1298868581052297, "ppl/zlib": 0.011110329600015671, "Min_5.0% Prob": 8.703050708770752, "Min_10.0% Prob": 7.574603861028498, "Min_20.0% Prob": 5.975687883116982, "Min_30.0% Prob": 4.635532758452675, "Min_40.0% Prob": 3.788168965415521, "Min_50.0% Prob": 3.1694709105925125, "Min_60.0% Prob": 2.690995671758146}}
{"hexsha": "ff59c7ea7617a563fc51b5b5692cc80137be391a", "ext": "rs", "lang": "Rust", "content": "fn test_function() {\n        let s = to_chars(\"function\");\n        let cur = &mut 0;\n        expect_next_token(&s, cur, Token::Function);\n    }", "item_id": 89, "repo": "jalextowle/solfix", "file": "src/lex_4_25.rs", "last_update_at": "2019-06-12T10:41:50+00:00", "question_id": "ff59c7ea7617a563fc51b5b5692cc80137be391a_89", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_function() {\n        let s = to_chars(\"function\");\n        let cur = &mut 0;\n        expect_next_token(&s, cur, Token::Function);\n"]], "pred": {"ppl": 6.286260604858398, "ppl_lower": 7.7898430824279785, "ppl/lowercase_ppl": -1.1166548307494455, "ppl/zlib": 0.017508251385670477, "Min_5.0% Prob": 9.251906394958496, "Min_10.0% Prob": 8.365698099136353, "Min_20.0% Prob": 6.434344662560357, "Min_30.0% Prob": 5.017948303903852, "Min_40.0% Prob": 4.215083671940698, "Min_50.0% Prob": 3.5125476899354355, "Min_60.0% Prob": 2.9885770412428037}}
{"hexsha": "e62d4bad820b2b50b02221c0ab525295304277f4", "ext": "rs", "lang": "Rust", "content": "fn test_message() {\n    test_text_format_str_descriptor(\"test_message_singular {}\", TestTypes::descriptor_static());\n\n    test_text_format_str_descriptor(\n        \"test_message_singular { value: 10 }\",\n        TestTypes::descriptor_static(),\n    );\n\n    test_text_format_str_descriptor(\n        \"test_message_repeated { value: 10 } test_message_repeated { value: 20 }\",\n        TestTypes::descriptor_static(),\n    );\n}", "item_id": 7, "repo": "comiclee/rust-protobuf", "file": "protobuf-test/src/common/v2/test_fmt_text_format.rs", "last_update_at": "2019-05-20T14:11:28+00:00", "question_id": "e62d4bad820b2b50b02221c0ab525295304277f4_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_message() {\n    test_text_format_str_descriptor(\"test_message_singular {}\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\n        \"test_message_singular { value: 10 }\",\n        TestTypes::descriptor_static(),\n    );\n    test_text_format_str_descriptor(\n        \"test_message_repeated { value: 10 } test_message_repeated { value: 20 }\",\n        TestTypes::descriptor_static(),\n    );\n"]], "pred": {"ppl": 2.425020456314087, "ppl_lower": 2.7065320014953613, "ppl/lowercase_ppl": -1.1239819336947372, "ppl/zlib": 0.006026122176512279, "Min_5.0% Prob": 7.371942179543631, "Min_10.0% Prob": 6.138148512159075, "Min_20.0% Prob": 4.087545233113425, "Min_30.0% Prob": 2.889417645122324, "Min_40.0% Prob": 2.196472765877843, "Min_50.0% Prob": 1.7666875211521984, "Min_60.0% Prob": 1.4749931856723768}}
{"hexsha": "c7b80c42c1baa657e4f99df074114b163190f538", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // Make sure codegen can emit all the intrinsics correctly\n    ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, Acquire, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, Release, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, AcqRel, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, Acquire, Acquire).ok();\n    ATOMIC.compare_exchange(0, 1, AcqRel, Acquire).ok();\n    ATOMIC.compare_exchange(0, 1, SeqCst, Acquire).ok();\n    ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Acquire, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire).ok();\n    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire).ok();\n    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire).ok();\n    ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();\n}", "item_id": 0, "repo": "martell/rust", "file": "src/test/run-pass/atomic-compare_exchange.rs", "last_update_at": "2019-04-06T13:56:42+00:00", "question_id": "c7b80c42c1baa657e4f99df074114b163190f538_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    // Make sure codegen can emit all the intrinsics correctly\n    ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, Acquire, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, Release, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, AcqRel, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, Acquire, Acquire).ok();\n    ATOMIC.compare_exchange(0, 1, AcqRel, Acquire).ok();\n    ATOMIC.compare_exchange(0, 1, SeqCst, Acquire).ok();\n    ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Acquire, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire).ok();\n    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire).ok();\n    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire).ok();\n    ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();\n"]], "pred": {"ppl": 1.2629668712615967, "ppl_lower": 1.3178342580795288, "ppl/lowercase_ppl": -1.1821528512939186, "ppl/zlib": 0.00111173148965552, "Min_5.0% Prob": 4.223130479454994, "Min_10.0% Prob": 2.305238874895232, "Min_20.0% Prob": 1.1720335063695604, "Min_30.0% Prob": 0.7826209677316781, "Min_40.0% Prob": 0.5841639669263986, "Min_50.0% Prob": 0.46784891438505655, "Min_60.0% Prob": 0.3901517009553233}}
{"hexsha": "675110c1532e4d3c318357e731a5ac978e792779", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    server::new(|| App::new().resource(\"/\", |r| r.f(|_| HttpResponse::Ok())))\n        .keep_alive(75); // <- Set keep-alive to 75 seconds\n\n    server::new(|| App::new().resource(\"/\", |r| r.f(|_| HttpResponse::Ok())))\n        .keep_alive(server::KeepAlive::Tcp(75)); // <- Use `SO_KEEPALIVE` socket option.\n\n    server::new(|| App::new().resource(\"/\", |r| r.f(|_| HttpResponse::Ok())))\n        .keep_alive(None); // <- Disable keep-alive\n}", "item_id": 0, "repo": "awulkan/actix-website", "file": "examples/server/src/ka.rs", "last_update_at": "2019-07-16T03:34:51+00:00", "question_id": "675110c1532e4d3c318357e731a5ac978e792779_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    server::new(|| App::new().resource(\"/\", |r| r.f(|_| HttpResponse::Ok())))\n        .keep_alive(75); // <- Set keep-alive to 75 seconds\n    server::new(|| App::new().resource(\"/\", |r| r.f(|_| HttpResponse::Ok())))\n        .keep_alive(server::KeepAlive::Tcp(75)); // <- Use `SO_KEEPALIVE` socket option.\n    server::new(|| App::new().resource(\"/\", |r| r.f(|_| HttpResponse::Ok())))\n        .keep_alive(None); // <- Disable keep-alive\n"]], "pred": {"ppl": 1.9578914642333984, "ppl_lower": 2.5512454509735107, "ppl/lowercase_ppl": -1.3939962877856045, "ppl/zlib": 0.0033762216613948196, "Min_5.0% Prob": 8.151819884777069, "Min_10.0% Prob": 5.526425123214722, "Min_20.0% Prob": 3.2252858237308613, "Min_30.0% Prob": 2.2171543731408963, "Min_40.0% Prob": 1.6794003108516335, "Min_50.0% Prob": 1.3482057792189366, "Min_60.0% Prob": 1.125233722339366}}
{"hexsha": "12e8f9733fe2a0d5c3b46246047def3f81a8f7cd", "ext": "rs", "lang": "Rust", "content": "fn irr(\n        leg_:Leg,\n        npv_:Real,\n        dayCounter_:Box<DayCounter>,\n        compounding_:Compounding,\n        frequency_:Frequency,\n        includeSettlementDateFlows_:bool,\n        settlementDate_:LocalDate, \n        npvDate_:LocalDate,\n        accuracy:Real,\n        maxIterations:usize,\n        guess:Real)->Real {\n        let mut solver = Solver1D::default();\n        solver.setMaxEvaluations(maxIterations);\n        return irr_(solver, leg_, npv_, dayCounter_,\n                    compounding_, frequency_,\n                    includeSettlementDateFlows_,\n                    settlementDate_, npvDate_,\n                    accuracy, guess);\n}", "item_id": 9, "repo": "teddyzhu/quantrest", "file": "src/cashflow.rs", "last_update_at": "2019-07-15T06:27:47+00:00", "question_id": "12e8f9733fe2a0d5c3b46246047def3f81a8f7cd_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn irr(\n        leg_:Leg,\n        npv_:Real,\n        dayCounter_:Box<DayCounter>,\n        compounding_:Compounding,\n        frequency_:Frequency,\n        includeSettlementDateFlows_:bool,\n        settlementDate_:LocalDate, \n        npvDate_:LocalDate,\n        accuracy:Real,\n        maxIterations:usize,\n        guess:Real)->Real {\n        let mut solver = Solver1D::default();\n        solver.setMaxEvaluations(maxIterations);\n        return irr_(solver, leg_, npv_, dayCounter_,\n                    compounding_, frequency_,\n                    includeSettlementDateFlows_,\n                    settlementDate_, npvDate_,\n                    accuracy, guess);\n"]], "pred": {"ppl": 3.0421223640441895, "ppl_lower": 3.7629613876342773, "ppl/lowercase_ppl": -1.1911372945422967, "ppl/zlib": 0.004045656065071638, "Min_5.0% Prob": 8.096276760101318, "Min_10.0% Prob": 6.684994883007473, "Min_20.0% Prob": 4.8302227709744425, "Min_30.0% Prob": 3.4628771852169717, "Min_40.0% Prob": 2.7169682214388975, "Min_50.0% Prob": 2.204171022900971, "Min_60.0% Prob": 1.8491153828799725}}
{"hexsha": "e29a32837ca460e117c893629bd7c7ad0fa00d7a", "ext": "rs", "lang": "Rust", "content": "fn test_body_can_move_out_of_passable_body(\n        moving_body: PhysicalBody,\n        expected_location_after_moving: Point,\n    ) {\n        let mut world = NphysicsWorld::with_timestep(DEFAULT_TIMESTEP);\n\n        let moving_body_handle = world.add_body(moving_body.clone());\n\n        let passable_body = passable_body();\n        let passable_body_handle = world.add_body(passable_body.clone());\n\n        let force = Force {\n            torque: Torque::default(),\n            linear: Vector { x: 40.0, y: 40.0 },\n        };\n\n        world.apply_force(moving_body_handle, force);\n        world.step();\n\n        assert_eq!(\n            expected_location_after_moving,\n            world.body(moving_body_handle).unwrap().location\n        );\n\n        assert_eq!(\n            passable_body.location,\n            world.body(passable_body_handle).unwrap().location\n        );\n    }", "item_id": 26, "repo": "myelin-ai/engine", "file": "src/simulation/simulation_impl/world/nphysics_world.rs", "last_update_at": "2019-12-14T11:25:28+00:00", "question_id": "e29a32837ca460e117c893629bd7c7ad0fa00d7a_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_body_can_move_out_of_passable_body(\n        moving_body: PhysicalBody,\n        expected_location_after_moving: Point,\n    ) {\n        let mut world = NphysicsWorld::with_timestep(DEFAULT_TIMESTEP);\n        let moving_body_handle = world.add_body(moving_body.clone());\n        let passable_body = passable_body();\n        let passable_body_handle = world.add_body(passable_body.clone());\n        let force = Force {\n            torque: Torque::default(),\n            linear: Vector { x: 40.0, y: 40.0 },\n        };\n        world.apply_force(moving_body_handle, force);\n        world.step();\n        assert_eq!(\n            expected_location_after_moving,\n            world.body(moving_body_handle).unwrap().location\n        );\n        assert_eq!(\n            passable_body.location,\n            world.body(passable_body_handle).unwrap().location\n        );\n"]], "pred": {"ppl": 2.3469622135162354, "ppl_lower": 2.5678181648254395, "ppl/lowercase_ppl": -1.1054184251594157, "ppl/zlib": 0.002509181814210042, "Min_5.0% Prob": 7.503360381493201, "Min_10.0% Prob": 5.79167916224553, "Min_20.0% Prob": 3.7328504099036164, "Min_30.0% Prob": 2.731756083294749, "Min_40.0% Prob": 2.1060367404857527, "Min_50.0% Prob": 1.7028710274998822, "Min_60.0% Prob": 1.4235323145869911}}
{"hexsha": "38db1695cf2cee41c36549f86781d18a9cf63ec0", "ext": "rs", "lang": "Rust", "content": "fn test_with_fields() {\n    let t = WithFieldsTemplate {\n        names: (\n            Name {\n                first: \"foo\",\n                last: \"bar\",\n            },\n            Name {\n                first: \"fOO\",\n                last: \"bAR\",\n            },\n        ),\n    }; // instantiate your struct\n    assert_eq!(\"Hello, foo bar and fOO bAR!\", t.call().unwrap()); // then call it.\n}", "item_id": 7, "repo": "dgriffen/wearte", "file": "testing/tests/expr.rs", "last_update_at": "2019-07-28T23:01:15+00:00", "question_id": "38db1695cf2cee41c36549f86781d18a9cf63ec0_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_with_fields() {\n    let t = WithFieldsTemplate {\n        names: (\n            Name {\n                first: \"foo\",\n                last: \"bar\",\n            },\n            Name {\n                first: \"fOO\",\n                last: \"bAR\",\n            },\n        ),\n    }; // instantiate your struct\n    assert_eq!(\"Hello, foo bar and fOO bAR!\", t.call().unwrap()); // then call it.\n"]], "pred": {"ppl": 3.8783624172210693, "ppl_lower": 4.756622791290283, "ppl/lowercase_ppl": -1.1505997881109153, "ppl/zlib": 0.0068111206388272935, "Min_5.0% Prob": 9.33210916519165, "Min_10.0% Prob": 7.716551971435547, "Min_20.0% Prob": 5.7203160127003985, "Min_30.0% Prob": 4.22702400572598, "Min_40.0% Prob": 3.2954493511554808, "Min_50.0% Prob": 2.6786426697616226, "Min_60.0% Prob": 2.276675790315494}}
{"hexsha": "7fe5a54a817d02d76a3d99f537ed47c6580e866d", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn wlr_log_init(mut verbosity: wlr_log_importance,\n                                      mut callback: wlr_log_func_t) {\n    if (verbosity as libc::c_uint) <\n           WLR_LOG_IMPORTANCE_LAST as libc::c_int as libc::c_uint {\n        log_importance = verbosity\n    }\n    if callback.is_some() { log_callback = callback }\n    wl_log_set_handler_server(Some(log_wl as\n                                       unsafe extern \"C\" fn(_:\n                                                                *const libc::c_char,\n                                                            _:\n                                                                ::std::ffi::VaList)\n                                           -> ()));\n}", "item_id": 2, "repo": "RoastVeg/wlrusts", "file": "src/util/log.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "7fe5a54a817d02d76a3d99f537ed47c6580e866d_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn wlr_log_init(mut verbosity: wlr_log_importance,\n                                      mut callback: wlr_log_func_t) {\n    if (verbosity as libc::c_uint) <\n           WLR_LOG_IMPORTANCE_LAST as libc::c_int as libc::c_uint {\n        log_importance = verbosity\n    }\n    if callback.is_some() { log_callback = callback }\n    wl_log_set_handler_server(Some(log_wl as\n                                       unsafe extern \"C\" fn(_:\n                                                                *const libc::c_char,\n                                                            _:\n                                                                ::std::ffi::VaList)\n                                           -> ()));\n"]], "pred": {"ppl": 1.908072590827942, "ppl_lower": 2.7358038425445557, "ppl/lowercase_ppl": -1.5577081625191644, "ppl/zlib": 0.0024018350104449437, "Min_5.0% Prob": 6.4441603024800616, "Min_10.0% Prob": 4.401981454146536, "Min_20.0% Prob": 2.868842221223391, "Min_30.0% Prob": 2.0906420694342973, "Min_40.0% Prob": 1.6008782250185807, "Min_50.0% Prob": 1.2952423480137722, "Min_60.0% Prob": 1.0759652460105398}}
{"hexsha": "e62d4bad820b2b50b02221c0ab525295304277f4", "ext": "rs", "lang": "Rust", "content": "fn test_parse_float() {\n    test_text_format_str_descriptor(\"float_singular: 98.5\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"float_singular: -99.5\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"float_singular: -99\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"double_singular: 98.5\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"double_singular: -99.5\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"double_singular: 99\", TestTypes::descriptor_static());\n}", "item_id": 4, "repo": "comiclee/rust-protobuf", "file": "protobuf-test/src/common/v2/test_fmt_text_format.rs", "last_update_at": "2019-05-20T14:11:28+00:00", "question_id": "e62d4bad820b2b50b02221c0ab525295304277f4_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_parse_float() {\n    test_text_format_str_descriptor(\"float_singular: 98.5\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"float_singular: -99.5\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"float_singular: -99\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"double_singular: 98.5\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"double_singular: -99.5\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"double_singular: 99\", TestTypes::descriptor_static());\n"]], "pred": {"ppl": 2.089237689971924, "ppl_lower": 2.1531057357788086, "ppl/lowercase_ppl": -1.0408687576168714, "ppl/zlib": 0.005378096772277961, "Min_5.0% Prob": 7.198246214124891, "Min_10.0% Prob": 5.67803702856365, "Min_20.0% Prob": 3.5163938326713367, "Min_30.0% Prob": 2.4443585776676566, "Min_40.0% Prob": 1.842073873840744, "Min_50.0% Prob": 1.4728375682701367, "Min_60.0% Prob": 1.236149627865308}}
{"hexsha": "9f41e3f593abd4d21eb15c070a0fcbb464e65ab8", "ext": "rs", "lang": "Rust", "content": "pub fn tests() {\n    use crate::input::{test_part_one, test_part_two};\n\n    let example_part_one = \"class: 1-3 or 5-7\nrow: 6-11 or 33-44\nseat: 13-40 or 45-50\n\nyour ticket:\n7,1,14\n\nnearby tickets:\n7,3,47\n40,4,50\n55,2,20\n38,6,12\";\n    test_part_one!(example_part_one => 71);\n\n    let example_part_two = \"class: 0-1 or 4-19\nrow: 0-5 or 8-19\nseat: 0-13 or 16-19\n\nyour ticket:\n11,12,13\n\nnearby tickets:\n3,9,18\n15,1,5\n5,14,9\";\n    test_part_two!(example_part_two => 1);\n\n    let real_input = include_str!(\"day16_input.txt\");\n    test_part_one!(real_input => 29019);\n    test_part_two!(real_input => 517_827_547_723);\n}", "item_id": 1, "repo": "fornwall/advent-of-code-2019-rs", "file": "crates/core/src/year2020/day16.rs", "last_update_at": "2019-12-10T00:08:49+00:00", "question_id": "9f41e3f593abd4d21eb15c070a0fcbb464e65ab8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn tests() {\n    use crate::input::{test_part_one, test_part_two};\n    let example_part_one = \"class: 1-3 or 5-7\nrow: 6-11 or 33-44\nseat: 13-40 or 45-50\nyour ticket:\n7,1,14\nnearby tickets:\n7,3,47\n40,4,50\n55,2,20\n38,6,12\";\n    test_part_one!(example_part_one => 71);\n    let example_part_two = \"class: 0-1 or 4-19\nrow: 0-5 or 8-19\nseat: 0-13 or 16-19\nyour ticket:\n11,12,13\nnearby tickets:\n3,9,18\n15,1,5\n5,14,9\";\n    test_part_two!(example_part_two => 1);\n    let real_input = include_str!(\"day16_input.txt\");\n    test_part_one!(real_input => 29019);\n    test_part_two!(real_input => 517_827_547_723);\n"]], "pred": {"ppl": 1.4431877136230469, "ppl_lower": 1.4431877136230469, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0011834011516199479, "Min_5.0% Prob": 4.7846304923295975, "Min_10.0% Prob": 3.3492301413507173, "Min_20.0% Prob": 1.8285115757449106, "Min_30.0% Prob": 1.2250642364543647, "Min_40.0% Prob": 0.9195784554493994, "Min_50.0% Prob": 0.7358483143538858, "Min_60.0% Prob": 0.6132551963501193}}
{"hexsha": "42c6c97511da80cf4c4213e9d4274610ecc943ba", "ext": "rs", "lang": "Rust", "content": "fn must_round_trip_field_stop() {\n        let (mut i_prot, mut o_prot) = test_objects(true);\n\n        assert!(o_prot.write_field_stop().is_ok());\n\n        copy_write_buffer_to_read_buffer!(o_prot);\n\n        let expected_ident = TFieldIdentifier {\n            name: None,\n            field_type: TType::Stop,\n            id: Some(0),\n        }; // we get id 0\n\n        let received_ident = assert_success!(i_prot.read_field_begin());\n        assert_eq!(&received_ident, &expected_ident);\n    }", "item_id": 9, "repo": "ashetkar/snappy-thrift", "file": "lib/rs/src/protocol/binary.rs", "last_update_at": "2019-05-22T13:18:17+00:00", "question_id": "42c6c97511da80cf4c4213e9d4274610ecc943ba_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn must_round_trip_field_stop() {\n        let (mut i_prot, mut o_prot) = test_objects(true);\n        assert!(o_prot.write_field_stop().is_ok());\n        copy_write_buffer_to_read_buffer!(o_prot);\n        let expected_ident = TFieldIdentifier {\n            name: None,\n            field_type: TType::Stop,\n            id: Some(0),\n        }; // we get id 0\n        let received_ident = assert_success!(i_prot.read_field_begin());\n        assert_eq!(&received_ident, &expected_ident);\n"]], "pred": {"ppl": 3.5859341621398926, "ppl_lower": 4.314916133880615, "ppl/lowercase_ppl": -1.144914735690122, "ppl/zlib": 0.004968945584907076, "Min_5.0% Prob": 8.945359408855438, "Min_10.0% Prob": 7.213235288858414, "Min_20.0% Prob": 5.254398158102324, "Min_30.0% Prob": 3.9812033602169583, "Min_40.0% Prob": 3.123816990942666, "Min_50.0% Prob": 2.548794401673282, "Min_60.0% Prob": 2.1225289875509765}}
{"hexsha": "886a46a37b7cc405bae5161208a7c872eb3648c9", "ext": "rs", "lang": "Rust", "content": "pub fn tests() {\n    use crate::input::test_part_one;\n\n    let example = \"5764801\\n17807724\";\n    test_part_one!(example => 14_897_079);\n    let real_input = include_str!(\"day25_input.txt\");\n    test_part_one!(real_input => 18_862_163);\n}", "item_id": 2, "repo": "fornwall/advent-of-code-2019-rs", "file": "crates/core/src/year2020/day25.rs", "last_update_at": "2019-12-10T00:08:49+00:00", "question_id": "886a46a37b7cc405bae5161208a7c872eb3648c9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn tests() {\n    use crate::input::test_part_one;\n    let example = \"5764801\\n17807724\";\n    test_part_one!(example => 14_897_079);\n    let real_input = include_str!(\"day25_input.txt\");\n    test_part_one!(real_input => 18_862_163);\n"]], "pred": {"ppl": 2.4590673446655273, "ppl_lower": 2.4590673446655273, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.0055542108016806545, "Min_5.0% Prob": 8.498049640655518, "Min_10.0% Prob": 5.640560735355724, "Min_20.0% Prob": 3.8913201093673706, "Min_30.0% Prob": 2.8888108965122337, "Min_40.0% Prob": 2.2452142854983155, "Min_50.0% Prob": 1.8111355788667094, "Min_60.0% Prob": 1.5120130267953782}}
{"hexsha": "ad25688b53172401da5ffc97264b14502ce12e6e", "ext": "rs", "lang": "Rust", "content": "fn pregenerate_data<H: Hasher>(degree: usize) -> Pregenerated<H> {\n    let mut rng = thread_rng();\n    let data: Vec<u8> = (0..(degree + 1))\n        .flat_map(|_| fr_into_bytes::<Bls12>(&rng.gen()))\n        .collect();\n    let parents: Vec<usize> = (0..degree).map(|pos| pos).collect();\n    let replica_id: H::Domain = rng.gen();\n    Pregenerated {\n        data,\n        parents,\n        replica_id,\n    }\n}", "item_id": 0, "repo": "idotial/rust-fil-proofs", "file": "storage-proofs/benches/encode.rs", "last_update_at": "2019-07-18T01:28:09+00:00", "question_id": "ad25688b53172401da5ffc97264b14502ce12e6e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn pregenerate_data<H: Hasher>(degree: usize) -> Pregenerated<H> {\n    let mut rng = thread_rng();\n    let data: Vec<u8> = (0..(degree + 1))\n        .flat_map(|_| fr_into_bytes::<Bls12>(&rng.gen()))\n        .collect();\n    let parents: Vec<usize> = (0..degree).map(|pos| pos).collect();\n    let replica_id: H::Domain = rng.gen();\n    Pregenerated {\n        data,\n        parents,\n        replica_id,\n    }\n"]], "pred": {"ppl": 2.2120020389556885, "ppl_lower": 3.053630828857422, "ppl/lowercase_ppl": -1.4061394671209615, "ppl/zlib": 0.0033639745992790947, "Min_5.0% Prob": 8.18946099281311, "Min_10.0% Prob": 5.847972899675369, "Min_20.0% Prob": 3.6060547586530447, "Min_30.0% Prob": 2.553932750597596, "Min_40.0% Prob": 1.9609787625959143, "Min_50.0% Prob": 1.5829161928966642, "Min_60.0% Prob": 1.3223156172413535}}
{"hexsha": "b3e8a5a2959ca55a77af4546886f9d50848340df", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut display = DisplayBuilder::new().size(304, 128).scale(2).build();\n\n    display.draw(\n        Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32).stroke(Some(1u8.into())),\n    );\n\n    display.draw(\n        Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32)\n            .translate(icoord!(16, 16))\n            .stroke(Some(0u8.into()))\n            .fill(Some(1u8.into())),\n    );\n\n    display.draw(\n        Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32)\n            .translate(icoord!(CIRCLE_SIZE, CIRCLE_SIZE))\n            .stroke(Some(0u8.into()))\n            .fill(Some(0u8.into())),\n    );\n\n    display.draw(\n        Rectangle::new(icoord!(0, 0), icoord!(64, 64))\n            .translate(icoord!(96, 0))\n            .stroke(Some(1u8.into())),\n    );\n\n    display.draw(\n        &Rectangle::new(icoord!(0, 0), icoord!(64, 64))\n            .translate(icoord!(96 + 16, 16))\n            .stroke(Some(0u8.into()))\n            .fill(Some(1u8.into())),\n    );\n\n    display.draw(\n        Rectangle::new(icoord!(0, 0), icoord!(64, 64))\n            .translate(icoord!(96 + 32, 32))\n            .stroke(Some(0u8.into()))\n            .fill(Some(0u8.into())),\n    );\n\n    display.draw(\n        Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))\n            .translate(icoord!(96 * 2, 0))\n            .stroke(Some(1u8.into())),\n    );\n\n    display.draw(\n        Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))\n            .translate(icoord!(96 * 2 + 16, 16))\n            .stroke(Some(0u8.into()))\n            .fill(Some(1u8.into())),\n    );\n\n    display.draw(\n        Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))\n            .translate(icoord!(96 * 2 + 32, 32))\n            .stroke(Some(0u8.into()))\n            .fill(Some(0u8.into())),\n    );\n\n    loop {\n        let end = display.run_once();\n\n        if end {\n            break;\n        }\n\n        thread::sleep(Duration::from_millis(200));\n    }\n}", "item_id": 0, "repo": "mmou/embedded-graphics", "file": "simulator/examples/fill.rs", "last_update_at": "2019-07-16T02:31:01+00:00", "question_id": "b3e8a5a2959ca55a77af4546886f9d50848340df_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let mut display = DisplayBuilder::new().size(304, 128).scale(2).build();\n    display.draw(\n        Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32).stroke(Some(1u8.into())),\n    );\n    display.draw(\n        Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32)\n            .translate(icoord!(16, 16))\n            .stroke(Some(0u8.into()))\n            .fill(Some(1u8.into())),\n    );\n    display.draw(\n        Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32)\n            .translate(icoord!(CIRCLE_SIZE, CIRCLE_SIZE))\n            .stroke(Some(0u8.into()))\n            .fill(Some(0u8.into())),\n    );\n    display.draw(\n        Rectangle::new(icoord!(0, 0), icoord!(64, 64))\n            .translate(icoord!(96, 0))\n            .stroke(Some(1u8.into())),\n    );\n    display.draw(\n        &Rectangle::new(icoord!(0, 0), icoord!(64, 64))\n            .translate(icoord!(96 + 16, 16))\n            .stroke(Some(0u8.into()))\n            .fill(Some(1u8.into())),\n    );\n    display.draw(\n        Rectangle::new(icoord!(0, 0), icoord!(64, 64))\n            .translate(icoord!(96 + 32, 32))\n            .stroke(Some(0u8.into()))\n            .fill(Some(0u8.into())),\n    );\n    display.draw(\n        Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))\n            .translate(icoord!(96 * 2, 0))\n            .stroke(Some(1u8.into())),\n    );\n    display.draw(\n        Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))\n            .translate(icoord!(96 * 2 + 16, 16))\n            .stroke(Some(0u8.into()))\n            .fill(Some(1u8.into())),\n    );\n    display.draw(\n        Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))\n            .translate(icoord!(96 * 2 + 32, 32))\n            .stroke(Some(0u8.into()))\n            .fill(Some(0u8.into())),\n    );\n    loop {\n        let end = display.run_once();\n        if end {\n            break;\n        }\n        thread::sleep(Duration::from_millis(200));\n    }\n"]], "pred": {"ppl": 1.3270820379257202, "ppl_lower": 1.4144333600997925, "ppl/lowercase_ppl": -1.2252662483079995, "ppl/zlib": 0.0007546202014357997, "Min_5.0% Prob": 3.962544697523117, "Min_10.0% Prob": 2.521347185711802, "Min_20.0% Prob": 1.384696417516726, "Min_30.0% Prob": 0.9378509987601821, "Min_40.0% Prob": 0.7079205566123014, "Min_50.0% Prob": 0.5663228297643774, "Min_60.0% Prob": 0.4717380628419793}}
{"hexsha": "866493b9c7622fe5e4d49ba91613c03dea0bbbf7", "ext": "rs", "lang": "Rust", "content": "fn read_from_source<T: BufRead>(reader: &mut T) -> Result<Value, JpErr> {\n    let mut contents = String::new();\n    let size = reader.read_to_string(&mut contents)\n        .map_err(|_| JpErr::FileReadError)?;\n\n    if size == 0 {\n        return Err(JpErr::EmptyFileError);\n    }\n\n    let json = from_str(&contents)\n        .map_err(|_| JpErr::JsonParseError)?;\n\n    Ok(json)\n}", "item_id": 0, "repo": "therealklanni/jp-cli", "file": "src/main.rs", "last_update_at": "2019-02-10T01:14:37+00:00", "question_id": "866493b9c7622fe5e4d49ba91613c03dea0bbbf7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_from_source<T: BufRead>(reader: &mut T) -> Result<Value, JpErr> {\n    let mut contents = String::new();\n    let size = reader.read_to_string(&mut contents)\n        .map_err(|_| JpErr::FileReadError)?;\n    if size == 0 {\n        return Err(JpErr::EmptyFileError);\n    }\n    let json = from_str(&contents)\n        .map_err(|_| JpErr::JsonParseError)?;\n    Ok(json)\n"]], "pred": {"ppl": 2.0180554389953613, "ppl_lower": 3.01884388923645, "ppl/lowercase_ppl": -1.5735932461270636, "ppl/zlib": 0.003134528543756766, "Min_5.0% Prob": 6.206367413202922, "Min_10.0% Prob": 4.882723514850323, "Min_20.0% Prob": 3.149240224449723, "Min_30.0% Prob": 2.23841182124324, "Min_40.0% Prob": 1.746243076192008, "Min_50.0% Prob": 1.405510426772868, "Min_60.0% Prob": 1.170891704446659}}
{"hexsha": "7e0adff604bbf844ea75c468311965832ab8a9aa", "ext": "rs", "lang": "Rust", "content": "pub fn parse(args: &ArgMatches, config: SetupConfig) -> Result<DeleteNode, Error> {\n    let tendermint_key = parse_tendermint_key(args)?;\n    let eth = parse_ethereum_args(args, config)?;\n\n    Ok(DeleteNode {\n        tendermint_key,\n        eth,\n    })\n}", "item_id": 0, "repo": "lcoenen/fluence", "file": "cli/src/delete_node.rs", "last_update_at": "2019-05-30T14:42:54+00:00", "question_id": "7e0adff604bbf844ea75c468311965832ab8a9aa_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse(args: &ArgMatches, config: SetupConfig) -> Result<DeleteNode, Error> {\n    let tendermint_key = parse_tendermint_key(args)?;\n    let eth = parse_ethereum_args(args, config)?;\n    Ok(DeleteNode {\n        tendermint_key,\n        eth,\n    })\n"]], "pred": {"ppl": 3.7255592346191406, "ppl_lower": 5.553413391113281, "ppl/lowercase_ppl": -1.3035208656639425, "ppl/zlib": 0.00816904950721879, "Min_5.0% Prob": 11.050235033035278, "Min_10.0% Prob": 8.546607070498997, "Min_20.0% Prob": 5.741289363967048, "Min_30.0% Prob": 4.169853007351911, "Min_40.0% Prob": 3.212829440832138, "Min_50.0% Prob": 2.6126854108439552, "Min_60.0% Prob": 2.187184083516951}}
{"hexsha": "a96f2f01ce9ebf99caf325adfa022f5e02585d21", "ext": "rs", "lang": "Rust", "content": "fn bytes_and_ints() {\n        let mut c = Composer::new(ComposeMode::Unlimited, false);\n        c.compose_bytes(b\"foo\").unwrap();\n        c.compose_u8(0x07).unwrap();\n        c.compose_u16(0x1234).unwrap();\n        c.compose_u32(0xdeadbeef).unwrap();\n        assert_eq!(c.finish(),\n                   b\"foo\\x07\\x12\\x34\\xde\\xad\\xbe\\xef\");\n    }", "item_id": 0, "repo": "cloudshipping/domain-rs", "file": "src/bits/compose.rs", "last_update_at": "2019-07-23T15:41:21+00:00", "question_id": "a96f2f01ce9ebf99caf325adfa022f5e02585d21_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bytes_and_ints() {\n        let mut c = Composer::new(ComposeMode::Unlimited, false);\n        c.compose_bytes(b\"foo\").unwrap();\n        c.compose_u8(0x07).unwrap();\n        c.compose_u16(0x1234).unwrap();\n        c.compose_u32(0xdeadbeef).unwrap();\n        assert_eq!(c.finish(),\n                   b\"foo\\x07\\x12\\x34\\xde\\xad\\xbe\\xef\");\n"]], "pred": {"ppl": 2.372615098953247, "ppl_lower": 2.6566526889801025, "ppl/lowercase_ppl": -1.1308739880068999, "ppl/zlib": 0.004523522325180567, "Min_5.0% Prob": 6.583077498844692, "Min_10.0% Prob": 5.154114791325161, "Min_20.0% Prob": 3.684516544852938, "Min_30.0% Prob": 2.7319321902025315, "Min_40.0% Prob": 2.1314682508153573, "Min_50.0% Prob": 1.725910510229213, "Min_60.0% Prob": 1.4461526702867733}}
{"hexsha": "3b7a00a2c73c6dd3cba02828e4bdec4b19428f32", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // this signals overflow when checking is on\n    let x = 1_i8 << 17;\n\n    // ... but when checking is off, the fallback will truncate the\n    // input to its lower three bits (= 1). Note that this is *not*\n    // the behavior of the x86 processor for 8- and 16-bit types,\n    // but it is necessary to avoid undefined behavior from LLVM.\n    //\n    // We check that here, by ensuring the result has only been\n    // shifted by one place; if overflow checking is turned off, then\n    // this assertion will pass (and the compiletest driver will\n    // report that the test did not produce the error expected above).\n    assert_eq!(x, 2_i8);\n}", "item_id": 0, "repo": "canaltinova/rust", "file": "src/test/run-fail/overflowing-lsh-4.rs", "last_update_at": "2019-09-24T02:31:48+00:00", "question_id": "3b7a00a2c73c6dd3cba02828e4bdec4b19428f32_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    // this signals overflow when checking is on\n    let x = 1_i8 << 17;\n    // ... but when checking is off, the fallback will truncate the\n    // input to its lower three bits (= 1). Note that this is *not*\n    // the behavior of the x86 processor for 8- and 16-bit types,\n    // but it is necessary to avoid undefined behavior from LLVM.\n    //\n    // We check that here, by ensuring the result has only been\n    // shifted by one place; if overflow checking is turned off, then\n    // this assertion will pass (and the compiletest driver will\n    // report that the test did not produce the error expected above).\n    assert_eq!(x, 2_i8);\n"]], "pred": {"ppl": 7.719071388244629, "ppl_lower": 7.985072135925293, "ppl/lowercase_ppl": -1.0165776990513657, "ppl/zlib": 0.005420939178527518, "Min_5.0% Prob": 8.8655637105306, "Min_10.0% Prob": 7.359930780198839, "Min_20.0% Prob": 6.034911065488248, "Min_30.0% Prob": 5.178243147243153, "Min_40.0% Prob": 4.435997990337578, "Min_50.0% Prob": 3.8223858430821407, "Min_60.0% Prob": 3.338867940344252}}
{"hexsha": "85cc2e349629b4073bf751e1399639ab4021dd52", "ext": "rs", "lang": "Rust", "content": "fn write_export(content: &mut String, func: &parser::FuncDecl, package_info: &cargo::Info) {\n    let func_body = match marshal::has_marshaled_ret_value(func) {\n        true => export_marshaled_return(func, package_info),\n        false => format!(\"\\t\\t{}\\n\\t\\t{}\\n\\n\", get_import_decl(func, package_info), get_func_signature(func))\n    };\n\n    //Boolean values are 1 byte size, so append this in order to marshal it correctly\n    match func.ret {\n        parser::ReturnType::Type(parser::Type::Boolean) => content.push_str(\"\\t\\t[return: MarshalAs(UnmanagedType.I1)]\\n\"),\n        _=> ()\n    }\n\n    content.push_str(func_body.as_ref());\n}", "item_id": 2, "repo": "vvanders/ffigen", "file": "src/gen/csharp.rs", "last_update_at": "2019-08-06T16:37:09+00:00", "question_id": "85cc2e349629b4073bf751e1399639ab4021dd52_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn write_export(content: &mut String, func: &parser::FuncDecl, package_info: &cargo::Info) {\n    let func_body = match marshal::has_marshaled_ret_value(func) {\n        true => export_marshaled_return(func, package_info),\n        false => format!(\"\\t\\t{}\\n\\t\\t{}\\n\\n\", get_import_decl(func, package_info), get_func_signature(func))\n    };\n    //Boolean values are 1 byte size, so append this in order to marshal it correctly\n    match func.ret {\n        parser::ReturnType::Type(parser::Type::Boolean) => content.push_str(\"\\t\\t[return: MarshalAs(UnmanagedType.I1)]\\n\"),\n        _=> ()\n    }\n    content.push_str(func_body.as_ref());\n"]], "pred": {"ppl": 4.285906791687012, "ppl_lower": 5.800192356109619, "ppl/lowercase_ppl": -1.2078968242827492, "ppl/zlib": 0.004088011656343705, "Min_5.0% Prob": 9.230407810211181, "Min_10.0% Prob": 7.337222825913202, "Min_20.0% Prob": 5.489568693693294, "Min_30.0% Prob": 4.286399467174824, "Min_40.0% Prob": 3.4627644097668, "Min_50.0% Prob": 2.850522395394264, "Min_60.0% Prob": 2.421395017722478}}
{"hexsha": "cd63239b14314163ea6512af3f272a927623a2b7", "ext": "rs", "lang": "Rust", "content": "fn test_string() {\n    assert_eq!(parse_sexpr(\"\\\"\\\"\"), Ok(Elem::String(\"\".to_string())));\n    assert_eq!(parse_sexpr(\"\\\"foo\\\"\"), Ok(Elem::String(\"foo\".to_string())));\n    assert_eq!(parse_sexpr(\"\\\"A quote: \\\\\\\"\\\"\"),\n      Ok(Elem::String(\"A quote: \\\"\".to_string())));\n    assert_eq!(parse_sexpr(\"\\\"C:\\\\\\\\Windows\\\"\"),\n      Ok(Elem::String(\"C:\\\\Windows\".to_string())));\n    assert_eq!(parse_sexpr(\"\\\"\\\\r\\\\n\\\\t\\\\e\\\"\"), \n      Ok(Elem::String(\"\\r\\n\\t\\u{1b}\".to_string())));\n  }", "item_id": 8, "repo": "honzasp/spiral", "file": "src/sexpr/parse.rs", "last_update_at": "2019-09-19T04:40:59+00:00", "question_id": "cd63239b14314163ea6512af3f272a927623a2b7_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_string() {\n    assert_eq!(parse_sexpr(\"\\\"\\\"\"), Ok(Elem::String(\"\".to_string())));\n    assert_eq!(parse_sexpr(\"\\\"foo\\\"\"), Ok(Elem::String(\"foo\".to_string())));\n    assert_eq!(parse_sexpr(\"\\\"A quote: \\\\\\\"\\\"\"),\n      Ok(Elem::String(\"A quote: \\\"\".to_string())));\n    assert_eq!(parse_sexpr(\"\\\"C:\\\\\\\\Windows\\\"\"),\n      Ok(Elem::String(\"C:\\\\Windows\".to_string())));\n    assert_eq!(parse_sexpr(\"\\\"\\\\r\\\\n\\\\t\\\\e\\\"\"), \n      Ok(Elem::String(\"\\r\\n\\t\\u{1b}\".to_string())));\n"]], "pred": {"ppl": 1.9400904178619385, "ppl_lower": 2.074134588241577, "ppl/lowercase_ppl": -1.1008087155065567, "ppl/zlib": 0.004016573206875676, "Min_5.0% Prob": 6.980385409461127, "Min_10.0% Prob": 5.4553463326560125, "Min_20.0% Prob": 3.2167721761239543, "Min_30.0% Prob": 2.205683533102274, "Min_40.0% Prob": 1.6624126480519772, "Min_50.0% Prob": 1.331018502427701, "Min_60.0% Prob": 1.1080119573156786}}
{"hexsha": "2f0568a61430a64d4bc63607fb7e8905f9750296", "ext": "rs", "lang": "Rust", "content": "pub fn run(args: &ArgMatches) -> Result<(), Box<dyn Error>> {\n    // Load config\n    let config = Config::load()?;\n    let user_name = config.user.name;\n    let user_email = match config.user.email {\n        Some(email) => email,\n        None => String::new(),\n    };\n\n    // Return an error in case of an empty configuration\n    match &user_name {\n        Some(name) if name != &String::new() => (),\n        _ => return Err(Box::new(ConfigError::MissingAuthor(user_email))),\n    }\n\n    // Create tree object\n    let repo_path = utils::find_repo()?;\n    let index = Index::load(&repo_path);\n    let tree = Tree::from(&index);\n\n    // Save tree\n    tree.save(&repo_path);\n\n    // Get head commit (parent)\n    let mut parent = vec![];\n    if let Some(commit) = refs::get_head(&repo_path) {\n        parent.push(commit);\n    }\n\n    // Nothing to commit\n    if (parent.is_empty() && tree.entries.is_empty())\n        || (!parent.is_empty() && tree.hash() == parent[0].hash())\n    {\n        return Err(Box::new(NothingToCommit {}));\n    }\n\n    // Create commit object\n    let message = String::from(args.value_of(\"msg\").unwrap());\n    let commit = Commit::create(&tree, parent, user_name.unwrap(), user_email, message);\n\n    // Save commit object\n    commit.save(&repo_path);\n\n    // Update HEAD\n    refs::update(\n        &repo_path,\n        &String::from(\"HEAD\"),\n        &commit.hash().to_string(),\n        true,\n    )\n    .expect(\"fatal: error while updating HEAD ref\");\n\n    Ok(())\n}", "item_id": 0, "repo": "flomonster/my-git", "file": "src/cmd/commit.rs", "last_update_at": "2019-08-22T18:48:36+00:00", "question_id": "2f0568a61430a64d4bc63607fb7e8905f9750296_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn run(args: &ArgMatches) -> Result<(), Box<dyn Error>> {\n    // Load config\n    let config = Config::load()?;\n    let user_name = config.user.name;\n    let user_email = match config.user.email {\n        Some(email) => email,\n        None => String::new(),\n    };\n    // Return an error in case of an empty configuration\n    match &user_name {\n        Some(name) if name != &String::new() => (),\n        _ => return Err(Box::new(ConfigError::MissingAuthor(user_email))),\n    }\n    // Create tree object\n    let repo_path = utils::find_repo()?;\n    let index = Index::load(&repo_path);\n    let tree = Tree::from(&index);\n    // Save tree\n    tree.save(&repo_path);\n    // Get head commit (parent)\n    let mut parent = vec![];\n    if let Some(commit) = refs::get_head(&repo_path) {\n        parent.push(commit);\n    }\n    // Nothing to commit\n    if (parent.is_empty() && tree.entries.is_empty())\n        || (!parent.is_empty() && tree.hash() == parent[0].hash())\n    {\n        return Err(Box::new(NothingToCommit {}));\n    }\n    // Create commit object\n    let message = String::from(args.value_of(\"msg\").unwrap());\n    let commit = Commit::create(&tree, parent, user_name.unwrap(), user_email, message);\n    // Save commit object\n    commit.save(&repo_path);\n    // Update HEAD\n    refs::update(\n        &repo_path,\n        &String::from(\"HEAD\"),\n        &commit.hash().to_string(),\n        true,\n    )\n    .expect(\"fatal: error while updating HEAD ref\");\n    Ok(())\n"]], "pred": {"ppl": 2.2810654640197754, "ppl_lower": 2.6912145614624023, "ppl/lowercase_ppl": -1.2005110461413944, "ppl/zlib": 0.0012725966706669894, "Min_5.0% Prob": 6.439585001572318, "Min_10.0% Prob": 4.891756975904424, "Min_20.0% Prob": 3.3580701655529914, "Min_30.0% Prob": 2.537200301674241, "Min_40.0% Prob": 1.9951920618140508, "Min_50.0% Prob": 1.6342216903122806, "Min_60.0% Prob": 1.3736774360649155}}
{"hexsha": "a0c331818451a7bca9576b530cbe6507141ebff4", "ext": "rs", "lang": "Rust", "content": "async fn test_repo() {\n    let env = TestEnv::new();\n    env.add_repository(\n        RepositoryConfigBuilder::new(RepoUrl::new(\"example.com\".to_string()).expect(\"valid url\"))\n            .build(),\n    );\n\n    let output = env.run_pkgctl(vec![\"repo\"]).await;\n\n    assert_stdout(&output, \"fuchsia-pkg://example.com\\n\");\n    env.assert_only_repository_manager_called_with(vec![CapturedRepositoryManagerRequest::List]);\n}", "item_id": 0, "repo": "OpenTrustGroup/fuchsia", "file": "garnet/tests/pkgctl/src/lib.rs", "last_update_at": "2019-04-21T18:02:26+00:00", "question_id": "a0c331818451a7bca9576b530cbe6507141ebff4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_repo() {\n    let env = TestEnv::new();\n    env.add_repository(\n        RepositoryConfigBuilder::new(RepoUrl::new(\"example.com\".to_string()).expect(\"valid url\"))\n            .build(),\n    );\n    let output = env.run_pkgctl(vec![\"repo\"]).await;\n    assert_stdout(&output, \"fuchsia-pkg://example.com\\n\");\n    env.assert_only_repository_manager_called_with(vec![CapturedRepositoryManagerRequest::List]);\n"]], "pred": {"ppl": 3.580772638320923, "ppl_lower": 5.544739723205566, "ppl/lowercase_ppl": -1.3428021476146603, "ppl/zlib": 0.00479540826273193, "Min_5.0% Prob": 8.781274636586508, "Min_10.0% Prob": 6.64761235163762, "Min_20.0% Prob": 4.806926438441644, "Min_30.0% Prob": 3.727559811029679, "Min_40.0% Prob": 3.0246204218039145, "Min_50.0% Prob": 2.483524702715151, "Min_60.0% Prob": 2.1085410959358457}}
{"hexsha": "a508c2f05e13c70043b704481f43934a1170337d", "ext": "rs", "lang": "Rust", "content": "fn gcd(a: i64, b: i64) -> i64 {\n    if a < b {\n        return gcd(b, a);\n    }\n    if b == 0 {\n        return a;\n    }\n    return gcd(a - b, b);\n}", "item_id": 0, "repo": "pankdm/adventofcode-2019", "file": "src/bin/day12.rs", "last_update_at": "2019-12-13T02:21:50+00:00", "question_id": "a508c2f05e13c70043b704481f43934a1170337d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn gcd(a: i64, b: i64) -> i64 {\n    if a < b {\n        return gcd(b, a);\n    }\n    if b == 0 {\n        return a;\n    }\n    return gcd(a - b, b);\n"]], "pred": {"ppl": 1.6103171110153198, "ppl_lower": 1.6103171110153198, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.005353158685002109, "Min_5.0% Prob": 6.267666737238566, "Min_10.0% Prob": 3.7734539679118564, "Min_20.0% Prob": 2.257416469710214, "Min_30.0% Prob": 1.570402864898954, "Min_40.0% Prob": 1.1961116204038262, "Min_50.0% Prob": 0.9615827404494797, "Min_60.0% Prob": 0.8033674038458793}}
{"hexsha": "f1d785e6ae0e8d707e6d028b013b1a892468d352", "ext": "rs", "lang": "Rust", "content": "fn test_writer_bookmark_position_zero_two() {\n    SETUP_WRITER!(\n        \"=== hello\n=== world\",\n        reader,\n        writer\n    );\n\n    assert_eq!(writer.index, 0);\n\n    assert_eq!(writer.symbols[\"hello\"], 0);\n    assert_eq!(writer.symbols[\"world\"], 0);\n}", "item_id": 12, "repo": "Pomettini/visual-novel-text-baker", "file": "tests/writer_tests.rs", "last_update_at": "2019-09-29T16:27:31+00:00", "question_id": "f1d785e6ae0e8d707e6d028b013b1a892468d352_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_writer_bookmark_position_zero_two() {\n    SETUP_WRITER!(\n        \"=== hello\n=== world\",\n        reader,\n        writer\n    );\n    assert_eq!(writer.index, 0);\n    assert_eq!(writer.symbols[\"hello\"], 0);\n    assert_eq!(writer.symbols[\"world\"], 0);\n"]], "pred": {"ppl": 5.373212814331055, "ppl_lower": 5.356918811798096, "ppl/lowercase_ppl": -0.9981937606645322, "ppl/zlib": 0.010641936829519746, "Min_5.0% Prob": 10.725990295410156, "Min_10.0% Prob": 9.190826733907064, "Min_20.0% Prob": 6.643592410617405, "Min_30.0% Prob": 5.011861739335237, "Min_40.0% Prob": 4.04802938302358, "Min_50.0% Prob": 3.305274580483851, "Min_60.0% Prob": 2.79800014983524}}
{"hexsha": "259330ac289cd54ba2486b224d81e30bf7572268", "ext": "rs", "lang": "Rust", "content": "fn rename() -> Result<()> {\n        let mut fs = MemoryFileSystem::default();\n        fs.write(\"/a/b/hello.txt\", \"blue\")?;\n        assert!(fs.exists(\"/a/b/hello.txt\"));\n\n        fs.rename(\"/a/b/hello.txt\", \"/a/b2/hello.txt\")?;\n        assert!(!fs.exists(\"/a/b/hello.txt\"));\n        assert!(fs.exists(\"/a/b2/hello.txt\"));\n\n        fs.rename(\"/a/b2\", \"/a/b3\")?;\n        assert!(!fs.exists(\"/a/b/hello.txt\"));\n        assert!(!fs.exists(\"/a/b2/hello.txt\"));\n        assert!(fs.exists(\"/a/b3/hello.txt\"));\n\n        Ok(())\n    }", "item_id": 1, "repo": "hansl/refactory", "file": "src/virtualfs/src/fs/memory.rs", "last_update_at": "2019-12-31T22:14:50+00:00", "question_id": "259330ac289cd54ba2486b224d81e30bf7572268_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn rename() -> Result<()> {\n        let mut fs = MemoryFileSystem::default();\n        fs.write(\"/a/b/hello.txt\", \"blue\")?;\n        assert!(fs.exists(\"/a/b/hello.txt\"));\n        fs.rename(\"/a/b/hello.txt\", \"/a/b2/hello.txt\")?;\n        assert!(!fs.exists(\"/a/b/hello.txt\"));\n        assert!(fs.exists(\"/a/b2/hello.txt\"));\n        fs.rename(\"/a/b2\", \"/a/b3\")?;\n        assert!(!fs.exists(\"/a/b/hello.txt\"));\n        assert!(!fs.exists(\"/a/b2/hello.txt\"));\n        assert!(fs.exists(\"/a/b3/hello.txt\"));\n        Ok(())\n"]], "pred": {"ppl": 1.6910282373428345, "ppl_lower": 1.9246103763580322, "ppl/lowercase_ppl": -1.2462930157676777, "ppl/zlib": 0.002886465760346568, "Min_5.0% Prob": 6.214452004432678, "Min_10.0% Prob": 4.25974155664444, "Min_20.0% Prob": 2.519497913867235, "Min_30.0% Prob": 1.733521461735169, "Min_40.0% Prob": 1.308655491634272, "Min_50.0% Prob": 1.04946612293832, "Min_60.0% Prob": 0.875160339314607}}
{"hexsha": "418f9db693d9749aefa93f03516fa7a93d9aed51", "ext": "rs", "lang": "Rust", "content": "pub fn derive(item: syn::DeriveInput) -> Result<proc_macro2::TokenStream, Diagnostic> {\n    let model = Model::from_item(&item)?;\n    let tokens = MetaItem::all_with_name(&item.attrs, \"belongs_to\")\n        .into_iter()\n        .filter_map(\n            |attr| match derive_belongs_to(&model, &item.generics, attr) {\n                Ok(t) => Some(t),\n                Err(e) => {\n                    e.emit();\n                    None\n                }\n            },\n        );\n\n    Ok(wrap_in_dummy_mod(\n        model.dummy_mod_name(\"associations\"),\n        quote!(#(#tokens)*),\n    ))\n}", "item_id": 0, "repo": "marcelbuesing/diesel", "file": "diesel_derives/src/associations.rs", "last_update_at": "2019-04-29T12:41:50+00:00", "question_id": "418f9db693d9749aefa93f03516fa7a93d9aed51_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn derive(item: syn::DeriveInput) -> Result<proc_macro2::TokenStream, Diagnostic> {\n    let model = Model::from_item(&item)?;\n    let tokens = MetaItem::all_with_name(&item.attrs, \"belongs_to\")\n        .into_iter()\n        .filter_map(\n            |attr| match derive_belongs_to(&model, &item.generics, attr) {\n                Ok(t) => Some(t),\n                Err(e) => {\n                    e.emit();\n                    None\n                }\n            },\n        );\n    Ok(wrap_in_dummy_mod(\n        model.dummy_mod_name(\"associations\"),\n        quote!(#(#tokens)*),\n    ))\n"]], "pred": {"ppl": 2.461252450942993, "ppl_lower": 3.245466947555542, "ppl/lowercase_ppl": -1.3070922580725648, "ppl/zlib": 0.0028412313778643223, "Min_5.0% Prob": 7.6788004239400225, "Min_10.0% Prob": 5.955473966068691, "Min_20.0% Prob": 3.9414794879990653, "Min_30.0% Prob": 2.8398341925016473, "Min_40.0% Prob": 2.234431607900439, "Min_50.0% Prob": 1.8034318786875536, "Min_60.0% Prob": 1.50186779167104}}
{"hexsha": "c0b306050718d996e99faa856f777674f1e0989c", "ext": "rs", "lang": "Rust", "content": "fn is_processed_by_this_key_server_in_set_of_3() {\n\t\t// servers set is ordered && server range depends on index of this server\n\t\tlet servers_set = MapKeyServerSet::new(false, vec![\n\t\t\t// secret: 0000000000000000000000000000000000000000000000000000000000000001\n\t\t\t(\"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\".parse().unwrap(),\n\t\t\t\t\"127.0.0.1:8080\".parse().unwrap()),\n\t\t\t// secret: 0000000000000000000000000000000000000000000000000000000000000002\n\t\t\t(\"c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee51ae168fea63dc339a3c58419466ceaeef7f632653266d0e1236431a950cfe52a\".parse().unwrap(),\n\t\t\t\t\"127.0.0.1:8080\".parse().unwrap()),\n\t\t\t// secret: 0000000000000000000000000000000000000000000000000000000000000003\n\t\t\t(\"f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672\".parse().unwrap(),\n\t\t\t\t\"127.0.0.1:8080\".parse().unwrap()),\n\t\t].into_iter().collect());\n\n\t\t// 1st server: process hashes [0x0; 0x555...555]\n\t\tlet key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000001\".parse().unwrap()).unwrap());\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"0000000000000000000000000000000000000000000000000000000000000000\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"3000000000000000000000000000000000000000000000000000000000000000\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"5555555555555555555555555555555555555555555555555555555555555555\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"5555555555555555555555555555555555555555555555555555555555555556\".parse().unwrap()), false);\n\n\t\t// 2nd server: process hashes from 0x555...556 to 0xaaa...aab\n\t\tlet key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000002\".parse().unwrap()).unwrap());\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"5555555555555555555555555555555555555555555555555555555555555555\".parse().unwrap()), false);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"5555555555555555555555555555555555555555555555555555555555555556\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"7555555555555555555555555555555555555555555555555555555555555555\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac\".parse().unwrap()), false);\n\n\t\t// 3rd server: process hashes from 0x800...000 to 0xbff...ff\n\t\tlet key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000003\".parse().unwrap()).unwrap());\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\".parse().unwrap()), false);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"daaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\".parse().unwrap()), true);\n\t}", "item_id": 3, "repo": "altice-io/Daqiao", "file": "bridge/parity-ethereum/secret-store/src/listener/service_contract_listener.rs", "last_update_at": "2019-09-11T12:07:35+00:00", "question_id": "c0b306050718d996e99faa856f777674f1e0989c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn is_processed_by_this_key_server_in_set_of_3() {\n\t\t// servers set is ordered && server range depends on index of this server\n\t\tlet servers_set = MapKeyServerSet::new(false, vec![\n\t\t\t// secret: 0000000000000000000000000000000000000000000000000000000000000001\n\t\t\t(\"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\".parse().unwrap(),\n\t\t\t\t\"127.0.0.1:8080\".parse().unwrap()),\n\t\t\t// secret: 0000000000000000000000000000000000000000000000000000000000000002\n\t\t\t(\"c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee51ae168fea63dc339a3c58419466ceaeef7f632653266d0e1236431a950cfe52a\".parse().unwrap(),\n\t\t\t\t\"127.0.0.1:8080\".parse().unwrap()),\n\t\t\t// secret: 0000000000000000000000000000000000000000000000000000000000000003\n\t\t\t(\"f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672\".parse().unwrap(),\n\t\t\t\t\"127.0.0.1:8080\".parse().unwrap()),\n\t\t].into_iter().collect());\n\t\t// 1st server: process hashes [0x0; 0x555...555]\n\t\tlet key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000001\".parse().unwrap()).unwrap());\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"0000000000000000000000000000000000000000000000000000000000000000\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"3000000000000000000000000000000000000000000000000000000000000000\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"5555555555555555555555555555555555555555555555555555555555555555\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"5555555555555555555555555555555555555555555555555555555555555556\".parse().unwrap()), false);\n\t\t// 2nd server: process hashes from 0x555...556 to 0xaaa...aab\n\t\tlet key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000002\".parse().unwrap()).unwrap());\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"5555555555555555555555555555555555555555555555555555555555555555\".parse().unwrap()), false);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"5555555555555555555555555555555555555555555555555555555555555556\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"7555555555555555555555555555555555555555555555555555555555555555\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac\".parse().unwrap()), false);\n\t\t// 3rd server: process hashes from 0x800...000 to 0xbff...ff\n\t\tlet key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000003\".parse().unwrap()).unwrap());\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\".parse().unwrap()), false);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"daaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\".parse().unwrap()), true);\n"]], "pred": {"ppl": 2.2816858291625977, "ppl_lower": 2.3594539165496826, "ppl/lowercase_ppl": -1.0406292163436044, "ppl/zlib": 0.001142540953602889, "Min_5.0% Prob": 7.458360204509661, "Min_10.0% Prob": 5.6129311299791524, "Min_20.0% Prob": 3.8325377965674683, "Min_30.0% Prob": 2.7328889850113125, "Min_40.0% Prob": 2.0605427453016594, "Min_50.0% Prob": 1.6508859037567447, "Min_60.0% Prob": 1.376521225061042}}
{"hexsha": "5331daaaa8930389c7c3e413b08b8033ddef4674", "ext": "rs", "lang": "Rust", "content": "pub fn parse_opts() -> Result<CliStatus, Error> {\n    let opt = Opt::from_args();\n    log::debug!(\"Cli opts are: {:?}\", opt);\n\n    match opt.cmd {\n        Command::Generate => {\n            generate_empty_config().context(\"Failed to generate config\")?;\n            log::info!(\"config.yml generated\");\n            Ok(CliStatus::Exit)\n        }\n        Command::Run {\n            config,\n            twil_sid,\n            twil_token,\n            twil_from,\n        } => {\n            if twil_sid.is_none() || twil_token.is_none() || twil_from.is_none() {\n                bail!(\"TWIL_ACCOUNT_SID, TWIL_AUTH_TOKEN & TWIL_FROM env variables must be set, or passed via --twil-sid, --twil-token & --twil-from\");\n            }\n            let twil_sid = twil_sid.unwrap();\n            let twil_token = twil_token.unwrap();\n            let twil_from = twil_from.unwrap();\n\n            let app_config = AppConfig::new(config, twil_sid, twil_token, twil_from)\n                .context(\"Failed to get config\")?;\n\n            Ok(CliStatus::Continue(app_config))\n        }\n    }\n}", "item_id": 0, "repo": "tarkah/nhl-notifier", "file": "src/cli.rs", "last_update_at": "2019-11-24T21:54:07+00:00", "question_id": "5331daaaa8930389c7c3e413b08b8033ddef4674_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse_opts() -> Result<CliStatus, Error> {\n    let opt = Opt::from_args();\n    log::debug!(\"Cli opts are: {:?}\", opt);\n    match opt.cmd {\n        Command::Generate => {\n            generate_empty_config().context(\"Failed to generate config\")?;\n            log::info!(\"config.yml generated\");\n            Ok(CliStatus::Exit)\n        }\n        Command::Run {\n            config,\n            twil_sid,\n            twil_token,\n            twil_from,\n        } => {\n            if twil_sid.is_none() || twil_token.is_none() || twil_from.is_none() {\n                bail!(\"TWIL_ACCOUNT_SID, TWIL_AUTH_TOKEN & TWIL_FROM env variables must be set, or passed via --twil-sid, --twil-token & --twil-from\");\n            }\n            let twil_sid = twil_sid.unwrap();\n            let twil_token = twil_token.unwrap();\n            let twil_from = twil_from.unwrap();\n            let app_config = AppConfig::new(config, twil_sid, twil_token, twil_from)\n                .context(\"Failed to get config\")?;\n            Ok(CliStatus::Continue(app_config))\n        }\n    }\n"]], "pred": {"ppl": 2.0900473594665527, "ppl_lower": 2.5794694423675537, "ppl/lowercase_ppl": -1.2854053148157394, "ppl/zlib": 0.0016201906060479745, "Min_5.0% Prob": 6.353020780226764, "Min_10.0% Prob": 4.798461205819073, "Min_20.0% Prob": 3.1835446772368057, "Min_30.0% Prob": 2.364833679592725, "Min_40.0% Prob": 1.8270932479181152, "Min_50.0% Prob": 1.470837691314303, "Min_60.0% Prob": 1.231431856315025}}
{"hexsha": "dec8765a6119b016dea6eacdbbcd90f8406a09d3", "ext": "rs", "lang": "Rust", "content": "fn solve(players: usize, max_marble: usize) -> usize {\n    let mut scores = vec![0usize; players];\n\n    let mut circle = CircularList::with_capacity(max_marble + 1);\n    circle.insert(0usize);\n\n    for marble in 1..=max_marble {\n        if marble % 23 == 0 {\n            scores[marble % players] += circle.seek(-7).remove().unwrap() + marble;\n        } else {\n            circle.next().insert(marble);\n        }\n    }\n\n    scores.into_iter().max().unwrap()\n}", "item_id": 0, "repo": "EdeMeijer/aoc2018", "file": "src/days/day9.rs", "last_update_at": "2019-03-06T09:35:12+00:00", "question_id": "dec8765a6119b016dea6eacdbbcd90f8406a09d3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn solve(players: usize, max_marble: usize) -> usize {\n    let mut scores = vec![0usize; players];\n    let mut circle = CircularList::with_capacity(max_marble + 1);\n    circle.insert(0usize);\n    for marble in 1..=max_marble {\n        if marble % 23 == 0 {\n            scores[marble % players] += circle.seek(-7).remove().unwrap() + marble;\n        } else {\n            circle.next().insert(marble);\n        }\n    }\n    scores.into_iter().max().unwrap()\n"]], "pred": {"ppl": 1.8849852085113525, "ppl_lower": 2.0832388401031494, "ppl/lowercase_ppl": -1.15775468117241, "ppl/zlib": 0.0025561289271193834, "Min_5.0% Prob": 6.139582335948944, "Min_10.0% Prob": 4.390779510140419, "Min_20.0% Prob": 2.8873953260481358, "Min_30.0% Prob": 2.037815866370996, "Min_40.0% Prob": 1.561419625999406, "Min_50.0% Prob": 1.2606554311700164, "Min_60.0% Prob": 1.0543131181620993}}
{"hexsha": "f703fe03c06d740e5e4f8540ea77fb01065cea1e", "ext": "rs", "lang": "Rust", "content": "fn no_sensors() {\n            let mut status = api::Status {\n                sensors: None,\n                ..api::Status::default()\n            };\n            assert_eq!(status.state, None);\n            StateFromPeopleNowPresent.modify(&mut status);\n            assert_eq!(status.sensors, None);\n            assert_eq!(status.state, None);\n        }", "item_id": 0, "repo": "spaceapi-community/spaceapi-server-rs", "file": "src/modifiers.rs", "last_update_at": "2019-07-08T20:08:16+00:00", "question_id": "f703fe03c06d740e5e4f8540ea77fb01065cea1e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn no_sensors() {\n            let mut status = api::Status {\n                sensors: None,\n                ..api::Status::default()\n            };\n            assert_eq!(status.state, None);\n            StateFromPeopleNowPresent.modify(&mut status);\n            assert_eq!(status.sensors, None);\n            assert_eq!(status.state, None);\n"]], "pred": {"ppl": 4.729131698608398, "ppl_lower": 6.309499263763428, "ppl/lowercase_ppl": -1.185561551998071, "ppl/zlib": 0.010024139434963332, "Min_5.0% Prob": 10.295883655548096, "Min_10.0% Prob": 8.797202640109592, "Min_20.0% Prob": 6.532547076543172, "Min_30.0% Prob": 4.893612331814236, "Min_40.0% Prob": 3.861289479666286, "Min_50.0% Prob": 3.0812878417580025, "Min_60.0% Prob": 2.591136563772505}}
{"hexsha": "00d369fffd7cf57f1580aff9e033cd4f56302c88", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn wlr_pointer_gestures_v1_send_swipe_end(mut gestures:\n                                                                    *mut wlr_pointer_gestures_v1,\n                                                                mut seat:\n                                                                    *mut wlr_seat,\n                                                                mut time_msec:\n                                                                    uint32_t,\n                                                                mut cancelled:\n                                                                    bool) {\n    let mut focus: *mut wlr_surface = (*seat).pointer_state.focused_surface;\n    if focus.is_null() { return }\n    let mut focus_client: *mut wl_client =\n        wl_resource_get_client((*focus).resource);\n    let mut serial: uint32_t =\n        wlr_seat_client_next_serial((*seat).pointer_state.focused_client);\n    let mut gesture: *mut wl_resource = 0 as *mut wl_resource;\n    gesture = 0 as *mut wl_resource;\n    gesture = wl_resource_from_link((*gestures).swipes.next);\n    while wl_resource_get_link(gesture) !=\n              &mut (*gestures).swipes as *mut wl_list {\n        let mut gesture_seat: *mut wlr_seat =\n            seat_from_pointer_resource(gesture);\n        let mut gesture_client: *mut wl_client =\n            wl_resource_get_client(gesture);\n        if !(gesture_seat != seat || gesture_client != focus_client) {\n            zwp_pointer_gesture_swipe_v1_send_end(gesture, serial, time_msec,\n                                                  cancelled as int32_t);\n        }\n        gesture = wl_resource_from_link((*wl_resource_get_link(gesture)).next)\n    };\n}", "item_id": 5, "repo": "RoastVeg/wlrusts", "file": "src/types/wlr_pointer_gestures_v1.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "00d369fffd7cf57f1580aff9e033cd4f56302c88_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn wlr_pointer_gestures_v1_send_swipe_end(mut gestures:\n                                                                    *mut wlr_pointer_gestures_v1,\n                                                                mut seat:\n                                                                    *mut wlr_seat,\n                                                                mut time_msec:\n                                                                    uint32_t,\n                                                                mut cancelled:\n                                                                    bool) {\n    let mut focus: *mut wlr_surface = (*seat).pointer_state.focused_surface;\n    if focus.is_null() { return }\n    let mut focus_client: *mut wl_client =\n        wl_resource_get_client((*focus).resource);\n    let mut serial: uint32_t =\n        wlr_seat_client_next_serial((*seat).pointer_state.focused_client);\n    let mut gesture: *mut wl_resource = 0 as *mut wl_resource;\n    gesture = 0 as *mut wl_resource;\n    gesture = wl_resource_from_link((*gestures).swipes.next);\n    while wl_resource_get_link(gesture) !=\n              &mut (*gestures).swipes as *mut wl_list {\n        let mut gesture_seat: *mut wlr_seat =\n            seat_from_pointer_resource(gesture);\n        let mut gesture_client: *mut wl_client =\n            wl_resource_get_client(gesture);\n        if !(gesture_seat != seat || gesture_client != focus_client) {\n            zwp_pointer_gesture_swipe_v1_send_end(gesture, serial, time_msec,\n                                                  cancelled as int32_t);\n        }\n        gesture = wl_resource_from_link((*wl_resource_get_link(gesture)).next)\n    };\n"]], "pred": {"ppl": 1.501937985420227, "ppl_lower": 1.5232198238372803, "ppl/lowercase_ppl": -1.0345910716335607, "ppl/zlib": 0.000948149800669133, "Min_5.0% Prob": 4.750560159268587, "Min_10.0% Prob": 3.29210221260152, "Min_20.0% Prob": 1.9700101736344788, "Min_30.0% Prob": 1.3421789599986342, "Min_40.0% Prob": 1.0177292728404466, "Min_50.0% Prob": 0.8144887561397236, "Min_60.0% Prob": 0.6782368225207507}}
{"hexsha": "7c101485aa99c1b7d903812912399e3647b750eb", "ext": "rs", "lang": "Rust", "content": "fn test_map_lock() {\n        let lock = Arc::new(MapLock::new());\n        let g = lock.lock(vec![\"test\"]);\n        let g1 = lock.try_lock(vec![\"test\", \"test1\"]);\n        assert_eq!(g1.is_some(), false);\n        drop(g);\n        let g2 = lock.try_lock(vec![\"test\", \"test1\"]);\n        assert_eq!(g2.is_some(), true);\n\n        let lock_1 = lock.clone();\n        let j = go!(move || {\n            let _g = lock_1.lock(vec![\"test\"]);\n            println!(\"comeback in coroutine\");\n        });\n\n        drop(g2);\n        j.join().unwrap();\n    }", "item_id": 0, "repo": "ringringringring/rust-trustnote", "file": "src/utils/map_lock.rs", "last_update_at": "2019-05-28T10:59:27+00:00", "question_id": "7c101485aa99c1b7d903812912399e3647b750eb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_map_lock() {\n        let lock = Arc::new(MapLock::new());\n        let g = lock.lock(vec![\"test\"]);\n        let g1 = lock.try_lock(vec![\"test\", \"test1\"]);\n        assert_eq!(g1.is_some(), false);\n        drop(g);\n        let g2 = lock.try_lock(vec![\"test\", \"test1\"]);\n        assert_eq!(g2.is_some(), true);\n        let lock_1 = lock.clone();\n        let j = go!(move || {\n            let _g = lock_1.lock(vec![\"test\"]);\n            println!(\"comeback in coroutine\");\n        });\n        drop(g2);\n        j.join().unwrap();\n"]], "pred": {"ppl": 2.4110796451568604, "ppl_lower": 2.5841453075408936, "ppl/lowercase_ppl": -1.0787662575428696, "ppl/zlib": 0.003729129799700276, "Min_5.0% Prob": 7.859336906009251, "Min_10.0% Prob": 5.781730727145546, "Min_20.0% Prob": 3.8392602142534757, "Min_30.0% Prob": 2.799015378742887, "Min_40.0% Prob": 2.1649876419258747, "Min_50.0% Prob": 1.755544011373269, "Min_60.0% Prob": 1.4707231093034672}}
{"hexsha": "9cb5ffda8007df05fff157d52a348a054b4035c7", "ext": "rs", "lang": "Rust", "content": "fn test_health_watch_multiple() {\n    let (_server, service, client) = setup();\n\n    // Watch should fetch service status immediately.\n    let mut statuses0 = vec![watch(&client, \"\")];\n    assert_next(ServingStatus::ServiceUnknown, &mut statuses0[0]);\n\n    service.set_serving_status(\"\", ServingStatus::Serving);\n    statuses0.push(watch(&client, \"\"));\n    for s in &mut statuses0 {\n        assert_next(ServingStatus::Serving, s);\n    }\n\n    service.set_serving_status(\"\", ServingStatus::NotServing);\n    statuses0.push(watch(&client, \"\"));\n    for s in &mut statuses0 {\n        assert_next(ServingStatus::NotServing, s);\n    }\n\n    // Multiple watchers for multiple service should work correctly.\n    let mut statuses1 = vec![watch(&client, TEST_SERVICE)];\n    assert_next(ServingStatus::ServiceUnknown, &mut statuses1[0]);\n    service.set_serving_status(TEST_SERVICE, ServingStatus::NotServing);\n    service.set_serving_status(\"\", ServingStatus::Serving);\n    for s in &mut statuses0 {\n        assert_next(ServingStatus::Serving, s);\n    }\n    for s in &mut statuses1 {\n        assert_next(ServingStatus::NotServing, s);\n    }\n}", "item_id": 6, "repo": "tier-cap/grpc-rs", "file": "health/tests/health_check.rs", "last_update_at": "2019-10-21T14:15:04+00:00", "question_id": "9cb5ffda8007df05fff157d52a348a054b4035c7_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_health_watch_multiple() {\n    let (_server, service, client) = setup();\n    // Watch should fetch service status immediately.\n    let mut statuses0 = vec![watch(&client, \"\")];\n    assert_next(ServingStatus::ServiceUnknown, &mut statuses0[0]);\n    service.set_serving_status(\"\", ServingStatus::Serving);\n    statuses0.push(watch(&client, \"\"));\n    for s in &mut statuses0 {\n        assert_next(ServingStatus::Serving, s);\n    }\n    service.set_serving_status(\"\", ServingStatus::NotServing);\n    statuses0.push(watch(&client, \"\"));\n    for s in &mut statuses0 {\n        assert_next(ServingStatus::NotServing, s);\n    }\n    // Multiple watchers for multiple service should work correctly.\n    let mut statuses1 = vec![watch(&client, TEST_SERVICE)];\n    assert_next(ServingStatus::ServiceUnknown, &mut statuses1[0]);\n    service.set_serving_status(TEST_SERVICE, ServingStatus::NotServing);\n    service.set_serving_status(\"\", ServingStatus::Serving);\n    for s in &mut statuses0 {\n        assert_next(ServingStatus::Serving, s);\n    }\n    for s in &mut statuses1 {\n        assert_next(ServingStatus::NotServing, s);\n    }\n"]], "pred": {"ppl": 2.006840229034424, "ppl_lower": 2.2021636962890625, "ppl/lowercase_ppl": -1.1333391537362831, "ppl/zlib": 0.0021366915944374984, "Min_5.0% Prob": 7.0596723556518555, "Min_10.0% Prob": 5.218544006347656, "Min_20.0% Prob": 3.3451465435431036, "Min_30.0% Prob": 2.3196522925640934, "Min_40.0% Prob": 1.7460079995224942, "Min_50.0% Prob": 1.396424319920281, "Min_60.0% Prob": 1.162967441112431}}
{"hexsha": "c67d45ae049dc180a1387fa31f6a877a9ddcce61", "ext": "rs", "lang": "Rust", "content": "fn process_usage_update(current_hour: u64, msg: UpdateUsage, data: &mut UsageTracker) {\n    // history contains a reference to whatever the correct storage array is\n    let history = match msg.kind {\n        UsageType::Client => &mut data.client_bandwidth,\n        UsageType::Relay => &mut data.relay_bandwidth,\n        UsageType::Exit => &mut data.exit_bandwidth,\n    };\n    // we grab the front entry from the VecDeque, if there is an entry one we check if it's\n    // up to date, if it is we add to it, if it's not or there is no entry we create one.\n    // note that price is only sampled once per hour.\n    match history.front_mut() {\n        None => history.push_front(UsageHour {\n            index: current_hour,\n            up: msg.up,\n            down: msg.down,\n            price: msg.price,\n        }),\n        Some(entry) => {\n            if entry.index == current_hour {\n                entry.up += msg.up;\n                entry.down += msg.down;\n            } else {\n                history.push_front(UsageHour {\n                    index: current_hour,\n                    up: msg.up,\n                    down: msg.down,\n                    price: msg.price,\n                })\n            }\n        }\n    }\n    while history.len() > MAX_USAGE_ENTRIES {\n        let _discarded_entry = history.pop_back();\n    }\n}", "item_id": 2, "repo": "althea-mesh/althea_rs", "file": "rita_common/src/usage_tracker/mod.rs", "last_update_at": "2019-06-10T17:42:00+00:00", "question_id": "c67d45ae049dc180a1387fa31f6a877a9ddcce61_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn process_usage_update(current_hour: u64, msg: UpdateUsage, data: &mut UsageTracker) {\n    // history contains a reference to whatever the correct storage array is\n    let history = match msg.kind {\n        UsageType::Client => &mut data.client_bandwidth,\n        UsageType::Relay => &mut data.relay_bandwidth,\n        UsageType::Exit => &mut data.exit_bandwidth,\n    };\n    // we grab the front entry from the VecDeque, if there is an entry one we check if it's\n    // up to date, if it is we add to it, if it's not or there is no entry we create one.\n    // note that price is only sampled once per hour.\n    match history.front_mut() {\n        None => history.push_front(UsageHour {\n            index: current_hour,\n            up: msg.up,\n            down: msg.down,\n            price: msg.price,\n        }),\n        Some(entry) => {\n            if entry.index == current_hour {\n                entry.up += msg.up;\n                entry.down += msg.down;\n            } else {\n                history.push_front(UsageHour {\n                    index: current_hour,\n                    up: msg.up,\n                    down: msg.down,\n                    price: msg.price,\n                })\n            }\n        }\n    }\n    while history.len() > MAX_USAGE_ENTRIES {\n        let _discarded_entry = history.pop_back();\n    }\n"]], "pred": {"ppl": 2.5823824405670166, "ppl_lower": 2.862338066101074, "ppl/lowercase_ppl": -1.1084906206933907, "ppl/zlib": 0.0017601343217325792, "Min_5.0% Prob": 7.901654318759316, "Min_10.0% Prob": 6.171642579530415, "Min_20.0% Prob": 4.136833581485246, "Min_30.0% Prob": 3.0334278533333228, "Min_40.0% Prob": 2.3521849468938614, "Min_50.0% Prob": 1.8982030218173014, "Min_60.0% Prob": 1.584464072239618}}
{"hexsha": "d2f10e3d823b71a17fb7e7635542991e2937228f", "ext": "rs", "lang": "Rust", "content": "fn test_has_permission_b_has_a() {\n        let context = MockTransactionContext::default();\n        let pc = PermissionChecker::new(&context);\n\n        let builder = AgentBuilder::new();\n        let agent = builder\n            .with_org_id(ORG_ID.to_string())\n            .with_public_key(PUBLIC_KEY.to_string())\n            .with_active(true)\n            .with_roles(vec![ROLE_A.to_string()])\n            .build()\n            .unwrap();\n        let builder = AgentListBuilder::new();\n        let agent_list = builder.with_agents(vec![agent.clone()]).build().unwrap();\n        let agent_bytes = agent_list.into_bytes().unwrap();\n        let agent_address = compute_agent_address(PUBLIC_KEY);\n        context.set_state_entry(agent_address, agent_bytes).unwrap();\n\n        let result = pc.has_permission(PUBLIC_KEY, ROLE_B, ORG_ID).unwrap();\n        assert!(!result);\n    }", "item_id": 2, "repo": "target/grid", "file": "sdk/src/permissions.rs", "last_update_at": "2019-12-13T12:46:48+00:00", "question_id": "d2f10e3d823b71a17fb7e7635542991e2937228f_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_has_permission_b_has_a() {\n        let context = MockTransactionContext::default();\n        let pc = PermissionChecker::new(&context);\n        let builder = AgentBuilder::new();\n        let agent = builder\n            .with_org_id(ORG_ID.to_string())\n            .with_public_key(PUBLIC_KEY.to_string())\n            .with_active(true)\n            .with_roles(vec![ROLE_A.to_string()])\n            .build()\n            .unwrap();\n        let builder = AgentListBuilder::new();\n        let agent_list = builder.with_agents(vec![agent.clone()]).build().unwrap();\n        let agent_bytes = agent_list.into_bytes().unwrap();\n        let agent_address = compute_agent_address(PUBLIC_KEY);\n        context.set_state_entry(agent_address, agent_bytes).unwrap();\n        let result = pc.has_permission(PUBLIC_KEY, ROLE_B, ORG_ID).unwrap();\n        assert!(!result);\n"]], "pred": {"ppl": 1.8483878374099731, "ppl_lower": 2.357118844985962, "ppl/lowercase_ppl": -1.395768769980656, "ppl/zlib": 0.0017256006177766067, "Min_5.0% Prob": 6.412139195662278, "Min_10.0% Prob": 4.612931453264677, "Min_20.0% Prob": 2.821590720460965, "Min_30.0% Prob": 1.9932612339152564, "Min_40.0% Prob": 1.529849357619172, "Min_50.0% Prob": 1.2251430802103696, "Min_60.0% Prob": 1.0256174181682305}}
{"hexsha": "8d7634bac46112fcb1e2733661b44d4394ca48ce", "ext": "rs", "lang": "Rust", "content": "fn test_statsd_client_decr() {\n    let client = new_nop_client(\"client.test\");\n    let expected = Counter::new(\"client.test\", \"counter.key\", -1);\n    assert_eq!(expected, client.decr(\"counter.key\").unwrap());\n}", "item_id": 1, "repo": "Geal/cadence", "file": "tests/lib.rs", "last_update_at": "2019-11-13T13:45:14+00:00", "question_id": "8d7634bac46112fcb1e2733661b44d4394ca48ce_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_statsd_client_decr() {\n    let client = new_nop_client(\"client.test\");\n    let expected = Counter::new(\"client.test\", \"counter.key\", -1);\n    assert_eq!(expected, client.decr(\"counter.key\").unwrap());\n"]], "pred": {"ppl": 5.021444797515869, "ppl_lower": 5.359677791595459, "ppl/lowercase_ppl": -1.0403950202565275, "ppl/zlib": 0.011609479860178965, "Min_5.0% Prob": 9.255900700887045, "Min_10.0% Prob": 7.398744106292725, "Min_20.0% Prob": 5.678686874253409, "Min_30.0% Prob": 4.617636430831182, "Min_40.0% Prob": 3.770813988787787, "Min_50.0% Prob": 3.1530532257897512, "Min_60.0% Prob": 2.6851154892217544}}
{"hexsha": "763c7e6f78b7655590063808dc25ddfc9db84990", "ext": "rs", "lang": "Rust", "content": "fn test_regexp() {\n        let db = SqliteConnection::open_in_memory().unwrap();\n        db.create_scalar_function(\"regexp\", 2, true, Some(regexp)).unwrap();\n        let result = db.query_row(\"SELECT regexp('l.s[aeiouy]', 'lisa')\",\n                                           &[],\n                                           |r| r.get::<bool>(0));\n\n        assert_eq!(true, result.unwrap());\n    }", "item_id": 1, "repo": "Dashed/rusqlite", "file": "src/functions.rs", "last_update_at": "2019-06-12T22:17:19+00:00", "question_id": "763c7e6f78b7655590063808dc25ddfc9db84990_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_regexp() {\n        let db = SqliteConnection::open_in_memory().unwrap();\n        db.create_scalar_function(\"regexp\", 2, true, Some(regexp)).unwrap();\n        let result = db.query_row(\"SELECT regexp('l.s[aeiouy]', 'lisa')\",\n                                           &[],\n                                           |r| r.get::<bool>(0));\n        assert_eq!(true, result.unwrap());\n"]], "pred": {"ppl": 3.185399293899536, "ppl_lower": 3.7196168899536133, "ppl/lowercase_ppl": -1.1338218707113785, "ppl/zlib": 0.005242432797139208, "Min_5.0% Prob": 7.359009456634522, "Min_10.0% Prob": 6.208925463936546, "Min_20.0% Prob": 4.592094846393751, "Min_30.0% Prob": 3.554748671395438, "Min_40.0% Prob": 2.796923930340625, "Min_50.0% Prob": 2.2882491461301253, "Min_60.0% Prob": 1.925815328640837}}
{"hexsha": "c93ee20d28973beebaff3bb0a6c9ea476289d1ad", "ext": "rs", "lang": "Rust", "content": "fn apply_blur(pixels: &[Vec<u8>]) -> Vec<Vec<u8>> {\n    let strength = 20; // Amount of blur\n    let mut new_pixels = pixels.to_owned();\n    for (y, row) in pixels.iter().enumerate() {\n        for (x, v) in row.iter().enumerate() {\n            // Each lit pixel will bleed some light to the surrounding pixels\n            if *v == 255 {\n                // Apply bleed to surrounding pixels\n                let co_ords: Vec<(usize, usize)> = vec![\n                    (y.saturating_sub(1), x),\n                    (y+1,                 x),\n                    (y,                   x.saturating_sub(1)),\n                    (y,                   x+1),\n                    (y.saturating_sub(1), x.saturating_sub(1)),\n                    (y.saturating_sub(1), x+1),\n                    (y+1,                 x.saturating_sub(1)),\n                    (y+1,                 x+1),\n                ];\n\n                for (y, x) in co_ords {\n                    if (x < pixels[0].len()) &&\n                       (y < pixels.len()) {\n                        new_pixels[y][x] = new_pixels[y][x].saturating_add(strength);\n                    }\n                }\n            }\n        }\n    }\n    new_pixels\n}", "item_id": 4, "repo": "DavidSpickett/RustChip8", "file": "sdl/mod.rs", "last_update_at": "2019-09-27T13:38:41+00:00", "question_id": "c93ee20d28973beebaff3bb0a6c9ea476289d1ad_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn apply_blur(pixels: &[Vec<u8>]) -> Vec<Vec<u8>> {\n    let strength = 20; // Amount of blur\n    let mut new_pixels = pixels.to_owned();\n    for (y, row) in pixels.iter().enumerate() {\n        for (x, v) in row.iter().enumerate() {\n            // Each lit pixel will bleed some light to the surrounding pixels\n            if *v == 255 {\n                // Apply bleed to surrounding pixels\n                let co_ords: Vec<(usize, usize)> = vec![\n                    (y.saturating_sub(1), x),\n                    (y+1,                 x),\n                    (y,                   x.saturating_sub(1)),\n                    (y,                   x+1),\n                    (y.saturating_sub(1), x.saturating_sub(1)),\n                    (y.saturating_sub(1), x+1),\n                    (y+1,                 x.saturating_sub(1)),\n                    (y+1,                 x+1),\n                ];\n                for (y, x) in co_ords {\n                    if (x < pixels[0].len()) &&\n                       (y < pixels.len()) {\n                        new_pixels[y][x] = new_pixels[y][x].saturating_add(strength);\n                    }\n                }\n            }\n        }\n    }\n    new_pixels\n"]], "pred": {"ppl": 1.7177881002426147, "ppl_lower": 1.8347554206848145, "ppl/lowercase_ppl": -1.1217544346456987, "ppl/zlib": 0.001366256250004713, "Min_5.0% Prob": 6.597226858139038, "Min_10.0% Prob": 4.288127103367367, "Min_20.0% Prob": 2.544282771348953, "Min_30.0% Prob": 1.783509355969727, "Min_40.0% Prob": 1.3493480314314366, "Min_50.0% Prob": 1.080395875454068, "Min_60.0% Prob": 0.9036286128239913}}
{"hexsha": "bdf1312be213b2fabc38569406a808ee67757743", "ext": "rs", "lang": "Rust", "content": "fn expect_env(key: &str) -> String {\n    let value = env::var(key);\n    if value.is_err() {\n        eprintln!(\"{} environment variable is not defined.\", key);\n        eprintln!(\"Make sure you're running cargo via the `napi` wrapper script to assign correct environment variables and options.\");\n        std::process::exit(1);\n    };\n    value.unwrap()\n}", "item_id": 0, "repo": "apcragg/xray", "file": "napi/build.rs", "last_update_at": "2019-07-26T16:29:35+00:00", "question_id": "bdf1312be213b2fabc38569406a808ee67757743_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn expect_env(key: &str) -> String {\n    let value = env::var(key);\n    if value.is_err() {\n        eprintln!(\"{} environment variable is not defined.\", key);\n        eprintln!(\"Make sure you're running cargo via the `napi` wrapper script to assign correct environment variables and options.\");\n        std::process::exit(1);\n    };\n    value.unwrap()\n"]], "pred": {"ppl": 3.9952402114868164, "ppl_lower": 4.3646559715271, "ppl/lowercase_ppl": -1.0638476853155627, "ppl/zlib": 0.006128777457709575, "Min_5.0% Prob": 8.436769723892212, "Min_10.0% Prob": 7.1479828092787, "Min_20.0% Prob": 5.323983907699585, "Min_30.0% Prob": 4.172601897141029, "Min_40.0% Prob": 3.4167417554478896, "Min_50.0% Prob": 2.7690458657840886, "Min_60.0% Prob": 2.308382007325518}}
{"hexsha": "f02f604bf7808c8de5c8ef9656a8dddda99a4198", "ext": "rs", "lang": "Rust", "content": "fn shared_wtypesbase() {\n    use winapi::shared::wtypesbase::*;\n    assert_eq!(size_of::<COAUTHIDENTITY>(), 28);\n    assert_eq!(align_of::<COAUTHIDENTITY>(), 4);\n    assert_eq!(size_of::<COAUTHINFO>(), 28);\n    assert_eq!(align_of::<COAUTHINFO>(), 4);\n    assert_eq!(size_of::<BYTE_BLOB>(), 8);\n    assert_eq!(align_of::<BYTE_BLOB>(), 4);\n    assert_eq!(size_of::<WORD_BLOB>(), 8);\n    assert_eq!(align_of::<WORD_BLOB>(), 4);\n    assert_eq!(size_of::<WORD_BLOB>(), 8);\n    assert_eq!(align_of::<WORD_BLOB>(), 4);\n    assert_eq!(size_of::<FLAGGED_BYTE_BLOB>(), 12);\n    assert_eq!(align_of::<FLAGGED_BYTE_BLOB>(), 4);\n    assert_eq!(size_of::<FLAGGED_WORD_BLOB>(), 12);\n    assert_eq!(align_of::<FLAGGED_WORD_BLOB>(), 4);\n    assert_eq!(size_of::<BYTE_SIZEDARR>(), 8);\n    assert_eq!(align_of::<BYTE_SIZEDARR>(), 4);\n    assert_eq!(size_of::<WORD_SIZEDARR>(), 8);\n    assert_eq!(align_of::<WORD_SIZEDARR>(), 4);\n    assert_eq!(size_of::<DWORD_SIZEDARR>(), 8);\n    assert_eq!(align_of::<DWORD_SIZEDARR>(), 4);\n    assert_eq!(size_of::<HYPER_SIZEDARR>(), 8);\n    assert_eq!(align_of::<HYPER_SIZEDARR>(), 4);\n    assert_eq!(size_of::<BLOB>(), 8);\n    assert_eq!(align_of::<BLOB>(), 4);\n}", "item_id": 14, "repo": "mohandatla/winapi-rs", "file": "tests/structs.rs", "last_update_at": "2019-10-07T18:40:16+00:00", "question_id": "f02f604bf7808c8de5c8ef9656a8dddda99a4198_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn shared_wtypesbase() {\n    use winapi::shared::wtypesbase::*;\n    assert_eq!(size_of::<COAUTHIDENTITY>(), 28);\n    assert_eq!(align_of::<COAUTHIDENTITY>(), 4);\n    assert_eq!(size_of::<COAUTHINFO>(), 28);\n    assert_eq!(align_of::<COAUTHINFO>(), 4);\n    assert_eq!(size_of::<BYTE_BLOB>(), 8);\n    assert_eq!(align_of::<BYTE_BLOB>(), 4);\n    assert_eq!(size_of::<WORD_BLOB>(), 8);\n    assert_eq!(align_of::<WORD_BLOB>(), 4);\n    assert_eq!(size_of::<WORD_BLOB>(), 8);\n    assert_eq!(align_of::<WORD_BLOB>(), 4);\n    assert_eq!(size_of::<FLAGGED_BYTE_BLOB>(), 12);\n    assert_eq!(align_of::<FLAGGED_BYTE_BLOB>(), 4);\n    assert_eq!(size_of::<FLAGGED_WORD_BLOB>(), 12);\n    assert_eq!(align_of::<FLAGGED_WORD_BLOB>(), 4);\n    assert_eq!(size_of::<BYTE_SIZEDARR>(), 8);\n    assert_eq!(align_of::<BYTE_SIZEDARR>(), 4);\n    assert_eq!(size_of::<WORD_SIZEDARR>(), 8);\n    assert_eq!(align_of::<WORD_SIZEDARR>(), 4);\n    assert_eq!(size_of::<DWORD_SIZEDARR>(), 8);\n    assert_eq!(align_of::<DWORD_SIZEDARR>(), 4);\n    assert_eq!(size_of::<HYPER_SIZEDARR>(), 8);\n    assert_eq!(align_of::<HYPER_SIZEDARR>(), 4);\n    assert_eq!(size_of::<BLOB>(), 8);\n    assert_eq!(align_of::<BLOB>(), 4);\n"]], "pred": {"ppl": 1.2464532852172852, "ppl_lower": 1.4191831350326538, "ppl/lowercase_ppl": -1.5890968590328538, "ppl/zlib": 0.0009455027747557992, "Min_5.0% Prob": 3.929689973592758, "Min_10.0% Prob": 2.162824327924422, "Min_20.0% Prob": 1.1005781557677048, "Min_30.0% Prob": 0.7342600269747934, "Min_40.0% Prob": 0.5507435564229907, "Min_50.0% Prob": 0.4406011541804349, "Min_60.0% Prob": 0.3671694921818693}}
{"hexsha": "5176df6ed5a22dfbca02f1bf858b5f0bf670af30", "ext": "rs", "lang": "Rust", "content": "fn from_points_many() {\n        let points = vec![\n            Point::new(0, 0),\n            Point::new(5, 8),\n            Point::new(2, 3),\n            Point::new(8, 14),\n        ];\n\n        let poly = Polynomial::from_points(&points, 3).unwrap();\n        let poly2 = Polynomial::builder()\n            .with(Fraction::new(263, 180), 1)\n            .with(Fraction::new(1, 72), 2)\n            .with(Fraction::new(1, 360), 3)\n            .build();\n\n        assert_eq!(poly, poly2);\n    }", "item_id": 6, "repo": "bilowik/sss-rs", "file": "src/geometry/polynomial.rs", "last_update_at": "2019-12-24T02:53:17+00:00", "question_id": "5176df6ed5a22dfbca02f1bf858b5f0bf670af30_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn from_points_many() {\n        let points = vec![\n            Point::new(0, 0),\n            Point::new(5, 8),\n            Point::new(2, 3),\n            Point::new(8, 14),\n        ];\n        let poly = Polynomial::from_points(&points, 3).unwrap();\n        let poly2 = Polynomial::builder()\n            .with(Fraction::new(263, 180), 1)\n            .with(Fraction::new(1, 72), 2)\n            .with(Fraction::new(1, 360), 3)\n            .build();\n        assert_eq!(poly, poly2);\n"]], "pred": {"ppl": 2.4177982807159424, "ppl_lower": 2.632246971130371, "ppl/lowercase_ppl": -1.0962562307739507, "ppl/zlib": 0.004285715168403371, "Min_5.0% Prob": 7.035311460494995, "Min_10.0% Prob": 5.276998197331148, "Min_20.0% Prob": 3.557078150340489, "Min_30.0% Prob": 2.7361146945219774, "Min_40.0% Prob": 2.142492564661162, "Min_50.0% Prob": 1.7574866877376347, "Min_60.0% Prob": 1.4668273478036835}}
{"hexsha": "dd8027092ca620bcfab27b101d95d4ca23b197f8", "ext": "rs", "lang": "Rust", "content": "fn test_some_floats_f32() {\n    check_value(&Float::from(0.758f32).into());\n    check_value(&Float::from(std::f32::MAX).into());\n    check_value(&Float::from(std::f32::MIN).into());\n    check_value(&Float::from(std::f32::INFINITY).into());\n    check_value(&Float::from(0f32).into());\n\n    // special check for NaN\n    serialize_de_serialize(&Float::from(std::f32::NAN).into(), |result| match result {\n        Value::Float(float) => {\n            let v_float: f32 = f32::try_from(float).unwrap();\n            assert!(v_float.is_nan());\n        }\n        _ => panic!(\"Expected a float!\"),\n    });\n}", "item_id": 0, "repo": "cronosun/liquesco-rust", "file": "serialization/tests/value/float.rs", "last_update_at": "2019-05-30T21:20:19+00:00", "question_id": "dd8027092ca620bcfab27b101d95d4ca23b197f8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_some_floats_f32() {\n    check_value(&Float::from(0.758f32).into());\n    check_value(&Float::from(std::f32::MAX).into());\n    check_value(&Float::from(std::f32::MIN).into());\n    check_value(&Float::from(std::f32::INFINITY).into());\n    check_value(&Float::from(0f32).into());\n    // special check for NaN\n    serialize_de_serialize(&Float::from(std::f32::NAN).into(), |result| match result {\n        Value::Float(float) => {\n            let v_float: f32 = f32::try_from(float).unwrap();\n            assert!(v_float.is_nan());\n        }\n        _ => panic!(\"Expected a float!\"),\n    });\n"]], "pred": {"ppl": 2.5539047718048096, "ppl_lower": 2.9065120220184326, "ppl/lowercase_ppl": -1.137934125359611, "ppl/zlib": 0.003447145114017024, "Min_5.0% Prob": 7.105363607406616, "Min_10.0% Prob": 5.933683100200835, "Min_20.0% Prob": 4.17019740370817, "Min_30.0% Prob": 3.036748607800557, "Min_40.0% Prob": 2.324398184130932, "Min_50.0% Prob": 1.869630036858517, "Min_60.0% Prob": 1.5708982240551939}}
{"hexsha": "34214f6c591acc69b39dc0fa34b94a0a45b7d374", "ext": "rs", "lang": "Rust", "content": "fn kill_timeout_but_kill_not_set() {\n        let args = vec![\n            String::from(\"g-cli\"),\n            String::from(\"--kill-timeout\"),\n            String::from(\"5000\"),\n            String::from(\"test.vi\"),\n            String::from(\"--\"),\n            String::from(\"test1\"),\n        ];\n\n        let config = Configuration::from_arg_array(args);\n        assert_eq!(None, config.kill);\n    }", "item_id": 16, "repo": "JamesMc86/LabVIEW-CLI", "file": "rust-proxy/src/cli.rs", "last_update_at": "2019-04-02T09:55:35+00:00", "question_id": "34214f6c591acc69b39dc0fa34b94a0a45b7d374_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn kill_timeout_but_kill_not_set() {\n        let args = vec![\n            String::from(\"g-cli\"),\n            String::from(\"--kill-timeout\"),\n            String::from(\"5000\"),\n            String::from(\"test.vi\"),\n            String::from(\"--\"),\n            String::from(\"test1\"),\n        ];\n        let config = Configuration::from_arg_array(args);\n        assert_eq!(None, config.kill);\n"]], "pred": {"ppl": 4.054995059967041, "ppl_lower": 5.077504634857178, "ppl/lowercase_ppl": -1.1606275532903079, "ppl/zlib": 0.007864884659041747, "Min_5.0% Prob": 9.154531860351563, "Min_10.0% Prob": 7.531370162963867, "Min_20.0% Prob": 5.589114796031605, "Min_30.0% Prob": 4.2144813222043656, "Min_40.0% Prob": 3.3824261135525173, "Min_50.0% Prob": 2.75172893310848, "Min_60.0% Prob": 2.337858860654866}}
{"hexsha": "af54f0d6ab27c118a850cdea3b333c5b6e72654f", "ext": "rs", "lang": "Rust", "content": "fn initialize_environment() -> OcamlEnvironment {\n    let (task_tx, task_rx) = channel();\n    let spawner = OcamlTaskSpawner { spawned_tasks: Arc::new(Mutex::new(task_tx)) };\n    let executor = OcamlThreadExecutor { ready_tasks: task_rx };\n    thread::spawn(move || {\n        start_ocaml_runtime();\n        executor.run()\n    });\n\n    OcamlEnvironment { spawner }\n}", "item_id": 0, "repo": "mrjoe7/tezedge", "file": "tezos/interop/src/runtime.rs", "last_update_at": "2019-11-29T18:25:07+00:00", "question_id": "af54f0d6ab27c118a850cdea3b333c5b6e72654f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn initialize_environment() -> OcamlEnvironment {\n    let (task_tx, task_rx) = channel();\n    let spawner = OcamlTaskSpawner { spawned_tasks: Arc::new(Mutex::new(task_tx)) };\n    let executor = OcamlThreadExecutor { ready_tasks: task_rx };\n    thread::spawn(move || {\n        start_ocaml_runtime();\n        executor.run()\n    });\n    OcamlEnvironment { spawner }\n"]], "pred": {"ppl": 3.2360622882843018, "ppl_lower": 4.587852478027344, "ppl/lowercase_ppl": -1.2972305046439856, "ppl/zlib": 0.005756653174283004, "Min_5.0% Prob": 8.63558824857076, "Min_10.0% Prob": 7.315446972846985, "Min_20.0% Prob": 5.092426389455795, "Min_30.0% Prob": 3.649891524701505, "Min_40.0% Prob": 2.880778591243588, "Min_50.0% Prob": 2.3263945824676946, "Min_60.0% Prob": 1.9633918534964323}}
{"hexsha": "0a3ed13cc8ad6d16a88dd4fed5e2c3c927369b45", "ext": "rs", "lang": "Rust", "content": "fn new_rect(lat1: i32, lon1: i32, lat2: i32, lon2: i32) -> Rectangle {\n    let mut rect = Rectangle::default();\n    rect.set_lo(new_point(lat1, lon1));\n    rect.set_hi(new_point(lat2, lon2));\n    rect\n}", "item_id": 1, "repo": "tier-cap/grpc-rs", "file": "tests-and-examples/examples/route_guide/client.rs", "last_update_at": "2019-10-21T14:15:04+00:00", "question_id": "0a3ed13cc8ad6d16a88dd4fed5e2c3c927369b45_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn new_rect(lat1: i32, lon1: i32, lat2: i32, lon2: i32) -> Rectangle {\n    let mut rect = Rectangle::default();\n    rect.set_lo(new_point(lat1, lon1));\n    rect.set_hi(new_point(lat2, lon2));\n    rect\n"]], "pred": {"ppl": 1.9914511442184448, "ppl_lower": 2.1476693153381348, "ppl/lowercase_ppl": -1.109629285893935, "ppl/zlib": 0.00560051700151397, "Min_5.0% Prob": 8.089226961135864, "Min_10.0% Prob": 5.717656314373016, "Min_20.0% Prob": 3.401200359358507, "Min_30.0% Prob": 2.322300731562651, "Min_40.0% Prob": 1.744992652109691, "Min_50.0% Prob": 1.391405427574434, "Min_60.0% Prob": 1.1561090654324528}}
{"hexsha": "521446926353aa29f8e0c0f47a9ceb19d7a8585a", "ext": "rs", "lang": "Rust", "content": "fn main() -> std::io::Result<()> {\n    let args: Vec<_> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"usage: {}\u00a0filename\", args[0]);\n        return Result::Err(std::io::Error::new(std::io::ErrorKind::Other, \"\"))\n    }\n\n    let file = File::open(&args[1])?;\n    let buf_reader = BufReader::new(file);\n    let lines = buf_reader.lines().map(|l| l.unwrap());\n\n    let mut freqs = HashMap::new();\n\n    for l in lines {\n        let words = l.split_whitespace();\n        for w in words {\n            let val = match freqs.get(&w.to_string()) {\n                Some(c) => c+1,\n                None => 1,\n            };\n            freqs.insert(w.to_string(), val);\n        }\n    }\n    let mut counts: Vec<_> = freqs.iter().collect();\n    counts.sort_by(|a, b| b.1.cmp(a.1)); // compare by count value\n    for (w, c) in counts.iter().take(25) {\n        println!(\"{}:{}\", w, c);\n    }\n    Ok(())\n}", "item_id": 0, "repo": "elefevre/lost-in-transation", "file": "rust/wordcount/src/main.rs", "last_update_at": "2019-02-21T20:42:03+00:00", "question_id": "521446926353aa29f8e0c0f47a9ceb19d7a8585a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> std::io::Result<()> {\n    let args: Vec<_> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"usage: {}\u00a0filename\", args[0]);\n        return Result::Err(std::io::Error::new(std::io::ErrorKind::Other, \"\"))\n    }\n    let file = File::open(&args[1])?;\n    let buf_reader = BufReader::new(file);\n    let lines = buf_reader.lines().map(|l| l.unwrap());\n    let mut freqs = HashMap::new();\n    for l in lines {\n        let words = l.split_whitespace();\n        for w in words {\n            let val = match freqs.get(&w.to_string()) {\n                Some(c) => c+1,\n                None => 1,\n            };\n            freqs.insert(w.to_string(), val);\n        }\n    }\n    let mut counts: Vec<_> = freqs.iter().collect();\n    counts.sort_by(|a, b| b.1.cmp(a.1)); // compare by count value\n    for (w, c) in counts.iter().take(25) {\n        println!(\"{}:{}\", w, c);\n    }\n    Ok(())\n"]], "pred": {"ppl": 1.7484259605407715, "ppl_lower": 2.089057683944702, "ppl/lowercase_ppl": -1.3185825803343254, "ppl/zlib": 0.001168861782566916, "Min_5.0% Prob": 5.646439731121063, "Min_10.0% Prob": 3.992082767188549, "Min_20.0% Prob": 2.504175193607807, "Min_30.0% Prob": 1.804136105880295, "Min_40.0% Prob": 1.3873265400066856, "Min_50.0% Prob": 1.1130524169722642, "Min_60.0% Prob": 0.9316615634213787}}
{"hexsha": "fdd9b3dd30fa3c3b947a0f31d64c585355c642a6", "ext": "rs", "lang": "Rust", "content": "fn relu_with_threshold_test() {\n        assert_eq!(relu_with_threshold(1.0, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(0.5, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(0.0, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(-10.0, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(10.0, 2.0), 10.0);\n        assert_eq!(relu_with_threshold(1.9, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(2.1, 2.0), 2.1);\n    }", "item_id": 2, "repo": "elbow-jason/lib_annex", "file": "src/activation.rs", "last_update_at": "2019-04-06T01:50:45+00:00", "question_id": "fdd9b3dd30fa3c3b947a0f31d64c585355c642a6_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn relu_with_threshold_test() {\n        assert_eq!(relu_with_threshold(1.0, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(0.5, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(0.0, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(-10.0, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(10.0, 2.0), 10.0);\n        assert_eq!(relu_with_threshold(1.9, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(2.1, 2.0), 2.1);\n"]], "pred": {"ppl": 1.4960834980010986, "ppl_lower": 1.4960834980010986, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.003949516589868528, "Min_5.0% Prob": 5.137920784950256, "Min_10.0% Prob": 3.267426059359596, "Min_20.0% Prob": 1.941123781459672, "Min_30.0% Prob": 1.3336054612882435, "Min_40.0% Prob": 1.0114293018903802, "Min_50.0% Prob": 0.8047091596820783, "Min_60.0% Prob": 0.6731593693803006}}
{"hexsha": "8fe71bc79ab690e4d10c32b6e8d596c010446e03", "ext": "rs", "lang": "Rust", "content": "fn test_parse_deref() {\n        logger_init();\n        let sess = ParseSess::new();\n        let mut conv_map = unwrap_presult!(parse_types_conv_map(\n            &sess,\n            \"deref_code\",\n            r#\"\n#[allow(dead_code)]\n#[swig_code = \"let {to_var}: {to_var_type} = {from_var}.swig_deref();\"]\ntrait SwigDeref {\n    type Target: ?Sized;\n    fn swig_deref(&self) -> &Self::Target;\n}\n\nimpl SwigDeref for String {\n    type Target = str;\n    fn swig_deref(&self) -> &str {\n        &self\n    }\n}\n\"#,\n            HashMap::new(),\n            64\n        ));\n        let (_, code) = unwrap_presult!(conv_map.convert_rust_types(\n            &sess,\n            &rust_type_from_str(\"String\"),\n            &rust_type_from_str(\"&str\"),\n            \"a0\",\n            \"jlong\",\n            DUMMY_SP\n        ));\n        assert_eq!(\"    let a0: &str = a0.swig_deref();\\n\".to_string(), code);\n    }", "item_id": 12, "repo": "rubdos/rust_swig", "file": "macroslib/src/types_conv_map/parsing.rs", "last_update_at": "2019-04-21T12:35:26+00:00", "question_id": "8fe71bc79ab690e4d10c32b6e8d596c010446e03_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_parse_deref() {\n        logger_init();\n        let sess = ParseSess::new();\n        let mut conv_map = unwrap_presult!(parse_types_conv_map(\n            &sess,\n            \"deref_code\",\n            r#\"\n#[allow(dead_code)]\n#[swig_code = \"let {to_var}: {to_var_type} = {from_var}.swig_deref();\"]\ntrait SwigDeref {\n    type Target: ?Sized;\n    fn swig_deref(&self) -> &Self::Target;\n}\nimpl SwigDeref for String {\n    type Target = str;\n    fn swig_deref(&self) -> &str {\n        &self\n    }\n}\n\"#,\n            HashMap::new(),\n            64\n        ));\n        let (_, code) = unwrap_presult!(conv_map.convert_rust_types(\n            &sess,\n            &rust_type_from_str(\"String\"),\n            &rust_type_from_str(\"&str\"),\n            \"a0\",\n            \"jlong\",\n            DUMMY_SP\n        ));\n        assert_eq!(\"    let a0: &str = a0.swig_deref();\\n\".to_string(), code);\n"]], "pred": {"ppl": 2.9668478965759277, "ppl_lower": 3.7006349563598633, "ppl/lowercase_ppl": -1.203222367436586, "ppl/zlib": 0.0027956300126930657, "Min_5.0% Prob": 8.407967656850815, "Min_10.0% Prob": 6.583015337586403, "Min_20.0% Prob": 4.589784005972056, "Min_30.0% Prob": 3.4031085402381662, "Min_40.0% Prob": 2.655746965462925, "Min_50.0% Prob": 2.1630030571960095, "Min_60.0% Prob": 1.8116375443331785}}
{"hexsha": "66aa4ba1a1fd6eb6aa8f48ca4e62531839e0478f", "ext": "rs", "lang": "Rust", "content": "fn test_alloc_fil_second_hole() {\n        let mut alloc = Allocator::new();\n        let first = alloc.alloc(2, 4);\n        let sec = alloc.alloc(3, 8);\n        alloc.free(sec, 3 + 1);\n        alloc.free(first, 2 + 1);\n        println!(\"fail here \\n\\n{}\\n{:?}\\n\\n\", alloc.first_hole, alloc.heap);\n        println!(\"first hole : {}\", alloc.first_hole);\n        // first is before the 3. link to 0\n        assert_eq!(alloc.heap(), vec![3, 3, 0, 7, 4, 0, 0, 0, MAX_HEAP_SIZE]);\n        alloc.alloc(3, 8);\n        assert_eq!(alloc.heap(), vec![7, 3, 0, 8, 4, 0, 0, 0, MAX_HEAP_SIZE]);\n    }", "item_id": 4, "repo": "PBertinJohannet/Eptx", "file": "src/vm/allocator.rs", "last_update_at": "2019-03-27T11:31:05+00:00", "question_id": "66aa4ba1a1fd6eb6aa8f48ca4e62531839e0478f_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_alloc_fil_second_hole() {\n        let mut alloc = Allocator::new();\n        let first = alloc.alloc(2, 4);\n        let sec = alloc.alloc(3, 8);\n        alloc.free(sec, 3 + 1);\n        alloc.free(first, 2 + 1);\n        println!(\"fail here \\n\\n{}\\n{:?}\\n\\n\", alloc.first_hole, alloc.heap);\n        println!(\"first hole : {}\", alloc.first_hole);\n        // first is before the 3. link to 0\n        assert_eq!(alloc.heap(), vec![3, 3, 0, 7, 4, 0, 0, 0, MAX_HEAP_SIZE]);\n        alloc.alloc(3, 8);\n        assert_eq!(alloc.heap(), vec![7, 3, 0, 8, 4, 0, 0, 0, MAX_HEAP_SIZE]);\n"]], "pred": {"ppl": 3.651123523712158, "ppl_lower": 3.88236141204834, "ppl/lowercase_ppl": -1.0474185238229534, "ppl/zlib": 0.004814256263735427, "Min_5.0% Prob": 9.371439774831137, "Min_10.0% Prob": 7.120557884375255, "Min_20.0% Prob": 5.067452400922775, "Min_30.0% Prob": 3.907707298795382, "Min_40.0% Prob": 3.105524023063481, "Min_50.0% Prob": 2.5506165829797585, "Min_60.0% Prob": 2.1481251686087086}}
{"hexsha": "186bc91dc8abcb946bf0553c183033ccbe3646a3", "ext": "rs", "lang": "Rust", "content": "fn test_edge_inserted_without_adding_nodes_directed() {\n    let mut net: Network<usize, f64> = Network::new(true);\n\n    net.add_edge(0, 1, 10.0);\n\n    check_network(net, 2, 1, vec![0, 1], vec![(0, 1, vec![&10.0])]);\n}", "item_id": 4, "repo": "pbielak/rusty-nets", "file": "tests/unit/network/model_tests.rs", "last_update_at": "2019-02-20T11:27:22+00:00", "question_id": "186bc91dc8abcb946bf0553c183033ccbe3646a3_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_edge_inserted_without_adding_nodes_directed() {\n    let mut net: Network<usize, f64> = Network::new(true);\n    net.add_edge(0, 1, 10.0);\n    check_network(net, 2, 1, vec![0, 1], vec![(0, 1, vec![&10.0])]);\n"]], "pred": {"ppl": 3.5972912311553955, "ppl_lower": 4.171658515930176, "ppl/lowercase_ppl": -1.1157121854642007, "ppl/zlib": 0.007853871941411088, "Min_5.0% Prob": 7.5605308532714846, "Min_10.0% Prob": 6.602181816101075, "Min_20.0% Prob": 4.89817590713501, "Min_30.0% Prob": 3.769387118021647, "Min_40.0% Prob": 2.9952359654009344, "Min_50.0% Prob": 2.4779413241147994, "Min_60.0% Prob": 2.110858597854773}}
{"hexsha": "5e7e45fc371bccafaa17f418793da5254d860ceb", "ext": "rs", "lang": "Rust", "content": "fn named_target() {\n        let yaml = r#\"\n            targets:\n                config_json:\n                    type: fileset\n                    format: json\n                    location:\n                        path: /somewhere\n                        partition: 0\n        \"#;\n        let mapping: Mapping = serde_yaml::from_str(yaml).unwrap();\n        assert_eq!(mapping.target_count(), 1);\n\n        let target = mapping.named_target(\"config_json\").unwrap();\n        assert_eq!(target.type_(), Type::FileSet);\n        assert_eq!(target.format(), Format::Json);\n        assert_eq!(target.location().path(), \"/somewhere\");\n        assert_eq!(target.location().partition(), &Partition::Index(0));\n    }", "item_id": 0, "repo": "DalavanCloud/reconfix", "file": "src/types/mapping/mod.rs", "last_update_at": "2019-01-25T06:45:48+00:00", "question_id": "5e7e45fc371bccafaa17f418793da5254d860ceb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn named_target() {\n        let yaml = r#\"\n            targets:\n                config_json:\n                    type: fileset\n                    format: json\n                    location:\n                        path: /somewhere\n                        partition: 0\n        \"#;\n        let mapping: Mapping = serde_yaml::from_str(yaml).unwrap();\n        assert_eq!(mapping.target_count(), 1);\n        let target = mapping.named_target(\"config_json\").unwrap();\n        assert_eq!(target.type_(), Type::FileSet);\n        assert_eq!(target.format(), Format::Json);\n        assert_eq!(target.location().path(), \"/somewhere\");\n        assert_eq!(target.location().partition(), &Partition::Index(0));\n"]], "pred": {"ppl": 2.5539145469665527, "ppl_lower": 2.8206872940063477, "ppl/lowercase_ppl": -1.105962441736959, "ppl/zlib": 0.0033972003570327063, "Min_5.0% Prob": 7.410956223805745, "Min_10.0% Prob": 5.777035713195801, "Min_20.0% Prob": 3.985304716471079, "Min_30.0% Prob": 2.972588975321163, "Min_40.0% Prob": 2.289009310707853, "Min_50.0% Prob": 1.8677949288293072, "Min_60.0% Prob": 1.5572083781028654}}
{"hexsha": "2bb96d68f3d3067c15c34ee49864a6e598781ac0", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<()> {\n    let mut byte_array_test = Vec::new();\n    for i in 0i32..1000 {\n        let value = (i * i * 255 + i * 7) % 100;\n        byte_array_test.push(value as i8)\n    }\n    let byte_array_test = byte_array_test.into_boxed_slice();\n    let value = TestStruct {\n        nested: Nested {\n            egg: Food {\n                name: \"Eggbert\",\n                value: 0.5,\n            },\n            ham: Food {\n                name: \"Hampus\",\n                value: 0.75,\n            },\n        },\n        byte_test: 127,\n        short_test: 32767,\n        int_test: 2147483647,\n        long_test: 9223372036854775807,\n        double_test: 0.49312871321823148,\n        float_test: 0.49823147058486938,\n        string_test: \"HELLO WORLD THIS IS A TEST STRING!\",\n        list_long_test: [11, 12, 13, 14, 15],\n        list_compound_test: vec![\n            NestedCompound {\n                created_on: 1264099775885,\n                name: \"Compound tag #0\",\n            },\n            NestedCompound {\n                created_on: 1264099775885,\n                name: \"Compound tag #1\",\n            },\n        ],\n        byte_array_test,\n    };\n    println!(\"{}\", to_string_transcript((\"Level\", &value))?);\n    Ok(())\n}", "item_id": 0, "repo": "luojia65/coruscant", "file": "coruscant-nbt/examples/nbt-ser-big.rs", "last_update_at": "2019-10-19T20:58:42+00:00", "question_id": "2bb96d68f3d3067c15c34ee49864a6e598781ac0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<()> {\n    let mut byte_array_test = Vec::new();\n    for i in 0i32..1000 {\n        let value = (i * i * 255 + i * 7) % 100;\n        byte_array_test.push(value as i8)\n    }\n    let byte_array_test = byte_array_test.into_boxed_slice();\n    let value = TestStruct {\n        nested: Nested {\n            egg: Food {\n                name: \"Eggbert\",\n                value: 0.5,\n            },\n            ham: Food {\n                name: \"Hampus\",\n                value: 0.75,\n            },\n        },\n        byte_test: 127,\n        short_test: 32767,\n        int_test: 2147483647,\n        long_test: 9223372036854775807,\n        double_test: 0.49312871321823148,\n        float_test: 0.49823147058486938,\n        string_test: \"HELLO WORLD THIS IS A TEST STRING!\",\n        list_long_test: [11, 12, 13, 14, 15],\n        list_compound_test: vec![\n            NestedCompound {\n                created_on: 1264099775885,\n                name: \"Compound tag #0\",\n            },\n            NestedCompound {\n                created_on: 1264099775885,\n                name: \"Compound tag #1\",\n            },\n        ],\n        byte_array_test,\n    };\n    println!(\"{}\", to_string_transcript((\"Level\", &value))?);\n    Ok(())\n"]], "pred": {"ppl": 2.213939905166626, "ppl_lower": 2.5600523948669434, "ppl/lowercase_ppl": -1.182761502918753, "ppl/zlib": 0.0015402590907239524, "Min_5.0% Prob": 7.792816877365112, "Min_10.0% Prob": 5.531536688407262, "Min_20.0% Prob": 3.500307902232888, "Min_30.0% Prob": 2.5467832531422783, "Min_40.0% Prob": 1.9711297735953943, "Min_50.0% Prob": 1.5882104425538393, "Min_60.0% Prob": 1.3252463767053908}}
{"hexsha": "1a4b0fbeaf4cc15e38e56c6224e190fb3a4a79bc", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    if pkg_config::find_library(\"ao\").is_ok() {\n        return;\n    }\n    let source = PathBuf::from(&get!(\"CARGO_MANIFEST_DIR\")).join(\"source\");\n    let output = PathBuf::from(&get!(\"OUT_DIR\"));\n    let build = output.join(\"build\");\n    ok!(fs::create_dir_all(&build));\n    run!(cmd!(source.join(\"configure\")).current_dir(&build)\n                                       .arg(&format!(\"--prefix={}\", output.display())));\n    run!(cmd!(\"make\").current_dir(&build).arg(\"install\"));\n    println!(\"cargo:rustc-link-lib=dylib=ao\");\n    println!(\"cargo:rustc-link-search={}\", output.join(\"lib\").display());\n}", "item_id": 0, "repo": "stainless-steel/ao-sys", "file": "build.rs", "last_update_at": "2019-09-05T15:02:49+00:00", "question_id": "1a4b0fbeaf4cc15e38e56c6224e190fb3a4a79bc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    if pkg_config::find_library(\"ao\").is_ok() {\n        return;\n    }\n    let source = PathBuf::from(&get!(\"CARGO_MANIFEST_DIR\")).join(\"source\");\n    let output = PathBuf::from(&get!(\"OUT_DIR\"));\n    let build = output.join(\"build\");\n    ok!(fs::create_dir_all(&build));\n    run!(cmd!(source.join(\"configure\")).current_dir(&build)\n                                       .arg(&format!(\"--prefix={}\", output.display())));\n    run!(cmd!(\"make\").current_dir(&build).arg(\"install\"));\n    println!(\"cargo:rustc-link-lib=dylib=ao\");\n    println!(\"cargo:rustc-link-search={}\", output.join(\"lib\").display());\n"]], "pred": {"ppl": 2.2153406143188477, "ppl_lower": 2.681812047958374, "ppl/lowercase_ppl": -1.2402376837969091, "ppl/zlib": 0.0025250989456855003, "Min_5.0% Prob": 7.411092281341553, "Min_10.0% Prob": 5.689243578910828, "Min_20.0% Prob": 3.539337342977524, "Min_30.0% Prob": 2.543814951678117, "Min_40.0% Prob": 1.9617935579270125, "Min_50.0% Prob": 1.58395320892334, "Min_60.0% Prob": 1.3237895656221856}}
{"hexsha": "35ba411ab6ccdfa2e343b301a029ad3aa9c7fb1a", "ext": "rs", "lang": "Rust", "content": "pub fn outgoing_metrics<A: Account + CcpRoutingAccount>(\n    request: OutgoingRequest<A>,\n    mut next: impl OutgoingService<A>,\n) -> impl Future<Item = Fulfill, Error = Reject> {\n    let labels = labels!(\n        \"from_asset_code\" => request.from.asset_code().to_string(),\n        \"to_asset_code\" => request.to.asset_code().to_string(),\n        \"from_routing_relation\" => request.from.routing_relation().to_string(),\n        \"to_routing_relation\" => request.to.routing_relation().to_string(),\n    );\n\n    // TODO replace these calls with the counter! macro if there's a way to easily pass in the already-created labels\n    // right now if you pass the labels into one of the other macros, it gets a recursion limit error while expanding the macro\n    recorder().increment_counter(\n        Key::from_name_and_labels(\"requests.outgoing.prepare\", labels.clone()),\n        1,\n    );\n    let start_time = Instant::now();\n\n    next.send_request(request).then(move |result| {\n        if result.is_ok() {\n            recorder().increment_counter(\n                Key::from_name_and_labels(\"requests.outgoing.fulfill\", labels.clone()),\n                1,\n            );\n        } else {\n            recorder().increment_counter(\n                Key::from_name_and_labels(\"requests.outgoing.reject\", labels.clone()),\n                1,\n            );\n        }\n\n        recorder().record_histogram(\n            Key::from_name_and_labels(\"requests.outgoing.duration\", labels.clone()),\n            (Instant::now() - start_time).as_nanos() as u64,\n        );\n        result\n    })\n}", "item_id": 1, "repo": "dora-gt/interledger-rs", "file": "crates/ilp-node/src/metrics.rs", "last_update_at": "2019-04-16T14:29:42+00:00", "question_id": "35ba411ab6ccdfa2e343b301a029ad3aa9c7fb1a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn outgoing_metrics<A: Account + CcpRoutingAccount>(\n    request: OutgoingRequest<A>,\n    mut next: impl OutgoingService<A>,\n) -> impl Future<Item = Fulfill, Error = Reject> {\n    let labels = labels!(\n        \"from_asset_code\" => request.from.asset_code().to_string(),\n        \"to_asset_code\" => request.to.asset_code().to_string(),\n        \"from_routing_relation\" => request.from.routing_relation().to_string(),\n        \"to_routing_relation\" => request.to.routing_relation().to_string(),\n    );\n    // TODO replace these calls with the counter! macro if there's a way to easily pass in the already-created labels\n    // right now if you pass the labels into one of the other macros, it gets a recursion limit error while expanding the macro\n    recorder().increment_counter(\n        Key::from_name_and_labels(\"requests.outgoing.prepare\", labels.clone()),\n        1,\n    );\n    let start_time = Instant::now();\n    next.send_request(request).then(move |result| {\n        if result.is_ok() {\n            recorder().increment_counter(\n                Key::from_name_and_labels(\"requests.outgoing.fulfill\", labels.clone()),\n                1,\n            );\n        } else {\n            recorder().increment_counter(\n                Key::from_name_and_labels(\"requests.outgoing.reject\", labels.clone()),\n                1,\n            );\n        }\n        recorder().record_histogram(\n            Key::from_name_and_labels(\"requests.outgoing.duration\", labels.clone()),\n            (Instant::now() - start_time).as_nanos() as u64,\n        );\n        result\n    })\n"]], "pred": {"ppl": 2.4832348823547363, "ppl_lower": 2.941002368927002, "ppl/lowercase_ppl": -1.1860107925921637, "ppl/zlib": 0.0015628214746531254, "Min_5.0% Prob": 7.731661536476829, "Min_10.0% Prob": 5.970120090908474, "Min_20.0% Prob": 4.0480665789710155, "Min_30.0% Prob": 2.9256221376083515, "Min_40.0% Prob": 2.2604157887399197, "Min_50.0% Prob": 1.8154154717098032, "Min_60.0% Prob": 1.5163456993761757}}
{"hexsha": "d0cc772e8eed7bca68870c18551d47f163eb1e24", "ext": "rs", "lang": "Rust", "content": "fn test_invalid_url() {\n        let request_params = RequestParams::default();\n        let response = Response {\n            apps: vec![App {\n                update_check: Some(UpdateCheck::ok(vec![\"invalid-url\".to_string()])),\n                ..App::default()\n            }],\n            ..Response::default()\n        };\n        assert_eq!(\n            FuchsiaInstallPlan::try_create_from(&request_params, &response),\n            Err(InstallPlanErrors::Failed)\n        );\n    }", "item_id": 7, "repo": "zhangpf/fuchsia-rs", "file": "garnet/bin/omaha_client/src/install_plan.rs", "last_update_at": "2019-04-21T18:02:26+00:00", "question_id": "d0cc772e8eed7bca68870c18551d47f163eb1e24_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_invalid_url() {\n        let request_params = RequestParams::default();\n        let response = Response {\n            apps: vec![App {\n                update_check: Some(UpdateCheck::ok(vec![\"invalid-url\".to_string()])),\n                ..App::default()\n            }],\n            ..Response::default()\n        };\n        assert_eq!(\n            FuchsiaInstallPlan::try_create_from(&request_params, &response),\n            Err(InstallPlanErrors::Failed)\n        );\n"]], "pred": {"ppl": 3.2517316341400146, "ppl_lower": 5.123013973236084, "ppl/lowercase_ppl": -1.3854817015642347, "ppl/zlib": 0.004813010877359789, "Min_5.0% Prob": 7.540838718414307, "Min_10.0% Prob": 6.235929727554321, "Min_20.0% Prob": 4.58913818359375, "Min_30.0% Prob": 3.6311844377904325, "Min_40.0% Prob": 2.8255527031421663, "Min_50.0% Prob": 2.3319046156060312, "Min_60.0% Prob": 1.9540315675735473}}
{"hexsha": "d71b9abfbd1798542832aeae848148e506f4dc81", "ext": "rs", "lang": "Rust", "content": "fn should_be_able_to_get_correct_matrix_representation_of_connections() {\n        let mut organism = NeuralNetwork::with_neurons(3);\n        organism.add_connection(0, 1, 1.0);\n        organism.add_connection(1, 2, 0.5);\n        organism.add_connection(2, 1, 0.5);\n        organism.add_connection(2, 2, 0.75);\n        organism.add_connection(1, 0, 1.0);\n        let nn = organism.make_network();\n        assert_eq!(\n            organism.get_weights(),\n            vec![0.0, 1.0, 0.0, 1.0, 0.0, 0.5, 0.0, 0.5, 0.75]\n        );\n    }", "item_id": 13, "repo": "playXE/rustneat", "file": "src/nn/mod.rs", "last_update_at": "2019-07-30T05:52:26+00:00", "question_id": "d71b9abfbd1798542832aeae848148e506f4dc81_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn should_be_able_to_get_correct_matrix_representation_of_connections() {\n        let mut organism = NeuralNetwork::with_neurons(3);\n        organism.add_connection(0, 1, 1.0);\n        organism.add_connection(1, 2, 0.5);\n        organism.add_connection(2, 1, 0.5);\n        organism.add_connection(2, 2, 0.75);\n        organism.add_connection(1, 0, 1.0);\n        let nn = organism.make_network();\n        assert_eq!(\n            organism.get_weights(),\n            vec![0.0, 1.0, 0.0, 1.0, 0.0, 0.5, 0.0, 0.5, 0.75]\n        );\n"]], "pred": {"ppl": 2.1598424911499023, "ppl_lower": 2.280519962310791, "ppl/lowercase_ppl": -1.0706047793650189, "ppl/zlib": 0.0033334861397112184, "Min_5.0% Prob": 7.208944147283381, "Min_10.0% Prob": 5.209191625768488, "Min_20.0% Prob": 3.325862391428514, "Min_30.0% Prob": 2.4326063597744163, "Min_40.0% Prob": 1.8999279348010367, "Min_50.0% Prob": 1.5307439335764528, "Min_60.0% Prob": 1.2833768366871023}}
{"hexsha": "f9d636c2729fa87c771437d2527eaa8d7c4f40cf", "ext": "rs", "lang": "Rust", "content": "fn polygon_with_point_on_interior_ring() {\n        let poly = holy_polygon();\n        let p = poly.interiors()[0].0[3];\n        let should_be = Closest::Intersection(p.into());\n\n        let got = poly.closest_point(&p.into());\n\n        assert_eq!(got, should_be);\n    }", "item_id": 6, "repo": "phreeheeler/geo", "file": "geo/src/algorithm/closest_point.rs", "last_update_at": "2019-04-21T09:54:39+00:00", "question_id": "f9d636c2729fa87c771437d2527eaa8d7c4f40cf_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn polygon_with_point_on_interior_ring() {\n        let poly = holy_polygon();\n        let p = poly.interiors()[0].0[3];\n        let should_be = Closest::Intersection(p.into());\n        let got = poly.closest_point(&p.into());\n        assert_eq!(got, should_be);\n"]], "pred": {"ppl": 4.525984764099121, "ppl_lower": 5.31437349319458, "ppl/lowercase_ppl": -1.106355945838144, "ppl/zlib": 0.009436469880623103, "Min_5.0% Prob": 11.358651638031006, "Min_10.0% Prob": 8.305262406667074, "Min_20.0% Prob": 5.9082500272327, "Min_30.0% Prob": 4.4904123456389815, "Min_40.0% Prob": 3.561317037891697, "Min_50.0% Prob": 2.960966725712237, "Min_60.0% Prob": 2.5134428376501257}}
{"hexsha": "0b18c2571246b24f06e847aab245d829fafa3049", "ext": "rs", "lang": "Rust", "content": "pub fn update_registry_and_shuffling_data(\n    state: &mut BeaconState,\n    current_total_balance: u64,\n    spec: &ChainSpec,\n) -> Result<(), Error> {\n    // First set previous shuffling data to current shuffling data.\n    state.previous_shuffling_epoch = state.current_shuffling_epoch;\n    state.previous_shuffling_start_shard = state.previous_shuffling_start_shard;\n    state.previous_shuffling_seed = state.previous_shuffling_seed;\n\n    let current_epoch = state.current_epoch(spec);\n    let next_epoch = current_epoch + 1;\n\n    // Check we should update, and if so, update.\n    if should_update_validator_registry(state, spec)? {\n        update_validator_registry(state, current_total_balance, spec)?;\n\n        // If we update the registry, update the shuffling data and shards as well.\n        state.current_shuffling_epoch = next_epoch;\n        state.current_shuffling_start_shard = {\n            let active_validators =\n                state.get_cached_active_validator_indices(RelativeEpoch::Current, spec)?;\n            let epoch_committee_count = spec.get_epoch_committee_count(active_validators.len());\n\n            (state.current_shuffling_start_shard + epoch_committee_count) % spec.shard_count\n        };\n        state.current_shuffling_seed = state.generate_seed(state.current_shuffling_epoch, spec)?;\n    } else {\n        // If processing at least on crosslink keeps failing, the reshuffle every power of two, but\n        // don't update the current_shuffling_start_shard.\n        let epochs_since_last_update = current_epoch - state.validator_registry_update_epoch;\n\n        if epochs_since_last_update > 1 && epochs_since_last_update.is_power_of_two() {\n            state.current_shuffling_epoch = next_epoch;\n            state.current_shuffling_seed =\n                state.generate_seed(state.current_shuffling_epoch, spec)?;\n        }\n    }\n\n    Ok(())\n}", "item_id": 0, "repo": "zedt3ster/lighthouse", "file": "eth2/state_processing/src/per_epoch_processing/update_registry_and_shuffling_data.rs", "last_update_at": "2019-04-15T06:39:50+00:00", "question_id": "0b18c2571246b24f06e847aab245d829fafa3049_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn update_registry_and_shuffling_data(\n    state: &mut BeaconState,\n    current_total_balance: u64,\n    spec: &ChainSpec,\n) -> Result<(), Error> {\n    // First set previous shuffling data to current shuffling data.\n    state.previous_shuffling_epoch = state.current_shuffling_epoch;\n    state.previous_shuffling_start_shard = state.previous_shuffling_start_shard;\n    state.previous_shuffling_seed = state.previous_shuffling_seed;\n    let current_epoch = state.current_epoch(spec);\n    let next_epoch = current_epoch + 1;\n    // Check we should update, and if so, update.\n    if should_update_validator_registry(state, spec)? {\n        update_validator_registry(state, current_total_balance, spec)?;\n        // If we update the registry, update the shuffling data and shards as well.\n        state.current_shuffling_epoch = next_epoch;\n        state.current_shuffling_start_shard = {\n            let active_validators =\n                state.get_cached_active_validator_indices(RelativeEpoch::Current, spec)?;\n            let epoch_committee_count = spec.get_epoch_committee_count(active_validators.len());\n            (state.current_shuffling_start_shard + epoch_committee_count) % spec.shard_count\n        };\n        state.current_shuffling_seed = state.generate_seed(state.current_shuffling_epoch, spec)?;\n    } else {\n        // If processing at least on crosslink keeps failing, the reshuffle every power of two, but\n        // don't update the current_shuffling_start_shard.\n        let epochs_since_last_update = current_epoch - state.validator_registry_update_epoch;\n        if epochs_since_last_update > 1 && epochs_since_last_update.is_power_of_two() {\n            state.current_shuffling_epoch = next_epoch;\n            state.current_shuffling_seed =\n                state.generate_seed(state.current_shuffling_epoch, spec)?;\n        }\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.039152145385742, "ppl_lower": 2.261648178100586, "ppl/lowercase_ppl": -1.145340022935961, "ppl/zlib": 0.0011836114725204002, "Min_5.0% Prob": 6.978317133585612, "Min_10.0% Prob": 5.155986257394155, "Min_20.0% Prob": 3.2568398540218673, "Min_30.0% Prob": 2.3139643561508922, "Min_40.0% Prob": 1.7705339076307913, "Min_50.0% Prob": 1.4228454164912303, "Min_60.0% Prob": 1.1871585303943397}}
{"hexsha": "e2f89e943d304541c8ccd8a980ecf9d1ce9c654c", "ext": "rs", "lang": "Rust", "content": "fn find_cycle(moons: &Vec<Vec<Moon1D>>, axis_index: usize) -> usize {\n    let mut cloned = moons.clone();\n    let original: Vec<Moon1D> = cloned.iter().map(|m| m[axis_index]).collect();\n    let mut moons: Vec<&mut Moon1D> = cloned.iter_mut().map(|m| &mut m[axis_index]).collect();\n\n    let mut counter = 0;\n\n    loop {\n        update_velocities_1d(&mut moons);\n        update_positions_1d(&mut moons);\n\n        counter += 1;\n\n        let mut done = true;\n        for i in 0..original.len() {\n            if moons[i] != &original[i] {\n                done = false;\n                break;\n            }\n        }\n\n        if done {\n            break;\n        }\n    }\n\n    counter\n}", "item_id": 2, "repo": "gentoid/aoc-2019-rust", "file": "src/aoc_12.rs", "last_update_at": "2019-12-06T13:12:12+00:00", "question_id": "e2f89e943d304541c8ccd8a980ecf9d1ce9c654c_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn find_cycle(moons: &Vec<Vec<Moon1D>>, axis_index: usize) -> usize {\n    let mut cloned = moons.clone();\n    let original: Vec<Moon1D> = cloned.iter().map(|m| m[axis_index]).collect();\n    let mut moons: Vec<&mut Moon1D> = cloned.iter_mut().map(|m| &mut m[axis_index]).collect();\n    let mut counter = 0;\n    loop {\n        update_velocities_1d(&mut moons);\n        update_positions_1d(&mut moons);\n        counter += 1;\n        let mut done = true;\n        for i in 0..original.len() {\n            if moons[i] != &original[i] {\n                done = false;\n                break;\n            }\n        }\n        if done {\n            break;\n        }\n    }\n    counter\n"]], "pred": {"ppl": 1.9428801536560059, "ppl_lower": 2.08988881111145, "ppl/lowercase_ppl": -1.1098200963289158, "ppl/zlib": 0.0022438225926016495, "Min_5.0% Prob": 6.999135407534513, "Min_10.0% Prob": 4.952467498571976, "Min_20.0% Prob": 3.050520491092763, "Min_30.0% Prob": 2.1775225311517716, "Min_40.0% Prob": 1.6525009439346638, "Min_50.0% Prob": 1.324586436357665, "Min_60.0% Prob": 1.1104741868272372}}
{"hexsha": "795715f1939b533a655add7d1fe557971f48d9a7", "ext": "rs", "lang": "Rust", "content": "fn test_functional_process_file_green() {\n        Command::cargo_bin(\"stevia\")\n            .unwrap()\n            .arg(\"examples/example.ink\")\n            .assert()\n            .success();\n\n        // Check contents of output file\n        let expected = \"P;Hello there|P;I'm a VN written in the Ink format|P;Do you like it?|Q;Yes, I like it!;00120;No, I do not like it;00136|P;Thank you!|E;|P;Oh, I see|E;\";\n        let contents = read_to_string(\"example.stevia\").expect(\"Cannot find .stevia file\");\n\n        assert_eq!(expected, contents);\n\n        clean();\n    }", "item_id": 1, "repo": "Pomettini/visual-novel-text-baker", "file": "src/bin/stevia.rs", "last_update_at": "2019-09-29T16:27:31+00:00", "question_id": "795715f1939b533a655add7d1fe557971f48d9a7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_functional_process_file_green() {\n        Command::cargo_bin(\"stevia\")\n            .unwrap()\n            .arg(\"examples/example.ink\")\n            .assert()\n            .success();\n        // Check contents of output file\n        let expected = \"P;Hello there|P;I'm a VN written in the Ink format|P;Do you like it?|Q;Yes, I like it!;00120;No, I do not like it;00136|P;Thank you!|E;|P;Oh, I see|E;\";\n        let contents = read_to_string(\"example.stevia\").expect(\"Cannot find .stevia file\");\n        assert_eq!(expected, contents);\n        clean();\n"]], "pred": {"ppl": 5.378599643707275, "ppl_lower": 6.187199115753174, "ppl/lowercase_ppl": -1.0832454308234731, "ppl/zlib": 0.005176701695442524, "Min_5.0% Prob": 8.283832179175484, "Min_10.0% Prob": 7.076332913504706, "Min_20.0% Prob": 5.5867368015083105, "Min_30.0% Prob": 4.618630946766246, "Min_40.0% Prob": 3.855915475536037, "Min_50.0% Prob": 3.2458856246804677, "Min_60.0% Prob": 2.787049597716546}}
{"hexsha": "a084fb80681ade4e35fc1fa32ee0cd38df7eaf71", "ext": "rs", "lang": "Rust", "content": "fn it_should_know_if_input_is_less_than_8_in_immediate_mode() {\n        let program: Vec<i32> = vec![3, 3, 1107, -1, 8, 3, 4, 3, 99];\n        assert_eq!(run_program(&mut program.clone(), &mut vec![7]), 1);\n        assert_eq!(run_program(&mut program.clone(), &mut vec![8]), 0);\n    }", "item_id": 5, "repo": "paulsouche/adventofcode2019", "file": "src/bin/day05-sunny-with-a-chance-of-asteroids/main.rs", "last_update_at": "2019-12-01T11:34:37+00:00", "question_id": "a084fb80681ade4e35fc1fa32ee0cd38df7eaf71_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_should_know_if_input_is_less_than_8_in_immediate_mode() {\n        let program: Vec<i32> = vec![3, 3, 1107, -1, 8, 3, 4, 3, 99];\n        assert_eq!(run_program(&mut program.clone(), &mut vec![7]), 1);\n        assert_eq!(run_program(&mut program.clone(), &mut vec![8]), 0);\n"]], "pred": {"ppl": 2.4911789894104004, "ppl_lower": 2.6740236282348633, "ppl/lowercase_ppl": -1.0775981970546353, "ppl/zlib": 0.00536915345963989, "Min_5.0% Prob": 7.8008973598480225, "Min_10.0% Prob": 6.024825255076091, "Min_20.0% Prob": 4.024679844578107, "Min_30.0% Prob": 2.918933365907934, "Min_40.0% Prob": 2.2698407884066305, "Min_50.0% Prob": 1.8167043180495013, "Min_60.0% Prob": 1.5235449617652044}}
{"hexsha": "96186abbda429901a23f60fa088fec1ae6f38405", "ext": "rs", "lang": "Rust", "content": "fn last_day_of_solar_month(timestamp: i64, longitude: f64) -> usize {\n    // HACK: This rely on an undefined behavior when getting a timestamp for\n    // day following the last day of the month.\n    let format = String::from(\"%h:%y:%s:%d:%c:%b\");\n    for i in 88..100 {\n        let a = get_formatted_date(&format!(\"%h:%y:%s:{:02}:50:00\", i), timestamp, longitude);\n        let t = get_timestamp(format.clone(), a.clone(), longitude);\n        let b = get_formatted_date(&format, t, longitude);\n        if a != b {\n            return i - 1;\n        }\n    }\n    unreachable!();\n}", "item_id": 1, "repo": "vinc/geocal", "file": "src/main.rs", "last_update_at": "2019-12-10T04:12:25+00:00", "question_id": "96186abbda429901a23f60fa088fec1ae6f38405_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn last_day_of_solar_month(timestamp: i64, longitude: f64) -> usize {\n    // HACK: This rely on an undefined behavior when getting a timestamp for\n    // day following the last day of the month.\n    let format = String::from(\"%h:%y:%s:%d:%c:%b\");\n    for i in 88..100 {\n        let a = get_formatted_date(&format!(\"%h:%y:%s:{:02}:50:00\", i), timestamp, longitude);\n        let t = get_timestamp(format.clone(), a.clone(), longitude);\n        let b = get_formatted_date(&format, t, longitude);\n        if a != b {\n            return i - 1;\n        }\n    }\n    unreachable!();\n"]], "pred": {"ppl": 4.753880023956299, "ppl_lower": 5.131952285766602, "ppl/lowercase_ppl": -1.0490871876140333, "ppl/zlib": 0.004949082957959297, "Min_5.0% Prob": 9.359964423709446, "Min_10.0% Prob": 7.807335577513042, "Min_20.0% Prob": 5.922502150902381, "Min_30.0% Prob": 4.663064812791759, "Min_40.0% Prob": 3.7124565045038858, "Min_50.0% Prob": 3.0448996336484444, "Min_60.0% Prob": 2.588020402906287}}
{"hexsha": "ad84a70282b8c08846b32a8b2fca20191e7dbc30", "ext": "rs", "lang": "Rust", "content": "fn tuple_without_element() {\n            let mut heap = RegionHeap::default();\n            let lhs = heap.tuple_from_slice(&[]).unwrap();\n            let rhs = heap.tuple_from_slice(&[]).unwrap();\n\n            assert_eq!(lhs, lhs);\n            assert_eq!(lhs, rhs);\n            assert_eq!(rhs, lhs);\n        }", "item_id": 8, "repo": "bitwalker/lumen", "file": "liblumen_alloc/src/erts/term/tuple.rs", "last_update_at": "2019-12-15T01:06:38+00:00", "question_id": "ad84a70282b8c08846b32a8b2fca20191e7dbc30_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn tuple_without_element() {\n            let mut heap = RegionHeap::default();\n            let lhs = heap.tuple_from_slice(&[]).unwrap();\n            let rhs = heap.tuple_from_slice(&[]).unwrap();\n            assert_eq!(lhs, lhs);\n            assert_eq!(lhs, rhs);\n            assert_eq!(rhs, lhs);\n"]], "pred": {"ppl": 2.4559953212738037, "ppl_lower": 3.059664726257324, "ppl/lowercase_ppl": -1.2445914139594918, "ppl/zlib": 0.006239806286557444, "Min_5.0% Prob": 8.337499141693115, "Min_10.0% Prob": 6.4780527750651045, "Min_20.0% Prob": 4.176412542661031, "Min_30.0% Prob": 2.877351587372167, "Min_40.0% Prob": 2.236906329924996, "Min_50.0% Prob": 1.782614457638974, "Min_60.0% Prob": 1.5035630202120436}}
{"hexsha": "b8ef5fd1940b3ac7cf801c21a9bce0be53947648", "ext": "rs", "lang": "Rust", "content": "fn get_value(cpu: cpu_state, v: value) -> u16 {\n    alt v {\n      value_reg(t)     { cpu.regs[t] }\n      value_mem(t)     { cpu.mem[t] }\n      value_sp         { cpu.sp }", "item_id": 1, "repo": "jamorton/rust-dcpu16", "file": "emu.rs", "last_update_at": "2019-09-16T15:23:47+00:00", "question_id": "b8ef5fd1940b3ac7cf801c21a9bce0be53947648_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_value(cpu: cpu_state, v: value) -> u16 {\n    alt v {\n      value_reg(t)     { cpu.regs[t] }\n      value_mem(t)     { cpu.mem[t] }\n"]], "pred": {"ppl": 4.654128551483154, "ppl_lower": 4.654128551483154, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.014645282725888158, "Min_5.0% Prob": 10.55688730875651, "Min_10.0% Prob": 8.336669921875, "Min_20.0% Prob": 6.1821199996130805, "Min_30.0% Prob": 4.651998985381353, "Min_40.0% Prob": 3.683366507291794, "Min_50.0% Prob": 3.0244426812444414, "Min_60.0% Prob": 2.559471763315655}}
{"hexsha": "12d2341080374528fc5e5df648a6876f10f81621", "ext": "rs", "lang": "Rust", "content": "pub fn check_config(spec: &Spec) -> Result<bool, Error> {\n    let deploy_config = render_deploy_config(&spec)\n        .map_err(|e| format_err!(\"{}\", e))?;\n    let ref filename = spec.config.vagga_config;\n    let mut buf = String::with_capacity(1024);\n    let mut f = match File::open(&filename) {\n        Ok(f) => f,\n        Err(ref e) if e.kind() == io::ErrorKind::NotFound => return Ok(false),\n        Err(e) => bail!(\"Can't open file {:?}: {}\", filename, e),\n    };\n    f.read_to_string(&mut buf)\n        .map_err(|e| format_err!(\"Error reading {:?}: {}\", filename, e))?;\n    return Ok(deploy_config == buf);\n}", "item_id": 0, "repo": "tailhook/wark", "file": "src/local/mod.rs", "last_update_at": "2019-05-21T00:13:12+00:00", "question_id": "12d2341080374528fc5e5df648a6876f10f81621_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn check_config(spec: &Spec) -> Result<bool, Error> {\n    let deploy_config = render_deploy_config(&spec)\n        .map_err(|e| format_err!(\"{}\", e))?;\n    let ref filename = spec.config.vagga_config;\n    let mut buf = String::with_capacity(1024);\n    let mut f = match File::open(&filename) {\n        Ok(f) => f,\n        Err(ref e) if e.kind() == io::ErrorKind::NotFound => return Ok(false),\n        Err(e) => bail!(\"Can't open file {:?}: {}\", filename, e),\n    };\n    f.read_to_string(&mut buf)\n        .map_err(|e| format_err!(\"Error reading {:?}: {}\", filename, e))?;\n    return Ok(deploy_config == buf);\n"]], "pred": {"ppl": 2.3538291454315186, "ppl_lower": 3.050706386566162, "ppl/lowercase_ppl": -1.3029399356450044, "ppl/zlib": 0.002555353509473507, "Min_5.0% Prob": 8.503142261505127, "Min_10.0% Prob": 6.037404639380319, "Min_20.0% Prob": 3.8464058211871555, "Min_30.0% Prob": 2.7513148826546967, "Min_40.0% Prob": 2.1255138874053956, "Min_50.0% Prob": 1.704550993776767, "Min_60.0% Prob": 1.4293815247729071}}
{"hexsha": "ab5293ee458ad84b43eb8071de56c5dbee8e5e61", "ext": "rs", "lang": "Rust", "content": "fn insert_two_items_and_get_list_entries() {\n        let mut table = InvertibleBloomLookupTable::<DefaultHasher>::new(256, 8).unwrap();\n        assert!(table.insert(4, 6).is_ok());\n        assert!(table.insert(5, 7).is_ok());\n        let results = table.list_entries().ok().unwrap();\n        assert_eq!(results.key_pairs.len(), 2);\n        for output in results.key_pairs {\n            if output.key_sum == 4 {\n                assert_eq!(output.value_sum, 6);\n            } else if output.key_sum == 5 {\n                assert_eq!(output.value_sum, 7);\n            }\n        }\n    }", "item_id": 4, "repo": "elniallo/IBLT", "file": "src/iblt.rs", "last_update_at": "2019-02-04T13:11:27+00:00", "question_id": "ab5293ee458ad84b43eb8071de56c5dbee8e5e61_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn insert_two_items_and_get_list_entries() {\n        let mut table = InvertibleBloomLookupTable::<DefaultHasher>::new(256, 8).unwrap();\n        assert!(table.insert(4, 6).is_ok());\n        assert!(table.insert(5, 7).is_ok());\n        let results = table.list_entries().ok().unwrap();\n        assert_eq!(results.key_pairs.len(), 2);\n        for output in results.key_pairs {\n            if output.key_sum == 4 {\n                assert_eq!(output.value_sum, 6);\n            } else if output.key_sum == 5 {\n                assert_eq!(output.value_sum, 7);\n            }\n        }\n"]], "pred": {"ppl": 2.6717259883880615, "ppl_lower": 3.1967573165893555, "ppl/lowercase_ppl": -1.1825661409482813, "ppl/zlib": 0.003779710389076538, "Min_5.0% Prob": 7.506417433420817, "Min_10.0% Prob": 6.074460305665669, "Min_20.0% Prob": 4.28511538317329, "Min_30.0% Prob": 3.139547502785398, "Min_40.0% Prob": 2.435785046141399, "Min_50.0% Prob": 1.9543692610847454, "Min_60.0% Prob": 1.6378646644075279}}
{"hexsha": "cd2364b37d17ebebef7c057656e96f18c3f124f2", "ext": "rs", "lang": "Rust", "content": "pub fn platform() -> String {\n\tlet env = Target::env();\n\tlet env_dash = if env.is_empty() { \"\" } else { \"-\" };\n\tformat!(\"{}-{}{}{}\", Target::arch(), Target::os(), env_dash, env)\n}", "item_id": 0, "repo": "HPIPS/HPIPS_Chain", "file": "core/service/src/config.rs", "last_update_at": "2019-08-07T10:22:08+00:00", "question_id": "cd2364b37d17ebebef7c057656e96f18c3f124f2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn platform() -> String {\n\tlet env = Target::env();\n\tlet env_dash = if env.is_empty() { \"\" } else { \"-\" };\n\tformat!(\"{}-{}{}{}\", Target::arch(), Target::os(), env_dash, env)\n"]], "pred": {"ppl": 4.528109073638916, "ppl_lower": 4.3720574378967285, "ppl/lowercase_ppl": -0.9767790382306475, "ppl/zlib": 0.01118744021712539, "Min_5.0% Prob": 10.035309155782064, "Min_10.0% Prob": 9.1839919090271, "Min_20.0% Prob": 6.0957391659418745, "Min_30.0% Prob": 4.531200001114293, "Min_40.0% Prob": 3.6613641285896303, "Min_50.0% Prob": 2.9626052863895893, "Min_60.0% Prob": 2.5263884861610437}}
{"hexsha": "77a16e6f9acfb714a3642fbd3355c499f2af936f", "ext": "rs", "lang": "Rust", "content": "fn multiply_assign_vector_by_vector_component_wise() {\n        let mut v1 = Vec3::new(1., 2., 3.);\n        let v2 = Vec3::new(3., 2., 1.);\n        v1 *= v2;\n        assert_eq!(v1.x(), 3.);\n        assert_eq!(v1.y(), 4.);\n        assert_eq!(v1.z(), 3.);\n    }", "item_id": 8, "repo": "FractalArt/raytracer.rs", "file": "src/vec3.rs", "last_update_at": "2019-12-04T11:19:11+00:00", "question_id": "77a16e6f9acfb714a3642fbd3355c499f2af936f_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn multiply_assign_vector_by_vector_component_wise() {\n        let mut v1 = Vec3::new(1., 2., 3.);\n        let v2 = Vec3::new(3., 2., 1.);\n        v1 *= v2;\n        assert_eq!(v1.x(), 3.);\n        assert_eq!(v1.y(), 4.);\n        assert_eq!(v1.z(), 3.);\n"]], "pred": {"ppl": 1.9275039434432983, "ppl_lower": 2.01773738861084, "ppl/lowercase_ppl": -1.0697182305198003, "ppl/zlib": 0.004621308960128411, "Min_5.0% Prob": 7.5611883163452145, "Min_10.0% Prob": 4.8900862607088955, "Min_20.0% Prob": 3.1447092701088297, "Min_30.0% Prob": 2.1494193576714573, "Min_40.0% Prob": 1.6496704038646486, "Min_50.0% Prob": 1.3089330476104168, "Min_60.0% Prob": 1.0991304100504802}}
{"hexsha": "9082b1af96e07a420786ee77cf1d8f83d61e92ba", "ext": "rs", "lang": "Rust", "content": "fn handle_err<A: AsRef<str>>(o: io::Result<Output>, cmd: A) -> Output {\n    let o = match o {\n        Err(e) => {\n            eprintln!(\"{}\", cmd.as_ref());\n            eprintln!(\"\\tIO Error on exec:\\n{:?}\", e);\n            ::std::process::exit(1);\n        }\n        Ok(o) => o,\n    };\n    if !o.status.success() {\n        let stderr = String::from_utf8_lossy(o.stderr.as_slice());\n        let stdout = String::from_utf8_lossy(o.stdout.as_slice());\n        eprintln!(\"{}\", cmd.as_ref());\n        match o.status.code() {\n            Option::Some(x) => eprintln!(\"\\tExit Code: {:?}\", x),\n            _ => {}\n        };\n        eprintln!(\"\\tStdErr:\\n {}\", stderr);\n        eprintln!(\"\\tStdOut:\\n {}\", stdout);\n        ::std::process::exit(1);\n    }\n    o\n}", "item_id": 0, "repo": "Phantomical/xed-sys", "file": "build.rs", "last_update_at": "2019-06-24T02:19:09+00:00", "question_id": "9082b1af96e07a420786ee77cf1d8f83d61e92ba_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn handle_err<A: AsRef<str>>(o: io::Result<Output>, cmd: A) -> Output {\n    let o = match o {\n        Err(e) => {\n            eprintln!(\"{}\", cmd.as_ref());\n            eprintln!(\"\\tIO Error on exec:\\n{:?}\", e);\n            ::std::process::exit(1);\n        }\n        Ok(o) => o,\n    };\n    if !o.status.success() {\n        let stderr = String::from_utf8_lossy(o.stderr.as_slice());\n        let stdout = String::from_utf8_lossy(o.stdout.as_slice());\n        eprintln!(\"{}\", cmd.as_ref());\n        match o.status.code() {\n            Option::Some(x) => eprintln!(\"\\tExit Code: {:?}\", x),\n            _ => {}\n        };\n        eprintln!(\"\\tStdErr:\\n {}\", stderr);\n        eprintln!(\"\\tStdOut:\\n {}\", stdout);\n        ::std::process::exit(1);\n    }\n    o\n"]], "pred": {"ppl": 1.941498875617981, "ppl_lower": 2.245720386505127, "ppl/lowercase_ppl": -1.219404334339359, "ppl/zlib": 0.0019804784807726517, "Min_5.0% Prob": 6.765774176670955, "Min_10.0% Prob": 5.071759168918316, "Min_20.0% Prob": 3.1216264929411546, "Min_30.0% Prob": 2.18633626778669, "Min_40.0% Prob": 1.6488548571349315, "Min_50.0% Prob": 1.3296374024287092, "Min_60.0% Prob": 1.1051563960822217}}
{"hexsha": "55fd51ac5eb0db8c567c311373a2941b8af58c04", "ext": "rs", "lang": "Rust", "content": "pub fn cross_word<T>(first: T, second: T, bit_index: u8) -> (T, T) \r\n    where T: PrimInt + FromPrimitive + ToPrimitive {\r\n    let bit_mask = T::from_u32(2_u32.pow(bit_index.to_u32().unwrap()) - 1).unwrap();\r\n\r\n    let first_result  = (first  & !bit_mask) | (second & bit_mask);\r\n    let second_result = (second & !bit_mask) | (first  & bit_mask);\r\n\r\n    (first_result, second_result)\r\n}", "item_id": 7, "repo": "nsmryan/rgep", "file": "src/crossover.rs", "last_update_at": "2019-04-12T16:06:04+00:00", "question_id": "55fd51ac5eb0db8c567c311373a2941b8af58c04_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn cross_word<T>(first: T, second: T, bit_index: u8) -> (T, T) \r\n    where T: PrimInt + FromPrimitive + ToPrimitive {\r\n    let bit_mask = T::from_u32(2_u32.pow(bit_index.to_u32().unwrap()) - 1).unwrap();\r\n\r\n    let first_result  = (first  & !bit_mask) | (second & bit_mask);\r\n    let second_result = (second & !bit_mask) | (first  & bit_mask);\r\n\r\n    (first_result, second_result)\r\n"]], "pred": {"ppl": 2.4387896060943604, "ppl_lower": 2.8977859020233154, "ppl/lowercase_ppl": -1.1934321387807358, "ppl/zlib": 0.004146520247204817, "Min_5.0% Prob": 8.219317981175013, "Min_10.0% Prob": 5.808043003082275, "Min_20.0% Prob": 3.898936152458191, "Min_30.0% Prob": 2.8759876595603093, "Min_40.0% Prob": 2.198957470108251, "Min_50.0% Prob": 1.7838393530661338, "Min_60.0% Prob": 1.4961976775960935}}
{"hexsha": "bbf08393c0cea4fb3d6e0589ed2718bd1e720180", "ext": "rs", "lang": "Rust", "content": "pub fn minimize1d<F>(mut begin: f64, mut end: f64, iterations: usize, function: F) -> f64\n    where F: Fn(f64) -> f64\n{\n    let mut x1 = 0.0;\n    let mut y1 = 0.0;\n    let mut x2 = 0.0;\n    let mut y2 = 0.0;\n    let mut is1 = false;\n    let mut is2 = false;\n    let inverted_phi = 2.0 / (1.0 + 5.0f64.sqrt());\n    (0..iterations)\n        .for_each(|_| {\n            if !is1 {\n                x1 = end - (end  - begin) * inverted_phi;\n                y1 = function(x1);\n                is1 = true;\n            }\n            if !is2 {\n                x2 = begin + (end - begin) * inverted_phi;\n                y2 = function(x2);\n                is2 = true;\n            }\n            if y1 < y2 {\n                end = x2;\n                x2 = x1;\n                y2 = y1;\n                is1 = false;\n            } else {\n                begin = x1;\n                x1 = x2;\n                y1 = y2;\n                is2 = false;\n            }\n        });\n    (begin + end) / 2.0\n}", "item_id": 0, "repo": "elsid/CodeBall", "file": "src/optimization.rs", "last_update_at": "2019-12-05T09:54:16+00:00", "question_id": "bbf08393c0cea4fb3d6e0589ed2718bd1e720180_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn minimize1d<F>(mut begin: f64, mut end: f64, iterations: usize, function: F) -> f64\n    where F: Fn(f64) -> f64\n{\n    let mut x1 = 0.0;\n    let mut y1 = 0.0;\n    let mut x2 = 0.0;\n    let mut y2 = 0.0;\n    let mut is1 = false;\n    let mut is2 = false;\n    let inverted_phi = 2.0 / (1.0 + 5.0f64.sqrt());\n    (0..iterations)\n        .for_each(|_| {\n            if !is1 {\n                x1 = end - (end  - begin) * inverted_phi;\n                y1 = function(x1);\n                is1 = true;\n            }\n            if !is2 {\n                x2 = begin + (end - begin) * inverted_phi;\n                y2 = function(x2);\n                is2 = true;\n            }\n            if y1 < y2 {\n                end = x2;\n                x2 = x1;\n                y2 = y1;\n                is1 = false;\n            } else {\n                begin = x1;\n                x1 = x2;\n                y1 = y2;\n                is2 = false;\n            }\n        });\n    (begin + end) / 2.0\n"]], "pred": {"ppl": 1.7296180725097656, "ppl_lower": 1.8525362014770508, "ppl/lowercase_ppl": -1.1253055774134124, "ppl/zlib": 0.0016503030626554116, "Min_5.0% Prob": 6.982649073881261, "Min_10.0% Prob": 4.508141589164734, "Min_20.0% Prob": 2.600252453344209, "Min_30.0% Prob": 1.7912680588307834, "Min_40.0% Prob": 1.3610834793054631, "Min_50.0% Prob": 1.0949914624541999, "Min_60.0% Prob": 0.9145386812410184}}
{"hexsha": "0fdf076499d7999f24b7275c91703c6682d5c793", "ext": "rs", "lang": "Rust", "content": "fn main() {\r\n    stdweb::initialize();\r\n\r\n    assert!(\r\n        !cluster::is_worker(),\r\n        \"This module should not be instantiated as a worker!\"\r\n    );\r\n\r\n    cluster::setup_master(\r\n        cluster::ClusterSettingsBuilder::new()\r\n            .exec(node_rs::dirname().join(\"worker.js\"))\r\n            .build(),\r\n    );\r\n\r\n    println!(\"I'm the master!\");\r\n\r\n    let args: Vec<_> = std::env::args().collect();\r\n\r\n    let num_procs = if args.len() >= 2 {\r\n        args[1].parse().expect(\"First argument must be an integer.\")\r\n    } else {\r\n        4\r\n    };\r\n\r\n    let workers: Vec<_> = (0..num_procs).map(|_| cluster::fork()).collect();\r\n\r\n    let promises: Vec<_> = workers\r\n        .iter()\r\n        .cloned()\r\n        .map(|worker| {\r\n            Promise::new(move |resolve, _| {\r\n                worker.on_exit(move |_, _| {\r\n                    resolve.complete();\r\n                });\r\n            })\r\n        })\r\n        .collect();\r\n\r\n    Promise::all(&promises).then(|_| {\r\n        println!(\"Master exiting...\");\r\n        stdweb::Value::Undefined\r\n    });\r\n\r\n    stdweb::event_loop();\r\n}", "item_id": 0, "repo": "AndrewGaspar/node-rs", "file": "examples/master.rs", "last_update_at": "2019-04-03T22:49:34+00:00", "question_id": "0fdf076499d7999f24b7275c91703c6682d5c793_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\r\n    stdweb::initialize();\r\n\r\n    assert!(\r\n        !cluster::is_worker(),\r\n        \"This module should not be instantiated as a worker!\"\r\n    );\r\n\r\n    cluster::setup_master(\r\n        cluster::ClusterSettingsBuilder::new()\r\n            .exec(node_rs::dirname().join(\"worker.js\"))\r\n            .build(),\r\n    );\r\n\r\n    println!(\"I'm the master!\");\r\n\r\n    let args: Vec<_> = std::env::args().collect();\r\n\r\n    let num_procs = if args.len() >= 2 {\r\n        args[1].parse().expect(\"First argument must be an integer.\")\r\n    } else {\r\n        4\r\n    };\r\n\r\n    let workers: Vec<_> = (0..num_procs).map(|_| cluster::fork()).collect();\r\n\r\n    let promises: Vec<_> = workers\r\n        .iter()\r\n        .cloned()\r\n        .map(|worker| {\r\n            Promise::new(move |resolve, _| {\r\n                worker.on_exit(move |_, _| {\r\n                    resolve.complete();\r\n                });\r\n            })\r\n        })\r\n        .collect();\r\n\r\n    Promise::all(&promises).then(|_| {\r\n        println!(\"Master exiting...\");\r\n        stdweb::Value::Undefined\r\n    });\r\n\r\n    stdweb::event_loop();\r\n"]], "pred": {"ppl": 2.2917141914367676, "ppl_lower": 2.6458377838134766, "ppl/lowercase_ppl": -1.1732637752310875, "ppl/zlib": 0.0016519922166354439, "Min_5.0% Prob": 7.260594283833223, "Min_10.0% Prob": 5.363093095667222, "Min_20.0% Prob": 3.5381191778874053, "Min_30.0% Prob": 2.6373305115306263, "Min_40.0% Prob": 2.0415133849002314, "Min_50.0% Prob": 1.6572592687944687, "Min_60.0% Prob": 1.3811639807938378}}
{"hexsha": "5c5a296736c56916cf1a8908600471af2952d7c2", "ext": "rs", "lang": "Rust", "content": "pub fn save(new_todo: NewTodo) -> Todo {\n    let mut todos = TODOS.write().unwrap();\n    todos.counter += 1;\n    let todo = Todo {\n        id: todos.counter,\n        title: new_todo.title,\n        completed: new_todo.completed.unwrap_or(false),\n        order: new_todo.order.unwrap_or(0),\n    };\n\n    todos.db.insert(todo.id, todo.clone());\n    todo\n}", "item_id": 0, "repo": "ubnt-intrepid/finchers-todo", "file": "src/todo.rs", "last_update_at": "2019-09-25T11:36:15+00:00", "question_id": "5c5a296736c56916cf1a8908600471af2952d7c2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn save(new_todo: NewTodo) -> Todo {\n    let mut todos = TODOS.write().unwrap();\n    todos.counter += 1;\n    let todo = Todo {\n        id: todos.counter,\n        title: new_todo.title,\n        completed: new_todo.completed.unwrap_or(false),\n        order: new_todo.order.unwrap_or(0),\n    };\n    todos.db.insert(todo.id, todo.clone());\n    todo\n"]], "pred": {"ppl": 2.2460434436798096, "ppl_lower": 2.602968692779541, "ppl/lowercase_ppl": -1.1822637561000604, "ppl/zlib": 0.004236493187530495, "Min_5.0% Prob": 8.47865112622579, "Min_10.0% Prob": 6.083295981089274, "Min_20.0% Prob": 3.76829430103302, "Min_30.0% Prob": 2.6434158871048377, "Min_40.0% Prob": 2.00619656168947, "Min_50.0% Prob": 1.6111538379336707, "Min_60.0% Prob": 1.3608678958721852}}
{"hexsha": "e53601326c2b64b9489b460595926388bfcd2363", "ext": "rs", "lang": "Rust", "content": "async fn handle_schedule_request(\r\n    query: web::Query<DateBasedQuery>,\r\n) -> Result<HttpResponse, KretaError> {\r\n    let request_started = Instant::now();\r\n\r\n    let lessons: Vec<Lesson> = get_schedule(\r\n        query.token.clone(),\r\n        query.url.clone(),\r\n        query.from_date.clone(),\r\n        query.to_date.clone(),\r\n    )\r\n    .await?;\r\n\r\n    info!(\r\n        \"Schedule request done for {} in {}\",\r\n        &query.url,\r\n        request_started.elapsed().as_millis()\r\n    );\r\n\r\n    Ok(HttpResponse::build(StatusCode::OK).json(lessons))\r\n}", "item_id": 4, "repo": "hazizz/kreta-proxy", "file": "src/kreta_proxy.rs", "last_update_at": "2019-09-30T19:20:34+00:00", "question_id": "e53601326c2b64b9489b460595926388bfcd2363_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn handle_schedule_request(\r\n    query: web::Query<DateBasedQuery>,\r\n) -> Result<HttpResponse, KretaError> {\r\n    let request_started = Instant::now();\r\n\r\n    let lessons: Vec<Lesson> = get_schedule(\r\n        query.token.clone(),\r\n        query.url.clone(),\r\n        query.from_date.clone(),\r\n        query.to_date.clone(),\r\n    )\r\n    .await?;\r\n\r\n    info!(\r\n        \"Schedule request done for {} in {}\",\r\n        &query.url,\r\n        request_started.elapsed().as_millis()\r\n    );\r\n\r\n    Ok(HttpResponse::build(StatusCode::OK).json(lessons))\r\n"]], "pred": {"ppl": 2.7227132320404053, "ppl_lower": 4.142911911010742, "ppl/lowercase_ppl": -1.4190873565806, "ppl/zlib": 0.0034069010030720937, "Min_5.0% Prob": 8.991661442650688, "Min_10.0% Prob": 6.836519028011121, "Min_20.0% Prob": 4.410204696027856, "Min_30.0% Prob": 3.1790962925082757, "Min_40.0% Prob": 2.461771936989144, "Min_50.0% Prob": 1.9942006036639213, "Min_60.0% Prob": 1.6679635588651556}}
{"hexsha": "0c77eac154be90b49ab4c1b601b57a7fd90e0ef1", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // initialize logger\n    simple_logger::init().unwrap();\n\n    // setup of main data structures\n    let mut ecs_ = ecs::ECS::new();\n    let mut render_conf = RenderConfig {\n        scale: 100.0,\n        window_xs: 1000,\n        window_ys: 1000,\n        focused_entity: None\n    };\n\n    info!(\"Creating window with {:?}\", render_conf);\n    \n    // setup of opengl window\n    let opengl  = OpenGL::V3_2;\n\tlet mut window: Window = WindowSettings::new(\n            \"rustac\",\n            [render_conf.window_xs, render_conf.window_ys]\n        )\n        .graphics_api(opengl)\n        .exit_on_esc(true)\n        .build()\n        .unwrap();\n\n\n\tlet ref mut gl  = GlGraphics::new(opengl);\n    let sprite_textures = sprite::setup_sprite_textures();\n\t\n    // BEGIN test code\n\n    use crate::builder::dungeon;\n\n    dungeon::create_empty_room(&mut ecs_, 0.0, 0.0, 10, 8);\n    dungeon::create_empty_room(&mut ecs_, 0.0, 8.0, 8, 10);\n    dungeon::delete_dungeon_entities(&mut ecs_, \n                                     gamestate::dungeon::DungeonElement::Wall,\n                                     LocationVec { x: 4.0, y: 7.0 });\n    dungeon::delete_dungeon_entities(&mut ecs_, \n                                     gamestate::dungeon::DungeonElement::Wall,\n                                     LocationVec { x: 4.0, y: 8.0 });\n    dungeon::create_attack_dummy(&mut ecs_, 3.0, 4.0);\n\n    \n    // player\n    let player = create_test_dummy_player(&mut ecs_);\n\n    render_conf.focused_entity = Some(player);\n\n    // END test code\n\n\t//Main loop\n\n    let mut events = Events::new(EventSettings::new());\n    events.set_ups(UPDATES_PER_SECOND);\n\n    let mut button_buffer: Option<Button> = None;\n\n    while let Some(e) = events.next(&mut window) {\n\n        if e.press_args().is_some() || button_buffer.is_some() {\n            debug!(\"{:?}\", &button_buffer);\n            if let Some(p) = e.press_args() {\n                button_buffer = input::handle_input(&p, &mut ecs_);\n            } else {\n                button_buffer = input::handle_input(&button_buffer.unwrap(), &mut ecs_);\n            }\n        }\n\n        if let Some(_) = e.update_args() {\n            gamelogic::update_entity_positions(&mut ecs_);\n        }\n\n        if let Some(r) = e.render_args() {\n            render_game(gl, &r, &mut ecs_, &sprite_textures, &render_conf);\n        }\n\n        gamelogic::check_and_perform_end_turn(&mut ecs_);\n\t}\n}", "item_id": 0, "repo": "hpkoehn/rustac", "file": "src/main.rs", "last_update_at": "2019-11-16T13:26:19+00:00", "question_id": "0c77eac154be90b49ab4c1b601b57a7fd90e0ef1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    // initialize logger\n    simple_logger::init().unwrap();\n    // setup of main data structures\n    let mut ecs_ = ecs::ECS::new();\n    let mut render_conf = RenderConfig {\n        scale: 100.0,\n        window_xs: 1000,\n        window_ys: 1000,\n        focused_entity: None\n    };\n    info!(\"Creating window with {:?}\", render_conf);\n    // setup of opengl window\n    let opengl  = OpenGL::V3_2;\n\tlet mut window: Window = WindowSettings::new(\n            \"rustac\",\n            [render_conf.window_xs, render_conf.window_ys]\n        )\n        .graphics_api(opengl)\n        .exit_on_esc(true)\n        .build()\n        .unwrap();\n\tlet ref mut gl  = GlGraphics::new(opengl);\n    let sprite_textures = sprite::setup_sprite_textures();\n\t\n    // BEGIN test code\n    use crate::builder::dungeon;\n    dungeon::create_empty_room(&mut ecs_, 0.0, 0.0, 10, 8);\n    dungeon::create_empty_room(&mut ecs_, 0.0, 8.0, 8, 10);\n    dungeon::delete_dungeon_entities(&mut ecs_, \n                                     gamestate::dungeon::DungeonElement::Wall,\n                                     LocationVec { x: 4.0, y: 7.0 });\n    dungeon::delete_dungeon_entities(&mut ecs_, \n                                     gamestate::dungeon::DungeonElement::Wall,\n                                     LocationVec { x: 4.0, y: 8.0 });\n    dungeon::create_attack_dummy(&mut ecs_, 3.0, 4.0);\n    // player\n    let player = create_test_dummy_player(&mut ecs_);\n    render_conf.focused_entity = Some(player);\n    // END test code\n\t//Main loop\n    let mut events = Events::new(EventSettings::new());\n    events.set_ups(UPDATES_PER_SECOND);\n    let mut button_buffer: Option<Button> = None;\n    while let Some(e) = events.next(&mut window) {\n        if e.press_args().is_some() || button_buffer.is_some() {\n            debug!(\"{:?}\", &button_buffer);\n            if let Some(p) = e.press_args() {\n                button_buffer = input::handle_input(&p, &mut ecs_);\n            } else {\n                button_buffer = input::handle_input(&button_buffer.unwrap(), &mut ecs_);\n            }\n        }\n        if let Some(_) = e.update_args() {\n            gamelogic::update_entity_positions(&mut ecs_);\n        }\n        if let Some(r) = e.render_args() {\n            render_game(gl, &r, &mut ecs_, &sprite_textures, &render_conf);\n        }\n        gamelogic::check_and_perform_end_turn(&mut ecs_);\n\t}\n"]], "pred": {"ppl": 2.466799020767212, "ppl_lower": 2.9268763065338135, "ppl/lowercase_ppl": -1.1894011886254054, "ppl/zlib": 0.0010319101339089302, "Min_5.0% Prob": 7.503533840179443, "Min_10.0% Prob": 5.707820786051004, "Min_20.0% Prob": 3.876602299960263, "Min_30.0% Prob": 2.837716432699717, "Min_40.0% Prob": 2.2079310774892926, "Min_50.0% Prob": 1.7944421644670419, "Min_60.0% Prob": 1.5030373903739465}}
{"hexsha": "c0a7bc562db7822e47b08f91970f60b2fccf1dd1", "ext": "rs", "lang": "Rust", "content": "fn should_skip_char(input: char) -> bool {\n    // Ignore obsolete control characters, and tab characters we can't render\n    // properly anyways.  Also ignore newline characters since we don't\n    // support multi-line text at the moment.\n    input < '\\u{20}'\n    // Ignore delete character too\n    || input == '\\u{7F}'\n    // Unicode reserves some characters for \"private use\".  Systems emit\n    // these for no clear reason, so we're just going to ignore all of them.\n    || (input >= '\\u{E000}' && input <= '\\u{F8FF}')\n    || (input >= '\\u{F0000}' && input <= '\\u{FFFFF}')\n    || (input >= '\\u{100000}' && input <= '\\u{10FFFF}')\n}", "item_id": 2, "repo": "StarArawn/amethyst", "file": "amethyst_ui/src/text_editing.rs", "last_update_at": "2019-09-18T14:44:57+00:00", "question_id": "c0a7bc562db7822e47b08f91970f60b2fccf1dd1_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn should_skip_char(input: char) -> bool {\n    // Ignore obsolete control characters, and tab characters we can't render\n    // properly anyways.  Also ignore newline characters since we don't\n    // support multi-line text at the moment.\n    input < '\\u{20}'\n    // Ignore delete character too\n    || input == '\\u{7F}'\n    // Unicode reserves some characters for \"private use\".  Systems emit\n    // these for no clear reason, so we're just going to ignore all of them.\n    || (input >= '\\u{E000}' && input <= '\\u{F8FF}')\n    || (input >= '\\u{F0000}' && input <= '\\u{FFFFF}')\n    || (input >= '\\u{100000}' && input <= '\\u{10FFFF}')\n"]], "pred": {"ppl": 3.0502960681915283, "ppl_lower": 3.1905388832092285, "ppl/lowercase_ppl": -1.0403063269812793, "ppl/zlib": 0.003369301079898457, "Min_5.0% Prob": 8.13416862487793, "Min_10.0% Prob": 6.324499607086182, "Min_20.0% Prob": 4.509825136603379, "Min_30.0% Prob": 3.4596635939613467, "Min_40.0% Prob": 2.7553960404744964, "Min_50.0% Prob": 2.2324097815503197, "Min_60.0% Prob": 1.8603015250165857}}
{"hexsha": "de8d796c472d95c1d39dd823d9b1acfd1afb5b94", "ext": "rs", "lang": "Rust", "content": "fn g_mpolygon_to_w_mpolygon(g_mpolygon: &geo_types::MultiPolygon<f64>) -> MultiPolygon {\n    let &geo_types::MultiPolygon(ref g_polygons) = g_mpolygon;\n    let w_polygons = g_polygons_to_w_polygons(g_polygons);\n    MultiPolygon(w_polygons)\n}", "item_id": 7, "repo": "CanalTP/rust-wkt", "file": "src/towkt.rs", "last_update_at": "2019-03-29T06:33:07+00:00", "question_id": "de8d796c472d95c1d39dd823d9b1acfd1afb5b94_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn g_mpolygon_to_w_mpolygon(g_mpolygon: &geo_types::MultiPolygon<f64>) -> MultiPolygon {\n    let &geo_types::MultiPolygon(ref g_polygons) = g_mpolygon;\n    let w_polygons = g_polygons_to_w_polygons(g_polygons);\n    MultiPolygon(w_polygons)\n"]], "pred": {"ppl": 2.3286280632019043, "ppl_lower": 2.9124703407287598, "ppl/lowercase_ppl": -1.2646727071026571, "ppl/zlib": 0.007286890345535235, "Min_5.0% Prob": 8.633233165740966, "Min_10.0% Prob": 6.910916376113891, "Min_20.0% Prob": 4.097835574831281, "Min_30.0% Prob": 2.791655372362584, "Min_40.0% Prob": 2.107283215190089, "Min_50.0% Prob": 1.687457994868358, "Min_60.0% Prob": 1.4259678492962848}}
{"hexsha": "dab278eed03fd4d3bf6464ee142402771532d99d", "ext": "rs", "lang": "Rust", "content": "fn check_export_rsa_public_possible() -> Result<()> {\n    // Exporting a public key is always permitted\n    let mut client = TestClient::new();\n    let key_name = auto_test_keyname!();\n    if !client.is_operation_supported(Opcode::PsaExportPublicKey) {\n        return Ok(());\n    }\n    let mut usage_flags: UsageFlags = Default::default();\n    let _ = usage_flags.set_sign_hash();\n    let key_attributes = Attributes {\n        lifetime: Lifetime::Persistent,\n        key_type: Type::RsaKeyPair,\n        bits: 1024,\n        policy: Policy {\n            usage_flags,\n            permitted_algorithms: Algorithm::AsymmetricSignature(\n                AsymmetricSignature::RsaPkcs1v15Sign {\n                    hash_alg: Hash::Sha256.into(),\n                },\n            ),\n        },\n    };\n\n    client.generate_key(key_name.clone(), key_attributes)?;\n\n    let _public_key = client.export_public_key(key_name)?;\n\n    Ok(())\n}", "item_id": 7, "repo": "paulhowardarm/parsec", "file": "e2e_tests/tests/per_provider/normal_tests/export_public_key.rs", "last_update_at": "2019-05-28T00:14:41+00:00", "question_id": "dab278eed03fd4d3bf6464ee142402771532d99d_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn check_export_rsa_public_possible() -> Result<()> {\n    // Exporting a public key is always permitted\n    let mut client = TestClient::new();\n    let key_name = auto_test_keyname!();\n    if !client.is_operation_supported(Opcode::PsaExportPublicKey) {\n        return Ok(());\n    }\n    let mut usage_flags: UsageFlags = Default::default();\n    let _ = usage_flags.set_sign_hash();\n    let key_attributes = Attributes {\n        lifetime: Lifetime::Persistent,\n        key_type: Type::RsaKeyPair,\n        bits: 1024,\n        policy: Policy {\n            usage_flags,\n            permitted_algorithms: Algorithm::AsymmetricSignature(\n                AsymmetricSignature::RsaPkcs1v15Sign {\n                    hash_alg: Hash::Sha256.into(),\n                },\n            ),\n        },\n    };\n    client.generate_key(key_name.clone(), key_attributes)?;\n    let _public_key = client.export_public_key(key_name)?;\n    Ok(())\n"]], "pred": {"ppl": 1.9638088941574097, "ppl_lower": 2.9316465854644775, "ppl/lowercase_ppl": -1.5936978954084895, "ppl/zlib": 0.0014703396531533543, "Min_5.0% Prob": 7.537589141300747, "Min_10.0% Prob": 5.151307148592813, "Min_20.0% Prob": 3.192813848194323, "Min_30.0% Prob": 2.227815319199202, "Min_40.0% Prob": 1.684011223361544, "Min_50.0% Prob": 1.348488785125988, "Min_60.0% Prob": 1.129780161110576}}
{"hexsha": "41225c3fa3efc98a8ed4e49f32ad466e86bed2df", "ext": "rs", "lang": "Rust", "content": "fn sync(route: &api::Route, list: &List) -> Result<(), Error> {\n    let before = route\n        .actions\n        .iter()\n        .map(|action| extract(action, \"forward(\\\"\", \"\\\")\"))\n        .collect::<HashSet<_>>();\n    let after = list.members.iter().map(|s| &s[..]).collect::<HashSet<_>>();\n    if before == after {\n        return Ok(())\n    }\n\n    let mut form = Form::new();\n    for member in list.members.iter() {\n        form.part(\"action\").contents(format!(\"forward(\\\"{}\\\")\", member).as_bytes()).add()?;\n    }\n    put::<Empty>(&format!(\"/routes/{}\", route.id), form)?;\n\n    Ok(())\n}", "item_id": 3, "repo": "rust-lang/mailgun-mailmap", "file": "src/main.rs", "last_update_at": "2019-06-02T21:50:26+00:00", "question_id": "41225c3fa3efc98a8ed4e49f32ad466e86bed2df_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn sync(route: &api::Route, list: &List) -> Result<(), Error> {\n    let before = route\n        .actions\n        .iter()\n        .map(|action| extract(action, \"forward(\\\"\", \"\\\")\"))\n        .collect::<HashSet<_>>();\n    let after = list.members.iter().map(|s| &s[..]).collect::<HashSet<_>>();\n    if before == after {\n        return Ok(())\n    }\n    let mut form = Form::new();\n    for member in list.members.iter() {\n        form.part(\"action\").contents(format!(\"forward(\\\"{}\\\")\", member).as_bytes()).add()?;\n    }\n    put::<Empty>(&format!(\"/routes/{}\", route.id), form)?;\n    Ok(())\n"]], "pred": {"ppl": 3.191117525100708, "ppl_lower": 3.694718837738037, "ppl/lowercase_ppl": -1.1262813873784232, "ppl/zlib": 0.003603637195020936, "Min_5.0% Prob": 9.145969443851047, "Min_10.0% Prob": 7.2488777135547835, "Min_20.0% Prob": 4.81156001946865, "Min_30.0% Prob": 3.5626375887353543, "Min_40.0% Prob": 2.8075281656995603, "Min_50.0% Prob": 2.2886125505572616, "Min_60.0% Prob": 1.9389210790395737}}
{"hexsha": "c45b0273ee0058edc6fcbfda651bb0552426749e", "ext": "rs", "lang": "Rust", "content": "pub fn eql(\n    interp: &Artichoke,\n    regexp: Value,\n    other: Value,\n) -> Result<Value, Box<dyn RubyException>> {\n    let regexp = unsafe { Regexp::try_from_ruby(interp, &regexp) }.map_err(|err| {\n        let err: Box<dyn RubyException> = if let ArtichokeError::UninitializedValue(\"Regexp\") = err\n        {\n            Box::new(TypeError::new(interp, \"uninitialized Regexp\"))\n        } else {\n            Box::new(Fatal::new(\n                interp,\n                \"Unable to extract Rust Regexp from Ruby Regexp receiver\",\n            ))\n        };\n        err\n    })?;\n    let borrow = regexp.borrow();\n    borrow.eql(interp, other)\n}", "item_id": 2, "repo": "zaccari/artichoke", "file": "artichoke-backend/src/extn/core/regexp/trampoline.rs", "last_update_at": "2019-12-04T11:52:24+00:00", "question_id": "c45b0273ee0058edc6fcbfda651bb0552426749e_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn eql(\n    interp: &Artichoke,\n    regexp: Value,\n    other: Value,\n) -> Result<Value, Box<dyn RubyException>> {\n    let regexp = unsafe { Regexp::try_from_ruby(interp, &regexp) }.map_err(|err| {\n        let err: Box<dyn RubyException> = if let ArtichokeError::UninitializedValue(\"Regexp\") = err\n        {\n            Box::new(TypeError::new(interp, \"uninitialized Regexp\"))\n        } else {\n            Box::new(Fatal::new(\n                interp,\n                \"Unable to extract Rust Regexp from Ruby Regexp receiver\",\n            ))\n        };\n        err\n    })?;\n    let borrow = regexp.borrow();\n    borrow.eql(interp, other)\n"]], "pred": {"ppl": 1.9708611965179443, "ppl_lower": 3.2226433753967285, "ppl/lowercase_ppl": -1.724764406826442, "ppl/zlib": 0.0021538749295812523, "Min_5.0% Prob": 7.574402856826782, "Min_10.0% Prob": 5.519461905956268, "Min_20.0% Prob": 3.21293359340691, "Min_30.0% Prob": 2.222890411413485, "Min_40.0% Prob": 1.7045926254060937, "Min_50.0% Prob": 1.362047183842769, "Min_60.0% Prob": 1.1322662890419335}}
{"hexsha": "6993c1ac0af8494846cba5d4624959d71ea7584c", "ext": "rs", "lang": "Rust", "content": "fn pollable_set_test() {\n        let mut runtime = tokio::runtime::Builder::new()\n            .basic_scheduler()\n            .build()\n            .unwrap();\n\n        let set = PollableSet::<u32>::new();\n        assert_eq!(0, set.items.read().len());\n        assert_eq!(0, set.len());\n\n        set.insert(6);\n        assert_eq!(1, set.items.read().len());\n        assert_eq!(1, set.len());\n\n        set.insert(4);\n        set.insert(8);\n        assert_eq!(3, set.items.read().len());\n        assert_eq!(3, set.len());\n\n        set.insert(10);\n        {\n            let odd_query = poll_fn(|cx| -> Poll<bool> {\n                match set.poll_take(cx, |x| x % 2 == 1) {\n                    Poll::Ready(_) => Poll::Ready(true),\n                    Poll::Pending => Poll::Ready(false),\n                }\n            });\n            let even_query = poll_fn(|cx| -> Poll<bool> {\n                match set.poll_take(cx, |x| x % 2 == 0) {\n                    Poll::Ready(_) => Poll::Ready(true),\n                    Poll::Pending => Poll::Ready(false),\n                }\n            });\n\n            // Wait for all the queries to complete\n            assert_eq!(runtime.block_on(odd_query), false);\n            assert_eq!(runtime.block_on(even_query), true);\n        }\n\n        // 3 (before the queries are created), 10 is inserted, and the query consumes one value.\n        assert_eq!(3, set.items.read().len());\n        assert_eq!(3, set.len());\n    }", "item_id": 0, "repo": "zrneely/wamp-proto", "file": "src/pollable.rs", "last_update_at": "2019-11-03T00:07:27+00:00", "question_id": "6993c1ac0af8494846cba5d4624959d71ea7584c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn pollable_set_test() {\n        let mut runtime = tokio::runtime::Builder::new()\n            .basic_scheduler()\n            .build()\n            .unwrap();\n        let set = PollableSet::<u32>::new();\n        assert_eq!(0, set.items.read().len());\n        assert_eq!(0, set.len());\n        set.insert(6);\n        assert_eq!(1, set.items.read().len());\n        assert_eq!(1, set.len());\n        set.insert(4);\n        set.insert(8);\n        assert_eq!(3, set.items.read().len());\n        assert_eq!(3, set.len());\n        set.insert(10);\n        {\n            let odd_query = poll_fn(|cx| -> Poll<bool> {\n                match set.poll_take(cx, |x| x % 2 == 1) {\n                    Poll::Ready(_) => Poll::Ready(true),\n                    Poll::Pending => Poll::Ready(false),\n                }\n            });\n            let even_query = poll_fn(|cx| -> Poll<bool> {\n                match set.poll_take(cx, |x| x % 2 == 0) {\n                    Poll::Ready(_) => Poll::Ready(true),\n                    Poll::Pending => Poll::Ready(false),\n                }\n            });\n            // Wait for all the queries to complete\n            assert_eq!(runtime.block_on(odd_query), false);\n            assert_eq!(runtime.block_on(even_query), true);\n        }\n        // 3 (before the queries are created), 10 is inserted, and the query consumes one value.\n        assert_eq!(3, set.items.read().len());\n        assert_eq!(3, set.len());\n"]], "pred": {"ppl": 1.9047743082046509, "ppl_lower": 2.2021007537841797, "ppl/lowercase_ppl": -1.225103157321839, "ppl/zlib": 0.0014847085902690168, "Min_5.0% Prob": 6.657756046815352, "Min_10.0% Prob": 4.840503496593899, "Min_20.0% Prob": 3.0311329476125946, "Min_30.0% Prob": 2.1315011463134828, "Min_40.0% Prob": 1.6092683339868088, "Min_50.0% Prob": 1.2879309781347137, "Min_60.0% Prob": 1.0768397349229484}}
{"hexsha": "ccfe9f2f805a78b7b457b0d541aeee39263e803c", "ext": "rs", "lang": "Rust", "content": "fn wire_assign_01() {\n        let mut b = \"module test { wire a; a = a + 1'b1;}\".as_bytes();\n        let mut l = Lexer::new(&mut b);\n        let mut p = Parser::new(&mut l);\n\n        let wire = create_node!(ASTClass::Wire(vec![(\n            create_node!(ASTClass::Identifire(\"a\".to_string())),\n            None,\n        )]));\n\n        let expr = create_node!(ASTClass::Expression(\n            create_node!(ASTClass::Identifire(\"a\".to_string())),\n            create_node!(ASTClass::Operator(Operator::Plus)),\n            create_node!(ASTClass::Number(\"1'b1\".to_string())),\n        ));\n        let assign = create_node!(ASTClass::Assign(\n            create_node!(ASTClass::Identifire(\"a\".to_string())),\n            expr,\n        ));\n        let components = vec![wire, assign];\n        let module = create_node!(ASTClass::Module(\n            create_node!(ASTClass::Identifire(\"test\".to_string())),\n            create_node!(ASTClass::Block(components))\n        ));\n        assert_eq!(p.next_ast(), module);\n    }", "item_id": 56, "repo": "sux2mfgj/nslfmt", "file": "tests/parser.rs", "last_update_at": "2019-10-07T02:44:41+00:00", "question_id": "ccfe9f2f805a78b7b457b0d541aeee39263e803c_56", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn wire_assign_01() {\n        let mut b = \"module test { wire a; a = a + 1'b1;}\".as_bytes();\n        let mut l = Lexer::new(&mut b);\n        let mut p = Parser::new(&mut l);\n        let wire = create_node!(ASTClass::Wire(vec![(\n            create_node!(ASTClass::Identifire(\"a\".to_string())),\n            None,\n        )]));\n        let expr = create_node!(ASTClass::Expression(\n            create_node!(ASTClass::Identifire(\"a\".to_string())),\n            create_node!(ASTClass::Operator(Operator::Plus)),\n            create_node!(ASTClass::Number(\"1'b1\".to_string())),\n        ));\n        let assign = create_node!(ASTClass::Assign(\n            create_node!(ASTClass::Identifire(\"a\".to_string())),\n            expr,\n        ));\n        let components = vec![wire, assign];\n        let module = create_node!(ASTClass::Module(\n            create_node!(ASTClass::Identifire(\"test\".to_string())),\n            create_node!(ASTClass::Block(components))\n        ));\n        assert_eq!(p.next_ast(), module);\n"]], "pred": {"ppl": 2.1443698406219482, "ppl_lower": 2.3387880325317383, "ppl/lowercase_ppl": -1.11376760529828, "ppl/zlib": 0.0023186800262072313, "Min_5.0% Prob": 7.198820559183757, "Min_10.0% Prob": 5.094681809025426, "Min_20.0% Prob": 3.3434764848601435, "Min_30.0% Prob": 2.442300145984978, "Min_40.0% Prob": 1.8821892951645198, "Min_50.0% Prob": 1.5195470105255804, "Min_60.0% Prob": 1.269893709004366}}
{"hexsha": "ec46d9919a51d054ee2df99349e9af08a5b0a658", "ext": "rs", "lang": "Rust", "content": "pub fn convert(mkdoc: &str) -> String {\n    let mut options = Options::empty();\n    options.insert(Options::ENABLE_STRIKETHROUGH);\n    options.insert(Options::ENABLE_FOOTNOTES);\n    options.insert(Options::ENABLE_TASKLISTS);\n    options.insert(Options::ENABLE_TABLES);\n    let parser = Parser::new_ext(mkdoc, options);\n\n    let mut htdoc = String::new();\n    html::push_html(&mut htdoc, parser);\n    htdoc\n}", "item_id": 1, "repo": "Teaonly/Teaonly.github.io", "file": "generator/src/blog.rs", "last_update_at": "2019-07-11T13:20:46+00:00", "question_id": "ec46d9919a51d054ee2df99349e9af08a5b0a658_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn convert(mkdoc: &str) -> String {\n    let mut options = Options::empty();\n    options.insert(Options::ENABLE_STRIKETHROUGH);\n    options.insert(Options::ENABLE_FOOTNOTES);\n    options.insert(Options::ENABLE_TASKLISTS);\n    options.insert(Options::ENABLE_TABLES);\n    let parser = Parser::new_ext(mkdoc, options);\n    let mut htdoc = String::new();\n    html::push_html(&mut htdoc, parser);\n    htdoc\n"]], "pred": {"ppl": 1.8923252820968628, "ppl_lower": 2.8581607341766357, "ppl/lowercase_ppl": -1.6465472117344944, "ppl/zlib": 0.003126501866914802, "Min_5.0% Prob": 7.873459952218192, "Min_10.0% Prob": 5.299547467912946, "Min_20.0% Prob": 3.0462925976940562, "Min_30.0% Prob": 2.1133757996417226, "Min_40.0% Prob": 1.6065803508141212, "Min_50.0% Prob": 1.272858896056636, "Min_60.0% Prob": 1.064644159239662}}
{"hexsha": "a037fa45bf34d8df074e2ce5b0fe164373bceaed", "ext": "rs", "lang": "Rust", "content": "fn should_list_attacks() {\n    let client = ShieldClient::simple(Region::UsEast1);\n    let request = ListAttacksRequest::default();\n\n    let result = client.list_attacks(&request).sync().unwrap();\n    println!(\"{:#?}\", result);\n}", "item_id": 0, "repo": "tureus/rusoto", "file": "integration_tests/tests/shield.rs", "last_update_at": "2019-10-22T03:13:55+00:00", "question_id": "a037fa45bf34d8df074e2ce5b0fe164373bceaed_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn should_list_attacks() {\n    let client = ShieldClient::simple(Region::UsEast1);\n    let request = ListAttacksRequest::default();\n    let result = client.list_attacks(&request).sync().unwrap();\n    println!(\"{:#?}\", result);\n"]], "pred": {"ppl": 2.5505049228668213, "ppl_lower": 5.487421035766602, "ppl/lowercase_ppl": -1.8182998178091312, "ppl/zlib": 0.005709093588637363, "Min_5.0% Prob": 9.068571090698242, "Min_10.0% Prob": 7.488664013998849, "Min_20.0% Prob": 4.466895671827452, "Min_30.0% Prob": 3.0679728175912584, "Min_40.0% Prob": 2.3259336115526303, "Min_50.0% Prob": 1.8693531468510627, "Min_60.0% Prob": 1.5593826563341455}}
{"hexsha": "5a62b9a46fc40ca7c1d02d99ad7085dd94fff29c", "ext": "rs", "lang": "Rust", "content": "fn moves_sprites() {\n    let mut tia = Tia::new();\n    tia.write(registers::COLUBK, 0x00).unwrap();\n    tia.write(registers::COLUP0, 0x02).unwrap();\n    tia.write(registers::COLUP1, 0x04).unwrap();\n    tia.write(registers::COLUPF, 0x06).unwrap();\n    tia.write(registers::GRP0, 0b1100_0011).unwrap();\n    tia.write(registers::GRP1, 0b1100_0011).unwrap();\n    tia.write(registers::ENAM0, flags::ENAXX_ENABLE).unwrap();\n    tia.write(registers::ENAM1, flags::ENAXX_ENABLE).unwrap();\n    tia.write(registers::ENABL, flags::ENAXX_ENABLE).unwrap();\n    tia.write(registers::HMP0, 3 << 4).unwrap();\n    tia.write(registers::HMP1, (-5i8 << 4) as u8).unwrap();\n    tia.write(registers::HMM0, (-6i8 << 4) as u8).unwrap();\n    tia.write(registers::HMM1, 4 << 4 as u8).unwrap();\n    tia.write(registers::HMBL, (-1i8 << 4) as u8).unwrap();\n\n    let p0_delay = 32 * 3;\n    let p1_delay = 6 * 3;\n    let m0_delay = 9 * 3;\n    let m1_delay = 2 * 3;\n    let ball_delay = 3 * 3;\n    wait_ticks(&mut tia, p0_delay);\n    tia.write(registers::RESP0, 0).unwrap();\n    wait_ticks(&mut tia, p1_delay);\n    tia.write(registers::RESP1, 0).unwrap();\n    wait_ticks(&mut tia, m0_delay);\n    tia.write(registers::RESM0, 0).unwrap();\n    wait_ticks(&mut tia, m1_delay);\n    tia.write(registers::RESM1, 0).unwrap();\n    wait_ticks(&mut tia, ball_delay);\n    tia.write(registers::RESBL, 0).unwrap();\n    wait_ticks(\n        &mut tia,\n        TOTAL_WIDTH - p0_delay - p1_delay - m0_delay - m1_delay - ball_delay,\n    );\n\n    // Pretend we're doing an STA: wait for 2 CPU cycles, write to register\n    // on the 3rd one.\n    let mut scanline = scan_video(&mut tia, 2 * 3 + 1);\n    tia.write(registers::HMOVE, 0).unwrap();\n    scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));\n\n    assert_eq!(\n        encode_video_outputs(scanline),\n        \"................||||||||||||||||....................................\\\n         ........000000000000000000000000220000220000000000000000004400004400000000000000\\\n         04000200000000060000000000000000000000000000000000000000000000000000000000000000\",\n    );\n\n    // Do the same once again, and then clear the movement registers before\n    // HMOVE on the 3rd line. The 3rd line should look exactly as the 2nd\n    // one.\n    let mut scanline = scan_video(&mut tia, 2 * 3 + 1);\n    tia.write(registers::HMOVE, 0).unwrap();\n    scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));\n    tia.write(registers::HMCLR, 0).unwrap();\n    scanline.append(&mut scan_video(&mut tia, 2 * 3 + 1));\n    tia.write(registers::HMOVE, 0).unwrap();\n    scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));\n\n    assert_eq!(\n        encode_video_outputs(scanline),\n        \"................||||||||||||||||....................................\\\n         ........000000000000000000000220000220000000000000000000000000044000044000000400\\\n         00000000000200006000000000000000000000000000000000000000000000000000000000000000\\\n         ................||||||||||||||||....................................\\\n         ........000000000000000000000220000220000000000000000000000000044000044000000400\\\n         00000000000200006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n\n    // Test RESMPx: make sure the missiles move along with players and stop\n    // following them once they are freed.\n    tia.write(registers::RESMP0, flags::RESMPX_RESET).unwrap();\n    assert_eq!(\n        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),\n        \"................||||||||||||||||....................................\\\n         00000000000000000000000000000220000220000000000000000000000000044000044000000400\\\n         00000000000000006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n\n    tia.write(registers::RESMP1, flags::RESMPX_RESET).unwrap();\n    assert_eq!(\n        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),\n        \"................||||||||||||||||....................................\\\n         00000000000000000000000000000220000220000000000000000000000000044000044000000000\\\n         00000000000000006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n\n    tia.write(registers::RESMP0, 0).unwrap();\n    assert_eq!(\n        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),\n        \"................||||||||||||||||....................................\\\n         00000000000000000000000000000220020220000000000000000000000000044000044000000000\\\n         00000000000000006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n    tia.write(registers::RESMP1, 0).unwrap();\n    assert_eq!(\n        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),\n        \"................||||||||||||||||....................................\\\n         00000000000000000000000000000220020220000000000000000000000000044004044000000000\\\n         00000000000000006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n}", "item_id": 12, "repo": "technomaniak/atari-emulator", "file": "atari2600/src/tia/tests.rs", "last_update_at": "2019-08-16T09:49:50+00:00", "question_id": "5a62b9a46fc40ca7c1d02d99ad7085dd94fff29c_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn moves_sprites() {\n    let mut tia = Tia::new();\n    tia.write(registers::COLUBK, 0x00).unwrap();\n    tia.write(registers::COLUP0, 0x02).unwrap();\n    tia.write(registers::COLUP1, 0x04).unwrap();\n    tia.write(registers::COLUPF, 0x06).unwrap();\n    tia.write(registers::GRP0, 0b1100_0011).unwrap();\n    tia.write(registers::GRP1, 0b1100_0011).unwrap();\n    tia.write(registers::ENAM0, flags::ENAXX_ENABLE).unwrap();\n    tia.write(registers::ENAM1, flags::ENAXX_ENABLE).unwrap();\n    tia.write(registers::ENABL, flags::ENAXX_ENABLE).unwrap();\n    tia.write(registers::HMP0, 3 << 4).unwrap();\n    tia.write(registers::HMP1, (-5i8 << 4) as u8).unwrap();\n    tia.write(registers::HMM0, (-6i8 << 4) as u8).unwrap();\n    tia.write(registers::HMM1, 4 << 4 as u8).unwrap();\n    tia.write(registers::HMBL, (-1i8 << 4) as u8).unwrap();\n    let p0_delay = 32 * 3;\n    let p1_delay = 6 * 3;\n    let m0_delay = 9 * 3;\n    let m1_delay = 2 * 3;\n    let ball_delay = 3 * 3;\n    wait_ticks(&mut tia, p0_delay);\n    tia.write(registers::RESP0, 0).unwrap();\n    wait_ticks(&mut tia, p1_delay);\n    tia.write(registers::RESP1, 0).unwrap();\n    wait_ticks(&mut tia, m0_delay);\n    tia.write(registers::RESM0, 0).unwrap();\n    wait_ticks(&mut tia, m1_delay);\n    tia.write(registers::RESM1, 0).unwrap();\n    wait_ticks(&mut tia, ball_delay);\n    tia.write(registers::RESBL, 0).unwrap();\n    wait_ticks(\n        &mut tia,\n        TOTAL_WIDTH - p0_delay - p1_delay - m0_delay - m1_delay - ball_delay,\n    );\n    // Pretend we're doing an STA: wait for 2 CPU cycles, write to register\n    // on the 3rd one.\n    let mut scanline = scan_video(&mut tia, 2 * 3 + 1);\n    tia.write(registers::HMOVE, 0).unwrap();\n    scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));\n    assert_eq!(\n        encode_video_outputs(scanline),\n        \"................||||||||||||||||....................................\\\n         ........000000000000000000000000220000220000000000000000004400004400000000000000\\\n         04000200000000060000000000000000000000000000000000000000000000000000000000000000\",\n    );\n    // Do the same once again, and then clear the movement registers before\n    // HMOVE on the 3rd line. The 3rd line should look exactly as the 2nd\n    // one.\n    let mut scanline = scan_video(&mut tia, 2 * 3 + 1);\n    tia.write(registers::HMOVE, 0).unwrap();\n    scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));\n    tia.write(registers::HMCLR, 0).unwrap();\n    scanline.append(&mut scan_video(&mut tia, 2 * 3 + 1));\n    tia.write(registers::HMOVE, 0).unwrap();\n    scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));\n    assert_eq!(\n        encode_video_outputs(scanline),\n        \"................||||||||||||||||....................................\\\n         ........000000000000000000000220000220000000000000000000000000044000044000000400\\\n         00000000000200006000000000000000000000000000000000000000000000000000000000000000\\\n         ................||||||||||||||||....................................\\\n         ........000000000000000000000220000220000000000000000000000000044000044000000400\\\n         00000000000200006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n    // Test RESMPx: make sure the missiles move along with players and stop\n    // following them once they are freed.\n    tia.write(registers::RESMP0, flags::RESMPX_RESET).unwrap();\n    assert_eq!(\n        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),\n        \"................||||||||||||||||....................................\\\n         00000000000000000000000000000220000220000000000000000000000000044000044000000400\\\n         00000000000000006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n    tia.write(registers::RESMP1, flags::RESMPX_RESET).unwrap();\n    assert_eq!(\n        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),\n        \"................||||||||||||||||....................................\\\n         00000000000000000000000000000220000220000000000000000000000000044000044000000000\\\n         00000000000000006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n    tia.write(registers::RESMP0, 0).unwrap();\n    assert_eq!(\n        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),\n        \"................||||||||||||||||....................................\\\n         00000000000000000000000000000220020220000000000000000000000000044000044000000000\\\n         00000000000000006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n    tia.write(registers::RESMP1, 0).unwrap();\n    assert_eq!(\n        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),\n        \"................||||||||||||||||....................................\\\n         00000000000000000000000000000220020220000000000000000000000000044004044000000000\\\n         00000000000000006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n"]], "pred": {"ppl": 2.0090646743774414, "ppl_lower": 2.137251138687134, "ppl/lowercase_ppl": -1.088654055797057, "ppl/zlib": 0.0008775714184124549, "Min_5.0% Prob": 6.781960001178816, "Min_10.0% Prob": 5.0413280094371125, "Min_20.0% Prob": 3.183142885273578, "Min_30.0% Prob": 2.2551135365285124, "Min_40.0% Prob": 1.7239646663146964, "Min_50.0% Prob": 1.3908339108243848, "Min_60.0% Prob": 1.163109192740154}}
{"hexsha": "ede8b8f9c2808f2f605471faa9ab0f2e263c0969", "ext": "rs", "lang": "Rust", "content": "fn parse_use4() {\n    let input = \"use\";\n    let expected_output = IResult::Incomplete(Needed::Unknown);\n\n    let result = parse_use(input);\n\n    assert_eq!(result, expected_output);\n}", "item_id": 3, "repo": "willi-kappler/comment_units", "file": "src/fortran/tests/parse_use.rs", "last_update_at": "2019-06-06T11:14:46+00:00", "question_id": "ede8b8f9c2808f2f605471faa9ab0f2e263c0969_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_use4() {\n    let input = \"use\";\n    let expected_output = IResult::Incomplete(Needed::Unknown);\n    let result = parse_use(input);\n    assert_eq!(result, expected_output);\n"]], "pred": {"ppl": 3.2940852642059326, "ppl_lower": 5.730925559997559, "ppl/lowercase_ppl": -1.4645040554498674, "ppl/zlib": 0.009100217680318321, "Min_5.0% Prob": 9.495822588602701, "Min_10.0% Prob": 7.409914612770081, "Min_20.0% Prob": 4.907638818025589, "Min_30.0% Prob": 3.696544630659951, "Min_40.0% Prob": 2.8969583498934903, "Min_50.0% Prob": 2.3634326266745727, "Min_60.0% Prob": 1.980234074095885}}
{"hexsha": "81db081b951c3b37e1dcc178b4dfa17e5e178be5", "ext": "rs", "lang": "Rust", "content": "fn clean_release() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.0.1\"\n            authors = []\n\n            [dependencies]\n            a = { path = \"a\" }\n        \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .file(\"a/Cargo.toml\", &basic_manifest(\"a\", \"0.0.1\"))\n        .file(\"a/src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"build --release\").run();\n\n    p.cargo(\"clean -p foo\").run();\n    p.cargo(\"build --release\").with_stdout(\"\").run();\n\n    p.cargo(\"clean -p foo --release\").run();\n    p.cargo(\"build --release\")\n        .with_stderr(\n            \"\\\n[COMPILING] foo v0.0.1 ([..])\n[FINISHED] release [optimized] target(s) in [..]\n\",\n        )\n        .run();\n\n    p.cargo(\"build\").run();\n\n    p.cargo(\"clean\").arg(\"--release\").run();\n    assert!(p.build_dir().is_dir());\n    assert!(p.build_dir().join(\"debug\").is_dir());\n    assert!(!p.build_dir().join(\"release\").is_dir());\n}", "item_id": 3, "repo": "lizh06/cargo", "file": "tests/testsuite/clean.rs", "last_update_at": "2019-02-05T07:19:42+00:00", "question_id": "81db081b951c3b37e1dcc178b4dfa17e5e178be5_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn clean_release() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.0.1\"\n            authors = []\n            [dependencies]\n            a = { path = \"a\" }\n        \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .file(\"a/Cargo.toml\", &basic_manifest(\"a\", \"0.0.1\"))\n        .file(\"a/src/lib.rs\", \"\")\n        .build();\n    p.cargo(\"build --release\").run();\n    p.cargo(\"clean -p foo\").run();\n    p.cargo(\"build --release\").with_stdout(\"\").run();\n    p.cargo(\"clean -p foo --release\").run();\n    p.cargo(\"build --release\")\n        .with_stderr(\n            \"\\\n[COMPILING] foo v0.0.1 ([..])\n[FINISHED] release [optimized] target(s) in [..]\n\",\n        )\n        .run();\n    p.cargo(\"build\").run();\n    p.cargo(\"clean\").arg(\"--release\").run();\n    assert!(p.build_dir().is_dir());\n    assert!(p.build_dir().join(\"debug\").is_dir());\n    assert!(!p.build_dir().join(\"release\").is_dir());\n"]], "pred": {"ppl": 1.415336012840271, "ppl_lower": 1.5677783489227295, "ppl/lowercase_ppl": -1.2944798858280258, "ppl/zlib": 0.0008861402240042304, "Min_5.0% Prob": 3.963384747505188, "Min_10.0% Prob": 2.744475166002909, "Min_20.0% Prob": 1.6485092254976432, "Min_30.0% Prob": 1.1506812181323767, "Min_40.0% Prob": 0.8665510504217497, "Min_50.0% Prob": 0.6959648415039793, "Min_60.0% Prob": 0.5809141756641606}}
{"hexsha": "6412366c01d9d1fcc0f260d34b639412ea8704fc", "ext": "rs", "lang": "Rust", "content": "pub async fn set_phone_number(req: String) -> HttpResponse {\n    let clean_string = clean_quotes(&req);\n    trace!(\"Got number {:?}\", clean_string);\n    let phone_number: PhoneNumber = match clean_string.parse() {\n        Ok(p) => p,\n        Err(e) => {\n            info!(\"Failed to parse phonenumber with {:?}\", e);\n            return HttpResponse::BadRequest().finish();\n        }\n    };\n\n    let mut rita_client = settings::get_rita_client();\n\n    // merge the new value into the existing struct, for the various possibilities\n    let res = match option_convert(rita_client.exit_client.contact_info.clone()) {\n        Some(ContactType::Phone {\n            number: _,\n            sequence_number,\n        }) => Some(ContactType::Phone {\n            number: phone_number,\n            sequence_number: Some(add_to_sequence(sequence_number)),\n        }),\n        Some(ContactType::Email {\n            email,\n            sequence_number,\n        }) => Some(ContactType::Both {\n            number: phone_number,\n            email,\n            sequence_number: Some(add_to_sequence(sequence_number)),\n        }),\n        Some(ContactType::Both {\n            number: _number,\n            email,\n            sequence_number,\n        }) => Some(ContactType::Both {\n            number: phone_number,\n            email,\n            sequence_number: Some(add_to_sequence(sequence_number)),\n        }),\n        Some(ContactType::Bad {\n            invalid_number: _,\n            invalid_email: _,\n            sequence_number,\n        }) => Some(ContactType::Phone {\n            number: phone_number,\n            sequence_number: Some(add_to_sequence(sequence_number)),\n        }),\n        None => Some(ContactType::Phone {\n            number: phone_number,\n            sequence_number: Some(0),\n        }),\n    };\n    rita_client.exit_client.contact_info = option_convert(res);\n\n    settings::set_rita_client(rita_client);\n\n    // save immediately\n    if let Err(_e) = settings::write_config() {\n        return HttpResponse::InternalServerError().finish();\n    }\n\n    HttpResponse::Ok().finish()\n}", "item_id": 0, "repo": "althea-mesh/althea_rs", "file": "rita_client/src/dashboard/contact_info.rs", "last_update_at": "2019-06-10T17:42:00+00:00", "question_id": "6412366c01d9d1fcc0f260d34b639412ea8704fc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn set_phone_number(req: String) -> HttpResponse {\n    let clean_string = clean_quotes(&req);\n    trace!(\"Got number {:?}\", clean_string);\n    let phone_number: PhoneNumber = match clean_string.parse() {\n        Ok(p) => p,\n        Err(e) => {\n            info!(\"Failed to parse phonenumber with {:?}\", e);\n            return HttpResponse::BadRequest().finish();\n        }\n    };\n    let mut rita_client = settings::get_rita_client();\n    // merge the new value into the existing struct, for the various possibilities\n    let res = match option_convert(rita_client.exit_client.contact_info.clone()) {\n        Some(ContactType::Phone {\n            number: _,\n            sequence_number,\n        }) => Some(ContactType::Phone {\n            number: phone_number,\n            sequence_number: Some(add_to_sequence(sequence_number)),\n        }),\n        Some(ContactType::Email {\n            email,\n            sequence_number,\n        }) => Some(ContactType::Both {\n            number: phone_number,\n            email,\n            sequence_number: Some(add_to_sequence(sequence_number)),\n        }),\n        Some(ContactType::Both {\n            number: _number,\n            email,\n            sequence_number,\n        }) => Some(ContactType::Both {\n            number: phone_number,\n            email,\n            sequence_number: Some(add_to_sequence(sequence_number)),\n        }),\n        Some(ContactType::Bad {\n            invalid_number: _,\n            invalid_email: _,\n            sequence_number,\n        }) => Some(ContactType::Phone {\n            number: phone_number,\n            sequence_number: Some(add_to_sequence(sequence_number)),\n        }),\n        None => Some(ContactType::Phone {\n            number: phone_number,\n            sequence_number: Some(0),\n        }),\n    };\n    rita_client.exit_client.contact_info = option_convert(res);\n    settings::set_rita_client(rita_client);\n    // save immediately\n    if let Err(_e) = settings::write_config() {\n        return HttpResponse::InternalServerError().finish();\n    }\n    HttpResponse::Ok().finish()\n"]], "pred": {"ppl": 2.0465049743652344, "ppl_lower": 2.2876052856445312, "ppl/lowercase_ppl": -1.1555186346529682, "ppl/zlib": 0.0012810974018191712, "Min_5.0% Prob": 7.729602694511414, "Min_10.0% Prob": 5.599878128085818, "Min_20.0% Prob": 3.401309650556176, "Min_30.0% Prob": 2.3646695847518346, "Min_40.0% Prob": 1.7876615095389101, "Min_50.0% Prob": 1.4311488265197974, "Min_60.0% Prob": 1.195440912672118}}
{"hexsha": "e3d4833798277cb9b8a9a72fafc2aee5e3bb035c", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<()> {\n    // appeneds \"___\\n\" after every line\n    let editor = linurgy::factory::appender(\"___\\n\", 1);\n\n    // create a buffered reader over stdin\n    let mut input = BufReader::new(stdin());\n\n    // `edit_buffered` returns an io::Result\n    // in a simple program like this, we can pass stdout directly\n    editor.edit_buffered(&mut input, &mut stdout())?;\n\n    Ok(())\n}", "item_id": 0, "repo": "sonro/linurgy", "file": "examples/buffered-stdio.rs", "last_update_at": "2019-07-31T16:37:40+00:00", "question_id": "e3d4833798277cb9b8a9a72fafc2aee5e3bb035c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<()> {\n    // appeneds \"___\\n\" after every line\n    let editor = linurgy::factory::appender(\"___\\n\", 1);\n    // create a buffered reader over stdin\n    let mut input = BufReader::new(stdin());\n    // `edit_buffered` returns an io::Result\n    // in a simple program like this, we can pass stdout directly\n    editor.edit_buffered(&mut input, &mut stdout())?;\n    Ok(())\n"]], "pred": {"ppl": 5.713374614715576, "ppl_lower": 7.294572353363037, "ppl/lowercase_ppl": -1.1401878170833133, "ppl/zlib": 0.006971239399686216, "Min_5.0% Prob": 9.325393835703531, "Min_10.0% Prob": 8.138639609018961, "Min_20.0% Prob": 6.083825807571412, "Min_30.0% Prob": 4.871915277681853, "Min_40.0% Prob": 4.0802135133743285, "Min_50.0% Prob": 3.401302952615042, "Min_60.0% Prob": 2.8806063162260935}}
{"hexsha": "592650d55ab075e7500b3d4a644155b35081988e", "ext": "rs", "lang": "Rust", "content": "fn node_remove_next() {\n    let mut node: Node<&str> = Node::new(\"one\");\n    node.insert_after(Box::new(Node::new(\"two\")));\n    node.remove_after();\n}", "item_id": 3, "repo": "jonalmeida/algorithms.rs", "file": "src/datastructures/linkedlist.rs", "last_update_at": "2019-07-01T06:45:01+00:00", "question_id": "592650d55ab075e7500b3d4a644155b35081988e_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn node_remove_next() {\n    let mut node: Node<&str> = Node::new(\"one\");\n    node.insert_after(Box::new(Node::new(\"two\")));\n    node.remove_after();\n"]], "pred": {"ppl": 3.6214756965637207, "ppl_lower": 4.947216033935547, "ppl/lowercase_ppl": -1.2424025712517812, "ppl/zlib": 0.011593527871667066, "Min_5.0% Prob": 8.997660160064697, "Min_10.0% Prob": 6.985648536682129, "Min_20.0% Prob": 5.023655913092873, "Min_30.0% Prob": 3.9681520089507103, "Min_40.0% Prob": 3.0717275643890556, "Min_50.0% Prob": 2.5575279698327735, "Min_60.0% Prob": 2.1240682525165155}}
{"hexsha": "3e6bd45234983a3e9b2e01a3c4914abacbeade6a", "ext": "rs", "lang": "Rust", "content": "pub fn _68(c: &mut Context, b: &mut Bus) {\n    // Increment S\n    c.step(b);\n    c.s = c.s.wrapping_add(1);\n\n    // Pull register from stack\n    c.step(b);\n    c.a = b.read(0x100 + c.s as u16);\n\n    c.p.set(cpu::ZERO, c.a == 0);\n    c.p.set(cpu::SIGN, c.a & 0x80 != 0);\n}", "item_id": 13, "repo": "mehcode/lintel-nes", "file": "src/cpu/op.rs", "last_update_at": "2019-03-17T11:26:30+00:00", "question_id": "3e6bd45234983a3e9b2e01a3c4914abacbeade6a_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn _68(c: &mut Context, b: &mut Bus) {\n    // Increment S\n    c.step(b);\n    c.s = c.s.wrapping_add(1);\n    // Pull register from stack\n    c.step(b);\n    c.a = b.read(0x100 + c.s as u16);\n    c.p.set(cpu::ZERO, c.a == 0);\n    c.p.set(cpu::SIGN, c.a & 0x80 != 0);\n"]], "pred": {"ppl": 3.072218894958496, "ppl_lower": 3.3524909019470215, "ppl/lowercase_ppl": -1.0777829200667581, "ppl/zlib": 0.00600213939901722, "Min_5.0% Prob": 8.063541957310267, "Min_10.0% Prob": 6.458690813609532, "Min_20.0% Prob": 4.609407118388584, "Min_30.0% Prob": 3.419934223095576, "Min_40.0% Prob": 2.7218576185405254, "Min_50.0% Prob": 2.2171601993097387, "Min_60.0% Prob": 1.8688137452392017}}
{"hexsha": "3deac005077f7c70c346c676b2f9596a2b4440d9", "ext": "rs", "lang": "Rust", "content": "fn test_single_row_insert() {\n        let expected = expected_values(\"INSERT INTO \\\"users\\\" (\\\"foo\\\") VALUES ($1)\", vec![10]);\n        let query = Insert::single_into(\"users\").value(\"foo\", 10);\n        let (sql, params) = Postgres::build(query).unwrap();\n\n        assert_eq!(expected.0, sql);\n        assert_eq!(expected.1, params);\n    }", "item_id": 2, "repo": "prisma/prisma-query", "file": "src/visitor/postgres.rs", "last_update_at": "2019-11-02T17:23:18+00:00", "question_id": "3deac005077f7c70c346c676b2f9596a2b4440d9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_single_row_insert() {\n        let expected = expected_values(\"INSERT INTO \\\"users\\\" (\\\"foo\\\") VALUES ($1)\", vec![10]);\n        let query = Insert::single_into(\"users\").value(\"foo\", 10);\n        let (sql, params) = Postgres::build(query).unwrap();\n        assert_eq!(expected.0, sql);\n        assert_eq!(expected.1, params);\n"]], "pred": {"ppl": 2.437807321548462, "ppl_lower": 2.8962693214416504, "ppl/lowercase_ppl": -1.193384205367776, "ppl/zlib": 0.004032122156459893, "Min_5.0% Prob": 6.331373596191407, "Min_10.0% Prob": 5.147224807739258, "Min_20.0% Prob": 3.674423024767921, "Min_30.0% Prob": 2.812642149386867, "Min_40.0% Prob": 2.179488384297916, "Min_50.0% Prob": 1.7900531909500177, "Min_60.0% Prob": 1.4831501548252408}}
{"hexsha": "299ec8d08f451f1a3aad65b243a34e49c04917f5", "ext": "rs", "lang": "Rust", "content": "fn test_transaction() {\n        let hex_tx = hex_bytes(\"0400008085202f8901e9f7b47c2a612e30a6e2cae39e1d4763901fedd076e9450c5df0f0d087d25\\\n                    e45010000006b483045022100a4553c79e56d119c50c73055d4e6d6a4f8faa2e257a6762c8f9e2758f208d774022\\\n                    0250257e51bbeb50ecd8e27b65d976b5108c3bf62ead19984a6377963bcdfd3de012103804a8e414c7c541d7a0720\\\n                    de5330e1fc51a696286b1523051286058ee9e724c3feffffff02650400000000000017a91466db59c466b84e64eda\\\n                    5db42cc48c5c8fc927cd4871148e111000000001976a914060277e4e1c2ab568d17ba769dcfc489a9c973a088ac09\\\n                    8b0400288b04000000000000000000000000\").unwrap();\n        let tx: Result<Transaction, _> = deserialize(&hex_tx);\n        assert!(tx.is_ok());\n        let realtx = tx.unwrap();\n        // All these tests aren't really needed because if they fail, the hash check at the end\n        // will also fail. But these will show you where the failure is so I'll leave them in.\n        assert_eq!(realtx.header, TxHeader::FourthAndOverwintered);\n        assert_eq!(realtx.version_group_id, 0x892F2085);\n        assert_eq!(realtx.input.len(), 1);\n        assert_eq!(realtx.output.len(), 2);\n        assert_eq!(realtx.lock_time, 297737);\n        assert_eq!(realtx.expiry_height, 297768);\n        assert_eq!(realtx.join_split.len(), 0);\n        assert_eq!(realtx.shielded_output.len(), 0);\n        assert_eq!(realtx.shielded_spend.len(), 0);\n        assert_eq!(realtx.binding_sig, None);\n        assert_eq!(realtx.join_split_pubkey, None);\n        assert_eq!(realtx.join_split_sig, None);\n    }", "item_id": 0, "repo": "rndintec/rust-bitcoin", "file": "src/blockdata/transaction.rs", "last_update_at": "2019-10-17T03:53:15+00:00", "question_id": "299ec8d08f451f1a3aad65b243a34e49c04917f5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_transaction() {\n        let hex_tx = hex_bytes(\"0400008085202f8901e9f7b47c2a612e30a6e2cae39e1d4763901fedd076e9450c5df0f0d087d25\\\n                    e45010000006b483045022100a4553c79e56d119c50c73055d4e6d6a4f8faa2e257a6762c8f9e2758f208d774022\\\n                    0250257e51bbeb50ecd8e27b65d976b5108c3bf62ead19984a6377963bcdfd3de012103804a8e414c7c541d7a0720\\\n                    de5330e1fc51a696286b1523051286058ee9e724c3feffffff02650400000000000017a91466db59c466b84e64eda\\\n                    5db42cc48c5c8fc927cd4871148e111000000001976a914060277e4e1c2ab568d17ba769dcfc489a9c973a088ac09\\\n                    8b0400288b04000000000000000000000000\").unwrap();\n        let tx: Result<Transaction, _> = deserialize(&hex_tx);\n        assert!(tx.is_ok());\n        let realtx = tx.unwrap();\n        // All these tests aren't really needed because if they fail, the hash check at the end\n        // will also fail. But these will show you where the failure is so I'll leave them in.\n        assert_eq!(realtx.header, TxHeader::FourthAndOverwintered);\n        assert_eq!(realtx.version_group_id, 0x892F2085);\n        assert_eq!(realtx.input.len(), 1);\n        assert_eq!(realtx.output.len(), 2);\n        assert_eq!(realtx.lock_time, 297737);\n        assert_eq!(realtx.expiry_height, 297768);\n        assert_eq!(realtx.join_split.len(), 0);\n        assert_eq!(realtx.shielded_output.len(), 0);\n        assert_eq!(realtx.shielded_spend.len(), 0);\n        assert_eq!(realtx.binding_sig, None);\n        assert_eq!(realtx.join_split_pubkey, None);\n        assert_eq!(realtx.join_split_sig, None);\n"]], "pred": {"ppl": 6.141390323638916, "ppl_lower": 6.47775936126709, "ppl/lowercase_ppl": -1.029378521525698, "ppl/zlib": 0.0025385330819591443, "Min_5.0% Prob": 6.838393106693175, "Min_10.0% Prob": 5.637928828960511, "Min_20.0% Prob": 4.440834480343443, "Min_30.0% Prob": 3.9112813434293194, "Min_40.0% Prob": 3.5967803894573107, "Min_50.0% Prob": 3.3458498209570915, "Min_60.0% Prob": 2.978523111499291}}
{"hexsha": "aca57c29143659cbac6350849918fd439a686969", "ext": "rs", "lang": "Rust", "content": "async fn main() {\n    env_logger::init();\n\n    let opts = Opt::parse();\n\n    let index_html_s = tokio::fs::read_to_string(opts.dir.join(\"index.html\"))\n        .await\n        .expect(\"failed to read index.html\");\n\n    let handle_error = |e| async move {\n        (\n            StatusCode::INTERNAL_SERVER_ERROR,\n            format!(\"error occurred: {}\", e),\n        )\n    };\n\n    let app = Router::new()\n        .route(\"/api/test\", get(|| async move { \"Hello World\" }))\n        // needed because https://github.com/tower-rs/tower-http/issues/262\n        .route(\"/\", get(render))\n        .fallback(HandleError::new(\n            ServeDir::new(opts.dir)\n                .append_index_html_on_directories(false)\n                .fallback(\n                    render\n                        .layer(Extension(index_html_s))\n                        .into_service()\n                        .map_err(|err| -> std::io::Error { match err {} }),\n                ),\n            handle_error,\n        ));\n\n    println!(\"You can view the website at: http://localhost:8080/\");\n\n    axum::Server::bind(&\"0.0.0.0:8080\".parse().unwrap())\n        .serve(app.into_make_service())\n        .await\n        .unwrap();\n}", "item_id": 1, "repo": "lostinspiration/yew", "file": "examples/ssr_router/src/bin/ssr_router_server.rs", "last_update_at": "2019-08-04T03:56:11+00:00", "question_id": "aca57c29143659cbac6350849918fd439a686969_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn main() {\n    env_logger::init();\n    let opts = Opt::parse();\n    let index_html_s = tokio::fs::read_to_string(opts.dir.join(\"index.html\"))\n        .await\n        .expect(\"failed to read index.html\");\n    let handle_error = |e| async move {\n        (\n            StatusCode::INTERNAL_SERVER_ERROR,\n            format!(\"error occurred: {}\", e),\n        )\n    };\n    let app = Router::new()\n        .route(\"/api/test\", get(|| async move { \"Hello World\" }))\n        // needed because https://github.com/tower-rs/tower-http/issues/262\n        .route(\"/\", get(render))\n        .fallback(HandleError::new(\n            ServeDir::new(opts.dir)\n                .append_index_html_on_directories(false)\n                .fallback(\n                    render\n                        .layer(Extension(index_html_s))\n                        .into_service()\n                        .map_err(|err| -> std::io::Error { match err {} }),\n                ),\n            handle_error,\n        ));\n    println!(\"You can view the website at: http://localhost:8080/\");\n    axum::Server::bind(&\"0.0.0.0:8080\".parse().unwrap())\n        .serve(app.into_make_service())\n        .await\n        .unwrap();\n"]], "pred": {"ppl": 2.3298819065093994, "ppl_lower": 3.144885301589966, "ppl/lowercase_ppl": -1.3546389236375642, "ppl/zlib": 0.0014658883576977324, "Min_5.0% Prob": 7.1285965707567005, "Min_10.0% Prob": 5.608405437734392, "Min_20.0% Prob": 3.747945703872263, "Min_30.0% Prob": 2.724801940108658, "Min_40.0% Prob": 2.093502522688614, "Min_50.0% Prob": 1.6856180638522724, "Min_60.0% Prob": 1.411895183331788}}
{"hexsha": "f8a18e866d4e60df133607ac744341aa1bf12e57", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let matches = App::new(\"TezEdge Protocol Runner\")\n        .version(env!(\"CARGO_PKG_VERSION\"))\n        .author(\"TezEdge and the project contributors\")\n        .about(\"Tezos Protocol Runner\")\n        .arg(\n            Arg::with_name(\"socket-path\")\n                .short(\"c\")\n                .long(\"socket-path\")\n                .value_name(\"path\")\n                .help(\"Path to a command socket\")\n                .takes_value(true)\n                .empty_values(false)\n                .required(true),\n        )\n        .arg(\n            Arg::with_name(\"endpoint\")\n                .long(\"endpoint\")\n                .value_name(\"STRING\")\n                .help(\"Name of the endpoint, which spawned runner\")\n                .takes_value(true)\n                .empty_values(false)\n                .required(true),\n        )\n        .arg(\n            Arg::with_name(\"log-level\")\n                .long(\"log-level\")\n                .takes_value(true)\n                .value_name(\"LEVEL\")\n                .possible_values(&[\"critical\", \"error\", \"warn\", \"info\", \"debug\", \"trace\"])\n                .help(\"Set log level\"),\n        )\n        .get_matches();\n\n    let cmd_socket_path = matches\n        .value_of(\"socket-path\")\n        .expect(\"Missing socket-path value\");\n    let endpoint_name = matches\n        .value_of(\"endpoint\")\n        .expect(\"Missing endpoint value\")\n        .to_string();\n    let log_level = matches\n        .value_of(\"log-level\")\n        .unwrap_or(\"info\")\n        .parse::<slog::Level>()\n        .expect(\"Was expecting one value from slog::Level\");\n\n    let log = create_logger(log_level, endpoint_name);\n\n    let shutdown_callback = |log: &Logger| {\n        debug!(log, \"Shutting down OCaml runtime\");\n        match std::panic::catch_unwind(|| {\n            tezos_interop::shutdown();\n        }) {\n            Ok(_) => debug!(log, \"OCaml runtime shutdown was successful\"),\n            Err(e) => {\n                warn!(log, \"Shutting down OCaml runtime failed (check running sub-process for this endpoint or `[protocol-runner] <defunct>`, and and terminate/kill manually)!\"; \"reason\" => format!(\"{:?}\", e))\n            }\n        }\n    };\n\n    {\n        let log = log.clone();\n        // do nothing and wait for parent process to send termination command\n        // this is just fallback, if ProtocolController.shutdown will fail or if we need to kill sub-process manually\n        ctrlc::set_handler(move || {\n            shutdown_callback(&log);\n            warn!(log, \"Protocol runner was terminated/killed/ctrl-c - please, check running sub-processes for `[protocol-runner] <defunct>`, and terminate/kill manually!\");\n        }).expect(\"Error setting Ctrl-C handler\");\n    }\n\n    #[cfg(dyncov)]\n    dyncov::initialize_callbacks();\n\n    match tezos_interop::start_ipc_loop(cmd_socket_path.into()) {\n        Err(OCamlBlockPanic) => warn!(log, \"Protocol runner loop exited with a panic\"),\n        Ok(Err(trace)) => warn!(log, \"Protocol runner loop exited with error: {:?}\", trace),\n        Ok(Ok(code)) => info!(\n            log,\n            \"Protocol runner exited with internal exit code = {}\", code\n        ),\n    }\n\n    shutdown_callback(&log);\n\n    info!(log, \"Protocol runner finished gracefully\");\n}", "item_id": 0, "repo": "simplestaking/tezos-rs", "file": "protocol_runner/src/main.rs", "last_update_at": "2019-10-25T18:40:15+00:00", "question_id": "f8a18e866d4e60df133607ac744341aa1bf12e57_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let matches = App::new(\"TezEdge Protocol Runner\")\n        .version(env!(\"CARGO_PKG_VERSION\"))\n        .author(\"TezEdge and the project contributors\")\n        .about(\"Tezos Protocol Runner\")\n        .arg(\n            Arg::with_name(\"socket-path\")\n                .short(\"c\")\n                .long(\"socket-path\")\n                .value_name(\"path\")\n                .help(\"Path to a command socket\")\n                .takes_value(true)\n                .empty_values(false)\n                .required(true),\n        )\n        .arg(\n            Arg::with_name(\"endpoint\")\n                .long(\"endpoint\")\n                .value_name(\"STRING\")\n                .help(\"Name of the endpoint, which spawned runner\")\n                .takes_value(true)\n                .empty_values(false)\n                .required(true),\n        )\n        .arg(\n            Arg::with_name(\"log-level\")\n                .long(\"log-level\")\n                .takes_value(true)\n                .value_name(\"LEVEL\")\n                .possible_values(&[\"critical\", \"error\", \"warn\", \"info\", \"debug\", \"trace\"])\n                .help(\"Set log level\"),\n        )\n        .get_matches();\n    let cmd_socket_path = matches\n        .value_of(\"socket-path\")\n        .expect(\"Missing socket-path value\");\n    let endpoint_name = matches\n        .value_of(\"endpoint\")\n        .expect(\"Missing endpoint value\")\n        .to_string();\n    let log_level = matches\n        .value_of(\"log-level\")\n        .unwrap_or(\"info\")\n        .parse::<slog::Level>()\n        .expect(\"Was expecting one value from slog::Level\");\n    let log = create_logger(log_level, endpoint_name);\n    let shutdown_callback = |log: &Logger| {\n        debug!(log, \"Shutting down OCaml runtime\");\n        match std::panic::catch_unwind(|| {\n            tezos_interop::shutdown();\n        }) {\n            Ok(_) => debug!(log, \"OCaml runtime shutdown was successful\"),\n            Err(e) => {\n                warn!(log, \"Shutting down OCaml runtime failed (check running sub-process for this endpoint or `[protocol-runner] <defunct>`, and and terminate/kill manually)!\"; \"reason\" => format!(\"{:?}\", e))\n            }\n        }\n    };\n    {\n        let log = log.clone();\n        // do nothing and wait for parent process to send termination command\n        // this is just fallback, if ProtocolController.shutdown will fail or if we need to kill sub-process manually\n        ctrlc::set_handler(move || {\n            shutdown_callback(&log);\n            warn!(log, \"Protocol runner was terminated/killed/ctrl-c - please, check running sub-processes for `[protocol-runner] <defunct>`, and terminate/kill manually!\");\n        }).expect(\"Error setting Ctrl-C handler\");\n    }\n    #[cfg(dyncov)]\n    dyncov::initialize_callbacks();\n    match tezos_interop::start_ipc_loop(cmd_socket_path.into()) {\n        Err(OCamlBlockPanic) => warn!(log, \"Protocol runner loop exited with a panic\"),\n        Ok(Err(trace)) => warn!(log, \"Protocol runner loop exited with error: {:?}\", trace),\n        Ok(Ok(code)) => info!(\n            log,\n            \"Protocol runner exited with internal exit code = {}\", code\n        ),\n    }\n    shutdown_callback(&log);\n    info!(log, \"Protocol runner finished gracefully\");\n"]], "pred": {"ppl": 2.469379186630249, "ppl_lower": 2.7957444190979004, "ppl/lowercase_ppl": -1.1373187999684455, "ppl/zlib": 0.0007929533136869192, "Min_5.0% Prob": 7.402967495388455, "Min_10.0% Prob": 5.851560356881883, "Min_20.0% Prob": 4.013207014753015, "Min_30.0% Prob": 2.915107855463729, "Min_40.0% Prob": 2.2426982328870406, "Min_50.0% Prob": 1.8060728979916496, "Min_60.0% Prob": 1.5069680918922324}}
{"hexsha": "8be196cd7b12228b079f482931760d8c91b265a9", "ext": "rs", "lang": "Rust", "content": "pub fn update_handler(request: &mut Request) -> IronResult<Response> {\n    // get param id\n    let id = request.extensions.get::<Router>().unwrap().find(\"id\").unwrap().to_owned();\n    \n    // get the body\n    let body_option = itry!(request.get::<bodyparser::Raw>(), status::BadRequest);\n    let raw_body = iexpect!(body_option, status::BadRequest);\n    let todo_partial = itry!(serde_json::from_str(&raw_body), status::BadRequest);\n\n    let mutex = request.get::<State<TodoItems>>().unwrap();\n    let mut todo_items = mutex.write().unwrap();\n\n    // find item (as mutable)\n    let item_option = todo_items.iter_mut().find(|item| item.get_id() == id);\n    let mut item = iexpect!(item_option, status::NotFound);\n\n    item.update(todo_partial);\n\n    Ok(Response::with((status::Ok, format!(\"{{\\\"id\\\": \\\"{}\\\"}}\", item.get_id()))))\n}", "item_id": 2, "repo": "lofim/rust-todo-backend", "file": "src/controller.rs", "last_update_at": "2019-06-10T11:29:24+00:00", "question_id": "8be196cd7b12228b079f482931760d8c91b265a9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn update_handler(request: &mut Request) -> IronResult<Response> {\n    // get param id\n    let id = request.extensions.get::<Router>().unwrap().find(\"id\").unwrap().to_owned();\n    // get the body\n    let body_option = itry!(request.get::<bodyparser::Raw>(), status::BadRequest);\n    let raw_body = iexpect!(body_option, status::BadRequest);\n    let todo_partial = itry!(serde_json::from_str(&raw_body), status::BadRequest);\n    let mutex = request.get::<State<TodoItems>>().unwrap();\n    let mut todo_items = mutex.write().unwrap();\n    // find item (as mutable)\n    let item_option = todo_items.iter_mut().find(|item| item.get_id() == id);\n    let mut item = iexpect!(item_option, status::NotFound);\n    item.update(todo_partial);\n    Ok(Response::with((status::Ok, format!(\"{{\\\"id\\\": \\\"{}\\\"}}\", item.get_id()))))\n"]], "pred": {"ppl": 2.596681833267212, "ppl_lower": 3.3313000202178955, "ppl/lowercase_ppl": -1.2610765333386373, "ppl/zlib": 0.00234455629482455, "Min_5.0% Prob": 8.997340825887827, "Min_10.0% Prob": 6.521815626709549, "Min_20.0% Prob": 4.179534085370876, "Min_30.0% Prob": 3.033891823924618, "Min_40.0% Prob": 2.347954665621122, "Min_50.0% Prob": 1.8913996924153145, "Min_60.0% Prob": 1.587391545070461}}
{"hexsha": "6c6b7709d25131232741c5b45dd3d3a10fea5786", "ext": "rs", "lang": "Rust", "content": "fn parse_goodbye(msg: &[Value]) -> Result<rx::Goodbye, MessageParseError> {\n    if msg.len() != 2 {\n        warn!(\"Bad GOODBYE message length: {}\", msg.len());\n        return Err(MessageParseError::BadMessageLength);\n    }\n\n    let details = helpers::parse_details(&msg[0])?;\n    let reason = helpers::parse_uri(&msg[1])?;\n\n    let goodbye = rx::Goodbye { details, reason };\n    trace!(\"Received GOODBYE message: {:?}\", goodbye);\n    Ok(goodbye)\n}", "item_id": 9, "repo": "zrneely/wamp-proto", "file": "src/transport/websocket/parsers.rs", "last_update_at": "2019-11-03T00:07:27+00:00", "question_id": "6c6b7709d25131232741c5b45dd3d3a10fea5786_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_goodbye(msg: &[Value]) -> Result<rx::Goodbye, MessageParseError> {\n    if msg.len() != 2 {\n        warn!(\"Bad GOODBYE message length: {}\", msg.len());\n        return Err(MessageParseError::BadMessageLength);\n    }\n    let details = helpers::parse_details(&msg[0])?;\n    let reason = helpers::parse_uri(&msg[1])?;\n    let goodbye = rx::Goodbye { details, reason };\n    trace!(\"Received GOODBYE message: {:?}\", goodbye);\n    Ok(goodbye)\n"]], "pred": {"ppl": 2.3391799926757812, "ppl_lower": 3.0541863441467285, "ppl/lowercase_ppl": -1.3138534320760509, "ppl/zlib": 0.0033066164882259363, "Min_5.0% Prob": 8.931060109819684, "Min_10.0% Prob": 6.02828377087911, "Min_20.0% Prob": 3.7884228487809497, "Min_30.0% Prob": 2.7296456111801994, "Min_40.0% Prob": 2.116667053103447, "Min_50.0% Prob": 1.6922184420063306, "Min_60.0% Prob": 1.417684658277002}}
{"hexsha": "814cbcc022d08652f6da9219c91e0c8da2a81337", "ext": "rs", "lang": "Rust", "content": "fn binding_to_unimplemented_apis_doesnt_break_everything() {\n    let array = Array::new();\n    let res = array.standardized_method_this_js_runtime_doesnt_implement_yet();\n    assert!(res.is_err());\n}", "item_id": 0, "repo": "not-an-aardvark/wasm-bindgen", "file": "tests/wasm/simple.rs", "last_update_at": "2019-10-15T03:00:51+00:00", "question_id": "814cbcc022d08652f6da9219c91e0c8da2a81337_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn binding_to_unimplemented_apis_doesnt_break_everything() {\n    let array = Array::new();\n    let res = array.standardized_method_this_js_runtime_doesnt_implement_yet();\n    assert!(res.is_err());\n"]], "pred": {"ppl": 7.8828816413879395, "ppl_lower": 8.909316062927246, "ppl/lowercase_ppl": -1.0592843193123007, "ppl/zlib": 0.014141736490087441, "Min_5.0% Prob": 11.016687711079916, "Min_10.0% Prob": 10.090316931406656, "Min_20.0% Prob": 7.789311959193303, "Min_30.0% Prob": 6.211088955402374, "Min_40.0% Prob": 4.96934668885337, "Min_50.0% Prob": 4.076415145221879, "Min_60.0% Prob": 3.4349490349612584}}
{"hexsha": "3deac005077f7c70c346c676b2f9596a2b4440d9", "ext": "rs", "lang": "Rust", "content": "fn join_is_inserted_positionally() {\n        let joined_table = Table::from(\"User\").left_join(\n            \"Post\"\n                .alias(\"p\")\n                .on((\"p\", \"userId\").equals(Column::from((\"User\", \"id\")))),\n        );\n        let q = Select::from_table(joined_table).and_from(\"Toto\");\n        let (sql, _) = Postgres::build(q).unwrap();\n\n        assert_eq!(\"SELECT \\\"User\\\".*, \\\"Toto\\\".* FROM \\\"User\\\" LEFT JOIN \\\"Post\\\" AS \\\"p\\\" ON \\\"p\\\".\\\"userId\\\" = \\\"User\\\".\\\"id\\\", \\\"Toto\\\"\", sql);\n    }", "item_id": 34, "repo": "prisma/prisma-query", "file": "src/visitor/postgres.rs", "last_update_at": "2019-11-02T17:23:18+00:00", "question_id": "3deac005077f7c70c346c676b2f9596a2b4440d9_34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn join_is_inserted_positionally() {\n        let joined_table = Table::from(\"User\").left_join(\n            \"Post\"\n                .alias(\"p\")\n                .on((\"p\", \"userId\").equals(Column::from((\"User\", \"id\")))),\n        );\n        let q = Select::from_table(joined_table).and_from(\"Toto\");\n        let (sql, _) = Postgres::build(q).unwrap();\n        assert_eq!(\"SELECT \\\"User\\\".*, \\\"Toto\\\".* FROM \\\"User\\\" LEFT JOIN \\\"Post\\\" AS \\\"p\\\" ON \\\"p\\\".\\\"userId\\\" = \\\"User\\\".\\\"id\\\", \\\"Toto\\\"\", sql);\n"]], "pred": {"ppl": 2.666048288345337, "ppl_lower": 3.155341863632202, "ppl/lowercase_ppl": -1.1718335407724734, "ppl/zlib": 0.003440692400877721, "Min_5.0% Prob": 7.766264796257019, "Min_10.0% Prob": 6.156205266714096, "Min_20.0% Prob": 4.104471932757985, "Min_30.0% Prob": 3.043528674840927, "Min_40.0% Prob": 2.4089142522125533, "Min_50.0% Prob": 1.9549356996115432, "Min_60.0% Prob": 1.633410422988236}}
{"hexsha": "d3498df38a6f786e322e2eae2e457e06ee9b7226", "ext": "rs", "lang": "Rust", "content": "pub fn with_prof_context<T, F: FnOnce()->T>(s: &str, f: F) -> T {\n    set_prof_context(s);\n    let res = f();\n    set_prof_context(\"\");\n    res\n}", "item_id": 0, "repo": "remysucre/differential-datalog", "file": "rust/template/differential_datalog/profile.rs", "last_update_at": "2019-07-04T00:43:39+00:00", "question_id": "d3498df38a6f786e322e2eae2e457e06ee9b7226_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn with_prof_context<T, F: FnOnce()->T>(s: &str, f: F) -> T {\n    set_prof_context(s);\n    let res = f();\n    set_prof_context(\"\");\n    res\n"]], "pred": {"ppl": 3.3896708488464355, "ppl_lower": 5.998319625854492, "ppl/lowercase_ppl": -1.4675441959482558, "ppl/zlib": 0.011097571108570865, "Min_5.0% Prob": 10.175543467203775, "Min_10.0% Prob": 8.065011739730835, "Min_20.0% Prob": 5.398795207341512, "Min_30.0% Prob": 3.9283373951911926, "Min_40.0% Prob": 3.026833196481069, "Min_50.0% Prob": 2.456676201770703, "Min_60.0% Prob": 2.059915222434534}}
{"hexsha": "fe10072128c762a21040b34bde45feaa361b5dbc", "ext": "rs", "lang": "Rust", "content": "fn unbalanced_at(graph: &Graph<Node, ()>, node: NodeIndex) -> Option<(NodeIndex, usize)> {\n    let mut dfs = Dfs::new(&graph, node);\n    while let Some(nx) = dfs.next(&graph) {\n        let mut expected_weight = None;\n        for neighbor in graph.neighbors_directed(nx, Outgoing) {\n            let neighbor_weight = weight_for_node(&graph, neighbor);\n            if expected_weight.is_none() {\n                expected_weight = Some(neighbor_weight);\n            }\n            if neighbor_weight != expected_weight.unwrap() {\n                return Some((neighbor, expected_weight.unwrap()));\n            }\n        }\n    }\n    None\n}", "item_id": 4, "repo": "Mark-Simulacrum/advent-of-code", "file": "src/bin/y2017/day07.rs", "last_update_at": "2019-04-05T21:56:09+00:00", "question_id": "fe10072128c762a21040b34bde45feaa361b5dbc_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn unbalanced_at(graph: &Graph<Node, ()>, node: NodeIndex) -> Option<(NodeIndex, usize)> {\n    let mut dfs = Dfs::new(&graph, node);\n    while let Some(nx) = dfs.next(&graph) {\n        let mut expected_weight = None;\n        for neighbor in graph.neighbors_directed(nx, Outgoing) {\n            let neighbor_weight = weight_for_node(&graph, neighbor);\n            if expected_weight.is_none() {\n                expected_weight = Some(neighbor_weight);\n            }\n            if neighbor_weight != expected_weight.unwrap() {\n                return Some((neighbor, expected_weight.unwrap()));\n            }\n        }\n    }\n    None\n"]], "pred": {"ppl": 2.0278337001800537, "ppl_lower": 2.520658254623413, "ppl/lowercase_ppl": -1.3077253486945264, "ppl/zlib": 0.002570793019938166, "Min_5.0% Prob": 6.746401733822292, "Min_10.0% Prob": 4.911025206247966, "Min_20.0% Prob": 3.133063210023416, "Min_30.0% Prob": 2.2943935014984826, "Min_40.0% Prob": 1.7468674083215159, "Min_50.0% Prob": 1.417165851706396, "Min_60.0% Prob": 1.177473966103584}}
{"hexsha": "b683a9bc0cbf1f4c4272cab9f93c985ad6eb9290", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn handle_cursor_motion(mut listener: *mut wl_listener,\n                                          mut data: *mut libc::c_void) {\n    let mut sample: *mut sample_state =\n        (listener as *mut libc::c_char).offset(-168) as *mut sample_state;\n    let mut event: *mut wlr_event_pointer_motion =\n        data as *mut wlr_event_pointer_motion;\n    wlr_cursor_move((*sample).cursor, (*event).device, (*event).delta_x,\n                    (*event).delta_y);\n}", "item_id": 2, "repo": "RoastVeg/wlrusts", "file": "src/examples/pointer.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "b683a9bc0cbf1f4c4272cab9f93c985ad6eb9290_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe extern \"C\" fn handle_cursor_motion(mut listener: *mut wl_listener,\n                                          mut data: *mut libc::c_void) {\n    let mut sample: *mut sample_state =\n        (listener as *mut libc::c_char).offset(-168) as *mut sample_state;\n    let mut event: *mut wlr_event_pointer_motion =\n        data as *mut wlr_event_pointer_motion;\n    wlr_cursor_move((*sample).cursor, (*event).device, (*event).delta_x,\n                    (*event).delta_y);\n"]], "pred": {"ppl": 1.8696194887161255, "ppl_lower": 1.9385663270950317, "ppl/lowercase_ppl": -1.0578739709106622, "ppl/zlib": 0.002923994991547869, "Min_5.0% Prob": 8.09122623716082, "Min_10.0% Prob": 4.874723688761393, "Min_20.0% Prob": 2.907764369249344, "Min_30.0% Prob": 2.0462372091081407, "Min_40.0% Prob": 1.5595166432360807, "Min_50.0% Prob": 1.2563325909276803, "Min_60.0% Prob": 1.04921952051421}}
{"hexsha": "f648d923a7db5cc7b0d38b1fc342933334116d2d", "ext": "rs", "lang": "Rust", "content": "pub fn get_row(mut row_index: i32) -> Vec<i32> {\n    row_index += 1;\n    if row_index == 1 {\n        return vec![1];\n    }\n    let mut res = vec![1];\n    let row_index = row_index as usize;\n    for i in 1..row_index {\n        for j in (1..=i).rev() {\n            if j == i {\n                res.push(1);\n            } else {\n                let sum = res[j - 1] + res[j];\n                res[j] = sum;\n            }\n        }\n    }\n\n    res\n}", "item_id": 0, "repo": "yjhmelody/leetcode-rust", "file": "src/pascal_triangle_2.rs", "last_update_at": "2019-06-05T06:51:56+00:00", "question_id": "f648d923a7db5cc7b0d38b1fc342933334116d2d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_row(mut row_index: i32) -> Vec<i32> {\n    row_index += 1;\n    if row_index == 1 {\n        return vec![1];\n    }\n    let mut res = vec![1];\n    let row_index = row_index as usize;\n    for i in 1..row_index {\n        for j in (1..=i).rev() {\n            if j == i {\n                res.push(1);\n            } else {\n                let sum = res[j - 1] + res[j];\n                res[j] = sum;\n            }\n        }\n    }\n    res\n"]], "pred": {"ppl": 1.9221292734146118, "ppl_lower": 2.0897879600524902, "ppl/lowercase_ppl": -1.1279839944890202, "ppl/zlib": 0.0030968415551060106, "Min_5.0% Prob": 5.7856104373931885, "Min_10.0% Prob": 4.238746628165245, "Min_20.0% Prob": 2.8661583960056305, "Min_30.0% Prob": 2.0929615994294486, "Min_40.0% Prob": 1.5981998230402286, "Min_50.0% Prob": 1.2995004920679847, "Min_60.0% Prob": 1.0931115666231543}}
{"hexsha": "3b302192db72a36180e84949f0e32c0ba23d8d6a", "ext": "rs", "lang": "Rust", "content": "fn fontgen_should_reject_padding_larger_than_slot_glyph_size() -> Result<(), Box<std::error::Error>> {\n    let mut cmd = Command::cargo_bin(\"fontgen\")?;\n    cmd.arg(\"--input\")\n        .arg(\"assets/FreeMono.ttf\")\n        .arg(\"--output\")\n        .arg(\"FreeMono.bmfa\")\n        .arg(\"--padding\")\n        .arg(\"129\")\n        .arg(\"--slot-glyph-size\")\n        .arg(\"128\");\n    cmd.assert().failure();\n\n    Ok(())\n}", "item_id": 2, "repo": "lambdaxymox/fontgen", "file": "tests/fontgen.rs", "last_update_at": "2019-05-08T14:51:01+00:00", "question_id": "3b302192db72a36180e84949f0e32c0ba23d8d6a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn fontgen_should_reject_padding_larger_than_slot_glyph_size() -> Result<(), Box<std::error::Error>> {\n    let mut cmd = Command::cargo_bin(\"fontgen\")?;\n    cmd.arg(\"--input\")\n        .arg(\"assets/FreeMono.ttf\")\n        .arg(\"--output\")\n        .arg(\"FreeMono.bmfa\")\n        .arg(\"--padding\")\n        .arg(\"129\")\n        .arg(\"--slot-glyph-size\")\n        .arg(\"128\");\n    cmd.assert().failure();\n    Ok(())\n"]], "pred": {"ppl": 2.7814064025878906, "ppl_lower": 3.8078174591064453, "ppl/lowercase_ppl": -1.3070506108759574, "ppl/zlib": 0.004298137394914487, "Min_5.0% Prob": 8.645497049604144, "Min_10.0% Prob": 6.991693719228109, "Min_20.0% Prob": 4.571065391263654, "Min_30.0% Prob": 3.3123407357412837, "Min_40.0% Prob": 2.5303329832611547, "Min_50.0% Prob": 2.052816061956155, "Min_60.0% Prob": 1.7037602748661753}}
{"hexsha": "53d4becce91a846b8e0d0f880bb3593ffb82e915", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn wlr_surface_send_leave(mut surface: *mut wlr_surface,\n                                                mut output: *mut wlr_output) {\n    let mut client: *mut wl_client =\n        wl_resource_get_client((*surface).resource);\n    let mut resource: *mut wl_resource = 0 as *mut wl_resource;\n    resource = 0 as *mut wl_resource;\n    resource = wl_resource_from_link((*output).resources.next);\n    while wl_resource_get_link(resource) !=\n              &mut (*output).resources as *mut wl_list {\n        if client == wl_resource_get_client(resource) {\n            wl_surface_send_leave((*surface).resource, resource);\n        }\n        resource =\n            wl_resource_from_link((*wl_resource_get_link(resource)).next)\n    };\n}", "item_id": 43, "repo": "RoastVeg/wlrusts", "file": "src/types/wlr_surface.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "53d4becce91a846b8e0d0f880bb3593ffb82e915_43", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn wlr_surface_send_leave(mut surface: *mut wlr_surface,\n                                                mut output: *mut wlr_output) {\n    let mut client: *mut wl_client =\n        wl_resource_get_client((*surface).resource);\n    let mut resource: *mut wl_resource = 0 as *mut wl_resource;\n    resource = 0 as *mut wl_resource;\n    resource = wl_resource_from_link((*output).resources.next);\n    while wl_resource_get_link(resource) !=\n              &mut (*output).resources as *mut wl_list {\n        if client == wl_resource_get_client(resource) {\n            wl_surface_send_leave((*surface).resource, resource);\n        }\n        resource =\n            wl_resource_from_link((*wl_resource_get_link(resource)).next)\n    };\n"]], "pred": {"ppl": 1.4678125381469727, "ppl_lower": 1.5092312097549438, "ppl/lowercase_ppl": -1.0725093978677054, "ppl/zlib": 0.0015664213192986632, "Min_5.0% Prob": 4.787550709464333, "Min_10.0% Prob": 3.248953964399255, "Min_20.0% Prob": 1.8693011644038748, "Min_30.0% Prob": 1.2675354494385316, "Min_40.0% Prob": 0.9644941714730986, "Min_50.0% Prob": 0.7700672607229612, "Min_60.0% Prob": 0.6403841509821523}}
{"hexsha": "8abc642a1a9e173471919c37ded33ce7410c8640", "ext": "rs", "lang": "Rust", "content": "fn add_team_as_non_member() {\n    let (app, _) = TestApp::with_proxy().empty();\n    let user = app.db_new_user(mock_user_on_only_one_team().gh_login);\n    let token = user.db_new_token(\"arbitrary token name\");\n\n    app.db(|conn| {\n        CrateBuilder::new(\"foo_team_non_member\", user.as_model().id).expect_build(conn);\n    });\n\n    let json = token\n        .add_named_owner(\n            \"foo_team_non_member\",\n            \"github:crates-test-org:just-for-crates-2\",\n        )\n        .bad_with_status(200);\n\n    assert!(\n        json.errors[0]\n            .detail\n            .contains(\"only members of a team can add it as an owner\"),\n        \"{:?}\",\n        json.errors\n    );\n}", "item_id": 5, "repo": "FreeMasen/crates.io", "file": "src/tests/team.rs", "last_update_at": "2019-04-28T19:41:26+00:00", "question_id": "8abc642a1a9e173471919c37ded33ce7410c8640_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn add_team_as_non_member() {\n    let (app, _) = TestApp::with_proxy().empty();\n    let user = app.db_new_user(mock_user_on_only_one_team().gh_login);\n    let token = user.db_new_token(\"arbitrary token name\");\n    app.db(|conn| {\n        CrateBuilder::new(\"foo_team_non_member\", user.as_model().id).expect_build(conn);\n    });\n    let json = token\n        .add_named_owner(\n            \"foo_team_non_member\",\n            \"github:crates-test-org:just-for-crates-2\",\n        )\n        .bad_with_status(200);\n    assert!(\n        json.errors[0]\n            .detail\n            .contains(\"only members of a team can add it as an owner\"),\n        \"{:?}\",\n        json.errors\n    );\n"]], "pred": {"ppl": 3.1579113006591797, "ppl_lower": 4.255175590515137, "ppl/lowercase_ppl": -1.2593463705729255, "ppl/zlib": 0.0032030942291104304, "Min_5.0% Prob": 8.229718858545477, "Min_10.0% Prob": 6.762671366981838, "Min_20.0% Prob": 4.908093628676041, "Min_30.0% Prob": 3.6157274075916837, "Min_40.0% Prob": 2.8158841011344746, "Min_50.0% Prob": 2.277569203167899, "Min_60.0% Prob": 1.91699796518577}}
{"hexsha": "9cc9e61b1b2da25cbe78ae25641c848b7e3bd037", "ext": "rs", "lang": "Rust", "content": "fn logout(client: &mut Client) -> Result<(), Error> {\n    println!(\"Logging out...\");\n\n    let logout_res = match client.logout() {\n        Ok(t) => t,\n        Err(e) => {\n            let msg = format!(\"Failed to run logout: {}\", e);\n            return Err(Error::Custom(msg));\n        }\n    };\n\n    if logout_res.is_not_success() {\n        let msg = format!(\"Failed to logout: {}\", logout_res.data[\"message\"]);\n        return Err(Error::Custom(msg));\n    }\n\n    Ok(())\n}", "item_id": 6, "repo": "seiruss/cp_api", "file": "examples/unused_objects.rs", "last_update_at": "2019-03-10T05:15:50+00:00", "question_id": "9cc9e61b1b2da25cbe78ae25641c848b7e3bd037_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn logout(client: &mut Client) -> Result<(), Error> {\n    println!(\"Logging out...\");\n    let logout_res = match client.logout() {\n        Ok(t) => t,\n        Err(e) => {\n            let msg = format!(\"Failed to run logout: {}\", e);\n            return Err(Error::Custom(msg));\n        }\n    };\n    if logout_res.is_not_success() {\n        let msg = format!(\"Failed to logout: {}\", logout_res.data[\"message\"]);\n        return Err(Error::Custom(msg));\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.0214734077453613, "ppl_lower": 2.414013385772705, "ppl/lowercase_ppl": -1.2521416474997178, "ppl/zlib": 0.0029083746086695133, "Min_5.0% Prob": 6.607807636260986, "Min_10.0% Prob": 5.051607322692871, "Min_20.0% Prob": 3.097844789105077, "Min_30.0% Prob": 2.2588861364385355, "Min_40.0% Prob": 1.7323278961402755, "Min_50.0% Prob": 1.4074423970146612, "Min_60.0% Prob": 1.1704550217436527}}
{"hexsha": "7c00465375714126de0fd6af657926f61181f564", "ext": "rs", "lang": "Rust", "content": "fn test_parse_value_param() {\n        let v: Value = json!({ \"confirmations\": 10 });\n\n        let confirmations = v\n            .get(\"confirmations\")\n            .and_then(|el| el.as_u64())\n            .ok_or(HttpError::from(\n                \"confirmations absent or not a u64\".to_string(),\n            ))\n            .unwrap();\n\n        assert_eq!(10, confirmations);\n\n        let err = v\n            .get(\"notexist\")\n            .and_then(|el| el.as_u64())\n            .ok_or(HttpError::from(\"notexist absent or not a u64\".to_string()));\n\n        assert!(err.is_err());\n    }", "item_id": 7, "repo": "dogecash/electrs-dogecash", "file": "src/rest.rs", "last_update_at": "2019-03-04T09:08:35+00:00", "question_id": "7c00465375714126de0fd6af657926f61181f564_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_parse_value_param() {\n        let v: Value = json!({ \"confirmations\": 10 });\n        let confirmations = v\n            .get(\"confirmations\")\n            .and_then(|el| el.as_u64())\n            .ok_or(HttpError::from(\n                \"confirmations absent or not a u64\".to_string(),\n            ))\n            .unwrap();\n        assert_eq!(10, confirmations);\n        let err = v\n            .get(\"notexist\")\n            .and_then(|el| el.as_u64())\n            .ok_or(HttpError::from(\"notexist absent or not a u64\".to_string()));\n        assert!(err.is_err());\n"]], "pred": {"ppl": 2.27461838722229, "ppl_lower": 2.4628474712371826, "ppl/lowercase_ppl": -1.096744588845307, "ppl/zlib": 0.0034970736019249316, "Min_5.0% Prob": 7.437035613589817, "Min_10.0% Prob": 5.607801596323649, "Min_20.0% Prob": 3.625243137280146, "Min_30.0% Prob": 2.638551367101846, "Min_40.0% Prob": 2.0291202997099864, "Min_50.0% Prob": 1.645768611681658, "Min_60.0% Prob": 1.378264702232811}}
{"hexsha": "c9b0c98eaee246e494403e5118411b99fae85574", "ext": "rs", "lang": "Rust", "content": "fn run() -> std::result::Result<(), Box<dyn std::error::Error>> {\n    let mut manager = dbus_bluez::BluezManager::new()?;\n    let cmd_opts = CmdOpts::from_args();\n\n    manager.start_discovery(Some(4000))?;\n\n    match cmd_opts.cmd {\n        cmd_opts::Command::Scan { duration_sec } => scan(&mut manager, &cmd_opts, duration_sec)?,\n        cmd_opts::Command::Read { ref addr } => read(&mut manager, &cmd_opts, addr)?,\n        cmd_opts::Command::Blink { ref addr } => blink(&mut manager, &cmd_opts, addr)?,\n        cmd_opts::Command::History { ref addr, from, to, page, clear } => history(&mut manager, &cmd_opts, addr, from, to, page, clear)?,\n        cmd_opts::Command::HistoryCount { ref addr } => history_count(&mut manager, &cmd_opts, addr)?,\n        cmd_opts::Command::HistoryClear { ref addr } => clear_history(&mut manager, &cmd_opts, addr)?,\n    }\n\n    Ok(())\n}", "item_id": 6, "repo": "dennis/hat", "file": "hat-miflora/src/main.rs", "last_update_at": "2019-05-11T00:28:18+00:00", "question_id": "c9b0c98eaee246e494403e5118411b99fae85574_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn run() -> std::result::Result<(), Box<dyn std::error::Error>> {\n    let mut manager = dbus_bluez::BluezManager::new()?;\n    let cmd_opts = CmdOpts::from_args();\n    manager.start_discovery(Some(4000))?;\n    match cmd_opts.cmd {\n        cmd_opts::Command::Scan { duration_sec } => scan(&mut manager, &cmd_opts, duration_sec)?,\n        cmd_opts::Command::Read { ref addr } => read(&mut manager, &cmd_opts, addr)?,\n        cmd_opts::Command::Blink { ref addr } => blink(&mut manager, &cmd_opts, addr)?,\n        cmd_opts::Command::History { ref addr, from, to, page, clear } => history(&mut manager, &cmd_opts, addr, from, to, page, clear)?,\n        cmd_opts::Command::HistoryCount { ref addr } => history_count(&mut manager, &cmd_opts, addr)?,\n        cmd_opts::Command::HistoryClear { ref addr } => clear_history(&mut manager, &cmd_opts, addr)?,\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.0912833213806152, "ppl_lower": 2.7705883979797363, "ppl/lowercase_ppl": -1.381255396976874, "ppl/zlib": 0.002249322886910172, "Min_5.0% Prob": 6.62243744305202, "Min_10.0% Prob": 5.165610253810883, "Min_20.0% Prob": 3.387698320966018, "Min_30.0% Prob": 2.4052512701167617, "Min_40.0% Prob": 1.8360963498768599, "Min_50.0% Prob": 1.4729074479805098, "Min_60.0% Prob": 1.2347621090309477}}
{"hexsha": "c3c329bb1e4cac9189079e337c9f390bdb7e218d", "ext": "rs", "lang": "Rust", "content": "fn test_codec_datetime() -> Result<()> {\n        let cases = vec![\n            (\"2010-10-10 10:11:11\", 0),\n            (\"2017-01-01 00:00:00\", 0),\n            (\"2004-01-01 00:00:00\", UNSPECIFIED_FSP),\n            (\"2013-01-01 00:00:00.000000\", MAX_FSP),\n            (\"2019-01-01 00:00:00.123456\", MAX_FSP),\n            (\"2001-01-01 00:00:00.123456\", MAX_FSP),\n            (\"2007-06-01 00:00:00.999999\", MAX_FSP),\n            // Invalid cases\n            (\"0000-00-00 00:00:00\", 0),\n            (\"2007-00-01 00:00:00.999999\", MAX_FSP),\n            (\"2017-01-00 00:00:00.999999\", MAX_FSP),\n            (\"2027-00-00 00:00:00.999999\", MAX_FSP),\n            (\"2027-04-31 00:00:00.999999\", MAX_FSP),\n        ];\n\n        for (case, fsp) in cases {\n            let mut ctx = EvalContext::from(TimeEnv {\n                allow_invalid_date: true,\n                ..TimeEnv::default()\n            });\n            let time = Time::parse_datetime(&mut ctx, case, fsp, false)?;\n\n            let packed = time.to_packed_u64(&mut ctx)?;\n            let reverted_datetime =\n                Time::from_packed_u64(&mut ctx, packed, TimeType::DateTime, fsp)?;\n\n            assert_eq!(time, reverted_datetime);\n        }\n\n        Ok(())\n    }", "item_id": 24, "repo": "andylokandy/tikv", "file": "components/tidb_query/src/codec/mysql/time/mod.rs", "last_update_at": "2019-06-20T15:45:53+00:00", "question_id": "c3c329bb1e4cac9189079e337c9f390bdb7e218d_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_codec_datetime() -> Result<()> {\n        let cases = vec![\n            (\"2010-10-10 10:11:11\", 0),\n            (\"2017-01-01 00:00:00\", 0),\n            (\"2004-01-01 00:00:00\", UNSPECIFIED_FSP),\n            (\"2013-01-01 00:00:00.000000\", MAX_FSP),\n            (\"2019-01-01 00:00:00.123456\", MAX_FSP),\n            (\"2001-01-01 00:00:00.123456\", MAX_FSP),\n            (\"2007-06-01 00:00:00.999999\", MAX_FSP),\n            // Invalid cases\n            (\"0000-00-00 00:00:00\", 0),\n            (\"2007-00-01 00:00:00.999999\", MAX_FSP),\n            (\"2017-01-00 00:00:00.999999\", MAX_FSP),\n            (\"2027-00-00 00:00:00.999999\", MAX_FSP),\n            (\"2027-04-31 00:00:00.999999\", MAX_FSP),\n        ];\n        for (case, fsp) in cases {\n            let mut ctx = EvalContext::from(TimeEnv {\n                allow_invalid_date: true,\n                ..TimeEnv::default()\n            });\n            let time = Time::parse_datetime(&mut ctx, case, fsp, false)?;\n            let packed = time.to_packed_u64(&mut ctx)?;\n            let reverted_datetime =\n                Time::from_packed_u64(&mut ctx, packed, TimeType::DateTime, fsp)?;\n            assert_eq!(time, reverted_datetime);\n        }\n        Ok(())\n"]], "pred": {"ppl": 1.7537328004837036, "ppl_lower": 2.056215524673462, "ppl/lowercase_ppl": -1.283260530133595, "ppl/zlib": 0.0013217565767223865, "Min_5.0% Prob": 6.015740428652082, "Min_10.0% Prob": 4.214581824185555, "Min_20.0% Prob": 2.562548770852711, "Min_30.0% Prob": 1.8106873385434927, "Min_40.0% Prob": 1.3855507301895515, "Min_50.0% Prob": 1.1201459547433392, "Min_60.0% Prob": 0.9346908538858744}}
{"hexsha": "76795363af213f8e4b2960b268e373b6e81cb00a", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn xed_decoded_inst_set_mode(\n    mut p: *mut xed_decoded_inst_t,\n    mut mmode: xed_machine_mode_enum_t,\n    mut stack_addr_width: xed_address_width_enum_t,\n) {\n    let mut dstate: xed_state_t = xed_state_t {\n        mmode: XED_MACHINE_MODE_INVALID,\n        stack_addr_width: XED_ADDRESS_WIDTH_INVALID,\n    };\n    dstate.mmode = mmode;\n    dstate.stack_addr_width = stack_addr_width;\n    xed_operand_values_set_mode(p, &mut dstate);\n}", "item_id": 27, "repo": "khuey/xed-sys", "file": "src/xed-c2rust.rs", "last_update_at": "2019-11-22T22:35:46+00:00", "question_id": "76795363af213f8e4b2960b268e373b6e81cb00a_27", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn xed_decoded_inst_set_mode(\n    mut p: *mut xed_decoded_inst_t,\n    mut mmode: xed_machine_mode_enum_t,\n    mut stack_addr_width: xed_address_width_enum_t,\n) {\n    let mut dstate: xed_state_t = xed_state_t {\n        mmode: XED_MACHINE_MODE_INVALID,\n        stack_addr_width: XED_ADDRESS_WIDTH_INVALID,\n    };\n    dstate.mmode = mmode;\n    dstate.stack_addr_width = stack_addr_width;\n    xed_operand_values_set_mode(p, &mut dstate);\n"]], "pred": {"ppl": 1.6220506429672241, "ppl_lower": 1.7496610879898071, "ppl/lowercase_ppl": -1.156568758967643, "ppl/zlib": 0.0020238124592064245, "Min_5.0% Prob": 5.583752155303955, "Min_10.0% Prob": 3.9249112672275968, "Min_20.0% Prob": 2.291718046407442, "Min_30.0% Prob": 1.5845668848071779, "Min_40.0% Prob": 1.216789130020786, "Min_50.0% Prob": 0.9713341642211202, "Min_60.0% Prob": 0.8072290838400866}}
{"hexsha": "ffd517b59b213f7b78c006298fc3e011b14b4049", "ext": "rs", "lang": "Rust", "content": "fn read_i16bit_wav_file_test() { // Test based on Hound's tests\n        let wav_handler = WavHandler::new(\"testsamples/pcmwaveformat-16bit-44100Hz-mono.wav\").unwrap();\n        let file_data = vec![2i16, -3i16, 5i16, -7i16];\n        let file_data_f32_conversion: Vec<f32> = file_data.iter()\n                                                          .map(|x| (*x as f32) * (1f32 / (i16::MAX as f32 + 1f32)))\n                                                          .collect();\n\n        assert_eq!(file_data_f32_conversion, wav_handler.audio_data);\n    }", "item_id": 2, "repo": "fogodev/dictawav-rs", "file": "src/dictawav/wav_handler.rs", "last_update_at": "2019-04-21T19:44:32+00:00", "question_id": "ffd517b59b213f7b78c006298fc3e011b14b4049_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_i16bit_wav_file_test() { // Test based on Hound's tests\n        let wav_handler = WavHandler::new(\"testsamples/pcmwaveformat-16bit-44100Hz-mono.wav\").unwrap();\n        let file_data = vec![2i16, -3i16, 5i16, -7i16];\n        let file_data_f32_conversion: Vec<f32> = file_data.iter()\n                                                          .map(|x| (*x as f32) * (1f32 / (i16::MAX as f32 + 1f32)))\n                                                          .collect();\n        assert_eq!(file_data_f32_conversion, wav_handler.audio_data);\n"]], "pred": {"ppl": 3.066575527191162, "ppl_lower": 3.5159056186676025, "ppl/lowercase_ppl": -1.1220242383060355, "ppl/zlib": 0.003945638998419256, "Min_5.0% Prob": 8.256370401382446, "Min_10.0% Prob": 6.404790186882019, "Min_20.0% Prob": 4.512842130661011, "Min_30.0% Prob": 3.4054894584124207, "Min_40.0% Prob": 2.7168189301902865, "Min_50.0% Prob": 2.2115653250731673, "Min_60.0% Prob": 1.8668304729412815}}
{"hexsha": "2eaf2c14dfb2018537ae64b44361084e80ffd3ca", "ext": "rs", "lang": "Rust", "content": "fn rpc_find_where_spent(client: &mut Client, outpoint: &OutPoint) -> Result<Transaction, jsonrpc::Error> {\n    let request = client\n        .build_request(\"getbestblockhash\".to_string(), vec![]);\n\n    let mut block_hash = String::from(\"\");\n\n    client.send_request(&request).and_then(|res| {\n        block_hash = String::from(res.result.unwrap().string().unwrap());\n\n        Ok(())\n    });\n\n    let mut tx: Option<Transaction> = None;\n\n    while tx.is_none() {\n        let request = client\n            .build_request(\"getblock\".to_string(), vec![Json::from_serialize(block_hash.to_string()).unwrap(), Json::from_serialize(0).unwrap()]);\n\n        client.send_request(&request).and_then(|res| {\n            let block: Result<Block, bitcoin::network::serialize::Error> = bitcoin::network::serialize::deserialize(&mut hex_to_bytes(String::from(res.result.unwrap().string().unwrap())));\n            let block = block.unwrap();\n\n            for this_tx in &block.txdata {\n                for vin in &this_tx.input {\n                    if vin.previous_output == *outpoint {\n                        tx = Some(this_tx.clone());\n\n                        break;\n                    }\n                }\n\n                if tx.is_some() {\n                    break;\n                }\n            }\n\n            block_hash = block.header.prev_blockhash.to_string();\n\n            Ok(())\n        });\n    }\n\n    Ok(tx.unwrap())\n}", "item_id": 0, "repo": "afilini/kaleidoscope", "file": "src/chain/indexer.rs", "last_update_at": "2019-05-02T12:18:09+00:00", "question_id": "2eaf2c14dfb2018537ae64b44361084e80ffd3ca_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn rpc_find_where_spent(client: &mut Client, outpoint: &OutPoint) -> Result<Transaction, jsonrpc::Error> {\n    let request = client\n        .build_request(\"getbestblockhash\".to_string(), vec![]);\n    let mut block_hash = String::from(\"\");\n    client.send_request(&request).and_then(|res| {\n        block_hash = String::from(res.result.unwrap().string().unwrap());\n        Ok(())\n    });\n    let mut tx: Option<Transaction> = None;\n    while tx.is_none() {\n        let request = client\n            .build_request(\"getblock\".to_string(), vec![Json::from_serialize(block_hash.to_string()).unwrap(), Json::from_serialize(0).unwrap()]);\n        client.send_request(&request).and_then(|res| {\n            let block: Result<Block, bitcoin::network::serialize::Error> = bitcoin::network::serialize::deserialize(&mut hex_to_bytes(String::from(res.result.unwrap().string().unwrap())));\n            let block = block.unwrap();\n            for this_tx in &block.txdata {\n                for vin in &this_tx.input {\n                    if vin.previous_output == *outpoint {\n                        tx = Some(this_tx.clone());\n                        break;\n                    }\n                }\n                if tx.is_some() {\n                    break;\n                }\n            }\n            block_hash = block.header.prev_blockhash.to_string();\n            Ok(())\n        });\n    }\n    Ok(tx.unwrap())\n"]], "pred": {"ppl": 1.884240984916687, "ppl_lower": 2.0448031425476074, "ppl/lowercase_ppl": -1.1290816187597388, "ppl/zlib": 0.0012277617815674542, "Min_5.0% Prob": 6.152886819839478, "Min_10.0% Prob": 4.436788221684898, "Min_20.0% Prob": 2.8274805836561248, "Min_30.0% Prob": 2.039150405220869, "Min_40.0% Prob": 1.5632444167679007, "Min_50.0% Prob": 1.2634496130049229, "Min_60.0% Prob": 1.0573192713329727}}
{"hexsha": "1b03fdfd09f7603796726fd649568fd14e7f04af", "ext": "rs", "lang": "Rust", "content": "fn openssl_bench(b: &mut Bencher) {\n    use openssl::hash::{Hasher, MessageDigest};\n\n    // Make buffer big enough to not fit in cache.\n    let buf = vec![0; 1024 * 1024 * 16];\n\n    b.iter(|| {\n        let mut h = Hasher::new(MessageDigest::sha1()).unwrap();\n        h.write_all(&buf).unwrap();\n        h.finish().unwrap();\n    })\n}", "item_id": 1, "repo": "d3zd3z/rsure", "file": "benches/hash.rs", "last_update_at": "2019-12-18T20:30:15+00:00", "question_id": "1b03fdfd09f7603796726fd649568fd14e7f04af_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn openssl_bench(b: &mut Bencher) {\n    use openssl::hash::{Hasher, MessageDigest};\n    // Make buffer big enough to not fit in cache.\n    let buf = vec![0; 1024 * 1024 * 16];\n    b.iter(|| {\n        let mut h = Hasher::new(MessageDigest::sha1()).unwrap();\n        h.write_all(&buf).unwrap();\n        h.finish().unwrap();\n    })\n"]], "pred": {"ppl": 2.093735933303833, "ppl_lower": 2.861974000930786, "ppl/lowercase_ppl": -1.4229807152030423, "ppl/zlib": 0.0034052995306295894, "Min_5.0% Prob": 7.238604545593262, "Min_10.0% Prob": 5.0635096828142805, "Min_20.0% Prob": 3.151975145339966, "Min_30.0% Prob": 2.3381589626943744, "Min_40.0% Prob": 1.8053031051158905, "Min_50.0% Prob": 1.4769293336618332, "Min_60.0% Prob": 1.2291360368579627}}
{"hexsha": "b475cda86e32301d7feb341ce14e8004c9914740", "ext": "rs", "lang": "Rust", "content": "fn init_logger(matches: &ArgMatches) {\n    let pkg_name = str::replace(env!(\"CARGO_PKG_NAME\"), \"-\", \"_\");\n    let prog_name = str::replace(progname().as_str(), \"-\", \"_\");\n    let log_lv = if matches.is_present(\"quiet\") {\n        \"off\".to_owned()\n    } else {\n        match matches.occurrences_of(\"verbose\") {\n            0 => \"error\".to_owned(),\n            1 => format!(\"error,{}=warn,{}=warn\", pkg_name, prog_name),\n            2 => format!(\"error,{}=info,{}=info\", pkg_name, prog_name),\n            3 => format!(\"error,{}=debug,{}=debug\", pkg_name, prog_name),\n            4 => format!(\"error,{}=trace,{}=trace\", pkg_name, prog_name),\n            5 => format!(\"warn,{}=trace,{}=trace\", pkg_name, prog_name),\n            6 => format!(\"info,{}=trace,{}=trace\", pkg_name, prog_name),\n            7 => format!(\"debug,{}=trace,{}=trace\", pkg_name, prog_name),\n            _ => \"trace\".to_owned(),\n        }\n    };\n    env::set_var(LOG_LEVEL_ENV, log_lv.as_str());\n    pretty_env_logger::try_init_timed_custom_env(LOG_LEVEL_ENV).unwrap();\n}", "item_id": 0, "repo": "yangby-cryptape/cita-bench", "file": "src/config.rs", "last_update_at": "2019-03-15T02:17:45+00:00", "question_id": "b475cda86e32301d7feb341ce14e8004c9914740_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn init_logger(matches: &ArgMatches) {\n    let pkg_name = str::replace(env!(\"CARGO_PKG_NAME\"), \"-\", \"_\");\n    let prog_name = str::replace(progname().as_str(), \"-\", \"_\");\n    let log_lv = if matches.is_present(\"quiet\") {\n        \"off\".to_owned()\n    } else {\n        match matches.occurrences_of(\"verbose\") {\n            0 => \"error\".to_owned(),\n            1 => format!(\"error,{}=warn,{}=warn\", pkg_name, prog_name),\n            2 => format!(\"error,{}=info,{}=info\", pkg_name, prog_name),\n            3 => format!(\"error,{}=debug,{}=debug\", pkg_name, prog_name),\n            4 => format!(\"error,{}=trace,{}=trace\", pkg_name, prog_name),\n            5 => format!(\"warn,{}=trace,{}=trace\", pkg_name, prog_name),\n            6 => format!(\"info,{}=trace,{}=trace\", pkg_name, prog_name),\n            7 => format!(\"debug,{}=trace,{}=trace\", pkg_name, prog_name),\n            _ => \"trace\".to_owned(),\n        }\n    };\n    env::set_var(LOG_LEVEL_ENV, log_lv.as_str());\n    pretty_env_logger::try_init_timed_custom_env(LOG_LEVEL_ENV).unwrap();\n"]], "pred": {"ppl": 1.610263705253601, "ppl_lower": 1.8043345212936401, "ppl/lowercase_ppl": -1.2388630724401932, "ppl/zlib": 0.001260312057319828, "Min_5.0% Prob": 5.784912837876214, "Min_10.0% Prob": 3.9025466119920886, "Min_20.0% Prob": 2.2695239679018657, "Min_30.0% Prob": 1.5746757862424212, "Min_40.0% Prob": 1.187106150748829, "Min_50.0% Prob": 0.9546078897484722, "Min_60.0% Prob": 0.7938363409580456}}
{"hexsha": "e9ed937129783e1d58168f053869e06652922c05", "ext": "rs", "lang": "Rust", "content": "pub fn init_send_tx<T: ?Sized, C, K>(\n\tw: &mut T,\n\targs: InitTxArgs,\n\tuse_test_rng: bool,\n) -> Result<Slate, Error>\nwhere\n\tT: WalletBackend<C, K>,\n\tC: NodeClient,\n\tK: Keychain,\n{\n\tlet parent_key_id = match args.src_acct_name {\n\t\tSome(d) => {\n\t\t\tlet pm = w.get_acct_path(d)?;\n\t\t\tmatch pm {\n\t\t\t\tSome(p) => p.path,\n\t\t\t\tNone => w.parent_key_id(),\n\t\t\t}\n\t\t}\n\t\tNone => w.parent_key_id(),\n\t};\n\n\tlet message = match args.message {\n\t\tSome(mut m) => {\n\t\t\tm.truncate(USER_MESSAGE_MAX_LEN);\n\t\t\tSome(m)\n\t\t}\n\t\tNone => None,\n\t};\n\n\tlet mut slate = tx::new_tx_slate(&mut *w, args.amount, 2, use_test_rng)?;\n\n\t// if we just want to estimate, don't save a context, just send the results\n\t// back\n\tif let Some(true) = args.estimate_only {\n\t\tlet (total, fee) = tx::estimate_send_tx(\n\t\t\t&mut *w,\n\t\t\targs.amount,\n\t\t\targs.minimum_confirmations,\n\t\t\targs.max_outputs as usize,\n\t\t\targs.num_change_outputs as usize,\n\t\t\targs.selection_strategy,\n\t\t\t&parent_key_id,\n\t\t)?;\n\t\tslate.amount = total;\n\t\tslate.fee = fee;\n\t\treturn Ok(slate);\n\t}\n\n\tlet context = tx::add_inputs_to_slate(\n\t\t&mut *w,\n\t\t&mut slate,\n\t\targs.minimum_confirmations,\n\t\targs.max_outputs as usize,\n\t\targs.num_change_outputs as usize,\n\t\targs.selection_strategy,\n\t\t&parent_key_id,\n\t\t0,\n\t\tmessage,\n\t\ttrue,\n\t\tuse_test_rng,\n\t)?;\n\n\t// Save the aggsig context in our DB for when we\n\t// receive the transaction back\n\t{\n\t\tlet mut batch = w.batch()?;\n\t\tbatch.save_private_context(slate.id.as_bytes(), 0, &context)?;\n\t\tbatch.commit()?;\n\t}\n\tif let Some(v) = args.target_slate_version {\n\t\tslate.version_info.orig_version = v;\n\t}\n\tOk(slate)\n}", "item_id": 4, "repo": "terryzhao/grin-wallet", "file": "libwallet/src/api_impl/owner.rs", "last_update_at": "2019-09-03T15:28:57+00:00", "question_id": "e9ed937129783e1d58168f053869e06652922c05_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn init_send_tx<T: ?Sized, C, K>(\n\tw: &mut T,\n\targs: InitTxArgs,\n\tuse_test_rng: bool,\n) -> Result<Slate, Error>\nwhere\n\tT: WalletBackend<C, K>,\n\tC: NodeClient,\n\tK: Keychain,\n{\n\tlet parent_key_id = match args.src_acct_name {\n\t\tSome(d) => {\n\t\t\tlet pm = w.get_acct_path(d)?;\n\t\t\tmatch pm {\n\t\t\t\tSome(p) => p.path,\n\t\t\t\tNone => w.parent_key_id(),\n\t\t\t}\n\t\t}\n\t\tNone => w.parent_key_id(),\n\t};\n\tlet message = match args.message {\n\t\tSome(mut m) => {\n\t\t\tm.truncate(USER_MESSAGE_MAX_LEN);\n\t\t\tSome(m)\n\t\t}\n\t\tNone => None,\n\t};\n\tlet mut slate = tx::new_tx_slate(&mut *w, args.amount, 2, use_test_rng)?;\n\t// if we just want to estimate, don't save a context, just send the results\n\t// back\n\tif let Some(true) = args.estimate_only {\n\t\tlet (total, fee) = tx::estimate_send_tx(\n\t\t\t&mut *w,\n\t\t\targs.amount,\n\t\t\targs.minimum_confirmations,\n\t\t\targs.max_outputs as usize,\n\t\t\targs.num_change_outputs as usize,\n\t\t\targs.selection_strategy,\n\t\t\t&parent_key_id,\n\t\t)?;\n\t\tslate.amount = total;\n\t\tslate.fee = fee;\n\t\treturn Ok(slate);\n\t}\n\tlet context = tx::add_inputs_to_slate(\n\t\t&mut *w,\n\t\t&mut slate,\n\t\targs.minimum_confirmations,\n\t\targs.max_outputs as usize,\n\t\targs.num_change_outputs as usize,\n\t\targs.selection_strategy,\n\t\t&parent_key_id,\n\t\t0,\n\t\tmessage,\n\t\ttrue,\n\t\tuse_test_rng,\n\t)?;\n\t// Save the aggsig context in our DB for when we\n\t// receive the transaction back\n\t{\n\t\tlet mut batch = w.batch()?;\n\t\tbatch.save_private_context(slate.id.as_bytes(), 0, &context)?;\n\t\tbatch.commit()?;\n\t}\n\tif let Some(v) = args.target_slate_version {\n\t\tslate.version_info.orig_version = v;\n\t}\n\tOk(slate)\n"]], "pred": {"ppl": 1.4264439344406128, "ppl_lower": 1.7041724920272827, "ppl/lowercase_ppl": -1.5008524271104744, "ppl/zlib": 0.0004885620192823811, "Min_5.0% Prob": 4.482530951499939, "Min_10.0% Prob": 2.912122067477968, "Min_20.0% Prob": 1.6999436544461384, "Min_30.0% Prob": 1.172393228513775, "Min_40.0% Prob": 0.8868303970116863, "Min_50.0% Prob": 0.710917269738598, "Min_60.0% Prob": 0.5927121255412607}}
{"hexsha": "da08379faa3c75f93b9a419410a34b98558e9ff4", "ext": "rs", "lang": "Rust", "content": "fn zero_or_more_combinator() {\n    let parser = zero_or_more(match_literal(\"ha\"));\n    assert_eq!(Ok((\"\", vec![(), (), ()])), parser.parse(\"hahaha\"));\n    assert_eq!(Ok((\"ahah\", vec![])), parser.parse(\"ahah\"));\n    assert_eq!(Ok((\"\", vec![])), parser.parse(\"\"));\n}", "item_id": 5, "repo": "U007D/parser_combinator", "file": "src/unit_tests.rs", "last_update_at": "2019-04-20T00:01:58+00:00", "question_id": "da08379faa3c75f93b9a419410a34b98558e9ff4_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn zero_or_more_combinator() {\n    let parser = zero_or_more(match_literal(\"ha\"));\n    assert_eq!(Ok((\"\", vec![(), (), ()])), parser.parse(\"hahaha\"));\n    assert_eq!(Ok((\"ahah\", vec![])), parser.parse(\"ahah\"));\n    assert_eq!(Ok((\"\", vec![])), parser.parse(\"\"));\n"]], "pred": {"ppl": 2.5249438285827637, "ppl_lower": 2.7713937759399414, "ppl/lowercase_ppl": -1.100550262898447, "ppl/zlib": 0.006711730553435063, "Min_5.0% Prob": 7.410117340087891, "Min_10.0% Prob": 5.559900403022766, "Min_20.0% Prob": 3.8809850931167604, "Min_30.0% Prob": 2.896392321586609, "Min_40.0% Prob": 2.267407726496458, "Min_50.0% Prob": 1.8383590739965439, "Min_60.0% Prob": 1.5402236141264438}}
{"hexsha": "41ccb31f1a0052a8d992fa5f0b9831a8fdbd346b", "ext": "rs", "lang": "Rust", "content": "fn update(host: &mut HostApi, state: &mut State) -> ShouldQuit {\n    state.set_host(host);\n    state.update_and_render();\n    ShouldQuit::No\n}", "item_id": 0, "repo": "scottjmaddox/rust-game-boilerplate", "file": "dev-client-lib/src/lib.rs", "last_update_at": "2019-12-12T06:04:00+00:00", "question_id": "41ccb31f1a0052a8d992fa5f0b9831a8fdbd346b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn update(host: &mut HostApi, state: &mut State) -> ShouldQuit {\n    state.set_host(host);\n    state.update_and_render();\n    ShouldQuit::No\n"]], "pred": {"ppl": 5.826118469238281, "ppl_lower": 8.305927276611328, "ppl/lowercase_ppl": -1.2012189388871044, "ppl/zlib": 0.016784295170535632, "Min_5.0% Prob": 9.979391098022461, "Min_10.0% Prob": 8.569159889221192, "Min_20.0% Prob": 6.481405925750733, "Min_30.0% Prob": 5.083866620063782, "Min_40.0% Prob": 4.113608247041702, "Min_50.0% Prob": 3.4125602900981904, "Min_60.0% Prob": 2.9083073367675145}}
{"hexsha": "8651fa15c5ba0e6ed940a1ff083ebee8c3933ded", "ext": "rs", "lang": "Rust", "content": "pub fn derive_actor( input: TokenStream ) -> TokenStream\n{\n\tlet input = parse_macro_input!( input as DeriveInput );\n\tlet name  = input.ident;\n\n\tlet ( impl_generics, ty_generics, where_clause ) = input.generics.split_for_impl();\n\n\t// The generated impl.\n\t//\n\tlet expanded = quote!\n\t{\n\t\timpl #impl_generics thespis::Actor for #name #ty_generics #where_clause\n\t\t{}\n\t};\n\n\tTokenStream::from( expanded )\n}", "item_id": 0, "repo": "thespis-rs/thespis_derive", "file": "src/lib.rs", "last_update_at": "2019-10-11T14:02:47+00:00", "question_id": "8651fa15c5ba0e6ed940a1ff083ebee8c3933ded_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn derive_actor( input: TokenStream ) -> TokenStream\n{\n\tlet input = parse_macro_input!( input as DeriveInput );\n\tlet name  = input.ident;\n\tlet ( impl_generics, ty_generics, where_clause ) = input.generics.split_for_impl();\n\t// The generated impl.\n\t//\n\tlet expanded = quote!\n\t{\n\t\timpl #impl_generics thespis::Actor for #name #ty_generics #where_clause\n\t\t{}\n\t};\n\tTokenStream::from( expanded )\n"]], "pred": {"ppl": 2.2237484455108643, "ppl_lower": 3.08404278755188, "ppl/lowercase_ppl": -1.4092209925264794, "ppl/zlib": 0.003372127683367688, "Min_5.0% Prob": 7.999691826956613, "Min_10.0% Prob": 5.818824478558132, "Min_20.0% Prob": 3.681263744831085, "Min_30.0% Prob": 2.653467010884058, "Min_40.0% Prob": 1.9932804544243896, "Min_50.0% Prob": 1.606203136467178, "Min_60.0% Prob": 1.3434395151815433}}
{"hexsha": "429e3dd3fff57432aa820a7f0c39f4fccdc9df52", "ext": "rs", "lang": "Rust", "content": "fn find_chapter(rc: &mut RenderContext, target: Target) -> Result<Option<StringMap>, RenderError> {\n    debug!(\"Get data from context\");\n\n    let chapters = rc.evaluate_absolute(\"chapters\", true).and_then(|c| {\n        serde_json::value::from_value::<Vec<StringMap>>(c.clone())\n            .map_err(|_| RenderError::new(\"Could not decode the JSON data\"))\n    })?;\n\n    let base_path = rc.evaluate_absolute(\"path\", true)?\n        .as_str()\n        .ok_or_else(|| RenderError::new(\"Type error for `path`, string expected\"))?\n        .replace(\"\\\"\", \"\");\n\n    let mut previous: Option<StringMap> = None;\n\n    debug!(\"Search for chapter\");\n\n    for item in chapters {\n        match item.get(\"path\") {\n            Some(path) if !path.is_empty() => {\n                if let Some(previous) = previous {\n                    if let Some(item) = target.find(&base_path, &path, &item, &previous)? {\n                        return Ok(Some(item));\n                    }\n                }\n\n                previous = Some(item.clone());\n            }\n            _ => continue,\n        }\n    }\n\n    Ok(None)\n}", "item_id": 0, "repo": "cxuauto/rust-book", "file": "src/renderer/html_handlebars/helpers/navigation.rs", "last_update_at": "2019-04-24T23:46:28+00:00", "question_id": "429e3dd3fff57432aa820a7f0c39f4fccdc9df52_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn find_chapter(rc: &mut RenderContext, target: Target) -> Result<Option<StringMap>, RenderError> {\n    debug!(\"Get data from context\");\n    let chapters = rc.evaluate_absolute(\"chapters\", true).and_then(|c| {\n        serde_json::value::from_value::<Vec<StringMap>>(c.clone())\n            .map_err(|_| RenderError::new(\"Could not decode the JSON data\"))\n    })?;\n    let base_path = rc.evaluate_absolute(\"path\", true)?\n        .as_str()\n        .ok_or_else(|| RenderError::new(\"Type error for `path`, string expected\"))?\n        .replace(\"\\\"\", \"\");\n    let mut previous: Option<StringMap> = None;\n    debug!(\"Search for chapter\");\n    for item in chapters {\n        match item.get(\"path\") {\n            Some(path) if !path.is_empty() => {\n                if let Some(previous) = previous {\n                    if let Some(item) = target.find(&base_path, &path, &item, &previous)? {\n                        return Ok(Some(item));\n                    }\n                }\n                previous = Some(item.clone());\n            }\n            _ => continue,\n        }\n    }\n    Ok(None)\n"]], "pred": {"ppl": 2.7676162719726562, "ppl_lower": 3.1832077503204346, "ppl/lowercase_ppl": -1.1374311258693721, "ppl/zlib": 0.002031908978199012, "Min_5.0% Prob": 7.695154219865799, "Min_10.0% Prob": 5.883355990052223, "Min_20.0% Prob": 4.171211671829224, "Min_30.0% Prob": 3.151519921022592, "Min_40.0% Prob": 2.475595189057864, "Min_50.0% Prob": 2.0158015587395686, "Min_60.0% Prob": 1.6970690675652944}}
{"hexsha": "7a5c4c6f1fb8404074bc9ef350a73b801ae2d166", "ext": "rs", "lang": "Rust", "content": "fn display(&self) -> String {\n        let mut display = String::from(\"option name \")\n            + self.option_name()\n            + \" type \"\n            + self.option_type();\n\n        if let Some(part_dis) = self.partial_display() {\n            display += \" \";\n            display += &part_dis;\n        }\n        display\n    }", "item_id": 0, "repo": "alanthinker/Pleco", "file": "pleco_engine/src/uci/options.rs", "last_update_at": "2019-02-01T04:14:47+00:00", "question_id": "7a5c4c6f1fb8404074bc9ef350a73b801ae2d166_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn display(&self) -> String {\n        let mut display = String::from(\"option name \")\n            + self.option_name()\n            + \" type \"\n            + self.option_type();\n        if let Some(part_dis) = self.partial_display() {\n            display += \" \";\n            display += &part_dis;\n        }\n        display\n"]], "pred": {"ppl": 3.753601312637329, "ppl_lower": 4.743020534515381, "ppl/lowercase_ppl": -1.1768773455878643, "ppl/zlib": 0.008266973307361664, "Min_5.0% Prob": 10.389168739318848, "Min_10.0% Prob": 8.576688706874847, "Min_20.0% Prob": 5.523734225946314, "Min_30.0% Prob": 4.040341918285076, "Min_40.0% Prob": 3.1840031376906803, "Min_50.0% Prob": 2.5988727178085935, "Min_60.0% Prob": 2.224069052447493}}
{"hexsha": "931992201a7c2a31e83fc3ca3ff95c22f30a61be", "ext": "rs", "lang": "Rust", "content": "fn perlin_generate_permutation() -> NoiseData {\n    let mut result: NoiseData = [0; 256];\n    for i in 0..256 {\n        result[i] = i;\n    }\n    permute(&mut result);\n    result\n}", "item_id": 3, "repo": "Alekssasho/GarageRay", "file": "simple/src/texture/noise_texture.rs", "last_update_at": "2019-12-19T17:44:29+00:00", "question_id": "931992201a7c2a31e83fc3ca3ff95c22f30a61be_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn perlin_generate_permutation() -> NoiseData {\n    let mut result: NoiseData = [0; 256];\n    for i in 0..256 {\n        result[i] = i;\n    }\n    permute(&mut result);\n    result\n"]], "pred": {"ppl": 2.6189067363739014, "ppl_lower": 2.814103126525879, "ppl/lowercase_ppl": -1.0746674961451796, "ppl/zlib": 0.007405822726891547, "Min_5.0% Prob": 9.329073270161947, "Min_10.0% Prob": 6.495448453085763, "Min_20.0% Prob": 4.216640566076551, "Min_30.0% Prob": 3.0218525983038402, "Min_40.0% Prob": 2.3450798275215283, "Min_50.0% Prob": 1.909780205147607, "Min_60.0% Prob": 1.6000069611306702}}
{"hexsha": "de2771d85d0cf9d825f9f0e2a9a64fd516f14db0", "ext": "rs", "lang": "Rust", "content": "fn block_results() {\n        let response =\n            endpoint::block_results::Response::from_string(&read_json_fixture(\"block_results\"))\n                .unwrap();\n        assert_eq!(response.height.value(), 1814);\n\n        let validator_updates = response.validator_updates;\n        let deliver_tx = response.txs_results.unwrap();\n        let log_json = &deliver_tx[0].log.parse_json().unwrap();\n        let log_json_value = &log_json.as_array().as_ref().unwrap()[0];\n\n        assert_eq!(log_json_value[\"msg_index\"].as_str().unwrap(), \"0\");\n        assert_eq!(log_json_value[\"success\"].as_bool().unwrap(), true);\n\n        assert_eq!(deliver_tx[0].gas_wanted.value(), 200_000);\n        assert_eq!(deliver_tx[0].gas_used.value(), 105_662);\n\n        assert_eq!(validator_updates[0].power.value(), 1_233_243);\n    }", "item_id": 4, "repo": "yihuang/tendermint-rs", "file": "rpc/tests/integration.rs", "last_update_at": "2019-11-11T10:52:30+00:00", "question_id": "de2771d85d0cf9d825f9f0e2a9a64fd516f14db0_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn block_results() {\n        let response =\n            endpoint::block_results::Response::from_string(&read_json_fixture(\"block_results\"))\n                .unwrap();\n        assert_eq!(response.height.value(), 1814);\n        let validator_updates = response.validator_updates;\n        let deliver_tx = response.txs_results.unwrap();\n        let log_json = &deliver_tx[0].log.parse_json().unwrap();\n        let log_json_value = &log_json.as_array().as_ref().unwrap()[0];\n        assert_eq!(log_json_value[\"msg_index\"].as_str().unwrap(), \"0\");\n        assert_eq!(log_json_value[\"success\"].as_bool().unwrap(), true);\n        assert_eq!(deliver_tx[0].gas_wanted.value(), 200_000);\n        assert_eq!(deliver_tx[0].gas_used.value(), 105_662);\n        assert_eq!(validator_updates[0].power.value(), 1_233_243);\n"]], "pred": {"ppl": 2.442352294921875, "ppl_lower": 2.5235066413879395, "ppl/lowercase_ppl": -1.036606083965182, "ppl/zlib": 0.002665557105068966, "Min_5.0% Prob": 6.729911940438407, "Min_10.0% Prob": 5.007465652057102, "Min_20.0% Prob": 3.5524959840944836, "Min_30.0% Prob": 2.735536513584001, "Min_40.0% Prob": 2.173587911629251, "Min_50.0% Prob": 1.765341966974397, "Min_60.0% Prob": 1.4854595384301519}}
{"hexsha": "9bdad3ccd5e54814c4f1d59bdbd7e9c6bf5f107a", "ext": "rs", "lang": "Rust", "content": "pub fn add_chunks(header: String, chunks: &[&[u8]]) -> Vec<u8> {\n    let headlen = header.len();\n    let rawlen = chunks.iter().fold(1, |sum, c| sum + c.len());\n    let mut buf = Vec::with_capacity(5 + headlen + rawlen);\n    buf.write_all(&[1]).unwrap(); // version\n    buf.write_u32::<LittleEndian>(headlen as u32).unwrap();\n    buf.write_all(header.as_bytes()).unwrap();\n    buf.write_u8(chunks.len() as u8).unwrap();\n    for chunk in chunks {\n        buf.write_u32::<LittleEndian>(chunk.len() as u32).unwrap();\n        buf.write_all(chunk).unwrap();\n    }\n    buf\n}", "item_id": 3, "repo": "passcod/trebuchet", "file": "src/message.rs", "last_update_at": "2019-10-08T03:54:41+00:00", "question_id": "9bdad3ccd5e54814c4f1d59bdbd7e9c6bf5f107a_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn add_chunks(header: String, chunks: &[&[u8]]) -> Vec<u8> {\n    let headlen = header.len();\n    let rawlen = chunks.iter().fold(1, |sum, c| sum + c.len());\n    let mut buf = Vec::with_capacity(5 + headlen + rawlen);\n    buf.write_all(&[1]).unwrap(); // version\n    buf.write_u32::<LittleEndian>(headlen as u32).unwrap();\n    buf.write_all(header.as_bytes()).unwrap();\n    buf.write_u8(chunks.len() as u8).unwrap();\n    for chunk in chunks {\n        buf.write_u32::<LittleEndian>(chunk.len() as u32).unwrap();\n        buf.write_all(chunk).unwrap();\n    }\n    buf\n"]], "pred": {"ppl": 1.9570720195770264, "ppl_lower": 2.4323747158050537, "ppl/lowercase_ppl": -1.3238047602305907, "ppl/zlib": 0.0024416345045346613, "Min_5.0% Prob": 7.644282245635987, "Min_10.0% Prob": 5.308292763573783, "Min_20.0% Prob": 3.155283450387245, "Min_30.0% Prob": 2.203322231536731, "Min_40.0% Prob": 1.6693771230273469, "Min_50.0% Prob": 1.3388377866293821, "Min_60.0% Prob": 1.1229907834591966}}
{"hexsha": "03e02fe4f4effa796beac6e1a84112d19c5bf2eb", "ext": "rs", "lang": "Rust", "content": "fn cg() -> Result<(), io::Error> {\n    let pids: &Path = Path::new(\"/sys/fs/cgroup/pids\");\n    match fs::create_dir(pids.join(\"myuser\")) {\n        _ => (),\n    };\n\n    fs::write(pids.join(\"myuser/pids.max\"), b\"20\").unwrap();\n    fs::write(pids.join(\"myuser/notify_on_release\"), b\"1\").unwrap();\n    fs::write(\n        pids.join(\"myuser/cgroup.procs\"),\n        format!(\"{}\", nix::unistd::getpid().as_raw()),\n    )\n    .unwrap();\n\n    Ok(())\n}", "item_id": 3, "repo": "hails/containers-from-scratch-rs", "file": "src/main.rs", "last_update_at": "2019-04-17T14:21:46+00:00", "question_id": "03e02fe4f4effa796beac6e1a84112d19c5bf2eb_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn cg() -> Result<(), io::Error> {\n    let pids: &Path = Path::new(\"/sys/fs/cgroup/pids\");\n    match fs::create_dir(pids.join(\"myuser\")) {\n        _ => (),\n    };\n    fs::write(pids.join(\"myuser/pids.max\"), b\"20\").unwrap();\n    fs::write(pids.join(\"myuser/notify_on_release\"), b\"1\").unwrap();\n    fs::write(\n        pids.join(\"myuser/cgroup.procs\"),\n        format!(\"{}\", nix::unistd::getpid().as_raw()),\n    )\n    .unwrap();\n    Ok(())\n"]], "pred": {"ppl": 2.0481748580932617, "ppl_lower": 2.323629379272461, "ppl/lowercase_ppl": -1.1759975294841885, "ppl/zlib": 0.0028337908437191827, "Min_5.0% Prob": 5.871497213840485, "Min_10.0% Prob": 4.763961104785695, "Min_20.0% Prob": 3.2676186351215137, "Min_30.0% Prob": 2.341265822832401, "Min_40.0% Prob": 1.7962171489885752, "Min_50.0% Prob": 1.4305980459348053, "Min_60.0% Prob": 1.19841298324844}}
{"hexsha": "4a7a44286a7c80c34cdd0cba4d7e276771cca4ee", "ext": "rs", "lang": "Rust", "content": "pub fn read_pixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, pixel_type: GLenum) -> Vec<u8> {\n    let colors = match format {\n        RGB => 3,\n        RGBA => 3,\n        _ => panic!(\"unsupported format for read_pixels\"),\n    };\n    let depth = match pixel_type {\n        UNSIGNED_BYTE => 1,\n        _ => panic!(\"unsupported pixel_type for read_pixels\"),\n    };\n\n    let len = (width * height * colors * depth) as uint;\n    let mut pixels: Vec<u8> = Vec::new();\n    pixels.reserve(len);\n\n    unsafe {\n        // We don't want any alignment padding on pixel rows.\n        glPixelStorei(PACK_ALIGNMENT, 1);\n        glReadPixels(x, y, width, height, format, pixel_type, pixels.as_mut_ptr() as *mut c_void);\n        pixels.set_len(len);\n    }\n\n    pixels\n}", "item_id": 0, "repo": "robn/rust-opengles", "file": "src/gl2.rs", "last_update_at": "2019-05-14T00:48:43+00:00", "question_id": "4a7a44286a7c80c34cdd0cba4d7e276771cca4ee_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn read_pixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, pixel_type: GLenum) -> Vec<u8> {\n    let colors = match format {\n        RGB => 3,\n        RGBA => 3,\n        _ => panic!(\"unsupported format for read_pixels\"),\n    };\n    let depth = match pixel_type {\n        UNSIGNED_BYTE => 1,\n        _ => panic!(\"unsupported pixel_type for read_pixels\"),\n    };\n    let len = (width * height * colors * depth) as uint;\n    let mut pixels: Vec<u8> = Vec::new();\n    pixels.reserve(len);\n    unsafe {\n        // We don't want any alignment padding on pixel rows.\n        glPixelStorei(PACK_ALIGNMENT, 1);\n        glReadPixels(x, y, width, height, format, pixel_type, pixels.as_mut_ptr() as *mut c_void);\n        pixels.set_len(len);\n    }\n    pixels\n"]], "pred": {"ppl": 1.8871409893035889, "ppl_lower": 2.236020088195801, "ppl/lowercase_ppl": -1.2671145460417188, "ppl/zlib": 0.0016409896116471143, "Min_5.0% Prob": 6.581947289980375, "Min_10.0% Prob": 4.803501738442315, "Min_20.0% Prob": 2.9187177723104303, "Min_30.0% Prob": 2.066199140032617, "Min_40.0% Prob": 1.5694155637513507, "Min_50.0% Prob": 1.2690222903569466, "Min_60.0% Prob": 1.0565565857246066}}
{"hexsha": "b966e8b98bd995dd5d1a2e68088c7ca3c17c9057", "ext": "rs", "lang": "Rust", "content": "fn bool_succeeds() {\n    // word format\n    assert_eq!(fm::<bool>(quote!(ignore)), true);\n\n    // bool literal\n    assert_eq!(fm::<bool>(quote!(ignore = true)), true);\n    assert_eq!(fm::<bool>(quote!(ignore = false)), false);\n\n    // string literals\n    assert_eq!(fm::<bool>(quote!(ignore = \"true\")), true);\n    assert_eq!(fm::<bool>(quote!(ignore = \"false\")), false);\n  }", "item_id": 0, "repo": "YoloDev/evitable", "file": "syn-meta-ext/src/from_meta.rs", "last_update_at": "2019-08-27T15:40:16+00:00", "question_id": "b966e8b98bd995dd5d1a2e68088c7ca3c17c9057_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bool_succeeds() {\n    // word format\n    assert_eq!(fm::<bool>(quote!(ignore)), true);\n    // bool literal\n    assert_eq!(fm::<bool>(quote!(ignore = true)), true);\n    assert_eq!(fm::<bool>(quote!(ignore = false)), false);\n    // string literals\n    assert_eq!(fm::<bool>(quote!(ignore = \"true\")), true);\n    assert_eq!(fm::<bool>(quote!(ignore = \"false\")), false);\n"]], "pred": {"ppl": 2.8147993087768555, "ppl_lower": 2.8147993087768555, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.007137179072709084, "Min_5.0% Prob": 9.736608823140463, "Min_10.0% Prob": 7.544556339581807, "Min_20.0% Prob": 4.877456889152527, "Min_30.0% Prob": 3.389524741392387, "Min_40.0% Prob": 2.6127724449336527, "Min_50.0% Prob": 2.0819652571032443, "Min_60.0% Prob": 1.7281455881035839}}
{"hexsha": "63ee7d95bc3e38ce182365b2cf49a9c3256cb4d0", "ext": "rs", "lang": "Rust", "content": "pub fn create_rkf_stepper_subcommand(_parent_command_name: &'static str) -> Command<'static> {\n    let command_name = \"rkf_stepper\";\n\n    update_command_graph!(_parent_command_name, command_name);\n\n    Command::new(command_name)\n        .about(\"Use a Runge-Kutta-Fehlberg stepper\")\n        .long_about(\n            \"Use a Runge-Kutta-Fehlberg stepper.\\n\\\n             The next position is computed with a Runge-Kutta scheme, and tbe resulting error\\n\\\n             is estimated using an embedded lower-order step. The errors are used to adjust\\n\\\n             the step length, and steps are re-attempted until the error is below a certain\\n\\\n             tolerance.\",\n        )\n        .arg(\n            Arg::new(\"dense-step-length\")\n                .long(\"dense-step-length\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Step length to use for dense (uniform) output positions [Mm]\\n\")\n                .takes_value(true)\n                .default_value(\"0.01\"),\n        )\n        .arg(\n            Arg::new(\"max-step-attempts\")\n                .long(\"max-step-attempts\")\n                .require_equals(true)\n                .value_name(\"NUMBER\")\n                .help(\"Maximum number of step attempts before terminating\")\n                .takes_value(true)\n                .default_value(\"16\"),\n        )\n        .arg(\n            Arg::new(\"absolute-tolerance\")\n                .long(\"absolute-tolerance\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Absolute error tolerance for stepping\")\n                .takes_value(true)\n                .default_value(\"1e-6\"),\n        )\n        .arg(\n            Arg::new(\"relative-tolerance\")\n                .long(\"relative-tolerance\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Relative error tolerance for stepping\")\n                .takes_value(true)\n                .default_value(\"1e-6\"),\n        )\n        .arg(\n            Arg::new(\"safety-factor\")\n                .long(\"safety-factor\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Scaling factor for the error to reduce step length oscillations\\n\")\n                .takes_value(true)\n                .default_value(\"0.9\"),\n        )\n        .arg(\n            Arg::new(\"min-step-scale\")\n                .long(\"min-step-scale\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Smallest allowed scaling of the step size in one step\")\n                .takes_value(true)\n                .default_value(\"0.2\"),\n        )\n        .arg(\n            Arg::new(\"max-step-scale\")\n                .long(\"max-step-scale\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Largest allowed scaling of the step size in one step\")\n                .takes_value(true)\n                .default_value(\"10.0\"),\n        )\n        .arg(\n            Arg::new(\"initial-error\")\n                .long(\"initial-error\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Start value for stepping error\")\n                .takes_value(true)\n                .default_value(\"1e-4\"),\n        )\n        .arg(\n            Arg::new(\"initial-step-length\")\n                .long(\"initial-step-length\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Initial step size\")\n                .takes_value(true)\n                .default_value(\"1e-4\"),\n        )\n        .arg(\n            Arg::new(\"sudden-reversals-for-sink\")\n                .long(\"sudden-reversals-for-sink\")\n                .require_equals(true)\n                .value_name(\"NUMBER\")\n                .help(\n                    \"Number of sudden direction reversals before the area is considered\\n\\\n                     a sink\",\n                )\n                .takes_value(true)\n                .default_value(\"3\"),\n        )\n        .arg(\n            Arg::new(\"disable-pi-control\")\n                .long(\"disable-pi-control\")\n                .help(\n                    \"Disable Proportional Integral (PI) control used for stabilizing the stepping\",\n                ),\n        )\n        .arg(\n            Arg::new(\"stepping-scheme\")\n                .long(\"stepping-scheme\")\n                .require_equals(true)\n                .value_name(\"NAME\")\n                .help(\"Which Runge-Kutta-Fehlberg stepping scheme to use\\n\")\n                .takes_value(true)\n                .possible_values(&[\"rkf23\", \"rkf45\"])\n                .default_value(\"rkf45\"),\n        )\n}", "item_id": 0, "repo": "lars-frogner/bifrost-rust", "file": "src/cli/tracing/stepping/rkf.rs", "last_update_at": "2019-10-24T07:24:05+00:00", "question_id": "63ee7d95bc3e38ce182365b2cf49a9c3256cb4d0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn create_rkf_stepper_subcommand(_parent_command_name: &'static str) -> Command<'static> {\n    let command_name = \"rkf_stepper\";\n    update_command_graph!(_parent_command_name, command_name);\n    Command::new(command_name)\n        .about(\"Use a Runge-Kutta-Fehlberg stepper\")\n        .long_about(\n            \"Use a Runge-Kutta-Fehlberg stepper.\\n\\\n             The next position is computed with a Runge-Kutta scheme, and tbe resulting error\\n\\\n             is estimated using an embedded lower-order step. The errors are used to adjust\\n\\\n             the step length, and steps are re-attempted until the error is below a certain\\n\\\n             tolerance.\",\n        )\n        .arg(\n            Arg::new(\"dense-step-length\")\n                .long(\"dense-step-length\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Step length to use for dense (uniform) output positions [Mm]\\n\")\n                .takes_value(true)\n                .default_value(\"0.01\"),\n        )\n        .arg(\n            Arg::new(\"max-step-attempts\")\n                .long(\"max-step-attempts\")\n                .require_equals(true)\n                .value_name(\"NUMBER\")\n                .help(\"Maximum number of step attempts before terminating\")\n                .takes_value(true)\n                .default_value(\"16\"),\n        )\n        .arg(\n            Arg::new(\"absolute-tolerance\")\n                .long(\"absolute-tolerance\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Absolute error tolerance for stepping\")\n                .takes_value(true)\n                .default_value(\"1e-6\"),\n        )\n        .arg(\n            Arg::new(\"relative-tolerance\")\n                .long(\"relative-tolerance\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Relative error tolerance for stepping\")\n                .takes_value(true)\n                .default_value(\"1e-6\"),\n        )\n        .arg(\n            Arg::new(\"safety-factor\")\n                .long(\"safety-factor\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Scaling factor for the error to reduce step length oscillations\\n\")\n                .takes_value(true)\n                .default_value(\"0.9\"),\n        )\n        .arg(\n            Arg::new(\"min-step-scale\")\n                .long(\"min-step-scale\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Smallest allowed scaling of the step size in one step\")\n                .takes_value(true)\n                .default_value(\"0.2\"),\n        )\n        .arg(\n            Arg::new(\"max-step-scale\")\n                .long(\"max-step-scale\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Largest allowed scaling of the step size in one step\")\n                .takes_value(true)\n                .default_value(\"10.0\"),\n        )\n        .arg(\n            Arg::new(\"initial-error\")\n                .long(\"initial-error\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Start value for stepping error\")\n                .takes_value(true)\n                .default_value(\"1e-4\"),\n        )\n        .arg(\n            Arg::new(\"initial-step-length\")\n                .long(\"initial-step-length\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Initial step size\")\n                .takes_value(true)\n                .default_value(\"1e-4\"),\n        )\n        .arg(\n            Arg::new(\"sudden-reversals-for-sink\")\n                .long(\"sudden-reversals-for-sink\")\n                .require_equals(true)\n                .value_name(\"NUMBER\")\n                .help(\n                    \"Number of sudden direction reversals before the area is considered\\n\\\n                     a sink\",\n                )\n                .takes_value(true)\n                .default_value(\"3\"),\n        )\n        .arg(\n            Arg::new(\"disable-pi-control\")\n                .long(\"disable-pi-control\")\n                .help(\n                    \"Disable Proportional Integral (PI) control used for stabilizing the stepping\",\n                ),\n        )\n        .arg(\n            Arg::new(\"stepping-scheme\")\n                .long(\"stepping-scheme\")\n                .require_equals(true)\n                .value_name(\"NAME\")\n                .help(\"Which Runge-Kutta-Fehlberg stepping scheme to use\\n\")\n                .takes_value(true)\n                .possible_values(&[\"rkf23\", \"rkf45\"])\n                .default_value(\"rkf45\"),\n        )\n"]], "pred": {"ppl": 1.746128797531128, "ppl_lower": 1.7974247932434082, "ppl/lowercase_ppl": -1.0519441778410223, "ppl/zlib": 0.000581231722520024, "Min_5.0% Prob": 6.147491272758035, "Min_10.0% Prob": 4.411389698000515, "Min_20.0% Prob": 2.7042873227128794, "Min_30.0% Prob": 1.8547102623174783, "Min_40.0% Prob": 1.3926598651751347, "Min_50.0% Prob": 1.115465621454386, "Min_60.0% Prob": 0.9301013642953189}}
{"hexsha": "de600b9a9480f426db0c274e78354a485857ba74", "ext": "rs", "lang": "Rust", "content": "fn parses_blogpost_package_oftd() {\n    let src = r#\"(authors\n  \"Nathan Ringo <remexre@gmail.com>\")\n(license \"MIT\")\n(name foo)\n(version \"0.1.0\")\n\n(components\n  (library)\n  (binary\n    (name \"foo\")\n    (path \"src/main.oft\")))\n\n(dependencies\n  (combinargs\n    (version \"^0.2.1\"))\n  (grid\n    (git \"https://github.com/remexre/oftlisp-grid.git\")\n    (version \"^0.1.0\")))\n\"#;\n    let data = PackageMetadata {\n        authors: vec![\"Nathan Ringo <remexre@gmail.com>\".to_string()],\n        components: ComponentsMetadata {\n            library: Some(LibraryComponentMetadata),\n            binaries: vec![BinaryComponentMetadata {\n                name: \"foo\".to_string(),\n                path: \"src/main.oft\".to_string(),\n            }],\n        },\n        dependencies: vec![\n            (\n                \"combinargs\".into(),\n                DependencyMetadata {\n                    git: None,\n                    version: \"0.2.1\".parse().unwrap(),\n                },\n            ),\n            (\n                \"grid\".into(),\n                DependencyMetadata {\n                    git: Some(\"https://github.com/remexre/oftlisp-grid.git\".to_string()),\n                    version: \"0.1.0\".parse().unwrap(),\n                },\n            ),\n        ].into_iter()\n            .collect(),\n        license: Some(\"MIT\".to_string()),\n        name: \"foo\".into(),\n        version: \"0.1.0\".parse().unwrap(),\n    };\n\n    let lits = parse_program(src).unwrap();\n    assert_eq!(data.clone().to_literals(), lits);\n    let meta = PackageMetadata::from_literals(lits).unwrap();\n    assert_eq!(meta, data);\n}", "item_id": 0, "repo": "oftlisp/oftb", "file": "src/modules/tests.rs", "last_update_at": "2019-10-14T00:32:53+00:00", "question_id": "de600b9a9480f426db0c274e78354a485857ba74_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parses_blogpost_package_oftd() {\n    let src = r#\"(authors\n  \"Nathan Ringo <remexre@gmail.com>\")\n(license \"MIT\")\n(name foo)\n(version \"0.1.0\")\n(components\n  (library)\n  (binary\n    (name \"foo\")\n    (path \"src/main.oft\")))\n(dependencies\n  (combinargs\n    (version \"^0.2.1\"))\n  (grid\n    (git \"https://github.com/remexre/oftlisp-grid.git\")\n    (version \"^0.1.0\")))\n\"#;\n    let data = PackageMetadata {\n        authors: vec![\"Nathan Ringo <remexre@gmail.com>\".to_string()],\n        components: ComponentsMetadata {\n            library: Some(LibraryComponentMetadata),\n            binaries: vec![BinaryComponentMetadata {\n                name: \"foo\".to_string(),\n                path: \"src/main.oft\".to_string(),\n            }],\n        },\n        dependencies: vec![\n            (\n                \"combinargs\".into(),\n                DependencyMetadata {\n                    git: None,\n                    version: \"0.2.1\".parse().unwrap(),\n                },\n            ),\n            (\n                \"grid\".into(),\n                DependencyMetadata {\n                    git: Some(\"https://github.com/remexre/oftlisp-grid.git\".to_string()),\n                    version: \"0.1.0\".parse().unwrap(),\n                },\n            ),\n        ].into_iter()\n            .collect(),\n        license: Some(\"MIT\".to_string()),\n        name: \"foo\".into(),\n        version: \"0.1.0\".parse().unwrap(),\n    };\n    let lits = parse_program(src).unwrap();\n    assert_eq!(data.clone().to_literals(), lits);\n    let meta = PackageMetadata::from_literals(lits).unwrap();\n    assert_eq!(meta, data);\n"]], "pred": {"ppl": 2.2995572090148926, "ppl_lower": 2.4375061988830566, "ppl/lowercase_ppl": -1.0699624354496726, "ppl/zlib": 0.0014843432915892297, "Min_5.0% Prob": 8.19787714878718, "Min_10.0% Prob": 5.886634831525842, "Min_20.0% Prob": 3.7523729367689653, "Min_30.0% Prob": 2.6980344796100177, "Min_40.0% Prob": 2.0613583074224118, "Min_50.0% Prob": 1.6645099831978802, "Min_60.0% Prob": 1.3871509189739422}}
{"hexsha": "edeef41d0f27105f1329da21b4afdf0ce9350dfd", "ext": "rs", "lang": "Rust", "content": "fn part1_summed_area(input: usize) -> String {\n    const GRID_SIZE: usize = 300;\n    const SQUARE_SIZE: usize = 3;\n\n    let grid = SummedAreaFuelCellGrid::new(GRID_SIZE, input);\n    let (_, (x, y)) = summed_area_calculate_best_square(&grid, SQUARE_SIZE);\n\n    format!(\"Square of largest total power at: {},{}\", x, y)\n}", "item_id": 3, "repo": "zoewithabang/rust-aoc-2018", "file": "src/days/day11.rs", "last_update_at": "2019-05-23T15:47:24+00:00", "question_id": "edeef41d0f27105f1329da21b4afdf0ce9350dfd_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn part1_summed_area(input: usize) -> String {\n    const GRID_SIZE: usize = 300;\n    const SQUARE_SIZE: usize = 3;\n    let grid = SummedAreaFuelCellGrid::new(GRID_SIZE, input);\n    let (_, (x, y)) = summed_area_calculate_best_square(&grid, SQUARE_SIZE);\n    format!(\"Square of largest total power at: {},{}\", x, y)\n"]], "pred": {"ppl": 3.660358428955078, "ppl_lower": 4.979352951049805, "ppl/lowercase_ppl": -1.237167163241956, "ppl/zlib": 0.005924936411081274, "Min_5.0% Prob": 8.172720273335775, "Min_10.0% Prob": 6.924572706222534, "Min_20.0% Prob": 5.054648561477661, "Min_30.0% Prob": 3.990132431726198, "Min_40.0% Prob": 3.130357803106308, "Min_50.0% Prob": 2.550979649263715, "Min_60.0% Prob": 2.165847623149554}}
{"hexsha": "d680324d013bb719f96d055ca5c2fdd33a9ebae3", "ext": "rs", "lang": "Rust", "content": "fn download(url: &str, dest_filename: &Path) -> Result<Interactions, failure::Error> {\n    let data_dir = create_data_dir()?;\n    let desired_filename = data_dir.join(dest_filename);\n\n    if !desired_filename.exists() {\n        let temp_filename = env::temp_dir().join(\n            rand::thread_rng()\n                .sample_iter(&rand::distributions::Alphanumeric)\n                .take(10)\n                .collect::<String>(),\n        );\n\n        let file = File::create(&temp_filename)?;\n        let mut writer = BufWriter::new(file);\n\n        let mut response = reqwest::get(url)?;\n        response.copy_to(&mut writer)?;\n\n        rename(temp_filename, &desired_filename)?;\n    }\n\n    let mut reader = csv::Reader::from_path(desired_filename)?;\n    let interactions: Vec<Interaction> = reader.deserialize().collect::<Result<Vec<_>, _>>()?;\n\n    Ok(Interactions::from(interactions))\n}", "item_id": 1, "repo": "timedcy/sbr-rs", "file": "src/datasets.rs", "last_update_at": "2019-03-06T06:47:15+00:00", "question_id": "d680324d013bb719f96d055ca5c2fdd33a9ebae3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn download(url: &str, dest_filename: &Path) -> Result<Interactions, failure::Error> {\n    let data_dir = create_data_dir()?;\n    let desired_filename = data_dir.join(dest_filename);\n    if !desired_filename.exists() {\n        let temp_filename = env::temp_dir().join(\n            rand::thread_rng()\n                .sample_iter(&rand::distributions::Alphanumeric)\n                .take(10)\n                .collect::<String>(),\n        );\n        let file = File::create(&temp_filename)?;\n        let mut writer = BufWriter::new(file);\n        let mut response = reqwest::get(url)?;\n        response.copy_to(&mut writer)?;\n        rename(temp_filename, &desired_filename)?;\n    }\n    let mut reader = csv::Reader::from_path(desired_filename)?;\n    let interactions: Vec<Interaction> = reader.deserialize().collect::<Result<Vec<_>, _>>()?;\n    Ok(Interactions::from(interactions))\n"]], "pred": {"ppl": 1.8488960266113281, "ppl_lower": 2.3908042907714844, "ppl/lowercase_ppl": -1.4182327242487396, "ppl/zlib": 0.0014738338575452845, "Min_5.0% Prob": 6.707194658426138, "Min_10.0% Prob": 4.5764736202028065, "Min_20.0% Prob": 2.7790014489933297, "Min_30.0% Prob": 2.00040540025558, "Min_40.0% Prob": 1.5253380500121947, "Min_50.0% Prob": 1.2306640811182339, "Min_60.0% Prob": 1.0287817191715392}}
{"hexsha": "25af6178a4375d001ecc3aa9ac91731af7e88458", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // Generate initial random population\n    println_err!(\"Generating initial population\");\n    let mut population = evolve::random_population::<Program>(POPULATION_SIZE);\n    let mut rng = rand::StdRng::new().unwrap();\n    let mut stdout = std::io::stdout();\n    let mut keeper = OptimumKeeper::<Program>::new();\n\n    loop {\n        println_err!(\"[{}] Scoring\", population.generation);\n        population.score(|p| score_program(p, &mut rng));\n        {\n            let winner = population.winner();\n            println_err!(\"[{}] Best score: {}\", population.generation, winner.score.total_score());\n            \n            if keeper.improved(&winner.program, &winner.score, population.generation) {\n                let random_score = score_single_run(&winner.program, &mut rng);\n\n                let _ = serialize::writeln(&serialize::TraceOutput {\n                    generation: population.generation,\n                    program: &winner.program.simplify(),\n                    score_card: &random_score\n                }, &mut stdout);\n            }\n        }\n\n        println_err!(\"[{}] Evolving\", population.generation);\n        population = population.evolve(TOURNAMENT_SIZE,\n                                       REPRODUCE_WEIGHT, \n                                       MUTATE_WEIGHT, \n                                       CROSSOVER_WEIGHT,\n                                       &mut rng);\n    }\n}", "item_id": 3, "repo": "darwins-challenge/moonlander-ast-rust", "file": "examples/evolve.rs", "last_update_at": "2019-03-12T10:41:50+00:00", "question_id": "25af6178a4375d001ecc3aa9ac91731af7e88458_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    // Generate initial random population\n    println_err!(\"Generating initial population\");\n    let mut population = evolve::random_population::<Program>(POPULATION_SIZE);\n    let mut rng = rand::StdRng::new().unwrap();\n    let mut stdout = std::io::stdout();\n    let mut keeper = OptimumKeeper::<Program>::new();\n    loop {\n        println_err!(\"[{}] Scoring\", population.generation);\n        population.score(|p| score_program(p, &mut rng));\n        {\n            let winner = population.winner();\n            println_err!(\"[{}] Best score: {}\", population.generation, winner.score.total_score());\n            if keeper.improved(&winner.program, &winner.score, population.generation) {\n                let random_score = score_single_run(&winner.program, &mut rng);\n                let _ = serialize::writeln(&serialize::TraceOutput {\n                    generation: population.generation,\n                    program: &winner.program.simplify(),\n                    score_card: &random_score\n                }, &mut stdout);\n            }\n        }\n        println_err!(\"[{}] Evolving\", population.generation);\n        population = population.evolve(TOURNAMENT_SIZE,\n                                       REPRODUCE_WEIGHT, \n                                       MUTATE_WEIGHT, \n                                       CROSSOVER_WEIGHT,\n                                       &mut rng);\n    }\n"]], "pred": {"ppl": 2.998042345046997, "ppl_lower": 3.6350948810577393, "ppl/lowercase_ppl": -1.175485238296602, "ppl/zlib": 0.002182822115333222, "Min_5.0% Prob": 8.23752212524414, "Min_10.0% Prob": 6.6824531941800505, "Min_20.0% Prob": 4.607600704828898, "Min_30.0% Prob": 3.391826729331396, "Min_40.0% Prob": 2.6689513677003367, "Min_50.0% Prob": 2.1787395027894823, "Min_60.0% Prob": 1.8267914983997786}}
{"hexsha": "bbcf632bd6ec044f33f555480b48984dd326426e", "ext": "rs", "lang": "Rust", "content": "fn Block(tokens: Input<InputWrapper>) -> IResult<Input<InputWrapper>, node::BlockStatement> {\n    let brackets = is_token!(tokens, Token::LCurly)?;\n    if let Ok((rest, statement)) = StatementList(brackets.0) {\n        let brackets = is_token!(rest, Token::RCurly)?;\n        return Ok((brackets.0, node::BlockStatement { body: statement }));\n    }\n    let brackets = is_token!(brackets.0, Token::RCurly)?;\n    Ok((brackets.0, node::BlockStatement { body: vec![] }))\n}", "item_id": 50, "repo": "retep007/javascript-es9-parser", "file": "components/parser/src/statement_declaration.rs", "last_update_at": "2019-05-24T15:26:18+00:00", "question_id": "bbcf632bd6ec044f33f555480b48984dd326426e_50", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn Block(tokens: Input<InputWrapper>) -> IResult<Input<InputWrapper>, node::BlockStatement> {\n    let brackets = is_token!(tokens, Token::LCurly)?;\n    if let Ok((rest, statement)) = StatementList(brackets.0) {\n        let brackets = is_token!(rest, Token::RCurly)?;\n        return Ok((brackets.0, node::BlockStatement { body: statement }));\n    }\n    let brackets = is_token!(brackets.0, Token::RCurly)?;\n    Ok((brackets.0, node::BlockStatement { body: vec![] }))\n"]], "pred": {"ppl": 2.784954309463501, "ppl_lower": 3.6839818954467773, "ppl/lowercase_ppl": -1.2731440554504394, "ppl/zlib": 0.004947978102932207, "Min_5.0% Prob": 9.1499422618321, "Min_10.0% Prob": 7.013662052154541, "Min_20.0% Prob": 4.677789119879405, "Min_30.0% Prob": 3.3301659968164232, "Min_40.0% Prob": 2.5490535321334997, "Min_50.0% Prob": 2.054317678809166, "Min_60.0% Prob": 1.716284591673563}}
{"hexsha": "b0d399e938b989f7d14a3334b8ab01f8ea791fcb", "ext": "rs", "lang": "Rust", "content": "fn find_stable_conflicting_units(\n    db: &Connection,\n    unit_prop: &graph::UnitProps,\n) -> Result<Vec<String>> {\n    // units come here sorted by original unit,\n    //so the smallest original on the same MCI comes first and will become good,\n    //all others will become final-bad\n    let mut stmt = db.prepare_cached(\n        \"SELECT competitor_units.* \\\n        FROM unit_authors AS this_unit_authors \\\n        JOIN unit_authors AS competitor_unit_authors USING(address) \\\n        JOIN units AS competitor_units ON competitor_unit_authors.unit=competitor_units.unit \\\n        JOIN units AS this_unit ON this_unit_authors.unit=this_unit.unit \\\n        WHERE this_unit_authors.unit=? AND competitor_units.is_stable=1 AND +competitor_units.sequence='good' \\\n            -- if it were main_chain_index <= this_unit_limci, the competitor would've been included \\\n            AND (competitor_units.main_chain_index > this_unit.latest_included_mc_index) \\\n            AND (competitor_units.main_chain_index <= this_unit.main_chain_index)\",\n    )?;\n    let rows = stmt.query_map(&[&unit_prop.unit], |row| graph::UnitProps {\n        unit: row.get(\"unit\"),\n        level: row.get(\"level\"),\n        latest_included_mc_index: row.get(\"latest_included_mc_index\"),\n        main_chain_index: row.get(\"main_chain_index\"),\n        is_on_main_chain: row.get(\"is_on_main_chain\"),\n        is_free: row.get(\"is_free\"),\n    })?;\n\n    let mut conflicting_units = Vec::new();\n    for row in rows {\n        let row = row?;\n        if graph::compare_unit_props(db, &row, unit_prop)? == None {\n            conflicting_units.push(row.unit);\n        }\n    }\n\n    Ok(conflicting_units)\n}", "item_id": 8, "repo": "ringringringring/rust-trustnote", "file": "src/main_chain.rs", "last_update_at": "2019-05-28T10:59:27+00:00", "question_id": "b0d399e938b989f7d14a3334b8ab01f8ea791fcb_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn find_stable_conflicting_units(\n    db: &Connection,\n    unit_prop: &graph::UnitProps,\n) -> Result<Vec<String>> {\n    // units come here sorted by original unit,\n    //so the smallest original on the same MCI comes first and will become good,\n    //all others will become final-bad\n    let mut stmt = db.prepare_cached(\n        \"SELECT competitor_units.* \\\n        FROM unit_authors AS this_unit_authors \\\n        JOIN unit_authors AS competitor_unit_authors USING(address) \\\n        JOIN units AS competitor_units ON competitor_unit_authors.unit=competitor_units.unit \\\n        JOIN units AS this_unit ON this_unit_authors.unit=this_unit.unit \\\n        WHERE this_unit_authors.unit=? AND competitor_units.is_stable=1 AND +competitor_units.sequence='good' \\\n            -- if it were main_chain_index <= this_unit_limci, the competitor would've been included \\\n            AND (competitor_units.main_chain_index > this_unit.latest_included_mc_index) \\\n            AND (competitor_units.main_chain_index <= this_unit.main_chain_index)\",\n    )?;\n    let rows = stmt.query_map(&[&unit_prop.unit], |row| graph::UnitProps {\n        unit: row.get(\"unit\"),\n        level: row.get(\"level\"),\n        latest_included_mc_index: row.get(\"latest_included_mc_index\"),\n        main_chain_index: row.get(\"main_chain_index\"),\n        is_on_main_chain: row.get(\"is_on_main_chain\"),\n        is_free: row.get(\"is_free\"),\n    })?;\n    let mut conflicting_units = Vec::new();\n    for row in rows {\n        let row = row?;\n        if graph::compare_unit_props(db, &row, unit_prop)? == None {\n            conflicting_units.push(row.unit);\n        }\n    }\n    Ok(conflicting_units)\n"]], "pred": {"ppl": 2.3758394718170166, "ppl_lower": 2.640089988708496, "ppl/lowercase_ppl": -1.1218721492679664, "ppl/zlib": 0.0013354179581039868, "Min_5.0% Prob": 8.23223497249462, "Min_10.0% Prob": 6.105604087864911, "Min_20.0% Prob": 3.967494194706281, "Min_30.0% Prob": 2.8026413968735677, "Min_40.0% Prob": 2.151648104087823, "Min_50.0% Prob": 1.7276560711975701, "Min_60.0% Prob": 1.4436183574893713}}
{"hexsha": "3833dd49822bd951353a13d4bb69e52f525e1493", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut input = format!(\"\");\n    std::io::stdin().read_line(&mut input).expect(\"\");\n    //let n_arr: usize = input.trim().parse().expect(\"\");\n    input = format!(\"\");\n    std::io::stdin().read_line(&mut input).expect(\"\");\n    let mut arr: Vec<u64> = input\n        .trim()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let mut sorted: bool = false;\n    let mut temp: u64;\n    let mut step: u64 = 0;\n    loop {\n        sorted = true;\n        for i in 0..arr.len() - 1 {\n            if arr[i] > arr[i + 1] {\n                temp = arr[i + 1];\n                arr[i + 1] = arr[i];\n                arr[i] = temp;\n                step = step + 1;\n                sorted = false;\n            }\n        }\n        if sorted == true {\n            break;\n        }\n    }\n    println!(\n        \"Array is sorted in {} swaps.\\nFirst Element: {}\\nLast Element: {}\",\n        step,\n        arr[0],\n        arr[arr.len() - 1]\n    );\n}", "item_id": 0, "repo": "andraantariksa/code-exercise-answer", "file": "hackerrank/30 Days of Code/20. Sorting.rs", "last_update_at": "2019-11-06T15:17:48+00:00", "question_id": "3833dd49822bd951353a13d4bb69e52f525e1493_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let mut input = format!(\"\");\n    std::io::stdin().read_line(&mut input).expect(\"\");\n    //let n_arr: usize = input.trim().parse().expect(\"\");\n    input = format!(\"\");\n    std::io::stdin().read_line(&mut input).expect(\"\");\n    let mut arr: Vec<u64> = input\n        .trim()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let mut sorted: bool = false;\n    let mut temp: u64;\n    let mut step: u64 = 0;\n    loop {\n        sorted = true;\n        for i in 0..arr.len() - 1 {\n            if arr[i] > arr[i + 1] {\n                temp = arr[i + 1];\n                arr[i + 1] = arr[i];\n                arr[i] = temp;\n                step = step + 1;\n                sorted = false;\n            }\n        }\n        if sorted == true {\n            break;\n        }\n    }\n    println!(\n        \"Array is sorted in {} swaps.\\nFirst Element: {}\\nLast Element: {}\",\n        step,\n        arr[0],\n        arr[arr.len() - 1]\n    );\n"]], "pred": {"ppl": 1.4883774518966675, "ppl_lower": 1.5533934831619263, "ppl/lowercase_ppl": -1.1075100771726996, "ppl/zlib": 0.0010223305093899771, "Min_5.0% Prob": 4.583093091845512, "Min_10.0% Prob": 3.2686670422554016, "Min_20.0% Prob": 1.882855098751875, "Min_30.0% Prob": 1.3083250966575957, "Min_40.0% Prob": 0.9885217699580467, "Min_50.0% Prob": 0.7959846418845341, "Min_60.0% Prob": 0.6621749328485188}}
{"hexsha": "8ad2e3b0199c65a92c5747a6718f0d5d37cd4526", "ext": "rs", "lang": "Rust", "content": "fn load_libraries(ids: &UniqueIdGenerator, lib: &Path) -> Result<im::HashMap<String, Module>> {\n    tracing::info!(\"Reading precompiled module metadata files\");\n    let mut manifests = im::HashMap::new();\n    for lib in fs::read_dir(lib)?.filter_map(Result::ok) {\n        let path = lib.path().join(\"build\");\n        if !path.is_dir() {\n            continue;\n        }\n        for module in fs::gleam_modules_metadata_paths(path)? {\n            let reader = fs::buffered_reader(module)?;\n            let module = metadata::ModuleDecoder::new(ids.clone()).read(reader)?;\n            let _ = manifests.insert(module.name.join(\"/\"), module);\n        }\n    }\n    Ok(manifests)\n}", "item_id": 1, "repo": "HarryET/gleam", "file": "compiler-cli/src/compile_package.rs", "last_update_at": "2019-10-27T15:26:35+00:00", "question_id": "8ad2e3b0199c65a92c5747a6718f0d5d37cd4526_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn load_libraries(ids: &UniqueIdGenerator, lib: &Path) -> Result<im::HashMap<String, Module>> {\n    tracing::info!(\"Reading precompiled module metadata files\");\n    let mut manifests = im::HashMap::new();\n    for lib in fs::read_dir(lib)?.filter_map(Result::ok) {\n        let path = lib.path().join(\"build\");\n        if !path.is_dir() {\n            continue;\n        }\n        for module in fs::gleam_modules_metadata_paths(path)? {\n            let reader = fs::buffered_reader(module)?;\n            let module = metadata::ModuleDecoder::new(ids.clone()).read(reader)?;\n            let _ = manifests.insert(module.name.join(\"/\"), module);\n        }\n    }\n    Ok(manifests)\n"]], "pred": {"ppl": 3.8769454956054688, "ppl_lower": 4.8115315437316895, "ppl/lowercase_ppl": -1.1593802619700113, "ppl/zlib": 0.0037226582422959223, "Min_5.0% Prob": 10.294995403289795, "Min_10.0% Prob": 8.036310076713562, "Min_20.0% Prob": 5.629791688919068, "Min_30.0% Prob": 4.179878016964334, "Min_40.0% Prob": 3.2978127701782887, "Min_50.0% Prob": 2.680419362497096, "Min_60.0% Prob": 2.2596439765613585}}
{"hexsha": "e184291a10e1f81d117c0559f7b63aedca25f8b4", "ext": "rs", "lang": "Rust", "content": "fn construct_cpu(filename: &str, classic_mode: bool, output_serial: bool, output_printer: bool) -> Option<Device> {\n    let opt_c = match classic_mode {\n        true => Device::new(filename),\n        false => Device::new_cgb(filename),\n    };\n    let mut c = match opt_c\n    {\n        Ok(cpu) => { cpu },\n        Err(message) => { warn(message); return None; },\n    };\n\n    if output_printer {\n        c.attach_printer();\n    }\n    else {\n        c.set_stdout(output_serial);\n    }\n\n    Some(c)\n}", "item_id": 2, "repo": "krocki/rboy", "file": "src/main.rs", "last_update_at": "2019-05-13T19:05:20+00:00", "question_id": "e184291a10e1f81d117c0559f7b63aedca25f8b4_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn construct_cpu(filename: &str, classic_mode: bool, output_serial: bool, output_printer: bool) -> Option<Device> {\n    let opt_c = match classic_mode {\n        true => Device::new(filename),\n        false => Device::new_cgb(filename),\n    };\n    let mut c = match opt_c\n    {\n        Ok(cpu) => { cpu },\n        Err(message) => { warn(message); return None; },\n    };\n    if output_printer {\n        c.attach_printer();\n    }\n    else {\n        c.set_stdout(output_serial);\n    }\n    Some(c)\n"]], "pred": {"ppl": 3.683764696121216, "ppl_lower": 3.888352155685425, "ppl/lowercase_ppl": -1.041451608305307, "ppl/zlib": 0.0051743462083638, "Min_5.0% Prob": 9.529468894004822, "Min_10.0% Prob": 7.399269282817841, "Min_20.0% Prob": 5.361487049609423, "Min_30.0% Prob": 3.9373461518968855, "Min_40.0% Prob": 3.146560131586515, "Min_50.0% Prob": 2.5688043291248928, "Min_60.0% Prob": 2.1709214586536496}}
{"hexsha": "78bee61259e517838765e26e9021310e19532ccc", "ext": "rs", "lang": "Rust", "content": "pub fn parse_duration(s: &str) -> Option<Duration> {\n    let mut digits = String::new();\n    let mut unit = String::new();\n    let mut reading_digits = true;\n    for c in s.chars().filter(|c| !c.is_whitespace()) {\n        if reading_digits {\n            if c.is_digit(BASE_TEN) {\n                digits.push(c);\n            } else {\n                reading_digits = false;\n                unit.push(c)\n            }\n        } else {\n            unit.push(c);\n        }\n    }\n\n    if digits.is_empty() { return None; }\n\n    let mk_duration: fn(i64) -> Duration = match &*unit {\n        \"ns\" | \"nanos\" | \"nano\" | \"nanoseconds\" | \"nanosecond\" => Duration::nanoseconds,\n        \"us\" | \"micros\" | \"micro\" | \"microseconds\" | \"microsecond\" => Duration::microseconds,\n        \"ms\" | \"millis\" | \"milli\" | \"milliseconds\" | \"millisecond\" => Duration::milliseconds,\n        \"s\" | \"secs\" | \"sec\" | \"seconds\" | \"second\" => Duration::seconds,\n        \"m\" | \"mins\" | \"min\" | \"minutes\" | \"minute\" => Duration::minutes,\n        \"h\" | \"hours\" | \"hour\" => Duration::hours,\n        \"d\" | \"days\" | \"day\" => Duration::days,\n        _ => return None\n    };\n\n    let n = digits.parse().unwrap();  // always correct\n    Some(mk_duration(n))\n}", "item_id": 0, "repo": "netvl/wcd", "file": "src/common/util.rs", "last_update_at": "2019-11-25T16:37:00+00:00", "question_id": "78bee61259e517838765e26e9021310e19532ccc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse_duration(s: &str) -> Option<Duration> {\n    let mut digits = String::new();\n    let mut unit = String::new();\n    let mut reading_digits = true;\n    for c in s.chars().filter(|c| !c.is_whitespace()) {\n        if reading_digits {\n            if c.is_digit(BASE_TEN) {\n                digits.push(c);\n            } else {\n                reading_digits = false;\n                unit.push(c)\n            }\n        } else {\n            unit.push(c);\n        }\n    }\n    if digits.is_empty() { return None; }\n    let mk_duration: fn(i64) -> Duration = match &*unit {\n        \"ns\" | \"nanos\" | \"nano\" | \"nanoseconds\" | \"nanosecond\" => Duration::nanoseconds,\n        \"us\" | \"micros\" | \"micro\" | \"microseconds\" | \"microsecond\" => Duration::microseconds,\n        \"ms\" | \"millis\" | \"milli\" | \"milliseconds\" | \"millisecond\" => Duration::milliseconds,\n        \"s\" | \"secs\" | \"sec\" | \"seconds\" | \"second\" => Duration::seconds,\n        \"m\" | \"mins\" | \"min\" | \"minutes\" | \"minute\" => Duration::minutes,\n        \"h\" | \"hours\" | \"hour\" => Duration::hours,\n        \"d\" | \"days\" | \"day\" => Duration::days,\n        _ => return None\n    };\n    let n = digits.parse().unwrap();  // always correct\n    Some(mk_duration(n))\n"]], "pred": {"ppl": 1.5481635332107544, "ppl_lower": 1.669076919555664, "ppl/lowercase_ppl": -1.1720580706533978, "ppl/zlib": 0.0009910871002196554, "Min_5.0% Prob": 5.906660624912807, "Min_10.0% Prob": 3.700350406624022, "Min_20.0% Prob": 2.091238377725377, "Min_30.0% Prob": 1.4460258699777557, "Min_40.0% Prob": 1.0886343263089657, "Min_50.0% Prob": 0.8749654992958004, "Min_60.0% Prob": 0.7280975088394959}}
{"hexsha": "d87c9e045f315190d8c5e8bd4dc961076a207bc2", "ext": "rs", "lang": "Rust", "content": "fn badly_signed_check_should_fail() {\n\t\tlet ux = Ex::new_signed(\n\t\t\tvec![0u8; 0],\n\t\t\tTEST_ACCOUNT,\n\t\t\tTestSig(TEST_ACCOUNT, vec![0u8; 0]),\n\t\t\tTestExtra\n\t\t);\n\t\tassert!(ux.is_signed().unwrap_or(false));\n\t\tassert_eq!(<Ex as Checkable<TestContext>>::check(ux, &TestContext), Err(crate::BAD_SIGNATURE));\n\t}", "item_id": 4, "repo": "HPIPS/HPIPS_Chain", "file": "core/sr-primitives/src/generic/unchecked_extrinsic.rs", "last_update_at": "2019-08-07T10:22:08+00:00", "question_id": "d87c9e045f315190d8c5e8bd4dc961076a207bc2_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn badly_signed_check_should_fail() {\n\t\tlet ux = Ex::new_signed(\n\t\t\tvec![0u8; 0],\n\t\t\tTEST_ACCOUNT,\n\t\t\tTestSig(TEST_ACCOUNT, vec![0u8; 0]),\n\t\t\tTestExtra\n\t\t);\n\t\tassert!(ux.is_signed().unwrap_or(false));\n\t\tassert_eq!(<Ex as Checkable<TestContext>>::check(ux, &TestContext), Err(crate::BAD_SIGNATURE));\n"]], "pred": {"ppl": 5.083558082580566, "ppl_lower": 7.245966911315918, "ppl/lowercase_ppl": -1.2179773117598782, "ppl/zlib": 0.007424709709473129, "Min_5.0% Prob": 9.180207967758179, "Min_10.0% Prob": 7.5880411588228664, "Min_20.0% Prob": 5.7701248327891035, "Min_30.0% Prob": 4.545084921325126, "Min_40.0% Prob": 3.774176584349738, "Min_50.0% Prob": 3.156951807001058, "Min_60.0% Prob": 2.6838256307854884}}
{"hexsha": "a6369dc4c983beb04ed254ef2f1ba5e7e983dc43", "ext": "rs", "lang": "Rust", "content": "fn delegate_to_test(){\n    let mut this=Foo{value:(3,5,8,13,21)};\n\n    let fields=&[\n        FieldInfo::not_renamed(\"0\"),\n        FieldInfo::not_renamed(\"1\"),\n        FieldInfo::not_renamed(\"2\"),\n        FieldInfo::not_renamed(\"3\"),\n        FieldInfo::not_renamed(\"4\"),\n    ];\n\n    assert_eq!( this.fields_info(), &fields[..] );\n    assert_eq!( get_fields_assoc_const(&this), &fields[..] );\n\n    assert_eq!(\n        this.fields(fp!(1,3,0,2,4)),\n        (&5,&13,&3,&8,&21),\n    );\n    assert_eq!(\n        this.fields_mut(fp!(1,3,0,2,4)),\n        (&mut 5,&mut 13,&mut 3,&mut 8,&mut 21),\n    );\n\n    assert_eq!( this.clone().into_field(fp!(0)), 3 );\n    assert_eq!( this.clone().into_field(fp!(1)), 5 );\n    assert_eq!( this.clone().into_field(fp!(2)), 8 );\n    assert_eq!( this.clone().into_field(fp!(3)), 13 );\n    assert_eq!( this.clone().into_field(fp!(4)), 21 );\n}", "item_id": 7, "repo": "RalfJung/structural_crates", "file": "structural/src/tests/structural_derive.rs", "last_update_at": "2019-12-06T08:59:49+00:00", "question_id": "a6369dc4c983beb04ed254ef2f1ba5e7e983dc43_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn delegate_to_test(){\n    let mut this=Foo{value:(3,5,8,13,21)};\n    let fields=&[\n        FieldInfo::not_renamed(\"0\"),\n        FieldInfo::not_renamed(\"1\"),\n        FieldInfo::not_renamed(\"2\"),\n        FieldInfo::not_renamed(\"3\"),\n        FieldInfo::not_renamed(\"4\"),\n    ];\n    assert_eq!( this.fields_info(), &fields[..] );\n    assert_eq!( get_fields_assoc_const(&this), &fields[..] );\n    assert_eq!(\n        this.fields(fp!(1,3,0,2,4)),\n        (&5,&13,&3,&8,&21),\n    );\n    assert_eq!(\n        this.fields_mut(fp!(1,3,0,2,4)),\n        (&mut 5,&mut 13,&mut 3,&mut 8,&mut 21),\n    );\n    assert_eq!( this.clone().into_field(fp!(0)), 3 );\n    assert_eq!( this.clone().into_field(fp!(1)), 5 );\n    assert_eq!( this.clone().into_field(fp!(2)), 8 );\n    assert_eq!( this.clone().into_field(fp!(3)), 13 );\n    assert_eq!( this.clone().into_field(fp!(4)), 21 );\n"]], "pred": {"ppl": 2.0630197525024414, "ppl_lower": 2.1436941623687744, "ppl/lowercase_ppl": -1.0529706192668102, "ppl/zlib": 0.0025144819746285817, "Min_5.0% Prob": 7.097599730772131, "Min_10.0% Prob": 5.143499442509243, "Min_20.0% Prob": 3.3335438076878936, "Min_30.0% Prob": 2.37151776337735, "Min_40.0% Prob": 1.8021501796906227, "Min_50.0% Prob": 1.445645883871898, "Min_60.0% Prob": 1.2106070901445662}}
{"hexsha": "2ccc6dde5b7dd9bfb6866553d62b8e08904cd9c7", "ext": "rs", "lang": "Rust", "content": "pub fn add_http_breakpoint(\n    service: &ZapService,\n    string: String,\n    location: String,\n    mtch: String,\n    inverse: String,\n    ignorecase: String,\n) -> Result<Value, ZapApiError> {\n    let mut params = HashMap::new();\n    params.insert(\"string\".to_string(), string);\n    params.insert(\"location\".to_string(), location);\n    params.insert(\"match\".to_string(), mtch);\n    params.insert(\"inverse\".to_string(), inverse);\n    params.insert(\"ignorecase\".to_string(), ignorecase);\n    super::call(service, \"break\", \"action\", \"addHttpBreakpoint\", params)\n}", "item_id": 2, "repo": "cak/zap-api-rust", "file": "src/brk.rs", "last_update_at": "2019-05-23T12:34:22+00:00", "question_id": "2ccc6dde5b7dd9bfb6866553d62b8e08904cd9c7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn add_http_breakpoint(\n    service: &ZapService,\n    string: String,\n    location: String,\n    mtch: String,\n    inverse: String,\n    ignorecase: String,\n) -> Result<Value, ZapApiError> {\n    let mut params = HashMap::new();\n    params.insert(\"string\".to_string(), string);\n    params.insert(\"location\".to_string(), location);\n    params.insert(\"match\".to_string(), mtch);\n    params.insert(\"inverse\".to_string(), inverse);\n    params.insert(\"ignorecase\".to_string(), ignorecase);\n    super::call(service, \"break\", \"action\", \"addHttpBreakpoint\", params)\n"]], "pred": {"ppl": 2.953014373779297, "ppl_lower": 3.585325002670288, "ppl/lowercase_ppl": -1.1791816706152949, "ppl/zlib": 0.004213332569134162, "Min_5.0% Prob": 9.46204388141632, "Min_10.0% Prob": 7.439939106211943, "Min_20.0% Prob": 4.925622729694142, "Min_30.0% Prob": 3.4801538752821775, "Min_40.0% Prob": 2.6961203284453656, "Min_50.0% Prob": 2.160920046826546, "Min_60.0% Prob": 1.8105583582610751}}
{"hexsha": "dfd72bab48f625510568aae031fef93488dae578", "ext": "rs", "lang": "Rust", "content": "fn fibonacci_sync(mut cx: FunctionContext) -> JsResult<JsString> {\n    let n = cx.argument::<JsNumber>(0)?.value() as usize;\n    let big = compute(n);\n    Ok(cx.string(big.to_str_radix(10)))\n}", "item_id": 1, "repo": "theJian/examples", "file": "fibonacci-task/native/src/lib.rs", "last_update_at": "2019-02-04T14:47:12+00:00", "question_id": "dfd72bab48f625510568aae031fef93488dae578_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn fibonacci_sync(mut cx: FunctionContext) -> JsResult<JsString> {\n    let n = cx.argument::<JsNumber>(0)?.value() as usize;\n    let big = compute(n);\n    Ok(cx.string(big.to_str_radix(10)))\n"]], "pred": {"ppl": 2.630391836166382, "ppl_lower": 4.495034217834473, "ppl/lowercase_ppl": -1.5540505355346284, "ppl/zlib": 0.005933330197715942, "Min_5.0% Prob": 8.734541257222494, "Min_10.0% Prob": 7.395632198878697, "Min_20.0% Prob": 4.535223670800527, "Min_30.0% Prob": 3.2156818956136703, "Min_40.0% Prob": 2.4011270068585873, "Min_50.0% Prob": 1.9557726866490133, "Min_60.0% Prob": 1.6106735149915847}}
{"hexsha": "a10d4c508021a2a4a7f87ea06703e2856e0f8eee", "ext": "rs", "lang": "Rust", "content": "fn ShiftExpression2(tokens: Input<InputWrapper>) -> IResult<Input<InputWrapper>, node::Expression> {\n    let skipped = take!(tokens.clone(), 1)?;\n    let tok = is_token!(skipped.0, Token::DoubleBigger)?;\n    let or = ShiftExpression(skipped.1)?;\n    let and = ShiftExpression(tok.0)?;\n    Ok((\n        and.0,\n        node::Expression::BinaryExpression(node::BinaryExpression {\n            operator: estree::BinaryOperator::MoreMore,\n            left: box or.1,\n            right: box and.1,\n        }),\n    ))\n}", "item_id": 25, "repo": "retep007/javascript-es9-parser", "file": "components/parser/src/expression.rs", "last_update_at": "2019-05-24T15:26:18+00:00", "question_id": "a10d4c508021a2a4a7f87ea06703e2856e0f8eee_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn ShiftExpression2(tokens: Input<InputWrapper>) -> IResult<Input<InputWrapper>, node::Expression> {\n    let skipped = take!(tokens.clone(), 1)?;\n    let tok = is_token!(skipped.0, Token::DoubleBigger)?;\n    let or = ShiftExpression(skipped.1)?;\n    let and = ShiftExpression(tok.0)?;\n    Ok((\n        and.0,\n        node::Expression::BinaryExpression(node::BinaryExpression {\n            operator: estree::BinaryOperator::MoreMore,\n            left: box or.1,\n            right: box and.1,\n        }),\n    ))\n"]], "pred": {"ppl": 4.305664539337158, "ppl_lower": 5.647092819213867, "ppl/lowercase_ppl": -1.1857685642932825, "ppl/zlib": 0.00579337893057525, "Min_5.0% Prob": 10.189948081970215, "Min_10.0% Prob": 8.20094832777977, "Min_20.0% Prob": 5.90679008513689, "Min_30.0% Prob": 4.466960899531841, "Min_40.0% Prob": 3.5406859572976828, "Min_50.0% Prob": 2.8869020199403166, "Min_60.0% Prob": 2.423183880125483}}
{"hexsha": "c5ea232e0ddefb1a144497f1ef8f8ffb237b24f3", "ext": "rs", "lang": "Rust", "content": "fn test_new_by_line_empty_2() {\n        let ingredient = Ingredient::new_by_line(\";\");\n        assert_eq!(ingredient.name, \"\");\n        assert_eq!(ingredient.group, Group::Other);\n    }", "item_id": 1, "repo": "totoMauz/Cooking-Book", "file": "src/cooking_book/ingredient.rs", "last_update_at": "2019-04-02T19:01:39+00:00", "question_id": "c5ea232e0ddefb1a144497f1ef8f8ffb237b24f3_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_new_by_line_empty_2() {\n        let ingredient = Ingredient::new_by_line(\";\");\n        assert_eq!(ingredient.name, \"\");\n        assert_eq!(ingredient.group, Group::Other);\n"]], "pred": {"ppl": 3.9001994132995605, "ppl_lower": 4.622341156005859, "ppl/lowercase_ppl": -1.1248127713266667, "ppl/zlib": 0.011632715243108516, "Min_5.0% Prob": 9.342503547668457, "Min_10.0% Prob": 7.920935710271199, "Min_20.0% Prob": 5.7840369664705715, "Min_30.0% Prob": 4.374198700252332, "Min_40.0% Prob": 3.3475990020311794, "Min_50.0% Prob": 2.6861378636324043, "Min_60.0% Prob": 2.288745659857224}}
{"hexsha": "c124457118cb97768a98b181f70be07ad85e7dd9", "ext": "rs", "lang": "Rust", "content": "unsafe fn shrink_in_place(&mut self,\n                              ptr: NonNull<u8>,\n                              layout: Layout,\n                              new_size: usize) -> Result<(), CannotReallocInPlace> {\n        let _ = ptr; // this default implementation doesn't care about the actual address.\n        debug_assert!(new_size <= layout.size());\n        let (l, _u) = self.usable_size(&layout);\n        //                      layout.size() <= _u  [guaranteed by usable_size()]\n        // new_layout.size() <= layout.size()        [required by this method]\n        if l <= new_size {\n            Ok(())\n        } else {\n            Err(CannotReallocInPlace)\n        }\n    }", "item_id": 6, "repo": "jespersm/rust", "file": "src/libcore/alloc.rs", "last_update_at": "2019-05-18T01:43:48+00:00", "question_id": "c124457118cb97768a98b181f70be07ad85e7dd9_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn shrink_in_place(&mut self,\n                              ptr: NonNull<u8>,\n                              layout: Layout,\n                              new_size: usize) -> Result<(), CannotReallocInPlace> {\n        let _ = ptr; // this default implementation doesn't care about the actual address.\n        debug_assert!(new_size <= layout.size());\n        let (l, _u) = self.usable_size(&layout);\n        //                      layout.size() <= _u  [guaranteed by usable_size()]\n        // new_layout.size() <= layout.size()        [required by this method]\n        if l <= new_size {\n            Ok(())\n        } else {\n            Err(CannotReallocInPlace)\n        }\n"]], "pred": {"ppl": 3.2832493782043457, "ppl_lower": 4.426290035247803, "ppl/lowercase_ppl": -1.2512783742341755, "ppl/zlib": 0.003762131633224432, "Min_5.0% Prob": 7.782079855600993, "Min_10.0% Prob": 6.371702750523885, "Min_20.0% Prob": 4.716586768627167, "Min_30.0% Prob": 3.6662883493635388, "Min_40.0% Prob": 2.881283737616996, "Min_50.0% Prob": 2.366287519479846, "Min_60.0% Prob": 1.98985807136248}}
{"hexsha": "d9abf304aa292dad0efdb6ed6c7088f9d9f6a173", "ext": "rs", "lang": "Rust", "content": "fn create(\n    name: &str,\n    config: &types::SubscriptionCreateConfig,\n    reg: &SharedRegistry,\n    cfg: &Config,\n) -> Option<HttpResponse> {\n    let ack_deadline = config\n        .ack_deadline\n        .map(|ack_deadline| Duration::seconds(i64::from(ack_deadline)))\n        .unwrap_or(cfg.default_ack_deadline);\n    let ttl = config\n        .ttl\n        .map(|ttl| Duration::seconds(i64::from(ttl)))\n        .unwrap_or(cfg.default_subscription_ttl);\n    let subscribe = reg.create_subscription(\n        &name,\n        &config.topic,\n        ack_deadline,\n        ttl,\n        config.historical.unwrap_or(false),\n    );\n    subscribe.map(|(created, subscription)| {\n        let mut response = if created {\n            HttpResponse::Created()\n        } else {\n            HttpResponse::Conflict()\n        };\n        response.json(subscription)\n    })\n}", "item_id": 0, "repo": "davidMcneil/qorier", "file": "service/src/http_protocol/subscription_handlers.rs", "last_update_at": "2019-12-21T14:47:59+00:00", "question_id": "d9abf304aa292dad0efdb6ed6c7088f9d9f6a173_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn create(\n    name: &str,\n    config: &types::SubscriptionCreateConfig,\n    reg: &SharedRegistry,\n    cfg: &Config,\n) -> Option<HttpResponse> {\n    let ack_deadline = config\n        .ack_deadline\n        .map(|ack_deadline| Duration::seconds(i64::from(ack_deadline)))\n        .unwrap_or(cfg.default_ack_deadline);\n    let ttl = config\n        .ttl\n        .map(|ttl| Duration::seconds(i64::from(ttl)))\n        .unwrap_or(cfg.default_subscription_ttl);\n    let subscribe = reg.create_subscription(\n        &name,\n        &config.topic,\n        ack_deadline,\n        ttl,\n        config.historical.unwrap_or(false),\n    );\n    subscribe.map(|(created, subscription)| {\n        let mut response = if created {\n            HttpResponse::Created()\n        } else {\n            HttpResponse::Conflict()\n        };\n        response.json(subscription)\n    })\n"]], "pred": {"ppl": 2.160034418106079, "ppl_lower": 2.50087308883667, "ppl/lowercase_ppl": -1.1902495194373583, "ppl/zlib": 0.002206659472428349, "Min_5.0% Prob": 7.318530632899358, "Min_10.0% Prob": 5.424106668542932, "Min_20.0% Prob": 3.425690407102758, "Min_30.0% Prob": 2.4913774983185095, "Min_40.0% Prob": 1.9075198800049045, "Min_50.0% Prob": 1.5353754723741524, "Min_60.0% Prob": 1.287326367142977}}
{"hexsha": "b7ecef4eacbdb112e8837bf86f4b80e3b8e33182", "ext": "rs", "lang": "Rust", "content": "fn ask_with_optional_default<F>(question: &str, default: Option<&str>, validator: F) -> String\n    where\n        F: Fn(String) -> Result<(), String>\n{\n    println!(\"{}{}\", question, default.map(|start| format!(\" [{}]\", start)).unwrap_or(String::new()));\n    let mut buffer = String::new();\n    io::stdin().read_line(&mut buffer).expect(\"Could not read from stdin\");\n    match default {\n        None => {\n            let mut validation_result = validator(buffer.trim().to_string());\n            while buffer.trim().is_empty() || validation_result.is_err() {\n                println!(\"{}\", if buffer.trim().is_empty() { \"Please provide an answer.\".to_string() } else { validation_result.unwrap_err() });\n                buffer.clear();\n                io::stdin().read_line(&mut buffer).expect(\"Could not read from stdin\");\n                validation_result = validator(buffer.trim().to_string());\n            }\n            buffer.trim().to_string()\n        }\n        Some(default_value) =>\n            if buffer.trim().is_empty() {\n                default_value.to_string()\n            } else {\n                let mut validation_result = validator(buffer.trim().to_string());\n                while validation_result.is_err() {\n                    println!(\"{}\", validation_result.unwrap_err());\n                    buffer.clear();\n                    io::stdin().read_line(&mut buffer).expect(\"Could not read from stdin\");\n                    validation_result = validator(buffer.trim().to_string());\n                }\n                buffer.trim().to_string()\n            }\n    }\n}", "item_id": 3, "repo": "SiXoS/No-Project-Time-Tracker", "file": "src/main.rs", "last_update_at": "2019-11-29T23:31:39+00:00", "question_id": "b7ecef4eacbdb112e8837bf86f4b80e3b8e33182_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn ask_with_optional_default<F>(question: &str, default: Option<&str>, validator: F) -> String\n    where\n        F: Fn(String) -> Result<(), String>\n{\n    println!(\"{}{}\", question, default.map(|start| format!(\" [{}]\", start)).unwrap_or(String::new()));\n    let mut buffer = String::new();\n    io::stdin().read_line(&mut buffer).expect(\"Could not read from stdin\");\n    match default {\n        None => {\n            let mut validation_result = validator(buffer.trim().to_string());\n            while buffer.trim().is_empty() || validation_result.is_err() {\n                println!(\"{}\", if buffer.trim().is_empty() { \"Please provide an answer.\".to_string() } else { validation_result.unwrap_err() });\n                buffer.clear();\n                io::stdin().read_line(&mut buffer).expect(\"Could not read from stdin\");\n                validation_result = validator(buffer.trim().to_string());\n            }\n            buffer.trim().to_string()\n        }\n        Some(default_value) =>\n            if buffer.trim().is_empty() {\n                default_value.to_string()\n            } else {\n                let mut validation_result = validator(buffer.trim().to_string());\n                while validation_result.is_err() {\n                    println!(\"{}\", validation_result.unwrap_err());\n                    buffer.clear();\n                    io::stdin().read_line(&mut buffer).expect(\"Could not read from stdin\");\n                    validation_result = validator(buffer.trim().to_string());\n                }\n                buffer.trim().to_string()\n            }\n    }\n"]], "pred": {"ppl": 1.4825230836868286, "ppl_lower": 1.6591540575027466, "ppl/lowercase_ppl": -1.2858762021419956, "ppl/zlib": 0.00085042207894647, "Min_5.0% Prob": 5.2310935974121096, "Min_10.0% Prob": 3.2712706152985738, "Min_20.0% Prob": 1.8723681791719184, "Min_30.0% Prob": 1.3012649895803583, "Min_40.0% Prob": 0.982387981422425, "Min_50.0% Prob": 0.7863701683616875, "Min_60.0% Prob": 0.6574941583437822}}
{"hexsha": "3048cef1fe3ed92c2a75e92ef6cb649ff367ac1b", "ext": "rs", "lang": "Rust", "content": "fn special_chars_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"?x!+ // -| ]z]]\"#\n        );\n\n        assert_oks!(for lex and buf ;\n            Token::Character('?')\n            Token::Character('x')\n            Token::Character('!')\n            Token::Character('+')\n            Token::Whitespace(' ')\n            Token::Character('/')\n            Token::Character('/')\n            Token::Whitespace(' ')\n            Token::Character('-')\n            Token::Character('|')\n            Token::Whitespace(' ')\n            Token::Character(']')\n            Token::Character('z')\n            Token::Chunk(\"]]\")\n        );\n        assert_none!(for lex and buf);\n    }", "item_id": 1, "repo": "andrewrk/xml-rs", "file": "src/reader/lexer.rs", "last_update_at": "2019-07-10T01:57:50+00:00", "question_id": "3048cef1fe3ed92c2a75e92ef6cb649ff367ac1b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn special_chars_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"?x!+ // -| ]z]]\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::Character('?')\n            Token::Character('x')\n            Token::Character('!')\n            Token::Character('+')\n            Token::Whitespace(' ')\n            Token::Character('/')\n            Token::Character('/')\n            Token::Whitespace(' ')\n            Token::Character('-')\n            Token::Character('|')\n            Token::Whitespace(' ')\n            Token::Character(']')\n            Token::Character('z')\n            Token::Chunk(\"]]\")\n        );\n        assert_none!(for lex and buf);\n"]], "pred": {"ppl": 3.2816414833068848, "ppl_lower": 3.3549978733062744, "ppl/lowercase_ppl": -1.0186035287405004, "ppl/zlib": 0.005658779759234806, "Min_5.0% Prob": 9.207463370429146, "Min_10.0% Prob": 7.347643425590114, "Min_20.0% Prob": 5.160756286821868, "Min_30.0% Prob": 3.811472132540586, "Min_40.0% Prob": 2.9366644362085745, "Min_50.0% Prob": 2.368110041594819, "Min_60.0% Prob": 1.977825202194876}}
{"hexsha": "419b76ee1e8daaf42ad8810717a2a1539029d563", "ext": "rs", "lang": "Rust", "content": "pub fn to_absolute_path(path: &Path) -> io::Result<PathBuf> {\n    // IDEA: Provide a flag --real-path for canonicalization of file path?\n    //       Match real paths and/or output real paths? (affect --include and --exclude?)\n    //       Logical: resolve '..' components before symlinks (Windows)\n    //       Physical: resolve symlinks as encountered (Unix)\n    // NOTE: A path like /root/../compo is considered an absolute path, seriously.\n    //       An absolute path is not always a real path (with symlinks fully resolved).\n    if path.is_absolute() {\n        Ok(path.to_path_buf())\n    } else {\n        if *HAS_PWD {\n            let path = path.strip_prefix(\".\").unwrap_or(path);\n\n            Ok((*PWD).join(path))\n        } else {\n            Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"could not resolve relative path into absolute path\",\n            ))\n        }\n    }\n}", "item_id": 0, "repo": "jakwings/find-file", "file": "src/fshelper.rs", "last_update_at": "2019-08-25T18:37:49+00:00", "question_id": "419b76ee1e8daaf42ad8810717a2a1539029d563_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn to_absolute_path(path: &Path) -> io::Result<PathBuf> {\n    // IDEA: Provide a flag --real-path for canonicalization of file path?\n    //       Match real paths and/or output real paths? (affect --include and --exclude?)\n    //       Logical: resolve '..' components before symlinks (Windows)\n    //       Physical: resolve symlinks as encountered (Unix)\n    // NOTE: A path like /root/../compo is considered an absolute path, seriously.\n    //       An absolute path is not always a real path (with symlinks fully resolved).\n    if path.is_absolute() {\n        Ok(path.to_path_buf())\n    } else {\n        if *HAS_PWD {\n            let path = path.strip_prefix(\".\").unwrap_or(path);\n            Ok((*PWD).join(path))\n        } else {\n            Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"could not resolve relative path into absolute path\",\n            ))\n        }\n    }\n"]], "pred": {"ppl": 4.7795939445495605, "ppl_lower": 6.276670455932617, "ppl/lowercase_ppl": -1.174182944521594, "ppl/zlib": 0.003314312699271194, "Min_5.0% Prob": 8.799951039827787, "Min_10.0% Prob": 7.248005793644832, "Min_20.0% Prob": 5.6931326526861925, "Min_30.0% Prob": 4.590582853631128, "Min_40.0% Prob": 3.745888154279618, "Min_50.0% Prob": 3.071828323896184, "Min_60.0% Prob": 2.5970307322619837}}
{"hexsha": "0b6b0c16e50b21486ecd92e41b394ca64915236c", "ext": "rs", "lang": "Rust", "content": "fn encipher_small() {\n    let rail_fence = RailFence::new(4);\n\n    let ctext = rail_fence.encipher(\"DEFENDTHEEASTWALLOFTHECASTLE\");\n    assert_eq!(ctext.unwrap(), \"DTTFSEDHSWOTATFNEAALHCLEELEE\");\n}", "item_id": 0, "repo": "sradley/cipher", "file": "tests/test_rail_fence.rs", "last_update_at": "2019-08-25T11:07:39+00:00", "question_id": "0b6b0c16e50b21486ecd92e41b394ca64915236c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn encipher_small() {\n    let rail_fence = RailFence::new(4);\n    let ctext = rail_fence.encipher(\"DEFENDTHEEASTWALLOFTHECASTLE\");\n    assert_eq!(ctext.unwrap(), \"DTTFSEDHSWOTATFNEAALHCLEELEE\");\n"]], "pred": {"ppl": 7.1427903175354, "ppl_lower": 8.875561714172363, "ppl/lowercase_ppl": -1.1104713583113683, "ppl/zlib": 0.012211822986236184, "Min_5.0% Prob": 9.944341897964478, "Min_10.0% Prob": 8.439281165599823, "Min_20.0% Prob": 7.008853070876178, "Min_30.0% Prob": 5.902028656005859, "Min_40.0% Prob": 4.706365636166404, "Min_50.0% Prob": 3.911751328479676, "Min_60.0% Prob": 3.260076773079003}}
{"hexsha": "f25a31a02a812d218db611088e5f74d52eeb1e1c", "ext": "rs", "lang": "Rust", "content": "fn create_transaction_test() {\n        let manager = SqliteConnectionManager::memory();\n        let pool = r2d2::Pool::new(manager).unwrap();\n        create_base(pool.get().unwrap());\n\n        let id = create_transaction(pool.get().unwrap(), 1, 2, 50, \"Super Payment\");\n\n        assert_eq!(id.unwrap(), 1);\n    }", "item_id": 9, "repo": "DemonusPC/pig-ledger", "file": "src/transaction/db.rs", "last_update_at": "2019-11-22T10:48:45+00:00", "question_id": "f25a31a02a812d218db611088e5f74d52eeb1e1c_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn create_transaction_test() {\n        let manager = SqliteConnectionManager::memory();\n        let pool = r2d2::Pool::new(manager).unwrap();\n        create_base(pool.get().unwrap());\n        let id = create_transaction(pool.get().unwrap(), 1, 2, 50, \"Super Payment\");\n        assert_eq!(id.unwrap(), 1);\n"]], "pred": {"ppl": 3.3462014198303223, "ppl_lower": 5.001982688903809, "ppl/lowercase_ppl": -1.332836551714159, "ppl/zlib": 0.006710143321958841, "Min_5.0% Prob": 9.128899335861206, "Min_10.0% Prob": 7.528000195821126, "Min_20.0% Prob": 5.077291789807771, "Min_30.0% Prob": 3.7047860581299354, "Min_40.0% Prob": 2.9069640384270596, "Min_50.0% Prob": 2.3757961334622637, "Min_60.0% Prob": 2.0292188725594817}}
{"hexsha": "54d6d8efd7e07029294e63de8142cc5e2bb9272d", "ext": "rs", "lang": "Rust", "content": "fn test_i64() {\n    let test: i64 = 0x12345678_90ABCDEF;\n    assert_eq!(from_bytes::<BE, i64>(&[0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF]).unwrap(), test);\n    assert_eq!(from_bytes::<LE, i64>(&[0xEF, 0xCD, 0xAB, 0x90, 0x78, 0x56, 0x34, 0x12]).unwrap(), test);\n  }", "item_id": 7, "repo": "Mingun/serde-pod", "file": "src/de.rs", "last_update_at": "2019-02-15T10:23:51+00:00", "question_id": "54d6d8efd7e07029294e63de8142cc5e2bb9272d_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_i64() {\n    let test: i64 = 0x12345678_90ABCDEF;\n    assert_eq!(from_bytes::<BE, i64>(&[0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF]).unwrap(), test);\n    assert_eq!(from_bytes::<LE, i64>(&[0xEF, 0xCD, 0xAB, 0x90, 0x78, 0x56, 0x34, 0x12]).unwrap(), test);\n"]], "pred": {"ppl": 1.574736475944519, "ppl_lower": 1.5709612369537354, "ppl/lowercase_ppl": -0.9947141151474719, "ppl/zlib": 0.002803011984061396, "Min_5.0% Prob": 6.371072381734848, "Min_10.0% Prob": 3.954824454644147, "Min_20.0% Prob": 2.226966596701566, "Min_30.0% Prob": 1.51513824801819, "Min_40.0% Prob": 1.1405590604579843, "Min_50.0% Prob": 0.9132659071097698, "Min_60.0% Prob": 0.7612151881627391}}
{"hexsha": "11855d90c160f0af20154f7cdd4a32325dd0b5e5", "ext": "rs", "lang": "Rust", "content": "fn merkle_one_id_should_work() {\n        let ids: Vec<Checksum256> = vec![[1u8; 32].into()];\n        let result = merkle(ids);\n        assert!(result.is_ok());\n        let expect: Checksum256 = [1u8; 32].into();\n        assert_eq!(result.unwrap(), expect);\n    }", "item_id": 7, "repo": "monacohq/rust-eos", "file": "chain/src/merkle.rs", "last_update_at": "2019-12-05T09:54:09+00:00", "question_id": "11855d90c160f0af20154f7cdd4a32325dd0b5e5_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn merkle_one_id_should_work() {\n        let ids: Vec<Checksum256> = vec![[1u8; 32].into()];\n        let result = merkle(ids);\n        assert!(result.is_ok());\n        let expect: Checksum256 = [1u8; 32].into();\n        assert_eq!(result.unwrap(), expect);\n"]], "pred": {"ppl": 2.988656520843506, "ppl_lower": 3.351139545440674, "ppl/lowercase_ppl": -1.1045615482139726, "ppl/zlib": 0.00680014883412206, "Min_5.0% Prob": 9.030147552490234, "Min_10.0% Prob": 7.051114583015442, "Min_20.0% Prob": 4.639665991067886, "Min_30.0% Prob": 3.4571989317735037, "Min_40.0% Prob": 2.678954964131117, "Min_50.0% Prob": 2.1702424602210524, "Min_60.0% Prob": 1.8195554134746392}}
{"hexsha": "e9bad59d21144d285f826a09abafb38ed1827fee", "ext": "rs", "lang": "Rust", "content": "pub fn run() {\n    let mut client = serenity::client::Client::new(config::DISCORD_TOKEN, Handler::new()).expect(\"To create client\");\n\n    client.with_framework(\n        serenity::framework::StandardFramework::new().configure(configure)\n                                                     .help(&HELP)\n                                                     .on_dispatch_error(on_dispatch_error)\n                                                     .group(&GENERAL_GROUP)\n                                                     .group(&ADMIN_GROUP)\n    );\n\n    match client.cache_and_http.http.get_current_user() {\n        Ok(info) => {\n            SELF_ID.store(info.id.0, Ordering::Release);\n        },\n        Err(error) => {\n            rogu::error!(\"Discord unable to get current user info: {}\", error);\n        }\n    }\n\n    if config::DISCORD.with_read(|config| config.owner) == 0 {\n        match client.cache_and_http.http.get_current_application_info() {\n            Ok(info) => {\n                rogu::info!(\"Discord setting new owner id={}\", info.owner.id.0);\n                config::DISCORD.with_write(|config| config.owner = info.owner.id.0);\n            },\n            Err(error) => {\n                rogu::error!(\"Discord unable to get application information: {}\", error);\n                STATS.increment(stats::DiscordNoAppInfo);\n            }\n        };\n    }\n\n    HTTP.write().replace(client.cache_and_http.clone());\n\n    while let Some((tweet_id, user_name, tweet_type)) = twitter::BUFFERED_TWEETS.dequeue() {\n        twitter::redirect_tweet(&client.cache_and_http.http, tweet_id, user_name, tweet_type);\n    }\n\n    loop {\n        rogu::info!(\"Discord: start\");\n        match client.start() {\n            Ok(_) => {\n                STATS.increment(stats::DiscordShutdown);\n                break;\n            }\n            Err(error) => {\n                STATS.increment(stats::DiscordFailure);\n                rogu::warn!(\"Discord stopped with error: {}\", error);\n            }\n        }\n    }\n\n    HTTP.write().take();\n}", "item_id": 0, "repo": "DoumanAsh/Jeanne", "file": "src/discord/mod.rs", "last_update_at": "2019-07-23T08:12:20+00:00", "question_id": "e9bad59d21144d285f826a09abafb38ed1827fee_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn run() {\n    let mut client = serenity::client::Client::new(config::DISCORD_TOKEN, Handler::new()).expect(\"To create client\");\n    client.with_framework(\n        serenity::framework::StandardFramework::new().configure(configure)\n                                                     .help(&HELP)\n                                                     .on_dispatch_error(on_dispatch_error)\n                                                     .group(&GENERAL_GROUP)\n                                                     .group(&ADMIN_GROUP)\n    );\n    match client.cache_and_http.http.get_current_user() {\n        Ok(info) => {\n            SELF_ID.store(info.id.0, Ordering::Release);\n        },\n        Err(error) => {\n            rogu::error!(\"Discord unable to get current user info: {}\", error);\n        }\n    }\n    if config::DISCORD.with_read(|config| config.owner) == 0 {\n        match client.cache_and_http.http.get_current_application_info() {\n            Ok(info) => {\n                rogu::info!(\"Discord setting new owner id={}\", info.owner.id.0);\n                config::DISCORD.with_write(|config| config.owner = info.owner.id.0);\n            },\n            Err(error) => {\n                rogu::error!(\"Discord unable to get application information: {}\", error);\n                STATS.increment(stats::DiscordNoAppInfo);\n            }\n        };\n    }\n    HTTP.write().replace(client.cache_and_http.clone());\n    while let Some((tweet_id, user_name, tweet_type)) = twitter::BUFFERED_TWEETS.dequeue() {\n        twitter::redirect_tweet(&client.cache_and_http.http, tweet_id, user_name, tweet_type);\n    }\n    loop {\n        rogu::info!(\"Discord: start\");\n        match client.start() {\n            Ok(_) => {\n                STATS.increment(stats::DiscordShutdown);\n                break;\n            }\n            Err(error) => {\n                STATS.increment(stats::DiscordFailure);\n                rogu::warn!(\"Discord stopped with error: {}\", error);\n            }\n        }\n    }\n    HTTP.write().take();\n"]], "pred": {"ppl": 2.4676618576049805, "ppl_lower": 2.793844699859619, "ppl/lowercase_ppl": -1.1374422272724132, "ppl/zlib": 0.001295941299801171, "Min_5.0% Prob": 7.920000433921814, "Min_10.0% Prob": 6.031590122925608, "Min_20.0% Prob": 4.0623852211496105, "Min_30.0% Prob": 2.926512977291394, "Min_40.0% Prob": 2.2398635516047993, "Min_50.0% Prob": 1.8024866838381983, "Min_60.0% Prob": 1.5050114101894008}}
{"hexsha": "44e7d0caefd8d4c874ec5bc5d9c66bae2b0ef5e4", "ext": "rs", "lang": "Rust", "content": "pub fn get_sphere_uv(p: Vec3) -> (f32, f32) {\n    let phi = p.z().atan2(p.x());\n    let theta = p.y().asin();\n    let u = 1.0 - (phi + PI) / (2.0 * PI);\n    let v = (theta + PI / 2.0) / PI;\n    (u, v)\n}", "item_id": 1, "repo": "BlackGoku36/RRayTracer", "file": "src/raytrace/vec.rs", "last_update_at": "2019-05-29T19:54:30+00:00", "question_id": "44e7d0caefd8d4c874ec5bc5d9c66bae2b0ef5e4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_sphere_uv(p: Vec3) -> (f32, f32) {\n    let phi = p.z().atan2(p.x());\n    let theta = p.y().asin();\n    let u = 1.0 - (phi + PI) / (2.0 * PI);\n    let v = (theta + PI / 2.0) / PI;\n    (u, v)\n"]], "pred": {"ppl": 1.731381893157959, "ppl_lower": 1.924654483795166, "ppl/lowercase_ppl": -1.1927905989538918, "ppl/zlib": 0.0037089180528731462, "Min_5.0% Prob": 6.844523811340332, "Min_10.0% Prob": 4.565118932723999, "Min_20.0% Prob": 2.619339119820368, "Min_30.0% Prob": 1.8144676056690514, "Min_40.0% Prob": 1.3733237470651782, "Min_50.0% Prob": 1.1022850306428693, "Min_60.0% Prob": 0.9187268047521894}}
{"hexsha": "0dca4d208f861c5e801ff9730ecd5939ebe89970", "ext": "rs", "lang": "Rust", "content": "fn json_ser_simple(b: &mut Bencher) {\n    let value = value();\n    let mut vec = Vec::with_capacity(512);\n    b.iter(|| {\n        let _ = serde_json::to_writer(&mut vec, &value).unwrap();\n        vec.clear();\n    });\n}", "item_id": 1, "repo": "luojia65/coruscant", "file": "coruscant-nbt/benches/nbt-speeds.rs", "last_update_at": "2019-10-19T20:58:42+00:00", "question_id": "0dca4d208f861c5e801ff9730ecd5939ebe89970_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn json_ser_simple(b: &mut Bencher) {\n    let value = value();\n    let mut vec = Vec::with_capacity(512);\n    b.iter(|| {\n        let _ = serde_json::to_writer(&mut vec, &value).unwrap();\n        vec.clear();\n    });\n"]], "pred": {"ppl": 2.3666110038757324, "ppl_lower": 3.4934659004211426, "ppl/lowercase_ppl": -1.4520648963090004, "ppl/zlib": 0.00559388945203536, "Min_5.0% Prob": 7.991987943649292, "Min_10.0% Prob": 5.929933130741119, "Min_20.0% Prob": 3.8692846968770027, "Min_30.0% Prob": 2.7504315972328186, "Min_40.0% Prob": 2.114484974183142, "Min_50.0% Prob": 1.7110618716105819, "Min_60.0% Prob": 1.4329757681504514}}
{"hexsha": "54ff55a37ac8e7a11044c07423baa1b703584212", "ext": "rs", "lang": "Rust", "content": "fn fixed_height() {\n        let (mut tree, root) = layout_tree! {\n            (node(display = Block, size.height = Px(10.)))\n        };\n\n        tree.calculate(root, 0., 10.);\n        assert_eq!(tree.debug(root), \"Block(0.0, 10.0) []\");\n\n        tree.calculate(root, 10., 0.);\n        assert_eq!(tree.debug(root), \"Block(10.0, 10.0) []\");\n    }", "item_id": 1, "repo": "cztomsik/node-webrender", "file": "libgraffiti/src/layout/block.rs", "last_update_at": "2019-03-07T14:40:18+00:00", "question_id": "54ff55a37ac8e7a11044c07423baa1b703584212_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn fixed_height() {\n        let (mut tree, root) = layout_tree! {\n            (node(display = Block, size.height = Px(10.)))\n        };\n        tree.calculate(root, 0., 10.);\n        assert_eq!(tree.debug(root), \"Block(0.0, 10.0) []\");\n        tree.calculate(root, 10., 0.);\n        assert_eq!(tree.debug(root), \"Block(10.0, 10.0) []\");\n"]], "pred": {"ppl": 3.33400297164917, "ppl_lower": 3.4209747314453125, "ppl/lowercase_ppl": -1.0213854899320605, "ppl/zlib": 0.006727227238238508, "Min_5.0% Prob": 8.449898401896158, "Min_10.0% Prob": 6.718421899355375, "Min_20.0% Prob": 4.669042498977096, "Min_30.0% Prob": 3.618008488562049, "Min_40.0% Prob": 2.880953132022511, "Min_50.0% Prob": 2.375507360783176, "Min_60.0% Prob": 2.0199356271726328}}
{"hexsha": "07b2dcc89f88ebd13d2e9fb46dabe7784856e641", "ext": "rs", "lang": "Rust", "content": "pub fn verify_client(\n    client: &ExitClientIdentity,\n    client_verified: bool,\n    conn: &PgConnection,\n) -> Result<(), RitaExitError> {\n    use self::schema::clients::dsl::*;\n    let ip = client.global.mesh_ip;\n    let wg = client.global.wg_public_key;\n    let key = client.global.eth_address;\n    let filtered_list = clients\n        .filter(mesh_ip.eq(ip.to_string()))\n        .filter(wg_pubkey.eq(wg.to_string()))\n        .filter(eth_address.eq(key.to_string().to_lowercase()));\n\n    diesel::update(filtered_list)\n        .set(verified.eq(client_verified))\n        .execute(&*conn)?;\n\n    Ok(())\n}", "item_id": 4, "repo": "althea-mesh/althea_rs", "file": "rita_exit/src/database/database_tools.rs", "last_update_at": "2019-06-10T17:42:00+00:00", "question_id": "07b2dcc89f88ebd13d2e9fb46dabe7784856e641_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn verify_client(\n    client: &ExitClientIdentity,\n    client_verified: bool,\n    conn: &PgConnection,\n) -> Result<(), RitaExitError> {\n    use self::schema::clients::dsl::*;\n    let ip = client.global.mesh_ip;\n    let wg = client.global.wg_public_key;\n    let key = client.global.eth_address;\n    let filtered_list = clients\n        .filter(mesh_ip.eq(ip.to_string()))\n        .filter(wg_pubkey.eq(wg.to_string()))\n        .filter(eth_address.eq(key.to_string().to_lowercase()));\n    diesel::update(filtered_list)\n        .set(verified.eq(client_verified))\n        .execute(&*conn)?;\n    Ok(())\n"]], "pred": {"ppl": 2.4655590057373047, "ppl_lower": 3.1652424335479736, "ppl/lowercase_ppl": -1.2768239743074128, "ppl/zlib": 0.0029587493736392585, "Min_5.0% Prob": 8.107938718795776, "Min_10.0% Prob": 6.3078953084491545, "Min_20.0% Prob": 4.038274296494418, "Min_30.0% Prob": 2.8812829246887794, "Min_40.0% Prob": 2.2374687487649365, "Min_50.0% Prob": 1.8048875885843128, "Min_60.0% Prob": 1.5048085732027314}}
{"hexsha": "e9003be21e9cd0a74b416abdd5eb140f10fddf56", "ext": "rs", "lang": "Rust", "content": "pub fn read<P: AsRef<Path>>(path: P, size_hint: Option<usize>) -> io::Result<(usize, usize, usize)> {\n            let path = path.as_ref();\n            let mut ffr = if let Some(size_hint) = size_hint {\n                FastFile::read(path)\n                    .expect(\"Failed to create FastFileReaderBuilder\")\n                    .with_size_hint(size_hint)\n                    .open()\n                    .expect(\"Failed to open path as FastFile\")\n            } else {\n                FastFile::read(path)\n                    .expect(\"Failed to create FastFileReaderBuilder\")\n                    .open()\n                    .expect(\"Failed to open path as FastFile\")\n            };\n\n            let mut bytes_read = 0usize;\n            let mut sum = 0usize;\n            let mut reads_count = 0usize;\n            loop {\n                let len = match ffr.read() {\n                    Ok(buf) if buf.is_empty() => return Ok((bytes_read, sum, reads_count)),\n                    Ok(buf) => {\n                        sum += buf.iter().map(|x| usize::from(*x)).sum::<usize>();\n                        buf.len()\n                    }\n                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                    Err(e) => return Err(e),\n                };\n                reads_count += 1;\n                bytes_read += len;\n            }\n        }", "item_id": 0, "repo": "lukaspustina/fastfile", "file": "fastfile_benches/src/benches/methods.rs", "last_update_at": "2019-10-10T10:20:51+00:00", "question_id": "e9003be21e9cd0a74b416abdd5eb140f10fddf56_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn read<P: AsRef<Path>>(path: P, size_hint: Option<usize>) -> io::Result<(usize, usize, usize)> {\n            let path = path.as_ref();\n            let mut ffr = if let Some(size_hint) = size_hint {\n                FastFile::read(path)\n                    .expect(\"Failed to create FastFileReaderBuilder\")\n                    .with_size_hint(size_hint)\n                    .open()\n                    .expect(\"Failed to open path as FastFile\")\n            } else {\n                FastFile::read(path)\n                    .expect(\"Failed to create FastFileReaderBuilder\")\n                    .open()\n                    .expect(\"Failed to open path as FastFile\")\n            };\n            let mut bytes_read = 0usize;\n            let mut sum = 0usize;\n            let mut reads_count = 0usize;\n            loop {\n                let len = match ffr.read() {\n                    Ok(buf) if buf.is_empty() => return Ok((bytes_read, sum, reads_count)),\n                    Ok(buf) => {\n                        sum += buf.iter().map(|x| usize::from(*x)).sum::<usize>();\n                        buf.len()\n                    }\n                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                    Err(e) => return Err(e),\n                };\n                reads_count += 1;\n                bytes_read += len;\n            }\n"]], "pred": {"ppl": 1.7697558403015137, "ppl_lower": 2.0375454425811768, "ppl/lowercase_ppl": -1.2468360343726355, "ppl/zlib": 0.001277050545275622, "Min_5.0% Prob": 5.883064998520745, "Min_10.0% Prob": 4.302072247943363, "Min_20.0% Prob": 2.6889545154571532, "Min_30.0% Prob": 1.8852570097494339, "Min_40.0% Prob": 1.4233558078482746, "Min_50.0% Prob": 1.1395448246633912, "Min_60.0% Prob": 0.9532111548342639}}
{"hexsha": "ec17c73f381a5a41e8282bafdbacc2c32fc4504f", "ext": "rs", "lang": "Rust", "content": "fn test_i8() {\n    let test: i8 = 0x12;\n    assert_eq!(to_vec::<BE,_>(&test).unwrap(), vec![0x12]);\n    assert_eq!(to_vec::<LE,_>(&test).unwrap(), vec![0x12]);\n  }", "item_id": 2, "repo": "Mingun/serde-pod", "file": "src/ser.rs", "last_update_at": "2019-02-15T10:23:51+00:00", "question_id": "ec17c73f381a5a41e8282bafdbacc2c32fc4504f_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_i8() {\n    let test: i8 = 0x12;\n    assert_eq!(to_vec::<BE,_>(&test).unwrap(), vec![0x12]);\n    assert_eq!(to_vec::<LE,_>(&test).unwrap(), vec![0x12]);\n"]], "pred": {"ppl": 2.9554812908172607, "ppl_lower": 2.9626264572143555, "ppl/lowercase_ppl": -1.0022282608883568, "ppl/zlib": 0.010946075868370193, "Min_5.0% Prob": 8.765841484069824, "Min_10.0% Prob": 7.31636939729963, "Min_20.0% Prob": 4.912698340415955, "Min_30.0% Prob": 3.4957732350929924, "Min_40.0% Prob": 2.6675594348099922, "Min_50.0% Prob": 2.1518210283456702, "Min_60.0% Prob": 1.8326314600265545}}
{"hexsha": "f25a31a02a812d218db611088e5f74d52eeb1e1c", "ext": "rs", "lang": "Rust", "content": "pub fn list_transactions(\n    conn: r2d2::PooledConnection<r2d2_sqlite::SqliteConnectionManager>,\n) -> Result<Vec<Transaction>> {\n    let mut stmt = conn.prepare(\"SELECT id, date, name from Transactions ORDER BY date DESC\")?;\n\n    let transactions = stmt\n        .query_map(NO_PARAMS, |row| {\n            Ok(Transaction {\n                id: row.get(0).unwrap(),\n                date: row.get(1).unwrap(),\n                name: row.get(2).unwrap(),\n            })\n        })\n        .and_then(|mapped_rows| {\n            Ok(mapped_rows\n                .map(|row| row.unwrap())\n                .collect::<Vec<Transaction>>())\n        })?;\n\n    Ok(transactions)\n}", "item_id": 4, "repo": "DemonusPC/pig-ledger", "file": "src/transaction/db.rs", "last_update_at": "2019-11-22T10:48:45+00:00", "question_id": "f25a31a02a812d218db611088e5f74d52eeb1e1c_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn list_transactions(\n    conn: r2d2::PooledConnection<r2d2_sqlite::SqliteConnectionManager>,\n) -> Result<Vec<Transaction>> {\n    let mut stmt = conn.prepare(\"SELECT id, date, name from Transactions ORDER BY date DESC\")?;\n    let transactions = stmt\n        .query_map(NO_PARAMS, |row| {\n            Ok(Transaction {\n                id: row.get(0).unwrap(),\n                date: row.get(1).unwrap(),\n                name: row.get(2).unwrap(),\n            })\n        })\n        .and_then(|mapped_rows| {\n            Ok(mapped_rows\n                .map(|row| row.unwrap())\n                .collect::<Vec<Transaction>>())\n        })?;\n    Ok(transactions)\n"]], "pred": {"ppl": 1.751567006111145, "ppl_lower": 2.3425121307373047, "ppl/lowercase_ppl": -1.5186574180036423, "ppl/zlib": 0.0017626126394301952, "Min_5.0% Prob": 6.427807188034057, "Min_10.0% Prob": 4.319112753868103, "Min_20.0% Prob": 2.5945328429341314, "Min_30.0% Prob": 1.8333992476264636, "Min_40.0% Prob": 1.3973101111128927, "Min_50.0% Prob": 1.123322054594755, "Min_60.0% Prob": 0.9379812366329133}}
{"hexsha": "4af374f4d857972acd76462687db970c5d638c05", "ext": "rs", "lang": "Rust", "content": "async fn extract(intent: &ImportIntent, paths: &Paths) -> Result<(), ImportError> {\n    let extract_new = extract::extract_gzip(paths.store_new(), paths.extract_new())\n        .instrument(debug_span!(\"gzip::new\"));\n\n    if intent.has_old_dump() {\n        let extract_old = extract::extract_gzip(paths.store_old(), paths.extract_old())\n            .instrument(debug_span!(\"gzip::old\"));\n\n        info!(\"extracting old and new indexes\");\n        futures::try_join!(extract_old, extract_new)?;\n    } else {\n        info!(\"extracting new index\");\n        extract_new.await?;\n    };\n\n    Ok(())\n}", "item_id": 2, "repo": "satelit-project/satelit-import", "file": "src/anidb/importer.rs", "last_update_at": "2019-05-27T16:37:09+00:00", "question_id": "4af374f4d857972acd76462687db970c5d638c05_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn extract(intent: &ImportIntent, paths: &Paths) -> Result<(), ImportError> {\n    let extract_new = extract::extract_gzip(paths.store_new(), paths.extract_new())\n        .instrument(debug_span!(\"gzip::new\"));\n    if intent.has_old_dump() {\n        let extract_old = extract::extract_gzip(paths.store_old(), paths.extract_old())\n            .instrument(debug_span!(\"gzip::old\"));\n        info!(\"extracting old and new indexes\");\n        futures::try_join!(extract_old, extract_new)?;\n    } else {\n        info!(\"extracting new index\");\n        extract_new.await?;\n    };\n    Ok(())\n"]], "pred": {"ppl": 3.0788800716400146, "ppl_lower": 3.813666582107544, "ppl/lowercase_ppl": -1.1903180264847033, "ppl/zlib": 0.004089330610030246, "Min_5.0% Prob": 9.051418198479546, "Min_10.0% Prob": 7.171925650702582, "Min_20.0% Prob": 4.905135465992822, "Min_30.0% Prob": 3.637143742155146, "Min_40.0% Prob": 2.780444611629395, "Min_50.0% Prob": 2.2545946055388715, "Min_60.0% Prob": 1.886428751376107}}
{"hexsha": "561f2c3356a39fb03a420b702a2019bcb2193606", "ext": "rs", "lang": "Rust", "content": "fn should_stay_idle_when_no_release() {\n\t\tlet (update_policy, _) = update_policy();\n\t\tlet (_client, updater, _, _, ..) = setup(update_policy);\n\n\t\tassert_eq!(updater.state.lock().status, UpdaterStatus::Idle);\n\t\tupdater.poll();\n\t\tassert_eq!(updater.state.lock().status, UpdaterStatus::Idle);\n\t}", "item_id": 4, "repo": "altice-io/Daqiao", "file": "bridge/parity-ethereum/updater/src/updater.rs", "last_update_at": "2019-09-11T12:07:35+00:00", "question_id": "561f2c3356a39fb03a420b702a2019bcb2193606_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn should_stay_idle_when_no_release() {\n\t\tlet (update_policy, _) = update_policy();\n\t\tlet (_client, updater, _, _, ..) = setup(update_policy);\n\t\tassert_eq!(updater.state.lock().status, UpdaterStatus::Idle);\n\t\tupdater.poll();\n\t\tassert_eq!(updater.state.lock().status, UpdaterStatus::Idle);\n"]], "pred": {"ppl": 3.185189723968506, "ppl_lower": 3.914151191711426, "ppl/lowercase_ppl": -1.1778891087945382, "ppl/zlib": 0.0073323535140191135, "Min_5.0% Prob": 8.450145053863526, "Min_10.0% Prob": 6.909296209161932, "Min_20.0% Prob": 4.761750656625499, "Min_30.0% Prob": 3.692301368012148, "Min_40.0% Prob": 2.852861018932384, "Min_50.0% Prob": 2.306077480316162, "Min_60.0% Prob": 1.945787693441346}}
{"hexsha": "e049f4062c0057693c0c90e18fb5d6b5ec44bb92", "ext": "rs", "lang": "Rust", "content": "fn problem_2017_2_2() {\n    #![allow(clippy::unwrap_used)]\n    let input = read_to_string(\"src/year2017/day02_input.txt\").unwrap();\n    solve(2017, 2, 2, &input).unwrap();\n}", "item_id": 103, "repo": "fornwall/advent-of-code-2019-rs", "file": "crates/core/benches/iai.rs", "last_update_at": "2019-12-10T00:08:49+00:00", "question_id": "e049f4062c0057693c0c90e18fb5d6b5ec44bb92_103", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn problem_2017_2_2() {\n    #![allow(clippy::unwrap_used)]\n    let input = read_to_string(\"src/year2017/day02_input.txt\").unwrap();\n    solve(2017, 2, 2, &input).unwrap();\n"]], "pred": {"ppl": 3.5688047409057617, "ppl_lower": 3.5688047409057617, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.00908736238044553, "Min_5.0% Prob": 8.59098752339681, "Min_10.0% Prob": 6.86843340737479, "Min_20.0% Prob": 4.7845776081085205, "Min_30.0% Prob": 3.744159926538882, "Min_40.0% Prob": 3.0911511023839315, "Min_50.0% Prob": 2.525841269053911, "Min_60.0% Prob": 2.114593949978766}}
{"hexsha": "ba06ea081f0dc27f380ce611f4424033b44f9ce3", "ext": "rs", "lang": "Rust", "content": "fn basic_pipeline() {\n        let pipeline = pipeline! {\n            i32\n            => add2\n            => div_by_3\n            => mul_by_83\n            ;-> f32\n        };\n        let result = pipeline.run(2);\n\n        assert_eq!(result, ((2 + 2) as f64 / 3.0) as f32 * 83.0);\n    }", "item_id": 0, "repo": "Cackbone/pipeline-macro", "file": "src/lib.rs", "last_update_at": "2019-08-23T07:00:17+00:00", "question_id": "ba06ea081f0dc27f380ce611f4424033b44f9ce3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn basic_pipeline() {\n        let pipeline = pipeline! {\n            i32\n            => add2\n            => div_by_3\n            => mul_by_83\n            ;-> f32\n        };\n        let result = pipeline.run(2);\n        assert_eq!(result, ((2 + 2) as f64 / 3.0) as f32 * 83.0);\n"]], "pred": {"ppl": 3.951242208480835, "ppl_lower": 3.951242208480835, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.00916020008422181, "Min_5.0% Prob": 8.222521877288818, "Min_10.0% Prob": 6.915459203720093, "Min_20.0% Prob": 5.3408111214637755, "Min_30.0% Prob": 4.153726804256439, "Min_40.0% Prob": 3.3306764125823975, "Min_50.0% Prob": 2.685193739393178, "Min_60.0% Prob": 2.2731208693785745}}
{"hexsha": "1d74d2e8c42f9bc517d8ccbf2408f9c1e687350f", "ext": "rs", "lang": "Rust", "content": "pub fn longest_common_prefix(strs: Vec<String>) -> String {\n    let mut common = String::new();\n    if strs.len() == 0 {\n        return common;\n    } else if strs.len() == 1 {\n        return strs[0].clone();\n    }\n\n    let mut k: usize = 0;\n    loop {\n        let cur_ch: char;\n        match strs[0].chars().nth(k) {\n            None => {\n                return common;\n            }\n            Some(ch) => {\n                cur_ch = ch;\n            }\n        };\n\n        for i in 1..strs.len() {\n            match strs[i].chars().nth(k) {\n                Some(ch) if cur_ch == ch => {}\n                _ => return common,\n            }\n        }\n\n        common.push(cur_ch);\n        k += 1;\n    }\n}", "item_id": 0, "repo": "yjhmelody/leetcode-rust", "file": "src/longest_common_prefix.rs", "last_update_at": "2019-06-05T06:51:56+00:00", "question_id": "1d74d2e8c42f9bc517d8ccbf2408f9c1e687350f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn longest_common_prefix(strs: Vec<String>) -> String {\n    let mut common = String::new();\n    if strs.len() == 0 {\n        return common;\n    } else if strs.len() == 1 {\n        return strs[0].clone();\n    }\n    let mut k: usize = 0;\n    loop {\n        let cur_ch: char;\n        match strs[0].chars().nth(k) {\n            None => {\n                return common;\n            }\n            Some(ch) => {\n                cur_ch = ch;\n            }\n        };\n        for i in 1..strs.len() {\n            match strs[i].chars().nth(k) {\n                Some(ch) if cur_ch == ch => {}\n                _ => return common,\n            }\n        }\n        common.push(cur_ch);\n        k += 1;\n    }\n"]], "pred": {"ppl": 1.5754977464675903, "ppl_lower": 1.7932592630386353, "ppl/lowercase_ppl": -1.2848036014865034, "ppl/zlib": 0.0016062588404735813, "Min_5.0% Prob": 5.601229971105402, "Min_10.0% Prob": 3.5926823097726572, "Min_20.0% Prob": 2.1135731618041578, "Min_30.0% Prob": 1.4816033521640128, "Min_40.0% Prob": 1.1279938446924738, "Min_50.0% Prob": 0.9067664567624097, "Min_60.0% Prob": 0.7567597158097973}}
{"hexsha": "b8be3287b5d43ce8bc7ea21333e00d3b9139acee", "ext": "rs", "lang": "Rust", "content": "pub fn task( data : &str, iter_count : i32 ) -> i32 {\n    let map = create_map( data );\n    let init = \".#./..#/###\";\n    let init_image = to_image( init );\n    let mut image = init_image;\n    for _ in 0 .. iter_count {\n        let n = to_side( image.len() );\n        let is_by_2 = n % 2 == 0;\n        let is_by_3 = n % 3 == 0;\n        let size = if is_by_2 { 2 } else if is_by_3 { 3 } else { panic!(\"not expacted\") };\n        let image2 : Image2 = split( &image, size );\n        let new_image2 : Image2 = image2.iter()\n            .map( |i| ( *i.0, transform(i.1, &map ) ) ).collect();\n        image = unify( &new_image2 );\n    }\n    image.iter().filter( |i| *i.1 == '#' ).count() as i32\n}", "item_id": 7, "repo": "yury-fedorov/AoC18", "file": "AoC17/rust/src/day21.rs", "last_update_at": "2019-01-21T15:08:21+00:00", "question_id": "b8be3287b5d43ce8bc7ea21333e00d3b9139acee_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn task( data : &str, iter_count : i32 ) -> i32 {\n    let map = create_map( data );\n    let init = \".#./..#/###\";\n    let init_image = to_image( init );\n    let mut image = init_image;\n    for _ in 0 .. iter_count {\n        let n = to_side( image.len() );\n        let is_by_2 = n % 2 == 0;\n        let is_by_3 = n % 3 == 0;\n        let size = if is_by_2 { 2 } else if is_by_3 { 3 } else { panic!(\"not expacted\") };\n        let image2 : Image2 = split( &image, size );\n        let new_image2 : Image2 = image2.iter()\n            .map( |i| ( *i.0, transform(i.1, &map ) ) ).collect();\n        image = unify( &new_image2 );\n    }\n    image.iter().filter( |i| *i.1 == '#' ).count() as i32\n"]], "pred": {"ppl": 3.04491925239563, "ppl_lower": 3.1040947437286377, "ppl/lowercase_ppl": -1.017286201235381, "ppl/zlib": 0.003313911853314215, "Min_5.0% Prob": 8.710780217097355, "Min_10.0% Prob": 6.5891516116949225, "Min_20.0% Prob": 4.542975225538577, "Min_30.0% Prob": 3.3939432486891747, "Min_40.0% Prob": 2.6755161143351938, "Min_50.0% Prob": 2.1955955983765088, "Min_60.0% Prob": 1.8496432613974774}}
{"hexsha": "a57cd8f7631515b8061ff79db8646cf271ca5d59", "ext": "rs", "lang": "Rust", "content": "fn connect(name_hash: NameHash, our_uid: UniqueId, listener: &Listener) {\n        const SOCKET_TOKEN: Token = Token(0);\n        let el = unwrap!(Poll::new());\n\n        let (our_pk, our_sk) = gen_encrypt_keypair();\n        let mut sock = unwrap!(TcpSock::connect(&listener.addr));\n        unwrap!(sock.set_encrypt_ctx(EncryptContext::anonymous_encrypt(listener.pub_key)));\n        let shared_key = our_sk.shared_secret(&listener.pub_key);\n        unwrap!(sock.set_decrypt_ctx(DecryptContext::authenticated(shared_key.clone())));\n        unwrap!(el.register(&sock, SOCKET_TOKEN, Ready::writable(), PollOpt::edge()));\n\n        let message = Message::ConnectRequest(our_uid, name_hash, Default::default(), our_pk);\n\n        let mut events = Events::with_capacity(16);\n        'event_loop: loop {\n            let _ = unwrap!(el.poll(&mut events, None));\n            for ev in events.iter() {\n                match ev.token() {\n                    SOCKET_TOKEN => {\n                        if ev.readiness().is_writable() {\n                            let sent = unwrap!(sock.write(Some((message.clone(), 0))));\n                            assert!(sent);\n                            unwrap!(el.reregister(\n                                &sock,\n                                SOCKET_TOKEN,\n                                Ready::readable(),\n                                PollOpt::edge(),\n                            ));\n                        }\n                        if ev.readiness().is_readable() {\n                            let msg: Message<UniqueId> = unwrap!(unwrap!(sock.read()));\n                            let their_uid = match msg {\n                                Message::ConnectResponse(peer_uid, peer_hash) => {\n                                    assert_eq!(peer_uid, listener.uid);\n                                    assert_eq!(peer_hash, NAME_HASH);\n\n                                    unwrap!(sock.set_encrypt_ctx(EncryptContext::authenticated(\n                                        shared_key\n                                    )));\n                                    peer_uid\n                                }\n                                msg => panic!(\"Unexpected message: {:?}\", msg),\n                            };\n                            if our_uid > their_uid {\n                                let message = Message::ChooseConnection::<UniqueId>;\n                                let sent = unwrap!(sock.write(Some((message, 0))));\n                                assert!(sent);\n                            }\n                            break 'event_loop;\n                        }\n                    }\n                    _ => panic!(\"Unexpected event\"),\n                }\n            }\n        }\n\n        match unwrap!(listener.event_rx.recv(), \"Could not read event channel\") {\n            Event::ConnectSuccess(id) => assert_eq!(id, our_uid),\n            event => panic!(\"Unexpected event notification: {:?}\", event),\n        }\n    }", "item_id": 3, "repo": "hbeimf/crust", "file": "src/main/connection_listener/mod.rs", "last_update_at": "2019-01-15T02:34:24+00:00", "question_id": "a57cd8f7631515b8061ff79db8646cf271ca5d59_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn connect(name_hash: NameHash, our_uid: UniqueId, listener: &Listener) {\n        const SOCKET_TOKEN: Token = Token(0);\n        let el = unwrap!(Poll::new());\n        let (our_pk, our_sk) = gen_encrypt_keypair();\n        let mut sock = unwrap!(TcpSock::connect(&listener.addr));\n        unwrap!(sock.set_encrypt_ctx(EncryptContext::anonymous_encrypt(listener.pub_key)));\n        let shared_key = our_sk.shared_secret(&listener.pub_key);\n        unwrap!(sock.set_decrypt_ctx(DecryptContext::authenticated(shared_key.clone())));\n        unwrap!(el.register(&sock, SOCKET_TOKEN, Ready::writable(), PollOpt::edge()));\n        let message = Message::ConnectRequest(our_uid, name_hash, Default::default(), our_pk);\n        let mut events = Events::with_capacity(16);\n        'event_loop: loop {\n            let _ = unwrap!(el.poll(&mut events, None));\n            for ev in events.iter() {\n                match ev.token() {\n                    SOCKET_TOKEN => {\n                        if ev.readiness().is_writable() {\n                            let sent = unwrap!(sock.write(Some((message.clone(), 0))));\n                            assert!(sent);\n                            unwrap!(el.reregister(\n                                &sock,\n                                SOCKET_TOKEN,\n                                Ready::readable(),\n                                PollOpt::edge(),\n                            ));\n                        }\n                        if ev.readiness().is_readable() {\n                            let msg: Message<UniqueId> = unwrap!(unwrap!(sock.read()));\n                            let their_uid = match msg {\n                                Message::ConnectResponse(peer_uid, peer_hash) => {\n                                    assert_eq!(peer_uid, listener.uid);\n                                    assert_eq!(peer_hash, NAME_HASH);\n                                    unwrap!(sock.set_encrypt_ctx(EncryptContext::authenticated(\n                                        shared_key\n                                    )));\n                                    peer_uid\n                                }\n                                msg => panic!(\"Unexpected message: {:?}\", msg),\n                            };\n                            if our_uid > their_uid {\n                                let message = Message::ChooseConnection::<UniqueId>;\n                                let sent = unwrap!(sock.write(Some((message, 0))));\n                                assert!(sent);\n                            }\n                            break 'event_loop;\n                        }\n                    }\n                    _ => panic!(\"Unexpected event\"),\n                }\n            }\n        }\n        match unwrap!(listener.event_rx.recv(), \"Could not read event channel\") {\n            Event::ConnectSuccess(id) => assert_eq!(id, our_uid),\n            event => panic!(\"Unexpected event notification: {:?}\", event),\n        }\n"]], "pred": {"ppl": 2.144030809402466, "ppl_lower": 2.5096051692962646, "ppl/lowercase_ppl": -1.20642504456814, "ppl/zlib": 0.0008920322960964065, "Min_5.0% Prob": 7.0216978305094955, "Min_10.0% Prob": 5.273731444333051, "Min_20.0% Prob": 3.389040886555742, "Min_30.0% Prob": 2.445461600220629, "Min_40.0% Prob": 1.887731263719275, "Min_50.0% Prob": 1.521812874873612, "Min_60.0% Prob": 1.272727679466438}}
{"hexsha": "027b6a61e28dbcd833904451788b18bd7d052de7", "ext": "rs", "lang": "Rust", "content": "pub fn open(req: OpenRequest) -> super::super::error::Result<()> {\n    let mut hm = ::std::collections::HashMap::new();\n    hm.insert(\"token\".to_owned(), req.token);\n    hm.insert(\"dialog\".to_owned(), serde_json::to_string(&req.dialog)?);\n    hm.insert(\"trigger_id\".to_owned(), req.trigger_id);\n    let response: OpenResponse = super::request(\"dialog.open\", &hm)?;\n\n    if !response.ok {\n        return Err(From::from(\"Bad Slack Response\"));\n    }\n\n    Ok(())\n}", "item_id": 0, "repo": "pbzweihander/old-ip-manager", "file": "src/slack/dialog.rs", "last_update_at": "2019-04-11T12:20:25+00:00", "question_id": "027b6a61e28dbcd833904451788b18bd7d052de7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn open(req: OpenRequest) -> super::super::error::Result<()> {\n    let mut hm = ::std::collections::HashMap::new();\n    hm.insert(\"token\".to_owned(), req.token);\n    hm.insert(\"dialog\".to_owned(), serde_json::to_string(&req.dialog)?);\n    hm.insert(\"trigger_id\".to_owned(), req.trigger_id);\n    let response: OpenResponse = super::request(\"dialog.open\", &hm)?;\n    if !response.ok {\n        return Err(From::from(\"Bad Slack Response\"));\n    }\n    Ok(())\n"]], "pred": {"ppl": 2.7391812801361084, "ppl_lower": 3.8015501499176025, "ppl/lowercase_ppl": -1.325258665038966, "ppl/zlib": 0.003704628944409828, "Min_5.0% Prob": 7.8959367615836005, "Min_10.0% Prob": 6.52932669321696, "Min_20.0% Prob": 4.448368318619266, "Min_30.0% Prob": 3.2705699347931407, "Min_40.0% Prob": 2.5023768609089236, "Min_50.0% Prob": 2.0062113016461716, "Min_60.0% Prob": 1.68825414919004}}
{"hexsha": "1ee58ef95cb3db42e6e38ac4c6c773b922bf072a", "ext": "rs", "lang": "Rust", "content": "fn test_seek_maximum() {\n        let mut sub_cursor = SubCursor::new().start(0).end(usize::max_value());\n\n        sub_cursor.seek(SeekFrom::Current(1)).unwrap();\n\n        let position = sub_cursor\n            .seek(SeekFrom::Current(u64::max_value() as i64))\n            .unwrap();\n\n        assert_eq!(position, 0);\n\n        sub_cursor.seek(SeekFrom::Current(2)).unwrap();\n\n        let position = sub_cursor\n            .seek(SeekFrom::Current(u64::max_value() as i64))\n            .unwrap();\n\n        assert_eq!(position, 1);\n\n        let position = sub_cursor.seek(SeekFrom::Start(u64::max_value())).unwrap();\n        assert_eq!(position, 0);\n    }", "item_id": 0, "repo": "Luro02/SubCursor", "file": "src/sub_cursor.rs", "last_update_at": "2019-10-30T10:39:22+00:00", "question_id": "1ee58ef95cb3db42e6e38ac4c6c773b922bf072a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_seek_maximum() {\n        let mut sub_cursor = SubCursor::new().start(0).end(usize::max_value());\n        sub_cursor.seek(SeekFrom::Current(1)).unwrap();\n        let position = sub_cursor\n            .seek(SeekFrom::Current(u64::max_value() as i64))\n            .unwrap();\n        assert_eq!(position, 0);\n        sub_cursor.seek(SeekFrom::Current(2)).unwrap();\n        let position = sub_cursor\n            .seek(SeekFrom::Current(u64::max_value() as i64))\n            .unwrap();\n        assert_eq!(position, 1);\n        let position = sub_cursor.seek(SeekFrom::Start(u64::max_value())).unwrap();\n        assert_eq!(position, 0);\n"]], "pred": {"ppl": 1.8941209316253662, "ppl_lower": 2.0464181900024414, "ppl/lowercase_ppl": -1.1210733646909334, "ppl/zlib": 0.0030129945404743833, "Min_5.0% Prob": 6.753526600924405, "Min_10.0% Prob": 4.6214891997250644, "Min_20.0% Prob": 2.9319232173941354, "Min_30.0% Prob": 2.0932293789404812, "Min_40.0% Prob": 1.5998894990506498, "Min_50.0% Prob": 1.2756555027890581, "Min_60.0% Prob": 1.065727907833398}}
{"hexsha": "81a9fdea48ce9dcc5294dfa4ab94ca9cf80eada2", "ext": "rs", "lang": "Rust", "content": "fn get_mock_update_to_latest_ledger(\n    req: &UpdateToLatestLedgerRequest,\n) -> UpdateToLatestLedgerResponse {\n    let mut resp = UpdateToLatestLedgerResponse::new();\n    for request_item in req.get_requested_items().iter() {\n        resp.mut_response_items()\n            .push(get_mock_response_item(request_item).unwrap());\n    }\n    let mut ledger_info = types::proto::ledger_info::LedgerInfo::new();\n    ledger_info.set_transaction_accumulator_hash(HashValue::zero().to_vec());\n    ledger_info.set_consensus_data_hash(HashValue::zero().to_vec());\n    ledger_info.set_consensus_block_id(HashValue::zero().to_vec());\n    ledger_info.set_version(7);\n    let mut ledger_info_with_sigs = ProtoLedgerInfoWithSignatures::new();\n    ledger_info_with_sigs.set_ledger_info(ledger_info);\n    resp.set_ledger_info_with_sigs(ledger_info_with_sigs);\n    resp\n}", "item_id": 0, "repo": "ts25504/libra", "file": "storage/storage_service/src/mocks/mock_storage_client.rs", "last_update_at": "2019-09-26T17:16:41+00:00", "question_id": "81a9fdea48ce9dcc5294dfa4ab94ca9cf80eada2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_mock_update_to_latest_ledger(\n    req: &UpdateToLatestLedgerRequest,\n) -> UpdateToLatestLedgerResponse {\n    let mut resp = UpdateToLatestLedgerResponse::new();\n    for request_item in req.get_requested_items().iter() {\n        resp.mut_response_items()\n            .push(get_mock_response_item(request_item).unwrap());\n    }\n    let mut ledger_info = types::proto::ledger_info::LedgerInfo::new();\n    ledger_info.set_transaction_accumulator_hash(HashValue::zero().to_vec());\n    ledger_info.set_consensus_data_hash(HashValue::zero().to_vec());\n    ledger_info.set_consensus_block_id(HashValue::zero().to_vec());\n    ledger_info.set_version(7);\n    let mut ledger_info_with_sigs = ProtoLedgerInfoWithSignatures::new();\n    ledger_info_with_sigs.set_ledger_info(ledger_info);\n    resp.set_ledger_info_with_sigs(ledger_info_with_sigs);\n    resp\n"]], "pred": {"ppl": 1.6037218570709229, "ppl_lower": 1.9897181987762451, "ppl/lowercase_ppl": -1.4566029276558823, "ppl/zlib": 0.0013932952465830768, "Min_5.0% Prob": 5.964011685053507, "Min_10.0% Prob": 4.065774897734324, "Min_20.0% Prob": 2.317401714126269, "Min_30.0% Prob": 1.5822066204001506, "Min_40.0% Prob": 1.1813994488517239, "Min_50.0% Prob": 0.9475225596657849, "Min_60.0% Prob": 0.7906505358577461}}
{"hexsha": "c54db15f30cff27fe0e28f1218b83293f87d063a", "ext": "rs", "lang": "Rust", "content": "fn create_ac_client(conn_addr: &str) -> AdmissionControlClient {\n    let env_builder = Arc::new(EnvBuilder::new().name_prefix(\"ac-grpc-\").build());\n    let ch = ChannelBuilder::new(env_builder).connect(&conn_addr);\n    AdmissionControlClient::new(ch)\n}", "item_id": 1, "repo": "vgao1996/libra", "file": "benchmark/src/bin/ruben.rs", "last_update_at": "2019-09-24T19:26:07+00:00", "question_id": "c54db15f30cff27fe0e28f1218b83293f87d063a_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn create_ac_client(conn_addr: &str) -> AdmissionControlClient {\n    let env_builder = Arc::new(EnvBuilder::new().name_prefix(\"ac-grpc-\").build());\n    let ch = ChannelBuilder::new(env_builder).connect(&conn_addr);\n    AdmissionControlClient::new(ch)\n"]], "pred": {"ppl": 2.4357941150665283, "ppl_lower": 4.839993953704834, "ppl/lowercase_ppl": -1.7712699082170231, "ppl/zlib": 0.0053955929009167096, "Min_5.0% Prob": 7.852106809616089, "Min_10.0% Prob": 6.30913233757019, "Min_20.0% Prob": 4.120184049010277, "Min_30.0% Prob": 2.9079450890421867, "Min_40.0% Prob": 2.2301317437086254, "Min_50.0% Prob": 1.796735427249223, "Min_60.0% Prob": 1.5011692507153687}}
{"hexsha": "4f1eff5ab7f706e1985fe1f023a02960c15d529c", "ext": "rs", "lang": "Rust", "content": "fn p_one() -> i32 {\n    let limit = 576723;\n    let mut hits = 0;\n    let mut password = 109165;\n    while password < limit {\n        let mut digits: Vec<u32> = split(password);\n        make_inc(&mut digits);\n        password = revert_to_number(&digits);\n        if password > limit {\n            break;\n        }\n        if has_double(&digits) {\n            hits = hits + 1;\n        }\n        password = password + 1;\n    }\n\n    hits\n}", "item_id": 0, "repo": "VuQuangPhuc/AdventOfCode2019", "file": "src/day_04/mod.rs", "last_update_at": "2019-12-11T20:38:00+00:00", "question_id": "4f1eff5ab7f706e1985fe1f023a02960c15d529c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn p_one() -> i32 {\n    let limit = 576723;\n    let mut hits = 0;\n    let mut password = 109165;\n    while password < limit {\n        let mut digits: Vec<u32> = split(password);\n        make_inc(&mut digits);\n        password = revert_to_number(&digits);\n        if password > limit {\n            break;\n        }\n        if has_double(&digits) {\n            hits = hits + 1;\n        }\n        password = password + 1;\n    }\n    hits\n"]], "pred": {"ppl": 3.4382712841033936, "ppl_lower": 3.740222215652466, "ppl/lowercase_ppl": -1.068160599242162, "ppl/zlib": 0.006053768683245385, "Min_5.0% Prob": 8.97680936540876, "Min_10.0% Prob": 6.983625275748117, "Min_20.0% Prob": 4.833538236289189, "Min_30.0% Prob": 3.7369328764351932, "Min_40.0% Prob": 3.0087822922344865, "Min_50.0% Prob": 2.450552710931595, "Min_60.0% Prob": 2.0513014633377846}}
{"hexsha": "ea66f9b181d23da56328a4bd97b96f8629cf11c2", "ext": "rs", "lang": "Rust", "content": "fn trim_input(user_input: &mut String) {\n    // Something like trim (perhaps just use `trim`?)\n    if let Some('\\n') = user_input.chars().next_back() {\n        user_input.pop();\n    }\n    if let Some('\\r') = user_input.chars().next_back() {\n        user_input.pop();\n    }\n}", "item_id": 0, "repo": "raventid/renard", "file": "src/repl.rs", "last_update_at": "2019-03-20T16:30:33+00:00", "question_id": "ea66f9b181d23da56328a4bd97b96f8629cf11c2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn trim_input(user_input: &mut String) {\n    // Something like trim (perhaps just use `trim`?)\n    if let Some('\\n') = user_input.chars().next_back() {\n        user_input.pop();\n    }\n    if let Some('\\r') = user_input.chars().next_back() {\n        user_input.pop();\n    }\n"]], "pred": {"ppl": 2.7561302185058594, "ppl_lower": 3.4216036796569824, "ppl/lowercase_ppl": -1.2133318840191583, "ppl/zlib": 0.006944024665275501, "Min_5.0% Prob": 8.455891251564026, "Min_10.0% Prob": 6.925014760759142, "Min_20.0% Prob": 4.6471939839814835, "Min_30.0% Prob": 3.331003383866378, "Min_40.0% Prob": 2.511640548313919, "Min_50.0% Prob": 2.0451886880984333, "Min_60.0% Prob": 1.6887756378487928}}
{"hexsha": "d9449e8de10a9133e484394fe9859bc91333bdb7", "ext": "rs", "lang": "Rust", "content": "fn stored_configuration_toml() {\n        let original = create_test_configuration();\n        let toml = toml::to_string(&original).unwrap();\n        let deserialized: StoredConfiguration = toml::from_str(&toml).unwrap();\n        assert_eq!(original, deserialized);\n    }", "item_id": 0, "repo": "fossabot/exonum", "file": "exonum/src/blockchain/config.rs", "last_update_at": "2019-10-21T13:25:28+00:00", "question_id": "d9449e8de10a9133e484394fe9859bc91333bdb7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn stored_configuration_toml() {\n        let original = create_test_configuration();\n        let toml = toml::to_string(&original).unwrap();\n        let deserialized: StoredConfiguration = toml::from_str(&toml).unwrap();\n        assert_eq!(original, deserialized);\n"]], "pred": {"ppl": 2.7557690143585205, "ppl_lower": 3.6607015132904053, "ppl/lowercase_ppl": -1.2801215660261525, "ppl/zlib": 0.006669056169227897, "Min_5.0% Prob": 10.370582898457846, "Min_10.0% Prob": 7.945864813668387, "Min_20.0% Prob": 4.614639373620351, "Min_30.0% Prob": 3.326702734286135, "Min_40.0% Prob": 2.4991652444005013, "Min_50.0% Prob": 2.041614628623466, "Min_60.0% Prob": 1.6856091948846976}}
{"hexsha": "ffef2c29479bce5ac9e6e0c155f6b7a23d555af7", "ext": "rs", "lang": "Rust", "content": "fn hash( string: String ) -> String {\n    let mut hasher = Sha1::new();\n    hasher.update( string.as_bytes() );\n    hasher.digest().to_string()\n}", "item_id": 0, "repo": "tomhoule/stdweb", "file": "examples/hasher/src/main.rs", "last_update_at": "2019-09-20T16:35:23+00:00", "question_id": "ffef2c29479bce5ac9e6e0c155f6b7a23d555af7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn hash( string: String ) -> String {\n    let mut hasher = Sha1::new();\n    hasher.update( string.as_bytes() );\n    hasher.digest().to_string()\n"]], "pred": {"ppl": 2.3290727138519287, "ppl_lower": 3.020517349243164, "ppl/lowercase_ppl": -1.3074714039677464, "ppl/zlib": 0.007686092831601872, "Min_5.0% Prob": 9.234427452087402, "Min_10.0% Prob": 6.065827512741089, "Min_20.0% Prob": 3.6712173938751222, "Min_30.0% Prob": 2.6859293739000956, "Min_40.0% Prob": 2.1047733165323734, "Min_50.0% Prob": 1.7082157553732396, "Min_60.0% Prob": 1.431700727591912}}
{"hexsha": "2b0c35ce77cefeb0c4ca7fe0d3381aac8a734270", "ext": "rs", "lang": "Rust", "content": "fn start_lobby() {\n    let mut client = common::setup();\n    client.send(1, \".n 1\");\n    client.send(1, \".m\");\n    client.send(2, \".n 2\");\n    client.send(2, \".j 1\");\n    client.send(1, \".s\");\n    client.read_all();\n    assert!(client\n        .last(1)\n        .contains(\"You are the THRUSTEE. Choose NOW..........\"));\n    assert!(client\n        .last(2)\n        .contains(\"You are a THRUSTER. waiting for a good THRUSTEE from 1; mmm baby!\"));\n}", "item_id": 3, "repo": "maxrchung/THRUSTIN", "file": "backend/tests/lobby_navigation.rs", "last_update_at": "2019-04-06T22:07:11+00:00", "question_id": "2b0c35ce77cefeb0c4ca7fe0d3381aac8a734270_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn start_lobby() {\n    let mut client = common::setup();\n    client.send(1, \".n 1\");\n    client.send(1, \".m\");\n    client.send(2, \".n 2\");\n    client.send(2, \".j 1\");\n    client.send(1, \".s\");\n    client.read_all();\n    assert!(client\n        .last(1)\n        .contains(\"You are the THRUSTEE. Choose NOW..........\"));\n    assert!(client\n        .last(2)\n        .contains(\"You are a THRUSTER. waiting for a good THRUSTEE from 1; mmm baby!\"));\n"]], "pred": {"ppl": 5.134017467498779, "ppl_lower": 5.299077033996582, "ppl/lowercase_ppl": -1.019343724464222, "ppl/zlib": 0.007716455116796244, "Min_5.0% Prob": 10.280703961849213, "Min_10.0% Prob": 8.6455717086792, "Min_20.0% Prob": 6.463708482682705, "Min_30.0% Prob": 4.977595932781696, "Min_40.0% Prob": 3.9018301367759705, "Min_50.0% Prob": 3.2179388536347284, "Min_60.0% Prob": 2.7278929512525343}}
{"hexsha": "8a90f06ca17e46ceee5442f95de6c867ec26f2f8", "ext": "rs", "lang": "Rust", "content": "fn parse_baseframe( mut buf: & str, num_joints: Option< u64 > ) -> Result< ( & str, Vec< FrameJoint > ), & 'static str > {\n\n    let mut baseframe : Vec< FrameJoint > = vec![];\n    \n    match md5anim_baseframe_opening( buf ) {\n        nom::IResult::Done( i, o ) => {\n            buf = i;\n        },\n        _ => {\n            return Err( \"baseframe opening token not found\" )\n        },\n    }\n    match num_joints {\n        None => {\n            return Err( \"num joints not specified at point of baseframe parsing\" )\n        },\n        _ => {},\n    }\n    \n    let n = num_joints.unwrap();\n    let mut count = 0;\n    while count < n {\n        match peek_and_consume_comments( buf ) {\n            Some(x) => {\n                buf = x;\n                continue;\n            },\n            _ => {}\n        }\n        match md5anim_baseframe( buf ) {\n            nom::IResult::Done( i, mut o ) => {\n                buf = i;\n                o._index = count as u64; //set index\n                baseframe.push( o );\n            },\n            _ => {\n                return Err(\"bounds parse unsuccessful\")\n            },\n        }\n\n        count += 1;\n    }                \n\n    match peek_and_consume_comments( buf ) {\n        Some(x) => {\n            buf = x;\n        },\n        _ => {}\n    }\n\n    match md5anim_baseframe_closing( buf ) {\n        nom::IResult::Done( i, o ) => {\n            buf = i;\n        },\n        _ => {},\n    }\n\n    match peek_and_consume_comments( buf ) {\n        Some(x) => { buf = x; },\n        _ => {},\n    }\n\n    Ok( ( buf, baseframe ) )\n}", "item_id": 2, "repo": "clearlycloudy/e2", "file": "core/implement/file/md5anim_nom.rs", "last_update_at": "2019-11-16T21:20:44+00:00", "question_id": "8a90f06ca17e46ceee5442f95de6c867ec26f2f8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_baseframe( mut buf: & str, num_joints: Option< u64 > ) -> Result< ( & str, Vec< FrameJoint > ), & 'static str > {\n    let mut baseframe : Vec< FrameJoint > = vec![];\n    match md5anim_baseframe_opening( buf ) {\n        nom::IResult::Done( i, o ) => {\n            buf = i;\n        },\n        _ => {\n            return Err( \"baseframe opening token not found\" )\n        },\n    }\n    match num_joints {\n        None => {\n            return Err( \"num joints not specified at point of baseframe parsing\" )\n        },\n        _ => {},\n    }\n    let n = num_joints.unwrap();\n    let mut count = 0;\n    while count < n {\n        match peek_and_consume_comments( buf ) {\n            Some(x) => {\n                buf = x;\n                continue;\n            },\n            _ => {}\n        }\n        match md5anim_baseframe( buf ) {\n            nom::IResult::Done( i, mut o ) => {\n                buf = i;\n                o._index = count as u64; //set index\n                baseframe.push( o );\n            },\n            _ => {\n                return Err(\"bounds parse unsuccessful\")\n            },\n        }\n        count += 1;\n    }                \n    match peek_and_consume_comments( buf ) {\n        Some(x) => {\n            buf = x;\n        },\n        _ => {}\n    }\n    match md5anim_baseframe_closing( buf ) {\n        nom::IResult::Done( i, o ) => {\n            buf = i;\n        },\n        _ => {},\n    }\n    match peek_and_consume_comments( buf ) {\n        Some(x) => { buf = x; },\n        _ => {},\n    }\n    Ok( ( buf, baseframe ) )\n"]], "pred": {"ppl": 2.278188467025757, "ppl_lower": 2.434755563735962, "ppl/lowercase_ppl": -1.0807230243608774, "ppl/zlib": 0.0016272343777712593, "Min_5.0% Prob": 7.786423246065776, "Min_10.0% Prob": 5.810971061388652, "Min_20.0% Prob": 3.733496112921803, "Min_30.0% Prob": 2.6610193795171275, "Min_40.0% Prob": 2.037299279968456, "Min_50.0% Prob": 1.6380224994885824, "Min_60.0% Prob": 1.3720640494324958}}
{"hexsha": "c843c54f6a0f77e2fb96eb50cd973380d45b90c5", "ext": "rs", "lang": "Rust", "content": "pub fn spiral_matrix(size: u32) -> Vec<Vec<u32>> {\n    let size = size as usize;\n    if size == 0 {\n        return Vec::new();\n    } else if size == 1 {\n        return vec![vec![1; size]; size];\n    }\n    let mut spiral: Vec<Vec<u32>> = vec![vec![0; size]; size];\n\n    let mut i = 0;\n    let mut j = 0;\n    let mut val = 1;\n    let mut moving = State::MovingRight;\n\n    while spiral[i][j] == 0 {\n        spiral[i][j] = val;\n        val += 1;\n        match moving {\n            State::MovingRight => {\n                if j == size - 1 || spiral[i][j + 1] != 0 {\n                    i += 1;\n                    moving = State::MovieDown;\n                } else {\n                    j += 1;\n                }\n            }\n            State::MovieDown => {\n                if i == size - 1 || spiral[i + 1][j] != 0 {\n                    j -= 1;\n                    moving = State::MovingLeft;\n                } else {\n                    i += 1;\n                }\n            }\n            State::MovingLeft => {\n                println!(\"{:?}\", (i, j));\n                if j == 0 || spiral[i][j - 1] != 0 {\n                    i -= 1;\n                    moving = State::MovingUp\n                } else {\n                    j -= 1;\n                }\n            }\n            State::MovingUp => {\n                if i == 0 || spiral[i - 1][j] != 0 {\n                    j += 1;\n                    moving = State::MovingRight;\n                } else {\n                    i -= 1\n                }\n            }\n        }\n    }\n\n    spiral\n}", "item_id": 0, "repo": "Dimkar3000/exercism", "file": "rust/spiral-matrix/src/lib.rs", "last_update_at": "2019-11-09T09:44:41+00:00", "question_id": "c843c54f6a0f77e2fb96eb50cd973380d45b90c5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn spiral_matrix(size: u32) -> Vec<Vec<u32>> {\n    let size = size as usize;\n    if size == 0 {\n        return Vec::new();\n    } else if size == 1 {\n        return vec![vec![1; size]; size];\n    }\n    let mut spiral: Vec<Vec<u32>> = vec![vec![0; size]; size];\n    let mut i = 0;\n    let mut j = 0;\n    let mut val = 1;\n    let mut moving = State::MovingRight;\n    while spiral[i][j] == 0 {\n        spiral[i][j] = val;\n        val += 1;\n        match moving {\n            State::MovingRight => {\n                if j == size - 1 || spiral[i][j + 1] != 0 {\n                    i += 1;\n                    moving = State::MovieDown;\n                } else {\n                    j += 1;\n                }\n            }\n            State::MovieDown => {\n                if i == size - 1 || spiral[i + 1][j] != 0 {\n                    j -= 1;\n                    moving = State::MovingLeft;\n                } else {\n                    i += 1;\n                }\n            }\n            State::MovingLeft => {\n                println!(\"{:?}\", (i, j));\n                if j == 0 || spiral[i][j - 1] != 0 {\n                    i -= 1;\n                    moving = State::MovingUp\n                } else {\n                    j -= 1;\n                }\n            }\n            State::MovingUp => {\n                if i == 0 || spiral[i - 1][j] != 0 {\n                    j += 1;\n                    moving = State::MovingRight;\n                } else {\n                    i -= 1\n                }\n            }\n        }\n    }\n    spiral\n"]], "pred": {"ppl": 1.4197381734848022, "ppl_lower": 1.5257186889648438, "ppl/lowercase_ppl": -1.2054172780213386, "ppl/zlib": 0.0009056136169052502, "Min_5.0% Prob": 5.443679432074229, "Min_10.0% Prob": 3.1968065413335958, "Min_20.0% Prob": 1.7089161351323128, "Min_30.0% Prob": 1.1585241358778957, "Min_40.0% Prob": 0.873389909582329, "Min_50.0% Prob": 0.6999014361548083, "Min_60.0% Prob": 0.5837480175832752}}
{"hexsha": "159f6eeae51553bfec2097e8b9fa0cb56f76db0e", "ext": "rs", "lang": "Rust", "content": "fn coords_can_be_subtracted() {\n        let left = Coord::new(30, 40);\n        let right = Coord::new(10, 20);\n\n        assert_eq!(left - right, Coord::new(20, 20));\n    }", "item_id": 1, "repo": "mmou/embedded-graphics", "file": "embedded-graphics/src/coord.rs", "last_update_at": "2019-07-16T02:31:01+00:00", "question_id": "159f6eeae51553bfec2097e8b9fa0cb56f76db0e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn coords_can_be_subtracted() {\n        let left = Coord::new(30, 40);\n        let right = Coord::new(10, 20);\n        assert_eq!(left - right, Coord::new(20, 20));\n"]], "pred": {"ppl": 2.368201494216919, "ppl_lower": 2.8770811557769775, "ppl/lowercase_ppl": -1.2257725717571004, "ppl/zlib": 0.007837552762409064, "Min_5.0% Prob": 8.383080005645752, "Min_10.0% Prob": 6.033882754189627, "Min_20.0% Prob": 3.8996516380991255, "Min_30.0% Prob": 2.791362230073322, "Min_40.0% Prob": 2.166365729323749, "Min_50.0% Prob": 1.7171755285077803, "Min_60.0% Prob": 1.4478435918096115}}
{"hexsha": "4dc9d67aea24d51052b9f28b34b9f377263483ee", "ext": "rs", "lang": "Rust", "content": "fn test_as_number() {\n        // bytestring is a number\n        let num = as_number::<u64>(vec![b'1', b'2']).unwrap();\n        assert_eq!(num, 12);\n\n        // bytestring is not a number\n        let err = as_number::<u64>(vec![b' ', b'1', b'2']).unwrap_err();\n        assert_eq!(err, TcpTransportError::NumberParseError);\n    }", "item_id": 1, "repo": "numerodix/memcache.rs", "file": "src/tcp_transport/conversions.rs", "last_update_at": "2019-08-21T20:55:07+00:00", "question_id": "4dc9d67aea24d51052b9f28b34b9f377263483ee_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_as_number() {\n        // bytestring is a number\n        let num = as_number::<u64>(vec![b'1', b'2']).unwrap();\n        assert_eq!(num, 12);\n        // bytestring is not a number\n        let err = as_number::<u64>(vec![b' ', b'1', b'2']).unwrap_err();\n        assert_eq!(err, TcpTransportError::NumberParseError);\n"]], "pred": {"ppl": 2.8774166107177734, "ppl_lower": 3.497450351715088, "ppl/lowercase_ppl": -1.1846368294236127, "ppl/zlib": 0.006144726054802595, "Min_5.0% Prob": 7.823179721832275, "Min_10.0% Prob": 6.2092249610207295, "Min_20.0% Prob": 4.620071773943693, "Min_30.0% Prob": 3.374482831784657, "Min_40.0% Prob": 2.604554540299355, "Min_50.0% Prob": 2.1028618032144286, "Min_60.0% Prob": 1.7602888842598654}}
{"hexsha": "5cb84beea124480ed2fce88c87e31da1965ff14a", "ext": "rs", "lang": "Rust", "content": "pub fn fetch(instr_mem: &dyn MemoryAccess, pc: u32) -> Result<(u32, u32), FetchError> {\n    alignment_check(pc)?;\n\n    let instr = instr_mem.read_u32(pc as usize)?;\n    let next_pc = pc + 4;\n    Ok((instr, next_pc))\n}", "item_id": 0, "repo": "tomoyuki-nakabayashi/Rustemu86", "file": "arch/riscv/src/fetch.rs", "last_update_at": "2019-02-07T05:27:30+00:00", "question_id": "5cb84beea124480ed2fce88c87e31da1965ff14a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn fetch(instr_mem: &dyn MemoryAccess, pc: u32) -> Result<(u32, u32), FetchError> {\n    alignment_check(pc)?;\n    let instr = instr_mem.read_u32(pc as usize)?;\n    let next_pc = pc + 4;\n    Ok((instr, next_pc))\n"]], "pred": {"ppl": 3.1069087982177734, "ppl_lower": 4.39989709854126, "ppl/lowercase_ppl": -1.3069373664076411, "ppl/zlib": 0.0068704744020167425, "Min_5.0% Prob": 10.670345783233643, "Min_10.0% Prob": 7.346037944157918, "Min_20.0% Prob": 4.7061169147491455, "Min_30.0% Prob": 3.5148831946509227, "Min_40.0% Prob": 2.7327192794335518, "Min_50.0% Prob": 2.229138861099879, "Min_60.0% Prob": 1.8987123021169712}}
{"hexsha": "99ec1b268c51c3421dd383fb23681b4c110262f0", "ext": "rs", "lang": "Rust", "content": "fn make_pocket_enum_declaration(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R, arg3 : Self::R, arg4 : Self::R, arg5 : Self::R) -> (State, Self::R) {\n        let s = State::next(s, &[&arg0, &arg1, &arg2, &arg3, &arg4, &arg5]);\n        let r = Self::R::make_pocket_enum_declaration(&s, arg0, arg1, arg2, arg3, arg4, arg5);\n        (s, r)\n    }", "item_id": 167, "repo": "jeffomatic/hhvm", "file": "hphp/hack/src/parser/syntax_smart_constructors_generated.rs", "last_update_at": "2019-07-21T09:08:35+00:00", "question_id": "99ec1b268c51c3421dd383fb23681b4c110262f0_167", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn make_pocket_enum_declaration(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R, arg3 : Self::R, arg4 : Self::R, arg5 : Self::R) -> (State, Self::R) {\n        let s = State::next(s, &[&arg0, &arg1, &arg2, &arg3, &arg4, &arg5]);\n        let r = Self::R::make_pocket_enum_declaration(&s, arg0, arg1, arg2, arg3, arg4, arg5);\n        (s, r)\n"]], "pred": {"ppl": 2.5285346508026123, "ppl_lower": 2.757728099822998, "ppl/lowercase_ppl": -1.0935354750451727, "ppl/zlib": 0.005488993760582069, "Min_5.0% Prob": 8.064146654946464, "Min_10.0% Prob": 6.344713226954142, "Min_20.0% Prob": 4.24864284992218, "Min_30.0% Prob": 2.9923004002674767, "Min_40.0% Prob": 2.3117399232797937, "Min_50.0% Prob": 1.8489669025815152, "Min_60.0% Prob": 1.5508599953179287}}
{"hexsha": "203f7b00ab1186a5ef888404f0c41f06f9eeb3d6", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn xdg_popup_configure(mut data: *mut libc::c_void,\n                                         mut xdg_popup: *mut xdg_popup,\n                                         mut x: int32_t, mut y: int32_t,\n                                         mut width_0: int32_t,\n                                         mut height_0: int32_t) {\n    _wlr_log(WLR_DEBUG,\n             b\"[%s:%d] Popup configured %dx%d@%d,%d\\x00\" as *const u8 as\n                 *const libc::c_char,\n             b\"../examples/layer-shell.c\\x00\" as *const u8 as\n                 *const libc::c_char, 181i32, width_0, height_0, x, y);\n    popup_width = width_0 as uint32_t;\n    popup_height = height_0 as uint32_t;\n    if !popup_egl_window.is_null() {\n        wl_egl_window_resize(popup_egl_window, width_0, height_0, 0i32, 0i32);\n    };\n}", "item_id": 14, "repo": "RoastVeg/wlrusts", "file": "src/examples/layer_shell.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "203f7b00ab1186a5ef888404f0c41f06f9eeb3d6_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe extern \"C\" fn xdg_popup_configure(mut data: *mut libc::c_void,\n                                         mut xdg_popup: *mut xdg_popup,\n                                         mut x: int32_t, mut y: int32_t,\n                                         mut width_0: int32_t,\n                                         mut height_0: int32_t) {\n    _wlr_log(WLR_DEBUG,\n             b\"[%s:%d] Popup configured %dx%d@%d,%d\\x00\" as *const u8 as\n                 *const libc::c_char,\n             b\"../examples/layer-shell.c\\x00\" as *const u8 as\n                 *const libc::c_char, 181i32, width_0, height_0, x, y);\n    popup_width = width_0 as uint32_t;\n    popup_height = height_0 as uint32_t;\n    if !popup_egl_window.is_null() {\n        wl_egl_window_resize(popup_egl_window, width_0, height_0, 0i32, 0i32);\n    };\n"]], "pred": {"ppl": 1.7183294296264648, "ppl_lower": 1.8342585563659668, "ppl/lowercase_ppl": -1.1206012339525402, "ppl/zlib": 0.0017077367728702253, "Min_5.0% Prob": 6.365888468424479, "Min_10.0% Prob": 4.414192092418671, "Min_20.0% Prob": 2.6379848182201386, "Min_30.0% Prob": 1.8071678924891683, "Min_40.0% Prob": 1.3527770454048618, "Min_50.0% Prob": 1.0856017143841807, "Min_60.0% Prob": 0.906091324659579}}
{"hexsha": "4bcd4416d1f71112f228d505492b8211eaceecfb", "ext": "rs", "lang": "Rust", "content": "fn json_str_vec_to_yaml() {\n        let input = serde_json::to_value(&vec![\"foo\"]);\n        let output = serde_yaml::Value::Array(vec![serde_yaml::Value::String(\"foo\".to_owned())]);\n        assert_eq!(to_yaml(&input).unwrap(), output);\n    }", "item_id": 0, "repo": "softprops/jamal", "file": "src/lib.rs", "last_update_at": "2019-08-10T14:26:07+00:00", "question_id": "4bcd4416d1f71112f228d505492b8211eaceecfb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn json_str_vec_to_yaml() {\n        let input = serde_json::to_value(&vec![\"foo\"]);\n        let output = serde_yaml::Value::Array(vec![serde_yaml::Value::String(\"foo\".to_owned())]);\n        assert_eq!(to_yaml(&input).unwrap(), output);\n"]], "pred": {"ppl": 2.8002140522003174, "ppl_lower": 4.004116058349609, "ppl/lowercase_ppl": -1.3473132198951205, "ppl/zlib": 0.0065585723660740005, "Min_5.0% Prob": 7.358188509941101, "Min_10.0% Prob": 5.9726327657699585, "Min_20.0% Prob": 4.343340292572975, "Min_30.0% Prob": 3.272373797992865, "Min_40.0% Prob": 2.5133066285740244, "Min_50.0% Prob": 2.0626212929080174, "Min_60.0% Prob": 1.7387474696246945}}
{"hexsha": "e9c1ce20b302b0326aedf17d9dd8d687e7361261", "ext": "rs", "lang": "Rust", "content": "unsafe fn mi_realloc_zero_aligned_at(mut p: *mut c_void, mut newsize: usize,\n                                     mut alignment: usize, mut offset: usize,\n                                     mut zero: bool) -> *mut c_void {\n    if alignment > 0 {\n        0\n    } else {\n        _mi_assert_fail(\"alignment > 0\", \"src/alloc-aligned.c\", 90,\n                        \"mi_realloc_zero_aligned_at\")\n    }\n    if alignment <= std::mem::size_of::<usize>() {\n        return _mi_realloc_zero(p, newsize, zero != 0);\n    }\n    if p.is_null() {\n        return mi_malloc_zero_aligned_at(newsize, alignment, offset,\n                                         zero != 0);\n    }\n    let mut size = mi_usable_size(p);\n    if newsize <= size && newsize >= (size - (size / 2)) &&\n           (((p as usize) + offset) % alignment) == 0 {\n        return p;\n    } else {\n        let mut newp = mi_malloc_aligned_at(newsize, alignment, offset);\n        if !newp.is_null() {\n            if zero != 0 != 0 && newsize > size {\n                // also set last word in the previous allocation to zero to ensure any padding is zero-initialized\n                let mut start =\n                    if size >= std::mem::size_of::<isize>() {\n                        size - std::mem::size_of::<isize>()\n                    } else { 0 }; // only free if successful\n                memset((newp as *mut u8).offset(start), 0,\n                       newsize -\n                           start); // use offset of previous allocation (p can be NULL)\n            }\n            memcpy(newp, p as *const c_void,\n                   if newsize > size { size } else { newsize });\n            mi_free(p);\n        }\n        return newp;\n    };\n}", "item_id": 3, "repo": "rusch95/mimalloc-rs", "file": "mimalloc-sys/rust_impl/citrus/alloc-aligned.rs", "last_update_at": "2019-10-20T05:44:39+00:00", "question_id": "e9c1ce20b302b0326aedf17d9dd8d687e7361261_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn mi_realloc_zero_aligned_at(mut p: *mut c_void, mut newsize: usize,\n                                     mut alignment: usize, mut offset: usize,\n                                     mut zero: bool) -> *mut c_void {\n    if alignment > 0 {\n        0\n    } else {\n        _mi_assert_fail(\"alignment > 0\", \"src/alloc-aligned.c\", 90,\n                        \"mi_realloc_zero_aligned_at\")\n    }\n    if alignment <= std::mem::size_of::<usize>() {\n        return _mi_realloc_zero(p, newsize, zero != 0);\n    }\n    if p.is_null() {\n        return mi_malloc_zero_aligned_at(newsize, alignment, offset,\n                                         zero != 0);\n    }\n    let mut size = mi_usable_size(p);\n    if newsize <= size && newsize >= (size - (size / 2)) &&\n           (((p as usize) + offset) % alignment) == 0 {\n        return p;\n    } else {\n        let mut newp = mi_malloc_aligned_at(newsize, alignment, offset);\n        if !newp.is_null() {\n            if zero != 0 != 0 && newsize > size {\n                // also set last word in the previous allocation to zero to ensure any padding is zero-initialized\n                let mut start =\n                    if size >= std::mem::size_of::<isize>() {\n                        size - std::mem::size_of::<isize>()\n                    } else { 0 }; // only free if successful\n                memset((newp as *mut u8).offset(start), 0,\n                       newsize -\n                           start); // use offset of previous allocation (p can be NULL)\n            }\n            memcpy(newp, p as *const c_void,\n                   if newsize > size { size } else { newsize });\n            mi_free(p);\n        }\n        return newp;\n    };\n"]], "pred": {"ppl": 2.3672847747802734, "ppl_lower": 2.3591034412384033, "ppl/lowercase_ppl": -0.9959825816997881, "ppl/zlib": 0.0014883309736130291, "Min_5.0% Prob": 6.523493031660716, "Min_10.0% Prob": 5.016057437779952, "Min_20.0% Prob": 3.561746217987754, "Min_30.0% Prob": 2.673709252136666, "Min_40.0% Prob": 2.1024485936566215, "Min_50.0% Prob": 1.7101387233738918, "Min_60.0% Prob": 1.4333096460554513}}
{"hexsha": "28be31fdab926ee2f934b2f9d1a00757e8b486b4", "ext": "rs", "lang": "Rust", "content": "fn tear(\n    input: image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>>,\n    rng: &mut rand_xoshiro::Xoshiro256StarStar,\n    max_times: u32,\n    max_thickness: u32,\n    max_amount: u32,\n    range: u32,\n) -> image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>> {\n    println!(\"Tear FX\");\n\n    let mut output = input.clone();\n    let (width, height) = input.dimensions();\n    let range_begin = if height - range == 0 { 0 } else { rng.gen_range(0, height - range) };\n\n    let shift_times = (rng.gen::<f64>() * max_times as f64).floor() as u64;\n    for _ in 0..shift_times {\n        let begin_y = rng.gen_range(0, range) + range_begin;\n        let thickness = rng.gen_range(0, max_thickness);\n        let amount = rng.gen_range(0, max_amount);\n        let direction = rng.gen_range(0, 2);\n\n        if direction == 0 { // ->\n            for x in 0..amount { // \u7aef\u3092\u30df\u30e9\u30fc\u30ea\u30f3\u30b0\n                let max_y = cmp::min(height, begin_y + thickness);\n                for y in begin_y..max_y {\n                    output.put_pixel(x, y, *input.get_pixel(amount - x, y));\n                }\n            }\n            for x in amount..width {\n                let max_y = cmp::min(height, begin_y + thickness);\n                for y in begin_y..max_y {\n                    output.put_pixel(x, y, *input.get_pixel(x - amount, y));\n                }\n            }\n        } else { // <-\n            for x in (width - amount)..width { // \u7aef\u3092\u30df\u30e9\u30fc\u30ea\u30f3\u30b0\n                let max_y = cmp::min(height, begin_y + thickness);\n                for y in begin_y..max_y {\n                    output.put_pixel(x, y, *input.get_pixel(width - (x - (width - amount)) - 1, y));\n                }\n            }\n            for x in 0..(width - amount) {\n                let max_y = cmp::min(height, begin_y + thickness);\n                for y in begin_y..max_y {\n                    output.put_pixel(x, y, *input.get_pixel(x + amount, y));\n                }\n            }\n        }\n    }\n\n    output\n}", "item_id": 5, "repo": "syuilo/glitch-studio-rs", "file": "src/main.rs", "last_update_at": "2019-09-16T23:30:56+00:00", "question_id": "28be31fdab926ee2f934b2f9d1a00757e8b486b4_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn tear(\n    input: image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>>,\n    rng: &mut rand_xoshiro::Xoshiro256StarStar,\n    max_times: u32,\n    max_thickness: u32,\n    max_amount: u32,\n    range: u32,\n) -> image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>> {\n    println!(\"Tear FX\");\n    let mut output = input.clone();\n    let (width, height) = input.dimensions();\n    let range_begin = if height - range == 0 { 0 } else { rng.gen_range(0, height - range) };\n    let shift_times = (rng.gen::<f64>() * max_times as f64).floor() as u64;\n    for _ in 0..shift_times {\n        let begin_y = rng.gen_range(0, range) + range_begin;\n        let thickness = rng.gen_range(0, max_thickness);\n        let amount = rng.gen_range(0, max_amount);\n        let direction = rng.gen_range(0, 2);\n        if direction == 0 { // ->\n            for x in 0..amount { // \u7aef\u3092\u30df\u30e9\u30fc\u30ea\u30f3\u30b0\n                let max_y = cmp::min(height, begin_y + thickness);\n                for y in begin_y..max_y {\n                    output.put_pixel(x, y, *input.get_pixel(amount - x, y));\n                }\n            }\n            for x in amount..width {\n                let max_y = cmp::min(height, begin_y + thickness);\n                for y in begin_y..max_y {\n                    output.put_pixel(x, y, *input.get_pixel(x - amount, y));\n                }\n            }\n        } else { // <-\n            for x in (width - amount)..width { // \u7aef\u3092\u30df\u30e9\u30fc\u30ea\u30f3\u30b0\n                let max_y = cmp::min(height, begin_y + thickness);\n                for y in begin_y..max_y {\n                    output.put_pixel(x, y, *input.get_pixel(width - (x - (width - amount)) - 1, y));\n                }\n            }\n            for x in 0..(width - amount) {\n                let max_y = cmp::min(height, begin_y + thickness);\n                for y in begin_y..max_y {\n                    output.put_pixel(x, y, *input.get_pixel(x + amount, y));\n                }\n            }\n        }\n    }\n    output\n"]], "pred": {"ppl": 1.6428078413009644, "ppl_lower": 1.7270866632461548, "ppl/lowercase_ppl": -1.1007824537954831, "ppl/zlib": 0.0008724198176110746, "Min_5.0% Prob": 5.920992437530966, "Min_10.0% Prob": 3.9971361885900083, "Min_20.0% Prob": 2.3742643523475397, "Min_30.0% Prob": 1.636293618975637, "Min_40.0% Prob": 1.2399439318408174, "Min_50.0% Prob": 0.992111412773408, "Min_60.0% Prob": 0.8279735224913076}}
{"hexsha": "caae2b7a6aa584af89eaa322d7e3011277b83992", "ext": "rs", "lang": "Rust", "content": "extern \"C\" fn read_data_safe(ptr: *mut Pixel, len: usize) {\n    println!(\"Reading safely from instance {:?}\", *INSTANCE);\n\n    let data: Vec<Pixel> = INSTANCE.rx\n        .iter()\n        .take(len)\n        .collect();\n\n    let ptr = data.as_ptr();\n\n}", "item_id": 3, "repo": "borismarin/microscopio", "file": "arch/threaded/server/src/lib.rs", "last_update_at": "2019-07-25T17:41:34+00:00", "question_id": "caae2b7a6aa584af89eaa322d7e3011277b83992_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["extern \"C\" fn read_data_safe(ptr: *mut Pixel, len: usize) {\n    println!(\"Reading safely from instance {:?}\", *INSTANCE);\n    let data: Vec<Pixel> = INSTANCE.rx\n        .iter()\n        .take(len)\n        .collect();\n    let ptr = data.as_ptr();\n"]], "pred": {"ppl": 6.4967522621154785, "ppl_lower": 8.689014434814453, "ppl/lowercase_ppl": -1.1553768749885005, "ppl/zlib": 0.010396124444731725, "Min_5.0% Prob": 11.31271743774414, "Min_10.0% Prob": 9.238383829593658, "Min_20.0% Prob": 6.793924780452953, "Min_30.0% Prob": 5.353207973333506, "Min_40.0% Prob": 4.380680409499577, "Min_50.0% Prob": 3.635607426816767, "Min_60.0% Prob": 3.1345171083051424}}
{"hexsha": "8ba64be453af66291a90197773b7ec8d6ae86ce4", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    println!(\"Starting Queue\");\n    let mut head = Node {\n        name: \"head\".to_string(),\n        next: None,\n    };\n\n    loop {\n        let mut input = String::new();\n        println!(\"Next action please\");\n        stdin().read_line(&mut input);\n\n        let cloned = input.clone();\n        let items = cloned.split(' ');\n        let mut cmds: Vec<&str> = items.collect();\n        let command = cmds[0].trim_end();\n\n        match command {\n            command if command == \"push\" => {\n                let name = cmds[1].trim_end().to_string();\n                head.push(name);\n            }\n            command if command == \"pop\" => match head.clone().pop() {\n                None => head.next = None,\n                Some(ref mut node) => head.next = Some(Box::new(node.clone())),\n            },\n            command if command == \"print\" => {\n                head.print(0);\n            }\n            command if command == \"count\" => {\n                head.count(0);\n            }\n            command if command == \"quit\" => {\n                println!(\"Good Bye\");\n                break;\n            }\n            _ => println!(\"Invalid command\"),\n        }\n    }\n    drop(head);\n}", "item_id": 0, "repo": "MatthewFrisby/Rust-Data-Structures", "file": "Queue with Linked List/Queue_with_LL.rs", "last_update_at": "2019-07-21T20:10:35+00:00", "question_id": "8ba64be453af66291a90197773b7ec8d6ae86ce4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    println!(\"Starting Queue\");\n    let mut head = Node {\n        name: \"head\".to_string(),\n        next: None,\n    };\n    loop {\n        let mut input = String::new();\n        println!(\"Next action please\");\n        stdin().read_line(&mut input);\n        let cloned = input.clone();\n        let items = cloned.split(' ');\n        let mut cmds: Vec<&str> = items.collect();\n        let command = cmds[0].trim_end();\n        match command {\n            command if command == \"push\" => {\n                let name = cmds[1].trim_end().to_string();\n                head.push(name);\n            }\n            command if command == \"pop\" => match head.clone().pop() {\n                None => head.next = None,\n                Some(ref mut node) => head.next = Some(Box::new(node.clone())),\n            },\n            command if command == \"print\" => {\n                head.print(0);\n            }\n            command if command == \"count\" => {\n                head.count(0);\n            }\n            command if command == \"quit\" => {\n                println!(\"Good Bye\");\n                break;\n            }\n            _ => println!(\"Invalid command\"),\n        }\n    }\n    drop(head);\n"]], "pred": {"ppl": 2.2171316146850586, "ppl_lower": 2.4871089458465576, "ppl/lowercase_ppl": -1.1443162672718843, "ppl/zlib": 0.0018430886458118783, "Min_5.0% Prob": 6.804688632488251, "Min_10.0% Prob": 5.121786504983902, "Min_20.0% Prob": 3.4157727137207985, "Min_30.0% Prob": 2.498878004010191, "Min_40.0% Prob": 1.9591629606808802, "Min_50.0% Prob": 1.5805632134002667, "Min_60.0% Prob": 1.3264284300493057}}
{"hexsha": "3dcb4abc314f4804e5cb7dd717e5662dc3d48f57", "ext": "rs", "lang": "Rust", "content": "fn delete_user() {\n    let client = Graph::new(\"ACCESS_TOKEN\");\n\n    let response = client.v1().user(USER_ID).delete_user().send().unwrap();\n\n    println!(\"{:#?}\", response);\n}", "item_id": 5, "repo": "DevLazio/graph-rs", "file": "examples/users.rs", "last_update_at": "2019-04-14T21:43:36+00:00", "question_id": "3dcb4abc314f4804e5cb7dd717e5662dc3d48f57_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn delete_user() {\n    let client = Graph::new(\"ACCESS_TOKEN\");\n    let response = client.v1().user(USER_ID).delete_user().send().unwrap();\n    println!(\"{:#?}\", response);\n"]], "pred": {"ppl": 2.5195066928863525, "ppl_lower": 3.397904872894287, "ppl/lowercase_ppl": -1.3236747511984996, "ppl/zlib": 0.006647936155175111, "Min_5.0% Prob": 7.5748826662699384, "Min_10.0% Prob": 5.61562975247701, "Min_20.0% Prob": 3.6737396816412606, "Min_30.0% Prob": 2.7363977895842657, "Min_40.0% Prob": 2.1881925178070865, "Min_50.0% Prob": 1.8166646301746368, "Min_60.0% Prob": 1.531274013635185}}
{"hexsha": "75df2846d4cbf5d8886a55eb69ef935f8b37a1d1", "ext": "rs", "lang": "Rust", "content": "pub fn wif_compressed(priv_key: &SecretKey) -> WIFCompressed {\n    let decoded = base16::decode(priv_key.to_string().as_bytes()).unwrap();\n    let mut wc = Vec::with_capacity(decoded.len()+1);\n    wc.extend_from_slice(&decoded);\n    wc.push(constants::BITCOIN_WIF_COMPRESSED_SUFFIX);\n    encode_base58_check(constants::BITCOIN_PRIVATE_KEY_WIF_VERSION_PREFIX, &wc)\n}", "item_id": 2, "repo": "michaelsdunn1/bitcoin", "file": "src/keys.rs", "last_update_at": "2019-01-17T15:55:24+00:00", "question_id": "75df2846d4cbf5d8886a55eb69ef935f8b37a1d1_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn wif_compressed(priv_key: &SecretKey) -> WIFCompressed {\n    let decoded = base16::decode(priv_key.to_string().as_bytes()).unwrap();\n    let mut wc = Vec::with_capacity(decoded.len()+1);\n    wc.extend_from_slice(&decoded);\n    wc.push(constants::BITCOIN_WIF_COMPRESSED_SUFFIX);\n    encode_base58_check(constants::BITCOIN_PRIVATE_KEY_WIF_VERSION_PREFIX, &wc)\n"]], "pred": {"ppl": 3.1006078720092773, "ppl_lower": 3.761469841003418, "ppl/lowercase_ppl": -1.1707422471811015, "ppl/zlib": 0.0043691049421364465, "Min_5.0% Prob": 8.06933661869594, "Min_10.0% Prob": 6.778852156230381, "Min_20.0% Prob": 4.730124077626637, "Min_30.0% Prob": 3.505232815132585, "Min_40.0% Prob": 2.7570194330131796, "Min_50.0% Prob": 2.234432618237204, "Min_60.0% Prob": 1.8872895830765712}}
{"hexsha": "99ec1b268c51c3421dd383fb23681b4c110262f0", "ext": "rs", "lang": "Rust", "content": "fn make_braced_expression(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R) -> (State, Self::R) {\n        let s = State::next(s, &[&arg0, &arg1, &arg2]);\n        let r = Self::R::make_braced_expression(&s, arg0, arg1, arg2);\n        (s, r)\n    }", "item_id": 102, "repo": "jeffomatic/hhvm", "file": "hphp/hack/src/parser/syntax_smart_constructors_generated.rs", "last_update_at": "2019-07-21T09:08:35+00:00", "question_id": "99ec1b268c51c3421dd383fb23681b4c110262f0_102", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn make_braced_expression(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R) -> (State, Self::R) {\n        let s = State::next(s, &[&arg0, &arg1, &arg2]);\n        let r = Self::R::make_braced_expression(&s, arg0, arg1, arg2);\n        (s, r)\n"]], "pred": {"ppl": 3.0012993812561035, "ppl_lower": 3.364853620529175, "ppl/lowercase_ppl": -1.1040349631603155, "ppl/zlib": 0.007739755788598714, "Min_5.0% Prob": 7.782884788513184, "Min_10.0% Prob": 6.399026346206665, "Min_20.0% Prob": 4.632626749220348, "Min_30.0% Prob": 3.4891186529590237, "Min_40.0% Prob": 2.6958557005439485, "Min_50.0% Prob": 2.1745330872681907, "Min_60.0% Prob": 1.8405432367017345}}
{"hexsha": "90bf85eca0ffa7db9371046e8587a54f62c4813c", "ext": "rs", "lang": "Rust", "content": "pub fn get_random_peers(\n    conn: &Connection,\n    count: u32,\n    expired_at_ms: u64,\n) -> DBResult<Vec<PeerId>> {\n    // random select peers that we have connect to recently.\n    let mut stmt = conn.prepare(\n        \"SELECT peer_id FROM peer_info \n                                WHERE ban_time_secs < strftime('%s','now') \n                                AND last_connected_at_secs > :time \n                                ORDER BY RANDOM() LIMIT :count\",\n    )?;\n    let rows = stmt.query_map_named(\n        &[\n            (\":count\", &count),\n            (\":time\", &millis_to_secs(expired_at_ms)),\n        ],\n        |row| Ok(PeerId::from_bytes(row.get(0)?).expect(\"parse peer_id\")),\n    )?;\n    rows.collect::<Result<Vec<_>, _>>().map_err(Into::into)\n}", "item_id": 1, "repo": "nervoscommunity/ckb-miner-opt", "file": "network/src/peer_store/sqlite/db.rs", "last_update_at": "2019-07-05T05:50:43+00:00", "question_id": "90bf85eca0ffa7db9371046e8587a54f62c4813c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_random_peers(\n    conn: &Connection,\n    count: u32,\n    expired_at_ms: u64,\n) -> DBResult<Vec<PeerId>> {\n    // random select peers that we have connect to recently.\n    let mut stmt = conn.prepare(\n        \"SELECT peer_id FROM peer_info \n                                WHERE ban_time_secs < strftime('%s','now') \n                                AND last_connected_at_secs > :time \n                                ORDER BY RANDOM() LIMIT :count\",\n    )?;\n    let rows = stmt.query_map_named(\n        &[\n            (\":count\", &count),\n            (\":time\", &millis_to_secs(expired_at_ms)),\n        ],\n        |row| Ok(PeerId::from_bytes(row.get(0)?).expect(\"parse peer_id\")),\n    )?;\n    rows.collect::<Result<Vec<_>, _>>().map_err(Into::into)\n"]], "pred": {"ppl": 2.5178894996643066, "ppl_lower": 3.257979154586792, "ppl/lowercase_ppl": -1.279055866560124, "ppl/zlib": 0.002193399169812236, "Min_5.0% Prob": 7.29596479733785, "Min_10.0% Prob": 5.379758243560791, "Min_20.0% Prob": 3.7408345984477624, "Min_30.0% Prob": 2.8463294992321417, "Min_40.0% Prob": 2.2497318524355983, "Min_50.0% Prob": 1.8301885296823457, "Min_60.0% Prob": 1.5411645422987883}}
{"hexsha": "3d9c204ab5e87806b487b1e18376ede4b321b8a6", "ext": "rs", "lang": "Rust", "content": "pub fn find_or_create_venv(\n    cfg_vers: &Version,\n    pypackages_dir: &Path,\n    pyflow_dir: &Path,\n    dep_cache_path: &Path,\n) -> (PathBuf, Version) {\n    let venvs = find_venvs(pypackages_dir);\n    // The version's explicitly specified; check if an environment for that version\n    let compatible_venvs: Vec<&(u32, u32)> = venvs\n        .iter()\n        .filter(|(ma, mi)| cfg_vers.major == Some(*ma) && cfg_vers.minor == Some(*mi))\n        .collect();\n\n    let vers_path;\n    let py_vers;\n    match compatible_venvs.len() {\n        0 => {\n            let vers =\n                py_versions::create_venv(cfg_vers, pypackages_dir, pyflow_dir, dep_cache_path);\n            vers_path = pypackages_dir.join(vers.to_string_med());\n            py_vers = Version::new_opt(vers.major, vers.minor, None); // Don't include patch.\n        }\n        1 => {\n            vers_path = pypackages_dir.join(&format!(\n                \"{}.{}\",\n                compatible_venvs[0].0, compatible_venvs[0].1\n            ));\n            py_vers = Version::new_short(compatible_venvs[0].0, compatible_venvs[0].1);\n        }\n        _ => {\n            abort(\n                // todo: Handle this, eg by letting the user pick the one to use?\n                \"Multiple compatible Python environments found\n                for this project.\",\n            )\n        }\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        (vers_path, py_vers)\n    }\n\n    #[cfg(target_os = \"linux\")]\n    {\n        let vers_path = fs::canonicalize(vers_path);\n        let vers_path = match vers_path {\n            Ok(path) => path,\n            Err(error) => {\n                abort(&format!(\n                    \"Problem converting path to absolute path: {:?}\",\n                    error\n                ));\n                unreachable!()\n            }\n        };\n        (vers_path, py_vers)\n    }\n\n    #[cfg(target_os = \"macos\")]\n    {\n        let vers_path = fs::canonicalize(vers_path);\n        let vers_path = match vers_path {\n            Ok(path) => path,\n            Err(error) => abort(&format!(\n                \"Problem converting path to absolute path: {:?}\",\n                error\n            )),\n        };\n        (vers_path, py_vers)\n    }\n}", "item_id": 9, "repo": "sthagen/David-OConnor-pyflow", "file": "src/util/mod.rs", "last_update_at": "2019-09-11T09:22:37+00:00", "question_id": "3d9c204ab5e87806b487b1e18376ede4b321b8a6_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn find_or_create_venv(\n    cfg_vers: &Version,\n    pypackages_dir: &Path,\n    pyflow_dir: &Path,\n    dep_cache_path: &Path,\n) -> (PathBuf, Version) {\n    let venvs = find_venvs(pypackages_dir);\n    // The version's explicitly specified; check if an environment for that version\n    let compatible_venvs: Vec<&(u32, u32)> = venvs\n        .iter()\n        .filter(|(ma, mi)| cfg_vers.major == Some(*ma) && cfg_vers.minor == Some(*mi))\n        .collect();\n    let vers_path;\n    let py_vers;\n    match compatible_venvs.len() {\n        0 => {\n            let vers =\n                py_versions::create_venv(cfg_vers, pypackages_dir, pyflow_dir, dep_cache_path);\n            vers_path = pypackages_dir.join(vers.to_string_med());\n            py_vers = Version::new_opt(vers.major, vers.minor, None); // Don't include patch.\n        }\n        1 => {\n            vers_path = pypackages_dir.join(&format!(\n                \"{}.{}\",\n                compatible_venvs[0].0, compatible_venvs[0].1\n            ));\n            py_vers = Version::new_short(compatible_venvs[0].0, compatible_venvs[0].1);\n        }\n        _ => {\n            abort(\n                // todo: Handle this, eg by letting the user pick the one to use?\n                \"Multiple compatible Python environments found\n                for this project.\",\n            )\n        }\n    }\n    #[cfg(target_os = \"windows\")]\n    {\n        (vers_path, py_vers)\n    }\n    #[cfg(target_os = \"linux\")]\n    {\n        let vers_path = fs::canonicalize(vers_path);\n        let vers_path = match vers_path {\n            Ok(path) => path,\n            Err(error) => {\n                abort(&format!(\n                    \"Problem converting path to absolute path: {:?}\",\n                    error\n                ));\n                unreachable!()\n            }\n        };\n        (vers_path, py_vers)\n    }\n    #[cfg(target_os = \"macos\")]\n    {\n        let vers_path = fs::canonicalize(vers_path);\n        let vers_path = match vers_path {\n            Ok(path) => path,\n            Err(error) => abort(&format!(\n                \"Problem converting path to absolute path: {:?}\",\n                error\n            )),\n        };\n        (vers_path, py_vers)\n    }\n"]], "pred": {"ppl": 2.209129810333252, "ppl_lower": 2.338733673095703, "ppl/lowercase_ppl": -1.071929125632622, "ppl/zlib": 0.0010857516260396713, "Min_5.0% Prob": 7.0719638712265915, "Min_10.0% Prob": 5.435719781062183, "Min_20.0% Prob": 3.5869383540223625, "Min_30.0% Prob": 2.582260250314778, "Min_40.0% Prob": 1.969616724348767, "Min_50.0% Prob": 1.5851924713711933, "Min_60.0% Prob": 1.3230784290816298}}
{"hexsha": "d025ee16b7b0876b786f6337c60abdfc0ac61309", "ext": "rs", "lang": "Rust", "content": "pub fn send(config: &ServerSettings, message: &String) -> SendResult {\n    let mut socket = Socket::new(Protocol::Req).unwrap();\n    let mut endpoint = socket.connect(&config.url[..]).unwrap();\n    let mut reply = String::new();\n\n    debug!(\"send.socket.write_all: {}\", message);\n\n    socket.write_all(message.as_bytes())\n        .map_err(|err| { error!(\"send.socket.write_all: {}\", err); err })\n        .and_then(|_| {\n            socket.read_to_string(&mut reply)\n                .map_err(|err| { error!(\"send.socket.read_to_string: {}\", err); err })\n        })\n        .map_err(|err| {\n            let _ = endpoint.shutdown()\n                .map_err(|err| error!(\"send.endpoint.shutdown: {}\", err) );\n            err\n        })?;\n\n    debug!(\"send.reply: {}\", reply);\n\n    let _ = endpoint.shutdown()\n        .map_err(|err| error!(\"send.endpoint.shutdown: {}\", err) );\n    return Ok(reply);\n}", "item_id": 0, "repo": "irony-rust/dots", "file": "lib/src/protocols/reqrep.rs", "last_update_at": "2019-02-26T07:28:48+00:00", "question_id": "d025ee16b7b0876b786f6337c60abdfc0ac61309_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn send(config: &ServerSettings, message: &String) -> SendResult {\n    let mut socket = Socket::new(Protocol::Req).unwrap();\n    let mut endpoint = socket.connect(&config.url[..]).unwrap();\n    let mut reply = String::new();\n    debug!(\"send.socket.write_all: {}\", message);\n    socket.write_all(message.as_bytes())\n        .map_err(|err| { error!(\"send.socket.write_all: {}\", err); err })\n        .and_then(|_| {\n            socket.read_to_string(&mut reply)\n                .map_err(|err| { error!(\"send.socket.read_to_string: {}\", err); err })\n        })\n        .map_err(|err| {\n            let _ = endpoint.shutdown()\n                .map_err(|err| error!(\"send.endpoint.shutdown: {}\", err) );\n            err\n        })?;\n    debug!(\"send.reply: {}\", reply);\n    let _ = endpoint.shutdown()\n        .map_err(|err| error!(\"send.endpoint.shutdown: {}\", err) );\n    return Ok(reply);\n"]], "pred": {"ppl": 2.1560845375061035, "ppl_lower": 2.44675612449646, "ppl/lowercase_ppl": -1.164610522046254, "ppl/zlib": 0.002307188776648962, "Min_5.0% Prob": 6.5571010793958395, "Min_10.0% Prob": 5.194872736930847, "Min_20.0% Prob": 3.4603152149601986, "Min_30.0% Prob": 2.471336095832115, "Min_40.0% Prob": 1.89425205692001, "Min_50.0% Prob": 1.5301665467882737, "Min_60.0% Prob": 1.2797690895359124}}
{"hexsha": "ef73092254983280efce6aedce3fd2de6b0c3b43", "ext": "rs", "lang": "Rust", "content": "fn send_send() {\n    let (send, _recv) = super::new();\n    send.send(1u8).unwrap();\n    assert_eq!(send.send(1u8).unwrap_err(), (1, Error::Full));\n}", "item_id": 3, "repo": "mahkoh/comm", "file": "src/spsc/one_space/test.rs", "last_update_at": "2019-06-03T17:03:36+00:00", "question_id": "ef73092254983280efce6aedce3fd2de6b0c3b43_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn send_send() {\n    let (send, _recv) = super::new();\n    send.send(1u8).unwrap();\n    assert_eq!(send.send(1u8).unwrap_err(), (1, Error::Full));\n"]], "pred": {"ppl": 3.7492339611053467, "ppl_lower": 4.446394920349121, "ppl/lowercase_ppl": -1.129046874132787, "ppl/zlib": 0.01149175253979434, "Min_5.0% Prob": 8.00602912902832, "Min_10.0% Prob": 6.6413664023081465, "Min_20.0% Prob": 4.730297684669495, "Min_30.0% Prob": 3.6862312422858343, "Min_40.0% Prob": 3.0067986622452736, "Min_50.0% Prob": 2.5216594139734902, "Min_60.0% Prob": 2.1613546336690583}}
{"hexsha": "9636b48c2daa3c3b541943dd47a29eb3d35d6b32", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    local_deprecated!(); //~ WARN use of deprecated item 'local_deprecated': local deprecation note\n    deprecated_macro!(); //~ WARN use of deprecated item 'deprecated_macro': deprecation note\n}", "item_id": 0, "repo": "Timmmm/rust", "file": "src/test/ui/macros/macro-deprecation.rs", "last_update_at": "2019-12-10T20:07:24+00:00", "question_id": "9636b48c2daa3c3b541943dd47a29eb3d35d6b32_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    local_deprecated!(); //~ WARN use of deprecated item 'local_deprecated': local deprecation note\n    deprecated_macro!(); //~ WARN use of deprecated item 'deprecated_macro': deprecation note\n"]], "pred": {"ppl": 3.872083902359009, "ppl_lower": 4.688076019287109, "ppl/lowercase_ppl": -1.1412545732932908, "ppl/zlib": 0.0130172388286273, "Min_5.0% Prob": 10.417844772338867, "Min_10.0% Prob": 7.921575546264648, "Min_20.0% Prob": 5.662588314576582, "Min_30.0% Prob": 4.328427763546214, "Min_40.0% Prob": 3.3719126478485437, "Min_50.0% Prob": 2.7175117926350953, "Min_60.0% Prob": 2.2714295136077065}}
{"hexsha": "7bcafbc527a27944c206358ec81bf88cc10d2e1e", "ext": "rs", "lang": "Rust", "content": "fn create_coordinate_subarrays_3d<F: BFloat, const N_POINTS: usize>(\n    crosses_periodic_bound: &In3D<bool>,\n    coords: &CoordRefs3<F>,\n    extents: &Vec3<F>,\n    start_indices: &Idx3<isize>,\n) -> ([F; N_POINTS], [F; N_POINTS], [F; N_POINTS]) {\n    let x_coord_subarray = if crosses_periodic_bound[X] {\n        create_coordinate_subarray_for_periodic::<_, N_POINTS>(\n            coords[X],\n            extents[X],\n            start_indices[X],\n        )\n    } else {\n        create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[X], start_indices[X])\n    };\n    let y_coord_subarray = if crosses_periodic_bound[Y] {\n        create_coordinate_subarray_for_periodic::<_, N_POINTS>(\n            coords[Y],\n            extents[Y],\n            start_indices[Y],\n        )\n    } else {\n        create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[Y], start_indices[Y])\n    };\n    let z_coord_subarray = if crosses_periodic_bound[Z] {\n        create_coordinate_subarray_for_periodic::<_, N_POINTS>(\n            coords[Z],\n            extents[Z],\n            start_indices[Z],\n        )\n    } else {\n        create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[Z], start_indices[Z])\n    };\n    (x_coord_subarray, y_coord_subarray, z_coord_subarray)\n}", "item_id": 14, "repo": "lars-frogner/bifrost-rust", "file": "src/interpolation/poly_fit.rs", "last_update_at": "2019-10-24T07:24:05+00:00", "question_id": "7bcafbc527a27944c206358ec81bf88cc10d2e1e_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn create_coordinate_subarrays_3d<F: BFloat, const N_POINTS: usize>(\n    crosses_periodic_bound: &In3D<bool>,\n    coords: &CoordRefs3<F>,\n    extents: &Vec3<F>,\n    start_indices: &Idx3<isize>,\n) -> ([F; N_POINTS], [F; N_POINTS], [F; N_POINTS]) {\n    let x_coord_subarray = if crosses_periodic_bound[X] {\n        create_coordinate_subarray_for_periodic::<_, N_POINTS>(\n            coords[X],\n            extents[X],\n            start_indices[X],\n        )\n    } else {\n        create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[X], start_indices[X])\n    };\n    let y_coord_subarray = if crosses_periodic_bound[Y] {\n        create_coordinate_subarray_for_periodic::<_, N_POINTS>(\n            coords[Y],\n            extents[Y],\n            start_indices[Y],\n        )\n    } else {\n        create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[Y], start_indices[Y])\n    };\n    let z_coord_subarray = if crosses_periodic_bound[Z] {\n        create_coordinate_subarray_for_periodic::<_, N_POINTS>(\n            coords[Z],\n            extents[Z],\n            start_indices[Z],\n        )\n    } else {\n        create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[Z], start_indices[Z])\n    };\n    (x_coord_subarray, y_coord_subarray, z_coord_subarray)\n"]], "pred": {"ppl": 1.626859188079834, "ppl_lower": 1.788069486618042, "ppl/lowercase_ppl": -1.1941539365059337, "ppl/zlib": 0.0015255525941113178, "Min_5.0% Prob": 6.249690810839335, "Min_10.0% Prob": 4.267681206266086, "Min_20.0% Prob": 2.4133062001007297, "Min_30.0% Prob": 1.6308971474257608, "Min_40.0% Prob": 1.2177780057403738, "Min_50.0% Prob": 0.9753053606402613, "Min_60.0% Prob": 0.8133264432642001}}
{"hexsha": "5b184d4e24859fdd22ebd6aee1c206c05230a6f8", "ext": "rs", "lang": "Rust", "content": "fn recv_close_gets_none_idle() {\n    let (mut tx, mut rx) = mpsc::channel::<i32>(10);\n    let mut task = MockTask::new();\n\n    rx.close();\n\n    task.enter(|| {\n        let val = assert_ready!(rx.poll());\n        assert!(val.is_none());\n        assert!(tx.poll_ready().is_err());\n    });\n}", "item_id": 7, "repo": "AmpMe/tokio", "file": "tokio-sync/tests/mpsc.rs", "last_update_at": "2019-10-20T00:22:31+00:00", "question_id": "5b184d4e24859fdd22ebd6aee1c206c05230a6f8_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn recv_close_gets_none_idle() {\n    let (mut tx, mut rx) = mpsc::channel::<i32>(10);\n    let mut task = MockTask::new();\n    rx.close();\n    task.enter(|| {\n        let val = assert_ready!(rx.poll());\n        assert!(val.is_none());\n        assert!(tx.poll_ready().is_err());\n    });\n"]], "pred": {"ppl": 2.9256539344787598, "ppl_lower": 3.20625638961792, "ppl/lowercase_ppl": -1.0853138911439977, "ppl/zlib": 0.005866218705134051, "Min_5.0% Prob": 8.506704807281494, "Min_10.0% Prob": 6.526770309968428, "Min_20.0% Prob": 4.3747721910476685, "Min_30.0% Prob": 3.330799989628069, "Min_40.0% Prob": 2.6340853463519704, "Min_50.0% Prob": 2.1204219854303767, "Min_60.0% Prob": 1.7872017935029607}}
{"hexsha": "07d3c69498cd95b7c29a43403d451c0281bec4fc", "ext": "rs", "lang": "Rust", "content": "fn test_intersection_none() {\n        let r1 = RectRange::from_ranges(4..7, 3..5).unwrap();\n        let r2 = RectRange::from_ranges(7..9, 5..6).unwrap();\n        assert!(r1.intersection(&r2).is_none());\n    }", "item_id": 5, "repo": "kngwyu/rect-iter", "file": "src/lib.rs", "last_update_at": "2019-10-31T11:14:55+00:00", "question_id": "07d3c69498cd95b7c29a43403d451c0281bec4fc_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_intersection_none() {\n        let r1 = RectRange::from_ranges(4..7, 3..5).unwrap();\n        let r2 = RectRange::from_ranges(7..9, 5..6).unwrap();\n        assert!(r1.intersection(&r2).is_none());\n"]], "pred": {"ppl": 2.6885170936584473, "ppl_lower": 3.0838794708251953, "ppl/lowercase_ppl": -1.1387260019835364, "ppl/zlib": 0.0074360133482153515, "Min_5.0% Prob": 8.4298677444458, "Min_10.0% Prob": 6.136054277420044, "Min_20.0% Prob": 4.099961423873902, "Min_30.0% Prob": 3.115290532941404, "Min_40.0% Prob": 2.458027902149385, "Min_50.0% Prob": 1.9902523354842112, "Min_60.0% Prob": 1.6587758921879403}}
{"hexsha": "8c5da4c29637725a8ea05ff3f2acc0fd5947f2d9", "ext": "rs", "lang": "Rust", "content": "fn type_create_works() {\n        TestUtils::cleanup_sovrin_home();\n\n        let wallet_type = DefaultWalletType::new();\n        wallet_type.create(\"wallet1\", None, None).unwrap();\n\n        TestUtils::cleanup_sovrin_home();\n    }", "item_id": 2, "repo": "evernym/sovrin-client-rust2", "file": "src/services/wallet/default.rs", "last_update_at": "2019-06-11T14:47:13+00:00", "question_id": "8c5da4c29637725a8ea05ff3f2acc0fd5947f2d9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn type_create_works() {\n        TestUtils::cleanup_sovrin_home();\n        let wallet_type = DefaultWalletType::new();\n        wallet_type.create(\"wallet1\", None, None).unwrap();\n        TestUtils::cleanup_sovrin_home();\n"]], "pred": {"ppl": 3.714890480041504, "ppl_lower": 5.5894670486450195, "ppl/lowercase_ppl": -1.3113003353660537, "ppl/zlib": 0.009241895755364892, "Min_5.0% Prob": 9.524422645568848, "Min_10.0% Prob": 8.505508354731969, "Min_20.0% Prob": 5.682279253005982, "Min_30.0% Prob": 4.211363483559001, "Min_40.0% Prob": 3.2345082143942516, "Min_50.0% Prob": 2.60810746605459, "Min_60.0% Prob": 2.2121346097025607}}
{"hexsha": "fca924f526160ff35a76982b32c8bef963bf7e64", "ext": "rs", "lang": "Rust", "content": "fn it_resolves() {\n        let c = setup(false);\n        assert_eq!(\n            c.node().resolve(0),\n            Some(vec![(c.narrow_base_id().as_global(), 0)])\n        );\n        assert_eq!(c.node().resolve(1), None);\n    }", "item_id": 6, "repo": "alanamarzoev/noria", "file": "noria-server/dataflow/src/ops/grouped/aggregate.rs", "last_update_at": "2019-07-01T00:50:18+00:00", "question_id": "fca924f526160ff35a76982b32c8bef963bf7e64_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_resolves() {\n        let c = setup(false);\n        assert_eq!(\n            c.node().resolve(0),\n            Some(vec![(c.narrow_base_id().as_global(), 0)])\n        );\n        assert_eq!(c.node().resolve(1), None);\n"]], "pred": {"ppl": 5.24721622467041, "ppl_lower": 6.164383888244629, "ppl/lowercase_ppl": -1.0971772490349985, "ppl/zlib": 0.01184069780753657, "Min_5.0% Prob": 8.85437266031901, "Min_10.0% Prob": 7.641761439187186, "Min_20.0% Prob": 5.790654023488362, "Min_30.0% Prob": 4.66280051936274, "Min_40.0% Prob": 3.8307309112241192, "Min_50.0% Prob": 3.195446355220599, "Min_60.0% Prob": 2.771946287025576}}
{"hexsha": "846dfa56e4e9ff121ac577ff5b11d279c4e15dcf", "ext": "rs", "lang": "Rust", "content": "fn generate_rsa() {\n        let mut pk =\n            Pk::generate_rsa(&mut crate::test_support::rand::test_rng(), 2048, 0x10001).unwrap();\n        let generated = pk.write_private_pem_string().unwrap();\n        assert_eq!(0x10001, pk.rsa_public_exponent().unwrap());\n        assert_eq!(generated, TEST_PEM[..TEST_PEM.len() - 1]);\n    }", "item_id": 0, "repo": "lkatalin/mbedtls", "file": "src/pk/mod.rs", "last_update_at": "2019-10-09T18:26:37+00:00", "question_id": "846dfa56e4e9ff121ac577ff5b11d279c4e15dcf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn generate_rsa() {\n        let mut pk =\n            Pk::generate_rsa(&mut crate::test_support::rand::test_rng(), 2048, 0x10001).unwrap();\n        let generated = pk.write_private_pem_string().unwrap();\n        assert_eq!(0x10001, pk.rsa_public_exponent().unwrap());\n        assert_eq!(generated, TEST_PEM[..TEST_PEM.len() - 1]);\n"]], "pred": {"ppl": 3.320209264755249, "ppl_lower": 3.6716830730438232, "ppl/lowercase_ppl": -1.0838500128138775, "ppl/zlib": 0.006030290515049136, "Min_5.0% Prob": 7.471496105194092, "Min_10.0% Prob": 5.9013238319983845, "Min_20.0% Prob": 4.418494829764733, "Min_30.0% Prob": 3.502354521017808, "Min_40.0% Prob": 2.851061467940991, "Min_50.0% Prob": 2.3638190118166116, "Min_60.0% Prob": 2.000241711162604}}
{"hexsha": "565c1c80b8d9d0a78dea728266f693f25c27f2d0", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut file = read_file(\"input.txt\");\n    let l1 = file.nth(0).unwrap();\n    let l1 = l1.split(',').map(|s| s.chars());\n    let l2 = file.nth(0).unwrap();\n    let l2 = l2.split(',').map(|s| s.chars());\n\n    let mut l1_points_hash = HashSet::new();\n    let mut x: i32 = 0;\n    let mut y: i32 = 0;\n    let mut l1_points = vec![(x, y)];\n    for mut line in l1 {\n        let dir = line.next().unwrap();\n        let number = line.as_str().parse::<i32>().unwrap();\n        for _ in 0..number {\n            match dir {\n                'R' => x += 1,\n                'D' => y += 1,\n                'U' => y -= 1,\n                'L' => x -= 1,\n                _ => panic!(\"invalid\"),\n            }\n            l1_points.push((x, y));\n            l1_points_hash.insert((x, y));\n        }\n    }\n\n    let mut candidate_points = Vec::new();\n\n    let mut min_dist = std::i32::MAX;\n    x = 0;\n    y = 0;\n    let mut l2_points = vec![(x, y)];\n    l2_points.push((x, y));\n    for mut line in l2 {\n        let dir = line.next().unwrap();\n        let number = line.as_str().parse::<i32>().unwrap();\n        for _ in 0..number {\n            match dir {\n                'R' => x += 1,\n                'D' => y += 1,\n                'U' => y -= 1,\n                'L' => x -= 1,\n                _ => panic!(\"invalid\"),\n            }\n            l2_points.push((x, y));\n            if l1_points_hash.contains(&(x, y)) {\n                candidate_points.push((x, y)); // needed for part2\n                if x.abs() + y.abs() < min_dist {\n                    min_dist = x.abs() + y.abs();\n                }\n            }\n        }\n    }\n    //answer to part1\n    println!(\"distance:{}\", min_dist);\n\n    //Now compute steps for all candidate points\n    let mut min_steps = std::usize::MAX;\n    for (px, py) in candidate_points {\n        let l1_steps = l1_points\n            .iter()\n            .take_while(|(x, y)| *x != px || *y != py)\n            .count();\n        let l2_steps = l2_points\n            .iter()\n            .take_while(|(x, y)| *x != px || *y != py)\n            .count();\n        let sum = l1_steps + l2_steps;\n        if sum < min_steps {\n            min_steps = sum;\n        }\n    }\n\n    println!(\"steps:{}\", min_steps);\n}", "item_id": 0, "repo": "jackmott/advent2019", "file": "day_03/src/main.rs", "last_update_at": "2019-12-26T01:11:07+00:00", "question_id": "565c1c80b8d9d0a78dea728266f693f25c27f2d0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let mut file = read_file(\"input.txt\");\n    let l1 = file.nth(0).unwrap();\n    let l1 = l1.split(',').map(|s| s.chars());\n    let l2 = file.nth(0).unwrap();\n    let l2 = l2.split(',').map(|s| s.chars());\n    let mut l1_points_hash = HashSet::new();\n    let mut x: i32 = 0;\n    let mut y: i32 = 0;\n    let mut l1_points = vec![(x, y)];\n    for mut line in l1 {\n        let dir = line.next().unwrap();\n        let number = line.as_str().parse::<i32>().unwrap();\n        for _ in 0..number {\n            match dir {\n                'R' => x += 1,\n                'D' => y += 1,\n                'U' => y -= 1,\n                'L' => x -= 1,\n                _ => panic!(\"invalid\"),\n            }\n            l1_points.push((x, y));\n            l1_points_hash.insert((x, y));\n        }\n    }\n    let mut candidate_points = Vec::new();\n    let mut min_dist = std::i32::MAX;\n    x = 0;\n    y = 0;\n    let mut l2_points = vec![(x, y)];\n    l2_points.push((x, y));\n    for mut line in l2 {\n        let dir = line.next().unwrap();\n        let number = line.as_str().parse::<i32>().unwrap();\n        for _ in 0..number {\n            match dir {\n                'R' => x += 1,\n                'D' => y += 1,\n                'U' => y -= 1,\n                'L' => x -= 1,\n                _ => panic!(\"invalid\"),\n            }\n            l2_points.push((x, y));\n            if l1_points_hash.contains(&(x, y)) {\n                candidate_points.push((x, y)); // needed for part2\n                if x.abs() + y.abs() < min_dist {\n                    min_dist = x.abs() + y.abs();\n                }\n            }\n        }\n    }\n    //answer to part1\n    println!(\"distance:{}\", min_dist);\n    //Now compute steps for all candidate points\n    let mut min_steps = std::usize::MAX;\n    for (px, py) in candidate_points {\n        let l1_steps = l1_points\n            .iter()\n            .take_while(|(x, y)| *x != px || *y != py)\n            .count();\n        let l2_steps = l2_points\n            .iter()\n            .take_while(|(x, y)| *x != px || *y != py)\n            .count();\n        let sum = l1_steps + l2_steps;\n        if sum < min_steps {\n            min_steps = sum;\n        }\n    }\n    println!(\"steps:{}\", min_steps);\n"]], "pred": {"ppl": 1.5599212646484375, "ppl_lower": 1.628346562385559, "ppl/lowercase_ppl": -1.0965505163039162, "ppl/zlib": 0.0006925784246238568, "Min_5.0% Prob": 5.650834089831302, "Min_10.0% Prob": 3.705534365270045, "Min_20.0% Prob": 2.1317393190481444, "Min_30.0% Prob": 1.4659964441930577, "Min_40.0% Prob": 1.1093750302135557, "Min_50.0% Prob": 0.8879172514431622, "Min_60.0% Prob": 0.7409896266120677}}
{"hexsha": "fe6c8a7fe7303b729df325b6ab28632a5fc594ad", "ext": "rs", "lang": "Rust", "content": "pub fn task2( map: &Vec<String> ) -> usize {\n    let n : i32 = 128;\n    let mut on : HashMap<Point, i32> = HashMap::new();\n    let no_group = -1;\n    for y in 0 .. n {\n        let r : Vec<bool> = map.get(y as usize ).unwrap().chars()\n            .flat_map( |c| hex_to_bin(c) ).collect();\n        assert_eq!( n as usize, r.len() );\n        for x in 0 .. n {\n            let is_set = r.get(x as usize).unwrap();\n            if *is_set { on.insert((x, y), no_group); }\n        }\n    }\n    let max_gr = on.len() as i32;\n    for cur_gr in 0 .. max_gr {\n        let oe = on.clone().into_iter().find( |e| e.1 == no_group);\n        if oe.is_none() { break; }\n        // this is a new group\n        let p0 = oe.unwrap().0;\n        on.insert(p0, cur_gr );\n        let mut s : HashSet<Point> = HashSet::new();\n        s.insert(p0);\n        while !s.is_empty() {\n            let mut s1 : HashSet<Point> = HashSet::new();\n            for p in s  {\n                let close_points : Vec<Point> = on.clone().into_iter()\n                    .filter( |e| e.1 == no_group && close(&e.0, &p ) )\n                    .map( |e| e.0 ).collect();\n                s1.extend( close_points );\n            }\n            for p in &s1 { on.insert(*p, cur_gr ); }\n            s = s1;\n        }\n    }\n\n    let set : HashSet<i32> = on.into_iter().map( |e| e.1 ).collect();\n    assert!( !set.contains( &no_group) );\n    set.len()\n}", "item_id": 3, "repo": "yury-fedorov/AoC18", "file": "AoC17/rust/src/day14.rs", "last_update_at": "2019-01-21T15:08:21+00:00", "question_id": "fe6c8a7fe7303b729df325b6ab28632a5fc594ad_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn task2( map: &Vec<String> ) -> usize {\n    let n : i32 = 128;\n    let mut on : HashMap<Point, i32> = HashMap::new();\n    let no_group = -1;\n    for y in 0 .. n {\n        let r : Vec<bool> = map.get(y as usize ).unwrap().chars()\n            .flat_map( |c| hex_to_bin(c) ).collect();\n        assert_eq!( n as usize, r.len() );\n        for x in 0 .. n {\n            let is_set = r.get(x as usize).unwrap();\n            if *is_set { on.insert((x, y), no_group); }\n        }\n    }\n    let max_gr = on.len() as i32;\n    for cur_gr in 0 .. max_gr {\n        let oe = on.clone().into_iter().find( |e| e.1 == no_group);\n        if oe.is_none() { break; }\n        // this is a new group\n        let p0 = oe.unwrap().0;\n        on.insert(p0, cur_gr );\n        let mut s : HashSet<Point> = HashSet::new();\n        s.insert(p0);\n        while !s.is_empty() {\n            let mut s1 : HashSet<Point> = HashSet::new();\n            for p in s  {\n                let close_points : Vec<Point> = on.clone().into_iter()\n                    .filter( |e| e.1 == no_group && close(&e.0, &p ) )\n                    .map( |e| e.0 ).collect();\n                s1.extend( close_points );\n            }\n            for p in &s1 { on.insert(*p, cur_gr ); }\n            s = s1;\n        }\n    }\n    let set : HashSet<i32> = on.into_iter().map( |e| e.1 ).collect();\n    assert!( !set.contains( &no_group) );\n    set.len()\n"]], "pred": {"ppl": 2.2838618755340576, "ppl_lower": 2.3973796367645264, "ppl/lowercase_ppl": -1.0587364065124534, "ppl/zlib": 0.001461712947177224, "Min_5.0% Prob": 7.05914867401123, "Min_10.0% Prob": 5.238980424170401, "Min_20.0% Prob": 3.5629878333471354, "Min_30.0% Prob": 2.6072340419215543, "Min_40.0% Prob": 2.0291062457468905, "Min_50.0% Prob": 1.6417031752797522, "Min_60.0% Prob": 1.3733456876489425}}
{"hexsha": "b194a5513f6755d1d1e9114a658dd899c1279134", "ext": "rs", "lang": "Rust", "content": "fn swap_hl_op() {\n        let mut mem: Memory = Memory::new();\n        let addr = 1;\n        mem.write_byte(addr, 0b10100101);\n        let mut cpu: CPU = CPU::new(&mut mem);\n        cpu.registers.write_16b(&Register16bits::HL, addr);\n\n        swap_hl(&mut cpu);\n\n        assert_eq!(mem.read_byte(addr), 0b01011010);\n    }", "item_id": 80, "repo": "davidor/gebers", "file": "src/cpu/rotate_ops.rs", "last_update_at": "2019-04-08T09:31:04+00:00", "question_id": "b194a5513f6755d1d1e9114a658dd899c1279134_80", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn swap_hl_op() {\n        let mut mem: Memory = Memory::new();\n        let addr = 1;\n        mem.write_byte(addr, 0b10100101);\n        let mut cpu: CPU = CPU::new(&mut mem);\n        cpu.registers.write_16b(&Register16bits::HL, addr);\n        swap_hl(&mut cpu);\n        assert_eq!(mem.read_byte(addr), 0b01011010);\n"]], "pred": {"ppl": 2.480400800704956, "ppl_lower": 2.8233938217163086, "ppl/lowercase_ppl": -1.1425766287188992, "ppl/zlib": 0.004781158738454572, "Min_5.0% Prob": 7.050561507542928, "Min_10.0% Prob": 5.217017889022827, "Min_20.0% Prob": 3.5288353967666626, "Min_30.0% Prob": 2.6545966549923548, "Min_40.0% Prob": 2.1579827439785, "Min_50.0% Prob": 1.7749082566726775, "Min_60.0% Prob": 1.4996743657087024}}
{"hexsha": "f4f90cce53e601952a2eb4fb2def5e4d0d39868d", "ext": "rs", "lang": "Rust", "content": "fn _prepare_block_nosum(\n\tkc: &ExtKeychain,\n\tprev: &BlockHeader,\n\tdiff: u64,\n\ttxs: Vec<&Transaction>,\n) -> Block {\n\tlet key_id = ExtKeychainPath::new(1, diff as u32, 0, 0, 0).to_identifier();\n\n\tlet fees = txs.iter().map(|tx| tx.fee()).sum();\n\tlet reward = libtx::reward::output(kc, &key_id, fees, false).unwrap();\n\tlet mut b = match core::core::Block::new(\n\t\tprev,\n\t\ttxs.into_iter().cloned().collect(),\n\t\tDifficulty::from_num(diff),\n\t\treward,\n\t) {\n\t\tErr(e) => panic!(\"{:?}\", e),\n\t\tOk(b) => b,\n\t};\n\tb.header.timestamp = prev.timestamp + Duration::seconds(60);\n\tb.header.pow.total_difficulty = Difficulty::from_num(diff);\n\tb\n}", "item_id": 6, "repo": "morningsprouter/grin", "file": "chain/tests/data_file_integrity.rs", "last_update_at": "2019-06-25T10:33:43+00:00", "question_id": "f4f90cce53e601952a2eb4fb2def5e4d0d39868d_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn _prepare_block_nosum(\n\tkc: &ExtKeychain,\n\tprev: &BlockHeader,\n\tdiff: u64,\n\ttxs: Vec<&Transaction>,\n) -> Block {\n\tlet key_id = ExtKeychainPath::new(1, diff as u32, 0, 0, 0).to_identifier();\n\tlet fees = txs.iter().map(|tx| tx.fee()).sum();\n\tlet reward = libtx::reward::output(kc, &key_id, fees, false).unwrap();\n\tlet mut b = match core::core::Block::new(\n\t\tprev,\n\t\ttxs.into_iter().cloned().collect(),\n\t\tDifficulty::from_num(diff),\n\t\treward,\n\t) {\n\t\tErr(e) => panic!(\"{:?}\", e),\n\t\tOk(b) => b,\n\t};\n\tb.header.timestamp = prev.timestamp + Duration::seconds(60);\n\tb.header.pow.total_difficulty = Difficulty::from_num(diff);\n\tb\n"]], "pred": {"ppl": 1.762698769569397, "ppl_lower": 2.4569554328918457, "ppl/lowercase_ppl": -1.5858326823647777, "ppl/zlib": 0.0014460357816481705, "Min_5.0% Prob": 7.142612127157358, "Min_10.0% Prob": 4.635109358363682, "Min_20.0% Prob": 2.689831600696952, "Min_30.0% Prob": 1.8689020152813123, "Min_40.0% Prob": 1.4196767814940325, "Min_50.0% Prob": 1.1321656003745053, "Min_60.0% Prob": 0.9455657198016697}}
{"hexsha": "b13122209cbe9bea76769d10eb0941a034de074f", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let config = config::get_config();\n    let input = fs::read_to_string(&config.target_file_path)\n        .expect(\"unable to read file\");\n\n    let ron_ast = parser::parse_ron(&input);\n    let ron_formatted = ron_ast.pretty_print(&config);\n\n    if config.format_in_place {\n        if config.with_backup {\n            create_backup(&config.target_file_path);\n        }\n\n        fs::write(&config.target_file_path, ron_formatted)\n            .expect(\"unable to overwrite target file\");\n    } else {\n        println!(\"{}\", ron_formatted);\n    }\n}", "item_id": 0, "repo": "Ristarg/ronfmt", "file": "src/main.rs", "last_update_at": "2019-09-02T04:14:34+00:00", "question_id": "b13122209cbe9bea76769d10eb0941a034de074f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let config = config::get_config();\n    let input = fs::read_to_string(&config.target_file_path)\n        .expect(\"unable to read file\");\n    let ron_ast = parser::parse_ron(&input);\n    let ron_formatted = ron_ast.pretty_print(&config);\n    if config.format_in_place {\n        if config.with_backup {\n            create_backup(&config.target_file_path);\n        }\n        fs::write(&config.target_file_path, ron_formatted)\n            .expect(\"unable to overwrite target file\");\n    } else {\n        println!(\"{}\", ron_formatted);\n    }\n"]], "pred": {"ppl": 2.207139253616333, "ppl_lower": 2.207139253616333, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.003129238030123989, "Min_5.0% Prob": 6.37928565343221, "Min_10.0% Prob": 5.055232882499695, "Min_20.0% Prob": 3.4183227684762745, "Min_30.0% Prob": 2.486939415335655, "Min_40.0% Prob": 1.9338784598641925, "Min_50.0% Prob": 1.5736986412770217, "Min_60.0% Prob": 1.3172218290123123}}
{"hexsha": "70cdb095b9259bb3ff13a654da91ffd54dae8fc6", "ext": "rs", "lang": "Rust", "content": "fn input_port_b_direction() {\n        let mut riot = Riot::new();\n\n        // Reading from the bits set as output should return the register value\n        // instead of port input.\n        riot.set_port(Port::PB, 0b1100_1100);\n        riot.write(registers::SWBCNT, 0b1111_0000).unwrap();\n        riot.write(registers::SWCHB, 0b0101_0101).unwrap();\n        assert_eq!(riot.read(registers::SWCHB).unwrap(), 0b0101_1100);\n\n        // Data in the output register should be cached and return what we wrote\n        // to bits previously set to act as inputs.\n        riot.write(registers::SWBCNT, 0b0000_1111).unwrap();\n        assert_eq!(riot.read(registers::SWCHB).unwrap(), 0b1100_0101);\n    }", "item_id": 6, "repo": "technomaniak/atari-emulator", "file": "atari2600/src/riot.rs", "last_update_at": "2019-08-16T09:49:50+00:00", "question_id": "70cdb095b9259bb3ff13a654da91ffd54dae8fc6_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn input_port_b_direction() {\n        let mut riot = Riot::new();\n        // Reading from the bits set as output should return the register value\n        // instead of port input.\n        riot.set_port(Port::PB, 0b1100_1100);\n        riot.write(registers::SWBCNT, 0b1111_0000).unwrap();\n        riot.write(registers::SWCHB, 0b0101_0101).unwrap();\n        assert_eq!(riot.read(registers::SWCHB).unwrap(), 0b0101_1100);\n        // Data in the output register should be cached and return what we wrote\n        // to bits previously set to act as inputs.\n        riot.write(registers::SWBCNT, 0b0000_1111).unwrap();\n        assert_eq!(riot.read(registers::SWCHB).unwrap(), 0b1100_0101);\n"]], "pred": {"ppl": 3.241881847381592, "ppl_lower": 3.541149139404297, "ppl/lowercase_ppl": -1.0750729185650445, "ppl/zlib": 0.003818681747689475, "Min_5.0% Prob": 8.509161114692688, "Min_10.0% Prob": 6.891078586578369, "Min_20.0% Prob": 4.6570759964924235, "Min_30.0% Prob": 3.5281207259599263, "Min_40.0% Prob": 2.819787683417496, "Min_50.0% Prob": 2.316150814294815, "Min_60.0% Prob": 1.9608741413269724}}
{"hexsha": "b5f1472236bf3f1eb6278d696524d731f5055f49", "ext": "rs", "lang": "Rust", "content": "fn object_panics_on_internal_error() {\n        let object_behavior = ObjectBehaviorMock::new();\n        let expected_object = Object {\n            id: 125,\n            description: object_description(),\n            behavior: &object_behavior,\n        };\n\n        let mut interactable = InteractableMock::<()>::new();\n        interactable\n            .expect_object(|arg| arg.partial_eq(expected_object.id))\n            .returns(None);\n        let world_interactor = WorldInteractorImpl::new(&interactable, expected_object.id);\n\n        let _object = world_interactor.own_object();\n    }", "item_id": 4, "repo": "myelin-ai/engine", "file": "src/world_interactor/world_interactor_impl.rs", "last_update_at": "2019-12-14T11:25:28+00:00", "question_id": "b5f1472236bf3f1eb6278d696524d731f5055f49_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn object_panics_on_internal_error() {\n        let object_behavior = ObjectBehaviorMock::new();\n        let expected_object = Object {\n            id: 125,\n            description: object_description(),\n            behavior: &object_behavior,\n        };\n        let mut interactable = InteractableMock::<()>::new();\n        interactable\n            .expect_object(|arg| arg.partial_eq(expected_object.id))\n            .returns(None);\n        let world_interactor = WorldInteractorImpl::new(&interactable, expected_object.id);\n        let _object = world_interactor.own_object();\n"]], "pred": {"ppl": 4.271053791046143, "ppl_lower": 5.482555866241455, "ppl/lowercase_ppl": -1.1719936523355114, "ppl/zlib": 0.005715986560099155, "Min_5.0% Prob": 8.787009000778198, "Min_10.0% Prob": 7.17029869556427, "Min_20.0% Prob": 5.46214185655117, "Min_30.0% Prob": 4.246057237188022, "Min_40.0% Prob": 3.4371618069708347, "Min_50.0% Prob": 2.839837033301592, "Min_60.0% Prob": 2.4019064490372934}}
{"hexsha": "6ee7812d7118b6d191334106a34ef882bb9b8a7e", "ext": "rs", "lang": "Rust", "content": "fn points((a, b): Segment) -> Vec<Point> {\n    let mut xs: Vec<i64> = (a.x.min(b.x)..=a.x.max(b.x)).collect();\n    if a.x > b.x {\n        xs.reverse();\n    }\n\n    let mut ys: Vec<i64> = (a.y.min(b.y)..=a.y.max(b.y)).collect();\n    if a.y > b.y {\n        ys.reverse();\n    }\n\n    if xs.len() == 1 {\n        xs.iter()\n            .cycle()\n            .zip(ys.iter())\n            .map(|(&x, &y)| Point::new(x, y))\n            .collect()\n    } else {\n        xs.iter()\n            .zip(ys.iter().cycle())\n            .map(|(&x, &y)| Point::new(x, y))\n            .collect()\n    }\n}", "item_id": 0, "repo": "sebnow/adventofcode", "file": "2021/src/bin/day05.rs", "last_update_at": "2019-08-12T13:58:00+00:00", "question_id": "6ee7812d7118b6d191334106a34ef882bb9b8a7e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn points((a, b): Segment) -> Vec<Point> {\n    let mut xs: Vec<i64> = (a.x.min(b.x)..=a.x.max(b.x)).collect();\n    if a.x > b.x {\n        xs.reverse();\n    }\n    let mut ys: Vec<i64> = (a.y.min(b.y)..=a.y.max(b.y)).collect();\n    if a.y > b.y {\n        ys.reverse();\n    }\n    if xs.len() == 1 {\n        xs.iter()\n            .cycle()\n            .zip(ys.iter())\n            .map(|(&x, &y)| Point::new(x, y))\n            .collect()\n    } else {\n        xs.iter()\n            .zip(ys.iter().cycle())\n            .map(|(&x, &y)| Point::new(x, y))\n            .collect()\n    }\n"]], "pred": {"ppl": 1.596695065498352, "ppl_lower": 1.755905270576477, "ppl/lowercase_ppl": -1.2031231988901379, "ppl/zlib": 0.0020256965754163886, "Min_5.0% Prob": 6.089527289072673, "Min_10.0% Prob": 3.8548872470855713, "Min_20.0% Prob": 2.233935127655665, "Min_30.0% Prob": 1.5468582263112896, "Min_40.0% Prob": 1.16693996230606, "Min_50.0% Prob": 0.9351774479883412, "Min_60.0% Prob": 0.779709299047277}}
{"hexsha": "02354d15ae2988c17b5c379480cdf009abee280a", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let input = \"\u592a\u90ce\u306f\u30ab\u30b9\u30c6\u30e9\u304c\u597d\u304d\u3060\u3002\u3057\u304b\u3057\u725b\u4e73\u3082\u597d\u304d\u3060\u3002\";\n    let sr = lightblue(input).unwrap();\n    println!(\"{}\", format_sr(&sr));\n}", "item_id": 0, "repo": "denjiry/pindilogji", "file": "src/main.rs", "last_update_at": "2019-08-03T16:54:25+00:00", "question_id": "02354d15ae2988c17b5c379480cdf009abee280a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let input = \"\u592a\u90ce\u306f\u30ab\u30b9\u30c6\u30e9\u304c\u597d\u304d\u3060\u3002\u3057\u304b\u3057\u725b\u4e73\u3082\u597d\u304d\u3060\u3002\";\n    let sr = lightblue(input).unwrap();\n    println!(\"{}\", format_sr(&sr));\n"]], "pred": {"ppl": 7.80742883682251, "ppl_lower": 7.80742883682251, "ppl/lowercase_ppl": -1.0, "ppl/zlib": 0.013006808198819098, "Min_5.0% Prob": 11.97847048441569, "Min_10.0% Prob": 10.265007575352987, "Min_20.0% Prob": 7.727397720019023, "Min_30.0% Prob": 6.142454200320774, "Min_40.0% Prob": 4.838703966140747, "Min_50.0% Prob": 4.0352477911979925, "Min_60.0% Prob": 3.4401765312697434}}
{"hexsha": "ce1a663d7060e0580e0bf6949cbd1522434a345d", "ext": "rs", "lang": "Rust", "content": "fn draw_polar_line_bottom_left_to_top_right() {\n        let actual = image_with_polar_line(5, 5, 3.0, 45, Luma([1]));\n        let expected = gray_image!(\n            0, 0, 0, 0, 1;\n            0, 0, 0, 1, 0;\n            0, 0, 1, 0, 0;\n            0, 1, 0, 0, 0;\n            1, 0, 0, 0, 0);\n        assert_pixels_eq!(actual, expected);\n    }", "item_id": 12, "repo": "foresterre/imageproc-patched", "file": "src/hough.rs", "last_update_at": "2019-04-17T02:43:14+00:00", "question_id": "ce1a663d7060e0580e0bf6949cbd1522434a345d_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn draw_polar_line_bottom_left_to_top_right() {\n        let actual = image_with_polar_line(5, 5, 3.0, 45, Luma([1]));\n        let expected = gray_image!(\n            0, 0, 0, 0, 1;\n            0, 0, 0, 1, 0;\n            0, 0, 1, 0, 0;\n            0, 1, 0, 0, 0;\n            1, 0, 0, 0, 0);\n        assert_pixels_eq!(actual, expected);\n"]], "pred": {"ppl": 2.1247262954711914, "ppl_lower": 2.241278648376465, "ppl/lowercase_ppl": -1.0708605225515202, "ppl/zlib": 0.004257870011013951, "Min_5.0% Prob": 6.9225174358912875, "Min_10.0% Prob": 4.974647585550944, "Min_20.0% Prob": 3.3782674035718365, "Min_30.0% Prob": 2.4495065801955285, "Min_40.0% Prob": 1.8808985687200985, "Min_50.0% Prob": 1.5121415517516905, "Min_60.0% Prob": 1.2605127805059677}}
{"hexsha": "56e24ff3f14534ce11dc14e4b54ec7e76665f8ee", "ext": "rs", "lang": "Rust", "content": "pub fn save<T>(zipfilename: &str, filename: &str, data: &T) -> bool\nwhere\n    T: Serialize,\n{\n    let data: Vec<u8> = serialize(data).unwrap();\n    let file = if let Ok(file) = File::create(path(zipfilename)) {\n        file\n    } else {\n        return true;\n    };\n    let mut zip = zip::write::ZipWriter::new(file);\n    let options = zip::write::FileOptions::default().compression_method(zip::CompressionMethod::Deflated).unix_permissions(0o755);\n    zip.start_file(filename, options).unwrap();\n    zip.write_all(&data[..]).unwrap();\n\n    zip.finish().unwrap();\n    false\n}", "item_id": 1, "repo": "OxyDeadbeef/files", "file": "src/lib.rs", "last_update_at": "2019-03-22T04:12:59+00:00", "question_id": "56e24ff3f14534ce11dc14e4b54ec7e76665f8ee_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn save<T>(zipfilename: &str, filename: &str, data: &T) -> bool\nwhere\n    T: Serialize,\n{\n    let data: Vec<u8> = serialize(data).unwrap();\n    let file = if let Ok(file) = File::create(path(zipfilename)) {\n        file\n    } else {\n        return true;\n    };\n    let mut zip = zip::write::ZipWriter::new(file);\n    let options = zip::write::FileOptions::default().compression_method(zip::CompressionMethod::Deflated).unix_permissions(0o755);\n    zip.start_file(filename, options).unwrap();\n    zip.write_all(&data[..]).unwrap();\n    zip.finish().unwrap();\n    false\n"]], "pred": {"ppl": 2.127492666244507, "ppl_lower": 2.721885919570923, "ppl/lowercase_ppl": -1.326356411410841, "ppl/zlib": 0.0023890637162526417, "Min_5.0% Prob": 7.678161091274685, "Min_10.0% Prob": 5.565798746912103, "Min_20.0% Prob": 3.451674627630334, "Min_30.0% Prob": 2.436741408548857, "Min_40.0% Prob": 1.8674469278439094, "Min_50.0% Prob": 1.503630280200588, "Min_60.0% Prob": 1.2558595970387392}}
{"hexsha": "18397dd69503cb1e223befe5d34e6f6cd15e3d53", "ext": "rs", "lang": "Rust", "content": "pub fn stop(SomeUser: komodorpcutil::KomodoRPC) -> Result<String, reqwest::Error> {\n    let method_name: String = String::from(\"stop\");\n    let method_body: String = String::from(\"[]\");\n    let data: String = String::from(komodorpcutil::generate_body(\n        SomeUser.clone(),\n        method_name,\n        method_body,\n    ));\n    let result = komodorpcutil::request(SomeUser.clone(), data);\n    return result;\n}", "item_id": 2, "repo": "sudipghale/Komodo-RPC-API-Rust", "file": "src/komodo/control.rs", "last_update_at": "2019-12-07T03:17:44+00:00", "question_id": "18397dd69503cb1e223befe5d34e6f6cd15e3d53_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn stop(SomeUser: komodorpcutil::KomodoRPC) -> Result<String, reqwest::Error> {\n    let method_name: String = String::from(\"stop\");\n    let method_body: String = String::from(\"[]\");\n    let data: String = String::from(komodorpcutil::generate_body(\n        SomeUser.clone(),\n        method_name,\n        method_body,\n    ));\n    let result = komodorpcutil::request(SomeUser.clone(), data);\n    return result;\n"]], "pred": {"ppl": 2.842355966567993, "ppl_lower": 3.637537956237793, "ppl/lowercase_ppl": -1.2361343442990587, "ppl/zlib": 0.005071035310517616, "Min_5.0% Prob": 10.006782611211142, "Min_10.0% Prob": 7.163075347741445, "Min_20.0% Prob": 4.604273991584778, "Min_30.0% Prob": 3.3053697237842963, "Min_40.0% Prob": 2.560058977089676, "Min_50.0% Prob": 2.0739042753120884, "Min_60.0% Prob": 1.7547860545057214}}
