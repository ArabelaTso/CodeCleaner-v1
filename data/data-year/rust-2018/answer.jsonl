{"hexsha": "6b05a737ab80d77ea0ef4de1fc466367d251d8c4", "ext": "rs", "lang": "Rust", "content": "fn make_moon(day: f64, earth_coords: &Array3d) -> PlanetPS {\n    let solar_trait = Solarobj::Moon {\n        attr: Some(SolarAttr {\n            radius: 1.7381e6,\n            mass: 0.07346e24,\n        }),\n    };\n\n    let mut moon_body = PlanetPS {\n        solartype: solar_trait,\n        coords: SolarobjCoords::default(),\n        velocity: Array3d::default(), // Zero until sim update\n        n0: 125.1228,\n        nc: -0.0529538083,\n        i0: 5.1454,\n        ic: 0.0,\n        w0: 318.0634,\n        wc: 0.1643573223,\n        a0: 60.2666 / EARTH_RADII_PER_ASTRONOMICAL_UNIT,\n        ac: 0.0,\n        e0: 0.054900,\n        ec: 0.0,\n        m0: 115.3654,\n        mc: 13.0649929509,\n        mag_base: 0.23,\n        mag_phase_factor: 0.026,\n        mag_nonlinear_factor: 4.0e-9,\n        mag_nonlinear_exponent: 4f64,\n    };\n\n    // Calculate the location of the moon and convert to heliocentric coords\n    let initial_coords = moon_body.ecliptic_cartesian_coords(day) + earth_coords;\n    moon_body.coords.ahead_coords = initial_coords;\n    moon_body.coords.current_coords = initial_coords;\n    moon_body.coords.behind_coords = initial_coords;\n\n    moon_body\n}", "item_id": 3, "repo": "wagnerdylan/POSE", "file": "src/bodies.rs", "last_update_at": "2019-04-22T16:47:35+00:00"}
{"hexsha": "7a5406638910b7fd1cbce133805b4516bb853406", "ext": "rs", "lang": "Rust", "content": "fn test_initialize_vertices() {\n        let left_image = [[1, 1].to_vec()].to_vec();\n        let right_image = [[1, 0].to_vec()].to_vec();\n        let max_disparity: usize = 2;\n        let mut diffusion_graph = DiffusionGraph::initialize(left_image, right_image, max_disparity, 1.);\n        diffusion_graph.potentials[0][0][2][0] = 0.6;\n        diffusion_graph.potentials[0][1][0][0] = -13.7;\n        diffusion_graph.potentials[0][1][0][1] = 80.;\n        let vertices = vec![vec![vec![false; max_disparity]; 2]; 1];\n        let edges = vec![vec![vec![vec![vec![false; max_disparity]; 4]; max_disparity]; 2]; 1];\n        let mut crossing_out_graph = CrossingOutGraph::initialize(diffusion_graph, vertices, edges);\n        crossing_out_graph.initialize_vertices(1.);\n        assert!(crossing_out_graph.vertices[0][0][0]);\n        assert!(!crossing_out_graph.vertices[0][1][0]);\n        assert!(crossing_out_graph.vertices[0][1][1]);\n    }", "item_id": 3, "repo": "Helga-Helga/stereo-vision", "file": "diffusion_stereo/src/crossing_out_graph.rs", "last_update_at": "2019-09-29T09:16:29+00:00"}
{"hexsha": "a28196ca355d1ed4bddbae5254b02a442b8003f0", "ext": "rs", "lang": "Rust", "content": "pub fn daily_temperatures(t: Vec<i32>) -> Vec<i32> {\n    let mut stack: Vec<usize> = vec![];\n    let mut res = vec![];\n    res.resize(t.len(), 0);\n\n    let mut count = 0;\n    for i in 0..t.len() {\n        while !stack.is_empty() && t[stack[stack.len() - 1]] < t[i] {\n            let cur = stack.pop().unwrap();\n            let days = count - cur;\n            res[cur] = days as i32;\n        }\n        stack.push(count);\n        count += 1;\n    }\n    res\n}", "item_id": 0, "repo": "yjhmelody/leetcode-rust", "file": "src/daily_temperatures.rs", "last_update_at": "2019-06-05T06:51:56+00:00"}
{"hexsha": "3784db95164066da6e55327253379eabe8e2a952", "ext": "rs", "lang": "Rust", "content": "fn test_divsd_rr() {\n        assert_emit!(0xf2, 0x0f, 0x5e, 0xc1; divsd_rr(XMM0, XMM1));\n        assert_emit!(0xf2, 0x41, 0x0f, 0x5e, 0xdf; divsd_rr(XMM3, XMM15));\n        assert_emit!(0xf2, 0x44, 0x0f, 0x5e, 0xc4; divsd_rr(XMM8, XMM4));\n    }", "item_id": 55, "repo": "ashwanidausodia/dora", "file": "dora/src/asm/x64.rs", "last_update_at": "2019-03-22T22:25:17+00:00"}
{"hexsha": "76e0b99ebf5020cb073dd1bfcba07a6ba4d25e3d", "ext": "rs", "lang": "Rust", "content": "fn test_check_answer_1() {\n    let answer = \"1 2 ABC 3.449999999993847\";\n    let expected = \"1 2 ABC 3.45\";\n    assert!(check_answer(answer, expected).is_ok());\n}", "item_id": 1, "repo": "mouri111/kunai", "file": "src/judge.rs", "last_update_at": "2019-12-19T07:54:16+00:00"}
{"hexsha": "89cbaf2d12ed958d64b971f50820c779d053f628", "ext": "rs", "lang": "Rust", "content": "fn test_parse_duration() {\n    assert_eq!(None, parse_duration(\"\"));\n    assert_eq!(None, parse_duration(\"X\"));\n    assert_eq!(None, parse_duration(\"S\"));\n    assert_eq!(Duration::from_millis(1), parse_duration(\"1\").unwrap());\n    assert_eq!(Duration::from_millis(100), parse_duration(\"100\").unwrap());\n    assert_eq!(Duration::from_millis(1000), parse_duration(\"1s\").unwrap());\n    assert_eq!(Duration::from_millis(2000), parse_duration(\"2S\").unwrap());\n    assert_eq!(Duration::from_millis(1500), parse_duration(\"1.5s\").unwrap());\n    assert_eq!(Duration::from_millis(60000), parse_duration(\"1m\").unwrap());\n    assert_eq!(Duration::from_millis(3600000), parse_duration(\"1h\").unwrap());\n    assert_eq!(Duration::from_millis(1800000), parse_duration(\"0.5h\").unwrap());\n    assert_eq!(Duration::from_millis(24 * 3600000), parse_duration(\"1d\").unwrap());\n}", "item_id": 1, "repo": "jht5945/rust_util", "file": "src/util_time.rs", "last_update_at": "2019-08-11T05:31:28+00:00"}
{"hexsha": "ca916874d99d1804e8d632c564046b2689a8f57d", "ext": "rs", "lang": "Rust", "content": "fn test_fn(dir_name: &str, fn_name: &str) -> Result<(), Error> {\n    do catch {\n        let facts_dir = Path::new(env!(\"CARGO_MANIFEST_DIR\"))\n            .join(\"inputs\")\n            .join(dir_name)\n            .join(\"nll-facts\")\n            .join(fn_name);\n        println!(\"facts_dir = {:?}\", facts_dir);\n        let tables = &mut intern::InternerTables::new();\n        let all_facts = tab_delim::load_tab_delimited_facts(tables, &facts_dir)?;\n        let naive = Output::compute(&all_facts, Algorithm::Naive, false);\n        let opt = Output::compute(&all_facts, Algorithm::DatafrogOpt, true);\n        assert_eq!(naive.borrow_live_at, opt.borrow_live_at);\n    }", "item_id": 0, "repo": "nikomatsakis/borrow-check", "file": "src/test.rs", "last_update_at": "2019-01-28T10:31:16+00:00"}
{"hexsha": "29e13d4dd0da6fa3c93f41a5bf4533c7c4e334cd", "ext": "rs", "lang": "Rust", "content": "fn eat_string(chars: &mut Peekable<Chars>) -> Option<String> {\n    let mut s = String::with_capacity(15);\n\n    while let Some(c) = chars.next() {\n        match c {\n            '\"' => return Some(s.to_owned()),\n            '\\\\' => match chars.next()? {\n                '\\\\' => s.push('\\\\'),\n                '/' => s.push('/'),\n                '\"' => s.push('\"'),\n                'n' => s.push('\\n'),\n                't' => s.push('\\t'),\n                'b' => s.push(8 as char),\n                'f' => s.push(12 as char),\n                'r' => s.push(13 as char),\n                'u' => {\n                    if let Ok(num) = u8::from_str_radix(&chars.take(4).collect::<String>(), 16) {\n                        s.push(num as char);\n                    }\n                }\n                _ => {}\n            },\n            _ => s.push(c),\n        }\n    }\n\n    Some(s.to_owned())\n}", "item_id": 0, "repo": "mlvzk/json-to-sh", "file": "src/lexer.rs", "last_update_at": "2019-07-30T09:08:49+00:00"}
{"hexsha": "2791ab82c02c885f427c58931d2c5ec2e77eb458", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let n: usize = {\n        let mut line: String = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n        line.trim().parse().unwrap()\n    };\n    let a: Vec<i64> = {\n        let mut line: String = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|x| x.parse().unwrap())\n            .collect()\n    };\n\n    let ans = (0..n)\n        .map(|i| if i < (n + 1) / 2 { a[n - 2 * i - 1] } else { a[2 * (i - (n + 1) / 2) + n % 2] })\n        .map(|x| x.to_string())\n        .collect::<Vec<_>>()\n        .join(\" \");\n\n    println!(\"{}\", ans);\n}", "item_id": 0, "repo": "wotsushi/competitive-programming", "file": "arc/077/c.rs", "last_update_at": "2019-07-13T15:18:51+00:00"}
{"hexsha": "53d4b0e15843bcbffd0d575e9f2fec82e4f3dd91", "ext": "rs", "lang": "Rust", "content": "fn overflow_flag_hi_under() {\n    let mut flags = StatusFlags::empty();\n    flags.set_overflow(-129i16 as u16);\n\n    assert!(flags.contains(StatusFlags::V_FLAG));\n  }", "item_id": 5, "repo": "WeAreRust/Nes", "file": "nes/src/cpu/register.rs", "last_update_at": "2019-07-12T01:31:25+00:00"}
{"hexsha": "3c49efe78c33a7ba0a4c81366ec0a1ce02b21082", "ext": "rs", "lang": "Rust", "content": "pub fn get_doc(attrs: &[syn::Attribute], null_terminated: bool) -> syn::Lit {\n    let mut doc = Vec::new();\n\n    // TODO(althonos): set span on produced doc str literal\n    // let mut span = None;\n\n    for attr in attrs.iter() {\n        if let Some(syn::Meta::NameValue(ref metanv)) = attr.interpret_meta() {\n            if metanv.ident == \"doc\" {\n                // span = Some(metanv.span());\n                if let syn::Lit::Str(ref litstr) = metanv.lit {\n                    let d = litstr.value();\n                    doc.push(if d.starts_with(' ') {\n                        d[1..d.len()].to_string()\n                    } else {\n                        d\n                    });\n                } else {\n                    panic!(\"Invalid doc comment\");\n                }\n            }\n        }\n    }\n\n    let doc = doc.join(\"\\n\");\n\n    // FIXME: add span\n    syn::parse_str(&if null_terminated {\n        format!(\"\\\"{}\\0\\\"\", doc)\n    } else {\n        format!(\"\\\"{}\\\"\", doc)\n    })\n    .unwrap()\n}", "item_id": 0, "repo": "milesgranger/pyo3", "file": "pyo3-derive-backend/src/utils.rs", "last_update_at": "2019-10-06T11:46:45+00:00"}
{"hexsha": "6284d1836ef46c50637504ab98bc58c982d91ef0", "ext": "rs", "lang": "Rust", "content": "pub fn vmresume() -> Result<(), u32> {\n    let ret: u32;\n    unsafe {\n        asm!(\n            \"xor %eax, %eax; \\\n             vmresume; \\\n             setc %ah; \\\n             setz %al;\"\n             : \"={eax}\"(ret)\n             :\n             :\n            );\n    }\n    if ret == 0 { Ok(()) } else { Err(ret) }\n}", "item_id": 10, "repo": "colonelpopcorn/rustyvisor", "file": "src/vmx.rs", "last_update_at": "2019-04-11T21:37:17+00:00"}
{"hexsha": "e9bdfb8b405be3498686f9dabb15f50e1ef6e656", "ext": "rs", "lang": "Rust", "content": "fn test_move_c_e() {\n        let mut cpu: CPU = CPU::new();\n\n        cpu = cpu.set_c(Register { value: 0 });\n        cpu = cpu.set_e(Register { value: 10 });\n\n        cpu = execute_move(cpu, 0b010, 0b100);\n\n        assert_eq!(cpu.pc.value, 0);\n        assert_eq!(cpu.f.value, 0);\n        assert_eq!(cpu.c.value, 10);\n    }", "item_id": 21, "repo": "TheLocust3/simple-virtual-machine", "file": "emu/tests/executor_register_tests.rs", "last_update_at": "2019-02-18T04:28:41+00:00"}
{"hexsha": "1d7205e2c4cf31cc23d270feb49066850ba1639e", "ext": "rs", "lang": "Rust", "content": "fn crypto_encrypt_decypt_success() {\n    // arrange\n    let crypto = Crypto::new().unwrap();\n\n    let client_id = b\"module1\";\n    let plaintext = b\"plaintext\";\n    let iv = b\"initialization vector\";\n\n    match crypto.create_key() {\n        Ok(_result) => assert!(true),\n        Err(_) => panic!(\"Create master key function returned error\"),\n    };\n\n    //act\n    let ciphertext = match crypto.encrypt(client_id, plaintext, iv) {\n        //assert\n        Ok(result) => result,\n        Err(_) => panic!(\"Encrypt function returned error\"),\n    };\n    assert_ne!(ciphertext.as_ref().len(), 0);\n\n    //act\n    let plaintext_result = match crypto.decrypt(client_id, ciphertext.as_ref(), iv) {\n        //assert\n        Ok(result) => result,\n        Err(_) => panic!(\"Decrypt function returned error\"),\n    };\n    assert_eq!(\n        plaintext,\n        plaintext_result.as_ref(),\n        \"Failure plaintext after decrypt did not match {:?} and {:?}\",\n        plaintext,\n        plaintext_result.as_ref()\n    );\n\n    let bad_client_id = b\"module2\";\n    match crypto.decrypt(bad_client_id, ciphertext.as_ref(), iv) {\n        //assert\n        Ok(_result) => panic!(\"Decrypt function returned unexpected success\"),\n        Err(_) => (),\n    };\n\n    let bad_iv = b\"inconsistent_iv\";\n    match crypto.decrypt(client_id, ciphertext.as_ref(), bad_iv) {\n        //assert\n        Ok(_result) => panic!(\"Decrypt function returned unexpected success\"),\n        Err(_) => (),\n    };\n\n    // cleanup\n    match crypto.destroy_key() {\n        Ok(_result) => assert!(true),\n        Err(_) => panic!(\"Destroy master key function returned error\"),\n    };\n}", "item_id": 0, "repo": "ngi644/iotedge", "file": "edgelet/edgelet-hsm/tests/crypto_encrypt_decrypt_success.rs", "last_update_at": "2019-03-22T13:38:47+00:00"}
{"hexsha": "893e26f9cd6149860f4273adaa5bdb87a286db0a", "ext": "rs", "lang": "Rust", "content": "fn router(logger: slog::Logger, cfg: config::Config, irc: Box<irc::IrcWriter + Send>) -> Router {\n    let state = AppState {\n        logger: Arc::new(logger),\n        cfg: Arc::new(RwLock::new(cfg)),\n        irc: Arc::new(Mutex::new(irc)),\n    };\n\n    let middleware = StateMiddleware::new(state);\n\n    // create a middleware pipeline from our middleware\n    let pipeline = single_middleware(middleware);\n\n    // construct a basic chain from our pipeline\n    let (chain, pipelines) = single_pipeline(pipeline);\n\n    // build a router with the chain & pipeline\n    build_router(chain, pipelines, |route| {\n        route.post(\"/gitlab\").to(handle_gitlab);\n    })\n}", "item_id": 0, "repo": "abbec/raccoon", "file": "src/main.rs", "last_update_at": "2019-07-31T01:41:04+00:00"}
{"hexsha": "0b458401e1b7d5cf9a66d03576d5655663a69e37", "ext": "rs", "lang": "Rust", "content": "fn test_normalization() {\n    assert_eq!(huifier::huify(\"\"), \"\u0425\u0443\u0439\");\n    assert_eq!(huifier::huify(\" \"), \"\u0425\u0443\u0439\");\n    assert_eq!(huifier::huify(\"   \"), \"\u0425\u0443\u0439\");\n    assert_eq!(huifier::huify(\"  \u0412\u0438\u043b\u043a\u0430  \"), \"\u0425\u0443\u0438\u043b\u043a\u0430\");\n    assert_eq!(huifier::huify(\"\u0419\"), \"\u0425\u0443\u0439\");\n    assert_eq!(huifier::huify(\"\u041e\"), \"\u0425\u0443\u0451\");\n}", "item_id": 3, "repo": "kefir500/huifier", "file": "rust/tests/huifier_test.rs", "last_update_at": "2019-11-04T13:04:17+00:00"}
{"hexsha": "0db53506213438afcfd9c2bded69626c73d1403b", "ext": "rs", "lang": "Rust", "content": "fn test_dual_convergence() {\n        let c1 = FnResidual::new(1e-4);\n        let c2 = DeltaX::new(1e-9);\n        let c = DualCriteria::new(&c1, &c2);\n\n        // neither c1 nor c2\n        let x_0 = -3.7;\n        assert_eq!(false, c.is_converged(x_0, x_0 + 1.0, 113456.987));\n\n        // c1 but not c2\n        assert_eq!(false, c.is_converged(x_0, x_0 + 5e-10, 113456.987));\n\n        // c2 but not c1\n        assert_eq!(false, c.is_converged(x_0, x_0 + 1.0, 0.00008));\n\n        // both c1 and c2\n        assert_eq!(true, c.is_converged(0.0, 1e-10, 0.00008));\n    }", "item_id": 2, "repo": "nieksand/rootfind", "file": "src/convergence.rs", "last_update_at": "2019-08-27T11:01:10+00:00"}
{"hexsha": "8494e71f88ab6613fb56f6f14e886aa65e4aefe3", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn environment_set_decimal(env: *mut ASTEnvironment,\n                                          name: *const c_char,\n                                          value: f64) {\n    let environment = unsafe { &mut *env };\n    let key: String = unsafe { CStr::from_ptr(name).to_string_lossy().into_owned() };\n\n    environment.set(key.as_str(), Lit::Decimal(value));\n}", "item_id": 2, "repo": "DarinM223/yamlate", "file": "src/ffi/environment.rs", "last_update_at": "2019-01-13T11:36:37+00:00"}
{"hexsha": "51cf295daa4895d161c50a095a69e7784e638f6f", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn handle_device_removed(mut backend:\n                                               *mut wlr_libinput_backend,\n                                           mut libinput_dev:\n                                               *mut libinput_device) {\n    let mut wlr_devices: *mut wl_list =\n        libinput_device_get_user_data(libinput_dev) as *mut wl_list;\n    let mut vendor: libc::c_int =\n        libinput_device_get_id_vendor(libinput_dev) as libc::c_int;\n    let mut product: libc::c_int =\n        libinput_device_get_id_product(libinput_dev) as libc::c_int;\n    let mut name: *const libc::c_char =\n        libinput_device_get_name(libinput_dev);\n    _wlr_log(WLR_DEBUG,\n             b\"[%s:%d] Removing %s [%d:%d]\\x00\" as *const u8 as\n                 *const libc::c_char,\n             b\"../backend/libinput/events.c\\x00\" as *const u8 as\n                 *const libc::c_char, 208i32, name, vendor, product);\n    if wlr_devices.is_null() { return }\n    let mut dev: *mut wlr_input_device = 0 as *mut wlr_input_device;\n    let mut tmp_dev: *mut wlr_input_device = 0 as *mut wlr_input_device;\n    dev =\n        ((*wlr_devices).next as *mut libc::c_char).offset(-88) as\n            *mut wlr_input_device;\n    tmp_dev =\n        ((*dev).link.next as *mut libc::c_char).offset(-88) as\n            *mut wlr_input_device;\n    while &mut (*dev).link as *mut wl_list != wlr_devices {\n        wlr_input_device_destroy(dev);\n        dev = tmp_dev;\n        tmp_dev =\n            ((*dev).link.next as *mut libc::c_char).offset(-88) as\n                *mut wlr_input_device\n    }\n    let mut i: size_t = 0i32 as size_t;\n    while i < (*backend).wlr_device_lists.length {\n        if *(*backend).wlr_device_lists.items.offset(i as isize) ==\n               wlr_devices as *mut libc::c_void {\n            wlr_list_del(&mut (*backend).wlr_device_lists, i);\n            break ;\n        } else { i = i.wrapping_add(1) }\n    }\n    free(wlr_devices as *mut libc::c_void);\n}", "item_id": 5, "repo": "RoastVeg/wlrusts", "file": "src/backend/libinput/events.rs", "last_update_at": "2019-12-10T16:29:26+00:00"}
{"hexsha": "862f0f0cb9bd34f3b4ddb8afdc7dcc3abdec80c9", "ext": "rs", "lang": "Rust", "content": "fn run_import_command<'a>(args: &ArgMatches<'a>) -> Result<(), CliError> {\n    let ctx = create_context()?;\n    let blockstore = open_blockstore(&ctx)?;\n\n    let filepath = args\n        .value_of(\"blockfile\")\n        .ok_or_else(|| CliError::ArgumentError(\"No file\".into()))?;\n    let mut file = File::open(filepath)\n        .map_err(|err| CliError::EnvironmentError(format!(\"Failed to open file: {}\", err)))?;\n    let mut packed = Vec::new();\n    file.read_to_end(&mut packed)\n        .map_err(|err| CliError::EnvironmentError(format!(\"Failed to read file: {}\", err)))?;\n\n    let block: Block = protobuf::parse_from_bytes(&packed)\n        .map_err(|err| CliError::ParseError(format!(\"{}\", err)))?;\n    let block_header: BlockHeader = protobuf::parse_from_bytes(&block.header)\n        .map_err(|err| CliError::ParseError(format!(\"{}\", err)))?;\n    let block_id = block.header_signature.clone();\n\n    // Ensure this block is an immediate child of the current chain head\n    match blockstore.get_chain_head() {\n        Ok(chain_head) => {\n            if block_header.previous_block_id != chain_head {\n                return Err(CliError::ArgumentError(format!(\n                    \"New block must be an immediate child of the current chain head: {}\",\n                    chain_head\n                )));\n            }\n        }\n        Err(DatabaseError::NotFoundError(_)) => (),\n        Err(err) => {\n            return Err(CliError::EnvironmentError(format!(\"{}\", err)));\n        }\n    }\n\n    blockstore.put(&block).map_err(|err| {\n        CliError::ArgumentError(format!(\"Failed to put block into database: {}\", err))\n    })?;\n\n    println!(\"Block {} added\", block_id);\n    Ok(())\n}", "item_id": 6, "repo": "Capco-JayPanicker123/Sawtooth", "file": "adm/src/commands/blockstore.rs", "last_update_at": "2019-10-23T14:32:31+00:00"}
{"hexsha": "ff59c7ea7617a563fc51b5b5692cc80137be391a", "ext": "rs", "lang": "Rust", "content": "fn test_minus_equals() {\n        let s = to_chars(\"-=\");\n        let cur = &mut 0;\n        expect_next_token(&s, cur, Token::MinusEquals);\n    }", "item_id": 18, "repo": "jalextowle/solfix", "file": "src/lex_4_25.rs", "last_update_at": "2019-06-12T10:41:50+00:00"}
{"hexsha": "a50ac8eaf12cd8bc570c3cd645e26d649f1a20f1", "ext": "rs", "lang": "Rust", "content": "fn test_links() {\n        let mut i = 3usize;\n        while i < 512 {\n            dbg!(i, format!(\"{:032b}\", i));\n            i = next_fwd(i);\n        }\n\n        let mut i = 7usize;\n        while i > 0 {\n            dbg!(i, format!(\"{:032b}\", i));\n            i = next_bwd(i);\n        }\n    }", "item_id": 1, "repo": "feb29/cwt", "file": "src/fenwick.rs", "last_update_at": "2019-08-06T00:42:06+00:00"}
{"hexsha": "ae40e35935b9c79c3de52a08d8bab950d2c150bd", "ext": "rs", "lang": "Rust", "content": "fn import_donorbox(ledger: &mut Ledger, data: &PathBuf) {\n    let stripe = ledger\n        .get_account(\"Stripe\")\n        .expect(\"Account for Stripe not found\");\n\n    let paypal = ledger\n        .get_account(\"PayPal\")\n        .expect(\"Account for PayPal not found\");\n\n    let known_donations: Vec<DonationID> = stripe\n        .transactions\n        .iter()\n        .chain(&paypal.transactions)\n        .filter_map(|x| match &x.meta {\n            TransactionMetadata::Income {\n                kind: IncomeKind::Donation(x),\n                ..\n            } => Some(x),\n            _ => None,\n        })\n        .map(Clone::clone)\n        .collect();\n\n    let mut donations_stripe: Vec<Transaction> = Vec::new();\n    let mut donations_paypal: Vec<Transaction> = Vec::new();\n\n    let mut reader = csv::Reader::from_path(data).expect(\"Could not read the CSV file\");\n\n    let records = reader.deserialize();\n    for (i, x) in records.enumerate() {\n        let x: DonorBoxRow =\n            x.unwrap_or_else(|e| panic!(\"Could not deserialize entry on entry {}!\\n{}\", i, e));\n        let mut amount = currency::Currency::from_str(&x.amount)\n            .unwrap_or_else(|e| panic!(\"Could not parse transaction amount on entry {}!\\n{}\", i, e));\n        let mut fee = currency::Currency::from_str(&x.fee)\n            .unwrap_or_else(|e| panic!(\"Could not parse fee on entry {}!\\n{}\", i, e));\n        let date = chrono::Utc\n            .datetime_from_str(&x.date.trim_end_matches(\" UTC\"), \"%Y-%m-%d %H:%M:%S\")\n            .unwrap_or_else(|e| panic!(\"Could not parse transaction date on entry {}!\\n{}\", i, e));\n\n        amount.set_symbol('$');\n        fee.set_symbol('$');\n\n        let mut hasher = crypto::sha2::Sha256::new();\n        hasher.input_str(\"DonorBox\");\n        hasher.input_str(&x.name);\n        hasher.input_str(&x.date);\n        hasher.input_str(&x.amount);\n        hasher.input_str(&x.receipt);\n\n        let mut hash = vec![0; 32];\n        hasher.result(&mut hash);\n\n        if !known_donations.contains(&hash) {\n            let meta = TransactionMetadata::Income {\n                kind: IncomeKind::Donation(hash),\n                from: x.name.to_owned(),\n            };\n\n            match x.processor.as_ref() {\n                \"stripe\" => {\n                    donations_stripe.push(Transaction {\n                        amount,\n                        date,\n                        meta,\n                        description: \"Donation made through the DonorBox platform\".to_owned(),\n                        fees: vec![Fee {\n                            amount: fee,\n                            towards: \"DonorBox Processing\".to_owned(),\n                        }],\n                    });\n                }\n                \"paypal\" | \"paypal_express\" => {\n                    donations_paypal.push(Transaction {\n                        amount,\n                        date,\n                        meta,\n                        description: \"Donation made through the DonorBox platform\".to_owned(),\n                        fees: vec![Fee {\n                            amount: fee,\n                            towards: \"DonorBox Processing\".to_owned(),\n                        }],\n                    });\n                }\n                mtd => println!(\"WARNING: Unknown donation method `{}` for donation from `{}` on {} (entry {}).\", mtd, x.name, x.date, i),\n            }\n        } else {\n            println!(\n                \"WARNING: Donation from `{}` on {} (entry {}) is already in the ledger.\",\n                x.name, x.date, i\n            );\n        }\n    }\n\n    donations_stripe.sort_by(|x, y| x.date.cmp(&y.date));\n    ledger\n        .get_account_mut(\"Stripe\")\n        .expect(\"Account for Stripe not found\")\n        .transactions\n        .append(&mut donations_stripe);\n\n    donations_paypal.sort_by(|x, y| x.date.cmp(&y.date));\n    ledger\n        .get_account_mut(\"PayPal\")\n        .expect(\"Account for PayPal not found\")\n        .transactions\n        .append(&mut donations_paypal);\n}", "item_id": 2, "repo": "fhaynes/backertrack", "file": "src/ledger/donations.rs", "last_update_at": "2019-02-21T17:20:19+00:00"}
{"hexsha": "8da5c467b3fa5aa2cbcfc9d5127dc5dc89fc64d9", "ext": "rs", "lang": "Rust", "content": "fn empty_read() {\n        let mut recv = RecvBuf::new(std::usize::MAX);\n        assert_eq!(recv.len(), 0);\n\n        let mut buf = [0; 32];\n\n        assert_eq!(recv.pop(&mut buf), Err(Error::Done));\n    }", "item_id": 0, "repo": "quininer/quiche", "file": "src/stream.rs", "last_update_at": "2019-10-21T21:04:57+00:00"}
{"hexsha": "7810d7c3173239d6be3550ae2aa616701babc34b", "ext": "rs", "lang": "Rust", "content": "async fn backpressure_basic()\n{\n\tCOUNTER.with( |c| c.store( 0, Ordering::SeqCst ) );\n\n\tlet (server, client) = Endpoint::pair( 64, 64 );\n\n\tlet peera = async move\n\t{\n\t\t// Create mailbox for our handler\n\t\t//\n\t\tlet slow  = Addr::builder().spawn_local( Slow , &AsyncStd ).expect( \"spawn actor mailbox\" );\n\t\tlet slow2 = Addr::builder().spawn_local( Slow , &AsyncStd ).expect( \"spawn actor mailbox\" );\n\t\tlet after = Addr::builder().spawn_local( After, &AsyncStd ).expect( \"spawn actor mailbox\" );\n\n\t\t// Create a service map\n\t\t//\n\t\tlet mut sm = bpsm::Services::new();\n\n\t\t// Register our handlers\n\t\t//\n\t\tsm.register_handler::<Add >( slow .clone_box() );\n\t\tsm.register_handler::<Add2>( slow2.clone_box() );\n\t\tsm.register_handler::<Show>( after.clone_box() );\n\n\t\t// create peer with stream/sink\n\t\t//\n\t\tlet (mut peer, peer_mb, _peer_addr) = CborWF::create_peer\n\t\t(\n\t\t\t\"server\", server,\n\t\t\t1024, 1024,\n\t\t\tAsyncStd,\n\t\t\tSome(Arc::new( Semaphore::new(2) )),\n\t\t\tNone\n\n\t\t).expect( \"spawn peer\" );\n\n\n\t\t// register service map with peer\n\t\t//\n\t\tpeer.register_services( Arc::new( sm ) );\n\n\t\tlet handle = AsyncStd.spawn_handle_local( peer_mb.start(peer) ).expect( \"start mailbox of Peer\" );\n\t\thandle.await;\n\n\t\ttrace!( \"end of peera\" );\n\t};\n\n\n\tlet peerb = async move\n\t{\n\t\tlet (mut peera, _)  = peer_connect( client, AsyncStd, \"peer_b_to_peera\" ).await;\n\n\t\t// Call the service and receive the response\n\t\t//\n\t\tlet mut addr  = bpsm::RemoteAddr::new( peera.clone() );\n\t\tlet mut addr2 = addr.clone();\n\t\tlet mut addr3 = addr.clone();\n\n\t\tlet add1 = async move { addr .call( Add (1) ).await.expect( \"call add1\"  ) };\n\t\tlet add2 = async move { addr2.call( Add2(1) ).await.expect( \"call add2\"  ) };\n\t\tlet show = async move { addr3.call( Show    ).await.expect( \"call check\" ) };\n\n\t\tlet add1_handle = AsyncStd.spawn_handle_local( add1 ).expect( \"spawn add1\"  );\n\t\tlet add2_handle = AsyncStd.spawn_handle_local( add2 ).expect( \"spawn add2\"  );\n\n\t\t// We must make sure the adds are send before the show, but spawning is not deterministic.\n\t\t//\n\t\tDelay::new( Duration::from_millis(20) ).await;\n\t\tlet show_handle = AsyncStd.spawn_handle_local( show ).expect( \"spawn check\" );\n\n\t\tadd1_handle.await;\n\t\tadd2_handle.await;\n\n\t\t// Add1 should be guaranteed to have finished and updated the counter to 1 before\n\t\t// show can run due to back pressure. As add2 has a longer timeout, it shouldn't have\n\t\t// run yet.\n\t\t//\n\t\tassert_eq!( show_handle.await, 1 );\n\n\t\tpeera.send( CloseConnection{ remote: false, reason: \"Program end.\".to_string() } ).await.expect( \"close connection to peera\" );\n\t};\n\n\n\t// As far as I can tell, execution order is not defined, so hmm, there is no\n\t// guarantee that a is listening before b tries to connect, but it seems to work for now.\n\t//\n\tjoin( peera, peerb ).await;\n}", "item_id": 0, "repo": "thespis-rs/thespis_impl_remote", "file": "tests/backpressure.rs", "last_update_at": "2019-06-19T20:00:34+00:00"}
{"hexsha": "4ce4fa3770f043bf602d3076f9b8b92b67fad2ea", "ext": "rs", "lang": "Rust", "content": "fn run_meal_server(listen_address: &str,\n                   i_transport_factory: Box<TTransportFactory>,\n                   i_protocol_factory: Box<TInputProtocolFactory>,\n                   o_transport_factory: Box<TTransportFactory>,\n                   o_protocol_factory: Box<TOutputProtocolFactory>)\n                   -> thrift::Result<()> {\n    let processor = MealServiceSyncProcessor::new(PartHandler {});\n    let mut server = TSimpleServer::new(i_transport_factory,\n                                        i_protocol_factory,\n                                        o_transport_factory,\n                                        o_protocol_factory,\n                                        processor);\n\n    server.listen(listen_address)\n}", "item_id": 1, "repo": "przygienda/thrift-rust-thrift-include-and-custom-trait-support", "file": "lib/rs/test/src/bin/kitchen_sink_server.rs", "last_update_at": "2019-03-19T15:47:42+00:00"}
{"hexsha": "9aacdbe51d873bcdceab2a7cc16e8a62fda74071", "ext": "rs", "lang": "Rust", "content": "fn slice_x1000(b: &mut Bencher) {\n    let buf = HeapRb::<u64>::new(RB_SIZE);\n    let (mut prod, mut cons) = buf.split();\n    prod.push_slice(&[1; 12]);\n    let mut data = [1; 1000];\n    b.iter(|| {\n        prod.push_slice(&data);\n        cons.pop_slice(&mut data);\n    });\n    black_box(data);\n}", "item_id": 2, "repo": "nthend/ringbuf", "file": "src/benchmarks/slice.rs", "last_update_at": "2019-08-14T13:35:13+00:00"}
{"hexsha": "927c269aa7f041cc059ea7bae05a9da3f8a70ad7", "ext": "rs", "lang": "Rust", "content": "fn test_eval_int(){\n        use std::fs;\n        let unparsed_query = fs::read_to_string(\"tests/data/qfuflia.smt2\").expect(\"cannot read file\");\n        let mut query = Query::new();\n        query.parse_query(&unparsed_query).expect(\"cannot parse file\");\n        \n        let unparsed_answer = fs::read_to_string(\"tests/data/qfuflia_result.smt2\").expect(\"cannot read file\");\n        let s = query.parse_answer(&unparsed_answer).expect(\"cannot parse file\");\n        assert!(query.eval(&s).unwrap());\n    }", "item_id": 0, "repo": "FedericoAureliano/llama", "file": "src/evl/mod.rs", "last_update_at": "2019-12-15T06:32:59+00:00"}
{"hexsha": "0666d72748aed0aa7b92794f5c4831a43dcbd431", "ext": "rs", "lang": "Rust", "content": "pub fn keygen() -> [u8; KEY] {\n    let mut k = [0u8; KEY];\n    crypto_random(&mut k);\n    k\n}", "item_id": 3, "repo": "oniproject/tto", "file": "src/crypto/mod.rs", "last_update_at": "2019-12-04T21:29:43+00:00"}
{"hexsha": "3a7845b9ce83d59a7ac3a5d0a07ef9559b8e0d9f", "ext": "rs", "lang": "Rust", "content": "pub fn is_lambda() -> bool {\n    #[cfg(feature = \"local\")]\n    {\n        std::env::var_os(\"AWS_LAMBDA_RUNTIME_API\").is_some()\n    }\n\n    #[cfg(not(feature = \"local\"))]\n    {\n        true\n    }\n}", "item_id": 1, "repo": "Skirmisher/lambda-http-local", "file": "src/lib.rs", "last_update_at": "2019-05-26T23:10:33+00:00"}
{"hexsha": "56c98fa0761a4f26afa8494785b0973862ea2945", "ext": "rs", "lang": "Rust", "content": "pub fn load_block_report(path: &str) -> Result<BlockReport> {\n    println!(\"Reading BlockReport from blocks.json\");\n    let block_report = read_to_string(path).context(\"blocks report `blocks.json` not found\")?;\n    serde_json::from_str::<BlockReport>(&block_report).map_err(|err| err.into())\n}", "item_id": 0, "repo": "fredsterorg/feather", "file": "libcraft/generators/src/common.rs", "last_update_at": "2019-11-01T20:06:33+00:00"}
{"hexsha": "a50fef61e9c80433c5337e43ef2b50fa0e7fad72", "ext": "rs", "lang": "Rust", "content": "fn knights_in_corners() {\n    let knights = Square::from_pos(Rank::A, File::First).as_bb()\n        | Square::from_pos(Rank::H, File::Eighth).as_bb();\n    let attacks = attack_targets(knights);\n    assert_eq!(0x0020400000020400, attacks.0);\n}", "item_id": 1, "repo": "nagyf/rs-chess", "file": "src/engine/board/piece/knight/tests.rs", "last_update_at": "2019-03-23T10:31:21+00:00"}
{"hexsha": "8575b68d0fa746beecb98c7add4a8f904d5f4f05", "ext": "rs", "lang": "Rust", "content": "pub fn get_last_segid_stakes(\n    SomeUser: komodorpcutil::KomodoRPC,\n    depth: u32,\n) -> Result<String, reqwest::Error> {\n    let method_name: String = String::from(\"getlastsegidstakes\");\n    let method_body: String = String::from(format!(\"[{}]\", depth));\n    let data: String = String::from(komodorpcutil::generate_body(\n        SomeUser.clone(),\n        method_name,\n        method_body,\n    ));\n    komodorpcutil::request(SomeUser.clone(), data)\n}", "item_id": 11, "repo": "sudipghale/Komodo-RPC-API-Rust", "file": "src/komodo/blockchain.rs", "last_update_at": "2019-12-07T03:17:44+00:00"}
{"hexsha": "793c4bcf09ef5b7b6fc9e715a78847c15658f9b5", "ext": "rs", "lang": "Rust", "content": "fn relay_addr(\n    json_cfg: &str,\n) -> Result<String, Error> {\n    let config = MobileWalletCfg::from_str(json_cfg)?;\n    let wallet = get_wallet_instance(config.clone())?;\n    Ok(grinrelay_address(\n        wallet.clone(),\n        config.grinrelay_config.clone().unwrap_or_default(),\n    )?)\n}", "item_id": 28, "repo": "garyyu/grinwallet-nodejs", "file": "native/src/lib.rs", "last_update_at": "2019-11-09T09:19:19+00:00"}
{"hexsha": "332f83b92e5efc550367fadde9ff23955e525dd6", "ext": "rs", "lang": "Rust", "content": "fn test_generate_continuous() {\n        let grad_desc = color::GradientDescriptor::new(vec![\n            Lch::from_color(color::ColorType::new(0., 0., 0., 1.)),\n            Lch::from_color(color::ColorType::new(0.5, 0.5, 0.5, 1.)),\n            Lch::from_color(color::ColorType::new(1., 1., 1., 1.)),\n        ]);\n\n        let colors = grad_desc.generate(12, color::GradientGeneratorType::Continuous);\n        assert_eq!(colors.len(), 12);\n\n        assert_eq!(colors[0].chroma, 0.0);\n        assert_eq!(colors[4].chroma, 0.0);\n        assert_eq!(colors[8].chroma, 0.0);\n    }", "item_id": 3, "repo": "jwoos/go_rainbowgif", "file": "src/color.rs", "last_update_at": "2019-04-23T05:10:19+00:00"}
{"hexsha": "0bb0cd84432a73281ff4d9a3f145225979d07bcb", "ext": "rs", "lang": "Rust", "content": "async fn newterm(item: web::Json<Term>) -> Result<HttpResponse> {\n    let Term { word, lambda: _ } = item.into_inner();\n    let lambda = match lightblue(&word) {\n        Ok(lambda) => lambda,\n        Err(error) => {\n            let error_msg = format!(\"{:?}\", error);\n            return Ok(HttpResponse::InternalServerError().body(error_msg));\n        }\n    };\n    let ret_term = Term { word, lambda };\n    Ok(HttpResponse::Ok().json(ret_term))\n}", "item_id": 0, "repo": "denjiry/pindilogji", "file": "pindilogji-server/src/main.rs", "last_update_at": "2019-08-03T16:54:25+00:00"}
{"hexsha": "470b6e8f11f1eb1b64b8a5753f071a6be0cc57b7", "ext": "rs", "lang": "Rust", "content": "pub unsafe fn list_node_at(l: *const list, mut index: libc::c_uint) -> *mut node {\n    /* if there's no data in the list, fail */\n    if (*l).list.is_null() {\n        return 0 as *mut node;\n    } else {\n        let mut current: *mut node = (*l).list;\n        while index > 0i32 as libc::c_uint {\n            if (*current).next.is_null() {\n                return 0 as *mut node;\n            } else {\n                current = (*current).next;\n                index = index.wrapping_sub(1)\n            }\n        }\n        return current;\n    };\n}", "item_id": 2, "repo": "palfrey/ashuffle-rs", "file": "src/list.rs", "last_update_at": "2019-05-03T14:43:08+00:00"}
{"hexsha": "e62053eb29d1ca24129f50b429669912dabb72ac", "ext": "rs", "lang": "Rust", "content": "fn put_var_uint(&mut self, uint: u64) {\n        let size = predict_var_uint_size(uint);\n        self.put_var_octet_string_length(size);\n        self.put_uint_be(uint, size);\n    }", "item_id": 2, "repo": "pensivej/interledger-rs", "file": "crates/interledger-packet/src/oer.rs", "last_update_at": "2019-08-06T07:59:44+00:00"}
{"hexsha": "8a18ef3dfa3e641a7a4affec16f2333c7cb41eaa", "ext": "rs", "lang": "Rust", "content": "fn assign(\n    context: &mut Context,\n    result: &mut Block,\n    sp!(loc, ta_): T::Assign,\n    rvalue_ty: &H::SingleType,\n) -> ReachableResult<(H::LValue, Block)> {\n    use H::{LValue_ as L, UnannotatedExp_ as E};\n    use T::Assign_ as A;\n    let mut after = Block::new();\n    let l_ = match ta_ {\n        A::Ignore => L::Ignore,\n        A::Var(v, st) => L::Var(\n            context.remapped_local(v),\n            Box::new(single_type(context, st)),\n        ),\n        A::Unpack(_m, s, tbs, tfields) => {\n            let bs = base_types(context, tbs);\n\n            let mut fields = vec![];\n            for (decl_idx, f, bt, tfa) in assign_fields(context, &s, tfields) {\n                assert!(fields.len() == decl_idx);\n                let st = &H::SingleType_::base(bt);\n                let (fa, mut fafter) = match assign(context, result, tfa, st) {\n                    Unreachable { report, loc } => return Unreachable { report, loc },\n                    Reachable(res) => res,\n                };\n                after.append(&mut fafter);\n                fields.push((f, fa))\n            }\n            L::Unpack(s, bs, fields)\n        }\n        A::BorrowUnpack(mut_, _m, s, _tss, tfields) => {\n            let tmp = context.new_temp(loc, rvalue_ty.clone());\n            let copy_tmp = || {\n                let copy_tmp_ = E::Copy {\n                    from_user: false,\n                    var: tmp.clone(),\n                };\n                H::exp(H::Type_::single(rvalue_ty.clone()), sp(loc, copy_tmp_))\n            };\n            let fields = assign_fields(context, &s, tfields).into_iter().enumerate();\n            for (idx, (decl_idx, f, bt, tfa)) in fields {\n                assert!(idx == decl_idx);\n                let floc = tfa.loc;\n                let borrow_ = E::Borrow(mut_, Box::new(copy_tmp()), f);\n                let borrow = H::exp(H::Type_::base(bt), sp(floc, borrow_));\n                match assign_command(context, &mut after, floc, sp(floc, vec![tfa]), borrow) {\n                    Unreachable { report, loc } => return Unreachable { report, loc },\n                    Reachable(()) => (),\n                };\n            }\n            L::Var(tmp, Box::new(rvalue_ty.clone()))\n        }\n    };\n    Reachable((sp(loc, l_), after))\n}", "item_id": 15, "repo": "marciseli/libra", "file": "language/move-lang/src/hlir/translate.rs", "last_update_at": "2019-07-11T21:59:32+00:00"}
{"hexsha": "ad88834532221493e9aed8fbbd37c0207d11156b", "ext": "rs", "lang": "Rust", "content": "fn ind_mut() {\n    let mut x = RwLockStorage::new();\n    x.allocate_for::<usize>();\n    x.insert(0usize).unwrap();\n    x.insert(1usize).unwrap();\n    {\n        let y = x.get::<&mut [usize]>();\n        ok!(y, 0, [0])[0] = 10;\n    }\n    {\n        let y = x.get::<&mut [usize]>();\n        ok!(y, 1, [1]);\n    }\n    {\n        let y = x.get::<&mut [usize]>();\n        let z = x.get::<&mut [usize]>();\n        err!(z, ErrorDesc::BorrowedIncompatibly);\n        ok!(y, 10, [0]);\n    }\n}", "item_id": 8, "repo": "OptimisticPeach/restor", "file": "tests/rwlock.rs", "last_update_at": "2019-08-08T12:08:36+00:00"}
{"hexsha": "35cb44c1572d5b6f29c6b4f71d50258804b87694", "ext": "rs", "lang": "Rust", "content": "fn observables_csv(observables: &ObservablesOutput, project: &str) -> Result<()> {\n    let filename = format!(\n        \"{}/observables_{}.csv\",\n        get_project_dir(project),\n        observables.state\n    );\n    let mut buffer = csv::Writer::from_path(&filename)\n        .chain_err(|| ErrorKind::CreateFile(filename.to_string()))?;\n    buffer\n        .serialize(observables)\n        .chain_err(|| ErrorKind::Serialize)?;\n    buffer.flush().chain_err(|| ErrorKind::Flush)?;\n    Ok(())\n}", "item_id": 18, "repo": "Libbum/Wafer", "file": "src/output.rs", "last_update_at": "2019-11-29T12:45:29+00:00"}
{"hexsha": "3cbe789fd0fb7cd7d9ee871974f5002a9a73c56c", "ext": "rs", "lang": "Rust", "content": "fn null_key() {\n        let mut hm = BTreeMap::new();\n        let lol: Option<i32> = None;\n        hm.insert(lol, 1337);\n        let tr = to_transit_json(hm);\n\n        assert_eq!(json!([\"^\", \"~_\", 1337]), tr);\n    }", "item_id": 5, "repo": "fominok/transit-rs", "file": "src/ser/json.rs", "last_update_at": "2019-06-23T09:38:53+00:00"}
{"hexsha": "531b10ba9ca02ffba834fe974f8d3154387ef543", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let s = [120, 0].into();\n    println!(\"{}\", s);\n    // let four_k_bytes = 1024 * 4;\n    // let f = File::open(\"aidans_theme-inst.wav\").unwrap();\n    // let mut buf: Vec<u8> = Vec::<u8>::with_capacity(four_k_bytes);\n\n    // let mut i = 0;\n\n    // for byte in f.bytes() {\n    //     buf.push(byte.unwrap());\n    //     i += 1;\n    //     if i % four_k_bytes == 0 {\n    //         println!(\"{}K bytes read\", i / four_k_bytes);\n    //     }\n    // }\n\n    // println!(\"Length: {}\", buf.len());\n    // let mut reader = BufReader::with_capacity(4, f);\n\n    // loop {\n    //     match reader.fill_buf() {\n    //         Ok(_) => println!(\"{:?}\", reader.buffer()),\n    //         _ => break\n    //     }\n    // }\n}", "item_id": 0, "repo": "bnert/monorepo", "file": "projects/learning-rust/filereader.rs", "last_update_at": "2019-10-28T22:48:39+00:00"}
{"hexsha": "8963703e3db3eddc9448e90979b0bb9fc667cf3a", "ext": "rs", "lang": "Rust", "content": "fn parsing() {\n        use super::ParseAmountError as E;\n        let tpc = Denomination::TPC;\n        let tap = Denomination::Tapyrus;\n        let p = Amount::from_str_in;\n        let sp = SignedAmount::from_str_in;\n\n        assert_eq!(p(\"x\", tpc), Err(E::InvalidCharacter('x')));\n        assert_eq!(p(\"-\", tpc), Err(E::InvalidFormat));\n        assert_eq!(sp(\"-\", tpc), Err(E::InvalidFormat));\n        assert_eq!(p(\"-1.0x\", tpc), Err(E::InvalidCharacter('x')));\n        assert_eq!(p(\"0.0 \", tpc), Err(ParseAmountError::InvalidCharacter(' ')));\n        assert_eq!(p(\"0.000.000\", tpc), Err(E::InvalidFormat));\n        let more_than_max = format!(\"1{}\", Amount::max_value());\n        assert_eq!(p(&more_than_max, tpc), Err(E::TooBig));\n        assert_eq!(p(\"0.000000042\", tpc), Err(E::TooPrecise));\n\n        assert_eq!(p(\"1\", tpc), Ok(Amount::from_tap(1_000_000_00)));\n        assert_eq!(sp(\"-.5\", tpc), Ok(SignedAmount::from_tap(-500_000_00)));\n        assert_eq!(p(\"1.1\", tpc), Ok(Amount::from_tap(1_100_000_00)));\n        assert_eq!(p(\"100\", tap), Ok(Amount::from_tap(100)));\n        assert_eq!(p(\"55\", tap), Ok(Amount::from_tap(55)));\n        assert_eq!(p(\"5500000000000000000\", tap), Ok(Amount::from_tap(5_500_000_000_000_000_000)));\n        // Should this even pass?\n        assert_eq!(p(\"5500000000000000000.\", tap), Ok(Amount::from_tap(5_500_000_000_000_000_000)));\n        assert_eq!(\n            p(\"12345678901.12345678\", tpc),\n            Ok(Amount::from_tap(12_345_678_901__123_456_78))\n        );\n\n        // make sure tapyrus > i64::max_value() is checked.\n        let amount = Amount::from_tap(i64::max_value() as u64);\n        assert_eq!(Amount::from_str_in(&amount.to_string_in(tap), tap), Ok(amount));\n        assert_eq!(Amount::from_str_in(&(amount+Amount(1)).to_string_in(tap), tap), Err(E::TooBig));\n\n        assert_eq!(p(\"12.000\", Denomination::MilliTapyrus), Err(E::TooPrecise));\n        // exactly 50 chars.\n        assert_eq!(p(\"100000000000000.0000000000000000000000000000000000\", Denomination::TPC), Err(E::TooBig));\n        // more than 50 chars.\n        assert_eq!(p(\"100000000000000.00000000000000000000000000000000000\", Denomination::TPC), Err(E::InputTooLarge));\n    }", "item_id": 5, "repo": "Yamaguchi/rust-tapyrus", "file": "src/util/amount.rs", "last_update_at": "2019-11-14T06:46:14+00:00"}
{"hexsha": "f247a6157004da3df73791c1bd17952df4a42af9", "ext": "rs", "lang": "Rust", "content": "fn test_case_insensitive() {\n        let a = Ascii(\"foobar\");\n        let b = Ascii(\"FOOBAR\");\n\n        assert_eq!(a, b);\n        assert_eq!(hash(&a), hash(&b));\n\n        assert_eq!(a, \"fooBar\");\n        assert_eq!(\"fooBar\", a);\n        assert_eq!(String::from(\"fooBar\"), a);\n        assert_eq!(a, String::from(\"fooBar\"));\n    }", "item_id": 1, "repo": "green-element-chain/rust-sgx-sdk", "file": "third_party/unicase/src/ascii.rs", "last_update_at": "2019-07-30T08:59:45+00:00"}
{"hexsha": "d6af236d4b20131e6524b3a278bba79785a70345", "ext": "rs", "lang": "Rust", "content": "pub fn prepare_share_change_session_plan(cluster_nodes: &BTreeSet<NodeId>, threshold: usize, key_id: &ServerKeyId, key_version: H256, master: &NodeId, old_key_version_owners: &BTreeSet<NodeId>, new_nodes_set: &BTreeSet<NodeId>) -> Result<ShareChangeSessionPlan, Error> {\n\t// we can't do anything if there are no enought shares\n\tif old_key_version_owners.len() < threshold + 1 {\n\t\twarn!(\"cannot add shares to key {} with threshold {}: only {} shares owners are available\",\n\t\t\tkey_id, threshold, old_key_version_owners.len());\n\t\treturn Ok(ShareChangeSessionPlan {\n\t\t\tkey_version: key_version,\n\t\t\tversion_holders: Default::default(),\n\t\t\tconsensus_group: Default::default(),\n\t\t\tnew_nodes_map: Default::default(),\n\t\t});\n\t}\n\n\t// warn if we're loosing the key\n\tif new_nodes_set.len() < threshold + 1 {\n\t\twarn!(\"losing key {} with threshold {}: only {} nodes left after servers set change session\",\n\t\t\tkey_id, threshold, new_nodes_set.len());\n\t}\n\n\t// make new nodes map, so that:\n\t// all non-isolated old nodes will have their id number preserved\n\t// all new nodes will have new id number\n\tlet mut new_nodes_map = new_nodes_set.difference(&old_key_version_owners)\n\t\t.map(|n| math::generate_random_scalar().map(|id| (n.clone(), Some(id))))\n\t\t.collect::<Result<BTreeMap<_, _>, _>>()?;\n\tif !new_nodes_map.is_empty() {\n\t\tfor old_node in old_key_version_owners.iter().filter(|n| cluster_nodes.contains(n)) {\n\t\t\tnew_nodes_map.insert(old_node.clone(), None);\n\t\t}\n\t}\n\n\t// select consensus group if there are some nodes to add\n\tlet consensus_group = if !new_nodes_map.is_empty() {\n\t\t\t::std::iter::once(master.clone())\n\t\t\t\t.chain(old_key_version_owners.iter()\n\t\t\t\t\t.filter(|n| *n != master && cluster_nodes.contains(*n))\n\t\t\t\t\t.take(threshold)\n\t\t\t\t\t.cloned())\n\t\t\t\t.collect()\n\t\t} else {\n\t\t\tBTreeSet::new()\n\t\t};\n\n\tOk(ShareChangeSessionPlan {\n\t\tkey_version: key_version,\n\t\tversion_holders: old_key_version_owners.clone(),\n\t\tconsensus_group: consensus_group,\n\t\tnew_nodes_map: new_nodes_map,\n\t})\n}", "item_id": 0, "repo": "altice-io/Daqiao", "file": "bridge/parity-ethereum/secret-store/src/key_server_cluster/admin_sessions/share_change_session.rs", "last_update_at": "2019-09-11T12:07:35+00:00"}
{"hexsha": "2533ac14e5a017e1a719eccfdaa05e7c6ee94ede", "ext": "rs", "lang": "Rust", "content": "fn append_vec_concurrent_get_append(bencher: &mut Bencher) {\n    let path = get_append_vec_bench_path(\"bench_get_append\");\n    let vec = Arc::new(RwLock::new(AppendVec::<AtomicUsize>::new(\n        &path, true, START_SIZE, INC_SIZE,\n    )));\n    let vec1 = vec.clone();\n    let size = 1_000_000;\n    let count = Arc::new(AtomicUsize::new(0));\n    let count1 = count.clone();\n    spawn(move || loop {\n        let mut len = count.load(Ordering::Relaxed);\n        {\n            let rlock = vec1.read().unwrap();\n            loop {\n                if rlock.append(AtomicUsize::new(0)).is_none() {\n                    break;\n                }\n                len = count.fetch_add(1, Ordering::Relaxed);\n            }\n            if len >= size {\n                break;\n            }\n        }\n        {\n            let mut wlock = vec1.write().unwrap();\n            if len >= size {\n                break;\n            }\n            assert!(wlock.grow_file().is_ok());\n        }\n    });\n    bencher.iter(|| {\n        let rlock = vec.read().unwrap();\n        let len = count1.load(Ordering::Relaxed);\n        if len > 0 {\n            let index = thread_rng().gen_range(0, len);\n            rlock.get((index * std::mem::size_of::<AtomicUsize>()) as u64);\n        }\n    });\n    std::fs::remove_file(path).unwrap();\n}", "item_id": 6, "repo": "abalaki6/solana", "file": "runtime/benches/append_vec.rs", "last_update_at": "2019-03-10T22:29:28+00:00"}
{"hexsha": "77efe572845f43de1875230da2a8de1297689d34", "ext": "rs", "lang": "Rust", "content": "fn test_thermal_parser() {\n    let test_data = include_str!(\"../tests/chassis-thermal.json\");\n    let result: Thermal = serde_json::from_str(&test_data).unwrap();\n    println!(\"result: {:#?}\", result);\n}", "item_id": 0, "repo": "cholcombe973/libredfish", "file": "src/thermal.rs", "last_update_at": "2019-09-17T03:56:17+00:00"}
{"hexsha": "6fb4663bd5897e58b347d5e9d64c66d596d2a8fc", "ext": "rs", "lang": "Rust", "content": "fn process_overspecified_remap() {\n        let mut mode_map = ModeMap::<u8, TestOp>::new();\n        assert_eq!(\n            InsertionResult::Create,\n            mode_map.insert_remap(vec![1u8, 1u8, 1u8], vec![2u8])\n        );\n\n        let mut typeahead = Typeahead::<u8>::new();\n        typeahead.push_back(1u8, RemapType::Remap);\n        typeahead.push_back(1u8, RemapType::Remap);\n\n        assert_eq!(Err(MapErr::NoMatch), mode_map.process(&mut typeahead));\n        assert_eq!(Some((1u8, RemapType::Remap)), typeahead.pop_front());\n        assert_eq!(Some((1u8, RemapType::Remap)), typeahead.pop_front());\n        assert_eq!(None, typeahead.pop_front());\n    }", "item_id": 7, "repo": "jakalope/vixi", "file": "src/mode_map.rs", "last_update_at": "2019-05-19T15:40:10+00:00"}
{"hexsha": "0ec973067cd91f723406dbffdd0912d59865edc6", "ext": "rs", "lang": "Rust", "content": "fn compare(a: &str, b: &str, operator: &CompOp) {\n        // Get both versions\n        let version_a: Version = a.parse().unwrap();\n        let version_b: Version = b.parse().unwrap();\n\n        // Compare them\n        assert_eq!(version_a.compare_version(&version_b), operator.clone(),);\n\n        // Compare them\n        assert_eq!(version_a.compare_str(b), operator.clone(),);\n    }", "item_id": 5, "repo": "msarahan/libronda", "file": "core/src/version/version.rs", "last_update_at": "2019-10-15T14:12:12+00:00"}
{"hexsha": "918dbc84e6d0449f3662fd1404138c56c47f1969", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // Compute the totient of the first 25 natural integers\n    println!(\"N\\t phi(n)\\t Prime\");\n    for n in 1..26 {\n        let phi_n = phi(n);\n        println!(\"{}\\t {}\\t {:?}\", n, phi_n, phi_n == n - 1);\n    }\n\n    // Compute the number of prime numbers for various steps\n    [1, 100, 1000, 10000, 100000]\n        .windows(2)\n        .scan(0, |acc, window| {\n            let (lower, upper) = (window[0], window[1]);\n            *acc += (lower..=upper).filter(is_prime).count();\n            Some((upper, *acc))\n        })\n        .for_each(|x| println!(\"Until {}: {} prime numbers\", x.0, x.1));\n}", "item_id": 0, "repo": "kaiuri/rust-rosetta", "file": "tasks/totient-function/src/main.rs", "last_update_at": "2019-09-05T06:56:04+00:00"}
{"hexsha": "28a61e0ae694670963b9349442b4f33323959f7e", "ext": "rs", "lang": "Rust", "content": "fn _null_chunk_slow<R>(mut rdr: R, max: Option<usize>) -> io::Result<Vec<u8>>\nwhere\n    R: io::Read,\n{\n    let mut buf = Vec::new();\n    let mut count = 0;\n    loop {\n        if let Some(max) = max {\n            if count > max {\n                break Err(io::ErrorKind::UnexpectedEof.into());\n            }\n        }\n\n        let byte = rdr.read_u8()?;\n        if byte != 0x00 {\n            buf.push(byte);\n            count += 1;\n        } else {\n            break Ok(buf);\n        }\n    }\n}", "item_id": 0, "repo": "viriuwu/minio", "file": "src/lib.rs", "last_update_at": "2019-10-29T20:31:47+00:00"}
{"hexsha": "139212fac6270a44a498f6036ea8c3fbb049d001", "ext": "rs", "lang": "Rust", "content": "fn test_lexer06() {\n        let input = \"t = {x = 3}\";\n        let tokens = &[\n            (Identifier, 0, 1),\n            (Assign, 2, 1),\n            (LCurly, 4, 1),\n            (Identifier, 5, 1),\n            (Assign, 7, 1),\n            (LiteralNumber, 9, 1),\n            (RCurly, 10, 1),\n        ];\n        check_line(input, tokens);\n    }", "item_id": 5, "repo": "OrangeChris/lua-in-rust", "file": "src/compiler/lexer.rs", "last_update_at": "2019-07-18T15:18:12+00:00"}
{"hexsha": "988c2c115995c18a31b43e2398f81c6df358924f", "ext": "rs", "lang": "Rust", "content": "fn test_VSMT_4_Verif() {\n        let width = 5;\n\n        let mut db = InMemoryHashDb::<DBVal_4_ary>::new();\n\n        #[cfg(feature = \"bls381\")]\n        let (full_b, full_e, partial_rounds) = (4, 4, 56);\n\n        #[cfg(feature = \"bn254\")]\n        let (full_b, full_e, partial_rounds) = (4, 4, 56);\n\n        #[cfg(feature = \"secp256k1\")]\n        let (full_b, full_e, partial_rounds) = (4, 4, 56);\n\n        #[cfg(feature = \"ed25519\")]\n        let (full_b, full_e, partial_rounds) = (4, 4, 56);\n\n        let total_rounds = full_b + partial_rounds + full_e;\n        let hash_params = PoseidonParams::new(width, full_b, full_e, partial_rounds);\n        let tree_depth = 12;\n        let mut tree = VanillaSparseMerkleTree_4::new(&hash_params, tree_depth, &mut db);\n\n        for i in 1..=10 {\n            let s = FieldElement::from(i as u32);\n            tree.update(&s, s.clone(), &mut db).unwrap();\n        }\n\n        // TODO: Use iterators. Generating so many generators at once is very slow. In practice, generators will be persisted.\n        let G: G1Vector = get_generators(\"G\", 8192).into();\n        let H: G1Vector = get_generators(\"H\", 8192).into();\n\n        let g = G1::from_msg_hash(\"g\".as_bytes());\n        let h = G1::from_msg_hash(\"h\".as_bytes());\n\n        for i in vec![3u32, 4u32, 7u32, 8u32, 9u32] {\n            let mut merkle_proof_vec = Vec::<ProofNode_4_ary>::new();\n            let mut merkle_proof = Some(merkle_proof_vec);\n            let k = FieldElement::from(i);\n            assert_eq!(k, tree.get(&k, &mut merkle_proof, &db).unwrap());\n            merkle_proof_vec = merkle_proof.unwrap();\n            assert!(tree.verify_proof(&k, &k, &merkle_proof_vec, Some(&tree.root)));\n\n            let mut rng = rand::thread_rng();\n\n            let sbox_type = &SboxType::Quint;\n\n            let label = b\"4-aryMerkleTree\";\n\n            let (proof, commitments) = gen_proof_of_leaf_inclusion_4_ary_merkle_tree(\n                k.clone(),\n                k.clone(),\n                None,\n                merkle_proof_vec,\n                &tree.root,\n                tree.depth,\n                &hash_params,\n                sbox_type,\n                Some(&mut rng),\n                label,\n                &g,\n                &h,\n                &G,\n                &H,\n            )\n            .unwrap();\n\n            verify_proof_of_leaf_inclusion_4_ary_merkle_tree(\n                &tree.root,\n                tree.depth,\n                &hash_params,\n                sbox_type,\n                proof,\n                commitments,\n                label,\n                &g,\n                &h,\n                &G,\n                &H,\n            )\n            .unwrap();\n        }\n    }", "item_id": 4, "repo": "lovesh/bulletproofs-amcl", "file": "src/r1cs/gadgets/sparse_merkle_tree_4_ary.rs", "last_update_at": "2019-04-03T21:19:03+00:00"}
{"hexsha": "42b615fb9dd49aedd97eda953019ec7cea74fcaf", "ext": "rs", "lang": "Rust", "content": "fn returns_no_objects_when_empty() {\n        let world = box WorldMock::new();\n        let simulation = SimulationImpl::new(\n            world,\n            box world_interactor_factory_fn,\n            box instant_wrapper_factory_fn,\n        );\n        let objects = simulation.objects();\n        assert!(objects.is_empty())\n    }", "item_id": 4, "repo": "myelin-ai/engine", "file": "src/simulation/simulation_impl.rs", "last_update_at": "2019-12-14T11:25:28+00:00"}
{"hexsha": "22153c435cc54c6faae68c0d8688a6746167fa41", "ext": "rs", "lang": "Rust", "content": "pub fn load_summary<P: AsRef<Path>>(path: P) -> Result<Vec<PartialTxnLookup>, Box<Error>> {\n    let mut res = Vec::new();\n    let mut reader = Reader::from_path(path)?;\n    for row in reader.records() {\n        TxnSummary::from_row(&row?)?\n            .partial_txns()\n            .into_iter()\n            .for_each(|partial_txn| res.push(partial_txn));\n    }\n    Ok(res)\n}", "item_id": 0, "repo": "mplanchard/rust-intro", "file": "src/implementations/owned.rs", "last_update_at": "2019-06-02T17:32:17+00:00"}
{"hexsha": "c07c906f4e2d89e2c628ffb8b0d12fd5c80dc16d", "ext": "rs", "lang": "Rust", "content": "fn clear(mut cx: FunctionContext) -> JsResult<JsUndefined> {\n    let x = cx.argument::<JsNumber>(0)?.value();\n    terminal().clear(map_js_clear_type(x as u16));\n    Ok(cx.undefined())\n}", "item_id": 7, "repo": "sdgluck/node-crossterm", "file": "native/src/lib.rs", "last_update_at": "2019-05-28T22:02:17+00:00"}
{"hexsha": "70ebb8340de8eb4f2864aff55a425b894d26f778", "ext": "rs", "lang": "Rust", "content": "fn cic() {\n        init();\n\n        let refe = b\"GGATAACTCT\";\n        //           |||||\n        let read = b\"GGATATACTCT\";\n\n        let mut data: pcon::solid::Solid = pcon::solid::Solid::new(5);\n\n        for kmer in cocktail::tokenizer::Tokenizer::new(refe, 5) {\n            data.set(kmer, true);\n        }\n\n        let set: set::BoxKmerSet = Box::new(set::Pcon::new(data));\n\n        let corrector = GapSize::new(&set, 2);\n\n        assert_eq!(refe, corrector.correct(read).as_slice()); // test correction work\n        assert_eq!(refe, corrector.correct(refe).as_slice()); // test not overcorrection\n    }", "item_id": 6, "repo": "natir/br", "file": "src/correct/gap_size.rs", "last_update_at": "2019-10-19T01:35:14+00:00"}
{"hexsha": "ce0bf3a6d09ddbb303c5b95108ef08990609a305", "ext": "rs", "lang": "Rust", "content": "fn should_add_entry() {\n    let tmp_dir = TempDir::new(\"emerald\").unwrap();\n    let a = AddressbookStorage::new(tmp_dir.into_path());\n    let act = a.list();\n    assert_eq!(act.len(), 0);\n\n    let json = serde_json::from_str::<Value>(\n        \"{\\\"address\\\":\\\"0x000000000031eaedbc2b611aa528f22343eb52db\\\", \\\"name\\\":\\\"elaine\\\", \\\n         \\\"description\\\":\\\"drug money\\\"}\",\n    ).unwrap();\n    a.add(&json).ok();\n    let act = a.list();\n    assert_eq!(act.len(), 1);\n}", "item_id": 1, "repo": "driconrikus/webchain-rs", "file": "tests/addressbook_test.rs", "last_update_at": "2019-04-07T19:16:55+00:00"}
{"hexsha": "7ffb78845294a56637418f2b0eb1e09c6cf0b4b7", "ext": "rs", "lang": "Rust", "content": "fn is_prime_number3(v: usize, prime_numbers: &[usize]) -> bool {\n    if v < 10000 {\n        let r = prime_numbers.binary_search(&v);\n        return r.is_ok();\n    }\n\n    for n in prime_numbers {\n        if v % n == 0 {\n            return false;\n        }\n    }\n\n    true\n}", "item_id": 2, "repo": "tikv/rp-prof", "file": "examples/profile_proto.rs", "last_update_at": "2019-10-23T12:50:34+00:00"}
{"hexsha": "a94f445f7cafef35db84cf97b3855cc7ca506211", "ext": "rs", "lang": "Rust", "content": "pub fn next_input(player: &PlayerState, bot: &mut BotState) -> rlbot::ControllerState {\n    if let Some(ref plan) = bot.plan {\n        // we need to take into account the inputs previously sent that will be processed\n        // prior to finding where we are. instead of passing the current player, apply\n        // LAG_FRAMES inputs that are not yet applied\n        let player = player.lag_compensated_player(&bot.controller_history, LAG_FRAMES);\n        let index = closest_plan_index(&player, &plan);\n\n        // we need to look one past closest index to see the controller to reach next position\n        if index < plan.len() - 1 {\n            let current_heading = player.rotation.to_rotation_matrix() * Vector3::new(-1.0, 0.0, 0.0);\n            let (closest_player, _, _) = &plan[index];\n            let (_next_player, controller, _) = &plan[index + 1];\n            //println!(\"index: {}, controller.steer: {:?}\", index, controller.steer);\n\n            // FIXME we should account for differences in the tick and interpolate between the two\n            // closest indices to get the real closet delta/distance\n            let closest_delta = player.position - closest_player.position;\n            let closest_distance = closest_delta.norm();\n            let clockwise_90_rotation = Rotation3::from_euler_angles(0.0, 0.0, PI / 2.0);\n            let relative_right = clockwise_90_rotation * current_heading;\n\n            if closest_distance == 0.0 {\n                bot.turn_errors.push_back(0.0);\n            } else {\n                // NOTE positive for right, negative for left\n                let projection = na::Matrix::dot(&Unit::new_normalize(closest_delta).into_inner(), &relative_right);\n                //println!(\"projection: {}, distance: {}\", projection, closest_distance);\n                let error = projection * closest_distance;\n                bot.turn_errors.push_back(error);\n            }\n\n            if bot.turn_errors.len() > 1000 {\n                // keep last 100\n                bot.turn_errors = bot.turn_errors.split_off(900);\n            }\n\n            //println!(\"controller: {:?}\", controller);\n            let mut input = controller.into();\n            //println!(\"input before: {:?}\", input);\n            pd_adjust(&mut input, &bot.turn_errors);\n            //println!(\"input after: {:?}\", input);\n\n            return input;\n        }\n    }\n\n    // fallback\n    let mut input = rlbot::ControllerState::default();\n    input.throttle = 1.0;\n    if player.position.z > 150.0 && (player.position.z as i32 % 2) == 0 {\n        input.jump = true;\n    }\n    input\n}", "item_id": 6, "repo": "ehsanul/brick", "file": "brain/src/play.rs", "last_update_at": "2019-05-14T15:30:02+00:00"}
{"hexsha": "bf8e6ec5bd774f4b8dc104e6b26e1bc0825fc19d", "ext": "rs", "lang": "Rust", "content": "pub fn purge_handled_balls_from_hash_tree(db: &Connection) -> Result<()> {\n    let mut stmt = db.prepare_cached(\n        \"SELECT ball FROM hash_tree_balls \\\n         CROSS JOIN balls USING(ball)\",\n    )?;\n    let balls = stmt.query_map(&[], |row| row.get::<_, String>(0))?;\n\n    let mut stmt = db.prepare_cached(\"DELETE FROM hash_tree_balls WHERE ball=?\")?;\n    for ball in balls {\n        stmt.execute(&[&ball?])?;\n    }\n    Ok(())\n}", "item_id": 4, "repo": "ringringringring/rust-trustnote", "file": "src/catchup.rs", "last_update_at": "2019-05-28T10:59:27+00:00"}
{"hexsha": "045bda0b25736e784dac7151320cf5230548722d", "ext": "rs", "lang": "Rust", "content": "fn can_apply_simple_change_tagged() {\n        let initial_tree    = tree!(\"test\", (\"one\", 1), (\"two\", 2), (\"three\", 3));\n        let change_two      = TreeChange::new(&(\"two\"), &(\"replaced\", 4));\n        let changed_tree    = change_two.apply(&initial_tree);\n\n        assert!(changed_tree.get_child_ref_at(\"one\").unwrap().get_value().to_int(0) == 1);\n        assert!(changed_tree.get_child_ref_at(\"replaced\").unwrap().get_value().to_int(0) == 4);\n        assert!(!changed_tree.get_child_ref_at(\"replaced\").unwrap().get_sibling_ref().is_none());\n        assert!(changed_tree.get_child_ref_at(\"two\").is_none());\n        assert!(!changed_tree.get_child_ref_at(\"three\").is_none());\n    }", "item_id": 0, "repo": "Logicalshift/tame-tree", "file": "src/tree/change.rs", "last_update_at": "2019-04-30T08:19:14+00:00"}
{"hexsha": "13450344a708155aea510fca40876281dc394e86", "ext": "rs", "lang": "Rust", "content": "pub fn secret_2_address(secret: &str) -> Address {\n    let a = hex::decode(clean_0x(secret)).unwrap();\n    let secret_key = secp256k1::SecretKey::parse_slice(a.as_slice()).unwrap();\n    let public_key = secp256k1::PublicKey::from_secret_key(&secret_key);\n    let serialized = public_key.serialize();\n    let mut public = Public::default();\n    public.copy_from_slice(&serialized[1..65]);\n    public_2_address(&public)\n}", "item_id": 4, "repo": "baajur/cita", "file": "tests/json-test/src/helper.rs", "last_update_at": "2019-11-26T10:07:48+00:00"}
{"hexsha": "fb2806f592d4ef9064be9b3733dc3d197c377900", "ext": "rs", "lang": "Rust", "content": "fn slti_imm() {\n    let program = vec![\n        0x13, 0xa1, 0x10, 0x00, // slti sp, ra, 1\n        0x93, 0xa1, 0xf0, 0xff, // slti gp, ra -1\n        0x73, 0x00, 0x50, 0x10, // wfi\n    ];\n\n    let riscv = execute_program(program);\n\n    assert_eq!(riscv.get_gpr(sp), 1);\n    assert_eq!(riscv.get_gpr(gp), 0);\n}", "item_id": 1, "repo": "tomoyuki-nakabayashi/Rustemu86", "file": "arch/riscv/src/instruction_level_tests/rv32i.rs", "last_update_at": "2019-02-07T05:27:30+00:00"}
{"hexsha": "f4200d5b69463191ec55095c12534810cdc02eea", "ext": "rs", "lang": "Rust", "content": "pub async fn get_block_operations(\n    _req: Request<Body>,\n    params: Params,\n    _: Query,\n    env: Arc<RpcServiceEnvironment>,\n) -> ServiceResult {\n    let chain_id = parse_chain_id(required_param!(params, \"chain_id\")?, &env)?;\n    let block_hash =\n        parse_block_hash_or_fail!(&chain_id, required_param!(params, \"block_id\")?, &env);\n\n    result_to_json_response(\n        base_services::get_block_operations_metadata(chain_id, &block_hash, &env).await,\n        env.log(),\n    )\n}", "item_id": 22, "repo": "simplestaking/tezos-rs", "file": "rpc/src/server/shell_handler.rs", "last_update_at": "2019-10-25T18:40:15+00:00"}
{"hexsha": "2a33af9047576b2894497c5d67f427b2828214e5", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn reload_trampoline<P>(this: *mut ffi::GResolver, f: glib_ffi::gpointer)\nwhere P: IsA<Resolver> {\n    callback_guard!();\n    let f: &&(Fn(&P) + 'static) = transmute(f);\n    f(&Resolver::from_glib_borrow(this).downcast_unchecked())\n}", "item_id": 0, "repo": "ystreet/gio", "file": "src/auto/resolver.rs", "last_update_at": "2019-08-16T16:25:27+00:00"}
{"hexsha": "9b22243f15d784a38d414df180b98694caf0a46a", "ext": "rs", "lang": "Rust", "content": "fn process_table(table: &Table) -> ProcessedTable {\n    let mut processed_data = vec![];\n    for row in &table.data {\n        let mut out_row = vec![];\n        for column in row {\n            let cleaned = clean(&column.contents);\n            out_row.push(ProcessedCell {\n                contents: split_sublines(&cleaned),\n                style: column.style,\n            });\n        }\n        processed_data.push(out_row);\n    }\n\n    let mut processed_headers = vec![];\n    for header in &table.headers {\n        let cleaned = clean(&header.contents);\n        processed_headers.push(ProcessedCell {\n            contents: split_sublines(&cleaned),\n            style: header.style,\n        });\n    }\n\n    ProcessedTable {\n        headers: processed_headers,\n        data: processed_data,\n        theme: table.theme.clone(),\n    }\n}", "item_id": 0, "repo": "hustcer/nushell", "file": "crates/nu-table/src/table.rs", "last_update_at": "2019-06-13T10:16:43+00:00"}
{"hexsha": "57a011a843d4347ef4ad4b0efc200225090cdd5e", "ext": "rs", "lang": "Rust", "content": "fn test_fft2() -> Result<()> {\n        let input = parse_signal(\"80871224585914546619083218645595\")?;\n        assert_eq!([2, 4, 1, 7, 6, 1, 7, 6], apply_fft(100, &input)[0..8]);\n        Ok(())\n    }", "item_id": 5, "repo": "HaronK/aoc2019", "file": "task16_1/src/main.rs", "last_update_at": "2019-12-12T13:11:51+00:00"}
{"hexsha": "3a4b0708fe96dfc325bf1d4d3549e1c2eb5bca86", "ext": "rs", "lang": "Rust", "content": "fn test_insert_batch_error() {\n        let db = MemoryDB::open();\n\n        let data = b\"test\".to_vec();\n\n        match db.insert_batch(None, vec![data], vec![]) {\n            Err(DatabaseError::InvalidData) => (), // pass\n            _ => panic!(\"should return error DatabaseError::InvalidData\"),\n        }\n    }", "item_id": 1, "repo": "citahub/cita-database", "file": "src/memorydb.rs", "last_update_at": "2019-07-17T11:21:05+00:00"}
{"hexsha": "9d7144822e067d0fd0a9ac28041188ee73d2dd65", "ext": "rs", "lang": "Rust", "content": "fn notice_with_add_environment() {\n        let notice = Notice::builder().add_environment(\"foo\", \"bar\").build();\n        let expected_json = r#\"\n        {\n            \"errors\": [],\n            \"environment\": {\n                \"foo\": \"bar\"\n            }\n        }\n        \"#;\n        assert_eq!(Value::from_str(expected_json).unwrap(), Value::from(notice));\n    }", "item_id": 1, "repo": "kyrylo/airbrake-rust", "file": "src/notice/notice.rs", "last_update_at": "2019-09-16T21:29:44+00:00"}
{"hexsha": "72c9a7eba86ad12532b8101b9ba38d094b9dc8fa", "ext": "rs", "lang": "Rust", "content": "fn escape<T: AsRef<CStr>>(s: T) -> String {\n    let mut res = String::new();\n    s.as_ref().to_bytes().iter().for_each(|c| match c {\n        b'\\n' => {\n            res.push_str(\"\\\\n\");\n        }\n        b'\\t' => {\n            res.push_str(\"\\\\t\");\n        }\n        _ => {\n            if *c >= 0x20 && *c < 0x7f {\n                res.push(*c as char);\n            } else {\n                res.push_str(&format!(\"\\\\{:o}\", c));\n            }\n        }\n    });\n    res\n}", "item_id": 2, "repo": "iu-parfunc/systrace", "file": "examples/hostecho/src/show/args.rs", "last_update_at": "2019-06-14T23:39:19+00:00"}
{"hexsha": "48fdd719daff0a3ee010653b00f98ae7e12f3a36", "ext": "rs", "lang": "Rust", "content": "pub fn permute_vector_into_buffer() {\n    let x = vector![ 0, 1, 2, 3];\n    let p = PermutationMatrix::from_array(vec![2, 1, 3, 0]).unwrap();\n    let mut output = Vector::zeros(4);\n    p.permute_vector_into_buffer(&x, &mut output);\n    assert_vector_eq!(output, vector![ 3, 1, 0, 2]);\n}", "item_id": 18, "repo": "mesalock-linux/rulinalg-sgx", "file": "sgx/rulinalg-sgx-test/enclave/src/matrix/permutation_matrix.rs", "last_update_at": "2019-08-22T16:34:34+00:00"}
{"hexsha": "cf28a84a0251ce76297200a96cf7eb2b418bdb3b", "ext": "rs", "lang": "Rust", "content": "fn as_unix_millis() {\n        assert_eq!(Some(100),\n                   (UNIX_EPOCH + Duration::from_millis(100)).as_unix_millis());\n        assert_eq!(Some(-100),\n                   (UNIX_EPOCH - Duration::from_millis(100)).as_unix_millis());\n        assert_eq!(None,\n                   (UNIX_EPOCH - Duration::from_secs(1 << 60)).as_unix_millis());\n    }", "item_id": 0, "repo": "sfackler/time2", "file": "src/system_time.rs", "last_update_at": "2019-08-26T09:46:47+00:00"}
{"hexsha": "eaa111470141c108d7893ca634be26134ec228b4", "ext": "rs", "lang": "Rust", "content": "fn when_connected<T, S, R>(\n    params: T::Params,\n    sender: S,\n    receiver: R,\n    handle: &Handle,\n    client_event_sender: mpsc::Sender<ClientEvent>,\n) -> T\nwhere\n    T: ClientState + Clone + 'static,\n    S: Sink<SinkItem = T::Send, SinkError = ()> + 'static,\n    R: Stream<Item = T::Receive, Error = Error> + 'static,\n{\n    let (from_socket, to_socket) = mpsc::channel(20);\n    let client = T::new(params, from_socket);\n    let connect_event_f = client_event_sender\n        .clone()\n        .send(client.connected_event())\n        .map(|_| ())\n        .map_err(|_| ());\n    handle.spawn(connect_event_f);\n\n    let client_id = client.id();\n    let recv_client = client.clone();\n    let from_socket_stream = receiver\n        .map(move |message| recv_client.on_receive(message))\n        .map_err(move |err| error!(\"[{}] Recv error: {}\", client_id, err));\n    let socket_read_stream = client_event_sender\n        .clone()\n        .sink_map_err(|_| ())\n        .send_all(from_socket_stream);\n    let send_stream = sender.send_all(to_socket);\n    let disconnect_message = client.disconnected_event();\n    let connection = send_stream\n        .map(|_| ())\n        .select(socket_read_stream.map(|_| ()))\n        .then(move |_| {\n            client_event_sender\n                .clone()\n                .send(disconnect_message)\n                .map(|_| ())\n                .map_err(|_| ())\n        });\n\n    handle.spawn(connection);\n    client\n}", "item_id": 2, "repo": "kphelps/akio", "file": "akio-net/src/protocol.rs", "last_update_at": "2019-01-06T23:05:12+00:00"}
{"hexsha": "3fec523dcb6d96ef2d6f29f70124ebe3f1578bf2", "ext": "rs", "lang": "Rust", "content": "pub fn light_block_import<B, E, Block: BlockT<Hash=H256>, RA, PRA>(\n\tclient: Arc<Client<B, E, Block, RA>>,\n\tauthority_set_provider: Arc<dyn AuthoritySetForFinalityChecker<Block>>,\n\tapi: Arc<PRA>,\n) -> Result<GrandpaLightBlockImport<B, E, Block, RA>, ClientError>\n\twhere\n\t\tB: Backend<Block, Blake2Hasher> + 'static,\n\t\tE: CallExecutor<Block, Blake2Hasher> + 'static + Clone + Send + Sync,\n\t\tRA: Send + Sync,\n\t\tPRA: ProvideRuntimeApi,\n\t\tPRA::Api: GrandpaApi<Block>,\n{\n\tlet info = client.info();\n\t#[allow(deprecated)]\n\tlet import_data = load_aux_import_data(info.chain.finalized_hash, &**client.backend(), api)?;\n\tOk(GrandpaLightBlockImport {\n\t\tclient,\n\t\tauthority_set_provider,\n\t\tdata: Arc::new(RwLock::new(import_data)),\n\t})\n}", "item_id": 0, "repo": "HPIPS/HPIPS_Chain", "file": "core/finality-grandpa/src/light_import.rs", "last_update_at": "2019-08-07T10:22:08+00:00"}
{"hexsha": "3f36e0b1faaea8f1d4fec66a2bea1c6bacda2743", "ext": "rs", "lang": "Rust", "content": "fn valid_system_is_parsed() {\n        let input = r##\"config:\n        step = 8\n        angle = 45\n        rules:\n        axiom = A\n        A => BA\n        B => A\n        \"##;\n\n        let (actual, _rem) = system().parse(input).expect(\"to parse a system\");\n\n        let expected = LSystem {\n            render_config: RenderConfig { step: 8, angle: 45 },\n            axiom: vec!['A'],\n            rules: LSystemRules::from_rules(vec![Rule::new('A', vec!['B', 'A']), Rule::new('B', vec!['A'])])\n        };\n        assert_eq!(actual, expected);\n    }", "item_id": 5, "repo": "jacobmischka/workshop", "file": "code/examplar-parser/src/lib.rs", "last_update_at": "2019-11-10T13:34:47+00:00"}
{"hexsha": "eb9b23205a19504ec56baccd162346bee27f35ac", "ext": "rs", "lang": "Rust", "content": "fn test_scope() {\n        /*\n        Scope (_SB.MBRD)\n        {\n            Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings\n            {\n                Memory32Fixed (ReadWrite,\n                    0xE8000000,         // Address Base\n                    0x10000000,         // Address Length\n                    )\n            })\n        }\n        */\n\n        let mbrd_scope = [\n            0x10, 0x21, 0x2E, 0x5F, 0x53, 0x42, 0x5F, 0x4D, 0x42, 0x52, 0x44, 0x08, 0x5F, 0x43,\n            0x52, 0x53, 0x11, 0x11, 0x0A, 0x0E, 0x86, 0x09, 0x00, 0x01, 0x00, 0x00, 0x00, 0xE8,\n            0x00, 0x00, 0x00, 0x10, 0x79, 0x00,\n        ];\n\n        assert_eq!(\n            Scope::new(\n                \"_SB_.MBRD\".into(),\n                vec![&Name::new(\n                    \"_CRS\".into(),\n                    &ResourceTemplate::new(vec![&Memory32Fixed::new(\n                        true,\n                        0xE800_0000,\n                        0x1000_0000\n                    )])\n                )]\n            )\n            .to_aml_bytes(),\n            &mbrd_scope[..]\n        );\n    }", "item_id": 3, "repo": "drmint80/cloud-hypervisor", "file": "acpi_tables/src/aml.rs", "last_update_at": "2019-11-15T20:21:47+00:00"}
{"hexsha": "887725c01c78a4d7a28c624bd2bc986b7a9779ce", "ext": "rs", "lang": "Rust", "content": "fn fails_on_duplicate_http_incoming_auth() {\n    let mut account = ACCOUNT_DETAILS_2.clone();\n    account.http_incoming_token = Some(\"incoming_auth_token\".to_string());\n    let result = block_on(test_store().and_then(|(store, context)| {\n        store.insert_account(account).then(move |result| {\n            let _ = context;\n            result\n        })\n    }));\n    assert!(result.is_err());\n}", "item_id": 0, "repo": "pensivej/interledger-rs", "file": "crates/interledger-store-redis/tests/accounts_test.rs", "last_update_at": "2019-08-06T07:59:44+00:00"}
{"hexsha": "2a51ba000b3fd5f005f0dd637b2db64af7406eea", "ext": "rs", "lang": "Rust", "content": "fn test_send_message() {\n        init!(\"true\");\n\n        let msg = CString::new(\"MESSAGE\").unwrap().into_raw();\n        let msg_type = CString::new(\"TYPE\").unwrap().into_raw();\n        let msg_title = CString::new(\"TITLE\").unwrap().into_raw();\n        let connection_handle = ::connection::tests::build_test_connection();\n        ::connection::set_state(connection_handle, VcxStateType::VcxStateAccepted).unwrap();\n        let cb = return_types_u32::Return_U32_STR::new().unwrap();\n        assert_eq!(vcx_connection_send_message(cb.command_handle, connection_handle, msg, msg_type, msg_title, Some(cb.get_callback())), error::SUCCESS.code_num);\n        cb.receive(Some(Duration::from_secs(10))).unwrap();\n    }", "item_id": 23, "repo": "cobear25/indy-sdk", "file": "vcx/libvcx/src/api/connection.rs", "last_update_at": "2019-05-22T08:47:56+00:00"}
{"hexsha": "9b4bb4dc17494c29ed047aad5e066b77167628b6", "ext": "rs", "lang": "Rust", "content": "pub fn end_of_word(buffer: &Buffer, mut point: Point) -> Point {\n    // TODO: remove this once the iterator returns char instances.\n    let mut iter = decode_utf16(buffer.iter_starting_at_point(point)).map(|c| c.unwrap());\n    let skip_alphanumeric = iter.next().map_or(false, |c| c.is_alphanumeric());\n    point = right(buffer, point);\n    for character in iter {\n        if skip_alphanumeric == character.is_alphanumeric() {\n            point = right(buffer, point);\n        } else {\n            break;\n        }\n    }\n    point\n}", "item_id": 4, "repo": "Mattlk13/xray", "file": "xray_core/src/movement.rs", "last_update_at": "2019-07-21T10:37:29+00:00"}
{"hexsha": "5f1380e6c1debec737ab1239768457e2ae4edaea", "ext": "rs", "lang": "Rust", "content": "async fn nexus_create_grpc(\n    compose: &Arc<ComposeTest>,\n    nr_children: usize,\n) -> GrpcNexus {\n    let children = get_children(compose.clone())\n        .await\n        .iter()\n        .take(nr_children)\n        .cloned();\n    let mut hdls = compose.grpc_handles().await.unwrap();\n\n    let nexus_hdl = &mut hdls.last_mut().unwrap();\n    let nexus = nexus_hdl\n        .mayastor\n        .create_nexus(rpc::mayastor::CreateNexusRequest {\n            uuid: uuid::Uuid::new_v4().to_string(),\n            size: 10 * 1024 * 1024,\n            children: children.collect::<Vec<_>>(),\n        })\n        .await\n        .unwrap();\n    GrpcNexus(compose.clone(), nexus.into_inner())\n}", "item_id": 3, "repo": "openebs/MayaStor", "file": "io-engine-bench/src/nexus.rs", "last_update_at": "2019-12-06T14:10:56+00:00"}
{"hexsha": "6284d1836ef46c50637504ab98bc58c982d91ef0", "ext": "rs", "lang": "Rust", "content": "pub fn read_ss() -> u16 {\n    let ret: u16;\n    unsafe {\n        asm!(\n            \"mov %ss, $0\"\n            : \"=r\"(ret)\n            :\n            :\n            );\n    }\n    ret\n}", "item_id": 12, "repo": "colonelpopcorn/rustyvisor", "file": "src/vmx.rs", "last_update_at": "2019-04-11T21:37:17+00:00"}
{"hexsha": "40d2f61e590f789ef9bffeb853ea99e094d762c9", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn okclient(mut ip: *mut u8) -> i32 {\n    let mut _currentBlock;\n    let mut st: stat;\n    let mut i: i32;\n    filename[0usize] = b'i';\n    filename[1usize] = b'p';\n    filename[2usize] = b'/';\n    filename[3u32.wrapping_add(ip4::fmt(filename.as_mut_ptr().offset(3isize), ip as (*const u8))) as\n            (usize)] = 0u8;\n    'loop1: loop {\n        if stat(filename.as_mut_ptr() as (*const u8), &mut st as (*mut stat)) == 0i32 {\n            _currentBlock = 5;\n            break;\n        }\n        i = string::rchr(filename.as_mut_ptr() as (*const u8), b'.' as (i32)) as (i32);\n        if filename[i as (usize)] == 0 {\n            _currentBlock = 4;\n            break;\n        }\n        filename[i as (usize)] = 0u8;\n    }\n    if _currentBlock == 4 { 0i32 } else { 1i32 }\n}", "item_id": 0, "repo": "oxidizers/drdns", "file": "src/okclient.rs", "last_update_at": "2019-09-13T11:39:33+00:00"}
{"hexsha": "6c8088375c4b0548fc7d84f0b41a77827e137224", "ext": "rs", "lang": "Rust", "content": "pub fn set_frame_pointer_elimination(cx: &CodegenCx, llfn: ValueRef) {\n    // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a\n    // parameter.\n    if cx.sess().must_not_eliminate_frame_pointers() {\n        llvm::AddFunctionAttrStringValue(\n            llfn, llvm::AttributePlace::Function,\n            cstr(\"no-frame-pointer-elim\\0\"), cstr(\"true\\0\"));\n    }\n}", "item_id": 1, "repo": "mrhota/rust", "file": "src/librustc_trans/attributes.rs", "last_update_at": "2019-01-07T03:31:05+00:00"}
{"hexsha": "93f71f55ff58446c73eaee318546064439cbdfde", "ext": "rs", "lang": "Rust", "content": "fn create_task() {\n        let domain = \"atcoder.jp\".to_string();\n        let path = \"/contests/abc125/tasks\".to_string();\n\n        let result = atcoder::get_tasks(&domain, &path);\n        let lang_ja = atcoder::Lang::Ja;\n\n        let mut task_result = vec![];\n        if let Some(tasks) = result {\n            for task in tasks {\n                task_result.push(Task::new(task.title, task.link, lang_ja));\n            }\n        } else {\n            assert!(false);\n        }\n\n        let answer = vec![\n            Task::new(\n                \"A: Biscuit Generator\".to_string(),\n                \"https://atcoder.jp/contests/abc125/tasks/abc125_a\".to_string(),\n                atcoder::Lang::Ja,\n            ),\n            Task::new(\n                \"B: Resale\".to_string(),\n                \"https://atcoder.jp/contests/abc125/tasks/abc125_b\".to_string(),\n                atcoder::Lang::Ja,\n            ),\n            Task::new(\n                \"C: GCD on Blackboard\".to_string(),\n                \"https://atcoder.jp/contests/abc125/tasks/abc125_c\".to_string(),\n                atcoder::Lang::Ja,\n            ),\n            Task::new(\n                \"D: Flipping Signs\".to_string(),\n                \"https://atcoder.jp/contests/abc125/tasks/abc125_d\".to_string(),\n                atcoder::Lang::Ja,\n            ),\n        ];\n        assert_eq!(answer.len(), task_result.len());\n        for i in 0..answer.len() {\n            assert_eq!(answer[i], task_result[i]);\n        }\n    }", "item_id": 0, "repo": "sux2mfgj/abc_utils", "file": "src/task.rs", "last_update_at": "2019-05-18T15:47:54+00:00"}
{"hexsha": "86b8655d7cb8d82dc2fe9d1d35390277ad99bcea", "ext": "rs", "lang": "Rust", "content": "pub fn build_index(lang: &str, library: &Library) -> Result<String> {\n    let language = match Language::from_code(lang) {\n        Some(l) => l,\n        None => {\n            bail!(\"Tried to build search index for language {} which is not supported\", lang);\n        }\n    };\n\n    let mut index = Index::with_language(language, &[\"title\", \"body\"]);\n\n    for section in library.sections_values() {\n        if section.lang == lang {\n            add_section_to_index(&mut index, section, library);\n        }\n    }\n\n    Ok(index.to_json())\n}", "item_id": 0, "repo": "pheki/zola", "file": "components/search/src/lib.rs", "last_update_at": "2019-12-23T02:07:39+00:00"}
{"hexsha": "290052921f5b8d0d6ea234711eae018ccb14fae3", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let log_config = Config {\n        filter: Some(\"info\".to_owned()),\n        ..Default::default()\n    };\n    let _logger_guard = ckb_logger::init(log_config).expect(\"init Logger\");\n\n    let binary = env::args()\n        .nth(1)\n        .unwrap_or_else(|| \"../target/release/ckb\".to_string());\n    let start_port = env::args()\n        .nth(2)\n        .unwrap_or_else(|| \"9000\".to_string())\n        .parse()\n        .expect(\"invalid port number\");\n    let mut specs: HashMap<&str, Box<dyn Spec>> = HashMap::new();\n    specs.insert(\"block_relay_basic\", Box::new(BlockRelayBasic));\n    specs.insert(\"block_sync_from_one\", Box::new(BlockSyncFromOne));\n    specs.insert(\"block_sync_forks\", Box::new(BlockSyncForks));\n    specs.insert(\n        \"block_sync_duplicated_and_reconnect\",\n        Box::new(BlockSyncDuplicatedAndReconnect),\n    );\n    specs.insert(\"block_sync_orphan_blocks\", Box::new(BlockSyncOrphanBlocks));\n    specs.insert(\"sync_timeout\", Box::new(SyncTimeout));\n    specs.insert(\"chain_fork_1\", Box::new(ChainFork1));\n    specs.insert(\"chain_fork_2\", Box::new(ChainFork2));\n    specs.insert(\"chain_fork_3\", Box::new(ChainFork3));\n    specs.insert(\"chain_fork_4\", Box::new(ChainFork4));\n    specs.insert(\"chain_fork_5\", Box::new(ChainFork5));\n    specs.insert(\"chain_fork_6\", Box::new(ChainFork6));\n    specs.insert(\"chain_fork_7\", Box::new(ChainFork7));\n    specs.insert(\"mining_basic\", Box::new(MiningBasic));\n    specs.insert(\"mining_bootstrap_cellbase\", Box::new(BootstrapCellbase));\n    specs.insert(\"mining_template_size_limit\", Box::new(TemplateSizeLimit));\n    specs.insert(\"pool_reconcile\", Box::new(PoolReconcile));\n    specs.insert(\"pool_resurrect\", Box::new(PoolResurrect));\n    specs.insert(\"transaction_relay_basic\", Box::new(TransactionRelayBasic));\n    // FIXME: There is a probability of failure on low resouce CI server\n    // specs.insert(\n    //     \"transaction_relay_multiple\",\n    //     Box::new(TransactionRelayMultiple),\n    // );\n    specs.insert(\"discovery\", Box::new(Discovery));\n    // TODO enable this after p2p lib resolve close timeout issue\n    // specs.insert(\"disconnect\", Box::new(Disconnect));\n    specs.insert(\"malformed_message\", Box::new(MalformedMessage));\n    specs.insert(\"depent_tx_in_same_block\", Box::new(DepentTxInSameBlock));\n    // TODO enable these after proposed/pending pool tip verfiry logic changing\n    // specs.insert(\"cellbase_maturity\", Box::new(CellbaseMaturity));\n    specs.insert(\"valid_since\", Box::new(ValidSince));\n    specs.insert(\n        \"different_txs_with_same_input\",\n        Box::new(DifferentTxsWithSameInput),\n    );\n    specs.insert(\"compact_block_empty\", Box::new(CompactBlockEmpty));\n    specs.insert(\n        \"compact_block_empty_parent_unknown\",\n        Box::new(CompactBlockEmptyParentUnknown),\n    );\n    specs.insert(\"compact_block_prefilled\", Box::new(CompactBlockPrefilled));\n    specs.insert(\n        \"compact_block_missing_txs\",\n        Box::new(CompactBlockMissingTxs),\n    );\n    specs.insert(\n        \"compact_block_lose_get_block_transactions\",\n        Box::new(CompactBlockLoseGetBlockTransactions),\n    );\n    specs.insert(\n        \"compact_block_relay_parent_of_orphan_block\",\n        Box::new(CompactBlockRelayParentOfOrphanBlock),\n    );\n    specs.insert(\"invalid_locator_size\", Box::new(InvalidLocatorSize));\n    specs.insert(\"tx_pool_size_limit\", Box::new(SizeLimit));\n    specs.insert(\"tx_pool_cycles_limit\", Box::new(CyclesLimit));\n    specs.insert(\"alert_propagation\", Box::new(AlertPropagation::default()));\n    specs.insert(\"indexer_basic\", Box::new(IndexerBasic));\n    specs.insert(\"genesis_issued_cells\", Box::new(GenesisIssuedCells));\n\n    if let Some(spec_name) = env::args().nth(3) {\n        if let Some(spec) = specs.get(spec_name.as_str()) {\n            let net = spec.setup_net(&binary, start_port);\n            spec.run(net);\n        }\n    } else {\n        specs.iter().for_each(|(spec_name, spec)| {\n            info!(\"Running {}\", spec_name);\n            let net = spec.setup_net(&binary, start_port);\n            spec.run(net);\n        })\n    }\n}", "item_id": 0, "repo": "Tresdin-commander/blockchain", "file": "test/src/main.rs", "last_update_at": "2019-07-05T05:50:43+00:00"}
{"hexsha": "c385df2d912b71e555df414919d72c181b8dfd50", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn frame_handle_copy_with_damage(mut wl_client:\n                                                       *mut wl_client,\n                                                   mut frame_resource:\n                                                       *mut wl_resource,\n                                                   mut buffer_resource:\n                                                       *mut wl_resource) {\n    let mut frame: *mut wlr_screencopy_frame_v1 =\n        frame_from_resource(frame_resource);\n    if frame.is_null() { return }\n    (*frame).with_damage = 1i32 != 0;\n    frame_handle_copy(wl_client, frame_resource, buffer_resource);\n}", "item_id": 12, "repo": "RoastVeg/wlrusts", "file": "src/types/wlr_screencopy_v1.rs", "last_update_at": "2019-12-10T16:29:26+00:00"}
{"hexsha": "2867a1f3feefae55b4fc230de6519892c66e499b", "ext": "rs", "lang": "Rust", "content": "unsafe fn last_row(buf: &mut [u8], data: &[u8], x: usize, w: usize, h: usize) {\n    debug_assert!(buf.len() == 3*w*h);\n    debug_assert!(data.len() == w*h);\n    debug_assert!(x < w);\n\n    let y = h - 2;\n\n    let g1 = get(data, x  , y-1, w);\n    let g3 = get(data, x-1, y, w);\n    let g5 = get(data, x+1, y, w);\n    let g8 = get(data, x  , y+1, w);\n    let g10 = get(data, x+2, y+1, w);\n\n    set(buf, x, y, 1, w, (g1+g3+g5+g8)/4);\n    set(buf, x+1, y, 1, w, g5);\n    set(buf, x, y+1, 1, w, g8);\n    set(buf, x+1, y+1, 1, w, (g5+g8+g10)/3);\n\n    let r0 = get(data, x-1, y-1, w);\n    let r2 = get(data, x+1, y-1, w);\n    let r7 = get(data, x-1, y+1, w);\n    let r9 = get(data, x+1, y+1, w);\n\n    set(buf, x, y, 2, w, (r0+r2+r7+r9)/4);\n    set(buf, x+1, y, 2, w, (r2+r9)/2);\n    set(buf, x, y+1, 2, w, (r7+r9)/2);\n    set(buf, x+1, y+1, 2, w, r9);\n\n    let b4 = get(data, x  , y, w);\n    let b6 = get(data, x+2, y, w);\n\n    set(buf, x, y, 0, w, b4);\n    set(buf, x+1, y, 0, w, (b4+b6)/2);\n    set(buf, x, y+1, 0, w, b4);\n    set(buf, x+1, y+1, 0, w, (b4+b6)/2);\n}", "item_id": 5, "repo": "SkoltechRobotics/cam-vis", "file": "src/rggb.rs", "last_update_at": "2019-09-17T17:02:57+00:00"}
{"hexsha": "6a486030df4a2fcec1c8152076ec128bf46681ee", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), Error> {\n    // Lets get some logs out\n    TermLogger::init(LevelFilter::Info, Config::default())?;\n\n    let starstruck = StarstruckBuilder::new().init()?;\n    starstruck.run()?;\n\n    Ok(())\n}", "item_id": 0, "repo": "Joatin/starstruck", "file": "examples/01_window.rs", "last_update_at": "2019-03-28T15:24:56+00:00"}
{"hexsha": "c44da432c27616a0c513aa4feb48d085fcb4d125", "ext": "rs", "lang": "Rust", "content": "fn read_known_repos_table() -> Result<Vec<(String, String)>, KRTError> {\n    let mut file = File::open(known_repos_table_filepath())?;\n    let mut buffer = String::new();\n    file.read_to_string(&mut buffer)?;\n    let mut v: Vec<(String, String)> = serde_json::from_str(&buffer)?;\n    // Prune any repos that no longer exist.\n    let mut pruned = vec![];\n    for item in v.drain(..) {\n        if is_repo_workdir(&item.1) {\n            pruned.push(item);\n        }\n    }\n    Ok(pruned)\n}", "item_id": 2, "repo": "pwil3058/gwsm_git", "file": "rgwsm_git/src/repos.rs", "last_update_at": "2019-07-09T06:01:40+00:00"}
{"hexsha": "862e1bcb28fb7e5e9044737f10b3949d9c2b6d3e", "ext": "rs", "lang": "Rust", "content": "fn lockfile_locks_transitively() {\n    let p = project(\"foo\")\n        .file(\"Cargo.toml\", r#\"\n            [project]\n            name = \"foo\"\n            version = \"0.0.1\"\n            authors = []\n\n            [dependencies]\n            bar = \"*\"\n        \"#)\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"baz\", \"0.0.1\").publish();\n    Package::new(\"bar\", \"0.0.1\").dep(\"baz\", \"*\").publish();\n\n    assert_that(p.cargo(\"build\"),\n                execs().with_status(0).with_stderr(&format!(\"\\\n[UPDATING] registry `[..]`\n[DOWNLOADING] [..] v0.0.1 (registry `file://[..]`)\n[DOWNLOADING] [..] v0.0.1 (registry `file://[..]`)\n[COMPILING] baz v0.0.1\n[COMPILING] bar v0.0.1\n[COMPILING] foo v0.0.1 ({dir})\n[FINISHED] dev [unoptimized + debuginfo] target(s) in [..] secs\n\",\n   dir = p.url())));\n\n    p.root().move_into_the_past();\n    Package::new(\"baz\", \"0.0.2\").publish();\n    Package::new(\"bar\", \"0.0.2\").dep(\"baz\", \"*\").publish();\n\n    assert_that(p.cargo(\"build\"),\n                execs().with_status(0).with_stdout(\"\"));\n}", "item_id": 8, "repo": "cnmade/cargo", "file": "tests/registry.rs", "last_update_at": "2019-07-19T20:12:12+00:00"}
{"hexsha": "e6acd81b8f398cb45de21fb4e0325b8f492db280", "ext": "rs", "lang": "Rust", "content": "fn get_one() {\n    consul_put(\"tower-consul/test-key\", \"test-value\");\n\n    let mut rt = Runtime::new().unwrap();\n\n    let response = rt.block_on(future::lazy(|| {\n        let mut client = client(hyper);\n        client.get(\"tower-consul/test-key\")\n    }));\n\n    let mut values = response.unwrap();\n    let value = values.pop().unwrap();\n    assert_eq!(value.key, \"tower-consul/test-key\");\n\n    consul_del(\"tower-consul/test-key\");\n}", "item_id": 1, "repo": "LucioFranco/tower-consul", "file": "tests/kv.rs", "last_update_at": "2019-01-18T17:50:03+00:00"}
{"hexsha": "3d55062c5244f88dcd462a368f5ca932bdf94007", "ext": "rs", "lang": "Rust", "content": "fn spec_test_595() {\n    let original = r##\"<made-up-scheme://foo,bar>\n\"##;\n    let expected = r##\"<p><a href=\"made-up-scheme://foo,bar\">made-up-scheme://foo,bar</a></p>\n\"##;\n\n    test_markdown_html(original, expected);\n}", "item_id": 594, "repo": "NaokiM03/pulldown-cmark", "file": "tests/suite/spec.rs", "last_update_at": "2019-07-11T13:20:46+00:00"}
{"hexsha": "af2a630995c0e2d564b4d37c8a10b3b0b3deee7d", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    pretty_env_logger::init();\n\n    let addr = \"127.0.0.1:1337\".parse().unwrap();\n\n    hyper::rt::run(future::lazy(move || {\n        // Share a `Client` with all `Service`s\n        let client = Client::new();\n\n        let new_service = move || {\n            // Move a clone of `client` into the `service_fn`.\n            let client = client.clone();\n            service_fn(move |req| {\n                response_examples(req, &client)\n            })\n        };\n\n        let server = Server::bind(&addr)\n            .serve(new_service)\n            .map_err(|e| eprintln!(\"server error: {}\", e));\n\n        println!(\"Listening on http://{}\", addr);\n\n        server\n    }));\n}", "item_id": 1, "repo": "jxs/hyper", "file": "examples/web_api.rs", "last_update_at": "2019-11-19T09:28:31+00:00"}
{"hexsha": "c3a2f978e1a8a4945f39ed8c091edbe5857ef762", "ext": "rs", "lang": "Rust", "content": "fn mubs_scc_2() {\n    //      +----+\n    //      v    |\n    // a -> c -> d\n    //      ^    ^\n    //      |    |\n    //      +--- b\n\n    // \"digraph { a -> c -> d; d -> c; b -> d; b -> c; }\",\n    let mut relation = TransitiveRelation::new();\n    relation.add(\"a\", \"c\");\n    relation.add(\"c\", \"d\");\n    relation.add(\"d\", \"c\");\n    relation.add(\"b\", \"d\");\n    relation.add(\"b\", \"c\");\n\n    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n}", "item_id": 12, "repo": "canaltinova/rust", "file": "src/librustc_data_structures/transitive_relation.rs", "last_update_at": "2019-09-24T02:31:48+00:00"}
{"hexsha": "646397b3942e04431f6ddb56afcd819a544cc158", "ext": "rs", "lang": "Rust", "content": "pub fn iter(x0: f64, y0: f64, maxi: Uint) -> Uint {\n    let (mut x, mut y) = (x0, y0);\n\n    for i in 1..maxi+1 {\n        let (xx, yy) = (x*x, y*y);\n        if xx+yy >= 4.0 {\n            return i;\n        }\n        y = 2.0*x*y+y0;\n        x = xx-yy+x0;\n    }\n\n    maxi\n}", "item_id": 0, "repo": "royaltm/rust-fractx", "file": "src/iter.rs", "last_update_at": "2019-03-19T11:07:59+00:00"}
{"hexsha": "eef249cf3016daced42d7e087b6e3db5dc2eb890", "ext": "rs", "lang": "Rust", "content": "fn test_lookup_index_not_exists_array() {\n        let _ = env_logger::builder().is_test(true).try_init();\n\n        let sample = array![array![\"test\"]];\n\n        let found = lookup::<_, _, DefaultTokenizer>(&sample, \"[1]\");\n\n        assert!(found.is_err());\n\n        assert_eq!(found, Err(Error::IndexNotExist(1)),);\n    }", "item_id": 3, "repo": "zerosign/querable", "file": "src/lib.rs", "last_update_at": "2019-10-26T11:35:38+00:00"}
{"hexsha": "9ecff8a3f9b50a3fe4c595109bb5cffdf777d1f8", "ext": "rs", "lang": "Rust", "content": "fn CalculateDeltaWeight1(number: i32, I2HWeight: [[f64;4];3], H2OWeight: [[f64;3];4], InputBias: [f64;4], HiddenBias: [f64;3], OutputBias: [f64;4], TeacherSignal: [f64;4]) -> [[f64;4];3] {\n    let mut NeuralNetwork = NeuronAndWeight::new(number, I2HWeight, H2OWeight, InputBias, HiddenBias, OutputBias, TeacherSignal);\n    let mut inputlayer = NeuralNetwork.inputlayer();\n    let mut Hiddenlayer = NeuralNetwork.Hiddenlayer(inputlayer);\n    let mut Outputlayer = NeuralNetwork.Outputlayer(Hiddenlayer);\n    let mut DeltaWeight: [[f64;4];3] = [[0.0;4];3];\n    for i in 0..3{\n        for j in 0..4{\n            DeltaWeight[i][j] = -0.19 * (Outputlayer[j] - TeacherSignal[j]) * Outputlayer[j] * (1.0 - Outputlayer[j]) * Hiddenlayer[i];\n        }\n    }\n    DeltaWeight\n}", "item_id": 1, "repo": "hota1024/Rust-NeuralNetwork", "file": "NeuralNetwork/NN/src/main.rs", "last_update_at": "2019-10-06T09:45:24+00:00"}
{"hexsha": "22c5e8c32a3eb4f8b9d2b68f1e265dcc1e8369a3", "ext": "rs", "lang": "Rust", "content": "fn update_maze(\n    maze: &mut HashMap<String, Coordinates>,\n    drone_coordinates: &Coordinates,\n    current_direction: &Direction,\n    kind: &CoordinatesKind,\n) -> () {\n    let coordinates = match current_direction {\n        Direction::North => Coordinates::new(\n            drone_coordinates.x,\n            drone_coordinates.y + 1,\n            Some(drone_coordinates.distance + 1),\n            Some(kind.clone()),\n        ),\n        Direction::East => Coordinates::new(\n            drone_coordinates.x + 1,\n            drone_coordinates.y,\n            Some(drone_coordinates.distance + 1),\n            Some(kind.clone()),\n        ),\n        Direction::South => Coordinates::new(\n            drone_coordinates.x,\n            drone_coordinates.y - 1,\n            Some(drone_coordinates.distance + 1),\n            Some(kind.clone()),\n        ),\n        Direction::West => Coordinates::new(\n            drone_coordinates.x - 1,\n            drone_coordinates.y,\n            Some(drone_coordinates.distance + 1),\n            Some(kind.clone()),\n        ),\n    };\n\n    let key = coordinates.to_maze_key();\n    if !maze.contains_key(&key) {\n        maze.insert(coordinates.to_maze_key(), coordinates.clone());\n    } else {\n        if maze.get(&key).unwrap().distance > coordinates.distance {\n            maze.insert(coordinates.to_maze_key(), coordinates.clone());\n        }\n    }\n}", "item_id": 3, "repo": "paulsouche/adventofcode2019", "file": "src/bin/day15-oxygen-system/main.rs", "last_update_at": "2019-12-01T11:34:37+00:00"}
{"hexsha": "97e8ae8f274d578a2fd82dbffc5c7a07a411b24f", "ext": "rs", "lang": "Rust", "content": "fn test_boundary_to_difficulty() {\n        let h1 = h256!(\"0x1000\");\n        let h2: U256 = target_to_difficulty(&h1);\n\n        assert_eq!(target_to_difficulty(&h2.into()), u256!(\"4096\"));\n    }", "item_id": 0, "repo": "LeastAuthority/nervos-ckb", "file": "util/types/src/utilities.rs", "last_update_at": "2019-08-09T07:30:56+00:00"}
{"hexsha": "aaa343b9c3f6dc86d8dafd26820f0757fa9a7f13", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let input = {\n        let fname = std::env::args()\n            .nth(1)\n            .expect(\"Please give input as first argument!\");\n        std::fs::read_to_string(fname).unwrap()\n    };\n\n    // part one\n    let module_fuel: i32 = input\n        .lines()\n        .map(|mass| mass.parse::<i32>().unwrap())\n        .map(|mass| mass / 3 - 2)\n        .sum();\n    println!(\"Module fuel required: {}\", module_fuel);\n\n    // part one\n    let total_fuel: i32 = input\n        .lines()\n        .map(|mass| mass.parse::<i32>().unwrap())\n        .map(|mut mass| {\n            let mut total = 0;\n            loop {\n                mass = mass / 3 - 2;\n                if mass < 0 {\n                    break;\n                }\n                total += mass;\n            }\n            total\n        })\n        .sum();\n    println!(\"Total fuel required: {}\", total_fuel);\n}", "item_id": 0, "repo": "johannst/aoc2019", "file": "src/bin/day1.rs", "last_update_at": "2019-12-01T16:26:58+00:00"}
{"hexsha": "79fe1bf2f4d04b57afd3610546532d7a6b279df5", "ext": "rs", "lang": "Rust", "content": "fn main() {\n  let mut argv = std::env::args();\n  let argc = argv.len();\n  if argc == 0 || argc > 2 {\n    panic!(\"restart test binary expect either no arguments or `restart`.\")\n  }\n\n  println!(\n    \"{}\",\n    tauri::api::process::current_binary(&Default::default())\n      .expect(\"tauri::api::process::current_binary could not resolve\")\n      .display()\n  );\n\n  match argv.nth(1).as_deref() {\n    Some(\"restart\") => tauri::api::process::restart(&Default::default()),\n    Some(invalid) => panic!(\"only argument `restart` is allowed, {} is invalid\", invalid),\n    None => {}\n  };\n}", "item_id": 0, "repo": "Brooooooklyn/tauri", "file": "core/tauri/tests/restart/src/main.rs", "last_update_at": "2019-08-14T10:10:32+00:00"}
{"hexsha": "871acf8c0c281eda48b914b078dfe4caf16b4b4c", "ext": "rs", "lang": "Rust", "content": "pub fn do_write(fd: FileDesc, buf: &[u8]) -> Result<usize, Error> {\n    let current_ref = process::get_current();\n    let current_process = current_ref.lock().unwrap();\n    let file_ref = current_process.get_files().get(fd)?;\n    file_ref.write(buf)\n}", "item_id": 1, "repo": "wangrunji0408/libos", "file": "src/libos/src/fs/mod.rs", "last_update_at": "2019-12-23T03:12:24+00:00"}
{"hexsha": "e576b0a0a4abab1238ee2fe01221f68906adc664", "ext": "rs", "lang": "Rust", "content": "fn test_version_to_string() {\n    let valid_version = \"1.10.1947-abcd-EFG+1A-bc-2\";\n\n    let version_a = Version::parse(valid_version).unwrap();\n    let version_a_str = version_a.to_string();\n\n    let version_b = Version::parse(&version_a_str).unwrap();\n    assert_eq!(version_a, version_b);\n}", "item_id": 7, "repo": "alsacoin/alsacoin", "file": "models/src/version.rs", "last_update_at": "2019-07-14T22:18:10+00:00"}
{"hexsha": "141117cc909f026ccff6c9b0051d5dace3ad9055", "ext": "rs", "lang": "Rust", "content": "fn alu2_bic(arm: &mut Arm7TDMI, op: ThumbOp) {\n    let (rd_index, rd, rs) = decode_alu2_reg(arm, op);\n    let result = rd & !rs;\n    set_zn(arm, result);\n    arm.regs[rd_index] = result;\n}", "item_id": 17, "repo": "angusholder/gba-emulator", "file": "src/arm7tdmi/core_thumb.rs", "last_update_at": "2019-09-29T05:10:36+00:00"}
{"hexsha": "5652327da33a0f6fc607804ae111f4a5fc642430", "ext": "rs", "lang": "Rust", "content": "fn test_example2() {\n        // 2,3,0,3,99 becomes 2,3,0,6,99 (3 * 2 = 6).\n        let prog = vec![2, 3, 0, 3, 99];\n        assert_eq!(eval(&prog, 3), 6);\n    }", "item_id": 3, "repo": "johannst/aoc2019", "file": "src/bin/day5.rs", "last_update_at": "2019-12-01T16:26:58+00:00"}
{"hexsha": "c2cbdf536ea85ec0bf04276863059a2f52bd05c1", "ext": "rs", "lang": "Rust", "content": "pub fn derive_enum_signingkey(input: TokenStream) -> TokenStream {\n    let ast = parse_macro_input!(input as DeriveInput);\n\n    let name = &ast.ident;\n    let public_key_type = get_type_from_attrs(&ast.attrs, \"PublicKeyType\").unwrap();\n    let signature_type = get_type_from_attrs(&ast.attrs, \"SignatureType\").unwrap();\n    match ast.data {\n        Data::Enum(ref variants) => {\n            impl_enum_signingkey(name, public_key_type, signature_type, variants)\n        }\n        Data::Struct(_) | Data::Union(_) => {\n            panic!(\"#[derive(PrivateKey)] is only defined for enums\")\n        }\n    }\n}", "item_id": 12, "repo": "prz23/libra", "file": "crypto/crypto_derive/src/lib.rs", "last_update_at": "2019-09-04T22:10:07+00:00"}
{"hexsha": "8a352e4719ceb70abd5709261c76807c8aee0b69", "ext": "rs", "lang": "Rust", "content": "fn test_matrix_sub_move_ref() {\n        let (m, n) = (2, 4);\n        let a = Matrix::from_vec(vec![40.0, 90.0, 50.0, 100.0, 50.0, 120.0, 60.0, 130.0], m, n);\n        let b = Matrix::from_vec(vec![38.0, 83.0, 44.0, 98.0, 50.0, 113.0, 56.0, 128.0], m, n);\n\n        let out = a - &b;\n\n        let out_data = out.data();\n        assert_eq!(*out_data.values(), vec![2.0, 7.0, 6.0, 2.0, 0.0, 7.0, 4.0, 2.0]);\n    }", "item_id": 20, "repo": "jblondin/matrix", "file": "src/ops.rs", "last_update_at": "2019-06-29T15:43:58+00:00"}
{"hexsha": "4b08a39dbd37f75e9e839e81b665a09333063dda", "ext": "rs", "lang": "Rust", "content": "fn assert_reverse_seek(engine: &Engine, key: &[u8], pair: (&[u8], &[u8])) {\n        let snapshot = engine.snapshot(&Context::new()).unwrap();\n        let mut iter = snapshot.iter(None, true, ScanMode::Mixed).unwrap();\n        iter.reverse_seek(&make_key(key)).unwrap();\n        assert_eq!((iter.key(), iter.value()),\n                   (&*bytes::encode_bytes(pair.0), pair.1));\n    }", "item_id": 3, "repo": "Caoming/tikv", "file": "src/storage/engine/mod.rs", "last_update_at": "2019-09-07T01:44:36+00:00"}
{"hexsha": "99ddf068c2e6c5ae1bfed4b3eb160e784bc0d71b", "ext": "rs", "lang": "Rust", "content": "pub unsafe fn mailimf_comments_new(mut cm_value: *mut libc::c_char) -> *mut mailimf_comments {\n    let mut comments: *mut mailimf_comments = 0 as *mut mailimf_comments;\n    comments =\n        malloc(::std::mem::size_of::<mailimf_comments>() as libc::size_t) as *mut mailimf_comments;\n    if comments.is_null() {\n        return 0 as *mut mailimf_comments;\n    }\n    (*comments).cm_value = cm_value;\n    return comments;\n}", "item_id": 30, "repo": "KAction/mmime", "file": "src/mailimf_types.rs", "last_update_at": "2019-09-16T15:25:05+00:00"}
{"hexsha": "4b05c21a539d186db17926df1a3431106bdd680b", "ext": "rs", "lang": "Rust", "content": "fn load_asset_to_vmo(path: &Path) -> Result<mem::Buffer, Error> {\n    let file = File::open(path)?;\n    let vmo = fdio::get_vmo_copy_from_file(&file)?;\n    let size = file.metadata()?.len();\n    Ok(mem::Buffer { vmo, size })\n}", "item_id": 1, "repo": "bootingman/fuchsia2", "file": "garnet/bin/fonts/src/font_service.rs", "last_update_at": "2019-10-09T10:50:57+00:00"}
{"hexsha": "e049f4062c0057693c0c90e18fb5d6b5ec44bb92", "ext": "rs", "lang": "Rust", "content": "fn problem_2021_19_1() {\n    #![allow(clippy::unwrap_used)]\n    let input = read_to_string(\"src/year2021/day19_input.txt\").unwrap();\n    solve(2021, 19, 1, &input).unwrap();\n}", "item_id": 336, "repo": "fornwall/advent-of-code-2019-rs", "file": "crates/core/benches/iai.rs", "last_update_at": "2019-12-10T00:08:49+00:00"}
{"hexsha": "66865861197b2155e1c09f6108e6ff6943ea3ca2", "ext": "rs", "lang": "Rust", "content": "pub fn generate_key()->[u8;32]{\n    let mut rng = rand::thread_rng();\n    let random:[u8;32] = rng.gen();\n    let secret = key::SecretKey::from_slice(&random).unwrap();\n    let mut return_slice:[u8;32] = [0;32];\n    (0..32).for_each(|i|{\n        return_slice[i] = secret[i];\n    });\n    return_slice\n}", "item_id": 1, "repo": "Vreath-core/rust-vreath-core", "file": "src/crypto.rs", "last_update_at": "2019-06-08T06:37:57+00:00"}
{"hexsha": "299aaaf5554c5d755825149a0e5f45c45387e24f", "ext": "rs", "lang": "Rust", "content": "fn test_align_baseline_multiline_column() {\n\tlet mut root = Node::new();\n\n\tstyle!(root,\n\t\tAlignItems(Align::Baseline),\n\t\tFlexWrap(Wrap::Wrap),\n\t\tWidth(100 pt),\n\t\tHeight(100 pt)\n\t);\n\n\tlet mut root_child_0 = Node::new();\n\n\tstyle!(root_child_0,\n\t\tWidth(50 pt),\n\t\tHeight(50 pt)\n\t);\n\n\tlet mut root_child_1 = Node::new();\n\n\tstyle!(root_child_1,\n\t\tWidth(30 pt),\n\t\tHeight(50 pt)\n\t);\n\n\tlet mut root_child_1_child_0 = Node::new();\n\n\tstyle!(root_child_1_child_0,\n\t\tWidth(20 pt),\n\t\tHeight(20 pt)\n\t);\n\n\tlet mut root_child_2 = Node::new();\n\n\tstyle!(root_child_2,\n\t\tWidth(40 pt),\n\t\tHeight(70 pt)\n\t);\n\n\tlet mut root_child_2_child_0 = Node::new();\n\n\tstyle!(root_child_2_child_0,\n\t\tWidth(10 pt),\n\t\tHeight(10 pt)\n\t);\n\n\tlet mut root_child_3 = Node::new();\n\n\tstyle!(root_child_3,\n\t\tWidth(50 pt),\n\t\tHeight(20 pt)\n\t);\n\n\troot.insert_child(&mut root_child_0, 0);\n\troot.insert_child(&mut root_child_1, 1);\n\troot.insert_child(&mut root_child_2, 2);\n\troot.insert_child(&mut root_child_3, 3);\n\n\troot_child_1.insert_child(&mut root_child_1_child_0, 0);\n\troot_child_2.insert_child(&mut root_child_2_child_0, 0);\n\troot.calculate_layout(Undefined, Undefined, Direction::LTR);\n\n\tlet root_layout = root.get_layout();\n\tlet child_0_layout = root_child_0.get_layout();\n\tlet child_1_layout = root_child_1.get_layout();\n\tlet child_1_child_0_layout = root_child_1_child_0.get_layout();\n\tlet child_2_layout = root_child_2.get_layout();\n\tlet child_2_child_0_layout = root_child_2_child_0.get_layout();\n\tlet child_3_layout = root_child_3.get_layout();\n\n\tassert_eq!(0.0, root_layout.left());\n\tassert_eq!(0.0, root_layout.top());\n\tassert_eq!(100.0, root_layout.width());\n\tassert_eq!(100.0, root_layout.height());\n\n\tassert_eq!(0.0, child_0_layout.left());\n\tassert_eq!(0.0, child_0_layout.top());\n\tassert_eq!(50.0, child_0_layout.width());\n\tassert_eq!(50.0, child_0_layout.height());\n\n\tassert_eq!(0.0, child_1_layout.left());\n\tassert_eq!(50.0, child_1_layout.top());\n\tassert_eq!(30.0, child_1_layout.width());\n\tassert_eq!(50.0, child_1_layout.height());\n\n\tassert_eq!(0.0, child_1_child_0_layout.left());\n\tassert_eq!(0.0, child_1_child_0_layout.top());\n\tassert_eq!(20.0, child_1_child_0_layout.width());\n\tassert_eq!(20.0, child_1_child_0_layout.height());\n\n\tassert_eq!(50.0, child_2_layout.left());\n\tassert_eq!(0.0, child_2_layout.top());\n\tassert_eq!(40.0, child_2_layout.width());\n\tassert_eq!(70.0, child_2_layout.height());\n\n\tassert_eq!(0.0, child_2_child_0_layout.left());\n\tassert_eq!(0.0, child_2_child_0_layout.top());\n\tassert_eq!(10.0, child_2_child_0_layout.width());\n\tassert_eq!(10.0, child_2_child_0_layout.height());\n\n\tassert_eq!(50.0, child_3_layout.left());\n\tassert_eq!(70.0, child_3_layout.top());\n\tassert_eq!(50.0, child_3_layout.width());\n\tassert_eq!(20.0, child_3_layout.height());\n\n\troot.calculate_layout(Undefined, Undefined, Direction::RTL);\n\n\tlet root_layout = root.get_layout();\n\tlet child_0_layout = root_child_0.get_layout();\n\tlet child_1_layout = root_child_1.get_layout();\n\tlet child_1_child_0_layout = root_child_1_child_0.get_layout();\n\tlet child_2_layout = root_child_2.get_layout();\n\tlet child_2_child_0_layout = root_child_2_child_0.get_layout();\n\tlet child_3_layout = root_child_3.get_layout();\n\n\tassert_eq!(0.0, root_layout.left());\n\tassert_eq!(0.0, root_layout.top());\n\tassert_eq!(100.0, root_layout.width());\n\tassert_eq!(100.0, root_layout.height());\n\n\tassert_eq!(50.0, child_0_layout.left());\n\tassert_eq!(0.0, child_0_layout.top());\n\tassert_eq!(50.0, child_0_layout.width());\n\tassert_eq!(50.0, child_0_layout.height());\n\n\tassert_eq!(70.0, child_1_layout.left());\n\tassert_eq!(50.0, child_1_layout.top());\n\tassert_eq!(30.0, child_1_layout.width());\n\tassert_eq!(50.0, child_1_layout.height());\n\n\tassert_eq!(10.0, child_1_child_0_layout.left());\n\tassert_eq!(0.0, child_1_child_0_layout.top());\n\tassert_eq!(20.0, child_1_child_0_layout.width());\n\tassert_eq!(20.0, child_1_child_0_layout.height());\n\n\tassert_eq!(10.0, child_2_layout.left());\n\tassert_eq!(0.0, child_2_layout.top());\n\tassert_eq!(40.0, child_2_layout.width());\n\tassert_eq!(70.0, child_2_layout.height());\n\n\tassert_eq!(30.0, child_2_child_0_layout.left());\n\tassert_eq!(0.0, child_2_child_0_layout.top());\n\tassert_eq!(10.0, child_2_child_0_layout.width());\n\tassert_eq!(10.0, child_2_child_0_layout.height());\n\n\tassert_eq!(0.0, child_3_layout.left());\n\tassert_eq!(70.0, child_3_layout.top());\n\tassert_eq!(50.0, child_3_layout.width());\n\tassert_eq!(20.0, child_3_layout.height());\n}", "item_id": 16, "repo": "mehcode/yoga-rs", "file": "tests/align_items_test.rs", "last_update_at": "2019-04-11T14:07:42+00:00"}
{"hexsha": "64bd06241455d09a190e768da6e96ebf6504eb3f", "ext": "rs", "lang": "Rust", "content": "fn calculate_intersections(horizontals: Segments, verticals: Segments) -> Intersections {\n    let mut intersections: Intersections = vec![];\n    for h in horizontals.iter() {\n        for v in verticals.iter() {\n            let (x1, x2, xv) = (h.p1.x, h.p2.x, v.p1.x);\n            let (y1, y2, yh) = (v.p1.y, v.p2.y, h.p1.y);\n\n            if route(x1, x2).contains(&xv) && route(y1, y2).contains(&yh) {\n                let h_steps = if x1 > xv { x1 - xv } else { xv - x1 };\n                let v_steps = if y1 > yh { y1 - yh } else { yh - y1 };\n                let steps = h_steps.abs() + v_steps.abs();\n\n                let point = Point { x: xv, y: yh };\n                let cost = h.last_steps + v.last_steps + steps;\n                intersections.push(Intersection { point, cost })\n            }\n        }\n    }\n    intersections\n}", "item_id": 4, "repo": "asaaki/advent-of-code-2019", "file": "day_3/src/main.rs", "last_update_at": "2019-12-04T08:04:47+00:00"}
{"hexsha": "361786427b43e63c96e1572d6ae73b7ec03b5555", "ext": "rs", "lang": "Rust", "content": "fn menu_loop() {\n    let mut keep_playing = true;\n    while keep_playing {\n        game_loop();\n        keep_playing = play_again();\n    }\n    println!(\"Bye.\");\n}", "item_id": 4, "repo": "OMerkel/hangman", "file": "rust/src/main.rs", "last_update_at": "2019-04-16T04:09:41+00:00"}
{"hexsha": "8dccec5f395287c0afb837916967123e68a704f1", "ext": "rs", "lang": "Rust", "content": "fn greet(_: &Request, res: Response<Fresh>, cap: Captures) {\n    let mut r = res.start().unwrap();\n    r.write_all(format!(\"Hello, {}\", cap.at(1).unwrap()).as_bytes()).unwrap();\n    r.end().unwrap();\n}", "item_id": 2, "repo": "kpp/rust_vs_go_habr_273341", "file": "rust/src/main.rs", "last_update_at": "2019-09-04T01:32:36+00:00"}
{"hexsha": "debf0e957e9532c37cfb48e0ca38a957ebc75263", "ext": "rs", "lang": "Rust", "content": "fn is_range_empty(engine: &DB, cf: &str, start_key: &[u8], end_key: &[u8]) -> Result<bool> {\n    let mut count: u32 = 0;\n    engine.scan_cf(cf, start_key, end_key, false, |_, _| {\n        count += 1;\n        Ok(false)\n    })?;\n\n    Ok(count == 0)\n}", "item_id": 0, "repo": "gregwebs/tikv", "file": "src/raftstore/store/bootstrap.rs", "last_update_at": "2019-03-06T07:07:25+00:00"}
{"hexsha": "026a03dfe1d252c9b6a778c7eca0317b6a75f042", "ext": "rs", "lang": "Rust", "content": "pub fn report_errors(files: Files, errors: Errors) -> ! {\n    assert!(!errors.is_empty());\n    let mut codemap = CodeMap::new();\n    let mut file_mapping = HashMap::new();\n    let mut current_end = 1;\n    for (fname, filemap) in files.into_iter() {\n        file_mapping.insert(fname, current_end);\n        let added_fmap = codemap.add_filemap(FileName::real(fname), filemap.src().to_string());\n        current_end = added_fmap.span().end().to_usize() + 1;\n    }\n    render_errors(&codemap, file_mapping, errors);\n    std::process::exit(1)\n}", "item_id": 0, "repo": "iqlusioninc/libra", "file": "language/move-lang/src/errors/mod.rs", "last_update_at": "2019-06-19T01:34:22+00:00"}
{"hexsha": "5e6c54232d0ab5769881565b62e2e5745ca9b290", "ext": "rs", "lang": "Rust", "content": "pub fn runner() {\n    let mut console = ConsoleHandle::init_default();\n    console.clear();\n\n    println!(\"Setting up sterr file hooks.\");\n    console.update();\n    let mut error_file = match redirect_stderr(\"nx_fatdrive_sterr.txt\") {\n        Ok(fl) => fl,\n        Err(e) => {\n            println!(\"Error setting stderr output: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    console.update();\n    \n    \n    multprint!(console,error_file,\"Setting up HID context.\");\n    let mut hid_ctx = HidContext::new();\n    let controller = hid_ctx.get_controller(HidControllerID::CONTROLLER_P1_AUTO);\n\n    multprint!(console,error_file,\"Setting up usb:hs context\");\n    let mut usbhs_ctx = match UsbHsContext::initialize() {\n        Ok(ctx) => ctx, \n        Err(e) => {\n            multprint!(console, error_file, \"Failed setting up usb:hs context: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    let filter : InterfaceFilter = InterfaceFilter::new()\n        .with_interface_class(8)\n        .with_interface_subclass(6)\n        .with_interface_protocol(80);\n    \n    multprint!(console, error_file, \"Waiting for usb event.\");\n    let evt = match InterfaceAvailableEvent::create(true, 0, filter) {\n        Ok(ev) => ev, \n        Err(e) => {\n            multprint!(console, error_file, \"Failed building iface available event: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n\n        }\n    };\n    if let Err(e) = evt.wait(u64::max_value()) {\n        multprint!(console, error_file, \"Failed waiting for event: {:?}\", e);\n        let delay_start = Instant::now();\n        while delay_start.elapsed() < Duration::from_secs(5) {\n            console.update();\n        }\n        return;\n    }\n    multprint!(console,error_file,\"Looking for usb devices.\");\n\n    let mut interfaces = match usbhs_ctx.query_available_interfaces(filter, 3) {\n        Ok(ifaces) => ifaces, \n        Err(e) => {\n            multprint!(console, error_file, \"Failed querying available interfaces: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    multprint!(console, error_file, \"Got interfaces: {:?}\", interfaces);\n\n    let mut iface = match interfaces.pop() {\n        Some(iface) => iface, \n        None => {\n            multprint!(console, error_file, \"Failed finding any matching interfaces.\");\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    multprint!(console, error_file, \"\\nSuccess! Using iface: {:?}\", iface);\n\n    console.update();\n\n    let (read_ep, write_ep) = match UsbClient::retrieve_iface_endpoints(&iface) {\n        Ok(p) => p,\n        Err(e) => {\n            multprint!(console, error_file, \"Failed getting eps: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    let mut session = match usbhs_ctx.acquire_interface(&iface) {\n        Ok(s) => s,\n        Err(e) => {\n            multprint!(console, error_file, \"Failed acquiring iface: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    let client = match UsbClient::new(session, read_ep, write_ep) {\n        Ok(c) => c, \n        Err(e) => {\n            multprint!(console, error_file, \"Got error on usbclient::new of {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n\n        }\n    };\n    \n    multprint!(console,error_file,\"Making SCSI wrapper object.\");\n    console.update();\n\n    let mut scsi_wrapper = match scsi::scsi::ScsiBlockDevice::new(client, VecNewtype::new(), VecNewtype::new(), VecNewtype::new()) {\n        Ok(c) => c,\n        Err(e) => {\n            multprint!(console, error_file, \"Failed creating SCSI wrapper object: {:?}\", e);\n\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    multprint!(console,error_file,\"SCSI device found with block size {}.\", scsi_wrapper.block_size());\n    multprint!(console,error_file,\"Trying to get MBR.\");\n    console.update();\n\n    let mut mbr_buff = VecNewtype::with_fake_capacity(512.max(scsi_wrapper.block_size() as usize));\n    let mut mbr_read_count = 0;\n    while mbr_buff.inner.len() < 512 {\n        multprint!(console, error_file, \"MBR Parse pre-status {}: {}/512.\", mbr_read_count, mbr_buff.inner.len());\n        let _bt = match scsi_wrapper.read(mbr_buff.inner.len() as u32, &mut mbr_buff) {\n            Ok(bt) => {\n                multprint!(console, error_file, \"Got {} bytes on read {}.\", mbr_buff.inner.len(), bt);\n                multprint!(console, error_file, \"Ended with bytes: {:X?}\", mbr_buff.inner);\n                bt\n            }, \n            Err(e) => {\n                multprint!(console, error_file, \"Failed reading MBR on read number {} after already getting {} bytes: {:?}.\", mbr_read_count, mbr_buff.inner.len(), e);\n                multprint!(console, error_file, \"Ended with bytes: {:X?}\", mbr_buff.inner);\n\n                let delay_start = Instant::now();\n                while delay_start.elapsed() < Duration::from_secs(5) {\n                    console.update();\n                }\n                return;\n            }\n        };\n        mbr_read_count += 1;\n    }\n\n    multprint!(console,error_file,\"Parsing MBR.\");\n    console.update();\n\n    let mbr_entry = match mbr_nostd::MasterBootRecord::from_bytes(&mut mbr_buff.inner) {\n        Ok(mbr) => mbr, \n        Err(e) => {\n            multprint!(console, error_file, \"Failed parsing mbr: {:?}\", e);\n\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n\n    multprint!(console,error_file,\"Partitions:\");\n    for ent in mbr_entry.partition_table_entries() {\n        multprint!(console,error_file,\"    {:?}\", ent);\n    }\n\n\n    let first_ent : &PartitionTableEntry = &mbr_entry.partition_table_entries()[0];\n    let raw_offset : usize = (first_ent.logical_block_address * scsi_wrapper.block_size()) as usize; \n    multprint!(console, error_file, \"Creating FATFS wrapper starting at offset block {}, raw {}.\", first_ent.logical_block_address, raw_offset);\n\n    let mut partition = OffsetScsiDevice::new(scsi_wrapper, raw_offset);\n    let mut fs : fatfs::FileSystem<OffsetScsiDevice> = match fatfs::FileSystem::new(partition, fatfs::FsOptions::new()) {\n        Ok(fs) => fs, \n        Err(e) => {\n            multprint!(console, error_file, \"Error mounting FAT32 file system: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    multprint!(console, error_file, \"Scanning filesystem.\");\n    let mut root_dir = fs.root_dir();\n    let all_dirs = root_dir.iter().filter_map(|ent_res| {\n        match ent_res {\n            Ok(ent) => {\n                multprint!(console, error_file, \"FAT: Found itm. Short name: {}, long name: {}, attr: {:?}\", ent.short_file_name(), ent.file_name(), ent.attributes());\n                Some(ent)\n            },\n            Err(e) => {\n                multprint!(console, error_file, \"Error reading dirent: {:?}\", e);\n                None\n            }\n        }\n\n    }).collect::<Vec<_>>();\n\n    multprint!(console, error_file, \"Getting handle to test_folder directory.\");\n    let subdir_opt = all_dirs.iter().find_map(|fl| {\n        if fl.is_dir() && fl.file_name() == \"test_folder\".to_owned() {\n            multprint!(console, error_file,\"FAT: Using existing subdir: Short name: {}, long name: {}, attr: {:?}\", fl.short_file_name(), fl.file_name(), fl.attributes());\n            Some(fl.to_dir())\n        }\n        else {\n            None\n        }\n    });\n\n    let mut subdir_res = subdir_opt.ok_or(\"Could not find existing subdir.\").or_else(|_| {\n        root_dir.create_dir(\"test_folder\")\n    });\n    let mut subdir = match subdir_res {\n        Ok(s) => s, \n        Err(e) => {\n            multprint!(console, error_file, \"Error getting handle to test_folder: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n\n    let now = Instant::now();\n    let fl_name = format!(\"{:?}.txt\", now).replace(\" \", \"s\").replace(\":\", \"o\").replace(\"{\", \"q\").replace(\"}\", \"p\");\n    multprint!(console, error_file, \"Creating test file {} in the folder.\", fl_name);\n    let mut fl = match subdir.create_file(&fl_name) {\n        Ok(f) => f, \n        Err(e) => {\n            multprint!(console, error_file, \"Error creating test file: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    multprint!(console, error_file,\"Now writing to file.\");\n    if let Err(e) = fl.write_fmt(format_args!(\"Hello world at time {:?}\", now)) {\n        multprint!(console, error_file, \"Error writing to test file: {:?}\", e);\n        let delay_start = Instant::now();\n        while delay_start.elapsed() < Duration::from_secs(5) {\n            console.update();\n        }\n        return;\n    }\n\n    let next_dir_name = format!(\"{:?}_next_dir\", now).replace(\" \", \"s\").replace(\":\", \"o\").replace(\"{\", \"q\").replace(\"}\", \"p\");\n    multprint!(console, error_file, \"Now trying directory {}.\", next_dir_name);\n    let mut next_dir = match root_dir.create_dir(&next_dir_name) {\n        Ok(s) => s, \n        Err(e) => {\n            multprint!(console, error_file, \"Error getting handle to next_dir: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n    let mut outfile = match next_dir.create_file(\"for_seuth.txt\") {\n        Ok(f) => f, \n        Err(e) => {\n            multprint!(console, error_file, \"Error creating for_seuth.txt: {:?}\", e);\n            let delay_start = Instant::now();\n            while delay_start.elapsed() < Duration::from_secs(5) {\n                console.update();\n            }\n            return;\n        }\n    };\n\n    if let Err(e) = outfile.write(\"To be or not to be and all that jazz!.\".to_owned().into_bytes().as_slice()) {\n        multprint!(console, error_file, \"Error writing to for_seuth.txt: {:?}\", e);\n        let delay_start = Instant::now();\n        while delay_start.elapsed() < Duration::from_secs(5) {\n            console.update();\n        }\n        return;\n\n    }\n\n    multprint!(console, error_file, \"Done.\");\n\n    loop {\n        hid_ctx.scan_input();\n        if controller.keys_down_raw() & HidControllerKeys::KEY_PLUS.0 as u64 != 0 {\n            break;\n        }\n    }\n}", "item_id": 2, "repo": "tiliarou/nx-fatdrive", "file": "src/main.rs", "last_update_at": "2019-06-03T03:09:36+00:00"}
{"hexsha": "103bb289955d9d19e1c77ea529c987c8fd24466b", "ext": "rs", "lang": "Rust", "content": "fn _left(state: State) -> State {\n    let (s1, s2, s3, s4) = state.coords;\n    let coords = (\n        Coord {\n            x: s1.x - 1,\n            y: s1.y,\n        },\n        Coord {\n            x: s2.x - 1,\n            y: s2.y,\n        },\n        Coord {\n            x: s3.x - 1,\n            y: s3.y,\n        },\n        Coord {\n            x: s4.x - 1,\n            y: s4.y,\n        },\n    );\n    State {\n        coords: coords,\n        position: state.position,\n    }\n}", "item_id": 7, "repo": "patrickgombert/tetris", "file": "src/tetris/piece.rs", "last_update_at": "2019-02-13T22:55:12+00:00"}
{"hexsha": "e0e2dc5d343e738004eb2cfde6a1c8daa851ffd6", "ext": "rs", "lang": "Rust", "content": "fn test_trace_estimator() {\n        let n = 1000;\n        let num_random_vecs = 40;\n        let x = Array::random((n, n), StandardNormal).mapv(|e| e as i32 as f32);\n        // want to estimate the trace of x.t().dot(&x)\n        let true_trace = sum_of_squares(x.iter());\n        println!(\"true trace: {}\", true_trace);\n\n        let rand_mat =\n            generate_plus_minus_one_bernoulli_matrix(n, num_random_vecs);\n\n        let trace_est =\n            sum_of_squares(x.dot(&rand_mat).iter()) / num_random_vecs as f64;\n        println!(\"trace_est: {}\", trace_est);\n    }", "item_id": 1, "repo": "sriramlab/saber", "file": "src/bin/estimate_heritability.rs", "last_update_at": "2019-09-05T08:34:59+00:00"}
{"hexsha": "48f231d013221c6e8c0d645a2ded48f68932b7cc", "ext": "rs", "lang": "Rust", "content": "fn parse_int(rem: &mut &str) -> u64 {\n    let end = rem\n        .char_indices()\n        .skip_while(|&(_, c)| c.is_ascii_digit())\n        .map(|(i, _)| i)\n        .next()\n        .unwrap_or(rem.len());\n\n    let int = rem[..end].parse().unwrap();\n    *rem = &rem[end..];\n    int\n}", "item_id": 2, "repo": "agausmann/puzzles", "file": "adventofcode/2020/day18b.rs", "last_update_at": "2019-08-10T12:12:04+00:00"}
{"hexsha": "42a292c6fe6822a497a65fcea755d5270bfc7dbc", "ext": "rs", "lang": "Rust", "content": "fn multiword_to_multiword_synonyms() {\n        let mut store = TempDatabase::from_iter(vec![\n            (\"NY\", &[doc_char_index(0, 0, 0)][..]),\n            (\"subway\", &[doc_char_index(0, 1, 1)][..]),\n            (\"NYC\", &[doc_char_index(1, 0, 0)][..]),\n            (\"blue\", &[doc_char_index(1, 1, 1)][..]),\n            (\"subway\", &[doc_char_index(1, 2, 2)][..]),\n            (\"broken\", &[doc_char_index(1, 3, 3)][..]),\n            (\"new\", &[doc_char_index(2, 0, 0)][..]),\n            (\"york\", &[doc_char_index(2, 1, 1)][..]),\n            (\"underground\", &[doc_char_index(2, 2, 2)][..]),\n            (\"train\", &[doc_char_index(2, 3, 3)][..]),\n            (\"broken\", &[doc_char_index(2, 4, 4)][..]),\n        ]);\n\n        store.add_synonym(\n            \"new york\",\n            SetBuf::from_dirty(vec![\"NYC\", \"NY\", \"new york city\"]),\n        );\n        store.add_synonym(\n            \"new york city\",\n            SetBuf::from_dirty(vec![\"NYC\", \"NY\", \"new york\"]),\n        );\n        store.add_synonym(\"underground train\", SetBuf::from_dirty(vec![\"subway\"]));\n\n        let env = &store.database.env;\n        let reader = env.read_txn().unwrap();\n\n        let builder = store.query_builder();\n        let results = builder\n            .query(&reader, \"new york underground train broken\", 0..20)\n            .unwrap();\n        let mut iter = results.into_iter();\n\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(2), matches, .. }) => {\n            let mut matches = matches.into_iter();\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: false, .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: false, .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // city\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // underground\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // train\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 5, word_index: 5, is_exact: true,  .. })); // broken\n            assert_matches!(matches.next(), None);\n        });\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(1), matches, .. }) => {\n            let mut iter = matches.into_iter();\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NYC = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NYC = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // NYC = city\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 4, is_exact: true,  .. })); // subway = underground\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 5, is_exact: true,  .. })); // subway = train\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 5, word_index: 6, is_exact: true,  .. })); // broken\n            assert_matches!(iter.next(), None);\n        });\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(0), matches, .. }) => {\n            let mut iter = matches.into_iter();\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NY = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NY = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // NY = city\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // subway = underground\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // subway = train\n            assert_matches!(iter.next(), None);\n        });\n        assert_matches!(iter.next(), None);\n\n        let builder = store.query_builder();\n        let results = builder\n            .query(&reader, \"new york city underground train broken\", 0..20)\n            .unwrap();\n        let mut iter = results.into_iter();\n\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(2), matches, .. }) => {\n            let mut matches = matches.into_iter();\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: false, .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: false, .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // new\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: false, .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: false, .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // york\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: false, .. })); // city\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // underground\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // train\n            assert_matches!(matches.next(), Some(TmpMatch { query_index: 5, word_index: 5, is_exact: true,  .. })); // broken\n            assert_matches!(matches.next(), None);\n        });\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(1), matches, .. }) => {\n            let mut iter = matches.into_iter();\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true, .. })); // NYC = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true, .. })); // NYC = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true, .. })); // NYC = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true, .. })); // NYC = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true, .. })); // NYC = city\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 4, is_exact: true, .. })); // subway = underground\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 5, is_exact: true, .. })); // subway = train\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 5, word_index: 6, is_exact: true, .. })); // broken\n            assert_matches!(iter.next(), None);\n        });\n        assert_matches!(iter.next(), Some(Document { id: DocumentId(0), matches, .. }) => {\n            let mut iter = matches.into_iter();\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NY = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NY = new\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NY = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NY = york\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // NY = city\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // subway = underground\n            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // subway = train\n            assert_matches!(iter.next(), None);\n        });\n        assert_matches!(iter.next(), None);\n    }", "item_id": 17, "repo": "bidoubiwa/MeiliDB", "file": "meilidb-core/src/query_builder.rs", "last_update_at": "2019-11-07T16:51:03+00:00"}
{"hexsha": "e24c2a009f438fb0d893e36b3e90c9d67639c771", "ext": "rs", "lang": "Rust", "content": "pub unsafe fn mailmime_set_epilogue_text(\n    mut build_info: *mut mailmime,\n    mut data_str: *mut libc::c_char,\n    mut length: size_t,\n) -> libc::c_int {\n    let mut data: *mut mailmime_data = 0 as *mut mailmime_data;\n    data = mailmime_data_new(\n        MAILMIME_DATA_TEXT as libc::c_int,\n        MAILMIME_MECHANISM_8BIT as libc::c_int,\n        0i32,\n        data_str,\n        length,\n        0 as *mut libc::c_char,\n    );\n    if data.is_null() {\n        return MAILIMF_ERROR_MEMORY as libc::c_int;\n    }\n    (*build_info).mm_data.mm_multipart.mm_epilogue = data;\n    return MAILIMF_NO_ERROR as libc::c_int;\n}", "item_id": 15, "repo": "KAction/mmime", "file": "src/mailmime_types_helper.rs", "last_update_at": "2019-09-16T15:25:05+00:00"}
{"hexsha": "8d5fbe44f15a13bf82e8b3d2c7dd5a9f213e3057", "ext": "rs", "lang": "Rust", "content": "fn get_nugetpkg_version<P: AsRef<Path>>(nuget_path: P) -> String {\n    let version_path = {\n        let mut version_path = nuget_path.as_ref().to_owned();\n        version_path.push(\"VERSION\");\n        version_path\n    };\n    let mut version_file = File::open(version_path)\n                                .expect(\"Failed to open VERSION file\");\n\n    let mut version_string = String::new();\n    version_file.read_to_string(&mut version_string).unwrap();\n\n    version_string\n}", "item_id": 7, "repo": "robmikh/nuget_cpp", "file": "src/main.rs", "last_update_at": "2019-07-29T19:34:48+00:00"}
{"hexsha": "487997dd54a7c4c3dce18928fcf3135a4cfc70d7", "ext": "rs", "lang": "Rust", "content": "fn test_run() {\n    let man = ProcessManager::new();\n    let inner = man.clone();\n    let flag: Arc<RwLock<Option<Vec<u8>>>> = Default::default();\n    let inner_flag = flag.clone();\n\n    thread::spawn(move || {\n        inner.run_process_with_intercept(\n            \"foo\".to_string(),\n            Command::new(\"echo\").arg(\"hello\"),\n            move |ev: ProcessEvent, k: &dyn Fn(ProcessEvent) -> Result<()>| {\n                println!(\"event: {}\", ev);\n                if let ProcessEvent::Output(_handle, bytes, len) = &ev {\n                    if *len > 0 {\n                        *inner_flag.write().unwrap() = Some({\n                            let mut b = bytes.clone();\n                            b.truncate(*len);\n                            b\n                        })\n                    }\n                };\n                k(ev)\n            },\n        )\n    });\n\n    println!(\"running the directory\");\n    man.run_director().expect(\"run_director failed\");\n\n    let mv = flag.read().unwrap();\n    let v = mv.as_ref().unwrap();\n    assert_eq!(&v[..v.len()], \"hello\\n\".as_bytes());\n}", "item_id": 0, "repo": "jwiegley/procman", "file": "tests/simple.rs", "last_update_at": "2019-08-28T14:34:57+00:00"}
{"hexsha": "f66bb2399630427c8a60fab70536952f6fd70fe8", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    env_logger::init();\n    let server = Server::http(\"127.0.0.1:1337\").unwrap();\n    let _guard = server.handle(echo);\n    println!(\"Listening on http://127.0.0.1:1337\");\n}", "item_id": 1, "repo": "khvzak/hyper-sync", "file": "examples/server.rs", "last_update_at": "2019-04-22T10:04:57+00:00"}
{"hexsha": "4b1c925c4ddbff08468c073c2584476e28efd091", "ext": "rs", "lang": "Rust", "content": "pub fn cli_command(arg: &[String]) -> Result<(), UnameError> {\n    let mut buf: utsname = utsname {\n        sysname: [0; 65],\n        nodename: [0; 65],\n        release: [0; 65],\n        version: [0; 65],\n        machine: [0; 65],\n        domainname: [0; 65],\n    };\n\n    unsafe {\n        uname(&mut buf as *mut libc::utsname);\n    };\n\n    let opts = Opts::parse_from(arg);\n\n    if opts.kernel_name\n        || opts.all\n        || (!opts.nodename && !opts.kernel_release && !opts.kernel_version && !opts.machine)\n    {\n        print_c_char(&buf.sysname);\n        print!(\" \");\n    }\n\n    if opts.nodename || opts.all {\n        print_c_char(&buf.nodename);\n        print!(\" \");\n    }\n\n    if opts.kernel_release || opts.all {\n        print_c_char(&buf.release);\n        print!(\" \");\n    }\n\n    if opts.kernel_version || opts.all {\n        print_c_char(&buf.version);\n        print!(\" \");\n    }\n\n    if opts.machine || opts.all {\n        print_c_char(&buf.machine);\n        print!(\" \");\n    }\n\n    println!();\n\n    Ok(())\n}", "item_id": 0, "repo": "rarewin/rust-coreutils", "file": "src/uname.rs", "last_update_at": "2019-10-25T13:17:58+00:00"}
{"hexsha": "3047fd74874230e1c025c791fdfd2f52903a61cc", "ext": "rs", "lang": "Rust", "content": "pub fn lba_to_cls(\n    disk_lba: u64,\n    head_count: u64,\n    sector_count: u64,\n) -> (u8, u8, u8)\n{\n    let mut sector_number = (disk_lba % sector_count) + 1;;\n    let tmp = disk_lba / sector_count;\n    let mut head_number = tmp % head_count;\n    let mut cylinder_number = tmp / head_count;\n\n    if cylinder_number > 0x400 {\n        cylinder_number = 0x3FF;\n        head_number = head_count;\n        sector_number = sector_count;\n    }\n\n    sector_number |= (cylinder_number & 0x300) >> 2;\n    cylinder_number &= 0xFF;\n\n    (head_number as u8, sector_number as u8, cylinder_number as u8)\n}", "item_id": 1, "repo": "tiliarou/KFS", "file": "fs/src/detail/utils.rs", "last_update_at": "2019-07-27T12:48:13+00:00"}
{"hexsha": "6d6ccdb6ad23839ab86b70aa322f7b95e988d44d", "ext": "rs", "lang": "Rust", "content": "fn test_cvc4_qfuflia() {\n        use std::fs;\n        let unparsed_file = fs::read_to_string(\"tests/data/qfuflia.smt2\").expect(\"cannot read file\");\n        let mut q = Query::new();\n        q.parse_query(&unparsed_file).unwrap();\n\n        let sol_cvc4 = q.check_cvc4().expect(\"could not parse\");\n        assert!(q.eval(&sol_cvc4).unwrap());\n    }", "item_id": 0, "repo": "FedericoAureliano/llama", "file": "src/smt/mod.rs", "last_update_at": "2019-12-15T06:32:59+00:00"}
{"hexsha": "7b88f28c36d15e7bf13ac1132acc18ea157450c6", "ext": "rs", "lang": "Rust", "content": "pub fn parse(input_string: String) -> ParseTree {\n    let mut tree = NonTerminal::SourceUnit.to_leaf();\n    let current_ptr = &mut 0;\n    let input = &mut input_string.chars().collect::<Vec<char>>();\n    while *current_ptr < input.len() {\n        match lex_4_25::peek_token(input, current_ptr) {\n            lex_4_25::Token::Pragma => {\n                tree.add_tree(parse_pragma_directive(input, current_ptr));\n            }\n            lex_4_25::Token::Import => {\n                tree.add_tree(parse_import_directive(input, current_ptr));\n            }\n            lex_4_25::Token::Contract  |\n            lex_4_25::Token::Library   |\n            lex_4_25::Token::Interface => {\n                tree.add_tree(parse_contract_definition(input, current_ptr));\n            }\n            lex_4_25::Token::EOF => {\n                lex_4_25::next_token(input, current_ptr);\n            }\n            actual => {\n                lex_4_25::next_token(input, current_ptr);\n                tree.root = NonTerminal::SourceUnit.to_invalid_token_pair(actual);\n            }\n        }\n    }\n    tree\n}", "item_id": 0, "repo": "jalextowle/solfix", "file": "src/parse_4_25.rs", "last_update_at": "2019-06-12T10:41:50+00:00"}
{"hexsha": "183e5b808be51086657173d38d4150c4720d81d0", "ext": "rs", "lang": "Rust", "content": "fn test_div() {\n        let one: ModInt = ModInt::from_value_modulus(\n            BigInt::from(23),\n            BigInt::from(11),\n        );\n\n        let two: ModInt = ModInt::from_value_modulus(\n            BigInt::from(2),\n            BigInt::from(0),\n        );\n\n        let div = one / two;\n        assert_eq!(BigInt::from(6), div.value);\n        assert_eq!(BigInt::from(11), div.modulus);\n\n\n        let one2: ModInt = ModInt::from_value_modulus(\n            BigInt::from(23),\n            BigInt::from(11),\n        );\n        let two2: ModInt = ModInt::from_value_modulus(\n            BigInt::from(2),\n            BigInt::from(0),\n        );\n\n        let zero: ModInt = one2 - ModInt::one();\n        let zero_res: ModInt = zero / two2;\n        assert_eq!(BigInt::from(0), zero_res.value);\n        assert_eq!(BigInt::from(11), zero_res.modulus);\n    }", "item_id": 12, "repo": "provotum/rust-crypto", "file": "src/arithmetic/mod_int.rs", "last_update_at": "2019-03-15T15:46:46+00:00"}
{"hexsha": "2a744d18cddede60664e7d18cf64ed3cb4a32db7", "ext": "rs", "lang": "Rust", "content": "fn eval_pr(expression: &str) -> Result<bool> {\n        let mut map = HashMap::new();\n        map.insert(\n            String::from(\"commits\"),\n            Value::List(vec![\n                Expr::Value(Value::Dictionary(HashMap::new())),\n                Expr::Value(Value::Dictionary(HashMap::new())),\n            ]),\n        );\n        eval(expression, &Value::Dictionary(map))\n    }", "item_id": 2, "repo": "crawford/tailor", "file": "src/expr/mod.rs", "last_update_at": "2019-12-07T22:57:49+00:00"}
{"hexsha": "89a4cdc445e3fa9af21cef3c43502fa26f8bcfe9", "ext": "rs", "lang": "Rust", "content": "fn following_sibling_selects_in_document_order() {\n        let package = Package::new();\n        let doc = package.as_document();\n\n        let root = doc.root();\n        let child1 = doc.create_element(\"a\");\n        let child2 = doc.create_comment(\"b\");\n        let child3 = doc.create_processing_instruction(\"c\", None);\n\n        root.append_child(child1);\n        root.append_child(child2);\n        root.append_child(child3);\n\n        let result = execute(FollowingSibling, child1);\n\n        assert_eq!(result, ordered_nodes![child2, child3]);\n    }", "item_id": 7, "repo": "Acidburn0zzz/sxd-xpath", "file": "src/axis.rs", "last_update_at": "2019-02-26T08:49:41+00:00"}
{"hexsha": "e4e9c39ce892196e7b4e05ec3c4238d0b15599e5", "ext": "rs", "lang": "Rust", "content": "pub fn build_ssh_command_to_instance(\n        instance_id: &str,\n        ip_addr: &IpAddr,\n        login_name: Option<&String>,\n        ssh_opts: &[&str],\n        remote_command_args: &[&str],\n        timeout: Duration,\n    ) -> Result<Command> {\n        let mut ssh_opts: Vec<String> = ssh_opts.iter().map(|&s| s.to_string()).collect();\n        if let Some(login_name) = login_name {\n            ssh_opts.insert(0, \"-l\".to_owned());\n            ssh_opts.insert(1, login_name.to_owned());\n        };\n\n        let mut remote_command_args: Vec<String> = remote_command_args.iter().map(|&s| s.to_string()).collect();\n\n        let ssh_args = build_ssh_arguments(&ip_addr, &mut ssh_opts, &mut remote_command_args);\n\n        let log_path = tempfile::NamedTempFile::new()\n            .chain_err(|| ErrorKind::FailedToBuildSshCommand)?\n            .path()\n            .to_path_buf();\n        let c = Command {\n            id:      instance_id.to_owned(),\n            cmd:     \"ssh\".to_owned(),\n            args:    Some(ssh_args),\n            cwd:     None,\n            log:     log_path,\n            timeout: Some(timeout),\n        };\n        Ok(c)\n    }", "item_id": 5, "repo": "lukaspustina/ceres", "file": "src/utils/mod.rs", "last_update_at": "2019-05-20T08:36:46+00:00"}
{"hexsha": "cf4f3c0e7f482173044e709d3b612eb2d50eea60", "ext": "rs", "lang": "Rust", "content": "fn blockchain_will_not_add_block_with_unacceptable_proof_of_work() {\n        let mut chain = BlockChain::new();\n        let block = Block {\n            block_num: 1,\n            timestamp: util::millis_since_unix_epoch(),\n            nonce: 0,\n            data: String::from(\"hello\"),\n            prev_hash: chain.genesis_hash.clone(),\n        };\n        let hash = block.hash().unwrap();\n        assert!(!is_acceptable_proof_of_work(&hash));\n        let result = chain.add(block);\n        assert!(result.is_err());\n        let err = result.unwrap_err();\n        assert_eq!(err, Error::UnacceptableProofOfWork { hash });\n    }", "item_id": 4, "repo": "dan-f/blockchain", "file": "src/blockchain.rs", "last_update_at": "2019-08-08T00:55:12+00:00"}
{"hexsha": "8375521a70210c4c52d2caa4043e490a84754f40", "ext": "rs", "lang": "Rust", "content": "pub fn sync<F, B, E>(spec: FactoryChainSpec<F>, mut block_factory: B, mut extrinsic_factory: E) where\n\tF: ServiceFactory,\n\tF::FullService: Future<Item=(), Error=()>,\n\tF::LightService: Future<Item=(), Error=()>,\n\tB: FnMut(&SyncService<F::FullService>) -> BlockImportParams<F::Block>,\n\tE: FnMut(&SyncService<F::FullService>) -> FactoryExtrinsic<F>,\n{\n\tconst NUM_FULL_NODES: usize = 10;\n\t// FIXME: BABE light client support is currently not working.\n\tconst NUM_LIGHT_NODES: usize = 0;\n\tconst NUM_BLOCKS: usize = 512;\n\tlet temp = TempDir::new(\"substrate-sync-test\").expect(\"Error creating test dir\");\n\tlet mut network = TestNet::<F>::new(\n\t\t&temp,\n\t\tspec.clone(),\n\t\tNUM_FULL_NODES,\n\t\tNUM_LIGHT_NODES,\n\t\tvec![],\n\t\t30500,\n\t);\n\tinfo!(\"Checking block sync\");\n\tlet first_address = {\n\t\tlet first_service = &network.full_nodes[0].1;\n\t\tlet mut client = first_service.get().client();\n\t\tfor i in 0 .. NUM_BLOCKS {\n\t\t\tif i % 128 == 0 {\n\t\t\t\tinfo!(\"Generating #{}\", i);\n\t\t\t}\n\t\t\tlet import_data = block_factory(&first_service);\n\t\t\tclient.import_block(import_data, HashMap::new()).expect(\"Error importing test block\");\n\t\t}\n\t\tnetwork.full_nodes[0].2.clone()\n\t};\n\n\tinfo!(\"Running sync\");\n\tfor (_, service, _) in network.full_nodes.iter().skip(1) {\n\t\tservice.get().network().add_reserved_peer(first_address.to_string()).expect(\"Error adding reserved peer\");\n\t}\n\tfor (_, service, _) in network.light_nodes.iter() {\n\t\tservice.get().network().add_reserved_peer(first_address.to_string()).expect(\"Error adding reserved peer\");\n\t}\n\tnetwork.run_until_all_full(\n\t\t|_index, service|\n\t\t\tservice.get().client().info().chain.best_number == (NUM_BLOCKS as u32).into(),\n\t\t|_index, service|\n\t\t\tservice.get().client().info().chain.best_number == (NUM_BLOCKS as u32).into(),\n\t);\n\n\tinfo!(\"Checking extrinsic propagation\");\n\tlet first_service = network.full_nodes[0].1.clone();\n\tlet best_block = BlockId::number(first_service.get().client().info().chain.best_number);\n\tlet extrinsic = extrinsic_factory(&first_service);\n\tfirst_service.get().transaction_pool().submit_one(&best_block, extrinsic).unwrap();\n\tnetwork.run_until_all_full(\n\t\t|_index, service| service.get().transaction_pool().ready().count() == 1,\n\t\t|_index, _service| true,\n\t);\n}", "item_id": 2, "repo": "HPIPS/HPIPS_Chain", "file": "core/service/test/src/lib.rs", "last_update_at": "2019-08-07T10:22:08+00:00"}
{"hexsha": "73afd4d81a04d3d999cd95dbbd4bbb68b04e2778", "ext": "rs", "lang": "Rust", "content": "pub fn test_deserialize_vehicle_status() {\n        let msg_data = test_shared::get_vehicle_status();\n        let encoded:Vec<u8> = msg_data.ser();\n        let decoded = VehicleStatusData::deser(encoded.as_slice()).unwrap();\n        assert_eq!(msg_data.onboard_control_sensors_health, decoded.onboard_control_sensors_health);\n    }", "item_id": 1, "repo": "tstellanova/uorb-codec", "file": "tests/serialization_tests.rs", "last_update_at": "2019-02-24T02:42:58+00:00"}
{"hexsha": "317cd575022f054f10b312acd977441a6c51fefc", "ext": "rs", "lang": "Rust", "content": "fn dns_san_server() {\n    const MODULE_ID: &str = \"m1\";\n    const GENERATION_ID: &str = \"g1\";\n\n    let (mut service, identity, home_dir, crypto) = init_test(MODULE_ID, GENERATION_ID);\n\n    // start up a simple Echo server using this server cert\n    let port = get_unused_tcp_port();\n    println!(\"Test server listening on port {}\", port);\n    let server = run_echo_server(identity, port);\n    let mut runtime = tokio::runtime::Runtime::new().unwrap();\n    runtime.spawn(server);\n\n    // run a test client that uses the module id for TLS domain name\n    let client1 = run_echo_client(&mut service, port, MODULE_ID);\n    runtime.block_on(client1).unwrap();\n\n    // run a test client that uses the CN for TLS domain name\n    // NOTE: Ideally, this should be a separate test, but there's some global\n    // state in the HSM C library that does not get reset between multiple\n    // tests in the same run and causes the test to fail.\n    let client2 = run_echo_client(&mut service, port, COMMON_NAME);\n    runtime.block_on(client2).unwrap();\n\n    // cleanup\n    crypto\n        .destroy_certificate(IOTEDGED_CA_ALIAS.to_string())\n        .unwrap();\n    home_dir.close().unwrap();\n}", "item_id": 6, "repo": "CIPop/iotedge", "file": "edgelet/edgelet-http-workload/tests/dns-san.rs", "last_update_at": "2019-11-27T22:42:12+00:00"}
{"hexsha": "e20fb5cff0b8d96462bc1af6489b1709a0e61066", "ext": "rs", "lang": "Rust", "content": "fn for_in() {\n        let mut out = Cursor::new(Vec::new());\n        let mut rt = Runtime::new(Program::empty(), &mut out).unwrap();\n        let stmt = get_stmt(\n            r#\"{\n            a[0] = 5;\n            a[1] = 10;\n            a[2] = 15;\n            a[3] = 20;\n            for (i in a) {\n                a[i] *= 2;\n            }\n        }\"#,\n        );\n        eval_stmt(&stmt, &mut rt).unwrap();\n        assert_eq!(\n            rt.vars.get(\"a\", Some(\"0\")).unwrap(),\n            Value::from(10.0),\n            \"{:?}\",\n            stmt\n        );\n        assert_eq!(\n            rt.vars.get(\"a\", Some(\"1\")).unwrap(),\n            Value::from(20.0),\n            \"{:?}\",\n            stmt\n        );\n        assert_eq!(\n            rt.vars.get(\"a\", Some(\"2\")).unwrap(),\n            Value::from(30.0),\n            \"{:?}\",\n            stmt\n        );\n        assert_eq!(\n            rt.vars.get(\"a\", Some(\"3\")).unwrap(),\n            Value::from(40.0),\n            \"{:?}\",\n            stmt\n        );\n    }", "item_id": 6, "repo": "scampi/falcon", "file": "src/interpreter/stmt.rs", "last_update_at": "2019-12-15T09:53:00+00:00"}
{"hexsha": "f2372cd5c8d2fa1010f169daaea859147731d6f4", "ext": "rs", "lang": "Rust", "content": "fn test_pool_serialize_toml() {\n    let config_a = PoolConfig::default();\n\n    let res = config_a.to_toml();\n    assert!(res.is_ok());\n    let toml = res.unwrap();\n\n    let res = PoolConfig::from_toml(&toml);\n    assert!(res.is_ok());\n    let config_b = res.unwrap();\n\n    assert_eq!(config_a, config_b)\n}", "item_id": 2, "repo": "alsacoin/alsacoin", "file": "config/src/pool.rs", "last_update_at": "2019-07-14T22:18:10+00:00"}
{"hexsha": "44707d76fcae4b9d0b451a68e7256373916d4b9f", "ext": "rs", "lang": "Rust", "content": "fn test_wrap_nodes_with_content_sizing_overflowing_margin() {\n\tlet mut root = Node::new();\n\troot.set_width(StyleUnit::Point(500.0.into()));\n\troot.set_height(StyleUnit::Point(500.0.into()));\n\n\tlet mut root_child0 = Node::new();\n\troot_child0.set_flex_direction(FlexDirection::Row);\n\troot_child0.set_flex_wrap(Wrap::Wrap);\n\troot_child0.set_width(StyleUnit::Point(85.0.into()));\n\troot.insert_child(&mut root_child0, 0);\n\n\tlet mut root_child0_child0 = Node::new();\n\troot_child0.insert_child(&mut root_child0_child0, 0);\n\n\tlet mut root_child0_child0_child0 = Node::new();\n\troot_child0_child0_child0.set_width(StyleUnit::Point(40.0.into()));\n\troot_child0_child0_child0.set_height(StyleUnit::Point(40.0.into()));\n\troot_child0_child0.insert_child(&mut root_child0_child0_child0, 0);\n\n\tlet mut root_child0_child1 = Node::new();\n\troot_child0_child1.set_margin(Edge::Right, StyleUnit::Point(10.0.into()));\n\troot_child0.insert_child(&mut root_child0_child1, 1);\n\n\tlet mut root_child0_child1_child0 = Node::new();\n\troot_child0_child1_child0.set_width(StyleUnit::Point(40.0.into()));\n\troot_child0_child1_child0.set_height(StyleUnit::Point(40.0.into()));\n\troot_child0_child1.insert_child(&mut root_child0_child1_child0, 0);\n\troot.calculate_layout(Undefined, Undefined, Direction::LTR);\n\n\tassert_eq!(0, root.get_layout_left() as i32);\n\tassert_eq!(0, root.get_layout_top() as i32);\n\tassert_eq!(500, root.get_layout_width() as i32);\n\tassert_eq!(500, root.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0.get_layout_top() as i32);\n\tassert_eq!(85, root_child0.get_layout_width() as i32);\n\tassert_eq!(80, root_child0.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child0.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0_child0_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child0_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child0_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child0_child0.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0_child1.get_layout_left() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0_child1_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child1_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child1_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child1_child0.get_layout_height() as i32);\n\n\troot.calculate_layout(Undefined, Undefined, Direction::RTL);\n\n\tassert_eq!(0, root.get_layout_left() as i32);\n\tassert_eq!(0, root.get_layout_top() as i32);\n\tassert_eq!(500, root.get_layout_width() as i32);\n\tassert_eq!(500, root.get_layout_height() as i32);\n\n\tassert_eq!(415, root_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0.get_layout_top() as i32);\n\tassert_eq!(85, root_child0.get_layout_width() as i32);\n\tassert_eq!(80, root_child0.get_layout_height() as i32);\n\n\tassert_eq!(45, root_child0_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child0.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0_child0_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child0_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child0_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child0_child0.get_layout_height() as i32);\n\n\tassert_eq!(35, root_child0_child1.get_layout_left() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child1.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0_child1_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0_child1_child0.get_layout_top() as i32);\n\tassert_eq!(40, root_child0_child1_child0.get_layout_width() as i32);\n\tassert_eq!(40, root_child0_child1_child0.get_layout_height() as i32);\n}", "item_id": 18, "repo": "mehcode/yoga-rs", "file": "tests/flex_wrap_test.rs", "last_update_at": "2019-04-11T14:07:42+00:00"}
{"hexsha": "a76a0e9010de0f7000b8fb8aad7bc8a5990bf20d", "ext": "rs", "lang": "Rust", "content": "fn get() {\n        let mut buf = new(String::from(\"123\"));\n        assert_eq!(buf.get().unwrap(), '1');\n        assert_eq!(buf.get().unwrap(), '2');\n        assert_eq!(buf.get().unwrap(), '3');\n        assert_eq!(buf.get().is_none(), true);\n    }", "item_id": 3, "repo": "gaswelder/che", "file": "src/buf.rs", "last_update_at": "2019-11-17T04:12:08+00:00"}
{"hexsha": "f5319d4e9ef5c4e40c952921c46d11eeb9384e47", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn namei(path: *const u8) -> *mut Inode {\n    check_it(\"namei (1)\");\n    let mut name = [0u8; DIRSIZ];\n    // cprintf(\"namei: namex start\\n\", &[]);\n    let res = namex(path, 0, name.as_mut_ptr());\n    // cprintf(\"namei:  namex end\\n\", &[]);\n    res\n}", "item_id": 18, "repo": "ogiekako/rx6", "file": "kern/src/fs.rs", "last_update_at": "2019-06-20T09:35:01+00:00"}
{"hexsha": "a8ddd4f503630a268882e3e17ed4c9b7f3befe9e", "ext": "rs", "lang": "Rust", "content": "pub fn init() -> Result<(), SalmiakError> {\n    // Disable UART0\n    unsafe {\n        UART0_CR.write_volatile(0x0);\n    }\n\n    // we want consistent divisor values and\n    // therefore set the clock rate of the UART\n    let res = MailboxPropertyBufferBuilder::new()\n        .set_clock_rate(\n            mailbox::clock::UART,\n            4_000_000, // 4 MHz\n            0,         // skip turbo\n            None,\n        )\n        .submit();\n\n    if !res {\n        return Err(\n            SalmiakErrorKind::InitSerialError(\"Failed to set serial clockrate\".to_owned()).into(),\n        );\n    }\n\n    unsafe {\n        let mut ra = GPFSEL1.read_volatile();\n        ra &= !((7 << 12) | (7 << 15)); //gpio14, gpio15\n        ra |= (4 << 12) | (4 << 15); //alt0\n        GPFSEL1.write_volatile(ra);\n\n        // Disable pull up/down for all GPIO pins and delay for 150 cycles\n        GPPUD.write_volatile(0x0);\n        delay(150);\n\n        // Disable pull up/down for pin 14,15 & delay for 150 cycles.\n        GPPUDCLK0.write_volatile((1 << 14) | (1 << 15));\n        delay(150);\n\n        // Write 0 to GPPUDCLK0 to make it take effect.\n        GPPUDCLK0.write_volatile(0x0);\n\n        // Clear pending interrupts.\n        UART0_ICR.write_volatile(0x7ff);\n\n        // Set integer & fractional part of baud rate.\n        // Divider = UART_CLOCK/(16 * Baud)\n        // Fraction part register = (Fractional part * 64) + 0.5\n        // UART_CLOCK = 3000000; Baud = 115200.\n\n        UART0_IBRD.write_volatile(2);\n        UART0_FBRD.write_volatile(0xb);\n\n        // Enable FIFO & 8 bit data transmissio (1 stop bit, no parity).\n        UART0_LCRH.write_volatile(0b11 << 5);\n\n        // Enable UART0, receive & transfer part of UART.\n        UART0_CR.write_volatile((1) | (1 << 8) | (1 << 9));\n        Ok(())\n    }\n}", "item_id": 0, "repo": "abbec/salmiak", "file": "salmiak/src/serial.rs", "last_update_at": "2019-05-28T20:18:51+00:00"}
{"hexsha": "635995e22d6a3512849e9d3b51640804889b1f65", "ext": "rs", "lang": "Rust", "content": "fn write(fmt: DefaultFormat) -> String {\n        let buf = fmt.buf.buf.clone();\n\n        let record = Record::builder()\n            .args(format_args!(\"log message\"))\n            .level(Level::Info)\n            .file(Some(\"test.rs\"))\n            .line(Some(144))\n            .module_path(Some(\"test::path\"))\n            .build();\n\n        fmt.write(&record).expect(\"failed to write record\");\n\n        let buf = buf.borrow();\n        String::from_utf8(buf.bytes().to_vec()).expect(\"failed to read record\")\n    }", "item_id": 0, "repo": "hcpl/env_logger", "file": "src/fmt/mod.rs", "last_update_at": "2019-04-24T23:46:26+00:00"}
{"hexsha": "889207f29fb47fe1b3a16b4c1b4abbccb6704f1d", "ext": "rs", "lang": "Rust", "content": "fn finish_epoch(\n    storage: &mut Storage,\n    genesis_data: &GenesisData,\n    epoch_writer_state: EpochWriterState,\n    chain_state: &ChainState,\n    is_epoch_with_ebb: bool,\n) -> Result<()> {\n    let epoch_id = epoch_writer_state.epoch_id;\n    let (packhash, index) = pack::packwriter_finalize(&storage.config, epoch_writer_state.writer);\n    let (lookup, tmpfile) = pack::create_index(&storage, &index);\n    tmpfile.render_permanent(&storage.config.get_index_filepath(&packhash))?;\n    storage.add_lookup(packhash, lookup);\n    let epoch_time_elapsed = epoch_writer_state.write_start_time.elapsed().unwrap();\n\n    if epoch_id > 0 {\n        assert!(\n            epoch_exists(&storage.config, epoch_id - 1)?,\n            \"Attempted finish_epoch() with non-existent previous epoch (ID {}, previous' ID {})\",\n            epoch_id,\n            epoch_id - 1\n        );\n    }\n\n    assert_eq!(chain_state.last_date.unwrap().get_epochid(), epoch_id);\n\n    let epoch_flags = EpochFlags {\n        is_ebb: is_epoch_with_ebb,\n    };\n\n    epoch::epoch_create(\n        storage,\n        &packhash,\n        epoch_id,\n        index,\n        Some((chain_state, genesis_data)),\n        &epoch_flags,\n    );\n\n    info!(\n        \"=> pack {} written for epoch {} in {}\",\n        hex::encode(&packhash[..]),\n        epoch_id,\n        duration_print(epoch_time_elapsed)\n    );\n\n    for hash in &epoch_writer_state.blobs_to_delete {\n        debug!(\"removing blob {}\", hash);\n        blob::remove(&storage, &hash.clone().into());\n    }\n\n    let diff = storage\n        .read_block(&types::header_to_blockhash(&chain_state.last_block))?\n        .decode()?\n        .header()\n        .difficulty();\n\n    // Drop this epoch from loose index\n    storage.drop_loose_index_before(diff);\n\n    Ok(())\n}", "item_id": 4, "repo": "Emurgo/rust-cardano", "file": "exe-common/src/sync.rs", "last_update_at": "2019-07-30T11:25:14+00:00"}
{"hexsha": "5c830e32a8a58663d500f834aa864852764f4773", "ext": "rs", "lang": "Rust", "content": "fn convert_duration_to_string() {\n        assert_eq!(duration_to_string(Duration::milliseconds(1002)), \"0:0:1.2\");\n        assert_eq!(\n            duration_to_string(Duration::milliseconds(65125)),\n            \"0:1:5.125\"\n        );\n        assert_eq!(\n            duration_to_string(Duration::milliseconds(6065125)),\n            \"1:41:5.125\"\n        );\n        assert_eq!(duration_to_string(Duration::seconds(128)), \"0:2:8.0\");\n    }", "item_id": 0, "repo": "CBenoit/media-cutter", "file": "src/lib.rs", "last_update_at": "2019-12-06T05:19:23+00:00"}
{"hexsha": "8adbe438799bd65136cc48972950cd5e0682d8cb", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn say_something(some_string: *const u8, some_len: usize) -> sgx_status_t {\n    let person_slice = unsafe { slice::from_raw_parts(some_string, some_len) };\n\n    let the_one: person::Person = person::Person::decode(person_slice).unwrap();\n    println!(\"name: {}, id: 0x{:08X}, email at: {}\",\n        the_one.name,\n        the_one.id,\n        the_one.email);\n    println!(\"{:?}\", the_one);\n\n    let ts = Timestamp { seconds: 0x1234, nanos: 0x5678 };\n    println!(\"well known types ts = {:?}\", ts);\n\n    sgx_status_t::SGX_SUCCESS\n}", "item_id": 0, "repo": "veracruz-project/incubator-teaclave-sgx-sdk", "file": "samplecode/prost-protobuf/enclave/src/lib.rs", "last_update_at": "2019-10-30T10:05:21+00:00"}
{"hexsha": "936467b7824d9d53a9506197ec628a29f8a8b998", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let input_file = match env::args().nth(1) {\n        Some(input_file) => input_file,\n        None => {\n            println!(\"Please supply input file!\");\n            std::process::exit(1);\n        }\n    };\n\n    let orbits: Vec<Orbit> = match FileReader::new().split_lines().read_from_file(input_file) {\n        Ok(input) => input,\n        Err(e) => {\n            println!(\"Error reading input: {}\", e);\n            std::process::exit(1);\n        }\n    };\n\n    let graph = Graph::construct_graph(&orbits);\n    let number_of_orbits = graph.count_orbits();\n    println!(\"Number of orbits: {}\", number_of_orbits);\n\n    let minimal_distance = graph.minimal_distance(\"YOU\", \"SAN\");\n    println!(\"Minimal distance: {}\", minimal_distance - 2);\n}", "item_id": 0, "repo": "df5602/aoc2019", "file": "06-universal-orbit-map/src/main.rs", "last_update_at": "2019-12-03T21:30:12+00:00"}
{"hexsha": "8fe71bc79ab690e4d10c32b6e8d596c010446e03", "ext": "rs", "lang": "Rust", "content": "fn extract_trait_param_type<'a>(\n    sess: &'a ParseSess,\n    trait_ref: &ast::TraitRef,\n) -> PResult<'a, ast::Ty> {\n    assert_eq!(1, trait_ref.path.segments.len());\n    let seg = &trait_ref.path.segments[0];\n    let param = seg\n        .parameters\n        .as_ref()\n        .ok_or_else(|| fatal_error(sess, trait_ref.path.span, \"No type param\"))?;\n    match **param {\n        ast::PathParameters::AngleBracketed(ref p) => {\n            if p.types.len() != 1 {\n                return Err(fatal_error(\n                    sess,\n                    trait_ref.path.span,\n                    \"Expect one type parameter\",\n                ));\n            }\n            let pty: &P<ast::Ty> = &p.types[0];\n            Ok((**pty).clone())\n        }\n        _ => Err(fatal_error(\n            sess,\n            trait_ref.path.span,\n            \"Expect type params in <>\",\n        )),\n    }\n}", "item_id": 4, "repo": "rubdos/rust_swig", "file": "macroslib/src/types_conv_map/parsing.rs", "last_update_at": "2019-04-21T12:35:26+00:00"}
{"hexsha": "18137537ca9c54fa3de54068d587a43481df8875", "ext": "rs", "lang": "Rust", "content": "fn read_line() -> String {\n    let mut return_ = format!(\"\");\n    std::io::stdin().read_line(&mut return_).ok();\n    return_\n}", "item_id": 0, "repo": "andraantariksa/code-exercise-answer", "file": "aizuonlinejudge/0101.rs", "last_update_at": "2019-11-06T15:17:48+00:00"}
{"hexsha": "a8d1fde9c77cd0725b89297c76fc56632d95b453", "ext": "rs", "lang": "Rust", "content": "fn test_apply_without_bias() {\n        let weights: Array2<f64> = array![[0.0, 1.0, 0.0], [1.0, 0.0, 1.0]];\n        let input: Array2<f64> = array![[2.0, 5.0], [7.0, 1.0], [4.0, 3.0]];\n        let expected_output: Array2<f64> =\n            array![[5.0, 2.0, 5.0], [1.0, 7.0, 1.0], [3.0, 4.0, 3.0]];\n        let layer: DenseLayer<NdArrayBackend<_>> =\n            DenseLayer::new(String::from(\"layer_1\"), weights, None);\n        let output = layer.apply(input.try_into().unwrap());\n        assert!(output.is_ok());\n        let output: Array2<f64> = output.unwrap().try_into().unwrap();\n        assert_eq!(output, expected_output);\n    }", "item_id": 2, "repo": "andrei-papou/horn", "file": "rust/src/backends/ndarray/tests.rs", "last_update_at": "2019-10-23T12:54:37+00:00"}
{"hexsha": "b3de16a792060052320e753a449a25b234163faa", "ext": "rs", "lang": "Rust", "content": "fn test_is_shifted_mask() {\n        assert_eq!(true, is_shifted_mask(8));\n        assert_eq!(true, is_shifted_mask(6));\n        assert_eq!(true, is_shifted_mask(7));\n        assert_eq!(true, is_shifted_mask(3));\n        assert_eq!(true, is_shifted_mask(1));\n        assert_eq!(true, is_shifted_mask(!0));\n\n        assert_eq!(false, is_shifted_mask(0));\n        assert_eq!(false, is_shifted_mask(9));\n        assert_eq!(false, is_shifted_mask(1 << 63 | 1));\n    }", "item_id": 83, "repo": "rodrigo-bruno/dora", "file": "src/cpu/arm64/asm.rs", "last_update_at": "2019-04-21T12:35:18+00:00"}
{"hexsha": "be1d9f4b464389a8dd70f58b26b8dd892ece02e2", "ext": "rs", "lang": "Rust", "content": "fn set_command() {\n    assert_setting!(\"option1\", \"42\", Set(\"option1\".to_string(), Int(42)));\n    assert_setting!(\"option1\", \"12.345\", Set(\"option1\".to_string(), Float(12.345)));\n    assert_setting!(\"option1\", \"false\", Set(\"option1\".to_string(), Bool(false)));\n    assert_setting!(\"option1\", \"true\", Set(\"option1\".to_string(), Bool(true)));\n    assert_setting!(\"option1\", \"value\", Set(\"option1\".to_string(), Str(\"value\".to_string())));\n    assert_setting!(\"option1\", \"value with spaces\", Set(\"option1\".to_string(), Str(\"value with spaces\".to_string())));\n    assert_eq!(parse_string(\"set option1 = 42\\nset option2 = 12.345\"), vec![Set(\"option1\".to_string(), Int(42)), Set(\"option2\".to_string(), Float(12.345))]);\n    assert_eq!(parse_string(\"set option1 = 42\\nset option2 = 12.345\\n\"), vec![Set(\"option1\".to_string(), Int(42)), Set(\"option2\".to_string(), Float(12.345))]);\n    assert_eq!(parse_string(\"set option1 = 42\\n\\nset option2 = 12.345\\n\"), vec![Set(\"option1\".to_string(), Int(42)), Set(\"option2\".to_string(), Float(12.345))]);\n    assert_eq!(parse_string(\"  set    option1    =    42    \"), vec![Set(\"option1\".to_string(), Int(42))]);\n}", "item_id": 7, "repo": "antoyo/mg-settings", "file": "tests/lib.rs", "last_update_at": "2019-02-19T14:30:14+00:00"}
{"hexsha": "99567ce850ec5f85c9892be34b275a1bd667c349", "ext": "rs", "lang": "Rust", "content": "fn test_inverse() {\n        let perm1 = Permutation::new(0..9).unwrap();\n        let mut perm2 = perm1.clone();\n        perm2.invert();\n        assert_eq!(perm1, perm2);\n\n        let mut perm1 = Permutation::new(vec![3, 0, 1, 2, 4]).unwrap();\n        let mut perm2 = perm1.clone();\n        perm2.invert();\n        perm1.compose_with(&perm2);\n        assert!(perm1.is_identity());\n    }", "item_id": 1, "repo": "k7f/aces", "file": "src/symmetry.rs", "last_update_at": "2019-06-27T21:56:02+00:00"}
{"hexsha": "6b663401101c386b1b9edf492dc35440f49edf40", "ext": "rs", "lang": "Rust", "content": "fn parse_rpc_attr(attr: &Attribute) -> Vec<(AttrKey, AttrValue)> {\n    let meta = match attr.parse_meta() {\n        Ok(m) => m,\n        Err(_) => return Vec::new(),\n    };\n\n    if &format!(\"{}\", meta.name()) != \"rpc\" {\n        return Vec::new();\n    }\n\n    match meta {\n        Meta::List(list) => list\n            .nested\n            .iter()\n            .flat_map(|met| match met {\n                NestedMeta::Meta(m) => parse_rpc_attr_meta(m),\n                _ => Vec::new(),\n            })\n            .collect(),\n        _ => Vec::new(),\n    }\n}", "item_id": 0, "repo": "passcod/rpc-impl-macro", "file": "src/lib.rs", "last_update_at": "2019-02-25T06:17:45+00:00"}
{"hexsha": "4a1d151e963f3e9b73fe97636c1f3ce2c5443df7", "ext": "rs", "lang": "Rust", "content": "fn it_correctly_detects_no_intersection_for_parallel_lines() {\n            let l1 = WireSegment::new(Point::new(0, 0), Point::new(1, 1));\n            let l2 = WireSegment::new(Point::new(0, 1), Point::new(1, 2));\n            assert_eq!(None, l1.intersection(&l2))\n        }", "item_id": 11, "repo": "jstuczyn/AoC19", "file": "day3/src/main.rs", "last_update_at": "2019-12-02T20:03:22+00:00"}
{"hexsha": "02d33f5dbee2c24643a69a08e136740bbaa188d6", "ext": "rs", "lang": "Rust", "content": "fn fails_to_complete_initialization_if_not_waiting_for_it() {\n\t\tlet ml = MessageLoop::new(2).init(0).unwrap();\n\t\tml.0.take_and_process_message();\n\t\tassert_eq!(ml.session_at(0).on_complete_initialization(ml.0.node(1), &message::CompleteInitialization {\n\t\t\tsession: Default::default(),\n\t\t\tsession_nonce: 0,\n\t\t\tderived_point: math::generate_random_point().unwrap().into(),\n\t\t}), Err(Error::InvalidStateForRequest));\n\t}", "item_id": 6, "repo": "altice-io/Daqiao", "file": "bridge/parity-ethereum/secret-store/src/key_server_cluster/client_sessions/generation_session.rs", "last_update_at": "2019-09-11T12:07:35+00:00"}
{"hexsha": "55fd51ac5eb0db8c567c311373a2941b8af58c04", "ext": "rs", "lang": "Rust", "content": "fn test_cross_at_point() {\r\n    let ind1 = Ind(vec!(0xF, 0xF, 0xF, 0xF, 0xF));\r\n    let ind2 = Ind(vec!(0x0, 0x0, 0x0, 0x0, 0x0));\r\n    let mut pair = [ind1, ind2];\r\n\r\n    cross_at_point(&mut pair, 4, 10);\r\n    assert!(pair[0] == Ind(vec!(0, 0, 3, 0xF, 0xF)));\r\n    assert!(pair[1] == Ind(vec!(0xF, 0xF, 0xC, 0x0, 0x0)));\r\n}", "item_id": 2, "repo": "nsmryan/rgep", "file": "src/crossover.rs", "last_update_at": "2019-04-12T16:06:04+00:00"}
{"hexsha": "a68a9b4e66ec30f339f46729943cc9414da5a1f2", "ext": "rs", "lang": "Rust", "content": "fn parse_instructions(input: &str) -> (Vec<Step>, BTreeMap<Step, Vec<Step>>) {\n    let matcher = Regex::new(\"Step (.) must be finished before step (.) can begin.\").unwrap();\n    let mut instruction_map = BTreeMap::new();\n\n    matcher.captures_iter(input).for_each(|capture| {\n        let prerequisite = capture[1].chars().next().unwrap();\n        let step = capture[2].chars().next().unwrap();\n\n        let entry = instruction_map.entry(step).or_insert_with(Vec::new);\n\n        entry.push(prerequisite);\n\n        instruction_map.entry(prerequisite).or_insert_with(Vec::new);\n    });\n\n    let all_steps = instruction_map.keys().cloned().collect::<Vec<char>>();\n\n    (all_steps, instruction_map)\n}", "item_id": 0, "repo": "mEEksIsu/rust-aoc-2018", "file": "src/days/day7.rs", "last_update_at": "2019-05-23T15:47:24+00:00"}
{"hexsha": "eaa111470141c108d7893ca634be26134ec228b4", "ext": "rs", "lang": "Rust", "content": "fn bind_client<C: ClientState, T: AsyncRead + AsyncWrite>(\n    io: T,\n) -> (\n    impl Sink<SinkItem = C::Send, SinkError = ()>,\n    impl Stream<Item = C::Receive, Error = Error>,\n) {\n    let (raw_sender, raw_receiver) = bind_transport(io);\n    let sender = raw_sender\n        .with(|msg| serialize_message(&msg))\n        .sink_map_err(|_| ());\n    let receiver = raw_receiver.and_then(parse_message::<C::Receive>);\n    (sender, receiver)\n}", "item_id": 0, "repo": "kphelps/akio", "file": "akio-net/src/protocol.rs", "last_update_at": "2019-01-06T23:05:12+00:00"}
{"hexsha": "e2f89e943d304541c8ccd8a980ecf9d1ce9c654c", "ext": "rs", "lang": "Rust", "content": "fn update_velocities_1d(moons: &mut Vec<&mut Moon1D>) {\n    let mut moons_clone: Vec<Moon1D> = vec![];\n\n    for moon in moons.iter() {\n        moons_clone.push(**moon.clone());\n    }\n\n    for moon_update in moons.iter_mut() {\n        for moon in moons_clone.iter() {\n            moon_update.update_velocity(*moon);\n        }\n    }\n}", "item_id": 4, "repo": "gentoid/aoc-2019-rust", "file": "src/aoc_12.rs", "last_update_at": "2019-12-06T13:12:12+00:00"}
{"hexsha": "e9709670122c32fae206b2a80ebfa4321dfcdf7b", "ext": "rs", "lang": "Rust", "content": "pub fn render_chars_entity_references_to_chars(\n    text: &Vec<char>,\n    entities: &Vec<&DecodedEntity>,\n) -> Vec<char> {\n    let mut my_entities: Vec<&DecodedEntity> = Vec::with_capacity(entities.len());\n    for e in entities {\n        my_entities.push(e);\n    }\n    my_entities.sort_unstable();\n\n    let mut sb: Vec<char> = Vec::with_capacity(text.len() * 2);\n    let mut pos = 0 as usize;\n    my_entities.iter().for_each(|entity| {\n        sb.extend_from_slice(&text[pos..entity.start]);\n        sb.extend_from_slice(&entity.html);\n        pos = entity.end;\n    });\n    sb.extend_from_slice(&text[pos..text.len()]);\n    sb\n}", "item_id": 4, "repo": "spullara/interviewcode", "file": "rust/unicode_test/src/lib.rs", "last_update_at": "2019-11-13T17:40:28+00:00"}
{"hexsha": "debb9911930aebf69268ceb52a490f921caa45cf", "ext": "rs", "lang": "Rust", "content": "fn ansi_rgb_colors() {\n        use super::ColorExt;\n        assert_eq!(Color::Rgb(0x12, 0x89, 0xef).to_rgb(), (0x12, 0x89, 0xef));\n        assert_eq!(Color::Rgb(0xff, 0xff, 0xff).to_rgb(), (0xff, 0xff, 0xff));\n        assert_eq!(Color::Rgb(0, 0, 0).to_rgb(), (0, 0, 0));\n    }", "item_id": 1, "repo": "rhysd/termcolor2rgb", "file": "src/lib.rs", "last_update_at": "2019-01-12T12:37:16+00:00"}
{"hexsha": "a4d9a79eb9bbafb3fe8f46e3f83c8a2712f51b1b", "ext": "rs", "lang": "Rust", "content": "fn test_game_id() {\n        assert_parsed!(\n            Event::GameId {\n                id: \"CHN201604110\".into()\n            },\n            game_id(\"id,CHN201604110\")\n        );\n        assert!(game_id(\"asdlfk,3,5\").is_err());\n        assert!(game_id(\"id,3455\").is_err());\n    }", "item_id": 33, "repo": "eugene-bulkin/retrosheet-rs", "file": "src/parsers.rs", "last_update_at": "2019-11-27T04:32:55+00:00"}
{"hexsha": "ff59c7ea7617a563fc51b5b5692cc80137be391a", "ext": "rs", "lang": "Rust", "content": "fn test_function() {\n        let s = to_chars(\"function\");\n        let cur = &mut 0;\n        expect_next_token(&s, cur, Token::Function);\n    }", "item_id": 89, "repo": "jalextowle/solfix", "file": "src/lex_4_25.rs", "last_update_at": "2019-06-12T10:41:50+00:00"}
{"hexsha": "e62d4bad820b2b50b02221c0ab525295304277f4", "ext": "rs", "lang": "Rust", "content": "fn test_message() {\n    test_text_format_str_descriptor(\"test_message_singular {}\", TestTypes::descriptor_static());\n\n    test_text_format_str_descriptor(\n        \"test_message_singular { value: 10 }\",\n        TestTypes::descriptor_static(),\n    );\n\n    test_text_format_str_descriptor(\n        \"test_message_repeated { value: 10 } test_message_repeated { value: 20 }\",\n        TestTypes::descriptor_static(),\n    );\n}", "item_id": 7, "repo": "comiclee/rust-protobuf", "file": "protobuf-test/src/common/v2/test_fmt_text_format.rs", "last_update_at": "2019-05-20T14:11:28+00:00"}
{"hexsha": "c7b80c42c1baa657e4f99df074114b163190f538", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // Make sure codegen can emit all the intrinsics correctly\n    ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, Acquire, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, Release, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, AcqRel, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed).ok();\n    ATOMIC.compare_exchange(0, 1, Acquire, Acquire).ok();\n    ATOMIC.compare_exchange(0, 1, AcqRel, Acquire).ok();\n    ATOMIC.compare_exchange(0, 1, SeqCst, Acquire).ok();\n    ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Acquire, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed).ok();\n    ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire).ok();\n    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire).ok();\n    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire).ok();\n    ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();\n}", "item_id": 0, "repo": "martell/rust", "file": "src/test/run-pass/atomic-compare_exchange.rs", "last_update_at": "2019-04-06T13:56:42+00:00"}
{"hexsha": "675110c1532e4d3c318357e731a5ac978e792779", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    server::new(|| App::new().resource(\"/\", |r| r.f(|_| HttpResponse::Ok())))\n        .keep_alive(75); // <- Set keep-alive to 75 seconds\n\n    server::new(|| App::new().resource(\"/\", |r| r.f(|_| HttpResponse::Ok())))\n        .keep_alive(server::KeepAlive::Tcp(75)); // <- Use `SO_KEEPALIVE` socket option.\n\n    server::new(|| App::new().resource(\"/\", |r| r.f(|_| HttpResponse::Ok())))\n        .keep_alive(None); // <- Disable keep-alive\n}", "item_id": 0, "repo": "awulkan/actix-website", "file": "examples/server/src/ka.rs", "last_update_at": "2019-07-16T03:34:51+00:00"}
{"hexsha": "12e8f9733fe2a0d5c3b46246047def3f81a8f7cd", "ext": "rs", "lang": "Rust", "content": "fn irr(\n        leg_:Leg,\n        npv_:Real,\n        dayCounter_:Box<DayCounter>,\n        compounding_:Compounding,\n        frequency_:Frequency,\n        includeSettlementDateFlows_:bool,\n        settlementDate_:LocalDate, \n        npvDate_:LocalDate,\n        accuracy:Real,\n        maxIterations:usize,\n        guess:Real)->Real {\n        let mut solver = Solver1D::default();\n        solver.setMaxEvaluations(maxIterations);\n        return irr_(solver, leg_, npv_, dayCounter_,\n                    compounding_, frequency_,\n                    includeSettlementDateFlows_,\n                    settlementDate_, npvDate_,\n                    accuracy, guess);\n}", "item_id": 9, "repo": "teddyzhu/quantrest", "file": "src/cashflow.rs", "last_update_at": "2019-07-15T06:27:47+00:00"}
{"hexsha": "e29a32837ca460e117c893629bd7c7ad0fa00d7a", "ext": "rs", "lang": "Rust", "content": "fn test_body_can_move_out_of_passable_body(\n        moving_body: PhysicalBody,\n        expected_location_after_moving: Point,\n    ) {\n        let mut world = NphysicsWorld::with_timestep(DEFAULT_TIMESTEP);\n\n        let moving_body_handle = world.add_body(moving_body.clone());\n\n        let passable_body = passable_body();\n        let passable_body_handle = world.add_body(passable_body.clone());\n\n        let force = Force {\n            torque: Torque::default(),\n            linear: Vector { x: 40.0, y: 40.0 },\n        };\n\n        world.apply_force(moving_body_handle, force);\n        world.step();\n\n        assert_eq!(\n            expected_location_after_moving,\n            world.body(moving_body_handle).unwrap().location\n        );\n\n        assert_eq!(\n            passable_body.location,\n            world.body(passable_body_handle).unwrap().location\n        );\n    }", "item_id": 26, "repo": "myelin-ai/engine", "file": "src/simulation/simulation_impl/world/nphysics_world.rs", "last_update_at": "2019-12-14T11:25:28+00:00"}
{"hexsha": "38db1695cf2cee41c36549f86781d18a9cf63ec0", "ext": "rs", "lang": "Rust", "content": "fn test_with_fields() {\n    let t = WithFieldsTemplate {\n        names: (\n            Name {\n                first: \"foo\",\n                last: \"bar\",\n            },\n            Name {\n                first: \"fOO\",\n                last: \"bAR\",\n            },\n        ),\n    }; // instantiate your struct\n    assert_eq!(\"Hello, foo bar and fOO bAR!\", t.call().unwrap()); // then call it.\n}", "item_id": 7, "repo": "dgriffen/wearte", "file": "testing/tests/expr.rs", "last_update_at": "2019-07-28T23:01:15+00:00"}
{"hexsha": "7fe5a54a817d02d76a3d99f537ed47c6580e866d", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn wlr_log_init(mut verbosity: wlr_log_importance,\n                                      mut callback: wlr_log_func_t) {\n    if (verbosity as libc::c_uint) <\n           WLR_LOG_IMPORTANCE_LAST as libc::c_int as libc::c_uint {\n        log_importance = verbosity\n    }\n    if callback.is_some() { log_callback = callback }\n    wl_log_set_handler_server(Some(log_wl as\n                                       unsafe extern \"C\" fn(_:\n                                                                *const libc::c_char,\n                                                            _:\n                                                                ::std::ffi::VaList)\n                                           -> ()));\n}", "item_id": 2, "repo": "RoastVeg/wlrusts", "file": "src/util/log.rs", "last_update_at": "2019-12-10T16:29:26+00:00"}
{"hexsha": "e62d4bad820b2b50b02221c0ab525295304277f4", "ext": "rs", "lang": "Rust", "content": "fn test_parse_float() {\n    test_text_format_str_descriptor(\"float_singular: 98.5\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"float_singular: -99.5\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"float_singular: -99\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"double_singular: 98.5\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"double_singular: -99.5\", TestTypes::descriptor_static());\n    test_text_format_str_descriptor(\"double_singular: 99\", TestTypes::descriptor_static());\n}", "item_id": 4, "repo": "comiclee/rust-protobuf", "file": "protobuf-test/src/common/v2/test_fmt_text_format.rs", "last_update_at": "2019-05-20T14:11:28+00:00"}
{"hexsha": "9f41e3f593abd4d21eb15c070a0fcbb464e65ab8", "ext": "rs", "lang": "Rust", "content": "pub fn tests() {\n    use crate::input::{test_part_one, test_part_two};\n\n    let example_part_one = \"class: 1-3 or 5-7\nrow: 6-11 or 33-44\nseat: 13-40 or 45-50\n\nyour ticket:\n7,1,14\n\nnearby tickets:\n7,3,47\n40,4,50\n55,2,20\n38,6,12\";\n    test_part_one!(example_part_one => 71);\n\n    let example_part_two = \"class: 0-1 or 4-19\nrow: 0-5 or 8-19\nseat: 0-13 or 16-19\n\nyour ticket:\n11,12,13\n\nnearby tickets:\n3,9,18\n15,1,5\n5,14,9\";\n    test_part_two!(example_part_two => 1);\n\n    let real_input = include_str!(\"day16_input.txt\");\n    test_part_one!(real_input => 29019);\n    test_part_two!(real_input => 517_827_547_723);\n}", "item_id": 1, "repo": "fornwall/advent-of-code-2019-rs", "file": "crates/core/src/year2020/day16.rs", "last_update_at": "2019-12-10T00:08:49+00:00"}
{"hexsha": "42c6c97511da80cf4c4213e9d4274610ecc943ba", "ext": "rs", "lang": "Rust", "content": "fn must_round_trip_field_stop() {\n        let (mut i_prot, mut o_prot) = test_objects(true);\n\n        assert!(o_prot.write_field_stop().is_ok());\n\n        copy_write_buffer_to_read_buffer!(o_prot);\n\n        let expected_ident = TFieldIdentifier {\n            name: None,\n            field_type: TType::Stop,\n            id: Some(0),\n        }; // we get id 0\n\n        let received_ident = assert_success!(i_prot.read_field_begin());\n        assert_eq!(&received_ident, &expected_ident);\n    }", "item_id": 9, "repo": "ashetkar/snappy-thrift", "file": "lib/rs/src/protocol/binary.rs", "last_update_at": "2019-05-22T13:18:17+00:00"}
{"hexsha": "886a46a37b7cc405bae5161208a7c872eb3648c9", "ext": "rs", "lang": "Rust", "content": "pub fn tests() {\n    use crate::input::test_part_one;\n\n    let example = \"5764801\\n17807724\";\n    test_part_one!(example => 14_897_079);\n    let real_input = include_str!(\"day25_input.txt\");\n    test_part_one!(real_input => 18_862_163);\n}", "item_id": 2, "repo": "fornwall/advent-of-code-2019-rs", "file": "crates/core/src/year2020/day25.rs", "last_update_at": "2019-12-10T00:08:49+00:00"}
{"hexsha": "ad25688b53172401da5ffc97264b14502ce12e6e", "ext": "rs", "lang": "Rust", "content": "fn pregenerate_data<H: Hasher>(degree: usize) -> Pregenerated<H> {\n    let mut rng = thread_rng();\n    let data: Vec<u8> = (0..(degree + 1))\n        .flat_map(|_| fr_into_bytes::<Bls12>(&rng.gen()))\n        .collect();\n    let parents: Vec<usize> = (0..degree).map(|pos| pos).collect();\n    let replica_id: H::Domain = rng.gen();\n    Pregenerated {\n        data,\n        parents,\n        replica_id,\n    }\n}", "item_id": 0, "repo": "idotial/rust-fil-proofs", "file": "storage-proofs/benches/encode.rs", "last_update_at": "2019-07-18T01:28:09+00:00"}
{"hexsha": "b3e8a5a2959ca55a77af4546886f9d50848340df", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut display = DisplayBuilder::new().size(304, 128).scale(2).build();\n\n    display.draw(\n        Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32).stroke(Some(1u8.into())),\n    );\n\n    display.draw(\n        Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32)\n            .translate(icoord!(16, 16))\n            .stroke(Some(0u8.into()))\n            .fill(Some(1u8.into())),\n    );\n\n    display.draw(\n        Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32)\n            .translate(icoord!(CIRCLE_SIZE, CIRCLE_SIZE))\n            .stroke(Some(0u8.into()))\n            .fill(Some(0u8.into())),\n    );\n\n    display.draw(\n        Rectangle::new(icoord!(0, 0), icoord!(64, 64))\n            .translate(icoord!(96, 0))\n            .stroke(Some(1u8.into())),\n    );\n\n    display.draw(\n        &Rectangle::new(icoord!(0, 0), icoord!(64, 64))\n            .translate(icoord!(96 + 16, 16))\n            .stroke(Some(0u8.into()))\n            .fill(Some(1u8.into())),\n    );\n\n    display.draw(\n        Rectangle::new(icoord!(0, 0), icoord!(64, 64))\n            .translate(icoord!(96 + 32, 32))\n            .stroke(Some(0u8.into()))\n            .fill(Some(0u8.into())),\n    );\n\n    display.draw(\n        Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))\n            .translate(icoord!(96 * 2, 0))\n            .stroke(Some(1u8.into())),\n    );\n\n    display.draw(\n        Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))\n            .translate(icoord!(96 * 2 + 16, 16))\n            .stroke(Some(0u8.into()))\n            .fill(Some(1u8.into())),\n    );\n\n    display.draw(\n        Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))\n            .translate(icoord!(96 * 2 + 32, 32))\n            .stroke(Some(0u8.into()))\n            .fill(Some(0u8.into())),\n    );\n\n    loop {\n        let end = display.run_once();\n\n        if end {\n            break;\n        }\n\n        thread::sleep(Duration::from_millis(200));\n    }\n}", "item_id": 0, "repo": "mmou/embedded-graphics", "file": "simulator/examples/fill.rs", "last_update_at": "2019-07-16T02:31:01+00:00"}
{"hexsha": "866493b9c7622fe5e4d49ba91613c03dea0bbbf7", "ext": "rs", "lang": "Rust", "content": "fn read_from_source<T: BufRead>(reader: &mut T) -> Result<Value, JpErr> {\n    let mut contents = String::new();\n    let size = reader.read_to_string(&mut contents)\n        .map_err(|_| JpErr::FileReadError)?;\n\n    if size == 0 {\n        return Err(JpErr::EmptyFileError);\n    }\n\n    let json = from_str(&contents)\n        .map_err(|_| JpErr::JsonParseError)?;\n\n    Ok(json)\n}", "item_id": 0, "repo": "therealklanni/jp-cli", "file": "src/main.rs", "last_update_at": "2019-02-10T01:14:37+00:00"}
{"hexsha": "7e0adff604bbf844ea75c468311965832ab8a9aa", "ext": "rs", "lang": "Rust", "content": "pub fn parse(args: &ArgMatches, config: SetupConfig) -> Result<DeleteNode, Error> {\n    let tendermint_key = parse_tendermint_key(args)?;\n    let eth = parse_ethereum_args(args, config)?;\n\n    Ok(DeleteNode {\n        tendermint_key,\n        eth,\n    })\n}", "item_id": 0, "repo": "lcoenen/fluence", "file": "cli/src/delete_node.rs", "last_update_at": "2019-05-30T14:42:54+00:00"}
{"hexsha": "a96f2f01ce9ebf99caf325adfa022f5e02585d21", "ext": "rs", "lang": "Rust", "content": "fn bytes_and_ints() {\n        let mut c = Composer::new(ComposeMode::Unlimited, false);\n        c.compose_bytes(b\"foo\").unwrap();\n        c.compose_u8(0x07).unwrap();\n        c.compose_u16(0x1234).unwrap();\n        c.compose_u32(0xdeadbeef).unwrap();\n        assert_eq!(c.finish(),\n                   b\"foo\\x07\\x12\\x34\\xde\\xad\\xbe\\xef\");\n    }", "item_id": 0, "repo": "cloudshipping/domain-rs", "file": "src/bits/compose.rs", "last_update_at": "2019-07-23T15:41:21+00:00"}
{"hexsha": "3b7a00a2c73c6dd3cba02828e4bdec4b19428f32", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // this signals overflow when checking is on\n    let x = 1_i8 << 17;\n\n    // ... but when checking is off, the fallback will truncate the\n    // input to its lower three bits (= 1). Note that this is *not*\n    // the behavior of the x86 processor for 8- and 16-bit types,\n    // but it is necessary to avoid undefined behavior from LLVM.\n    //\n    // We check that here, by ensuring the result has only been\n    // shifted by one place; if overflow checking is turned off, then\n    // this assertion will pass (and the compiletest driver will\n    // report that the test did not produce the error expected above).\n    assert_eq!(x, 2_i8);\n}", "item_id": 0, "repo": "canaltinova/rust", "file": "src/test/run-fail/overflowing-lsh-4.rs", "last_update_at": "2019-09-24T02:31:48+00:00"}
{"hexsha": "85cc2e349629b4073bf751e1399639ab4021dd52", "ext": "rs", "lang": "Rust", "content": "fn write_export(content: &mut String, func: &parser::FuncDecl, package_info: &cargo::Info) {\n    let func_body = match marshal::has_marshaled_ret_value(func) {\n        true => export_marshaled_return(func, package_info),\n        false => format!(\"\\t\\t{}\\n\\t\\t{}\\n\\n\", get_import_decl(func, package_info), get_func_signature(func))\n    };\n\n    //Boolean values are 1 byte size, so append this in order to marshal it correctly\n    match func.ret {\n        parser::ReturnType::Type(parser::Type::Boolean) => content.push_str(\"\\t\\t[return: MarshalAs(UnmanagedType.I1)]\\n\"),\n        _=> ()\n    }\n\n    content.push_str(func_body.as_ref());\n}", "item_id": 2, "repo": "vvanders/ffigen", "file": "src/gen/csharp.rs", "last_update_at": "2019-08-06T16:37:09+00:00"}
{"hexsha": "cd63239b14314163ea6512af3f272a927623a2b7", "ext": "rs", "lang": "Rust", "content": "fn test_string() {\n    assert_eq!(parse_sexpr(\"\\\"\\\"\"), Ok(Elem::String(\"\".to_string())));\n    assert_eq!(parse_sexpr(\"\\\"foo\\\"\"), Ok(Elem::String(\"foo\".to_string())));\n    assert_eq!(parse_sexpr(\"\\\"A quote: \\\\\\\"\\\"\"),\n      Ok(Elem::String(\"A quote: \\\"\".to_string())));\n    assert_eq!(parse_sexpr(\"\\\"C:\\\\\\\\Windows\\\"\"),\n      Ok(Elem::String(\"C:\\\\Windows\".to_string())));\n    assert_eq!(parse_sexpr(\"\\\"\\\\r\\\\n\\\\t\\\\e\\\"\"), \n      Ok(Elem::String(\"\\r\\n\\t\\u{1b}\".to_string())));\n  }", "item_id": 8, "repo": "honzasp/spiral", "file": "src/sexpr/parse.rs", "last_update_at": "2019-09-19T04:40:59+00:00"}
{"hexsha": "2f0568a61430a64d4bc63607fb7e8905f9750296", "ext": "rs", "lang": "Rust", "content": "pub fn run(args: &ArgMatches) -> Result<(), Box<dyn Error>> {\n    // Load config\n    let config = Config::load()?;\n    let user_name = config.user.name;\n    let user_email = match config.user.email {\n        Some(email) => email,\n        None => String::new(),\n    };\n\n    // Return an error in case of an empty configuration\n    match &user_name {\n        Some(name) if name != &String::new() => (),\n        _ => return Err(Box::new(ConfigError::MissingAuthor(user_email))),\n    }\n\n    // Create tree object\n    let repo_path = utils::find_repo()?;\n    let index = Index::load(&repo_path);\n    let tree = Tree::from(&index);\n\n    // Save tree\n    tree.save(&repo_path);\n\n    // Get head commit (parent)\n    let mut parent = vec![];\n    if let Some(commit) = refs::get_head(&repo_path) {\n        parent.push(commit);\n    }\n\n    // Nothing to commit\n    if (parent.is_empty() && tree.entries.is_empty())\n        || (!parent.is_empty() && tree.hash() == parent[0].hash())\n    {\n        return Err(Box::new(NothingToCommit {}));\n    }\n\n    // Create commit object\n    let message = String::from(args.value_of(\"msg\").unwrap());\n    let commit = Commit::create(&tree, parent, user_name.unwrap(), user_email, message);\n\n    // Save commit object\n    commit.save(&repo_path);\n\n    // Update HEAD\n    refs::update(\n        &repo_path,\n        &String::from(\"HEAD\"),\n        &commit.hash().to_string(),\n        true,\n    )\n    .expect(\"fatal: error while updating HEAD ref\");\n\n    Ok(())\n}", "item_id": 0, "repo": "flomonster/my-git", "file": "src/cmd/commit.rs", "last_update_at": "2019-08-22T18:48:36+00:00"}
{"hexsha": "a0c331818451a7bca9576b530cbe6507141ebff4", "ext": "rs", "lang": "Rust", "content": "async fn test_repo() {\n    let env = TestEnv::new();\n    env.add_repository(\n        RepositoryConfigBuilder::new(RepoUrl::new(\"example.com\".to_string()).expect(\"valid url\"))\n            .build(),\n    );\n\n    let output = env.run_pkgctl(vec![\"repo\"]).await;\n\n    assert_stdout(&output, \"fuchsia-pkg://example.com\\n\");\n    env.assert_only_repository_manager_called_with(vec![CapturedRepositoryManagerRequest::List]);\n}", "item_id": 0, "repo": "OpenTrustGroup/fuchsia", "file": "garnet/tests/pkgctl/src/lib.rs", "last_update_at": "2019-04-21T18:02:26+00:00"}
{"hexsha": "a508c2f05e13c70043b704481f43934a1170337d", "ext": "rs", "lang": "Rust", "content": "fn gcd(a: i64, b: i64) -> i64 {\n    if a < b {\n        return gcd(b, a);\n    }\n    if b == 0 {\n        return a;\n    }\n    return gcd(a - b, b);\n}", "item_id": 0, "repo": "pankdm/adventofcode-2019", "file": "src/bin/day12.rs", "last_update_at": "2019-12-13T02:21:50+00:00"}
{"hexsha": "f1d785e6ae0e8d707e6d028b013b1a892468d352", "ext": "rs", "lang": "Rust", "content": "fn test_writer_bookmark_position_zero_two() {\n    SETUP_WRITER!(\n        \"=== hello\n=== world\",\n        reader,\n        writer\n    );\n\n    assert_eq!(writer.index, 0);\n\n    assert_eq!(writer.symbols[\"hello\"], 0);\n    assert_eq!(writer.symbols[\"world\"], 0);\n}", "item_id": 12, "repo": "Pomettini/visual-novel-text-baker", "file": "tests/writer_tests.rs", "last_update_at": "2019-09-29T16:27:31+00:00"}
{"hexsha": "259330ac289cd54ba2486b224d81e30bf7572268", "ext": "rs", "lang": "Rust", "content": "fn rename() -> Result<()> {\n        let mut fs = MemoryFileSystem::default();\n        fs.write(\"/a/b/hello.txt\", \"blue\")?;\n        assert!(fs.exists(\"/a/b/hello.txt\"));\n\n        fs.rename(\"/a/b/hello.txt\", \"/a/b2/hello.txt\")?;\n        assert!(!fs.exists(\"/a/b/hello.txt\"));\n        assert!(fs.exists(\"/a/b2/hello.txt\"));\n\n        fs.rename(\"/a/b2\", \"/a/b3\")?;\n        assert!(!fs.exists(\"/a/b/hello.txt\"));\n        assert!(!fs.exists(\"/a/b2/hello.txt\"));\n        assert!(fs.exists(\"/a/b3/hello.txt\"));\n\n        Ok(())\n    }", "item_id": 1, "repo": "hansl/refactory", "file": "src/virtualfs/src/fs/memory.rs", "last_update_at": "2019-12-31T22:14:50+00:00"}
{"hexsha": "418f9db693d9749aefa93f03516fa7a93d9aed51", "ext": "rs", "lang": "Rust", "content": "pub fn derive(item: syn::DeriveInput) -> Result<proc_macro2::TokenStream, Diagnostic> {\n    let model = Model::from_item(&item)?;\n    let tokens = MetaItem::all_with_name(&item.attrs, \"belongs_to\")\n        .into_iter()\n        .filter_map(\n            |attr| match derive_belongs_to(&model, &item.generics, attr) {\n                Ok(t) => Some(t),\n                Err(e) => {\n                    e.emit();\n                    None\n                }\n            },\n        );\n\n    Ok(wrap_in_dummy_mod(\n        model.dummy_mod_name(\"associations\"),\n        quote!(#(#tokens)*),\n    ))\n}", "item_id": 0, "repo": "marcelbuesing/diesel", "file": "diesel_derives/src/associations.rs", "last_update_at": "2019-04-29T12:41:50+00:00"}
{"hexsha": "c0b306050718d996e99faa856f777674f1e0989c", "ext": "rs", "lang": "Rust", "content": "fn is_processed_by_this_key_server_in_set_of_3() {\n\t\t// servers set is ordered && server range depends on index of this server\n\t\tlet servers_set = MapKeyServerSet::new(false, vec![\n\t\t\t// secret: 0000000000000000000000000000000000000000000000000000000000000001\n\t\t\t(\"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\".parse().unwrap(),\n\t\t\t\t\"127.0.0.1:8080\".parse().unwrap()),\n\t\t\t// secret: 0000000000000000000000000000000000000000000000000000000000000002\n\t\t\t(\"c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee51ae168fea63dc339a3c58419466ceaeef7f632653266d0e1236431a950cfe52a\".parse().unwrap(),\n\t\t\t\t\"127.0.0.1:8080\".parse().unwrap()),\n\t\t\t// secret: 0000000000000000000000000000000000000000000000000000000000000003\n\t\t\t(\"f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672\".parse().unwrap(),\n\t\t\t\t\"127.0.0.1:8080\".parse().unwrap()),\n\t\t].into_iter().collect());\n\n\t\t// 1st server: process hashes [0x0; 0x555...555]\n\t\tlet key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000001\".parse().unwrap()).unwrap());\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"0000000000000000000000000000000000000000000000000000000000000000\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"3000000000000000000000000000000000000000000000000000000000000000\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"5555555555555555555555555555555555555555555555555555555555555555\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"5555555555555555555555555555555555555555555555555555555555555556\".parse().unwrap()), false);\n\n\t\t// 2nd server: process hashes from 0x555...556 to 0xaaa...aab\n\t\tlet key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000002\".parse().unwrap()).unwrap());\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"5555555555555555555555555555555555555555555555555555555555555555\".parse().unwrap()), false);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"5555555555555555555555555555555555555555555555555555555555555556\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"7555555555555555555555555555555555555555555555555555555555555555\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac\".parse().unwrap()), false);\n\n\t\t// 3rd server: process hashes from 0x800...000 to 0xbff...ff\n\t\tlet key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(\n\t\t\t\"0000000000000000000000000000000000000000000000000000000000000003\".parse().unwrap()).unwrap());\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\".parse().unwrap()), false);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"daaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac\".parse().unwrap()), true);\n\t\tassert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),\n\t\t\t&\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\".parse().unwrap()), true);\n\t}", "item_id": 3, "repo": "altice-io/Daqiao", "file": "bridge/parity-ethereum/secret-store/src/listener/service_contract_listener.rs", "last_update_at": "2019-09-11T12:07:35+00:00"}
{"hexsha": "5331daaaa8930389c7c3e413b08b8033ddef4674", "ext": "rs", "lang": "Rust", "content": "pub fn parse_opts() -> Result<CliStatus, Error> {\n    let opt = Opt::from_args();\n    log::debug!(\"Cli opts are: {:?}\", opt);\n\n    match opt.cmd {\n        Command::Generate => {\n            generate_empty_config().context(\"Failed to generate config\")?;\n            log::info!(\"config.yml generated\");\n            Ok(CliStatus::Exit)\n        }\n        Command::Run {\n            config,\n            twil_sid,\n            twil_token,\n            twil_from,\n        } => {\n            if twil_sid.is_none() || twil_token.is_none() || twil_from.is_none() {\n                bail!(\"TWIL_ACCOUNT_SID, TWIL_AUTH_TOKEN & TWIL_FROM env variables must be set, or passed via --twil-sid, --twil-token & --twil-from\");\n            }\n            let twil_sid = twil_sid.unwrap();\n            let twil_token = twil_token.unwrap();\n            let twil_from = twil_from.unwrap();\n\n            let app_config = AppConfig::new(config, twil_sid, twil_token, twil_from)\n                .context(\"Failed to get config\")?;\n\n            Ok(CliStatus::Continue(app_config))\n        }\n    }\n}", "item_id": 0, "repo": "tarkah/nhl-notifier", "file": "src/cli.rs", "last_update_at": "2019-11-24T21:54:07+00:00"}
{"hexsha": "dec8765a6119b016dea6eacdbbcd90f8406a09d3", "ext": "rs", "lang": "Rust", "content": "fn solve(players: usize, max_marble: usize) -> usize {\n    let mut scores = vec![0usize; players];\n\n    let mut circle = CircularList::with_capacity(max_marble + 1);\n    circle.insert(0usize);\n\n    for marble in 1..=max_marble {\n        if marble % 23 == 0 {\n            scores[marble % players] += circle.seek(-7).remove().unwrap() + marble;\n        } else {\n            circle.next().insert(marble);\n        }\n    }\n\n    scores.into_iter().max().unwrap()\n}", "item_id": 0, "repo": "EdeMeijer/aoc2018", "file": "src/days/day9.rs", "last_update_at": "2019-03-06T09:35:12+00:00"}
{"hexsha": "f703fe03c06d740e5e4f8540ea77fb01065cea1e", "ext": "rs", "lang": "Rust", "content": "fn no_sensors() {\n            let mut status = api::Status {\n                sensors: None,\n                ..api::Status::default()\n            };\n            assert_eq!(status.state, None);\n            StateFromPeopleNowPresent.modify(&mut status);\n            assert_eq!(status.sensors, None);\n            assert_eq!(status.state, None);\n        }", "item_id": 0, "repo": "spaceapi-community/spaceapi-server-rs", "file": "src/modifiers.rs", "last_update_at": "2019-07-08T20:08:16+00:00"}
{"hexsha": "00d369fffd7cf57f1580aff9e033cd4f56302c88", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn wlr_pointer_gestures_v1_send_swipe_end(mut gestures:\n                                                                    *mut wlr_pointer_gestures_v1,\n                                                                mut seat:\n                                                                    *mut wlr_seat,\n                                                                mut time_msec:\n                                                                    uint32_t,\n                                                                mut cancelled:\n                                                                    bool) {\n    let mut focus: *mut wlr_surface = (*seat).pointer_state.focused_surface;\n    if focus.is_null() { return }\n    let mut focus_client: *mut wl_client =\n        wl_resource_get_client((*focus).resource);\n    let mut serial: uint32_t =\n        wlr_seat_client_next_serial((*seat).pointer_state.focused_client);\n    let mut gesture: *mut wl_resource = 0 as *mut wl_resource;\n    gesture = 0 as *mut wl_resource;\n    gesture = wl_resource_from_link((*gestures).swipes.next);\n    while wl_resource_get_link(gesture) !=\n              &mut (*gestures).swipes as *mut wl_list {\n        let mut gesture_seat: *mut wlr_seat =\n            seat_from_pointer_resource(gesture);\n        let mut gesture_client: *mut wl_client =\n            wl_resource_get_client(gesture);\n        if !(gesture_seat != seat || gesture_client != focus_client) {\n            zwp_pointer_gesture_swipe_v1_send_end(gesture, serial, time_msec,\n                                                  cancelled as int32_t);\n        }\n        gesture = wl_resource_from_link((*wl_resource_get_link(gesture)).next)\n    };\n}", "item_id": 5, "repo": "RoastVeg/wlrusts", "file": "src/types/wlr_pointer_gestures_v1.rs", "last_update_at": "2019-12-10T16:29:26+00:00"}
{"hexsha": "7c101485aa99c1b7d903812912399e3647b750eb", "ext": "rs", "lang": "Rust", "content": "fn test_map_lock() {\n        let lock = Arc::new(MapLock::new());\n        let g = lock.lock(vec![\"test\"]);\n        let g1 = lock.try_lock(vec![\"test\", \"test1\"]);\n        assert_eq!(g1.is_some(), false);\n        drop(g);\n        let g2 = lock.try_lock(vec![\"test\", \"test1\"]);\n        assert_eq!(g2.is_some(), true);\n\n        let lock_1 = lock.clone();\n        let j = go!(move || {\n            let _g = lock_1.lock(vec![\"test\"]);\n            println!(\"comeback in coroutine\");\n        });\n\n        drop(g2);\n        j.join().unwrap();\n    }", "item_id": 0, "repo": "ringringringring/rust-trustnote", "file": "src/utils/map_lock.rs", "last_update_at": "2019-05-28T10:59:27+00:00"}
{"hexsha": "9cb5ffda8007df05fff157d52a348a054b4035c7", "ext": "rs", "lang": "Rust", "content": "fn test_health_watch_multiple() {\n    let (_server, service, client) = setup();\n\n    // Watch should fetch service status immediately.\n    let mut statuses0 = vec![watch(&client, \"\")];\n    assert_next(ServingStatus::ServiceUnknown, &mut statuses0[0]);\n\n    service.set_serving_status(\"\", ServingStatus::Serving);\n    statuses0.push(watch(&client, \"\"));\n    for s in &mut statuses0 {\n        assert_next(ServingStatus::Serving, s);\n    }\n\n    service.set_serving_status(\"\", ServingStatus::NotServing);\n    statuses0.push(watch(&client, \"\"));\n    for s in &mut statuses0 {\n        assert_next(ServingStatus::NotServing, s);\n    }\n\n    // Multiple watchers for multiple service should work correctly.\n    let mut statuses1 = vec![watch(&client, TEST_SERVICE)];\n    assert_next(ServingStatus::ServiceUnknown, &mut statuses1[0]);\n    service.set_serving_status(TEST_SERVICE, ServingStatus::NotServing);\n    service.set_serving_status(\"\", ServingStatus::Serving);\n    for s in &mut statuses0 {\n        assert_next(ServingStatus::Serving, s);\n    }\n    for s in &mut statuses1 {\n        assert_next(ServingStatus::NotServing, s);\n    }\n}", "item_id": 6, "repo": "tier-cap/grpc-rs", "file": "health/tests/health_check.rs", "last_update_at": "2019-10-21T14:15:04+00:00"}
{"hexsha": "c67d45ae049dc180a1387fa31f6a877a9ddcce61", "ext": "rs", "lang": "Rust", "content": "fn process_usage_update(current_hour: u64, msg: UpdateUsage, data: &mut UsageTracker) {\n    // history contains a reference to whatever the correct storage array is\n    let history = match msg.kind {\n        UsageType::Client => &mut data.client_bandwidth,\n        UsageType::Relay => &mut data.relay_bandwidth,\n        UsageType::Exit => &mut data.exit_bandwidth,\n    };\n    // we grab the front entry from the VecDeque, if there is an entry one we check if it's\n    // up to date, if it is we add to it, if it's not or there is no entry we create one.\n    // note that price is only sampled once per hour.\n    match history.front_mut() {\n        None => history.push_front(UsageHour {\n            index: current_hour,\n            up: msg.up,\n            down: msg.down,\n            price: msg.price,\n        }),\n        Some(entry) => {\n            if entry.index == current_hour {\n                entry.up += msg.up;\n                entry.down += msg.down;\n            } else {\n                history.push_front(UsageHour {\n                    index: current_hour,\n                    up: msg.up,\n                    down: msg.down,\n                    price: msg.price,\n                })\n            }\n        }\n    }\n    while history.len() > MAX_USAGE_ENTRIES {\n        let _discarded_entry = history.pop_back();\n    }\n}", "item_id": 2, "repo": "althea-mesh/althea_rs", "file": "rita_common/src/usage_tracker/mod.rs", "last_update_at": "2019-06-10T17:42:00+00:00"}
{"hexsha": "d2f10e3d823b71a17fb7e7635542991e2937228f", "ext": "rs", "lang": "Rust", "content": "fn test_has_permission_b_has_a() {\n        let context = MockTransactionContext::default();\n        let pc = PermissionChecker::new(&context);\n\n        let builder = AgentBuilder::new();\n        let agent = builder\n            .with_org_id(ORG_ID.to_string())\n            .with_public_key(PUBLIC_KEY.to_string())\n            .with_active(true)\n            .with_roles(vec![ROLE_A.to_string()])\n            .build()\n            .unwrap();\n        let builder = AgentListBuilder::new();\n        let agent_list = builder.with_agents(vec![agent.clone()]).build().unwrap();\n        let agent_bytes = agent_list.into_bytes().unwrap();\n        let agent_address = compute_agent_address(PUBLIC_KEY);\n        context.set_state_entry(agent_address, agent_bytes).unwrap();\n\n        let result = pc.has_permission(PUBLIC_KEY, ROLE_B, ORG_ID).unwrap();\n        assert!(!result);\n    }", "item_id": 2, "repo": "target/grid", "file": "sdk/src/permissions.rs", "last_update_at": "2019-12-13T12:46:48+00:00"}
{"hexsha": "8d7634bac46112fcb1e2733661b44d4394ca48ce", "ext": "rs", "lang": "Rust", "content": "fn test_statsd_client_decr() {\n    let client = new_nop_client(\"client.test\");\n    let expected = Counter::new(\"client.test\", \"counter.key\", -1);\n    assert_eq!(expected, client.decr(\"counter.key\").unwrap());\n}", "item_id": 1, "repo": "Geal/cadence", "file": "tests/lib.rs", "last_update_at": "2019-11-13T13:45:14+00:00"}
{"hexsha": "763c7e6f78b7655590063808dc25ddfc9db84990", "ext": "rs", "lang": "Rust", "content": "fn test_regexp() {\n        let db = SqliteConnection::open_in_memory().unwrap();\n        db.create_scalar_function(\"regexp\", 2, true, Some(regexp)).unwrap();\n        let result = db.query_row(\"SELECT regexp('l.s[aeiouy]', 'lisa')\",\n                                           &[],\n                                           |r| r.get::<bool>(0));\n\n        assert_eq!(true, result.unwrap());\n    }", "item_id": 1, "repo": "Dashed/rusqlite", "file": "src/functions.rs", "last_update_at": "2019-06-12T22:17:19+00:00"}
{"hexsha": "c93ee20d28973beebaff3bb0a6c9ea476289d1ad", "ext": "rs", "lang": "Rust", "content": "fn apply_blur(pixels: &[Vec<u8>]) -> Vec<Vec<u8>> {\n    let strength = 20; // Amount of blur\n    let mut new_pixels = pixels.to_owned();\n    for (y, row) in pixels.iter().enumerate() {\n        for (x, v) in row.iter().enumerate() {\n            // Each lit pixel will bleed some light to the surrounding pixels\n            if *v == 255 {\n                // Apply bleed to surrounding pixels\n                let co_ords: Vec<(usize, usize)> = vec![\n                    (y.saturating_sub(1), x),\n                    (y+1,                 x),\n                    (y,                   x.saturating_sub(1)),\n                    (y,                   x+1),\n                    (y.saturating_sub(1), x.saturating_sub(1)),\n                    (y.saturating_sub(1), x+1),\n                    (y+1,                 x.saturating_sub(1)),\n                    (y+1,                 x+1),\n                ];\n\n                for (y, x) in co_ords {\n                    if (x < pixels[0].len()) &&\n                       (y < pixels.len()) {\n                        new_pixels[y][x] = new_pixels[y][x].saturating_add(strength);\n                    }\n                }\n            }\n        }\n    }\n    new_pixels\n}", "item_id": 4, "repo": "DavidSpickett/RustChip8", "file": "sdl/mod.rs", "last_update_at": "2019-09-27T13:38:41+00:00"}
{"hexsha": "bdf1312be213b2fabc38569406a808ee67757743", "ext": "rs", "lang": "Rust", "content": "fn expect_env(key: &str) -> String {\n    let value = env::var(key);\n    if value.is_err() {\n        eprintln!(\"{} environment variable is not defined.\", key);\n        eprintln!(\"Make sure you're running cargo via the `napi` wrapper script to assign correct environment variables and options.\");\n        std::process::exit(1);\n    };\n    value.unwrap()\n}", "item_id": 0, "repo": "apcragg/xray", "file": "napi/build.rs", "last_update_at": "2019-07-26T16:29:35+00:00"}
{"hexsha": "f02f604bf7808c8de5c8ef9656a8dddda99a4198", "ext": "rs", "lang": "Rust", "content": "fn shared_wtypesbase() {\n    use winapi::shared::wtypesbase::*;\n    assert_eq!(size_of::<COAUTHIDENTITY>(), 28);\n    assert_eq!(align_of::<COAUTHIDENTITY>(), 4);\n    assert_eq!(size_of::<COAUTHINFO>(), 28);\n    assert_eq!(align_of::<COAUTHINFO>(), 4);\n    assert_eq!(size_of::<BYTE_BLOB>(), 8);\n    assert_eq!(align_of::<BYTE_BLOB>(), 4);\n    assert_eq!(size_of::<WORD_BLOB>(), 8);\n    assert_eq!(align_of::<WORD_BLOB>(), 4);\n    assert_eq!(size_of::<WORD_BLOB>(), 8);\n    assert_eq!(align_of::<WORD_BLOB>(), 4);\n    assert_eq!(size_of::<FLAGGED_BYTE_BLOB>(), 12);\n    assert_eq!(align_of::<FLAGGED_BYTE_BLOB>(), 4);\n    assert_eq!(size_of::<FLAGGED_WORD_BLOB>(), 12);\n    assert_eq!(align_of::<FLAGGED_WORD_BLOB>(), 4);\n    assert_eq!(size_of::<BYTE_SIZEDARR>(), 8);\n    assert_eq!(align_of::<BYTE_SIZEDARR>(), 4);\n    assert_eq!(size_of::<WORD_SIZEDARR>(), 8);\n    assert_eq!(align_of::<WORD_SIZEDARR>(), 4);\n    assert_eq!(size_of::<DWORD_SIZEDARR>(), 8);\n    assert_eq!(align_of::<DWORD_SIZEDARR>(), 4);\n    assert_eq!(size_of::<HYPER_SIZEDARR>(), 8);\n    assert_eq!(align_of::<HYPER_SIZEDARR>(), 4);\n    assert_eq!(size_of::<BLOB>(), 8);\n    assert_eq!(align_of::<BLOB>(), 4);\n}", "item_id": 14, "repo": "mohandatla/winapi-rs", "file": "tests/structs.rs", "last_update_at": "2019-10-07T18:40:16+00:00"}
{"hexsha": "5176df6ed5a22dfbca02f1bf858b5f0bf670af30", "ext": "rs", "lang": "Rust", "content": "fn from_points_many() {\n        let points = vec![\n            Point::new(0, 0),\n            Point::new(5, 8),\n            Point::new(2, 3),\n            Point::new(8, 14),\n        ];\n\n        let poly = Polynomial::from_points(&points, 3).unwrap();\n        let poly2 = Polynomial::builder()\n            .with(Fraction::new(263, 180), 1)\n            .with(Fraction::new(1, 72), 2)\n            .with(Fraction::new(1, 360), 3)\n            .build();\n\n        assert_eq!(poly, poly2);\n    }", "item_id": 6, "repo": "bilowik/sss-rs", "file": "src/geometry/polynomial.rs", "last_update_at": "2019-12-24T02:53:17+00:00"}
{"hexsha": "dd8027092ca620bcfab27b101d95d4ca23b197f8", "ext": "rs", "lang": "Rust", "content": "fn test_some_floats_f32() {\n    check_value(&Float::from(0.758f32).into());\n    check_value(&Float::from(std::f32::MAX).into());\n    check_value(&Float::from(std::f32::MIN).into());\n    check_value(&Float::from(std::f32::INFINITY).into());\n    check_value(&Float::from(0f32).into());\n\n    // special check for NaN\n    serialize_de_serialize(&Float::from(std::f32::NAN).into(), |result| match result {\n        Value::Float(float) => {\n            let v_float: f32 = f32::try_from(float).unwrap();\n            assert!(v_float.is_nan());\n        }\n        _ => panic!(\"Expected a float!\"),\n    });\n}", "item_id": 0, "repo": "cronosun/liquesco-rust", "file": "serialization/tests/value/float.rs", "last_update_at": "2019-05-30T21:20:19+00:00"}
{"hexsha": "34214f6c591acc69b39dc0fa34b94a0a45b7d374", "ext": "rs", "lang": "Rust", "content": "fn kill_timeout_but_kill_not_set() {\n        let args = vec![\n            String::from(\"g-cli\"),\n            String::from(\"--kill-timeout\"),\n            String::from(\"5000\"),\n            String::from(\"test.vi\"),\n            String::from(\"--\"),\n            String::from(\"test1\"),\n        ];\n\n        let config = Configuration::from_arg_array(args);\n        assert_eq!(None, config.kill);\n    }", "item_id": 16, "repo": "JamesMc86/LabVIEW-CLI", "file": "rust-proxy/src/cli.rs", "last_update_at": "2019-04-02T09:55:35+00:00"}
{"hexsha": "af54f0d6ab27c118a850cdea3b333c5b6e72654f", "ext": "rs", "lang": "Rust", "content": "fn initialize_environment() -> OcamlEnvironment {\n    let (task_tx, task_rx) = channel();\n    let spawner = OcamlTaskSpawner { spawned_tasks: Arc::new(Mutex::new(task_tx)) };\n    let executor = OcamlThreadExecutor { ready_tasks: task_rx };\n    thread::spawn(move || {\n        start_ocaml_runtime();\n        executor.run()\n    });\n\n    OcamlEnvironment { spawner }\n}", "item_id": 0, "repo": "mrjoe7/tezedge", "file": "tezos/interop/src/runtime.rs", "last_update_at": "2019-11-29T18:25:07+00:00"}
{"hexsha": "0a3ed13cc8ad6d16a88dd4fed5e2c3c927369b45", "ext": "rs", "lang": "Rust", "content": "fn new_rect(lat1: i32, lon1: i32, lat2: i32, lon2: i32) -> Rectangle {\n    let mut rect = Rectangle::default();\n    rect.set_lo(new_point(lat1, lon1));\n    rect.set_hi(new_point(lat2, lon2));\n    rect\n}", "item_id": 1, "repo": "tier-cap/grpc-rs", "file": "tests-and-examples/examples/route_guide/client.rs", "last_update_at": "2019-10-21T14:15:04+00:00"}
{"hexsha": "521446926353aa29f8e0c0f47a9ceb19d7a8585a", "ext": "rs", "lang": "Rust", "content": "fn main() -> std::io::Result<()> {\n    let args: Vec<_> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"usage: {}\u00a0filename\", args[0]);\n        return Result::Err(std::io::Error::new(std::io::ErrorKind::Other, \"\"))\n    }\n\n    let file = File::open(&args[1])?;\n    let buf_reader = BufReader::new(file);\n    let lines = buf_reader.lines().map(|l| l.unwrap());\n\n    let mut freqs = HashMap::new();\n\n    for l in lines {\n        let words = l.split_whitespace();\n        for w in words {\n            let val = match freqs.get(&w.to_string()) {\n                Some(c) => c+1,\n                None => 1,\n            };\n            freqs.insert(w.to_string(), val);\n        }\n    }\n    let mut counts: Vec<_> = freqs.iter().collect();\n    counts.sort_by(|a, b| b.1.cmp(a.1)); // compare by count value\n    for (w, c) in counts.iter().take(25) {\n        println!(\"{}:{}\", w, c);\n    }\n    Ok(())\n}", "item_id": 0, "repo": "elefevre/lost-in-transation", "file": "rust/wordcount/src/main.rs", "last_update_at": "2019-02-21T20:42:03+00:00"}
{"hexsha": "fdd9b3dd30fa3c3b947a0f31d64c585355c642a6", "ext": "rs", "lang": "Rust", "content": "fn relu_with_threshold_test() {\n        assert_eq!(relu_with_threshold(1.0, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(0.5, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(0.0, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(-10.0, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(10.0, 2.0), 10.0);\n        assert_eq!(relu_with_threshold(1.9, 2.0), 2.0);\n        assert_eq!(relu_with_threshold(2.1, 2.0), 2.1);\n    }", "item_id": 2, "repo": "elbow-jason/lib_annex", "file": "src/activation.rs", "last_update_at": "2019-04-06T01:50:45+00:00"}
{"hexsha": "8fe71bc79ab690e4d10c32b6e8d596c010446e03", "ext": "rs", "lang": "Rust", "content": "fn test_parse_deref() {\n        logger_init();\n        let sess = ParseSess::new();\n        let mut conv_map = unwrap_presult!(parse_types_conv_map(\n            &sess,\n            \"deref_code\",\n            r#\"\n#[allow(dead_code)]\n#[swig_code = \"let {to_var}: {to_var_type} = {from_var}.swig_deref();\"]\ntrait SwigDeref {\n    type Target: ?Sized;\n    fn swig_deref(&self) -> &Self::Target;\n}\n\nimpl SwigDeref for String {\n    type Target = str;\n    fn swig_deref(&self) -> &str {\n        &self\n    }\n}\n\"#,\n            HashMap::new(),\n            64\n        ));\n        let (_, code) = unwrap_presult!(conv_map.convert_rust_types(\n            &sess,\n            &rust_type_from_str(\"String\"),\n            &rust_type_from_str(\"&str\"),\n            \"a0\",\n            \"jlong\",\n            DUMMY_SP\n        ));\n        assert_eq!(\"    let a0: &str = a0.swig_deref();\\n\".to_string(), code);\n    }", "item_id": 12, "repo": "rubdos/rust_swig", "file": "macroslib/src/types_conv_map/parsing.rs", "last_update_at": "2019-04-21T12:35:26+00:00"}
{"hexsha": "66aa4ba1a1fd6eb6aa8f48ca4e62531839e0478f", "ext": "rs", "lang": "Rust", "content": "fn test_alloc_fil_second_hole() {\n        let mut alloc = Allocator::new();\n        let first = alloc.alloc(2, 4);\n        let sec = alloc.alloc(3, 8);\n        alloc.free(sec, 3 + 1);\n        alloc.free(first, 2 + 1);\n        println!(\"fail here \\n\\n{}\\n{:?}\\n\\n\", alloc.first_hole, alloc.heap);\n        println!(\"first hole : {}\", alloc.first_hole);\n        // first is before the 3. link to 0\n        assert_eq!(alloc.heap(), vec![3, 3, 0, 7, 4, 0, 0, 0, MAX_HEAP_SIZE]);\n        alloc.alloc(3, 8);\n        assert_eq!(alloc.heap(), vec![7, 3, 0, 8, 4, 0, 0, 0, MAX_HEAP_SIZE]);\n    }", "item_id": 4, "repo": "PBertinJohannet/Eptx", "file": "src/vm/allocator.rs", "last_update_at": "2019-03-27T11:31:05+00:00"}
{"hexsha": "186bc91dc8abcb946bf0553c183033ccbe3646a3", "ext": "rs", "lang": "Rust", "content": "fn test_edge_inserted_without_adding_nodes_directed() {\n    let mut net: Network<usize, f64> = Network::new(true);\n\n    net.add_edge(0, 1, 10.0);\n\n    check_network(net, 2, 1, vec![0, 1], vec![(0, 1, vec![&10.0])]);\n}", "item_id": 4, "repo": "pbielak/rusty-nets", "file": "tests/unit/network/model_tests.rs", "last_update_at": "2019-02-20T11:27:22+00:00"}
{"hexsha": "5e7e45fc371bccafaa17f418793da5254d860ceb", "ext": "rs", "lang": "Rust", "content": "fn named_target() {\n        let yaml = r#\"\n            targets:\n                config_json:\n                    type: fileset\n                    format: json\n                    location:\n                        path: /somewhere\n                        partition: 0\n        \"#;\n        let mapping: Mapping = serde_yaml::from_str(yaml).unwrap();\n        assert_eq!(mapping.target_count(), 1);\n\n        let target = mapping.named_target(\"config_json\").unwrap();\n        assert_eq!(target.type_(), Type::FileSet);\n        assert_eq!(target.format(), Format::Json);\n        assert_eq!(target.location().path(), \"/somewhere\");\n        assert_eq!(target.location().partition(), &Partition::Index(0));\n    }", "item_id": 0, "repo": "DalavanCloud/reconfix", "file": "src/types/mapping/mod.rs", "last_update_at": "2019-01-25T06:45:48+00:00"}
{"hexsha": "2bb96d68f3d3067c15c34ee49864a6e598781ac0", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<()> {\n    let mut byte_array_test = Vec::new();\n    for i in 0i32..1000 {\n        let value = (i * i * 255 + i * 7) % 100;\n        byte_array_test.push(value as i8)\n    }\n    let byte_array_test = byte_array_test.into_boxed_slice();\n    let value = TestStruct {\n        nested: Nested {\n            egg: Food {\n                name: \"Eggbert\",\n                value: 0.5,\n            },\n            ham: Food {\n                name: \"Hampus\",\n                value: 0.75,\n            },\n        },\n        byte_test: 127,\n        short_test: 32767,\n        int_test: 2147483647,\n        long_test: 9223372036854775807,\n        double_test: 0.49312871321823148,\n        float_test: 0.49823147058486938,\n        string_test: \"HELLO WORLD THIS IS A TEST STRING!\",\n        list_long_test: [11, 12, 13, 14, 15],\n        list_compound_test: vec![\n            NestedCompound {\n                created_on: 1264099775885,\n                name: \"Compound tag #0\",\n            },\n            NestedCompound {\n                created_on: 1264099775885,\n                name: \"Compound tag #1\",\n            },\n        ],\n        byte_array_test,\n    };\n    println!(\"{}\", to_string_transcript((\"Level\", &value))?);\n    Ok(())\n}", "item_id": 0, "repo": "luojia65/coruscant", "file": "coruscant-nbt/examples/nbt-ser-big.rs", "last_update_at": "2019-10-19T20:58:42+00:00"}
{"hexsha": "1a4b0fbeaf4cc15e38e56c6224e190fb3a4a79bc", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    if pkg_config::find_library(\"ao\").is_ok() {\n        return;\n    }\n    let source = PathBuf::from(&get!(\"CARGO_MANIFEST_DIR\")).join(\"source\");\n    let output = PathBuf::from(&get!(\"OUT_DIR\"));\n    let build = output.join(\"build\");\n    ok!(fs::create_dir_all(&build));\n    run!(cmd!(source.join(\"configure\")).current_dir(&build)\n                                       .arg(&format!(\"--prefix={}\", output.display())));\n    run!(cmd!(\"make\").current_dir(&build).arg(\"install\"));\n    println!(\"cargo:rustc-link-lib=dylib=ao\");\n    println!(\"cargo:rustc-link-search={}\", output.join(\"lib\").display());\n}", "item_id": 0, "repo": "stainless-steel/ao-sys", "file": "build.rs", "last_update_at": "2019-09-05T15:02:49+00:00"}
{"hexsha": "35ba411ab6ccdfa2e343b301a029ad3aa9c7fb1a", "ext": "rs", "lang": "Rust", "content": "pub fn outgoing_metrics<A: Account + CcpRoutingAccount>(\n    request: OutgoingRequest<A>,\n    mut next: impl OutgoingService<A>,\n) -> impl Future<Item = Fulfill, Error = Reject> {\n    let labels = labels!(\n        \"from_asset_code\" => request.from.asset_code().to_string(),\n        \"to_asset_code\" => request.to.asset_code().to_string(),\n        \"from_routing_relation\" => request.from.routing_relation().to_string(),\n        \"to_routing_relation\" => request.to.routing_relation().to_string(),\n    );\n\n    // TODO replace these calls with the counter! macro if there's a way to easily pass in the already-created labels\n    // right now if you pass the labels into one of the other macros, it gets a recursion limit error while expanding the macro\n    recorder().increment_counter(\n        Key::from_name_and_labels(\"requests.outgoing.prepare\", labels.clone()),\n        1,\n    );\n    let start_time = Instant::now();\n\n    next.send_request(request).then(move |result| {\n        if result.is_ok() {\n            recorder().increment_counter(\n                Key::from_name_and_labels(\"requests.outgoing.fulfill\", labels.clone()),\n                1,\n            );\n        } else {\n            recorder().increment_counter(\n                Key::from_name_and_labels(\"requests.outgoing.reject\", labels.clone()),\n                1,\n            );\n        }\n\n        recorder().record_histogram(\n            Key::from_name_and_labels(\"requests.outgoing.duration\", labels.clone()),\n            (Instant::now() - start_time).as_nanos() as u64,\n        );\n        result\n    })\n}", "item_id": 1, "repo": "dora-gt/interledger-rs", "file": "crates/ilp-node/src/metrics.rs", "last_update_at": "2019-04-16T14:29:42+00:00"}
{"hexsha": "d0cc772e8eed7bca68870c18551d47f163eb1e24", "ext": "rs", "lang": "Rust", "content": "fn test_invalid_url() {\n        let request_params = RequestParams::default();\n        let response = Response {\n            apps: vec![App {\n                update_check: Some(UpdateCheck::ok(vec![\"invalid-url\".to_string()])),\n                ..App::default()\n            }],\n            ..Response::default()\n        };\n        assert_eq!(\n            FuchsiaInstallPlan::try_create_from(&request_params, &response),\n            Err(InstallPlanErrors::Failed)\n        );\n    }", "item_id": 7, "repo": "zhangpf/fuchsia-rs", "file": "garnet/bin/omaha_client/src/install_plan.rs", "last_update_at": "2019-04-21T18:02:26+00:00"}
{"hexsha": "d71b9abfbd1798542832aeae848148e506f4dc81", "ext": "rs", "lang": "Rust", "content": "fn should_be_able_to_get_correct_matrix_representation_of_connections() {\n        let mut organism = NeuralNetwork::with_neurons(3);\n        organism.add_connection(0, 1, 1.0);\n        organism.add_connection(1, 2, 0.5);\n        organism.add_connection(2, 1, 0.5);\n        organism.add_connection(2, 2, 0.75);\n        organism.add_connection(1, 0, 1.0);\n        let nn = organism.make_network();\n        assert_eq!(\n            organism.get_weights(),\n            vec![0.0, 1.0, 0.0, 1.0, 0.0, 0.5, 0.0, 0.5, 0.75]\n        );\n    }", "item_id": 13, "repo": "playXE/rustneat", "file": "src/nn/mod.rs", "last_update_at": "2019-07-30T05:52:26+00:00"}
{"hexsha": "f9d636c2729fa87c771437d2527eaa8d7c4f40cf", "ext": "rs", "lang": "Rust", "content": "fn polygon_with_point_on_interior_ring() {\n        let poly = holy_polygon();\n        let p = poly.interiors()[0].0[3];\n        let should_be = Closest::Intersection(p.into());\n\n        let got = poly.closest_point(&p.into());\n\n        assert_eq!(got, should_be);\n    }", "item_id": 6, "repo": "phreeheeler/geo", "file": "geo/src/algorithm/closest_point.rs", "last_update_at": "2019-04-21T09:54:39+00:00"}
{"hexsha": "0b18c2571246b24f06e847aab245d829fafa3049", "ext": "rs", "lang": "Rust", "content": "pub fn update_registry_and_shuffling_data(\n    state: &mut BeaconState,\n    current_total_balance: u64,\n    spec: &ChainSpec,\n) -> Result<(), Error> {\n    // First set previous shuffling data to current shuffling data.\n    state.previous_shuffling_epoch = state.current_shuffling_epoch;\n    state.previous_shuffling_start_shard = state.previous_shuffling_start_shard;\n    state.previous_shuffling_seed = state.previous_shuffling_seed;\n\n    let current_epoch = state.current_epoch(spec);\n    let next_epoch = current_epoch + 1;\n\n    // Check we should update, and if so, update.\n    if should_update_validator_registry(state, spec)? {\n        update_validator_registry(state, current_total_balance, spec)?;\n\n        // If we update the registry, update the shuffling data and shards as well.\n        state.current_shuffling_epoch = next_epoch;\n        state.current_shuffling_start_shard = {\n            let active_validators =\n                state.get_cached_active_validator_indices(RelativeEpoch::Current, spec)?;\n            let epoch_committee_count = spec.get_epoch_committee_count(active_validators.len());\n\n            (state.current_shuffling_start_shard + epoch_committee_count) % spec.shard_count\n        };\n        state.current_shuffling_seed = state.generate_seed(state.current_shuffling_epoch, spec)?;\n    } else {\n        // If processing at least on crosslink keeps failing, the reshuffle every power of two, but\n        // don't update the current_shuffling_start_shard.\n        let epochs_since_last_update = current_epoch - state.validator_registry_update_epoch;\n\n        if epochs_since_last_update > 1 && epochs_since_last_update.is_power_of_two() {\n            state.current_shuffling_epoch = next_epoch;\n            state.current_shuffling_seed =\n                state.generate_seed(state.current_shuffling_epoch, spec)?;\n        }\n    }\n\n    Ok(())\n}", "item_id": 0, "repo": "zedt3ster/lighthouse", "file": "eth2/state_processing/src/per_epoch_processing/update_registry_and_shuffling_data.rs", "last_update_at": "2019-04-15T06:39:50+00:00"}
{"hexsha": "e2f89e943d304541c8ccd8a980ecf9d1ce9c654c", "ext": "rs", "lang": "Rust", "content": "fn find_cycle(moons: &Vec<Vec<Moon1D>>, axis_index: usize) -> usize {\n    let mut cloned = moons.clone();\n    let original: Vec<Moon1D> = cloned.iter().map(|m| m[axis_index]).collect();\n    let mut moons: Vec<&mut Moon1D> = cloned.iter_mut().map(|m| &mut m[axis_index]).collect();\n\n    let mut counter = 0;\n\n    loop {\n        update_velocities_1d(&mut moons);\n        update_positions_1d(&mut moons);\n\n        counter += 1;\n\n        let mut done = true;\n        for i in 0..original.len() {\n            if moons[i] != &original[i] {\n                done = false;\n                break;\n            }\n        }\n\n        if done {\n            break;\n        }\n    }\n\n    counter\n}", "item_id": 2, "repo": "gentoid/aoc-2019-rust", "file": "src/aoc_12.rs", "last_update_at": "2019-12-06T13:12:12+00:00"}
{"hexsha": "795715f1939b533a655add7d1fe557971f48d9a7", "ext": "rs", "lang": "Rust", "content": "fn test_functional_process_file_green() {\n        Command::cargo_bin(\"stevia\")\n            .unwrap()\n            .arg(\"examples/example.ink\")\n            .assert()\n            .success();\n\n        // Check contents of output file\n        let expected = \"P;Hello there|P;I'm a VN written in the Ink format|P;Do you like it?|Q;Yes, I like it!;00120;No, I do not like it;00136|P;Thank you!|E;|P;Oh, I see|E;\";\n        let contents = read_to_string(\"example.stevia\").expect(\"Cannot find .stevia file\");\n\n        assert_eq!(expected, contents);\n\n        clean();\n    }", "item_id": 1, "repo": "Pomettini/visual-novel-text-baker", "file": "src/bin/stevia.rs", "last_update_at": "2019-09-29T16:27:31+00:00"}
{"hexsha": "a084fb80681ade4e35fc1fa32ee0cd38df7eaf71", "ext": "rs", "lang": "Rust", "content": "fn it_should_know_if_input_is_less_than_8_in_immediate_mode() {\n        let program: Vec<i32> = vec![3, 3, 1107, -1, 8, 3, 4, 3, 99];\n        assert_eq!(run_program(&mut program.clone(), &mut vec![7]), 1);\n        assert_eq!(run_program(&mut program.clone(), &mut vec![8]), 0);\n    }", "item_id": 5, "repo": "paulsouche/adventofcode2019", "file": "src/bin/day05-sunny-with-a-chance-of-asteroids/main.rs", "last_update_at": "2019-12-01T11:34:37+00:00"}
{"hexsha": "96186abbda429901a23f60fa088fec1ae6f38405", "ext": "rs", "lang": "Rust", "content": "fn last_day_of_solar_month(timestamp: i64, longitude: f64) -> usize {\n    // HACK: This rely on an undefined behavior when getting a timestamp for\n    // day following the last day of the month.\n    let format = String::from(\"%h:%y:%s:%d:%c:%b\");\n    for i in 88..100 {\n        let a = get_formatted_date(&format!(\"%h:%y:%s:{:02}:50:00\", i), timestamp, longitude);\n        let t = get_timestamp(format.clone(), a.clone(), longitude);\n        let b = get_formatted_date(&format, t, longitude);\n        if a != b {\n            return i - 1;\n        }\n    }\n    unreachable!();\n}", "item_id": 1, "repo": "vinc/geocal", "file": "src/main.rs", "last_update_at": "2019-12-10T04:12:25+00:00"}
{"hexsha": "ad84a70282b8c08846b32a8b2fca20191e7dbc30", "ext": "rs", "lang": "Rust", "content": "fn tuple_without_element() {\n            let mut heap = RegionHeap::default();\n            let lhs = heap.tuple_from_slice(&[]).unwrap();\n            let rhs = heap.tuple_from_slice(&[]).unwrap();\n\n            assert_eq!(lhs, lhs);\n            assert_eq!(lhs, rhs);\n            assert_eq!(rhs, lhs);\n        }", "item_id": 8, "repo": "bitwalker/lumen", "file": "liblumen_alloc/src/erts/term/tuple.rs", "last_update_at": "2019-12-15T01:06:38+00:00"}
{"hexsha": "b8ef5fd1940b3ac7cf801c21a9bce0be53947648", "ext": "rs", "lang": "Rust", "content": "fn get_value(cpu: cpu_state, v: value) -> u16 {\n    alt v {\n      value_reg(t)     { cpu.regs[t] }\n      value_mem(t)     { cpu.mem[t] }\n      value_sp         { cpu.sp }", "item_id": 1, "repo": "jamorton/rust-dcpu16", "file": "emu.rs", "last_update_at": "2019-09-16T15:23:47+00:00"}
{"hexsha": "12d2341080374528fc5e5df648a6876f10f81621", "ext": "rs", "lang": "Rust", "content": "pub fn check_config(spec: &Spec) -> Result<bool, Error> {\n    let deploy_config = render_deploy_config(&spec)\n        .map_err(|e| format_err!(\"{}\", e))?;\n    let ref filename = spec.config.vagga_config;\n    let mut buf = String::with_capacity(1024);\n    let mut f = match File::open(&filename) {\n        Ok(f) => f,\n        Err(ref e) if e.kind() == io::ErrorKind::NotFound => return Ok(false),\n        Err(e) => bail!(\"Can't open file {:?}: {}\", filename, e),\n    };\n    f.read_to_string(&mut buf)\n        .map_err(|e| format_err!(\"Error reading {:?}: {}\", filename, e))?;\n    return Ok(deploy_config == buf);\n}", "item_id": 0, "repo": "tailhook/wark", "file": "src/local/mod.rs", "last_update_at": "2019-05-21T00:13:12+00:00"}
{"hexsha": "ab5293ee458ad84b43eb8071de56c5dbee8e5e61", "ext": "rs", "lang": "Rust", "content": "fn insert_two_items_and_get_list_entries() {\n        let mut table = InvertibleBloomLookupTable::<DefaultHasher>::new(256, 8).unwrap();\n        assert!(table.insert(4, 6).is_ok());\n        assert!(table.insert(5, 7).is_ok());\n        let results = table.list_entries().ok().unwrap();\n        assert_eq!(results.key_pairs.len(), 2);\n        for output in results.key_pairs {\n            if output.key_sum == 4 {\n                assert_eq!(output.value_sum, 6);\n            } else if output.key_sum == 5 {\n                assert_eq!(output.value_sum, 7);\n            }\n        }\n    }", "item_id": 4, "repo": "elniallo/IBLT", "file": "src/iblt.rs", "last_update_at": "2019-02-04T13:11:27+00:00"}
{"hexsha": "cd2364b37d17ebebef7c057656e96f18c3f124f2", "ext": "rs", "lang": "Rust", "content": "pub fn platform() -> String {\n\tlet env = Target::env();\n\tlet env_dash = if env.is_empty() { \"\" } else { \"-\" };\n\tformat!(\"{}-{}{}{}\", Target::arch(), Target::os(), env_dash, env)\n}", "item_id": 0, "repo": "HPIPS/HPIPS_Chain", "file": "core/service/src/config.rs", "last_update_at": "2019-08-07T10:22:08+00:00"}
{"hexsha": "77a16e6f9acfb714a3642fbd3355c499f2af936f", "ext": "rs", "lang": "Rust", "content": "fn multiply_assign_vector_by_vector_component_wise() {\n        let mut v1 = Vec3::new(1., 2., 3.);\n        let v2 = Vec3::new(3., 2., 1.);\n        v1 *= v2;\n        assert_eq!(v1.x(), 3.);\n        assert_eq!(v1.y(), 4.);\n        assert_eq!(v1.z(), 3.);\n    }", "item_id": 8, "repo": "FractalArt/raytracer.rs", "file": "src/vec3.rs", "last_update_at": "2019-12-04T11:19:11+00:00"}
{"hexsha": "9082b1af96e07a420786ee77cf1d8f83d61e92ba", "ext": "rs", "lang": "Rust", "content": "fn handle_err<A: AsRef<str>>(o: io::Result<Output>, cmd: A) -> Output {\n    let o = match o {\n        Err(e) => {\n            eprintln!(\"{}\", cmd.as_ref());\n            eprintln!(\"\\tIO Error on exec:\\n{:?}\", e);\n            ::std::process::exit(1);\n        }\n        Ok(o) => o,\n    };\n    if !o.status.success() {\n        let stderr = String::from_utf8_lossy(o.stderr.as_slice());\n        let stdout = String::from_utf8_lossy(o.stdout.as_slice());\n        eprintln!(\"{}\", cmd.as_ref());\n        match o.status.code() {\n            Option::Some(x) => eprintln!(\"\\tExit Code: {:?}\", x),\n            _ => {}\n        };\n        eprintln!(\"\\tStdErr:\\n {}\", stderr);\n        eprintln!(\"\\tStdOut:\\n {}\", stdout);\n        ::std::process::exit(1);\n    }\n    o\n}", "item_id": 0, "repo": "Phantomical/xed-sys", "file": "build.rs", "last_update_at": "2019-06-24T02:19:09+00:00"}
{"hexsha": "55fd51ac5eb0db8c567c311373a2941b8af58c04", "ext": "rs", "lang": "Rust", "content": "pub fn cross_word<T>(first: T, second: T, bit_index: u8) -> (T, T) \r\n    where T: PrimInt + FromPrimitive + ToPrimitive {\r\n    let bit_mask = T::from_u32(2_u32.pow(bit_index.to_u32().unwrap()) - 1).unwrap();\r\n\r\n    let first_result  = (first  & !bit_mask) | (second & bit_mask);\r\n    let second_result = (second & !bit_mask) | (first  & bit_mask);\r\n\r\n    (first_result, second_result)\r\n}", "item_id": 7, "repo": "nsmryan/rgep", "file": "src/crossover.rs", "last_update_at": "2019-04-12T16:06:04+00:00"}
{"hexsha": "bbf08393c0cea4fb3d6e0589ed2718bd1e720180", "ext": "rs", "lang": "Rust", "content": "pub fn minimize1d<F>(mut begin: f64, mut end: f64, iterations: usize, function: F) -> f64\n    where F: Fn(f64) -> f64\n{\n    let mut x1 = 0.0;\n    let mut y1 = 0.0;\n    let mut x2 = 0.0;\n    let mut y2 = 0.0;\n    let mut is1 = false;\n    let mut is2 = false;\n    let inverted_phi = 2.0 / (1.0 + 5.0f64.sqrt());\n    (0..iterations)\n        .for_each(|_| {\n            if !is1 {\n                x1 = end - (end  - begin) * inverted_phi;\n                y1 = function(x1);\n                is1 = true;\n            }\n            if !is2 {\n                x2 = begin + (end - begin) * inverted_phi;\n                y2 = function(x2);\n                is2 = true;\n            }\n            if y1 < y2 {\n                end = x2;\n                x2 = x1;\n                y2 = y1;\n                is1 = false;\n            } else {\n                begin = x1;\n                x1 = x2;\n                y1 = y2;\n                is2 = false;\n            }\n        });\n    (begin + end) / 2.0\n}", "item_id": 0, "repo": "elsid/CodeBall", "file": "src/optimization.rs", "last_update_at": "2019-12-05T09:54:16+00:00"}
{"hexsha": "0fdf076499d7999f24b7275c91703c6682d5c793", "ext": "rs", "lang": "Rust", "content": "fn main() {\r\n    stdweb::initialize();\r\n\r\n    assert!(\r\n        !cluster::is_worker(),\r\n        \"This module should not be instantiated as a worker!\"\r\n    );\r\n\r\n    cluster::setup_master(\r\n        cluster::ClusterSettingsBuilder::new()\r\n            .exec(node_rs::dirname().join(\"worker.js\"))\r\n            .build(),\r\n    );\r\n\r\n    println!(\"I'm the master!\");\r\n\r\n    let args: Vec<_> = std::env::args().collect();\r\n\r\n    let num_procs = if args.len() >= 2 {\r\n        args[1].parse().expect(\"First argument must be an integer.\")\r\n    } else {\r\n        4\r\n    };\r\n\r\n    let workers: Vec<_> = (0..num_procs).map(|_| cluster::fork()).collect();\r\n\r\n    let promises: Vec<_> = workers\r\n        .iter()\r\n        .cloned()\r\n        .map(|worker| {\r\n            Promise::new(move |resolve, _| {\r\n                worker.on_exit(move |_, _| {\r\n                    resolve.complete();\r\n                });\r\n            })\r\n        })\r\n        .collect();\r\n\r\n    Promise::all(&promises).then(|_| {\r\n        println!(\"Master exiting...\");\r\n        stdweb::Value::Undefined\r\n    });\r\n\r\n    stdweb::event_loop();\r\n}", "item_id": 0, "repo": "AndrewGaspar/node-rs", "file": "examples/master.rs", "last_update_at": "2019-04-03T22:49:34+00:00"}
{"hexsha": "5c5a296736c56916cf1a8908600471af2952d7c2", "ext": "rs", "lang": "Rust", "content": "pub fn save(new_todo: NewTodo) -> Todo {\n    let mut todos = TODOS.write().unwrap();\n    todos.counter += 1;\n    let todo = Todo {\n        id: todos.counter,\n        title: new_todo.title,\n        completed: new_todo.completed.unwrap_or(false),\n        order: new_todo.order.unwrap_or(0),\n    };\n\n    todos.db.insert(todo.id, todo.clone());\n    todo\n}", "item_id": 0, "repo": "ubnt-intrepid/finchers-todo", "file": "src/todo.rs", "last_update_at": "2019-09-25T11:36:15+00:00"}
{"hexsha": "e53601326c2b64b9489b460595926388bfcd2363", "ext": "rs", "lang": "Rust", "content": "async fn handle_schedule_request(\r\n    query: web::Query<DateBasedQuery>,\r\n) -> Result<HttpResponse, KretaError> {\r\n    let request_started = Instant::now();\r\n\r\n    let lessons: Vec<Lesson> = get_schedule(\r\n        query.token.clone(),\r\n        query.url.clone(),\r\n        query.from_date.clone(),\r\n        query.to_date.clone(),\r\n    )\r\n    .await?;\r\n\r\n    info!(\r\n        \"Schedule request done for {} in {}\",\r\n        &query.url,\r\n        request_started.elapsed().as_millis()\r\n    );\r\n\r\n    Ok(HttpResponse::build(StatusCode::OK).json(lessons))\r\n}", "item_id": 4, "repo": "hazizz/kreta-proxy", "file": "src/kreta_proxy.rs", "last_update_at": "2019-09-30T19:20:34+00:00"}
{"hexsha": "0c77eac154be90b49ab4c1b601b57a7fd90e0ef1", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // initialize logger\n    simple_logger::init().unwrap();\n\n    // setup of main data structures\n    let mut ecs_ = ecs::ECS::new();\n    let mut render_conf = RenderConfig {\n        scale: 100.0,\n        window_xs: 1000,\n        window_ys: 1000,\n        focused_entity: None\n    };\n\n    info!(\"Creating window with {:?}\", render_conf);\n    \n    // setup of opengl window\n    let opengl  = OpenGL::V3_2;\n\tlet mut window: Window = WindowSettings::new(\n            \"rustac\",\n            [render_conf.window_xs, render_conf.window_ys]\n        )\n        .graphics_api(opengl)\n        .exit_on_esc(true)\n        .build()\n        .unwrap();\n\n\n\tlet ref mut gl  = GlGraphics::new(opengl);\n    let sprite_textures = sprite::setup_sprite_textures();\n\t\n    // BEGIN test code\n\n    use crate::builder::dungeon;\n\n    dungeon::create_empty_room(&mut ecs_, 0.0, 0.0, 10, 8);\n    dungeon::create_empty_room(&mut ecs_, 0.0, 8.0, 8, 10);\n    dungeon::delete_dungeon_entities(&mut ecs_, \n                                     gamestate::dungeon::DungeonElement::Wall,\n                                     LocationVec { x: 4.0, y: 7.0 });\n    dungeon::delete_dungeon_entities(&mut ecs_, \n                                     gamestate::dungeon::DungeonElement::Wall,\n                                     LocationVec { x: 4.0, y: 8.0 });\n    dungeon::create_attack_dummy(&mut ecs_, 3.0, 4.0);\n\n    \n    // player\n    let player = create_test_dummy_player(&mut ecs_);\n\n    render_conf.focused_entity = Some(player);\n\n    // END test code\n\n\t//Main loop\n\n    let mut events = Events::new(EventSettings::new());\n    events.set_ups(UPDATES_PER_SECOND);\n\n    let mut button_buffer: Option<Button> = None;\n\n    while let Some(e) = events.next(&mut window) {\n\n        if e.press_args().is_some() || button_buffer.is_some() {\n            debug!(\"{:?}\", &button_buffer);\n            if let Some(p) = e.press_args() {\n                button_buffer = input::handle_input(&p, &mut ecs_);\n            } else {\n                button_buffer = input::handle_input(&button_buffer.unwrap(), &mut ecs_);\n            }\n        }\n\n        if let Some(_) = e.update_args() {\n            gamelogic::update_entity_positions(&mut ecs_);\n        }\n\n        if let Some(r) = e.render_args() {\n            render_game(gl, &r, &mut ecs_, &sprite_textures, &render_conf);\n        }\n\n        gamelogic::check_and_perform_end_turn(&mut ecs_);\n\t}\n}", "item_id": 0, "repo": "hpkoehn/rustac", "file": "src/main.rs", "last_update_at": "2019-11-16T13:26:19+00:00"}
{"hexsha": "c0a7bc562db7822e47b08f91970f60b2fccf1dd1", "ext": "rs", "lang": "Rust", "content": "fn should_skip_char(input: char) -> bool {\n    // Ignore obsolete control characters, and tab characters we can't render\n    // properly anyways.  Also ignore newline characters since we don't\n    // support multi-line text at the moment.\n    input < '\\u{20}'\n    // Ignore delete character too\n    || input == '\\u{7F}'\n    // Unicode reserves some characters for \"private use\".  Systems emit\n    // these for no clear reason, so we're just going to ignore all of them.\n    || (input >= '\\u{E000}' && input <= '\\u{F8FF}')\n    || (input >= '\\u{F0000}' && input <= '\\u{FFFFF}')\n    || (input >= '\\u{100000}' && input <= '\\u{10FFFF}')\n}", "item_id": 2, "repo": "StarArawn/amethyst", "file": "amethyst_ui/src/text_editing.rs", "last_update_at": "2019-09-18T14:44:57+00:00"}
{"hexsha": "de8d796c472d95c1d39dd823d9b1acfd1afb5b94", "ext": "rs", "lang": "Rust", "content": "fn g_mpolygon_to_w_mpolygon(g_mpolygon: &geo_types::MultiPolygon<f64>) -> MultiPolygon {\n    let &geo_types::MultiPolygon(ref g_polygons) = g_mpolygon;\n    let w_polygons = g_polygons_to_w_polygons(g_polygons);\n    MultiPolygon(w_polygons)\n}", "item_id": 7, "repo": "CanalTP/rust-wkt", "file": "src/towkt.rs", "last_update_at": "2019-03-29T06:33:07+00:00"}
{"hexsha": "dab278eed03fd4d3bf6464ee142402771532d99d", "ext": "rs", "lang": "Rust", "content": "fn check_export_rsa_public_possible() -> Result<()> {\n    // Exporting a public key is always permitted\n    let mut client = TestClient::new();\n    let key_name = auto_test_keyname!();\n    if !client.is_operation_supported(Opcode::PsaExportPublicKey) {\n        return Ok(());\n    }\n    let mut usage_flags: UsageFlags = Default::default();\n    let _ = usage_flags.set_sign_hash();\n    let key_attributes = Attributes {\n        lifetime: Lifetime::Persistent,\n        key_type: Type::RsaKeyPair,\n        bits: 1024,\n        policy: Policy {\n            usage_flags,\n            permitted_algorithms: Algorithm::AsymmetricSignature(\n                AsymmetricSignature::RsaPkcs1v15Sign {\n                    hash_alg: Hash::Sha256.into(),\n                },\n            ),\n        },\n    };\n\n    client.generate_key(key_name.clone(), key_attributes)?;\n\n    let _public_key = client.export_public_key(key_name)?;\n\n    Ok(())\n}", "item_id": 7, "repo": "paulhowardarm/parsec", "file": "e2e_tests/tests/per_provider/normal_tests/export_public_key.rs", "last_update_at": "2019-05-28T00:14:41+00:00"}
{"hexsha": "41225c3fa3efc98a8ed4e49f32ad466e86bed2df", "ext": "rs", "lang": "Rust", "content": "fn sync(route: &api::Route, list: &List) -> Result<(), Error> {\n    let before = route\n        .actions\n        .iter()\n        .map(|action| extract(action, \"forward(\\\"\", \"\\\")\"))\n        .collect::<HashSet<_>>();\n    let after = list.members.iter().map(|s| &s[..]).collect::<HashSet<_>>();\n    if before == after {\n        return Ok(())\n    }\n\n    let mut form = Form::new();\n    for member in list.members.iter() {\n        form.part(\"action\").contents(format!(\"forward(\\\"{}\\\")\", member).as_bytes()).add()?;\n    }\n    put::<Empty>(&format!(\"/routes/{}\", route.id), form)?;\n\n    Ok(())\n}", "item_id": 3, "repo": "rust-lang/mailgun-mailmap", "file": "src/main.rs", "last_update_at": "2019-06-02T21:50:26+00:00"}
{"hexsha": "c45b0273ee0058edc6fcbfda651bb0552426749e", "ext": "rs", "lang": "Rust", "content": "pub fn eql(\n    interp: &Artichoke,\n    regexp: Value,\n    other: Value,\n) -> Result<Value, Box<dyn RubyException>> {\n    let regexp = unsafe { Regexp::try_from_ruby(interp, &regexp) }.map_err(|err| {\n        let err: Box<dyn RubyException> = if let ArtichokeError::UninitializedValue(\"Regexp\") = err\n        {\n            Box::new(TypeError::new(interp, \"uninitialized Regexp\"))\n        } else {\n            Box::new(Fatal::new(\n                interp,\n                \"Unable to extract Rust Regexp from Ruby Regexp receiver\",\n            ))\n        };\n        err\n    })?;\n    let borrow = regexp.borrow();\n    borrow.eql(interp, other)\n}", "item_id": 2, "repo": "zaccari/artichoke", "file": "artichoke-backend/src/extn/core/regexp/trampoline.rs", "last_update_at": "2019-12-04T11:52:24+00:00"}
{"hexsha": "6993c1ac0af8494846cba5d4624959d71ea7584c", "ext": "rs", "lang": "Rust", "content": "fn pollable_set_test() {\n        let mut runtime = tokio::runtime::Builder::new()\n            .basic_scheduler()\n            .build()\n            .unwrap();\n\n        let set = PollableSet::<u32>::new();\n        assert_eq!(0, set.items.read().len());\n        assert_eq!(0, set.len());\n\n        set.insert(6);\n        assert_eq!(1, set.items.read().len());\n        assert_eq!(1, set.len());\n\n        set.insert(4);\n        set.insert(8);\n        assert_eq!(3, set.items.read().len());\n        assert_eq!(3, set.len());\n\n        set.insert(10);\n        {\n            let odd_query = poll_fn(|cx| -> Poll<bool> {\n                match set.poll_take(cx, |x| x % 2 == 1) {\n                    Poll::Ready(_) => Poll::Ready(true),\n                    Poll::Pending => Poll::Ready(false),\n                }\n            });\n            let even_query = poll_fn(|cx| -> Poll<bool> {\n                match set.poll_take(cx, |x| x % 2 == 0) {\n                    Poll::Ready(_) => Poll::Ready(true),\n                    Poll::Pending => Poll::Ready(false),\n                }\n            });\n\n            // Wait for all the queries to complete\n            assert_eq!(runtime.block_on(odd_query), false);\n            assert_eq!(runtime.block_on(even_query), true);\n        }\n\n        // 3 (before the queries are created), 10 is inserted, and the query consumes one value.\n        assert_eq!(3, set.items.read().len());\n        assert_eq!(3, set.len());\n    }", "item_id": 0, "repo": "zrneely/wamp-proto", "file": "src/pollable.rs", "last_update_at": "2019-11-03T00:07:27+00:00"}
{"hexsha": "ccfe9f2f805a78b7b457b0d541aeee39263e803c", "ext": "rs", "lang": "Rust", "content": "fn wire_assign_01() {\n        let mut b = \"module test { wire a; a = a + 1'b1;}\".as_bytes();\n        let mut l = Lexer::new(&mut b);\n        let mut p = Parser::new(&mut l);\n\n        let wire = create_node!(ASTClass::Wire(vec![(\n            create_node!(ASTClass::Identifire(\"a\".to_string())),\n            None,\n        )]));\n\n        let expr = create_node!(ASTClass::Expression(\n            create_node!(ASTClass::Identifire(\"a\".to_string())),\n            create_node!(ASTClass::Operator(Operator::Plus)),\n            create_node!(ASTClass::Number(\"1'b1\".to_string())),\n        ));\n        let assign = create_node!(ASTClass::Assign(\n            create_node!(ASTClass::Identifire(\"a\".to_string())),\n            expr,\n        ));\n        let components = vec![wire, assign];\n        let module = create_node!(ASTClass::Module(\n            create_node!(ASTClass::Identifire(\"test\".to_string())),\n            create_node!(ASTClass::Block(components))\n        ));\n        assert_eq!(p.next_ast(), module);\n    }", "item_id": 56, "repo": "sux2mfgj/nslfmt", "file": "tests/parser.rs", "last_update_at": "2019-10-07T02:44:41+00:00"}
{"hexsha": "ec46d9919a51d054ee2df99349e9af08a5b0a658", "ext": "rs", "lang": "Rust", "content": "pub fn convert(mkdoc: &str) -> String {\n    let mut options = Options::empty();\n    options.insert(Options::ENABLE_STRIKETHROUGH);\n    options.insert(Options::ENABLE_FOOTNOTES);\n    options.insert(Options::ENABLE_TASKLISTS);\n    options.insert(Options::ENABLE_TABLES);\n    let parser = Parser::new_ext(mkdoc, options);\n\n    let mut htdoc = String::new();\n    html::push_html(&mut htdoc, parser);\n    htdoc\n}", "item_id": 1, "repo": "Teaonly/Teaonly.github.io", "file": "generator/src/blog.rs", "last_update_at": "2019-07-11T13:20:46+00:00"}
{"hexsha": "a037fa45bf34d8df074e2ce5b0fe164373bceaed", "ext": "rs", "lang": "Rust", "content": "fn should_list_attacks() {\n    let client = ShieldClient::simple(Region::UsEast1);\n    let request = ListAttacksRequest::default();\n\n    let result = client.list_attacks(&request).sync().unwrap();\n    println!(\"{:#?}\", result);\n}", "item_id": 0, "repo": "tureus/rusoto", "file": "integration_tests/tests/shield.rs", "last_update_at": "2019-10-22T03:13:55+00:00"}
{"hexsha": "5a62b9a46fc40ca7c1d02d99ad7085dd94fff29c", "ext": "rs", "lang": "Rust", "content": "fn moves_sprites() {\n    let mut tia = Tia::new();\n    tia.write(registers::COLUBK, 0x00).unwrap();\n    tia.write(registers::COLUP0, 0x02).unwrap();\n    tia.write(registers::COLUP1, 0x04).unwrap();\n    tia.write(registers::COLUPF, 0x06).unwrap();\n    tia.write(registers::GRP0, 0b1100_0011).unwrap();\n    tia.write(registers::GRP1, 0b1100_0011).unwrap();\n    tia.write(registers::ENAM0, flags::ENAXX_ENABLE).unwrap();\n    tia.write(registers::ENAM1, flags::ENAXX_ENABLE).unwrap();\n    tia.write(registers::ENABL, flags::ENAXX_ENABLE).unwrap();\n    tia.write(registers::HMP0, 3 << 4).unwrap();\n    tia.write(registers::HMP1, (-5i8 << 4) as u8).unwrap();\n    tia.write(registers::HMM0, (-6i8 << 4) as u8).unwrap();\n    tia.write(registers::HMM1, 4 << 4 as u8).unwrap();\n    tia.write(registers::HMBL, (-1i8 << 4) as u8).unwrap();\n\n    let p0_delay = 32 * 3;\n    let p1_delay = 6 * 3;\n    let m0_delay = 9 * 3;\n    let m1_delay = 2 * 3;\n    let ball_delay = 3 * 3;\n    wait_ticks(&mut tia, p0_delay);\n    tia.write(registers::RESP0, 0).unwrap();\n    wait_ticks(&mut tia, p1_delay);\n    tia.write(registers::RESP1, 0).unwrap();\n    wait_ticks(&mut tia, m0_delay);\n    tia.write(registers::RESM0, 0).unwrap();\n    wait_ticks(&mut tia, m1_delay);\n    tia.write(registers::RESM1, 0).unwrap();\n    wait_ticks(&mut tia, ball_delay);\n    tia.write(registers::RESBL, 0).unwrap();\n    wait_ticks(\n        &mut tia,\n        TOTAL_WIDTH - p0_delay - p1_delay - m0_delay - m1_delay - ball_delay,\n    );\n\n    // Pretend we're doing an STA: wait for 2 CPU cycles, write to register\n    // on the 3rd one.\n    let mut scanline = scan_video(&mut tia, 2 * 3 + 1);\n    tia.write(registers::HMOVE, 0).unwrap();\n    scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));\n\n    assert_eq!(\n        encode_video_outputs(scanline),\n        \"................||||||||||||||||....................................\\\n         ........000000000000000000000000220000220000000000000000004400004400000000000000\\\n         04000200000000060000000000000000000000000000000000000000000000000000000000000000\",\n    );\n\n    // Do the same once again, and then clear the movement registers before\n    // HMOVE on the 3rd line. The 3rd line should look exactly as the 2nd\n    // one.\n    let mut scanline = scan_video(&mut tia, 2 * 3 + 1);\n    tia.write(registers::HMOVE, 0).unwrap();\n    scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));\n    tia.write(registers::HMCLR, 0).unwrap();\n    scanline.append(&mut scan_video(&mut tia, 2 * 3 + 1));\n    tia.write(registers::HMOVE, 0).unwrap();\n    scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));\n\n    assert_eq!(\n        encode_video_outputs(scanline),\n        \"................||||||||||||||||....................................\\\n         ........000000000000000000000220000220000000000000000000000000044000044000000400\\\n         00000000000200006000000000000000000000000000000000000000000000000000000000000000\\\n         ................||||||||||||||||....................................\\\n         ........000000000000000000000220000220000000000000000000000000044000044000000400\\\n         00000000000200006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n\n    // Test RESMPx: make sure the missiles move along with players and stop\n    // following them once they are freed.\n    tia.write(registers::RESMP0, flags::RESMPX_RESET).unwrap();\n    assert_eq!(\n        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),\n        \"................||||||||||||||||....................................\\\n         00000000000000000000000000000220000220000000000000000000000000044000044000000400\\\n         00000000000000006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n\n    tia.write(registers::RESMP1, flags::RESMPX_RESET).unwrap();\n    assert_eq!(\n        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),\n        \"................||||||||||||||||....................................\\\n         00000000000000000000000000000220000220000000000000000000000000044000044000000000\\\n         00000000000000006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n\n    tia.write(registers::RESMP0, 0).unwrap();\n    assert_eq!(\n        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),\n        \"................||||||||||||||||....................................\\\n         00000000000000000000000000000220020220000000000000000000000000044000044000000000\\\n         00000000000000006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n    tia.write(registers::RESMP1, 0).unwrap();\n    assert_eq!(\n        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),\n        \"................||||||||||||||||....................................\\\n         00000000000000000000000000000220020220000000000000000000000000044004044000000000\\\n         00000000000000006000000000000000000000000000000000000000000000000000000000000000\",\n    );\n}", "item_id": 12, "repo": "technomaniak/atari-emulator", "file": "atari2600/src/tia/tests.rs", "last_update_at": "2019-08-16T09:49:50+00:00"}
{"hexsha": "ede8b8f9c2808f2f605471faa9ab0f2e263c0969", "ext": "rs", "lang": "Rust", "content": "fn parse_use4() {\n    let input = \"use\";\n    let expected_output = IResult::Incomplete(Needed::Unknown);\n\n    let result = parse_use(input);\n\n    assert_eq!(result, expected_output);\n}", "item_id": 3, "repo": "willi-kappler/comment_units", "file": "src/fortran/tests/parse_use.rs", "last_update_at": "2019-06-06T11:14:46+00:00"}
{"hexsha": "81db081b951c3b37e1dcc178b4dfa17e5e178be5", "ext": "rs", "lang": "Rust", "content": "fn clean_release() {\n    let p = project()\n        .file(\n            \"Cargo.toml\",\n            r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.0.1\"\n            authors = []\n\n            [dependencies]\n            a = { path = \"a\" }\n        \"#,\n        )\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .file(\"a/Cargo.toml\", &basic_manifest(\"a\", \"0.0.1\"))\n        .file(\"a/src/lib.rs\", \"\")\n        .build();\n\n    p.cargo(\"build --release\").run();\n\n    p.cargo(\"clean -p foo\").run();\n    p.cargo(\"build --release\").with_stdout(\"\").run();\n\n    p.cargo(\"clean -p foo --release\").run();\n    p.cargo(\"build --release\")\n        .with_stderr(\n            \"\\\n[COMPILING] foo v0.0.1 ([..])\n[FINISHED] release [optimized] target(s) in [..]\n\",\n        )\n        .run();\n\n    p.cargo(\"build\").run();\n\n    p.cargo(\"clean\").arg(\"--release\").run();\n    assert!(p.build_dir().is_dir());\n    assert!(p.build_dir().join(\"debug\").is_dir());\n    assert!(!p.build_dir().join(\"release\").is_dir());\n}", "item_id": 3, "repo": "lizh06/cargo", "file": "tests/testsuite/clean.rs", "last_update_at": "2019-02-05T07:19:42+00:00"}
{"hexsha": "6412366c01d9d1fcc0f260d34b639412ea8704fc", "ext": "rs", "lang": "Rust", "content": "pub async fn set_phone_number(req: String) -> HttpResponse {\n    let clean_string = clean_quotes(&req);\n    trace!(\"Got number {:?}\", clean_string);\n    let phone_number: PhoneNumber = match clean_string.parse() {\n        Ok(p) => p,\n        Err(e) => {\n            info!(\"Failed to parse phonenumber with {:?}\", e);\n            return HttpResponse::BadRequest().finish();\n        }\n    };\n\n    let mut rita_client = settings::get_rita_client();\n\n    // merge the new value into the existing struct, for the various possibilities\n    let res = match option_convert(rita_client.exit_client.contact_info.clone()) {\n        Some(ContactType::Phone {\n            number: _,\n            sequence_number,\n        }) => Some(ContactType::Phone {\n            number: phone_number,\n            sequence_number: Some(add_to_sequence(sequence_number)),\n        }),\n        Some(ContactType::Email {\n            email,\n            sequence_number,\n        }) => Some(ContactType::Both {\n            number: phone_number,\n            email,\n            sequence_number: Some(add_to_sequence(sequence_number)),\n        }),\n        Some(ContactType::Both {\n            number: _number,\n            email,\n            sequence_number,\n        }) => Some(ContactType::Both {\n            number: phone_number,\n            email,\n            sequence_number: Some(add_to_sequence(sequence_number)),\n        }),\n        Some(ContactType::Bad {\n            invalid_number: _,\n            invalid_email: _,\n            sequence_number,\n        }) => Some(ContactType::Phone {\n            number: phone_number,\n            sequence_number: Some(add_to_sequence(sequence_number)),\n        }),\n        None => Some(ContactType::Phone {\n            number: phone_number,\n            sequence_number: Some(0),\n        }),\n    };\n    rita_client.exit_client.contact_info = option_convert(res);\n\n    settings::set_rita_client(rita_client);\n\n    // save immediately\n    if let Err(_e) = settings::write_config() {\n        return HttpResponse::InternalServerError().finish();\n    }\n\n    HttpResponse::Ok().finish()\n}", "item_id": 0, "repo": "althea-mesh/althea_rs", "file": "rita_client/src/dashboard/contact_info.rs", "last_update_at": "2019-06-10T17:42:00+00:00"}
{"hexsha": "e3d4833798277cb9b8a9a72fafc2aee5e3bb035c", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<()> {\n    // appeneds \"___\\n\" after every line\n    let editor = linurgy::factory::appender(\"___\\n\", 1);\n\n    // create a buffered reader over stdin\n    let mut input = BufReader::new(stdin());\n\n    // `edit_buffered` returns an io::Result\n    // in a simple program like this, we can pass stdout directly\n    editor.edit_buffered(&mut input, &mut stdout())?;\n\n    Ok(())\n}", "item_id": 0, "repo": "sonro/linurgy", "file": "examples/buffered-stdio.rs", "last_update_at": "2019-07-31T16:37:40+00:00"}
{"hexsha": "592650d55ab075e7500b3d4a644155b35081988e", "ext": "rs", "lang": "Rust", "content": "fn node_remove_next() {\n    let mut node: Node<&str> = Node::new(\"one\");\n    node.insert_after(Box::new(Node::new(\"two\")));\n    node.remove_after();\n}", "item_id": 3, "repo": "jonalmeida/algorithms.rs", "file": "src/datastructures/linkedlist.rs", "last_update_at": "2019-07-01T06:45:01+00:00"}
{"hexsha": "3e6bd45234983a3e9b2e01a3c4914abacbeade6a", "ext": "rs", "lang": "Rust", "content": "pub fn _68(c: &mut Context, b: &mut Bus) {\n    // Increment S\n    c.step(b);\n    c.s = c.s.wrapping_add(1);\n\n    // Pull register from stack\n    c.step(b);\n    c.a = b.read(0x100 + c.s as u16);\n\n    c.p.set(cpu::ZERO, c.a == 0);\n    c.p.set(cpu::SIGN, c.a & 0x80 != 0);\n}", "item_id": 13, "repo": "mehcode/lintel-nes", "file": "src/cpu/op.rs", "last_update_at": "2019-03-17T11:26:30+00:00"}
{"hexsha": "3deac005077f7c70c346c676b2f9596a2b4440d9", "ext": "rs", "lang": "Rust", "content": "fn test_single_row_insert() {\n        let expected = expected_values(\"INSERT INTO \\\"users\\\" (\\\"foo\\\") VALUES ($1)\", vec![10]);\n        let query = Insert::single_into(\"users\").value(\"foo\", 10);\n        let (sql, params) = Postgres::build(query).unwrap();\n\n        assert_eq!(expected.0, sql);\n        assert_eq!(expected.1, params);\n    }", "item_id": 2, "repo": "prisma/prisma-query", "file": "src/visitor/postgres.rs", "last_update_at": "2019-11-02T17:23:18+00:00"}
{"hexsha": "299ec8d08f451f1a3aad65b243a34e49c04917f5", "ext": "rs", "lang": "Rust", "content": "fn test_transaction() {\n        let hex_tx = hex_bytes(\"0400008085202f8901e9f7b47c2a612e30a6e2cae39e1d4763901fedd076e9450c5df0f0d087d25\\\n                    e45010000006b483045022100a4553c79e56d119c50c73055d4e6d6a4f8faa2e257a6762c8f9e2758f208d774022\\\n                    0250257e51bbeb50ecd8e27b65d976b5108c3bf62ead19984a6377963bcdfd3de012103804a8e414c7c541d7a0720\\\n                    de5330e1fc51a696286b1523051286058ee9e724c3feffffff02650400000000000017a91466db59c466b84e64eda\\\n                    5db42cc48c5c8fc927cd4871148e111000000001976a914060277e4e1c2ab568d17ba769dcfc489a9c973a088ac09\\\n                    8b0400288b04000000000000000000000000\").unwrap();\n        let tx: Result<Transaction, _> = deserialize(&hex_tx);\n        assert!(tx.is_ok());\n        let realtx = tx.unwrap();\n        // All these tests aren't really needed because if they fail, the hash check at the end\n        // will also fail. But these will show you where the failure is so I'll leave them in.\n        assert_eq!(realtx.header, TxHeader::FourthAndOverwintered);\n        assert_eq!(realtx.version_group_id, 0x892F2085);\n        assert_eq!(realtx.input.len(), 1);\n        assert_eq!(realtx.output.len(), 2);\n        assert_eq!(realtx.lock_time, 297737);\n        assert_eq!(realtx.expiry_height, 297768);\n        assert_eq!(realtx.join_split.len(), 0);\n        assert_eq!(realtx.shielded_output.len(), 0);\n        assert_eq!(realtx.shielded_spend.len(), 0);\n        assert_eq!(realtx.binding_sig, None);\n        assert_eq!(realtx.join_split_pubkey, None);\n        assert_eq!(realtx.join_split_sig, None);\n    }", "item_id": 0, "repo": "rndintec/rust-bitcoin", "file": "src/blockdata/transaction.rs", "last_update_at": "2019-10-17T03:53:15+00:00"}
{"hexsha": "aca57c29143659cbac6350849918fd439a686969", "ext": "rs", "lang": "Rust", "content": "async fn main() {\n    env_logger::init();\n\n    let opts = Opt::parse();\n\n    let index_html_s = tokio::fs::read_to_string(opts.dir.join(\"index.html\"))\n        .await\n        .expect(\"failed to read index.html\");\n\n    let handle_error = |e| async move {\n        (\n            StatusCode::INTERNAL_SERVER_ERROR,\n            format!(\"error occurred: {}\", e),\n        )\n    };\n\n    let app = Router::new()\n        .route(\"/api/test\", get(|| async move { \"Hello World\" }))\n        // needed because https://github.com/tower-rs/tower-http/issues/262\n        .route(\"/\", get(render))\n        .fallback(HandleError::new(\n            ServeDir::new(opts.dir)\n                .append_index_html_on_directories(false)\n                .fallback(\n                    render\n                        .layer(Extension(index_html_s))\n                        .into_service()\n                        .map_err(|err| -> std::io::Error { match err {} }),\n                ),\n            handle_error,\n        ));\n\n    println!(\"You can view the website at: http://localhost:8080/\");\n\n    axum::Server::bind(&\"0.0.0.0:8080\".parse().unwrap())\n        .serve(app.into_make_service())\n        .await\n        .unwrap();\n}", "item_id": 1, "repo": "lostinspiration/yew", "file": "examples/ssr_router/src/bin/ssr_router_server.rs", "last_update_at": "2019-08-04T03:56:11+00:00"}
{"hexsha": "f8a18e866d4e60df133607ac744341aa1bf12e57", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let matches = App::new(\"TezEdge Protocol Runner\")\n        .version(env!(\"CARGO_PKG_VERSION\"))\n        .author(\"TezEdge and the project contributors\")\n        .about(\"Tezos Protocol Runner\")\n        .arg(\n            Arg::with_name(\"socket-path\")\n                .short(\"c\")\n                .long(\"socket-path\")\n                .value_name(\"path\")\n                .help(\"Path to a command socket\")\n                .takes_value(true)\n                .empty_values(false)\n                .required(true),\n        )\n        .arg(\n            Arg::with_name(\"endpoint\")\n                .long(\"endpoint\")\n                .value_name(\"STRING\")\n                .help(\"Name of the endpoint, which spawned runner\")\n                .takes_value(true)\n                .empty_values(false)\n                .required(true),\n        )\n        .arg(\n            Arg::with_name(\"log-level\")\n                .long(\"log-level\")\n                .takes_value(true)\n                .value_name(\"LEVEL\")\n                .possible_values(&[\"critical\", \"error\", \"warn\", \"info\", \"debug\", \"trace\"])\n                .help(\"Set log level\"),\n        )\n        .get_matches();\n\n    let cmd_socket_path = matches\n        .value_of(\"socket-path\")\n        .expect(\"Missing socket-path value\");\n    let endpoint_name = matches\n        .value_of(\"endpoint\")\n        .expect(\"Missing endpoint value\")\n        .to_string();\n    let log_level = matches\n        .value_of(\"log-level\")\n        .unwrap_or(\"info\")\n        .parse::<slog::Level>()\n        .expect(\"Was expecting one value from slog::Level\");\n\n    let log = create_logger(log_level, endpoint_name);\n\n    let shutdown_callback = |log: &Logger| {\n        debug!(log, \"Shutting down OCaml runtime\");\n        match std::panic::catch_unwind(|| {\n            tezos_interop::shutdown();\n        }) {\n            Ok(_) => debug!(log, \"OCaml runtime shutdown was successful\"),\n            Err(e) => {\n                warn!(log, \"Shutting down OCaml runtime failed (check running sub-process for this endpoint or `[protocol-runner] <defunct>`, and and terminate/kill manually)!\"; \"reason\" => format!(\"{:?}\", e))\n            }\n        }\n    };\n\n    {\n        let log = log.clone();\n        // do nothing and wait for parent process to send termination command\n        // this is just fallback, if ProtocolController.shutdown will fail or if we need to kill sub-process manually\n        ctrlc::set_handler(move || {\n            shutdown_callback(&log);\n            warn!(log, \"Protocol runner was terminated/killed/ctrl-c - please, check running sub-processes for `[protocol-runner] <defunct>`, and terminate/kill manually!\");\n        }).expect(\"Error setting Ctrl-C handler\");\n    }\n\n    #[cfg(dyncov)]\n    dyncov::initialize_callbacks();\n\n    match tezos_interop::start_ipc_loop(cmd_socket_path.into()) {\n        Err(OCamlBlockPanic) => warn!(log, \"Protocol runner loop exited with a panic\"),\n        Ok(Err(trace)) => warn!(log, \"Protocol runner loop exited with error: {:?}\", trace),\n        Ok(Ok(code)) => info!(\n            log,\n            \"Protocol runner exited with internal exit code = {}\", code\n        ),\n    }\n\n    shutdown_callback(&log);\n\n    info!(log, \"Protocol runner finished gracefully\");\n}", "item_id": 0, "repo": "simplestaking/tezos-rs", "file": "protocol_runner/src/main.rs", "last_update_at": "2019-10-25T18:40:15+00:00"}
{"hexsha": "8be196cd7b12228b079f482931760d8c91b265a9", "ext": "rs", "lang": "Rust", "content": "pub fn update_handler(request: &mut Request) -> IronResult<Response> {\n    // get param id\n    let id = request.extensions.get::<Router>().unwrap().find(\"id\").unwrap().to_owned();\n    \n    // get the body\n    let body_option = itry!(request.get::<bodyparser::Raw>(), status::BadRequest);\n    let raw_body = iexpect!(body_option, status::BadRequest);\n    let todo_partial = itry!(serde_json::from_str(&raw_body), status::BadRequest);\n\n    let mutex = request.get::<State<TodoItems>>().unwrap();\n    let mut todo_items = mutex.write().unwrap();\n\n    // find item (as mutable)\n    let item_option = todo_items.iter_mut().find(|item| item.get_id() == id);\n    let mut item = iexpect!(item_option, status::NotFound);\n\n    item.update(todo_partial);\n\n    Ok(Response::with((status::Ok, format!(\"{{\\\"id\\\": \\\"{}\\\"}}\", item.get_id()))))\n}", "item_id": 2, "repo": "lofim/rust-todo-backend", "file": "src/controller.rs", "last_update_at": "2019-06-10T11:29:24+00:00"}
{"hexsha": "6c6b7709d25131232741c5b45dd3d3a10fea5786", "ext": "rs", "lang": "Rust", "content": "fn parse_goodbye(msg: &[Value]) -> Result<rx::Goodbye, MessageParseError> {\n    if msg.len() != 2 {\n        warn!(\"Bad GOODBYE message length: {}\", msg.len());\n        return Err(MessageParseError::BadMessageLength);\n    }\n\n    let details = helpers::parse_details(&msg[0])?;\n    let reason = helpers::parse_uri(&msg[1])?;\n\n    let goodbye = rx::Goodbye { details, reason };\n    trace!(\"Received GOODBYE message: {:?}\", goodbye);\n    Ok(goodbye)\n}", "item_id": 9, "repo": "zrneely/wamp-proto", "file": "src/transport/websocket/parsers.rs", "last_update_at": "2019-11-03T00:07:27+00:00"}
{"hexsha": "814cbcc022d08652f6da9219c91e0c8da2a81337", "ext": "rs", "lang": "Rust", "content": "fn binding_to_unimplemented_apis_doesnt_break_everything() {\n    let array = Array::new();\n    let res = array.standardized_method_this_js_runtime_doesnt_implement_yet();\n    assert!(res.is_err());\n}", "item_id": 0, "repo": "not-an-aardvark/wasm-bindgen", "file": "tests/wasm/simple.rs", "last_update_at": "2019-10-15T03:00:51+00:00"}
{"hexsha": "3deac005077f7c70c346c676b2f9596a2b4440d9", "ext": "rs", "lang": "Rust", "content": "fn join_is_inserted_positionally() {\n        let joined_table = Table::from(\"User\").left_join(\n            \"Post\"\n                .alias(\"p\")\n                .on((\"p\", \"userId\").equals(Column::from((\"User\", \"id\")))),\n        );\n        let q = Select::from_table(joined_table).and_from(\"Toto\");\n        let (sql, _) = Postgres::build(q).unwrap();\n\n        assert_eq!(\"SELECT \\\"User\\\".*, \\\"Toto\\\".* FROM \\\"User\\\" LEFT JOIN \\\"Post\\\" AS \\\"p\\\" ON \\\"p\\\".\\\"userId\\\" = \\\"User\\\".\\\"id\\\", \\\"Toto\\\"\", sql);\n    }", "item_id": 34, "repo": "prisma/prisma-query", "file": "src/visitor/postgres.rs", "last_update_at": "2019-11-02T17:23:18+00:00"}
{"hexsha": "d3498df38a6f786e322e2eae2e457e06ee9b7226", "ext": "rs", "lang": "Rust", "content": "pub fn with_prof_context<T, F: FnOnce()->T>(s: &str, f: F) -> T {\n    set_prof_context(s);\n    let res = f();\n    set_prof_context(\"\");\n    res\n}", "item_id": 0, "repo": "remysucre/differential-datalog", "file": "rust/template/differential_datalog/profile.rs", "last_update_at": "2019-07-04T00:43:39+00:00"}
{"hexsha": "fe10072128c762a21040b34bde45feaa361b5dbc", "ext": "rs", "lang": "Rust", "content": "fn unbalanced_at(graph: &Graph<Node, ()>, node: NodeIndex) -> Option<(NodeIndex, usize)> {\n    let mut dfs = Dfs::new(&graph, node);\n    while let Some(nx) = dfs.next(&graph) {\n        let mut expected_weight = None;\n        for neighbor in graph.neighbors_directed(nx, Outgoing) {\n            let neighbor_weight = weight_for_node(&graph, neighbor);\n            if expected_weight.is_none() {\n                expected_weight = Some(neighbor_weight);\n            }\n            if neighbor_weight != expected_weight.unwrap() {\n                return Some((neighbor, expected_weight.unwrap()));\n            }\n        }\n    }\n    None\n}", "item_id": 4, "repo": "Mark-Simulacrum/advent-of-code", "file": "src/bin/y2017/day07.rs", "last_update_at": "2019-04-05T21:56:09+00:00"}
{"hexsha": "b683a9bc0cbf1f4c4272cab9f93c985ad6eb9290", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn handle_cursor_motion(mut listener: *mut wl_listener,\n                                          mut data: *mut libc::c_void) {\n    let mut sample: *mut sample_state =\n        (listener as *mut libc::c_char).offset(-168) as *mut sample_state;\n    let mut event: *mut wlr_event_pointer_motion =\n        data as *mut wlr_event_pointer_motion;\n    wlr_cursor_move((*sample).cursor, (*event).device, (*event).delta_x,\n                    (*event).delta_y);\n}", "item_id": 2, "repo": "RoastVeg/wlrusts", "file": "src/examples/pointer.rs", "last_update_at": "2019-12-10T16:29:26+00:00"}
{"hexsha": "f648d923a7db5cc7b0d38b1fc342933334116d2d", "ext": "rs", "lang": "Rust", "content": "pub fn get_row(mut row_index: i32) -> Vec<i32> {\n    row_index += 1;\n    if row_index == 1 {\n        return vec![1];\n    }\n    let mut res = vec![1];\n    let row_index = row_index as usize;\n    for i in 1..row_index {\n        for j in (1..=i).rev() {\n            if j == i {\n                res.push(1);\n            } else {\n                let sum = res[j - 1] + res[j];\n                res[j] = sum;\n            }\n        }\n    }\n\n    res\n}", "item_id": 0, "repo": "yjhmelody/leetcode-rust", "file": "src/pascal_triangle_2.rs", "last_update_at": "2019-06-05T06:51:56+00:00"}
{"hexsha": "3b302192db72a36180e84949f0e32c0ba23d8d6a", "ext": "rs", "lang": "Rust", "content": "fn fontgen_should_reject_padding_larger_than_slot_glyph_size() -> Result<(), Box<std::error::Error>> {\n    let mut cmd = Command::cargo_bin(\"fontgen\")?;\n    cmd.arg(\"--input\")\n        .arg(\"assets/FreeMono.ttf\")\n        .arg(\"--output\")\n        .arg(\"FreeMono.bmfa\")\n        .arg(\"--padding\")\n        .arg(\"129\")\n        .arg(\"--slot-glyph-size\")\n        .arg(\"128\");\n    cmd.assert().failure();\n\n    Ok(())\n}", "item_id": 2, "repo": "lambdaxymox/fontgen", "file": "tests/fontgen.rs", "last_update_at": "2019-05-08T14:51:01+00:00"}
{"hexsha": "53d4becce91a846b8e0d0f880bb3593ffb82e915", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn wlr_surface_send_leave(mut surface: *mut wlr_surface,\n                                                mut output: *mut wlr_output) {\n    let mut client: *mut wl_client =\n        wl_resource_get_client((*surface).resource);\n    let mut resource: *mut wl_resource = 0 as *mut wl_resource;\n    resource = 0 as *mut wl_resource;\n    resource = wl_resource_from_link((*output).resources.next);\n    while wl_resource_get_link(resource) !=\n              &mut (*output).resources as *mut wl_list {\n        if client == wl_resource_get_client(resource) {\n            wl_surface_send_leave((*surface).resource, resource);\n        }\n        resource =\n            wl_resource_from_link((*wl_resource_get_link(resource)).next)\n    };\n}", "item_id": 43, "repo": "RoastVeg/wlrusts", "file": "src/types/wlr_surface.rs", "last_update_at": "2019-12-10T16:29:26+00:00"}
{"hexsha": "8abc642a1a9e173471919c37ded33ce7410c8640", "ext": "rs", "lang": "Rust", "content": "fn add_team_as_non_member() {\n    let (app, _) = TestApp::with_proxy().empty();\n    let user = app.db_new_user(mock_user_on_only_one_team().gh_login);\n    let token = user.db_new_token(\"arbitrary token name\");\n\n    app.db(|conn| {\n        CrateBuilder::new(\"foo_team_non_member\", user.as_model().id).expect_build(conn);\n    });\n\n    let json = token\n        .add_named_owner(\n            \"foo_team_non_member\",\n            \"github:crates-test-org:just-for-crates-2\",\n        )\n        .bad_with_status(200);\n\n    assert!(\n        json.errors[0]\n            .detail\n            .contains(\"only members of a team can add it as an owner\"),\n        \"{:?}\",\n        json.errors\n    );\n}", "item_id": 5, "repo": "FreeMasen/crates.io", "file": "src/tests/team.rs", "last_update_at": "2019-04-28T19:41:26+00:00"}
{"hexsha": "9cc9e61b1b2da25cbe78ae25641c848b7e3bd037", "ext": "rs", "lang": "Rust", "content": "fn logout(client: &mut Client) -> Result<(), Error> {\n    println!(\"Logging out...\");\n\n    let logout_res = match client.logout() {\n        Ok(t) => t,\n        Err(e) => {\n            let msg = format!(\"Failed to run logout: {}\", e);\n            return Err(Error::Custom(msg));\n        }\n    };\n\n    if logout_res.is_not_success() {\n        let msg = format!(\"Failed to logout: {}\", logout_res.data[\"message\"]);\n        return Err(Error::Custom(msg));\n    }\n\n    Ok(())\n}", "item_id": 6, "repo": "seiruss/cp_api", "file": "examples/unused_objects.rs", "last_update_at": "2019-03-10T05:15:50+00:00"}
{"hexsha": "7c00465375714126de0fd6af657926f61181f564", "ext": "rs", "lang": "Rust", "content": "fn test_parse_value_param() {\n        let v: Value = json!({ \"confirmations\": 10 });\n\n        let confirmations = v\n            .get(\"confirmations\")\n            .and_then(|el| el.as_u64())\n            .ok_or(HttpError::from(\n                \"confirmations absent or not a u64\".to_string(),\n            ))\n            .unwrap();\n\n        assert_eq!(10, confirmations);\n\n        let err = v\n            .get(\"notexist\")\n            .and_then(|el| el.as_u64())\n            .ok_or(HttpError::from(\"notexist absent or not a u64\".to_string()));\n\n        assert!(err.is_err());\n    }", "item_id": 7, "repo": "dogecash/electrs-dogecash", "file": "src/rest.rs", "last_update_at": "2019-03-04T09:08:35+00:00"}
{"hexsha": "c9b0c98eaee246e494403e5118411b99fae85574", "ext": "rs", "lang": "Rust", "content": "fn run() -> std::result::Result<(), Box<dyn std::error::Error>> {\n    let mut manager = dbus_bluez::BluezManager::new()?;\n    let cmd_opts = CmdOpts::from_args();\n\n    manager.start_discovery(Some(4000))?;\n\n    match cmd_opts.cmd {\n        cmd_opts::Command::Scan { duration_sec } => scan(&mut manager, &cmd_opts, duration_sec)?,\n        cmd_opts::Command::Read { ref addr } => read(&mut manager, &cmd_opts, addr)?,\n        cmd_opts::Command::Blink { ref addr } => blink(&mut manager, &cmd_opts, addr)?,\n        cmd_opts::Command::History { ref addr, from, to, page, clear } => history(&mut manager, &cmd_opts, addr, from, to, page, clear)?,\n        cmd_opts::Command::HistoryCount { ref addr } => history_count(&mut manager, &cmd_opts, addr)?,\n        cmd_opts::Command::HistoryClear { ref addr } => clear_history(&mut manager, &cmd_opts, addr)?,\n    }\n\n    Ok(())\n}", "item_id": 6, "repo": "dennis/hat", "file": "hat-miflora/src/main.rs", "last_update_at": "2019-05-11T00:28:18+00:00"}
{"hexsha": "c3c329bb1e4cac9189079e337c9f390bdb7e218d", "ext": "rs", "lang": "Rust", "content": "fn test_codec_datetime() -> Result<()> {\n        let cases = vec![\n            (\"2010-10-10 10:11:11\", 0),\n            (\"2017-01-01 00:00:00\", 0),\n            (\"2004-01-01 00:00:00\", UNSPECIFIED_FSP),\n            (\"2013-01-01 00:00:00.000000\", MAX_FSP),\n            (\"2019-01-01 00:00:00.123456\", MAX_FSP),\n            (\"2001-01-01 00:00:00.123456\", MAX_FSP),\n            (\"2007-06-01 00:00:00.999999\", MAX_FSP),\n            // Invalid cases\n            (\"0000-00-00 00:00:00\", 0),\n            (\"2007-00-01 00:00:00.999999\", MAX_FSP),\n            (\"2017-01-00 00:00:00.999999\", MAX_FSP),\n            (\"2027-00-00 00:00:00.999999\", MAX_FSP),\n            (\"2027-04-31 00:00:00.999999\", MAX_FSP),\n        ];\n\n        for (case, fsp) in cases {\n            let mut ctx = EvalContext::from(TimeEnv {\n                allow_invalid_date: true,\n                ..TimeEnv::default()\n            });\n            let time = Time::parse_datetime(&mut ctx, case, fsp, false)?;\n\n            let packed = time.to_packed_u64(&mut ctx)?;\n            let reverted_datetime =\n                Time::from_packed_u64(&mut ctx, packed, TimeType::DateTime, fsp)?;\n\n            assert_eq!(time, reverted_datetime);\n        }\n\n        Ok(())\n    }", "item_id": 24, "repo": "andylokandy/tikv", "file": "components/tidb_query/src/codec/mysql/time/mod.rs", "last_update_at": "2019-06-20T15:45:53+00:00"}
{"hexsha": "76795363af213f8e4b2960b268e373b6e81cb00a", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn xed_decoded_inst_set_mode(\n    mut p: *mut xed_decoded_inst_t,\n    mut mmode: xed_machine_mode_enum_t,\n    mut stack_addr_width: xed_address_width_enum_t,\n) {\n    let mut dstate: xed_state_t = xed_state_t {\n        mmode: XED_MACHINE_MODE_INVALID,\n        stack_addr_width: XED_ADDRESS_WIDTH_INVALID,\n    };\n    dstate.mmode = mmode;\n    dstate.stack_addr_width = stack_addr_width;\n    xed_operand_values_set_mode(p, &mut dstate);\n}", "item_id": 27, "repo": "khuey/xed-sys", "file": "src/xed-c2rust.rs", "last_update_at": "2019-11-22T22:35:46+00:00"}
{"hexsha": "ffd517b59b213f7b78c006298fc3e011b14b4049", "ext": "rs", "lang": "Rust", "content": "fn read_i16bit_wav_file_test() { // Test based on Hound's tests\n        let wav_handler = WavHandler::new(\"testsamples/pcmwaveformat-16bit-44100Hz-mono.wav\").unwrap();\n        let file_data = vec![2i16, -3i16, 5i16, -7i16];\n        let file_data_f32_conversion: Vec<f32> = file_data.iter()\n                                                          .map(|x| (*x as f32) * (1f32 / (i16::MAX as f32 + 1f32)))\n                                                          .collect();\n\n        assert_eq!(file_data_f32_conversion, wav_handler.audio_data);\n    }", "item_id": 2, "repo": "fogodev/dictawav-rs", "file": "src/dictawav/wav_handler.rs", "last_update_at": "2019-04-21T19:44:32+00:00"}
{"hexsha": "2eaf2c14dfb2018537ae64b44361084e80ffd3ca", "ext": "rs", "lang": "Rust", "content": "fn rpc_find_where_spent(client: &mut Client, outpoint: &OutPoint) -> Result<Transaction, jsonrpc::Error> {\n    let request = client\n        .build_request(\"getbestblockhash\".to_string(), vec![]);\n\n    let mut block_hash = String::from(\"\");\n\n    client.send_request(&request).and_then(|res| {\n        block_hash = String::from(res.result.unwrap().string().unwrap());\n\n        Ok(())\n    });\n\n    let mut tx: Option<Transaction> = None;\n\n    while tx.is_none() {\n        let request = client\n            .build_request(\"getblock\".to_string(), vec![Json::from_serialize(block_hash.to_string()).unwrap(), Json::from_serialize(0).unwrap()]);\n\n        client.send_request(&request).and_then(|res| {\n            let block: Result<Block, bitcoin::network::serialize::Error> = bitcoin::network::serialize::deserialize(&mut hex_to_bytes(String::from(res.result.unwrap().string().unwrap())));\n            let block = block.unwrap();\n\n            for this_tx in &block.txdata {\n                for vin in &this_tx.input {\n                    if vin.previous_output == *outpoint {\n                        tx = Some(this_tx.clone());\n\n                        break;\n                    }\n                }\n\n                if tx.is_some() {\n                    break;\n                }\n            }\n\n            block_hash = block.header.prev_blockhash.to_string();\n\n            Ok(())\n        });\n    }\n\n    Ok(tx.unwrap())\n}", "item_id": 0, "repo": "afilini/kaleidoscope", "file": "src/chain/indexer.rs", "last_update_at": "2019-05-02T12:18:09+00:00"}
{"hexsha": "1b03fdfd09f7603796726fd649568fd14e7f04af", "ext": "rs", "lang": "Rust", "content": "fn openssl_bench(b: &mut Bencher) {\n    use openssl::hash::{Hasher, MessageDigest};\n\n    // Make buffer big enough to not fit in cache.\n    let buf = vec![0; 1024 * 1024 * 16];\n\n    b.iter(|| {\n        let mut h = Hasher::new(MessageDigest::sha1()).unwrap();\n        h.write_all(&buf).unwrap();\n        h.finish().unwrap();\n    })\n}", "item_id": 1, "repo": "d3zd3z/rsure", "file": "benches/hash.rs", "last_update_at": "2019-12-18T20:30:15+00:00"}
{"hexsha": "b475cda86e32301d7feb341ce14e8004c9914740", "ext": "rs", "lang": "Rust", "content": "fn init_logger(matches: &ArgMatches) {\n    let pkg_name = str::replace(env!(\"CARGO_PKG_NAME\"), \"-\", \"_\");\n    let prog_name = str::replace(progname().as_str(), \"-\", \"_\");\n    let log_lv = if matches.is_present(\"quiet\") {\n        \"off\".to_owned()\n    } else {\n        match matches.occurrences_of(\"verbose\") {\n            0 => \"error\".to_owned(),\n            1 => format!(\"error,{}=warn,{}=warn\", pkg_name, prog_name),\n            2 => format!(\"error,{}=info,{}=info\", pkg_name, prog_name),\n            3 => format!(\"error,{}=debug,{}=debug\", pkg_name, prog_name),\n            4 => format!(\"error,{}=trace,{}=trace\", pkg_name, prog_name),\n            5 => format!(\"warn,{}=trace,{}=trace\", pkg_name, prog_name),\n            6 => format!(\"info,{}=trace,{}=trace\", pkg_name, prog_name),\n            7 => format!(\"debug,{}=trace,{}=trace\", pkg_name, prog_name),\n            _ => \"trace\".to_owned(),\n        }\n    };\n    env::set_var(LOG_LEVEL_ENV, log_lv.as_str());\n    pretty_env_logger::try_init_timed_custom_env(LOG_LEVEL_ENV).unwrap();\n}", "item_id": 0, "repo": "yangby-cryptape/cita-bench", "file": "src/config.rs", "last_update_at": "2019-03-15T02:17:45+00:00"}
{"hexsha": "e9ed937129783e1d58168f053869e06652922c05", "ext": "rs", "lang": "Rust", "content": "pub fn init_send_tx<T: ?Sized, C, K>(\n\tw: &mut T,\n\targs: InitTxArgs,\n\tuse_test_rng: bool,\n) -> Result<Slate, Error>\nwhere\n\tT: WalletBackend<C, K>,\n\tC: NodeClient,\n\tK: Keychain,\n{\n\tlet parent_key_id = match args.src_acct_name {\n\t\tSome(d) => {\n\t\t\tlet pm = w.get_acct_path(d)?;\n\t\t\tmatch pm {\n\t\t\t\tSome(p) => p.path,\n\t\t\t\tNone => w.parent_key_id(),\n\t\t\t}\n\t\t}\n\t\tNone => w.parent_key_id(),\n\t};\n\n\tlet message = match args.message {\n\t\tSome(mut m) => {\n\t\t\tm.truncate(USER_MESSAGE_MAX_LEN);\n\t\t\tSome(m)\n\t\t}\n\t\tNone => None,\n\t};\n\n\tlet mut slate = tx::new_tx_slate(&mut *w, args.amount, 2, use_test_rng)?;\n\n\t// if we just want to estimate, don't save a context, just send the results\n\t// back\n\tif let Some(true) = args.estimate_only {\n\t\tlet (total, fee) = tx::estimate_send_tx(\n\t\t\t&mut *w,\n\t\t\targs.amount,\n\t\t\targs.minimum_confirmations,\n\t\t\targs.max_outputs as usize,\n\t\t\targs.num_change_outputs as usize,\n\t\t\targs.selection_strategy,\n\t\t\t&parent_key_id,\n\t\t)?;\n\t\tslate.amount = total;\n\t\tslate.fee = fee;\n\t\treturn Ok(slate);\n\t}\n\n\tlet context = tx::add_inputs_to_slate(\n\t\t&mut *w,\n\t\t&mut slate,\n\t\targs.minimum_confirmations,\n\t\targs.max_outputs as usize,\n\t\targs.num_change_outputs as usize,\n\t\targs.selection_strategy,\n\t\t&parent_key_id,\n\t\t0,\n\t\tmessage,\n\t\ttrue,\n\t\tuse_test_rng,\n\t)?;\n\n\t// Save the aggsig context in our DB for when we\n\t// receive the transaction back\n\t{\n\t\tlet mut batch = w.batch()?;\n\t\tbatch.save_private_context(slate.id.as_bytes(), 0, &context)?;\n\t\tbatch.commit()?;\n\t}\n\tif let Some(v) = args.target_slate_version {\n\t\tslate.version_info.orig_version = v;\n\t}\n\tOk(slate)\n}", "item_id": 4, "repo": "terryzhao/grin-wallet", "file": "libwallet/src/api_impl/owner.rs", "last_update_at": "2019-09-03T15:28:57+00:00"}
{"hexsha": "da08379faa3c75f93b9a419410a34b98558e9ff4", "ext": "rs", "lang": "Rust", "content": "fn zero_or_more_combinator() {\n    let parser = zero_or_more(match_literal(\"ha\"));\n    assert_eq!(Ok((\"\", vec![(), (), ()])), parser.parse(\"hahaha\"));\n    assert_eq!(Ok((\"ahah\", vec![])), parser.parse(\"ahah\"));\n    assert_eq!(Ok((\"\", vec![])), parser.parse(\"\"));\n}", "item_id": 5, "repo": "U007D/parser_combinator", "file": "src/unit_tests.rs", "last_update_at": "2019-04-20T00:01:58+00:00"}
{"hexsha": "41ccb31f1a0052a8d992fa5f0b9831a8fdbd346b", "ext": "rs", "lang": "Rust", "content": "fn update(host: &mut HostApi, state: &mut State) -> ShouldQuit {\n    state.set_host(host);\n    state.update_and_render();\n    ShouldQuit::No\n}", "item_id": 0, "repo": "scottjmaddox/rust-game-boilerplate", "file": "dev-client-lib/src/lib.rs", "last_update_at": "2019-12-12T06:04:00+00:00"}
{"hexsha": "8651fa15c5ba0e6ed940a1ff083ebee8c3933ded", "ext": "rs", "lang": "Rust", "content": "pub fn derive_actor( input: TokenStream ) -> TokenStream\n{\n\tlet input = parse_macro_input!( input as DeriveInput );\n\tlet name  = input.ident;\n\n\tlet ( impl_generics, ty_generics, where_clause ) = input.generics.split_for_impl();\n\n\t// The generated impl.\n\t//\n\tlet expanded = quote!\n\t{\n\t\timpl #impl_generics thespis::Actor for #name #ty_generics #where_clause\n\t\t{}\n\t};\n\n\tTokenStream::from( expanded )\n}", "item_id": 0, "repo": "thespis-rs/thespis_derive", "file": "src/lib.rs", "last_update_at": "2019-10-11T14:02:47+00:00"}
{"hexsha": "429e3dd3fff57432aa820a7f0c39f4fccdc9df52", "ext": "rs", "lang": "Rust", "content": "fn find_chapter(rc: &mut RenderContext, target: Target) -> Result<Option<StringMap>, RenderError> {\n    debug!(\"Get data from context\");\n\n    let chapters = rc.evaluate_absolute(\"chapters\", true).and_then(|c| {\n        serde_json::value::from_value::<Vec<StringMap>>(c.clone())\n            .map_err(|_| RenderError::new(\"Could not decode the JSON data\"))\n    })?;\n\n    let base_path = rc.evaluate_absolute(\"path\", true)?\n        .as_str()\n        .ok_or_else(|| RenderError::new(\"Type error for `path`, string expected\"))?\n        .replace(\"\\\"\", \"\");\n\n    let mut previous: Option<StringMap> = None;\n\n    debug!(\"Search for chapter\");\n\n    for item in chapters {\n        match item.get(\"path\") {\n            Some(path) if !path.is_empty() => {\n                if let Some(previous) = previous {\n                    if let Some(item) = target.find(&base_path, &path, &item, &previous)? {\n                        return Ok(Some(item));\n                    }\n                }\n\n                previous = Some(item.clone());\n            }\n            _ => continue,\n        }\n    }\n\n    Ok(None)\n}", "item_id": 0, "repo": "cxuauto/rust-book", "file": "src/renderer/html_handlebars/helpers/navigation.rs", "last_update_at": "2019-04-24T23:46:28+00:00"}
{"hexsha": "7a5c4c6f1fb8404074bc9ef350a73b801ae2d166", "ext": "rs", "lang": "Rust", "content": "fn display(&self) -> String {\n        let mut display = String::from(\"option name \")\n            + self.option_name()\n            + \" type \"\n            + self.option_type();\n\n        if let Some(part_dis) = self.partial_display() {\n            display += \" \";\n            display += &part_dis;\n        }\n        display\n    }", "item_id": 0, "repo": "alanthinker/Pleco", "file": "pleco_engine/src/uci/options.rs", "last_update_at": "2019-02-01T04:14:47+00:00"}
{"hexsha": "931992201a7c2a31e83fc3ca3ff95c22f30a61be", "ext": "rs", "lang": "Rust", "content": "fn perlin_generate_permutation() -> NoiseData {\n    let mut result: NoiseData = [0; 256];\n    for i in 0..256 {\n        result[i] = i;\n    }\n    permute(&mut result);\n    result\n}", "item_id": 3, "repo": "Alekssasho/GarageRay", "file": "simple/src/texture/noise_texture.rs", "last_update_at": "2019-12-19T17:44:29+00:00"}
{"hexsha": "de2771d85d0cf9d825f9f0e2a9a64fd516f14db0", "ext": "rs", "lang": "Rust", "content": "fn block_results() {\n        let response =\n            endpoint::block_results::Response::from_string(&read_json_fixture(\"block_results\"))\n                .unwrap();\n        assert_eq!(response.height.value(), 1814);\n\n        let validator_updates = response.validator_updates;\n        let deliver_tx = response.txs_results.unwrap();\n        let log_json = &deliver_tx[0].log.parse_json().unwrap();\n        let log_json_value = &log_json.as_array().as_ref().unwrap()[0];\n\n        assert_eq!(log_json_value[\"msg_index\"].as_str().unwrap(), \"0\");\n        assert_eq!(log_json_value[\"success\"].as_bool().unwrap(), true);\n\n        assert_eq!(deliver_tx[0].gas_wanted.value(), 200_000);\n        assert_eq!(deliver_tx[0].gas_used.value(), 105_662);\n\n        assert_eq!(validator_updates[0].power.value(), 1_233_243);\n    }", "item_id": 4, "repo": "yihuang/tendermint-rs", "file": "rpc/tests/integration.rs", "last_update_at": "2019-11-11T10:52:30+00:00"}
{"hexsha": "9bdad3ccd5e54814c4f1d59bdbd7e9c6bf5f107a", "ext": "rs", "lang": "Rust", "content": "pub fn add_chunks(header: String, chunks: &[&[u8]]) -> Vec<u8> {\n    let headlen = header.len();\n    let rawlen = chunks.iter().fold(1, |sum, c| sum + c.len());\n    let mut buf = Vec::with_capacity(5 + headlen + rawlen);\n    buf.write_all(&[1]).unwrap(); // version\n    buf.write_u32::<LittleEndian>(headlen as u32).unwrap();\n    buf.write_all(header.as_bytes()).unwrap();\n    buf.write_u8(chunks.len() as u8).unwrap();\n    for chunk in chunks {\n        buf.write_u32::<LittleEndian>(chunk.len() as u32).unwrap();\n        buf.write_all(chunk).unwrap();\n    }\n    buf\n}", "item_id": 3, "repo": "passcod/trebuchet", "file": "src/message.rs", "last_update_at": "2019-10-08T03:54:41+00:00"}
{"hexsha": "03e02fe4f4effa796beac6e1a84112d19c5bf2eb", "ext": "rs", "lang": "Rust", "content": "fn cg() -> Result<(), io::Error> {\n    let pids: &Path = Path::new(\"/sys/fs/cgroup/pids\");\n    match fs::create_dir(pids.join(\"myuser\")) {\n        _ => (),\n    };\n\n    fs::write(pids.join(\"myuser/pids.max\"), b\"20\").unwrap();\n    fs::write(pids.join(\"myuser/notify_on_release\"), b\"1\").unwrap();\n    fs::write(\n        pids.join(\"myuser/cgroup.procs\"),\n        format!(\"{}\", nix::unistd::getpid().as_raw()),\n    )\n    .unwrap();\n\n    Ok(())\n}", "item_id": 3, "repo": "hails/containers-from-scratch-rs", "file": "src/main.rs", "last_update_at": "2019-04-17T14:21:46+00:00"}
{"hexsha": "4a7a44286a7c80c34cdd0cba4d7e276771cca4ee", "ext": "rs", "lang": "Rust", "content": "pub fn read_pixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, pixel_type: GLenum) -> Vec<u8> {\n    let colors = match format {\n        RGB => 3,\n        RGBA => 3,\n        _ => panic!(\"unsupported format for read_pixels\"),\n    };\n    let depth = match pixel_type {\n        UNSIGNED_BYTE => 1,\n        _ => panic!(\"unsupported pixel_type for read_pixels\"),\n    };\n\n    let len = (width * height * colors * depth) as uint;\n    let mut pixels: Vec<u8> = Vec::new();\n    pixels.reserve(len);\n\n    unsafe {\n        // We don't want any alignment padding on pixel rows.\n        glPixelStorei(PACK_ALIGNMENT, 1);\n        glReadPixels(x, y, width, height, format, pixel_type, pixels.as_mut_ptr() as *mut c_void);\n        pixels.set_len(len);\n    }\n\n    pixels\n}", "item_id": 0, "repo": "robn/rust-opengles", "file": "src/gl2.rs", "last_update_at": "2019-05-14T00:48:43+00:00"}
{"hexsha": "b966e8b98bd995dd5d1a2e68088c7ca3c17c9057", "ext": "rs", "lang": "Rust", "content": "fn bool_succeeds() {\n    // word format\n    assert_eq!(fm::<bool>(quote!(ignore)), true);\n\n    // bool literal\n    assert_eq!(fm::<bool>(quote!(ignore = true)), true);\n    assert_eq!(fm::<bool>(quote!(ignore = false)), false);\n\n    // string literals\n    assert_eq!(fm::<bool>(quote!(ignore = \"true\")), true);\n    assert_eq!(fm::<bool>(quote!(ignore = \"false\")), false);\n  }", "item_id": 0, "repo": "YoloDev/evitable", "file": "syn-meta-ext/src/from_meta.rs", "last_update_at": "2019-08-27T15:40:16+00:00"}
{"hexsha": "63ee7d95bc3e38ce182365b2cf49a9c3256cb4d0", "ext": "rs", "lang": "Rust", "content": "pub fn create_rkf_stepper_subcommand(_parent_command_name: &'static str) -> Command<'static> {\n    let command_name = \"rkf_stepper\";\n\n    update_command_graph!(_parent_command_name, command_name);\n\n    Command::new(command_name)\n        .about(\"Use a Runge-Kutta-Fehlberg stepper\")\n        .long_about(\n            \"Use a Runge-Kutta-Fehlberg stepper.\\n\\\n             The next position is computed with a Runge-Kutta scheme, and tbe resulting error\\n\\\n             is estimated using an embedded lower-order step. The errors are used to adjust\\n\\\n             the step length, and steps are re-attempted until the error is below a certain\\n\\\n             tolerance.\",\n        )\n        .arg(\n            Arg::new(\"dense-step-length\")\n                .long(\"dense-step-length\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Step length to use for dense (uniform) output positions [Mm]\\n\")\n                .takes_value(true)\n                .default_value(\"0.01\"),\n        )\n        .arg(\n            Arg::new(\"max-step-attempts\")\n                .long(\"max-step-attempts\")\n                .require_equals(true)\n                .value_name(\"NUMBER\")\n                .help(\"Maximum number of step attempts before terminating\")\n                .takes_value(true)\n                .default_value(\"16\"),\n        )\n        .arg(\n            Arg::new(\"absolute-tolerance\")\n                .long(\"absolute-tolerance\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Absolute error tolerance for stepping\")\n                .takes_value(true)\n                .default_value(\"1e-6\"),\n        )\n        .arg(\n            Arg::new(\"relative-tolerance\")\n                .long(\"relative-tolerance\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Relative error tolerance for stepping\")\n                .takes_value(true)\n                .default_value(\"1e-6\"),\n        )\n        .arg(\n            Arg::new(\"safety-factor\")\n                .long(\"safety-factor\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Scaling factor for the error to reduce step length oscillations\\n\")\n                .takes_value(true)\n                .default_value(\"0.9\"),\n        )\n        .arg(\n            Arg::new(\"min-step-scale\")\n                .long(\"min-step-scale\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Smallest allowed scaling of the step size in one step\")\n                .takes_value(true)\n                .default_value(\"0.2\"),\n        )\n        .arg(\n            Arg::new(\"max-step-scale\")\n                .long(\"max-step-scale\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Largest allowed scaling of the step size in one step\")\n                .takes_value(true)\n                .default_value(\"10.0\"),\n        )\n        .arg(\n            Arg::new(\"initial-error\")\n                .long(\"initial-error\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Start value for stepping error\")\n                .takes_value(true)\n                .default_value(\"1e-4\"),\n        )\n        .arg(\n            Arg::new(\"initial-step-length\")\n                .long(\"initial-step-length\")\n                .require_equals(true)\n                .value_name(\"VALUE\")\n                .help(\"Initial step size\")\n                .takes_value(true)\n                .default_value(\"1e-4\"),\n        )\n        .arg(\n            Arg::new(\"sudden-reversals-for-sink\")\n                .long(\"sudden-reversals-for-sink\")\n                .require_equals(true)\n                .value_name(\"NUMBER\")\n                .help(\n                    \"Number of sudden direction reversals before the area is considered\\n\\\n                     a sink\",\n                )\n                .takes_value(true)\n                .default_value(\"3\"),\n        )\n        .arg(\n            Arg::new(\"disable-pi-control\")\n                .long(\"disable-pi-control\")\n                .help(\n                    \"Disable Proportional Integral (PI) control used for stabilizing the stepping\",\n                ),\n        )\n        .arg(\n            Arg::new(\"stepping-scheme\")\n                .long(\"stepping-scheme\")\n                .require_equals(true)\n                .value_name(\"NAME\")\n                .help(\"Which Runge-Kutta-Fehlberg stepping scheme to use\\n\")\n                .takes_value(true)\n                .possible_values(&[\"rkf23\", \"rkf45\"])\n                .default_value(\"rkf45\"),\n        )\n}", "item_id": 0, "repo": "lars-frogner/bifrost-rust", "file": "src/cli/tracing/stepping/rkf.rs", "last_update_at": "2019-10-24T07:24:05+00:00"}
{"hexsha": "de600b9a9480f426db0c274e78354a485857ba74", "ext": "rs", "lang": "Rust", "content": "fn parses_blogpost_package_oftd() {\n    let src = r#\"(authors\n  \"Nathan Ringo <remexre@gmail.com>\")\n(license \"MIT\")\n(name foo)\n(version \"0.1.0\")\n\n(components\n  (library)\n  (binary\n    (name \"foo\")\n    (path \"src/main.oft\")))\n\n(dependencies\n  (combinargs\n    (version \"^0.2.1\"))\n  (grid\n    (git \"https://github.com/remexre/oftlisp-grid.git\")\n    (version \"^0.1.0\")))\n\"#;\n    let data = PackageMetadata {\n        authors: vec![\"Nathan Ringo <remexre@gmail.com>\".to_string()],\n        components: ComponentsMetadata {\n            library: Some(LibraryComponentMetadata),\n            binaries: vec![BinaryComponentMetadata {\n                name: \"foo\".to_string(),\n                path: \"src/main.oft\".to_string(),\n            }],\n        },\n        dependencies: vec![\n            (\n                \"combinargs\".into(),\n                DependencyMetadata {\n                    git: None,\n                    version: \"0.2.1\".parse().unwrap(),\n                },\n            ),\n            (\n                \"grid\".into(),\n                DependencyMetadata {\n                    git: Some(\"https://github.com/remexre/oftlisp-grid.git\".to_string()),\n                    version: \"0.1.0\".parse().unwrap(),\n                },\n            ),\n        ].into_iter()\n            .collect(),\n        license: Some(\"MIT\".to_string()),\n        name: \"foo\".into(),\n        version: \"0.1.0\".parse().unwrap(),\n    };\n\n    let lits = parse_program(src).unwrap();\n    assert_eq!(data.clone().to_literals(), lits);\n    let meta = PackageMetadata::from_literals(lits).unwrap();\n    assert_eq!(meta, data);\n}", "item_id": 0, "repo": "oftlisp/oftb", "file": "src/modules/tests.rs", "last_update_at": "2019-10-14T00:32:53+00:00"}
{"hexsha": "edeef41d0f27105f1329da21b4afdf0ce9350dfd", "ext": "rs", "lang": "Rust", "content": "fn part1_summed_area(input: usize) -> String {\n    const GRID_SIZE: usize = 300;\n    const SQUARE_SIZE: usize = 3;\n\n    let grid = SummedAreaFuelCellGrid::new(GRID_SIZE, input);\n    let (_, (x, y)) = summed_area_calculate_best_square(&grid, SQUARE_SIZE);\n\n    format!(\"Square of largest total power at: {},{}\", x, y)\n}", "item_id": 3, "repo": "zoewithabang/rust-aoc-2018", "file": "src/days/day11.rs", "last_update_at": "2019-05-23T15:47:24+00:00"}
{"hexsha": "d680324d013bb719f96d055ca5c2fdd33a9ebae3", "ext": "rs", "lang": "Rust", "content": "fn download(url: &str, dest_filename: &Path) -> Result<Interactions, failure::Error> {\n    let data_dir = create_data_dir()?;\n    let desired_filename = data_dir.join(dest_filename);\n\n    if !desired_filename.exists() {\n        let temp_filename = env::temp_dir().join(\n            rand::thread_rng()\n                .sample_iter(&rand::distributions::Alphanumeric)\n                .take(10)\n                .collect::<String>(),\n        );\n\n        let file = File::create(&temp_filename)?;\n        let mut writer = BufWriter::new(file);\n\n        let mut response = reqwest::get(url)?;\n        response.copy_to(&mut writer)?;\n\n        rename(temp_filename, &desired_filename)?;\n    }\n\n    let mut reader = csv::Reader::from_path(desired_filename)?;\n    let interactions: Vec<Interaction> = reader.deserialize().collect::<Result<Vec<_>, _>>()?;\n\n    Ok(Interactions::from(interactions))\n}", "item_id": 1, "repo": "timedcy/sbr-rs", "file": "src/datasets.rs", "last_update_at": "2019-03-06T06:47:15+00:00"}
{"hexsha": "25af6178a4375d001ecc3aa9ac91731af7e88458", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    // Generate initial random population\n    println_err!(\"Generating initial population\");\n    let mut population = evolve::random_population::<Program>(POPULATION_SIZE);\n    let mut rng = rand::StdRng::new().unwrap();\n    let mut stdout = std::io::stdout();\n    let mut keeper = OptimumKeeper::<Program>::new();\n\n    loop {\n        println_err!(\"[{}] Scoring\", population.generation);\n        population.score(|p| score_program(p, &mut rng));\n        {\n            let winner = population.winner();\n            println_err!(\"[{}] Best score: {}\", population.generation, winner.score.total_score());\n            \n            if keeper.improved(&winner.program, &winner.score, population.generation) {\n                let random_score = score_single_run(&winner.program, &mut rng);\n\n                let _ = serialize::writeln(&serialize::TraceOutput {\n                    generation: population.generation,\n                    program: &winner.program.simplify(),\n                    score_card: &random_score\n                }, &mut stdout);\n            }\n        }\n\n        println_err!(\"[{}] Evolving\", population.generation);\n        population = population.evolve(TOURNAMENT_SIZE,\n                                       REPRODUCE_WEIGHT, \n                                       MUTATE_WEIGHT, \n                                       CROSSOVER_WEIGHT,\n                                       &mut rng);\n    }\n}", "item_id": 3, "repo": "darwins-challenge/moonlander-ast-rust", "file": "examples/evolve.rs", "last_update_at": "2019-03-12T10:41:50+00:00"}
{"hexsha": "bbcf632bd6ec044f33f555480b48984dd326426e", "ext": "rs", "lang": "Rust", "content": "fn Block(tokens: Input<InputWrapper>) -> IResult<Input<InputWrapper>, node::BlockStatement> {\n    let brackets = is_token!(tokens, Token::LCurly)?;\n    if let Ok((rest, statement)) = StatementList(brackets.0) {\n        let brackets = is_token!(rest, Token::RCurly)?;\n        return Ok((brackets.0, node::BlockStatement { body: statement }));\n    }\n    let brackets = is_token!(brackets.0, Token::RCurly)?;\n    Ok((brackets.0, node::BlockStatement { body: vec![] }))\n}", "item_id": 50, "repo": "retep007/javascript-es9-parser", "file": "components/parser/src/statement_declaration.rs", "last_update_at": "2019-05-24T15:26:18+00:00"}
{"hexsha": "b0d399e938b989f7d14a3334b8ab01f8ea791fcb", "ext": "rs", "lang": "Rust", "content": "fn find_stable_conflicting_units(\n    db: &Connection,\n    unit_prop: &graph::UnitProps,\n) -> Result<Vec<String>> {\n    // units come here sorted by original unit,\n    //so the smallest original on the same MCI comes first and will become good,\n    //all others will become final-bad\n    let mut stmt = db.prepare_cached(\n        \"SELECT competitor_units.* \\\n        FROM unit_authors AS this_unit_authors \\\n        JOIN unit_authors AS competitor_unit_authors USING(address) \\\n        JOIN units AS competitor_units ON competitor_unit_authors.unit=competitor_units.unit \\\n        JOIN units AS this_unit ON this_unit_authors.unit=this_unit.unit \\\n        WHERE this_unit_authors.unit=? AND competitor_units.is_stable=1 AND +competitor_units.sequence='good' \\\n            -- if it were main_chain_index <= this_unit_limci, the competitor would've been included \\\n            AND (competitor_units.main_chain_index > this_unit.latest_included_mc_index) \\\n            AND (competitor_units.main_chain_index <= this_unit.main_chain_index)\",\n    )?;\n    let rows = stmt.query_map(&[&unit_prop.unit], |row| graph::UnitProps {\n        unit: row.get(\"unit\"),\n        level: row.get(\"level\"),\n        latest_included_mc_index: row.get(\"latest_included_mc_index\"),\n        main_chain_index: row.get(\"main_chain_index\"),\n        is_on_main_chain: row.get(\"is_on_main_chain\"),\n        is_free: row.get(\"is_free\"),\n    })?;\n\n    let mut conflicting_units = Vec::new();\n    for row in rows {\n        let row = row?;\n        if graph::compare_unit_props(db, &row, unit_prop)? == None {\n            conflicting_units.push(row.unit);\n        }\n    }\n\n    Ok(conflicting_units)\n}", "item_id": 8, "repo": "ringringringring/rust-trustnote", "file": "src/main_chain.rs", "last_update_at": "2019-05-28T10:59:27+00:00"}
{"hexsha": "3833dd49822bd951353a13d4bb69e52f525e1493", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut input = format!(\"\");\n    std::io::stdin().read_line(&mut input).expect(\"\");\n    //let n_arr: usize = input.trim().parse().expect(\"\");\n    input = format!(\"\");\n    std::io::stdin().read_line(&mut input).expect(\"\");\n    let mut arr: Vec<u64> = input\n        .trim()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let mut sorted: bool = false;\n    let mut temp: u64;\n    let mut step: u64 = 0;\n    loop {\n        sorted = true;\n        for i in 0..arr.len() - 1 {\n            if arr[i] > arr[i + 1] {\n                temp = arr[i + 1];\n                arr[i + 1] = arr[i];\n                arr[i] = temp;\n                step = step + 1;\n                sorted = false;\n            }\n        }\n        if sorted == true {\n            break;\n        }\n    }\n    println!(\n        \"Array is sorted in {} swaps.\\nFirst Element: {}\\nLast Element: {}\",\n        step,\n        arr[0],\n        arr[arr.len() - 1]\n    );\n}", "item_id": 0, "repo": "andraantariksa/code-exercise-answer", "file": "hackerrank/30 Days of Code/20. Sorting.rs", "last_update_at": "2019-11-06T15:17:48+00:00"}
{"hexsha": "8ad2e3b0199c65a92c5747a6718f0d5d37cd4526", "ext": "rs", "lang": "Rust", "content": "fn load_libraries(ids: &UniqueIdGenerator, lib: &Path) -> Result<im::HashMap<String, Module>> {\n    tracing::info!(\"Reading precompiled module metadata files\");\n    let mut manifests = im::HashMap::new();\n    for lib in fs::read_dir(lib)?.filter_map(Result::ok) {\n        let path = lib.path().join(\"build\");\n        if !path.is_dir() {\n            continue;\n        }\n        for module in fs::gleam_modules_metadata_paths(path)? {\n            let reader = fs::buffered_reader(module)?;\n            let module = metadata::ModuleDecoder::new(ids.clone()).read(reader)?;\n            let _ = manifests.insert(module.name.join(\"/\"), module);\n        }\n    }\n    Ok(manifests)\n}", "item_id": 1, "repo": "HarryET/gleam", "file": "compiler-cli/src/compile_package.rs", "last_update_at": "2019-10-27T15:26:35+00:00"}
{"hexsha": "e184291a10e1f81d117c0559f7b63aedca25f8b4", "ext": "rs", "lang": "Rust", "content": "fn construct_cpu(filename: &str, classic_mode: bool, output_serial: bool, output_printer: bool) -> Option<Device> {\n    let opt_c = match classic_mode {\n        true => Device::new(filename),\n        false => Device::new_cgb(filename),\n    };\n    let mut c = match opt_c\n    {\n        Ok(cpu) => { cpu },\n        Err(message) => { warn(message); return None; },\n    };\n\n    if output_printer {\n        c.attach_printer();\n    }\n    else {\n        c.set_stdout(output_serial);\n    }\n\n    Some(c)\n}", "item_id": 2, "repo": "krocki/rboy", "file": "src/main.rs", "last_update_at": "2019-05-13T19:05:20+00:00"}
{"hexsha": "78bee61259e517838765e26e9021310e19532ccc", "ext": "rs", "lang": "Rust", "content": "pub fn parse_duration(s: &str) -> Option<Duration> {\n    let mut digits = String::new();\n    let mut unit = String::new();\n    let mut reading_digits = true;\n    for c in s.chars().filter(|c| !c.is_whitespace()) {\n        if reading_digits {\n            if c.is_digit(BASE_TEN) {\n                digits.push(c);\n            } else {\n                reading_digits = false;\n                unit.push(c)\n            }\n        } else {\n            unit.push(c);\n        }\n    }\n\n    if digits.is_empty() { return None; }\n\n    let mk_duration: fn(i64) -> Duration = match &*unit {\n        \"ns\" | \"nanos\" | \"nano\" | \"nanoseconds\" | \"nanosecond\" => Duration::nanoseconds,\n        \"us\" | \"micros\" | \"micro\" | \"microseconds\" | \"microsecond\" => Duration::microseconds,\n        \"ms\" | \"millis\" | \"milli\" | \"milliseconds\" | \"millisecond\" => Duration::milliseconds,\n        \"s\" | \"secs\" | \"sec\" | \"seconds\" | \"second\" => Duration::seconds,\n        \"m\" | \"mins\" | \"min\" | \"minutes\" | \"minute\" => Duration::minutes,\n        \"h\" | \"hours\" | \"hour\" => Duration::hours,\n        \"d\" | \"days\" | \"day\" => Duration::days,\n        _ => return None\n    };\n\n    let n = digits.parse().unwrap();  // always correct\n    Some(mk_duration(n))\n}", "item_id": 0, "repo": "netvl/wcd", "file": "src/common/util.rs", "last_update_at": "2019-11-25T16:37:00+00:00"}
{"hexsha": "d87c9e045f315190d8c5e8bd4dc961076a207bc2", "ext": "rs", "lang": "Rust", "content": "fn badly_signed_check_should_fail() {\n\t\tlet ux = Ex::new_signed(\n\t\t\tvec![0u8; 0],\n\t\t\tTEST_ACCOUNT,\n\t\t\tTestSig(TEST_ACCOUNT, vec![0u8; 0]),\n\t\t\tTestExtra\n\t\t);\n\t\tassert!(ux.is_signed().unwrap_or(false));\n\t\tassert_eq!(<Ex as Checkable<TestContext>>::check(ux, &TestContext), Err(crate::BAD_SIGNATURE));\n\t}", "item_id": 4, "repo": "HPIPS/HPIPS_Chain", "file": "core/sr-primitives/src/generic/unchecked_extrinsic.rs", "last_update_at": "2019-08-07T10:22:08+00:00"}
{"hexsha": "a6369dc4c983beb04ed254ef2f1ba5e7e983dc43", "ext": "rs", "lang": "Rust", "content": "fn delegate_to_test(){\n    let mut this=Foo{value:(3,5,8,13,21)};\n\n    let fields=&[\n        FieldInfo::not_renamed(\"0\"),\n        FieldInfo::not_renamed(\"1\"),\n        FieldInfo::not_renamed(\"2\"),\n        FieldInfo::not_renamed(\"3\"),\n        FieldInfo::not_renamed(\"4\"),\n    ];\n\n    assert_eq!( this.fields_info(), &fields[..] );\n    assert_eq!( get_fields_assoc_const(&this), &fields[..] );\n\n    assert_eq!(\n        this.fields(fp!(1,3,0,2,4)),\n        (&5,&13,&3,&8,&21),\n    );\n    assert_eq!(\n        this.fields_mut(fp!(1,3,0,2,4)),\n        (&mut 5,&mut 13,&mut 3,&mut 8,&mut 21),\n    );\n\n    assert_eq!( this.clone().into_field(fp!(0)), 3 );\n    assert_eq!( this.clone().into_field(fp!(1)), 5 );\n    assert_eq!( this.clone().into_field(fp!(2)), 8 );\n    assert_eq!( this.clone().into_field(fp!(3)), 13 );\n    assert_eq!( this.clone().into_field(fp!(4)), 21 );\n}", "item_id": 7, "repo": "RalfJung/structural_crates", "file": "structural/src/tests/structural_derive.rs", "last_update_at": "2019-12-06T08:59:49+00:00"}
{"hexsha": "2ccc6dde5b7dd9bfb6866553d62b8e08904cd9c7", "ext": "rs", "lang": "Rust", "content": "pub fn add_http_breakpoint(\n    service: &ZapService,\n    string: String,\n    location: String,\n    mtch: String,\n    inverse: String,\n    ignorecase: String,\n) -> Result<Value, ZapApiError> {\n    let mut params = HashMap::new();\n    params.insert(\"string\".to_string(), string);\n    params.insert(\"location\".to_string(), location);\n    params.insert(\"match\".to_string(), mtch);\n    params.insert(\"inverse\".to_string(), inverse);\n    params.insert(\"ignorecase\".to_string(), ignorecase);\n    super::call(service, \"break\", \"action\", \"addHttpBreakpoint\", params)\n}", "item_id": 2, "repo": "cak/zap-api-rust", "file": "src/brk.rs", "last_update_at": "2019-05-23T12:34:22+00:00"}
{"hexsha": "dfd72bab48f625510568aae031fef93488dae578", "ext": "rs", "lang": "Rust", "content": "fn fibonacci_sync(mut cx: FunctionContext) -> JsResult<JsString> {\n    let n = cx.argument::<JsNumber>(0)?.value() as usize;\n    let big = compute(n);\n    Ok(cx.string(big.to_str_radix(10)))\n}", "item_id": 1, "repo": "theJian/examples", "file": "fibonacci-task/native/src/lib.rs", "last_update_at": "2019-02-04T14:47:12+00:00"}
{"hexsha": "a10d4c508021a2a4a7f87ea06703e2856e0f8eee", "ext": "rs", "lang": "Rust", "content": "fn ShiftExpression2(tokens: Input<InputWrapper>) -> IResult<Input<InputWrapper>, node::Expression> {\n    let skipped = take!(tokens.clone(), 1)?;\n    let tok = is_token!(skipped.0, Token::DoubleBigger)?;\n    let or = ShiftExpression(skipped.1)?;\n    let and = ShiftExpression(tok.0)?;\n    Ok((\n        and.0,\n        node::Expression::BinaryExpression(node::BinaryExpression {\n            operator: estree::BinaryOperator::MoreMore,\n            left: box or.1,\n            right: box and.1,\n        }),\n    ))\n}", "item_id": 25, "repo": "retep007/javascript-es9-parser", "file": "components/parser/src/expression.rs", "last_update_at": "2019-05-24T15:26:18+00:00"}
{"hexsha": "c5ea232e0ddefb1a144497f1ef8f8ffb237b24f3", "ext": "rs", "lang": "Rust", "content": "fn test_new_by_line_empty_2() {\n        let ingredient = Ingredient::new_by_line(\";\");\n        assert_eq!(ingredient.name, \"\");\n        assert_eq!(ingredient.group, Group::Other);\n    }", "item_id": 1, "repo": "totoMauz/Cooking-Book", "file": "src/cooking_book/ingredient.rs", "last_update_at": "2019-04-02T19:01:39+00:00"}
{"hexsha": "c124457118cb97768a98b181f70be07ad85e7dd9", "ext": "rs", "lang": "Rust", "content": "unsafe fn shrink_in_place(&mut self,\n                              ptr: NonNull<u8>,\n                              layout: Layout,\n                              new_size: usize) -> Result<(), CannotReallocInPlace> {\n        let _ = ptr; // this default implementation doesn't care about the actual address.\n        debug_assert!(new_size <= layout.size());\n        let (l, _u) = self.usable_size(&layout);\n        //                      layout.size() <= _u  [guaranteed by usable_size()]\n        // new_layout.size() <= layout.size()        [required by this method]\n        if l <= new_size {\n            Ok(())\n        } else {\n            Err(CannotReallocInPlace)\n        }\n    }", "item_id": 6, "repo": "jespersm/rust", "file": "src/libcore/alloc.rs", "last_update_at": "2019-05-18T01:43:48+00:00"}
{"hexsha": "d9abf304aa292dad0efdb6ed6c7088f9d9f6a173", "ext": "rs", "lang": "Rust", "content": "fn create(\n    name: &str,\n    config: &types::SubscriptionCreateConfig,\n    reg: &SharedRegistry,\n    cfg: &Config,\n) -> Option<HttpResponse> {\n    let ack_deadline = config\n        .ack_deadline\n        .map(|ack_deadline| Duration::seconds(i64::from(ack_deadline)))\n        .unwrap_or(cfg.default_ack_deadline);\n    let ttl = config\n        .ttl\n        .map(|ttl| Duration::seconds(i64::from(ttl)))\n        .unwrap_or(cfg.default_subscription_ttl);\n    let subscribe = reg.create_subscription(\n        &name,\n        &config.topic,\n        ack_deadline,\n        ttl,\n        config.historical.unwrap_or(false),\n    );\n    subscribe.map(|(created, subscription)| {\n        let mut response = if created {\n            HttpResponse::Created()\n        } else {\n            HttpResponse::Conflict()\n        };\n        response.json(subscription)\n    })\n}", "item_id": 0, "repo": "davidMcneil/qorier", "file": "service/src/http_protocol/subscription_handlers.rs", "last_update_at": "2019-12-21T14:47:59+00:00"}
{"hexsha": "b7ecef4eacbdb112e8837bf86f4b80e3b8e33182", "ext": "rs", "lang": "Rust", "content": "fn ask_with_optional_default<F>(question: &str, default: Option<&str>, validator: F) -> String\n    where\n        F: Fn(String) -> Result<(), String>\n{\n    println!(\"{}{}\", question, default.map(|start| format!(\" [{}]\", start)).unwrap_or(String::new()));\n    let mut buffer = String::new();\n    io::stdin().read_line(&mut buffer).expect(\"Could not read from stdin\");\n    match default {\n        None => {\n            let mut validation_result = validator(buffer.trim().to_string());\n            while buffer.trim().is_empty() || validation_result.is_err() {\n                println!(\"{}\", if buffer.trim().is_empty() { \"Please provide an answer.\".to_string() } else { validation_result.unwrap_err() });\n                buffer.clear();\n                io::stdin().read_line(&mut buffer).expect(\"Could not read from stdin\");\n                validation_result = validator(buffer.trim().to_string());\n            }\n            buffer.trim().to_string()\n        }\n        Some(default_value) =>\n            if buffer.trim().is_empty() {\n                default_value.to_string()\n            } else {\n                let mut validation_result = validator(buffer.trim().to_string());\n                while validation_result.is_err() {\n                    println!(\"{}\", validation_result.unwrap_err());\n                    buffer.clear();\n                    io::stdin().read_line(&mut buffer).expect(\"Could not read from stdin\");\n                    validation_result = validator(buffer.trim().to_string());\n                }\n                buffer.trim().to_string()\n            }\n    }\n}", "item_id": 3, "repo": "SiXoS/No-Project-Time-Tracker", "file": "src/main.rs", "last_update_at": "2019-11-29T23:31:39+00:00"}
{"hexsha": "3048cef1fe3ed92c2a75e92ef6cb649ff367ac1b", "ext": "rs", "lang": "Rust", "content": "fn special_chars_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"?x!+ // -| ]z]]\"#\n        );\n\n        assert_oks!(for lex and buf ;\n            Token::Character('?')\n            Token::Character('x')\n            Token::Character('!')\n            Token::Character('+')\n            Token::Whitespace(' ')\n            Token::Character('/')\n            Token::Character('/')\n            Token::Whitespace(' ')\n            Token::Character('-')\n            Token::Character('|')\n            Token::Whitespace(' ')\n            Token::Character(']')\n            Token::Character('z')\n            Token::Chunk(\"]]\")\n        );\n        assert_none!(for lex and buf);\n    }", "item_id": 1, "repo": "andrewrk/xml-rs", "file": "src/reader/lexer.rs", "last_update_at": "2019-07-10T01:57:50+00:00"}
{"hexsha": "419b76ee1e8daaf42ad8810717a2a1539029d563", "ext": "rs", "lang": "Rust", "content": "pub fn to_absolute_path(path: &Path) -> io::Result<PathBuf> {\n    // IDEA: Provide a flag --real-path for canonicalization of file path?\n    //       Match real paths and/or output real paths? (affect --include and --exclude?)\n    //       Logical: resolve '..' components before symlinks (Windows)\n    //       Physical: resolve symlinks as encountered (Unix)\n    // NOTE: A path like /root/../compo is considered an absolute path, seriously.\n    //       An absolute path is not always a real path (with symlinks fully resolved).\n    if path.is_absolute() {\n        Ok(path.to_path_buf())\n    } else {\n        if *HAS_PWD {\n            let path = path.strip_prefix(\".\").unwrap_or(path);\n\n            Ok((*PWD).join(path))\n        } else {\n            Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"could not resolve relative path into absolute path\",\n            ))\n        }\n    }\n}", "item_id": 0, "repo": "jakwings/find-file", "file": "src/fshelper.rs", "last_update_at": "2019-08-25T18:37:49+00:00"}
{"hexsha": "0b6b0c16e50b21486ecd92e41b394ca64915236c", "ext": "rs", "lang": "Rust", "content": "fn encipher_small() {\n    let rail_fence = RailFence::new(4);\n\n    let ctext = rail_fence.encipher(\"DEFENDTHEEASTWALLOFTHECASTLE\");\n    assert_eq!(ctext.unwrap(), \"DTTFSEDHSWOTATFNEAALHCLEELEE\");\n}", "item_id": 0, "repo": "sradley/cipher", "file": "tests/test_rail_fence.rs", "last_update_at": "2019-08-25T11:07:39+00:00"}
{"hexsha": "f25a31a02a812d218db611088e5f74d52eeb1e1c", "ext": "rs", "lang": "Rust", "content": "fn create_transaction_test() {\n        let manager = SqliteConnectionManager::memory();\n        let pool = r2d2::Pool::new(manager).unwrap();\n        create_base(pool.get().unwrap());\n\n        let id = create_transaction(pool.get().unwrap(), 1, 2, 50, \"Super Payment\");\n\n        assert_eq!(id.unwrap(), 1);\n    }", "item_id": 9, "repo": "DemonusPC/pig-ledger", "file": "src/transaction/db.rs", "last_update_at": "2019-11-22T10:48:45+00:00"}
{"hexsha": "54d6d8efd7e07029294e63de8142cc5e2bb9272d", "ext": "rs", "lang": "Rust", "content": "fn test_i64() {\n    let test: i64 = 0x12345678_90ABCDEF;\n    assert_eq!(from_bytes::<BE, i64>(&[0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF]).unwrap(), test);\n    assert_eq!(from_bytes::<LE, i64>(&[0xEF, 0xCD, 0xAB, 0x90, 0x78, 0x56, 0x34, 0x12]).unwrap(), test);\n  }", "item_id": 7, "repo": "Mingun/serde-pod", "file": "src/de.rs", "last_update_at": "2019-02-15T10:23:51+00:00"}
{"hexsha": "11855d90c160f0af20154f7cdd4a32325dd0b5e5", "ext": "rs", "lang": "Rust", "content": "fn merkle_one_id_should_work() {\n        let ids: Vec<Checksum256> = vec![[1u8; 32].into()];\n        let result = merkle(ids);\n        assert!(result.is_ok());\n        let expect: Checksum256 = [1u8; 32].into();\n        assert_eq!(result.unwrap(), expect);\n    }", "item_id": 7, "repo": "monacohq/rust-eos", "file": "chain/src/merkle.rs", "last_update_at": "2019-12-05T09:54:09+00:00"}
{"hexsha": "e9bad59d21144d285f826a09abafb38ed1827fee", "ext": "rs", "lang": "Rust", "content": "pub fn run() {\n    let mut client = serenity::client::Client::new(config::DISCORD_TOKEN, Handler::new()).expect(\"To create client\");\n\n    client.with_framework(\n        serenity::framework::StandardFramework::new().configure(configure)\n                                                     .help(&HELP)\n                                                     .on_dispatch_error(on_dispatch_error)\n                                                     .group(&GENERAL_GROUP)\n                                                     .group(&ADMIN_GROUP)\n    );\n\n    match client.cache_and_http.http.get_current_user() {\n        Ok(info) => {\n            SELF_ID.store(info.id.0, Ordering::Release);\n        },\n        Err(error) => {\n            rogu::error!(\"Discord unable to get current user info: {}\", error);\n        }\n    }\n\n    if config::DISCORD.with_read(|config| config.owner) == 0 {\n        match client.cache_and_http.http.get_current_application_info() {\n            Ok(info) => {\n                rogu::info!(\"Discord setting new owner id={}\", info.owner.id.0);\n                config::DISCORD.with_write(|config| config.owner = info.owner.id.0);\n            },\n            Err(error) => {\n                rogu::error!(\"Discord unable to get application information: {}\", error);\n                STATS.increment(stats::DiscordNoAppInfo);\n            }\n        };\n    }\n\n    HTTP.write().replace(client.cache_and_http.clone());\n\n    while let Some((tweet_id, user_name, tweet_type)) = twitter::BUFFERED_TWEETS.dequeue() {\n        twitter::redirect_tweet(&client.cache_and_http.http, tweet_id, user_name, tweet_type);\n    }\n\n    loop {\n        rogu::info!(\"Discord: start\");\n        match client.start() {\n            Ok(_) => {\n                STATS.increment(stats::DiscordShutdown);\n                break;\n            }\n            Err(error) => {\n                STATS.increment(stats::DiscordFailure);\n                rogu::warn!(\"Discord stopped with error: {}\", error);\n            }\n        }\n    }\n\n    HTTP.write().take();\n}", "item_id": 0, "repo": "DoumanAsh/Jeanne", "file": "src/discord/mod.rs", "last_update_at": "2019-07-23T08:12:20+00:00"}
{"hexsha": "44e7d0caefd8d4c874ec5bc5d9c66bae2b0ef5e4", "ext": "rs", "lang": "Rust", "content": "pub fn get_sphere_uv(p: Vec3) -> (f32, f32) {\n    let phi = p.z().atan2(p.x());\n    let theta = p.y().asin();\n    let u = 1.0 - (phi + PI) / (2.0 * PI);\n    let v = (theta + PI / 2.0) / PI;\n    (u, v)\n}", "item_id": 1, "repo": "BlackGoku36/RRayTracer", "file": "src/raytrace/vec.rs", "last_update_at": "2019-05-29T19:54:30+00:00"}
{"hexsha": "0dca4d208f861c5e801ff9730ecd5939ebe89970", "ext": "rs", "lang": "Rust", "content": "fn json_ser_simple(b: &mut Bencher) {\n    let value = value();\n    let mut vec = Vec::with_capacity(512);\n    b.iter(|| {\n        let _ = serde_json::to_writer(&mut vec, &value).unwrap();\n        vec.clear();\n    });\n}", "item_id": 1, "repo": "luojia65/coruscant", "file": "coruscant-nbt/benches/nbt-speeds.rs", "last_update_at": "2019-10-19T20:58:42+00:00"}
{"hexsha": "54ff55a37ac8e7a11044c07423baa1b703584212", "ext": "rs", "lang": "Rust", "content": "fn fixed_height() {\n        let (mut tree, root) = layout_tree! {\n            (node(display = Block, size.height = Px(10.)))\n        };\n\n        tree.calculate(root, 0., 10.);\n        assert_eq!(tree.debug(root), \"Block(0.0, 10.0) []\");\n\n        tree.calculate(root, 10., 0.);\n        assert_eq!(tree.debug(root), \"Block(10.0, 10.0) []\");\n    }", "item_id": 1, "repo": "cztomsik/node-webrender", "file": "libgraffiti/src/layout/block.rs", "last_update_at": "2019-03-07T14:40:18+00:00"}
{"hexsha": "07b2dcc89f88ebd13d2e9fb46dabe7784856e641", "ext": "rs", "lang": "Rust", "content": "pub fn verify_client(\n    client: &ExitClientIdentity,\n    client_verified: bool,\n    conn: &PgConnection,\n) -> Result<(), RitaExitError> {\n    use self::schema::clients::dsl::*;\n    let ip = client.global.mesh_ip;\n    let wg = client.global.wg_public_key;\n    let key = client.global.eth_address;\n    let filtered_list = clients\n        .filter(mesh_ip.eq(ip.to_string()))\n        .filter(wg_pubkey.eq(wg.to_string()))\n        .filter(eth_address.eq(key.to_string().to_lowercase()));\n\n    diesel::update(filtered_list)\n        .set(verified.eq(client_verified))\n        .execute(&*conn)?;\n\n    Ok(())\n}", "item_id": 4, "repo": "althea-mesh/althea_rs", "file": "rita_exit/src/database/database_tools.rs", "last_update_at": "2019-06-10T17:42:00+00:00"}
{"hexsha": "e9003be21e9cd0a74b416abdd5eb140f10fddf56", "ext": "rs", "lang": "Rust", "content": "pub fn read<P: AsRef<Path>>(path: P, size_hint: Option<usize>) -> io::Result<(usize, usize, usize)> {\n            let path = path.as_ref();\n            let mut ffr = if let Some(size_hint) = size_hint {\n                FastFile::read(path)\n                    .expect(\"Failed to create FastFileReaderBuilder\")\n                    .with_size_hint(size_hint)\n                    .open()\n                    .expect(\"Failed to open path as FastFile\")\n            } else {\n                FastFile::read(path)\n                    .expect(\"Failed to create FastFileReaderBuilder\")\n                    .open()\n                    .expect(\"Failed to open path as FastFile\")\n            };\n\n            let mut bytes_read = 0usize;\n            let mut sum = 0usize;\n            let mut reads_count = 0usize;\n            loop {\n                let len = match ffr.read() {\n                    Ok(buf) if buf.is_empty() => return Ok((bytes_read, sum, reads_count)),\n                    Ok(buf) => {\n                        sum += buf.iter().map(|x| usize::from(*x)).sum::<usize>();\n                        buf.len()\n                    }\n                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                    Err(e) => return Err(e),\n                };\n                reads_count += 1;\n                bytes_read += len;\n            }\n        }", "item_id": 0, "repo": "lukaspustina/fastfile", "file": "fastfile_benches/src/benches/methods.rs", "last_update_at": "2019-10-10T10:20:51+00:00"}
{"hexsha": "ec17c73f381a5a41e8282bafdbacc2c32fc4504f", "ext": "rs", "lang": "Rust", "content": "fn test_i8() {\n    let test: i8 = 0x12;\n    assert_eq!(to_vec::<BE,_>(&test).unwrap(), vec![0x12]);\n    assert_eq!(to_vec::<LE,_>(&test).unwrap(), vec![0x12]);\n  }", "item_id": 2, "repo": "Mingun/serde-pod", "file": "src/ser.rs", "last_update_at": "2019-02-15T10:23:51+00:00"}
{"hexsha": "f25a31a02a812d218db611088e5f74d52eeb1e1c", "ext": "rs", "lang": "Rust", "content": "pub fn list_transactions(\n    conn: r2d2::PooledConnection<r2d2_sqlite::SqliteConnectionManager>,\n) -> Result<Vec<Transaction>> {\n    let mut stmt = conn.prepare(\"SELECT id, date, name from Transactions ORDER BY date DESC\")?;\n\n    let transactions = stmt\n        .query_map(NO_PARAMS, |row| {\n            Ok(Transaction {\n                id: row.get(0).unwrap(),\n                date: row.get(1).unwrap(),\n                name: row.get(2).unwrap(),\n            })\n        })\n        .and_then(|mapped_rows| {\n            Ok(mapped_rows\n                .map(|row| row.unwrap())\n                .collect::<Vec<Transaction>>())\n        })?;\n\n    Ok(transactions)\n}", "item_id": 4, "repo": "DemonusPC/pig-ledger", "file": "src/transaction/db.rs", "last_update_at": "2019-11-22T10:48:45+00:00"}
{"hexsha": "4af374f4d857972acd76462687db970c5d638c05", "ext": "rs", "lang": "Rust", "content": "async fn extract(intent: &ImportIntent, paths: &Paths) -> Result<(), ImportError> {\n    let extract_new = extract::extract_gzip(paths.store_new(), paths.extract_new())\n        .instrument(debug_span!(\"gzip::new\"));\n\n    if intent.has_old_dump() {\n        let extract_old = extract::extract_gzip(paths.store_old(), paths.extract_old())\n            .instrument(debug_span!(\"gzip::old\"));\n\n        info!(\"extracting old and new indexes\");\n        futures::try_join!(extract_old, extract_new)?;\n    } else {\n        info!(\"extracting new index\");\n        extract_new.await?;\n    };\n\n    Ok(())\n}", "item_id": 2, "repo": "satelit-project/satelit-import", "file": "src/anidb/importer.rs", "last_update_at": "2019-05-27T16:37:09+00:00"}
{"hexsha": "561f2c3356a39fb03a420b702a2019bcb2193606", "ext": "rs", "lang": "Rust", "content": "fn should_stay_idle_when_no_release() {\n\t\tlet (update_policy, _) = update_policy();\n\t\tlet (_client, updater, _, _, ..) = setup(update_policy);\n\n\t\tassert_eq!(updater.state.lock().status, UpdaterStatus::Idle);\n\t\tupdater.poll();\n\t\tassert_eq!(updater.state.lock().status, UpdaterStatus::Idle);\n\t}", "item_id": 4, "repo": "altice-io/Daqiao", "file": "bridge/parity-ethereum/updater/src/updater.rs", "last_update_at": "2019-09-11T12:07:35+00:00"}
{"hexsha": "e049f4062c0057693c0c90e18fb5d6b5ec44bb92", "ext": "rs", "lang": "Rust", "content": "fn problem_2017_2_2() {\n    #![allow(clippy::unwrap_used)]\n    let input = read_to_string(\"src/year2017/day02_input.txt\").unwrap();\n    solve(2017, 2, 2, &input).unwrap();\n}", "item_id": 103, "repo": "fornwall/advent-of-code-2019-rs", "file": "crates/core/benches/iai.rs", "last_update_at": "2019-12-10T00:08:49+00:00"}
{"hexsha": "ba06ea081f0dc27f380ce611f4424033b44f9ce3", "ext": "rs", "lang": "Rust", "content": "fn basic_pipeline() {\n        let pipeline = pipeline! {\n            i32\n            => add2\n            => div_by_3\n            => mul_by_83\n            ;-> f32\n        };\n        let result = pipeline.run(2);\n\n        assert_eq!(result, ((2 + 2) as f64 / 3.0) as f32 * 83.0);\n    }", "item_id": 0, "repo": "Cackbone/pipeline-macro", "file": "src/lib.rs", "last_update_at": "2019-08-23T07:00:17+00:00"}
{"hexsha": "1d74d2e8c42f9bc517d8ccbf2408f9c1e687350f", "ext": "rs", "lang": "Rust", "content": "pub fn longest_common_prefix(strs: Vec<String>) -> String {\n    let mut common = String::new();\n    if strs.len() == 0 {\n        return common;\n    } else if strs.len() == 1 {\n        return strs[0].clone();\n    }\n\n    let mut k: usize = 0;\n    loop {\n        let cur_ch: char;\n        match strs[0].chars().nth(k) {\n            None => {\n                return common;\n            }\n            Some(ch) => {\n                cur_ch = ch;\n            }\n        };\n\n        for i in 1..strs.len() {\n            match strs[i].chars().nth(k) {\n                Some(ch) if cur_ch == ch => {}\n                _ => return common,\n            }\n        }\n\n        common.push(cur_ch);\n        k += 1;\n    }\n}", "item_id": 0, "repo": "yjhmelody/leetcode-rust", "file": "src/longest_common_prefix.rs", "last_update_at": "2019-06-05T06:51:56+00:00"}
{"hexsha": "b8be3287b5d43ce8bc7ea21333e00d3b9139acee", "ext": "rs", "lang": "Rust", "content": "pub fn task( data : &str, iter_count : i32 ) -> i32 {\n    let map = create_map( data );\n    let init = \".#./..#/###\";\n    let init_image = to_image( init );\n    let mut image = init_image;\n    for _ in 0 .. iter_count {\n        let n = to_side( image.len() );\n        let is_by_2 = n % 2 == 0;\n        let is_by_3 = n % 3 == 0;\n        let size = if is_by_2 { 2 } else if is_by_3 { 3 } else { panic!(\"not expacted\") };\n        let image2 : Image2 = split( &image, size );\n        let new_image2 : Image2 = image2.iter()\n            .map( |i| ( *i.0, transform(i.1, &map ) ) ).collect();\n        image = unify( &new_image2 );\n    }\n    image.iter().filter( |i| *i.1 == '#' ).count() as i32\n}", "item_id": 7, "repo": "yury-fedorov/AoC18", "file": "AoC17/rust/src/day21.rs", "last_update_at": "2019-01-21T15:08:21+00:00"}
{"hexsha": "a57cd8f7631515b8061ff79db8646cf271ca5d59", "ext": "rs", "lang": "Rust", "content": "fn connect(name_hash: NameHash, our_uid: UniqueId, listener: &Listener) {\n        const SOCKET_TOKEN: Token = Token(0);\n        let el = unwrap!(Poll::new());\n\n        let (our_pk, our_sk) = gen_encrypt_keypair();\n        let mut sock = unwrap!(TcpSock::connect(&listener.addr));\n        unwrap!(sock.set_encrypt_ctx(EncryptContext::anonymous_encrypt(listener.pub_key)));\n        let shared_key = our_sk.shared_secret(&listener.pub_key);\n        unwrap!(sock.set_decrypt_ctx(DecryptContext::authenticated(shared_key.clone())));\n        unwrap!(el.register(&sock, SOCKET_TOKEN, Ready::writable(), PollOpt::edge()));\n\n        let message = Message::ConnectRequest(our_uid, name_hash, Default::default(), our_pk);\n\n        let mut events = Events::with_capacity(16);\n        'event_loop: loop {\n            let _ = unwrap!(el.poll(&mut events, None));\n            for ev in events.iter() {\n                match ev.token() {\n                    SOCKET_TOKEN => {\n                        if ev.readiness().is_writable() {\n                            let sent = unwrap!(sock.write(Some((message.clone(), 0))));\n                            assert!(sent);\n                            unwrap!(el.reregister(\n                                &sock,\n                                SOCKET_TOKEN,\n                                Ready::readable(),\n                                PollOpt::edge(),\n                            ));\n                        }\n                        if ev.readiness().is_readable() {\n                            let msg: Message<UniqueId> = unwrap!(unwrap!(sock.read()));\n                            let their_uid = match msg {\n                                Message::ConnectResponse(peer_uid, peer_hash) => {\n                                    assert_eq!(peer_uid, listener.uid);\n                                    assert_eq!(peer_hash, NAME_HASH);\n\n                                    unwrap!(sock.set_encrypt_ctx(EncryptContext::authenticated(\n                                        shared_key\n                                    )));\n                                    peer_uid\n                                }\n                                msg => panic!(\"Unexpected message: {:?}\", msg),\n                            };\n                            if our_uid > their_uid {\n                                let message = Message::ChooseConnection::<UniqueId>;\n                                let sent = unwrap!(sock.write(Some((message, 0))));\n                                assert!(sent);\n                            }\n                            break 'event_loop;\n                        }\n                    }\n                    _ => panic!(\"Unexpected event\"),\n                }\n            }\n        }\n\n        match unwrap!(listener.event_rx.recv(), \"Could not read event channel\") {\n            Event::ConnectSuccess(id) => assert_eq!(id, our_uid),\n            event => panic!(\"Unexpected event notification: {:?}\", event),\n        }\n    }", "item_id": 3, "repo": "hbeimf/crust", "file": "src/main/connection_listener/mod.rs", "last_update_at": "2019-01-15T02:34:24+00:00"}
{"hexsha": "027b6a61e28dbcd833904451788b18bd7d052de7", "ext": "rs", "lang": "Rust", "content": "pub fn open(req: OpenRequest) -> super::super::error::Result<()> {\n    let mut hm = ::std::collections::HashMap::new();\n    hm.insert(\"token\".to_owned(), req.token);\n    hm.insert(\"dialog\".to_owned(), serde_json::to_string(&req.dialog)?);\n    hm.insert(\"trigger_id\".to_owned(), req.trigger_id);\n    let response: OpenResponse = super::request(\"dialog.open\", &hm)?;\n\n    if !response.ok {\n        return Err(From::from(\"Bad Slack Response\"));\n    }\n\n    Ok(())\n}", "item_id": 0, "repo": "pbzweihander/old-ip-manager", "file": "src/slack/dialog.rs", "last_update_at": "2019-04-11T12:20:25+00:00"}
{"hexsha": "1ee58ef95cb3db42e6e38ac4c6c773b922bf072a", "ext": "rs", "lang": "Rust", "content": "fn test_seek_maximum() {\n        let mut sub_cursor = SubCursor::new().start(0).end(usize::max_value());\n\n        sub_cursor.seek(SeekFrom::Current(1)).unwrap();\n\n        let position = sub_cursor\n            .seek(SeekFrom::Current(u64::max_value() as i64))\n            .unwrap();\n\n        assert_eq!(position, 0);\n\n        sub_cursor.seek(SeekFrom::Current(2)).unwrap();\n\n        let position = sub_cursor\n            .seek(SeekFrom::Current(u64::max_value() as i64))\n            .unwrap();\n\n        assert_eq!(position, 1);\n\n        let position = sub_cursor.seek(SeekFrom::Start(u64::max_value())).unwrap();\n        assert_eq!(position, 0);\n    }", "item_id": 0, "repo": "Luro02/SubCursor", "file": "src/sub_cursor.rs", "last_update_at": "2019-10-30T10:39:22+00:00"}
{"hexsha": "81a9fdea48ce9dcc5294dfa4ab94ca9cf80eada2", "ext": "rs", "lang": "Rust", "content": "fn get_mock_update_to_latest_ledger(\n    req: &UpdateToLatestLedgerRequest,\n) -> UpdateToLatestLedgerResponse {\n    let mut resp = UpdateToLatestLedgerResponse::new();\n    for request_item in req.get_requested_items().iter() {\n        resp.mut_response_items()\n            .push(get_mock_response_item(request_item).unwrap());\n    }\n    let mut ledger_info = types::proto::ledger_info::LedgerInfo::new();\n    ledger_info.set_transaction_accumulator_hash(HashValue::zero().to_vec());\n    ledger_info.set_consensus_data_hash(HashValue::zero().to_vec());\n    ledger_info.set_consensus_block_id(HashValue::zero().to_vec());\n    ledger_info.set_version(7);\n    let mut ledger_info_with_sigs = ProtoLedgerInfoWithSignatures::new();\n    ledger_info_with_sigs.set_ledger_info(ledger_info);\n    resp.set_ledger_info_with_sigs(ledger_info_with_sigs);\n    resp\n}", "item_id": 0, "repo": "ts25504/libra", "file": "storage/storage_service/src/mocks/mock_storage_client.rs", "last_update_at": "2019-09-26T17:16:41+00:00"}
{"hexsha": "c54db15f30cff27fe0e28f1218b83293f87d063a", "ext": "rs", "lang": "Rust", "content": "fn create_ac_client(conn_addr: &str) -> AdmissionControlClient {\n    let env_builder = Arc::new(EnvBuilder::new().name_prefix(\"ac-grpc-\").build());\n    let ch = ChannelBuilder::new(env_builder).connect(&conn_addr);\n    AdmissionControlClient::new(ch)\n}", "item_id": 1, "repo": "vgao1996/libra", "file": "benchmark/src/bin/ruben.rs", "last_update_at": "2019-09-24T19:26:07+00:00"}
{"hexsha": "4f1eff5ab7f706e1985fe1f023a02960c15d529c", "ext": "rs", "lang": "Rust", "content": "fn p_one() -> i32 {\n    let limit = 576723;\n    let mut hits = 0;\n    let mut password = 109165;\n    while password < limit {\n        let mut digits: Vec<u32> = split(password);\n        make_inc(&mut digits);\n        password = revert_to_number(&digits);\n        if password > limit {\n            break;\n        }\n        if has_double(&digits) {\n            hits = hits + 1;\n        }\n        password = password + 1;\n    }\n\n    hits\n}", "item_id": 0, "repo": "VuQuangPhuc/AdventOfCode2019", "file": "src/day_04/mod.rs", "last_update_at": "2019-12-11T20:38:00+00:00"}
{"hexsha": "ea66f9b181d23da56328a4bd97b96f8629cf11c2", "ext": "rs", "lang": "Rust", "content": "fn trim_input(user_input: &mut String) {\n    // Something like trim (perhaps just use `trim`?)\n    if let Some('\\n') = user_input.chars().next_back() {\n        user_input.pop();\n    }\n    if let Some('\\r') = user_input.chars().next_back() {\n        user_input.pop();\n    }\n}", "item_id": 0, "repo": "raventid/renard", "file": "src/repl.rs", "last_update_at": "2019-03-20T16:30:33+00:00"}
{"hexsha": "d9449e8de10a9133e484394fe9859bc91333bdb7", "ext": "rs", "lang": "Rust", "content": "fn stored_configuration_toml() {\n        let original = create_test_configuration();\n        let toml = toml::to_string(&original).unwrap();\n        let deserialized: StoredConfiguration = toml::from_str(&toml).unwrap();\n        assert_eq!(original, deserialized);\n    }", "item_id": 0, "repo": "fossabot/exonum", "file": "exonum/src/blockchain/config.rs", "last_update_at": "2019-10-21T13:25:28+00:00"}
{"hexsha": "ffef2c29479bce5ac9e6e0c155f6b7a23d555af7", "ext": "rs", "lang": "Rust", "content": "fn hash( string: String ) -> String {\n    let mut hasher = Sha1::new();\n    hasher.update( string.as_bytes() );\n    hasher.digest().to_string()\n}", "item_id": 0, "repo": "tomhoule/stdweb", "file": "examples/hasher/src/main.rs", "last_update_at": "2019-09-20T16:35:23+00:00"}
{"hexsha": "2b0c35ce77cefeb0c4ca7fe0d3381aac8a734270", "ext": "rs", "lang": "Rust", "content": "fn start_lobby() {\n    let mut client = common::setup();\n    client.send(1, \".n 1\");\n    client.send(1, \".m\");\n    client.send(2, \".n 2\");\n    client.send(2, \".j 1\");\n    client.send(1, \".s\");\n    client.read_all();\n    assert!(client\n        .last(1)\n        .contains(\"You are the THRUSTEE. Choose NOW..........\"));\n    assert!(client\n        .last(2)\n        .contains(\"You are a THRUSTER. waiting for a good THRUSTEE from 1; mmm baby!\"));\n}", "item_id": 3, "repo": "maxrchung/THRUSTIN", "file": "backend/tests/lobby_navigation.rs", "last_update_at": "2019-04-06T22:07:11+00:00"}
{"hexsha": "8a90f06ca17e46ceee5442f95de6c867ec26f2f8", "ext": "rs", "lang": "Rust", "content": "fn parse_baseframe( mut buf: & str, num_joints: Option< u64 > ) -> Result< ( & str, Vec< FrameJoint > ), & 'static str > {\n\n    let mut baseframe : Vec< FrameJoint > = vec![];\n    \n    match md5anim_baseframe_opening( buf ) {\n        nom::IResult::Done( i, o ) => {\n            buf = i;\n        },\n        _ => {\n            return Err( \"baseframe opening token not found\" )\n        },\n    }\n    match num_joints {\n        None => {\n            return Err( \"num joints not specified at point of baseframe parsing\" )\n        },\n        _ => {},\n    }\n    \n    let n = num_joints.unwrap();\n    let mut count = 0;\n    while count < n {\n        match peek_and_consume_comments( buf ) {\n            Some(x) => {\n                buf = x;\n                continue;\n            },\n            _ => {}\n        }\n        match md5anim_baseframe( buf ) {\n            nom::IResult::Done( i, mut o ) => {\n                buf = i;\n                o._index = count as u64; //set index\n                baseframe.push( o );\n            },\n            _ => {\n                return Err(\"bounds parse unsuccessful\")\n            },\n        }\n\n        count += 1;\n    }                \n\n    match peek_and_consume_comments( buf ) {\n        Some(x) => {\n            buf = x;\n        },\n        _ => {}\n    }\n\n    match md5anim_baseframe_closing( buf ) {\n        nom::IResult::Done( i, o ) => {\n            buf = i;\n        },\n        _ => {},\n    }\n\n    match peek_and_consume_comments( buf ) {\n        Some(x) => { buf = x; },\n        _ => {},\n    }\n\n    Ok( ( buf, baseframe ) )\n}", "item_id": 2, "repo": "clearlycloudy/e2", "file": "core/implement/file/md5anim_nom.rs", "last_update_at": "2019-11-16T21:20:44+00:00"}
{"hexsha": "c843c54f6a0f77e2fb96eb50cd973380d45b90c5", "ext": "rs", "lang": "Rust", "content": "pub fn spiral_matrix(size: u32) -> Vec<Vec<u32>> {\n    let size = size as usize;\n    if size == 0 {\n        return Vec::new();\n    } else if size == 1 {\n        return vec![vec![1; size]; size];\n    }\n    let mut spiral: Vec<Vec<u32>> = vec![vec![0; size]; size];\n\n    let mut i = 0;\n    let mut j = 0;\n    let mut val = 1;\n    let mut moving = State::MovingRight;\n\n    while spiral[i][j] == 0 {\n        spiral[i][j] = val;\n        val += 1;\n        match moving {\n            State::MovingRight => {\n                if j == size - 1 || spiral[i][j + 1] != 0 {\n                    i += 1;\n                    moving = State::MovieDown;\n                } else {\n                    j += 1;\n                }\n            }\n            State::MovieDown => {\n                if i == size - 1 || spiral[i + 1][j] != 0 {\n                    j -= 1;\n                    moving = State::MovingLeft;\n                } else {\n                    i += 1;\n                }\n            }\n            State::MovingLeft => {\n                println!(\"{:?}\", (i, j));\n                if j == 0 || spiral[i][j - 1] != 0 {\n                    i -= 1;\n                    moving = State::MovingUp\n                } else {\n                    j -= 1;\n                }\n            }\n            State::MovingUp => {\n                if i == 0 || spiral[i - 1][j] != 0 {\n                    j += 1;\n                    moving = State::MovingRight;\n                } else {\n                    i -= 1\n                }\n            }\n        }\n    }\n\n    spiral\n}", "item_id": 0, "repo": "Dimkar3000/exercism", "file": "rust/spiral-matrix/src/lib.rs", "last_update_at": "2019-11-09T09:44:41+00:00"}
{"hexsha": "159f6eeae51553bfec2097e8b9fa0cb56f76db0e", "ext": "rs", "lang": "Rust", "content": "fn coords_can_be_subtracted() {\n        let left = Coord::new(30, 40);\n        let right = Coord::new(10, 20);\n\n        assert_eq!(left - right, Coord::new(20, 20));\n    }", "item_id": 1, "repo": "mmou/embedded-graphics", "file": "embedded-graphics/src/coord.rs", "last_update_at": "2019-07-16T02:31:01+00:00"}
{"hexsha": "4dc9d67aea24d51052b9f28b34b9f377263483ee", "ext": "rs", "lang": "Rust", "content": "fn test_as_number() {\n        // bytestring is a number\n        let num = as_number::<u64>(vec![b'1', b'2']).unwrap();\n        assert_eq!(num, 12);\n\n        // bytestring is not a number\n        let err = as_number::<u64>(vec![b' ', b'1', b'2']).unwrap_err();\n        assert_eq!(err, TcpTransportError::NumberParseError);\n    }", "item_id": 1, "repo": "numerodix/memcache.rs", "file": "src/tcp_transport/conversions.rs", "last_update_at": "2019-08-21T20:55:07+00:00"}
{"hexsha": "5cb84beea124480ed2fce88c87e31da1965ff14a", "ext": "rs", "lang": "Rust", "content": "pub fn fetch(instr_mem: &dyn MemoryAccess, pc: u32) -> Result<(u32, u32), FetchError> {\n    alignment_check(pc)?;\n\n    let instr = instr_mem.read_u32(pc as usize)?;\n    let next_pc = pc + 4;\n    Ok((instr, next_pc))\n}", "item_id": 0, "repo": "tomoyuki-nakabayashi/Rustemu86", "file": "arch/riscv/src/fetch.rs", "last_update_at": "2019-02-07T05:27:30+00:00"}
{"hexsha": "99ec1b268c51c3421dd383fb23681b4c110262f0", "ext": "rs", "lang": "Rust", "content": "fn make_pocket_enum_declaration(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R, arg3 : Self::R, arg4 : Self::R, arg5 : Self::R) -> (State, Self::R) {\n        let s = State::next(s, &[&arg0, &arg1, &arg2, &arg3, &arg4, &arg5]);\n        let r = Self::R::make_pocket_enum_declaration(&s, arg0, arg1, arg2, arg3, arg4, arg5);\n        (s, r)\n    }", "item_id": 167, "repo": "jeffomatic/hhvm", "file": "hphp/hack/src/parser/syntax_smart_constructors_generated.rs", "last_update_at": "2019-07-21T09:08:35+00:00"}
{"hexsha": "203f7b00ab1186a5ef888404f0c41f06f9eeb3d6", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn xdg_popup_configure(mut data: *mut libc::c_void,\n                                         mut xdg_popup: *mut xdg_popup,\n                                         mut x: int32_t, mut y: int32_t,\n                                         mut width_0: int32_t,\n                                         mut height_0: int32_t) {\n    _wlr_log(WLR_DEBUG,\n             b\"[%s:%d] Popup configured %dx%d@%d,%d\\x00\" as *const u8 as\n                 *const libc::c_char,\n             b\"../examples/layer-shell.c\\x00\" as *const u8 as\n                 *const libc::c_char, 181i32, width_0, height_0, x, y);\n    popup_width = width_0 as uint32_t;\n    popup_height = height_0 as uint32_t;\n    if !popup_egl_window.is_null() {\n        wl_egl_window_resize(popup_egl_window, width_0, height_0, 0i32, 0i32);\n    };\n}", "item_id": 14, "repo": "RoastVeg/wlrusts", "file": "src/examples/layer_shell.rs", "last_update_at": "2019-12-10T16:29:26+00:00"}
{"hexsha": "4bcd4416d1f71112f228d505492b8211eaceecfb", "ext": "rs", "lang": "Rust", "content": "fn json_str_vec_to_yaml() {\n        let input = serde_json::to_value(&vec![\"foo\"]);\n        let output = serde_yaml::Value::Array(vec![serde_yaml::Value::String(\"foo\".to_owned())]);\n        assert_eq!(to_yaml(&input).unwrap(), output);\n    }", "item_id": 0, "repo": "softprops/jamal", "file": "src/lib.rs", "last_update_at": "2019-08-10T14:26:07+00:00"}
{"hexsha": "e9c1ce20b302b0326aedf17d9dd8d687e7361261", "ext": "rs", "lang": "Rust", "content": "unsafe fn mi_realloc_zero_aligned_at(mut p: *mut c_void, mut newsize: usize,\n                                     mut alignment: usize, mut offset: usize,\n                                     mut zero: bool) -> *mut c_void {\n    if alignment > 0 {\n        0\n    } else {\n        _mi_assert_fail(\"alignment > 0\", \"src/alloc-aligned.c\", 90,\n                        \"mi_realloc_zero_aligned_at\")\n    }\n    if alignment <= std::mem::size_of::<usize>() {\n        return _mi_realloc_zero(p, newsize, zero != 0);\n    }\n    if p.is_null() {\n        return mi_malloc_zero_aligned_at(newsize, alignment, offset,\n                                         zero != 0);\n    }\n    let mut size = mi_usable_size(p);\n    if newsize <= size && newsize >= (size - (size / 2)) &&\n           (((p as usize) + offset) % alignment) == 0 {\n        return p;\n    } else {\n        let mut newp = mi_malloc_aligned_at(newsize, alignment, offset);\n        if !newp.is_null() {\n            if zero != 0 != 0 && newsize > size {\n                // also set last word in the previous allocation to zero to ensure any padding is zero-initialized\n                let mut start =\n                    if size >= std::mem::size_of::<isize>() {\n                        size - std::mem::size_of::<isize>()\n                    } else { 0 }; // only free if successful\n                memset((newp as *mut u8).offset(start), 0,\n                       newsize -\n                           start); // use offset of previous allocation (p can be NULL)\n            }\n            memcpy(newp, p as *const c_void,\n                   if newsize > size { size } else { newsize });\n            mi_free(p);\n        }\n        return newp;\n    };\n}", "item_id": 3, "repo": "rusch95/mimalloc-rs", "file": "mimalloc-sys/rust_impl/citrus/alloc-aligned.rs", "last_update_at": "2019-10-20T05:44:39+00:00"}
{"hexsha": "28be31fdab926ee2f934b2f9d1a00757e8b486b4", "ext": "rs", "lang": "Rust", "content": "fn tear(\n    input: image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>>,\n    rng: &mut rand_xoshiro::Xoshiro256StarStar,\n    max_times: u32,\n    max_thickness: u32,\n    max_amount: u32,\n    range: u32,\n) -> image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>> {\n    println!(\"Tear FX\");\n\n    let mut output = input.clone();\n    let (width, height) = input.dimensions();\n    let range_begin = if height - range == 0 { 0 } else { rng.gen_range(0, height - range) };\n\n    let shift_times = (rng.gen::<f64>() * max_times as f64).floor() as u64;\n    for _ in 0..shift_times {\n        let begin_y = rng.gen_range(0, range) + range_begin;\n        let thickness = rng.gen_range(0, max_thickness);\n        let amount = rng.gen_range(0, max_amount);\n        let direction = rng.gen_range(0, 2);\n\n        if direction == 0 { // ->\n            for x in 0..amount { // \u7aef\u3092\u30df\u30e9\u30fc\u30ea\u30f3\u30b0\n                let max_y = cmp::min(height, begin_y + thickness);\n                for y in begin_y..max_y {\n                    output.put_pixel(x, y, *input.get_pixel(amount - x, y));\n                }\n            }\n            for x in amount..width {\n                let max_y = cmp::min(height, begin_y + thickness);\n                for y in begin_y..max_y {\n                    output.put_pixel(x, y, *input.get_pixel(x - amount, y));\n                }\n            }\n        } else { // <-\n            for x in (width - amount)..width { // \u7aef\u3092\u30df\u30e9\u30fc\u30ea\u30f3\u30b0\n                let max_y = cmp::min(height, begin_y + thickness);\n                for y in begin_y..max_y {\n                    output.put_pixel(x, y, *input.get_pixel(width - (x - (width - amount)) - 1, y));\n                }\n            }\n            for x in 0..(width - amount) {\n                let max_y = cmp::min(height, begin_y + thickness);\n                for y in begin_y..max_y {\n                    output.put_pixel(x, y, *input.get_pixel(x + amount, y));\n                }\n            }\n        }\n    }\n\n    output\n}", "item_id": 5, "repo": "syuilo/glitch-studio-rs", "file": "src/main.rs", "last_update_at": "2019-09-16T23:30:56+00:00"}
{"hexsha": "caae2b7a6aa584af89eaa322d7e3011277b83992", "ext": "rs", "lang": "Rust", "content": "extern \"C\" fn read_data_safe(ptr: *mut Pixel, len: usize) {\n    println!(\"Reading safely from instance {:?}\", *INSTANCE);\n\n    let data: Vec<Pixel> = INSTANCE.rx\n        .iter()\n        .take(len)\n        .collect();\n\n    let ptr = data.as_ptr();\n\n}", "item_id": 3, "repo": "borismarin/microscopio", "file": "arch/threaded/server/src/lib.rs", "last_update_at": "2019-07-25T17:41:34+00:00"}
{"hexsha": "8ba64be453af66291a90197773b7ec8d6ae86ce4", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    println!(\"Starting Queue\");\n    let mut head = Node {\n        name: \"head\".to_string(),\n        next: None,\n    };\n\n    loop {\n        let mut input = String::new();\n        println!(\"Next action please\");\n        stdin().read_line(&mut input);\n\n        let cloned = input.clone();\n        let items = cloned.split(' ');\n        let mut cmds: Vec<&str> = items.collect();\n        let command = cmds[0].trim_end();\n\n        match command {\n            command if command == \"push\" => {\n                let name = cmds[1].trim_end().to_string();\n                head.push(name);\n            }\n            command if command == \"pop\" => match head.clone().pop() {\n                None => head.next = None,\n                Some(ref mut node) => head.next = Some(Box::new(node.clone())),\n            },\n            command if command == \"print\" => {\n                head.print(0);\n            }\n            command if command == \"count\" => {\n                head.count(0);\n            }\n            command if command == \"quit\" => {\n                println!(\"Good Bye\");\n                break;\n            }\n            _ => println!(\"Invalid command\"),\n        }\n    }\n    drop(head);\n}", "item_id": 0, "repo": "MatthewFrisby/Rust-Data-Structures", "file": "Queue with Linked List/Queue_with_LL.rs", "last_update_at": "2019-07-21T20:10:35+00:00"}
{"hexsha": "3dcb4abc314f4804e5cb7dd717e5662dc3d48f57", "ext": "rs", "lang": "Rust", "content": "fn delete_user() {\n    let client = Graph::new(\"ACCESS_TOKEN\");\n\n    let response = client.v1().user(USER_ID).delete_user().send().unwrap();\n\n    println!(\"{:#?}\", response);\n}", "item_id": 5, "repo": "DevLazio/graph-rs", "file": "examples/users.rs", "last_update_at": "2019-04-14T21:43:36+00:00"}
{"hexsha": "75df2846d4cbf5d8886a55eb69ef935f8b37a1d1", "ext": "rs", "lang": "Rust", "content": "pub fn wif_compressed(priv_key: &SecretKey) -> WIFCompressed {\n    let decoded = base16::decode(priv_key.to_string().as_bytes()).unwrap();\n    let mut wc = Vec::with_capacity(decoded.len()+1);\n    wc.extend_from_slice(&decoded);\n    wc.push(constants::BITCOIN_WIF_COMPRESSED_SUFFIX);\n    encode_base58_check(constants::BITCOIN_PRIVATE_KEY_WIF_VERSION_PREFIX, &wc)\n}", "item_id": 2, "repo": "michaelsdunn1/bitcoin", "file": "src/keys.rs", "last_update_at": "2019-01-17T15:55:24+00:00"}
{"hexsha": "99ec1b268c51c3421dd383fb23681b4c110262f0", "ext": "rs", "lang": "Rust", "content": "fn make_braced_expression(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R) -> (State, Self::R) {\n        let s = State::next(s, &[&arg0, &arg1, &arg2]);\n        let r = Self::R::make_braced_expression(&s, arg0, arg1, arg2);\n        (s, r)\n    }", "item_id": 102, "repo": "jeffomatic/hhvm", "file": "hphp/hack/src/parser/syntax_smart_constructors_generated.rs", "last_update_at": "2019-07-21T09:08:35+00:00"}
{"hexsha": "90bf85eca0ffa7db9371046e8587a54f62c4813c", "ext": "rs", "lang": "Rust", "content": "pub fn get_random_peers(\n    conn: &Connection,\n    count: u32,\n    expired_at_ms: u64,\n) -> DBResult<Vec<PeerId>> {\n    // random select peers that we have connect to recently.\n    let mut stmt = conn.prepare(\n        \"SELECT peer_id FROM peer_info \n                                WHERE ban_time_secs < strftime('%s','now') \n                                AND last_connected_at_secs > :time \n                                ORDER BY RANDOM() LIMIT :count\",\n    )?;\n    let rows = stmt.query_map_named(\n        &[\n            (\":count\", &count),\n            (\":time\", &millis_to_secs(expired_at_ms)),\n        ],\n        |row| Ok(PeerId::from_bytes(row.get(0)?).expect(\"parse peer_id\")),\n    )?;\n    rows.collect::<Result<Vec<_>, _>>().map_err(Into::into)\n}", "item_id": 1, "repo": "nervoscommunity/ckb-miner-opt", "file": "network/src/peer_store/sqlite/db.rs", "last_update_at": "2019-07-05T05:50:43+00:00"}
{"hexsha": "3d9c204ab5e87806b487b1e18376ede4b321b8a6", "ext": "rs", "lang": "Rust", "content": "pub fn find_or_create_venv(\n    cfg_vers: &Version,\n    pypackages_dir: &Path,\n    pyflow_dir: &Path,\n    dep_cache_path: &Path,\n) -> (PathBuf, Version) {\n    let venvs = find_venvs(pypackages_dir);\n    // The version's explicitly specified; check if an environment for that version\n    let compatible_venvs: Vec<&(u32, u32)> = venvs\n        .iter()\n        .filter(|(ma, mi)| cfg_vers.major == Some(*ma) && cfg_vers.minor == Some(*mi))\n        .collect();\n\n    let vers_path;\n    let py_vers;\n    match compatible_venvs.len() {\n        0 => {\n            let vers =\n                py_versions::create_venv(cfg_vers, pypackages_dir, pyflow_dir, dep_cache_path);\n            vers_path = pypackages_dir.join(vers.to_string_med());\n            py_vers = Version::new_opt(vers.major, vers.minor, None); // Don't include patch.\n        }\n        1 => {\n            vers_path = pypackages_dir.join(&format!(\n                \"{}.{}\",\n                compatible_venvs[0].0, compatible_venvs[0].1\n            ));\n            py_vers = Version::new_short(compatible_venvs[0].0, compatible_venvs[0].1);\n        }\n        _ => {\n            abort(\n                // todo: Handle this, eg by letting the user pick the one to use?\n                \"Multiple compatible Python environments found\n                for this project.\",\n            )\n        }\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        (vers_path, py_vers)\n    }\n\n    #[cfg(target_os = \"linux\")]\n    {\n        let vers_path = fs::canonicalize(vers_path);\n        let vers_path = match vers_path {\n            Ok(path) => path,\n            Err(error) => {\n                abort(&format!(\n                    \"Problem converting path to absolute path: {:?}\",\n                    error\n                ));\n                unreachable!()\n            }\n        };\n        (vers_path, py_vers)\n    }\n\n    #[cfg(target_os = \"macos\")]\n    {\n        let vers_path = fs::canonicalize(vers_path);\n        let vers_path = match vers_path {\n            Ok(path) => path,\n            Err(error) => abort(&format!(\n                \"Problem converting path to absolute path: {:?}\",\n                error\n            )),\n        };\n        (vers_path, py_vers)\n    }\n}", "item_id": 9, "repo": "sthagen/David-OConnor-pyflow", "file": "src/util/mod.rs", "last_update_at": "2019-09-11T09:22:37+00:00"}
{"hexsha": "d025ee16b7b0876b786f6337c60abdfc0ac61309", "ext": "rs", "lang": "Rust", "content": "pub fn send(config: &ServerSettings, message: &String) -> SendResult {\n    let mut socket = Socket::new(Protocol::Req).unwrap();\n    let mut endpoint = socket.connect(&config.url[..]).unwrap();\n    let mut reply = String::new();\n\n    debug!(\"send.socket.write_all: {}\", message);\n\n    socket.write_all(message.as_bytes())\n        .map_err(|err| { error!(\"send.socket.write_all: {}\", err); err })\n        .and_then(|_| {\n            socket.read_to_string(&mut reply)\n                .map_err(|err| { error!(\"send.socket.read_to_string: {}\", err); err })\n        })\n        .map_err(|err| {\n            let _ = endpoint.shutdown()\n                .map_err(|err| error!(\"send.endpoint.shutdown: {}\", err) );\n            err\n        })?;\n\n    debug!(\"send.reply: {}\", reply);\n\n    let _ = endpoint.shutdown()\n        .map_err(|err| error!(\"send.endpoint.shutdown: {}\", err) );\n    return Ok(reply);\n}", "item_id": 0, "repo": "irony-rust/dots", "file": "lib/src/protocols/reqrep.rs", "last_update_at": "2019-02-26T07:28:48+00:00"}
{"hexsha": "ef73092254983280efce6aedce3fd2de6b0c3b43", "ext": "rs", "lang": "Rust", "content": "fn send_send() {\n    let (send, _recv) = super::new();\n    send.send(1u8).unwrap();\n    assert_eq!(send.send(1u8).unwrap_err(), (1, Error::Full));\n}", "item_id": 3, "repo": "mahkoh/comm", "file": "src/spsc/one_space/test.rs", "last_update_at": "2019-06-03T17:03:36+00:00"}
{"hexsha": "9636b48c2daa3c3b541943dd47a29eb3d35d6b32", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    local_deprecated!(); //~ WARN use of deprecated item 'local_deprecated': local deprecation note\n    deprecated_macro!(); //~ WARN use of deprecated item 'deprecated_macro': deprecation note\n}", "item_id": 0, "repo": "Timmmm/rust", "file": "src/test/ui/macros/macro-deprecation.rs", "last_update_at": "2019-12-10T20:07:24+00:00"}
{"hexsha": "7bcafbc527a27944c206358ec81bf88cc10d2e1e", "ext": "rs", "lang": "Rust", "content": "fn create_coordinate_subarrays_3d<F: BFloat, const N_POINTS: usize>(\n    crosses_periodic_bound: &In3D<bool>,\n    coords: &CoordRefs3<F>,\n    extents: &Vec3<F>,\n    start_indices: &Idx3<isize>,\n) -> ([F; N_POINTS], [F; N_POINTS], [F; N_POINTS]) {\n    let x_coord_subarray = if crosses_periodic_bound[X] {\n        create_coordinate_subarray_for_periodic::<_, N_POINTS>(\n            coords[X],\n            extents[X],\n            start_indices[X],\n        )\n    } else {\n        create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[X], start_indices[X])\n    };\n    let y_coord_subarray = if crosses_periodic_bound[Y] {\n        create_coordinate_subarray_for_periodic::<_, N_POINTS>(\n            coords[Y],\n            extents[Y],\n            start_indices[Y],\n        )\n    } else {\n        create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[Y], start_indices[Y])\n    };\n    let z_coord_subarray = if crosses_periodic_bound[Z] {\n        create_coordinate_subarray_for_periodic::<_, N_POINTS>(\n            coords[Z],\n            extents[Z],\n            start_indices[Z],\n        )\n    } else {\n        create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[Z], start_indices[Z])\n    };\n    (x_coord_subarray, y_coord_subarray, z_coord_subarray)\n}", "item_id": 14, "repo": "lars-frogner/bifrost-rust", "file": "src/interpolation/poly_fit.rs", "last_update_at": "2019-10-24T07:24:05+00:00"}
{"hexsha": "5b184d4e24859fdd22ebd6aee1c206c05230a6f8", "ext": "rs", "lang": "Rust", "content": "fn recv_close_gets_none_idle() {\n    let (mut tx, mut rx) = mpsc::channel::<i32>(10);\n    let mut task = MockTask::new();\n\n    rx.close();\n\n    task.enter(|| {\n        let val = assert_ready!(rx.poll());\n        assert!(val.is_none());\n        assert!(tx.poll_ready().is_err());\n    });\n}", "item_id": 7, "repo": "AmpMe/tokio", "file": "tokio-sync/tests/mpsc.rs", "last_update_at": "2019-10-20T00:22:31+00:00"}
{"hexsha": "07d3c69498cd95b7c29a43403d451c0281bec4fc", "ext": "rs", "lang": "Rust", "content": "fn test_intersection_none() {\n        let r1 = RectRange::from_ranges(4..7, 3..5).unwrap();\n        let r2 = RectRange::from_ranges(7..9, 5..6).unwrap();\n        assert!(r1.intersection(&r2).is_none());\n    }", "item_id": 5, "repo": "kngwyu/rect-iter", "file": "src/lib.rs", "last_update_at": "2019-10-31T11:14:55+00:00"}
{"hexsha": "8c5da4c29637725a8ea05ff3f2acc0fd5947f2d9", "ext": "rs", "lang": "Rust", "content": "fn type_create_works() {\n        TestUtils::cleanup_sovrin_home();\n\n        let wallet_type = DefaultWalletType::new();\n        wallet_type.create(\"wallet1\", None, None).unwrap();\n\n        TestUtils::cleanup_sovrin_home();\n    }", "item_id": 2, "repo": "evernym/sovrin-client-rust2", "file": "src/services/wallet/default.rs", "last_update_at": "2019-06-11T14:47:13+00:00"}
{"hexsha": "fca924f526160ff35a76982b32c8bef963bf7e64", "ext": "rs", "lang": "Rust", "content": "fn it_resolves() {\n        let c = setup(false);\n        assert_eq!(\n            c.node().resolve(0),\n            Some(vec![(c.narrow_base_id().as_global(), 0)])\n        );\n        assert_eq!(c.node().resolve(1), None);\n    }", "item_id": 6, "repo": "alanamarzoev/noria", "file": "noria-server/dataflow/src/ops/grouped/aggregate.rs", "last_update_at": "2019-07-01T00:50:18+00:00"}
{"hexsha": "846dfa56e4e9ff121ac577ff5b11d279c4e15dcf", "ext": "rs", "lang": "Rust", "content": "fn generate_rsa() {\n        let mut pk =\n            Pk::generate_rsa(&mut crate::test_support::rand::test_rng(), 2048, 0x10001).unwrap();\n        let generated = pk.write_private_pem_string().unwrap();\n        assert_eq!(0x10001, pk.rsa_public_exponent().unwrap());\n        assert_eq!(generated, TEST_PEM[..TEST_PEM.len() - 1]);\n    }", "item_id": 0, "repo": "lkatalin/mbedtls", "file": "src/pk/mod.rs", "last_update_at": "2019-10-09T18:26:37+00:00"}
{"hexsha": "565c1c80b8d9d0a78dea728266f693f25c27f2d0", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut file = read_file(\"input.txt\");\n    let l1 = file.nth(0).unwrap();\n    let l1 = l1.split(',').map(|s| s.chars());\n    let l2 = file.nth(0).unwrap();\n    let l2 = l2.split(',').map(|s| s.chars());\n\n    let mut l1_points_hash = HashSet::new();\n    let mut x: i32 = 0;\n    let mut y: i32 = 0;\n    let mut l1_points = vec![(x, y)];\n    for mut line in l1 {\n        let dir = line.next().unwrap();\n        let number = line.as_str().parse::<i32>().unwrap();\n        for _ in 0..number {\n            match dir {\n                'R' => x += 1,\n                'D' => y += 1,\n                'U' => y -= 1,\n                'L' => x -= 1,\n                _ => panic!(\"invalid\"),\n            }\n            l1_points.push((x, y));\n            l1_points_hash.insert((x, y));\n        }\n    }\n\n    let mut candidate_points = Vec::new();\n\n    let mut min_dist = std::i32::MAX;\n    x = 0;\n    y = 0;\n    let mut l2_points = vec![(x, y)];\n    l2_points.push((x, y));\n    for mut line in l2 {\n        let dir = line.next().unwrap();\n        let number = line.as_str().parse::<i32>().unwrap();\n        for _ in 0..number {\n            match dir {\n                'R' => x += 1,\n                'D' => y += 1,\n                'U' => y -= 1,\n                'L' => x -= 1,\n                _ => panic!(\"invalid\"),\n            }\n            l2_points.push((x, y));\n            if l1_points_hash.contains(&(x, y)) {\n                candidate_points.push((x, y)); // needed for part2\n                if x.abs() + y.abs() < min_dist {\n                    min_dist = x.abs() + y.abs();\n                }\n            }\n        }\n    }\n    //answer to part1\n    println!(\"distance:{}\", min_dist);\n\n    //Now compute steps for all candidate points\n    let mut min_steps = std::usize::MAX;\n    for (px, py) in candidate_points {\n        let l1_steps = l1_points\n            .iter()\n            .take_while(|(x, y)| *x != px || *y != py)\n            .count();\n        let l2_steps = l2_points\n            .iter()\n            .take_while(|(x, y)| *x != px || *y != py)\n            .count();\n        let sum = l1_steps + l2_steps;\n        if sum < min_steps {\n            min_steps = sum;\n        }\n    }\n\n    println!(\"steps:{}\", min_steps);\n}", "item_id": 0, "repo": "jackmott/advent2019", "file": "day_03/src/main.rs", "last_update_at": "2019-12-26T01:11:07+00:00"}
{"hexsha": "fe6c8a7fe7303b729df325b6ab28632a5fc594ad", "ext": "rs", "lang": "Rust", "content": "pub fn task2( map: &Vec<String> ) -> usize {\n    let n : i32 = 128;\n    let mut on : HashMap<Point, i32> = HashMap::new();\n    let no_group = -1;\n    for y in 0 .. n {\n        let r : Vec<bool> = map.get(y as usize ).unwrap().chars()\n            .flat_map( |c| hex_to_bin(c) ).collect();\n        assert_eq!( n as usize, r.len() );\n        for x in 0 .. n {\n            let is_set = r.get(x as usize).unwrap();\n            if *is_set { on.insert((x, y), no_group); }\n        }\n    }\n    let max_gr = on.len() as i32;\n    for cur_gr in 0 .. max_gr {\n        let oe = on.clone().into_iter().find( |e| e.1 == no_group);\n        if oe.is_none() { break; }\n        // this is a new group\n        let p0 = oe.unwrap().0;\n        on.insert(p0, cur_gr );\n        let mut s : HashSet<Point> = HashSet::new();\n        s.insert(p0);\n        while !s.is_empty() {\n            let mut s1 : HashSet<Point> = HashSet::new();\n            for p in s  {\n                let close_points : Vec<Point> = on.clone().into_iter()\n                    .filter( |e| e.1 == no_group && close(&e.0, &p ) )\n                    .map( |e| e.0 ).collect();\n                s1.extend( close_points );\n            }\n            for p in &s1 { on.insert(*p, cur_gr ); }\n            s = s1;\n        }\n    }\n\n    let set : HashSet<i32> = on.into_iter().map( |e| e.1 ).collect();\n    assert!( !set.contains( &no_group) );\n    set.len()\n}", "item_id": 3, "repo": "yury-fedorov/AoC18", "file": "AoC17/rust/src/day14.rs", "last_update_at": "2019-01-21T15:08:21+00:00"}
{"hexsha": "b194a5513f6755d1d1e9114a658dd899c1279134", "ext": "rs", "lang": "Rust", "content": "fn swap_hl_op() {\n        let mut mem: Memory = Memory::new();\n        let addr = 1;\n        mem.write_byte(addr, 0b10100101);\n        let mut cpu: CPU = CPU::new(&mut mem);\n        cpu.registers.write_16b(&Register16bits::HL, addr);\n\n        swap_hl(&mut cpu);\n\n        assert_eq!(mem.read_byte(addr), 0b01011010);\n    }", "item_id": 80, "repo": "davidor/gebers", "file": "src/cpu/rotate_ops.rs", "last_update_at": "2019-04-08T09:31:04+00:00"}
{"hexsha": "f4f90cce53e601952a2eb4fb2def5e4d0d39868d", "ext": "rs", "lang": "Rust", "content": "fn _prepare_block_nosum(\n\tkc: &ExtKeychain,\n\tprev: &BlockHeader,\n\tdiff: u64,\n\ttxs: Vec<&Transaction>,\n) -> Block {\n\tlet key_id = ExtKeychainPath::new(1, diff as u32, 0, 0, 0).to_identifier();\n\n\tlet fees = txs.iter().map(|tx| tx.fee()).sum();\n\tlet reward = libtx::reward::output(kc, &key_id, fees, false).unwrap();\n\tlet mut b = match core::core::Block::new(\n\t\tprev,\n\t\ttxs.into_iter().cloned().collect(),\n\t\tDifficulty::from_num(diff),\n\t\treward,\n\t) {\n\t\tErr(e) => panic!(\"{:?}\", e),\n\t\tOk(b) => b,\n\t};\n\tb.header.timestamp = prev.timestamp + Duration::seconds(60);\n\tb.header.pow.total_difficulty = Difficulty::from_num(diff);\n\tb\n}", "item_id": 6, "repo": "morningsprouter/grin", "file": "chain/tests/data_file_integrity.rs", "last_update_at": "2019-06-25T10:33:43+00:00"}
{"hexsha": "b13122209cbe9bea76769d10eb0941a034de074f", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let config = config::get_config();\n    let input = fs::read_to_string(&config.target_file_path)\n        .expect(\"unable to read file\");\n\n    let ron_ast = parser::parse_ron(&input);\n    let ron_formatted = ron_ast.pretty_print(&config);\n\n    if config.format_in_place {\n        if config.with_backup {\n            create_backup(&config.target_file_path);\n        }\n\n        fs::write(&config.target_file_path, ron_formatted)\n            .expect(\"unable to overwrite target file\");\n    } else {\n        println!(\"{}\", ron_formatted);\n    }\n}", "item_id": 0, "repo": "Ristarg/ronfmt", "file": "src/main.rs", "last_update_at": "2019-09-02T04:14:34+00:00"}
{"hexsha": "70cdb095b9259bb3ff13a654da91ffd54dae8fc6", "ext": "rs", "lang": "Rust", "content": "fn input_port_b_direction() {\n        let mut riot = Riot::new();\n\n        // Reading from the bits set as output should return the register value\n        // instead of port input.\n        riot.set_port(Port::PB, 0b1100_1100);\n        riot.write(registers::SWBCNT, 0b1111_0000).unwrap();\n        riot.write(registers::SWCHB, 0b0101_0101).unwrap();\n        assert_eq!(riot.read(registers::SWCHB).unwrap(), 0b0101_1100);\n\n        // Data in the output register should be cached and return what we wrote\n        // to bits previously set to act as inputs.\n        riot.write(registers::SWBCNT, 0b0000_1111).unwrap();\n        assert_eq!(riot.read(registers::SWCHB).unwrap(), 0b1100_0101);\n    }", "item_id": 6, "repo": "technomaniak/atari-emulator", "file": "atari2600/src/riot.rs", "last_update_at": "2019-08-16T09:49:50+00:00"}
{"hexsha": "b5f1472236bf3f1eb6278d696524d731f5055f49", "ext": "rs", "lang": "Rust", "content": "fn object_panics_on_internal_error() {\n        let object_behavior = ObjectBehaviorMock::new();\n        let expected_object = Object {\n            id: 125,\n            description: object_description(),\n            behavior: &object_behavior,\n        };\n\n        let mut interactable = InteractableMock::<()>::new();\n        interactable\n            .expect_object(|arg| arg.partial_eq(expected_object.id))\n            .returns(None);\n        let world_interactor = WorldInteractorImpl::new(&interactable, expected_object.id);\n\n        let _object = world_interactor.own_object();\n    }", "item_id": 4, "repo": "myelin-ai/engine", "file": "src/world_interactor/world_interactor_impl.rs", "last_update_at": "2019-12-14T11:25:28+00:00"}
{"hexsha": "6ee7812d7118b6d191334106a34ef882bb9b8a7e", "ext": "rs", "lang": "Rust", "content": "fn points((a, b): Segment) -> Vec<Point> {\n    let mut xs: Vec<i64> = (a.x.min(b.x)..=a.x.max(b.x)).collect();\n    if a.x > b.x {\n        xs.reverse();\n    }\n\n    let mut ys: Vec<i64> = (a.y.min(b.y)..=a.y.max(b.y)).collect();\n    if a.y > b.y {\n        ys.reverse();\n    }\n\n    if xs.len() == 1 {\n        xs.iter()\n            .cycle()\n            .zip(ys.iter())\n            .map(|(&x, &y)| Point::new(x, y))\n            .collect()\n    } else {\n        xs.iter()\n            .zip(ys.iter().cycle())\n            .map(|(&x, &y)| Point::new(x, y))\n            .collect()\n    }\n}", "item_id": 0, "repo": "sebnow/adventofcode", "file": "2021/src/bin/day05.rs", "last_update_at": "2019-08-12T13:58:00+00:00"}
{"hexsha": "02354d15ae2988c17b5c379480cdf009abee280a", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let input = \"\u592a\u90ce\u306f\u30ab\u30b9\u30c6\u30e9\u304c\u597d\u304d\u3060\u3002\u3057\u304b\u3057\u725b\u4e73\u3082\u597d\u304d\u3060\u3002\";\n    let sr = lightblue(input).unwrap();\n    println!(\"{}\", format_sr(&sr));\n}", "item_id": 0, "repo": "denjiry/pindilogji", "file": "src/main.rs", "last_update_at": "2019-08-03T16:54:25+00:00"}
{"hexsha": "ce1a663d7060e0580e0bf6949cbd1522434a345d", "ext": "rs", "lang": "Rust", "content": "fn draw_polar_line_bottom_left_to_top_right() {\n        let actual = image_with_polar_line(5, 5, 3.0, 45, Luma([1]));\n        let expected = gray_image!(\n            0, 0, 0, 0, 1;\n            0, 0, 0, 1, 0;\n            0, 0, 1, 0, 0;\n            0, 1, 0, 0, 0;\n            1, 0, 0, 0, 0);\n        assert_pixels_eq!(actual, expected);\n    }", "item_id": 12, "repo": "foresterre/imageproc-patched", "file": "src/hough.rs", "last_update_at": "2019-04-17T02:43:14+00:00"}
{"hexsha": "56e24ff3f14534ce11dc14e4b54ec7e76665f8ee", "ext": "rs", "lang": "Rust", "content": "pub fn save<T>(zipfilename: &str, filename: &str, data: &T) -> bool\nwhere\n    T: Serialize,\n{\n    let data: Vec<u8> = serialize(data).unwrap();\n    let file = if let Ok(file) = File::create(path(zipfilename)) {\n        file\n    } else {\n        return true;\n    };\n    let mut zip = zip::write::ZipWriter::new(file);\n    let options = zip::write::FileOptions::default().compression_method(zip::CompressionMethod::Deflated).unix_permissions(0o755);\n    zip.start_file(filename, options).unwrap();\n    zip.write_all(&data[..]).unwrap();\n\n    zip.finish().unwrap();\n    false\n}", "item_id": 1, "repo": "OxyDeadbeef/files", "file": "src/lib.rs", "last_update_at": "2019-03-22T04:12:59+00:00"}
{"hexsha": "18397dd69503cb1e223befe5d34e6f6cd15e3d53", "ext": "rs", "lang": "Rust", "content": "pub fn stop(SomeUser: komodorpcutil::KomodoRPC) -> Result<String, reqwest::Error> {\n    let method_name: String = String::from(\"stop\");\n    let method_body: String = String::from(\"[]\");\n    let data: String = String::from(komodorpcutil::generate_body(\n        SomeUser.clone(),\n        method_name,\n        method_body,\n    ));\n    let result = komodorpcutil::request(SomeUser.clone(), data);\n    return result;\n}", "item_id": 2, "repo": "sudipghale/Komodo-RPC-API-Rust", "file": "src/komodo/control.rs", "last_update_at": "2019-12-07T03:17:44+00:00"}
