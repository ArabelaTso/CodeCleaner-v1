{"hexsha": "d955e186b4b6c88b16b55a9851ba51f929615645", "ext": "rs", "lang": "Rust", "content": "async fn read_continuation_frames() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n\n    let large = build_large_headers();\n    let frame = large\n        .iter()\n        .fold(\n            frames::headers(1).response(200),\n            |frame, &(name, ref value)| frame.field(name, &value[..]),\n        )\n        .eos();\n\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_default_settings!(settings);\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://http2.akamai.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(frame).await;\n    };\n\n    let client = async move {\n        let (mut client, mut conn) = client::handshake(io).await.expect(\"handshake\");\n\n        let request = Request::builder()\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n\n        let req = async {\n            let res = client\n                .send_request(request, true)\n                .expect(\"send_request\")\n                .0\n                .await\n                .expect(\"response\");\n            assert_eq!(res.status(), StatusCode::OK);\n            let (head, _body) = res.into_parts();\n            let expected = large\n                .iter()\n                .fold(HeaderMap::new(), |mut map, &(name, ref value)| {\n                    map.append(name, value.parse().unwrap());\n                    map\n                });\n            assert_eq!(head.headers, expected);\n        };\n\n        conn.drive(req).await;\n        conn.await.expect(\"client\");\n    };\n\n    join(srv, client).await;\n}", "item_id": 5, "repo": "hikaricai/h2", "file": "tests/h2-tests/tests/codec_read.rs", "last_update_at": "2019-04-19T15:06:21+00:00", "question_id": "d955e186b4b6c88b16b55a9851ba51f929615645_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn read_continuation_frames() {\n    h2_support::trace_init!();\n    let (io, mut srv) = mock::new();\n    let large = build_large_headers();\n    let frame = large\n        .iter()\n        .fold(\n            frames::headers(1).response(200),\n            |frame, &(name, ref value)| frame.field(name, &value[..]),\n        )\n        .eos();\n    let srv = async move {\n        let settings = srv.assert_client_handshake().await;\n        assert_default_settings!(settings);\n        srv.recv_frame(\n            frames::headers(1)\n                .request(\"GET\", \"https://http2.akamai.com/\")\n                .eos(),\n        )\n        .await;\n        srv.send_frame(frame).await;\n    };\n    let client = async move {\n        let (mut client, mut conn) = client::handshake(io).await.expect(\"handshake\");\n        let request = Request::builder()\n            .uri(\"https://http2.akamai.com/\")\n            .body(())\n            .unwrap();\n        let req = async {\n            let res = client\n                .send_request(request, true)\n                .expect(\"send_request\")\n                .0\n                .await\n                .expect(\"response\");\n            assert_eq!(res.status(), StatusCode::OK);\n            let (head, _body) = res.into_parts();\n            let expected = large\n                .iter()\n                .fold(HeaderMap::new(), |mut map, &(name, ref value)| {\n                    map.append(name, value.parse().unwrap());\n                    map\n                });\n            assert_eq!(head.headers, expected);\n        };\n        conn.drive(req).await;\n        conn.await.expect(\"client\");\n    };\n    join(srv, client).await;\n"]]}
{"hexsha": "8bc8f45004c4d25f677dad56db1a20032fa502ec", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    println!(\"VALUE: {}\", VALUE);\n    println!(\"{}\", env!(\"CARGO_MANIFEST_DIR\"));\n    println!(\"{}\", src_file!(\"foo.rs\"));\n}", "item_id": 0, "repo": "Amanita-muscaria/build_const", "file": "test_crates/example/src/main.rs", "last_update_at": "2019-04-20T15:06:27+00:00", "question_id": "8bc8f45004c4d25f677dad56db1a20032fa502ec_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    println!(\"VALUE: {}\", VALUE);\n    println!(\"{}\", env!(\"CARGO_MANIFEST_DIR\"));\n    println!(\"{}\", src_file!(\"foo.rs\"));\n"]]}
{"hexsha": "4f407509350c506c0bf501c2d75a4cd2e75dc4de", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), Box<dyn Error>> {\n    let config_file = match std::env::args_os().nth(1) {\n        Some(x) => x,\n        None => {\n            eprintln!(\"Config file argument required.\");\n            std::process::exit(1);\n        }\n    };\n\n    let config_file = std::fs::File::open(config_file)?;\n    let config: Box<HashMap<String, Endpoint>> = Box::new(serde_yaml::from_reader(config_file)?);\n\n    let route = warp::put2()\n        .and(warp::path::param())\n        .and(warp::path::end())\n        .and(warp::query::raw())\n        .and(warp::body::concat())\n        .map(move |f, a, b| file_sink_wrapper(f, a, b, &*config));\n\n    warp::serve(route).run(([0, 0, 0, 0], 8228));\n    Ok(())\n}", "item_id": 1, "repo": "ohomburg/filesink", "file": "src/main.rs", "last_update_at": "2019-09-20T22:52:55+00:00", "question_id": "4f407509350c506c0bf501c2d75a4cd2e75dc4de_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), Box<dyn Error>> {\n    let config_file = match std::env::args_os().nth(1) {\n        Some(x) => x,\n        None => {\n            eprintln!(\"Config file argument required.\");\n            std::process::exit(1);\n        }\n    };\n    let config_file = std::fs::File::open(config_file)?;\n    let config: Box<HashMap<String, Endpoint>> = Box::new(serde_yaml::from_reader(config_file)?);\n    let route = warp::put2()\n        .and(warp::path::param())\n        .and(warp::path::end())\n        .and(warp::query::raw())\n        .and(warp::body::concat())\n        .map(move |f, a, b| file_sink_wrapper(f, a, b, &*config));\n    warp::serve(route).run(([0, 0, 0, 0], 8228));\n    Ok(())\n"]]}
{"hexsha": "3eeb5f3f4ecb0c8ac6444551d55612497a0e0580", "ext": "rs", "lang": "Rust", "content": "fn test_parse_valid_ses_verify_domain_dkim() {\n        let mock_response = MockResponseReader::read_response(\"test_resources/generated/valid\",\n                                                              \"ses-verify-domain-dkim.xml\");\n        let mock = MockRequestDispatcher::with_status(200).with_body(&mock_response);\n        let client = SesClient::new(mock, MockCredentialsProvider, rusoto_region::UsEast1);\n        let request = VerifyDomainDkimRequest::default();\n        let result = client.verify_domain_dkim(&request);\n        assert!(result.is_ok(), \"parse error: {:?}\", result);\n    }", "item_id": 11, "repo": "RelationalAI-oss/rusoto", "file": "rusoto/services/ses/src/generated.rs", "last_update_at": "2019-09-08T17:16:26+00:00", "question_id": "3eeb5f3f4ecb0c8ac6444551d55612497a0e0580_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_parse_valid_ses_verify_domain_dkim() {\n        let mock_response = MockResponseReader::read_response(\"test_resources/generated/valid\",\n                                                              \"ses-verify-domain-dkim.xml\");\n        let mock = MockRequestDispatcher::with_status(200).with_body(&mock_response);\n        let client = SesClient::new(mock, MockCredentialsProvider, rusoto_region::UsEast1);\n        let request = VerifyDomainDkimRequest::default();\n        let result = client.verify_domain_dkim(&request);\n        assert!(result.is_ok(), \"parse error: {:?}\", result);\n"]]}
{"hexsha": "f4f4547468a8f440cc427f66c3b41987d275b23b", "ext": "rs", "lang": "Rust", "content": "fn create_colormap() {\n        // We will make a vector. This is in R, G, B, A order.\n        // We will make it with linearly ramping R, 255 A, and 0 elsewhere.\n        let rgba_map = linear_ramp_cmap();\n        let _cm = Colormap::new(rgba_map);\n        // Test that our pixels are in the right order.\n        for (i, rgba) in _cm.table.iter().enumerate() {\n            assert_eq!(i as u8, rgba.red);\n            assert_eq!(0, rgba.green);\n            assert_eq!(0, rgba.blue);\n            assert_eq!(255, rgba.alpha);\n        }\n    }", "item_id": 1, "repo": "data-exp-lab/rust-yt-tools", "file": "src/colormaps.rs", "last_update_at": "2019-07-10T15:51:08+00:00", "question_id": "f4f4547468a8f440cc427f66c3b41987d275b23b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn create_colormap() {\n        // We will make a vector. This is in R, G, B, A order.\n        // We will make it with linearly ramping R, 255 A, and 0 elsewhere.\n        let rgba_map = linear_ramp_cmap();\n        let _cm = Colormap::new(rgba_map);\n        // Test that our pixels are in the right order.\n        for (i, rgba) in _cm.table.iter().enumerate() {\n            assert_eq!(i as u8, rgba.red);\n            assert_eq!(0, rgba.green);\n            assert_eq!(0, rgba.blue);\n            assert_eq!(255, rgba.alpha);\n        }\n"]]}
{"hexsha": "a47c5012bd0bf5d51aeedf3e847c3d718a818abb", "ext": "rs", "lang": "Rust", "content": "fn ints8() {\n        eq(5i8, vec![0, 3, 4]);\n        eq(-5i8, vec![5, 0, -3, -4]);\n        eq(0i8, vec![]);\n    }", "item_id": 6, "repo": "huonw/quickcheck", "file": "src/arbitrary.rs", "last_update_at": "2019-03-07T11:41:53+00:00", "question_id": "a47c5012bd0bf5d51aeedf3e847c3d718a818abb_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn ints8() {\n        eq(5i8, vec![0, 3, 4]);\n        eq(-5i8, vec![5, 0, -3, -4]);\n        eq(0i8, vec![]);\n"]]}
{"hexsha": "3984f9bbb71389b81b6d19c6b0ac07e3b485b9b9", "ext": "rs", "lang": "Rust", "content": "pub fn fission_to(filled: &V3<bool>, to: &Vec<P>) -> (Vec<usize>, Vec<Command>)  {\n    eprintln!(\"fission: started\");\n    let mut log_bots = Vec::new();\n    let mut log_cmds = Vec::new();\n    {\n        let fusion_cmds = postproc::fusion_all(filled, to.clone());\n        let mut sim = sim::SimState::from_positions(filled.clone(), to.clone());\n\n        let mut ip = 0;\n        while ip < fusion_cmds.len() {\n            log_bots.push(sim.bots.clone());\n            let n = sim.bots.len();\n            let mut cmds_step = Vec::new();\n            for i in ip..ip+n {\n                cmds_step.push(fusion_cmds[i]);\n            }\n            // eprintln!(\"{:?}\", cmds_step);\n            log_cmds.push(cmds_step.clone());\n            sim.step(cmds_step);\n            ip += n;\n        }\n        assert_eq!(ip, fusion_cmds.len());\n        assert_eq!(sim.bots.len(), 0);\n        let last_cmds = log_cmds.pop();\n        assert_eq!(last_cmds, Some(vec![Command::Halt]));\n    }\n    let mut bots = log_bots.pop().unwrap(); //.into_iter().collect();\n\n    let mut fission_cmds = Vec::new();\n    let mut sim = sim::SimState::new(filled.len(), to.len());\n\n    while let Some(cmds) = log_cmds.pop() {\n        let next_bots = bots;\n        bots = log_bots.pop().unwrap(); //.into_iter().collect();\n        // eprintln!(\"fusion: {:?} <- {:?}\", next_bots, bots);\n        // eprintln!(\"fission: {:?} -> \", sim.bots);\n\n        let mut back_cmds = BTreeMap::new();\n        for (bot, &cmd) in bots.iter().zip(cmds.iter()) {\n            // if let Command::FusionS(nd) = cmd {\n            //     continue;\n            // }\n            if let Some(next_bot) = next_bots.iter().find(|&b| b.bid == bot.bid) {\n                let back_bot = sim.bots.iter().find(|&b| b.p == next_bot.p).unwrap();\n                let back_cmd = match cmd {\n                    Command::Wait => Command::Wait,\n                    Command::SMove(d) => Command::SMove(-d),\n                    Command::LMove(d1, d2) => Command::LMove(-d2, -d1),\n                    Command::FusionP(nd) => Command::Fission(nd, next_bot.seeds.len() - bot.seeds.len() - 1),\n                    _ => panic!(),\n                };\n                back_cmds.insert(back_bot.bid, back_cmd);\n            }\n        }\n        let back_cmds: Vec<_> = back_cmds.values().cloned().collect();\n        fission_cmds.append(&mut back_cmds.clone());\n        sim.step(back_cmds);\n    }\n\n    let mut bids = Vec::new();\n    for &pos in to.iter() {\n        let bot = sim.bots.iter().find(|&b| b.p == pos).unwrap();\n        bids.push(bot.bid);\n    }\n    eprintln!(\"fission: finished!\");\n    (bids, fission_cmds)\n}", "item_id": 1, "repo": "cmk/icfpc2018", "file": "wata/src/lib.rs", "last_update_at": "2019-05-31T04:31:00+00:00", "question_id": "3984f9bbb71389b81b6d19c6b0ac07e3b485b9b9_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn fission_to(filled: &V3<bool>, to: &Vec<P>) -> (Vec<usize>, Vec<Command>)  {\n    eprintln!(\"fission: started\");\n    let mut log_bots = Vec::new();\n    let mut log_cmds = Vec::new();\n    {\n        let fusion_cmds = postproc::fusion_all(filled, to.clone());\n        let mut sim = sim::SimState::from_positions(filled.clone(), to.clone());\n        let mut ip = 0;\n        while ip < fusion_cmds.len() {\n            log_bots.push(sim.bots.clone());\n            let n = sim.bots.len();\n            let mut cmds_step = Vec::new();\n            for i in ip..ip+n {\n                cmds_step.push(fusion_cmds[i]);\n            }\n            // eprintln!(\"{:?}\", cmds_step);\n            log_cmds.push(cmds_step.clone());\n            sim.step(cmds_step);\n            ip += n;\n        }\n        assert_eq!(ip, fusion_cmds.len());\n        assert_eq!(sim.bots.len(), 0);\n        let last_cmds = log_cmds.pop();\n        assert_eq!(last_cmds, Some(vec![Command::Halt]));\n    }\n    let mut bots = log_bots.pop().unwrap(); //.into_iter().collect();\n    let mut fission_cmds = Vec::new();\n    let mut sim = sim::SimState::new(filled.len(), to.len());\n    while let Some(cmds) = log_cmds.pop() {\n        let next_bots = bots;\n        bots = log_bots.pop().unwrap(); //.into_iter().collect();\n        // eprintln!(\"fusion: {:?} <- {:?}\", next_bots, bots);\n        // eprintln!(\"fission: {:?} -> \", sim.bots);\n        let mut back_cmds = BTreeMap::new();\n        for (bot, &cmd) in bots.iter().zip(cmds.iter()) {\n            // if let Command::FusionS(nd) = cmd {\n            //     continue;\n            // }\n            if let Some(next_bot) = next_bots.iter().find(|&b| b.bid == bot.bid) {\n                let back_bot = sim.bots.iter().find(|&b| b.p == next_bot.p).unwrap();\n                let back_cmd = match cmd {\n                    Command::Wait => Command::Wait,\n                    Command::SMove(d) => Command::SMove(-d),\n                    Command::LMove(d1, d2) => Command::LMove(-d2, -d1),\n                    Command::FusionP(nd) => Command::Fission(nd, next_bot.seeds.len() - bot.seeds.len() - 1),\n                    _ => panic!(),\n                };\n                back_cmds.insert(back_bot.bid, back_cmd);\n            }\n        }\n        let back_cmds: Vec<_> = back_cmds.values().cloned().collect();\n        fission_cmds.append(&mut back_cmds.clone());\n        sim.step(back_cmds);\n    }\n    let mut bids = Vec::new();\n    for &pos in to.iter() {\n        let bot = sim.bots.iter().find(|&b| b.p == pos).unwrap();\n        bids.push(bot.bid);\n    }\n    eprintln!(\"fission: finished!\");\n    (bids, fission_cmds)\n"]]}
{"hexsha": "a7d963b47a8c9db4df321781695097a1333e6961", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut deck = Deck::new(10007);\n    let mut actions = Vec::new();\n    for line in read_file(\"input.txt\") {\n        if line.starts_with(\"deal into\") {\n            actions.push(Deal)\n        } else if line.starts_with(\"deal with\") {\n            let split = line.split(' ');\n            let last = split.last().unwrap();\n            let num = last.parse::<usize>().unwrap();\n            actions.push(DealN(num));\n        } else if line.starts_with(\"cut\") {\n            let split = line.split(' ');\n            let last = split.last().unwrap();\n            let num = last.parse::<i64>().unwrap();\n            actions.push(Cut(num));\n        }\n    }\n\n    for action in &actions {\n        deck.do_action(*action);\n    }\n\n    let pos = deck.cards.iter().position(|n| *n == 2019).unwrap();\n    println!(\"part 1 pos:{}\", pos);\n\n    let mut deck = PosDeck::new(119315717514047, 2020);\n    let end : u64 = 101741582076661;\n    for i in 1..end {\n        for action in &actions {\n            deck.do_action(*action);\n        }\n        if deck.pos == 2020 {\n            println!(\"repeat at {}\",i);\n            break;\n        }\n        if i % 1_000_000 == 0 {\n            println!(\"{}%\",i as f64/end as f64);\n        }\n    }\n   // println!(\"part2 test pos:{}\", deck.pos);\n}", "item_id": 0, "repo": "jackmott/advent2019", "file": "day_22/src/main.rs", "last_update_at": "2019-12-26T01:11:07+00:00", "question_id": "a7d963b47a8c9db4df321781695097a1333e6961_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let mut deck = Deck::new(10007);\n    let mut actions = Vec::new();\n    for line in read_file(\"input.txt\") {\n        if line.starts_with(\"deal into\") {\n            actions.push(Deal)\n        } else if line.starts_with(\"deal with\") {\n            let split = line.split(' ');\n            let last = split.last().unwrap();\n            let num = last.parse::<usize>().unwrap();\n            actions.push(DealN(num));\n        } else if line.starts_with(\"cut\") {\n            let split = line.split(' ');\n            let last = split.last().unwrap();\n            let num = last.parse::<i64>().unwrap();\n            actions.push(Cut(num));\n        }\n    }\n    for action in &actions {\n        deck.do_action(*action);\n    }\n    let pos = deck.cards.iter().position(|n| *n == 2019).unwrap();\n    println!(\"part 1 pos:{}\", pos);\n    let mut deck = PosDeck::new(119315717514047, 2020);\n    let end : u64 = 101741582076661;\n    for i in 1..end {\n        for action in &actions {\n            deck.do_action(*action);\n        }\n        if deck.pos == 2020 {\n            println!(\"repeat at {}\",i);\n            break;\n        }\n        if i % 1_000_000 == 0 {\n            println!(\"{}%\",i as f64/end as f64);\n        }\n    }\n   // println!(\"part2 test pos:{}\", deck.pos);\n"]]}
{"hexsha": "519540d5655f412771175dcf4028b061d08cbe9e", "ext": "rs", "lang": "Rust", "content": "fn bindgen_test_layout_NVIC_Type() {\n    assert_eq!(::core::mem::size_of::<NVIC_Type>() , 800usize , concat ! (\n               \"Size of: \" , stringify ! ( NVIC_Type ) ));\n    assert_eq! (::core::mem::align_of::<NVIC_Type>() , 4usize , concat ! (\n                \"Alignment of \" , stringify ! ( NVIC_Type ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . ISER as * const _ as\n                usize } , 0usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( ISER ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . RESERVED0 as * const _ as\n                usize } , 4usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( RESERVED0 ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . ICER as * const _ as\n                usize } , 128usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( ICER ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . RSERVED1 as * const _ as\n                usize } , 132usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( RSERVED1 ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . ISPR as * const _ as\n                usize } , 256usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( ISPR ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . RESERVED2 as * const _ as\n                usize } , 260usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( RESERVED2 ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . ICPR as * const _ as\n                usize } , 384usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( ICPR ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . RESERVED3 as * const _ as\n                usize } , 388usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( RESERVED3 ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . RESERVED4 as * const _ as\n                usize } , 512usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( RESERVED4 ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . IP as * const _ as usize\n                } , 768usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( IP ) ));\n}", "item_id": 11, "repo": "japaric-archived/ble400", "file": "src/ll.rs", "last_update_at": "2019-08-11T05:30:33+00:00", "question_id": "519540d5655f412771175dcf4028b061d08cbe9e_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bindgen_test_layout_NVIC_Type() {\n    assert_eq!(::core::mem::size_of::<NVIC_Type>() , 800usize , concat ! (\n               \"Size of: \" , stringify ! ( NVIC_Type ) ));\n    assert_eq! (::core::mem::align_of::<NVIC_Type>() , 4usize , concat ! (\n                \"Alignment of \" , stringify ! ( NVIC_Type ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . ISER as * const _ as\n                usize } , 0usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( ISER ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . RESERVED0 as * const _ as\n                usize } , 4usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( RESERVED0 ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . ICER as * const _ as\n                usize } , 128usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( ICER ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . RSERVED1 as * const _ as\n                usize } , 132usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( RSERVED1 ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . ISPR as * const _ as\n                usize } , 256usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( ISPR ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . RESERVED2 as * const _ as\n                usize } , 260usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( RESERVED2 ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . ICPR as * const _ as\n                usize } , 384usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( ICPR ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . RESERVED3 as * const _ as\n                usize } , 388usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( RESERVED3 ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . RESERVED4 as * const _ as\n                usize } , 512usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( RESERVED4 ) ));\n    assert_eq! (unsafe {\n                & ( * ( 0 as * const NVIC_Type ) ) . IP as * const _ as usize\n                } , 768usize , concat ! (\n                \"Alignment of field: \" , stringify ! ( NVIC_Type ) , \"::\" ,\n                stringify ! ( IP ) ));\n"]]}
{"hexsha": "73f99e784fdf86e9e522844ec5659c19688be32e", "ext": "rs", "lang": "Rust", "content": "fn slufigy_replaces_url_punctuation() {\n        assert_eq!(\"foo-bar\", slugify(\"foo&bar\"));\n        assert_eq!(\"foo-bar\", slugify(\"foo\\\"bar\"));\n        assert_eq!(\"foo-bar\", slugify(\"foo?bar\"));\n        assert_eq!(\"foo-bar\", slugify(\"foo=bar\"));\n    }", "item_id": 2, "repo": "iwillspeak/docket", "file": "src/util.rs", "last_update_at": "2019-12-24T17:42:57+00:00", "question_id": "73f99e784fdf86e9e522844ec5659c19688be32e_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn slufigy_replaces_url_punctuation() {\n        assert_eq!(\"foo-bar\", slugify(\"foo&bar\"));\n        assert_eq!(\"foo-bar\", slugify(\"foo\\\"bar\"));\n        assert_eq!(\"foo-bar\", slugify(\"foo?bar\"));\n        assert_eq!(\"foo-bar\", slugify(\"foo=bar\"));\n"]]}
{"hexsha": "2e70a62330b5d3b9ea1fc2683957d7ca04479b4d", "ext": "rs", "lang": "Rust", "content": "fn test_tile_to_wgs84() {\n    assert_eq!((0.0, 66.51326044311186), tile_to_wgs84(2, 1, 2));\n    assert_eq!((270.0, -85.0511287798066), tile_to_wgs84(5, 4, 2));\n    assert_eq!((-9.140625, 53.33087298301705), tile_to_wgs84(486, 332, 10));\n}", "item_id": 3, "repo": "evomassiny/tiler-rs", "file": "src/tile.rs", "last_update_at": "2019-07-30T11:30:05+00:00", "question_id": "2e70a62330b5d3b9ea1fc2683957d7ca04479b4d_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_tile_to_wgs84() {\n    assert_eq!((0.0, 66.51326044311186), tile_to_wgs84(2, 1, 2));\n    assert_eq!((270.0, -85.0511287798066), tile_to_wgs84(5, 4, 2));\n    assert_eq!((-9.140625, 53.33087298301705), tile_to_wgs84(486, 332, 10));\n"]]}
{"hexsha": "6d4fe79fd24dcb9be3481f875857c2f1a7fcc843", "ext": "rs", "lang": "Rust", "content": "fn main() -> Result<(), Box<Error>> {\n    env_logger::init();\n    let opt = Opt::from_args();\n\n    let schema = kobuta::schema::parse(&opt.schema)?;\n\n    let stdout = std::io::stdout();\n    let mut stdout = stdout.lock();\n\n    output_csv(opt.records, &schema, &mut stdout)?;\n\n    Ok(())\n}", "item_id": 2, "repo": "golddranks/Kobuta", "file": "src/bin/create_test_data.rs", "last_update_at": "2019-12-08T17:13:00+00:00", "question_id": "6d4fe79fd24dcb9be3481f875857c2f1a7fcc843_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> Result<(), Box<Error>> {\n    env_logger::init();\n    let opt = Opt::from_args();\n    let schema = kobuta::schema::parse(&opt.schema)?;\n    let stdout = std::io::stdout();\n    let mut stdout = stdout.lock();\n    output_csv(opt.records, &schema, &mut stdout)?;\n    Ok(())\n"]]}
{"hexsha": "de3c1c02c98f9bfc3c051149e02907f25afd8e5d", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn sr_sign(\n\tmessage: *const u8,\n\tlen: usize,\n\trandom: *const u8,\n\tkeypair: *const u8,\n    sig_out: *mut u8,\n) -> u32 {\n\tlet context = signing_context(b\"substrate\");\n\tlet keypair =\n\t\tmatch Keypair::from_bytes(slice::from_raw_parts(keypair, SR_PUBLIC_LEN + SR_SECRET_LEN)) {\n\t\t\tOk(pair) => pair,\n\t\t\tErr(_) => {\n\t\t\t\treturn {SR_PAIR_FAIL};\n\t\t\t}\n\t\t};\n\tlet message_bytes = slice::from_raw_parts(message, len);\n\tlet trng_bytes = slice::from_raw_parts(random, SR_PUBLIC_LEN);\n    let signature: Signature = keypair.sign(\n        attach_rng(\n            context.bytes(&message_bytes[..]), \n            ExternalRng{\n                rng_bytes:ExternalRng::copy_into_array(trng_bytes),\n                len:32}\n                ));\n     ptr::copy(signature.to_bytes().as_ptr(), sig_out, SR_SIGNATURE_LEN as usize);  \n    { SR_OK }\n}", "item_id": 1, "repo": "wookong-dot/sr25519-embedded-c", "file": "src/api.rs", "last_update_at": "2019-09-06T01:39:26+00:00", "question_id": "de3c1c02c98f9bfc3c051149e02907f25afd8e5d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn sr_sign(\n\tmessage: *const u8,\n\tlen: usize,\n\trandom: *const u8,\n\tkeypair: *const u8,\n    sig_out: *mut u8,\n) -> u32 {\n\tlet context = signing_context(b\"substrate\");\n\tlet keypair =\n\t\tmatch Keypair::from_bytes(slice::from_raw_parts(keypair, SR_PUBLIC_LEN + SR_SECRET_LEN)) {\n\t\t\tOk(pair) => pair,\n\t\t\tErr(_) => {\n\t\t\t\treturn {SR_PAIR_FAIL};\n\t\t\t}\n\t\t};\n\tlet message_bytes = slice::from_raw_parts(message, len);\n\tlet trng_bytes = slice::from_raw_parts(random, SR_PUBLIC_LEN);\n    let signature: Signature = keypair.sign(\n        attach_rng(\n            context.bytes(&message_bytes[..]), \n            ExternalRng{\n                rng_bytes:ExternalRng::copy_into_array(trng_bytes),\n                len:32}\n                ));\n     ptr::copy(signature.to_bytes().as_ptr(), sig_out, SR_SIGNATURE_LEN as usize);  \n    { SR_OK }\n"]]}
{"hexsha": "e24c2a009f438fb0d893e36b3e90c9d67639c771", "ext": "rs", "lang": "Rust", "content": "pub unsafe fn mailmime_single_fields_init(\n    mut single_fields: *mut mailmime_single_fields,\n    mut fld_fields: *mut mailmime_fields,\n    mut fld_content: *mut mailmime_content,\n) {\n    let mut cur: *mut clistiter = 0 as *mut clistiter;\n    memset(\n        single_fields as *mut libc::c_void,\n        0i32,\n        ::std::mem::size_of::<mailmime_single_fields>() as libc::size_t,\n    );\n    if !fld_content.is_null() {\n        mailmime_content_single_fields_init(single_fields, fld_content);\n    }\n    if fld_fields.is_null() {\n        return;\n    }\n    cur = (*(*fld_fields).fld_list).first;\n    while !cur.is_null() {\n        let mut field: *mut mailmime_field = 0 as *mut mailmime_field;\n        field = (if !cur.is_null() {\n            (*cur).data\n        } else {\n            0 as *mut libc::c_void\n        }) as *mut mailmime_field;\n        match (*field).fld_type {\n            1 => {\n                mailmime_content_single_fields_init(single_fields, (*field).fld_data.fld_content);\n            }\n            2 => (*single_fields).fld_encoding = (*field).fld_data.fld_encoding,\n            3 => (*single_fields).fld_id = (*field).fld_data.fld_id,\n            4 => (*single_fields).fld_description = (*field).fld_data.fld_description,\n            5 => (*single_fields).fld_version = (*field).fld_data.fld_version,\n            6 => {\n                mailmime_disposition_single_fields_init(\n                    single_fields,\n                    (*field).fld_data.fld_disposition,\n                );\n            }\n            7 => (*single_fields).fld_language = (*field).fld_data.fld_language,\n            8 => (*single_fields).fld_location = (*field).fld_data.fld_location,\n            _ => {}\n        }\n        cur = if !cur.is_null() {\n            (*cur).next\n        } else {\n            0 as *mut clistcell\n        }\n    }\n}", "item_id": 20, "repo": "KAction/mmime", "file": "src/mailmime_types_helper.rs", "last_update_at": "2019-09-16T15:25:05+00:00", "question_id": "e24c2a009f438fb0d893e36b3e90c9d67639c771_20", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe fn mailmime_single_fields_init(\n    mut single_fields: *mut mailmime_single_fields,\n    mut fld_fields: *mut mailmime_fields,\n    mut fld_content: *mut mailmime_content,\n) {\n    let mut cur: *mut clistiter = 0 as *mut clistiter;\n    memset(\n        single_fields as *mut libc::c_void,\n        0i32,\n        ::std::mem::size_of::<mailmime_single_fields>() as libc::size_t,\n    );\n    if !fld_content.is_null() {\n        mailmime_content_single_fields_init(single_fields, fld_content);\n    }\n    if fld_fields.is_null() {\n        return;\n    }\n    cur = (*(*fld_fields).fld_list).first;\n    while !cur.is_null() {\n        let mut field: *mut mailmime_field = 0 as *mut mailmime_field;\n        field = (if !cur.is_null() {\n            (*cur).data\n        } else {\n            0 as *mut libc::c_void\n        }) as *mut mailmime_field;\n        match (*field).fld_type {\n            1 => {\n                mailmime_content_single_fields_init(single_fields, (*field).fld_data.fld_content);\n            }\n            2 => (*single_fields).fld_encoding = (*field).fld_data.fld_encoding,\n            3 => (*single_fields).fld_id = (*field).fld_data.fld_id,\n            4 => (*single_fields).fld_description = (*field).fld_data.fld_description,\n            5 => (*single_fields).fld_version = (*field).fld_data.fld_version,\n            6 => {\n                mailmime_disposition_single_fields_init(\n                    single_fields,\n                    (*field).fld_data.fld_disposition,\n                );\n            }\n            7 => (*single_fields).fld_language = (*field).fld_data.fld_language,\n            8 => (*single_fields).fld_location = (*field).fld_data.fld_location,\n            _ => {}\n        }\n        cur = if !cur.is_null() {\n            (*cur).next\n        } else {\n            0 as *mut clistcell\n        }\n    }\n"]]}
{"hexsha": "008e5912f49bcf34bed169ddffc5f10575f28b1d", "ext": "rs", "lang": "Rust", "content": "fn test_memorydb_threading() {\n        let col_name: &str = BLOCKS_DB_COLUMN;\n\n        let db = Arc::new(MemoryDB::open());\n\n        let thread_count = 10;\n        let write_count = 10;\n\n        // We're execting the product of these numbers to fit in one byte.\n        assert!(thread_count * write_count <= 255);\n\n        let mut handles = vec![];\n        for t in 0..thread_count {\n            let wc = write_count;\n            let db = db.clone();\n            let col = col_name.clone();\n            let handle = thread::spawn(move || {\n                for w in 0..wc {\n                    let key = (t * w) as u8;\n                    let val = 42;\n                    db.put(&col, &vec![key], &vec![val]).unwrap();\n                }\n            });\n            handles.push(handle);\n        }\n\n        for handle in handles {\n            handle.join().unwrap();\n        }\n\n        for t in 0..thread_count {\n            for w in 0..write_count {\n                let key = (t * w) as u8;\n                let val = db.get(&col_name, &vec![key]).unwrap().unwrap();\n                assert_eq!(vec![42], val);\n            }\n        }\n    }", "item_id": 4, "repo": "zedt3ster/lighthouse", "file": "beacon_node/db/src/memory_db.rs", "last_update_at": "2019-04-15T06:39:50+00:00", "question_id": "008e5912f49bcf34bed169ddffc5f10575f28b1d_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_memorydb_threading() {\n        let col_name: &str = BLOCKS_DB_COLUMN;\n        let db = Arc::new(MemoryDB::open());\n        let thread_count = 10;\n        let write_count = 10;\n        // We're execting the product of these numbers to fit in one byte.\n        assert!(thread_count * write_count <= 255);\n        let mut handles = vec![];\n        for t in 0..thread_count {\n            let wc = write_count;\n            let db = db.clone();\n            let col = col_name.clone();\n            let handle = thread::spawn(move || {\n                for w in 0..wc {\n                    let key = (t * w) as u8;\n                    let val = 42;\n                    db.put(&col, &vec![key], &vec![val]).unwrap();\n                }\n            });\n            handles.push(handle);\n        }\n        for handle in handles {\n            handle.join().unwrap();\n        }\n        for t in 0..thread_count {\n            for w in 0..write_count {\n                let key = (t * w) as u8;\n                let val = db.get(&col_name, &vec![key]).unwrap().unwrap();\n                assert_eq!(vec![42], val);\n            }\n        }\n"]]}
{"hexsha": "b10e281f4bf8905b7685a364741537a3b4a8522e", "ext": "rs", "lang": "Rust", "content": "fn compare_similar() {\r\n        let a = Hash::hash(FOX).unwrap();\r\n        let b = Hash::hash(FOX1).unwrap();\r\n        let score = Hash::compare(&a, &b);\r\n        println!(\"{}\", score);\r\n        assert!(score == 10);\r\n    }", "item_id": 1, "repo": "mmaisel/similarity-hash-rs", "file": "src/ssdeep/mod.rs", "last_update_at": "2019-01-23T15:39:20+00:00", "question_id": "b10e281f4bf8905b7685a364741537a3b4a8522e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn compare_similar() {\r\n        let a = Hash::hash(FOX).unwrap();\r\n        let b = Hash::hash(FOX1).unwrap();\r\n        let score = Hash::compare(&a, &b);\r\n        println!(\"{}\", score);\r\n        assert!(score == 10);\r\n"]]}
{"hexsha": "5cebbf5a247289a67b185006a954d337d4a18fd4", "ext": "rs", "lang": "Rust", "content": "fn it_strips_comments() {\n        assert_eq!(\n            strip_comment(String::from(\"Foobar\")),\n            String::from(\"Foobar\"),\n        );\n\n        assert_eq!(strip_comment(String::from(\"Foo#bar\")), String::from(\"Foo\"),);\n\n        assert_eq!(\n            strip_comment(String::from(\" Complicated # oh yes!! # another one\")),\n            String::from(\"Complicated\"),\n        );\n\n        assert_eq!(\n            strip_comment(String::from(\"# Just a comment\")),\n            String::from(\"\"),\n        );\n\n        assert_eq!(\n            strip_comment(String::from(\"  \\t# Just a comment\")),\n            String::from(\"\"),\n        );\n    }", "item_id": 7, "repo": "Mange/graceful-shutdown", "file": "src/main.rs", "last_update_at": "2019-01-20T03:14:15+00:00", "question_id": "5cebbf5a247289a67b185006a954d337d4a18fd4_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_strips_comments() {\n        assert_eq!(\n            strip_comment(String::from(\"Foobar\")),\n            String::from(\"Foobar\"),\n        );\n        assert_eq!(strip_comment(String::from(\"Foo#bar\")), String::from(\"Foo\"),);\n        assert_eq!(\n            strip_comment(String::from(\" Complicated # oh yes!! # another one\")),\n            String::from(\"Complicated\"),\n        );\n        assert_eq!(\n            strip_comment(String::from(\"# Just a comment\")),\n            String::from(\"\"),\n        );\n        assert_eq!(\n            strip_comment(String::from(\"  \\t# Just a comment\")),\n            String::from(\"\"),\n        );\n"]]}
{"hexsha": "2beab526c50deb5dd572d1a7e311921b71bac838", "ext": "rs", "lang": "Rust", "content": "fn codec_basic_get() {\n    let mut enc_table = DynamicTable::new();\n    let mut dec_table = DynamicTable::new();\n\n    let mut block_buf = vec![];\n    let mut enc_buf = vec![];\n    let mut dec_buf = vec![];\n\n    let header = vec![\n        HeaderField::new(\":method\", \"GET\"),\n        HeaderField::new(\":path\", \"/\"),\n        HeaderField::new(\"foo\", \"bar\"),\n    ];\n\n    encode(\n        &mut enc_table.encoder(42),\n        &mut block_buf,\n        &mut enc_buf,\n        header.clone().into_iter(),\n    )\n    .unwrap();\n\n    let mut enc_cur = Cursor::new(&mut enc_buf);\n    on_encoder_recv(&mut dec_table.inserter(), &mut enc_cur, &mut dec_buf).unwrap();\n\n    let mut block_cur = Cursor::new(&mut block_buf);\n    assert_eq!(decode_header(&dec_table, &mut block_cur), Ok(header));\n\n    let mut dec_cur = Cursor::new(&mut dec_buf);\n    on_decoder_recv(&mut enc_table, &mut dec_cur).unwrap();\n}", "item_id": 2, "repo": "tetcoin/quinn", "file": "quinn-h3/src/qpack/tests.rs", "last_update_at": "2019-11-10T21:24:54+00:00", "question_id": "2beab526c50deb5dd572d1a7e311921b71bac838_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn codec_basic_get() {\n    let mut enc_table = DynamicTable::new();\n    let mut dec_table = DynamicTable::new();\n    let mut block_buf = vec![];\n    let mut enc_buf = vec![];\n    let mut dec_buf = vec![];\n    let header = vec![\n        HeaderField::new(\":method\", \"GET\"),\n        HeaderField::new(\":path\", \"/\"),\n        HeaderField::new(\"foo\", \"bar\"),\n    ];\n    encode(\n        &mut enc_table.encoder(42),\n        &mut block_buf,\n        &mut enc_buf,\n        header.clone().into_iter(),\n    )\n    .unwrap();\n    let mut enc_cur = Cursor::new(&mut enc_buf);\n    on_encoder_recv(&mut dec_table.inserter(), &mut enc_cur, &mut dec_buf).unwrap();\n    let mut block_cur = Cursor::new(&mut block_buf);\n    assert_eq!(decode_header(&dec_table, &mut block_cur), Ok(header));\n    let mut dec_cur = Cursor::new(&mut dec_buf);\n    on_decoder_recv(&mut enc_table, &mut dec_cur).unwrap();\n"]]}
{"hexsha": "8b8f8095a6e61a9e5c6f93e1186ec020d71b62c2", "ext": "rs", "lang": "Rust", "content": "fn get_pos(value: i64, mode: i64, base: i64) -> i64 {\n    let mut pos = 0;\n    if mode == 0 {\n        pos = value\n    } else if mode == 2 {\n        pos = value + base;\n    } else {\n        assert!(false);\n    }\n    return pos;\n}", "item_id": 1, "repo": "pankdm/adventofcode-2019", "file": "src/bin/day17.rs", "last_update_at": "2019-12-13T02:21:50+00:00", "question_id": "8b8f8095a6e61a9e5c6f93e1186ec020d71b62c2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_pos(value: i64, mode: i64, base: i64) -> i64 {\n    let mut pos = 0;\n    if mode == 0 {\n        pos = value\n    } else if mode == 2 {\n        pos = value + base;\n    } else {\n        assert!(false);\n    }\n    return pos;\n"]]}
{"hexsha": "2cf05c9fa1c0f36fadf892b626e7a18bc381f371", "ext": "rs", "lang": "Rust", "content": "pub fn concat_with_file_separator<S1: Into<String>, S2: AsRef<str>>(s1: S1, s2: S2) -> String {\n    #[cfg(unix)]\n    {\n        crate::concat_with_slash(s1, s2)\n    }\n\n    #[cfg(windows)]\n    {\n        crate::concat_with_backslash(s1, s2)\n    }\n}", "item_id": 8, "repo": "magiclen/slash-formatter", "file": "src/file_separator.rs", "last_update_at": "2019-12-03T07:34:39+00:00", "question_id": "2cf05c9fa1c0f36fadf892b626e7a18bc381f371_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn concat_with_file_separator<S1: Into<String>, S2: AsRef<str>>(s1: S1, s2: S2) -> String {\n    #[cfg(unix)]\n    {\n        crate::concat_with_slash(s1, s2)\n    }\n    #[cfg(windows)]\n    {\n        crate::concat_with_backslash(s1, s2)\n    }\n"]]}
{"hexsha": "21a036a24be53e507c8f939654a8bc32af1477a1", "ext": "rs", "lang": "Rust", "content": "fn on_visibility_change() {\n    let window = window().unwrap();\n    let document = window.document().unwrap();\n\n    if document.visibility_state() == VisibilityState::Visible {\n        document.set_title(DEFAULT_TITLE);\n    }\n}", "item_id": 0, "repo": "rail44/wino", "file": "rust/src/lib.rs", "last_update_at": "2019-07-04T22:32:00+00:00", "question_id": "21a036a24be53e507c8f939654a8bc32af1477a1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn on_visibility_change() {\n    let window = window().unwrap();\n    let document = window.document().unwrap();\n    if document.visibility_state() == VisibilityState::Visible {\n        document.set_title(DEFAULT_TITLE);\n    }\n"]]}
{"hexsha": "afc255f62ac60f15d10841fcb2b606dfdc700761", "ext": "rs", "lang": "Rust", "content": "fn test_pointers_bitfield() {\n        let mut bitfield = PointersBitfield::default();\n\n        bitfield.set(0);\n        bitfield.set(1);\n        bitfield.set(3);\n        bitfield.set(4);\n        bitfield.set(8);\n        bitfield.set(30);\n        bitfield.set(31);\n\n        assert_eq!(bitfield.get_index_for(0).unwrap(), 0);\n        assert_eq!(bitfield.get_index_for(1).unwrap(), 1);\n        assert_eq!(bitfield.get_index_for(3).unwrap(), 2);\n        assert_eq!(bitfield.get_index_for(4).unwrap(), 3);\n        assert_eq!(bitfield.get_index_for(8).unwrap(), 4);\n        assert_eq!(bitfield.get_index_for(30).unwrap(), 5);\n        assert_eq!(bitfield.get_index_for(31).unwrap(), 6);\n\n        assert!(bitfield.get_index_for(15).is_none());\n        assert!(bitfield.get_index_for(29).is_none());\n\n        assert_eq!(bitfield.count(), 7);\n\n        let mut bitfield = PointersBitfield::default();\n\n        bitfield.set(5);\n        bitfield.set(30);\n        bitfield.set(31);\n\n        assert_eq!(bitfield.get_index_for(5).unwrap(), 0);\n        assert_eq!(bitfield.get_index_for(30).unwrap(), 1);\n        assert_eq!(bitfield.get_index_for(31).unwrap(), 2);\n\n        assert_eq!(bitfield.count(), 3);\n    }", "item_id": 1, "repo": "simplestaking/tezos-rs", "file": "tezos/context/src/working_tree/storage.rs", "last_update_at": "2019-10-25T18:40:15+00:00", "question_id": "afc255f62ac60f15d10841fcb2b606dfdc700761_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_pointers_bitfield() {\n        let mut bitfield = PointersBitfield::default();\n        bitfield.set(0);\n        bitfield.set(1);\n        bitfield.set(3);\n        bitfield.set(4);\n        bitfield.set(8);\n        bitfield.set(30);\n        bitfield.set(31);\n        assert_eq!(bitfield.get_index_for(0).unwrap(), 0);\n        assert_eq!(bitfield.get_index_for(1).unwrap(), 1);\n        assert_eq!(bitfield.get_index_for(3).unwrap(), 2);\n        assert_eq!(bitfield.get_index_for(4).unwrap(), 3);\n        assert_eq!(bitfield.get_index_for(8).unwrap(), 4);\n        assert_eq!(bitfield.get_index_for(30).unwrap(), 5);\n        assert_eq!(bitfield.get_index_for(31).unwrap(), 6);\n        assert!(bitfield.get_index_for(15).is_none());\n        assert!(bitfield.get_index_for(29).is_none());\n        assert_eq!(bitfield.count(), 7);\n        let mut bitfield = PointersBitfield::default();\n        bitfield.set(5);\n        bitfield.set(30);\n        bitfield.set(31);\n        assert_eq!(bitfield.get_index_for(5).unwrap(), 0);\n        assert_eq!(bitfield.get_index_for(30).unwrap(), 1);\n        assert_eq!(bitfield.get_index_for(31).unwrap(), 2);\n        assert_eq!(bitfield.count(), 3);\n"]]}
{"hexsha": "3d55062c5244f88dcd462a368f5ca932bdf94007", "ext": "rs", "lang": "Rust", "content": "fn spec_test_401() {\n    let original = r##\"__foo__bar__baz__\n\"##;\n    let expected = r##\"<p><strong>foo__bar__baz</strong></p>\n\"##;\n\n    test_markdown_html(original, expected);\n}", "item_id": 400, "repo": "NaokiM03/pulldown-cmark", "file": "tests/suite/spec.rs", "last_update_at": "2019-07-11T13:20:46+00:00", "question_id": "3d55062c5244f88dcd462a368f5ca932bdf94007_400", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn spec_test_401() {\n    let original = r##\"__foo__bar__baz__\n\"##;\n    let expected = r##\"<p><strong>foo__bar__baz</strong></p>\n\"##;\n    test_markdown_html(original, expected);\n"]]}
{"hexsha": "7ee77bc234dc7f335e2c53edac5b765a1a3cdf1d", "ext": "rs", "lang": "Rust", "content": "fn inc_with_hc() {\n        let mut mem: Memory = Memory::new();\n        let mut cpu: CPU = CPU::new(&mut mem);\n        cpu.registers.write(&Register8bits::B, 15);\n\n        inc(&mut cpu, Register8bits::B);\n\n        assert_eq!(cpu.registers.read(&Register8bits::B), 16);\n        assert_eq!(cpu.registers.read_hc_flag(), true)\n    }", "item_id": 25, "repo": "davidor/gebers", "file": "src/cpu/eight_bit_arithm_logic_ops.rs", "last_update_at": "2019-04-08T09:31:04+00:00", "question_id": "7ee77bc234dc7f335e2c53edac5b765a1a3cdf1d_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn inc_with_hc() {\n        let mut mem: Memory = Memory::new();\n        let mut cpu: CPU = CPU::new(&mut mem);\n        cpu.registers.write(&Register8bits::B, 15);\n        inc(&mut cpu, Register8bits::B);\n        assert_eq!(cpu.registers.read(&Register8bits::B), 16);\n        assert_eq!(cpu.registers.read_hc_flag(), true)\n"]]}
{"hexsha": "388ae2ff921b6696053c375108e34e169c32e862", "ext": "rs", "lang": "Rust", "content": "fn primitive_type() {\n    let mut i = 0;\n    let mut v = 0;\n    observable::from_iter(100..101)\n      .tap(|i| v = *i)\n      .subscribe(|v| i += v);\n    assert_eq!(i, 100);\n    assert_eq!(v, 100);\n  }", "item_id": 0, "repo": "corp-momenti/rxRust", "file": "src/ops/tap.rs", "last_update_at": "2019-11-11T23:56:57+00:00", "question_id": "388ae2ff921b6696053c375108e34e169c32e862_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn primitive_type() {\n    let mut i = 0;\n    let mut v = 0;\n    observable::from_iter(100..101)\n      .tap(|i| v = *i)\n      .subscribe(|v| i += v);\n    assert_eq!(i, 100);\n    assert_eq!(v, 100);\n"]]}
{"hexsha": "29bd81d0aa810bf8b8ee38a2428e054b9a5f4924", "ext": "rs", "lang": "Rust", "content": "pub fn polling() {\n        let spec = Arc::new(ChainSpec::foundation());\n        let duties_map = Arc::new(EpochDutiesMap::new(spec.slots_per_epoch));\n        let keypair = Keypair::random();\n        let slot_clock = Arc::new(TestingSlotClock::new(0));\n        let beacon_node = Arc::new(TestBeaconNode::default());\n\n        let manager = DutiesManager {\n            spec: spec.clone(),\n            pubkey: keypair.pk.clone(),\n            duties_map: duties_map.clone(),\n            slot_clock: slot_clock.clone(),\n            beacon_node: beacon_node.clone(),\n        };\n\n        // Configure response from the BeaconNode.\n        let duties = EpochDuties {\n            validator_index: 0,\n            block_production_slot: Some(Slot::new(10)),\n        };\n        beacon_node.set_next_shuffling_result(Ok(Some(duties)));\n\n        // Get the duties for the first time...\n        assert_eq!(\n            manager.poll(),\n            Ok(PollOutcome::NewDuties(Epoch::new(0), duties))\n        );\n        // Get the same duties again...\n        assert_eq!(manager.poll(), Ok(PollOutcome::NoChange(Epoch::new(0))));\n\n        // Return new duties.\n        let duties = EpochDuties {\n            validator_index: 0,\n            block_production_slot: Some(Slot::new(11)),\n        };\n        beacon_node.set_next_shuffling_result(Ok(Some(duties)));\n        assert_eq!(\n            manager.poll(),\n            Ok(PollOutcome::DutiesChanged(Epoch::new(0), duties))\n        );\n\n        // Return no duties.\n        beacon_node.set_next_shuffling_result(Ok(None));\n        assert_eq!(\n            manager.poll(),\n            Ok(PollOutcome::UnknownValidatorOrEpoch(Epoch::new(0)))\n        );\n    }", "item_id": 0, "repo": "zedt3ster/lighthouse", "file": "validator_client/src/duties/mod.rs", "last_update_at": "2019-04-15T06:39:50+00:00", "question_id": "29bd81d0aa810bf8b8ee38a2428e054b9a5f4924_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn polling() {\n        let spec = Arc::new(ChainSpec::foundation());\n        let duties_map = Arc::new(EpochDutiesMap::new(spec.slots_per_epoch));\n        let keypair = Keypair::random();\n        let slot_clock = Arc::new(TestingSlotClock::new(0));\n        let beacon_node = Arc::new(TestBeaconNode::default());\n        let manager = DutiesManager {\n            spec: spec.clone(),\n            pubkey: keypair.pk.clone(),\n            duties_map: duties_map.clone(),\n            slot_clock: slot_clock.clone(),\n            beacon_node: beacon_node.clone(),\n        };\n        // Configure response from the BeaconNode.\n        let duties = EpochDuties {\n            validator_index: 0,\n            block_production_slot: Some(Slot::new(10)),\n        };\n        beacon_node.set_next_shuffling_result(Ok(Some(duties)));\n        // Get the duties for the first time...\n        assert_eq!(\n            manager.poll(),\n            Ok(PollOutcome::NewDuties(Epoch::new(0), duties))\n        );\n        // Get the same duties again...\n        assert_eq!(manager.poll(), Ok(PollOutcome::NoChange(Epoch::new(0))));\n        // Return new duties.\n        let duties = EpochDuties {\n            validator_index: 0,\n            block_production_slot: Some(Slot::new(11)),\n        };\n        beacon_node.set_next_shuffling_result(Ok(Some(duties)));\n        assert_eq!(\n            manager.poll(),\n            Ok(PollOutcome::DutiesChanged(Epoch::new(0), duties))\n        );\n        // Return no duties.\n        beacon_node.set_next_shuffling_result(Ok(None));\n        assert_eq!(\n            manager.poll(),\n            Ok(PollOutcome::UnknownValidatorOrEpoch(Epoch::new(0)))\n        );\n"]]}
{"hexsha": "af0d17a5364b49e50bfb038555efe03a2d80bbbf", "ext": "rs", "lang": "Rust", "content": "fn spawn_with_handle(cmd: &mut Command) -> io::Result<(Child, ProcessHandle)> {\n        use self::spawn_task_port::CommandSpawnWithTask;\n        let (child, mach_port_name) = cmd.spawn_get_task_port()?;\n\n        let handle = ProcessHandle::try_from(mach_port_name)?;\n        Ok((child, handle))\n    }", "item_id": 5, "repo": "akhramov/read-process-memory", "file": "src/lib.rs", "last_update_at": "2019-05-03T16:19:53+00:00", "question_id": "af0d17a5364b49e50bfb038555efe03a2d80bbbf_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn spawn_with_handle(cmd: &mut Command) -> io::Result<(Child, ProcessHandle)> {\n        use self::spawn_task_port::CommandSpawnWithTask;\n        let (child, mach_port_name) = cmd.spawn_get_task_port()?;\n        let handle = ProcessHandle::try_from(mach_port_name)?;\n        Ok((child, handle))\n"]]}
{"hexsha": "e6b1432668cf5fcb3e0d437d0afcc02a65b1c4f7", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn wl_display_get_registry(mut wl_display: *mut wl_display)\n -> *mut wl_registry {\n    let mut registry: *mut wl_proxy = 0 as *mut wl_proxy;\n    registry =\n        wl_proxy_marshal_constructor(wl_display as *mut wl_proxy,\n                                     1i32 as uint32_t,\n                                     &wl_registry_interface as\n                                         *const wl_interface,\n                                     0 as *mut libc::c_void);\n    return registry as *mut wl_registry;\n}", "item_id": 0, "repo": "RoastVeg/wlrusts", "file": "src/examples/screencopy.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "e6b1432668cf5fcb3e0d437d0afcc02a65b1c4f7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe extern \"C\" fn wl_display_get_registry(mut wl_display: *mut wl_display)\n -> *mut wl_registry {\n    let mut registry: *mut wl_proxy = 0 as *mut wl_proxy;\n    registry =\n        wl_proxy_marshal_constructor(wl_display as *mut wl_proxy,\n                                     1i32 as uint32_t,\n                                     &wl_registry_interface as\n                                         *const wl_interface,\n                                     0 as *mut libc::c_void);\n    return registry as *mut wl_registry;\n"]]}
{"hexsha": "dacb2e04b07e5e2b6da0be51cd33e4c7689e0ffe", "ext": "rs", "lang": "Rust", "content": "pub fn handle_reset_password(\n    password_data: Form<PasswordData>\n) -> Box<dyn Future<Item=HttpResponse, Error=Error>> {\n    let response: &str;\n    if check_email_format(password_data.email.as_str()) {\n        if check_password_format(password_data.password.as_str()) &&\n            check_password_format(password_data.confirm_password.as_str()) {\n            response = validate_reset_password(password_data.email.as_str(),\n                                               password_data.password.as_str(),\n                                               password_data.confirm_password.as_str())\n        } else {\n            error!(\"{}\", WRONG_PASSWORD_FORMAT);\n            response = WRONG_PASSWORD_FORMAT;\n        }\n    } else {\n        error!(\"{}\", WRONG_EMAIL_FORMAT);\n        response = WRONG_EMAIL_FORMAT;\n    }\n    result(Ok(HttpResponse::Ok()\n        .json(json!({RESPONSE: response}))))\n        .responder()\n}", "item_id": 0, "repo": "pawanbisht62/conf-count", "file": "src/request_handlers/reset_password_handler.rs", "last_update_at": "2019-11-13T18:31:02+00:00", "question_id": "dacb2e04b07e5e2b6da0be51cd33e4c7689e0ffe_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn handle_reset_password(\n    password_data: Form<PasswordData>\n) -> Box<dyn Future<Item=HttpResponse, Error=Error>> {\n    let response: &str;\n    if check_email_format(password_data.email.as_str()) {\n        if check_password_format(password_data.password.as_str()) &&\n            check_password_format(password_data.confirm_password.as_str()) {\n            response = validate_reset_password(password_data.email.as_str(),\n                                               password_data.password.as_str(),\n                                               password_data.confirm_password.as_str())\n        } else {\n            error!(\"{}\", WRONG_PASSWORD_FORMAT);\n            response = WRONG_PASSWORD_FORMAT;\n        }\n    } else {\n        error!(\"{}\", WRONG_EMAIL_FORMAT);\n        response = WRONG_EMAIL_FORMAT;\n    }\n    result(Ok(HttpResponse::Ok()\n        .json(json!({RESPONSE: response}))))\n        .responder()\n"]]}
{"hexsha": "8a1db5bbb64701d67faaec6060244b687ae6608d", "ext": "rs", "lang": "Rust", "content": "fn run_all_thursters(\n    phase_sequence: Vec<i32>,\n    program: &Vec<i32>,\n) -> Result<i32, Box<dyn error::Error>> {\n    let mut input_signal = 0;\n    for phase_setting in phase_sequence {\n        input_signal = run_thruster_computer(phase_setting, input_signal, program)?;\n    }\n    Ok(input_signal)\n}", "item_id": 1, "repo": "dmweis/advent_of_code_2019", "file": "src/day_seven.rs", "last_update_at": "2019-12-02T17:50:57+00:00", "question_id": "8a1db5bbb64701d67faaec6060244b687ae6608d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn run_all_thursters(\n    phase_sequence: Vec<i32>,\n    program: &Vec<i32>,\n) -> Result<i32, Box<dyn error::Error>> {\n    let mut input_signal = 0;\n    for phase_setting in phase_sequence {\n        input_signal = run_thruster_computer(phase_setting, input_signal, program)?;\n    }\n    Ok(input_signal)\n"]]}
{"hexsha": "8ad40a073520dbaa4b6acc84644721085c98f77e", "ext": "rs", "lang": "Rust", "content": "fn i32_overflow() {\n        let max = std::i32::MAX;\n        let min = std::i32::MIN;\n\n        let apply_overflow = Transform::AddInt32(1).apply(max.into());\n        let apply_underflow = Transform::AddInt32(-1).apply(min.into());\n\n        let transform_overflow = Transform::AddInt32(max) + Transform::AddInt32(1);\n        let transform_underflow = Transform::AddInt32(min) + Transform::AddInt32(-1);\n\n        assert_eq!(apply_overflow.expect(\"Unexpected overflow\"), min.into());\n        assert_eq!(apply_underflow.expect(\"Unexpected underflow\"), max.into());\n\n        assert_eq!(transform_overflow, min.into());\n        assert_eq!(transform_underflow, max.into());\n    }", "item_id": 0, "repo": "srinivasreddy/CasperLabs", "file": "execution-engine/engine-shared/src/transform.rs", "last_update_at": "2019-09-18T18:14:02+00:00", "question_id": "8ad40a073520dbaa4b6acc84644721085c98f77e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn i32_overflow() {\n        let max = std::i32::MAX;\n        let min = std::i32::MIN;\n        let apply_overflow = Transform::AddInt32(1).apply(max.into());\n        let apply_underflow = Transform::AddInt32(-1).apply(min.into());\n        let transform_overflow = Transform::AddInt32(max) + Transform::AddInt32(1);\n        let transform_underflow = Transform::AddInt32(min) + Transform::AddInt32(-1);\n        assert_eq!(apply_overflow.expect(\"Unexpected overflow\"), min.into());\n        assert_eq!(apply_underflow.expect(\"Unexpected underflow\"), max.into());\n        assert_eq!(transform_overflow, min.into());\n        assert_eq!(transform_underflow, max.into());\n"]]}
{"hexsha": "0ebfaaf2747abc0df43c3fc555667b942b1ca34f", "ext": "rs", "lang": "Rust", "content": "fn empty_string() {\n        let mut d = String::from(r#\"\"\"\"#);\n        let mut d1 = d.clone();\n        let mut d1 = unsafe { d1.as_bytes_mut() };\n        let mut d = unsafe { d.as_bytes_mut() };\n        let v_serde: serde_json::Value = serde_json::from_slice(d).expect(\"\");\n        let v_simd: serde_json::Value = from_slice(&mut d).expect(\"\");\n        assert_eq!(to_value(&mut d1), Ok(Value::from(\"\")));\n        assert_eq!(v_simd, v_serde);\n    }", "item_id": 19, "repo": "sunnygleason/simdjson-rs", "file": "src/lib.rs", "last_update_at": "2019-11-16T16:07:15+00:00", "question_id": "0ebfaaf2747abc0df43c3fc555667b942b1ca34f_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn empty_string() {\n        let mut d = String::from(r#\"\"\"\"#);\n        let mut d1 = d.clone();\n        let mut d1 = unsafe { d1.as_bytes_mut() };\n        let mut d = unsafe { d.as_bytes_mut() };\n        let v_serde: serde_json::Value = serde_json::from_slice(d).expect(\"\");\n        let v_simd: serde_json::Value = from_slice(&mut d).expect(\"\");\n        assert_eq!(to_value(&mut d1), Ok(Value::from(\"\")));\n        assert_eq!(v_simd, v_serde);\n"]]}
{"hexsha": "bcf21bfed2654741d2a5676fa297cc74ab3f6c2d", "ext": "rs", "lang": "Rust", "content": "pub fn serialize_stub(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let ast = parse_macro_input!(input as DeriveInput);\n    let struct_name = &ast.ident;\n    \n    proc_macro::TokenStream::from(quote! {\n        #[doc(hidden)]\n        #[allow(non_upper_case_globals,unused_attributes,unused_qualifications)]\n        const _: () = {\n            #[allow(unused_extern_crates,clippy::useless_attribute)]\n            extern crate serde as _serde;\n\n            #[automatically_derived]\n            impl _serde::Serialize for #struct_name {\n                fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error> where __S: _serde::Serializer {\n                    Err(_serde::ser::Error::custom(\"This is a placeholder generated by the Serialize_Stub macro, for quick resolution during cargo-check. You should not be seeing this at runtime.\"))\n                }\n            }\n        };\n    })\n}", "item_id": 1, "repo": "Venryx/DebateMap", "file": "Packages/rust-macros/src/lib.rs", "last_update_at": "2019-12-30T13:00:05+00:00", "question_id": "bcf21bfed2654741d2a5676fa297cc74ab3f6c2d_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn serialize_stub(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    let ast = parse_macro_input!(input as DeriveInput);\n    let struct_name = &ast.ident;\n    proc_macro::TokenStream::from(quote! {\n        #[doc(hidden)]\n        #[allow(non_upper_case_globals,unused_attributes,unused_qualifications)]\n        const _: () = {\n            #[allow(unused_extern_crates,clippy::useless_attribute)]\n            extern crate serde as _serde;\n            #[automatically_derived]\n            impl _serde::Serialize for #struct_name {\n                fn serialize<__S>(&self, __serializer: __S) -> _serde::__private::Result<__S::Ok, __S::Error> where __S: _serde::Serializer {\n                    Err(_serde::ser::Error::custom(\"This is a placeholder generated by the Serialize_Stub macro, for quick resolution during cargo-check. You should not be seeing this at runtime.\"))\n                }\n            }\n        };\n    })\n"]]}
{"hexsha": "a4d9a79eb9bbafb3fe8f46e3f83c8a2712f51b1b", "ext": "rs", "lang": "Rust", "content": "fn play_desc_pickoff_cs(input: &str) -> IResult<&str, PlayDescription> {\n    let (input, _) = tag(\"POCS\")(input)?;\n    let (input, base) = base(input)?;\n    let (input, _) = tag(\"(\")(input)?;\n    let (input, throws) = many1(complete(fielder))(input)?;\n    let (input, _) = tag(\")\")(input)?;\n\n    Ok((input, PlayDescription::PickOffCaughtStealing(base, throws)))\n}", "item_id": 18, "repo": "eugene-bulkin/retrosheet-rs", "file": "src/parsers.rs", "last_update_at": "2019-11-27T04:32:55+00:00", "question_id": "a4d9a79eb9bbafb3fe8f46e3f83c8a2712f51b1b_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn play_desc_pickoff_cs(input: &str) -> IResult<&str, PlayDescription> {\n    let (input, _) = tag(\"POCS\")(input)?;\n    let (input, base) = base(input)?;\n    let (input, _) = tag(\"(\")(input)?;\n    let (input, throws) = many1(complete(fielder))(input)?;\n    let (input, _) = tag(\")\")(input)?;\n    Ok((input, PlayDescription::PickOffCaughtStealing(base, throws)))\n"]]}
{"hexsha": "929d0e4e2dca7b13138bc8a1f95780ecec935cf7", "ext": "rs", "lang": "Rust", "content": "fn program() {\n        assert_program(\n            r#\"BEGIN { print \"start\" } END { print \"end\" }\"#,\n            Program::new(vec![\n                Item::PatternAction(\n                    Some(Pattern::Begin),\n                    StmtList(vec![Stmt::Print(\n                        ExprList(vec![Expr::String(\"start\".to_owned())]),\n                        None,\n                    )]),\n                ),\n                Item::PatternAction(\n                    Some(Pattern::End),\n                    StmtList(vec![Stmt::Print(\n                        ExprList(vec![Expr::String(\"end\".to_owned())]),\n                        None,\n                    )]),\n                ),\n            ]),\n        );\n        assert_program(\n            r#\"BEGIN { print \"start\" }; ; END { print \"end\" }\"#,\n            Program::new(vec![\n                Item::PatternAction(\n                    Some(Pattern::Begin),\n                    StmtList(vec![Stmt::Print(\n                        ExprList(vec![Expr::String(\"start\".to_owned())]),\n                        None,\n                    )]),\n                ),\n                Item::PatternAction(\n                    Some(Pattern::End),\n                    StmtList(vec![Stmt::Print(\n                        ExprList(vec![Expr::String(\"end\".to_owned())]),\n                        None,\n                    )]),\n                ),\n            ]),\n        );\n        assert_program(\n            r#\"\n            BEGIN { print \"start\" }\n            END { print \"end\" }\"#,\n            Program::new(vec![\n                Item::PatternAction(\n                    Some(Pattern::Begin),\n                    StmtList(vec![Stmt::Print(\n                        ExprList(vec![Expr::String(\"start\".to_owned())]),\n                        None,\n                    )]),\n                ),\n                Item::PatternAction(\n                    Some(Pattern::End),\n                    StmtList(vec![Stmt::Print(\n                        ExprList(vec![Expr::String(\"end\".to_owned())]),\n                        None,\n                    )]),\n                ),\n            ]),\n        );\n        assert_program(\"\", Program::new(vec![]));\n    }", "item_id": 5, "repo": "scampi/falcon", "file": "src/parser/program.rs", "last_update_at": "2019-12-15T09:53:00+00:00", "question_id": "929d0e4e2dca7b13138bc8a1f95780ecec935cf7_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn program() {\n        assert_program(\n            r#\"BEGIN { print \"start\" } END { print \"end\" }\"#,\n            Program::new(vec![\n                Item::PatternAction(\n                    Some(Pattern::Begin),\n                    StmtList(vec![Stmt::Print(\n                        ExprList(vec![Expr::String(\"start\".to_owned())]),\n                        None,\n                    )]),\n                ),\n                Item::PatternAction(\n                    Some(Pattern::End),\n                    StmtList(vec![Stmt::Print(\n                        ExprList(vec![Expr::String(\"end\".to_owned())]),\n                        None,\n                    )]),\n                ),\n            ]),\n        );\n        assert_program(\n            r#\"BEGIN { print \"start\" }; ; END { print \"end\" }\"#,\n            Program::new(vec![\n                Item::PatternAction(\n                    Some(Pattern::Begin),\n                    StmtList(vec![Stmt::Print(\n                        ExprList(vec![Expr::String(\"start\".to_owned())]),\n                        None,\n                    )]),\n                ),\n                Item::PatternAction(\n                    Some(Pattern::End),\n                    StmtList(vec![Stmt::Print(\n                        ExprList(vec![Expr::String(\"end\".to_owned())]),\n                        None,\n                    )]),\n                ),\n            ]),\n        );\n        assert_program(\n            r#\"\n            BEGIN { print \"start\" }\n            END { print \"end\" }\"#,\n            Program::new(vec![\n                Item::PatternAction(\n                    Some(Pattern::Begin),\n                    StmtList(vec![Stmt::Print(\n                        ExprList(vec![Expr::String(\"start\".to_owned())]),\n                        None,\n                    )]),\n                ),\n                Item::PatternAction(\n                    Some(Pattern::End),\n                    StmtList(vec![Stmt::Print(\n                        ExprList(vec![Expr::String(\"end\".to_owned())]),\n                        None,\n                    )]),\n                ),\n            ]),\n        );\n        assert_program(\"\", Program::new(vec![]));\n"]]}
{"hexsha": "b182c96428d3cea258dfcf413950acc17aed17e0", "ext": "rs", "lang": "Rust", "content": "fn no_digits() {\n        let input = \"verify\\nthis\";\n        let expected = \"    verify\\n    this\";\n        let mut output = String::new();\n\n        Indented {\n            inner: &mut output,\n            ind: None,\n            started: false,\n        }\n        .write_str(input)\n        .unwrap();\n\n        assert_eq!(expected, output);\n    }", "item_id": 2, "repo": "yaahc/eyre-impl", "file": "src/lib.rs", "last_update_at": "2019-12-18T20:47:23+00:00", "question_id": "b182c96428d3cea258dfcf413950acc17aed17e0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn no_digits() {\n        let input = \"verify\\nthis\";\n        let expected = \"    verify\\n    this\";\n        let mut output = String::new();\n        Indented {\n            inner: &mut output,\n            ind: None,\n            started: false,\n        }\n        .write_str(input)\n        .unwrap();\n        assert_eq!(expected, output);\n"]]}
{"hexsha": "83310b584c1263b665f6548706cb87d445c7cd85", "ext": "rs", "lang": "Rust", "content": "pub fn mutate<'a, T, R>(a: &'a T, rng: &mut R) -> T where \n    T: Visitable<'a>+Copyable,\n    R: rand::Rng+Sized\n{\n    let mut nodes = BucketCollector::new();\n    a.visit(&mut nodes);\n\n    let t_nodes = nodes.get_counts().into_iter()\n        .filter(|&(_, nc)| nc > 0)\n        .map(|(t, _)| t)\n        .collect::<Vec<NodeType>>();\n\n    let picked_type = rng.choose(&t_nodes).unwrap();\n\n    match *picked_type {\n        NodeType::Program    => mut_program(a, rng.choose(&nodes.programs).unwrap(), rng),\n        NodeType::Expression => mut_expression(a, rng.choose(&nodes.expressions).unwrap(), rng),\n        NodeType::Condition  => mut_condition(a, rng.choose(&nodes.conditions).unwrap(), rng),\n        NodeType::Sensor     => mut_sensor(a, rng.choose(&nodes.sensors).unwrap(), rng),\n        NodeType::Command    => mut_command(a, rng.choose(&nodes.commands).unwrap(), rng)\n    }\n}", "item_id": 0, "repo": "darwins-challenge/moonlander-ast-rust", "file": "src/darwin/mutation.rs", "last_update_at": "2019-03-12T10:41:50+00:00", "question_id": "83310b584c1263b665f6548706cb87d445c7cd85_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn mutate<'a, T, R>(a: &'a T, rng: &mut R) -> T where \n    T: Visitable<'a>+Copyable,\n    R: rand::Rng+Sized\n{\n    let mut nodes = BucketCollector::new();\n    a.visit(&mut nodes);\n    let t_nodes = nodes.get_counts().into_iter()\n        .filter(|&(_, nc)| nc > 0)\n        .map(|(t, _)| t)\n        .collect::<Vec<NodeType>>();\n    let picked_type = rng.choose(&t_nodes).unwrap();\n    match *picked_type {\n        NodeType::Program    => mut_program(a, rng.choose(&nodes.programs).unwrap(), rng),\n        NodeType::Expression => mut_expression(a, rng.choose(&nodes.expressions).unwrap(), rng),\n        NodeType::Condition  => mut_condition(a, rng.choose(&nodes.conditions).unwrap(), rng),\n        NodeType::Sensor     => mut_sensor(a, rng.choose(&nodes.sensors).unwrap(), rng),\n        NodeType::Command    => mut_command(a, rng.choose(&nodes.commands).unwrap(), rng)\n    }\n"]]}
{"hexsha": "96c41d09acad5146cfdf35724a2db6aa8f836d1c", "ext": "rs", "lang": "Rust", "content": "pub fn add_bindings() {\n        let out_dir = env::var(\"OUT_DIR\").unwrap();\n        let out_path = PathBuf::from(out_dir).join(\"bindings.rs\");\n        fs::copy(\"bindings/yara-3.7.rs\", out_path)\n            .expect(\"Could not copy bindings to output directory\");\n    }", "item_id": 1, "repo": "r3dlight/yara-rust", "file": "yara-sys/build.rs", "last_update_at": "2019-09-18T13:26:01+00:00", "question_id": "96c41d09acad5146cfdf35724a2db6aa8f836d1c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn add_bindings() {\n        let out_dir = env::var(\"OUT_DIR\").unwrap();\n        let out_path = PathBuf::from(out_dir).join(\"bindings.rs\");\n        fs::copy(\"bindings/yara-3.7.rs\", out_path)\n            .expect(\"Could not copy bindings to output directory\");\n"]]}
{"hexsha": "3184a53b98aeeabc5cd4886b8149ea3bf52266b1", "ext": "rs", "lang": "Rust", "content": "pub fn openssl_find() -> &'static str {\n    // We need a homebrew openssl, because OSX comes with\n    // 0.9.8y or something equally ancient!\n    if cfg!(target_os = \"macos\") {\n        return \"/usr/local/opt/openssl/bin/openssl\";\n    }\n\n    \"openssl\"\n}", "item_id": 1, "repo": "zhangpf/fuchsia-rs", "file": "third_party/rust_crates/vendor/rustls/tests/common/mod.rs", "last_update_at": "2019-04-21T18:02:26+00:00", "question_id": "3184a53b98aeeabc5cd4886b8149ea3bf52266b1_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn openssl_find() -> &'static str {\n    // We need a homebrew openssl, because OSX comes with\n    // 0.9.8y or something equally ancient!\n    if cfg!(target_os = \"macos\") {\n        return \"/usr/local/opt/openssl/bin/openssl\";\n    }\n    \"openssl\"\n"]]}
{"hexsha": "177534a9ff288c0aef4797a0bc6a71cad8e13514", "ext": "rs", "lang": "Rust", "content": "fn test_undefined_conts() {\n    let errs = parse_check(\n      \"(program halt\n        (letfun (f r () (a b) (cont r 100))\n          (letcont (bad-call () (call f cc1 1 2))\n                   (bad-ext-call () (extern-call ext_add cc2 1 2))\n                   (bad-cont () (cont cc3 3))\n                   (bad-branch () (branch (is-true 1) cc4 cc5))\n            (cont halt 0))))\");\n    assert_eq!(errs.len(), 5);\n    assert!(errs[0].contains(\"return to undefined cont: 'cc1'\"));\n    assert!(errs[1].contains(\"extern return to undefined cont: 'cc2'\"));\n    assert!(errs[2].contains(\"continue to undefined cont: 'cc3'\"));\n    assert!(errs[3].contains(\"then-branch to undefined cont: 'cc4'\"));\n    assert!(errs[4].contains(\"else-branch to undefined cont: 'cc5'\"));\n  }", "item_id": 5, "repo": "honzasp/spiral", "file": "src/spine/check.rs", "last_update_at": "2019-09-19T04:40:59+00:00", "question_id": "177534a9ff288c0aef4797a0bc6a71cad8e13514_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_undefined_conts() {\n    let errs = parse_check(\n      \"(program halt\n        (letfun (f r () (a b) (cont r 100))\n          (letcont (bad-call () (call f cc1 1 2))\n                   (bad-ext-call () (extern-call ext_add cc2 1 2))\n                   (bad-cont () (cont cc3 3))\n                   (bad-branch () (branch (is-true 1) cc4 cc5))\n            (cont halt 0))))\");\n    assert_eq!(errs.len(), 5);\n    assert!(errs[0].contains(\"return to undefined cont: 'cc1'\"));\n    assert!(errs[1].contains(\"extern return to undefined cont: 'cc2'\"));\n    assert!(errs[2].contains(\"continue to undefined cont: 'cc3'\"));\n    assert!(errs[3].contains(\"then-branch to undefined cont: 'cc4'\"));\n    assert!(errs[4].contains(\"else-branch to undefined cont: 'cc5'\"));\n"]]}
{"hexsha": "fca020326a46bc5abaad26abc848d7a31fc8aa39", "ext": "rs", "lang": "Rust", "content": "pub fn colors(input: &str) -> model::R<view::Colors> {\n    if input == \"simple\" {\n        // Add colorscheme presets here\n        return Ok(view::Colors {\n            ok: Some(Color::Fixed(2)),\n            high: Some(Color::Fixed(1)),\n            normal: Some(Color::Fixed(3)),\n        });\n    }\n\n    let parts: Vec<u8> = input\n        .split(',')\n        .map(|s| s.parse::<u8>().unwrap_or(0))\n        .collect();\n\n    match parts.len() {\n        3 => Ok(view::Colors {\n            ok: Some(Color::Fixed(parts[0])),\n            high: Some(Color::Fixed(parts[1])),\n            normal: Some(Color::Fixed(parts[2])),\n        }),\n        l => Err(format!(\n            \"Unknown custom color input: {}. Expected 4 terms, but got {}.\",\n            input, l\n        )),\n    }\n}", "item_id": 0, "repo": "aignas/git_prompt", "file": "src/parse.rs", "last_update_at": "2019-10-02T16:16:25+00:00", "question_id": "fca020326a46bc5abaad26abc848d7a31fc8aa39_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn colors(input: &str) -> model::R<view::Colors> {\n    if input == \"simple\" {\n        // Add colorscheme presets here\n        return Ok(view::Colors {\n            ok: Some(Color::Fixed(2)),\n            high: Some(Color::Fixed(1)),\n            normal: Some(Color::Fixed(3)),\n        });\n    }\n    let parts: Vec<u8> = input\n        .split(',')\n        .map(|s| s.parse::<u8>().unwrap_or(0))\n        .collect();\n    match parts.len() {\n        3 => Ok(view::Colors {\n            ok: Some(Color::Fixed(parts[0])),\n            high: Some(Color::Fixed(parts[1])),\n            normal: Some(Color::Fixed(parts[2])),\n        }),\n        l => Err(format!(\n            \"Unknown custom color input: {}. Expected 4 terms, but got {}.\",\n            input, l\n        )),\n    }\n"]]}
{"hexsha": "d0add26fda6317ed9502f6dddb6b8abe038328d6", "ext": "rs", "lang": "Rust", "content": "fn it_makes_a_raw_header() {\n        let merkle_root = vec![\n            218, 175, 98, 56, 136, 59, 157, 43, 178, 250, 66, 194, 50, 129, 87, 37, 147, 54, 157,\n            79, 238, 83, 118, 209, 92, 202, 25, 32, 246, 230, 153, 39,\n        ];\n        let state_root = vec![\n            121, 132, 139, 154, 165, 229, 182, 152, 126, 204, 58, 142, 150, 220, 236, 119, 144, 1,\n            181, 107, 19, 130, 67, 220, 241, 192, 46, 94, 69, 215, 134, 11,\n        ];\n        let time_stamp = 1515003305000;\n        let difficulty = 0 as f64;\n        let miner = Address::from_string(&\"H3yGUaF38TxQxoFrqCqPdB2pN9jyBHnaj\".to_string()).unwrap();\n        let previous_hash = vec![\"G4qXusbRyXmf62c8Tsha7iZoyLsVGfka7ynkvb3Esd1d\"\n            .from_base58()\n            .unwrap()];\n        let nonce = 0;\n        let header = Header::new(\n            merkle_root.clone(),\n            time_stamp,\n            difficulty,\n            state_root.clone(),\n            previous_hash.clone(),\n            nonce,\n            miner,\n        );\n        let encoding = header.encode().unwrap();\n        let expected_encoding = vec![\n            10, 32, 223, 218, 236, 54, 245, 118, 35, 75, 80, 237, 79, 63, 61, 46, 46, 228, 77, 128,\n            114, 163, 92, 252, 73, 201, 159, 108, 48, 48, 86, 233, 136, 20, 18, 32, 218, 175, 98,\n            56, 136, 59, 157, 43, 178, 250, 66, 194, 50, 129, 87, 37, 147, 54, 157, 79, 238, 83,\n            118, 209, 92, 202, 25, 32, 246, 230, 153, 39, 26, 32, 121, 132, 139, 154, 165, 229,\n            182, 152, 126, 204, 58, 142, 150, 220, 236, 119, 144, 1, 181, 107, 19, 130, 67, 220,\n            241, 192, 46, 94, 69, 215, 134, 11, 33, 0, 0, 0, 0, 0, 0, 0, 0, 40, 168, 184, 239, 233,\n            139, 44, 48, 0, 58, 20, 213, 49, 13, 190, 194, 137, 35, 119, 16, 249, 57, 125, 207, 78,\n            117, 246, 36, 136, 151, 210,\n        ];\n        let prehash = header.prehash().unwrap();\n        let expected_prehash = vec![\n            213, 155, 184, 6, 160, 192, 238, 37, 190, 172, 89, 224, 41, 36, 132, 38, 46, 5, 70,\n            193, 159, 49, 130, 25, 220, 56, 238, 148, 167, 135, 240, 158, 162, 189, 223, 13, 85,\n            156, 251, 105, 34, 21, 90, 14, 21, 248, 16, 183, 136, 77, 231, 102, 80, 183, 192, 177,\n            184, 19, 75, 226, 188, 134, 38, 218,\n        ];\n\n        assert_eq!(encoding, expected_encoding);\n        assert_eq!(prehash, expected_prehash);\n    }", "item_id": 1, "repo": "elniallo/tokio-experiment", "file": "src/common/header.rs", "last_update_at": "2019-05-24T08:38:11+00:00", "question_id": "d0add26fda6317ed9502f6dddb6b8abe038328d6_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_makes_a_raw_header() {\n        let merkle_root = vec![\n            218, 175, 98, 56, 136, 59, 157, 43, 178, 250, 66, 194, 50, 129, 87, 37, 147, 54, 157,\n            79, 238, 83, 118, 209, 92, 202, 25, 32, 246, 230, 153, 39,\n        ];\n        let state_root = vec![\n            121, 132, 139, 154, 165, 229, 182, 152, 126, 204, 58, 142, 150, 220, 236, 119, 144, 1,\n            181, 107, 19, 130, 67, 220, 241, 192, 46, 94, 69, 215, 134, 11,\n        ];\n        let time_stamp = 1515003305000;\n        let difficulty = 0 as f64;\n        let miner = Address::from_string(&\"H3yGUaF38TxQxoFrqCqPdB2pN9jyBHnaj\".to_string()).unwrap();\n        let previous_hash = vec![\"G4qXusbRyXmf62c8Tsha7iZoyLsVGfka7ynkvb3Esd1d\"\n            .from_base58()\n            .unwrap()];\n        let nonce = 0;\n        let header = Header::new(\n            merkle_root.clone(),\n            time_stamp,\n            difficulty,\n            state_root.clone(),\n            previous_hash.clone(),\n            nonce,\n            miner,\n        );\n        let encoding = header.encode().unwrap();\n        let expected_encoding = vec![\n            10, 32, 223, 218, 236, 54, 245, 118, 35, 75, 80, 237, 79, 63, 61, 46, 46, 228, 77, 128,\n            114, 163, 92, 252, 73, 201, 159, 108, 48, 48, 86, 233, 136, 20, 18, 32, 218, 175, 98,\n            56, 136, 59, 157, 43, 178, 250, 66, 194, 50, 129, 87, 37, 147, 54, 157, 79, 238, 83,\n            118, 209, 92, 202, 25, 32, 246, 230, 153, 39, 26, 32, 121, 132, 139, 154, 165, 229,\n            182, 152, 126, 204, 58, 142, 150, 220, 236, 119, 144, 1, 181, 107, 19, 130, 67, 220,\n            241, 192, 46, 94, 69, 215, 134, 11, 33, 0, 0, 0, 0, 0, 0, 0, 0, 40, 168, 184, 239, 233,\n            139, 44, 48, 0, 58, 20, 213, 49, 13, 190, 194, 137, 35, 119, 16, 249, 57, 125, 207, 78,\n            117, 246, 36, 136, 151, 210,\n        ];\n        let prehash = header.prehash().unwrap();\n        let expected_prehash = vec![\n            213, 155, 184, 6, 160, 192, 238, 37, 190, 172, 89, 224, 41, 36, 132, 38, 46, 5, 70,\n            193, 159, 49, 130, 25, 220, 56, 238, 148, 167, 135, 240, 158, 162, 189, 223, 13, 85,\n            156, 251, 105, 34, 21, 90, 14, 21, 248, 16, 183, 136, 77, 231, 102, 80, 183, 192, 177,\n            184, 19, 75, 226, 188, 134, 38, 218,\n        ];\n        assert_eq!(encoding, expected_encoding);\n        assert_eq!(prehash, expected_prehash);\n"]]}
{"hexsha": "624a0d351ed2e6d8bae2b933511189877adfdd2b", "ext": "rs", "lang": "Rust", "content": "fn name_checks_database() {\n    let mut client = common::setup_with_db(\"name_checks_database\");\n    client.send(1, \".r SWAGGINGi'mSWAGGINGOUT yo yo\");\n    client.send(2, \".n SWAGGINGi'mSWAGGINGOUT\");\n    client.read_all();\n    assert_eq!(\n        client.last(2),\n        \"yo that name exists ya gotta pick something else aight?\"\n    );\n}", "item_id": 5, "repo": "maxrchung/THRUSTIN", "file": "backend/tests/database.rs", "last_update_at": "2019-04-06T22:07:11+00:00", "question_id": "624a0d351ed2e6d8bae2b933511189877adfdd2b_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn name_checks_database() {\n    let mut client = common::setup_with_db(\"name_checks_database\");\n    client.send(1, \".r SWAGGINGi'mSWAGGINGOUT yo yo\");\n    client.send(2, \".n SWAGGINGi'mSWAGGINGOUT\");\n    client.read_all();\n    assert_eq!(\n        client.last(2),\n        \"yo that name exists ya gotta pick something else aight?\"\n    );\n"]]}
{"hexsha": "3d092515e8fcb817d274bfd5a9df7fcf8a1d28bc", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn roots(mut servers: *mut u8, mut q: *mut u8) -> i32 {\n    let mut r: i32;\n    r = roots_find(q);\n    if r == -1i32 {\n        0i32\n    } else {\n        byte::copy(servers, 64u32, data.s.offset(r as (isize)));\n        1i32\n    }\n}", "item_id": 1, "repo": "oxidizers/drdns", "file": "src/roots.rs", "last_update_at": "2019-09-13T11:39:33+00:00", "question_id": "3d092515e8fcb817d274bfd5a9df7fcf8a1d28bc_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn roots(mut servers: *mut u8, mut q: *mut u8) -> i32 {\n    let mut r: i32;\n    r = roots_find(q);\n    if r == -1i32 {\n        0i32\n    } else {\n        byte::copy(servers, 64u32, data.s.offset(r as (isize)));\n        1i32\n    }\n"]]}
{"hexsha": "814f424c5a62e828e2da1367fe7f0b9dbcbafec3", "ext": "rs", "lang": "Rust", "content": "fn parent() {\n        let bitvec = bit_vec![true, true, false, false];\n        let tree: LOUDSTree<String> = LOUDSTree::from_bitvec(bitvec.clone()).unwrap();\n        assert_eq!(tree.parent(3).unwrap(), 1)\n    }", "item_id": 9, "repo": "davidmehren/fp-succinct-trees-1", "file": "src/louds_tree.rs", "last_update_at": "2019-07-19T08:03:22+00:00", "question_id": "814f424c5a62e828e2da1367fe7f0b9dbcbafec3_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parent() {\n        let bitvec = bit_vec![true, true, false, false];\n        let tree: LOUDSTree<String> = LOUDSTree::from_bitvec(bitvec.clone()).unwrap();\n        assert_eq!(tree.parent(3).unwrap(), 1)\n"]]}
{"hexsha": "86e276cf73aeebbd84207b9fb5d96c9fb1160eb4", "ext": "rs", "lang": "Rust", "content": "fn protover_all_supported_should_exclude_versions_we_actually_do_support_complex2() {\n    let proto: UnvalidatedProtoEntry = \"Link=1-3,5-12\".parse().unwrap();\n    let result: String = proto.all_supported().unwrap().to_string();\n\n    assert_eq!(result, \"Link=6-12\".to_string());\n}", "item_id": 32, "repo": "sofwerx/tor", "file": "src/rust/protover/tests/protover.rs", "last_update_at": "2019-05-31T20:10:19+00:00", "question_id": "86e276cf73aeebbd84207b9fb5d96c9fb1160eb4_32", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn protover_all_supported_should_exclude_versions_we_actually_do_support_complex2() {\n    let proto: UnvalidatedProtoEntry = \"Link=1-3,5-12\".parse().unwrap();\n    let result: String = proto.all_supported().unwrap().to_string();\n    assert_eq!(result, \"Link=6-12\".to_string());\n"]]}
{"hexsha": "474cfdaebd1e7049d631e0a9ce53ec815892756b", "ext": "rs", "lang": "Rust", "content": "fn can_evaluate_map_with_duplicate_keys() {\n        let map_expr            = Expression::Map(vec![ (Expression::string(\"\\\"Foo\\\"\"), Expression::number(\"1\")), (Expression::string(\"\\\"Foo\\\"\"), Expression::number(\"2\")) ]);\n        let empty_environment   = EmptyEnvironment::new();\n        let mut env             = ScriptExecutionEnvironment::new();\n        let result              = evaluate_unbound_expression(&map_expr, &empty_environment, &mut env);\n\n        assert!(result == Ok(json![ { \"Foo\": 2 } ]));\n    }", "item_id": 21, "repo": "Logicalshift/gossyp", "file": "gossyp_lang/src/script/evaluate_expression.rs", "last_update_at": "2019-04-16T19:55:25+00:00", "question_id": "474cfdaebd1e7049d631e0a9ce53ec815892756b_21", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn can_evaluate_map_with_duplicate_keys() {\n        let map_expr            = Expression::Map(vec![ (Expression::string(\"\\\"Foo\\\"\"), Expression::number(\"1\")), (Expression::string(\"\\\"Foo\\\"\"), Expression::number(\"2\")) ]);\n        let empty_environment   = EmptyEnvironment::new();\n        let mut env             = ScriptExecutionEnvironment::new();\n        let result              = evaluate_unbound_expression(&map_expr, &empty_environment, &mut env);\n        assert!(result == Ok(json![ { \"Foo\": 2 } ]));\n"]]}
{"hexsha": "6d056f9b5880c8e6f933ab4571208896692720e6", "ext": "rs", "lang": "Rust", "content": "pub fn get_topic(topic: &str) -> Result<Json<dto::GetTopicResult>, String> {\n    let offsets = _get_offsets(topic)?;\n    let groups = _get_topic_consumer_groups(topic, &offsets, false)?;\n    Ok(Json(dto::GetTopicResult{\n        offsets: offsets,\n        consumer_groups: groups,\n    }))\n}", "item_id": 2, "repo": "tzachshabtay/kafka-browser", "file": "src/server/kafka/api.rs", "last_update_at": "2019-06-17T13:17:44+00:00", "question_id": "6d056f9b5880c8e6f933ab4571208896692720e6_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_topic(topic: &str) -> Result<Json<dto::GetTopicResult>, String> {\n    let offsets = _get_offsets(topic)?;\n    let groups = _get_topic_consumer_groups(topic, &offsets, false)?;\n    Ok(Json(dto::GetTopicResult{\n        offsets: offsets,\n        consumer_groups: groups,\n    }))\n"]]}
{"hexsha": "aef2ef5c2b69a79c8bd960a4d436d5edb1a15ab5", "ext": "rs", "lang": "Rust", "content": "fn test_put_with_err() {\n        let config = Config::new();\n        // New engine lack of some column families.\n        let engine = engine::new_local_engine(&config.path, &[\"default\"]).unwrap();\n        let mut storage = Storage::from_engine(engine, &config).unwrap();\n        storage.start(&config).unwrap();\n        let (tx, rx) = channel();\n        storage.async_prewrite(Context::new(),\n                            vec![\n            Mutation::Put((make_key(b\"a\"), b\"aa\".to_vec())),\n            Mutation::Put((make_key(b\"b\"), b\"bb\".to_vec())),\n            Mutation::Put((make_key(b\"c\"), b\"cc\".to_vec())),\n            ],\n                            b\"a\".to_vec(),\n                            1,\n                            Options::default(),\n                            expect_fail(tx.clone()))\n            .unwrap();\n        rx.recv().unwrap();\n        storage.stop().unwrap();\n    }", "item_id": 2, "repo": "Caoming/tikv", "file": "src/storage/mod.rs", "last_update_at": "2019-09-07T01:44:36+00:00", "question_id": "aef2ef5c2b69a79c8bd960a4d436d5edb1a15ab5_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_put_with_err() {\n        let config = Config::new();\n        // New engine lack of some column families.\n        let engine = engine::new_local_engine(&config.path, &[\"default\"]).unwrap();\n        let mut storage = Storage::from_engine(engine, &config).unwrap();\n        storage.start(&config).unwrap();\n        let (tx, rx) = channel();\n        storage.async_prewrite(Context::new(),\n                            vec![\n            Mutation::Put((make_key(b\"a\"), b\"aa\".to_vec())),\n            Mutation::Put((make_key(b\"b\"), b\"bb\".to_vec())),\n            Mutation::Put((make_key(b\"c\"), b\"cc\".to_vec())),\n            ],\n                            b\"a\".to_vec(),\n                            1,\n                            Options::default(),\n                            expect_fail(tx.clone()))\n            .unwrap();\n        rx.recv().unwrap();\n        storage.stop().unwrap();\n"]]}
{"hexsha": "0ea3f28bf591ffea3729aec61c156bd215a88317", "ext": "rs", "lang": "Rust", "content": "fn destruct_vector_2<T>(vec: Vec<T>) -> (T, T)\nwhere\n    T: Default,\n{\n    let mut a = T::default();\n    let mut b = T::default();\n    for (i, item) in vec.into_iter().enumerate() {\n        match i {\n            0 => a = item,\n            1 => b = item,\n            _ => (),\n        }\n    }\n\n    (a, b)\n}", "item_id": 0, "repo": "lochbrunner/chop-compiler", "file": "core/src/specializer.rs", "last_update_at": "2019-08-21T20:16:01+00:00", "question_id": "0ea3f28bf591ffea3729aec61c156bd215a88317_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn destruct_vector_2<T>(vec: Vec<T>) -> (T, T)\nwhere\n    T: Default,\n{\n    let mut a = T::default();\n    let mut b = T::default();\n    for (i, item) in vec.into_iter().enumerate() {\n        match i {\n            0 => a = item,\n            1 => b = item,\n            _ => (),\n        }\n    }\n    (a, b)\n"]]}
{"hexsha": "1d7255d5eb579d7e77aea14b18a2241ab7db1e66", "ext": "rs", "lang": "Rust", "content": "fn edge_of_unicode_in_utf8() {\n        // U+10FFFF is the highest character in unicode. It is in a private use area.\n        colored::control::set_override(false);\n        let decoding = DecodedString::decode(&[0xF4, 0x8f, 0xBF, 0xBF], UTF_8).unwrap();\n        assert_eq!(decoding.format_bytes(), \"f4 8f bf bf \");\n        assert_eq!(decoding.format_characters(), \"10ffff      \");\n    }", "item_id": 7, "repo": "MatMoore/string-inspector", "file": "src/decoding.rs", "last_update_at": "2019-07-22T11:54:31+00:00", "question_id": "1d7255d5eb579d7e77aea14b18a2241ab7db1e66_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn edge_of_unicode_in_utf8() {\n        // U+10FFFF is the highest character in unicode. It is in a private use area.\n        colored::control::set_override(false);\n        let decoding = DecodedString::decode(&[0xF4, 0x8f, 0xBF, 0xBF], UTF_8).unwrap();\n        assert_eq!(decoding.format_bytes(), \"f4 8f bf bf \");\n        assert_eq!(decoding.format_characters(), \"10ffff      \");\n"]]}
{"hexsha": "ed627a81b771f108689e6b15271a322fd57e21ca", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let args: Vec<String> = ::std::env::args().collect();\n    println!(\"Args: {}\", args.len());\n    if args.len() >= 2 {\n        match &args[1][..] {\n            \"server\" => return server::server::run(args).unwrap(),\n            _ => (),\n        }\n    }\n\n    println!(\"usage: {} [client | server] ADDRESS\", args[0]);\n}", "item_id": 0, "repo": "elniallo/tokio-experiment", "file": "src/main.rs", "last_update_at": "2019-05-24T08:38:11+00:00", "question_id": "ed627a81b771f108689e6b15271a322fd57e21ca_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let args: Vec<String> = ::std::env::args().collect();\n    println!(\"Args: {}\", args.len());\n    if args.len() >= 2 {\n        match &args[1][..] {\n            \"server\" => return server::server::run(args).unwrap(),\n            _ => (),\n        }\n    }\n    println!(\"usage: {} [client | server] ADDRESS\", args[0]);\n"]]}
{"hexsha": "d3a3b6d708be4c157507c35f97cb917d50b278b3", "ext": "rs", "lang": "Rust", "content": "fn upsample_multioutput(&mut self, img: &dyn core::ToInputArray, imgs_new: &mut core::Vector<core::Mat>, scale_factors: &core::Vector<i32>, node_names: &core::Vector<String>) -> Result<()> {\n\t\tinput_array_arg!(img);\n\t\treturn_send!(via ocvrs_return);\n\t\tunsafe { sys::cv_dnn_superres_DnnSuperResImpl_upsampleMultioutput_const__InputArrayR_vector_Mat_R_const_vector_int_R_const_vector_String_R(self.as_raw_mut_DnnSuperResImpl(), img.as_raw__InputArray(), imgs_new.as_raw_mut_VectorOfMat(), scale_factors.as_raw_VectorOfi32(), node_names.as_raw_VectorOfString(), ocvrs_return.as_mut_ptr()) };\n\t\treturn_receive!(unsafe ocvrs_return => ret);\n\t\tlet ret = ret.into_result()?;\n\t\tOk(ret)\n\t}", "item_id": 6, "repo": "thbkrshw/opencv-rust", "file": "src/opencv/hub/dnn_superres.rs", "last_update_at": "2019-03-21T14:39:35+00:00", "question_id": "d3a3b6d708be4c157507c35f97cb917d50b278b3_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn upsample_multioutput(&mut self, img: &dyn core::ToInputArray, imgs_new: &mut core::Vector<core::Mat>, scale_factors: &core::Vector<i32>, node_names: &core::Vector<String>) -> Result<()> {\n\t\tinput_array_arg!(img);\n\t\treturn_send!(via ocvrs_return);\n\t\tunsafe { sys::cv_dnn_superres_DnnSuperResImpl_upsampleMultioutput_const__InputArrayR_vector_Mat_R_const_vector_int_R_const_vector_String_R(self.as_raw_mut_DnnSuperResImpl(), img.as_raw__InputArray(), imgs_new.as_raw_mut_VectorOfMat(), scale_factors.as_raw_VectorOfi32(), node_names.as_raw_VectorOfString(), ocvrs_return.as_mut_ptr()) };\n\t\treturn_receive!(unsafe ocvrs_return => ret);\n\t\tlet ret = ret.into_result()?;\n\t\tOk(ret)\n"]]}
{"hexsha": "e60b73fa0f73d27208b54c78ca955583cf8801f9", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn wlr_input_method_v2_send_done(mut input_method:\n                                                           *mut wlr_input_method_v2) {\n    zwp_input_method_v2_send_done((*input_method).resource);\n    (*input_method).client_active = (*input_method).active;\n    (*input_method).current_serial =\n        (*input_method).current_serial.wrapping_add(1);\n}", "item_id": 8, "repo": "RoastVeg/wlrusts", "file": "src/types/wlr_input_method_v2.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "e60b73fa0f73d27208b54c78ca955583cf8801f9_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn wlr_input_method_v2_send_done(mut input_method:\n                                                           *mut wlr_input_method_v2) {\n    zwp_input_method_v2_send_done((*input_method).resource);\n    (*input_method).client_active = (*input_method).active;\n    (*input_method).current_serial =\n        (*input_method).current_serial.wrapping_add(1);\n"]]}
{"hexsha": "e77b4e98187704a1639d9a1b15181777a2dc337b", "ext": "rs", "lang": "Rust", "content": "fn bit_hl_is_zero() {\n        let mut mem: Memory = Memory::new();\n        let addr = 1;\n        mem.write_byte(addr, 0b10);\n        let mut cpu: CPU = CPU::new(&mut mem);\n        cpu.registers.write_16b(&Register16bits::HL, addr);\n\n        bit_hl(&mut cpu, 2);\n\n        assert_eq!(cpu.registers.read_z_flag(), true);\n        assert_eq!(cpu.registers.read_s_flag(), false);\n        assert_eq!(cpu.registers.read_hc_flag(), true);\n        assert_eq!(cpu.registers.read_c_flag(), false);\n    }", "item_id": 7, "repo": "davidor/gebers", "file": "src/cpu/bit_ops.rs", "last_update_at": "2019-04-08T09:31:04+00:00", "question_id": "e77b4e98187704a1639d9a1b15181777a2dc337b_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bit_hl_is_zero() {\n        let mut mem: Memory = Memory::new();\n        let addr = 1;\n        mem.write_byte(addr, 0b10);\n        let mut cpu: CPU = CPU::new(&mut mem);\n        cpu.registers.write_16b(&Register16bits::HL, addr);\n        bit_hl(&mut cpu, 2);\n        assert_eq!(cpu.registers.read_z_flag(), true);\n        assert_eq!(cpu.registers.read_s_flag(), false);\n        assert_eq!(cpu.registers.read_hc_flag(), true);\n        assert_eq!(cpu.registers.read_c_flag(), false);\n"]]}
{"hexsha": "8f1ad55d2f879a1462289feedaf7c669bf023b74", "ext": "rs", "lang": "Rust", "content": "fn data_integrity_f64_test() {\n        let vec: Vec<Rc<f64>> = vec![1f64, -3.0, 10.02, -23.1, 32e-1]\n            .into_iter()\n            .map(Rc::new)\n            .collect();\n        let buf = VecClone::from(vec.clone()); // Convert into buffer\n        let nu_vec: Vec<Rc<f64>> = buf.clone_into_vec().unwrap(); // Convert back into vec\n        assert_eq!(vec, nu_vec);\n\n        let vec: Vec<Rc<f64>> = vec![1f64, -3.1, 100.2, -2.31, 3.2, 4e2, -1e23]\n            .into_iter()\n            .map(Rc::new)\n            .collect();\n        let buf = VecClone::from(vec.clone()); // Convert into buffer\n        let nu_vec: Vec<Rc<f64>> = buf.clone_into_vec().unwrap(); // Convert back into vec\n        assert_eq!(vec, nu_vec);\n    }", "item_id": 8, "repo": "elrnv/buffer", "file": "src/vec_clone.rs", "last_update_at": "2019-12-22T21:44:15+00:00", "question_id": "8f1ad55d2f879a1462289feedaf7c669bf023b74_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn data_integrity_f64_test() {\n        let vec: Vec<Rc<f64>> = vec![1f64, -3.0, 10.02, -23.1, 32e-1]\n            .into_iter()\n            .map(Rc::new)\n            .collect();\n        let buf = VecClone::from(vec.clone()); // Convert into buffer\n        let nu_vec: Vec<Rc<f64>> = buf.clone_into_vec().unwrap(); // Convert back into vec\n        assert_eq!(vec, nu_vec);\n        let vec: Vec<Rc<f64>> = vec![1f64, -3.1, 100.2, -2.31, 3.2, 4e2, -1e23]\n            .into_iter()\n            .map(Rc::new)\n            .collect();\n        let buf = VecClone::from(vec.clone()); // Convert into buffer\n        let nu_vec: Vec<Rc<f64>> = buf.clone_into_vec().unwrap(); // Convert back into vec\n        assert_eq!(vec, nu_vec);\n"]]}
{"hexsha": "3d55062c5244f88dcd462a368f5ca932bdf94007", "ext": "rs", "lang": "Rust", "content": "fn spec_test_395() {\n    let original = r##\"**foo**bar\n\"##;\n    let expected = r##\"<p><strong>foo</strong>bar</p>\n\"##;\n\n    test_markdown_html(original, expected);\n}", "item_id": 394, "repo": "NaokiM03/pulldown-cmark", "file": "tests/suite/spec.rs", "last_update_at": "2019-07-11T13:20:46+00:00", "question_id": "3d55062c5244f88dcd462a368f5ca932bdf94007_394", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn spec_test_395() {\n    let original = r##\"**foo**bar\n\"##;\n    let expected = r##\"<p><strong>foo</strong>bar</p>\n\"##;\n    test_markdown_html(original, expected);\n"]]}
{"hexsha": "f474ebe4ad94cfcaa9b4192a0257bde388ea136f", "ext": "rs", "lang": "Rust", "content": "fn ego(args: &Vec<String>, cases: &mut BTreeMap<String, Case>) -> Result<i32, TestaError> {\n    if args.iter().any(|x| {x == \"-h\" || x == \"--help\"}) {\n        return Result::Err(TestaError::Help);\n    };\n    match args.len() {\n        2 => {\n            let a = &args[1];\n            if a == \"--show-cases\" {\n                for x in cases.keys() {\n                    println!(\"{}\", x);\n                }\n            } else {\n                match cases.remove(a) {\n                    None => {\n                        return Result::Err(TestaError::ArgsError(\n                            std::fmt::format(format_args!(\"unknown arg: {}\", a))))\n                    },\n                    Some(c) => {\n                        if let Some(msg) = c() {\n                            return Result::Err(TestaError::CaseFail(msg));\n                        }\n                    }\n                }\n            }\n        },\n        _ => {\n            return Result::Err(TestaError::ArgsError(\"want exactly one arg\".to_owned()));\n        }\n    };\n    Ok(0)\n}", "item_id": 1, "repo": "TimeExceed/testa", "file": "rust/testa.rs", "last_update_at": "2019-09-10T23:38:46+00:00", "question_id": "f474ebe4ad94cfcaa9b4192a0257bde388ea136f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn ego(args: &Vec<String>, cases: &mut BTreeMap<String, Case>) -> Result<i32, TestaError> {\n    if args.iter().any(|x| {x == \"-h\" || x == \"--help\"}) {\n        return Result::Err(TestaError::Help);\n    };\n    match args.len() {\n        2 => {\n            let a = &args[1];\n            if a == \"--show-cases\" {\n                for x in cases.keys() {\n                    println!(\"{}\", x);\n                }\n            } else {\n                match cases.remove(a) {\n                    None => {\n                        return Result::Err(TestaError::ArgsError(\n                            std::fmt::format(format_args!(\"unknown arg: {}\", a))))\n                    },\n                    Some(c) => {\n                        if let Some(msg) = c() {\n                            return Result::Err(TestaError::CaseFail(msg));\n                        }\n                    }\n                }\n            }\n        },\n        _ => {\n            return Result::Err(TestaError::ArgsError(\"want exactly one arg\".to_owned()));\n        }\n    };\n    Ok(0)\n"]]}
{"hexsha": "0fa397177e2a1fb9d612b3f22749867c27890f90", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    \n    let mut io = IoHandler::new();\n\n    io.add_method(\"verify_transaction\", |params: Params| {\n        let parsed: Transaction = params.parse().unwrap();\n        let is_self = verify_raw(parsed.defunc_hash(), &parsed.signature, &parsed.sender);\n        Ok(Value::String(format!(\"{}\", is_self)))\n    });\n\n    \n    \n    let server = ServerBuilder::new(io)\n    .start_http(&\"127.0.0.1:3030\".parse().unwrap())\n    .expect(\"Unable to start RPC server\");\n    server.wait();\n}", "item_id": 0, "repo": "decentral-inc/nyc-blockchain-workshop", "file": "Topic1/03_putting_it_all_together/server/src/main.rs", "last_update_at": "2019-04-14T05:36:16+00:00", "question_id": "0fa397177e2a1fb9d612b3f22749867c27890f90_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let mut io = IoHandler::new();\n    io.add_method(\"verify_transaction\", |params: Params| {\n        let parsed: Transaction = params.parse().unwrap();\n        let is_self = verify_raw(parsed.defunc_hash(), &parsed.signature, &parsed.sender);\n        Ok(Value::String(format!(\"{}\", is_self)))\n    });\n    let server = ServerBuilder::new(io)\n    .start_http(&\"127.0.0.1:3030\".parse().unwrap())\n    .expect(\"Unable to start RPC server\");\n    server.wait();\n"]]}
{"hexsha": "ad4654f855115397598b90dbca1e2c0da3950c3e", "ext": "rs", "lang": "Rust", "content": "fn serialize_deserialize_works_for_point_g1() {\n        let structure = TestPointG1Structure {\n            field: PointG1::from_string(\"false 6556E08075C674 EE6E05C6A17E67 20E189DE31926E DD41F2F92026FC 9181F00 BEC671398C0F1 25D98934EA6B2D 9600760C4F9729 51F977993486B1 9BC9712 FFFFFF7D07A8A8 FFFF7888802F07 FFC63D474548B7 F417D05FB10933 95E45DD\").unwrap()\n        };\n\n        let deserialized: TestPointG1Structure = serde_json::from_str(&serde_json::to_string(&structure).unwrap()).unwrap();\n\n        assert_eq!(structure, deserialized);\n    }", "item_id": 8, "repo": "dcmiddle/crypto-lib", "file": "libhl-crypto/src/pair/amcl.rs", "last_update_at": "2019-01-16T06:06:50+00:00", "question_id": "ad4654f855115397598b90dbca1e2c0da3950c3e_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn serialize_deserialize_works_for_point_g1() {\n        let structure = TestPointG1Structure {\n            field: PointG1::from_string(\"false 6556E08075C674 EE6E05C6A17E67 20E189DE31926E DD41F2F92026FC 9181F00 BEC671398C0F1 25D98934EA6B2D 9600760C4F9729 51F977993486B1 9BC9712 FFFFFF7D07A8A8 FFFF7888802F07 FFC63D474548B7 F417D05FB10933 95E45DD\").unwrap()\n        };\n        let deserialized: TestPointG1Structure = serde_json::from_str(&serde_json::to_string(&structure).unwrap()).unwrap();\n        assert_eq!(structure, deserialized);\n"]]}
{"hexsha": "7a0e9db013523aab2c0587d722219ac766744a48", "ext": "rs", "lang": "Rust", "content": "fn test_apply_infix_op_scalar_vector() -> Result<(), YolkError> {\n    let lhs = Value::Scalar(\"a\".parse()?);\n    let rhs = Value::Vector(Vector::from_expanded_ident(\"b\", 3));\n    lhs.apply_infix_op(&InfixOp::Add, &rhs)?;\n    Ok(())\n}", "item_id": 11, "repo": "averycrespi/yolk", "file": "src/transpiler/tests.rs", "last_update_at": "2019-08-17T16:05:19+00:00", "question_id": "7a0e9db013523aab2c0587d722219ac766744a48_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_apply_infix_op_scalar_vector() -> Result<(), YolkError> {\n    let lhs = Value::Scalar(\"a\".parse()?);\n    let rhs = Value::Vector(Vector::from_expanded_ident(\"b\", 3));\n    lhs.apply_infix_op(&InfixOp::Add, &rhs)?;\n    Ok(())\n"]]}
{"hexsha": "df587fdcb935b657c6ea6572e74ce98542967f7f", "ext": "rs", "lang": "Rust", "content": "fn upgrade_entity18(entity: &mut Value, file_name: &str) {\n    let item_action_names = [\"Spawn\", \"Idle\", \"Fall\", \"Held\", \"Thrown\", \"Dropped\"];\n\n    let projectile_action_names = [\"Spawn\", \"Travel\", \"Hit\"];\n\n    let fighter_action_names = [\n        \"Spawn\",\n        \"ReSpawn\",\n        \"ReSpawnIdle\",\n        \"Idle\",\n        \"Crouch\",\n        \"LedgeIdle\",\n        \"Teeter\",\n        \"TeeterIdle\",\n        \"MissedTechIdle\",\n        // Movement\n        \"Fall\",\n        \"AerialFall\",\n        \"Land\",\n        \"JumpSquat\",\n        \"JumpF\",\n        \"JumpB\",\n        \"JumpAerialF\",\n        \"JumpAerialB\",\n        \"TiltTurn\",\n        \"RunTurn\",\n        \"SmashTurn\",\n        \"Dash\",\n        \"Run\",\n        \"RunEnd\",\n        \"Walk\",\n        \"PassPlatform\",\n        \"Damage\",\n        \"DamageFly\",\n        \"DamageFall\",\n        \"LedgeGrab\",\n        \"LedgeJump\",\n        \"LedgeJumpSlow\",\n        \"LedgeGetup\",\n        \"LedgeGetupSlow\",\n        \"LedgeIdleChain\",\n        // Defense\n        \"PowerShield\",\n        \"ShieldOn\",\n        \"Shield\",\n        \"ShieldOff\",\n        \"RollF\",\n        \"RollB\",\n        \"SpotDodge\",\n        \"AerialDodge\",\n        \"SpecialFall\",\n        \"SpecialLand\",\n        \"TechF\",\n        \"TechN\",\n        \"TechB\",\n        \"MissedTechGetupF\",\n        \"MissedTechGetupN\",\n        \"MissedTechGetupB\",\n        \"Rebound\",\n        \"LedgeRoll\",\n        \"LedgeRollSlow\",\n        // Vulnerable\n        \"ShieldBreakFall\",\n        \"ShieldBreakGetup\",\n        \"Stun\",\n        \"MissedTechStart\",\n        // Attack\",\n        \"Jab\",\n        \"Jab2\",\n        \"Jab3\",\n        \"Utilt\",\n        \"Dtilt\",\n        \"Ftilt\",\n        \"DashAttack\",\n        \"Usmash\",\n        \"Dsmash\",\n        \"Fsmash\",\n        // Grabs\n        \"Grab\",\n        \"DashGrab\",\n        \"GrabbingIdle\",\n        \"GrabbingEnd\",\n        \"GrabbedIdleAir\",\n        \"GrabbedIdle\",\n        \"GrabbedEnd\",\n        // Throws\n        \"Uthrow\",\n        \"Dthrow\",\n        \"Fthrow\",\n        \"Bthrow\",\n        // Items\n        \"ItemGrab\",\n        \"ItemEat\",\n        \"ItemThrowU\",\n        \"ItemThrowD\",\n        \"ItemThrowF\",\n        \"ItemThrowB\",\n        \"ItemThrowAirU\",\n        \"ItemThrowAirD\",\n        \"ItemThrowAirF\",\n        \"ItemThrowAirB\",\n        // Getup attacks\n        \"LedgeAttack\",\n        \"LedgeAttackSlow\",\n        \"MissedTechAttack\",\n        // Aerials\n        \"Uair\",\n        \"Dair\",\n        \"Fair\",\n        \"Bair\",\n        \"Nair\",\n        \"UairLand\",\n        \"DairLand\",\n        \"FairLand\",\n        \"BairLand\",\n        \"NairLand\",\n        // Taunts\n        \"TauntUp\",\n        \"TauntDown\",\n        \"TauntLeft\",\n        \"TauntRight\",\n        // Crouch\n        \"CrouchStart\",\n        \"CrouchEnd\",\n        \"Eliminated\",\n        \"DummyFramePreStart\",\n    ];\n\n    let action_names = match file_name {\n        \"PerfectlyGenericProjectile.cbor\" => projectile_action_names.as_ref(),\n        \"PerfectlyGenericObject.cbor\" => item_action_names.as_ref(),\n        \"TorielFireball.cbor\" => projectile_action_names.as_ref(),\n        _ => fighter_action_names.as_ref(),\n    };\n\n    if let Some(actions) = get_vec(entity, \"actions\") {\n        let mut new_actions = BTreeMap::new();\n        new_actions.insert(\n            Value::Text(\"keys\".into()),\n            Value::Array(\n                action_names\n                    .iter()\n                    .map(|x| Value::Text(x.to_string()))\n                    .collect(),\n            ),\n        );\n        new_actions.insert(\n            Value::Text(\"vector\".into()),\n            Value::Array(actions[0..action_names.len()].to_vec()),\n        );\n\n        if let Value::Map(entity) = entity {\n            entity.insert(Value::Text(\"actions\".into()), Value::Map(new_actions));\n        }\n    }\n}", "item_id": 3, "repo": "rukai/game", "file": "package_upgrader/src/main.rs", "last_update_at": "2019-09-18T14:14:21+00:00", "question_id": "df587fdcb935b657c6ea6572e74ce98542967f7f_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn upgrade_entity18(entity: &mut Value, file_name: &str) {\n    let item_action_names = [\"Spawn\", \"Idle\", \"Fall\", \"Held\", \"Thrown\", \"Dropped\"];\n    let projectile_action_names = [\"Spawn\", \"Travel\", \"Hit\"];\n    let fighter_action_names = [\n        \"Spawn\",\n        \"ReSpawn\",\n        \"ReSpawnIdle\",\n        \"Idle\",\n        \"Crouch\",\n        \"LedgeIdle\",\n        \"Teeter\",\n        \"TeeterIdle\",\n        \"MissedTechIdle\",\n        // Movement\n        \"Fall\",\n        \"AerialFall\",\n        \"Land\",\n        \"JumpSquat\",\n        \"JumpF\",\n        \"JumpB\",\n        \"JumpAerialF\",\n        \"JumpAerialB\",\n        \"TiltTurn\",\n        \"RunTurn\",\n        \"SmashTurn\",\n        \"Dash\",\n        \"Run\",\n        \"RunEnd\",\n        \"Walk\",\n        \"PassPlatform\",\n        \"Damage\",\n        \"DamageFly\",\n        \"DamageFall\",\n        \"LedgeGrab\",\n        \"LedgeJump\",\n        \"LedgeJumpSlow\",\n        \"LedgeGetup\",\n        \"LedgeGetupSlow\",\n        \"LedgeIdleChain\",\n        // Defense\n        \"PowerShield\",\n        \"ShieldOn\",\n        \"Shield\",\n        \"ShieldOff\",\n        \"RollF\",\n        \"RollB\",\n        \"SpotDodge\",\n        \"AerialDodge\",\n        \"SpecialFall\",\n        \"SpecialLand\",\n        \"TechF\",\n        \"TechN\",\n        \"TechB\",\n        \"MissedTechGetupF\",\n        \"MissedTechGetupN\",\n        \"MissedTechGetupB\",\n        \"Rebound\",\n        \"LedgeRoll\",\n        \"LedgeRollSlow\",\n        // Vulnerable\n        \"ShieldBreakFall\",\n        \"ShieldBreakGetup\",\n        \"Stun\",\n        \"MissedTechStart\",\n        // Attack\",\n        \"Jab\",\n        \"Jab2\",\n        \"Jab3\",\n        \"Utilt\",\n        \"Dtilt\",\n        \"Ftilt\",\n        \"DashAttack\",\n        \"Usmash\",\n        \"Dsmash\",\n        \"Fsmash\",\n        // Grabs\n        \"Grab\",\n        \"DashGrab\",\n        \"GrabbingIdle\",\n        \"GrabbingEnd\",\n        \"GrabbedIdleAir\",\n        \"GrabbedIdle\",\n        \"GrabbedEnd\",\n        // Throws\n        \"Uthrow\",\n        \"Dthrow\",\n        \"Fthrow\",\n        \"Bthrow\",\n        // Items\n        \"ItemGrab\",\n        \"ItemEat\",\n        \"ItemThrowU\",\n        \"ItemThrowD\",\n        \"ItemThrowF\",\n        \"ItemThrowB\",\n        \"ItemThrowAirU\",\n        \"ItemThrowAirD\",\n        \"ItemThrowAirF\",\n        \"ItemThrowAirB\",\n        // Getup attacks\n        \"LedgeAttack\",\n        \"LedgeAttackSlow\",\n        \"MissedTechAttack\",\n        // Aerials\n        \"Uair\",\n        \"Dair\",\n        \"Fair\",\n        \"Bair\",\n        \"Nair\",\n        \"UairLand\",\n        \"DairLand\",\n        \"FairLand\",\n        \"BairLand\",\n        \"NairLand\",\n        // Taunts\n        \"TauntUp\",\n        \"TauntDown\",\n        \"TauntLeft\",\n        \"TauntRight\",\n        // Crouch\n        \"CrouchStart\",\n        \"CrouchEnd\",\n        \"Eliminated\",\n        \"DummyFramePreStart\",\n    ];\n    let action_names = match file_name {\n        \"PerfectlyGenericProjectile.cbor\" => projectile_action_names.as_ref(),\n        \"PerfectlyGenericObject.cbor\" => item_action_names.as_ref(),\n        \"TorielFireball.cbor\" => projectile_action_names.as_ref(),\n        _ => fighter_action_names.as_ref(),\n    };\n    if let Some(actions) = get_vec(entity, \"actions\") {\n        let mut new_actions = BTreeMap::new();\n        new_actions.insert(\n            Value::Text(\"keys\".into()),\n            Value::Array(\n                action_names\n                    .iter()\n                    .map(|x| Value::Text(x.to_string()))\n                    .collect(),\n            ),\n        );\n        new_actions.insert(\n            Value::Text(\"vector\".into()),\n            Value::Array(actions[0..action_names.len()].to_vec()),\n        );\n        if let Value::Map(entity) = entity {\n            entity.insert(Value::Text(\"actions\".into()), Value::Map(new_actions));\n        }\n    }\n"]]}
{"hexsha": "93c07f610f1c99849ac5975a8746c9b9bf775afe", "ext": "rs", "lang": "Rust", "content": "fn flags_from_vec(args: Vec<String>) -> DenoFlags {\n    let cli_app = create_cli_app();\n    let matches = cli_app.get_matches_from(args);\n    parse_flags(matches)\n  }", "item_id": 1, "repo": "duy-tung/deno", "file": "cli/flags.rs", "last_update_at": "2019-04-23T14:28:48+00:00", "question_id": "93c07f610f1c99849ac5975a8746c9b9bf775afe_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn flags_from_vec(args: Vec<String>) -> DenoFlags {\n    let cli_app = create_cli_app();\n    let matches = cli_app.get_matches_from(args);\n    parse_flags(matches)\n"]]}
{"hexsha": "ecd632c89fd5050b93d64aea0587b471224a2f20", "ext": "rs", "lang": "Rust", "content": "pub fn tokenize(input: &str) -> Vec<Token> {\n    let mut state = TokenizerState::Default;\n    let mut tokens: Vec<Token> = vec![];\n    let mut current_token: String = String::new();\n    for chr in input.chars() {\n        state = match state {\n            TokenizerState::DoubleQuoted => {\n                process_character_double_quoted(&mut tokens, &mut current_token, chr)\n            }\n            TokenizerState::SingleQuoted => {\n                process_character_single_quoted(&mut tokens, &mut current_token, chr)\n            }\n            TokenizerState::Commented => {\n                process_character_comment(&mut tokens, &mut current_token, chr)\n            }\n            _ => process_character_default(&mut tokens, &mut current_token, chr),\n        }\n    }\n    if !current_token.is_empty() {\n        tokens.push(Token::Word(current_token.clone()));\n    }\n    tokens.push(Token::End);\n    tokens\n}", "item_id": 1, "repo": "ticki/ion", "file": "src/tokenizer.rs", "last_update_at": "2019-08-17T17:53:27+00:00", "question_id": "ecd632c89fd5050b93d64aea0587b471224a2f20_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn tokenize(input: &str) -> Vec<Token> {\n    let mut state = TokenizerState::Default;\n    let mut tokens: Vec<Token> = vec![];\n    let mut current_token: String = String::new();\n    for chr in input.chars() {\n        state = match state {\n            TokenizerState::DoubleQuoted => {\n                process_character_double_quoted(&mut tokens, &mut current_token, chr)\n            }\n            TokenizerState::SingleQuoted => {\n                process_character_single_quoted(&mut tokens, &mut current_token, chr)\n            }\n            TokenizerState::Commented => {\n                process_character_comment(&mut tokens, &mut current_token, chr)\n            }\n            _ => process_character_default(&mut tokens, &mut current_token, chr),\n        }\n    }\n    if !current_token.is_empty() {\n        tokens.push(Token::Word(current_token.clone()));\n    }\n    tokens.push(Token::End);\n    tokens\n"]]}
{"hexsha": "26caec3b68200965c1ae496817ad5becc02735bf", "ext": "rs", "lang": "Rust", "content": "fn encrypt_decrypt_lossless() {\n        let mut henon = HenonMap{parameters: HenonMapParametersBuilder::default()\n                .build()\n                .unwrap()};\n        match fs::create_dir_all(\"assets/lossless\") {\n            Ok(f) => f,\n            Err(e) => println!(\"Error: {}.\", e),\n        };\n        henon.transform(&\"assets/lenna.png\".to_string(), &\"assets/lossless/lenna_encrypted.png\".to_string()).unwrap();\n        henon.transform(&\"assets/lossless/lenna_encrypted.png\".to_string(), &\"assets/lossless/lenna_decrypted.png\".to_string()).unwrap();\n        assert_eq!(image_diff(&\"assets/lenna.png\".to_string(), &\"assets/lossless/lenna_decrypted.png\".to_string()), 0 as f64);\n        match fs::remove_dir_all(\"assets/lossless\") {\n            Ok(f) => f,\n            Err(e) => println!(\"Error: {}.\", e),\n        };\n    }", "item_id": 0, "repo": "austin-millan/WAVE-Steganography", "file": "src/chaos_image_encryption/tests/test_henon.rs", "last_update_at": "2019-03-30T21:43:48+00:00", "question_id": "26caec3b68200965c1ae496817ad5becc02735bf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn encrypt_decrypt_lossless() {\n        let mut henon = HenonMap{parameters: HenonMapParametersBuilder::default()\n                .build()\n                .unwrap()};\n        match fs::create_dir_all(\"assets/lossless\") {\n            Ok(f) => f,\n            Err(e) => println!(\"Error: {}.\", e),\n        };\n        henon.transform(&\"assets/lenna.png\".to_string(), &\"assets/lossless/lenna_encrypted.png\".to_string()).unwrap();\n        henon.transform(&\"assets/lossless/lenna_encrypted.png\".to_string(), &\"assets/lossless/lenna_decrypted.png\".to_string()).unwrap();\n        assert_eq!(image_diff(&\"assets/lenna.png\".to_string(), &\"assets/lossless/lenna_decrypted.png\".to_string()), 0 as f64);\n        match fs::remove_dir_all(\"assets/lossless\") {\n            Ok(f) => f,\n            Err(e) => println!(\"Error: {}.\", e),\n        };\n"]]}
{"hexsha": "6732bab6ef6e85f86e1639ba6b2f9d8be63dbb63", "ext": "rs", "lang": "Rust", "content": "pub fn vector_bitand_assign_bool_broadcast() {\n    let mut a = vector![true, true, false, false];\n    let b = true;\n\n    let exp = vector![true, true, false, false];\n\n    a &= &b;\n    assert_eq!(a, exp);\n\n    let mut a = vector![true, true, false, false];\n\n    a &= b;\n    assert_eq!(a, exp);\n}", "item_id": 38, "repo": "mesalock-linux/rulinalg-sgx", "file": "sgx/rulinalg-sgx-test/enclave/src/vector/impl_ops.rs", "last_update_at": "2019-08-22T16:34:34+00:00", "question_id": "6732bab6ef6e85f86e1639ba6b2f9d8be63dbb63_38", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn vector_bitand_assign_bool_broadcast() {\n    let mut a = vector![true, true, false, false];\n    let b = true;\n    let exp = vector![true, true, false, false];\n    a &= &b;\n    assert_eq!(a, exp);\n    let mut a = vector![true, true, false, false];\n    a &= b;\n    assert_eq!(a, exp);\n"]]}
{"hexsha": "7bf6a0cbb2541ae427e37193226a18baebb4fdaf", "ext": "rs", "lang": "Rust", "content": "fn start_by_sending_rpc_to_known_peers() {\n        let random_id = PeerId::random();\n        let target = PeerId::random();\n\n        let mut query = QueryState::new(QueryConfig {\n            target,\n            known_closest_peers: iter::once(random_id.clone()),\n            parallelism: 3,\n            num_results: 100,\n            rpc_timeout: Duration::from_secs(10),\n        });\n\n        tokio::run(futures::future::poll_fn(move || {\n            match try_ready!(Ok(query.poll())) {\n                QueryStatePollOut::SendRpc { peer_id, .. } if peer_id == &random_id => {\n                    Ok(Async::Ready(()))\n                }\n                _ => panic!(),\n            }\n        }));\n    }", "item_id": 0, "repo": "fbaiesec/rust-libp2p", "file": "protocols/kad/src/query.rs", "last_update_at": "2019-05-11T02:05:39+00:00", "question_id": "7bf6a0cbb2541ae427e37193226a18baebb4fdaf_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn start_by_sending_rpc_to_known_peers() {\n        let random_id = PeerId::random();\n        let target = PeerId::random();\n        let mut query = QueryState::new(QueryConfig {\n            target,\n            known_closest_peers: iter::once(random_id.clone()),\n            parallelism: 3,\n            num_results: 100,\n            rpc_timeout: Duration::from_secs(10),\n        });\n        tokio::run(futures::future::poll_fn(move || {\n            match try_ready!(Ok(query.poll())) {\n                QueryStatePollOut::SendRpc { peer_id, .. } if peer_id == &random_id => {\n                    Ok(Async::Ready(()))\n                }\n                _ => panic!(),\n            }\n        }));\n"]]}
{"hexsha": "25153499df4821da586a8505bd3fa879ea84ea20", "ext": "rs", "lang": "Rust", "content": "fn test_push() {\n        let mut heap = Heap::new();\n        heap.push(-2);\n        heap.push(-4);\n        heap.push(-9);\n        assert!(*heap.peek().unwrap() == -9);\n        heap.push(-11);\n        assert!(*heap.peek().unwrap() == -11);\n        heap.push(-5);\n        assert!(*heap.peek().unwrap() == -11);\n        heap.push(-27);\n        assert!(*heap.peek().unwrap() == -27);\n        heap.push(-3);\n        assert!(*heap.peek().unwrap() == -27);\n        heap.push(-103);\n        assert!(*heap.peek().unwrap() == -103);\n    }", "item_id": 5, "repo": "illicitonion/futures-timer", "file": "src/heap.rs", "last_update_at": "2019-02-22T18:15:51+00:00", "question_id": "25153499df4821da586a8505bd3fa879ea84ea20_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_push() {\n        let mut heap = Heap::new();\n        heap.push(-2);\n        heap.push(-4);\n        heap.push(-9);\n        assert!(*heap.peek().unwrap() == -9);\n        heap.push(-11);\n        assert!(*heap.peek().unwrap() == -11);\n        heap.push(-5);\n        assert!(*heap.peek().unwrap() == -11);\n        heap.push(-27);\n        assert!(*heap.peek().unwrap() == -27);\n        heap.push(-3);\n        assert!(*heap.peek().unwrap() == -27);\n        heap.push(-103);\n        assert!(*heap.peek().unwrap() == -103);\n"]]}
{"hexsha": "51f8d22c1d59a1668b8cf2d7106c201e02df9d69", "ext": "rs", "lang": "Rust", "content": "fn size(args: CommandArgs, _registry: &CommandRegistry) -> Result<OutputStream, ShellError> {\n    let input = args.input;\n    let tag = args.call_info.name_tag;\n    Ok(input\n        .values\n        .map(move |v| match v.item {\n            Value::Primitive(Primitive::String(ref s)) => ReturnSuccess::value(count(s, v.tag())),\n            _ => Err(ShellError::labeled_error_with_secondary(\n                \"Expected a string from pipeline\",\n                \"requires string input\",\n                tag,\n                \"value originates from here\",\n                v.tag(),\n            )),\n        })\n        .to_output_stream())\n}", "item_id": 0, "repo": "lehoang123/nushell", "file": "src/commands/size.rs", "last_update_at": "2019-10-01T21:06:39+00:00", "question_id": "51f8d22c1d59a1668b8cf2d7106c201e02df9d69_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn size(args: CommandArgs, _registry: &CommandRegistry) -> Result<OutputStream, ShellError> {\n    let input = args.input;\n    let tag = args.call_info.name_tag;\n    Ok(input\n        .values\n        .map(move |v| match v.item {\n            Value::Primitive(Primitive::String(ref s)) => ReturnSuccess::value(count(s, v.tag())),\n            _ => Err(ShellError::labeled_error_with_secondary(\n                \"Expected a string from pipeline\",\n                \"requires string input\",\n                tag,\n                \"value originates from here\",\n                v.tag(),\n            )),\n        })\n        .to_output_stream())\n"]]}
{"hexsha": "ee307021413d7a66cdee779f8c0a7c58c1e90d1e", "ext": "rs", "lang": "Rust", "content": "fn test_unify_tag() {\n        let tags = \"a,#b\";\n        let tags = Recipe::unify_tags(tags);\n\n        let tag_a = \"#a\".to_string();\n        assert!(tags.contains(&tag_a));\n\n        let tag_b = \"#b\".to_string();\n        assert!(tags.contains(&tag_b));\n    }", "item_id": 2, "repo": "totoMauz/Cooking-Book", "file": "src/cooking_book/recipe.rs", "last_update_at": "2019-04-02T19:01:39+00:00", "question_id": "ee307021413d7a66cdee779f8c0a7c58c1e90d1e_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_unify_tag() {\n        let tags = \"a,#b\";\n        let tags = Recipe::unify_tags(tags);\n        let tag_a = \"#a\".to_string();\n        assert!(tags.contains(&tag_a));\n        let tag_b = \"#b\".to_string();\n        assert!(tags.contains(&tag_b));\n"]]}
{"hexsha": "a4feb9df9e7ec15f97abed630c88e5d9be189159", "ext": "rs", "lang": "Rust", "content": "pub fn run(data: &Data, issue: &Issue, args: RunArgs) -> Result<()> {\n    let name = get_name(&data.db, issue, args.name)?;\n\n    if data.experiments.exists(&name)? {\n        bail!(\"an experiment named **`{}`** already exists!\", name);\n    }\n\n    data.experiments.create(\n        &name,\n        &args.start.ok_or_else(|| \"missing start toolchain\")?,\n        &args.end.ok_or_else(|| \"missing end toolchain\")?,\n        args.mode.unwrap_or(ExMode::BuildAndTest),\n        args.crates.unwrap_or(ExCrateSelect::Full),\n        args.cap_lints.unwrap_or(ExCapLints::Forbid),\n        &data.config,\n        Some(&issue.url),\n        Some(&issue.html_url),\n        Some(issue.number),\n        args.priority.unwrap_or(0),\n    )?;\n\n    Message::new()\n        .line(\n            \"ok_hand\",\n            format!(\"Experiment **`{}`** created and queued.\", name),\n        )\n        .set_label(Label::ExperimentQueued)\n        .send(&issue.url, data)?;\n\n    Ok(())\n}", "item_id": 0, "repo": "pietroalbini/crater", "file": "src/server/routes/webhooks/commands.rs", "last_update_at": "2019-08-21T21:21:44+00:00", "question_id": "a4feb9df9e7ec15f97abed630c88e5d9be189159_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn run(data: &Data, issue: &Issue, args: RunArgs) -> Result<()> {\n    let name = get_name(&data.db, issue, args.name)?;\n    if data.experiments.exists(&name)? {\n        bail!(\"an experiment named **`{}`** already exists!\", name);\n    }\n    data.experiments.create(\n        &name,\n        &args.start.ok_or_else(|| \"missing start toolchain\")?,\n        &args.end.ok_or_else(|| \"missing end toolchain\")?,\n        args.mode.unwrap_or(ExMode::BuildAndTest),\n        args.crates.unwrap_or(ExCrateSelect::Full),\n        args.cap_lints.unwrap_or(ExCapLints::Forbid),\n        &data.config,\n        Some(&issue.url),\n        Some(&issue.html_url),\n        Some(issue.number),\n        args.priority.unwrap_or(0),\n    )?;\n    Message::new()\n        .line(\n            \"ok_hand\",\n            format!(\"Experiment **`{}`** created and queued.\", name),\n        )\n        .set_label(Label::ExperimentQueued)\n        .send(&issue.url, data)?;\n    Ok(())\n"]]}
{"hexsha": "b4dd3973523698a0f050c7f709a7bd07349d8f78", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn mi_heap_malloc(mut heap: *mut mi_heap_t,\n                                        mut size: usize) -> *mut c_void {\n    if !heap.is_null() {\n        0\n    } else {\n        _mi_assert_fail(\"heap!=NULL\", \"src/alloc.c\", 66, \"mi_heap_malloc\")\n    } // heaps are thread local\n    if heap.thread_id == 0 || heap.thread_id == _mi_thread_id() {\n        0\n    } else {\n        _mi_assert_fail(\"heap->thread_id == 0 || heap->thread_id == _mi_thread_id()\",\n                        \"src/alloc.c\", 67, \"mi_heap_malloc\")\n    } // overestimate for aligned sizes\n    let mut p: *mut c_void;\n    if __builtin_expect((size <= MI_SMALL_SIZE_MAX), 1) != 0 {\n        p = mi_heap_malloc_small(heap, size);\n    } else { p = _mi_malloc_generic(heap, size); }\n    if !p.is_null() {\n        if !mi_heap_is_initialized(heap) { heap = mi_get_default_heap(); }\n        _mi_stat_increase(&mut ((heap).tld.stats.malloc), mi_good_size(size));\n    }\n    return p;\n}", "item_id": 3, "repo": "rusch95/mimalloc-rs", "file": "mimalloc-sys/rust_impl/citrus/alloc.rs", "last_update_at": "2019-10-20T05:44:39+00:00", "question_id": "b4dd3973523698a0f050c7f709a7bd07349d8f78_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn mi_heap_malloc(mut heap: *mut mi_heap_t,\n                                        mut size: usize) -> *mut c_void {\n    if !heap.is_null() {\n        0\n    } else {\n        _mi_assert_fail(\"heap!=NULL\", \"src/alloc.c\", 66, \"mi_heap_malloc\")\n    } // heaps are thread local\n    if heap.thread_id == 0 || heap.thread_id == _mi_thread_id() {\n        0\n    } else {\n        _mi_assert_fail(\"heap->thread_id == 0 || heap->thread_id == _mi_thread_id()\",\n                        \"src/alloc.c\", 67, \"mi_heap_malloc\")\n    } // overestimate for aligned sizes\n    let mut p: *mut c_void;\n    if __builtin_expect((size <= MI_SMALL_SIZE_MAX), 1) != 0 {\n        p = mi_heap_malloc_small(heap, size);\n    } else { p = _mi_malloc_generic(heap, size); }\n    if !p.is_null() {\n        if !mi_heap_is_initialized(heap) { heap = mi_get_default_heap(); }\n        _mi_stat_increase(&mut ((heap).tld.stats.malloc), mi_good_size(size));\n    }\n    return p;\n"]]}
{"hexsha": "ebe2142122059ad0ed019626e7520ad3ad7a8aa0", "ext": "rs", "lang": "Rust", "content": "fn test_version_spec_1() {\n        let v1 = VersionSpec::try_from(\"1.7.1\").unwrap();\n        let v2 = VersionSpec::try_from(\"1.7.1*\").unwrap();\n        let v3 = VersionSpec::try_from(\"1.7.1\").unwrap();\n        assert!(v1.is_exact());\n        assert_ne!(v2.is_exact(), true);\n        assert!(v3.is_exact());\n        // right now, VersionSpec instance are not orderable nor equal by value. Versions are, though.\n        // assert_eq!(v1, v3);\n        // assert_ne!(v1, v2);\n        // assert_ne!(v3, v2);\n        // assert_ne!(v1, 1.0);\n        // pointer tests here are testing caching - are equal values created as just one object?\n        // https://users.rust-lang.org/t/is-any-way-to-know-references-are-referencing-the-same-object/9716/6\n        assert_eq!(&v1 as *const _, &v3 as *const _);\n        assert_ne!(&v1 as *const _, &v2 as *const _);\n    }", "item_id": 9, "repo": "msarahan/libronda", "file": "core/src/version/spec_trees.rs", "last_update_at": "2019-10-15T14:12:12+00:00", "question_id": "ebe2142122059ad0ed019626e7520ad3ad7a8aa0_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_version_spec_1() {\n        let v1 = VersionSpec::try_from(\"1.7.1\").unwrap();\n        let v2 = VersionSpec::try_from(\"1.7.1*\").unwrap();\n        let v3 = VersionSpec::try_from(\"1.7.1\").unwrap();\n        assert!(v1.is_exact());\n        assert_ne!(v2.is_exact(), true);\n        assert!(v3.is_exact());\n        // right now, VersionSpec instance are not orderable nor equal by value. Versions are, though.\n        // assert_eq!(v1, v3);\n        // assert_ne!(v1, v2);\n        // assert_ne!(v3, v2);\n        // assert_ne!(v1, 1.0);\n        // pointer tests here are testing caching - are equal values created as just one object?\n        // https://users.rust-lang.org/t/is-any-way-to-know-references-are-referencing-the-same-object/9716/6\n        assert_eq!(&v1 as *const _, &v3 as *const _);\n        assert_ne!(&v1 as *const _, &v2 as *const _);\n"]]}
{"hexsha": "8c7a2e373f5af33d321be5c1639cda1a637927f5", "ext": "rs", "lang": "Rust", "content": "async fn apply_a_base_delta() {\n        let store = open_memory_store();\n        let builder = store.create_base_layer().await.unwrap();\n\n        builder\n            .add_string_triple(StringTriple::new_value(\"cow\", \"says\", \"moo\"))\n            .unwrap();\n\n        let layer = builder.commit().await.unwrap();\n\n        let builder2 = layer.open_write().await.unwrap();\n\n        builder2\n            .add_string_triple(StringTriple::new_value(\"dog\", \"says\", \"woof\"))\n            .unwrap();\n\n        let layer2 = builder2.commit().await.unwrap();\n\n        let delta_builder_1 = store.create_base_layer().await.unwrap();\n\n        delta_builder_1\n            .add_string_triple(StringTriple::new_value(\"dog\", \"says\", \"woof\"))\n            .unwrap();\n        delta_builder_1\n            .add_string_triple(StringTriple::new_value(\"cat\", \"says\", \"meow\"))\n            .unwrap();\n\n        let delta_1 = delta_builder_1.commit().await.unwrap();\n\n        let delta_builder_2 = delta_1.open_write().await.unwrap();\n\n        delta_builder_2\n            .add_string_triple(StringTriple::new_value(\"crow\", \"says\", \"caw\"))\n            .unwrap();\n        delta_builder_2\n            .remove_string_triple(StringTriple::new_value(\"cat\", \"says\", \"meow\"))\n            .unwrap();\n\n        let delta = delta_builder_2.commit().await.unwrap();\n\n        let rebase_builder = layer2.open_write().await.unwrap();\n\n        let _ = rebase_builder.apply_delta(&delta).await.unwrap();\n\n        let rebase_layer = rebase_builder.commit().await.unwrap();\n\n        assert!(rebase_layer.string_triple_exists(&StringTriple::new_value(\"cow\", \"says\", \"moo\")));\n        assert!(rebase_layer.string_triple_exists(&StringTriple::new_value(\"crow\", \"says\", \"caw\")));\n        assert!(rebase_layer.string_triple_exists(&StringTriple::new_value(\"dog\", \"says\", \"woof\")));\n        assert!(!rebase_layer.string_triple_exists(&StringTriple::new_value(\"cat\", \"says\", \"meow\")));\n    }", "item_id": 6, "repo": "regulumdb/ferricstore", "file": "src/store/mod.rs", "last_update_at": "2019-07-27T11:57:30+00:00", "question_id": "8c7a2e373f5af33d321be5c1639cda1a637927f5_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn apply_a_base_delta() {\n        let store = open_memory_store();\n        let builder = store.create_base_layer().await.unwrap();\n        builder\n            .add_string_triple(StringTriple::new_value(\"cow\", \"says\", \"moo\"))\n            .unwrap();\n        let layer = builder.commit().await.unwrap();\n        let builder2 = layer.open_write().await.unwrap();\n        builder2\n            .add_string_triple(StringTriple::new_value(\"dog\", \"says\", \"woof\"))\n            .unwrap();\n        let layer2 = builder2.commit().await.unwrap();\n        let delta_builder_1 = store.create_base_layer().await.unwrap();\n        delta_builder_1\n            .add_string_triple(StringTriple::new_value(\"dog\", \"says\", \"woof\"))\n            .unwrap();\n        delta_builder_1\n            .add_string_triple(StringTriple::new_value(\"cat\", \"says\", \"meow\"))\n            .unwrap();\n        let delta_1 = delta_builder_1.commit().await.unwrap();\n        let delta_builder_2 = delta_1.open_write().await.unwrap();\n        delta_builder_2\n            .add_string_triple(StringTriple::new_value(\"crow\", \"says\", \"caw\"))\n            .unwrap();\n        delta_builder_2\n            .remove_string_triple(StringTriple::new_value(\"cat\", \"says\", \"meow\"))\n            .unwrap();\n        let delta = delta_builder_2.commit().await.unwrap();\n        let rebase_builder = layer2.open_write().await.unwrap();\n        let _ = rebase_builder.apply_delta(&delta).await.unwrap();\n        let rebase_layer = rebase_builder.commit().await.unwrap();\n        assert!(rebase_layer.string_triple_exists(&StringTriple::new_value(\"cow\", \"says\", \"moo\")));\n        assert!(rebase_layer.string_triple_exists(&StringTriple::new_value(\"crow\", \"says\", \"caw\")));\n        assert!(rebase_layer.string_triple_exists(&StringTriple::new_value(\"dog\", \"says\", \"woof\")));\n        assert!(!rebase_layer.string_triple_exists(&StringTriple::new_value(\"cat\", \"says\", \"meow\")));\n"]]}
{"hexsha": "8628c4805e8c53308825a02fc09c4a329058da0b", "ext": "rs", "lang": "Rust", "content": "async fn test_metadata() {\n    let _r = env_logger::try_init();\n\n    let topic_name = rand_test_topic();\n    populate_topic(&topic_name, 1, &value_fn, &key_fn, Some(0), None).await;\n    populate_topic(&topic_name, 1, &value_fn, &key_fn, Some(1), None).await;\n    populate_topic(&topic_name, 1, &value_fn, &key_fn, Some(2), None).await;\n    let consumer = create_consumer(&rand_test_group());\n\n    let metadata = consumer\n        .fetch_metadata(None, Duration::from_secs(5))\n        .unwrap();\n    let orig_broker_id = metadata.orig_broker_id();\n    // The orig_broker_id may be -1 if librdkafka's bootstrap \"broker\" handles\n    // the request.\n    if orig_broker_id != -1 && orig_broker_id != 0 {\n        panic!(\n            \"metadata.orig_broker_id = {}, not 0 or 1 as expected\",\n            orig_broker_id\n        )\n    }\n    assert!(!metadata.orig_broker_name().is_empty());\n\n    let broker_metadata = metadata.brokers();\n    assert_eq!(broker_metadata.len(), 1);\n    assert_eq!(broker_metadata[0].id(), 0);\n    assert!(!broker_metadata[0].host().is_empty());\n    assert_eq!(broker_metadata[0].port(), 9092);\n\n    let topic_metadata = metadata\n        .topics()\n        .iter()\n        .find(|m| m.name() == topic_name)\n        .unwrap();\n\n    let mut ids = topic_metadata\n        .partitions()\n        .iter()\n        .map(|p| {\n            assert_eq!(p.error(), None);\n            p.id()\n        })\n        .collect::<Vec<_>>();\n    ids.sort();\n\n    assert_eq!(ids, vec![0, 1, 2]);\n    assert_eq!(topic_metadata.error(), None);\n    assert_eq!(topic_metadata.partitions().len(), 3);\n    assert_eq!(topic_metadata.partitions()[0].leader(), 0);\n    assert_eq!(topic_metadata.partitions()[1].leader(), 0);\n    assert_eq!(topic_metadata.partitions()[2].leader(), 0);\n    assert_eq!(topic_metadata.partitions()[0].replicas(), &[0]);\n    assert_eq!(topic_metadata.partitions()[0].isr(), &[0]);\n\n    let metadata_one_topic = consumer\n        .fetch_metadata(Some(&topic_name), Duration::from_secs(5))\n        .unwrap();\n    assert_eq!(metadata_one_topic.topics().len(), 1);\n}", "item_id": 0, "repo": "kosta/rust-rdkafka", "file": "tests/test_metadata.rs", "last_update_at": "2019-12-01T20:28:58+00:00", "question_id": "8628c4805e8c53308825a02fc09c4a329058da0b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_metadata() {\n    let _r = env_logger::try_init();\n    let topic_name = rand_test_topic();\n    populate_topic(&topic_name, 1, &value_fn, &key_fn, Some(0), None).await;\n    populate_topic(&topic_name, 1, &value_fn, &key_fn, Some(1), None).await;\n    populate_topic(&topic_name, 1, &value_fn, &key_fn, Some(2), None).await;\n    let consumer = create_consumer(&rand_test_group());\n    let metadata = consumer\n        .fetch_metadata(None, Duration::from_secs(5))\n        .unwrap();\n    let orig_broker_id = metadata.orig_broker_id();\n    // The orig_broker_id may be -1 if librdkafka's bootstrap \"broker\" handles\n    // the request.\n    if orig_broker_id != -1 && orig_broker_id != 0 {\n        panic!(\n            \"metadata.orig_broker_id = {}, not 0 or 1 as expected\",\n            orig_broker_id\n        )\n    }\n    assert!(!metadata.orig_broker_name().is_empty());\n    let broker_metadata = metadata.brokers();\n    assert_eq!(broker_metadata.len(), 1);\n    assert_eq!(broker_metadata[0].id(), 0);\n    assert!(!broker_metadata[0].host().is_empty());\n    assert_eq!(broker_metadata[0].port(), 9092);\n    let topic_metadata = metadata\n        .topics()\n        .iter()\n        .find(|m| m.name() == topic_name)\n        .unwrap();\n    let mut ids = topic_metadata\n        .partitions()\n        .iter()\n        .map(|p| {\n            assert_eq!(p.error(), None);\n            p.id()\n        })\n        .collect::<Vec<_>>();\n    ids.sort();\n    assert_eq!(ids, vec![0, 1, 2]);\n    assert_eq!(topic_metadata.error(), None);\n    assert_eq!(topic_metadata.partitions().len(), 3);\n    assert_eq!(topic_metadata.partitions()[0].leader(), 0);\n    assert_eq!(topic_metadata.partitions()[1].leader(), 0);\n    assert_eq!(topic_metadata.partitions()[2].leader(), 0);\n    assert_eq!(topic_metadata.partitions()[0].replicas(), &[0]);\n    assert_eq!(topic_metadata.partitions()[0].isr(), &[0]);\n    let metadata_one_topic = consumer\n        .fetch_metadata(Some(&topic_name), Duration::from_secs(5))\n        .unwrap();\n    assert_eq!(metadata_one_topic.topics().len(), 1);\n"]]}
{"hexsha": "8c5b3fdbbe30d409022c932d316af6f8511066c9", "ext": "rs", "lang": "Rust", "content": "fn check_withdraw_unbonded_stake_transaction() {\n        let name = \"name\";\n        let passphrase = &SecUtf8::from(\"passphrase\");\n\n        let storage = MemoryStorage::default();\n        let signer_manager = WalletSignerManager::new(storage.clone());\n\n        let fee_algorithm = UnitFeeAlgorithm::default();\n\n        let wallet_client = DefaultWalletClient::new_read_only(storage.clone());\n\n        let tendermint_client = MockClient::default();\n        let network_ops_client = DefaultNetworkOpsClient::new(\n            wallet_client,\n            signer_manager,\n            tendermint_client,\n            fee_algorithm,\n            MockTransactionCipher,\n        );\n\n        network_ops_client\n            .get_wallet_client()\n            .new_wallet(name, passphrase, WalletKind::Basic)\n            .unwrap();\n\n        let from_address = network_ops_client\n            .get_wallet_client()\n            .new_staking_address(name, passphrase)\n            .unwrap();\n\n        let transaction = network_ops_client\n            .create_withdraw_unbonded_stake_transaction(\n                name,\n                passphrase,\n                &from_address,\n                vec![TxOut::new(ExtendedAddr::OrTree([0; 32]), Coin::unit())],\n                TxAttributes::new(171),\n            )\n            .unwrap();\n\n        match transaction {\n            TxAux::EnclaveTx(TxEnclaveAux::WithdrawUnbondedStakeTx {\n                payload: TxObfuscated { txid, .. },\n                witness,\n                ..\n            }) => {\n                let account_address = verify_tx_recover_address(&witness, &txid)\n                    .expect(\"Unable to verify transaction\");\n\n                assert_eq!(account_address, from_address)\n            }\n            _ => unreachable!(\n                \"`create_withdraw_unbonded_stake_transaction()` created invalid transaction type\"\n            ),\n        }\n    }", "item_id": 2, "repo": "leejw51/mychain", "file": "client-network/src/network_ops/default_network_ops_client.rs", "last_update_at": "2019-11-26T13:30:11+00:00", "question_id": "8c5b3fdbbe30d409022c932d316af6f8511066c9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn check_withdraw_unbonded_stake_transaction() {\n        let name = \"name\";\n        let passphrase = &SecUtf8::from(\"passphrase\");\n        let storage = MemoryStorage::default();\n        let signer_manager = WalletSignerManager::new(storage.clone());\n        let fee_algorithm = UnitFeeAlgorithm::default();\n        let wallet_client = DefaultWalletClient::new_read_only(storage.clone());\n        let tendermint_client = MockClient::default();\n        let network_ops_client = DefaultNetworkOpsClient::new(\n            wallet_client,\n            signer_manager,\n            tendermint_client,\n            fee_algorithm,\n            MockTransactionCipher,\n        );\n        network_ops_client\n            .get_wallet_client()\n            .new_wallet(name, passphrase, WalletKind::Basic)\n            .unwrap();\n        let from_address = network_ops_client\n            .get_wallet_client()\n            .new_staking_address(name, passphrase)\n            .unwrap();\n        let transaction = network_ops_client\n            .create_withdraw_unbonded_stake_transaction(\n                name,\n                passphrase,\n                &from_address,\n                vec![TxOut::new(ExtendedAddr::OrTree([0; 32]), Coin::unit())],\n                TxAttributes::new(171),\n            )\n            .unwrap();\n        match transaction {\n            TxAux::EnclaveTx(TxEnclaveAux::WithdrawUnbondedStakeTx {\n                payload: TxObfuscated { txid, .. },\n                witness,\n                ..\n            }) => {\n                let account_address = verify_tx_recover_address(&witness, &txid)\n                    .expect(\"Unable to verify transaction\");\n                assert_eq!(account_address, from_address)\n            }\n            _ => unreachable!(\n                \"`create_withdraw_unbonded_stake_transaction()` created invalid transaction type\"\n            ),\n        }\n"]]}
{"hexsha": "300fab5baeffe749309470c739d4cf6d822f7522", "ext": "rs", "lang": "Rust", "content": "pub fn do_report(settings: Settings) -> impl Future<Item = (), Error = Error> + Send {\n    info!(\"Beginning report run\");\n\n    let report = Arc::new(Mutex::new(Report::new(format!(\"{}\", settings.build_id()))));\n    let timestamp = Utc::now().timestamp();\n\n    // collect docker logs from all running containers\n    let add_log_files = {\n        let report = report.clone();\n        let report_copy = report.clone();\n        let settings_copy = settings.clone();\n        get_module_logs(&settings)\n            .and_then(move |module_logs| {\n                info!(\"Fetched module logs.\");\n\n                // add each log as a file into the report\n                for (container_name, logs) in module_logs {\n                    report\n                        .lock()\n                        .unwrap()\n                        .add_file(&format!(\"./{}.log\", container_name), logs.as_bytes());\n                }\n\n                // write all the files in the report into blob storage\n                info!(\"Compressing module logs\");\n                let buffer = Vec::new();\n                let report = report.lock().unwrap();\n                report.write_files(buffer.writer()).into_future()\n            })\n            .and_then(move |writer| {\n                info!(\"Uploading module logs to blob storage\");\n                let buffer = writer.into_inner();\n                let report_copy = report_copy.lock().unwrap();\n                upload_file(\n                    report_copy.id(),\n                    &settings_copy,\n                    &format!(\"{}/{}\", timestamp, LOGS_FILE_NAME),\n                    &buffer,\n                )\n            })\n            .map(|_| info!(\"Module logs uploaded to blob storage\"))\n    };\n\n    // collect report from analyzer module\n    let get_analysis = {\n        let report = report.clone();\n        fetch_message_analysis(&settings).map(move |analysis| {\n            info!(\"Got message analysis from analyzer\");\n\n            if let Some(analysis) = analysis {\n                report.lock().unwrap().set_message_analysis(analysis);\n            }\n        })\n    };\n\n    // wait for all the bits to get done and then build report and alert\n    let all_futures: Vec<Box<Future<Item = (), Error = Error> + Send>> =\n        vec![Box::new(add_log_files), Box::new(get_analysis)];\n    let report_copy = report.clone();\n    future::join_all(all_futures)\n        .and_then(move |_| {\n            info!(\"Preparing report\");\n            let report = &mut *report_copy.lock().unwrap();\n            debug!(\n                \"alert url: {:?}, report: {:?}\",\n                &settings.alert().url(),\n                report\n            );\n            let report_id = report.id().to_string();\n            report.add_attachment(\n                LOGS_FILE_NAME,\n                &format!(\n                    \"https://{}.blob.core.windows.net/{}/{}/{}\",\n                    settings.blob_storage_account(),\n                    report_id,\n                    timestamp,\n                    LOGS_FILE_NAME\n                ),\n            );\n            report.add_notes(format!(\n                \"Test report generated at: {}\",\n                Utc::now().to_rfc3339()\n            ));\n\n            info!(\"Serialize report to json\");\n            serde_json::to_value(report)\n                .map_err(Error::from)\n                .map(|report_json| Either::A(raise_alert(&settings, report_json)))\n                .unwrap_or_else(|err| Either::B(future::err(err)))\n        })\n        .map(|_| info!(\"Report run complete\"))\n}", "item_id": 1, "repo": "kkdawkins/iotedge", "file": "tools/snitch/snitcher/src/lib.rs", "last_update_at": "2019-10-03T13:36:14+00:00", "question_id": "300fab5baeffe749309470c739d4cf6d822f7522_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn do_report(settings: Settings) -> impl Future<Item = (), Error = Error> + Send {\n    info!(\"Beginning report run\");\n    let report = Arc::new(Mutex::new(Report::new(format!(\"{}\", settings.build_id()))));\n    let timestamp = Utc::now().timestamp();\n    // collect docker logs from all running containers\n    let add_log_files = {\n        let report = report.clone();\n        let report_copy = report.clone();\n        let settings_copy = settings.clone();\n        get_module_logs(&settings)\n            .and_then(move |module_logs| {\n                info!(\"Fetched module logs.\");\n                // add each log as a file into the report\n                for (container_name, logs) in module_logs {\n                    report\n                        .lock()\n                        .unwrap()\n                        .add_file(&format!(\"./{}.log\", container_name), logs.as_bytes());\n                }\n                // write all the files in the report into blob storage\n                info!(\"Compressing module logs\");\n                let buffer = Vec::new();\n                let report = report.lock().unwrap();\n                report.write_files(buffer.writer()).into_future()\n            })\n            .and_then(move |writer| {\n                info!(\"Uploading module logs to blob storage\");\n                let buffer = writer.into_inner();\n                let report_copy = report_copy.lock().unwrap();\n                upload_file(\n                    report_copy.id(),\n                    &settings_copy,\n                    &format!(\"{}/{}\", timestamp, LOGS_FILE_NAME),\n                    &buffer,\n                )\n            })\n            .map(|_| info!(\"Module logs uploaded to blob storage\"))\n    };\n    // collect report from analyzer module\n    let get_analysis = {\n        let report = report.clone();\n        fetch_message_analysis(&settings).map(move |analysis| {\n            info!(\"Got message analysis from analyzer\");\n            if let Some(analysis) = analysis {\n                report.lock().unwrap().set_message_analysis(analysis);\n            }\n        })\n    };\n    // wait for all the bits to get done and then build report and alert\n    let all_futures: Vec<Box<Future<Item = (), Error = Error> + Send>> =\n        vec![Box::new(add_log_files), Box::new(get_analysis)];\n    let report_copy = report.clone();\n    future::join_all(all_futures)\n        .and_then(move |_| {\n            info!(\"Preparing report\");\n            let report = &mut *report_copy.lock().unwrap();\n            debug!(\n                \"alert url: {:?}, report: {:?}\",\n                &settings.alert().url(),\n                report\n            );\n            let report_id = report.id().to_string();\n            report.add_attachment(\n                LOGS_FILE_NAME,\n                &format!(\n                    \"https://{}.blob.core.windows.net/{}/{}/{}\",\n                    settings.blob_storage_account(),\n                    report_id,\n                    timestamp,\n                    LOGS_FILE_NAME\n                ),\n            );\n            report.add_notes(format!(\n                \"Test report generated at: {}\",\n                Utc::now().to_rfc3339()\n            ));\n            info!(\"Serialize report to json\");\n            serde_json::to_value(report)\n                .map_err(Error::from)\n                .map(|report_json| Either::A(raise_alert(&settings, report_json)))\n                .unwrap_or_else(|err| Either::B(future::err(err)))\n        })\n        .map(|_| info!(\"Report run complete\"))\n"]]}
{"hexsha": "b61fc7149166a71ee05df261c035f637aa80ac79", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn wlr_xdg_surface_from_resource(mut resource:\n                                                           *mut wl_resource)\n -> *mut wlr_xdg_surface {\n    // TODO: Double check that all of the callers can deal with NULL\n    if resource.is_null() { return 0 as *mut wlr_xdg_surface }\n    if wl_resource_instance_of(resource, &xdg_surface_interface,\n                               &xdg_surface_implementation as\n                                   *const xdg_surface_interface as\n                                   *const libc::c_void) != 0 {\n    } else {\n        __assert_fail(b\"wl_resource_instance_of(resource, &xdg_surface_interface, &xdg_surface_implementation)\\x00\"\n                          as *const u8 as *const libc::c_char,\n                      b\"../types/xdg_shell/wlr_xdg_surface.c\\x00\" as *const u8\n                          as *const libc::c_char, 510i32 as libc::c_uint,\n                      (*::std::mem::transmute::<&[u8; 76],\n                                                &[libc::c_char; 76]>(b\"struct wlr_xdg_surface *wlr_xdg_surface_from_resource(struct wl_resource *)\\x00\")).as_ptr());\n    };\n    return wl_resource_get_user_data(resource) as *mut wlr_xdg_surface;\n}", "item_id": 17, "repo": "RoastVeg/wlrusts", "file": "src/types/xdg_shell/wlr_xdg_surface.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "b61fc7149166a71ee05df261c035f637aa80ac79_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn wlr_xdg_surface_from_resource(mut resource:\n                                                           *mut wl_resource)\n -> *mut wlr_xdg_surface {\n    // TODO: Double check that all of the callers can deal with NULL\n    if resource.is_null() { return 0 as *mut wlr_xdg_surface }\n    if wl_resource_instance_of(resource, &xdg_surface_interface,\n                               &xdg_surface_implementation as\n                                   *const xdg_surface_interface as\n                                   *const libc::c_void) != 0 {\n    } else {\n        __assert_fail(b\"wl_resource_instance_of(resource, &xdg_surface_interface, &xdg_surface_implementation)\\x00\"\n                          as *const u8 as *const libc::c_char,\n                      b\"../types/xdg_shell/wlr_xdg_surface.c\\x00\" as *const u8\n                          as *const libc::c_char, 510i32 as libc::c_uint,\n                      (*::std::mem::transmute::<&[u8; 76],\n                                                &[libc::c_char; 76]>(b\"struct wlr_xdg_surface *wlr_xdg_surface_from_resource(struct wl_resource *)\\x00\")).as_ptr());\n    };\n    return wl_resource_get_user_data(resource) as *mut wlr_xdg_surface;\n"]]}
{"hexsha": "b53fa495947627f8fe136b0812c1f9507e751d06", "ext": "rs", "lang": "Rust", "content": "fn parse_output(src: &OsStr) -> Result<Output, OsString> {\n    let mut chunks = src.as_bytes().splitn(2, |&b| b == b':');\n    let ports = String::from_utf8(chunks.next().unwrap().to_vec())\n        .map_err(Into::into)\n        .and_then(|ports| parse_ports(ports.as_str()))\n        .map_err(|err| err.to_string())?;\n    let path = chunks.next().map(|path| OsStr::from_bytes(path).into());\n    Ok(Output { ports, path })\n}", "item_id": 1, "repo": "drone-os/itmsink", "file": "src/cli.rs", "last_update_at": "2019-09-26T13:56:14+00:00", "question_id": "b53fa495947627f8fe136b0812c1f9507e751d06_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_output(src: &OsStr) -> Result<Output, OsString> {\n    let mut chunks = src.as_bytes().splitn(2, |&b| b == b':');\n    let ports = String::from_utf8(chunks.next().unwrap().to_vec())\n        .map_err(Into::into)\n        .and_then(|ports| parse_ports(ports.as_str()))\n        .map_err(|err| err.to_string())?;\n    let path = chunks.next().map(|path| OsStr::from_bytes(path).into());\n    Ok(Output { ports, path })\n"]]}
{"hexsha": "148a32529711b4917d13f4af8a1c511d85d510a4", "ext": "rs", "lang": "Rust", "content": "fn make_weight_accessors(weights: &FSkinWeightVertexBuffer, buffer: &mut Vec<u8>, mesh_data: &mut GLTFItem, section: &FSkelMeshRenderSection, off: usize) \n    -> ParserResult<(Rc<RefCell<GLTFAccessor>>, Rc<RefCell<GLTFAccessor>>)> {\n    let joint_buffer_view = mesh_data.add_buffer_view({\n        let startpos = buffer.len();\n        let length = write_joints_buffer(weights, buffer, section, off)?;\n        GLTFBufferView::new(startpos as u32, length)\n    });\n    let joint_accessor = mesh_data.add_accessor(GLTFAccessor::new(\n        joint_buffer_view,\n        GLTFComponentType::UnsignedShort, section.get_num_verts() as u32,\n        \"VEC4\", GLTFAccessorValue::None, GLTFAccessorValue::None\n    ));\n\n    let weight_buffer_view = mesh_data.add_buffer_view({\n        let startpos = buffer.len();\n        let length = write_weights_buffer(weights, buffer, section, off)?;\n        GLTFBufferView::new(startpos as u32, length)\n    });\n    let weight_accessor = mesh_data.add_accessor(GLTFAccessor::new(\n        weight_buffer_view,\n        GLTFComponentType::UnsignedByte, section.get_num_verts() as u32,\n        \"VEC4\", GLTFAccessorValue::None, GLTFAccessorValue::None\n    ).set_normalized(true));\n\n    Ok((joint_accessor, weight_accessor))\n}", "item_id": 3, "repo": "FunGamesLeaks/JohnWickParse", "file": "src/meshes.rs", "last_update_at": "2019-08-15T10:30:31+00:00", "question_id": "148a32529711b4917d13f4af8a1c511d85d510a4_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn make_weight_accessors(weights: &FSkinWeightVertexBuffer, buffer: &mut Vec<u8>, mesh_data: &mut GLTFItem, section: &FSkelMeshRenderSection, off: usize) \n    -> ParserResult<(Rc<RefCell<GLTFAccessor>>, Rc<RefCell<GLTFAccessor>>)> {\n    let joint_buffer_view = mesh_data.add_buffer_view({\n        let startpos = buffer.len();\n        let length = write_joints_buffer(weights, buffer, section, off)?;\n        GLTFBufferView::new(startpos as u32, length)\n    });\n    let joint_accessor = mesh_data.add_accessor(GLTFAccessor::new(\n        joint_buffer_view,\n        GLTFComponentType::UnsignedShort, section.get_num_verts() as u32,\n        \"VEC4\", GLTFAccessorValue::None, GLTFAccessorValue::None\n    ));\n    let weight_buffer_view = mesh_data.add_buffer_view({\n        let startpos = buffer.len();\n        let length = write_weights_buffer(weights, buffer, section, off)?;\n        GLTFBufferView::new(startpos as u32, length)\n    });\n    let weight_accessor = mesh_data.add_accessor(GLTFAccessor::new(\n        weight_buffer_view,\n        GLTFComponentType::UnsignedByte, section.get_num_verts() as u32,\n        \"VEC4\", GLTFAccessorValue::None, GLTFAccessorValue::None\n    ).set_normalized(true));\n    Ok((joint_accessor, weight_accessor))\n"]]}
{"hexsha": "8c6723109c04419ec61890636bd5c8f173f8934d", "ext": "rs", "lang": "Rust", "content": "fn output_symbol_is_none_by_default() {\n        let ndfa: Ndfa<u32, u32> = Ndfa::new();\n\n        assert!(ndfa.output_symbol_for_state(0) == None);\n        assert!(ndfa.output_symbol_for_state(1) == None);\n    }", "item_id": 6, "repo": "Logicalshift/rust-ndfa", "file": "src/ndfa.rs", "last_update_at": "2019-04-16T19:55:25+00:00", "question_id": "8c6723109c04419ec61890636bd5c8f173f8934d_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn output_symbol_is_none_by_default() {\n        let ndfa: Ndfa<u32, u32> = Ndfa::new();\n        assert!(ndfa.output_symbol_for_state(0) == None);\n        assert!(ndfa.output_symbol_for_state(1) == None);\n"]]}
{"hexsha": "2ac950027523cdd0b783cf904f7a2f788318e32b", "ext": "rs", "lang": "Rust", "content": "unsafe fn test_mm_adds_pi16() {\n        let a = _mm_setr_pi16(-32000, 32000, 4, 0);\n        let b = _mm_setr_pi16(-32000, 32000, -5, 1);\n        let e = _mm_setr_pi16(i16::MIN, i16::MAX, -1, 1);\n        assert_eq_m64(e, _mm_adds_pi16(a, b));\n        assert_eq_m64(e, _m_paddsw(a, b));\n    }", "item_id": 4, "repo": "ultimate-research/rust-std-skyline-squashed", "file": "src/stdarch/crates/core_arch/src/x86/mmx.rs", "last_update_at": "2019-08-26T03:46:37+00:00", "question_id": "2ac950027523cdd0b783cf904f7a2f788318e32b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn test_mm_adds_pi16() {\n        let a = _mm_setr_pi16(-32000, 32000, 4, 0);\n        let b = _mm_setr_pi16(-32000, 32000, -5, 1);\n        let e = _mm_setr_pi16(i16::MIN, i16::MAX, -1, 1);\n        assert_eq_m64(e, _mm_adds_pi16(a, b));\n        assert_eq_m64(e, _m_paddsw(a, b));\n"]]}
{"hexsha": "6732965205dbb9584f0f035768b7132c4c3ad828", "ext": "rs", "lang": "Rust", "content": "fn gzencoder_read_hello_world() -> io::Result<Vec<u8>> {\n    let mut ret_vec = [0; 100];\n    let c = b\"hello world\";\n    let mut z = GzEncoder::new(&c[..], Compression::fast());\n    let count = z.read(&mut ret_vec)?;\n    Ok(ret_vec[0..count].to_vec())\n}", "item_id": 0, "repo": "erickt/flate2-rs", "file": "examples/gzencoder-read.rs", "last_update_at": "2019-04-24T23:46:26+00:00", "question_id": "6732965205dbb9584f0f035768b7132c4c3ad828_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn gzencoder_read_hello_world() -> io::Result<Vec<u8>> {\n    let mut ret_vec = [0; 100];\n    let c = b\"hello world\";\n    let mut z = GzEncoder::new(&c[..], Compression::fast());\n    let count = z.read(&mut ret_vec)?;\n    Ok(ret_vec[0..count].to_vec())\n"]]}
{"hexsha": "41d1761a011505fc8993d495cd1c79ded6a693a8", "ext": "rs", "lang": "Rust", "content": "fn test_not_b() {\n        let mut cpu: CPU = CPU::new();\n        cpu.memory.write_8bit(0, 0b00111011);\n\n        cpu = cpu.set_b(Register { value: 0 });\n\n        cpu = executor::execute(cpu);\n\n        assert_eq!(cpu.pc.value, 1);\n        assert_eq!(cpu.f.value, 0);\n        assert_eq!(cpu.b.value, u64::max_value());\n    }", "item_id": 86, "repo": "TheLocust3/simple-virtual-machine", "file": "emu/tests/executor_tests.rs", "last_update_at": "2019-02-18T04:28:41+00:00", "question_id": "41d1761a011505fc8993d495cd1c79ded6a693a8_86", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_not_b() {\n        let mut cpu: CPU = CPU::new();\n        cpu.memory.write_8bit(0, 0b00111011);\n        cpu = cpu.set_b(Register { value: 0 });\n        cpu = executor::execute(cpu);\n        assert_eq!(cpu.pc.value, 1);\n        assert_eq!(cpu.f.value, 0);\n        assert_eq!(cpu.b.value, u64::max_value());\n"]]}
{"hexsha": "7c2a7d6f4de2da70cba9dcbcb8f1e0fad82fafda", "ext": "rs", "lang": "Rust", "content": "fn test_qc_smalln() {\n    quick_check_occurs!(|n: SmallN| *n == 0);\n    quick_check_occurs!(|n: SmallN| *n == 1);\n    quick_check_occurs!(|n: SmallN| *n > 10);\n}", "item_id": 6, "repo": "graydon/qc.rs", "file": "qc.rs", "last_update_at": "2019-06-03T17:04:10+00:00", "question_id": "7c2a7d6f4de2da70cba9dcbcb8f1e0fad82fafda_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_qc_smalln() {\n    quick_check_occurs!(|n: SmallN| *n == 0);\n    quick_check_occurs!(|n: SmallN| *n == 1);\n    quick_check_occurs!(|n: SmallN| *n > 10);\n"]]}
{"hexsha": "0e7e7760255ed40fe8810ab91f682be552e8fbd8", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn wl_registry_bind(mut wl_registry: *mut wl_registry,\n                                      mut name: uint32_t,\n                                      mut interface: *const wl_interface,\n                                      mut version: uint32_t)\n -> *mut libc::c_void {\n    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;\n    id =\n        wl_proxy_marshal_constructor_versioned(wl_registry as *mut wl_proxy,\n                                               0i32 as uint32_t, interface,\n                                               version, name,\n                                               (*interface).name, version,\n                                               0 as *mut libc::c_void);\n    return id as *mut libc::c_void;\n}", "item_id": 1, "repo": "RoastVeg/wlrusts", "file": "src/examples/foreign_toplevel.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "0e7e7760255ed40fe8810ab91f682be552e8fbd8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe extern \"C\" fn wl_registry_bind(mut wl_registry: *mut wl_registry,\n                                      mut name: uint32_t,\n                                      mut interface: *const wl_interface,\n                                      mut version: uint32_t)\n -> *mut libc::c_void {\n    let mut id: *mut wl_proxy = 0 as *mut wl_proxy;\n    id =\n        wl_proxy_marshal_constructor_versioned(wl_registry as *mut wl_proxy,\n                                               0i32 as uint32_t, interface,\n                                               version, name,\n                                               (*interface).name, version,\n                                               0 as *mut libc::c_void);\n    return id as *mut libc::c_void;\n"]]}
{"hexsha": "8a6f298c413813ccbbfc54ef647dd6fcc232100e", "ext": "rs", "lang": "Rust", "content": "pub fn initialize() -> Option<&'static Reference> {\r\n    static mut CLUSTER: Option<Reference> = None;\r\n\r\n    if unsafe { CLUSTER.is_none() } {\r\n        unsafe {\r\n            CLUSTER = js! {\r\n                return @{ super::js_private() }.cluster = require(\"cluster\");\r\n            }.into_reference()\r\n        };\r\n    }\r\n\r\n    unsafe { CLUSTER.as_ref() }\r\n}", "item_id": 0, "repo": "AndrewGaspar/node-rs", "file": "src/cluster.rs", "last_update_at": "2019-04-03T22:49:34+00:00", "question_id": "8a6f298c413813ccbbfc54ef647dd6fcc232100e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn initialize() -> Option<&'static Reference> {\r\n    static mut CLUSTER: Option<Reference> = None;\r\n\r\n    if unsafe { CLUSTER.is_none() } {\r\n        unsafe {\r\n            CLUSTER = js! {\r\n                return @{ super::js_private() }.cluster = require(\"cluster\");\r\n            }.into_reference()\r\n        };\r\n    }\r\n\r\n    unsafe { CLUSTER.as_ref() }\r\n"]]}
{"hexsha": "1d67ca4254ee2e57907b6ccb5129e8c67dc5275b", "ext": "rs", "lang": "Rust", "content": "fn error_type() {\n            use serde_tagged::de::WithTag;\n            use serde_tagged::de::external::deserialize as de;\n\n            let json = \"[]\";\n\n            let mut jde = serde_json::Deserializer::from_str(json);\n            let (_t, _v): (&str, &str) = de(&mut jde, WithTag::new()).unwrap();\n        }", "item_id": 5, "repo": "qzed/serde_tagged", "file": "tests/json.rs", "last_update_at": "2019-04-12T12:39:15+00:00", "question_id": "1d67ca4254ee2e57907b6ccb5129e8c67dc5275b_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn error_type() {\n            use serde_tagged::de::WithTag;\n            use serde_tagged::de::external::deserialize as de;\n            let json = \"[]\";\n            let mut jde = serde_json::Deserializer::from_str(json);\n            let (_t, _v): (&str, &str) = de(&mut jde, WithTag::new()).unwrap();\n"]]}
{"hexsha": "2bd6b627d5874983aee1b3f01a96e738bb064529", "ext": "rs", "lang": "Rust", "content": "async fn iterate_over_logarray() {\n        let store = MemoryBackedStore::new();\n        let mut builder = LogArrayFileBuilder::new(store.open_write().await.unwrap(), 5);\n        let original = vec![1, 3, 2, 5, 12, 31, 18];\n        block_on(async {\n            builder.push_all(stream_iter_ok(original.clone())).await?;\n            builder.finalize().await?;\n\n            Ok::<_, io::Error>(())\n        })\n        .unwrap();\n\n        let content = block_on(store.map()).unwrap();\n\n        let logarray = LogArray::parse(content).unwrap();\n\n        let result: Vec<u64> = logarray.iter().collect();\n\n        assert_eq!(original, result);\n    }", "item_id": 12, "repo": "terminusdb/ferricstore", "file": "src/structure/logarray.rs", "last_update_at": "2019-09-19T05:26:23+00:00", "question_id": "2bd6b627d5874983aee1b3f01a96e738bb064529_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn iterate_over_logarray() {\n        let store = MemoryBackedStore::new();\n        let mut builder = LogArrayFileBuilder::new(store.open_write().await.unwrap(), 5);\n        let original = vec![1, 3, 2, 5, 12, 31, 18];\n        block_on(async {\n            builder.push_all(stream_iter_ok(original.clone())).await?;\n            builder.finalize().await?;\n            Ok::<_, io::Error>(())\n        })\n        .unwrap();\n        let content = block_on(store.map()).unwrap();\n        let logarray = LogArray::parse(content).unwrap();\n        let result: Vec<u64> = logarray.iter().collect();\n        assert_eq!(original, result);\n"]]}
{"hexsha": "31f3415b1ecd026424e2de1baf2444e0e7edbe7f", "ext": "rs", "lang": "Rust", "content": "fn find_msvc_latest(arch: &str, ver: &str) -> Option<(Command, PathBuf)> {\n        let vcdir = otry!(get_vc_dir(ver));\n        let (mut cmd, host) = otry!(get_linker(&vcdir, arch));\n        let sub = otry!(lib_subdir(arch));\n        let ucrt = otry!(get_ucrt_dir());\n        debug!(\"Found Universal CRT {:?}\", ucrt);\n        add_lib(&mut cmd, &ucrt.join(\"ucrt\").join(sub));\n        if let Some(dir) = get_sdk10_dir() {\n            debug!(\"Found Win10 SDK {:?}\", dir);\n            add_lib(&mut cmd, &dir.join(\"um\").join(sub));\n        } else if let Some(dir) = get_sdk81_dir() {\n            debug!(\"Found Win8.1 SDK {:?}\", dir);\n            add_lib(&mut cmd, &dir.join(\"um\").join(sub));\n        } else {\n            return None\n        }\n        Some((cmd, host))\n    }", "item_id": 0, "repo": "sylvestre/rust", "file": "src/librustc_trans/back/msvc/mod.rs", "last_update_at": "2019-07-19T20:48:33+00:00", "question_id": "31f3415b1ecd026424e2de1baf2444e0e7edbe7f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn find_msvc_latest(arch: &str, ver: &str) -> Option<(Command, PathBuf)> {\n        let vcdir = otry!(get_vc_dir(ver));\n        let (mut cmd, host) = otry!(get_linker(&vcdir, arch));\n        let sub = otry!(lib_subdir(arch));\n        let ucrt = otry!(get_ucrt_dir());\n        debug!(\"Found Universal CRT {:?}\", ucrt);\n        add_lib(&mut cmd, &ucrt.join(\"ucrt\").join(sub));\n        if let Some(dir) = get_sdk10_dir() {\n            debug!(\"Found Win10 SDK {:?}\", dir);\n            add_lib(&mut cmd, &dir.join(\"um\").join(sub));\n        } else if let Some(dir) = get_sdk81_dir() {\n            debug!(\"Found Win8.1 SDK {:?}\", dir);\n            add_lib(&mut cmd, &dir.join(\"um\").join(sub));\n        } else {\n            return None\n        }\n        Some((cmd, host))\n"]]}
{"hexsha": "ea157e62bd72244c04d7ebe0067b7960a3693723", "ext": "rs", "lang": "Rust", "content": "pub fn public_decrypt(key: &Rsa<openssl::pkey::Public>, bytes: Tomb) -> Result<Tomb, Error> {\n    let mut sym = vec![0; key.size() as usize];\n    let mut iv = vec![0; key.size() as usize];\n    let len_sym = key.public_decrypt(\n        &decode(&bytes.aes_key)?,\n        &mut sym,\n        openssl::rsa::Padding::PKCS1,\n    )?;\n    let len_iv = key.public_decrypt(\n        &decode(&bytes.aes_iv)?,\n        &mut iv,\n        openssl::rsa::Padding::PKCS1,\n    )?;\n    let sym = encode(&sym[..len_sym].to_vec());\n    let iv = encode(&iv[..len_iv].to_vec());\n    let text = sym_dec(sym.clone(), iv.clone(), bytes.value)?;\n    Ok(Tomb {\n        aes_key: sym,\n        aes_iv: iv,\n        value: encode(&text),\n    })\n}", "item_id": 1, "repo": "joxcat/arthur-hugon-tools", "file": "src/security/rsa.rs", "last_update_at": "2019-09-25T15:46:02+00:00", "question_id": "ea157e62bd72244c04d7ebe0067b7960a3693723_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn public_decrypt(key: &Rsa<openssl::pkey::Public>, bytes: Tomb) -> Result<Tomb, Error> {\n    let mut sym = vec![0; key.size() as usize];\n    let mut iv = vec![0; key.size() as usize];\n    let len_sym = key.public_decrypt(\n        &decode(&bytes.aes_key)?,\n        &mut sym,\n        openssl::rsa::Padding::PKCS1,\n    )?;\n    let len_iv = key.public_decrypt(\n        &decode(&bytes.aes_iv)?,\n        &mut iv,\n        openssl::rsa::Padding::PKCS1,\n    )?;\n    let sym = encode(&sym[..len_sym].to_vec());\n    let iv = encode(&iv[..len_iv].to_vec());\n    let text = sym_dec(sym.clone(), iv.clone(), bytes.value)?;\n    Ok(Tomb {\n        aes_key: sym,\n        aes_iv: iv,\n        value: encode(&text),\n    })\n"]]}
{"hexsha": "56013aa6660245fa103909bf0708f9fb545181ff", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn iterate_component_events<T, D>(\n    tracked_storage: &Storage<T, D>,\n    reader_id: &mut ReaderId<ComponentEvent>,\n) -> (BitSet, BitSet, BitSet)\nwhere\n    T: Component,\n    T::Storage: Tracked,\n    D: Deref<Target = MaskedStorage<T>>,\n{\n    let (mut inserted, mut modified, mut removed) = (BitSet::new(), BitSet::new(), BitSet::new());\n    for component_event in tracked_storage.channel().read(reader_id) {\n        match component_event {\n            ComponentEvent::Inserted(id) => {\n                debug!(\"Got Inserted event with id: {}\", id);\n                inserted.add(*id);\n            }\n            ComponentEvent::Modified(id) => {\n                debug!(\"Got Modified event with id: {}\", id);\n                modified.add(*id);\n            }\n            ComponentEvent::Removed(id) => {\n                debug!(\"Got Removed event with id: {}\", id);\n                removed.add(*id);\n            }\n        }\n    }\n\n    (inserted, modified, removed)\n}", "item_id": 0, "repo": "jmeggitt/specs-physics", "file": "src/systems/mod.rs", "last_update_at": "2019-09-18T23:00:55+00:00", "question_id": "56013aa6660245fa103909bf0708f9fb545181ff_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn iterate_component_events<T, D>(\n    tracked_storage: &Storage<T, D>,\n    reader_id: &mut ReaderId<ComponentEvent>,\n) -> (BitSet, BitSet, BitSet)\nwhere\n    T: Component,\n    T::Storage: Tracked,\n    D: Deref<Target = MaskedStorage<T>>,\n{\n    let (mut inserted, mut modified, mut removed) = (BitSet::new(), BitSet::new(), BitSet::new());\n    for component_event in tracked_storage.channel().read(reader_id) {\n        match component_event {\n            ComponentEvent::Inserted(id) => {\n                debug!(\"Got Inserted event with id: {}\", id);\n                inserted.add(*id);\n            }\n            ComponentEvent::Modified(id) => {\n                debug!(\"Got Modified event with id: {}\", id);\n                modified.add(*id);\n            }\n            ComponentEvent::Removed(id) => {\n                debug!(\"Got Removed event with id: {}\", id);\n                removed.add(*id);\n            }\n        }\n    }\n    (inserted, modified, removed)\n"]]}
{"hexsha": "0f873cdf896e80d85368b960a5b5a0b02b84feb4", "ext": "rs", "lang": "Rust", "content": "pub fn main(matches: &ArgMatches) {\n    let input_files: Vec<String> = match values_t!(matches, \"input-files\", String) {\n        Ok(v) => v,\n        Err(e) => {\n            eprintln!(\"binstore: invalid input file: {}\", e);\n            process::exit(1)\n        }\n    };\n\n    let output_files: Vec<String> = match values_t!(matches, \"output-files\", String) {\n        Ok(v) => v,\n        Err(e) => {\n            eprintln!(\"binstore: invalid output file: {}\", e);\n            process::exit(1)\n        }\n    };\n\n    let values: Vec<Value> = match values_t!(matches, \"values\", Value) {\n        Ok(v) => v,\n        Err(e) => {\n            eprintln!(\"hydroxyde: invalid values: {}\", e);\n            process::exit(1);\n        }\n    };\n\n    if input_files.len() != output_files.len() {\n        eprintln!(\"binstore: number of input files does not match number of output files\");\n        process::exit(1)\n    }\n\n    let files: Vec<(String, String)> = input_files.into_iter().zip(output_files).collect();\n\n    let mut ret = 0;\n    for (input, output) in &files {\n        if let Err(e) = binstore::bucket::delete(input, output, &values) {\n            ret = 1;\n            eprintln!(\"binstore: {}: {}\", input, e);\n        }\n    }\n    process::exit(ret);\n}", "item_id": 0, "repo": "matlapo/binstore", "file": "src/subcommands/delete.rs", "last_update_at": "2019-11-22T05:27:55+00:00", "question_id": "0f873cdf896e80d85368b960a5b5a0b02b84feb4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn main(matches: &ArgMatches) {\n    let input_files: Vec<String> = match values_t!(matches, \"input-files\", String) {\n        Ok(v) => v,\n        Err(e) => {\n            eprintln!(\"binstore: invalid input file: {}\", e);\n            process::exit(1)\n        }\n    };\n    let output_files: Vec<String> = match values_t!(matches, \"output-files\", String) {\n        Ok(v) => v,\n        Err(e) => {\n            eprintln!(\"binstore: invalid output file: {}\", e);\n            process::exit(1)\n        }\n    };\n    let values: Vec<Value> = match values_t!(matches, \"values\", Value) {\n        Ok(v) => v,\n        Err(e) => {\n            eprintln!(\"hydroxyde: invalid values: {}\", e);\n            process::exit(1);\n        }\n    };\n    if input_files.len() != output_files.len() {\n        eprintln!(\"binstore: number of input files does not match number of output files\");\n        process::exit(1)\n    }\n    let files: Vec<(String, String)> = input_files.into_iter().zip(output_files).collect();\n    let mut ret = 0;\n    for (input, output) in &files {\n        if let Err(e) = binstore::bucket::delete(input, output, &values) {\n            ret = 1;\n            eprintln!(\"binstore: {}: {}\", input, e);\n        }\n    }\n    process::exit(ret);\n"]]}
{"hexsha": "89e4089c0a7dd1189fd2b5eee7bba650eded0a39", "ext": "rs", "lang": "Rust", "content": "fn test_update_ts_activity() {\n        let (mut conn, _guard) = setup_db();\n\n        let data = vec![\n            TsActivity {\n                client: 1,\n                time: 1,\n                channel: 1,\n            },\n            TsActivity {\n                client: 1,\n                time: 2,\n                channel: 2,\n            },\n            TsActivity {\n                client: 2,\n                time: 3,\n                channel: 1,\n            },\n        ];\n        let date = NaiveDate::from_ymd(2020, 03, 29);\n        update_ts_activity(&mut conn, date, &data).unwrap();\n\n        let res = get_ts_activity_ordered(&mut conn).unwrap();\n        for i in 0..res.len() {\n            let (r_date, act) = &res[i];\n            assert_eq!(*r_date, date);\n            assert_eq!(act, &data[i]);\n        }\n\n        // now update it\n        let data = vec![\n            TsActivity {\n                client: 1,\n                time: 10,\n                channel: 1,\n            },\n            TsActivity {\n                client: 2,\n                time: 10,\n                channel: 1,\n            },\n        ];\n        update_ts_activity(&mut conn, date, &data).unwrap();\n        let res = get_ts_activity_ordered(&mut conn).unwrap();\n        let expected: Vec<_> = vec![\n            TsActivity {\n                client: 1,\n                time: 11,\n                channel: 1,\n            },\n            TsActivity {\n                client: 1,\n                time: 2,\n                channel: 2,\n            },\n            TsActivity {\n                client: 2,\n                time: 13,\n                channel: 1,\n            },\n        ]\n        .drain(..)\n        .map(|v| (date.clone(), v))\n        .collect();\n        assert_eq!(expected, res);\n    }", "item_id": 6, "repo": "0xpr03/cf-tool", "file": "daemon/src/db/ts.rs", "last_update_at": "2019-01-08T18:49:06+00:00", "question_id": "89e4089c0a7dd1189fd2b5eee7bba650eded0a39_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_update_ts_activity() {\n        let (mut conn, _guard) = setup_db();\n        let data = vec![\n            TsActivity {\n                client: 1,\n                time: 1,\n                channel: 1,\n            },\n            TsActivity {\n                client: 1,\n                time: 2,\n                channel: 2,\n            },\n            TsActivity {\n                client: 2,\n                time: 3,\n                channel: 1,\n            },\n        ];\n        let date = NaiveDate::from_ymd(2020, 03, 29);\n        update_ts_activity(&mut conn, date, &data).unwrap();\n        let res = get_ts_activity_ordered(&mut conn).unwrap();\n        for i in 0..res.len() {\n            let (r_date, act) = &res[i];\n            assert_eq!(*r_date, date);\n            assert_eq!(act, &data[i]);\n        }\n        // now update it\n        let data = vec![\n            TsActivity {\n                client: 1,\n                time: 10,\n                channel: 1,\n            },\n            TsActivity {\n                client: 2,\n                time: 10,\n                channel: 1,\n            },\n        ];\n        update_ts_activity(&mut conn, date, &data).unwrap();\n        let res = get_ts_activity_ordered(&mut conn).unwrap();\n        let expected: Vec<_> = vec![\n            TsActivity {\n                client: 1,\n                time: 11,\n                channel: 1,\n            },\n            TsActivity {\n                client: 1,\n                time: 2,\n                channel: 2,\n            },\n            TsActivity {\n                client: 2,\n                time: 13,\n                channel: 1,\n            },\n        ]\n        .drain(..)\n        .map(|v| (date.clone(), v))\n        .collect();\n        assert_eq!(expected, res);\n"]]}
{"hexsha": "347963d1618b9b928197154aec004580113b30f7", "ext": "rs", "lang": "Rust", "content": "fn two_variables_for_two_froms() {\n    let mut p = Parser::new(\n        r#\"howdy = from()\n\t\t\tdoody = from()\n\t\t\thowdy|>count()\n\t\t\tdoody|>sum()\"#,\n    );\n    let parsed = p.parse_file(\"\".to_string());\n    assert_eq!(\n        parsed,\n        File {\n            base: BaseNode { errors: vec![] },\n            name: \"\".to_string(),\n            package: None,\n            imports: vec![],\n            body: vec![\n                Var(VariableAssignment {\n                    base: BaseNode { errors: vec![] },\n                    id: Identifier {\n                        base: BaseNode { errors: vec![] },\n                        name: \"howdy\".to_string()\n                    },\n                    init: Call(Box::new(CallExpression {\n                        base: BaseNode { errors: vec![] },\n                        arguments: vec![],\n                        callee: Idt(Identifier {\n                            base: BaseNode { errors: vec![] },\n                            name: \"from\".to_string()\n                        })\n                    })),\n                }),\n                Var(VariableAssignment {\n                    base: BaseNode { errors: vec![] },\n                    id: Identifier {\n                        base: BaseNode { errors: vec![] },\n                        name: \"doody\".to_string()\n                    },\n                    init: Call(Box::new(CallExpression {\n                        base: BaseNode { errors: vec![] },\n                        arguments: vec![],\n                        callee: Idt(Identifier {\n                            base: BaseNode { errors: vec![] },\n                            name: \"from\".to_string()\n                        })\n                    })),\n                }),\n                Expr(ExpressionStatement {\n                    base: BaseNode { errors: vec![] },\n                    expression: Pipe(Box::new(PipeExpression {\n                        base: BaseNode { errors: vec![] },\n                        argument: Idt(Identifier {\n                            base: BaseNode { errors: vec![] },\n                            name: \"howdy\".to_string()\n                        }),\n                        call: CallExpression {\n                            base: BaseNode { errors: vec![] },\n                            callee: Idt(Identifier {\n                                base: BaseNode { errors: vec![] },\n                                name: \"count\".to_string()\n                            }),\n                            arguments: vec![]\n                        }\n                    }))\n                }),\n                Expr(ExpressionStatement {\n                    base: BaseNode { errors: vec![] },\n                    expression: Pipe(Box::new(PipeExpression {\n                        base: BaseNode { errors: vec![] },\n                        argument: Idt(Identifier {\n                            base: BaseNode { errors: vec![] },\n                            name: \"doody\".to_string()\n                        }),\n                        call: CallExpression {\n                            base: BaseNode { errors: vec![] },\n                            callee: Idt(Identifier {\n                                base: BaseNode { errors: vec![] },\n                                name: \"sum\".to_string()\n                            }),\n                            arguments: vec![]\n                        }\n                    }))\n                })\n            ]\n        },\n    )\n}", "item_id": 31, "repo": "davidgs/flux", "file": "internal/rust/parser/src/tests.rs", "last_update_at": "2019-04-29T06:33:07+00:00", "question_id": "347963d1618b9b928197154aec004580113b30f7_31", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn two_variables_for_two_froms() {\n    let mut p = Parser::new(\n        r#\"howdy = from()\n\t\t\tdoody = from()\n\t\t\thowdy|>count()\n\t\t\tdoody|>sum()\"#,\n    );\n    let parsed = p.parse_file(\"\".to_string());\n    assert_eq!(\n        parsed,\n        File {\n            base: BaseNode { errors: vec![] },\n            name: \"\".to_string(),\n            package: None,\n            imports: vec![],\n            body: vec![\n                Var(VariableAssignment {\n                    base: BaseNode { errors: vec![] },\n                    id: Identifier {\n                        base: BaseNode { errors: vec![] },\n                        name: \"howdy\".to_string()\n                    },\n                    init: Call(Box::new(CallExpression {\n                        base: BaseNode { errors: vec![] },\n                        arguments: vec![],\n                        callee: Idt(Identifier {\n                            base: BaseNode { errors: vec![] },\n                            name: \"from\".to_string()\n                        })\n                    })),\n                }),\n                Var(VariableAssignment {\n                    base: BaseNode { errors: vec![] },\n                    id: Identifier {\n                        base: BaseNode { errors: vec![] },\n                        name: \"doody\".to_string()\n                    },\n                    init: Call(Box::new(CallExpression {\n                        base: BaseNode { errors: vec![] },\n                        arguments: vec![],\n                        callee: Idt(Identifier {\n                            base: BaseNode { errors: vec![] },\n                            name: \"from\".to_string()\n                        })\n                    })),\n                }),\n                Expr(ExpressionStatement {\n                    base: BaseNode { errors: vec![] },\n                    expression: Pipe(Box::new(PipeExpression {\n                        base: BaseNode { errors: vec![] },\n                        argument: Idt(Identifier {\n                            base: BaseNode { errors: vec![] },\n                            name: \"howdy\".to_string()\n                        }),\n                        call: CallExpression {\n                            base: BaseNode { errors: vec![] },\n                            callee: Idt(Identifier {\n                                base: BaseNode { errors: vec![] },\n                                name: \"count\".to_string()\n                            }),\n                            arguments: vec![]\n                        }\n                    }))\n                }),\n                Expr(ExpressionStatement {\n                    base: BaseNode { errors: vec![] },\n                    expression: Pipe(Box::new(PipeExpression {\n                        base: BaseNode { errors: vec![] },\n                        argument: Idt(Identifier {\n                            base: BaseNode { errors: vec![] },\n                            name: \"doody\".to_string()\n                        }),\n                        call: CallExpression {\n                            base: BaseNode { errors: vec![] },\n                            callee: Idt(Identifier {\n                                base: BaseNode { errors: vec![] },\n                                name: \"sum\".to_string()\n                            }),\n                            arguments: vec![]\n                        }\n                    }))\n                })\n            ]\n        },\n    )\n"]]}
{"hexsha": "7e531c3bdea1ac61d9c878887639024900ad84fb", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    pretty_env_logger::init().unwrap();\n\n    let url = match env::args().nth(1) {\n        Some(url) => url,\n        None => {\n            println!(\"Usage: client <url>\");\n            return;\n        }\n    };\n\n    infinite_request(url)\n}", "item_id": 0, "repo": "reoring/influxdb_benchmark", "file": "src/main.rs", "last_update_at": "2019-04-01T13:27:26+00:00", "question_id": "7e531c3bdea1ac61d9c878887639024900ad84fb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    pretty_env_logger::init().unwrap();\n    let url = match env::args().nth(1) {\n        Some(url) => url,\n        None => {\n            println!(\"Usage: client <url>\");\n            return;\n        }\n    };\n    infinite_request(url)\n"]]}
{"hexsha": "b27f4ea621e611566b5fbb0e8bbcce089ef8c7a2", "ext": "rs", "lang": "Rust", "content": "fn format_dft_counterclockwise(omega: i64, n: i64) -> String {\n    let has_halves = 0 == n % 2;\n    let has_quarters = 0 == n % 4;\n\n    let i = n / 4;\n    let neg_one = n / 2;\n    let neg_i = 3 * n / 4;\n\n    let q2 = i..neg_one;\n    let q3 = neg_one..neg_i;\n    let q4 = neg_i..n;\n\n    if omega == 0 { \" 1\".to_string() }\n    else if has_quarters && omega == i          { \" i\".to_string() }\n    else if has_halves   && omega == neg_one    { \"-1\".to_string() } \n    else if has_quarters && omega == neg_i      { \"-i\".to_string() }\n    else if has_quarters && q2.contains(&omega) { format_omega(\" i\", omega - i)       }\n    else if has_halves   && q3.contains(&omega) { format_omega(\" -\", omega - neg_one) }\n    else if has_quarters && q4.contains(&omega) { format_omega(\"-i\", omega - neg_i)   }\n    else { format_omega(\"\", omega) }\n}", "item_id": 2, "repo": "aeketn/nordint", "file": "exercise-02-dft-matrices/src/main.rs", "last_update_at": "2019-02-16T16:31:40+00:00", "question_id": "b27f4ea621e611566b5fbb0e8bbcce089ef8c7a2_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn format_dft_counterclockwise(omega: i64, n: i64) -> String {\n    let has_halves = 0 == n % 2;\n    let has_quarters = 0 == n % 4;\n    let i = n / 4;\n    let neg_one = n / 2;\n    let neg_i = 3 * n / 4;\n    let q2 = i..neg_one;\n    let q3 = neg_one..neg_i;\n    let q4 = neg_i..n;\n    if omega == 0 { \" 1\".to_string() }\n    else if has_quarters && omega == i          { \" i\".to_string() }\n    else if has_halves   && omega == neg_one    { \"-1\".to_string() } \n    else if has_quarters && omega == neg_i      { \"-i\".to_string() }\n    else if has_quarters && q2.contains(&omega) { format_omega(\" i\", omega - i)       }\n    else if has_halves   && q3.contains(&omega) { format_omega(\" -\", omega - neg_one) }\n    else if has_quarters && q4.contains(&omega) { format_omega(\"-i\", omega - neg_i)   }\n    else { format_omega(\"\", omega) }\n"]]}
{"hexsha": "93c28e8e074c403d1d9e704fd396a0f10b3d6c75", "ext": "rs", "lang": "Rust", "content": "fn solve(from: &Vec<i64>, to: &Vec<i64>) -> i64 {\n  let roads = from.len();\n  let mut cities: Vec<bool> = vec![false; roads + 1];\n  for city in to.iter() {\n    cities[*city as usize] = true;\n  }\n  for city in from.iter() {\n    cities[*city as usize] = false;\n  }\n  let mut result: i64 = -1;\n  for (city, is_rome) in cities.iter().enumerate() {\n    if *is_rome {\n      if result < 0 {\n        result = city as i64;\n      } else {\n        return -1;\n      }\n    }\n  }\n  return result;\n}", "item_id": 2, "repo": "sgeos/InterviewQuestions", "file": "rust/src/question/rome.rs", "last_update_at": "2019-04-20T14:06:22+00:00", "question_id": "93c28e8e074c403d1d9e704fd396a0f10b3d6c75_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn solve(from: &Vec<i64>, to: &Vec<i64>) -> i64 {\n  let roads = from.len();\n  let mut cities: Vec<bool> = vec![false; roads + 1];\n  for city in to.iter() {\n    cities[*city as usize] = true;\n  }\n  for city in from.iter() {\n    cities[*city as usize] = false;\n  }\n  let mut result: i64 = -1;\n  for (city, is_rome) in cities.iter().enumerate() {\n    if *is_rome {\n      if result < 0 {\n        result = city as i64;\n      } else {\n        return -1;\n      }\n    }\n  }\n  return result;\n"]]}
{"hexsha": "3d55062c5244f88dcd462a368f5ca932bdf94007", "ext": "rs", "lang": "Rust", "content": "fn spec_test_587() {\n    let original = r##\"![Foo]\n\n[foo]: /url \"title\"\n\"##;\n    let expected = r##\"<p><img src=\"/url\" alt=\"Foo\" title=\"title\" /></p>\n\"##;\n\n    test_markdown_html(original, expected);\n}", "item_id": 586, "repo": "NaokiM03/pulldown-cmark", "file": "tests/suite/spec.rs", "last_update_at": "2019-07-11T13:20:46+00:00", "question_id": "3d55062c5244f88dcd462a368f5ca932bdf94007_586", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn spec_test_587() {\n    let original = r##\"![Foo]\n[foo]: /url \"title\"\n\"##;\n    let expected = r##\"<p><img src=\"/url\" alt=\"Foo\" title=\"title\" /></p>\n\"##;\n    test_markdown_html(original, expected);\n"]]}
{"hexsha": "afc32c6487a6bb37e86efce5225b760f10e4bd17", "ext": "rs", "lang": "Rust", "content": "unsafe fn set_hw_params_from_format(\n    pcm_handle: *mut alsa::snd_pcm_t,\n    hw_params: &HwParams,\n    format: &Format,\n) -> Result<(), String> {\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_any(pcm_handle, hw_params.0)) {\n        return Err(format!(\"errors on pcm handle: {}\", e));\n    }\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_access(pcm_handle,\n                                                    hw_params.0,\n                                                    alsa::SND_PCM_ACCESS_RW_INTERLEAVED)) {\n        return Err(format!(\"handle not acessible: {}\", e));\n    }\n\n    let data_type = if cfg!(target_endian = \"big\") {\n        match format.data_type {\n            SampleFormat::I16 => alsa::SND_PCM_FORMAT_S16_BE,\n            SampleFormat::U16 => alsa::SND_PCM_FORMAT_U16_BE,\n            SampleFormat::F32 => alsa::SND_PCM_FORMAT_FLOAT_BE,\n        }\n    } else {\n        match format.data_type {\n            SampleFormat::I16 => alsa::SND_PCM_FORMAT_S16_LE,\n            SampleFormat::U16 => alsa::SND_PCM_FORMAT_U16_LE,\n            SampleFormat::F32 => alsa::SND_PCM_FORMAT_FLOAT_LE,\n        }\n    };\n\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_format(pcm_handle,\n                                                    hw_params.0,\n                                                    data_type)) {\n        return Err(format!(\"format could not be set: {}\", e));\n    }\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_rate(pcm_handle,\n                                                  hw_params.0,\n                                                  format.sample_rate.0 as libc::c_uint,\n                                                  0)) {\n        return Err(format!(\"sample rate could not be set: {}\", e));\n    }\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_channels(pcm_handle,\n                                                      hw_params.0,\n                                                      format.channels as\n                                                                      libc::c_uint)) {\n        return Err(format!(\"channel count could not be set: {}\", e));\n    }\n\n    // If this isn't set manually a overlarge buffer may be used causing audio delay\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_buffer_time_near(\n        pcm_handle,\n        hw_params.0,\n        &mut 100_000,\n        &mut 0,\n    )) {\n        return Err(format!(\"buffer time could not be set: {}\", e));\n    }\n\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params(pcm_handle, hw_params.0)) {\n        return Err(format!(\"hardware params could not be set: {}\", e));\n    }\n\n    Ok(())\n}", "item_id": 1, "repo": "Luni-4/cpal", "file": "src/host/alsa/mod.rs", "last_update_at": "2019-11-10T17:44:22+00:00", "question_id": "afc32c6487a6bb37e86efce5225b760f10e4bd17_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn set_hw_params_from_format(\n    pcm_handle: *mut alsa::snd_pcm_t,\n    hw_params: &HwParams,\n    format: &Format,\n) -> Result<(), String> {\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_any(pcm_handle, hw_params.0)) {\n        return Err(format!(\"errors on pcm handle: {}\", e));\n    }\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_access(pcm_handle,\n                                                    hw_params.0,\n                                                    alsa::SND_PCM_ACCESS_RW_INTERLEAVED)) {\n        return Err(format!(\"handle not acessible: {}\", e));\n    }\n    let data_type = if cfg!(target_endian = \"big\") {\n        match format.data_type {\n            SampleFormat::I16 => alsa::SND_PCM_FORMAT_S16_BE,\n            SampleFormat::U16 => alsa::SND_PCM_FORMAT_U16_BE,\n            SampleFormat::F32 => alsa::SND_PCM_FORMAT_FLOAT_BE,\n        }\n    } else {\n        match format.data_type {\n            SampleFormat::I16 => alsa::SND_PCM_FORMAT_S16_LE,\n            SampleFormat::U16 => alsa::SND_PCM_FORMAT_U16_LE,\n            SampleFormat::F32 => alsa::SND_PCM_FORMAT_FLOAT_LE,\n        }\n    };\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_format(pcm_handle,\n                                                    hw_params.0,\n                                                    data_type)) {\n        return Err(format!(\"format could not be set: {}\", e));\n    }\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_rate(pcm_handle,\n                                                  hw_params.0,\n                                                  format.sample_rate.0 as libc::c_uint,\n                                                  0)) {\n        return Err(format!(\"sample rate could not be set: {}\", e));\n    }\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_channels(pcm_handle,\n                                                      hw_params.0,\n                                                      format.channels as\n                                                                      libc::c_uint)) {\n        return Err(format!(\"channel count could not be set: {}\", e));\n    }\n    // If this isn't set manually a overlarge buffer may be used causing audio delay\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params_set_buffer_time_near(\n        pcm_handle,\n        hw_params.0,\n        &mut 100_000,\n        &mut 0,\n    )) {\n        return Err(format!(\"buffer time could not be set: {}\", e));\n    }\n    if let Err(e) = check_errors(alsa::snd_pcm_hw_params(pcm_handle, hw_params.0)) {\n        return Err(format!(\"hardware params could not be set: {}\", e));\n    }\n    Ok(())\n"]]}
{"hexsha": "c06910b5192a29097bb166d93be686624985f051", "ext": "rs", "lang": "Rust", "content": "fn mv_ll<P: AsRef<Path>>(old: P, new: P) {\n\trmdir(&new);\n\tmkdir(&new);\n\tfs::rename(old, new).unwrap();\n}", "item_id": 2, "repo": "aldarons-tech/adi_storage", "file": "src/lib.rs", "last_update_at": "2019-07-25T10:50:17+00:00", "question_id": "c06910b5192a29097bb166d93be686624985f051_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn mv_ll<P: AsRef<Path>>(old: P, new: P) {\n\trmdir(&new);\n\tmkdir(&new);\n\tfs::rename(old, new).unwrap();\n"]]}
{"hexsha": "05a8e3d209a834b128c7405ce0187866ee65df72", "ext": "rs", "lang": "Rust", "content": "fn basic_parsing() {\n        assert_eq!(super::Version::from_str(\"0.1.2\").unwrap(), super::Version::new(&[0,1,2]));\n        assert_eq!(super::Version::from_str(\"120.1.2\").unwrap(), super::Version::new(&[120,1,2]));\n        assert_eq!(super::Version::from_str(\"1.12.2\").unwrap(), super::Version::new(&[1,12,2]));\n        assert_eq!(super::Version::from_str(\"1.1.132\").unwrap(), super::Version::new(&[1,1,132]));\n        assert_eq!(super::Version::from_str(\"0.0.2\").unwrap(), super::Version::new(&[0,0,2]));\n        assert_eq!(super::Version::from_str(\"0132.1.2\").unwrap(), super::Version::new(&[132,1,2]));\n        assert_eq!(super::Version::from_str(\"1.2.3.12.123.231.111\").unwrap(), super::Version::new(&[1,2,3,12,123,231,111]));\n        assert_eq!(super::Version::from_str(\"1.2\").unwrap(), super::Version::new(&[1,2]));\n        assert_eq!(super::Version::from_str(\"1\").unwrap(), super::Version::new(&[1]));\n    }", "item_id": 12, "repo": "snsvrno/version-lp-rs", "file": "src/version.rs", "last_update_at": "2019-02-18T05:07:17+00:00", "question_id": "05a8e3d209a834b128c7405ce0187866ee65df72_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn basic_parsing() {\n        assert_eq!(super::Version::from_str(\"0.1.2\").unwrap(), super::Version::new(&[0,1,2]));\n        assert_eq!(super::Version::from_str(\"120.1.2\").unwrap(), super::Version::new(&[120,1,2]));\n        assert_eq!(super::Version::from_str(\"1.12.2\").unwrap(), super::Version::new(&[1,12,2]));\n        assert_eq!(super::Version::from_str(\"1.1.132\").unwrap(), super::Version::new(&[1,1,132]));\n        assert_eq!(super::Version::from_str(\"0.0.2\").unwrap(), super::Version::new(&[0,0,2]));\n        assert_eq!(super::Version::from_str(\"0132.1.2\").unwrap(), super::Version::new(&[132,1,2]));\n        assert_eq!(super::Version::from_str(\"1.2.3.12.123.231.111\").unwrap(), super::Version::new(&[1,2,3,12,123,231,111]));\n        assert_eq!(super::Version::from_str(\"1.2\").unwrap(), super::Version::new(&[1,2]));\n        assert_eq!(super::Version::from_str(\"1\").unwrap(), super::Version::new(&[1]));\n"]]}
{"hexsha": "3ea220d29184a0a8e2e8d27279ea0a0f05f6f451", "ext": "rs", "lang": "Rust", "content": "fn bytecode_xor() {\n    let mut state1 = AbstractState::new();\n    state1.stack_push(AbstractValue::new_primitive(SignatureToken::U64));\n    state1.stack_push(AbstractValue::new_primitive(SignatureToken::U64));\n    let state2 = common::run_instruction(Bytecode::Xor, state1);\n    assert_eq!(\n        state2.stack_peek(0),\n        Some(AbstractValue::new_primitive(SignatureToken::U64)),\n        \"stack type postcondition not met\"\n    );\n}", "item_id": 2, "repo": "the729/libra", "file": "language/tools/test_generation/tests/bitwise_instructions.rs", "last_update_at": "2019-09-28T08:38:24+00:00", "question_id": "3ea220d29184a0a8e2e8d27279ea0a0f05f6f451_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bytecode_xor() {\n    let mut state1 = AbstractState::new();\n    state1.stack_push(AbstractValue::new_primitive(SignatureToken::U64));\n    state1.stack_push(AbstractValue::new_primitive(SignatureToken::U64));\n    let state2 = common::run_instruction(Bytecode::Xor, state1);\n    assert_eq!(\n        state2.stack_peek(0),\n        Some(AbstractValue::new_primitive(SignatureToken::U64)),\n        \"stack type postcondition not met\"\n    );\n"]]}
{"hexsha": "b15cb133f18ab2b10e59882e4af5ced68b32f928", "ext": "rs", "lang": "Rust", "content": "fn parse_align() {\n        assert_eq!(Align::parse(\"auto\"), Ok(Align::Auto));\n        //assert_eq!(Align::parse(\"start\"), Ok(Align::Start));\n\n        assert_eq!(Align::parse(\"flex-start\"), Ok(Align::FlexStart));\n        assert_eq!(Align::parse(\"center\"), Ok(Align::Center));\n        //assert_eq!(Align::parse(\"end\"), Ok(Align::End));\n\n        assert_eq!(Align::parse(\"flex-end\"), Ok(Align::FlexEnd));\n        assert_eq!(Align::parse(\"stretch\"), Ok(Align::Stretch));\n        assert_eq!(Align::parse(\"baseline\"), Ok(Align::Baseline));\n        assert_eq!(Align::parse(\"space-between\"), Ok(Align::SpaceBetween));\n        assert_eq!(Align::parse(\"space-around\"), Ok(Align::SpaceAround));\n        //assert_eq!(Align::parse(\"space-evenly\"), Ok(Align::SpaceEvenly));\n    }", "item_id": 0, "repo": "cztomsik/stain", "file": "libgraffiti/src/css/values/enums.rs", "last_update_at": "2019-10-05T02:38:44+00:00", "question_id": "b15cb133f18ab2b10e59882e4af5ced68b32f928_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_align() {\n        assert_eq!(Align::parse(\"auto\"), Ok(Align::Auto));\n        //assert_eq!(Align::parse(\"start\"), Ok(Align::Start));\n        assert_eq!(Align::parse(\"flex-start\"), Ok(Align::FlexStart));\n        assert_eq!(Align::parse(\"center\"), Ok(Align::Center));\n        //assert_eq!(Align::parse(\"end\"), Ok(Align::End));\n        assert_eq!(Align::parse(\"flex-end\"), Ok(Align::FlexEnd));\n        assert_eq!(Align::parse(\"stretch\"), Ok(Align::Stretch));\n        assert_eq!(Align::parse(\"baseline\"), Ok(Align::Baseline));\n        assert_eq!(Align::parse(\"space-between\"), Ok(Align::SpaceBetween));\n        assert_eq!(Align::parse(\"space-around\"), Ok(Align::SpaceAround));\n        //assert_eq!(Align::parse(\"space-evenly\"), Ok(Align::SpaceEvenly));\n"]]}
{"hexsha": "c10ed2ed122f6a4542f1d037cce05602f68c8c04", "ext": "rs", "lang": "Rust", "content": "pub fn parse_lambda(args: &List<LispObject>) -> GenResult<ParsedLambda> {\n    let no_arglist = || SyntaxError::new(\"no arglist in lambda\");\n\n    let name_or_arglist = args.first().ok_or_else(no_arglist)?;\n\n    let mut name = None;\n    let arglist;\n    let body;\n\n    if let Ok(sym) = object::to_symbol(name_or_arglist) {\n        name = Some(sym.clone());\n        arglist = args.iter().nth(1).ok_or_else(no_arglist)?;\n        body = args.tailn(2);\n    } else {\n        arglist = name_or_arglist;\n        body = args.tail()\n    }\n\n    let arglist =\n        object::to_list(arglist).map_err(|_e| SyntaxError::new(\"lambda arglist in not a list\"))?;\n    let arglist = arglist\n        .iter()\n        .map(|lo| {\n            object::to_symbol(lo)\n                .map(|s| s.clone())\n                .map_err(|_e| SyntaxError::new(\"expected symbol in arglist\"))\n        })\n        .collect::<Result<Vec<_>, _>>()?;\n\n    let (simple_args, restarg) = parse_arglist(arglist)?;\n\n    Ok(ParsedLambda {\n        name: name,\n        simple_args: simple_args,\n        restarg: restarg,\n        body: body,\n    })\n}", "item_id": 3, "repo": "OlegTheCat/unlisp", "file": "src/special.rs", "last_update_at": "2019-05-30T15:03:16+00:00", "question_id": "c10ed2ed122f6a4542f1d037cce05602f68c8c04_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse_lambda(args: &List<LispObject>) -> GenResult<ParsedLambda> {\n    let no_arglist = || SyntaxError::new(\"no arglist in lambda\");\n    let name_or_arglist = args.first().ok_or_else(no_arglist)?;\n    let mut name = None;\n    let arglist;\n    let body;\n    if let Ok(sym) = object::to_symbol(name_or_arglist) {\n        name = Some(sym.clone());\n        arglist = args.iter().nth(1).ok_or_else(no_arglist)?;\n        body = args.tailn(2);\n    } else {\n        arglist = name_or_arglist;\n        body = args.tail()\n    }\n    let arglist =\n        object::to_list(arglist).map_err(|_e| SyntaxError::new(\"lambda arglist in not a list\"))?;\n    let arglist = arglist\n        .iter()\n        .map(|lo| {\n            object::to_symbol(lo)\n                .map(|s| s.clone())\n                .map_err(|_e| SyntaxError::new(\"expected symbol in arglist\"))\n        })\n        .collect::<Result<Vec<_>, _>>()?;\n    let (simple_args, restarg) = parse_arglist(arglist)?;\n    Ok(ParsedLambda {\n        name: name,\n        simple_args: simple_args,\n        restarg: restarg,\n        body: body,\n    })\n"]]}
{"hexsha": "c98722bdeae8e2e99256969c4c0af456b787ca7c", "ext": "rs", "lang": "Rust", "content": "fn load_graph_test() {\n        let f = File::open(\"testdata/parser.graph.gz\").expect(\"Cannot open test graph.\");\n        let mut decoder = GzDecoder::new(BufReader::new(f));\n        let mut data = Vec::new();\n        decoder\n            .read_to_end(&mut data)\n            .expect(\"Cannot decompress test graph.\");\n\n        let system = StackProjectiveSystem::new();\n        let vectorizer = InputVectorizer::new(\n            LayerLookups::new(),\n            AddressedValues(Vec::new()),\n            HashMap::new(),\n            Vec::new()\n        );\n\n        let mut op_names = LayerOps::new();\n        op_names.insert(\n            Layer::Token,\n            LayerOp::Embedding {\n                op: \"model/tokens\",\n                embed_op: \"model/token_embeds\",\n            },\n        );\n        op_names.insert(\n            Layer::Tag,\n            LayerOp::Embedding {\n                op: \"model/tags\",\n                embed_op: \"model/tag_embeds\",\n            },\n        );\n        op_names.insert(\n            Layer::DepRel,\n            LayerOp::Table {\n                op: \"model/deprels\",\n            },\n        );\n        op_names.insert(\n            Layer::Feature,\n            LayerOp::Table {\n                op: \"model/features\",\n            },\n        );\n        op_names.insert(\n            Layer::Char,\n            LayerOp::Embedding {\n                op: \"model/chars\",\n                embed_op: \"model/char_embeds\",\n            },\n        );\n\n        TensorflowModel::load_graph(&[], &data, system, vectorizer, &op_names)\n            .expect(\"Cannot load graph.\");\n    }", "item_id": 1, "repo": "sfb833-a3/dpar", "file": "dpar/src/models/tensorflow/model.rs", "last_update_at": "2019-03-13T08:04:51+00:00", "question_id": "c98722bdeae8e2e99256969c4c0af456b787ca7c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn load_graph_test() {\n        let f = File::open(\"testdata/parser.graph.gz\").expect(\"Cannot open test graph.\");\n        let mut decoder = GzDecoder::new(BufReader::new(f));\n        let mut data = Vec::new();\n        decoder\n            .read_to_end(&mut data)\n            .expect(\"Cannot decompress test graph.\");\n        let system = StackProjectiveSystem::new();\n        let vectorizer = InputVectorizer::new(\n            LayerLookups::new(),\n            AddressedValues(Vec::new()),\n            HashMap::new(),\n            Vec::new()\n        );\n        let mut op_names = LayerOps::new();\n        op_names.insert(\n            Layer::Token,\n            LayerOp::Embedding {\n                op: \"model/tokens\",\n                embed_op: \"model/token_embeds\",\n            },\n        );\n        op_names.insert(\n            Layer::Tag,\n            LayerOp::Embedding {\n                op: \"model/tags\",\n                embed_op: \"model/tag_embeds\",\n            },\n        );\n        op_names.insert(\n            Layer::DepRel,\n            LayerOp::Table {\n                op: \"model/deprels\",\n            },\n        );\n        op_names.insert(\n            Layer::Feature,\n            LayerOp::Table {\n                op: \"model/features\",\n            },\n        );\n        op_names.insert(\n            Layer::Char,\n            LayerOp::Embedding {\n                op: \"model/chars\",\n                embed_op: \"model/char_embeds\",\n            },\n        );\n        TensorflowModel::load_graph(&[], &data, system, vectorizer, &op_names)\n            .expect(\"Cannot load graph.\");\n"]]}
{"hexsha": "e7c71b95b528baf35e23a357ace4bcdd25f22836", "ext": "rs", "lang": "Rust", "content": "fn test_rol_zero_page_carry() {\n    let mut ram = Ram::new(1024);\n    ram.fill(vec![0x26, 0x02, 0x80], 0);\n    let mut cpu = MOS6502::new(ram);\n    cpu.set_flag(CARRY, true);\n    cpu.step();\n    assert_eq!(cpu.read(0x0002), 1);\n    assert_eq!(cpu.get_flag(CARRY), true);\n    assert_eq!(cpu.get_flag(ZERO), false);\n    assert_eq!(cpu.get_flag(SIGN), false);\n}", "item_id": 12, "repo": "rdeioris/impostor", "file": "src/mos6502/tests.rs", "last_update_at": "2019-06-19T22:47:34+00:00", "question_id": "e7c71b95b528baf35e23a357ace4bcdd25f22836_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_rol_zero_page_carry() {\n    let mut ram = Ram::new(1024);\n    ram.fill(vec![0x26, 0x02, 0x80], 0);\n    let mut cpu = MOS6502::new(ram);\n    cpu.set_flag(CARRY, true);\n    cpu.step();\n    assert_eq!(cpu.read(0x0002), 1);\n    assert_eq!(cpu.get_flag(CARRY), true);\n    assert_eq!(cpu.get_flag(ZERO), false);\n    assert_eq!(cpu.get_flag(SIGN), false);\n"]]}
{"hexsha": "23346562ba02b4c39ebc9fff19ce56e065849f7f", "ext": "rs", "lang": "Rust", "content": "unsafe fn unalign_slice(slice: &mut [u8]) -> &mut [u8] {\n    let ptr = slice.as_mut_ptr();\n    let offset_buffer = core::slice::from_raw_parts(ptr.offset(-2), 2);\n    let offset = read_u16(offset_buffer);\n    let orig_ptr = ptr.offset(-(offset as isize));\n    core::slice::from_raw_parts_mut(orig_ptr, slice.len() + offset as usize)\n}", "item_id": 1, "repo": "Richard-W/efw", "file": "src/allocator.rs", "last_update_at": "2019-04-21T07:51:14+00:00", "question_id": "23346562ba02b4c39ebc9fff19ce56e065849f7f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn unalign_slice(slice: &mut [u8]) -> &mut [u8] {\n    let ptr = slice.as_mut_ptr();\n    let offset_buffer = core::slice::from_raw_parts(ptr.offset(-2), 2);\n    let offset = read_u16(offset_buffer);\n    let orig_ptr = ptr.offset(-(offset as isize));\n    core::slice::from_raw_parts_mut(orig_ptr, slice.len() + offset as usize)\n"]]}
{"hexsha": "ca451efece603a7494b6d1e98cb568ca3ef3d174", "ext": "rs", "lang": "Rust", "content": "fn cipher_encrypt_ecb_invalid_data_size() {\n    let key_name = auto_test_keyname!();\n    let mut client = TestClient::new();\n\n    if !client.is_operation_supported(Opcode::PsaCipherEncrypt) {\n        return;\n    }\n\n    client\n        .import_aes_key_cipher(key_name.clone(), KEY_DATA.to_vec(), Cipher::EcbNoPadding)\n        .unwrap();\n\n    let invalid_plaintext = vec![0u8; INVALID_DATA_SIZE];\n\n    assert_eq!(\n        client\n            .cipher_encrypt_message(key_name, Cipher::EcbNoPadding, &invalid_plaintext[..])\n            .unwrap_err(),\n        ResponseStatus::PsaErrorInvalidArgument\n    );\n}", "item_id": 8, "repo": "paulhowardarm/parsec", "file": "e2e_tests/tests/per_provider/normal_tests/cipher.rs", "last_update_at": "2019-05-28T00:14:41+00:00", "question_id": "ca451efece603a7494b6d1e98cb568ca3ef3d174_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn cipher_encrypt_ecb_invalid_data_size() {\n    let key_name = auto_test_keyname!();\n    let mut client = TestClient::new();\n    if !client.is_operation_supported(Opcode::PsaCipherEncrypt) {\n        return;\n    }\n    client\n        .import_aes_key_cipher(key_name.clone(), KEY_DATA.to_vec(), Cipher::EcbNoPadding)\n        .unwrap();\n    let invalid_plaintext = vec![0u8; INVALID_DATA_SIZE];\n    assert_eq!(\n        client\n            .cipher_encrypt_message(key_name, Cipher::EcbNoPadding, &invalid_plaintext[..])\n            .unwrap_err(),\n        ResponseStatus::PsaErrorInvalidArgument\n    );\n"]]}
{"hexsha": "0d6ffc9b0cc03c08591f656a92233bcf1aca6fea", "ext": "rs", "lang": "Rust", "content": "fn parse_time_param(time: &str, mult_param: u64) -> Duration {\n    let re = Regex::new(r\"[0-9]+\").unwrap();\n    let time_parsed = re.find(time).unwrap();\n    Duration::new(time[time_parsed.start()..time_parsed.end()].parse::<u64>().unwrap()*mult_param,0)\n}", "item_id": 1, "repo": "marvintherain/file_age_tracker", "file": "src/main.rs", "last_update_at": "2019-11-09T20:11:03+00:00", "question_id": "0d6ffc9b0cc03c08591f656a92233bcf1aca6fea_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_time_param(time: &str, mult_param: u64) -> Duration {\n    let re = Regex::new(r\"[0-9]+\").unwrap();\n    let time_parsed = re.find(time).unwrap();\n    Duration::new(time[time_parsed.start()..time_parsed.end()].parse::<u64>().unwrap()*mult_param,0)\n"]]}
{"hexsha": "3b69d7c8b9787cb21010f351c85a54d8e9376ae1", "ext": "rs", "lang": "Rust", "content": "pub fn run() {\n    print!(\"Hello from print.rs: \");\n    println!(\"sponsored by the numbers {1:e} {0:010b}\", 42, 2);\n    println!(\"{name} is learning {language}\", name=\"James\", language=\"Rust\");\n}", "item_id": 0, "repo": "JamesMcGuigan/ecosystem-research", "file": "rust/rust-crash-course/src/print.rs", "last_update_at": "2019-01-01T02:04:27+00:00", "question_id": "3b69d7c8b9787cb21010f351c85a54d8e9376ae1_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn run() {\n    print!(\"Hello from print.rs: \");\n    println!(\"sponsored by the numbers {1:e} {0:010b}\", 42, 2);\n    println!(\"{name} is learning {language}\", name=\"James\", language=\"Rust\");\n"]]}
{"hexsha": "feefd8a0a21a9cfdbf9578926fbaebfe0518c14c", "ext": "rs", "lang": "Rust", "content": "fn test_ecp_mul_add() {\n        let mut group1 = EcGroup::new(EcGroupId::SecP256R1).unwrap();\n        let mut group2 = group1.clone();\n\n        let g = group1.generator().unwrap();\n\n        let k1 = Mpi::new(1212238156).unwrap();\n        let k2 = Mpi::new(1163020627).unwrap();\n\n        // Test that k1*g + k2*g == k2*g + k1*g\n        let pt1 = EcPoint::muladd(&mut group1, &g, &k2, &g, &k1).unwrap();\n        let pt2 = EcPoint::muladd(&mut group2, &g, &k1, &g, &k2).unwrap();\n        assert_eq!(pt1.eq(&pt2).unwrap(), true);\n\n        let pt3 = pt1.clone();\n        assert_eq!(pt2.eq(&pt3).unwrap(), true);\n    }", "item_id": 6, "repo": "lkatalin/mbedtls", "file": "src/ecp/mod.rs", "last_update_at": "2019-10-09T18:26:37+00:00", "question_id": "feefd8a0a21a9cfdbf9578926fbaebfe0518c14c_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_ecp_mul_add() {\n        let mut group1 = EcGroup::new(EcGroupId::SecP256R1).unwrap();\n        let mut group2 = group1.clone();\n        let g = group1.generator().unwrap();\n        let k1 = Mpi::new(1212238156).unwrap();\n        let k2 = Mpi::new(1163020627).unwrap();\n        // Test that k1*g + k2*g == k2*g + k1*g\n        let pt1 = EcPoint::muladd(&mut group1, &g, &k2, &g, &k1).unwrap();\n        let pt2 = EcPoint::muladd(&mut group2, &g, &k1, &g, &k2).unwrap();\n        assert_eq!(pt1.eq(&pt2).unwrap(), true);\n        let pt3 = pt1.clone();\n        assert_eq!(pt2.eq(&pt3).unwrap(), true);\n"]]}
{"hexsha": "dcf6af63c26c1d9a64727846887b2d85c665e24d", "ext": "rs", "lang": "Rust", "content": "pub fn split_odd_even(n: u64) -> (u64, u64) {\n\tlet mut even_power = 0;\n\tlet mut n_shift = n;\n\n\tloop {\n\t\tif n_shift & 1 == 0 {\n\t\t\teven_power += 1;\n\t\t\tn_shift = n_shift.rotate_right(1)\n\t\t} else {\n\t\t\treturn (n_shift, even_power)\n\t\t}\n\t}\n}", "item_id": 2, "repo": "VanLeeuwarden/modular_arithmetic", "file": "modular_arithmetic/src/functions.rs", "last_update_at": "2019-01-10T16:21:35+00:00", "question_id": "dcf6af63c26c1d9a64727846887b2d85c665e24d_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn split_odd_even(n: u64) -> (u64, u64) {\n\tlet mut even_power = 0;\n\tlet mut n_shift = n;\n\tloop {\n\t\tif n_shift & 1 == 0 {\n\t\t\teven_power += 1;\n\t\t\tn_shift = n_shift.rotate_right(1)\n\t\t} else {\n\t\t\treturn (n_shift, even_power)\n\t\t}\n\t}\n"]]}
{"hexsha": "0ee6bd124be69d29ecc638e42424432315dc1129", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut builtins = vec![\n        expr_decl!(Add as '+', #slots a b, |_, k| AstExpr::Add(k[0], k[1])),\n        expr_decl!(If as '?', #slots cond t f, |_, k| AstExpr::If(k[0], k[1], k[2])),\n        expr_decl!(True as 't', |_, _| AstExpr::Constant(Value::Bool(true))),\n        expr_decl!(False as 'f', |_, _| AstExpr::Constant(Value::Bool(false))),\n        expr_decl!(Repeat as '#', #slots count body, |_, k| AstExpr::Repeat(k[0], k[1])),\n    ];\n\n    let functions = vec![\n        func_decl! {\n            name \"Print\", symbol 'P', args 1,\n            type [ExprType::Int] => ExprType::Int,\n            type [ExprType::String] => ExprType::String,\n            type [ExprType::Bool] => ExprType::Bool,\n            |builder, store, children| {\n                let t = builder.build_instructions(store, children[0])?;\n                builder.push(Instruction::Print(t.into_value_type()));\n                Ok(t)\n            }\n        },\n        func_decl! {\n            name \"ReadLine\", symbol 'R', args 0,\n            type [] => ExprType::String,\n            |builder, _store, _children| {\n                builder.push(Instruction::ReadLine);\n                Ok(ExprType::String)\n            }\n        },\n        func_decl! {\n            name \"CompareLT\", symbol '<', args 2,\n            type [ExprType::Int, ExprType::Int] => ExprType::Bool,\n            |builder, store, children| {\n                use Instruction::*;\n                builder.build_instructions(store, children[0])?;\n                builder.build_instructions(store, children[1])?;\n                builder.push(SubInt);\n                builder.push(CompareZero(Ordering::Less));\n                builder.push(PushRegister(Register::Bool(0)));\n                Ok(ExprType::Bool)\n            }\n        },\n        func_decl! {\n            name \"CompareGT\", symbol '>', args 2,\n            type [ExprType::Int, ExprType::Int] => ExprType::Bool,\n            |builder, store, children| {\n                use Instruction::*;\n                builder.build_instructions(store, children[0])?;\n                builder.build_instructions(store, children[1])?;\n                builder.push(SubInt);\n                builder.push(CompareZero(Ordering::Greater));\n                builder.push(PushRegister(Register::Bool(0)));\n                Ok(ExprType::Bool)\n            }\n        },\n        func_decl! {\n            name \"Equal\", symbol '=', args 2,\n            type [ExprType::Int, ExprType::Int] => ExprType::Bool,\n            type [ExprType::String, ExprType::String] => ExprType::Bool,\n            type [ExprType::Bool, ExprType::Bool] => ExprType::Bool,\n            |builder, store, children| {\n                use Instruction::*;\n                builder.build_instructions(store, children[0])?;\n                let t = builder.build_instructions(store, children[1])?;\n                builder.push(CompareEqual(t.into_value_type()));\n                builder.push(PushRegister(Register::Bool(0)));\n                Ok(ExprType::Bool)\n            }\n        },\n        func_decl! {\n            name \"Void\", symbol 'V', args 0,\n            type [] => ExprType::Void,\n            |_builder, _store, _children| {\n                Ok(ExprType::Void)\n            }\n        },\n    ];\n\n    for func in functions {\n        let func = Rc::new(func);\n        builtins.push(ExprDecl {\n            name: func.name,\n            symbol: func.symbol,\n            shapes: vec![ExprShape {\n                slots: std::iter::repeat(ExprSlot::Value { name: \"\" })\n                    .take(func.param_count)\n                    .collect(),\n                build_expr: Box::new(move |_, k| AstExpr::CallBuiltin(func.clone(), k.into())),\n            }],\n        })\n    }\n\n    let mut parser = Parser::new();\n    let code = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| r#\"P\"Hello, world\"\"#.to_owned());\n    let context = ParserContext::new(builtins, &code);\n\n    let (res, total_time) = measure(|| -> VMResult<()> {\n        let (keys, parsing_time) = measure(|| parser.read_all_expressions(&context));\n\n        let keys = match keys {\n            Ok(keys) => keys,\n            Err(e) => {\n                println!(\n                    \"Error at position {}\",\n                    if let Some(p) = e.position {\n                        p.to_string()\n                    } else {\n                        \"EOF\".to_owned()\n                    }\n                );\n                println!(\"  {:?}\", e.reason);\n                return Ok(());\n            }\n        };\n\n        println!(\"Code: {}\", code);\n        println!(\"\\nParsing duration: {:?}\", parsing_time);\n        println!(\n            \"Ast:\\n{}\\n\",\n            keys.iter()\n                .map(|key| parser.ast_store.get(*key).print(&parser.ast_store, 0))\n                .join(\"\\n\")\n        );\n\n        let (res, bb_build_time) = measure(|| -> Result<_, Box<TypeError>> {\n            let mut blocks = BasicBlockBuilder::new();\n            keys.iter()\n                .try_for_each(|k| blocks.build_statement(&parser.ast_store, *k).map(|_| ()))?;\n            Ok(blocks.blocks)\n        });\n        let mut blocks = res?;\n\n        println!(\"BlockSet build duration: {:?}\", bb_build_time);\n        println!(\"BlockSet (unoptimized)\");\n        for (i, block) in blocks.iter().enumerate() {\n            println!(\"  #{} -> {:?}\", i, block.end);\n            for ins in &block.instructions {\n                println!(\"    {:?}\", ins);\n            }\n        }\n\n        let (_, optimize_time) = measure(|| {\n            remove_unnecessary_register_loads(&mut blocks);\n            remove_duplicates(&mut blocks);\n            remove_empty(&mut blocks);\n        });\n\n        println!(\"BlockSet optimization duration: {:?}\", optimize_time);\n        println!(\"BlockSet\");\n        for (i, block) in blocks.iter().enumerate() {\n            println!(\"  #{} -> {:?}\", i, block.end);\n            for ins in &block.instructions {\n                println!(\"    {:?}\", ins);\n            }\n        }\n\n        let (instructions, inst_build_time) =\n            measure(move || InstructionSetBuilder::from_bb(blocks).into_instructions());\n\n        println!(\"InstructionSet build duration: {:?}\", inst_build_time);\n        println!(\"InstructionSet\");\n        for (i, ins) in instructions.iter().enumerate() {\n            println!(\"  {:04}: {:?}\", i, ins);\n        }\n\n        println!(\"\\nExecution:\");\n        let mut vm = VM::<UncheckedValues>::new(instructions);\n        let (res, exec_time) = measure(|| {\n            vm.run(\n                std::env::args()\n                    .nth(2)\n                    .map(|x| x.chars().nth(0) == Some('y'))\n                    .unwrap_or(false),\n            )\n        });\n        res?;\n\n        println!(\"\\n\\nTrace:\");\n        for frame in &vm.stack_frames {\n            println!(\n                \"{: <3} {: <30} -> Int: {:?}, Bool: {:?}, String: {:?}, T: {:?}\",\n                frame.execution_pointer,\n                format!(\"{:?}\", &vm.instructions[frame.execution_pointer]),\n                frame.val_stack.int_values,\n                frame.val_stack.bool_values,\n                frame.val_stack.string_values,\n                frame.registers.bools,\n            );\n        }\n\n        println!(\"\\nInstructions executed:        {}\", vm.instruction_counter);\n        println!(\n            \"Execution duration:           {:?} ({:.3} ns/op)\",\n            exec_time,\n            exec_time.as_nanos() as f64 / vm.instruction_counter as f64\n        );\n        println!(\n            \"Total duration (excl. debug): {:?}\",\n            parsing_time + bb_build_time + optimize_time + inst_build_time + exec_time\n        );\n\n        Ok(())\n    });\n    match res.map_err(|v| *v) {\n        Ok(()) => {}\n        Err(VMError::IO(e)) => {\n            println!(\"IO error: {:?}\", e);\n        }\n        Err(VMError::TypeError(e)) => {\n            print_type_error(&code, &e);\n        }\n    }\n\n    println!(\"Total duration:               {:?}\", total_time);\n}", "item_id": 1, "repo": "JaniM/stgolf", "file": "src/main.rs", "last_update_at": "2019-08-02T05:25:58+00:00", "question_id": "0ee6bd124be69d29ecc638e42424432315dc1129_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let mut builtins = vec![\n        expr_decl!(Add as '+', #slots a b, |_, k| AstExpr::Add(k[0], k[1])),\n        expr_decl!(If as '?', #slots cond t f, |_, k| AstExpr::If(k[0], k[1], k[2])),\n        expr_decl!(True as 't', |_, _| AstExpr::Constant(Value::Bool(true))),\n        expr_decl!(False as 'f', |_, _| AstExpr::Constant(Value::Bool(false))),\n        expr_decl!(Repeat as '#', #slots count body, |_, k| AstExpr::Repeat(k[0], k[1])),\n    ];\n    let functions = vec![\n        func_decl! {\n            name \"Print\", symbol 'P', args 1,\n            type [ExprType::Int] => ExprType::Int,\n            type [ExprType::String] => ExprType::String,\n            type [ExprType::Bool] => ExprType::Bool,\n            |builder, store, children| {\n                let t = builder.build_instructions(store, children[0])?;\n                builder.push(Instruction::Print(t.into_value_type()));\n                Ok(t)\n            }\n        },\n        func_decl! {\n            name \"ReadLine\", symbol 'R', args 0,\n            type [] => ExprType::String,\n            |builder, _store, _children| {\n                builder.push(Instruction::ReadLine);\n                Ok(ExprType::String)\n            }\n        },\n        func_decl! {\n            name \"CompareLT\", symbol '<', args 2,\n            type [ExprType::Int, ExprType::Int] => ExprType::Bool,\n            |builder, store, children| {\n                use Instruction::*;\n                builder.build_instructions(store, children[0])?;\n                builder.build_instructions(store, children[1])?;\n                builder.push(SubInt);\n                builder.push(CompareZero(Ordering::Less));\n                builder.push(PushRegister(Register::Bool(0)));\n                Ok(ExprType::Bool)\n            }\n        },\n        func_decl! {\n            name \"CompareGT\", symbol '>', args 2,\n            type [ExprType::Int, ExprType::Int] => ExprType::Bool,\n            |builder, store, children| {\n                use Instruction::*;\n                builder.build_instructions(store, children[0])?;\n                builder.build_instructions(store, children[1])?;\n                builder.push(SubInt);\n                builder.push(CompareZero(Ordering::Greater));\n                builder.push(PushRegister(Register::Bool(0)));\n                Ok(ExprType::Bool)\n            }\n        },\n        func_decl! {\n            name \"Equal\", symbol '=', args 2,\n            type [ExprType::Int, ExprType::Int] => ExprType::Bool,\n            type [ExprType::String, ExprType::String] => ExprType::Bool,\n            type [ExprType::Bool, ExprType::Bool] => ExprType::Bool,\n            |builder, store, children| {\n                use Instruction::*;\n                builder.build_instructions(store, children[0])?;\n                let t = builder.build_instructions(store, children[1])?;\n                builder.push(CompareEqual(t.into_value_type()));\n                builder.push(PushRegister(Register::Bool(0)));\n                Ok(ExprType::Bool)\n            }\n        },\n        func_decl! {\n            name \"Void\", symbol 'V', args 0,\n            type [] => ExprType::Void,\n            |_builder, _store, _children| {\n                Ok(ExprType::Void)\n            }\n        },\n    ];\n    for func in functions {\n        let func = Rc::new(func);\n        builtins.push(ExprDecl {\n            name: func.name,\n            symbol: func.symbol,\n            shapes: vec![ExprShape {\n                slots: std::iter::repeat(ExprSlot::Value { name: \"\" })\n                    .take(func.param_count)\n                    .collect(),\n                build_expr: Box::new(move |_, k| AstExpr::CallBuiltin(func.clone(), k.into())),\n            }],\n        })\n    }\n    let mut parser = Parser::new();\n    let code = std::env::args()\n        .nth(1)\n        .unwrap_or_else(|| r#\"P\"Hello, world\"\"#.to_owned());\n    let context = ParserContext::new(builtins, &code);\n    let (res, total_time) = measure(|| -> VMResult<()> {\n        let (keys, parsing_time) = measure(|| parser.read_all_expressions(&context));\n        let keys = match keys {\n            Ok(keys) => keys,\n            Err(e) => {\n                println!(\n                    \"Error at position {}\",\n                    if let Some(p) = e.position {\n                        p.to_string()\n                    } else {\n                        \"EOF\".to_owned()\n                    }\n                );\n                println!(\"  {:?}\", e.reason);\n                return Ok(());\n            }\n        };\n        println!(\"Code: {}\", code);\n        println!(\"\\nParsing duration: {:?}\", parsing_time);\n        println!(\n            \"Ast:\\n{}\\n\",\n            keys.iter()\n                .map(|key| parser.ast_store.get(*key).print(&parser.ast_store, 0))\n                .join(\"\\n\")\n        );\n        let (res, bb_build_time) = measure(|| -> Result<_, Box<TypeError>> {\n            let mut blocks = BasicBlockBuilder::new();\n            keys.iter()\n                .try_for_each(|k| blocks.build_statement(&parser.ast_store, *k).map(|_| ()))?;\n            Ok(blocks.blocks)\n        });\n        let mut blocks = res?;\n        println!(\"BlockSet build duration: {:?}\", bb_build_time);\n        println!(\"BlockSet (unoptimized)\");\n        for (i, block) in blocks.iter().enumerate() {\n            println!(\"  #{} -> {:?}\", i, block.end);\n            for ins in &block.instructions {\n                println!(\"    {:?}\", ins);\n            }\n        }\n        let (_, optimize_time) = measure(|| {\n            remove_unnecessary_register_loads(&mut blocks);\n            remove_duplicates(&mut blocks);\n            remove_empty(&mut blocks);\n        });\n        println!(\"BlockSet optimization duration: {:?}\", optimize_time);\n        println!(\"BlockSet\");\n        for (i, block) in blocks.iter().enumerate() {\n            println!(\"  #{} -> {:?}\", i, block.end);\n            for ins in &block.instructions {\n                println!(\"    {:?}\", ins);\n            }\n        }\n        let (instructions, inst_build_time) =\n            measure(move || InstructionSetBuilder::from_bb(blocks).into_instructions());\n        println!(\"InstructionSet build duration: {:?}\", inst_build_time);\n        println!(\"InstructionSet\");\n        for (i, ins) in instructions.iter().enumerate() {\n            println!(\"  {:04}: {:?}\", i, ins);\n        }\n        println!(\"\\nExecution:\");\n        let mut vm = VM::<UncheckedValues>::new(instructions);\n        let (res, exec_time) = measure(|| {\n            vm.run(\n                std::env::args()\n                    .nth(2)\n                    .map(|x| x.chars().nth(0) == Some('y'))\n                    .unwrap_or(false),\n            )\n        });\n        res?;\n        println!(\"\\n\\nTrace:\");\n        for frame in &vm.stack_frames {\n            println!(\n                \"{: <3} {: <30} -> Int: {:?}, Bool: {:?}, String: {:?}, T: {:?}\",\n                frame.execution_pointer,\n                format!(\"{:?}\", &vm.instructions[frame.execution_pointer]),\n                frame.val_stack.int_values,\n                frame.val_stack.bool_values,\n                frame.val_stack.string_values,\n                frame.registers.bools,\n            );\n        }\n        println!(\"\\nInstructions executed:        {}\", vm.instruction_counter);\n        println!(\n            \"Execution duration:           {:?} ({:.3} ns/op)\",\n            exec_time,\n            exec_time.as_nanos() as f64 / vm.instruction_counter as f64\n        );\n        println!(\n            \"Total duration (excl. debug): {:?}\",\n            parsing_time + bb_build_time + optimize_time + inst_build_time + exec_time\n        );\n        Ok(())\n    });\n    match res.map_err(|v| *v) {\n        Ok(()) => {}\n        Err(VMError::IO(e)) => {\n            println!(\"IO error: {:?}\", e);\n        }\n        Err(VMError::TypeError(e)) => {\n            print_type_error(&code, &e);\n        }\n    }\n    println!(\"Total duration:               {:?}\", total_time);\n"]]}
{"hexsha": "655d82be0bf7ebbe15359c10e8e19cc6beaf60ff", "ext": "rs", "lang": "Rust", "content": "fn keep_inhabited_variant(_self: &syn::Ident, variant: syn::Variant)\n    -> Option<(u32, syn::Ident, Vec<syn::Field>, ParsedAttributes)>\n{\n    use void::IsUninhabited;\n\n    let attrs = parse_attributes(variant.attrs);\n    let fields = variant_data_to_fields(variant.data);\n\n    if attrs.skip {\n        // We've been ordered to skip this variant!\n        // Check that all other attributes are not set.\n        ensure_has_only_skip_attr(attrs, error::ENUM_VARIANT);\n        fields.into_iter().for_each(|field| {\n            let f_attrs = parse_attributes(field.attrs);\n            error::if_skip_present(&f_attrs, error::ENUM_VARIANT_FIELD);\n            ensure_has_only_skip_attr(f_attrs, error::ENUM_VARIANT_FIELD);\n        });\n\n        return None\n    }\n\n    // If the variant is uninhabited, we can't generate it, so skip it.\n    if (&*fields).is_uninhabited() { return None }\n\n    // Compute the weight:\n    let weight = attrs.weight.unwrap_or(1);\n\n    Some((weight, variant.ident, fields, attrs))\n}", "item_id": 7, "repo": "Centril/proptest-derive", "file": "src/derive.rs", "last_update_at": "2019-02-23T12:46:33+00:00", "question_id": "655d82be0bf7ebbe15359c10e8e19cc6beaf60ff_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn keep_inhabited_variant(_self: &syn::Ident, variant: syn::Variant)\n    -> Option<(u32, syn::Ident, Vec<syn::Field>, ParsedAttributes)>\n{\n    use void::IsUninhabited;\n    let attrs = parse_attributes(variant.attrs);\n    let fields = variant_data_to_fields(variant.data);\n    if attrs.skip {\n        // We've been ordered to skip this variant!\n        // Check that all other attributes are not set.\n        ensure_has_only_skip_attr(attrs, error::ENUM_VARIANT);\n        fields.into_iter().for_each(|field| {\n            let f_attrs = parse_attributes(field.attrs);\n            error::if_skip_present(&f_attrs, error::ENUM_VARIANT_FIELD);\n            ensure_has_only_skip_attr(f_attrs, error::ENUM_VARIANT_FIELD);\n        });\n        return None\n    }\n    // If the variant is uninhabited, we can't generate it, so skip it.\n    if (&*fields).is_uninhabited() { return None }\n    // Compute the weight:\n    let weight = attrs.weight.unwrap_or(1);\n    Some((weight, variant.ident, fields, attrs))\n"]]}
{"hexsha": "6294c5752e18359c58f9cb995f0587e746d15dbd", "ext": "rs", "lang": "Rust", "content": "pub fn commit_at(ptr: Address, size: usize, executable: bool) {\n    debug_assert!(ptr.is_page_aligned());\n    debug_assert!(mem::is_page_aligned(size));\n\n    use winapi::um::memoryapi::VirtualAlloc;\n    use winapi::um::winnt::{MEM_COMMIT, PAGE_EXECUTE_READWRITE, PAGE_READWRITE};\n\n    let prot = if executable {\n        PAGE_EXECUTE_READWRITE\n    } else {\n        PAGE_READWRITE\n    };\n\n    let result = unsafe { VirtualAlloc(ptr.to_mut_ptr(), size, MEM_COMMIT, prot) };\n\n    if result != ptr.to_mut_ptr() {\n        panic!(\"VirtualAlloc failed\");\n    }\n}", "item_id": 8, "repo": "ashwanidausodia/dora", "file": "dora/src/os/allocator.rs", "last_update_at": "2019-03-22T22:25:17+00:00", "question_id": "6294c5752e18359c58f9cb995f0587e746d15dbd_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn commit_at(ptr: Address, size: usize, executable: bool) {\n    debug_assert!(ptr.is_page_aligned());\n    debug_assert!(mem::is_page_aligned(size));\n    use winapi::um::memoryapi::VirtualAlloc;\n    use winapi::um::winnt::{MEM_COMMIT, PAGE_EXECUTE_READWRITE, PAGE_READWRITE};\n    let prot = if executable {\n        PAGE_EXECUTE_READWRITE\n    } else {\n        PAGE_READWRITE\n    };\n    let result = unsafe { VirtualAlloc(ptr.to_mut_ptr(), size, MEM_COMMIT, prot) };\n    if result != ptr.to_mut_ptr() {\n        panic!(\"VirtualAlloc failed\");\n    }\n"]]}
{"hexsha": "efe145d6a2d9d1af77e27122a4c7ea32df3fcd27", "ext": "rs", "lang": "Rust", "content": "pub fn fiat_p384_addcarryx_u32(out1: &mut u32, out2: &mut fiat_p384_u1, arg1: fiat_p384_u1, arg2: u32, arg3: u32) -> () {\n  let x1: u64 = (((arg1 as u64) + (arg2 as u64)) + (arg3 as u64));\n  let x2: u32 = ((x1 & (0xffffffff as u64)) as u32);\n  let x3: fiat_p384_u1 = ((x1 >> 32) as fiat_p384_u1);\n  *out1 = x2;\n  *out2 = x3;\n}", "item_id": 0, "repo": "babylouie28/fiat-crypto", "file": "fiat-rust/src/p384_32.rs", "last_update_at": "2019-12-06T04:56:25+00:00", "question_id": "efe145d6a2d9d1af77e27122a4c7ea32df3fcd27_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn fiat_p384_addcarryx_u32(out1: &mut u32, out2: &mut fiat_p384_u1, arg1: fiat_p384_u1, arg2: u32, arg3: u32) -> () {\n  let x1: u64 = (((arg1 as u64) + (arg2 as u64)) + (arg3 as u64));\n  let x2: u32 = ((x1 & (0xffffffff as u64)) as u32);\n  let x3: fiat_p384_u1 = ((x1 >> 32) as fiat_p384_u1);\n  *out1 = x2;\n  *out2 = x3;\n"]]}
{"hexsha": "332db6f049736fc458aa677ffa25250a36f1c7ea", "ext": "rs", "lang": "Rust", "content": "unsafe fn mailmime_id_write_driver(\n    mut do_write: Option<\n        unsafe fn(_: *mut libc::c_void, _: *const libc::c_char, _: size_t) -> libc::c_int,\n    >,\n    mut data: *mut libc::c_void,\n    mut col: *mut libc::c_int,\n    mut id: *mut libc::c_char,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    r = mailimf_string_write_driver(\n        do_write,\n        data,\n        col,\n        b\"Content-ID: \\x00\" as *const u8 as *const libc::c_char,\n        12i32 as size_t,\n    );\n    if r != MAILIMF_NO_ERROR as libc::c_int {\n        return r;\n    }\n    r = mailimf_string_write_driver(\n        do_write,\n        data,\n        col,\n        b\"<\\x00\" as *const u8 as *const libc::c_char,\n        1i32 as size_t,\n    );\n    if r != MAILIMF_NO_ERROR as libc::c_int {\n        return r;\n    }\n    r = mailimf_string_write_driver(do_write, data, col, id, strlen(id));\n    if r != MAILIMF_NO_ERROR as libc::c_int {\n        return r;\n    }\n    r = mailimf_string_write_driver(\n        do_write,\n        data,\n        col,\n        b\">\\x00\" as *const u8 as *const libc::c_char,\n        1i32 as size_t,\n    );\n    if r != MAILIMF_NO_ERROR as libc::c_int {\n        return r;\n    }\n    r = mailimf_string_write_driver(\n        do_write,\n        data,\n        col,\n        b\"\\r\\n\\x00\" as *const u8 as *const libc::c_char,\n        2i32 as size_t,\n    );\n    if r != MAILIMF_NO_ERROR as libc::c_int {\n        return r;\n    }\n    return MAILIMF_NO_ERROR as libc::c_int;\n}", "item_id": 9, "repo": "KAction/mmime", "file": "src/mailmime_write_generic.rs", "last_update_at": "2019-09-16T15:25:05+00:00", "question_id": "332db6f049736fc458aa677ffa25250a36f1c7ea_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn mailmime_id_write_driver(\n    mut do_write: Option<\n        unsafe fn(_: *mut libc::c_void, _: *const libc::c_char, _: size_t) -> libc::c_int,\n    >,\n    mut data: *mut libc::c_void,\n    mut col: *mut libc::c_int,\n    mut id: *mut libc::c_char,\n) -> libc::c_int {\n    let mut r: libc::c_int = 0;\n    r = mailimf_string_write_driver(\n        do_write,\n        data,\n        col,\n        b\"Content-ID: \\x00\" as *const u8 as *const libc::c_char,\n        12i32 as size_t,\n    );\n    if r != MAILIMF_NO_ERROR as libc::c_int {\n        return r;\n    }\n    r = mailimf_string_write_driver(\n        do_write,\n        data,\n        col,\n        b\"<\\x00\" as *const u8 as *const libc::c_char,\n        1i32 as size_t,\n    );\n    if r != MAILIMF_NO_ERROR as libc::c_int {\n        return r;\n    }\n    r = mailimf_string_write_driver(do_write, data, col, id, strlen(id));\n    if r != MAILIMF_NO_ERROR as libc::c_int {\n        return r;\n    }\n    r = mailimf_string_write_driver(\n        do_write,\n        data,\n        col,\n        b\">\\x00\" as *const u8 as *const libc::c_char,\n        1i32 as size_t,\n    );\n    if r != MAILIMF_NO_ERROR as libc::c_int {\n        return r;\n    }\n    r = mailimf_string_write_driver(\n        do_write,\n        data,\n        col,\n        b\"\\r\\n\\x00\" as *const u8 as *const libc::c_char,\n        2i32 as size_t,\n    );\n    if r != MAILIMF_NO_ERROR as libc::c_int {\n        return r;\n    }\n    return MAILIMF_NO_ERROR as libc::c_int;\n"]]}
{"hexsha": "99a092f8c4cb9df6e0904979a07d187bf51da5de", "ext": "rs", "lang": "Rust", "content": "fn compress_decompress() {\n    let source = vec![0,1,2,4, 100, 123412, 1543245423];\n    let compressed = Compressed::from(source.iter().map(|&x|x));\n    let decompressor = compressed.decompress();\n    let result = decompressor.collect::<Vec<_>>();\n    assert_eq!(result, source);\n}", "item_id": 0, "repo": "frankmcsherry/graph-layout", "file": "tests/tests.rs", "last_update_at": "2019-03-26T22:46:47+00:00", "question_id": "99a092f8c4cb9df6e0904979a07d187bf51da5de_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn compress_decompress() {\n    let source = vec![0,1,2,4, 100, 123412, 1543245423];\n    let compressed = Compressed::from(source.iter().map(|&x|x));\n    let decompressor = compressed.decompress();\n    let result = decompressor.collect::<Vec<_>>();\n    assert_eq!(result, source);\n"]]}
{"hexsha": "63c03229343ca2d9c2ae27790dbf3c681fde5aad", "ext": "rs", "lang": "Rust", "content": "fn test_parse_comment_and_text() {\n    SETUP_READER!(\n        reader,\n        \"// Hello world\nCiao mondo\"\n    );\n\n    assert_eq!(reader.lines.len(), 2);\n\n    assert_eq!(reader.lines[0].type_, LineType::Comment);\n    assert_eq!(reader.lines[1].type_, LineType::Text);\n}", "item_id": 18, "repo": "Pomettini/visual-novel-text-baker", "file": "tests/reader_tests.rs", "last_update_at": "2019-09-29T16:27:31+00:00", "question_id": "63c03229343ca2d9c2ae27790dbf3c681fde5aad_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_parse_comment_and_text() {\n    SETUP_READER!(\n        reader,\n        \"// Hello world\nCiao mondo\"\n    );\n    assert_eq!(reader.lines.len(), 2);\n    assert_eq!(reader.lines[0].type_, LineType::Comment);\n    assert_eq!(reader.lines[1].type_, LineType::Text);\n"]]}
{"hexsha": "99ec1b268c51c3421dd383fb23681b4c110262f0", "ext": "rs", "lang": "Rust", "content": "fn make_qualified_name(s: State, arg0 : Self::R) -> (State, Self::R) {\n        let s = State::next(s, &[&arg0]);\n        let r = Self::R::make_qualified_name(&s, arg0);\n        (s, r)\n    }", "item_id": 2, "repo": "jeffomatic/hhvm", "file": "hphp/hack/src/parser/syntax_smart_constructors_generated.rs", "last_update_at": "2019-07-21T09:08:35+00:00", "question_id": "99ec1b268c51c3421dd383fb23681b4c110262f0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn make_qualified_name(s: State, arg0 : Self::R) -> (State, Self::R) {\n        let s = State::next(s, &[&arg0]);\n        let r = Self::R::make_qualified_name(&s, arg0);\n        (s, r)\n"]]}
{"hexsha": "dc94ca414ec24537d2f06e7bb0d3e640fa8d32ce", "ext": "rs", "lang": "Rust", "content": "fn check_accumulator_op(\n            state: &mut ComputerState,\n            operation: Operation,\n            initial_value: Option<u8>,\n            operand_value: Option<u8>,\n            expected_value: u8,\n            expected_flags: Vec<StatusFlag>,\n        ) {\n            match initial_value {\n                Some(value) => state.registers.accumulator = value,\n                None => (),\n            };\n\n            let operand = match operand_value {\n                Some(val) => Operand::Immediate(val),\n                None => Operand::Accumulator,\n            };\n\n            state.execute_operation(operation, operand).unwrap();\n            assert_eq!(state.registers.accumulator, expected_value);\n            check_status_flags(&state, &expected_flags);\n        }", "item_id": 3, "repo": "lvdr/nestegg", "file": "src/lib.rs", "last_update_at": "2019-09-03T16:34:10+00:00", "question_id": "dc94ca414ec24537d2f06e7bb0d3e640fa8d32ce_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn check_accumulator_op(\n            state: &mut ComputerState,\n            operation: Operation,\n            initial_value: Option<u8>,\n            operand_value: Option<u8>,\n            expected_value: u8,\n            expected_flags: Vec<StatusFlag>,\n        ) {\n            match initial_value {\n                Some(value) => state.registers.accumulator = value,\n                None => (),\n            };\n            let operand = match operand_value {\n                Some(val) => Operand::Immediate(val),\n                None => Operand::Accumulator,\n            };\n            state.execute_operation(operation, operand).unwrap();\n            assert_eq!(state.registers.accumulator, expected_value);\n            check_status_flags(&state, &expected_flags);\n"]]}
{"hexsha": "ada541d03d501f3f49006046587dfaeaa1e3f73b", "ext": "rs", "lang": "Rust", "content": "fn lcm(v1: usize, v2: usize) -> usize {\n    v1 * v2 / gcd(v1, v2)\n    // while v1 != 0 {\n    //     let old_v1 = v1;\n    //     v1 = v2 % v1;\n    //     v2 = old_v1;\n    // }\n    // v2\n}", "item_id": 4, "repo": "HaronK/aoc2019", "file": "task12_1/src/main.rs", "last_update_at": "2019-12-12T13:11:51+00:00", "question_id": "ada541d03d501f3f49006046587dfaeaa1e3f73b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn lcm(v1: usize, v2: usize) -> usize {\n    v1 * v2 / gcd(v1, v2)\n    // while v1 != 0 {\n    //     let old_v1 = v1;\n    //     v1 = v2 % v1;\n    //     v2 = old_v1;\n    // }\n    // v2\n"]]}
{"hexsha": "3deac005077f7c70c346c676b2f9596a2b4440d9", "ext": "rs", "lang": "Rust", "content": "fn difference_with_a_lhs_json_value() {\n        let expected = expected_values(\n            r#\"SELECT \"users\".* FROM \"users\" WHERE $1 <> \"jsonField\"::jsonb\"#,\n            vec![serde_json::json!({\"a\": \"b\"})],\n        );\n\n        let value_expr: Expression = Value::json(serde_json::json!({\"a\":\"b\"})).into();\n        let query = Select::from_table(\"users\").so_that(value_expr.not_equals(Column::from(\"jsonField\")));\n        let (sql, params) = Postgres::build(query).unwrap();\n\n        assert_eq!(expected.0, sql);\n        assert_eq!(expected.1, params);\n    }", "item_id": 18, "repo": "prisma/prisma-query", "file": "src/visitor/postgres.rs", "last_update_at": "2019-11-02T17:23:18+00:00", "question_id": "3deac005077f7c70c346c676b2f9596a2b4440d9_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn difference_with_a_lhs_json_value() {\n        let expected = expected_values(\n            r#\"SELECT \"users\".* FROM \"users\" WHERE $1 <> \"jsonField\"::jsonb\"#,\n            vec![serde_json::json!({\"a\": \"b\"})],\n        );\n        let value_expr: Expression = Value::json(serde_json::json!({\"a\":\"b\"})).into();\n        let query = Select::from_table(\"users\").so_that(value_expr.not_equals(Column::from(\"jsonField\")));\n        let (sql, params) = Postgres::build(query).unwrap();\n        assert_eq!(expected.0, sql);\n        assert_eq!(expected.1, params);\n"]]}
{"hexsha": "382aead3de860442cd78c6d05287f34dd63c6f9c", "ext": "rs", "lang": "Rust", "content": "fn test_canvas_passing_syntax() {\n    use crate::utils::new_null_canvas;\n    use crate::Surface;\n\n    let mut null_canvas = new_null_canvas();\n    let view = View3D::default();\n    // as mutable reference\n    view.apply_to_canvas(&mut null_canvas);\n    // moved\n    view.apply_to_canvas(null_canvas);\n\n    // and one with a mutable reference to a shared Canvas:\n    let mut surface = Surface::new_raster_n32_premul((100, 100)).unwrap();\n    view.apply_to_canvas(surface.canvas());\n}", "item_id": 0, "repo": "ostera/rust-skia", "file": "skia-safe/src/utils/camera.rs", "last_update_at": "2019-06-22T23:21:10+00:00", "question_id": "382aead3de860442cd78c6d05287f34dd63c6f9c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_canvas_passing_syntax() {\n    use crate::utils::new_null_canvas;\n    use crate::Surface;\n    let mut null_canvas = new_null_canvas();\n    let view = View3D::default();\n    // as mutable reference\n    view.apply_to_canvas(&mut null_canvas);\n    // moved\n    view.apply_to_canvas(null_canvas);\n    // and one with a mutable reference to a shared Canvas:\n    let mut surface = Surface::new_raster_n32_premul((100, 100)).unwrap();\n    view.apply_to_canvas(surface.canvas());\n"]]}
{"hexsha": "c1e9fc9d50b4c9a0d563639e4f4cf3b1e87754fd", "ext": "rs", "lang": "Rust", "content": "fn init() {\n    let vec = new_empty_vec::<i32>();\n    assert_eq!(vec.len(), 0);\n    assert_eq!(vec.is_empty(), true);\n    assert_eq!(vec.iter().next(), None);\n}", "item_id": 1, "repo": "OIEIEIO/ink", "file": "core/src/storage/collections/vec/tests.rs", "last_update_at": "2019-11-18T11:03:09+00:00", "question_id": "c1e9fc9d50b4c9a0d563639e4f4cf3b1e87754fd_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn init() {\n    let vec = new_empty_vec::<i32>();\n    assert_eq!(vec.len(), 0);\n    assert_eq!(vec.is_empty(), true);\n    assert_eq!(vec.iter().next(), None);\n"]]}
{"hexsha": "f07fbe0fa8f606927d7cf56e306c4f3bee05d7b9", "ext": "rs", "lang": "Rust", "content": "fn can_parse_command_statement_with_empty_tuple_parameter() {\n        let statement   = \"some-command ()\";\n        let parsed      = parse(statement);\n\n        assert!(parsed.is_ok());\n\n        let result = parsed.unwrap();\n        assert!(result.len() == 1);\n\n        let ref cmd = result[0];\n        assert!(match applies_to(cmd) { Some((Expression::Identifier(_), Expression::Tuple(_))) => true, _ => false });\n    }", "item_id": 18, "repo": "Logicalshift/gossyp", "file": "gossyp_lang/src/script/parse_script_tool.rs", "last_update_at": "2019-04-16T19:55:25+00:00", "question_id": "f07fbe0fa8f606927d7cf56e306c4f3bee05d7b9_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn can_parse_command_statement_with_empty_tuple_parameter() {\n        let statement   = \"some-command ()\";\n        let parsed      = parse(statement);\n        assert!(parsed.is_ok());\n        let result = parsed.unwrap();\n        assert!(result.len() == 1);\n        let ref cmd = result[0];\n        assert!(match applies_to(cmd) { Some((Expression::Identifier(_), Expression::Tuple(_))) => true, _ => false });\n"]]}
{"hexsha": "983199c8fd73bfa4646d6f830a2d2bf49d343f56", "ext": "rs", "lang": "Rust", "content": "fn prepare_integration_test(code: &str, filename: &str) -> (Connection, StoppableHandle<()>) {\n    let (server, client) = Connection::memory();\n\n    // Manually handle LSP communications here. This is needed in order to not wait\n    // indefinetely for a message to be able to exit as soon as the test is finished\n    // and the thread is stopped.\n    let h = spawn(move |stopped| {\n        let mut app = App { files: HashMap::new(), conn: server };\n\n        loop {\n            if let Ok(msg) = app.conn.receiver.recv_timeout(Duration::from_millis(100)) {\n                match msg {\n                    Message::Request(req) => app.handle_request(req),\n                    Message::Notification(notification) => {\n                        let _ = app.handle_notification(notification);\n                    }\n                    Message::Response(_) => (),\n                }\n            }\n            if stopped.get() {\n                break;\n            }\n        }\n    });\n\n    let open = Notification {\n        method: String::from(\"textDocument/didOpen\"),\n        params: json!({\n            \"textDocument\": { \"uri\": filename, \"text\": code, \"version\": 1, \"languageId\": \"nix\" }\n        })\n    };\n    client.sender.send(open.into()).expect(\"Cannot send didOpen!\");\n\n    (client, h)\n}", "item_id": 1, "repo": "jD91mZM2/rnix-lsp", "file": "src/tests.rs", "last_update_at": "2019-01-21T17:10:35+00:00", "question_id": "983199c8fd73bfa4646d6f830a2d2bf49d343f56_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn prepare_integration_test(code: &str, filename: &str) -> (Connection, StoppableHandle<()>) {\n    let (server, client) = Connection::memory();\n    // Manually handle LSP communications here. This is needed in order to not wait\n    // indefinetely for a message to be able to exit as soon as the test is finished\n    // and the thread is stopped.\n    let h = spawn(move |stopped| {\n        let mut app = App { files: HashMap::new(), conn: server };\n        loop {\n            if let Ok(msg) = app.conn.receiver.recv_timeout(Duration::from_millis(100)) {\n                match msg {\n                    Message::Request(req) => app.handle_request(req),\n                    Message::Notification(notification) => {\n                        let _ = app.handle_notification(notification);\n                    }\n                    Message::Response(_) => (),\n                }\n            }\n            if stopped.get() {\n                break;\n            }\n        }\n    });\n    let open = Notification {\n        method: String::from(\"textDocument/didOpen\"),\n        params: json!({\n            \"textDocument\": { \"uri\": filename, \"text\": code, \"version\": 1, \"languageId\": \"nix\" }\n        })\n    };\n    client.sender.send(open.into()).expect(\"Cannot send didOpen!\");\n    (client, h)\n"]]}
{"hexsha": "8a85ec39c4873751b0aee8e0beea8647338a30fb", "ext": "rs", "lang": "Rust", "content": "fn decrypt_server_initial_draft28() {\n        let mut pkt = [\n            0xc9, 0xff, 0x00, 0x00, 0x1c, 0x00, 0x08, 0xf0, 0x67, 0xa5, 0x50,\n            0x2a, 0x42, 0x62, 0xb5, 0x00, 0x40, 0x74, 0x16, 0x8b, 0xf2, 0x2b,\n            0x70, 0x02, 0x59, 0x6f, 0x99, 0xae, 0x67, 0xab, 0xf6, 0x5a, 0x58,\n            0x52, 0xf5, 0x4f, 0x58, 0xc3, 0x7c, 0x80, 0x86, 0x82, 0xe2, 0xe4,\n            0x04, 0x92, 0xd8, 0xa3, 0x89, 0x9f, 0xb0, 0x4f, 0xc0, 0xaf, 0xe9,\n            0xaa, 0xbc, 0x87, 0x67, 0xb1, 0x8a, 0x0a, 0xa4, 0x93, 0x53, 0x74,\n            0x26, 0x37, 0x3b, 0x48, 0xd5, 0x02, 0x21, 0x4d, 0xd8, 0x56, 0xd6,\n            0x3b, 0x78, 0xce, 0xe3, 0x7b, 0xc6, 0x64, 0xb3, 0xfe, 0x86, 0xd4,\n            0x87, 0xac, 0x7a, 0x77, 0xc5, 0x30, 0x38, 0xa3, 0xcd, 0x32, 0xf0,\n            0xb5, 0x00, 0x4d, 0x9f, 0x57, 0x54, 0xc4, 0xf7, 0xf2, 0xd1, 0xf3,\n            0x5c, 0xf3, 0xf7, 0x11, 0x63, 0x51, 0xc9, 0x2b, 0xda, 0x5b, 0x23,\n            0xc8, 0x10, 0x34, 0xab, 0x74, 0xf5, 0x4c, 0xb1, 0xbd, 0x72, 0x95,\n            0x12, 0x56,\n        ];\n\n        let dcid = [0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08];\n\n        let frames = [\n            0x0d, 0x00, 0x00, 0x00, 0x00, 0x18, 0x41, 0x0a, 0x02, 0x00, 0x00,\n            0x56, 0x03, 0x03, 0xee, 0xfc, 0xe7, 0xf7, 0xb3, 0x7b, 0xa1, 0xd1,\n            0x63, 0x2e, 0x96, 0x67, 0x78, 0x25, 0xdd, 0xf7, 0x39, 0x88, 0xcf,\n            0xc7, 0x98, 0x25, 0xdf, 0x56, 0x6d, 0xc5, 0x43, 0x0b, 0x9a, 0x04,\n            0x5a, 0x12, 0x00, 0x13, 0x01, 0x00, 0x00, 0x2e, 0x00, 0x33, 0x00,\n            0x24, 0x00, 0x1d, 0x00, 0x20, 0x9d, 0x3c, 0x94, 0x0d, 0x89, 0x69,\n            0x0b, 0x84, 0xd0, 0x8a, 0x60, 0x99, 0x3c, 0x14, 0x4e, 0xca, 0x68,\n            0x4d, 0x10, 0x81, 0x28, 0x7c, 0x83, 0x4d, 0x53, 0x11, 0xbc, 0xf3,\n            0x2b, 0xb9, 0xda, 0x1a, 0x00, 0x2b, 0x00, 0x02, 0x03, 0x04,\n        ];\n\n        assert_decrypt_initial_pkt(&mut pkt, &dcid, false, &frames, 1, 2);\n    }", "item_id": 24, "repo": "kckeiks/quiche", "file": "quiche/src/packet.rs", "last_update_at": "2019-01-16T08:10:40+00:00", "question_id": "8a85ec39c4873751b0aee8e0beea8647338a30fb_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn decrypt_server_initial_draft28() {\n        let mut pkt = [\n            0xc9, 0xff, 0x00, 0x00, 0x1c, 0x00, 0x08, 0xf0, 0x67, 0xa5, 0x50,\n            0x2a, 0x42, 0x62, 0xb5, 0x00, 0x40, 0x74, 0x16, 0x8b, 0xf2, 0x2b,\n            0x70, 0x02, 0x59, 0x6f, 0x99, 0xae, 0x67, 0xab, 0xf6, 0x5a, 0x58,\n            0x52, 0xf5, 0x4f, 0x58, 0xc3, 0x7c, 0x80, 0x86, 0x82, 0xe2, 0xe4,\n            0x04, 0x92, 0xd8, 0xa3, 0x89, 0x9f, 0xb0, 0x4f, 0xc0, 0xaf, 0xe9,\n            0xaa, 0xbc, 0x87, 0x67, 0xb1, 0x8a, 0x0a, 0xa4, 0x93, 0x53, 0x74,\n            0x26, 0x37, 0x3b, 0x48, 0xd5, 0x02, 0x21, 0x4d, 0xd8, 0x56, 0xd6,\n            0x3b, 0x78, 0xce, 0xe3, 0x7b, 0xc6, 0x64, 0xb3, 0xfe, 0x86, 0xd4,\n            0x87, 0xac, 0x7a, 0x77, 0xc5, 0x30, 0x38, 0xa3, 0xcd, 0x32, 0xf0,\n            0xb5, 0x00, 0x4d, 0x9f, 0x57, 0x54, 0xc4, 0xf7, 0xf2, 0xd1, 0xf3,\n            0x5c, 0xf3, 0xf7, 0x11, 0x63, 0x51, 0xc9, 0x2b, 0xda, 0x5b, 0x23,\n            0xc8, 0x10, 0x34, 0xab, 0x74, 0xf5, 0x4c, 0xb1, 0xbd, 0x72, 0x95,\n            0x12, 0x56,\n        ];\n        let dcid = [0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08];\n        let frames = [\n            0x0d, 0x00, 0x00, 0x00, 0x00, 0x18, 0x41, 0x0a, 0x02, 0x00, 0x00,\n            0x56, 0x03, 0x03, 0xee, 0xfc, 0xe7, 0xf7, 0xb3, 0x7b, 0xa1, 0xd1,\n            0x63, 0x2e, 0x96, 0x67, 0x78, 0x25, 0xdd, 0xf7, 0x39, 0x88, 0xcf,\n            0xc7, 0x98, 0x25, 0xdf, 0x56, 0x6d, 0xc5, 0x43, 0x0b, 0x9a, 0x04,\n            0x5a, 0x12, 0x00, 0x13, 0x01, 0x00, 0x00, 0x2e, 0x00, 0x33, 0x00,\n            0x24, 0x00, 0x1d, 0x00, 0x20, 0x9d, 0x3c, 0x94, 0x0d, 0x89, 0x69,\n            0x0b, 0x84, 0xd0, 0x8a, 0x60, 0x99, 0x3c, 0x14, 0x4e, 0xca, 0x68,\n            0x4d, 0x10, 0x81, 0x28, 0x7c, 0x83, 0x4d, 0x53, 0x11, 0xbc, 0xf3,\n            0x2b, 0xb9, 0xda, 0x1a, 0x00, 0x2b, 0x00, 0x02, 0x03, 0x04,\n        ];\n        assert_decrypt_initial_pkt(&mut pkt, &dcid, false, &frames, 1, 2);\n"]]}
{"hexsha": "eac8d866a7e8fa72bd61398904001386f1a07ba8", "ext": "rs", "lang": "Rust", "content": "fn mine_cuckatoo_lean_cpu_19() {\n\tlet mut config = PluginConfig::new(\"cuckatoo_lean_cpu_19\").unwrap();\n\tconfig.params.nthreads = 4;\n\tmine_async_for_duration(&vec![config], 20);\n}", "item_id": 3, "repo": "dpc/grin-miner", "file": "cuckoo-miner/tests/miner.rs", "last_update_at": "2019-12-02T07:42:40+00:00", "question_id": "eac8d866a7e8fa72bd61398904001386f1a07ba8_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn mine_cuckatoo_lean_cpu_19() {\n\tlet mut config = PluginConfig::new(\"cuckatoo_lean_cpu_19\").unwrap();\n\tconfig.params.nthreads = 4;\n\tmine_async_for_duration(&vec![config], 20);\n"]]}
{"hexsha": "81f0c7bdc33aa7a47e1522a9dc8ed63589fc8278", "ext": "rs", "lang": "Rust", "content": "pub fn get_rdkafka_version() -> (u16, String) {\n    let version_number = unsafe { rdsys::rd_kafka_version() } as u16;\n    let c_str = unsafe { CStr::from_ptr(rdsys::rd_kafka_version_str()) };\n    (version_number, c_str.to_string_lossy().into_owned())\n}", "item_id": 0, "repo": "vectordotdev/rust-rdkafka", "file": "src/util.rs", "last_update_at": "2019-11-04T16:15:24+00:00", "question_id": "81f0c7bdc33aa7a47e1522a9dc8ed63589fc8278_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_rdkafka_version() -> (u16, String) {\n    let version_number = unsafe { rdsys::rd_kafka_version() } as u16;\n    let c_str = unsafe { CStr::from_ptr(rdsys::rd_kafka_version_str()) };\n    (version_number, c_str.to_string_lossy().into_owned())\n"]]}
{"hexsha": "5f2555ba435ae4886b42755019de8cf1eab75942", "ext": "rs", "lang": "Rust", "content": "pub fn learning_summary_upage(db: DB, ip: Ip, pg: i64, user: User) -> Template {\n\tlog_to_db(&db, ip, user.0);\n\tlet category = \"LearningSummary\";\n\tlet (articles, total_article) = Article::pagination_query_by_category(db.conn(), &category, pg);\n\tlet mut context = user_context(&db, user);\n\tlet total_page = (total_article - 1) / 10 + 1;\n\tcontext.insert(\"articles\", &articles);\n\tcontext.insert(\"total_page\", &total_page);\n\tcontext.insert(\"pg\", &pg);\n\tcontext.insert(\"category\", \"Learning Summary\");\n\tTemplate::render(\"article_list\", &context)\n}", "item_id": 10, "repo": "C0n5t4ntK/unless", "file": "src/controller/article.rs", "last_update_at": "2019-10-31T00:08:09+00:00", "question_id": "5f2555ba435ae4886b42755019de8cf1eab75942_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn learning_summary_upage(db: DB, ip: Ip, pg: i64, user: User) -> Template {\n\tlog_to_db(&db, ip, user.0);\n\tlet category = \"LearningSummary\";\n\tlet (articles, total_article) = Article::pagination_query_by_category(db.conn(), &category, pg);\n\tlet mut context = user_context(&db, user);\n\tlet total_page = (total_article - 1) / 10 + 1;\n\tcontext.insert(\"articles\", &articles);\n\tcontext.insert(\"total_page\", &total_page);\n\tcontext.insert(\"pg\", &pg);\n\tcontext.insert(\"category\", \"Learning Summary\");\n\tTemplate::render(\"article_list\", &context)\n"]]}
{"hexsha": "ad1c4145b2bbc700d25cc902d5247fcd981d6f2c", "ext": "rs", "lang": "Rust", "content": "fn test_get_current_url() {\n    let mut driver = WebDriver::new(Browser::Chrome);\n    driver.start_session();\n    driver.navigate(\"http://google.com\");\n    let url = driver.get_current_url().unwrap();\n    assert!(\n        driver.get_current_url().unwrap() == String::from(\"https://www.google.com/?gws_rd=ssl\")\n    );\n}", "item_id": 3, "repo": "fusillicode/selenium-rs", "file": "tests/webdriver_tests.rs", "last_update_at": "2019-11-21T19:13:37+00:00", "question_id": "ad1c4145b2bbc700d25cc902d5247fcd981d6f2c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_get_current_url() {\n    let mut driver = WebDriver::new(Browser::Chrome);\n    driver.start_session();\n    driver.navigate(\"http://google.com\");\n    let url = driver.get_current_url().unwrap();\n    assert!(\n        driver.get_current_url().unwrap() == String::from(\"https://www.google.com/?gws_rd=ssl\")\n    );\n"]]}
{"hexsha": "d206f1f57a6f8f4cfd67220d6340d32183703b69", "ext": "rs", "lang": "Rust", "content": "fn get_response<T, R>(\n    server: &mut test::TestServer,\n    path: &str,\n    method: Method,\n    json: T,\n) -> (StatusCode, R)\nwhere\n    T: Serialize,\n    R: DeserializeOwned + 'static,\n{\n    let request = server\n        .client(method, &format!(\"api/v1/{}\", path))\n        .content_type(\"application/json\")\n        .json(json)\n        .unwrap();\n    let response = server.execute(request.send()).unwrap();\n    (response.status(), response.json::<R>().wait().unwrap())\n}", "item_id": 1, "repo": "davidMcneil/qorier", "file": "service/src/http_protocol/tests.rs", "last_update_at": "2019-12-21T14:47:59+00:00", "question_id": "d206f1f57a6f8f4cfd67220d6340d32183703b69_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_response<T, R>(\n    server: &mut test::TestServer,\n    path: &str,\n    method: Method,\n    json: T,\n) -> (StatusCode, R)\nwhere\n    T: Serialize,\n    R: DeserializeOwned + 'static,\n{\n    let request = server\n        .client(method, &format!(\"api/v1/{}\", path))\n        .content_type(\"application/json\")\n        .json(json)\n        .unwrap();\n    let response = server.execute(request.send()).unwrap();\n    (response.status(), response.json::<R>().wait().unwrap())\n"]]}
{"hexsha": "5cb84beea124480ed2fce88c87e31da1965ff14a", "ext": "rs", "lang": "Rust", "content": "pub fn fetch(instr_mem: &dyn MemoryAccess, pc: u32) -> Result<(u32, u32), FetchError> {\n    alignment_check(pc)?;\n\n    let instr = instr_mem.read_u32(pc as usize)?;\n    let next_pc = pc + 4;\n    Ok((instr, next_pc))\n}", "item_id": 0, "repo": "tomoyuki-nakabayashi/Rustemu86", "file": "arch/riscv/src/fetch.rs", "last_update_at": "2019-02-07T05:27:30+00:00", "question_id": "5cb84beea124480ed2fce88c87e31da1965ff14a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn fetch(instr_mem: &dyn MemoryAccess, pc: u32) -> Result<(u32, u32), FetchError> {\n    alignment_check(pc)?;\n    let instr = instr_mem.read_u32(pc as usize)?;\n    let next_pc = pc + 4;\n    Ok((instr, next_pc))\n"]]}
{"hexsha": "3deac005077f7c70c346c676b2f9596a2b4440d9", "ext": "rs", "lang": "Rust", "content": "fn difference_with_a_lhs_xml_value() {\n        let expected = expected_values(\n            r#\"SELECT \"users\".* FROM \"users\" WHERE $1 <> \"xmlField\"::text\"#,\n            vec![Value::xml(\"<salad>wurst</salad>\")],\n        );\n\n        let value_expr: Expression = Value::xml(\"<salad>wurst</salad>\").into();\n        let query = Select::from_table(\"users\").so_that(value_expr.not_equals(Column::from(\"xmlField\")));\n        let (sql, params) = Postgres::build(query).unwrap();\n\n        assert_eq!(expected.0, sql);\n        assert_eq!(expected.1, params);\n    }", "item_id": 22, "repo": "prisma/prisma-query", "file": "src/visitor/postgres.rs", "last_update_at": "2019-11-02T17:23:18+00:00", "question_id": "3deac005077f7c70c346c676b2f9596a2b4440d9_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn difference_with_a_lhs_xml_value() {\n        let expected = expected_values(\n            r#\"SELECT \"users\".* FROM \"users\" WHERE $1 <> \"xmlField\"::text\"#,\n            vec![Value::xml(\"<salad>wurst</salad>\")],\n        );\n        let value_expr: Expression = Value::xml(\"<salad>wurst</salad>\").into();\n        let query = Select::from_table(\"users\").so_that(value_expr.not_equals(Column::from(\"xmlField\")));\n        let (sql, params) = Postgres::build(query).unwrap();\n        assert_eq!(expected.0, sql);\n        assert_eq!(expected.1, params);\n"]]}
{"hexsha": "d84e321bc09376b4b1f71df5104cb5c54a74cfe9", "ext": "rs", "lang": "Rust", "content": "pub fn link_csfml(lib_name: &str) {\n    // Figure out the path to libraries within the CSFML base folder\n    // based on the operating system\n    let lib_path = if cfg!(target_family = \"windows\") {\n        if cfg!(target_env = \"msvc\") {\n            \"lib/msvc\"\n        } else {\n            \"lib/gcc\"\n        }\n    } else {\n        \"lib\"\n    };\n\n    // CSFML_HOME points to the base CSFML directory\n    // Let cargo find the CSFML library files there\n    if let Ok(csfml_home) = var(\"CSFML_HOME\") {\n        println!(\"cargo:rustc-link-search=native={}/{}\", csfml_home, lib_path);\n    }\n\n    // Link to the csfml library\n    println!(\"cargo:rustc-link-lib=csfml-{}\", lib_name);\n}", "item_id": 0, "repo": "dmolina/rust-sfml", "file": "ffi/sfml-build/src/lib.rs", "last_update_at": "2019-10-04T04:49:22+00:00", "question_id": "d84e321bc09376b4b1f71df5104cb5c54a74cfe9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn link_csfml(lib_name: &str) {\n    // Figure out the path to libraries within the CSFML base folder\n    // based on the operating system\n    let lib_path = if cfg!(target_family = \"windows\") {\n        if cfg!(target_env = \"msvc\") {\n            \"lib/msvc\"\n        } else {\n            \"lib/gcc\"\n        }\n    } else {\n        \"lib\"\n    };\n    // CSFML_HOME points to the base CSFML directory\n    // Let cargo find the CSFML library files there\n    if let Ok(csfml_home) = var(\"CSFML_HOME\") {\n        println!(\"cargo:rustc-link-search=native={}/{}\", csfml_home, lib_path);\n    }\n    // Link to the csfml library\n    println!(\"cargo:rustc-link-lib=csfml-{}\", lib_name);\n"]]}
{"hexsha": "43968cb5bf5aa2079bf3e4a0ebebb609aa6819f7", "ext": "rs", "lang": "Rust", "content": "fn test_rotate_with_wallkick() {\n        let field = Field::new();\n        let mut block = Block::new(block::Id::S, &field);\n        let wk = wallkick::SRS::new();\n\n        block.shift(&field, Direction::Down);\n\n        // Non-reference `wk` is slightly annoying.\n        block.rotate_with_wallkick(&field, wk, Rotation::R90);\n    }", "item_id": 0, "repo": "tiehuis/tetrs", "file": "src/utility.rs", "last_update_at": "2019-09-23T22:16:28+00:00", "question_id": "43968cb5bf5aa2079bf3e4a0ebebb609aa6819f7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_rotate_with_wallkick() {\n        let field = Field::new();\n        let mut block = Block::new(block::Id::S, &field);\n        let wk = wallkick::SRS::new();\n        block.shift(&field, Direction::Down);\n        // Non-reference `wk` is slightly annoying.\n        block.rotate_with_wallkick(&field, wk, Rotation::R90);\n"]]}
{"hexsha": "351fb60051510e6e6812bd55755fcd77e3cf5b1e", "ext": "rs", "lang": "Rust", "content": "fn test_compile_push_f() {\n    let compiled = miscellaneous::compile_push(\"F\".to_string());\n\n    assert_eq!(compiled.len(), 1);\n    assert_eq!(compiled[0], 0b11001101);\n}", "item_id": 7, "repo": "TheLocust3/simple-virtual-machine", "file": "asm/tests/compiler_miscellaneous_tests.rs", "last_update_at": "2019-02-18T04:28:41+00:00", "question_id": "351fb60051510e6e6812bd55755fcd77e3cf5b1e_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_compile_push_f() {\n    let compiled = miscellaneous::compile_push(\"F\".to_string());\n    assert_eq!(compiled.len(), 1);\n    assert_eq!(compiled[0], 0b11001101);\n"]]}
{"hexsha": "f7ae5f9680f23adb5272273c5c3ddcb768c21af0", "ext": "rs", "lang": "Rust", "content": "fn get_format(byte: &u8) -> ChunkHeaderFormat {\n    const TYPE_0_MASK: u8 = 0b00000000;\n    const TYPE_1_MASK: u8 = 0b01000000;\n    const TYPE_2_MASK: u8 = 0b10000000;\n    const FORMAT_MASK: u8 = 0b11000000;    \n\n    let format_id = *byte & FORMAT_MASK;\n\n    match format_id {\n        TYPE_0_MASK => ChunkHeaderFormat::Full,\n        TYPE_1_MASK => ChunkHeaderFormat::TimeDeltaWithoutMessageStreamId,\n        TYPE_2_MASK => ChunkHeaderFormat::TimeDeltaOnly,\n        _ => ChunkHeaderFormat::Empty\n    }\n}", "item_id": 0, "repo": "KallDrexx/mmids-rust", "file": "rtmp_chunk_io/src/deserialization.rs", "last_update_at": "2019-04-02T23:27:04+00:00", "question_id": "f7ae5f9680f23adb5272273c5c3ddcb768c21af0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_format(byte: &u8) -> ChunkHeaderFormat {\n    const TYPE_0_MASK: u8 = 0b00000000;\n    const TYPE_1_MASK: u8 = 0b01000000;\n    const TYPE_2_MASK: u8 = 0b10000000;\n    const FORMAT_MASK: u8 = 0b11000000;    \n    let format_id = *byte & FORMAT_MASK;\n    match format_id {\n        TYPE_0_MASK => ChunkHeaderFormat::Full,\n        TYPE_1_MASK => ChunkHeaderFormat::TimeDeltaWithoutMessageStreamId,\n        TYPE_2_MASK => ChunkHeaderFormat::TimeDeltaOnly,\n        _ => ChunkHeaderFormat::Empty\n    }\n"]]}
{"hexsha": "35fa58ab4c3b5656012cb431e9999bf1e8870b6f", "ext": "rs", "lang": "Rust", "content": "fn parse_input(s: &str) -> Result<Grid> {\n    let mut g = Grid::default();\n\n    for (y, l) in s.lines().enumerate() {\n        for (x, c) in l.chars().enumerate() {\n            g.insert(Point::new(x as i64, 0 - y as i64), c.try_into()?)\n        }\n    }\n\n    Ok(g)\n}", "item_id": 2, "repo": "sebnow/adventofcode", "file": "2020/src/bin/day11.rs", "last_update_at": "2019-08-12T13:58:00+00:00", "question_id": "35fa58ab4c3b5656012cb431e9999bf1e8870b6f_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_input(s: &str) -> Result<Grid> {\n    let mut g = Grid::default();\n    for (y, l) in s.lines().enumerate() {\n        for (x, c) in l.chars().enumerate() {\n            g.insert(Point::new(x as i64, 0 - y as i64), c.try_into()?)\n        }\n    }\n    Ok(g)\n"]]}
{"hexsha": "e9cd8cc8fcfeb87718edb509a63b4746f9bbbcf5", "ext": "rs", "lang": "Rust", "content": "fn main() {\n\tprintln!(\"\");\n\tprintln!(\"Enter it in the terminal !!\");\n\tprintln!();\n\tprintln!(\"=====================\");\n\tprintln!(\"cargo bench --example bench\");\n\tprintln!(\"=====================\");\n}", "item_id": 0, "repo": "clucompany/cluCStr", "file": "examples/bench.rs", "last_update_at": "2019-04-25T04:14:31+00:00", "question_id": "e9cd8cc8fcfeb87718edb509a63b4746f9bbbcf5_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n\tprintln!(\"\");\n\tprintln!(\"Enter it in the terminal !!\");\n\tprintln!();\n\tprintln!(\"=====================\");\n\tprintln!(\"cargo bench --example bench\");\n\tprintln!(\"=====================\");\n"]]}
{"hexsha": "58c23ad09deb2dc100c9a062a5d8021d1cad94e4", "ext": "rs", "lang": "Rust", "content": "fn test_backup() {\n        let db = SqliteConnection::open_in_memory().unwrap();\n        let sql = \"BEGIN;\n                CREATE TABLE foo(x INTEGER);\n                INSERT INTO foo VALUES(42);\n                END;\";\n        db.execute_batch(sql).unwrap();\n        db.backup(\"main\", &\":memory:\").unwrap();\n        assert!(db.close().is_ok());\n    }", "item_id": 0, "repo": "Dashed/rusqlite", "file": "src/backup.rs", "last_update_at": "2019-06-12T22:17:19+00:00", "question_id": "58c23ad09deb2dc100c9a062a5d8021d1cad94e4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_backup() {\n        let db = SqliteConnection::open_in_memory().unwrap();\n        let sql = \"BEGIN;\n                CREATE TABLE foo(x INTEGER);\n                INSERT INTO foo VALUES(42);\n                END;\";\n        db.execute_batch(sql).unwrap();\n        db.backup(\"main\", &\":memory:\").unwrap();\n        assert!(db.close().is_ok());\n"]]}
{"hexsha": "07282abc447bc6ea6b051c04fc4143cdd0bd1220", "ext": "rs", "lang": "Rust", "content": "fn test_patch() {\n    setup();\n    let body = get_body(mrq::patch(url(\"/i\")).with_body(\"O\").send());\n    assert_eq!(body, \"r: O\");\n}", "item_id": 8, "repo": "mattgathu/minreq", "file": "tests/main.rs", "last_update_at": "2019-05-31T23:41:47+00:00", "question_id": "07282abc447bc6ea6b051c04fc4143cdd0bd1220_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_patch() {\n    setup();\n    let body = get_body(mrq::patch(url(\"/i\")).with_body(\"O\").send());\n    assert_eq!(body, \"r: O\");\n"]]}
{"hexsha": "771d01cffd9eed813c254422d7edf92b8f5f8dd7", "ext": "rs", "lang": "Rust", "content": "fn test_types_are_creatable() {\n    let i = number!(3);\n    assert_eq!(\"3\".to_string(), format!(\"{:?}\", i));\n    assert_eq!(false, i.is_reducible());\n\n    let i = add!(number!(3), number!(4));\n    assert_eq!(\"3 + 4\".to_string(), format!(\"{:?}\", i));\n    assert_eq!(true, i.is_reducible());\n\n    let i = multiply!(\n        add!(number!(3), number!(4)),\n        number!(2));\n    assert_eq!(\"3 + 4 * 2\".to_string(), format!(\"{:?}\", i));\n    assert_eq!(true, i.is_reducible());\n\n    let i = boolean!(true);\n    assert_eq!(\"true\".to_string(), format!(\"{:?}\", i));\n    assert_eq!(false, i.is_reducible());\n\n    let i = less_than!(number!(2), number!(3));\n    assert_eq!(\"2 < 3\".to_string(), format!(\"{:?}\", i));\n    assert_eq!(true, i.is_reducible());\n}", "item_id": 0, "repo": "badboy/small-step-simple-rust", "file": "src/lib.rs", "last_update_at": "2019-04-17T23:50:24+00:00", "question_id": "771d01cffd9eed813c254422d7edf92b8f5f8dd7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_types_are_creatable() {\n    let i = number!(3);\n    assert_eq!(\"3\".to_string(), format!(\"{:?}\", i));\n    assert_eq!(false, i.is_reducible());\n    let i = add!(number!(3), number!(4));\n    assert_eq!(\"3 + 4\".to_string(), format!(\"{:?}\", i));\n    assert_eq!(true, i.is_reducible());\n    let i = multiply!(\n        add!(number!(3), number!(4)),\n        number!(2));\n    assert_eq!(\"3 + 4 * 2\".to_string(), format!(\"{:?}\", i));\n    assert_eq!(true, i.is_reducible());\n    let i = boolean!(true);\n    assert_eq!(\"true\".to_string(), format!(\"{:?}\", i));\n    assert_eq!(false, i.is_reducible());\n    let i = less_than!(number!(2), number!(3));\n    assert_eq!(\"2 < 3\".to_string(), format!(\"{:?}\", i));\n    assert_eq!(true, i.is_reducible());\n"]]}
{"hexsha": "fb594ff611a0feacfdbc0a6ac79665c149b46b6b", "ext": "rs", "lang": "Rust", "content": "pub fn start_logging(config: &LoggingConfig){\n    let root_and_loggers: String = match &config.loggers {\n        None => config.root_level.clone(),\n        Some (loggers) => {\n            let mut accumul: String = config.root_level.clone();\n            for (log_name, level) in loggers {\n                accumul.push_str(&format!(\", {}={}\", log_name, level));\n            }\n            accumul\n        }\n    };\n    let mut logger = Logger::with_env_or_str(root_and_loggers).format(opt_format);\n    if config.log_to_file{\n        logger = logger.log_to_file();\n        let dir = match &config.directory{\n            Some(dir) => dir,\n            None => panic!(\"A logging directory needs to be provided to log to a file\"),\n        };\n        let rotate = match &config.rotate_size_mb{\n            Some(size) => *size as u64 * MEGA_BYTE,\n            None => MEGA_BYTE,            \n        };\n        let cleanup = match &config.num_keep_files{\n            Some(num) => Cleanup::KeepLogFiles(*num as usize),\n            None => Cleanup::KeepLogFiles(5),\n        };\n        logger = logger.directory(dir)\n                       .rotate(rotate as usize, cleanup);\n    }\n    logger.start().expect(\"Unable to configure logging!!\");\n    info!(\"Logging system started\")\n}", "item_id": 0, "repo": "dashpipe/12factor-rs", "file": "src/logging.rs", "last_update_at": "2019-06-14T21:49:20+00:00", "question_id": "fb594ff611a0feacfdbc0a6ac79665c149b46b6b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn start_logging(config: &LoggingConfig){\n    let root_and_loggers: String = match &config.loggers {\n        None => config.root_level.clone(),\n        Some (loggers) => {\n            let mut accumul: String = config.root_level.clone();\n            for (log_name, level) in loggers {\n                accumul.push_str(&format!(\", {}={}\", log_name, level));\n            }\n            accumul\n        }\n    };\n    let mut logger = Logger::with_env_or_str(root_and_loggers).format(opt_format);\n    if config.log_to_file{\n        logger = logger.log_to_file();\n        let dir = match &config.directory{\n            Some(dir) => dir,\n            None => panic!(\"A logging directory needs to be provided to log to a file\"),\n        };\n        let rotate = match &config.rotate_size_mb{\n            Some(size) => *size as u64 * MEGA_BYTE,\n            None => MEGA_BYTE,            \n        };\n        let cleanup = match &config.num_keep_files{\n            Some(num) => Cleanup::KeepLogFiles(*num as usize),\n            None => Cleanup::KeepLogFiles(5),\n        };\n        logger = logger.directory(dir)\n                       .rotate(rotate as usize, cleanup);\n    }\n    logger.start().expect(\"Unable to configure logging!!\");\n    info!(\"Logging system started\")\n"]]}
{"hexsha": "19cecf477208fb902565e29bf7954a7ba15ae90b", "ext": "rs", "lang": "Rust", "content": "fn js_node_height(mut cx: FunctionContext) -> JsResult<JsString> {\n    let path = cx.argument::<JsString>(0)?.value();\n    let password = cx.argument::<JsString>(1)?.value();\n\n    match node_height(&path, &password) {\n        Ok(res) => {\n            Ok(cx.string(res))\n        }\n        Err(e) => {\n            Ok(cx.string(serde_json::to_string(&format!(\"{}\",e)).unwrap()))\n        }\n    }\n}", "item_id": 26, "repo": "BitHighlander/diagonAlley", "file": "grinRs/native/src/lib.rs", "last_update_at": "2019-11-12T03:14:19+00:00", "question_id": "19cecf477208fb902565e29bf7954a7ba15ae90b_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn js_node_height(mut cx: FunctionContext) -> JsResult<JsString> {\n    let path = cx.argument::<JsString>(0)?.value();\n    let password = cx.argument::<JsString>(1)?.value();\n    match node_height(&path, &password) {\n        Ok(res) => {\n            Ok(cx.string(res))\n        }\n        Err(e) => {\n            Ok(cx.string(serde_json::to_string(&format!(\"{}\",e)).unwrap()))\n        }\n    }\n"]]}
{"hexsha": "6ecb0a9b415432be05860208284480440e5203c2", "ext": "rs", "lang": "Rust", "content": "fn make_phf<I, K>(s: I, ident: Ident) -> proc_macro2::TokenStream\nwhere\n    K: AsRef<[u8]>,\n    I: ExactSizeIterator<Item = (usize, K)> + Clone,\n{\n    let phf = internal::Hash::generate(s);\n\n    let name_phf = Ident::new(&format!(\"{}_derive_phf\", ident), ident.span());\n    let phf_static = Ident::new(\n        &format!(\"{}_derive_phf\", ident).TO_SHOUTY_SNEK_CASE(),\n        ident.span(),\n    );\n\n    let (left_len, left) = (phf.left.len(), phf.left);\n    let (right_len, right) = (phf.right.len(), phf.right);\n    let (graph_len, graph) = (phf.graph.len(), phf.graph);\n\n    quote! {\n        #[doc(hidden)]\n        #[allow(non_camel_case_types)]\n        struct #name_phf {\n            left: [u8; #left_len],\n            right: [u8; #right_len],\n            graph: [u8; #graph_len],\n        }\n\n        use PerfectHash as _;\n        impl PerfectHash for #name_phf {\n            fn left(&self) -> &[u8] { &self.left }\n            fn right(&self) -> &[u8] { &self.right }\n            fn graph(&self) -> &[u8] { &self.graph }\n        }\n\n        #[doc(hidden)]\n        #[allow(non_camel_case_types)]\n        static #phf_static: #name_phf = #name_phf {\n            left: [#(#left,)*],\n            right: [#(#right,)*],\n            graph: [#(#graph,)*],\n        };\n    }\n}", "item_id": 3, "repo": "museun/phf", "file": "derive/src/lib.rs", "last_update_at": "2019-05-04T22:09:01+00:00", "question_id": "6ecb0a9b415432be05860208284480440e5203c2_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn make_phf<I, K>(s: I, ident: Ident) -> proc_macro2::TokenStream\nwhere\n    K: AsRef<[u8]>,\n    I: ExactSizeIterator<Item = (usize, K)> + Clone,\n{\n    let phf = internal::Hash::generate(s);\n    let name_phf = Ident::new(&format!(\"{}_derive_phf\", ident), ident.span());\n    let phf_static = Ident::new(\n        &format!(\"{}_derive_phf\", ident).TO_SHOUTY_SNEK_CASE(),\n        ident.span(),\n    );\n    let (left_len, left) = (phf.left.len(), phf.left);\n    let (right_len, right) = (phf.right.len(), phf.right);\n    let (graph_len, graph) = (phf.graph.len(), phf.graph);\n    quote! {\n        #[doc(hidden)]\n        #[allow(non_camel_case_types)]\n        struct #name_phf {\n            left: [u8; #left_len],\n            right: [u8; #right_len],\n            graph: [u8; #graph_len],\n        }\n        use PerfectHash as _;\n        impl PerfectHash for #name_phf {\n            fn left(&self) -> &[u8] { &self.left }\n            fn right(&self) -> &[u8] { &self.right }\n            fn graph(&self) -> &[u8] { &self.graph }\n        }\n        #[doc(hidden)]\n        #[allow(non_camel_case_types)]\n        static #phf_static: #name_phf = #name_phf {\n            left: [#(#left,)*],\n            right: [#(#right,)*],\n            graph: [#(#graph,)*],\n        };\n    }\n"]]}
{"hexsha": "c8d111cdabacd5de9555b2f36a8e04a6c22c5c99", "ext": "rs", "lang": "Rust", "content": "pub fn main() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"common.rs\");\n    let mut fout = File::create(&dest_path).unwrap();\n\n    let src_dir = env::current_dir().unwrap();\n    let msg_dr = src_dir.join(\"msg\");\n\n    let mut parso = parser::Parser::new();\n    let _res = parso.process_msg_directory(&msg_dr, &mut fout);\n\n    println!(\"output path: {:?}\", dest_path);\n\n    //TODO verify this works if we add new files OR updated files\n    println!(\"cargo:rerun-if-changed=msg/\");\n}", "item_id": 0, "repo": "tstellanova/uorb-codec", "file": "build/main.rs", "last_update_at": "2019-02-24T02:42:58+00:00", "question_id": "c8d111cdabacd5de9555b2f36a8e04a6c22c5c99_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn main() {\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&out_dir).join(\"common.rs\");\n    let mut fout = File::create(&dest_path).unwrap();\n    let src_dir = env::current_dir().unwrap();\n    let msg_dr = src_dir.join(\"msg\");\n    let mut parso = parser::Parser::new();\n    let _res = parso.process_msg_directory(&msg_dr, &mut fout);\n    println!(\"output path: {:?}\", dest_path);\n    //TODO verify this works if we add new files OR updated files\n    println!(\"cargo:rerun-if-changed=msg/\");\n"]]}
{"hexsha": "a08423d010cf4e3f2c3d54afedefe29db74f8bfc", "ext": "rs", "lang": "Rust", "content": "fn test0() {\n    let mut node = Node::new().unwrap();\n    node.init();\n    node.create_environment(\"X\").unwrap();\n    node.create_entity().unwrap();\n    node.run().unwrap();\n}", "item_id": 0, "repo": "Alex6323/reee", "file": "src/main.rs", "last_update_at": "2019-07-09T10:56:15+00:00", "question_id": "a08423d010cf4e3f2c3d54afedefe29db74f8bfc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test0() {\n    let mut node = Node::new().unwrap();\n    node.init();\n    node.create_environment(\"X\").unwrap();\n    node.create_entity().unwrap();\n    node.run().unwrap();\n"]]}
{"hexsha": "c344fa3db7b65c0e0ee11fb74ac3c1959837b23b", "ext": "rs", "lang": "Rust", "content": "fn key_setup(key : &[u8], subkeys : &mut[u32; 100]) {\n    let mut full_key : [u8; 32] = [0; 32];\n    if key.len() < 32 {\n        copy_memory(&key, &mut full_key[0..key.len()]);\n        full_key[key.len()] = 0x01;\n    } else {\n        copy_memory(&key[0..32], &mut full_key[0..32]);\n    }\n\n    let mut w0 = read_u32_le(&full_key[0..4]);\n    let mut w1 = read_u32_le(&full_key[4..8]);\n    let mut w2 = read_u32_le(&full_key[8..12]);\n    let mut w3 = read_u32_le(&full_key[12..16]);\n    let mut w4 = read_u32_le(&full_key[16..20]);\n    let mut w5 = read_u32_le(&full_key[20..24]);\n    let mut w6 = read_u32_le(&full_key[24..28]);\n    let mut w7 = read_u32_le(&full_key[28..32]);\n    let mut r0 : u32;\n    let mut r1 : u32;\n    let mut r2 : u32;\n    let mut r3 : u32;\n    let mut r4 : u32;\n    let mut tt : u32;\n    let mut i = 0;\n\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (0));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (0 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (0 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (0 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r0;\n    r0 |= r3;\n    r3 ^= r1;\n    r1 &= r4;\n    r4 ^= r2;\n    r2 ^= r3;\n    r3 &= r0;\n    r4 |= r1;\n    r3 ^= r4;\n    r0 ^= r1;\n    r4 &= r0;\n    r1 ^= r3;\n    r4 ^= r2;\n    r1 |= r0;\n    r1 ^= r2;\n    r0 ^= r3;\n    r2 = r1;\n    r1 |= r3;\n    r1 ^= r0;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r4; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (4));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (4 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (4 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (4 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r4 = r0;\n    r0 &= r2;\n    r0 ^= r3;\n    r2 ^= r1;\n    r2 ^= r0;\n    r3 |= r4;\n    r3 ^= r1;\n    r4 ^= r2;\n    r1 = r3;\n    r3 |= r4;\n    r3 ^= r0;\n    r0 &= r1;\n    r4 ^= r0;\n    r1 ^= r3;\n    r1 ^= r4;\n    r4 = !r4;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (8));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (8 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (8 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (8 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r0 = !r0;\n    r2 = !r2;\n    r4 = r0;\n    r0 &= r1;\n    r2 ^= r0;\n    r0 |= r3;\n    r3 ^= r2;\n    r1 ^= r0;\n    r0 ^= r4;\n    r4 |= r1;\n    r1 ^= r3;\n    r2 |= r0;\n    r2 &= r4;\n    r0 ^= r1;\n    r1 &= r2;\n    r1 ^= r0;\n    r0 &= r2;\n    r0 ^= r4;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (12));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (12 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (12 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (12 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r3 ^= r0;\n    r4 = r1;\n    r1 &= r3;\n    r4 ^= r2;\n    r1 ^= r0;\n    r0 |= r3;\n    r0 ^= r4;\n    r4 ^= r3;\n    r3 ^= r2;\n    r2 |= r1;\n    r2 ^= r4;\n    r4 = !r4;\n    r4 |= r1;\n    r1 ^= r3;\n    r1 ^= r4;\n    r3 |= r0;\n    r1 ^= r3;\n    r4 ^= r3;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r0; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (16));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (16 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (16 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (16 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r1;\n    r1 |= r2;\n    r1 ^= r3;\n    r4 ^= r2;\n    r2 ^= r1;\n    r3 |= r4;\n    r3 &= r0;\n    r4 ^= r2;\n    r3 ^= r1;\n    r1 |= r4;\n    r1 ^= r0;\n    r0 |= r4;\n    r0 ^= r2;\n    r1 ^= r4;\n    r2 ^= r1;\n    r1 &= r0;\n    r1 ^= r4;\n    r2 = !r2;\n    r2 |= r0;\n    r4 ^= r2;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r0; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (20));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (20 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (20 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (20 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r2 = !r2;\n    r4 = r3;\n    r3 &= r0;\n    r0 ^= r4;\n    r3 ^= r2;\n    r2 |= r4;\n    r1 ^= r3;\n    r2 ^= r0;\n    r0 |= r1;\n    r2 ^= r1;\n    r4 ^= r0;\n    r0 |= r3;\n    r0 ^= r2;\n    r4 ^= r3;\n    r4 ^= r0;\n    r3 = !r3;\n    r2 &= r4;\n    r2 ^= r3;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r2; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (24));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (24 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (24 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (24 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r0 ^= r1;\n    r1 ^= r3;\n    r3 = !r3;\n    r4 = r1;\n    r1 &= r0;\n    r2 ^= r3;\n    r1 ^= r2;\n    r2 |= r4;\n    r4 ^= r3;\n    r3 &= r1;\n    r3 ^= r0;\n    r4 ^= r1;\n    r4 ^= r2;\n    r2 ^= r0;\n    r0 &= r3;\n    r2 = !r2;\n    r0 ^= r4;\n    r4 |= r3;\n    r2 ^= r4;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r2; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (28));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (28 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (28 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (28 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r1 ^= r3;\n    r3 = !r3;\n    r2 ^= r3;\n    r3 ^= r0;\n    r4 = r1;\n    r1 &= r3;\n    r1 ^= r2;\n    r4 ^= r3;\n    r0 ^= r4;\n    r2 &= r4;\n    r2 ^= r0;\n    r0 &= r1;\n    r3 ^= r0;\n    r4 |= r1;\n    r4 ^= r0;\n    r0 |= r3;\n    r0 ^= r2;\n    r2 &= r3;\n    r0 = !r0;\n    r4 ^= r2;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r3; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (32));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (32 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (32 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (32 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r0;\n    r0 |= r3;\n    r3 ^= r1;\n    r1 &= r4;\n    r4 ^= r2;\n    r2 ^= r3;\n    r3 &= r0;\n    r4 |= r1;\n    r3 ^= r4;\n    r0 ^= r1;\n    r4 &= r0;\n    r1 ^= r3;\n    r4 ^= r2;\n    r1 |= r0;\n    r1 ^= r2;\n    r0 ^= r3;\n    r2 = r1;\n    r1 |= r3;\n    r1 ^= r0;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r4; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (36));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (36 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (36 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (36 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r4 = r0;\n    r0 &= r2;\n    r0 ^= r3;\n    r2 ^= r1;\n    r2 ^= r0;\n    r3 |= r4;\n    r3 ^= r1;\n    r4 ^= r2;\n    r1 = r3;\n    r3 |= r4;\n    r3 ^= r0;\n    r0 &= r1;\n    r4 ^= r0;\n    r1 ^= r3;\n    r1 ^= r4;\n    r4 = !r4;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (40));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (40 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (40 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (40 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r0 = !r0;\n    r2 = !r2;\n    r4 = r0;\n    r0 &= r1;\n    r2 ^= r0;\n    r0 |= r3;\n    r3 ^= r2;\n    r1 ^= r0;\n    r0 ^= r4;\n    r4 |= r1;\n    r1 ^= r3;\n    r2 |= r0;\n    r2 &= r4;\n    r0 ^= r1;\n    r1 &= r2;\n    r1 ^= r0;\n    r0 &= r2;\n    r0 ^= r4;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (44));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (44 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (44 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (44 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r3 ^= r0;\n    r4 = r1;\n    r1 &= r3;\n    r4 ^= r2;\n    r1 ^= r0;\n    r0 |= r3;\n    r0 ^= r4;\n    r4 ^= r3;\n    r3 ^= r2;\n    r2 |= r1;\n    r2 ^= r4;\n    r4 = !r4;\n    r4 |= r1;\n    r1 ^= r3;\n    r1 ^= r4;\n    r3 |= r0;\n    r1 ^= r3;\n    r4 ^= r3;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r0; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (48));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (48 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (48 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (48 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r1;\n    r1 |= r2;\n    r1 ^= r3;\n    r4 ^= r2;\n    r2 ^= r1;\n    r3 |= r4;\n    r3 &= r0;\n    r4 ^= r2;\n    r3 ^= r1;\n    r1 |= r4;\n    r1 ^= r0;\n    r0 |= r4;\n    r0 ^= r2;\n    r1 ^= r4;\n    r2 ^= r1;\n    r1 &= r0;\n    r1 ^= r4;\n    r2 = !r2;\n    r2 |= r0;\n    r4 ^= r2;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r0; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (52));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (52 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (52 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (52 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r2 = !r2;\n    r4 = r3;\n    r3 &= r0;\n    r0 ^= r4;\n    r3 ^= r2;\n    r2 |= r4;\n    r1 ^= r3;\n    r2 ^= r0;\n    r0 |= r1;\n    r2 ^= r1;\n    r4 ^= r0;\n    r0 |= r3;\n    r0 ^= r2;\n    r4 ^= r3;\n    r4 ^= r0;\n    r3 = !r3;\n    r2 &= r4;\n    r2 ^= r3;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r2; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (56));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (56 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (56 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (56 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r0 ^= r1;\n    r1 ^= r3;\n    r3 = !r3;\n    r4 = r1;\n    r1 &= r0;\n    r2 ^= r3;\n    r1 ^= r2;\n    r2 |= r4;\n    r4 ^= r3;\n    r3 &= r1;\n    r3 ^= r0;\n    r4 ^= r1;\n    r4 ^= r2;\n    r2 ^= r0;\n    r0 &= r3;\n    r2 = !r2;\n    r0 ^= r4;\n    r4 |= r3;\n    r2 ^= r4;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r2; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (60));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (60 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (60 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (60 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r1 ^= r3;\n    r3 = !r3;\n    r2 ^= r3;\n    r3 ^= r0;\n    r4 = r1;\n    r1 &= r3;\n    r1 ^= r2;\n    r4 ^= r3;\n    r0 ^= r4;\n    r2 &= r4;\n    r2 ^= r0;\n    r0 &= r1;\n    r3 ^= r0;\n    r4 |= r1;\n    r4 ^= r0;\n    r0 |= r3;\n    r0 ^= r2;\n    r2 &= r3;\n    r0 = !r0;\n    r4 ^= r2;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r3; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (64));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (64 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (64 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (64 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r0;\n    r0 |= r3;\n    r3 ^= r1;\n    r1 &= r4;\n    r4 ^= r2;\n    r2 ^= r3;\n    r3 &= r0;\n    r4 |= r1;\n    r3 ^= r4;\n    r0 ^= r1;\n    r4 &= r0;\n    r1 ^= r3;\n    r4 ^= r2;\n    r1 |= r0;\n    r1 ^= r2;\n    r0 ^= r3;\n    r2 = r1;\n    r1 |= r3;\n    r1 ^= r0;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r4; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (68));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (68 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (68 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (68 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r4 = r0;\n    r0 &= r2;\n    r0 ^= r3;\n    r2 ^= r1;\n    r2 ^= r0;\n    r3 |= r4;\n    r3 ^= r1;\n    r4 ^= r2;\n    r1 = r3;\n    r3 |= r4;\n    r3 ^= r0;\n    r0 &= r1;\n    r4 ^= r0;\n    r1 ^= r3;\n    r1 ^= r4;\n    r4 = !r4;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (72));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (72 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (72 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (72 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r0 = !r0;\n    r2 = !r2;\n    r4 = r0;\n    r0 &= r1;\n    r2 ^= r0;\n    r0 |= r3;\n    r3 ^= r2;\n    r1 ^= r0;\n    r0 ^= r4;\n    r4 |= r1;\n    r1 ^= r3;\n    r2 |= r0;\n    r2 &= r4;\n    r0 ^= r1;\n    r1 &= r2;\n    r1 ^= r0;\n    r0 &= r2;\n    r0 ^= r4;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (76));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (76 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (76 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (76 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r3 ^= r0;\n    r4 = r1;\n    r1 &= r3;\n    r4 ^= r2;\n    r1 ^= r0;\n    r0 |= r3;\n    r0 ^= r4;\n    r4 ^= r3;\n    r3 ^= r2;\n    r2 |= r1;\n    r2 ^= r4;\n    r4 = !r4;\n    r4 |= r1;\n    r1 ^= r3;\n    r1 ^= r4;\n    r3 |= r0;\n    r1 ^= r3;\n    r4 ^= r3;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r0; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (80));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (80 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (80 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (80 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r1;\n    r1 |= r2;\n    r1 ^= r3;\n    r4 ^= r2;\n    r2 ^= r1;\n    r3 |= r4;\n    r3 &= r0;\n    r4 ^= r2;\n    r3 ^= r1;\n    r1 |= r4;\n    r1 ^= r0;\n    r0 |= r4;\n    r0 ^= r2;\n    r1 ^= r4;\n    r2 ^= r1;\n    r1 &= r0;\n    r1 ^= r4;\n    r2 = !r2;\n    r2 |= r0;\n    r4 ^= r2;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r0; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (84));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (84 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (84 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (84 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r2 = !r2;\n    r4 = r3;\n    r3 &= r0;\n    r0 ^= r4;\n    r3 ^= r2;\n    r2 |= r4;\n    r1 ^= r3;\n    r2 ^= r0;\n    r0 |= r1;\n    r2 ^= r1;\n    r4 ^= r0;\n    r0 |= r3;\n    r0 ^= r2;\n    r4 ^= r3;\n    r4 ^= r0;\n    r3 = !r3;\n    r2 &= r4;\n    r2 ^= r3;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r2; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (88));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (88 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (88 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (88 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r0 ^= r1;\n    r1 ^= r3;\n    r3 = !r3;\n    r4 = r1;\n    r1 &= r0;\n    r2 ^= r3;\n    r1 ^= r2;\n    r2 |= r4;\n    r4 ^= r3;\n    r3 &= r1;\n    r3 ^= r0;\n    r4 ^= r1;\n    r4 ^= r2;\n    r2 ^= r0;\n    r0 &= r3;\n    r2 = !r2;\n    r0 ^= r4;\n    r4 |= r3;\n    r2 ^= r4;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r2; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (92));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (92 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (92 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (92 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r1 ^= r3;\n    r3 = !r3;\n    r2 ^= r3;\n    r3 ^= r0;\n    r4 = r1;\n    r1 &= r3;\n    r1 ^= r2;\n    r4 ^= r3;\n    r0 ^= r4;\n    r2 &= r4;\n    r2 ^= r0;\n    r0 &= r1;\n    r3 ^= r0;\n    r4 |= r1;\n    r4 ^= r0;\n    r0 |= r3;\n    r0 ^= r2;\n    r2 &= r3;\n    r0 = !r0;\n    r4 ^= r2;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r3; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (96));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (96 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (96 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (96 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r0;\n    r0 |= r3;\n    r3 ^= r1;\n    r1 &= r4;\n    r4 ^= r2;\n    r2 ^= r3;\n    r3 &= r0;\n    r4 |= r1;\n    r3 ^= r4;\n    r0 ^= r1;\n    r4 &= r0;\n    r1 ^= r3;\n    r4 ^= r2;\n    r1 |= r0;\n    r1 ^= r2;\n    r0 ^= r3;\n    r2 = r1;\n    r1 |= r3;\n    r1 ^= r0;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r4;\n}", "item_id": 0, "repo": "newpavlov/rust-crypto-decoupled", "file": "symmetric/sosemanuk/src/lib.rs", "last_update_at": "2019-03-24T21:24:27+00:00", "question_id": "c344fa3db7b65c0e0ee11fb74ac3c1959837b23b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn key_setup(key : &[u8], subkeys : &mut[u32; 100]) {\n    let mut full_key : [u8; 32] = [0; 32];\n    if key.len() < 32 {\n        copy_memory(&key, &mut full_key[0..key.len()]);\n        full_key[key.len()] = 0x01;\n    } else {\n        copy_memory(&key[0..32], &mut full_key[0..32]);\n    }\n    let mut w0 = read_u32_le(&full_key[0..4]);\n    let mut w1 = read_u32_le(&full_key[4..8]);\n    let mut w2 = read_u32_le(&full_key[8..12]);\n    let mut w3 = read_u32_le(&full_key[12..16]);\n    let mut w4 = read_u32_le(&full_key[16..20]);\n    let mut w5 = read_u32_le(&full_key[20..24]);\n    let mut w6 = read_u32_le(&full_key[24..28]);\n    let mut w7 = read_u32_le(&full_key[28..32]);\n    let mut r0 : u32;\n    let mut r1 : u32;\n    let mut r2 : u32;\n    let mut r3 : u32;\n    let mut r4 : u32;\n    let mut tt : u32;\n    let mut i = 0;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (0));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (0 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (0 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (0 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r0;\n    r0 |= r3;\n    r3 ^= r1;\n    r1 &= r4;\n    r4 ^= r2;\n    r2 ^= r3;\n    r3 &= r0;\n    r4 |= r1;\n    r3 ^= r4;\n    r0 ^= r1;\n    r4 &= r0;\n    r1 ^= r3;\n    r4 ^= r2;\n    r1 |= r0;\n    r1 ^= r2;\n    r0 ^= r3;\n    r2 = r1;\n    r1 |= r3;\n    r1 ^= r0;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r4; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (4));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (4 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (4 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (4 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r4 = r0;\n    r0 &= r2;\n    r0 ^= r3;\n    r2 ^= r1;\n    r2 ^= r0;\n    r3 |= r4;\n    r3 ^= r1;\n    r4 ^= r2;\n    r1 = r3;\n    r3 |= r4;\n    r3 ^= r0;\n    r0 &= r1;\n    r4 ^= r0;\n    r1 ^= r3;\n    r1 ^= r4;\n    r4 = !r4;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (8));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (8 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (8 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (8 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r0 = !r0;\n    r2 = !r2;\n    r4 = r0;\n    r0 &= r1;\n    r2 ^= r0;\n    r0 |= r3;\n    r3 ^= r2;\n    r1 ^= r0;\n    r0 ^= r4;\n    r4 |= r1;\n    r1 ^= r3;\n    r2 |= r0;\n    r2 &= r4;\n    r0 ^= r1;\n    r1 &= r2;\n    r1 ^= r0;\n    r0 &= r2;\n    r0 ^= r4;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (12));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (12 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (12 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (12 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r3 ^= r0;\n    r4 = r1;\n    r1 &= r3;\n    r4 ^= r2;\n    r1 ^= r0;\n    r0 |= r3;\n    r0 ^= r4;\n    r4 ^= r3;\n    r3 ^= r2;\n    r2 |= r1;\n    r2 ^= r4;\n    r4 = !r4;\n    r4 |= r1;\n    r1 ^= r3;\n    r1 ^= r4;\n    r3 |= r0;\n    r1 ^= r3;\n    r4 ^= r3;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r0; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (16));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (16 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (16 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (16 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r1;\n    r1 |= r2;\n    r1 ^= r3;\n    r4 ^= r2;\n    r2 ^= r1;\n    r3 |= r4;\n    r3 &= r0;\n    r4 ^= r2;\n    r3 ^= r1;\n    r1 |= r4;\n    r1 ^= r0;\n    r0 |= r4;\n    r0 ^= r2;\n    r1 ^= r4;\n    r2 ^= r1;\n    r1 &= r0;\n    r1 ^= r4;\n    r2 = !r2;\n    r2 |= r0;\n    r4 ^= r2;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r0; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (20));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (20 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (20 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (20 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r2 = !r2;\n    r4 = r3;\n    r3 &= r0;\n    r0 ^= r4;\n    r3 ^= r2;\n    r2 |= r4;\n    r1 ^= r3;\n    r2 ^= r0;\n    r0 |= r1;\n    r2 ^= r1;\n    r4 ^= r0;\n    r0 |= r3;\n    r0 ^= r2;\n    r4 ^= r3;\n    r4 ^= r0;\n    r3 = !r3;\n    r2 &= r4;\n    r2 ^= r3;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r2; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (24));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (24 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (24 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (24 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r0 ^= r1;\n    r1 ^= r3;\n    r3 = !r3;\n    r4 = r1;\n    r1 &= r0;\n    r2 ^= r3;\n    r1 ^= r2;\n    r2 |= r4;\n    r4 ^= r3;\n    r3 &= r1;\n    r3 ^= r0;\n    r4 ^= r1;\n    r4 ^= r2;\n    r2 ^= r0;\n    r0 &= r3;\n    r2 = !r2;\n    r0 ^= r4;\n    r4 |= r3;\n    r2 ^= r4;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r2; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (28));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (28 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (28 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (28 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r1 ^= r3;\n    r3 = !r3;\n    r2 ^= r3;\n    r3 ^= r0;\n    r4 = r1;\n    r1 &= r3;\n    r1 ^= r2;\n    r4 ^= r3;\n    r0 ^= r4;\n    r2 &= r4;\n    r2 ^= r0;\n    r0 &= r1;\n    r3 ^= r0;\n    r4 |= r1;\n    r4 ^= r0;\n    r0 |= r3;\n    r0 ^= r2;\n    r2 &= r3;\n    r0 = !r0;\n    r4 ^= r2;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r3; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (32));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (32 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (32 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (32 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r0;\n    r0 |= r3;\n    r3 ^= r1;\n    r1 &= r4;\n    r4 ^= r2;\n    r2 ^= r3;\n    r3 &= r0;\n    r4 |= r1;\n    r3 ^= r4;\n    r0 ^= r1;\n    r4 &= r0;\n    r1 ^= r3;\n    r4 ^= r2;\n    r1 |= r0;\n    r1 ^= r2;\n    r0 ^= r3;\n    r2 = r1;\n    r1 |= r3;\n    r1 ^= r0;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r4; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (36));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (36 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (36 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (36 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r4 = r0;\n    r0 &= r2;\n    r0 ^= r3;\n    r2 ^= r1;\n    r2 ^= r0;\n    r3 |= r4;\n    r3 ^= r1;\n    r4 ^= r2;\n    r1 = r3;\n    r3 |= r4;\n    r3 ^= r0;\n    r0 &= r1;\n    r4 ^= r0;\n    r1 ^= r3;\n    r1 ^= r4;\n    r4 = !r4;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (40));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (40 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (40 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (40 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r0 = !r0;\n    r2 = !r2;\n    r4 = r0;\n    r0 &= r1;\n    r2 ^= r0;\n    r0 |= r3;\n    r3 ^= r2;\n    r1 ^= r0;\n    r0 ^= r4;\n    r4 |= r1;\n    r1 ^= r3;\n    r2 |= r0;\n    r2 &= r4;\n    r0 ^= r1;\n    r1 &= r2;\n    r1 ^= r0;\n    r0 &= r2;\n    r0 ^= r4;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (44));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (44 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (44 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (44 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r3 ^= r0;\n    r4 = r1;\n    r1 &= r3;\n    r4 ^= r2;\n    r1 ^= r0;\n    r0 |= r3;\n    r0 ^= r4;\n    r4 ^= r3;\n    r3 ^= r2;\n    r2 |= r1;\n    r2 ^= r4;\n    r4 = !r4;\n    r4 |= r1;\n    r1 ^= r3;\n    r1 ^= r4;\n    r3 |= r0;\n    r1 ^= r3;\n    r4 ^= r3;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r0; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (48));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (48 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (48 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (48 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r1;\n    r1 |= r2;\n    r1 ^= r3;\n    r4 ^= r2;\n    r2 ^= r1;\n    r3 |= r4;\n    r3 &= r0;\n    r4 ^= r2;\n    r3 ^= r1;\n    r1 |= r4;\n    r1 ^= r0;\n    r0 |= r4;\n    r0 ^= r2;\n    r1 ^= r4;\n    r2 ^= r1;\n    r1 &= r0;\n    r1 ^= r4;\n    r2 = !r2;\n    r2 |= r0;\n    r4 ^= r2;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r0; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (52));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (52 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (52 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (52 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r2 = !r2;\n    r4 = r3;\n    r3 &= r0;\n    r0 ^= r4;\n    r3 ^= r2;\n    r2 |= r4;\n    r1 ^= r3;\n    r2 ^= r0;\n    r0 |= r1;\n    r2 ^= r1;\n    r4 ^= r0;\n    r0 |= r3;\n    r0 ^= r2;\n    r4 ^= r3;\n    r4 ^= r0;\n    r3 = !r3;\n    r2 &= r4;\n    r2 ^= r3;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r2; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (56));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (56 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (56 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (56 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r0 ^= r1;\n    r1 ^= r3;\n    r3 = !r3;\n    r4 = r1;\n    r1 &= r0;\n    r2 ^= r3;\n    r1 ^= r2;\n    r2 |= r4;\n    r4 ^= r3;\n    r3 &= r1;\n    r3 ^= r0;\n    r4 ^= r1;\n    r4 ^= r2;\n    r2 ^= r0;\n    r0 &= r3;\n    r2 = !r2;\n    r0 ^= r4;\n    r4 |= r3;\n    r2 ^= r4;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r2; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (60));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (60 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (60 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (60 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r1 ^= r3;\n    r3 = !r3;\n    r2 ^= r3;\n    r3 ^= r0;\n    r4 = r1;\n    r1 &= r3;\n    r1 ^= r2;\n    r4 ^= r3;\n    r0 ^= r4;\n    r2 &= r4;\n    r2 ^= r0;\n    r0 &= r1;\n    r3 ^= r0;\n    r4 |= r1;\n    r4 ^= r0;\n    r0 |= r3;\n    r0 ^= r2;\n    r2 &= r3;\n    r0 = !r0;\n    r4 ^= r2;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r3; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (64));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (64 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (64 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (64 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r0;\n    r0 |= r3;\n    r3 ^= r1;\n    r1 &= r4;\n    r4 ^= r2;\n    r2 ^= r3;\n    r3 &= r0;\n    r4 |= r1;\n    r3 ^= r4;\n    r0 ^= r1;\n    r4 &= r0;\n    r1 ^= r3;\n    r4 ^= r2;\n    r1 |= r0;\n    r1 ^= r2;\n    r0 ^= r3;\n    r2 = r1;\n    r1 |= r3;\n    r1 ^= r0;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r4; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (68));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (68 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (68 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (68 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r4 = r0;\n    r0 &= r2;\n    r0 ^= r3;\n    r2 ^= r1;\n    r2 ^= r0;\n    r3 |= r4;\n    r3 ^= r1;\n    r4 ^= r2;\n    r1 = r3;\n    r3 |= r4;\n    r3 ^= r0;\n    r0 &= r1;\n    r4 ^= r0;\n    r1 ^= r3;\n    r1 ^= r4;\n    r4 = !r4;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (72));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (72 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (72 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (72 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r0 = !r0;\n    r2 = !r2;\n    r4 = r0;\n    r0 &= r1;\n    r2 ^= r0;\n    r0 |= r3;\n    r3 ^= r2;\n    r1 ^= r0;\n    r0 ^= r4;\n    r4 |= r1;\n    r1 ^= r3;\n    r2 |= r0;\n    r2 &= r4;\n    r0 ^= r1;\n    r1 &= r2;\n    r1 ^= r0;\n    r0 &= r2;\n    r0 ^= r4;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (76));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (76 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (76 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (76 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r3 ^= r0;\n    r4 = r1;\n    r1 &= r3;\n    r4 ^= r2;\n    r1 ^= r0;\n    r0 |= r3;\n    r0 ^= r4;\n    r4 ^= r3;\n    r3 ^= r2;\n    r2 |= r1;\n    r2 ^= r4;\n    r4 = !r4;\n    r4 |= r1;\n    r1 ^= r3;\n    r1 ^= r4;\n    r3 |= r0;\n    r1 ^= r3;\n    r4 ^= r3;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r0; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (80));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (80 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (80 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (80 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r1;\n    r1 |= r2;\n    r1 ^= r3;\n    r4 ^= r2;\n    r2 ^= r1;\n    r3 |= r4;\n    r3 &= r0;\n    r4 ^= r2;\n    r3 ^= r1;\n    r1 |= r4;\n    r1 ^= r0;\n    r0 |= r4;\n    r0 ^= r2;\n    r1 ^= r4;\n    r2 ^= r1;\n    r1 &= r0;\n    r1 ^= r4;\n    r2 = !r2;\n    r2 |= r0;\n    r4 ^= r2;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r0; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (84));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (84 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (84 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (84 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r2 = !r2;\n    r4 = r3;\n    r3 &= r0;\n    r0 ^= r4;\n    r3 ^= r2;\n    r2 |= r4;\n    r1 ^= r3;\n    r2 ^= r0;\n    r0 |= r1;\n    r2 ^= r1;\n    r4 ^= r0;\n    r0 |= r3;\n    r0 ^= r2;\n    r4 ^= r3;\n    r4 ^= r0;\n    r3 = !r3;\n    r2 &= r4;\n    r2 ^= r3;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r2; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (88));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (88 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (88 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (88 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r0 ^= r1;\n    r1 ^= r3;\n    r3 = !r3;\n    r4 = r1;\n    r1 &= r0;\n    r2 ^= r3;\n    r1 ^= r2;\n    r2 |= r4;\n    r4 ^= r3;\n    r3 &= r1;\n    r3 ^= r0;\n    r4 ^= r1;\n    r4 ^= r2;\n    r2 ^= r0;\n    r0 &= r3;\n    r2 = !r2;\n    r0 ^= r4;\n    r4 |= r3;\n    r2 ^= r4;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r2; i+=1;\n    tt = w4 ^ w7 ^ w1 ^ w3 ^ (0x9E3779B9 ^ (92));\n    w4 = tt.rotate_left(11);\n    tt = w5 ^ w0 ^ w2 ^ w4 ^ (0x9E3779B9 ^ (92 + 1));\n    w5 = tt.rotate_left(11);\n    tt = w6 ^ w1 ^ w3 ^ w5 ^ (0x9E3779B9 ^ (92 + 2));\n    w6 = tt.rotate_left(11);\n    tt = w7 ^ w2 ^ w4 ^ w6 ^ (0x9E3779B9 ^ (92 + 3));\n    w7 = tt.rotate_left(11);\n    r0 = w4;\n    r1 = w5;\n    r2 = w6;\n    r3 = w7;\n    r1 ^= r3;\n    r3 = !r3;\n    r2 ^= r3;\n    r3 ^= r0;\n    r4 = r1;\n    r1 &= r3;\n    r1 ^= r2;\n    r4 ^= r3;\n    r0 ^= r4;\n    r2 &= r4;\n    r2 ^= r0;\n    r0 &= r1;\n    r3 ^= r0;\n    r4 |= r1;\n    r4 ^= r0;\n    r0 |= r3;\n    r0 ^= r2;\n    r2 &= r3;\n    r0 = !r0;\n    r4 ^= r2;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r4; i+=1;\n    subkeys[i] = r0; i+=1;\n    subkeys[i] = r3; i+=1;\n    tt = w0 ^ w3 ^ w5 ^ w7 ^ (0x9E3779B9 ^ (96));\n    w0 = tt.rotate_left(11);\n    tt = w1 ^ w4 ^ w6 ^ w0 ^ (0x9E3779B9 ^ (96 + 1));\n    w1 = tt.rotate_left(11);\n    tt = w2 ^ w5 ^ w7 ^ w1 ^ (0x9E3779B9 ^ (96 + 2));\n    w2 = tt.rotate_left(11);\n    tt = w3 ^ w6 ^ w0 ^ w2 ^ (0x9E3779B9 ^ (96 + 3));\n    w3 = tt.rotate_left(11);\n    r0 = w0;\n    r1 = w1;\n    r2 = w2;\n    r3 = w3;\n    r4 = r0;\n    r0 |= r3;\n    r3 ^= r1;\n    r1 &= r4;\n    r4 ^= r2;\n    r2 ^= r3;\n    r3 &= r0;\n    r4 |= r1;\n    r3 ^= r4;\n    r0 ^= r1;\n    r4 &= r0;\n    r1 ^= r3;\n    r4 ^= r2;\n    r1 |= r0;\n    r1 ^= r2;\n    r0 ^= r3;\n    r2 = r1;\n    r1 |= r3;\n    r1 ^= r0;\n    subkeys[i] = r1; i+=1;\n    subkeys[i] = r2; i+=1;\n    subkeys[i] = r3; i+=1;\n    subkeys[i] = r4;\n"]]}
{"hexsha": "5d810dfc3fb38aa1d745632ba2beb5ec1334ab6b", "ext": "rs", "lang": "Rust", "content": "fn callsite_disabled_includes_directive_field_no_value() {\n        let filter = EnvFilter::from(\"app[mySpan{field}]=debug\");\n        let store = Store::with_capacity(1);\n        let ctx = Context::new(&store, &NewRecorder);\n        let meta = Metadata::new(\n            \"mySpan\",\n            \"app\",\n            Level::TRACE,\n            None,\n            None,\n            None,\n            FieldSet::new(&[\"field=\\\"value\\\"\"], identify_callsite!(&Cs)),\n            Kind::SPAN,\n        );\n\n        let interest = filter.callsite_enabled(&meta, &ctx);\n        assert!(interest.is_always());\n    }", "item_id": 5, "repo": "waywardmonkeys/tracing", "file": "tracing-fmt/src/filter/env.rs", "last_update_at": "2019-06-30T14:43:11+00:00", "question_id": "5d810dfc3fb38aa1d745632ba2beb5ec1334ab6b_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn callsite_disabled_includes_directive_field_no_value() {\n        let filter = EnvFilter::from(\"app[mySpan{field}]=debug\");\n        let store = Store::with_capacity(1);\n        let ctx = Context::new(&store, &NewRecorder);\n        let meta = Metadata::new(\n            \"mySpan\",\n            \"app\",\n            Level::TRACE,\n            None,\n            None,\n            None,\n            FieldSet::new(&[\"field=\\\"value\\\"\"], identify_callsite!(&Cs)),\n            Kind::SPAN,\n        );\n        let interest = filter.callsite_enabled(&meta, &ctx);\n        assert!(interest.is_always());\n"]]}
{"hexsha": "cc43ac73689f0af0c58a101f178c1c084da8e0a4", "ext": "rs", "lang": "Rust", "content": "fn gen_colors() -> Result<()> {\n    let map_name = \"COLORS\";\n    let struct_name = \"Color\";\n\n    let mut spec = String::new();\n    fs::File::open(\"spec/colors.txt\")?.read_to_string(&mut spec)?;\n\n    let mut map = phf_codegen::Map::new();\n    for (line1, line2) in spec.split('\\n').filter(|s| !s.is_empty()).tuples() {\n        let rgb: Vec<&str> = line2.split(',').collect();\n        map.entry(line1, &format!(\"{} {{ red: {}, green: {}, blue: {} }}\",\n                                  struct_name, rgb[0], rgb[1], rgb[2]));\n    }\n\n    let mut map_data = Vec::new();\n    map.build(&mut map_data)?;\n    let map_data = str::from_utf8(&map_data)?;\n\n\n    let f = &mut fs::File::create(\"../src/color/colors.rs\")?;\n\n    write_header(f)?;\n\n    writeln!(f, \"use {};\\n\", struct_name)?;\n\n    writeln!(f, \"static {}: ::phf::Map<&'static str, {}> = {};\\n\", map_name, struct_name, map_data)?;\n\n    writeln!(f, \"pub fn from_str(text: &str) -> Option<{}> {{\", struct_name)?;\n    writeln!(f, \"    {}.get(text).cloned()\", map_name)?;\n    writeln!(f, \"}}\")?;\n\n    Ok(())\n}", "item_id": 2, "repo": "sahwar/svgtypes", "file": "codegen/src/main.rs", "last_update_at": "2019-04-14T20:19:08+00:00", "question_id": "cc43ac73689f0af0c58a101f178c1c084da8e0a4_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn gen_colors() -> Result<()> {\n    let map_name = \"COLORS\";\n    let struct_name = \"Color\";\n    let mut spec = String::new();\n    fs::File::open(\"spec/colors.txt\")?.read_to_string(&mut spec)?;\n    let mut map = phf_codegen::Map::new();\n    for (line1, line2) in spec.split('\\n').filter(|s| !s.is_empty()).tuples() {\n        let rgb: Vec<&str> = line2.split(',').collect();\n        map.entry(line1, &format!(\"{} {{ red: {}, green: {}, blue: {} }}\",\n                                  struct_name, rgb[0], rgb[1], rgb[2]));\n    }\n    let mut map_data = Vec::new();\n    map.build(&mut map_data)?;\n    let map_data = str::from_utf8(&map_data)?;\n    let f = &mut fs::File::create(\"../src/color/colors.rs\")?;\n    write_header(f)?;\n    writeln!(f, \"use {};\\n\", struct_name)?;\n    writeln!(f, \"static {}: ::phf::Map<&'static str, {}> = {};\\n\", map_name, struct_name, map_data)?;\n    writeln!(f, \"pub fn from_str(text: &str) -> Option<{}> {{\", struct_name)?;\n    writeln!(f, \"    {}.get(text).cloned()\", map_name)?;\n    writeln!(f, \"}}\")?;\n    Ok(())\n"]]}
{"hexsha": "a5201ec3af959eda63b49a7592dd407ddd518af6", "ext": "rs", "lang": "Rust", "content": "fn get_and_notify(\n    cache: &Cache,\n    installation_allowed: bool,\n    name: &str,\n    url: &str,\n) -> Result<Option<PathBuf>, failure::Error> {\n    if let Some(dl) = cache.download(false, name, &[name], &url)? {\n        return Ok(Some(dl.binary(name)?));\n    }\n    if installation_allowed {\n        PBAR.info(&format!(\"Getting {}...\", name));\n    }\n    match cache.download(installation_allowed, name, &[name], &url)? {\n        Some(dl) => Ok(Some(dl.binary(name)?)),\n        None => Ok(None),\n    }\n}", "item_id": 0, "repo": "csmoe/wasm-pack", "file": "src/test/webdriver.rs", "last_update_at": "2019-10-10T09:27:38+00:00", "question_id": "a5201ec3af959eda63b49a7592dd407ddd518af6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_and_notify(\n    cache: &Cache,\n    installation_allowed: bool,\n    name: &str,\n    url: &str,\n) -> Result<Option<PathBuf>, failure::Error> {\n    if let Some(dl) = cache.download(false, name, &[name], &url)? {\n        return Ok(Some(dl.binary(name)?));\n    }\n    if installation_allowed {\n        PBAR.info(&format!(\"Getting {}...\", name));\n    }\n    match cache.download(installation_allowed, name, &[name], &url)? {\n        Some(dl) => Ok(Some(dl.binary(name)?)),\n        None => Ok(None),\n    }\n"]]}
{"hexsha": "554ea24a982ed06686ab286aa2b63066542e978e", "ext": "rs", "lang": "Rust", "content": "fn test_phys_dist() {\n        let sf = Coordinate {\n            latitude: 37.774929,\n            longitude: -122.419416,\n        };\n        let nyc = Coordinate {\n            latitude: 40.730610,\n            longitude: -73.935242,\n        };\n        assert_eq!(CityData::find_distance_earth(sf, nyc), 4135.694);\n    }", "item_id": 3, "repo": "PrismaPhonic/city-spellcheck-lib", "file": "src/lib.rs", "last_update_at": "2019-09-17T09:02:45+00:00", "question_id": "554ea24a982ed06686ab286aa2b63066542e978e_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_phys_dist() {\n        let sf = Coordinate {\n            latitude: 37.774929,\n            longitude: -122.419416,\n        };\n        let nyc = Coordinate {\n            latitude: 40.730610,\n            longitude: -73.935242,\n        };\n        assert_eq!(CityData::find_distance_earth(sf, nyc), 4135.694);\n"]]}
{"hexsha": "41c90c2cd1d2cd60d973394720f52d1df142125d", "ext": "rs", "lang": "Rust", "content": "fn test_non_bmp() {\n        let gil = Python::acquire_gil();\n        let py = gil.python();\n        let s = \"\\u{1F30F}\";\n        let py_string = s.to_object(py);\n        assert_eq!(s, py_string.extract::<String>(py).unwrap());\n    }", "item_id": 0, "repo": "chr1sj0nes/pyo3", "file": "src/types/string.rs", "last_update_at": "2019-10-06T11:46:45+00:00", "question_id": "41c90c2cd1d2cd60d973394720f52d1df142125d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_non_bmp() {\n        let gil = Python::acquire_gil();\n        let py = gil.python();\n        let s = \"\\u{1F30F}\";\n        let py_string = s.to_object(py);\n        assert_eq!(s, py_string.extract::<String>(py).unwrap());\n"]]}
{"hexsha": "b55f3757e31b3470f618ee22cd5a891f077f27a3", "ext": "rs", "lang": "Rust", "content": "fn encode(input: String, output: String) -> io::Result<()> {\n    let mut input_file = File::open(input)?;\n    let output_file = File::create(output)?;\n    let mut output_writer = io::BufWriter::new(output_file);\n\n    let input_copy = input_file.try_clone()?;\n    let freqs = coding::Frequencies::count_bytes(input_copy.bytes())?;\n    freqs.write(&mut output_writer)?;\n\n    let tree = coding::HuffTree::from_freqs(&freqs);\n    let mut encoder = coding::HuffWriter::from_tree(&tree);\n    input_file.seek(io::SeekFrom::Start(0))?;\n    for maybe_byte in input_file.bytes() {\n        let byte = maybe_byte?;\n        encoder.write_byte(byte, &mut output_writer)?;\n    }\n    encoder.end_transmission(&mut output_writer)\n}", "item_id": 0, "repo": "cronokirby/huffman-rs", "file": "src/cli.rs", "last_update_at": "2019-03-13T21:26:13+00:00", "question_id": "b55f3757e31b3470f618ee22cd5a891f077f27a3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn encode(input: String, output: String) -> io::Result<()> {\n    let mut input_file = File::open(input)?;\n    let output_file = File::create(output)?;\n    let mut output_writer = io::BufWriter::new(output_file);\n    let input_copy = input_file.try_clone()?;\n    let freqs = coding::Frequencies::count_bytes(input_copy.bytes())?;\n    freqs.write(&mut output_writer)?;\n    let tree = coding::HuffTree::from_freqs(&freqs);\n    let mut encoder = coding::HuffWriter::from_tree(&tree);\n    input_file.seek(io::SeekFrom::Start(0))?;\n    for maybe_byte in input_file.bytes() {\n        let byte = maybe_byte?;\n        encoder.write_byte(byte, &mut output_writer)?;\n    }\n    encoder.end_transmission(&mut output_writer)\n"]]}
{"hexsha": "72a5da63e57c036abb84e0762d6a85bef40559a3", "ext": "rs", "lang": "Rust", "content": "pub fn find_char_3(b: &mut Bencher) {\n    let haystack = black_box(LONG);\n    let needle = black_box('\u03b1');\n    b.iter(|| {\n        let t = haystack.find(needle);\n        t\n    });\n    b.bytes = haystack.len() as u64;\n}", "item_id": 4, "repo": "strake/subslice.rs", "file": "benches/pathology.rs", "last_update_at": "2019-12-18T07:50:05+00:00", "question_id": "72a5da63e57c036abb84e0762d6a85bef40559a3_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn find_char_3(b: &mut Bencher) {\n    let haystack = black_box(LONG);\n    let needle = black_box('\u03b1');\n    b.iter(|| {\n        let t = haystack.find(needle);\n        t\n    });\n    b.bytes = haystack.len() as u64;\n"]]}
{"hexsha": "7b350788bb594d096c9ec534f6ed57c1e148fea9", "ext": "rs", "lang": "Rust", "content": "pub fn public_to_address(public: &Public) -> Address {\n\tlet hash = public.keccak256();\n\tlet mut result = Address::zero();\n\tresult.as_bytes_mut().copy_from_slice(&hash[12..]);\n\tresult\n}", "item_id": 0, "repo": "altice-io/Daqiao", "file": "bridge/parity-ethereum/accounts/ethkey/src/keypair.rs", "last_update_at": "2019-09-11T12:07:35+00:00", "question_id": "7b350788bb594d096c9ec534f6ed57c1e148fea9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn public_to_address(public: &Public) -> Address {\n\tlet hash = public.keccak256();\n\tlet mut result = Address::zero();\n\tresult.as_bytes_mut().copy_from_slice(&hash[12..]);\n\tresult\n"]]}
{"hexsha": "f1611a42999396da85535c1b551efb06595e8fea", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn _mi_segment_try_reclaim_abandoned(mut heap:\n                                                               *mut mi_heap_t,\n                                                           mut try_all: bool,\n                                                           mut tld:\n                                                               &mut mi_segments_tld_t)\n -> bool {\n    let mut reclaimed = 0;\n    let mut atmost: usize;\n    if try_all != 0 {\n        atmost = abandoned_count + 16;\n    } else { atmost = abandoned_count / 8; if atmost < 8 { atmost = 8; }; }\n    // for `atmost` `reclaimed` abandoned segments...\n    while atmost > reclaimed\n          { // try to claim the head of the abandoned segments\n        let mut segment:\n                *mut mi_segment_t; // stop early if no more segments available\n        loop  {\n            segment = abandoned as *mut mi_segment_t; // got it.\n            if !(!segment.is_null() &&\n                     !mi_atomic_compare_exchange_ptr(&mut abandoned as\n                                                         *mut *mut c_void,\n                                                     segment.abandoned_next as\n                                                         *mut _,\n                                                     segment as *mut _)) {\n                break\n            }; // add its free pages to the the current thread\n        } // add its abandoned pages to the current thread\n        if segment.is_null() {\n            break ; // if everything free by now, free the page\n        } // otherwise reclaim it\n        mi_atomic_decrement(&mut abandoned_count); // due to page_clear\n        segment.thread_id = _mi_thread_id();\n        segment.abandoned_next = ptr::null_mut();\n        mi_segments_count_add(1, tld);\n        _mi_stat_decrease(&mut (tld.stats.segments_abandoned), 1);\n        if segment.page_kind == MI_PAGE_SMALL &&\n               mi_segment_has_free(segment) != 0 {\n            mi_segment_enqueue(&mut tld.small_free, segment);\n        }\n        if segment.abandoned == segment.used {\n            0\n        } else {\n            _mi_assert_fail(\"segment->abandoned == segment->used\",\n                            \"src/segment.c\", 548,\n                            \"_mi_segment_try_reclaim_abandoned\")\n        }\n        for mut i in 0..segment.capacity {\n            let mut page = &mut segment.pages[i];\n            if page.segment_in_use != 0 {\n                segment.abandoned -= 1;\n                if page.next.is_null() {\n                    0\n                } else {\n                    _mi_assert_fail(\"page->next == NULL\", \"src/segment.c\",\n                                    553, \"_mi_segment_try_reclaim_abandoned\")\n                }\n                _mi_stat_decrease(&mut (tld.stats.pages_abandoned), 1);\n                if mi_page_all_free(page) {\n                    mi_segment_page_clear(segment, page, tld.stats);\n                } else { _mi_page_reclaim(heap, page); };\n            };\n        }\n        if segment.abandoned == 0 {\n            0\n        } else {\n            _mi_assert_fail(\"segment->abandoned == 0\", \"src/segment.c\", 565,\n                            \"_mi_segment_try_reclaim_abandoned\")\n        }\n        if segment.used == 0 {\n            mi_segment_free(segment, false, tld);\n        } else { reclaimed += 1; };\n    }\n    return (reclaimed > 0);\n}", "item_id": 18, "repo": "rusch95/mimalloc-rs", "file": "mimalloc-sys/rust_impl/citrus/segment.rs", "last_update_at": "2019-10-20T05:44:39+00:00", "question_id": "f1611a42999396da85535c1b551efb06595e8fea_18", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn _mi_segment_try_reclaim_abandoned(mut heap:\n                                                               *mut mi_heap_t,\n                                                           mut try_all: bool,\n                                                           mut tld:\n                                                               &mut mi_segments_tld_t)\n -> bool {\n    let mut reclaimed = 0;\n    let mut atmost: usize;\n    if try_all != 0 {\n        atmost = abandoned_count + 16;\n    } else { atmost = abandoned_count / 8; if atmost < 8 { atmost = 8; }; }\n    // for `atmost` `reclaimed` abandoned segments...\n    while atmost > reclaimed\n          { // try to claim the head of the abandoned segments\n        let mut segment:\n                *mut mi_segment_t; // stop early if no more segments available\n        loop  {\n            segment = abandoned as *mut mi_segment_t; // got it.\n            if !(!segment.is_null() &&\n                     !mi_atomic_compare_exchange_ptr(&mut abandoned as\n                                                         *mut *mut c_void,\n                                                     segment.abandoned_next as\n                                                         *mut _,\n                                                     segment as *mut _)) {\n                break\n            }; // add its free pages to the the current thread\n        } // add its abandoned pages to the current thread\n        if segment.is_null() {\n            break ; // if everything free by now, free the page\n        } // otherwise reclaim it\n        mi_atomic_decrement(&mut abandoned_count); // due to page_clear\n        segment.thread_id = _mi_thread_id();\n        segment.abandoned_next = ptr::null_mut();\n        mi_segments_count_add(1, tld);\n        _mi_stat_decrease(&mut (tld.stats.segments_abandoned), 1);\n        if segment.page_kind == MI_PAGE_SMALL &&\n               mi_segment_has_free(segment) != 0 {\n            mi_segment_enqueue(&mut tld.small_free, segment);\n        }\n        if segment.abandoned == segment.used {\n            0\n        } else {\n            _mi_assert_fail(\"segment->abandoned == segment->used\",\n                            \"src/segment.c\", 548,\n                            \"_mi_segment_try_reclaim_abandoned\")\n        }\n        for mut i in 0..segment.capacity {\n            let mut page = &mut segment.pages[i];\n            if page.segment_in_use != 0 {\n                segment.abandoned -= 1;\n                if page.next.is_null() {\n                    0\n                } else {\n                    _mi_assert_fail(\"page->next == NULL\", \"src/segment.c\",\n                                    553, \"_mi_segment_try_reclaim_abandoned\")\n                }\n                _mi_stat_decrease(&mut (tld.stats.pages_abandoned), 1);\n                if mi_page_all_free(page) {\n                    mi_segment_page_clear(segment, page, tld.stats);\n                } else { _mi_page_reclaim(heap, page); };\n            };\n        }\n        if segment.abandoned == 0 {\n            0\n        } else {\n            _mi_assert_fail(\"segment->abandoned == 0\", \"src/segment.c\", 565,\n                            \"_mi_segment_try_reclaim_abandoned\")\n        }\n        if segment.used == 0 {\n            mi_segment_free(segment, false, tld);\n        } else { reclaimed += 1; };\n    }\n    return (reclaimed > 0);\n"]]}
{"hexsha": "044c972a94bac860ba918be56fce5a72a4aa0bf4", "ext": "rs", "lang": "Rust", "content": "fn find_node_string() {\n    let expr = compile_expression(r#\" \"ok\" \"#);\n    assert_eq!(expr.find_node(0), None);\n    assert_eq!(expr.find_node(1), Some(&expr));\n    assert_eq!(expr.find_node(4), Some(&expr));\n    assert_eq!(expr.find_node(5), None);\n}", "item_id": 3, "repo": "HarryET/gleam", "file": "compiler-core/src/ast/tests.rs", "last_update_at": "2019-10-27T15:26:35+00:00", "question_id": "044c972a94bac860ba918be56fce5a72a4aa0bf4_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn find_node_string() {\n    let expr = compile_expression(r#\" \"ok\" \"#);\n    assert_eq!(expr.find_node(0), None);\n    assert_eq!(expr.find_node(1), Some(&expr));\n    assert_eq!(expr.find_node(4), Some(&expr));\n    assert_eq!(expr.find_node(5), None);\n"]]}
{"hexsha": "738d566614aa665f09309550580c3db3be969668", "ext": "rs", "lang": "Rust", "content": "fn given_u8_byte_then_get_bits_values() {\n        let a: u8 = 0xff;\n        let b: u8 = 0x00;\n        let c: u8 = 0x3a;\n\n        assert_eq!(\n            bits_of_byte(a),\n            [true, true, true, true, true, true, true, true]\n        );\n        assert_eq!(\n            bits_of_byte(b),\n            [false, false, false, false, false, false, false, false]\n        );\n        assert_eq!(\n            bits_of_byte(c),\n            [false, false, true, true, true, false, true, false]\n        );\n    }", "item_id": 17, "repo": "Cutii/enocean", "file": "src/eep.rs", "last_update_at": "2019-02-20T09:45:44+00:00", "question_id": "738d566614aa665f09309550580c3db3be969668_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn given_u8_byte_then_get_bits_values() {\n        let a: u8 = 0xff;\n        let b: u8 = 0x00;\n        let c: u8 = 0x3a;\n        assert_eq!(\n            bits_of_byte(a),\n            [true, true, true, true, true, true, true, true]\n        );\n        assert_eq!(\n            bits_of_byte(b),\n            [false, false, false, false, false, false, false, false]\n        );\n        assert_eq!(\n            bits_of_byte(c),\n            [false, false, true, true, true, false, true, false]\n        );\n"]]}
{"hexsha": "41445f7e7713b22a4f3c28baea17f96cd2e21df7", "ext": "rs", "lang": "Rust", "content": "fn test_tx_persist_cooldown_refresh() {\n\t\tlet mut machine = TimedMachine::new(TestState::A);\n\t\tlet cd = Cooldown::new(Duration::from_secs(200).into(), false, false);\n\n\t\tmachine\n\t\t\t.add_priority_transition(TestState::A, TestState::B, TestAlpha::A, 1, Some(cd))\n\t\t\t.add_transition(TestState::A, TestState::C, TestAlpha::A);\n\n\t\tlet s1 = machine.advance(TestAlpha::A);\n\t\tmachine.refresh();\n\n\t\tassert_eq!(s1, Some(TestState::B));\n\t\tassert_eq!(machine.advance(TestAlpha::A), Some(TestState::C));\n\t}", "item_id": 8, "repo": "FelixMcFelix/felyne-bot", "file": "src/automata.rs", "last_update_at": "2019-07-03T21:45:38+00:00", "question_id": "41445f7e7713b22a4f3c28baea17f96cd2e21df7_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_tx_persist_cooldown_refresh() {\n\t\tlet mut machine = TimedMachine::new(TestState::A);\n\t\tlet cd = Cooldown::new(Duration::from_secs(200).into(), false, false);\n\t\tmachine\n\t\t\t.add_priority_transition(TestState::A, TestState::B, TestAlpha::A, 1, Some(cd))\n\t\t\t.add_transition(TestState::A, TestState::C, TestAlpha::A);\n\t\tlet s1 = machine.advance(TestAlpha::A);\n\t\tmachine.refresh();\n\t\tassert_eq!(s1, Some(TestState::B));\n\t\tassert_eq!(machine.advance(TestAlpha::A), Some(TestState::C));\n"]]}
{"hexsha": "c75afb5f19a284ebd979979d7ff68fda1a67d5e2", "ext": "rs", "lang": "Rust", "content": "fn read_discrete_inputs_max_quantity() {\n            let quantity = 2000;\n            let byte_count = quantity / 8;\n            let mut raw: Vec<u8> = vec![2, byte_count as u8];\n            let mut values: Vec<u8> = (0..byte_count).map(|_| 0b_1111_1111).collect();\n            raw.append(&mut values);\n            let bytes = Bytes::from(raw);\n            let rsp = Response::try_from(bytes).unwrap();\n            assert_eq!(rsp, Response::ReadDiscreteInputs(vec![true; quantity]));\n        }", "item_id": 42, "repo": "mosolovsa/tokio-modbus", "file": "src/codec/mod.rs", "last_update_at": "2019-04-03T10:10:55+00:00", "question_id": "c75afb5f19a284ebd979979d7ff68fda1a67d5e2_42", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_discrete_inputs_max_quantity() {\n            let quantity = 2000;\n            let byte_count = quantity / 8;\n            let mut raw: Vec<u8> = vec![2, byte_count as u8];\n            let mut values: Vec<u8> = (0..byte_count).map(|_| 0b_1111_1111).collect();\n            raw.append(&mut values);\n            let bytes = Bytes::from(raw);\n            let rsp = Response::try_from(bytes).unwrap();\n            assert_eq!(rsp, Response::ReadDiscreteInputs(vec![true; quantity]));\n"]]}
{"hexsha": "6e382b8d17efcf9d32903c1c8bbea7c312aa7d8c", "ext": "rs", "lang": "Rust", "content": "fn trade_payload_deserialize() {\n        let json1 = r##\"{\"e\":\"trade\",\"E\":1539264159120,\"s\":\"BNBBTC\",\"t\":29661698,\"p\":\"0.00152100\",\"q\":\"1.00000000\",\"b\":84391627,\"a\":84391631,\"T\":1539264159104,\"m\":true,\"M\":true}\"##;\n\n        let payload: Payload = serde_json::from_str(json1).unwrap();\n        let back = serde_json::to_string(&payload).unwrap();\n        assert_eq!(back.as_str(), json1);\n    }", "item_id": 0, "repo": "kvsari/sammy", "file": "fetchers/binance/src/payload.rs", "last_update_at": "2019-12-19T08:26:23+00:00", "question_id": "6e382b8d17efcf9d32903c1c8bbea7c312aa7d8c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn trade_payload_deserialize() {\n        let json1 = r##\"{\"e\":\"trade\",\"E\":1539264159120,\"s\":\"BNBBTC\",\"t\":29661698,\"p\":\"0.00152100\",\"q\":\"1.00000000\",\"b\":84391627,\"a\":84391631,\"T\":1539264159104,\"m\":true,\"M\":true}\"##;\n        let payload: Payload = serde_json::from_str(json1).unwrap();\n        let back = serde_json::to_string(&payload).unwrap();\n        assert_eq!(back.as_str(), json1);\n"]]}
{"hexsha": "14a42b31bf71bea4f1d7cc5a8752b44573a611d9", "ext": "rs", "lang": "Rust", "content": "fn test_transfer_for_store() {\n        let keypair = KeyPair::gen_keypair();\n        let data_len = 4096;\n        let provided_gas = U256::from(100_000);\n        let t = Transaction {\n            action: Action::Store,\n            value: U256::from(0),\n            data: vec![0; data_len],\n            gas: provided_gas,\n            gas_price: U256::one(),\n            nonce: U256::zero().to_string(),\n            block_limit: 100u64,\n            chain_id: 1.into(),\n            version: 2,\n        }\n        .fake_sign(keypair.address().clone());\n\n        let sender = t.sender();\n        let mut state = get_temp_state();\n        state\n            .add_balance(&sender, U256::from(18 + 100_000))\n            .unwrap();\n\n        let mut context = Context::default();\n        context.block_quota_limit = U256::from(100_000);\n\n        let block_data_provider = EVMBlockDataProvider::new(context.clone());\n\n        let state = Arc::new(RefCell::new(state));\n\n        let result = {\n            CitaExecutive::new(\n                Arc::new(block_data_provider),\n                state,\n                &context,\n                EconomicalModel::Charge,\n            )\n            .exec(&t, &BlockSysConfig::default())\n        };\n\n        let expected = ExecutionError::NotEnoughBaseGas;\n\n        assert!(result.is_err());\n        assert_eq!(result.err().unwrap(), expected);\n    }", "item_id": 10, "repo": "baajur/cita", "file": "cita-executor/core/src/cita_executive.rs", "last_update_at": "2019-11-26T10:07:48+00:00", "question_id": "14a42b31bf71bea4f1d7cc5a8752b44573a611d9_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_transfer_for_store() {\n        let keypair = KeyPair::gen_keypair();\n        let data_len = 4096;\n        let provided_gas = U256::from(100_000);\n        let t = Transaction {\n            action: Action::Store,\n            value: U256::from(0),\n            data: vec![0; data_len],\n            gas: provided_gas,\n            gas_price: U256::one(),\n            nonce: U256::zero().to_string(),\n            block_limit: 100u64,\n            chain_id: 1.into(),\n            version: 2,\n        }\n        .fake_sign(keypair.address().clone());\n        let sender = t.sender();\n        let mut state = get_temp_state();\n        state\n            .add_balance(&sender, U256::from(18 + 100_000))\n            .unwrap();\n        let mut context = Context::default();\n        context.block_quota_limit = U256::from(100_000);\n        let block_data_provider = EVMBlockDataProvider::new(context.clone());\n        let state = Arc::new(RefCell::new(state));\n        let result = {\n            CitaExecutive::new(\n                Arc::new(block_data_provider),\n                state,\n                &context,\n                EconomicalModel::Charge,\n            )\n            .exec(&t, &BlockSysConfig::default())\n        };\n        let expected = ExecutionError::NotEnoughBaseGas;\n        assert!(result.is_err());\n        assert_eq!(result.err().unwrap(), expected);\n"]]}
{"hexsha": "6ed3822fabee84a2449771b7cb685bb729c4f58d", "ext": "rs", "lang": "Rust", "content": "fn verify(tree: &sled::Tree) -> (u32, u32) {\n    // key 0 should always be the highest value, as that's where we increment\n    // at some point, it might go down by one\n    // it should never return, or go down again after that\n    let mut iter = tree.iter();\n    let highest = match iter.next() {\n        Some(Ok((_k, v))) => slice_to_u32(&*v),\n        Some(Err(e)) => panic!(\"{:?}\", e),\n        None => return (0, 0),\n    };\n\n    let highest_vec = u32_to_vec(highest);\n\n    // find how far we got\n    let mut contiguous: u32 = 0;\n    let mut lowest = 0;\n    for res in iter {\n        let (mut k, v) = res.unwrap();\n        if &v[..4] == &highest_vec[..4] {\n            contiguous += 1;\n        } else {\n            k.reverse();\n            let expected = if highest == 0 {\n                CYCLE as u32 - 1\n            } else {\n                (highest - 1) % CYCLE as u32\n            };\n            let actual = slice_to_u32(&*v);\n            assert_eq!(expected, actual);\n            lowest = actual;\n            break;\n        }\n    }\n\n    let lowest_vec = u32_to_vec(lowest);\n\n    // ensure nothing changes after this point\n    let low_beginning = u32_to_vec(contiguous + 1);\n\n    for res in tree.scan(&*low_beginning) {\n        let (mut k, v) = res.unwrap();\n        if v != lowest_vec {\n            k.reverse();\n        }\n        assert_eq!(\n            v,\n            lowest_vec,\n            \"expected key {} to have value {}, instead it had value {}\",\n            slice_to_u32(&*k),\n            lowest,\n            slice_to_u32(&*v)\n        );\n    }\n\n    (contiguous, highest)\n}", "item_id": 0, "repo": "anxiousmodernman/sled", "file": "tests/tests/test_crash_recovery.rs", "last_update_at": "2019-06-05T12:32:28+00:00", "question_id": "6ed3822fabee84a2449771b7cb685bb729c4f58d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn verify(tree: &sled::Tree) -> (u32, u32) {\n    // key 0 should always be the highest value, as that's where we increment\n    // at some point, it might go down by one\n    // it should never return, or go down again after that\n    let mut iter = tree.iter();\n    let highest = match iter.next() {\n        Some(Ok((_k, v))) => slice_to_u32(&*v),\n        Some(Err(e)) => panic!(\"{:?}\", e),\n        None => return (0, 0),\n    };\n    let highest_vec = u32_to_vec(highest);\n    // find how far we got\n    let mut contiguous: u32 = 0;\n    let mut lowest = 0;\n    for res in iter {\n        let (mut k, v) = res.unwrap();\n        if &v[..4] == &highest_vec[..4] {\n            contiguous += 1;\n        } else {\n            k.reverse();\n            let expected = if highest == 0 {\n                CYCLE as u32 - 1\n            } else {\n                (highest - 1) % CYCLE as u32\n            };\n            let actual = slice_to_u32(&*v);\n            assert_eq!(expected, actual);\n            lowest = actual;\n            break;\n        }\n    }\n    let lowest_vec = u32_to_vec(lowest);\n    // ensure nothing changes after this point\n    let low_beginning = u32_to_vec(contiguous + 1);\n    for res in tree.scan(&*low_beginning) {\n        let (mut k, v) = res.unwrap();\n        if v != lowest_vec {\n            k.reverse();\n        }\n        assert_eq!(\n            v,\n            lowest_vec,\n            \"expected key {} to have value {}, instead it had value {}\",\n            slice_to_u32(&*k),\n            lowest,\n            slice_to_u32(&*v)\n        );\n    }\n    (contiguous, highest)\n"]]}
{"hexsha": "5b09ca6344446c6fac292af222f8e56143a65779", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut buf = BufReader::new(stdin());\n    let mut out = BufWriter::new(stdout());\n    let mut buffer = String::new();\n\n    buf.read_line(&mut buffer).unwrap();\n    let mut values: Vec<usize>;\n    let n: usize;\n    let m: usize;\n    values = buffer\n        .split_whitespace()\n        .map(|x| x.parse::<usize>().unwrap())\n        .collect();\n    n = values[0];\n    m = values[1];\n\n    let mut graph = Graph::new();\n\n    for _ in 0..m {\n        buffer.clear();\n        buf.read_line(&mut buffer).unwrap();\n        values.clear();\n        values = buffer\n            .split_whitespace()\n            .map(|x| x.parse::<usize>().unwrap())\n            .collect();\n\n        graph.add_node(&values[0]);\n        graph.add_node(&values[1]);\n        graph.add_edge(&values[0], &values[1]);\n    }\n    writeln!(out, \"{}\", solution(n, &graph)).unwrap();\n    out.flush().unwrap();\n}", "item_id": 2, "repo": "yskang/AlgorithmPractice", "file": "baekjoon/rust/make_line_2252.rs", "last_update_at": "2019-11-04T06:46:55+00:00", "question_id": "5b09ca6344446c6fac292af222f8e56143a65779_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let mut buf = BufReader::new(stdin());\n    let mut out = BufWriter::new(stdout());\n    let mut buffer = String::new();\n    buf.read_line(&mut buffer).unwrap();\n    let mut values: Vec<usize>;\n    let n: usize;\n    let m: usize;\n    values = buffer\n        .split_whitespace()\n        .map(|x| x.parse::<usize>().unwrap())\n        .collect();\n    n = values[0];\n    m = values[1];\n    let mut graph = Graph::new();\n    for _ in 0..m {\n        buffer.clear();\n        buf.read_line(&mut buffer).unwrap();\n        values.clear();\n        values = buffer\n            .split_whitespace()\n            .map(|x| x.parse::<usize>().unwrap())\n            .collect();\n        graph.add_node(&values[0]);\n        graph.add_node(&values[1]);\n        graph.add_edge(&values[0], &values[1]);\n    }\n    writeln!(out, \"{}\", solution(n, &graph)).unwrap();\n    out.flush().unwrap();\n"]]}
{"hexsha": "ddfeb1d44158fd0079ee1727c3457335017f470e", "ext": "rs", "lang": "Rust", "content": "fn reverse_order() {\n    let mut array = vec![5, 4, 3, 2, 1];\n    let array = insertion_sort(&mut array);\n    let val = vec![1, 2, 3, 4, 5];\n    assert_eq!(array.as_slice(), val.as_slice());\n}", "item_id": 1, "repo": "ldemouy/Algorithms-and-Data-Structures-In-Rust", "file": "src/insertion_sort.rs", "last_update_at": "2019-03-07T09:30:55+00:00", "question_id": "ddfeb1d44158fd0079ee1727c3457335017f470e_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn reverse_order() {\n    let mut array = vec![5, 4, 3, 2, 1];\n    let array = insertion_sort(&mut array);\n    let val = vec![1, 2, 3, 4, 5];\n    assert_eq!(array.as_slice(), val.as_slice());\n"]]}
{"hexsha": "af2a630995c0e2d564b4d37c8a10b3b0b3deee7d", "ext": "rs", "lang": "Rust", "content": "fn api_get_response() -> ResponseFuture {\n    let data = vec![\"foo\", \"bar\"];\n    let res = match serde_json::to_string(&data) {\n        Ok(json) => {\n            Response::builder()\n                .header(header::CONTENT_TYPE, \"application/json\")\n                .body(Body::from(json))\n                .unwrap()\n        }\n        Err(_) => {\n            Response::builder()\n                .status(StatusCode::INTERNAL_SERVER_ERROR)\n                .body(Body::from(\"Internal Server Error\"))\n                .unwrap()\n        }\n    };\n\n    Box::new(future::ok(res))\n}", "item_id": 0, "repo": "jxs/hyper", "file": "examples/web_api.rs", "last_update_at": "2019-11-19T09:28:31+00:00", "question_id": "af2a630995c0e2d564b4d37c8a10b3b0b3deee7d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn api_get_response() -> ResponseFuture {\n    let data = vec![\"foo\", \"bar\"];\n    let res = match serde_json::to_string(&data) {\n        Ok(json) => {\n            Response::builder()\n                .header(header::CONTENT_TYPE, \"application/json\")\n                .body(Body::from(json))\n                .unwrap()\n        }\n        Err(_) => {\n            Response::builder()\n                .status(StatusCode::INTERNAL_SERVER_ERROR)\n                .body(Body::from(\"Internal Server Error\"))\n                .unwrap()\n        }\n    };\n    Box::new(future::ok(res))\n"]]}
{"hexsha": "2b10ebecdeb13f24ccb41040b2ca5224c82736db", "ext": "rs", "lang": "Rust", "content": "fn retrieving_a_peer_is_none_if_peer_is_missing_or_not_connected() {\n    let mut cs = TestCollectionStream::new();\n    let peer_id = PeerId::random();\n    assert!(cs.peer_mut(&peer_id).is_none());\n\n    let handler = Handler::default();\n    let fut = future::ok((peer_id.clone(), DummyMuxer::new()));\n    cs.add_reach_attempt(fut, handler);\n    assert!(cs.peer_mut(&peer_id).is_none()); // task is pending\n}", "item_id": 1, "repo": "Atul9/rust-libp2p", "file": "core/src/nodes/collection/tests.rs", "last_update_at": "2019-05-11T02:05:39+00:00", "question_id": "2b10ebecdeb13f24ccb41040b2ca5224c82736db_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn retrieving_a_peer_is_none_if_peer_is_missing_or_not_connected() {\n    let mut cs = TestCollectionStream::new();\n    let peer_id = PeerId::random();\n    assert!(cs.peer_mut(&peer_id).is_none());\n    let handler = Handler::default();\n    let fut = future::ok((peer_id.clone(), DummyMuxer::new()));\n    cs.add_reach_attempt(fut, handler);\n    assert!(cs.peer_mut(&peer_id).is_none()); // task is pending\n"]]}
{"hexsha": "2d774b1052fbf4c2ce861a46e60c60e05411930e", "ext": "rs", "lang": "Rust", "content": "fn test_channel_last_same_padding() {\n            let input = test_utils::get_input_channel_last();\n            let output = max_pool2d(\n                &input,\n                (2, 2),\n                (2, 2),\n                Padding::Same,\n                DataFormat::ChannelsLast\n            ).unwrap();\n            let exp_output_1: Array3<f64> = array![\n                [[2., 4., 2.], [5., 6., 5.], [2., 6., 7.]],\n                [[7., 3., 6.], [4., 5., 7.], [2., 5., 5.]],\n                [[7., 4., 3.], [5., 6., 2.], [1., 1., 2.]]\n            ];\n            let exp_output_2: Array3<f64> = array![\n                [[5., 6., 4.], [3., 5., 2.], [5., 7., 1.]],\n                [[4., 3., 7.], [7., 7., 6.], [3., 5., 5.]],\n                [[7., 5., 5.], [4., 6., 5.], [6., 3., 1.]]\n            ];\n            let exp_output = join_new_axis(vec![exp_output_1, exp_output_2]).unwrap();\n            assert_eq!(output.shape(), &[2, 3, 3, 3]);\n            assert_eq!(output, exp_output);\n        }", "item_id": 4, "repo": "andrei-papou/horn", "file": "rust/src/backends/ndarray/convnets/pool.rs", "last_update_at": "2019-10-23T12:54:37+00:00", "question_id": "2d774b1052fbf4c2ce861a46e60c60e05411930e_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_channel_last_same_padding() {\n            let input = test_utils::get_input_channel_last();\n            let output = max_pool2d(\n                &input,\n                (2, 2),\n                (2, 2),\n                Padding::Same,\n                DataFormat::ChannelsLast\n            ).unwrap();\n            let exp_output_1: Array3<f64> = array![\n                [[2., 4., 2.], [5., 6., 5.], [2., 6., 7.]],\n                [[7., 3., 6.], [4., 5., 7.], [2., 5., 5.]],\n                [[7., 4., 3.], [5., 6., 2.], [1., 1., 2.]]\n            ];\n            let exp_output_2: Array3<f64> = array![\n                [[5., 6., 4.], [3., 5., 2.], [5., 7., 1.]],\n                [[4., 3., 7.], [7., 7., 6.], [3., 5., 5.]],\n                [[7., 5., 5.], [4., 6., 5.], [6., 3., 1.]]\n            ];\n            let exp_output = join_new_axis(vec![exp_output_1, exp_output_2]).unwrap();\n            assert_eq!(output.shape(), &[2, 3, 3, 3]);\n            assert_eq!(output, exp_output);\n"]]}
{"hexsha": "72a69f0c391af9a5778bb8c66ad58f96b6f980f7", "ext": "rs", "lang": "Rust", "content": "fn it_works_string() {\n        let mut lexer = Document::new(\"\\\"test\\\"\");\n        assert_eq!(lexer.next(), Some(Token::String { start: 0, end: 5 }));\n        assert_eq!(lexer.next(), None);\n\n        let mut lexer = Document::new(\"\\\"test\");\n        assert_eq!(lexer.next(), Some(Token::InvalidJSON { index: 0 }));\n        assert_eq!(lexer.next(), None);\n    }", "item_id": 1, "repo": "deankarn/lexer-exercise", "file": "lexer/src/lib.rs", "last_update_at": "2019-11-17T03:12:26+00:00", "question_id": "72a69f0c391af9a5778bb8c66ad58f96b6f980f7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_works_string() {\n        let mut lexer = Document::new(\"\\\"test\\\"\");\n        assert_eq!(lexer.next(), Some(Token::String { start: 0, end: 5 }));\n        assert_eq!(lexer.next(), None);\n        let mut lexer = Document::new(\"\\\"test\");\n        assert_eq!(lexer.next(), Some(Token::InvalidJSON { index: 0 }));\n        assert_eq!(lexer.next(), None);\n"]]}
{"hexsha": "a7466e590879380d07d3ad6d5da420fca494bece", "ext": "rs", "lang": "Rust", "content": "pub async fn update_track_title(\n    active_user: Option<User>,\n    track_id: i32,\n    title: String,\n    channel: tonic::transport::Channel,\n) -> Result<Track, GatewayError> {\n    let mut client = CoursesClient::new(channel);\n    let request = tonic::Request::new(UpdateTrackTitleRequest {\n        active_user,\n        track_id,\n        title,\n    });\n    let response = client.update_track_title(request).await?.into_inner();\n    let track = response.track.unwrap();\n    Ok(Track {\n        id: track.id,\n        track_number: track.track_number,\n        audio_path: track.audio_path,\n        title: track.title,\n        document_id: track.document_id,\n    })\n}", "item_id": 0, "repo": "nicksenger/synchrotron-server", "file": "api-gateway/src/data/track/update_track_title.rs", "last_update_at": "2019-11-29T03:32:12+00:00", "question_id": "a7466e590879380d07d3ad6d5da420fca494bece_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn update_track_title(\n    active_user: Option<User>,\n    track_id: i32,\n    title: String,\n    channel: tonic::transport::Channel,\n) -> Result<Track, GatewayError> {\n    let mut client = CoursesClient::new(channel);\n    let request = tonic::Request::new(UpdateTrackTitleRequest {\n        active_user,\n        track_id,\n        title,\n    });\n    let response = client.update_track_title(request).await?.into_inner();\n    let track = response.track.unwrap();\n    Ok(Track {\n        id: track.id,\n        track_number: track.track_number,\n        audio_path: track.audio_path,\n        title: track.title,\n        document_id: track.document_id,\n    })\n"]]}
{"hexsha": "2b4ca688137df6eb0e2d7aff08555f29ac133807", "ext": "rs", "lang": "Rust", "content": "fn test_insufficient_funds() {\n        let (genesis_block, mint_keypair) = GenesisBlock::new(11_000);\n        let bank = Bank::new(&genesis_block);\n        let pubkey = Pubkey::new_rand();\n        bank.transfer(1_000, &mint_keypair, &pubkey).unwrap();\n        assert_eq!(bank.transaction_count(), 1);\n        assert_eq!(bank.get_balance(&pubkey), 1_000);\n        assert_eq!(\n            bank.transfer(10_001, &mint_keypair, &pubkey),\n            Err(TransactionError::InstructionError(\n                0,\n                InstructionError::new_result_with_negative_lamports(),\n            ))\n        );\n        assert_eq!(bank.transaction_count(), 1);\n\n        let mint_pubkey = mint_keypair.pubkey();\n        assert_eq!(bank.get_balance(&mint_pubkey), 10_000);\n        assert_eq!(bank.get_balance(&pubkey), 1_000);\n    }", "item_id": 8, "repo": "abalaki6/solana", "file": "runtime/src/bank.rs", "last_update_at": "2019-03-10T22:29:28+00:00", "question_id": "2b4ca688137df6eb0e2d7aff08555f29ac133807_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_insufficient_funds() {\n        let (genesis_block, mint_keypair) = GenesisBlock::new(11_000);\n        let bank = Bank::new(&genesis_block);\n        let pubkey = Pubkey::new_rand();\n        bank.transfer(1_000, &mint_keypair, &pubkey).unwrap();\n        assert_eq!(bank.transaction_count(), 1);\n        assert_eq!(bank.get_balance(&pubkey), 1_000);\n        assert_eq!(\n            bank.transfer(10_001, &mint_keypair, &pubkey),\n            Err(TransactionError::InstructionError(\n                0,\n                InstructionError::new_result_with_negative_lamports(),\n            ))\n        );\n        assert_eq!(bank.transaction_count(), 1);\n        let mint_pubkey = mint_keypair.pubkey();\n        assert_eq!(bank.get_balance(&mint_pubkey), 10_000);\n        assert_eq!(bank.get_balance(&pubkey), 1_000);\n"]]}
{"hexsha": "9730e4a3c465bb45b9385794979fe4f7291213e6", "ext": "rs", "lang": "Rust", "content": "pub fn is_prime(x: u128) -> bool {\n    if x==2 {\n        return true\n    }\n    let help = integer_sqrt(x);\n    if x<2 || x%2==0 {\n        false\n    } else {\n        let mut i: u128 = 3;\n        while i<=help {\n            if x%i==0 {\n                return false\n            }\n            i = i+2;\n        };\n        true\n    }\n}", "item_id": 1, "repo": "Herbert-Karl/project_euler", "file": "src/common.rs", "last_update_at": "2019-05-14T20:05:42+00:00", "question_id": "9730e4a3c465bb45b9385794979fe4f7291213e6_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn is_prime(x: u128) -> bool {\n    if x==2 {\n        return true\n    }\n    let help = integer_sqrt(x);\n    if x<2 || x%2==0 {\n        false\n    } else {\n        let mut i: u128 = 3;\n        while i<=help {\n            if x%i==0 {\n                return false\n            }\n            i = i+2;\n        };\n        true\n    }\n"]]}
{"hexsha": "eeea6b71e888e2b308ff376f4e25e5a3658e27dd", "ext": "rs", "lang": "Rust", "content": "fn test_eigen_left_eigenvectors() {\n        let (m, n) = (6, 8);\n        let a = Matrix::randsn(m, n);\n        let b = a.t() * a;\n\n        eigen_test_driver(b, EigenOptions::LeftEigenvectorsOnly).unwrap();\n    }", "item_id": 10, "repo": "jblondin/matrix", "file": "src/decompose.rs", "last_update_at": "2019-06-29T15:43:58+00:00", "question_id": "eeea6b71e888e2b308ff376f4e25e5a3658e27dd_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_eigen_left_eigenvectors() {\n        let (m, n) = (6, 8);\n        let a = Matrix::randsn(m, n);\n        let b = a.t() * a;\n        eigen_test_driver(b, EigenOptions::LeftEigenvectorsOnly).unwrap();\n"]]}
{"hexsha": "9d5af356183cde7875f69aef72ca78ad2a84fde0", "ext": "rs", "lang": "Rust", "content": "fn reachable_with_relation_join(edges: &[(u32, u32)]) -> Relation<(u32, u32)> {\n    let edges: Relation<_> = edges.iter().collect();\n    let mut iteration = Iteration::new();\n\n    // NB. Changed from `reachable_with_var_join`:\n    let edges_by_successor: Relation<_> = edges.iter().map(|&(n1, n2)| (n2, n1)).collect();\n\n    let reachable = iteration.variable::<(u32, u32)>(\"reachable\");\n    reachable.insert(edges);\n\n    while iteration.changed() {\n        // reachable(N1, N3) :- edges(N1, N2), reachable(N2, N3).\n        reachable.from_join(&reachable, &edges_by_successor, |&_, &n3, &n1| (n1, n3));\n    }\n\n    reachable.complete()\n}", "item_id": 1, "repo": "regexident/datafrog", "file": "src/test.rs", "last_update_at": "2019-04-24T23:46:28+00:00", "question_id": "9d5af356183cde7875f69aef72ca78ad2a84fde0_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn reachable_with_relation_join(edges: &[(u32, u32)]) -> Relation<(u32, u32)> {\n    let edges: Relation<_> = edges.iter().collect();\n    let mut iteration = Iteration::new();\n    // NB. Changed from `reachable_with_var_join`:\n    let edges_by_successor: Relation<_> = edges.iter().map(|&(n1, n2)| (n2, n1)).collect();\n    let reachable = iteration.variable::<(u32, u32)>(\"reachable\");\n    reachable.insert(edges);\n    while iteration.changed() {\n        // reachable(N1, N3) :- edges(N1, N2), reachable(N2, N3).\n        reachable.from_join(&reachable, &edges_by_successor, |&_, &n3, &n1| (n1, n3));\n    }\n    reachable.complete()\n"]]}
{"hexsha": "dbc2a3e87800e15f1c7dd681947024518bd95164", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn dmtr_connect(\n    qtok_out: *mut dmtr_qtoken_t,\n    qd: c_int,\n    saddr: *const sockaddr,\n    size: socklen_t,\n) -> c_int {\n    trace!(\"dmtr_connect()\");\n\n    // Check if socket address is invalid.\n    if saddr.is_null() {\n        return libc::EINVAL;\n    }\n\n    // Check if socket address length is invalid.\n    if size as usize != mem::size_of::<libc::sockaddr_in>() {\n        return libc::EINVAL;\n    }\n\n    // Get socket address.\n    let endpoint: Ipv4Endpoint = match sockaddr_to_ipv4endpoint(saddr) {\n        Ok(endpoint) => endpoint,\n        Err(e) => {\n            warn!(\"connect() failed: {:?}\", e);\n            return e.errno;\n        },\n    };\n\n    // Issue connect operation.\n    with_libos(|libos| match libos.connect(qd.into(), endpoint) {\n        Ok(qt) => {\n            unsafe { *qtok_out = qt.into() };\n            0\n        },\n        Err(e) => {\n            warn!(\"connect() failed: {:?}\", e);\n            e.errno\n        },\n    })\n}", "item_id": 5, "repo": "iyzhang/demikernel", "file": "src/demikernel/bindings.rs", "last_update_at": "2019-11-05T19:16:02+00:00", "question_id": "dbc2a3e87800e15f1c7dd681947024518bd95164_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub extern \"C\" fn dmtr_connect(\n    qtok_out: *mut dmtr_qtoken_t,\n    qd: c_int,\n    saddr: *const sockaddr,\n    size: socklen_t,\n) -> c_int {\n    trace!(\"dmtr_connect()\");\n    // Check if socket address is invalid.\n    if saddr.is_null() {\n        return libc::EINVAL;\n    }\n    // Check if socket address length is invalid.\n    if size as usize != mem::size_of::<libc::sockaddr_in>() {\n        return libc::EINVAL;\n    }\n    // Get socket address.\n    let endpoint: Ipv4Endpoint = match sockaddr_to_ipv4endpoint(saddr) {\n        Ok(endpoint) => endpoint,\n        Err(e) => {\n            warn!(\"connect() failed: {:?}\", e);\n            return e.errno;\n        },\n    };\n    // Issue connect operation.\n    with_libos(|libos| match libos.connect(qd.into(), endpoint) {\n        Ok(qt) => {\n            unsafe { *qtok_out = qt.into() };\n            0\n        },\n        Err(e) => {\n            warn!(\"connect() failed: {:?}\", e);\n            e.errno\n        },\n    })\n"]]}
{"hexsha": "16054c5616c4a0085995cca3221f2b6f10cea7e9", "ext": "rs", "lang": "Rust", "content": "fn print_fat16() {\n    let f = OpenOptions::new().read(true).write(true).open(\"images/fat16.img\").expect(\"Failed to open fat16.img\");\n    let mut fs = redox_fatfs::FileSystem::from_offset(0, f).expect(\"Parsing Error\");\n    let max_cluster = fs.max_cluster_number();\n    let root_sec = fs.bpb.rsvd_sec_cnt as u64 + (fs.bpb.num_fats as u64 * fs.bpb.fat_size_16 as u64);\n    let root_clus = Cluster::new(root_sec / fs.bpb.sectors_per_cluster as u64);\n    println!(\"Root Cluster = {:?}\", fs.clusters(root_clus));\n    println!(\"First Data Sec = {}\", fs.first_data_sec);\n    // Cluster 2 starts from first_data_sec sector onwards\n\n    let mut buf = [0; 32];\n    fs.read_sector(root_sec, &mut buf);\n    println!(\"Buffer = {:?}\", buf);\n    println!(\"BPB = {:?}\", fs.bpb);\n    println!(\"FsInfo = {:?}\", fs.fs_info.borrow());\n    println!(\"Mirroring Enabled = {:?}\", fs.mirroring_enabled());\n\n    fs.read_cluster(Cluster::new(5), &mut buf);\n    println!(\"somefile.txt = {:?}\", buf);\n\n    let free = get_free_cluster(&mut fs, Cluster::new(5), Cluster::new(100));\n    println!(\"Free Cluster = {:?}\", free);\n    println!(\"Num free Cluster = {:?}\", get_free_count(&mut fs, max_cluster));\n    println!(\"Cluster Chain of longFile.txt = {:?}\", fs.clusters(Cluster::new(3)));\n    let root_dir : Vec<DirEntry> = fs.root_dir().to_iter(&mut fs).collect();\n    for entry in root_dir  {\n        println!(\"Dir Entry : {:?}\\n\", entry);\n    }\n}", "item_id": 2, "repo": "planet-s/redox-fatfs", "file": "tests/cluster.rs", "last_update_at": "2019-08-13T16:23:57+00:00", "question_id": "16054c5616c4a0085995cca3221f2b6f10cea7e9_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn print_fat16() {\n    let f = OpenOptions::new().read(true).write(true).open(\"images/fat16.img\").expect(\"Failed to open fat16.img\");\n    let mut fs = redox_fatfs::FileSystem::from_offset(0, f).expect(\"Parsing Error\");\n    let max_cluster = fs.max_cluster_number();\n    let root_sec = fs.bpb.rsvd_sec_cnt as u64 + (fs.bpb.num_fats as u64 * fs.bpb.fat_size_16 as u64);\n    let root_clus = Cluster::new(root_sec / fs.bpb.sectors_per_cluster as u64);\n    println!(\"Root Cluster = {:?}\", fs.clusters(root_clus));\n    println!(\"First Data Sec = {}\", fs.first_data_sec);\n    // Cluster 2 starts from first_data_sec sector onwards\n    let mut buf = [0; 32];\n    fs.read_sector(root_sec, &mut buf);\n    println!(\"Buffer = {:?}\", buf);\n    println!(\"BPB = {:?}\", fs.bpb);\n    println!(\"FsInfo = {:?}\", fs.fs_info.borrow());\n    println!(\"Mirroring Enabled = {:?}\", fs.mirroring_enabled());\n    fs.read_cluster(Cluster::new(5), &mut buf);\n    println!(\"somefile.txt = {:?}\", buf);\n    let free = get_free_cluster(&mut fs, Cluster::new(5), Cluster::new(100));\n    println!(\"Free Cluster = {:?}\", free);\n    println!(\"Num free Cluster = {:?}\", get_free_count(&mut fs, max_cluster));\n    println!(\"Cluster Chain of longFile.txt = {:?}\", fs.clusters(Cluster::new(3)));\n    let root_dir : Vec<DirEntry> = fs.root_dir().to_iter(&mut fs).collect();\n    for entry in root_dir  {\n        println!(\"Dir Entry : {:?}\\n\", entry);\n    }\n"]]}
{"hexsha": "c6633fc301d67b960002674286f7e2e8307d1abf", "ext": "rs", "lang": "Rust", "content": "fn get_replays_dir_path() -> PathBuf {\n    let mut replays_path = files::get_path();\n    replays_path.push(\"replays\");\n    replays_path\n}", "item_id": 1, "repo": "rukai/game", "file": "canon_collision_lib/src/replays_files.rs", "last_update_at": "2019-09-18T14:14:21+00:00", "question_id": "c6633fc301d67b960002674286f7e2e8307d1abf_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_replays_dir_path() -> PathBuf {\n    let mut replays_path = files::get_path();\n    replays_path.push(\"replays\");\n    replays_path\n"]]}
{"hexsha": "0653e56e889588dca5cd052a94bf4a102e2e4f57", "ext": "rs", "lang": "Rust", "content": "fn test_register_output_file() {\n    let url = Url::parse(\"https://external-storage.com/filepath?presigned_token\").unwrap();\n    let crypto_info = FileCrypto::default();\n\n    let request = RegisterOutputFileRequest::new(url.clone(), crypto_info);\n    let response = authorized_client().register_output_file(request);\n    assert!(response.is_ok());\n\n    let request = RegisterOutputFileRequest::new(url, crypto_info);\n    let response = unauthorized_client().register_output_file(request);\n    assert!(response.is_err());\n}", "item_id": 3, "repo": "qinkunbao/incubator-teaclave", "file": "tests/functional/enclave/src/frontend_service.rs", "last_update_at": "2019-11-07T17:35:55+00:00", "question_id": "0653e56e889588dca5cd052a94bf4a102e2e4f57_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_register_output_file() {\n    let url = Url::parse(\"https://external-storage.com/filepath?presigned_token\").unwrap();\n    let crypto_info = FileCrypto::default();\n    let request = RegisterOutputFileRequest::new(url.clone(), crypto_info);\n    let response = authorized_client().register_output_file(request);\n    assert!(response.is_ok());\n    let request = RegisterOutputFileRequest::new(url, crypto_info);\n    let response = unauthorized_client().register_output_file(request);\n    assert!(response.is_err());\n"]]}
{"hexsha": "cdbc92eeeb7c3a60ce671ea88b40c91a547b18d6", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    pretty_env_logger::init();\n\n    let tileset_image = image::load_from_memory(TILESET_IMAGE_DATA)\n        .unwrap()\n        .to_rgba();\n    \n    let glyph_lib = create_glyph_lib();\n\n    let mut canvas = CellBuffer::new(80, 50, Cell::default());\n    let mut console = tcrab_console_gl::Console::new(tcrab_console_gl::Settings {\n        title: \"tcrab example\".into(),\n        texture_width: tileset_image.width(),\n        texture_height: tileset_image.height(),\n        texture_data: tileset_image.into_vec(),\n        cell_width: TILESET_CELL_WIDTH,\n        cell_height: TILESET_CELL_HEIGHT,\n    }).unwrap();\n\n    let mut player_pos = (5, 10);\n    let mut is_running = true;\n    while is_running {\n        let (canvas_width, canvas_height) = canvas.size();\n        draw(&mut canvas, player_pos);\n        console.present(&canvas, &glyph_lib);\n        console.wait_for_events_forever(|event| match event {\n            Event::Quit |\n            Event::KeyboardInput { key_code: Some(KeyCode::Escape), .. } => {\n                is_running = false;\n                ControlFlow::Break\n            }\n            Event::KeyboardInput { key_code: Some(key_code), key_state: ButtonState::Pressed } => {\n                let mut moved = false;\n                let mut move_player = |x, y| {\n                    let mut new_pos = player_pos;\n                    new_pos.0 += x;\n                    new_pos.1 += y;\n                    if new_pos.0 < 0 {\n                        new_pos.0 = 0;\n                    }\n                    if new_pos.0 > canvas_width as i32 - 1 {\n                        new_pos.0 = canvas_width as i32 - 1;\n                    }\n                    if new_pos.1 < 0 {\n                        new_pos.1 = 0;\n                    }\n                    if new_pos.1 > canvas_height as i32 - 1 {\n                        new_pos.1 = canvas_height as i32 - 1;\n                    }\n                    if new_pos != player_pos {\n                        moved = true;\n                        player_pos = new_pos;\n                        ControlFlow::Break\n                    } else { ControlFlow::Continue }\n                };\n                match key_code {\n                    KeyCode::Up => move_player(0, -1),\n                    KeyCode::Down => move_player(0, 1),\n                    KeyCode::Left => move_player(-1, 0),\n                    KeyCode::Right => move_player(1, 0),\n                    _ => ControlFlow::Continue,\n                }\n            }\n            _ => ControlFlow::Continue,\n        });\n    }\n}", "item_id": 1, "repo": "dkaste/tcrab", "file": "tcrab/examples/basic.rs", "last_update_at": "2019-07-25T15:42:17+00:00", "question_id": "cdbc92eeeb7c3a60ce671ea88b40c91a547b18d6_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    pretty_env_logger::init();\n    let tileset_image = image::load_from_memory(TILESET_IMAGE_DATA)\n        .unwrap()\n        .to_rgba();\n    let glyph_lib = create_glyph_lib();\n    let mut canvas = CellBuffer::new(80, 50, Cell::default());\n    let mut console = tcrab_console_gl::Console::new(tcrab_console_gl::Settings {\n        title: \"tcrab example\".into(),\n        texture_width: tileset_image.width(),\n        texture_height: tileset_image.height(),\n        texture_data: tileset_image.into_vec(),\n        cell_width: TILESET_CELL_WIDTH,\n        cell_height: TILESET_CELL_HEIGHT,\n    }).unwrap();\n    let mut player_pos = (5, 10);\n    let mut is_running = true;\n    while is_running {\n        let (canvas_width, canvas_height) = canvas.size();\n        draw(&mut canvas, player_pos);\n        console.present(&canvas, &glyph_lib);\n        console.wait_for_events_forever(|event| match event {\n            Event::Quit |\n            Event::KeyboardInput { key_code: Some(KeyCode::Escape), .. } => {\n                is_running = false;\n                ControlFlow::Break\n            }\n            Event::KeyboardInput { key_code: Some(key_code), key_state: ButtonState::Pressed } => {\n                let mut moved = false;\n                let mut move_player = |x, y| {\n                    let mut new_pos = player_pos;\n                    new_pos.0 += x;\n                    new_pos.1 += y;\n                    if new_pos.0 < 0 {\n                        new_pos.0 = 0;\n                    }\n                    if new_pos.0 > canvas_width as i32 - 1 {\n                        new_pos.0 = canvas_width as i32 - 1;\n                    }\n                    if new_pos.1 < 0 {\n                        new_pos.1 = 0;\n                    }\n                    if new_pos.1 > canvas_height as i32 - 1 {\n                        new_pos.1 = canvas_height as i32 - 1;\n                    }\n                    if new_pos != player_pos {\n                        moved = true;\n                        player_pos = new_pos;\n                        ControlFlow::Break\n                    } else { ControlFlow::Continue }\n                };\n                match key_code {\n                    KeyCode::Up => move_player(0, -1),\n                    KeyCode::Down => move_player(0, 1),\n                    KeyCode::Left => move_player(-1, 0),\n                    KeyCode::Right => move_player(1, 0),\n                    _ => ControlFlow::Continue,\n                }\n            }\n            _ => ControlFlow::Continue,\n        });\n    }\n"]]}
{"hexsha": "8e91021cb3f6a08dd98a933c36ee5026f00bfba4", "ext": "rs", "lang": "Rust", "content": "fn lengths() {\n    let mut s: LendingLibrary<i64, i64> = LendingLibrary::new();\n    assert_eq!(s.len(), 0);\n    assert!(s.is_empty());\n    s.insert(1, 1);\n    s.insert(2, 1);\n    assert_eq!(s.len(), 2);\n    assert!(!s.is_empty());\n    {\n        let _v = s.lend(&1);\n        assert_eq!(s.len(), 2);\n        assert!(!s.is_empty());\n        s.remove(&1);\n        assert_eq!(s.len(), 1);\n        assert!(!s.is_empty());\n        s.clear();\n    }\n    assert_eq!(s.len(), 0);\n    assert!(s.is_empty());\n}", "item_id": 3, "repo": "HarkonenBade/lending-library", "file": "src/tests.rs", "last_update_at": "2019-05-03T01:51:16+00:00", "question_id": "8e91021cb3f6a08dd98a933c36ee5026f00bfba4_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn lengths() {\n    let mut s: LendingLibrary<i64, i64> = LendingLibrary::new();\n    assert_eq!(s.len(), 0);\n    assert!(s.is_empty());\n    s.insert(1, 1);\n    s.insert(2, 1);\n    assert_eq!(s.len(), 2);\n    assert!(!s.is_empty());\n    {\n        let _v = s.lend(&1);\n        assert_eq!(s.len(), 2);\n        assert!(!s.is_empty());\n        s.remove(&1);\n        assert_eq!(s.len(), 1);\n        assert!(!s.is_empty());\n        s.clear();\n    }\n    assert_eq!(s.len(), 0);\n    assert!(s.is_empty());\n"]]}
{"hexsha": "40fa2c4fe904294809879b6efd9ffb69549288d2", "ext": "rs", "lang": "Rust", "content": "fn test_percentage_flex_basis() {\n\tlet mut root = Node::new();\n\troot.set_flex_direction(FlexDirection::Row);\n\troot.set_width(StyleUnit::Point(200.0.into()));\n\troot.set_height(StyleUnit::Point(200.0.into()));\n\n\tlet mut root_child0 = Node::new();\n\troot_child0.set_flex_grow(1.0);\n\troot_child0.set_flex_basis(StyleUnit::Percent(50.0.into()));\n\troot.insert_child(&mut root_child0, 0);\n\n\tlet mut root_child1 = Node::new();\n\troot_child1.set_flex_grow(1.0);\n\troot_child1.set_flex_basis(StyleUnit::Percent(25.0.into()));\n\troot.insert_child(&mut root_child1, 1);\n\troot.calculate_layout(Undefined, Undefined, Direction::LTR);\n\n\tassert_eq!(0, root.get_layout_left() as i32);\n\tassert_eq!(0, root.get_layout_top() as i32);\n\tassert_eq!(200, root.get_layout_width() as i32);\n\tassert_eq!(200, root.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0.get_layout_top() as i32);\n\tassert_eq!(125, root_child0.get_layout_width() as i32);\n\tassert_eq!(200, root_child0.get_layout_height() as i32);\n\n\tassert_eq!(125, root_child1.get_layout_left() as i32);\n\tassert_eq!(0, root_child1.get_layout_top() as i32);\n\tassert_eq!(75, root_child1.get_layout_width() as i32);\n\tassert_eq!(200, root_child1.get_layout_height() as i32);\n\n\troot.calculate_layout(Undefined, Undefined, Direction::RTL);\n\n\tassert_eq!(0, root.get_layout_left() as i32);\n\tassert_eq!(0, root.get_layout_top() as i32);\n\tassert_eq!(200, root.get_layout_width() as i32);\n\tassert_eq!(200, root.get_layout_height() as i32);\n\n\tassert_eq!(75, root_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0.get_layout_top() as i32);\n\tassert_eq!(125, root_child0.get_layout_width() as i32);\n\tassert_eq!(200, root_child0.get_layout_height() as i32);\n\n\tassert_eq!(0, root_child1.get_layout_left() as i32);\n\tassert_eq!(0, root_child1.get_layout_top() as i32);\n\tassert_eq!(75, root_child1.get_layout_width() as i32);\n\tassert_eq!(200, root_child1.get_layout_height() as i32);\n}", "item_id": 3, "repo": "mehcode/yoga-rs", "file": "tests/percentage_test.rs", "last_update_at": "2019-04-11T14:07:42+00:00", "question_id": "40fa2c4fe904294809879b6efd9ffb69549288d2_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_percentage_flex_basis() {\n\tlet mut root = Node::new();\n\troot.set_flex_direction(FlexDirection::Row);\n\troot.set_width(StyleUnit::Point(200.0.into()));\n\troot.set_height(StyleUnit::Point(200.0.into()));\n\tlet mut root_child0 = Node::new();\n\troot_child0.set_flex_grow(1.0);\n\troot_child0.set_flex_basis(StyleUnit::Percent(50.0.into()));\n\troot.insert_child(&mut root_child0, 0);\n\tlet mut root_child1 = Node::new();\n\troot_child1.set_flex_grow(1.0);\n\troot_child1.set_flex_basis(StyleUnit::Percent(25.0.into()));\n\troot.insert_child(&mut root_child1, 1);\n\troot.calculate_layout(Undefined, Undefined, Direction::LTR);\n\tassert_eq!(0, root.get_layout_left() as i32);\n\tassert_eq!(0, root.get_layout_top() as i32);\n\tassert_eq!(200, root.get_layout_width() as i32);\n\tassert_eq!(200, root.get_layout_height() as i32);\n\tassert_eq!(0, root_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0.get_layout_top() as i32);\n\tassert_eq!(125, root_child0.get_layout_width() as i32);\n\tassert_eq!(200, root_child0.get_layout_height() as i32);\n\tassert_eq!(125, root_child1.get_layout_left() as i32);\n\tassert_eq!(0, root_child1.get_layout_top() as i32);\n\tassert_eq!(75, root_child1.get_layout_width() as i32);\n\tassert_eq!(200, root_child1.get_layout_height() as i32);\n\troot.calculate_layout(Undefined, Undefined, Direction::RTL);\n\tassert_eq!(0, root.get_layout_left() as i32);\n\tassert_eq!(0, root.get_layout_top() as i32);\n\tassert_eq!(200, root.get_layout_width() as i32);\n\tassert_eq!(200, root.get_layout_height() as i32);\n\tassert_eq!(75, root_child0.get_layout_left() as i32);\n\tassert_eq!(0, root_child0.get_layout_top() as i32);\n\tassert_eq!(125, root_child0.get_layout_width() as i32);\n\tassert_eq!(200, root_child0.get_layout_height() as i32);\n\tassert_eq!(0, root_child1.get_layout_left() as i32);\n\tassert_eq!(0, root_child1.get_layout_top() as i32);\n\tassert_eq!(75, root_child1.get_layout_width() as i32);\n\tassert_eq!(200, root_child1.get_layout_height() as i32);\n"]]}
{"hexsha": "f9520156218e9bcfb79679b0e5b28646d0ebfa83", "ext": "rs", "lang": "Rust", "content": "fn main() -> io::Result<()> {\n    let file = File::open(\"input.txt\")?;\n    let reader = BufReader::new(file);\n    let mut asteroids = reader\n        .lines()\n        .map(|line| line.map(|l| l.bytes().map(|b| b == b'#').collect()))\n        .collect::<io::Result<Vec<Vec<bool>>>>()?;\n    let width = asteroids[0].len();\n    let height = asteroids.len();\n    let mut remaining = 199;\n    loop {\n        let mut visible = get_visible_asteroids(&mut asteroids, BASE_X, BASE_Y, width, height);\n        // visible.sort();\n        // for (i, v) in visible.iter().enumerate() {\n        //     println!(\"{}: {}\", i, v);\n        // }\n        if visible.len() < remaining {\n            remaining -= visible.len();\n        } else {\n            visible.sort();\n\n            let target = &visible[remaining];\n            println!(\"200th asteroid: {}\", (BASE_X as isize + target.x) * 100 + (BASE_Y as isize + target.y));\n            break;\n        }\n    }\n\n    Ok(())\n}", "item_id": 1, "repo": "bmatcuk/adventofcode2019", "file": "day10/src/bin/part2.rs", "last_update_at": "2019-12-11T19:38:53+00:00", "question_id": "f9520156218e9bcfb79679b0e5b28646d0ebfa83_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> io::Result<()> {\n    let file = File::open(\"input.txt\")?;\n    let reader = BufReader::new(file);\n    let mut asteroids = reader\n        .lines()\n        .map(|line| line.map(|l| l.bytes().map(|b| b == b'#').collect()))\n        .collect::<io::Result<Vec<Vec<bool>>>>()?;\n    let width = asteroids[0].len();\n    let height = asteroids.len();\n    let mut remaining = 199;\n    loop {\n        let mut visible = get_visible_asteroids(&mut asteroids, BASE_X, BASE_Y, width, height);\n        // visible.sort();\n        // for (i, v) in visible.iter().enumerate() {\n        //     println!(\"{}: {}\", i, v);\n        // }\n        if visible.len() < remaining {\n            remaining -= visible.len();\n        } else {\n            visible.sort();\n            let target = &visible[remaining];\n            println!(\"200th asteroid: {}\", (BASE_X as isize + target.x) * 100 + (BASE_Y as isize + target.y));\n            break;\n        }\n    }\n    Ok(())\n"]]}
{"hexsha": "22dd84ba6cc61592110b2559221a4e52b0c7844c", "ext": "rs", "lang": "Rust", "content": "fn duplicate_includes() {\n    let src = indoc!(\n        r#\"\n        #include \"A.glsl\"\n        #include \"A.glsl\"\n        #include <A.glsl>\n        void main() {}\"#\n    );\n    let expand_src = Context::new()\n        .include(\"A.glsl\", \"void A() {}\")\n        .expand(src)\n        .unwrap();\n    let expected = indoc!(\n        r#\"\n        void A() {}\n        #line 4 0\n        void main() {}\"#\n    );\n    assert_eq!(expected, expand_src);\n}", "item_id": 4, "repo": "germangb/glsl-include", "file": "tests/mod.rs", "last_update_at": "2019-09-24T18:59:14+00:00", "question_id": "22dd84ba6cc61592110b2559221a4e52b0c7844c_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn duplicate_includes() {\n    let src = indoc!(\n        r#\"\n        #include \"A.glsl\"\n        #include \"A.glsl\"\n        #include <A.glsl>\n        void main() {}\"#\n    );\n    let expand_src = Context::new()\n        .include(\"A.glsl\", \"void A() {}\")\n        .expand(src)\n        .unwrap();\n    let expected = indoc!(\n        r#\"\n        void A() {}\n        #line 4 0\n        void main() {}\"#\n    );\n    assert_eq!(expected, expand_src);\n"]]}
{"hexsha": "99ec1b268c51c3421dd383fb23681b4c110262f0", "ext": "rs", "lang": "Rust", "content": "fn make_xhp_close(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R) -> (State, Self::R) {\n        let s = State::next(s, &[&arg0, &arg1, &arg2]);\n        let r = Self::R::make_xhp_close(&s, arg0, arg1, arg2);\n        (s, r)\n    }", "item_id": 133, "repo": "jeffomatic/hhvm", "file": "hphp/hack/src/parser/syntax_smart_constructors_generated.rs", "last_update_at": "2019-07-21T09:08:35+00:00", "question_id": "99ec1b268c51c3421dd383fb23681b4c110262f0_133", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn make_xhp_close(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R) -> (State, Self::R) {\n        let s = State::next(s, &[&arg0, &arg1, &arg2]);\n        let r = Self::R::make_xhp_close(&s, arg0, arg1, arg2);\n        (s, r)\n"]]}
{"hexsha": "2ac950027523cdd0b783cf904f7a2f788318e32b", "ext": "rs", "lang": "Rust", "content": "unsafe fn test_mm_add_pi32() {\n        let a = _mm_setr_pi32(1, -1);\n        let b = _mm_setr_pi32(i32::MAX - 1, i32::MIN + 1);\n        let e = _mm_setr_pi32(i32::MAX, i32::MIN);\n        assert_eq_m64(e, _mm_add_pi32(a, b));\n        assert_eq_m64(e, _m_paddd(a, b));\n    }", "item_id": 2, "repo": "ultimate-research/rust-std-skyline-squashed", "file": "src/stdarch/crates/core_arch/src/x86/mmx.rs", "last_update_at": "2019-08-26T03:46:37+00:00", "question_id": "2ac950027523cdd0b783cf904f7a2f788318e32b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe fn test_mm_add_pi32() {\n        let a = _mm_setr_pi32(1, -1);\n        let b = _mm_setr_pi32(i32::MAX - 1, i32::MIN + 1);\n        let e = _mm_setr_pi32(i32::MAX, i32::MIN);\n        assert_eq_m64(e, _mm_add_pi32(a, b));\n        assert_eq_m64(e, _m_paddd(a, b));\n"]]}
{"hexsha": "6794c0e1c9e16196a23cb7ecb4003ffa8f3dfa95", "ext": "rs", "lang": "Rust", "content": "fn image_for_address(report: &CrashReport, address: u64) -> Option<&CrashReport_BinaryImage> {\n    for image in report.get_binary_images() {\n        let base_address = image.get_base_address();\n        if base_address <= address && address < (base_address + image.get_size()) {\n            return Some(image);\n        }\n    }\n\n    /* Not found */\n    None\n}", "item_id": 2, "repo": "griff/plcrash.rs", "file": "src/text.rs", "last_update_at": "2019-09-10T21:46:01+00:00", "question_id": "6794c0e1c9e16196a23cb7ecb4003ffa8f3dfa95_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn image_for_address(report: &CrashReport, address: u64) -> Option<&CrashReport_BinaryImage> {\n    for image in report.get_binary_images() {\n        let base_address = image.get_base_address();\n        if base_address <= address && address < (base_address + image.get_size()) {\n            return Some(image);\n        }\n    }\n    /* Not found */\n    None\n"]]}
{"hexsha": "c02aa149c14839a8741c508920f5a7d9a7d06a01", "ext": "rs", "lang": "Rust", "content": "fn load_key(key_path: &str) -> Result<String, Box<dyn Error>> {\n    let mut key_file = File::open(key_path)?;\n    let mut key = String::new();\n    key_file.read_to_string(&mut key)?;\n    Ok(key.trim_end_matches(|c| c == '\\r' || c == '\\n').to_string())\n}", "item_id": 2, "repo": "jcsora/occlum", "file": "example/init_ra/src/main.rs", "last_update_at": "2019-06-30T05:43:27+00:00", "question_id": "c02aa149c14839a8741c508920f5a7d9a7d06a01_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn load_key(key_path: &str) -> Result<String, Box<dyn Error>> {\n    let mut key_file = File::open(key_path)?;\n    let mut key = String::new();\n    key_file.read_to_string(&mut key)?;\n    Ok(key.trim_end_matches(|c| c == '\\r' || c == '\\n').to_string())\n"]]}
{"hexsha": "621ce1e81b5205f9e5a8f4ed6cdbac020637a641", "ext": "rs", "lang": "Rust", "content": "fn get_target_file_header(filepath: &str) -> Option<Header> {\n    let mut file = File::open(format!(\"{}.cache\", filepath)).ok()?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents).ok()?;\n    let header: Header = serde_json::from_str(contents.trim()).ok()?;\n    Some(header)\n}", "item_id": 2, "repo": "Dentosal/hepta-lang", "file": "build.rs", "last_update_at": "2019-08-23T13:46:24+00:00", "question_id": "621ce1e81b5205f9e5a8f4ed6cdbac020637a641_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_target_file_header(filepath: &str) -> Option<Header> {\n    let mut file = File::open(format!(\"{}.cache\", filepath)).ok()?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents).ok()?;\n    let header: Header = serde_json::from_str(contents.trim()).ok()?;\n    Some(header)\n"]]}
{"hexsha": "c3d594204f413de24eeeb0ab860a88c37a52170a", "ext": "rs", "lang": "Rust", "content": "fn emit_to_destination(rendered_buffer: &[Vec<StyledString>],\n                       lvl: &Level,\n                       dst: &mut Destination,\n                       short_message: bool)\n                       -> io::Result<()> {\n    use crate::lock;\n\n    let mut dst = dst.writable();\n\n    // In order to prevent error message interleaving, where multiple error lines get intermixed\n    // when multiple compiler processes error simultaneously, we emit errors with additional\n    // steps.\n    //\n    // On Unix systems, we write into a buffered terminal rather than directly to a terminal. When\n    // the .flush() is called we take the buffer created from the buffered writes and write it at\n    // one shot.  Because the Unix systems use ANSI for the colors, which is a text-based styling\n    // scheme, this buffered approach works and maintains the styling.\n    //\n    // On Windows, styling happens through calls to a terminal API. This prevents us from using the\n    // same buffering approach.  Instead, we use a global Windows mutex, which we acquire long\n    // enough to output the full error message, then we release.\n    let _buffer_lock = lock::acquire_global_lock(\"rustc_errors\");\n    for (pos, line) in rendered_buffer.iter().enumerate() {\n        for part in line {\n            dst.apply_style(lvl.clone(), part.style)?;\n            write!(dst, \"{}\", part.text)?;\n            dst.reset()?;\n        }\n        if !short_message && (!lvl.is_failure_note() || pos != rendered_buffer.len() - 1) {\n            write!(dst, \"\\n\")?;\n        }\n    }\n    dst.flush()?;\n    Ok(())\n}", "item_id": 0, "repo": "jespersm/rust", "file": "src/librustc_errors/emitter.rs", "last_update_at": "2019-08-08T00:57:46+00:00", "question_id": "c3d594204f413de24eeeb0ab860a88c37a52170a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn emit_to_destination(rendered_buffer: &[Vec<StyledString>],\n                       lvl: &Level,\n                       dst: &mut Destination,\n                       short_message: bool)\n                       -> io::Result<()> {\n    use crate::lock;\n    let mut dst = dst.writable();\n    // In order to prevent error message interleaving, where multiple error lines get intermixed\n    // when multiple compiler processes error simultaneously, we emit errors with additional\n    // steps.\n    //\n    // On Unix systems, we write into a buffered terminal rather than directly to a terminal. When\n    // the .flush() is called we take the buffer created from the buffered writes and write it at\n    // one shot.  Because the Unix systems use ANSI for the colors, which is a text-based styling\n    // scheme, this buffered approach works and maintains the styling.\n    //\n    // On Windows, styling happens through calls to a terminal API. This prevents us from using the\n    // same buffering approach.  Instead, we use a global Windows mutex, which we acquire long\n    // enough to output the full error message, then we release.\n    let _buffer_lock = lock::acquire_global_lock(\"rustc_errors\");\n    for (pos, line) in rendered_buffer.iter().enumerate() {\n        for part in line {\n            dst.apply_style(lvl.clone(), part.style)?;\n            write!(dst, \"{}\", part.text)?;\n            dst.reset()?;\n        }\n        if !short_message && (!lvl.is_failure_note() || pos != rendered_buffer.len() - 1) {\n            write!(dst, \"\\n\")?;\n        }\n    }\n    dst.flush()?;\n    Ok(())\n"]]}
{"hexsha": "63002339256b5b3b228ded2b86ff3153e0921cd3", "ext": "rs", "lang": "Rust", "content": "fn compile_resources() -> BuildResult<()> {\n    const VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n\n    let template = fs::read_to_string(\"assets/miniraw.rc.in\")?;\n    let parts = VERSION.split('.').collect::<Vec<_>>();\n    let app_version_windows = if parts.len() >= 3 {\n        format!(\"{},{},{},0\", parts[0], parts[1], parts[2])\n    } else {\n        \"0,0,0,0\".to_owned()\n    };\n    let rc = template\n        .replace(\"@APP_VERSION_WINDOWS@\", &app_version_windows)\n        .replace(\"@APP_VERSION@\", VERSION)\n        .replace(\n            \"@ROOT@\",\n            &env::var(\"CARGO_MANIFEST_DIR\")?.replace('\\\\', \"/\"),\n        );\n\n    let rc_path = Path::new(&env::var(\"OUT_DIR\")?).join(\"miniraw.rc\");\n    fs::write(&rc_path, rc.as_bytes())?;\n\n    embed_resource::compile(rc_path);\n\n    Ok(())\n}", "item_id": 0, "repo": "dremon/miniraw", "file": "build.rs", "last_update_at": "2019-12-19T23:48:23+00:00", "question_id": "63002339256b5b3b228ded2b86ff3153e0921cd3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn compile_resources() -> BuildResult<()> {\n    const VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n    let template = fs::read_to_string(\"assets/miniraw.rc.in\")?;\n    let parts = VERSION.split('.').collect::<Vec<_>>();\n    let app_version_windows = if parts.len() >= 3 {\n        format!(\"{},{},{},0\", parts[0], parts[1], parts[2])\n    } else {\n        \"0,0,0,0\".to_owned()\n    };\n    let rc = template\n        .replace(\"@APP_VERSION_WINDOWS@\", &app_version_windows)\n        .replace(\"@APP_VERSION@\", VERSION)\n        .replace(\n            \"@ROOT@\",\n            &env::var(\"CARGO_MANIFEST_DIR\")?.replace('\\\\', \"/\"),\n        );\n    let rc_path = Path::new(&env::var(\"OUT_DIR\")?).join(\"miniraw.rc\");\n    fs::write(&rc_path, rc.as_bytes())?;\n    embed_resource::compile(rc_path);\n    Ok(())\n"]]}
{"hexsha": "a093d1ae8fc9854446f95a48e277505f7c83482c", "ext": "rs", "lang": "Rust", "content": "fn test_scan() {\n        let table_id = 1;\n        let pk = table::encode_row_key(table_id, b\"key1\");\n        let pv = b\"value1\";\n        let test_data = vec![\n            (pk.clone(), pv.to_vec()),\n            (table::encode_row_key(table_id, b\"key2\"), b\"value2\".to_vec()),\n        ];\n        let mut statistics = Statistics::default();\n        let mut test_store = TestStore::new(&test_data);\n        let (snapshot, start_ts) = test_store.get_snapshot();\n        let store = SnapshotStore::new(snapshot, start_ts, IsolationLevel::SI, true);\n        let mut scanner = Scanner::new(store, false, false, &mut statistics);\n        let range = get_range(table_id, i64::MIN, i64::MAX);\n        for &(ref k, ref v) in &test_data {\n            let (key, value) = scanner.next_row(&range).unwrap().unwrap();\n            let seek_key = prefix_next(&key);\n            scanner.set_seek_key(Some(seek_key));\n            assert_eq!(*k, key);\n            assert_eq!(*v, value);\n        }\n        assert!(scanner.next_row(&range).unwrap().is_none());\n    }", "item_id": 5, "repo": "hicqu/tikv", "file": "src/coprocessor/dag/executor/scanner.rs", "last_update_at": "2019-06-28T14:11:52+00:00", "question_id": "a093d1ae8fc9854446f95a48e277505f7c83482c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_scan() {\n        let table_id = 1;\n        let pk = table::encode_row_key(table_id, b\"key1\");\n        let pv = b\"value1\";\n        let test_data = vec![\n            (pk.clone(), pv.to_vec()),\n            (table::encode_row_key(table_id, b\"key2\"), b\"value2\".to_vec()),\n        ];\n        let mut statistics = Statistics::default();\n        let mut test_store = TestStore::new(&test_data);\n        let (snapshot, start_ts) = test_store.get_snapshot();\n        let store = SnapshotStore::new(snapshot, start_ts, IsolationLevel::SI, true);\n        let mut scanner = Scanner::new(store, false, false, &mut statistics);\n        let range = get_range(table_id, i64::MIN, i64::MAX);\n        for &(ref k, ref v) in &test_data {\n            let (key, value) = scanner.next_row(&range).unwrap().unwrap();\n            let seek_key = prefix_next(&key);\n            scanner.set_seek_key(Some(seek_key));\n            assert_eq!(*k, key);\n            assert_eq!(*v, value);\n        }\n        assert!(scanner.next_row(&range).unwrap().is_none());\n"]]}
{"hexsha": "9a979beb3aa2c43c90ae9366df5d52fb3ad55958", "ext": "rs", "lang": "Rust", "content": "fn number_01() {\n    let mut b = \"#define SYSTEM_FUNCT_CONTROL    (4'hf)\".as_bytes();\n    let mut l = Lexer::new(&mut b);\n\n    assert_eq!(\n        l.next(true),\n        Token::new(TokenClass::Symbol(Symbol::Sharp), 1, 1)\n    );\n    assert_eq!(\n        l.next(true),\n        Token::new(TokenClass::Macro(Macro::Define), 1, 2)\n    );\n    assert_eq!(\n        l.next(true),\n        Token::new(\n            TokenClass::Identifire(\"SYSTEM_FUNCT_CONTROL\".to_string()),\n            1,\n            3\n        )\n    );\n    assert_eq!(\n        l.next(true),\n        Token::new(TokenClass::Symbol(Symbol::LeftParen), 1, 4)\n    );\n    assert_eq!(\n        l.next(true),\n        Token::new(TokenClass::Number(\"4'hf\".to_string()), 1, 5)\n    );\n    assert_eq!(\n        l.next(true),\n        Token::new(TokenClass::Symbol(Symbol::RightParen), 1, 6)\n    );\n}", "item_id": 24, "repo": "sux2mfgj/nslfmt", "file": "tests/lexer.rs", "last_update_at": "2019-10-07T02:44:41+00:00", "question_id": "9a979beb3aa2c43c90ae9366df5d52fb3ad55958_24", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn number_01() {\n    let mut b = \"#define SYSTEM_FUNCT_CONTROL    (4'hf)\".as_bytes();\n    let mut l = Lexer::new(&mut b);\n    assert_eq!(\n        l.next(true),\n        Token::new(TokenClass::Symbol(Symbol::Sharp), 1, 1)\n    );\n    assert_eq!(\n        l.next(true),\n        Token::new(TokenClass::Macro(Macro::Define), 1, 2)\n    );\n    assert_eq!(\n        l.next(true),\n        Token::new(\n            TokenClass::Identifire(\"SYSTEM_FUNCT_CONTROL\".to_string()),\n            1,\n            3\n        )\n    );\n    assert_eq!(\n        l.next(true),\n        Token::new(TokenClass::Symbol(Symbol::LeftParen), 1, 4)\n    );\n    assert_eq!(\n        l.next(true),\n        Token::new(TokenClass::Number(\"4'hf\".to_string()), 1, 5)\n    );\n    assert_eq!(\n        l.next(true),\n        Token::new(TokenClass::Symbol(Symbol::RightParen), 1, 6)\n    );\n"]]}
{"hexsha": "f017aa46723fb74d6f27790b365aae9b5c0969ca", "ext": "rs", "lang": "Rust", "content": "pub fn ProgressDelay(props: &Props) -> Html {\n    let Props { duration_ms, .. } = props.clone();\n\n    let value = {\n        let props = props.clone();\n        use_reducer(move || ValueState {\n            start: Instant::now(),\n            value: 0.0,\n\n            props,\n        })\n    };\n\n    {\n        let value = value.clone();\n        use_effect_with_deps(\n            move |_| {\n                let interval = (duration_ms / RESOLUTION).min(MIN_INTERVAL_MS);\n                let interval =\n                    Interval::new(interval as u32, move || value.dispatch(ValueAction::Tick));\n\n                || {\n                    let _interval = interval;\n                }\n            },\n            (),\n        );\n    }\n\n    {\n        let value = value.clone();\n        use_effect_with_deps(\n            move |props| {\n                value.dispatch(ValueAction::Props(props.clone()));\n                || {}\n            },\n            props.clone(),\n        );\n    }\n\n    let value = &value.value;\n\n    html! {\n        <progress class=\"progress is-primary\" value={value.to_string()} max=1.0>\n            { format!(\"{:.0}%\", 100.0 * value) }\n        </progress>\n    }\n}", "item_id": 0, "repo": "lostinspiration/yew", "file": "examples/function_router/src/components/progress_delay.rs", "last_update_at": "2019-08-04T03:56:11+00:00", "question_id": "f017aa46723fb74d6f27790b365aae9b5c0969ca_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn ProgressDelay(props: &Props) -> Html {\n    let Props { duration_ms, .. } = props.clone();\n    let value = {\n        let props = props.clone();\n        use_reducer(move || ValueState {\n            start: Instant::now(),\n            value: 0.0,\n            props,\n        })\n    };\n    {\n        let value = value.clone();\n        use_effect_with_deps(\n            move |_| {\n                let interval = (duration_ms / RESOLUTION).min(MIN_INTERVAL_MS);\n                let interval =\n                    Interval::new(interval as u32, move || value.dispatch(ValueAction::Tick));\n                || {\n                    let _interval = interval;\n                }\n            },\n            (),\n        );\n    }\n    {\n        let value = value.clone();\n        use_effect_with_deps(\n            move |props| {\n                value.dispatch(ValueAction::Props(props.clone()));\n                || {}\n            },\n            props.clone(),\n        );\n    }\n    let value = &value.value;\n    html! {\n        <progress class=\"progress is-primary\" value={value.to_string()} max=1.0>\n            { format!(\"{:.0}%\", 100.0 * value) }\n        </progress>\n    }\n"]]}
{"hexsha": "ce0e2c840fb308e77b8479ebf63837c612040a52", "ext": "rs", "lang": "Rust", "content": "pub fn add_two_numbers(\n    l1: Option<Box<ListNode>>,\n    l2: Option<Box<ListNode>>,\n) -> Option<Box<ListNode>> {\n    let mut dummy = Box::new(ListNode::new(0));\n    // Secondary pointer\n    let mut cur = &mut dummy;\n    let mut sum = 0;\n\n    let mut l1 = l1.as_ref();\n    let mut l2 = l2.as_ref();\n    while l1.is_some() || l2.is_some() {\n        match l1 {\n            Some(ref node) => {\n                sum += node.val;\n                l1 = l1.unwrap().next.as_ref();\n                // or\n                // l1 = l1.map(|n| n.next.as_ref()).unwrap_or(None);\n            }\n            None => {}\n        }\n\n        match l2 {\n            Some(ref node) => {\n                sum += node.val;\n                l2 = l2.unwrap().next.as_ref();\n            }\n            None => {}\n        }\n\n        cur.next = Some(Box::new(ListNode::new(sum % 10)));\n        sum /= 10;\n        cur = cur.next.as_mut().unwrap();\n    }\n\n    if sum != 0 {\n        cur.next = Some(Box::new(ListNode::new(1)));\n    }\n\n    dummy.next\n}", "item_id": 0, "repo": "yjhmelody/leetcode-rust", "file": "src/add_two_numbers.rs", "last_update_at": "2019-06-05T06:51:56+00:00", "question_id": "ce0e2c840fb308e77b8479ebf63837c612040a52_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn add_two_numbers(\n    l1: Option<Box<ListNode>>,\n    l2: Option<Box<ListNode>>,\n) -> Option<Box<ListNode>> {\n    let mut dummy = Box::new(ListNode::new(0));\n    // Secondary pointer\n    let mut cur = &mut dummy;\n    let mut sum = 0;\n    let mut l1 = l1.as_ref();\n    let mut l2 = l2.as_ref();\n    while l1.is_some() || l2.is_some() {\n        match l1 {\n            Some(ref node) => {\n                sum += node.val;\n                l1 = l1.unwrap().next.as_ref();\n                // or\n                // l1 = l1.map(|n| n.next.as_ref()).unwrap_or(None);\n            }\n            None => {}\n        }\n        match l2 {\n            Some(ref node) => {\n                sum += node.val;\n                l2 = l2.unwrap().next.as_ref();\n            }\n            None => {}\n        }\n        cur.next = Some(Box::new(ListNode::new(sum % 10)));\n        sum /= 10;\n        cur = cur.next.as_mut().unwrap();\n    }\n    if sum != 0 {\n        cur.next = Some(Box::new(ListNode::new(1)));\n    }\n    dummy.next\n"]]}
{"hexsha": "1df1be4ce7f6a5fb76415b5ebe3f6a95ace12a41", "ext": "rs", "lang": "Rust", "content": "fn should_move_transactions_to_future_if_gap_introduced() {\n\t// given\n\tlet txq = new_queue();\n\tlet (tx, tx2) = Tx::default().signed_pair();\n\tlet hash = tx.hash();\n\tlet tx3 = Tx::default().signed();\n\n\tlet res = txq.import(TestClient::new(), vec![tx3, tx2].local());\n\tassert_eq!(res, vec![Ok(()), Ok(())]);\n\tassert_eq!(txq.status().status.transaction_count, 2);\n\tassert_eq!(txq.pending(TestClient::new(), PendingSettings::all_prioritized(0, 0)).len(), 1);\n\n\tlet res = txq.import(TestClient::new(), vec![tx].local());\n\tassert_eq!(res, vec![Ok(())]);\n\tassert_eq!(txq.status().status.transaction_count, 3);\n\tassert_eq!(txq.pending(TestClient::new(), PendingSettings::all_prioritized(0, 0)).len(), 3);\n\n\t// when\n\ttxq.remove(vec![&hash], true);\n\n\t// then\n\tassert_eq!(txq.status().status.transaction_count, 2);\n\tassert_eq!(txq.pending(TestClient::new(), PendingSettings::all_prioritized(0, 0)).len(), 1);\n}", "item_id": 16, "repo": "altice-io/Daqiao", "file": "bridge/parity-ethereum/miner/src/pool/tests/mod.rs", "last_update_at": "2019-09-11T12:07:35+00:00", "question_id": "1df1be4ce7f6a5fb76415b5ebe3f6a95ace12a41_16", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn should_move_transactions_to_future_if_gap_introduced() {\n\t// given\n\tlet txq = new_queue();\n\tlet (tx, tx2) = Tx::default().signed_pair();\n\tlet hash = tx.hash();\n\tlet tx3 = Tx::default().signed();\n\tlet res = txq.import(TestClient::new(), vec![tx3, tx2].local());\n\tassert_eq!(res, vec![Ok(()), Ok(())]);\n\tassert_eq!(txq.status().status.transaction_count, 2);\n\tassert_eq!(txq.pending(TestClient::new(), PendingSettings::all_prioritized(0, 0)).len(), 1);\n\tlet res = txq.import(TestClient::new(), vec![tx].local());\n\tassert_eq!(res, vec![Ok(())]);\n\tassert_eq!(txq.status().status.transaction_count, 3);\n\tassert_eq!(txq.pending(TestClient::new(), PendingSettings::all_prioritized(0, 0)).len(), 3);\n\t// when\n\ttxq.remove(vec![&hash], true);\n\t// then\n\tassert_eq!(txq.status().status.transaction_count, 2);\n\tassert_eq!(txq.pending(TestClient::new(), PendingSettings::all_prioritized(0, 0)).len(), 1);\n"]]}
{"hexsha": "862e1bcb28fb7e5e9044737f10b3949d9c2b6d3e", "ext": "rs", "lang": "Rust", "content": "fn resolve_and_backtracking() {\n    let p = project(\"foo\")\n        .file(\"Cargo.toml\", r#\"\n            [project]\n            name = \"bar\"\n            version = \"0.5.0\"\n            authors = []\n\n            [dependencies]\n            foo = \"*\"\n        \"#)\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n\n    Package::new(\"foo\", \"0.1.1\")\n            .feature_dep(\"bar\", \"0.1\", &[\"a\", \"b\"])\n            .publish();\n    Package::new(\"foo\", \"0.1.0\").publish();\n\n    assert_that(p.cargo(\"build\"),\n                execs().with_status(0));\n}", "item_id": 29, "repo": "cnmade/cargo", "file": "tests/registry.rs", "last_update_at": "2019-07-19T20:12:12+00:00", "question_id": "862e1bcb28fb7e5e9044737f10b3949d9c2b6d3e_29", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn resolve_and_backtracking() {\n    let p = project(\"foo\")\n        .file(\"Cargo.toml\", r#\"\n            [project]\n            name = \"bar\"\n            version = \"0.5.0\"\n            authors = []\n            [dependencies]\n            foo = \"*\"\n        \"#)\n        .file(\"src/main.rs\", \"fn main() {}\")\n        .build();\n    Package::new(\"foo\", \"0.1.1\")\n            .feature_dep(\"bar\", \"0.1\", &[\"a\", \"b\"])\n            .publish();\n    Package::new(\"foo\", \"0.1.0\").publish();\n    assert_that(p.cargo(\"build\"),\n                execs().with_status(0));\n"]]}
{"hexsha": "3140f68555fc3fe4de664a89b6fc66d189062d27", "ext": "rs", "lang": "Rust", "content": "fn test_rate_limit_basic() {\n        let mut core = Core::new().unwrap();\n        let handle = core.handle();\n\n        let (rl_sender, rl_receiver) = rate_limit_channel(5, 1, &handle);\n        let source_stream = stream::iter_ok(0 .. 100u32);\n\n        handle.spawn(\n            source_stream.forward(rl_sender)\n            .map_err(|_e: mpsc::SendError<u32>| ())\n            .and_then(|_| Ok(()))\n        );\n\n        let mut res_vec = Vec::new();\n        {\n            let recv_future = rl_receiver.for_each(|item| {\n                res_vec.push(item);\n                Ok(())\n            }); \n            core.run(recv_future).unwrap();\n        }\n\n        let expected_vec = (0 .. 100).collect::<Vec<u32>>();\n        assert_eq!(res_vec, expected_vec);\n    }", "item_id": 1, "repo": "realcr/fragmentos", "file": "src/rate_limit.rs", "last_update_at": "2019-09-10T14:47:07+00:00", "question_id": "3140f68555fc3fe4de664a89b6fc66d189062d27_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_rate_limit_basic() {\n        let mut core = Core::new().unwrap();\n        let handle = core.handle();\n        let (rl_sender, rl_receiver) = rate_limit_channel(5, 1, &handle);\n        let source_stream = stream::iter_ok(0 .. 100u32);\n        handle.spawn(\n            source_stream.forward(rl_sender)\n            .map_err(|_e: mpsc::SendError<u32>| ())\n            .and_then(|_| Ok(()))\n        );\n        let mut res_vec = Vec::new();\n        {\n            let recv_future = rl_receiver.for_each(|item| {\n                res_vec.push(item);\n                Ok(())\n            }); \n            core.run(recv_future).unwrap();\n        }\n        let expected_vec = (0 .. 100).collect::<Vec<u32>>();\n        assert_eq!(res_vec, expected_vec);\n"]]}
{"hexsha": "171528595e8411d168912ec7ceac499215efacc7", "ext": "rs", "lang": "Rust", "content": "fn read_varint<R: Read>(r: &mut R) -> std::io::Result<u64> {\n    let mut b = [0_u8];\n    r.read_exact(&mut b)?;\n    Ok(match b[0] {\n        0xff => {\n            let mut b = [0_u8; 8];\n            r.read_exact(&mut b)?;\n            u64::from_be_bytes(b)\n        }\n        0xfe => {\n            let mut b = [0_u8; 4];\n            r.read_exact(&mut b)?;\n            u32::from_be_bytes(b) as u64\n        }\n        0xfd => {\n            let mut b = [0_u8; 2];\n            r.read_exact(&mut b)?;\n            u16::from_be_bytes(b) as u64\n        }\n        n => n as u64,\n    })\n}", "item_id": 0, "repo": "DR-BoneZ/lightning-wire-msgs-rs", "file": "expanded/src/lib.rs", "last_update_at": "2019-09-04T01:31:09+00:00", "question_id": "171528595e8411d168912ec7ceac499215efacc7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_varint<R: Read>(r: &mut R) -> std::io::Result<u64> {\n    let mut b = [0_u8];\n    r.read_exact(&mut b)?;\n    Ok(match b[0] {\n        0xff => {\n            let mut b = [0_u8; 8];\n            r.read_exact(&mut b)?;\n            u64::from_be_bytes(b)\n        }\n        0xfe => {\n            let mut b = [0_u8; 4];\n            r.read_exact(&mut b)?;\n            u32::from_be_bytes(b) as u64\n        }\n        0xfd => {\n            let mut b = [0_u8; 2];\n            r.read_exact(&mut b)?;\n            u16::from_be_bytes(b) as u64\n        }\n        n => n as u64,\n    })\n"]]}
{"hexsha": "f7ae5f9680f23adb5272273c5c3ddcb768c21af0", "ext": "rs", "lang": "Rust", "content": "fn can_read_full_type_3_chunk() {\n        let csid = 50;\n        let timestamp = 20;\n        let delta1 = 10;\n        let delta2 = 12;\n        let message_stream_id = 52;\n        let type_id = 3;\n        let payload1 = vec![1, 2, 3];\n        let payload2 = vec![1, 2, 3];\n        let payload3 = vec![2, 2, 2];\n        let payload4 = vec![4, 4, 4];\n\n        let chunk_0_bytes = get_type_0_chunk(csid, timestamp, message_stream_id, type_id, payload1);        \n        let chunk_1_bytes = get_type_1_chunk(csid, delta1, type_id, payload2);\n        let chunk_2_bytes = get_type_2_chunk(csid, delta2, payload3);\n        let chunk_3_bytes = get_type_3_chunk(csid, payload4);\n\n        let mut deserializer = Deserializer::new();\n        deserializer.process_bytes(&chunk_0_bytes).unwrap();\n        deserializer.process_bytes(&chunk_1_bytes).unwrap();\n        deserializer.process_bytes(&chunk_2_bytes).unwrap();\n\n        let result = deserializer.process_bytes(&chunk_3_bytes).unwrap();\n\n        assert_eq!(1, result.len());\n        assert_eq!(timestamp + delta1 + delta2 + delta2, result[0].timestamp);\n        assert_eq!(type_id, result[0].type_id);\n        assert_eq!(message_stream_id, result[0].stream_id);\n        assert_eq!(vec![4, 4, 4], result[0].data);\n    }", "item_id": 7, "repo": "KallDrexx/mmids-rust", "file": "rtmp_chunk_io/src/deserialization.rs", "last_update_at": "2019-04-02T23:27:04+00:00", "question_id": "f7ae5f9680f23adb5272273c5c3ddcb768c21af0_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn can_read_full_type_3_chunk() {\n        let csid = 50;\n        let timestamp = 20;\n        let delta1 = 10;\n        let delta2 = 12;\n        let message_stream_id = 52;\n        let type_id = 3;\n        let payload1 = vec![1, 2, 3];\n        let payload2 = vec![1, 2, 3];\n        let payload3 = vec![2, 2, 2];\n        let payload4 = vec![4, 4, 4];\n        let chunk_0_bytes = get_type_0_chunk(csid, timestamp, message_stream_id, type_id, payload1);        \n        let chunk_1_bytes = get_type_1_chunk(csid, delta1, type_id, payload2);\n        let chunk_2_bytes = get_type_2_chunk(csid, delta2, payload3);\n        let chunk_3_bytes = get_type_3_chunk(csid, payload4);\n        let mut deserializer = Deserializer::new();\n        deserializer.process_bytes(&chunk_0_bytes).unwrap();\n        deserializer.process_bytes(&chunk_1_bytes).unwrap();\n        deserializer.process_bytes(&chunk_2_bytes).unwrap();\n        let result = deserializer.process_bytes(&chunk_3_bytes).unwrap();\n        assert_eq!(1, result.len());\n        assert_eq!(timestamp + delta1 + delta2 + delta2, result[0].timestamp);\n        assert_eq!(type_id, result[0].type_id);\n        assert_eq!(message_stream_id, result[0].stream_id);\n        assert_eq!(vec![4, 4, 4], result[0].data);\n"]]}
{"hexsha": "ce67a888bc467015393e20315440f93e728daa41", "ext": "rs", "lang": "Rust", "content": "fn trailing_zero_should_work() {\n\t\tlet mut t = super::TrailingZeroInput(&[1, 2, 3]);\n\t\tassert_eq!(t.remaining_len(), Ok(None));\n\t\tlet mut buffer = [0u8; 2];\n\t\tassert_eq!(t.read(&mut buffer), Ok(()));\n\t\tassert_eq!(t.remaining_len(), Ok(None));\n\t\tassert_eq!(buffer, [1, 2]);\n\t\tassert_eq!(t.read(&mut buffer), Ok(()));\n\t\tassert_eq!(t.remaining_len(), Ok(None));\n\t\tassert_eq!(buffer, [3, 0]);\n\t\tassert_eq!(t.read(&mut buffer), Ok(()));\n\t\tassert_eq!(t.remaining_len(), Ok(None));\n\t\tassert_eq!(buffer, [0, 0]);\n\t}", "item_id": 1, "repo": "HPIPS/HPIPS_Chain", "file": "core/sr-primitives/src/traits.rs", "last_update_at": "2019-08-07T10:22:08+00:00", "question_id": "ce67a888bc467015393e20315440f93e728daa41_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn trailing_zero_should_work() {\n\t\tlet mut t = super::TrailingZeroInput(&[1, 2, 3]);\n\t\tassert_eq!(t.remaining_len(), Ok(None));\n\t\tlet mut buffer = [0u8; 2];\n\t\tassert_eq!(t.read(&mut buffer), Ok(()));\n\t\tassert_eq!(t.remaining_len(), Ok(None));\n\t\tassert_eq!(buffer, [1, 2]);\n\t\tassert_eq!(t.read(&mut buffer), Ok(()));\n\t\tassert_eq!(t.remaining_len(), Ok(None));\n\t\tassert_eq!(buffer, [3, 0]);\n\t\tassert_eq!(t.read(&mut buffer), Ok(()));\n\t\tassert_eq!(t.remaining_len(), Ok(None));\n\t\tassert_eq!(buffer, [0, 0]);\n"]]}
{"hexsha": "e95c9c0c731d1cfd82297bb9c368dab29e5e0369", "ext": "rs", "lang": "Rust", "content": "fn write() {\n        let p: &Path = &TestPath::new().path;\n        let f: TestFile = TestFile::new(p);\n        let s: String = String::from(\"Hello, world!\");\n        let mut c: ConfigFile<StringFormat> = ConfigFile::new(p, StringFormat::new());\n\n        c.content = Some(s.clone());\n        c.write().unwrap();\n\n        assert_eq!(f.read(), s);\n    }", "item_id": 1, "repo": "aery-chan/crate-that-loads-configs", "file": "src/config_file.rs", "last_update_at": "2019-09-13T16:00:53+00:00", "question_id": "e95c9c0c731d1cfd82297bb9c368dab29e5e0369_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn write() {\n        let p: &Path = &TestPath::new().path;\n        let f: TestFile = TestFile::new(p);\n        let s: String = String::from(\"Hello, world!\");\n        let mut c: ConfigFile<StringFormat> = ConfigFile::new(p, StringFormat::new());\n        c.content = Some(s.clone());\n        c.write().unwrap();\n        assert_eq!(f.read(), s);\n"]]}
{"hexsha": "3d55062c5244f88dcd462a368f5ca932bdf94007", "ext": "rs", "lang": "Rust", "content": "fn spec_test_627() {\n    let original = r##\"foo <a href=\"&ouml;\">\n\"##;\n    let expected = r##\"<p>foo <a href=\"&ouml;\"></p>\n\"##;\n\n    test_markdown_html(original, expected);\n}", "item_id": 626, "repo": "NaokiM03/pulldown-cmark", "file": "tests/suite/spec.rs", "last_update_at": "2019-07-11T13:20:46+00:00", "question_id": "3d55062c5244f88dcd462a368f5ca932bdf94007_626", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn spec_test_627() {\n    let original = r##\"foo <a href=\"&ouml;\">\n\"##;\n    let expected = r##\"<p>foo <a href=\"&ouml;\"></p>\n\"##;\n    test_markdown_html(original, expected);\n"]]}
{"hexsha": "918f2eeb9cbd57c26e281ee6f0c9b936907401cc", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn call() {\n    let contract_key: Key = contract_api::get_uref(\"hello_ext\")\n        .unwrap_or_else(|| contract_api::revert(Error::HelloExtNotFound as u32));\n    let contract_pointer: ContractPointer = match contract_key {\n        Key::Hash(hash) => ContractPointer::Hash(hash),\n        _ => contract_api::revert(Error::InvalidURef as u32),\n    };\n\n    let extra_urefs = [].to_vec();\n\n    let result: URef = contract_api::call_contract(contract_pointer, &(), &extra_urefs);\n\n    let value: String = contract_api::read(TURef::from_uref(result).unwrap());\n\n    assert_eq!(\"Hello, world!\", &value);\n}", "item_id": 0, "repo": "Tominous/CasperLabs", "file": "execution-engine/contracts/test/ee-401-regression-call/src/lib.rs", "last_update_at": "2019-09-18T18:14:02+00:00", "question_id": "918f2eeb9cbd57c26e281ee6f0c9b936907401cc_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub extern \"C\" fn call() {\n    let contract_key: Key = contract_api::get_uref(\"hello_ext\")\n        .unwrap_or_else(|| contract_api::revert(Error::HelloExtNotFound as u32));\n    let contract_pointer: ContractPointer = match contract_key {\n        Key::Hash(hash) => ContractPointer::Hash(hash),\n        _ => contract_api::revert(Error::InvalidURef as u32),\n    };\n    let extra_urefs = [].to_vec();\n    let result: URef = contract_api::call_contract(contract_pointer, &(), &extra_urefs);\n    let value: String = contract_api::read(TURef::from_uref(result).unwrap());\n    assert_eq!(\"Hello, world!\", &value);\n"]]}
{"hexsha": "a7c8edf50102a79a2cd1e1106b5eb3ae8f8add54", "ext": "rs", "lang": "Rust", "content": "fn splice<'a>(env: &'a Env, this: Value<'a, Object>, args: &[Value<'a, Any>]) -> Result<Option<Value<'a, Any>>> {\n        let start: usize = args[0].try_into()?.into();\n        let count: usize = args[1].try_into()?.into();\n        let new_text: Vec<u16> = args[2].try_into()?.into();\n\n        let buffer: &Rc<RefCell<Buffer>> = env.unwrap(&this)?;\n        buffer.borrow_mut().splice(start..(start + count), new_text);\n\n        Ok(None)\n    }", "item_id": 2, "repo": "imajeet/xray", "file": "xray_node/src/lib.rs", "last_update_at": "2019-07-26T16:29:35+00:00", "question_id": "a7c8edf50102a79a2cd1e1106b5eb3ae8f8add54_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn splice<'a>(env: &'a Env, this: Value<'a, Object>, args: &[Value<'a, Any>]) -> Result<Option<Value<'a, Any>>> {\n        let start: usize = args[0].try_into()?.into();\n        let count: usize = args[1].try_into()?.into();\n        let new_text: Vec<u16> = args[2].try_into()?.into();\n        let buffer: &Rc<RefCell<Buffer>> = env.unwrap(&this)?;\n        buffer.borrow_mut().splice(start..(start + count), new_text);\n        Ok(None)\n"]]}
{"hexsha": "12de4f73542f765810aac7e57fde9ff38f487d01", "ext": "rs", "lang": "Rust", "content": "fn write_untyped_local(key_bytes: &[u8], value: &Value) {\n    let key_bytes_ptr = key_bytes.as_ptr();\n    let key_bytes_size = key_bytes.len();\n    let (value_ptr, value_size, _bytes2) = to_ptr(value);\n    unsafe {\n        ext_ffi::write_local(key_bytes_ptr, key_bytes_size, value_ptr, value_size);\n    }\n}", "item_id": 6, "repo": "flowstake/CasperLabs", "file": "execution-engine/contract-ffi/src/contract_api/storage.rs", "last_update_at": "2019-10-16T06:05:41+00:00", "question_id": "12de4f73542f765810aac7e57fde9ff38f487d01_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn write_untyped_local(key_bytes: &[u8], value: &Value) {\n    let key_bytes_ptr = key_bytes.as_ptr();\n    let key_bytes_size = key_bytes.len();\n    let (value_ptr, value_size, _bytes2) = to_ptr(value);\n    unsafe {\n        ext_ffi::write_local(key_bytes_ptr, key_bytes_size, value_ptr, value_size);\n    }\n"]]}
{"hexsha": "902691511daa064a7d1f43f98f73b957650de43d", "ext": "rs", "lang": "Rust", "content": "pub fn load_dump(\n    meta: Metadata,\n    src: impl AsRef<Path>,\n    dst: impl AsRef<Path>,\n    index_db_size: usize,\n    meta_env_size: usize,\n    indexing_options: &IndexerOpts,\n) -> anyhow::Result<()> {\n    info!(\"Patching dump V3 to dump V4...\");\n\n    let patched_dir = tempdir()?;\n\n    let options = CopyOptions::default();\n    dir::copy(src.as_ref().join(\"indexes\"), patched_dir.path(), &options)?;\n    dir::copy(\n        src.as_ref().join(\"index_uuids\"),\n        patched_dir.path(),\n        &options,\n    )?;\n\n    let uuid_map = patch_index_meta(\n        src.as_ref().join(\"index_uuids/data.jsonl\"),\n        patched_dir.path(),\n    )?;\n\n    fs::copy(\n        src.as_ref().join(\"metadata.json\"),\n        patched_dir.path().join(\"metadata.json\"),\n    )?;\n\n    patch_updates(&src, patched_dir.path(), uuid_map)?;\n\n    super::v4::load_dump(\n        meta,\n        patched_dir.path(),\n        dst,\n        index_db_size,\n        meta_env_size,\n        indexing_options,\n    )\n}", "item_id": 0, "repo": "phial3/MeiliSearch", "file": "meilisearch-lib/src/index_controller/dump_actor/loaders/v3.rs", "last_update_at": "2019-11-26T09:01:30+00:00", "question_id": "902691511daa064a7d1f43f98f73b957650de43d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn load_dump(\n    meta: Metadata,\n    src: impl AsRef<Path>,\n    dst: impl AsRef<Path>,\n    index_db_size: usize,\n    meta_env_size: usize,\n    indexing_options: &IndexerOpts,\n) -> anyhow::Result<()> {\n    info!(\"Patching dump V3 to dump V4...\");\n    let patched_dir = tempdir()?;\n    let options = CopyOptions::default();\n    dir::copy(src.as_ref().join(\"indexes\"), patched_dir.path(), &options)?;\n    dir::copy(\n        src.as_ref().join(\"index_uuids\"),\n        patched_dir.path(),\n        &options,\n    )?;\n    let uuid_map = patch_index_meta(\n        src.as_ref().join(\"index_uuids/data.jsonl\"),\n        patched_dir.path(),\n    )?;\n    fs::copy(\n        src.as_ref().join(\"metadata.json\"),\n        patched_dir.path().join(\"metadata.json\"),\n    )?;\n    patch_updates(&src, patched_dir.path(), uuid_map)?;\n    super::v4::load_dump(\n        meta,\n        patched_dir.path(),\n        dst,\n        index_db_size,\n        meta_env_size,\n        indexing_options,\n    )\n"]]}
{"hexsha": "6d056f9b5880c8e6f933ab4571208896692720e6", "ext": "rs", "lang": "Rust", "content": "fn _get_members(group: &rdkafka::groups::GroupInfo) -> Vec<dto::GroupMemberMetadata> {\n    let mut members = Vec::with_capacity(group.members().len());\n    for member in group.members() {\n        let assignment = match member.assignment() {\n            None => \"\",\n            Some(assgn) => match std::str::from_utf8(assgn) {\n                Ok(v) => v,\n                Err(_) => \"Non-Utf8\",\n            }\n        };\n        let meta = match member.metadata() {\n            None => \"\",\n            Some(data) => match std::str::from_utf8(data) {\n                Ok(v) => v,\n                Err(_) => \"Non-Utf8\",\n            }\n        };\n        members.push(\n            dto::GroupMemberMetadata{\n                member_id: member.id().to_string(),\n                client_id: member.client_id().to_string(),\n                client_host: member.client_host().to_string(),\n                metadata: meta.to_string(),\n                assignment: assignment.to_string(),\n            })\n    }\n    members\n}", "item_id": 10, "repo": "tzachshabtay/kafka-browser", "file": "src/server/kafka/api.rs", "last_update_at": "2019-06-17T13:17:44+00:00", "question_id": "6d056f9b5880c8e6f933ab4571208896692720e6_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn _get_members(group: &rdkafka::groups::GroupInfo) -> Vec<dto::GroupMemberMetadata> {\n    let mut members = Vec::with_capacity(group.members().len());\n    for member in group.members() {\n        let assignment = match member.assignment() {\n            None => \"\",\n            Some(assgn) => match std::str::from_utf8(assgn) {\n                Ok(v) => v,\n                Err(_) => \"Non-Utf8\",\n            }\n        };\n        let meta = match member.metadata() {\n            None => \"\",\n            Some(data) => match std::str::from_utf8(data) {\n                Ok(v) => v,\n                Err(_) => \"Non-Utf8\",\n            }\n        };\n        members.push(\n            dto::GroupMemberMetadata{\n                member_id: member.id().to_string(),\n                client_id: member.client_id().to_string(),\n                client_host: member.client_host().to_string(),\n                metadata: meta.to_string(),\n                assignment: assignment.to_string(),\n            })\n    }\n    members\n"]]}
{"hexsha": "1b2d9b5f363aeb33f36f312a4d6fddaddb2ce611", "ext": "rs", "lang": "Rust", "content": "fn test_newton_gravitational_field() {\n        let grav_result = newton_gravitational_field(\n            &Array3d {\n                x: 1.0,\n                z: 1.0,\n                y: 1.0,\n            },\n            1e15f64,\n        );\n\n        assert!(-12845.0 < grav_result.x && grav_result.x < -12843.0);\n        assert!(-12845.0 < grav_result.y && grav_result.y < -12843.0);\n        assert!(-12845.0 < grav_result.z && grav_result.z < -12843.0);\n    }", "item_id": 3, "repo": "wagnerdylan/POSE", "file": "src/cpu/sim_cpu.rs", "last_update_at": "2019-04-22T16:47:35+00:00", "question_id": "1b2d9b5f363aeb33f36f312a4d6fddaddb2ce611_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_newton_gravitational_field() {\n        let grav_result = newton_gravitational_field(\n            &Array3d {\n                x: 1.0,\n                z: 1.0,\n                y: 1.0,\n            },\n            1e15f64,\n        );\n        assert!(-12845.0 < grav_result.x && grav_result.x < -12843.0);\n        assert!(-12845.0 < grav_result.y && grav_result.y < -12843.0);\n        assert!(-12845.0 < grav_result.z && grav_result.z < -12843.0);\n"]]}
{"hexsha": "aca57c29143659cbac6350849918fd439a686969", "ext": "rs", "lang": "Rust", "content": "async fn main() {\n    env_logger::init();\n\n    let opts = Opt::parse();\n\n    let index_html_s = tokio::fs::read_to_string(opts.dir.join(\"index.html\"))\n        .await\n        .expect(\"failed to read index.html\");\n\n    let handle_error = |e| async move {\n        (\n            StatusCode::INTERNAL_SERVER_ERROR,\n            format!(\"error occurred: {}\", e),\n        )\n    };\n\n    let app = Router::new()\n        .route(\"/api/test\", get(|| async move { \"Hello World\" }))\n        // needed because https://github.com/tower-rs/tower-http/issues/262\n        .route(\"/\", get(render))\n        .fallback(HandleError::new(\n            ServeDir::new(opts.dir)\n                .append_index_html_on_directories(false)\n                .fallback(\n                    render\n                        .layer(Extension(index_html_s))\n                        .into_service()\n                        .map_err(|err| -> std::io::Error { match err {} }),\n                ),\n            handle_error,\n        ));\n\n    println!(\"You can view the website at: http://localhost:8080/\");\n\n    axum::Server::bind(&\"0.0.0.0:8080\".parse().unwrap())\n        .serve(app.into_make_service())\n        .await\n        .unwrap();\n}", "item_id": 1, "repo": "lostinspiration/yew", "file": "examples/ssr_router/src/bin/ssr_router_server.rs", "last_update_at": "2019-08-04T03:56:11+00:00", "question_id": "aca57c29143659cbac6350849918fd439a686969_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn main() {\n    env_logger::init();\n    let opts = Opt::parse();\n    let index_html_s = tokio::fs::read_to_string(opts.dir.join(\"index.html\"))\n        .await\n        .expect(\"failed to read index.html\");\n    let handle_error = |e| async move {\n        (\n            StatusCode::INTERNAL_SERVER_ERROR,\n            format!(\"error occurred: {}\", e),\n        )\n    };\n    let app = Router::new()\n        .route(\"/api/test\", get(|| async move { \"Hello World\" }))\n        // needed because https://github.com/tower-rs/tower-http/issues/262\n        .route(\"/\", get(render))\n        .fallback(HandleError::new(\n            ServeDir::new(opts.dir)\n                .append_index_html_on_directories(false)\n                .fallback(\n                    render\n                        .layer(Extension(index_html_s))\n                        .into_service()\n                        .map_err(|err| -> std::io::Error { match err {} }),\n                ),\n            handle_error,\n        ));\n    println!(\"You can view the website at: http://localhost:8080/\");\n    axum::Server::bind(&\"0.0.0.0:8080\".parse().unwrap())\n        .serve(app.into_make_service())\n        .await\n        .unwrap();\n"]]}
{"hexsha": "3f2d70445a38a9b70f445d6c911e276c010565e2", "ext": "rs", "lang": "Rust", "content": "fn secure_hash(master: &[u8], domain: &[u8]) -> [u8; 64] {\n    let mut hasher = Sha512::new();\n    //Hash the master password a few thousand times\n    hasher.input(SALT);\n    hasher.input(master);\n    let mut master_hash = get_hash(&mut hasher);\n    for i in 0..25_000_u32 {\n        //Generate salt\n        hasher.input(SALT);\n        hasher.input(&i.to_le_bytes()[..]);\n        let salt = get_hash(&mut hasher);\n        //Feed in previous hash, salt and master password to modify hash\n        hasher.input(&salt[..]);\n        hasher.input(&master_hash[..]);\n        hasher.input(master);\n        master_hash = get_hash(&mut hasher);\n    }\n    //Hash both master and domain a few thousand times\n    hasher.input(SALT);\n    hasher.input(domain);\n    hasher.input(master);\n    let mut final_hash = get_hash(&mut hasher);\n    for i in 0..25_000_u32 {\n        //Generate salt for this iteration\n        hasher.input(&i.to_be_bytes());\n        hasher.input(SALT);\n        let salt = get_hash(&mut hasher);\n        //Feed in previous hash, salt and both master and domain in order to modify hash\n        hasher.input(&salt[..]);\n        hasher.input(&final_hash[..]);\n        hasher.input(&master_hash[..]);\n        hasher.input(master);\n        hasher.input(domain);\n        final_hash = get_hash(&mut hasher);\n    }\n    //Hopefully this algorithm is slow enough\n    final_hash\n}", "item_id": 1, "repo": "negamartin/pazzfraze", "file": "src/lib.rs", "last_update_at": "2019-09-25T11:22:08+00:00", "question_id": "3f2d70445a38a9b70f445d6c911e276c010565e2_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn secure_hash(master: &[u8], domain: &[u8]) -> [u8; 64] {\n    let mut hasher = Sha512::new();\n    //Hash the master password a few thousand times\n    hasher.input(SALT);\n    hasher.input(master);\n    let mut master_hash = get_hash(&mut hasher);\n    for i in 0..25_000_u32 {\n        //Generate salt\n        hasher.input(SALT);\n        hasher.input(&i.to_le_bytes()[..]);\n        let salt = get_hash(&mut hasher);\n        //Feed in previous hash, salt and master password to modify hash\n        hasher.input(&salt[..]);\n        hasher.input(&master_hash[..]);\n        hasher.input(master);\n        master_hash = get_hash(&mut hasher);\n    }\n    //Hash both master and domain a few thousand times\n    hasher.input(SALT);\n    hasher.input(domain);\n    hasher.input(master);\n    let mut final_hash = get_hash(&mut hasher);\n    for i in 0..25_000_u32 {\n        //Generate salt for this iteration\n        hasher.input(&i.to_be_bytes());\n        hasher.input(SALT);\n        let salt = get_hash(&mut hasher);\n        //Feed in previous hash, salt and both master and domain in order to modify hash\n        hasher.input(&salt[..]);\n        hasher.input(&final_hash[..]);\n        hasher.input(&master_hash[..]);\n        hasher.input(master);\n        hasher.input(domain);\n        final_hash = get_hash(&mut hasher);\n    }\n    //Hopefully this algorithm is slow enough\n    final_hash\n"]]}
{"hexsha": "0df75b08c2e8741e8f59697eb443e21bc7ad471f", "ext": "rs", "lang": "Rust", "content": "fn two_params(k1: &str, v1: &str, k2: &str, v2: &str) -> Params {\n        let mut map = Params::new();\n        map.insert(k1.to_string(), v1.to_string());\n        map.insert(k2.to_string(), v2.to_string());\n        map\n    }", "item_id": 14, "repo": "allanbenelli/route-recognizer-sgx", "file": "src/lib.rs", "last_update_at": "2019-09-27T02:49:47+00:00", "question_id": "0df75b08c2e8741e8f59697eb443e21bc7ad471f_14", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn two_params(k1: &str, v1: &str, k2: &str, v2: &str) -> Params {\n        let mut map = Params::new();\n        map.insert(k1.to_string(), v1.to_string());\n        map.insert(k2.to_string(), v2.to_string());\n        map\n"]]}
{"hexsha": "6327e1705088064d49c202c7f7c32ea0df70277d", "ext": "rs", "lang": "Rust", "content": "pub fn verify_marking(\n    young: &YoungGen,\n    old_protected: &OldGenProtected,\n    large: &LargeSpace,\n    heap: Region,\n) {\n    for region in &old_protected.regions {\n        let active = region.active_region();\n        verify_marking_region(active, heap);\n    }\n\n    let eden = young.eden_active();\n    verify_marking_region(eden, heap);\n\n    let from = young.from_active();\n    verify_marking_region(from, heap);\n\n    let to = young.to_active();\n    verify_marking_region(to, heap);\n\n    large.visit_objects(|obj_address| {\n        verify_marking_object(obj_address, heap);\n    });\n}", "item_id": 0, "repo": "ashwanidausodia/dora", "file": "dora/src/gc/swiper/compact.rs", "last_update_at": "2019-03-22T22:25:17+00:00", "question_id": "6327e1705088064d49c202c7f7c32ea0df70277d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn verify_marking(\n    young: &YoungGen,\n    old_protected: &OldGenProtected,\n    large: &LargeSpace,\n    heap: Region,\n) {\n    for region in &old_protected.regions {\n        let active = region.active_region();\n        verify_marking_region(active, heap);\n    }\n    let eden = young.eden_active();\n    verify_marking_region(eden, heap);\n    let from = young.from_active();\n    verify_marking_region(from, heap);\n    let to = young.to_active();\n    verify_marking_region(to, heap);\n    large.visit_objects(|obj_address| {\n        verify_marking_object(obj_address, heap);\n    });\n"]]}
{"hexsha": "3bdcb1c594668692dcccd7d9aa194c7568a33d51", "ext": "rs", "lang": "Rust", "content": "fn chunk2x2_sum_uget1(bench: &mut Bencher) {\n    let a = Array::<f32, _>::zeros((256, 256));\n    let chunksz = (2, 2);\n    let mut sum = Array::<f32, _>::zeros(a.exact_chunks(chunksz).raw_dim());\n    bench.iter(|| {\n        let (m, n) = a.dim();\n        for i in 0..m {\n            for j in 0..n {\n                unsafe {\n                    *sum.uget_mut([i / 2, j / 2]) += *a.uget([i, j]);\n                }\n            }\n        }\n    });\n}", "item_id": 3, "repo": "cafeclimber/ndarray", "file": "benches/chunks.rs", "last_update_at": "2019-06-21T09:11:32+00:00", "question_id": "3bdcb1c594668692dcccd7d9aa194c7568a33d51_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn chunk2x2_sum_uget1(bench: &mut Bencher) {\n    let a = Array::<f32, _>::zeros((256, 256));\n    let chunksz = (2, 2);\n    let mut sum = Array::<f32, _>::zeros(a.exact_chunks(chunksz).raw_dim());\n    bench.iter(|| {\n        let (m, n) = a.dim();\n        for i in 0..m {\n            for j in 0..n {\n                unsafe {\n                    *sum.uget_mut([i / 2, j / 2]) += *a.uget([i, j]);\n                }\n            }\n        }\n    });\n"]]}
{"hexsha": "2767f034058e4eab7db9b94e2327cf06ccbce530", "ext": "rs", "lang": "Rust", "content": "fn matches(word: &str, search: &str) -> bool {\n    let mut search = search.chars();\n    for ch in word.chars().skip_while(|ch| !ch.is_alphabetic()) {\n        match search.next() {\n            None => {\n                return !ch.is_alphabetic();\n            }\n            Some(expect) => {\n                if ch.to_lowercase().next() != Some(expect) {\n                    return false;\n                }\n            }\n        }\n    }\n    return search.next().is_none();\n}", "item_id": 0, "repo": "usagi/neon-examples", "file": "word-counting/native/src/lib.rs", "last_update_at": "2019-09-11T09:05:44+00:00", "question_id": "2767f034058e4eab7db9b94e2327cf06ccbce530_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn matches(word: &str, search: &str) -> bool {\n    let mut search = search.chars();\n    for ch in word.chars().skip_while(|ch| !ch.is_alphabetic()) {\n        match search.next() {\n            None => {\n                return !ch.is_alphabetic();\n            }\n            Some(expect) => {\n                if ch.to_lowercase().next() != Some(expect) {\n                    return false;\n                }\n            }\n        }\n    }\n    return search.next().is_none();\n"]]}
{"hexsha": "386571ca246b0caad7784540804701b761513959", "ext": "rs", "lang": "Rust", "content": "fn reverse_id_comparator_correct_order() -> Result<(), Error> {\n        let a = ContextActionByContractIndexKey {\n            contract_address: hex::decode(\"0000cf49f66b9ea137e11818f2a78b4b6fc9895b4e50\")?,\n            id: 6548,\n        }.encode()?;\n        let b = ContextActionByContractIndexKey {\n            contract_address: hex::decode(\"0000cf49f66b9ea137e11818f2a78b4b6fc9895b4e50\")?,\n            id: 6546,\n        }.encode()?;\n\n        Ok(assert_eq!(Ordering::Less, ContextActionByContractIndexKey::reverse_id_comparator(&a, &b)))\n    }", "item_id": 3, "repo": "mrjoe7/tezedge", "file": "storage/src/context_action_storage.rs", "last_update_at": "2019-11-29T18:25:07+00:00", "question_id": "386571ca246b0caad7784540804701b761513959_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn reverse_id_comparator_correct_order() -> Result<(), Error> {\n        let a = ContextActionByContractIndexKey {\n            contract_address: hex::decode(\"0000cf49f66b9ea137e11818f2a78b4b6fc9895b4e50\")?,\n            id: 6548,\n        }.encode()?;\n        let b = ContextActionByContractIndexKey {\n            contract_address: hex::decode(\"0000cf49f66b9ea137e11818f2a78b4b6fc9895b4e50\")?,\n            id: 6546,\n        }.encode()?;\n        Ok(assert_eq!(Ordering::Less, ContextActionByContractIndexKey::reverse_id_comparator(&a, &b)))\n"]]}
{"hexsha": "826fcce4520871552dc7894082787c6104e5acf8", "ext": "rs", "lang": "Rust", "content": "fn test_validate_phase_rejects_partial_def() {\n        let good_value: Option<f64> = Some(0.0);\n        let good_units: Option<AngleType> = Some(AngleType::Degrees);\n        assert!(validate_phase(&good_value, &None).is_err());\n        assert!(validate_phase(&None, &good_units).is_err());\n    }", "item_id": 13, "repo": "zmitchell/polsim", "file": "src/validate.rs", "last_update_at": "2019-10-25T08:14:20+00:00", "question_id": "826fcce4520871552dc7894082787c6104e5acf8_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_validate_phase_rejects_partial_def() {\n        let good_value: Option<f64> = Some(0.0);\n        let good_units: Option<AngleType> = Some(AngleType::Degrees);\n        assert!(validate_phase(&good_value, &None).is_err());\n        assert!(validate_phase(&None, &good_units).is_err());\n"]]}
{"hexsha": "b98228e9b240c63b992bdedf9aff1a639eed4fc4", "ext": "rs", "lang": "Rust", "content": "fn prove_execution_and_proof_check_works() {\n\t\tlet executor = DummyCodeExecutor {\n\t\t\tchange_changes_trie_config: false,\n\t\t\tnative_available: true,\n\t\t\tnative_succeeds: true,\n\t\t\tfallback_succeeds: true,\n\t\t};\n\n\t\t// fetch execution proof from 'remote' full node\n\t\tlet remote_backend = trie_backend::tests::test_trie();\n\t\tlet remote_root = remote_backend.storage_root(::std::iter::empty()).0;\n\t\tlet (remote_result, remote_proof) = prove_execution(remote_backend,\n\t\t\t&mut Default::default(), &executor, \"test\", &[]).unwrap();\n\n\t\t// check proof locally\n\t\tlet local_result = execution_proof_check::<Blake2Hasher, _>(remote_root, remote_proof,\n\t\t\t&mut Default::default(), &executor, \"test\", &[]).unwrap();\n\n\t\t// check that both results are correct\n\t\tassert_eq!(remote_result, vec![66]);\n\t\tassert_eq!(remote_result, local_result);\n\t}", "item_id": 5, "repo": "HPIPS/HPIPS_Chain", "file": "core/state-machine/src/lib.rs", "last_update_at": "2019-08-07T10:22:08+00:00", "question_id": "b98228e9b240c63b992bdedf9aff1a639eed4fc4_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn prove_execution_and_proof_check_works() {\n\t\tlet executor = DummyCodeExecutor {\n\t\t\tchange_changes_trie_config: false,\n\t\t\tnative_available: true,\n\t\t\tnative_succeeds: true,\n\t\t\tfallback_succeeds: true,\n\t\t};\n\t\t// fetch execution proof from 'remote' full node\n\t\tlet remote_backend = trie_backend::tests::test_trie();\n\t\tlet remote_root = remote_backend.storage_root(::std::iter::empty()).0;\n\t\tlet (remote_result, remote_proof) = prove_execution(remote_backend,\n\t\t\t&mut Default::default(), &executor, \"test\", &[]).unwrap();\n\t\t// check proof locally\n\t\tlet local_result = execution_proof_check::<Blake2Hasher, _>(remote_root, remote_proof,\n\t\t\t&mut Default::default(), &executor, \"test\", &[]).unwrap();\n\t\t// check that both results are correct\n\t\tassert_eq!(remote_result, vec![66]);\n\t\tassert_eq!(remote_result, local_result);\n"]]}
{"hexsha": "ce0119bedcd43a5a6bdb3fbb8df4c1ba4c3567b7", "ext": "rs", "lang": "Rust", "content": "pub fn main() -> Result<(), String> {\n    let elc = EventLoopContext::new();\n    run(elc);\n    Ok(())\n}", "item_id": 0, "repo": "elimirks/miscprojects", "file": "glsl_mandelbrot/src/main.rs", "last_update_at": "2019-04-16T21:42:59+00:00", "question_id": "ce0119bedcd43a5a6bdb3fbb8df4c1ba4c3567b7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn main() -> Result<(), String> {\n    let elc = EventLoopContext::new();\n    run(elc);\n    Ok(())\n"]]}
{"hexsha": "1d789524c5f4c8e73ac67b243a7f7e4d0d845ffa", "ext": "rs", "lang": "Rust", "content": "pub fn parse_any_text(\n    token_iter: &mut std::iter::Peekable<std::slice::Iter<'_, TokenInfo>>,\n) -> bool {\n    let token = token_iter.peek();\n    if token.is_none() {\n        return false;\n    }\n\n    match token.unwrap().token_type {\n        TokenType::Text(_) => {\n            token_iter.next();\n            true\n        }\n\n        _ => false,\n    }\n}", "item_id": 28, "repo": "petrSchreiber/thinclippy", "file": "src/tokenizer/mod.rs", "last_update_at": "2019-08-10T10:49:53+00:00", "question_id": "1d789524c5f4c8e73ac67b243a7f7e4d0d845ffa_28", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse_any_text(\n    token_iter: &mut std::iter::Peekable<std::slice::Iter<'_, TokenInfo>>,\n) -> bool {\n    let token = token_iter.peek();\n    if token.is_none() {\n        return false;\n    }\n    match token.unwrap().token_type {\n        TokenType::Text(_) => {\n            token_iter.next();\n            true\n        }\n        _ => false,\n    }\n"]]}
{"hexsha": "e0761de80413ea19c8171a9211ada7b4e48e35e5", "ext": "rs", "lang": "Rust", "content": "fn delta_list(conn: State<DbReadWrite>, mut auth: auth::Auth, auth_rules: State<auth::CustomAuth>) ->  Result<Json, status::Custom<Json>> {\n    let conn = conn.get()?;\n\n    auth_rules.allows_delta_list(&mut auth, &conn)?;\n\n    match delta::list_by_offset(&conn, None, None) {\n        Ok(deltas) => Ok(Json(deltas)),\n        Err(err) => Err(status::Custom(HTTPStatus::InternalServerError, Json(json!(err.to_string()))))\n    }\n}", "item_id": 26, "repo": "crazyrex/Hecate", "file": "src/lib.rs", "last_update_at": "2019-04-14T20:17:29+00:00", "question_id": "e0761de80413ea19c8171a9211ada7b4e48e35e5_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn delta_list(conn: State<DbReadWrite>, mut auth: auth::Auth, auth_rules: State<auth::CustomAuth>) ->  Result<Json, status::Custom<Json>> {\n    let conn = conn.get()?;\n    auth_rules.allows_delta_list(&mut auth, &conn)?;\n    match delta::list_by_offset(&conn, None, None) {\n        Ok(deltas) => Ok(Json(deltas)),\n        Err(err) => Err(status::Custom(HTTPStatus::InternalServerError, Json(json!(err.to_string()))))\n    }\n"]]}
{"hexsha": "db5258f2c3fd0077c3c83991672dc06fb4c06544", "ext": "rs", "lang": "Rust", "content": "fn parse_toplevel<T>(ctx: &mut Context, tokens: &mut Peekable<T>) -> Result<Option<Ast>>\nwhere\n    T: Iterator<Item = Token>,\n{\n    debug!(\"parse_toplevel --\");\n\n    let (ty, mut loc) = consume_type_name(tokens)?;\n    let mut ty = ty.into();\n    while let Some(TokenKind::Asterisk) = tokens.peek().map(|token| &token.value) {\n        loc = loc.merge(&consume(tokens, TokenKind::Asterisk)?);\n        ty = Type::ptr(ty);\n    }\n    let (name, ident_loc) = consume_ident(tokens)?;\n    loc = loc.merge(&ident_loc);\n\n    let ret = if let Some(TokenKind::LParen) = tokens.peek().map(|token| &token.value) {\n        // function\n\n        ctx.env.create_scope();\n        let mut args = Vec::new();\n\n        consume(tokens, TokenKind::LParen)?;\n        loop {\n            if let Some(TokenKind::RParen) = tokens.peek().map(|token| &token.value) {\n                break;\n            }\n            if args.len() > 0 {\n                consume(tokens, TokenKind::Comma)?;\n            }\n            let (type_name, _) = consume_type_name(tokens)?;\n            // TODO: support default arguments\n            let (_assign, arg, ty, d_loc) = parse_declarator(ctx, tokens, type_name.into())?;\n            let ty = match ty {\n                Type::Array(ty, _len) => Type::Ptr(ty),\n                _ => ty,\n            };\n            let var = Var {\n                name: arg.clone(),\n                ty,\n                is_local: true,\n            };\n            args.push(var.clone());\n            if ctx.add_lvar(var).is_some() {\n                return Err(ParseError::Redefinition(Token::ident(&arg, d_loc)));\n            }\n        }\n        loc = loc.merge(&consume(tokens, TokenKind::RParen)?);\n\n        match ctx.add_func(&name, ty.clone()) {\n            Some(ret_ty) => {\n                if ty != ret_ty {\n                    return Err(ParseError::ConflictingTypes(Token::ident(\n                        &name,\n                        loc.clone(),\n                    )));\n                }\n                // TODO: check duplicate declaration\n            }\n            None => {}\n        };\n\n        let ret = match tokens.peek().map(|token| &token.value) {\n            Some(TokenKind::Semicolon) => {\n                tokens.next().unwrap();\n                Ok(None)\n            }\n            _ => {\n                let block = parse_block(ctx, tokens)?;\n                loc = loc.merge(&block.loc);\n                let lvars = ctx.lvars.take().unwrap_or_else(|| HashMap::new());\n                Ok(Some(Ast::func(name, args, lvars, ty, block, loc)))\n            }\n        };\n        ctx.env.pop_scope();\n        ret\n    } else {\n        // global var\n\n        let (ty, _loc) = read_array(tokens, ty)?;\n        consume(tokens, TokenKind::Semicolon)?;\n\n        let var = Var {\n            name: name,\n            ty,\n            is_local: false,\n        };\n        ctx.add_gvar(var);\n\n        Ok(None)\n    };\n\n    debug!(\"parse_toplevel: {:?}\", ret);\n    ret\n}", "item_id": 3, "repo": "gky360/mycc", "file": "src/parser/mod.rs", "last_update_at": "2019-06-20T14:02:11+00:00", "question_id": "db5258f2c3fd0077c3c83991672dc06fb4c06544_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_toplevel<T>(ctx: &mut Context, tokens: &mut Peekable<T>) -> Result<Option<Ast>>\nwhere\n    T: Iterator<Item = Token>,\n{\n    debug!(\"parse_toplevel --\");\n    let (ty, mut loc) = consume_type_name(tokens)?;\n    let mut ty = ty.into();\n    while let Some(TokenKind::Asterisk) = tokens.peek().map(|token| &token.value) {\n        loc = loc.merge(&consume(tokens, TokenKind::Asterisk)?);\n        ty = Type::ptr(ty);\n    }\n    let (name, ident_loc) = consume_ident(tokens)?;\n    loc = loc.merge(&ident_loc);\n    let ret = if let Some(TokenKind::LParen) = tokens.peek().map(|token| &token.value) {\n        // function\n        ctx.env.create_scope();\n        let mut args = Vec::new();\n        consume(tokens, TokenKind::LParen)?;\n        loop {\n            if let Some(TokenKind::RParen) = tokens.peek().map(|token| &token.value) {\n                break;\n            }\n            if args.len() > 0 {\n                consume(tokens, TokenKind::Comma)?;\n            }\n            let (type_name, _) = consume_type_name(tokens)?;\n            // TODO: support default arguments\n            let (_assign, arg, ty, d_loc) = parse_declarator(ctx, tokens, type_name.into())?;\n            let ty = match ty {\n                Type::Array(ty, _len) => Type::Ptr(ty),\n                _ => ty,\n            };\n            let var = Var {\n                name: arg.clone(),\n                ty,\n                is_local: true,\n            };\n            args.push(var.clone());\n            if ctx.add_lvar(var).is_some() {\n                return Err(ParseError::Redefinition(Token::ident(&arg, d_loc)));\n            }\n        }\n        loc = loc.merge(&consume(tokens, TokenKind::RParen)?);\n        match ctx.add_func(&name, ty.clone()) {\n            Some(ret_ty) => {\n                if ty != ret_ty {\n                    return Err(ParseError::ConflictingTypes(Token::ident(\n                        &name,\n                        loc.clone(),\n                    )));\n                }\n                // TODO: check duplicate declaration\n            }\n            None => {}\n        };\n        let ret = match tokens.peek().map(|token| &token.value) {\n            Some(TokenKind::Semicolon) => {\n                tokens.next().unwrap();\n                Ok(None)\n            }\n            _ => {\n                let block = parse_block(ctx, tokens)?;\n                loc = loc.merge(&block.loc);\n                let lvars = ctx.lvars.take().unwrap_or_else(|| HashMap::new());\n                Ok(Some(Ast::func(name, args, lvars, ty, block, loc)))\n            }\n        };\n        ctx.env.pop_scope();\n        ret\n    } else {\n        // global var\n        let (ty, _loc) = read_array(tokens, ty)?;\n        consume(tokens, TokenKind::Semicolon)?;\n        let var = Var {\n            name: name,\n            ty,\n            is_local: false,\n        };\n        ctx.add_gvar(var);\n        Ok(None)\n    };\n    debug!(\"parse_toplevel: {:?}\", ret);\n    ret\n"]]}
{"hexsha": "1cbfc6d1db5e9a40c6e82b16bc6ebcb958ba15f9", "ext": "rs", "lang": "Rust", "content": "fn hello_extension_protocol_version() {\n            let bytes = rustls_bytes(r_ServerHelloPayload {\n                legacy_version: r_ProtocolVersion::TLSv1_2,\n                random: r_Random::from_slice(&[0; 32]),\n                session_id: r_SessionId::new(&[]),\n                cipher_suite: r_CipherSuite::TLS13_AES_128_GCM_SHA256,\n                compression_method: r_Compression::Null,\n                extensions: vec![r_ServerExtension::SupportedVersions(\n                    r_ProtocolVersion::TLSv1_3,\n                )],\n            });\n            let mut dec = Decoder::new(&bytes);\n            let payload = ServerHelloPayload::decode(&mut dec).unwrap();\n\n            assert_eq!(\n                payload.extensions,\n                Extensions::from(arr![ServerExtension::from(ProtocolVersion::TLSv1_3)]),\n            );\n        }", "item_id": 3, "repo": "joshleeb/tls-embed", "file": "message/src/handshake/server.rs", "last_update_at": "2019-05-01T11:52:11+00:00", "question_id": "1cbfc6d1db5e9a40c6e82b16bc6ebcb958ba15f9_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn hello_extension_protocol_version() {\n            let bytes = rustls_bytes(r_ServerHelloPayload {\n                legacy_version: r_ProtocolVersion::TLSv1_2,\n                random: r_Random::from_slice(&[0; 32]),\n                session_id: r_SessionId::new(&[]),\n                cipher_suite: r_CipherSuite::TLS13_AES_128_GCM_SHA256,\n                compression_method: r_Compression::Null,\n                extensions: vec![r_ServerExtension::SupportedVersions(\n                    r_ProtocolVersion::TLSv1_3,\n                )],\n            });\n            let mut dec = Decoder::new(&bytes);\n            let payload = ServerHelloPayload::decode(&mut dec).unwrap();\n            assert_eq!(\n                payload.extensions,\n                Extensions::from(arr![ServerExtension::from(ProtocolVersion::TLSv1_3)]),\n            );\n"]]}
{"hexsha": "5d81362a1ce240ef1552832e89445ee1765cb6b4", "ext": "rs", "lang": "Rust", "content": "pub fn register() -> Resp!() {\n    #[derive(Debug, Deserialize)]\n    struct Form {\n        email: String,\n        username: String,\n    }\n\n    warp::body::content_length_limit(2 * 1024)\n        .and(warp::ext::get::<DB>())\n        .and(warp::ext::get::<Mailer>())\n        .and(warp::body::form())\n        .and_then(|db, mailer, form: Form| {\n            logic::auth::register(db, mailer, form.username, form.email).err_to_rejection()\n        })\n        .untuple_one()\n        .and(simple_page(\"login-ok.html\"))\n        .recover_with_template(\"register.html\", |err: &Compat<Error>| {\n            let err = err.to_string();\n            match coerce!(&err => &str) {\n                r#\"new row for relation \"users\" violates check constraint \"name_fmt\"\"# => Some((\n                    StatusCode::BAD_REQUEST,\n                    vec![\"bad_username\"],\n                    vec![\"Your username must contain only ASCII letters and digits\"],\n                )),\n                r#\"new row for relation \"users\" violates check constraint \"name_len\"\"# => Some((\n                    StatusCode::BAD_REQUEST,\n                    vec![\"bad_username\"],\n                    vec![\"Your username must be at least 3 characters\"],\n                )),\n                r#\"duplicate key value violates unique constraint \"users_name_key\"\"# => Some((\n                    StatusCode::BAD_REQUEST,\n                    vec![\"bad_username\"],\n                    vec![\"This username is already taken\"],\n                )),\n                r#\"new row for relation \"users\" violates check constraint \"email_fmt\"\"# => Some((\n                    StatusCode::BAD_REQUEST,\n                    vec![\"bad_email\"],\n                    vec![\"That doesn't look like an email address...\"],\n                )),\n                r#\"new row for relation \"users\" violates check constraint \"email_len\"\"# => Some((\n                    StatusCode::BAD_REQUEST,\n                    vec![\"bad_email\"],\n                    vec![\"That doesn't look like an email address...\"],\n                )),\n                r#\"duplicate key value violates unique constraint \"users_email_key\"\"# => Some((\n                    StatusCode::BAD_REQUEST,\n                    vec![\"bad_email\"],\n                    vec![\"This email is already registered\"],\n                )),\n                _ => None,\n            }\n        })\n}", "item_id": 1, "repo": "remexre/nihctfplat", "file": "src/router/auth.rs", "last_update_at": "2019-02-14T20:41:37+00:00", "question_id": "5d81362a1ce240ef1552832e89445ee1765cb6b4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn register() -> Resp!() {\n    #[derive(Debug, Deserialize)]\n    struct Form {\n        email: String,\n        username: String,\n    }\n    warp::body::content_length_limit(2 * 1024)\n        .and(warp::ext::get::<DB>())\n        .and(warp::ext::get::<Mailer>())\n        .and(warp::body::form())\n        .and_then(|db, mailer, form: Form| {\n            logic::auth::register(db, mailer, form.username, form.email).err_to_rejection()\n        })\n        .untuple_one()\n        .and(simple_page(\"login-ok.html\"))\n        .recover_with_template(\"register.html\", |err: &Compat<Error>| {\n            let err = err.to_string();\n            match coerce!(&err => &str) {\n                r#\"new row for relation \"users\" violates check constraint \"name_fmt\"\"# => Some((\n                    StatusCode::BAD_REQUEST,\n                    vec![\"bad_username\"],\n                    vec![\"Your username must contain only ASCII letters and digits\"],\n                )),\n                r#\"new row for relation \"users\" violates check constraint \"name_len\"\"# => Some((\n                    StatusCode::BAD_REQUEST,\n                    vec![\"bad_username\"],\n                    vec![\"Your username must be at least 3 characters\"],\n                )),\n                r#\"duplicate key value violates unique constraint \"users_name_key\"\"# => Some((\n                    StatusCode::BAD_REQUEST,\n                    vec![\"bad_username\"],\n                    vec![\"This username is already taken\"],\n                )),\n                r#\"new row for relation \"users\" violates check constraint \"email_fmt\"\"# => Some((\n                    StatusCode::BAD_REQUEST,\n                    vec![\"bad_email\"],\n                    vec![\"That doesn't look like an email address...\"],\n                )),\n                r#\"new row for relation \"users\" violates check constraint \"email_len\"\"# => Some((\n                    StatusCode::BAD_REQUEST,\n                    vec![\"bad_email\"],\n                    vec![\"That doesn't look like an email address...\"],\n                )),\n                r#\"duplicate key value violates unique constraint \"users_email_key\"\"# => Some((\n                    StatusCode::BAD_REQUEST,\n                    vec![\"bad_email\"],\n                    vec![\"This email is already registered\"],\n                )),\n                _ => None,\n            }\n        })\n"]]}
{"hexsha": "af2e026e82ee3123ac95af923430a05f9022694c", "ext": "rs", "lang": "Rust", "content": "fn scan_cf<F>(\n        &self,\n        cf: &str,\n        start_key: &[u8],\n        end_key: &[u8],\n        fill_cache: bool,\n        f: F,\n    ) -> Result<()>\n    where\n        F: FnMut(&[u8], &[u8]) -> Result<bool>,\n    {\n        let start = KeyBuilder::from_slice(start_key, DATA_KEY_PREFIX_LEN, 0);\n        let end = KeyBuilder::from_slice(end_key, DATA_KEY_PREFIX_LEN, 0);\n        let iter_opt = IterOption::new(Some(start), Some(end), fill_cache);\n        scan_impl(self.new_iterator_cf(cf, iter_opt)?, start_key, f)\n    }", "item_id": 1, "repo": "Renkai/tikv", "file": "components/engine/src/iterable.rs", "last_update_at": "2019-09-26T02:25:41+00:00", "question_id": "af2e026e82ee3123ac95af923430a05f9022694c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn scan_cf<F>(\n        &self,\n        cf: &str,\n        start_key: &[u8],\n        end_key: &[u8],\n        fill_cache: bool,\n        f: F,\n    ) -> Result<()>\n    where\n        F: FnMut(&[u8], &[u8]) -> Result<bool>,\n    {\n        let start = KeyBuilder::from_slice(start_key, DATA_KEY_PREFIX_LEN, 0);\n        let end = KeyBuilder::from_slice(end_key, DATA_KEY_PREFIX_LEN, 0);\n        let iter_opt = IterOption::new(Some(start), Some(end), fill_cache);\n        scan_impl(self.new_iterator_cf(cf, iter_opt)?, start_key, f)\n"]]}
{"hexsha": "e1b0338243deafb7b412b723e51281aaed1afe82", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn handle_compositor_destroy(mut listener: *mut wl_listener,\n                                               mut data: *mut libc::c_void) {\n    let mut xwm: *mut wlr_xwm =\n        (listener as *mut libc::c_char).offset(-904) as *mut wlr_xwm;\n    wl_list_remove(&mut (*xwm).compositor_new_surface.link);\n    wl_list_remove(&mut (*xwm).compositor_destroy.link);\n    wl_list_init(&mut (*xwm).compositor_new_surface.link);\n    wl_list_init(&mut (*xwm).compositor_destroy.link);\n}", "item_id": 49, "repo": "RoastVeg/wlrusts", "file": "src/xwayland/xwm.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "e1b0338243deafb7b412b723e51281aaed1afe82_49", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe extern \"C\" fn handle_compositor_destroy(mut listener: *mut wl_listener,\n                                               mut data: *mut libc::c_void) {\n    let mut xwm: *mut wlr_xwm =\n        (listener as *mut libc::c_char).offset(-904) as *mut wlr_xwm;\n    wl_list_remove(&mut (*xwm).compositor_new_surface.link);\n    wl_list_remove(&mut (*xwm).compositor_destroy.link);\n    wl_list_init(&mut (*xwm).compositor_new_surface.link);\n    wl_list_init(&mut (*xwm).compositor_destroy.link);\n"]]}
{"hexsha": "247e428dce046f1d72875b8da595f240a61b333d", "ext": "rs", "lang": "Rust", "content": "pub fn highlight<S: AsRef<str>>(ty: &str, text: S) {\n    // Load these once at the start of your program\n    let ps = SyntaxSet::load_defaults_nonewlines();\n    let ts = ThemeSet::load_defaults();\n\n    let syntax = ps.find_syntax_by_extension(ty)\n        .expect(\"Unable to find highlighting grammar\");\n    let mut theme = ts.themes[\"base16-eighties.dark\"].clone();\n    theme.settings.background.as_mut().map(|color| {\n        color.r = 0x2c;\n        color.g = 0x2c;\n        color.b = 0x2c;\n        color.a = 0xff;\n    });\n\n    let mut h = HighlightLines::new(syntax, &theme);\n    for line in text.as_ref().lines() {\n        let ranges: Vec<(Style, &str)> = h.highlight(line);\n        let escaped = as_24_bit_terminal_escaped(&ranges[..], true);\n        println!(\"{}\", escaped);\n    }\n\n    println!(\"\\x1b[0m\");\n}", "item_id": 0, "repo": "FCG-LLC/hyena-demo", "file": "src/syntax_highlight.rs", "last_update_at": "2019-12-16T09:51:19+00:00", "question_id": "247e428dce046f1d72875b8da595f240a61b333d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn highlight<S: AsRef<str>>(ty: &str, text: S) {\n    // Load these once at the start of your program\n    let ps = SyntaxSet::load_defaults_nonewlines();\n    let ts = ThemeSet::load_defaults();\n    let syntax = ps.find_syntax_by_extension(ty)\n        .expect(\"Unable to find highlighting grammar\");\n    let mut theme = ts.themes[\"base16-eighties.dark\"].clone();\n    theme.settings.background.as_mut().map(|color| {\n        color.r = 0x2c;\n        color.g = 0x2c;\n        color.b = 0x2c;\n        color.a = 0xff;\n    });\n    let mut h = HighlightLines::new(syntax, &theme);\n    for line in text.as_ref().lines() {\n        let ranges: Vec<(Style, &str)> = h.highlight(line);\n        let escaped = as_24_bit_terminal_escaped(&ranges[..], true);\n        println!(\"{}\", escaped);\n    }\n    println!(\"\\x1b[0m\");\n"]]}
{"hexsha": "a09c5db65b675b5df4a637a255b612f6fa39d966", "ext": "rs", "lang": "Rust", "content": "fn test_sign_bytes() {\n        let good: &[u8] = b\"test message\";\n        let good_bytes = good.to_vec();\n        let private_key = PrivateKey::generate();\n        let sign = private_key.sign_bytes(&good_bytes);\n\n        let public_key = private_key.generate_public_key();\n        assert_eq!(true, public_key.verify_bytes(&good_bytes, &sign))\n    }", "item_id": 4, "repo": "placefortea/teatree", "file": "src/crypto/tests/keypair_test.rs", "last_update_at": "2019-06-17T09:55:37+00:00", "question_id": "a09c5db65b675b5df4a637a255b612f6fa39d966_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_sign_bytes() {\n        let good: &[u8] = b\"test message\";\n        let good_bytes = good.to_vec();\n        let private_key = PrivateKey::generate();\n        let sign = private_key.sign_bytes(&good_bytes);\n        let public_key = private_key.generate_public_key();\n        assert_eq!(true, public_key.verify_bytes(&good_bytes, &sign))\n"]]}
{"hexsha": "b2e35c1ba2adbadd63fbaffbff67b375dac31e14", "ext": "rs", "lang": "Rust", "content": "fn b_letter<G: Graphics>(\n    polygon: &graphics::Polygon, c: &Context, gl: &mut G\n) {\n    let mut draw = |poly| polygon.draw(poly, &c.draw_state, c.transform, gl);\n    draw(top_capped_right);\n    draw(upper_left_face_right);\n    draw(upper_right_face_left_capped_right);\n    draw(middle);\n    draw(lower_left_face_right);\n    draw(lower_right_face_left_capped_right);\n    draw(bottom_capped_right);\n}", "item_id": 4, "repo": "bvssvni/rust-snake", "file": "src/text.rs", "last_update_at": "2019-04-21T12:47:43+00:00", "question_id": "b2e35c1ba2adbadd63fbaffbff67b375dac31e14_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn b_letter<G: Graphics>(\n    polygon: &graphics::Polygon, c: &Context, gl: &mut G\n) {\n    let mut draw = |poly| polygon.draw(poly, &c.draw_state, c.transform, gl);\n    draw(top_capped_right);\n    draw(upper_left_face_right);\n    draw(upper_right_face_left_capped_right);\n    draw(middle);\n    draw(lower_left_face_right);\n    draw(lower_right_face_left_capped_right);\n    draw(bottom_capped_right);\n"]]}
{"hexsha": "8691f2177b5582024fe89f22192a6e4837a3e713", "ext": "rs", "lang": "Rust", "content": "async fn test_azblob_storage() {\n        use futures_util::stream;\n        let mut input = InputConfig::default();\n        input.set_account_name(\"devstoreaccount1\".to_owned());\n        input.set_bucket(\"test\".to_owned());\n        input.set_shared_key(\"Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==\".to_owned());\n        input.set_endpoint(\"http://127.0.0.1:10000/devstoreaccount1\".to_owned());\n        input.set_prefix(\"backup 01/prefix/\".to_owned());\n\n        let storage = AzureStorage::from_input(input).unwrap();\n        assert_eq!(storage.maybe_prefix_key(\"t\"), \"backup 01/prefix/t\");\n        let mut magic_contents = String::new();\n        for _ in 0..4096 {\n            // 4 KiB\n            magic_contents\n                .push_str(\"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890\\n\");\n        }\n        let size = magic_contents.len() as u64;\n        let stream = stream::once(async move { Ok(magic_contents) })\n            .boxed()\n            .into_async_read();\n        storage\n            .put(\"t\", PutResource(Box::new(stream)), size)\n            .await\n            .unwrap();\n\n        let mut reader = storage.get(\"t\");\n        let mut buf = Vec::new();\n        let get_size = reader.read_to_end(&mut buf).await.unwrap() as u64;\n        assert_eq!(get_size, size);\n    }", "item_id": 2, "repo": "lightmelodies/tikv", "file": "components/cloud/azure/src/azblob.rs", "last_update_at": "2019-04-14T21:00:48+00:00", "question_id": "8691f2177b5582024fe89f22192a6e4837a3e713_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn test_azblob_storage() {\n        use futures_util::stream;\n        let mut input = InputConfig::default();\n        input.set_account_name(\"devstoreaccount1\".to_owned());\n        input.set_bucket(\"test\".to_owned());\n        input.set_shared_key(\"Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==\".to_owned());\n        input.set_endpoint(\"http://127.0.0.1:10000/devstoreaccount1\".to_owned());\n        input.set_prefix(\"backup 01/prefix/\".to_owned());\n        let storage = AzureStorage::from_input(input).unwrap();\n        assert_eq!(storage.maybe_prefix_key(\"t\"), \"backup 01/prefix/t\");\n        let mut magic_contents = String::new();\n        for _ in 0..4096 {\n            // 4 KiB\n            magic_contents\n                .push_str(\"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890\\n\");\n        }\n        let size = magic_contents.len() as u64;\n        let stream = stream::once(async move { Ok(magic_contents) })\n            .boxed()\n            .into_async_read();\n        storage\n            .put(\"t\", PutResource(Box::new(stream)), size)\n            .await\n            .unwrap();\n        let mut reader = storage.get(\"t\");\n        let mut buf = Vec::new();\n        let get_size = reader.read_to_end(&mut buf).await.unwrap() as u64;\n        assert_eq!(get_size, size);\n"]]}
{"hexsha": "7b2292310199ea4863139fbaac2fb2b7234078fb", "ext": "rs", "lang": "Rust", "content": "fn activate(ctx: Context) -> Result<Box<Activator>> {\n    println!(\"I'm started (provider)\");\n    println!(\n        \"My Component def: {:?}\",\n        <SimpleGreeter as Component>::get_definition()\n    );\n\n    let srv = Box::new(SimpleGreeter::new());\n    let srv_reg = ctx.register_service_typed::<Greeter>(srv)?;\n    Ok(Box::new(SimpleActivator::new(srv_reg)))\n}", "item_id": 0, "repo": "ckaran/socrates-rs", "file": "examples/example-provider/src/lib.rs", "last_update_at": "2019-08-13T19:17:37+00:00", "question_id": "7b2292310199ea4863139fbaac2fb2b7234078fb_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn activate(ctx: Context) -> Result<Box<Activator>> {\n    println!(\"I'm started (provider)\");\n    println!(\n        \"My Component def: {:?}\",\n        <SimpleGreeter as Component>::get_definition()\n    );\n    let srv = Box::new(SimpleGreeter::new());\n    let srv_reg = ctx.register_service_typed::<Greeter>(srv)?;\n    Ok(Box::new(SimpleActivator::new(srv_reg)))\n"]]}
{"hexsha": "b42923d62f9cdb5f0cdd8dd2b1816d7bdbdb7969", "ext": "rs", "lang": "Rust", "content": "fn create_tx_since_absolute_epoch(node: &Node, number: u64, index: u64) -> TransactionView {\n    let epoch_length = GENESIS_EPOCH_LENGTH;\n    let epoch = EpochNumberWithFraction::new(number, index, epoch_length);\n    let since = since_from_absolute_epoch_number(epoch);\n    let cellbase = node.get_tip_block().transactions()[0].clone();\n    node.new_transaction_with_since(cellbase.hash(), since)\n}", "item_id": 0, "repo": "doitian/ckb", "file": "test/src/specs/hardfork/v2021/since.rs", "last_update_at": "2019-07-23T19:52:04+00:00", "question_id": "b42923d62f9cdb5f0cdd8dd2b1816d7bdbdb7969_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn create_tx_since_absolute_epoch(node: &Node, number: u64, index: u64) -> TransactionView {\n    let epoch_length = GENESIS_EPOCH_LENGTH;\n    let epoch = EpochNumberWithFraction::new(number, index, epoch_length);\n    let since = since_from_absolute_epoch_number(epoch);\n    let cellbase = node.get_tip_block().transactions()[0].clone();\n    node.new_transaction_with_since(cellbase.hash(), since)\n"]]}
{"hexsha": "4175d22e2afd1cb11deda7649e64e8a015760b19", "ext": "rs", "lang": "Rust", "content": "fn remove_overlay_keep_discard_overwritten_env() {\n    let inp = &[\n        r#\"overlay add samples/spam.nu\"#,\n        r#\"let-env BAZ = \"bagr\"\"#,\n        r#\"overlay remove --keep-custom spam\"#,\n        r#\"$env.BAZ\"#,\n    ];\n\n    let actual = nu!(cwd: \"tests/overlays\", pipeline(&inp.join(\"; \")));\n    let actual_repl = nu_repl(\"tests/overlays\", inp);\n\n    assert!(actual.err.contains(\"did you mean\"));\n    assert!(actual_repl.err.contains(\"DidYouMean\"));\n}", "item_id": 25, "repo": "hustcer/nushell", "file": "tests/overlays/mod.rs", "last_update_at": "2019-06-13T10:16:43+00:00", "question_id": "4175d22e2afd1cb11deda7649e64e8a015760b19_25", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn remove_overlay_keep_discard_overwritten_env() {\n    let inp = &[\n        r#\"overlay add samples/spam.nu\"#,\n        r#\"let-env BAZ = \"bagr\"\"#,\n        r#\"overlay remove --keep-custom spam\"#,\n        r#\"$env.BAZ\"#,\n    ];\n    let actual = nu!(cwd: \"tests/overlays\", pipeline(&inp.join(\"; \")));\n    let actual_repl = nu_repl(\"tests/overlays\", inp);\n    assert!(actual.err.contains(\"did you mean\"));\n    assert!(actual_repl.err.contains(\"DidYouMean\"));\n"]]}
{"hexsha": "7d44227546f4f02f7d051a52e64b5949b042485a", "ext": "rs", "lang": "Rust", "content": "fn lookup_bool() {\n        let rxvt: TermInfoBuf = TermInfo::parse(RXVT_INFO).unwrap().into();\n        let xterm: TermInfoBuf = TermInfo::parse(XTERM_INFO).unwrap().into();\n        let l16c: TermInfoBuf = TermInfo::parse(LINUX_16COLOR_INFO).unwrap().into();\n\n        assert_eq!(rxvt.boolean(BooleanField::LinefeedIsNewline), false);\n        assert_eq!(rxvt.boolean(BooleanField::AutoRightMargin), true);\n\n        assert_eq!(xterm.boolean(BooleanField::AutoLeftMargin), false);\n        assert_eq!(xterm.boolean(BooleanField::LinefeedIsNewline), false);\n\n        assert_eq!(l16c.boolean(BooleanField::HardCursor), false);\n        assert_eq!(l16c.boolean(BooleanField::AutoRightMargin), true);\n    }", "item_id": 2, "repo": "IanS5/tty-rs", "file": "src/terminfo/terminfobuf.rs", "last_update_at": "2019-07-01T13:55:10+00:00", "question_id": "7d44227546f4f02f7d051a52e64b5949b042485a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn lookup_bool() {\n        let rxvt: TermInfoBuf = TermInfo::parse(RXVT_INFO).unwrap().into();\n        let xterm: TermInfoBuf = TermInfo::parse(XTERM_INFO).unwrap().into();\n        let l16c: TermInfoBuf = TermInfo::parse(LINUX_16COLOR_INFO).unwrap().into();\n        assert_eq!(rxvt.boolean(BooleanField::LinefeedIsNewline), false);\n        assert_eq!(rxvt.boolean(BooleanField::AutoRightMargin), true);\n        assert_eq!(xterm.boolean(BooleanField::AutoLeftMargin), false);\n        assert_eq!(xterm.boolean(BooleanField::LinefeedIsNewline), false);\n        assert_eq!(l16c.boolean(BooleanField::HardCursor), false);\n        assert_eq!(l16c.boolean(BooleanField::AutoRightMargin), true);\n"]]}
{"hexsha": "46cad70abb82cb9bad097e96f56ef7fbce047205", "ext": "rs", "lang": "Rust", "content": "fn mul() {\n        assert_eq!(\n            ScalarWitness::from(5u64) * ScalarWitness::from(6u64),\n            ScalarWitness::from(30u64)\n        );\n\n        assert_eq!(\n            -ScalarWitness::from(2u64) * ScalarWitness::from(7u64),\n            -ScalarWitness::from(14u64)\n        );\n\n        assert_eq!(\n            ScalarWitness::from(100u64) * ScalarWitness::from(Scalar::from(0xffu64)),\n            ScalarWitness::from(Scalar::from(100u64) * Scalar::from(0xffu64))\n        );\n\n        assert_eq!(\n            ScalarWitness::from(Scalar::from(0xffu64)) * ScalarWitness::from(Scalar::from(0xfeu64)),\n            ScalarWitness::from(Scalar::from(0xffu64) * Scalar::from(0xfeu64))\n        );\n    }", "item_id": 4, "repo": "nondejus/slingshot", "file": "zkvm/src/scalar_witness.rs", "last_update_at": "2019-09-11T09:07:18+00:00", "question_id": "46cad70abb82cb9bad097e96f56ef7fbce047205_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn mul() {\n        assert_eq!(\n            ScalarWitness::from(5u64) * ScalarWitness::from(6u64),\n            ScalarWitness::from(30u64)\n        );\n        assert_eq!(\n            -ScalarWitness::from(2u64) * ScalarWitness::from(7u64),\n            -ScalarWitness::from(14u64)\n        );\n        assert_eq!(\n            ScalarWitness::from(100u64) * ScalarWitness::from(Scalar::from(0xffu64)),\n            ScalarWitness::from(Scalar::from(100u64) * Scalar::from(0xffu64))\n        );\n        assert_eq!(\n            ScalarWitness::from(Scalar::from(0xffu64)) * ScalarWitness::from(Scalar::from(0xfeu64)),\n            ScalarWitness::from(Scalar::from(0xffu64) * Scalar::from(0xfeu64))\n        );\n"]]}
{"hexsha": "add605204ef1c4b6e3127eb877c762171bfb3509", "ext": "rs", "lang": "Rust", "content": "fn return_from_block() {\n        let mut lang = Lang::new(Some(\n            \"\n        fn test() -> i32 {\n            {\n                return 100;\n            }\n        }\n        let value: i32 = test();\n        assert(value == 100);\n        \",\n        ));\n        let result = lang.run();\n        if let Err(ref error) = result {\n            println!(\"{}\", error);\n        }\n        assert_eq!(result.is_ok(), true)\n    }", "item_id": 12, "repo": "0X1A/lang", "file": "tests/test.rs", "last_update_at": "2019-04-19T16:55:10+00:00", "question_id": "add605204ef1c4b6e3127eb877c762171bfb3509_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn return_from_block() {\n        let mut lang = Lang::new(Some(\n            \"\n        fn test() -> i32 {\n            {\n                return 100;\n            }\n        }\n        let value: i32 = test();\n        assert(value == 100);\n        \",\n        ));\n        let result = lang.run();\n        if let Err(ref error) = result {\n            println!(\"{}\", error);\n        }\n        assert_eq!(result.is_ok(), true)\n"]]}
{"hexsha": "5dda8b3b908d7f02794840548a7243891299bd94", "ext": "rs", "lang": "Rust", "content": "fn fib_i64 (limit: i64) -> Vec<i64> {\n    let mut out: Vec<i64> = Vec::new();\n    let mut a = 0;\n    let mut b = 1;\n    while a <= limit {\n        out.push(a);\n        if b <= limit {\n            out.push(b);\n        }\n        a = a + b;\n        b = a + b;\n    }\n    out\n}", "item_id": 1, "repo": "elycruz/rs-fib", "file": "src/main.rs", "last_update_at": "2019-12-02T22:28:25+00:00", "question_id": "5dda8b3b908d7f02794840548a7243891299bd94_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn fib_i64 (limit: i64) -> Vec<i64> {\n    let mut out: Vec<i64> = Vec::new();\n    let mut a = 0;\n    let mut b = 1;\n    while a <= limit {\n        out.push(a);\n        if b <= limit {\n            out.push(b);\n        }\n        a = a + b;\n        b = a + b;\n    }\n    out\n"]]}
{"hexsha": "e049f4062c0057693c0c90e18fb5d6b5ec44bb92", "ext": "rs", "lang": "Rust", "content": "fn problem_2016_21_1() {\n    #![allow(clippy::unwrap_used)]\n    let input = read_to_string(\"src/year2016/day21_input.txt\").unwrap();\n    solve(2016, 21, 1, &input).unwrap();\n}", "item_id": 90, "repo": "fornwall/advent-of-code-2019-rs", "file": "crates/core/benches/iai.rs", "last_update_at": "2019-12-10T00:08:49+00:00", "question_id": "e049f4062c0057693c0c90e18fb5d6b5ec44bb92_90", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn problem_2016_21_1() {\n    #![allow(clippy::unwrap_used)]\n    let input = read_to_string(\"src/year2016/day21_input.txt\").unwrap();\n    solve(2016, 21, 1, &input).unwrap();\n"]]}
{"hexsha": "54f8eee53c19dc6c34a6e481e7b741d565b59d65", "ext": "rs", "lang": "Rust", "content": "fn test_get_frame_info_loaded() {\n        let context = Context::new();\n        let path = Path::new(\"./test/test0.mod\");\n\n        load_module(&context, &path);\n        start_player(&context, Rate::new(44100), Format::Auto);\n\n        match get_frame_info(&context) {\n            Ok(x) => {\n                assert_eq!(x.bpm, 125)\n            },\n            Err(x) => assert_eq!(x.kind, ErrorKind::SelfType(SelfErrorKind::Other))\n        }\n    }", "item_id": 3, "repo": "cruatta/libxmp-rust", "file": "src/play.rs", "last_update_at": "2019-04-16T19:56:17+00:00", "question_id": "54f8eee53c19dc6c34a6e481e7b741d565b59d65_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_get_frame_info_loaded() {\n        let context = Context::new();\n        let path = Path::new(\"./test/test0.mod\");\n        load_module(&context, &path);\n        start_player(&context, Rate::new(44100), Format::Auto);\n        match get_frame_info(&context) {\n            Ok(x) => {\n                assert_eq!(x.bpm, 125)\n            },\n            Err(x) => assert_eq!(x.kind, ErrorKind::SelfType(SelfErrorKind::Other))\n        }\n"]]}
{"hexsha": "ad84b11866a7b759ac492cdb7ce138623325404c", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn wlr_xdg_toplevel_v6_set_resizing(mut surface:\n                                                              *mut wlr_xdg_surface_v6,\n                                                          mut resizing: bool)\n -> uint32_t {\n    if (*surface).role as libc::c_uint ==\n           WLR_XDG_SURFACE_V6_ROLE_TOPLEVEL as libc::c_int as libc::c_uint {\n    } else {\n        __assert_fail(b\"surface->role == WLR_XDG_SURFACE_V6_ROLE_TOPLEVEL\\x00\"\n                          as *const u8 as *const libc::c_char,\n                      b\"../types/xdg_shell_v6/wlr_xdg_toplevel_v6.c\\x00\" as\n                          *const u8 as *const libc::c_char,\n                      532i32 as libc::c_uint,\n                      (*::std::mem::transmute::<&[u8; 78],\n                                                &[libc::c_char; 78]>(b\"uint32_t wlr_xdg_toplevel_v6_set_resizing(struct wlr_xdg_surface_v6 *, _Bool)\\x00\")).as_ptr());\n    };\n    (*(*surface).c2rust_unnamed.toplevel).server_pending.resizing = resizing;\n    return schedule_xdg_surface_v6_configure(surface);\n}", "item_id": 26, "repo": "RoastVeg/wlrusts", "file": "src/types/xdg_shell_v6/wlr_xdg_toplevel_v6.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "ad84b11866a7b759ac492cdb7ce138623325404c_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn wlr_xdg_toplevel_v6_set_resizing(mut surface:\n                                                              *mut wlr_xdg_surface_v6,\n                                                          mut resizing: bool)\n -> uint32_t {\n    if (*surface).role as libc::c_uint ==\n           WLR_XDG_SURFACE_V6_ROLE_TOPLEVEL as libc::c_int as libc::c_uint {\n    } else {\n        __assert_fail(b\"surface->role == WLR_XDG_SURFACE_V6_ROLE_TOPLEVEL\\x00\"\n                          as *const u8 as *const libc::c_char,\n                      b\"../types/xdg_shell_v6/wlr_xdg_toplevel_v6.c\\x00\" as\n                          *const u8 as *const libc::c_char,\n                      532i32 as libc::c_uint,\n                      (*::std::mem::transmute::<&[u8; 78],\n                                                &[libc::c_char; 78]>(b\"uint32_t wlr_xdg_toplevel_v6_set_resizing(struct wlr_xdg_surface_v6 *, _Bool)\\x00\")).as_ptr());\n    };\n    (*(*surface).c2rust_unnamed.toplevel).server_pending.resizing = resizing;\n    return schedule_xdg_surface_v6_configure(surface);\n"]]}
{"hexsha": "e66322ea0c5706d174a77c18be0da46364ad01c8", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern \"C\" fn xwm_handle_selection_event(mut xwm: *mut wlr_xwm,\n                                                    mut event:\n                                                        *mut xcb_generic_event_t)\n -> libc::c_int {\n    if (*xwm).seat.is_null() {\n        _wlr_log(WLR_DEBUG,\n                 b\"[%s:%d] not handling selection events: no seat assigned to xwayland\\x00\"\n                     as *const u8 as *const libc::c_char,\n                 b\"../xwayland/selection/selection.c\\x00\" as *const u8 as\n                     *const libc::c_char, 118i32);\n        return 0i32\n    }\n    match (*event).response_type as libc::c_int & 0x7fi32 {\n        31 => {\n            xwm_handle_selection_notify(xwm,\n                                        event as\n                                            *mut xcb_selection_notify_event_t);\n            return 1i32\n        }\n        28 => {\n            return xwm_handle_selection_property_notify(xwm,\n                                                        event as\n                                                            *mut xcb_property_notify_event_t)\n        }\n        30 => {\n            xwm_handle_selection_request(xwm,\n                                         event as\n                                             *mut xcb_selection_request_event_t);\n            return 1i32\n        }\n        _ => { }\n    }\n    match (*event).response_type as libc::c_int -\n              (*(*xwm).xfixes).first_event as libc::c_int {\n        0 => {\n            // an X11 window has copied something to the clipboard\n            return xwm_handle_xfixes_selection_notify(xwm,\n                                                      event as\n                                                          *mut xcb_xfixes_selection_notify_event_t)\n        }\n        _ => { }\n    }\n    return 0i32;\n}", "item_id": 2, "repo": "RoastVeg/wlrusts", "file": "src/xwayland/selection/selection.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "e66322ea0c5706d174a77c18be0da46364ad01c8_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern \"C\" fn xwm_handle_selection_event(mut xwm: *mut wlr_xwm,\n                                                    mut event:\n                                                        *mut xcb_generic_event_t)\n -> libc::c_int {\n    if (*xwm).seat.is_null() {\n        _wlr_log(WLR_DEBUG,\n                 b\"[%s:%d] not handling selection events: no seat assigned to xwayland\\x00\"\n                     as *const u8 as *const libc::c_char,\n                 b\"../xwayland/selection/selection.c\\x00\" as *const u8 as\n                     *const libc::c_char, 118i32);\n        return 0i32\n    }\n    match (*event).response_type as libc::c_int & 0x7fi32 {\n        31 => {\n            xwm_handle_selection_notify(xwm,\n                                        event as\n                                            *mut xcb_selection_notify_event_t);\n            return 1i32\n        }\n        28 => {\n            return xwm_handle_selection_property_notify(xwm,\n                                                        event as\n                                                            *mut xcb_property_notify_event_t)\n        }\n        30 => {\n            xwm_handle_selection_request(xwm,\n                                         event as\n                                             *mut xcb_selection_request_event_t);\n            return 1i32\n        }\n        _ => { }\n    }\n    match (*event).response_type as libc::c_int -\n              (*(*xwm).xfixes).first_event as libc::c_int {\n        0 => {\n            // an X11 window has copied something to the clipboard\n            return xwm_handle_xfixes_selection_notify(xwm,\n                                                      event as\n                                                          *mut xcb_xfixes_selection_notify_event_t)\n        }\n        _ => { }\n    }\n    return 0i32;\n"]]}
{"hexsha": "84bf3aac3bc463604d597c6390aa6a7eafcf7749", "ext": "rs", "lang": "Rust", "content": "fn new_should_assign_origin_and_direction() {\n        let origin = Xyz::new(3.0, 4.4, 1.0);\n        let direction = Xyz::new(5.0, -2.1, 2.0);\n\n        let ray = Ray::new(origin.clone(), direction.clone());\n\n        assert_eq!(ray.origin, origin);\n        assert_eq!(ray.direction, direction);\n        assert_eq!(\"Ray { origin: Xyz { x: 3.0, y: 4.4, z: 1.0 }, direction: Xyz { x: 5.0, y: -2.1, z: 2.0 } }\",\n            format!(\"{:?}\", ray));\n    }", "item_id": 0, "repo": "projektir/ray_tracer_simple_image", "file": "src/lin_alg/ray.rs", "last_update_at": "2019-03-11T18:38:17+00:00", "question_id": "84bf3aac3bc463604d597c6390aa6a7eafcf7749_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn new_should_assign_origin_and_direction() {\n        let origin = Xyz::new(3.0, 4.4, 1.0);\n        let direction = Xyz::new(5.0, -2.1, 2.0);\n        let ray = Ray::new(origin.clone(), direction.clone());\n        assert_eq!(ray.origin, origin);\n        assert_eq!(ray.direction, direction);\n        assert_eq!(\"Ray { origin: Xyz { x: 3.0, y: 4.4, z: 1.0 }, direction: Xyz { x: 5.0, y: -2.1, z: 2.0 } }\",\n            format!(\"{:?}\", ray));\n"]]}
{"hexsha": "3cc3abdbe648d794c9de45ec027650a38bacbd4e", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn compositor_bind(mut wl_client: *mut wl_client,\n                                     mut data: *mut libc::c_void,\n                                     mut version: uint32_t,\n                                     mut id: uint32_t) {\n    let mut compositor: *mut wlr_compositor = data as *mut wlr_compositor;\n    let mut resource: *mut wl_resource =\n        wl_resource_create(wl_client, &wl_compositor_interface,\n                           version as libc::c_int, id);\n    if resource.is_null() { wl_client_post_no_memory(wl_client); return }\n    wl_resource_set_implementation(resource,\n                                   &compositor_impl as\n                                       *const wl_compositor_interface as\n                                       *const libc::c_void,\n                                   compositor as *mut libc::c_void, None);\n}", "item_id": 6, "repo": "RoastVeg/wlrusts", "file": "src/types/wlr_compositor.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "3cc3abdbe648d794c9de45ec027650a38bacbd4e_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe extern \"C\" fn compositor_bind(mut wl_client: *mut wl_client,\n                                     mut data: *mut libc::c_void,\n                                     mut version: uint32_t,\n                                     mut id: uint32_t) {\n    let mut compositor: *mut wlr_compositor = data as *mut wlr_compositor;\n    let mut resource: *mut wl_resource =\n        wl_resource_create(wl_client, &wl_compositor_interface,\n                           version as libc::c_int, id);\n    if resource.is_null() { wl_client_post_no_memory(wl_client); return }\n    wl_resource_set_implementation(resource,\n                                   &compositor_impl as\n                                       *const wl_compositor_interface as\n                                       *const libc::c_void,\n                                   compositor as *mut libc::c_void, None);\n"]]}
{"hexsha": "e1b0338243deafb7b412b723e51281aaed1afe82", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn xwayland_surface_destroy(mut xsurface:\n                                                  *mut wlr_xwayland_surface) {\n    xsurface_unmap(xsurface);\n    wlr_signal_emit_safe(&mut (*xsurface).events.destroy,\n                         xsurface as *mut libc::c_void);\n    if xsurface == (*(*xsurface).xwm).focus_surface {\n        xwm_surface_activate((*xsurface).xwm, 0 as *mut wlr_xwayland_surface);\n    }\n    wl_list_remove(&mut (*xsurface).link);\n    wl_list_remove(&mut (*xsurface).parent_link);\n    let mut child: *mut wlr_xwayland_surface = 0 as *mut wlr_xwayland_surface;\n    let mut next: *mut wlr_xwayland_surface = 0 as *mut wlr_xwayland_surface;\n    child =\n        ((*xsurface).children.next as *mut libc::c_char).offset(-144) as\n            *mut wlr_xwayland_surface;\n    next =\n        ((*child).parent_link.next as *mut libc::c_char).offset(-144) as\n            *mut wlr_xwayland_surface;\n    while &mut (*child).parent_link as *mut wl_list !=\n              &mut (*xsurface).children as *mut wl_list {\n        wl_list_remove(&mut (*child).parent_link);\n        wl_list_init(&mut (*child).parent_link);\n        (*child).parent = 0 as *mut wlr_xwayland_surface;\n        child = next;\n        next =\n            ((*child).parent_link.next as *mut libc::c_char).offset(-144) as\n                *mut wlr_xwayland_surface\n    }\n    if (*xsurface).surface_id != 0 {\n        wl_list_remove(&mut (*xsurface).unpaired_link);\n    }\n    if !(*xsurface).surface.is_null() {\n        wl_list_remove(&mut (*xsurface).surface_destroy.link);\n        (*(*xsurface).surface).role_data = 0 as *mut libc::c_void\n    }\n    wl_event_source_remove((*xsurface).ping_timer);\n    free((*xsurface).title as *mut libc::c_void);\n    free((*xsurface).class as *mut libc::c_void);\n    free((*xsurface).instance as *mut libc::c_void);\n    free((*xsurface).role as *mut libc::c_void);\n    free((*xsurface).window_type as *mut libc::c_void);\n    free((*xsurface).protocols as *mut libc::c_void);\n    free((*xsurface).hints as *mut libc::c_void);\n    free((*xsurface).size_hints as *mut libc::c_void);\n    free(xsurface as *mut libc::c_void);\n}", "item_id": 9, "repo": "RoastVeg/wlrusts", "file": "src/xwayland/xwm.rs", "last_update_at": "2019-12-10T16:29:26+00:00", "question_id": "e1b0338243deafb7b412b723e51281aaed1afe82_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe extern \"C\" fn xwayland_surface_destroy(mut xsurface:\n                                                  *mut wlr_xwayland_surface) {\n    xsurface_unmap(xsurface);\n    wlr_signal_emit_safe(&mut (*xsurface).events.destroy,\n                         xsurface as *mut libc::c_void);\n    if xsurface == (*(*xsurface).xwm).focus_surface {\n        xwm_surface_activate((*xsurface).xwm, 0 as *mut wlr_xwayland_surface);\n    }\n    wl_list_remove(&mut (*xsurface).link);\n    wl_list_remove(&mut (*xsurface).parent_link);\n    let mut child: *mut wlr_xwayland_surface = 0 as *mut wlr_xwayland_surface;\n    let mut next: *mut wlr_xwayland_surface = 0 as *mut wlr_xwayland_surface;\n    child =\n        ((*xsurface).children.next as *mut libc::c_char).offset(-144) as\n            *mut wlr_xwayland_surface;\n    next =\n        ((*child).parent_link.next as *mut libc::c_char).offset(-144) as\n            *mut wlr_xwayland_surface;\n    while &mut (*child).parent_link as *mut wl_list !=\n              &mut (*xsurface).children as *mut wl_list {\n        wl_list_remove(&mut (*child).parent_link);\n        wl_list_init(&mut (*child).parent_link);\n        (*child).parent = 0 as *mut wlr_xwayland_surface;\n        child = next;\n        next =\n            ((*child).parent_link.next as *mut libc::c_char).offset(-144) as\n                *mut wlr_xwayland_surface\n    }\n    if (*xsurface).surface_id != 0 {\n        wl_list_remove(&mut (*xsurface).unpaired_link);\n    }\n    if !(*xsurface).surface.is_null() {\n        wl_list_remove(&mut (*xsurface).surface_destroy.link);\n        (*(*xsurface).surface).role_data = 0 as *mut libc::c_void\n    }\n    wl_event_source_remove((*xsurface).ping_timer);\n    free((*xsurface).title as *mut libc::c_void);\n    free((*xsurface).class as *mut libc::c_void);\n    free((*xsurface).instance as *mut libc::c_void);\n    free((*xsurface).role as *mut libc::c_void);\n    free((*xsurface).window_type as *mut libc::c_void);\n    free((*xsurface).protocols as *mut libc::c_void);\n    free((*xsurface).hints as *mut libc::c_void);\n    free((*xsurface).size_hints as *mut libc::c_void);\n    free(xsurface as *mut libc::c_void);\n"]]}
{"hexsha": "5c725bead6867b9d04e5c3081fa4be81fbf89284", "ext": "rs", "lang": "Rust", "content": "fn prev_grapheme_boundary(slice: &RopeSlice, char_idx: usize) -> usize {\n    // Bounds check\n    debug_assert!(char_idx <= slice.len_chars());\n\n    // We work with bytes for this, so convert.\n    let byte_idx = slice.char_to_byte(char_idx);\n\n    // Get the chunk with our byte index in it.\n    let (mut chunk, mut chunk_byte_idx, mut chunk_char_idx, _) = slice.chunk_at_byte(byte_idx);\n\n    // Set up the grapheme cursor.\n    let mut gc = GraphemeCursor::new(byte_idx, slice.len_bytes(), true);\n\n    // Find the previous grapheme cluster boundary.\n    loop {\n        match gc.prev_boundary(chunk, chunk_byte_idx) {\n            Ok(None) => return 0,\n            Ok(Some(n)) => {\n                let tmp = byte_to_char_idx(chunk, n - chunk_byte_idx);\n                return chunk_char_idx + tmp;\n            }\n            Err(GraphemeIncomplete::PrevChunk) => {\n                let (a, b, c, _) = slice.chunk_at_byte(chunk_byte_idx - 1);\n                chunk = a;\n                chunk_byte_idx = b;\n                chunk_char_idx = c;\n            }\n            Err(GraphemeIncomplete::PreContext(n)) => {\n                let ctx_chunk = slice.chunk_at_byte(n - 1).0;\n                gc.provide_context(ctx_chunk, n - ctx_chunk.len());\n            }\n            _ => unreachable!(),\n        }\n    }\n}", "item_id": 0, "repo": "EwoutH/ropey", "file": "examples/graphemes_step.rs", "last_update_at": "2019-06-17T04:29:45+00:00", "question_id": "5c725bead6867b9d04e5c3081fa4be81fbf89284_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn prev_grapheme_boundary(slice: &RopeSlice, char_idx: usize) -> usize {\n    // Bounds check\n    debug_assert!(char_idx <= slice.len_chars());\n    // We work with bytes for this, so convert.\n    let byte_idx = slice.char_to_byte(char_idx);\n    // Get the chunk with our byte index in it.\n    let (mut chunk, mut chunk_byte_idx, mut chunk_char_idx, _) = slice.chunk_at_byte(byte_idx);\n    // Set up the grapheme cursor.\n    let mut gc = GraphemeCursor::new(byte_idx, slice.len_bytes(), true);\n    // Find the previous grapheme cluster boundary.\n    loop {\n        match gc.prev_boundary(chunk, chunk_byte_idx) {\n            Ok(None) => return 0,\n            Ok(Some(n)) => {\n                let tmp = byte_to_char_idx(chunk, n - chunk_byte_idx);\n                return chunk_char_idx + tmp;\n            }\n            Err(GraphemeIncomplete::PrevChunk) => {\n                let (a, b, c, _) = slice.chunk_at_byte(chunk_byte_idx - 1);\n                chunk = a;\n                chunk_byte_idx = b;\n                chunk_char_idx = c;\n            }\n            Err(GraphemeIncomplete::PreContext(n)) => {\n                let ctx_chunk = slice.chunk_at_byte(n - 1).0;\n                gc.provide_context(ctx_chunk, n - ctx_chunk.len());\n            }\n            _ => unreachable!(),\n        }\n    }\n"]]}
{"hexsha": "e1deaebe3f255077e6cb2fda6b0daeb0a45c3ba8", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let matches = App::new(\"Raytracer\")\n        .about(\"Raytracer in Rust from Peter Shirley's Raytracing in One Weekend\")\n        .arg(\n            Arg::with_name(\"output\")\n                .short(\"o\")\n                .long(\"output\")\n                .value_name(\"FILE\")\n                .takes_value(true)\n                .help(\"Output file. If not specified, wrties to stdout.\"),\n        )\n        .arg(\n            Arg::with_name(\"samples\")\n                .short(\"s\")\n                .long(\"samples\")\n                .takes_value(true)\n                .help(\"Number of samples per pixel\")\n                .default_value(\"100\"),\n        )\n        .arg(\n            Arg::with_name(\"threads\")\n                .short(\"t\")\n                .long(\"threads\")\n                .takes_value(true)\n                .help(\"Number of threads to run\")\n                .default_value(\"1\"),\n        )\n        .arg(\n            Arg::with_name(\"x_res\")\n                .short(\"x\")\n                .long(\"x_res\")\n                .takes_value(true)\n                .help(\"Width of trace in pixels\")\n                .default_value(\"200\"),\n        )\n        .arg(\n            Arg::with_name(\"y_res\")\n                .short(\"y\")\n                .long(\"y_res\")\n                .takes_value(true)\n                .help(\"Height of trace in pixels\")\n                .default_value(\"100\"),\n        )\n        .get_matches();\n\n    let x_res: u32 = matches.value_of(\"x_res\").unwrap().parse().unwrap();\n    let y_res: u32 = matches.value_of(\"y_res\").unwrap().parse().unwrap();\n    let num_samples: u32 = matches.value_of(\"samples\").unwrap().parse().unwrap();\n    let num_threads: u32 = matches.value_of(\"threads\").unwrap().parse().unwrap();\n    let output = matches.value_of(\"output\");\n\n    let lookfrom = Vector3::new(13.0, 2.0, 3.0);\n    let lookat = Vector3::new(0.0, 0.0, 0.0);\n    let vup = Vector3::new(0.0, 1.0, 0.0);\n    let dist_to_focus = (lookfrom - lookat).length();\n    let aperture = 0.1;\n    let cam = Camera::new(\n        lookfrom,\n        lookat,\n        vup,\n        30.0,\n        x_res as f32 / y_res as f32,\n        aperture,\n        dist_to_focus,\n    );\n\n    let hitable_list = random_scene();\n    let bvh = BVHNode::new(hitable_list.hitables.clone());\n\n    let mut thread_handles = Vec::new();\n    let result = Arc::new(Mutex::new(Vec::new()));\n    let samples_per_thread = num_samples / num_threads;\n\n    for _ in 0..num_threads {\n        let mut thread_output = Vec::new();\n        let bvh_clone = bvh.clone();\n        let result = Arc::clone(&result);\n        // TODO Handle exceptions + num_samples not divisible by num_threads\n        thread_handles.push(thread::spawn(move || {\n            for j in (0..y_res).rev() {\n                for i in 0..x_res {\n                    let mut col = Vector3::new(0.0, 0.0, 0.0);\n                    for _s in 0..samples_per_thread {\n                        let u_rand = random::random_in_unit_interval();\n                        let v_rand = random::random_in_unit_interval();\n                        let u = (i as f32 + u_rand) / x_res as f32;\n                        let v = (j as f32 + v_rand) / y_res as f32;\n                        let ray = cam.get_ray(u, v);\n                        col = col + color(&ray, &bvh_clone, 0);\n                    }\n                    col = col / num_samples as f32;\n                    thread_output.push(col);\n                    // Do averaging in th thread\n                    // Then the final average at the end\n                }\n            }\n            let mut l_result = result.lock().unwrap();\n            if l_result.len() == 0 {\n                *l_result = thread_output;\n            } else {\n                *l_result = l_result\n                    .iter()\n                    .zip(thread_output.iter())\n                    .map(|(a, b)| a + b)\n                    .collect();\n            }\n        }));\n    }\n\n    for thread in thread_handles {\n        thread.join().unwrap();\n    }\n\n    let mut output_buffer: Vec<u8> = Vec::with_capacity(x_res as usize * y_res as usize * 3);\n\n    // Should buffer and only write to the file at the end\n    for col in result.lock().unwrap().iter() {\n        let out_colour = Vector3::new(\n            (255.99 * col.r().sqrt()).floor(),\n            (255.99 * col.g().sqrt()).floor(),\n            (255.99 * col.b().sqrt()).floor(),\n        );\n\n        output_buffer.push(out_colour.r() as u8);\n        output_buffer.push(out_colour.g() as u8);\n        output_buffer.push(out_colour.b() as u8);\n    }\n\n    image_out::write_image(output, &output_buffer, x_res, y_res);\n}", "item_id": 1, "repo": "superphunthyme/raytracer", "file": "src/main.rs", "last_update_at": "2019-05-11T20:28:41+00:00", "question_id": "e1deaebe3f255077e6cb2fda6b0daeb0a45c3ba8_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let matches = App::new(\"Raytracer\")\n        .about(\"Raytracer in Rust from Peter Shirley's Raytracing in One Weekend\")\n        .arg(\n            Arg::with_name(\"output\")\n                .short(\"o\")\n                .long(\"output\")\n                .value_name(\"FILE\")\n                .takes_value(true)\n                .help(\"Output file. If not specified, wrties to stdout.\"),\n        )\n        .arg(\n            Arg::with_name(\"samples\")\n                .short(\"s\")\n                .long(\"samples\")\n                .takes_value(true)\n                .help(\"Number of samples per pixel\")\n                .default_value(\"100\"),\n        )\n        .arg(\n            Arg::with_name(\"threads\")\n                .short(\"t\")\n                .long(\"threads\")\n                .takes_value(true)\n                .help(\"Number of threads to run\")\n                .default_value(\"1\"),\n        )\n        .arg(\n            Arg::with_name(\"x_res\")\n                .short(\"x\")\n                .long(\"x_res\")\n                .takes_value(true)\n                .help(\"Width of trace in pixels\")\n                .default_value(\"200\"),\n        )\n        .arg(\n            Arg::with_name(\"y_res\")\n                .short(\"y\")\n                .long(\"y_res\")\n                .takes_value(true)\n                .help(\"Height of trace in pixels\")\n                .default_value(\"100\"),\n        )\n        .get_matches();\n    let x_res: u32 = matches.value_of(\"x_res\").unwrap().parse().unwrap();\n    let y_res: u32 = matches.value_of(\"y_res\").unwrap().parse().unwrap();\n    let num_samples: u32 = matches.value_of(\"samples\").unwrap().parse().unwrap();\n    let num_threads: u32 = matches.value_of(\"threads\").unwrap().parse().unwrap();\n    let output = matches.value_of(\"output\");\n    let lookfrom = Vector3::new(13.0, 2.0, 3.0);\n    let lookat = Vector3::new(0.0, 0.0, 0.0);\n    let vup = Vector3::new(0.0, 1.0, 0.0);\n    let dist_to_focus = (lookfrom - lookat).length();\n    let aperture = 0.1;\n    let cam = Camera::new(\n        lookfrom,\n        lookat,\n        vup,\n        30.0,\n        x_res as f32 / y_res as f32,\n        aperture,\n        dist_to_focus,\n    );\n    let hitable_list = random_scene();\n    let bvh = BVHNode::new(hitable_list.hitables.clone());\n    let mut thread_handles = Vec::new();\n    let result = Arc::new(Mutex::new(Vec::new()));\n    let samples_per_thread = num_samples / num_threads;\n    for _ in 0..num_threads {\n        let mut thread_output = Vec::new();\n        let bvh_clone = bvh.clone();\n        let result = Arc::clone(&result);\n        // TODO Handle exceptions + num_samples not divisible by num_threads\n        thread_handles.push(thread::spawn(move || {\n            for j in (0..y_res).rev() {\n                for i in 0..x_res {\n                    let mut col = Vector3::new(0.0, 0.0, 0.0);\n                    for _s in 0..samples_per_thread {\n                        let u_rand = random::random_in_unit_interval();\n                        let v_rand = random::random_in_unit_interval();\n                        let u = (i as f32 + u_rand) / x_res as f32;\n                        let v = (j as f32 + v_rand) / y_res as f32;\n                        let ray = cam.get_ray(u, v);\n                        col = col + color(&ray, &bvh_clone, 0);\n                    }\n                    col = col / num_samples as f32;\n                    thread_output.push(col);\n                    // Do averaging in th thread\n                    // Then the final average at the end\n                }\n            }\n            let mut l_result = result.lock().unwrap();\n            if l_result.len() == 0 {\n                *l_result = thread_output;\n            } else {\n                *l_result = l_result\n                    .iter()\n                    .zip(thread_output.iter())\n                    .map(|(a, b)| a + b)\n                    .collect();\n            }\n        }));\n    }\n    for thread in thread_handles {\n        thread.join().unwrap();\n    }\n    let mut output_buffer: Vec<u8> = Vec::with_capacity(x_res as usize * y_res as usize * 3);\n    // Should buffer and only write to the file at the end\n    for col in result.lock().unwrap().iter() {\n        let out_colour = Vector3::new(\n            (255.99 * col.r().sqrt()).floor(),\n            (255.99 * col.g().sqrt()).floor(),\n            (255.99 * col.b().sqrt()).floor(),\n        );\n        output_buffer.push(out_colour.r() as u8);\n        output_buffer.push(out_colour.g() as u8);\n        output_buffer.push(out_colour.b() as u8);\n    }\n    image_out::write_image(output, &output_buffer, x_res, y_res);\n"]]}
{"hexsha": "b7279b45356e24b72bd5321e19bff9273ae0acd2", "ext": "rs", "lang": "Rust", "content": "fn test_epoll_create1() {\n  assert!(epoll_create1(0) >= 0);\n  assert!(epoll_create1(EPOLL_CLOEXEC) >= 0);\n  assert!(epoll_create1(-1) == -1);\n}", "item_id": 0, "repo": "bnoordhuis/rust-epoll", "file": "epoll.rs", "last_update_at": "2019-07-20T00:00:35+00:00", "question_id": "b7279b45356e24b72bd5321e19bff9273ae0acd2_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_epoll_create1() {\n  assert!(epoll_create1(0) >= 0);\n  assert!(epoll_create1(EPOLL_CLOEXEC) >= 0);\n  assert!(epoll_create1(-1) == -1);\n"]]}
{"hexsha": "fce6576991161de1986c215c5426470d4dd65720", "ext": "rs", "lang": "Rust", "content": "fn highest_equivalent_value() {\n    let histogram = Histogram::<u64>::with_low_high_sigvdig(1024, HIGHEST_TRACKABLE, SIG_V_DIGITS).unwrap();\n    assert_eq!(\n        8183 * 1024 + 1023,\n        histogram.highest_equivalent_value(8180 * 1024),\n        \"The highest equivalent value to 8180 * 1024 is 8183 * 1024 + 1023\"\n    );\n    assert_eq!(\n        8191 * 1024 + 1023,\n        histogram.highest_equivalent_value(8191 * 1024),\n        \"The highest equivalent value to 8187 * 1024 is 8191 * 1024 + 1023\"\n    );\n    assert_eq!(\n        8199 * 1024 + 1023,\n        histogram.highest_equivalent_value(8193 * 1024),\n        \"The highest equivalent value to 8193 * 1024 is 8199 * 1024 + 1023\"\n    );\n    assert_eq!(\n        9999 * 1024 + 1023,\n        histogram.highest_equivalent_value(9995 * 1024),\n        \"The highest equivalent value to 9995 * 1024 is 9999 * 1024 + 1023\"\n    );\n    assert_eq!(\n        10007 * 1024 + 1023,\n        histogram.highest_equivalent_value(10007 * 1024),\n        \"The highest equivalent value to 10007 * 1024 is 10007 * 1024 + 1023\"\n    );\n    assert_eq!(\n        10015 * 1024 + 1023,\n        histogram.highest_equivalent_value(10008 * 1024),\n        \"The highest equivalent value to 10008 * 1024 is 10015 * 1024 + 1023\"\n    );\n    verify_max_value(histogram);\n}", "item_id": 10, "repo": "soro/rusty-hdrhistogram", "file": "src/tests/histogram.rs", "last_update_at": "2019-07-05T14:23:00+00:00", "question_id": "fce6576991161de1986c215c5426470d4dd65720_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn highest_equivalent_value() {\n    let histogram = Histogram::<u64>::with_low_high_sigvdig(1024, HIGHEST_TRACKABLE, SIG_V_DIGITS).unwrap();\n    assert_eq!(\n        8183 * 1024 + 1023,\n        histogram.highest_equivalent_value(8180 * 1024),\n        \"The highest equivalent value to 8180 * 1024 is 8183 * 1024 + 1023\"\n    );\n    assert_eq!(\n        8191 * 1024 + 1023,\n        histogram.highest_equivalent_value(8191 * 1024),\n        \"The highest equivalent value to 8187 * 1024 is 8191 * 1024 + 1023\"\n    );\n    assert_eq!(\n        8199 * 1024 + 1023,\n        histogram.highest_equivalent_value(8193 * 1024),\n        \"The highest equivalent value to 8193 * 1024 is 8199 * 1024 + 1023\"\n    );\n    assert_eq!(\n        9999 * 1024 + 1023,\n        histogram.highest_equivalent_value(9995 * 1024),\n        \"The highest equivalent value to 9995 * 1024 is 9999 * 1024 + 1023\"\n    );\n    assert_eq!(\n        10007 * 1024 + 1023,\n        histogram.highest_equivalent_value(10007 * 1024),\n        \"The highest equivalent value to 10007 * 1024 is 10007 * 1024 + 1023\"\n    );\n    assert_eq!(\n        10015 * 1024 + 1023,\n        histogram.highest_equivalent_value(10008 * 1024),\n        \"The highest equivalent value to 10008 * 1024 is 10015 * 1024 + 1023\"\n    );\n    verify_max_value(histogram);\n"]]}
{"hexsha": "1f75caedcb552cf7f55f3e067b517ba2a9e251fe", "ext": "rs", "lang": "Rust", "content": "fn test_spaces() {\n        let s = \"( a + 2 - \\t b \\t^ 2 ) == 5\";\n        let mut lexer = Lexer::new();\n        assert_eq!(lexer.parse_string(s), Ok(()));\n\n        let variable_result: VecDeque<Exp> = vec![Exp::Variable(\"a\".to_owned()),\n                                                  Exp::Lit(Lit::Number(2)),\n                                                  Exp::Variable(\"b\".to_owned()),\n                                                  Exp::Lit(Lit::Number(2)),\n                                                  Exp::Lit(Lit::Number(5))]\n            .into_iter()\n            .rev()\n            .collect();\n        assert_eq!(lexer.state.variables, variable_result);\n\n        let operator_result: VecDeque<String> = vec![\"(\", \"+\", \"-\", \"^\", \")\", \"==\"]\n            .into_iter()\n            .rev()\n            .map(|s| s.to_owned())\n            .collect();\n        assert_eq!(lexer.state.operators, operator_result);\n    }", "item_id": 3, "repo": "DarinM223/yamlate", "file": "src/lexer/mod.rs", "last_update_at": "2019-01-13T11:36:37+00:00", "question_id": "1f75caedcb552cf7f55f3e067b517ba2a9e251fe_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_spaces() {\n        let s = \"( a + 2 - \\t b \\t^ 2 ) == 5\";\n        let mut lexer = Lexer::new();\n        assert_eq!(lexer.parse_string(s), Ok(()));\n        let variable_result: VecDeque<Exp> = vec![Exp::Variable(\"a\".to_owned()),\n                                                  Exp::Lit(Lit::Number(2)),\n                                                  Exp::Variable(\"b\".to_owned()),\n                                                  Exp::Lit(Lit::Number(2)),\n                                                  Exp::Lit(Lit::Number(5))]\n            .into_iter()\n            .rev()\n            .collect();\n        assert_eq!(lexer.state.variables, variable_result);\n        let operator_result: VecDeque<String> = vec![\"(\", \"+\", \"-\", \"^\", \")\", \"==\"]\n            .into_iter()\n            .rev()\n            .map(|s| s.to_owned())\n            .collect();\n        assert_eq!(lexer.state.operators, operator_result);\n"]]}
{"hexsha": "637390b2c7ff458be9db22fd032ece68d03c4cd5", "ext": "rs", "lang": "Rust", "content": "fn offchain_local_storage_should_work() {\n\t\tuse substrate_client::backend::OffchainStorage;\n\n\t\tlet mut ext = TestExternalities::<Blake2Hasher>::default();\n\t\tlet (offchain, state) = testing::TestOffchainExt::new();\n\t\text.set_offchain_externalities(offchain);\n\t\tlet test_code = WASM_BINARY;\n\t\tassert_eq!(\n\t\t\tWasmExecutor::new().call(&mut ext, 8, &test_code[..], \"test_offchain_local_storage\", &[]).unwrap(),\n\t\t\tvec![0]\n\t\t);\n\t\tassert_eq!(state.read().persistent_storage.get(b\"\", b\"test\"), Some(vec![]));\n\t}", "item_id": 11, "repo": "HPIPS/HPIPS_Chain", "file": "core/executor/src/wasm_executor.rs", "last_update_at": "2019-08-07T10:22:08+00:00", "question_id": "637390b2c7ff458be9db22fd032ece68d03c4cd5_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn offchain_local_storage_should_work() {\n\t\tuse substrate_client::backend::OffchainStorage;\n\t\tlet mut ext = TestExternalities::<Blake2Hasher>::default();\n\t\tlet (offchain, state) = testing::TestOffchainExt::new();\n\t\text.set_offchain_externalities(offchain);\n\t\tlet test_code = WASM_BINARY;\n\t\tassert_eq!(\n\t\t\tWasmExecutor::new().call(&mut ext, 8, &test_code[..], \"test_offchain_local_storage\", &[]).unwrap(),\n\t\t\tvec![0]\n\t\t);\n\t\tassert_eq!(state.read().persistent_storage.get(b\"\", b\"test\"), Some(vec![]));\n"]]}
{"hexsha": "d70c00feb034c08e7df1e706ca60e83f1fc05eab", "ext": "rs", "lang": "Rust", "content": "fn create_bitmap_metadata(glyph_tab: &GlyphTable, spec: AtlasSpec) -> HashMap<usize, GlyphMetadata> {\n    let mut metadata = HashMap::new();\n    let glyph_metadata_space = GlyphMetadata::new(32, 0, 0, 0.5, 1.0, 0.0, 0.0, 0.0);\n    metadata.insert(32, glyph_metadata_space);\n    for i in glyph_tab.buffer.keys() {\n        let order = i - 32;\n        let col = order % spec.columns;\n        let row = order % spec.columns;\n\n        // Glyph metadata parameters.\n        let x_min = (col * spec.slot_glyph_size) as f32 / spec.width as f32;\n        let y_min = (row * spec.slot_glyph_size) as f32 / spec.height as f32;\n        let width = (glyph_tab.width[*i] + spec.padding as i32) as f32 / spec.slot_glyph_size as f32;\n        let height = (glyph_tab.rows[*i] + spec.padding as i32) as f32 / spec.slot_glyph_size as f32;\n        let y_offset = -(spec.padding as f32 - glyph_tab.y_min[*i] as f32) / spec.slot_glyph_size as f32;\n\n        let row = order / spec.rows;\n        let column = order % spec.columns;\n        let glyph_metadata_i = GlyphMetadata::new(*i, row, column, width, height, x_min, y_min, y_offset);\n        metadata.insert(*i, glyph_metadata_i);\n    }\n\n    metadata\n}", "item_id": 2, "repo": "lambdaxymox/fontgen", "file": "src/main.rs", "last_update_at": "2019-05-08T14:51:01+00:00", "question_id": "d70c00feb034c08e7df1e706ca60e83f1fc05eab_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn create_bitmap_metadata(glyph_tab: &GlyphTable, spec: AtlasSpec) -> HashMap<usize, GlyphMetadata> {\n    let mut metadata = HashMap::new();\n    let glyph_metadata_space = GlyphMetadata::new(32, 0, 0, 0.5, 1.0, 0.0, 0.0, 0.0);\n    metadata.insert(32, glyph_metadata_space);\n    for i in glyph_tab.buffer.keys() {\n        let order = i - 32;\n        let col = order % spec.columns;\n        let row = order % spec.columns;\n        // Glyph metadata parameters.\n        let x_min = (col * spec.slot_glyph_size) as f32 / spec.width as f32;\n        let y_min = (row * spec.slot_glyph_size) as f32 / spec.height as f32;\n        let width = (glyph_tab.width[*i] + spec.padding as i32) as f32 / spec.slot_glyph_size as f32;\n        let height = (glyph_tab.rows[*i] + spec.padding as i32) as f32 / spec.slot_glyph_size as f32;\n        let y_offset = -(spec.padding as f32 - glyph_tab.y_min[*i] as f32) / spec.slot_glyph_size as f32;\n        let row = order / spec.rows;\n        let column = order % spec.columns;\n        let glyph_metadata_i = GlyphMetadata::new(*i, row, column, width, height, x_min, y_min, y_offset);\n        metadata.insert(*i, glyph_metadata_i);\n    }\n    metadata\n"]]}
{"hexsha": "288857f932a01df49cd36640e03ea4769e361ab4", "ext": "rs", "lang": "Rust", "content": "fn projection_onto_zero_vector_is_zero_vector() {\n        let vector = Vector {\n            x: 1_000.0,\n            y: -2_000.0,\n        };\n        let zero_vector = Vector::default();\n        let expected_projection = zero_vector;\n        let projection = vector.project_onto(zero_vector);\n\n        assert_eq!(expected_projection, projection);\n    }", "item_id": 34, "repo": "myelin-ai/geometry", "file": "src/vector.rs", "last_update_at": "2019-12-16T12:57:14+00:00", "question_id": "288857f932a01df49cd36640e03ea4769e361ab4_34", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn projection_onto_zero_vector_is_zero_vector() {\n        let vector = Vector {\n            x: 1_000.0,\n            y: -2_000.0,\n        };\n        let zero_vector = Vector::default();\n        let expected_projection = zero_vector;\n        let projection = vector.project_onto(zero_vector);\n        assert_eq!(expected_projection, projection);\n"]]}
{"hexsha": "cd1fef1155dc9f5367ec66296326ca2c1202a43b", "ext": "rs", "lang": "Rust", "content": "pub fn cached_expand_impl(input: TokenStream) -> TokenStream {\n    if let Ok(val) = env::var(\"IN_DOCKER\") {\n        if val == \"1\" {\n            println!(\"Running in Docker, so just returning original input-tokens.\");\n            return input;\n        }\n    }\n\n    let _input_str = input.to_string();\n    //println!(\"Input: {:?}\", input);\n\n    let mut group_id = \"\".to_owned();\n    let mut exclude_lines_with = \"NEVER_MATCHING\".to_owned();\n    {\n        let mut past_token_strings: Vec<String> = Vec::new();\n        for token in input.clone() {\n            println!(\"Got token:{token}\");\n            let token_str = format!(\"{token}\");\n\n            /*if token_str.starts_with(\"CEID_\") && last_token_str.is_some() && last_token_str.unwrap() == \"struct\" {\n                result = token_str[\"CEID_\".len()..].to_string();\n                break;\n            }*/\n            if let Some(token_5_back) = past_token_strings.get((past_token_strings.len() as isize - 5) as usize) {\n                if token_5_back == \"ce_args\" {\n                    let mut lines = token_str.split(\"\\n\");\n                    // example line: id = \"access_policies\"\n                    if let Some(id_line) = lines.find(|a| a.contains(\"id = \")) {\n                        group_id = id_line.split(\"\\\"\").collect::<Vec<&str>>()[1].to_owned();\n                    }\n                    // example line: excludeLinesWith = \"#[graphql(name\"\n                    if let Some(exclude_lines_with_0line) = lines.find(|a| a.contains(\"excludeLinesWith = \")) {\n                        exclude_lines_with = exclude_lines_with_0line.split(\"\\\"\").collect::<Vec<&str>>()[1].to_owned();\n                    }\n                    break;\n                }\n            }\n\n            past_token_strings.push(token_str);\n            /*if past_token_strings.len() > 3 {\n                past_token_strings.pop_front();\n            }*/\n\n            // if we've processed 30 tokens, and still haven't reached a ce_args string, give up (it should be at the very top)\n            if past_token_strings.len() > 30 {\n                break;\n            }\n        }\n    }\n    if group_id == \"\" {\n        panic!(\"Could not cached_expand args. Provide it using pattern: const ce_args: &str = r#\\\"id = \\\"<group name here>\\\"\\\"#;\");\n    }\n    println!(\"Found args. @id:{group_id} @excludeLinesWith:{exclude_lines_with}\");\n    let cache_folder_path = env::current_dir().unwrap().join(\"target\").join(\"cached_expand\").join(\"expansions\");\n    let cache_input_path = cache_folder_path.join(group_id.clone() + \"_Input\");\n    let cache_output_path = cache_folder_path.join(group_id.clone() + \"_Output\");\n\n    //if env::var(\"FOR_CACHED_EXPAND\").is_ok_with(|a| a == \"1\") {\n    //if let Ok(val) = env::var(\"FOR_CACHED_EXPAND\") && val == \"1\" {\n    const SPECIAL_MESSAGE_1: &str = \"FOR_CACHED_EXPAND is true, so only adding markers.\";\n    const SPECIAL_MESSAGE_2: &str = \"FOR_RUST_ANALYZER is true, so only adding markers.\";\n    let only_add_markers = {\n        let mut temp = false;\n        // if this macro is running as part of the \"cargo expand\" command (of a parent instance of this macro), then...\n        if let Ok(val) = env::var(\"FOR_CACHED_EXPAND\") {\n            if val == \"1\" {\n                println!(\"{}\", SPECIAL_MESSAGE_1);\n                temp = true;\n            }\n        }\n        // if this macro is running as part of rust-analyzer, then...\n        // todo: find alternative (one I didn't hard-code into settings.json)\n        if let Ok(val) = env::var(\"FOR_RUST_ANALYZER\") {\n            if val == \"1\" {\n                println!(\"{}\", SPECIAL_MESSAGE_2);\n                temp = true;\n            }\n        }\n        temp\n    };\n    if only_add_markers {\n        /*let pre_tokens = TokenStream::from(quote! { struct StartMarker {} });*/\n        let pre_tokens = TokenStream::from_str(format!(\"struct StartMarker_{group_id} {{}}\").as_str()).unwrap();\n        //println!(\"PreTokens:{}\", pre_tokens);\n        //let post_tokens = TokenStream::from(quote! { struct EndMarker {} });\n        let post_tokens = TokenStream::from_str(format!(\"struct EndMarker_{group_id} {{}}\").as_str()).unwrap();\n        return pre_tokens.into_iter()\n            .chain(input)\n            .chain(post_tokens.into_iter())\n            .collect();\n    }\n\n    // check for a cache-hit\n    if cache_input_path.exists() && fs::read_to_string(cache_input_path.clone()).unwrap() == input.to_string() && cache_output_path.exists() {\n        let cached_output = fs::read_to_string(cache_output_path.clone()).unwrap();\n        println!(\"Cache hit! Cached-output length: {}\", cached_output.len());\n        return TokenStream::from_str(&cached_output).unwrap();\n    }\n\n    //println!(\"Env-vars:{}\", env::vars().map(|(var_name, var_value)| format!(\"{var_name}: {var_value}\")).collect::<Vec<String>>().join(\"\\n\"));\n\n    let working_dir = env::current_dir().unwrap();\n    let working_dir_str = working_dir.as_path().display().to_string();\n    println!(\"Working-dir:{}\", working_dir_str);\n    \n    let mut cmd =\n        // todo: fix that the user must call \"cargo +nightly build\" instead of just \"cargo build\" (for the initial command to start things off)\n        Command::new(\"cargo\")//.arg(\"+nightly\")\n        .arg(\"expand\")\n        //.arg(\"::\".to_owned() + &struct_id)\n        //.arg(\"::sub1\") // temp\n        .arg(\"--target-dir\").arg(\"/tmp/cargo-expand-for-cached-expand\")\n        .env(\"FOR_CACHED_EXPAND\", \"1\")\n        //.current_dir(working_dir)\n        .current_dir(working_dir_str + \"/Packages/app-server-rs\")\n        \n        //.output()\n        .stdout(Stdio::piped())\n        //.stderr(Stdio::piped())\n        .spawn()\n\n        .unwrap();\n\n    //String::from_utf8_lossy(&expand_command_output.stderr)\n    let mut expanded_code = \"\".to_owned();\n    {\n        /*let stderr = cmd.stderr.as_mut().unwrap();\n        let stderr_reader = BufReader::new(stderr);\n        let stderr_lines = stderr_reader.lines();\n        for (i, line) in stderr_lines.enumerate() {\n            let line_str = line.unwrap().to_string();\n            println!(\"Err({i}): {line_str}\");\n        }*/\n\n        let stdout = cmd.stdout.as_mut().unwrap();\n        let stdout_reader = BufReader::new(stdout);\n        let stdout_lines = stdout_reader.lines();\n\n        let mut start_marker_hit = false;\n        let mut end_marker_hit = false;\n        for (_i, line) in stdout_lines.enumerate() {\n            let line_str = line.unwrap().to_string();\n            //println!(\"Read({i}): {line_str}\");\n\n            if line_str.contains(format!(\"StartMarker_{group_id}\").as_str()) {\n                start_marker_hit = true;\n            }\n\n            if start_marker_hit && !end_marker_hit && line_str != SPECIAL_MESSAGE_1 && line_str != SPECIAL_MESSAGE_2 {\n                if line_str.contains(exclude_lines_with.as_str()) {\n                    println!(\"Ignoring line, based on excludeLinesWith setting:{}\", line_str);\n                } else {\n                    //println!(\"FoundExpanded({i}): {line_str}\");\n                    expanded_code += &line_str;\n                }\n            }\n\n            // run this after, so end-marker is still included\n            if line_str.contains(format!(\"EndMarker_{group_id}\").as_str()) {\n                end_marker_hit = true;\n            }\n        }\n    }\n\n    cmd.wait().unwrap();\n        \n    //println!(\"Expanded code:[[[{}]]]\", expanded_code);\n    println!(\"Expanded code length:{}\", expanded_code.len());\n    if expanded_code.is_empty() {\n        panic!(\"Expanded-code is empty! Terminating...\");\n    }\n\n    println!(\"Caching input-code and expanded-code to:{}\", cache_folder_path.as_path().display().to_string());\n    fs::create_dir_all(cache_folder_path).unwrap();\n    fs::write(cache_input_path.clone(), input.to_string()).unwrap();\n    fs::write(cache_output_path.clone(), expanded_code.clone()).unwrap();\n    println!(\"Writes done! Proofs:[{}, {}]\",\n        fs::read_to_string(cache_input_path.clone()).unwrap().len(),\n        fs::read_to_string(cache_output_path.clone()).unwrap().len());\n\n    return TokenStream::from_str(&expanded_code).unwrap();\n}", "item_id": 0, "repo": "Venryx/DebateMap", "file": "Packages/rust-macros/src/cached_expand.rs", "last_update_at": "2019-12-30T13:00:05+00:00", "question_id": "cd1fef1155dc9f5367ec66296326ca2c1202a43b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn cached_expand_impl(input: TokenStream) -> TokenStream {\n    if let Ok(val) = env::var(\"IN_DOCKER\") {\n        if val == \"1\" {\n            println!(\"Running in Docker, so just returning original input-tokens.\");\n            return input;\n        }\n    }\n    let _input_str = input.to_string();\n    //println!(\"Input: {:?}\", input);\n    let mut group_id = \"\".to_owned();\n    let mut exclude_lines_with = \"NEVER_MATCHING\".to_owned();\n    {\n        let mut past_token_strings: Vec<String> = Vec::new();\n        for token in input.clone() {\n            println!(\"Got token:{token}\");\n            let token_str = format!(\"{token}\");\n            /*if token_str.starts_with(\"CEID_\") && last_token_str.is_some() && last_token_str.unwrap() == \"struct\" {\n                result = token_str[\"CEID_\".len()..].to_string();\n                break;\n            }*/\n            if let Some(token_5_back) = past_token_strings.get((past_token_strings.len() as isize - 5) as usize) {\n                if token_5_back == \"ce_args\" {\n                    let mut lines = token_str.split(\"\\n\");\n                    // example line: id = \"access_policies\"\n                    if let Some(id_line) = lines.find(|a| a.contains(\"id = \")) {\n                        group_id = id_line.split(\"\\\"\").collect::<Vec<&str>>()[1].to_owned();\n                    }\n                    // example line: excludeLinesWith = \"#[graphql(name\"\n                    if let Some(exclude_lines_with_0line) = lines.find(|a| a.contains(\"excludeLinesWith = \")) {\n                        exclude_lines_with = exclude_lines_with_0line.split(\"\\\"\").collect::<Vec<&str>>()[1].to_owned();\n                    }\n                    break;\n                }\n            }\n            past_token_strings.push(token_str);\n            /*if past_token_strings.len() > 3 {\n                past_token_strings.pop_front();\n            }*/\n            // if we've processed 30 tokens, and still haven't reached a ce_args string, give up (it should be at the very top)\n            if past_token_strings.len() > 30 {\n                break;\n            }\n        }\n    }\n    if group_id == \"\" {\n        panic!(\"Could not cached_expand args. Provide it using pattern: const ce_args: &str = r#\\\"id = \\\"<group name here>\\\"\\\"#;\");\n    }\n    println!(\"Found args. @id:{group_id} @excludeLinesWith:{exclude_lines_with}\");\n    let cache_folder_path = env::current_dir().unwrap().join(\"target\").join(\"cached_expand\").join(\"expansions\");\n    let cache_input_path = cache_folder_path.join(group_id.clone() + \"_Input\");\n    let cache_output_path = cache_folder_path.join(group_id.clone() + \"_Output\");\n    //if env::var(\"FOR_CACHED_EXPAND\").is_ok_with(|a| a == \"1\") {\n    //if let Ok(val) = env::var(\"FOR_CACHED_EXPAND\") && val == \"1\" {\n    const SPECIAL_MESSAGE_1: &str = \"FOR_CACHED_EXPAND is true, so only adding markers.\";\n    const SPECIAL_MESSAGE_2: &str = \"FOR_RUST_ANALYZER is true, so only adding markers.\";\n    let only_add_markers = {\n        let mut temp = false;\n        // if this macro is running as part of the \"cargo expand\" command (of a parent instance of this macro), then...\n        if let Ok(val) = env::var(\"FOR_CACHED_EXPAND\") {\n            if val == \"1\" {\n                println!(\"{}\", SPECIAL_MESSAGE_1);\n                temp = true;\n            }\n        }\n        // if this macro is running as part of rust-analyzer, then...\n        // todo: find alternative (one I didn't hard-code into settings.json)\n        if let Ok(val) = env::var(\"FOR_RUST_ANALYZER\") {\n            if val == \"1\" {\n                println!(\"{}\", SPECIAL_MESSAGE_2);\n                temp = true;\n            }\n        }\n        temp\n    };\n    if only_add_markers {\n        /*let pre_tokens = TokenStream::from(quote! { struct StartMarker {} });*/\n        let pre_tokens = TokenStream::from_str(format!(\"struct StartMarker_{group_id} {{}}\").as_str()).unwrap();\n        //println!(\"PreTokens:{}\", pre_tokens);\n        //let post_tokens = TokenStream::from(quote! { struct EndMarker {} });\n        let post_tokens = TokenStream::from_str(format!(\"struct EndMarker_{group_id} {{}}\").as_str()).unwrap();\n        return pre_tokens.into_iter()\n            .chain(input)\n            .chain(post_tokens.into_iter())\n            .collect();\n    }\n    // check for a cache-hit\n    if cache_input_path.exists() && fs::read_to_string(cache_input_path.clone()).unwrap() == input.to_string() && cache_output_path.exists() {\n        let cached_output = fs::read_to_string(cache_output_path.clone()).unwrap();\n        println!(\"Cache hit! Cached-output length: {}\", cached_output.len());\n        return TokenStream::from_str(&cached_output).unwrap();\n    }\n    //println!(\"Env-vars:{}\", env::vars().map(|(var_name, var_value)| format!(\"{var_name}: {var_value}\")).collect::<Vec<String>>().join(\"\\n\"));\n    let working_dir = env::current_dir().unwrap();\n    let working_dir_str = working_dir.as_path().display().to_string();\n    println!(\"Working-dir:{}\", working_dir_str);\n    let mut cmd =\n        // todo: fix that the user must call \"cargo +nightly build\" instead of just \"cargo build\" (for the initial command to start things off)\n        Command::new(\"cargo\")//.arg(\"+nightly\")\n        .arg(\"expand\")\n        //.arg(\"::\".to_owned() + &struct_id)\n        //.arg(\"::sub1\") // temp\n        .arg(\"--target-dir\").arg(\"/tmp/cargo-expand-for-cached-expand\")\n        .env(\"FOR_CACHED_EXPAND\", \"1\")\n        //.current_dir(working_dir)\n        .current_dir(working_dir_str + \"/Packages/app-server-rs\")\n        //.output()\n        .stdout(Stdio::piped())\n        //.stderr(Stdio::piped())\n        .spawn()\n        .unwrap();\n    //String::from_utf8_lossy(&expand_command_output.stderr)\n    let mut expanded_code = \"\".to_owned();\n    {\n        /*let stderr = cmd.stderr.as_mut().unwrap();\n        let stderr_reader = BufReader::new(stderr);\n        let stderr_lines = stderr_reader.lines();\n        for (i, line) in stderr_lines.enumerate() {\n            let line_str = line.unwrap().to_string();\n            println!(\"Err({i}): {line_str}\");\n        }*/\n        let stdout = cmd.stdout.as_mut().unwrap();\n        let stdout_reader = BufReader::new(stdout);\n        let stdout_lines = stdout_reader.lines();\n        let mut start_marker_hit = false;\n        let mut end_marker_hit = false;\n        for (_i, line) in stdout_lines.enumerate() {\n            let line_str = line.unwrap().to_string();\n            //println!(\"Read({i}): {line_str}\");\n            if line_str.contains(format!(\"StartMarker_{group_id}\").as_str()) {\n                start_marker_hit = true;\n            }\n            if start_marker_hit && !end_marker_hit && line_str != SPECIAL_MESSAGE_1 && line_str != SPECIAL_MESSAGE_2 {\n                if line_str.contains(exclude_lines_with.as_str()) {\n                    println!(\"Ignoring line, based on excludeLinesWith setting:{}\", line_str);\n                } else {\n                    //println!(\"FoundExpanded({i}): {line_str}\");\n                    expanded_code += &line_str;\n                }\n            }\n            // run this after, so end-marker is still included\n            if line_str.contains(format!(\"EndMarker_{group_id}\").as_str()) {\n                end_marker_hit = true;\n            }\n        }\n    }\n    cmd.wait().unwrap();\n    //println!(\"Expanded code:[[[{}]]]\", expanded_code);\n    println!(\"Expanded code length:{}\", expanded_code.len());\n    if expanded_code.is_empty() {\n        panic!(\"Expanded-code is empty! Terminating...\");\n    }\n    println!(\"Caching input-code and expanded-code to:{}\", cache_folder_path.as_path().display().to_string());\n    fs::create_dir_all(cache_folder_path).unwrap();\n    fs::write(cache_input_path.clone(), input.to_string()).unwrap();\n    fs::write(cache_output_path.clone(), expanded_code.clone()).unwrap();\n    println!(\"Writes done! Proofs:[{}, {}]\",\n        fs::read_to_string(cache_input_path.clone()).unwrap().len(),\n        fs::read_to_string(cache_output_path.clone()).unwrap().len());\n    return TokenStream::from_str(&expanded_code).unwrap();\n"]]}
{"hexsha": "c69be8ce7ea790a7130a3a0e58140a8bb5541808", "ext": "rs", "lang": "Rust", "content": "fn update_number_of_confirmations<F1: Fn() -> H256, F2: Fn(H256) -> Option<u64>>(latest_block: &F1, confirmations: &F2, future_new_set: &mut Option<FutureNewSet>, snapshot: &mut KeyServerSetSnapshot) {\n\tmatch future_new_set.as_mut() {\n\t\t// no future new set is scheduled => do nothing,\n\t\tNone => return,\n\t\t// else we should calculate number of confirmations for future new set\n\t\tSome(future_new_set) => match confirmations(future_new_set.block.clone()) {\n\t\t\t// we have enough confirmations => should move new_set from future to snapshot\n\t\t\tSome(confirmations) if confirmations >= MIGRATION_CONFIRMATIONS_REQUIRED => (),\n\t\t\t// not enough confirmations => do nothing\n\t\t\tSome(_) => return,\n\t\t\t// if number of confirmations is None, then reorg has happened && we need to reset block\n\t\t\t// (some more intelligent strategy is possible, but let's stick to simplest one)\n\t\t\tNone => {\n\t\t\t\tfuture_new_set.block = latest_block();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tlet future_new_set = future_new_set.take()\n\t\t.expect(\"we only pass through match above when future_new_set is some; qed\");\n\tsnapshot.new_set = future_new_set.new_set;\n}", "item_id": 2, "repo": "altice-io/Daqiao", "file": "bridge/parity-ethereum/secret-store/src/key_server_set.rs", "last_update_at": "2019-09-11T12:07:35+00:00", "question_id": "c69be8ce7ea790a7130a3a0e58140a8bb5541808_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn update_number_of_confirmations<F1: Fn() -> H256, F2: Fn(H256) -> Option<u64>>(latest_block: &F1, confirmations: &F2, future_new_set: &mut Option<FutureNewSet>, snapshot: &mut KeyServerSetSnapshot) {\n\tmatch future_new_set.as_mut() {\n\t\t// no future new set is scheduled => do nothing,\n\t\tNone => return,\n\t\t// else we should calculate number of confirmations for future new set\n\t\tSome(future_new_set) => match confirmations(future_new_set.block.clone()) {\n\t\t\t// we have enough confirmations => should move new_set from future to snapshot\n\t\t\tSome(confirmations) if confirmations >= MIGRATION_CONFIRMATIONS_REQUIRED => (),\n\t\t\t// not enough confirmations => do nothing\n\t\t\tSome(_) => return,\n\t\t\t// if number of confirmations is None, then reorg has happened && we need to reset block\n\t\t\t// (some more intelligent strategy is possible, but let's stick to simplest one)\n\t\t\tNone => {\n\t\t\t\tfuture_new_set.block = latest_block();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tlet future_new_set = future_new_set.take()\n\t\t.expect(\"we only pass through match above when future_new_set is some; qed\");\n\tsnapshot.new_set = future_new_set.new_set;\n"]]}
{"hexsha": "28a61e0ae694670963b9349442b4f33323959f7e", "ext": "rs", "lang": "Rust", "content": "fn read_str_utf8_lossy(&mut self, len: usize) -> io::Result<String> {\n        let mut buf = vec![0u8; len];\n        self.read_exact(&mut buf[..])?;\n        Ok(String::from_utf8_lossy(&buf).into_owned())\n    }", "item_id": 2, "repo": "viriuwu/minio", "file": "src/lib.rs", "last_update_at": "2019-10-29T20:31:47+00:00", "question_id": "28a61e0ae694670963b9349442b4f33323959f7e_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_str_utf8_lossy(&mut self, len: usize) -> io::Result<String> {\n        let mut buf = vec![0u8; len];\n        self.read_exact(&mut buf[..])?;\n        Ok(String::from_utf8_lossy(&buf).into_owned())\n"]]}
{"hexsha": "54fab6b6c5be235d38e2ca03ba98a85d03f5e074", "ext": "rs", "lang": "Rust", "content": "fn find_best_phase_setting(run: fn(&IntcodeMachine, &Vec<Value>) -> Value, range: std::ops::Range<Value>, template: &IntcodeMachine) -> (Value, Vec<Value>) {\n    let mut max = 0;\n    let mut best_phase_setting = vec![];\n    for perm in range.permutations(5) {\n        let output = run(&template, &perm);\n        if output > max {\n            max = output;\n            best_phase_setting = perm;\n        }\n    }\n    (max, best_phase_setting)\n}", "item_id": 0, "repo": "scy/advent-of-code", "file": "2019/src/bin/aoc2019_07.rs", "last_update_at": "2019-12-10T15:40:37+00:00", "question_id": "54fab6b6c5be235d38e2ca03ba98a85d03f5e074_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn find_best_phase_setting(run: fn(&IntcodeMachine, &Vec<Value>) -> Value, range: std::ops::Range<Value>, template: &IntcodeMachine) -> (Value, Vec<Value>) {\n    let mut max = 0;\n    let mut best_phase_setting = vec![];\n    for perm in range.permutations(5) {\n        let output = run(&template, &perm);\n        if output > max {\n            max = output;\n            best_phase_setting = perm;\n        }\n    }\n    (max, best_phase_setting)\n"]]}
{"hexsha": "e3db959b6939aacb3fd4ba6e78bab7943a36f1f8", "ext": "rs", "lang": "Rust", "content": "fn main() {\n  // ...handle just one enum variant specially\n  if let RoughTime::InTheFuture(_, _) = user.date_of_birth() { user.set_time_traveler(true); }\n\n  // ...run some code only if a table lookup succeeds\n  if let Some(document) = cache_map.get(&id) { return send_cached_response(document); }\n\n  // ...repeatedly try something until it succeeds\n  while let Err(err) = present_cheesy_anti_robot_task() { log_robot_attempt(err);\n    // let the user try again (it might still be a human)\n  }\n\n  // ...manually loop over an iterator\n  while let Some(_) = lines.peek() {\n      read_paragraph(&mut lines);\n  }\n}", "item_id": 0, "repo": "raventid/coursera_learning", "file": "rust/programming_rust_notes/patterns.rs", "last_update_at": "2019-11-28T09:26:00+00:00", "question_id": "e3db959b6939aacb3fd4ba6e78bab7943a36f1f8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n  // ...handle just one enum variant specially\n  if let RoughTime::InTheFuture(_, _) = user.date_of_birth() { user.set_time_traveler(true); }\n  // ...run some code only if a table lookup succeeds\n  if let Some(document) = cache_map.get(&id) { return send_cached_response(document); }\n  // ...repeatedly try something until it succeeds\n  while let Err(err) = present_cheesy_anti_robot_task() { log_robot_attempt(err);\n    // let the user try again (it might still be a human)\n  }\n  // ...manually loop over an iterator\n  while let Some(_) = lines.peek() {\n      read_paragraph(&mut lines);\n  }\n"]]}
{"hexsha": "a4eeb1b00416106473e403e4ddafbb71c5bbe0f0", "ext": "rs", "lang": "Rust", "content": "fn test_label_order() {\n    let vec = CounterVec::new(Opts::new(\"foo\", \"bar\"), &[\"product\", \"method\"]).unwrap();\n    let metric = SimpleCounterVec::from(&vec);\n    assert_eq!(get_labels(&metric.post.foo), vec![\"post\", \"foo\"]);\n    assert_eq!(get_labels(&metric.put.bar), vec![\"put\", \"bar\"]);\n}", "item_id": 2, "repo": "nrc/rust-prometheus", "file": "static-metric/tests/metric.rs", "last_update_at": "2019-07-18T01:26:49+00:00", "question_id": "a4eeb1b00416106473e403e4ddafbb71c5bbe0f0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_label_order() {\n    let vec = CounterVec::new(Opts::new(\"foo\", \"bar\"), &[\"product\", \"method\"]).unwrap();\n    let metric = SimpleCounterVec::from(&vec);\n    assert_eq!(get_labels(&metric.post.foo), vec![\"post\", \"foo\"]);\n    assert_eq!(get_labels(&metric.put.bar), vec![\"put\", \"bar\"]);\n"]]}
{"hexsha": "6b7315f81f184920c72a1f75fe6e92f1832af6e7", "ext": "rs", "lang": "Rust", "content": "pub fn part2(lines: &Vec<String>) -> i64 {\n    assert_eq!(lines.len(), 2);\n    let grid1 = follow_line(&lines[0]);\n    let grid2 = follow_line(&lines[1]);\n\n    let mut best = -1;\n    for (xy, v1) in grid1 {\n        match grid2.get(&xy) {\n            Some(&v2) => {\n                let dist = v1 + v2;\n                if best == -1 || dist < best {\n                    best = dist;\n                }\n            }\n            _ => {}\n        }\n    }\n    return best;\n}", "item_id": 2, "repo": "pankdm/adventofcode-2019", "file": "src/bin/day3.rs", "last_update_at": "2019-12-13T02:21:50+00:00", "question_id": "6b7315f81f184920c72a1f75fe6e92f1832af6e7_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn part2(lines: &Vec<String>) -> i64 {\n    assert_eq!(lines.len(), 2);\n    let grid1 = follow_line(&lines[0]);\n    let grid2 = follow_line(&lines[1]);\n    let mut best = -1;\n    for (xy, v1) in grid1 {\n        match grid2.get(&xy) {\n            Some(&v2) => {\n                let dist = v1 + v2;\n                if best == -1 || dist < best {\n                    best = dist;\n                }\n            }\n            _ => {}\n        }\n    }\n    return best;\n"]]}
{"hexsha": "05216473848c00ceff74ec3f9ad623dd59bf324a", "ext": "rs", "lang": "Rust", "content": "fn setting_getting_caller() {\n    // given\n    let mut engine = Engine::new();\n    let account_id = vec![1; 32];\n\n    // when\n    engine.set_caller(account_id.clone());\n\n    // then\n    let mut output = get_buffer();\n    engine.caller(&mut &mut output[..]);\n    assert_eq!(&output[..account_id.len()], &account_id);\n}", "item_id": 2, "repo": "kaiweicai/ink-example", "file": "crates/engine/src/tests.rs", "last_update_at": "2019-04-20T01:12:47+00:00", "question_id": "05216473848c00ceff74ec3f9ad623dd59bf324a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn setting_getting_caller() {\n    // given\n    let mut engine = Engine::new();\n    let account_id = vec![1; 32];\n    // when\n    engine.set_caller(account_id.clone());\n    // then\n    let mut output = get_buffer();\n    engine.caller(&mut &mut output[..]);\n    assert_eq!(&output[..account_id.len()], &account_id);\n"]]}
{"hexsha": "e4e38acf3a7a5b13173f28b25bbf959d8dde15d4", "ext": "rs", "lang": "Rust", "content": "fn test_return() {\n    let mut cpu = CPU::new(&vec![], None);\n    cpu.stack.push(0x400);\n    cpu.do_instruction(&Instruction::Return).unwrap();\n    assert_eq!(cpu.stack.len(), 0);\n    assert_eq!(cpu.pc, 0x402);\n}", "item_id": 2, "repo": "shiver/chip8", "file": "tests/chip8.rs", "last_update_at": "2019-03-11T00:08:10+00:00", "question_id": "e4e38acf3a7a5b13173f28b25bbf959d8dde15d4_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_return() {\n    let mut cpu = CPU::new(&vec![], None);\n    cpu.stack.push(0x400);\n    cpu.do_instruction(&Instruction::Return).unwrap();\n    assert_eq!(cpu.stack.len(), 0);\n    assert_eq!(cpu.pc, 0x402);\n"]]}
{"hexsha": "eafee5552fec09ab40e3dc80effd66bf763c7af4", "ext": "rs", "lang": "Rust", "content": "fn test_origin() {\n        let r: Raw = vec![b\"http://foo.com\".to_vec()].into();\n        let origin : Origin = Header::parse_header(&r).unwrap();\n        assert_eq!(&origin, &Origin::new(\"http\", \"foo.com\", None));\n        assert_borrowed!(origin.scheme().unwrap().into());\n\n        let r: Raw = vec![b\"https://foo.com:443\".to_vec()].into();\n        let origin : Origin = Header::parse_header(&r).unwrap();\n        assert_eq!(&origin, &Origin::new(\"https\", \"foo.com\", Some(443)));\n        assert_borrowed!(origin.scheme().unwrap().into());\n    }", "item_id": 0, "repo": "alyssais/hyperx", "file": "src/header/common/origin.rs", "last_update_at": "2019-06-02T06:33:59+00:00", "question_id": "eafee5552fec09ab40e3dc80effd66bf763c7af4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_origin() {\n        let r: Raw = vec![b\"http://foo.com\".to_vec()].into();\n        let origin : Origin = Header::parse_header(&r).unwrap();\n        assert_eq!(&origin, &Origin::new(\"http\", \"foo.com\", None));\n        assert_borrowed!(origin.scheme().unwrap().into());\n        let r: Raw = vec![b\"https://foo.com:443\".to_vec()].into();\n        let origin : Origin = Header::parse_header(&r).unwrap();\n        assert_eq!(&origin, &Origin::new(\"https\", \"foo.com\", Some(443)));\n        assert_borrowed!(origin.scheme().unwrap().into());\n"]]}
{"hexsha": "e8f1df1fcc4fb8ee3fe36c57f9e8adb3b0f8dca4", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn write(path: &Path, contents: TokenStream) -> Result<()> {\n    let mut out = header().into_bytes();\n    out.extend_from_slice(prettyplease::unparse(&syn::parse2(contents).unwrap()).as_bytes());\n    if path.is_file() && fs::read(&path)? == out {\n        return Ok(());\n    }\n    fs::write(path, out)?;\n    Ok(())\n}", "item_id": 1, "repo": "taiki-e/serde-syn", "file": "tools/codegen/src/file.rs", "last_update_at": "2019-09-06T03:47:46+00:00", "question_id": "e8f1df1fcc4fb8ee3fe36c57f9e8adb3b0f8dca4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn write(path: &Path, contents: TokenStream) -> Result<()> {\n    let mut out = header().into_bytes();\n    out.extend_from_slice(prettyplease::unparse(&syn::parse2(contents).unwrap()).as_bytes());\n    if path.is_file() && fs::read(&path)? == out {\n        return Ok(());\n    }\n    fs::write(path, out)?;\n    Ok(())\n"]]}
{"hexsha": "3e319eb06ec5d4f48b6b885940d3ac2c7ceba3d7", "ext": "rs", "lang": "Rust", "content": "fn test_compile_set_e() {\n    let compiled = register::compile_set(\"E\".to_string(), \"10\".to_string());\n\n    assert_eq!(compiled.len(), 9);\n    assert_eq!(compiled[0], 0b00001100);\n    assert_eq!(compiled[1], 0);\n    assert_eq!(compiled[2], 0);\n    assert_eq!(compiled[3], 0);\n    assert_eq!(compiled[4], 0);\n    assert_eq!(compiled[5], 0);\n    assert_eq!(compiled[6], 0);\n    assert_eq!(compiled[7], 0);\n    assert_eq!(compiled[8], 10);\n}", "item_id": 4, "repo": "TheLocust3/simple-virtual-machine", "file": "asm/tests/compiler_register_tests.rs", "last_update_at": "2019-02-18T04:28:41+00:00", "question_id": "3e319eb06ec5d4f48b6b885940d3ac2c7ceba3d7_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_compile_set_e() {\n    let compiled = register::compile_set(\"E\".to_string(), \"10\".to_string());\n    assert_eq!(compiled.len(), 9);\n    assert_eq!(compiled[0], 0b00001100);\n    assert_eq!(compiled[1], 0);\n    assert_eq!(compiled[2], 0);\n    assert_eq!(compiled[3], 0);\n    assert_eq!(compiled[4], 0);\n    assert_eq!(compiled[5], 0);\n    assert_eq!(compiled[6], 0);\n    assert_eq!(compiled[7], 0);\n    assert_eq!(compiled[8], 10);\n"]]}
{"hexsha": "1f50e7f1250bee8348568faf50ea5f0cf659fb4b", "ext": "rs", "lang": "Rust", "content": "pub async fn hunt(ctx: &Context, msg: &Message, mut args: Args) -> CommandResult {\n\t// Get the guild ID.\n\tlet guild = match msg.guild(&ctx.cache).await {\n\t\tSome(c) => c.id,\n\t\tNone => {\n\t\t\treturn confused(&ctx, &msg).await;\n\t\t},\n\t};\n\n\tlet gs = {\n\t\tlet data = ctx.data.read().await;\n\t\tArc::clone(data.get::<GuildStates>().unwrap())\n\t};\n\n\t// Turn first arg (hopefully a channel mention) into a real channel\n\tvoicehunt_control(\n\t\t&ctx,\n\t\tguild,\n\t\tmatch args.single::<u64>().ok() {\n\t\t\tSome(c) => {\n\t\t\t\tif let Some(state) = gs.get(&guild) {\n\t\t\t\t\tlet mut lock = state.write().await;\n\t\t\t\t\tlock.set_join(Join::DirectedHunt(ChannelId(c))).await;\n\t\t\t\t}\n\n\t\t\t\tVoiceHuntCommand::DirectedHunt(ChannelId(c))\n\t\t\t},\n\t\t\tNone => {\n\t\t\t\tif let Some(state) = gs.get(&guild) {\n\t\t\t\t\tlet mut lock = state.write().await;\n\t\t\t\t\tlock.set_join(Join::Hunt).await;\n\t\t\t\t}\n\n\t\t\t\tVoiceHuntCommand::BraveHunt\n\t\t\t},\n\t\t},\n\t)\n\t.await;\n\n\tcheck_msg(msg.channel_id.say(&ctx.http, \"Mrowr!\").await);\n\n\tOk(())\n}", "item_id": 0, "repo": "FelixMcFelix/felyne-bot", "file": "src/commands/cat_control.rs", "last_update_at": "2019-07-03T21:45:38+00:00", "question_id": "1f50e7f1250bee8348568faf50ea5f0cf659fb4b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn hunt(ctx: &Context, msg: &Message, mut args: Args) -> CommandResult {\n\t// Get the guild ID.\n\tlet guild = match msg.guild(&ctx.cache).await {\n\t\tSome(c) => c.id,\n\t\tNone => {\n\t\t\treturn confused(&ctx, &msg).await;\n\t\t},\n\t};\n\tlet gs = {\n\t\tlet data = ctx.data.read().await;\n\t\tArc::clone(data.get::<GuildStates>().unwrap())\n\t};\n\t// Turn first arg (hopefully a channel mention) into a real channel\n\tvoicehunt_control(\n\t\t&ctx,\n\t\tguild,\n\t\tmatch args.single::<u64>().ok() {\n\t\t\tSome(c) => {\n\t\t\t\tif let Some(state) = gs.get(&guild) {\n\t\t\t\t\tlet mut lock = state.write().await;\n\t\t\t\t\tlock.set_join(Join::DirectedHunt(ChannelId(c))).await;\n\t\t\t\t}\n\t\t\t\tVoiceHuntCommand::DirectedHunt(ChannelId(c))\n\t\t\t},\n\t\t\tNone => {\n\t\t\t\tif let Some(state) = gs.get(&guild) {\n\t\t\t\t\tlet mut lock = state.write().await;\n\t\t\t\t\tlock.set_join(Join::Hunt).await;\n\t\t\t\t}\n\t\t\t\tVoiceHuntCommand::BraveHunt\n\t\t\t},\n\t\t},\n\t)\n\t.await;\n\tcheck_msg(msg.channel_id.say(&ctx.http, \"Mrowr!\").await);\n\tOk(())\n"]]}
{"hexsha": "8438b4da320daa7bd880a52a633b27dbffeb7f6b", "ext": "rs", "lang": "Rust", "content": "fn test_solc() {\n        let executor = init_executor();\n\n        // Test all_accounts\n        let permission_management = PermissionManagement::new(&executor);\n        let all_accounts: Vec<Address> = permission_management\n            .all_accounts(BlockTag::Tag(Tag::Pending))\n            .unwrap();\n\n        assert_eq!(\n            all_accounts,\n            vec![\n                Address::from_str(DEFAULT_SUPER_ADEMIN).unwrap(),\n                Address::from_str(reserved_addresses::GROUP).unwrap(),\n            ]\n        );\n\n        // Test permissions\n        let super_admin_address = Address::from_str(DEFAULT_SUPER_ADEMIN).unwrap();\n\n        let mut permissions: Vec<Address> = permission_management\n            .permissions(\n                &(H256::from(super_admin_address)),\n                BlockTag::Tag(Tag::Pending),\n            )\n            .unwrap();\n        permissions.sort();\n\n        let mut expected_permissions = vec![\n            Address::from_str(reserved_addresses::PERMISSION_NEW_PERMISSION).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_DELETE_PERMISSION).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_UPDATE_PERMISSION).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_SET_AUTH).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_CANCEL_AUTH).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_NEW_ROLE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_DELETE_ROLE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_UPDATE_ROLE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_SET_ROLE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_CANCEL_ROLE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_NEW_GROUP).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_DELETE_GROUP).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_UPDATE_GROUP).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_SEND_TX).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_CREATE_CONTRACT).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_NEW_NODE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_DELETE_NODE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_UPDATE_NODE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_ACCOUNT_QUOTA).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_BLOCK_QUOTA).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_BATCH_TX).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_EMERGENCY_INTERVENTION).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_QUOTA_PRICE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_VERSION).unwrap(),\n        ];\n        expected_permissions.sort();\n\n        assert_eq!(permissions, expected_permissions);\n\n        // Test account permissions\n        let account_permissions: HashMap<Address, Vec<Resource>> =\n            permission_management.load_account_permissions(BlockTag::Tag(Tag::Pending));\n        assert_eq!(account_permissions.contains_key(&super_admin_address), true);\n\n        let mut resources = (*account_permissions.get(&super_admin_address).unwrap()).clone();\n        resources.sort();\n\n        let mut expected_resources = vec![\n            // newPermission\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(NEW_PERMISSION),\n            },\n            // deletePermission\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_PERMISSION),\n            },\n            // updatePermission\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(ADD_RESOURCES),\n            },\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_RESOURCES),\n            },\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(UPDATE_PERMISSIONNAME),\n            },\n            // setAuth\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(SET_AUTHORIZATION),\n            },\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(SET_AUTHORIZATIONS),\n            },\n            // cancelAuth\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(CANCEL_AUTHORIZATION),\n            },\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(CLEAR_AUTHORIZATION),\n            },\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(CANCEL_AUTHORIZATIONS),\n            },\n            // newRole\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(NEW_ROLE),\n            },\n            // deleteRole\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_ROLE),\n            },\n            // updateRole\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(ADD_PERMISSIONS),\n            },\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_PERMISSIONS),\n            },\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(UPDATE_ROLENAME),\n            },\n            // setRole\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(SET_ROLE),\n            },\n            // cancelRole\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(CANCEL_ROLE),\n            },\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(CLEAR_ROLE),\n            },\n            // newGroup\n            Resource {\n                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(NEW_GROUP),\n            },\n            // deleteGroup\n            Resource {\n                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_GROUP),\n            },\n            // updateGroup\n            Resource {\n                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(ADD_ACCOUNTS),\n            },\n            Resource {\n                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_ACCOUNTS),\n            },\n            Resource {\n                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(UPDATE_GROUPNAME),\n            },\n            // senTx\n            Resource {\n                cont: H160::from_str(reserved_addresses::PERMISSION_SEND_TX).unwrap(),\n                func: vec![0, 0, 0, 0],\n            },\n            // createContract\n            Resource {\n                cont: H160::from_str(reserved_addresses::PERMISSION_CREATE_CONTRACT).unwrap(),\n                func: vec![0, 0, 0, 0],\n            },\n            // approveNode\n            Resource {\n                cont: H160::from_str(reserved_addresses::NODE_MANAGER).unwrap(),\n                func: method_tools::encode_to_vec(APPROVE_NODE),\n            },\n            // deleteNode\n            Resource {\n                cont: H160::from_str(reserved_addresses::NODE_MANAGER).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_NODE),\n            },\n            // setStake\n            Resource {\n                cont: H160::from_str(reserved_addresses::NODE_MANAGER).unwrap(),\n                func: method_tools::encode_to_vec(SET_STAKE),\n            },\n            // defaultAQL\n            Resource {\n                cont: H160::from_str(reserved_addresses::QUOTA_MANAGER).unwrap(),\n                func: method_tools::encode_to_vec(SET_DEFAULTAQL),\n            },\n            // AQL\n            Resource {\n                cont: H160::from_str(reserved_addresses::QUOTA_MANAGER).unwrap(),\n                func: method_tools::encode_to_vec(SET_AQL),\n            },\n            // BQL\n            Resource {\n                cont: H160::from_str(reserved_addresses::QUOTA_MANAGER).unwrap(),\n                func: method_tools::encode_to_vec(SET_BQL),\n            },\n            // batchTx\n            Resource {\n                cont: H160::from_str(reserved_addresses::BATCH_TX).unwrap(),\n                func: method_tools::encode_to_vec(MULTI_TXS),\n            },\n            // emergencyIntervention\n            Resource {\n                cont: H160::from_str(reserved_addresses::EMERGENCY_INTERVENTION).unwrap(),\n                func: method_tools::encode_to_vec(SET_STATE),\n            },\n            // quotaPrice\n            Resource {\n                cont: H160::from_str(reserved_addresses::PRICE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(SET_QUOTA_PRICE),\n            },\n            // setVersion(Will deprecated)\n            Resource {\n                cont: H160::from_str(reserved_addresses::VERSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(SET_VERSION),\n            },\n            // setProtocolVersion\n            Resource {\n                cont: H160::from_str(reserved_addresses::VERSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(SET_PROTOCOL_VERSION),\n            },\n        ];\n        expected_resources.sort();\n\n        assert_eq!(resources, expected_resources);\n    }", "item_id": 1, "repo": "baajur/cita", "file": "cita-executor/core/src/contracts/solc/permission_management.rs", "last_update_at": "2019-11-26T10:07:48+00:00", "question_id": "8438b4da320daa7bd880a52a633b27dbffeb7f6b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_solc() {\n        let executor = init_executor();\n        // Test all_accounts\n        let permission_management = PermissionManagement::new(&executor);\n        let all_accounts: Vec<Address> = permission_management\n            .all_accounts(BlockTag::Tag(Tag::Pending))\n            .unwrap();\n        assert_eq!(\n            all_accounts,\n            vec![\n                Address::from_str(DEFAULT_SUPER_ADEMIN).unwrap(),\n                Address::from_str(reserved_addresses::GROUP).unwrap(),\n            ]\n        );\n        // Test permissions\n        let super_admin_address = Address::from_str(DEFAULT_SUPER_ADEMIN).unwrap();\n        let mut permissions: Vec<Address> = permission_management\n            .permissions(\n                &(H256::from(super_admin_address)),\n                BlockTag::Tag(Tag::Pending),\n            )\n            .unwrap();\n        permissions.sort();\n        let mut expected_permissions = vec![\n            Address::from_str(reserved_addresses::PERMISSION_NEW_PERMISSION).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_DELETE_PERMISSION).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_UPDATE_PERMISSION).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_SET_AUTH).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_CANCEL_AUTH).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_NEW_ROLE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_DELETE_ROLE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_UPDATE_ROLE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_SET_ROLE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_CANCEL_ROLE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_NEW_GROUP).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_DELETE_GROUP).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_UPDATE_GROUP).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_SEND_TX).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_CREATE_CONTRACT).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_NEW_NODE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_DELETE_NODE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_UPDATE_NODE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_ACCOUNT_QUOTA).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_BLOCK_QUOTA).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_BATCH_TX).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_EMERGENCY_INTERVENTION).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_QUOTA_PRICE).unwrap(),\n            Address::from_str(reserved_addresses::PERMISSION_VERSION).unwrap(),\n        ];\n        expected_permissions.sort();\n        assert_eq!(permissions, expected_permissions);\n        // Test account permissions\n        let account_permissions: HashMap<Address, Vec<Resource>> =\n            permission_management.load_account_permissions(BlockTag::Tag(Tag::Pending));\n        assert_eq!(account_permissions.contains_key(&super_admin_address), true);\n        let mut resources = (*account_permissions.get(&super_admin_address).unwrap()).clone();\n        resources.sort();\n        let mut expected_resources = vec![\n            // newPermission\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(NEW_PERMISSION),\n            },\n            // deletePermission\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_PERMISSION),\n            },\n            // updatePermission\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(ADD_RESOURCES),\n            },\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_RESOURCES),\n            },\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(UPDATE_PERMISSIONNAME),\n            },\n            // setAuth\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(SET_AUTHORIZATION),\n            },\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(SET_AUTHORIZATIONS),\n            },\n            // cancelAuth\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(CANCEL_AUTHORIZATION),\n            },\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(CLEAR_AUTHORIZATION),\n            },\n            Resource {\n                cont: Address::from_str(reserved_addresses::PERMISSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(CANCEL_AUTHORIZATIONS),\n            },\n            // newRole\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(NEW_ROLE),\n            },\n            // deleteRole\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_ROLE),\n            },\n            // updateRole\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(ADD_PERMISSIONS),\n            },\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_PERMISSIONS),\n            },\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(UPDATE_ROLENAME),\n            },\n            // setRole\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(SET_ROLE),\n            },\n            // cancelRole\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(CANCEL_ROLE),\n            },\n            Resource {\n                cont: H160::from_str(reserved_addresses::ROLE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(CLEAR_ROLE),\n            },\n            // newGroup\n            Resource {\n                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(NEW_GROUP),\n            },\n            // deleteGroup\n            Resource {\n                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_GROUP),\n            },\n            // updateGroup\n            Resource {\n                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(ADD_ACCOUNTS),\n            },\n            Resource {\n                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_ACCOUNTS),\n            },\n            Resource {\n                cont: H160::from_str(reserved_addresses::GROUP_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(UPDATE_GROUPNAME),\n            },\n            // senTx\n            Resource {\n                cont: H160::from_str(reserved_addresses::PERMISSION_SEND_TX).unwrap(),\n                func: vec![0, 0, 0, 0],\n            },\n            // createContract\n            Resource {\n                cont: H160::from_str(reserved_addresses::PERMISSION_CREATE_CONTRACT).unwrap(),\n                func: vec![0, 0, 0, 0],\n            },\n            // approveNode\n            Resource {\n                cont: H160::from_str(reserved_addresses::NODE_MANAGER).unwrap(),\n                func: method_tools::encode_to_vec(APPROVE_NODE),\n            },\n            // deleteNode\n            Resource {\n                cont: H160::from_str(reserved_addresses::NODE_MANAGER).unwrap(),\n                func: method_tools::encode_to_vec(DELETE_NODE),\n            },\n            // setStake\n            Resource {\n                cont: H160::from_str(reserved_addresses::NODE_MANAGER).unwrap(),\n                func: method_tools::encode_to_vec(SET_STAKE),\n            },\n            // defaultAQL\n            Resource {\n                cont: H160::from_str(reserved_addresses::QUOTA_MANAGER).unwrap(),\n                func: method_tools::encode_to_vec(SET_DEFAULTAQL),\n            },\n            // AQL\n            Resource {\n                cont: H160::from_str(reserved_addresses::QUOTA_MANAGER).unwrap(),\n                func: method_tools::encode_to_vec(SET_AQL),\n            },\n            // BQL\n            Resource {\n                cont: H160::from_str(reserved_addresses::QUOTA_MANAGER).unwrap(),\n                func: method_tools::encode_to_vec(SET_BQL),\n            },\n            // batchTx\n            Resource {\n                cont: H160::from_str(reserved_addresses::BATCH_TX).unwrap(),\n                func: method_tools::encode_to_vec(MULTI_TXS),\n            },\n            // emergencyIntervention\n            Resource {\n                cont: H160::from_str(reserved_addresses::EMERGENCY_INTERVENTION).unwrap(),\n                func: method_tools::encode_to_vec(SET_STATE),\n            },\n            // quotaPrice\n            Resource {\n                cont: H160::from_str(reserved_addresses::PRICE_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(SET_QUOTA_PRICE),\n            },\n            // setVersion(Will deprecated)\n            Resource {\n                cont: H160::from_str(reserved_addresses::VERSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(SET_VERSION),\n            },\n            // setProtocolVersion\n            Resource {\n                cont: H160::from_str(reserved_addresses::VERSION_MANAGEMENT).unwrap(),\n                func: method_tools::encode_to_vec(SET_PROTOCOL_VERSION),\n            },\n        ];\n        expected_resources.sort();\n        assert_eq!(resources, expected_resources);\n"]]}
{"hexsha": "aaa085a889c7cc296732b54441d7e7fec703a8f8", "ext": "rs", "lang": "Rust", "content": "fn skip_bom(mut reader: BufReader<File>) -> Result<BufReader<File>> {\n    let buf = reader.fill_buf()?;\n    if buf.len() >= 3 && buf[0] == 0xEF && buf[1] == 0xBB && buf[2] == 0xBF {\n        reader.read_exact(&mut [0; 3])?;\n    }\n    Ok(reader)\n}", "item_id": 0, "repo": "pascalgn/azi", "file": "src/utils.rs", "last_update_at": "2019-07-21T14:38:40+00:00", "question_id": "aaa085a889c7cc296732b54441d7e7fec703a8f8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn skip_bom(mut reader: BufReader<File>) -> Result<BufReader<File>> {\n    let buf = reader.fill_buf()?;\n    if buf.len() >= 3 && buf[0] == 0xEF && buf[1] == 0xBB && buf[2] == 0xBF {\n        reader.read_exact(&mut [0; 3])?;\n    }\n    Ok(reader)\n"]]}
{"hexsha": "12f79b4c00c01abedbe5232c1bedeba5410c64f4", "ext": "rs", "lang": "Rust", "content": "pub fn matrix_macro_empty_mat() {\n    let mat: Matrix<f64> = matrix![];\n\n    assert_eq!(0, mat.rows());\n    assert_eq!(0, mat.cols());\n}", "item_id": 1, "repo": "mesalock-linux/rulinalg-sgx", "file": "sgx/rulinalg-sgx-test/enclave/src/macros/matrix.rs", "last_update_at": "2019-08-22T16:34:34+00:00", "question_id": "12f79b4c00c01abedbe5232c1bedeba5410c64f4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn matrix_macro_empty_mat() {\n    let mat: Matrix<f64> = matrix![];\n    assert_eq!(0, mat.rows());\n    assert_eq!(0, mat.cols());\n"]]}
{"hexsha": "63184879b73d4e89a77a8104511ad617cb023a5a", "ext": "rs", "lang": "Rust", "content": "fn wrapping_sub_generation() {\n        let zero = Generation::zero();\n\n        for i in 1..20 {\n            assert_eq!(zero.wrapping_sub(i), Generation::from(128 - i));\n        }\n        assert_eq!(zero.wrapping_sub(1), Generation::from(127));\n        assert_eq!(zero.wrapping_sub(2), Generation::from(126));\n        assert_eq!(zero.wrapping_sub(3), Generation::from(125));\n\n        let one = zero.wrapping_increment();\n        assert_eq!(one, Generation::from(1));\n\n        for i in 2..20 {\n            assert_eq!(one.wrapping_sub(i), Generation::from(128 - i + 1));\n        }\n        assert_eq!(one.wrapping_sub(1), Generation::from(0));\n        assert_eq!(one.wrapping_sub(2), Generation::from(127));\n        assert_eq!(one.wrapping_sub(3), Generation::from(126));\n\n        let two = one.wrapping_increment();\n        assert_eq!(two, Generation::from(2));\n\n        for i in 3..20 {\n            assert_eq!(two.wrapping_sub(i), Generation::from(128 - i + 2));\n        }\n        assert_eq!(two.wrapping_sub(1), Generation::from(1));\n        assert_eq!(two.wrapping_sub(2), Generation::from(0));\n        assert_eq!(two.wrapping_sub(3), Generation::from(127));\n        assert_eq!(two.wrapping_sub(4), Generation::from(126));\n\n        let n = Generation::from(127);\n\n        for i in 0..20 {\n            assert_eq!(n.wrapping_sub(i), Generation::from(127 - i));\n        }\n    }", "item_id": 2, "repo": "simplestaking/tezos-rs", "file": "tezos/context/src/gc/worker.rs", "last_update_at": "2019-10-25T18:40:15+00:00", "question_id": "63184879b73d4e89a77a8104511ad617cb023a5a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn wrapping_sub_generation() {\n        let zero = Generation::zero();\n        for i in 1..20 {\n            assert_eq!(zero.wrapping_sub(i), Generation::from(128 - i));\n        }\n        assert_eq!(zero.wrapping_sub(1), Generation::from(127));\n        assert_eq!(zero.wrapping_sub(2), Generation::from(126));\n        assert_eq!(zero.wrapping_sub(3), Generation::from(125));\n        let one = zero.wrapping_increment();\n        assert_eq!(one, Generation::from(1));\n        for i in 2..20 {\n            assert_eq!(one.wrapping_sub(i), Generation::from(128 - i + 1));\n        }\n        assert_eq!(one.wrapping_sub(1), Generation::from(0));\n        assert_eq!(one.wrapping_sub(2), Generation::from(127));\n        assert_eq!(one.wrapping_sub(3), Generation::from(126));\n        let two = one.wrapping_increment();\n        assert_eq!(two, Generation::from(2));\n        for i in 3..20 {\n            assert_eq!(two.wrapping_sub(i), Generation::from(128 - i + 2));\n        }\n        assert_eq!(two.wrapping_sub(1), Generation::from(1));\n        assert_eq!(two.wrapping_sub(2), Generation::from(0));\n        assert_eq!(two.wrapping_sub(3), Generation::from(127));\n        assert_eq!(two.wrapping_sub(4), Generation::from(126));\n        let n = Generation::from(127);\n        for i in 0..20 {\n            assert_eq!(n.wrapping_sub(i), Generation::from(127 - i));\n        }\n"]]}
{"hexsha": "ce8a5b1822c93fa2108de6f1558fa5e22a6dc46f", "ext": "rs", "lang": "Rust", "content": "fn table_exists_test() {\n        let log_context = \"table_exists_test\";\n\n        tracer(&log_context, \"fixtures\");\n        let local_client = local_client();\n        let table_name = table_name_fresh();\n        let key_schema = key_schema_a();\n        let attribute_definitions = attribute_definitions_a();\n\n        // not exists\n        assert!(!table_exists(&log_context, &local_client, &table_name)\n            .expect(\"could not check if table exists\"));\n\n        // ensure table\n        match ensure_table(\n            &log_context,\n            &local_client,\n            &table_name,\n            &key_schema,\n            &attribute_definitions,\n        ) {\n            Ok(_) => {}\n            Err(err) => panic!(\"{:?}\", err),\n        };\n\n        // exists\n        assert!(table_exists(&log_context, &local_client, &table_name)\n            .expect(\"could not check if table exists\"));\n\n        // delete\n        assert!(delete_table(&log_context, &local_client, &table_name).is_ok());\n\n        // not exists\n        assert!(!table_exists(&log_context, &local_client, &table_name)\n            .expect(\"could not check if table exists\"));\n    }", "item_id": 1, "repo": "jamesray1/sim1h", "file": "crates/sim1h/src/dht/bbdht/dynamodb/api/table/exist.rs", "last_update_at": "2019-10-15T07:05:39+00:00", "question_id": "ce8a5b1822c93fa2108de6f1558fa5e22a6dc46f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn table_exists_test() {\n        let log_context = \"table_exists_test\";\n        tracer(&log_context, \"fixtures\");\n        let local_client = local_client();\n        let table_name = table_name_fresh();\n        let key_schema = key_schema_a();\n        let attribute_definitions = attribute_definitions_a();\n        // not exists\n        assert!(!table_exists(&log_context, &local_client, &table_name)\n            .expect(\"could not check if table exists\"));\n        // ensure table\n        match ensure_table(\n            &log_context,\n            &local_client,\n            &table_name,\n            &key_schema,\n            &attribute_definitions,\n        ) {\n            Ok(_) => {}\n            Err(err) => panic!(\"{:?}\", err),\n        };\n        // exists\n        assert!(table_exists(&log_context, &local_client, &table_name)\n            .expect(\"could not check if table exists\"));\n        // delete\n        assert!(delete_table(&log_context, &local_client, &table_name).is_ok());\n        // not exists\n        assert!(!table_exists(&log_context, &local_client, &table_name)\n            .expect(\"could not check if table exists\"));\n"]]}
{"hexsha": "52855b44587cc0959d108f7862ad0b3b277606e9", "ext": "rs", "lang": "Rust", "content": "fn nop() {\n    let uni_orig = universe();\n    let (mut memory, mut ports, mut registers, mut pc, mut sp, mut adr, mut ins) = universe();\n    let mut stack = vec![];\n\n    assert_eq!(MicroOp::Nop.perform(&mut stack, &mut memory, &mut ports, &mut registers, &mut pc, &mut sp, &mut adr, &mut ins),\n               Ok(true));\n\n    assert_eq!((memory, ports, registers, pc, sp, adr, ins), uni_orig);\n\n    assert_eq!(stack, vec![]);\n}", "item_id": 0, "repo": "nabijaczleweli/pir-8-emu.deb", "file": "tests/micro/perform/ok/mod.rs", "last_update_at": "2019-08-17T16:09:47+00:00", "question_id": "52855b44587cc0959d108f7862ad0b3b277606e9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn nop() {\n    let uni_orig = universe();\n    let (mut memory, mut ports, mut registers, mut pc, mut sp, mut adr, mut ins) = universe();\n    let mut stack = vec![];\n    assert_eq!(MicroOp::Nop.perform(&mut stack, &mut memory, &mut ports, &mut registers, &mut pc, &mut sp, &mut adr, &mut ins),\n               Ok(true));\n    assert_eq!((memory, ports, registers, pc, sp, adr, ins), uni_orig);\n    assert_eq!(stack, vec![]);\n"]]}
{"hexsha": "000b92362b685d3dc681038680bd5f4b70ad0463", "ext": "rs", "lang": "Rust", "content": "fn assert_contracts() {\n        let (_, _r) = crate::unbounded::<i32>(Duration::from_millis(100));\n\n        assert_send::<Receiver<i32>>();\n        assert_sync::<Receiver<i32>>();\n    }", "item_id": 0, "repo": "dbcfd/channel-async", "file": "src/receiver.rs", "last_update_at": "2019-11-14T13:20:27+00:00", "question_id": "000b92362b685d3dc681038680bd5f4b70ad0463_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn assert_contracts() {\n        let (_, _r) = crate::unbounded::<i32>(Duration::from_millis(100));\n        assert_send::<Receiver<i32>>();\n        assert_sync::<Receiver<i32>>();\n"]]}
{"hexsha": "3644b9a5c5feb3422d0fbcbee5941eff000fc54e", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut client = ClientBuilder::new(CONNECTION)\n        .expect(\"address parse fail\")\n        .connect(None)\n        .expect(\"connect failed\");\n\n    println!(\"{:?}\", client.recv_message());\n\n    client\n        .send_message(&Message::close())\n        .expect(\"failed to close connection\");\n}", "item_id": 0, "repo": "sebasv/pokerroom", "file": "src/bin/test-con.rs", "last_update_at": "2019-09-25T08:53:02+00:00", "question_id": "3644b9a5c5feb3422d0fbcbee5941eff000fc54e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let mut client = ClientBuilder::new(CONNECTION)\n        .expect(\"address parse fail\")\n        .connect(None)\n        .expect(\"connect failed\");\n    println!(\"{:?}\", client.recv_message());\n    client\n        .send_message(&Message::close())\n        .expect(\"failed to close connection\");\n"]]}
{"hexsha": "8dfe4a1dd336f402669a8a09515a1398934f5b0e", "ext": "rs", "lang": "Rust", "content": "fn challenge5() -> errors::Result<()> {\n  let expected = from_hex_string(\"0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f\")?;\n\n  let input_string = b\"Burning 'em, if you ain't quick and nimble\\nI go crazy when I hear a cymbal\";\n  let key = b\"ICE\";\n  let actual = encrypt_repeating_key(input_string, key);\n\n  println!(\"expected : {}\", to_hex_string(&expected));\n  println!(\"actual   : {}\", to_hex_string(&actual));\n\n  assert_eq!(expected, actual);\n\n  Ok(())\n}", "item_id": 4, "repo": "dat2/cryptopals-rust", "file": "src/main.rs", "last_update_at": "2019-07-29T15:36:48+00:00", "question_id": "8dfe4a1dd336f402669a8a09515a1398934f5b0e_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn challenge5() -> errors::Result<()> {\n  let expected = from_hex_string(\"0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f\")?;\n  let input_string = b\"Burning 'em, if you ain't quick and nimble\\nI go crazy when I hear a cymbal\";\n  let key = b\"ICE\";\n  let actual = encrypt_repeating_key(input_string, key);\n  println!(\"expected : {}\", to_hex_string(&expected));\n  println!(\"actual   : {}\", to_hex_string(&actual));\n  assert_eq!(expected, actual);\n  Ok(())\n"]]}
{"hexsha": "3d9c204ab5e87806b487b1e18376ede4b321b8a6", "ext": "rs", "lang": "Rust", "content": "pub fn find_best_release(\n    data: &[WarehouseRelease],\n    name: &str,\n    version: &Version,\n    os: Os,\n    python_vers: &Version,\n) -> (WarehouseRelease, PackageType) {\n    // Find which release we should download. Preferably wheels, and if so, for the right OS and\n    // Python version.\n    let mut compatible_releases = vec![];\n    // Store source releases as a fallback, for if no wheels are found.\n    let mut source_releases = vec![];\n\n    for rel in data.iter() {\n        let mut compatible = true;\n        match rel.packagetype.as_ref() {\n            \"bdist_wheel\" => {\n                // Now determine if this wheel is appropriate for the Os and Python version.\n                if let Some(py_ver) = &rel.requires_python {\n                    // If a version constraint exists, make sure it's compatible.\n                    let py_constrs = Constraint::from_str_multiple(py_ver)\n                        .expect(\"Problem parsing constraint from requires_python\");\n\n                    for constr in &py_constrs {\n                        if !constr.is_compatible(python_vers) {\n                            compatible = false;\n                        }\n                    }\n                }\n\n                let wheel_os =\n                    os_from_wheel_fname(&rel.filename).expect(\"Problem getting os from wheel name\");\n                if wheel_os != os && wheel_os != Os::Any {\n                    compatible = false;\n                }\n\n                // Packages that use C code(eg numpy) may fail to load C extensions if installing\n                // for the wrong version of python (eg  cp35 when python 3.7 is installed), even\n                // if `requires_python` doesn't indicate an incompatibility. Check `python_version`\n                // instead of `requires_python`.\n                // Note that the result of this parse is an any match.\n                if let Ok(constrs) = Constraint::from_wh_py_vers(&rel.python_version) {\n                    let mut compat_py_v = false;\n                    for constr in &constrs {\n                        if constr.is_compatible(python_vers) {\n                            compat_py_v = true;\n                        }\n                    }\n                    if !compat_py_v {\n                        compatible = false;\n                    }\n                } else {\n                    println!(\n                        \"Unable to match python version from python_version: {}\",\n                        &rel.python_version\n                    )\n                };\n\n                if compatible {\n                    compatible_releases.push(rel.clone());\n                }\n            }\n            \"sdist\" => source_releases.push(rel.clone()),\n            \"bdist_wininst\" | \"bdist_msi\" | \"bdist_egg\" => (), // Don't execute Windows installers\n            _ => {\n                println!(\"Found surprising package type: {}\", rel.packagetype);\n                continue;\n            }\n        }\n    }\n\n    let best_release;\n    let package_type;\n    // todo: Sort further / try to match exact python_version if able.\n    if compatible_releases.is_empty() {\n        if source_releases.is_empty() {\n            abort(&format!(\n                \"Unable to find a compatible release for {}: {}\",\n                name,\n                version.to_string_color()\n            ))\n        } else {\n            best_release = source_releases[0].clone();\n            package_type = install::PackageType::Source;\n        }\n    } else {\n        best_release = compatible_releases[0].clone();\n        package_type = install::PackageType::Wheel;\n    }\n\n    (best_release, package_type)\n}", "item_id": 11, "repo": "sthagen/David-OConnor-pyflow", "file": "src/util/mod.rs", "last_update_at": "2019-09-11T09:22:37+00:00", "question_id": "3d9c204ab5e87806b487b1e18376ede4b321b8a6_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn find_best_release(\n    data: &[WarehouseRelease],\n    name: &str,\n    version: &Version,\n    os: Os,\n    python_vers: &Version,\n) -> (WarehouseRelease, PackageType) {\n    // Find which release we should download. Preferably wheels, and if so, for the right OS and\n    // Python version.\n    let mut compatible_releases = vec![];\n    // Store source releases as a fallback, for if no wheels are found.\n    let mut source_releases = vec![];\n    for rel in data.iter() {\n        let mut compatible = true;\n        match rel.packagetype.as_ref() {\n            \"bdist_wheel\" => {\n                // Now determine if this wheel is appropriate for the Os and Python version.\n                if let Some(py_ver) = &rel.requires_python {\n                    // If a version constraint exists, make sure it's compatible.\n                    let py_constrs = Constraint::from_str_multiple(py_ver)\n                        .expect(\"Problem parsing constraint from requires_python\");\n                    for constr in &py_constrs {\n                        if !constr.is_compatible(python_vers) {\n                            compatible = false;\n                        }\n                    }\n                }\n                let wheel_os =\n                    os_from_wheel_fname(&rel.filename).expect(\"Problem getting os from wheel name\");\n                if wheel_os != os && wheel_os != Os::Any {\n                    compatible = false;\n                }\n                // Packages that use C code(eg numpy) may fail to load C extensions if installing\n                // for the wrong version of python (eg  cp35 when python 3.7 is installed), even\n                // if `requires_python` doesn't indicate an incompatibility. Check `python_version`\n                // instead of `requires_python`.\n                // Note that the result of this parse is an any match.\n                if let Ok(constrs) = Constraint::from_wh_py_vers(&rel.python_version) {\n                    let mut compat_py_v = false;\n                    for constr in &constrs {\n                        if constr.is_compatible(python_vers) {\n                            compat_py_v = true;\n                        }\n                    }\n                    if !compat_py_v {\n                        compatible = false;\n                    }\n                } else {\n                    println!(\n                        \"Unable to match python version from python_version: {}\",\n                        &rel.python_version\n                    )\n                };\n                if compatible {\n                    compatible_releases.push(rel.clone());\n                }\n            }\n            \"sdist\" => source_releases.push(rel.clone()),\n            \"bdist_wininst\" | \"bdist_msi\" | \"bdist_egg\" => (), // Don't execute Windows installers\n            _ => {\n                println!(\"Found surprising package type: {}\", rel.packagetype);\n                continue;\n            }\n        }\n    }\n    let best_release;\n    let package_type;\n    // todo: Sort further / try to match exact python_version if able.\n    if compatible_releases.is_empty() {\n        if source_releases.is_empty() {\n            abort(&format!(\n                \"Unable to find a compatible release for {}: {}\",\n                name,\n                version.to_string_color()\n            ))\n        } else {\n            best_release = source_releases[0].clone();\n            package_type = install::PackageType::Source;\n        }\n    } else {\n        best_release = compatible_releases[0].clone();\n        package_type = install::PackageType::Wheel;\n    }\n    (best_release, package_type)\n"]]}
{"hexsha": "094ea5430fdb1987e60e6113a2a2d2007ad90c51", "ext": "rs", "lang": "Rust", "content": "fn test_python_matches() {\n        let python = Python {\n            location: String::new(),\n            version: (1, 2, 3),\n            order: 0,\n        };\n        assert!(python.matches(&Major(1)));\n        assert!(python.matches(&Minor(1, 2)));\n        assert!(!python.matches(&Major(2)));\n        assert!(!python.matches(&Minor(2, 2)));\n    }", "item_id": 5, "repo": "uranusjr/pylauncher-posix", "file": "src/pythons.rs", "last_update_at": "2019-03-07T20:21:05+00:00", "question_id": "094ea5430fdb1987e60e6113a2a2d2007ad90c51_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_python_matches() {\n        let python = Python {\n            location: String::new(),\n            version: (1, 2, 3),\n            order: 0,\n        };\n        assert!(python.matches(&Major(1)));\n        assert!(python.matches(&Minor(1, 2)));\n        assert!(!python.matches(&Major(2)));\n        assert!(!python.matches(&Minor(2, 2)));\n"]]}
{"hexsha": "81b12bb3bff77651943ad50a3c36a227c2851fc6", "ext": "rs", "lang": "Rust", "content": "pub unsafe extern fn kstart_ap(args_ptr: *const KernelArgsAp) -> ! {\n    let cpu_id = {\n        let args = &*args_ptr;\n        let cpu_id = args.cpu_id as usize;\n        let bsp_table = args.page_table as usize;\n        let stack_start = args.stack_start as usize;\n        let stack_end = args.stack_end as usize;\n\n        assert_eq!(BSS_TEST_ZERO, 0);\n        assert_eq!(DATA_TEST_NONZERO, 0xFFFF_FFFF_FFFF_FFFF);\n\n        // Set up GDT before paging\n        gdt::init();\n\n        // Set up IDT before paging\n        idt::init();\n\n        // Initialize paging\n        let tcb_offset = paging::init_ap(cpu_id, bsp_table, stack_start, stack_end);\n\n        // Set up GDT with TLS\n        gdt::init_paging(tcb_offset, stack_end);\n\n        // Set up IDT for AP\n        idt::init_paging();\n\n        // Test tdata and tbss\n        {\n            assert_eq!(TBSS_TEST_ZERO, 0);\n            TBSS_TEST_ZERO += 1;\n            assert_eq!(TBSS_TEST_ZERO, 1);\n            assert_eq!(TDATA_TEST_NONZERO, 0xFFFF_FFFF_FFFF_FFFF);\n            TDATA_TEST_NONZERO -= 1;\n            assert_eq!(TDATA_TEST_NONZERO, 0xFFFF_FFFF_FFFF_FFFE);\n        }\n\n        // Initialize devices (for AP)\n        device::init_ap();\n\n        AP_READY.store(true, Ordering::SeqCst);\n\n        cpu_id\n    };\n\n    while ! BSP_READY.load(Ordering::SeqCst) {\n        interrupt::pause();\n    }\n\n    ::kmain_ap(cpu_id);\n}", "item_id": 0, "repo": "phil-opp/kernel", "file": "src/arch/x86_64/start.rs", "last_update_at": "2019-07-07T22:49:30+00:00", "question_id": "81b12bb3bff77651943ad50a3c36a227c2851fc6_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe extern fn kstart_ap(args_ptr: *const KernelArgsAp) -> ! {\n    let cpu_id = {\n        let args = &*args_ptr;\n        let cpu_id = args.cpu_id as usize;\n        let bsp_table = args.page_table as usize;\n        let stack_start = args.stack_start as usize;\n        let stack_end = args.stack_end as usize;\n        assert_eq!(BSS_TEST_ZERO, 0);\n        assert_eq!(DATA_TEST_NONZERO, 0xFFFF_FFFF_FFFF_FFFF);\n        // Set up GDT before paging\n        gdt::init();\n        // Set up IDT before paging\n        idt::init();\n        // Initialize paging\n        let tcb_offset = paging::init_ap(cpu_id, bsp_table, stack_start, stack_end);\n        // Set up GDT with TLS\n        gdt::init_paging(tcb_offset, stack_end);\n        // Set up IDT for AP\n        idt::init_paging();\n        // Test tdata and tbss\n        {\n            assert_eq!(TBSS_TEST_ZERO, 0);\n            TBSS_TEST_ZERO += 1;\n            assert_eq!(TBSS_TEST_ZERO, 1);\n            assert_eq!(TDATA_TEST_NONZERO, 0xFFFF_FFFF_FFFF_FFFF);\n            TDATA_TEST_NONZERO -= 1;\n            assert_eq!(TDATA_TEST_NONZERO, 0xFFFF_FFFF_FFFF_FFFE);\n        }\n        // Initialize devices (for AP)\n        device::init_ap();\n        AP_READY.store(true, Ordering::SeqCst);\n        cpu_id\n    };\n    while ! BSP_READY.load(Ordering::SeqCst) {\n        interrupt::pause();\n    }\n    ::kmain_ap(cpu_id);\n"]]}
{"hexsha": "c416d347d6b9c6efb4a793877160b912b93a0fef", "ext": "rs", "lang": "Rust", "content": "fn poll_until_sync(&mut self) -> Async<()> {\n\t\tself.poll();\n\n\t\t// Return `NotReady` if there's a mismatch in the highest block number.\n\t\tlet mut highest = None;\n\t\tfor peer in self.peers().iter() {\n\t\t\tmatch (highest, peer.client.info().chain.best_number) {\n\t\t\t\t(None, b) => highest = Some(b),\n\t\t\t\t(Some(ref a), ref b) if a == b => {},\n\t\t\t\t(Some(_), _) => return Async::NotReady,\n\t\t\t}\n\t\t}\n\t\tAsync::Ready(())\n\t}", "item_id": 3, "repo": "HPIPS/HPIPS_Chain", "file": "core/network/src/test/mod.rs", "last_update_at": "2019-08-07T10:22:08+00:00", "question_id": "c416d347d6b9c6efb4a793877160b912b93a0fef_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn poll_until_sync(&mut self) -> Async<()> {\n\t\tself.poll();\n\t\t// Return `NotReady` if there's a mismatch in the highest block number.\n\t\tlet mut highest = None;\n\t\tfor peer in self.peers().iter() {\n\t\t\tmatch (highest, peer.client.info().chain.best_number) {\n\t\t\t\t(None, b) => highest = Some(b),\n\t\t\t\t(Some(ref a), ref b) if a == b => {},\n\t\t\t\t(Some(_), _) => return Async::NotReady,\n\t\t\t}\n\t\t}\n\t\tAsync::Ready(())\n"]]}
{"hexsha": "5c449da2b98037d891558adc36493ab6f1016c1a", "ext": "rs", "lang": "Rust", "content": "fn returns_err() {\n                let value = \"value\";\n                let mut args = args!(Occur::Multi, None);\n                args.parse(&vec!(\"-o\", \"0\", \"-o\", value));\n\n                assert!(args.values_of::<i32>(\"option\").is_err());\n            }", "item_id": 22, "repo": "Dalvany/args", "file": "src/tst/mod.rs", "last_update_at": "2019-10-16T07:45:52+00:00", "question_id": "5c449da2b98037d891558adc36493ab6f1016c1a_22", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn returns_err() {\n                let value = \"value\";\n                let mut args = args!(Occur::Multi, None);\n                args.parse(&vec!(\"-o\", \"0\", \"-o\", value));\n                assert!(args.values_of::<i32>(\"option\").is_err());\n"]]}
{"hexsha": "19ceb2daabf7e79eee4b2c2210bf2643a08eb52c", "ext": "rs", "lang": "Rust", "content": "pub fn files<'a>(args: &ArgMatches<'a>) -> Result<LogStream, Error> {\n    let files = args\n        .values_of(\"input\")\n        .ok_or_else(|| err_msg(\"Missing input argument\"))?\n        .map(PathBuf::from)\n        .collect::<Vec<PathBuf>>();\n\n    let f = iter_ok::<_, Error>(files)\n        .map(|f| {\n            File::open(f.clone())\n                .map(|s| Decoder::framed(LossyLinesCodec::new(), s))\n                .flatten_stream()\n                .map(StreamData::Line)\n                .map_err(move |e| format_err!(\"Failed to open {}: {}\", f.display(), e))\n        })\n        .flatten();\n\n    Ok(Box::new(f))\n}", "item_id": 0, "repo": "wngr/rogcat", "file": "src/reader.rs", "last_update_at": "2019-12-12T09:15:29+00:00", "question_id": "19ceb2daabf7e79eee4b2c2210bf2643a08eb52c_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn files<'a>(args: &ArgMatches<'a>) -> Result<LogStream, Error> {\n    let files = args\n        .values_of(\"input\")\n        .ok_or_else(|| err_msg(\"Missing input argument\"))?\n        .map(PathBuf::from)\n        .collect::<Vec<PathBuf>>();\n    let f = iter_ok::<_, Error>(files)\n        .map(|f| {\n            File::open(f.clone())\n                .map(|s| Decoder::framed(LossyLinesCodec::new(), s))\n                .flatten_stream()\n                .map(StreamData::Line)\n                .map_err(move |e| format_err!(\"Failed to open {}: {}\", f.display(), e))\n        })\n        .flatten();\n    Ok(Box::new(f))\n"]]}
{"hexsha": "a4d9a79eb9bbafb3fe8f46e3f83c8a2712f51b1b", "ext": "rs", "lang": "Rust", "content": "fn hit_with_location(input: &str) -> IResult<&str, PlayModifier> {\n    let (input, hit_type) = alt((\n        value(HitType::PopFly, tag(\"P\")),\n        value(HitType::PopUpBunt, tag(\"BP\")),\n        value(HitType::Fly, tag(\"F\")),\n        value(HitType::GroundBall, tag(\"G\")),\n        value(HitType::GroundBallBunt, tag(\"BG\")),\n        value(HitType::LineDrive, tag(\"L\")),\n    ))(input)?;\n    let (input, hit_location) = opt(hit_location)(input)?;\n    Ok((input, PlayModifier::HitWithLocation(hit_type, hit_location)))\n}", "item_id": 7, "repo": "eugene-bulkin/retrosheet-rs", "file": "src/parsers.rs", "last_update_at": "2019-11-27T04:32:55+00:00", "question_id": "a4d9a79eb9bbafb3fe8f46e3f83c8a2712f51b1b_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn hit_with_location(input: &str) -> IResult<&str, PlayModifier> {\n    let (input, hit_type) = alt((\n        value(HitType::PopFly, tag(\"P\")),\n        value(HitType::PopUpBunt, tag(\"BP\")),\n        value(HitType::Fly, tag(\"F\")),\n        value(HitType::GroundBall, tag(\"G\")),\n        value(HitType::GroundBallBunt, tag(\"BG\")),\n        value(HitType::LineDrive, tag(\"L\")),\n    ))(input)?;\n    let (input, hit_location) = opt(hit_location)(input)?;\n    Ok((input, PlayModifier::HitWithLocation(hit_type, hit_location)))\n"]]}
{"hexsha": "63c03229343ca2d9c2ae27790dbf3c681fde5aad", "ext": "rs", "lang": "Rust", "content": "fn test_parse_comment_two_spaces() {\n    SETUP_READER!(\n        reader,\n        \" //  Hello world\n //  Ciao mondo\"\n    );\n\n    assert_eq!(reader.lines.len(), 2);\n\n    assert_eq!(reader.lines[0].type_, LineType::Comment);\n    assert_eq!(reader.lines[1].type_, LineType::Comment);\n}", "item_id": 17, "repo": "Pomettini/visual-novel-text-baker", "file": "tests/reader_tests.rs", "last_update_at": "2019-09-29T16:27:31+00:00", "question_id": "63c03229343ca2d9c2ae27790dbf3c681fde5aad_17", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_parse_comment_two_spaces() {\n    SETUP_READER!(\n        reader,\n        \" //  Hello world\n //  Ciao mondo\"\n    );\n    assert_eq!(reader.lines.len(), 2);\n    assert_eq!(reader.lines[0].type_, LineType::Comment);\n    assert_eq!(reader.lines[1].type_, LineType::Comment);\n"]]}
{"hexsha": "687da4c5b9686d9cf5f2174c50edd696678e64fe", "ext": "rs", "lang": "Rust", "content": "fn test_entityarray() {\n        let data = vec![\n            System::builder()\n                .location(Point::origin())\n                .name(\"Sol\")\n                .build(),\n            System::builder()\n                .location(Point::origin())\n                .name(\"Alpha Centauri\")\n                .build(),\n        ];\n\n        // Test indexing and insert.\n        let mut array = EntityArray::new();\n        for item in &data {\n            let idx = array.insert(item.clone());\n            assert_eq!(array[idx], *item);\n        }\n        assert_eq!(array.len(), data.len());\n\n        // Test iterator.\n        for (index, entity) in array.into_iter().enumerate() {\n            assert_eq!(entity, data[index]);\n        }\n    }", "item_id": 0, "repo": "holmgr/prospero", "file": "src/entity/mod.rs", "last_update_at": "2019-03-21T17:50:55+00:00", "question_id": "687da4c5b9686d9cf5f2174c50edd696678e64fe_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_entityarray() {\n        let data = vec![\n            System::builder()\n                .location(Point::origin())\n                .name(\"Sol\")\n                .build(),\n            System::builder()\n                .location(Point::origin())\n                .name(\"Alpha Centauri\")\n                .build(),\n        ];\n        // Test indexing and insert.\n        let mut array = EntityArray::new();\n        for item in &data {\n            let idx = array.insert(item.clone());\n            assert_eq!(array[idx], *item);\n        }\n        assert_eq!(array.len(), data.len());\n        // Test iterator.\n        for (index, entity) in array.into_iter().enumerate() {\n            assert_eq!(entity, data[index]);\n        }\n"]]}
{"hexsha": "f449b5f70b0618999aa9fc59bcf54fe9477f4b7a", "ext": "rs", "lang": "Rust", "content": "fn record_intro() {\n    let mut codemap = CodeMap::new();\n    let context = Context::default();\n\n    let expected_ty = r\"Record { t : Type; x : String }\";\n    let given_expr = r#\"record { t = String; x = \"hello\" }\"#;\n\n    let expected_ty = support::parse_nf_term(&mut codemap, &context, expected_ty);\n    support::parse_check_term(&mut codemap, &context, given_expr, &expected_ty);\n}", "item_id": 0, "repo": "heyrutvik/pikelet", "file": "crates/pikelet-concrete/tests/check.rs", "last_update_at": "2019-01-03T11:03:53+00:00", "question_id": "f449b5f70b0618999aa9fc59bcf54fe9477f4b7a_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn record_intro() {\n    let mut codemap = CodeMap::new();\n    let context = Context::default();\n    let expected_ty = r\"Record { t : Type; x : String }\";\n    let given_expr = r#\"record { t = String; x = \"hello\" }\"#;\n    let expected_ty = support::parse_nf_term(&mut codemap, &context, expected_ty);\n    support::parse_check_term(&mut codemap, &context, given_expr, &expected_ty);\n"]]}
{"hexsha": "443cd06dadc9a483fa457e12f92c295f60d92484", "ext": "rs", "lang": "Rust", "content": "fn test_bitand() {\n        let a = BooleanBitfield::from_bytes(&vec![2, 8, 1][..]);\n        let b = BooleanBitfield::from_bytes(&vec![4, 8, 16][..]);\n        let c = BooleanBitfield::from_bytes(&vec![6, 8, 17][..]);\n        assert_eq!(c, a & b);\n    }", "item_id": 15, "repo": "zedt3ster/lighthouse", "file": "eth2/utils/boolean-bitfield/src/lib.rs", "last_update_at": "2019-04-15T06:39:50+00:00", "question_id": "443cd06dadc9a483fa457e12f92c295f60d92484_15", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_bitand() {\n        let a = BooleanBitfield::from_bytes(&vec![2, 8, 1][..]);\n        let b = BooleanBitfield::from_bytes(&vec![4, 8, 16][..]);\n        let c = BooleanBitfield::from_bytes(&vec![6, 8, 17][..]);\n        assert_eq!(c, a & b);\n"]]}
{"hexsha": "c1326ad899b048ecdd81838676f8b0657335b588", "ext": "rs", "lang": "Rust", "content": "fn object_identifier() {\n        use core::types::ObjectIdentifier;\n\n        let just_root: Vec<u8> = to_vec(&ObjectIdentifier::new(vec![1, 2]).unwrap()).unwrap();\n        let itu: Vec<u8> = to_vec(&ObjectIdentifier::new(vec![2, 999, 3]).unwrap()).unwrap();\n        let rsa: Vec<u8> =\n            to_vec(&ObjectIdentifier::new(vec![1, 2, 840, 113549]).unwrap()).unwrap();\n\n        assert_eq!(&[0x6, 0x1, 0x2a][..], &*just_root);\n        assert_eq!(&[0x6, 0x3, 0x88, 0x37, 0x03][..], &*itu);\n        assert_eq!(&[0x6, 0x6, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d][..], &*rsa);\n    }", "item_id": 8, "repo": "1aim/asn1", "file": "dasn1-der/src/encoder.rs", "last_update_at": "2019-06-12T06:18:19+00:00", "question_id": "c1326ad899b048ecdd81838676f8b0657335b588_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn object_identifier() {\n        use core::types::ObjectIdentifier;\n        let just_root: Vec<u8> = to_vec(&ObjectIdentifier::new(vec![1, 2]).unwrap()).unwrap();\n        let itu: Vec<u8> = to_vec(&ObjectIdentifier::new(vec![2, 999, 3]).unwrap()).unwrap();\n        let rsa: Vec<u8> =\n            to_vec(&ObjectIdentifier::new(vec![1, 2, 840, 113549]).unwrap()).unwrap();\n        assert_eq!(&[0x6, 0x1, 0x2a][..], &*just_root);\n        assert_eq!(&[0x6, 0x3, 0x88, 0x37, 0x03][..], &*itu);\n        assert_eq!(&[0x6, 0x6, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d][..], &*rsa);\n"]]}
{"hexsha": "583f304981d2cd49da188a06c00c0a8a0abc4250", "ext": "rs", "lang": "Rust", "content": "fn it_signs_data() {\n        let wallet = Wallet::new();\n        let message = hash(\"This is a test message to be signed\".as_bytes(), 32);\n        let secp_message = Message::from_slice(&message[..]).unwrap();\n        let recoverable_signature = wallet.sign(&message.to_vec()).unwrap();\n        let secp = Secp256k1::verification_only();\n        let signature = recoverable_signature.to_standard(&secp);\n        let pubkey = secp.recover(&secp_message, &recoverable_signature).unwrap();\n        assert_eq!(pubkey, wallet.public_key);\n        secp.verify(&secp_message, &signature, &wallet.public_key)\n            .unwrap();\n    }", "item_id": 0, "repo": "elniallo/tokio-experiment", "file": "src/common/wallet.rs", "last_update_at": "2019-05-24T08:38:11+00:00", "question_id": "583f304981d2cd49da188a06c00c0a8a0abc4250_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn it_signs_data() {\n        let wallet = Wallet::new();\n        let message = hash(\"This is a test message to be signed\".as_bytes(), 32);\n        let secp_message = Message::from_slice(&message[..]).unwrap();\n        let recoverable_signature = wallet.sign(&message.to_vec()).unwrap();\n        let secp = Secp256k1::verification_only();\n        let signature = recoverable_signature.to_standard(&secp);\n        let pubkey = secp.recover(&secp_message, &recoverable_signature).unwrap();\n        assert_eq!(pubkey, wallet.public_key);\n        secp.verify(&secp_message, &signature, &wallet.public_key)\n            .unwrap();\n"]]}
{"hexsha": "aa2bc3b4d4bef9d9b0519addc895a09484449321", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn create() {\n    let reference: URef = storage::new_uref(DATA);\n    let read_only_reference: URef = URef::new(reference.addr(), AccessRights::READ);\n    let return_value = CLValue::from_t(read_only_reference).unwrap_or_revert();\n    runtime::ret(return_value)\n}", "item_id": 0, "repo": "EdHastingsCasperLabs/CasperLabs", "file": "execution-engine/contracts/test/ee-572-regression-create/src/main.rs", "last_update_at": "2019-08-28T23:06:18+00:00", "question_id": "aa2bc3b4d4bef9d9b0519addc895a09484449321_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub extern \"C\" fn create() {\n    let reference: URef = storage::new_uref(DATA);\n    let read_only_reference: URef = URef::new(reference.addr(), AccessRights::READ);\n    let return_value = CLValue::from_t(read_only_reference).unwrap_or_revert();\n    runtime::ret(return_value)\n"]]}
{"hexsha": "04562bc524c57cfa42238858b057083cee8d7295", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let args: Vec<_> = env::args().collect();\n\n    let opts = Opts::parse_args_default(&args[1..]).unwrap_or_else(|e| {\n        match e.to_string().as_ref() {\n            // Show usage if no command name is given or if \"help\" is given\n            \"missing command name\" => help(&[]),\n            string => eprintln!(\"{}: {}\", args[0], string),\n        }\n\n        exit(2);\n    });\n\n    match opts {\n        Opts::Help(opts) => help(&opts.commands),\n        Opts::Check(_) => check(),\n    }\n\n    exit(0);\n}", "item_id": 0, "repo": "gedigi/advisory-db", "file": "src/main.rs", "last_update_at": "2019-06-27T08:28:29+00:00", "question_id": "04562bc524c57cfa42238858b057083cee8d7295_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let args: Vec<_> = env::args().collect();\n    let opts = Opts::parse_args_default(&args[1..]).unwrap_or_else(|e| {\n        match e.to_string().as_ref() {\n            // Show usage if no command name is given or if \"help\" is given\n            \"missing command name\" => help(&[]),\n            string => eprintln!(\"{}: {}\", args[0], string),\n        }\n        exit(2);\n    });\n    match opts {\n        Opts::Help(opts) => help(&opts.commands),\n        Opts::Check(_) => check(),\n    }\n    exit(0);\n"]]}
{"hexsha": "f04f9b01cfeb6576029f2cb76f20a60949516539", "ext": "rs", "lang": "Rust", "content": "fn test_parse_slow_warning_data() {\n    let o = exec(\"--warnings=tests/data/idmap-warnings/verbose.log.gz\");\n    assert_eq!(o.status.code(), Some(0xff));\n\n    let o = exec(\"--warnings=tests/data/idmap-both-errors-and-warnings/verbose.log.gz\");\n    assert_eq!(o.status.code(), Some(0xff));\n\n    let o = exec(\"--warnings=tests/data/idmap-errors/verbose.log.gz\");\n    assert_eq!(o.status.code(), Some(0));\n}", "item_id": 3, "repo": "amhk/soong-digest", "file": "tests/integration.rs", "last_update_at": "2019-02-17T18:35:58+00:00", "question_id": "f04f9b01cfeb6576029f2cb76f20a60949516539_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_parse_slow_warning_data() {\n    let o = exec(\"--warnings=tests/data/idmap-warnings/verbose.log.gz\");\n    assert_eq!(o.status.code(), Some(0xff));\n    let o = exec(\"--warnings=tests/data/idmap-both-errors-and-warnings/verbose.log.gz\");\n    assert_eq!(o.status.code(), Some(0xff));\n    let o = exec(\"--warnings=tests/data/idmap-errors/verbose.log.gz\");\n    assert_eq!(o.status.code(), Some(0));\n"]]}
{"hexsha": "3db6c68cfd3edc063954f520f11b22883d49e17c", "ext": "rs", "lang": "Rust", "content": "fn dotted_field_name() {\n    let (collector, handle) = collector::mock()\n        .event(\n            event::mock().with_fields(\n                field::mock(\"foo.bar\")\n                    .with_value(&true)\n                    .and(field::mock(\"foo.baz\").with_value(&false))\n                    .only(),\n            ),\n        )\n        .done()\n        .run_with_handle();\n    with_default(collector, || {\n        tracing::event!(Level::INFO, foo.bar = true, foo.baz = false);\n    });\n\n    handle.assert_finished();\n}", "item_id": 5, "repo": "nickshiling/tracing", "file": "tracing/tests/event.rs", "last_update_at": "2019-06-11T22:05:56+00:00", "question_id": "3db6c68cfd3edc063954f520f11b22883d49e17c_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn dotted_field_name() {\n    let (collector, handle) = collector::mock()\n        .event(\n            event::mock().with_fields(\n                field::mock(\"foo.bar\")\n                    .with_value(&true)\n                    .and(field::mock(\"foo.baz\").with_value(&false))\n                    .only(),\n            ),\n        )\n        .done()\n        .run_with_handle();\n    with_default(collector, || {\n        tracing::event!(Level::INFO, foo.bar = true, foo.baz = false);\n    });\n    handle.assert_finished();\n"]]}
{"hexsha": "0290ddf9aafc22c2dc4b8339bd5b722287a7f25c", "ext": "rs", "lang": "Rust", "content": "fn small_example() {\n        let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8];\n        let numbers = calculate_next_phase(numbers);\n        assert_eq!(vec![4, 8, 2, 2, 6, 1, 5, 8], numbers);\n\n        let numbers = calculate_next_phase(numbers);\n        assert_eq!(vec![3, 4, 0, 4, 0, 4, 3, 8], numbers);\n\n        let numbers = calculate_next_phase(numbers);\n        assert_eq!(vec![0, 3, 4, 1, 5, 5, 1, 8], numbers);\n\n        let numbers = calculate_next_phase(numbers);\n        assert_eq!(vec![0, 1, 0, 2, 9, 4, 9, 8], numbers);\n    }", "item_id": 3, "repo": "df5602/aoc2019", "file": "16-flawed-frequency-transmission/src/main.rs", "last_update_at": "2019-12-03T21:30:12+00:00", "question_id": "0290ddf9aafc22c2dc4b8339bd5b722287a7f25c_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn small_example() {\n        let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8];\n        let numbers = calculate_next_phase(numbers);\n        assert_eq!(vec![4, 8, 2, 2, 6, 1, 5, 8], numbers);\n        let numbers = calculate_next_phase(numbers);\n        assert_eq!(vec![3, 4, 0, 4, 0, 4, 3, 8], numbers);\n        let numbers = calculate_next_phase(numbers);\n        assert_eq!(vec![0, 3, 4, 1, 5, 5, 1, 8], numbers);\n        let numbers = calculate_next_phase(numbers);\n        assert_eq!(vec![0, 1, 0, 2, 9, 4, 9, 8], numbers);\n"]]}
{"hexsha": "cecc5e6436200924337c7cfa7fdd23457615fe0a", "ext": "rs", "lang": "Rust", "content": "fn test_notify() {\n        let (tx1, rx1) = super::unbounded();\n        let (tx2, rx2) = mpsc::unbounded();\n        let mut rx2 = rx2.wait();\n        let j = thread::spawn(move || {\n            rx1.map_err(|_| ())\n                .forward(tx2.sink_map_err(|_| ()))\n                .wait()\n                .unwrap();\n        });\n        tx1.send(2).unwrap();\n        assert_eq!(rx2.next().unwrap(), Ok(2));\n        for i in 0..100 {\n            tx1.send(i).unwrap();\n        }\n        for i in 0..100 {\n            assert_eq!(rx2.next().unwrap(), Ok(i));\n        }\n        thread::spawn(move || {\n            for i in 100..10000 {\n                tx1.send(i).unwrap();\n            }\n        });\n        for i in 100..10000 {\n            assert_eq!(rx2.next().unwrap(), Ok(i));\n        }\n        // j should automatically stop when tx1 is dropped.\n        j.join().unwrap();\n    }", "item_id": 4, "repo": "gregwebs/tikv", "file": "src/util/mpsc.rs", "last_update_at": "2019-03-06T07:07:25+00:00", "question_id": "cecc5e6436200924337c7cfa7fdd23457615fe0a_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_notify() {\n        let (tx1, rx1) = super::unbounded();\n        let (tx2, rx2) = mpsc::unbounded();\n        let mut rx2 = rx2.wait();\n        let j = thread::spawn(move || {\n            rx1.map_err(|_| ())\n                .forward(tx2.sink_map_err(|_| ()))\n                .wait()\n                .unwrap();\n        });\n        tx1.send(2).unwrap();\n        assert_eq!(rx2.next().unwrap(), Ok(2));\n        for i in 0..100 {\n            tx1.send(i).unwrap();\n        }\n        for i in 0..100 {\n            assert_eq!(rx2.next().unwrap(), Ok(i));\n        }\n        thread::spawn(move || {\n            for i in 100..10000 {\n                tx1.send(i).unwrap();\n            }\n        });\n        for i in 100..10000 {\n            assert_eq!(rx2.next().unwrap(), Ok(i));\n        }\n        // j should automatically stop when tx1 is dropped.\n        j.join().unwrap();\n"]]}
{"hexsha": "0f71508e0e6f428e625cec06bc478640105e0c30", "ext": "rs", "lang": "Rust", "content": "fn update_clone_randomly(criterion: &mut Criterion) {\n    macro_rules! bench {\n        ($n:ident, $rnd:ident) => {\n            |vec| {\n                let mut vec_1 = vec;\n                let mut vec_2 = vec_1.clone();\n                let mut vec_3 = vec_2.clone();\n\n                for _ in 0..*$n {\n                    vec_3 = vec_1;\n                    vec_1 = vec_2;\n\n                    let j = ($rnd.next_u32() as usize) % *$n;\n                    (*vec_1.get_mut(j).unwrap()) += 1;\n\n                    vec_2 = vec_1.clone();\n                }\n\n                (vec_1, vec_2, vec_3)\n            }\n        };\n    }\n\n    let mut group = criterion.benchmark_group(\"update_clone_randomly\");\n    group.plot_config(PlotConfiguration::default().summary_scale(AxisScale::Logarithmic));\n\n    macro_rules! bench_balanced {\n        ($name:ident, $p:ident, $new_vec:expr, $push:ident) => {\n            group.bench_with_input(BenchmarkId::new($name, $p), $p, |b, n| {\n                let mut rnd = rnd();\n\n                b.iter_batched(\n                    vec_balanced!(n, $new_vec, $push),\n                    bench!(n, rnd),\n                    SmallInput,\n                )\n            });\n        };\n    }\n\n    macro_rules! bench_relaxed {\n        ($name:ident, $p:ident, $new_vec:expr, $push:ident, $append:path) => {\n            group.bench_with_input(BenchmarkId::new($name, $p), $p, |b, n| {\n                let mut rnd = rnd();\n\n                b.iter_batched(\n                    vec_relaxed!(n, $new_vec, $push, $append),\n                    bench!(n, rnd),\n                    SmallInput,\n                )\n            });\n        };\n    }\n\n    let params = vec![\n        20, 40, 60, 80, 100, 200, 400, 600, 800, 1000, 2000, 4000, 6000, 8000, 10000, 20000,\n    ];\n\n    for p in params.iter() {\n        bench_balanced!(STD_VEC, p, || Vec::new(), push);\n\n        bench_balanced!(IM_RS_VECTOR_BALANCED, p, || IVec::new(), push_back);\n        bench_relaxed!(\n            IM_RS_VECTOR_RELAXED,\n            p,\n            || IVec::new(),\n            push_back,\n            append::ivec\n        );\n\n        bench_balanced!(RBVEC, p, || RbVec::new(), push);\n        bench_relaxed!(RRBVEC, p, || RrbVec::new(), push, append::rrbvec);\n\n        bench_balanced!(PVEC_STD, p, || PVec::new(), push);\n        bench_balanced!(PVEC_RRBVEC_BALANCED, p, || PVec::new_with_tree(), push);\n        bench_relaxed!(\n            PVEC_RRBVEC_RELAXED,\n            p,\n            || PVec::new_with_tree(),\n            push,\n            append::pvec\n        );\n    }\n\n    group.finish();\n}", "item_id": 10, "repo": "ArazAbishov/pvec-rs", "file": "benches/sequential.rs", "last_update_at": "2019-10-22T06:54:13+00:00", "question_id": "0f71508e0e6f428e625cec06bc478640105e0c30_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn update_clone_randomly(criterion: &mut Criterion) {\n    macro_rules! bench {\n        ($n:ident, $rnd:ident) => {\n            |vec| {\n                let mut vec_1 = vec;\n                let mut vec_2 = vec_1.clone();\n                let mut vec_3 = vec_2.clone();\n                for _ in 0..*$n {\n                    vec_3 = vec_1;\n                    vec_1 = vec_2;\n                    let j = ($rnd.next_u32() as usize) % *$n;\n                    (*vec_1.get_mut(j).unwrap()) += 1;\n                    vec_2 = vec_1.clone();\n                }\n                (vec_1, vec_2, vec_3)\n            }\n        };\n    }\n    let mut group = criterion.benchmark_group(\"update_clone_randomly\");\n    group.plot_config(PlotConfiguration::default().summary_scale(AxisScale::Logarithmic));\n    macro_rules! bench_balanced {\n        ($name:ident, $p:ident, $new_vec:expr, $push:ident) => {\n            group.bench_with_input(BenchmarkId::new($name, $p), $p, |b, n| {\n                let mut rnd = rnd();\n                b.iter_batched(\n                    vec_balanced!(n, $new_vec, $push),\n                    bench!(n, rnd),\n                    SmallInput,\n                )\n            });\n        };\n    }\n    macro_rules! bench_relaxed {\n        ($name:ident, $p:ident, $new_vec:expr, $push:ident, $append:path) => {\n            group.bench_with_input(BenchmarkId::new($name, $p), $p, |b, n| {\n                let mut rnd = rnd();\n                b.iter_batched(\n                    vec_relaxed!(n, $new_vec, $push, $append),\n                    bench!(n, rnd),\n                    SmallInput,\n                )\n            });\n        };\n    }\n    let params = vec![\n        20, 40, 60, 80, 100, 200, 400, 600, 800, 1000, 2000, 4000, 6000, 8000, 10000, 20000,\n    ];\n    for p in params.iter() {\n        bench_balanced!(STD_VEC, p, || Vec::new(), push);\n        bench_balanced!(IM_RS_VECTOR_BALANCED, p, || IVec::new(), push_back);\n        bench_relaxed!(\n            IM_RS_VECTOR_RELAXED,\n            p,\n            || IVec::new(),\n            push_back,\n            append::ivec\n        );\n        bench_balanced!(RBVEC, p, || RbVec::new(), push);\n        bench_relaxed!(RRBVEC, p, || RrbVec::new(), push, append::rrbvec);\n        bench_balanced!(PVEC_STD, p, || PVec::new(), push);\n        bench_balanced!(PVEC_RRBVEC_BALANCED, p, || PVec::new_with_tree(), push);\n        bench_relaxed!(\n            PVEC_RRBVEC_RELAXED,\n            p,\n            || PVec::new_with_tree(),\n            push,\n            append::pvec\n        );\n    }\n    group.finish();\n"]]}
{"hexsha": "4945796b0f67484b227519adebc25a57ebe2a8df", "ext": "rs", "lang": "Rust", "content": "fn create_fastfield_bitpacker(len: usize, num_bits: u8) -> (BitUnpacker<Vec<u8>>, Vec<u64>) {\n        let mut data = Vec::new();\n        let mut bitpacker = BitPacker::new();\n        let max_val: u64 = (1u64 << num_bits as u64) - 1u64;\n        let vals: Vec<u64> = (0u64..len as u64)\n            .map(|i| if max_val == 0 { 0 } else { i % max_val })\n            .collect();\n        for &val in &vals {\n            bitpacker.write(val, num_bits, &mut data).unwrap();\n        }\n        bitpacker.close(&mut data).unwrap();\n        assert_eq!(data.len(), ((num_bits as usize) * len + 7) / 8 + 7);\n        let bitunpacker = BitUnpacker::new(data, num_bits);\n        (bitunpacker, vals)\n    }", "item_id": 0, "repo": "Atul9/tantivy", "file": "src/common/bitpacker.rs", "last_update_at": "2019-07-19T20:34:37+00:00", "question_id": "4945796b0f67484b227519adebc25a57ebe2a8df_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn create_fastfield_bitpacker(len: usize, num_bits: u8) -> (BitUnpacker<Vec<u8>>, Vec<u64>) {\n        let mut data = Vec::new();\n        let mut bitpacker = BitPacker::new();\n        let max_val: u64 = (1u64 << num_bits as u64) - 1u64;\n        let vals: Vec<u64> = (0u64..len as u64)\n            .map(|i| if max_val == 0 { 0 } else { i % max_val })\n            .collect();\n        for &val in &vals {\n            bitpacker.write(val, num_bits, &mut data).unwrap();\n        }\n        bitpacker.close(&mut data).unwrap();\n        assert_eq!(data.len(), ((num_bits as usize) * len + 7) / 8 + 7);\n        let bitunpacker = BitUnpacker::new(data, num_bits);\n        (bitunpacker, vals)\n"]]}
{"hexsha": "1d788a0244e453936f43adcf7a42c031a678d1c8", "ext": "rs", "lang": "Rust", "content": "pub fn get_test_config() -> (NodeConfig, KeyPair<Ed25519PrivateKey, Ed25519PublicKey>) {\n    let mut config = NodeConfig::random();\n    config.randomize_ports();\n\n    // Get a deterministic seed per process, as many tests expect the same genesis keys\n    let base_seed = process::id().to_be_bytes();\n    let mut seed = [0u8; 32];\n    seed[..base_seed.len()].clone_from_slice(&base_seed[..]);\n    let mut rng = StdRng::from_seed(seed);\n\n    let private_key = Ed25519PrivateKey::generate_for_testing(&mut rng);\n    let keypair: KeyPair<Ed25519PrivateKey, Ed25519PublicKey> = KeyPair::from(private_key);\n    let network_peers = &config.validator_network.as_ref().unwrap().network_peers;\n\n    config.execution.genesis = Some(Transaction::UserTransaction(\n        vm_genesis::encode_genesis_transaction_with_validator(\n            &keypair.private_key,\n            keypair.public_key.clone(),\n            config\n                .consensus\n                .consensus_peers\n                .get_validator_set(network_peers),\n        )\n        .into_inner(),\n    ));\n\n    (config, keypair)\n}", "item_id": 0, "repo": "mingzhuyang/libra", "file": "config/config-builder/src/util.rs", "last_update_at": "2019-12-02T16:54:08+00:00", "question_id": "1d788a0244e453936f43adcf7a42c031a678d1c8_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn get_test_config() -> (NodeConfig, KeyPair<Ed25519PrivateKey, Ed25519PublicKey>) {\n    let mut config = NodeConfig::random();\n    config.randomize_ports();\n    // Get a deterministic seed per process, as many tests expect the same genesis keys\n    let base_seed = process::id().to_be_bytes();\n    let mut seed = [0u8; 32];\n    seed[..base_seed.len()].clone_from_slice(&base_seed[..]);\n    let mut rng = StdRng::from_seed(seed);\n    let private_key = Ed25519PrivateKey::generate_for_testing(&mut rng);\n    let keypair: KeyPair<Ed25519PrivateKey, Ed25519PublicKey> = KeyPair::from(private_key);\n    let network_peers = &config.validator_network.as_ref().unwrap().network_peers;\n    config.execution.genesis = Some(Transaction::UserTransaction(\n        vm_genesis::encode_genesis_transaction_with_validator(\n            &keypair.private_key,\n            keypair.public_key.clone(),\n            config\n                .consensus\n                .consensus_peers\n                .get_validator_set(network_peers),\n        )\n        .into_inner(),\n    ));\n    (config, keypair)\n"]]}
{"hexsha": "d353aab467ce9d2579c72ac83df3bff28b8029c3", "ext": "rs", "lang": "Rust", "content": "fn add_assign_with_ovfl_3_works() {\n        let expected = {\n            let mut expected = [0x00; 32];\n            expected[24] = 0x01;\n            expected\n        };\n        let mut key = Key::from(OVERFLOW_3_TEST_BYTES);\n        key.add_assign(1u64);\n        assert_eq!(key.as_ref(), &expected);\n    }", "item_id": 12, "repo": "kaiweicai/ink-example", "file": "crates/primitives/src/tests.rs", "last_update_at": "2019-04-20T01:12:47+00:00", "question_id": "d353aab467ce9d2579c72ac83df3bff28b8029c3_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn add_assign_with_ovfl_3_works() {\n        let expected = {\n            let mut expected = [0x00; 32];\n            expected[24] = 0x01;\n            expected\n        };\n        let mut key = Key::from(OVERFLOW_3_TEST_BYTES);\n        key.add_assign(1u64);\n        assert_eq!(key.as_ref(), &expected);\n"]]}
{"hexsha": "2689e05a0a702b59b9509a058be334d8a8302bc3", "ext": "rs", "lang": "Rust", "content": "pub fn gen_mr_builder_types(grammar: &structs::Grammar) -> String {\n    let kinds = &grammar.operand_kinds;\n    // Generate build methods for all types.\n    let elements: Vec<String> = grammar.instructions.iter().filter(|inst| {\n        inst.class == \"Type\" && inst.opname != \"OpTypeForwardPointer\" &&\n            inst.opname != \"OpTypePointer\" && inst.opname != \"OpTypeOpaque\"\n    }).map(|inst| {\n        // Parameter list for this build method.\n        let (param_list, type_generics) = get_param_list(&inst.operands, false, kinds);\n        // Initializer list for constructing the operands parameter\n        // for Instruction.\n        let init_list = get_init_list(&inst.operands[1..]).join(\", \");\n        // Parameters that are not single values thus need special treatment.\n        let extras = get_push_extras(&inst.operands[1..],\n                                     kinds,\n                                     \"self.module.types_global_values.last_mut()\\\n                                     .expect(\\\"interal error\\\").operands\").join(\";\\n\");\n        format!(\"{s:4}/// Appends an Op{opcode} instruction and returns the result id.\\n\\\n                 {s:4}pub fn {name}{generic}(&mut self{sep}{param}) -> spirv::Word {{\\n\\\n                 {s:8}let id = self.id();\\n\\\n                 {s:8}self.module.types_global_values.push(\\\n                     mr::Instruction::new(spirv::Op::{opcode}, \\\n                     None, Some(id), vec![{init}]));\\n\\\n                 {extras}{x}\\\n                 {s:8}id\\n\\\n                 {s:4}}}\",\n                s = \"\",\n                sep = if param_list.len() != 0 { \", \" } else { \"\" },\n                opcode = &inst.opname[2..],\n                name = snake_casify(&inst.opname[2..]),\n                generic = type_generics,\n                param = param_list,\n                init = init_list,\n                extras = extras,\n                x = if extras.len() != 0 { \";\\n\" } else { \"\" })\n    }).collect();\n    format!(\"impl Builder {{\\n{}\\n}}\", elements.join(\"\\n\\n\"))\n}", "item_id": 3, "repo": "fkaa/rspirv", "file": "codegen/mr.rs", "last_update_at": "2019-07-05T14:48:42+00:00", "question_id": "2689e05a0a702b59b9509a058be334d8a8302bc3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn gen_mr_builder_types(grammar: &structs::Grammar) -> String {\n    let kinds = &grammar.operand_kinds;\n    // Generate build methods for all types.\n    let elements: Vec<String> = grammar.instructions.iter().filter(|inst| {\n        inst.class == \"Type\" && inst.opname != \"OpTypeForwardPointer\" &&\n            inst.opname != \"OpTypePointer\" && inst.opname != \"OpTypeOpaque\"\n    }).map(|inst| {\n        // Parameter list for this build method.\n        let (param_list, type_generics) = get_param_list(&inst.operands, false, kinds);\n        // Initializer list for constructing the operands parameter\n        // for Instruction.\n        let init_list = get_init_list(&inst.operands[1..]).join(\", \");\n        // Parameters that are not single values thus need special treatment.\n        let extras = get_push_extras(&inst.operands[1..],\n                                     kinds,\n                                     \"self.module.types_global_values.last_mut()\\\n                                     .expect(\\\"interal error\\\").operands\").join(\";\\n\");\n        format!(\"{s:4}/// Appends an Op{opcode} instruction and returns the result id.\\n\\\n                 {s:4}pub fn {name}{generic}(&mut self{sep}{param}) -> spirv::Word {{\\n\\\n                 {s:8}let id = self.id();\\n\\\n                 {s:8}self.module.types_global_values.push(\\\n                     mr::Instruction::new(spirv::Op::{opcode}, \\\n                     None, Some(id), vec![{init}]));\\n\\\n                 {extras}{x}\\\n                 {s:8}id\\n\\\n                 {s:4}}}\",\n                s = \"\",\n                sep = if param_list.len() != 0 { \", \" } else { \"\" },\n                opcode = &inst.opname[2..],\n                name = snake_casify(&inst.opname[2..]),\n                generic = type_generics,\n                param = param_list,\n                init = init_list,\n                extras = extras,\n                x = if extras.len() != 0 { \";\\n\" } else { \"\" })\n    }).collect();\n    format!(\"impl Builder {{\\n{}\\n}}\", elements.join(\"\\n\\n\"))\n"]]}
{"hexsha": "34c52df3a8af957ca975e35de99cfc539cdf4af0", "ext": "rs", "lang": "Rust", "content": "fn main() -> std::io::Result<()> {\n    let filename = r\"C:\\Users\\Attila\\Downloads\\input1.txt\";\n    // Open the file in read-only mode (ignoring errors).\n    let file = File::open(filename).unwrap();\n    let reader = BufReader::new(file);\n\n    let mut sum = 0u32;\n    // Read the file line by line using the lines() iterator from std::io::BufRead.\n    for (index, line) in reader.lines().enumerate() {\n        let line = line.unwrap(); // Ignore errors.\n                                  // Show the line and its number.\n\n        let value = line.parse::<u32>().unwrap();\n        sum += (value / 3) - 2;\n        println!(\"{0}. {1}\", index + 1, line);\n    }\n\n    println!(\"sum: {}\", sum);\n\n    //println!(\"{}\", contents);\n    Ok(())\n}", "item_id": 0, "repo": "attixray/AOC2019", "file": "src/main.rs", "last_update_at": "2019-12-18T13:58:10+00:00", "question_id": "34c52df3a8af957ca975e35de99cfc539cdf4af0_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> std::io::Result<()> {\n    let filename = r\"C:\\Users\\Attila\\Downloads\\input1.txt\";\n    // Open the file in read-only mode (ignoring errors).\n    let file = File::open(filename).unwrap();\n    let reader = BufReader::new(file);\n    let mut sum = 0u32;\n    // Read the file line by line using the lines() iterator from std::io::BufRead.\n    for (index, line) in reader.lines().enumerate() {\n        let line = line.unwrap(); // Ignore errors.\n                                  // Show the line and its number.\n        let value = line.parse::<u32>().unwrap();\n        sum += (value / 3) - 2;\n        println!(\"{0}. {1}\", index + 1, line);\n    }\n    println!(\"sum: {}\", sum);\n    //println!(\"{}\", contents);\n    Ok(())\n"]]}
{"hexsha": "2973364ce34d6141d42d75ae46ab7551f160c1dc", "ext": "rs", "lang": "Rust", "content": "pub fn sync_drive_items<DriveItem: 'static>(\n    client: &Client,\n    reset_link: String,\n    link: String,\n    handler: &mut impl DriveItemHandler<DriveItem>,\n) -> Result<String>\nwhere\n    DriveItem: Send + serde::de::DeserializeOwned,\n{\n    let (sender, receiver) = mpsc::channel::<Option<Vec<DriveItem>>>();\n    let client = client.clone();\n    let t = std::thread::spawn(move || fetch_items(&client, reset_link, link, sender));\n    loop {\n        match receiver.recv() {\n            Ok(Some(items)) => {\n                for item in items.into_iter() {\n                    handler.handle(item);\n                }\n            }\n            Ok(None) => {\n                // None indicates that the sender thread has had to restart the sync from the beginning.\n                handler.reset();\n            }\n            Err(mpsc::RecvError) => {\n                // RecvError means that the sender has closed the channel. This only happens\n                // when there are no more pages or the sending thread has panicked.\n                break;\n            }\n        }\n    }\n    match t.join() {\n        Ok(delta_link) => Ok(delta_link),\n        Err(err) => {\n            match err.downcast::<&str>() {\n                Ok(s) => {\n                    Err(eyre!(s))\n                }\n                Err(err) => {\n                    panic::resume_unwind(err)\n                }\n            }\n        }\n    }\n}", "item_id": 1, "repo": "jongiddy/msod-stat", "file": "src/sync.rs", "last_update_at": "2019-07-25T08:19:22+00:00", "question_id": "2973364ce34d6141d42d75ae46ab7551f160c1dc_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn sync_drive_items<DriveItem: 'static>(\n    client: &Client,\n    reset_link: String,\n    link: String,\n    handler: &mut impl DriveItemHandler<DriveItem>,\n) -> Result<String>\nwhere\n    DriveItem: Send + serde::de::DeserializeOwned,\n{\n    let (sender, receiver) = mpsc::channel::<Option<Vec<DriveItem>>>();\n    let client = client.clone();\n    let t = std::thread::spawn(move || fetch_items(&client, reset_link, link, sender));\n    loop {\n        match receiver.recv() {\n            Ok(Some(items)) => {\n                for item in items.into_iter() {\n                    handler.handle(item);\n                }\n            }\n            Ok(None) => {\n                // None indicates that the sender thread has had to restart the sync from the beginning.\n                handler.reset();\n            }\n            Err(mpsc::RecvError) => {\n                // RecvError means that the sender has closed the channel. This only happens\n                // when there are no more pages or the sending thread has panicked.\n                break;\n            }\n        }\n    }\n    match t.join() {\n        Ok(delta_link) => Ok(delta_link),\n        Err(err) => {\n            match err.downcast::<&str>() {\n                Ok(s) => {\n                    Err(eyre!(s))\n                }\n                Err(err) => {\n                    panic::resume_unwind(err)\n                }\n            }\n        }\n    }\n"]]}
{"hexsha": "0ad09fd0f7dfba492e8146a64a17ed0a25eb1f69", "ext": "rs", "lang": "Rust", "content": "fn test_is_empty() {\n        let test0 = TokenStream::from_tts(Vec::new());\n        let test1 = TokenStream::from_tts(vec![TokenTree::Token(sp(0, 1),\n                                                                Token::Ident(str_to_ident(\"a\")))]);\n        let test2 = TokenStream::from_tts(string_to_tts(\"foo(bar::baz)\".to_string()));\n\n        assert_eq!(test0.is_empty(), true);\n        assert_eq!(test1.is_empty(), false);\n        assert_eq!(test2.is_empty(), false);\n    }", "item_id": 1, "repo": "canaltinova/rust", "file": "src/libsyntax/tokenstream.rs", "last_update_at": "2019-09-24T02:31:48+00:00", "question_id": "0ad09fd0f7dfba492e8146a64a17ed0a25eb1f69_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_is_empty() {\n        let test0 = TokenStream::from_tts(Vec::new());\n        let test1 = TokenStream::from_tts(vec![TokenTree::Token(sp(0, 1),\n                                                                Token::Ident(str_to_ident(\"a\")))]);\n        let test2 = TokenStream::from_tts(string_to_tts(\"foo(bar::baz)\".to_string()));\n        assert_eq!(test0.is_empty(), true);\n        assert_eq!(test1.is_empty(), false);\n        assert_eq!(test2.is_empty(), false);\n"]]}
{"hexsha": "0b18c5df7300dd5100bdb673063d5ab9c517417b", "ext": "rs", "lang": "Rust", "content": "pub fn create_new_ledger(ledger_path: &str, genesis_block: &GenesisBlock) -> Result<Hash> {\n    let ticks_per_slot = genesis_block.ticks_per_slot;\n    Blocktree::destroy(ledger_path)?;\n    genesis_block.write(&ledger_path)?;\n\n    // Fill slot 0 with ticks that link back to the genesis_block to bootstrap the ledger.\n    let blocktree = Blocktree::open(ledger_path)?;\n    let entries = crate::entry::create_ticks(ticks_per_slot, genesis_block.hash());\n    blocktree.write_entries(0, 0, 0, ticks_per_slot, &entries)?;\n\n    Ok(entries.last().unwrap().hash)\n}", "item_id": 0, "repo": "abalaki6/solana", "file": "core/src/blocktree.rs", "last_update_at": "2019-03-10T22:29:28+00:00", "question_id": "0b18c5df7300dd5100bdb673063d5ab9c517417b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn create_new_ledger(ledger_path: &str, genesis_block: &GenesisBlock) -> Result<Hash> {\n    let ticks_per_slot = genesis_block.ticks_per_slot;\n    Blocktree::destroy(ledger_path)?;\n    genesis_block.write(&ledger_path)?;\n    // Fill slot 0 with ticks that link back to the genesis_block to bootstrap the ledger.\n    let blocktree = Blocktree::open(ledger_path)?;\n    let entries = crate::entry::create_ticks(ticks_per_slot, genesis_block.hash());\n    blocktree.write_entries(0, 0, 0, ticks_per_slot, &entries)?;\n    Ok(entries.last().unwrap().hash)\n"]]}
{"hexsha": "9f93a5606ae682304267c246e5b42734d38a78a9", "ext": "rs", "lang": "Rust", "content": "pub fn compile_read(mv: &mut MustacheVisitor, reader: &mut Read, file: &str) -> Result<(), String> {\n    let mut buf = &mut BufReader::new(reader).chars();\n    let iter = &mut buf.take_while(|c| {\n        c.is_ok()\n    }).map(|c| {\n        c.ok().unwrap()\n    });\n    let chars = Lookahead::new(iter);\n\n    compile_internal(mv, &chars, None, &Cell::new(0), file, DEFAULT_SM, DEFAULT_EM, true)\n}", "item_id": 0, "repo": "spullara/mustache.rs", "file": "src/compiler.rs", "last_update_at": "2019-12-01T19:57:51+00:00", "question_id": "9f93a5606ae682304267c246e5b42734d38a78a9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn compile_read(mv: &mut MustacheVisitor, reader: &mut Read, file: &str) -> Result<(), String> {\n    let mut buf = &mut BufReader::new(reader).chars();\n    let iter = &mut buf.take_while(|c| {\n        c.is_ok()\n    }).map(|c| {\n        c.ok().unwrap()\n    });\n    let chars = Lookahead::new(iter);\n    compile_internal(mv, &chars, None, &Cell::new(0), file, DEFAULT_SM, DEFAULT_EM, true)\n"]]}
{"hexsha": "3cb4507dc281365e2ae4798fce6f9bfcdbaa2731", "ext": "rs", "lang": "Rust", "content": "fn main() -> AocResult<()> {\n    let input = fs::read_to_string(\"input.txt\")?;\n    let lines: Vec<&str> = input.lines().collect();\n    let wire1 = Wire::new(lines[0])?;\n    let wire2 = Wire::new(lines[1])?;\n    println!(\"{:?}\", solve(&wire1, &wire2)?);\n    Ok(())\n}", "item_id": 0, "repo": "gizmondo/AOC2019", "file": "day03/src/main.rs", "last_update_at": "2019-12-02T20:01:42+00:00", "question_id": "3cb4507dc281365e2ae4798fce6f9bfcdbaa2731_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() -> AocResult<()> {\n    let input = fs::read_to_string(\"input.txt\")?;\n    let lines: Vec<&str> = input.lines().collect();\n    let wire1 = Wire::new(lines[0])?;\n    let wire2 = Wire::new(lines[1])?;\n    println!(\"{:?}\", solve(&wire1, &wire2)?);\n    Ok(())\n"]]}
{"hexsha": "e77e2d5f4ada4fa31f95fec71754c0282a221614", "ext": "rs", "lang": "Rust", "content": "fn test_edge_clipping_intersects_opposite_edges() {\n        assert!((Point(r3::vector::Vector{x: 0.169258, y: -0.169258, z: 0.664013}) as PointUVW).intersects_opposite_edges() == false);\n        assert!((Point(r3::vector::Vector{x: 0.169258, y: -0.169258, z: -0.664013}) as PointUVW).intersects_opposite_edges() == false);\n        assert!((Point(r3::vector::Vector{x: (4.0_f64 / 3.0_f64).sqrt(), y: 0_f64, z: -(4_f64 / 3_f64).sqrt()}) as PointUVW).intersects_opposite_edges() == true);\n        assert!((Point(r3::vector::Vector{x: (4.0_f64 / 3.0_f64).sqrt(), y: 0_f64, z: (4_f64 / 3_f64).sqrt()}) as PointUVW).intersects_opposite_edges() == true);\n        assert!((Point(r3::vector::Vector{x: -(2.0_f64 / 3.0_f64).sqrt(), y: -(2.0_f64 / 3.0_f64).sqrt(), z: 1.66533453694e-16}) as PointUVW).intersects_opposite_edges() == false);\n        assert!((Point(r3::vector::Vector{x: (2.0_f64 / 3.0_f64).sqrt(), y: (2.0_f64 / 3.0_f64).sqrt(), z: -1.66533453694e-16}) as PointUVW).intersects_opposite_edges() == false);\n    }", "item_id": 12, "repo": "eltorocorp/rust-s2", "file": "src/s2/edge_clipping.rs", "last_update_at": "2019-06-18T13:48:44+00:00", "question_id": "e77e2d5f4ada4fa31f95fec71754c0282a221614_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_edge_clipping_intersects_opposite_edges() {\n        assert!((Point(r3::vector::Vector{x: 0.169258, y: -0.169258, z: 0.664013}) as PointUVW).intersects_opposite_edges() == false);\n        assert!((Point(r3::vector::Vector{x: 0.169258, y: -0.169258, z: -0.664013}) as PointUVW).intersects_opposite_edges() == false);\n        assert!((Point(r3::vector::Vector{x: (4.0_f64 / 3.0_f64).sqrt(), y: 0_f64, z: -(4_f64 / 3_f64).sqrt()}) as PointUVW).intersects_opposite_edges() == true);\n        assert!((Point(r3::vector::Vector{x: (4.0_f64 / 3.0_f64).sqrt(), y: 0_f64, z: (4_f64 / 3_f64).sqrt()}) as PointUVW).intersects_opposite_edges() == true);\n        assert!((Point(r3::vector::Vector{x: -(2.0_f64 / 3.0_f64).sqrt(), y: -(2.0_f64 / 3.0_f64).sqrt(), z: 1.66533453694e-16}) as PointUVW).intersects_opposite_edges() == false);\n        assert!((Point(r3::vector::Vector{x: (2.0_f64 / 3.0_f64).sqrt(), y: (2.0_f64 / 3.0_f64).sqrt(), z: -1.66533453694e-16}) as PointUVW).intersects_opposite_edges() == false);\n"]]}
{"hexsha": "2fd7524533968e072b1e6140e86783e83581253d", "ext": "rs", "lang": "Rust", "content": "fn let_shift_universes_literals() {\n    let mut codemap = CodeMap::new();\n    let context = Context::default();\n\n    let given_expr = r#\"\n        let\n            id : (a : Type) -> a -> a;\n            id a x = x;\n\n            test2 = \"hello\" : id^1 Type String;\n        in\n            record {}\n    \"#;\n\n    support::parse_infer_term(&mut codemap, &context, given_expr);\n}", "item_id": 26, "repo": "heyrutvik/pikelet", "file": "crates/pikelet-concrete/tests/infer.rs", "last_update_at": "2019-01-03T11:03:53+00:00", "question_id": "2fd7524533968e072b1e6140e86783e83581253d_26", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn let_shift_universes_literals() {\n    let mut codemap = CodeMap::new();\n    let context = Context::default();\n    let given_expr = r#\"\n        let\n            id : (a : Type) -> a -> a;\n            id a x = x;\n            test2 = \"hello\" : id^1 Type String;\n        in\n            record {}\n    \"#;\n    support::parse_infer_term(&mut codemap, &context, given_expr);\n"]]}
{"hexsha": "75dd36fa694fd983b0edab7acdb1eac57405ff32", "ext": "rs", "lang": "Rust", "content": "pub async fn create_user(\n    data: NewUser,\n    channel: tonic::transport::Channel,\n) -> Result<User, GatewayError> {\n    let mut client = UsersClient::new(channel);\n    let request = tonic::Request::new(CreateUserRequest {\n        username: data.username,\n        password: data.password,\n    });\n    let response = client.create_user(request).await?.into_inner();\n    Ok(response.user.unwrap().into())\n}", "item_id": 0, "repo": "nicksenger/microbiome", "file": "api-gateway/src/data/user/create_user.rs", "last_update_at": "2019-11-29T03:32:12+00:00", "question_id": "75dd36fa694fd983b0edab7acdb1eac57405ff32_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub async fn create_user(\n    data: NewUser,\n    channel: tonic::transport::Channel,\n) -> Result<User, GatewayError> {\n    let mut client = UsersClient::new(channel);\n    let request = tonic::Request::new(CreateUserRequest {\n        username: data.username,\n        password: data.password,\n    });\n    let response = client.create_user(request).await?.into_inner();\n    Ok(response.user.unwrap().into())\n"]]}
{"hexsha": "7be6eedc2704db183a29bd11d07026a157fde6da", "ext": "rs", "lang": "Rust", "content": "pub fn root() -> PathBuf {\n    let idx = IDX.with(|x| *x);\n\n    let mut me = env::current_exe().unwrap();\n    me.pop(); // chop off exe name\n    me.pop(); // chop off `deps`\n    me.pop(); // chop off `debug` / `release`\n    me.push(\"generated-tests\");\n    me.push(&format!(\"test{}\", idx));\n    return me\n}", "item_id": 1, "repo": "lukewagner/wasm-bindgen", "file": "crates/test-support/src/lib.rs", "last_update_at": "2019-02-22T00:00:52+00:00", "question_id": "7be6eedc2704db183a29bd11d07026a157fde6da_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn root() -> PathBuf {\n    let idx = IDX.with(|x| *x);\n    let mut me = env::current_exe().unwrap();\n    me.pop(); // chop off exe name\n    me.pop(); // chop off `deps`\n    me.pop(); // chop off `debug` / `release`\n    me.push(\"generated-tests\");\n    me.push(&format!(\"test{}\", idx));\n    return me\n"]]}
{"hexsha": "9b9e9f65e1cf531c72ddcaf1ded2a4d1a6bce82e", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    #[cfg(not(target_os = \"wasi\"))]\n    let mut base = PathBuf::from(\"wasitests/test_fs/hamlet\");\n    #[cfg(target_os = \"wasi\")]\n    let mut base = PathBuf::from(\".\");\n\n    base.push(\"act1/scene3.txt\");\n\n    let mut file = fs::File::open(&base).expect(\"Could not open file\");\n\n    let mut buffer = [0u8; 32];\n\n    assert_eq!(file.read(&mut buffer).unwrap(), 32);\n    let str_val = std::str::from_utf8(&buffer[..]).unwrap();\n    println!(\"{}\", str_val);\n\n    assert_eq!(file.read(&mut buffer).unwrap(), 32);\n    let str_val = std::str::from_utf8(&buffer[..]).unwrap();\n    println!(\"{}\", str_val);\n\n    assert_eq!(file.seek(SeekFrom::Start(123)).unwrap(), 123);\n    assert_eq!(file.read(&mut buffer).unwrap(), 32);\n    let str_val = std::str::from_utf8(&buffer[..]).unwrap();\n    println!(\"{}\", str_val);\n\n    assert_eq!(file.seek(SeekFrom::End(-123)).unwrap(), 6617);\n    assert_eq!(file.read(&mut buffer).unwrap(), 32);\n    let str_val = std::str::from_utf8(&buffer[..]).unwrap();\n    println!(\"{}\", str_val);\n\n    assert_eq!(file.seek(SeekFrom::Current(-250)).unwrap(), 6399);\n    assert_eq!(file.read(&mut buffer).unwrap(), 32);\n    let str_val = std::str::from_utf8(&buffer[..]).unwrap();\n    println!(\"{}\", str_val);\n\n    assert_eq!(file.seek(SeekFrom::Current(50)).unwrap(), 6481);\n    assert_eq!(file.read(&mut buffer).unwrap(), 32);\n    let str_val = std::str::from_utf8(&buffer[..]).unwrap();\n    println!(\"{}\", str_val);\n}", "item_id": 0, "repo": "bookmoons/wasmer", "file": "lib/wasi-tests/wasitests/fseek.rs", "last_update_at": "2019-12-28T04:17:46+00:00", "question_id": "9b9e9f65e1cf531c72ddcaf1ded2a4d1a6bce82e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    #[cfg(not(target_os = \"wasi\"))]\n    let mut base = PathBuf::from(\"wasitests/test_fs/hamlet\");\n    #[cfg(target_os = \"wasi\")]\n    let mut base = PathBuf::from(\".\");\n    base.push(\"act1/scene3.txt\");\n    let mut file = fs::File::open(&base).expect(\"Could not open file\");\n    let mut buffer = [0u8; 32];\n    assert_eq!(file.read(&mut buffer).unwrap(), 32);\n    let str_val = std::str::from_utf8(&buffer[..]).unwrap();\n    println!(\"{}\", str_val);\n    assert_eq!(file.read(&mut buffer).unwrap(), 32);\n    let str_val = std::str::from_utf8(&buffer[..]).unwrap();\n    println!(\"{}\", str_val);\n    assert_eq!(file.seek(SeekFrom::Start(123)).unwrap(), 123);\n    assert_eq!(file.read(&mut buffer).unwrap(), 32);\n    let str_val = std::str::from_utf8(&buffer[..]).unwrap();\n    println!(\"{}\", str_val);\n    assert_eq!(file.seek(SeekFrom::End(-123)).unwrap(), 6617);\n    assert_eq!(file.read(&mut buffer).unwrap(), 32);\n    let str_val = std::str::from_utf8(&buffer[..]).unwrap();\n    println!(\"{}\", str_val);\n    assert_eq!(file.seek(SeekFrom::Current(-250)).unwrap(), 6399);\n    assert_eq!(file.read(&mut buffer).unwrap(), 32);\n    let str_val = std::str::from_utf8(&buffer[..]).unwrap();\n    println!(\"{}\", str_val);\n    assert_eq!(file.seek(SeekFrom::Current(50)).unwrap(), 6481);\n    assert_eq!(file.read(&mut buffer).unwrap(), 32);\n    let str_val = std::str::from_utf8(&buffer[..]).unwrap();\n    println!(\"{}\", str_val);\n"]]}
{"hexsha": "54b8beb75521418242ccb9c0a2fe6112a22fca18", "ext": "rs", "lang": "Rust", "content": "fn broken_assert() {\n\t\tlet mut jdb = new_db();\n\n\t\t// history is 1\n\t\tlet foo = jdb.insert(EMPTY_PREFIX, b\"foo\");\n\t\tcommit_batch(&mut jdb, 1, &keccak(b\"1\"), Some((0, keccak(b\"0\")))).unwrap();\n\t\tassert!(jdb.can_reconstruct_refs());\n\n\t\t// foo is ancient history.\n\n\t\tjdb.remove(&foo, EMPTY_PREFIX);\n\t\tcommit_batch(&mut jdb, 2, &keccak(b\"2\"), Some((1, keccak(b\"1\")))).unwrap();\n\t\tassert!(jdb.can_reconstruct_refs());\n\n\t\tjdb.insert(EMPTY_PREFIX, b\"foo\");\n\t\tcommit_batch(&mut jdb, 3, &keccak(b\"3\"), Some((2, keccak(b\"2\")))).unwrap();\t// BROKEN\n\t\tassert!(jdb.can_reconstruct_refs());\n\t\tassert!(jdb.contains(&foo, EMPTY_PREFIX));\n\n\t\tjdb.remove(&foo, EMPTY_PREFIX);\n\t\tcommit_batch(&mut jdb, 4, &keccak(b\"4\"), Some((3, keccak(b\"3\")))).unwrap();\n\t\tassert!(jdb.can_reconstruct_refs());\n\n\t\tcommit_batch(&mut jdb, 5, &keccak(b\"5\"), Some((4, keccak(b\"4\")))).unwrap();\n\t\tassert!(jdb.can_reconstruct_refs());\n\t\tassert!(!jdb.contains(&foo, EMPTY_PREFIX));\n\t}", "item_id": 12, "repo": "altice-io/Daqiao", "file": "bridge/parity-ethereum/util/journaldb/src/earlymergedb.rs", "last_update_at": "2019-09-11T12:07:35+00:00", "question_id": "54b8beb75521418242ccb9c0a2fe6112a22fca18_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn broken_assert() {\n\t\tlet mut jdb = new_db();\n\t\t// history is 1\n\t\tlet foo = jdb.insert(EMPTY_PREFIX, b\"foo\");\n\t\tcommit_batch(&mut jdb, 1, &keccak(b\"1\"), Some((0, keccak(b\"0\")))).unwrap();\n\t\tassert!(jdb.can_reconstruct_refs());\n\t\t// foo is ancient history.\n\t\tjdb.remove(&foo, EMPTY_PREFIX);\n\t\tcommit_batch(&mut jdb, 2, &keccak(b\"2\"), Some((1, keccak(b\"1\")))).unwrap();\n\t\tassert!(jdb.can_reconstruct_refs());\n\t\tjdb.insert(EMPTY_PREFIX, b\"foo\");\n\t\tcommit_batch(&mut jdb, 3, &keccak(b\"3\"), Some((2, keccak(b\"2\")))).unwrap();\t// BROKEN\n\t\tassert!(jdb.can_reconstruct_refs());\n\t\tassert!(jdb.contains(&foo, EMPTY_PREFIX));\n\t\tjdb.remove(&foo, EMPTY_PREFIX);\n\t\tcommit_batch(&mut jdb, 4, &keccak(b\"4\"), Some((3, keccak(b\"3\")))).unwrap();\n\t\tassert!(jdb.can_reconstruct_refs());\n\t\tcommit_batch(&mut jdb, 5, &keccak(b\"5\"), Some((4, keccak(b\"4\")))).unwrap();\n\t\tassert!(jdb.can_reconstruct_refs());\n\t\tassert!(!jdb.contains(&foo, EMPTY_PREFIX));\n"]]}
{"hexsha": "3d04a24ccc60e218d2ba1fd7d36833082eed6fc1", "ext": "rs", "lang": "Rust", "content": "fn ctrl_c_kills_everyone() {\n    if !enabled() {\n        return\n    }\n\n    let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n    let addr = listener.local_addr().unwrap();\n\n    let p = project(\"foo\")\n        .file(\"Cargo.toml\", r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.0.1\"\n            authors = []\n            build = \"build.rs\"\n        \"#)\n        .file(\"src/lib.rs\", \"\")\n        .file(\"build.rs\", &format!(r#\"\n            use std::net::TcpStream;\n            use std::io::Read;\n\n            fn main() {{\n                let mut socket = TcpStream::connect(\"{}\").unwrap();\n                let _ = socket.read(&mut [0; 10]);\n                panic!(\"that read should never return\");\n            }}\n        \"#, addr))\n        .build();\n\n    let mut cargo = p.cargo(\"build\").build_command();\n    cargo.stdin(Stdio::piped())\n         .stdout(Stdio::piped())\n         .stderr(Stdio::piped())\n         .env(\"__CARGO_TEST_SETSID_PLEASE_DONT_USE_ELSEWHERE\", \"1\");\n    let mut child = cargo.spawn().unwrap();\n\n    let mut sock = listener.accept().unwrap().0;\n    ctrl_c(&mut child);\n\n    assert!(!child.wait().unwrap().success());\n    match sock.read(&mut [0; 10]) {\n        Ok(n) => assert_eq!(n, 0),\n        Err(e) => assert_eq!(e.kind(), io::ErrorKind::ConnectionReset),\n    }\n\n    // Ok so what we just did was spawn cargo that spawned a build script, then\n    // we killed cargo in hopes of it killing the build script as well. If all\n    // went well the build script is now dead. On Windows, however, this is\n    // enforced with job objects which means that it may actually be in the\n    // *process* of being torn down at this point.\n    //\n    // Now on Windows we can't completely remove a file until all handles to it\n    // have been closed. Including those that represent running processes. So if\n    // we were to return here then there may still be an open reference to some\n    // file in the build directory. What we want to actually do is wait for the\n    // build script to *complete* exit. Take care of that by blowing away the\n    // build directory here, and panicking if we eventually spin too long\n    // without being able to.\n    for i in 0..10 {\n        match fs::remove_dir_all(&p.root().join(\"target\")) {\n            Ok(()) => return,\n            Err(e) => println!(\"attempt {}: {}\", i, e),\n        }\n        thread::sleep(Duration::from_millis(100));\n    }\n\n    panic!(\"couldn't remove build directory after a few tries, seems like \\\n            we won't be able to!\");\n}", "item_id": 1, "repo": "roblabla/cargo", "file": "tests/death.rs", "last_update_at": "2019-07-19T20:12:12+00:00", "question_id": "3d04a24ccc60e218d2ba1fd7d36833082eed6fc1_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn ctrl_c_kills_everyone() {\n    if !enabled() {\n        return\n    }\n    let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n    let addr = listener.local_addr().unwrap();\n    let p = project(\"foo\")\n        .file(\"Cargo.toml\", r#\"\n            [package]\n            name = \"foo\"\n            version = \"0.0.1\"\n            authors = []\n            build = \"build.rs\"\n        \"#)\n        .file(\"src/lib.rs\", \"\")\n        .file(\"build.rs\", &format!(r#\"\n            use std::net::TcpStream;\n            use std::io::Read;\n            fn main() {{\n                let mut socket = TcpStream::connect(\"{}\").unwrap();\n                let _ = socket.read(&mut [0; 10]);\n                panic!(\"that read should never return\");\n            }}\n        \"#, addr))\n        .build();\n    let mut cargo = p.cargo(\"build\").build_command();\n    cargo.stdin(Stdio::piped())\n         .stdout(Stdio::piped())\n         .stderr(Stdio::piped())\n         .env(\"__CARGO_TEST_SETSID_PLEASE_DONT_USE_ELSEWHERE\", \"1\");\n    let mut child = cargo.spawn().unwrap();\n    let mut sock = listener.accept().unwrap().0;\n    ctrl_c(&mut child);\n    assert!(!child.wait().unwrap().success());\n    match sock.read(&mut [0; 10]) {\n        Ok(n) => assert_eq!(n, 0),\n        Err(e) => assert_eq!(e.kind(), io::ErrorKind::ConnectionReset),\n    }\n    // Ok so what we just did was spawn cargo that spawned a build script, then\n    // we killed cargo in hopes of it killing the build script as well. If all\n    // went well the build script is now dead. On Windows, however, this is\n    // enforced with job objects which means that it may actually be in the\n    // *process* of being torn down at this point.\n    //\n    // Now on Windows we can't completely remove a file until all handles to it\n    // have been closed. Including those that represent running processes. So if\n    // we were to return here then there may still be an open reference to some\n    // file in the build directory. What we want to actually do is wait for the\n    // build script to *complete* exit. Take care of that by blowing away the\n    // build directory here, and panicking if we eventually spin too long\n    // without being able to.\n    for i in 0..10 {\n        match fs::remove_dir_all(&p.root().join(\"target\")) {\n            Ok(()) => return,\n            Err(e) => println!(\"attempt {}: {}\", i, e),\n        }\n        thread::sleep(Duration::from_millis(100));\n    }\n    panic!(\"couldn't remove build directory after a few tries, seems like \\\n            we won't be able to!\");\n"]]}
{"hexsha": "3d55062c5244f88dcd462a368f5ca932bdf94007", "ext": "rs", "lang": "Rust", "content": "fn spec_test_345() {\n    let original = r##\"`<http://foo.bar.`baz>`\n\"##;\n    let expected = r##\"<p><code>&lt;http://foo.bar.</code>baz&gt;`</p>\n\"##;\n\n    test_markdown_html(original, expected);\n}", "item_id": 344, "repo": "NaokiM03/pulldown-cmark", "file": "tests/suite/spec.rs", "last_update_at": "2019-07-11T13:20:46+00:00", "question_id": "3d55062c5244f88dcd462a368f5ca932bdf94007_344", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn spec_test_345() {\n    let original = r##\"`<http://foo.bar.`baz>`\n\"##;\n    let expected = r##\"<p><code>&lt;http://foo.bar.</code>baz&gt;`</p>\n\"##;\n    test_markdown_html(original, expected);\n"]]}
{"hexsha": "3d55062c5244f88dcd462a368f5ca932bdf94007", "ext": "rs", "lang": "Rust", "content": "fn spec_test_567() {\n    let original = r##\"[foo][bar][baz]\n\n[baz]: /url1\n[foo]: /url2\n\"##;\n    let expected = r##\"<p>[foo]<a href=\"/url1\">bar</a></p>\n\"##;\n\n    test_markdown_html(original, expected);\n}", "item_id": 566, "repo": "NaokiM03/pulldown-cmark", "file": "tests/suite/spec.rs", "last_update_at": "2019-07-11T13:20:46+00:00", "question_id": "3d55062c5244f88dcd462a368f5ca932bdf94007_566", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn spec_test_567() {\n    let original = r##\"[foo][bar][baz]\n[baz]: /url1\n[foo]: /url2\n\"##;\n    let expected = r##\"<p>[foo]<a href=\"/url1\">bar</a></p>\n\"##;\n    test_markdown_html(original, expected);\n"]]}
{"hexsha": "ddfa5c7090f7a002f54a5495b9709a608fa6affe", "ext": "rs", "lang": "Rust", "content": "fn read_inner_header_field<R: Read>(input: &mut R, database: &mut PwDatabase, kdbx: &mut Kdbx, buffer: &mut Vec<u8>) -> Result<bool, Error> {\n    let field_id = ioutil::io_read_u8(input)?;\n    let size = ioutil::io_read_i32(input)?;\n\n    println!(\"INNER HEADER ITEM: {}, {} ({})\", field_id, size, size as usize);\n\n    if size < 0 {\n        return Err(Error::BadFormat(\"File Corrupted (inner header field size)\"));\n    } else {\n        buffer.resize(size as usize, 0);\n        input.read_exact(&mut buffer[0..(size as usize)]).map_err(|e| Error::IO(e))?;\n    }\n\n    let data = &buffer[0..(size as usize)];\n\n    let mut result = true;\n\n    match KdbxInnerHeaderFieldID::from_bits(field_id) {\n        Some(KdbxInnerHeaderFieldID::END_OF_HEADER) => {\n            result = false; // returning false indicates the end of the header\n        },\n\n        Some(KdbxInnerHeaderFieldID::INNER_RANDOM_STREAM_ID) => {\n            let stream_id = memutil::bytes_to_u32(data);\n            if let Some(alg) = CrsAlgorithm::from_int(stream_id) {\n                kdbx.inner_random_stream_algorithm = alg;\n            } else {\n                return Err(Error::BadFormat(\"Unknown stream cipher algorithm.\"));\n            }\n            debug_println!(\"Set InnerRandomStreamID. (inner header)\");\n        },\n\n        Some(KdbxInnerHeaderFieldID::INNER_RANDOM_STREAM_KEY) => {\n            kdbx.inner_random_stream_key = ProtectedBinary::copy_slice(data);\n            debug_println!(\"Set InnerRandomStreamKey. (inner header)\");\n            database.context.crypto_random.add_entropy(data);\n        },\n\n        Some(KdbxInnerHeaderFieldID::BINARY) => {\n            debug_println!(\"Added binary with length: {}\", data.len());\n            kdbx.binaries.push(ProtectedBinary::copy_slice(data));\n        },\n\n        Some(_) => {\n            debug_println!(\"Unhandled Known Inner Header ID: {:b}\", field_id);\n        },\n\n        _ => {\n            debug_println!(\"Unknown Inner Header ID: {:b}\", field_id);\n        }\n    }\n\n    Ok(result)\n}", "item_id": 10, "repo": "ExPixel/KeePass", "file": "src/kdbx/read.rs", "last_update_at": "2019-11-30T15:47:42+00:00", "question_id": "ddfa5c7090f7a002f54a5495b9709a608fa6affe_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_inner_header_field<R: Read>(input: &mut R, database: &mut PwDatabase, kdbx: &mut Kdbx, buffer: &mut Vec<u8>) -> Result<bool, Error> {\n    let field_id = ioutil::io_read_u8(input)?;\n    let size = ioutil::io_read_i32(input)?;\n    println!(\"INNER HEADER ITEM: {}, {} ({})\", field_id, size, size as usize);\n    if size < 0 {\n        return Err(Error::BadFormat(\"File Corrupted (inner header field size)\"));\n    } else {\n        buffer.resize(size as usize, 0);\n        input.read_exact(&mut buffer[0..(size as usize)]).map_err(|e| Error::IO(e))?;\n    }\n    let data = &buffer[0..(size as usize)];\n    let mut result = true;\n    match KdbxInnerHeaderFieldID::from_bits(field_id) {\n        Some(KdbxInnerHeaderFieldID::END_OF_HEADER) => {\n            result = false; // returning false indicates the end of the header\n        },\n        Some(KdbxInnerHeaderFieldID::INNER_RANDOM_STREAM_ID) => {\n            let stream_id = memutil::bytes_to_u32(data);\n            if let Some(alg) = CrsAlgorithm::from_int(stream_id) {\n                kdbx.inner_random_stream_algorithm = alg;\n            } else {\n                return Err(Error::BadFormat(\"Unknown stream cipher algorithm.\"));\n            }\n            debug_println!(\"Set InnerRandomStreamID. (inner header)\");\n        },\n        Some(KdbxInnerHeaderFieldID::INNER_RANDOM_STREAM_KEY) => {\n            kdbx.inner_random_stream_key = ProtectedBinary::copy_slice(data);\n            debug_println!(\"Set InnerRandomStreamKey. (inner header)\");\n            database.context.crypto_random.add_entropy(data);\n        },\n        Some(KdbxInnerHeaderFieldID::BINARY) => {\n            debug_println!(\"Added binary with length: {}\", data.len());\n            kdbx.binaries.push(ProtectedBinary::copy_slice(data));\n        },\n        Some(_) => {\n            debug_println!(\"Unhandled Known Inner Header ID: {:b}\", field_id);\n        },\n        _ => {\n            debug_println!(\"Unknown Inner Header ID: {:b}\", field_id);\n        }\n    }\n    Ok(result)\n"]]}
{"hexsha": "2c478637fdfd8fa877b4ed05be953f3a34c4a251", "ext": "rs", "lang": "Rust", "content": "fn decode_png(png_data: &[u8]) -> Box<[u8]> {\n    let decoder = png::Decoder::new(png_data);\n    let (info, mut reader) = decoder.read_info().unwrap();\n    let mut buf = vec![0; info.buffer_size()];\n    reader.next_frame(&mut buf).unwrap();\n    buf.into_boxed_slice()\n}", "item_id": 0, "repo": "maroider/flif.rs", "file": "flif/tests/png_equality.rs", "last_update_at": "2019-07-04T10:17:46+00:00", "question_id": "2c478637fdfd8fa877b4ed05be953f3a34c4a251_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn decode_png(png_data: &[u8]) -> Box<[u8]> {\n    let decoder = png::Decoder::new(png_data);\n    let (info, mut reader) = decoder.read_info().unwrap();\n    let mut buf = vec![0; info.buffer_size()];\n    reader.next_frame(&mut buf).unwrap();\n    buf.into_boxed_slice()\n"]]}
{"hexsha": "9e39d8f82fe31b0658e57ea626596d2de50ea866", "ext": "rs", "lang": "Rust", "content": "fn no_version_returns_none() {\n        let mut installs = SystemLabviewInstalls::new();\n\n        let install = LabviewInstall {\n            version: String::from(\"2011\"),\n            bitness: Bitness::X64,\n            path: PathBuf::from(\"C:\\\\LV2011_64\"),\n        };\n\n        installs.add_install(install);\n\n        // Non-existant version\n        assert_eq!(installs.get_version(\"2012\", Bitness::X64), None);\n    }", "item_id": 3, "repo": "JamesMc86/LabVIEW-CLI", "file": "rust-proxy/src/labview/installs.rs", "last_update_at": "2019-04-02T09:55:35+00:00", "question_id": "9e39d8f82fe31b0658e57ea626596d2de50ea866_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn no_version_returns_none() {\n        let mut installs = SystemLabviewInstalls::new();\n        let install = LabviewInstall {\n            version: String::from(\"2011\"),\n            bitness: Bitness::X64,\n            path: PathBuf::from(\"C:\\\\LV2011_64\"),\n        };\n        installs.add_install(install);\n        // Non-existant version\n        assert_eq!(installs.get_version(\"2012\", Bitness::X64), None);\n"]]}
{"hexsha": "cf3e338740762f28621308c6cfbf7ad647da243d", "ext": "rs", "lang": "Rust", "content": "unsafe extern \"C\" fn notify_domain_trampoline<P>(this: *mut ffi::GMountOperation, _param_spec: glib_ffi::gpointer, f: glib_ffi::gpointer)\nwhere P: IsA<MountOperation> {\n    callback_guard!();\n    let f: &&(Fn(&P) + 'static) = transmute(f);\n    f(&MountOperation::from_glib_borrow(this).downcast_unchecked())\n}", "item_id": 6, "repo": "ystreet/gio", "file": "src/auto/mount_operation.rs", "last_update_at": "2019-08-16T16:25:27+00:00", "question_id": "cf3e338740762f28621308c6cfbf7ad647da243d_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["unsafe extern \"C\" fn notify_domain_trampoline<P>(this: *mut ffi::GMountOperation, _param_spec: glib_ffi::gpointer, f: glib_ffi::gpointer)\nwhere P: IsA<MountOperation> {\n    callback_guard!();\n    let f: &&(Fn(&P) + 'static) = transmute(f);\n    f(&MountOperation::from_glib_borrow(this).downcast_unchecked())\n"]]}
{"hexsha": "6eca1beef00d0196dc32d05050d7dd673c20c177", "ext": "rs", "lang": "Rust", "content": "fn test_get_nweights() {\n        let xornet = build_small_network();\n        let nweights = xornet.nweights();\n        assert_eq!(nweights, (2 * 4) + (4 * 4) + (4 * 2));\n    }", "item_id": 5, "repo": "MaxStrange/roboarm", "file": "experiment/src/network.rs", "last_update_at": "2019-10-07T04:23:33+00:00", "question_id": "6eca1beef00d0196dc32d05050d7dd673c20c177_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_get_nweights() {\n        let xornet = build_small_network();\n        let nweights = xornet.nweights();\n        assert_eq!(nweights, (2 * 4) + (4 * 4) + (4 * 2));\n"]]}
{"hexsha": "d353aab467ce9d2579c72ac83df3bff28b8029c3", "ext": "rs", "lang": "Rust", "content": "fn encode_works() {\n        let bytes = TEST_BYTES;\n        let encoded = Key::from(bytes).encode();\n        assert_eq!(encoded, bytes);\n    }", "item_id": 3, "repo": "kaiweicai/ink-example", "file": "crates/primitives/src/tests.rs", "last_update_at": "2019-04-20T01:12:47+00:00", "question_id": "d353aab467ce9d2579c72ac83df3bff28b8029c3_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn encode_works() {\n        let bytes = TEST_BYTES;\n        let encoded = Key::from(bytes).encode();\n        assert_eq!(encoded, bytes);\n"]]}
{"hexsha": "c75afb5f19a284ebd979979d7ff68fda1a67d5e2", "ext": "rs", "lang": "Rust", "content": "fn read_coils() {\n            assert!(Request::try_from(Bytes::from(vec![0x01])).is_err());\n            assert!(Request::try_from(Bytes::from(vec![0x01, 0x0, 0x0, 0x22])).is_err());\n\n            let bytes = Bytes::from(vec![0x01, 0x00, 0x12, 0x0, 0x4]);\n            let req = Request::try_from(bytes).unwrap();\n            assert_eq!(req, Request::ReadCoils(0x12, 4));\n        }", "item_id": 19, "repo": "mosolovsa/tokio-modbus", "file": "src/codec/mod.rs", "last_update_at": "2019-04-03T10:10:55+00:00", "question_id": "c75afb5f19a284ebd979979d7ff68fda1a67d5e2_19", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn read_coils() {\n            assert!(Request::try_from(Bytes::from(vec![0x01])).is_err());\n            assert!(Request::try_from(Bytes::from(vec![0x01, 0x0, 0x0, 0x22])).is_err());\n            let bytes = Bytes::from(vec![0x01, 0x00, 0x12, 0x0, 0x4]);\n            let req = Request::try_from(bytes).unwrap();\n            assert_eq!(req, Request::ReadCoils(0x12, 4));\n"]]}
{"hexsha": "8a4504989d5a3208514b06723b5bdf36fcdf6aa3", "ext": "rs", "lang": "Rust", "content": "fn test_simple_operator_gt_plaintext_parse() {\n        let name1 = _random_string(10);\n        let value1 = _random_string(10);\n\n        let json = format!(r#\"{{\"~{}\":{{\"$gt\":\"{}\"}}}}\"#, name1, value1);\n\n        let query = parse_from_json(&json).unwrap();\n\n        let expected = Operator::Gt(\n            TagName::PlainTagName(name1.to_vec()),\n            TargetValue::Unencrypted(value1.clone())\n        );\n\n        assert_eq!(query, expected);\n    }", "item_id": 10, "repo": "cobear25/indy-sdk", "file": "libindy/src/services/wallet/language.rs", "last_update_at": "2019-05-22T08:47:56+00:00", "question_id": "8a4504989d5a3208514b06723b5bdf36fcdf6aa3_10", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_simple_operator_gt_plaintext_parse() {\n        let name1 = _random_string(10);\n        let value1 = _random_string(10);\n        let json = format!(r#\"{{\"~{}\":{{\"$gt\":\"{}\"}}}}\"#, name1, value1);\n        let query = parse_from_json(&json).unwrap();\n        let expected = Operator::Gt(\n            TagName::PlainTagName(name1.to_vec()),\n            TargetValue::Unencrypted(value1.clone())\n        );\n        assert_eq!(query, expected);\n"]]}
{"hexsha": "9497e53cee4b782f8881996dd18888c313d8c29b", "ext": "rs", "lang": "Rust", "content": "pub extern \"C\" fn vmovd_freg_mem(buf: &mut Assembler, dst: XMMRegister, src: Mem) {\n    emit_vex_prefixfm(buf,\n                      dst,\n                      XMM0,\n                      unsafe { mem::transmute(src) },\n                      VectorLength::kL128,\n                      SIMDPrefix::k0x66,\n                      LeadingOpcode::k0F,\n                      VexW::W0);\n    buf.emit(0x6e);\n    emit_sse_mem_f(buf, dst, src);\n}", "item_id": 13, "repo": "jazz-lang/Jazz-jit", "file": "src/avx.rs", "last_update_at": "2019-10-03T22:34:02+00:00", "question_id": "9497e53cee4b782f8881996dd18888c313d8c29b_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub extern \"C\" fn vmovd_freg_mem(buf: &mut Assembler, dst: XMMRegister, src: Mem) {\n    emit_vex_prefixfm(buf,\n                      dst,\n                      XMM0,\n                      unsafe { mem::transmute(src) },\n                      VectorLength::kL128,\n                      SIMDPrefix::k0x66,\n                      LeadingOpcode::k0F,\n                      VexW::W0);\n    buf.emit(0x6e);\n    emit_sse_mem_f(buf, dst, src);\n"]]}
{"hexsha": "87cb1786258851c4332c6427e21a561f3fc5a20d", "ext": "rs", "lang": "Rust", "content": "fn is_used_in_encryption() {\n        let tmp_dir = TempDir::new(\"emerald-global-key-test\").unwrap();\n        let vault = VaultStorage::create(tmp_dir.path()).unwrap();\n\n        let global_store = vault.global_key();\n        global_store.create(\"test-1\").unwrap();\n        let global = Some(global_store.get().unwrap());\n\n        let seed_id = vault.seeds().add(\n            Seed::test_generate(None, \"test-1\".as_bytes(), global.clone()).unwrap()\n        ).unwrap();\n\n        let seed_source = vault.seeds().get(seed_id).unwrap().source;\n\n        let get_no_global = seed_source.get_addresses::<EthereumAddress>(\n            Some(\"test-1\".to_string()),\n            None,\n            &vec![StandardHDPath::from_str(\"m/44'/60'/0'/0/0\").unwrap()],\n            Blockchain::Ethereum,\n        );\n\n        assert!(get_no_global.is_err());\n\n        let get_w_global = seed_source.get_addresses::<EthereumAddress>(\n            Some(\"test-1\".to_string()),\n            global,\n            &vec![StandardHDPath::from_str(\"m/44'/60'/0'/0/0\").unwrap()],\n            Blockchain::Ethereum,\n        );\n\n        println!(\"Result: {:?}\", get_w_global);\n\n        assert!(get_w_global.is_ok());\n    }", "item_id": 7, "repo": "ETCDEVTeam/emerald-rs", "file": "src/storage/global_key.rs", "last_update_at": "2019-07-24T23:50:52+00:00", "question_id": "87cb1786258851c4332c6427e21a561f3fc5a20d_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn is_used_in_encryption() {\n        let tmp_dir = TempDir::new(\"emerald-global-key-test\").unwrap();\n        let vault = VaultStorage::create(tmp_dir.path()).unwrap();\n        let global_store = vault.global_key();\n        global_store.create(\"test-1\").unwrap();\n        let global = Some(global_store.get().unwrap());\n        let seed_id = vault.seeds().add(\n            Seed::test_generate(None, \"test-1\".as_bytes(), global.clone()).unwrap()\n        ).unwrap();\n        let seed_source = vault.seeds().get(seed_id).unwrap().source;\n        let get_no_global = seed_source.get_addresses::<EthereumAddress>(\n            Some(\"test-1\".to_string()),\n            None,\n            &vec![StandardHDPath::from_str(\"m/44'/60'/0'/0/0\").unwrap()],\n            Blockchain::Ethereum,\n        );\n        assert!(get_no_global.is_err());\n        let get_w_global = seed_source.get_addresses::<EthereumAddress>(\n            Some(\"test-1\".to_string()),\n            global,\n            &vec![StandardHDPath::from_str(\"m/44'/60'/0'/0/0\").unwrap()],\n            Blockchain::Ethereum,\n        );\n        println!(\"Result: {:?}\", get_w_global);\n        assert!(get_w_global.is_ok());\n"]]}
{"hexsha": "6c421ef40e41eb38a8a331c1c4bac35636e5c39b", "ext": "rs", "lang": "Rust", "content": "fn make_fixture(size: usize, cos: bool) -> Vec<f32> {\n        let step = f32::consts::PI * 2.0 / size as f32;\n        let mut data = Vec::new();\n        let mut value = 0.0f32;\n        for _ in 0..size {\n            data.push(value.sin());\n            if cos { data.push(value.cos()); }\n            value += step;\n        }\n        data\n    }", "item_id": 2, "repo": "whitequark/samplerate-rs", "file": "samplerate/src/lib.rs", "last_update_at": "2019-11-04T01:23:00+00:00", "question_id": "6c421ef40e41eb38a8a331c1c4bac35636e5c39b_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn make_fixture(size: usize, cos: bool) -> Vec<f32> {\n        let step = f32::consts::PI * 2.0 / size as f32;\n        let mut data = Vec::new();\n        let mut value = 0.0f32;\n        for _ in 0..size {\n            data.push(value.sin());\n            if cos { data.push(value.cos()); }\n            value += step;\n        }\n        data\n"]]}
{"hexsha": "707201530c4d90617d12d9c9ffeb66d1ca2dbc1a", "ext": "rs", "lang": "Rust", "content": "pub fn set_option_max_crawl_states(\n    service: &ZapService,\n    integer: String,\n) -> Result<Value, ZapApiError> {\n    let mut params = HashMap::new();\n    params.insert(\"Integer\".to_string(), integer);\n    super::call(\n        service,\n        \"ajaxSpider\",\n        \"action\",\n        \"setOptionMaxCrawlStates\",\n        params,\n    )\n}", "item_id": 8, "repo": "cak/zap-api-rust", "file": "src/ajax_spider.rs", "last_update_at": "2019-05-23T12:34:22+00:00", "question_id": "707201530c4d90617d12d9c9ffeb66d1ca2dbc1a_8", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn set_option_max_crawl_states(\n    service: &ZapService,\n    integer: String,\n) -> Result<Value, ZapApiError> {\n    let mut params = HashMap::new();\n    params.insert(\"Integer\".to_string(), integer);\n    super::call(\n        service,\n        \"ajaxSpider\",\n        \"action\",\n        \"setOptionMaxCrawlStates\",\n        params,\n    )\n"]]}
{"hexsha": "b54b272ada64b327872d8ddb397b5309707a3565", "ext": "rs", "lang": "Rust", "content": "pub fn read_next_spendable_mc_index(\n    db: &Connection,\n    kind: &str,\n    address: &str,\n    conflict_units: &[String],\n) -> Result<u32> {\n    let sql = if !conflict_units.is_empty() {\n        let conflict_units_list = conflict_units\n            .iter()\n            .map(|s| format!(\"'{}'\", s))\n            .collect::<Vec<_>>()\n            .join(\", \");\n        format!(\n            \"SELECT to_main_chain_index FROM inputs CROSS JOIN units USING(unit) \\\n             WHERE type={} AND address={} AND sequence='good' \\\n             AND unit NOT IN({}) \\\n             ORDER BY to_main_chain_index DESC LIMIT 1\",\n            kind, address, conflict_units_list\n        )\n    } else {\n        format!(\n            \"SELECT to_main_chain_index FROM inputs CROSS JOIN units USING(unit) \\\n             WHERE type={} AND address={} AND sequence='good' \\\n             ORDER BY to_main_chain_index DESC LIMIT 1\",\n            kind, address\n        )\n    };\n\n    let mut stmt = db.prepare(&sql)?;\n    let mut rows = stmt.query_map(&[], |row| row.get::<_, u32>(0))?;\n    let row = rows.next();\n    if row.is_none() {\n        Ok(0)\n    } else {\n        Ok(row.unwrap()? + 1)\n    }\n}", "item_id": 0, "repo": "ringringringring/rust-trustnote", "file": "src/mc_outputs.rs", "last_update_at": "2019-05-28T10:59:27+00:00", "question_id": "b54b272ada64b327872d8ddb397b5309707a3565_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn read_next_spendable_mc_index(\n    db: &Connection,\n    kind: &str,\n    address: &str,\n    conflict_units: &[String],\n) -> Result<u32> {\n    let sql = if !conflict_units.is_empty() {\n        let conflict_units_list = conflict_units\n            .iter()\n            .map(|s| format!(\"'{}'\", s))\n            .collect::<Vec<_>>()\n            .join(\", \");\n        format!(\n            \"SELECT to_main_chain_index FROM inputs CROSS JOIN units USING(unit) \\\n             WHERE type={} AND address={} AND sequence='good' \\\n             AND unit NOT IN({}) \\\n             ORDER BY to_main_chain_index DESC LIMIT 1\",\n            kind, address, conflict_units_list\n        )\n    } else {\n        format!(\n            \"SELECT to_main_chain_index FROM inputs CROSS JOIN units USING(unit) \\\n             WHERE type={} AND address={} AND sequence='good' \\\n             ORDER BY to_main_chain_index DESC LIMIT 1\",\n            kind, address\n        )\n    };\n    let mut stmt = db.prepare(&sql)?;\n    let mut rows = stmt.query_map(&[], |row| row.get::<_, u32>(0))?;\n    let row = rows.next();\n    if row.is_none() {\n        Ok(0)\n    } else {\n        Ok(row.unwrap()? + 1)\n    }\n"]]}
{"hexsha": "40ec2526cd056075e8da11b41ee7afd67fd91c90", "ext": "rs", "lang": "Rust", "content": "fn test_sort_stakes_basic() {\n        let pubkey0 = Pubkey::new_rand();\n        let pubkey1 = Pubkey::new_rand();\n        let mut stakes = vec![(pubkey0, 1), (pubkey1, 2)];\n        sort_stakes(&mut stakes);\n        assert_eq!(stakes, vec![(pubkey1, 2), (pubkey0, 1)]);\n    }", "item_id": 7, "repo": "abalaki6/solana", "file": "core/src/leader_schedule_utils.rs", "last_update_at": "2019-03-10T22:29:28+00:00", "question_id": "40ec2526cd056075e8da11b41ee7afd67fd91c90_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_sort_stakes_basic() {\n        let pubkey0 = Pubkey::new_rand();\n        let pubkey1 = Pubkey::new_rand();\n        let mut stakes = vec![(pubkey0, 1), (pubkey1, 2)];\n        sort_stakes(&mut stakes);\n        assert_eq!(stakes, vec![(pubkey1, 2), (pubkey0, 1)]);\n"]]}
{"hexsha": "d749a804fa24c468a7add811d430483e8a35f6e9", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    use std::collections::{HashMap, HashSet};\n\n    let input = adventofcode::read_input_file();\n\n    let mut dists = HashMap::<(&str, &str), u32>::new();\n    let mut places = HashSet::<&str>::new();\n\n    for line in input.lines() {\n        let words: Vec<&str> = line.split_whitespace().collect();\n        match words[..] {\n            [a, \"to\", b, \"=\", dist] => {\n                let dist = dist.parse::<u32>().expect(\"not an integer\");\n                dists.insert((a, b), dist);\n                dists.insert((b, a), dist);\n                places.insert(a);\n                places.insert(b);\n            }\n            _ => panic!(\"Unrecognized line {:?}\", line),\n        }\n    }\n\n    let mut min_dist = std::u32::MAX;\n    let mut max_dist = 0;\n\n    let mut places: Vec<_> = places.iter().collect();\n\n    adventofcode::each_perm(&mut places, |path| {\n        let dist = path\n            .iter()\n            .zip(path.iter().skip(1))\n            .map(|(&&a, &&b)| dists[&(a, b)])\n            .sum::<u32>();\n        if dist < min_dist {\n            min_dist = dist;\n        }\n        if dist > max_dist {\n            max_dist = dist;\n        }\n    });\n\n    println!(\"{}\", min_dist);\n    println!(\"{}\", max_dist);\n}", "item_id": 0, "repo": "petertseng/adventofcode-rs-2015", "file": "src/bin/09_hamiltonian.rs", "last_update_at": "2019-06-25T06:14:33+00:00", "question_id": "d749a804fa24c468a7add811d430483e8a35f6e9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    use std::collections::{HashMap, HashSet};\n    let input = adventofcode::read_input_file();\n    let mut dists = HashMap::<(&str, &str), u32>::new();\n    let mut places = HashSet::<&str>::new();\n    for line in input.lines() {\n        let words: Vec<&str> = line.split_whitespace().collect();\n        match words[..] {\n            [a, \"to\", b, \"=\", dist] => {\n                let dist = dist.parse::<u32>().expect(\"not an integer\");\n                dists.insert((a, b), dist);\n                dists.insert((b, a), dist);\n                places.insert(a);\n                places.insert(b);\n            }\n            _ => panic!(\"Unrecognized line {:?}\", line),\n        }\n    }\n    let mut min_dist = std::u32::MAX;\n    let mut max_dist = 0;\n    let mut places: Vec<_> = places.iter().collect();\n    adventofcode::each_perm(&mut places, |path| {\n        let dist = path\n            .iter()\n            .zip(path.iter().skip(1))\n            .map(|(&&a, &&b)| dists[&(a, b)])\n            .sum::<u32>();\n        if dist < min_dist {\n            min_dist = dist;\n        }\n        if dist > max_dist {\n            max_dist = dist;\n        }\n    });\n    println!(\"{}\", min_dist);\n    println!(\"{}\", max_dist);\n"]]}
{"hexsha": "28be31fdab926ee2f934b2f9d1a00757e8b486b4", "ext": "rs", "lang": "Rust", "content": "fn block_stretch(\n    input: image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>>,\n    rng: &mut rand_xoshiro::Xoshiro256StarStar,\n    size: u32,\n    range: u32,\n) -> image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>> {\n    println!(\"BlockStretch FX\");\n\n    let mut output = input.clone();\n    let (width, height) = input.dimensions();\n    let times = 128;\n    let range_begin = if height - range == 0 { 0 } else { rng.gen_range(0, height - range) };\n\n    for _ in 0..times {\n        let noise_x = rng.gen_range(0, width);\n        let noise_y = rng.gen_range(0, range) + range_begin;\n\n        // Snap\n        let noise_x = (noise_x as f32 / size as f32).round() as u32 * size;\n        let noise_y = (noise_y as f32 / size as f32).round() as u32 * size;\n\n        let direction = rng.gen_range(0, 2);\n\n        if direction == 0 {\n            for i in 0..size {\n                let dst_x = noise_x + i;\n                let dst_y = noise_y;\n\n                if dst_x >= width { continue; }\n\n                for j in 0..size {\n                    if dst_y + j >= height { continue; }\n\n                    output.put_pixel(dst_x, dst_y + j, *input.get_pixel(noise_x, noise_y + j));\n                }\n            }\n        } else {\n            for i in 0..size {\n                let dst_x = noise_x;\n                let dst_y = noise_y + i;\n\n                if dst_y >= height { continue; }\n\n                for j in 0..size {\n                    if dst_x + j >= width { continue; }\n\n                    output.put_pixel(dst_x + j, dst_y, *input.get_pixel(noise_x + j, noise_y));\n                }\n            }\n        }\n    }\n\n    output\n}", "item_id": 3, "repo": "syuilo/glitch-studio-rs", "file": "src/main.rs", "last_update_at": "2019-09-16T23:30:56+00:00", "question_id": "28be31fdab926ee2f934b2f9d1a00757e8b486b4_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn block_stretch(\n    input: image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>>,\n    rng: &mut rand_xoshiro::Xoshiro256StarStar,\n    size: u32,\n    range: u32,\n) -> image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>> {\n    println!(\"BlockStretch FX\");\n    let mut output = input.clone();\n    let (width, height) = input.dimensions();\n    let times = 128;\n    let range_begin = if height - range == 0 { 0 } else { rng.gen_range(0, height - range) };\n    for _ in 0..times {\n        let noise_x = rng.gen_range(0, width);\n        let noise_y = rng.gen_range(0, range) + range_begin;\n        // Snap\n        let noise_x = (noise_x as f32 / size as f32).round() as u32 * size;\n        let noise_y = (noise_y as f32 / size as f32).round() as u32 * size;\n        let direction = rng.gen_range(0, 2);\n        if direction == 0 {\n            for i in 0..size {\n                let dst_x = noise_x + i;\n                let dst_y = noise_y;\n                if dst_x >= width { continue; }\n                for j in 0..size {\n                    if dst_y + j >= height { continue; }\n                    output.put_pixel(dst_x, dst_y + j, *input.get_pixel(noise_x, noise_y + j));\n                }\n            }\n        } else {\n            for i in 0..size {\n                let dst_x = noise_x;\n                let dst_y = noise_y + i;\n                if dst_y >= height { continue; }\n                for j in 0..size {\n                    if dst_x + j >= width { continue; }\n                    output.put_pixel(dst_x + j, dst_y, *input.get_pixel(noise_x + j, noise_y));\n                }\n            }\n        }\n    }\n    output\n"]]}
{"hexsha": "c4d4de40d0b7e2bd6b1ad76079cf70286537b751", "ext": "rs", "lang": "Rust", "content": "fn test_lastcache() {\n        let mut lc = LastCache::new(10);\n        for i in 0 .. 10 {\n            lc.push(1);\n        }\n        assert_eq!(lc.iter().all(|i| *i == 1), true);\n        lc.push(2);\n        lc.push(2);\n        let mut i = 0;\n        for item in &lc {\n            if i == 0 || i == 1 {\n                assert_eq!(*item, 2);\n            } else {\n                assert_eq!(*item, 1);\n            }\n            i += 1;\n        }\n    }", "item_id": 1, "repo": "snf/synthir", "file": "src/utils.rs", "last_update_at": "2019-12-16T02:24:12+00:00", "question_id": "c4d4de40d0b7e2bd6b1ad76079cf70286537b751_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_lastcache() {\n        let mut lc = LastCache::new(10);\n        for i in 0 .. 10 {\n            lc.push(1);\n        }\n        assert_eq!(lc.iter().all(|i| *i == 1), true);\n        lc.push(2);\n        lc.push(2);\n        let mut i = 0;\n        for item in &lc {\n            if i == 0 || i == 1 {\n                assert_eq!(*item, 2);\n            } else {\n                assert_eq!(*item, 1);\n            }\n            i += 1;\n        }\n"]]}
{"hexsha": "eabe9ebed14fff6b92d6c17cecc752bf9299288e", "ext": "rs", "lang": "Rust", "content": "pub fn nucleotide_counts(code :&str) -> Result<HashMap<char,usize>, &str>{\n    let mut h: HashMap<char,usize> = HashMap::new();\n    for c in ['G','T','A','C'].iter(){\n        match count(*c,code){\n            Ok(x) => h.insert(*c,x),\n            Err(x) => return Err(x),\n        };\n    }\n    Ok(h)\n}", "item_id": 0, "repo": "Dimkar3000/exercism", "file": "rust/nucleotide-count/src/lib.rs", "last_update_at": "2019-11-09T09:44:41+00:00", "question_id": "eabe9ebed14fff6b92d6c17cecc752bf9299288e_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn nucleotide_counts(code :&str) -> Result<HashMap<char,usize>, &str>{\n    let mut h: HashMap<char,usize> = HashMap::new();\n    for c in ['G','T','A','C'].iter(){\n        match count(*c,code){\n            Ok(x) => h.insert(*c,x),\n            Err(x) => return Err(x),\n        };\n    }\n    Ok(h)\n"]]}
{"hexsha": "2d759d4904794c2914d55296f9c1b68ef997e488", "ext": "rs", "lang": "Rust", "content": "fn king() {\n\tlog();\n    let moves = setup((3,3), &WHITE[5]);\n\n    assert_eq!(moves.len(), 8);\n\n    let mut game = Game::new_empty();\n    game.set_at_pos((1, 2), Some(&WHITE[4]));\n    game.set_at_pos((0, 0), Some(&BLACK[5]));\n    game.set_at_pos((6, 7), Some(&WHITE[5]));\n\n    assert_eq!(game.valid_moves((0,0)).len(), 0);\n\n    let mut found = false;\n    game = Game::new();\n    game.set_at_pos((5, 0), None);\n\n    for v in game.valid_moves((4, 0)) {\n        assert_eq!(v.len(), 1);\n    }\n\n    game.set_at_pos((6, 0), None);\n    for v in game.valid_moves((4, 0)) {\n        if v.len() == 3 {\n            found = true;\n            break;\n        }\n    }\n    assert!(found);\n\n    found = false;\n    game.set_at_pos((3, 0), None);\n    game.set_at_pos((2, 0), None);\n    game.set_at_pos((6, 0), Some(&WHITE[2]));\n    for v in game.valid_moves((4, 0)) {\n        assert_eq!(v.len(), 1);\n    }\n\n    game.set_at_pos((1, 0), None);\n    for v in game.valid_moves((4, 0)) {\n        if v.len() == 3 {\n            found = true;\n            break;\n        }\n    }\n    assert!(found);\n\n    game.set_at_pos((3, 1), None);\n    game.set_at_pos((3, 5), Some(&BLACK[4]));\n    for v in game.valid_moves((4, 0)) {\n        assert_eq!(v.len(), 1);\n    }\n}", "item_id": 6, "repo": "kalkins/rust_chess", "file": "tests/moves.rs", "last_update_at": "2019-01-17T14:32:43+00:00", "question_id": "2d759d4904794c2914d55296f9c1b68ef997e488_6", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn king() {\n\tlog();\n    let moves = setup((3,3), &WHITE[5]);\n    assert_eq!(moves.len(), 8);\n    let mut game = Game::new_empty();\n    game.set_at_pos((1, 2), Some(&WHITE[4]));\n    game.set_at_pos((0, 0), Some(&BLACK[5]));\n    game.set_at_pos((6, 7), Some(&WHITE[5]));\n    assert_eq!(game.valid_moves((0,0)).len(), 0);\n    let mut found = false;\n    game = Game::new();\n    game.set_at_pos((5, 0), None);\n    for v in game.valid_moves((4, 0)) {\n        assert_eq!(v.len(), 1);\n    }\n    game.set_at_pos((6, 0), None);\n    for v in game.valid_moves((4, 0)) {\n        if v.len() == 3 {\n            found = true;\n            break;\n        }\n    }\n    assert!(found);\n    found = false;\n    game.set_at_pos((3, 0), None);\n    game.set_at_pos((2, 0), None);\n    game.set_at_pos((6, 0), Some(&WHITE[2]));\n    for v in game.valid_moves((4, 0)) {\n        assert_eq!(v.len(), 1);\n    }\n    game.set_at_pos((1, 0), None);\n    for v in game.valid_moves((4, 0)) {\n        if v.len() == 3 {\n            found = true;\n            break;\n        }\n    }\n    assert!(found);\n    game.set_at_pos((3, 1), None);\n    game.set_at_pos((3, 5), Some(&BLACK[4]));\n    for v in game.valid_moves((4, 0)) {\n        assert_eq!(v.len(), 1);\n    }\n"]]}
{"hexsha": "36856a3ce25f672182e1bac99c3afb2ae51c2b25", "ext": "rs", "lang": "Rust", "content": "fn parse_regcmd_stmt(hash: PToken, px: &mut Px) -> PRegCmdStmt {\n    assert_eq!(px.next_token().body_text(), \"regcmd\");\n\n    let keyword = px.bump();\n    let args = parse_args(px);\n    parse_end_of_preproc(px);\n\n    PRegCmdStmt {\n        hash,\n        keyword,\n        args,\n    }\n}", "item_id": 12, "repo": "honobonosun/hsp3-ginger", "file": "hsp3-analyzer-mini/ham-core/src/parse/parse_preproc.rs", "last_update_at": "2019-11-23T06:02:14+00:00", "question_id": "36856a3ce25f672182e1bac99c3afb2ae51c2b25_12", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_regcmd_stmt(hash: PToken, px: &mut Px) -> PRegCmdStmt {\n    assert_eq!(px.next_token().body_text(), \"regcmd\");\n    let keyword = px.bump();\n    let args = parse_args(px);\n    parse_end_of_preproc(px);\n    PRegCmdStmt {\n        hash,\n        keyword,\n        args,\n    }\n"]]}
{"hexsha": "91c38625693e1daa59748c39e7988adfa088614d", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let mut machine = Machine::new();\n    println!(\"{:?}\", machine);\n    \n    machine.execute_instruction(&Instruction::NOP{});\n    println!(\"{:?}\", machine);\n\n    machine.execute_instruction(&Instruction::ADD{\n        source: Operand::Immediate(3),\n        dest: Operand::Register(Register::ZERO)\n    });\n    println!(\"{:?}\", machine);\n}", "item_id": 0, "repo": "fbergero/rust_vm", "file": "src/main.rs", "last_update_at": "2019-01-11T12:30:50+00:00", "question_id": "91c38625693e1daa59748c39e7988adfa088614d_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let mut machine = Machine::new();\n    println!(\"{:?}\", machine);\n    machine.execute_instruction(&Instruction::NOP{});\n    println!(\"{:?}\", machine);\n    machine.execute_instruction(&Instruction::ADD{\n        source: Operand::Immediate(3),\n        dest: Operand::Register(Register::ZERO)\n    });\n    println!(\"{:?}\", machine);\n"]]}
{"hexsha": "c7e4f42c1fba857dd562a9de4cbd8146360fb480", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    let xsize = 5760;\n    let ysize = 3240;\n    let view = Viewport::new(\n        Point::new(0.0, 10.0, 10.0),\n        Vector3::new(0.0, -2.0, -1.0),\n        Vector3::new(0.0, 0.0, 1.0),\n        std::f64::consts::PI / 2.0,\n        (xsize, ysize),\n    );\n    // Example isometries. This is the way you express position of an object-- Collision is\n    // checked between a ray (our camera's light ray) and a RayCast object (ie a\n    // sphere, cuboid, etc) under a certain isometry.\n    // The UnitQuaternion means no rotation. Quaternions are used widely in computer graphics to\n    // represent rotation. The Wikipedia: https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation\n    let cube = Polyhedron::new(\n        Box::new(Cuboid::new(Vector3::new(1.0, 1.0, 1.0))),\n        image::Rgb([255, 0, 255]),\n        Isometry3::from_parts(\n            Translation3::from(Vector3::new(-4.0, 0.0, 0.0)),\n            UnitQuaternion::identity(),\n        ),\n    );\n    let ground = Polyhedron::new(\n        Box::new(Cuboid::new(Vector3::new(20.0, 20.0, 0.0))),\n        image::Rgb([0, 0, 255]),\n        Isometry3::from_parts(\n            Translation3::from(Vector3::new(0.0, 0.0, -1.0)),\n            UnitQuaternion::identity(),\n        ),\n    );\n    let sphere = Polyhedron::new(\n        Box::new(Ball::new(2.0)),\n        image::Rgb([0, 120, 0]),\n        Isometry3::from_parts(\n            Translation3::from(Vector3::new(6.0, 0.0, 9.0)),\n            UnitQuaternion::identity(),\n        ),\n    );\n    let sphere2 = Polyhedron::new(\n        Box::new(Ball::new(2.0)),\n        image::Rgb([0, 0, 0]),\n        Isometry3::from_parts(\n            Translation3::from(Vector3::new(0.0, 3.0, 9.0)),\n            UnitQuaternion::identity(),\n        ),\n    );\n    // This is an example scene\n    let scene = Scene::new(\n        vec![ground, sphere, sphere2, cube],\n        view,\n        image::Rgb([120, 120, 120]),\n        2.0,\n        vec![],\n    );\n    // Render the scene, consuming it.\n    scene.render(\"output.png\".to_string());\n}", "item_id": 0, "repo": "ogkloo/raytrace", "file": "src/main.rs", "last_update_at": "2019-07-16T00:22:25+00:00", "question_id": "c7e4f42c1fba857dd562a9de4cbd8146360fb480_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    let xsize = 5760;\n    let ysize = 3240;\n    let view = Viewport::new(\n        Point::new(0.0, 10.0, 10.0),\n        Vector3::new(0.0, -2.0, -1.0),\n        Vector3::new(0.0, 0.0, 1.0),\n        std::f64::consts::PI / 2.0,\n        (xsize, ysize),\n    );\n    // Example isometries. This is the way you express position of an object-- Collision is\n    // checked between a ray (our camera's light ray) and a RayCast object (ie a\n    // sphere, cuboid, etc) under a certain isometry.\n    // The UnitQuaternion means no rotation. Quaternions are used widely in computer graphics to\n    // represent rotation. The Wikipedia: https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation\n    let cube = Polyhedron::new(\n        Box::new(Cuboid::new(Vector3::new(1.0, 1.0, 1.0))),\n        image::Rgb([255, 0, 255]),\n        Isometry3::from_parts(\n            Translation3::from(Vector3::new(-4.0, 0.0, 0.0)),\n            UnitQuaternion::identity(),\n        ),\n    );\n    let ground = Polyhedron::new(\n        Box::new(Cuboid::new(Vector3::new(20.0, 20.0, 0.0))),\n        image::Rgb([0, 0, 255]),\n        Isometry3::from_parts(\n            Translation3::from(Vector3::new(0.0, 0.0, -1.0)),\n            UnitQuaternion::identity(),\n        ),\n    );\n    let sphere = Polyhedron::new(\n        Box::new(Ball::new(2.0)),\n        image::Rgb([0, 120, 0]),\n        Isometry3::from_parts(\n            Translation3::from(Vector3::new(6.0, 0.0, 9.0)),\n            UnitQuaternion::identity(),\n        ),\n    );\n    let sphere2 = Polyhedron::new(\n        Box::new(Ball::new(2.0)),\n        image::Rgb([0, 0, 0]),\n        Isometry3::from_parts(\n            Translation3::from(Vector3::new(0.0, 3.0, 9.0)),\n            UnitQuaternion::identity(),\n        ),\n    );\n    // This is an example scene\n    let scene = Scene::new(\n        vec![ground, sphere, sphere2, cube],\n        view,\n        image::Rgb([120, 120, 120]),\n        2.0,\n        vec![],\n    );\n    // Render the scene, consuming it.\n    scene.render(\"output.png\".to_string());\n"]]}
{"hexsha": "4bc1869e862a7d4d4629c46b2325f19453e5f2e4", "ext": "rs", "lang": "Rust", "content": "fn assert_multiple(json: String, expected: Vec<serde_json::Value>) {\n        let dids: Vec<serde_json::Value> = serde_json::from_str(&json).unwrap();\n\n        assert_eq!(expected.len(), dids.len());\n\n        for did in expected {\n            assert!(dids.contains(&did));\n        }\n    }", "item_id": 52, "repo": "absltkaos/indy-sdk", "file": "wrappers/rust/tests/did.rs", "last_update_at": "2019-06-12T01:45:30+00:00", "question_id": "4bc1869e862a7d4d4629c46b2325f19453e5f2e4_52", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn assert_multiple(json: String, expected: Vec<serde_json::Value>) {\n        let dids: Vec<serde_json::Value> = serde_json::from_str(&json).unwrap();\n        assert_eq!(expected.len(), dids.len());\n        for did in expected {\n            assert!(dids.contains(&did));\n        }\n"]]}
{"hexsha": "0f124613f688d15139b709202c0eb1be80b79c77", "ext": "rs", "lang": "Rust", "content": "pub fn main() -> () {\n\tlet mut window = connect!();\n\tlet mut queue = InputQueue::create();\n\n\t'mainloop: loop {\n\t\twindow.update(&mut queue);\n\n\t\tfor input in queue.iter() {\n\t\t\tuse window::Input::*;\n\t\t\tuse window::Msg::*;\n\n\t\t\tmatch *input {\n\t\t\t\tMsg(Quit) | Msg(Back) => break 'mainloop,\n\t//\t\t\tInput::Redraw => redraw(&mut context),\n\t\t\t\t_ => {},\n\t\t\t}\n\t\t}\n\t}\n}", "item_id": 0, "repo": "aldarons-tech/packager", "file": "demo/src/mod.rs", "last_update_at": "2019-03-22T18:06:26+00:00", "question_id": "0f124613f688d15139b709202c0eb1be80b79c77_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn main() -> () {\n\tlet mut window = connect!();\n\tlet mut queue = InputQueue::create();\n\t'mainloop: loop {\n\t\twindow.update(&mut queue);\n\t\tfor input in queue.iter() {\n\t\t\tuse window::Input::*;\n\t\t\tuse window::Msg::*;\n\t\t\tmatch *input {\n\t\t\t\tMsg(Quit) | Msg(Back) => break 'mainloop,\n\t//\t\t\tInput::Redraw => redraw(&mut context),\n\t\t\t\t_ => {},\n\t\t\t}\n\t\t}\n\t}\n"]]}
{"hexsha": "4961bda800c51f4d13c02881316f0ad045dba647", "ext": "rs", "lang": "Rust", "content": "fn foreign_keys_nested_alias() {\n        let columns = vec![\n            \"id\".to_string(),\n            \"parent_id.company_id.name AS parent_company\".to_string(),\n        ];\n        let fks = [ForeignKeyReference {\n            original_refs: vec![\"parent_id.company_id.name\".to_string()],\n            referring_table: \"child\".to_string(),\n            referring_column: \"parent_id\".to_string(),\n            referring_column_type: \"int8\",\n            foreign_key_table: \"adult\".to_string(),\n            foreign_key_table_stats: vec![],\n            foreign_key_column: \"id\".to_string(),\n            foreign_key_column_type: \"int8\",\n            nested_fks: vec![ForeignKeyReference {\n                original_refs: vec![\"company_id.name\".to_string()],\n                referring_table: \"adult\".to_string(),\n                referring_column: \"company_id\".to_string(),\n                referring_column_type: \"int8\",\n                foreign_key_table: \"company\".to_string(),\n                foreign_key_table_stats: vec![],\n                foreign_key_column: \"id\".to_string(),\n                foreign_key_column_type: \"int8\",\n                nested_fks: vec![],\n            }],\n        }];\n        let table = \"child\";\n\n        let column_str = get_columns_str(&columns, table, &fks).unwrap().join(\"\");\n        assert_eq!(\n            column_str,\n            r#\"child.id AS \"id\", company.name AS \"parent_company\"\"#\n        );\n    }", "item_id": 13, "repo": "kaibyao/experiment00", "file": "postgres-rest/src/queries/utils.rs", "last_update_at": "2019-10-19T04:35:56+00:00", "question_id": "4961bda800c51f4d13c02881316f0ad045dba647_13", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn foreign_keys_nested_alias() {\n        let columns = vec![\n            \"id\".to_string(),\n            \"parent_id.company_id.name AS parent_company\".to_string(),\n        ];\n        let fks = [ForeignKeyReference {\n            original_refs: vec![\"parent_id.company_id.name\".to_string()],\n            referring_table: \"child\".to_string(),\n            referring_column: \"parent_id\".to_string(),\n            referring_column_type: \"int8\",\n            foreign_key_table: \"adult\".to_string(),\n            foreign_key_table_stats: vec![],\n            foreign_key_column: \"id\".to_string(),\n            foreign_key_column_type: \"int8\",\n            nested_fks: vec![ForeignKeyReference {\n                original_refs: vec![\"company_id.name\".to_string()],\n                referring_table: \"adult\".to_string(),\n                referring_column: \"company_id\".to_string(),\n                referring_column_type: \"int8\",\n                foreign_key_table: \"company\".to_string(),\n                foreign_key_table_stats: vec![],\n                foreign_key_column: \"id\".to_string(),\n                foreign_key_column_type: \"int8\",\n                nested_fks: vec![],\n            }],\n        }];\n        let table = \"child\";\n        let column_str = get_columns_str(&columns, table, &fks).unwrap().join(\"\");\n        assert_eq!(\n            column_str,\n            r#\"child.id AS \"id\", company.name AS \"parent_company\"\"#\n        );\n"]]}
{"hexsha": "3606d2c00a03802dc158028a6f2e7b76639aeade", "ext": "rs", "lang": "Rust", "content": "fn testOP_TAY() {\r\n        let mut cpu = super::CPU::new_empty();\r\n\r\n        cpu.a = 0;\r\n        cpu.TAY();\r\n        assert_eq!(cpu.y, 0); //Changes 'Z, N'\r\n        assert_eq!(cpu.get_status(\"Z\"), true);\r\n    }", "item_id": 37, "repo": "Spalynx/rs-nes", "file": "src/core/cpu_test.rs", "last_update_at": "2019-09-28T22:12:13+00:00", "question_id": "3606d2c00a03802dc158028a6f2e7b76639aeade_37", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn testOP_TAY() {\r\n        let mut cpu = super::CPU::new_empty();\r\n\r\n        cpu.a = 0;\r\n        cpu.TAY();\r\n        assert_eq!(cpu.y, 0); //Changes 'Z, N'\r\n        assert_eq!(cpu.get_status(\"Z\"), true);\r\n"]]}
{"hexsha": "9b41b9d444481b80f15c61050cd7267d0b972dba", "ext": "rs", "lang": "Rust", "content": "fn _to_db_passwd(plain_password: String, salt: i32) -> Blake2bResult {\n\t let salted_pwd = plain_password + &salt.to_string();\n\t let res = blake2b(64, &[], salted_pwd.as_bytes());\n\t return res;\n}", "item_id": 9, "repo": "SpenQ/rabe-keyserver", "file": "src/main.rs", "last_update_at": "2019-09-30T03:21:57+00:00", "question_id": "9b41b9d444481b80f15c61050cd7267d0b972dba_9", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn _to_db_passwd(plain_password: String, salt: i32) -> Blake2bResult {\n\t let salted_pwd = plain_password + &salt.to_string();\n\t let res = blake2b(64, &[], salted_pwd.as_bytes());\n\t return res;\n"]]}
{"hexsha": "e95801833f5ef16ff1c262b5a4cce30b9469635b", "ext": "rs", "lang": "Rust", "content": "fn template_decomposition() {\n        let title = \"\";\n        let labels: Vec<String> = vec!();\n        let body: Option<String> = None;\n        let assignee: Option<String> = None;\n        let milestone: Option<u64> = None;\n        let mut issue = IssueOptions::new(title, body, assignee, milestone, labels);\n\n        populate_metadata(&mut issue, &mut template());\n\n        assert_eq!(\"Test title\", issue.title);\n        assert_eq!(vec![\"new\", \"bug\"], issue.labels);\n        assert_eq!(Some(raw_body()), issue.body);\n    }", "item_id": 5, "repo": "LeakyBucket/child_issue", "file": "src/template.rs", "last_update_at": "2019-08-30T20:38:04+00:00", "question_id": "e95801833f5ef16ff1c262b5a4cce30b9469635b_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn template_decomposition() {\n        let title = \"\";\n        let labels: Vec<String> = vec!();\n        let body: Option<String> = None;\n        let assignee: Option<String> = None;\n        let milestone: Option<u64> = None;\n        let mut issue = IssueOptions::new(title, body, assignee, milestone, labels);\n        populate_metadata(&mut issue, &mut template());\n        assert_eq!(\"Test title\", issue.title);\n        assert_eq!(vec![\"new\", \"bug\"], issue.labels);\n        assert_eq!(Some(raw_body()), issue.body);\n"]]}
{"hexsha": "c69be8ce7ea790a7130a3a0e58140a8bb5541808", "ext": "rs", "lang": "Rust", "content": "fn future_set_is_updated_to_none_when_no_migration_is_required() {\n\t\tlet node_id = Default::default();\n\t\tlet address1 = \"127.0.0.1:12000\".parse().unwrap();\n\t\tlet address2 = \"127.0.0.1:12001\".parse().unwrap();\n\n\t\t// addresses are different, but node set is the same => no migration is required\n\t\tlet mut future_new_set = Some(Default::default());\n\t\tlet mut new_snapshot = KeyServerSetSnapshot {\n\t\t\tcurrent_set: vec![(node_id, address1)].into_iter().collect(),\n\t\t\tnew_set: vec![(node_id, address2)].into_iter().collect(),\n\t\t\t..Default::default()\n\t\t};\n\t\tlet new_snapshot_copy = new_snapshot.clone();\n\t\tupdate_future_set(&mut future_new_set, &mut new_snapshot, Default::default());\n\t\tassert_eq!(future_new_set, None);\n\t\tassert_eq!(new_snapshot, new_snapshot_copy);\n\n\t\t// everything is the same => no migration is required\n\t\tlet mut future_new_set = Some(Default::default());\n\t\tlet mut new_snapshot = KeyServerSetSnapshot {\n\t\t\tcurrent_set: vec![(node_id, address1)].into_iter().collect(),\n\t\t\tnew_set: vec![(node_id, address1)].into_iter().collect(),\n\t\t\t..Default::default()\n\t\t};\n\t\tlet new_snapshot_copy = new_snapshot.clone();\n\t\tupdate_future_set(&mut future_new_set, &mut new_snapshot, Default::default());\n\t\tassert_eq!(future_new_set, None);\n\t\tassert_eq!(new_snapshot, new_snapshot_copy);\n\t}", "item_id": 5, "repo": "altice-io/Daqiao", "file": "bridge/parity-ethereum/secret-store/src/key_server_set.rs", "last_update_at": "2019-09-11T12:07:35+00:00", "question_id": "c69be8ce7ea790a7130a3a0e58140a8bb5541808_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn future_set_is_updated_to_none_when_no_migration_is_required() {\n\t\tlet node_id = Default::default();\n\t\tlet address1 = \"127.0.0.1:12000\".parse().unwrap();\n\t\tlet address2 = \"127.0.0.1:12001\".parse().unwrap();\n\t\t// addresses are different, but node set is the same => no migration is required\n\t\tlet mut future_new_set = Some(Default::default());\n\t\tlet mut new_snapshot = KeyServerSetSnapshot {\n\t\t\tcurrent_set: vec![(node_id, address1)].into_iter().collect(),\n\t\t\tnew_set: vec![(node_id, address2)].into_iter().collect(),\n\t\t\t..Default::default()\n\t\t};\n\t\tlet new_snapshot_copy = new_snapshot.clone();\n\t\tupdate_future_set(&mut future_new_set, &mut new_snapshot, Default::default());\n\t\tassert_eq!(future_new_set, None);\n\t\tassert_eq!(new_snapshot, new_snapshot_copy);\n\t\t// everything is the same => no migration is required\n\t\tlet mut future_new_set = Some(Default::default());\n\t\tlet mut new_snapshot = KeyServerSetSnapshot {\n\t\t\tcurrent_set: vec![(node_id, address1)].into_iter().collect(),\n\t\t\tnew_set: vec![(node_id, address1)].into_iter().collect(),\n\t\t\t..Default::default()\n\t\t};\n\t\tlet new_snapshot_copy = new_snapshot.clone();\n\t\tupdate_future_set(&mut future_new_set, &mut new_snapshot, Default::default());\n\t\tassert_eq!(future_new_set, None);\n\t\tassert_eq!(new_snapshot, new_snapshot_copy);\n"]]}
{"hexsha": "3fde9932d414d213fcba06a5184b8dd1a357c5e7", "ext": "rs", "lang": "Rust", "content": "fn test_function_directory() {\n    let formatter = Formatter::new();\n    // tests with functions\n    {\n        let test_metadata = test::MetadataProvider::new(HashMap::new());\n        {\n            let expression = formatter\n                .parser()\n                .parse(\"$directory('/home/test/Music/hello world.mp3')\")\n                .unwrap();\n            let s = expression.apply(&test_metadata);\n            assert_eq!(\"Music\", s.to_string().as_str());\n        }\n        {\n            let expression = formatter\n                .parser()\n                .parse(\"$directory('/home/test/Music/hello world.mp3', 1)\")\n                .unwrap();\n            let s = expression.apply(&test_metadata);\n            assert_eq!(\"test\", s.to_string().as_str());\n        }\n        {\n            let expression = formatter\n                .parser()\n                .parse(\"$directory('/home/test/Music/hello world.mp3', 2)\")\n                .unwrap();\n            let s = expression.apply(&test_metadata);\n            assert_eq!(\"home\", s.to_string().as_str());\n        }\n        {\n            let expression = formatter\n                .parser()\n                .parse(\"$directory('/home/test/Music/hello world.mp3', 5)\")\n                .unwrap();\n            let s = expression.apply(&test_metadata);\n            assert_eq!(\"\", s.to_string().as_str());\n        }\n    }\n}", "item_id": 0, "repo": "suntorvic/titleformat", "file": "src/function/string/directory/test.rs", "last_update_at": "2019-05-27T22:36:24+00:00", "question_id": "3fde9932d414d213fcba06a5184b8dd1a357c5e7_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_function_directory() {\n    let formatter = Formatter::new();\n    // tests with functions\n    {\n        let test_metadata = test::MetadataProvider::new(HashMap::new());\n        {\n            let expression = formatter\n                .parser()\n                .parse(\"$directory('/home/test/Music/hello world.mp3')\")\n                .unwrap();\n            let s = expression.apply(&test_metadata);\n            assert_eq!(\"Music\", s.to_string().as_str());\n        }\n        {\n            let expression = formatter\n                .parser()\n                .parse(\"$directory('/home/test/Music/hello world.mp3', 1)\")\n                .unwrap();\n            let s = expression.apply(&test_metadata);\n            assert_eq!(\"test\", s.to_string().as_str());\n        }\n        {\n            let expression = formatter\n                .parser()\n                .parse(\"$directory('/home/test/Music/hello world.mp3', 2)\")\n                .unwrap();\n            let s = expression.apply(&test_metadata);\n            assert_eq!(\"home\", s.to_string().as_str());\n        }\n        {\n            let expression = formatter\n                .parser()\n                .parse(\"$directory('/home/test/Music/hello world.mp3', 5)\")\n                .unwrap();\n            let s = expression.apply(&test_metadata);\n            assert_eq!(\"\", s.to_string().as_str());\n        }\n    }\n"]]}
{"hexsha": "41d0d3de6eac7746cda3976054e9eb26c415cdf0", "ext": "rs", "lang": "Rust", "content": "pub fn encrypt(pbc: &RsaPublicKey,f: &[u8],g: &mut [u8]) {\n\tlet m=pbc.n.getlen();\n\tlet mut r=FF::new_int(m);\n\n\tFF::frombytes(&mut r,f);\n\tr.power(pbc.e,&pbc.n);\n\tr.tobytes(g);\n}", "item_id": 7, "repo": "jonnycrunch/crypto-lib", "file": "libhl-crypto/amcl/src/rsa4096/rsa.rs", "last_update_at": "2019-01-16T06:06:50+00:00", "question_id": "41d0d3de6eac7746cda3976054e9eb26c415cdf0_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn encrypt(pbc: &RsaPublicKey,f: &[u8],g: &mut [u8]) {\n\tlet m=pbc.n.getlen();\n\tlet mut r=FF::new_int(m);\n\tFF::frombytes(&mut r,f);\n\tr.power(pbc.e,&pbc.n);\n\tr.tobytes(g);\n"]]}
{"hexsha": "67c57f38931704a9fbeca6791665a83f9eadfa4a", "ext": "rs", "lang": "Rust", "content": "fn setup_watch_test() {\n        setup();\n\n        let cfg = test_config();\n        let (tx, rx) = channel();\n\n        // Launch write_to_file after 1 second delay\n        thread::spawn(|| {\n            thread::sleep(Duration::from_secs(1));\n            write_to_file();\n        });\n\n        // The shutdown task after a 3 second delay\n        thread::spawn(move || {\n            thread::sleep(Duration::from_secs(3));\n            tx.send(true).unwrap();\n        });\n\n        // Start the watch\n        setup_watch(rx, cfg);\n        assert!(path::Path::new(GEN_FILE).exists());\n\n        teardown();\n    }", "item_id": 2, "repo": "abhijat/rgr", "file": "src/watcher/mod.rs", "last_update_at": "2019-01-21T04:16:19+00:00", "question_id": "67c57f38931704a9fbeca6791665a83f9eadfa4a_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn setup_watch_test() {\n        setup();\n        let cfg = test_config();\n        let (tx, rx) = channel();\n        // Launch write_to_file after 1 second delay\n        thread::spawn(|| {\n            thread::sleep(Duration::from_secs(1));\n            write_to_file();\n        });\n        // The shutdown task after a 3 second delay\n        thread::spawn(move || {\n            thread::sleep(Duration::from_secs(3));\n            tx.send(true).unwrap();\n        });\n        // Start the watch\n        setup_watch(rx, cfg);\n        assert!(path::Path::new(GEN_FILE).exists());\n        teardown();\n"]]}
{"hexsha": "001470d48999b54fd5a702510d1753e28c2e3bd4", "ext": "rs", "lang": "Rust", "content": "fn set_key_from_u256(key: u32, val: U256) {\n\tlet mut full_key = [0u8; 32];\n\twrite_u32(&mut full_key[0..4], key);\n\n\tlet _ = ext::write(&H256::from(full_key), &val.into());\n}", "item_id": 1, "repo": "openvapory/wasm-tests", "file": "src/logger.rs", "last_update_at": "2019-04-24T05:07:38+00:00", "question_id": "001470d48999b54fd5a702510d1753e28c2e3bd4_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn set_key_from_u256(key: u32, val: U256) {\n\tlet mut full_key = [0u8; 32];\n\twrite_u32(&mut full_key[0..4], key);\n\tlet _ = ext::write(&H256::from(full_key), &val.into());\n"]]}
{"hexsha": "fa07feab815556d8b81911272007935b4eed7a7c", "ext": "rs", "lang": "Rust", "content": "fn pack_sorted(rectangles: &[PackInput], options: &PackOptions) -> Vec<Bin> {\n  let mut bins: Vec<Bin> = vec![new_bin(options)];\n  let insert_fn: &'static Fn(&mut Bin, &Dimension, u32, &PackOptions) -> bool =\n    if options.atlas_compact_steps == 0 { &try_insert } else { &try_insert_with_growth };\n\n  for &input in rectangles {\n    let packed = bins.iter_mut().any(|bin| insert_fn(bin, &input.dim, input.id, options));\n    if !packed {\n      let mut new_bin = new_bin(options);\n      new_bin.insert(&input.dim, input.id, options.flipping);\n      bins.push(new_bin);\n    }\n  }\n  bins\n}", "item_id": 1, "repo": "vstepchik/sprack", "file": "sprack/src/lib.rs", "last_update_at": "2019-11-10T14:33:18+00:00", "question_id": "fa07feab815556d8b81911272007935b4eed7a7c_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn pack_sorted(rectangles: &[PackInput], options: &PackOptions) -> Vec<Bin> {\n  let mut bins: Vec<Bin> = vec![new_bin(options)];\n  let insert_fn: &'static Fn(&mut Bin, &Dimension, u32, &PackOptions) -> bool =\n    if options.atlas_compact_steps == 0 { &try_insert } else { &try_insert_with_growth };\n  for &input in rectangles {\n    let packed = bins.iter_mut().any(|bin| insert_fn(bin, &input.dim, input.id, options));\n    if !packed {\n      let mut new_bin = new_bin(options);\n      new_bin.insert(&input.dim, input.id, options.flipping);\n      bins.push(new_bin);\n    }\n  }\n  bins\n"]]}
{"hexsha": "ad0bba81d73aab9eccc18d3b02aaf45f1cbd9170", "ext": "rs", "lang": "Rust", "content": "pub(crate) fn generate_include_guard(\n    uri: &Url,\n    range: Range,\n    docs: &Docs,\n    wa: &mut WorkspaceAnalysis,\n) -> Option<Vec<CodeAction>> {\n    let (doc, pos) = from_document_position(&uri, range.start, &docs)?;\n    let version = docs.get_version(doc);\n\n    let DocSyntax { text, tokens, .. } = wa.get_syntax(doc)?;\n\n    // \u30ab\u30fc\u30bd\u30eb\u304c\u884c\u982d\u306b\u3042\u3063\u3066\u3001\u6700\u521d\u306e\u30c8\u30fc\u30af\u30f3\u4ee5\u524d\u306b\u3042\u3063\u3066\u3001\u6587\u5b57\u5217\u3084\u30b3\u30e1\u30f3\u30c8\u306e\u5916\u3067\u3042\u3063\u3066\u3001\u30a4\u30f3\u30af\u30eb\u30fc\u30c9\u30ac\u30fc\u30c9\u304c\u307e\u3060\u306a\u3044\u3068\u304d\u3002\n    let ok = pos.column == 0\n        && pos <= tokens.first()?.body_pos16()\n        && !wa.in_str_or_comment(doc, pos).unwrap_or(true)\n        && !wa.has_include_guard(doc);\n    if !ok {\n        return None;\n    }\n\n    // \u30d5\u30a1\u30a4\u30eb\u540d\u304b\u3089\u30b7\u30f3\u30dc\u30eb\u3092\u751f\u6210\u3059\u308b\u3002\n    let name = {\n        let path = docs.get_uri(doc)?.clone().into_url().to_file_path().ok()?;\n        let name = path.file_name()?.to_str()?;\n        name.replace(\".\", \"_\") + \"_included\"\n    };\n    let eol = if text.contains(\"\\r\\n\") { \"\\r\\n\" } else { \"\\n\" };\n    let new_text = format!(\n        \"#ifndef {name}{eol}#define {name}{eol}{eol}#endif{eol}\",\n        name = name,\n        eol = eol,\n    );\n\n    Some(vec![CodeAction {\n        title: \"\u30a4\u30f3\u30af\u30eb\u30fc\u30c9\u30ac\u30fc\u30c9\u3092\u751f\u6210\u3059\u308b\".into(),\n        kind: Some(\"refactor.rewrite\".into()),\n        edit: Some(WorkspaceEdit {\n            document_changes: Some(DocumentChanges::Edits(vec![TextDocumentEdit {\n                text_document: OptionalVersionedTextDocumentIdentifier {\n                    uri: uri.clone(),\n                    version,\n                },\n                edits: vec![OneOf::Left(TextEdit { range, new_text })],\n            }])),\n            ..WorkspaceEdit::default()\n        }),\n        ..Default::default()\n    }])\n}", "item_id": 0, "repo": "vain0x/hsp3-ginger", "file": "hsp3-analyzer-mini/ham-core/src/assists/rewrites/generate_include_guard.rs", "last_update_at": "2019-11-23T06:02:14+00:00", "question_id": "ad0bba81d73aab9eccc18d3b02aaf45f1cbd9170_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub(crate) fn generate_include_guard(\n    uri: &Url,\n    range: Range,\n    docs: &Docs,\n    wa: &mut WorkspaceAnalysis,\n) -> Option<Vec<CodeAction>> {\n    let (doc, pos) = from_document_position(&uri, range.start, &docs)?;\n    let version = docs.get_version(doc);\n    let DocSyntax { text, tokens, .. } = wa.get_syntax(doc)?;\n    // \u30ab\u30fc\u30bd\u30eb\u304c\u884c\u982d\u306b\u3042\u3063\u3066\u3001\u6700\u521d\u306e\u30c8\u30fc\u30af\u30f3\u4ee5\u524d\u306b\u3042\u3063\u3066\u3001\u6587\u5b57\u5217\u3084\u30b3\u30e1\u30f3\u30c8\u306e\u5916\u3067\u3042\u3063\u3066\u3001\u30a4\u30f3\u30af\u30eb\u30fc\u30c9\u30ac\u30fc\u30c9\u304c\u307e\u3060\u306a\u3044\u3068\u304d\u3002\n    let ok = pos.column == 0\n        && pos <= tokens.first()?.body_pos16()\n        && !wa.in_str_or_comment(doc, pos).unwrap_or(true)\n        && !wa.has_include_guard(doc);\n    if !ok {\n        return None;\n    }\n    // \u30d5\u30a1\u30a4\u30eb\u540d\u304b\u3089\u30b7\u30f3\u30dc\u30eb\u3092\u751f\u6210\u3059\u308b\u3002\n    let name = {\n        let path = docs.get_uri(doc)?.clone().into_url().to_file_path().ok()?;\n        let name = path.file_name()?.to_str()?;\n        name.replace(\".\", \"_\") + \"_included\"\n    };\n    let eol = if text.contains(\"\\r\\n\") { \"\\r\\n\" } else { \"\\n\" };\n    let new_text = format!(\n        \"#ifndef {name}{eol}#define {name}{eol}{eol}#endif{eol}\",\n        name = name,\n        eol = eol,\n    );\n    Some(vec![CodeAction {\n        title: \"\u30a4\u30f3\u30af\u30eb\u30fc\u30c9\u30ac\u30fc\u30c9\u3092\u751f\u6210\u3059\u308b\".into(),\n        kind: Some(\"refactor.rewrite\".into()),\n        edit: Some(WorkspaceEdit {\n            document_changes: Some(DocumentChanges::Edits(vec![TextDocumentEdit {\n                text_document: OptionalVersionedTextDocumentIdentifier {\n                    uri: uri.clone(),\n                    version,\n                },\n                edits: vec![OneOf::Left(TextEdit { range, new_text })],\n            }])),\n            ..WorkspaceEdit::default()\n        }),\n        ..Default::default()\n    }])\n"]]}
{"hexsha": "689bb07b9139a9851ee649f181679cd88e95af6e", "ext": "rs", "lang": "Rust", "content": "pub unsafe fn _get_bool_config(sz_setting: *const c_char) -> SettingBool {\n    let mut setting: SettingBool = SettingBool {\n        value: false,\n        source: SettingSource::Default,\n    };\n    let mut sz_line = [0u8; 256];\n    let mut psz_name: *mut c_char;\n    let mut psz_value: *mut c_char;\n    let mut sz_name = [0u8; 256];\n    let mut sz_value = [0u8; 256];\n\n    let pf = fopen(\n        b\"/etc/yubico/yubikeypiv.conf\\0\".as_ptr() as *const c_char,\n        b\"r\\0\".as_ptr() as *const c_char,\n    );\n\n    if pf.is_null() {\n        return setting;\n    }\n\n    while feof(pf) == 0 {\n        if fgets(\n            sz_line.as_mut_ptr() as *mut c_char,\n            sz_line.len() as c_int,\n            pf,\n        )\n        .is_null()\n        {\n            continue;\n        }\n\n        if sz_line[0] == b'#' {\n            continue;\n        }\n\n        if sz_line[0] == b'\\r' {\n            continue;\n        }\n\n        if sz_line[0] == b'\\n' {\n            continue;\n        }\n\n        if sscanf(\n            sz_line.as_ptr() as *const c_char,\n            b\"%255[^=]=%255s\\0\".as_ptr() as *const c_char,\n            sz_name.as_mut_ptr(),\n            sz_value.as_mut_ptr(),\n        ) != 2\n        {\n            continue;\n        }\n\n        psz_name = _strip_ws(sz_name.as_mut_ptr() as *mut c_char);\n\n        if strcasecmp(psz_name, sz_setting) != 0 {\n            continue;\n        }\n\n        psz_value = _strip_ws(sz_value.as_mut_ptr() as *mut c_char);\n        setting.source = SettingSource::Admin;\n        setting.value = strcmp(psz_value, b\"1\\0\".as_ptr() as *const c_char) == 0\n            || strcasecmp(psz_value, b\"true\\0\".as_ptr() as *const c_char) == 0;\n    }\n\n    fclose(pf);\n    setting\n}", "item_id": 3, "repo": "str4d/yubikey-piv.rs", "file": "src/internal.rs", "last_update_at": "2019-11-19T17:17:28+00:00", "question_id": "689bb07b9139a9851ee649f181679cd88e95af6e_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub unsafe fn _get_bool_config(sz_setting: *const c_char) -> SettingBool {\n    let mut setting: SettingBool = SettingBool {\n        value: false,\n        source: SettingSource::Default,\n    };\n    let mut sz_line = [0u8; 256];\n    let mut psz_name: *mut c_char;\n    let mut psz_value: *mut c_char;\n    let mut sz_name = [0u8; 256];\n    let mut sz_value = [0u8; 256];\n    let pf = fopen(\n        b\"/etc/yubico/yubikeypiv.conf\\0\".as_ptr() as *const c_char,\n        b\"r\\0\".as_ptr() as *const c_char,\n    );\n    if pf.is_null() {\n        return setting;\n    }\n    while feof(pf) == 0 {\n        if fgets(\n            sz_line.as_mut_ptr() as *mut c_char,\n            sz_line.len() as c_int,\n            pf,\n        )\n        .is_null()\n        {\n            continue;\n        }\n        if sz_line[0] == b'#' {\n            continue;\n        }\n        if sz_line[0] == b'\\r' {\n            continue;\n        }\n        if sz_line[0] == b'\\n' {\n            continue;\n        }\n        if sscanf(\n            sz_line.as_ptr() as *const c_char,\n            b\"%255[^=]=%255s\\0\".as_ptr() as *const c_char,\n            sz_name.as_mut_ptr(),\n            sz_value.as_mut_ptr(),\n        ) != 2\n        {\n            continue;\n        }\n        psz_name = _strip_ws(sz_name.as_mut_ptr() as *mut c_char);\n        if strcasecmp(psz_name, sz_setting) != 0 {\n            continue;\n        }\n        psz_value = _strip_ws(sz_value.as_mut_ptr() as *mut c_char);\n        setting.source = SettingSource::Admin;\n        setting.value = strcmp(psz_value, b\"1\\0\".as_ptr() as *const c_char) == 0\n            || strcasecmp(psz_value, b\"true\\0\".as_ptr() as *const c_char) == 0;\n    }\n    fclose(pf);\n    setting\n"]]}
{"hexsha": "97b42a47dea1a408fb0df18381b985264a485878", "ext": "rs", "lang": "Rust", "content": "pub fn tree_policy(\n    current_state : &game_state::GameState,\n    visisted_states : &HashSet<game_state::GameState>,\n    stats : &HashMap<game_state::GameState, UCTData>\n    ) -> TreePolicyResult{\n    \n    //represents the states we went through to get to the selected node\n    //used for backpropogation without an actual tree structure\n    let mut path : Vec<game_state::GameState> = Vec::new();\n\n    let mut current_node = current_state.clone();\n\n    loop{\n\n        path.push(current_node);\n\n        let possible_moves = current_node.legal_moves(current_node.player);\n\n        if possible_moves.len() < 1 || victory(current_node.win()){\n            //no legal moves or game ends\n            return TreePolicyResult::new(path, current_node);\n        }\n        \n        //has every possible move been explored?\n        let fully_explored = possible_moves.iter().fold(true, \n            |acc, x| \n            acc && visisted_states.contains(&current_node.place(x))\n        );\n\n        //if not, exploration\n        if !fully_explored {\n            //for a node with number played of 0, ucb1 returns infinity\n            //in other words unexplored child nodes are always explored at least once\n            let not_explored = possible_moves.into_iter().filter(\n                |x| !visisted_states.contains(&current_node.place(x))\n                ).collect::<Vec<_>>();\n            let random_choice = choose_random(&not_explored);\n            let chosen_node = current_node.place(&random_choice);\n            path.push(chosen_node);\n            let result = TreePolicyResult::new(path, chosen_node);\n            return result; \n        }\n\n        //all child nodes have been simulated at least once, so use ucb1 to select best\n        else{\n            //sort \n            let mut best_move = possible_moves.last().unwrap();\n            let mut best_uct = 0f64;\n            let total_played = stats.get(&current_node).unwrap().num_plays;\n            for possibility in possible_moves.iter(){\n                \n                //TODO: switch to pattern matching\n                let data = stats.get(&current_node.place(&possibility)).unwrap();\n                let uct = ucb1(data.wins, data.num_plays as f64, total_played as f64);\n                if(uct > best_uct){\n                    best_uct = uct;\n                    best_move = possibility;\n                }\n            }\n            let chosen_node = current_node.place(&best_move);\n            current_node = chosen_node;\n        }\n    }\n}", "item_id": 7, "repo": "starrtnow/mcts-connect-four", "file": "src/monte_carlo.rs", "last_update_at": "2019-07-16T05:30:47+00:00", "question_id": "97b42a47dea1a408fb0df18381b985264a485878_7", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn tree_policy(\n    current_state : &game_state::GameState,\n    visisted_states : &HashSet<game_state::GameState>,\n    stats : &HashMap<game_state::GameState, UCTData>\n    ) -> TreePolicyResult{\n    //represents the states we went through to get to the selected node\n    //used for backpropogation without an actual tree structure\n    let mut path : Vec<game_state::GameState> = Vec::new();\n    let mut current_node = current_state.clone();\n    loop{\n        path.push(current_node);\n        let possible_moves = current_node.legal_moves(current_node.player);\n        if possible_moves.len() < 1 || victory(current_node.win()){\n            //no legal moves or game ends\n            return TreePolicyResult::new(path, current_node);\n        }\n        //has every possible move been explored?\n        let fully_explored = possible_moves.iter().fold(true, \n            |acc, x| \n            acc && visisted_states.contains(&current_node.place(x))\n        );\n        //if not, exploration\n        if !fully_explored {\n            //for a node with number played of 0, ucb1 returns infinity\n            //in other words unexplored child nodes are always explored at least once\n            let not_explored = possible_moves.into_iter().filter(\n                |x| !visisted_states.contains(&current_node.place(x))\n                ).collect::<Vec<_>>();\n            let random_choice = choose_random(&not_explored);\n            let chosen_node = current_node.place(&random_choice);\n            path.push(chosen_node);\n            let result = TreePolicyResult::new(path, chosen_node);\n            return result; \n        }\n        //all child nodes have been simulated at least once, so use ucb1 to select best\n        else{\n            //sort \n            let mut best_move = possible_moves.last().unwrap();\n            let mut best_uct = 0f64;\n            let total_played = stats.get(&current_node).unwrap().num_plays;\n            for possibility in possible_moves.iter(){\n                //TODO: switch to pattern matching\n                let data = stats.get(&current_node.place(&possibility)).unwrap();\n                let uct = ucb1(data.wins, data.num_plays as f64, total_played as f64);\n                if(uct > best_uct){\n                    best_uct = uct;\n                    best_move = possibility;\n                }\n            }\n            let chosen_node = current_node.place(&best_move);\n            current_node = chosen_node;\n        }\n    }\n"]]}
{"hexsha": "1dd214dcc0a65b6e7269dcb8fb9fba695a030496", "ext": "rs", "lang": "Rust", "content": "fn net_fee_dynamic_increase() {\n    let minter = Arc::new(TestMinter::new());\n    let from_acc = minter.genesis_info().owner_id;\n    {\n        // Create enough funds for all the accounts being created in quick succession\n        let mut tx = TxVariant::V0(TxVariantV0::MintTx(MintTx {\n            base: create_tx_header(\"0.00000 TEST\"),\n            to: from_acc,\n            amount: get_asset(\"5000.00000 TEST\"),\n            attachment: vec![],\n            attachment_name: \"\".to_string(),\n        }));\n\n        tx.append_sign(&minter.genesis_info().wallet_keys[1]);\n        tx.append_sign(&minter.genesis_info().wallet_keys[0]);\n\n        let res = minter.send_req(rpc::Request::Broadcast(tx));\n        assert_eq!(res, Some(Ok(rpc::Response::Broadcast)));\n        minter.produce_block().unwrap();\n    }\n\n    let accs = Arc::new(\n        (1..100)\n            .map(|id| {\n                let key = KeyPair::gen();\n                let mut acc = Account::create_default(\n                    id,\n                    Permissions {\n                        threshold: 1,\n                        keys: vec![key.0.clone()],\n                    },\n                );\n                let owner_acc = minter.minter().get_account_info(from_acc).unwrap();\n                let fee = owner_acc\n                    .total_fee()\n                    .unwrap()\n                    .checked_mul(GRAEL_ACC_CREATE_FEE_MULT)\n                    .unwrap();\n                acc.balance = fee.checked_mul(GRAEL_ACC_CREATE_MIN_BAL_MULT).unwrap();\n\n                // Minor optimization to reduce the number of blocks being produced\n                if acc.balance.amount > 500_00000 {\n                    // Reset the fee window\n                    for _ in 0..=NETWORK_FEE_AVG_WINDOW {\n                        minter.produce_block().unwrap();\n                    }\n                }\n                (minter.create_account(acc, &fee.to_string(), false), key)\n            })\n            .collect::<Vec<_>>(),\n    );\n\n    for (acc, _) in accs.as_ref() {\n        let tx = {\n            let amount = Asset::new(100000);\n            let mut tx = TxVariant::V0(TxVariantV0::TransferTx(TransferTx {\n                base: create_tx_header(\"1.00000 TEST\"),\n                from: from_acc,\n                call_fn: 1,\n                args: {\n                    let mut args = vec![];\n                    args.push_u64(acc.id);\n                    args.push_asset(amount);\n                    args\n                },\n                amount,\n                memo: vec![],\n            }));\n            tx.append_sign(&minter.genesis_info().wallet_keys[3]);\n            tx.append_sign(&minter.genesis_info().wallet_keys[0]);\n            tx\n        };\n\n        let req = rpc::Request::Broadcast(tx);\n        let res = minter.send_req(req.clone()).unwrap();\n        let exp = Err(net::ErrorKind::TxValidation(\n            blockchain::TxErr::InvalidFeeAmount,\n        ));\n        if res == exp {\n            for _ in 0..=FEE_RESET_WINDOW {\n                minter.produce_block().unwrap();\n            }\n            let res = minter.send_req(req).unwrap();\n            assert_eq!(res, Ok(rpc::Response::Broadcast));\n        } else {\n            assert_eq!(res, Ok(rpc::Response::Broadcast));\n        }\n    }\n\n    for (acc, key) in accs.as_ref() {\n        let tx = {\n            let mut tx = TxVariant::V0(TxVariantV0::TransferTx(TransferTx {\n                base: create_tx_header(\"1.00000 TEST\"),\n                from: acc.id,\n                call_fn: 0,\n                args: {\n                    let mut args = vec![];\n                    args.push_u64(from_acc);\n                    args.push_asset(Asset::default());\n                    args\n                },\n                amount: Asset::default(),\n                memo: vec![],\n            }));\n            tx.append_sign(&key);\n            tx\n        };\n\n        let res = minter.send_req(rpc::Request::Broadcast(tx));\n        assert_eq!(res, Some(Ok(rpc::Response::Broadcast)));\n    }\n\n    // Ensure the network fee gets updated\n    for _ in 0..5 {\n        minter.produce_block().unwrap();\n    }\n\n    {\n        let res = minter.send_req(rpc::Request::GetProperties).unwrap();\n        let props = match res {\n            Ok(rpc::Response::GetProperties(props)) => props,\n            unexp @ _ => panic!(\"Expected GetProperties response: {:?}\", unexp),\n        };\n\n        let chain = minter.chain();\n        let max_height = props.height - (props.height % 5);\n        let min_height = max_height - NETWORK_FEE_AVG_WINDOW;\n        assert!(min_height < max_height);\n\n        let receipt_count = (min_height..=max_height).fold(1u64, |receipt_count, height| {\n            let block = chain.get_block(height).unwrap();\n            receipt_count + block.receipts().len() as u64\n        });\n        let receipt_count = (receipt_count / NETWORK_FEE_AVG_WINDOW) as u16;\n        assert!(receipt_count > 10);\n\n        let fee = GRAEL_FEE_MIN.checked_mul(GRAEL_FEE_NET_MULT.checked_pow(receipt_count).unwrap());\n        assert_eq!(Some(props.network_fee), fee);\n    }\n\n    for _ in 0..=NETWORK_FEE_AVG_WINDOW {\n        minter.produce_block().unwrap();\n    }\n\n    // Test network delta fee reset\n    let expected_fee = GRAEL_FEE_MIN.checked_mul(GRAEL_FEE_NET_MULT);\n    assert_eq!(minter.chain().get_network_fee(), expected_fee);\n}", "item_id": 11, "repo": "GODcoin/GODcoin-rs", "file": "crates/server/tests/transfer_tx.rs", "last_update_at": "2019-05-30T07:36:20+00:00", "question_id": "1dd214dcc0a65b6e7269dcb8fb9fba695a030496_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn net_fee_dynamic_increase() {\n    let minter = Arc::new(TestMinter::new());\n    let from_acc = minter.genesis_info().owner_id;\n    {\n        // Create enough funds for all the accounts being created in quick succession\n        let mut tx = TxVariant::V0(TxVariantV0::MintTx(MintTx {\n            base: create_tx_header(\"0.00000 TEST\"),\n            to: from_acc,\n            amount: get_asset(\"5000.00000 TEST\"),\n            attachment: vec![],\n            attachment_name: \"\".to_string(),\n        }));\n        tx.append_sign(&minter.genesis_info().wallet_keys[1]);\n        tx.append_sign(&minter.genesis_info().wallet_keys[0]);\n        let res = minter.send_req(rpc::Request::Broadcast(tx));\n        assert_eq!(res, Some(Ok(rpc::Response::Broadcast)));\n        minter.produce_block().unwrap();\n    }\n    let accs = Arc::new(\n        (1..100)\n            .map(|id| {\n                let key = KeyPair::gen();\n                let mut acc = Account::create_default(\n                    id,\n                    Permissions {\n                        threshold: 1,\n                        keys: vec![key.0.clone()],\n                    },\n                );\n                let owner_acc = minter.minter().get_account_info(from_acc).unwrap();\n                let fee = owner_acc\n                    .total_fee()\n                    .unwrap()\n                    .checked_mul(GRAEL_ACC_CREATE_FEE_MULT)\n                    .unwrap();\n                acc.balance = fee.checked_mul(GRAEL_ACC_CREATE_MIN_BAL_MULT).unwrap();\n                // Minor optimization to reduce the number of blocks being produced\n                if acc.balance.amount > 500_00000 {\n                    // Reset the fee window\n                    for _ in 0..=NETWORK_FEE_AVG_WINDOW {\n                        minter.produce_block().unwrap();\n                    }\n                }\n                (minter.create_account(acc, &fee.to_string(), false), key)\n            })\n            .collect::<Vec<_>>(),\n    );\n    for (acc, _) in accs.as_ref() {\n        let tx = {\n            let amount = Asset::new(100000);\n            let mut tx = TxVariant::V0(TxVariantV0::TransferTx(TransferTx {\n                base: create_tx_header(\"1.00000 TEST\"),\n                from: from_acc,\n                call_fn: 1,\n                args: {\n                    let mut args = vec![];\n                    args.push_u64(acc.id);\n                    args.push_asset(amount);\n                    args\n                },\n                amount,\n                memo: vec![],\n            }));\n            tx.append_sign(&minter.genesis_info().wallet_keys[3]);\n            tx.append_sign(&minter.genesis_info().wallet_keys[0]);\n            tx\n        };\n        let req = rpc::Request::Broadcast(tx);\n        let res = minter.send_req(req.clone()).unwrap();\n        let exp = Err(net::ErrorKind::TxValidation(\n            blockchain::TxErr::InvalidFeeAmount,\n        ));\n        if res == exp {\n            for _ in 0..=FEE_RESET_WINDOW {\n                minter.produce_block().unwrap();\n            }\n            let res = minter.send_req(req).unwrap();\n            assert_eq!(res, Ok(rpc::Response::Broadcast));\n        } else {\n            assert_eq!(res, Ok(rpc::Response::Broadcast));\n        }\n    }\n    for (acc, key) in accs.as_ref() {\n        let tx = {\n            let mut tx = TxVariant::V0(TxVariantV0::TransferTx(TransferTx {\n                base: create_tx_header(\"1.00000 TEST\"),\n                from: acc.id,\n                call_fn: 0,\n                args: {\n                    let mut args = vec![];\n                    args.push_u64(from_acc);\n                    args.push_asset(Asset::default());\n                    args\n                },\n                amount: Asset::default(),\n                memo: vec![],\n            }));\n            tx.append_sign(&key);\n            tx\n        };\n        let res = minter.send_req(rpc::Request::Broadcast(tx));\n        assert_eq!(res, Some(Ok(rpc::Response::Broadcast)));\n    }\n    // Ensure the network fee gets updated\n    for _ in 0..5 {\n        minter.produce_block().unwrap();\n    }\n    {\n        let res = minter.send_req(rpc::Request::GetProperties).unwrap();\n        let props = match res {\n            Ok(rpc::Response::GetProperties(props)) => props,\n            unexp @ _ => panic!(\"Expected GetProperties response: {:?}\", unexp),\n        };\n        let chain = minter.chain();\n        let max_height = props.height - (props.height % 5);\n        let min_height = max_height - NETWORK_FEE_AVG_WINDOW;\n        assert!(min_height < max_height);\n        let receipt_count = (min_height..=max_height).fold(1u64, |receipt_count, height| {\n            let block = chain.get_block(height).unwrap();\n            receipt_count + block.receipts().len() as u64\n        });\n        let receipt_count = (receipt_count / NETWORK_FEE_AVG_WINDOW) as u16;\n        assert!(receipt_count > 10);\n        let fee = GRAEL_FEE_MIN.checked_mul(GRAEL_FEE_NET_MULT.checked_pow(receipt_count).unwrap());\n        assert_eq!(Some(props.network_fee), fee);\n    }\n    for _ in 0..=NETWORK_FEE_AVG_WINDOW {\n        minter.produce_block().unwrap();\n    }\n    // Test network delta fee reset\n    let expected_fee = GRAEL_FEE_MIN.checked_mul(GRAEL_FEE_NET_MULT);\n    assert_eq!(minter.chain().get_network_fee(), expected_fee);\n"]]}
{"hexsha": "7ee77bc234dc7f335e2c53edac5b765a1a3cdf1d", "ext": "rs", "lang": "Rust", "content": "fn cp_equals_0() {\n        let mut mem: Memory = Memory::new();\n        let mut cpu: CPU = CPU::new(&mut mem);\n\n        cp(&mut cpu, Register8bits::B);\n\n        assert_eq!(cpu.registers.read_z_flag(), true)\n    }", "item_id": 53, "repo": "davidor/gebers", "file": "src/cpu/eight_bit_arithm_logic_ops.rs", "last_update_at": "2019-04-08T09:31:04+00:00", "question_id": "7ee77bc234dc7f335e2c53edac5b765a1a3cdf1d_53", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn cp_equals_0() {\n        let mut mem: Memory = Memory::new();\n        let mut cpu: CPU = CPU::new(&mut mem);\n        cp(&mut cpu, Register8bits::B);\n        assert_eq!(cpu.registers.read_z_flag(), true)\n"]]}
{"hexsha": "70ba18680993cec11915b7c1db8bad71851303be", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    env_logger::init();\n    let server = TcpListener::bind(\"127.0.0.1:3012\").unwrap();\n    for stream in server.incoming() {\n        spawn(move || {\n            let callback = |req: &Request| {\n                println!(\"Received a new ws handshake\");\n                println!(\"The request's path is: {}\", req.path);\n                println!(\"The request's headers are:\");\n                for &(ref header, _ /* value */) in req.headers.iter() {\n                    println!(\"* {}\", header);\n                }\n\n                // Let's add an additional header to our response to the client.\n                let extra_headers = vec![\n                    (String::from(\"MyCustomHeader\"), String::from(\":)\")),\n                    (\n                        String::from(\"SOME_TUNGSTENITE_HEADER\"),\n                        String::from(\"header_value\"),\n                    ),\n                ];\n                Ok(Some(extra_headers))\n            };\n            let mut websocket = accept_hdr(stream.unwrap(), callback).unwrap();\n\n            loop {\n                let msg = websocket.read_message().unwrap();\n                if msg.is_binary() || msg.is_text() {\n                    websocket.write_message(msg).unwrap();\n                }\n            }\n        });\n    }\n}", "item_id": 0, "repo": "psmit/tungstenite-rs", "file": "examples/server.rs", "last_update_at": "2019-09-14T03:53:51+00:00", "question_id": "70ba18680993cec11915b7c1db8bad71851303be_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    env_logger::init();\n    let server = TcpListener::bind(\"127.0.0.1:3012\").unwrap();\n    for stream in server.incoming() {\n        spawn(move || {\n            let callback = |req: &Request| {\n                println!(\"Received a new ws handshake\");\n                println!(\"The request's path is: {}\", req.path);\n                println!(\"The request's headers are:\");\n                for &(ref header, _ /* value */) in req.headers.iter() {\n                    println!(\"* {}\", header);\n                }\n                // Let's add an additional header to our response to the client.\n                let extra_headers = vec![\n                    (String::from(\"MyCustomHeader\"), String::from(\":)\")),\n                    (\n                        String::from(\"SOME_TUNGSTENITE_HEADER\"),\n                        String::from(\"header_value\"),\n                    ),\n                ];\n                Ok(Some(extra_headers))\n            };\n            let mut websocket = accept_hdr(stream.unwrap(), callback).unwrap();\n            loop {\n                let msg = websocket.read_message().unwrap();\n                if msg.is_binary() || msg.is_text() {\n                    websocket.write_message(msg).unwrap();\n                }\n            }\n        });\n    }\n"]]}
{"hexsha": "41d0d3de6eac7746cda3976054e9eb26c415cdf0", "ext": "rs", "lang": "Rust", "content": "pub fn mgf1(sha: usize,z: &[u8],olen: usize,k: &mut [u8]) {\n\tlet hlen=sha;\n\n\tlet mut j=0;\n\tfor i in 0..k.len() {k[i]=0}\n\n\tlet mut cthreshold=olen/hlen; \n\tif olen%hlen!=0 {cthreshold+=1}\n\tfor counter in 0..cthreshold {\n\t\tlet mut b:[u8;64]=[0;64];\t\t\n\t\thashit(sha,Some(z),counter as isize,&mut b);\n\n\t\tif j+hlen>olen {\n\t\t\tfor i in 0..(olen%hlen) {k[j]=b[i]; j+=1}\n\t\t} else {\n\t\t\tfor i in 0..hlen {k[j]=b[i]; j+=1}\n\t\t}\n\t}\t\n}", "item_id": 2, "repo": "jonnycrunch/crypto-lib", "file": "libhl-crypto/amcl/src/rsa4096/rsa.rs", "last_update_at": "2019-01-16T06:06:50+00:00", "question_id": "41d0d3de6eac7746cda3976054e9eb26c415cdf0_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn mgf1(sha: usize,z: &[u8],olen: usize,k: &mut [u8]) {\n\tlet hlen=sha;\n\tlet mut j=0;\n\tfor i in 0..k.len() {k[i]=0}\n\tlet mut cthreshold=olen/hlen; \n\tif olen%hlen!=0 {cthreshold+=1}\n\tfor counter in 0..cthreshold {\n\t\tlet mut b:[u8;64]=[0;64];\t\t\n\t\thashit(sha,Some(z),counter as isize,&mut b);\n\t\tif j+hlen>olen {\n\t\t\tfor i in 0..(olen%hlen) {k[j]=b[i]; j+=1}\n\t\t} else {\n\t\t\tfor i in 0..hlen {k[j]=b[i]; j+=1}\n\t\t}\n\t}\t\n"]]}
{"hexsha": "129ad04d63bb6f1759b4ff452fc1ab726b26815b", "ext": "rs", "lang": "Rust", "content": "pub fn request(bus: &Bus<Missive>, topic: Topic) -> RpcResult<Missive> {\n    let (tx, rx) = bounded(1);\n    trace!(\"making {:?} request to data service\", topic);\n    bus.send_top(Missive::DataRequest { topic, tx });\n    rx.recv()\n        .map_err(|_| app_error(68, \"data service channel disconnect\", None))?\n}", "item_id": 0, "repo": "passcod/trebuchet", "file": "src/castle/data.rs", "last_update_at": "2019-10-08T03:54:41+00:00", "question_id": "129ad04d63bb6f1759b4ff452fc1ab726b26815b_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn request(bus: &Bus<Missive>, topic: Topic) -> RpcResult<Missive> {\n    let (tx, rx) = bounded(1);\n    trace!(\"making {:?} request to data service\", topic);\n    bus.send_top(Missive::DataRequest { topic, tx });\n    rx.recv()\n        .map_err(|_| app_error(68, \"data service channel disconnect\", None))?\n"]]}
{"hexsha": "f2c37ea2a950ce027aef3faab5e285be074f7e15", "ext": "rs", "lang": "Rust", "content": "pub fn list(client: &PeripherioClient, matches: &ArgMatches) -> Result<(), Error> {\n    let conf: protos::Config = matches\n        .values_of(\"config\")\n        .map(|confs| util::parse_config_list(confs))\n        .unwrap_or(Ok(protos::Config::new()))?;\n    let mut req = protos::FindRequest::new();\n    req.set_config(conf);\n    let spec = util::get_driver_spec_from_matches(matches);\n    req.set_spec(spec);\n    let reply = client.find_drivers(&req)?;\n    println!(\"NAME VENDOR PATH CATEGORIES\");\n    for res in reply.get_results() {\n        let name = res.get_name();\n        let vendor = res.get_vendor();\n        let path = res.get_path();\n        let categories = res.get_category();\n        println!(\"{} {} {} {}\", name, vendor, path, categories.join(\",\"));\n    }\n    Ok(())\n}", "item_id": 0, "repo": "coord-e/unitry", "file": "src/subcommand/driver.rs", "last_update_at": "2019-02-01T14:16:02+00:00", "question_id": "f2c37ea2a950ce027aef3faab5e285be074f7e15_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn list(client: &PeripherioClient, matches: &ArgMatches) -> Result<(), Error> {\n    let conf: protos::Config = matches\n        .values_of(\"config\")\n        .map(|confs| util::parse_config_list(confs))\n        .unwrap_or(Ok(protos::Config::new()))?;\n    let mut req = protos::FindRequest::new();\n    req.set_config(conf);\n    let spec = util::get_driver_spec_from_matches(matches);\n    req.set_spec(spec);\n    let reply = client.find_drivers(&req)?;\n    println!(\"NAME VENDOR PATH CATEGORIES\");\n    for res in reply.get_results() {\n        let name = res.get_name();\n        let vendor = res.get_vendor();\n        let path = res.get_path();\n        let categories = res.get_category();\n        println!(\"{} {} {} {}\", name, vendor, path, categories.join(\",\"));\n    }\n    Ok(())\n"]]}
{"hexsha": "b66a82070f0cdb39812b5d4f11a4e6a29ad4b761", "ext": "rs", "lang": "Rust", "content": "fn bench_functional_curl_par(num_hashes: usize) {\n    print_title(&format!(\"Functional Curl ({} threads)\", num_cpus::get()));\n\n    let transactions_as_trits = get_random_tx_balanced_trits(num_hashes);\n    let num_threads = num_cpus::get();\n    let pool = Pool::new(num_threads);\n    let chunk_length = transactions_as_trits.len() / num_threads;\n    let index = AtomicUsize::new(0);\n\n    let start = Instant::now();\n    pool.scoped(|scope| {\n        for _ in 0..num_threads {\n            scope.execute(|| {\n                let i = index.fetch_add(1, Ordering::SeqCst);\n                //\n                let offset = i * chunk_length;\n                //println!(\"offset {} = {}\", i, offset);\n                for j in offset..offset + chunk_length {\n                    let _hash_trits =\n                        curl_func(&transactions_as_trits[j], NUM_CURL_ROUNDS);\n                }\n            })\n        }\n    });\n\n    print_timing(start.elapsed(), num_hashes);\n}", "item_id": 4, "repo": "Alex6323/bct_curl_rust", "file": "src/main.rs", "last_update_at": "2019-08-11T10:22:17+00:00", "question_id": "b66a82070f0cdb39812b5d4f11a4e6a29ad4b761_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn bench_functional_curl_par(num_hashes: usize) {\n    print_title(&format!(\"Functional Curl ({} threads)\", num_cpus::get()));\n    let transactions_as_trits = get_random_tx_balanced_trits(num_hashes);\n    let num_threads = num_cpus::get();\n    let pool = Pool::new(num_threads);\n    let chunk_length = transactions_as_trits.len() / num_threads;\n    let index = AtomicUsize::new(0);\n    let start = Instant::now();\n    pool.scoped(|scope| {\n        for _ in 0..num_threads {\n            scope.execute(|| {\n                let i = index.fetch_add(1, Ordering::SeqCst);\n                //\n                let offset = i * chunk_length;\n                //println!(\"offset {} = {}\", i, offset);\n                for j in offset..offset + chunk_length {\n                    let _hash_trits =\n                        curl_func(&transactions_as_trits[j], NUM_CURL_ROUNDS);\n                }\n            })\n        }\n    });\n    print_timing(start.elapsed(), num_hashes);\n"]]}
{"hexsha": "c353ad1ff9a32675118aa026e45a741a35429f84", "ext": "rs", "lang": "Rust", "content": "fn test_load_module() {\n        let path = Path::new(\"./test/test1.xm\");\n\n        let context = Context::new();\n\n        if let Ok(x) = load_module(&context, &path) {\n            assert_eq!(x, ());\n        }\n\n        if let Ok(x) = load_module(&context, &path) {\n            assert_eq!(x, ());\n        }\n\n    }", "item_id": 3, "repo": "cruatta/libxmp-rust", "file": "src/load.rs", "last_update_at": "2019-04-16T19:56:17+00:00", "question_id": "c353ad1ff9a32675118aa026e45a741a35429f84_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_load_module() {\n        let path = Path::new(\"./test/test1.xm\");\n        let context = Context::new();\n        if let Ok(x) = load_module(&context, &path) {\n            assert_eq!(x, ());\n        }\n        if let Ok(x) = load_module(&context, &path) {\n            assert_eq!(x, ());\n        }\n"]]}
{"hexsha": "90c5fc352a93b1bebb27db239274be41b3720df7", "ext": "rs", "lang": "Rust", "content": "pub fn decrypt_cms(smime: &[u8], pkey: &PKey, x509: &X509) -> Result<Vec<u8>> {\n    // now we need to read in that mime file\n    let cms = CmsContentInfo::smime_read_cms(smime)\n        .chain_err(|| \"failed to read cms file\")?;\n\n    // and decrypt it's contents\n    let p12_der = cms.decrypt(pkey, x509)\n        .chain_err(|| \"failed to decrypt cms file\")?;\n\n    Ok(p12_der)\n}", "item_id": 1, "repo": "lucab/coreos-metadata", "file": "src/providers/azure/crypto/mod.rs", "last_update_at": "2019-07-18T01:26:31+00:00", "question_id": "90c5fc352a93b1bebb27db239274be41b3720df7_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn decrypt_cms(smime: &[u8], pkey: &PKey, x509: &X509) -> Result<Vec<u8>> {\n    // now we need to read in that mime file\n    let cms = CmsContentInfo::smime_read_cms(smime)\n        .chain_err(|| \"failed to read cms file\")?;\n    // and decrypt it's contents\n    let p12_der = cms.decrypt(pkey, x509)\n        .chain_err(|| \"failed to decrypt cms file\")?;\n    Ok(p12_der)\n"]]}
{"hexsha": "3de5849ae4ee3680df1543cd530ce9b5fb349dcb", "ext": "rs", "lang": "Rust", "content": "fn test_shift_pos() {\n        let a: Int32Array = vec![Some(1), None, Some(4)].into();\n        let res = shift(&a, 1).unwrap();\n\n        let expected: Int32Array = vec![None, Some(1), None].into();\n\n        assert_eq!(res.as_ref(), &expected);\n    }", "item_id": 2, "repo": "dev870/arrow-rs", "file": "arrow/src/compute/kernels/window.rs", "last_update_at": "2019-03-21T16:02:48+00:00", "question_id": "3de5849ae4ee3680df1543cd530ce9b5fb349dcb_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_shift_pos() {\n        let a: Int32Array = vec![Some(1), None, Some(4)].into();\n        let res = shift(&a, 1).unwrap();\n        let expected: Int32Array = vec![None, Some(1), None].into();\n        assert_eq!(res.as_ref(), &expected);\n"]]}
{"hexsha": "c384b864cc14b2d84c3295275e9b7deb881dbb21", "ext": "rs", "lang": "Rust", "content": "fn project_first_column() -> Result<()> {\n        let schema = Arc::new(Schema::new(vec![\n            Field::new(\"c1\", DataType::Utf8, false),\n            Field::new(\"c2\", DataType::UInt32, false),\n            Field::new(\"c3\", DataType::Int8, false),\n            Field::new(\"c3\", DataType::Int16, false),\n            Field::new(\"c4\", DataType::Int32, false),\n            Field::new(\"c5\", DataType::Int64, false),\n            Field::new(\"c6\", DataType::UInt8, false),\n            Field::new(\"c7\", DataType::UInt16, false),\n            Field::new(\"c8\", DataType::UInt32, false),\n            Field::new(\"c9\", DataType::UInt64, false),\n            Field::new(\"c10\", DataType::Float32, false),\n            Field::new(\"c11\", DataType::Float64, false),\n            Field::new(\"c12\", DataType::Utf8, false),\n        ]));\n\n        let partitions = 4;\n        let path = create_partitioned_csv(\"aggregate_test_100.csv\", partitions)?;\n\n        let csv = CsvExec::try_new(&path, schema, true, None, 1024)?;\n\n        let projection =\n            ProjectionExec::try_new(vec![Arc::new(Column::new(0))], Arc::new(csv))?;\n\n        let mut partition_count = 0;\n        let mut row_count = 0;\n        for partition in projection.partitions()? {\n            partition_count += 1;\n            let iterator = partition.execute()?;\n            let mut iterator = iterator.lock().unwrap();\n            while let Some(batch) = iterator.next()? {\n                assert_eq!(1, batch.num_columns());\n                row_count += batch.num_rows();\n            }\n        }\n        assert_eq!(partitions, partition_count);\n        assert_eq!(100, row_count);\n\n        Ok(())\n    }", "item_id": 0, "repo": "harrism/arrow", "file": "rust/datafusion/src/execution/physical_plan/projection.rs", "last_update_at": "2019-03-14T19:51:12+00:00", "question_id": "c384b864cc14b2d84c3295275e9b7deb881dbb21_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn project_first_column() -> Result<()> {\n        let schema = Arc::new(Schema::new(vec![\n            Field::new(\"c1\", DataType::Utf8, false),\n            Field::new(\"c2\", DataType::UInt32, false),\n            Field::new(\"c3\", DataType::Int8, false),\n            Field::new(\"c3\", DataType::Int16, false),\n            Field::new(\"c4\", DataType::Int32, false),\n            Field::new(\"c5\", DataType::Int64, false),\n            Field::new(\"c6\", DataType::UInt8, false),\n            Field::new(\"c7\", DataType::UInt16, false),\n            Field::new(\"c8\", DataType::UInt32, false),\n            Field::new(\"c9\", DataType::UInt64, false),\n            Field::new(\"c10\", DataType::Float32, false),\n            Field::new(\"c11\", DataType::Float64, false),\n            Field::new(\"c12\", DataType::Utf8, false),\n        ]));\n        let partitions = 4;\n        let path = create_partitioned_csv(\"aggregate_test_100.csv\", partitions)?;\n        let csv = CsvExec::try_new(&path, schema, true, None, 1024)?;\n        let projection =\n            ProjectionExec::try_new(vec![Arc::new(Column::new(0))], Arc::new(csv))?;\n        let mut partition_count = 0;\n        let mut row_count = 0;\n        for partition in projection.partitions()? {\n            partition_count += 1;\n            let iterator = partition.execute()?;\n            let mut iterator = iterator.lock().unwrap();\n            while let Some(batch) = iterator.next()? {\n                assert_eq!(1, batch.num_columns());\n                row_count += batch.num_rows();\n            }\n        }\n        assert_eq!(partitions, partition_count);\n        assert_eq!(100, row_count);\n        Ok(())\n"]]}
{"hexsha": "b2b437f22354245840eca3e6e498291427c5015f", "ext": "rs", "lang": "Rust", "content": "fn parse_note_no_accidentals() {\n        let result = parser(note).parse(\"A\");\n        assert_eq!(result, Ok((Note::new(A, 0), \"\")));\n\n        let result = parser(note).parse(\"G\");\n        assert_eq!(result, Ok((Note::new(G, 0), \"\")));\n    }", "item_id": 3, "repo": "tiehuis/quartic", "file": "src/parser.rs", "last_update_at": "2019-12-07T16:41:57+00:00", "question_id": "b2b437f22354245840eca3e6e498291427c5015f_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn parse_note_no_accidentals() {\n        let result = parser(note).parse(\"A\");\n        assert_eq!(result, Ok((Note::new(A, 0), \"\")));\n        let result = parser(note).parse(\"G\");\n        assert_eq!(result, Ok((Note::new(G, 0), \"\")));\n"]]}
{"hexsha": "5a6392e2dcffd27633f9d2c79ed11b872ef7f9f9", "ext": "rs", "lang": "Rust", "content": "fn swap_fields2() {\n    let int = TypeInfo::new_fundamental::<i64>();\n    let float = TypeInfo::new_fundamental::<f64>();\n\n    let struct1 = TypeInfo::new_struct(\n        STRUCT1_NAME,\n        STRUCT1_GUID,\n        StructInfo::new(&[(\"a\", &float), (\"b\", &int), (\"c\", &float), (\"d\", &int)]),\n    );\n    let struct2 = TypeInfo::new_struct(\n        STRUCT1_NAME,\n        STRUCT2_GUID,\n        StructInfo::new(&[(\"d\", &int), (\"c\", &float), (\"b\", &int), (\"a\", &float)]),\n    );\n\n    let old = &[&struct1];\n    let new = &[&struct2];\n\n    let diff = diff(old, new);\n    assert_eq!(\n        diff,\n        vec![Diff::Edit {\n            diff: vec![\n                FieldDiff::Move {\n                    old_index: 0,\n                    new_index: 3,\n                    edit: None,\n                },\n                FieldDiff::Move {\n                    old_index: 1,\n                    new_index: 2,\n                    edit: None,\n                },\n                FieldDiff::Move {\n                    old_index: 2,\n                    new_index: 1,\n                    edit: None,\n                }\n            ],\n            old_index: 0,\n            new_index: 0\n        }]\n    );\n    assert_eq_struct(&apply_diff(old, new, diff), &[struct2.clone()]);\n}", "item_id": 11, "repo": "mun-lang/runtime", "file": "crates/mun_memory/tests/diff/structs.rs", "last_update_at": "2019-09-28T10:51:34+00:00", "question_id": "5a6392e2dcffd27633f9d2c79ed11b872ef7f9f9_11", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn swap_fields2() {\n    let int = TypeInfo::new_fundamental::<i64>();\n    let float = TypeInfo::new_fundamental::<f64>();\n    let struct1 = TypeInfo::new_struct(\n        STRUCT1_NAME,\n        STRUCT1_GUID,\n        StructInfo::new(&[(\"a\", &float), (\"b\", &int), (\"c\", &float), (\"d\", &int)]),\n    );\n    let struct2 = TypeInfo::new_struct(\n        STRUCT1_NAME,\n        STRUCT2_GUID,\n        StructInfo::new(&[(\"d\", &int), (\"c\", &float), (\"b\", &int), (\"a\", &float)]),\n    );\n    let old = &[&struct1];\n    let new = &[&struct2];\n    let diff = diff(old, new);\n    assert_eq!(\n        diff,\n        vec![Diff::Edit {\n            diff: vec![\n                FieldDiff::Move {\n                    old_index: 0,\n                    new_index: 3,\n                    edit: None,\n                },\n                FieldDiff::Move {\n                    old_index: 1,\n                    new_index: 2,\n                    edit: None,\n                },\n                FieldDiff::Move {\n                    old_index: 2,\n                    new_index: 1,\n                    edit: None,\n                }\n            ],\n            old_index: 0,\n            new_index: 0\n        }]\n    );\n    assert_eq_struct(&apply_diff(old, new, diff), &[struct2.clone()]);\n"]]}
{"hexsha": "3d55062c5244f88dcd462a368f5ca932bdf94007", "ext": "rs", "lang": "Rust", "content": "fn spec_test_88() {\n    let original = r##\"    foo  \n\"##;\n    let expected = r##\"<pre><code>foo  \n</code></pre>\n\"##;\n\n    test_markdown_html(original, expected);\n}", "item_id": 87, "repo": "NaokiM03/pulldown-cmark", "file": "tests/suite/spec.rs", "last_update_at": "2019-07-11T13:20:46+00:00", "question_id": "3d55062c5244f88dcd462a368f5ca932bdf94007_87", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn spec_test_88() {\n    let original = r##\"    foo  \n\"##;\n    let expected = r##\"<pre><code>foo  \n</code></pre>\n\"##;\n    test_markdown_html(original, expected);\n"]]}
{"hexsha": "3f36e0b1faaea8f1d4fec66a2bea1c6bacda2743", "ext": "rs", "lang": "Rust", "content": "fn valid_render_config_is_parsed() {\n        let input = r##\"config:\n        step = 8\n        angle = 45\n        \"##;\n\n        let (actual, _rem) = render_config().parse(input).expect(\"to parse a configuration\");\n\n        let expected = RenderConfig { step: 8, angle: 45 };\n        assert_eq!(actual, expected);\n    }", "item_id": 2, "repo": "jacobmischka/workshop", "file": "code/examplar-parser/src/lib.rs", "last_update_at": "2019-11-10T13:34:47+00:00", "question_id": "3f36e0b1faaea8f1d4fec66a2bea1c6bacda2743_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn valid_render_config_is_parsed() {\n        let input = r##\"config:\n        step = 8\n        angle = 45\n        \"##;\n        let (actual, _rem) = render_config().parse(input).expect(\"to parse a configuration\");\n        let expected = RenderConfig { step: 8, angle: 45 };\n        assert_eq!(actual, expected);\n"]]}
{"hexsha": "c4c344049bf2ae99456a3241210d1b016f5e299b", "ext": "rs", "lang": "Rust", "content": "fn get_total_input_amount(inputs: &[TransactionInput]) -> Result<Option<Coin>> {\n    if inputs.is_empty() {\n        return Ok(None);\n    }\n\n    let mut amount = Coin::zero();\n\n    for input in inputs.iter() {\n        if let Some(ref output) = input.output {\n            amount = (amount + output.value).chain(|| {\n                (\n                    ErrorKind::IllegalInput,\n                    \"Total input amount exceeded maximum allowed value\",\n                )\n            })?;\n        } else {\n            return Ok(None);\n        }\n    }\n\n    Ok(Some(amount))\n}", "item_id": 1, "repo": "leejw51/chain", "file": "client-core/src/handler/default_transaction_handler.rs", "last_update_at": "2019-07-02T12:26:31+00:00", "question_id": "c4c344049bf2ae99456a3241210d1b016f5e299b_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_total_input_amount(inputs: &[TransactionInput]) -> Result<Option<Coin>> {\n    if inputs.is_empty() {\n        return Ok(None);\n    }\n    let mut amount = Coin::zero();\n    for input in inputs.iter() {\n        if let Some(ref output) = input.output {\n            amount = (amount + output.value).chain(|| {\n                (\n                    ErrorKind::IllegalInput,\n                    \"Total input amount exceeded maximum allowed value\",\n                )\n            })?;\n        } else {\n            return Ok(None);\n        }\n    }\n    Ok(Some(amount))\n"]]}
{"hexsha": "6a6683404adcff3d9c623ffb7de7de2d2e2629fd", "ext": "rs", "lang": "Rust", "content": "pub fn test_display_formatting_precision() {\n    let our_matrix = matrix![1.2, 1.23, 1.234;\n                             1.2345, 1.23456, 1.234567];\n    let expectations = vec![\"\u23a11.2 1.2 1.2\u23a4\\n\u23a31.2 1.2 1.2\u23a6\",\n\n                            \"\u23a11.20 1.23 1.23\u23a4\\n\u23a31.23 1.23 1.23\u23a6\",\n\n                            \"\u23a11.200 1.230 1.234\u23a4\\n\u23a31.234 1.235 1.235\u23a6\",\n\n                            \"\u23a11.2000 1.2300 1.2340\u23a4\\n\u23a31.2345 1.2346 1.2346\u23a6\"];\n\n    for (places, &expectation) in (1..5).zip(expectations.iter()) {\n        assert_eq!(expectation, format!(\"{:.1$}\", our_matrix, places));\n    }\n}", "item_id": 5, "repo": "mesalock-linux/rulinalg-sgx", "file": "sgx/rulinalg-sgx-test/enclave/src/matrix/impl_mat.rs", "last_update_at": "2019-08-22T16:34:34+00:00", "question_id": "6a6683404adcff3d9c623ffb7de7de2d2e2629fd_5", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn test_display_formatting_precision() {\n    let our_matrix = matrix![1.2, 1.23, 1.234;\n                             1.2345, 1.23456, 1.234567];\n    let expectations = vec![\"\u23a11.2 1.2 1.2\u23a4\\n\u23a31.2 1.2 1.2\u23a6\",\n                            \"\u23a11.20 1.23 1.23\u23a4\\n\u23a31.23 1.23 1.23\u23a6\",\n                            \"\u23a11.200 1.230 1.234\u23a4\\n\u23a31.234 1.235 1.235\u23a6\",\n                            \"\u23a11.2000 1.2300 1.2340\u23a4\\n\u23a31.2345 1.2346 1.2346\u23a6\"];\n    for (places, &expectation) in (1..5).zip(expectations.iter()) {\n        assert_eq!(expectation, format!(\"{:.1$}\", our_matrix, places));\n    }\n"]]}
{"hexsha": "b45b03cd956ff41ab46eea2227102a13d91b54a4", "ext": "rs", "lang": "Rust", "content": "fn test_fetch_problem_list() {\n        let client = CodeChefClient::default();\n        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Beginner)).is_ok());\n        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Easy)).is_ok());\n        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Medium)).is_ok());\n        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Hard)).is_ok());\n        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Challenge)).is_ok());\n        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Peer)).is_ok());\n    }", "item_id": 0, "repo": "kenkoooo/algorithm-problem-client", "file": "src/codechef/client.rs", "last_update_at": "2019-07-20T19:47:00+00:00", "question_id": "b45b03cd956ff41ab46eea2227102a13d91b54a4_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_fetch_problem_list() {\n        let client = CodeChefClient::default();\n        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Beginner)).is_ok());\n        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Easy)).is_ok());\n        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Medium)).is_ok());\n        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Hard)).is_ok());\n        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Challenge)).is_ok());\n        assert!(block_on(client.fetch_problem_list(CodeChefProblemPage::Peer)).is_ok());\n"]]}
{"hexsha": "198fbbebfea1a34dc7c7289b20b4b10882195892", "ext": "rs", "lang": "Rust", "content": "fn rsa_shadower1_test () {\n  let smode = ASymSymMode::None;\n  let input_length = 256;\n  let write_buffer_length = 256;\n  let read_buffer_length = 256;\n  rsa_shadower_test (input_length, write_buffer_length, read_buffer_length, smode);\n}", "item_id": 3, "repo": "cheme/mydht", "file": "mydht-openssl/src/rsa_openssl.rs", "last_update_at": "2019-05-30T09:40:00+00:00", "question_id": "198fbbebfea1a34dc7c7289b20b4b10882195892_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn rsa_shadower1_test () {\n  let smode = ASymSymMode::None;\n  let input_length = 256;\n  let write_buffer_length = 256;\n  let read_buffer_length = 256;\n  rsa_shadower_test (input_length, write_buffer_length, read_buffer_length, smode);\n"]]}
{"hexsha": "46841c61f445d80c26a7c5ae2f23d153f10c9a62", "ext": "rs", "lang": "Rust", "content": "fn get_field_1_test(){\n        assert_eq!(*get_field_1(&(2,8)), 8);\n        assert_eq!(*get_field_1(&(2,5,8)), 5);\n        assert_eq!(*get_field_1(&(2,3,5,8)), 3);\n        assert_eq!(*get_field_1(&(1,2,3,5,8)), 2);\n        assert_eq!(*get_field_1(&(1,1,2,3,5,8)), 1);\n        assert_eq!(*get_field_1(&(11,13,17,19,23,29,31)), 13);\n        assert_eq!(*get_field_1(&(7,11,13,17,19,23,29,31)), 11);\n        assert_eq!(*get_field_1(&(5,7,11,13,17,19,23,29,31)), 7);\n        assert_eq!(*get_field_1(&(3,5,7,11,13,17,19,23,29,31)), 5);\n    }", "item_id": 0, "repo": "RalfJung/structural_crates", "file": "structural/src/field_traits/tuple_impls.rs", "last_update_at": "2019-12-06T08:59:49+00:00", "question_id": "46841c61f445d80c26a7c5ae2f23d153f10c9a62_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_field_1_test(){\n        assert_eq!(*get_field_1(&(2,8)), 8);\n        assert_eq!(*get_field_1(&(2,5,8)), 5);\n        assert_eq!(*get_field_1(&(2,3,5,8)), 3);\n        assert_eq!(*get_field_1(&(1,2,3,5,8)), 2);\n        assert_eq!(*get_field_1(&(1,1,2,3,5,8)), 1);\n        assert_eq!(*get_field_1(&(11,13,17,19,23,29,31)), 13);\n        assert_eq!(*get_field_1(&(7,11,13,17,19,23,29,31)), 11);\n        assert_eq!(*get_field_1(&(5,7,11,13,17,19,23,29,31)), 7);\n        assert_eq!(*get_field_1(&(3,5,7,11,13,17,19,23,29,31)), 5);\n"]]}
{"hexsha": "bf7fba5b4cafdd53b35d36aec525c4d622721384", "ext": "rs", "lang": "Rust", "content": "fn permissions() {\n        use nix::sys::stat::{self, Mode};\n        let path = std::path::Path::new(\"./test_pipe_2\");\n        let assert_stats_eq = |input| {\n            super::create_pipe(path, input).expect(\"Failed to create pipe\");\n            let file_stat = stat::stat(path).expect(\"Failed to get file stat\");\n            let mode = Mode::from_bits_truncate(file_stat.st_mode);\n            if let Some(new_mode) = input {\n                assert_eq!(mode, new_mode);\n            } else {\n                assert_eq!(mode, Mode::from_bits_truncate(0o660));\n            }\n            block_on(super::remove_pipe(path)).expect(\"Failed to remove pipe\");\n        };\n        // Defaults\n        assert_stats_eq(None);\n        // Custom mode\n        assert_stats_eq(Some(Mode::from_bits_truncate(0o644)));\n    }", "item_id": 1, "repo": "Follpvosten/unix-fifo-async", "file": "src/util.rs", "last_update_at": "2019-09-03T10:42:35+00:00", "question_id": "bf7fba5b4cafdd53b35d36aec525c4d622721384_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn permissions() {\n        use nix::sys::stat::{self, Mode};\n        let path = std::path::Path::new(\"./test_pipe_2\");\n        let assert_stats_eq = |input| {\n            super::create_pipe(path, input).expect(\"Failed to create pipe\");\n            let file_stat = stat::stat(path).expect(\"Failed to get file stat\");\n            let mode = Mode::from_bits_truncate(file_stat.st_mode);\n            if let Some(new_mode) = input {\n                assert_eq!(mode, new_mode);\n            } else {\n                assert_eq!(mode, Mode::from_bits_truncate(0o660));\n            }\n            block_on(super::remove_pipe(path)).expect(\"Failed to remove pipe\");\n        };\n        // Defaults\n        assert_stats_eq(None);\n        // Custom mode\n        assert_stats_eq(Some(Mode::from_bits_truncate(0o644)));\n"]]}
{"hexsha": "46ca2e4cf6900a338f6f55ef8f15c6b3e89df3f4", "ext": "rs", "lang": "Rust", "content": "pub fn profile_upage(db: DB, id: i32, user: auth::User) -> Template {\n\tlet result = User::query_by_id(db.conn(), id);\n\tlet mut context = user_context(&db, user);\n\tif let Some(profile) = result.first() {\n\t\tcontext.insert(\"profile\", profile);\n\t}\n\tTemplate::render(\"profile\", &context)\n}", "item_id": 2, "repo": "C0n5t4ntK/unless", "file": "src/controller/user.rs", "last_update_at": "2019-10-31T00:08:09+00:00", "question_id": "46ca2e4cf6900a338f6f55ef8f15c6b3e89df3f4_2", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn profile_upage(db: DB, id: i32, user: auth::User) -> Template {\n\tlet result = User::query_by_id(db.conn(), id);\n\tlet mut context = user_context(&db, user);\n\tif let Some(profile) = result.first() {\n\t\tcontext.insert(\"profile\", profile);\n\t}\n\tTemplate::render(\"profile\", &context)\n"]]}
{"hexsha": "64d453f90c5f0322b90a2e56396bff644c17bbdd", "ext": "rs", "lang": "Rust", "content": "fn modifiers_to_gdk_modifier_type(modifiers: Modifiers) -> gdk::ModifierType {\n    let mut result = ModifierType::empty();\n\n    result.set(ModifierType::MOD1_MASK, modifiers & M_ALT == M_ALT);\n    result.set(ModifierType::CONTROL_MASK, modifiers & M_CTRL == M_CTRL);\n    result.set(ModifierType::SHIFT_MASK, modifiers & M_SHIFT == M_SHIFT);\n    result.set(ModifierType::META_MASK, modifiers & M_META == M_META);\n\n    result\n}", "item_id": 0, "repo": "vbsteven/druid", "file": "druid-shell/src/gtk/menu.rs", "last_update_at": "2019-09-13T13:29:42+00:00", "question_id": "64d453f90c5f0322b90a2e56396bff644c17bbdd_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn modifiers_to_gdk_modifier_type(modifiers: Modifiers) -> gdk::ModifierType {\n    let mut result = ModifierType::empty();\n    result.set(ModifierType::MOD1_MASK, modifiers & M_ALT == M_ALT);\n    result.set(ModifierType::CONTROL_MASK, modifiers & M_CTRL == M_CTRL);\n    result.set(ModifierType::SHIFT_MASK, modifiers & M_SHIFT == M_SHIFT);\n    result.set(ModifierType::META_MASK, modifiers & M_META == M_META);\n    result\n"]]}
{"hexsha": "01eb19df7b2b2680259e3d4ce64ff154926f277f", "ext": "rs", "lang": "Rust", "content": "pub fn parse_ruleset<I: 'static>(\n    tokens: &mut Peekable<I>,\n    selector_group: Option<&SelectorGroup>,\n) -> Option<RulesetNode>\nwhere\n    I: Iterator<Item = TokenTree>,\n{\n    let mut declarations = Vec::<DeclarationNode>::new();\n    let mut nested_rulesets = Vec::<RulesetNode>::new();\n    let mut root_metadatas = Vec::<MetadataNode>::new();\n    let mut rule_metadatas = Vec::<MetadataNode>::new();\n    let mut first = None;\n    let mut last = None;\n\n    let mut parse_declaration = |rule_metadatas: &mut Vec<MetadataNode>,\n                                 declarations: &mut Vec<DeclarationNode>,\n                                 tokens: &mut Peekable<I>| {\n        let parsed = parse_declaration(rule_metadatas.to_vec(), tokens);\n\n        if let Some(node) = parsed {\n            if first.is_none() {\n                first = Some(node.range);\n            }\n            last = Some(node.range);\n\n            declarations.push(node);\n        }\n    };\n\n    loop {\n        let token = tokens.peek().cloned();\n        match token {\n            Some(TokenTree::Punct(ref token)) if token.as_char() == '#' => {\n                let sharp = tokens.next().expect(\"Guaranteed by match\");\n\n                let parsed = parse_metadata(sharp, tokens);\n\n                match parsed {\n                    Some(node @ MetadataNode {\n                        metadata_type: MetadataType::Root,\n                        ..\n                    }) => {\n                        if !rule_metadatas.is_empty() || !declarations.is_empty() {\n                            node.range.warning(\"Put root metadata on the first of ruleset\").emit();\n                        }\n                        if selector_group.is_some() {\n                            node.range.error(\"Put root metadata on the root of ruleset\").emit();\n                            continue;\n                        }\n                        root_metadatas.push(node);\n                    },\n                    Some(node @ MetadataNode {\n                        metadata_type: MetadataType::Rule,\n                        ..\n                    }) => {\n                        rule_metadatas.push(node);\n                    }\n                    _ => {\n                        // todo: unwrap_or(parse_selector())\n                        panic!(\"Not Implemented\")\n                    }\n                }\n                continue;\n            }\n            Some(TokenTree::Punct(ref punct))\n            // class selector\n            if punct.as_char() == '.'\n            // itself selector\n            || punct.as_char() == '&'\n            // universal selector\n            || punct.as_char() == '*'\n            // state selector\n            || punct.as_char() == ':'\n            // adjacent sibling selector\n            || punct.as_char() == '+'\n            // general sibling selector\n            || punct.as_char() == '~'\n            // child selector\n            || punct.as_char() == '>' =>\n            {\n                if let Some((parsed_selector_group, stream)) = parse_selector_group(vec!(), tokens) {\n                    let mut joined = Vec::<Selector>::new();\n                    if let Some(selector_group) = selector_group.cloned() {\n                        for selector in selector_group {\n                            joined.push(selector);\n                        }\n                    }\n                    for selector in parsed_selector_group {\n                        joined.push(selector);\n                    }\n\n                    if let Some(ruleset) = parse_ruleset(&mut stream.into_iter().peekable(), Some(&joined)) {\n                        nested_rulesets.push(ruleset);\n                    } else {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            }\n            Some(TokenTree::Group(ref token)) if token.delimiter() == Delimiter::Bracket => {\n                // todo: parse_selector()\n                break;\n            }\n            Some(TokenTree::Ident(_))  => {\n                parse_declaration(&mut rule_metadatas, &mut declarations, tokens);\n            }\n            Some(TokenTree::Punct(ref token)) if token.as_char() == '-' => {\n                parse_declaration(&mut rule_metadatas,&mut declarations, tokens);\n            }\n            Some(TokenTree::Punct(ref token)) if token.as_char() == ';' => {\n                parse_declaration(&mut rule_metadatas, &mut declarations,tokens);\n            }\n            None => {\n                break;\n            }\n            Some(token) => {\n                token.span().error(format!(\"Unacceptable token {:?}\", token.to_string())).emit();\n                return None;\n            }\n        }\n    }\n\n    if declarations.is_empty() {\n        None\n    } else {\n        Some(RulesetNode {\n            range: first.map(|first| first.join(last.unwrap_or(first)).expect(\"In the same file\")),\n            declarations: declarations,\n            metadatas: root_metadatas,\n            nested_rulesets: nested_rulesets,\n            ruleset_type: selector_group.map_or(RulesetType::Root, |selector_group| {\n                RulesetType::Selector(selector_group.to_vec())\n            }),\n        })\n    }\n}", "item_id": 0, "repo": "RanolP/rustyle", "file": "parse/src/ruleset.rs", "last_update_at": "2019-05-05T15:46:57+00:00", "question_id": "01eb19df7b2b2680259e3d4ce64ff154926f277f_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn parse_ruleset<I: 'static>(\n    tokens: &mut Peekable<I>,\n    selector_group: Option<&SelectorGroup>,\n) -> Option<RulesetNode>\nwhere\n    I: Iterator<Item = TokenTree>,\n{\n    let mut declarations = Vec::<DeclarationNode>::new();\n    let mut nested_rulesets = Vec::<RulesetNode>::new();\n    let mut root_metadatas = Vec::<MetadataNode>::new();\n    let mut rule_metadatas = Vec::<MetadataNode>::new();\n    let mut first = None;\n    let mut last = None;\n    let mut parse_declaration = |rule_metadatas: &mut Vec<MetadataNode>,\n                                 declarations: &mut Vec<DeclarationNode>,\n                                 tokens: &mut Peekable<I>| {\n        let parsed = parse_declaration(rule_metadatas.to_vec(), tokens);\n        if let Some(node) = parsed {\n            if first.is_none() {\n                first = Some(node.range);\n            }\n            last = Some(node.range);\n            declarations.push(node);\n        }\n    };\n    loop {\n        let token = tokens.peek().cloned();\n        match token {\n            Some(TokenTree::Punct(ref token)) if token.as_char() == '#' => {\n                let sharp = tokens.next().expect(\"Guaranteed by match\");\n                let parsed = parse_metadata(sharp, tokens);\n                match parsed {\n                    Some(node @ MetadataNode {\n                        metadata_type: MetadataType::Root,\n                        ..\n                    }) => {\n                        if !rule_metadatas.is_empty() || !declarations.is_empty() {\n                            node.range.warning(\"Put root metadata on the first of ruleset\").emit();\n                        }\n                        if selector_group.is_some() {\n                            node.range.error(\"Put root metadata on the root of ruleset\").emit();\n                            continue;\n                        }\n                        root_metadatas.push(node);\n                    },\n                    Some(node @ MetadataNode {\n                        metadata_type: MetadataType::Rule,\n                        ..\n                    }) => {\n                        rule_metadatas.push(node);\n                    }\n                    _ => {\n                        // todo: unwrap_or(parse_selector())\n                        panic!(\"Not Implemented\")\n                    }\n                }\n                continue;\n            }\n            Some(TokenTree::Punct(ref punct))\n            // class selector\n            if punct.as_char() == '.'\n            // itself selector\n            || punct.as_char() == '&'\n            // universal selector\n            || punct.as_char() == '*'\n            // state selector\n            || punct.as_char() == ':'\n            // adjacent sibling selector\n            || punct.as_char() == '+'\n            // general sibling selector\n            || punct.as_char() == '~'\n            // child selector\n            || punct.as_char() == '>' =>\n            {\n                if let Some((parsed_selector_group, stream)) = parse_selector_group(vec!(), tokens) {\n                    let mut joined = Vec::<Selector>::new();\n                    if let Some(selector_group) = selector_group.cloned() {\n                        for selector in selector_group {\n                            joined.push(selector);\n                        }\n                    }\n                    for selector in parsed_selector_group {\n                        joined.push(selector);\n                    }\n                    if let Some(ruleset) = parse_ruleset(&mut stream.into_iter().peekable(), Some(&joined)) {\n                        nested_rulesets.push(ruleset);\n                    } else {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            }\n            Some(TokenTree::Group(ref token)) if token.delimiter() == Delimiter::Bracket => {\n                // todo: parse_selector()\n                break;\n            }\n            Some(TokenTree::Ident(_))  => {\n                parse_declaration(&mut rule_metadatas, &mut declarations, tokens);\n            }\n            Some(TokenTree::Punct(ref token)) if token.as_char() == '-' => {\n                parse_declaration(&mut rule_metadatas,&mut declarations, tokens);\n            }\n            Some(TokenTree::Punct(ref token)) if token.as_char() == ';' => {\n                parse_declaration(&mut rule_metadatas, &mut declarations,tokens);\n            }\n            None => {\n                break;\n            }\n            Some(token) => {\n                token.span().error(format!(\"Unacceptable token {:?}\", token.to_string())).emit();\n                return None;\n            }\n        }\n    }\n    if declarations.is_empty() {\n        None\n    } else {\n        Some(RulesetNode {\n            range: first.map(|first| first.join(last.unwrap_or(first)).expect(\"In the same file\")),\n            declarations: declarations,\n            metadatas: root_metadatas,\n            nested_rulesets: nested_rulesets,\n            ruleset_type: selector_group.map_or(RulesetType::Root, |selector_group| {\n                RulesetType::Selector(selector_group.to_vec())\n            }),\n        })\n    }\n"]]}
{"hexsha": "eeb9ebd9e83e5060cf92d257badc608ec4e98992", "ext": "rs", "lang": "Rust", "content": "fn get_precision(qualifiers: &Option<syntax::TypeQualifier>) -> Option<PrecisionQualifier>{\n    let mut precision = None;\n    for qual in qualifiers.iter().flat_map(|x| x.qualifiers.0.iter()) {\n        match qual {\n            syntax::TypeQualifierSpec::Precision(p) => {\n                if precision.is_some() {\n                    panic!(\"Multiple precisions\");\n                }\n                precision = Some(p.clone());\n            }\n            _ => {}\n        }\n    }\n    precision\n}", "item_id": 0, "repo": "jrmuizel/glsl-to-spriv", "file": "src/hir.rs", "last_update_at": "2019-08-20T09:50:51+00:00", "question_id": "eeb9ebd9e83e5060cf92d257badc608ec4e98992_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn get_precision(qualifiers: &Option<syntax::TypeQualifier>) -> Option<PrecisionQualifier>{\n    let mut precision = None;\n    for qual in qualifiers.iter().flat_map(|x| x.qualifiers.0.iter()) {\n        match qual {\n            syntax::TypeQualifierSpec::Precision(p) => {\n                if precision.is_some() {\n                    panic!(\"Multiple precisions\");\n                }\n                precision = Some(p.clone());\n            }\n            _ => {}\n        }\n    }\n    precision\n"]]}
{"hexsha": "e611f1ab455078c81fca0e23255d860706740bd3", "ext": "rs", "lang": "Rust", "content": "fn main() {\n    env_logger::init();\n\n    let args: Vec<_> = env::args().collect();\n    \n    if args.len() != 2 { // main.rs INPUT_FILE\n        println!(\"Wrong number of arguments!\");\n        println!(\"Format: INPUT_FILE\");\n\n        process::abort();\n    }\n\n    let in_file = &args[1];\n\n    let program = fs::read_to_string(in_file).expect(\"Failed to read input file\");\n\n    let mut computer: Computer = Computer::new();\n    computer = computer.read_program(program);\n\n    while !computer.is_stopped() {\n        computer = computer.cycle();\n    }\n}", "item_id": 0, "repo": "TheLocust3/simple-virtual-machine", "file": "emu/src/main.rs", "last_update_at": "2019-02-18T04:28:41+00:00", "question_id": "e611f1ab455078c81fca0e23255d860706740bd3_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn main() {\n    env_logger::init();\n    let args: Vec<_> = env::args().collect();\n    if args.len() != 2 { // main.rs INPUT_FILE\n        println!(\"Wrong number of arguments!\");\n        println!(\"Format: INPUT_FILE\");\n        process::abort();\n    }\n    let in_file = &args[1];\n    let program = fs::read_to_string(in_file).expect(\"Failed to read input file\");\n    let mut computer: Computer = Computer::new();\n    computer = computer.read_program(program);\n    while !computer.is_stopped() {\n        computer = computer.cycle();\n    }\n"]]}
{"hexsha": "b58d5fdb9b9ccd968c297d727f1f4aeeb81a12f9", "ext": "rs", "lang": "Rust", "content": "pub fn subactions(tokens: &[&str], character: &str) -> Vec<&'static str> {\n    // TODO: This should be made a vector to contain all the subactions related to the action. (multiple jabs, smash attack startup/attack)\n    // TODO: Manually handle character specific stuff such as jabs, glides, etc\n    let mut subactions = vec!();\n\n    // common movement\n    if tokens.contains(&\"dash\")                              { subactions = vec!(\"Dash\") }\n    if tokens.contains(&\"run\")                               { subactions = vec!(\"Run\") }\n    if tokens.contains(&\"teeter\")                            { subactions = vec!(\"OttottoWait\") }\n    if tokens.contains(&\"crouch\")                            { subactions = vec!(\"SquatWait\") }\n    if tokens.contains(&\"idle\")                              { subactions = vec!(\"Wait1\") }\n    if tokens.contains(&\"jump\") && tokens.contains(&\"squat\") { subactions = vec!(\"JumpSquat\") }\n    if tokens.contains(&\"jumpsquat\")                         { subactions = vec!(\"JumpSquat\") }\n\n    // jabs\n    if tokens.contains(&\"jab\") { subactions = vec!(\"Attack11\") }\n\n    // dash attack\n    if tokens.contains(&\"dash\") && tokens.contains(&\"attack\") { subactions = vec!(\"AttackDash\") }\n    if tokens.contains(&\"dashattack\")                         { subactions = vec!(\"AttackDash\") }\n\n    // grabs\n    if tokens.contains(&\"grab\")                              { subactions = vec!(\"Catch\") }\n    if tokens.contains(&\"dash\")  && tokens.contains(&\"grab\") { subactions = vec!(\"CatchDash\") }\n    if tokens.contains(&\"dashgrab\")                          { subactions = vec!(\"CatchDash\") }\n    if tokens.contains(&\"pivot\") && tokens.contains(&\"grab\") { subactions = vec!(\"CatchTurn\") }\n    if tokens.contains(&\"pivotgrab\")                         { subactions = vec!(\"CatchTurn\") }\n    if tokens.contains(&\"turn\")  && tokens.contains(&\"grab\") { subactions = vec!(\"CatchTurn\") }\n    if tokens.contains(&\"turngrab\")                          { subactions = vec!(\"CatchTurn\") }\n    if tokens.contains(&\"pummel\")                            { subactions = vec!(\"CatchAttack\") }\n\n    //throws\n    if tokens.contains(&\"up\")      && tokens.contains(&\"throw\") { subactions = vec!(\"ThrowHi\") }\n    if tokens.contains(&\"upthrow\")                              { subactions = vec!(\"ThrowHi\") }\n    if tokens.contains(&\"uthrow\")                               { subactions = vec!(\"ThrowHi\") }\n    if tokens.contains(&\"down\")    && tokens.contains(&\"throw\") { subactions = vec!(\"ThrowLw\") }\n    if tokens.contains(&\"downthrow\")                            { subactions = vec!(\"ThrowLw\") }\n    if tokens.contains(&\"dthrow\")                               { subactions = vec!(\"ThrowLw\") }\n    if tokens.contains(&\"back\")    && tokens.contains(&\"throw\") { subactions = vec!(\"ThrowB\") }\n    if tokens.contains(&\"backthrow\")                            { subactions = vec!(\"ThrowB\") }\n    if tokens.contains(&\"bthrow\")                               { subactions = vec!(\"ThrowB\") }\n    if tokens.contains(&\"forward\") && tokens.contains(&\"throw\") { subactions = vec!(\"ThrowF\") }\n    if tokens.contains(&\"forwardthrow\")                         { subactions = vec!(\"ThrowF\") }\n    if tokens.contains(&\"fthrow\")                               { subactions = vec!(\"ThrowF\") }\n\n    // tilts\n    if tokens.contains(&\"up\")      && tokens.contains(&\"tilt\") { subactions = vec!(\"AttackHi3\") }\n    if tokens.contains(&\"uptilt\")                              { subactions = vec!(\"AttackHi3\") }\n    if tokens.contains(&\"utilt\")                               { subactions = vec!(\"AttackHi3\") }\n    if tokens.contains(&\"down\")    && tokens.contains(&\"tilt\") { subactions = vec!(\"AttackLw3\") }\n    if tokens.contains(&\"downtilt\")                            { subactions = vec!(\"AttackLw3\") }\n    if tokens.contains(&\"dtilt\")                               { subactions = vec!(\"AttackLw3\") }\n    if tokens.contains(&\"forward\") && tokens.contains(&\"tilt\") { subactions = vec!(\"AttackS3S\") }\n    if tokens.contains(&\"forwardtilt\")                         { subactions = vec!(\"AttackS3S\") }\n    if tokens.contains(&\"ftilt\")                               { subactions = vec!(\"AttackS3S\") }\n    if tokens.contains(&\"side\")    && tokens.contains(&\"tilt\") { subactions = vec!(\"AttackS3S\") }\n    if tokens.contains(&\"sidetilt\")                            { subactions = vec!(\"AttackS3S\") }\n    if tokens.contains(&\"stilt\")                               { subactions = vec!(\"AttackS3S\") }\n\n    // ledge getup\n    let ledge = tokens.contains(&\"ledge\") || tokens.contains(&\"edge\") || tokens.contains(&\"cliff\");\n    if ledge && tokens.contains(&\"attack\") && tokens.contains(&\"slow\")  { subactions = vec!(\"CliffAttackSlow\") }\n    if ledge && tokens.contains(&\"attack\") && tokens.contains(&\"quick\") { subactions = vec!(\"CliffAttackQuick\") }\n    if ledge && tokens.contains(&\"roll\")   && tokens.contains(&\"slow\")  { subactions = vec!(\"CliffEscapeSlow\") }\n    if ledge && tokens.contains(&\"roll\")   && tokens.contains(&\"quick\") { subactions = vec!(\"CliffEscapeQuick\") }\n    if ledge && tokens.contains(&\"getup\")  && tokens.contains(&\"slow\")  { subactions = vec!(\"CliffClimbSlow\") }\n    if ledge && tokens.contains(&\"getup\")  && tokens.contains(&\"quick\") { subactions = vec!(\"CliffClimbQuick\") }\n\n    // getup\n    let facedown = tokens.contains(&\"facedown\") || tokens.contains(&\"down\") || tokens.contains(&\"d\");\n    if tokens.contains(&\"getup\") && tokens.contains(&\"attack\")             { subactions = vec!(\"DownAttackU\") }\n    if tokens.contains(&\"getup\") && tokens.contains(&\"attack\") && facedown { subactions = vec!(\"DownAttackD\") }\n    if tokens.contains(&\"getup\") && tokens.contains(&\"stand\")              { subactions = vec!(\"DownStandU\") }\n    if tokens.contains(&\"getup\") && tokens.contains(&\"stand\")  && facedown { subactions = vec!(\"DownStandD\") }\n\n    // trip\n    if tokens.contains(&\"trip\") || tokens.contains(&\"slip\")   { subactions = vec!(\"Slip\") }\n    if tokens.contains(&\"trip\") && tokens.contains(&\"attack\") { subactions = vec!(\"DownAttackU\") }\n    if tokens.contains(&\"trip\") && tokens.contains(&\"stand\")  { subactions = vec!(\"DownStandU\") }\n\n    // escape\n    if tokens.contains(&\"spotdodge\")                                { subactions = vec!(\"EscapeN\") }\n    if tokens.contains(&\"spot\")    && tokens.contains(&\"dodge\")     { subactions = vec!(\"EscapeN\") }\n    if tokens.contains(&\"airdodge\")                                 { subactions = vec!(\"EscapeAir\") }\n    if tokens.contains(&\"air\")     && tokens.contains(&\"dodge\")     { subactions = vec!(\"EscapeAir\") }\n    if tokens.contains(&\"roll\")    && tokens.contains(&\"forward\")   { subactions = vec!(\"EscapeF\") }\n    if tokens.contains(&\"roll\")    && tokens.contains(&\"forwards\")  { subactions = vec!(\"EscapeF\") }\n    if tokens.contains(&\"roll\")    && tokens.contains(&\"backward\")  { subactions = vec!(\"EscapeB\") }\n    if tokens.contains(&\"roll\")    && tokens.contains(&\"backwards\") { subactions = vec!(\"EscapeB\") }\n    if tokens.contains(&\"roll\")    && tokens.contains(&\"back\")      { subactions = vec!(\"EscapeB\") }\n\n    // yeet\n    if tokens.contains(&\"yeet\") && \"Ness\" == character {\n        subactions = vec!(\"ThrowB\");\n    }\n\n    // crawl attack\n    if (tokens.contains(&\"crawl\") && tokens.contains(&\"attack\")) ||\n        (tokens.contains(&\"crawl\") && tokens.contains(&\"tilt\"))  ||\n        tokens.contains(&\"ctilt\") {\n        match character {\n            \"Lucario\"  => subactions = vec!(\"AttackSquat\"),\n            \"Squirtle\" => subactions = vec!(\"AttackSquat\"),\n            \"Snake\"    => subactions = vec!(\"AttackLwShank\"),\n            \"Samus\"    => subactions = vec!(\"SpecialSDash\"),\n            _ => { }\n        }\n    }\n\n    // Smashes\n    if tokens.contains(&\"up\")      && tokens.contains(&\"smash\") { subactions = vec!(\"AttackHi4Start\", \"AttackHi4\") }\n    if tokens.contains(&\"upsmash\")                              { subactions = vec!(\"AttackHi4Start\", \"AttackHi4\") }\n    if tokens.contains(&\"usmash\")                               { subactions = vec!(\"AttackHi4Start\", \"AttackHi4\") }\n    if tokens.contains(&\"down\")    && tokens.contains(&\"smash\") { subactions = vec!(\"AttackLw4Start\", \"AttackLw4\") }\n    if tokens.contains(&\"downsmash\")                            { subactions = vec!(\"AttackLw4Start\", \"AttackLw4\") }\n    if tokens.contains(&\"dsmash\")                               { subactions = vec!(\"AttackLw4Start\", \"AttackLw4\") }\n    if tokens.contains(&\"forward\") && tokens.contains(&\"smash\") { subactions = vec!(\"AttackS4Start\", \"AttackS4S\") }\n    if tokens.contains(&\"forwardsmash\")                         { subactions = vec!(\"AttackS4Start\", \"AttackS4S\") }\n    if tokens.contains(&\"fsmash\")                               { subactions = vec!(\"AttackS4Start\", \"AttackS4S\") }\n    if tokens.contains(&\"side\")    && tokens.contains(&\"smash\") { subactions = vec!(\"AttackS4Start\", \"AttackS4S\") }\n    if tokens.contains(&\"sidesmash\")                            { subactions = vec!(\"AttackS4Start\", \"AttackS4S\") }\n    if tokens.contains(&\"ssmash\")                               { subactions = vec!(\"AttackS4Start\", \"AttackS4S\") }\n\n    // aerials\n    if tokens.contains(&\"up\")      && tokens.contains(&\"air\") { subactions = vec!(\"AttackAirHi\") }\n    if tokens.contains(&\"upair\")                              { subactions = vec!(\"AttackAirHi\") }\n    if tokens.contains(&\"uair\")                               { subactions = vec!(\"AttackAirHi\") }\n    if tokens.contains(&\"down\")    && tokens.contains(&\"air\") { subactions = vec!(\"AttackAirLw\") }\n    if tokens.contains(&\"downair\")                            { subactions = vec!(\"AttackAirLw\") }\n    if tokens.contains(&\"dair\")                               { subactions = vec!(\"AttackAirLw\") }\n    if tokens.contains(&\"forward\") && tokens.contains(&\"air\") { subactions = vec!(\"AttackAirF\") }\n    if tokens.contains(&\"forwardair\")                         { subactions = vec!(\"AttackAirF\") }\n    if tokens.contains(&\"fair\")                               { subactions = vec!(\"AttackAirF\") }\n    if tokens.contains(&\"unfair\")                             { subactions = vec!(\"AttackAirF\") }\n    if tokens.contains(&\"back\")    && tokens.contains(&\"air\") { subactions = vec!(\"AttackAirB\") }\n    if tokens.contains(&\"backair\")                            { subactions = vec!(\"AttackAirB\") }\n    if tokens.contains(&\"bair\")                               { subactions = vec!(\"AttackAirB\") }\n    if tokens.contains(&\"neutral\") && tokens.contains(&\"air\") { subactions = vec!(\"AttackAirN\") }\n    if tokens.contains(&\"neutralair\")                         { subactions = vec!(\"AttackAirN\") }\n    if tokens.contains(&\"nair\")                               { subactions = vec!(\"AttackAirN\") }\n\n    // specials\n    if tokens.contains(&\"u\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialHi\") }\n    if tokens.contains(&\"up\")      && tokens.contains(&\"special\") { subactions = vec!(\"SpecialHi\") }\n    if tokens.contains(&\"up\")      && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialHi\") }\n    if tokens.contains(&\"upspecial\")                              { subactions = vec!(\"SpecialHi\") }\n    if tokens.contains(&\"uspecial\")                               { subactions = vec!(\"SpecialHi\") }\n    if tokens.contains(&\"upb\")                                    { subactions = vec!(\"SpecialHi\") }\n    if tokens.contains(&\"d\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialLw\") }\n    if tokens.contains(&\"down\")    && tokens.contains(&\"special\") { subactions = vec!(\"SpecialLw\") }\n    if tokens.contains(&\"down\")    && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialLw\") }\n    if tokens.contains(&\"downspecial\")                            { subactions = vec!(\"SpecialLw\") }\n    if tokens.contains(&\"dspecial\")                               { subactions = vec!(\"SpecialLw\") }\n    if tokens.contains(&\"downb\")                                  { subactions = vec!(\"SpecialLw\") }\n    if tokens.contains(&\"n\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialN\") }\n    if tokens.contains(&\"neutral\") && tokens.contains(&\"special\") { subactions = vec!(\"SpecialN\") }\n    if tokens.contains(&\"neutral\") && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialN\") }\n    if tokens.contains(&\"neutralspecial\")                         { subactions = vec!(\"SpecialN\") }\n    if tokens.contains(&\"nspecial\")                               { subactions = vec!(\"SpecialN\") }\n    if tokens.contains(&\"neutralb\")                               { subactions = vec!(\"SpecialN\") }\n    if tokens.contains(&\"f\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"forward\") && tokens.contains(&\"special\") { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"forward\") && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"forwardspecial\")                         { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"fspecial\")                               { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"forwardb\")                               { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"s\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"side\")    && tokens.contains(&\"special\") { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"side\")    && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"sidespecial\")                            { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"sspecial\")                               { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"sideb\")                                  { subactions = vec!(\"SpecialS\") }\n\n    // specials air\n    if tokens.contains(&\"air\") && tokens.contains(&\"u\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirHi\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"up\")      && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirHi\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"up\")      && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialAirHi\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"upspecial\")                              { subactions = vec!(\"SpecialAirHi\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"uspecial\")                               { subactions = vec!(\"SpecialAirHi\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"upb\")                                    { subactions = vec!(\"SpecialAirHi\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"d\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirLw\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"down\")    && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirLw\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"down\")    && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialAirLw\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"downspecial\")                            { subactions = vec!(\"SpecialAirLw\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"dspecial\")                               { subactions = vec!(\"SpecialAirLw\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"downb\")                                  { subactions = vec!(\"SpecialAirLw\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"n\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirN\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"neutral\") && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirN\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"neutral\") && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialAirN\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"neutralspecial\")                         { subactions = vec!(\"SpecialAirN\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"nspecial\")                               { subactions = vec!(\"SpecialAirN\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"neutralb\")                               { subactions = vec!(\"SpecialAirN\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"f\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"forward\") && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"forward\") && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"forwardspecial\")                         { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"fspecial\")                               { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"forwardb\")                               { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"s\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"side\")    && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"side\")    && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"sidespecial\")                            { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"sspecial\")                               { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"sideb\")                                  { subactions = vec!(\"SpecialAirS\") }\n\n    // taunts\n    if tokens.contains(&\"utaunt\") { subactions = vec!(\"AppealHiR\") }\n    if tokens.contains(&\"dtaunt\") { subactions = vec!(\"AppealLwR\") }\n    if tokens.contains(&\"staunt\") { subactions = vec!(\"AppealS\") }\n    if tokens.contains(&\"up\")   && tokens.contains(&\"taunt\") { subactions = vec!(\"AppealHi\") }\n    if tokens.contains(&\"down\") && tokens.contains(&\"taunt\") { subactions = vec!(\"AppealLw\") }\n    if tokens.contains(&\"side\") && tokens.contains(&\"taunt\") { subactions = vec!(\"AppealS\") }\n    if tokens.contains(&\"lose\")                              { subactions = vec!(\"Lose\") }\n    if (tokens.contains(&\"1\") && tokens.contains(&\"win\")) || tokens.contains(&\"win1\") { subactions = vec!(\"Win1\") }\n    if (tokens.contains(&\"2\") && tokens.contains(&\"win\")) || tokens.contains(&\"win2\") { subactions = vec!(\"Win2\") }\n    if (tokens.contains(&\"3\") && tokens.contains(&\"win\")) || tokens.contains(&\"win3\") { subactions = vec!(\"Win3\") }\n\n    subactions\n}", "item_id": 0, "repo": "rukai/brawl-frame-data-web", "file": "discord_bot/src/subactions.rs", "last_update_at": "2019-03-05T13:43:39+00:00", "question_id": "b58d5fdb9b9ccd968c297d727f1f4aeeb81a12f9_0", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["pub fn subactions(tokens: &[&str], character: &str) -> Vec<&'static str> {\n    // TODO: This should be made a vector to contain all the subactions related to the action. (multiple jabs, smash attack startup/attack)\n    // TODO: Manually handle character specific stuff such as jabs, glides, etc\n    let mut subactions = vec!();\n    // common movement\n    if tokens.contains(&\"dash\")                              { subactions = vec!(\"Dash\") }\n    if tokens.contains(&\"run\")                               { subactions = vec!(\"Run\") }\n    if tokens.contains(&\"teeter\")                            { subactions = vec!(\"OttottoWait\") }\n    if tokens.contains(&\"crouch\")                            { subactions = vec!(\"SquatWait\") }\n    if tokens.contains(&\"idle\")                              { subactions = vec!(\"Wait1\") }\n    if tokens.contains(&\"jump\") && tokens.contains(&\"squat\") { subactions = vec!(\"JumpSquat\") }\n    if tokens.contains(&\"jumpsquat\")                         { subactions = vec!(\"JumpSquat\") }\n    // jabs\n    if tokens.contains(&\"jab\") { subactions = vec!(\"Attack11\") }\n    // dash attack\n    if tokens.contains(&\"dash\") && tokens.contains(&\"attack\") { subactions = vec!(\"AttackDash\") }\n    if tokens.contains(&\"dashattack\")                         { subactions = vec!(\"AttackDash\") }\n    // grabs\n    if tokens.contains(&\"grab\")                              { subactions = vec!(\"Catch\") }\n    if tokens.contains(&\"dash\")  && tokens.contains(&\"grab\") { subactions = vec!(\"CatchDash\") }\n    if tokens.contains(&\"dashgrab\")                          { subactions = vec!(\"CatchDash\") }\n    if tokens.contains(&\"pivot\") && tokens.contains(&\"grab\") { subactions = vec!(\"CatchTurn\") }\n    if tokens.contains(&\"pivotgrab\")                         { subactions = vec!(\"CatchTurn\") }\n    if tokens.contains(&\"turn\")  && tokens.contains(&\"grab\") { subactions = vec!(\"CatchTurn\") }\n    if tokens.contains(&\"turngrab\")                          { subactions = vec!(\"CatchTurn\") }\n    if tokens.contains(&\"pummel\")                            { subactions = vec!(\"CatchAttack\") }\n    //throws\n    if tokens.contains(&\"up\")      && tokens.contains(&\"throw\") { subactions = vec!(\"ThrowHi\") }\n    if tokens.contains(&\"upthrow\")                              { subactions = vec!(\"ThrowHi\") }\n    if tokens.contains(&\"uthrow\")                               { subactions = vec!(\"ThrowHi\") }\n    if tokens.contains(&\"down\")    && tokens.contains(&\"throw\") { subactions = vec!(\"ThrowLw\") }\n    if tokens.contains(&\"downthrow\")                            { subactions = vec!(\"ThrowLw\") }\n    if tokens.contains(&\"dthrow\")                               { subactions = vec!(\"ThrowLw\") }\n    if tokens.contains(&\"back\")    && tokens.contains(&\"throw\") { subactions = vec!(\"ThrowB\") }\n    if tokens.contains(&\"backthrow\")                            { subactions = vec!(\"ThrowB\") }\n    if tokens.contains(&\"bthrow\")                               { subactions = vec!(\"ThrowB\") }\n    if tokens.contains(&\"forward\") && tokens.contains(&\"throw\") { subactions = vec!(\"ThrowF\") }\n    if tokens.contains(&\"forwardthrow\")                         { subactions = vec!(\"ThrowF\") }\n    if tokens.contains(&\"fthrow\")                               { subactions = vec!(\"ThrowF\") }\n    // tilts\n    if tokens.contains(&\"up\")      && tokens.contains(&\"tilt\") { subactions = vec!(\"AttackHi3\") }\n    if tokens.contains(&\"uptilt\")                              { subactions = vec!(\"AttackHi3\") }\n    if tokens.contains(&\"utilt\")                               { subactions = vec!(\"AttackHi3\") }\n    if tokens.contains(&\"down\")    && tokens.contains(&\"tilt\") { subactions = vec!(\"AttackLw3\") }\n    if tokens.contains(&\"downtilt\")                            { subactions = vec!(\"AttackLw3\") }\n    if tokens.contains(&\"dtilt\")                               { subactions = vec!(\"AttackLw3\") }\n    if tokens.contains(&\"forward\") && tokens.contains(&\"tilt\") { subactions = vec!(\"AttackS3S\") }\n    if tokens.contains(&\"forwardtilt\")                         { subactions = vec!(\"AttackS3S\") }\n    if tokens.contains(&\"ftilt\")                               { subactions = vec!(\"AttackS3S\") }\n    if tokens.contains(&\"side\")    && tokens.contains(&\"tilt\") { subactions = vec!(\"AttackS3S\") }\n    if tokens.contains(&\"sidetilt\")                            { subactions = vec!(\"AttackS3S\") }\n    if tokens.contains(&\"stilt\")                               { subactions = vec!(\"AttackS3S\") }\n    // ledge getup\n    let ledge = tokens.contains(&\"ledge\") || tokens.contains(&\"edge\") || tokens.contains(&\"cliff\");\n    if ledge && tokens.contains(&\"attack\") && tokens.contains(&\"slow\")  { subactions = vec!(\"CliffAttackSlow\") }\n    if ledge && tokens.contains(&\"attack\") && tokens.contains(&\"quick\") { subactions = vec!(\"CliffAttackQuick\") }\n    if ledge && tokens.contains(&\"roll\")   && tokens.contains(&\"slow\")  { subactions = vec!(\"CliffEscapeSlow\") }\n    if ledge && tokens.contains(&\"roll\")   && tokens.contains(&\"quick\") { subactions = vec!(\"CliffEscapeQuick\") }\n    if ledge && tokens.contains(&\"getup\")  && tokens.contains(&\"slow\")  { subactions = vec!(\"CliffClimbSlow\") }\n    if ledge && tokens.contains(&\"getup\")  && tokens.contains(&\"quick\") { subactions = vec!(\"CliffClimbQuick\") }\n    // getup\n    let facedown = tokens.contains(&\"facedown\") || tokens.contains(&\"down\") || tokens.contains(&\"d\");\n    if tokens.contains(&\"getup\") && tokens.contains(&\"attack\")             { subactions = vec!(\"DownAttackU\") }\n    if tokens.contains(&\"getup\") && tokens.contains(&\"attack\") && facedown { subactions = vec!(\"DownAttackD\") }\n    if tokens.contains(&\"getup\") && tokens.contains(&\"stand\")              { subactions = vec!(\"DownStandU\") }\n    if tokens.contains(&\"getup\") && tokens.contains(&\"stand\")  && facedown { subactions = vec!(\"DownStandD\") }\n    // trip\n    if tokens.contains(&\"trip\") || tokens.contains(&\"slip\")   { subactions = vec!(\"Slip\") }\n    if tokens.contains(&\"trip\") && tokens.contains(&\"attack\") { subactions = vec!(\"DownAttackU\") }\n    if tokens.contains(&\"trip\") && tokens.contains(&\"stand\")  { subactions = vec!(\"DownStandU\") }\n    // escape\n    if tokens.contains(&\"spotdodge\")                                { subactions = vec!(\"EscapeN\") }\n    if tokens.contains(&\"spot\")    && tokens.contains(&\"dodge\")     { subactions = vec!(\"EscapeN\") }\n    if tokens.contains(&\"airdodge\")                                 { subactions = vec!(\"EscapeAir\") }\n    if tokens.contains(&\"air\")     && tokens.contains(&\"dodge\")     { subactions = vec!(\"EscapeAir\") }\n    if tokens.contains(&\"roll\")    && tokens.contains(&\"forward\")   { subactions = vec!(\"EscapeF\") }\n    if tokens.contains(&\"roll\")    && tokens.contains(&\"forwards\")  { subactions = vec!(\"EscapeF\") }\n    if tokens.contains(&\"roll\")    && tokens.contains(&\"backward\")  { subactions = vec!(\"EscapeB\") }\n    if tokens.contains(&\"roll\")    && tokens.contains(&\"backwards\") { subactions = vec!(\"EscapeB\") }\n    if tokens.contains(&\"roll\")    && tokens.contains(&\"back\")      { subactions = vec!(\"EscapeB\") }\n    // yeet\n    if tokens.contains(&\"yeet\") && \"Ness\" == character {\n        subactions = vec!(\"ThrowB\");\n    }\n    // crawl attack\n    if (tokens.contains(&\"crawl\") && tokens.contains(&\"attack\")) ||\n        (tokens.contains(&\"crawl\") && tokens.contains(&\"tilt\"))  ||\n        tokens.contains(&\"ctilt\") {\n        match character {\n            \"Lucario\"  => subactions = vec!(\"AttackSquat\"),\n            \"Squirtle\" => subactions = vec!(\"AttackSquat\"),\n            \"Snake\"    => subactions = vec!(\"AttackLwShank\"),\n            \"Samus\"    => subactions = vec!(\"SpecialSDash\"),\n            _ => { }\n        }\n    }\n    // Smashes\n    if tokens.contains(&\"up\")      && tokens.contains(&\"smash\") { subactions = vec!(\"AttackHi4Start\", \"AttackHi4\") }\n    if tokens.contains(&\"upsmash\")                              { subactions = vec!(\"AttackHi4Start\", \"AttackHi4\") }\n    if tokens.contains(&\"usmash\")                               { subactions = vec!(\"AttackHi4Start\", \"AttackHi4\") }\n    if tokens.contains(&\"down\")    && tokens.contains(&\"smash\") { subactions = vec!(\"AttackLw4Start\", \"AttackLw4\") }\n    if tokens.contains(&\"downsmash\")                            { subactions = vec!(\"AttackLw4Start\", \"AttackLw4\") }\n    if tokens.contains(&\"dsmash\")                               { subactions = vec!(\"AttackLw4Start\", \"AttackLw4\") }\n    if tokens.contains(&\"forward\") && tokens.contains(&\"smash\") { subactions = vec!(\"AttackS4Start\", \"AttackS4S\") }\n    if tokens.contains(&\"forwardsmash\")                         { subactions = vec!(\"AttackS4Start\", \"AttackS4S\") }\n    if tokens.contains(&\"fsmash\")                               { subactions = vec!(\"AttackS4Start\", \"AttackS4S\") }\n    if tokens.contains(&\"side\")    && tokens.contains(&\"smash\") { subactions = vec!(\"AttackS4Start\", \"AttackS4S\") }\n    if tokens.contains(&\"sidesmash\")                            { subactions = vec!(\"AttackS4Start\", \"AttackS4S\") }\n    if tokens.contains(&\"ssmash\")                               { subactions = vec!(\"AttackS4Start\", \"AttackS4S\") }\n    // aerials\n    if tokens.contains(&\"up\")      && tokens.contains(&\"air\") { subactions = vec!(\"AttackAirHi\") }\n    if tokens.contains(&\"upair\")                              { subactions = vec!(\"AttackAirHi\") }\n    if tokens.contains(&\"uair\")                               { subactions = vec!(\"AttackAirHi\") }\n    if tokens.contains(&\"down\")    && tokens.contains(&\"air\") { subactions = vec!(\"AttackAirLw\") }\n    if tokens.contains(&\"downair\")                            { subactions = vec!(\"AttackAirLw\") }\n    if tokens.contains(&\"dair\")                               { subactions = vec!(\"AttackAirLw\") }\n    if tokens.contains(&\"forward\") && tokens.contains(&\"air\") { subactions = vec!(\"AttackAirF\") }\n    if tokens.contains(&\"forwardair\")                         { subactions = vec!(\"AttackAirF\") }\n    if tokens.contains(&\"fair\")                               { subactions = vec!(\"AttackAirF\") }\n    if tokens.contains(&\"unfair\")                             { subactions = vec!(\"AttackAirF\") }\n    if tokens.contains(&\"back\")    && tokens.contains(&\"air\") { subactions = vec!(\"AttackAirB\") }\n    if tokens.contains(&\"backair\")                            { subactions = vec!(\"AttackAirB\") }\n    if tokens.contains(&\"bair\")                               { subactions = vec!(\"AttackAirB\") }\n    if tokens.contains(&\"neutral\") && tokens.contains(&\"air\") { subactions = vec!(\"AttackAirN\") }\n    if tokens.contains(&\"neutralair\")                         { subactions = vec!(\"AttackAirN\") }\n    if tokens.contains(&\"nair\")                               { subactions = vec!(\"AttackAirN\") }\n    // specials\n    if tokens.contains(&\"u\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialHi\") }\n    if tokens.contains(&\"up\")      && tokens.contains(&\"special\") { subactions = vec!(\"SpecialHi\") }\n    if tokens.contains(&\"up\")      && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialHi\") }\n    if tokens.contains(&\"upspecial\")                              { subactions = vec!(\"SpecialHi\") }\n    if tokens.contains(&\"uspecial\")                               { subactions = vec!(\"SpecialHi\") }\n    if tokens.contains(&\"upb\")                                    { subactions = vec!(\"SpecialHi\") }\n    if tokens.contains(&\"d\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialLw\") }\n    if tokens.contains(&\"down\")    && tokens.contains(&\"special\") { subactions = vec!(\"SpecialLw\") }\n    if tokens.contains(&\"down\")    && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialLw\") }\n    if tokens.contains(&\"downspecial\")                            { subactions = vec!(\"SpecialLw\") }\n    if tokens.contains(&\"dspecial\")                               { subactions = vec!(\"SpecialLw\") }\n    if tokens.contains(&\"downb\")                                  { subactions = vec!(\"SpecialLw\") }\n    if tokens.contains(&\"n\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialN\") }\n    if tokens.contains(&\"neutral\") && tokens.contains(&\"special\") { subactions = vec!(\"SpecialN\") }\n    if tokens.contains(&\"neutral\") && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialN\") }\n    if tokens.contains(&\"neutralspecial\")                         { subactions = vec!(\"SpecialN\") }\n    if tokens.contains(&\"nspecial\")                               { subactions = vec!(\"SpecialN\") }\n    if tokens.contains(&\"neutralb\")                               { subactions = vec!(\"SpecialN\") }\n    if tokens.contains(&\"f\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"forward\") && tokens.contains(&\"special\") { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"forward\") && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"forwardspecial\")                         { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"fspecial\")                               { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"forwardb\")                               { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"s\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"side\")    && tokens.contains(&\"special\") { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"side\")    && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"sidespecial\")                            { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"sspecial\")                               { subactions = vec!(\"SpecialS\") }\n    if tokens.contains(&\"sideb\")                                  { subactions = vec!(\"SpecialS\") }\n    // specials air\n    if tokens.contains(&\"air\") && tokens.contains(&\"u\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirHi\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"up\")      && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirHi\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"up\")      && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialAirHi\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"upspecial\")                              { subactions = vec!(\"SpecialAirHi\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"uspecial\")                               { subactions = vec!(\"SpecialAirHi\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"upb\")                                    { subactions = vec!(\"SpecialAirHi\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"d\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirLw\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"down\")    && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirLw\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"down\")    && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialAirLw\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"downspecial\")                            { subactions = vec!(\"SpecialAirLw\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"dspecial\")                               { subactions = vec!(\"SpecialAirLw\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"downb\")                                  { subactions = vec!(\"SpecialAirLw\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"n\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirN\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"neutral\") && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirN\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"neutral\") && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialAirN\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"neutralspecial\")                         { subactions = vec!(\"SpecialAirN\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"nspecial\")                               { subactions = vec!(\"SpecialAirN\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"neutralb\")                               { subactions = vec!(\"SpecialAirN\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"f\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"forward\") && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"forward\") && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"forwardspecial\")                         { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"fspecial\")                               { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"forwardb\")                               { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"s\")       && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"side\")    && tokens.contains(&\"special\") { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"side\")    && tokens.contains(&\"b\")       { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"sidespecial\")                            { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"sspecial\")                               { subactions = vec!(\"SpecialAirS\") }\n    if tokens.contains(&\"air\") && tokens.contains(&\"sideb\")                                  { subactions = vec!(\"SpecialAirS\") }\n    // taunts\n    if tokens.contains(&\"utaunt\") { subactions = vec!(\"AppealHiR\") }\n    if tokens.contains(&\"dtaunt\") { subactions = vec!(\"AppealLwR\") }\n    if tokens.contains(&\"staunt\") { subactions = vec!(\"AppealS\") }\n    if tokens.contains(&\"up\")   && tokens.contains(&\"taunt\") { subactions = vec!(\"AppealHi\") }\n    if tokens.contains(&\"down\") && tokens.contains(&\"taunt\") { subactions = vec!(\"AppealLw\") }\n    if tokens.contains(&\"side\") && tokens.contains(&\"taunt\") { subactions = vec!(\"AppealS\") }\n    if tokens.contains(&\"lose\")                              { subactions = vec!(\"Lose\") }\n    if (tokens.contains(&\"1\") && tokens.contains(&\"win\")) || tokens.contains(&\"win1\") { subactions = vec!(\"Win1\") }\n    if (tokens.contains(&\"2\") && tokens.contains(&\"win\")) || tokens.contains(&\"win2\") { subactions = vec!(\"Win2\") }\n    if (tokens.contains(&\"3\") && tokens.contains(&\"win\")) || tokens.contains(&\"win3\") { subactions = vec!(\"Win3\") }\n    subactions\n"]]}
{"hexsha": "fab26e2a226a61ed3ccd6449a05f8250e59f797b", "ext": "rs", "lang": "Rust", "content": "fn test_extract_surveydata() {\n    let str = \"Survey data from wlan0\n    frequency:            2412 MHz\nSurvey data from wlan0\n    frequency:            2417 MHz\nSurvey data from wlan0\n    frequency:            2422 MHz\nSurvey data from wlan0\n    frequency:            2427 MHz\nSurvey data from wlan0\n    frequency:            2432 MHz\nSurvey data from wlan0\n    frequency:            2437 MHz\nSurvey data from wlan0\n    frequency:            2442 MHz\nSurvey data from wlan0\n    frequency:            2447 MHz\nSurvey data from wlan0\n    frequency:            2452 MHz\nSurvey data from wlan0\n    frequency:            2457 MHz\nSurvey data from wlan0\n    frequency:            2462 MHz [in use]\n    noise:                -102 dBm\n    channel active time:        4172127 ms\n    channel busy time:        828107 ms\n    channel receive time:        1448 ms\n    channel transmit time:        20225 ms\nSurvey data from wlan0\n    frequency:            24062 MHz [in use]\n    noise:                -1002 dBm\n    channel active time:        5127 ms\n    channel busy time:        5 ms\n    channel receive time:        5 ms\n    channel transmit time:        5 ms\";\n\n    let ret = extract_wifi_survey_data(str, \"wlan0\");\n\n    println!(\"{:?}\", ret);\n}", "item_id": 4, "repo": "althea-mesh/althea_rs", "file": "althea_types/src/wifi_info.rs", "last_update_at": "2019-06-10T17:42:00+00:00", "question_id": "fab26e2a226a61ed3ccd6449a05f8250e59f797b_4", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_extract_surveydata() {\n    let str = \"Survey data from wlan0\n    frequency:            2412 MHz\nSurvey data from wlan0\n    frequency:            2417 MHz\nSurvey data from wlan0\n    frequency:            2422 MHz\nSurvey data from wlan0\n    frequency:            2427 MHz\nSurvey data from wlan0\n    frequency:            2432 MHz\nSurvey data from wlan0\n    frequency:            2437 MHz\nSurvey data from wlan0\n    frequency:            2442 MHz\nSurvey data from wlan0\n    frequency:            2447 MHz\nSurvey data from wlan0\n    frequency:            2452 MHz\nSurvey data from wlan0\n    frequency:            2457 MHz\nSurvey data from wlan0\n    frequency:            2462 MHz [in use]\n    noise:                -102 dBm\n    channel active time:        4172127 ms\n    channel busy time:        828107 ms\n    channel receive time:        1448 ms\n    channel transmit time:        20225 ms\nSurvey data from wlan0\n    frequency:            24062 MHz [in use]\n    noise:                -1002 dBm\n    channel active time:        5127 ms\n    channel busy time:        5 ms\n    channel receive time:        5 ms\n    channel transmit time:        5 ms\";\n    let ret = extract_wifi_survey_data(str, \"wlan0\");\n    println!(\"{:?}\", ret);\n"]]}
{"hexsha": "c0580b0cfe479ade43d0b13e676989c13f359740", "ext": "rs", "lang": "Rust", "content": "fn test_scan_comments() {\n    let text = r#\"// this is a comment.\na\n// comment with // nested comment.\n// one more.\n// last but not least.\n1\n// ok, that's it.\"#;\n    let cdata = CString::new(text).expect(\"CString::new failed\");\n    let mut s = Scanner::new(cdata);\n    assert_eq!(\n        s.scan(),\n        Token {\n            tok: T_IDENT,\n            lit: String::from(\"a\"),\n            pos: 22,\n        }\n    );\n    assert_eq!(\n        s.scan(),\n        Token {\n            tok: T_INT,\n            lit: String::from(\"1\"),\n            pos: 95,\n        }\n    );\n    assert_eq!(\n        s.scan(),\n        Token {\n            tok: T_EOF,\n            lit: String::from(\"\"),\n            pos: 114,\n        }\n    );\n\n    // with regex\n    let cdata = CString::new(text).expect(\"CString::new failed\");\n    let mut s = Scanner::new(cdata);\n    assert_eq!(\n        s.scan_with_regex(),\n        Token {\n            tok: T_IDENT,\n            lit: String::from(\"a\"),\n            pos: 22,\n        }\n    );\n    assert_eq!(\n        s.scan_with_regex(),\n        Token {\n            tok: T_INT,\n            lit: String::from(\"1\"),\n            pos: 95,\n        }\n    );\n    assert_eq!(\n        s.scan_with_regex(),\n        Token {\n            tok: T_EOF,\n            lit: String::from(\"\"),\n            pos: 114,\n        }\n    );\n}", "item_id": 3, "repo": "davidgs/flux", "file": "internal/rust/scanner/src/tests.rs", "last_update_at": "2019-04-29T06:33:07+00:00", "question_id": "c0580b0cfe479ade43d0b13e676989c13f359740_3", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_scan_comments() {\n    let text = r#\"// this is a comment.\na\n// comment with // nested comment.\n// one more.\n// last but not least.\n1\n// ok, that's it.\"#;\n    let cdata = CString::new(text).expect(\"CString::new failed\");\n    let mut s = Scanner::new(cdata);\n    assert_eq!(\n        s.scan(),\n        Token {\n            tok: T_IDENT,\n            lit: String::from(\"a\"),\n            pos: 22,\n        }\n    );\n    assert_eq!(\n        s.scan(),\n        Token {\n            tok: T_INT,\n            lit: String::from(\"1\"),\n            pos: 95,\n        }\n    );\n    assert_eq!(\n        s.scan(),\n        Token {\n            tok: T_EOF,\n            lit: String::from(\"\"),\n            pos: 114,\n        }\n    );\n    // with regex\n    let cdata = CString::new(text).expect(\"CString::new failed\");\n    let mut s = Scanner::new(cdata);\n    assert_eq!(\n        s.scan_with_regex(),\n        Token {\n            tok: T_IDENT,\n            lit: String::from(\"a\"),\n            pos: 22,\n        }\n    );\n    assert_eq!(\n        s.scan_with_regex(),\n        Token {\n            tok: T_INT,\n            lit: String::from(\"1\"),\n            pos: 95,\n        }\n    );\n    assert_eq!(\n        s.scan_with_regex(),\n        Token {\n            tok: T_EOF,\n            lit: String::from(\"\"),\n            pos: 114,\n        }\n    );\n"]]}
{"hexsha": "8edd37c0ed0f70f332508fdca256a7cc63accd1f", "ext": "rs", "lang": "Rust", "content": "fn test_generate_response() {\n        // Test OK Empty response from VMM.\n        let vmm_resp = Ok(VmmData::Empty);\n        let hyper_resp = vmm_resp.generate_response();\n        assert_eq!(hyper_resp.status(), StatusCode::NoContent);\n        // assert that the body is empty. When the JSON is empty, serde returns and EOF error.\n        let body_err = get_body(hyper_resp).unwrap_err();\n        assert_eq!(\n            body_err.to_string(),\n            \"EOF while parsing a value at line 1 column 0\"\n        );\n\n        // Test OK response from VMM that contains the Machine Configuration.\n        let vmm_resp = Ok(VmmData::MachineConfiguration(VmConfig::default()));\n        let hyper_resp = vmm_resp.generate_response();\n        assert_eq!(hyper_resp.status(), StatusCode::Ok);\n        let vm_config_json = r#\"{\n            \"vcpu_count\": 1,\n            \"mem_size_mib\": 128,\n            \"ht_enabled\": false,\n            \"cpu_template\": \"Uninitialized\"\n        }\"#;\n        let vm_config_json: serde_json::Value = serde_json::from_str(vm_config_json).unwrap();\n        assert_eq!(get_body(hyper_resp).unwrap(), vm_config_json);\n\n        // Tests Error Cases\n        // Tests for BootSource Errors.\n        let vmm_resp =\n            VmmActionError::BootSource(ErrorKind::User, BootSourceConfigError::InvalidKernelPath);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::BootSource(\n            ErrorKind::User,\n            BootSourceConfigError::InvalidKernelCommandLine,\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::BootSource(\n            ErrorKind::User,\n            BootSourceConfigError::UpdateNotAllowedPostBoot,\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n\n        // Tests for DriveConfig Errors.\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::CannotOpenBlockDevice);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::InvalidBlockDeviceID);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::InvalidBlockDevicePath);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::BlockDevicePathAlreadyExists);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::OperationNotAllowedPreBoot);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::RootBlockDeviceAlreadyAdded);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::UpdateNotAllowedPostBoot);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n\n        // Tests for Logger Errors.\n        let vmm_resp = VmmActionError::Logger(\n            ErrorKind::User,\n            LoggerConfigError::InitializationFailure(\n                \"Could not open logging fifo: dummy\".to_string(),\n            ),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n\n        // Tests for MachineConfig Errors.\n        let vmm_resp =\n            VmmActionError::MachineConfig(ErrorKind::User, VmConfigError::InvalidVcpuCount);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::MachineConfig(ErrorKind::User, VmConfigError::InvalidMemorySize);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::MachineConfig(ErrorKind::User, VmConfigError::UpdateNotAllowedPostBoot);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n\n        // Tests for NetworkConfig Errors.\n        let vmm_resp = VmmActionError::NetworkConfig(\n            ErrorKind::User,\n            NetworkInterfaceError::OpenTap(TapError::OpenTun(io::Error::from_raw_os_error(22))),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::NetworkConfig(\n            ErrorKind::User,\n            NetworkInterfaceError::GuestMacAddressInUse(String::from(\"12:34:56:78:9a:bc\")),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::NetworkConfig(\n            ErrorKind::User,\n            NetworkInterfaceError::UpdateNotAllowedPostBoot,\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::NetworkConfig(\n            ErrorKind::User,\n            NetworkInterfaceError::HostDeviceNameInUse(String::from(\"tap_name\")),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n\n        // Tests for MicrovmStart Errors.\n        // RegisterBlockDevice, RegisterNetDevice, and LegacyIOBus cannot be tested because the\n        // device manager is a private module in the vmm crate.\n        // ConfigureVm, Vcpu and VcpuConfigure cannot be tested because vstate is a private module\n        // in the vmm crate.\n        let vmm_resp =\n            VmmActionError::StartMicrovm(ErrorKind::User, StartMicrovmError::MicroVMAlreadyRunning);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::StartMicrovm(ErrorKind::User, StartMicrovmError::MissingKernelConfig);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::GuestMemory(GuestMemoryError::MemoryNotInitialized),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::KernelCmdline(String::from(\"dummy error.\")),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::CreateBlockDevice(io::Error::from_raw_os_error(22)),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::OpenBlockDevice(io::Error::from_raw_os_error(22)),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::NetDeviceNotConfigured,\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::CreateNetDevice(VirtioNetError::TapOpen(TapError::OpenTun(\n                io::Error::from_raw_os_error(22),\n            ))),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::DeviceVmRequest(io::Error::from_raw_os_error(22)),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        #[cfg(target_arch = \"x86_64\")]\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::ConfigureSystem(arch::Error::X86_64Setup(\n                arch::x86_64::Error::ZeroPagePastRamEnd,\n            )),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp =\n            VmmActionError::StartMicrovm(ErrorKind::Internal, StartMicrovmError::EventFd);\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp =\n            VmmActionError::StartMicrovm(ErrorKind::Internal, StartMicrovmError::RegisterEvent);\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::VcpusNotConfigured,\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::VcpuSpawn(std::io::Error::from_raw_os_error(11)),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::BigEndianElfOnLittle),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::LoadCommandline(kernel::loader::Error::CommandLineCopy),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::LoadCommandline(kernel::loader::Error::CommandLineOverflow),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidElfMagicNumber),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidEntryAddress),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidProgramHeaderSize),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidProgramHeaderOffset),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidProgramHeaderAddress),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::ReadElfHeader),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::ReadKernelImage),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::ReadProgramHeader),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::SeekKernelStart),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::SeekElfStart),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::SeekProgramHeader),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n    }", "item_id": 1, "repo": "DavidObando/firecracker", "file": "api_server/src/request/mod.rs", "last_update_at": "2019-03-20T19:27:27+00:00", "question_id": "8edd37c0ed0f70f332508fdca256a7cc63accd1f_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["fn test_generate_response() {\n        // Test OK Empty response from VMM.\n        let vmm_resp = Ok(VmmData::Empty);\n        let hyper_resp = vmm_resp.generate_response();\n        assert_eq!(hyper_resp.status(), StatusCode::NoContent);\n        // assert that the body is empty. When the JSON is empty, serde returns and EOF error.\n        let body_err = get_body(hyper_resp).unwrap_err();\n        assert_eq!(\n            body_err.to_string(),\n            \"EOF while parsing a value at line 1 column 0\"\n        );\n        // Test OK response from VMM that contains the Machine Configuration.\n        let vmm_resp = Ok(VmmData::MachineConfiguration(VmConfig::default()));\n        let hyper_resp = vmm_resp.generate_response();\n        assert_eq!(hyper_resp.status(), StatusCode::Ok);\n        let vm_config_json = r#\"{\n            \"vcpu_count\": 1,\n            \"mem_size_mib\": 128,\n            \"ht_enabled\": false,\n            \"cpu_template\": \"Uninitialized\"\n        }\"#;\n        let vm_config_json: serde_json::Value = serde_json::from_str(vm_config_json).unwrap();\n        assert_eq!(get_body(hyper_resp).unwrap(), vm_config_json);\n        // Tests Error Cases\n        // Tests for BootSource Errors.\n        let vmm_resp =\n            VmmActionError::BootSource(ErrorKind::User, BootSourceConfigError::InvalidKernelPath);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::BootSource(\n            ErrorKind::User,\n            BootSourceConfigError::InvalidKernelCommandLine,\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::BootSource(\n            ErrorKind::User,\n            BootSourceConfigError::UpdateNotAllowedPostBoot,\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        // Tests for DriveConfig Errors.\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::CannotOpenBlockDevice);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::InvalidBlockDeviceID);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::InvalidBlockDevicePath);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::BlockDevicePathAlreadyExists);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::OperationNotAllowedPreBoot);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::RootBlockDeviceAlreadyAdded);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::DriveConfig(ErrorKind::User, DriveError::UpdateNotAllowedPostBoot);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        // Tests for Logger Errors.\n        let vmm_resp = VmmActionError::Logger(\n            ErrorKind::User,\n            LoggerConfigError::InitializationFailure(\n                \"Could not open logging fifo: dummy\".to_string(),\n            ),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        // Tests for MachineConfig Errors.\n        let vmm_resp =\n            VmmActionError::MachineConfig(ErrorKind::User, VmConfigError::InvalidVcpuCount);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::MachineConfig(ErrorKind::User, VmConfigError::InvalidMemorySize);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::MachineConfig(ErrorKind::User, VmConfigError::UpdateNotAllowedPostBoot);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        // Tests for NetworkConfig Errors.\n        let vmm_resp = VmmActionError::NetworkConfig(\n            ErrorKind::User,\n            NetworkInterfaceError::OpenTap(TapError::OpenTun(io::Error::from_raw_os_error(22))),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::NetworkConfig(\n            ErrorKind::User,\n            NetworkInterfaceError::GuestMacAddressInUse(String::from(\"12:34:56:78:9a:bc\")),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::NetworkConfig(\n            ErrorKind::User,\n            NetworkInterfaceError::UpdateNotAllowedPostBoot,\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::NetworkConfig(\n            ErrorKind::User,\n            NetworkInterfaceError::HostDeviceNameInUse(String::from(\"tap_name\")),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        // Tests for MicrovmStart Errors.\n        // RegisterBlockDevice, RegisterNetDevice, and LegacyIOBus cannot be tested because the\n        // device manager is a private module in the vmm crate.\n        // ConfigureVm, Vcpu and VcpuConfigure cannot be tested because vstate is a private module\n        // in the vmm crate.\n        let vmm_resp =\n            VmmActionError::StartMicrovm(ErrorKind::User, StartMicrovmError::MicroVMAlreadyRunning);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp =\n            VmmActionError::StartMicrovm(ErrorKind::User, StartMicrovmError::MissingKernelConfig);\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::GuestMemory(GuestMemoryError::MemoryNotInitialized),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::KernelCmdline(String::from(\"dummy error.\")),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::CreateBlockDevice(io::Error::from_raw_os_error(22)),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::OpenBlockDevice(io::Error::from_raw_os_error(22)),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::NetDeviceNotConfigured,\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::CreateNetDevice(VirtioNetError::TapOpen(TapError::OpenTun(\n                io::Error::from_raw_os_error(22),\n            ))),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::DeviceVmRequest(io::Error::from_raw_os_error(22)),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        #[cfg(target_arch = \"x86_64\")]\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::ConfigureSystem(arch::Error::X86_64Setup(\n                arch::x86_64::Error::ZeroPagePastRamEnd,\n            )),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp =\n            VmmActionError::StartMicrovm(ErrorKind::Internal, StartMicrovmError::EventFd);\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp =\n            VmmActionError::StartMicrovm(ErrorKind::Internal, StartMicrovmError::RegisterEvent);\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::VcpusNotConfigured,\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::Internal,\n            StartMicrovmError::VcpuSpawn(std::io::Error::from_raw_os_error(11)),\n        );\n        check_error_response(vmm_resp, StatusCode::InternalServerError);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::BigEndianElfOnLittle),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::LoadCommandline(kernel::loader::Error::CommandLineCopy),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::LoadCommandline(kernel::loader::Error::CommandLineOverflow),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidElfMagicNumber),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidEntryAddress),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidProgramHeaderSize),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidProgramHeaderOffset),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::InvalidProgramHeaderAddress),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::ReadElfHeader),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::ReadKernelImage),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::ReadProgramHeader),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::SeekKernelStart),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::SeekElfStart),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n        let vmm_resp = VmmActionError::StartMicrovm(\n            ErrorKind::User,\n            StartMicrovmError::KernelLoader(kernel::loader::Error::SeekProgramHeader),\n        );\n        check_error_response(vmm_resp, StatusCode::BadRequest);\n"]]}
{"hexsha": "2020ce2c4691d5730c8c919047a729dcab5da224", "ext": "rs", "lang": "Rust", "content": "async fn happy_path() {\n    let conn_pool = crate::db::ConnectionPool::new();\n    let session = conn_pool.start_session();\n\n    let user = session.create_user(UserBuilder::default().password(\"dummy password\"));\n    let records = session.create_records2(user.id, 1);\n\n    let query = UpdateRecord {\n        amount: BigDecimal::from(10.0),\n        amount_currency: \"CAD\".into(),\n        tags: vec![],\n        transaction_type: \"INC\".into(),\n        user_id: user.id.into(),\n        id: records[0].id,\n        comment: \"\".into(),\n    };\n\n    let res = conn_pool.execute(query).await;\n\n    assert!(res.is_ok(), \"result is not Ok, {:?}\", res);\n    assert_eq!((), res.unwrap());\n}", "item_id": 1, "repo": "saks/hb_api", "file": "octo-budget-api/src/db/queries/update_record/tests.rs", "last_update_at": "2019-04-10T08:59:40+00:00", "question_id": "2020ce2c4691d5730c8c919047a729dcab5da224_1", "category": "coding", "instruct": "Please complete the following code and only return the code.", "turns": [["async fn happy_path() {\n    let conn_pool = crate::db::ConnectionPool::new();\n    let session = conn_pool.start_session();\n    let user = session.create_user(UserBuilder::default().password(\"dummy password\"));\n    let records = session.create_records2(user.id, 1);\n    let query = UpdateRecord {\n        amount: BigDecimal::from(10.0),\n        amount_currency: \"CAD\".into(),\n        tags: vec![],\n        transaction_type: \"INC\".into(),\n        user_id: user.id.into(),\n        id: records[0].id,\n        comment: \"\".into(),\n    };\n    let res = conn_pool.execute(query).await;\n    assert!(res.is_ok(), \"result is not Ok, {:?}\", res);\n    assert_eq!((), res.unwrap());\n"]]}
