--- 0 --
Question ID: aaf02a9921531f8c4ac7d2eb14a1c6c4819a5a17
Original Code:
```
public class DOMSwitchStatement implements Handler {

	final SwitchStatement statement;

	DSubTree tree = new DSubTree();

	ArrayList<List<DASTNode>> bodies = new ArrayList<>();
	ArrayList<Integer> nodeType = new ArrayList<>();

	public DOMSwitchStatement(SwitchStatement statement) {
		this.statement = statement;
	}

	private DSubTree BuildTree(DSubTree Sexpr, int itPos) {
		DSubTree bodyPrev = new DSubTree();
		DSubTree caseNodes = new DSubTree();
        DSubTree bodyNext;
		for (int it1 = itPos; it1 < bodies.size(); it1++) {
			int typePrev = nodeType.get(it1);
			if (typePrev == 49) { // checks for 'case' statement
				bodyNext = BuildTree(Sexpr, it1+1);
				DASTNode caseNode = new DBranch(Sexpr.getNodesAsCalls(), bodyPrev.getNodes(), bodyNext.getNodes());
				caseNodes.addNode(caseNode);
				return caseNodes;
			} else {
				bodyPrev.addNodes(bodies.get(it1));
			}
		}

		return bodyPrev;
	}

	@Override
	public DSubTree handle() {
		DSubTree Sexpr = new DOMExpression(statement.getExpression()).handle();
		boolean branch = Sexpr.isValid();

		for (Object o : statement.statements()) {
			int type = ((Statement) o).getNodeType();
			nodeType.add(type);
			DSubTree body = new DOMStatement((Statement) o).handle();
			bodies.add(body.getNodes());
			if (type != 49) // excludes 'case' statement
				branch |= body.isValid();
		}

		if (branch) {
			DSubTree switchNode = BuildTree(Sexpr, 1);
			tree.addNode(switchNode.getNodes().get(0));
		} else {
			// only one  will add nodes, the rest will add nothing
			tree.addNodes(Sexpr.getNodes());
			for (Iterator<Object> iter = statement.statements().iterator(); iter.hasNext(); ) {
				Object o = iter.next();
				DSubTree body = new DOMStatement((Statement) o).handle();
				tree.addNodes(body.getNodes());
			}
		}

		return tree;
	}
}
```


Overlapping Code:
```
DOMSwitchStatement implements Handler {
final SwitchStatement statement;
DSubTree tree = new DSubTree();
ArrayList<List<DASTNode>> bodies = new ArrayList<>();
ArrayList<Integer> nodeType = new ArrayList<>();
public DOMSwitchStatement(SwitchStatement statement) {
this.statement = statement;
}
private DSubTree BuildTree(DSubTree Sexpr, int itPos) {
DSubTree bodyPrev = new DSubTree();
DSubTree caseNodes = new DSubTree();
DSubTree bodyNext;
for (int it1 = itPos; it1 < bodies.size(); it1++) {
int typePrev = nodeType.get(it1);
if (typePrev == 49) { // checks for 'case' statement
bodyNext = BuildTree(Sexpr, it1+1);
DASTNode caseNode = new DBranch(Sexpr.getNodesAsCalls(), bodyPrev.getNodes(), bodyNext.getNodes());
caseNodes.addNode(caseNode);
return caseNodes;
} else {
bodyPrev.addNodes(bodies.get(it1));
}
}
return bodyPrev;
}
@Override
public DSubTree handle() {
DSubTree Sexpr = new DOMExpression(statement.getExpression()).handle();
boolean branch = Sexpr.isValid();
for (Object o : statement.statements()) {
int type = ((Statement) o).getNodeType();
nodeType.add(type);
DSubTree body = new DOMStatement((Statement) o).handle();
bodies.add(body.getNodes());
if (type != 49) // excludes 'case' statement
branch |= body.isValid();
}
if (branch) {
DSubTree switchNode = BuildTree(Sexpr, 1);
tree.addNode(switchNode.getNodes().get(0));
} else {
// only one will add nodes, the rest will add nothing
tree.addNodes(Sexpr.getNodes());
for (Iterator<Object> iter = statement.statements().iterator(); iter.hasNext(); ) {
Object o = iter.next();
DSubTree body = new DOMStatement((Statement) o).handle();
tree.addNodes(body.getNodes());
```
<Overlap Ratio: 0.9795918367346939>

---

--- 1 --
Question ID: 3dd4af0cd04698dd15fea21bad6838cd7919ec9c
Original Code:
```
public final class XACMLUtils {

  /** XACML rule for combining policies */
  public static final String RULE_COMBINING_ALG = "urn:oasis:names:tc:xacml:1.0:rule-combining-algorithm:permit-overrides";
  /** XACML urn for actions */
  public static final String ACTION_IDENTIFIER = "urn:oasis:names:tc:xacml:1.0:action:action-id";
  /** XACML urn for resources */
  public static final String RESOURCE_IDENTIFIER = "urn:oasis:names:tc:xacml:1.0:resource:resource-id";
  /** XACML urn for subject */
  public static final String SUBJECT_IDENTIFIER = "urn:oasis:names:tc:xacml:1.0:subject:subject-id";
  /** XACML urn for roles */
  public static final String SUBJECT_ROLE_IDENTIFIER = "urn:oasis:names:tc:xacml:2.0:subject:role";
  /** XACML urn for string equality */
  public static final String XACML_STRING_EQUAL = "urn:oasis:names:tc:xacml:1.0:function:string-equal";
  /** XACML urn for string equality */
  public static final String XACML_STRING_IS_IN = "urn:oasis:names:tc:xacml:1.0:function:string-is-in";
  /** W3C String data type */
  public static final String W3C_STRING = "http://www.w3.org/2001/XMLSchema#string";
  /** The policy assertion issuer */
  public static final String ISSUER = "matterhorn";
  /** The JAXB Context to use for marshaling XACML security policy documents */
  protected static JAXBContext jBossXacmlJaxbContext;
  /** The logging facility */
  private static final Logger logger = LoggerFactory.getLogger(XACMLUtils.class);

  /** Static initializer for the single JAXB context */
  static {
    try {
      XACMLUtils.jBossXacmlJaxbContext = JAXBContext.newInstance("org.jboss.security.xacml.core.model.policy",
              PolicyType.class.getClassLoader());
    } catch (JAXBException e) {
      throw new RuntimeException(e);
    }
  }

  /**
   * Private constructor to disable clients from instantiating this class.
   */
  private XACMLUtils() {
  }

  /**
   * Parses a XACML into an {@link AccessControlList}.
   * <p>
   * Only rules which follow the structure of those created by {@link #getXacml(MediaPackage, AccessControlList)} may be
   * successfully parsed. All other rules are ignored.
   * 
   * @param xacml
   *          the XACML to parse
   * @return the ACL, never {@code null}
   * @throws XACMLParsingException
   *           if parsing fails
   */
  public static AccessControlList parseXacml(InputStream xacml) throws XACMLParsingException {

    try {
      @SuppressWarnings("unchecked")
      final AccessControlList acl = new AccessControlList();
      final List<AccessControlEntry> entries = acl.getEntries();
      final PolicyType policy = ((JAXBElement<PolicyType>) XACMLUtils.jBossXacmlJaxbContext.createUnmarshaller().unmarshal(XmlSafeParser.parse(xacml))).getValue();
      for (Object object : policy.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition()) {

        if (!(object instanceof RuleType)) {
          throw new XACMLParsingException("Object " + object + " of policy " + policy + " is not of type RuleType");
        }
        RuleType rule = (RuleType) object;
        if (rule.getTarget() == null) {
          if (rule.getRuleId().equals("DenyRule")) {
            logger.trace("Skipping global deny rule");
            continue;
          }
          throw new XACMLParsingException("Empty rule " + rule + " in policy " + policy);
        }

        String role = null;
        String actionForAce = null;
        try {
          ActionType action = rule.getTarget().getActions().getAction().get(0);
          actionForAce = (String) action.getActionMatch().get(0).getAttributeValue().getContent().get(0);

          @SuppressWarnings("unchecked") JAXBElement<ApplyType> apply = (JAXBElement<ApplyType>) rule.getCondition().getExpression();
          for (JAXBElement<?> element : apply.getValue().getExpression()) {
            if (element.getValue() instanceof AttributeValueType) {
              role = (String) ((AttributeValueType) element.getValue()).getContent().get(0);
              break;
            }
          }
        } catch (Exception e) {
          throw new XACMLParsingException("Rule " + rule + " of policy " + policy + " could not be parsed", e);
        }
        if (role == null) {
          throw new XACMLParsingException("Unable to find role in rule " + rule + " of policy " + policy);
        }
        AccessControlEntry ace = new AccessControlEntry(role, actionForAce, rule.getEffect().equals(EffectType.PERMIT));
        entries.add(ace);
      }
      return acl;
    } catch (Exception e) {
      if (e instanceof XACMLParsingException) {
        throw (XACMLParsingException) e;
      }
      throw new XACMLParsingException("XACML could not be parsed", e);
    }
  }

  /**
   * Builds an xml string containing the xacml for the mediapackage.
   *
   * @param mediapackage
   *          the mediapackage
   * @param accessControlList
   *          the tuples of roles to actions
   * @return
   * @throws JAXBException
   */
  public static String getXacml(MediaPackage mediapackage, AccessControlList accessControlList) throws JAXBException {
    ObjectFactory jbossXacmlObjectFactory = new ObjectFactory();
    PolicyType policy = new PolicyType();
    policy.setPolicyId(mediapackage.getIdentifier().toString());
    policy.setVersion("2.0");
    policy.setRuleCombiningAlgId(XACMLUtils.RULE_COMBINING_ALG);

    // TODO: Add target/resources to rule
    TargetType policyTarget = new TargetType();
    ResourcesType resources = new ResourcesType();
    ResourceType resource = new ResourceType();
    ResourceMatchType resourceMatch = new ResourceMatchType();
    resourceMatch.setMatchId(XACMLUtils.XACML_STRING_EQUAL);
    AttributeValueType resourceAttributeValue = new AttributeValueType();
    resourceAttributeValue.setDataType(XACMLUtils.W3C_STRING);
    resourceAttributeValue.getContent().add(mediapackage.getIdentifier().toString());
    AttributeDesignatorType resourceDesignator = new AttributeDesignatorType();
    resourceDesignator.setAttributeId(XACMLUtils.RESOURCE_IDENTIFIER);
    resourceDesignator.setDataType(XACMLUtils.W3C_STRING);

    // now go back up the tree
    resourceMatch.setResourceAttributeDesignator(resourceDesignator);
    resourceMatch.setAttributeValue(resourceAttributeValue);
    resource.getResourceMatch().add(resourceMatch);
    resources.getResource().add(resource);
    policyTarget.setResources(resources);
    policy.setTarget(policyTarget);

    // Loop over roleActions and add a rule for each
    for (AccessControlEntry ace : accessControlList.getEntries()) {
      boolean allow = ace.isAllow();

      RuleType rule = new RuleType();
      rule.setRuleId(ace.getRole() + "_" + ace.getAction() + (allow ? "_Permit" : "_Deny"));
      if (allow) {
        rule.setEffect(EffectType.PERMIT);
      } else {
        rule.setEffect(EffectType.DENY);
      }

      TargetType target = new TargetType();
      ActionsType actions = new ActionsType();
      ActionType action = new ActionType();
      ActionMatchType actionMatch = new ActionMatchType();
      actionMatch.setMatchId(XACMLUtils.XACML_STRING_EQUAL);
      AttributeValueType attributeValue = new AttributeValueType();
      attributeValue.setDataType(XACMLUtils.W3C_STRING);
      attributeValue.getContent().add(ace.getAction());
      AttributeDesignatorType designator = new AttributeDesignatorType();
      designator.setAttributeId(XACMLUtils.ACTION_IDENTIFIER);
      designator.setDataType(XACMLUtils.W3C_STRING);

      // now go back up the tree
      actionMatch.setActionAttributeDesignator(designator);
      actionMatch.setAttributeValue(attributeValue);
      action.getActionMatch().add(actionMatch);
      actions.getAction().add(action);
      target.setActions(actions);
      rule.setTarget(target);

      ConditionType condition = new ConditionType();
      ApplyType apply = new ApplyType();
      apply.setFunctionId(XACMLUtils.XACML_STRING_IS_IN);

      AttributeValueType conditionAttributeValue = new AttributeValueType();
      conditionAttributeValue.setDataType(XACMLUtils.W3C_STRING);
      conditionAttributeValue.getContent().add(ace.getRole());

      SubjectAttributeDesignatorType subjectDesignator = new SubjectAttributeDesignatorType();
      subjectDesignator.setDataType(XACMLUtils.W3C_STRING);
      subjectDesignator.setAttributeId(XACMLUtils.SUBJECT_ROLE_IDENTIFIER);
      apply.getExpression().add(jbossXacmlObjectFactory.createAttributeValue(conditionAttributeValue));
      apply.getExpression().add(jbossXacmlObjectFactory.createSubjectAttributeDesignator(subjectDesignator));

      condition.setExpression(jbossXacmlObjectFactory.createApply(apply));
      rule.setCondition(condition);
      policy.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition().add(rule);
    }

    // Add the global deny rule
    RuleType deny = new RuleType();
    deny.setEffect(EffectType.DENY);
    deny.setRuleId("DenyRule");
    policy.getCombinerParametersOrRuleCombinerParametersOrVariableDefinition().add(deny);

    // serialize to xml
    StringWriter writer = new StringWriter();
    XACMLUtils.jBossXacmlJaxbContext.createMarshaller().marshal(jbossXacmlObjectFactory.createPolicy(policy), writer);
    return writer.getBuffer().toString();
  }

}
```


Overlapping Code:
```
ACMLUtils {
/** XACML rule for combining policies */
public static final String RULE_COMBINING_ALG = "urn:oasis:names:tc:xacml:1.0:rule-combining-algorithm:permit-overrides";
/** XACML urn for actions */
public static final String ACTION_IDENTIFIER = "urn:oasis:names:tc:xacml:1.0:action:action-id";
/** XACML urn for resources */
public static final String RESOURCE_IDENTIFIER = "urn:oasis:names:tc:xacml:1.0:resource:resource-id";
/** XACML urn for subject */
public static final String SUBJECT_IDENTIFIER = "urn:oasis:names:tc:xacml:1.0:subject:subject-id";
/** XACML urn for roles */
public static final String SUBJECT_ROLE_IDENTIFIER = "urn:oasis:names:tc:xacml:2.0:subject:role";
/** XACML urn for string equality */
public static final String XACML_STRING_EQUAL = "urn:oasis:names:tc:xacml:1.0:function:string-equal";
/** XACML urn for string equality */
public static final String XACML_STRING_IS_IN = "urn:oasis:names:tc:xacml:1.0:function:string-is-in";
/** W3C String data type */
public static final String W3C_STRING = "http://www.w3.org/2001/XMLSchema#string";
/** The policy assertion issuer */
public static final String ISSUER = "matterhorn";
/** The JAXB Context to use for marshaling XACML security policy documents */
protected static JAXBContext jBossXacmlJaxbContext;
/** The logging facility */
private static final Logger logger = LoggerFactory.getLogger(XACMLUtils.class);
/** Static initializer for the single JAXB context */
static {
try {
XACMLUtils.jBossXacmlJaxbContext = JAXBContext.newInstance("org.jboss.security.xacml.core.model.policy",
PolicyType.class.getClassLoader());
} catch (JAXBException e) {
throw new RuntimeException(e);
}
}
/**
* Private constructor to disable clients from instantiating this class.
*/
private XACMLUtils() {
}
/**
* Parses a XACML into an {@link AccessControlList}.
* <p>
* Only rules which follow the structure of those created by {@link #getXacml(MediaPackage, AccessControlList)} may be
* successfully parsed. All other rules are ignored.
* 
* @param xacml
* the XACML to parse
* @return the ACL, never {@code null}
* @throws XACMLParsingException
* if parsing fails
*/
public static AccessControlList parseXacml(InputStream xacml) throws XACMLParsingException {
try {
@SuppressWarnings("unchecked")
final AccessControlList acl = ne
```
<Overlap Ratio: 0.990952175786299>

---

--- 2 --
Question ID: 05a56089dd1acc0703a839d688437da96a0423c8
Original Code:
```
public class TramiteDto implements Serializable {

    private static final long serialVersionUID = 1L;

    private String codTramite;

    private String nomRemitente;

    private String nomDestinatario;

    private String desComentario;

    private String desAsunto;

    private String codEstado;

    private String nomEstado;
    
    private Date fecRegistro;

    private String numDocumento;

    private List<TramiteDocumentoDto> documentosAdjuntos;

    private DocumentoAdjuntoDto documentoAdjunto;

    public TramiteDto() {

        documentosAdjuntos = new ArrayList<>();
        documentoAdjunto=new DocumentoAdjuntoDto();
    }

    public TramiteDto(String codTramite, String nomRemitente, String nomDestinatario, String desComentario, String desAsunto, String codEstado, Date fecRegistro, List<TramiteDocumentoDto> documentosAdjuntos,String nomEstado) {
        this.codTramite = codTramite;
        this.nomRemitente = nomRemitente;
        this.nomDestinatario = nomDestinatario;
        this.desComentario = desComentario;
        this.desAsunto = desAsunto;
        this.codEstado = codEstado;
        this.fecRegistro = fecRegistro;
        this.documentosAdjuntos = documentosAdjuntos;
        this.nomEstado=nomEstado;
    }
    
    
    
    

    public String getCodTramite() {
        return codTramite;
    }

    public void setCodTramite(String codTramite) {
        this.codTramite = codTramite;
    }

    public String getNomRemitente() {
        return nomRemitente;
    }

    public void setNomRemitente(String nomRemitente) {
        this.nomRemitente = nomRemitente;
    }

    public String getNomDestinatario() {
        return nomDestinatario;
    }

    public void setNomDestinatario(String nomDestinatario) {
        this.nomDestinatario = nomDestinatario;
    }

    public String getDesComentario() {
        return desComentario;
    }

    public void setDesComentario(String desComentario) {
        this.desComentario = desComentario;
    }

    public String getDesAsunto() {
        return desAsunto;
    }

    public void setDesAsunto(String desAsunto) {
        this.desAsunto = desAsunto;
    }

    public String getCodEstado() {
        return codEstado;
    }

    public void setCodEstado(String codEstado) {
        this.codEstado = codEstado;
    }

    public Date getFecRegistro() {
        return fecRegistro;
    }

    public void setFecRegistro(Date fecRegistro) {
        this.fecRegistro = fecRegistro;
    }

    public String getNumDocumento() {
        return numDocumento;
    }

    public void setNumDocumento(String numDocumento) {
        this.numDocumento = numDocumento;
    }

  
    public List<TramiteDocumentoDto> getDocumentosAdjuntos() {
        return documentosAdjuntos;
    }

    public void setDocumentosAdjuntos(List<TramiteDocumentoDto> documentosAdjuntos) {
        this.documentosAdjuntos = documentosAdjuntos;
    }

    public DocumentoAdjuntoDto getDocumentoAdjunto() {
        return documentoAdjunto;
    }

    public void setDocumentoAdjunto(DocumentoAdjuntoDto documentoAdjunto) {
        this.documentoAdjunto = documentoAdjunto;
    }

    public String getNomEstado() {
        return nomEstado;
    }

    public void setNomEstado(String nomEstado) {
        this.nomEstado = nomEstado;
    }
    
    
    
    

    @Override
    public int hashCode() {
        int hash = 7;
        hash = 53 * hash + Objects.hashCode(this.codTramite);
        hash = 53 * hash + Objects.hashCode(this.nomRemitente);
        hash = 53 * hash + Objects.hashCode(this.nomDestinatario);
        hash = 53 * hash + Objects.hashCode(this.desComentario);
        hash = 53 * hash + Objects.hashCode(this.desAsunto);
        hash = 53 * hash + Objects.hashCode(this.codEstado);
        hash = 53 * hash + Objects.hashCode(this.fecRegistro);
        hash = 53 * hash + Objects.hashCode(this.numDocumento);
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final TramiteDto other = (TramiteDto) obj;
        if (!Objects.equals(this.codTramite, other.codTramite)) {
            return false;
        }
        if (!Objects.equals(this.nomRemitente, other.nomRemitente)) {
            return false;
        }
        if (!Objects.equals(this.nomDestinatario, other.nomDestinatario)) {
            return false;
        }
        if (!Objects.equals(this.desComentario, other.desComentario)) {
            return false;
        }
        if (!Objects.equals(this.desAsunto, other.desAsunto)) {
            return false;
        }
        if (!Objects.equals(this.codEstado, other.codEstado)) {
            return false;
        }
        if (!Objects.equals(this.numDocumento, other.numDocumento)) {
            return false;
        }
        if (!Objects.equals(this.fecRegistro, other.fecRegistro)) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return "TramiteDto{" + "codTramite=" + codTramite + ", nomRemitente=" + nomRemitente + ", nomDestinatario=" + nomDestinatario + ", desComentario=" + desComentario + ", desAsunto=" + desAsunto + ", codEstado=" + codEstado + ", fecRegistro=" + fecRegistro + ", numDocumento=" + numDocumento + '}';
    }

}
```


Overlapping Code:
```
ramiteDto implements Serializable {
private static final long serialVersionUID = 1L;
private String codTramite;
private String nomRemitente;
private String nomDestinatario;
private String desComentario;
private String desAsunto;
private String codEstado;
private String nomEstado;

private Date fecRegistro;
private String numDocumento;
private List<TramiteDocumentoDto> documentosAdjuntos;
private DocumentoAdjuntoDto documentoAdjunto;
public TramiteDto() {
documentosAdjuntos = new ArrayList<>();
documentoAdjunto=new DocumentoAdjuntoDto();
}
public TramiteDto(String codTramite, String nomRemitente, String nomDestinatario, String desComentario, String desAsunto, String codEstado, Date fecRegistro, List<TramiteDocumentoDto> documentosAdjuntos,String nomEstado) {
this.codTramite = codTramite;
this.nomRemitente = nomRemitente;
this.nomDestinatario = nomDestinatario;
this.desComentario = desComentario;
this.desAsunto = desAsunto;
this.codEstado = codEstado;
this.fecRegistro = fecRegistro;
this.documentosAdjuntos = documentosAdjuntos;
this.nomEstado=nomEstado;
}




public String getCodTramite() {
return codTramite;
}
public void setCodTramite(String codTramite) {
this.codTramite = codTramite;
}
public String getNomRemitente() {
return nomRemitente;
}
public void setNomRemitente(String nomRemitente) {
this.nomRemitente = nomRemitente;
}
public String getNomDestinatario() {
return nomDestinatario;
}
public void setNomDestinatario(String nomDestinatario) {
this.nomDestinatario = nomDestinatario;
}
public String getDesComentario() {
return desComentario;
}
public void setDesComentario(String desComentario) {
this.desComentario = desComentario;
}
public String getDesAsunto() {
return desAsunto;
}
public void setDesAsunto(String desAsunto) {
this.desAsunto = desAsunto;
}
public String getCodEstado() {
return codEstado;
}
public void setCodEstado(String codEstado) {
this.codEstado = codEstado;
}
public Date getFecRegistro() {
return fecRegistro;
}
public void setFecRegistro(Date fecRegistro) {
this.fecRegistro = fecRegistro;
}

```
<Overlap Ratio: 0.9893719806763285>

---

--- 3 --
Question ID: f146e4e2f17a0639275f5c81007d7a73c2cfa651
Original Code:
```
public class Scope {
    private final ConcurrentHashMap<String, Symbol> locallyDefined = new ConcurrentHashMap<>();
    private Scope parentScope;
    
    public Optional<Scope> getParentScope() { return Optional.ofNullable(parentScope); }
    
    public Scope createNewChildScope() {
        Scope child = new Scope();
        child.parentScope = this;
        return child;
    }
    
    public Optional<Symbol> getForName(String name) {
        return Optional.ofNullable(locallyDefined.getOrDefault(name,
                getParentScope().map(scope -> scope.getForName(name).orElse(Symbol.getForName(name))).orElse(null)));
    }
    
    public java.util.Set<String> getAllSymbolNames() {
        return Collections.unmodifiableSet(locallyDefined.keySet());
    }
    
    public java.util.Set<Symbol> getAllSymbols() {
        return new HashSet<>(locallyDefined.values());
    }
    
    public Symbol getOrCreate(String name, String representation) {
        return locallyDefined.getOrDefault(name, new Symbol(name, representation, this));
    }
    
    public Optional<Symbol> unbind(String name) {
        return Optional.ofNullable(locallyDefined.remove(name));
    }
    
    public void rebind(Symbol binding) {
        Symbol previous = locallyDefined.put(binding.getName(), binding);
        if (previous == null) {
            Logger.getLogger(Scope.class.getName()).log(Level.WARNING,
                    "Symbol {} was rebound, but had no previous binding", binding.getName());
        } else {
            if (!previous.getRepresentation().equals(binding.getRepresentation())) {
                Logger.getLogger(Scope.class.getName()).log(Level.SEVERE,
                        "Symbol {} rebound with new representation; old = {}, current = {}",
                        new Object[] { binding.getName(), previous.getRepresentation(), binding.getRepresentation() });
            }
        }
    }

    public void cacheValue(String name, Numeric value) {
        checkIfAlreadyCached(name);
        Symbol symbol = new Symbol(name, name, this);
        symbol.setConcreteValue(value);
        locallyDefined.put(name, symbol);
    }

    private void checkIfAlreadyCached(String name) throws IllegalStateException {
        if (locallyDefined.containsKey(name)) {
            throw new IllegalStateException("Cache already contains entry for "
                    + name + " with value " + locallyDefined.get(name).getConcreteValue());
        }
    }
    
    public void cacheValue(String name, String representation, Numeric value) {
        checkIfAlreadyCached(name);
        Symbol symbol = new Symbol(name, representation, value, this);
        locallyDefined.put(name, symbol);
    }
    
    /**
     * Cache a {@link Symbol} explicitly. If the symbol has already been
     * associated with a different scope, the operation will fail without
     * throwing an exception.
     * 
     * @param symbol the symbol to cache
     * @return true if successful, false otherwise
     */
    public boolean cacheSymbol(Symbol symbol) {
        checkIfAlreadyCached(symbol.getName());
        if (!symbol.getScope().isPresent()) {
            symbol.updateScope(this);
            locallyDefined.put(symbol.getName(), symbol);
            return true;
        } else {
            return false;
        }
    }
    
    public Optional<? extends Numeric> updateValue(Symbol symbol, Numeric newValue) {
        final String name = symbol.getName();
        if (!locallyDefined.containsKey(name)) {
            Logger.getLogger(Scope.class.getName()).log(Level.INFO,
                    "Symbol {} is being redefined in this scope from an ancestor scope.", name);
            if (Symbol.getForName(name) != null &&
                    Symbol.getForName(name).getValueClass()
                            .map(clazz -> clazz.isAnnotationPresent(Constant.class)).orElse(false)) {
                throw new IllegalArgumentException("Cannot redefine a constant value in any scope.");
            }
        }
        
        Symbol old = locallyDefined.getOrDefault(name,
                getParentScope().flatMap((scope) -> scope.getForName(name)).orElse(symbol));
        final Optional<? extends Numeric> oldValue = old.getConcreteValue();
        oldValue.ifPresent(value -> {
            if (value.equals(newValue)) {
                Logger.getLogger(Scope.class.getName()).log(Level.INFO,
                        "Symbol {} is being updated in this scope, but the value {} appears to be unchanged.",
                        new Object[] { name, value });
            }
        });
        symbol.setConcreteValue(newValue);
        locallyDefined.put(name, symbol);
        return oldValue;
    }
    
    /**
     * Update the concrete value bound to a symbol. This method returns
     * the previously bound value.  Note that if the symbol was bound in a
     * parent {@link Scope}, this operation will rebind the symbol in the
     * current {@link Scope}, thus masking the binding in the parent scope.
     * 
     * @param name the unique name of the symbol to be rebound
     * @param newValue the new value to bind to the named symbol
     * @return the previously bound value of the named symbol
     */
    public Optional<? extends Numeric> updateValue(String name, Numeric newValue) {
        Optional<Symbol> old = getForName(name);
        if (old.isPresent()) {
            Symbol fresh = locallyDefined.containsKey(name) ? old.get() : new Symbol(name, old.get().getRepresentation(), this);
            Optional<? extends Numeric> oldValue = old.get().getConcreteValue();
            fresh.setConcreteValue(newValue);
            locallyDefined.put(name, fresh);
            return oldValue;
        } else {
            throw new IllegalArgumentException("Symbol " + name + " does not exist!");
        }
    }
}
```


Overlapping Code:
```
e {
private final ConcurrentHashMap<String, Symbol> locallyDefined = new ConcurrentHashMap<>();
private Scope parentScope;

public Optional<Scope> getParentScope() { return Optional.ofNullable(parentScope); }

public Scope createNewChildScope() {
Scope child = new Scope();
child.parentScope = this;
return child;
}

public Optional<Symbol> getForName(String name) {
return Optional.ofNullable(locallyDefined.getOrDefault(name,
getParentScope().map(scope -> scope.getForName(name).orElse(Symbol.getForName(name))).orElse(null)));
}

public java.util.Set<String> getAllSymbolNames() {
return Collections.unmodifiableSet(locallyDefined.keySet());
}

public java.util.Set<Symbol> getAllSymbols() {
return new HashSet<>(locallyDefined.values());
}

public Symbol getOrCreate(String name, String representation) {
return locallyDefined.getOrDefault(name, new Symbol(name, representation, this));
}

public Optional<Symbol> unbind(String name) {
return Optional.ofNullable(locallyDefined.remove(name));
}

public void rebind(Symbol binding) {
Symbol previous = locallyDefined.put(binding.getName(), binding);
if (previous == null) {
Logger.getLogger(Scope.class.getName()).log(Level.WARNING,
"Symbol {} was rebound, but had no previous binding", binding.getName());
} else {
if (!previous.getRepresentation().equals(binding.getRepresentation())) {
Logger.getLogger(Scope.class.getName()).log(Level.SEVERE,
"Symbol {} rebound with new representation; old = {}, current = {}",
new Object[] { binding.getName(), previous.getRepresentation(), binding.getRepresentation() });
}
}
}
public void cacheValue(String name, Numeric value) {
checkIfAlreadyCached(name);
Symbol symbol = new Symbol(name, name, this);
symbol.setConcreteValue(value);
locallyDefined.put(name, symbol);
}
private void checkIfAlreadyCached(String name) throws IllegalStateException {
if (locallyDefined.containsKey(name)) {
throw new IllegalStateException("Cache already contains entry for "
+ name + " with value " + locallyDefined.get(nam
```
<Overlap Ratio: 0.9881422924901185>

---

--- 4 --
Question ID: 3fc11ba4baa216b5230960773ff3e9fd9138895f
Original Code:
```
public class UserRoleTest
{

    private EntityManagerFactory emf;

    /** The em. */
    private EntityManager em;

    /**
     * Sets the up.
     */
    @Before
    public void setUp()
    {
        emf = Persistence.createEntityManagerFactory("mongoTest");
        em = emf.createEntityManager();
    }

    /**
     * Test association.
     */
    @Test
    public void testPersist()
    {
        RoleMongo rol = new RoleMongo();
        rol.setRolId(1);
        rol.setName("Administrador");
        User u = new User();
        u.setAge(15);
        u.setEmail("usuario1@infos.com");
        u.setName("usuario1");
        u.setUserId(1);
        u.setLastName("apellido1");
        User u2 = new User();
        u2.setAge(17);
        u2.setEmail("usuario2@infos.com");
        u2.setName("usuario2");
        u2.setUserId(2);
        u2.setLastName("apellido2");
        u.setUserRol(rol);
        u2.setUserRol(rol);
        List<User> users = new ArrayList<User>();
        users.add(u);
        users.add(u2);
        rol.setSegUsuarioList(users);
        em.persist(rol);

    }

    /**
     * Test findby role.
     */
    @Test
    public void testFindbyRole()
    {
        testPersist();
        String query = "Select r from RoleMongo r";
        Query q = em.createQuery(query);
        List<RoleMongo> roles = q.getResultList();
        Assert.assertNotNull(roles);
        Assert.assertEquals(1, roles.size());
    }

    /**
     * Test findby user.
     */
    @Test
    public void testFindbyUser()
    {
        testPersist();
        List<User> users = getAllUsers();
        Assert.assertNotNull(users);
        Assert.assertEquals(2, users.size());
    }

    /**
     * Tear down.
     */
    @After
    public void tearDown()
    {
        RoleMongo rol = em.find(RoleMongo.class, 1);
        if (rol != null)
        {
            em.remove(rol);
        }

        MongoUtils.dropDatabase(emf, "mongoTest");
        em.close();

        em = null;
        emf.close();
    }

    /**
     * @return
     */
    private List<User> getAllUsers()
    {
        String query = "Select u from User u";
        Query q = em.createQuery(query);
        List<User> users = q.getResultList();
        return users;
    }
}
```


Overlapping Code:
```

private EntityManagerFactory emf;
/** The em. */
private EntityManager em;
/**
* Sets the up.
*/
@Before
public void setUp()
{
emf = Persistence.createEntityManagerFactory("mongoTest");
em = emf.createEntityManager();
}
/**
* Test association.
*/
@Test
public void testPersist()
{
RoleMongo rol = new RoleMongo();
rol.setRolId(1);
rol.setName("Administrador");
User");
u.setName("usuario1");
u.setUserId(1);
u.setLastName("apellido1");
User u2 = new User();
u2.setAo2");
u2.setUserId(2);
u2.setLastName("apellido2");
u.setUserRol(rol);
u2.setUserRol(rol);
List<User> users = new ArrayList<User>();
users.add(u);
users.add(u2);
rol.setSegUsuarioList(users);
em.persist(rol);
}
/**
* Test findby role.
*/
@Test
public void testFindbyRole()
{
testPersist();
String query = "Select r from RoleMongo r";
Query q = em.createQuery(query);
List<RoleMongo> roles = q.getResultList();
Assert.assertNotNull(roles);
Assert.assertEquals(1, roles.size());
}
/**
* Test findby user.
*/
@Test
public void testFindbyUser()
{
testPersist();
List<User> users = getAllUsers();
Assert.assertNotNull(users);
Assert.assertEquals(2, users.size());
}
/**
* Tear down.
*/
@After
public void tearDown()
{
RoleMongo rol = em.find(RoleMongo.class, 1);
if (rol != null)
{
em.remove(rol);
}
MongoUtils.dropDatabase(emf, "mongoTest");
em.close();
em = null;
emf.close();
}
/**
* @return
*/
private List<User> getAllUsers()
{
String query = "Select u from User u";
Query q = em.createQuery(query);
List<User> users = q.getResultList();
return users
```
<Overlap Ratio: 0.9077844311377246>

---

--- 5 --
Question ID: 5568d8218206ecb2d0de57706117512a3224fd47
Original Code:
```
public class SonarWayProfileTest {
    private IMocksControl mocksControl;
    private XMLProfileParser parser;
    private RuleFinder ruleFinder;
    private SonarWayProfile profile;
    private ValidationMessages messages;

    @Before
    public void setup() {
        mocksControl = EasyMock.createControl();
        ruleFinder = mocksControl.createMock(RuleFinder.class);
        parser = new XMLProfileParser(ruleFinder);
        messages = ValidationMessages.create();

        profile = new SonarWayProfile(parser);
    }

    @Test
    public void testConstructor() {
        assertNotNull(profile);
    }

    @Test
    public void testCreateProfile() {
//       RulesProfile rulesProfile = profile.createProfile(messages);
//       assertNotNull(rulesProfile);
//       assertEquals("Sonar Way", rulesProfile.getName());
//       assertEquals("ruby", rulesProfile.getLanguage());
    }

}
```


Overlapping Code:
```
s SonarWayProfileTest {
private IMocksControl mocksControl;
private XMLProfileParser parser;
private RuleFinder ruleFinder;
private SonarWayProfile profile;
private ValidationMessages messages;
@Before
public void setup() {
mocksControl = EasyMock.createControl();
ruleFinder = mocksControl.createMock(RuleFinder.class);
parser = new XMLProfileParser(ruleFinder);
messages = ValidationMessages.create();
profile = new SonarWayProfile(parser);
}
@Test
public void testConstructor() {
assertNotNull(profile);
}
@Test
public void testCreateProfile() {
// RulesProfile rulesProfile = profile.createProfile(messages);
// assertNotNull(rulesProfile);
// assertEquals("Sonar Way", rulesProfile.getName());
// assertEquals("ruby", rulesProfile.getLanguage())
```
<Overlap Ratio: 0.97911227154047>

---

--- 6 --
Question ID: 9486a1f28603d9667ed026c3ca86f2c57691eabb
Original Code:
```
public class TestObservationFilter {
	private HDF5Dataset ds;
	private static TestData td;
	private ObservationFilter filter;

	@BeforeClass
	public static void setUpClass() throws IOException {
		td = new TestData();
	}

	@AfterClass
	public static void tearDownClass() {
		td.dispose();
	}

	@Before
	public void setUp() {
		ds = new HDF5Dataset(td.getPath());
		filter = new ObservationFilter(ds, "http://fake/");
	}

	@After
	public void tearDown() {
		ds.dispose();
	}

	private void checkObservation(Observation obs)
			throws CloneNotSupportedException {
		// observation -> URL -> meta is just a fast way of getting an
		// observationMeta
		String obsURL = URLScheme.observationURL(obs);
		ObservationMeta meta = URLScheme.parseObservationURL(obsURL);
		Observation shouldMatch = ObservationFilter.retrieveFromMeta(meta, ds, "http://fake/");
		assertNotNull(shouldMatch);
		assertTrue(obs.equals(shouldMatch));

		// Try retrieving some junk, just because we can
		ObservationMeta brokenCellMeta = meta.clone();
		brokenCellMeta.cell = brokenCellMeta.cell + "AKSJD";
		assertNull(ObservationFilter.retrieveFromMeta(brokenCellMeta, ds, "http://fake/"));

		ObservationMeta brokenLevelMeta = meta.clone();
		brokenLevelMeta.levelPixel = -1;
		assertNull(ObservationFilter.retrieveFromMeta(brokenLevelMeta, ds, "http://fake/"));
	}

	@Test
	public void testGetFromMeta() throws CloneNotSupportedException {
		Cell cell = ds.dggsCell("R7852");
		ZonedDateTime timestamp = ZonedDateTime.parse("2013-05-27T23:58:20Z");
		Product product = new Product(ds, "LS8_OLI_TIRS_NBAR");
		checkObservation(cell.pixelObservation(product, timestamp, 4));
		checkObservation(cell.tileObservation(product, timestamp, 3));
	}

	private void checkTypeFilterCount(int expected, Resource val) {
		filter = new ObservationFilter(ds, "http://fake/");
		ObservationProperty typeFilter = PropertyIndex
				.getProperty(RDF.type.getURI()).get();
		typeFilter.applyToFilter(filter, val.asNode());
		assertEquals(expected, filter.execute().count());
	}

	@Test
	public void testFilterByType() {
		// First, count the number of observations (no filtering)
		assertEquals(84, filter.execute().count());
		checkTypeFilterCount(0, LED.time);
		checkTypeFilterCount(84, QB.Observation);
		checkTypeFilterCount(42, LED.Pixel);
		checkTypeFilterCount(42, LED.GridSquare);
	}

	@Test
	public void testIncompatibleType() {
		filter.constrainToPixel().constrainToPixel();
		assertEquals(84 / 2, filter.execute().count());
		filter.constrainToTile();
		assertEquals(0, filter.execute().count());
	}

	@Test
	public void testIncompatibleLevel() {
		filter.constrainLevel(3).constrainLevel(3);
		assertEquals(14, filter.execute().count());
		filter.constrainLevel(5);
		assertEquals(0, filter.execute().count());
	}

	@Test
	public void testIncompatibleBand() {
		// double-specification of bands is fine iff it's the same band
		filter.constrainBandNum(3).constrainBandNum(3);
		assertEquals(84 / 7, filter.execute().count());
		filter.constrainBandNum(4);
		assertEquals(0, filter.execute().count());
	}

	@Test
	public void testIncompatibleCellID() {
		filter.constrainCellID("R78").constrainCellID("R78")
				.constrainCellID("R91");
		assertEquals(0, filter.execute().count());
	}

	@Test
	public void testConstrainLocation() {
		filter.constrainLatMin(-35.45).constrainLatMax(-35)
				.constrainLonMin(148.8).constrainLonMax(149.3)
				.constrainProperty(RDF.type.getURI(), LED.GridSquare.asNode())
				.constrainProperty(LED.etmBand.getURI(), createLiteralNode(0));
		List<String> cellIDs = filter.execute()
				.map(obs -> obs.getCell().getDGGSIdent())
				.collect(Collectors.toList());
		assertEquals(1, cellIDs.size());
		assertEquals("R78523", cellIDs.get(0));
	}

	@Test
	public void testNonexistentProperty() {
		filter.constrainProperty("http://example.com/doesntExist",
				createLiteralNode(42));
		assertEquals(0, filter.execute().count());
	}

	@Test
	public void testConstrainNaively() {
		// there are some thing that we can't really constrain by in an efficent
		// way
		filter.constrainNaively(PropertyIndex.getProperty(LED.etmBand).get(),
				createLiteralNode(3));
		List<Observation> allObs = filter.execute()
				.collect(Collectors.toList());
		// there are 84 observations total in the test set, and 7 bands, so we
		// should get back 1/7th of the observations
		assertEquals(84 / 7, allObs.size());
		for (Observation obs : allObs) {
			assertEquals(3, obs.getBand());
		}
	}

	@Test
	public void testIndirectNaiveConstraint() {
		// we can only really filter values naively, since we don't have an
		// inverted index for them
		filter.constrainProperty(LED.value.getURI(),
				createLiteralNode(new Double(931.0)));
		List<Observation> allObs = filter.execute()
				.collect(Collectors.toList());
		assertEquals(1, allObs.size());
		for (Observation obs : allObs) {
			assertTrue(obs instanceof PixelObservation);
			assertEquals(931.0, ((PixelObservation) obs).getPixel(), 0.001);
		}
	}

	@Test
	public void testFilterByDGGSSquare() {
		filter.constrainProperty(LED.dggsCell.getURI(),
				createLiteralNode("R7852"));
		List<Observation> allObs = filter.execute()
				.collect(Collectors.toList());
		assertEquals(14, allObs.size());
		for (Observation obs : allObs) {
			assertEquals("R7852", obs.getCell().getDGGSIdent());
		}

		// compatible constrain doesn't change anything
		filter.constrainProperty(LED.dggsCell.getURI(),
				createLiteralNode("R7852"));
		assertEquals(14, filter.execute().count());

		// incompatible constraint breaks everything
		filter.constrainProperty(LED.dggsCell.getURI(),
				createLiteralNode("R785"));
		assertEquals(0, filter.execute().count());

		filter.constrainProperty(LED.dggsCell.getURI(),
				createURINode("http://not-a-literal/"));
		assertEquals(0, filter.execute().count());
	}

	@Test
	public void testFilterByNonExistentSquare() {
		filter.constrainProperty(LED.dggsCell.getURI(),
				createLiteralNode("R8192"));
		assertEquals(0, filter.execute().count());
	}

	@Test
	public void testFilterByBand() {
		filter.constrainProperty(LED.etmBand.getURI(), createLiteralNode(3));
		List<Observation> allObs = filter.execute()
				.collect(Collectors.toList());
		assertEquals(12, allObs.size());
		for (Observation obs : allObs) {
			assertEquals(3, obs.getBand());
		}

		filter.constrainProperty(LED.etmBand.getURI(), createLiteralNode(3));
		assertEquals(12, filter.execute().count());

		filter.constrainProperty(LED.etmBand.getURI(), createLiteralNode(4));
		assertEquals(0, filter.execute().count());

		filter.constrainProperty(LED.etmBand.getURI(),
				createURINode("http://not-a-literal/"));
		assertEquals(0, filter.execute().count());
	}

	@Test
	public void testFilterByNonexistentBand() {
		filter.constrainProperty(LED.etmBand.getURI(), createLiteralNode(17));
		assertEquals(0, filter.execute().count());
	}

	@Test
	public void testFilterByLevel() {
		filter.constrainProperty(LED.dggsLevelSquare.getURI(),
				createLiteralNode(5));
		List<Observation> allObs = filter.execute()
				.collect(Collectors.toList());
		assertEquals(14, allObs.size());
		for (Observation obs : allObs) {
			assertEquals(5, obs.getCellLevel());
		}

		filter.constrainProperty(LED.dggsLevelSquare.getURI(),
				createLiteralNode(5));
		assertEquals(14, filter.execute().count());

		filter.constrainProperty(LED.dggsLevelSquare.getURI(),
				createLiteralNode(6));
		assertEquals(0, filter.execute().count());

		filter.constrainProperty(LED.dggsLevelSquare.getURI(),
				createURINode("http://not-a-literal/"));
		assertEquals(0, filter.execute().count());
	}

	@Test
	public void testFilterByNonexistentLevel() {
		filter.constrainProperty(LED.dggsLevelSquare.getURI(),
				createLiteralNode(21));
		assertEquals(0, filter.execute().count());
	}

	@Test
	public void testComposeFilters() {
		filter.constrainProperty(LED.dggsCell.getURI(),
				createLiteralNode("R7852"))
				.constrainProperty(LED.etmBand.getURI(), createLiteralNode(5))
				.constrainProperty(LED.dggsLevelSquare.getURI(),
						createLiteralNode(5))
				.constrainProperty(RDF.type.getURI(), LED.Pixel.asNode());
		List<Observation> allObs = filter.execute()
				.collect(Collectors.toList());
		assertEquals(1, allObs.size());
		Observation firstObs = allObs.get(0);
		assertEquals(5, firstObs.getBand());
		assertEquals("R7852", firstObs.getCell().getDGGSIdent());
		assertEquals(5, firstObs.getCellLevel());
	}

	@Test
	public void testIrrelevantLatLonBoxProperty() {
		// Shouldn't do anything
		filter.constrainProperty(BoxBottom.getURI(), createLiteralNode(-80.0));
		assertEquals(84, filter.execute().count());
	}

	@Test
	public void testInvalidLatLonBoxProperty() {
		filter.constrainProperty(BoxRight.getURI(),
				createLiteralNode("clearly not a number"));
		assertEquals(0, filter.execute().count());
	}

	@Test
	public void testMeaningfulLatLonBoxProperty() {
		filter.constrainProperty(BoxBottom.getURI(), createLiteralNode(-35.45))
				.constrainProperty(BoxTop.getURI(), createLiteralNode(-35))
				.constrainProperty(BoxLeft.getURI(), createLiteralNode(148.8))
				.constrainProperty(BoxRight.getURI(), createLiteralNode(149.3))
				.constrainProperty(RDF.type.getURI(), LED.GridSquare.asNode())
				.constrainProperty(LED.etmBand.getURI(), createLiteralNode(0));
		List<Observation> out = filter.execute().collect(Collectors.toList());
		assertEquals(1, out.size());
		assertEquals("R78523", out.get(0).getCell().getDGGSIdent());

	}
}
```


Overlapping Code:
```
c class TestObservationFilter {
private HDF5Dataset ds;
private static TestData td;
private ObservationFilter filter;
@BeforeClass
public static void setUpClass() throws IOException {
td = new TestData();
}
@AfterClass
public static void tearDownClass() {
td.dispose();
}
@Before
public void setUp() {
ds = new HDF5Dataset(td.getPath());
filter = new ObservationFilter(ds, "http://fake/");
}
@After
public void tearDown() {
ds.dispose();
}
private void checkObservation(Observation obs)
throws CloneNotSupportedException {
// observation -> URL -> meta is just a fast way of getting an
// observationMeta
String obsURL = URLScheme.observationURL(obs);
ObservationMeta meta = URLScheme.parseObservationURL(obsURL);
Observation shouldMatch = ObservationFilter.retrieveFromMeta(meta, ds, "http://fake/");
assertNotNull(shouldMatch);
assertTrue(obs.equals(shouldMatch));
// Try retrieving some junk, just because we can
ObservationMeta brokenCellMeta = meta.clone();
brokenCellMeta.cell = brokenCellMeta.cell + "AKSJD";
assertNull(ObservationFilter.retrieveFromMeta(brokenCellMeta, ds, "http://fake/"));
ObservationMeta brokenLevelMeta = meta.clone();
brokenLevelMeta.levelPixel = -1;
assertNull(ObservationFilter.retrieveFromMeta(brokenLevelMeta, ds, "http://fake/"));
}
@Test
public void testGetFromMeta() throws CloneNotSupportedException {
Cell cell = ds.dggsCell("R7852");
ZonedDateTime timestamp = ZonedDateTime.parse("2013-05-27T23:58:20Z");
Product product = new Product(ds, "LS8_OLI_TIRS_NBAR");
checkObservation(cell.pixelObservation(product, timestamp, 4));
checkObservation(cell.tileObservation(product, timestamp, 3));
}
private void checkTypeFilterCount(int expected, Resource val) {
filter = new ObservationFilter(ds, "http://fake/");
ObservationProperty typeFilter = PropertyIndex
.getProperty(RDF.type.getURI()).get();
typeFilter.applyToFilter(filter, val.asNode());
assertEquals(expected, filter.execute().count());
}
@Test
public void testFilterByType() {
// First, count the number of observations (no filtering)
assertEquals(84, filter.execute().count());
checkTypeFilterCount(0, LED.time);
checkTypeFilterCount(84, QB.Observation);
checkTypeFilterCount(42, LED.Pixel);
checkTypeFilterCount(42, LED.GridSquare);
}
@Test
public void testIncompatibleType() {
filter.constrainToPixel().constrainToPixel();
assertEquals(84 / 2, filter.ex
```
<Overlap Ratio: 0.9873949579831933>

---

--- 7 --
Question ID: 9f27eaf38684361a0bfa6e77909dd1cd92c9e4a6
Original Code:
```
public class ElectricTimeActivity extends BaseActivity {

    private ElectricTimesVH electricTimesVH;

    @Override
    protected void initViews() {
        ViewDataBinding viewDataBinding = DataBindingUtil.setContentView(this, R.layout.activity_electric_time);
        electricTimesVH = new ElectricTimesVH(this);
        viewDataBinding.setVariable(BR.times, electricTimesVH);
        BleUtils.send(new byte[]{0x01, 0x04, 0x00, 0x07, 0x00, 0x04});
    }

    @Override
    protected void onDataReceived(byte[] datas) {
        if (datas[0] == 0x01 && datas[1] == 0x04 && datas[2] == 0x08) {
            electricTimesVH.isRefresh.set(false);
            electricTimesVH.mainTimes.set((long) ByteUtils.bytesToInt2(datas, 3));
            electricTimesVH.secondTimes.set((long) ByteUtils.bytesToInt2(datas, 7));
        }
    }

}
```


Overlapping Code:
```
ctricTimeActivity extends BaseActivity {
private ElectricTimesVH electricTimesVH;
@Override
protected void initViews() {
ViewDataBinding viewDataBinding = DataBindingUtil.setContentView(this, R.layout.activity_electric_time);
electricTimesVH = new ElectricTimesVH(this);
viewDataBinding.setVariable(BR.times, electricTimesVH);
BleUtils.send(new byte[]{0x01, 0x04, 0x00, 0x07, 0x00, 0x04});
}
@Override
protected void onDataReceived(byte[] datas) {
if (datas[0] == 0x01 && datas[1] == 0x04 && datas[2] == 0x08) {
electricTimesVH.isRefresh.set(false);
electricTimesVH.mainTimes.set((long) ByteUtils.bytesToInt2(datas, 3));
electricTimesVH.secondTimes.s
```
<Overlap Ratio: 0.9090909090909091>

---

--- 8 --
Question ID: cf47c0639a563db276542ee2c7637a9940717e82
Original Code:
```
@Getter
public class MetricSuite {

    private PatternMapper patternMapper;
    private List<RBMLMapping> rbmlStructuralMappings;
    private SPS sps;
    private List<RBMLMapping> rbmlBehavioralMappings;
    private IPS ips;

    //number of participating classes
    private int numParticipatingClasses = 0;

    //number of conforming structural roles, and nonconforming structural roles, respectively
    private int numConformingStructuralRoles = 0;
    private int numNonConformingStructuralRoles = 0;

    //number of conforming and nonconforming behavioral roles.
    private int numConformingBehavioralRoles = 0;
    private int numNonConformingBehavioralRoles = 0;

    private int numConformingRolesTotal = 0;
    private int numNonConformingRolesTotal = 0;

    //ssize2 metric for pattern instance (sum of fields and methods for all classes in a pattern)
    private int ssize2 = 0;

    //afferent (incoming) coupling to pattern as a whole.
    private int afferentCoupling = 0;

    //efferent (outgoing) coupling from pattern to anything not pattern-related
    private int efferentCoupling = 0;

    //coupling between pattern objects.
    private int couplingBetweenPatternClasses = 0;

    //pattern integrity, defined as (numConformingStructuralRoles)/(numConformingStructuralRoles + numNonConformingStructuralRoles)
    private String patternStructuralIntegrity = "";
    private String patternBehavioralIntegrity = "";
    private String patternIntegrity = "";

    //pattern instability, defined as (efferentCoupling) / (afferentCoupling + efferentCoupling)
    private String patternInstability = "";

    public MetricSuite(ConformanceResults conformanceResults){
        this.patternMapper = conformanceResults.getPatternMapper();
        this.sps = conformanceResults.getSps();
        this.rbmlStructuralMappings = conformanceResults.getRbmlStructureMappings();
        this.ips = conformanceResults.getIps();
        this.rbmlBehavioralMappings = conformanceResults.getRbmlBehaviorMappings();
        calculate();
    }

    private void calculate(){
        calcNumParticipatingClasses();
        calcNumConformingStructuralRoles();
        calcNumNonConformingStructuralRoles();
        //behavioral roles being done in 1 method now
        calcNumConformingBehavioralRoles();
        calcNumConformingRolesTotal();
        calcNumNonConformingRolesTotal();
        calcSSize2();
        calcAfferentCoupling();
        calcEfferentCoupling();
        calcCouplingPatternClasses();
        calcPatternStructuralIntegrity();
        calcPatternBehavioralIntegrity();
        calcPatternIntegrity();
        calcPatternInstability();
    }

    private void calcNumParticipatingClasses(){
        numParticipatingClasses = patternMapper.getAllParticipatingClasses().size();
    }

    private void calcNumConformingStructuralRoles(){
        for (RBMLMapping rbmlMapping : rbmlStructuralMappings){
            for (Pair<String, UMLClassifier> classifier : patternMapper.getClassifierModelBlocks()){
                if (rbmlMapping.getUmlArtifact().equals(classifier.getValue())){
                    //found conforming classifier role
                    numConformingStructuralRoles++;
                }
            }
            for (Pair<String, UMLOperation> operation : patternMapper.getOperationModelBlocks()){
                if (rbmlMapping.getUmlArtifact().equals(operation.getValue())){
                    //found conforming operation role
                    numConformingStructuralRoles++;
                }
            }
            for (Pair<String, UMLAttribute> attribute : patternMapper.getAttributeModelBlocks()){
                if (rbmlMapping.getUmlArtifact().equals(attribute.getValue())){
                    //found conforming attribute role
                    numConformingStructuralRoles++;
                }
            }
            for (Relationship association : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.ASSOCIATION)){
                if (rbmlMapping.getUmlArtifact().equals(association)){
                    //will be a pair.
                    numConformingStructuralRoles++;
                }
            }
            for (Relationship generalization : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.GENERALIZATION)){
                if (rbmlMapping.getUmlArtifact().equals(generalization)){
                    //will be a pair.
                    numConformingStructuralRoles++;
                }
            }
            for (Relationship dependency : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.DEPENDENCY)){
                if (rbmlMapping.getUmlArtifact().equals(dependency)){
                    //will be a pair.
                    numConformingStructuralRoles++;
                }
            }
            for (Relationship realization : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.REALIZATION)){
                if (rbmlMapping.getUmlArtifact().equals(realization)){
                    //will be a pair.
                    numConformingStructuralRoles++;
                }
            }
        }
    }

    private void calcNumNonConformingStructuralRoles(){
        for (Role role : sps.getAllRoles()){
            boolean roleHasBeenMapped = false;
            for (RBMLMapping rbmlMapping : rbmlStructuralMappings){
                if (role.equals(rbmlMapping.getRole())){
                    roleHasBeenMapped = true;
                }
            }
            if (!roleHasBeenMapped){
                numNonConformingStructuralRoles++;
            }
        }
    }

    private void calcNumConformingBehavioralRoles(){
        List<InteractionRole> seenAlready = new ArrayList<>();
        for (InteractionRole interactionRole : ips.getInteractions()){
            for (RBMLMapping rbmlMapping : rbmlBehavioralMappings){
                if (interactionRole.equals(rbmlMapping.getRole())){
                    if (!seenAlready.contains(interactionRole)){
                        seenAlready.add(interactionRole);
                    }
                }
            }
        }
        numConformingBehavioralRoles = seenAlready.size();
        numNonConformingBehavioralRoles = ips.getInteractions().size() - seenAlready.size();
    }
    
    private void calcNumConformingRolesTotal(){
        numConformingRolesTotal = numConformingBehavioralRoles + numConformingStructuralRoles;

    }

    private void calcNumNonConformingRolesTotal(){
        numNonConformingRolesTotal = numNonConformingBehavioralRoles + numNonConformingStructuralRoles;
    }

    private void calcSSize2(){
        for (Pair<String, UMLClassifier> umlClassifierPair : patternMapper.getClassifierModelBlocks()){
            UMLClassifier umlClassifier = umlClassifierPair.getValue();
            ssize2 += umlClassifier.getAttributes().size();
            ssize2 += umlClassifier.getOperations().size();
        }
    }

    private void calcAfferentCoupling(){
        //afferent means the value of the pair is a pattern class. (nonpattern_class -> pattern_class)
        afferentCoupling = patternMapper.getUniqueAfferentClassifiers().size();

    }

    private void calcEfferentCoupling(){
        //efferent means the key of the pair is a pattern class. (pattern_class -> nonpattern_class)
        efferentCoupling = patternMapper.getUniqueEfferentClassifiers().size();
    }

    private void calcCouplingPatternClasses(){
        for (Relationship classifierPair : patternMapper.getUniqueRelationshipsFromPatternClassifiers(RelationshipType.ASSOCIATION)){
            if (isClassifierInPatternInstance(classifierPair.getFrom()) && isClassifierInPatternInstance(classifierPair.getTo())){
                couplingBetweenPatternClasses++;
            }
        }
    }

    //defined as percentage of conforming pattern roles out of whole.
    private void calcPatternStructuralIntegrity(){
        DecimalFormat df2 = new DecimalFormat("#.##");
        double unformattedIntegrity = ((double) numConformingStructuralRoles) / (numConformingStructuralRoles + numNonConformingStructuralRoles);
        patternStructuralIntegrity = df2.format(unformattedIntegrity);
    }

    //defined as percentage of conforming pattern roles out of whole.
    private void calcPatternBehavioralIntegrity(){
        DecimalFormat df2 = new DecimalFormat("#.##");
        double unformattedIntegrity = ((double) numConformingBehavioralRoles) / (numConformingBehavioralRoles + numNonConformingBehavioralRoles);
        patternBehavioralIntegrity = df2.format(unformattedIntegrity);
    }

    //defined as percentage of conforming pattern roles out of whole.
    private void calcPatternIntegrity(){
        DecimalFormat df2 = new DecimalFormat("#.##");
        double unformattedIntegrity = ((double) numConformingStructuralRoles + (double) numConformingBehavioralRoles) / (numConformingStructuralRoles + numNonConformingStructuralRoles + numConformingBehavioralRoles + numNonConformingBehavioralRoles);
        patternIntegrity = df2.format(unformattedIntegrity);
    }


    private void calcPatternInstability(){
        DecimalFormat df2 = new DecimalFormat("#.##");
        if (afferentCoupling + efferentCoupling != 0){
            double unformattedInstability = ((double)efferentCoupling) / (afferentCoupling + efferentCoupling);
            patternInstability = df2.format(unformattedInstability);
        }else{
            //would get a divide by 0 error here
            //this happens when a pattern-class only has dependencies on 3rd party libs, and no class depends on this class...
            //happens a few times with Template method implementations
            patternInstability = "0";
        }

    }

    private boolean isClassifierInPatternInstance(UMLClassifier tester){
        for (Pair<String, UMLClassifier> umlClassifierPair: patternMapper.getClassifierModelBlocks()){
            if (umlClassifierPair.getValue().equals(tester)){
                return true;
            }
        }
        return false;
    }


    public String getSummary(){
        String delim = "\t";
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(Main.projectID + delim);
        stringBuilder.append(patternMapper.getPi().getSoftwareVersion().getVersionNum() + delim);
        stringBuilder.append(patternMapper.getPi().getPatternType() + delim);
        stringBuilder.append(patternMapper.getPi().getUniqueID() + delim);
        stringBuilder.append(this.getNumParticipatingClasses() + delim);
        stringBuilder.append(this.getNumConformingStructuralRoles() + delim);
        stringBuilder.append(this.getNumNonConformingStructuralRoles() + delim);
        stringBuilder.append(this.getNumConformingBehavioralRoles() + delim);
        stringBuilder.append(this.getNumNonConformingBehavioralRoles() + delim);
        stringBuilder.append(this.getNumConformingRolesTotal() + delim);
        stringBuilder.append(this.getNumNonConformingRolesTotal() + delim);
        stringBuilder.append(this.getSsize2() + delim);
        stringBuilder.append(this.getPatternMapper().getPatternMembers().size() + delim);
        stringBuilder.append(this.getAfferentCoupling() + delim);
        stringBuilder.append(this.getEfferentCoupling() + delim);
        stringBuilder.append(this.getCouplingBetweenPatternClasses() + delim);
        stringBuilder.append(this.getPatternStructuralIntegrity() + delim);
        stringBuilder.append(this.getPatternBehavioralIntegrity() + delim);
        stringBuilder.append(this.getPatternIntegrity() + delim);
        stringBuilder.append(this.getPatternInstability() + delim);
        return stringBuilder.toString();
    }

}
```


Overlapping Code:
```
rivate PatternMapper patternMapper;
private List<RBMLMapping> rbmlStructuralMappings;
private SPS sps;
private List<RBMLMapping> rbmlBehavioralMappings;
private IPS ips;
//number of participating classes
private int numParticipatingClasses = 0;
//number of conforming structural roles, and nonconforming structural roles, respectively
private int numConformingStructuralRoles = 0;
private int numNonConformingStructuralRoles = 0;
//number of conforming and nonconforming behavioral roles.
private int numConformingBehavioralRoles = 0;
private int numNonConformingBehavioralRoles = 0;
private int numConformingRolesTotal = 0;
private int numNonConformingRolesTotal = 0;
//ssize2 metric for pattern instance (sum of fields and methods for all classes in a pattern)
private int ssize2 = 0;
//afferent (incoming) coupling to pattern as a whole.
private int afferentCoupling = 0;
//efferent (outgoing) coupling from pattern to anything not pattern-related
private int efferentCoupling = 0;
//coupling between pattern objects.
private int couplingBetweenPatternClasses = 0;
//pattern integrity, defined as (numConformingStructuralRoles)/(numConformingStructuralRoles + numNonConformingStructuralRoles)
private String patternStructuralIntegrity = "";
private String patternBehavioralIntegrity = "";
private String patternIntegrity = "";
//pattern instability, defined as (efferentCoupling) / (afferentCoupling + efferentCoupling)
private String patternInstability = "";
public MetricSuite(ConformanceResults conformanceResults){
this.patternMapper = conformanceResults.getPatternMapper();
this.sps = conformanceResults.getSps();
this.rbmlStructuralMappings = conformanceResults.getRbmlStructureMappings();
this.ips = conformanceResults.getIps();
this.rbmlBehavioralMappings = conformanceResults.getRbmlBehaviorMappings();
calculate();
}
private void calculate(){
calcNumParticipatingClasses();
calcNumConformingStructuralRoles();
calcNumNonConformingStructuralRoles();
//behavioral roles being done in 1 method now
calcNumConformingBehavioralRoles();
calcNumConformingRolesTotal();
calcNumNonConformingRolesTotal();
calcSSize2();
calcAfferentCoupling();
cal
```
<Overlap Ratio: 0.9675967596759676>

---

--- 9 --
Question ID: 7d3260ed208653d80c9045f17dc684ec11257666
Original Code:
```
public class WhileCommand extends AbstractCommand {

    // <--[command]
    // @Since 0.3.0
    // @Name while
    // @Arguments 'start'/'stop'/'next' [if comparisons]
    // @Short runs a block of code repeatedly for so long as the comparisons return true.
    // @Updated 2017/02/19
    // @Group Queue
    // @Procedural true
    // @Minimum 1
    // @Maximum -1
    // @Description
    // Runs a block of code repeatedly for so long as the comparisons return true.
    // TODO: Explain more!
    // @Example
    // # This example runs forever (until it's externally stopped, or the engine shuts down)
    // # and echoes "hi" every half second.
    // - while start true:
    //   - echo "hi"
    //   - wait 0.5s
    // -->

    @Override
    public String getName() {
        return "while";
    }

    @Override
    public String getArguments() {
        return "'start'/'stop'/'next' [if comparisons]";
    }

    @Override
    public int getMinimumArguments() {
        return 1;
    }

    @Override
    public int getMaximumArguments() {
        return -1;
    }

    @Override
    public boolean isProcedural() {
        return true;
    }

    @Override
    public boolean allowsBlock() {
        return true;
    }

    @Override
    public void execute(CommandQueue queue, CommandEntry entry) {
        if (entry.arguments.get(0).toString().equals("\0CALLBACK")) {
            CommandEntry orig = queue.commandStack.peek().entries[entry.blockStart - 1];
            IfCommand.TryIfHelper helper = new IfCommand.TryIfHelper();
            helper.queue = queue;
            helper.entry = orig;
            helper.arguments = new ArrayList<>(orig.arguments);
            boolean success = IfCommand.tryIf(helper);
            if (success) {
                if (queue.shouldShowGood()) {
                    queue.outGood("While continuing...");
                }
                queue.commandStack.peek().goTo(entry.blockStart);
            }
            else {
                if (queue.shouldShowGood()) {
                    queue.outGood("While completed!");
                }
            }
            return;
        }
        String type = entry.getArgumentObject(queue, 0).toString();
        if (type.equals("start")) {
            IfCommand.TryIfHelper helper = new IfCommand.TryIfHelper();
            helper.queue = queue;
            helper.entry = entry;
            helper.arguments = new ArrayList<>(entry.arguments);
            helper.arguments.remove(0);
            boolean success = IfCommand.tryIf(helper);
            if (!success) {
                if (queue.shouldShowGood()) {
                    queue.outGood("While is false, skipping.");
                }
                queue.commandStack.peek().goTo(entry.blockEnd + 1);
                return;
            }
            if (queue.shouldShowGood()) {
                queue.outGood("While is true, looping...");
            }
        }
        else if (type.equals("stop")) {
            CommandStackEntry cse = queue.commandStack.peek();
            for (int i = cse.getIndex(); i < cse.entries.length; i++) {
                if (cse.entries[i].command instanceof WhileCommand && cse.entries[i].arguments.get(0).toString().equals("\0CALLBACK")) {
                    if (queue.shouldShowGood()) {
                        queue.outGood("Stopping a while loop.");
                    }
                    cse.goTo(i + 1);
                    return;
                }
            }
            queue.handleError(entry, "Cannot stop while: not in one!");
        }
        else if (type.equals("next")) {
            CommandStackEntry cse = queue.commandStack.peek();
            for (int i = cse.getIndex(); i < cse.entries.length; i++) {
                if (cse.entries[i].command instanceof WhileCommand && cse.entries[i].arguments.get(0).toString().equals("\0CALLBACK")) {
                    if (queue.shouldShowGood()) {
                        queue.outGood("Jumping forward in a while loop.");
                    }
                    cse.goTo(i);
                    return;
                }
            }
            queue.handleError(entry, "Cannot advance while: not in one!");
        }
    }
}
```


Overlapping Code:
```
s WhileCommand extends AbstractCommand {
// <--[command]
// @Since 0.3.0
// @Name while
// @Arguments 'start'/'stop'/'next' [if comparisons]
// @Short runs a block of code repeatedly for so long as the comparisons return true.
// @Updated 2017/02/19
// @Group Queue
// @Procedural true
// @Minimum 1
// @Maximum -1
// @Description
// Runs a block of code repeatedly for so long as the comparisons return true.
// TODO: Explain more!
// @Example
// # This example runs forever (until it's externally stopped, or the engine shuts down)
// # and echoes "hi" every half second.
// - while start true:
// - echo "hi"
// - wait 0.5s
// -->
@Override
public String getName() {
return "while";
}
@Override
public String getArguments() {
return "'start'/'stop'/'next' [if comparisons]";
}
@Override
public int getMinimumArguments() {
return 1;
}
@Override
public int getMaximumArguments() {
return -1;
}
@Override
public boolean isProcedural() {
return true;
}
@Override
public boolean allowsBlock() {
return true;
}
@Override
public void execute(CommandQueue queue, CommandEntry entry) {
if (entry.arguments.get(0).toString().equals("\0CALLBACK")) {
CommandEntry orig = queue.commandStack.peek().entries[entry.blockStart - 1];
IfCommand.TryIfHelper helper = new IfCommand.TryIfHelper();
helper.queue = queue;
helper.entry = orig;
helper.arguments = new ArrayList<>(orig.arguments);
boolean success = IfCommand.tryIf(helper);
if (success) {
if (queue.shouldShowGood()) {
queue.outGood("While continuing...");
}
queue.commandStack.peek().goTo(entry.blockStart);
}
else {
if (queue.shouldShowGood()) {
queue.outGood("While completed!");
}
}
return;
}
String type = entry.getArgumentObject(queue, 0).toString();
if (type.equals("start")) {
IfCommand.TryIfHelper helper = new IfCommand.TryIfHelper();
helper.queue = queue;
helper.entry = entry;
helper.arguments = new ArrayList<>(entry.arguments);
helper.argument
```
<Overlap Ratio: 0.9880395215808633>

---

--- 10 --
Question ID: 6d76521cd39de2900907e491052a899a9a4eef79
Original Code:
```
public class Font extends AbstractStyle {
// ### E N U M S ###
    /**
     * Default font family as constant
     */
    public static final String DEFAULTFONT = "Calibri";

    /**
     * Enum for the vertical alignment of the text from base line
     */
    public enum VerticalAlignValue {
        // baseline, // Maybe not used in Excel
        /**
         * Text will be rendered as subscript
         */
        subscript(1),
        /**
         * Text will be rendered as superscript
         */
        superscript(2),
        /**
         * Text will be rendered normal
         */
        none(0);

        private final int value;

        VerticalAlignValue(int value) {
            this.value = value;
        }

        public int getValue() {
            return this.value;
        }
    }

    /**
     * Enum for the font scheme
     */
    public enum SchemeValue {
        /**
         * Font scheme is major
         */
        major(1),
        /**
         * Font scheme is minor (default)
         */
        minor(2),
        /**
         * No Font scheme is used
         */
        none(0);

        private final int value;

        SchemeValue(int value) {
            this.value = value;
        }

        public int getValue() {
            return this.value;
        }
    }

    // ### P R I V A T E  F I E L D S ###
    private int size;
    private String name;
    private String family;
    private int colorTheme;
    private String colorValue;
    private SchemeValue scheme;
    private VerticalAlignValue verticalAlign;
    private boolean bold;
    private boolean italic;
    private boolean underline;
    private boolean doubleUnderline;
    private boolean strike;
    private String charset;

// ### G E T T E R S  &  S E T T E R S ###

    /**
     * Gets the font size. Valid range is from 8 to 75
     *
     * @return Font size
     */
    public int getSize() {
        return this.size;
    }

    /**
     * Sets the Font size. Valid range is from 8 to 75
     *
     * @param size Font size
     */
    public void setSize(int size) {
        if (size < 8) {
            this.size = 8;
        } else if (size > 75) {
            this.size = 72;
        } else {
            this.size = size;
        }
    }

    /**
     * Gets the font name (Default is Calibri)
     *
     * @return Font name
     */
    public String getName() {
        return this.name;
    }

    /**
     * Sets the font name (Default is Calibri)
     *
     * @param name Font name
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Gets the font family (Default is 2)
     *
     * @return Font family
     */
    public String getFamily() {
        return this.family;
    }

    /**
     * Sets the font family (Default is 2)
     *
     * @param family Font family
     */
    public void setFamily(String family) {
        this.family = family;
    }

    /**
     * Gets the font color theme (Default is 1)
     *
     * @return Font color theme
     */
    public int getColorTheme() {
        return this.colorTheme;
    }

    /**
     * Sets the font color theme (Default is 1)
     *
     * @param colorTheme Font color theme
     */
    public void setColorTheme(int colorTheme) {
        this.colorTheme = colorTheme;
    }

    /**
     * Gets the Font color (default is empty)
     *
     * @return Font color
     */
    public String getColorValue() {
        return this.colorValue;
    }

    /**
     * Sets the font color (default is empty)
     *
     * @param colorValue Font color
     */
    public void setColorValue(String colorValue) {
        this.colorValue = colorValue;
    }

    /**
     * Gets the font scheme (Default is minor)
     *
     * @return Font scheme
     */
    public SchemeValue getScheme() {
        return this.scheme;
    }

    /**
     * Sets the Font scheme (Default is minor)
     *
     * @param scheme Font scheme
     */
    public void setScheme(SchemeValue scheme) {
        this.scheme = scheme;
    }

    /**
     * Gets the alignment of the font (Default is none)
     *
     * @return Alignment of the font
     */
    public VerticalAlignValue getVerticalAlign() {
        return this.verticalAlign;
    }

    /**
     * Sets the Alignment of the font (Default is none)
     *
     * @param verticalAlign Alignment of the font
     */
    public void setVerticalAlign(VerticalAlignValue verticalAlign) {
        this.verticalAlign = verticalAlign;
    }

    /**
     * Gets the bold parameter of the font
     *
     * @return If true, the font is bold
     */
    public boolean isBold() {
        return this.bold;
    }

    /**
     * Sets the bold parameter of the font
     *
     * @param bold If true, the font is bold
     */
    public void setBold(boolean bold) {
        this.bold = bold;
    }

    /**
     * Gets the italic parameter of the font
     *
     * @return If true, the font is italic
     */
    public boolean isItalic() {
        return this.italic;
    }

    /**
     * Sets the italic parameter of the font
     *
     * @param italic If true, the font is italic
     */
    public void setItalic(boolean italic) {
        this.italic = italic;
    }

    /**
     * Gets the underline parameter of the font
     *
     * @return If true, the font as one underline
     */
    public boolean isUnderline() {
        return this.underline;
    }

    /**
     * Sets the underline parameter of the font
     *
     * @param underline If true, the font as one underline
     */
    public void setUnderline(boolean underline) {
        this.underline = underline;
    }

    /**
     * Gets the double-underline parameter of the font
     *
     * @return If true, the font ha a double underline
     */
    public boolean isDoubleUnderline() {
        return this.doubleUnderline;
    }

    /**
     * Sets the double-underline parameter of the font
     *
     * @param doubleUnderline If true, the font ha a double underline
     */
    public void setDoubleUnderline(boolean doubleUnderline) {
        this.doubleUnderline = doubleUnderline;
    }

    /**
     * Gets whether the font is struck through
     *
     * @return If true, the font is declared as strike-through
     */
    public boolean isStrike() {
        return this.strike;
    }

    /**
     * Sets whether the font is struck through
     *
     * @param strike If true, the font is declared as strike-through
     */
    public void setStrike(boolean strike) {
        this.strike = strike;
    }

    /**
     * Gets the charset of the Font (Default is empty)
     *
     * @return Charset of the Font
     */
    public String getCharset() {
        return this.charset;
    }

    /**
     * Sets the charset of the Font (Default is empty)
     *
     * @param charset Charset of the Font
     */
    public void setCharset(String charset) {
        this.charset = charset;
    }

    /**
     * Gets whether this object is the default font
     *
     * @return In true the font is equals the default font
     */
    public boolean isDefaultFont() {
        Font temp = new Font();
        return this.equals(temp);
    }

// ### C O N S T R U C T O R S ###   

    /**
     * Default constructor
     */
    public Font() {
        this.size = 11;
        this.name = DEFAULTFONT;
        this.family = "2";
        this.colorTheme = 1;
        this.colorValue = "";
        this.charset = "";
        this.scheme = SchemeValue.minor;
        this.verticalAlign = VerticalAlignValue.none;
    }

    /**
     * Override toString method
     *
     * @return String of a class instance
     */
    @Override
    public String toString() {
        return "Font:" + this.hashCode();
    }

    /**
     * Method to copy the current object to a new one
     *
     * @return Copy of the current object without the internal ID
     */
    @Override
    public Font copy() {
        Font copy = new Font();
        copy.setBold(this.bold);
        copy.setCharset(this.charset);
        copy.setColorTheme(this.colorTheme);
        copy.setColorValue(this.colorValue);
        copy.setVerticalAlign(this.verticalAlign);
        copy.setDoubleUnderline(this.doubleUnderline);
        copy.setFamily(this.family);
        copy.setItalic(this.italic);
        copy.setName(this.name);
        copy.setScheme(this.scheme);
        copy.setSize(this.size);
        copy.setStrike(this.strike);
        copy.setUnderline(this.underline);
        return copy;
    }

    /**
     * Override method to calculate the hash of this component
     *
     * @return Calculated hash as string
     */
    @Override
    public int hashCode() {
        int p = 257;
        int r = 1;
        r *= p + (this.bold ? 0 : 1);
        r *= p + (this.italic ? 0 : 1);
        r *= p + (this.underline ? 0 : 1);
        r *= p + (this.doubleUnderline ? 0 : 1);
        r *= p + (this.strike ? 0 : 1);
        r *= p + this.colorTheme;
        r *= p + this.colorValue.hashCode();
        r *= p + this.family.hashCode();
        r *= p + this.name.hashCode();
        r *= p + this.scheme.getValue();
        r *= p + this.verticalAlign.value;
        r *= p + this.charset.hashCode();
        r *= p + this.size;
        return r;
    }


}
```


Overlapping Code:
```
ss Font extends AbstractStyle {
// ### E N U M S ###
/**
* Default font family as constant
*/
public static final String DEFAULTFONT = "Calibri";
/**
* Enum for the vertical alignment of the text from base line
*/
public enum VerticalAlignValue {
// baseline, // Maybe not used in Excel
/**
* Text will be rendered as subscript
*/
subscript(1),
/**
* Text will be rendered as superscript
*/
superscript(2),
/**
* Text will be rendered normal
*/
none(0);
private final int value;
VerticalAlignValue(int value) {
this.value = value;
}
public int getValue() {
return this.value;
}
}
/**
* Enum for the font scheme
*/
public enum SchemeValue {
/**
* Font scheme is major
*/
major(1),
/**
* Font scheme is minor (default)
*/
minor(2),
/**
* No Font scheme is used
*/
none(0);
private final int value;
SchemeValue(int value) {
this.value = value;
}
public int getValue() {
return this.value;
}
}
// ### P R I V A T E F I E L D S ###
private int size;
private String name;
private String family;
private int colorTheme;
private String colorValue;
private SchemeValue scheme;
private VerticalAlignValue verticalAlign;
private boolean bold;
private boolean italic;
private boolean underline;
private boolean doubleUnderline;
private boolean strike;
private String charset;
// ### G E T T E R S & S E T T E R S ###
/**
* Gets the font size. Valid range is from 8 to 75
*
* @return Font size
*/
public int getSize() {
return this.size;
}
/**
* Sets the Font size. Valid range is from 8 to 75
*
* @param size Font size
*/
public void setSize(int size) {
if (size < 8) {
this.size = 8;
} else if (size > 75) {
this.size = 72;
} else {
this.size = size;
}
}
/**
* Gets the font name (Default is Calibri)
*
* @retur
```
<Overlap Ratio: 0.9730967372638809>

---

--- 11 --
Question ID: f7251d3359d14487ed2dda0ef1ef2b1cda8c4b0a
Original Code:
```
@Slf4j
@RequiredArgsConstructor
public class InternalGroovyScriptDao extends BaseGroovyScriptDaoImpl {
    private final ApplicationContext applicationContext;
    private final CasConfigurationProperties casProperties;

    @Override
    public Map<String, List<Object>> getPersonAttributesFromMultivaluedAttributes(final Map<String, List<Object>> attributes) {
        if (attributes.containsKey("username")) {
            val username = attributes.get("username");
            if (!username.isEmpty()) {
                val results = new HashMap<String, List<Object>>();
                val attrs = getAttributesForUser(username.get(0).toString());
                LOGGER.debug("Groovy-based attributes found are [{}]", attrs);
                attrs.forEach((k, v) -> {
                    val values = new ArrayList<Object>(CollectionUtils.toCollection(v));
                    LOGGER.debug("Adding Groovy-based attribute [{}] with value(s) [{}]", k, values);
                    results.put(k, values);
                });
                return results;
            }
        }
        return new HashMap<>(0);
    }

    @Override
    public Map<String, Object> getAttributesForUser(final String uid) {
        val finalAttributes = new HashMap<String, Object>();
        casProperties.getAuthn().getAttributeRepository().getGroovy()
            .forEach(groovy -> {
                final Object[] args = {uid, LOGGER, casProperties, applicationContext};
                final Map<String, Object> personAttributesMap =
                    ScriptingUtils.executeGroovyScript(groovy.getLocation(), args, Map.class, true);
                finalAttributes.putAll(personAttributesMap);
            });

        return finalAttributes;
    }
}
```


Overlapping Code:
```
tructor
public class InternalGroovyScriptDao extends BaseGroovyScriptDaoImpl {
private final ApplicationContext applicationContext;
private final CasConfigurationProperties casProperties;
@Override
public Map<String, List<Object>> getPersonAttributesFromMultivaluedAttributes(final Map<String, List<Object>> attributes) {
if (attributes.containsKey("username")) {
val username = attributes.get("username");
if (!username.isEmpty()) {
val results = new HashMap<String, List<Object>>();
val attrs = getAttributesForUser(username.get(0).toString());
LOGGER.debug("Groovy-based attributes found are [{}]", attrs);
attrs.forEach((k, v) -> {
val values = new ArrayList<Object>(CollectionUtils.toCollection(v));
LOGGER.debug("Adding Groovy-based attribute [{}] with value(s) [{}]", k, values);
results.put(k, values);
});
return results;
}
}
return new HashMap<>(0);
}
@Override
public Map<String, Object> getAttributesForUser(final String uid) {
val finalAttributes = new HashMap<String, Object>();
casProperties.getAuthn().getAttributeRepository().getGroovy()
.forEach(groovy -> {
final Object[] args = {uid, LOGGER, casProperties, applicationContext};
final Map<String, Object> personAttributesMap =
ScriptingUtils.executeGroovyScript(groovy.getLocation(), args, Map.class, true);
finalAttributes.putAll(personAttributesMap);
});
return finalAttributes;

```
<Overlap Ratio: 0.9803921568627451>

---

--- 12 --
Question ID: 56a693011aa5ea0e90a6485a9b2175abb674b4ef
Original Code:
```
public class MyReducer extends Reducer<Text, Text, Text, Text> {
    private MultipleOutputs multipleOutputs;
    private String search;

    @Override
    public void setup(Context context) {
        multipleOutputs = new MultipleOutputs(context);
        /* get search query from configuration */
        Configuration conf = context.getConfiguration();
        search = conf.get("search");
        /* reduce has no named input file! */
    }

    @Override
    public void reduce(Text key, Iterable<Text> values, Context context) {
        int nbrOfMatches = 0;
        int nbrOfMisses = 0;

        for (Text val : values) {
           String[] fields = val.toString().split(" ");
           nbrOfMatches += Integer.parseInt(fields[0]);
           nbrOfMisses += Integer.parseInt(fields[1]);
        }
        try { 
           // context.write(key, new Text(nbrOfMatches+" "+nbrOfMisses));
           multipleOutputs.write("text", key, new Text(nbrOfMatches+" "+nbrOfMisses), "counts-"+search);
        } catch (Throwable e) {
           // catch io errors from FileInputStream or readLine()
           System.out.println("Error: " + e + " " + e.getMessage());
        }
//        try { 
//           // context.write(key, new Text(nbrOfMatches+" "+nbrOfMisses));
//           context.write(key, new Text(nbrOfMatches+" "+nbrOfMisses));
//        } catch (Throwable e) {
//           // catch io errors from FileInputStream or readLine()
//           System.out.println("Error: " + e + " " + e.getMessage());
//        }
    }

    @Override
    protected void cleanup(Context context) throws IOException, InterruptedException {
        multipleOutputs.close();
    }
}
```


Overlapping Code:
```
ic class MyReducer extends Reducer<Text, Text, Text, Text> {
private MultipleOutputs multipleOutputs;
private String search;
@Override
public void setup(Context context) {
multipleOutputs = new MultipleOutputs(context);
/* get search query from configuration */
Configuration conf = context.getConfiguration();
search = conf.get("search");
/* reduce has no named input file! */
}
@Override
public void reduce(Text key, Iterable<Text> values, Context context) {
int nbrOfMatches = 0;
int nbrOfMisses = 0;
for (Text val : values) {
String[] fields = val.toString().split(" ");
nbrOfMatches += Integer.parseInt(fields[0]);
nbrOfMisses += Integer.parseInt(fields[1]);
}
try { 
// context.write(key, new Text(nbrOfMatches+" "+nbrOfMisses));
multipleOutputs.write("text", key, new Text(nbrOfMatches+" "+nbrOfMisses), "counts-"+search);
} catch (Throwable e) {
// catch io errors from FileInputStream or readLine()
System.out.println("Error: " + e + " " + e.getMessage());
}
// try { 
// // context.write(key, new Text(nbrOfMatches+" "+nbrOfMisses));
// context.write(key, new Text(nbrOfMatches+" "+nbrOfMisses));
// } catch (Throwable e) {
// // catch io errors from FileInputStream or readLine()
// System.out.println("Error: " + e + " " + e.getMessage());
// }
}
@Override
protected void cleanup(Context context) throws IOException, InterruptedException {
multipleOutputs.close();

```
<Overlap Ratio: 0.994942196531792>

---

--- 13 --
Question ID: bbf24f4f98cb56512205ac6c13984c95a0538c30
Original Code:
```
public class Advent041 {

    public static void main(String[] args) throws Exception {
        String input = new String(Files.readAllBytes(Paths.get(Advent040.class.getClassLoader().getResource("2016/input_4.txt").toURI())));
        Pattern sectorP = Pattern.compile("(\\d+)");
        String[] rows = input.split("\n");
        System.out.println("a: " + (int)'a');
        System.out.println("z: " + (int)'z');
        System.out.println("A: " + (int)'A');
        System.out.println("Z: " + (int)'Z');
        System.out.println("-: " + (int)'-');
        System.out.println(" : " + (int)' ');
        int A = 65, Z = 90, a = 97, z = 122;
        int gapSize = a - Z - 1; // 6
        int phantomEndIndex = z - gapSize;
        int cycle = phantomEndIndex - A + 1;
        // calculate index from 65 to 115 (phantom end) and then add gap size to result
        Integer sectorId = null;
        for (String row : rows) {
            Matcher sectorM = sectorP.matcher(row);
            sectorM.find();
            Integer caesarShift = Integer.valueOf(sectorM.group());

            String encoded = row.substring(0, row.indexOf(caesarShift+""));
            StringBuilder sb = new StringBuilder();
            for (int code : encoded.toCharArray()) {
                if (code == (int)'-') {
                    code = 32;
                } else {
                    // normalize the gap between Z - a
                    if (code > Z) {
                        code = code - gapSize;
                    }
                    int left = caesarShift - cycle * (caesarShift / cycle);
                    if ((code - A) + left >= cycle) {
                        code = A + (left - (phantomEndIndex - code) - 1);
                    } else {
                        code = code + left;
                    }
                    // return the gap back
                    if (code > Z) {
                        code = code + gapSize;
                    }
                }
//                System.out.print(code + " ");
                sb.append((char)code);
            }
            System.out.println(sb.toString());
            if (sb.toString().toLowerCase().contains("northpole object")) {
                sectorId = caesarShift;
            }
        }
        System.out.println("---");
        System.out.println("SectorId with North Pole objects: " + sectorId);
    }
}
```


Overlapping Code:
```
41 {
public static void main(String[] args) throws Exception {
String input = new String(Files.readAllBytes(Paths.get(Advent040.class.getClassLoader().getResource("2016/input_4.txt").toURI())));
Pattern sectorP = Pattern.compile("(\\d+)");
String[] rows = input.split("\n");
System.out.println("a: " + (int)'a');
System.out.println("z: " + (int)'z');
System.out.println("A: " + (int)'A');
System.out.println("Z: " + (int)'Z');
System.out.println("-: " + (int)'-');
System.out.println(" : " + (int)' ');
int A = 65, Z = 90, a = 97, z = 122;
int gapSize = a - Z - 1; // 6
int phantomEndIndex = z - gapSize;
int cycle = phantomEndIndex - A + 1;
// calculate index from 65 to 115 (phantom end) and then add gap size to result
Integer sectorId = null;
for (String row : rows) {
Matcher sectorM = sectorP.matcher(row);
sectorM.find();
Integer caesarShift = Integer.valueOf(sectorM.group());
String encoded = row.substring(0, row.indexOf(caesarShift+""));
StringBuilder sb = new StringBuilder();
for (int code : encoded.toCharArray()) {
if (code == (int)'-') {
code = 32;
} else {
// normalize the gap between Z - a
if (code > Z) {
code = code - gapSize;
}
int left = caesarShift - cycle * (caesarShift / cycle);
if ((code - A) + left >= cycle) {
code = A + (left - (phantomEndIndex - code) - 1);
} else {
code = code + left;
}
// return the gap back
if (code > Z) {
code = code + gapSize;
}
}
// System.out.print(code + " ");
sb.append((char)code);
}
System.out.println(sb.toString());
if (sb.toString().toLowerCase().contains("northpole object")) {
sectorId = caesarShift;
}
}
System.out.println("---");
System.out.println("SectorId with North Pole objects: " + s
```
<Overlap Ratio: 0.9804849201655825>

---

--- 14 --
Question ID: f57cab796fe4c4589958e35066a2632ee32d4037
Original Code:
```
class Element {
    private final SubElement [] subElements;
    
    public Element(final Label l) {
        this.subElements = new SubElement [] {l};
    }
    
    public Element(final Label l, final Value v) {
        this.subElements = new SubElement [] {l, v};
    }
    
    public boolean isValue() {
        return this.subElements.length > 1;
    }
    
    public Label getLabel() {
        return (Label)this.subElements[0];
    }
    
    public Value getValue() {
        if (!isValue()) {
            return null;
        }
        return (Value)this.subElements[1];
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < subElements.length; i++) {
            sb.append(subElements[i].toString());
            if (i == 0) {
                // Add colon after Label.
                sb.append(':');
                if (isValue()) {
                    // Add space to intro the value.
                    sb.append(' ');
                }
            }
        }
        return sb.toString();
    }
}
```


Overlapping Code:
```
 Element {
private final SubElement [] subElements;

public Element(final Label l) {
this.subElements = new SubElement [] {l};
}

public Element(final Label l, final Value v) {
this.subElements = new SubElement [] {l, v};
}

public boolean isValue() {
return this.subElements.length > 1;
}

public Label getLabel() {
return (Label)this.subElements[0];
}

public Value getValue() {
if (!isValue()) {
return null;
}
return (Value)this.subElements[1];
}

@Override
public String toString() {
StringBuilder sb = new StringBuilder();
for (int i = 0; i < subElements.length; i++) {
sb.append(subElements[i].toString());
if (i == 0) {
// Add colon after Label.
sb.append(':');
if (isValue()) {
// Add space to intro the value.
sb.append(' ');
}
}
}
return sb.
```
<Overlap Ratio: 0.9740932642487047>

---

--- 15 --
Question ID: a086d7321caaa52e2f23a65babe0197032bcd427
Original Code:
```
@javax.annotation.Generated("by GAPIC")
public class DlpServiceClientTest {
  private static MockDlpService mockDlpService;
  private static MockServiceHelper serviceHelper;
  private DlpServiceClient client;
  private LocalChannelProvider channelProvider;

  @BeforeClass
  public static void startStaticServer() {
    mockDlpService = new MockDlpService();
    serviceHelper =
        new MockServiceHelper("in-process-1", Arrays.<MockGrpcService>asList(mockDlpService));
    serviceHelper.start();
  }

  @AfterClass
  public static void stopServer() {
    serviceHelper.stop();
  }

  @Before
  public void setUp() throws IOException {
    serviceHelper.reset();
    channelProvider = serviceHelper.createChannelProvider();
    DlpServiceSettings settings =
        DlpServiceSettings.newBuilder()
            .setTransportChannelProvider(channelProvider)
            .setCredentialsProvider(NoCredentialsProvider.create())
            .build();
    client = DlpServiceClient.create(settings);
  }

  @After
  public void tearDown() throws Exception {
    client.close();
  }

  @Test
  @SuppressWarnings("all")
  public void inspectContentTest() {
    InspectContentResponse expectedResponse = InspectContentResponse.newBuilder().build();
    mockDlpService.addResponse(expectedResponse);

    String name = "EMAIL_ADDRESS";
    InfoType infoTypesElement = InfoType.newBuilder().setName(name).build();
    List<InfoType> infoTypes = Arrays.asList(infoTypesElement);
    InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();
    String type = "text/plain";
    String value = "My email is example@example.com.";
    ContentItem itemsElement = ContentItem.newBuilder().setType(type).setValue(value).build();
    List<ContentItem> items = Arrays.asList(itemsElement);

    InspectContentResponse actualResponse = client.inspectContent(inspectConfig, items);
    Assert.assertEquals(expectedResponse, actualResponse);

    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();
    Assert.assertEquals(1, actualRequests.size());
    InspectContentRequest actualRequest = (InspectContentRequest) actualRequests.get(0);

    Assert.assertEquals(inspectConfig, actualRequest.getInspectConfig());
    Assert.assertEquals(items, actualRequest.getItemsList());
    Assert.assertTrue(
        channelProvider.isHeaderSent(
            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),
            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));
  }

  @Test
  @SuppressWarnings("all")
  public void inspectContentExceptionTest() throws Exception {
    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);
    mockDlpService.addException(exception);

    try {
      String name = "EMAIL_ADDRESS";
      InfoType infoTypesElement = InfoType.newBuilder().setName(name).build();
      List<InfoType> infoTypes = Arrays.asList(infoTypesElement);
      InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();
      String type = "text/plain";
      String value = "My email is example@example.com.";
      ContentItem itemsElement = ContentItem.newBuilder().setType(type).setValue(value).build();
      List<ContentItem> items = Arrays.asList(itemsElement);

      client.inspectContent(inspectConfig, items);
      Assert.fail("No exception raised");
    } catch (InvalidArgumentException e) {
      // Expected exception
    }
  }

  @Test
  @SuppressWarnings("all")
  public void deidentifyContentTest() {
    DeidentifyContentResponse expectedResponse = DeidentifyContentResponse.newBuilder().build();
    mockDlpService.addResponse(expectedResponse);

    DeidentifyConfig deidentifyConfig = DeidentifyConfig.newBuilder().build();
    InspectConfig inspectConfig = InspectConfig.newBuilder().build();
    List<ContentItem> items = new ArrayList<>();

    DeidentifyContentResponse actualResponse =
        client.deidentifyContent(deidentifyConfig, inspectConfig, items);
    Assert.assertEquals(expectedResponse, actualResponse);

    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();
    Assert.assertEquals(1, actualRequests.size());
    DeidentifyContentRequest actualRequest = (DeidentifyContentRequest) actualRequests.get(0);

    Assert.assertEquals(deidentifyConfig, actualRequest.getDeidentifyConfig());
    Assert.assertEquals(inspectConfig, actualRequest.getInspectConfig());
    Assert.assertEquals(items, actualRequest.getItemsList());
    Assert.assertTrue(
        channelProvider.isHeaderSent(
            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),
            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));
  }

  @Test
  @SuppressWarnings("all")
  public void deidentifyContentExceptionTest() throws Exception {
    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);
    mockDlpService.addException(exception);

    try {
      DeidentifyConfig deidentifyConfig = DeidentifyConfig.newBuilder().build();
      InspectConfig inspectConfig = InspectConfig.newBuilder().build();
      List<ContentItem> items = new ArrayList<>();

      client.deidentifyContent(deidentifyConfig, inspectConfig, items);
      Assert.fail("No exception raised");
    } catch (InvalidArgumentException e) {
      // Expected exception
    }
  }

  @Test
  @SuppressWarnings("all")
  public void analyzeDataSourceRiskTest() throws Exception {
    RiskAnalysisOperationResult expectedResponse = RiskAnalysisOperationResult.newBuilder().build();
    Operation resultOperation =
        Operation.newBuilder()
            .setName("analyzeDataSourceRiskTest")
            .setDone(true)
            .setResponse(Any.pack(expectedResponse))
            .build();
    mockDlpService.addResponse(resultOperation);

    PrivacyMetric privacyMetric = PrivacyMetric.newBuilder().build();
    BigQueryTable sourceTable = BigQueryTable.newBuilder().build();

    RiskAnalysisOperationResult actualResponse =
        client.analyzeDataSourceRiskAsync(privacyMetric, sourceTable).get();
    Assert.assertEquals(expectedResponse, actualResponse);

    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();
    Assert.assertEquals(1, actualRequests.size());
    AnalyzeDataSourceRiskRequest actualRequest =
        (AnalyzeDataSourceRiskRequest) actualRequests.get(0);

    Assert.assertEquals(privacyMetric, actualRequest.getPrivacyMetric());
    Assert.assertEquals(sourceTable, actualRequest.getSourceTable());
    Assert.assertTrue(
        channelProvider.isHeaderSent(
            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),
            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));
  }

  @Test
  @SuppressWarnings("all")
  public void analyzeDataSourceRiskExceptionTest() throws Exception {
    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);
    mockDlpService.addException(exception);

    try {
      PrivacyMetric privacyMetric = PrivacyMetric.newBuilder().build();
      BigQueryTable sourceTable = BigQueryTable.newBuilder().build();

      client.analyzeDataSourceRiskAsync(privacyMetric, sourceTable).get();
      Assert.fail("No exception raised");
    } catch (ExecutionException e) {
      Assert.assertEquals(InvalidArgumentException.class, e.getCause().getClass());
      InvalidArgumentException apiException = (InvalidArgumentException) e.getCause();
      Assert.assertEquals(StatusCode.Code.INVALID_ARGUMENT, apiException.getStatusCode().getCode());
    }
  }

  @Test
  @SuppressWarnings("all")
  public void createInspectOperationTest() throws Exception {
    ResultName name2 = ResultName.of("[RESULT]");
    InspectOperationResult expectedResponse =
        InspectOperationResult.newBuilder().setName(name2.toString()).build();
    Operation resultOperation =
        Operation.newBuilder()
            .setName("createInspectOperationTest")
            .setDone(true)
            .setResponse(Any.pack(expectedResponse))
            .build();
    mockDlpService.addResponse(resultOperation);

    String name = "EMAIL_ADDRESS";
    InfoType infoTypesElement = InfoType.newBuilder().setName(name).build();
    List<InfoType> infoTypes = Arrays.asList(infoTypesElement);
    InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();
    String url = "gs://example_bucket/example_file.png";
    CloudStorageOptions.FileSet fileSet =
        CloudStorageOptions.FileSet.newBuilder().setUrl(url).build();
    CloudStorageOptions cloudStorageOptions =
        CloudStorageOptions.newBuilder().setFileSet(fileSet).build();
    StorageConfig storageConfig =
        StorageConfig.newBuilder().setCloudStorageOptions(cloudStorageOptions).build();
    OutputStorageConfig outputConfig = OutputStorageConfig.newBuilder().build();

    InspectOperationResult actualResponse =
        client.createInspectOperationAsync(inspectConfig, storageConfig, outputConfig).get();
    Assert.assertEquals(expectedResponse, actualResponse);

    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();
    Assert.assertEquals(1, actualRequests.size());
    CreateInspectOperationRequest actualRequest =
        (CreateInspectOperationRequest) actualRequests.get(0);

    Assert.assertEquals(inspectConfig, actualRequest.getInspectConfig());
    Assert.assertEquals(storageConfig, actualRequest.getStorageConfig());
    Assert.assertEquals(outputConfig, actualRequest.getOutputConfig());
    Assert.assertTrue(
        channelProvider.isHeaderSent(
            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),
            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));
  }

  @Test
  @SuppressWarnings("all")
  public void createInspectOperationExceptionTest() throws Exception {
    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);
    mockDlpService.addException(exception);

    try {
      String name = "EMAIL_ADDRESS";
      InfoType infoTypesElement = InfoType.newBuilder().setName(name).build();
      List<InfoType> infoTypes = Arrays.asList(infoTypesElement);
      InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();
      String url = "gs://example_bucket/example_file.png";
      CloudStorageOptions.FileSet fileSet =
          CloudStorageOptions.FileSet.newBuilder().setUrl(url).build();
      CloudStorageOptions cloudStorageOptions =
          CloudStorageOptions.newBuilder().setFileSet(fileSet).build();
      StorageConfig storageConfig =
          StorageConfig.newBuilder().setCloudStorageOptions(cloudStorageOptions).build();
      OutputStorageConfig outputConfig = OutputStorageConfig.newBuilder().build();

      client.createInspectOperationAsync(inspectConfig, storageConfig, outputConfig).get();
      Assert.fail("No exception raised");
    } catch (ExecutionException e) {
      Assert.assertEquals(InvalidArgumentException.class, e.getCause().getClass());
      InvalidArgumentException apiException = (InvalidArgumentException) e.getCause();
      Assert.assertEquals(StatusCode.Code.INVALID_ARGUMENT, apiException.getStatusCode().getCode());
    }
  }

  @Test
  @SuppressWarnings("all")
  public void listInspectFindingsTest() {
    String nextPageToken = "nextPageToken-1530815211";
    ListInspectFindingsResponse expectedResponse =
        ListInspectFindingsResponse.newBuilder().setNextPageToken(nextPageToken).build();
    mockDlpService.addResponse(expectedResponse);

    ResultName name = ResultName.of("[RESULT]");

    ListInspectFindingsResponse actualResponse = client.listInspectFindings(name);
    Assert.assertEquals(expectedResponse, actualResponse);

    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();
    Assert.assertEquals(1, actualRequests.size());
    ListInspectFindingsRequest actualRequest = (ListInspectFindingsRequest) actualRequests.get(0);

    Assert.assertEquals(name, ResultName.parse(actualRequest.getName()));
    Assert.assertTrue(
        channelProvider.isHeaderSent(
            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),
            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));
  }

  @Test
  @SuppressWarnings("all")
  public void listInspectFindingsExceptionTest() throws Exception {
    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);
    mockDlpService.addException(exception);

    try {
      ResultName name = ResultName.of("[RESULT]");

      client.listInspectFindings(name);
      Assert.fail("No exception raised");
    } catch (InvalidArgumentException e) {
      // Expected exception
    }
  }

  @Test
  @SuppressWarnings("all")
  public void listInfoTypesTest() {
    ListInfoTypesResponse expectedResponse = ListInfoTypesResponse.newBuilder().build();
    mockDlpService.addResponse(expectedResponse);

    String category = "PII";
    String languageCode = "en";

    ListInfoTypesResponse actualResponse = client.listInfoTypes(category, languageCode);
    Assert.assertEquals(expectedResponse, actualResponse);

    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();
    Assert.assertEquals(1, actualRequests.size());
    ListInfoTypesRequest actualRequest = (ListInfoTypesRequest) actualRequests.get(0);

    Assert.assertEquals(category, actualRequest.getCategory());
    Assert.assertEquals(languageCode, actualRequest.getLanguageCode());
    Assert.assertTrue(
        channelProvider.isHeaderSent(
            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),
            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));
  }

  @Test
  @SuppressWarnings("all")
  public void listInfoTypesExceptionTest() throws Exception {
    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);
    mockDlpService.addException(exception);

    try {
      String category = "PII";
      String languageCode = "en";

      client.listInfoTypes(category, languageCode);
      Assert.fail("No exception raised");
    } catch (InvalidArgumentException e) {
      // Expected exception
    }
  }

  @Test
  @SuppressWarnings("all")
  public void listRootCategoriesTest() {
    ListRootCategoriesResponse expectedResponse = ListRootCategoriesResponse.newBuilder().build();
    mockDlpService.addResponse(expectedResponse);

    String languageCode = "en";

    ListRootCategoriesResponse actualResponse = client.listRootCategories(languageCode);
    Assert.assertEquals(expectedResponse, actualResponse);

    List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();
    Assert.assertEquals(1, actualRequests.size());
    ListRootCategoriesRequest actualRequest = (ListRootCategoriesRequest) actualRequests.get(0);

    Assert.assertEquals(languageCode, actualRequest.getLanguageCode());
    Assert.assertTrue(
        channelProvider.isHeaderSent(
            ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),
            GaxGrpcProperties.getDefaultApiClientHeaderPattern()));
  }

  @Test
  @SuppressWarnings("all")
  public void listRootCategoriesExceptionTest() throws Exception {
    StatusRuntimeException exception = new StatusRuntimeException(Status.INVALID_ARGUMENT);
    mockDlpService.addException(exception);

    try {
      String languageCode = "en";

      client.listRootCategories(languageCode);
      Assert.fail("No exception raised");
    } catch (InvalidArgumentException e) {
      // Expected exception
    }
  }
}
```


Overlapping Code:
```
@javax.annotation.Generated("by GAPIC")
public class DlpServiceClientTest {
private static MockDlpService mockDlpService;
private static MockServiceHelper serviceHelper;
private DlpServiceClient client;
private LocalChannelProvider channelProvider;
@BeforeClass
public static void startStaticServer() {
mockDlpService = new MockDlpService();
serviceHelper =
new MockServiceHelper("in-process-1", Arrays.<MockGrpcService>asList(mockDlpService));
serviceHelper.start();
}
@AfterClass
public static void stopServer() {
serviceHelper.stop();
}
@Before
public void setUp() throws IOException {
serviceHelper.reset();
channelProvider = serviceHelper.createChannelProvider();
DlpServiceSettings settings =
DlpServiceSettings.newBuilder()
.setTransportChannelProvider(channelProvider)
.setCredentialsProvider(NoCredentialsProvider.create())
.build();
client = DlpServiceClient.create(settings);
}
@After
public void tearDown() throws Exception {
client.close();
}
@Test
@SuppressWarnings("all")
public void inspectContentTest() {
InspectContentResponse expectedResponse = InspectContentResponse.newBuilder().build();
mockDlpService.addResponse(expectedResponse);
String name = "EMAIL_ADDRESS";
InfoType infoTypesElement = InfoType.newBuilder().setName(name).build();
List<InfoType> infoTypes = Arrays.asList(infoTypesElement);
InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();
String type = "text/plain";
String value = "My;
ContentItem itemsElement = ContentItem.newBuilder().setType(type).setValue(value).build();
List<ContentItem> items = Arrays.asList(itemsElement);
InspectContentResponse actualResponse = client.inspectContent(inspectConfig, items);
Assert.assertEquals(expectedResponse, actualResponse);
List<GeneratedMessageV3> actualRequests = mockDlpService.getRequests();
Assert.assertEquals(1, actualRequests.size());
InspectContentRequest actualRequest = (InspectContentRequest) actualRequests.get(0);
Assert.assertEquals(inspectConfig, actualRequest.getInspectConfig());
Assert.assertEquals(items, actualRequest.getItemsList());
Assert.assertTrue(
channelProvider.isHeaderSent(
ApiClientHeaderProvider.getDefaultApiClientHeaderKey(),
GaxGrpcProperties.getDefaultApiClientHeaderPat
```
<Overlap Ratio: 0.986283185840708>

---

--- 16 --
Question ID: 2ac66b8b935a5c3f37facf006d3fadd05afd602c
Original Code:
```
public class SaturnThreadFactory implements ThreadFactory {
	private static final AtomicInteger poolNumber = new AtomicInteger(1);
	private AtomicInteger threadNumber = new AtomicInteger(1);
	private boolean isMultiple = true;
	private String threadName;

	public SaturnThreadFactory(String threadName) {
		this.threadName = "Saturn-" + threadName + "-" + poolNumber.getAndIncrement() + "-thread-";
	}

	public SaturnThreadFactory(String threadName, boolean isMultiple) {
		this.isMultiple = isMultiple;
		this.threadName = threadName;
	}

	@Override
	public Thread newThread(Runnable r) {
		String name = isMultiple ? threadName + threadNumber.getAndIncrement() : threadName;
		Thread t = new Thread(r, name);
		if (t.isDaemon()) {
			t.setDaemon(false);
		}
		if (t.getPriority() != Thread.NORM_PRIORITY) {
			t.setPriority(Thread.NORM_PRIORITY);
		}
		return t;
	}
}
```


Overlapping Code:
```
ublic class SaturnThreadFactory implements ThreadFactory {
private static final AtomicInteger poolNumber = new AtomicInteger(1);
private AtomicInteger threadNumber = new AtomicInteger(1);
private boolean isMultiple = true;
private String threadName;
public SaturnThreadFactory(String threadName) {
this.threadName = "Saturn-" + threadName + "-" + poolNumber.getAndIncrement() + "-thread-";
}
public SaturnThreadFactory(String threadName, boolean isMultiple) {
this.isMultiple = isMultiple;
this.threadName = threadName;
}
@Override
public Thread newThread(Runnable r) {
String name = isMultiple ? threadName + threadNumber.getAndIncrement() : threadName;
Thread t = new Thread(r, name);
if (t.isDaemon()) {
t.setDaemon(false);
}
if (t.getPriority() != Thread.NORM_PRIORITY) {
t.setPriority(Thread.NORM_PRIORITY);
}
return t;
}
}
```
<Overlap Ratio: 0.9987937273823885>

---

--- 17 --
Question ID: aec70f0913dc1b41f1d3f19ea64e5929fac5acc8
Original Code:
```
public class DubboConfigBindingsRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware {

    private ConfigurableEnvironment environment;

    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

        AnnotationAttributes attributes = AnnotationAttributes.fromMap(
                importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings.class.getName()));

        AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray("value");

        DubboConfigBindingRegistrar registrar = new DubboConfigBindingRegistrar();
        registrar.setEnvironment(environment);

        for (AnnotationAttributes element : annotationAttributes) {

            registrar.registerBeanDefinitions(element, registry);

        }
    }

    @Override
    public void setEnvironment(Environment environment) {

        Assert.isInstanceOf(ConfigurableEnvironment.class, environment);

        this.environment = (ConfigurableEnvironment) environment;

    }

}
```


Overlapping Code:
```
dingsRegistrar implements ImportBeanDefinitionRegistrar, EnvironmentAware {
private ConfigurableEnvironment environment;
@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
AnnotationAttributes attributes = AnnotationAttributes.fromMap(
importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings.class.getName()));
AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray("value");
DubboConfigBindingRegistrar registrar = new DubboConfigBindingRegistrar();
registrar.setEnvironment(environment);
for (AnnotationAttributes element : annotationAttributes) {
registrar.registerBeanDefinitions(element, registry);
}
}
@Override
public void setEnvironment(Environment environment) {
Assert.isInstanceOf(ConfigurableEnvironment.class, environment);
this.environment = (ConfigurableEnvironment) environment;
}
```
<Overlap Ratio: 0.969017094017094>

---

--- 18 --
Question ID: fc55ef0a40a8c2c9934c98ee2821fcfa89fa2998
Original Code:
```
public class InputHandler extends AbstractTagHandler {

	/**
	 * 
	 */
	public InputHandler() {
		// TODO Auto-generated constructor stub
	}


	//this tag handler just creates the controller/htmlGenerator and returns
	//the original HTML, it acts as a mapping between the internal concept and
	//the provided input name 
	@Override
	public boolean doStartTag(FormEntrySession session, PrintWriter out, Node parent, Node node)
			throws BadFormDesignException {
		try {
		
		FormEntryContext context = session.getContext();
		
		Map<String, String> attrs = getAttributes(node);
		
		InputElement elem = (InputElement)createElement(session, context, attrs, node);
		
		//output
		out.print(elem.generateHtml(context));
		
		//should be self closing
		//context.pushToStack(elem);
		
	}catch(Exception e) {
		throw new IllegalStateException("Exception in InputHandler.doStartTag(): " + ExceptionUtils.getStackTrace(e));
	}

		
		//Returns whether or not to handle the body also. (True = Yes)
		//inputs should have no child elements
		return false;
	}

	@Override
	public void doEndTag(FormEntrySession session, PrintWriter out, Node parent, Node node)
			throws BadFormDesignException {
		
		//inputs are self closing, do nothing
		
	}


	public PassthroughElement createElement(FormEntrySession session, FormEntryContext context, Map<String, String> attrs, Node node) {
		
		InputElement elem = null;
			
		String inputType = attrs.get("type");
		
		
		//HTML specs (inputs default to type text if blank or unknown)
		if(inputType == null || inputType.isEmpty()) {
			inputType = "text";
			attrs.put("type", "text");
		}
		//throw new IllegalArgumentException("input type " + inputType + " type.equals(radio)" + (inputType.equals("radio")?"true":"false") );
		
		FieldsetElement parentFieldset = context.getHighestOnStack(FieldsetElement.class);
		
		if(inputType.equals("radio")) {

			elem = new RadioElement(session, attrs, node, parentFieldset);
			
		} else if (inputType.equals("date")) {
			
			elem = new DateElement(session, attrs, node, parentFieldset);
			
			if( elem.handlesSubmission() ) {
				session.getSubmissionController().addAction(elem);
			}
			
		}else if(inputType.equals("checkbox")) {
			
			elem = new CheckboxElement(session, attrs, node, parentFieldset);
			
			if( elem.handlesSubmission()) {
				session.getSubmissionController().addAction(elem);
			}
		}else if(inputType.equals("number")) {
			
			elem = new NumberInputElement(session, attrs, node);
			session.getSubmissionController().addAction(elem);
			
		}
		//instantiate a new instance of our observation controller adapter
		else {
			elem = new InputElement(session, attrs, node);
			session.getSubmissionController().addAction(elem);
		}
		
		
		return elem;
	}

}
```


Overlapping Code:
```
AbstractTagHandler {
/**
* 
*/
public InputHandler() {
// TODO Auto-generated constructor stub
}
//this tag handler just creates the controller/htmlGenerator and returns
//the original HTML, it acts as a mapping between the internal concept and
//the provided input name 
@Override
public boolean doStartTag(FormEntrySession session, PrintWriter out, Node parent, Node node)
throws BadFormDesignException {
try {

FormEntryContext context = session.getContext();

Map<String, String> attrs = getAttributes(node);

InputElement elem = (InputElement)createElement(session, context, attrs, node);

//output
out.print(elem.generateHtml(context));

//should be self closing
//context.pushToStack(elem);

}catch(Exception e) {
throw new IllegalStateException("Exception in InputHandler.doStartTag(): " + ExceptionUtils.getStackTrace(e));
}

//Returns whether or not to handle the body also. (True = Yes)
//inputs should have no child elements
return false;
}
@Override
public void doEndTag(FormEntrySession session, PrintWriter out, Node parent, Node node)
throws BadFormDesignException {

//inputs are self closing, do nothing

}
public PassthroughElement createElement(FormEntrySession session, FormEntryContext context, Map<String, String> attrs, Node node) {

InputElement elem = null;

String inputType = attrs.get("type");


//HTML specs (inputs default to type text if blank or unknown)
if(inputType == null || inputType.isEmpty()) {
inputType = "text";
attrs.put("type", "text");
}
//throw new IllegalArgumentException("input type " + inputType + " type.equals(radio)" + (inputType.equals("radio")?"true":"false") );

FieldsetElement parentFieldset = context.getHighestOnStack(FieldsetElement.class);

if(inputType.equals("radio")) {
elem = new RadioElement(session, attrs, node, parentFieldset);

} else if (inputType.equals("date")) {

elem = new DateElement(session, attrs, node, parentFieldset);

if( elem.handlesSubmission() ) {
session.getSubmissionController().addAction(elem);
}

}else if(inputType.equals("checkbox")) {

elem = new CheckboxElement(session, attrs, node, parentFieldset);

if( elem.handlesSubmission()) {
session.getSubmissionController().addAction(elem);
}
}else if(inputType.equals("number")) {

elem = new NumberInputElem
```
<Overlap Ratio: 0.9685751183814033>

---

--- 19 --
Question ID: dbd24dbac8536631b57f49df1a29798f80be97ac
Original Code:
```
public class Conversation {
  private final UUID id;
  private final UUID owner;
  private final Instant creation;
  private final String title;
  private List<UUID> conversationUsers = new ArrayList<>();
  private boolean isPublic = true;
  /**
   * Constructs a new Conversation.
   *
   * @param id the ID of this Conversation
   * @param owner the ID of the User who created this Conversation
   * @param title the title of this Conversation
   * @param creation the creation time of this Conversation
   */
  public Conversation(UUID id, UUID owner, String title, Instant creation) {
    this.id = id;
    this.owner = owner;
    this.creation = creation;
    this.title = title;
    this.conversationUsers.add(owner);
  }

  /**
   * Constructs a new Conversation.
   *
   * @param id the ID of this Conversation
   * @param owner the ID of the User who created this Conversation
   * @param title the title of this Conversation
   * @param creation the creation time of this Conversation
   * @param isPublic whether this Conversation is public
   */
  public Conversation(UUID id, UUID owner, String title, Instant creation, boolean isPublic) {
    this.id = id;
    this.owner = owner;
    this.creation = creation;
    this.title = title;
    this.isPublic = isPublic;
    this.conversationUsers.add(owner);
  }

  /** Returns the ID of this Conversation. */
  public UUID getId() {
    return id;
  }

  /** Returns the ID of the User who created this Conversation. */
  public UUID getOwnerId() {
    return owner;
  }

  /** Returns the title of this Conversation. */
  public String getTitle() {
    return title;
  }

  /** Returns the creation time of this Conversation. */
  public Instant getCreationTime() {
    return creation;
  }

  /** Returns the set of users in this Conversation. */
  public List<UUID> getConversationUsers() {
    return conversationUsers;
  }

  /**
   * Returns the set of users in this Conversation as a list of strings indicating the UUID of each
   * user. For use in persistentDataStore
   */
  public List<String> getUserIdsAsStrings() {
    List<String> ids = new ArrayList<>();
    for (UUID user : conversationUsers) {
      ids.add(user.toString());
    }
    return ids;
  }

  /** Adds a user to a conversation */
  public void addUser(UUID user) {
    conversationUsers.add(user);
    PersistentStorageAgent.getInstance().updateConversationEntityUsers(this);
  }

  /** Removes a user from a conversation */
  public void removeUser(UUID user) {
    conversationUsers.remove(user);
    PersistentStorageAgent.getInstance().updateConversationEntityUsers(this);
  }

  /** Updates the list of users from a list of user Ids */
  public void setUsers(List<String> users) {
    List<UUID> newUsers = new ArrayList<>();
    for (String userId : users) {
      UUID id = UUID.fromString(userId);
      newUsers.add(id);
    }
    conversationUsers = newUsers;
  }

  /** Returns true if conversation is public, false, otherwise */
  public boolean getIsPublic() {
    return isPublic;
  }

  /** Sets the privacy status of a conversation */
  public void setIsPublic(boolean isPublic) {
    this.isPublic = isPublic;
  }

  /** Returns true if user has permission to access a conversation, false if otherwise */
  public boolean hasPermission(UUID user) {
    if (isPublic) {
      return true;
    }
    return conversationUsers.contains(user);
  }

  public String getCreationTimeFormatted() {
    LocalDateTime ldt = LocalDateTime.ofInstant(creation, ZoneId.systemDefault());
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yy h:mm:ss a");
    return ldt.format(formatter);
  }
}
```


Overlapping Code:
```
lic class Conversation {
private final UUID id;
private final UUID owner;
private final Instant creation;
private final String title;
private List<UUID> conversationUsers = new ArrayList<>();
private boolean isPublic = true;
/**
* Constructs a new Conversation.
*
* @param id the ID of this Conversation
* @param owner the ID of the User who created this Conversation
* @param title the title of this Conversation
* @param creation the creation time of this Conversation
*/
public Conversation(UUID id, UUID owner, String title, Instant creation) {
this.id = id;
this.owner = owner;
this.creation = creation;
this.title = title;
this.conversationUsers.add(owner);
}
/**
* Constructs a new Conversation.
*
* @param id the ID of this Conversation
* @param owner the ID of the User who created this Conversation
* @param title the title of this Conversation
* @param creation the creation time of this Conversation
* @param isPublic whether this Conversation is public
*/
public Conversation(UUID id, UUID owner, String title, Instant creation, boolean isPublic) {
this.id = id;
this.owner = owner;
this.creation = creation;
this.title = title;
this.isPublic = isPublic;
this.conversationUsers.add(owner);
}
/** Returns the ID of this Conversation. */
public UUID getId() {
return id;
}
/** Returns the ID of the User who created this Conversation. */
public UUID getOwnerId() {
return owner;
}
/** Returns the title of this Conversation. */
public String getTitle() {
return title;
}
/** Returns the creation time of this Conversation. */
public Instant getCreationTime() {
return creation;
}
/** Returns the set of users in this Conversation. */
public List<UUID> getConversationUsers() {
return conversationUsers;
}
/**
* Returns the set of users in this Conversation as a list of strings indicating the UUID of each
* user. For use in persistentDataStore
*/
public List<String> getUserIdsAsStrings() {
List<String> ids = new ArrayList<>();
for (UUID user : conversationUsers) {
ids.add(user.toString());
}
return ids;
}
/** Adds a user to a conversation */
public void addUser(UUID user) {
conversationUsers.add(user);
PersistentStorageAgent.getInstance().updateConversationEntityUsers(this);
}
/** Removes a user from a conversati
```
<Overlap Ratio: 0.9823943661971831>

---

--- 20 --
Question ID: 1df3e8d8b4ee39f5094c91c53daa16ddc62b4284
Original Code:
```
public abstract class AbstractMessageAction extends AbstractAction {

	/**
	 * @param inParam
	 * @return
	 * @throws InvalidParameterException
	 * @throws NoSuchMessageException
	 * @throws APIException
	 */
	protected MessageData getRequestedMessage(ActionParam inParam, StatusMessage inStatus) throws InvalidParameterException, NoSuchMessageException {

		final String messageId = inParam.getMainParamAsString();

		final MessageData message = MessageData.findByAPIId(messageId, inParam.getCaller().getAPIKey(), inStatus);

		if (message == null) {
			throw new NoSuchMessageException(APIErrorMessage.NO_SUCH_MESSAGE);
		}

		return message;
	}

}
```


Overlapping Code:
```
tractMessageAction extends AbstractAction {
/**
* @param inParam
* @return
* @throws InvalidParameterException
* @throws NoSuchMessageException
* @throws APIException
*/
protected MessageData getRequestedMessage(ActionParam inParam, StatusMessage inStatus) throws InvalidParameterException, NoSuchMessageException {
final String messageId = inParam.getMainParamAsString();
final MessageData message = MessageData.findByAPIId(messageId, inParam.getCaller().getAPIKey(), inStatus);
if (message == null) {
throw new NoSuchMessageException(APIErrorMessage.NO_SUCH_MESSAGE);

```
<Overlap Ratio: 0.9253246753246753>

---

--- 21 --
Question ID: 9e11ce42f9ad2d7abf716ef541e0b07f2051435f
Original Code:
```
public class ItemBaseCyclic extends Item {

  public static final String ENERGYTTMAX = "energyttmax";
  public static final String ENERGYTT = "energytt";
  public static final float INACCURACY_DEFAULT = 1.0F;
  public static final float VELOCITY_MAX = 1.5F;
  private boolean hasEnergy;

  public ItemBaseCyclic(Properties properties) {
    super(properties);
    ItemRegistry.ITEMSFIXME.add(this);
  }

  public void setUsesEnergy() {
    this.hasEnergy = true;
  }

  protected void shootMe(Level world, Player shooter, Projectile ball, float pitch, float velocityFactor) {
    if (world.isClientSide) {
      return;
    }
    Vec3 vector3d1 = shooter.getUpVector(1.0F);
    // pitch is degrees so can be -10, +10, etc
    Quaternion quaternion = new Quaternion(new Vector3f(vector3d1), pitch, true);
    Vec3 vector3d = shooter.getViewVector(1.0F);
    Vector3f vector3f = new Vector3f(vector3d);
    vector3f.transform(quaternion);
    ball.shoot(vector3f.x(), vector3f.y(), vector3f.z(), velocityFactor * VELOCITY_MAX, INACCURACY_DEFAULT);
    //    worldIn.playSound(null, player.getPosX(), player.getPosY(), player.getPosZ(),
    //        SoundEvents.ENTITY_ENDER_PEARL_THROW, SoundCategory.NEUTRAL, 0.5F, 0.4F / (random.nextFloat() * 0.4F + 0.8F));
    world.addFreshEntity(ball);
  }

  protected ItemStack findAmmo(Player player, Item item) {
    for (int i = 0; i < player.getInventory().getContainerSize(); ++i) {
      ItemStack itemstack = player.getInventory().getItem(i);
      if (itemstack.getItem() == item) {
        return itemstack;
      }
    }
    return ItemStack.EMPTY;
  }

  public void tryRepairWith(ItemStack stackToRepair, Player player, Item target) {
    if (stackToRepair.isDamaged()) {
      ItemStack torches = this.findAmmo(player, target);
      if (!torches.isEmpty()) {
        torches.shrink(1);
        UtilItemStack.repairItem(stackToRepair);
      }
    }
  }

  public float getChargedPercent(ItemStack stack, int chargeTimer) {
    return BowItem.getPowerForTime(this.getUseDuration(stack) - chargeTimer);
  }

  @Override
  public boolean isBarVisible(ItemStack stack) {
    if (hasEnergy) {
      IEnergyStorage storage = stack.getCapability(CapabilityEnergy.ENERGY, null).orElse(null);
      return storage != null; // && storage.getEnergyStored() > 0;
    }
    return super.isBarVisible(stack);
  }

  @Override
  @OnlyIn(Dist.CLIENT)
  public void appendHoverText(ItemStack stack, Level worldIn, List<Component> tooltip, TooltipFlag flagIn) {
    tooltip.add(new TranslatableComponent(getDescriptionId() + ".tooltip").withStyle(ChatFormatting.GRAY));
    if (this.hasEnergy) {
      int current = 0;
      int energyttmax = 0;
      IEnergyStorage storage = stack.getCapability(CapabilityEnergy.ENERGY, null).orElse(null);
      if (storage != null) {
        current = storage.getEnergyStored();
        energyttmax = storage.getMaxEnergyStored();
        tooltip.add(new TranslatableComponent(current + "/" + energyttmax).withStyle(ChatFormatting.RED));
      }
    }
  }

  @Override
  public int getBarWidth(ItemStack stack) {
    if (hasEnergy) {
      float current = 0;
      float max = 0;
      IEnergyStorage storage = stack.getCapability(CapabilityEnergy.ENERGY, null).orElse(null);
      if (storage != null) {
        current = storage.getEnergyStored();
        max = storage.getMaxEnergyStored();
      }
      return (max == 0) ? 0 : Math.round(13.0F * current / max);
    }
    return super.getBarWidth(stack);
  }

  @OnlyIn(Dist.CLIENT)
  public void registerClient() {}

  @Override
  public ICapabilityProvider initCapabilities(ItemStack stack, CompoundTag nbt) {
    if (this.hasEnergy) {
      return new CapabilityProviderEnergyStack(16000);
    }
    return super.initCapabilities(stack, nbt);
  }

  // ShareTag for server->client capability data sync
  @Override
  public CompoundTag getShareTag(ItemStack stack) {
    if (hasEnergy) {
      CompoundTag nbt = stack.getOrCreateTag();
      IEnergyStorage storage = stack.getCapability(CapabilityEnergy.ENERGY, null).orElse(null);
      //on server  this runs . also has correct values.
      //set data for sync to client
      if (storage != null) {
        nbt.putInt(ENERGYTT, storage.getEnergyStored());
        nbt.putInt(ENERGYTTMAX, storage.getMaxEnergyStored());
      }
      return nbt;
    }
    return super.getShareTag(stack);
  }

  //clientside read tt
  @Override
  public void readShareTag(ItemStack stack, CompoundTag nbt) {
    if (hasEnergy && nbt != null) {
      CompoundTag stackTag = stack.getOrCreateTag();
      stackTag.putInt(ENERGYTT, nbt.getInt(ENERGYTT));
      stackTag.putInt(ENERGYTTMAX, nbt.getInt(ENERGYTTMAX));
    }
    super.readShareTag(stack, nbt);
  }
}
```


Overlapping Code:
```
 ItemBaseCyclic extends Item {
public static final String ENERGYTTMAX = "energyttmax";
public static final String ENERGYTT = "energytt";
public static final float INACCURACY_DEFAULT = 1.0F;
public static final float VELOCITY_MAX = 1.5F;
private boolean hasEnergy;
public ItemBaseCyclic(Properties properties) {
super(properties);
ItemRegistry.ITEMSFIXME.add(this);
}
public void setUsesEnergy() {
this.hasEnergy = true;
}
protected void shootMe(Level world, Player shooter, Projectile ball, float pitch, float velocityFactor) {
if (world.isClientSide) {
return;
}
Vec3 vector3d1 = shooter.getUpVector(1.0F);
// pitch is degrees so can be -10, +10, etc
Quaternion quaternion = new Quaternion(new Vector3f(vector3d1), pitch, true);
Vec3 vector3d = shooter.getViewVector(1.0F);
Vector3f vector3f = new Vector3f(vector3d);
vector3f.transform(quaternion);
ball.shoot(vector3f.x(), vector3f.y(), vector3f.z(), velocityFactor * VELOCITY_MAX, INACCURACY_DEFAULT);
// worldIn.playSound(null, player.getPosX(), player.getPosY(), player.getPosZ(),
// SoundEvents.ENTITY_ENDER_PEARL_THROW, SoundCategory.NEUTRAL, 0.5F, 0.4F / (random.nextFloat() * 0.4F + 0.8F));
world.addFreshEntity(ball);
}
protected ItemStack findAmmo(Player player, Item item) {
for (int i = 0; i < player.getInventory().getContainerSize(); ++i) {
ItemStack itemstack = player.getInventory().getItem(i);
if (itemstack.getItem() == item) {
return itemstack;
}
}
return ItemStack.EMPTY;
}
public void tryRepairWith(ItemStack stackToRepair, Player player, Item target) {
if (stackToRepair.isDamaged()) {
ItemStack torches = this.findAmmo(player, target);
if (!torches.isEmpty()) {
torches.shrink(1);
UtilItemStack.repairItem(stackToRepair);
}
}
}
public float getChargedPercent(ItemStack stack, int chargeTimer) {
return BowItem.getPowerForTime(this.getUseDuration(stack) - chargeTimer);
}
@Override
public boolean isBarVisible(ItemStack stack) {
if (hasEnergy) {
IEnergyStorage storage = stack.getCapability(CapabilityEnergy.ENERGY, null).orElse(null);
return storage != null; // && storage.getEnergyStored() > 0;
}
return super.isBarVisible(stack);
}
@Override
@OnlyIn(Dist.CLIENT)
public void appendHoverText(ItemStack stack, Level worldIn, List<Component> tooltip, TooltipFlag flagIn) {
```
<Overlap Ratio: 0.9946855624446412>

---

--- 22 --
Question ID: cd0d61e49f08e02815678fe85a6ae68ea4725adf
Original Code:
```
public class A_Lower implements Action {
    public static final int LOWERSPEED = FRACUNIT*6;

    @Override
    public void doAction(MapObject mo) {}

    @Override
    public void doAction(Player player, PSprite psp) {
    //    psp.sy += LOWERSPEED;
    //
    //    // Is already down.
    //    if (psp.sy < WEAPONBOTTOM )
    //	return;
    //
    //    // Player is dead.
    //    if (player.playerstate == PST_DEAD)
    //    {
    //	psp.sy = WEAPONBOTTOM;
    //
    //	// don't bring weapon back up
    //	return;		
    //    }
    //    
    //    // The old weapon has been lowered off the screen,
    //    // so change the weapon and start raising it
    //    if (!player.health)
    //    {
    //	// Player is dead, so keep the weapon off screen.
    //	P_SetPsprite (player,  ps_weapon, S_NULL);
    //	return;	
    //    }
    //	
    //    player.readyweapon = player.pendingweapon; 
    //
    //    P_BringUpWeapon (player);
    }
    
}
```


Overlapping Code:
```
ion {
public static final int LOWERSPEED = FRACUNIT*6;
@Override
public void doAction(MapObject mo) {}
@Override
public void doAction(Player player, PSprite psp) {
// psp.sy += LOWERSPEED;
//
// // Is already down.
// if (psp.sy < WEAPONBOTTOM )
// return;
//
// // Player is dead.
// if (player.playerstate == PST_DEAD)
// {
// psp.sy = WEAPONBOTTOM;
//
// // don't bring weapon back up
// return; 
// }
// 
// // The old weapon has been lowered off the screen,
// // so change the weapon and start raising it
// if (!player.health)
// {
// // Player is dead, so keep the weapon off screen.
// P_SetPsprite (player, ps_weapon, S_NULL);
// return; 
// }
// 
// player.readyweapon = player.pendingweap
```
<Overlap Ratio: 0.9020618556701031>

---

--- 23 --
Question ID: 8de92d28783d7456975c97221929990dc767c422
Original Code:
```
public class FilterTools {

    public static SimpleTraceClassifier toSimpleClassifier(ThreadSnapshotFilter rootFilter, Map<String, ThreadSnapshotFilter> subclasses) {
        Classifier cls = new Classifier();
        cls.rootFilter = rootFilter;
        cls.subclasses = new LinkedHashMap<String, ThreadSnapshotFilter>(subclasses);
        return cls;
    }

    public static SimpleTraceClassifier toSimpleClassifier(ThreadSnapshotFilter rootFilter, Map<String, ClassificatorAST.Filter> subclasses, BasicFilterFactory filterFactory) {
        Map<String, ThreadSnapshotFilter> subf = new LinkedHashMap<String, ThreadSnapshotFilter>();
        for(String k: subclasses.keySet()) {
            subf.put(k, filterFactory.build(subclasses.get(k)));
        }
        Classifier cls = new Classifier();
        cls.rootFilter = rootFilter;
        cls.subclasses = subf;
        return cls;
    }

    public static SimpleTraceFilter toSimpleFilter(ThreadSnapshotFilter filter) {
        Filter simpleFilter = new Filter();
        simpleFilter.filter = filter;
        return simpleFilter;
    }
    
    private static class Classifier implements SimpleTraceFilter, SimpleTraceClassifier {

        ThreadSnapshotFilter rootFilter;
        Map<String, ThreadSnapshotFilter> subclasses = new LinkedHashMap<String, ThreadSnapshotFilter>();
        DummyThreadSnapshot dummy = new DummyThreadSnapshot();
        
        @Override
        public String classify(StackFrame[] list) {
            dummy.array = list;
            if (rootFilter != null && !rootFilter.evaluate(dummy)) {
                return null;
            }
            for(String key: subclasses.keySet()) {
                ThreadSnapshotFilter filter = subclasses.get(key);
                if (filter.evaluate(dummy)) {
                    return key;
                }
            }
            return null;
        }

        @Override
        public boolean evaluate(StackFrame[] list) {
            return classify(list) != null;
        }
    }

    private static class Filter implements SimpleTraceFilter {

        ThreadSnapshotFilter filter;
        DummyThreadSnapshot dummy = new DummyThreadSnapshot();
        
        @Override
        public boolean evaluate(StackFrame[] list) {
            dummy.array = list;
            return filter.evaluate(dummy);
        }
    }
    
    private static class DummyThreadSnapshot extends AbstractStackFrameArray implements ThreadSnapshot {

        private StackFrame[] array;
        
        @Override
        protected StackFrame[] array() {
            return array;
        }

        @Override
        protected int from() {
            return 0;
        }

        @Override
        protected int to() {
            return array.length;
        }

        @Override
        public long threadId() {
            return 0;
        }

        @Override
        public String threadName() {
            return null;
        }

        @Override
        public long timestamp() {
            return 0;
        }

        @Override
        public StackFrameList stackTrace() {
            return this;
        }

        @Override
        public State threadState() {
            return null;
        }

        @Override
        public CounterCollection counters() {
            return CounterArray.EMPTY;
        }

        //@Override
        public boolean isEmpty() {
            return depth() == 0;
        }
    }    
}
```


Overlapping Code:
```
aceClassifier toSimpleClassifier(ThreadSnapshotFilter rootFilter, Map<String, ThreadSnapshotFilter> subclasses) {
Classifier cls = new Classifier();
cls.rootFilter = rootFilter;
cls.subclasses = new LinkedHashMap<String, ThreadSnapshotFilter>(subclasses);
return cls;
}
public static SimpleTraceClassifier toSimpleClassifier(ThreadSnapshotFilter rootFilter, Map<String, ClassificatorAST.Filter> subclasses, BasicFilterFactory filterFactory) {
Map<String, ThreadSnapshotFilter> subf = new LinkedHashMap<String, ThreadSnapshotFilter>();
for(String k: subclasses.keySet()) {
subf.put(k, filterFactory.build(subclasses.get(k)));
}
Classifier cls = new Classifier();
cls.rootFilter = rootFilter;
cls.subclasses = subf;
return cls;
}
public static SimpleTraceFilter toSimpleFilter(ThreadSnapshotFilter filter) {
Filter simpleFilter = new Filter();
simpleFilter.filter = filter;
return simpleFilter;
}

private static class Classifier implements SimpleTraceFilter, SimpleTraceClassifier {
ThreadSnapshotFilter rootFilter;
Map<String, ThreadSnapshotFilter> subclasses = new LinkedHashMap<String, ThreadSnapshotFilter>();
DummyThreadSnapshot dummy = new DummyThreadSnapshot();

@Override
public String classify(StackFrame[] list) {
dummy.array = list;
if (rootFilter != null && !rootFilter.evaluate(dummy)) {
return null;
}
for(String key: subclasses.keySet()) {
ThreadSnapshotFilter filter = subclasses.get(key);
if (filter.evaluate(dummy)) {
return key;
}
}
return null;
}
@Override
public boolean evaluate(StackFrame[] list) {
return classify(list) != null;
}
}
private static class Filter implements SimpleTraceFilter {
ThreadSnapshotFilter filter;
DummyThreadSnapshot dummy = new DummyThreadSnapshot();

@Override
public boolean evaluate(StackFrame[] list) {
dummy.array = list;
return filter.evaluate(dummy);
}
}

private static class DummyThreadSnapshot extends AbstractStackFrameArray implements ThreadSnapshot {
private St
```
<Overlap Ratio: 0.9672873678912934>

---

--- 24 --
Question ID: 3e01af8ee1e25334cbecf840bab9b7929ef585ed
Original Code:
```
final class cZ
  implements View.OnClickListener
{
  cZ(SettingWidget paramSettingWidget)
  {
  }

  public final void onClick(View paramView)
  {
    SettingWidget.d(this.a).setSelected(false);
    SettingWidget.e(this.a).setSelected(false);
    SettingWidget.f(this.a).setSelected(true);
    SettingWidget.b(this.a).a(3);
    SettingWidget.g(this.a).a();
  }
}
```


Overlapping Code:
```
ass cZ
implements View.OnClickListener
{
cZ(SettingWidget paramSettingWidget)
{
}
public final void onClick(View paramView)
{
SettingWidget.d(this.a).setSelected(false);
SettingWidget.e(this.a).setSelected(false);
SettingWidget.f(this.a).setSelected(true);
SettingWidget.b(this.a).a(3);
SettingWidget
```
<Overlap Ratio: 0.9174311926605505>

---

--- 25 --
Question ID: 181494bbe3ba258298bdeefa47a65d06d3653636
Original Code:
```
public class BukkitServerProvider implements ServerProvider {
	
	@Override
	public void broadcast(String message) {
		Bukkit.broadcastMessage(message);
	}
	
	@Override
	public void broadcast(String message, String permission) {
		Bukkit.broadcast(message, permission);
	}
	
	@SuppressWarnings("deprecation")
	@Override
	public void scheduleAsync(Runnable r, long tickDelay) {
		Bukkit.getScheduler().scheduleAsyncDelayedTask(ZaniPortalsBukkit.INSTANCE, r, tickDelay);
	}
	
	@Override
	public void scheduleSync(Runnable r, long tickDelay) {
		Bukkit.getScheduler().scheduleSyncDelayedTask(ZaniPortalsBukkit.INSTANCE, r, tickDelay);
	}
	
	@Override
	public PortalWorld getWorld(String name) {
		return new BukkitWorld(Bukkit.getWorld(name));
	}
	
	@SuppressWarnings("deprecation")
	@Override
	public PortalItem getItem(int id) {
		return new BukkitItem(new ItemStack(id));
	}
	
	@Override
	public PortalPlayer getPlayer(UUID uuid) {
		
		Player p = Bukkit.getPlayer(uuid);
		if (p == null) return null;
		
		return new BukkitPortalPlayer(p);
		
	}
	
	@Override
	public PortalPlayer getPlayer(String name) {
		
		Player p = Bukkit.getPlayer(name);
		if (p == null) return null;
		
		return new BukkitPortalPlayer(p);
		
	}

	@Override
	public String getUsername(UUID uuid) {
		return Bukkit.getOfflinePlayer(uuid).getName();
	}
	
}
```


Overlapping Code:
```
erverProvider implements ServerProvider {

@Override
public void broadcast(String message) {
Bukkit.broadcastMessage(message);
}

@Override
public void broadcast(String message, String permission) {
Bukkit.broadcast(message, permission);
}

@SuppressWarnings("deprecation")
@Override
public void scheduleAsync(Runnable r, long tickDelay) {
Bukkit.getScheduler().scheduleAsyncDelayedTask(ZaniPortalsBukkit.INSTANCE, r, tickDelay);
}

@Override
public void scheduleSync(Runnable r, long tickDelay) {
Bukkit.getScheduler().scheduleSyncDelayedTask(ZaniPortalsBukkit.INSTANCE, r, tickDelay);
}

@Override
public PortalWorld getWorld(String name) {
return new BukkitWorld(Bukkit.getWorld(name));
}

@SuppressWarnings("deprecation")
@Override
public PortalItem getItem(int id) {
return new BukkitItem(new ItemStack(id));
}

@Override
public PortalPlayer getPlayer(UUID uuid) {

Player p = Bukkit.getPlayer(uuid);
if (p == null) return null;

return new BukkitPortalPlayer(p);

}

@Override
public PortalPlayer getPlayer(String name) {

Player p = Bukkit.getPlayer(name);
if (p == null) return null;

return new BukkitPortalPlayer(p);

}
@Override
public String getUsername(UUID uuid) {
return Bukkit.getOfflinePlayer(uuid).getName();
```
<Overlap Ratio: 0.9800159872102319>

---

--- 26 --
Question ID: 10020f6a3b0388a9d7f4f25f6cf126f3d1d25c3f
Original Code:
```
public abstract class d
{
  protected static final String ADDRESS = "address";
  protected static final String AUTHOR = "author";
  protected static final String COMMENT = "comment";
  protected static final String CONTENT_TYPE = "contentType";
  protected static final String CUSTOM_FLAG = "customFlag";
  protected static final String EXECUTE_URL = "executeUrl";
  protected static final String EXT_INFO = "extInfo";
  protected static final String FILE_PATH = "filePath";
  protected static final String GROPU_ID = "gropuId";
  protected static final String HIDDEN = "hidden";
  protected static final String IMAGE_ARRAY = "imageArray";
  protected static final String IMAGE_DATA = "imageData";
  protected static final String IMAGE_PATH = "imagePath";
  protected static final String IMAGE_URL = "imageUrl";
  protected static final String INSTALL_URL = "installUrl";
  protected static final String IS_FAMILY = "isFamily";
  protected static final String IS_FRIEND = "isFriend";
  protected static final String IS_PUBLIC = "isPublic";
  protected static final String IS_SHARE_TENCENT_WEIBO = "isShareTencentWeibo";
  protected static final String LATITUDE = "latitude";
  protected static final String LONGITUDE = "longitude";
  protected static final String MUSIC_URL = "musicUrl";
  protected static final String NOTEBOOK = "notebook";
  protected static final String SAFETY_LEVEL = "safetyLevel";
  protected static final String SCENCE = "scene";
  protected static final String SHARE_TYPE = "shareType";
  protected static final String SITE = "site";
  protected static final String SITE_URL = "siteUrl";
  protected static final String STACK = "stack";
  protected static final String TAGS = "tags";
  protected static final String TEXT = "text";
  protected static final String TITLE = "title";
  protected static final String TITLE_URL = "titleUrl";
  protected static final String URL = "url";
  protected static final String VENUE_DESCRIPTION = "venueDescription";
  protected static final String VENUE_NAME = "venueName";
  private HashMap<String, Object> params = new HashMap();

  public d()
  {
  }

  public d(String paramString)
  {
    this(new e().a(paramString));
  }

  public d(HashMap<String, Object> paramHashMap)
  {
    this();
    if (paramHashMap != null)
      this.params.putAll(paramHashMap);
  }

  public <T> T get(String paramString, Class<T> paramClass)
  {
    Object localObject = this.params.get(paramString);
    if (localObject != null)
      return paramClass.cast(localObject);
    if ((Byte.class.equals(paramClass)) || (Byte.TYPE.equals(paramClass)))
      return paramClass.cast(new Byte(0));
    if ((Short.class.equals(paramClass)) || (Short.TYPE.equals(paramClass)))
      return paramClass.cast(new Short(0));
    if ((Integer.class.equals(paramClass)) || (Integer.TYPE.equals(paramClass)))
      return paramClass.cast(new Integer(0));
    if ((Long.class.equals(paramClass)) || (Long.TYPE.equals(paramClass)))
      return paramClass.cast(new Long(0L));
    if ((Float.class.equals(paramClass)) || (Float.TYPE.equals(paramClass)))
      return paramClass.cast(new Float(0.0F));
    if ((Double.class.equals(paramClass)) || (Double.TYPE.equals(paramClass)))
      return paramClass.cast(new Double(0.0D));
    if ((Boolean.class.equals(paramClass)) || (Boolean.TYPE.equals(paramClass)))
      return paramClass.cast(Boolean.valueOf(false));
    return null;
  }

  public String getAddress()
  {
    return (String)get("address", String.class);
  }

  public String getAuthor()
  {
    return (String)get("author", String.class);
  }

  public String getComment()
  {
    return (String)get("comment", String.class);
  }

  public int getContentType()
  {
    return ((Integer)get("contentType", Integer.class)).intValue();
  }

  public String[] getCustomFlag()
  {
    return (String[])get("customFlag", [Ljava.lang.String.class);
  }

  public String getExecuteUrl()
  {
    return (String)get("executeUrl", String.class);
  }

  public String getExtInfo()
  {
    return (String)get("extInfo", String.class);
  }

  public String getFilePath()
  {
    return (String)get("filePath", String.class);
  }

  public String getGroupId()
  {
    return (String)get("gropuId", String.class);
  }

  public int getHidden()
  {
    return ((Integer)get("hidden", Integer.class)).intValue();
  }

  public String[] getImageArray()
  {
    return (String[])get("imageArray", [Ljava.lang.String.class);
  }

  public Bitmap getImageData()
  {
    return (Bitmap)get("imageData", Bitmap.class);
  }

  public String getImagePath()
  {
    return (String)get("imagePath", String.class);
  }

  public String getImageUrl()
  {
    return (String)get("imageUrl", String.class);
  }

  public String getInstallUrl()
  {
    return (String)get("installUrl", String.class);
  }

  public float getLatitude()
  {
    return ((Float)get("latitude", Float.class)).floatValue();
  }

  public float getLongitude()
  {
    return ((Float)get("longitude", Float.class)).floatValue();
  }

  public String getMusicUrl()
  {
    return (String)get("musicUrl", String.class);
  }

  public String getNotebook()
  {
    return (String)get("notebook", String.class);
  }

  public int getSafetyLevel()
  {
    return ((Integer)get("safetyLevel", Integer.class)).intValue();
  }

  public int getScence()
  {
    return ((Integer)get("scene", Integer.class)).intValue();
  }

  public int getShareType()
  {
    return ((Integer)get("shareType", Integer.class)).intValue();
  }

  public String getSite()
  {
    return (String)get("site", String.class);
  }

  public String getSiteUrl()
  {
    return (String)get("siteUrl", String.class);
  }

  public String getStack()
  {
    return (String)get("stack", String.class);
  }

  public String[] getTags()
  {
    return (String[])get("tags", [Ljava.lang.String.class);
  }

  public String getText()
  {
    return (String)get("text", String.class);
  }

  public String getTitle()
  {
    return (String)get("title", String.class);
  }

  public String getTitleUrl()
  {
    return (String)get("titleUrl", String.class);
  }

  public String getUrl()
  {
    return (String)get("url", String.class);
  }

  public String getVenueDescription()
  {
    return (String)get("venueDescription", String.class);
  }

  public String getVenueName()
  {
    return (String)get("venueName", String.class);
  }

  public boolean isFamily()
  {
    return ((Boolean)get("isFamily", Boolean.class)).booleanValue();
  }

  public boolean isFriend()
  {
    return ((Boolean)get("isFriend", Boolean.class)).booleanValue();
  }

  public boolean isPublic()
  {
    return ((Boolean)get("isPublic", Boolean.class)).booleanValue();
  }

  public boolean isShareTencentWeibo()
  {
    return ((Boolean)get("isShareTencentWeibo", Boolean.class)).booleanValue();
  }

  public void set(String paramString, Object paramObject)
  {
    this.params.put(paramString, paramObject);
  }

  public void setAddress(String paramString)
  {
    set("address", paramString);
  }

  public void setAuthor(String paramString)
  {
    set("author", paramString);
  }

  public void setComment(String paramString)
  {
    set("comment", paramString);
  }

  public void setContentType(int paramInt)
  {
    set("contentType", Integer.valueOf(paramInt));
  }

  public void setCustomFlag(String[] paramArrayOfString)
  {
    set("customFlag", paramArrayOfString);
  }

  public void setExecuteUrl()
  {
    set("executeUrl", String.class);
  }

  public void setExtInfo(String paramString)
  {
    set("extInfo", paramString);
  }

  public void setFamily(boolean paramBoolean)
  {
    set("isFamily", Boolean.valueOf(paramBoolean));
  }

  public void setFilePath(String paramString)
  {
    set("filePath", paramString);
  }

  public void setFriend(boolean paramBoolean)
  {
    set("isFriend", Boolean.valueOf(paramBoolean));
  }

  public void setGroupId(String paramString)
  {
    set("gropuId", paramString);
  }

  public void setHidden(int paramInt)
  {
    set("hidden", Integer.valueOf(paramInt));
  }

  public void setImageArray(String[] paramArrayOfString)
  {
    set("imageArray", paramArrayOfString);
  }

  public void setImageData(Bitmap paramBitmap)
  {
    set("imageData", paramBitmap);
  }

  public void setImagePath(String paramString)
  {
    set("imagePath", paramString);
  }

  public void setImageUrl(String paramString)
  {
    set("imageUrl", paramString);
  }

  public void setInstallUrl()
  {
    set("installUrl", String.class);
  }

  public void setLatitude(float paramFloat)
  {
    set("latitude", Float.valueOf(paramFloat));
  }

  public void setLongitude(float paramFloat)
  {
    set("longitude", Float.valueOf(paramFloat));
  }

  public void setMusicUrl(String paramString)
  {
    set("musicUrl", paramString);
  }

  public void setNotebook(String paramString)
  {
    set("notebook", paramString);
  }

  public void setPublic(boolean paramBoolean)
  {
    set("isPublic", Boolean.valueOf(paramBoolean));
  }

  public void setSafetyLevel(int paramInt)
  {
    set("safetyLevel", Integer.valueOf(paramInt));
  }

  public void setScence(int paramInt)
  {
    set("scene", Integer.valueOf(paramInt));
  }

  public void setShareTencentWeibo(boolean paramBoolean)
  {
    set("isShareTencentWeibo", Boolean.valueOf(paramBoolean));
  }

  public void setShareType(int paramInt)
  {
    set("shareType", Integer.valueOf(paramInt));
  }

  public void setSite(String paramString)
  {
    set("site", paramString);
  }

  public void setSiteUrl(String paramString)
  {
    set("siteUrl", paramString);
  }

  public void setStack(String paramString)
  {
    set("stack", paramString);
  }

  public void setTags(String[] paramArrayOfString)
  {
    set("tags", paramArrayOfString);
  }

  public void setText(String paramString)
  {
    set("text", paramString);
  }

  public void setTitle(String paramString)
  {
    set("title", paramString);
  }

  public void setTitleUrl(String paramString)
  {
    set("titleUrl", paramString);
  }

  public void setUrl(String paramString)
  {
    set("url", paramString);
  }

  public void setVenueDescription(String paramString)
  {
    set("venueDescription", paramString);
  }

  public void setVenueName(String paramString)
  {
    set("venueName", paramString);
  }

  public HashMap<String, Object> toMap()
  {
    if (this.params == null)
      return new HashMap();
    return this.params;
  }

  public String toString()
  {
    try
    {
      String str = new e().a(this.params);
      return str;
    }
    catch (Throwable localThrowable)
    {
      cn.sharesdk.framework.utils.d.a().w(localThrowable);
    }
    return null;
  }
}
```


Overlapping Code:
```

protected static final String ADDRESS = "address";
protected static final String AUTHOR = "author";
protected static final String COMMENT = "comment";
protected static final String CONTENT_TYPE = "contentType";
protected static final String CUSTOM_FLAG = "customFlag";
protected static final String EXECUTE_URL = "executeUrl";
protected static final String EXT_INFO = "extInfo";
protected static final String FILE_PATH = "filePath";
protected static final String GROPU_ID = "gropuId";
protected static final String HIDDEN = "hidden";
protected static final String IMAGE_ARRAY = "imageArray";
protected static final String IMAGE_DATA = "imageData";
protected static final String IMAGE_PATH = "imagePath";
protected static final String IMAGE_URL = "imageUrl";
protected static final String INSTALL_URL = "installUrl";
protected static final String IS_FAMILY = "isFamily";
protected static final String IS_FRIEND = "isFriend";
protected static final String IS_PUBLIC = "isPublic";
protected static final String IS_SHARE_TENCENT_WEIBO = "isShareTencentWeibo";
protected static final String LATITUDE = "latitude";
protected static final String LONGITUDE = "longitude";
protected static final String MUSIC_URL = "musicUrl";
protected static final String NOTEBOOK = "notebook";
protected static final String SAFETY_LEVEL = "safetyLevel";
protected static final String SCENCE = "scene";
protected static final String SHARE_TYPE = "shareType";
protected static final String SITE = "site";
protected static final String SITE_URL = "siteUrl";
protected static final String STACK = "stack";
protected static final String TAGS = "tags";
protected static final String TEXT = "text";
protected static final String TITLE = "title";
protected static final String TITLE_URL = "titleUrl";
protected static final String URL = "url";
protected static final String VENUE_DESCRIPTION = "venueDescription";
protected static final String VENUE_NAME = "venueName";
private HashMap<String, Object> params = new HashMap();
public d()
{
}
public d(String paramString)
{
this(new e().a(paramString));
}
public d(HashMap<String, Object> paramHashMap)
{
this();
if (paramHashMap != null)
this.params.putAll(paramHashMap);
}
public <T> T get(String paramString, Class<T> paramClass)
{
Object localObject = this.params.get(paramString);
if (lo
```
<Overlap Ratio: 0.9759188846641318>

---

--- 27 --
Question ID: 1127bb6f5e9d7f7dfc2d09c1605febc452887c57
Original Code:
```
public class KubernetesResponseComposer implements ResponseComposer {

  @Override
  public String compose(Collection<String> collection) {
    List<HasMetadata> items = new ArrayList<>();
    for (String item : collection) {
      try (InputStream stream = new ByteArrayInputStream(item.getBytes(StandardCharsets.UTF_8.name()))) {
        HasMetadata h = Serialization.unmarshal(stream);
        items.add(h);
      } catch (Exception e) {
        throw KubernetesClientException.launderThrowable(e);
      }
    }
    KubernetesList list = new KubernetesListBuilder().withItems(items).build();
    return Serialization.asJson(list);
  }
}
```


Overlapping Code:
```
oser implements ResponseComposer {
@Override
public String compose(Collection<String> collection) {
List<HasMetadata> items = new ArrayList<>();
for (String item : collection) {
try (InputStream stream = new ByteArrayInputStream(item.getBytes(StandardCharsets.UTF_8.name()))) {
HasMetadata h = Serialization.unmarshal(stream);
items.add(h);
} catch (Exception e) {
throw KubernetesClientException.launderThrowable(e);
}
}
KubernetesList list = new KubernetesListBuilder().withItems(items).build();
re
```
<Overlap Ratio: 0.8756567425569177>

---

--- 28 --
Question ID: 26d3e04e94977bd658535c0ae3e8a40dd48604cc
Original Code:
```
public class EventStore {

  /** Singleton instance of EventStore. */
  private static EventStore instance;

  /**
   * Returns the singleton instance of EventStore that should be shared between all servlet classes.
   * Do not call this function from a test; use getTestInstance() instead.
   */
  public static EventStore getInstance() {
    if (instance == null) {
      instance = new EventStore(PersistentStorageAgent.getInstance());
    }
    return instance;
  }

  /**
   * Instance getter function used for testing. Supply a mock for PersistentStorageAgent.
   *
   * @param persistentStorageAgent a mock used for testing
   */
  public static EventStore getTestInstance(PersistentStorageAgent persistentStorageAgent) {
    return new EventStore(persistentStorageAgent);
  }

  /**
   * The PersistentStorageAgent responsible for loading Events from and saving Events to Datastore.
   */
  private PersistentStorageAgent persistentStorageAgent;

  /** The in-memory list of Events. */
  private List<Event> events;

  /** This class is a singleton, so its constructor is private. Call getInstance() instead. */
  private EventStore(PersistentStorageAgent persistentStorageAgent) {
    this.persistentStorageAgent = persistentStorageAgent;
    events = new ArrayList<>();
  }

  /** Access the current set of users known to the application. */
  public List<Event> getAllEvents() {
    return events;
  }

  /**
   * Access the Event object with the given UUID.
   *
   * @return null if the UUID does not match any existing Event.
   */
  public Event getEvent(UUID id) {
    for (Event event : events) {
      if (event.getId().equals(id)) {
        return event;
      }
    }
    return null;
  }

  /**
   * Add a new event to the current set of events known to the application. This should only be called
   * to add a new event, not to update an existing event.
   */
  public void addEvent(Event event) {
    events.add(event);
    persistentStorageAgent.writeThrough(event);
  }

  /**
   * Sets the List of Events stored by this EventStore. This should only be called once, when the data
   * is loaded from Datastore.
   */
  public void setEvents(List<Event> events) {
    this.events = events;
  }

  public List<Event> getEventsSince(Instant lastSeen){
    List<Event> eventsToShow = new ArrayList<Event>();
        for (Event event: events){
          Instant eventCreationTime = event.getCreationTime();
          if(eventCreationTime.isAfter(lastSeen)){
            eventsToShow.add(event);
          }
        }
        return eventsToShow;
  }

}
```


Overlapping Code:
```
EventStore {
/** Singleton instance of EventStore. */
private static EventStore instance;
/**
* Returns the singleton instance of EventStore that should be shared between all servlet classes.
* Do not call this function from a test; use getTestInstance() instead.
*/
public static EventStore getInstance() {
if (instance == null) {
instance = new EventStore(PersistentStorageAgent.getInstance());
}
return instance;
}
/**
* Instance getter function used for testing. Supply a mock for PersistentStorageAgent.
*
* @param persistentStorageAgent a mock used for testing
*/
public static EventStore getTestInstance(PersistentStorageAgent persistentStorageAgent) {
return new EventStore(persistentStorageAgent);
}
/**
* The PersistentStorageAgent responsible for loading Events from and saving Events to Datastore.
*/
private PersistentStorageAgent persistentStorageAgent;
/** The in-memory list of Events. */
private List<Event> events;
/** This class is a singleton, so its constructor is private. Call getInstance() instead. */
private EventStore(PersistentStorageAgent persistentStorageAgent) {
this.persistentStorageAgent = persistentStorageAgent;
events = new ArrayList<>();
}
/** Access the current set of users known to the application. */
public List<Event> getAllEvents() {
return events;
}
/**
* Access the Event object with the given UUID.
*
* @return null if the UUID does not match any existing Event.
*/
public Event getEvent(UUID id) {
for (Event event : events) {
if (event.getId().equals(id)) {
return event;
}
}
return null;
}
/**
* Add a new event to the current set of events known to the application. This should only be called
* to add a new event, not to update an existing event.
*/
public void addEvent(Event event) {
events.add(event);
persistentStorageAgent.writeThrough(event);
}
/**
* Sets the List of Events stored by this EventStore. This should only be called once, when the data
* is loaded from Datastore.
*/
public void setEvents(List<Event> events) {
this.events = events;
}
public List<Event> getEventsSince(Instant lastSeen){
List<Event> eventsToShow = new ArrayList<Event>();
for (Event event: events){
Instant eventCreationTime = event.getCreationTime();
if(eventC
```
<Overlap Ratio: 0.9764758100310696>

---

--- 29 --
Question ID: 335c1e6d0f4454939550f571c6304e34f1650ef9
Original Code:
```
public class Character {
    public enum CASE {
        lower,
        upper
    }

    public enum SYMBOL {
        a, b, c, d, e,
        f, g, h, i, j,
        k, l, m, n, o,
        p, q, r, s, t,
        u, v, w, x, y, z
    }

    public class Coordinate {
        public final double x;
        public final double y;

        Coordinate(double x, double y) {
            this.x = x;
            this.y = y;
        }
    }

    

    public Character() {

    }

    public Character(SYMBOL symbol, CASE charCase) {
        this.mSymbol = symbol;
        this.mCase = charCase;

        this.mOutline = new ArrayList<List<Coordinate>>();
    }

    public void clear() {
        this.mOutline = new ArrayList<List<Coordinate>>();
        this.mCurrentContour = null;
    }

    public void save(String fileName) throws ParserConfigurationException, TransformerException {

        //Create DOM document creator
        DocumentBuilderFactory documentFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder  documentBuilder =  documentFactory.newDocumentBuilder();
        Document document = documentBuilder.newDocument();

        //Create root element
        Element root =  document.createElement("glyph");

        //create root attribute
        Attr attr = document.createAttribute("name");
        attr.setValue(mSymbol.toString());
        root.setAttributeNode(attr);

        attr = document.createAttribute("format");
        attr.setValue("2");
        root.setAttributeNode(attr);

        //create advance element
        Element advance = document.createElement("advance");

        // set width attribute
        attr = document.createAttribute("width");
        attr.setValue("268");
        advance.setAttributeNode(attr);

        // set height attribute
        attr = document.createAttribute("height");
        attr.setValue("268");
        advance.setAttributeNode(attr);

        // append advance to root
        root.appendChild(advance);

        //create unicode element
        Element unicode = document.createElement("unicode");

        // Create hexcode element
        String charCode;

        if(mCase == CASE.upper) {
            charCode = mSymbol.toString().toUpperCase();

        } else {
            charCode = mSymbol.toString().toLowerCase();
        }

        int charCodeInt = (int)charCode.charAt(0);


        attr = document.createAttribute("hex");

        attr.setValue("00" + Integer.toHexString(charCodeInt));
        unicode.setAttributeNode(attr);

        root.appendChild(unicode);

        // create outline
        Element outline = document.createElement("outline");

        // for contour in outline
        for (List<Coordinate> contour : mOutline) {
            //Create contour element
            Element contourElement = document.createElement("contour");

            int i = 0;

            //For each point in the contour
            for (Coordinate point : contour) {
                //Create points
                Element pointElement = document.createElement("point");

                //Set x coordinate
                attr = document.createAttribute("x");
                attr.setValue(Double.toString(
                        point.x
                ));
                pointElement.setAttributeNode(attr);

                //Set y coordinate
                attr = document.createAttribute("y");
                attr.setValue(Double.toString(
                        350 - point.y
                ));
                pointElement.setAttributeNode(attr);

                //Set type
                attr = document.createAttribute("type");

//                if (i == 0) {
//                    attr.setValue("move");
//
//                } else {
//                    attr.setValue("line");
//                }

                attr.setValue("line");


                pointElement.setAttributeNode(attr);

                // append point to contour
                contourElement.appendChild(pointElement);

                i++;
            }

            // append contour to outline
            outline.appendChild(contourElement);
        }

        // appent outline to root
        root.appendChild(outline);

        // append root to document
        document.appendChild(root);

        // create transformer
        Transformer transformer = TransformerFactory.newInstance().newTransformer();

        //Set to indent for more legible output
        transformer.setOutputProperty(OutputKeys.INDENT, "yes");

        // create output stream to file
        Result output = new StreamResult(new File(fileName));

        // create input source
        Source input = new DOMSource(document);

        // transform document to file
        transformer.transform(input, output);
    }

    public static Character load(String fileName, SYMBOL symbol, CASE charCase) throws ParserConfigurationException, IOException, SAXException {
        Character character = new Character(symbol, charCase);

        // grab file stream
        File inputFile = new File(fileName);

        // check if file exists and is valid
        if(inputFile.exists() && !inputFile.isDirectory())
        {
            // create document builder
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            Document doc = dBuilder.parse(inputFile);
            doc.getDocumentElement().normalize();

            Element contourElement;
            NodeList contours;

            //Go through the points
            contours = doc.getElementsByTagName("contour");

            //For each contour
            for (int i = 0; i < contours.getLength(); i++)
            {

                //Get the contour
                character.openContour(); //Make new contour
                Node contourNode = contours.item(i);

                if (contourNode.getNodeType() == Node.ELEMENT_NODE)
                {

                    contourElement = (Element) contourNode;

                    //Get list of point elements from the contour
                    NodeList points = contourElement.getElementsByTagName("point");

                    for (int pointIndex = 0; pointIndex < points.getLength(); pointIndex++)
                    {
                        Node pointNode = points.item(pointIndex);

                        if (pointNode.getNodeType() == pointNode.ELEMENT_NODE) {
                            Element pointElement = (Element) pointNode;

                            // get point coordinates
                            double x = Double.parseDouble(pointElement.getAttribute("x"));
                            double y = Double.parseDouble(pointElement.getAttribute("y"));

                            // add point to character
                            character.addPoint(x, 350 - y);
                        }
                    }

                    // End of contour
                    character.closeContour();
                }
            }
        }

        // use openContour(), addPoint(), and closeContour()
        // to update the character with the loaded points

        return character;
    }

    public void openContour(double x, double y) {
        mCurrentContour = new ArrayList<Coordinate>();
        this.addPoint(x, y);
    }

    private void openContour()
    {
        mCurrentContour = new ArrayList<Coordinate>();
    }

    public void addPoint(double x, double y) {
        mCurrentContour.add(new Coordinate(x, y));
    }

    public void closeContour(double x, double y) {
        addPoint(x, y);
        mOutline.add(mCurrentContour);
    }

    private void closeContour()
    {
        mOutline.add(mCurrentContour);
    }

    public List<List<Coordinate>> getOutline() {
        return mOutline;
    }

    private SYMBOL mSymbol;
    private CASE mCase;
    private List<Coordinate> mCurrentContour;
    private List<List<Coordinate>> mOutline;
}
```


Overlapping Code:
```
haracter {
public enum CASE {
lower,
upper
}
public enum SYMBOL {
a, b, c, d, e,
f, g, h, i, j,
k, l, m, n, o,
p, q, r, s, t,
u, v, w, x, y, z
}
public class Coordinate {
public final double x;
public final double y;
Coordinate(double x, double y) {
this.x = x;
this.y = y;
}
}

public Character() {
}
public Character(SYMBOL symbol, CASE charCase) {
this.mSymbol = symbol;
this.mCase = charCase;
this.mOutline = new ArrayList<List<Coordinate>>();
}
public void clear() {
this.mOutline = new ArrayList<List<Coordinate>>();
this.mCurrentContour = null;
}
public void save(String fileName) throws ParserConfigurationException, TransformerException {
//Create DOM document creator
DocumentBuilderFactory documentFactory = DocumentBuilderFactory.newInstance();
DocumentBuilder documentBuilder = documentFactory.newDocumentBuilder();
Document document = documentBuilder.newDocument();
//Create root element
Element root = document.createElement("glyph");
//create root attribute
Attr attr = document.createAttribute("name");
attr.setValue(mSymbol.toString());
root.setAttributeNode(attr);
attr = document.createAttribute("format");
attr.setValue("2");
root.setAttributeNode(attr);
//create advance element
Element advance = document.createElement("advance");
// set width attribute
attr = document.createAttribute("width");
attr.setValue("268");
advance.setAttributeNode(attr);
// set height attribute
attr = document.createAttribute("height");
attr.setValue("268");
advance.setAttributeNode(attr);
// append advance to root
root.appendChild(advance);
//create unicode element
Element unicode = document.createElement("unicode");
// Create hexcode element
String charCode;
if(mCase == CASE.upper) {
charCode = mSymbol.toString().toUpperCase();
} else {
charCode = mSymbol.toString().toLowerCase();
}
int charCodeInt = (int)charCode.charAt(0);
attr = document.createAttribute("hex");
attr.setValue("00" + I
```
<Overlap Ratio: 0.9743589743589743>

---

--- 30 --
Question ID: 25a07b0e9ef067f335827cb82f7451f3289faefd
Original Code:
```
public class CMDLog implements CommandExecutor {

	@Override
	public CommandResult execute(CommandSource src, CommandContext args) throws CommandException {
		if (!args.hasAny("true|false")) {
			Help help = Help.get("sban log").get();
			throw new CommandException(Text.builder().onClick(TextActions.executeCallback(help.execute())).append(help.getUsageText()).build(), false);
		}
		boolean value = args.<Boolean>getOne("true|false").get();

		ConfigManager configManager = ConfigManager.get(Main.getPlugin());

		configManager.getConfig().getNode("console_log").setValue(value);
		configManager.save();

		src.sendMessage(Text.of(TextColors.GREEN, "Set ban logging to ", value));

		return CommandResult.success();
	}

}
```


Overlapping Code:
```
 implements CommandExecutor {
@Override
public CommandResult execute(CommandSource src, CommandContext args) throws CommandException {
if (!args.hasAny("true|false")) {
Help help = Help.get("sban log").get();
throw new CommandException(Text.builder().onClick(TextActions.executeCallback(help.execute())).append(help.getUsageText()).build(), false);
}
boolean value = args.<Boolean>getOne("true|false").get();
ConfigManager configManager = ConfigManager.get(Main.getPlugin());
configManager.getConfig().getNode("console_log").setValue(value);
configManager.save();
src.sendMessage(Text.of(TextColors.GREEN, "Set ban logging to ", value));
return CommandResult.success();
}
```
<Overlap Ratio: 0.9696531791907514>

---

--- 31 --
Question ID: 30fb1f555589dc920e3a5c9ea7000387ab1ca324
Original Code:
```
public class IperfUtils {

    private static final String Iperf_TAG = "Iperf";

    /**
     * create iperf binary from raw to data directory
     * and change its attribute to be executed
     *
     * @param context context
     */
    public static void createIperf(Context context) {
        try {
            InputStream is = context.getResources().openRawResource(R.raw.iperf3);
            FileOutputStream fos = context.openFileOutput("iperf3", Context.MODE_PRIVATE);

            int len;
            byte[] buf = new byte[1024];
            while ((len = is.read(buf)) > 0) {
                fos.write(buf, 0, len);
            }

            is.close();
            fos.close();

            Runtime.getRuntime().exec(
                    new String[]{
                            "chmod",
                            "755",
                            context.getFilesDir().getAbsolutePath() + File.separator + "iperf3"});

        } catch (Exception e) {
            Log.e(Iperf_TAG, "Exception in creating iperf, error message = " + e.getMessage());
        }
    }

    /**
     * run iperf command and collect the output string for usage
     *
     * @param context      context
     * @param iperfOptions iperf options
     * @return iperf output, if ok return the normal result, if contains error return null
     */
    public static IperfResult runIperf(Context context, IperfOptions iperfOptions) {
        IperfResult iperfResult = new IperfResult();
        iperfResult.setResultType(IperfResultType.RIGHT);

        String str = "";

        try {
            //Process process = Runtime.getRuntime().exec(
            // new String[] {
            //"su",
            //"-c",
            //context.getFilesDir().getAbsolutePath() + File.separator + "iperf3 "
            // + iperfOptions.toString()});
            Process process = Runtime.getRuntime().exec(context.getFilesDir().getAbsolutePath() + File.separator + "iperf3 "
                    + iperfOptions.toString());

            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));

            String line;
            while ((line = br.readLine()) != null) {
                str += line;
            }

            br.close();

            // waits for the command to finish
            process.waitFor();

            // if output contains error, the returned result is error message
            if (str.equals("")) {
                iperfResult.setResultType(IperfResultType.IS_NULL);
            } else if (!str.equals("") && str.contains("error")) {
                iperfResult.setResultType(IperfResultType.GET_ERROR);
            }

        } catch (IOException e) {
            Log.e(Iperf_TAG, "Error running iperf, error msg = " + e.getMessage());
            str = e.getMessage();
            iperfResult.setResultType(IperfResultType.GET_EXCEPTION);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        iperfResult.setResult(str);

        return iperfResult;
    }

    /**
     * find the pid of iperf by using and parsing the ps command output
     *
     * @return pid of iperf
     */
    public static String getIperfPID() {
        String pid = null;

        try {
            // run ps to get the process list
            Process process = Runtime.getRuntime().exec("ps");
            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));

            // find the pid column, for it varies with different versions of ps
            int pidColumn = 0;
            int i = 0;
            String line;

            // split first line by regular expression, which matches one or many whitespaces
            line = br.readLine();
            String[] columnNames = line.split("\\s+");
            for (String col : columnNames) {
                if (col.equalsIgnoreCase("PID")) {
                    pidColumn = i;
                    break;
                }
                i++;
            }

            // parse process list to find iperf entry
            while ((line = br.readLine()) != null) {
                if (line.contains("iperf3") && line.contains("cn.dizhangcs.crowdsignal.bandwidthtester")
                        && !line.contains("sh -c")) {

                    // split the line by white space
                    String strs[] = line.split("\\s+");
                    pid = strs[pidColumn];
                    break;
                }
            }

            br.close();

        } catch (IOException ie) {
            Log.e(Iperf_TAG, "Error getting tcpdump pid, error msg = " + ie.getMessage());
        }

        return pid;
    }

    /**
     * Check to see if iperf is running
     *
     * @return whether iperf is running
     */
    public static boolean isIperfRunning() {
        return getIperfPID() != null;
    }

    public static void stopIperf() {
        try {
            String pid = getIperfPID();

            // iperf is not running
            if (pid == null) {
                return;
            }

            Process process = Runtime.getRuntime().exec(new String[]{"su", "-c", "kill " + pid});
            BufferedReader br = new BufferedReader(new InputStreamReader(process.getErrorStream()));

            //check errors
            String line;
            while ((line = br.readLine()) != null) {
                Log.e(Iperf_TAG, "kill tcpdump error, error msg = " + line);
            }

            br.close();

        } catch (IOException e) {
            Log.e(Iperf_TAG, "kill iperf error, error msg = " + e.getMessage());
        }
    }
}
```


Overlapping Code:
```
 static final String Iperf_TAG = "Iperf";
/**
* create iperf binary from raw to data directory
* and change its attribute to be executed
*
* @param context context
*/
public static void createIperf(Context context) {
try {
InputStream is = context.getResources().openRawResource(R.raw.iperf3);
FileOutputStream fos = context.openFileOutput("iperf3", Context.MODE_PRIVATE);
int len;
byte[] buf = new byte[1024];
while ((len = is.read(buf)) > 0) {
fos.write(buf, 0, len);
}
is.close();
fos.close();
Runtime.getRuntime().exec(
new String[]{
"chmod",
"755",
context.getFilesDir().getAbsolutePath() + File.separator + "iperf3"});
} catch (Exception e) {
Log.e(Iperf_TAG, "Exception in creating iperf, error message = " + e.getMessage());
}
}
/**
* run iperf command and collect the output string for usage
*
* @param context context
* @param iperfOptions iperf options
* @return iperf output, if ok return the normal result, if contains error return null
*/
public static IperfResult runIperf(Context context, IperfOptions iperfOptions) {
IperfResult iperfResult = new IperfResult();
iperfResult.setResultType(IperfResultType.RIGHT);
String str = "";
try {
//Process process = Runtime.getRuntime().exec(
// new String[] {
//"su",
//"-c",
//context.getFilesDir().getAbsolutePath() + File.separator + "iperf3 "
// + iperfOptions.toString()});
Process process = Runtime.getRuntime().exec(context.getFilesDir().getAbsolutePath() + File.separator + "iperf3 "
+ iperfOptions.toString());
BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));
String line;
while ((line = br.readLine()) != null) {
str += line;
}
br.close();
// waits for the command to finish
process.waitFor();
// if output contains error, the returned result is error message
if (str.equals("")) {
iperfResult
```
<Overlap Ratio: 0.9672219236969372>

---

--- 32 --
Question ID: 865b5199ce355f47e8ff094868c884548a839a3c
Original Code:
```
public class AssignmentStatement extends Statement implements OutputWriter,
                                                              Optimize
{
	//~ Instance fields --------------------------------------------------------

	// data members

	/*
	 * An LvalExpression which is the LHS of the assignment.
	 */
	private LvalExpression lhs;

	/*
	 * An OperationExpression which is the RHS of the assignment expression.
	 */
	private OperationExpression rhs;

	/*
	 * The line number of this assignment statement in the output circuit.
	 * This number may vary form one transformation to another.
	 */
	private int outputLine = -1;

	//~ Constructors -----------------------------------------------------------

	/**
	 * Constructs a new AssignmentStatement from a given lhs and rhs.
	 * @param lhs An LvalExpression which is the LHS of the assignment.
	 * @param rhs An OperationExpression which is the RHS of the assignment
	 * expression.
	 */
	public AssignmentStatement(LvalExpression lhs, OperationExpression rhs) {
		this.lhs     = lhs;
		this.rhs     = rhs;
		this.lhs.setAssigningStatement(this);
	}

	//~ Methods ----------------------------------------------------------------

	/**
	 * Transforms this multibit AssignmentStatement into singlebit Statements
	 * and returns a BlockStatement containing the result.
	 * @param obj not used (null).
	 * @return BlockStatement containing singlebit Statements
	 *                 of this AssignmentStatement.
	 */
	public BlockStatement multi2SingleBit(Object obj) {
		return ((Multi2SingleBit) rhs).multi2SingleBit(this);
	}

	/**
	 * Returns a string representation of this AssignmentStatement.
	 * @return a string representation of this AssignmentStatement.
	 */
	public String toString() {
		return lhs.toString() + '=' + rhs.toString() + "\n";
	}

	/**
	 * Returns this AssignmentStatement's rhs.
	 * @return this AssignmentStatement's rhs.
	 */
	public OperationExpression getRHS() {
		return rhs;
	}

	/**
	 * Returns this AssignmentStatement's lhs.
	 * @return this AssignmentStatement's lhs.
	 */
	public LvalExpression getLHS() {
		return lhs;
	}

	/**
	 * Prints this AssignmentStatement into the circuit.
	 * @param circuit the circuit output file.
	 */
	public void toCircuit(PrintWriter circuit) {
		outputLine = Program.getLineNumber();

		circuit.print(outputLine + " " + ((lhs.isOutput()) ? "output " : ""));
		((OutputWriter) rhs).toCircuit(circuit);
		circuit.println(((lhs.isOutput()) ? ("\t//" + lhs.getName()) : ""));
	}

	/**
	 * Returns an int that represents the line number of this
	 * assignmnet statement in the output circuit.
	 * @return an int that represents the line number of this
	 * assignmnet statement in the output circuit.
	 */
	public int getOutputLine() {
		return outputLine;
	}

	/**
	 * Sets the output line of this assignment statement.
	 * @param line the line number in the output.
	 */
	public void setOutputLine(int line) {
		outputLine = line;
	}

	/**
	 * Optimizes this AssignmentStatement (Phase I): <br>
	 *
	 * Peephole optimization: local simplifications of code, e.g.
	 * (x and true --&gt; x), (x or not x --&gt; true), etc. <br>
	 * Duplicate code removal: a hash table of all values computed in the
	 * circuit is kept. If some value is computed twice, then one of the
	 * duplicates is removed and replaced with direct access to the other
	 * wire.<br>
	 * For more information see documation files.
	 *
	 */
	public void optimizePhaseI() {
		// the statement have to have an output line inorder to be able to sort 
		// input pins and refer to the output gate.
		// NOTE that this assignment of outputLine may not be the final one 
		//  (refer to the optimization phase II and circuit writing).
		// 
		outputLine = Program.getLineNumber();

		boolean statementChanged = true;

		do {
			// tracks if there where changes is this AssignmentStatment
			if (rhs.hasUnaryInput()) // if (this has unary exp as input)
			 {
				rhs.combineUnaryInput();
			} else if (rhs.hasSharedInput()) {
				rhs = rhs.combineSharedInput();
			}
			// NOTE:
			// the following two trasformations can reduce the rhs's arity.
			else if (((OperationExpression) rhs).hasConstantInput())
			//if (this has constant input)
			 {
				//combine the input into the gate;
				rhs = rhs.combineConstInput();
			} else if (rhs.hasEqualInputs()) {
				//combine equal inputs into one.
				rhs = rhs.combineEqualInputs();
			} else {
				statementChanged = false;
			}
		} while (statementChanged); //while (there are changes 
		                            //in this AssignmentStatmenet);

		if (rhs.isComplexIDOrNeg()) {
			rhs = rhs.simplify();
		}

		if (rhs.isConstant()) { // if the optimized 
			                    // gate returns a constant result
			rhs = rhs.getConstantOutput();
		}

		rhs.sortInputs();

		if (Optimizer.containsGateNegGate(rhs)) {
			rhs = Optimizer.getReference(rhs);
		} else {
			Optimizer.addGate(rhs, lhs);
		}
	}

	/**
	 * Second phase of the optimization: Dead code elimination.
	 * This statement adds to the new function-body, only if
	 * it is relevant the computation of the output
	 * pins of the circuit ( acording to a list of the needed statements that
	 * was assembled in earlier stage ).
	 * @param newBody the new function-body.
	 */
	public void optimizePhaseII(Vector newBody) {
		if (Optimizer.isUsed(this)) {
			newBody.add(this);
		}
	}

	/**
	 * Adds this AssignmentStatement to the list of statements that are
	 * needed to compute the output pins of the output circuit, if this
	 * AssigmentStatement IS indeed needed. The list is stored in
	 * Optimizer data structure.
	 */
	public void buildUsedStatementsHash() {
		if (lhs.isOutput()) {
			Optimizer.putUsedStatement(this);
		}

		if (Optimizer.isUsed(this)) {
			Vector v = rhs.getLvalExpressionInputs();

			for (int i = 0; i < v.size(); i++) {
				Statement as =
					((LvalExpression) (v.elementAt(i))).getAssigningStatement();
				Optimizer.putUsedStatement(as);
			}
		}
	}

	/**
	 * Unique vars transformations.
	 */
	public Statement uniqueVars() {
		rhs.changeReference(Function.getVars());

		// get the last referance existing
		lhs = Function.getVar(lhs);

		if (lhs.getAssigningStatement() != this) {
			Function.addVar(lhs); //.getName(), lhs.getType(), lhs.isOutput());

			// get the new ref to lhs
			lhs = Function.getVar(lhs);

			lhs.setAssigningStatement(this);
		}

		return this;
	}

	/**
	 * Returns true iff rhs if an UnaryOpExpression.
	 * @return true iff rhs if an UnaryOpExpression.
	 */
	public boolean hasUnaryOperator() {
		return rhs instanceof UnaryOpExpression;
	}

	/**
	 * Returns a replica this statement.
	 * @return a replica this statement.
	 */
	public Statement duplicate() {
		return new AssignmentStatement(lhs /*.duplicate() no need*/,
		                               (OperationExpression) rhs.duplicate());
	}
}
```


Overlapping Code:
```
ublic class AssignmentStatement extends Statement implements OutputWriter,
Optimize
{
//~ Instance fields --------------------------------------------------------
// data members
/*
* An LvalExpression which is the LHS of the assignment.
*/
private LvalExpression lhs;
/*
* An OperationExpression which is the RHS of the assignment expression.
*/
private OperationExpression rhs;
/*
* The line number of this assignment statement in the output circuit.
* This number may vary form one transformation to another.
*/
private int outputLine = -1;
//~ Constructors -----------------------------------------------------------
/**
* Constructs a new AssignmentStatement from a given lhs and rhs.
* @param lhs An LvalExpression which is the LHS of the assignment.
* @param rhs An OperationExpression which is the RHS of the assignment
* expression.
*/
public AssignmentStatement(LvalExpression lhs, OperationExpression rhs) {
this.lhs = lhs;
this.rhs = rhs;
this.lhs.setAssigningStatement(this);
}
//~ Methods ----------------------------------------------------------------
/**
* Transforms this multibit AssignmentStatement into singlebit Statements
* and returns a BlockStatement containing the result.
* @param obj not used (null).
* @return BlockStatement containing singlebit Statements
* of this AssignmentStatement.
*/
public BlockStatement multi2SingleBit(Object obj) {
return ((Multi2SingleBit) rhs).multi2SingleBit(this);
}
/**
* Returns a string representation of this AssignmentStatement.
* @return a string representation of this AssignmentStatement.
*/
public String toString() {
return lhs.toString() + '=' + rhs.toString() + "\n";
}
/**
* Returns this AssignmentStatement's rhs.
* @return this AssignmentStatement's rhs.
*/
public OperationExpression getRHS() {
return rhs;
}
/**
* Returns this AssignmentStatement's lhs.
* @return this AssignmentStatement's lhs.
*/
public LvalExpression getLHS() {
return lhs;
}
/**
* Prints this AssignmentStatement into the circuit.
* @param circuit the circuit output file.
*/
public void toCircuit(PrintWriter circuit) {
outputLine = Program.getLineNumber();
circuit.print(outputLine + " " + ((lhs.isOutput()) ? "output " : ""));
((OutputWriter) rhs).toCircuit(circuit);
circuit.println(((lhs.isOutput
```
<Overlap Ratio: 0.9829619921363041>

---

--- 33 --
Question ID: 1e86ab96d8b82bca2edc6dce1160b2febbc854be
Original Code:
```
public class MyCommitsHighlighter implements VcsLogHighlighter {
  @NotNull private final VcsLogData myLogData;
  @NotNull private final VcsLogUi myLogUi;
  private boolean myShouldHighlightUser = false;

  public MyCommitsHighlighter(@NotNull VcsLogData logData, @NotNull VcsLogUi logUi) {
    myLogData = logData;
    myLogUi = logUi;
  }

  @NotNull
  @Override
  public VcsCommitStyle getStyle(@NotNull VcsShortCommitDetails details, boolean isSelected) {
    if (!myLogUi.isHighlighterEnabled(Factory.ID)) return VcsCommitStyle.DEFAULT;
    if (myShouldHighlightUser) {
      VcsUser currentUser = myLogData.getCurrentUser().get(details.getRoot());
      if (currentUser != null && VcsUserUtil.isSamePerson(currentUser, details.getAuthor())) {
        return VcsCommitStyleFactory.bold();
      }
    }
    return VcsCommitStyle.DEFAULT;
  }

  @Override
  public void update(@NotNull VcsLogDataPack dataPack, boolean refreshHappened) {
    myShouldHighlightUser = !isSingleUser() && !isFilteredByCurrentUser(dataPack.getFilters());
  }

  // returns true if only one user commits to this repository
  private boolean isSingleUser() {
    NotNullFunction<VcsUser, String> nameToString = user -> VcsUserUtil.getNameInStandardForm(VcsUserUtil.getShortPresentation(user));
    Set<String> allUserNames = ContainerUtil.newHashSet(ContainerUtil.map(myLogData.getAllUsers(), nameToString));
    Set<String> currentUserNames = ContainerUtil.newHashSet(ContainerUtil.map(myLogData.getCurrentUser().values(), nameToString));
    return allUserNames.size() == currentUserNames.size() && currentUserNames.containsAll(allUserNames);
  }

  // returns true if filtered by "me"
  private static boolean isFilteredByCurrentUser(@NotNull VcsLogFilterCollection filters) {
    VcsLogUserFilter userFilter = filters.get(VcsLogFilterCollection.USER_FILTER);
    if (userFilter == null) return false;
    Collection<String> filterByName = ((VcsLogUserFilterImpl)userFilter).getUserNamesForPresentation();
    if (Collections.singleton(VcsLogUserFilterImpl.ME).containsAll(filterByName)) return true;
    return false;
  }

  public static class Factory implements VcsLogHighlighterFactory {
    @NotNull public static final String ID = "MY_COMMITS";

    @NotNull
    @Override
    public VcsLogHighlighter createHighlighter(@NotNull VcsLogData logData, @NotNull VcsLogUi logUi) {
      return new MyCommitsHighlighter(logData, logUi);
    }

    @NotNull
    @Override
    public String getId() {
      return ID;
    }

    @NotNull
    @Override
    public String getTitle() {
      return "My Commits";
    }

    @Override
    public boolean showMenuItem() {
      return true;
    }
  }
}
```


Overlapping Code:
```
lements VcsLogHighlighter {
@NotNull private final VcsLogData myLogData;
@NotNull private final VcsLogUi myLogUi;
private boolean myShouldHighlightUser = false;
public MyCommitsHighlighter(@NotNull VcsLogData logData, @NotNull VcsLogUi logUi) {
myLogData = logData;
myLogUi = logUi;
}
@NotNull
@Override
public VcsCommitStyle getStyle(@NotNull VcsShortCommitDetails details, boolean isSelected) {
if (!myLogUi.isHighlighterEnabled(Factory.ID)) return VcsCommitStyle.DEFAULT;
if (myShouldHighlightUser) {
VcsUser currentUser = myLogData.getCurrentUser().get(details.getRoot());
if (currentUser != null && VcsUserUtil.isSamePerson(currentUser, details.getAuthor())) {
return VcsCommitStyleFactory.bold();
}
}
return VcsCommitStyle.DEFAULT;
}
@Override
public void update(@NotNull VcsLogDataPack dataPack, boolean refreshHappened) {
myShouldHighlightUser = !isSingleUser() && !isFilteredByCurrentUser(dataPack.getFilters());
}
// returns true if only one user commits to this repository
private boolean isSingleUser() {
NotNullFunction<VcsUser, String> nameToString = user -> VcsUserUtil.getNameInStandardForm(VcsUserUtil.getShortPresentation(user));
Set<String> allUserNames = ContainerUtil.newHashSet(ContainerUtil.map(myLogData.getAllUsers(), nameToString));
Set<String> currentUserNames = ContainerUtil.newHashSet(ContainerUtil.map(myLogData.getCurrentUser().values(), nameToString));
return allUserNames.size() == currentUserNames.size() && currentUserNames.containsAll(allUserNames);
}
// returns true if filtered by "me"
private static boolean isFilteredByCurrentUser(@NotNull VcsLogFilterCollection filters) {
VcsLogUserFilter userFilter = filters.get(VcsLogFilterCollection.USER_FILTER);
if (userFilter == null) return false;
Collection<String> filterByName = ((VcsLogUserFilterImpl)userFilter).getUserNamesForPresentation();
if (Collections.singleton(VcsLogUserFilterImpl.ME).containsAll(filterByName)) return true;
return false;
}
public static class Factory implements VcsLogHighlighterFactory {
@NotNull public static final String ID = "MY_COMMITS";
@NotNull
@Override
public VcsLogHighlighter createHighlighter(@NotNull VcsLogData logData, @NotNull VcsLogUi logUi) {
return new MyCommitsHighlighter(logData, logUi);
}
@NotNull
@Override
public String getId() {
return ID;
```
<Overlap Ratio: 0.9840448469167745>

---

--- 34 --
Question ID: a4675cd1c6d00c6fa40e0166973f29640e4807a1
Original Code:
```
public class BoxLayoutTest
{
   public static void main(String[] args)
   {  
      BoxLayoutFrame frame = new BoxLayoutFrame();
      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      frame.setVisible(true);
   }
}
```


Overlapping Code:
```
tatic void main(String[] args)
{ 
BoxLayoutFrame frame = new BoxLayoutFrame();
frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
frame.setVisible(true);
}
}
```
<Overlap Ratio: 0.8121827411167513>

---

--- 35 --
Question ID: b8b7a68566d41f87ddb5ebcfd0dfa98318317a29
Original Code:
```
public class EmojiController extends SuperController {

    /**
     * Construct a controller for emojis.
     *
     * @param database the database containing emoji data
     */
    public EmojiController(MongoDatabase database) {
        this.gson = new Gson();
        this.database = database;
        this.collection = database.getCollection("emojis");
    }

    public String addNewEmoji(String userID, int mood, int intensity) {

        Document newEmoji = new Document();
        newEmoji.append("userID", userID);
        newEmoji.append("mood", mood);
        newEmoji.append("intensity", intensity);

        Date now = new Date();
        newEmoji.append("date", now.toString());

        try {
            collection.insertOne(newEmoji);

            ObjectId id = newEmoji.getObjectId("_id");
            System.err.println("Successfully added new emoji [_id=" + id + ", userID=" + userID + ", mood="
                + mood + " date=" + now + ']');

            return JSON.serialize(id);
        } catch(MongoException me) {
            me.printStackTrace();
            return null;
        }
    }
}
```


Overlapping Code:
```
mojiController extends SuperController {
/**
* Construct a controller for emojis.
*
* @param database the database containing emoji data
*/
public EmojiController(MongoDatabase database) {
this.gson = new Gson();
this.database = database;
this.collection = database.getCollection("emojis");
}
public String addNewEmoji(String userID, int mood, int intensity) {
Document newEmoji = new Document();
newEmoji.append("userID", userID);
newEmoji.append("mood", mood);
newEmoji.append("intensity", intensity);
Date now = new Date();
newEmoji.append("date", now.toString());
try {
collection.insertOne(newEmoji);
ObjectId id = newEmoji.getObjectId("_id");
System.err.println("Successfully added new emoji [_id=" + id + ", userID=" + userID + ", mood="
+ mood + " date=" + now + ']');
return JSON.serialize(id);
} catch(MongoException me) {
me.printStackTrace();
return null;
}
}
}
```
<Overlap Ratio: 0.9842164599774521>

---

--- 36 --
Question ID: ede009c5513ac7499544d9490a7fc8e56ae68ed2
Original Code:
```
public class DynamicRangeTestApp extends PApplet {

	DynamicRangeTimeRangeSlider timeRangeSlider;

	public void setup() {
		size(800, 600);
		smooth();

		timeRangeSlider = new DynamicRangeTimeRangeSlider(this, 100, 200, 300, 16,
				new DateTime(2011, 04, 11, 10, 0, 0), new DateTime(2011, 04, 11, 22, 0, 0), 60 * 10);
		timeRangeSlider.setTickIntervalSeconds(60 * 10);
	}

	public void draw() {
		background(240);

		timeRangeSlider.draw();
	}

	public void keyPressed() {
		if (key == 'i') {
			timeRangeSlider.increaseRange();
		}
		
		timeRangeSlider.onKeyPressed(key, keyCode);
	}

	// Gets called each time the time ranger slider has changed, both by user interaction as well as by animation
	public void timeUpdated(DateTime startDateTime, DateTime endDateTime) {
		println("timeUpdated to " + startDateTime.toString("hh:mm") + " - " + endDateTime.toString("hh:mm"));
	}

	public void mouseMoved() {
		timeRangeSlider.onMoved(mouseX, mouseY);
	}

	public void mouseDragged() {
		timeRangeSlider.onDragged(mouseX, mouseY, pmouseX, pmouseY);
	}

}
```


Overlapping Code:
```
class DynamicRangeTestApp extends PApplet {
DynamicRangeTimeRangeSlider timeRangeSlider;
public void setup() {
size(800, 600);
smooth();
timeRangeSlider = new DynamicRangeTimeRangeSlider(this, 100, 200, 300, 16,
new DateTime(2011, 04, 11, 10, 0, 0), new DateTime(2011, 04, 11, 22, 0, 0), 60 * 10);
timeRangeSlider.setTickIntervalSeconds(60 * 10);
}
public void draw() {
background(240);
timeRangeSlider.draw();
}
public void keyPressed() {
if (key == 'i') {
timeRangeSlider.increaseRange();
}

timeRangeSlider.onKeyPressed(key, keyCode);
}
// Gets called each time the time ranger slider has changed, both by user interaction as well as by animation
public void timeUpdated(DateTime startDateTime, DateTime endDateTime) {
println("timeUpdated to " + startDateTime.toString("hh:mm") + " - " + endDateTime.toString("hh:mm"));
}
public void mouseMoved() {
timeRangeSlider.onMoved(mouseX, mouseY);
}
public void mouseDragged() {
timeRangeSlider.onDragged
```
<Overlap Ratio: 0.9538152610441767>

---

--- 37 --
Question ID: 8c50434f3bc55f4ad1f803e9a189b6c6567b621f
Original Code:
```
@Log4j
@Stateless(name = DaoSharedDataValidatorCommand.COMMAND)
public class DaoSharedDataValidatorCommand implements Command {
	public static final String COMMAND = "DaoSharedDataValidatorCommand";

	@Resource
	private SessionContext daoContext;

	@EJB
	private TimetableDAO timetableDAO;

	@Override
	@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
	public boolean execute(Context context) throws Exception {
		boolean result = Constant.ERROR;
		Monitor monitor = MonitorFactory.start(COMMAND);
		ValidationData data = (ValidationData) context.get(Constant.VALIDATION_DATA);
		InitialContext initialContext = (InitialContext) context.get(Constant.INITIAL_CONTEXT);
		if (!context.containsKey(Constant.SOURCE)) {
			context.put(Constant.SOURCE, Constant.SOURCE_DATABASE);
		}

		try {

			data.getTimetables().clear();
			data.getTimetables().addAll(timetableDAO.findAll());

			Command validateSharedData = CommandFactory.create(initialContext,
					SharedDataValidatorCommand.class.getName());
			result = validateSharedData.execute(context);
			daoContext.setRollbackOnly();
		} finally {
			log.info(Color.MAGENTA + monitor.stop() + Color.NORMAL);
		}

		return result;
	}

	public static class DefaultCommandFactory extends CommandFactory {

		@Override
		protected Command create(InitialContext context) throws IOException {
			Command result = null;
			try {
				String name = "java:app/mobi.chouette.exchange.validator/" + COMMAND;
				result = (Command) context.lookup(name);
			} catch (NamingException e) {
				// try another way on test context
				String name = "java:module/" + COMMAND;
				try {
					result = (Command) context.lookup(name);
				} catch (NamingException e1) {
					log.error(e);
				}
			}
			return result;
		}
	}

	static {
		CommandFactory.register(DaoSharedDataValidatorCommand.class.getName(), new DefaultCommandFactory());
	}

}
```


Overlapping Code:
```
Command.COMMAND)
public class DaoSharedDataValidatorCommand implements Command {
public static final String COMMAND = "DaoSharedDataValidatorCommand";
@Resource
private SessionContext daoContext;
@EJB
private TimetableDAO timetableDAO;
@Override
@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
public boolean execute(Context context) throws Exception {
boolean result = Constant.ERROR;
Monitor monitor = MonitorFactory.start(COMMAND);
ValidationData data = (ValidationData) context.get(Constant.VALIDATION_DATA);
InitialContext initialContext = (InitialContext) context.get(Constant.INITIAL_CONTEXT);
if (!context.containsKey(Constant.SOURCE)) {
context.put(Constant.SOURCE, Constant.SOURCE_DATABASE);
}
try {
data.getTimetables().clear();
data.getTimetables().addAll(timetableDAO.findAll());
Command validateSharedData = CommandFactory.create(initialContext,
SharedDataValidatorCommand.class.getName());
result = validateSharedData.execute(context);
daoContext.setRollbackOnly();
} finally {
log.info(Color.MAGENTA + monitor.stop() + Color.NORMAL);
}
return result;
}
public static class DefaultCommandFactory extends CommandFactory {
@Override
protected Command create(InitialContext context) throws IOException {
Command result = null;
try {
String name = "java:app/mobi.chouette.exchange.validator/" + COMMAND;
result = (Command) context.lookup(name);
} catch (NamingException e) {
// try another way on test context
String name = "java:module/" + COMMAND;
try {
result = (Command) context.lookup(name);
} catch (NamingException e1) {
log.error(e);
}
}
return result;
}
}
static {
CommandFactory.register(DaoSharedDataValidatorCommand.class.getName(), new DefaultCommandFactory());
}
}
```
<Overlap Ratio: 0.9731275014293882>

---

--- 38 --
Question ID: c47eb33ce59d25967457b493da7dafa5ac1d96c7
Original Code:
```
public class DiscordInvite implements Serializable {

    private static final long serialVersionUID = 1L;

    private String code;
    private Guild guild;
    private Channel channel;

    public static long getSerialVersionUID() {
        return serialVersionUID;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public Guild getGuild() {
        return guild;
    }

    public void setGuild(Guild guild) {
        this.guild = guild;
    }

    public Channel getChannel() {
        return channel;
    }

    public void setChannel(Channel channel) {
        this.channel = channel;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DiscordInvite that = (DiscordInvite) o;
        return Objects.equals(code, that.code);
    }

    @Override
    public int hashCode() {
        return Objects.hash(code);
    }

    public static class Guild implements Serializable {

        private static final long serialVersionUID = 1L;

        private String id;
        private String name;
        private String splash;
        private String icon;

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getSplash() {
            return splash;
        }

        public void setSplash(String splash) {
            this.splash = splash;
        }

        public String getIcon() {
            return icon;
        }

        public void setIcon(String icon) {
            this.icon = icon;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Guild guild = (Guild) o;
            return Objects.equals(id, guild.id);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id);
        }
    }

    public static class Channel implements Serializable {

        private static final long serialVersionUID = 1L;

        private String id;
        private String name;
        private String type;

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getType() {
            return type;
        }

        public void setType(String type) {
            this.type = type;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Channel channel = (Channel) o;
            return Objects.equals(id, channel.id);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id);
        }
    }


}
```


Overlapping Code:
```
ite implements Serializable {
private static final long serialVersionUID = 1L;
private String code;
private Guild guild;
private Channel channel;
public static long getSerialVersionUID() {
return serialVersionUID;
}
public String getCode() {
return code;
}
public void setCode(String code) {
this.code = code;
}
public Guild getGuild() {
return guild;
}
public void setGuild(Guild guild) {
this.guild = guild;
}
public Channel getChannel() {
return channel;
}
public void setChannel(Channel channel) {
this.channel = channel;
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
DiscordInvite that = (DiscordInvite) o;
return Objects.equals(code, that.code);
}
@Override
public int hashCode() {
return Objects.hash(code);
}
public static class Guild implements Serializable {
private static final long serialVersionUID = 1L;
private String id;
private String name;
private String splash;
private String icon;
public String getId() {
return id;
}
public void setId(String id) {
this.id = id;
}
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public String getSplash() {
return splash;
}
public void setSplash(String splash) {
this.splash = splash;
}
public String getIcon() {
return icon;
}
public void setIcon(String icon) {
this.icon = icon;
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
Guild guild = (Guild) o;
return Objects.equals(id, guild.id);
}
@Override
public int hashCode() {
return Objects.hash(id);
}
}
public static class Channel implements Serializable {
private static final long serialVersionUID = 1L;
private String id;
private String name;
private String type;
public String get
```
<Overlap Ratio: 0.9831795984807379>

---

--- 39 --
Question ID: 6eb6673bcc56080af10b538418c371bfeb5b0414
Original Code:
```
public final class PersistedOutputRDD implements OutputRDD, PersistResultGraphAware {

    private static final Logger LOGGER = LoggerFactory.getLogger(PersistedOutputRDD.class);

    @Override
    public void writeGraphRDD(final Configuration configuration, final JavaPairRDD<Object, VertexWritable> graphRDD) {
        if (!configuration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT, false))
            LOGGER.warn("The SparkContext should be persisted in order for the RDD to persist across jobs. To do so, set " + Constants.GREMLIN_SPARK_PERSIST_CONTEXT + " to true");
        if (!configuration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))
            throw new IllegalArgumentException("There is no provided " + Constants.GREMLIN_HADOOP_OUTPUT_LOCATION + " to write the persisted RDD to");
        SparkContextStorage.open(configuration).rm(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION));  // this might be bad cause it unpersists the job RDD
        // determine which storage level to persist the RDD as with MEMORY_ONLY being the default cache()
        final StorageLevel storageLevel = StorageLevel.fromString(configuration.getString(Constants.GREMLIN_SPARK_PERSIST_STORAGE_LEVEL, "MEMORY_ONLY"));
        if (!configuration.getBoolean(Constants.GREMLIN_HADOOP_GRAPH_WRITER_HAS_EDGES, true))
            graphRDD.mapValues(vertex -> {
                vertex.get().dropEdges(Direction.BOTH);
                return vertex;
            }).setName(Constants.getGraphLocation(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))).persist(storageLevel)
                    // call action to eager store rdd
                    .count();
        else
            graphRDD.setName(Constants.getGraphLocation(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))).persist(storageLevel)
                    // call action to eager store rdd
                    .count();
        Spark.refresh(); // necessary to do really fast so the Spark GC doesn't clear out the RDD
    }

    @Override
    public <K, V> Iterator<KeyValue<K, V>> writeMemoryRDD(final Configuration configuration, final String memoryKey, final JavaPairRDD<K, V> memoryRDD) {
        if (!configuration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT, false))
            LOGGER.warn("The SparkContext should be persisted in order for the RDD to persist across jobs. To do so, set " + Constants.GREMLIN_SPARK_PERSIST_CONTEXT + " to true");
        if (!configuration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))
            throw new IllegalArgumentException("There is no provided " + Constants.GREMLIN_HADOOP_OUTPUT_LOCATION + " to write the persisted RDD to");
        final String memoryRDDName = Constants.getMemoryLocation(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION), memoryKey);
        Spark.removeRDD(memoryRDDName);
        memoryRDD.setName(memoryRDDName).persist(StorageLevel.fromString(configuration.getString(Constants.GREMLIN_SPARK_PERSIST_STORAGE_LEVEL, "MEMORY_ONLY")))
                // call action to eager store rdd
                .count();
        Spark.refresh(); // necessary to do really fast so the Spark GC doesn't clear out the RDD
        return IteratorUtils.map(memoryRDD.collect().iterator(), tuple -> new KeyValue<>(tuple._1(), tuple._2()));
    }

    @Override
    public boolean supportsResultGraphPersistCombination(final GraphComputer.ResultGraph resultGraph, final GraphComputer.Persist persist) {
        return persist.equals(GraphComputer.Persist.NOTHING) || resultGraph.equals(GraphComputer.ResultGraph.NEW);
    }
}
```


Overlapping Code:
```
ersistedOutputRDD implements OutputRDD, PersistResultGraphAware {
private static final Logger LOGGER = LoggerFactory.getLogger(PersistedOutputRDD.class);
@Override
public void writeGraphRDD(final Configuration configuration, final JavaPairRDD<Object, VertexWritable> graphRDD) {
if (!configuration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT, false))
LOGGER.warn("The SparkContext should be persisted in order for the RDD to persist across jobs. To do so, set " + Constants.GREMLIN_SPARK_PERSIST_CONTEXT + " to true");
if (!configuration.containsKey(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))
throw new IllegalArgumentException("There is no provided " + Constants.GREMLIN_HADOOP_OUTPUT_LOCATION + " to write the persisted RDD to");
SparkContextStorage.open(configuration).rm(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION)); // this might be bad cause it unpersists the job RDD
// determine which storage level to persist the RDD as with MEMORY_ONLY being the default cache()
final StorageLevel storageLevel = StorageLevel.fromString(configuration.getString(Constants.GREMLIN_SPARK_PERSIST_STORAGE_LEVEL, "MEMORY_ONLY"));
if (!configuration.getBoolean(Constants.GREMLIN_HADOOP_GRAPH_WRITER_HAS_EDGES, true))
graphRDD.mapValues(vertex -> {
vertex.get().dropEdges(Direction.BOTH);
return vertex;
}).setName(Constants.getGraphLocation(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))).persist(storageLevel)
// call action to eager store rdd
.count();
else
graphRDD.setName(Constants.getGraphLocation(configuration.getString(Constants.GREMLIN_HADOOP_OUTPUT_LOCATION))).persist(storageLevel)
// call action to eager store rdd
.count();
Spark.refresh(); // necessary to do really fast so the Spark GC doesn't clear out the RDD
}
@Override
public <K, V> Iterator<KeyValue<K, V>> writeMemoryRDD(final Configuration configuration, final String memoryKey, final JavaPairRDD<K, V> memoryRDD) {
if (!configuration.getBoolean(Constants.GREMLIN_SPARK_PERSIST_CONTEXT, false))
LOGGER.warn("The SparkContext should be persisted in order for the RDD to persist across jobs. To do so, set " + Constants.GREMLIN_SPARK_PERSIST_
```
<Overlap Ratio: 0.9741730856366108>

---

--- 40 --
Question ID: b3055d7d81d5f283a7a5236ae5c7ecae299b4935
Original Code:
```
public class PongGameView extends GameView {

	public static final float HALF_PI = (float) (Math.PI * 0.5f);

	protected static final int MIN_MOVEMENT = 2;

	private Racket leftRacket;
	private Racket rightRacket;
	private Racket activeRacket;
	private Ball ball;
	private int leftPoints;
	private int rightPoints;

	private int pixelSize = 10;
	private Vector2d dimens;
	private Vector2d dimensHalf;

	private final Paint paint = new Paint();
	private Paint textPaint = new Paint();

	private Random random = new Random();

	public PongGameView(Context context) {
		super(context);

		Vector2d racketSize = new Vector2d(pixelSize, 4 * pixelSize);
		float ballRadius = pixelSize;
		leftRacket = new Racket(racketSize);
		rightRacket = new Racket(racketSize);
		activeRacket = leftRacket;

		ball = new Ball(ballRadius);

		textPaint = new Paint();
		textPaint.setColor(Color.WHITE);
		textPaint.setTextAlign(Align.CENTER);
		textPaint.setTextSize(64);
		textPaint.setAntiAlias(true);

		paint.setColor(Color.WHITE);
		paint.setAntiAlias(true);

		setOnTouchListener(new OnTouchListener() {
			@Override
			public boolean onTouch(View v, MotionEvent event) {

				switch (event.getActionMasked()) {

				case MotionEvent.ACTION_DOWN:
				case MotionEvent.ACTION_POINTER_DOWN: {
					int pointerIndex = event.getActionIndex();

					float x = event.getX(pointerIndex);
					float y = event.getY(pointerIndex);

					Racket racket = (x < getWidth() * 0.5f) ? leftRacket
						: rightRacket;
					racket.setCenterY(y - dimensHalf.y);

					break;
				}

				case MotionEvent.ACTION_UP:
				case MotionEvent.ACTION_POINTER_UP: {
					break;
				}

				case MotionEvent.ACTION_MOVE: {
					for (int idx = 0; idx < event.getPointerCount(); idx++) {
						float x = event.getX(idx);
						float y = event.getY(idx);
						Racket racket = (x < getWidth() * 0.5f) ? leftRacket
							: rightRacket;

						Vector2d center = racket.getCenter();
						if (Math.abs(center.x + dimensHalf.x - x) > MIN_MOVEMENT
							|| Math.abs(center.y + dimensHalf.y - y) > MIN_MOVEMENT) {
							racket.setCenterY(y - dimensHalf.y);
						}
					}

					break;
				}

				default:
					Log.i(LOG_TAG, "unhandled action");
				}

				return true;
			}
		});
	}

	@Override
	protected void onUpdate() {
		float dt = getTimeDelta();
		ball.update(dt);
		activeRacket = (ball.getVelocity().x > 0) ? rightRacket : leftRacket;
		//leftRacket.update(dt);
		//rightRacket.update(dt);
	}

	@Override
	protected void onRender(Canvas canvas) {
		canvas.drawColor(Color.BLACK);

		canvas.save();

		canvas.translate(dimensHalf.x, dimensHalf.y);

		// stroke(0.25f);
		// fill(0.5f);

		drawPoints(canvas);
		drawNet(canvas);

		// fill(0.25f);
		// noStroke();

		drawBall(canvas);
		drawRackets(canvas);

		canvas.restore();
	}

	@Override
	public void surfaceCreated(SurfaceHolder holder) {
		dimens = new Vector2d(getWidth(), getHeight());
		dimensHalf = new Vector2d(0.5f * dimens.x, 0.5f * dimens.y);

		leftRacket.setCenter(new Vector2d(-dimensHalf.x * 0.8f, 0));
		rightRacket.setCenter(new Vector2d(dimensHalf.x * 0.8f, 0));

		ball.resetRandomly();

		super.surfaceCreated(holder);
	}

	void drawNet(Canvas canvas) {
		canvas.drawLine(0, -dimensHalf.y, 0, dimensHalf.y, paint);
	}

	void drawPoints(Canvas canvas) {
		float quarterWidth = dimens.x * 0.25f;
		float quarterHeight = dimens.y * 0.25f;
		canvas.drawText(String.valueOf(leftPoints),
			-quarterWidth,
			-quarterHeight,
			textPaint);
		canvas.drawText(String.valueOf(rightPoints),
			quarterWidth,
			-quarterHeight,
			textPaint);
	}

	void drawBall(Canvas canvas) {
		// fill(0.75f);
		ball.draw(canvas);
	}

	void drawRackets(Canvas canvas) {
		leftRacket.draw(canvas);
		rightRacket.draw(canvas);
	}

	private class Racket {
		private static final float SPEED = 1000f;
		private Vector2d center = new Vector2d(0, 0);
		private Vector2d size;

		public Racket(Vector2d size) {
			this.size = size;
		}

		public Vector2d getCenter() {
			return center;
		}

		public void setCenter(Vector2d center) {
			this.center = center;
		}

		public void setCenterY(float y) {
			center.y = y;
		}

		// public void update(float dt) {
		// if (keyPressed && (key == CODED) && activeRacket == this) {
		// float dy = 0;
		// if (keyCode == UP) {
		// dy = -SPEED * dt;
		// } else if (keyCode == DOWN) {
		// dy = SPEED * dt;
		// }
		// center.y += dy;
		// center.y = constrain(center.y,
		// size.y - dimensHalf.y,
		// dimensHalf.y - size.y);
		// }
		// }
		
		

		public boolean intersects(Rectangle otherRect) {
			Rectangle thisRect = Rectangle.fromCentered(center, size);
			return thisRect.intersects(otherRect);
		}

		public void draw(Canvas canvas) {
			// fill((activeRacket == this) ? 0.75f : 0.5f);

			float left = center.x - size.x;
			float top = center.y - size.y;
			float right = center.x + size.x;
			float bottom = center.y + size.y;

			canvas.drawRect(left, top, right, bottom, paint);
		}
	}

	private class Ball {
		Vector2d center;
		Vector2d velocity;
		float radius;

		static final float SPEED = 500f;

		public Ball(float radius) {
			this.radius = radius;
		}

		public void update(float dt) {
			float dx = dt * velocity.x;
			float dy = dt * velocity.y;
			float margin = radius - Math.abs(velocity.x);

			if (center.x - margin < -dimensHalf.x) {
				resetRandomly();
			} else if (center.x + margin > dimensHalf.x) {
				resetRandomly();
			}

			if (Math.abs(center.y + dy) + radius > dimensHalf.y) {
				dy *= -1;
				velocity.y *= -1;
			} else if (activeRacketIntersects(new Vector2d(center.x + dx,
				center.y + dy))) {
				dx *= -1;
				velocity.x *= -1;
			}

			if (center.x + dx - radius < -dimensHalf.x
				&& center.x - radius >= -dimensHalf.x) {
				rightPoints++;
			} else if (center.x + dx + radius > dimensHalf.x
				&& center.x + radius <= dimensHalf.x) {
				leftPoints++;
			}

			center.x += dx;
			center.y += dy;
		}

		private boolean activeRacketIntersects(Vector2d center) {
			Rectangle rect = Rectangle.fromCentered(center, new Vector2d(
				radius, radius));
			return activeRacket.intersects(rect);
		}

		public Vector2d getVelocity() {
			return velocity;
		}

		public void resetRandomly() {
			center = new Vector2d(0, (random.nextFloat() * dimens.y)
				- dimensHalf.y);

			float angle = ((int) random.nextInt(4) + 0.5f) * HALF_PI;
			velocity = new Vector2d(SPEED * (float) Math.cos(angle), SPEED
				* (float) Math.sin(angle));
		}

		public void draw(Canvas canvas) {
			float left = center.x - radius;
			float top = center.y - radius;
			float right = center.x + radius;
			float bottom = center.y + radius;
			canvas.drawRect(left, top, right, bottom, paint);
		}
	}

	private static class Rectangle {
		private Vector2d corner;
		private Vector2d size;

		public Rectangle(Vector2d corner, Vector2d size) {
			this.corner = corner;
			this.size = size;
		}

		public static Rectangle fromCentered(Vector2d center, Vector2d radius) {
			return new Rectangle(new Vector2d(center.x - radius.x, center.y
				- radius.y), new Vector2d(2 * radius.x, 2 * radius.y));
		}

		public boolean intersects(Rectangle other) {
			return (this.corner.x + this.size.x >= other.corner.x)
				&& (other.corner.x + other.size.x >= this.corner.x)
				&& (this.corner.y + this.size.y >= other.corner.y)
				&& (other.corner.y + other.size.y >= this.corner.y);
		}
	}

	private static class Vector2d {
		public float x;
		public float y;

		public Vector2d(float x, float y) {
			this.x = x;
			this.y = y;
		}
	}
}
```


Overlapping Code:
```
ass PongGameView extends GameView {
public static final float HALF_PI = (float) (Math.PI * 0.5f);
protected static final int MIN_MOVEMENT = 2;
private Racket leftRacket;
private Racket rightRacket;
private Racket activeRacket;
private Ball ball;
private int leftPoints;
private int rightPoints;
private int pixelSize = 10;
private Vector2d dimens;
private Vector2d dimensHalf;
private final Paint paint = new Paint();
private Paint textPaint = new Paint();
private Random random = new Random();
public PongGameView(Context context) {
super(context);
Vector2d racketSize = new Vector2d(pixelSize, 4 * pixelSize);
float ballRadius = pixelSize;
leftRacket = new Racket(racketSize);
rightRacket = new Racket(racketSize);
activeRacket = leftRacket;
ball = new Ball(ballRadius);
textPaint = new Paint();
textPaint.setColor(Color.WHITE);
textPaint.setTextAlign(Align.CENTER);
textPaint.setTextSize(64);
textPaint.setAntiAlias(true);
paint.setColor(Color.WHITE);
paint.setAntiAlias(true);
setOnTouchListener(new OnTouchListener() {
@Override
public boolean onTouch(View v, MotionEvent event) {
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
case MotionEvent.ACTION_POINTER_DOWN: {
int pointerIndex = event.getActionIndex();
float x = event.getX(pointerIndex);
float y = event.getY(pointerIndex);
Racket racket = (x < getWidth() * 0.5f) ? leftRacket
: rightRacket;
racket.setCenterY(y - dimensHalf.y);
break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_POINTER_UP: {
break;
}
case MotionEvent.ACTION_MOVE: {
for (int idx = 0; idx < event.getPointerCount(); idx++) {
float x = event.getX(idx);
float y = event.getY(idx);
Racket racket = (x < getWidth() * 0.5f) ? leftRacket
: rightRacket;
Vector2d center = racket.getCenter();
if (Math.abs(center.x + dimensHalf.x - x) > MIN_MOVEMENT
|| Math.abs(center.y + dimensHalf.y - y) > MIN_MOVEMENT) {
racket.setCenterY(y - dimensHalf.y);
}
}
break;
}
default:
Log.i(LOG_TAG, "unhandled action");
}
return true;
}
});
}
@Override
protected void onUpdate() {
float dt = getTimeDelta();
ball.update(dt);
activeRacket = (ball.getVelocity().x > 0) ? rightRacket : leftRacket;
//leftRacket.update(dt);
//rightRacket.update(dt);
}
@Override
protec
```
<Overlap Ratio: 0.9838998211091234>

---

--- 41 --
Question ID: 865967dc226c798bbeb8d012ce5b0e506277ef19
Original Code:
```
public class DomFileInfo {
    private int maxColCountInRow;
    private int minColCountInRow;
    private int rowCount;

    public boolean isTable(){
        return maxColCountInRow != 0 && maxColCountInRow == minColCountInRow;
    }

    public int getColCount(){
        return minColCountInRow;
    }
    public int getRowCount() { return rowCount; }

    public DomFileInfo(){
        this.maxColCountInRow=0;
        this.minColCountInRow=Integer.MAX_VALUE;
        this.rowCount = 0;
    }

    public void scan(String[] values){
        maxColCountInRow = Math.max(maxColCountInRow, values.length);
        minColCountInRow = Math.min(minColCountInRow, values.length);
        rowCount++;
    }

    public void scan(DomElement line){
        scan(line.data);
    }
}
```


Overlapping Code:
```
 DomFileInfo {
private int maxColCountInRow;
private int minColCountInRow;
private int rowCount;
public boolean isTable(){
return maxColCountInRow != 0 && maxColCountInRow == minColCountInRow;
}
public int getColCount(){
return minColCountInRow;
}
public int getRowCount() { return rowCount; }
public DomFileInfo(){
this.maxColCountInRow=0;
this.minColCountInRow=Integer.MAX_VALUE;
this.rowCount = 0;
}
public void scan(String[] values){
maxColCountInRow = Math.max(maxColCountInRow, values.length);
minColCountInRow = Math.min(minColCountInRow, values.length);
rowCount++;
}
public void scan(DomElem
```
<Overlap Ratio: 0.9331259720062208>

---

--- 42 --
Question ID: a4cf1ca82d68aca94e0e56a6c2211296df502f15
Original Code:
```
class EquivContext implements StringConstants {

    private static final int TRUNCATE_LENGTH = 15;

    private final String name;

    private final String type;

    private String failedProperty;

    private String a;

    private String b;

    public EquivContext(String name, Class<?> klazz) {
        this.name = name;
        this.type = klazz.getSimpleName().replaceAll("Immutable", EMPTY_STRING);
    }

    public String id() {
        StringBuilder builder = new StringBuilder();
        builder.append(type);

        if (name != null) {
            builder
                .append(OPEN_BRACKET)
                .append(QUOTE_MARK)
                .append(name)
                .append(QUOTE_MARK)
                .append(CLOSE_BRACKET);
        }

        return builder.toString();
    }

    public boolean hasFailed() {
        return this.failedProperty != null;
    }

    public String getFailed() {
        return "'" + this.failedProperty + "' is different" + NEW_LINE +
                        TAB + "=> " + QUOTE_MARK + this.a + QUOTE_MARK + NEW_LINE +
                        TAB + "=> " + QUOTE_MARK + this.b + QUOTE_MARK + NEW_LINE;
    }

    private String truncate(String fullText, String diffText, int diffIndex) {
        StringBuilder truncated = new StringBuilder();

        //
        // Adds a portion of the full text at the start of the value
        // then include '...'
        //
        if (diffIndex > 0 && diffIndex <= TRUNCATE_LENGTH) {
            truncated.append(fullText.substring(0, diffIndex));
        } else if (diffIndex > TRUNCATE_LENGTH) {
            truncated
                .append(fullText.substring(0, TRUNCATE_LENGTH))
                .append(SPACE).append(ELLIPSE).append(SPACE);
        }

        if (diffText.length() > 70) {
            truncated.append(diffText.substring(0, 70)).append(SPACE).append(ELLIPSE);
        } else {
            truncated.append(diffText);
        }

        return truncated.toString();
    }

    public void setFail(String property, Object a, Object b) {
        this.failedProperty = property;
        String aStr = toString(a);
        String bStr = toString(b);

        int diffPos = StringUtils.indexOfDifference(aStr, bStr);
        if (diffPos < 0) {
            this.a = aStr;
            this.b = bStr;
            return;
        }

        String aDiff = aStr.substring(diffPos);
        String bDiff = bStr.substring(diffPos);

        this.a = truncate(aStr, aDiff, diffPos);
        this.b = truncate(bStr, bDiff, diffPos);
    }

    private String toString(Object value) {
        if (value instanceof Optional) {
            Optional<?> ov = (Optional<?>) value;
            Object v = ov.orElse(null);
            if (v == null) {
                return EMPTY_STRING;
            } else {
                return v.toString();
            }
        }

        return value.toString();
    }
}
```


Overlapping Code:
```
 EquivContext implements StringConstants {
private static final int TRUNCATE_LENGTH = 15;
private final String name;
private final String type;
private String failedProperty;
private String a;
private String b;
public EquivContext(String name, Class<?> klazz) {
this.name = name;
this.type = klazz.getSimpleName().replaceAll("Immutable", EMPTY_STRING);
}
public String id() {
StringBuilder builder = new StringBuilder();
builder.append(type);
if (name != null) {
builder
.append(OPEN_BRACKET)
.append(QUOTE_MARK)
.append(name)
.append(QUOTE_MARK)
.append(CLOSE_BRACKET);
}
return builder.toString();
}
public boolean hasFailed() {
return this.failedProperty != null;
}
public String getFailed() {
return "'" + this.failedProperty + "' is different" + NEW_LINE +
TAB + "=> " + QUOTE_MARK + this.a + QUOTE_MARK + NEW_LINE +
TAB + "=> " + QUOTE_MARK + this.b + QUOTE_MARK + NEW_LINE;
}
private String truncate(String fullText, String diffText, int diffIndex) {
StringBuilder truncated = new StringBuilder();
//
// Adds a portion of the full text at the start of the value
// then include '...'
//
if (diffIndex > 0 && diffIndex <= TRUNCATE_LENGTH) {
truncated.append(fullText.substring(0, diffIndex));
} else if (diffIndex > TRUNCATE_LENGTH) {
truncated
.append(fullText.substring(0, TRUNCATE_LENGTH))
.append(SPACE).append(ELLIPSE).append(SPACE);
}
if (diffText.length() > 70) {
truncated.append(diffText.substring(0, 70)).append(SPACE).append(ELLIPSE);
} else {
truncated.append(diffText);
}
return truncated.toString();
}
public void setFail(String property, Object a, Object b) {
this.failedProperty = property;
String aStr = toString(a);
String bStr = toString(b);
int diffPos = StringUtils.indexOfDifference(aStr, bStr);
if (diffPos < 0) {
this.a = aStr;
this.b = bStr;
return;
}
String aDiff = aStr.substring(diffPos);
String bDiff = bStr.substring(diffPos);
this.a = truncate(aStr, aDiff, diffPo
```
<Overlap Ratio: 0.9958071278825996>

---

--- 43 --
Question ID: d915d20b533e26cbb5012ccdc535e6ce5c2894f2
Original Code:
```
@Slf4j
public class ExampleBasic {

  public static void main(String[] arg) {
    log.info("Test modem which only understand AT");

    //final Basic modem = new Basic(new JsscSerial("/dev/tty.usbserial-A1056QHL", 9600, FLOWCONTROL_NONE, callback));
    final Basic modem = new Basic(
        new JsscSerial("/dev/tty.usbserial-A1056QHL", 9600, FLOWCONTROL_XONXOFF_IN | FLOWCONTROL_XONXOFF_OUT,
            new UnsolicitedCallback()));

    try {
      modem.init();
      log.info("Is the modem responsive? {}", modem.isResponsive());
      // Send a simple AT
      modem.getSimpleCommand("AT").set();
      // Send a lot of AT commands
      for (int i = 0; i < 1000; i++) {
        modem.getAttention();
      }
      modem.close();
    } catch (final Exception e) {
      log.error("The modem had an error", e);
    }

  }

}
```


Overlapping Code:
```
void main(String[] arg) {
log.info("Test modem which only understand AT");
//final Basic modem = new Basic(new JsscSerial("/dev/tty.usbserial-A1056QHL", 9600, FLOWCONTROL_NONE, callback));
final Basic modem = new Basic(
new JsscSerial("/dev/tty.usbserial-A1056QHL", 9600, FLOWCONTROL_XONXOFF_IN | FLOWCONTROL_XONXOFF_OUT,
new UnsolicitedCallback()));
try {
modem.init();
log.info("Is the modem responsive? {}", modem.isResponsive());
// Send a simple AT
modem.getSimpleCommand("AT").set();
// Send a lot of AT commands
for (int i = 0; i < 1000; i++) {
modem.getAttention();
}
modem.close();
} catch (final Exception e) {
log.error("The modem had an error", e);
```
<Overlap Ratio: 0.9230769230769231>

---

--- 44 --
Question ID: befbfddbe0438b302a118c5a78782f73798f15c0
Original Code:
```
public class TestDatasetConfigManager {

  private Long datasetConfigId1;
  private Long datasetConfigId2;
  private static String collection1 = "my dataset1";
  private static String collection2 = "my dataset2";

  private DAOTestBase testDAOProvider;
  private DatasetConfigManager datasetConfigDAO;
  @BeforeClass
  void beforeClass() {
    testDAOProvider = DAOTestBase.getInstance();
    DAORegistry daoRegistry = DAORegistry.getInstance();
    datasetConfigDAO = daoRegistry.getDatasetConfigDAO();
  }

  @AfterClass(alwaysRun = true)
  void afterClass() {
    testDAOProvider.cleanup();
  }

  @Test
  public void testCreate() {

    DatasetConfigDTO datasetConfig1 = DaoTestUtils.getTestDatasetConfig(collection1);
    datasetConfig1.setRequiresCompletenessCheck(true);
    datasetConfigId1 = datasetConfigDAO.save(datasetConfig1);
    Assert.assertNotNull(datasetConfigId1);

    DatasetConfigDTO datasetConfig2 = DaoTestUtils.getTestDatasetConfig(collection2);
    datasetConfig2.setActive(false);
    datasetConfig2.setRequiresCompletenessCheck(true);
    datasetConfigId2 = datasetConfigDAO.save(datasetConfig2);
    Assert.assertNotNull(datasetConfigId2);

    List<DatasetConfigDTO> datasetConfigs = datasetConfigDAO.findAll();
    Assert.assertEquals(datasetConfigs.size(), 2);

    datasetConfigs = datasetConfigDAO.findActive();
    Assert.assertEquals(datasetConfigs.size(), 1);
  }

  @Test(dependsOnMethods = {"testCreate"})
  public void testFindByDataset() {
    DatasetConfigDTO datasetConfigs = datasetConfigDAO.findByDataset(collection1);
    Assert.assertEquals(datasetConfigs.getDataset(), collection1);
  }

  @Test(dependsOnMethods = { "testFindByDataset" })
  public void testUpdate() {
    DatasetConfigDTO datasetConfig = datasetConfigDAO.findById(datasetConfigId1);
    Assert.assertNotNull(datasetConfig);
    Assert.assertFalse(datasetConfig.isRealtime());
    datasetConfig.setRealtime(true);
    datasetConfigDAO.update(datasetConfig);
    datasetConfig = datasetConfigDAO.findById(datasetConfigId1);
    Assert.assertNotNull(datasetConfig);
    Assert.assertTrue(datasetConfig.isRealtime());
  }

  @Test(dependsOnMethods = { "testUpdate" })
  public void testDelete() {
    datasetConfigDAO.deleteById(datasetConfigId2);
    DatasetConfigDTO datasetConfig = datasetConfigDAO.findById(datasetConfigId2);
    Assert.assertNull(datasetConfig);
  }

  @Test(dependsOnMethods = {"testCreate"})
  public void testActiveRequiresCompletenessCheck() {
    Assert.assertEquals(datasetConfigDAO.findActiveRequiresCompletenessCheck().size(), 1);
  }
}
```


Overlapping Code:
```
atasetConfigManager {
private Long datasetConfigId1;
private Long datasetConfigId2;
private static String collection1 = "my dataset1";
private static String collection2 = "my dataset2";
private DAOTestBase testDAOProvider;
private DatasetConfigManager datasetConfigDAO;
@BeforeClass
void beforeClass() {
testDAOProvider = DAOTestBase.getInstance();
DAORegistry daoRegistry = DAORegistry.getInstance();
datasetConfigDAO = daoRegistry.getDatasetConfigDAO();
}
@AfterClass(alwaysRun = true)
void afterClass() {
testDAOProvider.cleanup();
}
@Test
public void testCreate() {
DatasetConfigDTO datasetConfig1 = DaoTestUtils.getTestDatasetConfig(collection1);
datasetConfig1.setRequiresCompletenessCheck(true);
datasetConfigId1 = datasetConfigDAO.save(datasetConfig1);
Assert.assertNotNull(datasetConfigId1);
DatasetConfigDTO datasetConfig2 = DaoTestUtils.getTestDatasetConfig(collection2);
datasetConfig2.setActive(false);
datasetConfig2.setRequiresCompletenessCheck(true);
datasetConfigId2 = datasetConfigDAO.save(datasetConfig2);
Assert.assertNotNull(datasetConfigId2);
List<DatasetConfigDTO> datasetConfigs = datasetConfigDAO.findAll();
Assert.assertEquals(datasetConfigs.size(), 2);
datasetConfigs = datasetConfigDAO.findActive();
Assert.assertEquals(datasetConfigs.size(), 1);
}
@Test(dependsOnMethods = {"testCreate"})
public void testFindByDataset() {
DatasetConfigDTO datasetConfigs = datasetConfigDAO.findByDataset(collection1);
Assert.assertEquals(datasetConfigs.getDataset(), collection1);
}
@Test(dependsOnMethods = { "testFindByDataset" })
public void testUpdate() {
DatasetConfigDTO datasetConfig = datasetConfigDAO.findById(datasetConfigId1);
Assert.assertNotNull(datasetConfig);
Assert.assertFalse(datasetConfig.isRealtime());
datasetConfig.setRealtime(true);
datasetConfigDAO.update(datasetConfig);
datasetConfig = datasetConfigDAO.findById(datasetConfigId1);
Assert.assertNotNull(datasetConfig);
Assert.assertTrue(datasetConfig.isRealtime());
}
@Test(dependsOnMethods = { "testUpdate" })
public void testDelete() {
datasetConfigDAO.deleteById(datasetConfigId2);
DatasetConfigDTO datasetConfig = datasetConfigDAO.findById(datasetConfigId2);
Assert.assertNull(datasetConfig);
}
@Test(dependsOnMethods = {"testCreate"})
public void testActive
```
<Overlap Ratio: 0.9736045002163566>

---

--- 45 --
Question ID: 1915bb67e7a930d1384da5fcc3688e1c1bea9fbd
Original Code:
```
public class SetDepartmentCommandTest {

    private Model model;
    private CommandHistory commandHistory = new CommandHistory();

    @Before
    public void setUp() {
        model = new ModelManager(TypicalPersons.getTypicalAddressBook(), new UserPrefs());
    }

    @Test
    public void constructor_nullParameters_throwsNullPointerException() {
        Assertions.assertThrows(NullPointerException.class, () -> {
            new SetDepartmentCommand(null, null);
        });
        Assertions.assertThrows(NullPointerException.class, () -> {
            new SetDepartmentCommand(INDEX_FIRST_PERSON, null);
        });
        Assertions.assertThrows(NullPointerException.class, () -> {
            new SetDepartmentCommand(null, new Department("Junior Management"));
        });
    }

    @Test
    public void execute_notLoggedIn_throwsCommandException() {
        Assertions.assertThrows(CommandException.class, () -> {
            SetDepartmentCommand sd = new SetDepartmentCommand(INDEX_FIRST_PERSON,
                    new Department("Junior Management"));
            sd.execute(model, commandHistory);
        }, SessionManager.NOT_LOGGED_IN);
    }

    @Test
    public void execute_invalidPersonIndexFilteredList_failure() throws CommandException {
        showPersonAtIndex(model, INDEX_FIRST_PERSON);
        Index outOfBoundIndex = INDEX_SECOND_PERSON;
        // ensures that outOfBoundIndex is still in bounds of address book list
        assertTrue(outOfBoundIndex.getZeroBased() < model.getAddressBook().getPersonList().size());

        LoginCommand loginCommand = new LoginCommand(TypicalPersons.ALICE.getNric(),
                TypicalPersons.ALICE.getPassword());
        loginCommand.execute(model, commandHistory);

        SetDepartmentCommand sd = new SetDepartmentCommand(outOfBoundIndex,
                new Department("Junior Management"));

        assertCommandFailure(sd, model, commandHistory, Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
    }

    /**
     * After this test method, Alice's Department remains, whereas Daniel's Department will become Junior Management.
     */
    @Test
    public void execute_setDepartmentOfFourthPerson_success() throws CommandException {
        SessionManager.getInstance(model).destroy();
        model = new ModelManager(TypicalPersons.getTypicalAddressBook(), new UserPrefs());

        LoginCommand loginCommand = new LoginCommand(TypicalPersons.ALICE.getNric(),
                TypicalPersons.ALICE.getPassword());
        loginCommand.execute(model, commandHistory);

        Person editedDaniel = new PersonBuilder(TypicalPersons.DANIEL)
                .withDepartment("Junior Management").build();

        Model expectedModel = new ModelManager(model.getAddressBook(), new UserPrefs());
        expectedModel.updatePerson(TypicalPersons.DANIEL, editedDaniel);
        expectedModel.commitAddressBook();

        SetDepartmentCommand sd = new SetDepartmentCommand(INDEX_FOURTH_PERSON,
                new Department("Junior Management"));
        String expectedMessage = String.format(SetDepartmentCommand.MESSAGE_CHANGE_DEPARTMENT_SUCCESS,
                TypicalPersons.DANIEL.getName(), "Junior Management");
        assertCommandSuccess(sd, model, commandHistory, expectedMessage, expectedModel);
    }

    @Test
    public void execute_insufficientPriorityLevel_throwsCommandException() throws CommandException {
        Person editedDaniel = new PersonBuilder(TypicalPersons.DANIEL)
                .withPriorityLevel(PriorityLevelEnum.BASIC.getPriorityLevelCode()).build();
        model.updatePerson(TypicalPersons.DANIEL, editedDaniel);
        LoginCommand loginCommand = new LoginCommand(TypicalPersons.DANIEL.getNric(),
                TypicalPersons.DANIEL.getPassword());
        loginCommand.execute(model, commandHistory);

        SetDepartmentCommand sd = new SetDepartmentCommand(INDEX_FIRST_PERSON,
                new Department("Junior Management"));

        Assertions.assertThrows(CommandException.class, () -> sd.execute(model, commandHistory),
                String.format(PriorityLevel.INSUFFICIENT_PRIORITY_LEVEL, PriorityLevelEnum.ADMINISTRATOR));

    }

    @Test
    public void execute_editOwnDepartment_throwsCommandException() throws CommandException {
        LoginCommand loginCommand = new LoginCommand(TypicalPersons.ALICE.getNric(),
                TypicalPersons.ALICE.getPassword());
        loginCommand.execute(model, commandHistory);

        SetDepartmentCommand sd = new SetDepartmentCommand(INDEX_FIRST_PERSON,
                new Department("Senior Management"));

        Assertions.assertThrows(CommandException.class, () -> sd.execute(model, commandHistory),
                SetDepartmentCommand.MESSAGE_CANNOT_EDIT_OWN_DEPARTMENT);
    }

    /**
     * Logs out of the application after each test
     */
    @After
    public void tearDown() throws CommandException {
        try {
            new LogoutCommand().execute(model, commandHistory);
        } catch (CommandException ce) {
            //Ignores the CommandException if user is not logged in in the first place.
            if (!ce.getMessage().equals(LogoutCommand.NOT_LOGGED_IN)) {
                throw new CommandException(ce.getMessage());
            }
        } finally {
            SessionManager.getInstance(model).destroy();
        }
    }
}
```


Overlapping Code:
```
CommandTest {
private Model model;
private CommandHistory commandHistory = new CommandHistory();
@Before
public void setUp() {
model = new ModelManager(TypicalPersons.getTypicalAddressBook(), new UserPrefs());
}
@Test
public void constructor_nullParameters_throwsNullPointerException() {
Assertions.assertThrows(NullPointerException.class, () -> {
new SetDepartmentCommand(null, null);
});
Assertions.assertThrows(NullPointerException.class, () -> {
new SetDepartmentCommand(INDEX_FIRST_PERSON, null);
});
Assertions.assertThrows(NullPointerException.class, () -> {
new SetDepartmentCommand(null, new Department("Junior Management"));
});
}
@Test
public void execute_notLoggedIn_throwsCommandException() {
Assertions.assertThrows(CommandException.class, () -> {
SetDepartmentCommand sd = new SetDepartmentCommand(INDEX_FIRST_PERSON,
new Department("Junior Management"));
sd.execute(model, commandHistory);
}, SessionManager.NOT_LOGGED_IN);
}
@Test
public void execute_invalidPersonIndexFilteredList_failure() throws CommandException {
showPersonAtIndex(model, INDEX_FIRST_PERSON);
Index outOfBoundIndex = INDEX_SECOND_PERSON;
// ensures that outOfBoundIndex is still in bounds of address book list
assertTrue(outOfBoundIndex.getZeroBased() < model.getAddressBook().getPersonList().size());
LoginCommand loginCommand = new LoginCommand(TypicalPersons.ALICE.getNric(),
TypicalPersons.ALICE.getPassword());
loginCommand.execute(model, commandHistory);
SetDepartmentCommand sd = new SetDepartmentCommand(outOfBoundIndex,
new Department("Junior Management"));
assertCommandFailure(sd, model, commandHistory, Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
}
/**
* After this test method, Alice's Department remains, whereas Daniel's Department will become Junior Management.
*/
@Test
public void execute_setDepartmentOfFourthPerson_success() throws CommandException {
SessionManager.getInstance(model).destroy();
model = new ModelManager(TypicalPersons.getTypicalAddressBook(), new UserPrefs());
LoginCommand loginCommand = new LoginCommand(TypicalPersons.ALICE.getNric(),
TypicalPersons
```
<Overlap Ratio: 0.981629769194536>

---

--- 46 --
Question ID: 7057aadca3164ef8094550db3fa34a8f5570fd57
Original Code:
```
public class CompareTwoBstLInkedListMap {
    private static double testMap(Map<String, Integer> map, String filename) {

        long startTime = System.nanoTime();

        System.out.println(filename);
        ArrayList<String> words = new ArrayList<>();
        if (FileOperation.readFile(filename, words)) {
            System.out.println("Total words: " + words.size());

            for (String word : words) {
                if (map.contains(word))
                    map.set(word, map.get(word) + 1);
                else
                    map.add(word, 1);
            }

            System.out.println("Total different words: " + map.getSize());
            System.out.println("Frequency of PRIDE: " + map.get("pride"));
            System.out.println("Frequency of PREJUDICE: " + map.get("prejudice"));
        }

        long endTime = System.nanoTime();

        return (endTime - startTime) / 1e9;
    }

    public static void main(String[] args) {

        String filename = "pride-and-prejudice.txt";

        BSTMap<String, Integer> bstMap = new BSTMap<>();
        double time1 = testMap(bstMap, filename);
        System.out.println("BST Map: " + time1 + " s");

        System.out.println();

        LinkedListMap<String, Integer> linkedListMap = new LinkedListMap<>();
        double time2 = testMap(linkedListMap, filename);
        System.out.println("Linked List Map: " + time2 + " s");

    }
}
```


Overlapping Code:
```
dListMap {
private static double testMap(Map<String, Integer> map, String filename) {
long startTime = System.nanoTime();
System.out.println(filename);
ArrayList<String> words = new ArrayList<>();
if (FileOperation.readFile(filename, words)) {
System.out.println("Total words: " + words.size());
for (String word : words) {
if (map.contains(word))
map.set(word, map.get(word) + 1);
else
map.add(word, 1);
}
System.out.println("Total different words: " + map.getSize());
System.out.println("Frequency of PRIDE: " + map.get("pride"));
System.out.println("Frequency of PREJUDICE: " + map.get("prejudice"));
}
long endTime = System.nanoTime();
return (endTime - startTime) / 1e9;
}
public static void main(String[] args) {
String filename = "pride-and-prejudice.txt";
BSTMap<String, Integer> bstMap = new BSTMap<>();
double time1 = testMap(bstMap, filename);
System.out.println("BST Map: " + time1 + " s");
System.out.println();
LinkedListMap<String, Integer> linkedListMap = new LinkedListMap<>();
double time2 = testMap(linkedListMap, filename);
System.out.println("Linked List Map: " + time2 + " s");

```
<Overlap Ratio: 0.9700176366843033>

---

--- 47 --
Question ID: c6f564848d36a048ee66efbb3bba56a2b1233f40
Original Code:
```
public class MoodLightSaveSettingsEvent extends MessageHandler
{
    @Override
    public void handle() throws Exception
    {
        Room room = this.client.getHabbo().getHabboInfo().getCurrentRoom();

        if((room.getGuildId() > 0 && room.guildRightLevel(this.client.getHabbo()) < 2) && !room.hasRights(this.client.getHabbo()))
            return;

        int id = this.packet.readInt();
        int backgroundOnly = this.packet.readInt();
        String color = this.packet.readString();
        int intensity = this.packet.readInt();

        for(RoomMoodlightData data : room.getMoodlightData().valueCollection())
        {
            if(data.getId() == id)
            {
                data.setBackgroundOnly(backgroundOnly == 2);
                data.setColor(color);
                data.setIntensity(intensity);
                data.enable();

                for(HabboItem item : room.getRoomSpecialTypes().getItemsOfType(InteractionMoodLight.class))
                {
                    item.setExtradata(data.toString());
                    item.needsUpdate(true);
                    room.updateItem(item);
                    Emulator.getThreading().run(item);
                }
            }
            else
            {
                data.disable();
            }
        }

        room.setNeedsUpdate(true);
        this.client.sendResponse(new MoodLightDataComposer(room.getMoodlightData()));
    }
}
```


Overlapping Code:
```
aveSettingsEvent extends MessageHandler
{
@Override
public void handle() throws Exception
{
Room room = this.client.getHabbo().getHabboInfo().getCurrentRoom();
if((room.getGuildId() > 0 && room.guildRightLevel(this.client.getHabbo()) < 2) && !room.hasRights(this.client.getHabbo()))
return;
int id = this.packet.readInt();
int backgroundOnly = this.packet.readInt();
String color = this.packet.readString();
int intensity = this.packet.readInt();
for(RoomMoodlightData data : room.getMoodlightData().valueCollection())
{
if(data.getId() == id)
{
data.setBackgroundOnly(backgroundOnly == 2);
data.setColor(color);
data.setIntensity(intensity);
data.enable();
for(HabboItem item : room.getRoomSpecialTypes().getItemsOfType(InteractionMoodLight.class))
{
item.setExtradata(data.toString());
item.needsUpdate(true);
room.updateItem(item);
Emulator.getThreading().run(item);
}
}
else
{
data.disable();
}
}
room.setNeedsUpdate(true);
this.client.sendResponse(new MoodLightDataComposer(room.getMoodlightData
```
<Overlap Ratio: 0.9689922480620154>

---

--- 48 --
Question ID: 71d017a0fe026f27a32d2391f1cd2efa785b2f98
Original Code:
```
@Wire
public class BulletSystem extends EntityProcessingSystem {

    @Mapper ComponentMapper<Bullet> sm;
    @Mapper ComponentMapper<Position> pm;
    @Mapper ComponentMapper<Physics> phm;
    @Mapper ComponentMapper<Health> hm;
    @Mapper ComponentMapper<Animation> am;
    public ParticleSystem particleSystem;
    public CombatSystem combatSystem;
    private PlayerSystem playerSystem;

    public BulletSystem() {
        super(Aspect.getAspectForAll(Bullet.class, Position.class, Physics.class));
    }

    private Vector2 tmp = new Vector2();

    @Override
    protected void initialize() {
        particleSystem = world.getSystem(ParticleSystem.class);
        combatSystem = world.getSystem(CombatSystem.class);
        playerSystem = world.getSystem(PlayerSystem.class);
    }

    @Override
    protected void process(Entity e) {
        Position position = pm.get(e);
        Position playerPos = pm.get(ToxUtil.getPlayer());
        Physics physics = phm.get(e);

        // create vector that points from bullet to player;
        int playerX = (int) (playerPos.x + Animation.DEFAULT_SCALE * ToxResource.TILE_SIZE * 0.5f);
        int playerY = (int) (playerPos.y + Animation.DEFAULT_SCALE * ToxResource.TILE_SIZE * 0.5f);
        tmp.set(playerX, playerY)
                .sub(position.x + Animation.DEFAULT_SCALE * 5, position.y + Animation.DEFAULT_SCALE * 5);

        if (tmp.len() > 20) {
            tmp.nor().scl(1200);
            am.get(e).rotation = tmp.angle();
            physics.velocityX = tmp.x;
            physics.velocityY = tmp.y;
        } else {
            particleSystem.explosion(playerX, playerY, Animation.DEFAULT_SCALE * ToxResource.TILE_SIZE);
            if (combatSystem.isAlive(ToxUtil.getPlayer())) {
                combatSystem.damage(ToxUtil.getPlayer(), Math.max(0.1f, hm.get(ToxUtil.getPlayer()).maxHealth / 10));
                if (!combatSystem.isAlive(ToxUtil.getPlayer())) {
                    playerSystem.killPlayer("The Jailer");
                }
            }
            e.deleteFromWorld();
        }
    }
}
```


Overlapping Code:
```
stem extends EntityProcessingSystem {
@Mapper ComponentMapper<Bullet> sm;
@Mapper ComponentMapper<Position> pm;
@Mapper ComponentMapper<Physics> phm;
@Mapper ComponentMapper<Health> hm;
@Mapper ComponentMapper<Animation> am;
public ParticleSystem particleSystem;
public CombatSystem combatSystem;
private PlayerSystem playerSystem;
public BulletSystem() {
super(Aspect.getAspectForAll(Bullet.class, Position.class, Physics.class));
}
private Vector2 tmp = new Vector2();
@Override
protected void initialize() {
particleSystem = world.getSystem(ParticleSystem.class);
combatSystem = world.getSystem(CombatSystem.class);
playerSystem = world.getSystem(PlayerSystem.class);
}
@Override
protected void process(Entity e) {
Position position = pm.get(e);
Position playerPos = pm.get(ToxUtil.getPlayer());
Physics physics = phm.get(e);
// create vector that points from bullet to player;
int playerX = (int) (playerPos.x + Animation.DEFAULT_SCALE * ToxResource.TILE_SIZE * 0.5f);
int playerY = (int) (playerPos.y + Animation.DEFAULT_SCALE * ToxResource.TILE_SIZE * 0.5f);
tmp.set(playerX, playerY)
.sub(position.x + Animation.DEFAULT_SCALE * 5, position.y + Animation.DEFAULT_SCALE * 5);
if (tmp.len() > 20) {
tmp.nor().scl(1200);
am.get(e).rotation = tmp.angle();
physics.velocityX = tmp.x;
physics.velocityY = tmp.y;
} else {
particleSystem.explosion(playerX, playerY, Animation.DEFAULT_SCALE * ToxResource.TILE_SIZE);
if (combatSystem.isAlive(ToxUtil.getPlayer())) {
combatSystem.damage(ToxUtil.getPlayer(), Math.max(0.1f, hm.get(ToxUtil.getPlayer()).maxHealth / 10));
if (!combatSystem.isAlive(ToxUtil.getPlayer())) {
p
```
<Overlap Ratio: 0.9444769140853302>

---

--- 49 --
Question ID: e067db237b92d515800eff0d3dff3e8754e33d3f
Original Code:
```
public final class AuctionableHall extends ClanHall
{
	protected long _paidUntil;
	private final int _grade;
	protected boolean _paid;
	private final int _lease;
	private final int _chRate = 604800000;
	
	public AuctionableHall(StatsSet set)
	{
		super(set);
		_paidUntil = set.getLong("paidUntil");
		_grade = set.getInt("grade");
		_paid = set.getBoolean("paid");
		_lease = set.getInt("lease");
		
		if (getOwnerId() != 0)
		{
			_isFree = false;
			initialyzeTask(false);
			loadFunctions();
		}
	}
	
	/**
	 * @return if clanHall is paid or not
	 */
	public final boolean getPaid()
	{
		return _paid;
	}
	
	/** Return lease */
	@Override
	public final int getLease()
	{
		return _lease;
	}
	
	/** Return PaidUntil */
	@Override
	public final long getPaidUntil()
	{
		return _paidUntil;
	}
	
	/** Return Grade */
	@Override
	public final int getGrade()
	{
		return _grade;
	}
	
	@Override
	public final void free()
	{
		super.free();
		_paidUntil = 0;
		_paid = false;
	}
	
	@Override
	public final void setOwner(L2Clan clan)
	{
		super.setOwner(clan);
		_paidUntil = System.currentTimeMillis();
		initialyzeTask(true);
	}
	
	/**
	 * Initialize Fee Task
	 * @param forced
	 */
	private final void initialyzeTask(boolean forced)
	{
		long currentTime = System.currentTimeMillis();
		if (_paidUntil > currentTime)
		{
			ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _paidUntil - currentTime);
		}
		else if (!_paid && !forced)
		{
			if ((System.currentTimeMillis() + (3600000 * 24)) <= (_paidUntil + _chRate))
			{
				ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), System.currentTimeMillis() + (3600000 * 24));
			}
			else
			{
				ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), (_paidUntil + _chRate) - System.currentTimeMillis());
			}
		}
		else
		{
			ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), 0);
		}
	}
	
	/** Fee Task */
	protected class FeeTask implements Runnable
	{
		private final Logger _log = Logger.getLogger(FeeTask.class.getName());
		
		@Override
		public void run()
		{
			try
			{
				long _time = System.currentTimeMillis();
				
				if (isFree())
				{
					return;
				}
				
				if (_paidUntil > _time)
				{
					ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _paidUntil - _time);
					return;
				}
				
				L2Clan Clan = ClanTable.getInstance().getClan(getOwnerId());
				if (ClanTable.getInstance().getClan(getOwnerId()).getWarehouse().getAdena() >= getLease())
				{
					if (_paidUntil != 0)
					{
						while (_paidUntil <= _time)
						{
							_paidUntil += _chRate;
						}
					}
					else
					{
						_paidUntil = _time + _chRate;
					}
					ClanTable.getInstance().getClan(getOwnerId()).getWarehouse().destroyItemByItemId("CH_rental_fee", Inventory.ADENA_ID, getLease(), null, null);
					ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _paidUntil - _time);
					_paid = true;
					updateDb();
				}
				else
				{
					_paid = false;
					if (_time > (_paidUntil + _chRate))
					{
						if (ClanHallManager.getInstance().loaded())
						{
							AuctionManager.getInstance().initNPC(getId());
							ClanHallManager.getInstance().setFree(getId());
							Clan.broadcastToOnlineMembers(SystemMessage.getSystemMessage(SystemMessageId.THE_CLAN_HALL_FEE_IS_ONE_WEEK_OVERDUE_THEREFORE_THE_CLAN_HALL_OWNERSHIP_HAS_BEEN_REVOKED));
						}
						else
						{
							ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), 3000);
						}
					}
					else
					{
						updateDb();
						SystemMessage sm = SystemMessage.getSystemMessage(SystemMessageId.PAYMENT_FOR_YOUR_CLAN_HALL_HAS_NOT_BEEN_MADE_PLEASE_MAKE_PAYMENT_TO_YOUR_CLAN_WAREHOUSE_BY_S1_TOMORROW);
						sm.addInt(getLease());
						Clan.broadcastToOnlineMembers(sm);
						if ((_time + (3600000 * 24)) <= (_paidUntil + _chRate))
						{
							ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _time + (3600000 * 24));
						}
						else
						{
							ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), (_paidUntil + _chRate) - _time);
						}
						
					}
				}
			}
			catch (Exception e)
			{
				_log.log(Level.SEVERE, "", e);
			}
		}
	}
	
	@Override
	public final void updateDb()
	{
		try (Connection con = ConnectionFactory.getInstance().getConnection();
			PreparedStatement ps = con.prepareStatement("UPDATE clanhall SET ownerId=?, paidUntil=?, paid=? WHERE id=?"))
		{
			ps.setInt(1, getOwnerId());
			ps.setLong(2, getPaidUntil());
			ps.setInt(3, (getPaid()) ? 1 : 0);
			ps.setInt(4, getId());
			ps.execute();
		}
		catch (Exception e)
		{
			_log.log(Level.WARNING, "Exception: updateOwnerInDB(L2Clan clan): " + e.getMessage(), e);
		}
	}
}
```


Overlapping Code:
```
al class AuctionableHall extends ClanHall
{
protected long _paidUntil;
private final int _grade;
protected boolean _paid;
private final int _lease;
private final int _chRate = 604800000;

public AuctionableHall(StatsSet set)
{
super(set);
_paidUntil = set.getLong("paidUntil");
_grade = set.getInt("grade");
_paid = set.getBoolean("paid");
_lease = set.getInt("lease");

if (getOwnerId() != 0)
{
_isFree = false;
initialyzeTask(false);
loadFunctions();
}
}

/**
* @return if clanHall is paid or not
*/
public final boolean getPaid()
{
return _paid;
}

/** Return lease */
@Override
public final int getLease()
{
return _lease;
}

/** Return PaidUntil */
@Override
public final long getPaidUntil()
{
return _paidUntil;
}

/** Return Grade */
@Override
public final int getGrade()
{
return _grade;
}

@Override
public final void free()
{
super.free();
_paidUntil = 0;
_paid = false;
}

@Override
public final void setOwner(L2Clan clan)
{
super.setOwner(clan);
_paidUntil = System.currentTimeMillis();
initialyzeTask(true);
}

/**
* Initialize Fee Task
* @param forced
*/
private final void initialyzeTask(boolean forced)
{
long currentTime = System.currentTimeMillis();
if (_paidUntil > currentTime)
{
ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _paidUntil - currentTime);
}
else if (!_paid && !forced)
{
if ((System.currentTimeMillis() + (3600000 * 24)) <= (_paidUntil + _chRate))
{
ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), System.currentTimeMillis() + (3600000 * 24));
}
else
{
ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), (_paidUntil + _chRate) - System.currentTimeMillis());
}
}
else
{
ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), 0);
}
}

/** Fee Task */
protected class FeeTask implements Runnable
{
private final Logger _log = Logger.getLogger(FeeTask.class.getName());

@Override
public void run()
{
try
{
long _time = System.currentTimeMillis();

if (isFree())
{
return;
}

if (_paidUntil > _time)
{
ThreadPoolManager.getInstance().scheduleGeneral(new FeeTask(), _paidUntil - _time);
return;
}

L2Clan Clan = ClanTable.getInstance().getClan(getOwnerId());
if (ClanTable.getInstance().getClan(getOwnerId()).getWarehouse().getAdena() >= getLease())

```
<Overlap Ratio: 0.9911150599733451>

---

--- 50 --
Question ID: 04a80de7558ca38cbf07beb9a98e61050884caee
Original Code:
```
public abstract class BaseDatum implements Datum, Cloneable {

	private static final ConcurrentMap<Class<?>, String[]> DATUM_TYPE_CACHE = new ConcurrentHashMap<Class<?>, String[]>();

	private String sourceId = null;
	private Date created = null;
	private Date uploaded = null;

	/**
	 * Default constructor.
	 */
	public BaseDatum() {
		super();
		setSourceId("");
	}

	/**
	 * {@inheritDoc}
	 * 
	 * <p>
	 * This method returns the result of {@link #createSimpleMap()}.
	 * </p>
	 * 
	 * @since 1.2
	 */
	@Override
	final public Map<String, ?> asSimpleMap() {
		return createSimpleMap();
	}

	/**
	 * Create a map of simple property data out of this object.
	 * 
	 * <p>
	 * This method will populate the properties of this class and the
	 * {@link Datum#DATUM_TYPE_PROPERTY} and {@link Datum#DATUM_TYPES_PROPERTY}
	 * properties. It will then call {@link #getSampleData()} and add all those
	 * values to the returned result.
	 * </p>
	 * 
	 * @return a map of simple property data
	 * @since 1.2
	 */
	protected Map<String, Object> createSimpleMap() {
		Map<String, Object> map = new LinkedHashMap<String, Object>();
		if ( created != null ) {
			map.put("created", created.getTime());
		}
		if ( sourceId != null ) {
			map.put("sourceId", sourceId);
		}
		String[] datumTypes = getDatumTypes(getClass());
		if ( datumTypes != null && datumTypes.length > 0 ) {
			map.put(DATUM_TYPE_PROPERTY, datumTypes[0]);
			map.put(DATUM_TYPES_PROPERTY, datumTypes);
		}
		if ( uploaded != null ) {
			map.put("uploaded", uploaded.getTime());
		}
		Map<String, ?> sampleData = getSampleData();
		if ( sampleData != null ) {
			map.putAll(sampleData);
		}
		return map;
	}

	/**
	 * Get an array of datum types for a class.
	 * 
	 * <p>
	 * This method caches the results for performance.
	 * </p>
	 * 
	 * @param clazz
	 *        the datum class to get the types for
	 * @return the types
	 * @since 1.2
	 */
	public static String[] getDatumTypes(Class<?> clazz) {
		String[] result = DATUM_TYPE_CACHE.get(clazz);
		if ( result != null ) {
			return result;
		}
		Set<Class<?>> interfaces = ClassUtils.getAllNonJavaInterfacesForClassAsSet(clazz);
		result = new String[interfaces.size()];
		int i = 0;
		for ( Class<?> intf : interfaces ) {
			result[i] = intf.getName();
			i++;
		}
		DATUM_TYPE_CACHE.putIfAbsent(clazz, result);
		return result;
	}

	@Override
	public Object clone() {
		try {
			return super.clone();
		} catch ( CloneNotSupportedException e ) {
			// should never get here
			throw new RuntimeException(e);
		}
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((created == null) ? 0 : created.hashCode());
		result = prime * result + ((sourceId == null) ? 0 : sourceId.hashCode());
		return result;
	}

	/**
	 * Compare for equality.
	 * 
	 * <p>
	 * This method compares the {@code created} and {@code sourceId} values for
	 * equality.
	 * </p>
	 * 
	 * @return <em>true</em> if the objects are equal
	 */
	@Override
	public boolean equals(Object obj) {
		if ( this == obj ) {
			return true;
		}
		if ( obj == null ) {
			return false;
		}
		if ( getClass() != obj.getClass() ) {
			return false;
		}
		BaseDatum other = (BaseDatum) obj;
		if ( created == null ) {
			if ( other.created != null ) {
				return false;
			}
		} else if ( !(created.getTime() == other.created.getTime()) ) {
			return false;
		}
		if ( sourceId == null ) {
			if ( other.sourceId != null ) {
				return false;
			}
		} else if ( !sourceId.equals(other.sourceId) ) {
			return false;
		}
		return true;
	}

	@Override
	public Map<String, ?> getSampleData() {
		return null;
	}

	@Override
	public Date getCreated() {
		return created;
	}

	public void setCreated(Date created) {
		this.created = created;
	}

	@Override
	public String getSourceId() {
		return sourceId;
	}

	public void setSourceId(String sourceId) {
		this.sourceId = sourceId;
	}

	@Override
	public Date getUploaded() {
		return uploaded;
	}

	public void setUploaded(Date uploaded) {
		this.uploaded = uploaded;
	}

}
```


Overlapping Code:
```
um implements Datum, Cloneable {
private static final ConcurrentMap<Class<?>, String[]> DATUM_TYPE_CACHE = new ConcurrentHashMap<Class<?>, String[]>();
private String sourceId = null;
private Date created = null;
private Date uploaded = null;
/**
* Default constructor.
*/
public BaseDatum() {
super();
setSourceId("");
}
/**
* {@inheritDoc}
* 
* <p>
* This method returns the result of {@link #createSimpleMap()}.
* </p>
* 
* @since 1.2
*/
@Override
final public Map<String, ?> asSimpleMap() {
return createSimpleMap();
}
/**
* Create a map of simple property data out of this object.
* 
* <p>
* This method will populate the properties of this class and the
* {@link Datum#DATUM_TYPE_PROPERTY} and {@link Datum#DATUM_TYPES_PROPERTY}
* properties. It will then call {@link #getSampleData()} and add all those
* values to the returned result.
* </p>
* 
* @return a map of simple property data
* @since 1.2
*/
protected Map<String, Object> createSimpleMap() {
Map<String, Object> map = new LinkedHashMap<String, Object>();
if ( created != null ) {
map.put("created", created.getTime());
}
if ( sourceId != null ) {
map.put("sourceId", sourceId);
}
String[] datumTypes = getDatumTypes(getClass());
if ( datumTypes != null && datumTypes.length > 0 ) {
map.put(DATUM_TYPE_PROPERTY, datumTypes[0]);
map.put(DATUM_TYPES_PROPERTY, datumTypes);
}
if ( uploaded != null ) {
map.put("uploaded", uploaded.getTime());
}
Map<String, ?> sampleData = getSampleData();
if ( sampleData != null ) {
map.putAll(sampleData);
}
return map;
}
/**
* Get an array of datum types for a class.
* 
* <p>
* This method caches the results for performance.
* </p>
* 
* @param clazz
* the datum class to get the types for
* @return the types
* @since 1.2
*/
public static String[] getDatumTypes(Class<?> clazz) {
String[] result = DATUM_TYPE_CACHE.get(clazz);
if ( result != null ) {
return result;
}
Set<Class<?>> interfaces = ClassUtils.getAllNonJavaInterfacesForClassAsSet(clazz);
result = new String[interfaces.size()];
int i = 0;
for ( Class<?> intf : interfaces ) {
result[i] = intf.getName();
i++;
}
DATUM_TYPE_CACHE.putIfAbsent(clazz, result);
return result;
}
@Override
public Object clone() {
try {
return super.clone();
} catch ( CloneNotSupportedException e ) {
// should never get here
throw
```
<Overlap Ratio: 0.9856895056374675>

---

--- 51 --
Question ID: 6364c7e6510e3360dd4dbb7c6351aa86a28aea3b
Original Code:
```
public class SelectionSort {
        
    private void swap(int array[] , int x , int y){
        int temp = array[x];
        array[x] = array[y];
        array[y] = temp;
    }
    
    public void sorting(int array[]){
        //i is every item in array 
        for(int i = 0 ; i < array.length ; i++){
            //Start after i to all right items
            for(int a = i+1 ; a < array.length ; a++){
                //if Next Item less than i will swap ^_^
                if(array[i] > array[a]){
                    swap(array,i,a);
                }
            }
        }
}
}
```


Overlapping Code:
```
ap(int array[] , int x , int y){
int temp = array[x];
array[x] = array[y];
array[y] = temp;
}

public void sorting(int array[]){
//i is every item in array 
for(int i = 0 ; i < array.length ; i++){
//Start after i to all right items
for(int a = i+1 ; a < array.length ; a++){
//if Next Item less than i will swap ^_^
if(array[i] > array[a]){
swap(arr
```
<Overlap Ratio: 0.847457627118644>

---

--- 52 --
Question ID: 5e808c8ac63aa4afc64c02c3a32d490251540631
Original Code:
```
public class EntidadeUtilsTest {
	
	@Test
	public void deveValidarEntidadeOuCodigoNulos() {
		assertTrue(EntidadeUtils.isNull(null));
		assertTrue(EntidadeUtils.isNull(new EntidadeUtilsTestEntidade(null)));
		assertFalse(EntidadeUtils.isNull(new EntidadeUtilsTestEntidade(1L)));
	}
	
	@Test
	public void deveValidarEntidadeOuCodigoNaoNulos() {
		assertFalse(EntidadeUtils.isNotNull(null));
		assertFalse(EntidadeUtils.isNotNull(new EntidadeUtilsTestEntidade(null)));
		assertTrue(EntidadeUtils.isNotNull(new EntidadeUtilsTestEntidade(1L)));
	}
	
	private class EntidadeUtilsTestEntidade implements Entidade {
		
		private static final long serialVersionUID = 1L;
		
		private Long id;
		
		public EntidadeUtilsTestEntidade(Long id) {
			this.id = id;
		}
		
		@Override
		public Long getId() {
			return id;
		}
		
		@Override
		public void setId(Long id) {
			this.id = id;
		}
		
	}
	
}
```


Overlapping Code:
```


@Test
public void deveValidarEntidadeOuCodigoNulos() {
assertTrue(EntidadeUtils.isNull(null));
assertTrue(EntidadeUtils.isNull(new EntidadeUtilsTestEntidade(null)));
assertFalse(EntidadeUtils.isNull(new EntidadeUtilsTestEntidade(1L)));
}

@Test
public void deveValidarEntidadeOuCodigoNaoNulos() {
assertFalse(EntidadeUtils.isNotNull(null));
assertFalse(EntidadeUtils.isNotNull(new EntidadeUtilsTestEntidade(null)));
assertTrue(EntidadeUtils.isNotNull(new EntidadeUtilsTestEntidade(1L)));
}

private class EntidadeUtilsTestEntidade implements Entidade {

private static final long serialVersionUID = 1L;

private Long id;

public EntidadeUtilsTestEntidade(Long id) {
this.id = id;
}

@Override
public Long getId() {
return id;
}

@Override
public void setId(Long id) {
this.id = id;
}


```
<Overlap Ratio: 0.9562575941676792>

---

--- 53 --
Question ID: 311434067375bc2f1fdcff4a7dce4ef006ffe3bc
Original Code:
```
public class IfStatement extends Statement {

	private final Expression condition;
	private final Statement trueStatement;
	private final Statement falseStatement;

	public IfStatement(int start, int end, Expression condition, Statement trueStatement, Statement falseStatement) {
		super(start, end);

		assert condition != null && trueStatement != null;
		this.condition = condition;
		this.trueStatement = trueStatement;
		this.falseStatement = falseStatement;
	}

	public void traverse(ASTVisitor visitor) throws Exception {
		final boolean visit = visitor.visit(this);
		if (visit) {
			condition.traverse(visitor);
			trueStatement.traverse(visitor);
			if (falseStatement != null) {
				falseStatement.traverse(visitor);
			}
		}
		visitor.endvisit(this);
	}

	public int getKind() {
		return ASTNodeKinds.IF_STATEMENT;
	}

	public Expression getCondition() {
		return condition;
	}

	public Statement getFalseStatement() {
		return falseStatement;
	}

	public Statement getTrueStatement() {
		return trueStatement;
	}

	/**
	 * We don't print anything - we use {@link ASTPrintVisitor} instead
	 */
	public final void printNode(CorePrinter output) {
	}

	public String toString() {
		return ASTPrintVisitor.toXMLString(this);
	}
}
```


Overlapping Code:
```
public class IfStatement extends Statement {
private final Expression condition;
private final Statement trueStatement;
private final Statement falseStatement;
public IfStatement(int start, int end, Expression condition, Statement trueStatement, Statement falseStatement) {
super(start, end);
assert condition != null && trueStatement != null;
this.condition = condition;
this.trueStatement = trueStatement;
this.falseStatement = falseStatement;
}
public void traverse(ASTVisitor visitor) throws Exception {
final boolean visit = visitor.visit(this);
if (visit) {
condition.traverse(visitor);
trueStatement.traverse(visitor);
if (falseStatement != null) {
falseStatement.traverse(visitor);
}
}
visitor.endvisit(this);
}
public int getKind() {
return ASTNodeKinds.IF_STATEMENT;
}
public Expression getCondition() {
return condition;
}
public Statement getFalseStatement() {
return falseStatement;
}
public Statement getTrueStatement() {
return trueStatement;
}
/**
* We don't print anything - we use {@link ASTPrintVisitor} instead
*/
public final void printNode(CorePrinter output) {
}
public String toString() {
return ASTPrintVisitor.toXMLString(this);
}
}
```
<Overlap Ratio: 1.0>

---

--- 54 --
Question ID: c6a4705a17638f6fa4149a96356a8185e4118e3c
Original Code:
```
public class GetAttribute extends SeleneseCommand<String> {
  private ElementFinder finder;

  public GetAttribute(ElementFinder finder) {
    this.finder = finder;
  }

  @Override
  protected String handleSeleneseCommand(WebDriver driver, String attributeLocator, String ignored) {
    int attributePos = attributeLocator.lastIndexOf("@");
    String elementLocator = attributeLocator.substring(0, attributePos);
    String attributeName = attributeLocator.substring(attributePos + 1);

    // Find the element.
    WebElement element = finder.findElement(driver, elementLocator);
    return element.getAttribute(attributeName);
  }
}
```


Overlapping Code:
```
ublic class GetAttribute extends SeleneseCommand<String> {
private ElementFinder finder;
public GetAttribute(ElementFinder finder) {
this.finder = finder;
}
@Override
protected String handleSeleneseCommand(WebDriver driver, String attributeLocator, String ignored) {
int attributePos = attributeLocator.lastIndexOf("@");
String elementLocator = attributeLocator.substring(0, attributePos);
String attributeName = attributeLocator.substring(attributePos + 1);
// Find the element.
WebElement element = finder.findElement(driver, elementLocator);
return element.getAttribute(attributeName);
}
}
```
<Overlap Ratio: 0.9983136593591906>

---

--- 55 --
Question ID: 0356139950e5a62f7f8bfe6a4c83f9528ef9d54d
Original Code:
```
public class JobCopyParticipant extends CopyParticipant {

	private IFile modifiedResource;
	private static List<IFile> copiedFileList;
	private static String copyToPath;
	private static List<IFile> previousJobFiles;
	


	@Override
	protected boolean initialize(Object element) {
		if (element instanceof IFile) {
			this.modifiedResource = (IFile) element;
			if (modifiedResource == null && StringUtils.isEmpty(modifiedResource.toString())) {
				return false;
			}
		}
		return true;
	}

	@Override
	public String getName() {
		return null;
	}

	@Override
	public RefactoringStatus checkConditions(IProgressMonitor pm, CheckConditionsContext context)
			throws OperationCanceledException {
		return new RefactoringStatus();
	}

	@Override
	public Change createChange(IProgressMonitor pm) throws CoreException, OperationCanceledException {
		
		copyToPath=getArguments().getDestination().toString();
		IWorkspaceRoot workSpaceRoot = ResourcesPlugin.getWorkspace().getRoot();
		IProject project = workSpaceRoot.getProject(copyToPath.split("/")[1]);
		IFolder jobFolder = project.getFolder(copyToPath.substring(copyToPath.indexOf('/', 2)));
		previousJobFiles=new ArrayList<>();
		for (IResource iResource : jobFolder.members()) {
			if (!(iResource instanceof IFolder)) {
				IFile iFile = (IFile) iResource;
				 if (iFile.getFileExtension().equalsIgnoreCase(Messages.JOB_EXT)) {
					 previousJobFiles.add(iFile);
				 }
			}
		}
		copiedFileList.add(modifiedResource);
		return null;
	}

	
	@Override
	public Change createPreChange(IProgressMonitor pm) throws CoreException, OperationCanceledException {
		return super.createPreChange(pm);
	}


	public static String getCopyToPath() {
		return copyToPath;
	}


	
	public static List<IFile> getCopiedFileList() {
		return copiedFileList;
	}

	public static void setCopiedFileList(List<IFile> copiedFileList) {
		JobCopyParticipant.copiedFileList = copiedFileList;
	}

	public static void cleanUpStaticResourcesAfterPasteOperation()
	{
		copyToPath=null;
		copiedFileList=null;
		previousJobFiles=null;
	}
	
	public static List<IFile> getPreviousJobFiles() {
		return previousJobFiles;
	}


	
}
```


Overlapping Code:
```
JobCopyParticipant extends CopyParticipant {
private IFile modifiedResource;
private static List<IFile> copiedFileList;
private static String copyToPath;
private static List<IFile> previousJobFiles;

@Override
protected boolean initialize(Object element) {
if (element instanceof IFile) {
this.modifiedResource = (IFile) element;
if (modifiedResource == null && StringUtils.isEmpty(modifiedResource.toString())) {
return false;
}
}
return true;
}
@Override
public String getName() {
return null;
}
@Override
public RefactoringStatus checkConditions(IProgressMonitor pm, CheckConditionsContext context)
throws OperationCanceledException {
return new RefactoringStatus();
}
@Override
public Change createChange(IProgressMonitor pm) throws CoreException, OperationCanceledException {

copyToPath=getArguments().getDestination().toString();
IWorkspaceRoot workSpaceRoot = ResourcesPlugin.getWorkspace().getRoot();
IProject project = workSpaceRoot.getProject(copyToPath.split("/")[1]);
IFolder jobFolder = project.getFolder(copyToPath.substring(copyToPath.indexOf('/', 2)));
previousJobFiles=new ArrayList<>();
for (IResource iResource : jobFolder.members()) {
if (!(iResource instanceof IFolder)) {
IFile iFile = (IFile) iResource;
if (iFile.getFileExtension().equalsIgnoreCase(Messages.JOB_EXT)) {
previousJobFiles.add(iFile);
}
}
}
copiedFileList.add(modifiedResource);
return null;
}

@Override
public Change createPreChange(IProgressMonitor pm) throws CoreException, OperationCanceledException {
return super.createPreChange(pm);
}
public static String getCopyToPath() {
return copyToPath;
}

public static List<IFile> getCopiedFileList() {
return copiedFileList;
}
public static void setCopiedFileList(List<IFile> copiedFileList) {
JobCopyParticipant.copiedFileList = copiedFileList;
}
public static void cleanUpStaticResourcesAfterPasteOperation()
{
copyToPath=null;
copiedFileList=null;
previousJobFiles=null;
}

public static List<IFile> getPrevi
```
<Overlap Ratio: 0.9711155378486056>

---

--- 56 --
Question ID: a81b80b6816be37cc18949c1f01cbf7ab1925db6
Original Code:
```
@SideOnly(Side.CLIENT)
@Mod.EventBusSubscriber(value = Side.CLIENT, modid = ArcaneConstants.MODID)
public class ClientEvents
{
	@SubscribeEvent
	public static void onClientTick(TickEvent.ClientTickEvent event)
	{
		Minecraft mc = Minecraft.getMinecraft();
		EntityPlayer player = mc.player;

		if(mc.world == null || mc.player == null)
			return;

		if(KeyBindings.keySpellbook.isPressed())
			mc.displayGuiScreen(new GuiSpellBook());

		PlayerData data = Minecraft.getMinecraft().player.getCapability(PlayerData.CAPABILITY, null);
		Spell sp = data.getSelectedSpells()[data.getSelectedIndex()];
		if(sp != null)
		{
			ClientUtil.getMouseOverExtended(sp.getSpellReach());
		}
		int maxDawTime = 5000;
		if(KeyBindings.keyCastSpell.isPressed())
		{
			if(sp != null && !data.isHoldingCast())
			{
				SpellUtil.castSpellPress(sp, player);
				ArcaneNetwork.NETWORK_INSTANCE.sendToServer(new PacketSendCastSpell(sp.getRegistryName().toString()));

				GuiManaBar.drawTime = maxDawTime;
			}
		}
		else if(KeyBindings.keyCastSpell.isKeyDown())
		{
			if(sp != null)
			{
				if(data.getHoldTime() == -1)
					data.setHoldTime(mc.world.getWorldTime());

				if(!data.isHoldingCast())
				{
					data.setHoldingCast(true);
					ArcaneNetwork.NETWORK_INSTANCE.sendToServer(new PacketSendCastHold(sp.getRegistryName().toString()));
				}
				GuiManaBar.drawTime = maxDawTime;
			}
		}

		if(data.isHoldingCast() && !KeyBindings.keyCastSpell.isKeyDown())
		{
			if(sp != null)
			{
				if(data.getHoldTime() == -1)
				{
					data.setHoldTime(-1);
					data.setHoldingCast(false);

					return;
				}
				long holdTime = mc.player.getEntityWorld().getTotalWorldTime() -  data.getHoldTime();
				SpellUtil.castSpellHoldRelease(sp, player, holdTime);
				ArcaneNetwork.NETWORK_INSTANCE.sendToServer(new PacketSendCastRelease(sp.getRegistryName().toString()));
				data.setHoldTime(-1);
				data.setHoldingCast(false);

				GuiManaBar.drawTime = maxDawTime;
			}
		}
	}

	@SubscribeEvent
	public static void onTextureStitchPre(TextureStitchEvent.Pre event)
	{
		for(Spell sp : SpellRegistry.SPELL_REGISTRY.getValues())
		{
			if(sp.getIconType() == Spell.IconType.TEXTURE)
			{
				TextureAtlasSprite spr = event.getMap().registerSprite(sp.getIconTexture());
				sp.setAtlasSprite(spr);
			}
		}
	}

	@SubscribeEvent
	public static void onHandRender(RenderHandEvent event)
	{
		PlayerData data = Minecraft.getMinecraft().player.getCapability(PlayerData.CAPABILITY, null);

		boolean showTime = Minecraft.getMinecraft().world.getTotalWorldTime() - data.getHoldTime() >= 2;
		if(data.isHoldingCast() && Minecraft.getMinecraft().gameSettings.thirdPersonView == 0 && !Minecraft.getMinecraft().gameSettings.hideGUI && showTime)
		{
			event.setCanceled(true);
			Minecraft mc = Minecraft.getMinecraft();
			AbstractClientPlayer pla = mc.player;

			float e = (float) (((Math.sin((mc.world.getTotalWorldTime()) / 2) * (Math.PI / 20)))) - mc.player.swingProgress;
			mc.getItemRenderer().renderItemInFirstPerson(pla, event.getPartialTicks(), 0, EnumHand.MAIN_HAND, 0, ItemStack.EMPTY, e);
		}
	}
}
```


Overlapping Code:
```
SideOnly(Side.CLIENT)
@Mod.EventBusSubscriber(value = Side.CLIENT, modid = ArcaneConstants.MODID)
public class ClientEvents
{
@SubscribeEvent
public static void onClientTick(TickEvent.ClientTickEvent event)
{
Minecraft mc = Minecraft.getMinecraft();
EntityPlayer player = mc.player;
if(mc.world == null || mc.player == null)
return;
if(KeyBindings.keySpellbook.isPressed())
mc.displayGuiScreen(new GuiSpellBook());
PlayerData data = Minecraft.getMinecraft().player.getCapability(PlayerData.CAPABILITY, null);
Spell sp = data.getSelectedSpells()[data.getSelectedIndex()];
if(sp != null)
{
ClientUtil.getMouseOverExtended(sp.getSpellReach());
}
int maxDawTime = 5000;
if(KeyBindings.keyCastSpell.isPressed())
{
if(sp != null && !data.isHoldingCast())
{
SpellUtil.castSpellPress(sp, player);
ArcaneNetwork.NETWORK_INSTANCE.sendToServer(new PacketSendCastSpell(sp.getRegistryName().toString()));
GuiManaBar.drawTime = maxDawTime;
}
}
else if(KeyBindings.keyCastSpell.isKeyDown())
{
if(sp != null)
{
if(data.getHoldTime() == -1)
data.setHoldTime(mc.world.getWorldTime());
if(!data.isHoldingCast())
{
data.setHoldingCast(true);
ArcaneNetwork.NETWORK_INSTANCE.sendToServer(new PacketSendCastHold(sp.getRegistryName().toString()));
}
GuiManaBar.drawTime = maxDawTime;
}
}
if(data.isHoldingCast() && !KeyBindings.keyCastSpell.isKeyDown())
{
if(sp != null)
{
if(data.getHoldTime() == -1)
{
data.setHoldTime(-1);
data.setHoldingCast(false);
return;
}
long holdTime = mc.player.getEntityWorld().getTotalWorldTime() - data.getHoldTime();
SpellUtil.castSpellHoldRelease(sp, player, holdTime);
ArcaneNetwork.NETWORK_INSTANCE.sendToServer(new PacketSendCastRelease(sp.getRegistryName().toString()));
data.setHoldTime(-1);
data.setHoldingCast(false);
GuiManaBar.drawTime = maxDawTime;
}
}
}
@SubscribeEvent
public static void onTextureStitchPre(TextureStitchEvent.Pre event)
{
for(Spell sp : SpellRegistry.SPELL_REGISTRY.getValues())
{
if(sp.getIconType() == Spell.IconType.TEXTURE)
{
TextureAtlasSprite spr = event.getMap().registerSprite(sp.getIconTexture());
sp.setAtlasSprite(spr);
}
}
}
@SubscribeEvent
public static void onHandRender(RenderHandEvent event)
{
PlayerData data = Minecraft.getMinecraft().player.getCapability(PlayerData.CAPABILITY, null);

```
<Overlap Ratio: 0.9846288976723759>

---

--- 57 --
Question ID: e39463d3d0481588ce4b9fabc095665bf256d3e5
Original Code:
```
public class MediaRetrieverService extends Service {

    private static final String TAG = "MediaRetrieverService";

    private static final int TIMEOUT_MS = 6000;
    private final Handler mHandler = new Handler() {
        public void handleMessage(Message msg) {
            Runtime.getRuntime().exit(-1);
        }
    };

    private final IBinder mBinder = new IMediaRetrieverService.Stub() {
        public MediaMetadata getMetadata(String path) {
            return MediaRetrieverService.this.getMetadata(path);
        }
    };

    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    public MediaMetadata getMetadata(String path) {
        mHandler.sendEmptyMessageDelayed(0, TIMEOUT_MS);
        IMediaMetadataRetriever retriever = MediaFactory.createMetadataRetriever(this);
        try {
            retriever.setDataSource(path);
            return retriever.getMediaMetadata();
        } catch (Throwable t) {
            // something failed, return null instead
            return null;
        } finally {
            mHandler.removeMessages(0);
            try {
                retriever.release();
            } catch (Throwable t) {
                // Ignore failures while cleaning up.
            }
        }
    }

    public int onStartCommand(Intent intent, int flags, int startId) {
        super.onStartCommand(intent, flags, startId);
        return START_NOT_STICKY;
    }

}
```


Overlapping Code:
```
 MediaRetrieverService extends Service {
private static final String TAG = "MediaRetrieverService";
private static final int TIMEOUT_MS = 6000;
private final Handler mHandler = new Handler() {
public void handleMessage(Message msg) {
Runtime.getRuntime().exit(-1);
}
};
private final IBinder mBinder = new IMediaRetrieverService.Stub() {
public MediaMetadata getMetadata(String path) {
return MediaRetrieverService.this.getMetadata(path);
}
};
@Override
public IBinder onBind(Intent intent) {
return mBinder;
}
public MediaMetadata getMetadata(String path) {
mHandler.sendEmptyMessageDelayed(0, TIMEOUT_MS);
IMediaMetadataRetriever retriever = MediaFactory.createMetadataRetriever(this);
try {
retriever.setDataSource(path);
return retriever.getMediaMetadata();
} catch (Throwable t) {
// something failed, return null instead
return null;
} finally {
mHandler.removeMessages(0);
try {
retriever.release();
} catch (Throwable t) {
// Ignore failures while cleaning up.
}
}
}
public int onStartCommand(Intent intent, int flags, int startId) {
super.onStartCommand(intent, flags, startId);
return START_NOT_STICKY;
}

```
<Overlap Ratio: 0.9884751773049646>

---

--- 58 --
Question ID: 5e039a1cd824f069304af157c77c9d997b7f3a9a
Original Code:
```
public class LogHelper
{
    private static Consumer<String> onNewLogEntry = null;

    public static void log(LogLevel level, String message, Object... args)
    {
        logInternal(level, message, args);
    }

    public static void log(Exception ex)
    {
        logInternal(LogLevel.ERROR, "%s: %s", ex.getClass().getName(), ex.getLocalizedMessage());
    }

    private static void logInternal(LogLevel level, String message, Object... args)
    {
        String m = String.format(message, args);
        String logMessage = String.format("%s [%s]: %s", ZonedDateTime.now().toLocalTime(), level.toString(), m);

        System.out.println(logMessage);
        if (onNewLogEntry != null)
        {
            onNewLogEntry.accept(logMessage);
        }
    }

    public static void setOnNewLogEntry(Consumer<String> onNewLogEntry)
    {
        LogHelper.onNewLogEntry = onNewLogEntry;
    }
}
```


Overlapping Code:
```
ogHelper
{
private static Consumer<String> onNewLogEntry = null;
public static void log(LogLevel level, String message, Object... args)
{
logInternal(level, message, args);
}
public static void log(Exception ex)
{
logInternal(LogLevel.ERROR, "%s: %s", ex.getClass().getName(), ex.getLocalizedMessage());
}
private static void logInternal(LogLevel level, String message, Object... args)
{
String m = String.format(message, args);
String logMessage = String.format("%s [%s]: %s", ZonedDateTime.now().toLocalTime(), level.toString(), m);
System.out.println(logMessage);
if (onNewLogEntry != null)
{
onNewLogEntry.accept(logMessage);
}
}
public static void setOnNewLogEntry(Consumer<String> onNewLogEntry
```
<Overlap Ratio: 0.9186351706036745>

---

--- 59 --
Question ID: 922f440422cac05f1d27c4df5769a8a5ccdcdbf0
Original Code:
```
@SuppressWarnings("deprecation")
public class DeployContract extends AbstractSampler implements Constants {
	private static final long serialVersionUID = 1L;
	
	public boolean isUseCorrelatedData() {
		return getPropertyAsBoolean("useCorrelatedData");
	}

	public void setUseCorrelatedData(boolean useCorrelatedData) {
		setProperty("useCorrelatedData", useCorrelatedData);
	}
	
	public String getBinStr() {
		return getPropertyAsString(BINCODE, "");
	}
	
	public void setBinStr(String binStr) {
		setProperty(BINCODE, binStr);
	}
	
	public String getGas() {
		return getPropertyAsString("gas", "");
	}
	
	public void setGas(String gas) {
		setProperty("gas", gas);
	}
	
	public String getFromUser() {
		return getPropertyAsString("fromUser", "");
	}
	
	public void setFromUser(String fromUser) {
		setProperty("fromUser", fromUser);
	}
	
	@Override
	public SampleResult sample(Entry arg0) {
		SampleResult result = new SampleResult();
		result.setSampleLabel(getName());
		try {
			String binStr, gas;
			if (isUseCorrelatedData()) {
				JMeterVariables vars = JMeterContextService.getContext().getVariables();
				binStr = (vars.get("binStr") == null) ? "null" : vars.get("binStr");
				gas = (vars.get("gas") == null) ? "null" : vars.get("gas");
			} else {
				binStr = getBinStr();
				gas= getGas();
			}
			String fromUser = getFromUser();
			
			result.sampleStart();
	        String postData = "{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\":[{\"from\":\"" 
	        		+ fromUser + "\",\"gas\":\"" + gas + "\",\"data\":\"" + binStr + "\"}],\"id\":1003}";
	        result.setRequestHeaders(postData);
	        String responseMsg = EthTestUtil.invokeAPI(null, postData);
	        result.sampleEnd();
	        
	        Object document = Configuration.defaultConfiguration().jsonProvider().parse(responseMsg);
	        try {
	        	JsonPath.read(document, "$.error").toString();  // detect possible error first
	        	result.setResponseCode("400");
				result.setResponseData(responseMsg);
	        } catch (com.jayway.jsonpath.PathNotFoundException e) {
	        	String txHash = JsonPath.read(document, "$.result").toString();
	        	result.setResponseCode("200");
		        result.setSuccessful(true);
				result.setResponseData(responseMsg);
	        	JMeterVariables vars = JMeterContextService.getContext().getVariables();
				vars.put("txHash", txHash);
	        }
		} catch(Exception ex) {
			if (result.getEndTime() == 0) result.sampleEnd(); // avoid twice call sampleEnd()
			result.setResponseCode("500");
			result.setResponseData(ex.getMessage().getBytes());
		}
		
		return result;
	}
	
}
```


Overlapping Code:
```
ation")
public class DeployContract extends AbstractSampler implements Constants {
private static final long serialVersionUID = 1L;

public boolean isUseCorrelatedData() {
return getPropertyAsBoolean("useCorrelatedData");
}
public void setUseCorrelatedData(boolean useCorrelatedData) {
setProperty("useCorrelatedData", useCorrelatedData);
}

public String getBinStr() {
return getPropertyAsString(BINCODE, "");
}

public void setBinStr(String binStr) {
setProperty(BINCODE, binStr);
}

public String getGas() {
return getPropertyAsString("gas", "");
}

public void setGas(String gas) {
setProperty("gas", gas);
}

public String getFromUser() {
return getPropertyAsString("fromUser", "");
}

public void setFromUser(String fromUser) {
setProperty("fromUser", fromUser);
}

@Override
public SampleResult sample(Entry arg0) {
SampleResult result = new SampleResult();
result.setSampleLabel(getName());
try {
String binStr, gas;
if (isUseCorrelatedData()) {
JMeterVariables vars = JMeterContextService.getContext().getVariables();
binStr = (vars.get("binStr") == null) ? "null" : vars.get("binStr");
gas = (vars.get("gas") == null) ? "null" : vars.get("gas");
} else {
binStr = getBinStr();
gas= getGas();
}
String fromUser = getFromUser();

result.sampleStart();
String postData = "{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\":[{\"from\":\"" 
+ fromUser + "\",\"gas\":\"" + gas + "\",\"data\":\"" + binStr + "\"}],\"id\":1003}";
result.setRequestHeaders(postData);
String responseMsg = EthTestUtil.invokeAPI(null, postData);
result.sampleEnd();

Object document = Configuration.defaultConfiguration().jsonProvider().parse(responseMsg);
try {
JsonPath.read(document, "$.error").toString(); // detect possible error first
result.setResponseCode("400");
result.setResponseData(responseMsg);
} catch (com.jayway.jsonpath.PathNotFoundException e) {
String txHash = JsonPath.read(document, "$.result").toString();
result.setResponseCode("200");
result.setSuccessful(true);
result.setResponseData(responseMsg);
JMeterVariables vars = JMeterContextService.getContext().getVariables();
vars.put("txHash", txHash);
}
} catch(Exception ex) {
if (result.getEndTime() == 0) result.sampleEnd(); 
```
<Overlap Ratio: 0.9830205540661304>

---

--- 60 --
Question ID: 96647287c4c9c2629c275a53bb63a71d0c256421
Original Code:
```
public class JoinExample extends AuroraExample {

  @Override
  protected void generatePath(ExecutionPath path) {
    path = path.addRandomTestGenerator(1, ExampleHelper.generateAttributeList("A", "B"), 1000);
    ExecutionPath secondPath = ExecutionPath.getExecutionPath();
    secondPath = secondPath.addRandomTestGenerator(1, ExampleHelper.generateAttributeList("A", "C"), 1000);
    path = path.join("A", 50, secondPath, true);
    path = path.addTuplePrinter();
  }

}
```


Overlapping Code:
```
Example extends AuroraExample {
@Override
protected void generatePath(ExecutionPath path) {
path = path.addRandomTestGenerator(1, ExampleHelper.generateAttributeList("A", "B"), 1000);
ExecutionPath secondPath = ExecutionPath.getExecutionPath();
secondPath = secondPath.addRandomTestGenerator(1, ExampleHelper.generateAttributeList("A", "C"), 1000);
path = path.join("A", 50, secondPath, true);
path = path.addTuplePrinter();
}

```
<Overlap Ratio: 0.9595505617977528>

---

--- 61 --
Question ID: bad87a2146023ed2ae2f5034ba61fa7070b8a5bc
Original Code:
```
public class CipherRSAFactory {
    public static final String ALGORITHM_WAS_INVALID = "Algorithm, %s, was invalid";
    public static final String PADDING_WAS_INVALID = "Padding for algorithm, %s, was invalid";
    public static final String KEY_WAS_INVALID_INIT_CIPHER = "Key was invalid when initializing cipher";
    public static final String ALGORITHM_WAS_INVALID_INIT_CIPHER = "Algorithm, %s, was invalid when initializing cipher";

    public Cipher forEncrypt(Transformation transformation, Key key) throws CipherException {
        AlgorithmParameterSpec spec = makeSpec(transformation);
        Cipher cipher = makeCipher(transformation, key, Cipher.ENCRYPT_MODE, spec);
        return cipher;
    }

    public Cipher forDecrypt(Transformation transformation, Key key) throws CipherException {
        AlgorithmParameterSpec spec = makeSpec(transformation);
        Cipher cipher = makeCipher(transformation, key, Cipher.DECRYPT_MODE, spec);
        return cipher;
    }

    protected AlgorithmParameterSpec makeSpec(Transformation transformation) {
        AlgorithmParameterSpec spec = null;
        if (transformation == Transformation.RSA_OAEP) {
            spec =  OAEPParameterSpec.DEFAULT;
        }
        return spec;
    }

    protected Cipher makeCipher(Transformation transformation, Key key, int mode, AlgorithmParameterSpec spec) throws CipherException {
        Cipher cipher;
        try {
            cipher = Cipher.getInstance(transformation.getValue());
        } catch (NoSuchAlgorithmException e) {
            throw new CipherException(String.format(ALGORITHM_WAS_INVALID, transformation.getValue()), e);
        } catch (NoSuchPaddingException e) {
            throw new CipherException(String.format(PADDING_WAS_INVALID, transformation.getValue()), e);
        }

        try {
            cipher.init(mode, key, spec);
        } catch (InvalidKeyException e) {
            throw new CipherException(KEY_WAS_INVALID_INIT_CIPHER, e);
        } catch (InvalidAlgorithmParameterException e) {
            throw new CipherException(String.format(ALGORITHM_WAS_INVALID_INIT_CIPHER, transformation.getValue()), e);
        }

        return cipher;
    }
}
```


Overlapping Code:
```
c static final String ALGORITHM_WAS_INVALID = "Algorithm, %s, was invalid";
public static final String PADDING_WAS_INVALID = "Padding for algorithm, %s, was invalid";
public static final String KEY_WAS_INVALID_INIT_CIPHER = "Key was invalid when initializing cipher";
public static final String ALGORITHM_WAS_INVALID_INIT_CIPHER = "Algorithm, %s, was invalid when initializing cipher";
public Cipher forEncrypt(Transformation transformation, Key key) throws CipherException {
AlgorithmParameterSpec spec = makeSpec(transformation);
Cipher cipher = makeCipher(transformation, key, Cipher.ENCRYPT_MODE, spec);
return cipher;
}
public Cipher forDecrypt(Transformation transformation, Key key) throws CipherException {
AlgorithmParameterSpec spec = makeSpec(transformation);
Cipher cipher = makeCipher(transformation, key, Cipher.DECRYPT_MODE, spec);
return cipher;
}
protected AlgorithmParameterSpec makeSpec(Transformation transformation) {
AlgorithmParameterSpec spec = null;
if (transformation == Transformation.RSA_OAEP) {
spec = OAEPParameterSpec.DEFAULT;
}
return spec;
}
protected Cipher makeCipher(Transformation transformation, Key key, int mode, AlgorithmParameterSpec spec) throws CipherException {
Cipher cipher;
try {
cipher = Cipher.getInstance(transformation.getValue());
} catch (NoSuchAlgorithmException e) {
throw new CipherException(String.format(ALGORITHM_WAS_INVALID, transformation.getValue()), e);
} catch (NoSuchPaddingException e) {
throw new CipherException(String.format(PADDING_WAS_INVALID, transformation.getValue()), e);
}
try {
cipher.init(mode, key, spec);
} catch (InvalidKeyException e) {
throw new CipherException(KEY_WAS_INVALID_INIT_CIPHER, e);
} catch (InvalidAlgorithmParameterException e) {
throw new CipherException(String.format(ALGORITHM_WAS_INVALID_INIT_CIPHER, transformation.getValue()), e);
}
return cipher
```
<Overlap Ratio: 0.9778012684989429>

---

--- 62 --
Question ID: 73580f86dc1928c74bd9c4351f580b9c6f313051
Original Code:
```
public class MessagePreProcessor implements EventHandler<InboundEventContainer> {

    private static final Log log = LogFactory.getLog(MessagePreProcessor.class);
    private final MessageIDGenerator idGenerator;

    private final ArrayList<AndesMessage> messageList;

    public MessagePreProcessor() {
        idGenerator = new MessageIDGenerator();
        messageList = new ArrayList<>();
    }

    @Override
    public void onEvent(InboundEventContainer inboundEvent, long sequence, boolean endOfBatch ) throws Exception {
        InboundEventContainer.Type eventType = inboundEvent.getEventType();

        if (log.isDebugEnabled()) {
            log.debug("[ sequence " + sequence + "] Event type " + eventType);
        }

        switch (eventType) {
            case MESSAGE_EVENT:
                // NOTE: This is the MESSAGE_EVENT and this is the first processing event for this message
                // published to ring. Therefore there should be exactly one message in the list.
                // NO NEED TO CHECK FOR LIST SIZE
                AndesMessage message = inboundEvent.popMessage();
                updateRoutingInformation(inboundEvent, message, sequence);
                break;
            case TRANSACTION_COMMIT_EVENT:
                preProcessTransaction(inboundEvent, sequence);
                break;
            case DTX_ONE_PHASE_COMMIT_EVENT:
            case DTX_COMMIT_EVENT:
                preProcessDtxCommit(inboundEvent);
                break;
            case DTX_ROLLBACK_EVENT:
                preProcessDtxRollback(inboundEvent);
                break;
            case SAFE_ZONE_DECLARE_EVENT:
                setSafeZoneLimit(inboundEvent, sequence);
                break;
            case PUBLISHER_RECOVERY_EVENT:
                inboundEvent.setRecoveryEventMessageId(idGenerator.getNextId());
                break;
            default:
                if (log.isDebugEnabled()) {
                    log.debug("[ sequence " + sequence + "] Unhandled event " + inboundEvent.eventInfo());
                }
                break;
        }
    }

    /**
     * Pre-process Dtx rollback messages. Acknowledged but not yet commited messages are given a new message id to be
     * restored.
     *
     * @param eventContainer {@link InboundEventContainer}
     */
    private void preProcessDtxRollback(InboundEventContainer eventContainer) {

        List<AndesPreparedMessageMetadata> dequeueList = eventContainer.getDtxBranch().getMessagesToRestore();
        for (AndesPreparedMessageMetadata messageMetadata: dequeueList) {
            messageMetadata.setMessageID(idGenerator.getNextId());
        }
    }

    /**
     * Pre process Dtx commit related incoming messages. Messages are cloned as needed for in topic scenarios
     * @param eventContainer
     */
    private void preProcessDtxCommit(InboundEventContainer eventContainer) {
        // Routing information of all the messages of current transaction is updated.
        // Messages duplicated as needed.
        ArrayList<AndesMessage> clonedMessages = new ArrayList<>();
        Collection<AndesMessage> enqueueList = eventContainer.getDtxBranch().getEnqueueList();

        for (AndesMessage message : enqueueList) {
            setMessageID(message);
            clonedMessages.addAll(preProcessIncomingMessage(eventContainer, message));
        }

        // Internal message list of transaction object is updated to reflect the messages
        // actually written to DB
        eventContainer.getDtxBranch().setMessagesToStore(clonedMessages);
    }

    /**
     * Pre process transaction related messages.
     * @param eventContainer InboundEventContainer
     * @param sequence Disruptor ring sequence number.
     * @throws AndesException
     */
    private void preProcessTransaction(InboundEventContainer eventContainer, long sequence) throws AndesException {

        // Routing information of all the messages of current transaction is updated.
        // Messages duplicated as needed.
        Collection<AndesMessage> messageList = eventContainer.getTransactionEvent().getQueuedMessages();
        for (AndesMessage message : messageList) {
            updateRoutingInformation(eventContainer, message, sequence);
        }

        // Internal message list of transaction object is updated to reflect the messages
        // to be written to DB
        eventContainer.getTransactionEvent().setMessagesToStore(eventContainer.getMessageList());
    }

    /**
     * Calculate the current safe zone for this node (using the last generated message ID)
     * @param event event
     * @param sequence position of the event at the event ring buffer
     */
    private void setSafeZoneLimit(InboundEventContainer event, long sequence) {
        long safeZoneLimit = idGenerator.getNextId();
        event.setSafeZoneLimit(safeZoneLimit);
        if(log.isDebugEnabled()){
            log.debug("[ Sequence " + sequence + " ] Pre processing message. Setting the Safe Zone " + safeZoneLimit);
        }
    }

    /**
     * Route the message to queue/queues of subscribers matching in AMQP way. Hierarchical topic message routing is
     * evaluated here. This will duplicate message for each "subscription destination (not message destination)" at
     * different nodes
     *
     * @param event InboundEventContainer containing the message list
     * @param message Routing details updated for the given {@link org.wso2.andes.kernel.AndesMessage}
     * @param sequence Disruptor slot sequence number
     */
    private void updateRoutingInformation(InboundEventContainer event, AndesMessage message, long sequence) {

        AndesChannel andesChannel = event.getChannel();

        // Messages are processed in the order they arrive at ring buffer By this processor.
        // By setting message ID through message pre processor we assure, even in a multi publisher scenario, there is
        // no message id ordering issue at node level.
        setMessageID(message);

        if(log.isDebugEnabled()){
            log.debug("[ Sequence " + sequence + " ] Pre processing message. Message ID "
                    + message.getMetadata().getMessageID());
        }

        List<? extends AndesMessage> messages = preProcessIncomingMessage(event, message);
        for (AndesMessage andesMessage: messages) {
            event.addMessage(andesMessage, andesChannel);
        }
    }

    /**
     * Pre process the message and clone the message if needed on topic scenarios.
     *
     * @param event InboundEventContainer containing the message list
     * @param message {@link AndesMessage}
     * @return List of {@link AndesMessage}
     */
    private List<AndesMessage> preProcessIncomingMessage(InboundEventContainer event, AndesMessage message) {

        boolean isMessageRouted = false;

        // Get storage queues bound to the message router
        String messageRouterName = message.getMetadata().getMessageRouterName();
        AndesMessageRouter messageRouter = AndesContext.getInstance().
                getMessageRouterRegistry().getMessageRouter(messageRouterName);

        // Do topic matching with the routing key of the message and get a list of
        // mating binding keys
        Set<StorageQueue> matchingQueues = messageRouter.getMatchingStorageQueues(message);
        messageList.clear(); // clear any previous entries

        boolean originalMessageConsumed = false;

        for (StorageQueue matchingQueue : matchingQueues) {

            if (!originalMessageConsumed) {
                message.getMetadata().setStorageQueueName(matchingQueue.getName());

                // add the topic wise cloned message to the events list. Message writers will pick that and
                // write it.
                messageList.add(message);
                originalMessageConsumed = true;

            } else {
                AndesMessage clonedMessage = cloneAndesMessageMetadataAndContent(message);

                //Message should be written to storage queue name. This is
                //determined by destination of the message. So should be
                //updated (but internal metadata will have topic name as usual)
                clonedMessage.getMetadata().setStorageQueueName(matchingQueue.getName());

                // Update cloned message metadata if isCompressed set true.
                if (clonedMessage.getMetadata().isCompressed()) {
                    clonedMessage.getMetadata().updateMetadata(true);
                }

                if (MessageTracer.isEnabled()) {
                    MessageTracer.trace(message, MessageTracer.MESSAGE_CLONED + clonedMessage.getMetadata()
                            .getMessageID() + " for " + clonedMessage.getMetadata().getStorageQueueName());
                }

                // add the topic wise cloned message to the events list. Message writers will pick that and
                // write it.
                messageList.add(clonedMessage);
            }

            isMessageRouted = true;
        }

        // TODO: validate this
        // If retain enabled, need to store the retained message. Set the retained message
        // so the message writer will persist the retained message
        if (message.getMetadata().isRetain()) {
            event.retainMessage = message;
        }

        // If there is no matching subscriber at the moment there is no point of storing the message
        if (!isMessageRouted) {

            // Even though we drop the message pub ack needs to be sent
            event.pubAckHandler.ack(message.getMetadata());

            // Adding metrics meter for ack rate
            Meter ackMeter = MetricManager.meter(MetricsConstants.ACK_SENT_RATE, Level.INFO);
            ackMeter.mark();

            // Since inbound message has no routes, inbound message list will be cleared.
            messageList.clear();
            log.info("Message routing key: " + message.getMetadata().getDestination() + " No routes in " +
                    "cluster. Ignoring Message id " + message.getMetadata().getMessageID());
        }
        return messageList;
    }

    /**
     * Create a clone of the message
     *
     * @param message message to be cloned
     * @return Cloned reference of AndesMessage
     */
    private AndesMessage cloneAndesMessageMetadataAndContent(AndesMessage message) {
        long newMessageId = idGenerator.getNextId();
        AndesMessageMetadata clonedMetadata = message.getMetadata().shallowCopy(newMessageId);
        AndesMessage clonedMessage = new AndesMessage(clonedMetadata);

        // Duplicate message content
        List<AndesMessagePart> messageParts = message.getContentChunkList();
        for (AndesMessagePart messagePart : messageParts) {
            clonedMessage.addMessagePart(messagePart.shallowCopy(newMessageId));
        }

        return clonedMessage;

    }

    /**
     * Set Message ID for AndesMessage.
     * @param message messageID
     */
    private void setMessageID(AndesMessage message) {
        long messageId = idGenerator.getNextId();

        message.getMetadata().setMessageID(messageId);

        // Tracing message
        if (MessageTracer.isEnabled()) {
            MessageTracer.trace(messageId, message.getMetadata().getDestination(), MessageTracer.MESSAGE_ID_MAPPED);
        }

        for (AndesMessagePart messagePart: message.getContentChunkList()) {
            messagePart.setMessageID(messageId);
        }
    }

    /**
     * Generates IDs. This id generator cannot be used in a multi threaded environment. Removed any locking behaviour to
     * improve id generation in single threaded approach
     */
    private static class MessageIDGenerator {

        /** REFERENCE_START time set to 2011 */
        private static final long REFERENCE_START = 41L * 365L * 24L * 60L * 60L * 1000L;
        private int uniqueIdForNode;
        private long lastTimestamp;
        private long lastID;
        private int offset;

        MessageIDGenerator() {
            uniqueIdForNode = 0;
            lastTimestamp = 0;
            lastID = 0;
            offset = 0;
        }

        /**
         * Out of 64 bits for long, we will use the range as follows
         * [1 sign bit][45bits for time spent from reference time in milliseconds][8bit node id][10 bit offset for ID
         * falls within the same timestamp]
         * This assumes there will not be more than 1024 hits within a given millisecond. Range is sufficient for
         * 6029925857 years.
         *
         * @return Generated ID
         */
        long getNextId() {

            // id might change at runtime. Hence reading the value
            uniqueIdForNode = ClusterResourceHolder.getInstance().getClusterManager().getUniqueIdForLocalNode();
            long ts = System.currentTimeMillis();

            if (ts == lastTimestamp) {
                offset = offset + 1;
            } else {
                offset = 0;
            }
            lastTimestamp = ts;
            long id = (ts - REFERENCE_START) * 256 * 1024 + uniqueIdForNode * 1024 + offset;
            if (lastID == id) {
                throw new RuntimeException("duplicate ids detected. This should never happen");
            }
            lastID = id;
            return id;
        }
    }
}
```


Overlapping Code:
```
ic class MessagePreProcessor implements EventHandler<InboundEventContainer> {
private static final Log log = LogFactory.getLog(MessagePreProcessor.class);
private final MessageIDGenerator idGenerator;
private final ArrayList<AndesMessage> messageList;
public MessagePreProcessor() {
idGenerator = new MessageIDGenerator();
messageList = new ArrayList<>();
}
@Override
public void onEvent(InboundEventContainer inboundEvent, long sequence, boolean endOfBatch ) throws Exception {
InboundEventContainer.Type eventType = inboundEvent.getEventType();
if (log.isDebugEnabled()) {
log.debug("[ sequence " + sequence + "] Event type " + eventType);
}
switch (eventType) {
case MESSAGE_EVENT:
// NOTE: This is the MESSAGE_EVENT and this is the first processing event for this message
// published to ring. Therefore there should be exactly one message in the list.
// NO NEED TO CHECK FOR LIST SIZE
AndesMessage message = inboundEvent.popMessage();
updateRoutingInformation(inboundEvent, message, sequence);
break;
case TRANSACTION_COMMIT_EVENT:
preProcessTransaction(inboundEvent, sequence);
break;
case DTX_ONE_PHASE_COMMIT_EVENT:
case DTX_COMMIT_EVENT:
preProcessDtxCommit(inboundEvent);
break;
case DTX_ROLLBACK_EVENT:
preProcessDtxRollback(inboundEvent);
break;
case SAFE_ZONE_DECLARE_EVENT:
setSafeZoneLimit(inboundEvent, sequence);
break;
case PUBLISHER_RECOVERY_EVENT:
inboundEvent.setRecoveryEventMessageId(idGenerator.getNextId());
break;
default:
if (log.isDebugEnabled()) {
log.debug("[ sequence " + sequence + "] Unhandled event " + inboundEvent.eventInfo());
}
break;
}
}
/**
* Pre-process Dtx rollback messages. Acknowledged but not yet commited messages are given a new message id to be
* restored.
*
* @param eventContainer {@link InboundEventContainer}
*/
private void preProcessDtxRollback(InboundEventContainer eventContainer) {
List<AndesPreparedMessageMetadata> de
```
<Overlap Ratio: 0.9730569948186528>

---

--- 63 --
Question ID: 76448458f8711fbbba7fb5cc7a15d3ff53c075e5
Original Code:
```
@Slf4j
public class PgConnectionSupplier {

    @NonNull
    @VisibleForTesting
    protected final org.apache.tomcat.jdbc.pool.DataSource ds;

    public PgConnectionSupplier(DataSource dataSource) {
        if (org.apache.tomcat.jdbc.pool.DataSource.class.isAssignableFrom(dataSource.getClass())) {
            this.ds = (org.apache.tomcat.jdbc.pool.DataSource) dataSource;
        } else {
            throw new IllegalArgumentException("expected "
                    + org.apache.tomcat.jdbc.pool.DataSource.class.getName()
                    + " , but got " + dataSource.getClass().getName());
        }
    }

    public PgConnection get() throws SQLException {
        try {
            return (PgConnection) DriverManager.getDriver(ds.getUrl())
                    .connect(ds.getUrl(), buildPgConnectionProperties(ds));
        } catch (SQLException e) {
            final String msg = "Cannot acquire Connection from DriverManager: " + ds.getUrl();
            log.error(msg, e);
            throw e;
        }
    }

    private void setProperty(Properties dbp, String propertyName, String value) {
        if (value != null)
            dbp.setProperty(propertyName, value);
    }

    @VisibleForTesting
    Properties buildPgConnectionProperties(org.apache.tomcat.jdbc.pool.DataSource ds) {
        Properties dbp = new Properties();
        final PoolConfiguration poolProperties = ds.getPoolProperties();
        if (poolProperties != null) {
            setProperty(dbp, "user", poolProperties.getUsername());
            setProperty(dbp, "password", poolProperties.getPassword());
            final String connectionProperties = poolProperties.getConnectionProperties();
            if (connectionProperties != null) {
                try {
                    @SuppressWarnings("UnstableApiUsage")
                    Map<String, String> singleConnectionProperties = Splitter.on(";")
                            .omitEmptyStrings()
                            .withKeyValueSeparator("=")
                            .split(connectionProperties);
                    setProperty(dbp, "socketTimeout", singleConnectionProperties.get(
                            "socketTimeout"));
                    setProperty(dbp, "connectTimeout", singleConnectionProperties.get(
                            "connectTimeout"));
                    setProperty(dbp, "loginTimeout", singleConnectionProperties.get(
                            "loginTimeout"));
                } catch (IllegalArgumentException e) {
                    throw new IllegalArgumentException("illegal connectionProperties: "
                            + connectionProperties);
                }
            }
        }
        return dbp;
    }
}
```


Overlapping Code:
```
{
@NonNull
@VisibleForTesting
protected final org.apache.tomcat.jdbc.pool.DataSource ds;
public PgConnectionSupplier(DataSource dataSource) {
if (org.apache.tomcat.jdbc.pool.DataSource.class.isAssignableFrom(dataSource.getClass())) {
this.ds = (org.apache.tomcat.jdbc.pool.DataSource) dataSource;
} else {
throw new IllegalArgumentException("expected "
+ org.apache.tomcat.jdbc.pool.DataSource.class.getName()
+ " , but got " + dataSource.getClass().getName());
}
}
public PgConnection get() throws SQLException {
try {
return (PgConnection) DriverManager.getDriver(ds.getUrl())
.connect(ds.getUrl(), buildPgConnectionProperties(ds));
} catch (SQLException e) {
final String msg = "Cannot acquire Connection from DriverManager: " + ds.getUrl();
log.error(msg, e);
throw e;
}
}
private void setProperty(Properties dbp, String propertyName, String value) {
if (value != null)
dbp.setProperty(propertyName, value);
}
@VisibleForTesting
Properties buildPgConnectionProperties(org.apache.tomcat.jdbc.pool.DataSource ds) {
Properties dbp = new Properties();
final PoolConfiguration poolProperties = ds.getPoolProperties();
if (poolProperties != null) {
setProperty(dbp, "user", poolProperties.getUsername());
setProperty(dbp, "password", poolProperties.getPassword());
final String connectionProperties = poolProperties.getConnectionProperties();
if (connectionProperties != null) {
try {
@SuppressWarnings("UnstableApiUsage")
Map<String, String> singleConnectionProperties = Splitter.on(";")
.omitEmptyStrings()
.withKeyValueSeparator("=")
.split(connectionProperties);
setProperty(dbp, "socketTimeout", singleConnectionProperties.get(
"socketTimeout"));
setProperty(dbp, "connectTimeout", singleConnectionProperties.get(
"connectTimeout"));
setProperty(dbp, "loginTimeout", singleConnectionProperties.get
```
<Overlap Ratio: 0.9584664536741214>

---

--- 64 --
Question ID: 1846de475f569d5db8396533a0614c0ff1e52fee
Original Code:
```
public class TrackerIdFetcherTest {

    private TrackerIdFetcher trackerIdFetcher;
    private TrackerIdFetcher nextTrackerIdFetcher;
    private TrackerIdFetcher nextTrackerIdFetcher1;
    private Http.Context ctx;

    @Before
    public void setup() {
        trackerIdFetcher = mock(TrackerIdFetcher.class);
        nextTrackerIdFetcher = mock(TrackerIdFetcher.class);
        ctx = mock(Http.Context.class);
    }

    @Test
    public void should_return_a_tracker_id() {
        Whitebox.setInternalState(trackerIdFetcher, "nextTrackerIdFetcher", nextTrackerIdFetcher);
        when(trackerIdFetcher.fetch(ctx)).thenReturn("123");
        doCallRealMethod().when(trackerIdFetcher).get(ctx);
        Assert.assertEquals(trackerIdFetcher.get(ctx), "123");
    }

    @Test
    public void should_return_a_tracker_id_from_next() {
        Whitebox.setInternalState(trackerIdFetcher, "nextTrackerIdFetcher", nextTrackerIdFetcher);
        when(trackerIdFetcher.fetch(ctx)).thenReturn(null);
        when(nextTrackerIdFetcher.fetch(ctx)).thenReturn("456");
        doCallRealMethod().when(trackerIdFetcher).get(ctx);
        Assert.assertEquals(trackerIdFetcher.get(ctx), "456");
    }

    @Test
    public void should_return_a_null_from_next() {
        Whitebox.setInternalState(trackerIdFetcher, "nextTrackerIdFetcher", nextTrackerIdFetcher1);
        when(trackerIdFetcher.fetch(ctx)).thenReturn(null);
        when(nextTrackerIdFetcher.fetch(ctx)).thenReturn(null);
        doCallRealMethod().when(trackerIdFetcher).get(ctx);
        Assert.assertNull(trackerIdFetcher.get(ctx));
    }

    @Test
    public void should_set_the_next_provider() {
        doCallRealMethod().when(trackerIdFetcher).setNextProvider(nextTrackerIdFetcher);
        trackerIdFetcher.setNextProvider(nextTrackerIdFetcher);
        Assert.assertEquals(Whitebox.getInternalState(trackerIdFetcher, "nextTrackerIdFetcher"), nextTrackerIdFetcher);
    }

}
```


Overlapping Code:
```
kerIdFetcherTest {
private TrackerIdFetcher trackerIdFetcher;
private TrackerIdFetcher nextTrackerIdFetcher;
private TrackerIdFetcher nextTrackerIdFetcher1;
private Http.Context ctx;
@Before
public void setup() {
trackerIdFetcher = mock(TrackerIdFetcher.class);
nextTrackerIdFetcher = mock(TrackerIdFetcher.class);
ctx = mock(Http.Context.class);
}
@Test
public void should_return_a_tracker_id() {
Whitebox.setInternalState(trackerIdFetcher, "nextTrackerIdFetcher", nextTrackerIdFetcher);
when(trackerIdFetcher.fetch(ctx)).thenReturn("123");
doCallRealMethod().when(trackerIdFetcher).get(ctx);
Assert.assertEquals(trackerIdFetcher.get(ctx), "123");
}
@Test
public void should_return_a_tracker_id_from_next() {
Whitebox.setInternalState(trackerIdFetcher, "nextTrackerIdFetcher", nextTrackerIdFetcher);
when(trackerIdFetcher.fetch(ctx)).thenReturn(null);
when(nextTrackerIdFetcher.fetch(ctx)).thenReturn("456");
doCallRealMethod().when(trackerIdFetcher).get(ctx);
Assert.assertEquals(trackerIdFetcher.get(ctx), "456");
}
@Test
public void should_return_a_null_from_next() {
Whitebox.setInternalState(trackerIdFetcher, "nextTrackerIdFetcher", nextTrackerIdFetcher1);
when(trackerIdFetcher.fetch(ctx)).thenReturn(null);
when(nextTrackerIdFetcher.fetch(ctx)).thenReturn(null);
doCallRealMethod().when(trackerIdFetcher).get(ctx);
Assert.assertNull(trackerIdFetcher.get(ctx));
}
@Test
public void should_set_the_next_provider() {
doCallRealMethod().when(trackerIdFetcher).setNextProvider(nextTrackerIdFetcher);
trackerIdFetcher.setNextProvider(nextTrackerIdFetcher);
Assert.assertEquals(Whitebox.getInternalState(trackerIdFetcher, "nextTrackerIdFetcher"), n
```
<Overlap Ratio: 0.975177304964539>

---

--- 65 --
Question ID: ed3afa5d2bcb1c4c5b6946c9430be20597e9ff65
Original Code:
```
public class BitcoinConf extends HashMap<String, String> {

    public RPCConfig getRPCConfig() {
        URI uri = null;
        try {
            uri = new URI("http://" + get("rpcconnect") + ":" + get("rpcport"));
        } catch (URISyntaxException e) {
            try {
                uri = new URI("http://127.0.0.1:8332");
            } catch (URISyntaxException e1) {
                throw new RuntimeException("Error creating RPC URI", e1);
            }
        }
        // TODO: Determine MainNet, TestNet, or RegTest from contents of .conf file
        RPCConfig config = new RPCConfig(MainNetParams.get(), uri,
                get("rpcuser"), get("rpcpassword"));
        return config;
    }
}
```


Overlapping Code:
```
public class BitcoinConf extends HashMap<String, String> {
public RPCConfig getRPCConfig() {
URI uri = null;
try {
uri = new URI("http://" + get("rpcconnect") + ":" + get("rpcport"));
} catch (URISyntaxException e) {
try {
uri = new URI("http://127.0.0.1:8332");
} catch (URISyntaxException e1) {
throw new RuntimeException("Error creating RPC URI", e1);
}
}
// TODO: Determine MainNet, TestNet, or RegTest from contents of .conf file
RPCConfig config = new RPCConfig(MainNetParams.get(), uri,
get("rpcuser"), get("rpcpassword"));
return c
```
<Overlap Ratio: 0.9817850637522769>

---

--- 66 --
Question ID: fdc8935095563e93449d1736b136b62f0d4ef8aa
Original Code:
```
@SuppressWarnings("UnusedParameters")
public class LandlordCommandExecutor implements CommandExecutor {

    private HashMap<String, LandlordCommand> registeredCommands;

    private Help helpCommand;

    public LandlordCommandExecutor(Landlord plugin) {
        this.registeredCommands = new HashMap<>();

        this.helpCommand = new Help(plugin, this);

        // note order of registration will affect how they show up in the help menu
        this.register(helpCommand);             // register the help command (already instantiated)

        this.register(new Claim(plugin));       // register the claim command
        this.register(new Unclaim(plugin));     // register the unclaim command
        this.register(new AddFriend(plugin));   // register the addfriend command
        this.register(new Unfriend(plugin));    // register the unfriend command
        this.register(new Friends(plugin));     // register the friends command
        this.register(new FriendAll(plugin));   // register the friendall command
        this.register(new UnfriendAll(plugin)); // register the unfriendall command
        this.register(new ShowMap(plugin));     // register the map command
        this.register(new Manage(plugin));      // register the manage command
        this.register(new LandList(plugin));    // register the list command
        this.register(new Info(plugin));        // register the info command
        this.register(new ListPlayer(plugin));  // register the listplayer command
        this.register(new ClearWorld(plugin));  // register the clearworld command
        this.register(new Reload(plugin));      // register the reload command

    }


    /**
     * Main command handler
     *
     * @param sender who sent the command
     * @param label  exact command (or alias) run
     * @param args   given with command
     * @return boolean
     */
    @Override
    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {
        if (cmd.getName().equalsIgnoreCase("landlord")) { // If the player typed /land then do the following...
            // Check if the attempted command is registered
            if (args.length == 0 || !registeredCommands.containsKey(args[0].toLowerCase())) {
                // if there is no command, or it's not registered, show the help text as the command given is unknown
                return helpCommand.execute(sender, new String[]{}, label);
            } else {
                // if it is, execute it with the given args
                return registeredCommands.get(args[0].toLowerCase()).execute(sender, args, label);
            }

        } //If this has happened the function should return true.
        // If this hasn't happened the value of false will be returned.
        return false;
    }


    /**
     * Register a new command
     *
     * @param cmd LandlordCommand to register
     * @return boolean of success - should fail if a requested label (name, alias) is not available
     */
    public boolean register(LandlordCommand cmd) {
        String[] commandTriggers = cmd.getTriggers();

        // if there are no aliases then fail, command would be impossible to trigger.
        if (commandTriggers.length <= 0) {

            return false;
        }

        // iterate the command aliases
        for (String trigger : commandTriggers) {

            // Check if the command is taken
            if (registeredCommands.containsKey(trigger.toLowerCase())) {
                System.out.println("Failed to register command with alias '" + trigger + "', already taken!");
                continue;   // Command name is taken already
            }

            // register an entry for this command trigger
            registeredCommands.put(trigger.toLowerCase(), cmd);
        }

        helpCommand.addCommand(cmd);    // add the command to the help list

        return true;
    }

}
```


Overlapping Code:
```
@SuppressWarnings("UnusedParameters")
public class LandlordCommandExecutor implements CommandExecutor {
private HashMap<String, LandlordCommand> registeredCommands;
private Help helpCommand;
public LandlordCommandExecutor(Landlord plugin) {
this.registeredCommands = new HashMap<>();
this.helpCommand = new Help(plugin, this);
// note order of registration will affect how they show up in the help menu
this.register(helpCommand); // register the help command (already instantiated)
this.register(new Claim(plugin)); // register the claim command
this.register(new Unclaim(plugin)); // register the unclaim command
this.register(new AddFriend(plugin)); // register the addfriend command
this.register(new Unfriend(plugin)); // register the unfriend command
this.register(new Friends(plugin)); // register the friends command
this.register(new FriendAll(plugin)); // register the friendall command
this.register(new UnfriendAll(plugin)); // register the unfriendall command
this.register(new ShowMap(plugin)); // register the map command
this.register(new Manage(plugin)); // register the manage command
this.register(new LandList(plugin)); // register the list command
this.register(new Info(plugin)); // register the info command
this.register(new ListPlayer(plugin)); // register the listplayer command
this.register(new ClearWorld(plugin)); // register the clearworld command
this.register(new Reload(plugin)); // register the reload command
}
/**
* Main command handler
*
* @param sender who sent the command
* @param label exact command (or alias) run
* @param args given with command
* @return boolean
*/
@Override
public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {
if (cmd.getName().equalsIgnoreCase("landlord")) { // If the player typed /land then do the following...
// Check if the attempted command is registered
if (args.length == 0 || !registeredCommands.containsKey(args[0].toLowerCase())) {
// if there is no command, or it's not registered, show the help text as the command given is unknown
return helpCommand.execute(sender, new String
```
<Overlap Ratio: 0.9835526315789473>

---

--- 67 --
Question ID: 3f1e64ec78e442dcd00b91b4997b2e200e449310
Original Code:
```
public class ForpladHelper {

	private final HibernateDAO dao;

	public ForpladHelper(HibernateDAO dao) {
		this.dao = dao;
	}

	public Document initializeDocument(PlanMacro plan) {
		if (plan == null) {
			throw new IllegalArgumentException("You must provide a PlanMacro to initialize a Forplad Document.");
		}

		Document document = this.retrieveByPlan(plan);
		if (document != null) {
			throw new IllegalArgumentException("The provided PlanMacro already has a Document.");
		}

		DocumentCreator creator = new DocumentCreator(plan);
		this.dao.execute(creator);

		return creator.document;
	}

	public Document retrieveByPlan(PlanMacro plan) {
		Criteria criteria = this.dao.newCriteria(Document.class).add(Restrictions.eq("plan", plan));
		return (Document) criteria.uniqueResult();
	}

	/**
	 * Classe privada que insere a estrutura do documento FORPLAD em uma única
	 * transação do banco de dados.
	 * 
	 * @author Renato Oliveira
	 *
	 */
	protected class DocumentCreator implements TransactionalOperation {

		public final Document document;

		public DocumentCreator(PlanMacro plan) {
			this.document = new Document();
			this.document.setPlan(plan);
			this.document.setDescription("O PDI, elaborado para um período de cinco anos, é o documento"
					+ " que identifica a IES no que diz respeito à sua filosofia de trabalho, à missão a que se propõe, "
					+ "às diretrizes pedagógicas que orientam suas ações, à sua estrutura organizacional "
					+ "e às atividades acadêmicas que desenvolve e/ou que pretende desenvolver " + "</br>" + "</br>"
					+ "</br>" + "Atenção: Evite colar textos formatados nas seções do Documento do PDI.");
			this.document.setTitle("Documento - " + plan.getName());
		}

		@Override
		public void execute(Session session) throws HibernateException {
			DocumentSection section, subsection;
			DocumentAttribute attr;
			Schedule schedule;
			TableFields tableFields;
			TableStructure tableStructure;
			OptionsField optionsField;

			session.persist(this.document);

			// SEÇÕES NÃO NUMERADAS - PRÉ TEXTUAIS

			// Seção 1 - Ficha técnica
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Ficha técnica");
			section.setSequence(1); // Número da seção para ordenar na exibição.
			section.setLeaf(true);
			section.setPreTextSection(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName("Ficha Técnica");
			attr.setSection(section);
			attr.setType(TableField.class.getCanonicalName());
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			tableFields = new TableFields();
			tableFields.setAttributeId(attr.getId());
			tableFields.setIsDocument(true);
			session.persist(tableFields);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Nome");
			tableStructure.setType(TextField.generateId(TextField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Cargo");
			tableStructure.setType(TextField.generateId(TextField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);

			// Seção 2 - Histórico de versões
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Histórico de versões");
			section.setSequence(2); // Número da seção para ordenar na exibição.
			section.setLeaf(true);
			section.setPreTextSection(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName("Histórico de versões");
			attr.setSection(section);
			attr.setType(TableField.class.getCanonicalName());
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			tableFields = new TableFields();
			tableFields.setAttributeId(attr.getId());
			tableFields.setIsDocument(true);
			session.persist(tableFields);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Data");
			tableStructure.setType(DateField.generateId(DateField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Versão");
			tableStructure.setType(TextField.generateId(TextField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Descrição");
			tableStructure.setType(TextField.generateId(TextField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Autor");
			tableStructure.setType(TextField.generateId(TextField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);

			// Seção 3 - Lista de abreviações
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Lista de abreviações");
			section.setSequence(3); // Número da seção para ordenar na exibição.
			section.setLeaf(true);
			section.setPreTextSection(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName("Lista de abreviações");
			attr.setSection(section);
			attr.setType(TableField.class.getCanonicalName());
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			tableFields = new TableFields();
			tableFields.setAttributeId(attr.getId());
			tableFields.setIsDocument(true);
			session.persist(tableFields);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Sigla");
			tableStructure.setType(TextField.generateId(TextField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Descrição");
			tableStructure.setType(TextField.generateId(TextField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);

			// SEÇÕES NUMERADAS

			// Seção 1 - Apresentação
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Apresentação");
			section.setSequence(1); // Número da seção para ordenar na exibição.
			section.setLeaf(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName("Apresentação do PDI");
			attr.setSection(section);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 2 - Método
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Método");
			section.setSequence(2); // Número da seção para ordenar na exibição.
			section.setLeaf(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName("Descrição do método utilizado para a elaboração do PDI");
			attr.setSection(section);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 3 - Documentos de referência
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Documentos de referência");
			section.setSequence(3); // Número da seção para ordenar na exibição.
			section.setLeaf(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName("Documentos de referência mais utilizados para a elaboração do PDI");
			attr.setSection(section);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 4 - Resultados do PDI anterior
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Resultados do PDI anterior");
			section.setSequence(4); // Número da seção para ordenar na exibição.
			section.setLeaf(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName("Resultados do PDI anterior");
			attr.setSection(section);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 5 - Perfil institucional
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Perfil institucional");
			section.setSequence(5); // Número da seção para ordenar na exibição.
			section.setLeaf(false);
			session.persist(section);

			// Subseção 5.1 - Histórico da IES
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Histórico da IES");
			subsection.setSequence(1); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Análise do histórico de todos os campus da IES");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 5.2 - Finalidade
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Finalidade");
			subsection.setSequence(2); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Finalidade da IES");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 5.3 - Missão
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Missão, visão e valores");
			subsection.setSequence(3); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Missão");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			attr = new DocumentAttribute();
			attr.setName("Visão");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(2); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			attr = new DocumentAttribute();
			attr.setName("Valores");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(3); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			attr = new DocumentAttribute();
			attr.setName("Objetivos estratégicos");
			attr.setSection(subsection);
			attr.setType(StrategicObjective.generateId(StrategicObjective.class));
			attr.setSequence(4); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 5.4 - Área(s) de atuação acadêmica
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Área(s) de atuação acadêmica");
			subsection.setSequence(4); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Áreas de atuação acadêmica");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 6 - Projeto Pedagógico Institucional (PPI)
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Projeto Pedagógico Institucional (PPI)");
			section.setSequence(6); // Número da seção para ordenar na exibição.
			section.setLeaf(false);
			session.persist(section);

			// Subseção 6.1 - Inserção regional
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Inserção regional");
			subsection.setSequence(1); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 6.2 - Princípios filosóficos e técnico-metodológicos
			// gerais
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Princípios filosóficos e técnico-metodológicos gerais");
			subsection.setSequence(2); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição dos princípios que norteiam as práticas acadêmicas da IES");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 6.3 - Organização didático-pedagógica da instituição
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Organização didático-pedagógica da instituição");
			subsection.setSequence(3); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Organização didático-pedagógica da instituição");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 6.4 - Políticas de ensino
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Políticas de ensino");
			subsection.setSequence(4); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição das políticas de ensino");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 6.5 - Políticas de extensão
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Políticas de extensão");
			subsection.setSequence(5); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição das políticas de extensão");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 6.6 - Políticas de pesquisa
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Políticas de pesquisa");
			subsection.setSequence(6); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição das políticas de pesquisa adotadas pela IES");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 6.7 - Políticas de gestão
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Políticas de gestão");
			subsection.setSequence(7); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição das políticas de gestão adotadas pela IES");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 6.8 - Responsabilidade Social da IES
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Responsabilidade social da IES");
			subsection.setSequence(8); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName(
					"Descrição da contribuição à inclusão social e ao desenvolvimento econômico e social da região");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 7 - Cronograma de implantação e desenvolvimento da
			// instituição e dos cursos
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Cronograma de implantação e desenvolvimento da instituição e dos cursos");
			section.setSequence(7); // Número da seção para ordenar na exibição.
			section.setLeaf(false);
			session.persist(section);

			// Subseção 7.1 - Descrição da situação atual
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Descrição da situação atual");
			subsection.setSequence(1); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição da situação atual");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			attr = new DocumentAttribute();
			attr.setName("Cursos ofertados pela IES");
			attr.setSection(subsection);
			attr.setType(TableField.class.getCanonicalName());
			attr.setSequence(2); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			tableFields = new TableFields();
			tableFields.setAttributeId(attr.getId());
			tableFields.setIsDocument(true);
			session.persist(tableFields);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Nome do Curso");
			tableStructure.setType(TextField.generateId(TextField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Habilitação");
			tableStructure.setType(SelectField.class.getCanonicalName());
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			// Valores da habilitação
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Tecnólogo");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Bacharelado");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Licenciatura");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Especialização");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("MBA");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Mestrado");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Doutorado");
			session.persist(optionsField);
			// Novo campo da tabela
			tableStructure = new TableStructure();
			tableStructure.setLabel("Modalidade");
			tableStructure.setType(SelectField.class.getCanonicalName());
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			// Valores da habilitação
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Presencial");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("À distância");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Semipresencial");
			session.persist(optionsField);
			// Novo campo da tabela
			tableStructure = new TableStructure();
			tableStructure.setLabel("Regime de matrícula");
			tableStructure.setType(SelectField.class.getCanonicalName());
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			// Valores da habilitação
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Anual");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Semestral");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Bienal");
			session.persist(optionsField);
			// Fim valores do selectfield
			tableStructure = new TableStructure();
			tableStructure.setLabel("Nº de turmas");
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Nº de Alunos por turma");
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Turno de funcionamento");
			tableStructure.setType(SelectField.class.getCanonicalName());
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			// Valores do select box
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Integral");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Diurno");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Noturno");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Vespertino");
			session.persist(optionsField);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Situação Atual");
			tableStructure.setType(TextField.generateId(TextField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);

			attr = new DocumentAttribute();
			attr.setName("Cursos que serão expandidos ou abertos no futuro");
			attr.setSection(subsection);
			attr.setType(TableField.class.getCanonicalName());
			attr.setSequence(3); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			tableFields = new TableFields();
			tableFields.setAttributeId(attr.getId());
			tableFields.setIsDocument(true);
			session.persist(tableFields);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Nome do Curso");
			tableStructure.setType(TextField.generateId(TextField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Habilitação");
			tableStructure.setType(SelectField.class.getCanonicalName());
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			// Valores da habilitação
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Tecnólogo");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Bacharelado");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Licenciatura");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Especialização");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("MBA");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Mestrado");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Doutorado");
			session.persist(optionsField);
			// Novo campo da tabela
			tableStructure = new TableStructure();
			tableStructure.setLabel("Modalidade");
			tableStructure.setType(SelectField.class.getCanonicalName());
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			// Valores da habilitação
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Presencial");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("À distância");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Semipresencial");
			session.persist(optionsField);
			// Novo campo da tabela
			tableStructure = new TableStructure();
			tableStructure.setLabel("Turno de funcionamento");
			tableStructure.setType(SelectField.class.getCanonicalName());
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			// Valores do select box
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Integral");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Diurno");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Noturno");
			session.persist(optionsField);
			optionsField = new OptionsField();
			optionsField.setAttributeId(attr.getId());
			optionsField.setColumnId(tableStructure.getId());
			optionsField.setDocument(true);
			optionsField.setLabel("Vespertino");
			session.persist(optionsField);
			/*
			 * tableStructure = new TableStructure(); tableStructure.setLabel(
			 * "Turno de funcionamento");
			 * tableStructure.setType(TextField.generateId(TextField.class));
			 * tableStructure.setTableFields(tableFields); session.persist(tableStructure);
			 */
			tableStructure = new TableStructure();
			tableStructure.setLabel("Nº de vagas autorizadas");
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Nº de vagas a solicitar");
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Ano previsto para solicitação");
			tableStructure.setType(TextField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);

			attr = new DocumentAttribute();
			attr.setName("Cronograma de expansão");
			attr.setSection(subsection);
			attr.setType(ScheduleField.class.getCanonicalName());
			attr.setSequence(4); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			schedule = new Schedule();
			schedule.setPeriodicityEnable(false);
			schedule.setAttributeId(attr.getId());
			schedule.setIsDocument(true);
			session.persist(schedule);

			// Subseção 7.2 - Objetivos e metas
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Objetivos e metas");
			subsection.setSequence(2); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição do plano de implantação e desenvolvimento da instituição e dos cursos");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			attr = new DocumentAttribute();
			attr.setName("Selecione o plano de metas correspondente");
			attr.setSection(subsection);
			attr.setType(SelectPlan.class.getCanonicalName());
			attr.setSequence(2); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 8 - Perfil do corpo docente
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Perfil do corpo docente");
			section.setSequence(8); // Número da seção para ordenar na exibição.
			section.setLeaf(false);
			session.persist(section);

			// Subseção 8.1 - Composição
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Composição");
			subsection.setSequence(1); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Evolução no quadro permanente de docentes por classe/ano");
			attr.setSection(subsection);
			attr.setType(TableField.class.getCanonicalName());
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			tableFields = new TableFields();
			tableFields.setAttributeId(attr.getId());
			tableFields.setIsDocument(true);
			session.persist(tableFields);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Ano");
			tableStructure.setInTotal(false);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Auxiliar");
			tableStructure.setInTotal(true);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Assistente");
			tableStructure.setInTotal(true);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Adjunto");
			tableStructure.setInTotal(true);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Associado");
			tableStructure.setInTotal(true);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Titular");
			tableStructure.setInTotal(true);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Total");
			tableStructure.setType(TotalField.generateId(TotalField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);

			attr = new DocumentAttribute();
			attr.setName("Evolução no quadro permanente de docentes por titulação");
			attr.setSection(subsection);
			attr.setType(TableField.class.getCanonicalName());
			attr.setSequence(2); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			tableFields = new TableFields();
			tableFields.setAttributeId(attr.getId());
			tableFields.setIsDocument(true);
			session.persist(tableFields);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Ano");
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Graduação");
			tableStructure.setInTotal(true);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Especialização");
			tableStructure.setInTotal(true);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Mestrado");
			tableStructure.setInTotal(true);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Doutorado");
			tableStructure.setInTotal(true);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Pós-doutorado");
			tableStructure.setInTotal(true);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Total");
			tableStructure.setType(TotalField.generateId(TotalField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);

			attr = new DocumentAttribute();
			attr.setName("Evolução no quadro permanente de docentes por regime de trabalho");
			attr.setSection(subsection);
			attr.setType(TableField.class.getCanonicalName());
			attr.setSequence(3); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			tableFields = new TableFields();
			tableFields.setAttributeId(attr.getId());
			tableFields.setIsDocument(true);
			session.persist(tableFields);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Ano");
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Dedicação exclusiva");
			tableStructure.setInTotal(true);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("40h");
			tableStructure.setInTotal(true);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("20h");
			tableStructure.setInTotal(true);
			tableStructure.setType(NumberField.generateId(NumberField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);
			tableStructure = new TableStructure();
			tableStructure.setLabel("Total");
			tableStructure.setType(TotalField.generateId(TotalField.class));
			tableStructure.setTableFields(tableFields);
			session.persist(tableStructure);

			// Subseção 8.2 - Plano de carreira
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Plano de carreira");
			subsection.setSequence(2); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Plano de carreira");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 8.3 - Critérios de seleção e contratação
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Critérios de seleção e contratação");
			subsection.setSequence(3); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Critérios de seleção e contratação");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 8.4 - Procedimentos para substituição (definitiva e
			// eventual) dos professores do quadro
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Procedimentos para substituição (definitiva e eventual) dos professores do quadro");
			subsection.setSequence(4); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName(
					"Procedimentos adotados pela IES, visando recomposição e substituição de professores do quadro");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 8.5 - Cronograma
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Cronograma e plano de expansão do corpo docente");
			subsection.setSequence(5); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Cronograma e plano de expansão do corpo docente");
			attr.setSection(subsection);
			attr.setType(ScheduleField.class.getCanonicalName());
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			schedule = new Schedule();
			schedule.setPeriodicityEnable(false);
			schedule.setAttributeId(attr.getId());
			schedule.setIsDocument(true);
			session.persist(schedule);

			// Subseção 8.6 - Objetivos e metas
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Objetivos e metas");
			subsection.setSequence(6); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição do plano de expansão do corpo docente");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			attr = new DocumentAttribute();
			attr.setName("Selecione o plano de metas correspondente");
			attr.setSection(subsection);
			attr.setType(SelectPlan.class.getCanonicalName());
			attr.setSequence(2); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 9 - Perfil do corpo técnico administrativo
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Perfil do corpo técnico administrativo");
			section.setSequence(9); // Número da seção para ordenar na exibição.
			section.setLeaf(false);
			session.persist(section);

			// Subseção 9.1 - Composição
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Composição");
			subsection.setSequence(1); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Composição");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 9.2 - Plano de carreira
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Plano de carreira");
			subsection.setSequence(2); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Plano de carreira");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 9.3 - Critérios de seleção e contratação
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Critérios de seleção e contratação");
			subsection.setSequence(3); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Apresentar os critérios de seleção e contratação de técnicos utilizados pela IES");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 9.4 - Procedimentos para substituição (definitiva e
			// eventual) dos professores do quadro
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Procedimentos para substituição (definitiva e eventual) dos técnicos do quadro");
			subsection.setSequence(4); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName(
					"Descrição dos procedimentos adotados pela IES, visando recomposição e substituição de técnicos do quadro");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 9.5 - Cronograma e plano de expansão do corpo técnico
			// administrativo
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Cronograma e plano de expansão do corpo técnico administrativo");
			subsection.setSequence(5); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Cronograma");
			attr.setSection(subsection);
			attr.setType(ScheduleField.class.getCanonicalName());
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			schedule = new Schedule();
			schedule.setPeriodicityEnable(false);
			schedule.setAttributeId(attr.getId());
			schedule.setIsDocument(true);
			session.persist(schedule);

			// Subseção 9.6 - Objetivos e metas
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Objetivos e metas");
			subsection.setSequence(6); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição do plano de expansão do corpo técnico administrativo");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			attr = new DocumentAttribute();
			attr.setName("Selecione o plano de metas correspondente");
			attr.setSection(subsection);
			attr.setType(SelectPlan.class.getCanonicalName());
			attr.setSequence(2); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 10 - Organização administrativa da IES
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Organização administrativa da IES");
			section.setSequence(10); // Número da seção para ordenar na
										// exibição.
			section.setLeaf(false);
			session.persist(section);

			// Subseção 10.1 - Estrutura Organizacional, Instâncias de Decisão e
			// Organograma Institucional e Acadêmico
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection
					.setName("Estrutura organizacional, instâncias de decisão e organograma institucional e acadêmico");
			subsection.setSequence(1); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrever a estrutura organizacional da IES");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 10.2 - Órgãos Colegiados
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Órgãos Colegiados");
			subsection.setSequence(2); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrever as competências e composição de cada órgão colegiado");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 10.3 - Órgãos de apoio às atividades acadêmicas
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Órgãos de apoio às atividades acadêmicas");
			subsection.setSequence(3); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrever as competências e composição de cada órgão de apoio");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 11 - Políticas de atendimento aos discentes
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Políticas de atendimento aos discentes");
			section.setSequence(11); // Número da seção para ordenar na
										// exibição.
			section.setLeaf(false);
			session.persist(section);

			// Subseção 11.1 - Programas de apoio pedagógico e financeiro
			// (bolsas)
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Programas de apoio pedagógico e financeiro (bolsas)");
			subsection.setSequence(1); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição de todos os programas de apoio pedagógico e financeiro");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 11.2 - Estímulos à permanência
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Estímulos à permanência");
			subsection.setSequence(2); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Estímulos à permanência");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 11.3 - Organização estudantil
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Organização estudantil");
			subsection.setSequence(3); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName(
					"Descrição dos espaços para participação e convivência estudantil, bem como dos órgãos de representatividade discente");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 11.4 - Acompanhamento dos egressos
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Acompanhamento dos egressos");
			subsection.setSequence(4); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição das formas de relação com os egressos");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 11.5 - Objetivos e metas
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Objetivos e metas");
			subsection.setSequence(5); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição do plano de atendimento aos discentes");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			attr = new DocumentAttribute();
			attr.setName("Selecione o plano de metas correspondente");
			attr.setSection(subsection);
			attr.setType(SelectPlan.class.getCanonicalName());
			attr.setSequence(2); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 12 - Infraestrutura
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Infraestrutura");
			section.setSequence(12); // Número da seção para ordenar na
										// exibição.
			section.setLeaf(false);
			session.persist(section);

			// Subseção 12.1 - Infraestrutura física
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Infraestrutura física");
			subsection.setSequence(1); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Detalhar infraestrutura física");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 12.2 - Biblioteca
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Biblioteca");
			subsection.setSequence(2); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Informações sobre a biblioteca");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			attr = new DocumentAttribute();
			attr.setName("Cronograma de expansão do acervo");
			attr.setSection(subsection);
			attr.setType(ScheduleField.class.getCanonicalName());
			attr.setSequence(2); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			schedule = new Schedule();
			schedule.setPeriodicityEnable(false);
			schedule.setAttributeId(attr.getId());
			schedule.setIsDocument(true);
			session.persist(schedule);

			// Subseção 12.3 - Laboratórios
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Laboratórios");
			subsection.setSequence(3); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Informações sobre os laboratórios");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 12.4 - Recursos tecnológicos e de áudio visual
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Recursos tecnológicos e de áudio visual");
			subsection.setSequence(4); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrever os recursos presentes na IES, e o planejamento de melhorias nessa área");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 12.5 - Plano de promoção de acessibilidade e de
			// atendimento diferenciado a portadores de necessidades especiais
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName(
					"Plano de promoção de acessibilidade e de atendimento diferenciado a portadores de necessidades especiais");
			subsection.setSequence(5); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Ações planejadas para promover acessibilidade aos portadores de necessidades especiais");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Subseção 12.6 - Cronograma de expansão da infra-estrutura para o
			// período de vigência do PDI
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Cronograma de expansão da infraestrutura para o período de vigência do PDI");
			subsection.setSequence(6); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Cronograma de implementação das ações voltadas para a infraestrutura");
			attr.setSection(subsection);
			attr.setType(ScheduleField.class.getCanonicalName());
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			schedule = new Schedule();
			schedule.setPeriodicityEnable(false);
			schedule.setAttributeId(attr.getId());
			schedule.setIsDocument(true);
			session.persist(schedule);

			// Subseção 12.7 - Objetivos e metas
			subsection = new DocumentSection();
			subsection.setDocument(document);
			subsection.setName("Objetivos e metas");
			subsection.setSequence(7); // Número da subseção para ordenar na
										// exibição.
			subsection.setParent(section);
			subsection.setLeaf(true);
			session.persist(subsection);

			attr = new DocumentAttribute();
			attr.setName("Descrição do plano de expansão da infraestrutura");
			attr.setSection(subsection);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			attr = new DocumentAttribute();
			attr.setName("Selecione o plano de metas correspondente");
			attr.setSection(subsection);
			attr.setType(SelectPlan.class.getCanonicalName());
			attr.setSequence(2); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 13 - Avaliação e acompanhamento do desenvolvimento
			// institucional
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Avaliação e acompanhamento do desenvolvimento institucional");
			section.setSequence(13); // Número da seção para ordenar na
										// exibição.
			section.setLeaf(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName("Descrever os procedimentos utilizados para a realização da autoavaliação da IES");
			attr.setSection(section);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 14 - Gestão financeira e orçamentária
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Gestão financeira e orçamentária");
			section.setSequence(14); // Número da seção para ordenar na
										// exibição.
			section.setLeaf(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName(
					"Apresentar ações relacionadas à melhoria da gestão financeira da IES, bem como demonstrar a sustentabilidade financeira");
			attr.setSection(section);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 15 - Processo de monitoramento, controle e revisão do PDI
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Processo de monitoramento, controle e revisão do PDI");
			section.setSequence(15); // Número da seção para ordenar na
										// exibição.
			section.setLeaf(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName(
					"Apresentar o planejamento das atividades de controle que ocorrerão durante a vigência do PDI");
			attr.setSection(section);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			attr = new DocumentAttribute();
			attr.setName("Cronograma de execução");
			attr.setSection(section);
			attr.setType(ScheduleField.class.getCanonicalName());
			attr.setSequence(2); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			schedule = new Schedule();
			schedule.setPeriodicityEnable(false);
			schedule.setAttributeId(attr.getId());
			schedule.setIsDocument(true);
			session.persist(schedule);

			// Seção 16 - Plano para gestão de riscos
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Plano para gestão de riscos");
			section.setSequence(16); // Número da seção para ordenar na
										// exibição.
			section.setLeaf(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName("Análise de riscos e o plano em caso de ocorrência");
			attr.setSection(section);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 17 - Conclusão
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Conclusão");
			section.setSequence(17); // Número da seção para ordenar na
										// exibição.
			section.setLeaf(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName("Conclusão do documento de PDI");
			attr.setSection(section);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 18 - Anexos
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Anexos");
			section.setSequence(18); // Número da seção para ordenar na
										// exibição.
			section.setLeaf(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName("Descrição dos anexos");
			attr.setSection(section);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

			// Seção 19 - Apêndice
			section = new DocumentSection();
			section.setDocument(document);
			section.setName("Apêndice");
			section.setSequence(19); // Número da seção para ordenar na
										// exibição.
			section.setLeaf(true);
			session.persist(section);

			attr = new DocumentAttribute();
			attr.setName("Descrição dos apêndices");
			attr.setSection(section);
			attr.setType(TextArea.generateId(TextArea.class));
			attr.setSequence(1); // Ordem do atributo dentro da seção
			attr.setRequired(false);
			session.persist(attr);

		}

	}
}
```


Overlapping Code:
```
 ForpladHelper {
private final HibernateDAO dao;
public ForpladHelper(HibernateDAO dao) {
this.dao = dao;
}
public Document initializeDocument(PlanMacro plan) {
if (plan == null) {
throw new IllegalArgumentException("You must provide a PlanMacro to initialize a Forplad Document.");
}
Document document = this.retrieveByPlan(plan);
if (document != null) {
throw new IllegalArgumentException("The provided PlanMacro already has a Document.");
}
DocumentCreator creator = new DocumentCreator(plan);
this.dao.execute(creator);
return creator.document;
}
public Document retrieveByPlan(PlanMacro plan) {
Criteria criteria = this.dao.newCriteria(Document.class).add(Restrictions.eq("plan", plan));
return (Document) criteria.uniqueResult();
}
/**
* Classe privada que insere a estrutura do documento FORPLAD em uma única
* transação do banco de dados.
* 
tor implements TransactionalOperation {
public final Document document;
public DocumentCreator(PlanMacro plan) {
this.document = new Document();
this.document.setPlan(plan);
this.document.setDescription("O PDI, elaborado para um período de cinco anos, é o documento"
+ " que identifica a IES no que diz respeito à sua filosofia de trabalho, à missão a que se propõe, "
+ "às diretrizes pedagógicas que orientam suas ações, à sua estrutura organizacional "
+ "e às atividades acadêmicas que desenvolve e/ou que pretende desenvolver " + "</br>" + "</br>"
+ "</br>" + "Atenção: Evite colar textos formatados nas seções do Documento do PDI.");
this.document.setTitle("Documento - " + plan.getName());
}
@Override
public void execute(Session session) throws HibernateException {
DocumentSection section, subsection;
DocumentAttribute attr;
Schedule schedule;
TableFields tableFields;
TableStructure tableStructure;
OptionsField optionsField;
session.persist(this.document);
// SEÇÕES NÃO NUMERADAS - PRÉ TEXTUAIS
// Seção 1 - Ficha técnica
section = new DocumentSection();
section.setDocument(document);
section.setName("Ficha técnica");
section.setSequence(1); // Número da seção para ordenar na exibição.
section.setLeaf(true);
section.setPreTextSection(true);
session.persist(section);
attr = new DocumentAttribute();
attr.setName("Ficha Técnica");
attr.setSection(section);
attr.setType(TableField.class.getC
```
<Overlap Ratio: 0.9674239177025289>

---

--- 68 --
Question ID: a2d196adf032d898ad48dcfdb93c63bcb959f615
Original Code:
```
public class RealmITCase extends AbstractITCase {

    private static Optional<RealmTO> getRealm(final String fullPath) {
        return realmService.list(fullPath).stream().filter(realm -> fullPath.equals(realm.getFullPath())).findFirst();
    }

    @Test
    public void search() {
        PagedResult<RealmTO> match = realmService.search(new RealmQuery.Builder().keyword("*o*").build());
        assertTrue(match.getResult().stream().allMatch(realm -> realm.getName().contains("o")));
    }

    @Test
    public void list() {
        List<RealmTO> realms = realmService.list(SyncopeConstants.ROOT_REALM);
        assertNotNull(realms);
        assertFalse(realms.isEmpty());
        realms.forEach(Assertions::assertNotNull);

        try {
            realmService.list("a name");
            fail("This should not happen");
        } catch (SyncopeClientException e) {
            assertEquals(ClientExceptionType.InvalidPath, e.getType());
        }
    }

    @Test
    public void createUpdate() {
        RealmTO realm = new RealmTO();
        realm.setName("last");

        // 1. create
        Response response = realmService.create("/even/two", realm);
        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);
        assertNotNull(actuals);
        assertTrue(actuals.length > 0);
        RealmTO actual = actuals[0];
        assertNotNull(actual.getKey());
        assertEquals("last", actual.getName());
        assertEquals("/even/two/last", actual.getFullPath());
        assertEquals(actual.getParent(), getRealm("/even/two").get().getKey());
        assertNull(realm.getAccountPolicy());
        assertNull(realm.getPasswordPolicy());

        // 2. update setting policies
        actual.setAccountPolicy("06e2ed52-6966-44aa-a177-a0ca7434201f");
        actual.setPasswordPolicy("986d1236-3ac5-4a19-810c-5ab21d79cba1");
        actual.setAuthPolicy("b912a0d4-a890-416f-9ab8-84ab077eb028");
        actual.setAccessPolicy("419935c7-deb3-40b3-8a9a-683037e523a2");
        actual.setAttrReleasePolicy("319935c7-deb3-40b3-8a9a-683037e523a2");
        realmService.update(actual);

        actual = getRealm(actual.getFullPath()).get();
        assertNotNull(actual.getAccountPolicy());
        assertNotNull(actual.getPasswordPolicy());
        assertNotNull(actual.getAuthPolicy());
        assertNotNull(actual.getAccessPolicy());
        assertNotNull(actual.getAttrReleasePolicy());

        // 3. update changing parent
        actual.setParent(getRealm("/odd").get().getKey());
        realmService.update(actual);

        actual = getRealm("/odd/last").get();
        assertNotNull(actual);
        assertEquals("/odd/last", actual.getFullPath());

        assertEquals(1, realmService.list(SyncopeConstants.ROOT_REALM).stream().
                filter(object -> realm.getName().equals(object.getName())).count());

        // 4. create under invalid path
        try {
            realmService.create("a name", realm);
            fail("This should not happen");
        } catch (SyncopeClientException e) {
            assertEquals(ClientExceptionType.InvalidPath, e.getType());
        }

        // 5. attempt to create duplicate
        try {
            realmService.create("/odd", realm);
            fail("This should not happen");
        } catch (SyncopeClientException e) {
            assertEquals(ClientExceptionType.EntityExists, e.getType());
        }
    }

    @Test
    public void createWithTilde() {
        RealmTO realm = new RealmTO();
        realm.setName("73~1~19534");

        Response response = realmService.create("/even/two", realm);
        assertEquals(Response.Status.CREATED.getStatusCode(), response.getStatus());

        List<RealmTO> realms = realmService.list("/even/two/73~1~19534");
        assertEquals(1, realms.size());
        assertEquals(realm.getName(), realms.get(0).getName());
    }

    @Test
    public void deletingAccountPolicy() {
        // 1. create account policy
        DefaultAccountRuleConf ruleConf = new DefaultAccountRuleConf();
        ruleConf.setMinLength(3);
        ruleConf.setMaxLength(8);

        ImplementationTO rule = new ImplementationTO();
        rule.setKey("DefaultAccountRuleConf" + UUID.randomUUID().toString());
        rule.setEngine(ImplementationEngine.JAVA);
        rule.setType(IdRepoImplementationType.ACCOUNT_RULE);
        rule.setBody(POJOHelper.serialize(ruleConf));
        Response response = implementationService.create(rule);
        rule.setKey(response.getHeaderString(RESTHeaders.RESOURCE_KEY));

        AccountPolicyTO policy = new AccountPolicyTO();
        policy.setDescription("deletingAccountPolicy");
        policy.getRules().add(rule.getKey());

        policy = createPolicy(PolicyType.ACCOUNT, policy);
        assertNotNull(policy);

        // 2. create realm with policy assigned
        RealmTO realm = new RealmTO();
        realm.setName("withPolicy");

        response = realmService.create(SyncopeConstants.ROOT_REALM, realm);
        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);
        assertNotNull(actuals);
        assertTrue(actuals.length > 0);
        realm = actuals[0];

        String existingAccountPolicy = realm.getAccountPolicy();

        realm.setAccountPolicy(policy.getKey());
        realmService.update(realm);

        actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);
        assertNotNull(actuals);
        assertTrue(actuals.length > 0);
        RealmTO actual = actuals[0];
        assertEquals(policy.getKey(), actual.getAccountPolicy());

        // 3. remove policy
        policyService.delete(PolicyType.ACCOUNT, policy.getKey());

        // 4. verify
        actual = getRealm(actual.getFullPath()).get();
        assertEquals(existingAccountPolicy, actual.getAccountPolicy());
    }

    @Test
    public void deletingAuthPolicy() {
        // 1. create authentication policy
        DefaultAuthPolicyConf ruleConf = new DefaultAuthPolicyConf();
        ruleConf.getAuthModules().addAll(List.of("LdapAuthentication1"));

        AuthPolicyTO policy = new AuthPolicyTO();
        policy.setDescription("Test Authentication policy");
        policy.setConf(ruleConf);
        policy = createPolicy(PolicyType.AUTH, policy);
        assertNotNull(policy);

        // 2. create realm with policy assigned
        RealmTO realm = new RealmTO();
        realm.setName("withAuthPolicy");

        Response response = realmService.create(SyncopeConstants.ROOT_REALM, realm);
        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);
        assertNotNull(actuals);
        assertTrue(actuals.length > 0);
        realm = actuals[0];

        String existingAuthPolicy = realm.getAuthPolicy();

        realm.setAuthPolicy(policy.getKey());
        realmService.update(realm);

        actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);
        assertNotNull(actuals);
        assertTrue(actuals.length > 0);
        RealmTO actual = actuals[0];
        assertEquals(policy.getKey(), actual.getAuthPolicy());

        // 3. remove policy
        policyService.delete(PolicyType.AUTH, policy.getKey());

        // 4. verify
        actual = getRealm(actual.getFullPath()).get();
        assertEquals(existingAuthPolicy, actual.getAuthPolicy());
    }

    @Test
    public void deletingAccessPolicy() {
        // 1. create access policy
        DefaultAccessPolicyConf ruleConf = new DefaultAccessPolicyConf();
        ruleConf.setEnabled(true);
        ruleConf.addRequiredAttr("cn", Set.of("admin", "Admin", "TheAdmin"));

        AccessPolicyTO policy = new AccessPolicyTO();
        policy.setDescription("Test Access policy");
        policy.setConf(ruleConf);
        policy = createPolicy(PolicyType.ACCESS, policy);
        assertNotNull(policy);

        // 2. create realm with policy assigned
        RealmTO realm = new RealmTO();
        realm.setName("withAccessPolicy");

        Response response = realmService.create(SyncopeConstants.ROOT_REALM, realm);
        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);
        assertNotNull(actuals);
        assertTrue(actuals.length > 0);
        realm = actuals[0];

        String existingAccessPolicy = realm.getAccessPolicy();

        realm.setAccessPolicy(policy.getKey());
        realmService.update(realm);

        actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);
        assertNotNull(actuals);
        assertTrue(actuals.length > 0);
        RealmTO actual = actuals[0];
        assertEquals(policy.getKey(), actual.getAccessPolicy());

        // 3. remove policy
        policyService.delete(PolicyType.ACCESS, policy.getKey());

        // 4. verify
        actual = getRealm(actual.getFullPath()).get();
        assertEquals(existingAccessPolicy, actual.getAccessPolicy());
    }

    @Test
    public void deletingAttributeReleasePolicy() {
        // 1. create attribute release policy
        AllowedAttrReleasePolicyConf ruleConf = new AllowedAttrReleasePolicyConf();
        ruleConf.getAllowedAttrs().addAll(List.of("cn", "givenName"));

        AllowedAttrReleasePolicyConf.ConsentPolicy consentPolicy1 = ruleConf.new ConsentPolicy();
        consentPolicy1.getIncludeOnlyAttrs().addAll(Set.of("cn"));
        ruleConf.setConsentPolicy(consentPolicy1);

        AttrReleasePolicyTO policy = new AttrReleasePolicyTO();
        policy.setDescription("Test Attribute Release policy");
        policy.setConf(ruleConf);
        policy = createPolicy(PolicyType.ATTR_RELEASE, policy);
        assertNotNull(policy);

        // 2. create realm with policy assigned
        RealmTO realm = new RealmTO();
        realm.setName("withAttrReleasePolicy");

        Response response = realmService.create(SyncopeConstants.ROOT_REALM, realm);
        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);
        assertNotNull(actuals);
        assertTrue(actuals.length > 0);
        realm = actuals[0];

        String existingAttrReleasePolicy = realm.getAttrReleasePolicy();

        realm.setAttrReleasePolicy(policy.getKey());
        realmService.update(realm);

        actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);
        assertNotNull(actuals);
        assertTrue(actuals.length > 0);
        RealmTO actual = actuals[0];
        assertEquals(policy.getKey(), actual.getAttrReleasePolicy());

        // 3. remove policy
        policyService.delete(PolicyType.ATTR_RELEASE, policy.getKey());

        // 4. verify
        actual = getRealm(actual.getFullPath()).get();
        assertEquals(existingAttrReleasePolicy, actual.getAttrReleasePolicy());
    }

    @Test
    public void delete() {
        RealmTO realm = new RealmTO();
        realm.setName("deletable3");

        Response response = realmService.create("/even/two", realm);
        RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);
        assertNotNull(actuals);
        assertTrue(actuals.length > 0);
        RealmTO actual = actuals[0];

        realmService.delete(actual.getFullPath());

        try {
            realmService.list(actual.getFullPath());
            fail("This should not happen");
        } catch (SyncopeClientException e) {
            assertEquals(ClientExceptionType.NotFound, e.getType());
        }
    }

    @Test
    public void deleteNonEmpty() {
        try {
            realmService.delete("/even/two");
            fail("This should not happen");
        } catch (SyncopeClientException e) {
            assertEquals(ClientExceptionType.AssociatedAnys, e.getType());
            assertEquals(3, e.getElements().size());
        }
    }

    @Test
    public void propagate() {
        // 1. create realm and add the LDAP resource
        RealmTO realm = new RealmTO();
        realm.setName("test");
        realm.getResources().add(RESOURCE_NAME_LDAP_ORGUNIT);
        RealmTO childRealm = new RealmTO();
        childRealm.setName("child");
        childRealm.getResources().add(RESOURCE_NAME_LDAP_ORGUNIT);
        RealmTO descendantRealm = new RealmTO();
        descendantRealm.setName("test");
        descendantRealm.getResources().add(RESOURCE_NAME_LDAP_ORGUNIT);

        // 2. check propagation
        ProvisioningResult<RealmTO> result = realmService.create("/", realm).readEntity(
                new GenericType<ProvisioningResult<RealmTO>>() {
        });
        assertNotNull(result);
        assertEquals(1, result.getPropagationStatuses().size());
        assertEquals(RESOURCE_NAME_LDAP_ORGUNIT, result.getPropagationStatuses().get(0).getResource());
        assertEquals(ExecStatus.SUCCESS, result.getPropagationStatuses().get(0).getStatus());

        ProvisioningResult<RealmTO> resultChild = realmService.create("/test", childRealm).readEntity(
                new GenericType<ProvisioningResult<RealmTO>>() {
        });
        assertNotNull(resultChild);
        assertEquals(1, resultChild.getPropagationStatuses().size());
        assertEquals(RESOURCE_NAME_LDAP_ORGUNIT, resultChild.getPropagationStatuses().get(0).getResource());
        assertEquals(ExecStatus.SUCCESS, resultChild.getPropagationStatuses().get(0).getStatus());

        ProvisioningResult<RealmTO> resultDescendant = realmService.create("/test/child", descendantRealm).readEntity(
                new GenericType<ProvisioningResult<RealmTO>>() {
        });
        assertNotNull(resultDescendant);
        assertEquals(1, resultDescendant.getPropagationStatuses().size());
        assertEquals(RESOURCE_NAME_LDAP_ORGUNIT, resultDescendant.getPropagationStatuses().get(0).getResource());
        assertEquals(ExecStatus.SUCCESS, resultDescendant.getPropagationStatuses().get(0).getStatus());

        // 3. check on LDAP
        assertNotNull(
                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, "ou=test,o=isp"));
        assertNotNull(
                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, "ou=child,ou=test,o=isp"));
        assertNotNull(
                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, "ou=test,ou=child,ou=test,o=isp"));

        // 4. remove realms
        realmService.delete("/test/child/test");
        realmService.delete("/test/child");
        realmService.delete("/test");

        // 5. check on LDAP: both realms should be deleted
        assertNull(
                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, "ou=test,ou=child,ou=test,o=isp"));
        assertNull(
                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, "ou=child,ou=test,o=isp"));
        assertNull(
                getLdapRemoteObject(RESOURCE_LDAP_ADMIN_DN, RESOURCE_LDAP_ADMIN_PWD, "ou=test,o=isp"));
    }

    @Test
    public void issueSYNCOPE1472() {
        // 1. assign twice resource-ldap-orgunit to /odd
        RealmTO realmTO = realmService.list("/odd").get(0);
        realmTO.getResources().clear();
        realmTO.getResources().add("resource-ldap-orgunit");
        realmTO.getResources().add("resource-ldap-orgunit");
        realmTO = realmService.update(realmTO).readEntity(new GenericType<ProvisioningResult<RealmTO>>() {
        }).getEntity();

        // 2. remove resource-ldap-orgunit resource
        realmTO.getResources().remove("resource-ldap-orgunit");

        realmTO = realmService.update(realmTO).readEntity(new GenericType<ProvisioningResult<RealmTO>>() {
        }).getEntity();

        assertFalse(realmTO.getResources().contains("resource-ldap-orgunit"), "Should not contain removed resources");
    }
}
```


Overlapping Code:
```
ic class RealmITCase extends AbstractITCase {
private static Optional<RealmTO> getRealm(final String fullPath) {
return realmService.list(fullPath).stream().filter(realm -> fullPath.equals(realm.getFullPath())).findFirst();
}
@Test
public void search() {
PagedResult<RealmTO> match = realmService.search(new RealmQuery.Builder().keyword("*o*").build());
assertTrue(match.getResult().stream().allMatch(realm -> realm.getName().contains("o")));
}
@Test
public void list() {
List<RealmTO> realms = realmService.list(SyncopeConstants.ROOT_REALM);
assertNotNull(realms);
assertFalse(realms.isEmpty());
realms.forEach(Assertions::assertNotNull);
try {
realmService.list("a name");
fail("This should not happen");
} catch (SyncopeClientException e) {
assertEquals(ClientExceptionType.InvalidPath, e.getType());
}
}
@Test
public void createUpdate() {
RealmTO realm = new RealmTO();
realm.setName("last");
// 1. create
Response response = realmService.create("/even/two", realm);
RealmTO[] actuals = getObject(response.getLocation(), RealmService.class, RealmTO[].class);
assertNotNull(actuals);
assertTrue(actuals.length > 0);
RealmTO actual = actuals[0];
assertNotNull(actual.getKey());
assertEquals("last", actual.getName());
assertEquals("/even/two/last", actual.getFullPath());
assertEquals(actual.getParent(), getRealm("/even/two").get().getKey());
assertNull(realm.getAccountPolicy());
assertNull(realm.getPasswordPolicy());
// 2. update setting policies
actual.set9a-683037e523a2");
actual.setAttrReleasePolicy("319935c7-deb3-40b3-8a9a-683037e523a2");
realmService.update(actual);
actual = getRealm(actual.getFullPath()).get();
assertNotNull(actual.getAccountPolicy());
assertNotNull(actual.getPasswordPolicy());
assertNotNull(actual.getAuthPolicy());
assertNotNull(actual.getAccessPolicy());
assertNotNull(actual.getAttrReleasePolicy());
// 3. update changing par
```
<Overlap Ratio: 0.8862987630827783>

---

--- 69 --
Question ID: fffc2b06975a35486c445b178e8f8505b695b312
Original Code:
```
public class Ball implements Runnable {

    private int x, y;
    private int diameter;
    private int rateOfFall;
    private Color color;
    private boolean isAlive;

    public Ball(final int x, final int y) {
        this.x = x;
        this.y = y;
        this.diameter = new Random().nextInt(50 - 20 + 1) + 20;
        this.generateRandomColor();
        this.setRateOfFall();
    }

    private void generateRandomColor() {
        Random random = new Random();
        float r = random.nextFloat();
        float g = random.nextFloat();
        float b = random.nextFloat();
        this.color = new Color(r, g, b);
    }

    private void setRateOfFall() {
        this.rateOfFall = new Random().nextInt(10 - 1 + 1) + 1;

    }

    private int getRateOfFall() {
        return this.rateOfFall;
    }

    public int getX() {
        return this.x;
    }

    public void setX(final int x) {
        this.x = x;
    }

    public int getY() {
        return this.y;
    }

    public void setY(final int y) {
        this.y = y;
    }

    public int getDiameter() {
        return this.diameter;
    }

    public void setDiameter(int diameter) {
        this.diameter = diameter;
    }

    public Color getColor() {
        return this.color;
    }

    public void setColor(Color color) {
        this.color = color;
    }


    @Override
    public void run() {
        this.isAlive = true;
        int end = 398 - getDiameter();
        for (int i = this.y; i < end; i++) {
            this.y = i;
            try {
                Thread.sleep(this.rateOfFall);
            } catch (InterruptedException iex) {
                iex.printStackTrace();
            }
        }
        while (this.color.getRGB() != -1) {
            this.color = this.color.brighter();
            try {
                Thread.sleep(500);
            } catch (InterruptedException iex) {
                iex.printStackTrace();
            }
        }
        this.isAlive = false;
    }

    public boolean isAlive() {
        return this.isAlive;
    }

    public void setAlive(boolean alive) {
        isAlive = alive;
    }
}
```


Overlapping Code:
```
ts Runnable {
private int x, y;
private int diameter;
private int rateOfFall;
private Color color;
private boolean isAlive;
public Ball(final int x, final int y) {
this.x = x;
this.y = y;
this.diameter = new Random().nextInt(50 - 20 + 1) + 20;
this.generateRandomColor();
this.setRateOfFall();
}
private void generateRandomColor() {
Random random = new Random();
float r = random.nextFloat();
float g = random.nextFloat();
float b = random.nextFloat();
this.color = new Color(r, g, b);
}
private void setRateOfFall() {
this.rateOfFall = new Random().nextInt(10 - 1 + 1) + 1;
}
private int getRateOfFall() {
return this.rateOfFall;
}
public int getX() {
return this.x;
}
public void setX(final int x) {
this.x = x;
}
public int getY() {
return this.y;
}
public void setY(final int y) {
this.y = y;
}
public int getDiameter() {
return this.diameter;
}
public void setDiameter(int diameter) {
this.diameter = diameter;
}
public Color getColor() {
return this.color;
}
public void setColor(Color color) {
this.color = color;
}
@Override
public void run() {
this.isAlive = true;
int end = 398 - getDiameter();
for (int i = this.y; i < end; i++) {
this.y = i;
try {
Thread.sleep(this.rateOfFall);
} catch (InterruptedException iex) {
iex.printStackTrace();
}
}
while (this.color.getRGB() != -1) {
this.color = this.color.brighter();
try {
Thread.sleep(500);
} catch (InterruptedException iex) {
iex.printStackTrace();
}
}
this.isAlive = false;
}
public boolean isAlive() {
return this.isAlive;
}
public void setAlive(boolean alive) {
isAlive = alive;
}
}
```
<Overlap Ratio: 0.9834815756035579>

---

--- 70 --
Question ID: cc8d3967434360dd9a5cdc85ebe3b54265a2cb0e
Original Code:
```
@Service("requestSigner")
public class CorsRequestSignerImpl implements CorsRequestSignerTemplate {
    private static final Logger LOGGER = LoggerFactory.getLogger(CorsRequestSignerImpl.class);

    private static final String PROTOCOL = "https://";
    private static final String S3_URL = "s3.amazonaws.com";
    private static final String MIME_TYPE = "application/octet-stream";
    private static final String AMAZON_UPLOAD_HEADERS = "x-amz-acl:private";
    private static final String AMAZON_SSE_HEADERS = "x-amz-server-side-encryption:AES256";
    private static final String AMAZON_SECURITY_TOKEN_HEADER = "x-amz-security-token";
    private static final String HMAC_SHA1_ALGORITHM = "HmacSHA1";
    private static final String UTF_8 = "UTF-8";

    private final FileMetaDataRepository fileMetaDataRepository;
    private final AWSCredentialsProvider credentialsProvider;
    private final AmazonPropertiesProvider amazonPropertiesProvider;

    @Inject
    public CorsRequestSignerImpl(FileMetaDataRepository fileMetaDataRepository,
                                 CloudStorageClientsProvider cloudStorageClientsProvider,
                                 AmazonPropertiesProvider amazonPropertiesProvider) {
        this.fileMetaDataRepository = fileMetaDataRepository;
        this.credentialsProvider = cloudStorageClientsProvider.getS3FileOperationHandler().getCredentialsProvider();
        this.amazonPropertiesProvider = amazonPropertiesProvider;
    }

    @Override
    public String signSingleFileUploadRequest(long userId, String objectName) {
        final String bucket = getBucketForSingleRequest(objectName);
        long expireTime = new Date().getTime() / 1000 + (60 * 5); // 2000 minutes from now
        objectName = urlencode(objectName);

        String stringToSign = "PUT\n\n"
            + MIME_TYPE + "\n"
            + expireTime + "\n"
            + AMAZON_UPLOAD_HEADERS + "\n"
            + (useServerSideEncryption() ? AMAZON_SSE_HEADERS + "\n" : "")
            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + ":" + getAmazonToken() + "\n" : "")
            + DELIMITER + bucket + DELIMITER + objectName;

        String signature = urlencode(calculateRFC2104HMAC(stringToSign, getAmazonSecret()));

        return urlencode(PROTOCOL + bucket + "." + S3_URL + DELIMITER + objectName
                             + "?AWSAccessKeyId=" + getAmazonKey() + "&Expires=" +
                             expireTime + "&Signature=" + signature
        );
    }

    private String getAmazonKey() {
        if (credentialsProvider != null) {
            return credentialsProvider.getCredentials().getAWSAccessKeyId();
        }

        return "";
    }

    private String getAmazonSecret() {
        if (credentialsProvider != null) {
            return credentialsProvider.getCredentials().getAWSSecretKey();
        }

        return "";
    }

    @Override
    public String getAmazonToken() {
        if (credentialsProvider != null && credentialsProvider instanceof InstanceProfileCredentialsProvider) {
            return ((BasicSessionCredentials) credentialsProvider.getCredentials()).getSessionToken();
        }

        return "";
    }

    @Override
    public boolean useSessionToken() {
        return (credentialsProvider != null && credentialsProvider instanceof InstanceProfileCredentialsProvider);
    }

    @Override
    public SignedRequest signForSingleFileUploadRequest(long userId, String objectName) {
        try {
            return new SignedRequest(
                null,
                URLDecoder.decode(signSingleFileUploadRequest(userId, objectName), "UTF-8"),
                null,
                getAmazonToken()
            );
        } catch (UnsupportedEncodingException e) {
            throw Throwables.propagate(e);
        }
    }

    //new multipart upload request signing methods
    //todo[tymchenko]: generify methods

    @Override
    public SignedRequest signInitialUploadRequest(long userId, String objectName) {
        final String bucket = processObjectForInitialUploadRequest(objectName);
        final String formattedDate = getAmzFormattedDate();
        objectName = urlencode(objectName);

        final String queryParams = "?uploads";
        String stringToSign = "POST\n\n"
            + "\n"
            + "\n"
            + AMAZON_UPLOAD_HEADERS + "\n"
            + "x-amz-date:" + formattedDate + "\n"
            + (useServerSideEncryption() ? AMAZON_SSE_HEADERS + "\n" : "")
            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + ":" + getAmazonToken() + "\n" : "")
            + DELIMITER + bucket + DELIMITER + objectName + queryParams;

        LOGGER.info(" **** StringToSign: {}", stringToSign);

        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());

        final String authorization = "AWS " + getAmazonKey() + ":" + signature;
        final String host = PROTOCOL + bucket + ".s3.amazonaws.com" + DELIMITER + objectName + queryParams;

        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());
    }


    @Override
    public SignedRequest signUploadPartRequest(long userId, String objectName, long partNumber, String uploadId) {
        final String objectBucket = getObjectBucket(objectName);
        final String formattedDate = getAmzFormattedDate();
        objectName = urlencode(objectName);

        final String queryParams = "?partNumber=" + partNumber + "&uploadId=" + uploadId;
        String stringToSign = "PUT\n\n"
            + MIME_TYPE + "\n"
            + "\n"
            + "x-amz-date:" + formattedDate + "\n"
            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + ":" + getAmazonToken() + "\n" : "")
            + DELIMITER + objectBucket + DELIMITER + objectName + queryParams;

        LOGGER.info(" **** StringToSign: {}", stringToSign);

        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());

        final String authorization = "AWS " + getAmazonKey() + ":" + signature;
        final String host = PROTOCOL + objectBucket + ".s3.amazonaws.com" + DELIMITER + objectName + queryParams;

        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());
    }

    @Override
    public SignedRequest signListPartsRequest(long userId, String objectName, String uploadId) {
        final String objectBucket = getObjectBucket(objectName);
        final String formattedDate = getAmzFormattedDate();
        objectName = urlencode(objectName);

        final String queryParams = "?uploadId=" + uploadId;
        String stringToSign = "GET\n\n"
            + "\n"
            + "\n"
            + "x-amz-date:" + formattedDate + "\n"
            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + ":" + getAmazonToken() + "\n" : "")
            + DELIMITER + objectBucket + DELIMITER + objectName + queryParams;

        LOGGER.info(" **** StringToSign: {}", stringToSign);

        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());

        final String authorization = "AWS " + getAmazonKey() + ":" + signature;
        final String host = PROTOCOL + objectBucket + ".s3.amazonaws.com" + DELIMITER + objectName + queryParams;

        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());
    }


    @Override
    public SignedRequest signAbortUploadRequest(long userId, String objectName, String uploadId) {
        final String objectBucket = getObjectBucket(objectName);
        final String formattedDate = getAmzFormattedDate();
        objectName = urlencode(objectName);

        final String queryParams = "?uploadId=" + uploadId;
        String stringToSign = "DELETE\n\n"
            + "\n"
            + "\n"
            + "x-amz-date:" + formattedDate + "\n"
            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + ":" + getAmazonToken() + "\n" : "")
            + DELIMITER + objectBucket + DELIMITER + objectName + queryParams;

        LOGGER.info(" **** StringToSign: {}", stringToSign);

        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());

        final String authorization = "AWS " + getAmazonKey() + ":" + signature;
        final String host = PROTOCOL + objectBucket + ".s3.amazonaws.com" + DELIMITER + objectName + queryParams;

        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());
    }


    @Override
    public SignedRequest signCompleteUploadRequest(long userId,
                                                   String objectName,
                                                   String uploadId,
                                                   boolean addCharsetToContentType) {
        final String bucket = processCompleteUploadRequest(objectName);
        final String formattedDate = getAmzFormattedDate();
        objectName = urlencode(objectName);

        final String queryParams = "?uploadId=" + uploadId;
        final String textXmlContentType = "text/xml";
        final String contentType = addCharsetToContentType
            ? (textXmlContentType + "; charset=UTF-8")
            : textXmlContentType;

        String stringToSign = "POST\n\n"
            + contentType + "\n"
            + "\n"
            + "x-amz-date:" + formattedDate + "\n"
            + (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + ":" + getAmazonToken() + "\n" : "")
            + DELIMITER + bucket + DELIMITER + objectName + queryParams;

        LOGGER.info(" **** StringToSign: {}", stringToSign);

        final String signature = calculateRFC2104HMAC(stringToSign, getAmazonSecret());

        final String authorization = "AWS " + getAmazonKey() + ":" + signature;
        final String host = PROTOCOL + bucket + ".s3.amazonaws.com" + DELIMITER + objectName + queryParams;

        return new SignedRequest(formattedDate, host, authorization, getAmazonToken());
    }

    @Override
    public boolean useServerSideEncryption() {
        return amazonPropertiesProvider.isServersideEncryptionEnabled();
    }

    // --- Helper methods ----

    private static String getAmzFormattedDate() {
        final Date date = new Date();

        final SimpleDateFormat simpleDateFormat = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss Z", Locale.ENGLISH);
        return simpleDateFormat.format(date);
    }

    private static String urlencode(String s) {
        try {
            return URLEncoder.encode(s, UTF_8);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static String calculateRFC2104HMAC(String data, String key) {
        String result;
        try {

            // get an hmac_sha1 key from the raw key bytes
            SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_SHA1_ALGORITHM);

            // get an hmac_sha1 Mac instance and initialize with the signing key
            Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);
            mac.init(signingKey);

            // compute the hmac on input data bytes
            byte[] rawHmac = mac.doFinal(data.getBytes());

            // base64-encode the hmac
            result = new String(Base64.encodeBase64(rawHmac), UTF_8);

        } catch (Exception e) {
            throw new IllegalStateException(e);
        }

        return result;
    }

    private String processObjectForInitialUploadRequest(String objectName) {
        return Optional.ofNullable(fileMetaDataRepository.findByDestinationPath(objectName)).map(metaFile -> {
            final String bucket = bucketForFileMetaData(metaFile);
            metaFile.setFileUploadBucket(bucket);
            fileMetaDataRepository.save(metaFile);
            return bucket;
        }).orElse(amazonPropertiesProvider.getActiveBucket());
    }

    private String getBucketForSingleRequest(String object) {

        return Optional.ofNullable(fileMetaDataRepository.findByDestinationPath(object))
            .map(this::bucketForFileMetaData)
            .orElse(amazonPropertiesProvider.getActiveBucket());
    }

    private String processCompleteUploadRequest(String objectName) {

        return Optional.ofNullable(fileMetaDataRepository.findByDestinationPath(objectName)).map(input -> {
            final String bucket = input.getFileUploadBucket();
            input.setFileUploadBucket(null);
            fileMetaDataRepository.save(input);
            return bucket;
        }).orElse(amazonPropertiesProvider.getActiveBucket());

    }

    private String bucketForFileMetaData(ActiveFileMetaData metaFile) {
        return amazonPropertiesProvider.getActiveBucket();
    }

    private String getObjectBucket(String objectName) {
        return Optional.ofNullable(fileMetaDataRepository.findByDestinationPath(objectName))
            .map(ActiveFileMetaData::getFileUploadBucket)
            .orElse(amazonPropertiesProvider.getActiveBucket());
    }

}
```


Overlapping Code:
```
tSigner")
public class CorsRequestSignerImpl implements CorsRequestSignerTemplate {
private static final Logger LOGGER = LoggerFactory.getLogger(CorsRequestSignerImpl.class);
private static final String PROTOCOL = "https://";
private static final String S3_URL = "s3.amazonaws.com";
private static final String MIME_TYPE = "application/octet-stream";
private static final String AMAZON_UPLOAD_HEADERS = "x-amz-acl:private";
private static final String AMAZON_SSE_HEADERS = "x-amz-server-side-encryption:AES256";
private static final String AMAZON_SECURITY_TOKEN_HEADER = "x-amz-security-token";
private static final String HMAC_SHA1_ALGORITHM = "HmacSHA1";
private static final String UTF_8 = "UTF-8";
private final FileMetaDataRepository fileMetaDataRepository;
private final AWSCredentialsProvider credentialsProvider;
private final AmazonPropertiesProvider amazonPropertiesProvider;
@Inject
public CorsRequestSignerImpl(FileMetaDataRepository fileMetaDataRepository,
CloudStorageClientsProvider cloudStorageClientsProvider,
AmazonPropertiesProvider amazonPropertiesProvider) {
this.fileMetaDataRepository = fileMetaDataRepository;
this.credentialsProvider = cloudStorageClientsProvider.getS3FileOperationHandler().getCredentialsProvider();
this.amazonPropertiesProvider = amazonPropertiesProvider;
}
@Override
public String signSingleFileUploadRequest(long userId, String objectName) {
final String bucket = getBucketForSingleRequest(objectName);
long expireTime = new Date().getTime() / 1000 + (60 * 5); // 2000 minutes from now
objectName = urlencode(objectName);
String stringToSign = "PUT\n\n"
+ MIME_TYPE + "\n"
+ expireTime + "\n"
+ AMAZON_UPLOAD_HEADERS + "\n"
+ (useServerSideEncryption() ? AMAZON_SSE_HEADERS + "\n" : "")
+ (useSessionToken() ? AMAZON_SECURITY_TOKEN_HEADER + ":" + getAmazonToken() + "\n" : "")
+ DELIMITER + bucket + DELIMITER + objectName;
String signature = urlencode(calculateRFC2104HMAC(stringToSign, getAmazonSecret()));
return urlencode(PROTOCOL + bucket + "." + S3_URL + DELIMITER + objectName
+ "?AWSAccessKeyId=" + getAmazonKey() + "&Expires=" +
expireTime + "&
```
<Overlap Ratio: 0.9794776119402985>

---

--- 71 --
Question ID: 0ee7fa3e3954616e13ad663536037c8fc0ebbbad
Original Code:
```
public class DBRunner implements DocumentService{
	//Variables
	private ObjectContainer db = null;
	private List<Shingle> docs = new ArrayList<Shingle>();
	
	//Constructor
	public DBRunner(){
		
		//init(); //Populate the database
		
		EmbeddedConfiguration config = Db4oEmbedded.newConfiguration();
		config.common().add(new TransparentActivationSupport());
		config.common().add(new TransparentPersistenceSupport());
		config.common().updateDepth(7);
		
		//Use the XTea library to add encryption. The basic Db4O container only has a Caesar cypher 
		config.file().storage(new XTeaEncryptionStorage("password", XTEA.ITERATIONS64));
		
		//Open a local database. Use Db4o.openServer(config, server, port) for full client / server
		db = Db4oEmbedded.openFile(config, "docs.data");
		
		compareDoc();
		saveDoc();
		
		
	}
	
	
	private void showAllShingles(){
		//An ObjectSet is a specialised List for storing results
		ObjectSet<Shingle> shingles = db.query(Shingle.class);
		for (Shingle shingle  : shingles){
			//out.print("[Shingle] " + shingle.getShingleStr() + "\t ***Database ObjID: " + db.ext().getID(shingle));
			
			
			db.commit();
		}
	}
	
	
	public static void main(String[] args) {
		new DBRunner();
	}

	@Override
	public void compareDoc() {
		//Jaccard..
		
	}

	@Override
	public void saveDoc() {
		for (Shingle s: docs){
			db.store(s); //Adds Shingle to db
		}
		db.commit(); //Commits the tx
		//db.rollback(); //Rolls back the tx
		
	}
	

}
```


Overlapping Code:
```
ements DocumentService{
//Variables
private ObjectContainer db = null;
private List<Shingle> docs = new ArrayList<Shingle>();

//Constructor
public DBRunner(){

//init(); //Populate the database

EmbeddedConfiguration config = Db4oEmbedded.newConfiguration();
config.common().add(new TransparentActivationSupport());
config.common().add(new TransparentPersistenceSupport());
config.common().updateDepth(7);

//Use the XTea library to add encryption. The basic Db4O container only has a Caesar cypher 
config.file().storage(new XTeaEncryptionStorage("password", XTEA.ITERATIONS64));

//Open a local database. Use Db4o.openServer(config, server, port) for full client / server
db = Db4oEmbedded.openFile(config, "docs.data");

compareDoc();
saveDoc();


}


private void showAllShingles(){
//An ObjectSet is a specialised List for storing results
ObjectSet<Shingle> shingles = db.query(Shingle.class);
for (Shingle shingle : shingles){
//out.print("[Shingle] " + shingle.getShingleStr() + "\t ***Database ObjID: " + db.ext().getID(shingle));


db.commit();
}
}


public static void main(String[] args) {
new DBRunner();
}
@Override
public void compareDoc() {
//Jaccard..

}
@Override
public void saveDoc() {
for (Shingle s: docs){
db.store(s); //Adds Shingle to db
}
db.commit(); //Commits the tx
//db.
```
<Overlap Ratio: 0.9537784299339692>

---

--- 72 --
Question ID: 69714de209eac7d35849ab31462dada94a0867a1
Original Code:
```
public final class MatcherItrator extends AbstractSpliterator<CharSequence>{
	private final Matcher matcher;

	public MatcherItrator(Matcher m){
		super(m.regionEnd() - m.regionStart(), ORDERED|NONNULL);
		matcher = m;
	}
	@Override
	public boolean tryAdvance(Consumer<? super CharSequence> c){
		if (!matcher.find()) return false;
		c.accept(matcher.group());
		return true;
	}
}
```


Overlapping Code:
```
 AbstractSpliterator<CharSequence>{
private final Matcher matcher;
public MatcherItrator(Matcher m){
super(m.regionEnd() - m.regionStart(), ORDERED|NONNULL);
matcher = m;
}
@Override
public boolean tryAdvance(Consumer<? super CharSequence> c){
if (!matcher.find()) return false;
c.accept(matcher.grou
```
<Overlap Ratio: 0.8264462809917356>

---

--- 73 --
Question ID: 0eb3bbf321da36588e118b1a0efebe766f702702
Original Code:
```
class UtilityListWithCriticalObjects extends UtilityList {
	/** This bit vectors stores the list of transaction containing the itemset represented
	 * by this utility-list
	 */
	BitSet tidset = new BitSet(); 
	
	/** This array of bitsets represents the critical objects of the itemsets represented by
	 *  this utility-list (see the DefMe paper for more details about critical objects 
	 */
	BitSet crit[] = null;
	
	/**
	 * Constructor.
	 * @param item the item that is used for this utility list
	 */
	public UtilityListWithCriticalObjects(Integer item){
		super(item);
//		this;
	}
	
	/**
	 * Method to add an element to this utility list and update the sums at the same time.
	 */
	public void addElement(Element element){
		sumIutils += element.iutils;
		sumRutils += element.rutils;
		elements.add(element);
		tidset.set(element.tid);
	}
	
}
```


Overlapping Code:
```
ithCriticalObjects extends UtilityList {
/** This bit vectors stores the list of transaction containing the itemset represented
* by this utility-list
*/
BitSet tidset = new BitSet(); 

/** This array of bitsets represents the critical objects of the itemsets represented by
* this utility-list (see the DefMe paper for more details about critical objects 
*/
BitSet crit[] = null;

/**
* Constructor.
* @param item the item that is used for this utility list
*/
public UtilityListWithCriticalObjects(Integer item){
super(item);
// this;
}

/**
* Method to add an element to this utility list and update the sums at the same time.
*/
public void addElement(Element element){
sumIutils += element.iutils;
sumRutils += element.rutils;
elements.add(elem
```
<Overlap Ratio: 0.933997509339975>

---

--- 74 --
Question ID: f417c149d062210a7bf1d526402038faa1ed3c60
Original Code:
```
public class AbstractITBatchIndexTest extends AbstractIndexerTest
{
  private static final Logger LOG = new Logger(AbstractITBatchIndexTest.class);

  @Inject
  IntegrationTestingConfig config;

  @Inject
  ClientInfoResourceTestClient clientInfoResourceTestClient;

  void doIndexTestTest(
      String dataSource,
      String indexTaskFilePath,
      String queryFilePath
  ) throws IOException
  {
    submitTaskAndWait(indexTaskFilePath, dataSource);
    try {
      queryHelper.testQueriesFromFile(queryFilePath, 2);

    }
    catch (Exception e) {
      LOG.error(e, "Error while testing");
      throw new RuntimeException(e);
    }
  }

  void doReindexTest(
      String reindexDataSource,
      String reindexTaskFilePath,
      String queryFilePath
  ) throws IOException
  {
    submitTaskAndWait(reindexTaskFilePath, reindexDataSource);
    try {
      queryHelper.testQueriesFromFile(queryFilePath, 2);
      // verify excluded dimension is not reIndexed
      final List<String> dimensions = clientInfoResourceTestClient.getDimensions(
          reindexDataSource,
          "2013-08-31T00:00:00.000Z/2013-09-10T00:00:00.000Z"
      );
      Assert.assertFalse("dimensions : " + dimensions, dimensions.contains("robot"));
    }
    catch (Exception e) {
      LOG.error(e, "Error while testing");
      throw new RuntimeException(e);
    }
  }

  private void submitTaskAndWait(String indexTaskFilePath, String dataSourceName) throws IOException
  {
    final String taskID = indexer.submitTask(getTaskAsString(indexTaskFilePath));
    LOG.info("TaskID for loading index task %s", taskID);
    indexer.waitUntilTaskCompletes(taskID);

    RetryUtil.retryUntilTrue(
        () -> coordinator.areSegmentsLoaded(dataSourceName), "Segment Load"
    );
  }
}
```


Overlapping Code:
```
ractITBatchIndexTest extends AbstractIndexerTest
{
private static final Logger LOG = new Logger(AbstractITBatchIndexTest.class);
@Inject
IntegrationTestingConfig config;
@Inject
ClientInfoResourceTestClient clientInfoResourceTestClient;
void doIndexTestTest(
String dataSource,
String indexTaskFilePath,
String queryFilePath
) throws IOException
{
submitTaskAndWait(indexTaskFilePath, dataSource);
try {
queryHelper.testQueriesFromFile(queryFilePath, 2);
}
catch (Exception e) {
LOG.error(e, "Error while testing");
throw new RuntimeException(e);
}
}
void doReindexTest(
String reindexDataSource,
String reindexTaskFilePath,
String queryFilePath
) throws IOException
{
submitTaskAndWait(reindexTaskFilePath, reindexDataSource);
try {
queryHelper.testQueriesFromFile(queryFilePath, 2);
// verify excluded dimension is not reIndexed
final List<String> dimensions = clientInfoResourceTestClient.getDimensions(
reindexDataSource,
"2013-08-31T00:00:00.000Z/2013-09-10T00:00:00.000Z"
);
Assert.assertFalse("dimensions : " + dimensions, dimensions.contains("robot"));
}
catch (Exception e) {
LOG.error(e, "Error while testing");
throw new RuntimeException(e);
}
}
private void submitTaskAndWait(String indexTaskFilePath, String dataSourceName) throws IOException
{
final String taskID = indexer.submitTask(getTaskAsString(indexTaskFilePath));
LOG.info("TaskID for loading index task %s", taskID);
indexer.waitUntilTaskCompletes(taskID);
RetryUtil.retryUntilTrue(
() -> coordinator.areSegmentsLoaded(dataSourceName), "Segmen
```
<Overlap Ratio: 0.9799612152553329>

---

--- 75 --
Question ID: ab7aedff7c7beb20850e83a0cf43078b04a017fd
Original Code:
```
public final class ImmutableMapNonSingletonArrayTest extends ImmutableMapTestCase3<ImmutableMapNonSingletonArray<String, Integer>> {

    @Test
    public void testNotCopied() {
        @SuppressWarnings("unchecked")
        final Entry<String, Integer>[] array = new Entry[2];
        array[0] = Maps.entry(KEY1, VALUE1);
        array[1] = Maps.entry(KEY2, VALUE2);
        final ImmutableMapNonSingletonArray<String, Integer> immutable = ImmutableMapNonSingletonArray.with(array);

        array[1] = Maps.entry(KEY2, 666);

        this.getAndCheck(immutable, KEY1, VALUE1);
        this.getAndCheck(immutable, KEY2, 666);
        this.sizeAndCheck(immutable, 2);
    }

    @Test
    public void testGetNullValue() {
        final ImmutableMapNonSingletonArray<String, Integer> map = this.createMap(KEY1, null, KEY2, VALUE2);
        this.getAndCheck(map, KEY1, null);
        this.getAndCheck(map, KEY2, VALUE2);
    }

    @Override
    ImmutableMapNonSingletonArray<String, Integer> createMap(final String key0,
                                                             final Integer value0,
                                                             final String key1,
                                                             final Integer value1) {
        //noinspection unchecked
        return ImmutableMapNonSingletonArray.with(Maps.entry(key0, value0), Maps.entry(key1, value1));
    }

    @Override
    public Class<ImmutableMapNonSingletonArray<String, Integer>> type() {
        return Cast.to(ImmutableMapNonSingletonArray.class);
    }
}
```


Overlapping Code:
```
ngletonArrayTest extends ImmutableMapTestCase3<ImmutableMapNonSingletonArray<String, Integer>> {
@Test
public void testNotCopied() {
@SuppressWarnings("unchecked")
final Entry<String, Integer>[] array = new Entry[2];
array[0] = Maps.entry(KEY1, VALUE1);
array[1] = Maps.entry(KEY2, VALUE2);
final ImmutableMapNonSingletonArray<String, Integer> immutable = ImmutableMapNonSingletonArray.with(array);
array[1] = Maps.entry(KEY2, 666);
this.getAndCheck(immutable, KEY1, VALUE1);
this.getAndCheck(immutable, KEY2, 666);
this.sizeAndCheck(immutable, 2);
}
@Test
public void testGetNullValue() {
final ImmutableMapNonSingletonArray<String, Integer> map = this.createMap(KEY1, null, KEY2, VALUE2);
this.getAndCheck(map, KEY1, null);
this.getAndCheck(map, KEY2, VALUE2);
}
@Override
ImmutableMapNonSingletonArray<String, Integer> createMap(final String key0,
final Integer value0,
final String key1,
final Integer value1) {
//noinspection unchecked
return ImmutableMapNonSingletonArray.with(Maps.entry(key0, value0), Maps.entry(key1, value1));
}
@Override
public Class<ImmutableMapNonSingletonArray<String, Integer>> type() {
return Cast.to(ImmutableMapNonSi
```
<Overlap Ratio: 0.9504132231404959>

---

--- 76 --
Question ID: cef7ccefd45b7b0a2984b821ad88cb0d91bd9cf0
Original Code:
```
public class MinRemoveValidParan {

    //https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/
    public static void main( String[] args ) {
        String str = "lee(t(c)o)de)";

        System.out.println(minRemoveToMakeValid(str));
    }

    //similar to MinimumAddParnanValid
    //Runtime: 19 ms, faster than 51.31% of Java
    private static String minRemoveToMakeValid( String s ) {
        Stack<Integer> stack = new Stack<>();

        HashSet<Integer> removeIndices = new HashSet<>();

        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(')
                stack.push(i);
            else if (s.charAt(i) == ')') {
                if (!stack.isEmpty())
                    stack.pop();
                else
                    removeIndices.add(i);
            }
        }

        //pop until brackets got balanced
        while (!stack.isEmpty()) {
            removeIndices.add(stack.pop());
        }

        //not appending the indices of brackets which are not balanced..
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (!removeIndices.contains(i))
                sb.append(s.charAt(i));
        }

        return sb.toString();
    }
}
```


Overlapping Code:
```
lass MinRemoveValidParan {
//https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/
public static void main( String[] args ) {
String str = "lee(t(c)o)de)";
System.out.println(minRemoveToMakeValid(str));
}
//similar to MinimumAddParnanValid
//Runtime: 19 ms, faster than 51.31% of Java
private static String minRemoveToMakeValid( String s ) {
Stack<Integer> stack = new Stack<>();
HashSet<Integer> removeIndices = new HashSet<>();
for (int i = 0; i < s.length(); i++) {
if (s.charAt(i) == '(')
stack.push(i);
else if (s.charAt(i) == ')') {
if (!stack.isEmpty())
stack.pop();
else
removeIndices.add(i);
}
}
//pop until brackets got balanced
while (!stack.isEmpty()) {
removeIndices.add(stack.pop());
}
//not appending the indices of brackets which are not balanced..
StringBuilder sb = new StringBuilder();
for (int i = 0; i < s.length(); i++) {
if (!removeIndices.contains(i))
sb.append(s.charAt(i));
}
return sb.toString();
}
}
```
<Overlap Ratio: 0.9916054564533053>

---

--- 77 --
Question ID: bd539f36c9f25f31c634e11d50b7b43ef3305bed
Original Code:
```
@Component
public class DHIS2SyncerListener {
	
	private final ClientService clientService;
	
	@Autowired
	private AllDHIS2Marker allDHIS2Marker;
	
	@Autowired
	private Dhis2TrackCaptureConnector dhis2TrackCaptureConnector;
	
	@Autowired
	private DHIS2TrackerService dhis2TrackerService;
	
	private DHIS2Tracker dhis2Tracker;
	
	@Autowired
	private EventService eventService;
	
	@Autowired
	public VaccinationTracker vaccinationTracker;
	
	@Autowired
	public DHIS2SyncerListener(ClientService clientService) {
		this.clientService = clientService;
	}
	
	public JSONObject pushToDHIS2() {
		JSONObject response = null;
		try {
			Long start = 0l;
			Long eventStart = 0l;
			List<DHIS2Marker> clientSync = allDHIS2Marker.findByName(DHIS2Constants.DHIS2_TRACK_DATA_SYNCER_VERSION_MARKER);
			List<DHIS2Marker> eventSync = allDHIS2Marker
			        .findByName(DHIS2Constants.DHIS2_TRACK_DATA_SYNCER_VERSION_MARKER_EVENT);
			if (clientSync.size() == 0) {
				allDHIS2Marker.add();
				start = 0l;
			} else {
				start = clientSync == null || clientSync.get(0).getValue() == null ? 0 : clientSync.get(0).getValue();
			}
			System.err.println("start:" + start);
			List<Client> cl = clientService.findByServerVersion(start);
			if (eventSync.size() == 0) {
				allDHIS2Marker.addEventMarker();
				eventStart = 0l;
			} else {
				eventStart = eventSync == null || eventSync.get(0).getValue() == null ? 0 : eventSync.get(0).getValue();
			}
			List<Event> events = eventService.findByServerVersion(eventStart);
			for (Client c : cl) {
				System.err.println("Name:" + c.fullName());
				try {
					response = processTrackerAndSendToDHIS2(c);
					allDHIS2Marker.update(c.getServerVersion());
				}
				catch (Exception e) {
					e.printStackTrace();
				}
			}
			
			processAndSendVaccineTrackerToDHIS2(events);
			
		}
		catch (Exception ex) {
			ex.printStackTrace();
		}
		return response;
	}
	
	private JSONObject processAndSendVaccineTrackerToDHIS2(List<Event> events) throws JSONException {
		vaccinationTracker.getTrackCaptureDataAndSend(events);
		return null;
		
	}
	
	private JSONObject processTrackerAndSendToDHIS2(Client client) throws JSONException {
		
		dhis2Tracker = dhis2TrackerService.getTrackerType(client);
		JSONArray clientData = dhis2Tracker.getTrackCaptureData(client);
		return dhis2Tracker.sendTrackCaptureData(clientData);
		
	}
	
	public JSONObject sentTrackCaptureDataToDHIS2(Client client) throws JSONException {
		
		JSONObject clientData = new JSONObject();
		JSONArray clientAttribute = new JSONArray();
		
		JSONObject fullName = new JSONObject();
		fullName.put("attribute", "pzuh7zrs9Xx");
		fullName.put("value", client.fullName());
		clientAttribute.put(fullName);
		
		JSONObject gender = new JSONObject();
		gender.put("attribute", "xDvyz0ezL4e");
		gender.put("value", client.getGender());
		clientAttribute.put(gender);
		if (client.getAttributes().containsKey("Father_NRC_Number")) {
			JSONObject Father_NRC_Number = new JSONObject();
			Father_NRC_Number.put("attribute", "UpMkVyXSk4b");
			Father_NRC_Number.put("value", client.getAttributes().get("Father_NRC_Number"));
			clientAttribute.put(Father_NRC_Number);
		}
		
		if (client.getAttributes().containsKey("Child_Register_Card_Number")) {
			JSONObject Child_Register_Card_Number = new JSONObject();
			Child_Register_Card_Number.put("attribute", "P5Ew7lka7GR");
			Child_Register_Card_Number.put("value", client.getAttributes().get("Child_Register_Card_Number"));
			clientAttribute.put(Child_Register_Card_Number);
		}
		if (client.getAttributes().containsKey("CHW_Phone_Number")) {
			JSONObject CHW_Phone_Number = new JSONObject();
			CHW_Phone_Number.put("attribute", "wCom53wUTKf");
			CHW_Phone_Number.put("value", client.getAttributes().get("CHW_Phone_Number"));
			clientAttribute.put(CHW_Phone_Number);
		}
		
		if (client.getAttributes().containsKey("CHW_Name")) {
			JSONObject CHW_Name = new JSONObject();
			CHW_Name.put("attribute", "t2C80PnQfJH");
			CHW_Name.put("value", client.getAttributes().get("CHW_Name"));
			clientAttribute.put(CHW_Name);
		}
		
		if (client.getAttributes().containsKey("Child_Birth_Certificate")) {
			JSONObject Child_Birth_Certificate = new JSONObject();
			Child_Birth_Certificate.put("attribute", "ZDWzVhjlgWK");
			Child_Birth_Certificate.put("value", client.getAttributes().get("Child_Birth_Certificate"));
			clientAttribute.put(Child_Birth_Certificate);
		}
		
		/////////////////////
		JSONArray enrollments = new JSONArray();
		JSONObject enrollmentsObj = new JSONObject();
		enrollmentsObj.put("orgUnit", "IDc0HEyjhvL");
		enrollmentsObj.put("program", "OprRhyWVIM6");
		enrollmentsObj.put("enrollmentDate", DateUtil.getTodayAsString());
		enrollmentsObj.put("incidentDate", DateUtil.getTodayAsString());
		enrollments.put(enrollmentsObj);
		
		clientData.put("attributes", clientAttribute);
		clientData.put("trackedEntity", "MCPQUTHX1Ze");
		clientData.put("orgUnit", "IDc0HEyjhvL");
		
		return dhis2TrackCaptureConnector.trackCaptureDataSendToDHIS2(clientData);
	}
}
```


Overlapping Code:
```
public class DHIS2SyncerListener {

private final ClientService clientService;

@Autowired
private AllDHIS2Marker allDHIS2Marker;

@Autowired
private Dhis2TrackCaptureConnector dhis2TrackCaptureConnector;

@Autowired
private DHIS2TrackerService dhis2TrackerService;

private DHIS2Tracker dhis2Tracker;

@Autowired
private EventService eventService;

@Autowired
public VaccinationTracker vaccinationTracker;

@Autowired
public DHIS2SyncerListener(ClientService clientService) {
this.clientService = clientService;
}

public JSONObject pushToDHIS2() {
JSONObject response = null;
try {
Long start = 0l;
Long eventStart = 0l;
List<DHIS2Marker> clientSync = allDHIS2Marker.findByName(DHIS2Constants.DHIS2_TRACK_DATA_SYNCER_VERSION_MARKER);
List<DHIS2Marker> eventSync = allDHIS2Marker
.findByName(DHIS2Constants.DHIS2_TRACK_DATA_SYNCER_VERSION_MARKER_EVENT);
if (clientSync.size() == 0) {
allDHIS2Marker.add();
start = 0l;
} else {
start = clientSync == null || clientSync.get(0).getValue() == null ? 0 : clientSync.get(0).getValue();
}
System.err.println("start:" + start);
List<Client> cl = clientService.findByServerVersion(start);
if (eventSync.size() == 0) {
allDHIS2Marker.addEventMarker();
eventStart = 0l;
} else {
eventStart = eventSync == null || eventSync.get(0).getValue() == null ? 0 : eventSync.get(0).getValue();
}
List<Event> events = eventService.findByServerVersion(eventStart);
for (Client c : cl) {
System.err.println("Name:" + c.fullName());
try {
response = processTrackerAndSendToDHIS2(c);
allDHIS2Marker.update(c.getServerVersion());
}
catch (Exception e) {
e.printStackTrace();
}
}

processAndSendVaccineTrackerToDHIS2(events);

}
catch (Exception ex) {
ex.printStackTrace();
}
return response;
}

private JSONObject processAndSendVaccineTrackerToDHIS2(List<Event> events) throws JSONException {
vaccinationTracker.getTrackCaptureDataAndSend(events);
return null;

}

private JSONObject processTrackerAndSendToDHIS2(Client client) throws JSONException {

dhis2Tracker = dhis2TrackerService.getTrackerType(client);
JSONArray clientData = dhis2Tracker.getTrackCaptureData(client);
return dhis2Tracker.sendTrackCaptureData(clientData);

}

public JSONObject sentTrackCaptureDataToDHIS2(Client client) throws JSONException {

JSONObject clientData = new JSONObject();
J
```
<Overlap Ratio: 0.9930495221546481>

---

--- 78 --
Question ID: 4e9c713604e93b2fc61261346cc9243f49640c84
Original Code:
```
public class NameGenerator {
	private static final char[] consos = "bcdfghjklmnprstvwxyz".toCharArray();
	private static final char[] vowels = "aeiou".toCharArray();
	private static final Random r = new Random();
	
	private NameGenerator() {}
	
	public static String getName() {
		StringBuilder name = new StringBuilder();
		for (int i = 0; i < 4; i++) {
			name.append(consos[r.nextInt(consos.length)]);
			name.append(vowels[r.nextInt(vowels.length)]);
		}
		return name.toString();
	}
}
```


Overlapping Code:
```
public class NameGenerator {
private static final char[] consos = "bcdfghjklmnprstvwxyz".toCharArray();
private static final char[] vowels = "aeiou".toCharArray();
private static final Random r = new Random();

private NameGenerator() {}

public static String getName() {
StringBuilder name = new StringBuilder();
for (int i = 0; i < 4; i++) {
name.append(consos[r.nextInt(consos.length)]);
name.append(vowels[r.nextInt(vowels.length)]);
}
return name.to
```
<Overlap Ratio: 0.9721627408993576>

---

--- 79 --
Question ID: ebacb0dc70d2b334e3d50dbd866d04dace8af192
Original Code:
```
public class FluidTools {

    /**
     * Make sure the forge bucket is enabled. If needed to this in your mod constructor:
     * FluidRegistry.enableUniversalBucket();
     * @param fluidStack
     * @return
     */
    @Nonnull
    public static ItemStack convertFluidToBucket(@Nonnull FluidStack fluidStack) {
        //                return FluidContainerRegistry.fillFluidContainer(fluidStack, new ItemStack(Items.BUCKET));
        IFluidHandlerItem fh = FluidUtil.getFluidHandler(new ItemStack(Items.BUCKET));
        fh.fill(fluidStack, true);
        return fh.getContainer();
    }

    public static FluidStack convertBucketToFluid(@Nonnull ItemStack bucket) {
        IFluidHandler fluidHandler = FluidUtil.getFluidHandler(bucket);
        if (fluidHandler == null) {
            return null;
        }
        IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();
        for (IFluidTankProperties properties : tankProperties) {
            FluidStack contents = properties.getContents();
            if (contents != null) {
                return contents;
            }
        }

        return null;
    }


    public static boolean isEmptyContainer(@Nonnull ItemStack itemStack) {
        IFluidHandler fluidHandler = FluidUtil.getFluidHandler(itemStack);
        if (fluidHandler == null) {
            return false;
        }

        IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();
        for (IFluidTankProperties properties : tankProperties) {
            if (properties.canFill() && properties.getCapacity() > 0) {
                FluidStack contents = properties.getContents();
                if (contents == null) {
                    return true;
                } else if (contents.amount > 0) {
                    return false;
                }
            }
        }

        return false;
    }

    public static boolean isFilledContainer(@Nonnull ItemStack itemStack) {
        IFluidHandler fluidHandler = FluidUtil.getFluidHandler(itemStack);
        if (fluidHandler == null) {
            return false;
        }

        IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();
        for (IFluidTankProperties properties : tankProperties) {
            if (!properties.canDrain()) {
                return false;
            }

            FluidStack contents = properties.getContents();
            if (contents == null || contents.amount < properties.getCapacity()) {
                return false;
            }
        }

        return true;
    }

    // Drain a fluid container and return an empty container
    @Nonnull
    public static ItemStack drainContainer(@Nonnull ItemStack container) {
        ItemStack empty = container.copy();
        if (1 <= 0) {
            empty.setCount(0);
        } else {
            empty.setCount(1);
        }
        IFluidHandlerItem fluidHandler = FluidUtil.getFluidHandler(empty);
        if (fluidHandler == null) {
            return ItemStack.EMPTY;
        }
        if (fluidHandler.drain(Integer.MAX_VALUE, true) != null){
            return fluidHandler.getContainer();
        }
        return ItemStack.EMPTY;
    }

    // Fill a container with a fluid and return the filled container
    @Nonnull
    public static ItemStack fillContainer(@Nonnull FluidStack fluidStack, @Nonnull ItemStack itemStack) {
        IFluidHandlerItem fh = FluidUtil.getFluidHandler(itemStack.copy());
        int filled = fh.fill(fluidStack, true);
        if (filled == 0) {
            return ItemStack.EMPTY;
        }
        return fh.getContainer();
    }

    /**
     * Get the capacity (in mb) of the given container for the given fluid
     */
    public static int getCapacity(@Nonnull FluidStack fluidStack, @Nonnull ItemStack itemStack) {
        IFluidHandler fluidHandler = FluidUtil.getFluidHandler(itemStack);
        if (fluidHandler == null) {
            return 0;
        }
        IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();
        for (IFluidTankProperties properties : tankProperties) {
            if (properties.canDrainFluidType(fluidStack)) {
                return properties.getCapacity();
            }
        }
        return 0;
    }

}
```


Overlapping Code:
```
ls {
/**
* Make sure the forge bucket is enabled. If needed to this in your mod constructor:
* FluidRegistry.enableUniversalBucket();
* @param fluidStack
* @return
*/
@Nonnull
public static ItemStack convertFluidToBucket(@Nonnull FluidStack fluidStack) {
// return FluidContainerRegistry.fillFluidContainer(fluidStack, new ItemStack(Items.BUCKET));
IFluidHandlerItem fh = FluidUtil.getFluidHandler(new ItemStack(Items.BUCKET));
fh.fill(fluidStack, true);
return fh.getContainer();
}
public static FluidStack convertBucketToFluid(@Nonnull ItemStack bucket) {
IFluidHandler fluidHandler = FluidUtil.getFluidHandler(bucket);
if (fluidHandler == null) {
return null;
}
IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();
for (IFluidTankProperties properties : tankProperties) {
FluidStack contents = properties.getContents();
if (contents != null) {
return contents;
}
}
return null;
}
public static boolean isEmptyContainer(@Nonnull ItemStack itemStack) {
IFluidHandler fluidHandler = FluidUtil.getFluidHandler(itemStack);
if (fluidHandler == null) {
return false;
}
IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();
for (IFluidTankProperties properties : tankProperties) {
if (properties.canFill() && properties.getCapacity() > 0) {
FluidStack contents = properties.getContents();
if (contents == null) {
return true;
} else if (contents.amount > 0) {
return false;
}
}
}
return false;
}
public static boolean isFilledContainer(@Nonnull ItemStack itemStack) {
IFluidHandler fluidHandler = FluidUtil.getFluidHandler(itemStack);
if (fluidHandler == null) {
return false;
}
IFluidTankProperties[] tankProperties = fluidHandler.getTankProperties();
for (IFluidTankProperties properties : tankProperties) {
if (!properties.canDrain()) {
return false;
}
FluidStack contents = properties.getContents();
if (contents == null || contents.amount < properties.getCapa
```
<Overlap Ratio: 0.9829280910501811>

---

--- 80 --
Question ID: 5e98922bdd63d58191123ae7cb9c99005c2c15d1
Original Code:
```
public class GFSlackDeviceInfoAttachment extends GFSlackAttachment implements Parcelable, Type {

    public static final Creator<GFSlackDeviceInfoAttachment> CREATOR = new Creator<GFSlackDeviceInfoAttachment>() {
        @Override
        public GFSlackDeviceInfoAttachment createFromParcel(Parcel in) {
            return new GFSlackDeviceInfoAttachment(in);
        }

        @Override
        public GFSlackDeviceInfoAttachment[] newArray(int size) {
            return new GFSlackDeviceInfoAttachment[size];
        }
    };

    private String make;
    private String model;
    private String deviceResolution;
    private String deviceDensity;
    private String release;
    private String api;

    public GFSlackDeviceInfoAttachment() {
        super();
        init();
    }

    public GFSlackDeviceInfoAttachment(Builder builder) {
        super(builder);
        init();
        make = builder.make;
        model = builder.model;
        deviceResolution = builder.deviceResolution;
        deviceDensity = builder.deviceDensity;
        release = builder.release;
        api = builder.api;
        setValues();
    }

    protected GFSlackDeviceInfoAttachment(Parcel in) {
        super(in);
        init();
        make = in.readString();
        model = in.readString();
        deviceResolution = in.readString();
        deviceDensity = in.readString();
        release = in.readString();
        api = in.readString();
        setValues();
    }

    private void init() {
        setTitle("Device Info");
        setColor("#03A9F4");
        getFields().get(0).setShort(false);
    }

    public String getMake() {
        return make;
    }

    public void setMake(String make) {
        this.make = make;
        setValues();
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
        setValues();
    }

    public String getDeviceResolution() {
        return deviceResolution;
    }

    public void setDeviceResolution(String deviceResolution) {
        this.deviceResolution = deviceResolution;
        setValues();
    }

    public String getDeviceDensity() {
        return deviceDensity;
    }

    public void setDeviceDensity(String deviceDensity) {
        this.deviceDensity = deviceDensity;
        setValues();
    }

    public String getRelease() {
        return release;
    }

    public void setRelease(String release) {
        this.release = release;
        setValues();
    }

    public String getApi() {
        return api;
    }

    public void setApi(String api) {
        this.api = api;
        setValues();
    }

    private void setValues() {
        GFSlackAttachment.Builder builder = new GFSlackAttachment.Builder();
        StringBuilder sb = new StringBuilder();
        sb.append("Make: ");
        sb.append(make);
        sb.append("\n");
        sb.append("Model: ");
        sb.append(model);
        sb.append("\n");

        sb.append("Resolution: ");
        sb.append(deviceResolution);
        sb.append("\n");
        sb.append("Density: ");
        sb.append(deviceDensity);

        sb.append("\n");
        sb.append("Release: ");
        sb.append(release);
        sb.append("\n");
        sb.append("Api: ");
        sb.append(api);
        setText(sb.toString());
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(make);
        dest.writeString(model);
        dest.writeString(deviceResolution);
        dest.writeString(deviceDensity);
        dest.writeString(release);
        dest.writeString(api);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    public static class SimpleBuilder extends Builder {

        public SimpleBuilder(Context context) {
            this(context.getResources().getDisplayMetrics());
        }

        public SimpleBuilder(Resources resources) {
            this(resources.getDisplayMetrics());
        }

        public SimpleBuilder(DisplayMetrics displayMetrics) {
            setMake(truncateAt(Build.MANUFACTURER, 20));
            setModel(truncateAt(Build.MODEL, 20));

            setDeviceResolution(displayMetrics.heightPixels + "x" + displayMetrics.widthPixels);
            buildDensityString(displayMetrics);

            setRelease(Build.VERSION.RELEASE);
            setApi(String.valueOf(Build.VERSION.SDK_INT));
        }

        @Override
        public SimpleBuilder setFallback(String fallback) {
            super.setFallback(fallback);

            return this;
        }

        @Override
        public SimpleBuilder setColor(String color) {
            super.setColor(color);

            return this;
        }

        @Override
        public SimpleBuilder setTitle(String title) {
            super.setTitle(title);

            return this;
        }

        @Override
        public SimpleBuilder setText(String text) {
            super.setText(text);

            return this;
        }

        @Override
        public SimpleBuilder setExtraTextFields(Map<String, String> extraTextFields) {
            super.setExtraTextFields(extraTextFields);

            return this;
        }

        @Override
        public SimpleBuilder setFooter(String footer) {
            super.setFooter(footer);

            return this;
        }

        @Override
        public SimpleBuilder setFooterIcon(String footerIcon) {
            super.setFooterIcon(footerIcon);

            return this;
        }

        private String truncateAt(String string, int length) {
            return string.length() > length ? string.substring(0, length) : string;
        }

        private void buildDensityString(DisplayMetrics displayMetrics) {
            String density;
            switch (displayMetrics.densityDpi) {
                case DisplayMetrics.DENSITY_260:
                case DisplayMetrics.DENSITY_280:
                case DisplayMetrics.DENSITY_300:
                    density = "hdpi/xhdpi";
                    break;
                case DisplayMetrics.DENSITY_340:
                case DisplayMetrics.DENSITY_360:
                case DisplayMetrics.DENSITY_400:
                case DisplayMetrics.DENSITY_420:
                    density = "xhdpi/xxhdpi";
                    break;
                case DisplayMetrics.DENSITY_560:
                    density = "xxhdpi/xxxhdpi";
                    break;
                case DisplayMetrics.DENSITY_LOW:
                    density = "ldpi";
                    break;
                case DisplayMetrics.DENSITY_MEDIUM:
                    density = "mdpi";
                    break;
                case DisplayMetrics.DENSITY_HIGH:
                    density = "hdpi";
                    break;
                case DisplayMetrics.DENSITY_XHIGH:
                    density = "xhdpi";
                    break;
                case DisplayMetrics.DENSITY_XXHIGH:
                    density = "xxhdpi";
                    break;
                case DisplayMetrics.DENSITY_XXXHIGH:
                    density = "xxxhdpi";
                    break;
                case DisplayMetrics.DENSITY_TV:
                    density = "tvdpi";
                    break;
                default:
                    density = "unknown";
            }

            setDeviceDensity(displayMetrics.densityDpi + "dpi (" + density + ")");
        }
    }

    public static class Builder extends GFSlackAttachment.Builder {

        private String make;
        private String model;
        private String deviceResolution;
        private String deviceDensity;
        private String release;
        private String api;

        public Builder setMake(String make) {
            this.make = make;

            return this;
        }

        public Builder setModel(String model) {
            this.model = model;

            return this;
        }

        public Builder setDeviceResolution(String deviceResolution) {
            this.deviceResolution = deviceResolution;

            return this;
        }

        public Builder setDeviceDensity(String deviceDensity) {
            this.deviceDensity = deviceDensity;

            return this;
        }

        public Builder setRelease(String release) {
            this.release = release;

            return this;
        }

        public Builder setApi(String api) {
            this.api = api;

            return this;
        }

        @Override
        public Builder setFallback(String fallback) {
            super.setFallback(fallback);

            return this;
        }

        @Override
        public Builder setColor(String color) {
            super.setColor(color);

            return this;
        }

        @Override
        public Builder setTitle(String title) {
            super.setTitle(title);

            return this;
        }

        @Override
        public Builder setText(String text) {
            super.setText(text);

            return this;
        }

        @Override
        public Builder setExtraTextFields(Map<String, String> extraTextFields) {
            super.setExtraTextFields(extraTextFields);

            return this;
        }

        @Override
        public Builder setFooter(String footer) {
            super.setFooter(footer);

            return this;
        }

        @Override
        public Builder setFooterIcon(String footerIcon) {
            super.setFooterIcon(footerIcon);

            return this;
        }

        @Override
        public GFSlackDeviceInfoAttachment build() {
            return new GFSlackDeviceInfoAttachment(this);
        }
    }
}
```


Overlapping Code:
```
ttachment extends GFSlackAttachment implements Parcelable, Type {
public static final Creator<GFSlackDeviceInfoAttachment> CREATOR = new Creator<GFSlackDeviceInfoAttachment>() {
@Override
public GFSlackDeviceInfoAttachment createFromParcel(Parcel in) {
return new GFSlackDeviceInfoAttachment(in);
}
@Override
public GFSlackDeviceInfoAttachment[] newArray(int size) {
return new GFSlackDeviceInfoAttachment[size];
}
};
private String make;
private String model;
private String deviceResolution;
private String deviceDensity;
private String release;
private String api;
public GFSlackDeviceInfoAttachment() {
super();
init();
}
public GFSlackDeviceInfoAttachment(Builder builder) {
super(builder);
init();
make = builder.make;
model = builder.model;
deviceResolution = builder.deviceResolution;
deviceDensity = builder.deviceDensity;
release = builder.release;
api = builder.api;
setValues();
}
protected GFSlackDeviceInfoAttachment(Parcel in) {
super(in);
init();
make = in.readString();
model = in.readString();
deviceResolution = in.readString();
deviceDensity = in.readString();
release = in.readString();
api = in.readString();
setValues();
}
private void init() {
setTitle("Device Info");
setColor("#03A9F4");
getFields().get(0).setShort(false);
}
public String getMake() {
return make;
}
public void setMake(String make) {
this.make = make;
setValues();
}
public String getModel() {
return model;
}
public void setModel(String model) {
this.model = model;
setValues();
}
public String getDeviceResolution() {
return deviceResolution;
}
public void setDeviceResolution(String deviceResolution) {
this.deviceResolution = deviceResolution;
setValues();
}
public String getDeviceDensity() {
return deviceDensity;
}
public void setDeviceDensity(String deviceDensity) {
this.deviceDensity = deviceDensity;
setValues();
}
public String getRelease() {
return release;
}
public void setRelease(String release) {
this.release = release;

```
<Overlap Ratio: 0.982706002034588>

---

--- 81 --
Question ID: 6223017e14845bf3bba283627af015ff2c4ab3a4
Original Code:
```
@SuppressWarnings("StringConcatenationInLoop")
public class L0068 {

//    private final int maxWidth = 16;
//    private final String[] words = new String[] {"This", "is", "an", "example", "of", "text", "justification."};

    private final int maxWidth = 16;
    private final String[] words = new String[] {"What","must","be","acknowledgment","shall","be"};

//    private final int maxWidth = 20;
//    private final String[] words = new String[] {"Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"};

    public void run() {
        List<String> result = fullJustify(words, maxWidth);
        for(String s: result) {
            System.out.println("\"" + s + "\"");
        }
    }

    public List<String> fullJustify(String[] words, int maxWidth) {
        List<String> result = new ArrayList<>();
        List<String> crtLine = new ArrayList<>();
        int crtLL = 0;
        for(int i = 0; i < words.length; i ++) {
            int candLL = crtLL + words[i].length() + (crtLL == 0 ? 0 : 1);
            if (candLL <= maxWidth) {
                crtLine.add(words[i]);
                crtLL = candLL;
                if (i == words.length - 1) {
                    result.add(commit(crtLine, crtLL, true));
                }
            }
            else {
                // we know that crtLine.length <= maxWidth from
                // the previous iteration
                result.add(commit(crtLine, crtLL, false));
                crtLL = 0;
                crtLine = new ArrayList<>();
                i--;
            }
        }
        return result;
    }

    /**
     * We get a list of words for which the total length + inter-word spacing
     * is <= maxWidth
     **/
    private String commit(List<String> crtLine, int lengthInclInterWordSpacing,
                          boolean finalLine) {
        int extraPadding = maxWidth - lengthInclInterWordSpacing;
        String s = "";
        if (finalLine || crtLine.size() == 1) {
            for(int i = 0; i < crtLine.size(); i ++) {
                s += (i > 0 ? " ": "") + crtLine.get(i);
            }
            for(int i = 0; i < extraPadding; i ++) {
                s += " ";
            }
            return s;
        }
        int eppg = extraPadding / (crtLine.size() - 1);
        // extra spaces to distribute to left gaps (may be 0)
        int eslg = extraPadding - eppg * (crtLine.size() - 1);
        for(int i = 0; i < crtLine.size(); i ++) {
            s +=
                    (i == 0 ? "": " " + spaces(eppg) + (eslg-- > 0 ? " " : "")) +
                            crtLine.get(i);
        }
        return s;
    }

    private String spaces(int count) {
        String s = "";
        for(int i = 0; i < count; i ++) {
            s += " ";
        }
        return s;
    }

}
```


Overlapping Code:
```
SuppressWarnings("StringConcatenationInLoop")
public class L0068 {
// private final int maxWidth = 16;
// private final String[] words = new String[] {"This", "is", "an", "example", "of", "text", "justification."};
private final int maxWidth = 16;
private final String[] words = new String[] {"What","must","be","acknowledgment","shall","be"};
// private final int maxWidth = 20;
// private final String[] words = new String[] {"Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"};
public void run() {
List<String> result = fullJustify(words, maxWidth);
for(String s: result) {
System.out.println("\"" + s + "\"");
}
}
public List<String> fullJustify(String[] words, int maxWidth) {
List<String> result = new ArrayList<>();
List<String> crtLine = new ArrayList<>();
int crtLL = 0;
for(int i = 0; i < words.length; i ++) {
int candLL = crtLL + words[i].length() + (crtLL == 0 ? 0 : 1);
if (candLL <= maxWidth) {
crtLine.add(words[i]);
crtLL = candLL;
if (i == words.length - 1) {
result.add(commit(crtLine, crtLL, true));
}
}
else {
// we know that crtLine.length <= maxWidth from
// the previous iteration
result.add(commit(crtLine, crtLL, false));
crtLL = 0;
crtLine = new ArrayList<>();
i--;
}
}
return result;
}
/**
* We get a list of words for which the total length + inter-word spacing
* is <= maxWidth
**/
private String commit(List<String> crtLine, int lengthInclInterWordSpacing,
boolean finalLine) {
int extraPadding = maxWidth - lengthInclInterWordSpacing;
String s = "";
if (finalLine || crtLine.size() == 1) {
for(int i = 0; i < crtLine.size(); i ++) {
s += (i > 0 ? " ": "") + crtLine.get(i);
}
for(int i = 0; i < extraPadding; i ++) {
s += " ";
}
return s;
}
int eppg = extraPadding / (crtLine.size() - 1);
// extra spaces to distribute to left gaps (may be 0)
int eslg = extraPadding - eppg * (crtLine.size() - 1);
for(int i = 
```
<Overlap Ratio: 0.9984431759211209>

---

--- 82 --
Question ID: 1a056898b8f77c85a861111da2ff9e3a2b25e035
Original Code:
```
@ApiModel(value = "Collection Set Response")
public class CollectionResponse implements Comparable<CollectionResponse> {

    @ApiModelProperty(value = "Name of the collection")
    private String collectionName;

    @ApiModelProperty(value = "Array of Canned Sets", dataType = "CannedSetResponse[]")
    private CannedSetResponse[] cannedSets;


    public CollectionResponse() {

    }

    public CollectionResponse(
            @JsonProperty("collectionName") String collectionName,
            @JsonProperty("cannedSets") CannedSetResponse[] cannedSets

    ) {
        this.collectionName = collectionName;
        this.cannedSets = cannedSets;
    }

    public String getCollectionName() {
        return collectionName;
    }

    public void setCollectionName(String collectionName) {
        this.collectionName = collectionName;
    }

    public CannedSetResponse[] getCannedSets() {
        return cannedSets;
    }

    public void setCannedSets(CannedSetResponse[] cannedSets) {
        this.cannedSets = cannedSets;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass())
            return false;

        CollectionResponse that = (CollectionResponse) o;

        if (!Arrays.equals(cannedSets, that.cannedSets))
            return false;
        if (!collectionName.equals(that.collectionName))
            return false;

        return true;
    }

    @Override
    public int hashCode() {
        int result = collectionName.hashCode();
        result = 31 * result + Arrays.hashCode(cannedSets);
        return result;
    }

    @Override
    public int compareTo(CollectionResponse o) {
        return collectionName.compareTo(o.collectionName);
    }
}
```


Overlapping Code:
```
 = "Collection Set Response")
public class CollectionResponse implements Comparable<CollectionResponse> {
@ApiModelProperty(value = "Name of the collection")
private String collectionName;
@ApiModelProperty(value = "Array of Canned Sets", dataType = "CannedSetResponse[]")
private CannedSetResponse[] cannedSets;
public CollectionResponse() {
}
public CollectionResponse(
@JsonProperty("collectionName") String collectionName,
@JsonProperty("cannedSets") CannedSetResponse[] cannedSets
) {
this.collectionName = collectionName;
this.cannedSets = cannedSets;
}
public String getCollectionName() {
return collectionName;
}
public void setCollectionName(String collectionName) {
this.collectionName = collectionName;
}
public CannedSetResponse[] getCannedSets() {
return cannedSets;
}
public void setCannedSets(CannedSetResponse[] cannedSets) {
this.cannedSets = cannedSets;
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass())
return false;
CollectionResponse that = (CollectionResponse) o;
if (!Arrays.equals(cannedSets, that.cannedSets))
return false;
if (!collectionName.equals(that.collectionName))
return false;
return true;
}
@Override
public int hashCode() {
int result = collectionName.hashCode();
result = 31 * result + Arrays.hashCode(cannedSets);
return result;
}
@Override
public int compareTo(CollectionResponse o) {
return
```
<Overlap Ratio: 0.9569377990430622>

---

--- 83 --
Question ID: 1e5133262aa9bb128f3b72d2202e00490c274b3b
Original Code:
```
public class NimbusProvider {

  public static void main(String[] args) {
    String token = null;
    try {
      token = new NimbusProvider().create();
      System.out.println("Token: " + token);
    } catch (JOSEException e) {
      throw new RuntimeException(e);
    }
  }

  public String create() throws JOSEException {

// Create RSA-signer with the private key
    JWSSigner signer = new RSASSASigner(Alice.getPrivateKey());

// Prepare JWT with claims set
    JWTClaimsSet claimsSet = new JWTClaimsSet.Builder()
            .subject("alice")
            .issueTime(new Date())
            .issuer("http://example.com")
            .build();

    String keyId = "id-0815";
    JWSHeader header = new JWSHeader(JWSAlgorithm.RS256, null, null, null, null, null, null, null, null, null, keyId, null, null);
    SignedJWT signedJWT = new SignedJWT(header, claimsSet);

    signedJWT.sign(signer);

    return signedJWT.serialize();
  }

}
```


Overlapping Code:
```
Provider {
public static void main(String[] args) {
String token = null;
try {
token = new NimbusProvider().create();
System.out.println("Token: " + token);
} catch (JOSEException e) {
throw new RuntimeException(e);
}
}
public String create() throws JOSEException {
// Create RSA-signer with the private key
JWSSigner signer = new RSASSASigner(Alice.getPrivateKey());
// Prepare JWT with claims set
JWTClaimsSet claimsSet = new JWTClaimsSet.Builder()
.subject("alice")
.issueTime(new Date())
.issuer("http://example.com")
.build();
String keyId = "id-0815";
JWSHeader header = new JWSHeader(JWSAlgorithm.RS256, null, null, null, null, null, null, null, null, null, keyId, null, null);
SignedJWT signedJWT = new SignedJWT(header, claimsSet);
signedJWT.sign(signer);
return signedJWT.serialize();
}
}
```
<Overlap Ratio: 0.9767441860465116>

---

--- 84 --
Question ID: dafcd543bd4fb8b3fd0e787bdf02e5a3dda45bd8
Original Code:
```
public class DepartureWidgetProvider extends AppWidgetProvider {

    public static final String EXTRA_STOP_SHORT_NAME = "extra_stop_short_name";
    public static final String ACTION_OPEN_FAVORITE = "action_open_favorite";
    public static final String EXTRA_STOP_NAME = "extra_stop_name";

    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
        final int N = appWidgetIds.length;

        // Perform this loop procedure for each App Widget that belongs to this provider
        for (int i = 0; i < N; i++) {
            final int appWidgetId = appWidgetIds[i];

            // Create an Intent to launch ExampleActivity
            final Intent remoteViewService = new Intent(context, DepartureWidgetRemoteViewService.class);
            // Add the app widget ID to the intent extras.

            // Get the layout for the App Widget and attach an on-click listener
            // to the button
            RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.widget_departure);

            views.setRemoteAdapter(R.id.listView, remoteViewService);

            // The empty view is displayed when the collection has no items.
            // It should be in the same layout used to instantiate the RemoteViews
            // object above.
            views.setEmptyView(R.id.listView, R.id.emptyView);
            // Tell the AppWidgetManager to perform an update on the current app widget
            final Intent stopIntent = new Intent(context, StationDetailActivity.class);// StationDetailActivity.createIntent(context);
            stopIntent.setAction(ACTION_OPEN_FAVORITE);
            stopIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);
            stopIntent.setData(Uri.parse(stopIntent.toUri(Intent.URI_INTENT_SCHEME)));
            Timber.d("uri: %s", Uri.parse(stopIntent.toUri(Intent.URI_INTENT_SCHEME)).toString());
            PendingIntent stopPendingIntent = PendingIntent.getActivity(context,
                    appWidgetId,
                    stopIntent,
                    PendingIntent.FLAG_CANCEL_CURRENT);
            views.setPendingIntentTemplate(R.id.listView, stopPendingIntent);
            appWidgetManager.updateAppWidget(appWidgetId, views);
        }
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        Timber.d("recieved");
        AppWidgetManager mgr = AppWidgetManager.getInstance(context);
        if (intent.getAction().equals(ACTION_OPEN_FAVORITE)) {
            int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,
                    AppWidgetManager.INVALID_APPWIDGET_ID);
            final String shortName = intent.getStringExtra(EXTRA_STOP_SHORT_NAME);
            final String name = intent.getStringExtra(EXTRA_STOP_NAME);
            final Intent stationDetailIntent = StationDetailActivity.createIntent(context, shortName);
            context.startActivity(stationDetailIntent);
            //Toast.makeText(context, "Touched view " + shortName, Toast.LENGTH_SHORT).show();
        }
        super.onReceive(context, intent);
    }
}
```


Overlapping Code:
```
eWidgetProvider extends AppWidgetProvider {
public static final String EXTRA_STOP_SHORT_NAME = "extra_stop_short_name";
public static final String ACTION_OPEN_FAVORITE = "action_open_favorite";
public static final String EXTRA_STOP_NAME = "extra_stop_name";
public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
final int N = appWidgetIds.length;
// Perform this loop procedure for each App Widget that belongs to this provider
for (int i = 0; i < N; i++) {
final int appWidgetId = appWidgetIds[i];
// Create an Intent to launch ExampleActivity
final Intent remoteViewService = new Intent(context, DepartureWidgetRemoteViewService.class);
// Add the app widget ID to the intent extras.
// Get the layout for the App Widget and attach an on-click listener
// to the button
RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.widget_departure);
views.setRemoteAdapter(R.id.listView, remoteViewService);
// The empty view is displayed when the collection has no items.
// It should be in the same layout used to instantiate the RemoteViews
// object above.
views.setEmptyView(R.id.listView, R.id.emptyView);
// Tell the AppWidgetManager to perform an update on the current app widget
final Intent stopIntent = new Intent(context, StationDetailActivity.class);// StationDetailActivity.createIntent(context);
stopIntent.setAction(ACTION_OPEN_FAVORITE);
stopIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetIds[i]);
stopIntent.setData(Uri.parse(stopIntent.toUri(Intent.URI_INTENT_SCHEME)));
Timber.d("uri: %s", Uri.parse(stopIntent.toUri(Intent.URI_INTENT_SCHEME)).toString());
PendingIntent stopPendingIntent = PendingIntent.getActivity(context,
appWidgetId,
stopIntent,
PendingIntent.FLAG_CANCEL_CURRENT);
views.setPendingIntentTemplate(R.id.listView, stopPendingIntent);
appWidgetManager.updateAppWidget(appWidgetId, views);
}
}
@Override
public void onReceive(Context context, Intent intent) {
Timber.d("recieved");
AppWidgetManager mgr = AppWidgetManager.getInstance(context);
if (intent.getAction().e
```
<Overlap Ratio: 0.9894988066825776>

---

--- 85 --
Question ID: 93326e75e3397b8a07e7421f3c95872f50434f89
Original Code:
```
public class DateUtil {

    public DateUtil() {
        super();
    }

    public static boolean checkIfPeriodIsValid(String startDate, String endDate) {
        int[] startPeriod = Arrays.stream(startDate.split("-")).mapToInt(Integer::parseInt).toArray();
        int[] endPeriod = Arrays.stream(endDate.split("-")).mapToInt(Integer::parseInt).toArray();

        // CHECK IF THE DATE IS BEFORE THE CURRENT DATE
        int[] todaySplit = Arrays.stream(getCurrentDateAsString().split("-"))
                .mapToInt(Integer::parseInt)
                .toArray();

        if (todaySplit[0] > startPeriod[0] || todaySplit[1] > startPeriod[1] || todaySplit[2] > startPeriod[2]) {
            throw new ApplicationRuntimeException("You cannot choose start date earlier than today!");
        }

        // CHECK IF THE END DATE IS BEFORE THE START DATE
        if (startPeriod[0] > endPeriod[0] || startPeriod[1] > endPeriod[1] || startPeriod[2] > endPeriod[2]) {
            throw new ApplicationRuntimeException("Start date must be before End date!");
        }

        return true;
    }

    public static String getTimeLapseOfSession(String startHour, String endHour) {
        //da predpolojim che podava startHour vuv format hh:MM
        String[] startHourTokens = startHour.split(":");
        String[] endHourTokens = endHour.split(":");

        TimeDiffUtil start = new TimeDiffUtil(Integer.parseInt(startHourTokens[0]), Integer.parseInt(startHourTokens[1]), 00);
        TimeDiffUtil end = new TimeDiffUtil(Integer.parseInt(endHourTokens[0]), Integer.parseInt(endHourTokens[1]), 00);

        TimeDiffUtil diff = TimeDiffUtil.difference(start, end);

        return diff.getHours() + ":" + diff.getMinutes();

    }

    public static int comparatorByStringDates(String dateOne, String dateTwo) {
        Comparator<String> comparator = (x, y) -> {
            int[] xColect = Arrays.stream(x.split("-"))
                    .mapToInt(Integer::parseInt)
                    .toArray();

            int[] yCollect = Arrays.stream(y.split("-"))
                    .mapToInt(Integer::parseInt)
                    .toArray();

            int year1 = xColect[0];
            int month1 = xColect[1];
            int day1 = xColect[2];

            int year2 = yCollect[0];
            int month2 = yCollect[1];
            int day2 = yCollect[2];


            if (year1 - year2 != 0) {
                return year1 - year2;
            }

            if (month1 - month2 != 0) {
                return month1 - month2;
            }

            if (day1 - day2 != 0) {
                return day1 - day2;
            }

            return 0;
        };

        return comparator.compare(dateOne, dateTwo);
    }

    public static String getCurrentDateAsString() {
        return LocalDate.now().toString();
    }

    public static String getCurrentTimeAsString() {
        String[] runtime = LocalDateTime.now().toString().split(":");
        return runtime[0].substring(runtime[0].length() - 2) + ":" + runtime[1];
    }


}
```


Overlapping Code:
```
blic class DateUtil {
public DateUtil() {
super();
}
public static boolean checkIfPeriodIsValid(String startDate, String endDate) {
int[] startPeriod = Arrays.stream(startDate.split("-")).mapToInt(Integer::parseInt).toArray();
int[] endPeriod = Arrays.stream(endDate.split("-")).mapToInt(Integer::parseInt).toArray();
// CHECK IF THE DATE IS BEFORE THE CURRENT DATE
int[] todaySplit = Arrays.stream(getCurrentDateAsString().split("-"))
.mapToInt(Integer::parseInt)
.toArray();
if (todaySplit[0] > startPeriod[0] || todaySplit[1] > startPeriod[1] || todaySplit[2] > startPeriod[2]) {
throw new ApplicationRuntimeException("You cannot choose start date earlier than today!");
}
// CHECK IF THE END DATE IS BEFORE THE START DATE
if (startPeriod[0] > endPeriod[0] || startPeriod[1] > endPeriod[1] || startPeriod[2] > endPeriod[2]) {
throw new ApplicationRuntimeException("Start date must be before End date!");
}
return true;
}
public static String getTimeLapseOfSession(String startHour, String endHour) {
//da predpolojim che podava startHour vuv format hh:MM
String[] startHourTokens = startHour.split(":");
String[] endHourTokens = endHour.split(":");
TimeDiffUtil start = new TimeDiffUtil(Integer.parseInt(startHourTokens[0]), Integer.parseInt(startHourTokens[1]), 00);
TimeDiffUtil end = new TimeDiffUtil(Integer.parseInt(endHourTokens[0]), Integer.parseInt(endHourTokens[1]), 00);
TimeDiffUtil diff = TimeDiffUtil.difference(start, end);
return diff.getHours() + ":" + diff.getMinutes();
}
public static int comparatorByStringDates(String dateOne, String dateTwo) {
Comparator<String> comparator = (x, y) -> {
int[] xColect = Arrays.stream(x.split("-"))
.mapToInt(Integer::parseInt)
.toArray();
int[] yCollect = Arrays.stream(y.split("-"))
.mapToInt(Integer::parseInt)
.toArray();
int year1 = xColect[0];
int month1 = xColect[1];
int day1 = xColect[2];
int year2 = yCollect[0];
int month2 = yCollect[1];
int day2 = yCollect[2];
if (year1 - year2 != 0) {
return year1 - year2;
}
if (month1 - month2
```
<Overlap Ratio: 0.9950248756218906>

---

--- 86 --
Question ID: 6f1ff3bf54598e2af3ea2c0f266b628bba02a812
Original Code:
```
@Slf4j
public class SearchEndpoint extends AbstractTwitchEndpoint {

	/**
	 * Search Endpoint
	 *
	 * @param client The Twitch Client.
	 */
	public SearchEndpoint(TwitchClient client) {
		super(client, client.getRestClient().getRestTemplate());
	}

	/**
	 * Endpoint: Search Channels
	 * Searches for channels based on a specified query parameter. A channel is returned if the query parameter is matched entirely or partially, in the channel description or game name.
	 * Requires Scope: none
	 *
	 * @param query search query
	 * @param limit Maximum number of most-recent objects to return. Default: 25. Maximum: 100.
	 * @return A list of Channels matching the query.
	 */
	public List<Channel> getChannels(String query, @Nullable Integer limit) {
		// Endpoint
		RestTemplate restTemplate = this.restTemplate;

		// Parameters
		if (limit != null) {
			restTemplate.getInterceptors().add(new QueryRequestInterceptor("limit", Integer.toString((limit > 100) ? 100 : (limit < 1) ? 25 : limit)));
		}
		restTemplate.getInterceptors().add(new QueryRequestInterceptor("query", URLEncoder.encode(query)));

		// REST Request
		try {
			return restTemplate.getForObject("/search/channels", ChannelList.class).getChannels();
		} catch (Exception ex) {
			log.error("Request failed: " + ex.getMessage());
			log.trace(ExceptionUtils.getStackTrace(ex));

			return Collections.emptyList();
		}
	}

	/**
	 * Endpoint: Search Games
	 * Searches for games based on a specified query parameter. A game is returned if the query parameter is matched entirely or partially, in the game name.
	 * Requires Scope: none
	 *
	 * @param query search query
	 * @param live  Whether only games that are live should be returned. This argument is optional.
	 * @return A list of games matching the query.
	 */
	public List<Game> getGames(String query, @Nullable Boolean live) {
		// Endpoint
		RestTemplate restTemplate = this.restTemplate;

		// Parameters
		restTemplate.getInterceptors().add(new QueryRequestInterceptor("query", query));
		if (live != null && live) {
			restTemplate.getInterceptors().add(new QueryRequestInterceptor("live", live.toString()));
		}

		// REST Request
		try {
			return restTemplate.getForObject("/search/games", GameList.class).getGames();
		} catch (Exception ex) {
			log.error("Request failed: " + ex.getMessage());
			log.trace(ExceptionUtils.getStackTrace(ex));

			return Collections.emptyList();
		}
	}

	/**
	 * Endpoint: Search Streams
	 * Searches for streams based on a specified query parameter. A stream is returned if the query parameter is matched entirely or partially, in the channel description or game name.
	 * Requires Scope: none
	 *
	 * @param query search query
	 * @param limit Maximum number of most-recent objects to return. Default: 25. Maximum: 100.
	 * @return A list of Streams matching the query.
	 */
	public List<Stream> getStreams(String query, @Nullable Integer limit) {
		// Endpoint
		RestTemplate restTemplate = this.restTemplate;

		// Parameters
		if (limit != null) {
			restTemplate.getInterceptors().add(new QueryRequestInterceptor("limit", Integer.toString((limit > 100) ? 100 : (limit < 1) ? 25 : limit)));
		}
		restTemplate.getInterceptors().add(new QueryRequestInterceptor("query", query));

		// REST Request
		try {
			return restTemplate.getForObject("/search/streams", StreamList.class).getStreams();
		} catch (Exception ex) {
			log.error("Request failed: " + ex.getMessage());
			log.trace(ExceptionUtils.getStackTrace(ex));

			return Collections.emptyList();
		}
	}
}
```


Overlapping Code:
```
c class SearchEndpoint extends AbstractTwitchEndpoint {
/**
* Search Endpoint
*
* @param client The Twitch Client.
*/
public SearchEndpoint(TwitchClient client) {
super(client, client.getRestClient().getRestTemplate());
}
/**
* Endpoint: Search Channels
* Searches for channels based on a specified query parameter. A channel is returned if the query parameter is matched entirely or partially, in the channel description or game name.
* Requires Scope: none
*
* @param query search query
* @param limit Maximum number of most-recent objects to return. Default: 25. Maximum: 100.
* @return A list of Channels matching the query.
*/
public List<Channel> getChannels(String query, @Nullable Integer limit) {
// Endpoint
RestTemplate restTemplate = this.restTemplate;
// Parameters
if (limit != null) {
restTemplate.getInterceptors().add(new QueryRequestInterceptor("limit", Integer.toString((limit > 100) ? 100 : (limit < 1) ? 25 : limit)));
}
restTemplate.getInterceptors().add(new QueryRequestInterceptor("query", URLEncoder.encode(query)));
// REST Request
try {
return restTemplate.getForObject("/search/channels", ChannelList.class).getChannels();
} catch (Exception ex) {
log.error("Request failed: " + ex.getMessage());
log.trace(ExceptionUtils.getStackTrace(ex));
return Collections.emptyList();
}
}
/**
* Endpoint: Search Games
* Searches for games based on a specified query parameter. A game is returned if the query parameter is matched entirely or partially, in the game name.
* Requires Scope: none
*
* @param query search query
* @param live Whether only games that are live should be returned. This argument is optional.
* @return A list of games matching the query.
*/
public List<Game> getGames(String query, @Nullable Boolean live) {
// Endpoint
RestTemplate restTemplate = this.restTemplate;
// Parameters
restTemplate.getInterceptors().add(new QueryRequestInterceptor("query", query));
if (live != null && live) {
restTemplate.getInterceptors().add(new QueryRequestInterceptor("live", live.toString()));
}
// REST Request
try {
return restTemplate.getForObject("/search/games", GameList.class).getGames();
} catch (Exception ex) {
log.error("Request failed: " + ex.getMessage());
log.trace(ExceptionUtils.getStackTrace(ex));
return Collections.emptyList();
}
}
/**
* Endpoint: Search Streams
* Searches for streams
```
<Overlap Ratio: 0.9877222692633362>

---

--- 87 --
Question ID: 92f5d7a974ce235cdfc003cc5f14c0011067d607
Original Code:
```
public class StopWatchActivity extends AppCompatActivity implements
        StopWatchActionsFragment.StopWatchActions,
        StopWatch.StopWatchTickEvents {

    private ActivityStopwatchBinding mBinding = null;
    private StopWatch mStopWatch = null;
    private List<Long> mLaps = null;
    private List<TimedActivity> mTimedActivities = new ArrayList<>();

    private void createLap() {
        LapTimesFragment lapTimesFragment = (LapTimesFragment) getSupportFragmentManager()
                .findFragmentById(mBinding.rlLapTimes.getId());

        // Add a new lap that starts at 0 to the list of laps.
        mLaps.add(0, 0L);

        if (lapTimesFragment != null) {
            if (!mLaps.isEmpty()) {
                lapTimesFragment.newLapTime(StopWatch.buildTimeStamp(mLaps.get(0)));
            }
        }
        else {
            throw new java.lang.UnsupportedOperationException(
                    "The lap time fragment does not exist and recieved a create lap event."
            );
        }
    }

    private void initializeFragments(long baseTime, List<String> times) {
        // Inform the fragments to update their times.
        ElapsedTimeFragment elapsedTimeFragment = (ElapsedTimeFragment) getSupportFragmentManager()
                .findFragmentById(mBinding.rlElapsedTime.getId());

        LapTimesFragment lapTimesFragment = (LapTimesFragment) getSupportFragmentManager()
                .findFragmentById(mBinding.rlLapTimes.getId());

        if (elapsedTimeFragment != null) {
            elapsedTimeFragment.updateElapsedTime(StopWatch.buildTimeStamp(baseTime));
        }
        else {
            throw new java.lang.UnsupportedOperationException(
                    "The elapsed time fragment does not exist and trying to initialize."
            );
        }

        if (lapTimesFragment != null) {
            lapTimesFragment.initializeLaps(times);
        }
        else {
            throw new java.lang.UnsupportedOperationException(
                    "The lap time fragment does not exist and trying to initialize."
            );
        }
    }

    private void saveAndReturn() {
        Bundle bundle = new Bundle();
        long [] lapsToSave = new long [mLaps.size()];
        long prevLap = 0L;
        long totalTime = 0L;

        // populate the array that will be passed back as a bundle.
        for (int index = lapsToSave.length - 1; index >= 0; index--) {
            lapsToSave[index] = mLaps.get(index) - prevLap;
            prevLap = mLaps.get(index);
        }

        if (mLaps.size() > 0) {
            totalTime = mLaps.get(0);
        }

        bundle.putLong(getString(R.string.key_total_time), totalTime);
        bundle.putLongArray(getString(R.string.key_lap_times), lapsToSave);
        bundle.putParcelableArrayList(
                getString(R.string.key_timed_activities),
                (ArrayList<TimedActivity>) mTimedActivities);

        Intent intent = new Intent();
        intent.putExtras(bundle);
        setResult(RESULT_OK, intent);
        finish();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        super.onOptionsItemSelected(item);

        if (item != null) {
            switch (item.getItemId()) {
                case R.id.mi_save:
                    mStopWatch.pause();
                    saveAndReturn();
                    break;
            }
        }

        return true;
    }

    @Override
    protected void onPause() {
        super.onPause();
        if (mStopWatch != null) {
            mStopWatch.unRegisterCallback();
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (mStopWatch != null) {
            mStopWatch.registerCallback(this);
        }
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        long [] times = new long [mLaps.size()];

        int index = 0;
        for (long time : mLaps) {
            times[index] = time;
            index++;
        }

        if (mStopWatch != null) {
            outState.putInt(
                    getString(R.string.key_stopwatch_state),
                    mStopWatch.getState().getStateValue());
            outState.putLongArray(getString(R.string.key_lap_times), times);
        }

        outState.putParcelableArrayList(
                getString(R.string.key_timed_activities),
                (ArrayList<TimedActivity>) mTimedActivities);
    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);
        getWindow().setEnterTransition(new Slide());
        getWindow().setExitTransition(new Slide());

        mBinding = DataBindingUtil.setContentView(this, R.layout.activity_stopwatch);
        setSupportActionBar(mBinding.tbActivityStopwatchToolbar);
        if (getSupportActionBar() != null) {
            getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        }

        long baseTime = 0L;
        List<String> timeStrings = new LinkedList<String>();
        int stopWatchState = StopWatch.sSTOP_STATE_VALUE;

        // Create the list of laps.
        mLaps = new LinkedList<Long>();

        if (savedInstanceState != null && !savedInstanceState.isEmpty()) {
            // Obtain instance state data
            long [] times = savedInstanceState.getLongArray(getString(R.string.key_lap_times));

            if (times != null && times.length > 0) {
                baseTime = times[0];
                for (long time : times) {
                    mLaps.add(time);
                    timeStrings.add(StopWatch.buildTimeStamp(time));
                    // Log.d("onCreate", "time found is " + Long.toString(time));
                }

                // need to account for the first lap time.
                if (mLaps.size() > 1) {
                    timeStrings.set(0,
                            StopWatch.buildTimeStamp(baseTime - mLaps.get(1)));
                }
            }

            stopWatchState = savedInstanceState.getInt(getString(R.string.key_stopwatch_state),
                    StopWatch.sSTOP_STATE_VALUE);

            mTimedActivities = savedInstanceState.
                    getParcelableArrayList(getString(R.string.key_timed_activities));
        }
        else {
            // Check intent data
            Bundle bundle = getIntent().getExtras();
            if (bundle != null) {
                mTimedActivities = bundle.
                        getParcelableArrayList(getString(R.string.key_timed_activities));
            }
        }

        if (mTimedActivities == null) {
            mTimedActivities = new ArrayList<>();
        }

        // Create the stopwatch object.
        mStopWatch = new StopWatch(this, StopWatch.sDEFAULT_TIME_INTERVAL, baseTime);

        // Population of the activity fragments.
        if (savedInstanceState == null) {
            LapTimesFragment lapTimesFragment = new LapTimesFragment();
            ElapsedTimeFragment elapsedTimeFragment = new ElapsedTimeFragment();
            StopWatchActionsFragment stopWatchActionsFragment = new StopWatchActionsFragment();

            getSupportFragmentManager().beginTransaction()
                    .add(mBinding.rlElapsedTime.getId(), elapsedTimeFragment)
                    .add(mBinding.rlLapTimes.getId(), lapTimesFragment)
                    .add(mBinding.rlStopwatchActions.getId(), stopWatchActionsFragment)
                    .commit();
        }
        else {
            // Populate the fragments associated with the StopWatchActivity.
            initializeFragments(baseTime, timeStrings);

            // Check the state
            if (stopWatchState == StopWatch.sPLAY_STATE_VALUE) {
                mStopWatch.play();
            }
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater menuInflater = getMenuInflater();
        menuInflater.inflate(R.menu.menu_stopwatch, menu);
        return super.onCreateOptionsMenu(menu);
    }

    @Override
    public void handleStopWatchAction(ACTIONS action) {
        // Allows the StopWatchActionsFragment to inform the StopWatchActivity class about a user
        // action on the supported StopWatchActions.
        switch (action) {
            case Start:
                mStopWatch.play();
                break;
            case Stop:
                mStopWatch.pause();
                break;
            case Lap:
                createLap();
                break;
            case Reset:
                mStopWatch.stop();
                mLaps.clear();
                tickEvent(0);
                break;
        }
    }

    @Override
    public void tickEvent(long milliSecondsElapsed) {
        Long lastLapTime = 0L;
        String totalTimeDisplay = null, lapTimeDisplay = null;

        if (mLaps.size() > 1) {
            lastLapTime = mLaps.get(1);
        }
        else if (mLaps.size() == 0) {
            mLaps.add(0L);
        }

        totalTimeDisplay = StopWatch.buildTimeStamp(milliSecondsElapsed);
        lapTimeDisplay = StopWatch.buildTimeStamp(
                milliSecondsElapsed - lastLapTime);
        mLaps.set(0, milliSecondsElapsed);

        // Inform the fragments to update their times.
        ElapsedTimeFragment elapsedTimeFragment = (ElapsedTimeFragment) getSupportFragmentManager()
                .findFragmentById(mBinding.rlElapsedTime.getId());

        LapTimesFragment lapTimesFragment = (LapTimesFragment) getSupportFragmentManager()
                .findFragmentById(mBinding.rlLapTimes.getId());

        if (elapsedTimeFragment != null) {
            elapsedTimeFragment.updateElapsedTime(totalTimeDisplay);
        }
        else {
            throw new java.lang.UnsupportedOperationException(
                    "The elapsed time fragment does not exist and recieved a tick event."
            );
        }

        if (lapTimesFragment != null) {
            if (milliSecondsElapsed == 0) {
                lapTimesFragment.resetLapTimes();
            }
            else {
                lapTimesFragment.updateLapTime(lapTimeDisplay);
            }
        }
        else {
            throw new java.lang.UnsupportedOperationException(
                    "The lap time fragment does not exist and recieved a tick event."
            );
        }
    }
}
```


Overlapping Code:
```
CompatActivity implements
StopWatchActionsFragment.StopWatchActions,
StopWatch.StopWatchTickEvents {
private ActivityStopwatchBinding mBinding = null;
private StopWatch mStopWatch = null;
private List<Long> mLaps = null;
private List<TimedActivity> mTimedActivities = new ArrayList<>();
private void createLap() {
LapTimesFragment lapTimesFragment = (LapTimesFragment) getSupportFragmentManager()
.findFragmentById(mBinding.rlLapTimes.getId());
// Add a new lap that starts at 0 to the list of laps.
mLaps.add(0, 0L);
if (lapTimesFragment != null) {
if (!mLaps.isEmpty()) {
lapTimesFragment.newLapTime(StopWatch.buildTimeStamp(mLaps.get(0)));
}
}
else {
throw new java.lang.UnsupportedOperationException(
"The lap time fragment does not exist and recieved a create lap event."
);
}
}
private void initializeFragments(long baseTime, List<String> times) {
// Inform the fragments to update their times.
ElapsedTimeFragment elapsedTimeFragment = (ElapsedTimeFragment) getSupportFragmentManager()
.findFragmentById(mBinding.rlElapsedTime.getId());
LapTimesFragment lapTimesFragment = (LapTimesFragment) getSupportFragmentManager()
.findFragmentById(mBinding.rlLapTimes.getId());
if (elapsedTimeFragment != null) {
elapsedTimeFragment.updateElapsedTime(StopWatch.buildTimeStamp(baseTime));
}
else {
throw new java.lang.UnsupportedOperationException(
"The elapsed time fragment does not exist and trying to initialize."
);
}
if (lapTimesFragment != null) {
lapTimesFragment.initializeLaps(times);
}
else {
throw new java.lang.UnsupportedOperationException(
"The lap time fragment does not exist and trying to initialize."
);
}
}
private void saveAndReturn() {
Bundle bundle = new Bundle();
long [] lapsToSave = new long [mLaps.size()];
long prevLap = 0L;
long totalTime = 0L;
// populate the array that will be passed back as a bundle.
for (int index = lapsToSave.length - 1; index >= 0; index--) {
lapsToS
```
<Overlap Ratio: 0.958627648839556>

---

--- 88 --
Question ID: 5034c8c4401260d65dcb92364ee41954bc827226
Original Code:
```
public class PlanetRadar extends Starship{
	
	static Texture tex1 = new Texture("WIP.png");
	
	public PlanetRadar(StarshipArena mygame, double spawnx, double spawny){
		super(mygame, spawnx, spawny);
	}
	
	public PlanetRadar(StarshipArena mygame, double spawnx, double spawny, double spawnangle){
		super(mygame, "none", spawnx, spawny, spawnangle);
	}

	public PlanetRadar(StarshipArena mygame, String newteam, double spawnx, double spawny, double spawnangle){
		super(mygame, newteam, spawnx, spawny, spawnangle);
	}
	
	public void shipStats(){
		max_health = 100;
		scan_range = 10000;
		radar_range = 10000;
		//movement
		acceleration = 0;
		max_velocity = 0;
		min_turn_velocity = 0;
		max_turn_speed = 1;
		current_turn_speed = -max_turn_speed;
		//other
		clickRadius = 45;
		xOff = 0;
		yOff = 0;
	}
	
	public void setTexture(){
		tex1.bind();
	}
	
	public void setTextureCoords(){
		textureCoords = new double[]{0, 0, 0, 1, 1, 0, 1, 1};
	}
	
	public void setIndices(){
		indices = new int[]{0, 1, 2, 2, 1, 3};
	}
	
	public Point[] generatePoints(){
		Point[] points = new Point[]{
			new Point(-32, 32, true),
			new Point(-32, -32, true),
			new Point(32, 32, true),
			new Point(32, -32, true)
		};
		return points;
	}
	
	public Point[] generateHitbox(){
		Point[] hitbox = new Point[]{
			new Point(-32, 32, true),
			new Point(-32, -32, true),
			new Point(32, 32, true),
			new Point(32, -32, true)
		};
		return hitbox;
	}
	
	
}
```


Overlapping Code:
```
 extends Starship{

static Texture tex1 = new Texture("WIP.png");

public PlanetRadar(StarshipArena mygame, double spawnx, double spawny){
super(mygame, spawnx, spawny);
}

public PlanetRadar(StarshipArena mygame, double spawnx, double spawny, double spawnangle){
super(mygame, "none", spawnx, spawny, spawnangle);
}
public PlanetRadar(StarshipArena mygame, String newteam, double spawnx, double spawny, double spawnangle){
super(mygame, newteam, spawnx, spawny, spawnangle);
}

public void shipStats(){
max_health = 100;
scan_range = 10000;
radar_range = 10000;
//movement
acceleration = 0;
max_velocity = 0;
min_turn_velocity = 0;
max_turn_speed = 1;
current_turn_speed = -max_turn_speed;
//other
clickRadius = 45;
xOff = 0;
yOff = 0;
}

public void setTexture(){
tex1.bind();
}

public void setTextureCoords(){
textureCoords = new double[]{0, 0, 0, 1, 1, 0, 1, 1};
}

public void setIndices(){
indices = new int[]{0, 1, 2, 2, 1, 3};
}

public Point[] generatePoints(){
Point[] points = new Point[]{
new Point(-32, 32, true),
new Point(-32, -32, true),
new Point(32, 32, true),
new Point(32, -32, true)
};
return points;
}

public Point[] generateHitbox(){
Point[] hitbox = new Point[]{
new Point(-32, 32, true),
new Point(-32, -32, true),
new Point(32, 32, true),
new Point(32, -32, true)
};

```
<Overlap Ratio: 0.9671396564600448>

---

--- 89 --
Question ID: c11ed96a4d9272e6f51ee973c876138e0f19bd50
Original Code:
```
public class User implements Parcelable {

    /**
     * User details for the login procedure.
     */
    private String username;
    private String oauthToken;
    private String oauthTokenSecret;

    /**
     * Default constructor.
     * 
     * @param oauthToken
     *            The OAuth token
     * @param oauthTokenSecret
     *            The OAuth secret token
     */
    public User(String oauthToken, String oauthTokenSecret) {
        this.oauthToken = oauthToken;
        this.oauthTokenSecret = oauthTokenSecret;
    }

    /**
     * Default constructor.
     * 
     * @param username
     *            The name of the user
     * @param oauthToken
     *            The OAuth token
     * @param oauthTokenSecret
     *            The OAuth secret token
     */
    public User(String username, String oauthToken, String oauthTokenSecret) {
        this.username = username;
        this.oauthToken = oauthToken;
        this.oauthTokenSecret = oauthTokenSecret;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getOAuthToken() {
        return oauthToken;
    }

    public void setOAuthToken(String oauthToken) {
        this.oauthToken = oauthToken;
    }

    public String getOauthTokenSecret() {
        return oauthTokenSecret;
    }

    public void setOauthTokenSecret(String oauthTokenSecret) {
        this.oauthTokenSecret = oauthTokenSecret;
    }

    /**
     * Constructor to create a User from a parcel.
     * 
     * @param in
     *            The parcel to read from
     */
    private User(Parcel in) {
        this.username = in.readString();
        this.oauthToken = in.readString();
        this.oauthTokenSecret = in.readString();
    }

    /**
     * Methods to write and restore a Parcel.
     */
    public static final Parcelable.Creator<User> CREATOR = new Parcelable.Creator<User>() {

        public User createFromParcel(Parcel in) {
            return new User(in);
        }

        public User[] newArray(int size) {
            return new User[size];
        }
    };

    /**
     * Writes the nodes to the given parcel.
     */
    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(username);
        dest.writeString(oauthToken);
        dest.writeString(oauthTokenSecret);
    }

    @Override
    public int describeContents() {
        return 0;
    }

}
```


Overlapping Code:
```

* User details for the login procedure.
*/
private String username;
private String oauthToken;
private String oauthTokenSecret;
/**
* Default constructor.
* 
* @param oauthToken
* The OAuth token
* @param oauthTokenSecret
* The OAuth secret token
*/
public User(String oauthToken, String oauthTokenSecret) {
this.oauthToken = oauthToken;
this.oauthTokenSecret = oauthTokenSecret;
}
/**
* Default constructor.
* 
* @param username
* The name of the user
* @param oauthToken
* The OAuth token
* @param oauthTokenSecret
* The OAuth secret token
*/
public User(String username, String oauthToken, String oauthTokenSecret) {
this.username = username;
this.oauthToken = oauthToken;
this.oauthTokenSecret = oauthTokenSecret;
}
public String getUsername() {
return username;
}
public void setUsername(String username) {
this.username = username;
}
public String getOAuthToken() {
return oauthToken;
}
public void setOAuthToken(String oauthToken) {
this.oauthToken = oauthToken;
}
public String getOauthTokenSecret() {
return oauthTokenSecret;
}
public void setOauthTokenSecret(String oauthTokenSecret) {
this.oauthTokenSecret = oauthTokenSecret;
}
/**
* Constructor to create a User from a parcel.
* 
* @param in
* The parcel to read from
*/
private User(Parcel in) {
this.username = in.readString();
this.oauthToken = in.readString();
this.oauthTokenSecret = in.readString();
}
/**
* Methods to write and restore a Parcel.
*/
public static final Parcelable.Creator<User> CREATOR = new Parcelable.Creator<User>() {
public User createFromParcel(Parcel in) {
return new User(in);
}
public User[] newArray(int size) {
return new User[size];
}
};
/**
* Writes the nodes to the given parcel.
*/
@Override
public void writeToParcel(Parcel dest, int flags) {
dest.writeString(username);
dest.writeString(oauthToken);
dest.writeString(oauthTokenSecret);
}
@Override
public int describeContents() {
return 0;
}
}
```
<Overlap Ratio: 0.9768160741885626>

---

--- 90 --
Question ID: 57ba7c5affc3bea5b2ee8f3766f262bcedca7d78
Original Code:
```
@Component
public class SavingsPotentialComputeTask extends BaseTask implements StoppableTasklet {

    /**
     * Service for accessing savings potential scenario data.
     */
    @Autowired
    private ISavingsPotentialService savingsPotentialService;

    /**
     * Repository for updating savings potential scenario data.
     */
    @Autowired
    private ISavingsPotentialRepository savingsPotentialRepository;

    /**
     * Repository for accessing utility data.
     */
    @Autowired
    private IUtilityRepository utilityRepository;

    /**
     * Repository for accessing user data.
     */
    @Autowired
    private IUserRepository userRepository;

    /**
     * Service for querying user consumption data.
     */
    @Autowired
    private IDataService dataService;

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {
        try {
            Map<String, String> parameters = getStepParameters(chunkContext.getStepContext());

            // Get scenario
            if(StringUtils.isBlank(parameters.get(EnumInParameter.SCENARIO_KEY.getValue()))) {
                return RepeatStatus.FINISHED;
            }

            UUID scenarioKey = UUID.fromString(parameters.get(EnumInParameter.SCENARIO_KEY.getValue()));
            SavingScenario scenario = savingsPotentialService.find(scenarioKey);

            // Get utility
            UtilityInfo utility = utilityRepository.getUtilityByKey(scenario.getUtilityKey());

            // Get scenario results
            SavingResultStore resultStore = new SavingResultStore();
            for(SavingsPotentialResultEntity result : savingsPotentialService.getScenarioResults(scenario.getKey())) {
                resultStore.add(result.getMonth(), result.getSerial(), result.getSavingsVolume() / (double) result.getClusterSize());
            }

            // Compute date interval
            DateTimeZone timezone = DateTimeZone.forID(utility.getTimezone());

            DateTime begin = new DateTime(scenario.getParameters().getTime().getStart(), timezone);
            begin = begin.dayOfMonth().withMinimumValue()
                         .hourOfDay().setCopy(0).minuteOfHour().setCopy(0).secondOfMinute().setCopy(0).millisOfSecond().setCopy(0);

            DateTime end = new DateTime(scenario.getParameters().getTime().getEnd(), timezone);
            end = end.dayOfMonth().withMaximumValue()
                     .hourOfDay().setCopy(23).minuteOfHour().setCopy(59).secondOfMinute().setCopy(59).millisOfSecond().setCopy(999);

            // Compute savings per user
            double scenarioConsumption = 0;
            double scenarioSavings = 0;

            Map<String, UUID> serialToUserMap = new HashMap<String, UUID>();
            Map<UUID, AccountSavings> savingsStore = new HashMap<UUID, AccountSavings>();

            while(begin.isBefore(end)) {
                int year = begin.getYear();
                int month = begin.getMonthOfYear();

                Map<String, SavingResult> monthlyResults = resultStore.results.get(month);

                if(monthlyResults == null) {
                    begin = begin.plusMonths(1);
                    continue;
                }

                for (SavingResult consumer : monthlyResults.values()) {
                    // Resolve user key and cache it
                    UUID userKey = serialToUserMap.get(consumer.serial);
                    if(userKey == null) {
                        AccountEntity account = userRepository.getUserByMeterSerial(consumer.serial);
                        if(account == null) {
                            continue;
                        }
                        userKey = account.getKey();
                        serialToUserMap.put(consumer.serial, userKey);
                    }

                    DataQuery query = DataQueryBuilder.create()
                                                      .timezone(timezone)
                                                      .absolute(begin, begin.dayOfMonth().withMaximumValue(), EnumTimeAggregation.MONTH)
                                                      .user(consumer.serial, userKey)
                                                      .meter()
                                                      .userAggregates()
                                                      .sum()
                                                      .build();
                    DataQueryResponse result = dataService.execute(query);
                    if(result.getMeters().isEmpty()) {
                        continue;
                    }

                    for (DataPoint point : result.getMeters().get(0).getPoints()) {
                        MeterDataPoint meterPoint = (MeterDataPoint) point;
                        DateTime instant = new DateTime(meterPoint.getTimestamp(), timezone);

                        if ((instant.getYear() == year) && (instant.getMonthOfYear() == month)) {
                            AccountSavings s = savingsStore.get(userKey);
                            if (s == null) {
                                s = new AccountSavings();
                                s.userKey = userKey;
                                savingsStore.put(userKey, s);
                            }

                            s.totalConsumption += meterPoint.getVolume().get(EnumMetric.SUM);
                            s.totalSavings += consumer.userMonthlyPotential;

                            scenarioConsumption += meterPoint.getVolume().get(EnumMetric.SUM);
                            scenarioSavings += consumer.userMonthlyPotential;

                            continue;
                        }
                    }
                }

                begin = begin.plusMonths(1);
            }

            // Update store
            for (AccountSavings s : savingsStore.values()) {
                savingsPotentialRepository.updateSavingConsumer(scenarioKey,
                                                                s.userKey,
                                                                s.totalConsumption,
                                                                s.totalSavings,
                                                                DateTime.now());
            }

            savingsPotentialRepository.updateSavingScenario(scenarioKey,
                                                            scenarioConsumption,
                                                            scenarioSavings,
                                                            DateTime.now(),
                                                            savingsStore.size());

        } catch (Throwable t) {
            throw wrapApplicationException(t, SchedulerErrorCode.SCHEDULER_JOB_STEP_FAILED).set("step", chunkContext.getStepContext().getStepName());
        }

        return RepeatStatus.FINISHED;
    }

    @Override
    public void stop() {
        // TODO: Add business logic for stopping processing
    }

    /**
     * Enumeration of job input parameters.
     */
    public static enum EnumInParameter {
        /**
         * Savings potential scenario key.
         */
        SCENARIO_KEY("scenario.key");


        private final String value;

        public String getValue() {
            return value;
        }

        private EnumInParameter(String value) {
            this.value = value;
        }
    }

    private static class SavingResultStore {

        public Map<Integer, Map<String, SavingResult>> results = new HashMap<Integer, Map<String, SavingResult>>();

        public void add(int month, String serial, double userMonthlyPotential) {
            Map<String, SavingResult> monthlySavings = results.get(month);
            if (monthlySavings == null) {
                monthlySavings = new HashMap<String, SavingResult>();
                results.put(month, monthlySavings);
            }
            monthlySavings.put(serial, new SavingResult(serial, userMonthlyPotential));
        }
    }

    private static class SavingResult {

        public String serial;

        public double userMonthlyPotential;

        public SavingResult(String serial, double userMonthlyPotential) {
            this.serial = serial;
            this.userMonthlyPotential = userMonthlyPotential;
        }
    }

    private static class AccountSavings {

        public UUID userKey;

        public double totalConsumption = 0;

        public double totalSavings = 0;
    }
}
```


Overlapping Code:
```
puteTask extends BaseTask implements StoppableTasklet {
/**
* Service for accessing savings potential scenario data.
*/
@Autowired
private ISavingsPotentialService savingsPotentialService;
/**
* Repository for updating savings potential scenario data.
*/
@Autowired
private ISavingsPotentialRepository savingsPotentialRepository;
/**
* Repository for accessing utility data.
*/
@Autowired
private IUtilityRepository utilityRepository;
/**
* Repository for accessing user data.
*/
@Autowired
private IUserRepository userRepository;
/**
* Service for querying user consumption data.
*/
@Autowired
private IDataService dataService;
@Override
public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) {
try {
Map<String, String> parameters = getStepParameters(chunkContext.getStepContext());
// Get scenario
if(StringUtils.isBlank(parameters.get(EnumInParameter.SCENARIO_KEY.getValue()))) {
return RepeatStatus.FINISHED;
}
UUID scenarioKey = UUID.fromString(parameters.get(EnumInParameter.SCENARIO_KEY.getValue()));
SavingScenario scenario = savingsPotentialService.find(scenarioKey);
// Get utility
UtilityInfo utility = utilityRepository.getUtilityByKey(scenario.getUtilityKey());
// Get scenario results
SavingResultStore resultStore = new SavingResultStore();
for(SavingsPotentialResultEntity result : savingsPotentialService.getScenarioResults(scenario.getKey())) {
resultStore.add(result.getMonth(), result.getSerial(), result.getSavingsVolume() / (double) result.getClusterSize());
}
// Compute date interval
DateTimeZone timezone = DateTimeZone.forID(utility.getTimezone());
DateTime begin = new DateTime(scenario.getParameters().getTime().getStart(), timezone);
begin = begin.dayOfMonth().withMinimumValue()
.hourOfDay().setCopy(0).minuteOfHour().setCopy(0).secondOfMinute().setCopy(0).millisOfSecond().setCopy(0);
DateTime end = new DateTime(scenario.getParameters().getTime().getEnd(), timezone);
end = end.dayOfMonth().withMaximumValue()
.hourOfDay().setCopy(23).m
```
<Overlap Ratio: 0.968054211035818>

---

--- 91 --
Question ID: 3b3070aaeb72a56bbd5331b654fcaafaa9e4086f
Original Code:
```
public class ObjectToSQLMapper extends SQLMapper implements IObjectToSQLMapper {

	public ObjectToSQLMapper(Connection connection, String packageName, String sourceVersion, String targetVersion) {
		super(connection, packageName, sourceVersion, targetVersion);
	}

	@Override
	public void newObject(String tableName) throws SpecmateException {
		String failmsg = "Migration: Could not add table " + tableName + ".";
		List<String> queries = new ArrayList<>();

		queries.add("CREATE TABLE " + tableName + "(" + "CDO_ID BIGINT NOT NULL, " + "CDO_VERSION INTEGER NOT NULL, "
				+ "CDO_CREATED BIGINT NOT NULL, " + "CDO_REVISED BIGINT NOT NULL, " + "CDO_RESOURCE BIGINT NOT NULL, "
				+ "CDO_CONTAINER BIGINT NOT NULL, " + "CDO_FEATURE INTEGER NOT NULL)");

		queries.add("CREATE UNIQUE INDEX " + SQLUtil.createTimebasedIdentifier("PK", H2ProviderConfig.MAX_ID_LENGTH)
				+ " ON " + tableName + " (CDO_ID ASC, CDO_VERSION ASC)");

		queries.add("CREATE INDEX " + SQLUtil.createTimebasedIdentifier("I", H2ProviderConfig.MAX_ID_LENGTH) + " ON "
				+ tableName + " (CDO_REVISED ASC)");

		queries.add("ALTER TABLE " + tableName + " ADD CONSTRAINT "
				+ SQLUtil.createTimebasedIdentifier("C", H2ProviderConfig.MAX_ID_LENGTH)
				+ " PRIMARY KEY (CDO_ID, CDO_VERSION)");

		queries.add(insertExternalObjectReference(tableName));
		SQLUtil.executeStatements(queries, connection, failmsg);
	}
}
```


Overlapping Code:
```
ublic class ObjectToSQLMapper extends SQLMapper implements IObjectToSQLMapper {
public ObjectToSQLMapper(Connection connection, String packageName, String sourceVersion, String targetVersion) {
super(connection, packageName, sourceVersion, targetVersion);
}
@Override
public void newObject(String tableName) throws SpecmateException {
String failmsg = "Migration: Could not add table " + tableName + ".";
List<String> queries = new ArrayList<>();
queries.add("CREATE TABLE " + tableName + "(" + "CDO_ID BIGINT NOT NULL, " + "CDO_VERSION INTEGER NOT NULL, "
+ "CDO_CREATED BIGINT NOT NULL, " + "CDO_REVISED BIGINT NOT NULL, " + "CDO_RESOURCE BIGINT NOT NULL, "
+ "CDO_CONTAINER BIGINT NOT NULL, " + "CDO_FEATURE INTEGER NOT NULL)");
queries.add("CREATE UNIQUE INDEX " + SQLUtil.createTimebasedIdentifier("PK", H2ProviderConfig.MAX_ID_LENGTH)
+ " ON " + tableName + " (CDO_ID ASC, CDO_VERSION ASC)");
queries.add("CREATE INDEX " + SQLUtil.createTimebasedIdentifier("I", H2ProviderConfig.MAX_ID_LENGTH) + " ON "
+ tableName + " (CDO_REVISED ASC)");
queries.add("ALTER TABLE " + tableName + " ADD CONSTRAINT "
+ SQLUtil.createTimebasedIdentifier("C", H2ProviderConfig.MAX_ID_LENGTH)
+ " PRIMARY KEY (CDO_ID, CDO_VERSION)");
queries.add(insertExternalObjectReference(tableName));
SQLUtil.executeStatements(queries, connection, failmsg)
```
<Overlap Ratio: 0.9955089820359282>

---

--- 92 --
Question ID: 48e4b08bad4647f81d597086647d7a1fbaf3c222
Original Code:
```
public class SparseVector<T> {
//    private long length;
//    private T defaultValue;

//    private Map<Long, T> valuesByNdx;

    private List<Data<T>> list;

    public SparseVector() {
//        this.length = length;
//        this.defaultValue = defaultValue;
//        this.valuesByNdx = new HashMap<>();
        this.list = new LinkedList<>();
    }

//    public long getLength() {
//        return length;
//    }

//    public T getDefaultValue() {
//        return defaultValue;
//    }

    public void put(long ndx, T value) {
//        if (value.equals(defaultValue)) {
//            if (valuesByNdx.containsKey(ndx)) {
//                valuesByNdx.remove(ndx);
//            }
//        } else {
//            valuesByNdx.put(ndx, value);
//        }
        list.add(new Data<T>(ndx, value));
    }

//    public T get(long ndx) {
//        return valuesByNdx.containsKey(ndx) ? valuesByNdx.get(ndx) : defaultValue;
//    }
//
//    public boolean has(long ndx) {
//        return valuesByNdx.containsKey(ndx);
//    }

    public Iterator<Data<T>> getIterator() {
        return list.iterator();
    }

    public class Data<T> {
        private long ndx;
        private T value;

        private Data(long ndx, T value) {
            this.ndx = ndx;
            this.value = value;
        }

        public long getNdx() {
            return ndx;
        }

        public T getValue() {
            return value;
        }
    }
}
```


Overlapping Code:
```
ong length;
// private T defaultValue;
// private Map<Long, T> valuesByNdx;
private List<Data<T>> list;
public SparseVector() {
// this.length = length;
// this.defaultValue = defaultValue;
// this.valuesByNdx = new HashMap<>();
this.list = new LinkedList<>();
}
// public long getLength() {
// return length;
// }
// public T getDefaultValue() {
// return defaultValue;
// }
public void put(long ndx, T value) {
// if (value.equals(defaultValue)) {
// if (valuesByNdx.containsKey(ndx)) {
// valuesByNdx.remove(ndx);
// }
// } else {
// valuesByNdx.put(ndx, value);
// }
list.add(new Data<T>(ndx, value));
}
// public T get(long ndx) {
// return valuesByNdx.containsKey(ndx) ? valuesByNdx.get(ndx) : defaultValue;
// }
//
// public boolean has(long ndx) {
// return valuesByNdx.containsKey(ndx);
// }
public Iterator<Data<T>> getIterator() {
return list.iterator();
}
public class Data<T> {
private long ndx;
private T value;
private Data(long ndx, T value) {
this.ndx = ndx;
this.value = value;
}
public long getNdx() {
return ndx;
}
public T getVal
```
<Overlap Ratio: 0.938337801608579>

---

--- 93 --
Question ID: b3da66788cb916c8b708fa1d648ce7fc77d342cc
Original Code:
```
@RunWith(LienzoMockitoTestRunner.class)
public class StunnerWiresConnectorHandlerTest {

    private StunnerWiresConnectorHandler stunnerWiresConnectorHandler;

    @Mock
    private WiresConnectorView connector;

    @Mock
    private NodeMouseDoubleClickEvent doubleClickEvent;

    @Before
    public void setUp() throws Exception {
        stunnerWiresConnectorHandler = new StunnerWiresConnectorHandler(connector, WiresManager.get(new Layer()));
    }

    @Test
    public void onNodeMouseDoubleClick() {
        stunnerWiresConnectorHandler.onNodeMouseDoubleClick(doubleClickEvent);
        //test it is not executing any action
        verify(connector, never()).getLine();
        verify(connector, never()).getPointHandles();
    }
}
```


Overlapping Code:
```
@RunWith(LienzoMockitoTestRunner.class)
public class StunnerWiresConnectorHandlerTest {
private StunnerWiresConnectorHandler stunnerWiresConnectorHandler;
@Mock
private WiresConnectorView connector;
@Mock
private NodeMouseDoubleClickEvent doubleClickEvent;
@Before
public void setUp() throws Exception {
stunnerWiresConnectorHandler = new StunnerWiresConnectorHandler(connector, WiresManager.get(new Layer()));
}
@Test
public void onNodeMouseDoubleClick() {
stunnerWiresConnectorHandler.onNodeMouseDoubleClick(doubleClickEvent);
//test it is not executing any action
verify(connector, never()).getLine();
verify(connec
```
<Overlap Ratio: 0.944954128440367>

---

--- 94 --
Question ID: 7b6ffec8eaef91ed6bcbe4d02e50f38f3e713e21
Original Code:
```
public class AdminServlet extends HttpServlet {

// store classes giving access to users, conversations, and messages
 private UserStore userStore; 
  private ConversationStore conversationStore;
  private MessageStore messageStore;

 @Override
 public void init() throws ServletException {
   super.init();
  setConversationStore(ConversationStore.getInstance());
  setMessageStore(MessageStore.getInstance());
  setUserStore(UserStore.getInstance());
 }


  void setConversationStore(ConversationStore conversationStore) {
    this.conversationStore = conversationStore;
  }

  void setMessageStore(MessageStore messageStore) {
    this.messageStore = messageStore;
  }

  void setUserStore(UserStore userStore) {
   this.userStore = userStore;
 }


  @Override
  public void doGet(HttpServletRequest request, HttpServletResponse response)
    throws IOException, ServletException {
      HashMap<String, Object> stats = new HashMap<String, Object>();
      stats.putAll(userStore.getUserStats());
      stats.putAll(conversationStore.getConversationStats());
      stats.putAll(messageStore.getMessageStats());
      //UUID mostActiveID = (UUID) stats.get("Most Active User: ");
      //User mostActiveUser = userStore.getUser(mostActiveID);
      //stats.put("Most Active User: ", mostActiveUser.getName());
      request.setAttribute("statistics", stats);
      request.getRequestDispatcher("/WEB-INF/view/admin.jsp").forward(request, response);
  }
}
```


Overlapping Code:
```
s HttpServlet {
// store classes giving access to users, conversations, and messages
private UserStore userStore; 
private ConversationStore conversationStore;
private MessageStore messageStore;
@Override
public void init() throws ServletException {
super.init();
setConversationStore(ConversationStore.getInstance());
setMessageStore(MessageStore.getInstance());
setUserStore(UserStore.getInstance());
}
void setConversationStore(ConversationStore conversationStore) {
this.conversationStore = conversationStore;
}
void setMessageStore(MessageStore messageStore) {
this.messageStore = messageStore;
}
void setUserStore(UserStore userStore) {
this.userStore = userStore;
}
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response)
throws IOException, ServletException {
HashMap<String, Object> stats = new HashMap<String, Object>();
stats.putAll(userStore.getUserStats());
stats.putAll(conversationStore.getConversationStats());
stats.putAll(messageStore.getMessageStats());
//UUID mostActiveID = (UUID) stats.get("Most Active User: ");
//User mostActiveUser = userStore.getUser(mostActiveID);
//stats.put("Most Active User: ", mostActiveUser.getName());
request.setAttribute("statistics", stats);
request.getRequestDispatcher("/WEB-INF/view/admin.jsp").forward(request, response);
}

```
<Overlap Ratio: 0.9754646840148699>

---

--- 95 --
Question ID: b0d981efcf3f9e5edd02c27390100d5d39cbaa71
Original Code:
```
public class Messenger {
//	IDiscordClient client;
	
	
	
	public Messenger(IDiscordClient c) {
//		this.client = c;
	}
//	public Messenger() {
//		
//	}
	
	public Messenger() {
		
	}
	
	//sends a message
	public void sendMessage(IChannel channel, String message) {
		

		Logger.logBot(channel, message);
		
        // this is so it can repeat sending messages when rate limited
        RequestBuffer.request(() -> {
            try{
                channel.sendMessage(message);
            } catch (DiscordException e){
                System.err.println("Message could not be sent with error: ");
                e.printStackTrace();
            }
			return ;
        });
		
		
		
	}
	
	public IMessage sendMessageAndGet(IChannel c, String str) {
		Logger.logBot(c, str);
        // this is so it can repeat sending messages when rate limited
        return RequestBuffer.request(() -> {
            try{
                return c.sendMessage(str);
            } catch (DiscordException e){
                System.err.println("Message could not be sent with error: ");
                e.printStackTrace();
                return null;
            }
        }).get();
	}
	
	
	
	
}
```


Overlapping Code:
```
nger {
// IDiscordClient client;



public Messenger(IDiscordClient c) {
// this.client = c;
}
// public Messenger() {
// 
// }

public Messenger() {

}

//sends a message
public void sendMessage(IChannel channel, String message) {

Logger.logBot(channel, message);

// this is so it can repeat sending messages when rate limited
RequestBuffer.request(() -> {
try{
channel.sendMessage(message);
} catch (DiscordException e){
System.err.println("Message could not be sent with error: ");
e.printStackTrace();
}
return ;
});



}

public IMessage sendMessageAndGet(IChannel c, String str) {
Logger.logBot(c, str);
// this is so it can repeat sending messages when rate limited
return RequestBuffer.request(() -> {
try{
return c.sendMessage(str);
} catch (DiscordException e){
System.err.println("Message could not be sent with error: ");
e.printStackTrace();
return null
```
<Overlap Ratio: 0.9570011025358324>

---

--- 96 --
Question ID: 43bb421c9ebf3eb625b5c03b105acc33142518f5
Original Code:
```
public class ConfigurationList implements WorkspaceUpdateListener {
    private Map<CElectionDescription, List<ConfigurationBatch>> configsByDescr =
            new LinkedHashMap<CElectionDescription, List<ConfigurationBatch>>();
    private Map<PropertyDescription, List<ConfigurationBatch>> configsByPropDescr =
                new LinkedHashMap<PropertyDescription, List<ConfigurationBatch>>();
    private Map<String, ConfigurationBatch> configsByName =
            new LinkedHashMap<String, ConfigurationBatch>();

    public final boolean canAdd(final ConfigurationBatch config) {
        return !configsByName.containsKey(config.getName());
    }

    public final void add(final ConfigurationBatch config) {
        if (configsByName.containsKey(config.getName())) {
            throw new NotImplementedException();
        } else {
            configsByName.put(config.getName(), config);
        }
        if (!configsByDescr.containsKey(config.getDescr())) {
            configsByDescr.put(config.getDescr(), new ArrayList<ConfigurationBatch>());
        }
        configsByDescr.get(config.getDescr()).add(config);
        if (!configsByPropDescr.containsKey(config.getPropDescr())) {
            configsByPropDescr.put(config.getPropDescr(),
                                       new ArrayList<ConfigurationBatch>());
        }
        configsByPropDescr.get(config.getPropDescr()).add(config);
    }

    public final Map<CElectionDescription, List<ConfigurationBatch>> getConfigsByDescr() {
        return configsByDescr;
    }

    public final Map<PropertyDescription, List<ConfigurationBatch>> getConfigsByPropDescr() {
        return configsByPropDescr;
    }

    public final List<ConfigurationBatch>
                getConfigsByPropDescr(final PropertyDescription currentPropDescr) {
        if (configsByPropDescr.containsKey(currentPropDescr)) {
            return configsByPropDescr.get(currentPropDescr);
        }
        return List.of();
    }

    public final void handleDescrChange(final CElectionDescription descr) {
        if (configsByDescr.containsKey(descr)) {
            for (final ConfigurationBatch tc : configsByDescr.get(descr)) {
                tc.handleDescrChange();
            }
        }
    }

    public final List<PropertyCheckRun> getRuns() {
        final List<PropertyCheckRun> list = new ArrayList<PropertyCheckRun>();
        for (final CElectionDescription descr : configsByDescr.keySet()) {
            final List<ConfigurationBatch> configBatches = configsByDescr.get(descr);
            for (final ConfigurationBatch configBatch : configBatches) {
                for (final Configuration config : configBatch.getConfigs()) {
                    list.addAll(config.getRuns());
                }
            }
        }
        return list;
    }

    @Override
    public final void handleExtractedFunctionLoops(final CElectionDescription descr,
                                                   final CElectionDescriptionFunction func) {
        handleDescrChange(descr);
    }

    @Override
    public final void handleDescrChangeUpdatedFunctionCode(final CElectionDescription descr,
                                                           final CElectionDescriptionFunction
                                                                   function,
                                                           final String code) {
        handleDescrChange(descr);
    }

    @Override
    public final void handleDescrChangeAddedVotingSigFunction(final CElectionDescription descr,
                                                              final VotingSigFunction func) {
        handleDescrChange(descr);
    }

    @Override
    public final void handleDescrChangeRemovedFunction(final CElectionDescription descr,
                                                       final CElectionDescriptionFunction func) {
        handleDescrChange(descr);
    }

    private void handlePropDescrChanged(final PropertyDescription propDescr) {
        if (configsByPropDescr.containsKey(propDescr)) {
            for (final ConfigurationBatch tc : configsByPropDescr.get(propDescr)) {
                tc.handlePropDescrChanged();
            }
        }

    }

    @Override
    public final void handleWorkspaceUpdateAddedVarToPropDescr(final PropertyDescription
                                                                        currentPropDescr,
                                                               final SymbolicVariable var) {
        handlePropDescrChanged(currentPropDescr);
    }

    @Override
    public final void handlePropDescrChangedCode(final PropertyDescription propDescr) {
        handlePropDescrChanged(propDescr);
    }

    @Override
    public final void handlePropDescrRemovedVar(final PropertyDescription propDescr,
                                                final SymbolicVariable selectedVar) {
        handlePropDescrChanged(propDescr);
    }

    public final void deleteRun(final PropertyCheckRun run) {
        run.getTc().deleteRun(run);
    }

    public final void deleteConfiguration(final ConfigurationBatch tc) {
        configsByName.remove(tc.getName());
        configsByDescr.get(tc.getDescr()).remove(tc);
        final List<ConfigurationBatch> emptyList = new LinkedList<ConfigurationBatch>();
        configsByPropDescr.getOrDefault(tc.getPropDescr(), emptyList).remove(tc);
    }

    public final void removeAll(final CElectionDescription descr) {
        for (final ConfigurationBatch tc : configsByDescr.get(descr)) {
            deleteConfiguration(tc);
        }
        configsByDescr.remove(descr);
    }

    public final void removeAll(final PropertyDescription propDescr) {
        for (final ConfigurationBatch tc : configsByPropDescr.get(propDescr)) {
            deleteConfiguration(tc);
        }
        configsByPropDescr.remove(propDescr);
    }
}
```


Overlapping Code:
```
ionList implements WorkspaceUpdateListener {
private Map<CElectionDescription, List<ConfigurationBatch>> configsByDescr =
new LinkedHashMap<CElectionDescription, List<ConfigurationBatch>>();
private Map<PropertyDescription, List<ConfigurationBatch>> configsByPropDescr =
new LinkedHashMap<PropertyDescription, List<ConfigurationBatch>>();
private Map<String, ConfigurationBatch> configsByName =
new LinkedHashMap<String, ConfigurationBatch>();
public final boolean canAdd(final ConfigurationBatch config) {
return !configsByName.containsKey(config.getName());
}
public final void add(final ConfigurationBatch config) {
if (configsByName.containsKey(config.getName())) {
throw new NotImplementedException();
} else {
configsByName.put(config.getName(), config);
}
if (!configsByDescr.containsKey(config.getDescr())) {
configsByDescr.put(config.getDescr(), new ArrayList<ConfigurationBatch>());
}
configsByDescr.get(config.getDescr()).add(config);
if (!configsByPropDescr.containsKey(config.getPropDescr())) {
configsByPropDescr.put(config.getPropDescr(),
new ArrayList<ConfigurationBatch>());
}
configsByPropDescr.get(config.getPropDescr()).add(config);
}
public final Map<CElectionDescription, List<ConfigurationBatch>> getConfigsByDescr() {
return configsByDescr;
}
public final Map<PropertyDescription, List<ConfigurationBatch>> getConfigsByPropDescr() {
return configsByPropDescr;
}
public final List<ConfigurationBatch>
getConfigsByPropDescr(final PropertyDescription currentPropDescr) {
if (configsByPropDescr.containsKey(currentPropDescr)) {
return configsByPropDescr.get(currentPropDescr);
}
return List.of();
}
public final void handleDescrChange(final CElectionDescription descr) {
if (configsByDescr.containsKey(descr)) {
for (final ConfigurationBatch tc : configsByDescr.get(descr)) {
tc.handleDescrChange();
}
}
}
public final List<PropertyCheckRun> getRuns() {
final List<PropertyCheckRun> list = new ArrayList<PropertyCheckRun>();
for (final CElectionDescription descr : configsByDescr.
```
<Overlap Ratio: 0.9666505558240696>

---

--- 97 --
Question ID: 25c270fe8d00ff3346947add33e1a7e77fea446c
Original Code:
```
public class PreDefienedStream {
	public static void main(String[] args) throws IOException{
		PrintStream ps=System.out;
		ps.println("hello there!");
		
		ps.println("Input a character:");
		InputStream is=System.in;
		char ch=(char)is.read();
		ps.println("Your character is : "+ch);
	}
}
```


Overlapping Code:
```
dStream {
public static void main(String[] args) throws IOException{
PrintStream ps=System.out;
ps.println("hello there!");

ps.println("Input a character:");
InputStream is=System.in;
char ch=(char)is.read()
```
<Overlap Ratio: 0.7563636363636363>

---

--- 98 --
Question ID: 93bb1fc99291496fee9c267997d2a5d2a61bf52a
Original Code:
```
public class ConfigHandler {
	
	public static boolean enable_limestone_gen ;
	public static boolean enable_marblestone_gen;
	
	public static boolean enable_demonite_gen;
	public static boolean enable_feliron_ore_gen;
	
	public static int limestone_gen_chance;
	public static int marblestone_gen_chance;
	public static int demonite_gen_chance;
	public static int feliron_ore_gen_chance;
	
	
	public static Configuration config;
	
	public static void init(File file) {
		
		config = new Configuration(file);
		syncConfig();
		
	}
	
	public static void syncConfig() {
		
		String category = "ORE & STONE GEN";
		config.addCustomCategoryComment(category, "Ore & stone generators");
		enable_limestone_gen = config.getBoolean("Enable Limestone gen?", category, true, "true for generating limestone in the world");
		enable_marblestone_gen = config.getBoolean("Enable Marblestone gen", category, true, "true for generating marblestone in the world");
		
		enable_demonite_gen = config.getBoolean("Enable Demonite gen?", category, true, "true for generating demonite in the nether");
		enable_feliron_ore_gen = config.getBoolean("Enable Feliron Ore gen?", category, true, "true for generating felrion ore in the nether");
		
		
		category = "ORE GEN SETTINGS";
		config.addCustomCategoryComment(category, "Ore & stone generating chance settings");
		limestone_gen_chance = config.getInt("Limestone generation chance", category, 25, 1, 50, "increase for more limestone generation");
		marblestone_gen_chance = config.getInt("Marblestone generation chance", category, 25, 1, 50, "increase for more marblestone generation");
		
		demonite_gen_chance = config.getInt("Demonite generation chance", category, 25, 1, 50, "increase for more demonite generation");
		feliron_ore_gen_chance = config.getInt("Feliron Ore generation chance", category, 25, 1, 50, "increase for more feliron ore generation");
		
		
	}

}
```


Overlapping Code:
```

public static boolean enable_limestone_gen ;
public static boolean enable_marblestone_gen;

public static boolean enable_demonite_gen;
public static boolean enable_feliron_ore_gen;

public static int limestone_gen_chance;
public static int marblestone_gen_chance;
public static int demonite_gen_chance;
public static int feliron_ore_gen_chance;


public static Configuration config;

public static void init(File file) {

config = new Configuration(file);
syncConfig();

}

public static void syncConfig() {

String category = "ORE & STONE GEN";
config.addCustomCategoryComment(category, "Ore & stone generators");
enable_limestone_gen = config.getBoolean("Enable Limestone gen?", category, true, "true for generating limestone in the world");
enable_marblestone_gen = config.getBoolean("Enable Marblestone gen", category, true, "true for generating marblestone in the world");

enable_demonite_gen = config.getBoolean("Enable Demonite gen?", category, true, "true for generating demonite in the nether");
enable_feliron_ore_gen = config.getBoolean("Enable Feliron Ore gen?", category, true, "true for generating felrion ore in the nether");


category = "ORE GEN SETTINGS";
config.addCustomCategoryComment(category, "Ore & stone generating chance settings");
limestone_gen_chance = config.getInt("Limestone generation chance", category, 25, 1, 50, "increase for more limestone generation");
marblestone_gen_chance = config.getInt("Marblestone generation chance", category, 25, 1, 50, "increase for more marblestone generation");

demonite_gen_chance = config.getInt("Demonite generation chance", category, 25, 1, 50, "increase for more demonite generation");
feliron_ore_gen_chance = config.getInt("Feliron Ore generation chance", category, 25, 1, 50, "increase for more feliron ore generation");


```
<Overlap Ratio: 0.9819967266775778>

---

--- 99 --
Question ID: af086e1d9ad7e16d326928927d976e32d121b702
Original Code:
```
public class MultiThreadedSuperstepOutput<I extends WritableComparable,
    V extends Writable, E extends Writable> implements
    SuperstepOutput<I, V, E> {
  /** Mapper context */
  private final Mapper<?, ?, ?, ?>.Context context;
  /** Configuration */
  private ImmutableClassesGiraphConfiguration<I, V, E, ?> configuration;
  /** Vertex output format, used to get new vertex writers */
  private final VertexOutputFormat<I, V, E> vertexOutputFormat;
  /**
   * List of returned vertex writers, these can be reused and will all be
   * closed in the end of the application
   */
  private final List<VertexWriter<I, V, E>> availableVertexWriters;
  /** Vertex writes which were created by this class and are currently used */
  private final Set<VertexWriter<I, V, E>> occupiedVertexWriters;

  /**
   * Constructor
   *
   * @param conf    Configuration
   * @param context Mapper context
   */
  public MultiThreadedSuperstepOutput(
      ImmutableClassesGiraphConfiguration<I, V, E, ?> conf,
      Mapper<?, ?, ?, ?>.Context context) {
    this.configuration = conf;
    vertexOutputFormat = conf.createVertexOutputFormat();
    this.context = context;
    availableVertexWriters = Lists.newArrayList();
    occupiedVertexWriters = Sets.newHashSet();
  }

  @Override
  public synchronized SimpleVertexWriter<I, V, E> getVertexWriter() {
    VertexWriter<I, V, E> vertexWriter;
    if (availableVertexWriters.isEmpty()) {
      try {
        vertexWriter = vertexOutputFormat.createVertexWriter(context);
        vertexWriter.setConf(
            (ImmutableClassesGiraphConfiguration<I, V, E, Writable>)
                configuration);
        vertexWriter.initialize(context);
      } catch (IOException e) {
        throw new IllegalStateException("getVertexWriter: " +
            "IOException occurred", e);
      } catch (InterruptedException e) {
        throw new IllegalStateException("getVertexWriter: " +
            "InterruptedException occurred", e);
      }
    } else {
      vertexWriter =
          availableVertexWriters.remove(availableVertexWriters.size() - 1);
    }
    occupiedVertexWriters.add(vertexWriter);
    return vertexWriter;
  }

  @Override
  public synchronized void returnVertexWriter(
      SimpleVertexWriter<I, V, E> vertexWriter) {
    VertexWriter<I, V, E> returnedWriter = (VertexWriter<I, V, E>) vertexWriter;
    if (!occupiedVertexWriters.remove(returnedWriter)) {
      throw new IllegalStateException("returnVertexWriter: " +
          "Returned vertex writer which is not currently occupied!");
    }
    availableVertexWriters.add(returnedWriter);
  }

  @Override
  public synchronized void postApplication() throws IOException,
      InterruptedException {
    if (!occupiedVertexWriters.isEmpty()) {
      throw new IllegalStateException("postApplication: " +
          occupiedVertexWriters.size() +
          " vertex writers were not returned!");
    }
    for (VertexWriter<I, V, E> vertexWriter : availableVertexWriters) {
      vertexWriter.close(context);
    }
  }
}
```


Overlapping Code:
```
s MultiThreadedSuperstepOutput<I extends WritableComparable,
V extends Writable, E extends Writable> implements
SuperstepOutput<I, V, E> {
/** Mapper context */
private final Mapper<?, ?, ?, ?>.Context context;
/** Configuration */
private ImmutableClassesGiraphConfiguration<I, V, E, ?> configuration;
/** Vertex output format, used to get new vertex writers */
private final VertexOutputFormat<I, V, E> vertexOutputFormat;
/**
* List of returned vertex writers, these can be reused and will all be
* closed in the end of the application
*/
private final List<VertexWriter<I, V, E>> availableVertexWriters;
/** Vertex writes which were created by this class and are currently used */
private final Set<VertexWriter<I, V, E>> occupiedVertexWriters;
/**
* Constructor
*
* @param conf Configuration
* @param context Mapper context
*/
public MultiThreadedSuperstepOutput(
ImmutableClassesGiraphConfiguration<I, V, E, ?> conf,
Mapper<?, ?, ?, ?>.Context context) {
this.configuration = conf;
vertexOutputFormat = conf.createVertexOutputFormat();
this.context = context;
availableVertexWriters = Lists.newArrayList();
occupiedVertexWriters = Sets.newHashSet();
}
@Override
public synchronized SimpleVertexWriter<I, V, E> getVertexWriter() {
VertexWriter<I, V, E> vertexWriter;
if (availableVertexWriters.isEmpty()) {
try {
vertexWriter = vertexOutputFormat.createVertexWriter(context);
vertexWriter.setConf(
(ImmutableClassesGiraphConfiguration<I, V, E, Writable>)
configuration);
vertexWriter.initialize(context);
} catch (IOException e) {
throw new IllegalStateException("getVertexWriter: " +
"IOException occurred", e);
} catch (InterruptedException e) {
throw new IllegalStateException("getVertexWriter: " +
"InterruptedException occurred", e);
}
} else {
vertexWriter =
availableVertexWriters.remove(availableVertexWriters.size() - 1);
}
occupiedVertexWriters.add(vertexWriter);
return vertexWriter;
}
@Override
public synchronized void returnVertexWriter(
SimpleVertexWriter<I, V, E> vertexWriter) {
VertexWriter<I, V, E> returnedWriter = (VertexWriter<I, V, E>) vertexWriter;
if (!occupiedVertexWriters.remove(returnedWriter)) {
throw new IllegalSt
```
<Overlap Ratio: 0.9741730856366108>

---

--- 100 --
Question ID: cdae97cbc5d2b38426ba0868ed3192b9560aceb3
Original Code:
```
public class ImageGifLoaderInstance {

    public static final String TAG = ImageGifLoaderInstance.class.getSimpleName();

    private ImageLoader mImageLoader;

    private GifLoader mGifLoader;

    private Map<String, String> headers;

    private static ImageGifLoaderInstance instance;

    private HttpRequestFactory httpRequestFactory;

    private String token;

    public ImageGifLoaderInstance(HttpRequestFactory httpRequestFactory) {
        this.httpRequestFactory = httpRequestFactory;
    }

    public static ImageGifLoaderInstance getInstance(HttpRequestFactory httpRequestFactory) {

        if (instance == null)
            instance = new ImageGifLoaderInstance(httpRequestFactory);

        return instance;
    }

    public static void destroyInstance() {

        Log.d(TAG, "destroyInstance: ");

        instance = null;
    }

    public void setToken(String token) {

        Log.d(TAG, "setToken: " + token);

        this.token = token;

        if (mImageLoader != null) {

            Log.d(TAG, "setToken: create header");

            createHeader();

            mImageLoader.setHeaders(headers);

            if (mGifLoader != null) {
                mGifLoader.setHeaders(headers);
            }

        }

    }

    public ImageLoader getImageLoader(Context context) {

        RequestQueue mRequestQueue = RequestQueueInstance.getInstance(context).getRequestQueue();
        mImageLoader = new ImageLoader(mRequestQueue, ImageLruCache.instance());

        Log.d(TAG, "getImageLoader: create header");

        createHeader();

        mImageLoader.setHeaders(headers);

        return mImageLoader;

    }

    private void createHeader() {
        headers = new ArrayMap<>();

        String token = httpRequestFactory.getTokenForHeaderValue();

        headers.put(Util.KEY_AUTHORIZATION, token);
        Log.i(TAG, "FNAS JWT: " + token);
    }

    public GifLoader getGifLoader(Context context) {

        RequestQueue mRequestQueue = RequestQueueInstance.getInstance(context).getRequestQueue();
        mGifLoader = new GifLoader(mRequestQueue, GifLruCache.instance());

        Log.d(TAG, "getGifLoader: create header");

        createHeader();

        mImageLoader.setHeaders(headers);

        return mGifLoader;

    }

}
```


Overlapping Code:
```
Instance {
public static final String TAG = ImageGifLoaderInstance.class.getSimpleName();
private ImageLoader mImageLoader;
private GifLoader mGifLoader;
private Map<String, String> headers;
private static ImageGifLoaderInstance instance;
private HttpRequestFactory httpRequestFactory;
private String token;
public ImageGifLoaderInstance(HttpRequestFactory httpRequestFactory) {
this.httpRequestFactory = httpRequestFactory;
}
public static ImageGifLoaderInstance getInstance(HttpRequestFactory httpRequestFactory) {
if (instance == null)
instance = new ImageGifLoaderInstance(httpRequestFactory);
return instance;
}
public static void destroyInstance() {
Log.d(TAG, "destroyInstance: ");
instance = null;
}
public void setToken(String token) {
Log.d(TAG, "setToken: " + token);
this.token = token;
if (mImageLoader != null) {
Log.d(TAG, "setToken: create header");
createHeader();
mImageLoader.setHeaders(headers);
if (mGifLoader != null) {
mGifLoader.setHeaders(headers);
}
}
}
public ImageLoader getImageLoader(Context context) {
RequestQueue mRequestQueue = RequestQueueInstance.getInstance(context).getRequestQueue();
mImageLoader = new ImageLoader(mRequestQueue, ImageLruCache.instance());
Log.d(TAG, "getImageLoader: create header");
createHeader();
mImageLoader.setHeaders(headers);
return mImageLoader;
}
private void createHeader() {
headers = new ArrayMap<>();
String token = httpRequestFactory.getTokenForHeaderValue();
headers.put(Util.KEY_AUTHORIZATION, token);
Log.i(TAG, "FNAS JWT: " + token);
}
public GifLoader getGifLoader(Context context) {
RequestQueue mRequestQueue = RequestQueueInstance.getInstance(context).getRequestQueue();
mGifLoader = new GifLoader(mRequestQueue, GifLruCache.instance());
Log.d(TAG, "getGifLoader: create header");
createHeader();
mImageLoader.setHeaders
```
<Overlap Ratio: 0.967741935483871>

---

--- 101 --
Question ID: 8aa3e95e01d2b98bbbbac9ab23a9db30fc944884
Original Code:
```
public class RepeatedSubstrings
{
	public static void main(String[] args)
	{
		String str = "pwwde";
		System.out.println(method1(str));
		System.out.println(method2(str));
		System.out.println(method3(str));
	}

	/**
	 * 自己的解法
	 * @param str
	 * @return
	 */
	public static int method1(String str){
		Map<Character,Integer> map = new HashMap<>();
		char[] ch = str.toCharArray();
		int max = 0;
		for(int i = 0; i < ch.length; i++){
			if(map.containsKey(ch[i])){
				int size = map.size();
				if(size > max){
					max = size;
				}
				i = map.get(ch[i]);
				map.clear();
			}else{
				map.put(ch[i] , i);
			}
		}
		int size = map.size();
		if(size > max){
			max = size;
		}
		return max;
	}

	public static int method2(String str){
		int size = str.length();
		Set<Character> set = new HashSet<>();
		int max = 0,i = 0, j = 0;
		while(i < size && j < size){
			if(!set.contains(str.charAt(j))){
				set.add(str.charAt(j));
				j++;
				max = Math.max(max , j - i);
			}else{
				set.remove(str.charAt(i));
				i++;
			}
		}
		return max;
	}

	public static int method3(String str){
		int size = str.length();
		int max = 0;
		Map<Character, Integer> map = new HashMap<>();
		for(int j = 0,i = 0; j < size; j++){
			if(map.containsKey(str.charAt(j))){
				i = map.get(str.charAt(j));
			}
			max = Math.max(max,j - i + 1);
			map.put(str.charAt(j),j + 1);
		}
		return max;
	}
}
```


Overlapping Code:
```
rings
{
public static void main(String[] args)
{
String str = "pwwde";
System.out.println(method1(str));
System.out.println(method2(str));
System.out.println(method3(str));
}
/**
* 自己的解法
* @param str
* @return
*/
public static int method1(String str){
Map<Character,Integer> map = new HashMap<>();
char[] ch = str.toCharArray();
int max = 0;
for(int i = 0; i < ch.length; i++){
if(map.containsKey(ch[i])){
int size = map.size();
if(size > max){
max = size;
}
i = map.get(ch[i]);
map.clear();
}else{
map.put(ch[i] , i);
}
}
int size = map.size();
if(size > max){
max = size;
}
return max;
}
public static int method2(String str){
int size = str.length();
Set<Character> set = new HashSet<>();
int max = 0,i = 0, j = 0;
while(i < size && j < size){
if(!set.contains(str.charAt(j))){
set.add(str.charAt(j));
j++;
max = Math.max(max , j - i);
}else{
set.remove(str.charAt(i));
i++;
}
}
return max;
}
public static int method3(String str){
int size = str.length();
int max = 0;
Map<Character, Integer> map = new HashMap<>();
for(int j = 0,i = 0; j < size; j++){
if(map.containsKey(str.charAt(j))){
i = map.get(str.charAt(j));
}
max = Math.max(max,j - i + 1);
map
```
<Overlap Ratio: 0.9429502852485737>

---

--- 102 --
Question ID: 6b03f3560c4931fc445ef56e0258273d847dd4c8
Original Code:
```
public class msg_gps_global_origin extends MAVLinkMessage {
  public static final int MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN = 49;
  private static final long serialVersionUID = MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN;
  public msg_gps_global_origin(int sysId, int componentId) {
    messageType = MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN;
    this.sysId = sysId;
    this.componentId = componentId;
    length = 12;
}

  /**
   * Latitude (WGS84), in degrees * 1E7
   */
  public long latitude;
  /**
   * Longitude (WGS84), in degrees * 1E7
   */
  public long longitude;
  /**
   * Altitude (WGS84), in meters * 1000 (positive for up)
   */
  public long altitude;
/**
 * Decode message with raw data
 */
public void decode(ByteBuffer dis) throws IOException {
  latitude = (int)dis.getInt();
  longitude = (int)dis.getInt();
  altitude = (int)dis.getInt();
}
/**
 * Encode message with raw data and other informations
 */
public byte[] encode() throws IOException {
  byte[] buffer = new byte[8+12];
   ByteBuffer dos = ByteBuffer.wrap(buffer).order(ByteOrder.LITTLE_ENDIAN);
  dos.put((byte)0xFE);
  dos.put((byte)(length & 0x00FF));
  dos.put((byte)(sequence & 0x00FF));
  dos.put((byte)(sysId & 0x00FF));
  dos.put((byte)(componentId & 0x00FF));
  dos.put((byte)(messageType & 0x00FF));
  dos.putInt((int)(latitude&0x00FFFFFFFF));
  dos.putInt((int)(longitude&0x00FFFFFFFF));
  dos.putInt((int)(altitude&0x00FFFFFFFF));
  int crc = MAVLinkCRC.crc_calculate_encode(buffer, 12);
  crc = MAVLinkCRC.crc_accumulate((byte) IMAVLinkCRC.MAVLINK_MESSAGE_CRCS[messageType], crc);
  byte crcl = (byte) (crc & 0x00FF);
  byte crch = (byte) ((crc >> 8) & 0x00FF);
  buffer[18] = crcl;
  buffer[19] = crch;
  return buffer;
}
public String toString() {
return "MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN : " +   "  latitude="+latitude+  "  longitude="+longitude+  "  altitude="+altitude;}
}
```


Overlapping Code:
```
_global_origin extends MAVLinkMessage {
public static final int MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN = 49;
private static final long serialVersionUID = MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN;
public msg_gps_global_origin(int sysId, int componentId) {
messageType = MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN;
this.sysId = sysId;
this.componentId = componentId;
length = 12;
}
/**
* Latitude (WGS84), in degrees * 1E7
*/
public long latitude;
/**
* Longitude (WGS84), in degrees * 1E7
*/
public long longitude;
/**
* Altitude (WGS84), in meters * 1000 (positive for up)
*/
public long altitude;
/**
* Decode message with raw data
*/
public void decode(ByteBuffer dis) throws IOException {
latitude = (int)dis.getInt();
longitude = (int)dis.getInt();
altitude = (int)dis.getInt();
}
/**
* Encode message with raw data and other informations
*/
public byte[] encode() throws IOException {
byte[] buffer = new byte[8+12];
ByteBuffer dos = ByteBuffer.wrap(buffer).order(ByteOrder.LITTLE_ENDIAN);
dos.put((byte)0xFE);
dos.put((byte)(length & 0x00FF));
dos.put((byte)(sequence & 0x00FF));
dos.put((byte)(sysId & 0x00FF));
dos.put((byte)(componentId & 0x00FF));
dos.put((byte)(messageType & 0x00FF));
dos.putInt((int)(latitude&0x00FFFFFFFF));
dos.putInt((int)(longitude&0x00FFFFFFFF));
dos.putInt((int)(altitude&0x00FFFFFFFF));
int crc = MAVLinkCRC.crc_calculate_encode(buffer, 12);
crc = MAVLinkCRC.crc_accumulate((byte) IMAVLinkCRC.MAVLINK_MESSAGE_CRCS[messageType], crc);
byte crcl = (byte) (crc & 0x00FF);
byte crch = (byte) ((crc >> 8) & 0x00FF);
buffer[18] = crcl;
buffer[19] = crch;
return buffer;
}
public String toString() {
return "MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN : " + " latitude="+latitude+ " longitude="+longitude+
```
<Overlap Ratio: 0.9736540664375716>

---

--- 103 --
Question ID: 376b3b617019608de4787f93beb8cc2aed87fbcf
Original Code:
```
public class MailService {
	private Logger logger = LogManager.getLogger( this.getClass().getName() );
	

	public void sendUserRequest( User user ) throws Exception {
		logger.debug("new user request " + user.getFullName() );
		Properties props = new Properties();
        Session session = Session.getDefaultInstance(props, null);

        String msgBody = "A new user is requesting access to Sagitarii system.<br>";
        msgBody += "Full Name: " + user.getFullName() + "<br>";
        msgBody += "Login Name: " + user.getLoginName() + "<br>";
        msgBody += "Mail Address: " + user.getUserMail() + "<br>";

        try {
        	MimeMessage msg = new MimeMessage(session);
            msg.setFrom(new InternetAddress("sagitarii@eic.cefet-rj.br", "Sagitarii Mail Service"));
            
            UserService us = new UserService();
            List<User> users = us.getList( UserType.ADMIN );
            
            for ( User admin : users ) {
            	msg.addRecipient(Message.RecipientType.TO,
                             new InternetAddress(admin.getUserMail(), admin.getFullName() ));
            }
            
            msg.setSubject("User Access Request: "+ user.getFullName() );
            msg.setText(msgBody, "utf-8", "html");
            Transport.send(msg);

        } catch ( Exception e) {
			logger.error( e.getMessage() );
		}
	}
	

	public void notifyUserChange( User user ) throws Exception {
		logger.debug("send user change notification " + user.getFullName() );
		Properties props = new Properties();
        Session session = Session.getDefaultInstance(props, null);

        String msgBody = "An administrator updated your data.<br>";
        msgBody += "Full Name: " + user.getFullName() + "<br>";
        msgBody += "Login Name: " + user.getLoginName() + "<br>";
        msgBody += "Mail Address: " + user.getUserMail() + "<br>";
        msgBody += "Type: " + user.getType() + "<br>";

        try {
        	MimeMessage msg = new MimeMessage(session);
            msg.setFrom(new InternetAddress("sagitarii@eic.cefet-rj.br", "Sagitarii Mail Service"));
            
            UserService us = new UserService();
            List<User> users = us.getList( UserType.ADMIN );
            
            for ( User admin : users ) {
            	msg.addRecipient(Message.RecipientType.TO,
                             new InternetAddress(admin.getUserMail(), admin.getFullName() ));
            }
            
            msg.setSubject("Your user data was updated");
            msg.setText(msgBody, "utf-8", "html");
            Transport.send(msg);

        } catch ( Exception e) {
			logger.error( e.getMessage() );
		}
	}
	
	
}
```


Overlapping Code:
```
Service {
private Logger logger = LogManager.getLogger( this.getClass().getName() );

public void sendUserRequest( User user ) throws Exception {
logger.debug("new user request " + user.getFullName() );
Properties props = new Properties();
Session session = Session.getDefaultInstance(props, null);
String msgBody = "A new user is requesting access to Sagitarii system.<br>";
msgBody += "Full Name: " + user.getFullName() + "<br>";
msgBody += "Login Name: " + user.getLoginName() + "<br>";
msgBody += "Mail Address: " + user.getUserMail() + "<br>";
try {
MimeMessage msg = new MimeMessage(session);
msg.setFrom(new InternetAddress("ervice us = new UserService();
List<User> users = us.getList( UserType.ADMIN );

for ( User admin : users ) {
msg.addRecipient(Message.RecipientType.TO,
new InternetAddress(admin.getUserMail(), admin.getFullName() ));
}

msg.setSubject("User Access Request: "+ user.getFullName() );
msg.setText(msgBody, "utf-8", "html");
Transport.send(msg);
} catch ( Exception e) {
logger.error( e.getMessage() );
}
}

public void notifyUserChange( User user ) throws Exception {
logger.debug("send user change notification " + user.getFullName() );
Properties props = new Properties();
Session session = Session.getDefaultInstance(props, null);
String msgBody = "An administrator updated your data.<br>";
msgBody += "Full Name: " + user.getFullName() + "<br>";
msgBody += "Login Name: " + user.getLoginName() + "<br>";
msgBody += "Mail Address: " + user.getUserMail() + "<br>";
msgBody += "Type: " + user.getType() + "<br>";
try {
MimeMessage msg = new MimeMessage(session);
msg.setFrom(new InternetAddress("ervice us = new UserService();
List<User> users = us.getList( UserType.ADMIN );

for ( User admin : users ) {
msg.addRecipient(Message.RecipientType.TO,
new InternetAddress(admin.getUserMail(), admin.getFullName
```
<Overlap Ratio: 0.9259445843828715>

---

--- 104 --
Question ID: 14b3dffa562fe19a1449d51905880eab860b5039
Original Code:
```
public class BittrexAdaptersTest {

  @Test
  public void testAdaptOrders() {
    BittrexLevel ask1 = new BittrexLevel(new BigDecimal("10"), new BigDecimal("1"));
    BittrexLevel ask2 = new BittrexLevel(new BigDecimal("11"), new BigDecimal("2"));
    BittrexLevel ask3 = new BittrexLevel(new BigDecimal("12"), new BigDecimal("3"));

    BittrexLevel bid1 = new BittrexLevel(new BigDecimal("9"), new BigDecimal("4"));
    BittrexLevel bid2 = new BittrexLevel(new BigDecimal("8"), new BigDecimal("5"));
    BittrexLevel bid3 = new BittrexLevel(new BigDecimal("7"), new BigDecimal("6"));

    BittrexLevel[] asks = {ask1, ask2, ask3};
    BittrexLevel[] bids = {bid1, bid2, bid3};
    CurrencyPair currencyPair = CurrencyPair.ETH_BTC;
    Order.OrderType askType = Order.OrderType.ASK;
    Order.OrderType bidType = Order.OrderType.BID;
    int depth = 2;

    List<LimitOrder> expectedAsks =
        Arrays.asList(
            new LimitOrder(askType, ask1.getAmount(), currencyPair, null, null, ask1.getPrice()),
            new LimitOrder(askType, ask2.getAmount(), currencyPair, null, null, ask2.getPrice()));

    List<LimitOrder> expectedBids =
        Arrays.asList(
            new LimitOrder(bidType, bid1.getAmount(), currencyPair, null, null, bid1.getPrice()),
            new LimitOrder(bidType, bid2.getAmount(), currencyPair, null, null, bid2.getPrice()));

    List<LimitOrder> adaptedAsks = BittrexAdapters.adaptOrders(asks, currencyPair, askType, depth);
    List<LimitOrder> adaptedBids = BittrexAdapters.adaptOrders(bids, currencyPair, bidType, depth);

    Assert.assertEquals(expectedAsks, adaptedAsks);
    Assert.assertEquals(expectedBids, adaptedBids);
  }

  @Test
  public void testAdaptOrderStatus() {
    BittrexOrder orderPartiallyFilled =
        new BittrexOrder(
            null,
            null,
            null,
            null,
            new BigDecimal("10"),
            null,
            null,
            null,
            null,
            new BigDecimal("5"),
            null,
            null,
            null,
            null,
            null,
            null,
            null);
    BittrexOrder orderFilled =
        new BittrexOrder(
            null,
            null,
            null,
            null,
            new BigDecimal("10"),
            null,
            null,
            null,
            null,
            new BigDecimal("10"),
            null,
            null,
            null,
            null,
            null,
            null,
            null);
    BittrexOrder orderNew =
        new BittrexOrder(
            null,
            null,
            null,
            null,
            new BigDecimal("10"),
            null,
            null,
            null,
            null,
            new BigDecimal("0"),
            null,
            null,
            null,
            null,
            null,
            null,
            null);
    BittrexOrder orderClosed =
        new BittrexOrder(
            null,
            null,
            null,
            null,
            new BigDecimal("10"),
            null,
            null,
            null,
            null,
            new BigDecimal("0"),
            null,
            null,
            null,
            null,
            null,
            Date.from(Instant.now()),
            null);
    BittrexOrder orderUnknown =
        new BittrexOrder(
            null, null, null, null, null, null, null, null, null, null, null, null, null, null,
            null, null, null);
    Assert.assertEquals(
        Order.OrderStatus.PARTIALLY_FILLED, BittrexAdapters.adaptOrderStatus(orderPartiallyFilled));
    Assert.assertEquals(Order.OrderStatus.FILLED, BittrexAdapters.adaptOrderStatus(orderFilled));
    Assert.assertEquals(Order.OrderStatus.NEW, BittrexAdapters.adaptOrderStatus(orderNew));
    Assert.assertEquals(Order.OrderStatus.UNKNOWN, BittrexAdapters.adaptOrderStatus(orderUnknown));
    Assert.assertEquals(Order.OrderStatus.CLOSED, BittrexAdapters.adaptOrderStatus(orderClosed));
  }

  @Test
  public void testAdaptTrades() {
    CurrencyPair pair = CurrencyPair.ETH_BTC;

    BittrexTrade trade1 = new BittrexTrade();
    trade1.setExecutedAt(new Date());
    trade1.setId("123");
    trade1.setQuantity(new BigDecimal("1"));
    trade1.setRate(new BigDecimal("2"));
    trade1.setTakerSide(BittrexConstants.BUY);

    BittrexTrade trade2 = new BittrexTrade();
    trade2.setExecutedAt(new Date());
    trade2.setId("456");
    trade2.setQuantity(new BigDecimal("3"));
    trade2.setRate(new BigDecimal("4"));
    trade2.setTakerSide(BittrexConstants.SELL);

    Trade adaptedTrade1 = BittrexAdapters.adaptTrade(trade1, pair);
    Trade adaptedTrade2 = BittrexAdapters.adaptTrade(trade2, pair);

    List<BittrexTrade> bittrexTradesList = Arrays.asList(trade1, trade2);
    List<Trade> tradesList = Arrays.asList(adaptedTrade1, adaptedTrade2);

    Trades adaptedTrades = BittrexAdapters.adaptTrades(bittrexTradesList, pair);
    Trades trades =
        new Trades(
            tradesList,
            Math.max(Long.parseLong(trade1.getId()), Long.parseLong(trade2.getId())),
            Trades.TradeSortType.SortByTimestamp);
    Assert.assertEquals(trades.getNextPageCursor(), adaptedTrades.getNextPageCursor());
    Assert.assertEquals(trades.getTrades(), adaptedTrades.getTrades());
    Assert.assertEquals(trades.getTradeSortType(), adaptedTrades.getTradeSortType());
  }

  @Test
  public void testAdaptUserTrades() {
    CurrencyPair pair = CurrencyPair.ETH_BTC;

    BittrexOrder order1 = new BittrexOrder();
    order1.setType(BittrexConstants.LIMIT);
    order1.setMarketSymbol("ETH-BTC");
    order1.setClosedAt(new Date());
    order1.setId("123");
    order1.setQuantity(new BigDecimal("1"));
    order1.setFillQuantity(new BigDecimal("1"));
    order1.setLimit(new BigDecimal("2"));
    order1.setDirection(BittrexConstants.BUY);
    order1.setCommission(new BigDecimal("2"));

    BittrexOrder order2 = new BittrexOrder();
    order2.setType(BittrexConstants.MARKET);
    order2.setMarketSymbol("ETH-BTC");
    order2.setClosedAt(new Date());
    order2.setId("456");
    order2.setQuantity(new BigDecimal("3"));
    order2.setFillQuantity(new BigDecimal("1"));
    order2.setLimit(new BigDecimal("4"));
    order2.setDirection(BittrexConstants.SELL);
    order2.setCommission(new BigDecimal("4"));

    List<UserTrade> tradesList = BittrexAdapters.adaptUserTrades(Arrays.asList(order1, order2));

    Assert.assertEquals(2, tradesList.size());

    UserTrade trade1 = tradesList.get(0);
    Assert.assertEquals(Order.OrderType.BID, trade1.getType());
    Assert.assertEquals(order1.getFillQuantity(), trade1.getOriginalAmount());
    Assert.assertEquals(pair, trade1.getInstrument());
    Assert.assertEquals(order1.getLimit(), trade1.getPrice());
    Assert.assertEquals(order1.getClosedAt(), trade1.getTimestamp());
    Assert.assertEquals(order1.getId(), trade1.getId());
    Assert.assertEquals(order1.getCommission(), trade1.getFeeAmount());
    Assert.assertEquals(pair.counter, trade1.getFeeCurrency());

    UserTrade trade2 = tradesList.get(1);
    Assert.assertEquals(Order.OrderType.ASK, trade2.getType());
    Assert.assertEquals(order2.getFillQuantity(), trade2.getOriginalAmount());
    Assert.assertEquals(pair, trade2.getInstrument());
    Assert.assertEquals(order2.getLimit(), trade2.getPrice());
    Assert.assertEquals(order2.getClosedAt(), trade2.getTimestamp());
    Assert.assertEquals(order2.getId(), trade2.getId());
    Assert.assertEquals(order2.getCommission(), trade2.getFeeAmount());
    Assert.assertEquals(pair.counter, trade2.getFeeCurrency());
  }
}
```


Overlapping Code:
```
lass BittrexAdaptersTest {
@Test
public void testAdaptOrders() {
BittrexLevel ask1 = new BittrexLevel(new BigDecimal("10"), new BigDecimal("1"));
BittrexLevel ask2 = new BittrexLevel(new BigDecimal("11"), new BigDecimal("2"));
BittrexLevel ask3 = new BittrexLevel(new BigDecimal("12"), new BigDecimal("3"));
BittrexLevel bid1 = new BittrexLevel(new BigDecimal("9"), new BigDecimal("4"));
BittrexLevel bid2 = new BittrexLevel(new BigDecimal("8"), new BigDecimal("5"));
BittrexLevel bid3 = new BittrexLevel(new BigDecimal("7"), new BigDecimal("6"));
BittrexLevel[] asks = {ask1, ask2, ask3};
BittrexLevel[] bids = {bid1, bid2, bid3};
CurrencyPair currencyPair = CurrencyPair.ETH_BTC;
Order.OrderType askType = Order.OrderType.ASK;
Order.OrderType bidType = Order.OrderType.BID;
int depth = 2;
List<LimitOrder> expectedAsks =
Arrays.asList(
new LimitOrder(askType, ask1.getAmount(), currencyPair, null, null, ask1.getPrice()),
new LimitOrder(askType, ask2.getAmount(), currencyPair, null, null, ask2.getPrice()));
List<LimitOrder> expectedBids =
Arrays.asList(
new LimitOrder(bidType, bid1.getAmount(), currencyPair, null, null, bid1.getPrice()),
new LimitOrder(bidType, bid2.getAmount(), currencyPair, null, null, bid2.getPrice()));
List<LimitOrder> adaptedAsks = BittrexAdapters.adaptOrders(asks, currencyPair, askType, depth);
List<LimitOrder> adaptedBids = BittrexAdapters.adaptOrders(bids, currencyPair, bidType, depth);
Assert.assertEquals(expectedAsks, adaptedAsks);
Assert.assertEquals(expectedBids, adaptedBids);
}
@Test
public void testAdaptOrderStatus() {
BittrexOrder orderPartiallyFilled =
new BittrexOrder(
null,
null,
null,
null,
new BigDecimal("10"),
null,
null,
null,
null,
new BigDecimal("5"),
null,
null,
null,
null,
null,
null,
null);
BittrexOrder orderFilled =
new BittrexOrder(
null,
null,
null,
null,
new BigDecimal("10"),
null,
null,
null,
null,
new BigDecimal("10"),
null,
null,
null,
null,
n
```
<Overlap Ratio: 0.9937694704049844>

---

--- 105 --
Question ID: 7d727698b89db5be38abe39efcac6f6e6a7eef7f
Original Code:
```
public class Review implements Parcelable{
    private String author;
    private String content;
    private String reivew_url;

    public Review(String author, String content, String reivew_url) {
        this.author = author;
        this.content = content;
        this.reivew_url = reivew_url;
    }

    public String getAuthor() {
        return author;
    }

    public String getContent() {
        return content;
    }

    public String getReivew_url() {
        return reivew_url;
    }

    protected Review(Parcel in) {
        author = in.readString();
        content = in.readString();
        reivew_url = in.readString();
    }

    public static final Creator<Review> CREATOR = new Creator<Review>() {
        @Override
        public Review createFromParcel(Parcel in) {
            return new Review(in);
        }

        @Override
        public Review[] newArray(int size) {
            return new Review[size];
        }
    };

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel parcel, int i) {
        parcel.writeString(author);
        parcel.writeString(content);
        parcel.writeString(reivew_url);
    }
}
```


Overlapping Code:
```
iew implements Parcelable{
private String author;
private String content;
private String reivew_url;
public Review(String author, String content, String reivew_url) {
this.author = author;
this.content = content;
this.reivew_url = reivew_url;
}
public String getAuthor() {
return author;
}
public String getContent() {
return content;
}
public String getReivew_url() {
return reivew_url;
}
protected Review(Parcel in) {
author = in.readString();
content = in.readString();
reivew_url = in.readString();
}
public static final Creator<Review> CREATOR = new Creator<Review>() {
@Override
public Review createFromParcel(Parcel in) {
return new Review(in);
}
@Override
public Review[] newArray(int size) {
return new Review[size];
}
};
@Override
public int describeContents() {
return 0;
}
@Override
public void writeToParcel(Parcel parcel, int i) {
parcel.writeString(author);
parcel.writeString(content);
parcel.writeString(reivew_u
```
<Overlap Ratio: 0.974816369359916>

---

--- 106 --
Question ID: c52341221e01d311fed1c6c693084960d0ac9299
Original Code:
```
@WebAppConfiguration
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = TestConfig.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class DifferentialAnalyticsSearchServiceIT {
    private static final SemanticQuery EMPTY_QUERY = SemanticQuery.create();

    @Inject
    private DataSource dataSource;

    @Inject
    private SpeciesFactory speciesFactory;

    @Inject
    private DifferentialAnalyticsSearchService subject;

    private SemanticQuery query = SemanticQuery.create("zinc finger");
    private SemanticQuery condition = SemanticQuery.create("watering");
    private String species = "oryza sativa";

    @BeforeAll
    void populateDatabaseTables() {
        ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
        populator.addScripts(new ClassPathResource("fixtures/experiment-fixture.sql"));
        populator.execute(dataSource);
    }

    @AfterAll
    void cleanDatabaseTables() {
        ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
        populator.addScripts(new ClassPathResource("fixtures/experiment-delete.sql"));
        populator.execute(dataSource);
    }

    @Test
    void fetchDifferentialFacetsForSearch() {
        JsonObject result = subject.fetchFacets(query, EMPTY_QUERY);
        assertAboutFacets(result);
    }

    @Test
    void fetchDifferentialResultsForSearch() {
        JsonObject result = subject.fetchResults(query, EMPTY_QUERY);
        assertAboutResults(result);
    }

    @Test
    void fetchDifferentialFacetsForQuery1() {
        JsonObject result = subject.fetchFacets(query, EMPTY_QUERY);
        assertAboutFacets(result);
    }

    @Test
    void fetchDifferentialFacetsForQuery3() {
        JsonObject result = subject.fetchFacets(query, condition, speciesFactory.create(species));
        assertAboutFacets(result);
    }

    @Test
    void fetchDifferentialResultsForQuery1() {
        JsonObject result = subject.fetchResults(query, EMPTY_QUERY);
        assertAboutResults(result);
    }
    @Test
    void fetchDifferentialResultsForQuery() {
        JsonObject result = subject.fetchResults(query, condition, speciesFactory.create(species));
        assertAboutResults(result);
    }

    private void assertAboutFacets(JsonObject result) {
        assertThat(result.entrySet().size(), greaterThan(0));
        for (Map.Entry<String, ?> e: result.entrySet()) {
            assertThat(e.getKey(),
                    isOneOf("kingdom", "species", "experimentType", "factors", "numReplicates", "regulation"));
        }
    }

    private void assertAboutResults(JsonObject result) {
        assertTrue(result.has("results"));
        assertThat(result.get("results").getAsJsonArray().size(), greaterThan(0));
        for (JsonElement e: result.get("results").getAsJsonArray()) {
            assertTrue(e.getAsJsonObject().has("bioentityIdentifier"));
            assertTrue(e.getAsJsonObject().has("bioentityName"));
            assertTrue(e.getAsJsonObject().has("experimentAccession"));
            assertTrue(e.getAsJsonObject().has("experimentType"));
            assertTrue(e.getAsJsonObject().has("contrastId"));
            assertTrue(e.getAsJsonObject().has("foldChange"));
            assertTrue(e.getAsJsonObject().has("comparison"));
            assertTrue(e.getAsJsonObject().has("experimentName"));
        }
    }
}
```


Overlapping Code:
```
@WebAppConfiguration
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = TestConfig.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class DifferentialAnalyticsSearchServiceIT {
private static final SemanticQuery EMPTY_QUERY = SemanticQuery.create();
@Inject
private DataSource dataSource;
@Inject
private SpeciesFactory speciesFactory;
@Inject
private DifferentialAnalyticsSearchService subject;
private SemanticQuery query = SemanticQuery.create("zinc finger");
private SemanticQuery condition = SemanticQuery.create("watering");
private String species = "oryza sativa";
@BeforeAll
void populateDatabaseTables() {
ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
populator.addScripts(new ClassPathResource("fixtures/experiment-fixture.sql"));
populator.execute(dataSource);
}
@AfterAll
void cleanDatabaseTables() {
ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
populator.addScripts(new ClassPathResource("fixtures/experiment-delete.sql"));
populator.execute(dataSource);
}
@Test
void fetchDifferentialFacetsForSearch() {
JsonObject result = subject.fetchFacets(query, EMPTY_QUERY);
assertAboutFacets(result);
}
@Test
void fetchDifferentialResultsForSearch() {
JsonObject result = subject.fetchResults(query, EMPTY_QUERY);
assertAboutResults(result);
}
@Test
void fetchDifferentialFacetsForQuery1() {
JsonObject result = subject.fetchFacets(query, EMPTY_QUERY);
assertAboutFacets(result);
}
@Test
void fetchDifferentialFacetsForQuery3() {
JsonObject result = subject.fetchFacets(query, condition, speciesFactory.create(species));
assertAboutFacets(result);
}
@Test
void fetchDifferentialResultsForQuery1() {
JsonObject result = subject.fetchResults(query, EMPTY_QUERY);
assertAboutResults(result);
}
@Test
void fetchDifferentialResultsForQuery() {
JsonObject result = subject.fetchResults(query, condition, speciesFactory.create(species));
assertAboutResults(result);
}
private void assertAboutFacets(JsonObject result) {
assertThat(result.entrySet().size(), greaterThan(0));
for (Map.Entry<String, ?> e: result.entrySet()) {
assertThat(e.getKey(),
isOneOf("kingdom", "spe
```
<Overlap Ratio: 0.9935034802784223>

---

--- 107 --
Question ID: 7c58a78c593c9765dd580328aa7d10c9efe5284e
Original Code:
```
public class ModuleManager {

    private static final Logger logger = LogsCenter.getLogger(ModuleManager.class);

    private static ModuleManager instance;

    private ArrayList<Module> modules;

    private ModuleManager() {
        modules = new ArrayList<>();
        readModuleList();
    }

    public static ModuleManager getInstance() {
        if (instance == null) {
            instance = new ModuleManager();
        }
        return instance;
    }

    /**
     * Adds a new module to the in-memory array list
     */
    public void addModule(Module module) throws DuplicateModuleException {
        if (doesModuleExist(module)) {
            throw new DuplicateModuleException();
        }
        modules.add(module);
    }

    /**
     * Replaces the given module {@code target} with {@code editedModule}
     * {@code target} must already exist in Trajectory
     */
    public void updateModule(Module target, Module editedModule) {
        requireAllNonNull(target, editedModule);

        int targetIndex = modules.indexOf(target);

        modules.set(targetIndex, editedModule);
    }

    /**
     * Deletes a module from Trajectory. This method will also handle the deletion of the other components that
     * rely on {@code Module}.
     */
    public void deleteModule(Module toDelete) {
        modules.remove(toDelete);
        ClassroomManager.getInstance().handleModuleDeletedByModuleCode(toDelete.getModuleCode().moduleCode);
    }

    public void enrolStudentInModule(Module module, Person student) {
        module.addStudent(student);
    }

    public void removeStudentFromModule(Module module, Person student) {
        module.removeStudent(student);
    }

    public boolean isStudentEnrolledInModule(Module module, Person student) {
        return module.getEnrolledStudents().stream().anyMatch(s -> s.equals(student));
    }

    /**
     * Overload for {@link #isStudentEnrolledInModule(Module, Person)} to accept {@code String} inputs.
     * The module code and matric no. must be validated before calling this method, otherwise
     * there is a risk of a {@code NullPointerException} being thrown.
     */
    public boolean isStudentEnrolledInModule(String moduleCode, String matricNo) {
        Module module = getModuleByModuleCode(moduleCode);
        Person student = StudentManager.getInstance().retrieveStudentByMatricNo(matricNo);
        return isStudentEnrolledInModule(module, student);
    }

    /**
     * Removes a deleted student from the modules that student was previously enrolled in.
     */
    public void handleStudentDeleted(Person student) {
        for (Module module : modules) {
            if (isStudentEnrolledInModule(module, student)) {
                removeStudentFromModule(module, student);
            }
        }
    }

    /**
     * Gets the module list from storage and converts it to a Module array list.
     * Also reads the association data between Student and Module and stores it in-memory in the module.
     */
    private void readModuleList() {
        ArrayList<XmlAdaptedModule> xmlModuleList = StorageController.getModuleStorage();
        ArrayList<XmlAdaptedStudentModule> xmlAdaptedStudentModuleList = StorageController.getStudentModuleStorage();
        try {
            for (XmlAdaptedModule xmlModule : xmlModuleList) {
                Module m = xmlModule.toModelType();
                modules.add(m);

                // Look for associations between this module and any students (i.e. any enrolled students?)
                for (XmlAdaptedStudentModule xmlStudentModule : xmlAdaptedStudentModuleList) {
                    if (xmlStudentModule.getModuleCode().equals(m.getModuleCode().moduleCode)) {
                        Person student = StudentManager.getInstance()
                                .retrieveStudentByMatricNo(xmlStudentModule.getStudentMatricNo());

                        m.addStudent(student);
                    }
                }
            }
        } catch (NullPointerException npe) {
            logger.info("Illegal values found when reading enrolled students: " + npe.getMessage());
        } catch (IllegalValueException ive) {
            logger.info("Illegal values found when reading module list: " + ive.getMessage());
        }
    }

    /**
     * Converts the Module array list and invokes the StorageController to save the current module list to file.
     * Also passes info on the association between Student and Module to be saved to file.
     */
    public void saveModuleList() {
        ArrayList<XmlAdaptedModule> xmlAdaptedModules =
                modules.stream().map(XmlAdaptedModule::new).collect(Collectors.toCollection(ArrayList::new));
        StorageController.setModuleStorage(xmlAdaptedModules);

        ArrayList<XmlAdaptedStudentModule> xmlAdaptedStudentModuleList = new ArrayList<>();
        for (Module m : modules) {
            xmlAdaptedStudentModuleList.addAll(
                    m.getEnrolledStudents()
                            .stream()
                            .map(s -> new XmlAdaptedStudentModule(
                                    s.getMatricNo().matricNo, m.getModuleCode().moduleCode))
                            .collect(Collectors.toCollection(ArrayList::new))
            );
        }
        StorageController.setStudentModuleStorage(xmlAdaptedStudentModuleList);

        StorageController.storeData();
    }

    /**
     * Searches the list of modules for module codes and/or names that match any of the keywords.
     * @return List of modules that match at least one keyword.
     */
    public List<Module> searchModulesWithKeywords(List<String> keywords) {
        return modules.stream()
                .filter(module ->
                        keywords.stream().anyMatch(keyword ->
                                StringUtil.containsWordIgnoreCase(module.getModuleCode().moduleCode, keyword)
                                || StringUtil.containsWordIgnoreCase(module.getModuleName().moduleName, keyword)))
                .collect(Collectors.toList());
    }

    /**
     * Searches the list of modules to find a module that matches the {@code moduleCode}
     * @param moduleCode The target module's code to find
     * @return The module object that matches the module code, or {@code null} if there isn't a matching module
     */
    public Module getModuleByModuleCode(String moduleCode) {
        return this.modules.stream()
                .filter(module -> module.getModuleCode().moduleCode.equals(moduleCode))
                .findAny()
                .orElse(null);
    }

    /**
     * Checks if the input module already exists in Trajectory.
     * @param module The module whose existence needs to be checked.
     * @return True if the module exists; false otherwise.
     */
    public boolean doesModuleExist(Module module) {
        return this.modules.stream().anyMatch(m -> m.isSameModule(module));
    }

    /**
     * Checks if the input module code matches a module that exists in Trajectory.
     * This is an overload to make it easier to check a module's existence without
     * creating a whole {@oode Module} object.
     * This overload adheres to the DRY principle by invoking the original
     * {@link #doesModuleExist(Module)} mathod.
     * @param moduleCode The module code that will be used to check for the module's existence.
     * @return True if the module exists; false otherwise.
     */
    public boolean doesModuleExist(String moduleCode) {
        Module module = getModuleByModuleCode(moduleCode);
        if (module != null) {
            return doesModuleExist(module);
        }
        return false;
    }

    /**
     * Converts the given list of modules to a HTML table representation.
     * @param moduleList
     * @return
     */
    public String convertModulesToTableRepresentation(List<Module> moduleList) {
        moduleList.sort(Comparator.comparing(m -> m.getModuleCode().toString()));

        StringBuilder sb = new StringBuilder();

        sb.append(HtmlTableProcessor.getBanner("Module List"));
        sb.append(HtmlTableProcessor.renderTableStart(new ArrayList<>(
                Arrays.asList("Module Code", "Module Name"))));

        sb.append(HtmlTableProcessor.getTableItemStart());
        for (Module m : moduleList) {
            ArrayList<String> dataRow = new ArrayList<>(Arrays.asList(
                    m.getModuleCode().toString(),
                    m.getModuleName().toString()
            ));

            sb.append(HtmlTableProcessor.renderTableItem(dataRow));
        }
        sb.append(HtmlTableProcessor.getTableItemEnd());

        return sb.toString();
    }

    /**
     * Converts the list of modules into a HTML table representation.
     * Internally calls {@link #convertModulesToTableRepresentation(List)} to generate the HTML string
     * to enforce DRY.
     * @return
     */
    public String getModuleTableRepresentation() {
        return convertModulesToTableRepresentation(modules);
    }

    /**
     * Converts the given module into a HTML String for display in the {@code BrowserPanel}
     */
    public String getModuleAsHtmlRepresentation(Module module) {
        final String listItemFormat = "%1$s (%2$s)";
        StringBuilder sb = new StringBuilder();
        StringBuilder studentEntries = new StringBuilder();

        // Sort the students by name in alphabetical order
        List<Person> enrolledStudents = new ArrayList<>(module.getEnrolledStudents());
        enrolledStudents.sort(Comparator.comparing(s -> s.getName().fullName));

        if (module.getEnrolledStudents().isEmpty()) {
            studentEntries.append("There are no students enrolled in this module.");
        } else {
            studentEntries.append(HtmlProcessor.getOrderedListStart());
            for (Person s : enrolledStudents) {
                studentEntries.append(HtmlProcessor.getListItem(
                        String.format(listItemFormat, s.getName().toString(), s.getMatricNo())
                ));
            }
            studentEntries.append(HtmlProcessor.getOrderedListEnd());
        }

        List<AbstractMap.SimpleEntry<String, String>> details = new ArrayList<>();
        details.add(new AbstractMap.SimpleEntry<>("Module Code: ", module.getModuleCode().toString()));
        details.add(new AbstractMap.SimpleEntry<>("Module Name: ", module.getModuleName().toString()));
        details.add(new AbstractMap.SimpleEntry<>("Enrolled Students: ", studentEntries.toString()));

        sb.append(HtmlProcessor.constructDetailedView(details));

        return sb.toString();
    }

    public void clearModules() {
        modules = new ArrayList<>();
    }

    public ArrayList<Module> getModules() {
        return this.modules;
    }
}
```


Overlapping Code:
```
public class ModuleManager {
private static final Logger logger = LogsCenter.getLogger(ModuleManager.class);
private static ModuleManager instance;
private ArrayList<Module> modules;
private ModuleManager() {
modules = new ArrayList<>();
readModuleList();
}
public static ModuleManager getInstance() {
if (instance == null) {
instance = new ModuleManager();
}
return instance;
}
/**
* Adds a new module to the in-memory array list
*/
public void addModule(Module module) throws DuplicateModuleException {
if (doesModuleExist(module)) {
throw new DuplicateModuleException();
}
modules.add(module);
}
/**
* Replaces the given module {@code target} with {@code editedModule}
* {@code target} must already exist in Trajectory
*/
public void updateModule(Module target, Module editedModule) {
requireAllNonNull(target, editedModule);
int targetIndex = modules.indexOf(target);
modules.set(targetIndex, editedModule);
}
/**
* Deletes a module from Trajectory. This method will also handle the deletion of the other components that
* rely on {@code Module}.
*/
public void deleteModule(Module toDelete) {
modules.remove(toDelete);
ClassroomManager.getInstance().handleModuleDeletedByModuleCode(toDelete.getModuleCode().moduleCode);
}
public void enrolStudentInModule(Module module, Person student) {
module.addStudent(student);
}
public void removeStudentFromModule(Module module, Person student) {
module.removeStudent(student);
}
public boolean isStudentEnrolledInModule(Module module, Person student) {
return module.getEnrolledStudents().stream().anyMatch(s -> s.equals(student));
}
/**
* Overload for {@link #isStudentEnrolledInModule(Module, Person)} to accept {@code String} inputs.
* The module code and matric no. must be validated before calling this method, otherwise
* there is a risk of a {@code NullPointerException} being thrown.
*/
public boolean isStudentEnrolledInModule(String moduleCode, String matricNo) {
Module module = getModuleByModuleCode(moduleCode);
Person student = StudentManager.getInstance().retrieveStudentByMatricNo(matricNo);
return isStudentEnrolledInModule(mod
```
<Overlap Ratio: 0.9775491113189897>

---

--- 108 --
Question ID: 613915c52c2920581d0460770d1aea3fd9280ee1
Original Code:
```
public class LocationListener  implements android.location.LocationListener{

    private LocationManager mLocationManager = null;
    public static final int LOCATION_INTERVAL = 1000;
    public static final float LOCATION_DISTANCE = 10f;
    private Location mLastLocation;
    private static final String TAG = "LocationListener";
    public static  final String ShareKeyLongitude = "Longitude";
    public static  final String ShareKeyLatitude= "Latitude";
    Context context;

    public LocationListener(String provider, Context context) {
        Log.e(TAG, "LocationListener s" + provider);
        mLastLocation = new Location(provider);
        this.context = context;
    }

    @Override
    public void onLocationChanged(Location location) {
        Log.e(TAG, "onLocationChanged: " + location);
        mLastLocation.set(location);

        Log.e(TAG, "onLocationChanged: " + location);
        mLastLocation.set(location);
        double longitude = location.getLongitude();
        double latitude = location.getLatitude();
        Log.e(TAG, "Longitude: " + longitude);
        Log.e(TAG, "latitude: " + latitude);


    //    Toast.makeText(context,longitude + "/ "+ latitude + " ",Toast.LENGTH_LONG).show();
    }

    @Override
    public void onStatusChanged(String provider, int status, Bundle extras) {
        Log.e(TAG, "onStatusChanged: " + provider);
    }

    @Override
    public void onProviderEnabled(String provider) {
        Log.e(TAG, "onProviderEnabled: " + provider);
    }

    @Override
    public void onProviderDisabled(String provider) {
        Log.e(TAG, "onProviderDisabled: " + provider);
        Toast.makeText(context,"GPS is de",Toast.LENGTH_LONG).show();

    }
}
```


Overlapping Code:
```
public class LocationListener implements android.location.LocationListener{
private LocationManager mLocationManager = null;
public static final int LOCATION_INTERVAL = 1000;
public static final float LOCATION_DISTANCE = 10f;
private Location mLastLocation;
private static final String TAG = "LocationListener";
public static final String ShareKeyLongitude = "Longitude";
public static final String ShareKeyLatitude= "Latitude";
Context context;
public LocationListener(String provider, Context context) {
Log.e(TAG, "LocationListener s" + provider);
mLastLocation = new Location(provider);
this.context = context;
}
@Override
public void onLocationChanged(Location location) {
Log.e(TAG, "onLocationChanged: " + location);
mLastLocation.set(location);
Log.e(TAG, "onLocationChanged: " + location);
mLastLocation.set(location);
double longitude = location.getLongitude();
double latitude = location.getLatitude();
Log.e(TAG, "Longitude: " + longitude);
Log.e(TAG, "latitude: " + latitude);
// Toast.makeText(context,longitude + "/ "+ latitude + " ",Toast.LENGTH_LONG).show();
}
@Override
public void onStatusChanged(String provider, int status, Bundle extras) {
Log.e(TAG, "onStatusChanged: " + provider);
}
@Override
public void onProviderEnabled(String provider) {
Log.e(TAG, "onProviderEnabled: " + provider);
}
@Override
public void onProviderDisabled(String provider) {
Log.e(TAG, "onProviderDisabled: " + provider);
Toast.makeText(context,"GPS
```
<Overlap Ratio: 0.9744451916610626>

---

--- 109 --
Question ID: add96ab720577cacf59b9a069aaabd5e041415b4
Original Code:
```
public class UtilsPreferences {

    private static final String TOKEN = "token";
    private static final String USUARIO = "usuario";
    private static final String LOGIN = "login";
    private static final String LOGIN_TIME = "loginTime";
    private static final String CONFIG = "config";
    private static final String COBRADO = "cobrado";
    private static final String MACIMPRESORA = "macImpresora";

    private static Calendar cal;

    private static Context mContext;

    private static Calendar getCalendar() {
        if (cal == null) {
            cal = new GregorianCalendar();
        }
        return cal;
    }

    public static void setContext(final Context context) {
        mContext = context;
    }

    public static void saveToken(final String token) {
        SharedPreferences settings = mContext.getSharedPreferences(TOKEN, 0);
        SharedPreferences.Editor editor = settings.edit();
        editor.putString(TOKEN, token);
        editor.commit();
    }

    public static String loadToken() {
        SharedPreferences settings = mContext.getSharedPreferences(TOKEN, 0);
        return settings.getString(TOKEN, "");
    }

    public static void saveLogedUser(Usuario usuario) {
        SharedPreferences settings = mContext.getSharedPreferences(USUARIO, 0);
        SharedPreferences.Editor editor = settings.edit();
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            editor.putString(USUARIO, objectMapper.writeValueAsString(usuario));
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        editor.commit();
    }

    public static Usuario loadLogedUser() {
        SharedPreferences settings = mContext.getSharedPreferences(USUARIO, 0);
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            return objectMapper.readValue(settings.getString(USUARIO, ""), Usuario.class);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static void saveLogin(Login.Request request) {
        SharedPreferences settings = mContext.getSharedPreferences(LOGIN, 0);
        SharedPreferences.Editor editor = settings.edit();
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            editor.putString(LOGIN, objectMapper.writeValueAsString(request));
            editor.putLong(LOGIN_TIME, System.currentTimeMillis());
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        editor.commit();
    }

    public static Login.Request loadLogin() {
        SharedPreferences settings = mContext.getSharedPreferences(LOGIN, 0);
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            Login.Request req = objectMapper.readValue(settings.getString(LOGIN, ""), Login.Request.class);
            long lastLoginTime = settings.getLong(LOGIN_TIME, 0);
            long actualTime = System.currentTimeMillis();
            if ((actualTime - lastLoginTime) > (1000 * 60 * 60)){ // si ya paso una hora, regresar null
                return null;
            }else{
                return req;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static void saveConfigs(Config config) {
        SharedPreferences settings = mContext.getSharedPreferences(CONFIG, 0);
        SharedPreferences.Editor editor = settings.edit();
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            editor.putString(CONFIG, objectMapper.writeValueAsString(config));
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        editor.commit();
    }

    public static Config loadConfig() {
        SharedPreferences settings = mContext.getSharedPreferences(CONFIG, 0);
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            return objectMapper.readValue(settings.getString(CONFIG, ""), Config.class);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * almacena un prestamo como cobrado el dia actual
     *
     * @param id identificador del prestamo cobrado
     */
    public static void setPrestamoCobradoHoy(int id) {
        //cobrado.{dia del año}
        String key = COBRADO + "." + getCalendar().get(Calendar.DAY_OF_YEAR);
        SharedPreferences settings = mContext.getSharedPreferences(key, 0);

        String prestamosCobrados = settings.getString(key, "");
        if (prestamosCobrados == "") {
            prestamosCobrados += String.valueOf(id);
        } else {
            prestamosCobrados += "," + id;
        }
        SharedPreferences.Editor editor = settings.edit();
        editor.putString(key, prestamosCobrados);
        editor.commit();
    }

    /**
     * consulta si un prestmo fue cobrado ya el dia de hoy o no
     *
     * @param id identificador del prestamo
     * @return true si el prestamo fue cobrado, false si el prestamo fue cobrado
     */
    public static boolean prestamoCobradoHoy(Integer id) {
        //cobrado.{dia del año}
        String key = COBRADO + "." + getCalendar().get(Calendar.DAY_OF_YEAR);
        SharedPreferences settings = mContext.getSharedPreferences(key, 0);
        String prestamosCobrados = settings.getString(key, "");
        return prestamosCobrados.contains(String.valueOf(id));
    }

    /**
     * consulta los prestmos que fueron cobrados hoy, separados por comas
     *
     * @return string con los ids de los prestmaos separados por comas ej: "1,65,35,15"
     */
    public static String prestmosCobradosHoy() {
        String key = COBRADO + "." + getCalendar().get(Calendar.DAY_OF_YEAR);
        SharedPreferences settings = mContext.getSharedPreferences(key, 0);
        return settings.getString(key, "");
    }


    /**
     * Metodo para guardar en preferencias la mac address de la impresora seleccionada para poder
     * imprimir los tickets.
     *
     * @param macAddress
     */
    public static void saveMacPrinter(String macAddress) {
        SharedPreferences settings = mContext.getSharedPreferences(MACIMPRESORA, 0);
        SharedPreferences.Editor editor = settings.edit();
        try {
            editor.putString(MACIMPRESORA, macAddress);
            editor.commit();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Metodo para consultar la mac address guardada anteriormente para la impresion del ticket.
     *
     * @return
     */
    public static String loadMacPrinter() {
        SharedPreferences settings = mContext.getSharedPreferences(MACIMPRESORA, 0);
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            return settings.getString(MACIMPRESORA, "");
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
```


Overlapping Code:
```
 {
private static final String TOKEN = "token";
private static final String USUARIO = "usuario";
private static final String LOGIN = "login";
private static final String LOGIN_TIME = "loginTime";
private static final String CONFIG = "config";
private static final String COBRADO = "cobrado";
private static final String MACIMPRESORA = "macImpresora";
private static Calendar cal;
private static Context mContext;
private static Calendar getCalendar() {
if (cal == null) {
cal = new GregorianCalendar();
}
return cal;
}
public static void setContext(final Context context) {
mContext = context;
}
public static void saveToken(final String token) {
SharedPreferences settings = mContext.getSharedPreferences(TOKEN, 0);
SharedPreferences.Editor editor = settings.edit();
editor.putString(TOKEN, token);
editor.commit();
}
public static String loadToken() {
SharedPreferences settings = mContext.getSharedPreferences(TOKEN, 0);
return settings.getString(TOKEN, "");
}
public static void saveLogedUser(Usuario usuario) {
SharedPreferences settings = mContext.getSharedPreferences(USUARIO, 0);
SharedPreferences.Editor editor = settings.edit();
ObjectMapper objectMapper = new ObjectMapper();
try {
editor.putString(USUARIO, objectMapper.writeValueAsString(usuario));
} catch (JsonProcessingException e) {
e.printStackTrace();
}
editor.commit();
}
public static Usuario loadLogedUser() {
SharedPreferences settings = mContext.getSharedPreferences(USUARIO, 0);
ObjectMapper objectMapper = new ObjectMapper();
try {
return objectMapper.readValue(settings.getString(USUARIO, ""), Usuario.class);
} catch (IOException e) {
e.printStackTrace();
}
return null;
}
public static void saveLogin(Login.Request request) {
SharedPreferences settings = mContext.getSharedPreferences(LOGIN, 0);
SharedPreferences.Editor editor = settings.edit();
ObjectMapper objectMapper = new ObjectMapper();
try {
editor.putString(LOGIN, objectMapper.writeValueAsString(request));
editor.putLong(LOGIN_TIME, System.currentTimeMillis());
} catch (JsonProcessingException e) {
e.printStac
```
<Overlap Ratio: 0.9860643921191735>

---

--- 110 --
Question ID: 00a232d9fd27d4eaad8be822976f3b8122583428
Original Code:
```
public class SocketOptionTests {

    static <T> void checkOption(DatagramChannel dc,
                                SocketOption<T> name,
                                T expectedValue)
        throws IOException
    {
        T value = dc.getOption(name);
        if (!value.equals(expectedValue))
            throw new RuntimeException("value not as expected");
    }

    public static void main(String[] args) throws IOException {
        DatagramChannel dc = DatagramChannel.open();

        // check supported options
        Set<SocketOption<?>> options = dc.supportedOptions();
        boolean reuseport = options.contains(SO_REUSEPORT);
        List<? extends SocketOption<?>> expected;
        if (reuseport) {
           expected = Arrays.asList(SO_SNDBUF, SO_RCVBUF,
                      SO_REUSEADDR, SO_REUSEPORT, SO_BROADCAST, IP_TOS, IP_MULTICAST_IF,
                      IP_MULTICAST_TTL, IP_MULTICAST_LOOP);
        } else {
           expected = Arrays.asList(SO_SNDBUF, SO_RCVBUF,
                      SO_REUSEADDR, SO_BROADCAST, IP_TOS, IP_MULTICAST_IF, IP_MULTICAST_TTL,
                      IP_MULTICAST_LOOP);
        }
        for (SocketOption opt: expected) {
            if (!options.contains(opt))
                throw new RuntimeException(opt.name() + " should be supported");
        }

        // check specified defaults
        checkOption(dc, SO_BROADCAST, false);
        checkOption(dc, IP_MULTICAST_TTL, 1);           // true on supported platforms
        checkOption(dc, IP_MULTICAST_LOOP, true);       // true on supported platforms

        // allowed to change when not bound
        dc.setOption(SO_BROADCAST, true);
        checkOption(dc, SO_BROADCAST, true);
        dc.setOption(SO_BROADCAST, false);
        checkOption(dc, SO_BROADCAST, false);
        dc.setOption(SO_SNDBUF, 128*1024);       // can't check
        dc.setOption(SO_RCVBUF, 128*1024);       // can't check
        int before, after;
        before = dc.getOption(SO_SNDBUF);
        after = dc.setOption(SO_SNDBUF, Integer.MAX_VALUE).getOption(SO_SNDBUF);
        if (after < before)
            throw new RuntimeException("setOption caused SO_SNDBUF to decrease");
        before = dc.getOption(SO_RCVBUF);
        after = dc.setOption(SO_RCVBUF, Integer.MAX_VALUE).getOption(SO_RCVBUF);
        if (after < before)
            throw new RuntimeException("setOption caused SO_RCVBUF to decrease");
        dc.setOption(SO_REUSEADDR, true);
        checkOption(dc, SO_REUSEADDR, true);
        dc.setOption(SO_REUSEADDR, false);
        checkOption(dc, SO_REUSEADDR, false);
        if (reuseport) {
            dc.setOption(SO_REUSEPORT, true);
            checkOption(dc, SO_REUSEPORT, true);
            dc.setOption(SO_REUSEPORT, false);
            checkOption(dc, SO_REUSEPORT, false);
        }
        // bind socket
        dc.bind(new InetSocketAddress(0));

        // allow to change when bound
        dc.setOption(SO_BROADCAST, true);
        checkOption(dc, SO_BROADCAST, true);
        dc.setOption(SO_BROADCAST, false);
        checkOption(dc, SO_BROADCAST, false);
        dc.setOption(IP_TOS, 0x08);     // can't check
        dc.setOption(IP_MULTICAST_TTL, 2);
        checkOption(dc, IP_MULTICAST_TTL, 2);
        dc.setOption(IP_MULTICAST_LOOP, false);
        checkOption(dc, IP_MULTICAST_LOOP, false);
        dc.setOption(IP_MULTICAST_LOOP, true);
        checkOption(dc, IP_MULTICAST_LOOP, true);


        // NullPointerException
        try {
            dc.setOption(null, "value");
            throw new RuntimeException("NullPointerException not thrown");
        } catch (NullPointerException x) {
        }
        try {
            dc.getOption(null);
            throw new RuntimeException("NullPointerException not thrown");
        } catch (NullPointerException x) {
        }

        // ClosedChannelException
        dc.close();
        try {
            dc.setOption(IP_MULTICAST_LOOP, true);
            throw new RuntimeException("ClosedChannelException not thrown");
        } catch (ClosedChannelException x) {
        }
    }
}
```


Overlapping Code:
```
static <T> void checkOption(DatagramChannel dc,
SocketOption<T> name,
T expectedValue)
throws IOException
{
T value = dc.getOption(name);
if (!value.equals(expectedValue))
throw new RuntimeException("value not as expected");
}
public static void main(String[] args) throws IOException {
DatagramChannel dc = DatagramChannel.open();
// check supported options
Set<SocketOption<?>> options = dc.supportedOptions();
boolean reuseport = options.contains(SO_REUSEPORT);
List<? extends SocketOption<?>> expected;
if (reuseport) {
expected = Arrays.asList(SO_SNDBUF, SO_RCVBUF,
SO_REUSEADDR, SO_REUSEPORT, SO_BROADCAST, IP_TOS, IP_MULTICAST_IF,
IP_MULTICAST_TTL, IP_MULTICAST_LOOP);
} else {
expected = Arrays.asList(SO_SNDBUF, SO_RCVBUF,
SO_REUSEADDR, SO_BROADCAST, IP_TOS, IP_MULTICAST_IF, IP_MULTICAST_TTL,
IP_MULTICAST_LOOP);
}
for (SocketOption opt: expected) {
if (!options.contains(opt))
throw new RuntimeException(opt.name() + " should be supported");
}
// check specified defaults
checkOption(dc, SO_BROADCAST, false);
checkOption(dc, IP_MULTICAST_TTL, 1); // true on supported platforms
checkOption(dc, IP_MULTICAST_LOOP, true); // true on supported platforms
// allowed to change when not bound
dc.setOption(SO_BROADCAST, true);
checkOption(dc, SO_BROADCAST, true);
dc.setOption(SO_BROADCAST, false);
checkOption(dc, SO_BROADCAST, false);
dc.setOption(SO_SNDBUF, 128*1024); // can't check
dc.setOption(SO_RCVBUF, 128*1024); // can't check
int before, after;
before = dc.getOption(SO_SNDBUF);
after = dc.setOption(SO_SNDBUF, Integer.MAX_VALUE).getOption(SO_SNDBUF);
if (after < before)
throw new RuntimeException("setOption caused SO_SNDBUF to decrease");
before = dc.getOption(SO_RCVBUF);
after = dc.setOption(SO_RCVBUF, Integer.MAX_VALUE).getOption(SO_RCVBUF);
if (after < before)
throw new RuntimeException("setOption caused SO_RCVBUF to decrease");
dc.setOption(SO_REUSEADDR, true);
checkOptio
```
<Overlap Ratio: 0.9753593429158111>

---

--- 111 --
Question ID: 299dcbce10a290b725e9afce5cbc2a73b314eee9
Original Code:
```
public class BrowseBooksScreen extends List implements CommandListener
{
	private static BookCollection books;
	
	public static int PAGE_SIZE = 5;
	
	private Midlet midlet;
	private int currentPage;
	
	private Command nextPage;
	private Command previousPage;
	
	private Command select;
	private Command home;
	
	public static BrowseBooksScreen getScreen (int pageNo, Midlet midlet) 
	{
		BrowseBooksScreen browseScreen = new BrowseBooksScreen (pageNo);
		browseScreen.setMidlet (midlet);
		
		return browseScreen;
	}
	
	private void setMidlet(Midlet m) 
	{
		midlet = m;
	}
	
	public BrowseBooksScreen (int page)
	{
		super ("Collection: Page " + (page + 1), List.IMPLICIT);
		
		currentPage = page;
		
		if (books == null)
		{
			books = BookCollection.getCollection ();
		}
		
		for (int i = (currentPage * PAGE_SIZE); i < books.size () && i < ((currentPage + 1) * PAGE_SIZE); i++)
		{
			Book b = books.getBookAtIndex (i);
			
			if (b.getValue ("Title") != null)
				this.append (b.getValue ("Title"), null);
		}
		
		if (((currentPage + 1) * PAGE_SIZE) < books.size ())
		{
			nextPage = new Command ("Next", Command.OK, 1);
			this.addCommand (nextPage);
		}
		else
		{
			home = new Command ("Home", Command.OK, 2);
			this.addCommand (home);
		}
		
		if (currentPage > 0)
		{
			previousPage = new Command ("Previous", Command.BACK, 1);
			this.addCommand (previousPage);
		}
		else
		{
			home = new Command ("Home", Command.BACK, 2);
			this.addCommand (home);
		}
		
		select = List.SELECT_COMMAND;
		this.addCommand (select);
		
		this.setCommandListener (this);
	}
	
	public BrowseBooksScreen (String arg0, int arg1) 
	{
		super (arg0, arg1);
	}
	
	public void commandAction(Command cmd, Displayable sender) 
	{
		if (cmd == home)
			midlet.setScreen (MainMenuScreen.getScreen (midlet));
		else if (cmd == select)
			midlet.setScreen (BookDisplayScreen.getScreen ((currentPage * PAGE_SIZE) + this.getSelectedIndex(), null, midlet));
		else if (cmd == nextPage)
			midlet.setScreen (BrowseBooksScreen.getScreen (currentPage + 1, midlet));
		else if (cmd ==previousPage)
		{
			if (currentPage > 0)
				midlet.setScreen (BrowseBooksScreen.getScreen (currentPage - 1, midlet));
		}
	}
}
```


Overlapping Code:
```
en extends List implements CommandListener
{
private static BookCollection books;

public static int PAGE_SIZE = 5;

private Midlet midlet;
private int currentPage;

private Command nextPage;
private Command previousPage;

private Command select;
private Command home;

public static BrowseBooksScreen getScreen (int pageNo, Midlet midlet) 
{
BrowseBooksScreen browseScreen = new BrowseBooksScreen (pageNo);
browseScreen.setMidlet (midlet);

return browseScreen;
}

private void setMidlet(Midlet m) 
{
midlet = m;
}

public BrowseBooksScreen (int page)
{
super ("Collection: Page " + (page + 1), List.IMPLICIT);

currentPage = page;

if (books == null)
{
books = BookCollection.getCollection ();
}

for (int i = (currentPage * PAGE_SIZE); i < books.size () && i < ((currentPage + 1) * PAGE_SIZE); i++)
{
Book b = books.getBookAtIndex (i);

if (b.getValue ("Title") != null)
this.append (b.getValue ("Title"), null);
}

if (((currentPage + 1) * PAGE_SIZE) < books.size ())
{
nextPage = new Command ("Next", Command.OK, 1);
this.addCommand (nextPage);
}
else
{
home = new Command ("Home", Command.OK, 2);
this.addCommand (home);
}

if (currentPage > 0)
{
previousPage = new Command ("Previous", Command.BACK, 1);
this.addCommand (previousPage);
}
else
{
home = new Command ("Home", Command.BACK, 2);
this.addCommand (home);
}

select = List.SELECT_COMMAND;
this.addCommand (select);

this.setCommandListener (this);
}

public BrowseBooksScreen (String arg0, int arg1) 
{
super (arg0, arg1);
}

public void commandAction(Command cmd, Displayable sender) 
{
if (cmd == home)
midlet.setScreen (MainMenuScreen.getScreen (midlet));
else if (cmd == select)
midlet.setScreen (BookDisplayScreen.getScreen ((currentPage * PAGE_SIZE) + this.getSelectedIndex(), null, midlet));
else if (cmd == nextPage)
midlet.setScreen (BrowseBooksScreen.getScreen (currentPage + 1, midlet));
else if (cmd ==previousPage)
{
if (currentPage > 0)
midlet.setScreen (BrowseBooksScreen.getScreen (cur
```
<Overlap Ratio: 0.9718379446640316>

---

--- 112 --
Question ID: e65eabca600c7e064574e2b0e94f29d9e12b3731
Original Code:
```
public class ImageResourceIdAdapter extends BaseImageAdapter<Integer> {


    public ImageResourceIdAdapter() {
        super(new ArrayList<Integer>());
    }

    public ImageResourceIdAdapter(List<Integer> objects) {
        super(objects);
    }

    @Override
    public void onBindViewHolder(ImageViewHolder holder, int position) {
        super.onBindViewHolder(holder, position);

        Integer resId = getItem(position);
        holder.imageView.setImageResource(resId);
    }


}
```


Overlapping Code:
```
ic class ImageResourceIdAdapter extends BaseImageAdapter<Integer> {
public ImageResourceIdAdapter() {
super(new ArrayList<Integer>());
}
public ImageResourceIdAdapter(List<Integer> objects) {
super(objects);
}
@Override
public void onBindViewHolder(ImageViewHolder holder, int position) {
super.onBindViewHolder(holder, position);
Integer resId = getItem(position);
holder.imageView.setImageResource(
```
<Overlap Ratio: 0.963855421686747>

---

--- 113 --
Question ID: 3ae5046e1ffa6c99f103dd166d9f4d30aea77c7d
Original Code:
```
public class JBossASTest {

	private static final String SERVER_HOME = "/Users/john01/projectZ/torquebox/jboss";

	@Test(dataProvider = "getServerProperties")
	public void shouldStartJBossWithProperCommand(ServerProperties properties, String expectedCommand) throws Exception {
	    // Given
		AbstractJBossAS jboss = (AbstractJBossAS) new JBossASProvider(properties).createJBossASInstance();

		// When
		String[] command = jboss.startCommand();

	    // Then
		assertThat(normalize(command)).isEqualTo(expectedCommand);
	}

    @DataProvider
    public Object[][] getServerProperties() {
        return new Object[][]{
                {
                        new ServerProperties(SERVER_HOME).asVersion(5),
                        SERVER_HOME + "/bin/run.sh -c default -Djboss.service.binding.set=ports-02"
                },
                {
                        new ServerProperties(SERVER_HOME).asVersion(5).secured(true).username("scott").password("tiger").configuration("myconf").portset(0),
                        SERVER_HOME + "/bin/run.sh -c myconf"
                },
                {
                        new ServerProperties(SERVER_HOME).asVersion(6).additionalSystemProperties("-Dmyprop=val"),
                        SERVER_HOME + "/bin/run.sh -c default -Djboss.service.binding.set=ports-02 -Dmyprop=val"
                },
                {
                        new ServerProperties(SERVER_HOME).asVersion(7).portset(0),
                        SERVER_HOME + "/bin/standalone.sh"
                },
                {
                        new ServerProperties(SERVER_HOME).asVersion(7).portset(2),
                        SERVER_HOME + "/bin/standalone.sh  -Djboss.socket.binding.port-offset=200"
                },
                {
                        new ServerProperties(SERVER_HOME).asVersion(7).configuration("mystandalone.xml").portset(0),
                        SERVER_HOME + "/bin/standalone.sh -c mystandalone.xml"
                },
        };
    }

    @Test(dataProvider = "getServerPropertiesShutdown")
	public void shouldShutdownJBossWithProperCommnd(ServerProperties properties, String expectedCommand) throws Exception {
	    // Given
	     AbstractJBossAS jboss = (AbstractJBossAS) new JBossASProvider(properties).createJBossASInstance();

		// When
		String[] command = jboss.shutdownCommand();

	    // Then
		assertThat(normalize(command)).isEqualTo(expectedCommand);
	}

	@DataProvider
    public Object[][] getServerPropertiesShutdown() {
        return new Object[][]{
                {
                        new ServerProperties(SERVER_HOME).asVersion(5),
                        SERVER_HOME + "/bin/shutdown.sh --server=localhost:1299 -S"
                },
                {
                        new ServerProperties(SERVER_HOME).asVersion(5).secured(true).username("scott").password("tiger").configuration("myconf").portset(0),
                        SERVER_HOME + "/bin/shutdown.sh --server=localhost:1099 -S -u scott -p tiger"
                },
                {
                        new ServerProperties(SERVER_HOME).asVersion(6).additionalSystemProperties("-Dmyprop=val"),
                        SERVER_HOME + "/bin/shutdown.sh --host=localhost --port=1290 -S"
                },
                {
                        new ServerProperties(SERVER_HOME).asVersion(7).portset(0),
                        SERVER_HOME + "/bin/jboss-cli.sh --connect command=:shutdown"
                },
                {
                        new ServerProperties(SERVER_HOME).asVersion(7).portset(2),
                        SERVER_HOME + "/bin/jboss-cli.sh --connect command=:shutdown --controller=localhost:10199"
                },
                {
                        new ServerProperties(SERVER_HOME).asVersion(7).portset(0).secured(true).username("scott").password("tiger"),
                        SERVER_HOME + "/bin/jboss-cli.sh --connect command=:shutdown --user=scott --password=tiger"
                },
        };
    }

    private static String normalize(String[] command) {
		return Arrays.toString(command).replaceAll("[,\\[\\]]","").trim();
	}
}
```


Overlapping Code:
```
atic final String SERVER_HOME = "/Users/john01/projectZ/torquebox/jboss";
@Test(dataProvider = "getServerProperties")
public void shouldStartJBossWithProperCommand(ServerProperties properties, String expectedCommand) throws Exception {
// Given
AbstractJBossAS jboss = (AbstractJBossAS) new JBossASProvider(properties).createJBossASInstance();
// When
String[] command = jboss.startCommand();
// Then
assertThat(normalize(command)).isEqualTo(expectedCommand);
}
@DataProvider
public Object[][] getServerProperties() {
return new Object[][]{
{
new ServerProperties(SERVER_HOME).asVersion(5),
SERVER_HOME + "/bin/run.sh -c default -Djboss.service.binding.set=ports-02"
},
{
new ServerProperties(SERVER_HOME).asVersion(5).secured(true).username("scott")rtset(0),
SERVER_HOME + "/bin/run.sh -c myconf"
},
{
new ServerProperties(SERVER_HOME).asVersion(6).additionalSystemProperties("-Dmyprop=val"),
SERVER_HOME + "/bin/run.sh -c default -Djboss.service.binding.set=ports-02 -Dmyprop=val"
},
{
new ServerProperties(SERVER_HOME).asVersion(7).portset(0),
SERVER_HOME + "/bin/standalone.sh"
},
{
new ServerProperties(SERVER_HOME).asVersion(7).portset(2),
SERVER_HOME + "/bin/standalone.sh -Djboss.socket.binding.port-offset=200"
},
{
new ServerProperties(SERVER_HOME).asVersion(7).configuration("mystandalone.xml").portset(0),
SERVER_HOME + "/bin/standalone.sh -c mystandalone.xml"
},
};
}
@Test(dataProvider = "getServerPropertiesShutdown")
public void shouldShutdownJBossWithProperCommnd(ServerProperties properties, String expectedCommand) throws Exception {
// Given
AbstractJBossAS jboss = (AbstractJBossAS) new JBossASProvider(properties).createJBossASInstance();
// When
String[] command = jboss.shutdownCommand();
// Then
assertThat(normalize(command)).isEqualTo(expectedCommand);
}
@DataProvider
public Object[][] getSer
```
<Overlap Ratio: 0.9454545454545454>

---

--- 114 --
Question ID: 6c63cf1b710e22cbc392114c3e041061166e3295
Original Code:
```
@RunWith(Arquillian.class)
public class MonitorArquillianTest {

    @Deployment(testable = false)
    public static Archive createDeployment() {
        JARArchive deployment = ShrinkWrap.create(JARArchive.class);
        deployment.add(EmptyAsset.INSTANCE, "nothing");
        return deployment;
    }

    @RunAsClient
    @Test
    public void testEndpoints() throws Exception {
        System.out.println(IOUtils.toString(new URL("http://127.0.0.1:8080/node"), Charset.forName("UTF-8")));
        System.out.println(IOUtils.toString(new URL("http://127.0.0.1:8080/heap"), Charset.forName("UTF-8")));
        System.out.println(IOUtils.toString(new URL("http://127.0.0.1:8080/threads"), Charset.forName("UTF-8")));
    }
}
```


Overlapping Code:
```
th(Arquillian.class)
public class MonitorArquillianTest {
@Deployment(testable = false)
public static Archive createDeployment() {
JARArchive deployment = ShrinkWrap.create(JARArchive.class);
deployment.add(EmptyAsset.INSTANCE, "nothing");
return deployment;
}
@RunAsClient
@Test
public void testEndpoints() throws Exception {
System.out.println(IOUtils.toString(new URL("http://127.0.0.1:8080/node"), Charset.forName("UTF-8")));
System.out.println(IOUtils.toString(new URL("http://127.0.0.1:8080/heap"), Charset.forName("UTF-8")));
System.out.println(IOUtils.toString(new URL("http://127.0.0.1:8080/threads"), Charset.forName("UTF-8")));
}
}
```
<Overlap Ratio: 0.9907407407407407>

---

--- 115 --
Question ID: f55a0802399e5abd77e82354deb402c84a1b0d53
Original Code:
```
@Configuration
@AutoConfigureBefore(StarterErrorHandlingAutoConfiguration.class)
@ConditionalOnProperty(prefix = "neostarter.mvc.restErrorHandling", value = "enabled", havingValue = "true", matchIfMissing = true)
@Import(ExceptionHandlersRegistryAutoConfiguration.RestExceptionHandlerRegistryRegistrar.class)
public class ExceptionHandlersRegistryAutoConfiguration {

    static class RestExceptionHandlerRegistryRegistrar implements ImportBeanDefinitionRegistrar {

        @Override
        public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
            GenericBeanDefinition beanDefinition = new GenericBeanDefinition();
            beanDefinition.setBeanClass(RestExceptionHandlerRegistry.class);
            beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
            beanDefinition.getConstructorArgumentValues()
                    .addGenericArgumentValue(Sets.newHashSet());
            beanDefinition.setSynthetic(true);
            registry.registerBeanDefinition(RestExceptionHandlerRegistry.BEAN_NAME, beanDefinition);
        }
    }
}
```


Overlapping Code:
```
reBefore(StarterErrorHandlingAutoConfiguration.class)
@ConditionalOnProperty(prefix = "neostarter.mvc.restErrorHandling", value = "enabled", havingValue = "true", matchIfMissing = true)
@Import(ExceptionHandlersRegistryAutoConfiguration.RestExceptionHandlerRegistryRegistrar.class)
public class ExceptionHandlersRegistryAutoConfiguration {
static class RestExceptionHandlerRegistryRegistrar implements ImportBeanDefinitionRegistrar {
@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
GenericBeanDefinition beanDefinition = new GenericBeanDefinition();
beanDefinition.setBeanClass(RestExceptionHandlerRegistry.class);
beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
beanDefinition.getConstructorArgumentValues()
.addGenericArgumentValue(Sets.newHashSet());
beanDefinition.setSynthetic(true);
registry.registerBeanDefinition(RestExceptionHandlerRegistry.BEAN_NAME, b
```
<Overlap Ratio: 0.9519038076152304>

---

--- 116 --
Question ID: 773e2fdc0bf822ea85331efeb42dbc220779c486
Original Code:
```
public class LinkImpl extends ElementImpl implements Link {
	//private java.util.Date date= new java.util.Date();
    /**
     * Creates a Element for a given WebElement.
     *
     * @param element element to wrap up
     */
    public LinkImpl(WebElement element) {
        super(element);
    }
    
    @Override
    public void jsClick(WebDriver driver) {
    	JavascriptExecutor executor = (JavascriptExecutor)driver;
    	try{
    	    executor.executeScript("arguments[0].click();", element);
    	}catch(RuntimeException rte){
    	    TestReporter.interfaceLog(" Click Link [ <b>@FindBy: " + getElementLocatorInfo()  + " </b> ]", true);
    	    throw rte;
    	}
    	TestReporter.interfaceLog(" Click Link [ <b>@FindBy: " + getElementLocatorInfo()  + " </b> ]");
        
    }
    
    @Override
    public void click() {    	
        try{
            getWrappedElement().click();
        }catch(RuntimeException rte){
            TestReporter.interfaceLog(" Click Link [ <b>@FindBy: " + getElementLocatorInfo()  + " </b> ]", true);
            throw rte;
        }
    	TestReporter.interfaceLog(" Click Link [ <b>@FindBy: " + getElementLocatorInfo()  + " </b> ]");
    	
    }
}
```


Overlapping Code:
```
blic class LinkImpl extends ElementImpl implements Link {
//private java.util.Date date= new java.util.Date();
/**
* Creates a Element for a given WebElement.
*
* @param element element to wrap up
*/
public LinkImpl(WebElement element) {
super(element);
}

@Override
public void jsClick(WebDriver driver) {
JavascriptExecutor executor = (JavascriptExecutor)driver;
try{
executor.executeScript("arguments[0].click();", element);
}catch(RuntimeException rte){
TestReporter.interfaceLog(" Click Link [ <b>@FindBy: " + getElementLocatorInfo() + " </b> ]", true);
throw rte;
}
TestReporter.interfaceLog(" Click Link [ <b>@FindBy: " + getElementLocatorInfo() + " </b> ]");

}

@Override
public void click() { 
try{
getWrappedElement().click();
}catch(RuntimeException rte){
TestReporter.interfaceLog(" Click Link [ <b>@FindBy: " + getElementLocatorInfo() + " </b> ]", true);
throw rte;
}
TestReporter.interfaceLog(" Click Link [ <b>@FindBy: " + getElementLocatorInfo() + " </b> ]");
```
<Overlap Ratio: 0.9928789420142421>

---

--- 117 --
Question ID: a433ab62423bd8da6f23e8dcd35d13f267fb5c75
Original Code:
```
public class ProjectComponent
        extends AbstractComponent<IProjectComponent.Controller, HTMLElement>
        implements IProjectComponent {

    private HTMLDivElement element;

    private FieldsGrouping fieldsGrouping = FieldsGrouping.create();
    private TextBox groupIdTextBox;
    private TextBox artifactIdTextBox;
    private Select<String> gwtVersionSelect;
    private Select<WidgetLibrary> widgetSetSelect;

    public ProjectComponent() {
    }

    @Override
    public void render() {

        groupIdTextBox = TextBox.create("Group ID")
                .setPlaceholder("com.example")
                .value("com.example")
                .floating()
                .setRequired(true)
                .setAutoValidation(true)
                .setLeftAddon(Icons.ALL.inbox())
                .groupBy(fieldsGrouping);

        artifactIdTextBox = TextBox.create("Artifact ID")
                .setPlaceholder("MyTestProject")
                .value("MyTestProject")
                .floating()
                .setRequired(true)
                .setAutoValidation(true)
                .setLeftAddon(Icons.ALL.archive())
                .groupBy(fieldsGrouping);

        gwtVersionSelect = Select.<String>create("GWT Version")
                .appendChild(SelectOption.create("2.8.2",
                        "2.8.2"))
                .selectAt(0)
                .setLeftAddon(Icons.ALL.code())
                .setRequired(true)
                .setAutoValidation(true)
                .groupBy(fieldsGrouping);

        widgetSetSelect = Select.<WidgetLibrary>create("Widget Set")
                .appendChild(SelectOption.create(WidgetLibrary.DOMINO_UI,
                        WidgetLibrary.DOMINO_UI.getText()))
                .appendChild(SelectOption
                        .create(WidgetLibrary.ELEMENTO,
                                WidgetLibrary.ELEMENTO.getText()))
                .appendChild(SelectOption.create(WidgetLibrary.GWT,
                        WidgetLibrary.GWT.getText()))
                .appendChild(SelectOption.create(WidgetLibrary.GXT,
                        WidgetLibrary.GXT.getText()))
                .selectAt(3)
                .setLeftAddon(Icons.ALL.dashboard())
                .setRequired(true)
                .setAutoValidation(true)
                .groupBy(fieldsGrouping);

        this.element = div().asElement();
        this.element.appendChild(Row.create()
                .appendChild(Column.span6()
                        .offset3()
                        .appendChild(BlockHeader.create("Project Meta Data"))
                        .appendChild(Card.create()
                                .styler(style -> style.setPaddingTop("20px"))
                                .appendChild(Row.create()
                                        .appendChild(Column
                                                .span6()
                                                .appendChild(groupIdTextBox))
                                        .appendChild(Column
                                                .span6()
                                                .appendChild(artifactIdTextBox)))
                                .appendChild(Row.create()
                                        .appendChild(Column
                                                .span6()
                                                .condenced()
                                                .appendChild(gwtVersionSelect))
                                        .appendChild(Column
                                                .span6()
                                                .condenced()
                                                .appendChild(widgetSetSelect)))
                        )
                )
                .asElement());
        initElement(this.element);
    }

    @Override
    public void edit(NaluGeneraterParms naluGeneraterParms) {
        this.groupIdTextBox.setValue(naluGeneraterParms.getGroupId());
        this.artifactIdTextBox.setValue(naluGeneraterParms.getArtefactId());
        this.gwtVersionSelect.setValue(naluGeneraterParms.getGwtVersion());
        this.widgetSetSelect.setValue(naluGeneraterParms.getWidgetLibrary());

    }

    @Override
    public NaluGeneraterParms flush(NaluGeneraterParms naluGeneraterParms) {
        naluGeneraterParms.setGroupId(this.groupIdTextBox.getValue());
        naluGeneraterParms.setArtefactId(this.artifactIdTextBox.getValue());
        naluGeneraterParms.setGwtVersion(this.gwtVersionSelect.getValue());
        naluGeneraterParms.setWidgetLibrary(this.widgetSetSelect.getValue());
        return naluGeneraterParms;
    }
}
```


Overlapping Code:
```
lass ProjectComponent
extends AbstractComponent<IProjectComponent.Controller, HTMLElement>
implements IProjectComponent {
private HTMLDivElement element;
private FieldsGrouping fieldsGrouping = FieldsGrouping.create();
private TextBox groupIdTextBox;
private TextBox artifactIdTextBox;
private Select<String> gwtVersionSelect;
private Select<WidgetLibrary> widgetSetSelect;
public ProjectComponent() {
}
@Override
public void render() {
groupIdTextBox = TextBox.create("Group ID")
.setPlaceholder("com.example")
.value("com.example")
.floating()
.setRequired(true)
.setAutoValidation(true)
.setLeftAddon(Icons.ALL.inbox())
.groupBy(fieldsGrouping);
artifactIdTextBox = TextBox.create("Artifact ID")
.setPlaceholder("MyTestProject")
.value("MyTestProject")
.floating()
.setRequired(true)
.setAutoValidation(true)
.setLeftAddon(Icons.ALL.archive())
.groupBy(fieldsGrouping);
gwtVersionSelect = Select.<String>create("GWT Version")
.appendChild(SelectOption.create("2.8.2",
"2.8.2"))
.selectAt(0)
.setLeftAddon(Icons.ALL.code())
.setRequired(true)
.setAutoValidation(true)
.groupBy(fieldsGrouping);
widgetSetSelect = Select.<WidgetLibrary>create("Widget Set")
.appendChild(SelectOption.create(WidgetLibrary.DOMINO_UI,
WidgetLibrary.DOMINO_UI.getText()))
.appendChild(SelectOption
.create(WidgetLibrary.ELEMENTO,
WidgetLibrary.ELEMENTO.getText()))
.appendChild(SelectOption.create(WidgetLibrary.GWT,
WidgetLibrary.GWT.getText()))
.appendChild(SelectOption.create(WidgetLibrary.GXT,
WidgetLibrary.GXT.getText()))
.selectAt(3)
.setLeftAddon(Icons.ALL.dashboard())
.setRequired(true)
.setAutoValidation(true)
.groupBy(fieldsGrouping);
this.element = div().asElement();
this.element.appendChild(Row.create()
.appendChild(Column.span6(
```
<Overlap Ratio: 0.9948126801152738>

---

--- 118 --
Question ID: 39a00aab3bb91f9ba6a8aa5a4edbc366e12074c0
Original Code:
```
public class setvalue001 {

    public static void main(String argv[]) {
        System.exit(run(argv, System.out) + 95); // JCK-compatible exit status
    }

    static int exitCode  = 0;
    static int exitCode0 = 0;
    static int exitCode2 = 2;

//
    static Connector.IntegerArgument intArgument = null;
    static int i;

    private static void check(int i1, PrintStream out) {

//
        String sErr2 =  "ERROR\n" +
                        "Method tested: " +
                        "jdi.Connector.IntegerArgument.setValue()\n" ;


            intArgument.setValue(i);
            intArgument.setValue(i1);
            if (intArgument.intValue() != i1) {
                exitCode = exitCode2;
                out.println(sErr2 +
                         "check: setValue(int); setValue(int)\n" +
                         "result: no equality\n");
            }

            intArgument.setValue(i);
            intArgument.setValue(intArgument.stringValueOf(i1));
            if (intArgument.intValue() != i1) {
                exitCode = exitCode2;
                out.println(sErr2 +
                         "check: setValue(int); setValue(String)\n" +
                         "result: no equality\n");
            }

            intArgument.setValue(intArgument.stringValueOf(i));
            intArgument.setValue(i1);
            if (intArgument.intValue() != i1) {
                exitCode = exitCode2;
                out.println(sErr2 +
                         "check: setValue(String); setValue(int)\n" +
                         "result: no equality\n");
            }

            intArgument.setValue(intArgument.stringValueOf(i));
            intArgument.setValue(intArgument.stringValueOf(i1));
            if (intArgument.intValue() != i1) {
                exitCode = exitCode2;
                out.println(sErr2 +
                         "check: setValue(String); setValue(String)\n" +
                         "result: no equality\n");
            }
    }

    public static int run(String argv[], PrintStream out) {

        VirtualMachineManager vmm = Bootstrap.virtualMachineManager();

        List connectorsList = vmm.allConnectors();
        Iterator connectorsListIterator = connectorsList.iterator();
//
        String sErr1 =  "WARNING\n" +
                        "Method tested: " +
                        "jdi.Connector.IntegerArgument.setValue\n" ;

        Integer intI = null;

        for ( ; ; ) {
            try {
                Connector connector =
                (Connector) connectorsListIterator.next();

                Map defaultArguments = connector.defaultArguments();
                Set keyset     = defaultArguments.keySet();
                int keysetSize = defaultArguments.size();
                Iterator  keysetIterator = keyset.iterator();

                for ( ; ; ) {
                    try {
                        String argName = (String) keysetIterator.next();

                        try {
//
                            intArgument = (Connector.IntegerArgument)
                                       defaultArguments.get(argName);
                            break ;
                        } catch ( ClassCastException e) {
                        }
                    } catch ( NoSuchElementException e) {
                        break ;
                    }
                }
                if (intArgument != null) {
                    break ;
                }
            } catch ( NoSuchElementException e) {
                out.println(sErr1 +
//
                    "no Connector with IntegerArgument found\n");
                return exitCode0;
            }
        }


        if (intArgument.min() >= 0) {
            i = -1;
        } else {
            i = 1;
        }

        check(intArgument.min(), out);
        check(intArgument.max(), out);
        if (intArgument.min() < intArgument.max()) {
            check(intArgument.min() + 1, out);
        }
        if (intArgument.min() > intI.MIN_VALUE) {
            check(intArgument.min() - 1, out);
        }
        if (intArgument.max() < intI.MAX_VALUE) {
            check(intArgument.max() + 1, out);
        }

        if (exitCode != exitCode0) {
            out.println("TEST FAILED");
        }
        return exitCode;
    }
}
```


Overlapping Code:
```
 {
public static void main(String argv[]) {
System.exit(run(argv, System.out) + 95); // JCK-compatible exit status
}
static int exitCode = 0;
static int exitCode0 = 0;
static int exitCode2 = 2;
//
static Connector.IntegerArgument intArgument = null;
static int i;
private static void check(int i1, PrintStream out) {
//
String sErr2 = "ERROR\n" +
"Method tested: " +
"jdi.Connector.IntegerArgument.setValue()\n" ;
intArgument.setValue(i);
intArgument.setValue(i1);
if (intArgument.intValue() != i1) {
exitCode = exitCode2;
out.println(sErr2 +
"check: setValue(int); setValue(int)\n" +
"result: no equality\n");
}
intArgument.setValue(i);
intArgument.setValue(intArgument.stringValueOf(i1));
if (intArgument.intValue() != i1) {
exitCode = exitCode2;
out.println(sErr2 +
"check: setValue(int); setValue(String)\n" +
"result: no equality\n");
}
intArgument.setValue(intArgument.stringValueOf(i));
intArgument.setValue(i1);
if (intArgument.intValue() != i1) {
exitCode = exitCode2;
out.println(sErr2 +
"check: setValue(String); setValue(int)\n" +
"result: no equality\n");
}
intArgument.setValue(intArgument.stringValueOf(i));
intArgument.setValue(intArgument.stringValueOf(i1));
if (intArgument.intValue() != i1) {
exitCode = exitCode2;
out.println(sErr2 +
"check: setValue(String); setValue(String)\n" +
"result: no equality\n");
}
}
public static int run(String argv[], PrintStream out) {
VirtualMachineManager vmm = Bootstrap.virtualMachineManager();
List connectorsList = vmm.allConnectors();
Iterator connectorsListIterator = connectorsList.iterator();
//
String sErr1 = "WARNING\n" +
"Method tested: " +
"jdi.Connector.IntegerArgument.setValue\n" ;
Integer i
```
<Overlap Ratio: 0.9584535487593768>

---

--- 119 --
Question ID: f90c99c54877be6bdeb238b60c068c41ff7f9894
Original Code:
```
@RunWith(MockitoJUnitRunner.class)
public class LessVariableOptionsBuilderTest {

    @Spy
    private LessVariableOptionsBuilder builder;

    @Test(expected = IllegalArgumentException.class)
    public void append_mapIsNull_throwsException() {
        builder.append((Map<String, String>) null);
    }

    @Test
    public void append_mapIsNotNull_variablesAreAdded() {
        final Map<String, String> variables = new LinkedHashMap<>();
        variables.put("name1", "value1");
        variables.put("name2", "value2");

        final LessVariableOptionsBuilder result = builder.append(variables);

        assertThat(result).isSameAs(builder);
        verify(builder).append("name1", "value1");
        verify(builder).append("name2", "value2");
        assertThat(builder.getVariables()).containsExactly(new LessVariableOption("name1", "value1"),
                new LessVariableOption("name2", "value2"));
    }

    @Test
    public void append_nameIsValue_variableIsAdded() {
        final LessVariableOptionsBuilder result = builder.append("name", "value");

        assertThat(result).isSameAs(builder);
        assertThat(builder.getVariables()).containsExactly(new LessVariableOption("name", "value"));

    }

    @Test(expected = IllegalArgumentException.class)
    public void append_iterableIsNull_throwsException() {
        builder.append((Iterable<LessVariableOption>) null);
    }

    @Test
    public void append_iterableIsNotNull_variablesAreAdded() {
        final LessVariableOption variable1 = new LessVariableOption("name1", "value1");
        final LessVariableOption variable2 = new LessVariableOption("name2", "value2");

        final LessVariableOptionsBuilder result = builder.append(Arrays.asList(variable1, variable2));

        assertThat(result).isSameAs(builder);
        verify(builder).append(variable1);
        verify(builder).append(variable2);
        assertThat(builder.getVariables()).containsExactly(variable1, variable2);
    }

    @Test(expected = IllegalArgumentException.class)
    public void append_arrayIsNull_throwsException() {
        builder.append((LessVariableOption[]) null);
    }

    @Test
    public void append_arrayIsNotNull_variablesAreAdded() {
        final LessVariableOption variable1 = new LessVariableOption("name1", "value1");
        final LessVariableOption variable2 = new LessVariableOption("name2", "value2");

        final LessVariableOptionsBuilder result = builder.append(new LessVariableOption[] { variable1, variable2 });

        assertThat(result).isSameAs(builder);
        verify(builder).append(variable1);
        verify(builder).append(variable2);
        assertThat(builder.getVariables()).containsExactly(variable1, variable2);
    }

    @Test(expected = IllegalArgumentException.class)
    public void append_variableIsNull_throwsException() {
        builder.append((LessVariableOption) null);
    }

    @Test
    public void append_variableIsNotNull_variablesAreAdded() {
        final LessVariableOption variable = new LessVariableOption("name", "value");

        final LessVariableOptionsBuilder result = builder.append(variable);

        assertThat(result).isSameAs(builder);
        assertThat(builder.getVariables()).containsExactly(variable);
    }

    @Test
    public void build() {
        final Map<String, String> variablesMap = new LinkedHashMap<>();
        variablesMap.put("name1", "value1");
        variablesMap.put("name2", "value2");

        final List<LessVariableOption> variables = builder //
                .append(variablesMap) //
                .append("name3", "value3") //
                .append(new LessVariableOption("name2", "value4")) //
                .build();

        assertThat(variables).containsExactly(//
                new LessVariableOption("name1", "value1"), //
                new LessVariableOption("name2", "value2"), //
                new LessVariableOption("name3", "value3"), //
                new LessVariableOption("name2", "value4"));
    }
}
```


Overlapping Code:
```
@RunWith(MockitoJUnitRunner.class)
public class LessVariableOptionsBuilderTest {
@Spy
private LessVariableOptionsBuilder builder;
@Test(expected = IllegalArgumentException.class)
public void append_mapIsNull_throwsException() {
builder.append((Map<String, String>) null);
}
@Test
public void append_mapIsNotNull_variablesAreAdded() {
final Map<String, String> variables = new LinkedHashMap<>();
variables.put("name1", "value1");
variables.put("name2", "value2");
final LessVariableOptionsBuilder result = builder.append(variables);
assertThat(result).isSameAs(builder);
verify(builder).append("name1", "value1");
verify(builder).append("name2", "value2");
assertThat(builder.getVariables()).containsExactly(new LessVariableOption("name1", "value1"),
new LessVariableOption("name2", "value2"));
}
@Test
public void append_nameIsValue_variableIsAdded() {
final LessVariableOptionsBuilder result = builder.append("name", "value");
assertThat(result).isSameAs(builder);
assertThat(builder.getVariables()).containsExactly(new LessVariableOption("name", "value"));
}
@Test(expected = IllegalArgumentException.class)
public void append_iterableIsNull_throwsException() {
builder.append((Iterable<LessVariableOption>) null);
}
@Test
public void append_iterableIsNotNull_variablesAreAdded() {
final LessVariableOption variable1 = new LessVariableOption("name1", "value1");
final LessVariableOption variable2 = new LessVariableOption("name2", "value2");
final LessVariableOptionsBuilder result = builder.append(Arrays.asList(variable1, variable2));
assertThat(result).isSameAs(builder);
verify(builder).append(variable1);
verify(builder).append(variable2);
assertThat(builder.getVariables()).containsExactly(variable1, variable2);
}
@Test(expected = IllegalArgumentException.class)
public void append_arrayIsNull_throwsException() {
builder.append((LessVariableOption[]) null);
}
@Test
public void append_arrayIsNotNull_variablesAreAdded() {
final LessVariableOption variable1 = new LessVariableOption("name1", "value1");
final LessVariableOption variable2 = new LessVariableOption("name2", "value2");
final LessVariableOptionsBuilder result = builder.append(new LessVariableOption[] { variable1
```
<Overlap Ratio: 0.9986288848263254>

---

--- 120 --
Question ID: 87111a89083951f4f7e4c9f771a3827f1f875f2d
Original Code:
```
public class FunctionCallExpression implements Expression
{
    private static final Pattern signaturePt = Pattern.compile("^(\\w+)\\s*\\((.*)\\)$");

    private final String functionName;
    private final Expression[] argumentExpressions;
    private final ExpressionMatcher origin;
    private final FunctionHandler handler;
    private final int hashCode;

    FunctionCallExpression (ExpressionMatcher matcher, String text) throws ParseException
    {
        origin = matcher;

        Matcher m = signaturePt.matcher(text);

        if(!m.find())
        {
            throw new ParseException("Unable to parse function expression", 0);
        }

        functionName = m.group(1);
        String args = m.group(2).trim();

        ArrayList<Expression> argList = new ArrayList<>();
        if(args.length() > 0)
        {
            int offset = 0, nesting = 0;
            boolean inQuotes = false;
            for(int i = 0; i <= args.length(); i++)
            {
                char c = i < args.length() ? args.charAt(i) : 0;
                if(nesting == 0 && (c == ',' && !inQuotes) || c == 0)
                {
                    Expression expression;

                    try
                    {
                        expression = matcher.match(args.substring(offset, i).trim());
                    }
                    catch(RenderingException e)
                    {
                        throw new ParseException("Could not parse expression of argument " + argList.size(), 0);
                    }

                    offset = i + 1;
                    argList.add(expression);
                    continue;
                }

                if(c == '\'')
                {
                    inQuotes = !inQuotes;
                }

                if(!inQuotes && c == '(')
                {
                    nesting++;
                }

                if(!inQuotes && c == ')')
                {
                    nesting--;
                }
            }
        }

        argumentExpressions = argList.stream().toArray(Expression[]::new);
        handler = origin.getFunctionCatalog().getHandler(functionName);

        {
            int result = functionName.hashCode();
            result = 31 * result + Arrays.hashCode(argumentExpressions);
            result = 31 * result + origin.hashCode();
            result = 31 * result + (handler != null ? handler.hashCode() : 0);

            hashCode = result;
        }
    }

    public Object resolve (Scope scope)
    {
        final FunctionHandler _handler = handler != null ?
            handler : origin.getFunctionCatalog().getHandler(functionName);

        final Object result;

        if(_handler != null)
        {
            result = _handler.apply
            (
                Arrays.stream(argumentExpressions)
                    .map((x) -> scope.evaluate(x))
                    .toArray(Object[]::new)
            );
        }
        else
        {
            throw new RenderingException("Unknown function: " + functionName);
        }

        return result;
    }

    @Override
    public Function<Scope, Object> getResolver ()
    {
        return this::resolve;
    }

    public String getFunctionName ()
    {
        return functionName;
    }

    public Expression[] getArgumentExpressions ()
    {
        return argumentExpressions;
    }

    static boolean matches (String text)
    {
        return signaturePt.matcher(text).find();
    }

    @Override
    public boolean equals (Object o)
    {
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;

        FunctionCallExpression that = (FunctionCallExpression) o;

        if(hashCode != that.hashCode) return false;
        if(!functionName.equals(that.functionName)) return false;
        if(!Arrays.equals(argumentExpressions, that.argumentExpressions)) return false;
        if(!origin.equals(that.origin)) return false;
        return handler != null ? handler.equals(that.handler) : that.handler == null;
    }

    @Override
    public int hashCode ()
    {
        return hashCode;
    }
}
```


Overlapping Code:
```
ublic class FunctionCallExpression implements Expression
{
private static final Pattern signaturePt = Pattern.compile("^(\\w+)\\s*\\((.*)\\)$");
private final String functionName;
private final Expression[] argumentExpressions;
private final ExpressionMatcher origin;
private final FunctionHandler handler;
private final int hashCode;
FunctionCallExpression (ExpressionMatcher matcher, String text) throws ParseException
{
origin = matcher;
Matcher m = signaturePt.matcher(text);
if(!m.find())
{
throw new ParseException("Unable to parse function expression", 0);
}
functionName = m.group(1);
String args = m.group(2).trim();
ArrayList<Expression> argList = new ArrayList<>();
if(args.length() > 0)
{
int offset = 0, nesting = 0;
boolean inQuotes = false;
for(int i = 0; i <= args.length(); i++)
{
char c = i < args.length() ? args.charAt(i) : 0;
if(nesting == 0 && (c == ',' && !inQuotes) || c == 0)
{
Expression expression;
try
{
expression = matcher.match(args.substring(offset, i).trim());
}
catch(RenderingException e)
{
throw new ParseException("Could not parse expression of argument " + argList.size(), 0);
}
offset = i + 1;
argList.add(expression);
continue;
}
if(c == '\'')
{
inQuotes = !inQuotes;
}
if(!inQuotes && c == '(')
{
nesting++;
}
if(!inQuotes && c == ')')
{
nesting--;
}
}
}
argumentExpressions = argList.stream().toArray(Expression[]::new);
handler = origin.getFunctionCatalog().getHandler(functionName);
{
int result = functionName.hashCode();
result = 31 * result + Arrays.hashCode(argumentExpressions);
result = 31 * result + origin.hashCode();
result = 31 * result + (handler != null ? handler.hashCode() : 0);
hashCode = re
```
<Overlap Ratio: 0.9844868735083532>

---

--- 121 --
Question ID: 240bf8060b22fd49e32e2bbba78248e881a5c84a
Original Code:
```
public class AlienFXActionMorph extends AlienFXActionBlink{	
	private static final long serialVersionUID = 1L;

	private ColorModel model = new ColorModel();
	
	public AlienFXActionMorph(Color c, Color c2) {
		super(c);
		model.setColor(c2);
		model.addObserver(new ModelObserver(model));
	}
	
	public Color getMorphToColor() {
		return model.getColor();
	}
	
	public ColorModel getMorphToColorModel(){
		return model;
	}
	
	@Override
	public Color getTrailingColor() {
		return getMorphToColor();
	}
	
	@Override
	public ColorModel getTrailingColorModel() {
		return model;
	}
	
	public String getName() {
		return AlienFXTexts.ACTION_MORPH_TEXT;
	}
	
	public AlienFXAction clone() {
		return new AlienFXActionMorph(getColor(), getMorphToColor());
	}
	
	public void loaded() {
		super.loaded();
		model.addObserver(new ModelObserver(model));
	}
	
	public void setMorphToColor(Color morphToColor) {
		model.setColor(morphToColor);
		setChanged();
		notifyObservers(this);
	}
}
```


Overlapping Code:
```
s AlienFXActionMorph extends AlienFXActionBlink{ 
private static final long serialVersionUID = 1L;
private ColorModel model = new ColorModel();

public AlienFXActionMorph(Color c, Color c2) {
super(c);
model.setColor(c2);
model.addObserver(new ModelObserver(model));
}

public Color getMorphToColor() {
return model.getColor();
}

public ColorModel getMorphToColorModel(){
return model;
}

@Override
public Color getTrailingColor() {
return getMorphToColor();
}

@Override
public ColorModel getTrailingColorModel() {
return model;
}

public String getName() {
return AlienFXTexts.ACTION_MORPH_TEXT;
}

public AlienFXAction clone() {
return new AlienFXActionMorph(getColor(), getMorphToColor());
}

public void loaded() {
super.loaded();
model.addObserver(new ModelObserver(model));
}

public void setMorphToColor(Color morphToColor) {
model.setColor(morphToColor);
setChanged();
notifyObservers(this)
```
<Overlap Ratio: 0.982532751091703>

---

--- 122 --
Question ID: ab189f6cf7c08aeeea8c4c3ccdb6a1c8b10ab39a
Original Code:
```
public class LiveCdoFactory implements CdoFactory {

    private final GlobalIdFactory globalIdFactory;
    private ObjectAccessHook objectAccessHook;
    private TypeMapper typeMapper;

    public LiveCdoFactory(GlobalIdFactory globalIdFactory, ObjectAccessHook objectAccessHook, TypeMapper typeMapper) {
        this.globalIdFactory = globalIdFactory;
        this.objectAccessHook = objectAccessHook;
        this.typeMapper = typeMapper;
    }

    @Override
    public LiveCdo create(Object cdo, OwnerContext owner) {
        GlobalId globalId = globalIdFactory.createId(cdo, owner);

        ManagedType managedType = typeMapper.getJaversManagedType(globalId);

        Optional<ObjectAccessProxy> objectAccessor = objectAccessHook.createAccessor(cdo);

        if (objectAccessor.isPresent()) {
            return new LazyCdoWrapper(objectAccessor.get().getObjectSupplier(), globalId, managedType);
        }
        else {
            return new LiveCdoWrapper(cdo, globalId, managedType);
        }
    }

    @Override
    public String typeDesc() {
        return "live";
    }
}
```


Overlapping Code:
```
ublic class LiveCdoFactory implements CdoFactory {
private final GlobalIdFactory globalIdFactory;
private ObjectAccessHook objectAccessHook;
private TypeMapper typeMapper;
public LiveCdoFactory(GlobalIdFactory globalIdFactory, ObjectAccessHook objectAccessHook, TypeMapper typeMapper) {
this.globalIdFactory = globalIdFactory;
this.objectAccessHook = objectAccessHook;
this.typeMapper = typeMapper;
}
@Override
public LiveCdo create(Object cdo, OwnerContext owner) {
GlobalId globalId = globalIdFactory.createId(cdo, owner);
ManagedType managedType = typeMapper.getJaversManagedType(globalId);
Optional<ObjectAccessProxy> objectAccessor = objectAccessHook.createAccessor(cdo);
if (objectAccessor.isPresent()) {
return new LazyCdoWrapper(objectAccessor.get().getObjectSupplier(), globalId, managedType);
}
else {
return new LiveCdoWrapper(cdo, globalId, managedType);
}
}
@Override
public String typeDesc() {
return "li
```
<Overlap Ratio: 0.9902912621359223>

---

--- 123 --
Question ID: 65196942232bf864dc2c40e5226176c75b1b569b
Original Code:
```
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "power-outlets")
public class PowerOutletController {

    private final PowerOutletService powerOutletService;
    private final RoomService roomService;

    private ExecutorService executorService;

    @PostConstruct
    public void init() {
        executorService = Executors.newFixedThreadPool(4);
    }

    @GetMapping
    public List<PowerOutlet> getPowerOutlets() {
        ResponseEntity<Resources<Resource<PowerOutlet>>> response = powerOutletService.determinePowerOutlets();
        Collection<Resource<PowerOutlet>> content = response.getBody().getContent();
        Map<String, Room> rooms = determineRooms(content);
        return content.stream()
                .peek(resource -> resource.getContent().setRoom(rooms.get(resource.getLink("room").getHref())))
                .map(Resource::getContent)
                .collect(Collectors.toList());
    }

    private Map<String, Room> determineRooms(Collection<Resource<PowerOutlet>> powerOutlets) {
        return powerOutlets.stream()
                .map(resource -> resource.getLink("room"))
                .filter(Objects::nonNull)
                .map(Link::getHref)
                .distinct()
                .map(href -> new Entry<Callable<Room>>(href, () -> roomService.determineRoom(href)))
                .map(entry -> new Entry<>(entry.getKey(), executorService.submit(entry.getValue())))
                .collect(Collectors.toMap(Entry::getKey, this::resolveFuture));
    }

    private Room resolveFuture(Entry<Future<Room>> entry) {
        try {
            return entry.getValue().get();
        } catch(InterruptedException | ExecutionException e) {
            throw new RuntimeException(e);
        }
    }

    @RequiredArgsConstructor
    @Getter
    private static class Entry<V> {

        private final String key;
        private final V value;
    }
}
```


Overlapping Code:
```
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "power-outlets")
public class PowerOutletController {
private final PowerOutletService powerOutletService;
private final RoomService roomService;
private ExecutorService executorService;
@PostConstruct
public void init() {
executorService = Executors.newFixedThreadPool(4);
}
@GetMapping
public List<PowerOutlet> getPowerOutlets() {
ResponseEntity<Resources<Resource<PowerOutlet>>> response = powerOutletService.determinePowerOutlets();
Collection<Resource<PowerOutlet>> content = response.getBody().getContent();
Map<String, Room> rooms = determineRooms(content);
return content.stream()
.peek(resource -> resource.getContent().setRoom(rooms.get(resource.getLink("room").getHref())))
.map(Resource::getContent)
.collect(Collectors.toList());
}
private Map<String, Room> determineRooms(Collection<Resource<PowerOutlet>> powerOutlets) {
return powerOutlets.stream()
.map(resource -> resource.getLink("room"))
.filter(Objects::nonNull)
.map(Link::getHref)
.distinct()
.map(href -> new Entry<Callable<Room>>(href, () -> roomService.determineRoom(href)))
.map(entry -> new Entry<>(entry.getKey(), executorService.submit(entry.getValue())))
.collect(Collectors.toMap(Entry::getKey, this::resolveFuture));
}
private Room resolveFuture(Entry<Future<Room>> entry) {
try {
return entry.getValue().get();
} catch(InterruptedException | ExecutionException e) {
throw new RuntimeException(e);
}
}
@RequiredArgsConstructor
@Getter
private static class Entry<V> {
private final String key;
private final V value;
}

```
<Overlap Ratio: 0.9993614303959132>

---

--- 124 --
Question ID: b5a40d6269c865608889f42ae2f5245e048f80b4
Original Code:
```
public class TestIdUtils {

    private TestIdUtils() {
        // hide default constructor for this util class
    }

    /**
     * Get issue or test case ID.
     *
     * @param iMethod the {@link IMethodInstance} to check for test ID annotations.
     * @return Optional of either the {@link TestCaseId} or {@link Issue} value.
     * @throws IllegalStateException if {@link TestCaseId} and {@link Issue}
     *                               are specified inconstantly.
     */
    public static Optional<String> getIssueOrTestCaseIdValue(IMethodInstance iMethod) {
        Method method = iMethod.getMethod().getConstructorOrMethod().getMethod();
        return getIssueOrTestCaseIdValue(method);
    }

    /**
     * Get issue or test case ID for a method.
     *
     * @param method the method to check for test ID annotations.
     * @return Optional of the {@link TestCaseId} or {@link Issue} value.
     * @throws IllegalStateException if {@link TestCaseId} and {@link Issue}
     *                               are both specified inconstantly.
     */
    public static Optional<String> getIssueOrTestCaseIdValue(Method method) {
        TestCaseId tcIdAnnotation = method.getAnnotation(TestCaseId.class);
        Issue issueAnnotation = method.getAnnotation(Issue.class);

        if (!isNull(issueAnnotation) && !isNull(tcIdAnnotation)
                && !issueAnnotation.value().equals(tcIdAnnotation.value())) {
            throw new IllegalStateException(
                    "TestCaseId and Issue annotation are both specified but "
                            + "not equal for method: " + method.toString());
        }

        if (!isNull(issueAnnotation)) {
            return Optional.of(issueAnnotation.value());
        } else if (!isNull(tcIdAnnotation)) {
            return Optional.of(tcIdAnnotation.value());
        } else {
            return Optional.empty();
        }
    }
}
```


Overlapping Code:
```
blic class TestIdUtils {
private TestIdUtils() {
// hide default constructor for this util class
}
/**
* Get issue or test case ID.
*
* @param iMethod the {@link IMethodInstance} to check for test ID annotations.
* @return Optional of either the {@link TestCaseId} or {@link Issue} value.
* @throws IllegalStateException if {@link TestCaseId} and {@link Issue}
* are specified inconstantly.
*/
public static Optional<String> getIssueOrTestCaseIdValue(IMethodInstance iMethod) {
Method method = iMethod.getMethod().getConstructorOrMethod().getMethod();
return getIssueOrTestCaseIdValue(method);
}
/**
* Get issue or test case ID for a method.
*
* @param method the method to check for test ID annotations.
* @return Optional of the {@link TestCaseId} or {@link Issue} value.
* @throws IllegalStateException if {@link TestCaseId} and {@link Issue}
* are both specified inconstantly.
*/
public static Optional<String> getIssueOrTestCaseIdValue(Method method) {
TestCaseId tcIdAnnotation = method.getAnnotation(TestCaseId.class);
Issue issueAnnotation = method.getAnnotation(Issue.class);
if (!isNull(issueAnnotation) && !isNull(tcIdAnnotation)
&& !issueAnnotation.value().equals(tcIdAnnotation.value())) {
throw new IllegalStateException(
"TestCaseId and Issue annotation are both specified but "
+ "not equal for method: " + method.toString());
}
if (!isNull(issueAnnotation)) {
return Optional.of(issueAnnotation.value());
} else if (!isNull(tcIdAnnotation)) {
return Optional.of(tcIdAnnotation.value());
} else {
return Optional.empt
```
<Overlap Ratio: 0.9922330097087378>

---

--- 125 --
Question ID: 2ebab7cb01b49557e017b8651d2d407a72730046
Original Code:
```
public class House {

    private static final String PHRASE_01 = "that lay in the house that Jack built.\n";
    private static final String PHRASE_02 = "that killed the rat ";
    private static final String PHRASE_03 = "that worried the cat ";
    private static final String PHRASE_04 = "that ate the malt ";
    private static final String PHRASE_05 = "that milked the cow with the crumpled horn ";
    private static final String PHRASE_06 = "that kissed the maiden all forlorn ";
    private static final String PHRASE_07 = "that married the man all tattered and torn ";
    private static final String PHRASE_08 = "that woke the priest all shaven and shorn ";
    private static final String PHRASE_09 = "that tossed the dog ";

    private static final String SONG =
            "This is the house that Jack built.\n" + "This is the malt " + PHRASE_01 + "This is the rat " + PHRASE_04 + PHRASE_01
                    + "This is the cat " + PHRASE_02 + PHRASE_04 + PHRASE_01 + "This is the dog " + PHRASE_03 + PHRASE_02 + PHRASE_04
                    + PHRASE_01 + "This is the cow with the crumpled horn " + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01
                    + "This is the maiden all forlorn " + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01
                    + "This is the man all tattered and torn " + PHRASE_06 + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04
                    + PHRASE_01 + "This is the priest all shaven and shorn " + PHRASE_07 + PHRASE_06 + PHRASE_05 + PHRASE_09 + PHRASE_03
                    + PHRASE_02 + PHRASE_04 + PHRASE_01 + "This is the rooster that crowed in the morn " + PHRASE_08 + PHRASE_07 + PHRASE_06
                    + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01 + "This is the farmer sowing his corn "
                    + "that kept the rooster that crowed in the morn " + PHRASE_08 + PHRASE_07 + PHRASE_06 + PHRASE_05 + PHRASE_09
                    + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01 + "This is the horse and the hound and the horn "
                    + "that belonged to the farmer sowing his corn " + "that kept the rooster that crowed in the morn " + PHRASE_08
                    + PHRASE_07 + PHRASE_06 + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04
                    + "that lay in the house that Jack built.";

    private static final Map<Integer, String> SONG_MAP = new HashMap<>();

    static {
        String[] array = SONG.split("\n");

        for (int i = 0; i < array.length; i++) {
            SONG_MAP.put(i + 1, array[i]);
        }
    }

    public String verse(int verseNumber) {
        return SONG_MAP.get(verseNumber);
    }

    public String verses(int startVerse, int endVerse) {
        StringBuilder result = new StringBuilder();
        for (int i = startVerse; i < endVerse; i++) {
            result.append(SONG_MAP.get(i))
                  .append("\n");
        }
        result.append(SONG_MAP.get(endVerse));

        return result.toString();
    }

    String sing() {
        return SONG;
    }
}
```


Overlapping Code:
```
blic class House {
private static final String PHRASE_01 = "that lay in the house that Jack built.\n";
private static final String PHRASE_02 = "that killed the rat ";
private static final String PHRASE_03 = "that worried the cat ";
private static final String PHRASE_04 = "that ate the malt ";
private static final String PHRASE_05 = "that milked the cow with the crumpled horn ";
private static final String PHRASE_06 = "that kissed the maiden all forlorn ";
private static final String PHRASE_07 = "that married the man all tattered and torn ";
private static final String PHRASE_08 = "that woke the priest all shaven and shorn ";
private static final String PHRASE_09 = "that tossed the dog ";
private static final String SONG =
"This is the house that Jack built.\n" + "This is the malt " + PHRASE_01 + "This is the rat " + PHRASE_04 + PHRASE_01
+ "This is the cat " + PHRASE_02 + PHRASE_04 + PHRASE_01 + "This is the dog " + PHRASE_03 + PHRASE_02 + PHRASE_04
+ PHRASE_01 + "This is the cow with the crumpled horn " + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01
+ "This is the maiden all forlorn " + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01
+ "This is the man all tattered and torn " + PHRASE_06 + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04
+ PHRASE_01 + "This is the priest all shaven and shorn " + PHRASE_07 + PHRASE_06 + PHRASE_05 + PHRASE_09 + PHRASE_03
+ PHRASE_02 + PHRASE_04 + PHRASE_01 + "This is the rooster that crowed in the morn " + PHRASE_08 + PHRASE_07 + PHRASE_06
+ PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01 + "This is the farmer sowing his corn "
+ "that kept the rooster that crowed in the morn " + PHRASE_08 + PHRASE_07 + PHRASE_06 + PHRASE_05 + PHRASE_09
+ PHRASE_03 + PHRASE_02 + PHRASE_04 + PHRASE_01 + "This is the horse and the hound and the horn "
+ "that belonged to the farmer sowing his corn " + "that kept the rooster that crowed in the morn " + PHRASE_08
+ PHRASE_07 + PHRASE_06 + PHRASE_05 + PHRASE_09 + PHRASE_03 + PHRASE_02 + PHRASE_04
+ "that lay in the house that Jack built.";
private static final Map<Integer, String> SONG_M
```
<Overlap Ratio: 0.9830818472793782>

---

--- 126 --
Question ID: c96f341573c717c518981a462ea0eb6b95407430
Original Code:
```
public class BatteryFragment extends RecyclerViewFragment implements
PopupCardView.DPopupCard.OnDPopupCardListener, SwitchCardView.DSwitchCard.OnDSwitchCardListener, SeekBarCardView.DSeekBarCard.OnDSeekBarCardListener {

    private int bclFreqCount = 0, bclArraylist = 60, bclFreqValue = 0;
    private List < Integer > Cpufreqs;

    private CardViewItem.DCardView mBatteryLevelCard, mBatteryVoltageCard, mBatteryTemperature, mBatteryChargingCurrentCard, mBatteryChargingTypeCard, mBatteryHealthCard;

    private SwitchCardView.DSwitchCard mForceFastChargeCard, mBatteryLedCard;
    private SwitchCardView.DSwitchCard mBclCard, mBclHotplugCard, mColdDisablerCard;

    private PopupCardView.DPopupCard mBclMaxFreqCard;
    private PopupCardView.DPopupCard mBclHotmask;
    private SeekBarCardView.DSeekBarCard mBclVphLowCard, mBclVphHighCard;

    private SeekBarCardView.DSeekBarCard mBlxCard;

    private SwitchCardView.DSwitchCard mCustomChargeRateEnableCard;
    private SeekBarCardView.DSeekBarCard mChargingRateCard;

    private SwitchCardView.DSwitchCard mC0StateCard, mC1StateCard, mC2StateCard, mC3StateCard;

    private SwitchCardView.DSwitchCard mDeviceidle, mDeviceidlelight, mDeviceidledeep;

    @Override
    public void init(Bundle savedInstanceState) {
        super.init(savedInstanceState);

        if (Battery.hasBatteryLed()) BatteryLedInit();
        batteryLevelInit();
        batteryHealthInit();
        batteryVoltageInit();
        batteryChargingCurrentInit();
        batteryTemperatureInit();
        batteryChargingTypeInit();
        if (Battery.hasColdDisabler()) bclColdDisablerInit();
        if (Battery.hasForceFastCharge()) forceFastChargeInit();
        if (Battery.hasBlx()) blxInit();
        if (Battery.hasChargeRate()) chargerateInit();

        if (Battery.hasBcl()) bclInit();
        if (Battery.hasBclFreq()) bclMaxFreqInit();
        if (Battery.hasBclHotMask()) bclHotmask();
        if (Battery.hasBclVphLow()) BclVphLowInit();
        if (Battery.hasBclVphHigh()) BclVphHighInit();
        if (Battery.hasBclHotplug()) bclHotplugInit();

        DeviceidleInit();
        cstatesInit();
        Update();
    }

    @Override
    public void postInit(Bundle savedInstanceState) {
        super.postInit(savedInstanceState);
        if (getCount() < 4) showApplyOnBoot(false);
    }

    private void batteryLevelInit() {
        mBatteryLevelCard = new CardViewItem.DCardView();
        mBatteryLevelCard.setTitle(getString(R.string.battery_level));

        addView(mBatteryLevelCard);
    }

    private void BatteryLedInit() {
        mBatteryLedCard = new SwitchCardView.DSwitchCard();
        mBatteryLedCard.setTitle(getString(R.string.battery_led));
        mBatteryLedCard.setDescription(getString(R.string.battery_led_summary));
        mBatteryLedCard.setChecked(Battery.getBatteryLed());
        mBatteryLedCard.setOnDSwitchCardListener(this);

        addView(mBatteryLedCard);
    }

    private void batteryVoltageInit() {
        mBatteryVoltageCard = new CardViewItem.DCardView();
        mBatteryVoltageCard.setTitle(getString(R.string.battery_voltage));

        addView(mBatteryVoltageCard);
    }

    private void batteryTemperatureInit() {
        mBatteryTemperature = new CardViewItem.DCardView();
        mBatteryTemperature.setTitle(getString(R.string.battery_temperature));

        addView(mBatteryTemperature);
    }

    private void batteryChargingCurrentInit() {
        mBatteryChargingCurrentCard = new CardViewItem.DCardView();
        mBatteryChargingCurrentCard.setTitle(getString(R.string.battery_charging_current));

        addView(mBatteryChargingCurrentCard);
    }

    private void batteryChargingTypeInit() {
        mBatteryChargingTypeCard = new CardViewItem.DCardView();
        mBatteryChargingTypeCard.setTitle(getString(R.string.battery_charging_mode));

        addView(mBatteryChargingTypeCard);
    }

    private void batteryHealthInit() {
        mBatteryHealthCard = new CardViewItem.DCardView();
        mBatteryHealthCard.setTitle(getString(R.string.battery_health));

        addView(mBatteryHealthCard);
    }

    private void forceFastChargeInit() {
        mForceFastChargeCard = new SwitchCardView.DSwitchCard();
        mForceFastChargeCard.setTitle(getString(R.string.usb_fast_charge));
        mForceFastChargeCard.setDescription(getString(R.string.usb_fast_charge_summary));
        mForceFastChargeCard.setChecked(Battery.isForceFastChargeActive());
        mForceFastChargeCard.setOnDSwitchCardListener(this);

        addView(mForceFastChargeCard);
    }

    private void blxInit() {
        List < String > list = new ArrayList < > ();
        for (int i = 0; i < 101; i++) list.add(String.valueOf(i));

        mBlxCard = new SeekBarCardView.DSeekBarCard(list);
        mBlxCard.setTitle(getString(R.string.blx));
        mBlxCard.setDescription(getString(R.string.blx_summary));
        mBlxCard.setProgress(Battery.getCurBlx());
        mBlxCard.setOnDSeekBarCardListener(this);

        addView(mBlxCard);
    }

    private void chargerateInit() {

        if (Battery.hasCustomChargeRateEnable()) {
            mCustomChargeRateEnableCard = new SwitchCardView.DSwitchCard();
            mCustomChargeRateEnableCard.setDescription(getString(R.string.custom_charge_rate));
            mCustomChargeRateEnableCard.setChecked(Battery.isCustomChargeRateActive());
            mCustomChargeRateEnableCard.setOnDSwitchCardListener(this);

            addView(mCustomChargeRateEnableCard);
        }

        if (Battery.hasChargingRate()) {
            List < String > list = new ArrayList < > ();
            for (int i = 10; i < 151; i++) list.add((i * 10) + getString(R.string.ma));

            mChargingRateCard = new SeekBarCardView.DSeekBarCard(list);
            mChargingRateCard.setTitle(getString(R.string.charge_rate));
            mChargingRateCard.setDescription(getString(R.string.charge_rate_summary));
            mChargingRateCard.setProgress((Battery.getChargingRate() / 10) - 10);
            mChargingRateCard.setOnDSeekBarCardListener(this);

            addView(mChargingRateCard);
        }
    }

    private void bclInit() {
        DDivider mBclDivider = new DDivider();
        mBclDivider.setText(getString(R.string.bcl));
        addView(mBclDivider);

        mBclCard = new SwitchCardView.DSwitchCard();
        mBclCard.setTitle(getString(R.string.bcl));
        mBclCard.setDescription(getString(R.string.bcl_summary));
        mBclCard.setChecked(Battery.isBclActive());
        mBclCard.setOnDSwitchCardListener(this);

        addView(mBclCard);
    }

    private void bclMaxFreqInit() {
        bclFreqCount = 0;
        List < String > freqs = new ArrayList < > ();
        Cpufreqs = CPU.getFreqs();
        for (int freq: Cpufreqs) {
            if (freq >= Battery.getBclLimitFreq()) {
                bclFreqCount++;
                freqs.add(freq / 1000 + getString(R.string.mhz));
            }
        }

        // replace top freq with a disable
        freqs.set(freqs.size() - 1, getString(R.string.disabled));

        mBclMaxFreqCard = new PopupCardView.DPopupCard(freqs);
        mBclMaxFreqCard.setTitle(getString(R.string.bcl_max_freq));
        mBclMaxFreqCard.setDescription(getString(R.string.bcl_max_freq_summary));

        bclFreqValue = Battery.getBclFreq();
        if (bclFreqValue == Cpufreqs.get((Cpufreqs.size() - 1))) mBclMaxFreqCard.setItem(getString(R.string.disabled));
        else mBclMaxFreqCard.setItem(bclFreqValue / 1000 + getString(R.string.mhz));

        mBclMaxFreqCard.setOnDPopupCardListener(this);

        addView(mBclMaxFreqCard);
    }

    private void bclHotmask() {
        mBclHotmask = new PopupCardView.DPopupCard(new ArrayList < > (
            Arrays.asList(getResources().getStringArray(R.array.bcl_hot_plug))));
        mBclHotmask.setTitle(getString(R.string.bcl_cores));
        mBclHotmask.setDescription(getString(R.string.bcl_cores_summary));
        mBclHotmask.setItem(Battery.getBclHotMask());
        mBclHotmask.setOnDPopupCardListener(this);

        addView(mBclHotmask);
    }

    private void BclVphLowInit() {
        int position = 0;
        List < String > list = new ArrayList < > ();
        for (int i = 0; i < 30; i++) {
            position = ((i + bclArraylist) * 50);
            list.add(String.valueOf(position + getString(R.string.mv)));
        }

        mBclVphLowCard = new SeekBarCardView.DSeekBarCard(list);
        mBclVphLowCard.setTitle(getString(R.string.bcl_voltage_low));
        mBclVphLowCard.setDescription(getString(R.string.bcl_voltage_low_summary));
        mBclVphLowCard.setProgress((((Battery.getBclVphLow()) / 1000) - (bclArraylist * 50)) / 50);
        mBclVphLowCard.setOnDSeekBarCardListener(this);

        addView(mBclVphLowCard);
    }

    private void BclVphHighInit() {
        int position = 0;
        List < String > list = new ArrayList < > ();
        for (int i = 0; i < 30; i++) {
            position = ((i + bclArraylist) * 50);
            list.add(String.valueOf(position + getString(R.string.mv)));
        }

        mBclVphHighCard = new SeekBarCardView.DSeekBarCard(list);
        mBclVphHighCard.setTitle(getString(R.string.bcl_voltage_high));
        mBclVphHighCard.setDescription(getString(R.string.bcl_voltage_high_summary));
        mBclVphHighCard.setProgress((((Battery.getBclVphHigh()) / 1000) - (bclArraylist * 50)) / 50);
        mBclVphHighCard.setOnDSeekBarCardListener(this);

        addView(mBclVphHighCard);
    }

    private void bclHotplugInit() {
        mBclHotplugCard = new SwitchCardView.DSwitchCard();
        mBclHotplugCard.setTitle(getString(R.string.bcl_hotplug));
        mBclHotplugCard.setDescription(getString(R.string.bcl_hotplug_summary));
        mBclHotplugCard.setChecked(Battery.isBclHotplugActive());
        mBclHotplugCard.setOnDSwitchCardListener(this);

        addView(mBclHotplugCard);
    }

    private void bclColdDisablerInit() {
        mColdDisablerCard = new SwitchCardView.DSwitchCard();
        mColdDisablerCard.setTitle(getString(R.string.battery_health_cold_disabler));
        mColdDisablerCard.setDescription(getString(R.string.battery_health_cold_disabler_summary));
        mColdDisablerCard.setChecked(Battery.isBclHotplugActive());
        mColdDisablerCard.setOnDSwitchCardListener(this);

        addView(mColdDisablerCard);
    }

    private void DeviceidleInit() {
        List < DAdapter.DView > views = new ArrayList < > ();

        if (Battery.hasDeviceidle()) {
            mDeviceidle = new SwitchCardView.DSwitchCard();
            mDeviceidle.setTitle(getString(R.string.deviceidle_doze));
            mDeviceidle.setDescription(getString(R.string.deviceidle_doze_summary));
            mDeviceidle.setChecked(Battery.isDeviceidleActive());
            mDeviceidle.setOnDSwitchCardListener(this);

            views.add(mDeviceidle);
        }

        if (Battery.hasDeviceidlelight()) {
            mDeviceidlelight = new SwitchCardView.DSwitchCard();
            mDeviceidlelight.setTitle(getString(R.string.deviceidle_doze_light));
            mDeviceidlelight.setDescription(getString(R.string.deviceidle_doze_light_summary));
            mDeviceidlelight.setChecked(Battery.isDeviceidlelightActive());
            mDeviceidlelight.setOnDSwitchCardListener(this);

            views.add(mDeviceidlelight);
        }

        if (Battery.hasDeviceidledeep()) {
            mDeviceidledeep = new SwitchCardView.DSwitchCard();
            mDeviceidledeep.setTitle(getString(R.string.deviceidle_doze_deep));
            mDeviceidledeep.setDescription(getString(R.string.deviceidle_doze_deep_summary));
            mDeviceidledeep.setChecked(Battery.isDeviceidledeepActive());
            mDeviceidledeep.setOnDSwitchCardListener(this);

            views.add(mDeviceidledeep);
        }

        if (views.size() > 0) {
            DDivider mDeviceidleCard = new DDivider();
            mDeviceidleCard.setText(getString(R.string.deviceidle));
            mDeviceidleCard.setDescription(getString(R.string.deviceidle_summary));
            addView(mDeviceidleCard);

            addAllViews(views);
        }
    }

    private void cstatesInit() {
        List < DAdapter.DView > views = new ArrayList < > ();

        if (Battery.hasC0State()) {
            mC0StateCard = new SwitchCardView.DSwitchCard();
            mC0StateCard.setTitle(getString(R.string.c0state));
            mC0StateCard.setDescription(getString(R.string.c0state_summary));
            mC0StateCard.setChecked(Battery.isC0StateActive());
            mC0StateCard.setOnDSwitchCardListener(this);

            views.add(mC0StateCard);
        }

        if (Battery.hasC1State()) {
            mC1StateCard = new SwitchCardView.DSwitchCard();
            mC1StateCard.setTitle(getString(R.string.c1state));
            mC1StateCard.setDescription(getString(R.string.c1state_summary));
            mC1StateCard.setChecked(Battery.isC1StateActive());
            mC1StateCard.setOnDSwitchCardListener(this);

            views.add(mC1StateCard);
        }

        if (Battery.hasC2State()) {
            mC2StateCard = new SwitchCardView.DSwitchCard();
            mC2StateCard.setTitle(getString(R.string.c2state));
            mC2StateCard.setDescription(getString(R.string.c2state_summary));
            mC2StateCard.setChecked(Battery.isC2StateActive());
            mC2StateCard.setOnDSwitchCardListener(this);

            views.add(mC2StateCard);
        }

        if (Battery.hasC3State()) {
            mC3StateCard = new SwitchCardView.DSwitchCard();
            mC3StateCard.setTitle(getString(R.string.c3state));
            mC3StateCard.setDescription(getString(R.string.c3state_summary));
            mC3StateCard.setChecked(Battery.isC3StateActive());
            mC3StateCard.setOnDSwitchCardListener(this);

            views.add(mC3StateCard);
        }

        if (views.size() > 0) {
            DDivider mCstatesCard = new DDivider();
            mCstatesCard.setText(getString(R.string.cstates));
            addView(mCstatesCard);

            addAllViews(views);
        }
    }

    @Override
    public void onItemSelected(PopupCardView.DPopupCard dPopupCard, int position) {
        if (dPopupCard == mBclMaxFreqCard)
            Battery.setBclFreq(Cpufreqs.get((Cpufreqs.size() - bclFreqCount) + position), getActivity());
        if (dPopupCard == mBclHotmask)
            Battery.setBclHotMask(position, getActivity());
    }

    @Override
    public boolean onRefresh() {
        Update();
        return true;
    }

    public void Update() {
        if (mBclMaxFreqCard != null) {
            bclFreqValue = Battery.getBclFreq();
            if (bclFreqValue == Cpufreqs.get((Cpufreqs.size() - 1))) mBclMaxFreqCard.setItem(getString(R.string.disabled));
            else mBclMaxFreqCard.setItem(bclFreqValue / 1000 + getString(R.string.mhz));
        }
        if (mBclHotmask != null) mBclHotmask.setItem(Battery.getBclHotMask());
        if (mBatteryLevelCard != null) mBatteryLevelCard.setDescription(Battery.getBatteryLevel() + getString(R.string.percent));
        if (mBatteryChargingCurrentCard != null) {
            double amperage = (double) Battery.getChargingCurrent() / 1000;
            if (amperage < 0) mBatteryChargingCurrentCard.setDescription(amperage + getString(R.string.ma));
            else mBatteryChargingCurrentCard.setDescription("+" + amperage + getString(R.string.ma));
        }
        if (mBatteryVoltageCard != null) {
            double voltage_now = (double) Battery.getBatteryVoltageNow() / 1000;
            mBatteryVoltageCard.setDescription(voltage_now + getString(R.string.mv));
        }
        if (mBatteryTemperature != null) {
            double celsius = (double) Battery.getBatteryTemp() / 10;
            mBatteryTemperature.setDescription(Utils.formatCelsius(celsius) + " " + Utils.celsiusToFahrenheit(celsius));
        }
        if (mBatteryChargingTypeCard != null) {
            if (Battery.getChargingType().equals("None"))
                mBatteryChargingTypeCard.setDescription(getString(R.string.battery_charging_mode_none));
            else if (Battery.getChargingType().equals("Weak"))
                mBatteryChargingTypeCard.setDescription(getString(R.string.battery_charging_mode_weak));
            else mBatteryChargingTypeCard.setDescription(Battery.getChargingType());
        }
        if (mBatteryLedCard != null)
            mBatteryLedCard.setChecked(Battery.getBatteryLed());
        if (mBatteryHealthCard != null)
            mBatteryHealthCard.setDescription(Battery.getHealth());
        if (mBclCard != null)
            mBclCard.setChecked(Battery.isBclActive());
        if (mBclHotplugCard != null)
            mBclHotplugCard.setChecked(Battery.isBclHotplugActive());
        if (mColdDisablerCard != null)
            mColdDisablerCard.setChecked(Battery.isColdDisablerActive());
        if (mBclVphHighCard != null)
            mBclVphHighCard.setProgress((((Battery.getBclVphHigh()) / 1000) - (bclArraylist * 50)) / 50);
        if (mBclVphLowCard != null)
            mBclVphLowCard.setProgress((((Battery.getBclVphLow()) / 1000) - (bclArraylist * 50)) / 50);

        if (mDeviceidle != null)
            mDeviceidle.setChecked(Battery.isDeviceidleActive());
        if (mDeviceidlelight != null)
            mDeviceidlelight.setChecked(Battery.isDeviceidlelightActive());
        if (mDeviceidledeep != null)
            mDeviceidledeep.setChecked(Battery.isDeviceidledeepActive());
    }

    @Override
    public void onChecked(SwitchCardView.DSwitchCard dSwitchCard, boolean checked) {
        if (dSwitchCard == mForceFastChargeCard) Battery.activateForceFastCharge(checked, getActivity());
        else if (dSwitchCard == mCustomChargeRateEnableCard) Battery.activateCustomChargeRate(checked, getActivity());
        else if (dSwitchCard == mC0StateCard) Battery.activateC0State(checked, getActivity());
        else if (dSwitchCard == mC1StateCard) Battery.activateC1State(checked, getActivity());
        else if (dSwitchCard == mC2StateCard) Battery.activateC2State(checked, getActivity());
        else if (dSwitchCard == mC3StateCard) Battery.activateC3State(checked, getActivity());
        else if (dSwitchCard == mBatteryLedCard) Battery.setBatteryLed(checked, getActivity());
        else if (dSwitchCard == mBclCard) Battery.activateBcl(checked, getActivity());
        else if (dSwitchCard == mBclHotplugCard) Battery.activateBclHotplug(checked, getActivity());
        else if (dSwitchCard == mColdDisablerCard) Battery.activateColdDisabler(checked, getActivity());
        else if (dSwitchCard == mDeviceidle) Battery.activateDeviceidle(checked, getActivity());
        else if (dSwitchCard == mDeviceidlelight) Battery.activateDeviceidlelight(checked, getActivity());
        else if (dSwitchCard == mDeviceidledeep) Battery.activateDeviceidledeep(checked, getActivity());
    }

    @Override
    public void onChanged(SeekBarCardView.DSeekBarCard dSeekBarCard, int position) {}

    @Override
    public void onStop(SeekBarCardView.DSeekBarCard dSeekBarCard, int position) {
        if (dSeekBarCard == mBlxCard)
            Battery.setBlx(position, getActivity());
        else if (dSeekBarCard == mChargingRateCard)
            Battery.setChargingRate((position * 10) + 100, getActivity());
        else if (dSeekBarCard == mBclVphLowCard)
            Battery.setBclVphLow((position + bclArraylist) * 50000, getActivity());
        else if (dSeekBarCard == mBclVphHighCard)
            Battery.setBclVphHigh((position + bclArraylist) * 50000, getActivity());
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
    }
}
```


Overlapping Code:
```
ublic class BatteryFragment extends RecyclerViewFragment implements
PopupCardView.DPopupCard.OnDPopupCardListener, SwitchCardView.DSwitchCard.OnDSwitchCardListener, SeekBarCardView.DSeekBarCard.OnDSeekBarCardListener {
private int bclFreqCount = 0, bclArraylist = 60, bclFreqValue = 0;
private List < Integer > Cpufreqs;
private CardViewItem.DCardView mBatteryLevelCard, mBatteryVoltageCard, mBatteryTemperature, mBatteryChargingCurrentCard, mBatteryChargingTypeCard, mBatteryHealthCard;
private SwitchCardView.DSwitchCard mForceFastChargeCard, mBatteryLedCard;
private SwitchCardView.DSwitchCard mBclCard, mBclHotplugCard, mColdDisablerCard;
private PopupCardView.DPopupCard mBclMaxFreqCard;
private PopupCardView.DPopupCard mBclHotmask;
private SeekBarCardView.DSeekBarCard mBclVphLowCard, mBclVphHighCard;
private SeekBarCardView.DSeekBarCard mBlxCard;
private SwitchCardView.DSwitchCard mCustomChargeRateEnableCard;
private SeekBarCardView.DSeekBarCard mChargingRateCard;
private SwitchCardView.DSwitchCard mC0StateCard, mC1StateCard, mC2StateCard, mC3StateCard;
private SwitchCardView.DSwitchCard mDeviceidle, mDeviceidlelight, mDeviceidledeep;
@Override
public void init(Bundle savedInstanceState) {
super.init(savedInstanceState);
if (Battery.hasBatteryLed()) BatteryLedInit();
batteryLevelInit();
batteryHealthInit();
batteryVoltageInit();
batteryChargingCurrentInit();
batteryTemperatureInit();
batteryChargingTypeInit();
if (Battery.hasColdDisabler()) bclColdDisablerInit();
if (Battery.hasForceFastCharge()) forceFastChargeInit();
if (Battery.hasBlx()) blxInit();
if (Battery.hasChargeRate()) chargerateInit();
if (Battery.hasBcl()) bclInit();
if (Battery.hasBclFreq()) bclMaxFreqInit();
if (Battery.hasBclHotMask()) bclHotmask();
if (Battery.hasBclVphLow()) BclVphLowInit();
if (Battery.hasBclVphHigh()) BclVphHighInit();
if (Battery.hasBclHotplug()) bclHotplugInit();
DeviceidleInit();
cstatesInit();
Update();
}
@Override
public void postInit(Bundle savedInstanceState) {
super.postInit(savedInstanceState);
if (getCount() < 4) showApplyOnBoot(false);
}
private void batteryLevelInit() {
mBatteryLevelCard = new CardViewItem.DCardView();
mBatteryLevelCard.
```
<Overlap Ratio: 0.9841269841269841>

---

--- 127 --
Question ID: 60a2cd4914e90ab72f60c9ce9f09bb0aea6eca91
Original Code:
```
class Node {
    Node left, right;
    int data;

    public Node(int data) {
        this.data = data;
    }

    public void insert (int value) {
        if (value < data) {
            if (left == null) {
                left = new Node(value);
            }
            else {
                left.insert(value);
            }
        }
        else {
            if (right == null) {
                right = new Node(value);
            }
            else {
                right.insert(value);
            }
        }
    }

    public void printInOrder() {
        if (left != null) {
            left.printInOrder();
        }
        System.out.print(data + " ");
        if (right != null) {
            right.printInOrder();
        }
    }

    public void printPreOrder() {
        System.out.print(data + " ");
        if (left != null) {
            left.printPreOrder();
        }
        if (right != null) {
            right.printPreOrder();
        }
    }

    public void printPostOrder() {
        if (left != null) {
            left.printPostOrder();
        }
        if (right != null) {
            right.printPostOrder();
        }
        System.out.print(data + " ");
    }

    /**
    * O(n) time algorithm.
    * Uses O(n) space to store nodes in a queue to aid in traversal.
    */
    public void printLevelOrder() {
        LinkedList<Node> queue = new LinkedList<>();
        queue.add(this);
        while (queue.size() > 0) {
            Node head = queue.remove();
            System.out.print(head.data + " ");
            // Add children of recently-printed node to queue, if they exist.
            if (head.left != null) {
                queue.add(head.left);
            }
            if (head.right != null) {
                queue.add(head.right);
            }
        }
    }
}
```


Overlapping Code:
```
ss Node {
Node left, right;
int data;
public Node(int data) {
this.data = data;
}
public void insert (int value) {
if (value < data) {
if (left == null) {
left = new Node(value);
}
else {
left.insert(value);
}
}
else {
if (right == null) {
right = new Node(value);
}
else {
right.insert(value);
}
}
}
public void printInOrder() {
if (left != null) {
left.printInOrder();
}
System.out.print(data + " ");
if (right != null) {
right.printInOrder();
}
}
public void printPreOrder() {
System.out.print(data + " ");
if (left != null) {
left.printPreOrder();
}
if (right != null) {
right.printPreOrder();
}
}
public void printPostOrder() {
if (left != null) {
left.printPostOrder();
}
if (right != null) {
right.printPostOrder();
}
System.out.print(data + " ");
}
/**
* O(n) time algorithm.
* Uses O(n) space to store nodes in a queue to aid in traversal.
*/
public void printLevelOrder() {
LinkedList<Node> queue = new LinkedList<>();
queue.add(this);
while (queue.size() > 0) {
Node head = queue.remove();
System.out.print(head.data + " ");
// Add children of recently-printed node to queue, if they exist.
if (head.left != null) {
queue.add(head.left);
}
if (head.right != null) {
queue.add(head.right);
}
}
```
<Overlap Ratio: 0.9942148760330578>

---

--- 128 --
Question ID: 822fe555017e61c5d3fad515cf03a0e47c935187
Original Code:
```
public class Server {

    /*
        INITIAL CONSTANTS/VARS
     */
    private SocketAddress addr;
    private ServerSocketChannel server;
    private Selector selector;

    //This handles incoming requests.
    private RequestHandler requestHandler;

    private final static int bufferSize = 512;

    //Stores users that have been authorized.
    private static BiMap<User, SelectionKey> clients = HashBiMap.create();

    //The database
    public Mongo mongo;




    /**
     * Initializes a non-blocking asynchronous Server object.
     * Binds a new Socket to a provided address and begins listening on a new thread.
     * @param port Start the server on this port.
     * @param ip Start the server on this IP.
     * @throws IOException
     */
    public Server(int port, String ip, Mongo mongo) throws IOException {

        if(selector != null) return;
        if(server != null) return;

        //Setup & bind on address (ip, port)
        selector = Selector.open();
        server = ServerSocketChannel.open();
        server.configureBlocking(false);


        //Begin listening for incoming connections
        addr = new InetSocketAddress(ip, port);
        server.socket().bind(addr);

        //Create a new request handler
        requestHandler = new RequestHandler(mongo);

        //set the db
        this.mongo = mongo;

        //Set up the selection key
        server.register(selector, SelectionKey.OP_ACCEPT);

        System.out.println("Server has been opened at " + ip + ":" + port);

        //Start the server in another thread.
        run();

    }

    public void run() {

        while (true) {
            try {
                selector.select();
            }
            //Client has closed connection
            catch(IOException ex) {
                ex.printStackTrace();
                return;
            }

            //Maintains a request for every channel
            Set<SelectionKey> selectedKeys = selector.selectedKeys();
            Iterator<SelectionKey> iter = selectedKeys.iterator();

            while (iter.hasNext()) {
                SelectionKey key = iter.next();

                if(!key.isValid()) {
                    continue;
                }

                if (key.isAcceptable()) {
                    accept(selector);

                } else if (key.isWritable()) {
                    write(key);

                } else if (key.isReadable()) {
                    read(key);
                }

                //Remove the request from the Set
                iter.remove();
            }
        }
    }


    /*
     * Accepts a new client connection and creates a new socket
     * for the client. Then, tells the server to read from the client.
     */
    private void accept(Selector selector) {
        try {

            SocketChannel client = server.accept();
            //Disable blocking on new client channel
            client.configureBlocking(false);
            //Tell the server to wait & read from the client
            SelectionKey key = client.register(selector, SelectionKey.OP_READ);
            addUser(key);

        }
        catch(IOException ex) {
            ex.printStackTrace();
        }
    }

    private void disconnect(SelectionKey key) {
        User user = clients.inverse().get(key);
        clients.remove(user);
        clients.remove(key);
        key.cancel();

        FetchActiveUsers.broadcastUserList(this, null);
    }

    private void read(SelectionKey key) {
        User user = getUser(key);
        SocketChannel client = user.getChannel();

        try {

            //Read from the socket
            ByteBuffer buffer = ByteBuffer.allocate(bufferSize);
            int read = client.read(buffer);

            //If there was anything in the read buffer...
            if(read > 0) {

                String data = new String(buffer.array(), "UTF-8");

                //Prune null values from the string.
                data = data.replaceAll("\u0000.*,", "");

                System.out.println(data);

                requestHandler.handleRequest(this, user, data);
                //ResponseHandler.handleResponse(this, user, response);

                //Write to the client if there are any messages to be sent
                if(user.hasMessages()) {
                    key.interestOps(SelectionKey.OP_WRITE);
                }
            }
        }
        catch(IOException ex) {
            ex.printStackTrace();
            disconnect(key);
        }
    }


    private void write(SelectionKey key) {

        User user = getUser(key);
        SocketChannel client = user.getChannel();

        try {

            //Get next message in queue belonging to THIS client channel & remove it
            ArrayList<String> messages = user.getMessages();
            while(!messages.isEmpty()) {
                String message = messages.remove(0) + "\r\n";
                System.out.println("Sending to client: " + message);
                client.write(ByteBuffer.wrap(message.getBytes()));
            }

            key.interestOps(SelectionKey.OP_READ);
        }
        catch(IOException ex) {
            ex.printStackTrace();
            disconnect(key);
        }
        //For now NullPointerException would be thrown if the server doesn't write back to the client.
        catch(NullPointerException ex) {
            ex.printStackTrace();
            key.interestOps(SelectionKey.OP_READ);
        }
    }

    /*
        UTILS
        ====
     */
    /**
     * Add a message to the message queue that will be sent next time
     * the server is writing to the client.
     * @param key the client that should be sent the message.
     * @param message the actual message.
     */
    public void pushMessage(SelectionKey key, String message) {
        User user = getUser(key);
        user.queueMessage(message);
    }

    /**
     * Adds a message to the message queue and tells the server to send the queue
     * to the client, given the username.
     * @param user the username to send the queue.
     * @param message the actual message.
     * @return true if the message was sent, otherwise false (invalid user was provided)
     */
    public boolean send(User user, String message) {
        SelectionKey key = user.getKey();
        pushMessage(key, message);
        if(key.isValid()) {
            key.interestOps(SelectionKey.OP_WRITE);
            return true;
        }
        return false;
    }


    /**
     * Returns a list of the currently connected users.
     * @return Set<String>
     */
    public Set<User> getClientList() {
        return clients.keySet();
    }

    /**
     * Adds a new client to the connected users list.
     * @param username the username of the client to add.
     * @param key the key belonging to the client.
     */
    public User addUser(String username, SelectionKey key) {
        User user = new User(key);
        user.setUsername(username);

        clients.put(user, key);
        return user;
    }

    /**
     * Adds a new user when the username is unknown
     * @param key
     */
    public User addUser(SelectionKey key) {
        User user = new User(key);
        clients.put(user, key);
        return user;
    }

    /**
     * Returns the username of a client, given their key.
     * @param key the key of the client.
     * @return the username as a String.
     */
    public User getUser(SelectionKey key) {
        if(clients.inverse().containsKey(key)) {
            return clients.inverse().get(key);
        }
        return addUser(key);
    }

}
```


Overlapping Code:
```
ITIAL CONSTANTS/VARS
*/
private SocketAddress addr;
private ServerSocketChannel server;
private Selector selector;
//This handles incoming requests.
private RequestHandler requestHandler;
private final static int bufferSize = 512;
//Stores users that have been authorized.
private static BiMap<User, SelectionKey> clients = HashBiMap.create();
//The database
public Mongo mongo;
/**
* Initializes a non-blocking asynchronous Server object.
* Binds a new Socket to a provided address and begins listening on a new thread.
* @param port Start the server on this port.
* @param ip Start the server on this IP.
* @throws IOException
*/
public Server(int port, String ip, Mongo mongo) throws IOException {
if(selector != null) return;
if(server != null) return;
//Setup & bind on address (ip, port)
selector = Selector.open();
server = ServerSocketChannel.open();
server.configureBlocking(false);
//Begin listening for incoming connections
addr = new InetSocketAddress(ip, port);
server.socket().bind(addr);
//Create a new request handler
requestHandler = new RequestHandler(mongo);
//set the db
this.mongo = mongo;
//Set up the selection key
server.register(selector, SelectionKey.OP_ACCEPT);
System.out.println("Server has been opened at " + ip + ":" + port);
//Start the server in another thread.
run();
}
public void run() {
while (true) {
try {
selector.select();
}
//Client has closed connection
catch(IOException ex) {
ex.printStackTrace();
return;
}
//Maintains a request for every channel
Set<SelectionKey> selectedKeys = selector.selectedKeys();
Iterator<SelectionKey> iter = selectedKeys.iterator();
while (iter.hasNext()) {
SelectionKey key = iter.next();
if(!key.isValid()) {
continue;
}
if (key.isAcceptable()) {
accept(selector);
} else if (key.isWritable()) {
write(key);
} else if (key.isReadable()) {
read(key);
}
```
<Overlap Ratio: 0.9854290339989207>

---

--- 129 --
Question ID: 866183579d23753b98110009f3dd7b056e5fd23c
Original Code:
```
public class MockJMSSession implements Session, QueueSession, TopicSession, AutoCloseable {

    private final AtomicBoolean closed = new AtomicBoolean();
    private final AtomicBoolean started = new AtomicBoolean();
    private final ReentrantLock sendLock = new ReentrantLock();

    private final Map<String, MockJMSMessageProducer> producers = new ConcurrentHashMap<>();
    private final Map<String, MockJMSMessageConsumer> consumers = new ConcurrentHashMap<>();

    private final Set<MockJMSSessionListener> sessionListeners = new HashSet<>();

    private final String sessionId;
    private final int sessionMode;
    private final MockJMSConnection connection;

    private final AtomicLong consumerIdGenerator = new AtomicLong();
    private final AtomicLong producerIdGenerator = new AtomicLong();

    private MessageListener messageListener;

    public MockJMSSession(String sessionId, int sessionMode, MockJMSConnection connection) {
        this.sessionMode = sessionMode;
        this.connection = connection;
        this.sessionId = sessionId;
    }

    @Override
    public void close() throws JMSException {
        if (closed.compareAndSet(false, true)) {
            connection.removeSession(this);

            for (MockJMSMessageProducer producer : producers.values()) {
                producer.close();
            }

            for (MockJMSMessageConsumer consumer : consumers.values()) {
                consumer.close();
            }

            for (MockJMSSessionListener listener : sessionListeners) {
                listener.onSessionClosed(this);
            }
        }
    }

    public void start() throws JMSException {
    }

    public void stop() throws JMSException {
    }

    @Override
    public boolean getTransacted() throws JMSException {
        checkClosed();
        return sessionMode == SESSION_TRANSACTED;
    }

    @Override
    public int getAcknowledgeMode() throws JMSException {
        checkClosed();
        return sessionMode;
    }

    @Override
    public void commit() throws JMSException {
        checkClosed();

        if (!getTransacted()) {
            throw new IllegalStateException("Session is not transacted");
        }

        for (MockJMSSessionListener listener : sessionListeners) {
            listener.onSessionCommit(this);
        }
    }

    @Override
    public void rollback() throws JMSException {
        checkClosed();

        if (!getTransacted()) {
            throw new IllegalStateException("Session is not transacted");
        }

        for (MockJMSSessionListener listener : sessionListeners) {
            listener.onSessionRollback(this);
        }
    }

    @Override
    public void recover() throws JMSException {
        checkClosed();
    }

    @Override
    public void unsubscribe(String name) throws JMSException {
        checkClosed();
    }

    @Override
    public MessageListener getMessageListener() throws JMSException {
        checkClosed();
        return messageListener;
    }

    @Override
    public void setMessageListener(MessageListener listener) throws JMSException {
        checkClosed();
        this.messageListener = listener;
    }

    public String getSessionId() {
        return sessionId;
    }

    public MockJMSConnection getConnection() {
        return connection;
    }

    public void addSessionListener(MockJMSSessionListener listener) throws JMSException {
        checkClosed();
        if (listener != null) {
            sessionListeners.add(listener);
        }
    }

    public void removeSessionListener(MockJMSSessionListener listener) throws JMSException {
        checkClosed();
        sessionListeners.remove(listener);
    }

    //----- Message Factory Methods ------------------------------------------//

    @Override
    public BytesMessage createBytesMessage() throws JMSException {
        checkClosed();
        return new MockJMSBytesMessage();
    }

    @Override
    public MapMessage createMapMessage() throws JMSException {
        checkClosed();
        return new MockJMSMapMessage();
    }

    @Override
    public Message createMessage() throws JMSException {
        checkClosed();
        return new MockJMSMessage();
    }

    @Override
    public ObjectMessage createObjectMessage() throws JMSException {
        checkClosed();
        return new MockJMSObjectMessage();
    }

    @Override
    public ObjectMessage createObjectMessage(Serializable object) throws JMSException {
        checkClosed();
        MockJMSObjectMessage message = new MockJMSObjectMessage();
        message.setObject(object);
        return message;
    }

    @Override
    public StreamMessage createStreamMessage() throws JMSException {
        checkClosed();
        return new MockJMSStreamMessage();
    }

    @Override
    public TextMessage createTextMessage() throws JMSException {
        checkClosed();
        return new MockJMSTextMessage();
    }

    @Override
    public TextMessage createTextMessage(String text) throws JMSException {
        checkClosed();
        MockJMSTextMessage message = new MockJMSTextMessage();
        message.setText(text);
        return message;
    }

    //----- Producer Factory Methods -----------------------------------------//

    @Override
    public MessageProducer createProducer(Destination destination) throws JMSException {
        checkClosed();
        return new MockJMSMessageProducer(this, getNextProducerId(), (MockJMSDestination) destination);
    }

    @Override
    public QueueSender createSender(Queue queue) throws JMSException {
        checkClosed();
        return new MockJMSQueueSender(this, getNextProducerId(), (MockJMSDestination) queue);
    }

    @Override
    public TopicPublisher createPublisher(Topic topic) throws JMSException {
        checkClosed();
        return new MockJMSTopicPublisher(this, getNextProducerId(), (MockJMSDestination) topic);
    }

    //----- Consumer Factory Methods -----------------------------------------//

    @Override
    public TopicSubscriber createSubscriber(Topic topic) throws JMSException {
        return createSubscriber(topic, null, false);
    }

    @Override
    public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException {
        checkClosed();
        checkDestination(topic);
        return new MockJMSTopicSubscriber(this, getNextConsumerId(), (MockJMSDestination) topic, messageSelector, noLocal);
    }

    @Override
    public QueueReceiver createReceiver(Queue queue) throws JMSException {
        return createReceiver(queue, null);
    }

    @Override
    public QueueReceiver createReceiver(Queue queue, String messageSelector) throws JMSException {
        checkClosed();
        checkDestination(queue);
        return new MockJMSQueueReceiver(this, getNextConsumerId(), (MockJMSDestination) queue, messageSelector);
    }

    @Override
    public MessageConsumer createConsumer(Destination destination) throws JMSException {
        checkClosed();
        return createConsumer(destination, null, false);
    }

    @Override
    public MessageConsumer createConsumer(Destination destination, String messageSelector) throws JMSException {
        checkClosed();
        return createConsumer(destination, messageSelector, false);
    }

    @Override
    public MessageConsumer createConsumer(Destination destination, String messageSelector, boolean noLocal) throws JMSException {
        checkClosed();
        checkDestination(destination);
        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSDestination) destination, messageSelector, noLocal);
    }

    @Override
    public TopicSubscriber createDurableSubscriber(Topic topic, String name) throws JMSException {
        return createDurableSubscriber(topic, name, null, false);
    }

    @Override
    public TopicSubscriber createDurableSubscriber(Topic topic, String name, String messageSelector, boolean noLocal) throws JMSException {
        checkClosed();
        checkDestination(topic);
        return new MockJMSTopicSubscriber(this, getNextConsumerId(), (MockJMSDestination) topic, messageSelector, noLocal);
    }

    //----- Browser Factory Methods ------------------------------------------//

    @Override
    public QueueBrowser createBrowser(Queue queue) throws JMSException {
        return createBrowser(queue, null);
    }

    @Override
    public QueueBrowser createBrowser(Queue queue, String messageSelector) throws JMSException {
        checkClosed();
        checkDestination(queue);
        return new MockJMSQueueBrowser(this, getNextConsumerId(), (MockJMSDestination) queue, messageSelector);
    }

    //----- Destination Factory Methods --------------------------------------//

    @Override
    public Queue createQueue(String queueName) throws JMSException {
        checkClosed();
        return new MockJMSQueue(queueName);
    }

    @Override
    public Topic createTopic(String topicName) throws JMSException {
        checkClosed();
        return new MockJMSTopic(topicName);
    }

    @Override
    public TemporaryQueue createTemporaryQueue() throws JMSException {
        checkClosed();
        return connection.createTemporaryQueue();
    }

    @Override
    public TemporaryTopic createTemporaryTopic() throws JMSException {
        checkClosed();
        return connection.createTemporaryTopic();
    }

    //----- JMS 2.0 Shared Consumer Creation ---------------------------------//

    @Override
    public MessageConsumer createSharedConsumer(Topic topic, String sharedSubscriptionName) throws JMSException {
        checkClosed();
        checkDestination(topic);
        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, null, false);
    }

    @Override
    public MessageConsumer createSharedConsumer(Topic topic, String sharedSubscriptionName, String messageSelector) throws JMSException {
        checkClosed();
        checkDestination(topic);
        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, messageSelector, false);
    }

    @Override
    public MessageConsumer createDurableConsumer(Topic topic, String name) throws JMSException {
        checkClosed();
        checkDestination(topic);
        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, null, false);
    }

    @Override
    public MessageConsumer createDurableConsumer(Topic topic, String name, String messageSelector, boolean noLocal)throws JMSException {
        checkClosed();
        checkDestination(topic);
        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, messageSelector, noLocal);
    }

    @Override
    public MessageConsumer createSharedDurableConsumer(Topic topic, String name) throws JMSException {
        checkClosed();
        checkDestination(topic);
        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, null, false);
    }

    @Override
    public MessageConsumer createSharedDurableConsumer(Topic topic, String name, String messageSelector) throws JMSException {
        checkClosed();
        checkDestination(topic);
        return new MockJMSMessageConsumer(this, getNextConsumerId(), (MockJMSTopic) topic, messageSelector, false);
    }

    //----- JEE Session methods not implemented ------------------------------//

    @Override
    public void run() {
        throw new JMSRuntimeException("Not Supported");
    }

    //----- Session access points for producer and consumer ------------------//

    void send(MockJMSMessageProducer producer, Destination destination, Message message, int deliveryMode, int priority, long timeToLive, boolean disableMessageId, boolean disableTimestamp, long deliveryDelay, CompletionListener completionListener) throws JMSException {
        sendLock.lock();
        try {
            message.setJMSDeliveryMode(deliveryMode);
            message.setJMSPriority(priority);
            message.setJMSRedelivered(false);
            message.setJMSDestination(destination);

            long timeStamp = System.currentTimeMillis();
            boolean hasTTL = timeToLive > Message.DEFAULT_TIME_TO_LIVE;
            boolean hasDelay = deliveryDelay > Message.DEFAULT_DELIVERY_DELAY;

            if (!(message instanceof MockJMSMessage)) {
                throw new IllegalStateException("Mock JMS client cannot handle foreign messages");
            }

            if (!disableTimestamp) {
                message.setJMSTimestamp(timeStamp);
            } else {
                message.setJMSTimestamp(0);
            }

            if (hasTTL) {
                message.setJMSExpiration(timeStamp + timeToLive);
            } else {
                message.setJMSExpiration(0);
            }

            long messageSequence = producer.getNextMessageSequence();
            String messageId = null;
            if (!disableMessageId) {
                messageId = producer.getProducerId() + ":"+ messageSequence;
            }

            // Set the delivery time. Purposefully avoided doing this earlier so
            // that we use the 'outbound' JmsMessage object reference when
            // updating our own message instances, avoids using the interface
            // in case the JMS 1.1 Message API is actually being used due to
            // being on the classpath too.
            long deliveryTime = timeStamp;
            if (hasDelay) {
                deliveryTime = timeStamp + deliveryDelay;
            }

            message.setJMSDeliveryTime(deliveryTime);

            // Set the message ID
            message.setJMSMessageID(messageId);

            try {
                connection.onMessageSend(this, message);
            } catch (JMSException jmsEx) {
                // If the synchronous portion of the send fails the completion be
                // notified but might depending on the circumstances of the failures,
                // remove it from the queue and check if is is already completed
                // once we decide to add completion support to the mock
                throw jmsEx;
            }
        } finally {
            sendLock.unlock();
        }
    }

    void acknowledge() throws JMSException {
        // TODO Auto-generated method stub
    }

    static void validateSessionMode(int mode) {
        switch (mode) {
            case JMSContext.AUTO_ACKNOWLEDGE:
            case JMSContext.CLIENT_ACKNOWLEDGE:
            case JMSContext.DUPS_OK_ACKNOWLEDGE:
            case JMSContext.SESSION_TRANSACTED:
                return;
            default:
                throw new JMSRuntimeException("Invalid Session Mode: " + mode);
        }
    }

    //----- Internal Utility Methods -----------------------------------------//

    private static void checkDestination(Destination dest) throws InvalidDestinationException {
        if (dest == null) {
            throw new InvalidDestinationException("Destination cannot be null");
        }
    }

    private void checkClosed() throws JMSException {
        if (closed.get()) {
            throw new JMSException("Session is closed");
        }
    }

    boolean isDestinationInUse(MockJMSTemporaryDestination destination) {
        // TODO Auto-generated method stub
        return false;
    }

    protected String getNextConsumerId() {
        return getSessionId() + ":" + consumerIdGenerator.incrementAndGet();
    }

    protected String getNextProducerId() {
        return getSessionId() + ":" + producerIdGenerator.incrementAndGet();
    }

    protected void add(MockJMSMessageConsumer consumer) throws JMSException {
        connection.onMessageConsumerCreate(this, consumer);
        consumers.put(consumer.getConsumerId(), consumer);

        if (started.get()) {
            consumer.start();
        }
    }

    protected void remove(MockJMSMessageConsumer consumer) throws JMSException {
        consumers.remove(consumer.getConsumerId());
        connection.onMessageConsumerClose(this, consumer);

        for (MockJMSSessionListener listener : sessionListeners) {
            listener.onConsumerClose(this, consumer);
        }
    }

    protected void add(MockJMSMessageProducer producer) {
        producers.put(producer.getProducerId(), producer);
    }

    protected void remove(MockJMSMessageProducer producer) throws JMSException {
        producers.remove(producer.getProducerId());

        for (MockJMSSessionListener listener : sessionListeners) {
            listener.onProducerClose(this, producer);
        }
    }
}
```


Overlapping Code:
```
ublic class MockJMSSession implements Session, QueueSession, TopicSession, AutoCloseable {
private final AtomicBoolean closed = new AtomicBoolean();
private final AtomicBoolean started = new AtomicBoolean();
private final ReentrantLock sendLock = new ReentrantLock();
private final Map<String, MockJMSMessageProducer> producers = new ConcurrentHashMap<>();
private final Map<String, MockJMSMessageConsumer> consumers = new ConcurrentHashMap<>();
private final Set<MockJMSSessionListener> sessionListeners = new HashSet<>();
private final String sessionId;
private final int sessionMode;
private final MockJMSConnection connection;
private final AtomicLong consumerIdGenerator = new AtomicLong();
private final AtomicLong producerIdGenerator = new AtomicLong();
private MessageListener messageListener;
public MockJMSSession(String sessionId, int sessionMode, MockJMSConnection connection) {
this.sessionMode = sessionMode;
this.connection = connection;
this.sessionId = sessionId;
}
@Override
public void close() throws JMSException {
if (closed.compareAndSet(false, true)) {
connection.removeSession(this);
for (MockJMSMessageProducer producer : producers.values()) {
producer.close();
}
for (MockJMSMessageConsumer consumer : consumers.values()) {
consumer.close();
}
for (MockJMSSessionListener listener : sessionListeners) {
listener.onSessionClosed(this);
}
}
}
public void start() throws JMSException {
}
public void stop() throws JMSException {
}
@Override
public boolean getTransacted() throws JMSException {
checkClosed();
return sessionMode == SESSION_TRANSACTED;
}
@Override
public int getAcknowledgeMode() throws JMSException {
checkClosed();
return sessionMode;
}
@Override
public void commit() throws JMSException {
checkClosed();
if (!getTransacted()) {
throw new IllegalStateException("Session is not transacted");
}
for (MockJMSSessionListener listener : sessionListeners) {
listener.onSessionCommit(this);
}
}
@Override
public void rollback() throws JMSException {
checkClosed();
if (!getTransacted()) {
throw new IllegalStateException
```
<Overlap Ratio: 0.9990267639902677>

---

--- 130 --
Question ID: 000afbbf1284da3cf10b356e16ba7e060725ab17
Original Code:
```
public class DevideTwoIntegers implements Facebook {

    /**
     * Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.
     * Return the quotient after dividing dividend by divisor.
     * The integer division should truncate toward zero.
     * Example 1:
     * Input: dividend = 10, divisor = 3
     * Output: 3
     * Example 2:
     * Input: dividend = 7, divisor = -3
     * Output: -2
     * Note:
     * Both dividend and divisor will be 32-bit signed integers.
     * The divisor will never be 0.
     * Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1].
     * For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.
     */

    public int divide(int dividend, int divisor) {
        //Reduce the problem to positive long integer to make it easier.
        //Use long to avoid integer overflow cases.
        int sign = 1;
        if( (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0) )
            sign = -1;
        long dd = Math.abs((long) dividend);
        long ds = Math.abs((long) divisor);
        //Take care the edge cases.
        if(ds == 0) return Integer.MAX_VALUE;
        if(dd == 0 || dd < ds) return 0;

        long lans = helper(dd, ds);
        int ans = 0;
        //Handle overflow.
        if(lans > Integer.MAX_VALUE){
            ans = sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
        }else {
            ans = (int) (sign * lans);
        }

        return ans;
    }


    private long helper(long dd, long ds){
        // Recursion exit condition
        if(dd < ds) return 0;

        //  Find the largest multiple so that (divisor * multiple <= dividend),
        //  whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason.
        //  Think this as a binary search.
        long sum = ds;
        long mul = 1;
        while (sum + sum <= dd){
            sum += sum;
            mul += mul;
        }
        //Look for additional value for the multiple from the reminder (dividend - sum) recursively
        return mul + helper(dd - sum, ds);
    }

    private long bsHelper(long dd, long ds){
        if(dd < ds) return 0;

        long pro = ds;
        while (pro * pro <= dd){
            pro *= pro;
        }
        return pro;
    }


    public void test(){
        System.out.println(divide(10 , 3));
        System.out.println(divide(7 , -3));
    }

}
```


Overlapping Code:
```
oIntegers implements Facebook {
/**
* Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.
* Return the quotient after dividing dividend by divisor.
* The integer division should truncate toward zero.
* Example 1:
* Input: dividend = 10, divisor = 3
* Output: 3
* Example 2:
* Input: dividend = 7, divisor = -3
* Output: -2
* Note:
* Both dividend and divisor will be 32-bit signed integers.
* The divisor will never be 0.
* Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1].
* For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.
*/
public int divide(int dividend, int divisor) {
//Reduce the problem to positive long integer to make it easier.
//Use long to avoid integer overflow cases.
int sign = 1;
if( (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0) )
sign = -1;
long dd = Math.abs((long) dividend);
long ds = Math.abs((long) divisor);
//Take care the edge cases.
if(ds == 0) return Integer.MAX_VALUE;
if(dd == 0 || dd < ds) return 0;
long lans = helper(dd, ds);
int ans = 0;
//Handle overflow.
if(lans > Integer.MAX_VALUE){
ans = sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
}else {
ans = (int) (sign * lans);
}
return ans;
}
private long helper(long dd, long ds){
// Recursion exit condition
if(dd < ds) return 0;
// Find the largest multiple so that (divisor * multiple <= dividend),
// whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason.
// Think this as a binary search.
long sum = ds;
long mul = 1;
while (sum + sum <= dd){
sum += sum;
mul += mul;
}
//Look for additional value for the multiple from the reminder (dividend - sum) recursively
return mul + helper(dd - sum, ds);
}
private long bsHelper(long dd, long ds){
if(dd < ds) return 0;
long pro = ds;
while (pro * pro <= dd){
pro *= pro;
}
return pro;
}
public void test(){
System.
```
<Overlap Ratio: 0.9799118079372856>

---

--- 131 --
Question ID: 488e42b56e4d776b792180f90bd83d5f740166f7
Original Code:
```
public abstract class PhaseBase implements IPhase {

    protected final EntityDragon field_188661_a;

    public PhaseBase(EntityDragon entityenderdragon) {
        this.field_188661_a = entityenderdragon;
    }

    public boolean func_188654_a() {
        return false;
    }

    public void func_188657_b() {}

    public void func_188659_c() {}

    public void func_188655_a(EntityEnderCrystal entityendercrystal, BlockPos blockposition, DamageSource damagesource, @Nullable EntityPlayer entityhuman) {}

    public void func_188660_d() {}

    public void func_188658_e() {}

    public float func_188651_f() {
        return 0.6F;
    }

    @Nullable
    public Vec3d func_188650_g() {
        return null;
    }

    public float func_188656_a(MultiPartEntityPart entitycomplexpart, DamageSource damagesource, float f) {
        return f;
    }

    public float func_188653_h() {
        float f = MathHelper.func_76133_a(this.field_188661_a.field_70159_w * this.field_188661_a.field_70159_w + this.field_188661_a.field_70179_y * this.field_188661_a.field_70179_y) + 1.0F;
        float f1 = Math.min(f, 40.0F);

        return 0.7F / f1 / f;
    }
}
```


Overlapping Code:
```
e implements IPhase {
protected final EntityDragon field_188661_a;
public PhaseBase(EntityDragon entityenderdragon) {
this.field_188661_a = entityenderdragon;
}
public boolean func_188654_a() {
return false;
}
public void func_188657_b() {}
public void func_188659_c() {}
public void func_188655_a(EntityEnderCrystal entityendercrystal, BlockPos blockposition, DamageSource damagesource, @Nullable EntityPlayer entityhuman) {}
public void func_188660_d() {}
public void func_188658_e() {}
public float func_188651_f() {
return 0.6F;
}
@Nullable
public Vec3d func_188650_g() {
return null;
}
public float func_188656_a(MultiPartEntityPart entitycomplexpart, DamageSource damagesource, float f) {
return f;
}
public float func_188653_h() {
float f = MathHelper.func_76133_a(this.field_188661_a.field_70159_w * this.field_188661_a.field_70159_w + this.field_188661_a.field_70179_y * this.field_188661_a.field_70179_y) + 1.0F;
float f1 = Math.min(f, 40.0F);
return 0.7F / f1 / f;

```
<Overlap Ratio: 0.9672943508424182>

---

--- 132 --
Question ID: f72cef719fbb63d62c00b96052ffeb973e0c42a3
Original Code:
```
@Configuration("graphicalUserAuthenticationConfiguration")
@EnableConfigurationProperties(CasConfigurationProperties.class)
public class GraphicalUserAuthenticationConfiguration {

    @Autowired
    private CasConfigurationProperties casProperties;

    @Autowired
    @Qualifier("loginFlowRegistry")
    private FlowDefinitionRegistry loginFlowDefinitionRegistry;

    @Autowired
    @Qualifier("servicesManager")
    private ServicesManager servicesManager;

    @Autowired
    private ApplicationContext applicationContext;
    
    @Autowired
    private FlowBuilderServices flowBuilderServices;

    @ConditionalOnMissingBean(name = "graphicalUserAuthenticationWebflowConfigurer")
    @Bean
    @DependsOn("defaultWebflowConfigurer")
    public CasWebflowConfigurer graphicalUserAuthenticationWebflowConfigurer() {
        final CasWebflowConfigurer w = new GraphicalUserAuthenticationWebflowConfigurer(flowBuilderServices, 
                loginFlowDefinitionRegistry, applicationContext, casProperties);
        w.initialize();
        return w;
    }

    @Bean
    @ConditionalOnMissingBean(name = "userGraphicalAuthenticationRepository")
    public UserGraphicalAuthenticationRepository userGraphicalAuthenticationRepository() {

        final GraphicalUserAuthenticationProperties gua = casProperties.getAuthn().getGua();
        if (gua.getResource().getLocation() != null) {
            return new StaticUserGraphicalAuthenticationRepository();
        }

        if (StringUtils.isNotBlank(gua.getLdap().getLdapUrl())
                && StringUtils.isNotBlank(gua.getLdap().getSearchFilter())
                && StringUtils.isNotBlank(gua.getLdap().getBaseDn())
                && StringUtils.isNotBlank(gua.getLdap().getImageAttribute())) {
            return new LdapUserGraphicalAuthenticationRepository();
        }

        throw new BeanCreationException("A repository instance must be configured to locate user-defined graphics");

    }

    @Bean
    @ConditionalOnMissingBean(name = "acceptUserGraphicsForAuthenticationAction")
    public Action acceptUserGraphicsForAuthenticationAction() {
        return new AcceptUserGraphicsForAuthenticationAction();
    }

    @Autowired
    @Bean
    public Action displayUserGraphicsBeforeAuthenticationAction(@Qualifier("userGraphicalAuthenticationRepository")
                                                                final UserGraphicalAuthenticationRepository repository) {
        return new DisplayUserGraphicsBeforeAuthenticationAction(repository);
    }

    @Bean
    public Action initializeLoginAction() {
        return new PrepareForGraphicalAuthenticationAction(servicesManager);
    }
}
```


Overlapping Code:
```
Configuration("graphicalUserAuthenticationConfiguration")
@EnableConfigurationProperties(CasConfigurationProperties.class)
public class GraphicalUserAuthenticationConfiguration {
@Autowired
private CasConfigurationProperties casProperties;
@Autowired
@Qualifier("loginFlowRegistry")
private FlowDefinitionRegistry loginFlowDefinitionRegistry;
@Autowired
@Qualifier("servicesManager")
private ServicesManager servicesManager;
@Autowired
private ApplicationContext applicationContext;

@Autowired
private FlowBuilderServices flowBuilderServices;
@ConditionalOnMissingBean(name = "graphicalUserAuthenticationWebflowConfigurer")
@Bean
@DependsOn("defaultWebflowConfigurer")
public CasWebflowConfigurer graphicalUserAuthenticationWebflowConfigurer() {
final CasWebflowConfigurer w = new GraphicalUserAuthenticationWebflowConfigurer(flowBuilderServices, 
loginFlowDefinitionRegistry, applicationContext, casProperties);
w.initialize();
return w;
}
@Bean
@ConditionalOnMissingBean(name = "userGraphicalAuthenticationRepository")
public UserGraphicalAuthenticationRepository userGraphicalAuthenticationRepository() {
final GraphicalUserAuthenticationProperties gua = casProperties.getAuthn().getGua();
if (gua.getResource().getLocation() != null) {
return new StaticUserGraphicalAuthenticationRepository();
}
if (StringUtils.isNotBlank(gua.getLdap().getLdapUrl())
&& StringUtils.isNotBlank(gua.getLdap().getSearchFilter())
&& StringUtils.isNotBlank(gua.getLdap().getBaseDn())
&& StringUtils.isNotBlank(gua.getLdap().getImageAttribute())) {
return new LdapUserGraphicalAuthenticationRepository();
}
throw new BeanCreationException("A repository instance must be configured to locate user-defined graphics");
}
@Bean
@ConditionalOnMissingBean(name = "acceptUserGraphicsForAuthenticationAction")
public Action acceptUserGraphicsForAuthenticationAction() {
return new AcceptUserGraphicsForAuthenticationAction();
}
@Autowired
@Bean
public Action displayUserGraphicsBeforeAuthenticationAction(@Qualifier("userGraphicalAuthenticationRepository")
final UserGraphicalAuthenticationRepository repository) {
return new
```
<Overlap Ratio: 0.985452839042703>

---

--- 133 --
Question ID: 58c0f14dafb4ef40ba3bdaa825c65b45219d745b
Original Code:
```
@Component(service = WordReverseService.class)
public class WordReverseService {

    /**
     * Copied from
     * http://codereview.stackexchange.com/questions/37364/reversing-words-in-a-string
     *
     * @param sentence
     * @return
     */
    public String reverseWords(String sentence) {
        StringBuilder sb = new StringBuilder(sentence.length() + 1);
        String[] words = sentence.split(" ");
        for (int i = words.length - 1; i >= 0; i--) {
            sb.append(words[i]).append(' ');
        }
        sb.setLength(sb.length() - 1);  // Strip trailing space
        return sb.toString();
    }

}
```


Overlapping Code:
```

public class WordReverseService {
/**
* Copied from
* http://codereview.stackexchange.com/questions/37364/reversing-words-in-a-string
*
* @param sentence
* @return
*/
public String reverseWords(String sentence) {
StringBuilder sb = new StringBuilder(sentence.length() + 1);
String[] words = sentence.split(" ");
for (int i = words.length - 1; i >= 0; i--) {
sb.append(words[i]).append(' ');
}
sb.setLength(sb.length() - 1); // Strip trailing space
r
```
<Overlap Ratio: 0.8653846153846154>

---

--- 134 --
Question ID: 764c59cdf295b973d8d1a3007f4c9ab9f3ae8134
Original Code:
```
public class NodeRegistry {

    private static final TreeMap<String, Node> REPRESENTATIVE_NODES = new TreeMap<>();

    private NodeRegistry() {

    }

    public static Node getRepresentive(Node node) {
        Node n = REPRESENTATIVE_NODES.get(node.toString());
        if (n == null) {
            n = node;
            REPRESENTATIVE_NODES.put(n.toString(), n);
        }
        return n;
    }

    public static void updateRepresentative(Node oldNode, Node newNode) {
        REPRESENTATIVE_NODES.remove(oldNode.toString());
        REPRESENTATIVE_NODES.put(newNode.toString(), newNode);
    }

}
```


Overlapping Code:
```
public class NodeRegistry {
private static final TreeMap<String, Node> REPRESENTATIVE_NODES = new TreeMap<>();
private NodeRegistry() {
}
public static Node getRepresentive(Node node) {
Node n = REPRESENTATIVE_NODES.get(node.toString());
if (n == null) {
n = node;
REPRESENTATIVE_NODES.put(n.toString(), n);
}
return n;
}
public static void updateRepresentative(Node oldNode, Node newNode) {
REPRESENTATIVE_NODES.remove(oldNode.toString());
REPRESENT
```
<Overlap Ratio: 0.9018036072144289>

---

--- 135 --
Question ID: f87b63cecf3033d46701e6018dab097d4225a3d3
Original Code:
```
@JsonIgnoreProperties(ignoreUnknown = true)
public class Field {
    public final String fieldName;
    final Datatype datatype;
    final Optional<RegisterId> register;
    final Cardinality cardinality;
    final String text;

    @JsonCreator
    public Field(@JsonProperty("field") String fieldName,
                 @JsonProperty("datatype") String datatype,
                 @JsonProperty("register") RegisterId register,
                 @JsonProperty("cardinality") Cardinality cardinality,
                 @JsonProperty("text") String text) {
        this.fieldName = fieldName;
        this.text = text;
        this.register = Optional.ofNullable(register);
        this.cardinality = cardinality;
        this.datatype = DatatypeFactory.get(datatype);
    }

    public Optional<RegisterId> getRegister() {
        return register;
    }

    @SuppressWarnings("unused")
    public Cardinality getCardinality() {
        return cardinality;
    }

    public Datatype getDatatype() {
        return datatype;
    }

    public String getText() {
        return text;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Field field = (Field) o;

        if (fieldName != null ? !fieldName.equals(field.fieldName) : field.fieldName != null) return false;
        if (datatype != null ? !datatype.equals(field.datatype) : field.datatype != null) return false;
        if (register != null ? !register.equals(field.register) : field.register != null) return false;
        if (cardinality != field.cardinality) return false;
        return text != null ? text.equals(field.text) : field.text == null;
    }

    @Override
    public int hashCode() {
        int result = fieldName != null ? fieldName.hashCode() : 0;
        result = 31 * result + (datatype != null ? datatype.hashCode() : 0);
        result = 31 * result + (register != null ? register.hashCode() : 0);
        result = 31 * result + (cardinality != null ? cardinality.hashCode() : 0);
        result = 31 * result + (text != null ? text.hashCode() : 0);
        return result;
    }
}
```


Overlapping Code:
```
@JsonIgnoreProperties(ignoreUnknown = true)
public class Field {
public final String fieldName;
final Datatype datatype;
final Optional<RegisterId> register;
final Cardinality cardinality;
final String text;
@JsonCreator
public Field(@JsonProperty("field") String fieldName,
@JsonProperty("datatype") String datatype,
@JsonProperty("register") RegisterId register,
@JsonProperty("cardinality") Cardinality cardinality,
@JsonProperty("text") String text) {
this.fieldName = fieldName;
this.text = text;
this.register = Optional.ofNullable(register);
this.cardinality = cardinality;
this.datatype = DatatypeFactory.get(datatype);
}
public Optional<RegisterId> getRegister() {
return register;
}
@SuppressWarnings("unused")
public Cardinality getCardinality() {
return cardinality;
}
public Datatype getDatatype() {
return datatype;
}
public String getText() {
return text;
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
Field field = (Field) o;
if (fieldName != null ? !fieldName.equals(field.fieldName) : field.fieldName != null) return false;
if (datatype != null ? !datatype.equals(field.datatype) : field.datatype != null) return false;
if (register != null ? !register.equals(field.register) : field.register != null) return false;
if (cardinality != field.cardinality) return false;
return text != null ? text.equals(field.text) : field.text == null;
}
@Override
public int hashCode() {
int result = fieldName != null ? fieldName.hashCode() : 0;
result = 31 * result + (datatype != null ? datatype.hashCode() : 0);
result = 31 * result + (register != null ? register.hashCode() : 0);
result = 31 * result + (cardinality != null ? cardinality.hashCode() : 0);
result = 31 * result + (text != null ? text.hashCode() : 0);
return result;
}
```
<Overlap Ratio: 0.9989059080962801>

---

--- 136 --
Question ID: 28f7a961cc08d2ec2738c8c957ece8a3c017d30c
Original Code:
```
public abstract class BaseTestsHelper extends IntegrationTestBase
{

    private final static Logger logger = LoggerFactory.getLogger(BaseTestsHelper.class);

    protected final CorePolicyObjectMapper mapper = new CorePolicyObjectMapper();
    protected static String INPUT_QUEUENAME = "Input";
    protected static String RESULT_QUEUENAME = "Results";

    //number of seconds allowed to wait for result to be delivered to results queue consumer
    protected static int RESULT_TIMEOUTSECONDS;
    protected static String RABBIT_HOST = "localhost";
    protected static String RABBIT_USER = "guest";
    protected static String RABBIT_PASS = "guest";
    protected static int RABBIT_PORT = 5672;

    protected static com.rabbitmq.client.Connection rabbitConnection;

    protected final AnnotationConfigApplicationContext testingPropertiesApplicationContext;
    protected final PolicyWorkerTestingProperties properties;

    EventPoller<QueuePublisher> publisher;
    DefaultRabbitConsumer consumer;
    TestQueueConsumerImpl consumerImpl;

    public BaseTestsHelper()
    {

        testingPropertiesApplicationContext = new AnnotationConfigApplicationContext();
        testingPropertiesApplicationContext.register(ConversionConfiguration.class);
        testingPropertiesApplicationContext.register(PropertySourcesPlaceholderConfigurer.class);
        RootBeanDefinition beanDefinition = new RootBeanDefinition();
        beanDefinition.setBeanClass(PolicyWorkerTestingProperties.class);
        testingPropertiesApplicationContext.registerBeanDefinition("PolicyWorkerTestingProperties", beanDefinition);
        testingPropertiesApplicationContext.refresh();

        properties = testingPropertiesApplicationContext.getBean(PolicyWorkerTestingProperties.class);
    }

    public static void RabbitConnectionSetup() throws TimeoutException, IOException
    {
        rabbitConnection = RabbitHelper.getRabbitConnection(RABBIT_HOST, RABBIT_PORT, RABBIT_USER, RABBIT_PASS);
    }

    @Before
    public void SetupRabbitQueues() throws IOException, TimeoutException {
        if(rabbitConnection==null) {
            INPUT_QUEUENAME = properties.getInputQueueName();
            RESULT_QUEUENAME = properties.getResultQueueName();
            RESULT_TIMEOUTSECONDS = properties.getResultTimeoutSeconds();
            RABBIT_HOST = properties.getRabbitHost();
            RABBIT_USER = properties.getRabbitUser();
            RABBIT_PASS = properties.getRabbitPass();
            RABBIT_PORT = properties.getRabbitPort();
            RabbitConnectionSetup();

            // the queues might not exist yet, if not do so now
            Channel inputChannel = rabbitConnection.createChannel();
            Channel resultsChannel = rabbitConnection.createChannel();

            RabbitUtil.declareWorkerQueue(inputChannel, INPUT_QUEUENAME, 32);
            RabbitUtil.declareWorkerQueue(resultsChannel, RESULT_QUEUENAME, 32);

            CloseChannel(inputChannel);
            CloseChannel(resultsChannel);
        }

        ClearRabbitQueues();
    }

    public static void ClearRabbitQueues() throws IOException
    {
        //clear input and result queues before each test
        PurgeQueue(INPUT_QUEUENAME);
        PurgeQueue(RESULT_QUEUENAME);
    }

    @AfterClass
    public static void StaticCleanup() throws IOException
    {
        //clear queues after tests ran
        ClearRabbitQueues();
        rabbitConnection.close();
        rabbitConnection = null;
    }

    public static void PurgeQueue(String queueName) throws IOException
    {
        Channel channel = rabbitConnection.createChannel();
        PurgeQueue(channel, queueName);
        CloseChannel(channel);
    }

    public static void PurgeQueue(Channel channel, String queueName) throws IOException
    {
        channel.queuePurge(queueName);
    }

    public static void CloseChannel(Channel channel) throws IOException {
        try {
            channel.close();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }

    protected void closeRabbitConnections(Channel resultsChannel, ConsumerCreationResult consumerResult)
    {
        try {
            consumer.shutdown();
            publisher.shutdown();
            try {
                resultsChannel.basicCancel(consumerResult.getConsumeId());
            } catch (IOException ex) {
                getLogger().warn("Failed to cancel results channel: ", ex);
            }
            try {
                resultsChannel.close();
            } catch (IOException | TimeoutException ex) {
                getLogger().warn("Failed to close results channel: ", ex);
            }
        } catch (Exception ex) {
            // dont let normal shutdown type issues cause a failure in the tests, this can happen in debugging, and we dont
            // want the shutdown of the queue being the recorded reason for the failure.
        }
    }

    protected CollectionSequence SetupCollectionSequence(ClassificationApi classificationApi, Long collectionId,
                                                         boolean returnCollectionSequenceInstead)
    {
        CollectionSequence collectionSequence = new CollectionSequence();
        collectionSequence.name = getUniqueString("ClassifyDocumentApiIT::setup_");
        collectionSequence.description = "Used in ClassifyDocumentApiIT tests.";
        collectionSequence.collectionSequenceEntries = new ArrayList<>();
        CollectionSequenceEntry collectionSequenceEntry = new CollectionSequenceEntry();
        collectionSequenceEntry.collectionIds = new HashSet<>(Arrays.asList(collectionId));
        collectionSequenceEntry.stopOnMatch = false;
        collectionSequenceEntry.order = 400;
        collectionSequence.collectionSequenceEntries.add(collectionSequenceEntry);

        collectionSequence = classificationApi.create(collectionSequence);

        if (returnCollectionSequenceInstead) {
            return collectionSequence;
        }

        throw new RuntimeException("This method is not used anymore!!");
    }

    protected DocumentCollection SetupCollection(Collection<Long> overridePolicyIds)
    {
        ClassificationApi classificationApi = genericApplicationContext.getBean(ClassificationApi.class);
        NumberCondition numberCondition = new NumberCondition();
        numberCondition.name = "afield condition 1";
        numberCondition.field = "afield";
        numberCondition.operator = NumberOperatorType.EQ;
        numberCondition.value = 1L;

        DocumentCollection collection1 = new DocumentCollection();
        collection1.name = "Collection 1";

        collection1.policyIds = new HashSet<>();
        if (overridePolicyIds != null) {
            collection1.policyIds.addAll(overridePolicyIds);
        }
        collection1.condition = numberCondition;

        collection1 = classificationApi.create(collection1);

        return collection1;

    }

    protected CollectionSequence SetupCollectionSequence(DocumentCollection collection)
    {
        ClassificationApi classificationApi = genericApplicationContext.getBean(ClassificationApi.class);
        return SetupCollectionSequence(classificationApi, collection.id, true);
    }

    protected CollectionSequence SetupCollectionSequenceWithPolicies(final Collection<Long> defaultPolicyIds)
    {
        return SetupCollectionSequenceWithPolicies(defaultPolicyIds, null);
    }

    protected CollectionSequence SetupCollectionSequenceWithPolicies(final Collection<Long> defaultPolicyIds,
                                                                     final Collection<Long> overridePolicyIds)
    {
        ClassificationApi classificationApi = genericApplicationContext.getBean(ClassificationApi.class);
        NumberCondition numberCondition = new NumberCondition();
        numberCondition.name = "afield condition 1";
        numberCondition.field = "afield";
        numberCondition.operator = NumberOperatorType.EQ;
        numberCondition.value = 1L;

        DocumentCollection collection1 = new DocumentCollection();
        collection1.name = "Collection 1";

        collection1.policyIds = new HashSet<>();
        if (overridePolicyIds == null) {
            collection1.policyIds.addAll(defaultPolicyIds);
        } else {
            collection1.policyIds.addAll(overridePolicyIds);
        }
        collection1.condition = numberCondition;

        collection1 = classificationApi.create(collection1);

        return SetupCollectionSequence(classificationApi, collection1.id, true);
    }

    protected Collection<Long> SetupPoliciesWithNoHandlersAvailable() throws IOException
    {
        PolicyApi policyApi = genericApplicationContext.getBean(PolicyApi.class);
        //register new policy type that will have no handlers associated
        MetadataPolicy metadataPolicy = new MetadataPolicy();
        metadataPolicy.setFieldActions(new ArrayList<>());
        FieldAction fieldAction = new FieldAction();
        fieldAction.setAction(FieldAction.Action.ADD_FIELD_VALUE);
        fieldAction.setFieldName("EXTERNAL_TEST");
        fieldAction.setFieldValue("1");
        metadataPolicy.getFieldActions().add(fieldAction);

        PolicyType policyType = createCustomPolicyType(policyApi, getUniqueString("NoHandler"), null);

        Policy policy = new Policy();
        policy.name = "Policy";
        policy.details = mapper.valueToTree(metadataPolicy);
        policy.typeId = policyType.id;
        policy.priority = 100;
        policy = policyApi.create(policy);

        ArrayList<Long> noHandlers = new ArrayList<>();
        noHandlers.add(policy.id);
        return noHandlers;
    }

    protected PolicyType createCustomPolicyType(PolicyApi policyApi, final String uniqueName, final String uniqueShortName)
    {
        PolicyType policyType = new PolicyType();
        policyType.conflictResolutionMode = ConflictResolutionMode.PRIORITY;
        policyType.name = uniqueName;
        policyType.shortName = Strings.isNullOrEmpty(uniqueShortName) ? getUniqueString("") : uniqueShortName;
        JsonNodeFactory nodeFactory = new JsonNodeFactory(false);
        policyType.definition = nodeFactory.objectNode();
        policyType = policyApi.create(policyType);
        return policyType;
    }

    public static String getUniqueString(String strPrefix)
    {
        return strPrefix + UUID.randomUUID().toString();
    }

    protected LinkedList<Long> SetupPolicies() throws IOException
    {
        PolicyApi policyApi = genericApplicationContext.getBean(PolicyApi.class);

        MetadataPolicy metadataPolicy = new MetadataPolicy();
        metadataPolicy.setFieldActions(new ArrayList<>());
        FieldAction fieldAction = new FieldAction();
        fieldAction.setAction(FieldAction.Action.ADD_FIELD_VALUE);
        fieldAction.setFieldName("EXTERNAL_TEST");
        fieldAction.setFieldValue("1");
        metadataPolicy.getFieldActions().add(fieldAction);

        PolicyType policyType = policyApi.retrievePolicyTypeByName("MetadataPolicy");
        Policy policy = new Policy();
        policy.name = "Policy";
        policy.details = mapper.valueToTree(metadataPolicy);
        policy.typeId = policyType.id;
        policy.priority = 100;
        policy = policyApi.create(policy);

        LinkedList<Long> policyIds = new LinkedList<>();
        policyIds.add(policy.id);

        return policyIds;
    }

    protected DocumentCollection getDocumentCollection(long colId) throws Exception
    {
        Collection<DocumentCollection> collections = getClassificationApi().retrieveCollections(Arrays.asList(colId), true, false);
        if (collections.isEmpty()) {
            throw new Exception("Failed to find document collection id: " + colId);
        }

        return collections.stream().filter(u -> u.id.equals(colId)).findFirst().get();
    }

    protected PolicyType createCustomExternalClassificationPolicyType(PolicyApi policyApi, String ptName, String ptShortName,
                                                                      String ptDesc, String ptJsonDefinition)
        throws IOException
    {

        PolicyType policyType = new PolicyType();
        policyType.name = getUniqueString(ptName);
        policyType.shortName = ptShortName;
        policyType.description = ptDesc;
        policyType.definition = mapper.readTree(ptJsonDefinition);

        return policyApi.create(policyType);
    }

    protected Policy createCustomExternalClassificationPolicy(PolicyApi policyApi, PolicyType policyType, CollectionSequence colSeq,
                                                              String polName, Integer polPriority, String queueName) throws IOException
    {

        String policyDef = "{\"classificationSequenceId\":" + colSeq.id + ",\"queueName\":\"" + queueName + "\"}";
        ObjectMapper mapper = new ObjectMapper();
        Policy policy = new Policy();
        policy.name = polName;
        policy.details = mapper.readTree(policyDef);
        policy.typeId = policyType.id;
        policy.priority = polPriority;

        return policyApi.create(policy);
    }

    protected DocumentCollection getWorkflowDocumentCollection(ClassificationApi classificationApi, Condition anyCondition)
    {
        DocumentCollection collection1 = new DocumentCollection();
        collection1.name = "Collection to drive workflow custom policy";
        collection1.condition = anyCondition;
        collection1 = classificationApi.create(collection1);
        return collection1;
    }

    protected DocumentCollection addPoliciesToDocumentCollection(ClassificationApi classificationApi, DocumentCollection collection,
                                                                 Collection<Long> policyIds)
    {
        collection.policyIds = new HashSet<>();
        collection.policyIds.addAll(policyIds);
        DocumentCollection collection1 = classificationApi.update(collection);
        return collection1;
    }

    protected void checkClassifyResult(com.github.cafdataprocessing.worker.policy.shared.ClassifyDocumentResult classifyResult,
                                       Collection<Long> policyIds, DocumentCollection collection)
    {
        //check no incomplete collections returned
        Collection<Long> incomplete = classifyResult.getIncompleteCollections();
        Assert.assertEquals(0, incomplete.size());

        //check expected policy was resolved
        Collection<Long> resolvedPolicies = classifyResult.getResolvedPolicies();
        Assert.assertArrayEquals(policyIds.toArray(), resolvedPolicies.toArray());

        //check that the collection we expected is the one matched
        Collection<com.github.cafdataprocessing.worker.policy.shared.MatchedCollection> matchedCollections = classifyResult.getMatchedCollections();
        Assert.assertEquals(1, matchedCollections.size());
        com.github.cafdataprocessing.worker.policy.shared.MatchedCollection matchedCollection = matchedCollections.iterator().next();

        Assert.assertEquals(collection.id, matchedCollection.getId());
        Assert.assertEquals(collection.name, matchedCollection.getName());
        //check the condition on the collection
        Collection<com.github.cafdataprocessing.worker.policy.shared.MatchedCondition> matchedConditions = matchedCollection.getMatchedConditions();
        assertTrue("Number of matched conditions should be positive ", matchedConditions.size() > 0);
        com.github.cafdataprocessing.worker.policy.shared.MatchedCondition matchedCondition = matchedConditions.stream().filter(u -> u.getId().equals(
            collection.condition.id)).findFirst().get();
        // compare the 2 top root condition matches at least, everything below should be fine
        // in our present test scenario.
        Assert.assertEquals(collection.condition.id, matchedCondition.getId());
        Assert.assertEquals(collection.condition.name, matchedCondition.getName());

        //check the policy on the collection
        Collection<com.github.cafdataprocessing.worker.policy.shared.CollectionPolicy> matchedPolicies = matchedCollection.getPolicies();
        Assert.assertEquals(collection.policyIds.size(), matchedPolicies.size());
        if (!matchedPolicies.isEmpty()) {
            com.github.cafdataprocessing.worker.policy.shared.CollectionPolicy matchedPolicy = matchedPolicies.iterator().next();
            Assert.assertEquals(collection.policyIds.iterator().next(), matchedPolicy.getId());
        }
    }

    /*
        Checks the task message passed in has the taskId set to expectedTaskId, that TaskStatus is RESULT_SUCCESS
     */
    protected void checkTaskMessageReturned(TaskMessage resultWrapper, String expectedTaskId)
    {
        checkTaskMessageReturnedTaskStatus(resultWrapper, expectedTaskId, TaskStatus.RESULT_SUCCESS);
    }

    /*
        Checks the task message passed in has the taskId set to expectedTaskId, that TaskStatus is RESULT_EXCEPTION
     */
    protected void checkTaskMessageReturnedException(TaskMessage resultWrapper, String expectedTaskId)
    {
        checkTaskMessageReturnedTaskStatus(resultWrapper, expectedTaskId, TaskStatus.RESULT_EXCEPTION);
    }

    /*
        Checks the task message passed in has the taskId set to expectedTaskId, that TaskStatus is RESULT_FAILURE
     */
    protected void checkTaskMessageReturnedTaskStatus(TaskMessage resultWrapper, String expectedTaskId, TaskStatus expectedStatus)
    {
        //check that this has the task ID we specified when adding to Input Queue
        Assert.assertEquals(expectedTaskId, resultWrapper.getTaskId());
        TaskStatus status = resultWrapper.getTaskStatus();
        //check that task status is x
        Assert.assertEquals(expectedStatus, status);
    }

    protected TaskMessage publishTaskAndAwaitThisMessagesResponse(final BlockingQueue<Event<QueuePublisher>> pubEvents,
                                                                  final ConsumerCreationResult consumerResult,
                                                                  final TaskMessage classifyMessage, final String taskMessageExpected)
        throws InterruptedException, CodecException, JsonProcessingException
    {
        return publishTaskAndAwaitResultAsTaskMessage(pubEvents, consumerResult.getLatch(), classifyMessage, taskMessageExpected);
    }

    protected TaskMessage publishTaskAndAwaitThisMessagesResponse(BlockingQueue<Event<QueuePublisher>> pubEvents,
                                                                  ConsumerCreationResult consumerResult, TaskMessage classifyMessage)
        throws InterruptedException, CodecException, JsonProcessingException
    {
        return publishTaskAndAwaitThisMessagesResponse(pubEvents, consumerResult, classifyMessage, null);
    }

    /*
        Utility method to publish a task to input queue and attempt to read the expected taskId back as a response from results queue.
     */
    protected TaskMessage publishTaskAndAwaitResultAsTaskMessage(BlockingQueue<Event<QueuePublisher>> pubEvents, CountDownLatch latch,
                                                                 TaskMessage message, String expectedTaskMessage)
        throws InterruptedException, JsonProcessingException, CodecException
    {
        //add message to input queue
        //pubEvents.add(new PublishQueueEvent(PublishEventType.PUBLISH, 0L, mapper.writeValueAsBytes(message), INPUT_QUEUENAME));
        pubEvents.add(new PublisherPublishEvent(mapper.writeValueAsBytes(message)));

        Delivery deliveredResult = null;
        final String awaitThisMessage = Strings.isNullOrEmpty(expectedTaskMessage) ? message.getTaskId() : expectedTaskMessage;

        //give some time for task to be processed and result consumed (result consumer should update latch on consumption)
        final boolean timeout = !latch.await(RESULT_TIMEOUTSECONDS, TimeUnit.SECONDS);

        return getResultAsTaskMessage(awaitThisMessage, timeout);

    }

    /**
     * Utility method to get a specific message from the queue without any waiting.
     *
     * @param getThisMessage
     * @return
     */
    protected TaskMessage getResultAsTaskMessage(String getThisMessage)
    {
        return getResultAsTaskMessage(getThisMessage, false);
    }

    /**
     * Utility method to get a specific message from the queue without any waiting.
     *
     * @param awaitThisMessage
     * @param timeout
     * @return
     */
    private TaskMessage getResultAsTaskMessage(String awaitThisMessage, boolean timeout)
    {
        Delivery deliveredResult;
        deliveredResult = consumerImpl.getDelivery(awaitThisMessage);

        if (timeout && deliveredResult == null) {
            // timeout happened while waiting on the given message, make final check for delivery then give up.
            logger.error("Timeout happened while waiting for the response to taskId: " + awaitThisMessage);
            throw new RuntimeException("Timeout happened while waiting for the response to taskId: " + awaitThisMessage);
        }

        // check if we haven't got a result, try relatching and waiting again -> we should only return from here with correct response or timeout.
        if (deliveredResult == null) {
            // the latch has fired, so the message queue filter has received a message the user was interested in, but they then requested
            // an item that wasn't in the queue yet.
            // This can happen if you do something like this: filter by taskId: 123.
            // Request child 123.2*, but the queue can accept 123 / 123.1 and 123.2, so any arriving will wake this code up.
            // We can either go back to latching for another message OR I have opted to throw, and fix the tests to filter better to only
            // the message you want.  So change here would be to use filter: 123.2, and publishAndAwait on the same 123.2 id.
            logger.warn("Failed to locate the message you requested taskId: " + awaitThisMessage);

            debugCurrentQueueItems();

            throw new RuntimeException(
                "Failed to locate the message you requested taskId: " + awaitThisMessage + "\nBut the message queue did receive a valid item matching the filter id.  Please make sure that you aren't allowing more than 1 item in your filter list ( and are latching on count 1) if you want a specific child only:\n"
                + "Ensure that the queue latch=1, and change the queue filter, or increase the latch to the number of children that the workflow accepts into the queue.");
        }

        TaskMessage resultMessage = getTaskMessageFromDelivery(deliveredResult);
        return resultMessage;
    }

    private void debugCurrentQueueItems()
    {
        logger.warn("Message queue currently contains: " + consumerImpl.getDelivery().size());

        // do we have any items on the queue at all, if so, output what we have?
        for (Map.Entry<String, Delivery> deliveredItem : consumerImpl.getDelivery().entrySet()) {
            Delivery tmpDel = deliveredItem.getValue();
            TaskMessage tm = getTaskMessageFromDelivery(tmpDel);
            logger.warn(
                String.format("Queue contains other item: {%s} TrackingInfo jobTaskId: {%s}",
                              tm.getTaskId(), tm.getTracking() == null ? "null" : tm.getTracking().getJobTaskId()));
        }
    }

    /**
     * Create policy worker task message to classify and execute on a document, given a workflow identifiers.
     *
     * @param taskId
     * @param taskClassifier
     * @param document
     * @param workflowId
     * @param executePolicy
     * @return
     * @throws CodecException
     */
    protected TaskMessage createPolicyWorkerTaskMessage(final String taskId, final String taskClassifier, final Document document,
                                                        final Long workflowId, final boolean executePolicy)
        throws CodecException
    {
        // create with job tracking by default.
        TrackingInfo trackingInfo = createTrackingInfo(taskId);

        TaskMessage classifyMessage
            = TestTaskMessageHelper.getClassifyTaskMessage(taskId, taskClassifier, document,
                                                           workflowId.toString(), executePolicy, getProjectId(),
                                                           properties.getDataStorePartialReference(), INPUT_QUEUENAME, trackingInfo);
        return classifyMessage;
    }

    /**
     * Create policy worker task message to classify and execute on a document, given a set of collection sequence identifiers.
     *
     * @param taskId
     * @param taskClassifier
     * @param document
     * @param collectionSequenceIds
     * @param executePolicy
     * @return
     * @throws CodecException
     */
    protected TaskMessage createPolicyWorkerTaskMessage(final String taskId, final String taskClassifier, final Document document,
                                                        final List<String> collectionSequenceIds, final boolean executePolicy)
        throws CodecException
    {
        // create with job tracking by default.
        TrackingInfo trackingInfo = createTrackingInfo(taskId);

        TaskMessage classifyMessage
            = TestTaskMessageHelper.getClassifyTaskMessage(taskId, taskClassifier, document,
                                                           collectionSequenceIds, executePolicy, getProjectId(),
                                                           properties.getDataStorePartialReference(), INPUT_QUEUENAME, trackingInfo);
        return classifyMessage;
    }

    /**
     * Create policy worker task message to classify and execute on a document, given a workflow identifiers.
     *
     * @param taskId
     * @param taskClassifier
     * @param document
     * @param workflowId
     * @param collectionSequenceIds
     * @param policyIds
     * @param executePolicy
     * @param executeOnly
     * @return
     * @throws CodecException
     */
    protected TaskMessage createPolicyWorkerTaskMessage(final String taskId, final String taskClassifier, final Document document,
                                                      final Long workflowId, final List<String> collectionSequenceIds,
                                                      final Collection<Long> policyIds, final boolean executePolicy,
                                                      final boolean executeOnly)
        throws CodecException
    {
        // create with job tracking by default.
        TrackingInfo trackingInfo = createTrackingInfo(taskId);

        if (executeOnly) {
            final TaskMessage taskMessage = TestTaskMessageHelper.getExecuteTaskMessage(taskId, taskClassifier, document, policyIds,
                                                                                     getProjectId(), collectionSequenceIds, INPUT_QUEUENAME, trackingInfo);
            return taskMessage;
        }
        
        final TaskMessage taskMessage
            = TestTaskMessageHelper.getClassifyTaskMessage(taskId, taskClassifier, document,
                                                           workflowId.toString(), executePolicy, getProjectId(),
                                                           properties.getDataStorePartialReference(), INPUT_QUEUENAME, trackingInfo);
        return taskMessage;
    }

    protected TrackingInfo createTrackingInfo(String taskId)
    {
        TrackingInfo trackingInfo = new TrackingInfo();
        trackingInfo.setTrackingPipe(properties.getJobTrackingPipe());
        trackingInfo.setJobTaskId(taskId);
        // if we need to set this, set to rubbish to never remove the tracking info.
        trackingInfo.setTrackTo("xyz");
        return trackingInfo;
    }

    /*
        Utility method to create publisher to put messages onto an input channel. Returns the publish queue for messages to added to
     */
    protected BlockingQueue<Event<QueuePublisher>> createRabbitPublisher(Channel inputChannel)
    {
        BlockingQueue<Event<QueuePublisher>> pubEvents = new LinkedBlockingQueue<>();
        TestQueuePublisherImpl publisherImpl = new TestQueuePublisherImpl(inputChannel, INPUT_QUEUENAME);
        this.publisher = new EventPoller<>(2, pubEvents, publisherImpl);
        new Thread(publisher).start();
        return pubEvents;
    }

    protected class ConsumerCreationResult
    {
        private CountDownLatch latch;
        private String consumeId;

        public ConsumerCreationResult(CountDownLatch latch, String consumeId)
        {
            this.latch = latch;
            this.consumeId = consumeId;
        }

        public CountDownLatch getLatch()
        {
            return latch;
        }

        public String getConsumeId()
        {
            return consumeId;
        }
    }

    protected ConsumerCreationResult createRabbitConsumer(Channel resultsChannel, BlockingQueue<Event<QueueConsumer>> conEvents,
                                                          final int latchCount, final String taskIdFilter)
        throws IOException
    {
        return createRabbitConsumer(resultsChannel, conEvents, RESULT_QUEUENAME, 1, taskIdFilter);
    }

    protected ConsumerCreationResult createRabbitConsumer(Channel resultsChannel, BlockingQueue<Event<QueueConsumer>> conEvents,
                                                          String queueName, int latchCount, final String taskIdFilter)
        throws IOException
    {
        CountDownLatch latch = new CountDownLatch(latchCount);
        RabbitUtil.declareWorkerQueue(resultsChannel, queueName, 32);
        this.consumerImpl = new TestQueueConsumerImpl(latch, conEvents, resultsChannel, taskIdFilter);
        this.consumer = new DefaultRabbitConsumer(conEvents, consumerImpl);
        String consumeId = resultsChannel.basicConsume(queueName, consumer);
        new Thread(consumer).start();
        return new ConsumerCreationResult(latch, consumeId);
    }

    /*
        Utility class used to publish messages onto a RabbitMQ queue
     */
    protected class TestQueuePublisherImpl implements QueuePublisher
    {
        private final Channel channel;
        private final String queueName;

        public TestQueuePublisherImpl(final Channel ch, final String queue)
        {
            this.channel = Objects.requireNonNull(ch);
            this.queueName = Objects.requireNonNull(queue);
        }

        @Override
        public void handlePublish(final byte[] data)
        {
            try {
                channel.basicPublish("", queueName, MessageProperties.TEXT_PLAIN, data);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```


Overlapping Code:
```
extends IntegrationTestBase
{
private final static Logger logger = LoggerFactory.getLogger(BaseTestsHelper.class);
protected final CorePolicyObjectMapper mapper = new CorePolicyObjectMapper();
protected static String INPUT_QUEUENAME = "Input";
protected static String RESULT_QUEUENAME = "Results";
//number of seconds allowed to wait for result to be delivered to results queue consumer
protected static int RESULT_TIMEOUTSECONDS;
protected static String RABBIT_HOST = "localhost";
protected static String RABBIT_USER = "guest";
protected static Strit RABBIT_PORT = 5672;
protected static com.rabbitmq.client.Connection rabbitConnection;
protected final AnnotationConfigApplicationContext testingPropertiesApplicationContext;
protected final PolicyWorkerTestingProperties properties;
EventPoller<QueuePublisher> publisher;
DefaultRabbitConsumer consumer;
TestQueueConsumerImpl consumerImpl;
public BaseTestsHelper()
{
testingPropertiesApplicationContext = new AnnotationConfigApplicationContext();
testingPropertiesApplicationContext.register(ConversionConfiguration.class);
testingPropertiesApplicationContext.register(PropertySourcesPlaceholderConfigurer.class);
RootBeanDefinition beanDefinition = new RootBeanDefinition();
beanDefinition.setBeanClass(PolicyWorkerTestingProperties.class);
testingPropertiesApplicationContext.registerBeanDefinition("PolicyWorkerTestingProperties", beanDefinition);
testingPropertiesApplicationContext.refresh();
properties = testingPropertiesApplicationContext.getBean(PolicyWorkerTestingProperties.class);
}
public static void RabbitConnectionSetup() throws TimeoutException, IOException
{
rabbitConnection = RabbitHelper.getRabbitConnection(RABBIT_HOST, RABBIT_PORT, RABBIT_USER, RABBIT_PASS);
}
@Before
public void SetupRabbitQueues() throws IOException, TimeoutException {
if(rabbitConnection==null) {
INPUT_QUEUENAME = properties.getInputQueueName();
RESULT_QUEUENAME = properties.getResultQueueName();
RESULT_TIMEOUTSECONDS = properties.getResultTimeoutSeconds();
RABBIT_HOST = properties.getRabbitHost();
RABBIT_USER = properties.getRabbitUser();
RABBIT_PA
```
<Overlap Ratio: 0.9429726088908846>

---

--- 137 --
Question ID: 1704444939fcf69e719c1bbc4bdecfe0465c939a
Original Code:
```
public class Home extends Fragment {

        private SessionManager sessionManager;


    public static Home newInstance() {
        Home fragment = new Home();
        return fragment;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
      final View view = inflater.inflate(R.layout.fragment_home, container, false);
            sessionManager=new SessionManager(getContext());
            if(sessionManager.isLoggedIn()==false){
                startActivity(new Intent(getActivity(),WalkThrough.class));
            }



        return view;


    }


}
```


Overlapping Code:
```
ragment {
private SessionManager sessionManager;
public static Home newInstance() {
Home fragment = new Home();
return fragment;
}
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
Bundle savedInstanceState) {
final View view = inflater.inflate(R.layout.fragment_home, container, false);
sessionManager=new SessionManager(getContext());
if(sessionManager.isLoggedIn()==false){
startActivity(new Intent(getActivity(),WalkThrou
```
<Overlap Ratio: 0.8888888888888888>

---

--- 138 --
Question ID: a64a8d59f9facfd85555beac520568b4f8641d58
Original Code:
```
class DutiesLoader extends Observable {
    private static final String DATA_FILE = "duties.txt";

    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    private final File filesDir;

    public DutiesLoader(File filesDir) {
        this.filesDir = filesDir;
    }

    ArrayList<Duty> readDuties() {
        File dutiesFile = new File(filesDir, DATA_FILE);
        if (!dutiesFile.exists()) {
            try {
                dutiesFile.createNewFile();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        ArrayList<String> lines;
        try {
            lines = new ArrayList<>(FileUtils.readLines(dutiesFile));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        ArrayList<Duty> newDuties = new ArrayList<>();
        ObjectReader reader = OBJECT_MAPPER.readerFor(Duty.class);
        for (String line : lines) {
            Duty duty;
            try {
                duty = reader.readValue(line);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            newDuties.add(duty);
        }
        return newDuties;
    }

    void saveDuties(List<Duty> duties) {
        File dutiesFile = new File(filesDir, DATA_FILE);
        ArrayList<String> lines = new ArrayList<>();
        for (Duty duty : duties) {
            ObjectWriter writer = OBJECT_MAPPER.writer();
            try {
                lines.add(writer.writeValueAsString(duty));
            } catch (JsonProcessingException e) {
                throw new RuntimeException(e);
            }
        }
        try {
            FileUtils.writeLines(dutiesFile, lines);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        setChanged();
        notifyObservers();
    }
}
```


Overlapping Code:
```
 extends Observable {
private static final String DATA_FILE = "duties.txt";
private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
private final File filesDir;
public DutiesLoader(File filesDir) {
this.filesDir = filesDir;
}
ArrayList<Duty> readDuties() {
File dutiesFile = new File(filesDir, DATA_FILE);
if (!dutiesFile.exists()) {
try {
dutiesFile.createNewFile();
} catch (IOException e) {
throw new RuntimeException(e);
}
}
ArrayList<String> lines;
try {
lines = new ArrayList<>(FileUtils.readLines(dutiesFile));
} catch (IOException e) {
throw new RuntimeException(e);
}
ArrayList<Duty> newDuties = new ArrayList<>();
ObjectReader reader = OBJECT_MAPPER.readerFor(Duty.class);
for (String line : lines) {
Duty duty;
try {
duty = reader.readValue(line);
} catch (IOException e) {
throw new RuntimeException(e);
}
newDuties.add(duty);
}
return newDuties;
}
void saveDuties(List<Duty> duties) {
File dutiesFile = new File(filesDir, DATA_FILE);
ArrayList<String> lines = new ArrayList<>();
for (Duty duty : duties) {
ObjectWriter writer = OBJECT_MAPPER.writer();
try {
lines.add(writer.writeValueAsString(duty));
} catch (JsonProcessingException e) {
throw new RuntimeException(e);
}
}
try {
FileUtils.writeLines(dutiesFile, lines);
} catch (IOException e) {
throw new RuntimeException(e);
}
setChanged();
notifyO
```
<Overlap Ratio: 0.9757709251101322>

---

--- 139 --
Question ID: 142f7fa91033369eeb5a00642c2ddf9f8d753aca
Original Code:
```
public class ProgramHeartbeatTable {
  private static final Gson GSON = TriggeringScheduleInfoAdapter.addTypeAdapters(new GsonBuilder()).create();
  private final StructuredTable table;

  // TODO: CDAP-14950 add service to clean up this table periodically
  public ProgramHeartbeatTable(StructuredTableContext context) {
    this.table = context.getTable(StoreDefinition.ProgramHeartbeatStore.PROGRAM_HEARTBEATS);
  }

  /**
   * Write {@link RunRecordMeta} to heart beat table as value.
   *
   * @param runRecordMeta row value to write
   * @param timestampInSeconds used for creating rowKey
   */
  public void writeRunRecordMeta(RunRecordMeta runRecordMeta, long timestampInSeconds) throws IOException {
    List<Field<?>> fields = createRowKey(timestampInSeconds, runRecordMeta.getProgramRunId());
    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.RUN_RECORD, GSON.toJson(runRecordMeta)));
    table.upsert(fields);
  }

  @VisibleForTesting
  public void deleteAll() throws IOException {
    table.deleteAll(Range.all());
  }

  private List<Field<?>> createRowKey(long timestampInSeconds, ProgramRunId programRunId) {
    List<Field<?>> fields = new ArrayList<>();
    // add namespace at the beginning
    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.NAMESPACE_FIELD, programRunId.getNamespace()));
    // add timestamp
    fields.add(Fields.longField(StoreDefinition.ProgramHeartbeatStore.TIMESTAMP_SECONDS_FIELD, timestampInSeconds));
    // add program runId fields, skip namespace as that is part of row key
    fields.add(
      Fields.stringField(StoreDefinition.ProgramHeartbeatStore.APPLICATION_FIELD, programRunId.getApplication()));
    fields.add(
      Fields.stringField(StoreDefinition.ProgramHeartbeatStore.PROGRAM_TYPE_FIELD, programRunId.getType().name()));
    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.PROGRAM_FIELD, programRunId.getProgram()));
    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.RUN_FIELD, programRunId.getRun()));
    return fields;
  }

  /**
   * Add namespace and timestamp and return it as the scan key.
   * @return scan key
   */
  private List<Field<?>> getScanKey(String namespace, long timestamp) {
    List<Field<?>> fields = new ArrayList<>();
    fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.NAMESPACE_FIELD, namespace));
    fields.add(Fields.longField(StoreDefinition.ProgramHeartbeatStore.TIMESTAMP_SECONDS_FIELD, timestamp));
    return fields;
  }

  /**
   * Scan the table for the time range for each of the namespace provided
   * and return collection of latest {@link RunRecordMeta}
   * we maintain the latest {@link RunRecordMeta} identified by {@link ProgramRunId},
   * Since there can be more than one RunRecordMeta for the
   * same runId due to multiple state changes and heart beat messages.
   *
   * @param startTimestampInSeconds inclusive start rowKey
   * @param endTimestampInSeconds exclusive end rowKey
   * @param namespaces set of namespaces
   * @return collection of {@link RunRecordMeta}
   */
  public Collection<RunRecordMeta> scan(long startTimestampInSeconds, long endTimestampInSeconds,
                                        Set<String> namespaces) throws IOException {
    List<RunRecordMeta> resultRunRecordList = new ArrayList<>();
    for (String namespace : namespaces) {
      List<Field<?>> startRowKey = getScanKey(namespace, startTimestampInSeconds);
      List<Field<?>> endRowKey = getScanKey(namespace, endTimestampInSeconds);
      performScanAddToList(startRowKey, endRowKey, resultRunRecordList);
    }
    return resultRunRecordList;
  }

  /**
   * Scan is executed based on the given startRowKey and endRowKey, for each of the scanned rows, we maintain
   * the latest {@link RunRecordMeta} identified by its {@link ProgramRunId} in a map. Finally after scan is
   * complete add the runrecords to the result list
   *
   * @param startRowKey byte array used as start row key in scan
   * @param endRowKey byte array used as end row key in scan
   * @param runRecordMetas result list to which the run records to be added
   */
  private void performScanAddToList(List<Field<?>> startRowKey, List<Field<?>> endRowKey,
                                    List<RunRecordMeta> runRecordMetas) throws IOException {
    try (CloseableIterator<StructuredRow> iterator =
      table.scan(Range.create(startRowKey, Range.Bound.INCLUSIVE, endRowKey, Range.Bound.EXCLUSIVE),
                 Integer.MAX_VALUE)) {
      Map<ProgramRunId, RunRecordMeta> runIdToRunRecordMap = new HashMap<>();
      while (iterator.hasNext()) {
        StructuredRow row = iterator.next();
        RunRecordMeta runRecordMeta = GSON.fromJson(row.getString(StoreDefinition.ProgramHeartbeatStore.RUN_RECORD),
                                                    RunRecordMeta.class);
        ProgramRunId runId = getProgramRunIdFromRow(row);
        runIdToRunRecordMap.put(runId, runRecordMeta);
      }

      // since the serialized runRecordMeta doesn't have programRunId (transient), we will create and
      // add the programRunId to RunRecordMeta and add to result list

      runIdToRunRecordMap.entrySet().forEach((entry) -> {
        RunRecordMeta.Builder builder = RunRecordMeta.builder(entry.getValue());
        builder.setProgramRunId(entry.getKey());
        runRecordMetas.add(builder.build());
      });
    }
  }

  /**
   * Return {@link ProgramRunId} from the row
   */
  private ProgramRunId getProgramRunIdFromRow(StructuredRow row) {
    return new ProgramRunId(row.getString(StoreDefinition.ProgramHeartbeatStore.NAMESPACE_FIELD),
                            row.getString(StoreDefinition.ProgramHeartbeatStore.APPLICATION_FIELD),
                            ProgramType.valueOf(
                              row.getString(StoreDefinition.ProgramHeartbeatStore.PROGRAM_TYPE_FIELD)),
                            row.getString(StoreDefinition.ProgramHeartbeatStore.PROGRAM_FIELD),
                            row.getString(StoreDefinition.ProgramHeartbeatStore.RUN_FIELD));
  }
}
```


Overlapping Code:
```
blic class ProgramHeartbeatTable {
private static final Gson GSON = TriggeringScheduleInfoAdapter.addTypeAdapters(new GsonBuilder()).create();
private final StructuredTable table;
// TODO: CDAP-14950 add service to clean up this table periodically
public ProgramHeartbeatTable(StructuredTableContext context) {
this.table = context.getTable(StoreDefinition.ProgramHeartbeatStore.PROGRAM_HEARTBEATS);
}
/**
* Write {@link RunRecordMeta} to heart beat table as value.
*
* @param runRecordMeta row value to write
* @param timestampInSeconds used for creating rowKey
*/
public void writeRunRecordMeta(RunRecordMeta runRecordMeta, long timestampInSeconds) throws IOException {
List<Field<?>> fields = createRowKey(timestampInSeconds, runRecordMeta.getProgramRunId());
fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.RUN_RECORD, GSON.toJson(runRecordMeta)));
table.upsert(fields);
}
@VisibleForTesting
public void deleteAll() throws IOException {
table.deleteAll(Range.all());
}
private List<Field<?>> createRowKey(long timestampInSeconds, ProgramRunId programRunId) {
List<Field<?>> fields = new ArrayList<>();
// add namespace at the beginning
fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.NAMESPACE_FIELD, programRunId.getNamespace()));
// add timestamp
fields.add(Fields.longField(StoreDefinition.ProgramHeartbeatStore.TIMESTAMP_SECONDS_FIELD, timestampInSeconds));
// add program runId fields, skip namespace as that is part of row key
fields.add(
Fields.stringField(StoreDefinition.ProgramHeartbeatStore.APPLICATION_FIELD, programRunId.getApplication()));
fields.add(
Fields.stringField(StoreDefinition.ProgramHeartbeatStore.PROGRAM_TYPE_FIELD, programRunId.getType().name()));
fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.PROGRAM_FIELD, programRunId.getProgram()));
fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.RUN_FIELD, programRunId.getRun()));
return fields;
}
/**
* Add namespace and timestamp and return it as the scan key.
* @return scan key
*/
private List<Field<?>> getScanKey(String namespace, long timestamp) {
List<Field<?>> fields = new ArrayList<>();
fields.add(Fields.stringField(StoreDefinition.ProgramHeartbeatStore.NAMESPACE_FIELD, namespace));
fields.add(Fields.longField(StoreDefinition.ProgramHeartbeatStore.TIMESTAMP_SECONDS_FIELD, timestam
```
<Overlap Ratio: 0.9991496598639455>

---

--- 140 --
Question ID: 290f1b1e289ef853c0757fccf9c2683d1336b132
Original Code:
```
public class MainTestCFPGrowth_saveToFile {

	public static void main(String[] arg) throws FileNotFoundException,
			IOException {
		String database = fileToPath("contextCFPGrowth.txt");
		String output = ".//output.txt";
		String MISfile = fileToPath("MIS.txt");

		// Applying the CFPGROWTH algorithmMainTestFPGrowth.java
		AlgoCFPGrowth algo = new AlgoCFPGrowth();
		algo.runAlgorithm(database, output, MISfile);
		algo.printStats();
	}

	public static String fileToPath(String filename)
			throws UnsupportedEncodingException {
		URL url = MainTestCFPGrowth_saveToFile.class.getResource(filename);
		return java.net.URLDecoder.decode(url.getPath(), "UTF-8");
	}
}
```


Overlapping Code:
```
FPGrowth_saveToFile {
public static void main(String[] arg) throws FileNotFoundException,
IOException {
String database = fileToPath("contextCFPGrowth.txt");
String output = ".//output.txt";
String MISfile = fileToPath("MIS.txt");
// Applying the CFPGROWTH algorithmMainTestFPGrowth.java
AlgoCFPGrowth algo = new AlgoCFPGrowth();
algo.runAlgorithm(database, output, MISfile);
algo.printStats();
}
public static String fileToPath(String filename)
throws UnsupportedEncodingException {
URL url = MainTestCFPGrowth_saveToFile.class.getResource(filename);
return java.net.URLDecoder.decode(url.getPath(), "UTF-8");
}
}
```
<Overlap Ratio: 0.9654088050314465>

---

--- 141 --
Question ID: 824135b9f6a04e10e994a5ef11d8d24cfa8c6860
Original Code:
```
public class ItemDetailFragment extends Fragment {
    /**
     * The fragment argument representing the item ID that this fragment
     * represents.
     */
    public static final String ARG_ITEM_ID = "item_id";

    /**
     * The dummy content this fragment is presenting.
     */
    private DummyContent.DummyItem mItem;

    /**
     * Mandatory empty constructor for the fragment manager to instantiate the
     * fragment (e.g. upon screen orientation changes).
     */
    public ItemDetailFragment() {
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (getArguments().containsKey(ARG_ITEM_ID)) {
            // Load the dummy content specified by the fragment
            // arguments. In a real-world scenario, use a Loader
            // to load content from a content provider.
            mItem = DummyContent.ITEM_MAP.get(getArguments().getString(ARG_ITEM_ID));

            Activity activity = this.getActivity();
            CollapsingToolbarLayout appBarLayout = (CollapsingToolbarLayout) activity.findViewById(R.id.toolbar_layout);
            if (appBarLayout != null) {
                appBarLayout.setTitle(mItem.content);
            }
        }
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View rootView = inflater.inflate(R.layout.fragment_item_detail, container, false);

        // Show the dummy content as text in a TextView.
        if (mItem != null) {
            String rf= readFile((Environment.getExternalStorageDirectory().getPath() + "/downloadhtml/"  + mItem.content));
            ((TextView) rootView.findViewById(R.id.item_detail)).setText(Html.fromHtml(rf));

        }

        return rootView;
    }
    public static String readFile(String path){
        String res="";
        try{
            FileInputStream fin = new FileInputStream(path);

            int length = fin.available();

            byte [] buffer = new byte[length];
            fin.read(buffer);

            res = EncodingUtils.getString(buffer, "UTF-8");

            fin.close();
        }

        catch(Exception e){
            e.printStackTrace();
        }

        return res;
    }
}
```


Overlapping Code:
```
ublic class ItemDetailFragment extends Fragment {
/**
* The fragment argument representing the item ID that this fragment
* represents.
*/
public static final String ARG_ITEM_ID = "item_id";
/**
* The dummy content this fragment is presenting.
*/
private DummyContent.DummyItem mItem;
/**
* Mandatory empty constructor for the fragment manager to instantiate the
* fragment (e.g. upon screen orientation changes).
*/
public ItemDetailFragment() {
}
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
if (getArguments().containsKey(ARG_ITEM_ID)) {
// Load the dummy content specified by the fragment
// arguments. In a real-world scenario, use a Loader
// to load content from a content provider.
mItem = DummyContent.ITEM_MAP.get(getArguments().getString(ARG_ITEM_ID));
Activity activity = this.getActivity();
CollapsingToolbarLayout appBarLayout = (CollapsingToolbarLayout) activity.findViewById(R.id.toolbar_layout);
if (appBarLayout != null) {
appBarLayout.setTitle(mItem.content);
}
}
}
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
Bundle savedInstanceState) {
View rootView = inflater.inflate(R.layout.fragment_item_detail, container, false);
// Show the dummy content as text in a TextView.
if (mItem != null) {
String rf= readFile((Environment.getExternalStorageDirectory().getPath() + "/downloadhtml/" + mItem.content));
((TextView) rootView.findViewById(R.id.item_detail)).setText(Html.fromHtml(rf));
}
return rootView;
}
public static String readFile(String path){
String res="";
try{
FileInputStream fin = new FileInputStream(path);
int length = fin.available();
byte [] buffer = new byte[length];
fin.read(buffer);
res = EncodingUtils.getString(buffer, "UTF-8");
fin.close();
}
catch(Exception e){
e.printStackTrace();
}
return res;
}
```
<Overlap Ratio: 0.9983606557377049>

---

--- 142 --
Question ID: 5b99103db174570ebeeb82d08a8a8fa6fe00b76b
Original Code:
```
public class SchedulerUtilities {

	private SchedulerUtilities() {
	}

	private static SchedulerUtilities singleton;
	private WorkloadService ws;
	String agentName = "_CLOUD";

	static public SchedulerUtilities getSingleton() {
		if (singleton == null) {
			singleton = new SchedulerUtilities();
		}
		return singleton;
	}

	public WorkloadService getWorkloadService() {
		
		AuthenticationServlet.configureSSL();
		
		if (ws != null)
			return ws;

		boolean configExists = false;
		String url = null;

		try {
			String ws_url = System.getenv("NA_WS_URL");
			if ((ws_url != null) && (!ws_url.equalsIgnoreCase(""))) {
				url = ws_url;
				configExists = true;
			} else {
				String VCAP_SERVICES = System.getenv("VCAP_SERVICES");

				if (VCAP_SERVICES != null) {
					Object jsonObject = JSON.parse(VCAP_SERVICES);
					JSONObject json = (JSONObject) jsonObject;
					String key = null;
					JSONArray list = null;
					java.util.Set<String> keys = json.keySet();
					for (String eachkey : keys) {
						if (eachkey.contains("WorkloadScheduler")) {
							key = eachkey;
							break;
						}
					}
					if (key == null) {
						return null;
					}
					list = (JSONArray) json.get(key);
					JSONObject jsonService = (JSONObject) list.get(0);
					JSONObject credentials = (JSONObject) jsonService
							.get("credentials");

					url = (String) credentials.get("url");
					configExists = true;
				}
			}
			if (configExists) {
				int index = url.indexOf("tenantId=") + 9;
				String prefix = url.substring(index, index + 2);
				agentName = prefix + agentName;
				try {
					WorkloadService.disableCertificateValidation();
					ws = new WorkloadService(url);
				} catch (Exception e) {
					return null;
				}

				return ws;
			} else {
				return null;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	public String turnOn() {
		if (ws == null) return null;
		SchedulerData data = getData();
		if (data == null) return null;
		
		if (data.isOn()) return "Already on";
		
		WAProcess process = new WAProcess("BluemixInfo", "BluemixInfo");
		RESTAction action = new RESTAction(
				"http://www.bluemix.info/api/readfeedsscheduler",
				"application/json", "text/html", RestfulStep.GET_METHOD,
				"file.text");
		RESTAuthenticationData auth = RESTAuthenticationData.fromUserPwd(
				data.getUserName(), data.getPassword());

		RESTInput input = RESTInput.fromText("");
		Step step = new RestfulStep(agentName, action, auth, input);
		process.addStep(step);

		try {
			process.addTrigger(TriggerFactory.everyDayAt(0, 0));
			process.addTrigger(TriggerFactory.everyDayAt(1, 0));
			process.addTrigger(TriggerFactory.everyDayAt(2, 0));
			process.addTrigger(TriggerFactory.everyDayAt(3, 0));
			process.addTrigger(TriggerFactory.everyDayAt(4, 0));
			process.addTrigger(TriggerFactory.everyDayAt(5, 0));
			process.addTrigger(TriggerFactory.everyDayAt(6, 0));
			process.addTrigger(TriggerFactory.everyDayAt(7, 0));
			process.addTrigger(TriggerFactory.everyDayAt(8, 0));
			process.addTrigger(TriggerFactory.everyDayAt(9, 0));
			process.addTrigger(TriggerFactory.everyDayAt(10, 0));
			process.addTrigger(TriggerFactory.everyDayAt(11, 0));
			process.addTrigger(TriggerFactory.everyDayAt(12, 0));
			process.addTrigger(TriggerFactory.everyDayAt(13, 0));
			process.addTrigger(TriggerFactory.everyDayAt(14, 0));
			process.addTrigger(TriggerFactory.everyDayAt(15, 0));
			process.addTrigger(TriggerFactory.everyDayAt(16, 0));
			process.addTrigger(TriggerFactory.everyDayAt(17, 0));
			process.addTrigger(TriggerFactory.everyDayAt(18, 0));
			process.addTrigger(TriggerFactory.everyDayAt(19, 0));
			process.addTrigger(TriggerFactory.everyDayAt(20, 0));
			process.addTrigger(TriggerFactory.everyDayAt(21, 0));
			process.addTrigger(TriggerFactory.everyDayAt(22, 0));
			process.addTrigger(TriggerFactory.everyDayAt(23, 0));

			Task task = ws.createAndEnableTask(process);
			if (task != null) {
				long processId = task.getId();
				data.setProcessId(processId);
				data.setLastChanged(new Date());
				data.setOn(true);
				
				ws.runTask(processId);

				try {
					CouchDbConnector db;
					db = DatabaseUtilities.getSingleton().getDB();
					db.update(data);
					
					return "Scheduler turned on";
				} catch (Exception e) {
					e.printStackTrace();
					return null;
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}		
		return null;
	}

	public String turnOff() {
		if (ws == null) return null;
		SchedulerData data = getData();
		if (data == null) return null;
		
		if (data.isOn() == false) return "Already off";
		
		try {
			ws.deleteTask(data.getProcessId());
			
			data.setLastChanged(new Date());
			data.setOn(false);
			
			CouchDbConnector db;
			db = DatabaseUtilities.getSingleton().getDB();
			db.update(data);
			
			return "Scheduler turned off";
		}
		catch (Exception e) {
			e.printStackTrace();
			return null;
		}	
	}

	public SchedulerData getData() {
		SchedulerData out = null;
		CouchDbConnector db;
		try {
			List<SchedulerData> list = new ArrayList<SchedulerData>();

			db = DatabaseUtilities.getSingleton().getDB();

			ViewQuery viewQuery = new ViewQuery().dbPath(db.path())
					.designDocId("_design/views").viewName("allSchedulerData")
					.includeDocs(true).cacheOk(false);
			list = db.queryView(viewQuery, SchedulerData.class);
			if (list != null) {
				if (list.size() > 0) {
					out = list.get(0);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}

		if (out == null) {
			try {
				db = DatabaseUtilities.getSingleton().getDB();
				UUID id = UUID.randomUUID();
				UUID userName = UUID.randomUUID();
				UUID password = UUID.randomUUID();

				SchedulerData data = new SchedulerData(id.toString(),
						userName.toString(), password.toString(), null, 0, false);

				db.create(data.getId(), data);

				out = db.get(SchedulerData.class, data.getId());
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		return out;
	}

	public static void main(String[] args) {
		WorkloadService w = SchedulerUtilities.getSingleton()
				.getWorkloadService();
		SchedulerUtilities.getSingleton().turnOn();

	}	
}
```


Overlapping Code:
```
 class SchedulerUtilities {
private SchedulerUtilities() {
}
private static SchedulerUtilities singleton;
private WorkloadService ws;
String agentName = "_CLOUD";
static public SchedulerUtilities getSingleton() {
if (singleton == null) {
singleton = new SchedulerUtilities();
}
return singleton;
}
public WorkloadService getWorkloadService() {

AuthenticationServlet.configureSSL();

if (ws != null)
return ws;
boolean configExists = false;
String url = null;
try {
String ws_url = System.getenv("NA_WS_URL");
if ((ws_url != null) && (!ws_url.equalsIgnoreCase(""))) {
url = ws_url;
configExists = true;
} else {
String VCAP_SERVICES = System.getenv("VCAP_SERVICES");
if (VCAP_SERVICES != null) {
Object jsonObject = JSON.parse(VCAP_SERVICES);
JSONObject json = (JSONObject) jsonObject;
String key = null;
JSONArray list = null;
java.util.Set<String> keys = json.keySet();
for (String eachkey : keys) {
if (eachkey.contains("WorkloadScheduler")) {
key = eachkey;
break;
}
}
if (key == null) {
return null;
}
list = (JSONArray) json.get(key);
JSONObject jsonService = (JSONObject) list.get(0);
JSONObject credentials = (JSONObject) jsonService
.get("credentials");
url = (String) credentials.get("url");
configExists = true;
}
}
if (configExists) {
int index = url.indexOf("tenantId=") + 9;
String prefix = url.substring(index, index + 2);
agentName = prefix + agentName;
try {
WorkloadService.disableCertificateValidation();
ws = new WorkloadService(url);
} catch (Exception e) {
return null;
}
return ws;
} else {
return null;
}
} catch (Exception e) {
e.printStackTrace();
return null;
}
}
public String turnOn() {
if (ws == null) return null;
SchedulerData data = getData();
if (data == null) return null;

if (data.isOn()) return "Already on";

WAProcess process = new WAProcess("BluemixInfo", "BluemixInfo");
RESTAction action = new RESTAction(
"http://www.bluemix.info/api/readfeedsscheduler",
"application/json", "text/html", RestfulStep.GET_METHOD,
"file.text");
RESTAuthenticationData auth = RESTAuthenticationData.fromUserPwd(
data.getUserName(), data.getPassword());
RESTInput input = RESTInput.fromText("");
Step step = new RestfulStep(age
```
<Overlap Ratio: 0.9750566893424036>

---

--- 143 --
Question ID: a118177967c8fcc855011eef1276e06e745a43f2
Original Code:
```
public class WordCountResource extends ServerResource {

	private static Logger logger = LoggerFactory.getLogger(WordCountResource.class);

	private StreamAnslysisApplication application;

	private String topn = "";

	@Override
	public void doInit() {
		application = (StreamAnslysisApplication) getApplication();
		topn = (String) this.getRequest().getAttributes().get("topn");
		logger.info("Request Url: " + URLCodecUtils.decoder(getReference().toString(), "utf-8") + ".");
	}

	@Get("json")
	public Object retrivalTopNWordCount() {
		if (topn == null || topn.length() == 0 || !JavaPattern.isAllNum(topn)) {
			logger.error("Params `type` or `datestr` is null.");
			return new ErrorResponse.Builder(-1, "params error!").build();
		}
		List<WordAndCount> wordCounts = application.selectWordCountTopN(Integer.parseInt(topn));
		return wordCounts;
	}

}
```


Overlapping Code:
```
 extends ServerResource {
private static Logger logger = LoggerFactory.getLogger(WordCountResource.class);
private StreamAnslysisApplication application;
private String topn = "";
@Override
public void doInit() {
application = (StreamAnslysisApplication) getApplication();
topn = (String) this.getRequest().getAttributes().get("topn");
logger.info("Request Url: " + URLCodecUtils.decoder(getReference().toString(), "utf-8") + ".");
}
@Get("json")
public Object retrivalTopNWordCount() {
if (topn == null || topn.length() == 0 || !JavaPattern.isAllNum(topn)) {
logger.error("Params `type` or `datestr` is null.");
return new ErrorResponse.Builder(-1, "params error!").build();
}
List<WordAndCount> wordCounts = application.selectWordCountTopN(Integer.
```
<Overlap Ratio: 0.9157509157509157>

---

--- 144 --
Question ID: a7f136cf3ce0f087dee10f2b8c0f79b108004cd0
Original Code:
```
@JsonIgnoreProperties(ignoreUnknown = true)
public class SubmitResult {

    public String version;

    @Override
    public String toString() {
        return "SubmitResult{" +
                "version='" + version + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SubmitResult that = (SubmitResult) o;
        return Objects.equals(version, that.version);
    }

    @Override
    public int hashCode() {
        return Objects.hash(version);
    }
}
```


Overlapping Code:
```
@JsonIgnoreProperties(ignoreUnknown = true)
public class SubmitResult {
public String version;
@Override
public String toString() {
return "SubmitResult{" +
"version='" + version + '\'' +
'}';
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
SubmitResult that = (SubmitResult) o;
return Objects.equals(version, that.version);
}
@Override
public int hashCode() {
return Objects.hash(version);
}

```
<Overlap Ratio: 0.9979123173277662>

---

--- 145 --
Question ID: b0b1bc8b5f5618af539d98868044fa261f40a73f
Original Code:
```
public class FormalToJavaExt_c extends ToJavaExt_c {
    private static final long serialVersionUID = SerialVersionUID.generate();

    @Override
    public Node toJava(JifToJavaRewriter rw) throws SemanticException {
        Formal n = (Formal) node();
        Formal newN = rw.nodeFactory().Formal(n.position(), n.flags(), n.type(),
                n.id());
        LocalInstance li = n.localInstance();

        newN = newN.localInstance(
                rw.typeSystem().localInstance(li.position(), li.flags(),
                        rw.typeSystem().unknownType(li.position()), li.name()));
        return newN;
    }
}
```


Overlapping Code:
```
oJavaExt_c extends ToJavaExt_c {
private static final long serialVersionUID = SerialVersionUID.generate();
@Override
public Node toJava(JifToJavaRewriter rw) throws SemanticException {
Formal n = (Formal) node();
Formal newN = rw.nodeFactory().Formal(n.position(), n.flags(), n.type(),
n.id());
LocalInstance li = n.localInstance();
newN = newN.localInstance(
rw.typeSystem().localInstance(li.position(), li.flags(),
rw.typeSystem().unknownType(li.position()),
```
<Overlap Ratio: 0.9019607843137255>

---

--- 146 --
Question ID: 92c8dfdbe78fe366baed58c95037a1c963e22e47
Original Code:
```
public final class FindOccurrencesEngine {

	public static FindOccurrencesEngine create(IOccurrencesFinder finder) {
		return new FindOccurrencesEngine(finder);
	}

	private IOccurrencesFinder fFinder;

	private FindOccurrencesEngine(IOccurrencesFinder finder) {
		if (finder == null)
			throw new IllegalArgumentException();
		fFinder = finder;
	}

	private String run(Program astRoot, int offset, int length) {
		String message = fFinder.initialize(astRoot, offset, length);
		if (message != null)
			return message;

		performNewSearch(fFinder, astRoot.getSourceModule());
		return null;
	}

	public String run(ISourceModule input, int offset, int length)
			throws ModelException, IOException {
		if (input.getSourceRange() == null) {
			return "SearchMessages.FindOccurrencesEngine_noSource_text"; //$NON-NLS-1$
		}

		final Program root = SharedASTProvider.getAST(input,
				SharedASTProvider.WAIT_YES, null);
		if (root == null) {
			return "SearchMessages.FindOccurrencesEngine_cannotParse_text"; //$NON-NLS-1$
		}
		return run(root, offset, length);
	}

	private void performNewSearch(IOccurrencesFinder finder,
			ISourceModule element) {
		NewSearchUI.runQueryInBackground(new OccurrencesSearchQuery(finder,
				element));
	}
}
```


Overlapping Code:
```
c final class FindOccurrencesEngine {
public static FindOccurrencesEngine create(IOccurrencesFinder finder) {
return new FindOccurrencesEngine(finder);
}
private IOccurrencesFinder fFinder;
private FindOccurrencesEngine(IOccurrencesFinder finder) {
if (finder == null)
throw new IllegalArgumentException();
fFinder = finder;
}
private String run(Program astRoot, int offset, int length) {
String message = fFinder.initialize(astRoot, offset, length);
if (message != null)
return message;
performNewSearch(fFinder, astRoot.getSourceModule());
return null;
}
public String run(ISourceModule input, int offset, int length)
throws ModelException, IOException {
if (input.getSourceRange() == null) {
return "SearchMessages.FindOccurrencesEngine_noSource_text"; //$NON-NLS-1$
}
final Program root = SharedASTProvider.getAST(input,
SharedASTProvider.WAIT_YES, null);
if (root == null) {
return "SearchMessages.FindOccurrencesEngine_cannotParse_text"; //$NON-NLS-1$
}
return run(root, offset, length);
}
private void performNewSearch(IOccurrencesFinder finder,
ISourceModule element) {
NewSearchUI.runQueryInBackground(new OccurrencesSearchQuery(fi
```
<Overlap Ratio: 0.9785407725321889>

---

--- 147 --
Question ID: b988d9d974cb5b731fb663b05fd6ef66706564d3
Original Code:
```
public class AliasCombinationsFunctionsFirstNameTest {

    @Test
    public void shouldReturnEmptyListForEmptyFirstName() {
        InputNames emptyFirstName = new InputNames("", "somename", "somename");
        assertThat(firstNameCombinations(emptyFirstName, emptyFirstName)).isEqualTo(emptyList());
    }

    @Test
    public void shouldReturnEmptyListForOneName() {
        InputNames oneFirstName = new InputNames("John", "somename", "somename");

        assertThat(firstNameCombinations(oneFirstName, oneFirstName)).isEqualTo(emptyList());
    }

    @Test
    public void shouldReturnCombinationsForTwoNames() {
        InputNames inputNames = new InputNames("John David", "somename", "somename");

        List<CandidateName> expected = asList(
                new CandidateName("John", "David"),
                new CandidateName("David", "John")
        );

        assertThat(firstNameCombinations(inputNames, inputNames)).isEqualTo(expected);
    }

    @Test
    public void shouldReturnCombinationsForThreeNames() {
        InputNames inputNames = new InputNames("John David Greg", "somename", "somename");

        List<CandidateName> expected = asList(
                new CandidateName("John", "David"),
                new CandidateName("John", "Greg"),
                new CandidateName("David", "John"),
                new CandidateName("David", "Greg"),
                new CandidateName("Greg", "John"),
                new CandidateName("Greg", "David")
        );

        assertThat(firstNameCombinations(inputNames, inputNames)).isEqualTo(expected);
    }
}
```


Overlapping Code:
```
nctionsFirstNameTest {
@Test
public void shouldReturnEmptyListForEmptyFirstName() {
InputNames emptyFirstName = new InputNames("", "somename", "somename");
assertThat(firstNameCombinations(emptyFirstName, emptyFirstName)).isEqualTo(emptyList());
}
@Test
public void shouldReturnEmptyListForOneName() {
InputNames oneFirstName = new InputNames("John", "somename", "somename");
assertThat(firstNameCombinations(oneFirstName, oneFirstName)).isEqualTo(emptyList());
}
@Test
public void shouldReturnCombinationsForTwoNames() {
InputNames inputNames = new somename", "somename");
List<CandidateName> expected = asList(
new CandidateName("John", "David"),
new CandidateName("David", "John")
);
assertThat(firstNameCombinations(inputNames, inputNames)).isEqualTo(expected);
}
@Test
public void shouldReturnCombinationsForThreeNames() {
somename", "somename");
List<CandidateName> expected = asList(
new CandidateName("John", "David"),
new CandidateName("John", "Greg"),
new CandidateName("David", "John"),
new CandidateName("David", "Greg"),
new CandidateName("Greg", "John"),
new CandidateName("Greg", "David")
);
assertThat(firstNameCombinations(inputNames, inputNames)).isEqualTo(expected);
}
}
```
<Overlap Ratio: 0.9104134762633997>

---

--- 148 --
Question ID: 91f85df2b19ffc6280b29d7542f65f0cb9ff258b
Original Code:
```
public class lesson1 extends Applet { // notice'lesson01', which is also the name of the file : lesson01.java
 SimpleUniverse simpleU; // this is the SimpleUniverse Class that is used for Java3D
	
	public lesson1 (){  // this constructor is sometimes needed, even when empty as in here    
	}    

	public void init() { 
	// this function will be called by both applications and applets
	//this is usually the first function to write        
	setLayout(new BorderLayout()); // standard Java code for BorderLayout

	// Canvas3D is where all the action will be taking place, don't worry, after adding it
	// to your layout, you don't have to touch it.    	
	Canvas3D c = new Canvas3D(SimpleUniverse.getPreferredConfiguration()); 

	// add Canvas3D to center of BorderLayout
 	add("Center", c);    

	simpleU= new SimpleUniverse(c); // setup the SimpleUniverse, attach the Canvas3D

	
	//This is very important, the SceneGraph (where all the action takes place) is created
	//by calling a function which here is called 'createSceneGraph'.
	//The function is not necessary, you can put all your code here, but it is a 
	//standard in Java3D to create your SceneGraph contents in the function 'createSceneGraph'

 	BranchGroup scene = createSceneGraph(); 

	//set the ViewingPlatform (where the User is) to nominal, more on this in the next lesson
     simpleU.getViewingPlatform().setNominalViewingTransform();

	// this will optimize your SceneGraph, not necessary, but it will allow your program to run faster.
     scene.compile(); 
     simpleU.addBranchGraph(scene); //add your SceneGraph to the SimpleUniverse   
 }

 public BranchGroup createSceneGraph() {      
	//Here we will create a basic SceneGraph with a ColorCube object

	// This BranchGroup is the root of the SceneGraph, 'objRoot' is the name I use,
	// and it is typically the standard name for it, but can be named anything.
	BranchGroup objRoot = new BranchGroup(); 

	// create a ColorCube object of size 0.5
	ColorCube c = new ColorCube(0.5f);
	
	// add ColorCube to SceneGraph
	objRoot.addChild(c);

	// return Scene Graph
	return objRoot;
	}

 public void destroy() {	// this function will allow Java3D to clean up upon quiting
	simpleU.removeAllLocales();    
 }  

 public static void main(String[] args) {
	// if called as an application, a 500x500 window will be opened    
     Frame frame = new MainFrame(new lesson1(), 500, 500);    
 }
}
```


Overlapping Code:
```
extends Applet { // notice'lesson01', which is also the name of the file : lesson01.java
SimpleUniverse simpleU; // this is the SimpleUniverse Class that is used for Java3D

public lesson1 (){ // this constructor is sometimes needed, even when empty as in here 
} 
public void init() { 
// this function will be called by both applications and applets
//this is usually the first function to write 
setLayout(new BorderLayout()); // standard Java code for BorderLayout
// Canvas3D is where all the action will be taking place, don't worry, after adding it
// to your layout, you don't have to touch it. 
Canvas3D c = new Canvas3D(SimpleUniverse.getPreferredConfiguration()); 
// add Canvas3D to center of BorderLayout
add("Center", c); 
simpleU= new SimpleUniverse(c); // setup the SimpleUniverse, attach the Canvas3D

//This is very important, the SceneGraph (where all the action takes place) is created
//by calling a function which here is called 'createSceneGraph'.
//The function is not necessary, you can put all your code here, but it is a 
//standard in Java3D to create your SceneGraph contents in the function 'createSceneGraph'
BranchGroup scene = createSceneGraph(); 
//set the ViewingPlatform (where the User is) to nominal, more on this in the next lesson
simpleU.getViewingPlatform().setNominalViewingTransform();
// this will optimize your SceneGraph, not necessary, but it will allow your program to run faster.
scene.compile(); 
simpleU.addBranchGraph(scene); //add your SceneGraph to the SimpleUniverse 
}
public BranchGroup createSceneGraph() { 
//Here we will create a basic SceneGraph with a ColorCube object
// This BranchGroup is the root of the SceneGraph, 'objRoot' is the name I use,
// and it is typically the standard name for it, but can be named anything.
BranchGroup objRoot = new BranchGroup(); 
// create a ColorCube object of size 0.5
ColorCube c = new ColorCube(0.5f);

// add ColorCube to SceneGraph
objRoot.addChild(c);
// return Scene Graph
return objRoot;
}
public void destroy() { // this function will allow Java3D to clean up upon quiting
simpleU.removeAllLocales(); 
} 
public static void main(String[] args) {
// if called as an application, a 500x500 window will be opened 
Frame frame = new MainFrame(n
```
<Overlap Ratio: 0.9782608695652174>

---

--- 149 --
Question ID: e15072953d44f08d20d8ddb6630b4142699dd6e7
Original Code:
```
public class WordIdMapCompilerTest {

    @Test
    public void testGrowableArray() {
        WordIdMapCompiler.GrowableIntArray array = new WordIdMapCompiler.GrowableIntArray(5);
        array.set(3, 1);
        assertEquals("[0, 0, 0, 1]", Arrays.toString(array.getArray()));
        array.set(0, 2);
        array.set(10, 3);
        assertEquals("[2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3]", Arrays.toString(array.getArray()));
    }

    @Test
    public void testCompiler() throws IOException {
        WordIdMapCompiler compiler = new WordIdMapCompiler();
        compiler.addMapping(3, 1);
        compiler.addMapping(3, 2);
        compiler.addMapping(3, 3);
        compiler.addMapping(10, 0);

        File file = File.createTempFile("kuromoji-wordid-", ".bin");
        file.deleteOnExit();

        OutputStream output = new BufferedOutputStream(new FileOutputStream(file));

        compiler.write(output);
        output.close();

        InputStream input = new BufferedInputStream(new FileInputStream(file));

        WordIdMap wordIds = new WordIdMap(input);

        assertEquals("[1, 2, 3]", Arrays.toString(wordIds.lookUp(3)));
        assertEquals("[0]", Arrays.toString(wordIds.lookUp(10)));
        assertEquals("[]", Arrays.toString(wordIds.lookUp(1)));
    }
}
```


Overlapping Code:
```
blic void testGrowableArray() {
WordIdMapCompiler.GrowableIntArray array = new WordIdMapCompiler.GrowableIntArray(5);
array.set(3, 1);
assertEquals("[0, 0, 0, 1]", Arrays.toString(array.getArray()));
array.set(0, 2);
array.set(10, 3);
assertEquals("[2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3]", Arrays.toString(array.getArray()));
}
@Test
public void testCompiler() throws IOException {
WordIdMapCompiler compiler = new WordIdMapCompiler();
compiler.addMapping(3, 1);
compiler.addMapping(3, 2);
compiler.addMapping(3, 3);
compiler.addMapping(10, 0);
File file = File.createTempFile("kuromoji-wordid-", ".bin");
file.deleteOnExit();
OutputStream output = new BufferedOutputStream(new FileOutputStream(file));
compiler.write(output);
output.close();
InputStream input = new BufferedInputStream(new FileInputStream(file));
WordIdMap wordIds = new WordIdMap(input);
assertEquals("[1, 2, 3]", Arrays.toString(wordIds.lookUp(3)));
assertEquals("[0]", Arrays.toString(wordIds.lookUp(10)));
assertEquals("[]", Arrays.toString(wordId
```
<Overlap Ratio: 0.9415041782729805>

---

--- 150 --
Question ID: d7ceb4df3cee3a8fd86da9044f015697da822d20
Original Code:
```
@Component
public class DefaultAccessAuthenticator implements AccessAuthenticator {

  private static final Logger logger = LoggerFactory.getLogger(DefaultAccessAuthenticator.class);

  @Autowired
  @Lazy
  private ObjectMapper objectMapper;

  @Override
  public String generateAccessToken(TokenInfo tokenInfo) {
    return generateAccessToken(tokenInfo, Preferences.getSystemSk());
  }

  @Override
  public String generateAccessToken(TokenInfo tokenInfo, String secretKey) {
    try {
      String token = objectMapper.writeValueAsString(tokenInfo);
      token = EncryptionUtil.aes(token, secretKey, true);
      return token;
    } catch (final Exception ex) {
      logger.error("Failed to generate api access token!", ex);
    }
    return null;
  }

  @Override
  public TokenInfo parseAccessToken(String tokenString) {
    return parseAccessToken(tokenString, Preferences.getSystemSk());
  }

  @Override
  public TokenInfo parseAccessToken(String tokenString, String secretKey) {
    TokenInfo tokenInfo = null;
    if (!StringUtils.isEmpty(tokenString)) {
      final String decrypted = EncryptionUtil.aes(tokenString, secretKey, false);
      if (StringUtils.isNotEmpty(decrypted)) {
        try {
          tokenInfo = objectMapper.readValue(decrypted, TokenInfo.class);
        } catch (final Exception ex) {
          logger.error(String.format("Failed to parse token: \"%s\"", tokenString), ex);
          logger.error(String.format("Decrypted data is: %s", decrypted));
        }
      }
    }
    return tokenInfo;
  }

  @Override
  public int verifyAccessToken(String tokenString) {
    return verifyAccessToken(tokenString, Preferences.getSystemSk());
  }

  @Override
  public int verifyAccessToken(String tokenString, String secretKey) {
    final TokenInfo tokenInfo = parseAccessToken(tokenString, secretKey);
    if (tokenInfo == null) {
      return TokenInfo.TOKEN_ERROR_INVALID;
    } else if ((tokenInfo.getExpiryTime() >= 0)
        && (tokenInfo.getExpiryTime() < System.currentTimeMillis())) {
      return TokenInfo.TOKEN_ERROR_EXPIRED;
    }
    return 0;
  }

}
```


Overlapping Code:
```
blic class DefaultAccessAuthenticator implements AccessAuthenticator {
private static final Logger logger = LoggerFactory.getLogger(DefaultAccessAuthenticator.class);
@Autowired
@Lazy
private ObjectMapper objectMapper;
@Override
public String generateAccessToken(TokenInfo tokenInfo) {
return generateAccessToken(tokenInfo, Preferences.getSystemSk());
}
@Override
public String generateAccessToken(TokenInfo tokenInfo, String secretKey) {
try {
String token = objectMapper.writeValueAsString(tokenInfo);
token = EncryptionUtil.aes(token, secretKey, true);
return token;
} catch (final Exception ex) {
logger.error("Failed to generate api access token!", ex);
}
return null;
}
@Override
public TokenInfo parseAccessToken(String tokenString) {
return parseAccessToken(tokenString, Preferences.getSystemSk());
}
@Override
public TokenInfo parseAccessToken(String tokenString, String secretKey) {
TokenInfo tokenInfo = null;
if (!StringUtils.isEmpty(tokenString)) {
final String decrypted = EncryptionUtil.aes(tokenString, secretKey, false);
if (StringUtils.isNotEmpty(decrypted)) {
try {
tokenInfo = objectMapper.readValue(decrypted, TokenInfo.class);
} catch (final Exception ex) {
logger.error(String.format("Failed to parse token: \"%s\"", tokenString), ex);
logger.error(String.format("Decrypted data is: %s", decrypted));
}
}
}
return tokenInfo;
}
@Override
public int verifyAccessToken(String tokenString) {
return verifyAccessToken(tokenString, Preferences.getSystemSk());
}
@Override
public int verifyAccessToken(String tokenString, String secretKey) {
final TokenInfo tokenInfo = parseAccessToken(tokenString, secretKey);
if (tokenInfo == null) {
return TokenInfo.TOKEN_ERROR_INVALID;
} else if ((tokenInfo.getExpiryTime() >= 0)
&& (tokenInfo.getExpiryTime() < System.currentTimeMillis())) {
return TokenInfo.TOKEN_ERROR_EXPIRED;
}
return 0;
}

```
<Overlap Ratio: 0.9924892703862661>

---

--- 151 --
Question ID: c8ae3cf188459210d699c76a648243cf46944212
Original Code:
```
class UALocationProvider {

    @Nullable
    private LocationAdapter availableAdapter;
    private boolean isConnected = false;

    private final List<LocationAdapter> adapters = new ArrayList<>();
    private final Context context;
    private final Intent locationUpdateIntent;

    /**
     * UALocationProvider constructor.
     *
     * @param context The application context.
     * @param locationUpdateIntent The update intent to send for location responses.
     */
    UALocationProvider(@NonNull Context context, @NonNull Intent locationUpdateIntent) {
        this.context = context;
        this.locationUpdateIntent = locationUpdateIntent;

        // This is to prevent a log message saying Google Play Services is unavailable on amazon devices.
        if (PlayServicesUtils.isGooglePlayStoreAvailable(context) && PlayServicesUtils.isFusedLocationDependencyAvailable()) {
            adapters.add(new FusedLocationAdapter(context));
        }

        adapters.add(new StandardLocationAdapter());
    }

    @VisibleForTesting
    UALocationProvider(@NonNull Context context, @NonNull Intent locationUpdateIntent, LocationAdapter... adapters) {
        this.context = context;
        this.locationUpdateIntent = locationUpdateIntent;
        this.adapters.addAll(Arrays.asList(adapters));
    }

    /**
     * Cancels all location requests for the connected adapter's pending intent.
     */
    @WorkerThread
    void cancelRequests() {
        Logger.verbose("UALocationProvider - Canceling location requests.");
        connect();

        if (availableAdapter == null) {
            Logger.debug("UALocationProvider - Ignoring request, connected adapter unavailable.");
            return;
        }

        try {
            PendingIntent pendingIntent = PendingIntent.getService(context, availableAdapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_NO_CREATE);
            if (pendingIntent != null) {
                availableAdapter.cancelLocationUpdates(context, pendingIntent);
            }
        } catch (Exception ex) {
            Logger.error("Unable to cancel location updates: " + ex.getMessage());
        }
    }

    /**
     * Requests location updates.
     *
     * @param options The request options.
     * @throws IllegalStateException if the provider is not connected.
     */
    @WorkerThread
    void requestLocationUpdates(@NonNull LocationRequestOptions options) {
        connect();

        if (availableAdapter == null) {
            Logger.debug("UALocationProvider - Ignoring request, connected adapter unavailable.");
            return;
        }

        Logger.verbose("UALocationProvider - Requesting location updates: " + options);
        try {
            PendingIntent pendingIntent = PendingIntent.getService(context, availableAdapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_UPDATE_CURRENT);
            availableAdapter.requestLocationUpdates(context, options, pendingIntent);
        } catch (Exception ex) {
            Logger.error("Unable to request location updates: " + ex.getMessage());
        }
    }

    /**
     * Requests a single location update.
     *
     * @param options The request options.
     * @return A pending location result.
     */
    @WorkerThread
    Cancelable requestSingleLocation(@NonNull LocationRequestOptions options, ResultCallback<Location> resultCallback) {
        connect();

        if (availableAdapter == null) {
            Logger.debug("UALocationProvider - Ignoring request, connected adapter unavailable.");
        }

        Logger.verbose("UALocationProvider - Requesting single location update: " + options);

        try {
            return availableAdapter.requestSingleLocation(context, options, resultCallback);
        } catch (Exception ex) {
            Logger.error("Unable to request location: " + ex.getMessage());
        }

        return null;
    }

    /**
     * Connects to the provider.
     */
    @WorkerThread
    private void connect() {
        if (isConnected) {
            return;
        }

        for (LocationAdapter adapter : adapters) {
            Logger.verbose("UALocationProvider - Attempting to connect to location adapter: " + adapter);

            if (adapter.isAvailable(context)) {

                if (availableAdapter == null) {
                    Logger.verbose("UALocationProvider - Using adapter: " + adapter);
                    availableAdapter = adapter;
                }

                /*
                 * Need to cancel requests on all providers regardless of the current
                 * connected provider because pending intents persist between app starts
                 * and there is no way to determine what provider was used previously.
                 */
                try {
                    PendingIntent pendingIntent = PendingIntent.getService(context, adapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_NO_CREATE);
                    if (pendingIntent != null) {
                        adapter.cancelLocationUpdates(context, pendingIntent);
                    }
                } catch (Exception ex) {
                    Logger.error("Unable to cancel location updates: " + ex.getMessage());
                }
            } else {
                Logger.verbose("UALocationProvider - Adapter unavailable: " + adapter);
            }
        }

        isConnected = true;
    }


    /**
     * Called when a system location provider availability changes.
     *
     * @param options Current location request options.
     */
    @WorkerThread
    void onSystemLocationProvidersChanged(@NonNull LocationRequestOptions options) {
        Logger.verbose("UALocationProvider - Available location providers changed.");

        connect();

        if (availableAdapter != null) {
            PendingIntent pendingIntent = PendingIntent.getService(context, availableAdapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_UPDATE_CURRENT);
            availableAdapter.onSystemLocationProvidersChanged(context, options, pendingIntent);
        }
    }

    /**
     * Checks if updates are currently being requested or not.
     *
     * @return {@code true} if updates are being requested, otherwise {@code false}.
     */
    @WorkerThread
    boolean areUpdatesRequested() {
        connect();

        if (availableAdapter == null) {
            return false;
        }

        return getService(context, availableAdapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_NO_CREATE) != null;
    }
}
```


Overlapping Code:
```
ocationProvider {
@Nullable
private LocationAdapter availableAdapter;
private boolean isConnected = false;
private final List<LocationAdapter> adapters = new ArrayList<>();
private final Context context;
private final Intent locationUpdateIntent;
/**
* UALocationProvider constructor.
*
* @param context The application context.
* @param locationUpdateIntent The update intent to send for location responses.
*/
UALocationProvider(@NonNull Context context, @NonNull Intent locationUpdateIntent) {
this.context = context;
this.locationUpdateIntent = locationUpdateIntent;
// This is to prevent a log message saying Google Play Services is unavailable on amazon devices.
if (PlayServicesUtils.isGooglePlayStoreAvailable(context) && PlayServicesUtils.isFusedLocationDependencyAvailable()) {
adapters.add(new FusedLocationAdapter(context));
}
adapters.add(new StandardLocationAdapter());
}
@VisibleForTesting
UALocationProvider(@NonNull Context context, @NonNull Intent locationUpdateIntent, LocationAdapter... adapters) {
this.context = context;
this.locationUpdateIntent = locationUpdateIntent;
this.adapters.addAll(Arrays.asList(adapters));
}
/**
* Cancels all location requests for the connected adapter's pending intent.
*/
@WorkerThread
void cancelRequests() {
Logger.verbose("UALocationProvider - Canceling location requests.");
connect();
if (availableAdapter == null) {
Logger.debug("UALocationProvider - Ignoring request, connected adapter unavailable.");
return;
}
try {
PendingIntent pendingIntent = PendingIntent.getService(context, availableAdapter.getRequestCode(), this.locationUpdateIntent, PendingIntent.FLAG_NO_CREATE);
if (pendingIntent != null) {
availableAdapter.cancelLocationUpdates(context, pendingIntent);
}
} catch (Exception ex) {
Logger.error("Unable to cancel location updates: " + ex.getMessage());
}
}
/**
* Requests location updates.
*
* @param options The request options.
* @throws IllegalStateException if the provider is not connected.
*/
@WorkerThread
void requestLocationUpdates(@NonNull LocationRequestOptions option
```
<Overlap Ratio: 0.9734345351043643>

---

--- 152 --
Question ID: be0015e402b07706ce13be7c877fce65664da2fb
Original Code:
```
@RunWith(MockitoJUnitRunner.class)
public class MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapperTest {

    @Mock
    private MatchingServiceAdapterConfiguration configuration;

    @Mock
    private IdGenerator idGenerator;

    @Mock
    private AssertionLifetimeConfiguration assertionLifetimeConfiguration;

    private static final String ENTITY_ID = "entityId";
    private static final String TEST_ID = "testId";
    private static final String REQUEST_ID = "requestId";
    private static final String ASSERTION_CONSUMER_SERVICE_URL = "assertionConsumerServiceUrl";
    private static final String AUTHN_REQUEST_ISSUER_ID = "authnRequestIssuerId";
    private static final String HASH_PID = "hashPid";
    private MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapper mapper;

    @Before
    public void setup(){
        DateTimeFreezer.freezeTime();
        mapper = new MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapper(configuration, assertionLifetimeConfiguration, idGenerator);
        when(assertionLifetimeConfiguration.getAssertionLifetime()).thenReturn(Duration.parse("30m"));
        when(configuration.getEntityId()).thenReturn(ENTITY_ID);
        when(idGenerator.getId()).thenReturn(TEST_ID);
    }

    @After
    public void after() {
        DateTimeFreezer.unfreezeTime();
    }

    @Test
    public void map_shouldTranslateMatchingServiceResponseDtoToIdaResponseFromMatchingServiceWithMatch() {
        MatchingServiceResponseDto response = aMatchingServiceResponseDto().withMatch().build();
        OutboundResponseFromMatchingService responseFromMatchingService = mapper.map(
            response,
            HASH_PID,
            REQUEST_ID,
            ASSERTION_CONSUMER_SERVICE_URL,
            AuthnContext.LEVEL_2,
            AUTHN_REQUEST_ISSUER_ID);

        assertThat(responseFromMatchingService.getStatus()).isEqualTo(MatchingServiceMatch);
        assertThat(responseFromMatchingService.getInResponseTo()).isEqualTo(REQUEST_ID);
        assertThat(responseFromMatchingService.getId()).isEqualTo(TEST_ID);
        assertThat(responseFromMatchingService.getIssuer()).isEqualTo(ENTITY_ID);
        assertThat(responseFromMatchingService.getMatchingServiceAssertion()).isPresent();
        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getAssertionRestrictions()).isNotNull();
        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getId()).isEqualTo(TEST_ID);
        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getIssuerId()).isEqualTo(ENTITY_ID);
        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getAssertionRestrictions().getInResponseTo()).isEqualTo(REQUEST_ID);
        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getAssertionRestrictions().getNotOnOrAfter()).isEqualTo(DateTime.now().plus(assertionLifetimeConfiguration.getAssertionLifetime().toMilliseconds()));
        assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getAssertionRestrictions().getRecipient()).isEqualTo(ASSERTION_CONSUMER_SERVICE_URL);
    }

    @Test
    public void map_shouldTranslateMatchingServiceResponseDtoToIdaResponseFromMatchingServiceWithNoMatch() {
        MatchingServiceResponseDto response = aMatchingServiceResponseDto().withNoMatch().build();

        OutboundResponseFromMatchingService idaResponse = mapper.map(
            response,
            HASH_PID,
            REQUEST_ID,
            ASSERTION_CONSUMER_SERVICE_URL,
            AuthnContext.LEVEL_2,
            AUTHN_REQUEST_ISSUER_ID);

        assertThat(idaResponse.getStatus()).isEqualTo(MatchingServiceIdaStatus.NoMatchingServiceMatchFromMatchingService);
    }

    @Test(expected = UnsupportedOperationException.class)
    public void map_shouldThrowExceptionIfNotNoMatchOrMatch() {
        MatchingServiceResponseDto response = aMatchingServiceResponseDto().withBadResponse().build();

        mapper.map(
            response,
            HASH_PID,
            REQUEST_ID,
            ASSERTION_CONSUMER_SERVICE_URL,
            AuthnContext.LEVEL_2,
            AUTHN_REQUEST_ISSUER_ID);
    }
}
```


Overlapping Code:
```
@RunWith(MockitoJUnitRunner.class)
public class MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapperTest {
@Mock
private MatchingServiceAdapterConfiguration configuration;
@Mock
private IdGenerator idGenerator;
@Mock
private AssertionLifetimeConfiguration assertionLifetimeConfiguration;
private static final String ENTITY_ID = "entityId";
private static final String TEST_ID = "testId";
private static final String REQUEST_ID = "requestId";
private static final String ASSERTION_CONSUMER_SERVICE_URL = "assertionConsumerServiceUrl";
private static final String AUTHN_REQUEST_ISSUER_ID = "authnRequestIssuerId";
private static final String HASH_PID = "hashPid";
private MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapper mapper;
@Before
public void setup(){
DateTimeFreezer.freezeTime();
mapper = new MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapper(configuration, assertionLifetimeConfiguration, idGenerator);
when(assertionLifetimeConfiguration.getAssertionLifetime()).thenReturn(Duration.parse("30m"));
when(configuration.getEntityId()).thenReturn(ENTITY_ID);
when(idGenerator.getId()).thenReturn(TEST_ID);
}
@After
public void after() {
DateTimeFreezer.unfreezeTime();
}
@Test
public void map_shouldTranslateMatchingServiceResponseDtoToIdaResponseFromMatchingServiceWithMatch() {
MatchingServiceResponseDto response = aMatchingServiceResponseDto().withMatch().build();
OutboundResponseFromMatchingService responseFromMatchingService = mapper.map(
response,
HASH_PID,
REQUEST_ID,
ASSERTION_CONSUMER_SERVICE_URL,
AuthnContext.LEVEL_2,
AUTHN_REQUEST_ISSUER_ID);
assertThat(responseFromMatchingService.getStatus()).isEqualTo(MatchingServiceMatch);
assertThat(responseFromMatchingService.getInResponseTo()).isEqualTo(REQUEST_ID);
assertThat(responseFromMatchingService.getId()).isEqualTo(TEST_ID);
assertThat(responseFromMatchingService.getIssuer()).isEqualTo(ENTITY_ID);
assertThat(responseFromMatchingService.getMatchingServiceAssertion()).isPresent();
assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().getAssertionRestrictions()).isNotNull();
assertThat(responseFromMatchingService.getMatchingServiceAssertion().get().get
```
<Overlap Ratio: 0.9954853273137697>

---

--- 153 --
Question ID: d652044c69f807aa99b44cd18e14e2977bde6388
Original Code:
```
public class Test {
    public static void main(String... args) throws Exception {
        new Test().run();
    }

    final File testSrc;
    final File pluginSrc;
    final File pluginClasses ;
    final File pluginJar;
    final List<String> ref1;
    final List<String> ref2;
    final JavaCompiler compiler;
    final StandardJavaFileManager fm;
    ToolBox tb = new ToolBox();

    Test() throws Exception {
        testSrc = new File(tb.testSrc);
        pluginSrc = new File(testSrc, "ShowTypePlugin.java");
        pluginClasses = new File("plugin");
        tb.createDirectories(pluginClasses.toPath());
        pluginJar = new File("plugin.jar");
        ref1 = tb.readAllLines((new File(testSrc,"Identifiers.out")).toPath());
        ref2 = tb.readAllLines((new File(testSrc,"Identifiers_PI.out")).toPath());
        compiler = ToolProvider.getSystemJavaCompiler();
        fm = compiler.getStandardFileManager(null, null, null);
    }

    void run() throws Exception {
        try {
            // compile the plugin explicitly, to a non-standard directory
            // so that we don't find it on the wrong path by accident
            new JavacTask(tb)
              .options("-d", pluginClasses.getPath())
              .files(pluginSrc.getPath())
              .run();

            File plugin = new File(pluginClasses.getPath(), "META-INF/services/com.sun.source.util.Plugin");
            tb.writeFile(plugin.getPath(), "ShowTypePlugin\n");
            new JarTask(tb)
              .run("cf", pluginJar.getPath(), "-C", pluginClasses.getPath(), ".");

            testCommandLine("-Xplugin:showtype", ref1);
            testCommandLine("-Xplugin:showtype PI", ref2);
            testAPI("-Xplugin:showtype", ref1);
            testAPI("-Xplugin:showtype PI", ref2);

            if (errors > 0)
                throw new Exception(errors + " errors occurred");
        } finally {
            fm.close();
        }
    }

    void testAPI(String opt, List<String> ref) throws Exception {
        File identifiers = new File(testSrc, "Identifiers.java");
        fm.setLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, Arrays.asList(pluginJar));
        fm.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(new File(".")));
        List<String> options = Arrays.asList(opt);
        Iterable<? extends JavaFileObject> files = fm.getJavaFileObjects(identifiers);

        System.err.println("test api: " + options + " " + files);
        Task.Result result = new JavacTask(tb, Task.Mode.API)
                                  .fileManager(fm)
                                  .options(opt)
                                  .files(identifiers.toPath())
                                  .run(Task.Expect.SUCCESS)
                                  .writeAll();
        String out = result.getOutput(Task.OutputKind.DIRECT);
        checkOutput(out, ref);
    }

    void testCommandLine(String opt, List<String> ref) {
        File identifiers = new File(testSrc, "Identifiers.java");
        String[] args = {
            "-d", ".",
            "-processorpath", pluginJar.getPath(),
            opt,
            identifiers.getPath() };

        System.err.println("test command line: " + Arrays.asList(args));
        Task.Result result = new JavacTask(tb, Task.Mode.CMDLINE)
                                  .options(args)
                                  .run(Task.Expect.SUCCESS)
                                  .writeAll();
        String out = result.getOutput(Task.OutputKind.DIRECT);
        checkOutput(out, ref);
    }

    private void checkOutput(String out, List<String> ref) {
        List<String> lines = Arrays.asList(out
                .replaceAll(".*?([A-Za-z.]+:[0-9]+: .*)", "$1") // remove file directory
                .split("[\r\n]+"));                             // allow for newline formats
        if (!lines.equals(ref)) {
            error("unexpected output");
        }
    }

    private void error(String msg) {
        System.err.println(msg);
        errors++;
    }

    int errors;
}
```


Overlapping Code:
```
public class Test {
public static void main(String... args) throws Exception {
new Test().run();
}
final File testSrc;
final File pluginSrc;
final File pluginClasses ;
final File pluginJar;
final List<String> ref1;
final List<String> ref2;
final JavaCompiler compiler;
final StandardJavaFileManager fm;
ToolBox tb = new ToolBox();
Test() throws Exception {
testSrc = new File(tb.testSrc);
pluginSrc = new File(testSrc, "ShowTypePlugin.java");
pluginClasses = new File("plugin");
tb.createDirectories(pluginClasses.toPath());
pluginJar = new File("plugin.jar");
ref1 = tb.readAllLines((new File(testSrc,"Identifiers.out")).toPath());
ref2 = tb.readAllLines((new File(testSrc,"Identifiers_PI.out")).toPath());
compiler = ToolProvider.getSystemJavaCompiler();
fm = compiler.getStandardFileManager(null, null, null);
}
void run() throws Exception {
try {
// compile the plugin explicitly, to a non-standard directory
// so that we don't find it on the wrong path by accident
new JavacTask(tb)
.options("-d", pluginClasses.getPath())
.files(pluginSrc.getPath())
.run();
File plugin = new File(pluginClasses.getPath(), "META-INF/services/com.sun.source.util.Plugin");
tb.writeFile(plugin.getPath(), "ShowTypePlugin\n");
new JarTask(tb)
.run("cf", pluginJar.getPath(), "-C", pluginClasses.getPath(), ".");
testCommandLine("-Xplugin:showtype", ref1);
testCommandLine("-Xplugin:showtype PI", ref2);
testAPI("-Xplugin:showtype", ref1);
testAPI("-Xplugin:showtype PI", ref2);
if (errors > 0)
throw new Exception(errors + " errors occurred");
} finally {
fm.close();
}
}
void testAPI(String opt, List<String> ref) throws Exception {
File identifiers = new File(testSrc, "Identifiers.java");
fm.setLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH, Arrays.asList(pluginJar));
fm.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(new File(".")));
List<String> options = Arrays.asList(opt);
Iterable<? extends JavaFileObject> files = fm.getJavaFileObjects(identifiers);
System.err.println("test api: " + options + " " + files);
Task.Result 
```
<Overlap Ratio: 0.9917113603120429>

---

--- 154 --
Question ID: 7fe767735439be440673ed769e77c88f39c34a20
Original Code:
```
@Mojo( name = "unpack", requiresDependencyResolution = ResolutionScope.TEST, inheritByDefault = false )
@Deprecated
public class UnpackMojo
    extends AbstractMojo
{

    /**
     */
    @Component
    private MavenProject project;

    /**
     */
    @Component
    private ArchiverManager archiverManager;

    /**
     * Directory to unpack JARs into if needed
     */
    @Parameter( defaultValue = "${project.build.directory}/assembly/work", required = true )
    protected File workDirectory;

    /**
     * Unpacks the archive file.
     *
     * @throws MojoExecutionException
     */
    public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        final Set<Artifact> dependencies = new LinkedHashSet<Artifact>();

        if ( project.getArtifact() != null && project.getArtifact().getFile() != null )
        {
            dependencies.add( project.getArtifact() );
        }

        @SuppressWarnings( "unchecked" )
        final Set<Artifact> projectArtifacts = project.getArtifacts();
        if ( projectArtifacts != null )
        {
            dependencies.addAll( projectArtifacts );
        }

        for (final Artifact artifact : dependencies) {
            final String name = artifact.getFile().getName();

            final File tempLocation = new File(workDirectory, name.substring(0, name.lastIndexOf('.')));
            boolean process = false;
            if (!tempLocation.exists()) {
                tempLocation.mkdirs();
                process = true;
            } else if (artifact.getFile().lastModified() > tempLocation.lastModified()) {
                process = true;
            }

            if (process) {
                final File file = artifact.getFile();
                try {
                    AssemblyFileUtils.unpack(file, tempLocation, archiverManager);
                } catch (final NoSuchArchiverException e) {
                    getLog().info("Skip unpacking dependency file with unknown extension: " + file.getPath());
                } catch (final ArchiveExpansionException e) {
                    throw new MojoExecutionException("Error unpacking dependency file: " + file, e);
                }
            }
        }
    }

}
```


Overlapping Code:
```
", requiresDependencyResolution = ResolutionScope.TEST, inheritByDefault = false )
@Deprecated
public class UnpackMojo
extends AbstractMojo
{
/**
*/
@Component
private MavenProject project;
/**
*/
@Component
private ArchiverManager archiverManager;
/**
* Directory to unpack JARs into if needed
*/
@Parameter( defaultValue = "${project.build.directory}/assembly/work", required = true )
protected File workDirectory;
/**
* Unpacks the archive file.
*
* @throws MojoExecutionException
*/
public void execute()
throws MojoExecutionException, MojoFailureException
{
final Set<Artifact> dependencies = new LinkedHashSet<Artifact>();
if ( project.getArtifact() != null && project.getArtifact().getFile() != null )
{
dependencies.add( project.getArtifact() );
}
@SuppressWarnings( "unchecked" )
final Set<Artifact> projectArtifacts = project.getArtifacts();
if ( projectArtifacts != null )
{
dependencies.addAll( projectArtifacts );
}
for (final Artifact artifact : dependencies) {
final String name = artifact.getFile().getName();
final File tempLocation = new File(workDirectory, name.substring(0, name.lastIndexOf('.')));
boolean process = false;
if (!tempLocation.exists()) {
tempLocation.mkdirs();
process = true;
} else if (artifact.getFile().lastModified() > tempLocation.lastModified()) {
process = true;
}
if (process) {
final File file = artifact.getFile();
try {
AssemblyFileUtils.unpack(file, tempLocation, archiverManager);
} catch (final NoSuchArchiverException e) {
getLog().info("Skip unpacking dependency file with unknown extension: " + file.getPath());
} catch (final ArchiveExpansionException e) {
throw new MojoExecutionException("Error unpacking 
```
<Overlap Ratio: 0.9645966337782936>

---

--- 155 --
Question ID: 73f029d31b58e29fa340cd156f628fde5bcde265
Original Code:
```
public class JavaBugDemoApplication {

    public static void main(String[] args) {
        JavaBug.addPlugin(new RecursiveOutputCatergory(JavaBug.getCore()));
        JavaBug.addPlugin(new TestPropertyCategory(JavaBug.getCore()));
        JavaBug.addPlugin(new TestOutputCatergory(JavaBug.getCore()));
        JavaBug.addPlugin(new TestSimpleOutputCategory(JavaBug.getCore()));

        JavaBug.addRootObject("Test", new TestClass());
        JavaBug.addRootObject("TestWrapped", BugByteCodeUtil.getBuggedInstance(TestClass.class));
        JavaBug.addRootObject("Recursion", RecursiveTestClass.getBuggedTestHierarchy());
        JavaBug.addRootObject("JavaBugCore", JavaBug.getCore());
        JavaBug.addRootObject("Formats", new BugFormatTest());
        JavaBug.addRootObject("Array", new String[]{"Eins", "Zwei", "Drei"});
        JavaBug.addRootObject("List", Arrays.asList("One", "Two", "Three"));
        HashMap<String, String> map = new LinkedHashMap<>();
        map.put("One", "Eins");
        map.put("Two", "Zwei");
        map.put("Three", "Drei");
        JavaBug.addRootObject("Map", map);
        for (int i = 0; i < 100; i++)
            JavaBug.addRootObject("Integer " + i, i);
        JavaBug.start();
        System.out.println("javaBug startet. Open your browser at: " + JavaBug.getIPAddresses(true));


        while (true) {
            try {
                Thread.sleep(Long.MAX_VALUE);
            } catch (InterruptedException e) {
            }
        }
    }
}
```


Overlapping Code:
```
BugDemoApplication {
public static void main(String[] args) {
JavaBug.addPlugin(new RecursiveOutputCatergory(JavaBug.getCore()));
JavaBug.addPlugin(new TestPropertyCategory(JavaBug.getCore()));
JavaBug.addPlugin(new TestOutputCatergory(JavaBug.getCore()));
JavaBug.addPlugin(new TestSimpleOutputCategory(JavaBug.getCore()));
JavaBug.addRootObject("Test", new TestClass());
JavaBug.addRootObject("TestWrapped", BugByteCodeUtil.getBuggedInstance(TestClass.class));
JavaBug.addRootObject("Recursion", RecursiveTestClass.getBuggedTestHierarchy());
JavaBug.addRootObject("JavaBugCore", JavaBug.getCore());
JavaBug.addRootObject("Formats", new BugFormatTest());
JavaBug.addRootObject("Array", new String[]{"Eins", "Zwei", "Drei"});
JavaBug.addRootObject("List", Arrays.asList("One", "Two", "Three"));
HashMap<String, String> map = new LinkedHashMap<>();
map.put("One", "Eins");
map.put("Two", "Zwei");
map.put("Three", "Drei");
JavaBug.addRootObject("Map", map);
for (int i = 0; i < 100; i++)
JavaBug.addRootObject("Integer " + i, i);
JavaBug.start();
System.out.println("javaBug startet. Open your browser at: " + JavaBug.getIPAddresses(true));
while (true) {
try {
Thread.sleep(Long.MAX_VALUE);
} catch (InterruptedException e) {
}
}
```
<Overlap Ratio: 0.9832>

---

--- 156 --
Question ID: ebf256c4e30dc2018b7d137838b24c4533c10cdf
Original Code:
```
public class ThreeLineAvatarWithTextView extends BaseView {

    public ThreeLineAvatarWithTextView(Context context) {
        super(context);
    }

    public ThreeLineAvatarWithTextView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public ThreeLineAvatarWithTextView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    public ThreeLineAvatarWithTextView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
    }

    @Override
    protected int getLayoutResourceId() {
        return R.layout.three_line_avatar_with_text_view;
    }

    @Override
    protected int[] getStyleAttributeIds() {
        return R.styleable.ThreeLineAvatarWithTextView;
    }

    @Override
    protected void useStyleAttributes(TypedArray attrs) {
        String titleText = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_textForTitle);
        int titleTextColor = attrs.getColor(R.styleable.ThreeLineAvatarWithTextView_textColorForTitle, -1);
        float titleTextSize = attrs.getDimension(R.styleable.ThreeLineAvatarWithTextView_textSizeForTitle, -1);
        int titleTextStyle = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_textStyleForTitle, Typeface.NORMAL);
        int titleTypeface = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_typefaceForTitle, 0);
        String titleFontFamily = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_fontFamilyForTitle);
        String subtitleText = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_textForSubtitle);
        int subtitleTextColor = attrs.getColor(R.styleable.ThreeLineAvatarWithTextView_textColorForSubtitle, -1);
        float subtitleTextSize = attrs.getDimension(R.styleable.ThreeLineAvatarWithTextView_textSizeForSubtitle, -1);
        int subtitleTextStyle = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_textStyleForSubtitle, Typeface.NORMAL);
        int subtitleTypeface = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_typefaceForSubtitle, 0);
        String subtitleFontFamily = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_fontFamilyForSubtitle);
        Drawable avatarSrc = attrs.getDrawable(R.styleable.ThreeLineAvatarWithTextView_avatarSrc);
        attrs.recycle();

        prepareTextViewWithAttrValues(mViewTitle, titleText, titleTextColor, titleTextSize, titleTextStyle, titleTypeface, titleFontFamily);
        prepareTextViewWithAttrValues(mViewSubtitle, subtitleText, subtitleTextColor, subtitleTextSize, subtitleTextStyle, subtitleTypeface, subtitleFontFamily);
        prepareAvatarViewWithAttrValues(avatarSrc);
    }

    @Override
    protected void prepareChildViews() {
        mViewSubtitle.setMaxLines(2);
    }

    @Override
    protected int getMinimumHeightInList() {
        return getContext().getResources().getDimensionPixelSize(R.dimen.threeLineListItemHeight);
    }

    @Override
    public TextView getTitleView() {
        return super.getTitleView();
    }

    @Override
    public TextView getSubtitleView() {
        return super.getSubtitleView();
    }

    @Override
    public AvatarImageView getAvatarImageView() {
        return super.getAvatarImageView();
    }

}
```


Overlapping Code:
```
ss ThreeLineAvatarWithTextView extends BaseView {
public ThreeLineAvatarWithTextView(Context context) {
super(context);
}
public ThreeLineAvatarWithTextView(Context context, AttributeSet attrs) {
super(context, attrs);
}
public ThreeLineAvatarWithTextView(Context context, AttributeSet attrs, int defStyleAttr) {
super(context, attrs, defStyleAttr);
}
public ThreeLineAvatarWithTextView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
super(context, attrs, defStyleAttr, defStyleRes);
}
@Override
protected int getLayoutResourceId() {
return R.layout.three_line_avatar_with_text_view;
}
@Override
protected int[] getStyleAttributeIds() {
return R.styleable.ThreeLineAvatarWithTextView;
}
@Override
protected void useStyleAttributes(TypedArray attrs) {
String titleText = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_textForTitle);
int titleTextColor = attrs.getColor(R.styleable.ThreeLineAvatarWithTextView_textColorForTitle, -1);
float titleTextSize = attrs.getDimension(R.styleable.ThreeLineAvatarWithTextView_textSizeForTitle, -1);
int titleTextStyle = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_textStyleForTitle, Typeface.NORMAL);
int titleTypeface = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_typefaceForTitle, 0);
String titleFontFamily = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_fontFamilyForTitle);
String subtitleText = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_textForSubtitle);
int subtitleTextColor = attrs.getColor(R.styleable.ThreeLineAvatarWithTextView_textColorForSubtitle, -1);
float subtitleTextSize = attrs.getDimension(R.styleable.ThreeLineAvatarWithTextView_textSizeForSubtitle, -1);
int subtitleTextStyle = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_textStyleForSubtitle, Typeface.NORMAL);
int subtitleTypeface = attrs.getInt(R.styleable.ThreeLineAvatarWithTextView_typefaceForSubtitle, 0);
String subtitleFontFamily = attrs.getString(R.styleable.ThreeLineAvatarWithTextView_fontFamilyForSubtitle);
Drawable avatarSrc = attrs.getDrawable(R.styleable.ThreeLineAvatarWithTextView_avatarSrc);
attrs.recycle();
prepareTextViewWithAttrValues(mViewTitle, titleText, titleTextColor, titleTextSize, titleTextStyle, titleTypeface, t
```
<Overlap Ratio: 0.9924745462594068>

---

--- 157 --
Question ID: 7c22b8e327301b6e0dc6375b3fb9ff4f845efc50
Original Code:
```
@SideOnly(Side.CLIENT)
public class ParticleFireflyTail extends Particle {

	private static ResourceLocation texture = new ResourceLocation(Motherlode.MOD_ID, "entity/firefly");
	
	public ParticleFireflyTail(World worldIn, double xCoordIn, double yCoordIn, double zCoordIn, double xSpeedIn,
			double ySpeedIn, double zSpeedIn) {
		
		super(worldIn, xCoordIn, yCoordIn, zCoordIn);
		this.motionX = xSpeedIn + 0.01 * (this.rand.nextDouble() - 0.5);
		this.motionY = ySpeedIn - 0.01 * this.rand.nextDouble();
		this.motionZ = zSpeedIn + 0.01 * (this.rand.nextDouble() - 0.5);
		this.particleScale = 0.25F;
		this.particleMaxAge = 10;
		
		TextureAtlasSprite sprite = Minecraft.getMinecraft().getTextureMapBlocks().getAtlasSprite(texture.toString());
		this.setParticleTexture(sprite);
	}
	
	public static ResourceLocation getTexture() {
		return texture;
	}
	
	@Override
	public void onUpdate() {
        this.prevPosX = this.posX;
        this.prevPosY = this.posY;
        this.prevPosZ = this.posZ;
        this.particleScale *= 0.9;
        
        if (this.particleAge++ >= this.particleMaxAge) {
            this.setExpired();
        }
        
        this.move(this.motionX, this.motionY, this.motionZ);
	}
	
	@Override
    public int getBrightnessForRender(float partialTicks) {
		return 15728800;
	}
	
	// Use the block+item texture sheet onto which we have stitched our sprite in event handler
	@Override
	public int getFXLayer() {
		return 1;
	}
}
```


Overlapping Code:
```
ly(Side.CLIENT)
public class ParticleFireflyTail extends Particle {
private static ResourceLocation texture = new ResourceLocation(Motherlode.MOD_ID, "entity/firefly");

public ParticleFireflyTail(World worldIn, double xCoordIn, double yCoordIn, double zCoordIn, double xSpeedIn,
double ySpeedIn, double zSpeedIn) {

super(worldIn, xCoordIn, yCoordIn, zCoordIn);
this.motionX = xSpeedIn + 0.01 * (this.rand.nextDouble() - 0.5);
this.motionY = ySpeedIn - 0.01 * this.rand.nextDouble();
this.motionZ = zSpeedIn + 0.01 * (this.rand.nextDouble() - 0.5);
this.particleScale = 0.25F;
this.particleMaxAge = 10;

TextureAtlasSprite sprite = Minecraft.getMinecraft().getTextureMapBlocks().getAtlasSprite(texture.toString());
this.setParticleTexture(sprite);
}

public static ResourceLocation getTexture() {
return texture;
}

@Override
public void onUpdate() {
this.prevPosX = this.posX;
this.prevPosY = this.posY;
this.prevPosZ = this.posZ;
this.particleScale *= 0.9;

if (this.particleAge++ >= this.particleMaxAge) {
this.setExpired();
}

this.move(this.motionX, this.motionY, this.motionZ);
}

@Override
public int getBrightnessForRender(float partialTicks) {
return 15728800;
}

// Use the block+item texture sheet onto which we have stitched our sprite in event handler
@Override
public int getFXLayer() {
return 1;
}
}
```
<Overlap Ratio: 0.9947049924357034>

---

--- 158 --
Question ID: b0efe8049b2c9de6ace5fa8ef9ad38714c83ddbf
Original Code:
```
@Component(immediate = true)
@Service
public class TeTunnelPceManager implements TeTunnelPceService {

    private static final Logger log = getLogger(TeTunnelPceManager.class);

    private List<TeTunnelPce> pces = Lists.newLinkedList();

    @Activate
    protected void activate() {
        pces.add(0, new DefaultTeTunnelPce());
        log.info("Started");
    }

    @Deactivate
    protected void deactivate() {
        log.info("Stopped");
    }

    @Override
    public Collection<List<TeRouteSubobject>> computePaths(TeTunnel teTunnel) {
        TeTunnelPce pce = null;
        synchronized (pces) {
            for (TeTunnelPce p : pces) {
                if (p.isSuitable(teTunnel)) {
                    pce = p;
                }
            }
        }
        if (pce != null) {
            return pce.computePaths(teTunnel);
        } else {
            return ImmutableList.of();
        }
    }

    @Override
    public Collection<List<TeRouteSubobject>> computePaths(TeTunnel teTunnel,
                                                           TeTunnelPce pce) {
        return pce == null ? null : pce.computePaths(teTunnel);
    }

    @Override
    public void registerPce(TeTunnelPce pce) {
        synchronized (pces) {
            int index = 0;
            while (pces.get(index).getPriority() > pce.getPriority()) {
                index++;
            }

            pces.add(index, pce);
        }
    }
}
```


Overlapping Code:
```
@Component(immediate = true)
@Service
public class TeTunnelPceManager implements TeTunnelPceService {
private static final Logger log = getLogger(TeTunnelPceManager.class);
private List<TeTunnelPce> pces = Lists.newLinkedList();
@Activate
protected void activate() {
pces.add(0, new DefaultTeTunnelPce());
log.info("Started");
}
@Deactivate
protected void deactivate() {
log.info("Stopped");
}
@Override
public Collection<List<TeRouteSubobject>> computePaths(TeTunnel teTunnel) {
TeTunnelPce pce = null;
synchronized (pces) {
for (TeTunnelPce p : pces) {
if (p.isSuitable(teTunnel)) {
pce = p;
}
}
}
if (pce != null) {
return pce.computePaths(teTunnel);
} else {
return ImmutableList.of();
}
}
@Override
public Collection<List<TeRouteSubobject>> computePaths(TeTunnel teTunnel,
TeTunnelPce pce) {
return pce == null ? null : pce.computePaths(teTunnel);
}
@Override
public void registerPce(TeTunnelPce pce) {
synchronized (pces) {
int index = 0;
while (pces.get(index).getPriority() > pce.getPriority()) {
index++;

```
<Overlap Ratio: 0.9721955896452541>

---

--- 159 --
Question ID: a38a856f22fdfa10638a66be1fb80061baeefb3a
Original Code:
```
@RunWith(SpringRunner.class)
@SpringBootTest
@ContextConfiguration(locations = "classpath*:/applicationTest.xml")
public class Test {

    @org.junit.Test
    public void testKeyCount() {
        try {
            BufferedReader bufferedReader = new BufferedReader(new FileReader("G:\\Intellij\\TPCDSkew\\lineitem.tbl"));
            String line = null;
            Map<String, Integer> map = new HashMap<>();
            while ((line = bufferedReader.readLine()) != null) {
                String[] splits = line.split("\\|");
                String key = splits[2];
                map.put(key, map.getOrDefault(key, 0) + 1);
            }
            int maxCount = Integer.MIN_VALUE;
            String maxCountKey = null;
            int minCount = Integer.MAX_VALUE;
            String minCountKey = null;
            for (Map.Entry<String, Integer> entry : map.entrySet()) {
                System.out.println(entry.getKey() + ": " + entry.getValue());
                if (entry.getValue() > maxCount) {
                    maxCount = entry.getValue();
                    maxCountKey = entry.getKey();
                }
                if (entry.getValue() < minCount) {
                    minCount = entry.getValue();
                    minCountKey = entry.getKey();
                }
            }
            System.out.println("=============================================");
            System.out.println(maxCountKey + ": " + maxCount);
            System.out.println(minCountKey + ": " + minCount);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @org.junit.Test
    public void generateFile() {
        int MAX = 8000000;
        Random random = new Random();
        try {
            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter("E:\\TPCH_DATA\\KeyWord.txt"));
            int i = 0;
            while (i < MAX) {
                StringBuilder stringBuilder = new StringBuilder();
                for (int j = 0; j < 20; j++) {
                    if (j != 19) {
                        stringBuilder.append("key" + "_" + random.nextInt(MAX) + " ");
                    } else {
                        stringBuilder.append("key" + "_" + random.nextInt(MAX));
                    }
                }
                bufferedWriter.write(stringBuilder.toString());
                bufferedWriter.newLine();
                i++;
                if (i % 1000 == 0) {
                    bufferedWriter.flush();
                }
            }
            bufferedWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```


Overlapping Code:
```
@RunWith(SpringRunner.class)
@SpringBootTest
@ContextConfiguration(locations = "classpath*:/applicationTest.xml")
public class Test {
@org.junit.Test
public void testKeyCount() {
try {
BufferedReader bufferedReader = new BufferedReader(new FileReader("G:\\Intellij\\TPCDSkew\\lineitem.tbl"));
String line = null;
Map<String, Integer> map = new HashMap<>();
while ((line = bufferedReader.readLine()) != null) {
String[] splits = line.split("\\|");
String key = splits[2];
map.put(key, map.getOrDefault(key, 0) + 1);
}
int maxCount = Integer.MIN_VALUE;
String maxCountKey = null;
int minCount = Integer.MAX_VALUE;
String minCountKey = null;
for (Map.Entry<String, Integer> entry : map.entrySet()) {
System.out.println(entry.getKey() + ": " + entry.getValue());
if (entry.getValue() > maxCount) {
maxCount = entry.getValue();
maxCountKey = entry.getKey();
}
if (entry.getValue() < minCount) {
minCount = entry.getValue();
minCountKey = entry.getKey();
}
}
System.out.println("=============================================");
System.out.println(maxCountKey + ": " + maxCount);
System.out.println(minCountKey + ": " + minCount);
} catch (IOException e) {
e.printStackTrace();
}
}
@org.junit.Test
public void generateFile() {
int MAX = 8000000;
Random random = new Random();
try {
BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter("E:\\TPCH_DATA\\KeyWord.txt"));
int i = 0;
while (i < MAX) {
StringBuilder stringBuilder = new StringBuilder();
for (int j = 0; j < 20; j++) {
if (j != 19) {
stringBuilder.append("key" + "_" + random.nextInt(MAX) + " ");
} else {
stringBuilder.append("key" + "_" + random.nextInt(MAX));
}
}
bufferedWriter.write(stringBuilder.toString());
bufferedWriter.newLine();
i++;
if (i % 1000 == 0) {
bufferedWriter.flu
```
<Overlap Ratio: 0.9971509971509972>

---

--- 160 --
Question ID: 4fa466c2fd8417ee84935d8509578afcf0599b9b
Original Code:
```
public class DefaultRetryManagerTest {
    /**
     * Used to mock the system clock.
     */
    private static final long FIXED_TIME = 100000L;
    private Clock mockClock;

    /**
     * Handles mocking Clock using Java 1.8's Clock interface.
     */
    @Before
    public void setup() {
        // Set our clock to be fixed.
        mockClock = Clock.fixed(Instant.ofEpochMilli(FIXED_TIME), ZoneId.of("UTC"));
    }

    /**
     * Tests that the open() set properties from the config.
     */
    @Test
    public void testOpen() {
        final int expectedMaxRetries = 44;
        final long expectedMinRetryTimeMs = 4455;
        final double expectedDelayMultiplier = 4.56;
        final long expectedMaxDelayMs = 1000;

        // Build config.
        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, expectedMaxDelayMs);

        // Create instance and call open.
        DefaultRetryManager retryManager = new DefaultRetryManager();
        retryManager.open(stormConfig);

        assertEquals("Wrong max retries", expectedMaxRetries, retryManager.getRetryLimit());
        assertEquals("Wrong retry time", expectedMinRetryTimeMs, retryManager.getInitialRetryDelayMs());
        assertEquals("Wrong retry time", expectedDelayMultiplier, retryManager.getRetryDelayMultiplier(), 0.001);
        assertEquals("Wrong retry time", expectedMaxDelayMs, retryManager.getRetryDelayMaxMs());
    }

    /**
     * Tests that the open() uses default values if not configured.
     */
    @Test
    public void testOpenWithNoConfigUsesDefaults() {
        // Build config.
        Map stormConfig = getDefaultConfig(null, null, null, null);

        // Create instance and call open.
        DefaultRetryManager retryManager = new DefaultRetryManager();
        retryManager.open(stormConfig);

        assertEquals("Wrong max retries", -1, retryManager.getRetryLimit());
        assertEquals("Wrong retry time", 2000, retryManager.getInitialRetryDelayMs());
        assertEquals("Wrong max delay", 15 * 60 * 1000, retryManager.getRetryDelayMaxMs());
        assertEquals("Wrong delay multiplier", 2.0, retryManager.getRetryDelayMultiplier(), 0.01);
    }

    /**
     * Tests tracking a new failed messageIds.
     */
    @Test
    public void testFailedSimpleCase() {
        // construct manager
        final int expectedMaxRetries = 10;
        final long expectedMinRetryTimeMs = 1000;

        // Use a wacky multiplier, because why not?
        final double expectedDelayMultiplier = 44.5;

        // Build config.
        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);

        // Create instance, inject our mock clock,  and call open.
        DefaultRetryManager retryManager = new DefaultRetryManager();
        retryManager.setClock(mockClock);
        retryManager.open(stormConfig);

        // Calculate the 1st retry times
        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);

        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier("MyConsumerId");

        // Define our tuple message id
        final MessageId messageId1 = new MessageId("MyTopic", 0, 101L, consumerId);
        final MessageId messageId2 = new MessageId("MyTopic", 0, 102L, consumerId);
        final MessageId messageId3 = new MessageId("MyTopic", 0, 103L, consumerId);

        // Mark first as having failed
        retryManager.failed(messageId1);

        // Validate it has failed
        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);

        // Mark second as having failed
        retryManager.failed(messageId2);

        // Validate it has first two as failed
        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);
        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);

        // Mark 3rd as having failed
        retryManager.failed(messageId3);

        // Validate it has all three as failed
        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);
        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);
        validateExpectedFailedMessageId(retryManager, messageId3, 1, firstRetryTime, false);
    }

    /**
     * Tests tracking a new failed messageId.
     */
    @Test
    public void testFailedMultipleFails() {
        // construct manager
        final int expectedMaxRetries = 10;
        final long expectedMinRetryTimeMs = 1000;

        // Use a wacky multiplier, because why not?
        final double expectedDelayMultiplier = 11.25;

        // Build config.
        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);

        // Create instance, inject our mock clock,  and call open.
        DefaultRetryManager retryManager = new DefaultRetryManager();
        retryManager.setClock(mockClock);
        retryManager.open(stormConfig);

        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier("MyConsumerId");

        // Define our tuple message id
        final MessageId messageId1 = new MessageId("MyTopic", 0, 101L, consumerId);
        final MessageId messageId2 = new MessageId("MyTopic", 0, 102L, consumerId);

        // Calculate the 1st, 2nd, and 3rd fail retry times
        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);
        final long secondRetryTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier);
        final long thirdRetryTime = FIXED_TIME + (long) (3 * expectedMinRetryTimeMs * expectedDelayMultiplier);

        // Mark first as having failed
        retryManager.failed(messageId1);

        // Validate it has failed
        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);

        // Mark second as having failed
        retryManager.failed(messageId2);

        // Validate it has first two as failed
        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);
        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);

        // Now fail messageId1 a second time.
        retryManager.failed(messageId1);

        // Validate it has first two as failed
        validateExpectedFailedMessageId(retryManager, messageId1, 2, secondRetryTime, false);
        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);

        // Now fail messageId1 a 3rd time.
        retryManager.failed(messageId1);

        // Validate it has first two as failed
        validateExpectedFailedMessageId(retryManager, messageId1, 3, thirdRetryTime, false);
        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);

        // Now fail messageId2 a 2nd time.
        retryManager.failed(messageId2);

        // Validate it has first two as failed
        validateExpectedFailedMessageId(retryManager, messageId1, 3, thirdRetryTime, false);
        validateExpectedFailedMessageId(retryManager, messageId2, 2, secondRetryTime, false);
    }

    /**
     * Tests what happens if a tuple fails more than our max fail limit.
     */
    @Test
    public void testRetryDelayWhenExceedsMaxTimeDelaySetting() {
        // construct manager
        final int expectedMaxRetries = 10;
        final long expectedMinRetryTimeMs = 1000;

        // Use a multiplier of 10
        final double expectedDelayMultiplier = 5;

        // Set a max delay of 12 seconds
        final long expectedMaxDelay = 12000;

        // Build config.
        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, expectedMaxDelay);

        // Create instance, inject our mock clock,  and call open.
        DefaultRetryManager retryManager = new DefaultRetryManager();
        retryManager.setClock(mockClock);
        retryManager.open(stormConfig);

        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier("MyConsumerId");

        // Define our tuple message id
        final MessageId messageId1 = new MessageId("MyTopic", 0, 101L, consumerId);

        // Calculate the 1st, 2nd, and 3rd fail retry times
        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);
        final long secondRetryTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier);
        final long thirdRetryTime = FIXED_TIME + expectedMaxDelay;

        // Mark first as having failed
        retryManager.failed(messageId1);

        // Validate it has failed
        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);

        // Now fail messageId1 a second time.
        retryManager.failed(messageId1);

        // Validate it incremented our delay time, still below configured max delay
        validateExpectedFailedMessageId(retryManager, messageId1, 2, secondRetryTime, false);

        // Now fail messageId1 a 3rd time.
        retryManager.failed(messageId1);

        // Validate its pinned at configured max delay
        validateExpectedFailedMessageId(retryManager, messageId1, 3, thirdRetryTime, false);

        // Now fail messageId1 a 4th time.
        retryManager.failed(messageId1);

        // Validate its still pinned at configured max delay
        validateExpectedFailedMessageId(retryManager, messageId1, 4, thirdRetryTime, false);
    }


    /**
     * Tests that all previously un-tracked messageIds should be retried.
     */
    @Test
    public void testRetryFurtherForUntrackedMessageId() {
        // construct manager
        final int expectedMaxRetries = 2;
        final long expectedMinRetryTimeMs = 1000;

        // Build config.
        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, null, null);

        // Create instance, inject our mock clock,  and call open.
        DefaultRetryManager retryManager = new DefaultRetryManager();
        retryManager.setClock(mockClock);
        retryManager.open(stormConfig);

        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier("MyConsumerId");

        // Define our tuple message id
        final MessageId messageId = new MessageId("MyTopic", 0, 100L, consumerId);

        assertTrue("Should always be true because its untracked", retryManager.retryFurther(messageId));
        assertTrue("Should always be true because its untracked", retryManager.retryFurther(messageId));
        assertTrue("Should always be true because its untracked", retryManager.retryFurther(messageId));
    }

    /**
     * Tests retryFurther always returns false if maxRetries is configured to 0.
     */
    @Test
    public void testRetryFurtherForUntrackedMessageIdWithMaxRetriesSetToZero() {
        // construct manager
        final int expectedMaxRetries = 0;
        final long expectedMinRetryTimeMs = 1000;

        // Build config.
        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, null, null);

        // Create instance, inject our mock clock,  and call open.
        DefaultRetryManager retryManager = new DefaultRetryManager();
        retryManager.setClock(mockClock);
        retryManager.open(stormConfig);

        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier("MyConsumerId");

        // Define our tuple message id
        final MessageId messageId = new MessageId("MyTopic", 0, 100L, consumerId);

        for (int x = 0; x < 100; x++) {
            assertFalse("Should always be false because we are configured to never retry", retryManager.retryFurther(messageId));
        }
    }

    /**
     * Tests retryFurther always returns true if maxRetries is configured to a value less than 0.
     */
    @Test
    public void testRetryFurtherWithMaxRetriesSetNegative() {
        // construct manager
        final int expectedMaxRetries = -1;
        final long expectedMinRetryTimeMs = 1000;

        // Build config.
        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, null, null);

        // Create instance, inject our mock clock,  and call open.
        DefaultRetryManager retryManager = new DefaultRetryManager();
        retryManager.setClock(mockClock);
        retryManager.open(stormConfig);

        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier("MyConsumerId");

        // Define our tuple message id
        final MessageId messageId = new MessageId("MyTopic", 0, 100L, consumerId);

        for (int x = 0;  x < 100; x++) {
            // Fail tuple
            retryManager.failed(messageId);

            // See if we should retry
            assertTrue("Should always be true because we are configured to always retry", retryManager.retryFurther(messageId));
        }
    }

    /**
     * Tests what happens if a tuple fails more than our max fail limit.
     */
    @Test
    public void testRetryFurtherWhenMessageExceedsRetryLimit() {
        // construct manager
        final int expectedMaxRetries = 3;
        final long expectedMinRetryTimeMs = 1000;

        // Use a wacky multiplier, because why not?
        final double expectedDelayMultiplier = 1.5;

        // Build config.
        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);

        // Create instance, inject our mock clock,  and call open.
        DefaultRetryManager retryManager = new DefaultRetryManager();
        retryManager.setClock(mockClock);
        retryManager.open(stormConfig);

        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier("MyConsumerId");

        // Define our tuple message id
        final MessageId messageId1 = new MessageId("MyTopic", 0, 101L, consumerId);
        final MessageId messageId2 = new MessageId("MyTopic", 0, 102L, consumerId);

        // Calculate the 1st, 2nd, and 3rd fail retry times
        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);
        final long secondRetryTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier);
        final long thirdRetryTime = FIXED_TIME + (long) (3 * expectedMinRetryTimeMs * expectedDelayMultiplier);

        // Mark first as having failed
        retryManager.failed(messageId1);

        // Validate it has failed
        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);

        // Mark second as having failed
        retryManager.failed(messageId2);

        // Validate it has first two as failed
        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);
        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);

        // Validate that we can retry both of these
        assertTrue("Should be able to retry", retryManager.retryFurther(messageId1));
        assertTrue("Should be able to retry", retryManager.retryFurther(messageId2));

        // Fail messageId1 a 2nd time
        retryManager.failed(messageId1);

        // Validate it has first two as failed
        validateExpectedFailedMessageId(retryManager, messageId1, 2, secondRetryTime, false);
        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);

        // Validate that we can retry both of these
        assertTrue("Should be able to retry", retryManager.retryFurther(messageId1));
        assertTrue("Should be able to retry", retryManager.retryFurther(messageId2));

        // Fail messageId1 a 3rd time
        retryManager.failed(messageId1);

        // Validate it has first two as failed
        validateExpectedFailedMessageId(retryManager, messageId1, 3, thirdRetryTime, false);
        validateExpectedFailedMessageId(retryManager, messageId2, 1, firstRetryTime, false);

        // Validate that messageId1 cannot be retried, messageId2 can.
        assertFalse("Should NOT be able to retry", retryManager.retryFurther(messageId1));
        assertTrue("Should be able to retry", retryManager.retryFurther(messageId2));
    }

    /**
     * Tests calling nextFailedMessageToRetry() when nothing should have been expired.
     */
    @Test
    public void testNextFailedMessageToRetryWithNothingExpired() {
        // construct manager
        final int expectedMaxRetries = 3;
        final long expectedMinRetryTimeMs = 1000;

        // Use a wacky multiplier, because why not?
        final double expectedDelayMultiplier = 4.2;

        // Build config.
        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);

        // Create instance, inject our mock clock,  and call open.
        DefaultRetryManager retryManager = new DefaultRetryManager();
        retryManager.setClock(mockClock);
        retryManager.open(stormConfig);

        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier("MyConsumerId");

        // Define our tuple message id
        final MessageId messageId1 = new MessageId("MyTopic", 0, 101L, consumerId);
        final MessageId messageId2 = new MessageId("MyTopic", 0, 102L, consumerId);

        // Mark both as having been failed.
        retryManager.failed(messageId1);
        retryManager.failed(messageId2);

        // Validate it has first two as failed
        validateExpectedFailedMessageId(
            retryManager,
            messageId1,
            1,
            (FIXED_TIME + (long) (expectedMinRetryTimeMs * expectedDelayMultiplier)),
            false
        );
        validateExpectedFailedMessageId(
            retryManager,
            messageId2,
            1,
            (FIXED_TIME + (long) (expectedMinRetryTimeMs * expectedDelayMultiplier)),
            false
        );

        // Ask for the next tuple to retry, should be empty
        assertNull("Should be null", retryManager.nextFailedMessageToRetry());
        assertNull("Should be null", retryManager.nextFailedMessageToRetry());
        assertNull("Should be null", retryManager.nextFailedMessageToRetry());
        assertNull("Should be null", retryManager.nextFailedMessageToRetry());
    }

    /**
     * Tests calling nextFailedMessageToRetry() when nothing should have been expired.
     */
    @Test
    public void testNextFailedMessageToRetryWithExpiring() {
        // construct manager
        final int expectedMaxRetries = 3;
        final long expectedMinRetryTimeMs = 1000;

        // Use a wacky multiplier, because why not?
        final double expectedDelayMultiplier = 6.2;

        // Build config.
        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);

        // Create instance, inject our mock clock,  and call open.
        DefaultRetryManager retryManager = new DefaultRetryManager();
        retryManager.setClock(mockClock);
        retryManager.open(stormConfig);

        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier("MyConsumerId");

        // Define our tuple message id
        final MessageId messageId1 = new MessageId("MyTopic", 0, 101L, consumerId);
        final MessageId messageId2 = new MessageId("MyTopic", 0, 102L, consumerId);

        // Mark messageId1 as having failed
        retryManager.failed(messageId1);

        // Mark messageId2 as having failed twice
        retryManager.failed(messageId2);
        retryManager.failed(messageId2);

        // Calculate the first and 2nd fail retry times
        final long firstRetryTime = FIXED_TIME + (long) (1 * expectedMinRetryTimeMs * expectedDelayMultiplier);
        final long secondRetryTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier);

        // Validate it has first two as failed
        validateExpectedFailedMessageId(retryManager, messageId1, 1, firstRetryTime, false);
        validateExpectedFailedMessageId(retryManager, messageId2, 2, secondRetryTime, false);

        // Ask for the next tuple to retry, should be empty
        assertNull("Should be null", retryManager.nextFailedMessageToRetry());
        assertNull("Should be null", retryManager.nextFailedMessageToRetry());
        assertNull("Should be null", retryManager.nextFailedMessageToRetry());
        assertNull("Should be null", retryManager.nextFailedMessageToRetry());

        // Now advance time by exactly expectedMinRetryTimeMs milliseconds
        retryManager.setClock(
            Clock.fixed(Instant.ofEpochMilli(FIXED_TIME + (long) (expectedMinRetryTimeMs * expectedDelayMultiplier)), ZoneId.of("UTC"))
        );

        // Now messageId1 should expire next,
        MessageId nextMessageIdToBeRetried = retryManager.nextFailedMessageToRetry();
        assertNotNull("result should not be null", nextMessageIdToBeRetried);
        assertEquals("Should be our messageId1", messageId1, nextMessageIdToBeRetried);

        // Validate the internal state.
        validateTupleNotInFailedSetButIsInFlight(retryManager, messageId1);
        validateExpectedFailedMessageId(retryManager, messageId2, 2, secondRetryTime, false);

        // Calling nextFailedMessageToRetry should result in null.
        assertNull("Should be null", retryManager.nextFailedMessageToRetry());
        assertNull("Should be null", retryManager.nextFailedMessageToRetry());
        assertNull("Should be null", retryManager.nextFailedMessageToRetry());
        assertNull("Should be null", retryManager.nextFailedMessageToRetry());

        // Advance time again, by 2x expected retry time, plus a few MS
        final long newFixedTime = FIXED_TIME + (long) (2 * expectedMinRetryTimeMs * expectedDelayMultiplier) + 10;
        retryManager.setClock(Clock.fixed(Instant.ofEpochMilli(newFixedTime), ZoneId.of("UTC")));

        // Now messageId1 should expire next,
        nextMessageIdToBeRetried = retryManager.nextFailedMessageToRetry();
        assertNotNull("result should not be null", nextMessageIdToBeRetried);

        // Validate state.
        validateTupleNotInFailedSetButIsInFlight(retryManager, messageId1);
        validateTupleNotInFailedSetButIsInFlight(retryManager, messageId2);

        // call ack, validate its no longer tracked
        retryManager.acked(messageId1);
        validateTupleIsNotBeingTracked(retryManager, messageId1);
        validateTupleNotInFailedSetButIsInFlight(retryManager, messageId2);

        // Calculate time for 3rd fail, against new fixed time
        final long thirdRetryTime = newFixedTime + (long) (3 * expectedMinRetryTimeMs * expectedDelayMultiplier);

        // Mark tuple2 as having failed
        retryManager.failed(messageId2);
        validateTupleIsNotBeingTracked(retryManager, messageId1);
        validateExpectedFailedMessageId(retryManager, messageId2, 3, thirdRetryTime, false);
    }

    /**
     * Validates that when we have multiple failed tuples that need to be retried,
     * we retry the earliest ones first.
     */
    @Test
    public void testRetryEarliestFailed() {
        // construct manager
        final int expectedMaxRetries = 3;
        final long expectedMinRetryTimeMs = 0;
        final double expectedDelayMultiplier = 0.5;

        // Build config.
        Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, null);

        // Create instance, inject our mock clock,  and call open.
        DefaultRetryManager retryManager = new DefaultRetryManager();
        retryManager.setClock(mockClock);
        retryManager.open(stormConfig);

        final DefaultVirtualSpoutIdentifier consumerId = new DefaultVirtualSpoutIdentifier("MyConsumerId");

        // Define our tuple message id
        final MessageId messageId1 = new MessageId("MyTopic", 0, 101L, consumerId);
        final MessageId messageId2 = new MessageId("MyTopic", 0, 102L, consumerId);
        final MessageId messageId3 = new MessageId("MyTopic", 0, 103L, consumerId);

        // Fail messageId 1 @ T0
        retryManager.failed(messageId1);

        // Increment clock to T1 and fail messageId 2
        retryManager.setClock(Clock.fixed(Instant.ofEpochMilli(FIXED_TIME + 100), ZoneId.of("UTC")));
        retryManager.failed(messageId2);

        // Increment clock to T2 and fail messageId 3
        retryManager.setClock(Clock.fixed(Instant.ofEpochMilli(FIXED_TIME + 200), ZoneId.of("UTC")));
        retryManager.failed(messageId3);

        // call 3 times, see what comes out.
        // We'd expect to get messageId1 since its the oldest, followed by messageId2, and then messageId3
        final MessageId result1 = retryManager.nextFailedMessageToRetry();
        final MessageId result2 = retryManager.nextFailedMessageToRetry();
        final MessageId result3 = retryManager.nextFailedMessageToRetry();

        assertEquals("Result1 should be messageId1", messageId1, result1);
        assertEquals("Result2 should be messageId1", messageId2, result2);
        assertEquals("Result3 should be messageId1", messageId3, result3);
    }

    private void validateExpectedFailedMessageId(
        DefaultRetryManager retryManager,
        MessageId messageId,
        int expectedFailCount,
        long expectedRetryTime,
        boolean expectedToBeInFlight
    ) {
        // Find its queue
        Queue<MessageId> failQueue = retryManager.getFailedMessageIds().get(expectedRetryTime);
        assertNotNull(
            "Queue should exist for our retry time of " + expectedRetryTime + " has [" + retryManager.getFailedMessageIds().keySet() + "]",
            failQueue
        );
        assertTrue("Queue should contain our tuple messageId", failQueue.contains(messageId));

        // This messageId should have the right number of fails associated with it.
        assertEquals(
            "Should have expected number of fails",
            (Integer) expectedFailCount, retryManager.getNumberOfTimesFailed().get(messageId)
        );

        // Should this be marked as in flight?
        assertEquals("Should or should not be in flight", expectedToBeInFlight, retryManager.getRetriesInFlight().contains(messageId));
    }

    private void validateTupleNotInFailedSetButIsInFlight(DefaultRetryManager retryManager, MessageId messageId) {
        // Loop through all failed tuples
        for (Long key : retryManager.getFailedMessageIds().keySet()) {
            Queue queue = retryManager.getFailedMessageIds().get(key);
            assertFalse("Should not contain our messageId", queue.contains(messageId));
        }
        assertTrue("Should be tracked as in flight", retryManager.getRetriesInFlight().contains(messageId));
    }

    private void validateTupleIsNotBeingTracked(DefaultRetryManager retryManager, MessageId messageId) {
        // Loop through all failed tuples
        for (Long key : retryManager.getFailedMessageIds().keySet()) {
            Queue queue = retryManager.getFailedMessageIds().get(key);
            assertFalse("Should not contain our messageId", queue.contains(messageId));
        }
        assertFalse("Should not be tracked as in flight", retryManager.getRetriesInFlight().contains(messageId));
        assertFalse("Should not have a fail count", retryManager.getNumberOfTimesFailed().containsKey(messageId));
    }

    // Helper method
    private Map getDefaultConfig(Integer maxRetries, Long minRetryTimeMs, Double delayMultiplier, Long expectedMaxDelayMs) {
        Map stormConfig = Maps.newHashMap();
        if (maxRetries != null) {
            stormConfig.put(SpoutConfig.RETRY_MANAGER_RETRY_LIMIT, maxRetries);
        }
        if (minRetryTimeMs != null) {
            stormConfig.put(SpoutConfig.RETRY_MANAGER_INITIAL_DELAY_MS, minRetryTimeMs);
        }
        if (delayMultiplier != null) {
            stormConfig.put(SpoutConfig.RETRY_MANAGER_DELAY_MULTIPLIER, delayMultiplier);
        }
        if (expectedMaxDelayMs != null) {
            stormConfig.put(SpoutConfig.RETRY_MANAGER_MAX_DELAY_MS, expectedMaxDelayMs);
        }
        return stormConfig;
    }
}
```


Overlapping Code:
```
d to mock the system clock.
*/
private static final long FIXED_TIME = 100000L;
private Clock mockClock;
/**
* Handles mocking Clock using Java 1.8's Clock interface.
*/
@Before
public void setup() {
// Set our clock to be fixed.
mockClock = Clock.fixed(Instant.ofEpochMilli(FIXED_TIME), ZoneId.of("UTC"));
}
/**
* Tests that the open() set properties from the config.
*/
@Test
public void testOpen() {
final int expectedMaxRetries = 44;
final long expectedMinRetryTimeMs = 4455;
final double expectedDelayMultiplier = 4.56;
final long expectedMaxDelayMs = 1000;
// Build config.
Map stormConfig = getDefaultConfig(expectedMaxRetries, expectedMinRetryTimeMs, expectedDelayMultiplier, expectedMaxDelayMs);
// Create instance and call open.
DefaultRetryManager retryManager = new DefaultRetryManager();
retryManager.open(stormConfig);
assertEquals("Wrong max retries", expectedMaxRetries, retryManager.getRetryLimit());
assertEquals("Wrong retry time", expectedMinRetryTimeMs, retryManager.getInitialRetryDelayMs());
assertEquals("Wrong retry time", expectedDelayMultiplier, retryManager.getRetryDelayMultiplier(), 0.001);
assertEquals("Wrong retry time", expectedMaxDelayMs, retryManager.getRetryDelayMaxMs());
}
/**
* Tests that the open() uses default values if not configured.
*/
@Test
public void testOpenWithNoConfigUsesDefaults() {
// Build config.
Map stormConfig = getDefaultConfig(null, null, null, null);
// Create instance and call open.
DefaultRetryManager retryManager = new DefaultRetryManager();
retryManager.open(stormConfig);
assertEquals("Wrong max retries", -1, retryManager.getRetryLimit());
assertEquals("Wrong retry time", 2000, retryManager.getInitialRetryDelayMs());
assertEquals("Wrong max delay", 15 * 60 * 1000, retryManager.getRetryDelayMaxMs());
assertEquals("Wrong delay multiplier", 2.0, retryManager.getRetryDelayMultiplier(), 0.01);
}
/**
* Tests tracking a new failed messageIds.
*/
@Test
public void testFailedSimpleCase() {
// construct manager
final int expectedMaxRetries = 10;
final long expectedMinRetryTimeMs = 1000;
// Use a wacky multiplier, because why
```
<Overlap Ratio: 0.9775910364145658>

---

--- 161 --
Question ID: 2b422de92cf599fed5d455c1995f27b404ce322e
Original Code:
```
public class Global extends GlobalSettings {

	 @Override
	  public void onStart(Application app) {
	    System.out.println("Application has started");
	    // OAuth
	    final Google2Client googleClient = new Google2Client (
	    		"134678913668-m92g9igaokp1jjknom4kbq5dnub66uhm.apps.googleusercontent.com", 
	    		"Ql5NPhYeLf5RuwC1w8FNjCYR");
	    
	    final FacebookClient facebookClient = new FacebookClient("132736803558924", "e461422527aeedb32ee6c10834d3e19e");
	    
	    final Clients clients = new Clients("http://localhost:9000/callback", googleClient, facebookClient);
	    Config.setClients(clients);
	  }  
	  
	  @Override
	  public void onStop(Application app) {
		  System.out.println("Application shutdown...");
	  }  
}
```


Overlapping Code:
```
public class Global extends GlobalSettings {
@Override
public void onStart(Application app) {
System.out.println("Application has started");
// OAuth
final Google2Client googleClient = new Google2Client (
"134678913668-m92g9igaokp1jjknom4kbq5dnub66uhm.app
final FacebookClient facebookClient = new FacebookClient("132736803558924"

final Clients clients = new Clients("http://localhost:9000/callback", googleClient, facebookClient);
Config.setClients(clients);
} 

@Override
public void onStop(Application app) {
System.out.println("Application shutdow
```
<Overlap Ratio: 0.8389057750759878>

---

--- 162 --
Question ID: c54d436109ff0ccb4ff9484823430a5fa07758c7
Original Code:
```
@Configuration
public class EnaAgentConfiguration {

    static String SUBMITTABLE_PACKAGE = "uk.ac.ebi.subs.data.submittable";
    static String COMPONENT_PACKAGE = "uk.ac.ebi.subs.data.component";

    @Autowired
    private ApplicationContext appContext;

    @Value("classpath:uk/ac/ebi/subs/data/component/attribute_mapping.xml")
    Resource componentMappingResource;

    @Value("classpath:uk/ac/ebi/subs/data/submittable/study_mapping.xml")
    Resource studyMappingResource;

    @Value("classpath:uk/ac/ebi/subs/data/submittable/experiment_mapping.xml")
    Resource experimentMappingResource;

    @Value("classpath:uk/ac/ebi/subs/data/submittable/run_mapping.xml")
    Resource runMappingResource;

    @Value("classpath:uk/ac/ebi/subs/data/submittable/sample_mapping.xml")
    Resource sampleMappingResource;

    @Value("classpath:uk/ac/ebi/subs/data/submittable/seq_var_analysis_mapping.xml")
    Resource seqVarAnalysisMappingResource;

    @Bean(name = "study")
    Jaxb2Marshaller jaxb2StudyMarshaller() throws IOException {
        Class enaStudyClass = ENAStudy.class;
        return getJaxb2Marshaller(studyMappingResource, enaStudyClass);
    }

    @Bean(name = "sample")
    Jaxb2Marshaller jaxb2SampleMarshaller() throws IOException {
        Class enaSampleClass = ENASample.class;
        return getJaxb2Marshaller(sampleMappingResource, enaSampleClass);
    }

    @Bean(name = "experiment")
    Jaxb2Marshaller jaxb2ExperimentMarshaller() throws IOException {
        Class enaExperimentClass = ENAExperiment.class;
        return getJaxb2Marshaller(experimentMappingResource, enaExperimentClass);
    }

    @Bean(name = "run")
    Jaxb2Marshaller jaxb2RunMarshaller() throws IOException {
        Class enaRunClass = ENARun.class;
        return getJaxb2Marshaller(runMappingResource, enaRunClass);
    }

    @Bean(name = "analysis")
    Jaxb2Marshaller jaxb2SequenceVariationAnalysisMarshaller() throws IOException {
        Class enaSequenceVariationAnalysisClass = ENASequenceVariationAnalysis.class;
        return getJaxb2Marshaller(seqVarAnalysisMappingResource, enaSequenceVariationAnalysisClass);
    }

    private Jaxb2Marshaller getJaxb2Marshaller(Resource resource, Class enaStudyClass) throws IOException {
        Jaxb2Marshaller jaxb2Marshaller = new Jaxb2Marshaller();
        final HashMap<String, Object> jaxpHashMap = new HashMap<>();
        jaxpHashMap.put(COMPONENT_PACKAGE, new StreamSource(componentMappingResource.getInputStream()));
        jaxpHashMap.put(SUBMITTABLE_PACKAGE, new StreamSource(resource.getInputStream()));
        Map<String, Object> properties = new HashMap<String, Object>();
        properties.put(JAXBContextProperties.OXM_METADATA_SOURCE, jaxpHashMap);
        jaxb2Marshaller.setJaxbContextProperties(properties);
        jaxb2Marshaller.setClassesToBeBound(enaStudyClass);
        return jaxb2Marshaller;
    }

}
```


Overlapping Code:
```
ss EnaAgentConfiguration {
static String SUBMITTABLE_PACKAGE = "uk.ac.ebi.subs.data.submittable";
static String COMPONENT_PACKAGE = "uk.ac.ebi.subs.data.component";
@Autowired
private ApplicationContext appContext;
@Value("classpath:uk/ac/ebi/subs/data/component/attribute_mapping.xml")
Resource componentMappingResource;
@Value("classpath:uk/ac/ebi/subs/data/submittable/study_mapping.xml")
Resource studyMappingResource;
@Value("classpath:uk/ac/ebi/subs/data/submittable/experiment_mapping.xml")
Resource experimentMappingResource;
@Value("classpath:uk/ac/ebi/subs/data/submittable/run_mapping.xml")
Resource runMappingResource;
@Value("classpath:uk/ac/ebi/subs/data/submittable/sample_mapping.xml")
Resource sampleMappingResource;
@Value("classpath:uk/ac/ebi/subs/data/submittable/seq_var_analysis_mapping.xml")
Resource seqVarAnalysisMappingResource;
@Bean(name = "study")
Jaxb2Marshaller jaxb2StudyMarshaller() throws IOException {
Class enaStudyClass = ENAStudy.class;
return getJaxb2Marshaller(studyMappingResource, enaStudyClass);
}
@Bean(name = "sample")
Jaxb2Marshaller jaxb2SampleMarshaller() throws IOException {
Class enaSampleClass = ENASample.class;
return getJaxb2Marshaller(sampleMappingResource, enaSampleClass);
}
@Bean(name = "experiment")
Jaxb2Marshaller jaxb2ExperimentMarshaller() throws IOException {
Class enaExperimentClass = ENAExperiment.class;
return getJaxb2Marshaller(experimentMappingResource, enaExperimentClass);
}
@Bean(name = "run")
Jaxb2Marshaller jaxb2RunMarshaller() throws IOException {
Class enaRunClass = ENARun.class;
return getJaxb2Marshaller(runMappingResource, enaRunClass);
}
@Bean(name = "analysis")
Jaxb2Marshaller jaxb2SequenceVariationAnalysisMarshaller() throws IOException {
Class enaSequenceVariationAnalysisClass = ENASequenceVariationAnalysis.class;
return getJaxb2Marshaller(seqVarAnalysisMappingResource, enaSequenceVariationAnalysisClass);
}
private Jaxb2Marshaller getJaxb2Marshaller(Resource resource, Class enaStudyClass) throws IOException {
Jaxb2Marshaller jaxb2Marshaller = new Jaxb2Marshaller();
final HashMap<String, Object> jaxpHashMap = new HashMap<>();
jaxpHashMap.put(COMPONENT_PACKAGE, new StreamSource(componentMappingResource.
```
<Overlap Ratio: 0.9803921568627451>

---

--- 163 --
Question ID: 8a0928ed87f81b4dc9e855ed048771059cbe1556
Original Code:
```
public class ComentarioDetailDTO extends ComentarioDTO{
    
    private ClienteDTO cliente; 
    
    private SucursalDTO sucursal;
    
    private List<FotoDTO> fotos;
    
    /**
     * Constructor vacío, heredado para inicialización de JaxRS
     */
    
    public ComentarioDetailDTO(){     
        super();
    }
       
    /**
     * Crea un objeto ComentarioDetailDTO a partir de un objeto ComentarioEntity
     * incluyendo los atributos de ComentarioDTO.
     *
     * @param entity Entidad ComentarioEntity desde la cual se va a crear el nuevo
     * objeto.
     *
     */
    public ComentarioDetailDTO(ComentarioEntity entity) {
        super(entity);
        
        if (entity != null) {
            
            cliente = new ClienteDTO(entity.getCliente());
            
            sucursal = new SucursalDTO(entity.getSucursal());
            
            fotos = new ArrayList<>();
            for (FotoEntity entityFoto : entity.getFotos()) {
                fotos.add(new FotoDTO(entityFoto));
            }
        }
    }
    
     /**
     * Convierte un objeto ComentarioDetailDTO a ComentarioEntity incluyendo los
     * atributos de ComentarioDTO.
     *
     * @return Nueva objeto ComentarioEntity.
     *
     */
    @Override
    public ComentarioEntity toEntity() {
        ComentarioEntity entity = super.toEntity();
        
        if (getCliente() != null) {            
            entity.setCliente(getCliente().toEntity());
        }
        
        if (getSucursal() != null) {            
            entity.setSucursal(getSucursal().toEntity());
        }
        
        if (getFotos() != null) {
            List<FotoEntity> fotosEntity = new ArrayList<>();
            for (FotoDTO dtoFoto : getFotos()) {
                fotosEntity.add(dtoFoto.toEntity());
            }
            entity.setFotos(fotosEntity);
        }
        
        return entity;
    }

    /**
     * @return the cliente
     */
    public ClienteDTO getCliente() {
        return cliente;
    }

    /**
     * @param cliente the cliente to set
     */
    public void setCliente(ClienteDTO cliente) {
        this.cliente = cliente;
    }

    /**
     * @return the sucursal
     */
    public SucursalDTO getSucursal() {
        return sucursal;
    }

    /**
     * @param sucursal the sucursal to set
     */
    public void setSucursal(SucursalDTO sucursal) {
        this.sucursal = sucursal;
    }

    /**
     * @return the fotos
     */
    public List<FotoDTO> getFotos() {
        return fotos;
    }

    /**
     * @param fotos the fotos to set
     */
    public void setFotos(List<FotoDTO> fotos) {
        this.fotos = fotos;
    }
    
    
}
```


Overlapping Code:
```
blic class ComentarioDetailDTO extends ComentarioDTO{

private ClienteDTO cliente; 

private SucursalDTO sucursal;

private List<FotoDTO> fotos;

/**
* Constructor vacío, heredado para inicialización de JaxRS
*/

public ComentarioDetailDTO(){ 
super();
}

/**
* Crea un objeto ComentarioDetailDTO a partir de un objeto ComentarioEntity
* incluyendo los atributos de ComentarioDTO.
*
* @param entity Entidad ComentarioEntity desde la cual se va a crear el nuevo
* objeto.
*
*/
public ComentarioDetailDTO(ComentarioEntity entity) {
super(entity);

if (entity != null) {

cliente = new ClienteDTO(entity.getCliente());

sucursal = new SucursalDTO(entity.getSucursal());

fotos = new ArrayList<>();
for (FotoEntity entityFoto : entity.getFotos()) {
fotos.add(new FotoDTO(entityFoto));
}
}
}

/**
* Convierte un objeto ComentarioDetailDTO a ComentarioEntity incluyendo los
* atributos de ComentarioDTO.
*
* @return Nueva objeto ComentarioEntity.
*
*/
@Override
public ComentarioEntity toEntity() {
ComentarioEntity entity = super.toEntity();

if (getCliente() != null) { 
entity.setCliente(getCliente().toEntity());
}

if (getSucursal() != null) { 
entity.setSucursal(getSucursal().toEntity());
}

if (getFotos() != null) {
List<FotoEntity> fotosEntity = new ArrayList<>();
for (FotoDTO dtoFoto : getFotos()) {
fotosEntity.add(dtoFoto.toEntity());
}
entity.setFotos(fotosEntity);
}

return entity;
}
/**
* @return the cliente
*/
public ClienteDTO getCliente() {
return cliente;
}
/**
* @param cliente the cliente to set
*/
public void setCliente(ClienteDTO cliente) {
this.cliente = cliente;
}
/**
* @return the sucursal
*/
public SucursalDTO getSucursal() {
return sucursal;
}
/**
* @param sucursal the sucursal to set
*/
public void setSucursal(SucursalDTO sucursal) {
this.sucursal = sucursal;
}
/**
* @return t
```
<Overlap Ratio: 0.9858310626702997>

---

--- 164 --
Question ID: f485edc9c37cda7badcb95c113e7db59bfa489a6
Original Code:
```
public class UsingPanel extends Applet{
	MyPanel p1,p2,p3,p4;
	@Override
	public void init() {
		setSize(500,500);
		p1=new MyPanel();
		p1.setLayout(new GridLayout(1, 4));
		
		p2=new MyPanel();
		p2.setLayout(new GridLayout(4, 1));
		
		p3=new MyPanel();
		p3.setLayout(new GridLayout(4, 1));
		
		p4=new MyPanel();
		p4.setLayout(new GridLayout(1, 4));
		
		setLayout(new BorderLayout());
		add(BorderLayout.NORTH,p1);
		add(BorderLayout.EAST,p2);
		add(BorderLayout.WEST,p3);
		add(BorderLayout.SOUTH,p4);
	}
}
```


Overlapping Code:
```
ingPanel extends Applet{
MyPanel p1,p2,p3,p4;
@Override
public void init() {
setSize(500,500);
p1=new MyPanel();
p1.setLayout(new GridLayout(1, 4));

p2=new MyPanel();
p2.setLayout(new GridLayout(4, 1));

p3=new MyPanel();
p3.setLayout(new GridLayout(4, 1));

p4=new MyPanel();
p4.setLayout(new GridLayout(1, 4));

setLayout(new BorderLayout());
add(BorderLayout.NORTH,p1);
add(BorderLayout.EAST,p2);
add(BorderLayout.WEST,p3);
add(BorderLayout.SOUTH,p4);
}
}
```
<Overlap Ratio: 0.9683544303797469>

---

--- 165 --
Question ID: ca033ea684f884699068a8548cc52f08bd2e8ff2
Original Code:
```
public class TestAbstractDeserializer extends AbstractDeserializer {

  private AbstractDeserializer abstractDeserializer = null;

  private JsonParser jsonParser = Mockito.mock(JsonParser.class);

  static ReaderHelpData readerHelpData = Mockito.mock(ReaderHelpData.class);

  static Map<String, ReaderHelpData> readerHelpDataMap = new HashMap<>();

  public static void setReaderHelpDataMap(Map<String, ReaderHelpData> readerHelpDataMap) {
    TestAbstractDeserializer.readerHelpDataMap = readerHelpDataMap;
    readerHelpDataMap.put("abc", readerHelpData);
    readerHelpDataMap.put("null", readerHelpData);
  }

  static {
    TestAbstractDeserializer.setReaderHelpDataMap(readerHelpDataMap);
  }

  public TestAbstractDeserializer() {
    super(readerHelpDataMap);
  }

  @Before
  public void setUp() throws Exception {
    abstractDeserializer = new TestAbstractDeserializer();
  }

  @After
  public void tearDown() throws Exception {
    abstractDeserializer = null;
    jsonParser = null;
  }

  @SuppressWarnings("unchecked")
  @Test
  public void testDeserialize() {
    boolean status = false;
    try {
      DeserializationContext ctxt = Mockito.mock(DeserializationContext.class);
      @SuppressWarnings("rawtypes")
      JsonDeserializer JsonDeserializer = Mockito.mock(JsonDeserializer.class);
      Object object = null;
      Mockito.when(jsonParser.nextFieldName()).thenReturn("abc", (String) null);
      Mockito.when(readerHelpData.getDeser()).thenReturn(JsonDeserializer);
      Mockito.when(JsonDeserializer.deserialize(jsonParser, ctxt)).thenReturn(object);
      Object deserializeObject = abstractDeserializer.deserialize(jsonParser, ctxt);
      Assert.assertNotNull(deserializeObject);
    } catch (Exception e) {
      status = true;
    }
    Assert.assertFalse(status);
  }

  @Override
  protected Object createResult() {
    return null;
  }

  @Override
  protected Object updateResult(Object result, Object value, ReaderHelpData helpData) {
    /* Do not worry, overridden method*/
    try {
      Mockito.when(jsonParser.nextToken()).thenReturn(JsonToken.VALUE_NULL);
    } catch (Exception e) {
    }
    return new Object();
  }
}
```


Overlapping Code:
```
tDeserializer extends AbstractDeserializer {
private AbstractDeserializer abstractDeserializer = null;
private JsonParser jsonParser = Mockito.mock(JsonParser.class);
static ReaderHelpData readerHelpData = Mockito.mock(ReaderHelpData.class);
static Map<String, ReaderHelpData> readerHelpDataMap = new HashMap<>();
public static void setReaderHelpDataMap(Map<String, ReaderHelpData> readerHelpDataMap) {
TestAbstractDeserializer.readerHelpDataMap = readerHelpDataMap;
readerHelpDataMap.put("abc", readerHelpData);
readerHelpDataMap.put("null", readerHelpData);
}
static {
TestAbstractDeserializer.setReaderHelpDataMap(readerHelpDataMap);
}
public TestAbstractDeserializer() {
super(readerHelpDataMap);
}
@Before
public void setUp() throws Exception {
abstractDeserializer = new TestAbstractDeserializer();
}
@After
public void tearDown() throws Exception {
abstractDeserializer = null;
jsonParser = null;
}
@SuppressWarnings("unchecked")
@Test
public void testDeserialize() {
boolean status = false;
try {
DeserializationContext ctxt = Mockito.mock(DeserializationContext.class);
@SuppressWarnings("rawtypes")
JsonDeserializer JsonDeserializer = Mockito.mock(JsonDeserializer.class);
Object object = null;
Mockito.when(jsonParser.nextFieldName()).thenReturn("abc", (String) null);
Mockito.when(readerHelpData.getDeser()).thenReturn(JsonDeserializer);
Mockito.when(JsonDeserializer.deserialize(jsonParser, ctxt)).thenReturn(object);
Object deserializeObject = abstractDeserializer.deserialize(jsonParser, ctxt);
Assert.assertNotNull(deserializeObject);
} catch (Exception e) {
status = true;
}
Assert.assertFalse(status);
}
@Override
protected Object createResult() {
return null;
}
@Override
protected Object updateResult(Object result, Object value, ReaderHelpData helpData) {
/* Do not worry, overridden method*/
try {
Mockito.when(jsonParser.nextToken()).thenReturn(JsonToken.VALUE_NULL);
} catch (Exception e) {
}
retur
```
<Overlap Ratio: 0.978117048346056>

---

--- 166 --
Question ID: c5b885aad96e3244e1712cb768cb78d6e20c3d2c
Original Code:
```
@SuppressWarnings("serial")
public class AmountDAO
	extends SetNameDescriptionDAO
	implements RenderableValue<String>
{

	/**
	 * Default currency set to U.S. dollar (USD).
	 */
	public static final Currency DEFAULT_CURRENCY = Currency.USD;
	
	public enum Params
		implements GetNVConfig
	{
		CURRENCY(NVConfigManager.createNVConfig("currency", "Currency", "Currency", true, true, Currency.class)),
		AMOUNT(NVConfigManager.createNVConfig("amount", "Amount", "Amount", true, true, BigDecimal.class)),
		
		;
		
		private final NVConfig cType;
		
		Params(NVConfig c)
		{
			cType = c;
		}
		
		@Override
		public NVConfig getNVConfig()
		{
			return cType;
		}

	}
	
	public static final NVConfigEntity NVC_AMOUNT_DAO = new NVConfigEntityLocal(
																						"amount_dao", 
																						null, 
																						"AmountDAO", 
																						true, 
																						false, 
																						false, 
																						false, 
																						AmountDAO.class, 
																						SharedUtil.extractNVConfigs(Params.values()), 
																						null, 
																						true, 
																						SetNameDescriptionDAO.NVC_NAME_DESCRIPTION_DAO
																					);
	
	
	/**
	 * The default constructor.
	 */
	public AmountDAO()
	{
		super(NVC_AMOUNT_DAO);
		setCurrency(DEFAULT_CURRENCY);
	}
	
	/**
	 * This constructor instantiates MoneyValueDAO based on given amount (BigDecimal) and currency (Currency).
	 * @param amount
	 * @param currency
	 */
	public AmountDAO(BigDecimal amount, Currency currency)
	{
		this();
		setAmount(amount);
		if (currency != null) {
            setCurrency(currency);
        }
	}

    public AmountDAO(BigDecimal amount) {
        this(amount, null);
    }
	
	/**
	 * This constructor instantiates MoneyValueDAO given the amount (String).
	 * The default currency is applied.
	 * @param amount
	 */
	public AmountDAO(String amount)
	{
		this(new BigDecimal(amount), null);
	}
	
	/**
	 * This constructor instantiates MoneyValueDAO given the amount (long).
	 * The default currency is applied.
	 * @param amount
	 */
	public AmountDAO(long amount)
	{
		this(new BigDecimal(amount), null);
	}
	
	/**
	 * This constructor instantiates MoneyValueDAO given the amount (float).
	 * The default currency is applied.
	 * @param amount
	 */
	public AmountDAO(float amount)
	{
		this(BigDecimal.valueOf(amount), null);
	}
	
	/**
	 * This constructor instantiates MoneyValueDAO based on given currency (Currency).
	 * @param currency
	 */
	public AmountDAO(Currency currency)
	{
		this(null, currency);
	}
	
	/**
	 * Returns the currency.
	 * @return currency
	 */
	public Currency getCurrency() 
	{
		return lookupValue(Params.CURRENCY);
	}
	
	@Override
	public boolean equals(Object obj)
	{
		if (obj != null)
		{
			
			if (obj instanceof AmountDAO)
			{
				AmountDAO mvd = (AmountDAO) obj;
				if (mvd.getCurrency() == getCurrency() && mvd.getAmount().equals(getAmount()))
				{
					return true;
				}
				
			}
			else if (obj instanceof BigDecimal)
			{
				return getAmount().equals(obj);
			}
			
		}
		
		return false;
	}
	/**
	 * Sets the currency.
	 * @param currency
	 */
	public void setCurrency(Currency currency)
	{
		setValue(Params.CURRENCY, currency);
	}
	
	/**
	 * Returns the value.
	 * @return value
	 */
	public BigDecimal getAmount()
	{
		BigDecimal ret = lookupValue(Params.AMOUNT);
		if (ret != null)
		{
		    ret = ret.setScale(2);
        }

		return ret;
	}
	
	/**
	 * Sets the value.
	 * @param value
	 */
	public void setAmount(BigDecimal value)
	{
		setValue(Params.AMOUNT, value);
	}
	
	/**
	 * Returns the value as String.
	 */
	@Override
	public String toValue() 
	{
		return toString();
	}

    /**
     * Returns a string representation of the value and currency.
     * Examples:
     * Value = 100.00 and currency = USD ($), returns $100.00,
     * Value = -100.00 and currency = USD ($), returns -$100.00
     */
    @Override
    public String toString()
    {
        String ret = null;

        if (getAmount() != null && getCurrency() != null)
        {

            if (getAmount().signum() < 0)
            {
                ret = "-" + getCurrency().getValue() + getAmount().abs();
            }
            else
            {
                ret = getCurrency().getValue() + getAmount();
            }
        }

        return ret;
    }
}
```


Overlapping Code:
```
("serial")
public class AmountDAO
extends SetNameDescriptionDAO
implements RenderableValue<String>
{
/**
* Default currency set to U.S. dollar (USD).
*/
public static final Currency DEFAULT_CURRENCY = Currency.USD;

public enum Params
implements GetNVConfig
{
CURRENCY(NVConfigManager.createNVConfig("currency", "Currency", "Currency", true, true, Currency.class)),
AMOUNT(NVConfigManager.createNVConfig("amount", "Amount", "Amount", true, true, BigDecimal.class)),

;

private final NVConfig cType;

Params(NVConfig c)
{
cType = c;
}

@Override
public NVConfig getNVConfig()
{
return cType;
}
}

public static final NVConfigEntity NVC_AMOUNT_DAO = new NVConfigEntityLocal(
"amount_dao", 
null, 
"AmountDAO", 
true, 
false, 
false, 
false, 
AmountDAO.class, 
SharedUtil.extractNVConfigs(Params.values()), 
null, 
true, 
SetNameDescriptionDAO.NVC_NAME_DESCRIPTION_DAO
);


/**
* The default constructor.
*/
public AmountDAO()
{
super(NVC_AMOUNT_DAO);
setCurrency(DEFAULT_CURRENCY);
}

/**
* This constructor instantiates MoneyValueDAO based on given amount (BigDecimal) and currency (Currency).
* @param amount
* @param currency
*/
public AmountDAO(BigDecimal amount, Currency currency)
{
this();
setAmount(amount);
if (currency != null) {
setCurrency(currency);
}
}
public AmountDAO(BigDecimal amount) {
this(amount, null);
}

/**
* This constructor instantiates MoneyValueDAO given the amount (String).
* The default currency is applied.
* @param amount
*/
public AmountDAO(String amount)
{
this(new BigDecimal(amount), null);
}

/**
* This constructor instantiates MoneyValueDAO given the amount (long).
* The default currency is applied.
* @param amount
*/
public AmountDAO(long amount)
{
this(new BigDecimal(amount), null);
}

/**
* This constructor instantiates MoneyValueDAO given the amount (float).
* The default currency is applied.
* @param amount
*/
public AmountDAO(float amount)
{
this(B
```
<Overlap Ratio: 0.9783728115345005>

---

--- 167 --
Question ID: acca4f51ed37e37e4b238bb26a92232f8f5f937d
Original Code:
```
public class SignatureCalculator {

    public static String signature(List<String> input) {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < input.size(); i++) {
            if (i > 0) {
                sb.append("|");
            }

            sb.append(input.get(i));
        }

        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(sb.toString().getBytes());
            byte[] digest = md.digest();
            return DatatypeConverter.printHexBinary(digest).toLowerCase();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException();
        }
    }

}
```


Overlapping Code:
```
r {
public static String signature(List<String> input) {
StringBuilder sb = new StringBuilder();
for (int i = 0; i < input.size(); i++) {
if (i > 0) {
sb.append("|");
}
sb.append(input.get(i));
}
try {
MessageDigest md = MessageDigest.getInstance("MD5");
md.update(sb.toString().getBytes());
byte[] digest = md.digest();
return DatatypeConverter.printHexBinary(digest).toLowerCase();
} catch (NoSuchAlgorithmException e) {
throw new RuntimeException();
}
}
}
```
<Overlap Ratio: 0.9366053169734151>

---

--- 168 --
Question ID: 2a63ae88b82dfa9318e34c2c4cc5d0d395254f1d
Original Code:
```
public class RegisterCustomerAgentToBlackboardPlan extends OneShotBehaviour implements PlanBody {

	private static final long serialVersionUID = 1L;
	private Logger log;

	@Override
	public EndState getEndState() {
		return EndState.SUCCESSFUL;
	}

	@Override
	public void init(PlanInstance planInstance) {
		log=LogManager.getLogger();
	}

	@Override
	public void action() {

		AID bb_aid = AgentUtil.findBlackboardAgent(myAgent);

		NamedZoneData ZoneDataName1 = 
				new NamedZoneData.Builder(ID.Customer.ZoneData.customerConfirmedJobs).
				MsgID(MessageIds.msgcustomerConfirmedJobs).
				appendValue(false).
				build();

		NamedZoneData ZoneDataName2 = 
				new NamedZoneData.Builder(ID.Customer.ZoneData.newWorkOrderFromCustomer).
				MsgID(MessageIds.msgnewWorkOrderFromCustomer).
				appendValue(false).
				build();

		NamedZoneData ZoneDataName3 = 
				new NamedZoneData.Builder(ID.Customer.ZoneData.customerJobsUnderNegotiation).
				MsgID(MessageIds.msgcustomerJobsUnderNegotiation).
				appendValue(false).
				build();

		NamedZoneData ZoneDataName4 = 
				new NamedZoneData.Builder(ID.Customer.ZoneData.customerCanceledOrders).
				MsgID(MessageIds.msgcustomerCanceledOrders).
				appendValue(false).
				build();

		NamedZoneData ZoneDataName5 = 
				new NamedZoneData.Builder(ID.Customer.ZoneData.customerChangeDDorders).
				MsgID(MessageIds.msgcustomerChangeDDorders).
				appendValue(false).
				build();

		NamedZoneData[] ZoneDataNames =  { ZoneDataName1,
				ZoneDataName2,ZoneDataName3, ZoneDataName4, ZoneDataName5 };


		AgentUtil.makeZoneBB(myAgent,ZoneDataNames);

		SubscriptionForm subform = new SubscriptionForm();
		AID target = new AID(ID.GlobalScheduler.LocalName, AID.ISLOCALNAME);

		String[] params = { ID.GlobalScheduler.ZoneData.GSAjobsUnderNegaotiation,
				ID.GlobalScheduler.ZoneData.GSAConfirmedOrder,
				ID.GlobalScheduler.ZoneData.completedJobByGSA ,
				ID.GlobalScheduler.ZoneData.dueDateChangeBatches,
				ID.GlobalScheduler.ZoneData.rejectedOrders};

		subform.AddSubscriptionReq(target, params);

		AgentUtil.subscribeToParam(myAgent, bb_aid, subform);
	}
}
```


Overlapping Code:
```
rAgentToBlackboardPlan extends OneShotBehaviour implements PlanBody {
private static final long serialVersionUID = 1L;
private Logger log;
@Override
public EndState getEndState() {
return EndState.SUCCESSFUL;
}
@Override
public void init(PlanInstance planInstance) {
log=LogManager.getLogger();
}
@Override
public void action() {
AID bb_aid = AgentUtil.findBlackboardAgent(myAgent);
NamedZoneData ZoneDataName1 = 
new NamedZoneData.Builder(ID.Customer.ZoneData.customerConfirmedJobs).
MsgID(MessageIds.msgcustomerConfirmedJobs).
appendValue(false).
build();
NamedZoneData ZoneDataName2 = 
new NamedZoneData.Builder(ID.Customer.ZoneData.newWorkOrderFromCustomer).
MsgID(MessageIds.msgnewWorkOrderFromCustomer).
appendValue(false).
build();
NamedZoneData ZoneDataName3 = 
new NamedZoneData.Builder(ID.Customer.ZoneData.customerJobsUnderNegotiation).
MsgID(MessageIds.msgcustomerJobsUnderNegotiation).
appendValue(false).
build();
NamedZoneData ZoneDataName4 = 
new NamedZoneData.Builder(ID.Customer.ZoneData.customerCanceledOrders).
MsgID(MessageIds.msgcustomerCanceledOrders).
appendValue(false).
build();
NamedZoneData ZoneDataName5 = 
new NamedZoneData.Builder(ID.Customer.ZoneData.customerChangeDDorders).
MsgID(MessageIds.msgcustomerChangeDDorders).
appendValue(false).
build();
NamedZoneData[] ZoneDataNames = { ZoneDataName1,
ZoneDataName2,ZoneDataName3, ZoneDataName4, ZoneDataName5 };
AgentUtil.makeZoneBB(myAgent,ZoneDataNames);
SubscriptionForm subform = new SubscriptionForm();
AID target = new AID(ID.GlobalScheduler.LocalName, AID.ISLOCALNAME);
String[] params = { ID.GlobalScheduler.ZoneData.GSAjobsUnderNegaotiation,
ID.GlobalScheduler.ZoneData.GSAConfirmedOrder,
ID.GlobalScheduler.ZoneData.completedJobByGSA ,
ID.GlobalScheduler.ZoneData.dueDateChangeBatches,
ID.GlobalScheduler.ZoneData.rejectedOrders};
subform.AddSubscriptionReq(target, params);
AgentUtil.subscribeToParam(myAgent, bb_aid, subform);
}
```
<Overlap Ratio: 0.9846153846153847>

---

--- 169 --
Question ID: 9cf93c7824064e384f1cedb46f2a6b6395b54566
Original Code:
```
public abstract class AbstractPartitionPrimaryReplicaAntiEntropyTask
        implements PartitionSpecificRunnable, UrgentSystemOperation {

    private static final int OPERATION_TRY_COUNT = 10;

    private static final int OPERATION_TRY_PAUSE_MILLIS = 250;

    protected final NodeEngineImpl nodeEngine;

    protected final InternalPartitionServiceImpl partitionService;

    protected final int partitionId;

    public AbstractPartitionPrimaryReplicaAntiEntropyTask(NodeEngineImpl nodeEngine, int partitionId) {
        this.nodeEngine = nodeEngine;
        this.partitionService = (InternalPartitionServiceImpl) nodeEngine.getPartitionService();
        this.partitionId = partitionId;
    }

    @Override
    public int getPartitionId() {
        return partitionId;
    }

    // works only on primary. backups are retained in PartitionBackupReplicaAntiEntropyTask
    final Collection<ServiceNamespace> retainAndGetNamespaces() {
        PartitionReplicationEvent event = new PartitionReplicationEvent(partitionId, 0);
        Collection<FragmentedMigrationAwareService> services = nodeEngine.getServices(FragmentedMigrationAwareService.class);

        Set<ServiceNamespace> namespaces = new HashSet<>();
        for (FragmentedMigrationAwareService service : services) {
            Collection<ServiceNamespace> serviceNamespaces = service.getAllServiceNamespaces(event);
            if (serviceNamespaces != null) {
                namespaces.addAll(serviceNamespaces);
            }
        }
        namespaces.add(NonFragmentedServiceNamespace.INSTANCE);

        PartitionReplicaManager replicaManager = partitionService.getReplicaManager();
        replicaManager.retainNamespaces(partitionId, namespaces);
        return replicaManager.getNamespaces(partitionId);
    }

    final void invokePartitionBackupReplicaAntiEntropyOp(int replicaIndex, PartitionReplica target,
                                                         Collection<ServiceNamespace> namespaces,
                                                         BiConsumer<Object, Throwable> callback) {
        if (skipSendingToTarget(target)) {
            return;
        }

        PartitionReplicaManager replicaManager = partitionService.getReplicaManager();
        Map<ServiceNamespace, Long> versionMap = new HashMap<>();
        for (ServiceNamespace ns : namespaces) {
            long[] versions = replicaManager.getPartitionReplicaVersions(partitionId, ns);
            long currentReplicaVersion = versions[replicaIndex - 1];

            if (currentReplicaVersion > 0) {
                versionMap.put(ns, currentReplicaVersion);
            }
        }

        boolean hasCallback = (callback != null);

        PartitionBackupReplicaAntiEntropyOperation op = new PartitionBackupReplicaAntiEntropyOperation(versionMap, hasCallback);
        op.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(SERVICE_NAME);
        OperationService operationService = nodeEngine.getOperationService();

        if (hasCallback) {
            operationService.createInvocationBuilder(SERVICE_NAME, op, target.address())
                            .setTryCount(OPERATION_TRY_COUNT)
                            .setTryPauseMillis(OPERATION_TRY_PAUSE_MILLIS)
                            .invoke()
                            .whenCompleteAsync(callback);
        } else {
            operationService.send(op, target.address());
        }
    }

    private boolean skipSendingToTarget(PartitionReplica target) {
        ClusterServiceImpl clusterService = nodeEngine.getNode().getClusterService();

        assert !target.isIdentical(nodeEngine.getLocalMember()) : "Could not send anti-entropy operation, because "
                + target + " is local member itself! Local-member: " + clusterService.getLocalMember()
                + ", " + partitionService.getPartition(partitionId);

        if (clusterService.getMember(target.address(), target.uuid()) == null) {
            ILogger logger = nodeEngine.getLogger(getClass());
            if (logger.isFinestEnabled()) {
                if (clusterService.isMissingMember(target.address(), target.uuid())) {
                    logger.finest("Could not send anti-entropy operation, because " + target + " is a missing member. "
                            + partitionService.getPartition(partitionId));
                } else {
                    logger.finest("Could not send anti-entropy operation, because " + target + " is not a known member. "
                            + partitionService.getPartition(partitionId));
                }
            }
            return true;
        }
        return false;
    }
}
```


Overlapping Code:
```
tPartitionPrimaryReplicaAntiEntropyTask
implements PartitionSpecificRunnable, UrgentSystemOperation {
private static final int OPERATION_TRY_COUNT = 10;
private static final int OPERATION_TRY_PAUSE_MILLIS = 250;
protected final NodeEngineImpl nodeEngine;
protected final InternalPartitionServiceImpl partitionService;
protected final int partitionId;
public AbstractPartitionPrimaryReplicaAntiEntropyTask(NodeEngineImpl nodeEngine, int partitionId) {
this.nodeEngine = nodeEngine;
this.partitionService = (InternalPartitionServiceImpl) nodeEngine.getPartitionService();
this.partitionId = partitionId;
}
@Override
public int getPartitionId() {
return partitionId;
}
// works only on primary. backups are retained in PartitionBackupReplicaAntiEntropyTask
final Collection<ServiceNamespace> retainAndGetNamespaces() {
PartitionReplicationEvent event = new PartitionReplicationEvent(partitionId, 0);
Collection<FragmentedMigrationAwareService> services = nodeEngine.getServices(FragmentedMigrationAwareService.class);
Set<ServiceNamespace> namespaces = new HashSet<>();
for (FragmentedMigrationAwareService service : services) {
Collection<ServiceNamespace> serviceNamespaces = service.getAllServiceNamespaces(event);
if (serviceNamespaces != null) {
namespaces.addAll(serviceNamespaces);
}
}
namespaces.add(NonFragmentedServiceNamespace.INSTANCE);
PartitionReplicaManager replicaManager = partitionService.getReplicaManager();
replicaManager.retainNamespaces(partitionId, namespaces);
return replicaManager.getNamespaces(partitionId);
}
final void invokePartitionBackupReplicaAntiEntropyOp(int replicaIndex, PartitionReplica target,
Collection<ServiceNamespace> namespaces,
BiConsumer<Object, Throwable> callback) {
if (skipSendingToTarget(target)) {
return;
}
PartitionReplicaManager replicaManager = partitionService.getReplicaManager();
Map<ServiceNamespace, Long> versionMap = new HashMap<>();
for (ServiceNamespace ns : namespaces) {
long[] versions = replicaManager.getPartitionReplicaVersions(partitionId, ns);
long current
```
<Overlap Ratio: 0.9764082811747713>

---

--- 170 --
Question ID: 635ba8819067695663e2ee8f115041f3ded041ae
Original Code:
```
public class LuceneBooleanIndex extends BaseLuceneTest {

  @Override
  protected String getDatabaseName() {
    return "booleanTest";
  }

  @BeforeClass
  public void init() {
    initDB();
    OSchema schema = databaseDocumentTx.getMetadata().getSchema();
    OClass v = schema.getClass("V");
    OClass song = schema.createClass("Person");
    song.setSuperClass(v);
    song.createProperty("isDeleted", OType.BOOLEAN);

    databaseDocumentTx.command(new OCommandSQL("create index Person.isDeleted on Person (isDeleted) FULLTEXT ENGINE LUCENE"))
        .execute();

  }

  @AfterClass
  public void deInit() {
    deInitDB();
  }

  public void insertPerson() {

    for (int i = 0; i < 1000; i++) {
      ODocument doc = new ODocument("Person");
      doc.field("isDeleted", i % 2 == 0);
      databaseDocumentTx.save(doc);
    }

    List<ODocument> docs = databaseDocumentTx
        .query(new OSQLSynchQuery<ODocument>("select from Person where isDeleted lucene false"));

    Assert.assertEquals(500, docs.size());
    Assert.assertEquals(false, docs.get(0).field("isDeleted"));
    docs = databaseDocumentTx.query(new OSQLSynchQuery<ODocument>("select from Person where isDeleted lucene true"));

    Assert.assertEquals(500, docs.size());
    Assert.assertEquals(true, docs.get(0).field("isDeleted"));
  }
}
```


Overlapping Code:
```
leanIndex extends BaseLuceneTest {
@Override
protected String getDatabaseName() {
return "booleanTest";
}
@BeforeClass
public void init() {
initDB();
OSchema schema = databaseDocumentTx.getMetadata().getSchema();
OClass v = schema.getClass("V");
OClass song = schema.createClass("Person");
song.setSuperClass(v);
song.createProperty("isDeleted", OType.BOOLEAN);
databaseDocumentTx.command(new OCommandSQL("create index Person.isDeleted on Person (isDeleted) FULLTEXT ENGINE LUCENE"))
.execute();
}
@AfterClass
public void deInit() {
deInitDB();
}
public void insertPerson() {
for (int i = 0; i < 1000; i++) {
ODocument doc = new ODocument("Person");
doc.field("isDeleted", i % 2 == 0);
databaseDocumentTx.save(doc);
}
List<ODocument> docs = databaseDocumentTx
.query(new OSQLSynchQuery<ODocument>("select from Person where isDeleted lucene false"));
Assert.assertEquals(500, docs.size());
Assert.assertEquals(false, docs.get(0).field("isDeleted"));
docs = databaseDocumentTx.query(new OSQLSynchQuery<ODocument>("select from Person where isDeleted lucene true"));
Assert.assertEquals(500, docs.size());
Assert.assertEquals(true, docs.get(0).field("is
```
<Overlap Ratio: 0.9688026981450253>

---

--- 171 --
Question ID: 77b83560aa4d4120003c17ff5690b46b85cae23c
Original Code:
```
@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
public class InputDeviceState {
	// DEVICE_ID_PAD_0 from the cpp code. TODO: allocate these sequentially if we get more controllers.
	private static int deviceId = 10;
	
	private InputDevice mDevice;
	private int[] mAxes;
		
	InputDevice getDevice() { return mDevice; }
	
	public InputDeviceState(InputDevice device) {
	     mDevice = device;
	     int numAxes = 0;
	     for (MotionRange range : device.getMotionRanges()) {
	          if ((range.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
	               numAxes += 1;
	          }
	     }

	     mAxes		= new int[numAxes];

	     int i = 0;
	     for (MotionRange range : device.getMotionRanges()) {
	          if ((range.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
	               mAxes[i++] = range.getAxis();
	          }
	     }
	}
	
	public static float ProcessAxis(InputDevice.MotionRange range, float axisvalue) {
		float absaxisvalue = Math.abs(axisvalue);
		float deadzone = range.getFlat();
		if (absaxisvalue <= deadzone) {
			return 0.0f;
		}
		float normalizedvalue;
		if (axisvalue < 0.0f) {
			normalizedvalue = absaxisvalue / range.getMin();
		} else {
			normalizedvalue = absaxisvalue / range.getMax();
		}

		return normalizedvalue;
	}
	
	private static boolean isGameKey(int keyCode) {
		switch (keyCode) {
		case KeyEvent.KEYCODE_DPAD_UP:
		case KeyEvent.KEYCODE_DPAD_DOWN:
		case KeyEvent.KEYCODE_DPAD_LEFT:
		case KeyEvent.KEYCODE_DPAD_RIGHT:
			return true;
		default:
			return KeyEvent.isGamepadButton(keyCode);
		}
	}
	
	public boolean onKeyDown(KeyEvent event) {
		int keyCode = event.getKeyCode();
		if (event.getRepeatCount() == 0) {
			if (isGameKey(keyCode)) {
				NativeApp.keyDown(deviceId, keyCode);
				return true;
			}
		}
		return false;
	}
	
	public boolean onKeyUp(KeyEvent event) {
	     int keyCode = event.getKeyCode();
	     if (isGameKey(keyCode)) {
	    	 NativeApp.keyUp(deviceId, keyCode);
	         return true;
	     }
	     return false;
	}
	
	public boolean onJoystickMotion(MotionEvent event) {
		if ((event.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) == 0) {
			return false;
		}
		NativeApp.beginJoystickEvent();
		for (int i = 0; i < mAxes.length; i++) {
			int axisId = mAxes[i];
			float value = event.getAxisValue(axisId);
			// TODO: Use processAxis or move that to the C++ code
			NativeApp.joystickAxis(deviceId, axisId, value);
		}
		NativeApp.endJoystickEvent();

		return true;
	}
}
```


Overlapping Code:
```
@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
public class InputDeviceState {
// DEVICE_ID_PAD_0 from the cpp code. TODO: allocate these sequentially if we get more controllers.
private static int deviceId = 10;

private InputDevice mDevice;
private int[] mAxes;

InputDevice getDevice() { return mDevice; }

public InputDeviceState(InputDevice device) {
mDevice = device;
int numAxes = 0;
for (MotionRange range : device.getMotionRanges()) {
if ((range.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
numAxes += 1;
}
}
mAxes = new int[numAxes];
int i = 0;
for (MotionRange range : device.getMotionRanges()) {
if ((range.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
mAxes[i++] = range.getAxis();
}
}
}

public static float ProcessAxis(InputDevice.MotionRange range, float axisvalue) {
float absaxisvalue = Math.abs(axisvalue);
float deadzone = range.getFlat();
if (absaxisvalue <= deadzone) {
return 0.0f;
}
float normalizedvalue;
if (axisvalue < 0.0f) {
normalizedvalue = absaxisvalue / range.getMin();
} else {
normalizedvalue = absaxisvalue / range.getMax();
}
return normalizedvalue;
}

private static boolean isGameKey(int keyCode) {
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
case KeyEvent.KEYCODE_DPAD_DOWN:
case KeyEvent.KEYCODE_DPAD_LEFT:
case KeyEvent.KEYCODE_DPAD_RIGHT:
return true;
default:
return KeyEvent.isGamepadButton(keyCode);
}
}

public boolean onKeyDown(KeyEvent event) {
int keyCode = event.getKeyCode();
if (event.getRepeatCount() == 0) {
if (isGameKey(keyCode)) {
NativeApp.keyDown(deviceId, keyCode);
return true;
}
}
return false;
}

public boolean onKeyUp(KeyEvent event) {
int keyCode = event.getKeyCode();
if (isGameKey(keyCode)) {
NativeApp.keyUp(deviceId, keyCode);
return true;
}
return false;
}

public boolean onJoystickMotion(MotionEvent event) {
if ((event.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) == 0) {
return false;
}
NativeApp.beginJoystickEvent();
for (int i = 0; i < mAxes.length; i++) {
int axisId = mAxes[i];
float value = event.getAxisValue(axisId);
// TODO: Use processAxis or move that to the C++ code
NativeApp.joystickAxis(deviceId, axisId, value);
}
NativeApp.endJoystickEvent();
return true
```
<Overlap Ratio: 0.9977106227106227>

---

--- 172 --
Question ID: 849440a30c7920d98667b01652e0d6d1d7ae9238
Original Code:
```
public abstract class ISO8601TypeAdapter extends TypeAdapter<Date>{

    private static final DateTimeFormatter iso8601Format = ISODateTimeFormat.dateTime();

    public static final TypeAdapter<Date> DATE_ADAPTER = new ISO8601TypeAdapter() {
        @Override
        public void write(JsonWriter out, Date value) throws IOException {
            if (value != null) {
                out.value(iso8601Format.print(value.getTime()));
            } else {
                out.nullValue();
            }
        }

        @Override
        public Date read(JsonReader in) throws IOException {
            JsonToken peek = in.peek();
            if (peek == JsonToken.NULL) {
                in.nextNull();
                return null;
            }
            return iso8601Format.parseDateTime(in.nextString()).toDate();
        }
    };
}
```


Overlapping Code:
```
tract class ISO8601TypeAdapter extends TypeAdapter<Date>{
private static final DateTimeFormatter iso8601Format = ISODateTimeFormat.dateTime();
public static final TypeAdapter<Date> DATE_ADAPTER = new ISO8601TypeAdapter() {
@Override
public void write(JsonWriter out, Date value) throws IOException {
if (value != null) {
out.value(iso8601Format.print(value.getTime()));
} else {
out.nullValue();
}
}
@Override
public Date read(JsonReader in) throws IOException {
JsonToken peek = in.peek();
if (peek == JsonToken.NULL) {
in.nextNull();
return null;
}
return iso8601Format.parseDateTime(in.nextString(
```
<Overlap Ratio: 0.9538950715421304>

---

--- 173 --
Question ID: b77c659fcfdaa812df9ef1097e903318901ccce2
Original Code:
```
public class UserTest {
    /**
     * property - TEST_NAME.
     */
    static final String TEST_NAME = "name";
    /**
     * property - TEST_CITY.
     */
    static final String TEST_CITY = "city";
    /**
     * property - TEST_ID.
     */
    private static final int TEST_ID = 99;
    /**
     * property - new object User for testing.
     */
    private User userOne = new User();

    /**
     * Test create new object User through a constructor with empty values.
     */
    @Test
    public void whenConstructorNotNewUserThenGetIdOne() {
        User userTwo = new User();
        final int expectedId = userTwo.getId() != 0 ? userTwo.getId() : 0;
        assertThat(userTwo.getId(), is(expectedId));
    }

    /**
     * Test create new object User through the designer with the specified id.
     */
    @Test
    public void whenConstructorIdNewUserThenGetIdOne() {
        User userTwo = new User(TEST_ID);
        assertThat(userTwo.getId(), is(TEST_ID));
    }

    /**
     * Test create new object User through the designer with the specified: id, name, city.
     */
    @Test
    public void whenConstructorAllNewUserThenGetIdTwo() {
        User userTwo = new User(TEST_ID, TEST_NAME, TEST_CITY);
        assertThat(userTwo.getId(), is(TEST_ID));
        assertThat(userTwo.getName(), is(TEST_NAME));
        assertThat(userTwo.getCity(), is(TEST_CITY));
    }

    /**
     * Test setter and getter property id.
     */
    @Test
    public void whenSetIdThenGetId() {
        userOne.setId(TEST_ID);
        assertThat(userOne.getId(), is(TEST_ID));
    }

    /**
     * Test setter and getter property name.
     */
    @Test
    public void whenSetNameThenGetName() {
        userOne.setName(TEST_NAME);
        assertThat(userOne.getName(), is(TEST_NAME));
    }

    /**
     * Test setter and getter property city.
     */
    @Test
    public void whenSetCityThenGetCity() {
        userOne.setCity(TEST_CITY);
        assertThat(userOne.getCity(), is(TEST_CITY));
    }
}
```


Overlapping Code:
```
c class UserTest {
/**
* property - TEST_NAME.
*/
static final String TEST_NAME = "name";
/**
* property - TEST_CITY.
*/
static final String TEST_CITY = "city";
/**
* property - TEST_ID.
*/
private static final int TEST_ID = 99;
/**
* property - new object User for testing.
*/
private User userOne = new User();
/**
* Test create new object User through a constructor with empty values.
*/
@Test
public void whenConstructorNotNewUserThenGetIdOne() {
User userTwo = new User();
final int expectedId = userTwo.getId() != 0 ? userTwo.getId() : 0;
assertThat(userTwo.getId(), is(expectedId));
}
/**
* Test create new object User through the designer with the specified id.
*/
@Test
public void whenConstructorIdNewUserThenGetIdOne() {
User userTwo = new User(TEST_ID);
assertThat(userTwo.getId(), is(TEST_ID));
}
/**
* Test create new object User through the designer with the specified: id, name, city.
*/
@Test
public void whenConstructorAllNewUserThenGetIdTwo() {
User userTwo = new User(TEST_ID, TEST_NAME, TEST_CITY);
assertThat(userTwo.getId(), is(TEST_ID));
assertThat(userTwo.getName(), is(TEST_NAME));
assertThat(userTwo.getCity(), is(TEST_CITY));
}
/**
* Test setter and getter property id.
*/
@Test
public void whenSetIdThenGetId() {
userOne.setId(TEST_ID);
assertThat(userOne.getId(), is(TEST_ID));
}
/**
* Test setter and getter property name.
*/
@Test
public void whenSetNameThenGetName() {
userOne.setName(TEST_NAME);
assertThat(userOne.getName(), is(TEST_NAME));
}
/**
* Test setter and getter property city.
*/
@Test
public void whenSetCityThenGetCity() {
userOne.setCity(TEST_CITY);
as
```
<Overlap Ratio: 0.9685230024213075>

---

--- 174 --
Question ID: 231b9d7a658cd195792984fa56050128b035442c
Original Code:
```
public class BasicGroup implements CoGroup {

    private String name;

    Map<String, Co> members;

    public BasicGroup(String name) {
        this.name = name;
        members = new ConcurrentHashMap<>();
    }

    /*
     * (non-Javadoc)
     * @see coca.co.CoGroup#name()
     */
    @Override
    public String name() {
        return name;
    }

    /*
     * (non-Javadoc)
     * @see coca.co.CoGroup#members()
     */
    @Override
    public Collection<Co> members() {
        return members.values();
    }

    /*
     * (non-Javadoc)
     * @see coca.co.CoGroup#join(coca.co.Co)
     */
    @Override
    public boolean join(Co co) {
        try {
            return members.putIfAbsent(co.id(), of(co)) == null;
        } finally {
            Co p = members.get(co.id());
            if (p != null && p instanceof CoProxy) ((CoProxy) p).lastAccess(System.currentTimeMillis());
        }
    }

    /*
     * (non-Javadoc)
     * @see coca.co.CoGroup#quit(coca.co.Co)
     */
    @Override
    public boolean quit(Co co) {
        return members.remove(co.id()) != null;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) return false;
        if (obj instanceof CoGroup) { return ((CoGroup) obj).name().equals(name()); }
        return false;
    }

    @Override
    public boolean contain(Co member) {
        return members.containsKey(member.id());
    }

    @Override
    public String toString() {
        return name + " " + members.toString();
    }

    public static final CoProxy of(Co co) {
        return new CoProxy(co.id());
    }

    public static class CoProxy implements Co {

        private String id;
        private long lastAccess; // clear this if lastAccess + timeout < now

        public CoProxy(String id) {
            this.id = id;
        }

        public long lastAccess() {
            return lastAccess;
        }

        public CoProxy lastAccess(long lastAccess) {
            this.lastAccess = lastAccess;
            return this;
        }

        @Override
        public void close() throws IOException {

        }

        @Override
        public String id() {
            return id;
        }

        @Override
        public Co init(CoConf conf) {
            return null;
        }

        @Override
        public CoConf conf() {
            return null;
        }

        @Override
        public boolean isClosed() {
            return false;
        }

        @Override
        public Collection<CoGroup> groups() {
            return null;
        }

        @Override
        public CoGroup group(String name, boolean addIfNil) {
            return null;
        }

        @Override
        public CoFuture<InsResult> join(String name) throws CoException {
            return null;
        }

        @Override
        public CoFuture<InsResult> quit(String name) throws CoException {
            return null;
        }

        @Override
        public CoFuture<InsResult> pub(CoIns<?> ins) throws CoException {
            return null;
        }

        @Override
        public CoIns<?> sub(long timeout, TimeUnit unit) throws CoException, InterruptedException {
            return null;
        }

        @Override
        public Co insFactory(CoInsFactory insFactory) {
            return null;
        }

        @Override
        public CoInsFactory insFactory() {
            return null;
        }

        @Override
        public Co io(CoIO io) {
            return null;
        }

        @Override
        public CoIO io() {
            return null;
        }

        @Override
        public Co withListener(String name, CoListener l) {
            return null;
        }

        @Override
        public CoListener removeListener(String name) {
            return null;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null) return false;
            if (obj instanceof Co) return ((Co) obj).id().equals(id);
            return false;
        }

    }

    @Override
    public Co find(String id) {
        return members.get(id);
    }

}
```


Overlapping Code:
```
class BasicGroup implements CoGroup {
private String name;
Map<String, Co> members;
public BasicGroup(String name) {
this.name = name;
members = new ConcurrentHashMap<>();
}
/*
* (non-Javadoc)
* @see coca.co.CoGroup#name()
*/
@Override
public String name() {
return name;
}
/*
* (non-Javadoc)
* @see coca.co.CoGroup#members()
*/
@Override
public Collection<Co> members() {
return members.values();
}
/*
* (non-Javadoc)
* @see coca.co.CoGroup#join(coca.co.Co)
*/
@Override
public boolean join(Co co) {
try {
return members.putIfAbsent(co.id(), of(co)) == null;
} finally {
Co p = members.get(co.id());
if (p != null && p instanceof CoProxy) ((CoProxy) p).lastAccess(System.currentTimeMillis());
}
}
/*
* (non-Javadoc)
* @see coca.co.CoGroup#quit(coca.co.Co)
*/
@Override
public boolean quit(Co co) {
return members.remove(co.id()) != null;
}
@Override
public boolean equals(Object obj) {
if (obj == null) return false;
if (obj instanceof CoGroup) { return ((CoGroup) obj).name().equals(name()); }
return false;
}
@Override
public boolean contain(Co member) {
return members.containsKey(member.id());
}
@Override
public String toString() {
return name + " " + members.toString();
}
public static final CoProxy of(Co co) {
return new CoProxy(co.id());
}
public static class CoProxy implements Co {
private String id;
private long lastAccess; // clear this if lastAccess + timeout < now
public CoProxy(String id) {
this.id = id;
}
public long lastAccess() {
return lastAccess;
}
public CoProxy lastAccess(long lastAccess) {
this.lastAccess = lastAccess;
return this;
}
@Override
public void close() throws IOException {
}
@Override
public String id() {
return id;
}
@Override
public Co init(CoConf conf) {
return null;
}
@Override
public CoConf conf() {
return null;
}
@Override
public boolean isClosed() {
return false;
}
@Override
public 
```
<Overlap Ratio: 0.9956616052060737>

---

--- 175 --
Question ID: 6642f9ef752debb2ee5ffb876a4847d2b1941b52
Original Code:
```
public class MethodNodeImpl extends MethodNode {

    public MethodNodeImpl() {
        super(Opcodes.ASM5);
        exceptions = new ArrayList();
        tryCatchBlocks = new ArrayList();
        localVariables = new ArrayList();
        attrs = new ArrayList();
    }

    public static MethodNodeImpl duplicate(MethodNode node) {
        MethodNodeImpl self = new MethodNodeImpl();

        self.name = node.name;
        self.desc = node.desc;
        self.access = node.access;
        self.annotationDefault = node.annotationDefault;
        self.attrs = node.attrs;
        self.exceptions = node.exceptions;
        self.tryCatchBlocks = node.tryCatchBlocks;
        self.localVariables = node.localVariables;

        self.instructions = node.instructions;

        self.invisibleAnnotations = node.invisibleAnnotations;
        self.invisibleParameterAnnotations = node.invisibleParameterAnnotations;
        self.visibleAnnotations = node.visibleAnnotations;
        self.visibleParameterAnnotations = node.visibleParameterAnnotations;
        self.maxLocals = node.maxLocals;
        self.maxStack = node.maxStack;

        self.localVariables = node.localVariables;

        // HACK
        // it's needed for copied trait method, else it will generate an error in duplicated usage
        try {
            Field field = node.getClass().getDeclaredField("visited");
            field.setAccessible(true);
            field.setBoolean(self, true);
        } catch (NoSuchFieldException e) {
            throw new CriticalException(e);
        } catch (IllegalAccessException e) {
            throw new CriticalException(e);
        }
        return self;
    }

    @Override
    public void accept(ClassVisitor cv) {
        super.accept(cv);
    }
}
```


Overlapping Code:
```
pl extends MethodNode {
public MethodNodeImpl() {
super(Opcodes.ASM5);
exceptions = new ArrayList();
tryCatchBlocks = new ArrayList();
localVariables = new ArrayList();
attrs = new ArrayList();
}
public static MethodNodeImpl duplicate(MethodNode node) {
MethodNodeImpl self = new MethodNodeImpl();
self.name = node.name;
self.desc = node.desc;
self.access = node.access;
self.annotationDefault = node.annotationDefault;
self.attrs = node.attrs;
self.exceptions = node.exceptions;
self.tryCatchBlocks = node.tryCatchBlocks;
self.localVariables = node.localVariables;
self.instructions = node.instructions;
self.invisibleAnnotations = node.invisibleAnnotations;
self.invisibleParameterAnnotations = node.invisibleParameterAnnotations;
self.visibleAnnotations = node.visibleAnnotations;
self.visibleParameterAnnotations = node.visibleParameterAnnotations;
self.maxLocals = node.maxLocals;
self.maxStack = node.maxStack;
self.localVariables = node.localVariables;
// HACK
// it's needed for copied trait method, else it will generate an error in duplicated usage
try {
Field field = node.getClass().getDeclaredField("visited");
field.setAccessible(true);
field.setBoolean(self, true);
} catch (NoSuchFieldException e) {
throw new CriticalException(e);
} catch (IllegalAccessException e) {
throw new CriticalException(e);
}
return self;
}
@Override
public void accept(ClassVisitor cv) {
super.accept(cv);

```
<Overlap Ratio: 0.9803921568627451>

---

--- 176 --
Question ID: 278ee5cb2eef2c2d3b388467e85853492b66d3d1
Original Code:
```
public final class StudyConfigurationGenerator extends AbstractTestDataGenerator<StudyConfiguration> {

    public static final AbstractTestDataGenerator<StudyConfiguration> INSTANCE = new StudyConfigurationGenerator();

    private StudyConfigurationGenerator() {
        super();
    }

    @Override
    public void compareFields(StudyConfiguration original, StudyConfiguration retrieved) {
        assertEquals(original.getStatus(), retrieved.getStatus());
        assertEquals(original.getVisibility(), retrieved.getVisibility());
        StudyTestDataGenerator.INSTANCE.compare(original.getStudy(), retrieved.getStudy());
        assertEquals(original.getClinicalConfigurationCollection().size(), retrieved.getClinicalConfigurationCollection().size());
        for (int i = 0; i < original.getClinicalConfigurationCollection().size(); i++) {
            DelimitedTextClinicalSourceConfiguration config1 = (DelimitedTextClinicalSourceConfiguration) original.getClinicalConfigurationCollection().get(i);
            DelimitedTextClinicalSourceConfiguration config2 = (DelimitedTextClinicalSourceConfiguration) retrieved.getClinicalConfigurationCollection().get(i);
            DelimitedTextClinicalSourceConfigurationGenerator.INSTANCE.compare(config1, config2);
        }
        assertEquals(original.getGenomicDataSources().size(), retrieved.getGenomicDataSources().size());
        for (int i = 0; i < original.getGenomicDataSources().size(); i++) {
            GenomicDataSourceConfiguration config1 = original.getGenomicDataSources().get(i);
            GenomicDataSourceConfiguration config2 = retrieved.getGenomicDataSources().get(i);
            GenomicDataSourceConfigurationGenerator.INSTANCE.compare(config1, config2);
        }
        assertEquals(original.getImageDataSources().size(), retrieved.getImageDataSources().size());
        for (int i = 0; i < original.getImageDataSources().size(); i++) {
            ImageDataSourceConfiguration config1 = original.getImageDataSources().get(i);
            ImageDataSourceConfiguration config2 = retrieved.getImageDataSources().get(i);
            ImageDataSourceConfigurationGenerator.INSTANCE.compare(config1, config2);
        }
    }

    @Override
    public StudyConfiguration createPersistentObject() {
        return new StudyConfiguration();
    }

    @Override
    public void setValues(StudyConfiguration studyConfiguration, Set<AbstractCaIntegrator2Object> nonCascadedObjects) {
        studyConfiguration.setStatus(getNewEnumValue(studyConfiguration.getStatus(), Status.values()));
        studyConfiguration.setVisibility(getNewEnumValue(studyConfiguration.getVisibility(), Visibility.values()));
        if (studyConfiguration.getStudy() == null) {
            studyConfiguration.setStudy(StudyTestDataGenerator.INSTANCE.createPersistentObject());
        }
        studyConfiguration.getStudy().setStudyConfiguration(studyConfiguration);
        StudyTestDataGenerator.INSTANCE.setValues(studyConfiguration.getStudy(), nonCascadedObjects);
        studyConfiguration.getClinicalConfigurationCollection().clear();
        for (int i = 0; i < 3; i++) {
            DelimitedTextClinicalSourceConfiguration config = new DelimitedTextClinicalSourceConfiguration(null, studyConfiguration);
            DelimitedTextClinicalSourceConfigurationGenerator.INSTANCE.setValues(config, nonCascadedObjects);
        }
        studyConfiguration.getGenomicDataSources().clear();
        for (int i = 0; i < 3; i++) {
            GenomicDataSourceConfiguration config = new GenomicDataSourceConfiguration();
            studyConfiguration.getGenomicDataSources().add(config);
            config.setStudyConfiguration(studyConfiguration);
            config.setDataType(PlatformDataTypeEnum.EXPRESSION);
            GenomicDataSourceConfigurationGenerator.INSTANCE.setValues(config, nonCascadedObjects);
        }
        for (int i = 0; i < 3; i++) {
            GenomicDataSourceConfiguration config = new GenomicDataSourceConfiguration();
            studyConfiguration.getGenomicDataSources().add(config);
            config.setStudyConfiguration(studyConfiguration);
            config.setDataType(PlatformDataTypeEnum.COPY_NUMBER);
            GenomicDataSourceConfigurationGenerator.INSTANCE.setValues(config, nonCascadedObjects);
        }
        for (int i = 0; i < 3; i++) {
            ImageDataSourceConfiguration config = new ImageDataSourceConfiguration();
            studyConfiguration.getImageDataSources().add(config);
            config.setStudyConfiguration(studyConfiguration);
            ImageDataSourceConfigurationGenerator.INSTANCE.setValues(config, nonCascadedObjects);
        }
    }

}
```


Overlapping Code:
```
 class StudyConfigurationGenerator extends AbstractTestDataGenerator<StudyConfiguration> {
public static final AbstractTestDataGenerator<StudyConfiguration> INSTANCE = new StudyConfigurationGenerator();
private StudyConfigurationGenerator() {
super();
}
@Override
public void compareFields(StudyConfiguration original, StudyConfiguration retrieved) {
assertEquals(original.getStatus(), retrieved.getStatus());
assertEquals(original.getVisibility(), retrieved.getVisibility());
StudyTestDataGenerator.INSTANCE.compare(original.getStudy(), retrieved.getStudy());
assertEquals(original.getClinicalConfigurationCollection().size(), retrieved.getClinicalConfigurationCollection().size());
for (int i = 0; i < original.getClinicalConfigurationCollection().size(); i++) {
DelimitedTextClinicalSourceConfiguration config1 = (DelimitedTextClinicalSourceConfiguration) original.getClinicalConfigurationCollection().get(i);
DelimitedTextClinicalSourceConfiguration config2 = (DelimitedTextClinicalSourceConfiguration) retrieved.getClinicalConfigurationCollection().get(i);
DelimitedTextClinicalSourceConfigurationGenerator.INSTANCE.compare(config1, config2);
}
assertEquals(original.getGenomicDataSources().size(), retrieved.getGenomicDataSources().size());
for (int i = 0; i < original.getGenomicDataSources().size(); i++) {
GenomicDataSourceConfiguration config1 = original.getGenomicDataSources().get(i);
GenomicDataSourceConfiguration config2 = retrieved.getGenomicDataSources().get(i);
GenomicDataSourceConfigurationGenerator.INSTANCE.compare(config1, config2);
}
assertEquals(original.getImageDataSources().size(), retrieved.getImageDataSources().size());
for (int i = 0; i < original.getImageDataSources().size(); i++) {
ImageDataSourceConfiguration config1 = original.getImageDataSources().get(i);
ImageDataSourceConfiguration config2 = retrieved.getImageDataSources().get(i);
ImageDataSourceConfigurationGenerator.INSTANCE.compare(config1, config2);
}
}
@Override
public StudyConfiguration createPersistentObject() {
return new StudyConfiguration();
}
@Override
public void setValues(StudyConfiguration studyConfiguration, Set<AbstractCaIntegrator2Object> nonCascadedObjects) {
studyConfiguration.setSt
```
<Overlap Ratio: 0.9900990099009901>

---

--- 177 --
Question ID: 9be7d4f43cbba04ab5ae5fbe41b5e00f9bd8602a
Original Code:
```
public class CustoController implements Initializable {

    @FXML
    private AnchorPane apPrincipal;
    private Date dtInclusao;
    @FXML
    private TextField tfCustoPlanejado;
    @FXML
    private TextField tfCustoRealizado;
    private Custo custo;
    private Projeto projeto;
    private Stage stage;
    private GerenciadorDeJanela gerenciadorDeJanela;
    Map<String,Object> params = new HashMap<>();
    /**
     * Initializes the controller class.
     */
    
    @Override
    public void initialize(URL url, ResourceBundle rb) {
        apPrincipal.sceneProperty().addListener((ObservableValue<? extends Scene> observable, Scene oldValue, Scene newValue) -> {
            params = (Map) apPrincipal.getUserData();
            gerenciadorDeJanela = (GerenciadorDeJanela) params.get("gerenciador");
        });
    }

    public void teste(){
        params = (Map) apPrincipal.getUserData();
        gerenciadorDeJanela = (GerenciadorDeJanela) params.get("gerenciador");
        dtInclusao = (Date) params.get("dtInclusao");
        custo = (Custo) params.get("custo");
        projeto = (Projeto) params.get("projeto");
        stage = (Stage) params.get("modalStage");
        if(null != custo.getCustoTecnicoPlanejado()){
            tfCustoPlanejado.setText(String.valueOf(custo.getCustoTecnicoPlanejado()));
        }else{
            tfCustoPlanejado.setText("0.0");
        }
        
        if(null != custo.getCustoTecnicoRealizado()){
            tfCustoRealizado.setText(String.valueOf(custo.getCustoTecnicoRealizado()));
        }else{
            tfCustoRealizado.setText("0.0");
        }
    }
    
    @FXML
    private void salvarCusto() {
        custo.setDtInclusao(dtInclusao);
        custo.setProjeto(projeto);
        if(StringUtil.isEmpty(tfCustoPlanejado.getText())){
            custo.setCustoTecnicoPlanejado(0.0);
        }else{
            String auxPlanejado = tfCustoPlanejado.getText();
            auxPlanejado.replaceAll("[,]*[.]*", "");
            custo.setCustoTecnicoPlanejado(DoubleConverter.stringToDouble(auxPlanejado));
        }
        
        if(StringUtil.isEmpty(tfCustoRealizado.getText())){
            custo.setCustoTecnicoRealizado(0.0);
        }else{
            String auxRealizado = tfCustoRealizado.getText();
            auxRealizado.replaceAll("[,]*[.]*", "");
            custo.setCustoTecnicoRealizado(DoubleConverter.stringToDouble(auxRealizado));
        }
        if(null == custo.getId()){
            CustoDAO.getInstance().salvar(custo);
            new Alert(Alert.AlertType.INFORMATION, "Custo cadastro com sucesso.").show();
            stage.close();
        }else{
            CustoDAO.getInstance().editar(custo);
            new Alert(Alert.AlertType.INFORMATION, "Custo atualizado com sucesso.").show();
            stage.close();
        }
        params.put("CustoAux", custo); 
    }
}
```


Overlapping Code:
```
toController implements Initializable {
@FXML
private AnchorPane apPrincipal;
private Date dtInclusao;
@FXML
private TextField tfCustoPlanejado;
@FXML
private TextField tfCustoRealizado;
private Custo custo;
private Projeto projeto;
private Stage stage;
private GerenciadorDeJanela gerenciadorDeJanela;
Map<String,Object> params = new HashMap<>();
/**
* Initializes the controller class.
*/

@Override
public void initialize(URL url, ResourceBundle rb) {
apPrincipal.sceneProperty().addListener((ObservableValue<? extends Scene> observable, Scene oldValue, Scene newValue) -> {
params = (Map) apPrincipal.getUserData();
gerenciadorDeJanela = (GerenciadorDeJanela) params.get("gerenciador");
});
}
public void teste(){
params = (Map) apPrincipal.getUserData();
gerenciadorDeJanela = (GerenciadorDeJanela) params.get("gerenciador");
dtInclusao = (Date) params.get("dtInclusao");
custo = (Custo) params.get("custo");
projeto = (Projeto) params.get("projeto");
stage = (Stage) params.get("modalStage");
if(null != custo.getCustoTecnicoPlanejado()){
tfCustoPlanejado.setText(String.valueOf(custo.getCustoTecnicoPlanejado()));
}else{
tfCustoPlanejado.setText("0.0");
}

if(null != custo.getCustoTecnicoRealizado()){
tfCustoRealizado.setText(String.valueOf(custo.getCustoTecnicoRealizado()));
}else{
tfCustoRealizado.setText("0.0");
}
}

@FXML
private void salvarCusto() {
custo.setDtInclusao(dtInclusao);
custo.setProjeto(projeto);
if(StringUtil.isEmpty(tfCustoPlanejado.getText())){
custo.setCustoTecnicoPlanejado(0.0);
}else{
String auxPlanejado = tfCustoPlanejado.getText();
auxPlanejado.replaceAll("[,]*[.]*", "");
custo.setCustoTecnicoPlanejado(DoubleConverter.stringToDouble(auxPlanejado));
}

if(StringUtil.isEmpty(tfCustoRealizado.getText())){
custo.setCustoTecnicoRealizado(0.0);
}else{
String auxRealizado = tfCustoRealizado.getText();
auxRealizado.replaceAll("[,]*[.]*", "");
custo.setCustoTecnicoRealizado(DoubleConverter.stringToDouble(auxRealizado));
}
if(null == custo
```
<Overlap Ratio: 0.9791976225854383>

---

--- 178 --
Question ID: cfcf3e66836f58db4b0e1571534047ea29d7fccd
Original Code:
```
public class SftpFileProgressMonitor implements SftpProgressMonitor {


    public long max; // the final count (i.e. length of file to transfer).
    public String destinationFileName;


    private long count; // the number of bytes transferred so far
    private int direction; // either SftpOverWriteByteChannel.PUT or get
    private String stringBeingTransferred;


    public void init(int i, String src, String destinationFileName, long max) {
        this.direction = i;
        this.stringBeingTransferred = src;
        this.destinationFileName = destinationFileName;
        this.max = max;
    }


    // Called periodically as more data is transfered.
    public boolean count(long count) {

        this.count = count;
        // true if the transfer should go on, false if the transfer should be cancelled.
        return true;
    }

    // called when the transfer ended, either because all the data was transferred,
    // or because the transfer was cancelled.
    public void end() {

    }

    public long getCount() {
        return count;
    }


}
```


Overlapping Code:
```
ProgressMonitor implements SftpProgressMonitor {
public long max; // the final count (i.e. length of file to transfer).
public String destinationFileName;
private long count; // the number of bytes transferred so far
private int direction; // either SftpOverWriteByteChannel.PUT or get
private String stringBeingTransferred;
public void init(int i, String src, String destinationFileName, long max) {
this.direction = i;
this.stringBeingTransferred = src;
this.destinationFileName = destinationFileName;
this.max = max;
}
// Called periodically as more data is transfered.
public boolean count(long count) {
this.count = count;
// true if the transfer should go on, false if the transfer should be cancelled.
return true;
}
// called when the transfer ended, either because all the data was transferred,
// or because the transfer was cancelled.
public void end()
```
<Overlap Ratio: 0.9269602577873255>

---

--- 179 --
Question ID: 20a70f427e5eae6e24a424a59041d0a32ecd9de2
Original Code:
```
public class Task11165 {
    public int[] changed(int[] array, int n, int m) {
        int[] mediumResult = new int[array.length * 3];
        int count = 0;
        for (int i = 0; i < array.length; i++) {
            if (array[i] > n) {
                mediumResult[i + count] = n;
                count++;
                mediumResult[i + count] = array[i];
            }
            if (array[i] < m) {
                mediumResult[i + count] = array[i];
                count++;
                mediumResult[i + count] = m;
            }
        }
        int[] result = new int[array.length + count];
        for (int i = 0; i < result.length; i++) {
            result[i] = mediumResult[i];
        }
        return result;
    }
}
```


Overlapping Code:
```
nt[] array, int n, int m) {
int[] mediumResult = new int[array.length * 3];
int count = 0;
for (int i = 0; i < array.length; i++) {
if (array[i] > n) {
mediumResult[i + count] = n;
count++;
mediumResult[i + count] = array[i];
}
if (array[i] < m) {
mediumResult[i + count] = array[i];
count++;
mediumResult[i + count] = m;
}
}
int[] result = new int[array.length + count];
for (int i = 0; i < result.length; i++) {
result[i] = mediumResult[i];
}
retur
```
<Overlap Ratio: 0.8823529411764706>

---

--- 180 --
Question ID: 624dc1f9b26fca3abea9621e672238fdf906c27a
Original Code:
```
public final class FNProfTest extends AdvancedQueryTest {
  /** Test method. */
  @Test
  public void mem() {
    try {
      System.setErr(NULL);
      query(_PROF_MEM.args("()"));
      query(COUNT.args(_PROF_MEM.args(" 1 to 100 ", false)), "100");
      query(COUNT.args(_PROF_MEM.args(" 1 to 100 ", true)), "100");
      query(COUNT.args(_PROF_MEM.args(" 1 to 100 ", true, "label")), "100");
    } finally {
      System.setErr(ERR);
    }
  }

  /** Test method. */
  @Test
  public void time() {
    try {
      System.setErr(NULL);
      query(_PROF_TIME.args("()"));
      query(COUNT.args(_PROF_TIME.args(" 1 to 100 ", false)), "100");
      query(COUNT.args(_PROF_TIME.args(" 1 to 100 ", true)), "100");
      query(COUNT.args(_PROF_TIME.args(" 1 to 100 ", true, "label")), "100");
    } finally {
      System.setErr(ERR);
    }
  }

  /** Test method. */
  @Test
  public void sleep() {
    query(_PROF_SLEEP.args(" 10"));
    query(_PROF_SLEEP.args(" 1"));
    query(_PROF_SLEEP.args(" 0"));
    query(_PROF_SLEEP.args(" -1"));
  }

  /** Test method. */
  @Test
  public void dump() {
    try {
      System.setErr(NULL);
      query(_PROF_DUMP.args("a"), "");
    } finally {
      System.setErr(ERR);
    }
  }

  /** Test method. */
  @Test
  public void currentMs() {
  }

  /** Test method. */
  @Test
  public void currentNs() {
  }
}
```


Overlapping Code:
```
ublic final class FNProfTest extends AdvancedQueryTest {
/** Test method. */
@Test
public void mem() {
try {
System.setErr(NULL);
query(_PROF_MEM.args("()"));
query(COUNT.args(_PROF_MEM.args(" 1 to 100 ", false)), "100");
query(COUNT.args(_PROF_MEM.args(" 1 to 100 ", true)), "100");
query(COUNT.args(_PROF_MEM.args(" 1 to 100 ", true, "label")), "100");
} finally {
System.setErr(ERR);
}
}
/** Test method. */
@Test
public void time() {
try {
System.setErr(NULL);
query(_PROF_TIME.args("()"));
query(COUNT.args(_PROF_TIME.args(" 1 to 100 ", false)), "100");
query(COUNT.args(_PROF_TIME.args(" 1 to 100 ", true)), "100");
query(COUNT.args(_PROF_TIME.args(" 1 to 100 ", true, "label")), "100");
} finally {
System.setErr(ERR);
}
}
/** Test method. */
@Test
public void sleep() {
query(_PROF_SLEEP.args(" 10"));
query(_PROF_SLEEP.args(" 1"));
query(_PROF_SLEEP.args(" 0"));
query(_PROF_SLEEP.args(" -1"));
}
/** Test method. */
@Test
public void dump() {
try {
System.setErr(NULL);
query(_PROF_DUMP.args("a"), "");
} finally {
System.setErr(ERR);
}
}
/** Test method. */
@Test
public void currentMs() {
}
/** Test method. */
@Test
```
<Overlap Ratio: 0.9732528041415013>

---

--- 181 --
Question ID: 030929737e204476711efd5a116853803fa01711
Original Code:
```
public class HibernateSessionConversationFilter
        implements Filter {

    private static Log log = LogFactory.getLog(HibernateSessionConversationFilter.class);

    private SessionFactory sf;

    public static final String HIBERNATE_SESSION_KEY = "hibernateSession";
    public static final String END_OF_CONVERSATION_FLAG = "endOfConversation";

    public void doFilter(ServletRequest request,
                         ServletResponse response,
                         FilterChain chain)
            throws IOException, ServletException {

        org.hibernate.classic.Session currentSession;

        // Try to get a Hibernate Session from the HttpSession
        HttpSession httpSession =
                ((HttpServletRequest) request).getSession();
        Session disconnectedSession =
                (Session) httpSession.getAttribute(HIBERNATE_SESSION_KEY);

        try {

            // Start a new conversation or in the middle?
            if (disconnectedSession == null) {
                log.debug(">>> New conversation");
                log.debug("Opening Session, disabling automatic flushing");
                currentSession = sf.openSession();
                currentSession.setFlushMode(FlushMode.MANUAL);
            } else {
                log.debug("< Continuing conversation");
                currentSession = (org.hibernate.classic.Session) disconnectedSession;
            }

            log.debug("Binding the current Session");
            ManagedSessionContext.bind(currentSession);

            log.debug("Starting a database transaction");
            currentSession.beginTransaction();

            log.debug("Processing the event");
            chain.doFilter(request, response);

            log.debug("Unbinding Session after processing");
            currentSession = ManagedSessionContext.unbind(sf);

            // End or continue the long-running conversation?
            if (request.getAttribute(END_OF_CONVERSATION_FLAG) != null ||
                request.getParameter(END_OF_CONVERSATION_FLAG) != null) {

                log.debug("Flushing Session");
                currentSession.flush();

                log.debug("Committing the database transaction");
                currentSession.getTransaction().commit();

                log.debug("Closing the Session");
                currentSession.close();

                log.debug("Cleaning Session from HttpSession");
                httpSession.setAttribute(HIBERNATE_SESSION_KEY, null);

                log.debug("<<< End of conversation");

            } else {

                log.debug("Committing database transaction");
                currentSession.getTransaction().commit();

                log.debug("Storing Session in the HttpSession");
                httpSession.setAttribute(HIBERNATE_SESSION_KEY, currentSession);

                log.debug("> Returning to user in conversation");
            }

        } catch (StaleObjectStateException staleEx) {
            log.error("This interceptor does not implement optimistic concurrency control!");
            log.error("Your application will not work until you add compensation actions!");
            // Rollback, close everything, possibly compensate for any permanent changes
            // during the conversation, and finally restart business conversation. Maybe
            // give the user of the application a chance to merge some of his work with
            // fresh data... what you do here depends on your applications design.
            throw staleEx;
        } catch (Throwable ex) {
            // Rollback only
            try {
                if (sf.getCurrentSession().getTransaction().isActive()) {
                    log.debug("Trying to rollback database transaction after exception");
                    sf.getCurrentSession().getTransaction().rollback();
                }
            } catch (Throwable rbEx) {
                log.error("Could not rollback transaction after exception!", rbEx);
            } finally {
                log.error("Cleanup after exception!");

                // Cleanup
                log.debug("Unbinding Session after exception");
                currentSession = ManagedSessionContext.unbind(sf);

                log.debug("Closing Session after exception");
                currentSession.close();

                log.debug("Removing Session from HttpSession");
                httpSession.setAttribute(HIBERNATE_SESSION_KEY, null);

            }

            // Let others handle it... maybe another interceptor for exceptions?
            throw new ServletException(ex);
        }

    }

    public void init(FilterConfig filterConfig) throws ServletException {
        log.debug("Initializing filter...");
        log.debug("Obtaining SessionFactory from HibernateUtil");
        sf = HibernateUtil.getSessionFactory();
    }

    public void destroy() {}

}
```


Overlapping Code:
```
ic class HibernateSessionConversationFilter
implements Filter {
private static Log log = LogFactory.getLog(HibernateSessionConversationFilter.class);
private SessionFactory sf;
public static final String HIBERNATE_SESSION_KEY = "hibernateSession";
public static final String END_OF_CONVERSATION_FLAG = "endOfConversation";
public void doFilter(ServletRequest request,
ServletResponse response,
FilterChain chain)
throws IOException, ServletException {
org.hibernate.classic.Session currentSession;
// Try to get a Hibernate Session from the HttpSession
HttpSession httpSession =
((HttpServletRequest) request).getSession();
Session disconnectedSession =
(Session) httpSession.getAttribute(HIBERNATE_SESSION_KEY);
try {
// Start a new conversation or in the middle?
if (disconnectedSession == null) {
log.debug(">>> New conversation");
log.debug("Opening Session, disabling automatic flushing");
currentSession = sf.openSession();
currentSession.setFlushMode(FlushMode.MANUAL);
} else {
log.debug("< Continuing conversation");
currentSession = (org.hibernate.classic.Session) disconnectedSession;
}
log.debug("Binding the current Session");
ManagedSessionContext.bind(currentSession);
log.debug("Starting a database transaction");
currentSession.beginTransaction();
log.debug("Processing the event");
chain.doFilter(request, response);
log.debug("Unbinding Session after processing");
currentSession = ManagedSessionContext.unbind(sf);
// End or continue the long-running conversation?
if (request.getAttribute(END_OF_CONVERSATION_FLAG) != null ||
request.getParameter(END_OF_CONVERSATION_FLAG) != null) {
log.debug("Flushing Session");
currentSession.flush();
log.debug("Committing the database transaction");
currentSession.getTransaction().commit();
log.debug("Closing the Session");
currentSession.close();
log.debug("Cleaning Session from HttpSession");
httpSession.setAttribute(HIBERNATE_SESSION_KEY
```
<Overlap Ratio: 0.99581589958159>

---

--- 182 --
Question ID: 126271718cb7d9b24047f28783c27b2bb56be6b6
Original Code:
```
public class BlockSolidLayoutBlock extends Block {

    public static final PropertyEnum<EnumDyeColor> COLOR = PropertyEnum.create("color", EnumDyeColor.class);

    public BlockSolidLayoutBlock(){
        super(Material.GROUND);
        this.setDefaultState(this.blockState.getBaseState().withProperty(COLOR, EnumDyeColor.GRAY));

        setHardness((float) .04);
        setResistance(0);
        setLightOpacity(0);

        setUnlocalizedName(LayoutBlocks.MOD_ID + ".solid_layout_block");
        setRegistryName("solid_layout_block");
    }

    @Override
    public void onBlockHarvested(World worldIn, BlockPos pos, IBlockState state, EntityPlayer player){
        if(player.getHeldItemMainhand().getItem() == ModItems.itemPlacer){
            ItemStack stack = player.getHeldItemMainhand();
            NBTTagCompound nbt;

            if (stack.hasTagCompound()){
                nbt = stack.getTagCompound();
                if (nbt.hasKey("breaks")){
                    byte breaks = nbt.getByte("breaks");

                    switch (breaks){
                        case 0: //normal
                            break;

                        case 1: //break all connected layoutblocks
                            if (Config.enableAltBreakMode)
                                new Thread(new BlockBreakerThread(worldIn, player, pos, stack)).start();
                            break;
                    }
                }
                else {
                    nbt.setByte("breaks", (byte) 0);
                    stack.setTagCompound(nbt);
                }
            }
            else {
                nbt = new NBTTagCompound();
                nbt.setByte("places", (byte) 1);
                nbt.setByte("breaks", (byte) 0);
                stack.setTagCompound(nbt);
            }
        }
    }



    @Override
    @SideOnly(Side.CLIENT)
    public BlockRenderLayer getBlockLayer() {
        return BlockRenderLayer.CUTOUT;
    }

    public boolean doesSideBlockRendering(IBlockState state, IBlockAccess world, BlockPos pos, EnumFacing face) {
        return false;
    }


    public Item createItemBlock(){
        return new ItemBlock(this).setRegistryName(this.getRegistryName());
    }

    @Override
    @SuppressWarnings( "deprecation" )
    public int quantityDropped(Random random) { return 0; }
    @Override
    @SuppressWarnings( "deprecation" )
    protected boolean canSilkHarvest(){return false;}

    public void registerItemModel(){
        LayoutBlocks.proxy.registerItemRenderer(Item.getItemFromBlock(this), 0, "solid_layout_block");
    }




    //<editor-fold desc="Coloring stuff">
    @Override
    public boolean onBlockActivated(World worldIn, BlockPos pos, IBlockState state, EntityPlayer playerIn, EnumHand hand, EnumFacing side,
                                    float hitX, float hitY, float hitZ){
        ItemStack itemstack = playerIn.getHeldItem(hand);

        if(!itemstack.isEmpty()){
            if(DyeUtils.isDye(itemstack)){
                if(DyeUtils.colorFromStack(itemstack) != null){
                    worldIn.setBlockState(pos, state.withProperty(COLOR, DyeUtils.colorFromStack(itemstack).get()));
                    return true;
                }
            }
        }

        return false;
    }


    /**
     * Get the MapColor for this Block and the given BlockState
     */
    @SuppressWarnings( "deprecation" )
    public MapColor getMapColor(IBlockState state, IBlockAccess worldIn, BlockPos pos)
    {
        return MapColor.getBlockColor((EnumDyeColor)state.getValue(COLOR));
    }

    /**
     * Convert the given metadata into a BlockState for this Block
     */
    @SuppressWarnings( "deprecation" )
    public IBlockState getStateFromMeta(int meta)
    {
        return this.getDefaultState().withProperty(COLOR, EnumDyeColor.byMetadata(meta));
    }

    /**
     * Convert the BlockState into the correct metadata value
     */
    public int getMetaFromState(IBlockState state)
    {
        return ((EnumDyeColor)state.getValue(COLOR)).getMetadata();
    }

    protected BlockStateContainer createBlockState()
    {
        return new BlockStateContainer(this, new IProperty[] {COLOR});
    }
    //</editor-fold>
}
```


Overlapping Code:
```
utBlock extends Block {
public static final PropertyEnum<EnumDyeColor> COLOR = PropertyEnum.create("color", EnumDyeColor.class);
public BlockSolidLayoutBlock(){
super(Material.GROUND);
this.setDefaultState(this.blockState.getBaseState().withProperty(COLOR, EnumDyeColor.GRAY));
setHardness((float) .04);
setResistance(0);
setLightOpacity(0);
setUnlocalizedName(LayoutBlocks.MOD_ID + ".solid_layout_block");
setRegistryName("solid_layout_block");
}
@Override
public void onBlockHarvested(World worldIn, BlockPos pos, IBlockState state, EntityPlayer player){
if(player.getHeldItemMainhand().getItem() == ModItems.itemPlacer){
ItemStack stack = player.getHeldItemMainhand();
NBTTagCompound nbt;
if (stack.hasTagCompound()){
nbt = stack.getTagCompound();
if (nbt.hasKey("breaks")){
byte breaks = nbt.getByte("breaks");
switch (breaks){
case 0: //normal
break;
case 1: //break all connected layoutblocks
if (Config.enableAltBreakMode)
new Thread(new BlockBreakerThread(worldIn, player, pos, stack)).start();
break;
}
}
else {
nbt.setByte("breaks", (byte) 0);
stack.setTagCompound(nbt);
}
}
else {
nbt = new NBTTagCompound();
nbt.setByte("places", (byte) 1);
nbt.setByte("breaks", (byte) 0);
stack.setTagCompound(nbt);
}
}
}
@Override
@SideOnly(Side.CLIENT)
public BlockRenderLayer getBlockLayer() {
return BlockRenderLayer.CUTOUT;
}
public boolean doesSideBlockRendering(IBlockState state, IBlockAccess world, BlockPos pos, EnumFacing face) {
return false;
}
public Item createItemBlock(){
return new ItemBlock(this).setRegistryName(this.getRegistryName());
}
@Override
@SuppressWarnings( "deprecation" )
public int quantityDropped(Random random) { return 0; }
@Override
@SuppressWarnings( "deprecation" )
protected boolean canSilkHarvest(){return false;}
public void registerI
```
<Overlap Ratio: 0.9763085399449036>

---

--- 183 --
Question ID: bade8124eea566f93d411e155eb6253801699711
Original Code:
```
class AndroidSupportProject implements Project {

    static final String MARKER = "AndroidSupport";

    AndroidSupportProject(SourceUnit unit) {
    }

    /**
     * @return bootclasspath to compile Android base framework (should include libcore classes)
     */
    @Override
    public List<String> getBootClassPath() {
        return getLibraries(new String[]{
                "../../out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/classes.jar",
                "sdk/android-sdk.jar" // this entry is for testing purposes only, see sgtest/java-android-support-framework
        });
    }

    /**
     *
     * @return classpath to use (include framework's output, junit)
     */
    @Override
    public List<String> getClassPath() {
        return getLibraries(new String[]{
                "../../out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar"
        });
    }

    /**
     * @return source directories that contain files generated from .logtags and
     * directories that contain R.java and Manifest.java
     */
    @Override
    public List<String> getSourcePath() throws IOException {
        List<String> sourcePath = new ArrayList<>();
        // include java directories generated from .logtags and AIDL and the ones containing R.java
        File intermediate = new File("../../out/target/common/obj/JAVA_LIBRARIES");
        if (intermediate.isDirectory()) {
            Files.walkFileTree(intermediate.toPath(), new GeneratedDirectoriesCollector(sourcePath));
        }
        return sourcePath;
    }

    @Override
    public RawDependency getDepForJAR(Path jarFile) throws Exception {
        return null;
    }

    @Override
    public String getSourceCodeVersion() throws Exception {
        return DEFAULT_SOURCE_CODE_VERSION;
    }

    @Override
    public String getSourceCodeEncoding() throws ModelBuildingException, IOException {
        return null;
    }

    /**
     * Creates source unit from a given directory
     * @return source unit
     * @throws IOException
     */
    static SourceUnit createSourceUnit() throws IOException {


        final SourceUnit unit = new SourceUnit();
        unit.Type = SourceUnit.DEFAULT_TYPE;
        unit.Name = MARKER;
        unit.Dir = ".";
        unit.Files = new ArrayList<>();
        Files.walkFileTree(PathUtil.CWD, new SourceFilesCollector(unit.Files));
        unit.Data.Type = MARKER;
        return unit;
    }

    public static boolean is(SourceUnit unit) {
        return MARKER.equals(unit.Data.Type);
    }

    /**
     * @param files files to search for
     * @return list of existing files resolved relative to current working directory
     */
    private List<String> getLibraries(String files[]) {
        List<String> ret = Arrays.stream(files).filter(s -> new File(s).isFile()).collect(Collectors.toList());
        return ret.isEmpty() ? null : ret;
    }

    /**
     * Walks file tree and collects source directories which contain generated java files if there are any
     */
    private static final class GeneratedDirectoriesCollector extends SimpleFileVisitor<Path> {

        private Collection<String> dirs;

        GeneratedDirectoriesCollector(Collection<String> dirs) {
            this.dirs = dirs;
        }

        @Override
        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
            String name = dir.getFileName().toString();
            if (name.equals("src")) {
                // special case: src/java
                if (!new File(dir.toFile(), "java").isDirectory()) {
                    dirs.add(dir.toAbsolutePath().normalize().toString());
                    return FileVisitResult.SKIP_SUBTREE;
                }
            } else if (name.equals("java")) {
                dirs.add(dir.toAbsolutePath().normalize().toString());
                return FileVisitResult.SKIP_SUBTREE;
            }
            return FileVisitResult.CONTINUE;
        }
    }

    /**
     * Walks file tree and collects source files for Android Support.
     * Excludes tests, "customtabs", "previewsdk", and "percent" folders
     */
    private static final class SourceFilesCollector extends SimpleFileVisitor<Path> {

        private Collection<String> files;

        SourceFilesCollector(Collection<String> files) {
            this.files = files;
        }

        @Override
        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
            String name = dir.getFileName().toString();
            if (name.equals("test") ||
                    name.equals("tests") ||
                    name.equals("percent") ||
                    name.equals("jvm-tests") ||
                    name.equals("customtabs") ||
                    name.equals("androidTest") ||
                    name.equals("previewsdk") ||
                    name.equals("static") ||
                    name.equals("animated")) {
                return FileVisitResult.SKIP_SUBTREE;
            }
            return FileVisitResult.CONTINUE;
        }

        @Override
        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
            String filename = file.toString();
            if (filename.endsWith(".java")) {
                files.add(PathUtil.relativizeCwd(file));
            }
            return FileVisitResult.CONTINUE;
        }
    }

}
```


Overlapping Code:
```
oject implements Project {
static final String MARKER = "AndroidSupport";
AndroidSupportProject(SourceUnit unit) {
}
/**
* @return bootclasspath to compile Android base framework (should include libcore classes)
*/
@Override
public List<String> getBootClassPath() {
return getLibraries(new String[]{
"../../out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/classes.jar",
"sdk/android-sdk.jar" // this entry is for testing purposes only, see sgtest/java-android-support-framework
});
}
/**
*
* @return classpath to use (include framework's output, junit)
*/
@Override
public List<String> getClassPath() {
return getLibraries(new String[]{
"../../out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar"
});
}
/**
* @return source directories that contain files generated from .logtags and
* directories that contain R.java and Manifest.java
*/
@Override
public List<String> getSourcePath() throws IOException {
List<String> sourcePath = new ArrayList<>();
// include java directories generated from .logtags and AIDL and the ones containing R.java
File intermediate = new File("../../out/target/common/obj/JAVA_LIBRARIES");
if (intermediate.isDirectory()) {
Files.walkFileTree(intermediate.toPath(), new GeneratedDirectoriesCollector(sourcePath));
}
return sourcePath;
}
@Override
public RawDependency getDepForJAR(Path jarFile) throws Exception {
return null;
}
@Override
public String getSourceCodeVersion() throws Exception {
return DEFAULT_SOURCE_CODE_VERSION;
}
@Override
public String getSourceCodeEncoding() throws ModelBuildingException, IOException {
return null;
}
/**
* Creates source unit from a given directory
* @return source unit
* @throws IOException
*/
static SourceUnit createSourceUnit() throws IOException {
final SourceUnit unit = new SourceUnit();
unit.Type = SourceUnit.DEFAULT_TYPE;
unit.Name = MARKER;
unit.Dir = ".";
unit.Files = new ArrayList<>();
Files.walkFileTree(PathUtil.CWD, new SourceFilesCollector(unit.Files));
unit.Data.Type = MARKER;
return unit;
}
public static boolean is(SourceUnit 
```
<Overlap Ratio: 0.9860509860509861>

---

--- 184 --
Question ID: 58ae8f016e5126730810de741270916b2d72845d
Original Code:
```
public class Matches implements FileEvents {
    private enum MatchType {
        Practice,
        Qualification,
        Semifinal,
        Final;
        
        public static MatchType parse(int number) {
            switch (number) {
                case 0:
                    return Practice;
                case 1:
                    return Qualification;
                case 2:
                    return Semifinal;
                case 3:
                    return Final;
            }
            return Qualification;
        }
    }
    
    private final File file;
    
    private final JSONArray matchArray;
    
    public Matches(File _file) {
        file = _file;
        matchArray = new JSONArray();
        if(file.exists()) {
            parseFile();
        }
        
        try {
            App.app.dirWatcher.registerFile(this);
        } catch (IOException ex) {
            Logger.getLogger(Matches.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    public JSONArray getMatchList() {
        return matchArray;
    }
    
    public final void parseFile() {
        String row;
        int i = 0;
        try {
            FileReader fileReader = new FileReader(file);
            BufferedReader bufferedReader = new BufferedReader(fileReader);
            
            while((row = bufferedReader.readLine()) != null) {
                parseRow(i, row);
                i++;
            }
            
            bufferedReader.close();
            
            App.app.log("Match List", matchArray.toJSONString());
            
        } catch (FileNotFoundException ex) {
            Logger.getLogger(TeamList.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(TeamList.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    private void parseRow(int i, String row) {
        int c = 0;
        String cols[] = row.split("\\|",-1);
        int division = Integer.parseInt(cols[c++]);
        MatchType matchType = MatchType.parse(Integer.parseInt(cols[c++]));
        int number = Integer.parseInt(cols[c++]);
        int matchStartTimeCnt = Integer.parseInt(cols[c++]);
        
        long matchStartTime = 0;
        
        for(int k = 0; k<matchStartTimeCnt; k++) {
            matchStartTime = Long.parseLong(cols[c++]);
        }
        
        
        c++;// dummy = cols[4]
        
        int[] red_team = new int[3];        
        red_team[0] = Integer.parseInt(cols[c++]);
        red_team[1] = Integer.parseInt(cols[c++]);
        red_team[2] = Integer.parseInt(cols[c++]);
        int[] blue_team = new int[3];
        blue_team[0] = Integer.parseInt(cols[c++]);
        blue_team[1] = Integer.parseInt(cols[c++]);
        blue_team[2] = Integer.parseInt(cols[c++]);
        c++;// int red1_state = cols[11] - 0: normal, 1: noshow, 2: DQed
        c++;// int red2_state = cols[12] //
        c++;// int red3_state = cols[13] //
        c++;// bool red1_yellow_card = cols[14]
        c++;// bool red2_yellow_card = cols[15]
        c++;// bool red3_yellow_card = cols[16]
        c++;// int blue1_state = cols[17]
        c++;// int blue2_state = cols[18]
        c++;// int blue3_state = cols[19]
        c++;// int blue1_yellow = cols[20]
        c++;// int blue2_yellow = cols[21]
        c++;// int blue3_yellow = cols[22]
        boolean[] red_surrogate = new boolean[3];
        red_surrogate[0] = "1".equals(cols[c++]);
        red_surrogate[1] = "1".equals(cols[c++]);
        red_surrogate[2] = "1".equals(cols[c++]);
        boolean[] blue_surrogate = new boolean[3];
        blue_surrogate[0] = "1".equals(cols[c++]);
        blue_surrogate[1] = "1".equals(cols[c++]);
        blue_surrogate[2] = "1".equals(cols[c++]);
        boolean saved = "1".equals(cols[c++]);
        
        int red_autoJewlesRemaining = Integer.parseInt(cols[c++]);
        int red_autoGlyphsInCryptobox = Integer.parseInt(cols[c++]);
        int red_autoCryptoboxKeys = Integer.parseInt(cols[c++]);
        int red_autoRobotParked = Integer.parseInt(cols[c++]);
        int red_teleGlyphsScored = Integer.parseInt(cols[c++]);
        int red_teleCompletedRows = Integer.parseInt(cols[c++]);
        int red_teleCompletedColumns = Integer.parseInt(cols[c++]);
        int red_teleCompletedCyphers = Integer.parseInt(cols[c++]);
        int red_endgRelicsInZone1 = Integer.parseInt(cols[c++]);
        int red_endgRelicsInZone2 = Integer.parseInt(cols[c++]);
        int red_endgRelicsInZone3 = Integer.parseInt(cols[c++]);
        int red_endgRelicsUpright = Integer.parseInt(cols[c++]);
        int red_endgRobotsBalanced = Integer.parseInt(cols[c++]);
        int red_minorPenalties = Integer.parseInt(cols[c++]);
        int red_majorPenalties = Integer.parseInt(cols[c++]);
        int red_minorPenaltiesAwarded = Integer.parseInt(cols[c++]);
        int red_majorPenalitesAwarded = Integer.parseInt(cols[c++]);
        
        int blue_autoJewlesRemaining = Integer.parseInt(cols[c++]);
        int blue_autoGlyphsInCryptobox = Integer.parseInt(cols[c++]);
        int blue_autoCryptoboxKeys = Integer.parseInt(cols[c++]);
        int blue_autoRobotParked = Integer.parseInt(cols[c++]);
        int blue_teleGlyphsScored = Integer.parseInt(cols[c++]);
        int blue_teleCompletedRows = Integer.parseInt(cols[c++]);
        int blue_teleCompletedColumns = Integer.parseInt(cols[c++]);
        int blue_teleCompletedCyphers = Integer.parseInt(cols[c++]);
        int blue_endgRelicsInZone1 = Integer.parseInt(cols[c++]);
        int blue_endgRelicsInZone2 = Integer.parseInt(cols[c++]);
        int blue_endgRelicsInZone3 = Integer.parseInt(cols[c++]);
        int blue_endgRelicsUpright = Integer.parseInt(cols[c++]);
        int blue_endgRobotsBalanced = Integer.parseInt(cols[c++]);
        int blue_minorPenalties = Integer.parseInt(cols[c++]);
        int blue_majorPenalties = Integer.parseInt(cols[c++]);
        int blue_minorPenaltiesAwarded = Integer.parseInt(cols[c++]);
        int blue_majorPenalitesAwarded = Integer.parseInt(cols[c++]);
        
        
        int red_autoBonus = 0;
        int red_auto = 30 * red_autoJewlesRemaining + 15 * red_autoGlyphsInCryptobox +
                30 * red_autoCryptoboxKeys + 10 * red_autoRobotParked;
        int red_endGame = 10 * red_endgRelicsInZone1 + 20 * red_endgRelicsInZone2 +
                40 * red_endgRelicsInZone3 + 15 * red_endgRelicsUpright +
                20 * red_endgRobotsBalanced;
        int red_teleop = 2 * red_teleGlyphsScored + 10 * red_teleCompletedRows +
                20 * red_teleCompletedColumns + 30 * red_teleCompletedCyphers;
        int blue_penalties = 10 * red_minorPenalties + 40 * red_majorPenalties;
        
        
        int blue_autoBonus = 0;
        int blue_auto = 30 * blue_autoJewlesRemaining + 15 * blue_autoGlyphsInCryptobox +
                30 * blue_autoCryptoboxKeys + 10 * blue_autoRobotParked;
        int blue_endGame = 10 * blue_endgRelicsInZone1 + 20 * blue_endgRelicsInZone2 +
                40 * blue_endgRelicsInZone3 + 15 * blue_endgRelicsUpright +
                20 * blue_endgRobotsBalanced;
        int blue_teleop = 2 * blue_teleGlyphsScored + 10 * blue_teleCompletedRows +
                20 * blue_teleCompletedColumns + 30 * blue_teleCompletedCyphers;
        int red_penalties = 10 * blue_minorPenalties + 40 * blue_majorPenalties;
        
        JSONObject match = new JSONObject();
        JSONObject red = new JSONObject();
        JSONObject blue = new JSONObject();
        
        JSONArray red_teams = new JSONArray();
        int j;
        for(j=0;j<3;j++) {
            JSONObject t = new JSONObject();
            if(red_team[j] != 0) { 
                t.put("number", red_team[j]);
                t.put("surrogate", red_surrogate[j]);
                red_teams.add(t);
            }
        }
        red.put("teams", red_teams);
        
        
        JSONArray blue_teams = new JSONArray();
        for(j=0;j<3;j++) {
            JSONObject t = new JSONObject();
            if(blue_team[j] != 0) { 
                t.put("number", blue_team[j]);
                t.put("surrogate", blue_surrogate[j]);
                blue_teams.add(t);
            }
        }
        blue.put("teams", blue_teams);

        
        
        
        
        if(saved) {
            red.put("auto_bonus", red_autoBonus);
            red.put("auto", red_auto);
            red.put("teleop", red_teleop);
            red.put("endg", red_endGame);
            red.put("penalties", red_penalties);
            
            blue.put("auto_bonus", blue_autoBonus);
            blue.put("auto", blue_auto);
            blue.put("teleop", blue_teleop);
            blue.put("endg", blue_endGame);
            blue.put("penalties", blue_penalties);
        }
        
        match.put("start", matchStartTime);
        
        match.put("number", number);
        match.put("division", division);
        match.put("type", matchType.toString());
        match.put("red", red);
        match.put("blue", blue);
        
        if(i < matchArray.size())
            matchArray.set(i, match);
        else
            matchArray.add(i, match);
        App.app.log("Parsed Match", match.toJSONString());
    }

    @Override
    public void onFileCreate() {
        parseFile();
    }

    @Override
    public void onFileDelete() {
        
    }

    @Override
    public void onFileModify() {
        parseFile();
    }
    
    @Override
    public File getFile() {
        return file;
    }
}
```


Overlapping Code:
```
ts FileEvents {
private enum MatchType {
Practice,
Qualification,
Semifinal,
Final;

public static MatchType parse(int number) {
switch (number) {
case 0:
return Practice;
case 1:
return Qualification;
case 2:
return Semifinal;
case 3:
return Final;
}
return Qualification;
}
}

private final File file;

private final JSONArray matchArray;

public Matches(File _file) {
file = _file;
matchArray = new JSONArray();
if(file.exists()) {
parseFile();
}

try {
App.app.dirWatcher.registerFile(this);
} catch (IOException ex) {
Logger.getLogger(Matches.class.getName()).log(Level.SEVERE, null, ex);
}
}

public JSONArray getMatchList() {
return matchArray;
}

public final void parseFile() {
String row;
int i = 0;
try {
FileReader fileReader = new FileReader(file);
BufferedReader bufferedReader = new BufferedReader(fileReader);

while((row = bufferedReader.readLine()) != null) {
parseRow(i, row);
i++;
}

bufferedReader.close();

App.app.log("Match List", matchArray.toJSONString());

} catch (FileNotFoundException ex) {
Logger.getLogger(TeamList.class.getName()).log(Level.SEVERE, null, ex);
} catch (IOException ex) {
Logger.getLogger(TeamList.class.getName()).log(Level.SEVERE, null, ex);
}
}

private void parseRow(int i, String row) {
int c = 0;
String cols[] = row.split("\\|",-1);
int division = Integer.parseInt(cols[c++]);
MatchType matchType = MatchType.parse(Integer.parseInt(cols[c++]));
int number = Integer.parseInt(cols[c++]);
int matchStartTimeCnt = Integer.parseInt(cols[c++]);

long matchStartTime = 0;

for(int k = 0; k<matchStartTimeCnt; k++) {
matchStartTime = Long.parseLong(col
```
<Overlap Ratio: 0.966183574879227>

---

--- 185 --
Question ID: a3fd86e4939c7d81c4d19871b4946f3105ad47aa
Original Code:
```
public class PlayerHelper {

    private static final String PLAYER_INVENTORY_PRIMARY_KEY = "primary";
    private static final String PLAYER_INVENTORY_ARMOR_KEY = "armor";

    private static Method getOnlinePlayers;
    public static boolean newOnlinePlayersMethod = false;

    static {
        try {
            getOnlinePlayers = Bukkit.class.getMethod("getOnlinePlayers");
            if (getOnlinePlayers.getReturnType() == Collection.class) {
                newOnlinePlayersMethod = true;
            }
        } catch (NoSuchMethodException ex) {
            SteelCore.logSevere("Failed to get getOnlinePlayers method!");
            ex.printStackTrace();
        }
    }

    /**
     * Pushes the inventory of the given player into persistent storage.
     *
     * @param player The {@link Player} to push the inventory of
     * @throws IOException If an exception occurs while saving into persistent
     *     storage
     */
    @SuppressWarnings("deprecation")
    public static void pushInventory(Player player) throws IOException {
        PlayerInventory inv = player.getInventory();
        // the file to store the inventory in
        File storage = new File(SteelDataFiles.PLAYER_INVENTORY_DIR.getFile(), player.getUniqueId() + ".yml");
        if (storage.exists()) { // verify file isn't already present on disk (meaning it wasn't popped the last time)
            SteelCore.logVerbose("Inventory push requested for player " + player.getName() + ", but "
                    + "inventory was already present in persistent storage. Popping stored inventory first.");
            try {
                popInventory(player);
            } catch (InvalidConfigurationException ex) {
                throw new IOException(ex); // this is probably a bad thing of me to do but it's for a fringe case anyway
            }
        }
        YamlConfiguration yaml = new YamlConfiguration();
        yaml.set(PLAYER_INVENTORY_PRIMARY_KEY, InventoryHelper.serializeInventory(inv));
        yaml.set(PLAYER_INVENTORY_ARMOR_KEY, InventoryHelper.serializeInventory(inv.getArmorContents()));
        yaml.save(storage); // save to disk
        inv.clear(); // clear the inventory to complete the push to disk
        inv.setArmorContents(new ItemStack[inv.getArmorContents().length]);
        player.updateInventory();
    }

    /**
     * Pops the inventory of the given player from persistent storage.
     *
     * @param player The {@link Player} to pop the inventory of
     * @throws IllegalArgumentException If the inventory of the given
     *     {@link Player} is not present in persistent storage
     * @throws IOException If an exception occurs while loading from persistent
     *     storage
     * @throws InvalidConfigurationException If the stored inventory is invalid
     */
    //TODO: generalize some of this code for use with rollback storage
    @SuppressWarnings("deprecation")
    public static void popInventory(Player player) throws IllegalArgumentException, IOException,
            InvalidConfigurationException {
        // the file to load the inventory from
        File storage = new File(SteelDataFiles.PLAYER_INVENTORY_DIR.getFile(), player.getUniqueId() + ".yml");
        if (!storage.exists()) { // verify file is present on disk
            throw new IllegalArgumentException("Inventory pop requested for player " + player.getName() + ", but "
                    + "inventory was not present in persistent storage!");
        }
        YamlConfiguration yaml = new YamlConfiguration();
        yaml.load(storage); // load from disk
        if (!yaml.contains(PLAYER_INVENTORY_PRIMARY_KEY)) {
            throw new InvalidConfigurationException("Stored inventory is missing required section \""
                    + PLAYER_INVENTORY_PRIMARY_KEY + "\"");
        }
        player.getInventory().clear();
        player.getInventory().setContents(
                InventoryHelper.deserializeInventory(yaml.getConfigurationSection(PLAYER_INVENTORY_PRIMARY_KEY))
        );
        if (yaml.contains(PLAYER_INVENTORY_ARMOR_KEY)) {
            player.getInventory().setArmorContents(
                    InventoryHelper.deserializeInventory(yaml.getConfigurationSection(PLAYER_INVENTORY_ARMOR_KEY))
            );
        }
        player.updateInventory();
        //noinspection ResultOfMethodCallIgnored
        storage.delete();
    }

    /**
     * Stores the given {@link Player}'s current location to persistent storage.
     *
     * @param player The {@link Player} to store the location of
     * @throws InvalidConfigurationException If an exception occurs while saving
     *     to disk
     * @throws IOException If an exception occurs while saving to disk
     */
    public static void storeLocation(Player player) throws InvalidConfigurationException, IOException {
        CommonPlayerHelper.storeLocation(player.getUniqueId(),
                LocationHelper.convertLocation(player.getLocation()));
    }

    /**
     * Pops the given {@link Player}'s stored location from persistent storage,
     * teleporting them to it.
     *
     * @param player The {@link Player} to load the location of and teleport
     * @throws IllegalArgumentException If the player's location is not present
     *     in the persistent store or if an error occurs during deserialization
     * @throws InvalidConfigurationException If an exception occurs while
     *     loading from disk
     * @throws IOException If an exception occurs while saving to disk
     */
    public static void popLocation(Player player)
            throws IllegalArgumentException, InvalidConfigurationException, IOException {
        Optional<Location3D> retLoc = CommonPlayerHelper.getReturnLocation(player.getUniqueId());
        if (!retLoc.isPresent()) {
            throw new IllegalArgumentException("Location of player " + player.getName()
                    + " not present in persistent store");
        }
        player.teleport(LocationHelper.convertLocation(retLoc.get()));
    }

    /**
     * Version-independent getOnlinePlayers() method.
     *
     * @return a list of online players
     */
    @SuppressWarnings("unchecked")
    public static Collection<? extends Player> getOnlinePlayers() {
        try {
            if (newOnlinePlayersMethod) {
                return (Collection<? extends Player>) getOnlinePlayers.invoke(null);
            } else {
                return Arrays.asList((Player[]) getOnlinePlayers.invoke(null));
            }
        } catch (IllegalAccessException | InvocationTargetException ex) {
            throw new RuntimeException("Failed to invoke getOnlinePlayers method!", ex);
        }
    }

}
```


Overlapping Code:
```
PlayerHelper {
private static final String PLAYER_INVENTORY_PRIMARY_KEY = "primary";
private static final String PLAYER_INVENTORY_ARMOR_KEY = "armor";
private static Method getOnlinePlayers;
public static boolean newOnlinePlayersMethod = false;
static {
try {
getOnlinePlayers = Bukkit.class.getMethod("getOnlinePlayers");
if (getOnlinePlayers.getReturnType() == Collection.class) {
newOnlinePlayersMethod = true;
}
} catch (NoSuchMethodException ex) {
SteelCore.logSevere("Failed to get getOnlinePlayers method!");
ex.printStackTrace();
}
}
/**
* Pushes the inventory of the given player into persistent storage.
*
* @param player The {@link Player} to push the inventory of
* @throws IOException If an exception occurs while saving into persistent
* storage
*/
@SuppressWarnings("deprecation")
public static void pushInventory(Player player) throws IOException {
PlayerInventory inv = player.getInventory();
// the file to store the inventory in
File storage = new File(SteelDataFiles.PLAYER_INVENTORY_DIR.getFile(), player.getUniqueId() + ".yml");
if (storage.exists()) { // verify file isn't already present on disk (meaning it wasn't popped the last time)
SteelCore.logVerbose("Inventory push requested for player " + player.getName() + ", but "
+ "inventory was already present in persistent storage. Popping stored inventory first.");
try {
popInventory(player);
} catch (InvalidConfigurationException ex) {
throw new IOException(ex); // this is probably a bad thing of me to do but it's for a fringe case anyway
}
}
YamlConfiguration yaml = new YamlConfiguration();
yaml.set(PLAYER_INVENTORY_PRIMARY_KEY, InventoryHelper.serializeInventory(inv));
yaml.set(PLAYER_INVENTORY_ARMOR_KEY, InventoryHelper.serializeInventory(inv.getArmorContents()));
yaml.save(storage); // save to disk
inv.clear(); // clear the inventory to complete the push to disk
inv.setArmorContents(new ItemStack[inv.getArmorContents().length]);
player.updateInventory();
}
/**
* Pops the inventory of the given player from persistent storage.
*
* @param player The {@link Player} to pop the inventory
```
<Overlap Ratio: 0.9890476190476191>

---

--- 186 --
Question ID: 52e2a64bbe42dbbf2abcec5408ef604a3081114b
Original Code:
```
@edu.umd.cs.findbugs.annotations.SuppressWarnings(
        value="RV_RETURN_VALUE_IGNORED", 
        justification="Designed to ignore.")

public class DynamicFamilyIT extends BaseHBaseManagedTimeTableReuseIT {
    private static final String WEB_STATS = generateRandomString();
    private static final String WEB_STATS_SCHEMA_NAME = "";
    private static final byte[] A_CF = Bytes.toBytes(SchemaUtil.normalizeIdentifier("A"));
    private static final byte[] B_CF = Bytes.toBytes(SchemaUtil.normalizeIdentifier("B"));
    private static final String USER_ID1 = "u0001";
    private static final String USER_ID2 = "u0002";
    private static final String USER_ID3 = "u0003";
    private static final byte[] USER_ID1_BYTES = Bytes.toBytes(USER_ID1);
    private static final byte[] USER_ID2_BYTES = Bytes.toBytes(USER_ID2);
    private static final byte[] USER_ID3_BYTES = Bytes.toBytes(USER_ID3);
    
    private static final String MAX_CLICK_COUNT_PREFIX = SchemaUtil.normalizeIdentifier("MaxClickCount_");
    private static final byte[] MAX_CLICK_COUNT_DYNCOL_PREFIX = Bytes.toBytes(MAX_CLICK_COUNT_PREFIX);
    private static final Integer ENTRY1_CLICK_COUNT = 12;
    private static final Integer ENTRY2_CLICK_COUNT = 34;
    private static final Integer ENTRY3_CLICK_COUNT = 56;
    
    private static final String LAST_LOGIN_TIME_PREFIX = SchemaUtil.normalizeIdentifier("LastLoginTime_");
    private static final byte[] LAST_LOGIN_TIME_DYNCOL_PREFIX = Bytes.toBytes(LAST_LOGIN_TIME_PREFIX);
    
    private static final Time ENTRY1_USER_ID1_LOGIN_TIME = new Time(System.currentTimeMillis()+60000);
    private static final Time ENTRY1_USER_ID2_LOGIN_TIME = new Time(System.currentTimeMillis()+120000);
    
    private static final Time ENTRY2_USER_ID2_LOGIN_TIME = new Time(System.currentTimeMillis()+180000);
    private static final Time ENTRY2_USER_ID3_LOGIN_TIME = new Time(System.currentTimeMillis()+240000);
    
    private static final Time ENTRY3_USER_ID1_LOGIN_TIME = new Time(System.currentTimeMillis()+300000);
    private static final Time ENTRY3_USER_ID2_LOGIN_TIME = new Time(System.currentTimeMillis()+360000);
    private static final Time ENTRY3_USER_ID3_LOGIN_TIME = new Time(System.currentTimeMillis()+420000);

    @Before
    public void doBeforeTestSetup() throws Exception {
        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);
        Connection conn = DriverManager.getConnection(getUrl(), props);
        String ddl = "create table if not exists  " + WEB_STATS
                + "   (entry varchar not null primary key,"
                + "    a.dummy varchar," 
                + "    b.dummy varchar)";
        conn.createStatement().execute(ddl);
        conn.close();
        initTableValues();
    }

    @SuppressWarnings("deprecation")
    private static void initTableValues() throws Exception {
        ConnectionQueryServices services = driver.getConnectionQueryServices(getUrl(), PropertiesUtil.deepCopy(TEST_PROPERTIES));
        HTableInterface hTable = services.getTable(SchemaUtil.getTableNameAsBytes(WEB_STATS_SCHEMA_NAME,WEB_STATS));
        try {
            // Insert rows using standard HBase mechanism with standard HBase "types"
            Put put;
            List<Row> mutations = new ArrayList<Row>();
            put = new Put(Bytes.toBytes("entry1"));
            put.add(A_CF, QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES, ByteUtil.EMPTY_BYTE_ARRAY);
            put.add(A_CF, ByteUtil.concat(MAX_CLICK_COUNT_DYNCOL_PREFIX, USER_ID2_BYTES), PInteger.INSTANCE.toBytes(ENTRY1_CLICK_COUNT));
            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID1_BYTES), PTime.INSTANCE.toBytes(ENTRY1_USER_ID1_LOGIN_TIME));
            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID2_BYTES), PTime.INSTANCE.toBytes(ENTRY1_USER_ID2_LOGIN_TIME));
            mutations.add(put);
            
            put = new Put(Bytes.toBytes("entry2"));
            put.add(A_CF, QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES, ByteUtil.EMPTY_BYTE_ARRAY);
            put.add(A_CF, ByteUtil.concat(MAX_CLICK_COUNT_DYNCOL_PREFIX, USER_ID3_BYTES), PInteger.INSTANCE.toBytes(ENTRY2_CLICK_COUNT));
            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID2_BYTES), PTime.INSTANCE.toBytes(ENTRY2_USER_ID2_LOGIN_TIME));
            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID3_BYTES), PTime.INSTANCE.toBytes(ENTRY2_USER_ID3_LOGIN_TIME));
            mutations.add(put);
            
            put = new Put(Bytes.toBytes("entry3"));
            put.add(A_CF, QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES, ByteUtil.EMPTY_BYTE_ARRAY);
            put.add(A_CF, ByteUtil.concat(MAX_CLICK_COUNT_DYNCOL_PREFIX, USER_ID1_BYTES), PInteger.INSTANCE.toBytes(ENTRY3_CLICK_COUNT));
            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID1_BYTES), PTime.INSTANCE.toBytes(ENTRY3_USER_ID1_LOGIN_TIME));
            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID2_BYTES), PTime.INSTANCE.toBytes(ENTRY3_USER_ID2_LOGIN_TIME));
            put.add(B_CF, ByteUtil.concat(LAST_LOGIN_TIME_DYNCOL_PREFIX, USER_ID3_BYTES), PTime.INSTANCE.toBytes(ENTRY3_USER_ID3_LOGIN_TIME));
            mutations.add(put);

            hTable.batch(mutations);

        } finally {
            hTable.close();
        }
    }

    private static Pair<String,Integer> getMaxClickCountValue(ResultSet rs) throws SQLException {
        ResultSetMetaData rsmd = rs.getMetaData();
        for (int i = 1; i <= rsmd.getColumnCount(); i++) {
            String colName = rsmd.getColumnName(i);
            if (colName.startsWith(MAX_CLICK_COUNT_PREFIX)) {
                String userId = colName.substring(MAX_CLICK_COUNT_PREFIX.length());
                Integer clickCount = rs.getInt(colName);
                return new Pair<String,Integer>(userId,clickCount);
            }
        }
        return null;
    }
    
    private static Time getLastLoginTimeValue(ResultSet rs, String userId) throws SQLException {
        String colName = LAST_LOGIN_TIME_PREFIX + userId;
        try {
            return rs.getTime(colName);
        } catch (SQLException e) {
            // Ignore COLUMN_NOT_FOUND error b/c it means that this user didn't login
            if (e.getErrorCode() == SQLExceptionCode.COLUMN_NOT_FOUND.getErrorCode()) {
                return null;
            }
            throw e;
        }
    }
    
    /**
     * Should project all of column family A columns qualifiers. Should also automatically be case insensitive,
     * since it is a wildcard.
     * @throws Exception
     */
    // FIXME @Test
    public void testGetAllDynColsInFamily() throws Exception {
        String query = "SELECT A.* FROM " + WEB_STATS + " WHERE entry='entry1'";
        String url = getUrl() + ";";
        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);
        Connection conn = DriverManager.getConnection(url, props);
        try {
            PreparedStatement statement = conn.prepareStatement(query);
            ResultSet rs = statement.executeQuery();
            assertTrue(rs.next());
            Pair<String,Integer> maxClickCountUserIdAndValue = getMaxClickCountValue(rs);
            // This fails for two reasons: 1) all column qualifiers in column family A
            // are not returned in the result, and 2) the dynamic columns are not available
            // through ResultSetMetaData.
            assertEquals(USER_ID2_BYTES,maxClickCountUserIdAndValue.getFirst());
            assertEquals(ENTRY1_CLICK_COUNT,maxClickCountUserIdAndValue.getSecond());
            
            assertFalse(rs.next());
        } finally {
            conn.close();
        }
    }

    /**
     * Should project all of column family A columns qualifiers. Should also automatically be case insensitive,
     * since it is a wildcard.
     * @throws Exception
     */
    // FIXME @Test
    public void testGetAllDynCols() throws Exception {
        String query = "SELECT * FROM " + WEB_STATS + "WHERE entry='entry1'";
        String url = getUrl() + ";";
        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);
        Connection conn = DriverManager.getConnection(url, props);
        try {
            PreparedStatement statement = conn.prepareStatement(query);
            ResultSet rs = statement.executeQuery();
            assertTrue(rs.next());
            Pair<String,Integer> maxClickCountUserIdAndValue = getMaxClickCountValue(rs);
            // This fails because the dynamic columns are not available through ResultSetMetaData
            assertEquals(USER_ID2_BYTES,maxClickCountUserIdAndValue.getFirst());
            assertEquals(ENTRY1_CLICK_COUNT,maxClickCountUserIdAndValue.getSecond());
            
            assertFalse(rs.next());
        } finally {
            conn.close();
        }
    }

    /**
     * Since the dynamic columns are not in double quotes, the column name is normalized by being upper cased.
     * In this case, since USER_ID is case sensitive, it will not find the columns
     */
    @Test
    public void testGetCaseInsensitiveDynCol() throws Exception {
        String query = "SELECT B.* FROM "+ WEB_STATS+ "(" +
                "B." + LAST_LOGIN_TIME_PREFIX + USER_ID2 + " TIME," + 
                "B." + LAST_LOGIN_TIME_PREFIX + USER_ID3 + " TIME) WHERE entry='entry2'";
        String url = getUrl() + ";";
        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);
        Connection conn = DriverManager.getConnection(url, props);
        try {
            PreparedStatement statement = conn.prepareStatement(query);
            ResultSet rs = statement.executeQuery();
            assertTrue(rs.next());
            assertEquals(null, getLastLoginTimeValue(rs, USER_ID2));
            assertEquals(null, getLastLoginTimeValue(rs, USER_ID3));
            assertEquals(null, getLastLoginTimeValue(rs, USER_ID1));
            assertFalse(rs.next());
        } finally {
            conn.close();
        }
    }

    /**
     * Since dynamic columns are not in double quotes, the column name is not normalized, but instead
     * is left as is. This should succeed, since the user ID case is matched
     */
    // FIXME @Test
    public void testGetCaseSensitiveDynCol() throws Exception {
        String query = "SELECT B.* FROM "+WEB_STATS +"(" +
                "B.\"" + LAST_LOGIN_TIME_PREFIX + USER_ID2 + "\"" + " TIME," + 
                "B.\"" + LAST_LOGIN_TIME_PREFIX + USER_ID3 + "\"" + " TIME) WHERE entry='entry2'";
        String url = getUrl() + ";";
        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);
        Connection conn = DriverManager.getConnection(url, props);
        try {
            PreparedStatement statement = conn.prepareStatement(query);
            ResultSet rs = statement.executeQuery();
            assertTrue(rs.next());
            assertEquals(ENTRY2_USER_ID2_LOGIN_TIME, getLastLoginTimeValue(rs, USER_ID2));
            assertEquals(ENTRY2_USER_ID3_LOGIN_TIME, getLastLoginTimeValue(rs, USER_ID3));
            assertEquals(null, getLastLoginTimeValue(rs, Bytes.toString(USER_ID1_BYTES)));

            assertFalse(rs.next());
        } finally {
            conn.close();
        }
    }

    /**
     * We have to make sure that static columns that are projected are in the expected order.
     * Dynamic columns should be projected as well, but we cannot guarantee their order.
     * @throws Exception
     */
    // FIXME @Test
    public void testProjectStaticAndDynamic() throws Exception {
        String query = "SELECT ENTRY, A.DUMMY, B.DUMMY, A.*,B.* FROM "+ WEB_STATS +" WHERE entry='entry3'";
        String url = getUrl() + ";";
        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);
        Connection conn = DriverManager.getConnection(url, props);
        try {
            PreparedStatement statement = conn.prepareStatement(query);
            ResultSet rs = statement.executeQuery();
            assertTrue(rs.next());
            assertEquals("entry3", rs.getString(1));
            assertEquals(null, rs.getString(2));
            assertEquals(null, rs.getString(3));
            Pair<String,Integer> clickCountUserIdAndValue = getMaxClickCountValue(rs);
            assertEquals(USER_ID1_BYTES,clickCountUserIdAndValue.getFirst());
            assertEquals(ENTRY3_CLICK_COUNT,clickCountUserIdAndValue.getSecond());
            
            assertEquals(ENTRY3_USER_ID1_LOGIN_TIME, getLastLoginTimeValue(rs, Bytes.toString(USER_ID1_BYTES)));
            assertEquals(ENTRY3_USER_ID2_LOGIN_TIME, getLastLoginTimeValue(rs, Bytes.toString(USER_ID2_BYTES)));
            assertEquals(ENTRY3_USER_ID3_LOGIN_TIME, getLastLoginTimeValue(rs, Bytes.toString(USER_ID3_BYTES)));

            assertFalse(rs.next());
        } finally {
            conn.close();
        }
    }

    @Test(expected = ColumnFamilyNotFoundException.class)
    public void testDynamicFamilyException() throws Exception {
        String query = "SELECT C.* FROM " + WEB_STATS;
        String url = getUrl() + ";";
        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);
        Connection conn = DriverManager.getConnection(url, props);
        try {
            PreparedStatement statement = conn.prepareStatement(query);
            statement.executeQuery();
        } finally {
            conn.close();
        }
    }

    @Test(expected = PhoenixParserException.class)
    public void testDynamicFamilyFunctionException() throws Exception {
        String query = "SELECT count(C.*) FROM " + WEB_STATS;
        String url = getUrl() + ";";
        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);
        Connection conn = DriverManager.getConnection(url, props);
        try {
            PreparedStatement statement = conn.prepareStatement(query);
            statement.executeQuery();
        } finally {
            conn.close();
        }
    }

    @Test
    public void testSelectEntireColumnFamily() throws Exception {
        ResultSet rs;
        Connection conn = DriverManager.getConnection(getUrl());
        conn.setAutoCommit(true);
        String tableName = generateRandomString();
        conn.createStatement().execute("CREATE TABLE " + tableName
            + " (Id VARCHAR NOT NULL PRIMARY KEY, COLFAM1.A VARCHAR, COLFAM1.B VARCHAR, COLFAM2.A VARCHAR )");
        conn.createStatement().execute("UPSERT INTO " + tableName
            + " (Id, COLFAM1.A, COLFAM1.B, COLFAM2.A) values ('row-2', '100', '200', '300')");
        rs = conn.createStatement().executeQuery("SELECT COLFAM1.A,COLFAM1.B FROM " + tableName);
        assertTrue(rs.next());
        assertEquals("100",rs.getString(1));
        assertEquals("200",rs.getString(2));
        assertFalse(rs.next());

        rs = conn.createStatement().executeQuery("SELECT COLFAM1.* FROM " + tableName);
        assertTrue(rs.next());
        assertEquals("100",rs.getString(1));
        assertEquals("200",rs.getString(2));
        assertFalse(rs.next());

        rs = conn.createStatement().executeQuery("SELECT COLFAM1.*,COLFAM1.A FROM " + tableName);
        assertTrue(rs.next());
        assertEquals("100",rs.getString(1));
        assertEquals("200",rs.getString(2));
        assertFalse(rs.next());
    }
}
```


Overlapping Code:
```
@edu.umd.cs.findbugs.annotations.SuppressWarnings(
value="RV_RETURN_VALUE_IGNORED", 
justification="Designed to ignore.")
public class DynamicFamilyIT extends BaseHBaseManagedTimeTableReuseIT {
private static final String WEB_STATS = generateRandomString();
private static final String WEB_STATS_SCHEMA_NAME = "";
private static final byte[] A_CF = Bytes.toBytes(SchemaUtil.normalizeIdentifier("A"));
private static final byte[] B_CF = Bytes.toBytes(SchemaUtil.normalizeIdentifier("B"));
private static final String USER_ID1 = "u0001";
private static final String USER_ID2 = "u0002";
private static final String USER_ID3 = "u0003";
private static final byte[] USER_ID1_BYTES = Bytes.toBytes(USER_ID1);
private static final byte[] USER_ID2_BYTES = Bytes.toBytes(USER_ID2);
private static final byte[] USER_ID3_BYTES = Bytes.toBytes(USER_ID3);

private static final String MAX_CLICK_COUNT_PREFIX = SchemaUtil.normalizeIdentifier("MaxClickCount_");
private static final byte[] MAX_CLICK_COUNT_DYNCOL_PREFIX = Bytes.toBytes(MAX_CLICK_COUNT_PREFIX);
private static final Integer ENTRY1_CLICK_COUNT = 12;
private static final Integer ENTRY2_CLICK_COUNT = 34;
private static final Integer ENTRY3_CLICK_COUNT = 56;

private static final String LAST_LOGIN_TIME_PREFIX = SchemaUtil.normalizeIdentifier("LastLoginTime_");
private static final byte[] LAST_LOGIN_TIME_DYNCOL_PREFIX = Bytes.toBytes(LAST_LOGIN_TIME_PREFIX);

private static final Time ENTRY1_USER_ID1_LOGIN_TIME = new Time(System.currentTimeMillis()+60000);
private static final Time ENTRY1_USER_ID2_LOGIN_TIME = new Time(System.currentTimeMillis()+120000);

private static final Time ENTRY2_USER_ID2_LOGIN_TIME = new Time(System.currentTimeMillis()+180000);
private static final Time ENTRY2_USER_ID3_LOGIN_TIME = new Time(System.currentTimeMillis()+240000);

private static final Time ENTRY3_USER_ID1_LOGIN_TIME = new Time(System.currentTimeMillis()+300000);
private static final Time ENTRY3_USER_ID2_LOGIN_TIME = new Time(System.currentTimeMillis()+360000);
private static final Time ENTRY3_USER_ID3_LOGIN_TIME = new Time(System.currentTimeMillis()+420000);
@Before
public void doBeforeTestSetup() throws Exception {
Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);
Connection conn = DriverManager.getConnection(getUrl(), props);
String ddl = "create table if not e
```
<Overlap Ratio: 0.9991427346763824>

---

--- 187 --
Question ID: 46e17bf80c0da7910855abeedcdca5059fe75ba8
Original Code:
```
public class ZkClientCacheFactory {

	static ConcurrentHashMap<String, InteligentZKClient> cache = new ConcurrentHashMap<String, InteligentZKClient>();
	
	public static InteligentZKClient getZKClient(String server) {
		return cache.get(server);
	}
	
	public static InteligentZKClient getZKClientIfNoneCreate(String server) {
		InteligentZKClient zk = cache.get(server);
		if(zk==null) {
			synchronized (cache) {
				zk = cache.get(server);
				if(zk==null) {
					zk = new InteligentZKClient(server);
					cache.put(server, zk);
				}
			}
		}
		if(!zk.isAvaliable()) {
			zk.reCreateClient();
		}
		return zk;
	}
	
	
}
```


Overlapping Code:
```
atic ConcurrentHashMap<String, InteligentZKClient> cache = new ConcurrentHashMap<String, InteligentZKClient>();

public static InteligentZKClient getZKClient(String server) {
return cache.get(server);
}

public static InteligentZKClient getZKClientIfNoneCreate(String server) {
InteligentZKClient zk = cache.get(server);
if(zk==null) {
synchronized (cache) {
zk = cache.get(server);
if(zk==null) {
zk = new InteligentZKClient(server);
cache.put(server, zk);
}
}
}
if(!zk.isAvaliable()) {
zk.reCreateC
```
<Overlap Ratio: 0.8849557522123894>

---

--- 188 --
Question ID: 147a7aaf84337926b56b394e01bf17b4732c073e
Original Code:
```
@Generated("com.amazonaws:aws-java-sdk-code-generator")
public class ProjectSource implements Serializable, Cloneable, StructuredPojo {

    /**
     * <p>
     * The type of repository that contains the source code to be built. Valid values include:
     * </p>
     * <ul>
     * <li>
     * <p>
     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS
     * CodePipeline.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>GITHUB</code>: The source code is in a GitHub repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.
     * </p>
     * </li>
     * </ul>
     */
    private String type;
    /**
     * <p>
     * Information about the location of the source code to be built. Valid values include:
     * </p>
     * <ul>
     * <li>
     * <p>
     * For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,
     * <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This is
     * because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source
     * code and the build spec (for example,
     * <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file that
     * contains the source code (for example,
     * <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the
     * build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS CodeBuild
     * console to begin creating a build project. When you use the console to connect (or reconnect) with GitHub, on the
     * GitHub <b>Authorize application</b> page that displays, for <b>Organization access</b>, choose <b>Request
     * access</b> next to each repository you want to allow AWS CodeBuild to have access to. Then choose <b>Authorize
     * application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build
     * project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this
     * connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to
     * <code>OAUTH</code>.
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the
     * build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the AWS CodeBuild
     * console to begin creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on
     * the Bitbucket <b>Confirm access to your account</b> page that displays, choose <b>Grant access</b>. (After you
     * have connected to your Bitbucket account, you do not need to finish creating the build project, and you may then
     * leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the
     * <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.
     * </p>
     * </li>
     * </ul>
     */
    private String location;
    /**
     * <p>
     * The build spec declaration to use for the builds in this build project.
     * </p>
     * <p>
     * If this value is not specified, a build spec must be included along with the source code to be built.
     * </p>
     */
    private String buildspec;
    /**
     * <p>
     * Information about the authorization settings for AWS CodeBuild to access the source code to be built.
     * </p>
     * <p>
     * This information is for the AWS CodeBuild console's use only. Your code should not get or set this information
     * directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code> or
     * <code>GITHUB</code>).
     * </p>
     */
    private SourceAuth auth;

    /**
     * <p>
     * The type of repository that contains the source code to be built. Valid values include:
     * </p>
     * <ul>
     * <li>
     * <p>
     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS
     * CodePipeline.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>GITHUB</code>: The source code is in a GitHub repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.
     * </p>
     * </li>
     * </ul>
     * 
     * @param type
     *        The type of repository that contains the source code to be built. Valid values include:</p>
     *        <ul>
     *        <li>
     *        <p>
     *        <code>BITBUCKET</code>: The source code is in a Bitbucket repository.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in
     *        AWS CodePipeline.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>GITHUB</code>: The source code is in a GitHub repository.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.
     *        </p>
     *        </li>
     * @see SourceType
     */

    public void setType(String type) {
        this.type = type;
    }

    /**
     * <p>
     * The type of repository that contains the source code to be built. Valid values include:
     * </p>
     * <ul>
     * <li>
     * <p>
     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS
     * CodePipeline.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>GITHUB</code>: The source code is in a GitHub repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.
     * </p>
     * </li>
     * </ul>
     * 
     * @return The type of repository that contains the source code to be built. Valid values include:</p>
     *         <ul>
     *         <li>
     *         <p>
     *         <code>BITBUCKET</code>: The source code is in a Bitbucket repository.
     *         </p>
     *         </li>
     *         <li>
     *         <p>
     *         <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.
     *         </p>
     *         </li>
     *         <li>
     *         <p>
     *         <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in
     *         AWS CodePipeline.
     *         </p>
     *         </li>
     *         <li>
     *         <p>
     *         <code>GITHUB</code>: The source code is in a GitHub repository.
     *         </p>
     *         </li>
     *         <li>
     *         <p>
     *         <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.
     *         </p>
     *         </li>
     * @see SourceType
     */

    public String getType() {
        return this.type;
    }

    /**
     * <p>
     * The type of repository that contains the source code to be built. Valid values include:
     * </p>
     * <ul>
     * <li>
     * <p>
     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS
     * CodePipeline.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>GITHUB</code>: The source code is in a GitHub repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.
     * </p>
     * </li>
     * </ul>
     * 
     * @param type
     *        The type of repository that contains the source code to be built. Valid values include:</p>
     *        <ul>
     *        <li>
     *        <p>
     *        <code>BITBUCKET</code>: The source code is in a Bitbucket repository.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in
     *        AWS CodePipeline.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>GITHUB</code>: The source code is in a GitHub repository.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.
     *        </p>
     *        </li>
     * @return Returns a reference to this object so that method calls can be chained together.
     * @see SourceType
     */

    public ProjectSource withType(String type) {
        setType(type);
        return this;
    }

    /**
     * <p>
     * The type of repository that contains the source code to be built. Valid values include:
     * </p>
     * <ul>
     * <li>
     * <p>
     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS
     * CodePipeline.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>GITHUB</code>: The source code is in a GitHub repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.
     * </p>
     * </li>
     * </ul>
     * 
     * @param type
     *        The type of repository that contains the source code to be built. Valid values include:</p>
     *        <ul>
     *        <li>
     *        <p>
     *        <code>BITBUCKET</code>: The source code is in a Bitbucket repository.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in
     *        AWS CodePipeline.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>GITHUB</code>: The source code is in a GitHub repository.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.
     *        </p>
     *        </li>
     * @see SourceType
     */

    public void setType(SourceType type) {
        withType(type);
    }

    /**
     * <p>
     * The type of repository that contains the source code to be built. Valid values include:
     * </p>
     * <ul>
     * <li>
     * <p>
     * <code>BITBUCKET</code>: The source code is in a Bitbucket repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS
     * CodePipeline.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>GITHUB</code>: The source code is in a GitHub repository.
     * </p>
     * </li>
     * <li>
     * <p>
     * <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.
     * </p>
     * </li>
     * </ul>
     * 
     * @param type
     *        The type of repository that contains the source code to be built. Valid values include:</p>
     *        <ul>
     *        <li>
     *        <p>
     *        <code>BITBUCKET</code>: The source code is in a Bitbucket repository.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in
     *        AWS CodePipeline.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>GITHUB</code>: The source code is in a GitHub repository.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.
     *        </p>
     *        </li>
     * @return Returns a reference to this object so that method calls can be chained together.
     * @see SourceType
     */

    public ProjectSource withType(SourceType type) {
        this.type = type.toString();
        return this;
    }

    /**
     * <p>
     * Information about the location of the source code to be built. Valid values include:
     * </p>
     * <ul>
     * <li>
     * <p>
     * For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,
     * <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This is
     * because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source
     * code and the build spec (for example,
     * <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file that
     * contains the source code (for example,
     * <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the
     * build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS CodeBuild
     * console to begin creating a build project. When you use the console to connect (or reconnect) with GitHub, on the
     * GitHub <b>Authorize application</b> page that displays, for <b>Organization access</b>, choose <b>Request
     * access</b> next to each repository you want to allow AWS CodeBuild to have access to. Then choose <b>Authorize
     * application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build
     * project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this
     * connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to
     * <code>OAUTH</code>.
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the
     * build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the AWS CodeBuild
     * console to begin creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on
     * the Bitbucket <b>Confirm access to your account</b> page that displays, choose <b>Grant access</b>. (After you
     * have connected to your Bitbucket account, you do not need to finish creating the build project, and you may then
     * leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the
     * <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.
     * </p>
     * </li>
     * </ul>
     * 
     * @param location
     *        Information about the location of the source code to be built. Valid values include:</p>
     *        <ul>
     *        <li>
     *        <p>
     *        For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,
     *        <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This
     *        is because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the
     *        source code and the build spec (for example,
     *        <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file
     *        that contains the source code (for example,
     *        <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and
     *        the build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS
     *        CodeBuild console to begin creating a build project. When you use the console to connect (or reconnect)
     *        with GitHub, on the GitHub <b>Authorize application</b> page that displays, for <b>Organization
     *        access</b>, choose <b>Request access</b> next to each repository you want to allow AWS CodeBuild to have
     *        access to. Then choose <b>Authorize application</b>. (After you have connected to your GitHub account, you
     *        do not need to finish creating the build project, and you may then leave the AWS CodeBuild console.) To
     *        instruct AWS CodeBuild to then use this connection, in the <code>source</code> object, set the
     *        <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source
     *        and the build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the
     *        AWS CodeBuild console to begin creating a build project. When you use the console to connect (or
     *        reconnect) with Bitbucket, on the Bitbucket <b>Confirm access to your account</b> page that displays,
     *        choose <b>Grant access</b>. (After you have connected to your Bitbucket account, you do not need to finish
     *        creating the build project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild
     *        to then use this connection, in the <code>source</code> object, set the <code>auth</code> object's
     *        <code>type</code> value to <code>OAUTH</code>.
     *        </p>
     *        </li>
     */

    public void setLocation(String location) {
        this.location = location;
    }

    /**
     * <p>
     * Information about the location of the source code to be built. Valid values include:
     * </p>
     * <ul>
     * <li>
     * <p>
     * For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,
     * <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This is
     * because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source
     * code and the build spec (for example,
     * <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file that
     * contains the source code (for example,
     * <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the
     * build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS CodeBuild
     * console to begin creating a build project. When you use the console to connect (or reconnect) with GitHub, on the
     * GitHub <b>Authorize application</b> page that displays, for <b>Organization access</b>, choose <b>Request
     * access</b> next to each repository you want to allow AWS CodeBuild to have access to. Then choose <b>Authorize
     * application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build
     * project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this
     * connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to
     * <code>OAUTH</code>.
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the
     * build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the AWS CodeBuild
     * console to begin creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on
     * the Bitbucket <b>Confirm access to your account</b> page that displays, choose <b>Grant access</b>. (After you
     * have connected to your Bitbucket account, you do not need to finish creating the build project, and you may then
     * leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the
     * <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.
     * </p>
     * </li>
     * </ul>
     * 
     * @return Information about the location of the source code to be built. Valid values include:</p>
     *         <ul>
     *         <li>
     *         <p>
     *         For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,
     *         <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This
     *         is because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.
     *         </p>
     *         </li>
     *         <li>
     *         <p>
     *         For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the
     *         source code and the build spec (for example,
     *         <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).
     *         </p>
     *         </li>
     *         <li>
     *         <p>
     *         For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file
     *         that contains the source code (for example,
     *         <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)
     *         </p>
     *         </li>
     *         <li>
     *         <p>
     *         For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source
     *         and the build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the
     *         AWS CodeBuild console to begin creating a build project. When you use the console to connect (or
     *         reconnect) with GitHub, on the GitHub <b>Authorize application</b> page that displays, for
     *         <b>Organization access</b>, choose <b>Request access</b> next to each repository you want to allow AWS
     *         CodeBuild to have access to. Then choose <b>Authorize application</b>. (After you have connected to your
     *         GitHub account, you do not need to finish creating the build project, and you may then leave the AWS
     *         CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the <code>source</code>
     *         object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.
     *         </p>
     *         </li>
     *         <li>
     *         <p>
     *         For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source
     *         and the build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use
     *         the AWS CodeBuild console to begin creating a build project. When you use the console to connect (or
     *         reconnect) with Bitbucket, on the Bitbucket <b>Confirm access to your account</b> page that displays,
     *         choose <b>Grant access</b>. (After you have connected to your Bitbucket account, you do not need to
     *         finish creating the build project, and you may then leave the AWS CodeBuild console.) To instruct AWS
     *         CodeBuild to then use this connection, in the <code>source</code> object, set the <code>auth</code>
     *         object's <code>type</code> value to <code>OAUTH</code>.
     *         </p>
     *         </li>
     */

    public String getLocation() {
        return this.location;
    }

    /**
     * <p>
     * Information about the location of the source code to be built. Valid values include:
     * </p>
     * <ul>
     * <li>
     * <p>
     * For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,
     * <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This is
     * because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source
     * code and the build spec (for example,
     * <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file that
     * contains the source code (for example,
     * <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the
     * build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS CodeBuild
     * console to begin creating a build project. When you use the console to connect (or reconnect) with GitHub, on the
     * GitHub <b>Authorize application</b> page that displays, for <b>Organization access</b>, choose <b>Request
     * access</b> next to each repository you want to allow AWS CodeBuild to have access to. Then choose <b>Authorize
     * application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build
     * project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this
     * connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to
     * <code>OAUTH</code>.
     * </p>
     * </li>
     * <li>
     * <p>
     * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the
     * build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the AWS CodeBuild
     * console to begin creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on
     * the Bitbucket <b>Confirm access to your account</b> page that displays, choose <b>Grant access</b>. (After you
     * have connected to your Bitbucket account, you do not need to finish creating the build project, and you may then
     * leave the AWS CodeBuild console.) To instruct AWS CodeBuild to then use this connection, in the
     * <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.
     * </p>
     * </li>
     * </ul>
     * 
     * @param location
     *        Information about the location of the source code to be built. Valid values include:</p>
     *        <ul>
     *        <li>
     *        <p>
     *        For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,
     *        <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This
     *        is because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the
     *        source code and the build spec (for example,
     *        <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file
     *        that contains the source code (for example,
     *        <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and
     *        the build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS
     *        CodeBuild console to begin creating a build project. When you use the console to connect (or reconnect)
     *        with GitHub, on the GitHub <b>Authorize application</b> page that displays, for <b>Organization
     *        access</b>, choose <b>Request access</b> next to each repository you want to allow AWS CodeBuild to have
     *        access to. Then choose <b>Authorize application</b>. (After you have connected to your GitHub account, you
     *        do not need to finish creating the build project, and you may then leave the AWS CodeBuild console.) To
     *        instruct AWS CodeBuild to then use this connection, in the <code>source</code> object, set the
     *        <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.
     *        </p>
     *        </li>
     *        <li>
     *        <p>
     *        For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source
     *        and the build spec. Also, you must connect your AWS account to your Bitbucket account. To do this, use the
     *        AWS CodeBuild console to begin creating a build project. When you use the console to connect (or
     *        reconnect) with Bitbucket, on the Bitbucket <b>Confirm access to your account</b> page that displays,
     *        choose <b>Grant access</b>. (After you have connected to your Bitbucket account, you do not need to finish
     *        creating the build project, and you may then leave the AWS CodeBuild console.) To instruct AWS CodeBuild
     *        to then use this connection, in the <code>source</code> object, set the <code>auth</code> object's
     *        <code>type</code> value to <code>OAUTH</code>.
     *        </p>
     *        </li>
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public ProjectSource withLocation(String location) {
        setLocation(location);
        return this;
    }

    /**
     * <p>
     * The build spec declaration to use for the builds in this build project.
     * </p>
     * <p>
     * If this value is not specified, a build spec must be included along with the source code to be built.
     * </p>
     * 
     * @param buildspec
     *        The build spec declaration to use for the builds in this build project.</p>
     *        <p>
     *        If this value is not specified, a build spec must be included along with the source code to be built.
     */

    public void setBuildspec(String buildspec) {
        this.buildspec = buildspec;
    }

    /**
     * <p>
     * The build spec declaration to use for the builds in this build project.
     * </p>
     * <p>
     * If this value is not specified, a build spec must be included along with the source code to be built.
     * </p>
     * 
     * @return The build spec declaration to use for the builds in this build project.</p>
     *         <p>
     *         If this value is not specified, a build spec must be included along with the source code to be built.
     */

    public String getBuildspec() {
        return this.buildspec;
    }

    /**
     * <p>
     * The build spec declaration to use for the builds in this build project.
     * </p>
     * <p>
     * If this value is not specified, a build spec must be included along with the source code to be built.
     * </p>
     * 
     * @param buildspec
     *        The build spec declaration to use for the builds in this build project.</p>
     *        <p>
     *        If this value is not specified, a build spec must be included along with the source code to be built.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public ProjectSource withBuildspec(String buildspec) {
        setBuildspec(buildspec);
        return this;
    }

    /**
     * <p>
     * Information about the authorization settings for AWS CodeBuild to access the source code to be built.
     * </p>
     * <p>
     * This information is for the AWS CodeBuild console's use only. Your code should not get or set this information
     * directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code> or
     * <code>GITHUB</code>).
     * </p>
     * 
     * @param auth
     *        Information about the authorization settings for AWS CodeBuild to access the source code to be built.</p>
     *        <p>
     *        This information is for the AWS CodeBuild console's use only. Your code should not get or set this
     *        information directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code>
     *        or <code>GITHUB</code>).
     */

    public void setAuth(SourceAuth auth) {
        this.auth = auth;
    }

    /**
     * <p>
     * Information about the authorization settings for AWS CodeBuild to access the source code to be built.
     * </p>
     * <p>
     * This information is for the AWS CodeBuild console's use only. Your code should not get or set this information
     * directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code> or
     * <code>GITHUB</code>).
     * </p>
     * 
     * @return Information about the authorization settings for AWS CodeBuild to access the source code to be built.</p>
     *         <p>
     *         This information is for the AWS CodeBuild console's use only. Your code should not get or set this
     *         information directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code>
     *         or <code>GITHUB</code>).
     */

    public SourceAuth getAuth() {
        return this.auth;
    }

    /**
     * <p>
     * Information about the authorization settings for AWS CodeBuild to access the source code to be built.
     * </p>
     * <p>
     * This information is for the AWS CodeBuild console's use only. Your code should not get or set this information
     * directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code> or
     * <code>GITHUB</code>).
     * </p>
     * 
     * @param auth
     *        Information about the authorization settings for AWS CodeBuild to access the source code to be built.</p>
     *        <p>
     *        This information is for the AWS CodeBuild console's use only. Your code should not get or set this
     *        information directly (unless the build project's source <code>type</code> value is <code>BITBUCKET</code>
     *        or <code>GITHUB</code>).
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public ProjectSource withAuth(SourceAuth auth) {
        setAuth(auth);
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getType() != null)
            sb.append("Type: ").append(getType()).append(",");
        if (getLocation() != null)
            sb.append("Location: ").append(getLocation()).append(",");
        if (getBuildspec() != null)
            sb.append("Buildspec: ").append(getBuildspec()).append(",");
        if (getAuth() != null)
            sb.append("Auth: ").append(getAuth());
        sb.append("}");
        return sb.toString();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;

        if (obj instanceof ProjectSource == false)
            return false;
        ProjectSource other = (ProjectSource) obj;
        if (other.getType() == null ^ this.getType() == null)
            return false;
        if (other.getType() != null && other.getType().equals(this.getType()) == false)
            return false;
        if (other.getLocation() == null ^ this.getLocation() == null)
            return false;
        if (other.getLocation() != null && other.getLocation().equals(this.getLocation()) == false)
            return false;
        if (other.getBuildspec() == null ^ this.getBuildspec() == null)
            return false;
        if (other.getBuildspec() != null && other.getBuildspec().equals(this.getBuildspec()) == false)
            return false;
        if (other.getAuth() == null ^ this.getAuth() == null)
            return false;
        if (other.getAuth() != null && other.getAuth().equals(this.getAuth()) == false)
            return false;
        return true;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;

        hashCode = prime * hashCode + ((getType() == null) ? 0 : getType().hashCode());
        hashCode = prime * hashCode + ((getLocation() == null) ? 0 : getLocation().hashCode());
        hashCode = prime * hashCode + ((getBuildspec() == null) ? 0 : getBuildspec().hashCode());
        hashCode = prime * hashCode + ((getAuth() == null) ? 0 : getAuth().hashCode());
        return hashCode;
    }

    @Override
    public ProjectSource clone() {
        try {
            return (ProjectSource) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException("Got a CloneNotSupportedException from Object.clone() " + "even though we're Cloneable!", e);
        }
    }

    @com.amazonaws.annotation.SdkInternalApi
    @Override
    public void marshall(ProtocolMarshaller protocolMarshaller) {
        com.amazonaws.services.codebuild.model.transform.ProjectSourceMarshaller.getInstance().marshall(this, protocolMarshaller);
    }
}
```


Overlapping Code:
```
@Generated("com.amazonaws:aws-java-sdk-code-generator")
public class ProjectSource implements Serializable, Cloneable, StructuredPojo {
/**
* <p>
* The type of repository that contains the source code to be built. Valid values include:
* </p>
* <ul>
* <li>
* <p>
* <code>BITBUCKET</code>: The source code is in a Bitbucket repository.
* </p>
* </li>
* <li>
* <p>
* <code>CODECOMMIT</code>: The source code is in an AWS CodeCommit repository.
* </p>
* </li>
* <li>
* <p>
* <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in AWS
* CodePipeline.
* </p>
* </li>
* <li>
* <p>
* <code>GITHUB</code>: The source code is in a GitHub repository.
* </p>
* </li>
* <li>
* <p>
* <code>S3</code>: The source code is in an Amazon Simple Storage Service (Amazon S3) input bucket.
* </p>
* </li>
* </ul>
*/
private String type;
/**
* <p>
* Information about the location of the source code to be built. Valid values include:
* </p>
* <ul>
* <li>
* <p>
* For source code settings that are specified in the source action of a pipeline in AWS CodePipeline,
* <code>location</code> should not be specified. If it is specified, AWS CodePipeline will ignore it. This is
* because AWS CodePipeline uses the settings in a pipeline's source action instead of this value.
* </p>
* </li>
* <li>
* <p>
* For source code in an AWS CodeCommit repository, the HTTPS clone URL to the repository that contains the source
* code and the build spec (for example,
* <code>https://git-codecommit.<i>region-ID</i>.amazonaws.com/v1/repos/<i>repo-name</i> </code>).
* </p>
* </li>
* <li>
* <p>
* For source code in an Amazon Simple Storage Service (Amazon S3) input bucket, the path to the ZIP file that
* contains the source code (for example,
* <code> <i>bucket-name</i>/<i>path</i>/<i>to</i>/<i>object-name</i>.zip</code>)
* </p>
* </li>
* <li>
* <p>
* For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the
* build spec. Also, you must connect your AWS account to your GitHub account. To do this, use the AWS CodeBuild
* console to begin creating a build project. When you use the console to connect (o
```
<Overlap Ratio: 0.9995404411764706>

---

--- 189 --
Question ID: 621ecba9574f30c177e33a6e5a64136fe557507c
Original Code:
```
public class GetShuffle extends AbstractItemAction {

	/**
	 * Returns the preferences of the given object.
	 * 
	 * @throws InvalidParameterException
	 * @see net.violet.platform.api.actions.Action#processRequest(java.util.Map)
	 */

	@Override
	protected Object doProcessRequest(ActionParam inParam) throws InvalidParameterException {

		final APICaller caller = inParam.getCaller();
		final StatusMusic type = getLibraryTypeId(inParam);
		final String thelanguageCode = inParam.getString("language", true);
		final ObjectLangData languageData = ObjectLangData.getByISOCode(thelanguageCode);

		final MusicData theMusicData = MusicData.findRandomByLang(type, languageData);

		return new ItemInformationMap(caller, theMusicData);
	}

	/**
	 * @see net.violet.platform.api.actions.Action#isCacheable()
	 */
	public boolean isCacheable() {
		return true;
	}

	/**
	 * Object informations may be cached one day
	 * 
	 * @see net.violet.platform.api.actions.Action#getExpirationTime()
	 */
	public long getExpirationTime() {
		return Constantes.ONE_DAY_IN_S;
	}

	/**
	 * Read Only action
	 * 
	 * @see net.violet.platform.api.actions.Action#getType()
	 */
	public ActionType getType() {
		return ActionType.GET;
	}

	@Override
	public List<ApplicationClass> getAuthorizedApplicationClasses() {
		return Application.CLASSES_ALL;
	}

}
```


Overlapping Code:
```
AbstractItemAction {
/**
* Returns the preferences of the given object.
* 
* @throws InvalidParameterException
* @see net.violet.platform.api.actions.Action#processRequest(java.util.Map)
*/
@Override
protected Object doProcessRequest(ActionParam inParam) throws InvalidParameterException {
final APICaller caller = inParam.getCaller();
final StatusMusic type = getLibraryTypeId(inParam);
final String thelanguageCode = inParam.getString("language", true);
final ObjectLangData languageData = ObjectLangData.getByISOCode(thelanguageCode);
final MusicData theMusicData = MusicData.findRandomByLang(type, languageData);
return new ItemInformationMap(caller, theMusicData);
}
/**
* @see net.violet.platform.api.actions.Action#isCacheable()
*/
public boolean isCacheable() {
return true;
}
/**
* Object informations may be cached one day
* 
* @see net.violet.platform.api.actions.Action#getExpirationTime()
*/
public long getExpirationTime() {
return Constantes.ONE_DAY_IN_S;
}
/**
* Read Only action
* 
* @see net.violet.platform.api.actions.Action#getType()
*/
public ActionType getType() {
return ActionType.GET;
}
@Override
public List<ApplicationClass> getAuthorizedApplicationClasses() {
return Application.CLASSES_ALL;
}

```
<Overlap Ratio: 0.9737261146496815>

---

--- 190 --
Question ID: 67945b4b78eef54af2decc2a519ec0a79292bd3a
Original Code:
```
public class SearchCriteriaNode extends DefaultMutableTreeNode {

    private boolean _isEdited = false;
    private boolean _isMergeCriterionNode = false;
    private Table _table = null;
    private int _sourceColNum = -1;

    public SearchCriteriaNode(CriterionValue val) {
        super(val);
    }

    public void setEdited(boolean b) {
        _isEdited = b;
    }

    public boolean getEdited() {
        return _isEdited;
    }

    public boolean isEdited() {
        return getEdited();
    }

    public List getPropertyNodes() {
        List propNodes = new ArrayList();
        if (children != null) {
            for (Iterator i = children.iterator(); i.hasNext();) {
                SearchCriteriaNode child = (SearchCriteriaNode) i.next();
                if (((CriterionValue) child.getUserObject()).getType() != CriterionValue.OBJECT_TYPE) {
                    propNodes.add(child);
                }
            }
        }
        return propNodes;
    }

    public List getObjectNodes() {
        List objNodes = new ArrayList();
        if (children != null) {
            for (Iterator i = children.iterator(); i.hasNext();) {
                SearchCriteriaNode child = (SearchCriteriaNode) i.next();
                if (((CriterionValue) child.getUserObject()).getType() == CriterionValue.OBJECT_TYPE) {
                    objNodes.add(child);
                }
            }
        }
        return objNodes;
    }

    public boolean isProperty() {
        return ((CriterionValue) userObject).getType() != CriterionValue.OBJECT_TYPE;
    }

    public boolean isObject() {
        return ((CriterionValue) userObject).getType() == CriterionValue.OBJECT_TYPE;
    }

    public void setIsMergeCriterionNode(boolean b) {
        _isMergeCriterionNode = b;
    }

    public boolean getIsMergeCriterionNode() {
        return _isMergeCriterionNode;
    }

    public boolean isMergeCriterionNode() {
        return getIsMergeCriterionNode();
    }

    public String getObjectName() {
        return ((CriterionValue) userObject).getObjectName();
    }

    public String getPropertyName() {
        return ((CriterionValue) userObject).getPropertyName();
    }

    public void setTable(Table t) {
        _table = t;
    }

    public Table getTable() {
        return _table;
    }

    public void setSourceColumnNumber(int n) {
        _sourceColNum = n;
    }

    public int getSourceColumnNumber() {
        return _sourceColNum;
    }

    public String getId() {
        return ((CriterionValue) userObject).getId();
    }

    public String toXML() {
        return null;
    }

    public boolean isEmpty() {
        boolean empty = true;
        CriterionValue val = (CriterionValue) userObject;
        if (val.getType() == CriterionValue.OBJECT_TYPE) {
            // then this is an object node
            if (userObject != null
                    && ((CriterionValue) userObject).isSelectAll()) {
                empty = false;
            }
            else if (children != null) {
                for (Iterator i = children.iterator(); i.hasNext();) {
                    if (!((SearchCriteriaNode) i.next()).isEmpty()) {
                        empty = false;
                    }
                }
            }
        }
        else {
            // then this is a property node
            List vals = val.getValues();
            if (vals != null && vals.size() > 0) {
                empty = false;
            }
        }
        return empty;
    }

    public SearchCriteriaNode findNonEmptyParent() {
        SearchCriteriaNode theParent = null;
        if (parent != null) {
            SearchCriteriaNode aParent = (SearchCriteriaNode) parent;
            if (!aParent.isEmpty()) {
                theParent = aParent.findNonEmptyParent();
            }
        }
        return theParent;
    }

    public void removeEmptyChildren() {
        for (Enumeration nodes = postorderEnumeration(); nodes.hasMoreElements();) {
            SearchCriteriaNode node = (SearchCriteriaNode) nodes.nextElement();
            if (node.isEmpty()) {
                node.removeFromParent();
            }
        }
    }

    public boolean isPathItem() {
        boolean isPI = false;
        if (isObject() && parent != null) {
            CriterionValue cv = (CriterionValue) ((DefaultMutableTreeNode) parent).getUserObject();
            if (cv != null) {
                SearchableObject so = cv.getSearchableObject();
                List assocs = so.getAssociations();
                search: for (Iterator i = assocs.iterator(); i.hasNext();) {
                    Association assoc = (Association) i.next();
                    List pis = assoc.getPathItems();
                    for (Iterator j = pis.iterator(); j.hasNext();) {
                        PathItem pi = (PathItem) j.next();
                        MessageLog.printInfo("pi.getClassname() = "
                                + pi.getClassname()
                                + ", this.getObjectName() = "
                                + this.getObjectName());
                        if (pi.getClassname().equals(this.getObjectName())) {
                            isPI = true;
                            break search;
                        }
                    }
                }
            }
        }
        return isPI;
    }

    public SearchCriteriaNode getPathEndPointNode() {
        SearchCriteriaNode endPointNode = null;
        if (!this.isPathItem()) {
            endPointNode = this;
        }
        else {
            if (children != null) {
                for (Iterator i = children.iterator(); i.hasNext();) {
                    endPointNode = ((SearchCriteriaNode) i.next()).getPathEndPointNode();
                }
            }
        }
        return endPointNode;
    }

    public SearchCriteriaNode getPathBeginPointNode() {
        SearchCriteriaNode beginPointNode = null;
        if (!this.isPathItem()) {
            beginPointNode = this;
        }
        else {
            if (parent != null) {
                beginPointNode = ((SearchCriteriaNode) parent).getPathBeginPointNode();
            }
        }
        return beginPointNode;
    }

    public boolean isOntological() {
        boolean isOnt = false;
        if (userObject != null) {
            if (((CriterionValue) userObject).getType() == CriterionValue.ONTOLOGICAL_TYPE) {
                isOnt = true;
            }
        }
        return isOnt;
    }
}
```


Overlapping Code:
```
Node extends DefaultMutableTreeNode {
private boolean _isEdited = false;
private boolean _isMergeCriterionNode = false;
private Table _table = null;
private int _sourceColNum = -1;
public SearchCriteriaNode(CriterionValue val) {
super(val);
}
public void setEdited(boolean b) {
_isEdited = b;
}
public boolean getEdited() {
return _isEdited;
}
public boolean isEdited() {
return getEdited();
}
public List getPropertyNodes() {
List propNodes = new ArrayList();
if (children != null) {
for (Iterator i = children.iterator(); i.hasNext();) {
SearchCriteriaNode child = (SearchCriteriaNode) i.next();
if (((CriterionValue) child.getUserObject()).getType() != CriterionValue.OBJECT_TYPE) {
propNodes.add(child);
}
}
}
return propNodes;
}
public List getObjectNodes() {
List objNodes = new ArrayList();
if (children != null) {
for (Iterator i = children.iterator(); i.hasNext();) {
SearchCriteriaNode child = (SearchCriteriaNode) i.next();
if (((CriterionValue) child.getUserObject()).getType() == CriterionValue.OBJECT_TYPE) {
objNodes.add(child);
}
}
}
return objNodes;
}
public boolean isProperty() {
return ((CriterionValue) userObject).getType() != CriterionValue.OBJECT_TYPE;
}
public boolean isObject() {
return ((CriterionValue) userObject).getType() == CriterionValue.OBJECT_TYPE;
}
public void setIsMergeCriterionNode(boolean b) {
_isMergeCriterionNode = b;
}
public boolean getIsMergeCriterionNode() {
return _isMergeCriterionNode;
}
public boolean isMergeCriterionNode() {
return getIsMergeCriterionNode();
}
public String getObjectName() {
return ((CriterionValue) userObject).getObjectName();
}
public String getPropertyName() {
return ((CriterionValue) userObject).getPropertyName();
}
public void setTable(Table t) {
_table = t;
}
public Table getTable() {
return _table;
}
public void setSourceColumnNumber(int n) {
_sourceColNum = n;
}
p
```
<Overlap Ratio: 0.9819532908704883>

---

--- 191 --
Question ID: f93360b466f28639034a273e529e0062c86b52d3
Original Code:
```
public final class OAuthHmacSha256Signer implements OAuthSigner {

  /** Client secret */
  private final String clientSharedSecret;

  /** Token secret */
  private String tokenSharedSecret;

  public void setTokenSecret(String tokenSecret) {
    tokenSharedSecret = tokenSecret;
  }

  public OAuthHmacSha256Signer(String clientSecret) {
    this.clientSharedSecret = clientSecret;
  }

  @Override
  public String getSignatureMethod() {
    return "HMAC-SHA256";
  }

  @Override
  public String computeSignature(String signatureBaseString) throws GeneralSecurityException {
    // compute key
    StringBuilder keyBuffer = new StringBuilder();
    if (clientSharedSecret != null) {
      keyBuffer.append(OAuthParameters.escape(clientSharedSecret));
    }
    keyBuffer.append('&');
    if (tokenSharedSecret != null) {
      keyBuffer.append(OAuthParameters.escape(tokenSharedSecret));
    }
    String key = keyBuffer.toString();
    // sign
    SecretKey secretKey = new SecretKeySpec(StringUtils.getBytesUtf8(key), "HmacSHA256");
    Mac mac = Mac.getInstance("HmacSHA256");
    mac.init(secretKey);
    return BaseEncoding.base64().encode(mac.doFinal(StringUtils.getBytesUtf8(signatureBaseString)));
  }
}
```


Overlapping Code:
```
ublic final class OAuthHmacSha256Signer implements OAuthSigner {
/** Client secret */
private final String clientSharedSecret;
/** Token secret */
private String tokenSharedSecret;
public void setTokenSecret(String tokenSecret) {
tokenSharedSecret = tokenSecret;
}
public OAuthHmacSha256Signer(String clientSecret) {
this.clientSharedSecret = clientSecret;
}
@Override
public String getSignatureMethod() {
return "HMAC-SHA256";
}
@Override
public String computeSignature(String signatureBaseString) throws GeneralSecurityException {
// compute key
StringBuilder keyBuffer = new StringBuilder();
if (clientSharedSecret != null) {
keyBuffer.append(OAuthParameters.escape(clientSharedSecret));
}
keyBuffer.append('&');
if (tokenSharedSecret != null) {
keyBuffer.append(OAuthParameters.escape(tokenSharedSecret));
}
String key = keyBuffer.toString();
// sign
SecretKey secretKey = new SecretKeySpec(StringUtils.getBytesUtf8(key), "HmacSHA256");
Mac mac = Mac.getInstance("HmacSHA256");
mac.init(secretKey);
return BaseEncoding.base64().encode(mac.doFinal(StringUtils.getBytesUtf8(signatureBaseString)));

```
<Overlap Ratio: 0.9963768115942029>

---

--- 192 --
Question ID: 57e94172c3c81be30c6639edc92a8eccde650e72
Original Code:
```
public class Ej3 {
    public static void main(String[] args) {
        int[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};
        int fila = 1;
        System.out.println(Ej3.mayor(matrix, fila));
    }
    
    public static int mayor(int[][] matrix,int i)
    {
        int mayor = matrix[i][0];
        int fila = 0;
        for (int j = 0; j < matrix[i].length; j++) 
        {
            if (matrix[i][j] > mayor) {
                mayor = matrix[i][j];
                fila=j;
            }
        }
        return fila;
    }  
}
```


Overlapping Code:
```
c class Ej3 {
public static void main(String[] args) {
int[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};
int fila = 1;
System.out.println(Ej3.mayor(matrix, fila));
}

public static int mayor(int[][] matrix,int i)
{
int mayor = matrix[i][0];
int fila = 0;
for (int j = 0; j < matrix[i].length; j++) 
{
if (matrix[i][j] > mayor) {
mayor = matrix[i][j];
fila=j;
}
}
return fil
```
<Overlap Ratio: 0.9683377308707124>

---

--- 193 --
Question ID: 6b27097c9d7bc4760cbcca7f100c0c2d72e8f7b1
Original Code:
```
public class netclient extends basesocket {
	
	//variables required to function that are specific to the client class
	private String ip = "localhost";
	
	public netclient(String ip, int portnumber){
		super(portnumber);
		this.ip=ip;
	}
	
	public boolean connect(){
		try{
			mainsocket = new Socket(ip, port);
			try{mainsocket.setSoTimeout(1);}catch(Exception e){}
			writer = new PrintStream(mainsocket.getOutputStream());
			reader = new BufferedReader(new InputStreamReader(mainsocket.getInputStream()));
		}catch(Exception e){disconnect(); return false;}
		
		try{Thread.sleep(100);}catch(Exception e){}
		
		//return testconnection();
		connected = true;
		return true;
	}

}
```


Overlapping Code:
```
ic class netclient extends basesocket {

//variables required to function that are specific to the client class
private String ip = "localhost";

public netclient(String ip, int portnumber){
super(portnumber);
this.ip=ip;
}

public boolean connect(){
try{
mainsocket = new Socket(ip, port);
try{mainsocket.setSoTimeout(1);}catch(Exception e){}
writer = new PrintStream(mainsocket.getOutputStream());
reader = new BufferedReader(new InputStreamReader(mainsocket.getInputStream()));
}catch(Exception e){disconnect(); return false;}

try{Thread.sleep(100);}catch(Exception e){}

//return testconnection();
conne
```
<Overlap Ratio: 0.9485179407176287>

---

--- 194 --
Question ID: 4d48ccc9b3488684b50100904f204203724d4d62
Original Code:
```
public class TopologyBuilder
{
	ArrayList<IRichSpout> spouts;
	ArrayList<IRichBolt> bolts;

	public TopologyBuilder()
	{
		spouts = new ArrayList<IRichSpout>();
		bolts  = new ArrayList<IRichBolt> ();
	}

	public SpoutDeclarer setSpout(String id, IRichSpout spout, Number parallelism_hint)
	{
		spouts.add(spout);
		return new SpoutDeclarer();
	}

	public  BoltDeclarer setBolt(String id, IRichBolt bolt, Number parallelism_hint)
	{
		bolts.add(bolt);
		return new BoltDeclarer();
	}

	public StormTopology createTopology()
	{
		StormTopology ret = new StormTopology();
		ret.WHsetSpoutsAndBolts(spouts, bolts);
		return ret;
	}

}
```


Overlapping Code:
```
<IRichSpout> spouts;
ArrayList<IRichBolt> bolts;
public TopologyBuilder()
{
spouts = new ArrayList<IRichSpout>();
bolts = new ArrayList<IRichBolt> ();
}
public SpoutDeclarer setSpout(String id, IRichSpout spout, Number parallelism_hint)
{
spouts.add(spout);
return new SpoutDeclarer();
}
public BoltDeclarer setBolt(String id, IRichBolt bolt, Number parallelism_hint)
{
bolts.add(bolt);
return new BoltDeclarer();
}
public StormTopology createTopology()
{
StormTopology ret = new StormTopology();
ret.WHsetSpoutsAndBolts(spouts, bolts);
return ret;
}
```
<Overlap Ratio: 0.9290540540540541>

---

--- 195 --
Question ID: 22c209a7a3105ba778af3755b98c9b9a9afd18bc
Original Code:
```
public class Form {


    private ModelRenderer mRenderer;
    private android.view.View mView;
    private Model mModel;
    private List<IFormOperation> mOperations;
    private List<Component> mComponents;


    public Form(ModelRenderer renderer){

        mRenderer = renderer;

    }

    public Form setModel(Model model){

        mModel = model;

        return this;

    }

    public Form create(LayoutInflater inflater, ViewGroup container) {

        mView = inflater.inflate( getModel().getOptions().getFormLayoutId() , container, false);

        getComponents().clear();

        return this;

    }

    public Form registerOperation(IFormOperation operation){

        if(getOperations().indexOf(operation)  <= -1) {

            getOperations().add(operation);

        }

        return this;

    }

    public Form registerComponent(Component component){

        if(!getComponents().contains(component)) {

            getComponents().add(component);

        }

        return this;

    }

    public Form initOperations(){

        for (IFormOperation operation:getOperations()) {

            operation.onInit();

        }

        return this;

    }


    public ModelRenderer getRenderer(){

        return mRenderer;

    }

    public List<Component> getComponents() {

        if(mComponents == null){

            mComponents = new ArrayList<>();

        }

        return mComponents;

    }

    public Model getModel(){

        return mModel;

    }

    public android.view.View getView() {

        return mView;

    }

    public List<IFormOperation> getOperations(){

        if(mOperations == null){

            mOperations = new ArrayList<>();

        }

        return mOperations;

    }

    public Component getComponent(PropertyInfo property){

        for (Component comp: getComponents()) {

            if(comp.getPropertyInfo().equals(property)) {

                return comp;

            }

        }

        return null;

    }

}
```


Overlapping Code:
```
c class Form {
private ModelRenderer mRenderer;
private android.view.View mView;
private Model mModel;
private List<IFormOperation> mOperations;
private List<Component> mComponents;
public Form(ModelRenderer renderer){
mRenderer = renderer;
}
public Form setModel(Model model){
mModel = model;
return this;
}
public Form create(LayoutInflater inflater, ViewGroup container) {
mView = inflater.inflate( getModel().getOptions().getFormLayoutId() , container, false);
getComponents().clear();
return this;
}
public Form registerOperation(IFormOperation operation){
if(getOperations().indexOf(operation) <= -1) {
getOperations().add(operation);
}
return this;
}
public Form registerComponent(Component component){
if(!getComponents().contains(component)) {
getComponents().add(component);
}
return this;
}
public Form initOperations(){
for (IFormOperation operation:getOperations()) {
operation.onInit();
}
return this;
}
public ModelRenderer getRenderer(){
return mRenderer;
}
public List<Component> getComponents() {
if(mComponents == null){
mComponents = new ArrayList<>();
}
return mComponents;
}
public Model getModel(){
return mModel;
}
public android.view.View getView() {
return mView;
}
public List<IFormOperation> getOperations(){
if(mOperations == null){
mOperations = new ArrayList<>();
}
return mOperations;
}
public Component getComponent(PropertyInfo property){
for (Component comp: getComponents()) {
if(comp.getPropertyInfo().equals(prop
```
<Overlap Ratio: 0.9686038744154977>

---

--- 196 --
Question ID: cb133cf02168fd625662a591a3141d4ce60e1059
Original Code:
```
public class SolrSearchSinkTest extends HydratorTestBase {
  @ClassRule
  public static final TestConfiguration CONFIG = new TestConfiguration("explore.enabled", false);
  private static final Schema inputSchema = Schema.recordOf(
    "input-record",
    Schema.Field.of("id", Schema.of(Schema.Type.STRING)),
    Schema.Field.of("firstname", Schema.of(Schema.Type.STRING)),
    Schema.Field.of("lastname", Schema.of(Schema.Type.STRING)),
    Schema.Field.of("office address", Schema.of(Schema.Type.STRING)),
    Schema.Field.of("pincode", Schema.of(Schema.Type.INT)));

  private static final String VERSION = "3.2.0";
  private static final ArtifactVersion CURRENT_VERSION = new ArtifactVersion(VERSION);
  private static final ArtifactId BATCH_APP_ARTIFACT_ID = NamespaceId.DEFAULT.artifact("data-pipeline", VERSION);
  private static final ArtifactSummary ETLBATCH_ARTIFACT =
    new ArtifactSummary(BATCH_APP_ARTIFACT_ID.getArtifact(), BATCH_APP_ARTIFACT_ID.getVersion());
  private static final ArtifactRange BATCH_ARTIFACT_RANGE = new ArtifactRange(NamespaceId.DEFAULT.getNamespace(),
                                                                              "data-pipeline",
                                                                              CURRENT_VERSION, true,
                                                                              CURRENT_VERSION, true);


  @ClassRule
  public static TemporaryFolder temporaryFolder = new TemporaryFolder();
  private SolrClient client;

  @BeforeClass
  public static void setupTest() throws Exception {
    setupBatchArtifacts(BATCH_APP_ARTIFACT_ID, DataPipelineApp.class);

    Set<ArtifactRange> parents = ImmutableSet.of(BATCH_ARTIFACT_RANGE);

    // add Solr search plugins
    addPluginArtifact(NamespaceId.DEFAULT.artifact("solrsearch-plugins", "1.0.0"), parents,
                      SolrSearchSink.class, SolrSearchSinkConfig.class);
  }

  @Ignore
  public void testBatchSolrSearchSink() throws Exception {
    client = new HttpSolrClient("http://localhost:8983/solr/collection1");
    String inputDatasetName = "solr-batch-input-source";
    ETLStage source = new ETLStage("source", MockSource.getPlugin(inputDatasetName));

    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()
      .put(Constants.Reference.REFERENCE_NAME, "BatchSolrSink")
      .put("solrMode", SolrSearchSinkConfig.SINGLE_NODE_MODE)
      .put("solrHost", "localhost:8983")
      .put("collectionName", "collection1")
      .put("keyField", "id")
      .put("batchSize", "1000")
      .put("outputFieldMappings", "office address:address")
      .build();

    ETLStage sink = new ETLStage("SolrSink", new ETLPlugin("SolrSearch", BatchSink.PLUGIN_TYPE, sinkConfigproperties,
                                                           null));

    ETLBatchConfig etlConfig = ETLBatchConfig.builder("* * * * *")
      .addStage(source)
      .addStage(sink)
      .addConnection(source.getName(), sink.getName())
      .build();

    ApplicationId appId = NamespaceId.DEFAULT.app("testBatchSolrSink");
    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);
    ApplicationManager appManager = deployApplication(appId, appRequest);

    DataSetManager<Table> inputManager = getDataset(inputDatasetName);
    List<StructuredRecord> input = ImmutableList.of(
      StructuredRecord.builder(inputSchema).set("id", "1").set("firstname", "Brett").set("lastname", "Lee").set
        ("office address", "NE lake side").set("pincode", 480001).build(),
      StructuredRecord.builder(inputSchema).set("id", "2").set("firstname", "John").set("lastname", "Ray").set
        ("office address", "SE lake side").set("pincode", 480002).build()
    );
    MockSource.writeInput(inputManager, input);

    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);
    workflowManager.start();
    workflowManager.waitForRun(ProgramRunStatus.COMPLETED, 5, TimeUnit.MINUTES);

    QueryResponse queryResponse = client.query(new SolrQuery("*:*"));
    SolrDocumentList resultList = queryResponse.getResults();

    Assert.assertEquals(2, resultList.size());
    for (SolrDocument document : resultList) {
      if (document.get("id").equals("1")) {
        Assert.assertEquals("Brett", document.get("firstname"));
        Assert.assertEquals("Lee", document.get("lastname"));
        Assert.assertEquals("NE lake side", document.get("address"));
        Assert.assertEquals(480001, document.get("pincode"));
      } else {
        Assert.assertEquals("John", document.get("firstname"));
        Assert.assertEquals("Ray", document.get("lastname"));
        Assert.assertEquals("SE lake side", document.get("address"));
        Assert.assertEquals(480002, document.get("pincode"));
      }
    }
    // Clean the indexes
    client.deleteByQuery("*:*");
    client.commit();
    client.shutdown();
  }

  @Ignore
  public void testSolrCloudModeSink() throws Exception {
    CloudSolrClient cloudClient = new CloudSolrClient("localhost:2181");
    cloudClient.setDefaultCollection("collection1");

    String inputDatasetName = "solrcloud-batch-input-source";
    ETLStage source = new ETLStage("source", MockSource.getPlugin(inputDatasetName));

    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()
      .put(Constants.Reference.REFERENCE_NAME, "SolrCloudSink")
      .put("solrMode", SolrSearchSinkConfig.SOLR_CLOUD_MODE)
      .put("solrHost", "localhost:2181")
      .put("collectionName", "collection1")
      .put("keyField", "id")
      .put("batchSize", "1000")
      .put("outputFieldMappings", "office address:address")
      .build();

    ETLStage sink = new ETLStage("SolrSink", new ETLPlugin("SolrSearch", BatchSink.PLUGIN_TYPE, sinkConfigproperties,
                                                           null));

    ETLBatchConfig etlConfig = ETLBatchConfig.builder("* * * * *")
      .addStage(source)
      .addStage(sink)
      .addConnection(source.getName(), sink.getName())
      .build();

    ApplicationId appId = NamespaceId.DEFAULT.app("testBatchSolrCloudSink");
    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);
    ApplicationManager appManager = deployApplication(appId, appRequest);

    DataSetManager<Table> inputManager = getDataset(inputDatasetName);
    List<StructuredRecord> input = ImmutableList.of(
      StructuredRecord.builder(inputSchema).set("id", "1").set("firstname", "Brett").set("lastname", "Lee").set
        ("office address", "NE lake side").set("pincode", 480001).build(),
      StructuredRecord.builder(inputSchema).set("id", "2").set("firstname", "John").set("lastname", "Ray").set
        ("office address", "SE lake side").set("pincode", 480002).build()
    );
    MockSource.writeInput(inputManager, input);

    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);
    workflowManager.start();
    workflowManager.waitForRun(ProgramRunStatus.COMPLETED, 5, TimeUnit.MINUTES);

    QueryResponse queryResponse = cloudClient.query(new SolrQuery("*:*"));
    SolrDocumentList resultList = queryResponse.getResults();

    Assert.assertEquals(2, resultList.size());
    for (SolrDocument document : resultList) {
      if (document.get("id").equals("1")) {
        Assert.assertEquals("Brett", document.get("firstname"));
        Assert.assertEquals("Lee", document.get("lastname"));
        Assert.assertEquals("NE lake side", document.get("address"));
        Assert.assertEquals(480001, document.get("pincode"));
      } else {
        Assert.assertEquals("John", document.get("firstname"));
        Assert.assertEquals("Ray", document.get("lastname"));
        Assert.assertEquals("SE lake side", document.get("address"));
        Assert.assertEquals(480002, document.get("pincode"));
      }
    }
    // Clean the indexes
    cloudClient.deleteByQuery("*:*");
    cloudClient.commit();
    cloudClient.shutdown();
  }

  @Ignore
  public void testSolrSinkWithNullValues() throws Exception {
    Schema nullInputSchema = Schema.recordOf(
      "input-record",
      Schema.Field.of("id", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
      Schema.Field.of("firstname", Schema.of(Schema.Type.STRING)),
      Schema.Field.of("lastname", Schema.of(Schema.Type.STRING)),
      Schema.Field.of("office address", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
      Schema.Field.of("pincode", Schema.nullableOf(Schema.of(Schema.Type.INT))));

    client = new HttpSolrClient("http://localhost:8983/solr/collection1");
    String inputDatasetName = "input-source-with-null";
    ETLStage source = new ETLStage("source", MockSource.getPlugin(inputDatasetName));

    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()
      .put(Constants.Reference.REFERENCE_NAME, "BatchSolrSink")
      .put("solrMode", SolrSearchSinkConfig.SINGLE_NODE_MODE)
      .put("solrHost", "localhost:8983")
      .put("collectionName", "collection1")
      .put("keyField", "id")
      .put("batchSize", "100")
      .put("outputFieldMappings", "office address:address")
      .build();

    ETLStage sink = new ETLStage("SolrSink", new ETLPlugin("SolrSearch", BatchSink.PLUGIN_TYPE, sinkConfigproperties,
                                                           null));

    ETLBatchConfig etlConfig = ETLBatchConfig.builder("* * * * *")
      .addStage(source)
      .addStage(sink)
      .addConnection(source.getName(), sink.getName())
      .build();

    ApplicationId appId = NamespaceId.DEFAULT.app("testBatchSolrSink");
    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);
    ApplicationManager appManager = deployApplication(appId, appRequest);

    DataSetManager<Table> inputManager = getDataset(inputDatasetName);
    List<StructuredRecord> input = ImmutableList.of(
      StructuredRecord.builder(nullInputSchema).set("id", "1").set("firstname", "Brett").set("lastname", "Lee").set
        ("office address", "NE lake side").set("pincode", 480001).build(),
      StructuredRecord.builder(nullInputSchema).set("id", "2").set("firstname", "John").set("lastname", "Ray").set
        ("office address", "SE lake side").set("pincode", null).build(),
      StructuredRecord.builder(nullInputSchema).set("id", "3").set("firstname", "Johnny").set("lastname", "Wagh").set
        ("office address", "").set("pincode", 480003).build(),
      StructuredRecord.builder(nullInputSchema).set("id", "").set("firstname", "Michael").set("lastname", "Hussey").set
        ("office address", "WE Lake Side").set("pincode", 480004).build(),
      StructuredRecord.builder(nullInputSchema).set("id", null).set("firstname", "Michael").set("lastname", "Clarke")
        .set("office address", "WE Lake Side").set("pincode", 480005).build());
    MockSource.writeInput(inputManager, input);

    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);
    workflowManager.start();
    workflowManager.waitForRun(ProgramRunStatus.COMPLETED, 5, TimeUnit.MINUTES);

    QueryResponse queryResponse = client.query(new SolrQuery("*:*"));
    SolrDocumentList resultList = queryResponse.getResults();

    Assert.assertEquals(4, resultList.size());
    for (SolrDocument document : resultList) {
      if (document.get("id").equals("1")) {
        Assert.assertEquals("Brett", document.get("firstname"));
        Assert.assertEquals("Lee", document.get("lastname"));
        Assert.assertEquals("NE lake side", document.get("address"));
        Assert.assertEquals(480001, document.get("pincode"));
      } else if (document.get("id").equals("2")) {
        Assert.assertEquals("John", document.get("firstname"));
        Assert.assertEquals("Ray", document.get("lastname"));
        Assert.assertEquals("SE lake side", document.get("address"));
      } else if (document.get("id").equals("3")) {
        Assert.assertEquals("Johnny", document.get("firstname"));
        Assert.assertEquals("Wagh", document.get("lastname"));
        Assert.assertEquals("", document.get("address"));
        Assert.assertEquals(480003, document.get("pincode"));
      } else {
        Assert.assertEquals("Michael", document.get("firstname"));
        Assert.assertEquals("Hussey", document.get("lastname"));
        Assert.assertEquals("WE Lake Side", document.get("address"));
        Assert.assertEquals(480004, document.get("pincode"));
      }
    }
    // Clean the indexes
    client.deleteByQuery("*:*");
    client.commit();
    client.shutdown();
  }

  @Test
  public void testSolrConnectionWithWrongHost() throws Exception {
    String inputDatasetName = "input-source-with-wrong-host";
    ETLStage source = new ETLStage("source", MockSource.getPlugin(inputDatasetName));

    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()
      .put(Constants.Reference.REFERENCE_NAME, "BatchSolrSink")
      .put("solrMode", SolrSearchSinkConfig.SINGLE_NODE_MODE)
      .put("solrHost", "localhost:8984")
      .put("collectionName", "collection1")
      .put("keyField", "id")
      .put("batchSize", "1000")
      .put("outputFieldMappings", "office address:address")
      .build();

    ETLStage sink = new ETLStage("SolrSink", new ETLPlugin("SolrSearch", BatchSink.PLUGIN_TYPE, sinkConfigproperties,
                                                           null));

    ETLBatchConfig etlConfig = ETLBatchConfig.builder("* * * * *")
      .addStage(source)
      .addStage(sink)
      .addConnection(source.getName(), sink.getName())
      .build();

    ApplicationId appId = NamespaceId.DEFAULT.app("testBatchSolrSinkWrongHost");
    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);
    ApplicationManager appManager = deployApplication(appId, appRequest);

    DataSetManager<Table> inputManager = getDataset(inputDatasetName);
    List<StructuredRecord> input = ImmutableList.of(
      StructuredRecord.builder(inputSchema).set("id", "1").set("firstname", "Brett").set("lastname", "Lee").set
        ("office address", "NE lake side").set("pincode", 480001).build(),
      StructuredRecord.builder(inputSchema).set("id", "2").set("firstname", "John").set("lastname", "Ray").set
        ("office address", "SE lake side").set("pincode", 480002).build()
    );
    MockSource.writeInput(inputManager, input);

    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);
    workflowManager.start();
    workflowManager.waitForRuns(ProgramRunStatus.FAILED, 1, 5, TimeUnit.MINUTES);
  }

  @Test
  public void testSolrConnectionWithWrongCollection() throws Exception {
    String inputDatasetName = "input-source-with-wrong-collection";
    ETLStage source = new ETLStage("source", MockSource.getPlugin(inputDatasetName));

    Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()
      .put(Constants.Reference.REFERENCE_NAME, "BatchSolrSink")
      .put("solrMode", SolrSearchSinkConfig.SINGLE_NODE_MODE)
      .put("solrHost", "localhost:8983")
      .put("collectionName", "wrong_collection")
      .put("keyField", "id")
      .put("batchSize", "1000")
      .put("outputFieldMappings", "office address:address")
      .build();

    ETLStage sink = new ETLStage("SolrSink", new ETLPlugin("SolrSearch", BatchSink.PLUGIN_TYPE, sinkConfigproperties,
                                                           null));

    ETLBatchConfig etlConfig = ETLBatchConfig.builder("* * * * *")
      .addStage(source)
      .addStage(sink)
      .addConnection(source.getName(), sink.getName())
      .build();

    ApplicationId appId = NamespaceId.DEFAULT.app("testBatchSolrSink");
    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(ETLBATCH_ARTIFACT, etlConfig);
    ApplicationManager appManager = deployApplication(appId, appRequest);

    DataSetManager<Table> inputManager = getDataset(inputDatasetName);
    List<StructuredRecord> input = ImmutableList.of(
      StructuredRecord.builder(inputSchema).set("id", "1").set("firstname", "Brett").set("lastname", "Lee").set
        ("office address", "NE lake side").set("pincode", 480001).build(),
      StructuredRecord.builder(inputSchema).set("id", "2").set("firstname", "John").set("lastname", "Ray").set
        ("office address", "SE lake side").set("pincode", 480002).build()
    );
    MockSource.writeInput(inputManager, input);

    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);
    workflowManager.start();
    workflowManager.waitForRuns(ProgramRunStatus.FAILED, 1, 5, TimeUnit.MINUTES);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testInvalidSingleNodeSolrUrl() {
    SolrSearchSink.BatchSolrSearchConfig config = new SolrSearchSink.BatchSolrSearchConfig
      ("SolrSink", SolrSearchSinkConfig.SINGLE_NODE_MODE, "localhost:8983,localhost:8984", "collection1", "id",
       "office address:address", "1000");
    SolrSearchSink sinkObject = new SolrSearchSink(config);
    MockPipelineConfigurer configurer = new MockPipelineConfigurer(inputSchema);
    sinkObject.configurePipeline(configurer);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testWrongKeyFieldName() {
    SolrSearchSink.BatchSolrSearchConfig config = new SolrSearchSink.BatchSolrSearchConfig
      ("SolrSink", SolrSearchSinkConfig.SINGLE_NODE_MODE, "localhost:8983", "collection1", "wrong_id",
       "office address:address", "1000");
    SolrSearchSink sinkObject = new SolrSearchSink(config);
    MockPipelineConfigurer configurer = new MockPipelineConfigurer(inputSchema);
    sinkObject.configurePipeline(configurer);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testInvalidInputDataType() {
    Schema inputSchema = Schema.recordOf(
      "input-record",
      Schema.Field.of("id", Schema.of(Schema.Type.STRING)),
      Schema.Field.of("firstname", Schema.of(Schema.Type.STRING)),
      Schema.Field.of("lastname", Schema.of(Schema.Type.STRING)),
      Schema.Field.of("office address", Schema.of(Schema.Type.STRING)),
      Schema.Field.of("pincode", Schema.nullableOf(Schema.of(Schema.Type.BYTES))));

    SolrSearchSink.BatchSolrSearchConfig config = new SolrSearchSink.BatchSolrSearchConfig
      ("SolrSink", SolrSearchSinkConfig.SINGLE_NODE_MODE, "localhost:8983", "collection1", "id",
       "office address:address", "1000");
    SolrSearchSink sinkObject = new SolrSearchSink(config);
    MockPipelineConfigurer configurer = new MockPipelineConfigurer(inputSchema);
    sinkObject.configurePipeline(configurer);
  }
}
```


Overlapping Code:
```
SinkTest extends HydratorTestBase {
@ClassRule
public static final TestConfiguration CONFIG = new TestConfiguration("explore.enabled", false);
private static final Schema inputSchema = Schema.recordOf(
"input-record",
Schema.Field.of("id", Schema.of(Schema.Type.STRING)),
Schema.Field.of("firstname", Schema.of(Schema.Type.STRING)),
Schema.Field.of("lastname", Schema.of(Schema.Type.STRING)),
Schema.Field.of("office address", Schema.of(Schema.Type.STRING)),
Schema.Field.of("pincode", Schema.of(Schema.Type.INT)));
private static final String VERSION = "3.2.0";
private static final ArtifactVersion CURRENT_VERSION = new ArtifactVersion(VERSION);
private static final ArtifactId BATCH_APP_ARTIFACT_ID = NamespaceId.DEFAULT.artifact("data-pipeline", VERSION);
private static final ArtifactSummary ETLBATCH_ARTIFACT =
new ArtifactSummary(BATCH_APP_ARTIFACT_ID.getArtifact(), BATCH_APP_ARTIFACT_ID.getVersion());
private static final ArtifactRange BATCH_ARTIFACT_RANGE = new ArtifactRange(NamespaceId.DEFAULT.getNamespace(),
"data-pipeline",
CURRENT_VERSION, true,
CURRENT_VERSION, true);
@ClassRule
public static TemporaryFolder temporaryFolder = new TemporaryFolder();
private SolrClient client;
@BeforeClass
public static void setupTest() throws Exception {
setupBatchArtifacts(BATCH_APP_ARTIFACT_ID, DataPipelineApp.class);
Set<ArtifactRange> parents = ImmutableSet.of(BATCH_ARTIFACT_RANGE);
// add Solr search plugins
addPluginArtifact(NamespaceId.DEFAULT.artifact("solrsearch-plugins", "1.0.0"), parents,
SolrSearchSink.class, SolrSearchSinkConfig.class);
}
@Ignore
public void testBatchSolrSearchSink() throws Exception {
client = new HttpSolrClient("http://localhost:8983/solr/collection1");
String inputDatasetName = "solr-batch-input-source";
ETLStage source = new ETLStage("source", MockSource.getPlugin(inputDatasetName));
Map<String, String> sinkConfigproperties = new ImmutableMap.Builder<String, String>()
.put(Constants.Reference.REFERENCE_NAME, "BatchSolrSink")
.put("solrMode", SolrSearchSinkConfig.SINGLE_NODE_MODE)
.put("solrHost", "localhost:8983
```
<Overlap Ratio: 0.9745162812647475>

---

--- 197 --
Question ID: 65e74ee3e9925ca00ecd3fc6b91d22884711ed15
Original Code:
```
public class HotelAlertLinkCommand extends Command
{
    public HotelAlertLinkCommand()
    {
        super("cmd_hal",  Emulator.getTexts().getValue("commands.keys.cmd_hal").split(";"));
    }

    @Override
    public boolean handle(GameClient gameClient, String[] params) throws Exception
    {
        if (params.length < 3)
        {
            return true;
        }

        String url = params[1];
        String message = "";
        for (int i = 2; i < params.length; i++)
        {
            message += params[i];
            message += " ";
        }

        message += "\r\r-<b>" + gameClient.getHabbo().getHabboInfo().getUsername() + "</b>";

        Emulator.getGameServer().getGameClientManager().sendBroadcastResponse(new StaffAlertWithLinkComposer(message, url).compose());
        return true;
    }
}
```


Overlapping Code:
```
ds Command
{
public HotelAlertLinkCommand()
{
super("cmd_hal", Emulator.getTexts().getValue("commands.keys.cmd_hal").split(";"));
}
@Override
public boolean handle(GameClient gameClient, String[] params) throws Exception
{
if (params.length < 3)
{
return true;
}
String url = params[1];
String message = "";
for (int i = 2; i < params.length; i++)
{
message += params[i];
message += " ";
}
message += "\r\r-<b>" + gameClient.getHabbo().getHabboInfo().getUsername() + "</b>";
Emulator.getGameServer().getGameClientManager().sendBroadcastResponse(new StaffAlertWithLinkComposer(message, url).compose())
```
<Overlap Ratio: 0.9118541033434651>

---

--- 198 --
Question ID: 71a65321ec0f63aed23f71b557b8db6af86ff773
Original Code:
```
public class Client extends AbstractVerticle {

  // Convenience method so you can run it in your IDE
  public static void main(String[] args) {
    Runner.runExample(Client.class);
  }

  @Override
  public void start() throws Exception {

    JsonObject config = new JsonObject().put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver");

    JDBCClient jdbc = JDBCClient.createShared(vertx, config);

    // Connect to the database
    jdbc.rxGetConnection().flatMap(conn -> {

      // Now chain some statements using flatmap composition
      Single<ResultSet> resa = conn.rxUpdate("CREATE TABLE test(col VARCHAR(20))")
        .flatMap(result -> conn.rxUpdate("INSERT INTO test (col) VALUES ('val1')"))
        .flatMap(result -> conn.rxUpdate("INSERT INTO test (col) VALUES ('val2')"))
        .flatMap(result -> conn.rxQuery("SELECT * FROM test"));

      return resa.doAfterTerminate(conn::close);

    }).subscribe(resultSet -> {
      // Subscribe to the final result
      System.out.println("Results : " + resultSet.getRows());
    }, err -> {
      System.out.println("Database problem");
      err.printStackTrace();
    });
  }
}
```


Overlapping Code:
```
blic class Client extends AbstractVerticle {
// Convenience method so you can run it in your IDE
public static void main(String[] args) {
Runner.runExample(Client.class);
}
@Override
public void start() throws Exception {
JsonObject config = new JsonObject().put("url", "jdbc:hsqldb:mem:test?shutdown=true")
.put("driver_class", "org.hsqldb.jdbcDriver");
JDBCClient jdbc = JDBCClient.createShared(vertx, config);
// Connect to the database
jdbc.rxGetConnection().flatMap(conn -> {
// Now chain some statements using flatmap composition
Single<ResultSet> resa = conn.rxUpdate("CREATE TABLE test(col VARCHAR(20))")
.flatMap(result -> conn.rxUpdate("INSERT INTO test (col) VALUES ('val1')"))
.flatMap(result -> conn.rxUpdate("INSERT INTO test (col) VALUES ('val2')"))
.flatMap(result -> conn.rxQuery("SELECT * FROM test"));
return resa.doAfterTerminate(conn::close);
}).subscribe(resultSet -> {
// Subscribe to the final result
System.out.println("Results : " + resultSet.getRows());
}, err -> {
System.out.println("Database problem");
err.printStackTrace();
});
}

```
<Overlap Ratio: 0.9971830985915493>

---

--- 199 --
Question ID: 04823fde620e02dc1f7c7a2a9855556048c2029a
Original Code:
```
public class ExCursedWeaponLocation extends L2GameServerPacket
{
	private final List<CursedWeaponInfo> _cursedWeaponInfo;
	
	public ExCursedWeaponLocation(List<CursedWeaponInfo> cursedWeaponInfo)
	{
		_cursedWeaponInfo = cursedWeaponInfo;
	}
	
	@Override
	protected void writeImpl()
	{
		writeC(0xfe);
		writeH(0x47);
		
		if (!_cursedWeaponInfo.isEmpty())
		{
			writeD(_cursedWeaponInfo.size());
			for (CursedWeaponInfo w : _cursedWeaponInfo)
			{
				writeD(w.id);
				writeD(w.activated);
				
				writeD(w.pos.getX());
				writeD(w.pos.getY());
				writeD(w.pos.getZ());
			}
		}
		else
		{
			writeD(0);
			writeD(0);
		}
	}
	
	public static class CursedWeaponInfo
	{
		public Location pos;
		public int id;
		public int activated; // 0 - not activated ? 1 - activated
		
		public CursedWeaponInfo(Location p, int ID, int status)
		{
			pos = p;
			id = ID;
			activated = status;
		}
		
	}
}
```


Overlapping Code:
```
 class ExCursedWeaponLocation extends L2GameServerPacket
{
private final List<CursedWeaponInfo> _cursedWeaponInfo;

public ExCursedWeaponLocation(List<CursedWeaponInfo> cursedWeaponInfo)
{
_cursedWeaponInfo = cursedWeaponInfo;
}

@Override
protected void writeImpl()
{
writeC(0xfe);
writeH(0x47);

if (!_cursedWeaponInfo.isEmpty())
{
writeD(_cursedWeaponInfo.size());
for (CursedWeaponInfo w : _cursedWeaponInfo)
{
writeD(w.id);
writeD(w.activated);

writeD(w.pos.getX());
writeD(w.pos.getY());
writeD(w.pos.getZ());
}
}
else
{
writeD(0);
writeD(0);
}
}

public static class CursedWeaponInfo
{
public Location pos;
public int id;
public int activated; // 0 - not activated ? 1 - activated

public CursedWeaponInfo(Location p, int ID, int status)
{
pos = p;
id = 
```
<Overlap Ratio: 0.9548872180451128>

---

--- 200 --
Question ID: 2b57b96e136592281b17f49acc9e388761918984
Original Code:
```
class EmbeddedInternalConnectionPool {
    private final ConcurrentPool<EmbeddedInternalConnection> pool;
    private volatile boolean closed;

    EmbeddedInternalConnectionPool(final EmbeddedInternalConnectionFactory internalConnectionFactory) {
        this.pool = new ConcurrentPool<EmbeddedInternalConnection>(Integer.MAX_VALUE,
                new EmbeddedConnectionItemFactory(internalConnectionFactory));
    }

    InternalConnection get() {
        isTrue("Embedded connection pool is open", !closed);
        return getPooledConnection();
    }

    void close() {
        if (!closed) {
            pool.close();
            closed = true;
        }
    }

    private static class EmbeddedConnectionItemFactory implements ConcurrentPool.ItemFactory<EmbeddedInternalConnection> {
        private final EmbeddedInternalConnectionFactory internalConnectionFactory;

        EmbeddedConnectionItemFactory(final EmbeddedInternalConnectionFactory internalConnectionFactory) {
            this.internalConnectionFactory = internalConnectionFactory;
        }

        @Override
        public EmbeddedInternalConnection create(final boolean initialize) {
            return internalConnectionFactory.create();
        }

        @Override
        public void close(final EmbeddedInternalConnection embeddedInternalConnection) {
            embeddedInternalConnection.close();
        }

        @Override
        public ConcurrentPool.Prune shouldPrune(final EmbeddedInternalConnection embeddedInternalConnection) {
            return ConcurrentPool.Prune.NO;
        }
    }

    private InternalConnection getPooledConnection() {
        PooledConnection connection = new PooledConnection(pool.get());
        if (!connection.opened()) {
            connection.open();
        }
        return connection;
    }

    private class PooledConnection implements InternalConnection {
        private final EmbeddedInternalConnection wrapped;
        private final AtomicBoolean isClosed = new AtomicBoolean();

        PooledConnection(final EmbeddedInternalConnection wrapped) {
            this.wrapped = wrapped;
        }

        @Override
        public ConnectionDescription getDescription() {
            return wrapped.getDescription();
        }

        @Override
        public void open() {
            wrapped.open();
        }

        @Override
        public void openAsync(final SingleResultCallback<Void> callback) {
            wrapped.openAsync(callback);
        }

        @Override
        public void close() {
            // All but the first call is a no-op
            if (!isClosed.getAndSet(true)) {
                pool.release(wrapped, wrapped.isClosed());
            }
        }

        @Override
        public boolean opened() {
            return wrapped.opened();
        }

        @Override
        public boolean isClosed() {
            return wrapped.isClosed();
        }

        @Override
        public <T> T sendAndReceive(final CommandMessage message, final Decoder<T> decoder, final SessionContext sessionContext) {
            return wrapped.sendAndReceive(message, decoder, sessionContext);
        }

        @Override
        public <T> void sendAndReceiveAsync(final CommandMessage message, final Decoder<T> decoder, final SessionContext sessionContext,
                                            final SingleResultCallback<T> callback) {
            wrapped.sendAndReceiveAsync(message, decoder, sessionContext, callback);
        }

        @Override
        public void sendMessage(final List<ByteBuf> byteBuffers, final int lastRequestId) {
            wrapped.sendMessage(byteBuffers, lastRequestId);
        }

        @Override
        public ResponseBuffers receiveMessage(final int responseTo) {
            return wrapped.receiveMessage(responseTo);
        }

        @Override
        public void sendMessageAsync(final List<ByteBuf> byteBuffers, final int lastRequestId, final SingleResultCallback<Void> callback) {
            wrapped.sendMessageAsync(byteBuffers, lastRequestId, callback);
        }

        @Override
        public void receiveMessageAsync(final int responseTo, final SingleResultCallback<ResponseBuffers> callback) {
            wrapped.receiveMessageAsync(responseTo, callback);
        }

        @Override
        public ByteBuf getBuffer(final int size) {
            return wrapped.getBuffer(size);
        }
    }

}
```


Overlapping Code:
```
ol {
private final ConcurrentPool<EmbeddedInternalConnection> pool;
private volatile boolean closed;
EmbeddedInternalConnectionPool(final EmbeddedInternalConnectionFactory internalConnectionFactory) {
this.pool = new ConcurrentPool<EmbeddedInternalConnection>(Integer.MAX_VALUE,
new EmbeddedConnectionItemFactory(internalConnectionFactory));
}
InternalConnection get() {
isTrue("Embedded connection pool is open", !closed);
return getPooledConnection();
}
void close() {
if (!closed) {
pool.close();
closed = true;
}
}
private static class EmbeddedConnectionItemFactory implements ConcurrentPool.ItemFactory<EmbeddedInternalConnection> {
private final EmbeddedInternalConnectionFactory internalConnectionFactory;
EmbeddedConnectionItemFactory(final EmbeddedInternalConnectionFactory internalConnectionFactory) {
this.internalConnectionFactory = internalConnectionFactory;
}
@Override
public EmbeddedInternalConnection create(final boolean initialize) {
return internalConnectionFactory.create();
}
@Override
public void close(final EmbeddedInternalConnection embeddedInternalConnection) {
embeddedInternalConnection.close();
}
@Override
public ConcurrentPool.Prune shouldPrune(final EmbeddedInternalConnection embeddedInternalConnection) {
return ConcurrentPool.Prune.NO;
}
}
private InternalConnection getPooledConnection() {
PooledConnection connection = new PooledConnection(pool.get());
if (!connection.opened()) {
connection.open();
}
return connection;
}
private class PooledConnection implements InternalConnection {
private final EmbeddedInternalConnection wrapped;
private final AtomicBoolean isClosed = new AtomicBoolean();
PooledConnection(final EmbeddedInternalConnection wrapped) {
this.wrapped = wrapped;
}
@Override
public ConnectionDescription getDescription() {
return wrapped.getDescription();
}
@Override
public void open() {
wrapped.open();
}
@Override
public void openAsync(final SingleResultCallback<Void> callback) {
wrapped.op
```
<Overlap Ratio: 0.9730538922155688>

---

--- 201 --
Question ID: 80ee9eb9244a53e1a98ecd558017547a5c033cb8
Original Code:
```
public class Fit3DSiteAlignment implements Fit3D {

    private static final Logger logger = LoggerFactory.getLogger(Fit3DSiteAlignment.class);
    private static final int PERMUTATION_CUTOFF = 3;

    private final StructuralMotif site1;
    private final StructuralMotif site2;

    private final LinkedHashSet<List<LeafSubstructure<?>>> site1Partitions;
    private final LinkedHashSet<List<LeafSubstructure<?>>> site2Partitions;

    private final RepresentationScheme representationScheme;
    private final Predicate<Atom> atomFilter;
    private final double rmsdCutoff;
    private final double distanceTolerance;
    private final boolean exhaustive;
    private final boolean restrictToExchanges;
    private final SubstitutionMatrix substitutionMatrix;
    private final boolean containsNonAminoAcids;
    private final boolean kuhnMunkres;

    private final double cutoffScore;
    private final List<Fit3DMatch> matches;
    private int currentAlignmentSize;
    private LabeledRegularMatrix<List<LeafSubstructure<?>>> currentSimilarityMatrix;
    private Pair<List<LeafSubstructure<?>>> currentBestMatchingPair;
    private double currentBestScore;
    private SubstructureSuperimposition currentBestSuperimposition;
    private String alignmentString;
    private boolean cutoffScoreReached;
    private XieScore xieScore;
    private PsScore psScore;
    private List<Pair<LeafSubstructure<?>>> assignment;

    public Fit3DSiteAlignment(Fit3DBuilder.Builder builder) throws SubstructureSuperimpositionException {
        site1 = builder.site1.getCopy();
        site2 = builder.site2.getCopy();

        containsNonAminoAcids = site1.getAllLeafSubstructures().stream()
                .anyMatch(leafSubstructure -> !(leafSubstructure.getFamily() instanceof AminoAcidFamily)) ||
                site1.getAllLeafSubstructures().stream()
                        .anyMatch(leafSubstructure -> !(leafSubstructure.getFamily() instanceof AminoAcidFamily));

        if (containsNonAminoAcids) {
            logger.warn("sites contain non-amino acid residues, no Xie and PS-scores can be calculated");
        }

        exhaustive = builder.exhaustive;
        kuhnMunkres = builder.kuhnMunkres;
        restrictToExchanges = builder.restrictToExchanges;

        // add exchanges against arbitrary types if not restricted
        if (!restrictToExchanges) {
            logger.warn("specified exchanges will be ignored for the Fit3DSite alignment and matched types will be arbitrary");
        }

        currentAlignmentSize = 2;
        currentBestScore = Double.MAX_VALUE;

        logger.debug("calculating initial 2-partitions");
        site1Partitions = createInitialPartitions(site1);
        site2Partitions = createInitialPartitions(site2);

        cutoffScore = builder.cutoffScore;

        atomFilter = builder.atomFilter;
        representationScheme = builder.representationScheme;

        rmsdCutoff = builder.rmsdCutoff;
        distanceTolerance = builder.distanceTolerance;

        substitutionMatrix = builder.substitutionMatrix;

        // initialize
        matches = new ArrayList<>();

        logger.info("computing Fit3DSite alignment for {} (size: {}) against {} (size: {}) with cutoff score {}", site1,
                site1.size(), site2, site2.size(), cutoffScore);

        // combinatorial extension alignment if Kuhn-Munkres is not used
        if (!kuhnMunkres) {
            logger.debug("using combinatorial extension to find alignment");
            calculateSimilarities();
            extendAlignment();
        } else {
            logger.debug("using Kuhn-Munkres optimization with substitution matrix {} to find alignment", substitutionMatrix);
            calculateAssignment();
            calculateAlignment();
        }

        Collections.sort(matches);
    }

    @Override
    public PsScore getPsScore() {
        return psScore;
    }

    @Override
    public XieScore getXieScore() {
        return xieScore;
    }

    @Override
    public String getAlignmentString() {
        return alignmentString;
    }

    /**
     * Iteratively extends the alignment until a cutoff score is exceeded or one site is fully aligned.
     */
    private void extendAlignment() {

        // iteratively extend alignment
        while (currentBestScore <= cutoffScore) {
            // terminate if one site is fully aligned
            if (site1.size() == currentAlignmentSize || site2.size() == currentAlignmentSize) {
                logger.debug("alignment fully terminated after {} iterations", currentAlignmentSize);
                break;
            }
            // extent site partitions
            extendPartitions();
            // recalculate similarities
            calculateSimilarities();
            if (cutoffScoreReached) {
                logger.debug("alignment reached cutoff score of {}", cutoffScore);
                break;
            }
        }

        if (currentBestSuperimposition != null) {
            matches.add(Fit3DMatch.of(currentBestScore, currentBestSuperimposition));
            if (!containsNonAminoAcids) {
                calculateXieScore();
                calculatePsScore();
            }
            outputSummary();
        } else {
            logger.debug("no suitable alignment could be found");
        }
    }

    private void calculatePsScore() {
        psScore = PsScore.of(currentBestSuperimposition, site1.getNumberOfLeafSubstructures(),
                site2.getNumberOfLeafSubstructures());
    }

    /**
     * Calculates the ligand binding site similarity score according to dio:10.1093/bioinformatics/btp220.
     */
    private void calculateXieScore() {
        xieScore = XieScore.of(substitutionMatrix, currentBestSuperimposition);
    }

    /**
     * Writes the result (the best largest alignment) in string representation.
     */
    private void outputSummary() {
        StringJoiner site1Joiner = new StringJoiner("|", "|", "|");
        StringJoiner site2Joiner = new StringJoiner("|", "|", "|");
        for (int i = 0; i < currentAlignmentSize; i++) {
            site1Joiner.add(String.format("%-7s", currentBestSuperimposition.getReference().get(i).toString()));
            site2Joiner.add(String.format("%-7s", currentBestSuperimposition.getCandidate().get(i).toString()));
        }
        alignmentString = String.format("%-7s", "s1size") + "|" + site1.size() + "\n" +
                String.format("%-7s", "s2size") + "|" + site2.size() + "\n" +
                site1.getAllLeafSubstructures().stream()
                        .map(LeafSubstructure::toString)
                        .map(s1 -> String.format("%-7s", s1))
                        .collect(Collectors.joining("|", String.format("%-7s", "s1") + "|", "|")) + "\n" +
                site2.getAllLeafSubstructures().stream()
                        .map(LeafSubstructure::toString)
                        .map(s1 -> String.format("%-7s", s1))
                        .collect(Collectors.joining("|", String.format("%-7s", "s2") + "|", "|")) + "\n" +
                String.format("%-7s", "RMSD") + "|" + currentBestSuperimposition.getRmsd() + "\n" +
                String.format("%-7s", "frac") + "|" + getAlignedResidueFraction() + "\n" +
                String.format("%-7s", "XieS") + "|" + (containsNonAminoAcids ? "NaN" : getXieScore().getScore()) + "\n" +
                String.format("%-7s", "XieExp") + "|" + (containsNonAminoAcids ? "NaN" : getXieScore().getSignificance()) + "\n" +
                String.format("%-7s", "PsS") + "|" + (containsNonAminoAcids ? "NaN" : getPsScore().getScore()) + "\n" +
                String.format("%-7s", "PsExp") + "|" + (containsNonAminoAcids ? "NaN" : getPsScore().getSignificance()) + "\n" +
                String.format("%-7s", "s1algn") + site1Joiner.toString() + "\n" + String.format("%-7s", "s2algn") + site2Joiner.toString();
        logger.debug("aligned {} residues (site 1 contains {} residues and site 2 contains {} residues)\n{}",
                currentAlignmentSize, site1.size(), site2.size(), alignmentString);
    }

    /**
     * Returns the fraction of successfully aligned residues.
     *
     * @return The fraction of aligned residues.
     */
    private double getAlignedResidueFraction() {
        return (site1.size() > site2.size() ? currentAlignmentSize /
                (double) site2.size() : currentAlignmentSize / (double) site1.size());
    }

    /**
     * Extends the partitions of the sites in the current round.
     */
    private void extendPartitions() {

        // increment counter for current size of alignment
        currentAlignmentSize++;

        // remove all old partitions
        site1Partitions.clear();
        site2Partitions.clear();

        // create new partitions
        for (LeafSubstructure<?> leafSubstructure : site1.getAllLeafSubstructures()) {
            List<LeafSubstructure<?>> site1Partition = new ArrayList<>(currentBestMatchingPair.getFirst());
            if (!site1Partition.contains(leafSubstructure)) {
                site1Partition.add(leafSubstructure);
            }
            if (site1Partition.size() == currentAlignmentSize) {
                // permute up to exhaustive cutoff to find ideal alignment seed
                if (currentAlignmentSize <= PERMUTATION_CUTOFF && !exhaustive) {
                    StreamPermutations.of(site1Partition.toArray(new LeafSubstructure<?>[0]))
                            .map(s -> s.collect(Collectors.toList()))
                            .forEach(site1Partitions::add);
                } else {
                    site1Partitions.add(site1Partition);
                }
            }
        }
        for (LeafSubstructure<?> leafSubstructure : site2.getAllLeafSubstructures()) {
            List<LeafSubstructure<?>> site2Partition = new ArrayList<>(currentBestMatchingPair.getSecond());
            if (!site2Partition.contains(leafSubstructure)) {
                site2Partition.add(leafSubstructure);
            }
            if (site2Partition.size() == currentAlignmentSize) {
                // permute up to exhaustive cutoff to find ideal alignment seed
                if (currentAlignmentSize <= PERMUTATION_CUTOFF && !exhaustive) {
                    StreamPermutations.of(site2Partition.toArray(new LeafSubstructure<?>[0]))
                            .map(s -> s.collect(Collectors.toList()))
                            .forEach(site2Partitions::add);
                } else {
                    site2Partitions.add(site2Partition);
                }
            }
        }
    }

    /**
     * Calculates the similarity scores of the current round, either by naive superimposition or with a {@link
     * Fit3DAlignment} if exchanges are defined.
     */
    private void calculateSimilarities() throws SubstructureSuperimpositionException {

        // reset best score for new iteration
        double localBestScore = Double.MAX_VALUE;

        // initialize storage for best superimposition of round
        SubstructureSuperimposition localBestSuperimposition = null;

        double[][] temporarySimilarityMatrix = new double[site1Partitions.size()][site2Partitions.size()];

        List<List<LeafSubstructure<?>>> rowLabels = new ArrayList<>();
        List<List<LeafSubstructure<?>>> columnLabels = new ArrayList<>();
        int i = 0;
        for (List<LeafSubstructure<?>> site1Partition : site1Partitions) {
            rowLabels.add(site1Partition);
            int j = 0;
            for (List<LeafSubstructure<?>> site2Partition : site2Partitions) {
                if (!columnLabels.contains(site2Partition)) {
                    columnLabels.add(site2Partition);
                }

                // use Fit3D if exchanges should be considered, otherwise use exhaustive alignment
                if (restrictToExchanges) {
                    // align the subset of sites with Fit3D
                    StructuralMotif query = site1.getCopy();
                    List<LeafSubstructure> queryLeavesToBeRemoved = site1.getAllLeafSubstructures().stream()
                            .filter(leafSubstructure -> !site1Partition.contains(leafSubstructure))
                            .collect(Collectors.toList());
                    queryLeavesToBeRemoved.forEach(leafSubstructure -> query.removeLeafSubstructure(leafSubstructure.getIdentifier()));
                    StructuralMotif target = site2.getCopy();
                    List<LeafSubstructure> targetLeavesToBeRemoved = site2.getAllLeafSubstructures().stream()
                            .filter(leafSubstructure -> !site2Partition.contains(leafSubstructure))
                            .collect(Collectors.toList());
                    targetLeavesToBeRemoved.forEach(target::removeLeafSubstructure);

                    // configure Fit3D
                    Fit3D fit3d;
                    if (representationScheme != null) {
                        fit3d = Fit3DBuilder.create()
                                .query(query)
                                .target(target)
                                .representationScheme(representationScheme.getType())
                                .rmsdCutoff(rmsdCutoff)
                                .distanceTolerance(distanceTolerance)
                                .run();
                    } else {
                        fit3d = Fit3DBuilder.create()
                                .query(query)
                                .target(target)
                                .atomFilter(atomFilter)
                                .rmsdCutoff(rmsdCutoff)
                                .distanceTolerance(distanceTolerance)
                                .run();
                    }

                    // collect results
                    if (fit3d.getMatches().isEmpty()) {
                        temporarySimilarityMatrix[i][j] = Double.MAX_VALUE;
                    } else {
                        Fit3DMatch bestMatch = fit3d.getMatches().get(0);
                        double rmsd = bestMatch.getRmsd();
                        temporarySimilarityMatrix[i][j] = rmsd;
                        // test if current score is new global winner and cutoff is not exceeded
                        if (rmsd < localBestScore) {
                            localBestSuperimposition = bestMatch.getSubstructureSuperimposition();
                            localBestScore = rmsd;
                        }
                    }
                } else {
                    SubstructureSuperimposition superimposition;
                    if (representationScheme != null) {
                        if (exhaustive) {
                            superimposition = SubstructureSuperimposer
                                    .calculateIdealSubstructureSuperimposition(site1Partition, site2Partition, representationScheme);
                        } else {
                            superimposition = SubstructureSuperimposer
                                    .calculateSubstructureSuperimposition(site1Partition, site2Partition, representationScheme);
                        }
                    } else {
                        if (exhaustive) {
                            superimposition = SubstructureSuperimposer
                                    .calculateIdealSubstructureSuperimposition(site1Partition, site2Partition, atomFilter);
                        } else {
                            superimposition = SubstructureSuperimposer
                                    .calculateSubstructureSuperimposition(site1Partition, site2Partition, atomFilter);
                        }
                    }
                    double rmsd = superimposition.getRmsd();
                    temporarySimilarityMatrix[i][j] = rmsd;
                    if (rmsd < localBestScore) {
                        localBestSuperimposition = superimposition;
                        localBestScore = rmsd;
                    }
                }
                j++;
            }
            i++;
        }

        currentSimilarityMatrix = new LabeledRegularMatrix<>(temporarySimilarityMatrix);
        currentSimilarityMatrix.setRowLabels(rowLabels);
        currentSimilarityMatrix.setColumnLabels(columnLabels);

        logger.debug("current similarity matrix is \n{}", currentSimilarityMatrix.getStringRepresentation());

        // if the minimal element is ambiguous select the first
        List<Pair<Integer>> minimalScores = Matrices.getPositionsOfMinimalElement(currentSimilarityMatrix);
        if (!minimalScores.isEmpty()) {
            List<LeafSubstructure<?>> first = currentSimilarityMatrix.getRowLabel(minimalScores.get(0).getFirst());
            List<LeafSubstructure<?>> second = currentSimilarityMatrix.getColumnLabel(minimalScores.get(0).getSecond());
            // if the alignment terminates in the next round do not set new best matching pair and score
            double scoreValue = currentSimilarityMatrix.getValueFromPosition(minimalScores.get(0));
            if (scoreValue > cutoffScore) {
                logger.debug("cutoff score exceeded");
                currentAlignmentSize--;
                cutoffScoreReached = true;
                return;
            }
            currentBestMatchingPair = new Pair<>(first, second);
            currentBestScore = scoreValue;
            currentBestSuperimposition = localBestSuperimposition;
            logger.debug("current best matching pair of size {} is {} with RMSD {}", currentAlignmentSize,
                    currentBestMatchingPair, currentBestScore);
        } else {
            if (currentAlignmentSize == 2) {
                throw new Fit3DException("could not find minimal agreement of partitions in first iteration");
            }
            logger.debug("no suitable alignment found in iteration {}", currentAlignmentSize);
            currentAlignmentSize--;
            currentBestScore = Double.MAX_VALUE;
        }
    }

    /**
     * Creates the initial 2-partitions of the site alignment.
     *
     * @param structuralMotif The {@link StructuralMotif} for which the 2-partitions should be created.
     * @return The generated set of 2-partitions.
     */
    private LinkedHashSet<List<LeafSubstructure<?>>> createInitialPartitions(StructuralMotif structuralMotif) {
        LinkedHashSet<List<LeafSubstructure<?>>> partitions = new LinkedHashSet<>();
        List<LeafSubstructure<?>> leafSubstructures = structuralMotif.getAllLeafSubstructures();
        for (int i = 0; i < leafSubstructures.size() - 1; i++) {
            for (int j = i + 1; j < leafSubstructures.size(); j++) {
                List<LeafSubstructure<?>> partition1 = new ArrayList<>();
                partition1.add(leafSubstructures.get(i));
                partition1.add(leafSubstructures.get(j));
                partitions.add(partition1);
                if (!exhaustive) {
                    // add first permutation of elements
                    List<LeafSubstructure<?>> partition2 = new ArrayList<>();
                    partition2.add(leafSubstructures.get(j));
                    partition2.add(leafSubstructures.get(i));
                    partitions.add(partition2);
                }
            }
        }
        return partitions;
    }


    /**
     * Calculates the optimal assignment of the input sites using Kuhn-Munkres optimization and the given {@link SubstitutionMatrix}.
     */
    private void calculateAssignment() {
        double[][] costValues = new double[site1.size()][site2.size()];
        for (int i = 0; i < site1.getNumberOfLeafSubstructures(); i++) {
            for (int j = 0; j < site2.getNumberOfLeafSubstructures(); j++) {
                LeafSubstructure<?> residue1 = site1.getAllLeafSubstructures().get(i);
                LeafSubstructure<?> residue2 = site2.getAllLeafSubstructures().get(j);
                if (restrictToExchanges && residue1.getFamily() != residue2.getFamily()) {
                    // exchanges do not penalize the score
                    if (residue1.getExchangeableFamilies().contains(residue2.getFamily()) ||
                            residue2.getExchangeableFamilies().contains(residue1.getFamily())) {
                        continue;
                    }
                    costValues[i][j] = Double.MAX_VALUE;
                    continue;
                }
                costValues[i][j] = substitutionMatrix.getMatrix().getValueForLabel(residue1.getFamily(), residue2.getFamily());
            }
        }
        LabeledMatrix<LeafSubstructure<?>> costMatrix = new LabeledRegularMatrix<>(costValues);
        costMatrix.setRowLabels(site1.getAllLeafSubstructures());
        costMatrix.setColumnLabels(site2.getAllLeafSubstructures());

        KuhnMunkres<LeafSubstructure<?>> kuhnMunkres = new KuhnMunkres<>(costMatrix);
        assignment = kuhnMunkres.getAssignedPairs();

        // remove last assigned pair if strong restriction to exchanges is desired
        if (restrictToExchanges) {
            assignment.remove(assignment.size() - 1);
        }

        String assignmentString = kuhnMunkres.getAssignedPairs().stream()
                .map(pair -> pair.getFirst() + "+" + pair.getSecond() + ":" + costMatrix.getValueForLabel(pair.getFirst(), pair.getSecond()))
                .collect(Collectors.joining("\n"));

        logger.debug("optimal assignment of binding sites is:\n{}", assignmentString);
    }


    /**
     * Calculates the alignment of sites based on the Kuhn-Munkres assignment.
     */
    private void calculateAlignment() {
        List<LeafSubstructure<?>> reference = assignment.stream()
                .map(Pair::getFirst)
                .collect(Collectors.toList());
        List<LeafSubstructure<?>> candidate = assignment.stream()
                .map(Pair::getSecond)
                .collect(Collectors.toList());
        currentAlignmentSize = reference.size();
        if (representationScheme != null) {
            currentBestSuperimposition = SubstructureSuperimposer.calculateSubstructureSuperimposition(reference, candidate, representationScheme);
        } else {
            currentBestSuperimposition = SubstructureSuperimposer.calculateSubstructureSuperimposition(reference, candidate, atomFilter);
        }
        currentBestScore = currentBestSuperimposition.getRmsd();
        matches.add(Fit3DMatch.of(currentBestSuperimposition.getRmsd(), currentBestSuperimposition));
        if (!containsNonAminoAcids) {
            calculateXieScore();
            calculatePsScore();
        }
        outputSummary();
    }


    @Override
    public void writeMatches(Path outputDirectory) {
        if (matches.isEmpty()) {
            throw new Fit3DException("cannot write matches as they are currently empty");
        }
        SubstructureSuperimposition bestSuperimposition = matches.get(0).getSubstructureSuperimposition();
        List<LeafSubstructure<?>> mappedSite2 = bestSuperimposition.applyTo(site2.getCopy().getAllLeafSubstructures());
        try {
            StructureWriter.writeLeafSubstructures(site1.getAllLeafSubstructures(),
                    outputDirectory.resolve(site1.getAllLeafSubstructures().stream()
                            .sorted(Comparator.comparing(LeafSubstructure::getIdentifier))
                            .map(leafSubstructure -> leafSubstructure.getChainIdentifier() + "-"
                                    + leafSubstructure.getIdentifier().getSerial())
                            .collect(Collectors.joining("_", bestSuperimposition.getFormattedRmsd() + "_"
                                    + site1.getAllLeafSubstructures().get(0).getPdbIdentifier()
                                    + "_", "")) + "_site1.pdb"));
            StructureWriter.writeLeafSubstructures(mappedSite2,
                    outputDirectory.resolve(site2.getAllLeafSubstructures().stream()
                            .sorted(Comparator.comparing(LeafSubstructure::getIdentifier))
                            .map(leafSubstructure -> leafSubstructure.getChainIdentifier() + "-"
                                    + leafSubstructure.getIdentifier().getSerial())
                            .collect(Collectors.joining("_", bestSuperimposition.getFormattedRmsd() + "_"
                                    + site2.getAllLeafSubstructures().get(0).getPdbIdentifier()
                                    + "_", "")) + "_site2.pdb"));
        } catch (IOException e) {
            logger.error("error writing Fit3DSite results", e);
        }
    }

    @Override
    public List<Fit3DMatch> getMatches() {
        return matches;
    }

    /**
     * Returns the fraction of aligned residues, in respect to the smaller site.
     */
    @Override
    public double getFraction() {
        return getAlignedResidueFraction();
    }
}
```


Overlapping Code:
```
plements Fit3D {
private static final Logger logger = LoggerFactory.getLogger(Fit3DSiteAlignment.class);
private static final int PERMUTATION_CUTOFF = 3;
private final StructuralMotif site1;
private final StructuralMotif site2;
private final LinkedHashSet<List<LeafSubstructure<?>>> site1Partitions;
private final LinkedHashSet<List<LeafSubstructure<?>>> site2Partitions;
private final RepresentationScheme representationScheme;
private final Predicate<Atom> atomFilter;
private final double rmsdCutoff;
private final double distanceTolerance;
private final boolean exhaustive;
private final boolean restrictToExchanges;
private final SubstitutionMatrix substitutionMatrix;
private final boolean containsNonAminoAcids;
private final boolean kuhnMunkres;
private final double cutoffScore;
private final List<Fit3DMatch> matches;
private int currentAlignmentSize;
private LabeledRegularMatrix<List<LeafSubstructure<?>>> currentSimilarityMatrix;
private Pair<List<LeafSubstructure<?>>> currentBestMatchingPair;
private double currentBestScore;
private SubstructureSuperimposition currentBestSuperimposition;
private String alignmentString;
private boolean cutoffScoreReached;
private XieScore xieScore;
private PsScore psScore;
private List<Pair<LeafSubstructure<?>>> assignment;
public Fit3DSiteAlignment(Fit3DBuilder.Builder builder) throws SubstructureSuperimpositionException {
site1 = builder.site1.getCopy();
site2 = builder.site2.getCopy();
containsNonAminoAcids = site1.getAllLeafSubstructures().stream()
.anyMatch(leafSubstructure -> !(leafSubstructure.getFamily() instanceof AminoAcidFamily)) ||
site1.getAllLeafSubstructures().stream()
.anyMatch(leafSubstructure -> !(leafSubstructure.getFamily() instanceof AminoAcidFamily));
if (containsNonAminoAcids) {
logger.warn("sites contain non-amino acid residues, no Xie and PS-scores can be calculated");
}
exhaustive = builder.exhaustive;
kuhnMunkres = builder.kuhnMunkres;
restrictToExchanges = builder.restrictToExchanges;
// add exchanges against arbitrary types if not restricted
if (!restrictToExchanges) {
logger.warn("specified exchanges will be ignored for the Fit3DSite alignment and mat
```
<Overlap Ratio: 0.9706546275395034>

---

--- 202 --
Question ID: 83345c1805fa18f74e369b316c42d29cce7aea48
Original Code:
```
public class LaunchTests {
	public static void main(String[] args) {
		List<EARMARKTest> tests = new ArrayList<EARMARKTest>();
		
		tests.add(new DocumentCreation());
		tests.add(new DocumentStructure());
		tests.add(new ModifyingDocument(DocumentCreation.getDocument()));
		tests.add(new ModifyingDocument(DocumentStructure.getDocument()));
		tests.add(new EqualityTest(DocumentStructure.getDocument(), DocumentStructure.getDocument()
				, true, true, true));
		tests.add(new EqualityTest(DocumentCreation.getDocument(), DocumentStructure.getDocument()
				, false, false, false));
		tests.add(new EqualityTest(
				EqualityTest.getDocumentWithDifferentDocumentId(), 
				DocumentStructure.getDocument()
				, false, true, true));
		tests.add(new EqualityTest(
				EqualityTest.getDocumentWithDifferentIds(), 
				DocumentStructure.getDocument()
				, false, true, true));
		tests.add(new EqualityTest(
				EqualityTest.getDocumentWithDifferentDocumentIdAndStructure(), 
				DocumentStructure.getDocument()
				, false, false, false));
		tests.add(new LoadTest());
		tests.add(new StoreTest(DocumentStructure.getDocument()));
		tests.add(new FrancescoPoggiTestOne(DocumentCreation.getDocument()));
		
		for (EARMARKTest test : tests) {
			System.out.print("\n*** BEGIN: " + test.getTestName() + " ***\n");
			for (String result : test.doTest()) {
				System.out.println(result);
			}
			System.out.print("*** END: " + test.getTestName() + " ***\n");
		}
	}
}
```


Overlapping Code:
```
ests {
public static void main(String[] args) {
List<EARMARKTest> tests = new ArrayList<EARMARKTest>();

tests.add(new DocumentCreation());
tests.add(new DocumentStructure());
tests.add(new ModifyingDocument(DocumentCreation.getDocument()));
tests.add(new ModifyingDocument(DocumentStructure.getDocument()));
tests.add(new EqualityTest(DocumentStructure.getDocument(), DocumentStructure.getDocument()
, true, true, true));
tests.add(new EqualityTest(DocumentCreation.getDocument(), DocumentStructure.getDocument()
, false, false, false));
tests.add(new EqualityTest(
EqualityTest.getDocumentWithDifferentDocumentId(), 
DocumentStructure.getDocument()
, false, true, true));
tests.add(new EqualityTest(
EqualityTest.getDocumentWithDifferentIds(), 
DocumentStructure.getDocument()
, false, true, true));
tests.add(new EqualityTest(
EqualityTest.getDocumentWithDifferentDocumentIdAndStructure(), 
DocumentStructure.getDocument()
, false, false, false));
tests.add(new LoadTest());
tests.add(new StoreTest(DocumentStructure.getDocument()));
tests.add(new FrancescoPoggiTestOne(DocumentCreation.getDocument()));

for (EARMARKTest test : tests) {
System.out.print("\n*** BEGIN: " + test.getTestName() + " ***\n");
for (String result : test.doTest()) {
System.out.println(result);
}
System.out.print("*** END: " + test.getTestNam
```
<Overlap Ratio: 0.969208211143695>

---

--- 203 --
Question ID: 8d5d2aa1c5437270ff72fac18474b7e3bc416c04
Original Code:
```
public class LevelChangesScriptEvent extends ScriptEvent {

    // <--[event]
    // @Since 0.3.0
    // @Events
    // level changes
    //
    // @Updated 2017/10/16
    //
    // @Cancellable true
    //
    // @Group Player
    //
    // @Triggers when a player's level changes.
    //
    // @Warning This event does not trigger in Sponge during last testing.
    //
    // @Switch world (WorldTag) checks the world.
    // @Switch cuboid (CuboidTag) checks the cuboid area.
    // @Switch weather (TextTag) checks the weather.
    //
    // @Context
    // player (PlayerTag) returns the player that changed level.
    // old_level (IntegerTag) returns the old level value.
    // new_level (IntegerTag) returns the new level value.
    //
    // @Determinations
    // level (IntegerTag) sets the new level value.
    // -->

    @Override
    public String getName() {
        return "LevelChanges";
    }

    @Override
    public boolean couldMatch(ScriptEventData data) {
        return data.eventPath.startsWith("level changes");
    }

    @Override
    public boolean matches(ScriptEventData data) {
        return D2SpongeEventHelper.checkWorld(player.getOnline(this::error).getLocation().getExtent(), data, this::error)
                && D2SpongeEventHelper.checkCuboid((new LocationTag(player.getOnline(this::error)
                .getLocation())).getInternal(), data, this::error)
                && D2SpongeEventHelper.checkWeather(Utilities.getIdWithoutDefaultPrefix(
                player.getOnline(this::error).getLocation().getExtent().getWeather().getId()), data, this::error);
    }

    public PlayerTag player;

    public IntegerTag old_level;

    public IntegerTag new_level;

    public ChangeLevelEvent.TargetPlayer internal;

    @Override
    public HashMap<String, AbstractTagObject> getDefinitions(ScriptEventData data) {
        HashMap<String, AbstractTagObject> defs = super.getDefinitions(data);
        defs.put("player", player);
        defs.put("old_level", old_level);
        defs.put("new_level", new_level);
        return defs;
    }

    @Override
    public void enable() {
        Sponge.getEventManager().registerListeners(Denizen2Sponge.instance, this);
    }

    @Override
    public void disable() {
        Sponge.getEventManager().unregisterListeners(this);
    }

    @Listener
    public void onLevelChanges(ChangeLevelEvent.TargetPlayer evt, @Root Player player) {
        LevelChangesScriptEvent event = (LevelChangesScriptEvent) clone();
        event.internal = evt;
        event.player = new PlayerTag(player);
        event.old_level = new IntegerTag(evt.getOriginalLevel());
        event.new_level = new IntegerTag(evt.getLevel());
        event.cancelled = evt.isCancelled();
        event.run();
        evt.setCancelled(event.cancelled);
    }

    @Override
    public void applyDetermination(boolean errors, String determination, AbstractTagObject value) {
        if (determination.equals("level")) {
            IntegerTag it = IntegerTag.getFor(this::error, value);
            new_level = it;
            internal.setLevel((int) it.getInternal());
        }
        else {
            super.applyDetermination(errors, determination, value);
        }
    }
}
```


Overlapping Code:
```
public class LevelChangesScriptEvent extends ScriptEvent {
// <--[event]
// @Since 0.3.0
// @Events
// level changes
//
// @Updated 2017/10/16
//
// @Cancellable true
//
// @Group Player
//
// @Triggers when a player's level changes.
//
// @Warning This event does not trigger in Sponge during last testing.
//
// @Switch world (WorldTag) checks the world.
// @Switch cuboid (CuboidTag) checks the cuboid area.
// @Switch weather (TextTag) checks the weather.
//
// @Context
// player (PlayerTag) returns the player that changed level.
// old_level (IntegerTag) returns the old level value.
// new_level (IntegerTag) returns the new level value.
//
// @Determinations
// level (IntegerTag) sets the new level value.
// -->
@Override
public String getName() {
return "LevelChanges";
}
@Override
public boolean couldMatch(ScriptEventData data) {
return data.eventPath.startsWith("level changes");
}
@Override
public boolean matches(ScriptEventData data) {
return D2SpongeEventHelper.checkWorld(player.getOnline(this::error).getLocation().getExtent(), data, this::error)
&& D2SpongeEventHelper.checkCuboid((new LocationTag(player.getOnline(this::error)
.getLocation())).getInternal(), data, this::error)
&& D2SpongeEventHelper.checkWeather(Utilities.getIdWithoutDefaultPrefix(
player.getOnline(this::error).getLocation().getExtent().getWeather().getId()), data, this::error);
}
public PlayerTag player;
public IntegerTag old_level;
public IntegerTag new_level;
public ChangeLevelEvent.TargetPlayer internal;
@Override
public HashMap<String, AbstractTagObject> getDefinitions(ScriptEventData data) {
HashMap<String, AbstractTagObject> defs = super.getDefinitions(data);
defs.put("player", player);
defs.put("old_level", old_level);
defs.put("new_level", new_level);
return defs;
}
@Override
public void enable() {
Sponge.getEventManager().registerListeners(Denizen2Sponge.instance, this);
}
@Override
public void disable() {
Sponge.getEventManager().unregisterListeners(this);
}
@Listener
public void onLevelChanges(ChangeLevelEvent.TargetPlayer evt, @Ro
```
<Overlap Ratio: 0.9941804073714839>

---

--- 204 --
Question ID: 6c84bf0abda2a21e54a9c10a2328fd24ecf0eb35
Original Code:
```
@With(Secure.class)
public class Admin extends Controller {
    
    @Before
    static void setConnectedUser() {
        if(Security.isConnected()) {
            User user = User.findUnique("email=?", Security.connected());
            renderArgs.put("user", user.getFullname());
        }
    }
 
    public static void index() {
        List<Post> posts = Post.<Post>find("author.email=?", Security.connected()).findList();
        render(posts);
    }
    
    public static void form(Long id) {
        if(id != null) {
            Post post = Post.findById(id);
            render(post);
        }
        render();
    }
    
    public static void save(Long id, String title, String content, String tags) {
        Post post;
        if(id == null) {
            // Create post
            User author = User.findUnique("email=?", Security.connected());
            post = new Post(author, title, content);
        } else {
            // Retrieve post
            post = Post.findById(id);
            post.setTitle(title);
            post.setContent(content);
            post.getTags().clear();
        }
        // Set tags list
        for(String tag : tags.split("\\s+")) {
            if(tag.trim().length() > 0) {
                post.getTags().add(Tag.findOrCreateByName(tag));
            }
        }
        // Validate
        validation.valid(post);
        if(validation.hasErrors()) {
            render("@form", post);
        }
        // Save
        post.save();
        index();
    }
    
}
```


Overlapping Code:
```
h(Secure.class)
public class Admin extends Controller {

@Before
static void setConnectedUser() {
if(Security.isConnected()) {
User user = User.findUnique("email=?", Security.connected());
renderArgs.put("user", user.getFullname());
}
}

public static void index() {
List<Post> posts = Post.<Post>find("author.email=?", Security.connected()).findList();
render(posts);
}

public static void form(Long id) {
if(id != null) {
Post post = Post.findById(id);
render(post);
}
render();
}

public static void save(Long id, String title, String content, String tags) {
Post post;
if(id == null) {
// Create post
User author = User.findUnique("email=?", Security.connected());
post = new Post(author, title, content);
} else {
// Retrieve post
post = Post.findById(id);
post.setTitle(title);
post.setContent(content);
post.getTags().clear();
}
// Set tags list
for(String tag : tags.split("\\s+")) {
if(tag.trim().length() > 0) {
post.getTags().add(Tag.findOrCreateByName(tag));
}
}
// Validate
validation.valid(post);
if(validation.hasErrors()) {
render("@form", post);
}
/
```
<Overlap Ratio: 0.9664551223934723>

---

--- 205 --
Question ID: b30acd33e1c62c5c5c15ee0305d99909dc3acfde
Original Code:
```
@ApplicationScoped
public class WsValidationErrorConverter {

    public WsViolationError toWsValidationError(ConstraintViolation constraintViolation) {
        String propertyPath = constraintViolation.getPropertyPath().toString();
        String messageTemplate = constraintViolation.getMessageTemplate();

        WsViolationError validationError = new WsViolationError(propertyPath, messageTemplate);
        return validationError;
    }
}
```


Overlapping Code:
```
icationScoped
public class WsValidationErrorConverter {
public WsViolationError toWsValidationError(ConstraintViolation constraintViolation) {
String propertyPath = constraintViolation.getPropertyPath().toString();
String messageTemplate = constraintViolation.getMessageTemplate();
WsViolationError validationError = new WsViolationError(propertyPath, 
```
<Overlap Ratio: 0.8756218905472637>

---

--- 206 --
Question ID: b18275f4e892e5e3b1039b05a4408790c98bda11
Original Code:
```
public class DefaultResultSet extends AbstractResultSet {

	private final static java.util.logging.Logger logger = java.util.logging.Logger.getLogger(
		DefaultResultSet.class.getName()
	);

	private boolean logContent = true;


	public DefaultResultSet(final String[] columnNames, final List<Object[]> rows) {

		logger.info(()->
			"DefaultResultSet(), rows.size: [" + (rows != null? rows.size(): null) +
			"], logContent: [" + logContent + "]"
		);

		this.columnNames = columnNames;

		if (logContent) {
			for (String columnName: columnNames) {
				logger.info(()-> "\tcolumnName: [" + columnName + "]");
			}
		}

		this.rows.addAll(rows);

		for (int i = 0; i < rows.size(); i++) {

			final Object[] row = rows.get(i);

			final StringBuilder line = new StringBuilder();

			for (Object item: row) {
				if (line.length() > 0)
					line.append(", ");
				line.append(item);
			}

			if (logContent)
				logger.info("\trow[" + i + "]: " + line);
		}
	}


	private int position = -1;

	private final String[] columnNames;
	private final List<Object[]> rows = new ArrayList<>();


	@Override
	public boolean next() throws SQLException {

		position++;

		if (position >= rows.size())
			return false;

		return true;
	}


	private boolean closed = false;

	@Override
	public void close() throws SQLException {
		closed = true;
	}


	@Override
	public String getString(final String columnLabel) throws SQLException {

		final Object value = getCurrentRow()[getColumnIndexByColumnName(columnLabel)];

		wasNullFlag = (value == null);

		return (value != null? value.toString(): null);
	}

	// XXX not used by hibernate
	@Override
	public String getString(final int columnIndex) throws SQLException {

		final Object value = getCurrentRow()[columnIndex - 1];

		wasNullFlag = (value == null);

		return (value != null? value.toString(): null);
	}

	// XXX not used by hibernate
	@Override
	public Object getObject(final int columnIndex) throws SQLException {
		return getCurrentRow()[columnIndex - 1];
	}



	protected int getColumnIndexByColumnName(final String columnName) {

		for (int i = 0; i < columnNames.length; i++) {
			if (isEqual(columnNames[i], columnName))
				return i;
		}

		throw new IllegalArgumentException("cannot find column [" + columnName + "]");
	}


	protected boolean isEqual(final Object item0, final Object item1) {
		if ((item0 == null) && (item1 == null))
			return true;

		if ((item0 == null) || (item1 == null))
			return false;

		return item0.equals(item1);
	}


	protected Object[] getCurrentRow() {

		if (position < 0)
			throw new IllegalArgumentException("position is < 0: [" + position + "]");

		if (position >= rows.size())
			throw new IllegalArgumentException("position > rows.size: [" + position + ", " + rows.size() + "]");

		return rows.get(position);
	}


	@Override
	public short getShort(final String columnLabel) throws SQLException {

		final Short result = (Short) getCurrentRow()[getColumnIndexByColumnName(columnLabel)];

		wasNullFlag = (result == null);

		if (result == null)
			return -1;

		return result.shortValue();
	}

	@Override
	public int getInt(final String columnLabel) throws SQLException {

		final Integer result = (Integer) getCurrentRow()[getColumnIndexByColumnName(columnLabel)];

		wasNullFlag = (result == null);

		if (result == null)
			return -1;

		return result.intValue();
	}

	// XXX not used by hibernate
	@Override
	public int getInt(final int columnIndex) throws SQLException {

		final Integer result = (Integer) getCurrentRow()[columnIndex - 1];

		wasNullFlag = (result == null);

		if (result == null)
			return -1;

		return result.intValue();
	}


	@Override
	public long getLong(final String columnLabel) throws SQLException {

		final Number result = (Number) getCurrentRow()[getColumnIndexByColumnName(columnLabel)];

		wasNullFlag = (result == null);

		if (result == null)
			return -1;

		return result.longValue();
	}

	// XXX not used by hibernate
	@Override
	public long getLong(final int columnIndex) throws SQLException {

		final Number result = (Number) getCurrentRow()[columnIndex - 1];

		wasNullFlag = (result == null);

		if (result == null)
			return -1;

		return result.longValue();
	}


	@Override
	public ResultSetMetaData getMetaData() throws SQLException {
		return new DefaultResultSetMetaData(
			columnNames
		);
	}

	
	private boolean wasNullFlag = false;

	// XXX not used by hibernate
	@Override
	public boolean wasNull() throws SQLException {
		return wasNullFlag;
	}

}
```


Overlapping Code:
```
 class DefaultResultSet extends AbstractResultSet {
private final static java.util.logging.Logger logger = java.util.logging.Logger.getLogger(
DefaultResultSet.class.getName()
);
private boolean logContent = true;
public DefaultResultSet(final String[] columnNames, final List<Object[]> rows) {
logger.info(()->
"DefaultResultSet(), rows.size: [" + (rows != null? rows.size(): null) +
"], logContent: [" + logContent + "]"
);
this.columnNames = columnNames;
if (logContent) {
for (String columnName: columnNames) {
logger.info(()-> "\tcolumnName: [" + columnName + "]");
}
}
this.rows.addAll(rows);
for (int i = 0; i < rows.size(); i++) {
final Object[] row = rows.get(i);
final StringBuilder line = new StringBuilder();
for (Object item: row) {
if (line.length() > 0)
line.append(", ");
line.append(item);
}
if (logContent)
logger.info("\trow[" + i + "]: " + line);
}
}
private int position = -1;
private final String[] columnNames;
private final List<Object[]> rows = new ArrayList<>();
@Override
public boolean next() throws SQLException {
position++;
if (position >= rows.size())
return false;
return true;
}
private boolean closed = false;
@Override
public void close() throws SQLException {
closed = true;
}
@Override
public String getString(final String columnLabel) throws SQLException {
final Object value = getCurrentRow()[getColumnIndexByColumnName(columnLabel)];
wasNullFlag = (value == null);
return (value != null? value.toString(): null);
}
// XXX not used by hibernate
@Override
public String getString(final int columnIndex) throws SQLException {
final Object value = getCurrentRow()[columnIndex - 1];
wasNullFlag = (value == null);
return (value != null? value.toString(): null);
}
// XXX not used by hibernate
@Override
public Object getObject(final int columnIndex) throws SQLException {
return getCurrentRow()[columnIndex - 1];
}
protected int getColumnIndexByColumnName(final String columnName) {
for (int i = 0; i < columnNames.length; i++) {
if (isEqual(columnNames[i], columnName))
return i;
}
throw new IllegalArgumentException("cannot find column [" + columnName + "]");
}
protected boolean isEqual(final Object item0, final Object item1) {
if ((item0 == null) && (item1 == null))
return true;
if ((item0 == null) || (item1 == null))
return false;
return item
```
<Overlap Ratio: 0.9896103896103896>

---

--- 207 --
Question ID: 7b5a50330b3bf53c555e9dfa8837c89a0f3367cc
Original Code:
```
public class ShowInstancesFromClassesViewAction extends ShowInstancesAction {
  private static final String POPUP_ELEMENT_LABEL = "Show Instances";

  @Override
  protected void perform(AnActionEvent e) {
    final Project project = e.getProject();
    final ReferenceType selectedClass = getSelectedClass(e);
    if (project != null && selectedClass != null) {
      final XDebugSession debugSession = XDebuggerManager.getInstance(project).getCurrentSession();
      if (debugSession != null) {
        new InstancesWindow(debugSession, limit -> selectedClass.instances(limit), selectedClass.name()).show();
      }
    }
  }

  @Override
  protected String getLabel() {
    return POPUP_ELEMENT_LABEL;
  }

  @Override
  protected int getInstancesCount(AnActionEvent e) {
    ClassesTable.ReferenceCountProvider countProvider = e.getData(ClassesTable.REF_COUNT_PROVIDER_KEY);
    ReferenceType selectedClass = getSelectedClass(e);
    if (countProvider == null || selectedClass == null) {
      return -1;
    }

    return countProvider.getTotalCount(selectedClass);
  }
}
```


Overlapping Code:
```
lass ShowInstancesFromClassesViewAction extends ShowInstancesAction {
private static final String POPUP_ELEMENT_LABEL = "Show Instances";
@Override
protected void perform(AnActionEvent e) {
final Project project = e.getProject();
final ReferenceType selectedClass = getSelectedClass(e);
if (project != null && selectedClass != null) {
final XDebugSession debugSession = XDebuggerManager.getInstance(project).getCurrentSession();
if (debugSession != null) {
new InstancesWindow(debugSession, limit -> selectedClass.instances(limit), selectedClass.name()).show();
}
}
}
@Override
protected String getLabel() {
return POPUP_ELEMENT_LABEL;
}
@Override
protected int getInstancesCount(AnActionEvent e) {
ClassesTable.ReferenceCountProvider countProvider = e.getData(ClassesTable.REF_COUNT_PROVIDER_KEY);
ReferenceType selectedClass = getSelectedClass(e);
if (countProvider == null || selectedClass == null) {
return -1;
}
return countProvider.getTotalCoun
```
<Overlap Ratio: 0.9703779366700716>

---

--- 208 --
Question ID: 69cd4c8caf8f1f53ec0db2a5f9d9fa670bd2c6c6
Original Code:
```
public class CityTest {


    @Test
    public void testGson() {
        Province p1=new Province("浙江","ZheJiang",18888);
        System.out.println(p1.toString());

        City c1=new City(p1,"杭州",343342);
        System.out.println(c1.toString());

        Gson gson = new Gson();
        System.out.println("p1 to Json String:"+gson.toJson(p1));
        System.out.println("c1 to Json String:"+gson.toJson(c1));
        System.out.println("c1 to Json String:"+c1.getJsonString());

        City c2=gson.fromJson("{\"p\":{\"name_c\":\"浙江\",\"name_e\":\"ZheJiang\",\"population\":18888},\"name\":\"温州\",\"population\":4342}",City.class);
        System.out.println("c2:"+c2.toString());

    }



}
```


Overlapping Code:
```
lic class CityTest {
@Test
public void testGson() {
Province p1=new Province("浙江","ZheJiang",18888);
System.out.println(p1.toString());
City c1=new City(p1,"杭州",343342);
System.out.println(c1.toString());
Gson gson = new Gson();
System.out.println("p1 to Json String:"+gson.toJson(p1));
System.out.println("c1 to Json String:"+gson.toJson(c1));
System.out.println("c1 to Json String:"+c1.getJsonString());
City c2=gson.fromJson("{\"p\":{\"name_c\":\"浙江\",\"name_e\":\"ZheJiang\",\"population\":18888},\"name\":\"温州\",\"population\":4342}",City.class)
```
<Overlap Ratio: 0.9181969949916527>

---

--- 209 --
Question ID: 3c3e8e4cb2309f805aa52932310fcbae62e0aa87
Original Code:
```
public class ICURegion {

	private Region icuRegion;
	private Locale countryLocale;
	private static final List<Class> REGION_DATATYPES = Arrays
			.asList(new Class[] { ICURegion.class });

	public ICURegion(Region icuRegion) {
		if (icuRegion == null) {
			throw new IllegalArgumentException("icuRegion required.");
		}
		this.icuRegion = icuRegion;
		this.countryLocale = new Locale("", icuRegion.toString());
	}

	public RegionType getRegionType() {
		return icuRegion.getType();
	}

	public String getRegionCode() {
		// returns region id!
		return icuRegion.toString();
	}

	public int getNumericCode() {
		return icuRegion.getNumericCode();
	}

	public Collection<String> getTimezoneIds() {
		String[] timezones = TimeZone.getAvailableIDs(getRegionCode());
		return Arrays.asList(timezones);
	}

	public String getDisplayName(Locale locale) {
		String name = this.countryLocale.getDisplayCountry(locale);
		if (name == null) {
			name = this.getRegionCode();
		}
		return name;
	}

	public Region getIcuRegion() {
		return this.icuRegion;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		String name = getDisplayName(Locale.getDefault());
		if (name == null) {
			name = "IcuRegion";
		}
		return name + " [code: " + icuRegion.toString() + ", type: "
				+ getRegionType().name() + "]";
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result
				+ ((icuRegion == null) ? 0 : icuRegion.hashCode());
		return result;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		ICURegion other = (ICURegion) obj;
		if (icuRegion == null) {
			if (other.icuRegion != null) {
				return false;
			}
		} else if (!icuRegion.equals(other.icuRegion)) {
			return false;
		}
		return true;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see javax.money.ext.Region#getLocale()
	 */
	public Locale getLocale() {
		return this.countryLocale;
	}


}
```


Overlapping Code:
```

private Region icuRegion;
private Locale countryLocale;
private static final List<Class> REGION_DATATYPES = Arrays
.asList(new Class[] { ICURegion.class });
public ICURegion(Region icuRegion) {
if (icuRegion == null) {
throw new IllegalArgumentException("icuRegion required.");
}
this.icuRegion = icuRegion;
this.countryLocale = new Locale("", icuRegion.toString());
}
public RegionType getRegionType() {
return icuRegion.getType();
}
public String getRegionCode() {
// returns region id!
return icuRegion.toString();
}
public int getNumericCode() {
return icuRegion.getNumericCode();
}
public Collection<String> getTimezoneIds() {
String[] timezones = TimeZone.getAvailableIDs(getRegionCode());
return Arrays.asList(timezones);
}
public String getDisplayName(Locale locale) {
String name = this.countryLocale.getDisplayCountry(locale);
if (name == null) {
name = this.getRegionCode();
}
return name;
}
public Region getIcuRegion() {
return this.icuRegion;
}
/*
* (non-Javadoc)
* 
* @see java.lang.Object#toString()
*/
@Override
public String toString() {
String name = getDisplayName(Locale.getDefault());
if (name == null) {
name = "IcuRegion";
}
return name + " [code: " + icuRegion.toString() + ", type: "
+ getRegionType().name() + "]";
}
/*
* (non-Javadoc)
* 
* @see java.lang.Object#hashCode()
*/
@Override
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result
+ ((icuRegion == null) ? 0 : icuRegion.hashCode());
return result;
}
/*
* (non-Javadoc)
* 
* @see java.lang.Object#equals(java.lang.Object)
*/
@Override
public boolean equals(Object obj) {
if (this == obj) {
return true;
}
if (obj == null) {
return false;
}
if (getClass() != obj.getClass()) {
return false;
}
ICURegion other = (ICURegion) obj;
if (icuRegion == null) {
if (other.icuRegion != null) {
return false;
}
} else if (!icuRegion.equals(other.icuRegion)) {
return false;
}
return true;
}
/*
* (non-Javadoc)
* 
* @see javax.money.ext.Region#getLocale()
*/
public Locale getLocale() {
return 
```
<Overlap Ratio: 0.9770395701025891>

---

--- 210 --
Question ID: 9d714c8b07d4b78f64eedddc78c756fc6e859940
Original Code:
```
public class EchoClientHandler extends ChannelInboundHandlerAdapter {

    private final ByteBuf message;

    public EchoClientHandler() {
        message = Unpooled.buffer(256);
        message.writeBytes("hello netty".getBytes(CharsetUtil.UTF_8));
    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        ctx.writeAndFlush(message);
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        System.out.println(((ByteBuf) msg).toString(CharsetUtil.UTF_8));
        ctx.write(msg);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        // Close the connection when an exception is raised.
        cause.printStackTrace();
        ctx.close();
    }
}
```


Overlapping Code:
```
public class EchoClientHandler extends ChannelInboundHandlerAdapter {
private final ByteBuf message;
public EchoClientHandler() {
message = Unpooled.buffer(256);
message.writeBytes("hello netty".getBytes(CharsetUtil.UTF_8));
}
@Override
public void channelActive(ChannelHandlerContext ctx) {
ctx.writeAndFlush(message);
}
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
System.out.println(((ByteBuf) msg).toString(CharsetUtil.UTF_8));
ctx.write(msg);
try {
Thread.sleep(1000);
} catch (InterruptedException e) {
e.printStackTrace();
}
}
@Override
public void channelReadComplete(ChannelHandlerContext ctx) {
ctx.flush();
}
@Override
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
// Close the connection when an exception is raised.
cause.printStackTrace();
ctx.close();
}
}
```
<Overlap Ratio: 1.0>

---

--- 211 --
Question ID: 52b08b4875222c79954eb4cfb0cec43fff40d3fd
Original Code:
```
@org.springframework.web.bind.annotation.RestController
@RequestMapping("/api")
public class RestController {

    @Resource
    private ArticleService articleService;

    @Resource
    private UserService userService;

    @Resource
    private ArticleTagRelationshipService articleTagRelationshipService;

    @GetMapping("/article/{title}")
    public String getArticle(@PathVariable String title) {
        List<Article> articles = articleService.getArticlesByTitle(title);
        return JSON.toJSONString(articles);
    }

    @DeleteMapping("/article/{title}")
    public String deleteArticle(@PathVariable String title) {
        boolean delete = articleService.deleteArticleByTitle(title);
        JSONObject result = new JSONObject();
        result.put("result", delete);
        return result.toJSONString();
    }

    @GetMapping("/article")
    public String getArticles(@RequestParam(value = "page") int page,
                              @RequestParam(value = "pageNum") int pageNum) {
        List<Article> articles = articleService.getArticles(pageNum, page);
        return JSON.toJSONString(articles);
    }

    @PostMapping(value = "/article", consumes = "application/json")
    public String addArticle(@RequestBody Article article) {
        JSONObject result = new JSONObject();
        result.put("result", articleService.insertArticle(article));
//        System.out.println("Get params:" + JSON.toJSONString(article)
//                + ", result:" + result.toJSONString());
        return result.toJSONString();
    }

    @GetMapping("/articles")
    public String getArticlesByTagName(@RequestParam(value = "tagName") String tagName) {
        List<Article> articles = articleService.getArticlesByTagName(tagName);
        return JSON.toJSONString(articles);
    }

    @PostMapping(value = "/auth", consumes = "application/json")
    public String authUser(@RequestBody User user) {
        boolean authenticated = userService.authUser(user.getUsername(), user.getPassword());
        JSONObject result = new JSONObject();
        result.put("authenticated", authenticated);
        return result.toJSONString();
    }
}
```


Overlapping Code:
```
@org.springframework.web.bind.annotation.RestController
@RequestMapping("/api")
public class RestController {
@Resource
private ArticleService articleService;
@Resource
private UserService userService;
@Resource
private ArticleTagRelationshipService articleTagRelationshipService;
@GetMapping("/article/{title}")
public String getArticle(@PathVariable String title) {
List<Article> articles = articleService.getArticlesByTitle(title);
return JSON.toJSONString(articles);
}
@DeleteMapping("/article/{title}")
public String deleteArticle(@PathVariable String title) {
boolean delete = articleService.deleteArticleByTitle(title);
JSONObject result = new JSONObject();
result.put("result", delete);
return result.toJSONString();
}
@GetMapping("/article")
public String getArticles(@RequestParam(value = "page") int page,
@RequestParam(value = "pageNum") int pageNum) {
List<Article> articles = articleService.getArticles(pageNum, page);
return JSON.toJSONString(articles);
}
@PostMapping(value = "/article", consumes = "application/json")
public String addArticle(@RequestBody Article article) {
JSONObject result = new JSONObject();
result.put("result", articleService.insertArticle(article));
// System.out.println("Get params:" + JSON.toJSONString(article)
// + ", result:" + result.toJSONString());
return result.toJSONString();
}
@GetMapping("/articles")
public String getArticlesByTagName(@RequestParam(value = "tagName") String tagName) {
List<Article> articles = articleService.getArticlesByTagName(tagName);
return JSON.toJSONString(articles);
}
@PostMapping(value = "/auth", consumes = "application/json")
public String authUser(@RequestBody User user) {
boolean authenticated = userService.authUser(user.getUsername(), user.getPassword());
JSONObject result = new JSONObject();
result.put("authenticated", authenticated);
return result.toJSONString()
```
<Overlap Ratio: 0.9973147153598282>

---

--- 212 --
Question ID: 8be5d02da06b0e97cfbdde59e4d9fbb0bbc67d6c
Original Code:
```
public class PatternedLogger extends BufferedLogger {
    private final Map<String, String> info = Maps.newHashMap();

    private static final Pattern PATTERN_APP_ID = Pattern.compile("Submitted application (.*?) to ResourceManager");
    private static final Pattern PATTERN_APP_URL = Pattern.compile("The url to track the job: (.*)");
    private static final Pattern PATTERN_JOB_ID = Pattern.compile("Running job: (.*)");
    private static final Pattern PATTERN_HDFS_BYTES_WRITTEN = Pattern.compile("(?:HD|MAPR)FS: Number of bytes written=(\\d+)");
    private static final Pattern PATTERN_SOURCE_RECORDS_COUNT = Pattern.compile("Map input records=(\\d+)");
    private static final Pattern PATTERN_SOURCE_RECORDS_SIZE = Pattern.compile("(?:HD|MAPR)FS Read: (\\d+) HDFS Write");

    // hive
    private static final Pattern PATTERN_HIVE_APP_ID_URL = Pattern.compile("Starting Job = (.*?), Tracking URL = (.*)");
    private static final Pattern PATTERN_HIVE_BYTES_WRITTEN = Pattern.compile("(?:HD|MAPR)FS Read: (\\d+) HDFS Write: (\\d+) SUCCESS");

    private static final Pattern PATTERN_HIVE_APP_ID_URL_2 = Pattern.compile("Executing on YARN cluster with App id  (.*?)");

    // spark
    private static final Pattern PATTERN_SPARK_APP_ID = Pattern.compile("Submitted application (.*?)");
    private static final Pattern PATTERN_SPARK_APP_URL = Pattern.compile("tracking URL: (.*)");


    public PatternedLogger(Logger wrappedLogger) {
        super(wrappedLogger);
    }

    @Override
    public void log(String message) {
        super.log(message);
        Matcher matcher = PATTERN_APP_ID.matcher(message);
        if (matcher.find()) {
            String appId = matcher.group(1);
            info.put(ExecutableConstants.YARN_APP_ID, appId);
        }

        matcher = PATTERN_APP_URL.matcher(message);
        if (matcher.find()) {
            String appTrackingUrl = matcher.group(1);
            info.put(ExecutableConstants.YARN_APP_URL, appTrackingUrl);
        }

        matcher = PATTERN_JOB_ID.matcher(message);
        if (matcher.find()) {
            String mrJobID = matcher.group(1);
            info.put(ExecutableConstants.MR_JOB_ID, mrJobID);
        }

        matcher = PATTERN_HDFS_BYTES_WRITTEN.matcher(message);
        if (matcher.find()) {
            String hdfsWritten = matcher.group(1);
            info.put(ExecutableConstants.HDFS_BYTES_WRITTEN, hdfsWritten);
        }

        matcher = PATTERN_SOURCE_RECORDS_COUNT.matcher(message);
        if (matcher.find()) {
            String sourceCount = matcher.group(1);
            info.put(ExecutableConstants.SOURCE_RECORDS_COUNT, sourceCount);
        }

        matcher = PATTERN_SOURCE_RECORDS_SIZE.matcher(message);
        if (matcher.find()) {
            String sourceSize = matcher.group(1);
            info.put(ExecutableConstants.SOURCE_RECORDS_SIZE, sourceSize);
        }

        // hive
        matcher = PATTERN_HIVE_APP_ID_URL.matcher(message);
        if (matcher.find()) {
            String jobId = matcher.group(1);
            String trackingUrl = matcher.group(2);
            info.put(ExecutableConstants.MR_JOB_ID, jobId);
            info.put(ExecutableConstants.YARN_APP_URL, trackingUrl);
        } else {
            matcher = PATTERN_HIVE_APP_ID_URL_2.matcher(message);
            if (matcher.find()) {
                String jobId = matcher.group(1);
                info.put(ExecutableConstants.YARN_APP_ID, jobId);
            }
        }

        matcher = PATTERN_HIVE_BYTES_WRITTEN.matcher(message);
        if (matcher.find()) {
            // String hdfsRead = matcher.group(1);
            String hdfsWritten = matcher.group(2);
            info.put(ExecutableConstants.HDFS_BYTES_WRITTEN, hdfsWritten);
        }

        // spark
        matcher = PATTERN_SPARK_APP_ID.matcher(message);
        if (matcher.find()) {
            String app_id = matcher.group(1);
            info.put(ExecutableConstants.YARN_APP_ID, app_id);
        }

        matcher = PATTERN_SPARK_APP_URL.matcher(message);
        if (matcher.find()) {
            String trackingUrl = matcher.group(1);
            info.put(ExecutableConstants.YARN_APP_URL, trackingUrl);
        }
    }

    public Map<String, String> getInfo() {
        return info;
    }

}
```


Overlapping Code:
```
er extends BufferedLogger {
private final Map<String, String> info = Maps.newHashMap();
private static final Pattern PATTERN_APP_ID = Pattern.compile("Submitted application (.*?) to ResourceManager");
private static final Pattern PATTERN_APP_URL = Pattern.compile("The url to track the job: (.*)");
private static final Pattern PATTERN_JOB_ID = Pattern.compile("Running job: (.*)");
private static final Pattern PATTERN_HDFS_BYTES_WRITTEN = Pattern.compile("(?:HD|MAPR)FS: Number of bytes written=(\\d+)");
private static final Pattern PATTERN_SOURCE_RECORDS_COUNT = Pattern.compile("Map input records=(\\d+)");
private static final Pattern PATTERN_SOURCE_RECORDS_SIZE = Pattern.compile("(?:HD|MAPR)FS Read: (\\d+) HDFS Write");
// hive
private static final Pattern PATTERN_HIVE_APP_ID_URL = Pattern.compile("Starting Job = (.*?), Tracking URL = (.*)");
private static final Pattern PATTERN_HIVE_BYTES_WRITTEN = Pattern.compile("(?:HD|MAPR)FS Read: (\\d+) HDFS Write: (\\d+) SUCCESS");
private static final Pattern PATTERN_HIVE_APP_ID_URL_2 = Pattern.compile("Executing on YARN cluster with App id (.*?)");
// spark
private static final Pattern PATTERN_SPARK_APP_ID = Pattern.compile("Submitted application (.*?)");
private static final Pattern PATTERN_SPARK_APP_URL = Pattern.compile("tracking URL: (.*)");
public PatternedLogger(Logger wrappedLogger) {
super(wrappedLogger);
}
@Override
public void log(String message) {
super.log(message);
Matcher matcher = PATTERN_APP_ID.matcher(message);
if (matcher.find()) {
String appId = matcher.group(1);
info.put(ExecutableConstants.YARN_APP_ID, appId);
}
matcher = PATTERN_APP_URL.matcher(message);
if (matcher.find()) {
String appTrackingUrl = matcher.group(1);
info.put(ExecutableConstants.YARN_APP_URL, appTrackingUrl);
}
matcher = PATTERN_JOB_ID.matcher(message);
if (matcher.find()) {
String mrJobID = matcher.group(1);
info.put(ExecutableConstants.MR_JOB_ID, mrJobID);
}
matcher = PATTERN_HDFS_BYTES_WRITTEN.matcher(message);
if (matcher.find()) {
String hdfsWritten = matcher.group(1);
info.put(ExecutableConstants.HDFS_BYTES_WRITTEN, hdfsWritten);
}
matcher = PATTERN_SOURCE_RECORDS_COUNT.matcher
```
<Overlap Ratio: 0.9812870835235052>

---

--- 213 --
Question ID: eea2fe90e591f7fd2932edfcc7457e1e1e602b06
Original Code:
```
public abstract class BaseObjectEnabler implements LwM2mObjectEnabler {

    final int id;
    private NotifySender notifySender;
    private ObjectModel objectModel;

    public BaseObjectEnabler(int id, ObjectModel objectModel) {
        this.id = id;
        this.objectModel = objectModel;
    }

    @Override
    public synchronized int getId() {
        return id;
    }

    @Override
    public synchronized ObjectModel getObjectModel() {
        return objectModel;
    }

    @Override
    public synchronized CreateResponse create(ServerIdentity identity, CreateRequest request) {
        if (!identity.isSystem()) {
            // we can not create new instance on single object
            if (objectModel != null && !objectModel.multiple) {
                return CreateResponse.methodNotAllowed();
            }

            if (id == LwM2mId.SECURITY) {
                return CreateResponse.notFound();
            }
        }

        // TODO we could do a validation of request.getObjectInstance() by comparing with resourceSpec information.

        return doCreate(request);
    }

    protected CreateResponse doCreate(CreateRequest request) {
        // This should be a not implemented error, but this is not defined in the spec.
        return CreateResponse.internalServerError("not implemented");
    }

    @Override
    public synchronized ReadResponse read(ServerIdentity identity, ReadRequest request) {
        LwM2mPath path = request.getPath();

        // read is not supported for bootstrap
        if (identity.isLwm2mBootstrapServer()) {
            return ReadResponse.methodNotAllowed();
        }

        if (!identity.isSystem()) {
            // read the security object is forbidden
            if (id == LwM2mId.SECURITY) {
                return ReadResponse.notFound();
            }

            // check if the resource is readable.
            if (path.isResource()) {
                ResourceModel resourceModel = objectModel.resources.get(path.getResourceId());
                if (resourceModel != null && !resourceModel.operations.isReadable()) {
                    return ReadResponse.methodNotAllowed();
                }
            }
        }

        return doRead(identity, request);

        // TODO we could do a validation of response.getContent by comparing with the spec.
    }

    protected ReadResponse doRead(ServerIdentity identity, ReadRequest request) {
        // This should be a not implemented error, but this is not defined in the spec.
        return ReadResponse.internalServerError("not implemented");
    }

    @Override
    public synchronized WriteResponse write(ServerIdentity identity, WriteRequest request) {
        LwM2mPath path = request.getPath();

        // write is not supported for bootstrap, use bootstrap write
        if (identity.isLwm2mBootstrapServer()) {
            return WriteResponse.methodNotAllowed();
        }

        // write the security object is forbidden
        if (LwM2mId.SECURITY == id && !identity.isSystem()) {
            return WriteResponse.notFound();
        }

        if (path.isResource()) {
            // resource write:
            // check if the resource is writable
            if (LwM2mId.SECURITY != id) { // security resources are writable by SYSTEM
                ResourceModel resourceModel = objectModel.resources.get(path.getResourceId());
                if (resourceModel != null && !resourceModel.operations.isWritable()) {
                    return WriteResponse.methodNotAllowed();
                }
            }
        } else if (path.isObjectInstance()) {
            // instance write:
            // check if all resources are writable
            if (LwM2mId.SECURITY != id) { // security resources are writable by SYSTEM
                ObjectModel model = getObjectModel();
                for (Integer writeResourceId : ((LwM2mObjectInstance) request.getNode()).getResources().keySet()) {
                    ResourceModel resourceModel = model.resources.get(writeResourceId);
                    if (null != resourceModel && !resourceModel.operations.isWritable()) {
                        return WriteResponse.methodNotAllowed();
                    }
                }
            }

            if (request.isReplaceRequest()) {
                // REPLACE
                // check, if all mandatory writable resources are provided
                // Collect all mandatory writable resource IDs from the model
                Set<Integer> mandatoryResources = new HashSet<>();
                for (ResourceModel resourceModel : getObjectModel().resources.values()) {
                    if (resourceModel.mandatory && (LwM2mId.SECURITY == id || resourceModel.operations.isWritable()))
                        mandatoryResources.add(resourceModel.id);
                }
                // Afterwards remove the provided resource IDs from that set
                for (Integer writeResourceId : ((LwM2mObjectInstance) request.getNode()).getResources().keySet()) {
                    mandatoryResources.remove(writeResourceId);
                }
                if (!mandatoryResources.isEmpty()) {
                    return WriteResponse.badRequest("mandatory writable resources missing!");
                }
            }
        }

        // TODO we could do a validation of request.getNode() by comparing with resourceSpec information

        return doWrite(identity, request);
    }

    protected WriteResponse doWrite(ServerIdentity identity, WriteRequest request) {
        // This should be a not implemented error, but this is not defined in the spec.
        return WriteResponse.internalServerError("not implemented");
    }

    @Override
    public synchronized BootstrapWriteResponse write(ServerIdentity identity, BootstrapWriteRequest request) {

        // We should not get a bootstrapWriteRequest from a LWM2M server
        if (!identity.isLwm2mBootstrapServer()) {
            return BootstrapWriteResponse.internalServerError("bootstrap write request from LWM2M server");
        }

        return doWrite(identity, request);
    }

    protected BootstrapWriteResponse doWrite(ServerIdentity identity, BootstrapWriteRequest request) {
        // This should be a not implemented error, but this is not defined in the spec.
        return BootstrapWriteResponse.internalServerError("not implemented");
    }

    @Override
    public synchronized DeleteResponse delete(ServerIdentity identity, DeleteRequest request) {
        if (!identity.isLwm2mBootstrapServer() && !identity.isSystem()) {

            // delete the security object is forbidden
            if (id == LwM2mId.SECURITY) {
                return DeleteResponse.notFound();
            }

            // a resource can not be deleted
            LwM2mPath path = request.getPath();
            if (path.isResource()) {
                return DeleteResponse.methodNotAllowed();
            }

            // we can not delete instance on single object
            if (objectModel != null && !objectModel.multiple) {
                return DeleteResponse.methodNotAllowed();
            }
        }

        return doDelete(request);
    }

    protected DeleteResponse doDelete(DeleteRequest request) {
        // This should be a not implemented error, but this is not defined in the spec.
        return DeleteResponse.internalServerError("not implemented");
    }

    @Override
    public synchronized ExecuteResponse execute(ServerIdentity identity, ExecuteRequest request) {
        LwM2mPath path = request.getPath();

        // execute is not supported for bootstrap
        if (identity.isLwm2mBootstrapServer()) {
            return ExecuteResponse.methodNotAllowed();
        }

        // execute on security object is forbidden
        if (id == LwM2mId.SECURITY) {
            return ExecuteResponse.notFound();
        }

        // only resource could be executed
        if (!path.isResource()) {
            return ExecuteResponse.badRequest(null);
        }

        // check if the resource is writable
        ResourceModel resourceModel = objectModel.resources.get(path.getResourceId());
        if (resourceModel != null && !resourceModel.operations.isExecutable()) {
            return ExecuteResponse.methodNotAllowed();
        }

        return doExecute(request);
    }

    protected ExecuteResponse doExecute(ExecuteRequest request) {
        // This should be a not implemented error, but this is not defined in the spec.
        return ExecuteResponse.internalServerError("not implemented");
    }

    @Override
    public synchronized WriteAttributesResponse writeAttributes(ServerIdentity identity,
            WriteAttributesRequest request) {
        // TODO should be implemented here to be available for all object enabler
        // This should be a not implemented error, but this is not defined in the spec.
        return WriteAttributesResponse.internalServerError("not implemented");
    }

    @Override
    public synchronized DiscoverResponse discover(ServerIdentity identity, DiscoverRequest request) {

        if (identity.isLwm2mBootstrapServer()) {
            // discover is not supported for bootstrap
            return DiscoverResponse.methodNotAllowed();
        }

        if (id == LwM2mId.SECURITY) {
            return DiscoverResponse.notFound();
        }

        LwM2mPath path = request.getPath();
        if (path.isObject()) {

            // Manage discover on object
            Link[] ObjectLinks = LinkFormatHelper.getObjectDescription(getObjectModel(), null);
            return DiscoverResponse.success(ObjectLinks);

        } else if (path.isObjectInstance()) {

            // Manage discover on instance
            if (!getAvailableInstanceIds().contains(path.getObjectInstanceId()))
                return DiscoverResponse.notFound();

            Link instanceLink = LinkFormatHelper.getInstanceDescription(getObjectModel(),
                    path.getObjectInstanceId(), null);
            return DiscoverResponse.success(new Link[] { instanceLink });

        } else if (path.isResource()) {
            // Manage discover on resource
            if (!getAvailableInstanceIds().contains(path.getObjectInstanceId()))
                return DiscoverResponse.notFound();

            ResourceModel resourceModel = getObjectModel().resources.get(path.getResourceId());
            if (resourceModel == null)
                return DiscoverResponse.notFound();

            Link resourceLink = LinkFormatHelper.getResourceDescription(getObjectModel().id,
                    path.getObjectInstanceId(), resourceModel, null);
            return DiscoverResponse.success(new Link[] { resourceLink });
        }
        return DiscoverResponse.badRequest(null);
    }

    @Override
    public synchronized ObserveResponse observe(ServerIdentity identity, ObserveRequest request) {
        LwM2mPath path = request.getPath();

        // observe is not supported for bootstrap
        if (identity.isLwm2mBootstrapServer())
            return ObserveResponse.methodNotAllowed();

        if (!identity.isSystem()) {
            // observe or read of the security object is forbidden
            if (id == LwM2mId.SECURITY)
                return ObserveResponse.notFound();

            // check if the resource is readable.
            if (path.isResource()) {
                ResourceModel resourceModel = objectModel.resources.get(path.getResourceId());
                if (resourceModel != null && !resourceModel.operations.isReadable())
                    return ObserveResponse.methodNotAllowed();
            }
        }
        return doObserve(identity, request);
    }

    protected ObserveResponse doObserve(ServerIdentity identity, ObserveRequest request) {
        ReadResponse readResponse = this.read(identity, new ReadRequest(request.getPath().toString()));
        return new ObserveResponse(readResponse.getCode(), readResponse.getContent(), null, null,
                   readResponse.getErrorMessage());
    }

    @Override
    public void setNotifySender(NotifySender sender) {
        notifySender = sender;
    }

    public NotifySender getNotifySender() {
        return notifySender;
    }
}
```


Overlapping Code:
```
tEnabler implements LwM2mObjectEnabler {
final int id;
private NotifySender notifySender;
private ObjectModel objectModel;
public BaseObjectEnabler(int id, ObjectModel objectModel) {
this.id = id;
this.objectModel = objectModel;
}
@Override
public synchronized int getId() {
return id;
}
@Override
public synchronized ObjectModel getObjectModel() {
return objectModel;
}
@Override
public synchronized CreateResponse create(ServerIdentity identity, CreateRequest request) {
if (!identity.isSystem()) {
// we can not create new instance on single object
if (objectModel != null && !objectModel.multiple) {
return CreateResponse.methodNotAllowed();
}
if (id == LwM2mId.SECURITY) {
return CreateResponse.notFound();
}
}
// TODO we could do a validation of request.getObjectInstance() by comparing with resourceSpec information.
return doCreate(request);
}
protected CreateResponse doCreate(CreateRequest request) {
// This should be a not implemented error, but this is not defined in the spec.
return CreateResponse.internalServerError("not implemented");
}
@Override
public synchronized ReadResponse read(ServerIdentity identity, ReadRequest request) {
LwM2mPath path = request.getPath();
// read is not supported for bootstrap
if (identity.isLwm2mBootstrapServer()) {
return ReadResponse.methodNotAllowed();
}
if (!identity.isSystem()) {
// read the security object is forbidden
if (id == LwM2mId.SECURITY) {
return ReadResponse.notFound();
}
// check if the resource is readable.
if (path.isResource()) {
ResourceModel resourceModel = objectModel.resources.get(path.getResourceId());
if (resourceModel != null && !resourceModel.operations.isReadable()) {
return ReadResponse.methodNotAllowed();
}
}
}
return doRead(identity, request);
// TODO we could do a validation of response.getContent by comparing with the spec.
}
protected ReadResponse doRead(ServerIdentity identity, ReadRequest request) {
// This should be a not implemented error, but this
```
<Overlap Ratio: 0.9794073329984933>

---

--- 214 --
Question ID: 06d7c92df3b2ba6eafb76808dffd6ef5b816bdcb
Original Code:
```
public class WordCount extends Configured implements Tool {

    public static class MapClass extends MapReduceBase
            implements Mapper<LongWritable, Text, Text, IntWritable>
    {
        private Text word = new Text();
        private final static IntWritable one = new IntWritable( 1 );

        public void map( LongWritable key, // Offset into the file
                         Text value,
                         OutputCollector<Text, IntWritable> output,
                         Reporter reporter) throws IOException
        {
            // Get the value as a String
            String text = value.toString().toLowerCase();

            // Replace all non-characters
            text = text.replaceAll( "'", "" );
            text = text.replaceAll( "[^a-zA-Z]", " " );

            // Iterate over all of the words in the string
            StringTokenizer st = new StringTokenizer( text );
            while( st.hasMoreTokens() )
            {
                // Get the next token and set it as the text for our "word" variable
                word.set( st.nextToken() );

                // Output this word as the key and 1 as the value
                output.collect( word, one );
            }
        }
    }

    public static class Reduce extends MapReduceBase
            implements Reducer<Text, IntWritable, Text, IntWritable>
    {
        public void reduce( Text key, Iterator<IntWritable> values,
                            OutputCollector<Text, IntWritable> output,
                            Reporter reporter) throws IOException
        {
            // Iterate over all of the values (counts of occurrences of this word)
            int count = 0;
            while( values.hasNext() )
            {
                // Add the value to our count
                count += values.next().get();
            }

            // Output the word with its count (wrapped in an IntWritable)
            output.collect( key, new IntWritable( count ) );
        }
    }


    public int run(String[] args) throws Exception
    {
        // Create a configuration
        Configuration conf = getConf();

        // Create a job from the default configuration that will use the WordCount class
        JobConf job = new JobConf( conf, WordCount.class );

        // Define our input path as the first command line argument and our output path as the second
        Path in = new Path( args[0] );
        Path out = new Path( args[1] );

        // Create File Input/Output formats for these paths (in the job)
        FileInputFormat.setInputPaths( job, in );
        FileOutputFormat.setOutputPath( job, out );

        // Configure the job: name, mapper, reducer, and combiner
        job.setJobName( "WordCount" );
        job.setMapperClass( MapClass.class );
        job.setReducerClass( Reduce.class );
        job.setCombinerClass( Reduce.class );

        // Configure the output
        job.setOutputFormat( TextOutputFormat.class );
        job.setOutputKeyClass( Text.class );
        job.setOutputValueClass( IntWritable.class );

        // Run the job
        JobClient.runJob(job);
        return 0;
    }

    public static void main(String[] args) throws Exception
    {
        // Start the WordCount MapReduce application
        int res = ToolRunner.run( new Configuration(),
                new WordCount(),
                args );
        System.exit( res );
    }
}
```


Overlapping Code:
```
public class WordCount extends Configured implements Tool {
public static class MapClass extends MapReduceBase
implements Mapper<LongWritable, Text, Text, IntWritable>
{
private Text word = new Text();
private final static IntWritable one = new IntWritable( 1 );
public void map( LongWritable key, // Offset into the file
Text value,
OutputCollector<Text, IntWritable> output,
Reporter reporter) throws IOException
{
// Get the value as a String
String text = value.toString().toLowerCase();
// Replace all non-characters
text = text.replaceAll( "'", "" );
text = text.replaceAll( "[^a-zA-Z]", " " );
// Iterate over all of the words in the string
StringTokenizer st = new StringTokenizer( text );
while( st.hasMoreTokens() )
{
// Get the next token and set it as the text for our "word" variable
word.set( st.nextToken() );
// Output this word as the key and 1 as the value
output.collect( word, one );
}
}
}
public static class Reduce extends MapReduceBase
implements Reducer<Text, IntWritable, Text, IntWritable>
{
public void reduce( Text key, Iterator<IntWritable> values,
OutputCollector<Text, IntWritable> output,
Reporter reporter) throws IOException
{
// Iterate over all of the values (counts of occurrences of this word)
int count = 0;
while( values.hasNext() )
{
// Add the value to our count
count += values.next().get();
}
// Output the word with its count (wrapped in an IntWritable)
output.collect( key, new IntWritable( count ) );
}
}
public int run(String[] args) throws Exception
{
// Create a configuration
Configuration conf = getConf();
// Create a job from the default configuration that will use the WordCount class
JobConf job = new JobConf( conf, WordCount.class );
// Define our input path as the first command line argument and our output path as the second
Path in = new Path( args[0] );
Path out = new Path( args[1] );
// Create File In
```
<Overlap Ratio: 0.9967948717948718>

---

--- 215 --
Question ID: 6c693e907d19ddb7b0ecb080ebaa06b3a8584965
Original Code:
```
public class LoadingUtils {

    private LoadingUtils() {
        // This class is not publicly instantiate

    }

    public static ProgressDialog showLoadingDialog(Context context) {
        ProgressDialog progressDialog = new ProgressDialog(context);
        progressDialog.show();
        if (progressDialog.getWindow() != null) {
            progressDialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
        }
        progressDialog.setContentView(R.layout.util_progress_dialog);
        progressDialog.setIndeterminate(true);
        progressDialog.setCancelable(false);
        progressDialog.setCanceledOnTouchOutside(false);
        return progressDialog;
    }
}
```


Overlapping Code:
```
s LoadingUtils {
private LoadingUtils() {
// This class is not publicly instantiate
}
public static ProgressDialog showLoadingDialog(Context context) {
ProgressDialog progressDialog = new ProgressDialog(context);
progressDialog.show();
if (progressDialog.getWindow() != null) {
progressDialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
}
progressDialog.setContentView(R.layout.util_progress_dialog);
progressDialog.setIndeterminate(true);
progressDialog.setCancelable(false);
progressDialog.setCanceledOnTouchOutside(false);
return progressDialog;
}
}
```
<Overlap Ratio: 0.981418918918919>

---

--- 216 --
Question ID: 2b9b079b4bb4f9b3f97e92da560029a5b16f5413
Original Code:
```
public class TwoDimensional{

	public static void main(String... args){
	
		int[] x[] = new int[1][1]; //2d array
		int[] y,z [],ap[][]; //1d , 2d, 3d array , 

		//int[] y, []z; this is not valid only after the variable if split
			
	
	}




}
```


Overlapping Code:
```
public class TwoDimensional{
public static void main(String... args){

int[] x[] = new int[1][1]; //2d array
int[] y,z [],ap[][]; //1d , 2d, 3d array , 
//int[] y, []z; this is not valid only after th
```
<Overlap Ratio: 0.8888888888888888>

---

--- 217 --
Question ID: e02dae8b915d95607e4812c2501d2bde454c69fe
Original Code:
```
public class TestConfigDeserializer  implements JsonDeserializer<TestConfig>

{
    // TODO: 16/08/17 overflow????
    //convert to float if target and value fits in its range - maybe should not use easy to go out...
    @SuppressWarnings("unchecked")
    @Override
    public TestConfig deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {
        System.out.println("Call deserialize");
        GsonBuilder gsonBuilder = new GsonBuilder();
        gsonBuilder.registerTypeAdapter(Range.class,new RangeDeserializer());
        gsonBuilder.registerTypeAdapter(Param.class, new ParamDeserializer());
        gsonBuilder.registerTypeAdapter(Objective.class, new ObjectiveDeserializer());
        Gson gson = gsonBuilder.create();
        TestConfig t = gson.fromJson(jsonElement, TestConfig.class);

        //TestConfig modified = null;
        List<Param> pl = t.getScriptParametersReference();
        if(t.getOptimizerParameters() == null )
            return t;
        List<Param> op = t.getOptimizerParameters();
       for(Param p : op) {
           for (Object pdo : p.getDependencies()) {
               ParameterDependency pd = (ParameterDependency)pdo;
               if(pd.getP()!=null)
                   for(Param p1: t.getOptimizerParameters())
                       if(p1.equals(pd.getP()))
                           pd.setP(p1);
           }
       }
        return t;

    }

}
```


Overlapping Code:
```
onDeserializer<TestConfig>
{
// TODO: 16/08/17 overflow????
//convert to float if target and value fits in its range - maybe should not use easy to go out...
@SuppressWarnings("unchecked")
@Override
public TestConfig deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {
System.out.println("Call deserialize");
GsonBuilder gsonBuilder = new GsonBuilder();
gsonBuilder.registerTypeAdapter(Range.class,new RangeDeserializer());
gsonBuilder.registerTypeAdapter(Param.class, new ParamDeserializer());
gsonBuilder.registerTypeAdapter(Objective.class, new ObjectiveDeserializer());
Gson gson = gsonBuilder.create();
TestConfig t = gson.fromJson(jsonElement, TestConfig.class);
//TestConfig modified = null;
List<Param> pl = t.getScriptParametersReference();
if(t.getOptimizerParameters() == null )
return t;
List<Param> op = t.getOptimizerParameters();
for(Param p : op) {
for (Object pdo : p.getDependencies()) {
ParameterDependency pd = (ParameterDependency)pdo;
if(pd.getP()!=null)
for(Param p1: t.getOptimizerParameters())
if(p1.equals(pd.getP()))
pd.setP(p1);
}
}
return t;

```
<Overlap Ratio: 0.956738768718802>

---

--- 218 --
Question ID: 43b0fc7502cd650291a0258042359563f09b9b70
Original Code:
```
public class ModItems {

    public static UpgradeArmory upgradeArmory;
    public static UpgradeMagic upgradeMagic;
    public static UpgradePower upgradePower;
    public static UpgradeDigital upgradeDigital;

    public static void init() {
        upgradeArmory = new UpgradeArmory();
        upgradeMagic = new UpgradeMagic();
        upgradePower = new UpgradePower();
        upgradeDigital = new UpgradeDigital();
    }

    @SideOnly(Side.CLIENT)
    public static void initModels() {
        upgradeArmory.initModel();
        upgradeMagic.initModel();
        upgradePower.initModel();
        upgradeDigital.initModel();
    }
}
```


Overlapping Code:
```
lic class ModItems {
public static UpgradeArmory upgradeArmory;
public static UpgradeMagic upgradeMagic;
public static UpgradePower upgradePower;
public static UpgradeDigital upgradeDigital;
public static void init() {
upgradeArmory = new UpgradeArmory();
upgradeMagic = new UpgradeMagic();
upgradePower = new UpgradePower();
upgradeDigital = new UpgradeDigital();
}
@SideOnly(Side.CLIENT)
public static void initModels() {
upgradeArmory.initModel();
upgradeMagic.initModel();
upgradePower.initModel(
```
<Overlap Ratio: 0.931098696461825>

---

--- 219 --
Question ID: e3367750fcb59a445174be90215610b4f0827217
Original Code:
```
public class DOMUtils {
	public static void stripWhitespace(Element node) throws XPathExpressionException{
		XPathFactory xf = XPathFactory.newInstance();
		// XPath to find empty text nodes.
		XPathExpression xe = xf.newXPath().compile("//text()[normalize-space(.) = '']");  
		NodeList nl = (NodeList)xe.evaluate(node, XPathConstants.NODESET);

		// Remove each empty text node from document.
		for (int i = 0; i < nl.getLength(); i++) {
		    Node empty = nl.item(i);
		    empty.getParentNode().removeChild(empty);
		}
	}
	public static void printDOM(Node node, OutputStream out){
		try {
			printDOM(node, out, "UTF-8");
		} catch (TransformerException e) {
			throw new RuntimeException(e);
		}
	}
	public static void printDOM(HiveMessage message, OutputStream out){
		printDOM(message.dom, out);
	}
	public static void printDOM(Node node, OutputStream out, String encoding) throws TransformerException{
		    TransformerFactory tf = TransformerFactory.newInstance();
		    Transformer transformer;
				transformer = tf.newTransformer();
		    transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
		    transformer.setOutputProperty(OutputKeys.METHOD, "xml");
		    transformer.setOutputProperty(OutputKeys.INDENT, "yes");
		    transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
		    transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4");
	
		    transformer.transform(new DOMSource(node), 
		         new StreamResult(out));
	}

}
```


Overlapping Code:
```
class DOMUtils {
public static void stripWhitespace(Element node) throws XPathExpressionException{
XPathFactory xf = XPathFactory.newInstance();
// XPath to find empty text nodes.
XPathExpression xe = xf.newXPath().compile("//text()[normalize-space(.) = '']"); 
NodeList nl = (NodeList)xe.evaluate(node, XPathConstants.NODESET);
// Remove each empty text node from document.
for (int i = 0; i < nl.getLength(); i++) {
Node empty = nl.item(i);
empty.getParentNode().removeChild(empty);
}
}
public static void printDOM(Node node, OutputStream out){
try {
printDOM(node, out, "UTF-8");
} catch (TransformerException e) {
throw new RuntimeException(e);
}
}
public static void printDOM(HiveMessage message, OutputStream out){
printDOM(message.dom, out);
}
public static void printDOM(Node node, OutputStream out, String encoding) throws TransformerException{
TransformerFactory tf = TransformerFactory.newInstance();
Transformer transformer;
transformer = tf.newTransformer();
transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
transformer.setOutputProperty(OutputKeys.METHOD, "xml");
transformer.setOutputProperty(OutputKeys.INDENT, "yes");
transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4");

transformer.transform(new DOMSource(node), 
new Strea
```
<Overlap Ratio: 0.9818577648766328>

---

--- 220 --
Question ID: ebf7c5aad673e2ed5110bb23a90470b4111f2d08
Original Code:
```
public class UseHotelRoom
{
    public static void main(String[] args)
   {
        HotelRoom h1 = new HotelRoom(200);
        Suite s1 = new Suite(234);
        
        System.out.println("Testing setters and getters for hotel and Suite :");
        h1.setRoomNumber(4);
        System.out.println(h1.getRoomNumber());
        s1.setNightlyRate(54);
        System.out.println(s1.getNightlyRate());
        
        HotelRoom[] array = new HotelRoom[5];
        array[0] = new HotelRoom(101);
        array[1] = new HotelRoom(102);
        array[2] = new Suite(500);
        array[3] = new Suite(501);
        array[4] = new Suite(541);
        
        System.out.println("\nTesting arrays : ");
        for(HotelRoom x:array)
        {
            System.out.println(x);
            System.out.println();
        }
        
        ArrayList<HotelRoom> list = new ArrayList(Arrays.asList(array));
        list.add(new HotelRoom(341));
        list.add(new HotelRoom(342));
        list.add(new HotelRoom(435));
        list.add(new Suite(899));
        list.add(new Suite(900));
        
        System.out.println("Testing ArrayList : ");
        for(HotelRoom x:list)
        {
            System.out.println(x);
            System.out.println();
        }
    }
}
```


Overlapping Code:
```
public static void main(String[] args)
{
HotelRoom h1 = new HotelRoom(200);
Suite s1 = new Suite(234);

System.out.println("Testing setters and getters for hotel and Suite :");
h1.setRoomNumber(4);
System.out.println(h1.getRoomNumber());
s1.setNightlyRate(54);
System.out.println(s1.getNightlyRate());

HotelRoom[] array = new HotelRoom[5];
array[0] = new HotelRoom(101);
array[1] = new HotelRoom(102);
array[2] = new Suite(500);
array[3] = new Suite(501);
array[4] = new Suite(541);

System.out.println("\nTesting arrays : ");
for(HotelRoom x:array)
{
System.out.println(x);
System.out.println();
}

ArrayList<HotelRoom> list = new ArrayList(Arrays.asList(array));
list.add(new HotelRoom(341));
list.add(new HotelRoom(342));
list.add(new HotelRoom(435));
list.add(new Suite(899));
list.add(new Suite(900));

System.out.println("Testing ArrayList : ");
for(HotelRoom x:list)
{
System.out.println(x);
System.out.println();
}

```
<Overlap Ratio: 0.9675392670157068>

---

--- 221 --
Question ID: f5c355d28bf19d10fc64b0c03d7862632fd13a40
Original Code:
```
@SuppressWarnings("unused")

public class ProductoEstadisticaModel extends FocusTraversalPolicy implements TableModel, Serializable,PropertyChangeListener  {	
		private static final long serialVersionUID = 1L;
		
		public JInternalFrameBase jInternalFrameBase;
		
	    private String[] columnNames = {
										Constantes2.S_SELECCIONAR
										,ProductoEstadisticaConstantesFunciones.LABEL_ID
										,ProductoEstadisticaConstantesFunciones.LABEL_IDEMPRESA
										,ProductoEstadisticaConstantesFunciones.LABEL_IDSUCURSAL
										,ProductoEstadisticaConstantesFunciones.LABEL_IDBODEGA
										,ProductoEstadisticaConstantesFunciones.LABEL_IDPRODUCTO
										,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMACOMPRA
										,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMAVENTA
										,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMACOTIZACION
										,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMAPROFORMA
										,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADDISPONIBLE
										,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADRESERVADA
										,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADDEMANDA
										,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADMAXIMO
										,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADMINIMO
										,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADFISICA
										,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADORDENCOMPRA
										,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADPEDIDA
										,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADREQUISICION
										,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAINGRESO
										,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAEGRESO
										,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAPRODUCCION
										,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMACOMPRA
										,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAVENTA
										,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMADEVOLUCION
										,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAORDENCOMPRA
										,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAPEDIDO
										,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAREQUISICION
										,ProductoEstadisticaConstantesFunciones.LABEL_TOTALINGRESO
										,ProductoEstadisticaConstantesFunciones.LABEL_TOTALEGRESO
										,ProductoEstadisticaConstantesFunciones.LABEL_TOTALCOMPRA
										,ProductoEstadisticaConstantesFunciones.LABEL_TOTALVENTA
										,ProductoEstadisticaConstantesFunciones.LABEL_TOTALPRODUCIDO
										,ProductoEstadisticaConstantesFunciones.LABEL_TOTALDEVUELTO
										,ProductoEstadisticaConstantesFunciones.LABEL_COSTOULTIMO
										,ProductoEstadisticaConstantesFunciones.LABEL_COSTOTOTAL
										,ProductoEstadisticaConstantesFunciones.LABEL_COSTOPRODUCCION
										};
	   
	    public List<ProductoEstadistica> productoestadisticas;
	  	 
	    //NO SE UTILIZA
	    public ProductoEstadisticaModel(List<ProductoEstadistica> productoestadisticas,JInternalFrameBase jInternalFrameBase) {
	    	this.productoestadisticas=productoestadisticas;
			this.jInternalFrameBase=jInternalFrameBase;
	    }
	    
	    public ProductoEstadisticaModel(JInternalFrameBase jInternalFrameBase) {
	    	this.productoestadisticas=new ArrayList<ProductoEstadistica>();
			this.jInternalFrameBase=jInternalFrameBase;
	    }	    	    
	    
	    @Override
	    public String getColumnName(int columnIndex) {
	    	return columnNames[columnIndex];	    	
	    }
	 
	    @Override
	    public int getRowCount() {
	        return this.productoestadisticas.size();
	    }
	 
	    @Override
	    public int getColumnCount() {	    	
	        return this.columnNames.length;
	    }
	 
	    @Override
	    public Object getValueAt(int rowIndex, int columnIndex) {
	        switch (columnIndex) {
				case 0: return this.productoestadisticas.get(rowIndex).getIsSelected();
	            
				case 1: return this.productoestadisticas.get(rowIndex).getId();
				case 2: return this.productoestadisticas.get(rowIndex).getid_empresa();
				case 3: return this.productoestadisticas.get(rowIndex).getid_sucursal();
				case 4: return this.productoestadisticas.get(rowIndex).getid_bodega();
				case 5: return this.productoestadisticas.get(rowIndex).getid_producto();
				case 6: return this.productoestadisticas.get(rowIndex).getprecio_ultima_compra();
				case 7: return this.productoestadisticas.get(rowIndex).getprecio_ultima_venta();
				case 8: return this.productoestadisticas.get(rowIndex).getprecio_ultima_cotizacion();
				case 9: return this.productoestadisticas.get(rowIndex).getprecio_ultima_proforma();
				case 10: return this.productoestadisticas.get(rowIndex).getcantidad_disponible();
				case 11: return this.productoestadisticas.get(rowIndex).getcantidad_reservada();
				case 12: return this.productoestadisticas.get(rowIndex).getcantidad_demanda();
				case 13: return this.productoestadisticas.get(rowIndex).getcantidad_maximo();
				case 14: return this.productoestadisticas.get(rowIndex).getcantidad_minimo();
				case 15: return this.productoestadisticas.get(rowIndex).getcantidad_fisica();
				case 16: return this.productoestadisticas.get(rowIndex).getcantidad_orden_compra();
				case 17: return this.productoestadisticas.get(rowIndex).getcantidad_pedida();
				case 18: return this.productoestadisticas.get(rowIndex).getcantidad_requisicion();
				case 19: return this.productoestadisticas.get(rowIndex).getfecha_ultima_ingreso();
				case 20: return this.productoestadisticas.get(rowIndex).getfecha_ultima_egreso();
				case 21: return this.productoestadisticas.get(rowIndex).getfecha_ultima_produccion();
				case 22: return this.productoestadisticas.get(rowIndex).getfecha_ultima_compra();
				case 23: return this.productoestadisticas.get(rowIndex).getfecha_ultima_venta();
				case 24: return this.productoestadisticas.get(rowIndex).getfecha_ultima_devolucion();
				case 25: return this.productoestadisticas.get(rowIndex).getfecha_ultima_orden_compra();
				case 26: return this.productoestadisticas.get(rowIndex).getfecha_ultima_pedido();
				case 27: return this.productoestadisticas.get(rowIndex).getfecha_ultima_requisicion();
				case 28: return this.productoestadisticas.get(rowIndex).gettotal_ingreso();
				case 29: return this.productoestadisticas.get(rowIndex).gettotal_egreso();
				case 30: return this.productoestadisticas.get(rowIndex).gettotal_compra();
				case 31: return this.productoestadisticas.get(rowIndex).gettotal_venta();
				case 32: return this.productoestadisticas.get(rowIndex).gettotal_producido();
				case 33: return this.productoestadisticas.get(rowIndex).gettotal_devuelto();
				case 34: return this.productoestadisticas.get(rowIndex).getcosto_ultimo();
				case 35: return this.productoestadisticas.get(rowIndex).getcosto_total();
				case 36: return this.productoestadisticas.get(rowIndex).getcosto_produccion();	            
	            default: return null;
	        }
	    }
	 
	    @Override
	    public Class<?> getColumnClass(int columnIndex) {
	    	switch (columnIndex) {
				case 0: return Boolean.class;
	            
				case 1: return Long.class;
				case 2: return Long.class;
				case 3: return Long.class;
				case 4: return Long.class;
				case 5: return Long.class;
				case 6: return Double.class;
				case 7: return Double.class;
				case 8: return Double.class;
				case 9: return Double.class;
				case 10: return Integer.class;
				case 11: return Double.class;
				case 12: return Double.class;
				case 13: return Integer.class;
				case 14: return Integer.class;
				case 15: return Double.class;
				case 16: return Double.class;
				case 17: return Double.class;
				case 18: return Double.class;
				case 19: return Date.class;
				case 20: return Date.class;
				case 21: return Date.class;
				case 22: return Date.class;
				case 23: return Date.class;
				case 24: return Date.class;
				case 25: return Date.class;
				case 26: return Date.class;
				case 27: return Date.class;
				case 28: return Double.class;
				case 29: return Double.class;
				case 30: return Double.class;
				case 31: return Double.class;
				case 32: return Double.class;
				case 33: return Double.class;
				case 34: return Double.class;
				case 35: return Double.class;
				case 36: return Double.class;	            
	            default: return String.class;
	        }	    		        
	    }
	 
	    @Override
	    public boolean isCellEditable(int rowIndex, int columnIndex) {
	    	switch (columnIndex) {
				case 0: return true;
            	
				case 1: return true;
				case 2: return true;
				case 3: return true;
				case 4: return true;
				case 5: return true;
				case 6: return true;
				case 7: return true;
				case 8: return true;
				case 9: return true;
				case 10: return true;
				case 11: return true;
				case 12: return true;
				case 13: return true;
				case 14: return true;
				case 15: return true;
				case 16: return true;
				case 17: return true;
				case 18: return true;
				case 19: return true;
				case 20: return true;
				case 21: return true;
				case 22: return true;
				case 23: return true;
				case 24: return true;
				case 25: return true;
				case 26: return true;
				case 27: return true;
				case 28: return true;
				case 29: return true;
				case 30: return true;
				case 31: return true;
				case 32: return true;
				case 33: return true;
				case 34: return true;
				case 35: return true;
				case 36: return true;	            
	            default: return true;
	        }	
	    }
	 
	    @Override
	    public void setValueAt(Object value, int rowIndex, int columnIndex) {
	    	ProductoEstadistica productoestadistica = this.productoestadisticas.get(rowIndex);
	    	Boolean esCampoValor=false;
			String sTipo="";
			
			ProductoEstadisticaBeanSwingJInternalFrame productoestadisticaBeanSwingJInternalFrame=(ProductoEstadisticaBeanSwingJInternalFrame)this.jInternalFrameBase; 
			
	        switch (columnIndex) {
				case 0: try {productoestadistica.setIsSelected((Boolean) value);} catch (Exception e) {e.printStackTrace();} break;
	            
				case 1: try {productoestadistica.setId((Long) value);} catch (Exception e) {e.printStackTrace();} break;
				case 2: try {productoestadistica.setid_empresa((Long) value);productoestadistica.setempresa_descripcion(productoestadisticaBeanSwingJInternalFrame.getActualEmpresaForeignKeyDescripcion((Long)value));} catch (Exception e) {e.printStackTrace();} break;
				case 3: try {productoestadistica.setid_sucursal((Long) value);productoestadistica.setsucursal_descripcion(productoestadisticaBeanSwingJInternalFrame.getActualSucursalForeignKeyDescripcion((Long)value));} catch (Exception e) {e.printStackTrace();} break;
				case 4: try {productoestadistica.setid_bodega((Long) value);productoestadistica.setbodega_descripcion(productoestadisticaBeanSwingJInternalFrame.getActualBodegaForeignKeyDescripcion((Long)value));} catch (Exception e) {e.printStackTrace();} break;
				case 5: try {productoestadistica.setid_producto((Long) value);productoestadistica.setproducto_descripcion(productoestadisticaBeanSwingJInternalFrame.getActualProductoForeignKeyDescripcion((Long)value));} catch (Exception e) {e.printStackTrace();} break;
				case 6: try {productoestadistica.setprecio_ultima_compra((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 7: try {productoestadistica.setprecio_ultima_venta((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 8: try {productoestadistica.setprecio_ultima_cotizacion((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 9: try {productoestadistica.setprecio_ultima_proforma((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 10: try {productoestadistica.setcantidad_disponible((Integer) value);} catch (Exception e) {e.printStackTrace();} break;
				case 11: try {productoestadistica.setcantidad_reservada((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 12: try {productoestadistica.setcantidad_demanda((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 13: try {productoestadistica.setcantidad_maximo((Integer) value);} catch (Exception e) {e.printStackTrace();} break;
				case 14: try {productoestadistica.setcantidad_minimo((Integer) value);} catch (Exception e) {e.printStackTrace();} break;
				case 15: try {productoestadistica.setcantidad_fisica((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 16: try {productoestadistica.setcantidad_orden_compra((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 17: try {productoestadistica.setcantidad_pedida((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 18: try {productoestadistica.setcantidad_requisicion((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 19: try {productoestadistica.setfecha_ultima_ingreso((Date) value);} catch (Exception e) {e.printStackTrace();} break;
				case 20: try {productoestadistica.setfecha_ultima_egreso((Date) value);} catch (Exception e) {e.printStackTrace();} break;
				case 21: try {productoestadistica.setfecha_ultima_produccion((Date) value);} catch (Exception e) {e.printStackTrace();} break;
				case 22: try {productoestadistica.setfecha_ultima_compra((Date) value);} catch (Exception e) {e.printStackTrace();} break;
				case 23: try {productoestadistica.setfecha_ultima_venta((Date) value);} catch (Exception e) {e.printStackTrace();} break;
				case 24: try {productoestadistica.setfecha_ultima_devolucion((Date) value);} catch (Exception e) {e.printStackTrace();} break;
				case 25: try {productoestadistica.setfecha_ultima_orden_compra((Date) value);} catch (Exception e) {e.printStackTrace();} break;
				case 26: try {productoestadistica.setfecha_ultima_pedido((Date) value);} catch (Exception e) {e.printStackTrace();} break;
				case 27: try {productoestadistica.setfecha_ultima_requisicion((Date) value);} catch (Exception e) {e.printStackTrace();} break;
				case 28: try {productoestadistica.settotal_ingreso((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 29: try {productoestadistica.settotal_egreso((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 30: try {productoestadistica.settotal_compra((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 31: try {productoestadistica.settotal_venta((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 32: try {productoestadistica.settotal_producido((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 33: try {productoestadistica.settotal_devuelto((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 34: try {productoestadistica.setcosto_ultimo((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 35: try {productoestadistica.setcosto_total((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
				case 36: try {productoestadistica.setcosto_produccion((Double) value);esCampoValor=true;} catch (Exception e) {e.printStackTrace();} break;
	        }
	        
	        fireTableCellUpdated(rowIndex, columnIndex);
			
			if(esCampoValor) {
				jInternalFrameBase.procesoActualizarFilaTotales(esCampoValor,sTipo);
			}
	    }
		
		
		//PARTE PARA EL PROPERTYVALORCHANGELISTENER
		//public JInternalFrameBase jInternalFrameBase;
		/*
		public ProductoEstadisticaModel(JInternalFrameBase jInternalFrameBase) {
			this.jInternalFrameBase=jInternalFrameBase;
		}
		*/
		
		@Override
		public void propertyChange(PropertyChangeEvent evt) {
			try {
				this.jInternalFrameBase.procesoActualizarFilaTotales();
					
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		//PARTE PARA EL PROPERTYVALORCHANGELISTENER FIN
		
			
		/*FUNCIONES PARA FOCUS TRAVERSAL POLICY*/
		
		private Component componentTab=new JTextField();
		private ProductoEstadisticaDetalleFormJInternalFrame productoestadisticaJInternalFrame=null;
		
		public ProductoEstadisticaModel(ProductoEstadisticaDetalleFormJInternalFrame productoestadisticaJInternalFrame) {
			this.productoestadisticaJInternalFrame=productoestadisticaJInternalFrame;
		}
		
		public Component getComponentAfter(Container focusCycleRoot, Component component) {
			
			componentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica())) {
				componentTab=this.productoestadisticaJInternalFrame.getjButtonEliminarToolBarProductoEstadistica();
				return componentTab;
			}
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonEliminarToolBarProductoEstadistica())) {
				componentTab=this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica();
				return componentTab;
			}
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica())) {
				componentTab=this.productoestadisticaJInternalFrame.jComboBoxid_empresaProductoEstadistica;
				return componentTab;
			}				
			
			
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_produccionProductoEstadistica)) {
				componentTab=this.productoestadisticaJInternalFrame.jComboBoxTiposAccionesFormularioProductoEstadistica;
				return componentTab;
			}
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxTiposAccionesFormularioProductoEstadistica)) {
				componentTab=this.productoestadisticaJInternalFrame.jButtonEliminarProductoEstadistica;
				return componentTab;
			}
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonEliminarProductoEstadistica)) {
				componentTab=this.productoestadisticaJInternalFrame.jButtonActualizarProductoEstadistica;
				return componentTab;
			}
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonActualizarProductoEstadistica)) {
				componentTab=this.productoestadisticaJInternalFrame.jButtonCancelarProductoEstadistica;
				return componentTab;
			}
			
			

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_empresaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jComboBoxid_sucursalProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_sucursalProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jComboBoxid_bodegaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_bodegaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jComboBoxid_productoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_productoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_compraProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_compraProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_ventaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_ventaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_cotizacionProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_cotizacionProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_proformaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_proformaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_disponibleProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_disponibleProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_reservadaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_reservadaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_demandaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_demandaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_maximoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_maximoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_minimoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_minimoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_fisicaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_fisicaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_orden_compraProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_orden_compraProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_pedidaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_pedidaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_requisicionProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_requisicionProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ingresoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ingresoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_egresoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_egresoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_produccionProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_produccionProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_compraProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_compraProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ventaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ventaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_devolucionProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_devolucionProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_orden_compraProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_orden_compraProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_pedidoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_pedidoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_requisicionProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_requisicionProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_ingresoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_ingresoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_egresoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_egresoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_compraProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_compraProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_ventaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_ventaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_producidoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_producidoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_devueltoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_devueltoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_ultimoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_ultimoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_totalProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_totalProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_produccionProductoEstadistica;
			return componentTab;
		}
			
			return componentTab;
		}
		
		public Component getComponentBefore(Container focusCycleRoot, Component component) {
			
			componentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonEliminarToolBarProductoEstadistica())) {
				componentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();
				return componentTab;
			}
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica())) {
				componentTab=this.productoestadisticaJInternalFrame.getjButtonEliminarToolBarProductoEstadistica();
				
				return componentTab;
			}
			
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_empresaProductoEstadistica)) {
				
				componentTab=this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica();
				
				
				return componentTab;
			}
			
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxTiposAccionesFormularioProductoEstadistica)) {
				componentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_produccionProductoEstadistica;
				return componentTab;
			}
			
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonEliminarProductoEstadistica)) {
				componentTab=this.productoestadisticaJInternalFrame.jComboBoxTiposAccionesFormularioProductoEstadistica;
				return componentTab;
			}
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonActualizarProductoEstadistica)) {
				componentTab=this.productoestadisticaJInternalFrame.jButtonEliminarProductoEstadistica;
				return componentTab;
			}
			
			if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jButtonCancelarProductoEstadistica)) {
				componentTab=this.productoestadisticaJInternalFrame.jButtonActualizarProductoEstadistica;
				return componentTab;
			}
			
			

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_sucursalProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jComboBoxid_empresaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_bodegaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jComboBoxid_sucursalProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jComboBoxid_productoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jComboBoxid_bodegaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_compraProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jComboBoxid_productoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_ventaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_compraProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_cotizacionProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_ventaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_proformaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_cotizacionProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_disponibleProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldprecio_ultima_proformaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_reservadaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_disponibleProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_demandaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_reservadaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_maximoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_demandaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_minimoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_maximoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_fisicaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_minimoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_orden_compraProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_fisicaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_pedidaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_orden_compraProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcantidad_requisicionProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_pedidaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ingresoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcantidad_requisicionProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_egresoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ingresoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_produccionProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_egresoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_compraProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_produccionProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ventaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_compraProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_devolucionProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_ventaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_orden_compraProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_devolucionProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_pedidoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_orden_compraProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_requisicionProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_pedidoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_ingresoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jDateChooserfecha_ultima_requisicionProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_egresoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_ingresoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_compraProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_egresoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_ventaProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_compraProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_producidoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_ventaProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldtotal_devueltoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_producidoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_ultimoProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldtotal_devueltoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_totalProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_ultimoProductoEstadistica;
			return componentTab;
		}

		if(component!=null && component.equals(this.productoestadisticaJInternalFrame.jTextFieldcosto_produccionProductoEstadistica)) {
			componentTab=this.productoestadisticaJInternalFrame.jTextFieldcosto_totalProductoEstadistica;
			return componentTab;
		}
			
			return componentTab;
		}
		
		public Component getDefaultComponent(Container focusCycleRoot) {
			
			componentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();
			
			
			return componentTab;		
		}
		
		public Component getFirstComponent(Container focusCycleRoot) {
			
			componentTab=this.productoestadisticaJInternalFrame.getjButtonActualizarToolBarProductoEstadistica();
			
			
			return componentTab;		
		}
		
		public Component getLastComponent(Container focusCycleRoot) {
			
			componentTab=this.productoestadisticaJInternalFrame.getjButtonCancelarToolBarProductoEstadistica();
			
			
			return componentTab;		
		}
		
		public ProductoEstadisticaDetalleFormJInternalFrame getproductoestadisticaJInternalFrame() {
			return this.productoestadisticaJInternalFrame;
		}
		
		public void setproductoestadisticaJInternalFrame(ProductoEstadisticaDetalleFormJInternalFrame productoestadisticaJInternalFrame) {
			this.productoestadisticaJInternalFrame=productoestadisticaJInternalFrame;
		}
		
		public Component getComponentTab() {
			return this.componentTab;
		}
		
		public void setComponentTab(Component componentTab) {
			this.componentTab=componentTab;
		}
		/*FUNCIONES PARA FOCUS TRAVERSAL POLICY FIN*/
		
		
		/*FUNCIONES PARA AbstractTableModel*/
		/*
		Notas:
		* Si Cambia version se copia variables y metodos que no son sobreescritos en esta clase.(Usa Jdk 8)
		* Se copia del Jdk javax.swing.table.AbstractTableModel
		* Los argumentos usados es de tipo Interface TableModel no de Clase AbstractTableModel
		* Si se cambia y/o actualiza jdj, toca actualizar el código nuevamente
		*/
		
		protected EventListenerList listenerList = new EventListenerList();

		public int findColumn(String columnName) {
			for (int i = 0; i < getColumnCount(); i++) {
				if (columnName.equals(getColumnName(i))) {
					return i;
				}
			}
			return -1;
		}
		
		public void addTableModelListener(TableModelListener l) {
        	listenerList.add(TableModelListener.class, l);
    	}
		
		public void removeTableModelListener(TableModelListener l) {
        	listenerList.remove(TableModelListener.class, l);
    	}
		
		public TableModelListener[] getTableModelListeners() {
			return listenerList.getListeners(TableModelListener.class);
		}
		
		public void fireTableDataChanged() {
			fireTableChanged(new TableModelEvent(this));
		}
		
		public void fireTableStructureChanged() {
        	fireTableChanged(new TableModelEvent(this, TableModelEvent.HEADER_ROW));
    	}
		
		public void fireTableRowsInserted(int firstRow, int lastRow) {
			fireTableChanged(new TableModelEvent(this, firstRow, lastRow,
								TableModelEvent.ALL_COLUMNS, TableModelEvent.INSERT));
		}
	
		public void fireTableRowsUpdated(int firstRow, int lastRow) {
			fireTableChanged(new TableModelEvent(this, firstRow, lastRow,
								TableModelEvent.ALL_COLUMNS, TableModelEvent.UPDATE));
		}
		
		public void fireTableRowsDeleted(int firstRow, int lastRow) {
			fireTableChanged(new TableModelEvent(this, firstRow, lastRow,
								TableModelEvent.ALL_COLUMNS, TableModelEvent.DELETE));
		}
	
		public void fireTableCellUpdated(int row, int column) {
			fireTableChanged(new TableModelEvent(this, row, row, column));
		}
		
		public void fireTableChanged(TableModelEvent e) {
			// Guaranteed to return a non-null array
			Object[] listeners = listenerList.getListenerList();
			// Process the listeners last to first, notifying
			// those that are interested in this event
			for (int i = listeners.length-2; i>=0; i-=2) {
				if (listeners[i]==TableModelListener.class) {
					((TableModelListener)listeners[i+1]).tableChanged(e);
				}
			}
		}
		
		public <T extends EventListener> T[] getListeners(Class<T> listenerType) {
			return listenerList.getListeners(listenerType);
		}
		/*FUNCIONES PARA AbstractTableModel FIN*/
}
```


Overlapping Code:
```
s ProductoEstadisticaModel extends FocusTraversalPolicy implements TableModel, Serializable,PropertyChangeListener { 
private static final long serialVersionUID = 1L;

public JInternalFrameBase jInternalFrameBase;

private String[] columnNames = {
Constantes2.S_SELECCIONAR
,ProductoEstadisticaConstantesFunciones.LABEL_ID
,ProductoEstadisticaConstantesFunciones.LABEL_IDEMPRESA
,ProductoEstadisticaConstantesFunciones.LABEL_IDSUCURSAL
,ProductoEstadisticaConstantesFunciones.LABEL_IDBODEGA
,ProductoEstadisticaConstantesFunciones.LABEL_IDPRODUCTO
,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMACOMPRA
,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMAVENTA
,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMACOTIZACION
,ProductoEstadisticaConstantesFunciones.LABEL_PRECIOULTIMAPROFORMA
,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADDISPONIBLE
,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADRESERVADA
,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADDEMANDA
,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADMAXIMO
,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADMINIMO
,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADFISICA
,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADORDENCOMPRA
,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADPEDIDA
,ProductoEstadisticaConstantesFunciones.LABEL_CANTIDADREQUISICION
,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAINGRESO
,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAEGRESO
,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAPRODUCCION
,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMACOMPRA
,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAVENTA
,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMADEVOLUCION
,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAORDENCOMPRA
,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAPEDIDO
,ProductoEstadisticaConstantesFunciones.LABEL_FECHAULTIMAREQUISICION
,ProductoEstadisticaConstantesFunciones.LABEL_TOTALINGRESO
,ProductoEstadisticaConstantesFunciones.LABEL_TOTALEGRES
```
<Overlap Ratio: 0.977996254681648>

---

--- 222 --
Question ID: 0dc246c463f73a72b8278978cbb0a556b3f10dc2
Original Code:
```
public class ExpressionFunction extends AbstractFunction implements XMLEntity {
	private static Variables varSet = new Variables();
	private Expression expr;
	private List<String> parameters;
	private String name;

	public static String listToString(List<String> l) {
		String r = "";
		if (l.isEmpty())
			return r;
		for (Object o : l) {
			r += o.toString() + ", ";
		}
		return r.substring(0, r.length() - 2);
	}

	public static void stringToList(String s, List<String> result)
			throws Exception {
		result.clear();
		s = s.trim();
		if (s.length() > 0) {
			for (String r : s.split(",")) {
				if (r.trim().isEmpty())
					throw new Exception("Invalid parameter list format!");
				result.add(r.trim());

			}
		}
	}

	public ExpressionFunction(String name, Expression expr,
			List<String> parameters) {
		this.expr = expr;
		this.parameters = parameters;
		this.name = name;
		FunctionList.registerSession(this, "World attribute function");
	}

	public boolean isStatic() {
		return false;
	}

	@Override
	public int getMinNbArg() {
		return parameters.size();
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public Object getValue(EntityInterface e, List<Object> args) {
		varSet.clear();
		int index = 0;
		for (String s : parameters)
			varSet.affect(s, args.get(index++), null);
		return expr.getObject(e, varSet);
	}

	public String toString() {
		return name + "(" + parameters + ") = " + expr.toString();
	}

	@Override
	public ExpressionFunction copy() {
		return new ExpressionFunction(name, new Expression(expr),
				new LinkedList<String>(parameters));
	}

	public void unregister() {
		FunctionList.unregister(this);
	}

	@Override
	public void fromXML(Element e, XMLCrossRef refs) throws Exception {
		name = e.getAttribute("name");
		expr = new Expression(e.getAttribute("expr"));
		parameters = new LinkedList<String>();
		stringToList(e.getAttribute("parameters"), parameters);
		FunctionList.registerSession(this, "World attribute function");
	}

	@Override
	public Element toXML(Document root, XMLCrossRef refs) throws Exception {
		Element e = root.createElement(this.getClass().getName());
		e.setAttribute("name", name);
		e.setAttribute("parameters", listToString(parameters));
		e.setAttribute("expr", expr.toString());
		return e;
	}

	public List<String> getParameters() {
		return parameters;
	}

	public Expression getExpression() {
		return expr;
	}

	public void setName(String name) {
		FunctionList.unregister(this);
		this.name = name;
		FunctionList.registerSession(this, "World attribute function");
	}

	public void setParameters(List<String> parameters) {
		FunctionList.unregister(this);
		this.parameters = parameters;
		FunctionList.registerSession(this, "World attribute function");
	}

	public void setExpression(Expression expr) {
		this.expr = expr;
	}

	public void setFunction(String name, String parameters) throws Exception {
		FunctionList.unregister(this);
		this.name = name;
		this.parameters = new LinkedList<String>();
		stringToList(parameters, this.parameters);
		FunctionList.registerSession(this, "World attribute function");
	}
}
```


Overlapping Code:
```
lic class ExpressionFunction extends AbstractFunction implements XMLEntity {
private static Variables varSet = new Variables();
private Expression expr;
private List<String> parameters;
private String name;
public static String listToString(List<String> l) {
String r = "";
if (l.isEmpty())
return r;
for (Object o : l) {
r += o.toString() + ", ";
}
return r.substring(0, r.length() - 2);
}
public static void stringToList(String s, List<String> result)
throws Exception {
result.clear();
s = s.trim();
if (s.length() > 0) {
for (String r : s.split(",")) {
if (r.trim().isEmpty())
throw new Exception("Invalid parameter list format!");
result.add(r.trim());
}
}
}
public ExpressionFunction(String name, Expression expr,
List<String> parameters) {
this.expr = expr;
this.parameters = parameters;
this.name = name;
FunctionList.registerSession(this, "World attribute function");
}
public boolean isStatic() {
return false;
}
@Override
public int getMinNbArg() {
return parameters.size();
}
@Override
public String getName() {
return name;
}
@Override
public Object getValue(EntityInterface e, List<Object> args) {
varSet.clear();
int index = 0;
for (String s : parameters)
varSet.affect(s, args.get(index++), null);
return expr.getObject(e, varSet);
}
public String toString() {
return name + "(" + parameters + ") = " + expr.toString();
}
@Override
public ExpressionFunction copy() {
return new ExpressionFunction(name, new Expression(expr),
new LinkedList<String>(parameters));
}
public void unregister() {
FunctionList.unregister(this);
}
@Override
public void fromXML(Element e, XMLCrossRef refs) throws Exception {
name = e.getAttribute("name");
expr = new Expression(e.getAttribute("expr"));
parameters = new LinkedList<String>();
stringToList(e.getAttribute("parameters"), parameters);
FunctionList.registerSession(this, "World attribute function");
}
@Override
public Element toXML(Document root, XMLCrossRef refs) throws Exception {
Element e = root.createElement(this.getClass().getName());
e.setAttribute("name", name);
e.setAttribute("parameters", listToString(parameters));
e.setAttribute("expr", expr.toString());
return e;
}
public List<String> getParameters() {
return parameters;
}
public Expression getExpression() {
return expr;
}
public void setName(String name) {
FunctionList.unre
```
<Overlap Ratio: 0.9862778730703259>

---

--- 223 --
Question ID: 3583a2c1703a891f08e8861bd356608838d740c5
Original Code:
```
public class EditCounterActivity extends AppCompatActivity {

    private Counter counter;
    private int counterIndex;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_edit_counter);

        Intent intent = getIntent();
        String counterTitle = intent.getStringExtra(IntentConstants.INTENT_COUNTER_TITLE);
        Integer counterInitialValue = intent.getIntExtra(IntentConstants.INTENT_COUNTER_INITIAL_VALUE, 0);
        Date counterDate = new Date(intent.getLongExtra(IntentConstants.INTENT_COUNTER_DATE, 0));
        String counterComment = intent.getStringExtra(IntentConstants.INTENT_COUNTER_COMMENT);
        Integer counterCurrentValue = intent.getIntExtra(IntentConstants.INTENT_COUNTER_CURRENT_VALUE, 0);
        counterIndex = intent.getIntExtra(IntentConstants.INTENT_COUNTER_INDEX, 0);

        counter = new Counter(counterTitle, counterDate, counterInitialValue, counterComment);
        counter.setCurrentValue(counterCurrentValue);

        TextView titleView = (TextView)findViewById(R.id.editCounterTitle);
        titleView.setText(counterTitle);
        TextView initialValueView = (TextView)findViewById(R.id.editCounterInitialValue);
        initialValueView.setText(counterInitialValue.toString());
        TextView currentValueView = (TextView)findViewById(R.id.editCounterCurrentValue);
        currentValueView.setText(counterCurrentValue.toString());
        TextView commentView = (TextView)findViewById(R.id.editCounterComment);
        commentView.setText(counterComment);
    }

    /**
     * Checks if all data in the form is valid. Then, finishes the activity
     * and sends data back to the previous activity.
     * @param v
     */
    public void saveEdits(View v) {
        String counterTitle = ((EditText) findViewById(R.id.editCounterTitle)).getText().toString();
        Date date = new Date();
        String initialValueString = ((EditText) findViewById(R.id.editCounterInitialValue)).getText().toString();
        String currentValueString = ((EditText) findViewById(R.id.editCounterCurrentValue)).getText().toString();
        String comment = ((EditText) findViewById(R.id.editCounterComment)).getText().toString();

        if (counterTitle.equals("")) {
            Toast.makeText(getApplicationContext(), "Please enter a title", Toast.LENGTH_SHORT).show();
        } else if (initialValueString.equals("")) {
            Toast.makeText(getApplicationContext(), "Please enter an initial value", Toast.LENGTH_SHORT).show();
        } else if (currentValueString.equals("")) {
           Toast.makeText(getApplicationContext(), "Please enter a current value", Toast.LENGTH_SHORT).show();
        } else if (Integer.parseInt(initialValueString) < 0) {
            Toast.makeText(getApplicationContext(), "The initial value must be positive", Toast.LENGTH_SHORT).show();
        } else if (Integer.parseInt(currentValueString) < 0) {
            Toast.makeText(getApplicationContext(), "The current value must be positive", Toast.LENGTH_SHORT).show();
        }
        else {
            Intent intent = new Intent();
            intent.putExtra(IntentConstants.INTENT_COUNTER_TITLE, counterTitle);
            intent.putExtra(IntentConstants.INTENT_COUNTER_INITIAL_VALUE, Integer.parseInt(initialValueString));
            intent.putExtra(IntentConstants.INTENT_COUNTER_CURRENT_VALUE, Integer.parseInt(currentValueString));
            intent.putExtra(IntentConstants.INTENT_COUNTER_DATE, date.getTime());
            intent.putExtra(IntentConstants.INTENT_COUNTER_COMMENT, comment);
            intent.putExtra(IntentConstants.INTENT_COUNTER_INDEX, counterIndex);
            setResult(IntentConstants.EDIT_COUNTER_INTENT_RESPONSE, intent);
            finish();
        }
    }
}
```


Overlapping Code:
```
ublic class EditCounterActivity extends AppCompatActivity {
private Counter counter;
private int counterIndex;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_edit_counter);
Intent intent = getIntent();
String counterTitle = intent.getStringExtra(IntentConstants.INTENT_COUNTER_TITLE);
Integer counterInitialValue = intent.getIntExtra(IntentConstants.INTENT_COUNTER_INITIAL_VALUE, 0);
Date counterDate = new Date(intent.getLongExtra(IntentConstants.INTENT_COUNTER_DATE, 0));
String counterComment = intent.getStringExtra(IntentConstants.INTENT_COUNTER_COMMENT);
Integer counterCurrentValue = intent.getIntExtra(IntentConstants.INTENT_COUNTER_CURRENT_VALUE, 0);
counterIndex = intent.getIntExtra(IntentConstants.INTENT_COUNTER_INDEX, 0);
counter = new Counter(counterTitle, counterDate, counterInitialValue, counterComment);
counter.setCurrentValue(counterCurrentValue);
TextView titleView = (TextView)findViewById(R.id.editCounterTitle);
titleView.setText(counterTitle);
TextView initialValueView = (TextView)findViewById(R.id.editCounterInitialValue);
initialValueView.setText(counterInitialValue.toString());
TextView currentValueView = (TextView)findViewById(R.id.editCounterCurrentValue);
currentValueView.setText(counterCurrentValue.toString());
TextView commentView = (TextView)findViewById(R.id.editCounterComment);
commentView.setText(counterComment);
}
/**
* Checks if all data in the form is valid. Then, finishes the activity
* and sends data back to the previous activity.
* @param v
*/
public void saveEdits(View v) {
String counterTitle = ((EditText) findViewById(R.id.editCounterTitle)).getText().toString();
Date date = new Date();
String initialValueString = ((EditText) findViewById(R.id.editCounterInitialValue)).getText().toString();
String currentValueString = ((EditText) findViewById(R.id.editCounterCurrentValue)).getText().toString();
String comment = ((EditText) findViewById(R.id.editCounterComment)).getText().toString();
if (counterTitle.equals("")) {
Toast.makeText(getApplicationContext(), "Please enter a title", Toast.LENGTH_SHORT).show();
} else if (initialValueString.equals("")) {
Toast.make
```
<Overlap Ratio: 0.9995479204339964>

---

--- 224 --
Question ID: be7f3ffbfa405aed6884040c4005a3bdff2de4e7
Original Code:
```
public class TransparentFetcher implements Fetcher {
    private boolean convertHttpToPhantomJs;
    private boolean convertHttpToSelenium;

    private TransparentFetcher() {
    }

    public static TransparentFetcher getDefault() {
        return new TransparentFetcher();
    }

    public static Builder custom() {
        return new Builder();
    }

    @Override
    public Page fetch(Task task) throws FetchException {
        switch (task.getProtocol()) {
            case "http":
            case "https":
                if (convertHttpToPhantomJs) {
                    task.setUrl("phantomjs://".concat(task.getUrl()));
                } else if (convertHttpToSelenium) {
                    task.setUrl("selenium://".concat(task.getUrl()));
                }
            default:
                Page page = new Page();
                task.addVisitCount();
                page.setTask(task);
                page.setContent(new byte[0]);
                page.setContentType(task.getProtocol());
                return page;
        }
    }

    @Override
    public String[] getAcceptedProtocols() {
        if (convertHttpToPhantomJs || convertHttpToSelenium) {
            return new String[]{"phantomjs", "selenium", "http", "https"};
        }
        return new String[]{"phantomjs", "selenium"};
    }

    @Override
    public String getUserAgent() {
        return null;
    }

    public static class Builder {
        private boolean convertHttpToPhantomJs;
        private boolean convertHttpToSelenium;

        public Builder convertHttpTaskToPhantomJs() {
            convertHttpToPhantomJs = true;
            convertHttpToSelenium = false;
            return this;
        }

        public Builder convertHttpTaskToSelenium() {
            convertHttpToPhantomJs = false;
            convertHttpToSelenium = true;
            return this;
        }

        public TransparentFetcher build() {
            TransparentFetcher fetcher = new TransparentFetcher();
            fetcher.convertHttpToPhantomJs = convertHttpToPhantomJs;
            fetcher.convertHttpToSelenium = convertHttpToSelenium;
            return fetcher;
        }

    }
}
```


Overlapping Code:
```
Fetcher {
private boolean convertHttpToPhantomJs;
private boolean convertHttpToSelenium;
private TransparentFetcher() {
}
public static TransparentFetcher getDefault() {
return new TransparentFetcher();
}
public static Builder custom() {
return new Builder();
}
@Override
public Page fetch(Task task) throws FetchException {
switch (task.getProtocol()) {
case "http":
case "https":
if (convertHttpToPhantomJs) {
task.setUrl("phantomjs://".concat(task.getUrl()));
} else if (convertHttpToSelenium) {
task.setUrl("selenium://".concat(task.getUrl()));
}
default:
Page page = new Page();
task.addVisitCount();
page.setTask(task);
page.setContent(new byte[0]);
page.setContentType(task.getProtocol());
return page;
}
}
@Override
public String[] getAcceptedProtocols() {
if (convertHttpToPhantomJs || convertHttpToSelenium) {
return new String[]{"phantomjs", "selenium", "http", "https"};
}
return new String[]{"phantomjs", "selenium"};
}
@Override
public String getUserAgent() {
return null;
}
public static class Builder {
private boolean convertHttpToPhantomJs;
private boolean convertHttpToSelenium;
public Builder convertHttpTaskToPhantomJs() {
convertHttpToPhantomJs = true;
convertHttpToSelenium = false;
return this;
}
public Builder convertHttpTaskToSelenium() {
convertHttpToPhantomJs = false;
convertHttpToSelenium = true;
return this;
}
public TransparentFetcher build() {
TransparentFetcher fetcher = new TransparentFetcher();
fetcher.convertHttpToPhantomJs = convertHttpToPhantomJs;
fetcher.convertHttpToSelenium = convertHttpToSelenium;
retu
```
<Overlap Ratio: 0.9627329192546584>

---

--- 225 --
Question ID: 16f8bbb394f434e3c6164d31cad301c322a2d0df
Original Code:
```
@Controller
@Path("{version}/oauth2/client")
@ResourceFilters({ APIVersionFilter.class, AuthenticationFilter.class,
        BlockingFilter.class })
public class OAuthClientController {

    @Autowired
    private OAuth2ClientService clientService;
    @Autowired
    private OAuth2ScopeService scopeService;
    @Autowired
    private OAuth2ResponseHandler responseHandler;

    /**
     * Registers a client application. Before starting an OAuth
     * process, client applications have to be registered first. Only
     * registered users are allowed to register client applications.
     * 
     * After registration, the client receives a client_id and a
     * client_secret, if the client is confidential (capable of
     * storing the client_secret), that are needed in the
     * authorization process.
     * 
     * From RFC 6749:
     * The authorization server SHOULD document the size of any
     * identifier it issues.
     * 
     * @param context
     * @param clientJson
     *            a JSON object describing the client
     * @return client_id and client_secret if the client type is
     *         confidential
     * 
     * @see OAuth2ClientJson
     */
    @POST
    @Path("register")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON + ";charset=utf-8")
    public OAuth2ClientDto registerClient (
            @Context SecurityContext securityContext,
            OAuth2ClientJson clientJson) {
        TokenContext context =
                (TokenContext) securityContext.getUserPrincipal();
        try {
            scopeService.verifyScope(context, OAuth2Scope.REGISTER_CLIENT);
            return clientService.registerClient(clientJson,
                    context.getUsername());
        }
        catch (KustvaktException e) {
            throw responseHandler.throwit(e);
        }
    }

    /**
     * Deregisters a client requires client owner authentication. 
     * 
     * 
     * @param securityContext
     * @param clientId
     *            the client id
     * @return HTTP Response OK if successful.
     */
    @DELETE
    @Path("deregister/{client_id}")
    public Response deregisterClient (
            @Context SecurityContext securityContext,
            @PathParam("client_id") String clientId) {
        TokenContext context =
                (TokenContext) securityContext.getUserPrincipal();
        try {
            scopeService.verifyScope(context, OAuth2Scope.DEREGISTER_CLIENT);
            clientService.deregisterClient(clientId, context.getUsername());
            return Response.ok().build();
        }
        catch (KustvaktException e) {
            throw responseHandler.throwit(e);
        }
    }

    /**
     * Resets client secret of the given client. This controller
     * requires client owner and client authentication. Only
     * confidential clients are issued client secrets.
     * 
     * @param securityContext
     * @param clientId
     * @param clientSecret
     * @return a new client secret
     */
    @POST
    @Path("reset")
    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
    @Produces(MediaType.APPLICATION_JSON + ";charset=utf-8")
    public OAuth2ClientDto resetClientSecret (
            @Context SecurityContext securityContext,
            @FormParam("client_id") String clientId) {
        TokenContext context =
                (TokenContext) securityContext.getUserPrincipal();
        try {
            scopeService.verifyScope(context, OAuth2Scope.RESET_CLIENT_SECRET);
            return clientService.resetSecret(clientId, context.getUsername());
        }
        catch (KustvaktException e) {
            throw responseHandler.throwit(e);
        }
    }

    /**
     * Facilitates editing client privileges for admin purposes, e.g.
     * setting a specific client to be a super client.
     * Only confidential clients are allowed to be super clients.
     * 
     * When upgrading clients to super clients, existing access tokens
     * and authorization codes retain their scopes.
     * 
     * When degrading super clients, all existing tokens and
     * authorization codes are invalidated.
     * 
     * @param securityContext
     * @param clientId
     *            OAuth2 client id
     * @param super
     *            true indicating super client, false otherwise
     * @return Response status OK, if successful
     */
    @POST
    @Path("privilege")
    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
    public Response updateClientPrivilege (
            @Context SecurityContext securityContext,
            @FormParam("client_id") String clientId,
            @FormParam("super") String isSuper) {
        TokenContext context =
                (TokenContext) securityContext.getUserPrincipal();
        try {
            scopeService.verifyScope(context, OAuth2Scope.ADMIN);
            clientService.updatePrivilege(context.getUsername(), clientId,
                    Boolean.valueOf(isSuper));
            return Response.ok("SUCCESS").build();
        }
        catch (KustvaktException e) {
            throw responseHandler.throwit(e);
        }
    }

    @GET
    @Path("{client_id}")
    @Produces(MediaType.APPLICATION_JSON + ";charset=utf-8")
    public OAuth2ClientInfoDto retrieveClientInfo (
            @Context SecurityContext securityContext,
            @PathParam("client_id") String clientId) {
        TokenContext context =
                (TokenContext) securityContext.getUserPrincipal();
        try {
            scopeService.verifyScope(context, OAuth2Scope.CLIENT_INFO);
            return clientService.retrieveClientInfo(context.getUsername(),
                    clientId);
        }
        catch (KustvaktException e) {
            throw responseHandler.throwit(e);
        }
    }

    /**
     * Lists user clients having active refresh tokens (not revoked,
     * not expired), except super clients.
     * 
     * This service is not part of the OAuth2 specification. It is
     * intended to facilitate users revoking any suspicious and
     * misused access or refresh tokens.
     * 
     * Only super clients are allowed to use this service. It requires
     * user and client authentications.
     * 
     * @param context
     * @param superClientId
     *            the client id of the super client
     * @param superClientSecret
     *            the client secret of the super client
     * @return a list of clients having refresh tokens of the
     *         given user
     */
    @POST
    @Path("/list")
    @ResourceFilters({ AuthenticationFilter.class, BlockingFilter.class })
    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
    @Produces(MediaType.APPLICATION_JSON + ";charset=utf-8")
    public List<OAuth2UserClientDto> listUserAuthorizedClients (
            @Context SecurityContext context,
            @FormParam("super_client_id") String superClientId,
            @FormParam("super_client_secret") String superClientSecret,
            @FormParam("authorized_only") boolean authorizedOnly) {

        TokenContext tokenContext = (TokenContext) context.getUserPrincipal();
        String username = tokenContext.getUsername();

        try {
            scopeService.verifyScope(tokenContext,
                    OAuth2Scope.LIST_USER_CLIENT);
            if(authorizedOnly){
                return clientService.listUserAuthorizedClients(username,
                        superClientId, superClientSecret);
            }
            else {
                return clientService.listUserRegisteredClients(username,
                        superClientId, superClientSecret);                
            }
        }
        catch (KustvaktException e) {
            throw responseHandler.throwit(e);
        }
    }
}
```


Overlapping Code:
```
ient")
@ResourceFilters({ APIVersionFilter.class, AuthenticationFilter.class,
BlockingFilter.class })
public class OAuthClientController {
@Autowired
private OAuth2ClientService clientService;
@Autowired
private OAuth2ScopeService scopeService;
@Autowired
private OAuth2ResponseHandler responseHandler;
/**
* Registers a client application. Before starting an OAuth
* process, client applications have to be registered first. Only
* registered users are allowed to register client applications.
* 
* After registration, the client receives a client_id and a
* client_secret, if the client is confidential (capable of
* storing the client_secret), that are needed in the
* authorization process.
* 
* From RFC 6749:
* The authorization server SHOULD document the size of any
* identifier it issues.
* 
* @param context
* @param clientJson
* a JSON object describing the client
* @return client_id and client_secret if the client type is
* confidential
* 
* @see OAuth2ClientJson
*/
@POST
@Path("register")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON + ";charset=utf-8")
public OAuth2ClientDto registerClient (
@Context SecurityContext securityContext,
OAuth2ClientJson clientJson) {
TokenContext context =
(TokenContext) securityContext.getUserPrincipal();
try {
scopeService.verifyScope(context, OAuth2Scope.REGISTER_CLIENT);
return clientService.registerClient(clientJson,
context.getUsername());
}
catch (KustvaktException e) {
throw responseHandler.throwit(e);
}
}
/**
* Deregisters a client requires client owner authentication. 
* 
* 
* @param securityContext
* @param clientId
* the client id
* @return HTTP Response OK if successful.
*/
@DELETE
@Path("deregister/{client_id}")
public Response deregisterClient (
@Context SecurityContext securityContext,
@PathParam("client_id") String clientId) {
TokenContext context =
(TokenContext) securityContext.getUserPrincipal();
try {
scopeService.verifyScope(context, OAuth2Scope.DEREGISTER_CLIENT);
cli
```
<Overlap Ratio: 0.9778215869886644>

---

--- 226 --
Question ID: 02333fba8ff5a709c3d5a735eb011408f2713320
Original Code:
```
public class CachedProviderHandler implements InvocationHandler {

    private Map<String, Object> cached = new HashMap<>();
    private Object              target;

    public CachedProviderHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Type[] types = method.getParameterTypes();
        if (method.getName().matches("get.+") && (types.length == 1) && (types[0] == String.class)) {
            String key   = (String) args[0];
            Object value = cached.get(key);
            if (value == null) {
                value = method.invoke(target, args);
                cached.put(key, value);
            }
            return value;
        }
        return method.invoke(target, args);
    }

}
```


Overlapping Code:
```
ndler implements InvocationHandler {
private Map<String, Object> cached = new HashMap<>();
private Object target;
public CachedProviderHandler(Object target) {
this.target = target;
}
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
Type[] types = method.getParameterTypes();
if (method.getName().matches("get.+") && (types.length == 1) && (types[0] == String.class)) {
String key = (String) args[0];
Object value = cached.get(key);
if (value == null) {
value = method.invoke(target, args);
cached.put(key, value);
}
return value;
}
return method.invoke(target, args);
}
}
```
<Overlap Ratio: 0.955108359133127>

---

--- 227 --
Question ID: 2ea814cde3b519bfac60feda1d0c6c581f8f8ffe
Original Code:
```
public class MessengerServer {

    private static final Configuration config = CFGService.getInstance().getConfiguration();
    private static final int PORT             = config.getInt("server.port", 8000);
    private static final String HOST          = config.getString("server.host", "localhost");

    public static final AttributeKey<MTSession> SESSION = AttributeKey.valueOf("session");

    public static void main(String[] args) throws Exception
    {
        EventLoopGroup bossGroup   = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                     .channel(NioServerSocketChannel.class)
                     .handler(new LoggingHandler(LogLevel.INFO))
                     .childHandler(new ServerInitializer())
                     .option(ChannelOption.SO_BACKLOG, 128)
                     .childOption(ChannelOption.SO_KEEPALIVE, true);

            bootstrap.bind(HOST, PORT).sync().channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
```


Overlapping Code:
```
class MessengerServer {
private static final Configuration config = CFGService.getInstance().getConfiguration();
private static final int PORT = config.getInt("server.port", 8000);
private static final String HOST = config.getString("server.host", "localhost");
public static final AttributeKey<MTSession> SESSION = AttributeKey.valueOf("session");
public static void main(String[] args) throws Exception
{
EventLoopGroup bossGroup = new NioEventLoopGroup(1);
EventLoopGroup workerGroup = new NioEventLoopGroup();
try {
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap.group(bossGroup, workerGroup)
.channel(NioServerSocketChannel.class)
.handler(new LoggingHandler(LogLevel.INFO))
.childHandler(new ServerInitializer())
.option(ChannelOption.SO_BACKLOG, 128)
.childOption(ChannelOption.SO_KEEPALIVE, true);
bootstrap.bind(HOST, PORT).sync().channel().closeFuture().sync();
} finally {
bossGroup.shutdownGracefully();
workerGroup.shutdownGracefully();
}
}
}
```
<Overlap Ratio: 0.992827868852459>

---

--- 228 --
Question ID: 98debbf21c6e1a1c1fa8fa8982ad8c30a3ee25b2
Original Code:
```
public class SReporterParam extends SUserParam implements SArgumentInterface {
    
    /**
     * Creates a reporter param from user param.
     * @param userParam User param.
     * @throws Exception 
     */
    public SReporterParam(final SUserParam userParam) throws Exception {
        super(userParam);
    }
    
    /**
     * Creates a reporter param from XML element param.
     * @param elementParam XML element param.
     * @throws Exception 
     */
    public SReporterParam(final SElementParam elementParam) throws Exception {
        super(elementParam.getAttribute(SElementParam.ATTRIB_NAME).getValue().toString(), 
                SEnumDataType.valueOf(elementParam.getAttribute(SElementParam.ATTRIB_DATA_TYPE).getValue().toString()), 
                SReporterUtils.castDataType(SEnumDataType.valueOf(elementParam.getAttribute(SElementParam.ATTRIB_DATA_TYPE).getValue().toString()), 
                        elementParam.getAttribute(SElementParam.ATTRIB_DEFAULT_VALUE).getValue().toString()));
    }

    @Override
    public boolean isComplete() {
        return moValue != null;
    }

    @Override
    public void combine(final SXmlElement element) throws Exception {
        if (!(element instanceof SElementParam)) {
            throw new IllegalArgumentException("Invalid argument data!");
        }
        
        SElementParam elementParam = (SElementParam) element;
        
        if (msName.compareTo(elementParam.getAttribute(SElementParam.ATTRIB_NAME).getValue().toString()) != 0) {
            throw new IllegalArgumentException("Attribute '" + SElementParam.ATTRIB_NAME + "' does not match!");
        }
        
        if (meDataType != SEnumDataType.valueOf(elementParam.getAttribute(SElementParam.ATTRIB_DATA_TYPE).getValue().toString())) {
            throw new IllegalArgumentException("Attribute '" + SElementParam.ATTRIB_DATA_TYPE + "' does not match!");
        }
        
        if (moValue == null) {
            String defaultValue = elementParam.getAttribute(SElementParam.ATTRIB_DEFAULT_VALUE).getValue().toString();
            if (defaultValue == null || defaultValue.isEmpty()) {
                throw new IllegalArgumentException("Attribute '" + SElementParam.ATTRIB_DEFAULT_VALUE + "' does not exist for '" + elementParam.getAttribute(SElementParam.ATTRIB_NAME).getValue().toString() + "'.");
            }
            else {
                moValue = SReporterUtils.castDataType(meDataType, defaultValue);
            }
        }
    }
}
```


Overlapping Code:
```
ram extends SUserParam implements SArgumentInterface {

/**
* Creates a reporter param from user param.
* @param userParam User param.
* @throws Exception 
*/
public SReporterParam(final SUserParam userParam) throws Exception {
super(userParam);
}

/**
* Creates a reporter param from XML element param.
* @param elementParam XML element param.
* @throws Exception 
*/
public SReporterParam(final SElementParam elementParam) throws Exception {
super(elementParam.getAttribute(SElementParam.ATTRIB_NAME).getValue().toString(), 
SEnumDataType.valueOf(elementParam.getAttribute(SElementParam.ATTRIB_DATA_TYPE).getValue().toString()), 
SReporterUtils.castDataType(SEnumDataType.valueOf(elementParam.getAttribute(SElementParam.ATTRIB_DATA_TYPE).getValue().toString()), 
elementParam.getAttribute(SElementParam.ATTRIB_DEFAULT_VALUE).getValue().toString()));
}
@Override
public boolean isComplete() {
return moValue != null;
}
@Override
public void combine(final SXmlElement element) throws Exception {
if (!(element instanceof SElementParam)) {
throw new IllegalArgumentException("Invalid argument data!");
}

SElementParam elementParam = (SElementParam) element;

if (msName.compareTo(elementParam.getAttribute(SElementParam.ATTRIB_NAME).getValue().toString()) != 0) {
throw new IllegalArgumentException("Attribute '" + SElementParam.ATTRIB_NAME + "' does not match!");
}

if (meDataType != SEnumDataType.valueOf(elementParam.getAttribute(SElementParam.ATTRIB_DATA_TYPE).getValue().toString())) {
throw new IllegalArgumentException("Attribute '" + SElementParam.ATTRIB_DATA_TYPE + "' does not match!");
}

if (moValue == null) {
String defaultValue = elementParam.getAttribute(SElementParam.ATTRIB_DEFAULT_VALUE).getValue().toString();
if (defaultValue == null || defaultValue.isEmpty()) {
throw new IllegalArgumentException("Attribute '" + SElementParam.ATTRIB_DEFAULT_VALUE + "' does not exist for '" + elementParam.getAttribute(SElementParam.ATTRIB_NAME).getValue().toString() + "'.");
}
else {
moValue
```
<Overlap Ratio: 0.9694619486185168>

---

--- 229 --
Question ID: f2258efb122ee9e15c630901fb34f36efbd14550
Original Code:
```
@AllArgsConstructor
@NotThreadSafe
public class MerkleTreeFactory {

  private final MessageDigest digest;

  /**
   * Calculates new {@link MerkleTree} given leaves.
   *
   * @param leafs the bottom-most level of the tree (e.g. leaves)
   * @return valid {@link MerkleTree}
   * @throws IllegalArgumentException when number of leaves is not at least 1
   */
  public MerkleTree createFromLeaves(@NonNull final List<Hash> leafs) {
    ArrayTree<Hash> tree = ArrayTreeFactory.createWithNLeafs(leafs.size());  // throws

    List<Hash> nextLevel = new ArrayList<>(tree.size());

    while (!leafs.isEmpty()) {
      // copy current level (`leafs`) inside our tree at given positions
      int leftmostLevelNode = ceilToPowerOf2(leafs.size()) - 1;
      for (int i = 0; i < leafs.size(); i++) {
        tree.set(leftmostLevelNode + i, leafs.get(i));
      }

      // calculate next level
      while (leafs.size() > 1) {
        // we can get 2 elements
        val left = leafs.remove(0);
        val right = leafs.remove(0);

        if (nonNull(left) && nonNull(right)) {
          nextLevel.add(
              Util.hash(digest, left, right)
          );
        } else if (nonNull(left)) {
          nextLevel.add(left);
        } else if (nonNull(right)) {
          nextLevel.add(right);
        } else {
          // both null
          nextLevel.add(null);
        }
      }

      if (leafs.size() == 1) {
        // orphan element; we do not calculate hash from it, just pass it to the next level
        nextLevel.add(
            leafs.remove(0)
        );
      }

      if (nextLevel.size() == 1) {
        // this is root
        tree.set(0, nextLevel.remove(0));
        break;
      }

      // level is clear at this point
      assert leafs.isEmpty();
      leafs.addAll(nextLevel);
      nextLevel.clear();
    }

    return new MerkleTree(digest, tree);
  }

  /**
   * Creates new Merkle Tree from tree bytes. Performs validity check. This method should be used
   * always when you read the tree from the untrusted source.
   *
   * @param tree merkle tree as described in {@link MerkleTree}
   * @return valid {@link MerkleTree}
   * @throws RootHashMismatchException when <code>tree</code> is not valid (roots are different).
   */
  public MerkleTree createFromFullTree(@NonNull final ArrayTree<Hash> tree)
      throws RootHashMismatchException {
    MerkleTree mt = new MerkleTree(digest, tree);
    MerkleTree check = createFromLeaves(tree.getLeaves());

    if (!mt.getRoot().equals(check.getRoot())) {
      throw new RootHashMismatchException(mt.getRoot(), check.getRoot());
    }

    return mt;
  }
}
```


Overlapping Code:
```
gsConstructor
@NotThreadSafe
public class MerkleTreeFactory {
private final MessageDigest digest;
/**
* Calculates new {@link MerkleTree} given leaves.
*
* @param leafs the bottom-most level of the tree (e.g. leaves)
* @return valid {@link MerkleTree}
* @throws IllegalArgumentException when number of leaves is not at least 1
*/
public MerkleTree createFromLeaves(@NonNull final List<Hash> leafs) {
ArrayTree<Hash> tree = ArrayTreeFactory.createWithNLeafs(leafs.size()); // throws
List<Hash> nextLevel = new ArrayList<>(tree.size());
while (!leafs.isEmpty()) {
// copy current level (`leafs`) inside our tree at given positions
int leftmostLevelNode = ceilToPowerOf2(leafs.size()) - 1;
for (int i = 0; i < leafs.size(); i++) {
tree.set(leftmostLevelNode + i, leafs.get(i));
}
// calculate next level
while (leafs.size() > 1) {
// we can get 2 elements
val left = leafs.remove(0);
val right = leafs.remove(0);
if (nonNull(left) && nonNull(right)) {
nextLevel.add(
Util.hash(digest, left, right)
);
} else if (nonNull(left)) {
nextLevel.add(left);
} else if (nonNull(right)) {
nextLevel.add(right);
} else {
// both null
nextLevel.add(null);
}
}
if (leafs.size() == 1) {
// orphan element; we do not calculate hash from it, just pass it to the next level
nextLevel.add(
leafs.remove(0)
);
}
if (nextLevel.size() == 1) {
// this is root
tree.set(0, nextLevel.remove(0));
break;
}
// level is clear at this point
assert leafs.isEmpty();
leafs.addAll(nextLevel);
nextLevel.clear();
}
return new MerkleTree(digest, tree);
}
/**
* Creates new Merkle Tree from tree bytes. Performs validity check. This method should be used
* always when you read the tree from the untrusted source.
*
* @param tree merkle tree as described in {@link MerkleTree}
* @return valid {@link MerkleTree}
* @throws RootHashMismatchException when <code>tree</code> is not valid (roots are different).
*/
public MerkleTree createFromFullTree(@NonNull final ArrayTree<Hash> tree)
throws RootHashMismatchException {
MerkleTree mt = new MerkleTree(digest, tree);
MerkleTree check = cre
```
<Overlap Ratio: 0.9757258448357925>

---

--- 230 --
Question ID: 6dfd7ed680985674c7a28d61ba08a9ffd7895c65
Original Code:
```
public class Guess1 {
   public static void main(String[] args) {
   final int SECRET_NUMBER = 535;
   int guess;
   Scanner kb = new Scanner(System.in);
   
   // initialize the border condition variable
   System.out.print("Guess the secret number: ");
   guess = kb.nextInt();
   
   while (guess != SECRET_NUMBER)  {
      
      System.out.print("Guess again: ");
      guess = kb.nextInt();
   
   }
   
   System.out.println("You got it!");
        
   } // main()
}
```


Overlapping Code:
```
ublic class Guess1 {
public static void main(String[] args) {
final int SECRET_NUMBER = 535;
int guess;
Scanner kb = new Scanner(System.in);

// initialize the border condition variable
System.out.print("Guess the secret number: ");
guess = kb.nextInt();

while (guess != SECRET_NUMBER) {

System.out.print("Guess again: ");
guess = kb.nextInt();

}

System.out.println("You got it!");

} // main()
}
```
<Overlap Ratio: 0.9975062344139651>

---

--- 231 --
Question ID: 1a66b5926a436792c4e6e85893917c876d89113e
Original Code:
```
public class IntervalsResourceTest
{
  private InventoryView inventoryView;
  private DruidServer server;
  private List<DataSegment> dataSegmentList;
  private HttpServletRequest request;

  @Before
  public void setUp()
  {
    inventoryView = EasyMock.createStrictMock(InventoryView.class);
    server = EasyMock.createStrictMock(DruidServer.class);
    request = EasyMock.createStrictMock(HttpServletRequest.class);

    dataSegmentList = new ArrayList<>();
    dataSegmentList.add(
        new DataSegment(
            "datasource1",
            Intervals.of("2010-01-01T00:00:00.000Z/P1D"),
            null,
            null,
            null,
            null,
            null,
            0x9,
            20
        )
    );
    dataSegmentList.add(
        new DataSegment(
            "datasource1",
            Intervals.of("2010-01-22T00:00:00.000Z/P1D"),
            null,
            null,
            null,
            null,
            null,
            0x9,
            10
        )
    );
    dataSegmentList.add(
        new DataSegment(
            "datasource2",
            Intervals.of("2010-01-01T00:00:00.000Z/P1D"),
            null,
            null,
            null,
            null,
            null,
            0x9,
            5
        )
    );
    server = new DruidServer("who", "host", null, 1234, ServerType.HISTORICAL, "tier1", 0);
    server.addDataSegment(dataSegmentList.get(0).getIdentifier(), dataSegmentList.get(0));
    server.addDataSegment(dataSegmentList.get(1).getIdentifier(), dataSegmentList.get(1));
    server.addDataSegment(dataSegmentList.get(2).getIdentifier(), dataSegmentList.get(2));
  }

  @Test
  public void testGetIntervals()
  {
    EasyMock.expect(inventoryView.getInventory()).andReturn(
        ImmutableList.of(server)
    ).atLeastOnce();
    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED)).andReturn(null).once();
    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT)).andReturn(
        new AuthenticationResult("druid", "druid", null)
    ).once();
    request.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true);
    EasyMock.expectLastCall().times(1);
    EasyMock.replay(inventoryView, request);

    List<Interval> expectedIntervals = new ArrayList<>();
    expectedIntervals.add(Intervals.of("2010-01-01T00:00:00.000Z/2010-01-02T00:00:00.000Z"));
    expectedIntervals.add(Intervals.of("2010-01-22T00:00:00.000Z/2010-01-23T00:00:00.000Z"));
    IntervalsResource intervalsResource = new IntervalsResource(
        inventoryView,
        new AuthConfig(),
        AuthTestUtils.TEST_AUTHORIZER_MAPPER
    );

    Response response = intervalsResource.getIntervals(request);
    TreeMap<Interval, Map<String, Map<String, Object>>> actualIntervals = (TreeMap) response.getEntity();
    Assert.assertEquals(2, actualIntervals.size());
    Assert.assertEquals(expectedIntervals.get(1), actualIntervals.firstKey());
    Assert.assertEquals(10L, actualIntervals.get(expectedIntervals.get(1)).get("datasource1").get("size"));
    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(1)).get("datasource1").get("count"));
    Assert.assertEquals(expectedIntervals.get(0), actualIntervals.lastKey());
    Assert.assertEquals(20L, actualIntervals.get(expectedIntervals.get(0)).get("datasource1").get("size"));
    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(0)).get("datasource1").get("count"));
    Assert.assertEquals(5L, actualIntervals.get(expectedIntervals.get(0)).get("datasource2").get("size"));
    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(0)).get("datasource2").get("count"));

  }

  @Test
  public void testSimpleGetSpecificIntervals()
  {
    EasyMock.expect(inventoryView.getInventory()).andReturn(
        ImmutableList.of(server)
    ).atLeastOnce();
    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED)).andReturn(null).once();
    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT)).andReturn(
        new AuthenticationResult("druid", "druid", null)
    ).once();
    request.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true);
    EasyMock.expectLastCall().times(1);
    EasyMock.replay(inventoryView, request);

    List<Interval> expectedIntervals = new ArrayList<>();
    expectedIntervals.add(Intervals.of("2010-01-01T00:00:00.000Z/2010-01-02T00:00:00.000Z"));
    IntervalsResource intervalsResource = new IntervalsResource(
        inventoryView,
        new AuthConfig(),
        AuthTestUtils.TEST_AUTHORIZER_MAPPER
    );

    Response response = intervalsResource.getSpecificIntervals("2010-01-01T00:00:00.000Z/P1D", "simple", null, request);
    Map<Interval, Map<String, Object>> actualIntervals = (Map) response.getEntity();
    Assert.assertEquals(1, actualIntervals.size());
    Assert.assertTrue(actualIntervals.containsKey(expectedIntervals.get(0)));
    Assert.assertEquals(25L, actualIntervals.get(expectedIntervals.get(0)).get("size"));
    Assert.assertEquals(2, actualIntervals.get(expectedIntervals.get(0)).get("count"));

  }

  @Test
  public void testFullGetSpecificIntervals()
  {
    EasyMock.expect(inventoryView.getInventory()).andReturn(
        ImmutableList.of(server)
    ).atLeastOnce();
    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED)).andReturn(null).once();
    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT)).andReturn(
        new AuthenticationResult("druid", "druid", null)
    ).once();
    request.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true);
    EasyMock.expectLastCall().times(1);
    EasyMock.replay(inventoryView, request);

    List<Interval> expectedIntervals = new ArrayList<>();
    expectedIntervals.add(Intervals.of("2010-01-01T00:00:00.000Z/2010-01-02T00:00:00.000Z"));
    IntervalsResource intervalsResource = new IntervalsResource(
        inventoryView,
        new AuthConfig(),
        AuthTestUtils.TEST_AUTHORIZER_MAPPER
    );

    Response response = intervalsResource.getSpecificIntervals("2010-01-01T00:00:00.000Z/P1D", null, "full", request);
    TreeMap<Interval, Map<String, Map<String, Object>>> actualIntervals = (TreeMap) response.getEntity();
    Assert.assertEquals(1, actualIntervals.size());
    Assert.assertEquals(expectedIntervals.get(0), actualIntervals.firstKey());
    Assert.assertEquals(20L, actualIntervals.get(expectedIntervals.get(0)).get("datasource1").get("size"));
    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(0)).get("datasource1").get("count"));
    Assert.assertEquals(5L, actualIntervals.get(expectedIntervals.get(0)).get("datasource2").get("size"));
    Assert.assertEquals(1, actualIntervals.get(expectedIntervals.get(0)).get("datasource2").get("count"));

  }

  @Test
  public void testGetSpecificIntervals()
  {
    EasyMock.expect(inventoryView.getInventory()).andReturn(
        ImmutableList.of(server)
    ).atLeastOnce();
    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED)).andReturn(null).once();
    EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT)).andReturn(
        new AuthenticationResult("druid", "druid", null)
    ).once();
    request.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true);
    EasyMock.expectLastCall().times(1);
    EasyMock.replay(inventoryView, request);

    IntervalsResource intervalsResource = new IntervalsResource(
        inventoryView,
        new AuthConfig(),
        AuthTestUtils.TEST_AUTHORIZER_MAPPER
    );

    Response response = intervalsResource.getSpecificIntervals("2010-01-01T00:00:00.000Z/P1D", null, null, request);
    Map<String, Object> actualIntervals = (Map) response.getEntity();
    Assert.assertEquals(2, actualIntervals.size());
    Assert.assertEquals(25L, actualIntervals.get("size"));
    Assert.assertEquals(2, actualIntervals.get("count"));
  }

  @After
  public void tearDown()
  {
    EasyMock.verify(inventoryView);
  }

}
```


Overlapping Code:
```
st
{
private InventoryView inventoryView;
private DruidServer server;
private List<DataSegment> dataSegmentList;
private HttpServletRequest request;
@Before
public void setUp()
{
inventoryView = EasyMock.createStrictMock(InventoryView.class);
server = EasyMock.createStrictMock(DruidServer.class);
request = EasyMock.createStrictMock(HttpServletRequest.class);
dataSegmentList = new ArrayList<>();
dataSegmentList.add(
new DataSegment(
"datasource1",
Intervals.of("2010-01-01T00:00:00.000Z/P1D"),
null,
null,
null,
null,
null,
0x9,
20
)
);
dataSegmentList.add(
new DataSegment(
"datasource1",
Intervals.of("2010-01-22T00:00:00.000Z/P1D"),
null,
null,
null,
null,
null,
0x9,
10
)
);
dataSegmentList.add(
new DataSegment(
"datasource2",
Intervals.of("2010-01-01T00:00:00.000Z/P1D"),
null,
null,
null,
null,
null,
0x9,
5
)
);
server = new DruidServer("who", "host", null, 1234, ServerType.HISTORICAL, "tier1", 0);
server.addDataSegment(dataSegmentList.get(0).getIdentifier(), dataSegmentList.get(0));
server.addDataSegment(dataSegmentList.get(1).getIdentifier(), dataSegmentList.get(1));
server.addDataSegment(dataSegmentList.get(2).getIdentifier(), dataSegmentList.get(2));
}
@Test
public void testGetIntervals()
{
EasyMock.expect(inventoryView.getInventory()).andReturn(
ImmutableList.of(server)
).atLeastOnce();
EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED)).andReturn(null).once();
EasyMock.expect(request.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT)).andReturn(
new AuthenticationResult("druid", "druid", null)
).once();
request.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true);
EasyMock.expectLastCall().times(1);
EasyMock.replay(inventoryView, request);
List<Interval> expectedIntervals = new ArrayList<>();
expectedIntervals.add(Intervals.of("2010-01-01T00:00:00.000Z/2010-01-02T00:00:00.000Z"));
expectedIntervals.add(Intervals.of("2010-01-22T00:
```
<Overlap Ratio: 0.9596163553760727>

---

--- 232 --
Question ID: 3d65c8b08719fa1d075000c214e0e5ce5ba9d10f
Original Code:
```
public class DefaultValidator implements Validator {
  private final List<Rule> rules = new LinkedList<Rule>();
  private final List<Tester> testers = new LinkedList<Tester>();

  public DefaultValidator(List<Rule> rules, List<Tester> testers) {
    this.rules.addAll(rules);
    this.testers.addAll(testers);
  }

  public void validate(PojoClass pojoClass) {
    ValidationHelper.runValidation(pojoClass, this.rules, this.testers);
  }

  public void validate(List<PojoClass> pojoClasses) {
    for (PojoClass pojoClass : pojoClasses)
      validate(pojoClass);
  }

  public List<PojoClass> validate(String packageName, PojoClassFilter... filters) {
    PojoClassFilter pojoClassFilter = new FilterChain(filters);
    List<PojoClass> pojoClasses = PojoClassFactory.getPojoClasses(packageName, pojoClassFilter);
    validate(pojoClasses);
    return pojoClasses;
  }

  public List<PojoClass> validateRecursively(String packageName, PojoClassFilter... filters) {
    PojoClassFilter pojoClassFilter = new FilterChain(filters);
    List<PojoClass> pojoClasses = PojoClassFactory.getPojoClassesRecursively(packageName, pojoClassFilter);
    validate(pojoClasses);
    return pojoClasses;
  }
}
```


Overlapping Code:
```
ublic class DefaultValidator implements Validator {
private final List<Rule> rules = new LinkedList<Rule>();
private final List<Tester> testers = new LinkedList<Tester>();
public DefaultValidator(List<Rule> rules, List<Tester> testers) {
this.rules.addAll(rules);
this.testers.addAll(testers);
}
public void validate(PojoClass pojoClass) {
ValidationHelper.runValidation(pojoClass, this.rules, this.testers);
}
public void validate(List<PojoClass> pojoClasses) {
for (PojoClass pojoClass : pojoClasses)
validate(pojoClass);
}
public List<PojoClass> validate(String packageName, PojoClassFilter... filters) {
PojoClassFilter pojoClassFilter = new FilterChain(filters);
List<PojoClass> pojoClasses = PojoClassFactory.getPojoClasses(packageName, pojoClassFilter);
validate(pojoClasses);
return pojoClasses;
}
public List<PojoClass> validateRecursively(String packageName, PojoClassFilter... filters) {
PojoClassFilter pojoClassFilter = new FilterChain(filters);
List<PojoClass> pojoClasses = PojoClassFactory.getPojoClassesRecursively(packageName, pojoClassFilter);
validate(pojoClasses);
retur
```
<Overlap Ratio: 0.9828828828828828>

---

--- 233 --
Question ID: dad71efdee9071062b43597211c7bb33b7520245
Original Code:
```
@SuppressWarnings("deprecation")
public class BlockAsymmetricalMachination extends BlockBaseFacing {

	private static final ImmutableMap<EnumFacing, AxisAlignedBB> BB_MAP = FacingAlignedBB.create(
			new Vector3(2, 6.5, 2),
			new Vector3(14, 15.5, 14),
			EnumFacing.UP
	).build();

	public BlockAsymmetricalMachination() {
		super(LibNames.ASYMMETRICAL_MACHINATION, IPMMaterial.MONOLITH);
		setDefaultState(getDefaultState().withProperty(BlockDirectional.FACING, EnumFacing.UP));
		setHarvestLevel(Tool.PICK, ToolLevel.STONE);
		setHardness(1F);
	}

	@Override
	public void randomDisplayTick(IBlockState state, World world, BlockPos pos, Random rand) {
		EnumFacing facing = state.getValue(BlockDirectional.FACING).getOpposite();
		BlockPos.MutableBlockPos posOffset = new BlockPos.MutableBlockPos(pos);
		float distance = 0;
		while(distance++ < Constants.REACH) {
			IBlockState found = world.getBlockState(posOffset.move(facing));
			if(found.getBlock() == ModBlocks.SYMMETRICAL_MACHINATION && found.getValue(BlockDirectional.FACING) == facing) {
				Vector3 offset = new Vector3.WrappedVec3i(facing.getDirectionVec()).asImmutable();
				Vector3 from = new Vector3.WrappedVec3i(pos).asImmutable().add(0.5D).offset(offset, -0.19);
				IPM.getProxy().spawnBeam(world, from, offset, distance + 0.41F, 36, 0.75F, 0xFF0303, Light.GLOW, GlowTexture.GLOW.getTexture());
				break;
			} else if(found.getBlock() == ModBlocks.ASYMMETRICAL_MACHINATION) break;
		}
	}

	@Override
	public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
		EnumFacing facing = state.getValue(BlockDirectional.FACING);
		return BB_MAP.getOrDefault(facing, FULL_BLOCK_AABB);
	}

	@Override
	public boolean hasTileEntity(IBlockState state) {
		return true;
	}

	@Nullable
	@Override
	public TileEntity createTileEntity(World world, IBlockState state) {
		return new TileAsymmetricalMachination();
	}

	@Override
	@SideOnly(Side.CLIENT)
	public void registerModel() {
		DummyModelRegistry.register(this, new ModelRendered()
				.setParticle(ResourceLibrary.ASYMMETRICAL_MACHINATION)
		);
		ModelHelper.registerModel(this, 0);
	}

	public static class Constants {
		public static int REACH = 15;
	}
}
```


Overlapping Code:
```
@SuppressWarnings("deprecation")
public class BlockAsymmetricalMachination extends BlockBaseFacing {
private static final ImmutableMap<EnumFacing, AxisAlignedBB> BB_MAP = FacingAlignedBB.create(
new Vector3(2, 6.5, 2),
new Vector3(14, 15.5, 14),
EnumFacing.UP
).build();
public BlockAsymmetricalMachination() {
super(LibNames.ASYMMETRICAL_MACHINATION, IPMMaterial.MONOLITH);
setDefaultState(getDefaultState().withProperty(BlockDirectional.FACING, EnumFacing.UP));
setHarvestLevel(Tool.PICK, ToolLevel.STONE);
setHardness(1F);
}
@Override
public void randomDisplayTick(IBlockState state, World world, BlockPos pos, Random rand) {
EnumFacing facing = state.getValue(BlockDirectional.FACING).getOpposite();
BlockPos.MutableBlockPos posOffset = new BlockPos.MutableBlockPos(pos);
float distance = 0;
while(distance++ < Constants.REACH) {
IBlockState found = world.getBlockState(posOffset.move(facing));
if(found.getBlock() == ModBlocks.SYMMETRICAL_MACHINATION && found.getValue(BlockDirectional.FACING) == facing) {
Vector3 offset = new Vector3.WrappedVec3i(facing.getDirectionVec()).asImmutable();
Vector3 from = new Vector3.WrappedVec3i(pos).asImmutable().add(0.5D).offset(offset, -0.19);
IPM.getProxy().spawnBeam(world, from, offset, distance + 0.41F, 36, 0.75F, 0xFF0303, Light.GLOW, GlowTexture.GLOW.getTexture());
break;
} else if(found.getBlock() == ModBlocks.ASYMMETRICAL_MACHINATION) break;
}
}
@Override
public AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos pos) {
EnumFacing facing = state.getValue(BlockDirectional.FACING);
return BB_MAP.getOrDefault(facing, FULL_BLOCK_AABB);
}
@Override
public boolean hasTileEntity(IBlockState state) {
return true;
}
@Nullable
@Override
public TileEntity createTileEntity(World world, IBlockState state) {
return new TileAsymmetricalMachination();
}
@Override
@SideOnly(Side.CLIENT)
public void registerModel() {
DummyModelRegistry.register(this, new ModelRendered()
.setParticle(ResourceLibrary.ASYMMETRICAL_MACHINATION)
);
ModelHelper.registerModel(this, 0);
}
public static class Constants {
public static int 
```
<Overlap Ratio: 0.9928707224334601>

---

--- 234 --
Question ID: bebee3f8b444cdb362eba93d17a3bfd5bee7eb9d
Original Code:
```
public class msg_image_trigger_control extends MAVLinkMessage{

	public static final int MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL = 153;
	public static final int MAVLINK_MSG_LENGTH = 1;
	private static final long serialVersionUID = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;
	

 	/**
	* 0 to disable, 1 to enable
	*/
	public byte enable; 

	/**
	 * Generates the payload for a mavlink message for a message of this type
	 * @return
	 */
	public MAVLinkPacket pack(){
		MAVLinkPacket packet = new MAVLinkPacket();
		packet.len = MAVLINK_MSG_LENGTH;
		packet.sysid = 255;
		packet.compid = 190;
		packet.msgid = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;
		packet.payload.putByte(enable);
		return packet;		
	}

    /**
     * Decode a image_trigger_control message into this class fields
     *
     * @param payload The message to decode
     */
    public void unpack(MAVLinkPayload payload) {
        payload.resetIndex();
	    enable = payload.getByte();    
    }

     /**
     * Constructor for a new message, just initializes the msgid
     */
    public msg_image_trigger_control(){
    	msgid = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;
    }

    /**
     * Constructor for a new message, initializes the message with the payload
     * from a mavlink packet
     * 
     */
    public msg_image_trigger_control(MAVLinkPacket mavLinkPacket){
        this.sysid = mavLinkPacket.sysid;
        this.compid = mavLinkPacket.compid;
        this.msgid = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;
        unpack(mavLinkPacket.payload);
        //Log.d("MAVLink", "IMAGE_TRIGGER_CONTROL");
        //Log.d("MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL", toString());
    }
    
  
    /**
     * Returns a string with the MSG name and data
     */
    public String toString(){
    	return "MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL -"+" enable:"+enable+"";
    }
}
```


Overlapping Code:
```
_control extends MAVLinkMessage{
public static final int MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL = 153;
public static final int MAVLINK_MSG_LENGTH = 1;
private static final long serialVersionUID = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;

/**
* 0 to disable, 1 to enable
*/
public byte enable; 
/**
* Generates the payload for a mavlink message for a message of this type
* @return
*/
public MAVLinkPacket pack(){
MAVLinkPacket packet = new MAVLinkPacket();
packet.len = MAVLINK_MSG_LENGTH;
packet.sysid = 255;
packet.compid = 190;
packet.msgid = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;
packet.payload.putByte(enable);
return packet; 
}
/**
* Decode a image_trigger_control message into this class fields
*
* @param payload The message to decode
*/
public void unpack(MAVLinkPayload payload) {
payload.resetIndex();
enable = payload.getByte(); 
}
/**
* Constructor for a new message, just initializes the msgid
*/
public msg_image_trigger_control(){
msgid = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;
}
/**
* Constructor for a new message, initializes the message with the payload
* from a mavlink packet
* 
*/
public msg_image_trigger_control(MAVLinkPacket mavLinkPacket){
this.sysid = mavLinkPacket.sysid;
this.compid = mavLinkPacket.compid;
this.msgid = MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL;
unpack(mavLinkPacket.payload);
//Log.d("MAVLink", "IMAGE_TRIGGER_CONTROL");
//Log.d("MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL", toString());
}


/**
* Returns a string with the MSG name and data
*/
public String toString(){
return "MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL -"+
```
<Overlap Ratio: 0.9657320872274143>

---

--- 235 --
Question ID: bddbe429e98d65a13bc788d7d12a025d69baee36
Original Code:
```
public class BaseTestExpressions {
	@BeforeClass
	public static void createObjects(){
		d1 = new DoubleExpression(1.0);
		d2 = new DoubleExpression(2.0);
		d3 = new DoubleExpression(3.0);
		d0 = new DoubleExpression(0.0);
		
		s123 = SumExpression.create(d1,d2,d3);
		p223 = ProductExpression.create(d2,d2,d3);
		
		min23 = MinExpression.create(d2, d3);
		div23 = DivExpression.create(d2, d3);
		pdiv23 = PEPADivExpression.create(d2, d3);
		pdiv20 = PEPADivExpression.create(d2, d0);
	}
	
	protected static AbstractExpression d1, d2, d3, d0;
	
	protected static AbstractExpression s123, p223, min23, div23, pdiv23, pdiv20;
}
```


Overlapping Code:
```
lass
public static void createObjects(){
d1 = new DoubleExpression(1.0);
d2 = new DoubleExpression(2.0);
d3 = new DoubleExpression(3.0);
d0 = new DoubleExpression(0.0);

s123 = SumExpression.create(d1,d2,d3);
p223 = ProductExpression.create(d2,d2,d3);

min23 = MinExpression.create(d2, d3);
div23 = DivExpression.create(d2, d3);
pdiv23 = PEPADivExpression.create(d2, d3);
pdiv20 = PEPADivExpression.create(d2, d0);
}

protected static AbstractExpression d1, d2, d3, d0;

protected static AbstractExpression s123, p223, min23, div23, pdiv23, pdiv20;
}
```
<Overlap Ratio: 0.927487352445194>

---

--- 236 --
Question ID: 9987969a732df10b6c93795bbedeb7c2832caf4f
Original Code:
```
public class OrderableRepository extends BaseRepository {

    public static final String TAG = OrderableRepository.class.getName();
    public static final String ORDERABLE_TABLE = "orderables";
    public static final String ID = "id";
    public static final String FULL_PRODUCT_CODE = "full_product_code";
    public static final String FULL_PRODUCT_NAME = "full_product_name";
    public static final String NET_CONTENT = "net_content";
    public static final String PACK_ROUNDING_THRESHOLD = "pack_rounding_threshold";
    public static final String ROUND_TO_ZERO = "round_to_zero";
    public static final String DISPENSABLE_ID = "dispensable_id";
    public static final String TRADE_ITEM_ID = "trade_item_id";
    public static final String COMMODITY_TYPE_ID = "commodity_type_id";
    public static final String DATE_UPDATED = "date_updated";

    public static final String[] ORDERABLE_TABLE_COLUMNS = {ID, FULL_PRODUCT_CODE, FULL_PRODUCT_NAME, NET_CONTENT,
            PACK_ROUNDING_THRESHOLD, ROUND_TO_ZERO, DISPENSABLE_ID, TRADE_ITEM_ID, COMMODITY_TYPE_ID, DATE_UPDATED};
    public static final String[] SELECT_TABLE_COLUMNS = {ID, FULL_PRODUCT_CODE, FULL_PRODUCT_NAME, NET_CONTENT, DISPENSABLE_ID, TRADE_ITEM_ID, COMMODITY_TYPE_ID};

    public static final String CREATE_ORDERABLE_TABLE =

            "CREATE TABLE " + ORDERABLE_TABLE
                    + "("
                    + ID + " VARCHAR NOT NULL PRIMARY KEY,"
                    + FULL_PRODUCT_CODE + " VARCHAR NOT NULL,"
                    + FULL_PRODUCT_NAME + " VARCHAR NOT NULL,"
                    + NET_CONTENT + " INTEGER,"
                    + PACK_ROUNDING_THRESHOLD + " INTEGER,"
                    + ROUND_TO_ZERO + " TINYINT,"
                    + DISPENSABLE_ID + " VARCHAR,"
                    + TRADE_ITEM_ID + " VARCHAR,"
                    + COMMODITY_TYPE_ID + " VARCHAR,"
                    + DATE_UPDATED + " INTEGER"
                    + ")";

    private static final String CREATE_ORDERABLES_INDEX = "CREATE INDEX "
            + ORDERABLE_TABLE + "_INDEX ON "
            + ORDERABLE_TABLE + "(" + COMMODITY_TYPE_ID + "," + TRADE_ITEM_ID + ")";

    public OrderableRepository(Repository repository) {
        super();
    }

    public static void createTable(SQLiteDatabase database) {
        database.execSQL(CREATE_ORDERABLE_TABLE);
        database.execSQL(CREATE_ORDERABLES_INDEX);
    }

    public void addOrUpdate(Orderable orderable) {

        if (orderable == null) {
            return;
        }

        if (orderable.getDateUpdated() == null) {
            orderable.setDateUpdated(Calendar.getInstance().getTimeInMillis());
        }

        try {
            SQLiteDatabase database = getWritableDatabase();

            String query = String.format(INSERT_OR_REPLACE, ORDERABLE_TABLE);
            query += "(" + StringUtils.repeat("?", ",", ORDERABLE_TABLE_COLUMNS.length) + ")";
            database.execSQL(query, createQueryValues(orderable));
        } catch (Exception e) {
            Log.e(TAG, Log.getStackTraceString(e));
        }
    }

    public List<Orderable> findOrderables(String id, String fullProductCode, String fullProductName, String netContent, String dispensable, String tradeItemId, String commodityTypeId) {

        List<Orderable> orderables = new ArrayList<>();
        Cursor cursor = null;
        try {

            String[] selectionArgs = new String[]{id, fullProductCode, fullProductName, netContent, dispensable, tradeItemId, commodityTypeId};
            Pair<String, String[]> query = createQuery(selectionArgs, SELECT_TABLE_COLUMNS);

            String querySelectString = query.first;
            selectionArgs = query.second;

            cursor = getReadableDatabase().query(ORDERABLE_TABLE, ORDERABLE_TABLE_COLUMNS, querySelectString, selectionArgs, null, null, null);
            orderables = readOrderables(cursor);
        } catch (Exception e) {
            Log.e(TAG, Log.getStackTraceString(e));
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        return orderables;
    }

    public Orderable findOrderable(String id) {

        Orderable orderable = null;
        Cursor cursor = null;
        try {
            String[] selectionArgs = new String[]{id};
            Pair<String, String[]> query = createQuery(selectionArgs, SELECT_TABLE_COLUMNS);

            String querySelectString = query.first;
            selectionArgs = query.second;

            cursor = getReadableDatabase().query(ORDERABLE_TABLE, ORDERABLE_TABLE_COLUMNS, querySelectString, selectionArgs, null, null, null);
            List<Orderable> orderables = readOrderables(cursor);
            if (orderables.size() > 0) {
                orderable = orderables.get(0);
            }
        } catch (Exception e) {
            Log.e(TAG, Log.getStackTraceString(e));
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        return orderable;
    }

    public String findOrderableIdByTradeItemId(String tradeItemId) {
        Cursor cursor = null;
        try {
            String[] selectionArgs = new String[]{tradeItemId};
            Pair<String, String[]> query = createQuery(selectionArgs, new String[]{TRADE_ITEM_ID});

            String querySelectString = query.first;
            selectionArgs = query.second;

            cursor = getReadableDatabase().query(ORDERABLE_TABLE, new String[]{ID}, querySelectString, selectionArgs, null, null, null);
            if (cursor.moveToFirst())
                return cursor.getString(0);
        } catch (Exception e) {
            Log.e(TAG, Log.getStackTraceString(e));
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        return null;
    }


    private List<Orderable> readOrderables(Cursor cursor) {

        List<Orderable> orderables = new ArrayList<>();
        try {
            if (cursor != null && cursor.getCount() > 0 && cursor.moveToFirst()) {
                while (!cursor.isAfterLast()) {
                    orderables.add(createOrderable(cursor));
                    cursor.moveToNext();
                }
            }
        } catch (Exception e) {
            Log.e(TAG, Log.getStackTraceString(e));
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        return orderables;
    }

    private Orderable createOrderable(Cursor cursor) {

        return new Orderable(
                cursor.getString(cursor.getColumnIndex(ID)),
                cursor.getString(cursor.getColumnIndex(FULL_PRODUCT_CODE)),
                cursor.getString(cursor.getColumnIndex(FULL_PRODUCT_NAME)),
                cursor.getLong(cursor.getColumnIndex(NET_CONTENT)),
                cursor.getLong(cursor.getColumnIndex(PACK_ROUNDING_THRESHOLD)),
                convertIntToBoolean(cursor.getInt(cursor.getColumnIndex(ROUND_TO_ZERO))),
                cursor.getString(cursor.getColumnIndex(DISPENSABLE_ID)),
                cursor.getString(cursor.getColumnIndex(TRADE_ITEM_ID)),
                cursor.getString(cursor.getColumnIndex(COMMODITY_TYPE_ID))
        );
    }

    private Object[] createQueryValues(Orderable orderable) {

        Object[] values = new Object[]{
                orderable.getId(),
                orderable.getFullProductCode(),
                orderable.getFullProductName(),
                orderable.getNetContent(),
                orderable.getPackRoundingThreshold(),
                convertBooleanToInt(orderable.isRoundToZero()),
                orderable.getDispensableId(),
                orderable.getTradeItemId(),
                orderable.getCommodityTypeId(),
                orderable.getDateUpdated()
        };
        return values;
    }


}
```


Overlapping Code:
```
pository extends BaseRepository {
public static final String TAG = OrderableRepository.class.getName();
public static final String ORDERABLE_TABLE = "orderables";
public static final String ID = "id";
public static final String FULL_PRODUCT_CODE = "full_product_code";
public static final String FULL_PRODUCT_NAME = "full_product_name";
public static final String NET_CONTENT = "net_content";
public static final String PACK_ROUNDING_THRESHOLD = "pack_rounding_threshold";
public static final String ROUND_TO_ZERO = "round_to_zero";
public static final String DISPENSABLE_ID = "dispensable_id";
public static final String TRADE_ITEM_ID = "trade_item_id";
public static final String COMMODITY_TYPE_ID = "commodity_type_id";
public static final String DATE_UPDATED = "date_updated";
public static final String[] ORDERABLE_TABLE_COLUMNS = {ID, FULL_PRODUCT_CODE, FULL_PRODUCT_NAME, NET_CONTENT,
PACK_ROUNDING_THRESHOLD, ROUND_TO_ZERO, DISPENSABLE_ID, TRADE_ITEM_ID, COMMODITY_TYPE_ID, DATE_UPDATED};
public static final String[] SELECT_TABLE_COLUMNS = {ID, FULL_PRODUCT_CODE, FULL_PRODUCT_NAME, NET_CONTENT, DISPENSABLE_ID, TRADE_ITEM_ID, COMMODITY_TYPE_ID};
public static final String CREATE_ORDERABLE_TABLE =
"CREATE TABLE " + ORDERABLE_TABLE
+ "("
+ ID + " VARCHAR NOT NULL PRIMARY KEY,"
+ FULL_PRODUCT_CODE + " VARCHAR NOT NULL,"
+ FULL_PRODUCT_NAME + " VARCHAR NOT NULL,"
+ NET_CONTENT + " INTEGER,"
+ PACK_ROUNDING_THRESHOLD + " INTEGER,"
+ ROUND_TO_ZERO + " TINYINT,"
+ DISPENSABLE_ID + " VARCHAR,"
+ TRADE_ITEM_ID + " VARCHAR,"
+ COMMODITY_TYPE_ID + " VARCHAR,"
+ DATE_UPDATED + " INTEGER"
+ ")";
private static final String CREATE_ORDERABLES_INDEX = "CREATE INDEX "
+ ORDERABLE_TABLE + "_INDEX ON "
+ ORDERABLE_TABLE + "(" + COMMODITY_TYPE_ID + "," + TRADE_ITEM_ID + ")";
public OrderableRepository(Repository repository) {
super();
}
public static void createTable(SQLiteDatabase database) {
database.execSQL(CREATE_ORDERABLE_TABLE);
database.execSQL(CREATE_ORDERABLES_INDEX);
}
public void addOrUpdate(Orderable orderable) {
if (orderable == nul
```
<Overlap Ratio: 0.9865449303219606>

---

--- 237 --
Question ID: 1e85f5e16bc02c980256ff551a737acba3b1e565
Original Code:
```
public class LocalizationManagerTest {
  private Logger log;
  private Logger cachedLogger;
  private LocalizationManager localizationManager;
  private ExecutorService executorService;

  @Before
  public void setup() {
    log = mock( Logger.class );
    cachedLogger = LocalizationManager.getLog();
    localizationManager = new LocalizationManager();
    executorService = mock( ExecutorService.class );
  }

  @After
  public void teardown() {
    LocalizationManager.setLog( cachedLogger );
  }

  @Test
  public void testLocalizationManager() throws IOException, ParseException {
    localizationManager.setExecutorService( executorService );
    assertBundleNullCacheNull( "messages", "de", "DE" );

    assertBundleNullCacheNullRegexp( Pattern.compile( "messages" ),
      "de", "DE" );

    localizationManager.bundleChanged( makeMockBundleNull( 1L, Bundle.ACTIVE ) );
    assertBundleNullCacheNull( "messages", "de", "DE" );
    assertBundleNullCacheNull( null, "de", "DE" );
    assertBundleNullCacheNull( "messages", null );

    localizationManager.setExecutorService( null );
    assertBundleNullCacheNull( "messages", "de", "DE" );
    assertBundleNullCacheNull( null, "de", "DE" );
    assertBundleNullCacheNull( "messages", null );
    localizationManager.bundleChanged( makeMockBundle( 1L, Bundle.ACTIVE, "i18n/bundle/messages.properties",
      "i18n/bundle/messages_fr.properties", "i18n/bundle/messages_de_DE.properties" ) );
    assertBundleNullCacheNull( null, "de", "DE" );
    assertBundleNullCacheNull( "", "de", "DE" );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "fakeLocale" );
    assertBundleKeyEquals( "key", "bundle/messages", "key", "fakeLocale" );
    assertBundleKeyEquals( "key_fr", "bundle/messages", "key", "fr" );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "fr" );
    assertBundleKeyEquals( "key_fr", "bundle/messages", "key", "fr", "FR" );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "fr", "FR" );
    assertBundleKeyEquals( "key", "bundle/messages", "key", "de" );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "de" );
    assertBundleKeyEquals( "key_de_DE", "bundle/messages", "key", "de", "DE" );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "de", "DE" );

    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "fakeLocale" );
    assertBundlePatternKeyEquals( "key", Pattern.compile( ".*messages" ), "key", "fakeLocale" );
    assertBundlePatternKeyEquals( "key_fr", Pattern.compile( ".*messages" ), "key", "fr" );
    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "fr" );
    assertBundlePatternKeyEquals( "key_fr", Pattern.compile( ".*messages" ), "key", "fr", "FR" );
    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "fr", "FR" );
    assertBundlePatternKeyEquals( "key", Pattern.compile( ".*messages" ), "key", "de" );
    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "de" );
    assertBundlePatternKeyEquals( "key_de_DE", Pattern.compile( ".*messages" ), "key", "de", "DE" );
    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "de", "DE" );

    localizationManager.bundleChanged( makeMockBundle( 2L, Bundle.ACTIVE, "i18n/bundle/messages_fr.properties.2" ) );
    assertBundleKeyEquals( "key_fr_bundle2", "bundle/messages", "key", "fr" );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "fr" );
    assertBundleKeyEquals( "key for priority 2", "bundle/messages", "key2", "fr" );

    assertBundlePatternKeyEquals( "key_fr_bundle2", Pattern.compile( ".*messages" ), "key", "fr" );
    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "fr" );
    assertBundlePatternKeyEquals( "key for priority 2", Pattern.compile( ".*messages" ), "key2", "fr" );

    //test bundle 2L stopping
    localizationManager.bundleChanged( makeMockBundle( 2L, Bundle.RESOLVED, "i18n/bundle/messages_fr.properties.2" ) );
    assertBundleKeyEquals( "key_fr", "bundle/messages", "key", "fr" );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "fr" );
    assertBundlePatternKeyEquals( "key_fr", Pattern.compile( ".*messages" ), "key", "fr" );
    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "fr" );

    localizationManager.bundleChanged( makeMockBundle( 3L, Bundle.ACTIVE, "i18n/bundle/messages_fr.properties.3" ) );
    assertBundleKeyEquals( "key_fr_bundle3", "bundle/messages", "key", "fr" );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "fr" );
    assertBundleKeyEquals( "key for priority 3", "bundle/messages", "key3", "fr" );

    assertBundlePatternKeyEquals( "key_fr_bundle3", Pattern.compile( ".*messages" ), "key", "fr" );
    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "fr" );
    assertBundlePatternKeyEquals( "key for priority 3", Pattern.compile( ".*messages" ), "key3", "fr" );

    localizationManager.bundleChanged( makeMockBundle( 4L, Bundle.ACTIVE, "i18n/bundle/messages_fr.properties.4" ) );
    assertBundleKeyEquals( "key_fr_bundle4", "bundle/messages", "key", "fr" );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "fr" );
    assertBundleKeyEquals( "key for priority 3", "bundle/messages", "key3", "fr" );

    assertBundlePatternKeyEquals( "key_fr_bundle4", Pattern.compile( ".*messages" ), "key", "fr" );
    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "fr" );
    assertBundlePatternKeyEquals( "key for priority 3", Pattern.compile( ".*messages" ), "key3", "fr" );

    localizationManager.bundleChanged( makeMockBundle( 5L, Bundle.ACTIVE, "fakepath" ) );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "fakeLocale" );
    assertBundleKeyEquals( "key", "bundle/messages", "key", "fakeLocale" );
    assertBundleKeyEquals( "key_fr_bundle4", "bundle/messages", "key", "fr" );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "fr" );
    assertBundleKeyEquals( "key_fr_bundle4", "bundle/messages", "key", "fr", "FR" );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "fr", "FR" );
    assertBundleKeyEquals( "key", "bundle/messages", "key", "de" );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "de" );
    assertBundleKeyEquals( "key_de_DE", "bundle/messages", "key", "de", "DE" );
    assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "de", "DE" );

    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "fakeLocale" );
    assertBundlePatternKeyEquals( "key", Pattern.compile( ".*messages" ), "key", "fakeLocale" );
    assertBundlePatternKeyEquals( "key_fr_bundle4", Pattern.compile( ".*messages" ), "key", "fr" );
    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "fr" );
    assertBundlePatternKeyEquals( "key_fr_bundle4", Pattern.compile( ".*messages" ), "key", "fr", "FR" );
    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "fr", "FR" );
    assertBundlePatternKeyEquals( "key", Pattern.compile( ".*messages" ), "key", "de" );
    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "de" );
    assertBundlePatternKeyEquals( "key_de_DE", Pattern.compile( ".*messages" ), "key", "de", "DE" );
    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "de", "DE" );
    assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "" );
  }

  @Test
  public void testLocalosationManagerWrongCache()
    throws IOException, ParseException, ExecutionException, InterruptedException {
    localizationManager.setExecutorService( mockExecutorServiceWithCacheTrowingError() );
    localizationManager.bundleChanged( makeMockBundle( 2L, Bundle.ACTIVE, "i18n/bundle/messages_fr.properties.2" ) );
    assertBundleNullCacheNull("bundle/messages", "key", "fr" );
  }

  private ExecutorService mockExecutorServiceWithCacheTrowingError() throws ExecutionException, InterruptedException {
    Future<Map<String, OSGIResourceBundle>> mockF = mock( Future.class );
    when( mockF.get() ).thenThrow( InterruptedException.class );
    ExecutorService service = mock( ExecutorService.class );
    when( service.submit( Matchers.any( Callable.class ) ) ).thenReturn( mockF );
    return service;
  }

  private void assertBundleKeyEquals( String expected, String key, String valueKey,
                                      String... localeStrings ) {
    Locale locale = null;
    if ( localeStrings.length == 1 ) {
      locale = new Locale( localeStrings[ 0 ] );
    } else if ( localeStrings.length == 2 ) {
      locale = new Locale( localeStrings[ 0 ], localeStrings[ 1 ] );
    } else {
      throw new RuntimeException( "Expected either 1 or 2 locale strings" );
    }
    assertEquals( expected, localizationManager.getResourceBundle( key, locale ).getString( valueKey ) );
  }

  private void assertBundlePatternKeyEquals( String expected, Pattern keyRegex, String valueKey,
                                             String... localeStrings ) {
    Locale locale = null;
    if ( localeStrings.length == 1 ) {
      locale = new Locale( localeStrings[ 0 ] );
    } else if ( localeStrings.length == 2 ) {
      locale = new Locale( localeStrings[ 0 ], localeStrings[ 1 ] );
    } else {
      throw new RuntimeException( "Expected either 1 or 2 locale strings" );
    }
    assertEquals( expected,
      localizationManager.getResourceBundles( keyRegex, locale ).get( 0 ).getString( valueKey ) );
  }

  private void assertBundleNullCacheNull( String key, String... localeStrings ) {
    Locale locale = null;

    if ( localeStrings != null ) {
      if ( localeStrings.length == 1 ) {
        locale = new Locale( localeStrings[ 0 ] );
      } else if ( localeStrings.length == 2 ) {
        locale = new Locale( localeStrings[ 0 ], localeStrings[ 1 ] );
      } else {
        throw new RuntimeException( "Expected either 1 or 2 locale strings" );
      }
    }
    assertNull( localizationManager.getResourceBundle( key, locale ) );

  }

  private void assertBundleNullCacheNullRegexp( Pattern keyRegex, String... localeStrings ) {
    Locale locale = null;

    if ( localeStrings != null ) {
      if ( localeStrings.length == 1 ) {
        locale = new Locale( localeStrings[ 0 ] );
      } else if ( localeStrings.length == 2 ) {
        locale = new Locale( localeStrings[ 0 ], localeStrings[ 1 ] );
      } else {
        throw new RuntimeException( "Expected either 1 or 2 locale strings" );
      }
    }
    assertNull( localizationManager.getResourceBundles( keyRegex, locale ) );

  }

  private Bundle makeMockBundle( Long bundleId, int bundleStatus, String... propertiesPaths ) {
    Bundle bundle = mock( Bundle.class );
    when( bundle.getState() ).thenReturn( bundleStatus );
    when( bundle.getBundleId() ).thenReturn( bundleId );
    List<URL> propertiesFiles = new ArrayList<URL>();
    for ( String path : propertiesPaths ) {
      propertiesFiles.add( getClass().getClassLoader().getResource( path ) );
    }
    when( bundle.findEntries( "i18n", "*.properties*", true ) )
      .thenReturn( new Vector<URL>( propertiesFiles ).elements() );
    return bundle;
  }

  private Bundle makeMockBundleNull( Long bundleId, int bundleStatus ) {
    Bundle bundle = mock( Bundle.class );
    when( bundle.getState() ).thenReturn( bundleStatus );
    when( bundle.getBundleId() ).thenReturn( bundleId );
    when( bundle.findEntries( "i18n", "*.properties*", true ) ).thenReturn( null );
    return bundle;
  }
}
```


Overlapping Code:
```
erTest {
private Logger log;
private Logger cachedLogger;
private LocalizationManager localizationManager;
private ExecutorService executorService;
@Before
public void setup() {
log = mock( Logger.class );
cachedLogger = LocalizationManager.getLog();
localizationManager = new LocalizationManager();
executorService = mock( ExecutorService.class );
}
@After
public void teardown() {
LocalizationManager.setLog( cachedLogger );
}
@Test
public void testLocalizationManager() throws IOException, ParseException {
localizationManager.setExecutorService( executorService );
assertBundleNullCacheNull( "messages", "de", "DE" );
assertBundleNullCacheNullRegexp( Pattern.compile( "messages" ),
"de", "DE" );
localizationManager.bundleChanged( makeMockBundleNull( 1L, Bundle.ACTIVE ) );
assertBundleNullCacheNull( "messages", "de", "DE" );
assertBundleNullCacheNull( null, "de", "DE" );
assertBundleNullCacheNull( "messages", null );
localizationManager.setExecutorService( null );
assertBundleNullCacheNull( "messages", "de", "DE" );
assertBundleNullCacheNull( null, "de", "DE" );
assertBundleNullCacheNull( "messages", null );
localizationManager.bundleChanged( makeMockBundle( 1L, Bundle.ACTIVE, "i18n/bundle/messages.properties",
"i18n/bundle/messages_fr.properties", "i18n/bundle/messages_de_DE.properties" ) );
assertBundleNullCacheNull( null, "de", "DE" );
assertBundleNullCacheNull( "", "de", "DE" );
assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "fakeLocale" );
assertBundleKeyEquals( "key", "bundle/messages", "key", "fakeLocale" );
assertBundleKeyEquals( "key_fr", "bundle/messages", "key", "fr" );
assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "fr" );
assertBundleKeyEquals( "key_fr", "bundle/messages", "key", "fr", "FR" );
assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "fr", "FR" );
assertBundleKeyEquals( "key", "bundle/messages", "key", "de" );
assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "de" );
assertBundleKeyEquals( "key_de_DE", "bundle/messages", "key", "de", "DE" );
assertBundleKeyEquals( "defaultKey", "bundle/messages", "defaultKey", "de", "DE" );
assertBundlePatternKeyEquals( "defaultKey", Pattern.compile( ".*messages" ), "defaultKey", "fakeLocale" );
assertBundlePatternKeyEquals( "
```
<Overlap Ratio: 0.9862778730703259>

---

--- 238 --
Question ID: 86eaf9118edd27052c3f5011af1e8658db68c3ae
Original Code:
```
public class PcmlStruct {
	
	private PcmlElement[] elements;
	private String[] shortElementNames;
	private String[] longElementNames;
	private String preamble;
 
	public PcmlStruct(String programName, String structName, PcmlElement[] elements) {
		if (structName.equals('[' + programName + ']')) {
			preamble = programName + '.';
		} else if (elements.length==1 || elements[0].getCount() > 1) {
			// this is a repeating structure
			preamble = programName + '.';
		} else {
			preamble = programName + '.' + structName + '.';
		}
		this.elements = elements;
		shortElementNames = new String[elements.length];
		longElementNames = new String[elements.length];
		for (int x=0; x<elements.length; x++) {
			String shortName = elements[x].getName();
			shortElementNames[x] = shortName;
			longElementNames[x] = preamble + shortName;
		}
	}
	
	public String[] getElementNames() {
		return shortElementNames;
	}
	
	public String getPreamble() {
		return preamble;
	}
	
	public PcmlElement getElement(String name) {
		boolean found = false;
		PcmlElement result = null;
		for (int x=0; x<elements.length && !found; x++) {
			if (name.equalsIgnoreCase(elements[x].getName())) {
				result = elements[x];
				found = true;
		 	}
		}
		return result;
	}
	
	private void checkElemValues(Object[] elementValues) throws PcmlCallException {
		if (elementValues.length != elements.length) {
			throw new PcmlCallException(
					"The number of element values do not equal the number of element names; " +
					"Names="  + elements.length + ", Values=" + elementValues.length);
		}
	}
	
	public void setDocValues(ProgramCallDocument pcd, Object[] elementValues) throws PcmlCallException {
		checkElemValues(elementValues);
		String elementName = null;
		Object elementValue = null;
		try {
			for (int x=0; x<elements.length; x++) {
				elementName = longElementNames[x];
				elementValue = elementValues[x];
				pcd.setValue(elementName, elementValue);
			}
		} catch (Exception e) {
			String msg = String.format(
					"Unable to set ProgramCallDocument element:%s, value:%s", 
					elementName, elementValue);
			throw new PcmlCallException(msg, e);
		}
	}
	
	public Map<String, Object> getDocValues(ProgramCallDocument pcd) throws PcmlCallException {
		Map<String, Object> resultMap = new HashMap<String, Object>();
		try {
			for (int x=0; x<elements.length; x++) {
				Object value = pcd.getValue(longElementNames[x]);
				resultMap.put(elements[x].getName(), value);
			}
			return resultMap;
		} catch (PcmlException e) {
			throw new PcmlCallException("Unable to get ProgramCallDocument values", e);
		}
	}
	
	public void setDocValues(ProgramCallDocument pcd, int index, Object[] elementValues) throws PcmlCallException {
		int[] indices = { index };
		setDocValues(pcd, indices, elementValues);
	}
	
	public Map<String, Object> getDocValues(ProgramCallDocument pcd, int index) throws PcmlCallException {
		int[] indices = { index };
		return getDocValues(pcd, indices);
	}
	
	public void setDocValues(ProgramCallDocument pcd, int[] indices, Object[] elementValues) throws PcmlCallException {
		checkElemValues(elementValues);
		try {
			for (int x=0; x<elements.length; x++) {
				pcd.setValue(longElementNames[x], indices, elementValues[x]);
			}
		} catch (PcmlException e) {
			throw new PcmlCallException("Unable to set ProgramCallDocument values", e);
		}
	}
	
	public Map<String, Object> getDocValues(ProgramCallDocument pcd, int[] indices) throws PcmlCallException {
		Map<String, Object> resultMap = new HashMap<String, Object>();
		try {
			for (int x=0; x<elements.length; x++) {
				Object value = pcd.getValue(longElementNames[x], indices);
				resultMap.put(elements[x].getName(), value);
			}
		} catch (PcmlException e) {
			throw new PcmlCallException("Unable to get ProgramCallDocument values", e);
		}
		return resultMap;
	}
	
	public Object getValue(ProgramCallDocument pcd, String element) throws PcmlCallException {
		Object result = null;
		try {
			result = pcd.getValue(preamble + element);
		} catch (PcmlException e) {
			throw new PcmlCallException("Unable to get ProgramCallDocument value", e);
		}
		return result;
	}
	
	public Object getValue(ProgramCallDocument pcd, String element, int index) throws PcmlCallException {
		int[] indices = { index };
		return getValue(pcd, element, indices);
	}

	private Object getValue(ProgramCallDocument pcd, String element, int[] indices) throws PcmlCallException {
		Object result = null;
		try {
			result = pcd.getValue(preamble + element, indices);
		} catch (PcmlException e) {
			throw new PcmlCallException("Unable to get ProgramCallDocument value", e);
		}
		return result;
	}

}
```


Overlapping Code:
```
cmlElement[] elements;
private String[] shortElementNames;
private String[] longElementNames;
private String preamble;

public PcmlStruct(String programName, String structName, PcmlElement[] elements) {
if (structName.equals('[' + programName + ']')) {
preamble = programName + '.';
} else if (elements.length==1 || elements[0].getCount() > 1) {
// this is a repeating structure
preamble = programName + '.';
} else {
preamble = programName + '.' + structName + '.';
}
this.elements = elements;
shortElementNames = new String[elements.length];
longElementNames = new String[elements.length];
for (int x=0; x<elements.length; x++) {
String shortName = elements[x].getName();
shortElementNames[x] = shortName;
longElementNames[x] = preamble + shortName;
}
}

public String[] getElementNames() {
return shortElementNames;
}

public String getPreamble() {
return preamble;
}

public PcmlElement getElement(String name) {
boolean found = false;
PcmlElement result = null;
for (int x=0; x<elements.length && !found; x++) {
if (name.equalsIgnoreCase(elements[x].getName())) {
result = elements[x];
found = true;
}
}
return result;
}

private void checkElemValues(Object[] elementValues) throws PcmlCallException {
if (elementValues.length != elements.length) {
throw new PcmlCallException(
"The number of element values do not equal the number of element names; " +
"Names=" + elements.length + ", Values=" + elementValues.length);
}
}

public void setDocValues(ProgramCallDocument pcd, Object[] elementValues) throws PcmlCallException {
checkElemValues(elementValues);
String elementName = null;
Object elementValue = null;
try {
for (int x=0; x<elements.length; x++) {
elementName = longElementNames[x];
elementValue = elementValues[x];
pcd.setValue(elementName, elementValue);
}
} catch (Exception e) {
String msg = String.format(
"Unable to set ProgramCallDocument element:%s, value:%s", 
elementName, elementValue);
throw new PcmlCallException(msg, e);
}
}

public Map<String, Object> getDocValues(ProgramCallDocument pcd) throws PcmlCallException {
Map<String, Object> resultMap = new HashMap<String, Object>();
try {
for (int x=0; x<elements.length; x++) {
Object value = pcd.getValue(longElementNames[x]);
resultMap.put(elements[x].getName(), value)
```
<Overlap Ratio: 0.9702457956015524>

---

--- 239 --
Question ID: 9174c8af9d3e4ea0796e381c89cbedfd2e523460
Original Code:
```
public class StatusBarController {

    @FXML
    private Label info;
    @FXML
    private Label host;
    @FXML
    private ProgressBar loadDataStatus;
    @FXML
    private Label loadDataLabel;

    public StatusBarController() {

    }

    @FXML
    public void initialize() {
        host.setText("Host: " + Resources.HOST_NAME);
        info.setText("Program version: " + Resources.PROGRAM_VERSION);
        loadDataStatus.visibleProperty().bind(Context.getIsLoadDataProperty());
        loadDataLabel.visibleProperty().bind(Context.getIsLoadDataProperty());
    }

}
```


Overlapping Code:
```
rController {
@FXML
private Label info;
@FXML
private Label host;
@FXML
private ProgressBar loadDataStatus;
@FXML
private Label loadDataLabel;
public StatusBarController() {
}
@FXML
public void initialize() {
host.setText("Host: " + Resources.HOST_NAME);
info.setText("Program version: " + Resources.PROGRAM_VERSION);
loadDataStatus.visibleProperty().bind(Context.getIsLoadDataProperty());
loadDataLabel.visibleProperty().bind(Context.getIsLoadDataPr
```
<Overlap Ratio: 0.9278350515463918>

---

--- 240 --
Question ID: 1e6fd2e693b09f6010a67cc46f0cd05ff756afe4
Original Code:
```
public class TestRange {

    @Test
    public void testBasic() {
        IntegerRange integerRange = new IntegerRange(5, 6);
        Assert.assertEquals(5, integerRange.getMin().intValue());
        Assert.assertEquals(6, integerRange.getMax().intValue());
        Assert.assertFalse(integerRange.isEmpty());
        Assert.assertEquals("[5, 6]", integerRange.toString());
        Assert.assertEquals(2L, integerRange.size().longValue());

        integerRange = new IntegerRange(null, 27);
        Assert.assertEquals(null, integerRange.getMin());
        Assert.assertEquals(27, integerRange.getMax().intValue());
        Assert.assertFalse(integerRange.isEmpty());
        Assert.assertEquals("[-inf, 27]", integerRange.toString());
        Assert.assertEquals(null, integerRange.size());

        integerRange = new IntegerRange(8, null);
        Assert.assertEquals(8, integerRange.getMin().intValue());
        Assert.assertEquals(null, integerRange.getMax());
        Assert.assertFalse(integerRange.isEmpty());
        Assert.assertEquals("[8, +inf]", integerRange.toString());
        Assert.assertEquals(null, integerRange.size());

        integerRange = new IntegerRange(null, null);
        Assert.assertEquals(null, integerRange.getMin());
        Assert.assertEquals(null, integerRange.getMax());
        Assert.assertFalse(integerRange.isEmpty());
        Assert.assertEquals("[-inf, +inf]", integerRange.toString());
        Assert.assertEquals(null, integerRange.size());

        integerRange = new IntegerRange(5, 4);
        Assert.assertEquals(5, integerRange.getMin().intValue());
        Assert.assertEquals(4, integerRange.getMax().intValue());
        Assert.assertTrue(integerRange.isEmpty());
        Assert.assertEquals("[5, 4]", integerRange.toString());
        Assert.assertEquals(0L, integerRange.size().longValue());
    }

    @Test
    public void testContains() {
        IntegerRange integerRange = new IntegerRange(5, 6);
        Assert.assertTrue(integerRange.contains(5));
        Assert.assertFalse(integerRange.contains(0));
        Assert.assertFalse(integerRange.contains(100));

        integerRange = new IntegerRange(null, 27);
        Assert.assertTrue(integerRange.contains(5));
        Assert.assertTrue(integerRange.contains(0));
        Assert.assertFalse(integerRange.contains(100));

        integerRange = new IntegerRange(8, null);
        Assert.assertTrue(integerRange.contains(15));
        Assert.assertFalse(integerRange.contains(0));
        Assert.assertTrue(integerRange.contains(100));

        integerRange = new IntegerRange(null, null);
        Assert.assertTrue(integerRange.contains(5));
        Assert.assertTrue(integerRange.contains(0));
        Assert.assertTrue(integerRange.contains(100));

        integerRange = new IntegerRange(5, 4);
        Assert.assertFalse(integerRange.contains(5));
        Assert.assertFalse(integerRange.contains(0));
        Assert.assertFalse(integerRange.contains(100));
    }

    @Test
    public void testCompareToValues() {
        IntegerRange integerRange = new IntegerRange(5, 6);
        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.RIGHT);
        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.LEFT);
        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);

        integerRange = new IntegerRange(null, 27);
        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.LEFT);
        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);

        integerRange = new IntegerRange(8, null);
        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.RIGHT);
        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.RIGHT);
        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);

        integerRange = new IntegerRange(null, null);
        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);

        integerRange = new IntegerRange(5, 4);
        Assert.assertEquals(integerRange.compareTo(5), Range.ValueComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(0), Range.ValueComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(100), Range.ValueComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo((Integer) null), Range.ValueComparison.ANY_EMPTY);
    }

    @Test
    public void testCompareRanges() {
        IntegerRange integerRange = new IntegerRange(0, 10);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.LEFT_NO_CONTACT);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.LEFT_CONTACT);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.LEFT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.EQUALS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.INSIDE);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.INSIDE);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.INSIDE);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.RIGHT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.RIGHT_CONTACT);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.RIGHT_NO_CONTACT);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.RIGHT_NO_CONTACT);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.RIGHT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.INSIDE);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.LEFT_NO_CONTACT);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, null)), Range.RangeComparison.LEFT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.INSIDE);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.INSIDE);

        integerRange = new IntegerRange(null, 10);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.LEFT_NO_CONTACT);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.LEFT_CONTACT);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.LEFT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.LEFT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.LEFT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.INSIDE);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.LEFT_NO_CONTACT);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, null)), Range.RangeComparison.LEFT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.LEFT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.INSIDE);

        integerRange = new IntegerRange(0, null);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.RIGHT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.RIGHT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.RIGHT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.RIGHT_CONTACT);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.RIGHT_NO_CONTACT);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.RIGHT_NO_CONTACT);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.RIGHT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.RIGHT_OVERLAP);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, null)), Range.RangeComparison.EQUALS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.INSIDE);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.INSIDE);

        integerRange = new IntegerRange(null, null);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, null)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.CONTAINS);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.EQUALS);

        integerRange = new IntegerRange(1, 0);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, -1)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, 20)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(11, 20)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 20)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 10)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 10)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 15)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 15)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, 5)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 10)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(5, 6)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, 5)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -1)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, -5)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, -5)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 5)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, 15)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(15, null)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(0, null)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(-5, null)), Range.RangeComparison.ANY_EMPTY);
        Assert.assertEquals(integerRange.compareTo(new IntegerRange(null, null)), Range.RangeComparison.ANY_EMPTY);
    }


    @Test
    public void testIntersection() {
        IntegerRange emptyRange = new IntegerRange(0, -1);
        IntegerRange integerRange = new IntegerRange(0, 10);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -1)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), new IntegerRange(0, 5));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), new IntegerRange(0, 10));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), new IntegerRange(0, 10));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), new IntegerRange(3, 5));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), new IntegerRange(5, 10));

        integerRange = new IntegerRange(null, 10);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), new IntegerRange(-10, -15));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), new IntegerRange(-10, -5));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 15)), new IntegerRange(-10, 10));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), new IntegerRange(-10, 5));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), new IntegerRange(0, 10));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), new IntegerRange(-10, 10));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), new IntegerRange(3, 5));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), new IntegerRange(5, 10));

        integerRange = new IntegerRange(0, null);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 15)), new IntegerRange(0, 15));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), new IntegerRange(11, 15));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), new IntegerRange(15, 15));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), new IntegerRange(0, 5));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), new IntegerRange(0, 10));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), new IntegerRange(0, 20));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), new IntegerRange(3, 5));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), new IntegerRange(5, 15));

        integerRange = new IntegerRange(null, null);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), new IntegerRange(-10, -15));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), new IntegerRange(-10, -5));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 15)), new IntegerRange(-10, 15));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), new IntegerRange(11, 15));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), new IntegerRange(15, 15));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), new IntegerRange(-10, 5));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), new IntegerRange(0, 10));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), new IntegerRange(-10, 20));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), new IntegerRange(3, 5));
        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), new IntegerRange(5, 15));

        integerRange = new IntegerRange(1, 0);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -15)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, -5)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 15)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(11, 15)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(15, 15)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 5)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(0, 10)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(-10, 20)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(3, 5)), emptyRange);
        Assert.assertEquals(integerRange.intersection(new IntegerRange(5, 15)), emptyRange);
    }

    @Test
    public void testGetPosition() {
        IntegerRange integerRange = new IntegerRange(0, 10);
        Assert.assertEquals((Integer) 5, integerRange.getPosition(5L));
        try {
            integerRange.getPosition(15L);
        } catch (IndexOutOfBoundsException e) {
            Assert.assertEquals(IndexOutOfBoundsException.class, e.getClass());
        }
        try {
            integerRange.getPosition(-5L);
        } catch (IllegalArgumentException e) {
            Assert.assertEquals(IllegalArgumentException.class, e.getClass());
        }

        integerRange = new IntegerRange(0, -1);
        try {
            integerRange.getPosition(5L);
        } catch (IndexOutOfBoundsException e) {
            Assert.assertEquals(IndexOutOfBoundsException.class, e.getClass());
        }
        try {
            integerRange.getPosition(15L);
        } catch (IndexOutOfBoundsException e) {
            Assert.assertEquals(IndexOutOfBoundsException.class, e.getClass());
        }
        try {
            integerRange.getPosition(-5L);
        } catch (IllegalArgumentException e) {
            Assert.assertEquals(IllegalArgumentException.class, e.getClass());
        }

        integerRange = new IntegerRange(null, 10);
        Assert.assertEquals(null, integerRange.getPosition(5L));
        Assert.assertEquals(null, integerRange.getPosition(15L));
        try {
            integerRange.getPosition(-5L);
        } catch (IllegalArgumentException e) {
            Assert.assertEquals(IllegalArgumentException.class, e.getClass());
        }

        integerRange = new IntegerRange(0, null);
        Assert.assertEquals((Integer) 5, integerRange.getPosition(5L));
        Assert.assertEquals((Integer) 15, integerRange.getPosition(15L));
        try {
            integerRange.getPosition(-5L);
        } catch (IllegalArgumentException e) {
            Assert.assertEquals(IllegalArgumentException.class, e.getClass());
        }

        integerRange = new IntegerRange(null, null);
        Assert.assertEquals(null, integerRange.getPosition(5L));
        Assert.assertEquals(null, integerRange.getPosition(15L));
        try {
            integerRange.getPosition(-5L);
        } catch (IllegalArgumentException e) {
            Assert.assertEquals(IllegalArgumentException.class, e.getClass());
        }
    }
}
```


Overlapping Code:
```
 class TestRange {
@Test
public void testBasic() {
IntegerRange integerRange = new IntegerRange(5, 6);
Assert.assertEquals(5, integerRange.getMin().intValue());
Assert.assertEquals(6, integerRange.getMax().intValue());
Assert.assertFalse(integerRange.isEmpty());
Assert.assertEquals("[5, 6]", integerRange.toString());
Assert.assertEquals(2L, integerRange.size().longValue());
integerRange = new IntegerRange(null, 27);
Assert.assertEquals(null, integerRange.getMin());
Assert.assertEquals(27, integerRange.getMax().intValue());
Assert.assertFalse(integerRange.isEmpty());
Assert.assertEquals("[-inf, 27]", integerRange.toString());
Assert.assertEquals(null, integerRange.size());
integerRange = new IntegerRange(8, null);
Assert.assertEquals(8, integerRange.getMin().intValue());
Assert.assertEquals(null, integerRange.getMax());
Assert.assertFalse(integerRange.isEmpty());
Assert.assertEquals("[8, +inf]", integerRange.toString());
Assert.assertEquals(null, integerRange.size());
integerRange = new IntegerRange(null, null);
Assert.assertEquals(null, integerRange.getMin());
Assert.assertEquals(null, integerRange.getMax());
Assert.assertFalse(integerRange.isEmpty());
Assert.assertEquals("[-inf, +inf]", integerRange.toString());
Assert.assertEquals(null, integerRange.size());
integerRange = new IntegerRange(5, 4);
Assert.assertEquals(5, integerRange.getMin().intValue());
Assert.assertEquals(4, integerRange.getMax().intValue());
Assert.assertTrue(integerRange.isEmpty());
Assert.assertEquals("[5, 4]", integerRange.toString());
Assert.assertEquals(0L, integerRange.size().longValue());
}
@Test
public void testContains() {
IntegerRange integerRange = new IntegerRange(5, 6);
Assert.assertTrue(integerRange.contains(5));
Assert.assertFalse(integerRange.contains(0));
Assert.assertFalse(integerRange.contains(100));
integerRange = new IntegerRange(null, 27);
Assert.assertTrue(integerRange.contains(5));
Assert.assertTrue(integerRange.contains(0));
Assert.assertFalse(integerRange.contains(100));
integerRange = new IntegerRange(8, null);
Assert.assertTrue(integerRange.contains(15));
Assert.ass
```
<Overlap Ratio: 0.9808500700607193>

---

--- 241 --
Question ID: a7fe7cd880b3d3c55ed05396633860597a9a3b2c
Original Code:
```
@SuppressWarnings("deprecation")
public class JSONWriterTestCase {

    @Test
    public void testJSONWriter() throws IOException {
        OutputStream out = new ByteArrayOutputStream();
        JSONWriter w = new JSONWriter(out);

        w.beginObject();

        w.beginField("string").value("a string").endField();
        w.beginField("number").value(37).endField();
        w.beginField("true").value(true).endField();
        w.beginField("false").value(false).endField();
        w.beginField("null").value().endField();

        w.beginField("object").beginObject();
        w.beginField("nested-array").beginArray().beginArrayValue().value(1).endArrayValue().endArray().endField();
        w.endObject().endField();

        w.beginField("array").beginArray();
        w.beginArrayValue().value("item1").endArrayValue();
        w.beginArrayValue().value("item2").endArrayValue();
        w.beginArrayValue().beginObject().beginField("nested").value("item3").endField().endObject().endArrayValue();
        w.endArray().endField();

        w.endObject();

        assertEquals("{\"string\":\"a string\"," +
                      "\"number\":37," +
                      "\"true\":true," +
                      "\"false\":false," +
                      "\"null\":null," +
                      "\"object\":{\"nested-array\":[1]}," +
                      "\"array\":[\"item1\",\"item2\",{\"nested\":\"item3\"}]}",
                     out.toString());
    }

    @Test
    public void testJSONWriterEmptyObject() throws IOException {
        OutputStream out = new ByteArrayOutputStream();
        JSONWriter w = new JSONWriter(out);
        w.beginObject();
        w.endObject();

        assertEquals("{}",out.toString());
    }

    @Test
    public void testJSONWriterEmptyArray() throws IOException {
        OutputStream out = new ByteArrayOutputStream();
        JSONWriter w = new JSONWriter(out);
        w.beginArray();
        w.endArray();

        assertEquals("[]",out.toString());
    }

    @Test
    public void testJSONWriterStringOnly() throws IOException {
        OutputStream out = new ByteArrayOutputStream();
        JSONWriter w = new JSONWriter(out);
        w.value("Hello, world!");

        assertEquals("\"Hello, world!\"",out.toString());
    }

    @Test
    public void testJSONWriterNestedArrays() throws IOException {
        OutputStream out = new ByteArrayOutputStream();
        JSONWriter w = new JSONWriter(out);
        w.beginArray();

        w.beginArrayValue().beginArray();
        w.endArray().endArrayValue();

        w.beginArrayValue().beginArray();
        w.beginArrayValue().value("hello").endArrayValue();
        w.beginArrayValue().value("world").endArrayValue();
        w.endArray().endArrayValue();

        w.beginArrayValue().beginArray();
        w.endArray().endArrayValue();

        w.beginArrayValue().beginArray();
        w.beginArrayValue().beginArray();
        w.endArray().endArrayValue();
        w.endArray().endArrayValue();

        w.beginArrayValue().beginArray();
        w.endArray().endArrayValue();

        w.endArray();

        assertEquals("[[],[\"hello\",\"world\"],[],[[]],[]]",out.toString());
    }

}
```


Overlapping Code:
```
ppressWarnings("deprecation")
public class JSONWriterTestCase {
@Test
public void testJSONWriter() throws IOException {
OutputStream out = new ByteArrayOutputStream();
JSONWriter w = new JSONWriter(out);
w.beginObject();
w.beginField("string").value("a string").endField();
w.beginField("number").value(37).endField();
w.beginField("true").value(true).endField();
w.beginField("false").value(false).endField();
w.beginField("null").value().endField();
w.beginField("object").beginObject();
w.beginField("nested-array").beginArray().beginArrayValue().value(1).endArrayValue().endArray().endField();
w.endObject().endField();
w.beginField("array").beginArray();
w.beginArrayValue().value("item1").endArrayValue();
w.beginArrayValue().value("item2").endArrayValue();
w.beginArrayValue().beginObject().beginField("nested").value("item3").endField().endObject().endArrayValue();
w.endArray().endField();
w.endObject();
assertEquals("{\"string\":\"a string\"," +
"\"number\":37," +
"\"true\":true," +
"\"false\":false," +
"\"null\":null," +
"\"object\":{\"nested-array\":[1]}," +
"\"array\":[\"item1\",\"item2\",{\"nested\":\"item3\"}]}",
out.toString());
}
@Test
public void testJSONWriterEmptyObject() throws IOException {
OutputStream out = new ByteArrayOutputStream();
JSONWriter w = new JSONWriter(out);
w.beginObject();
w.endObject();
assertEquals("{}",out.toString());
}
@Test
public void testJSONWriterEmptyArray() throws IOException {
OutputStream out = new ByteArrayOutputStream();
JSONWriter w = new JSONWriter(out);
w.beginArray();
w.endArray();
assertEquals("[]",out.toString());
}
@Test
public void testJSONWriterStringOnly() throws IOException {
OutputStream out = new ByteArrayOutputStream();
JSONWriter w = new JSONWriter(out);
w.value("Hello, world!");
assertEquals("\"Hello, world!\"",out.toString());
}
@Test
public void testJSONWriterNestedArrays() throws IOException {
OutputStream out = new ByteArrayOutputStream();
JSONWriter w = new JSONWriter(out
```
<Overlap Ratio: 0.9894313034725717>

---

--- 242 --
Question ID: 3abe7b52c94ec035e1029d23e697ea01235ace05
Original Code:
```
@Data
@JsonDeserialize(builder = Document.Builder.class)
public class Document implements Serializable {

    private static final long serialVersionUID = 7352690975010398089L;

    /**
     * @return The reference of the document
     * @serial The reference of the document
     */
    private final String reference;

    /**
     * @return The weight (relevance) of the document
     * @serial The weight (relevance) of the document
     */
    private final double weight;

    /**
     * @return The stemmed terms from the query which matched the document
     * @serial The stemmed terms from the query which matched the document
     */
    private final Set<String> links;

    /**
     * @return The index in which the document resides
     * @serial The index in which the document resides
     */
    private final String index;

    /**
     * @return The title of the document
     * @serial The title of the document
     */
    private final String title;

    /**
     * @return A summary of the document. If summaries were not requested, this will be the empty string
     * @serial A summary of the document. If summaries were not requested, this will be the empty string
     */
    private final String summary;

    /**
     * @return The content of the document. If content were not requested, this will be the empty string
     * @serial The content of the document. If content were not requested, this will be the empty string
     */
    private final String content;

    /**
     * @return A map containing any fields on the document which are not known ahead of time
     */
    @Setter(AccessLevel.NONE)
    private transient Map<String, Serializable> fields;

    /**
     * @return The section number of the result document
     * @serial The section number of the result document
     */
    private final Integer section;

    /**
     * @return The type of promotion which triggered this result
     * @serial The type of promotion which triggered this result
     */
    @Setter(AccessLevel.NONE)
    private PromotionType promotionType;

    private Document(final Builder builder) {
        reference = builder.reference;
        weight = builder.weight;
        links = builder.links;
        index = builder.index;
        title = builder.title;
        summary = builder.summary;
        fields = builder.fields;
        content = builder.content;
        section = builder.section;

        promotionType = builder.promotionType == null ? PromotionType.NONE : builder.promotionType;
    }

    /**
     * @param objectOutputStream The output stream
     * @serialData Writes out the standard fields, then the number of non-standard fields {@code int}, followed by
     * the non-standard field names alternated with their values
     */
    private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException {
        objectOutputStream.defaultWriteObject();

        objectOutputStream.writeInt(fields.size());

        for (final Map.Entry<String, Serializable> entry : fields.entrySet()) {
            objectOutputStream.writeObject(entry.getKey());
            objectOutputStream.writeObject(entry.getValue());
        }
    }

    private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
        objectInputStream.defaultReadObject();
        fields = new HashMap<>();

        final int fieldCount = objectInputStream.readInt();

        for (int i = 0; i < fieldCount; i++) {
            final String fieldName = (String) objectInputStream.readObject();
            final Serializable value = (Serializable) objectInputStream.readObject();
            fields.put(fieldName, value);
        }

        // For backwards compatibility of serialized form
        if (promotionType == null) {
            promotionType = PromotionType.NONE;
        }
    }

    @Setter
    @Accessors(chain = true)
    @JsonPOJOBuilder(withPrefix = "set")
    public static class Builder {

        private String reference;
        private double weight;
        private Set<String> links;
        private String index;
        private String title;
        private Integer section;

        @JsonProperty("promotion")
        private PromotionType promotionType;

        @SuppressWarnings("FieldMayBeFinal")
        private String content = "";

        private final Map<String, Serializable> fields = new HashMap<>();

        @SuppressWarnings("FieldMayBeFinal")
        private String summary = "";

        public Builder setLinks(final Set<String> links) {
            if (links != null) {
                this.links = new HashSet<>(links);
            }

            return this;
        }

        public Builder addField(final String key, final Serializable value) {
            fields.put(key, value);
            return this;
        }

        // Jackson can't convert to interfaces, so we need this helper method
        @JsonAnySetter
        Builder _addField(final String key, final Object value) {
            // Assume Jackson will give us a Serializable type
            this.addField(key, (Serializable) value);
            return this;
        }

        public Document build() {
            return new Document(this);
        }

    }

}
```


Overlapping Code:
```
onDeserialize(builder = Document.Builder.class)
public class Document implements Serializable {
private static final long serialVersionUID = 7352690975010398089L;
/**
* @return The reference of the document
* @serial The reference of the document
*/
private final String reference;
/**
* @return The weight (relevance) of the document
* @serial The weight (relevance) of the document
*/
private final double weight;
/**
* @return The stemmed terms from the query which matched the document
* @serial The stemmed terms from the query which matched the document
*/
private final Set<String> links;
/**
* @return The index in which the document resides
* @serial The index in which the document resides
*/
private final String index;
/**
* @return The title of the document
* @serial The title of the document
*/
private final String title;
/**
* @return A summary of the document. If summaries were not requested, this will be the empty string
* @serial A summary of the document. If summaries were not requested, this will be the empty string
*/
private final String summary;
/**
* @return The content of the document. If content were not requested, this will be the empty string
* @serial The content of the document. If content were not requested, this will be the empty string
*/
private final String content;
/**
* @return A map containing any fields on the document which are not known ahead of time
*/
@Setter(AccessLevel.NONE)
private transient Map<String, Serializable> fields;
/**
* @return The section number of the result document
* @serial The section number of the result document
*/
private final Integer section;
/**
* @return The type of promotion which triggered this result
* @serial The type of promotion which triggered this result
*/
@Setter(AccessLevel.NONE)
private PromotionType promotionType;
private Document(final Builder builder) {
reference = builder.reference;
weight = builder.weight;
links = builder.links;
index = builder.index;
title = builder.title;
summary = builder.summary;
fields = builder.fields;
content = builder.content;
section = builder.section;
promotionType = builder.promotionType == null ? PromotionType.NONE
```
<Overlap Ratio: 0.9958429561200923>

---

--- 243 --
Question ID: baabda339e69ba70e847b4d0fc5cb182a1f1d0cd
Original Code:
```
@Autonomous(name = "Crater - competition")
@Disabled

public class Crater extends LinearOpMode  {

MecanumDrive myMechDrive;

GyroCompetition myGyro;
MecanumMineralMiner myMineralMiner;
RevColorDistance myRevColorDistance;

Webcam myWebcam;
LiftMotor myLiftMotor;
TeamMarker myTeamMarker;

@Override
public void runOpMode() throws InterruptedException {



    final long sleepTime = 100;
    final double SPD_DRIVE_MED = .5;


    myMechDrive = new MecanumDrive(hardwareMap.dcMotor.get("front_left_motor"), hardwareMap.dcMotor.get("front_right_motor"), hardwareMap.dcMotor.get("rear_left_motor"), hardwareMap.dcMotor.get("rear_right_motor"));
    myMechDrive.setLinearOp(this);

    myGyro = new GyroCompetition(hardwareMap.get(BNO055IMU.class, "imu"));
    myGyro.setLinearOp(this);

    myMineralMiner = new MecanumMineralMiner();
    myMineralMiner.setLinearOp(this);

    myLiftMotor = new LiftMotor(hardwareMap.dcMotor.get("lift_motor"));
    myLiftMotor.setLinearOp(this);

    myTeamMarker = new TeamMarker(hardwareMap.servo.get("team_marker_arm"));
    myTeamMarker.setLinearOp(this);

    myRevColorDistance = new RevColorDistance(hardwareMap.get(ColorSensor.class, "rev_sensor_color_distance"), hardwareMap.get(DistanceSensor.class, "rev_sensor_color_distance"));
    myWebcam = new Webcam();


    waitForStart();

    boolean active = true;
    while (opModeIsActive() && !isStopRequested()) {
        while (active && !isStopRequested()) {
            idle();
            /*
            Find the correct gold mineral
             */
            myMineralMiner.findingMineral();
            sleep(sleepTime);
            idle();
            /*
            1) drives forward from lander a short distance so doesn't interfere with gyro turn
            2) angles self with gold mineral based on myMineralMiner.findingMineral
            3) Drives forward to knock of gold mineral.
             */
            myMineralMiner.driveMineral(myGyro, myMechDrive, myLiftMotor);
            sleep(sleepTime);
            idle();
            /*
            1) BACKS UP TO TAPE
            2) TURNS TO A) MISS LANDER AND AND B) MISS MINERALS WHEN GOING STRAIGHT
            3) GOES STRAIGHT TOWARDS WALL
             */
            myMineralMiner.craterMineralToWall (myGyro, myMechDrive, myRevColorDistance);
            sleep(sleepTime);

            idle();
            /*
            Will angle robot to be parallel with robot, score in depot, and then go to crater.
             */
           myMineralMiner.wallToDepot(myGyro, myMechDrive, myRevColorDistance, myTeamMarker);

            active = false;
        }
        idle();
        requestOpModeStop();
    }
}
}
```


Overlapping Code:
```
mpetition")
@Disabled
public class Crater extends LinearOpMode {
MecanumDrive myMechDrive;
GyroCompetition myGyro;
MecanumMineralMiner myMineralMiner;
RevColorDistance myRevColorDistance;
Webcam myWebcam;
LiftMotor myLiftMotor;
TeamMarker myTeamMarker;
@Override
public void runOpMode() throws InterruptedException {
final long sleepTime = 100;
final double SPD_DRIVE_MED = .5;
myMechDrive = new MecanumDrive(hardwareMap.dcMotor.get("front_left_motor"), hardwareMap.dcMotor.get("front_right_motor"), hardwareMap.dcMotor.get("rear_left_motor"), hardwareMap.dcMotor.get("rear_right_motor"));
myMechDrive.setLinearOp(this);
myGyro = new GyroCompetition(hardwareMap.get(BNO055IMU.class, "imu"));
myGyro.setLinearOp(this);
myMineralMiner = new MecanumMineralMiner();
myMineralMiner.setLinearOp(this);
myLiftMotor = new LiftMotor(hardwareMap.dcMotor.get("lift_motor"));
myLiftMotor.setLinearOp(this);
myTeamMarker = new TeamMarker(hardwareMap.servo.get("team_marker_arm"));
myTeamMarker.setLinearOp(this);
myRevColorDistance = new RevColorDistance(hardwareMap.get(ColorSensor.class, "rev_sensor_color_distance"), hardwareMap.get(DistanceSensor.class, "rev_sensor_color_distance"));
myWebcam = new Webcam();
waitForStart();
boolean active = true;
while (opModeIsActive() && !isStopRequested()) {
while (active && !isStopRequested()) {
idle();
/*
Find the correct gold mineral
*/
myMineralMiner.findingMineral();
sleep(sleepTime);
idle();
/*
1) drives forward from lander a short distance so doesn't interfere with gyro turn
2) angles self with gold mineral based on myMineralMiner.findingMineral
3) Drives forward to knock of gold mineral.
*/
myMineralMiner.driveMineral(myGyro, myMechDrive, myLiftMotor);
sleep(sleepTime);
idle();
/*
1) BACKS UP TO TAPE
2) TURNS TO A) MISS LANDER AND AND B) MISS MINERALS WHEN GOING STRAIGHT
3) GOES STRAIGHT TOWARDS WALL
*/
myMineralMiner.craterMineralToWall (myGyro, myMechDrive, myRevColorDistance);
sleep(sleepTime);
idle();
/*
Will angle robot to be parallel with rob
```
<Overlap Ratio: 0.9633911368015414>

---

--- 244 --
Question ID: 9670c6463531fbc79af00027460e80f1335f9bd1
Original Code:
```
public class TinyLog
{
    private BundleContext context;
    private LogService log_service;

    public TinyLog ()
    {
        context = FrameworkUtil.getBundle (this.getClass ()).getBundleContext ();
    }

    private String conv_str (Object obj)
    {
        if (obj == null)
        {
            return ("null");
        }
        else if (obj instanceof Object[])
        {
            Object[] obj_list = (Object[])obj;
            String result = "";

            for (int i = 0; i < obj_list.length; i++)
            {
                if (!result.isEmpty ())
                {
                    result += ",";
                }
                result += conv_str (obj_list [i]);
            }

            return ("[" + result + "]");
        }

        return (obj.toString ());
    }

    @SuppressWarnings ("unchecked")
    private LogService get_log_service ()
    {
        if (log_service != null)
        {
            try
            {
                // LogService still valid?
                FrameworkUtil.getBundle (log_service.getClass ());
            }
            catch (IllegalStateException oops)
            {
                log_service = null;
            }
        }

        if (log_service == null)
        {
            ServiceReference ref = context.getServiceReference (LogService.class.getName());

            if (ref != null)
            {
                log_service = (LogService) context.getService(ref);
            }
        }

        return (log_service);
    }

    private void write_log (int level, String msg, Object... args)
    {
        int i = 0;

        while (msg.contains ("{}"))
        {
            if (i == args.length)
            {
                break;
            }

            msg = msg.replaceFirst ("\\{\\}", (args [i] == null)? "null": conv_str (args [i]));
            i++;
        }

        Throwable t = null;

        for (i = 0; i < args.length; i++)
        {
            if (args [i] instanceof Throwable)
            {
                // Our beloved ugly stack trace
                t = (Throwable)args [i];
                break;
            }
        }

        if (t == null)
        {
            get_log_service ().log (level, msg);
        }
        else
        {
            get_log_service ().log (level, msg, t);
        }
    }

    public void debug (String msg, Object... args)
    {
        write_log (LogService.LOG_DEBUG, msg, args);
    }

    public void info (String msg, Object... args)
    {
        write_log (LogService.LOG_INFO, msg, args);
    }

    public void warn (String msg, Object... args)
    {
        write_log (LogService.LOG_WARNING, msg, args);
    }

    public void error (String msg, Object... args)
    {
        write_log (LogService.LOG_ERROR, msg, args);
    }
}
```


Overlapping Code:
```
lic class TinyLog
{
private BundleContext context;
private LogService log_service;
public TinyLog ()
{
context = FrameworkUtil.getBundle (this.getClass ()).getBundleContext ();
}
private String conv_str (Object obj)
{
if (obj == null)
{
return ("null");
}
else if (obj instanceof Object[])
{
Object[] obj_list = (Object[])obj;
String result = "";
for (int i = 0; i < obj_list.length; i++)
{
if (!result.isEmpty ())
{
result += ",";
}
result += conv_str (obj_list [i]);
}
return ("[" + result + "]");
}
return (obj.toString ());
}
@SuppressWarnings ("unchecked")
private LogService get_log_service ()
{
if (log_service != null)
{
try
{
// LogService still valid?
FrameworkUtil.getBundle (log_service.getClass ());
}
catch (IllegalStateException oops)
{
log_service = null;
}
}
if (log_service == null)
{
ServiceReference ref = context.getServiceReference (LogService.class.getName());
if (ref != null)
{
log_service = (LogService) context.getService(ref);
}
}
return (log_service);
}
private void write_log (int level, String msg, Object... args)
{
int i = 0;
while (msg.contains ("{}"))
{
if (i == args.length)
{
break;
}
msg = msg.replaceFirst ("\\{\\}", (args [i] == null)? "null": conv_str (args [i]));
i++;
}
Throwable t = null;
for (i = 0; i < args.length; i++)
{
if (args [i] instanceof Throwable)
{
// Our beloved ugly stack trace
t = (Throwable)args [i];
break;
}
}
if (t == null)
{
get_log_service ().log (level, msg);
}
else
{
get_log_service ().log (level, msg, t);
}
}
public void debug (String msg, Object... args)
{
write_log (LogService.LOG_DEBUG, msg, args);
}
public void info (Strin
```
<Overlap Ratio: 0.9846153846153847>

---

--- 245 --
Question ID: 32576c889ad08eef6d94070d0d89d01d7568b99f
Original Code:
```
public class SettingUp {

    private static final AnimeObject[] animeArray = new AnimeObject[]{new AnimeObject("eureka", 50)};
    private static final Logger logger = LoggerFactory.getLogger(SettingUp.class);

    @Deprecated
    public static void insertPartitionDumpToDatabase() {
        String insertScript = "";
        int[][][] tripleArray;

        logger.info("beginning to insert " + animeArray.length + " anime into the database");

        for (int animeNumber = 0; animeNumber < animeArray.length; animeNumber++) {
            logger.info("animeNumber:" + animeNumber);
            try {
                final int[] tmpPanels = new int[animeArray[animeNumber].getNumberOfEpisodes()];
                for (int a = 1; a <= animeArray[animeNumber].getNumberOfEpisodes(); a++) {
                    tmpPanels[a - 1] = Integer.valueOf(AkarinLogging.readFile(
                            "dev_output/description/" + animeArray[animeNumber].getName() + "_" + a + ".txt"));
                }
                animeArray[animeNumber].setPanels(tmpPanels);
            } catch (final IOException e) {
                logger.info("FAIL READING DESCRIPTION TEXT");
                logger.info(e.getMessage());
            }
            for (int episodeNumber = 1; episodeNumber <= animeArray[animeNumber]
                    .getNumberOfEpisodes(); episodeNumber++) {
                for (int panelNumber = 0; panelNumber < animeArray[animeNumber].getPanels()[episodeNumber
                        - 1]; panelNumber++) {
                    try (Connection connection = DatabaseManager.getConnection()) {

                        final Statement stmt = connection.createStatement();

                        tripleArray = AkarinLogging.parseIntegerPartitionTextOutput("dev_output/text/"
                                + animeArray[animeNumber].getName() + "/" + animeArray[animeNumber].getName() + "_"
                                + episodeNumber + "_" + panelNumber + ".txt");

                        insertScript = ScriptCreator.insertIntoImagedbAnimeRgbInteger(animeArray[animeNumber].getName(),
                                episodeNumber, panelNumber, tripleArray);

                        logger.info("Executing script:" + insertScript);
                        stmt.executeUpdate(insertScript);

                    } catch (final IOException | URISyntaxException e) {
                        logger.info("id:" + panelNumber);
                        logger.info(e.getMessage());
                    } catch (final SQLException e) {
                        logger.info("id:" + panelNumber);
                        logger.info("query:" + insertScript);
                        logger.info(e.getMessage());
                    }
                }
            }
        }
    }

    @Deprecated
    public static void createImageInfo() {
        try {
            final File DEV_OUTPUT_IMAGES_OUTPUT_PARTITION = new File("dev_output/images/output/partition");
            boolean isDirectoryExists = DEV_OUTPUT_IMAGES_OUTPUT_PARTITION.exists();
            if (!isDirectoryExists) {
                isDirectoryExists = DEV_OUTPUT_IMAGES_OUTPUT_PARTITION.mkdirs();
            }
            if (isDirectoryExists) {
                logger.info("the directory " + DEV_OUTPUT_IMAGES_OUTPUT_PARTITION.getPath() + " was created");
            }

            String animeName;
            for (AnimeObject anAnimeArray : animeArray) {
                animeName = anAnimeArray.getName();
                for (int episode = 1; episode <= anAnimeArray.getNumberOfEpisodes(); episode++) {
                    final Java2DFrameConverter frameConverter = new Java2DFrameConverter();

                    int frameIterator = 0; // the frame iterator
                    int panelIterator = 0; // the panel iterator
                    BufferedImage image; // the image
                    Frame frame;

                    FFmpegFrameGrabber g = new FFmpegFrameGrabber("videos/" + animeName + "/" + animeName + "_" + episode + ".mkv");
                    g.start();

                    while ((frame = g.grabImage()) != null) {
                        image = frameConverter.getBufferedImage(frame);
                        image = ImageProcessingTools.resizeImage(image);

                        if (Partition.activeBool) {
                            Partition.tripleArray = ImagePartition.getPartitionArray(image);

                            if (Partition.writeToDatabase) {
                                logger.info(animeName + " " + episode + " " + frameIterator);
                                ImageProcessingDb.insertPartitionHash(animeName, episode, frameIterator,
                                        ImageHashing.partitionHash(Partition.tripleArray));
                            }

                            if (Partition.writeLogBool) {
                                Partition.imageDir = "dev_output/images/output/partition/" + animeName + "/"
                                        + animeName + "_" + episode + "_" + panelIterator + ".png";
                                Partition.textDir = "dev_output/text/partition/" + animeName + "/" + animeName + "_"
                                        + episode + "_" + panelIterator + ".txt";
                            }
                        }

                        if (GlobalDifference.activeBool) {
                            GlobalDifference.tripleArray = ImageGlobalDifference.getGlobalDifference(image);

                            if (GlobalDifference.writeLogBool) {
                                GlobalDifference.imageDir = "dev_output/images/output/globaldifference/" + animeName
                                        + "/" + animeName + "_" + episode + "_" + panelIterator + ".png";
                                GlobalDifference.textDir = "dev_output/text/globaldifference/" + animeName + "/"
                                        + animeName + "_" + episode + "_" + panelIterator + ".txt";
                            }
                        }

                        if (BasicHistogramHash.activeBool) {
                            try (Connection connection = DatabaseManager.getConnection()) {
                                Statement statement = connection.createStatement();
                                statement.executeUpdate("INSERT INTO imagedb_test (hash) VALUES ('"
                                        + ImageHashing.basicHistogramHash(ImageHashing.getRGBHistogram(image))
                                        + "');");
                            } catch (final SQLException | URISyntaxException e) {
                                logger.warn(e.getMessage());
                            }
                        }

                        if (CheckPanelDifference.activeBool) {

                            if (panelIterator == 0) {
                                CheckPanelDifference.oldArray = ImageProcessingTools
                                        .getArrayFromBufferedImage(image);
                                CheckPanelDifference.panelDifferenceCountArray = new int[CheckPanelDifference.oldArray.length][CheckPanelDifference.oldArray[0].length][3];
                            } else {
                                CheckPanelDifference.newArray = ImageProcessingTools
                                        .getArrayFromBufferedImage(image);
                                CheckPanelDifference.panelDifferenceArray = ImageProcessingTools
                                        .checkArrayDifference(CheckPanelDifference.oldArray,
                                                CheckPanelDifference.newArray);
                                for (int y = 0; y < CheckPanelDifference.oldArray.length; y++) {
                                    for (int x = 0; x < CheckPanelDifference.oldArray[y].length; x++) {
                                        for (int z = 0; z < CheckPanelDifference.oldArray[y][x].length; z++) {
                                            if (CheckPanelDifference.panelDifferenceArray[y][x][z]) {
                                                CheckPanelDifference.panelDifferenceCountArray[y][x][z]++;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        panelIterator++;
                        frameIterator++;
                    }
                    AkarinLogging.log("" + panelIterator, "dev_output/description/" + animeName + "_" + episode + ".txt");
                    g.stop();
                }
            }
        } catch (final IOException e) {
            logger.warn(e.getMessage());
        }

    }

    public static void prepareDatabases() {
        TextboardDb.createTableBoards();
            TextboardDb.createTableThreads();
            TextboardDb.createTablePosts();
            YaaposDb.createYaaposUser();
            YaaposDb.createYaaposSpending();
    }

    static class CheckPanelDifference {
        static final boolean activeBool = false;
        public static boolean writeLogBool = false;

        static int[][][] oldArray;
        static int[][][] newArray;
        static int[][][] panelDifferenceCountArray;

        static boolean[][][] panelDifferenceArray;
    }

    static class Partition {
        static final boolean activeBool = true;
        static final boolean writeLogBool = false;
        static final boolean writeToDatabase = true;
        public static boolean printBool = false;

        static int[][][] tripleArray;

        static String imageDir;
        static String textDir;
    }

    static class GlobalDifference {
        static final boolean activeBool = false;
        static final boolean writeLogBool = false;

        static int[][][] tripleArray;

        static String imageDir;
        static String textDir;
    }

    static class BasicHistogramHash {
        static final boolean activeBool = false;
        public static boolean writeLogBool = false;
    }

    private static class globalAverageRGB {
        public static float[][][] average = new float[ImageProcessingTools.DIVISOR_VALUE][ImageProcessingTools.DIVISOR_VALUE][3];
    }
}
```


Overlapping Code:
```
final AnimeObject[] animeArray = new AnimeObject[]{new AnimeObject("eureka", 50)};
private static final Logger logger = LoggerFactory.getLogger(SettingUp.class);
@Deprecated
public static void insertPartitionDumpToDatabase() {
String insertScript = "";
int[][][] tripleArray;
logger.info("beginning to insert " + animeArray.length + " anime into the database");
for (int animeNumber = 0; animeNumber < animeArray.length; animeNumber++) {
logger.info("animeNumber:" + animeNumber);
try {
final int[] tmpPanels = new int[animeArray[animeNumber].getNumberOfEpisodes()];
for (int a = 1; a <= animeArray[animeNumber].getNumberOfEpisodes(); a++) {
tmpPanels[a - 1] = Integer.valueOf(AkarinLogging.readFile(
"dev_output/description/" + animeArray[animeNumber].getName() + "_" + a + ".txt"));
}
animeArray[animeNumber].setPanels(tmpPanels);
} catch (final IOException e) {
logger.info("FAIL READING DESCRIPTION TEXT");
logger.info(e.getMessage());
}
for (int episodeNumber = 1; episodeNumber <= animeArray[animeNumber]
.getNumberOfEpisodes(); episodeNumber++) {
for (int panelNumber = 0; panelNumber < animeArray[animeNumber].getPanels()[episodeNumber
- 1]; panelNumber++) {
try (Connection connection = DatabaseManager.getConnection()) {
final Statement stmt = connection.createStatement();
tripleArray = AkarinLogging.parseIntegerPartitionTextOutput("dev_output/text/"
+ animeArray[animeNumber].getName() + "/" + animeArray[animeNumber].getName() + "_"
+ episodeNumber + "_" + panelNumber + ".txt");
insertScript = ScriptCreator.insertIntoImagedbAnimeRgbInteger(animeArray[animeNumber].getName(),
episodeNumber, panelNumber, tripleArray);
logger.info("Executing script:" + insertScript);
stmt.executeUpdate(insertScript);
} catch (final IOException | URISyntaxException e) {
logger.info("id:" + panelNumber);
l
```
<Overlap Ratio: 0.9641902725815072>

---

--- 246 --
Question ID: 991adea834f02f0501ede9e084769835a451f54f
Original Code:
```
public class FinalizeDemo {

    public static void main(String[] args) {
        new Demo1();
        new Demo1();
        new Demo1();
        System.gc();    //启动垃圾回收器。垃圾回收线程是后台线程，随着其他线程的结束而自动结束
        System.out.println("Hello Threads");
    }

}
```


Overlapping Code:
```
lic class FinalizeDemo {
public static void main(String[] args) {
new Demo1();
new Demo1();
new Demo1();
System.gc(); //启动垃圾回收器。垃圾回收线程是后台线程，随着其他线程的结束而自动结束
System.out.printl
```
<Overlap Ratio: 0.8686868686868687>

---

--- 247 --
Question ID: 0d44edcb72c42ca000ce8bd7abf696c6737cac4d
Original Code:
```
public class EnvVariableTest extends TestRunner {
    final String testClasses;
    final ToolBox tb;
    final Path javaExePath;
    final ExecTask task;
    final PrintStream ostream;
    final ByteArrayOutputStream baos;

    public EnvVariableTest() {
        super(System.err);
        ostream = System.err;
        baos = new ByteArrayOutputStream();
        testClasses = System.getProperty("test.classes");
        tb = new ToolBox();
        javaExePath = tb.getJDKTool("java");
        task = new ExecTask(tb, javaExePath);
    }

    public static void main(String... args) throws Exception {
        EnvVariableTest t = new EnvVariableTest();
        t.runTests();
    }

    @Test
    public void testDoubleQuote() throws Exception {
        // white space quoted with double quotes
        test("-version -cp \"c:\\\\java libs\\\\one.jar\" \n",
                "-version", "-cp", "c:\\\\java libs\\\\one.jar");
    }

    @Test
    public void testSingleQuote() throws Exception {
        // white space quoted with single quotes
        test("-version -cp \'c:\\\\java libs\\\\one.jar\' \n",
                "-version", "-cp", "c:\\\\java libs\\\\one.jar");
    }

    @Test
    public void testEscapeCharacters() throws Exception {
        // escaped characters
        test("escaped chars testing \"\\a\\b\\c\\f\\n\\r\\t\\v\\9\\6\\23\\82\\28\\377\\477\\278\\287\"",
                "escaped", "chars", "testing", "\\a\\b\\c\\f\\n\\r\\t\\v\\9\\6\\23\\82\\28\\377\\477\\278\\287");
    }

    @Test
    public void testMixedQuotes() throws Exception {
        // more mixing of quote types
        test("\"mix 'single quote' in double\" 'mix \"double quote\" in single' partial\"quote me\"this",
                "mix 'single quote' in double", "mix \"double quote\" in single", "partialquote methis");
    }

    @Test
    public void testWhiteSpaces() throws Exception {
        // whitespace tests
        test("line one #comment\n'line #2' #rest are comment\r\n#comment on line 3\fline 4 #comment to eof",
                "line", "one", "#comment", "line #2", "#rest", "are", "comment", "#comment", "on", "line",
                "3", "line", "4", "#comment", "to", "eof");
    }

    @Test
    public void testMismatchedDoubleQuote() throws Exception {
        // mismatched quote
        test("This is an \"open quote \n    across line\n\t, note for WS.",
                "Exception: JDK_JAVAC_OPTIONS");
    }

    @Test
    public void testMismatchedSingleQuote() throws Exception {
        // mismatched quote
        test("This is an \'open quote \n    across line\n\t, note for WS.",
                "Exception: JDK_JAVAC_OPTIONS");
    }

    void test(String full, String... expectedArgs) throws Exception {
        task.envVar("JDK_JAVAC_OPTIONS", full);
        task.args("--add-exports", "jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED",
                "-cp", testClasses, "EnvVariableTest$Tester");
        Task.Result tr = task.run(Task.Expect.SUCCESS);
        String expected = Tester.arrayToString(expectedArgs);
        String in = tr.getOutput(Task.OutputKind.STDOUT);
        System.err.println("Matching...");
        System.err.println("Obtained: " + in);
        System.err.println("Expected: " + expected);
        if (in.contains(expected)) {
            System.err.println("....OK");
            return;
        }
        throw new Exception("Expected strings not found");
    }

    /**
     * A tester class that is invoked to invoke the CommandLine class, and
     * print the result.
     */
    public static class Tester {
        private static final String[] EMPTY_ARRAY = new String[0];
        static String arrayToString(String... args) {
            return String.join(", ", args);
        }
        public static void main(String... args) throws IOException {
            try {
                String[] argv = CommandLine.parse("JDK_JAVAC_OPTIONS", EMPTY_ARRAY);
                System.out.print(arrayToString(argv));
            } catch (CommandLine.UnmatchedQuote ex) {
                System.out.print("Exception: " + ex.variableName);
            }
        }
    }
}
```


Overlapping Code:
```
nvVariableTest extends TestRunner {
final String testClasses;
final ToolBox tb;
final Path javaExePath;
final ExecTask task;
final PrintStream ostream;
final ByteArrayOutputStream baos;
public EnvVariableTest() {
super(System.err);
ostream = System.err;
baos = new ByteArrayOutputStream();
testClasses = System.getProperty("test.classes");
tb = new ToolBox();
javaExePath = tb.getJDKTool("java");
task = new ExecTask(tb, javaExePath);
}
public static void main(String... args) throws Exception {
EnvVariableTest t = new EnvVariableTest();
t.runTests();
}
@Test
public void testDoubleQuote() throws Exception {
// white space quoted with double quotes
test("-version -cp \"c:\\\\java libs\\\\one.jar\" \n",
"-version", "-cp", "c:\\\\java libs\\\\one.jar");
}
@Test
public void testSingleQuote() throws Exception {
// white space quoted with single quotes
test("-version -cp \'c:\\\\java libs\\\\one.jar\' \n",
"-version", "-cp", "c:\\\\java libs\\\\one.jar");
}
@Test
public void testEscapeCharacters() throws Exception {
// escaped characters
test("escaped chars testing \"\\a\\b\\c\\f\\n\\r\\t\\v\\9\\6\\23\\82\\28\\377\\477\\278\\287\"",
"escaped", "chars", "testing", "\\a\\b\\c\\f\\n\\r\\t\\v\\9\\6\\23\\82\\28\\377\\477\\278\\287");
}
@Test
public void testMixedQuotes() throws Exception {
// more mixing of quote types
test("\"mix 'single quote' in double\" 'mix \"double quote\" in single' partial\"quote me\"this",
"mix 'single quote' in double", "mix \"double quote\" in single", "partialquote methis");
}
@Test
public void testWhiteSpaces() throws Exception {
// whitespace tests
test("line one #comment\n'line #2' #rest are comment\r\n#comment on line 3\fline 4 #comment to eof",
"line", "one", "#comment", "line #2", "#rest", "are", "comment", "#comment", "on", "line",
"3", "line", "4", "#comment", "to", "eof");
}
@Test
public void testMismatchedDoubleQuote() throws Exception {
// mismatched quote
test("This is an \"open quote \n across line\n\t, note for WS.",
"Exception: JDK_JAVAC_OPTIONS");
}
@Test
public void testMismatchedSingl
```
<Overlap Ratio: 0.9822712026832774>

---

--- 248 --
Question ID: 68a5442369dbbf4fb8e17e7df9cf0dedb72bd36c
Original Code:
```
@RunWith(AndroidJUnit4.class)
public class TabInfoTest extends TestCase {

    @Test
	public void testParcelable() {
		TabInfo tabInfo = new TabInfo();
		tabInfo.setTitle("test");
		tabInfo.setActivityClazz(0, ListableFragment.class);
		ListSettings settings = new ListSettings();
		settings.setShowFavorite(true);
		settings.addListItem(new ListItem(ListItemType.Attribute));

		tabInfo.getListSettings()[0] = settings;
		Parcel parcel = Parcel.obtain();

		tabInfo.writeToParcel(parcel, 0);

		parcel.setDataPosition(0);

		TabInfo newTabInfo = new TabInfo(parcel);
		ListSettings newSettings = newTabInfo.getListSettings()[0];

		assertEquals("test", tabInfo.getTitle());
		assertEquals(settings.isShowFavorite(), newSettings.isShowFavorite());
		assertEquals(settings.getListItems().size(), newSettings.getListItems().size());
	}

}
```


Overlapping Code:
```
ublic class TabInfoTest extends TestCase {
@Test
public void testParcelable() {
TabInfo tabInfo = new TabInfo();
tabInfo.setTitle("test");
tabInfo.setActivityClazz(0, ListableFragment.class);
ListSettings settings = new ListSettings();
settings.setShowFavorite(true);
settings.addListItem(new ListItem(ListItemType.Attribute));
tabInfo.getListSettings()[0] = settings;
Parcel parcel = Parcel.obtain();
tabInfo.writeToParcel(parcel, 0);
parcel.setDataPosition(0);
TabInfo newTabInfo = new TabInfo(parcel);
ListSettings newSettings = newTabInfo.getListSettings()[0];
assertEquals("test", tabInfo.getTitle());
assertEquals(settings.isShowFavorite(), newSettings.isShowFavorite());
assertEquals(settings.getListItems().size(), newSettings.getListItems().
```
<Overlap Ratio: 0.9457755359394704>

---

--- 249 --
Question ID: 363a1695ab14700775449ce4db08e09ece6ff906
Original Code:
```
public class CurrencyFormat {

    public static String rupiah(Float nominal)
    {
        DecimalFormat kursIndonesia = (DecimalFormat) DecimalFormat.getCurrencyInstance();
        DecimalFormatSymbols formatRp = new DecimalFormatSymbols();

        formatRp.setCurrencySymbol("Rp");
        formatRp.setMonetaryDecimalSeparator(',');
        formatRp.setGroupingSeparator('.');

        kursIndonesia.setDecimalFormatSymbols(formatRp);
        return kursIndonesia.format(nominal);
    }

}
```


Overlapping Code:
```
ing rupiah(Float nominal)
{
DecimalFormat kursIndonesia = (DecimalFormat) DecimalFormat.getCurrencyInstance();
DecimalFormatSymbols formatRp = new DecimalFormatSymbols();
formatRp.setCurrencySymbol("Rp");
formatRp.setMonetaryDecimalSeparator(',');
formatRp.setGroupingSeparator('.');
kursIndonesia.setDecimalFormatSymbols(formatRp);
return kursIndone
```
<Overlap Ratio: 0.831353919239905>

---

--- 250 --
Question ID: a6fba4ccef37c7f2c5a66c2f83f6382098182572
Original Code:
```
public class LocalDateTimeField extends CustomField<LocalDateTime> {

    private final DateField legacyDateField = new DateField();

    @Override
    protected void setInternalValue(LocalDateTime newValue) {
        super.setInternalValue(newValue);
        if (newValue == null) {
            legacyDateField.setValue(null);
        } else {
            Instant instant = newValue.atZone(ZoneId.systemDefault()).toInstant();
            legacyDateField.setValue(Date.from(instant));
        }
    }
    
     /**
     * Sets the resolution for UI.
     * 
     * The default resolution is {@link Resolution#SECOND}.
     * 
     * @param resolution
     *            the resolution to set.
     */
    public void setResolution(Resolution resolution) {
        legacyDateField.setResolution(resolution);
    }

    @Override
    protected Component initContent() {
        legacyDateField.addValueChangeListener(e -> {
            Date value = legacyDateField.getValue();
            if (value == null) {
                setValue(null);
            } else {
                setValue(LocalDateTime.ofInstant(value.toInstant(), ZoneId.systemDefault()));
            }
        });
        legacyDateField.setImmediate(true);
        legacyDateField.setResolution(Resolution.SECOND);
        return legacyDateField;
    }

    @Override
    public Class<? extends LocalDateTime> getType() {
        return LocalDateTime.class;
    }

}
```


Overlapping Code:
```
public class LocalDateTimeField extends CustomField<LocalDateTime> {
private final DateField legacyDateField = new DateField();
@Override
protected void setInternalValue(LocalDateTime newValue) {
super.setInternalValue(newValue);
if (newValue == null) {
legacyDateField.setValue(null);
} else {
Instant instant = newValue.atZone(ZoneId.systemDefault()).toInstant();
legacyDateField.setValue(Date.from(instant));
}
}

/**
* Sets the resolution for UI.
* 
* The default resolution is {@link Resolution#SECOND}.
* 
* @param resolution
* the resolution to set.
*/
public void setResolution(Resolution resolution) {
legacyDateField.setResolution(resolution);
}
@Override
protected Component initContent() {
legacyDateField.addValueChangeListener(e -> {
Date value = legacyDateField.getValue();
if (value == null) {
setValue(null);
} else {
setValue(LocalDateTime.ofInstant(value.toInstant(), ZoneId.systemDefault()));
}
});
legacyDateField.setImmediate(true);
legacyDateField.setResolution(Resolution.SECOND);
return legacyDateField;
}
@Override
public Class<? extends LocalDateTime> getType() {
return LocalDateTime.cla
```
<Overlap Ratio: 0.9937611408199644>

---

--- 251 --
Question ID: bfa69dbd88c38519fb209a7e4c2ea89fa9662cd1
Original Code:
```
public abstract class BasicPHPWizardPage extends WizardPage {

	private IStatus fCurrStatus;

	private boolean fPageVisible;

	protected BasicPHPWizardPage(String pageName) {
		super(pageName);
	}

	protected Button createButton(Composite composite, int style,
			String message, GridData gd) {
		Button button = new Button(composite, style);
		button.setText(message);
		button.setLayoutData(gd);
		return button;
	}

	protected GridLayout createGridLayout(int columns) {
		return new GridLayout(columns, false);

	}

	protected GridData createGridData(int flag, int hspan, int vspan, int indent) {
		GridData gd = new GridData(flag);
		gd.horizontalIndent = indent;
		gd.horizontalSpan = hspan;
		gd.verticalSpan = vspan;
		return gd;
	}

	protected GridData createGridData(int flag, int hspan, int indent) {
		GridData gd = new GridData(flag);
		gd.horizontalIndent = indent;
		gd.horizontalSpan = hspan;
		return gd;
	}

	protected GridData createGridData(int hspan) {
		GridData gd = new GridData();
		gd.horizontalSpan = hspan;
		return gd;
	}

	protected void createSeparator(Composite composite, int horizontalSpan) {
		Label line = new Label(composite, SWT.SEPARATOR | SWT.HORIZONTAL);
		GridData gridData = new GridData(GridData.FILL_HORIZONTAL);
		if (horizontalSpan > 0)
			gridData.horizontalSpan = horizontalSpan;

		line.setLayoutData(gridData);
	}

	protected Label createLabel(Composite composite, int style, String message,
			GridData gd) {
		Label label = new Label(composite, style);
		label.setText(message);
		label.setLayoutData(gd);
		return label;
	}

	protected Text createText(Composite composite, int style, String message,
			GridData gd) {
		Text text = new Text(composite, style);
		if (message != null)
			text.setText(message);
		text.setLayoutData(gd);
		return text;
	}

	protected Combo createCombo(Composite composite, int style, String message,
			GridData gd) {
		Combo combo = new Combo(composite, style);
		if (message != null)
			combo.setText(message);
		combo.setLayoutData(gd);
		return combo;
	}

	protected void handleFileBrowseButtonPressed(Text text,
			String[] extensions, String title) {
		FileDialog dialog = new FileDialog(text.getShell());
		dialog.setText(title);
		dialog.setFilterExtensions(extensions);
		String dirName = text.getText();
		if (!dirName.equals("")) { //$NON-NLS-1$
			File path = new File(dirName);
			if (path.exists())
				dialog.setFilterPath(dirName);

		}
		String selectedDirectory = dialog.open();
		if (selectedDirectory != null)
			text.setText(selectedDirectory);
	}

	protected void handleFileBrowseButtonPressed(Combo text,
			String[] extensions, String title) {
		FileDialog dialog = new FileDialog(text.getShell());
		dialog.setText(title);
		dialog.setFilterExtensions(extensions);
		String dirName = text.getText();
		if (!dirName.equals("")) { //$NON-NLS-1$
			File path = new File(dirName);
			if (path.exists())
				dialog.setFilterPath(dirName);

		}
		String selectedDirectory = dialog.open();
		if (selectedDirectory != null) {
			text.add(selectedDirectory);
			text.select(text.indexOf(selectedDirectory));
			text.notifyListeners(SWT.Modify, new Event());
		}
	}

	protected void handleFileBrowseButtonPressed(Combo text,
			String[] extensions, String title, String fileName) {
		FileDialog dialog = new FileDialog(text.getShell(), SWT.SAVE);
		dialog.setText(title);
		dialog.setFilterExtensions(extensions);
		dialog.setFileName(fileName);
		String dirName = text.getText();
		if (!dirName.equals("")) { //$NON-NLS-1$
			File path = new File(dirName);
			if (path.exists())
				dialog.setFilterPath(dirName);

		}
		String selectedDirectory = dialog.open();
		if (selectedDirectory != null) {
			text.add(selectedDirectory);
			text.select(text.indexOf(selectedDirectory));
			text.notifyListeners(SWT.Modify, new Event());
		}
	}

	protected String handleFolderBrowseButtonPressed(String dir, String title,
			String message) {
		DirectoryDialog dialog = new DirectoryDialog(getShell());
		dialog.setFilterPath(dir);
		dialog.setText(title);
		dialog.setMessage(message);
		String res = dialog.open();
		if (res != null) {
			File file = new File(res);
			if (file.isDirectory())
				return res;
		}
		return dir;
	}

	/**
	 * Updates the status line and the OK button according to the given status
	 * 
	 * @param status
	 *            status to apply
	 */
	protected void updateStatus(IStatus status) {
		fCurrStatus = status;
		setPageComplete(!status.matches(IStatus.ERROR));
		if (fPageVisible) {
			StatusUtil.applyToStatusLine(this, status);
		}
	}

	/*
	 * @see WizardPage#becomesVisible
	 */
	public void setVisible(boolean visible) {
		super.setVisible(visible);
		fPageVisible = visible;
		// policy: wizards are not allowed to come up with an error message
		if (visible && fCurrStatus.matches(IStatus.ERROR)) {
			StatusInfo status = new StatusInfo();
			status.setError(""); //$NON-NLS-1$
			fCurrStatus = status;
		}
		updateStatus(fCurrStatus);
	}

	public ArrayList setComboItems(Combo combo, ArrayList arrItems) {
		arrItems.clear();
		arrItems.add(combo.getText()); // must be first
		String[] items = combo.getItems();
		for (int i = 0; i < items.length; i++) {
			String curr = items[i];
			if (!arrItems.contains(curr)) {
				arrItems.add(curr);
			}
		}
		return arrItems;

	}

	protected static class EnableSelectionAdapter extends SelectionAdapter {
		private Control[] fEnable;
		private Control[] fDisable;

		protected EnableSelectionAdapter(Control[] enable, Control[] disable) {
			super();
			fEnable = enable;
			fDisable = disable;
		}

		public void widgetSelected(SelectionEvent e) {
			for (int i = 0; i < fEnable.length; i++) {
				fEnable[i].setEnabled(true);
			}
			for (int i = 0; i < fDisable.length; i++) {
				fDisable[i].setEnabled(false);
			}
			validate();
		}

		// copied from WizardNewProjectCreationPage
		public void validate() {
		}

	} // end class EnableSelectionAdapter

	protected static class ToggleSelectionAdapter extends SelectionAdapter {
		Control[] controls;

		protected ToggleSelectionAdapter(Control[] controls) {
			this.controls = controls;
		}

		public void widgetSelected(SelectionEvent e) {

			for (int i = 0; i < controls.length; i++) {
				Control control = controls[i];
				control.setEnabled(!control.getEnabled());
			}
			validate();
		}

		public void validate() {
		}

	} // end class ToggleSelection Adapter

}
```


Overlapping Code:
```
dPage extends WizardPage {
private IStatus fCurrStatus;
private boolean fPageVisible;
protected BasicPHPWizardPage(String pageName) {
super(pageName);
}
protected Button createButton(Composite composite, int style,
String message, GridData gd) {
Button button = new Button(composite, style);
button.setText(message);
button.setLayoutData(gd);
return button;
}
protected GridLayout createGridLayout(int columns) {
return new GridLayout(columns, false);
}
protected GridData createGridData(int flag, int hspan, int vspan, int indent) {
GridData gd = new GridData(flag);
gd.horizontalIndent = indent;
gd.horizontalSpan = hspan;
gd.verticalSpan = vspan;
return gd;
}
protected GridData createGridData(int flag, int hspan, int indent) {
GridData gd = new GridData(flag);
gd.horizontalIndent = indent;
gd.horizontalSpan = hspan;
return gd;
}
protected GridData createGridData(int hspan) {
GridData gd = new GridData();
gd.horizontalSpan = hspan;
return gd;
}
protected void createSeparator(Composite composite, int horizontalSpan) {
Label line = new Label(composite, SWT.SEPARATOR | SWT.HORIZONTAL);
GridData gridData = new GridData(GridData.FILL_HORIZONTAL);
if (horizontalSpan > 0)
gridData.horizontalSpan = horizontalSpan;
line.setLayoutData(gridData);
}
protected Label createLabel(Composite composite, int style, String message,
GridData gd) {
Label label = new Label(composite, style);
label.setText(message);
label.setLayoutData(gd);
return label;
}
protected Text createText(Composite composite, int style, String message,
GridData gd) {
Text text = new Text(composite, style);
if (message != null)
text.setText(message);
text.setLayoutData(gd);
return text;
}
protected Combo createCombo(Composite composite, int style, String message,
GridData gd) {
Combo combo = new Combo(composite, style);
if (message != null)
combo.setText(message);
combo.setLayoutData(gd);
return combo;
}
protected void handleFileBrowseButtonPressed(Text text,
String[] extensions, String title) {
FileDialog dialog = new FileDialog(text.getShell());
dialog.setText(title);
dialog.setFilterExtensions(extensions);
String dirName = text.getText();
if (!dirName.equals("")) { //$NON-NLS-1$
File path = new File(dirName);
if (path.exists())
dialog.setFilterPath(dirName);
}
String selectedDirectory = dialog.open();
if (selectedDire
```
<Overlap Ratio: 0.9850555081127241>

---

--- 252 --
Question ID: 4a3b2ea03318813390aab74120fed8575db66981
Original Code:
```
public class PotionNamePool {
  
  public static List<String> list = new ArrayList<String>();
  
  public static void clear() {
    list.clear();
    list.add(_("redPotion"));
    list.add(_("greenPotion"));
    list.add(_("bluePotion"));
    list.add(_("purplePotion"));
    list.add(_("yellowPotion"));
  }
  
  public static String get() {
    return list.remove(RandomProvider.getRandom().nextInt(list.size()));
  }

}
```


Overlapping Code:
```
mePool {

public static List<String> list = new ArrayList<String>();

public static void clear() {
list.clear();
list.add(_("redPotion"));
list.add(_("greenPotion"));
list.add(_("bluePotion"));
list.add(_("purplePotion"));
list.add(_("yellowPotion"));
}

public static String get() {
return list.remove(RandomProvider.getRandom().nextInt(list.size())
```
<Overlap Ratio: 0.9283819628647215>

---

--- 253 --
Question ID: 731e371e5ca6687559f264f32bd28fd8e61b2fd8
Original Code:
```
@SuppressWarnings("ConstantConditions")
public final class EmailUtils {

	/**
	 * Remove emails que possuem o mesmo título e conteudo, ou seja,
	 * são iguais perante o equals.
	 *
	 * @param emailList - cabeça da lista de emails
	 * @return lista de emails sem duplicacoes
	 */
	public static SingleLinkedList<Email> cleanDuplicatedEmails(SingleLinkedList<Email> emailList) {
		LinkedNode<Email> head = emailList.getHead();
		if (emailList == null || emailList.isEmpty()) {
			return emailList;
		}

		LinkedNode<Email> auxNode = head;
		for (; auxNode != null; auxNode = auxNode.getNext()) {
			if (auxNode.getNext() == null) {
				break;
			} else {
				LinkedNode<Email> next = auxNode.getNext();
				LinkedNode<Email> prevNode = auxNode;
				for (; next != null; next = next.getNext()) {
					if (isDuplicatedEmail(auxNode.getValue(), next.getValue())) {
						if (next.getNext() != null) {
							prevNode.setNext(next.getNext());
						} else {
							prevNode.setNext(null); // Final da lista
						}
					} else {
						prevNode = next; // atualiza prev somente para nao iguais
					}
				}
			}
		}
		emailList.updateSize();

		return emailList;
	}

	/**
	 * Encontra o nó que tem a mesma referencia que o nó de outra lista tem.
	 *
	 * @param firstList  - primeira lista
	 * @param secondList - a lista que sera verificado elemento a elemento se possue mesma ref que da primeira lista.
	 * @return primeiro nó que ambas listas possuem mesma referencia
	 */
	public static LinkedNode<Email> findIntersectionBetween(SingleLinkedList<Email> firstList, SingleLinkedList<Email> secondList) {
		LinkedNode<Email> head = firstList.getHead();
		LinkedNode<Email> secondHead = secondList.getHead();
		for (; head != null && secondHead != null; head = head.getNext(), secondHead = secondList.getHead()) {
			for (; secondHead != null; secondHead = secondHead.getNext()) {
				if (head.getNext() == secondHead.getNext()) {
					return head.getNext();
				}
			}
		}

		return null;
	}

	private static boolean isDuplicatedEmail(Email actual, Email compare) {
		return actual.equals(compare);
	}
}
```


Overlapping Code:
```
@SuppressWarnings("ConstantConditions")
public final class EmailUtils {
/**
* Remove emails que possuem o mesmo título e conteudo, ou seja,
* são iguais perante o equals.
*
* @param emailList - cabeça da lista de emails
* @return lista de emails sem duplicacoes
*/
public static SingleLinkedList<Email> cleanDuplicatedEmails(SingleLinkedList<Email> emailList) {
LinkedNode<Email> head = emailList.getHead();
if (emailList == null || emailList.isEmpty()) {
return emailList;
}
LinkedNode<Email> auxNode = head;
for (; auxNode != null; auxNode = auxNode.getNext()) {
if (auxNode.getNext() == null) {
break;
} else {
LinkedNode<Email> next = auxNode.getNext();
LinkedNode<Email> prevNode = auxNode;
for (; next != null; next = next.getNext()) {
if (isDuplicatedEmail(auxNode.getValue(), next.getValue())) {
if (next.getNext() != null) {
prevNode.setNext(next.getNext());
} else {
prevNode.setNext(null); // Final da lista
}
} else {
prevNode = next; // atualiza prev somente para nao iguais
}
}
}
}
emailList.updateSize();
return emailList;
}
/**
* Encontra o nó que tem a mesma referencia que o nó de outra lista tem.
*
* @param firstList - primeira lista
* @param secondList - a lista que sera verificado elemento a elemento se possue mesma ref que da primeira lista.
* @return primeiro nó que ambas listas possuem mesma referencia
*/
public static LinkedNode<Email> findIntersectionBetween(SingleLinkedList<Email> firstList, SingleLinkedList<Email> secondList) {
LinkedNode<Email> head = firstList.getHead();
LinkedNode<Email> secondHead = secondList.getHead();
for (; head != null && secondHead != null; head = head.getNext(), secondHead = secondList.getHead()) {
for (; secondHead != null; secondHead = secondHead.getNext()) {
if (head.getNext() == secondHead.getNext()) {
return head.getNext();
}
}
}
return null;
}
private static boolean isDuplicatedEmail(Email actual, Email com
```
<Overlap Ratio: 0.9781818181818182>

---

--- 254 --
Question ID: 417ebb05ad718a619e0b1d2a468e5237325991e2
Original Code:
```
public class CloudStackUsageTypes {

    /**
     * Access list of vanilla usage record types
     *
     * @return list
     */
    public static List<String> getList() {
        List<String> list = new ArrayList<String>();

        // we have to add them manually
        list.add(new VMUsageData().getMeterNameForRunning());
        list.add(new VMUsageData().getMeterNameForAllocated());
        list.add(new IPUsageData().getMeterName());
        list.add(new NetworkUsageData().getMeterNameForOutgoing());
        list.add(new NetworkUsageData().getMeterNameForIncoming());
        list.add(new VolumeUsageData().getMeterName());
        list.add(new TemplateAndIsoUsageData().getMeterNameTemplate());
        list.add(new TemplateAndIsoUsageData().getMeterNameISO());
        list.add(new SnapshotUsageData().getMeterName());
        list.add(new PolicyOrRuleUsageData().getMeterNameBalancer());
        list.add(new PolicyOrRuleUsageData().getMeterNameForwarder());
        list.add(new NetworkOfferingUsageData().getMeterName());
        list.add(new VPNUserUsageData().getMeterName());

        return list;
    }

}
```


Overlapping Code:
```
geTypes {
/**
* Access list of vanilla usage record types
*
* @return list
*/
public static List<String> getList() {
List<String> list = new ArrayList<String>();
// we have to add them manually
list.add(new VMUsageData().getMeterNameForRunning());
list.add(new VMUsageData().getMeterNameForAllocated());
list.add(new IPUsageData().getMeterName());
list.add(new NetworkUsageData().getMeterNameForOutgoing());
list.add(new NetworkUsageData().getMeterNameForIncoming());
list.add(new VolumeUsageData().getMeterName());
list.add(new TemplateAndIsoUsageData().getMeterNameTemplate());
list.add(new TemplateAndIsoUsageData().getMeterNameISO());
list.add(new SnapshotUsageData().getMeterName());
list.add(new PolicyOrRuleUsageData().getMeterNameBalancer());
list.add(new PolicyOrRuleUsageData().getMeterNameForwarder());
list.add(new NetworkOfferingUsageData().getMeterName());
list.add(new VPNUserUsageData
```
<Overlap Ratio: 0.9355509355509356>

---

--- 255 --
Question ID: 3fcb9272c622fcada129c1cbcd8a90c413009d5b
Original Code:
```
public class ExampleDeviceAccess {
	/*
	 * Maximum number or RO requests that can be executed simultaneously to each device. Other threads should wait
	 * their turn to request device data.
	 */
	private static final int MAX_SIMULTANEOUS_RO_REQUESTS_PER_DEVICE = 30;

	/* Maximum number or requests that can be executed simultaneously by server. */
	private static final int MAX_SIMULTANEOUS_FOR_ALL_DEVICES = 600;

	ACheckpoint cp = CheckpointBuilder.newInst()
			.setName("Device access")
			.setMaxPassesPerResource(MAX_SIMULTANEOUS_RO_REQUESTS_PER_DEVICE)
			.setReentrant(false)
			.setFair(true)
			.setGlobalPassesLimit(MAX_SIMULTANEOUS_FOR_ALL_DEVICES)
			.build();

	public String readDeviceData(InetAddress device) {
		String deviceData;
		
		try (Pass p = cp.getPassUninterruptibly(device)) {
			// read device data here 
			// there are no writing threads for current device and no more then
			// MAX_SIMULTANEOUS_RO_REQUESTS_PER_DEVICE threads are reading current device
			
			deviceData = "";
		}
		
		return deviceData;
	}

	public boolean writeDeviceData(InetAddress device, String deviceData) {
		
		try (Pass p = cp.getPassRWUninterruptibly(device)) {
			// write device data here 
			// there is no other reading or writing threads for current device 
			// when current thread received access here 
			// but there might be other RW threads in this section which access other devices
			
		}
		
		return true;
	}
}
```


Overlapping Code:
```
eAccess {
/*
* Maximum number or RO requests that can be executed simultaneously to each device. Other threads should wait
* their turn to request device data.
*/
private static final int MAX_SIMULTANEOUS_RO_REQUESTS_PER_DEVICE = 30;
/* Maximum number or requests that can be executed simultaneously by server. */
private static final int MAX_SIMULTANEOUS_FOR_ALL_DEVICES = 600;
ACheckpoint cp = CheckpointBuilder.newInst()
.setName("Device access")
.setMaxPassesPerResource(MAX_SIMULTANEOUS_RO_REQUESTS_PER_DEVICE)
.setReentrant(false)
.setFair(true)
.setGlobalPassesLimit(MAX_SIMULTANEOUS_FOR_ALL_DEVICES)
.build();
public String readDeviceData(InetAddress device) {
String deviceData;

try (Pass p = cp.getPassUninterruptibly(device)) {
// read device data here 
// there are no writing threads for current device and no more then
// MAX_SIMULTANEOUS_RO_REQUESTS_PER_DEVICE threads are reading current device

deviceData = "";
}

return deviceData;
}
public boolean writeDeviceData(InetAddress device, String deviceData) {

try (Pass p = cp.getPassRWUninterruptibly(device)) {
// write device data here 
// there is no other reading or writing threads for current device 
// when current thread received access here 
// but there might be other RW threads in this section which access other devices

}

retur
```
<Overlap Ratio: 0.9732739420935412>

---

--- 256 --
Question ID: ce9dfd48e9f0d8afa563abbbea460bdba9eb0271
Original Code:
```
public class CaseQueryServiceTest {

    private static final String[] LAST_MODIFIED = {"2018", "1", "1", "0", "0", "0", "0"};

    @Mock
    private RestTemplate restTemplate;

    @Mock
    private HttpHeadersFactory headers;

    @Mock
    private AppInsights appInsights;

    @Mock
    private CCDDataStoreAPIConfiguration ccdDataStoreAPIConfiguration;

    @Mock
    private IdamAuthenticateUserService idamAuthenticateUserService;

    @Mock
    private ServiceAuthTokenGenerator serviceAuthTokenGenerator;

    @Mock
    private FileSystemResourceService fileSystemResourceService;

    @Captor
    private ArgumentCaptor<HttpEntity<String>> entityCaptor;

    @InjectMocks
    private CaseQueryService caseQueryService;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);

        when(serviceAuthTokenGenerator.generate()).thenReturn("Bearer 321");
        when(idamAuthenticateUserService.getIdamOauth2Token()).thenReturn("Bearer 123");
        when(headers.getAuthorizationHeaders()).thenReturn(new HttpHeaders());

        when(ccdDataStoreAPIConfiguration.getHost()).thenReturn("http://localhost");
        when(ccdDataStoreAPIConfiguration.getCaseMatchingPath()).thenReturn("/path");

        CaseData caseData = CaseData.builder()
            .deceasedSurname("Smith")
            .build();
        List<ReturnedCaseDetails> caseList =
            new ImmutableList.Builder<ReturnedCaseDetails>().add(new ReturnedCaseDetails(caseData,
                LAST_MODIFIED, 1L))
                .build();
        ReturnedCases returnedCases = new ReturnedCases(caseList, 1);

        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases);
    }

    @Test
    public void findCasesWithDatedDocumentReturnsCaseList() {
        List<ReturnedCaseDetails> cases =
            caseQueryService.findGrantIssuedCasesWithGrantIssuedDate("invokingService", "2021-01-01");

        assertEquals(1, cases.size());
        assertThat(cases.get(0).getId(), is(1L));
        assertEquals("Smith", cases.get(0).getData().getDeceasedSurname());
    }

    @Test
    public void findAllCasesWithDatedDocumentReturnsCaseList() {
        caseQueryService.dataExtractPaginationSize = 1;
        List<ReturnedCaseDetails> cases = caseQueryService.findAllCasesWithGrantIssuedDate("invokingService",
            "2021-01-01");

        assertEquals(1, cases.size());
        assertThat(cases.get(0).getId(), is(1L));
        assertEquals("Smith", cases.get(0).getData().getDeceasedSurname());
    }

    @Test
    public void findAllCasesWithDatedDocumentReturnsCaseListForMultiplePages() {
        caseQueryService.dataExtractPaginationSize = 3;
        ReturnedCases returnedCases1 = getReturnedCases(3, 0, 5);
        ReturnedCases returnedCases2 = getReturnedCases(2, 3, 5);
        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2);
        List<ReturnedCaseDetails> cases = caseQueryService.findAllCasesWithGrantIssuedDate("invokingService",
            "2021-01-01");

        assertEquals(5, cases.size());
        assertThat(cases.get(0).getId(), is(0L));
        assertThat(cases.get(1).getId(), is(1L));
        assertThat(cases.get(2).getId(), is(2L));
        assertThat(cases.get(3).getId(), is(3L));
        assertThat(cases.get(4).getId(), is(4L));
        assertEquals("Smith0", cases.get(0).getData().getDeceasedSurname());
        assertEquals("Smith1", cases.get(1).getData().getDeceasedSurname());
        assertEquals("Smith2", cases.get(2).getData().getDeceasedSurname());
        assertEquals("Smith3", cases.get(3).getData().getDeceasedSurname());
        assertEquals("Smith4", cases.get(4).getData().getDeceasedSurname());
    }

    @Test
    public void findAllCasesWithDatedDocumentReturnsCaseListForMultiplePagesExact() {
        caseQueryService.dataExtractPaginationSize = 3;
        ReturnedCases returnedCases1 = getReturnedCases(3, 0, 6);
        ReturnedCases returnedCases2 = getReturnedCases(3, 3, 6);
        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2);
        List<ReturnedCaseDetails> cases = caseQueryService.findAllCasesWithGrantIssuedDate("invokingService",
            "2021-01-01");

        assertEquals(6, cases.size());
        assertThat(cases.get(0).getId(), is(0L));
        assertThat(cases.get(1).getId(), is(1L));
        assertThat(cases.get(2).getId(), is(2L));
        assertThat(cases.get(3).getId(), is(3L));
        assertThat(cases.get(4).getId(), is(4L));
        assertThat(cases.get(5).getId(), is(5L));
        assertEquals("Smith0", cases.get(0).getData().getDeceasedSurname());
        assertEquals("Smith1", cases.get(1).getData().getDeceasedSurname());
        assertEquals("Smith2", cases.get(2).getData().getDeceasedSurname());
        assertEquals("Smith3", cases.get(3).getData().getDeceasedSurname());
        assertEquals("Smith4", cases.get(4).getData().getDeceasedSurname());
        assertEquals("Smith5", cases.get(5).getData().getDeceasedSurname());
    }

    @Test
    public void findAllCasesWithDatedDocumentReturnsCaseListForMultiplePagesPlus() {
        caseQueryService.dataExtractPaginationSize = 3;
        ReturnedCases returnedCases1 = getReturnedCases(3, 0, 7);
        ReturnedCases returnedCases2 = getReturnedCases(3, 3, 7);
        ReturnedCases returnedCases3 = getReturnedCases(1, 6, 7);
        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2,
            returnedCases3);
        List<ReturnedCaseDetails> cases = caseQueryService.findAllCasesWithGrantIssuedDate("invokingService",
            "2021-01-01");

        assertEquals(7, cases.size());
        assertThat(cases.get(0).getId(), is(0L));
        assertThat(cases.get(1).getId(), is(1L));
        assertThat(cases.get(2).getId(), is(2L));
        assertThat(cases.get(3).getId(), is(3L));
        assertThat(cases.get(4).getId(), is(4L));
        assertThat(cases.get(5).getId(), is(5L));
        assertThat(cases.get(6).getId(), is(6L));
        assertEquals("Smith0", cases.get(0).getData().getDeceasedSurname());
        assertEquals("Smith1", cases.get(1).getData().getDeceasedSurname());
        assertEquals("Smith2", cases.get(2).getData().getDeceasedSurname());
        assertEquals("Smith3", cases.get(3).getData().getDeceasedSurname());
        assertEquals("Smith4", cases.get(4).getData().getDeceasedSurname());
        assertEquals("Smith5", cases.get(5).getData().getDeceasedSurname());
        assertEquals("Smith6", cases.get(6).getData().getDeceasedSurname());
    }

    private ReturnedCases getReturnedCases(int numCases, int caseIndex, int total) {
        ArrayList<ReturnedCaseDetails> allReturnedCases = new ArrayList<>();
        for (int i = 0; i < numCases; i++) {
            CaseData caseData = CaseData.builder()
                .deceasedSurname("Smith" + (caseIndex + i))
                .build();
            allReturnedCases.add(new ReturnedCaseDetails(caseData,
                LAST_MODIFIED, Long.valueOf(caseIndex + i)));
        }
        List<ReturnedCaseDetails> caseList =
            new ImmutableList.Builder<ReturnedCaseDetails>()
                .addAll(allReturnedCases)
                .build();
        return new ReturnedCases(caseList, total);
    }

    @Test
    public void findCasesInitiatedBySchedulerReturnsCaseList() {
        when(headers.getAuthorizationHeaders()).thenThrow(NullPointerException.class);
        List<ReturnedCaseDetails> cases = caseQueryService.findGrantIssuedCasesWithGrantIssuedDate("invokingService",
            "2021-01-01");

        assertEquals(1, cases.size());
        assertThat(cases.get(0).getId(), is(1L));
        assertEquals("Smith", cases.get(0).getData().getDeceasedSurname());
    }

    @Test
    public void findCasesWithDateRangeReturnsCaseListExela() {
        when(fileSystemResourceService.getFileFromResourceAsString(anyString())).thenReturn("qry");
        ReturnedCases returnedCases1 = getReturnedCases(1, 0, 3);
        ReturnedCases returnedCases2 = getReturnedCases(1, 1, 3);
        ReturnedCases returnedCases3 = getReturnedCases(1, 2, 3);
        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2,
                returnedCases3);
        List<ReturnedCaseDetails> cases = caseQueryService
            .findCaseStateWithinDateRangeExela("2019-01-01", "2019-02-05");

        assertEquals(3, cases.size());
        assertEquals(0, cases.get(0).getId().intValue());
        assertEquals("Smith0", cases.get(0).getData().getDeceasedSurname());
    }

    @Test(expected = ClientDataException.class)
    public void findCasesWithDateRangeThrowsError() {
        CaseData caseData = CaseData.builder()
            .deceasedSurname("Smith")
            .build();
        List<ReturnedCaseDetails> caseList =
            new ImmutableList.Builder<ReturnedCaseDetails>()
                .add(new ReturnedCaseDetails(caseData, LAST_MODIFIED, 1L))
                .add(new ReturnedCaseDetails(caseData, LAST_MODIFIED, 2L))
                .add(new ReturnedCaseDetails(caseData, LAST_MODIFIED, 3L))
                .build();
        ReturnedCases returnedCases = new ReturnedCases(caseList, 3);
        when(restTemplate.postForObject(any(), any(), any())).thenReturn(null);

        when(fileSystemResourceService.getFileFromResourceAsString(anyString())).thenReturn("qry");
        caseQueryService.findCaseStateWithinDateRangeExela("2019-01-01", "2019-02-05");
    }

    @Test
    public void findCasesWithDateRangeReturnsCaseListHMRC() {
        when(fileSystemResourceService.getFileFromResourceAsString(anyString())).thenReturn("qry");
        ReturnedCases returnedCases1 = getReturnedCases(1, 0, 3);
        ReturnedCases returnedCases2 = getReturnedCases(1, 1, 3);
        ReturnedCases returnedCases3 = getReturnedCases(1, 2, 3);
        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2,
                returnedCases3);
        List<ReturnedCaseDetails> cases = caseQueryService
            .findCaseStateWithinDateRangeHMRC("2019-01-01", "2019-02-05");

        assertEquals(3, cases.size());
        assertEquals(0, cases.get(0).getId().intValue());
        assertEquals("Smith0", cases.get(0).getData().getDeceasedSurname());
    }

    @Test
    public void findCasesWithDateRangeReturnsCaseListSmeeAndFord() {
        when(fileSystemResourceService.getFileFromResourceAsString(anyString())).thenReturn("qry");
        ReturnedCases returnedCases1 = getReturnedCases(1, 0, 3);
        ReturnedCases returnedCases2 = getReturnedCases(1, 1, 3);
        ReturnedCases returnedCases3 = getReturnedCases(1, 2, 3);
        when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases1, returnedCases2,
                returnedCases3);

        List<ReturnedCaseDetails> cases = caseQueryService
            .findCaseStateWithinDateRangeSmeeAndFord("2019-01-01", "2019-02-05");

        assertEquals(3, cases.size());
        assertEquals(0, cases.get(0).getId().intValue());
        assertEquals("Smith0", cases.get(0).getData().getDeceasedSurname());
    }

    @Test
    public void testHttpExceptionCaughtWithBadPost() {
        when(restTemplate.postForObject(any(), any(), any())).thenThrow(HttpClientErrorException.class);

        Assertions.assertThatThrownBy(() -> caseQueryService.findGrantIssuedCasesWithGrantIssuedDate("invokingService",
            "2021-01-01"))
            .isInstanceOf(CaseMatchingException.class);
    }

    @Test
    public void findCasesForGrantDelayed() {
        List<ReturnedCaseDetails> cases = caseQueryService.findCasesForGrantDelayed("2019-02-05");

        assertEquals(1, cases.size());
        assertEquals(1, cases.get(0).getId().intValue());
        assertEquals("Smith", cases.get(0).getData().getDeceasedSurname());
    }

    @Test
    public void findCasesForGrantAwaitingDocs() {
        CaseData caseData = CaseData.builder()
            .deceasedSurname("Smith")
            .build();
        List<ReturnedCaseDetails> caseList =
            new ImmutableList.Builder<ReturnedCaseDetails>().add(new ReturnedCaseDetails(caseData,
                LAST_MODIFIED, 1L))
                .build();
        ReturnedCases returnedCases = new ReturnedCases(caseList, 1);
        when(restTemplate.postForObject(any(), entityCaptor.capture(), any())).thenReturn(returnedCases);

        List<ReturnedCaseDetails> cases = caseQueryService.findCasesForGrantAwaitingDocumentation("2019-02-05");

        String expected = "{\"from\":0,\"size\":0,\"query\":{\"bool\":{\"must\":[{\"bool\":{\"should\":[{\"match\":"
                + "{\"state\":{\"query\":\"CasePrinted\",\"operator\":\"OR\",\"prefix_length\":0,\"max_expansions\":50,"
                + "\"fuzzy_transpositions\":true,\"lenient\":false,\"zero_terms_query\":\"NONE\","
                + "\"auto_generate_synonyms_phrase_query\":true,\"boost\":1.0}}}],\"adjust_pure_negative\":true,"
                + "\"minimum_should_match\":\"1\",\"boost\":1.0}},{\"match\":"
                + "{\"data.grantAwaitingDocumentationNotificationDate\":{\"query\":\"2019-02-05\",\"operator\":\"OR\","
                + "\"prefix_length\":0,\"max_expansions\":50,\"fuzzy_transpositions\":true,\"lenient\":false,"
                + "\"zero_terms_query\":\"NONE\",\"auto_generate_synonyms_phrase_query\":true,\"boost\":1.0}}},"
                + "{\"match\":{\"data.paperForm\":{\"query\":\"No\",\"operator\":\"OR\",\"prefix_length\":0,"
                + "\"max_expansions\":50,\"fuzzy_transpositions\":true,\"lenient\":false,\"zero_terms_query\":\"NONE\","
                + "\"auto_generate_synonyms_phrase_query\":true,\"boost\":1.0}}}],\"must_not\":[{\"exists\":{\"field\":"
                + "\"data.grantAwaitingDocumentatioNotificationSent\",\"boost\":1.0}},{\"exists\":{\"field\":"
                + "\"data.evidenceHandled\",\"boost\":1.0}}],\"adjust_pure_negative\":true,\"boost\":1.0}},"
                + "\"sort\":[{\"id\":{\"order\":\"asc\"}}]}";
        assertEquals(expected, entityCaptor.getValue().getBody());
        assertEquals(1, cases.size());
        assertEquals(1, cases.get(0).getId().intValue());
        assertEquals("Smith", cases.get(0).getData().getDeceasedSurname());
    }

    @Test(expected = ClientDataException.class)
    public void testExceptionWithNullFromRestTemplatePost() {
        when(restTemplate.postForObject(any(), any(), any())).thenReturn(null);
        caseQueryService.findGrantIssuedCasesWithGrantIssuedDate("invokingService", "2021-01-01");
    }
}
```


Overlapping Code:
```
ServiceTest {
private static final String[] LAST_MODIFIED = {"2018", "1", "1", "0", "0", "0", "0"};
@Mock
private RestTemplate restTemplate;
@Mock
private HttpHeadersFactory headers;
@Mock
private AppInsights appInsights;
@Mock
private CCDDataStoreAPIConfiguration ccdDataStoreAPIConfiguration;
@Mock
private IdamAuthenticateUserService idamAuthenticateUserService;
@Mock
private ServiceAuthTokenGenerator serviceAuthTokenGenerator;
@Mock
private FileSystemResourceService fileSystemResourceService;
@Captor
private ArgumentCaptor<HttpEntity<String>> entityCaptor;
@InjectMocks
private CaseQueryService caseQueryService;
@Before
public void setUp() {
MockitoAnnotations.initMocks(this);
when(serviceAuthTokenGenerator.generate()).thenReturn("Bearer 321");
when(idamAuthenticateUserService.getIdamOauth2Token()).thenReturn("Bearer 123");
when(headers.getAuthorizationHeaders()).thenReturn(new HttpHeaders());
when(ccdDataStoreAPIConfiguration.getHost()).thenReturn("http://localhost");
when(ccdDataStoreAPIConfiguration.getCaseMatchingPath()).thenReturn("/path");
CaseData caseData = CaseData.builder()
.deceasedSurname("Smith")
.build();
List<ReturnedCaseDetails> caseList =
new ImmutableList.Builder<ReturnedCaseDetails>().add(new ReturnedCaseDetails(caseData,
LAST_MODIFIED, 1L))
.build();
ReturnedCases returnedCases = new ReturnedCases(caseList, 1);
when(restTemplate.postForObject(any(), any(), any())).thenReturn(returnedCases);
}
@Test
public void findCasesWithDatedDocumentReturnsCaseList() {
List<ReturnedCaseDetails> cases =
caseQueryService.findGrantIssuedCasesWithGrantIssuedDate("invokingService", "2021-01-01");
assertEquals(1, cases.size());
assertThat(cases.get(0).getId(), is(1L));
assertEquals("Smith", cases.get(0).getData().getDeceasedSurname());
}
@Test
public void findAllCasesWithDatedDocumentReturnsCaseList() {
caseQueryService.dataExtractPaginationSize = 1;
List<ReturnedCaseDetails> cases = caseQueryService.findAllCasesWithGrantIssuedDate("invokingService",
"2021-01-01");
assertEquals(1, cases.size());
assertThat(cases.get(0).getId(), is(1L));
assertEquals("Smith", ca
```
<Overlap Ratio: 0.9859022556390977>

---

--- 257 --
Question ID: 9840e26fb17e826cc58f4dd6bf250109c9dfaf6b
Original Code:
```
public class ActivityFeedServlet extends HttpServlet{
  /** Store class that gives access to Conversations. */
  private ConversationStore conversationStore;

  /** Store class that gives access to Messages. */
  private MessageStore messageStore;

  /** Store class that gives access to Users. */
  private UserStore userStore;

  @Override
  public void init() throws ServletException{
    super.init();

    setMessageStore(MessageStore.getInstance());
    setUserStore(UserStore.getInstance());
    setConversationStore(ConversationStore.getInstance());
  }

  /**
   * Sets the UserStore used by this servlet. This function provides a common setup method for use
   * by the test framework or the servlet's init() function.
   */
  void setUserStore(UserStore userStore) {
    this.userStore = userStore;
  }

  /**
   * Sets the ConversationStore used by this servlet. This function provides a common setup method
   * for use by the test framework or the servlet's init() function.
   */
  void setConversationStore(ConversationStore conversationStore) {
    this.conversationStore = conversationStore;
  }

  /**
   * Sets the MessageStore used by this servlet. This function provides a common setup method for
   * use by the test framework or the servlet's init() function.
   */
  void setMessageStore(MessageStore messageStore) {
    this.messageStore = messageStore;
  }

  public static class DateFormatter {

    static final String FORMAT = "EEE MMM dd yyyy hh:mm:ss a z";
    static final String TIMEZONE = "PST";

    /**
     * Utility function to convert java Date to TimeZone format
     *
     * @param date date to be formatted
     */
    public static String formatDateToString(Date date) {
      // null check
      if (date == null) return null;
      // create SimpleDateFormat object with input format
      SimpleDateFormat sdf = new SimpleDateFormat(FORMAT);
      // set timezone to SimpleDateFormat
      sdf.setTimeZone(TimeZone.getTimeZone(TIMEZONE));
      // return Date in required format with timezone as String
      return sdf.format(date);
    }
  }


    /**
   * Subclass to combine activities together even if they are from different types.
   */
  public static class Item implements Comparable<Item>{
    Instant instant;
    UUID id;

    public Item(Message m){
      instant = m.getCreationTime();
      id = m.getId();
    }

    public Item(User u){
      instant = u.getCreationTime();
      id = u.getId();
    }

    public Item(Conversation c){
      instant = c.getCreationTime();
      id = c.getId();
    }

    @Override
    public int compareTo(Item item) {
      if (instant.compareTo(item.instant)>0) {
        return -1;
      } else if (instant.compareTo(item.instant)<0) {
        return 1;
      } else {
        return 0;
      }
    }

    public UUID getId() {
      return id;
    }
  }

  /**
   * This function fires when a user navigates to the activity feed page.
   * It then forwards to activityfeed.jsp for rendering.
   */
  @Override
  public void doGet(HttpServletRequest request, HttpServletResponse response)
      throws IOException, ServletException {

    PriorityQueue<Item> fringe = new PriorityQueue<>();
    Map<UUID, Object> ids = new HashMap<>();

    List<Conversation> conversations = conversationStore.getAllConversations();
    List<User> users = userStore.getUsers();
    List<Message> messages = messageStore.getMessages();

    for(Conversation c: conversations){
      fringe.add(new Item(c));
      ids.put(c.getId(),c);
    }

    for(User u: users){
      fringe.add(new Item(u));
      ids.put(u.getId(),u);
    }

    for(Message m: messages){
      fringe.add(new Item(m));
      ids.put(m.getId(),m);
    }

    request.setAttribute("FeedItems", fringe);
    request.setAttribute("ids", ids);
    request.getRequestDispatcher("/WEB-INF/view/activityfeed.jsp").forward(request, response);
  }
}
```


Overlapping Code:
```
public class ActivityFeedServlet extends HttpServlet{
/** Store class that gives access to Conversations. */
private ConversationStore conversationStore;
/** Store class that gives access to Messages. */
private MessageStore messageStore;
/** Store class that gives access to Users. */
private UserStore userStore;
@Override
public void init() throws ServletException{
super.init();
setMessageStore(MessageStore.getInstance());
setUserStore(UserStore.getInstance());
setConversationStore(ConversationStore.getInstance());
}
/**
* Sets the UserStore used by this servlet. This function provides a common setup method for use
* by the test framework or the servlet's init() function.
*/
void setUserStore(UserStore userStore) {
this.userStore = userStore;
}
/**
* Sets the ConversationStore used by this servlet. This function provides a common setup method
* for use by the test framework or the servlet's init() function.
*/
void setConversationStore(ConversationStore conversationStore) {
this.conversationStore = conversationStore;
}
/**
* Sets the MessageStore used by this servlet. This function provides a common setup method for
* use by the test framework or the servlet's init() function.
*/
void setMessageStore(MessageStore messageStore) {
this.messageStore = messageStore;
}
public static class DateFormatter {
static final String FORMAT = "EEE MMM dd yyyy hh:mm:ss a z";
static final String TIMEZONE = "PST";
/**
* Utility function to convert java Date to TimeZone format
*
* @param date date to be formatted
*/
public static String formatDateToString(Date date) {
// null check
if (date == null) return null;
// create SimpleDateFormat object with input format
SimpleDateFormat sdf = new SimpleDateFormat(FORMAT);
// set timezone to SimpleDateFormat
sdf.setTimeZone(TimeZone.getTimeZone(TIMEZONE));
// return Date in required format with timezone as String
return sdf.format(date);
}
}
/**
* Subclass to combine activities together even if they are from different types.
*/
public static class Item implements Comparable<Item>{
Instant instant;
UUID id;
public Item(Message m){
instant = m.getCreationTime();
id = m.getId();
}
public Item(User u){
instant = u.getCreationTime();
id = u.getId();

```
<Overlap Ratio: 0.9870362092087618>

---

--- 258 --
Question ID: 09d02d66b1f2c911e613968db7cdf65b9e0504ea
Original Code:
```
public class SecurityHeadersResponseFilter implements SecurityResponseFilter {

    @Override
    public void filter(DiscFilterResponse response, RequestView request) {
        response.setHeader("Cache-control", "no-store");
        response.setHeader("Pragma", "no-cache");
        response.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
        response.setHeader("X-Content-Type-Options", "nosniff");
    }
}
```


Overlapping Code:
```
public class SecurityHeadersResponseFilter implements SecurityResponseFilter {
@Override
public void filter(DiscFilterResponse response, RequestView request) {
response.setHeader("Cache-control", "no-store");
response.setHeader("Pragma", "no-cache");
response.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
response.setHeader("X-Content-Type-Options", "nosniff");
}

```
<Overlap Ratio: 0.9974937343358395>

---

--- 259 --
Question ID: a2ca575501639c8c26ae2c4ef665ad8675ab6df4
Original Code:
```
public class FormDataFileTableGenerator extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		response.setContentType("text/html");
		
		ServletContext context = request.getServletContext();
		final String INPUT_FILE_PATH =  context.getRealPath("/") + "output.txt";
		
		StringBuilder pageHTML = new StringBuilder(
			"<!DOCTYPE html>" +
			"<html>"+
			"<body>" +
				"<table border='1'>"
		);
		
		// Read from input file & add to page HTML
		BufferedReader bufferedReader = new BufferedReader(new FileReader(INPUT_FILE_PATH));
		String line = "";
		while ((line = bufferedReader.readLine()) != null) {
			pageHTML.append(
					"<tr><td>" + line + "</td></td>"	
			);
		}
		bufferedReader.close();
		
		pageHTML.append(
				"</table>" +
			"</body>" +
			"</html>");
		
		PrintWriter output = response.getWriter();
		output.print(pageHTML);
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
	}

}
```


Overlapping Code:
```
nerator extends HttpServlet {
private static final long serialVersionUID = 1L;
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
response.setContentType("text/html");

ServletContext context = request.getServletContext();
final String INPUT_FILE_PATH = context.getRealPath("/") + "output.txt";

StringBuilder pageHTML = new StringBuilder(
"<!DOCTYPE html>" +
"<html>"+
"<body>" +
"<table border='1'>"
);

// Read from input file & add to page HTML
BufferedReader bufferedReader = new BufferedReader(new FileReader(INPUT_FILE_PATH));
String line = "";
while ((line = bufferedReader.readLine()) != null) {
pageHTML.append(
"<tr><td>" + line + "</td></td>" 
);
}
bufferedReader.close();

pageHTML.append(
"</table>" +
"</body>" +
"</html>");

PrintWriter output = response.getWriter();
output.print(pageHTML);
}
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
// TODO Auto-generated method stub
}
}
```
<Overlap Ratio: 0.9699812382739212>

---

--- 260 --
Question ID: 0fdf7a1862ae973464c4f5efa105e754538dda10
Original Code:
```
class EnsnaringBridgeRestrictionEffect extends RestrictionEffect {

    public EnsnaringBridgeRestrictionEffect() {
        super(Duration.WhileOnBattlefield);
        this.staticText = "Creatures with power greater than the number of cards in your hand can't attack";
    }

    public EnsnaringBridgeRestrictionEffect(final EnsnaringBridgeRestrictionEffect effect) {
        super(effect);
    }

    @Override
    public boolean applies(Permanent permanent, Ability source, Game game) {
        Player controller = game.getPlayer(source.getControllerId());
        if (controller == null) {
            return false;
        }
        return controller.getInRange().contains(permanent.getControllerId())
                && permanent.getPower().getValue() > controller.getHand().size();
    }

    @Override
    public boolean canAttack(Game game) {
        return false;
    }

    @Override
    public EnsnaringBridgeRestrictionEffect copy() {
        return new EnsnaringBridgeRestrictionEffect(this);
    }

}
```


Overlapping Code:
```
estrictionEffect extends RestrictionEffect {
public EnsnaringBridgeRestrictionEffect() {
super(Duration.WhileOnBattlefield);
this.staticText = "Creatures with power greater than the number of cards in your hand can't attack";
}
public EnsnaringBridgeRestrictionEffect(final EnsnaringBridgeRestrictionEffect effect) {
super(effect);
}
@Override
public boolean applies(Permanent permanent, Ability source, Game game) {
Player controller = game.getPlayer(source.getControllerId());
if (controller == null) {
return false;
}
return controller.getInRange().contains(permanent.getControllerId())
&& permanent.getPower().getValue() > controller.getHand().size();
}
@Override
public boolean canAttack(Game game) {
return false;
}
@Override
public EnsnaringBridgeRestrictionEffect copy() {
return new EnsnaringBridgeRestrictionEff
```
<Overlap Ratio: 0.9579929988331388>

---

--- 261 --
Question ID: 63ffa144487f89d12fdecd5130e960448060408c
Original Code:
```
public class Calculator {
	
	
	
	
	public static int add(int ... x) { // vararg syntax
		int sum=0;
		for(int i=0;i<x.length;i++) {
			sum=sum+x[i];
		}
		return sum; 
		
	}
	

public static float add(float x, float y) {
	return x+y;
}



public static float add(float x, int y) {

	return x+y;
}
public static float add(int x, float y) {
	return x+y;
}

public float multiply(float x,float y) {
	return x*y;
}
}
```


Overlapping Code:
```
blic static int add(int ... x) { // vararg syntax
int sum=0;
for(int i=0;i<x.length;i++) {
sum=sum+x[i];
}
return sum; 

}

public static float add(float x, float y) {
return x+y;
}
public static float add(float x, int y) {
return x+y;
}
public static float add(int x, float y) {
return x+y;
}
public float multiply(float x,float y) {
return x*y;
}
}
```
<Overlap Ratio: 0.9162303664921466>

---

--- 262 --
Question ID: f225f0513742ccfa077692d83b378c82e9f48bbd
Original Code:
```
@RunWith(Parameterized.class)
public class CCROneHourTest {
    private static final int timeLimit = 10000;

    private static Engine engine = new Engine();

    @Parameterized.Parameters(name = "{index} Test: {1}")
    public static Collection<Object[]> data() {
        List<Object[]> answers = new ArrayList<>();

        for (int i = 0; i < splitUpBKs.length; i++) {
            String pos = splitUpBKs[i];
            Object[] objectAndName = new Object[2];
            ExtendedPositionDescriptionParser.EPDObject EPDObject = ExtendedPositionDescriptionParser.parseEDPPosition(pos);
            objectAndName[0] = EPDObject;
            objectAndName[1] = EPDObject.getId();
            answers.add(objectAndName);
        }
        return answers;
    }

    private static ExtendedPositionDescriptionParser.EPDObject EPDObject;

    public CCROneHourTest(Object edp, Object name) {
        EPDObject = (ExtendedPositionDescriptionParser.EPDObject) edp;
    }

    @Test
    public void test() {
        Engine.resetFull();
        System.out.println(EPDObject.getFullString());
        int[] winningMoves = EPDObject.getBestMoves();
        int[] losingMoves = EPDObject.getAvoidMoves();
        EngineSpecifications.PRINT_PV = false;
                
        SearchSpecs.basicTimeSearch(timeLimit);
        final int move = engine.simpleSearch(EPDObject.getBoard());

        Assert.assertTrue(contains(winningMoves, move) && !contains(losingMoves, move));
    }

    private static final String bkTests = "" +
            "rn1qkb1r/pp2pppp/5n2/3p1b2/3P4/2N1P3/PP3PPP/R1BQKBNR w KQkq - 0 1 id \"CCR01\"; bm Qb3;\n" +
            "rn1qkb1r/pp2pppp/5n2/3p1b2/3P4/1QN1P3/PP3PPP/R1B1KBNR b KQkq - 1 1 id \"CCR02\";bm Bc8;\n" +
            "r1bqk2r/ppp2ppp/2n5/4P3/2Bp2n1/5N1P/PP1N1PP1/R2Q1RK1 b kq - 1 10 id \"CCR03\"; bm Nh6; am Ne5;\n" +
            "r1bqrnk1/pp2bp1p/2p2np1/3p2B1/3P4/2NBPN2/PPQ2PPP/1R3RK1 w - - 1 12 id \"CCR04\"; bm b4;\n" +
            "rnbqkb1r/ppp1pppp/5n2/8/3PP3/2N5/PP3PPP/R1BQKBNR b KQkq - 3 5 id \"CCR05\"; bm e5; \n" +
            "rnbq1rk1/pppp1ppp/4pn2/8/1bPP4/P1N5/1PQ1PPPP/R1B1KBNR b KQ - 1 5 id \"CCR06\"; bm Bcx3+;\n" +
            "r4rk1/3nppbp/bq1p1np1/2pP4/8/2N2NPP/PP2PPB1/R1BQR1K1 b - - 1 12 id \"CCR07\"; bm Rfb8;\n" +
            "rn1qkb1r/pb1p1ppp/1p2pn2/2p5/2PP4/5NP1/PP2PPBP/RNBQK2R w KQkq c6 1 6 id \"CCR08\"; bm d5;\n" +
            "r1bq1rk1/1pp2pbp/p1np1np1/3Pp3/2P1P3/2N1BP2/PP4PP/R1NQKB1R b KQ - 1 9 id \"CCR09\"; bm Nd4;\n" +
            "rnbqr1k1/1p3pbp/p2p1np1/2pP4/4P3/2N5/PP1NBPPP/R1BQ1RK1 w - - 1 11 id \"CCR10\"; bm a4;\n" +
            "rnbqkb1r/pppp1ppp/5n2/4p3/4PP2/2N5/PPPP2PP/R1BQKBNR b KQkq f3 1 3 id \"CCR11\"; bm d5;\n" +
            "r1bqk1nr/pppnbppp/3p4/8/2BNP3/8/PPP2PPP/RNBQK2R w KQkq - 2 6 id \"CCR12\"; bm Bxf7+;\n" +
            "rnbq1b1r/ppp2kpp/3p1n2/8/3PP3/8/PPP2PPP/RNBQKB1R b KQ d3 1 5 id \"CCR13\"; am Ne4; \n" +
            "rnbqkb1r/pppp1ppp/3n4/8/2BQ4/5N2/PPP2PPP/RNB2RK1 b kq - 1 6 id \"CCR14\"; am Nxc4;\n" +
            "r2q1rk1/2p1bppp/p2p1n2/1p2P3/4P1b1/1nP1BN2/PP3PPP/RN1QR1K1 w - - 1 12 id \"CCR15\"; bm exf6;\n" +
            "r1bqkb1r/2pp1ppp/p1n5/1p2p3/3Pn3/1B3N2/PPP2PPP/RNBQ1RK1 b kq - 2 7 id \"CCR16\"; bm d5;\n" +
            "r2qkbnr/2p2pp1/p1pp4/4p2p/4P1b1/5N1P/PPPP1PP1/RNBQ1RK1 w kq - 1 8 id \"CCR17\"; am hxg4;\n" +
            "r1bqkb1r/pp3ppp/2np1n2/4p1B1/3NP3/2N5/PPP2PPP/R2QKB1R w KQkq e6 1 7 id \"CCR18\"; bm Bxf6+;\n" +
            "rn1qk2r/1b2bppp/p2ppn2/1p6/3NP3/1BN5/PPP2PPP/R1BQR1K1 w kq - 5 10 id \"CCR19\"; am Bxe6;\n" +
            "r1b1kb1r/1pqpnppp/p1n1p3/8/3NP3/2N1B3/PPP1BPPP/R2QK2R w KQkq - 3 8 id \"CCR20\"; am Ndb5;\n" +
            "r1bqnr2/pp1ppkbp/4N1p1/n3P3/8/2N1B3/PPP2PPP/R2QK2R b KQ - 2 11 id \"CCR21\"; am Kxe6;\n" +
            "r3kb1r/pp1n1ppp/1q2p3/n2p4/3P1Bb1/2PB1N2/PPQ2PPP/RN2K2R w KQkq - 3 11 id \"CCR22\"; bm a4;\n" +
            "r1bq1rk1/pppnnppp/4p3/3pP3/1b1P4/2NB3N/PPP2PPP/R1BQK2R w KQ - 3 7 id \"CCR23\"; bm Bxh7+;\n" +
            "r2qkbnr/ppp1pp1p/3p2p1/3Pn3/4P1b1/2N2N2/PPP2PPP/R1BQKB1R w KQkq - 2 6 id \"CCR24\"; bm Nxe5;\n" +
            "rn2kb1r/pp2pppp/1qP2n2/8/6b1/1Q6/PP1PPPBP/RNB1K1NR b KQkq - 1 6 id \"CCR25\"; am Qxb3;" +
            "";

    private static final String[] splitUpBKs = bkTests.split("\n");
}
```


Overlapping Code:
```
OneHourTest {
private static final int timeLimit = 10000;
private static Engine engine = new Engine();
@Parameterized.Parameters(name = "{index} Test: {1}")
public static Collection<Object[]> data() {
List<Object[]> answers = new ArrayList<>();
for (int i = 0; i < splitUpBKs.length; i++) {
String pos = splitUpBKs[i];
Object[] objectAndName = new Object[2];
ExtendedPositionDescriptionParser.EPDObject EPDObject = ExtendedPositionDescriptionParser.parseEDPPosition(pos);
objectAndName[0] = EPDObject;
objectAndName[1] = EPDObject.getId();
answers.add(objectAndName);
}
return answers;
}
private static ExtendedPositionDescriptionParser.EPDObject EPDObject;
public CCROneHourTest(Object edp, Object name) {
EPDObject = (ExtendedPositionDescriptionParser.EPDObject) edp;
}
@Test
public void test() {
Engine.resetFull();
System.out.println(EPDObject.getFullString());
int[] winningMoves = EPDObject.getBestMoves();
int[] losingMoves = EPDObject.getAvoidMoves();
EngineSpecifications.PRINT_PV = false;

SearchSpecs.basicTimeSearch(timeLimit);
final int move = engine.simpleSearch(EPDObject.getBoard());
Assert.assertTrue(contains(winningMoves, move) && !contains(losingMoves, move));
}
private static final String bkTests = "" +
"rn1qkb1r/pp2pppp/5n2/3p1b2/3P4/2N1P3/PP3PPP/R1BQKBNR w KQkq - 0 1 id \"CCR01\"; bm Qb3;\n" +
"rn1qkb1r/pp2pppp/5n2/3p1b2/3P4/1QN1P3/PP3PPP/R1B1KBNR b KQkq - 1 1 id \"CCR02\";bm Bc8;\n" +
"r1bqk2r/ppp2ppp/2n5/4P3/2Bp2n1/5N1P/PP1N1PP1/R2Q1RK1 b kq - 1 10 id \"CCR03\"; bm Nh6; am Ne5;\n" +
"r1bqrnk1/pp2bp1p/2p2np1/3p2B1/3P4/2NBPN2/PPQ2PPP/1R3RK1 w - - 1 12 id \"CCR04\"; bm b4;\n" +
"rnbqkb1r/ppp1pppp/5n2/8/3PP3/2N5/PP3PPP/R1BQKBNR b KQkq - 3 5 id \"CCR05\"; bm e5; \n" +
"rnbq1rk1/pppp1ppp/4pn2/8/1bPP4/P1N5/1PQ1PPPP/R1B1KBNR b KQ - 1 5 id \"CCR06\"; bm Bcx3+;\n" +
"r4rk1/3nppbp/bq1p1np1/2pP4/8/2N2NPP/PP2PPB1/R1BQR1K1 b - - 1 12 id \"CCR07\"; bm Rfb8;\n" +
"rn1qkb1r/pb1p1ppp/1p2pn2/2p5/2PP4/5NP1/PP2PPBP/RNBQK2R w KQkq c6 1 6 id \"CCR08\"; bm d5;\n" +
"r1bq1rk1/1pp2pbp/p1np1np1/3Pp3/2P1P3/2N1BP2/PP4PP/R1NQKB1R b KQ - 
```
<Overlap Ratio: 0.9619896762083529>

---

--- 263 --
Question ID: 8645fe0ceb9db2e3926ef11d399dddb1a7ba11ba
Original Code:
```
public class Medias_array {
    //Local Variables
    private static String name;
    private static String topic;
    
    //Object Variables
    static ArrayList<Double> vector = new ArrayList();
    static ArrayList<Storage> vectorMedia = new ArrayList();
    static Scanner keyboard = new Scanner(System.in);
    
    //Constructor
    public Medias_array() {
    }
    
    //Program: main csll
    public static void main(String[] args) {
        
        do {// Loop do...while - Name checking
            
            System.out.println("Introduce tu nombre - Tecla q para salir");
            name = keyboard.next(); //Variable name = User Name
            
            
            if (!name.equals("q")) { // Conditional if - Depending name.
                do { //True branch - name!=q
                    topic = Int_mat.int_mat(); // Int_mat.java calling - 
                    if (!name.equals("q") || !topic.equals("q")) {
                        //max_mat= Int_cant.int_cant();
                        Int_data.int_notas(vector,topic,vectorMedia,name);
                        vector.clear();
                    } else { // False branch - name=q
                        break;
                    }
                } while (!topic.equals("q")); //End - Subject checking
            }
            
            
            
        } while (!name.equals("q")); // End - Name checking
        
        //For each loop - Memory Writing - Nombre,Materia,Nota media de materia
        for (Storage a:vectorMedia) {
            System.out.println(a.getUser() + "\t\t" + a.getMateria() + "\t\t" + a.getNotamedia());
        }
        
        
        
        //ArrayList<Double> vector = new ArrayList();
        
        
        
    
    }
    
    /*public static void int_notas (ArrayList<Double> list, String materia) {
            
            //double mark;
            //int cont=1;
            //double media=0;
            
            System.out.println("\nIntroducción de notas. Número negativo para salir\n");
            do {
                
                System.out.println("\tIntroducce la nota " + cont + " de la materia " + materia);
                mark=keyboard.nextDouble();
                if (mark>=0) {
                    list.add(mark);
                }
                cont++;
            } while (mark>=0);
//            list.forEach((a) -> {
            for ( Double a:list ) {
                media+=a;
            }
            media/=list.size(); // media=media/list.size();
            System.out.println("\nMedia de " + materia + ": " + df.format(media));
    }*/

    //Función que devuelve la cantidad de materias
    /*public static int int_cant() {
        //int cant;
        
        System.out.println("Introduce la cantidad de materias de las que quieres obtener la media: ");
        cant = keyboard.nextInt();
        return cant;
    }*/
    
    //Función que devuelve el nombre de la materia
    /*public static String int_mat() {
        //String mat;
        
        System.out.println("Introduce la materia de la que quieres obtener la media: ");
        mat = keyboard.next();
        return mat;
    }*/
    
}
```


Overlapping Code:
```
cal Variables
private static String name;
private static String topic;

//Object Variables
static ArrayList<Double> vector = new ArrayList();
static ArrayList<Storage> vectorMedia = new ArrayList();
static Scanner keyboard = new Scanner(System.in);

//Constructor
public Medias_array() {
}

//Program: main csll
public static void main(String[] args) {

do {// Loop do...while - Name checking

System.out.println("Introduce tu nombre - Tecla q para salir");
name = keyboard.next(); //Variable name = User Name


if (!name.equals("q")) { // Conditional if - Depending name.
do { //True branch - name!=q
topic = Int_mat.int_mat(); // Int_mat.java calling - 
if (!name.equals("q") || !topic.equals("q")) {
//max_mat= Int_cant.int_cant();
Int_data.int_notas(vector,topic,vectorMedia,name);
vector.clear();
} else { // False branch - name=q
break;
}
} while (!topic.equals("q")); //End - Subject checking
}



} while (!name.equals("q")); // End - Name checking

//For each loop - Memory Writing - Nombre,Materia,Nota media de materia
for (Storage a:vectorMedia) {
System.out.println(a.getUser() + "\t\t" + a.getMateria() + "\t\t" + a.getNotamedia());
}



//ArrayList<Double> vector = new ArrayList();




}

/*public static void int_notas (ArrayList<Double> list, String materia) {

//double mark;
//int cont=1;
//double media=0;

System.out.println("\nIntroducción de notas. Número negativo para salir\n");
do {

System.out.println("\tIntroducce la nota " + cont + " de la materia " + materia);
mark=keyboard.nextDouble();
if (mark>=0) {
list.add(mark);
}
cont++;
} while (mark>=0);
// list.forEach((a)
```
<Overlap Ratio: 0.963275135460566>

---

--- 264 --
Question ID: 1c0bcc355406afb384b2590e49134412df890d11
Original Code:
```
public class ReplicationTest {
    @Rule
    public final TestRule   testLog = TestHelper.testLog;

    OSD[]                   osds;
    OSDConfig[]             configs;
    OSDServiceClient        client;

    private Capability      cap;
    private String          fileID;
    private XLocations      xLoc;

    // needed for dummy classes
    private int             stripeSize;
    private ReusableBuffer  data;

    private long            objectNo;
    private TestEnvironment testEnv;

    @BeforeClass
    public static void initializeTest() throws Exception {
        Logging.start(SetupUtils.DEBUG_LEVEL, SetupUtils.DEBUG_CATEGORIES);
    }

    /**
     * @throws java.lang.Exception
     */
    @Before
    public void setUp() throws Exception {
        this.stripeSize = 128 * 1024; // byte
        this.data = SetupUtils.generateData(stripeSize);

        // startup: DIR
        testEnv = new TestEnvironment(new TestEnvironment.Services[] { TestEnvironment.Services.DIR_SERVICE,
                TestEnvironment.Services.TIME_SYNC, TestEnvironment.Services.UUID_RESOLVER,
                TestEnvironment.Services.OSD_CLIENT });
        testEnv.start();

        osds = new OSD[12];
        configs = SetupUtils.createMultipleOSDConfigs(12);
        for (int i = 0; i < osds.length; i++) {
            osds[i] = new OSD(configs[i]);
        }

        client = testEnv.getOSDClient();

        fileID = "1:1";
        objectNo = 0;
        cap = new Capability(fileID, SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber(), 60,
                System.currentTimeMillis(), "", 0, false, SnapConfig.SNAP_CONFIG_SNAPS_DISABLED, 0,
                configs[0].getCapabilitySecret());

        xLoc = createLocations(4, 3);
    }

    private XLocations createLocations(int numberOfReplicas, int numberOfStripedOSDs) throws InvalidXLocationsException {
        assert (numberOfReplicas * numberOfStripedOSDs <= osds.length);

        List<Replica> rlist = new LinkedList();
        for (int replica = 0; replica < numberOfReplicas; replica++) {
            List<String> osdset = new LinkedList();
            int startOSD = replica * numberOfStripedOSDs;
            for (int stripe = 0; stripe < numberOfStripedOSDs; stripe++) {
                // add available osds
                osdset.add(configs[startOSD + stripe].getUUID().toString());
            }

            Replica r = Replica.newBuilder()
                    .setStripingPolicy(SetupUtils.getStripingPolicy(osdset.size(), stripeSize / 1024))
                    .setReplicationFlags(0).addAllOsdUuids(osdset).build();
            rlist.add(r);
        }
        XLocSet locSet = XLocSet.newBuilder().setReadOnlyFileSize(0)
                .setReplicaUpdatePolicy(ReplicaUpdatePolicies.REPL_UPDATE_PC_NONE).setVersion(1).addAllReplicas(rlist)
                .build();
        // set the first replica as current replica

        // set the first replica as current replica
        XLocations locations = new XLocations(locSet, new ServiceUUID(locSet.getReplicas(0).getOsdUuids(0)));
        return locations;
    }

    private void setReplicated(long filesize, int indexOfFullReplica) throws Exception {
        // set replication flags

        List<Replica> rlist = new LinkedList();

        for (int i = 0; i < xLoc.getXLocSet().getReplicasCount(); i++) {
            Replica r = xLoc.getXLocSet().getReplicas(i);
            if (i == indexOfFullReplica)
                rlist.add(r
                        .toBuilder()
                        .setReplicationFlags(
                                ReplicationFlags.setReplicaIsComplete(ReplicationFlags
                                        .setPartialReplica(ReplicationFlags.setRandomStrategy(0)))).build());
            else
                rlist.add(r.toBuilder()
                        .setReplicationFlags(ReplicationFlags.setPartialReplica(ReplicationFlags.setRandomStrategy(0)))
                        .build());
        }

        XLocSet locSet = xLoc.getXLocSet().toBuilder().clearReplicas().addAllReplicas(rlist)
                .setReplicaUpdatePolicy(ReplicaUpdatePolicies.REPL_UPDATE_PC_RONLY).setReadOnlyFileSize(filesize)
                .build();

        xLoc = new XLocations(locSet, new ServiceUUID(locSet.getReplicas(0).getOsdUuids(0)));

    }

    /**
     * @throws java.lang.Exception
     */
    @After
    public void tearDown() throws Exception {
        for (OSD osd : this.osds)
            osd.shutdown();

        testEnv.shutdown();

        // free buffers
        BufferPool.free(data);
    }

    /*
     * private ObjectData getObjectData(ReusableBuffer data) { return new ObjectData(0, false, 0,
     * data.createViewBuffer()); }
     */

    @Test
    public void testStriped() throws Exception {
        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();

        // write object to replica 3
        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)
                .build();
        RPCResponse<OSDWriteResponse> w = client.write(xLoc.getOSDsForObject(objectNo).get(2).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,
                data.createViewBuffer());
        OSDWriteResponse wResp = w.get();
        w.freeBuffers();

        // change XLoc
        setReplicated(data.limit(), 2);
        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();

        // read object from replica 3 (object exists on this OSD) => normal read
        RPCResponse<ObjectData> r = client.read(xLoc.getOSDsForObject(objectNo).get(2).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);
        ObjectData rResp = r.get();
        assertTrue(Arrays.equals(data.array(), r.getData().array()));
        r.freeBuffers();

        // read object from replica 2 (object not exists on this OSD) => replication
        r = client.read(xLoc.getOSDsForObject(objectNo).get(1).getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);
        rResp = r.get();
        if (data.capacity() > 0) {
            assertNotNull(r.getData());
            assertTrue(Arrays.equals(data.array(), r.getData().array()));
        } else
            assertNull(r.getData());
        r.freeBuffers();

        // read object from replica 4 (object not exists on this OSD) => replication
        r = client.read(xLoc.getOSDsForObject(objectNo).get(3).getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);
        rResp = r.get();
        if (data.capacity() > 0)
            assertTrue(Arrays.equals(data.array(), r.getData().array()));
        else
            assertNull(r.getData());
        r.freeBuffers();

        // read part of object from replica 1 (object not exists on this OSD) => replication
        r = client.read(xLoc.getOSDsForObject(objectNo).get(0).getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo, 0, stripeSize / 4, stripeSize / 4);
        rResp = r.get();
        int j = stripeSize / 4;
        byte[] responseData = r.getData().array();
        byte[] dataBytes = data.array();
        for (int i = 0; i < responseData.length; i++) {
            assertEquals(dataBytes[j++], responseData[i]);
        }
        r.freeBuffers();

    }

    @Test
    public void testHoleAndEOF() throws Exception {
        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();

        // write object 1 to replica 1 => full object
        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)
                .build();
        RPCResponse<OSDWriteResponse> w = client.write(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,
                data.createViewBuffer());
        OSDWriteResponse wResp = w.get();
        w.freeBuffers();

        // object 2 is a hole

        ReusableBuffer data2 = SetupUtils.generateData(stripeSize / 2);
        // write half object 3 to replica 1 with offset => half object, HOLE
        w = client.write(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, stripeSize / 4, 0, objdata,
                data2.createViewBuffer());
        wResp = w.get();
        w.freeBuffers();

        // write half object 4 to replica 1 => half object, EOF
        w = client.write(xLoc.getOSDsForObject(objectNo + 3).get(0).getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo + 3, 0, 0, 0, objdata, data2.createViewBuffer());
        wResp = w.get();
        w.freeBuffers();

        // change XLoc (filesize)
        setReplicated(stripeSize * 3 + data2.limit(), 0);
        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();

        // read object from replica 2
        RPCResponse<ObjectData> r = client.read(xLoc.getOSDsForObject(objectNo).get(1).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);
        ObjectData rResp = r.get();
        if (data.capacity() > 0)
            assertTrue(Arrays.equals(data.array(), r.getData().array()));
        else
            assertNull(r.getData());
        r.freeBuffers();

        // read hole from replica 2
        r = client.read(xLoc.getOSDsForObject(objectNo + 1).get(1).getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo + 1, 0, 0, stripeSize);
        rResp = r.get();
        // filled with zeros
        if (rResp.getZeroPadding() == 0) {
            for (byte b : r.getData().array()) {
                assertEquals(0, b);
            }
        }
        r.freeBuffers();

        // check whether a padding object for object 2 has been created on
        // replica 2
        RPCResponse<InternalReadLocalResponse> intRLRsp = client.xtreemfs_internal_read_local(
                xLoc.getOSDsForObject(objectNo + 1).get(1).getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo + 1, 0, 0, stripeSize, false, new ArrayList());
        InternalReadLocalResponse intRL = intRLRsp.get();
        assertEquals(stripeSize, intRL.getData().getZeroPadding());

        // read EOF from replica 2
        r = client.read(xLoc.getOSDsForObject(objectNo + 4).get(1).getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo + 4, 0, 0, stripeSize);
        rResp = r.get();
        assertNull(r.getData());
        r.freeBuffers();

        // read hole within an object from replica 2
        r = client.read(xLoc.getOSDsForObject(objectNo + 2).get(1).getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, 0, stripeSize);
        rResp = r.get();
        byte[] responseData = r.getData().array();
        // correct length
        assertEquals(stripeSize / 4 + data2.limit(), responseData.length);
        // first quarter filled with zeros
        for (int i = 0; i < stripeSize / 4; i++) {
            assertEquals((byte) 0, responseData[i]);
        }
        int j = 0;
        // then there is the data
        byte[] data2bytes = data2.array();
        for (int i = stripeSize / 4; i < (stripeSize / 4) * 3; i++) {
            assertEquals(data2bytes[j++], responseData[i]);
        }
        // last quarter filled with zeros again
        assertEquals(stripeSize / 4, rResp.getZeroPadding());
        r.freeBuffers();

        // read EOF within data from replica 2
        r = client.read(xLoc.getOSDsForObject(objectNo + 3).get(1).getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo + 3, 0, 0, stripeSize);
        rResp = r.get();
        assertTrue(Arrays.equals(data2.array(), r.getData().array()));
        r.freeBuffers();

        // read hole within an object from replica 2 with offset and length
        r = client.read(xLoc.getOSDsForObject(objectNo + 2).get(2).getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, stripeSize / 4, data2.limit());
        rResp = r.get();
        // correct length and data
        assertEquals(data2.limit(), r.getData().array().length);
        assertTrue(Arrays.equals(data2.array(), r.getData().array()));
        r.freeBuffers();

        // free buffers
        BufferPool.free(data2);
    }

    /*
     * following tests are testing readLocal-RPC
     */
    /**
     * striped case
     */
    @Test
    public void testObjectLocalAvailable() throws Exception {
        // Default case.
        helperObjectLocalAvailable();
    }

    public void helperObjectLocalAvailable() throws Exception {
        ServiceUUID serverID = xLoc.getOSDsForObject(objectNo).get(0);
        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();

        // write data
        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)
                .build();
        RPCResponse<OSDWriteResponse> r = client.write(serverID.getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata, this.data.createViewBuffer());
        OSDWriteResponse resp = r.get();
        r.freeBuffers();

        // change XLoc
        setReplicated(this.data.limit(), 0);
        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();

        // read data
        RPCResponse<InternalReadLocalResponse> r2 = client.xtreemfs_internal_read_local(serverID.getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize,
                false, new ArrayList());
        InternalReadLocalResponse resp2 = r2.get();

        assertTrue(Arrays.equals(data.array(), r2.getData().array()));
        assertEquals(0, resp2.getObjectSetCount());

        r2.freeBuffers();

        // read only part of data
        r2 = client.xtreemfs_internal_read_local(serverID.getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo, 0, stripeSize / 4, stripeSize / 2, true,
                new ArrayList());
        resp2 = r2.get();

        int j = stripeSize / 4;
        byte[] responseData = r2.getData().array();
        byte[] dataBytes = data.array();
        assertEquals(stripeSize / 2, responseData.length);
        for (int i = 0; i < responseData.length; i++) {
            assertEquals(dataBytes[j++], responseData[i]);
        }
        assertEquals(1, resp2.getObjectSetCount());

        // check object list
        ObjectList objectList = resp2.getObjectSet(0);
        ObjectSet list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet()
                .toByteArray());
        assertNotNull(list);
        assertEquals(1, list.size());
        assertTrue(list.contains(objectNo));

        r2.freeBuffers();
    }

    /**
     * striped case
     */
    @Test
    public void testObjectLocalNOTAvailable() throws Exception {
        helperObjectLocalNOTAvailable();
    }

    public void helperObjectLocalNOTAvailable() throws Exception {
        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();

        // read object, before one has been written
        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)
                .build();
        RPCResponse<InternalReadLocalResponse> r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo)
                .get(0).getAddress(), RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo,
                0, 0, stripeSize, true, new ArrayList());
        InternalReadLocalResponse resp = r.get();
        assertNull(r.getData());
        assertEquals(1, resp.getObjectSetCount());
        ObjectSet list = new ObjectSet(resp.getObjectSet(0).getStripeWidth(), resp.getObjectSet(0).getFirst(), resp
                .getObjectSet(0).getSet().toByteArray());
        assertEquals(0, list.size());
        r.freeBuffers();

        // write data
        RPCResponse<OSDWriteResponse> r2 = client.write(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,
                this.data.createViewBuffer());
        OSDWriteResponse resp2 = r2.get();
        r2.freeBuffers();
        r2 = client
                .write(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(), RPCAuthentication.authNone,
                        RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, 0, 0, objdata,
                        this.data.createViewBuffer());
        resp2 = r2.get();
        r2.freeBuffers();

        // change XLoc
        setReplicated(data.limit() * 2, 0);
        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();

        // read data
        r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize,
                false, new ArrayList());
        resp = r.get();
        assertTrue(Arrays.equals(data.array(), r.getData().array()));
        r.freeBuffers();
        r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, 0, stripeSize,
                false, new ArrayList());
        resp = r.get();
        assertTrue(Arrays.equals(data.array(), r.getData().array()));
        r.freeBuffers();

        // read higher object than has been written (EOF)
        r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo + 3).get(0).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo + 3, 0, 0, stripeSize,
                false, new ArrayList());
        resp = r.get();
        assertNull(r.getData());
        r.freeBuffers();

        // read object that has not been written (hole)
        r = client.xtreemfs_internal_read_local(xLoc.getOSDsForObject(objectNo + 1).get(0).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo + 1, 0, 0, stripeSize,
                false, new ArrayList());
        resp = r.get();
        assertNull(r.getData());
        r.freeBuffers();
    }

    @Test
    public void testObjectLocalAvailableNONStriped() throws Exception {
        this.xLoc = createLocations(2, 1);
        // reuse test
        helperObjectLocalAvailable();
    }

    @Test
    public void testObjectLocalNOTAvailableNONStriped() throws Exception {
        this.xLoc = createLocations(2, 1);
        // reuse test
        helperObjectLocalNOTAvailable();
    }

    @Test
    public void testGetObjectList() throws Exception {
        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLoc.getXLocSet()).build();
        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)
                .build();

        // read data
        RPCResponse<ObjectList> r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo).get(0)
                .getAddress(), RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);
        ObjectList objectList = r.get();
        r.freeBuffers();
        ObjectSet list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet()
                .toByteArray());
        assertEquals(0, list.size());

        // write object to replica 1 : OSD 1
        RPCResponse<OSDWriteResponse> w = client.write(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,
                this.data.createViewBuffer());
        OSDWriteResponse wResp = w.get();
        w.freeBuffers();

        // read data
        r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);
        objectList = r.get();
        r.freeBuffers();
        list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet().toByteArray());
        assertEquals(1, list.size());
        assertTrue(list.contains(objectNo));

        // write object to replica 1 : OSD 2
        w = client
                .write(xLoc.getOSDsForObject(objectNo + 1).get(0).getAddress(), RPCAuthentication.authNone,
                        RPCAuthentication.userService, fc, fileID, objectNo + 1, 0, 0, 0, objdata,
                        this.data.createViewBuffer());
        wResp = w.get();
        w.freeBuffers();

        // write object to replica 1 : OSD 3
        w = client
                .write(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(), RPCAuthentication.authNone,
                        RPCAuthentication.userService, fc, fileID, objectNo + 2, 0, 0, 0, objdata,
                        this.data.createViewBuffer());
        wResp = w.get();
        w.freeBuffers();

        // write object to replica 1 : OSD 1
        w = client
                .write(xLoc.getOSDsForObject(objectNo + 3).get(0).getAddress(), RPCAuthentication.authNone,
                        RPCAuthentication.userService, fc, fileID, objectNo + 3, 0, 0, 0, objdata,
                        this.data.createViewBuffer());
        wResp = w.get();
        w.freeBuffers();

        // read object list from OSD 1 : OSD 1
        r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);
        objectList = r.get();
        r.freeBuffers();
        list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet().toByteArray());
        assertEquals(2, list.size());
        assertTrue(list.contains(objectNo));
        assertTrue(list.contains(objectNo + 3));

        // read object list from OSD 1 : OSD 2
        r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo + 1).get(0).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);
        objectList = r.get();
        r.freeBuffers();
        list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet().toByteArray());
        assertEquals(1, list.size());
        assertTrue(list.contains(objectNo + 1));

        // read object list from OSD 1 : OSD 3
        r = client.xtreemfs_internal_get_object_set(xLoc.getOSDsForObject(objectNo + 2).get(0).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID);
        objectList = r.get();
        r.freeBuffers();
        list = new ObjectSet(objectList.getStripeWidth(), objectList.getFirst(), objectList.getSet().toByteArray());
        assertEquals(1, list.size());
        assertTrue(list.contains(objectNo + 2));
    }

    @Test
    public void testOutdatedView() throws Exception {
        xLoc = createLocations(2, 1);

        // Write with view version 2
        XLocSet xLocSet = xLoc.getXLocSet().toBuilder().setVersion(2).build();
        FileCredentials fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet).build();

        // write data
        ObjectData objdata = ObjectData.newBuilder().setChecksum(0).setZeroPadding(0).setInvalidChecksumOnOsd(false)
                .build();
        RPCResponse<OSDWriteResponse> r = client.write(xLoc.getOSDsForObject(objectNo).get(0).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, 0, objdata,
                this.data.createViewBuffer());
        OSDWriteResponse resp = r.get();
        r.freeBuffers();

        // change XLoc to replicated and set the view to the outdated version 1
        setReplicated(this.data.limit(), 0);
        xLocSet = xLoc.getXLocSet().toBuilder().setVersion(1).build();
        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet).build();

        // read data from first replica -> would have to replicate but will fail due to the VIEW error
        RPCResponse<ObjectData> r2 = client.read(xLoc.getOSDsForObject(objectNo).get(1).getAddress(),
                RPCAuthentication.authNone, RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);
        try {
            ObjectData resp2 = r2.get();
            fail();
        } catch (PBRPCException e) {
            assertEquals(ErrorType.INVALID_VIEW, e.getErrorType());
        } catch (IOException e) {
            fail();
        } finally {
            r2.freeBuffers();
        }

        // update to the view version 2
        xLocSet = xLoc.getXLocSet().toBuilder().setVersion(2).build();
        fc = FileCredentials.newBuilder().setXcap(cap.getXCap()).setXlocs(xLocSet).build();

        // read data from first replica -> has to replicate
        r2 = client.read(xLoc.getOSDsForObject(objectNo).get(1).getAddress(), RPCAuthentication.authNone,
                RPCAuthentication.userService, fc, fileID, objectNo, 0, 0, stripeSize);
        ObjectData resp2 = r2.get();
        if (data.capacity() > 0) {
            assertNotNull(r2.getData());
            assertTrue(Arrays.equals(data.array(), r2.getData().array()));
        } else
            assertNull(r2.getData());
        r2.freeBuffers();
    }
}
```


Overlapping Code:
```
plicationTest {
@Rule
public final TestRule testLog = TestHelper.testLog;
OSD[] osds;
OSDConfig[] configs;
OSDServiceClient client;
private Capability cap;
private String fileID;
private XLocations xLoc;
// needed for dummy classes
private int stripeSize;
private ReusableBuffer data;
private long objectNo;
private TestEnvironment testEnv;
@BeforeClass
public static void initializeTest() throws Exception {
Logging.start(SetupUtils.DEBUG_LEVEL, SetupUtils.DEBUG_CATEGORIES);
}
/**
* @throws java.lang.Exception
*/
@Before
public void setUp() throws Exception {
this.stripeSize = 128 * 1024; // byte
this.data = SetupUtils.generateData(stripeSize);
// startup: DIR
testEnv = new TestEnvironment(new TestEnvironment.Services[] { TestEnvironment.Services.DIR_SERVICE,
TestEnvironment.Services.TIME_SYNC, TestEnvironment.Services.UUID_RESOLVER,
TestEnvironment.Services.OSD_CLIENT });
testEnv.start();
osds = new OSD[12];
configs = SetupUtils.createMultipleOSDConfigs(12);
for (int i = 0; i < osds.length; i++) {
osds[i] = new OSD(configs[i]);
}
client = testEnv.getOSDClient();
fileID = "1:1";
objectNo = 0;
cap = new Capability(fileID, SYSTEM_V_FCNTL.SYSTEM_V_FCNTL_H_O_RDWR.getNumber(), 60,
System.currentTimeMillis(), "", 0, false, SnapConfig.SNAP_CONFIG_SNAPS_DISABLED, 0,
configs[0].getCapabilitySecret());
xLoc = createLocations(4, 3);
}
private XLocations createLocations(int numberOfReplicas, int numberOfStripedOSDs) throws InvalidXLocationsException {
assert (numberOfReplicas * numberOfStripedOSDs <= osds.length);
List<Replica> rlist = new LinkedList();
for (int replica = 0; replica < numberOfReplicas; replica++) {
List<String> osdset = new LinkedList();
int startOSD = replica * numberOfStripedOSDs;
for (int stripe = 0; stripe < numberOfStripedOSDs; stripe++) {
// add available osds
osdset.add(configs[startOSD + stripe].getUUID().toString());
}
Replica r = Replica.newBuilder()
.setStripingPolicy(SetupUtils.g
```
<Overlap Ratio: 0.9742033383915023>

---

--- 265 --
Question ID: a2679d23e812c436850e9784c31f528b1d917068
Original Code:
```
public class MockAuditJobStatusModel {
    private final Gson gson = new Gson();
    private final UUID jobId = UUID.randomUUID();
    private final String timeAuditCreated = new Date(400).toString();
    private final String timeLastSent = new Date(500).toString();
    private final String status = AuditEntryStatus.SUCCESS.name();

    public AuditJobStatusModel createRestModel() {
        return new AuditJobStatusModel(jobId, timeAuditCreated, timeLastSent, status);
    }

    public String getRestModelJson() {
        JsonObject json = new JsonObject();
        json.addProperty("jobId", jobId.toString());
        json.addProperty("timeAuditCreated", timeAuditCreated);
        json.addProperty("timeLastSent", timeLastSent);
        json.addProperty("status", status);

        return json.toString();
    }

    public void verifyRestModel() throws JSONException {
        String restModel = gson.toJson(createRestModel());
        String json = getRestModelJson();
        JSONAssert.assertEquals(restModel, json, false);
    }

    @Test
    public void testConfiguration() throws JSONException {
        verifyRestModel();
    }

}
```


Overlapping Code:
```
lic class MockAuditJobStatusModel {
private final Gson gson = new Gson();
private final UUID jobId = UUID.randomUUID();
private final String timeAuditCreated = new Date(400).toString();
private final String timeLastSent = new Date(500).toString();
private final String status = AuditEntryStatus.SUCCESS.name();
public AuditJobStatusModel createRestModel() {
return new AuditJobStatusModel(jobId, timeAuditCreated, timeLastSent, status);
}
public String getRestModelJson() {
JsonObject json = new JsonObject();
json.addProperty("jobId", jobId.toString());
json.addProperty("timeAuditCreated", timeAuditCreated);
json.addProperty("timeLastSent", timeLastSent);
json.addProperty("status", status);
return json.toString();
}
public void verifyRestModel() throws JSONException {
String restModel = gson.toJson(createRestModel());
String json = getRestModelJson();
JSONAssert.assertEquals(restModel, json, false);
}
@Test
public void testConfiguration() throws JSONException {
v
```
<Overlap Ratio: 0.9759036144578314>

---

--- 266 --
Question ID: bb913a430ade86c7ba7a428cb00aa1d67efe018f
Original Code:
```
public class Migration {

    public static void rekey(
            Account from,
            Account to,
            Callback1<List<String>> callback
    ) {
        checkValid(() -> from != null && to != null, "account is null");
        checkValid(
                () -> !from.getAccountNumber().equals(to.getAccountNumber()),
                "cannot use same account for rekey"
        );
        getOwningBitmarks(from).thenCompose(bitmarks -> offer(
                bitmarks,
                from,
                to
        )).thenCompose(offers -> respond(offers, to)).whenComplete(
                (txIds, throwable) -> {
                    if (throwable != null) {
                        callback.onError(throwable instanceof CompletionException
                                         ? throwable.getCause()
                                         : throwable);
                    } else {
                        callback.onSuccess(txIds);
                    }
                });
    }

    private static CompletableFuture<List<String>> respond(
            List<OfferRecord> offers,
            Account receiver
    ) {
        if (offers.isEmpty()) {
            return CompletableFuture.supplyAsync(ArrayList::new);
        }

        return CompletableFuture.supplyAsync(() -> offers.stream()
                .map(offer -> {
                    TransferResponseParams param = TransferResponseParams.accept(
                            offer);
                    param.sign(receiver.getAuthKeyPair());
                    return param;
                })
                .map(param -> CompletableFuture.supplyAsync(() -> {
                    try {
                        return Awaitility.<String>await(callback -> Bitmark.respond(
                                param,
                                callback
                        ));
                    } catch (Throwable e) {
                        throw new CompletionException(e);
                    }
                }))
                .map(CompletableFuture::join)
                .collect(Collectors.toList()));
    }

    private static CompletableFuture<List<OfferRecord>> offer(
            List<BitmarkRecord> bitmarks,
            Account sender,
            Account receiver
    ) {
        if (bitmarks.isEmpty()) {
            return CompletableFuture.supplyAsync(ArrayList::new);
        }

        return CompletableFuture.supplyAsync(() -> {
            List<Pair<String, TransferOfferParams>> params = bitmarks.stream()
                    .map(bm -> {
                        TransferOfferParams param = new TransferOfferParams(
                                receiver.toAddress(),
                                bm.getHeadId()
                        );
                        param.sign(sender.getAuthKeyPair());
                        return new Pair<>(bm.getId(), param);
                    })
                    .collect(Collectors.toList());

            return params.stream()
                    .map(p -> CompletableFuture.supplyAsync(
                            () -> {
                                try {
                                    String bitmarkId = p.first();
                                    TransferOfferParams param = p.second();
                                    Awaitility.<String>await(callback -> Bitmark
                                            .offer(param, callback));
                                    GetBitmarkResponse res = await(callback -> Bitmark
                                            .get(bitmarkId, callback));
                                    return res.getBitmark().getOffer();
                                } catch (Throwable e) {
                                    throw new CompletionException(e);
                                }
                            }))
                    .map(CompletableFuture::join)
                    .collect(Collectors.toList());
        });
    }

    private static CompletableFuture<List<BitmarkRecord>> getOwningBitmarks(
            Account owner
    ) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                final List<BitmarkRecord> bitmarks = new ArrayList<>();

                boolean existing = true;
                Long offset = null;
                while (existing) {
                    BitmarkQueryBuilder builder = new BitmarkQueryBuilder().ownedBy(
                            owner.getAccountNumber())
                            .to("earlier")
                            .limit(100)
                            .pending(false);
                    if (offset != null) {
                        builder.at(offset);
                    }
                    GetBitmarksResponse res = await(callback -> Bitmark.list(
                            builder,
                            callback
                    ));
                    List<BitmarkRecord> bms = res.getBitmarks();
                    existing = bms.size() == 100;
                    if (existing) {
                        offset = bms.get(bms.size() - 1).getOffset();
                    }
                    bitmarks.addAll(bms);
                }
                return bitmarks;
            } catch (Throwable e) {
                throw new CompletionException(e);
            }
        });
    }
}
```


Overlapping Code:
```
igration {
public static void rekey(
Account from,
Account to,
Callback1<List<String>> callback
) {
checkValid(() -> from != null && to != null, "account is null");
checkValid(
() -> !from.getAccountNumber().equals(to.getAccountNumber()),
"cannot use same account for rekey"
);
getOwningBitmarks(from).thenCompose(bitmarks -> offer(
bitmarks,
from,
to
)).thenCompose(offers -> respond(offers, to)).whenComplete(
(txIds, throwable) -> {
if (throwable != null) {
callback.onError(throwable instanceof CompletionException
? throwable.getCause()
: throwable);
} else {
callback.onSuccess(txIds);
}
});
}
private static CompletableFuture<List<String>> respond(
List<OfferRecord> offers,
Account receiver
) {
if (offers.isEmpty()) {
return CompletableFuture.supplyAsync(ArrayList::new);
}
return CompletableFuture.supplyAsync(() -> offers.stream()
.map(offer -> {
TransferResponseParams param = TransferResponseParams.accept(
offer);
param.sign(receiver.getAuthKeyPair());
return param;
})
.map(param -> CompletableFuture.supplyAsync(() -> {
try {
return Awaitility.<String>await(callback -> Bitmark.respond(
param,
callback
));
} catch (Throwable e) {
throw new CompletionException(e);
}
}))
.map(CompletableFuture::join)
.collect(Collectors.toList()));
}
private static CompletableFuture<List<OfferRecord>> offer(
List<BitmarkRecord> bitmarks,
Account sender,
Account receiver
) {
if (bitmarks.isEmpty()) {
return CompletableFuture.supplyAsync(ArrayList::new);
}
return CompletableFuture.supplyAsync(() -> {
List<
```
<Overlap Ratio: 0.9673076923076923>

---

--- 267 --
Question ID: ee6d07bdb8a3eedab88c3bba67dd1536c5f5b84b
Original Code:
```
public class AttrDescView_widget_TextView_imeActionId extends AttrDesc<ClassDescViewBased,View,AttrLayoutContext>
{
    public AttrDescView_widget_TextView_imeActionId(ClassDescViewBased parent)
    {
        super(parent,"imeActionId");
    }

    @Override
    public void setAttribute(View view, DOMAttr attr, AttrLayoutContext attrCtx)
    {
        int convertedValue = getInteger(attr.getResourceDesc(),attrCtx.getXMLInflaterContext());

        TextView textView = (TextView)view;
        textView.setImeActionLabel(textView.getImeActionLabel(),convertedValue);
    }

    @Override
    public void removeAttribute(View view, AttrLayoutContext attrCtx)
    {
        setAttributeToRemove(view, "0",attrCtx);
    }

}
```


Overlapping Code:
```
iew_imeActionId extends AttrDesc<ClassDescViewBased,View,AttrLayoutContext>
{
public AttrDescView_widget_TextView_imeActionId(ClassDescViewBased parent)
{
super(parent,"imeActionId");
}
@Override
public void setAttribute(View view, DOMAttr attr, AttrLayoutContext attrCtx)
{
int convertedValue = getInteger(attr.getResourceDesc(),attrCtx.getXMLInflaterContext());
TextView textView = (TextView)view;
textView.setImeActionLabel(textView.getImeActionLabel(),convertedValue);
}
@Override
public void removeAttribute(View view, AttrLayoutContext attrCtx)
{
setAttributeToRemove(view, "0",att
```
<Overlap Ratio: 0.9244094488188976>

---

--- 268 --
Question ID: 71359206e8c363e77cd9f23d261e515d46db6c6a
Original Code:
```
public class FilterTest {

  @Test
  public void filterJustCreatedShouldNotBeExpired() {
    final BlockFilter filter = new BlockFilter("foo");

    assertThat(filter.isExpired()).isFalse();
  }

  @Test
  public void isExpiredShouldReturnTrueForExpiredFilter() {
    final BlockFilter filter = new BlockFilter("foo");
    filter.setExpireTime(Instant.now().minusSeconds(1));

    assertThat(filter.isExpired()).isTrue();
  }

  @Test
  public void resetExpireDateShouldIncrementExpireDate() {
    final BlockFilter filter = new BlockFilter("foo");
    filter.setExpireTime(Instant.now().minus(Duration.ofDays(1)));
    filter.resetExpireTime();

    assertThat(filter.getExpireTime())
        .isBeforeOrEqualTo(Instant.now().plus(Duration.ofMinutes(10)));
  }
}
```


Overlapping Code:
```
public class FilterTest {
@Test
public void filterJustCreatedShouldNotBeExpired() {
final BlockFilter filter = new BlockFilter("foo");
assertThat(filter.isExpired()).isFalse();
}
@Test
public void isExpiredShouldReturnTrueForExpiredFilter() {
final BlockFilter filter = new BlockFilter("foo");
filter.setExpireTime(Instant.now().minusSeconds(1));
assertThat(filter.isExpired()).isTrue();
}
@Test
public void resetExpireDateShouldIncrementExpireDate() {
final BlockFilter filter = new BlockFilter("foo");
filter.setExpireTime(Instant.now().minus(Duration.ofDays(1)));
filter.resetExpireTime();
assertThat(filter.getExpireTime())
.isBeforeOrEqualTo(Instant.now().plus(Duration.
```
<Overlap Ratio: 0.9712230215827338>

---

--- 269 --
Question ID: 3b6c1b2cc43e8d6dbe227f98f253fc63f1878407
Original Code:
```
public final class OracleSegmentsExtractorRegistry implements SQLSegmentsExtractorRegistry {
    
    private static final Map<SQLStatementType, SQLStatementExtractor> EXTRACTORS = new HashMap<>();
    
    static {
        registerDDL();
    }
    
    private static void registerDDL() {
        EXTRACTORS.put(SQLStatementType.CREATE_TABLE, new CreateTableExtractor());
        EXTRACTORS.put(SQLStatementType.ALTER_TABLE, new OracleAlterTableExtractor());
        EXTRACTORS.put(SQLStatementType.DROP_TABLE, new OracleDropTableExtractor());
        EXTRACTORS.put(SQLStatementType.TRUNCATE_TABLE, new OracleTruncateTableExtractor());
        EXTRACTORS.put(SQLStatementType.CREATE_INDEX, new CreateIndexExtractor());
        EXTRACTORS.put(SQLStatementType.ALTER_INDEX, new OracleAlterIndexExtractor());
        EXTRACTORS.put(SQLStatementType.DROP_INDEX, new OracleDropIndexExtractor());
    }
    
    @Override
    public SQLStatementExtractor getExtractor(final SQLStatementType type) {
        return EXTRACTORS.get(type);
    }
}
```


Overlapping Code:
```
try implements SQLSegmentsExtractorRegistry {

private static final Map<SQLStatementType, SQLStatementExtractor> EXTRACTORS = new HashMap<>();

static {
registerDDL();
}

private static void registerDDL() {
EXTRACTORS.put(SQLStatementType.CREATE_TABLE, new CreateTableExtractor());
EXTRACTORS.put(SQLStatementType.ALTER_TABLE, new OracleAlterTableExtractor());
EXTRACTORS.put(SQLStatementType.DROP_TABLE, new OracleDropTableExtractor());
EXTRACTORS.put(SQLStatementType.TRUNCATE_TABLE, new OracleTruncateTableExtractor());
EXTRACTORS.put(SQLStatementType.CREATE_INDEX, new CreateIndexExtractor());
EXTRACTORS.put(SQLStatementType.ALTER_INDEX, new OracleAlterIndexExtractor());
EXTRACTORS.put(SQLStatementType.DROP_INDEX, new OracleDropIndexExtractor());
}

@Override
public SQLStatementExtractor getExtractor(final SQLStatementType type) {
return EXT
```
<Overlap Ratio: 0.9249183895538629>

---

--- 270 --
Question ID: 2a56e6c382aefd0652c476baa9969d716d68fafe
Original Code:
```
public class ChargeHelperActivity extends BaseActivity
{
  public void onCreate(Bundle paramBundle)
  {
    super.onCreate(paramBundle);
    setContentView(2130903091);
    b(2131034362);
  }
}
```


Overlapping Code:
```
tivity extends BaseActivity
{
public void onCreate(Bundle paramBundle)
{
super.onCreate(paramBundle);
setContentView(21309030
```
<Overlap Ratio: 0.7142857142857143>

---

--- 271 --
Question ID: 99ac7f2d67b578310b72527f6584ccba754cc888
Original Code:
```
public class SearchManagerImpl implements SearchManager {

    // Log
    @SuppressWarnings("unused")
    private static Log log = LogFactoryUtil.getLog(SearchManagerImpl.class);

    /**
     * Returns a list of buddies based on the search query. The search will be performed
     * in first name, middle name, last name, screen name and email.
     *
     * @param userId      Long
     * @param searchQuery String
     * @param start       of the list
     * @param end         of the list
     * @return List of buddies
     * @throws Exception
     */
    @Override
    public List<Buddy> searchBuddies(Long userId, String searchQuery, int start, int end) throws Exception {
        // Get selected list strategy
        Environment.BuddyListStrategy strategy = Environment.getBuddyListStrategy();
        // Get the info if the deactivated user should be ignored
        boolean ignoreDeactivatedUser = Environment.getBuddyListIgnoreDeactivatedUser();
        // Some sites or groups may be excluded
        String[] excludedSites = Environment.getBuddyListSiteExcludes();
        String[] excludedGroups = Environment.getBuddyListGroupExcludes();
        // Relation types
        Environment.BuddyListSocialRelation[] relationTypes = Environment.getBuddyListSocialRelations();

        // All buddies
        if (strategy == BuddyListStrategy.ALL) {
            return searchAllBuddies(
                    userId, searchQuery, true, ignoreDeactivatedUser, start, end
            );
        }
        // Buddies from sites
        else if (strategy == BuddyListStrategy.SITES) {
            return searchSitesBuddies(
                    userId, searchQuery, true, ignoreDeactivatedUser, excludedSites, start, end
            );
        }
        // Buddies by social relations
        else if (strategy == BuddyListStrategy.SOCIAL) {
            return searchSocialBuddies(
                    userId, searchQuery, true, ignoreDeactivatedUser, relationTypes, start, end
            );
        }
        // Buddies by social relations together with sites
        else if (strategy == BuddyListStrategy.SITES_AND_SOCIAL) {
            return searchSitesAndSocialBuddies(
                    userId, searchQuery, true, ignoreDeactivatedUser, excludedSites, relationTypes, start, end
            );
        }
        // Buddies by user groups
        else if (strategy == BuddyListStrategy.USER_GROUPS) {
            return searchUserGroupsBuddies(
                    userId, searchQuery, true, ignoreDeactivatedUser, excludedGroups, start, end
            );
        }
        // Unknown
        else {
            throw new Exception("Unknown buddy list strategy");
        }
    }


    /**
     * Returns a list of buddies related to the user based on the search query
     *
     * @param userId                Long
     * @param searchQuery           String
     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded
     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded
     * @param start                 of the list
     * @param end                   of the list
     * @return List of buddies
     * @throws Exception
     */
    private List<Buddy> searchAllBuddies(Long userId,
                                         String searchQuery,
                                         boolean ignoreDefaultUser,
                                         boolean ignoreDeactivatedUser,
                                         int start,
                                         int end) throws Exception {

        // Get from persistence
        List<Object[]> users = SettingsLocalServiceUtil.searchAllBuddies(
                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, start, end
        );

        // Return deserialized result
        return deserializeBuddyListFromUserObjects(users);
    }

    /**
     * Returns a list of buddies. The list is made of all buddies based on the search query in the sites
     * where the user participates
     *
     * @param userId                which should be excluded from the list
     * @param searchQuery           search query string
     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded
     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded
     * @param excludedSites         names of sites (groups) that should be excluded from the group collection
     * @param start                 of the list
     * @param end                   of the list
     * @return List of buddies
     * @throws Exception
     */
    private List<Buddy> searchSitesBuddies(Long userId,
                                           String searchQuery,
                                           boolean ignoreDefaultUser,
                                           boolean ignoreDeactivatedUser,
                                           String[] excludedSites,
                                           int start,
                                           int end) throws Exception {

        // Get from persistence
        List<Object[]> users = SettingsLocalServiceUtil.searchSitesBuddies(
                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, excludedSites, start, end
        );

        // Return deserialized result
        return deserializeBuddyListFromUserObjects(users);
    }

    /**
     * Returns a list of buddies. This list is made of all buddies based on the search query with whom the user
     * has a social relationships given in the parameter.
     *
     * @param userId                which should be excluded from the list
     * @param searchQuery           search query string
     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded
     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded
     * @param relationTypes         an array of relation types enums
     * @param start                 of the list
     * @param end                   of the list
     * @return List of buddies
     * @throws Exception
     */
    private List<Buddy> searchSocialBuddies(Long userId,
                                            String searchQuery,
                                            boolean ignoreDefaultUser,
                                            boolean ignoreDeactivatedUser,
                                            BuddyListSocialRelation[] relationTypes,
                                            int start,
                                            int end) throws Exception {

        // Get int codes from relation types since the persistence consumes an int array only.
        int[] relationCodes = new int[relationTypes.length];
        for (int i = 0; i < relationTypes.length; i++) {
            relationCodes[i] = relationTypes[i].getCode();
        }

        // Get from persistence
        List<Object[]> users = SettingsLocalServiceUtil.searchSocialBuddies(
                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, relationCodes, start, end
        );

        // Return deserialized result
        return deserializeBuddyListFromUserObjects(users);
    }

    /**
     * Returns a list of buddies. This list is made of all buddies based on the search query that are
     * in the same site and have a social relation given in parameter
     *
     * @param userId                which should be excluded from the list
     * @param searchQuery           search query string
     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded
     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded
     * @param excludedSites         names of sites (groups) that should be excluded from the group collection
     * @param relationTypes         an array of relation types enums
     * @param start                 of the list
     * @param end                   of the list
     * @return a list of buddies
     * @throws Exception
     */
    private List<Buddy> searchSitesAndSocialBuddies(Long userId,
                                                    String searchQuery,
                                                    boolean ignoreDefaultUser,
                                                    boolean ignoreDeactivatedUser,
                                                    String[] excludedSites,
                                                    BuddyListSocialRelation[] relationTypes,
                                                    int start,
                                                    int end) throws Exception {

        // Get site buddies
        List<Buddy> siteBuddies = searchSitesBuddies(
                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, excludedSites, start, end
        );

        // Get social buddies
        List<Buddy> socialBuddies = searchSocialBuddies(
                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, relationTypes, start, end
        );

        // Add it to set since we want to get rid of duplicates
        Set<Buddy> mergedBuddies = new HashSet<Buddy>();
        mergedBuddies.addAll(siteBuddies);
        mergedBuddies.addAll(socialBuddies);

        return new LinkedList<Buddy>(mergedBuddies);
    }

    /**
     * Returns a list of buddies. This list is made of all buddies based on the search query that are
     * in the same user group as the user.
     *
     * @param userId                which should be excluded from the list
     * @param searchQuery           search query string
     * @param ignoreDefaultUser     boolean set to true if the default user should be excluded
     * @param ignoreDeactivatedUser boolean set to true if the deactivated user should be excluded
     * @param excludedGroups        names of groups that should be excluded from the list of buddies
     * @param start                 of the list
     * @param end                   of the list
     * @return a list of buddies
     * @throws Exception
     */
    private List<Buddy> searchUserGroupsBuddies(Long userId,
                                                String searchQuery,
                                                boolean ignoreDefaultUser,
                                                boolean ignoreDeactivatedUser,
                                                String[] excludedGroups,
                                                int start,
                                                int end) throws Exception {

        // Get user groups
        List<Object[]> users = SettingsLocalServiceUtil.searchUserGroupsBuddies(
                userId, searchQuery, ignoreDefaultUser, ignoreDeactivatedUser, excludedGroups, start, end
        );

        // Return deserialized result
        return deserializeBuddyListFromUserObjects(users);
    }

    /**
     * Deserialize user objects to the list of buddies
     *
     * @param userObjects a list of user data stored in an object array
     * @return List of buddies
     */
    private List<Buddy> deserializeBuddyListFromUserObjects(List<Object[]> userObjects) {

        // Deserialize user info in plain objects to buddy
        List<Buddy> buddies = new LinkedList<Buddy>();
        for (Object[] userObject : userObjects) {
            // Deserialize
            Buddy buddy = Buddy.fromPlainObject(userObject, 0);
            // Add to list
            buddies.add(buddy);
        }

        return buddies;
    }
}
```


Overlapping Code:
```
ic class SearchManagerImpl implements SearchManager {
// Log
@SuppressWarnings("unused")
private static Log log = LogFactoryUtil.getLog(SearchManagerImpl.class);
/**
* Returns a list of buddies based on the search query. The search will be performed
* in first name, middle name, last name, screen name and email.
*
* @param userId Long
* @param searchQuery String
* @param start of the list
* @param end of the list
* @return List of buddies
* @throws Exception
*/
@Override
public List<Buddy> searchBuddies(Long userId, String searchQuery, int start, int end) throws Exception {
// Get selected list strategy
Environment.BuddyListStrategy strategy = Environment.getBuddyListStrategy();
// Get the info if the deactivated user should be ignored
boolean ignoreDeactivatedUser = Environment.getBuddyListIgnoreDeactivatedUser();
// Some sites or groups may be excluded
String[] excludedSites = Environment.getBuddyListSiteExcludes();
String[] excludedGroups = Environment.getBuddyListGroupExcludes();
// Relation types
Environment.BuddyListSocialRelation[] relationTypes = Environment.getBuddyListSocialRelations();
// All buddies
if (strategy == BuddyListStrategy.ALL) {
return searchAllBuddies(
userId, searchQuery, true, ignoreDeactivatedUser, start, end
);
}
// Buddies from sites
else if (strategy == BuddyListStrategy.SITES) {
return searchSitesBuddies(
userId, searchQuery, true, ignoreDeactivatedUser, excludedSites, start, end
);
}
// Buddies by social relations
else if (strategy == BuddyListStrategy.SOCIAL) {
return searchSocialBuddies(
userId, searchQuery, true, ignoreDeactivatedUser, relationTypes, start, end
);
}
// Buddies by social relations together with sites
else if (strategy == BuddyListStrategy.SITES_AND_SOCIAL) {
return searchSitesAndSocialBuddies(
userId, searchQuery, true, ignoreDeactivatedUser, excludedSites, relationTypes, start, end
);
}
// Buddies by user groups
else if (strategy == BuddyListStrategy.USER_GROUPS) {
return sear
```
<Overlap Ratio: 0.9751367478866235>

---

--- 272 --
Question ID: 37f03c2a172bd10071d66a3aa3654b804a7b81dc
Original Code:
```
@Component
public class UserArgumentResolver implements HandlerMethodArgumentResolver {

    @Autowired
    private SeckillUserService seckillUserService;

    @Override
    public boolean supportsParameter(MethodParameter methodParameter) {
        Class<?> clazz = methodParameter.getParameterType();
        return clazz == SeckillUser.class;
    }

    @Override
    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {
//        HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);
//        HttpServletResponse response = nativeWebRequest.getNativeResponse(HttpServletResponse.class);
//        //获取token
//        String paramToken = request.getParameter(SysConstant.COOKIE_NAME_TOKEN); //请求参数上的token
//        String cookieToken = CookieUtil.getCookieValue(request, SysConstant.COOKIE_NAME_TOKEN); //cookie中的token
//        if (StringUtils.isEmpty(paramToken) && StringUtils.isEmpty(cookieToken)) {
//            return null;
//        }
//        String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;
//        return seckillUserService.getUserByToken(response, token);
        return CurrentUserContext.getUser();
    }
}
```


Overlapping Code:
```
@Component
public class UserArgumentResolver implements HandlerMethodArgumentResolver {
@Autowired
private SeckillUserService seckillUserService;
@Override
public boolean supportsParameter(MethodParameter methodParameter) {
Class<?> clazz = methodParameter.getParameterType();
return clazz == SeckillUser.class;
}
@Override
public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {
// HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);
// HttpServletResponse response = nativeWebRequest.getNativeResponse(HttpServletResponse.class);
// //获取token
// String paramToken = request.getParameter(SysConstant.COOKIE_NAME_TOKEN); //请求参数上的token
// String cookieToken = CookieUtil.getCookieValue(request, SysConstant.COOKIE_NAME_TOKEN); //cookie中的token
// if (StringUtils.isEmpty(paramToken) && StringUtils.isEmpty(cookieToken)) {
// return null;
// }
// String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;
// return seckillUserService.getUserByToken(response, token);
return CurrentUserContext.getUser(
```
<Overlap Ratio: 0.9950331125827815>

---

--- 273 --
Question ID: fafdaa6c81f3967bad13b9cc30b9c6454a88ec12
Original Code:
```
@Component
@Path("/clouds/{cloudId}/comments")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Api(value = "Comments", produces = "application/json")
public class CommentsProvider {

	private static final Logger LOG = LoggerFactory.getLogger(CommentsProvider.class);

	@Value("${info.api.version}")
	private String apiVersion;

	@POST
	@Path("/")
	@ApiOperation(value = "Create new comment", response = JsonObj.class)
	public Response create(
			@HeaderParam("Authorization") String auth,
			@ApiParam @PathParam("cloudId") String cloudId,
			@ApiParam JsonObj request
	) throws InvalidInputException, NotFoundException, NotAuthorizedException {
		LOG.info("POST:{}/clouds/{}/comments", apiVersion, cloudId);
		JsonObj result = CommentsService.createComment(auth, cloudId, request);
		return Response.status(Status.OK).entity(result).build();
	}

	@GET
	@Path("/search")
	@ApiOperation(value = "Query comments for node", response = JsonObj.class)
	public Response get(
			@HeaderParam("Authorization") String auth,
			@ApiParam @PathParam("cloudId") String cloudId,
			@ApiParam @QueryParam("nodeId") String nodeId, 
			@ApiParam @QueryParam("query") String query,
			@ApiParam @QueryParam("projection") String projection,
			@ApiParam @QueryParam("limit") int limit
	) throws NotAuthorizedException {
		LOG.info("GET:{}/clouds/{}/comments/search/{}?query={}&projection={}&limit={}", apiVersion, cloudId, nodeId, query, projection, limit);
		JsonObj result = CommentsService.getCommentsforNode(auth, cloudId, nodeId, query, projection, limit);
		return Response.status(Status.OK).entity(result).build();
	}

}
```


Overlapping Code:
```
udId}/comments")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Api(value = "Comments", produces = "application/json")
public class CommentsProvider {
private static final Logger LOG = LoggerFactory.getLogger(CommentsProvider.class);
@Value("${info.api.version}")
private String apiVersion;
@POST
@Path("/")
@ApiOperation(value = "Create new comment", response = JsonObj.class)
public Response create(
@HeaderParam("Authorization") String auth,
@ApiParam @PathParam("cloudId") String cloudId,
@ApiParam JsonObj request
) throws InvalidInputException, NotFoundException, NotAuthorizedException {
LOG.info("POST:{}/clouds/{}/comments", apiVersion, cloudId);
JsonObj result = CommentsService.createComment(auth, cloudId, request);
return Response.status(Status.OK).entity(result).build();
}
@GET
@Path("/search")
@ApiOperation(value = "Query comments for node", response = JsonObj.class)
public Response get(
@HeaderParam("Authorization") String auth,
@ApiParam @PathParam("cloudId") String cloudId,
@ApiParam @QueryParam("nodeId") String nodeId, 
@ApiParam @QueryParam("query") String query,
@ApiParam @QueryParam("projection") String projection,
@ApiParam @QueryParam("limit") int limit
) throws NotAuthorizedException {
LOG.info("GET:{}/clouds/{}/comments/search/{}?query={}&projection={}&limit={}", apiVersion, cloudId, nodeId, query, projection, limit);
JsonObj result = CommentsService.getCommentsforNode(auth, cloudId, nodeId, query, projection, limit);
return Response.status(Status.OK).entity(result).build();
}
}
```
<Overlap Ratio: 0.981000633312223>

---

--- 274 --
Question ID: 35de4081b75a8c758fed2fee8348e1c234fe6700
Original Code:
```
@RestController
@RequestMapping("/account")
public class AccountController {

    @Autowired
    private AccountService accountService;



    @GetMapping("/fetchAll")
    public List<AccountOutput> fetchAllExpenses(){
        return accountService
                .findAll ()
                .parallelStream ()
                .map ( (source) -> {
                    AccountOutput accountOutput = new AccountOutput ( );
                    BeanUtils.copyProperties ( source, accountOutput );
                    return accountOutput;
                })
                .collect ( Collectors.toList ( ) );
    }


    @PostMapping("/add")
    public @ResponseBody AccountOutput addExpenses(@RequestBody AccountInput accountInput){

        Account account = new Account () ;
        BeanUtils.copyProperties ( accountInput, account );
        accountService.saveOrUpdate ( account );
        return new AccountOutput ();

    }

}
```


Overlapping Code:
```
@RestController
@RequestMapping("/account")
public class AccountController {
@Autowired
private AccountService accountService;
@GetMapping("/fetchAll")
public List<AccountOutput> fetchAllExpenses(){
return accountService
.findAll ()
.parallelStream ()
.map ( (source) -> {
AccountOutput accountOutput = new AccountOutput ( );
BeanUtils.copyProperties ( source, accountOutput );
return accountOutput;
})
.collect ( Collectors.toList ( ) );
}
@PostMapping("/add")
public @ResponseBody AccountOutput addExpenses(@RequestBody AccountInput accountInput){
Account account = new Account () ;
BeanUtils.copyProperties ( accountInput, account );
accountService.saveOrUpdate ( account );
return new Ac
```
<Overlap Ratio: 0.9732394366197183>

---

--- 275 --
Question ID: ba72a64b2f800c7613d25b00c0f32ec3d04a5603
Original Code:
```
@RunWith(Parameterized.class)
public class OnnxImportTest extends BaseNd4jTest {


    public OnnxImportTest(Nd4jBackend backend) {
        super(backend);
    }


    @Override
    public char ordering() {
        return 'c';
    }


    @After
    public void tearDown() throws Exception {
        NativeOpsHolder.getInstance().getDeviceNativeOps().enableDebugMode(false);
        NativeOpsHolder.getInstance().getDeviceNativeOps().enableVerboseMode(false);
    }

    @Test
    public void testOnnxImportEmbedding() throws Exception {
        /**
         *
         */
        val importGraph = OnnxGraphMapper.getInstance().importGraph(new ClassPathResource("onnx_graphs/embedding_only.onnx").getInputStream());
        val embeddingMatrix = importGraph.getVariable("2");
        assertArrayEquals(new long[] {100,300},embeddingMatrix.getShape());
       /* val onlyOp = importGraph.getFunctionForVertexId(importGraph.getVariable("3").getVertexId());
        assertNotNull(onlyOp);
        assertTrue(onlyOp instanceof Gather);
*/
    }

    @Test
    public void testOnnxImportCnn() throws Exception {
   /*     val importGraph = OnnxGraphMapper.getInstance().importGraph(new ClassPathResource("onnx_graphs/sm_cnn.onnx").getFile());
        assertEquals(20,importGraph.graph().numVertices());
        val outputTanhOutput = importGraph.getFunctionForVertexId(15);
        assertNotNull(outputTanhOutput);
        assertTrue(outputTanhOutput instanceof Tanh);

        val pooling = importGraph.getFunctionForVertexId(16);
        assertTrue(pooling instanceof MaxPooling2D);

        val poolingCast = (MaxPooling2D) pooling;
        assertEquals(24,poolingCast.getConfig().getkH());
        assertEquals(24,poolingCast.getConfig().getkW());*/

    }


}
```


Overlapping Code:
```
d.class)
public class OnnxImportTest extends BaseNd4jTest {
public OnnxImportTest(Nd4jBackend backend) {
super(backend);
}
@Override
public char ordering() {
return 'c';
}
@After
public void tearDown() throws Exception {
NativeOpsHolder.getInstance().getDeviceNativeOps().enableDebugMode(false);
NativeOpsHolder.getInstance().getDeviceNativeOps().enableVerboseMode(false);
}
@Test
public void testOnnxImportEmbedding() throws Exception {
/**
*
*/
val importGraph = OnnxGraphMapper.getInstance().importGraph(new ClassPathResource("onnx_graphs/embedding_only.onnx").getInputStream());
val embeddingMatrix = importGraph.getVariable("2");
assertArrayEquals(new long[] {100,300},embeddingMatrix.getShape());
/* val onlyOp = importGraph.getFunctionForVertexId(importGraph.getVariable("3").getVertexId());
assertNotNull(onlyOp);
assertTrue(onlyOp instanceof Gather);
*/
}
@Test
public void testOnnxImportCnn() throws Exception {
/* val importGraph = OnnxGraphMapper.getInstance().importGraph(new ClassPathResource("onnx_graphs/sm_cnn.onnx").getFile());
assertEquals(20,importGraph.graph().numVertices());
val outputTanhOutput = importGraph.getFunctionForVertexId(15);
assertNotNull(outputTanhOutput);
assertTrue(outputTanhOutput instanceof Tanh);
val pooling = importGraph.getFunctionForVertexId(16);
assertTrue(pooling instanceof MaxPooling2D);
val poolingCast = (MaxPooling2D) pooling;
assertEquals(24,poolingCast.getConfig().getkH());
assertEquals(24,poo
```
<Overlap Ratio: 0.962176509621765>

---

--- 276 --
Question ID: b281c919eb731b05a1526f642671132892b4d110
Original Code:
```
public class BackpointerUtil {
  private BackpointerUtil() {
  }

  public static boolean isBackpointerReference(PsiExpression expression, Condition<PsiField> value) {
    if (expression instanceof PsiParenthesizedExpression) {
      final PsiExpression contents = ((PsiParenthesizedExpression)expression).getExpression();
      return isBackpointerReference(contents, value);
    }
    if (!(expression instanceof PsiReferenceExpression)) {
      return false;
    }
    final PsiReferenceExpression reference = (PsiReferenceExpression)expression;
    final PsiElement qualifier = reference.getQualifier();
    if (qualifier != null && !(qualifier instanceof PsiThisExpression)) {
      return false;
    }
    final PsiElement referent = reference.resolve();
    return referent instanceof PsiField && value.value((PsiField)referent);
  }
}
```


Overlapping Code:
```
interUtil() {
}
public static boolean isBackpointerReference(PsiExpression expression, Condition<PsiField> value) {
if (expression instanceof PsiParenthesizedExpression) {
final PsiExpression contents = ((PsiParenthesizedExpression)expression).getExpression();
return isBackpointerReference(contents, value);
}
if (!(expression instanceof PsiReferenceExpression)) {
return false;
}
final PsiReferenceExpression reference = (PsiReferenceExpression)expression;
final PsiElement qualifier = reference.getQualifier();
if (qualifier != null && !(qualifier instanceof PsiThisExpression)) {
return false;
}
final PsiElement referent = reference.resolve();
return referent instanceof PsiField && value.value(
```
<Overlap Ratio: 0.9102730819245773>

---

--- 277 --
Question ID: 153cac855d2407b3580bea93e786ff4e10c64e51
Original Code:
```
@Service
public class ContractorServiceImpl implements ContractorService {

    private final ContractorRepository contractorRepository;
    private final ClientRepository clientRepository;

    public ContractorServiceImpl(ContractorRepository contractorRepository, ClientRepository clientRepository) {
        this.contractorRepository = contractorRepository;
        this.clientRepository = clientRepository;
    }


    @Override
    public Optional<Contractor> getContractorById(Long id) {
        return Optional.ofNullable(contractorRepository.findById(id));
    }

    @Override
    public void addContractor(Long id, Contractor contractor) {
        contractor.setClient(clientRepository.findOne(id));
        contractorRepository.save(contractor);
    }

    @Override
    public Contractor updateContractor(Contractor contractor) {
        Contractor temp = contractorRepository.findById(contractor.getId());
        temp.setDescription(contractor.getDescription());
        temp.setName(contractor.getName());

        return contractorRepository.save(temp);
    }

    @Override
    public void deleteContractorById(Long id) {
        contractorRepository.delete(id);
    }

}
```


Overlapping Code:
```
public class ContractorServiceImpl implements ContractorService {
private final ContractorRepository contractorRepository;
private final ClientRepository clientRepository;
public ContractorServiceImpl(ContractorRepository contractorRepository, ClientRepository clientRepository) {
this.contractorRepository = contractorRepository;
this.clientRepository = clientRepository;
}
@Override
public Optional<Contractor> getContractorById(Long id) {
return Optional.ofNullable(contractorRepository.findById(id));
}
@Override
public void addContractor(Long id, Contractor contractor) {
contractor.setClient(clientRepository.findOne(id));
contractorRepository.save(contractor);
}
@Override
public Contractor updateContractor(Contractor contractor) {
Contractor temp = contractorRepository.findById(contractor.getId());
temp.setDescription(contractor.getDescription());
temp.setName(contractor.getName());
return contractorRepository.save(temp);
}
@Override
public void deleteContractorById(Long id) {
contractorRe
```
<Overlap Ratio: 0.9681467181467182>

---

--- 278 --
Question ID: ff00f630cdc6e31f050192d22a59609aefab169b
Original Code:
```
public class ParseFormat extends Procedure1
{
  public static final ParseFormat parseFormat = new ParseFormat(false);

  boolean emacsStyle = true;
  public static final int PARAM_UNSPECIFIED = LispFormat.PARAM_UNSPECIFIED;
  public static final int PARAM_FROM_LIST = LispFormat.PARAM_FROM_LIST;

  public ParseFormat (boolean emacsStyle)
  {
    this.emacsStyle = emacsStyle;
  }

  public static final int SEEN_MINUS = 1;
  public static final int SEEN_PLUS  = 2;
  public static final int SEEN_SPACE = 4;
  public static final int SEEN_ZERO  = 8;
  public static final int SEEN_HASH = 16;

  public ReportFormat parseFormat(InPort fmt)
    throws java.text.ParseException, java.io.IOException
  {
    return parseFormat(fmt, emacsStyle ? '?' : '~');
  }

  public static ReportFormat parseFormat(InPort fmt, char magic)
    throws java.text.ParseException, java.io.IOException
  {
    StringBuffer fbuf = new StringBuffer(100);
    int position = 0;
    ArrayList<Format> formats = new ArrayList<Format>();
    Format format;
    for (;;)
      {
	int ch = fmt.read();
	if (ch >= 0)
	  {
	    if (ch != magic)
	      {
		// FIXME - quote special characters!
		fbuf.append((char) ch);
		continue;
	      }
	    ch = fmt.read();
	    if (ch == magic)
	      {
		fbuf.append((char) ch);
		continue;
	      }
	  }
	int len = fbuf.length();

        // Note we create a LiteralFormat even when fbuf is empty.
        // This is to make sure there are string-valued separators between
        // specifiers (as well as before and after).  Otherwise
        // ($sprintf$ "%s%s" 3 4) would return "3 4" rather than "34".
        if (len == 0)
            format = LiteralFormat.separator;
        else
          {
            char[] text = new char[len];
            fbuf.getChars(0, len, text, 0);
            fbuf.setLength(0);
            format = new LiteralFormat(text);
          }
        formats.add(format);

	if (ch < 0)
	  break;
	int digit;
	if (ch == '$')
	  {
	    ch = fmt.read();
	    position = Character.digit((char) ch, 10);
	    if (position < 0)
	      throw new ParseException("missing number (position) after '%$'",
				       -1);
	    for (;;)
	      {
		ch = fmt.read();
		digit = Character.digit((char) ch, 10);
		if (digit < 0)
		  break;
		position = 10 * position + digit;
	      }
	    position--;  /* Convert to zero-origin index. */
	  }

	int flags = 0;
	for (;; ch = fmt.read())
	  {
	    switch ((char) ch)
	      {
	      case '-':  flags |= SEEN_MINUS;  continue;
	      case '+':  flags |= SEEN_PLUS;   continue;
	      case ' ':  flags |= SEEN_SPACE;  continue;
	      case '0':  flags |= SEEN_ZERO;   continue;
	      case '#':  flags |= SEEN_HASH;   continue;
	      }
	    break;
	  }

	int width;
        if (ch == '*')
          {
            width = PARAM_FROM_LIST;
            ch = fmt.read();
          }
	else if ((digit = Character.digit((char) ch, 10)) >= 0)
	  {
	    width = digit;
	    for (;;)
	      {
		ch = fmt.read();
		digit = Character.digit((char) ch, 10);
		if (digit < 0)
		  break;
		width = 10 * width + digit;
	      }
	  }
        else
          width = PARAM_UNSPECIFIED;

	int precision = PARAM_UNSPECIFIED;
	if (ch == '.')
	  {
            ch = fmt.read();
	    if (ch == '*')
              {
                precision = PARAM_FROM_LIST;
                ch = fmt.read();
              }
	    else if ((digit = Character.digit((char) ch, 10)) >= 0)
	      {
                precision = digit;
                for (;;)
                  {
                    ch = fmt.read();
                    digit = Character.digit((char) ch, 10);
                    if (digit < 0)
                        break;
                    precision = 10 * precision + digit;
                  }
              }
          }

        char padChar
            = (flags & (SEEN_ZERO+SEEN_MINUS)) == SEEN_ZERO ? '0' : ' ';
	switch (ch)
	  {
	  case 's':
	  case 'S':
	    format = new ObjectFormat(ch == 'S', precision);
	    break;

	  case 'x':
	  case 'X':
	  case 'i':
	  case 'd':
	  case 'o':
	    int base;
            int fflags = 0;
	    if (ch == 'd' || ch == 'i')
              base = 10;
	    else if (ch == 'o')
              base = 8;
	    else
              { /* if (ch == 'x' || ch == 'X') */
                base = 16;
                if (ch == 'X') fflags = IntegerFormat.UPPERCASE;
              }
            boolean seenColon = false;
            boolean seenAt = false;
            if ((flags & SEEN_HASH) != 0)
              fflags |= IntegerFormat.SHOW_BASE;
            if ((flags & SEEN_PLUS) != 0)
              fflags |= IntegerFormat.SHOW_PLUS;
            if ((flags & SEEN_MINUS) != 0)
              fflags |= IntegerFormat.PAD_RIGHT;
            if ((flags & SEEN_SPACE) != 0)
              fflags |= IntegerFormat.SHOW_SPACE;
	    if (precision != PARAM_UNSPECIFIED)
	      {
		flags &= ~ SEEN_ZERO;
		fflags |= IntegerFormat.MIN_DIGITS;
		format = IntegerFormat.getInstance(base, precision,
						   '0', PARAM_UNSPECIFIED,
						   PARAM_UNSPECIFIED, fflags);
	      }
	    else
	      format = IntegerFormat.getInstance(base, width,
						 padChar, PARAM_UNSPECIFIED,
						 PARAM_UNSPECIFIED, fflags);
            break;
	  case 'f':
	  case 'e':
	  case 'E':
	  case 'g':
	  case 'G':
              LispRealFormat dfmt = new LispRealFormat();
              dfmt.op = (char) ch;
              dfmt.style = 'P';
              dfmt.arg1 = width;
              if (precision == PARAM_UNSPECIFIED)
                  precision = 6;
              dfmt.arg2 = precision;
              dfmt.showPlus = (flags & SEEN_PLUS) != 0;
              if (ch == 'e' || ch == 'E' || ch == 'g' || ch == 'G') {
                  dfmt.arg3 = 2;
                  dfmt.arg4 = 1; // intDigits
                  dfmt.arg5 = '\0'; // overflowChar
                  dfmt.arg6  = padChar;
                  // set exponentChar
                  dfmt.arg7 = ch == 'E' || ch == 'G' ? 'E' : 'e';
              }
              else {
                  dfmt.arg3 = '\0'; // overflowChar
                  dfmt.arg5 = padChar;
              }
              dfmt.internalPad = true;
              format = dfmt.resolve(null, 0);
	    break;
	  default:
	    throw new ParseException ("unknown format character '"+ch+"'", -1);
	  }
	if (width > 0)
	  {
	    padChar = (flags & SEEN_ZERO) != 0 ? '0' : ' ';
	    int where;
	    if ((flags & SEEN_MINUS) != 0)
	      where = 100;
	    else if (padChar == '0')
	      where = -1;
	    else
	      where = 0;
	    format = new gnu.text.PadFormat(format, width, padChar, where);
	  }
	// FIXME handle re-positioning
	//fbuf.append('{');
        // fbuf.append(position);
	//fbuf.append('}');
	formats.add(format);
	position++;
      }
    int fcount = formats.size();
    if (fcount == 1)
      {
	Object f = formats.get(0);
	if (f instanceof ReportFormat)
	  return (ReportFormat) f;
      }
    return new CompoundFormat(formats.toArray(new Format[fcount]));
  }

  public Object apply1 (Object arg)
  {
    return asFormat(arg, emacsStyle ? '?' : '~');
  }

  public static ReportFormat asFormat (Object arg, char style)
  {
    try
      {
	if (arg instanceof ReportFormat)
	  return (ReportFormat) arg;
	if (style == '~')
	  return new LispFormat(arg.toString());
	else
	  {
	    InPort iport;
	    if (arg instanceof FString)
              iport = ((FString) arg).openReader();
	    else 
	      iport = new CharArrayInPort(arg.toString()); 
	    try
	      {
		return parseFormat(iport, style);
	      }
	    finally
	      {
		iport.close();
	      }
	  }
      }
    catch (java.io.IOException ex)
      {
	throw new RuntimeException("Error parsing format ("+ex+")");
      }
    catch (ParseException ex)
      {
	throw new RuntimeException("Invalid format ("+ex+")");
      }
    catch (IndexOutOfBoundsException ex)
      {
	throw new RuntimeException("End while parsing format");
      }
  }
}
```


Overlapping Code:
```
nds Procedure1
{
public static final ParseFormat parseFormat = new ParseFormat(false);
boolean emacsStyle = true;
public static final int PARAM_UNSPECIFIED = LispFormat.PARAM_UNSPECIFIED;
public static final int PARAM_FROM_LIST = LispFormat.PARAM_FROM_LIST;
public ParseFormat (boolean emacsStyle)
{
this.emacsStyle = emacsStyle;
}
public static final int SEEN_MINUS = 1;
public static final int SEEN_PLUS = 2;
public static final int SEEN_SPACE = 4;
public static final int SEEN_ZERO = 8;
public static final int SEEN_HASH = 16;
public ReportFormat parseFormat(InPort fmt)
throws java.text.ParseException, java.io.IOException
{
return parseFormat(fmt, emacsStyle ? '?' : '~');
}
public static ReportFormat parseFormat(InPort fmt, char magic)
throws java.text.ParseException, java.io.IOException
{
StringBuffer fbuf = new StringBuffer(100);
int position = 0;
ArrayList<Format> formats = new ArrayList<Format>();
Format format;
for (;;)
{
int ch = fmt.read();
if (ch >= 0)
{
if (ch != magic)
{
// FIXME - quote special characters!
fbuf.append((char) ch);
continue;
}
ch = fmt.read();
if (ch == magic)
{
fbuf.append((char) ch);
continue;
}
}
int len = fbuf.length();
// Note we create a LiteralFormat even when fbuf is empty.
// This is to make sure there are string-valued separators between
// specifiers (as well as before and after). Otherwise
// ($sprintf$ "%s%s" 3 4) would return "3 4" rather than "34".
if (len == 0)
format = LiteralFormat.separator;
else
{
char[] text = new char[len];
fbuf.getChars(0, len, text, 0);
fbuf.setLength(0);
format = new LiteralFormat(text);
}
formats.add(format);
if (ch < 0)
break;
int digit;
if (ch == '$')
{
ch = fmt.read();
position = Character.digit((char) ch, 10);
if (position < 0)
throw new ParseException("missing number (position) after '%$'",
-1);
for (;;)
{
ch = fmt.read();
digit = Character.digit((char) ch, 10);
if (digit < 0)
break;
position = 10 * position + digit;
}
position--; /* Convert to zero-origin index. */
}
int flags = 0;
for (;; ch = fmt.read())
{
switch ((char) ch)
{
case '-': flags
```
<Overlap Ratio: 0.9743346007604563>

---

--- 279 --
Question ID: 62f53041d781faff39cb3333062d9690dbb55421
Original Code:
```
@Startup
@Singleton
@TransactionManagement(TransactionManagementType.BEAN)
public class Bootstrap {

    @Inject
    private Logger logger;

    @Inject
    private EnvironmentInitializer initializer;

    /**
     * Initialize and do the job
     */
    @PostConstruct
    protected void initialize() {
        this.logger.info("Initializing application, this may take a few minutes...");
        this.initializer.initialize();
        this.logger.info("Initialization finished!");
   }
}
```


Overlapping Code:
```

@Singleton
@TransactionManagement(TransactionManagementType.BEAN)
public class Bootstrap {
@Inject
private Logger logger;
@Inject
private EnvironmentInitializer initializer;
/**
* Initialize and do the job
*/
@PostConstruct
protected void initialize() {
this.logger.info("Initializing application, this may take a few minutes...");
this.initializer.initialize();
this.logger.info("Initiali
```
<Overlap Ratio: 0.9263657957244655>

---

--- 280 --
Question ID: 79d00d4d722a343f5b218c0cf9e9a29f25931d44
Original Code:
```
public class odd_even {

	public static void main(String[] args) {
		
		Scanner inp = new Scanner(System.in);
		
		System.out.print(" Enter the Size of the Array : ");
		int size = inp.nextInt();			// Getting the size of the Array input by the User
		
		int arr[] = new int[size];
		
		System.out.println(" Enter the " + " Elements of the Array : ");
		
		for ( int i = 0 ; i < size ; i++ ) {
			arr[i] = inp.nextInt();				// Getting the Elements of the Array input by the User
		}
		
		// Printing the Even Numbers
		System.out.println("\n The Even Numbers in the Array : \n");
		
		for ( int loop : arr ) {
			if ( loop % 2 == 0 )
				System.out.println(" " + loop);
		}
		
		// Printing the Odd Numbers
		System.out.println("\n The Odd Numbers in the Array : \n");
				
		for ( int loop : arr ) {
			if ( loop % 2 != 0 )
				System.out.println(" " + loop);
		}
	}

}
```


Overlapping Code:
```
n {
public static void main(String[] args) {

Scanner inp = new Scanner(System.in);

System.out.print(" Enter the Size of the Array : ");
int size = inp.nextInt(); // Getting the size of the Array input by the User

int arr[] = new int[size];

System.out.println(" Enter the " + " Elements of the Array : ");

for ( int i = 0 ; i < size ; i++ ) {
arr[i] = inp.nextInt(); // Getting the Elements of the Array input by the User
}

// Printing the Even Numbers
System.out.println("\n The Even Numbers in the Array : \n");

for ( int loop : arr ) {
if ( loop % 2 == 0 )
System.out.println(" " + loop);
}

// Printing the Odd Numbers
System.out.println("\n The Odd Numbers in the Array : \n");

for ( int loop : arr ) {
if ( loop % 2 != 0 )
System.out.println(" " + loop);
}

```
<Overlap Ratio: 0.9709962168978562>

---

--- 281 --
Question ID: 9c94c97914fd129e2a3f06edd182837991cbfa89
Original Code:
```
public class ResourceUtilTest extends BaseTest {

	private String CLASS_PATH_FILE_TEST_EXTENSION = "txt";
	private String CLASS_PATH_FILE_TEST = "CLASS_PATH_FILE_TEST." + CLASS_PATH_FILE_TEST_EXTENSION;

	@Test
	public void testClassNames() throws ZipException, IOException {
		final String[] classPathClassNames = ResourceUtil.getClasspathClassNames();
		assertNotNull(classPathClassNames);
		assertTrue( classPathClassNames.length > 0 );

		for (final String className : classPathClassNames) {
			System.out.println("Class found: " + className);
			assertNotNull(className);
		}

	}

	@Test
	public void testClasspathFileNames() throws ZipException, IOException {
		final String[] classPathFileNames = ResourceUtil.getClasspathFileNames();
		assertNotNull(classPathFileNames);
		assertTrue( classPathFileNames.length > 0 );

		boolean foundTestFile = false;
		for (final String fileName : classPathFileNames) {
			System.out.println("File found: " + fileName);
			assertNotNull(fileName);
			if (fileName.contains(CLASS_PATH_FILE_TEST)) {
				foundTestFile = true;
			}
		}
		assertTrue(foundTestFile);
	}

	@Test
	public void testClasspathFileNamesByExtension() throws ZipException, IOException {
		final String[] classPathFileNames = ResourceUtil.getClasspathFileNamesWithExtension(CLASS_PATH_FILE_TEST_EXTENSION);
		assertNotNull(classPathFileNames);
		assertTrue( classPathFileNames.length > 0 );

		boolean foundTestFile = false;
		for (final String fileName : classPathFileNames) {
			System.out.println("File found: " + fileName);
			assertNotNull(fileName);
			assertTrue(fileName.endsWith(CLASS_PATH_FILE_TEST_EXTENSION));
			if (fileName.contains(CLASS_PATH_FILE_TEST)) {
				foundTestFile = true;
			}
		}
		assertTrue(foundTestFile);
	}
}
```


Overlapping Code:
```
t extends BaseTest {
private String CLASS_PATH_FILE_TEST_EXTENSION = "txt";
private String CLASS_PATH_FILE_TEST = "CLASS_PATH_FILE_TEST." + CLASS_PATH_FILE_TEST_EXTENSION;
@Test
public void testClassNames() throws ZipException, IOException {
final String[] classPathClassNames = ResourceUtil.getClasspathClassNames();
assertNotNull(classPathClassNames);
assertTrue( classPathClassNames.length > 0 );
for (final String className : classPathClassNames) {
System.out.println("Class found: " + className);
assertNotNull(className);
}
}
@Test
public void testClasspathFileNames() throws ZipException, IOException {
final String[] classPathFileNames = ResourceUtil.getClasspathFileNames();
assertNotNull(classPathFileNames);
assertTrue( classPathFileNames.length > 0 );
boolean foundTestFile = false;
for (final String fileName : classPathFileNames) {
System.out.println("File found: " + fileName);
assertNotNull(fileName);
if (fileName.contains(CLASS_PATH_FILE_TEST)) {
foundTestFile = true;
}
}
assertTrue(foundTestFile);
}
@Test
public void testClasspathFileNamesByExtension() throws ZipException, IOException {
final String[] classPathFileNames = ResourceUtil.getClasspathFileNamesWithExtension(CLASS_PATH_FILE_TEST_EXTENSION);
assertNotNull(classPathFileNames);
assertTrue( classPathFileNames.length > 0 );
boolean foundTestFile = false;
for (final String fileName : classPathFileNames) {
System.out.println("File found: " + fileName);
assertNotNull(fileName);
assertTrue(fileName.endsWith(CLASS_PATH_FILE_TEST_EXTENSION));
if (fileName.contains(CLASS_PATH_FILE_TEST)) {
foundTestFile = true;
}
}
assertTru
```
<Overlap Ratio: 0.9703748488512697>

---

--- 282 --
Question ID: 2c099a0e683aae3b6d6a168dd6848cfb0831c823
Original Code:
```
@Lesson(9)
@ExtendWith({ParameterSupplier.class})
class OperationTest {

    @Test
    void zippingIntMonthIntToLocalDate(final Operations operations) {
        final Flux<Integer> yearFlux = Flux.just(2018, 2018, 2017, 2018);
        final Flux<Month> monthFlux = Flux.just(Month.JANUARY, Month.MARCH, Month.DECEMBER, Month.JANUARY);
        final Flux<Integer> dayOfMonthFlux = Flux.just(2, 30, 31, 17);

        final Flux<LocalDate> flux = operations.zipFluxToLocalDate(yearFlux, monthFlux, dayOfMonthFlux);

        StepVerifier.create(flux)
                .expectSubscription()
                .expectNext(LocalDate.of(2018, Month.JANUARY, 2))
                .expectNext(LocalDate.of(2018, Month.MARCH, 30))
                .expectNext(LocalDate.of(2017, Month.DECEMBER, 31))
                .expectNext(LocalDate.of(2018, Month.JANUARY, 17))
                .verifyComplete();
    }

    @Test
    void fastestMonoValue(final Operations operations) {
        final Mono<String> left = Mono.defer(() -> Mono.delay(Duration.ofSeconds(20L)).map(l -> "foo"));
        final Mono<String> right = Mono.defer(() -> Mono.delay(Duration.ofSeconds(19L)).map(l -> "bar"));
        final Mono<String> mono = operations.fastestMonoValue(left, right);
        StepVerifier.withVirtualTime(() -> mono)
                .thenAwait(Duration.ofSeconds(19L))
                .expectNext("bar")
                .verifyComplete();
                
    }

    @Test
    void firstEmittingNotMixed(final Operations operations) {
        final Flux<String> left = Flux.defer(
                () -> Flux.just("foo", "bar", "baz").delaySequence(Duration.ofSeconds(10L)).delayElements(Duration.ofSeconds(2L)));
        final Flux<String> right = Flux.defer(() -> Flux.interval(Duration.ofSeconds(9L), Duration.ofSeconds(3L)).map(v -> String.format("item-%d", v)).take(3L));
        StepVerifier.withVirtualTime(() -> operations.firstEmittingNotMixed(left, right))
                .expectSubscription()
                .expectNoEvent(Duration.ofSeconds(9L))
                .expectNext("item-0")
                .expectNoEvent(Duration.ofSeconds(3L))
                .expectNext("item-1")
                .expectNoEvent(Duration.ofSeconds(3L))
                .expectNext("item-2")
                .verifyComplete();
    }

    @Test
    void fluxCompletionByThen(final Operations operations) {
        final Flux<Long> flux = Flux.defer(() -> Flux.interval(Duration.ofMillis(30L)).take(10));
        StepVerifier.withVirtualTime(() -> operations.completeWithThen(flux))
                .expectSubscription()
                .expectNoEvent(Duration.ofMillis(30 * 10))
                .verifyComplete();
    }

    @Test
    void nullAwarenessStaticFactoryMethod(final Operations operations) {
        final Mono<String> firstMono = operations.nullAwareMono("foo");
        final Mono<String> secondMono = operations.nullAwareMono(null);
        assertAll(
                () -> StepVerifier.create(firstMono.hasElement()).expectNext(true).verifyComplete(),
                () -> StepVerifier.create(secondMono.hasElement()).expectNext(false).verifyComplete()
        );
    }

    @Test
    void emptyThenBar(final Operations operations) {
        final Mono<String> foo = operations.returnBarWhenEmpty(Mono.just("foo"));
        final Mono<String> bar = operations.returnBarWhenEmpty(Mono.empty());
        assertAll(
                () -> StepVerifier.create(foo).expectNext("foo").verifyComplete(),
                () -> StepVerifier.create(bar).expectNext("bar").verifyComplete()
        );
    }
}
```


Overlapping Code:
```
)
class OperationTest {
@Test
void zippingIntMonthIntToLocalDate(final Operations operations) {
final Flux<Integer> yearFlux = Flux.just(2018, 2018, 2017, 2018);
final Flux<Month> monthFlux = Flux.just(Month.JANUARY, Month.MARCH, Month.DECEMBER, Month.JANUARY);
final Flux<Integer> dayOfMonthFlux = Flux.just(2, 30, 31, 17);
final Flux<LocalDate> flux = operations.zipFluxToLocalDate(yearFlux, monthFlux, dayOfMonthFlux);
StepVerifier.create(flux)
.expectSubscription()
.expectNext(LocalDate.of(2018, Month.JANUARY, 2))
.expectNext(LocalDate.of(2018, Month.MARCH, 30))
.expectNext(LocalDate.of(2017, Month.DECEMBER, 31))
.expectNext(LocalDate.of(2018, Month.JANUARY, 17))
.verifyComplete();
}
@Test
void fastestMonoValue(final Operations operations) {
final Mono<String> left = Mono.defer(() -> Mono.delay(Duration.ofSeconds(20L)).map(l -> "foo"));
final Mono<String> right = Mono.defer(() -> Mono.delay(Duration.ofSeconds(19L)).map(l -> "bar"));
final Mono<String> mono = operations.fastestMonoValue(left, right);
StepVerifier.withVirtualTime(() -> mono)
.thenAwait(Duration.ofSeconds(19L))
.expectNext("bar")
.verifyComplete();

}
@Test
void firstEmittingNotMixed(final Operations operations) {
final Flux<String> left = Flux.defer(
() -> Flux.just("foo", "bar", "baz").delaySequence(Duration.ofSeconds(10L)).delayElements(Duration.ofSeconds(2L)));
final Flux<String> right = Flux.defer(() -> Flux.interval(Duration.ofSeconds(9L), Duration.ofSeconds(3L)).map(v -> String.format("item-%d", v)).take(3L));
StepVerifier.withVirtualTime(() -> operations.firstEmittingNotMixed(left, right))
.expectSubscription()
.expectNoEvent(Duration.ofSeconds(9L))
.expectNext("item-0")
.expectNoEvent(Duration.ofSeconds(3L))
.expectNext("item-1")
.expectNoEvent(Duration.ofSeconds(3L))
.expectNext("item-2")
.verifyComplete();
}
@Test
void fluxCompletionByThen(final Operations operations) {
final Flux<Long> flux = Flux.defer(() -> Flux.interval(Duration.ofMillis(
```
<Overlap Ratio: 0.9591736350221348>

---

--- 283 --
Question ID: fceff7407c9a52eacc1cc268626abc9557ccbc9b
Original Code:
```
public class PreviewRunnerModule extends PrivateModule {
  private final CConfiguration cConf;
  private final AccessEnforcer accessEnforcer;
  private final ContextAccessEnforcer contextAccessEnforcer;
  private final ProgramRuntimeProviderLoader programRuntimeProviderLoader;
  private final ArtifactRepositoryReaderProvider artifactRepositoryReaderProvider;
  private final PluginFinderProvider pluginFinderProvider;
  private final PreferencesFetcherProvider preferencesFetcherProvider;
  private final MessagingService messagingService;

  @Inject
  PreviewRunnerModule(CConfiguration cConf,
                      ArtifactRepositoryReaderProvider readerProvider,
                      AccessEnforcer accessEnforcer,
                      ContextAccessEnforcer contextAccessEnforcer,
                      ProgramRuntimeProviderLoader programRuntimeProviderLoader,
                      PluginFinderProvider pluginFinderProvider,
                      PreferencesFetcherProvider preferencesFetcherProvider,
                      MessagingService messagingService) {
    this.cConf = cConf;
    this.artifactRepositoryReaderProvider = readerProvider;
    this.accessEnforcer = accessEnforcer;
    this.contextAccessEnforcer = contextAccessEnforcer;
    this.programRuntimeProviderLoader = programRuntimeProviderLoader;
    this.pluginFinderProvider = pluginFinderProvider;
    this.preferencesFetcherProvider = preferencesFetcherProvider;
    this.messagingService = messagingService;
  }

  @Override
  protected void configure() {
    Boolean artifactLocalizerEnabled = cConf.getBoolean(Constants.Preview.ARTIFACT_LOCALIZER_ENABLED, false);

    if (artifactLocalizerEnabled) {
      // Use remote implementation to fetch artifact metadata from AppFab.
      // Remote implementation internally uses artifact localizer to fetch and cache artifacts locally.
      bind(ArtifactRepositoryReader.class).to(RemoteArtifactRepositoryReaderWithLocalization.class);
      bind(ArtifactRepository.class).to(RemoteArtifactRepositoryWithLocalization.class);
      expose(ArtifactRepository.class);
      bind(ArtifactRepository.class)
        .annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO))
        .to(RemoteArtifactRepositoryWithLocalization.class)
        .in(Scopes.SINGLETON);
      expose(ArtifactRepository.class).annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO));


      // Use remote implementation to fetch plugin metadata from AppFab.
      // Remote implementation internally uses artifact localizer to fetch and cache artifacts locally.
      bind(PluginFinder.class).to(RemoteWorkerPluginFinder.class);
      expose(PluginFinder.class);

      // Use remote implementation to fetch preferences from AppFab.
      bind(PreferencesFetcher.class).to(RemotePreferencesFetcherInternal.class);
      expose(PreferencesFetcher.class);
    } else {
      bind(ArtifactRepositoryReader.class).toProvider(artifactRepositoryReaderProvider);
      bind(ArtifactRepository.class).to(DefaultArtifactRepository.class);
      expose(ArtifactRepository.class);

      bind(ArtifactRepository.class)
        .annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO))
        .to(DefaultArtifactRepository.class)
        .in(Scopes.SINGLETON);
      expose(ArtifactRepository.class)
        .annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO));

      bind(PluginFinder.class).toProvider(pluginFinderProvider);
      expose(PluginFinder.class);

      bind(PreferencesFetcher.class).toProvider(preferencesFetcherProvider);
      expose(PreferencesFetcher.class);
    }

    bind(MessagingService.class)
      .annotatedWith(Names.named(PreviewConfigModule.GLOBAL_TMS))
      .toInstance(messagingService);
    expose(MessagingService.class).annotatedWith(Names.named(PreviewConfigModule.GLOBAL_TMS));

    bind(AccessEnforcer.class).toInstance(accessEnforcer);
    expose(AccessEnforcer.class);
    bind(ContextAccessEnforcer.class).toInstance(contextAccessEnforcer);
    expose(ContextAccessEnforcer.class);
    // bind explore client to mock.
    bind(ExploreClient.class).to(MockExploreClient.class);
    expose(ExploreClient.class);
    bind(ProgramRuntimeProviderLoader.class).toInstance(programRuntimeProviderLoader);
    expose(ProgramRuntimeProviderLoader.class);
    bind(StorageProviderNamespaceAdmin.class).to(LocalStorageProviderNamespaceAdmin.class);

    bind(PipelineFactory.class).to(SynchronousPipelineFactory.class);

    install(
      new FactoryModuleBuilder()
        .implement(Configurator.class, InMemoryConfigurator.class)
        .build(ConfiguratorFactory.class)
    );
    // expose this binding so program runner modules can use
    expose(ConfiguratorFactory.class);

    bind(InMemoryProgramRunDispatcher.class).in(Scopes.SINGLETON);
    expose(InMemoryProgramRunDispatcher.class);

    install(
      new FactoryModuleBuilder()
        .implement(new TypeLiteral<Manager<AppDeploymentInfo, ApplicationWithPrograms>>() { },
                   new TypeLiteral<PreviewApplicationManager<AppDeploymentInfo, ApplicationWithPrograms>>() { })
        .build(new TypeLiteral<ManagerFactory<AppDeploymentInfo, ApplicationWithPrograms>>() { })
    );

    bind(Store.class).to(DefaultStore.class);
    bind(SecretStore.class).to(DefaultSecretStore.class).in(Scopes.SINGLETON);

    bind(UGIProvider.class).to(DefaultUGIProvider.class);
    expose(UGIProvider.class);

    bind(WorkflowStateWriter.class).to(BasicWorkflowStateWriter.class);
    expose(WorkflowStateWriter.class);

    // we don't delete namespaces in preview as we just delete preview directory when its done
    bind(NamespaceResourceDeleter.class).to(NoopNamespaceResourceDeleter.class).in(Scopes.SINGLETON);
    bind(NamespaceAdmin.class).to(DefaultNamespaceAdmin.class).in(Scopes.SINGLETON);
    bind(NamespaceQueryAdmin.class).to(DefaultNamespaceAdmin.class).in(Scopes.SINGLETON);
    expose(NamespaceAdmin.class);
    expose(NamespaceQueryAdmin.class);

    bind(MetadataAdmin.class).to(DefaultMetadataAdmin.class);
    expose(MetadataAdmin.class);

    bindPreviewRunner(binder());
    expose(PreviewRunner.class);

    bind(Scheduler.class).to(NoOpScheduler.class);

    bind(DataTracerFactory.class).to(DefaultDataTracerFactory.class);
    expose(DataTracerFactory.class);

    bind(PreviewDataPublisher.class).to(MessagingPreviewDataPublisher.class);

    bind(OwnerStore.class).to(DefaultOwnerStore.class);
    expose(OwnerStore.class);
    bind(OwnerAdmin.class).to(DefaultOwnerAdmin.class);
    expose(OwnerAdmin.class);
    
    bind(CapabilityReader.class).to(CapabilityStatusStore.class);
  }

  /**
   * Binds an implementation for {@link PreviewRunner}.
   */
  protected void bindPreviewRunner(Binder binder) {
    binder.bind(PreviewRunner.class).to(DefaultPreviewRunner.class).in(Scopes.SINGLETON);
  }
}
```


Overlapping Code:
```
nnerModule extends PrivateModule {
private final CConfiguration cConf;
private final AccessEnforcer accessEnforcer;
private final ContextAccessEnforcer contextAccessEnforcer;
private final ProgramRuntimeProviderLoader programRuntimeProviderLoader;
private final ArtifactRepositoryReaderProvider artifactRepositoryReaderProvider;
private final PluginFinderProvider pluginFinderProvider;
private final PreferencesFetcherProvider preferencesFetcherProvider;
private final MessagingService messagingService;
@Inject
PreviewRunnerModule(CConfiguration cConf,
ArtifactRepositoryReaderProvider readerProvider,
AccessEnforcer accessEnforcer,
ContextAccessEnforcer contextAccessEnforcer,
ProgramRuntimeProviderLoader programRuntimeProviderLoader,
PluginFinderProvider pluginFinderProvider,
PreferencesFetcherProvider preferencesFetcherProvider,
MessagingService messagingService) {
this.cConf = cConf;
this.artifactRepositoryReaderProvider = readerProvider;
this.accessEnforcer = accessEnforcer;
this.contextAccessEnforcer = contextAccessEnforcer;
this.programRuntimeProviderLoader = programRuntimeProviderLoader;
this.pluginFinderProvider = pluginFinderProvider;
this.preferencesFetcherProvider = preferencesFetcherProvider;
this.messagingService = messagingService;
}
@Override
protected void configure() {
Boolean artifactLocalizerEnabled = cConf.getBoolean(Constants.Preview.ARTIFACT_LOCALIZER_ENABLED, false);
if (artifactLocalizerEnabled) {
// Use remote implementation to fetch artifact metadata from AppFab.
// Remote implementation internally uses artifact localizer to fetch and cache artifacts locally.
bind(ArtifactRepositoryReader.class).to(RemoteArtifactRepositoryReaderWithLocalization.class);
bind(ArtifactRepository.class).to(RemoteArtifactRepositoryWithLocalization.class);
expose(ArtifactRepository.class);
bind(ArtifactRepository.class)
.annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO))
.to(RemoteArtifactRepositoryWithLocalization.class)
.in(Scopes.SINGLETON);
expose(ArtifactRepository.class).annotatedWith(Names.named(AppFabricServiceRuntimeModule.NOAUTH_ARTIFACT_REPO));
// Use remote implementation to fe
```
<Overlap Ratio: 0.9763851044504995>

---

--- 284 --
Question ID: bfa21c6287378aad25b269bc6fd85bd158537822
Original Code:
```
@RestController
public class OrderController {

	@Autowired
	private OrderRepository orders;

	@Autowired
	private OrdersSource orderSource;

	@Value("${originator}")
	private String originator;

	@RequestMapping(value = "/orders", method = RequestMethod.GET, produces = { "application/json" })
	@ResponseStatus(HttpStatus.OK)
	public Iterable<Order> getOrder() {

		Iterable<Order> orderList = orders.findAll();

		return orderList;
	}

	@RequestMapping(method = RequestMethod.POST)
	public ResponseEntity<Order> add(@RequestBody Order input) {

		orders.save(input);

		// place order on Kinesis Stream
		orderSource.sendOrder(new Event(input, "ORDER", originator));

		return new ResponseEntity<Order>(input, HttpStatus.OK);
	}

}
```


Overlapping Code:
```
@RestController
public class OrderController {
@Autowired
private OrderRepository orders;
@Autowired
private OrdersSource orderSource;
@Value("${originator}")
private String originator;
@RequestMapping(value = "/orders", method = RequestMethod.GET, produces = { "application/json" })
@ResponseStatus(HttpStatus.OK)
public Iterable<Order> getOrder() {
Iterable<Order> orderList = orders.findAll();
return orderList;
}
@RequestMapping(method = RequestMethod.POST)
public ResponseEntity<Order> add(@RequestBody Order input) {
orders.save(input);
// place order on Kinesis Stream
orderSource.sendOrder(new Event(input, "ORDER", originator));
return new ResponseEntity<Order>(input, HttpStatus.OK)
```
<Overlap Ratio: 0.9928263988522238>

---

--- 285 --
Question ID: c6a08d4506d7ebc848c69ed35ec4d8bff5bec70b
Original Code:
```
public class SQLScriptGenerator {
 
    public static void main(String[] args) throws MappingException, IOException {
    	
    	String createSQLFile = "dbscripts/createTables.sql";
    	String dropSQLFile = "dbscripts/dropTables.sql";
    	String hibernateCfgFile = "/db/hibernate.cfg.xml";
    	
    	final EnumSet<TargetType> targetTypes = EnumSet.noneOf( TargetType.class );
		targetTypes.add(TargetType.SCRIPT);
    	
		System.out.println("Initialize Hibernate configuration from " + hibernateCfgFile );
		
    	Configuration cfg = new Configuration().configure(hibernateCfgFile);
    	Metadata metadata = MetadataHelper.getMetadata(cfg);
    	
    	SchemaExport export = new SchemaExport();
		export.setHaltOnError(true);
		export.setFormat(true);
		export.setDelimiter(";");
		
		System.out.println("Generating create SQL to file " + createSQLFile );
		if ( new File(createSQLFile).exists() ) {
			Files.delete(Paths.get(createSQLFile));
		}
		export.setOutputFile(createSQLFile);
		export.execute(targetTypes, Action.CREATE, metadata);
		
		System.out.println("Generating drop SQL to file " + dropSQLFile );
		export.setOutputFile(dropSQLFile);
		if ( new File(dropSQLFile).exists() ) {
			Files.delete(Paths.get(dropSQLFile));
		}
		export.execute(targetTypes, Action.DROP, metadata);

		System.out.println("Done!");
	}
}
```


Overlapping Code:
```
Generator {

public static void main(String[] args) throws MappingException, IOException {

String createSQLFile = "dbscripts/createTables.sql";
String dropSQLFile = "dbscripts/dropTables.sql";
String hibernateCfgFile = "/db/hibernate.cfg.xml";

final EnumSet<TargetType> targetTypes = EnumSet.noneOf( TargetType.class );
targetTypes.add(TargetType.SCRIPT);

System.out.println("Initialize Hibernate configuration from " + hibernateCfgFile );

Configuration cfg = new Configuration().configure(hibernateCfgFile);
Metadata metadata = MetadataHelper.getMetadata(cfg);

SchemaExport export = new SchemaExport();
export.setHaltOnError(true);
export.setFormat(true);
export.setDelimiter(";");

System.out.println("Generating create SQL to file " + createSQLFile );
if ( new File(createSQLFile).exists() ) {
Files.delete(Paths.get(createSQLFile));
}
export.setOutputFile(createSQLFile);
export.execute(targetTypes, Action.CREATE, metadata);

System.out.println("Generating drop SQL to file " + dropSQLFile );
export.setOutputFile(dropSQLFile);
if ( new File(dropSQLFile).exists() ) {
Files.delete(Paths.get(dropSQLFile));
}
export.execute(targetTypes, Action.D
```
<Overlap Ratio: 0.9428104575163399>

---

--- 286 --
Question ID: 3daece8ff6647364edea3069ff398ca62b9589ce
Original Code:
```
@JsonInclude(JsonInclude.Include.NON_NULL)
@Entity
@Table(name = "USER_DETAILS")
public class UserDetailsDAO extends AbstractIdentityDAO {

    @Column(name = "USER_ID")
    private String userName;

    @Column(name = "USER_PASSWORD")
    private String password;

    @Column(name = "USER_FIRST_NAME")
    private String userFirstName;

    @Column(name = "USER_LAST_NAME")
    private String userLastName;

    @Column(name = "USER_LAST_LOGIN")
    private Date lastSignInTime;

    @Column(name = "USER_ADDRESS")
    private String userAddress;

    @Column(name = "USER_CITY")
    private String userCity;

    @Column(name = "USER_PINCODE")
    private Integer userPostalCode;

    @Column(name = "USER_STATE")
    private String userState;

    @Column(name = "USER_COUNTRY")
    private String userCountry;

    private UserDetailsDAO() {

    }

    private UserDetailsDAO(Builder builder) {
        setId(builder.id);
        setUserName(builder.userName);
        setPassword(builder.password);
        setUserFirstName(builder.userFirstName);
        setUserLastName(builder.userLastName);
        setLastSignInTime(builder.lastSignInTime);
        setUserAddress(builder.userAddress);
        setUserCity(builder.userCity);
        setUserPostalCode(builder.userPostalCode);
        setUserState(builder.userState);
        setUserCountry(builder.userCountry);
    }

    public static Builder newBuilder() {
        return new Builder();
    }

    public static Builder newAddUserBuilder(UserDTO userDTo) {
        java.sql.Date sqlDate = new java.sql.Date(Calendar.getInstance().getTime().getTime());
        Builder builder = new Builder();
        builder.userName = userDTo.getUserName();
        builder.password = userDTo.getPassword();
        builder.userFirstName = userDTo.getUserFirstName();
        builder.userLastName = userDTo.getUserLastName();
        builder.userAddress = userDTo.getUserAddress();
        builder.userPostalCode = userDTo.getUserPostalCode();
        builder.userCity = userDTo.getUserCity();
        builder.userState = userDTo.getUserState();
        builder.userCountry = userDTo.getUserCountry();
        builder.lastSignInTime = sqlDate;
        return builder;
    }


    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getUserFirstName() {
        return userFirstName;
    }

    public void setUserFirstName(String userFirstName) {
        this.userFirstName = userFirstName;
    }

    public String getUserLastName() {
        return userLastName;
    }

    public void setUserLastName(String userLastName) {
        this.userLastName = userLastName;
    }

    public Date getLastSignInTime() {
        return lastSignInTime;
    }

    public void setLastSignInTime(Date lastSignInTime) {
        this.lastSignInTime = lastSignInTime;
    }

    public String getUserAddress() {
        return userAddress;
    }

    public void setUserAddress(String userAddress) {
        this.userAddress = userAddress;
    }

    public String getUserCity() {
        return userCity;
    }

    public void setUserCity(String userCity) {
        this.userCity = userCity;
    }

    public Integer getUserPostalCode() {
        return userPostalCode;
    }

    public void setUserPostalCode(Integer userPostalCode) {
        this.userPostalCode = userPostalCode;
    }

    public String getUserState() {
        return userState;
    }

    public void setUserState(String userState) {
        this.userState = userState;
    }

    public String getUserCountry() {
        return userCountry;
    }

    public void setUserCountry(String userCountry) {
        this.userCountry = userCountry;
    }


    public static final class Builder {
        private Integer id;
        private String userName;
        private String password;
        private String userFirstName;
        private String userLastName;
        private Date lastSignInTime;
        private String userAddress;
        private String userCity;
        private Integer userPostalCode;
        private String userState;
        private String userCountry;

        private Builder() {
        }

        public Builder withId(Integer id) {
            this.id = id;
            return this;
        }

        public Builder withUserName(String userName) {
            this.userName = userName;
            return this;
        }

        public Builder withPassword(String password) {
            this.password = password;
            return this;
        }

        public Builder withUserFirstName(String userFirstName) {
            this.userFirstName = userFirstName;
            return this;
        }

        public Builder withUserLastName(String userLastName) {
            this.userLastName = userLastName;
            return this;
        }

        public Builder withLastSignInTime(Date lastSignInTime) {
            this.lastSignInTime = lastSignInTime;
            return this;
        }

        public Builder withUserAddress(String userAddress) {
            this.userAddress = userAddress;
            return this;
        }

        public Builder withUserCity(String userCity) {
            this.userCity = userCity;
            return this;
        }

        public Builder withUserPostalCode(Integer userPostalCode) {
            this.userPostalCode = userPostalCode;
            return this;
        }

        public Builder withUserState(String userState) {
            this.userState = userState;
            return this;
        }

        public Builder withUserCountry(String userCountry) {
            this.userCountry = userCountry;
            return this;
        }

        public UserDetailsDAO build() {
            return new UserDetailsDAO(this);
        }
    }
}
```


Overlapping Code:
```
@JsonInclude(JsonInclude.Include.NON_NULL)
@Entity
@Table(name = "USER_DETAILS")
public class UserDetailsDAO extends AbstractIdentityDAO {
@Column(name = "USER_ID")
private String userName;
@Column(name = "USER_PASSWORD")
private String password;
@Column(name = "USER_FIRST_NAME")
private String userFirstName;
@Column(name = "USER_LAST_NAME")
private String userLastName;
@Column(name = "USER_LAST_LOGIN")
private Date lastSignInTime;
@Column(name = "USER_ADDRESS")
private String userAddress;
@Column(name = "USER_CITY")
private String userCity;
@Column(name = "USER_PINCODE")
private Integer userPostalCode;
@Column(name = "USER_STATE")
private String userState;
@Column(name = "USER_COUNTRY")
private String userCountry;
private UserDetailsDAO() {
}
private UserDetailsDAO(Builder builder) {
setId(builder.id);
setUserName(builder.userName);
setPassword(builder.password);
setUserFirstName(builder.userFirstName);
setUserLastName(builder.userLastName);
setLastSignInTime(builder.lastSignInTime);
setUserAddress(builder.userAddress);
setUserCity(builder.userCity);
setUserPostalCode(builder.userPostalCode);
setUserState(builder.userState);
setUserCountry(builder.userCountry);
}
public static Builder newBuilder() {
return new Builder();
}
public static Builder newAddUserBuilder(UserDTO userDTo) {
java.sql.Date sqlDate = new java.sql.Date(Calendar.getInstance().getTime().getTime());
Builder builder = new Builder();
builder.userName = userDTo.getUserName();
builder.passTo.getUserFirstName();
builder.userLastName = userDTo.getUserLastName();
builder.userAddress = userDTo.getUserAddress();
builder.userPostalCode = userDTo.getUserPostalCode();
builder.userCity = userDTo.getUserCity();
builder.userState = userDTo.getUserState();
builder.userCountry = userDTo.getUserCountry();
builder.lastSignInTime = sqlDate;
return builder;
}
public String getUserName() {
return userName;
}
public void setUserName(String userName) {
this.userName = userName;
}
public String getPassword() {
return password;
}
public void setPassword(String password) {
```
<Overlap Ratio: 0.972011385199241>

---

--- 287 --
Question ID: 03a0534138b293b8d67ff732c39550ea5e768c2d
Original Code:
```
public class RssTask extends AsyncTask<URL, Integer, ArrayList<Article>>
{
    private final static String TAG = "Download Task";
    private ArticleListActivity mCallback;

    public RssTask(ArticleListActivity callback)
    {
        mCallback = callback;
    }

    @Override
    protected void onPreExecute()
    {
        Log.d(TAG, "Sync started");
        /*
        Intent intent = new Intent();
        intent.setAction(MainActivity.SYNC_START);
        mAcitivity.sendOrderedBroadcast(intent, null);
        */
    }

    @Override
    protected ArrayList<Article> doInBackground(URL... params)
    {
        RssHandler rh = new RssHandler();

        try
        {
            SAXParserFactory spf = SAXParserFactory.newInstance();
            SAXParser sp;
            sp = spf.newSAXParser();
            XMLReader xr = sp.getXMLReader();

            xr.setContentHandler(rh);
            xr.parse(new InputSource(params[0].openStream()));
        } catch (ParserConfigurationException e)
        {
            e.printStackTrace();
        } catch (SAXException e)
        {
            e.printStackTrace();
        } catch (IOException e)
        {
            e.printStackTrace();
        }

        return rh.articleList;
    }

    protected void onPostExecute(ArrayList<Article> articles)
    {
        mCallback.onFetchArticles(articles);

        Log.d(TAG, "Sync ended");

        /*
        mArticles.clear();
        mArticles.addAll(articles);
        mAdapter.notifyDataSetChanged();

        Intent intent = new Intent();
        intent.setAction(MainActivity.SYNC_DONE);

        try
        {
            getActivity().sendOrderedBroadcast(intent, null);
        } catch (NullPointerException e)
        {
            // Om man kommer hit så har användaren avslutat applikationen
            // och denna async-task kan inte längre greppa 'current
            // activity'.
        }
        */
    }
}
```


Overlapping Code:
```
cTask<URL, Integer, ArrayList<Article>>
{
private final static String TAG = "Download Task";
private ArticleListActivity mCallback;
public RssTask(ArticleListActivity callback)
{
mCallback = callback;
}
@Override
protected void onPreExecute()
{
Log.d(TAG, "Sync started");
/*
Intent intent = new Intent();
intent.setAction(MainActivity.SYNC_START);
mAcitivity.sendOrderedBroadcast(intent, null);
*/
}
@Override
protected ArrayList<Article> doInBackground(URL... params)
{
RssHandler rh = new RssHandler();
try
{
SAXParserFactory spf = SAXParserFactory.newInstance();
SAXParser sp;
sp = spf.newSAXParser();
XMLReader xr = sp.getXMLReader();
xr.setContentHandler(rh);
xr.parse(new InputSource(params[0].openStream()));
} catch (ParserConfigurationException e)
{
e.printStackTrace();
} catch (SAXException e)
{
e.printStackTrace();
} catch (IOException e)
{
e.printStackTrace();
}
return rh.articleList;
}
protected void onPostExecute(ArrayList<Article> articles)
{
mCallback.onFetchArticles(articles);
Log.d(TAG, "Sync ended");
/*
mArticles.clear();
mArticles.addAll(articles);
mAdapter.notifyDataSetChanged();
Intent intent = new Intent();
intent.setAction(MainActivity.SYNC_DONE);
try
{
getActivity().sendOrderedBroadcast(intent, null);
} catch (NullPointerException e)
{
// Om man kommer hit så har användaren avslutat applikationen
// och denna async-task kan inte längre greppa 'current
// activit
```
<Overlap Ratio: 0.9688581314878892>

---

--- 288 --
Question ID: 00f5c7f8d4c96ef6669bf721485a9f705880267a
Original Code:
```
public class AppSearchUtils {
    public AppSearchUtils() {
    }

    @SuppressLint({"InlinedApi"})
    public static void invokeAppSearch(Context context) {
        TagRecorder.onTag(context, Tag.newInstance(30));
        Intent intent = new Intent("com.baidu.appsearch.extinvoker.LAUNCH");
        intent.putExtra("backop", "0");
        intent.putExtra("id", context.getPackageName());
        intent.putExtra("func", "10");
        intent.putExtra("pkg", context.getPackageName());
        intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        context.startActivity(intent);
    }

    public static boolean canAsUpdate(Context context) {
        try {
            int versioncode = context.getPackageManager().getPackageInfo("com.baidu.appsearch", PackageManager.GET_SIGNATURES).versionCode;
            if (versioncode > 16782394) {
                return true;
            }
        } catch (NameNotFoundException var2) {
//            LogUtils.printE(var2.getMessage());
        }

        return false;
    }
}
```


Overlapping Code:
```
blic AppSearchUtils() {
}
@SuppressLint({"InlinedApi"})
public static void invokeAppSearch(Context context) {
TagRecorder.onTag(context, Tag.newInstance(30));
Intent intent = new Intent("com.baidu.appsearch.extinvoker.LAUNCH");
intent.putExtra("backop", "0");
intent.putExtra("id", context.getPackageName());
intent.putExtra("func", "10");
intent.putExtra("pkg", context.getPackageName());
intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
context.startActivity(intent);
}
public static boolean canAsUpdate(Context context) {
try {
int versioncode = context.getPackageManager().getPackageInfo("com.baidu.appsearch", PackageManager.GET_SIGNATURES).versionCode;
if (versioncode > 16782394) {
return true;
}
} catch (NameNotFoundException var2) {
// LogUtils.printE(var2.getMessage());
}
return false
```
<Overlap Ratio: 0.9582863585118376>

---

--- 289 --
Question ID: 4cf2b02648798413dbfd2bef7368b982b182d53a
Original Code:
```
public class StatisticsPersisterTest {

    private ObservationsRepository repository;

    @BeforeMethod
    public void setUp() throws Exception {
        repository = mock(ObservationsRepository.class);

    }

    @Test
    public void testStartScheduler() throws Exception {
        StatisticsPersister persister = new StatisticsPersister(1,1,3);
        persister.startScheduler(repository, "testprefix");
        Thread.sleep(1500);
        verify(repository).persistAndResetStatistics(eq("testprefix"), eq(1L));

    }


}
```


Overlapping Code:
```
icsPersisterTest {
private ObservationsRepository repository;
@BeforeMethod
public void setUp() throws Exception {
repository = mock(ObservationsRepository.class);
}
@Test
public void testStartScheduler() throws Exception {
StatisticsPersister persister = new StatisticsPersister(1,1,3);
persister.startScheduler(repository, "testprefix");
Thread.sleep(1500);
verify(repository).persistAndResetStatis
```
<Overlap Ratio: 0.8791208791208791>

---

--- 290 --
Question ID: 7a8070a7512549a8df51b8c467b75d3b783f8d84
Original Code:
```
public class MathUtil {

    public static float roundToTick(double value, float tick) {
        if (tick <= 0) {
            return (float) value;
        }

        float tickMod = tick * 100;
        float round = Math.round( ( value * 100 )/ (tickMod)) * (tickMod);
        return round / 100;
    }

}
```


Overlapping Code:
```
public static float roundToTick(double value, float tick) {
if (tick <= 0) {
return (float) value;
}
float tickMod = tick * 100;
float round = Math.round( ( value * 100 )/ (tickMod)) * (tickMod);
return round / 
```
<Overlap Ratio: 0.8683127572016461>

---

--- 291 --
Question ID: 272d4fe4c1ada43e98084850e2683d0a9b2b6540
Original Code:
```
public class SethomeCommand extends Executor{
	
	private static final FileConfiguration cfg = Main.getInstance().getConfig();

	public SethomeCommand() {
		super(cfg.getString("commands.sethome.name"), 
				cfg.getString("commands.sethome.description"), 
				cfg.getString("commands.sethome.usage"), "sethome", 
				cfg.getStringList("commands.sethome.aliases"), true);
		
	}

	@Override
	public void onExecute(CommandSender sender, String[] args) {
		Player p = (Player)sender;
		User u = User.get(p);
		if(!u.hasGuild()){
			Util.sendMessage(p, Messages.PlayerDontHasGuild);
			return;
		}
		Guild g = u.getGuild();
		Region r = RegionManager.inWhich(p.getLocation());
		if(!(r == g.getRegion())) {
			Util.sendMessage(p, Messages.PlayerMustBeInGuild);
			return;
		}
		Location loc = p.getLocation();
		g.setHome(loc);
		g.save();
		DataManager.reload(false, false);
		Util.sendMessage(p, Messages.SethomeSuccess);
		return;
	}

}
```


Overlapping Code:
```
Command extends Executor{

private static final FileConfiguration cfg = Main.getInstance().getConfig();
public SethomeCommand() {
super(cfg.getString("commands.sethome.name"), 
cfg.getString("commands.sethome.description"), 
cfg.getString("commands.sethome.usage"), "sethome", 
cfg.getStringList("commands.sethome.aliases"), true);

}
@Override
public void onExecute(CommandSender sender, String[] args) {
Player p = (Player)sender;
User u = User.get(p);
if(!u.hasGuild()){
Util.sendMessage(p, Messages.PlayerDontHasGuild);
return;
}
Guild g = u.getGuild();
Region r = RegionManager.inWhich(p.getLocation());
if(!(r == g.getRegion())) {
Util.sendMessage(p, Messages.PlayerMustBeInGuild);
return;
}
Location loc = p.getLocation();
g.setHome(loc);
g.save();
DataManager.reload(false, false);
Util.sendMessage(p, Messages.Se
```
<Overlap Ratio: 0.9469434832756632>

---

--- 292 --
Question ID: 56ac7189dbc7efdaf48ea200097259ddff2f760d
Original Code:
```
public
class GeneAnnotator extends GazetteerAnnotator {
  /** The URI of this Annotator (namespace and ID are defined dynamically). */
  @SuppressWarnings("hiding")
  public static final String URI = GeneAnnotator.class.getName();
  public static final String PARAM_TAXA_ANNOTATOR_URI = "TaxaAnnotatorUri";
  @ConfigurationParameter(name = PARAM_TAXA_ANNOTATOR_URI,
                          description = "The annotator URI that made the taxon ID annotations.")
  private String taxaAnnotatorUri;
  public static final String PARAM_TAXA_NAMESPACE = "TaxaNamespace";
  @ConfigurationParameter(name = PARAM_TAXA_NAMESPACE,
                          description = "The NS in which the taxon ID annotations were made.")
  private String taxaNamespace;
  /** A mapping of taxonmic IDs to another. */
  public static final String MODEL_KEY_TAX_ID_MAPPING_RESOURCE = "TaxIdMappingResource";
  @ExternalResource(key = MODEL_KEY_TAX_ID_MAPPING_RESOURCE, mandatory = false)
  LineBasedStringMapResource<String> taxIdMapping;
  /** The name of the property used to set the taxon ID of the matched gene name. */
  public static final String TAX_ID_PROPERTY = "taxon";
  private int counter = 0;

  public static
  class Builder extends GazetteerAnnotator.Builder {
    Builder(String entityNamespace, ExternalResourceDescription geneGazetteerResourceDescription) {
      super(GeneAnnotator.class, entityNamespace, geneGazetteerResourceDescription);
    }

    /** Set the annotator URI of taxa annotations to use for filtering annotations. */
    public
    Builder setTaxaAnnotatorUri(String uri) {
      setOptionalParameter(PARAM_TAXA_ANNOTATOR_URI, uri);
      return this;
    }

    /** Set the namespace of taxa annotations to use for filtering annotations. */
    public
    Builder setTaxaNamespace(String ns) {
      setOptionalParameter(PARAM_TAXA_NAMESPACE, ns);
      return this;
    }

    /**
     * Supply a {@link LineBasedStringMapResource} that maps taxonomic IDs to another.
     * <p/>
     * If set, all Tax IDs with a matching key in this resource will instead be annotated with the
     * mapped target Tax ID.
     */
    public
    Builder setTaxIdMappingResource(ExternalResourceDescription desc) {
      setOptionalParameter(MODEL_KEY_TAX_ID_MAPPING_RESOURCE, desc);
      return this;
    }
  }

  /**
   * Create a new gazetteer configuration builder with a pre-configured gazetteer resource.
   *
   * @param entityNamespace to use for the {@link SemanticAnnotation SemanticAnnotations} of the
   *                        entity DB IDs
   * @param geneGazetteerResourceDescription
   *                        a pre-configured {@link GnamedGazetteerResource} description.
   */
  public static
  Builder configure(String entityNamespace,
                    ExternalResourceDescription geneGazetteerResourceDescription) {
    return new Builder(entityNamespace, geneGazetteerResourceDescription);
  }

  @Override
  public
  void initialize(UimaContext ctx) throws ResourceInitializationException {
    super.initialize(ctx);
    if (taxIdMapping != null && taxIdMapping.size() > 0) logger.log(
        Level.CONFIG, "{0} TaxID mappings provided to {1} Gazetteer", new Object[] {
        taxIdMapping.size(), entityNamespace
    }
    );
    counter = 0;
  }

  @Override
  public
  void process(JCas jcas) throws AnalysisEngineProcessException {
    List<SemanticAnnotation> buffer = new LinkedList<SemanticAnnotation>();
    Set<String> annotatedTaxa = getAnnotatedTaxa(jcas);
    if (textNamespace == null && textIdentifier == null) {
      String docText = jcas.getDocumentText();
      Map<Offset, List<String>> matches = gazetteer.match(docText);
      for (Offset offset : matches.keySet()) {
        String match = docText.substring(offset.start(), offset.end());
        if (filter.process(match))
          taxonFilter(jcas, buffer, match, offset, matches.get(offset), annotatedTaxa);
      }
    } else {
      FSMatchConstraint cons = TextAnnotation.makeConstraint(
          jcas, null, textNamespace, textIdentifier
      );
      FSIterator<Annotation> it = TextAnnotation.getIterator(jcas);
      it = jcas.createFilteredIterator(it, cons);
      while (it.hasNext()) {
        // findEntities -> annotateEntities
        Annotation ann = it.next();
        String text = ann.getCoveredText();
        Map<Offset, List<String>> matches = gazetteer.match(text);
        int annBegin = ann.getBegin();
        for (Offset offset : matches.keySet()) {
          String match = text.substring(offset.start(), offset.end());
          if (filter.process(match)) taxonFilter(
              jcas, buffer, match, new Offset(
              annBegin + offset.start(), annBegin + offset.end()
          ), matches.get(offset), annotatedTaxa
          );
        }
      }
    }
    for (SemanticAnnotation ann : buffer)
      ann.addToIndexes();
    logger.log(
        Level.FINE, "tagged {0} potential {1} genes", new Object[] {buffer.size(), entityNamespace}
    );
    counter += buffer.size();
  }

  @Override
  public
  void destroy() {
    super.destroy();
    logger.log(
        Level.CONFIG, "made {0} [potential] {1} gene annoations",
        new Object[] {counter, entityNamespace}
    );
  }

  /** Annotate the match if the taxon matches or if there is no taxon filter in use. */
  private
  void taxonFilter(JCas jcas, List<SemanticAnnotation> buffer, String match, Offset offset,
                   List<String> ids, Set<String> annotatedTaxa) {
    for (String id : ids) {
      if (annotatedTaxa == null || annotatedTaxa.contains(getTaxId(id))) {
        SemanticAnnotation ann = makeAnnotation(jcas, match, id, offset);
        if (ann != null) buffer.add(ann);
      } else {
        logger.log(Level.FINER, "taxon-filtered match ''{0}'' for {1}", new String[] {match, id});
      }
    }
  }

  /** Expands the parent method, adding a taxon ID property to the annotation. */
  @Override
  protected
  SemanticAnnotation annotate(String id, JCas jcas, Offset offset, double confidence, String name) {
    SemanticAnnotation entity = super.annotate(id, jcas, offset, confidence, name);
    entity.setAnnotator(URI); // update with static URI
    Property taxId = new Property(jcas);
    taxId.setName(TAX_ID_PROPERTY);
    taxId.setValue(getTaxId(id));
    entity.addProperty(jcas, taxId);
    return entity;
  }

  /** Get all annotated taxa on this SOFA. */
  private
  Set<String> getAnnotatedTaxa(JCas jcas) {
    Set<String> annotatedTaxa = null;
    if (taxaAnnotatorUri != null || taxaNamespace != null) {
      annotatedTaxa = new HashSet<String>();
      FSIterator<Annotation> iter = jcas.createFilteredIterator(
          SemanticAnnotation.getIterator(jcas),
          SemanticAnnotation.makeConstraint(jcas, taxaAnnotatorUri, taxaNamespace)
      );
      while (iter.hasNext()) annotatedTaxa.add(((SemanticAnnotation) iter.next()).getIdentifier());
      for (String taxId : annotatedTaxa)
        logger.log(Level.FINER, "(taxon-filtering) detected taxId={0}", taxId);
      if (annotatedTaxa.size() == 0) annotatedTaxa = null;
    }
    return annotatedTaxa;
  }

  /** Fetches the taxon from the {@link GnamedGazetteerResource gnamed gazetteer}. */
  private
  String getTaxId(String id) {
    String tid = ((GnamedGazetteerResource) gazetteer).getTaxId(id);
    if (taxIdMapping != null && taxIdMapping.containsKey(tid)) tid = taxIdMapping.get(tid);
    return tid;
  }
}
```


Overlapping Code:
```
ic
class GeneAnnotator extends GazetteerAnnotator {
/** The URI of this Annotator (namespace and ID are defined dynamically). */
@SuppressWarnings("hiding")
public static final String URI = GeneAnnotator.class.getName();
public static final String PARAM_TAXA_ANNOTATOR_URI = "TaxaAnnotatorUri";
@ConfigurationParameter(name = PARAM_TAXA_ANNOTATOR_URI,
description = "The annotator URI that made the taxon ID annotations.")
private String taxaAnnotatorUri;
public static final String PARAM_TAXA_NAMESPACE = "TaxaNamespace";
@ConfigurationParameter(name = PARAM_TAXA_NAMESPACE,
description = "The NS in which the taxon ID annotations were made.")
private String taxaNamespace;
/** A mapping of taxonmic IDs to another. */
public static final String MODEL_KEY_TAX_ID_MAPPING_RESOURCE = "TaxIdMappingResource";
@ExternalResource(key = MODEL_KEY_TAX_ID_MAPPING_RESOURCE, mandatory = false)
LineBasedStringMapResource<String> taxIdMapping;
/** The name of the property used to set the taxon ID of the matched gene name. */
public static final String TAX_ID_PROPERTY = "taxon";
private int counter = 0;
public static
class Builder extends GazetteerAnnotator.Builder {
Builder(String entityNamespace, ExternalResourceDescription geneGazetteerResourceDescription) {
super(GeneAnnotator.class, entityNamespace, geneGazetteerResourceDescription);
}
/** Set the annotator URI of taxa annotations to use for filtering annotations. */
public
Builder setTaxaAnnotatorUri(String uri) {
setOptionalParameter(PARAM_TAXA_ANNOTATOR_URI, uri);
return this;
}
/** Set the namespace of taxa annotations to use for filtering annotations. */
public
Builder setTaxaNamespace(String ns) {
setOptionalParameter(PARAM_TAXA_NAMESPACE, ns);
return this;
}
/**
* Supply a {@link LineBasedStringMapResource} that maps taxonomic IDs to another.
* <p/>
* If set, all Tax IDs with a matching key in this resource will instead be annotated with the
* mapped target Tax ID.
*/
public
Builder setTaxIdMappingResource(ExternalResourceDescription desc) {
setOptionalParameter(MODEL_KEY_TAX_ID_MAPPING_RESOURCE, desc);
return this;
}
}
/**
* Create a new gazetteer configuration builder with a pre-configured gazetteer resource.
*
* @param entityNamespace to use for the {@link SemanticAnnotation SemanticAnn
```
<Overlap Ratio: 0.9982378854625551>

---

--- 293 --
Question ID: 71c33504e313b023fee4bf56e1192b96a39ba56d
Original Code:
```
public class StringTest {
    public static void main(String[] args) {
        String a = "a"; //1个字节
        String b = "中";//3
        String c = "1";//1
        String d = "a中1";//5
        String e = "aa11";//4
        System.out.println(a.getBytes().length);
        System.out.println(b.getBytes().length);
        System.out.println(c.getBytes().length);
        System.out.println(d.getBytes().length);
        System.out.println(e.getBytes().length);
        System.out.println(Charset.defaultCharset()); //UTF-8
    }


    public void test0() {
        System.out.println("abc" == "abc"); //true
        System.out.println("abc".equals("abc")); //true
        System.out.println(System.identityHashCode(new String("abc"))); //1555009629
        System.out.println(System.identityHashCode(new String("abc"))); //41359092
        System.out.println(System.identityHashCode(new String("abc").intern())); //149928006
        System.out.println(System.identityHashCode("abc")); //149928006
    }


}
```


Overlapping Code:
```
public class StringTest {
public static void main(String[] args) {
String a = "a"; //1个字节
String b = "中";//3
String c = "1";//1
String d = "a中1";//5
String e = "aa11";//4
System.out.println(a.getBytes().length);
System.out.println(b.getBytes().length);
System.out.println(c.getBytes().length);
System.out.println(d.getBytes().length);
System.out.println(e.getBytes().length);
System.out.println(Charset.defaultCharset()); //UTF-8
}
public void test0() {
System.out.println("abc" == "abc"); //true
System.out.println("abc".equals("abc")); //true
System.out.println(System.identityHashCode(new String("abc"))); //1555009629
System.out.println(System.identityHashCode(new String("abc"))); //41359092
System.out.println(System.identityHashCode(new String("abc").intern())); //149928006
System.out.println(System.identityHashCode("abc")); //149928006
```
<Overlap Ratio: 0.9952885747938751>

---

--- 294 --
Question ID: 80aac1ac43b4f28347da6386a249e4e082bc6f92
Original Code:
```
@SuppressWarnings("deprecation")
public class NetconfChangeListener implements ClusteredDataTreeChangeListener<Node>, AutoCloseable {

    private static final Logger LOG = LoggerFactory.getLogger(NetconfChangeListener.class);

    private static final InstanceIdentifier<Node> NETCONF_NODE_TOPO_IID =
            InstanceIdentifier.create(NetworkTopology.class)
                    .child(Topology.class, new TopologyKey(new TopologyId(TopologyNetconf.QNAME.getLocalName())))
                    .child(Node.class);
    // Name of ODL controller NETCONF instance
    private static final String CONTROLLER = "controller-config";

    private final DeviceManagerService deviceManagerService;
    private final DataBroker dataBroker;
    private ListenerRegistration<NetconfChangeListener> dlcReg;

    public NetconfChangeListener(DeviceManagerService deviceManagerService, DataBroker dataBroker) {
        this.deviceManagerService = deviceManagerService;
        this.dataBroker = dataBroker;
    }

    public void register() {
        DataTreeIdentifier<Node> treeId = new DataTreeIdentifier<>(LogicalDatastoreType.OPERATIONAL, NETCONF_NODE_TOPO_IID);

        dlcReg = dataBroker.registerDataTreeChangeListener(treeId, this);
    }

    @Override
    public void close() {
        if (dlcReg != null) {
            dlcReg.close();
        }
    }
    /*---------------------------------------------------------------------------
     * Listener
     */
    @Override
    public void onDataTreeChanged(Collection<DataTreeModification<Node>> changes) {
        LOG.debug("OnDataChange, TreeChange, changes:{}", changes.size());

        for (final DataTreeModification<Node> change : changes) {
            final DataObjectModification<Node> root = change.getRootNode();
            final ModificationType modificationType = root.getModificationType();
            if (LOG.isTraceEnabled()) {
                LOG.trace("Handle this modificationType:{} path:{} root:{}", modificationType, change.getRootPath(),
                        root);
            }
            switch (modificationType) {
                case SUBTREE_MODIFIED:
                    // Change of subtree information
                    // update(change); OLD
                    doProcessing(Action.UPDATE, root.getDataAfter());
                    break;
                case WRITE:
                    // Create or modify top level node
                    // Treat an overwrite as an update
                    boolean update = root.getDataBefore() != null;
                    if (update) {
                        // update(change);
                        doProcessing(Action.UPDATE, root.getDataAfter());
                    } else {
                        // add(change);
                        doProcessing(Action.CREATE, root.getDataAfter());
                    }
                    break;
                case DELETE:
                    // Node removed
                    // remove(change);
                    doProcessing(Action.REMOVE, root.getDataBefore());
                    break;
            }
        }
    }

    /*
     * ---------------------------------------------------------------- Functions to select the right
     * node from DataObjectModification
     */

    /**
     * Process event and forward to clients
     *
     * @param action
     * @param node Basis node
     */
    private void doProcessing(Action action, Node node) {

        NodeId nodeId = null;
        NetconfNode nnode = null;
        NodeKey nodeKey = null;

        try {
            if (node != null) {
                if ((nodeKey = node.key()) != null) {
                    nodeId = nodeKey.getNodeId();
                }
                nnode = node.augmentation(NetconfNode.class);
            }

            if (node == null || nnode == null || nodeId == null || nodeKey == null) {
            	LOG.warn("Unexpected node {}, netconf node {} or key {} or id {}", node, nnode, nodeKey, nodeId);
            } else {
            	String nodeIdString = nodeId.getValue();
            	// Do not forward any controller related events to devicemanager
            	if (nodeIdString.equals(CONTROLLER)) {
            		LOG.debug("Stop processing for [{}]", nodeIdString);
            	} else {

            		ClusteredConnectionStatus ccsts = nnode.getClusteredConnectionStatus();
        			ConnectionStatus csts = nnode.getConnectionStatus();
          			LOG.debug("NETCONF Node processing with id {} action {} status {} cluster status {}", nodeIdString,
            					action, csts, ccsts);
          			// Action forwarded to devicehandler
           			deviceManagerService.netconfChangeHandler(action, csts, nodeId, nnode);
            	}
            }
        } catch (NullPointerException e) {
        	LOG.warn("Unexpected null .. stop processing.", e);
        }
    }

}
```


Overlapping Code:
```
ngs("deprecation")
public class NetconfChangeListener implements ClusteredDataTreeChangeListener<Node>, AutoCloseable {
private static final Logger LOG = LoggerFactory.getLogger(NetconfChangeListener.class);
private static final InstanceIdentifier<Node> NETCONF_NODE_TOPO_IID =
InstanceIdentifier.create(NetworkTopology.class)
.child(Topology.class, new TopologyKey(new TopologyId(TopologyNetconf.QNAME.getLocalName())))
.child(Node.class);
// Name of ODL controller NETCONF instance
private static final String CONTROLLER = "controller-config";
private final DeviceManagerService deviceManagerService;
private final DataBroker dataBroker;
private ListenerRegistration<NetconfChangeListener> dlcReg;
public NetconfChangeListener(DeviceManagerService deviceManagerService, DataBroker dataBroker) {
this.deviceManagerService = deviceManagerService;
this.dataBroker = dataBroker;
}
public void register() {
DataTreeIdentifier<Node> treeId = new DataTreeIdentifier<>(LogicalDatastoreType.OPERATIONAL, NETCONF_NODE_TOPO_IID);
dlcReg = dataBroker.registerDataTreeChangeListener(treeId, this);
}
@Override
public void close() {
if (dlcReg != null) {
dlcReg.close();
}
}
/*---------------------------------------------------------------------------
* Listener
*/
@Override
public void onDataTreeChanged(Collection<DataTreeModification<Node>> changes) {
LOG.debug("OnDataChange, TreeChange, changes:{}", changes.size());
for (final DataTreeModification<Node> change : changes) {
final DataObjectModification<Node> root = change.getRootNode();
final ModificationType modificationType = root.getModificationType();
if (LOG.isTraceEnabled()) {
LOG.trace("Handle this modificationType:{} path:{} root:{}", modificationType, change.getRootPath(),
root);
}
switch (modificationType) {
case SUBTREE_MODIFIED:
// Change of subtree information
// update(change); OLD
doProcessing(Action.UPDATE, root.getDataAfter());
break;
case WRITE:
// Create or modify top level node
// Treat an overwrite as an upda
```
<Overlap Ratio: 0.9860904123199206>

---

--- 295 --
Question ID: aae9342c99edf59bec717f8d099fa08a424e0c64
Original Code:
```
public class LTS extends DirectedSparseMultigraph<GraphNode,GraphEdge>  {
    private GraphNode initialNode;  // initial node of an LTS
    private GraphNode sink;
    private boolean isCounterexampleLTS;
    STDOut outputWriter;
    Map<Integer, GraphNode> specNodeIndex;

    private GraphNode fakeFinalNode;
    private Set<GraphEdge> fakeFinalEdges;

    public LTS(STDOut outputWriter) {
        super();
        initialNode = null;
        sink = null;
        isCounterexampleLTS = false;
        this.outputWriter = outputWriter;
        specNodeIndex = null;
    }

/*    public LTS(DirectedSparseMultigraph<GraphNode, GraphEdge> graph, GraphNode initialNode) {
        super();
        this.initialNode = initialNode;
        sink = null;
        isCounterexampleLTS = false;
    }*/

    public STDOut getOutputWriter() {
        return outputWriter;
    }

    public GraphNode getInitialNode() {
        return initialNode;
    }

    public void setInitialNode(GraphNode node) {
        this.initialNode = node;
    }

    private boolean hasSink() {
        return sink != null;
    }

    public void setSink(GraphNode node) {
        sink = node;
    }

    public GraphNode getSink() {
        return sink;
    }

    public boolean isCounterexampleLTS() {
        return isCounterexampleLTS;
    }

    public void setAsCounterexampleLTS() {
        isCounterexampleLTS = true;
    }

    @Override
    public Collection<GraphEdge> findEdgeSet(GraphNode n1, GraphNode n2) {
        return super.findEdgeSet(n1, n2);
    }

    /**
     *
     * @return a collection with all the vertices but without the sink
     */
    public Collection<GraphNode> getVerticesWOSink(){
        Collection<GraphNode> vertices = new HashSet<>();
        vertices.addAll(super.getVertices());
        vertices.remove(sink);
        return vertices;
    }

    /**
     * creates and return the sink
     */
    private GraphNode createSink() {
        // the id of the sink graph is the id of the vertex with the highest id +1
        // that is equivalent to the current size of the graph
        //System.out.println("Creating sink");
        // sink = new GraphNode(super.getVertexCount());  // OLD VERSION, after script
        // modification did not work anymore
        sink = new GraphNode(-1); // sink is node with -1
        super.addVertex(sink);   // TODO: check if this is necessary!
        outputWriter.printComplete("Sink is: "+ sink.toString(), true, true);
        return sink;
    }

    @Override
    public boolean addEdge(GraphEdge edge, GraphNode source, GraphNode dest) {
       return super.addEdge(edge, source, dest, EdgeType.DIRECTED);
        //Pair<GraphNode> pair = new Pair<>(source, dest);
        //return super.addEdge(edge, pair, EdgeType.DIRECTED);
        //return super.addEdge(edge, source, dest);
    }

    /**
     * Add a correct transition to the Counterexample LTS (always out transitions)
     * @param sourceNode
     * @param edge
     */
    public void addCorrectTransition(GraphNode sourceNode, GraphEdge edge){
        //System.out.println("Adding a correct transition");
        if (!hasSink()) {
            //System.out.println("Lts does not have the sink, adding it now");
            createSink(); // create the sink node if not created yet
        }
        edge.setAsCorrect();
        edge.setNodes(sourceNode, sink);
        addEdge(edge, sourceNode, sink);
    }

    /**
     *
     * @param node a node of this LTS
     * @return the collection of Correct (green) Transitions exiting from the given node
     */
    public Collection<GraphEdge> getOutCorrectTransitions(GraphNode node) {
        Collection<GraphEdge> transitionSet = new HashSet<>();
        for (GraphEdge edge : super.getOutEdges(node)) {
            if (edge.isCorrect())
                transitionSet.add(edge);
            // TODO: implement following check, we cannot return edges if there are still UNSET edges
            /*else if (edge.isUnset())
                throw new Exception(); */
        }
        return transitionSet;
    }

    /**
     *
     * @param node a node of this LTS
     * @return the collection of Incorrect (red) Transitions exiting from the given node
     */
    public Collection<GraphEdge> getOutIncorrectTransitions(GraphNode node) {
        Collection<GraphEdge> transitionSet = new HashSet<>();
        for (GraphEdge edge : super.getOutEdges(node)) {
            if (edge.isIncorrect())
                transitionSet.add(edge);
            // TODO: implement following check, we cannot return edges if there are still UNSET edges
            /*else if (edge.isUnset())
                throw new Exception(); */
        }
        return transitionSet;
    }

    /**
     *
     * @param node a node of this LTS
     * @return the collection of Neutral (black) Transitions exiting from the given node
     */
    public Collection<GraphEdge> getOutNeutralTransitions(GraphNode node) {
        Collection<GraphEdge> transitionSet = new HashSet<>();
        for (GraphEdge edge : super.getOutEdges(node)) {
            if (edge.isNeutral())
                transitionSet.add(edge);
            // TODO: implement following check, we cannot return edges if there are still UNSET edges
            /*else if (edge.isUnset())
                throw new Exception(); */
        }
        return transitionSet;
    }

    /**
     *
     * @param node the chosen graph node
     * @return true if the outgoing transitions for the node passed as parameter are all correct,
     * false otherwise
     */
    public boolean areOutTransCorrect(GraphNode node) {
        return (!getOutCorrectTransitions(node).isEmpty() &&
                getOutIncorrectTransitions(node).isEmpty() &&
                getOutNeutralTransitions(node).isEmpty());
    }

    /**
     *
     * @param node the chosen graph node
     * @return true if the outgoing transitions for the node passed as parameter are all incorrect,
     * false otherwise
     */
    public boolean areOutTransIncorrect(GraphNode node) {
        return (getOutCorrectTransitions(node).isEmpty() &&
                !getOutIncorrectTransitions(node).isEmpty() &&
                getOutNeutralTransitions(node).isEmpty());
    }

    /**
     *
     * @param node the chosen graph node
     * @return true if the outgoing transitions for the node passed as parameter are all neutral,
     * false otherwise
     */
    public boolean areOutTransNeutral(GraphNode node) {
        return (getOutCorrectTransitions(node).isEmpty() &&
                getOutIncorrectTransitions(node).isEmpty() &&
                !getOutNeutralTransitions(node).isEmpty());
    }

    /**
     *
     * @param node the chosen graph node
     * @return true if the outgoing transitions for the node passed as parameter belong to the
     * following combinations (where G:correct, R:incorrect, B:neutral): B, B+R, B+G, B+R+G, R+G.
     * Note that the presence of neutral allow to cover the first 4 combinations.
     */
    public boolean areOutTransMixed(GraphNode node) {
        boolean redEmpty, greenEmpty, blackEmpty;

        greenEmpty = getOutCorrectTransitions(node).isEmpty();
        redEmpty = getOutIncorrectTransitions(node).isEmpty();
        blackEmpty = getOutNeutralTransitions(node).isEmpty();

        return !blackEmpty || (!greenEmpty && !redEmpty);
    }


    /**
     * Add final edges for evaluating deadlock and livelocks
     * FIXME: missing removal function, add it !
     */
    public void addFakeFinalEdges() {

        // create fake final node
        fakeFinalEdges = new HashSet<>();
        fakeFinalNode = new GraphNode(-3);
        this.addVertex(fakeFinalNode);

        for (GraphNode node :  this.getVertices() ) {
            if (this.getOutEdges(node).isEmpty()) {
                // throw new NotImplementedException();
                GraphEdge fakeFinalEdge = new GraphEdge("FINALEDGE");
                fakeFinalEdges.add(fakeFinalEdge);
                this.addEdge(fakeFinalEdge, node, fakeFinalNode);
            }
        }
    }

    /**
     * Shallow copy of an LTS
     * @param other the LTS to copy
     * @return the shallow copy
     */
    public static LTS copy(LTS other) {
        LTS res = new LTS(other.getOutputWriter());
        res.specNodeIndex  = new HashMap<>();  // TODO: can be removed?

        for (GraphNode node : other.getVertices()) {
            res.addVertex(node);
            res.specNodeIndex.put(node.getId(), node);  // TODO: can be removed?
        }
        for (GraphEdge edge : other.getEdges()) {
            GraphNode source = other.getSource(edge);
            GraphNode dest = other.getDest(edge);
            res.addEdge(edge, source, dest);
        }

        res.setInitialNode(other.getInitialNode());
        if (other.hasSink()) {
            res.setSink(other.getSink());
        }
        return res;
    }

    /**
     * Shallow copy of a subset of the LTS
     * @param other the LTS to copy
     * @param nodesToCopy nodes representing the subset
     * @return the shallow copy
     */
    public static LTS copySubset(LTS other, Collection nodesToCopy) {
        LTS res = new LTS(other.getOutputWriter());
        res.specNodeIndex  = new HashMap<>();  // TODO: can be removed?

        for (GraphNode node : other.getVertices()) {
            if (nodesToCopy.contains(node)) {
                res.addVertex(node);
                res.specNodeIndex.put(node.getId(), node);  // TODO: can be removed?
            }
        }
        for (GraphEdge edge : other.getEdges()) {
            GraphNode source = other.getSource(edge);
            GraphNode dest = other.getDest(edge);
            if (nodesToCopy.contains(source) && nodesToCopy.contains(dest)) {
                res.addEdge(edge, source, dest);
            }
        }

        res.setInitialNode(other.getInitialNode());
        if (other.hasSink()) {
            res.setSink(other.getSink());
        }
        return res;
    }

    @Override
    public boolean removeEdge(GraphEdge edge) {
        return super.removeEdge(edge);
    }

    /**
     * Remove all the edges containing the action passed as parameter
     * @param action the String describing the edges to remove
     */
    public void removeAllEdges(String action) {
        /*boolean res = false;
        for (GraphEdge edge : getEdges()) {
            if (edge.getAction().equals(action))
                res = removeEdge(edge);
        }*/
        new ArrayList<>(getEdges()).stream()
                .filter(e -> e.getAction().equals(action))
                .forEach(this::removeEdge);
    }

    /**
     * Remove all the edges between the given set of nodes containing the action passed as parameter
     * @param action the String describing the edges to remove
     * @param nodes nodes representing sources and destinations of the edges to remove
     */
    public void removeAllEdges(String action, Collection nodes) {
        /*boolean res = false;
        for (GraphEdge edge : getEdges()) {
            GraphNode source = getSource(edge);
            GraphNode dest = getDest(edge);
            if (nodes.contains(source) && nodes.contains(dest)) {
                if (edge.getAction().equals(action))
                    res = removeEdge(edge);
            }
        }*/
        new ArrayList<>(getEdges()).stream()
                .filter(e -> (e.getAction().equals(action) && nodes.contains(getSource(e)) && nodes
                        .contains(getDest(e))))
                .forEach(this::removeEdge);
    }

    /**
     * Load a graph from an aut file
     * @param baseDir directory
     * @param testName name of the file to load
     * @throws Exception // TODO: to implement correctly
     * @return false if the size of the LTS is less or equal to 1, true otherwise
     */
    public boolean autLoaderOLD(String baseDir, String testName)  throws Exception  {
        BufferedReader br = new BufferedReader(new FileReader(baseDir + "/" + testName + ".aut"));
        // TODO: check that the file is actually an aut file
        // TODO: add exception in case of missing file

        class GraphEdgeExt  {
            GraphEdge edge;
            GraphNode source;
            GraphNode dest;

            GraphEdgeExt(GraphEdge edge, GraphNode source, GraphNode dest) {
                this.edge = edge;
                this.source = source;
                this.dest = dest;
            }
        }

        String line;
        int specStartNodeId = -1;
        int debugIterations = 0;
        Map<Integer, GraphNode> specNodeIndex = new HashMap<>();
        //Map<GraphEdge, Pair> edgePairMap = new Hashtable<>();
        List<GraphEdge> listEdges = new ArrayList<GraphEdge>();
        while ((line = br.readLine()) != null) {
            if (line.startsWith("des")) {
                specStartNodeId = Integer.parseInt(line.substring(5, line.length() - 1).split(",")[0].trim());
            } else {

                String[] data = new String[]{"", "", ""};
                int firstComma = line.indexOf(",");
                int lastComma = line.lastIndexOf(",");
                data[0] = line.substring(0, firstComma).replaceAll("[()]", "");
                data[1] = line.substring(firstComma + 1, lastComma);
                data[2] = line.substring(lastComma + 1).replaceAll("[()]", "");
                // label with quotes
                int firstIndx = line.indexOf("\"");
                if (firstIndx != -1) {
                    int lastIndx = line.lastIndexOf("\"");
                    data[1] = line.substring(firstIndx + 1, lastIndx);
                }

                int fromNodeId = Integer.valueOf(data[0].trim());
                String action = data[1].trim();
                int toNodeId = Integer.valueOf(data[2].trim());

                // TODO: see if it is possible to avoid "i" transitions directly on the script
                if (!action.equals("i")){ // this allows to avoid the final transitions "i"
                    GraphEdge edge = new GraphEdge(action);
                    GraphNode fromNode = specNodeIndex.get(fromNodeId);
                    if (fromNode == null) {
                        fromNode = new GraphNode(fromNodeId);
                        specNodeIndex.put(fromNodeId, fromNode);
                    }
                    GraphNode toNode = specNodeIndex.get(toNodeId);
                    if (toNode == null) {
                        toNode = new GraphNode(toNodeId);
                        specNodeIndex.put(toNodeId, toNode);
                    }
                    edge.setNodes(fromNode, toNode);
                    //addEdge(edge, fromNode, toNode);
                    //edgePairMap.put(edge, new Pair<>(fromNode, toNode));
                    listEdges.add(edge);

                    // FIXME: TRY TO AVOID THE NODE INDEX!
                }

            }
            if (debugIterations%100000 == 0)
                outputWriter.printComplete("autLoader: read "+ debugIterations  + " lines", false,
                        false);
            debugIterations++;
        }
        br.close();

        int debug = 0;
        for (GraphEdge edge : listEdges) {
            addEdge(edge, edge.source, edge.dest);
            if (debug%100000 == 0)
                outputWriter.printComplete("autLoader: inserted "+ debug  + " lines", false,
                        false);
            debug++;
        }

        setInitialNode(specNodeIndex.get(specStartNodeId));
        if (super.vertices.size() <= 1) {
            outputWriter.printError("autLoader: possible ERROR, the loaded lts contains only a " +
                    "node", true, true);
            // FIXME: should throw an exception in this case
            return false;
        }
        return true;
    }

    public boolean autLoader(String baseDir, String testName, Boolean fast, boolean safety) throws
            Exception  {
        long startTime = System.currentTimeMillis();
        List<GraphEdge> edgeList;
        edgeList = fileReader(baseDir, testName, fast, safety);
        boolean res = graphLoader(edgeList);
        outputWriter.printComplete("autLoader: loading completed.", true, false);
        long endTime = System.currentTimeMillis();
        outputWriter.printComplete("autLoader exec time: " +
                (endTime - startTime) + " ms\n", true, false);
        return res;
    }


    public List<GraphEdge> fileReader (String baseDir, String testName, boolean fast,
                                       boolean safety)
            throws Exception  {
        BufferedReader br = new BufferedReader(new FileReader(baseDir + "/" + testName + ".aut"));
        // TODO: check that the file is actually an aut file
        // TODO: add exception in case of missing file
        String line;
        int specStartNodeId = -1;
        int debugIterations = 0;
        specNodeIndex = new HashMap<>();
        List<GraphEdge> listEdges = new ArrayList<GraphEdge>();
        while ((line = br.readLine()) != null) {
            if (line.startsWith("des")) {
                specStartNodeId = Integer.parseInt(line.substring(5, line.length() - 1).split(",")[0].trim());
            } else {

                String[] data = new String[]{"", "", ""};
                int firstComma = line.indexOf(",");
                int lastComma = line.lastIndexOf(",");
                data[0] = line.substring(0, firstComma).replaceAll("[()]", "");
                data[1] = line.substring(firstComma + 1, lastComma);
                data[2] = line.substring(lastComma + 1).replaceAll("[()]", "");
                // label with quotes
                int firstIndx = line.indexOf("\"");
                if (firstIndx != -1) {
                    int lastIndx = line.lastIndexOf("\"");
                    data[1] = line.substring(firstIndx + 1, lastIndx);
                }

                int fromNodeId = Integer.valueOf(data[0].trim());
                String action = data[1].trim();
                int toNodeId = Integer.valueOf(data[2].trim());

                // TODO: see if it is possible to avoid "i" transitions directly on the script
                if (!safety || fast) {
                    // "i" transitions are allowed in liveness mode or
                    // in fast safety mode "i" transition are used only to detect
                    // final transitions
                    GraphEdge edge = new GraphEdge(action);
                    GraphNode fromNode = specNodeIndex.get(fromNodeId);
                    if (fromNode == null) {
                        fromNode = new GraphNode(fromNodeId);
                        specNodeIndex.put(fromNodeId, fromNode);
                    }
                    GraphNode toNode = specNodeIndex.get(toNodeId);
                    if (toNode == null) {
                        toNode = new GraphNode(toNodeId);
                        specNodeIndex.put(toNodeId, toNode);
                    }
                    edge.setNodes(fromNode, toNode);
                    //addEdge(edge, fromNode, toNode);
                    //edgePairMap.put(edge, new Pair<>(fromNode, toNode));
                    listEdges.add(edge);

                    // FIXME: TRY TO AVOID THE NODE INDEX!
                } else {
                    // in normal safety mode, "i" transition cannot be used
                    // (performs the i avoidance if normal mode is used)
                    // this allows to avoid the final transitions "i"
                    if (!action.equals("i") ) {
                        GraphEdge edge = new GraphEdge(action);
                        GraphNode fromNode = specNodeIndex.get(fromNodeId);
                        if (fromNode == null) {
                            fromNode = new GraphNode(fromNodeId);
                            specNodeIndex.put(fromNodeId, fromNode);
                        }
                        GraphNode toNode = specNodeIndex.get(toNodeId);
                        if (toNode == null) {
                            toNode = new GraphNode(toNodeId);
                            specNodeIndex.put(toNodeId, toNode);
                        }
                        edge.setNodes(fromNode, toNode);
                        //addEdge(edge, fromNode, toNode);
                        //edgePairMap.put(edge, new Pair<>(fromNode, toNode));
                        listEdges.add(edge);

                        // FIXME: TRY TO AVOID THE NODE INDEX!
                    }
                }

            }
            if (debugIterations%100000 == 0)
                outputWriter.printComplete("autLoader: read "+ debugIterations  + " lines", false,
                        false);
            debugIterations++;
        }
        br.close();
        setInitialNode(specNodeIndex.get(specStartNodeId));

        outputWriter.printComplete("autLoader: read finished after "+ debugIterations + " " +
                "iterations.", true, false);

        return listEdges;
    }

    public boolean graphLoader(List<GraphEdge> listEdges) {

        int debug = 0;
        for (GraphEdge edge : listEdges) {
            addEdge(edge, edge.source, edge.dest);
            if (debug%100000 == 0)
                outputWriter.printComplete("autLoader: inserted "+ debug  + " lines", false, true);
            debug++;
        }


        outputWriter.printComplete("autLoader: loading finished after "+ debug + " " +
                "iterations.", true, true);

        if (super.vertices.size() <= 1) {
            outputWriter.printError("autLoader: possible ERROR, the loaded lts contains only a " +
                    "node", true, true);
            // FIXME: should throw an exception in this case
            return false;
        }
        return true;
    }

    /**
     * If f option is chosen, it reads the table with the correspondence between states
     * It extracts data from the table containing the equivalence between states
     * @param baseDir
     * @param tableFileName
     * @throws Exception
     */
    public void equivTableLoader(String baseDir, String tableFileName, LTS fullLTS) throws
            Exception {
        BufferedReader br = new BufferedReader(new FileReader(baseDir + "/" + tableFileName
                + ".prd"));
        // TODO: check that the file is actually a table file
        // TODO: add exception in case of missing file
        String line;
        int specStartNodeId = -1;
        int debugIterations = 0;
        Map<Integer, Integer> cLTStoFullLTScorr = new HashMap<>(); // maps
        // <nodeInTheCounterexLTS, nodeInTheFullLTS>
        while ((line = br.readLine()) != null) {

            String[] data = new String[]{"", "", ""};
            int equalSign = line.indexOf("=");
            int comma = line.indexOf(",");
            int openBrace = line.indexOf("{");
            //int closedBrace = line.indexOf("}");
            data[0] = line.substring(0, equalSign).replaceAll("[()]", "");
            data[1] = line.substring(openBrace + 1, comma);
            //data[2] = line.substring(comma + 1, closedBrace).replaceAll("[()]", "");

            int cLTSState = Integer.valueOf(data[0].trim());
            int fullState = Integer.valueOf(data[1].trim());
            //int propState = Integer.valueOf(data[2].trim()); the index of the property is unused

            cLTStoFullLTScorr.put(cLTSState, fullState);

            if (debugIterations % 100000 == 0)
                outputWriter.printComplete("equivTableLoader: read " + debugIterations +
                        " lines", false, true);
            debugIterations++;
        }
        br.close();

        // Now it loads the data in the Counterexample LTS as equivalences
        for (Integer index : specNodeIndex.keySet()) {
            GraphNode node = specNodeIndex.get(index);
            node.setEquivalentInSpec(fullLTS.specNodeIndex.get(cLTStoFullLTScorr.get(index)));
        }

        outputWriter.printComplete("equivTableLoader: read finished after " + debugIterations +
                " iterations.", true, true);
    }

    /**
     * Write the lts with colors in aut format, using colon to separate action and transition type
     * @param baseDir
     * @param fileName
     * @return
     */
    public boolean writeToAut(String baseDir, String fileName) {
        String resFile = fileName+"_clr-res.aut";

        try (Writer writer = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream(baseDir + "/"+resFile, false), "utf-8"))) {

            // writing header
            writer.write("des ("+ this.getInitialNode().getId()+", " + this.getEdges().size()+"," +
                    " " + this.getVertices().size()+")\n");

            List<GraphNode> orderedVertices = new ArrayList<>(getVertices());
            Collections.sort(orderedVertices, GraphNode.COMPARE_BY_ID);
            for (GraphNode node: orderedVertices) {
                List<GraphNode> orderedSuccessors = new ArrayList<>(this.getSuccessors(node));
                Collections.sort(orderedSuccessors, GraphNode.COMPARE_BY_ID);
                for (GraphNode dest : orderedSuccessors) {
                    for (GraphEdge edge : this.findEdgeSet(node, dest))
                        writer.write("(" + node.getId() +", \""+ edge.getAction()+"\":"+
                                edge.getType() + ", " + dest.getId() +")\n");
                }
            }

            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * Write the lts with colors and neighbourhoods in aut format, using colon to separate action
     * and transition type (for colors) and colon to separate state id and neighbourhood type (for
     * neighbourhoods).
     * @param baseDir
     * @param fileName
     * @return
     */
    public boolean autDump(String baseDir, String fileName) {
        String resFile = fileName+"_res-dump.autx";

        try (Writer writer = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream(baseDir + "/"+resFile, false), "utf-8"))) {

            // writing header
            writer.write("des ("+ this.getInitialNode().getId()+", " + this.getEdges().size()+"," +
                    " " + this.getVertices().size()+")\n");

            List<GraphNode> orderedVertices = new ArrayList<>(getVertices());
            Collections.sort(orderedVertices, GraphNode.COMPARE_BY_ID);
            for (GraphNode node: orderedVertices) {
                List<GraphNode> orderedSuccessors = new ArrayList<>(this.getSuccessors(node));
                Collections.sort(orderedSuccessors, GraphNode.COMPARE_BY_ID);
                for (GraphNode dest : orderedSuccessors) {
                    for (GraphEdge edge : this.findEdgeSet(node, dest))
                        if (node.isFrontier()) {
                            writer.write("(" + node.getId()+":N:"+node.getNeighbourhood()
                                            .toStringShort()+ ", \""+ edge.getAction()+"\":"+
                                    edge.getType() + ", " + dest.getId() +")\n");
                        } else {
                        writer.write("(" + node.getId()+", \""+ edge.getAction()+"\":"+
                                edge.getType() + ", " + dest.getId() +")\n");
                    }
                }
            }

            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * Regression check on given file (only liveness)
     * @param baseDir
     * @param fileName
     * @return
     */
    public boolean regressionCheck(String baseDir, String fileName) {
        String resFile = fileName+"_clr-res.aut";
        String expFile = fileName+"_clr-exp.aut";
        int diffReturnValue = 2;  // 2 means error on diff
        List<String> commands = Arrays.asList("diff", resFile, expFile);

        // checking existence of regression results file to mathc results
        File f = new File(baseDir + "/"+ expFile);
        if(!f.exists() || f.isDirectory()) {
            System.out.println(expFile + " is missing");
            return false;
        }
        // write file to aut
        if (!writeToAut(baseDir, fileName)) {
            return false;
        }
        try {
            // diff = 0 means no differences, 1 means differences exist, 2 means error
            diffReturnValue = CmdLineCaller.cmdCaller(commands, null, baseDir, false);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return (diffReturnValue==0);
    }

    public String toSringAut() {
        String str = "";
        for (GraphNode node: this.getVertices()) {
            for (GraphNode dest : this.getSuccessors(node)) {
                for (GraphEdge edge : this.findEdgeSet(node, dest))
                    str+= "(" + node.getId() +", "+ edge.getAction() + ", " + dest.getId() +") " +
                            edge.getType().toString() + "\n";
            }
        }
        return str;
    }

    @Deprecated
    public String toStringAutColors() {
        String str = "des ("+ this.getInitialNode().getId()+", " + this.getEdges().size()+", " + this
                .getVertices().size()+")\n";
        List<GraphNode> orderedVertices = new ArrayList<>(getVertices());
        Collections.sort(orderedVertices, GraphNode.COMPARE_BY_ID);
        for (GraphNode node: orderedVertices) {
            List<GraphNode> orderedSuccessors = new ArrayList<>(this.getSuccessors(node));
            Collections.sort(orderedSuccessors, GraphNode.COMPARE_BY_ID);
            for (GraphNode dest : orderedSuccessors) {
                for (GraphEdge edge : this.findEdgeSet(node, dest))
                    str+= "(" + node.getId() +", \""+ edge.getAction()+"\":l"+ edge.getType() +
                            ", " +
                        dest.getId() +")\n";
            }
        }
        return str;
    }

    public String toSringAutPrefixSuffix() {
        String str = "";
        List<GraphNode> orderedVertices = new ArrayList<>(getVertices());
        Collections.sort(orderedVertices, GraphNode.COMPARE_BY_ID);
        for (GraphNode node: orderedVertices) {
            List<GraphNode> orderedSuccessors = new ArrayList<>(this.getSuccessors(node));
            Collections.sort(orderedSuccessors, GraphNode.COMPARE_BY_ID);
            for (GraphNode dest : orderedSuccessors) {
                for (GraphEdge edge : this.findEdgeSet(node, dest))
                    str+= "(" + node.getId() +", "+ edge.getAction() + ", " + dest.getId() +") " +
                            edge.getType().toString() + "\n";
            }
            str+= "(" + node.getId() +", "+ node.prefixSuffixToString() + "\n";
        }
        return str;
    }
}
```


Overlapping Code:
```
extends DirectedSparseMultigraph<GraphNode,GraphEdge> {
private GraphNode initialNode; // initial node of an LTS
private GraphNode sink;
private boolean isCounterexampleLTS;
STDOut outputWriter;
Map<Integer, GraphNode> specNodeIndex;
private GraphNode fakeFinalNode;
private Set<GraphEdge> fakeFinalEdges;
public LTS(STDOut outputWriter) {
super();
initialNode = null;
sink = null;
isCounterexampleLTS = false;
this.outputWriter = outputWriter;
specNodeIndex = null;
}
/* public LTS(DirectedSparseMultigraph<GraphNode, GraphEdge> graph, GraphNode initialNode) {
super();
this.initialNode = initialNode;
sink = null;
isCounterexampleLTS = false;
}*/
public STDOut getOutputWriter() {
return outputWriter;
}
public GraphNode getInitialNode() {
return initialNode;
}
public void setInitialNode(GraphNode node) {
this.initialNode = node;
}
private boolean hasSink() {
return sink != null;
}
public void setSink(GraphNode node) {
sink = node;
}
public GraphNode getSink() {
return sink;
}
public boolean isCounterexampleLTS() {
return isCounterexampleLTS;
}
public void setAsCounterexampleLTS() {
isCounterexampleLTS = true;
}
@Override
public Collection<GraphEdge> findEdgeSet(GraphNode n1, GraphNode n2) {
return super.findEdgeSet(n1, n2);
}
/**
*
* @return a collection with all the vertices but without the sink
*/
public Collection<GraphNode> getVerticesWOSink(){
Collection<GraphNode> vertices = new HashSet<>();
vertices.addAll(super.getVertices());
vertices.remove(sink);
return vertices;
}
/**
* creates and return the sink
*/
private GraphNode createSink() {
// the id of the sink graph is the id of the vertex with the highest id +1
// that is equivalent to the current size of the graph
//System.out.println("Creating sink");
// sink = new GraphNode(super.getVertexCount()); // OLD VERSION, after script
// modification did not work anymore
sink = new GraphNode(-1); // sink is node with -1
super.addVertex(sink); // TODO: check if this is necessary!
outputWriter.printComplete("Sink is: "+ si
```
<Overlap Ratio: 0.9722897423432183>

---

--- 296 --
Question ID: a3c651d7e12167098cc21186289d50aede65e8f7
Original Code:
```
@Mojo(threadSafe = true, name = "upgrade", requiresDirectInvocation = false, requiresProject = true)
public class StickyBoundsUpgradeMojo
    extends AbstractMojo {

  /**
   * The Maven Project.
   */
  @Parameter(defaultValue = "${project}", required = true, readonly = true)
  private MavenProject project;

  /**
   * The entry point to Aether, i.e. the component doing all the work.
   * 
   */
  @Component
  private RepositorySystem repository;

  /**
   * The current repository/network configuration of Maven.
   */
  @Parameter(defaultValue = "${repositorySystemSession}", required = true, readonly = true)
  private RepositorySystemSession session;

  private Pattern range = Pattern.compile("\\[[0-9.\\-A-Za-z]+\\s*(,\\s*([0-9.\\-A-Za-z]+)?)\\)");

  /**
   * The project's remote repositories to use for the resolution.
   */
  @Parameter(defaultValue = "${project.remoteProjectRepositories}", required = true, readonly = true)
  private List<RemoteRepository> repositories;

  @Parameter(defaultValue = "false")
  private Boolean includeSnapshots = false;

  @Parameter(defaultValue = "false")
  private Boolean updateProperties = false;

  @Parameter(defaultValue = "false")
  private Boolean failImmediately = false;

  /**
   * The line separator used when rewriting the pom, this to defaults to your platform encoding but if you fix your encoding despite
   * platform then you should use that.
   */
  @Parameter
  private LineSeparator lineSeparator = LineSeparator.defaultValue();

  Matcher matchVersion(String version) {
    return range.matcher(version);
  }

  /**
   * If bounds should be updated when there is no upgrade, useful for doing cascaded upgrades while minimising deltas
   */
  @Parameter()
  private boolean acceptMinorVersionChanges = false;

  Changes change = new Changes();

  @Override
  public void execute() throws MojoExecutionException {
    Document pom = load();

    change.acceptMinorVersionChanges(acceptMinorVersionChanges);

    processProperties(pom);

    processDependencies(pom);

    processDependencyManagement(pom);

    if (change.changed()) {
      if (change.upgraded())
        bumpMajorVersion(pom);
      writeChanges(pom);
    }
  }

  void bumpMajorVersion(Document pom) throws MojoExecutionException {
    XPathContext context = new XPathContext("mvn", "http://maven.apache.org/POM/4.0.0");
    Nodes project = pom.query("/mvn:project", context);
    if (project.size() == 0)
      throw new MojoExecutionException("Pom is broken");

    Nodes nodes = pom.query("/mvn:project/mvn:version", context);
    if (nodes.size() != 1)
      throw new MojoExecutionException("Version is not declared correctly");

    Element e = (Element) nodes.get(0);
    String[] components = e.getValue().split("\\.");
    components[0] = Integer.toString(Integer.valueOf(components[0]) + 1);

    String bumpedVersion = String.join(".", components);

    Element newVersion = new Element("version", "http://maven.apache.org/POM/4.0.0");
    newVersion.appendChild(bumpedVersion);
    ((Element) project.get(0)).replaceChild(e, newVersion);
    // TODO check that the next version does not already exist
  }

  private void processDependencyManagement(Document pom)
      throws MojoExecutionException {
    if (project.getDependencyManagement() != null) {
      for (Dependency dependency : project.getDependencyManagement().getDependencies()) {
        try {
          String version = dependency.getVersion();
          Artifact artifact = resolveLatestVersionRange(dependency, dependency.getVersion());

          if (change.change(artifact.getVersion(), version)) {
            updateDependencyManagement(pom, artifact, artifact.getVersion());
          }
        }
        catch (MojoExecutionException e) {
          fail(e);
        }
      }
    }
  }

  private void processDependencies(Document pom)
      throws MojoExecutionException {
    for (Dependency dependency : project.getDependencies()) {
      try {
        String version = dependency.getVersion();
        Artifact artifact = resolveLatestVersionRange(dependency, dependency.getVersion());

        if (change.change(artifact.getVersion(), version)) {
          updateDependency(pom, artifact, version);
        }
      }
      catch (MojoExecutionException e) {
        fail(e);
      }
    }
  }

  private void processProperties(Document pom)
      throws MojoExecutionException {
    for (String propertyName : project.getProperties().stringPropertyNames()) {
      if (propertyName.endsWith(".version")) {
        try {
          final String version = project.getProperties().getProperty(propertyName);
          Dependency dependency = findDependencyUsingVersionProperty(propertyName);
          if (dependency != null) {
            Artifact artifact = resolveLatestVersionRange(dependency, version);
            if (change.change(artifact.getVersion(), version)) {
              updateProperty(pom, propertyName, artifact.getVersion());
            }
          }
          else {
            getLog().warn("No dependency found using " + propertyName);
          }
        }
        catch (MojoExecutionException e) {
          fail(e);
        }
      }
    }
  }

  private void fail(MojoExecutionException e) throws MojoExecutionException {
    if (!failImmediately) {
      getLog().warn(e.getMessage());
    }
    else {
      throw e;
    }
  }

  Artifact resolveLatestVersionRange(Dependency dependency, String version) throws MojoExecutionException {
    Matcher versionMatch = matchVersion(version);

    if (versionMatch.matches()) {
      Artifact artifact = new DefaultArtifact(dependency.getGroupId(), dependency.getArtifactId(),
        dependency.getClassifier(), dependency.getType(), version.replaceFirst(versionMatch.group(1), ","));

      Version highestVersion = highestVersion(artifact);
      String newVersion = "[" + highestVersion.toString() + "," + majorVersionPlusOne(highestVersion) + ")";

      return artifact.setVersion(newVersion);
    }
    else {
      return new DefaultArtifact(dependency.getGroupId(), dependency.getArtifactId(),
        dependency.getClassifier(), dependency.getType(), version);
    }
  }

  private Integer majorVersionPlusOne(Version highestVersion) {
    String[] split = highestVersion.toString().split("\\.");
    return Integer.valueOf(split[0]) + 1;
  }

  private Dependency findDependencyUsingVersionProperty(String propertyName) {
    for (Dependency dependency : project.getDependencies()) {
      if (propertyName.equals(dependency.getArtifactId() + ".version")) {
        getLog()
          .warn(
            "If you use dependency composition then you will find that version properties "
              + "are really not that useful. Its an extra indirection that often you don't need. "
              + "IMO people take the magic number refactoring too far");
        return dependency;
      }
    }
    if (project.getDependencyManagement() != null) {
      for (Dependency dependency : project.getDependencyManagement().getDependencies()) {
        if (propertyName.equals(dependency.getArtifactId() + ".version")) {
          getLog()
            .warn(
              "Dependency Management is an anti pattern, think OO or functional, "
                + "dependencies should be composed NOT inherited");
          return dependency;
        }
      }
    }
    return null;
  }

  private void writeChanges(Document pom) {
    Serializer serializer = createSerialiser();
    try {
      serializer.write(pom);
    }
    catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  private Serializer createSerialiser() {
    try {
      Serializer serializer = new StickySerializer(new FileOutputStream(project.getFile()), "UTF-8");
      if (!System.lineSeparator().equals(lineSeparator.value()))
        getLog().info(String.format("The line separator is configured to %s, not using system line separator", lineSeparator));

      serializer.setLineSeparator(lineSeparator.value());
      return serializer;
    }
    catch (UnsupportedEncodingException e) {
      throw new RuntimeException(e);
    }
    catch (FileNotFoundException e) {
      throw new RuntimeException(e);
    }
  }

  protected Version highestVersion(Artifact artifact) throws MojoExecutionException {
    VersionRangeRequest request = new VersionRangeRequest(artifact, repositories, null);
    VersionRangeResult v = resolve(request);

    if (!includeSnapshots) {
      List<Version> filtered = new ArrayList<Version>();
      for (Version aVersion : v.getVersions()) {
        if (!aVersion.toString().endsWith("SNAPSHOT")) {
          filtered.add(aVersion);
        }
      }
      v.setVersions(filtered);
    }

    if (v.getHighestVersion() == null) {
      throw (v.getExceptions().isEmpty())
        ? new MojoExecutionException("Failed to resolve " + artifact.toString())
        : new MojoExecutionException("Failed to resolve " + artifact.toString(), v.getExceptions().get(0));
    }

    return v.getHighestVersion();
  }

  void updateProperty(Document pom, String propertyName, String newVersion) throws MojoExecutionException {
    XPathContext context = new XPathContext("mvn", "http://maven.apache.org/POM/4.0.0");
    Nodes nodes = pom.query("//mvn:properties", context);

    if (nodes.size() > 0) {
      final Element propertiesElement = (Element) nodes.get(0);
      Elements properties = propertiesElement.getChildElements();
      for (int i = 0; i < properties.size(); i++) {
        Element property = properties.get(i);
        if (property.getLocalName().equals(propertyName)) {
          Element newRange = new Element(propertyName, "http://maven.apache.org/POM/4.0.0");
          newRange.appendChild(newVersion);
          propertiesElement.replaceChild(property, newRange);
        }
      }
    }
  }

  void updateDependency(Document pom, Artifact artifact, String oldVersion) throws MojoExecutionException {
    updateDependency(pom, dependencyPath(artifact.getArtifactId()), oldVersion, artifact);
  }

  void updateDependencyManagement(Document pom, Artifact artifact, String oldVersion) throws MojoExecutionException {
    updateDependency(pom, dependencyManagementPath(artifact.getArtifactId()), oldVersion, artifact);
  }

  private void updateDependency(Document pom, String dependencyPath, String oldVersion, Artifact artifact)
      throws MojoExecutionException {
    XPathContext context = new XPathContext("mvn", "http://maven.apache.org/POM/4.0.0");
    Nodes nodes = pom.query(dependencyPath, context);

    if (nodes.size() == 0) {
      throw new MojoExecutionException(String.format("Missing <dependency> element for dependency %s, skipping.",
        artifact.getArtifactId()));
    }

    for (int i = 0; i < nodes.size(); i++) {
      Node node = nodes.get(i);
      ParentNode dependency = node.getParent();
      Nodes classifier = dependency.query("mvn:classifier", context);
      if (classifier.size() != 0)
        if (!classifier.get(0).getValue().equals(artifact.getClassifier()))
          return;

      final Nodes versionNodes = dependency.query("mvn:version", context);
      if (versionNodes.size() > 0) {
        getLog().info("Upgrading dependency to " + artifact.toString() + " from " + oldVersion);
        Element version = (Element) versionNodes.get(0);
        if (!version.getValue().startsWith("${") || updateProperties) {
          Element newRange = new Element("version", "http://maven.apache.org/POM/4.0.0");
          newRange.appendChild(artifact.getVersion());
          dependency.replaceChild(version, newRange);
        }
      }
      else {
        throw new MojoExecutionException(String.format("Missing <version> element for dependency %s, skipping.",
          artifact.getArtifactId()));
      }
    }
  }

  private String dependencyPath(String artifactId) {
    return "//mvn:dependencies/mvn:dependency/mvn:artifactId[text()='" + artifactId + "']";
  }

  private String dependencyManagementPath(String artifactId) {
    return "//mvn:dependencyManagement/mvn:dependencies/mvn:dependency/mvn:artifactId[text()='" + artifactId + "']";
  }

  private Document load() {
    try {
      return new Builder().build(project.getFile());
    }
    catch (ValidityException e) {
      throw new RuntimeException(e);
    }
    catch (ParsingException e) {
      throw new RuntimeException(e);
    }
    catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  private VersionRangeResult resolve(VersionRangeRequest request) {
    try {
      return repository.resolveVersionRange(session, request);
    }
    catch (VersionRangeResolutionException e) {
      throw new RuntimeException(e);
    }
  }

}
```


Overlapping Code:
```
pgrade", requiresDirectInvocation = false, requiresProject = true)
public class StickyBoundsUpgradeMojo
extends AbstractMojo {
/**
* The Maven Project.
*/
@Parameter(defaultValue = "${project}", required = true, readonly = true)
private MavenProject project;
/**
* The entry point to Aether, i.e. the component doing all the work.
* 
*/
@Component
private RepositorySystem repository;
/**
* The current repository/network configuration of Maven.
*/
@Parameter(defaultValue = "${repositorySystemSession}", required = true, readonly = true)
private RepositorySystemSession session;
private Pattern range = Pattern.compile("\\[[0-9.\\-A-Za-z]+\\s*(,\\s*([0-9.\\-A-Za-z]+)?)\\)");
/**
* The project's remote repositories to use for the resolution.
*/
@Parameter(defaultValue = "${project.remoteProjectRepositories}", required = true, readonly = true)
private List<RemoteRepository> repositories;
@Parameter(defaultValue = "false")
private Boolean includeSnapshots = false;
@Parameter(defaultValue = "false")
private Boolean updateProperties = false;
@Parameter(defaultValue = "false")
private Boolean failImmediately = false;
/**
* The line separator used when rewriting the pom, this to defaults to your platform encoding but if you fix your encoding despite
* platform then you should use that.
*/
@Parameter
private LineSeparator lineSeparator = LineSeparator.defaultValue();
Matcher matchVersion(String version) {
return range.matcher(version);
}
/**
* If bounds should be updated when there is no upgrade, useful for doing cascaded upgrades while minimising deltas
*/
@Parameter()
private boolean acceptMinorVersionChanges = false;
Changes change = new Changes();
@Override
public void execute() throws MojoExecutionException {
Document pom = load();
change.acceptMinorVersionChanges(acceptMinorVersionChanges);
processProperties(pom);
processDependencies(pom);
processDependencyManagement(pom);
if (change.changed()) {
if (change.upgraded())
bumpMajorVersion(pom);
writeChanges(pom);
}
}
void bumpMajorVersion(Document pom) throws MojoExecutionException {
XPathContext context = new XPathContext("mvn", "http://maven.apache.org/POM/4.0.0");
Nodes project = pom.query("/mvn:project", context);
if (project.size() == 0)
throw new MojoExecutionExcepti
```
<Overlap Ratio: 0.9782608695652174>

---

--- 297 --
Question ID: ce5034d512e499bd2aedc3051e77edee6f55e2fc
Original Code:
```
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath*:spring-context*.xml")
public class FriendCircleMessageServiceImplTest {
    @Autowired
    private FriendCircleMessageService friendCircleMessageService;

    @Autowired
    private FriendCircleMessageMapper friendCircleMessageMapper;

    @Autowired
    private TimeLineMapper timeLineMapper;
    @Test
    public void getFriendMessage(){
        List<FriendCircleMessage> friendCircleMessages = friendCircleMessageService.getFriendMessageByUid(3L);
        System.out.println(friendCircleMessages);
    }
    @Test
    public void insertMessage(){
        FriendCircleMessage friendCircleMessage=new FriendCircleMessage();
        friendCircleMessage.setContent("3333");
        friendCircleMessage.setImage("1.png");
        friendCircleMessage.setUid(9L);
        friendCircleMessage.setCreated(new Date());
        System.out.println(friendCircleMessage.getId());
        friendCircleMessageMapper.insert(friendCircleMessage);
        System.out.println(friendCircleMessage.getId());
    }

    @Test
    public void sendMessage(){
        FriendCircleMessage friendCircleMessage=new FriendCircleMessage();
        friendCircleMessage.setContent("今天是美好的一天");
        friendCircleMessage.setPicture("1.png");
        friendCircleMessage.setUid(2L);
        friendCircleMessage.setCreated(new Date());
        friendCircleMessageService.sendFriendMessage(friendCircleMessage);
    }
    @Test
    public void delete(){
        friendCircleMessageService.delete(8L);
    }
    @Test
    public void getOwnMessageByUid(){
        List<FriendCircleMessage> ownMessage = friendCircleMessageMapper.getOwnMessageByUid(2L);
        System.out.println(ownMessage);
    }
}
```


Overlapping Code:
```
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath*:spring-context*.xml")
public class FriendCircleMessageServiceImplTest {
@Autowired
private FriendCircleMessageService friendCircleMessageService;
@Autowired
private FriendCircleMessageMapper friendCircleMessageMapper;
@Autowired
private TimeLineMapper timeLineMapper;
@Test
public void getFriendMessage(){
List<FriendCircleMessage> friendCircleMessages = friendCircleMessageService.getFriendMessageByUid(3L);
System.out.println(friendCircleMessages);
}
@Test
public void insertMessage(){
FriendCircleMessage friendCircleMessage=new FriendCircleMessage();
friendCircleMessage.setContent("3333");
friendCircleMessage.setImage("1.png");
friendCircleMessage.setUid(9L);
friendCircleMessage.setCreated(new Date());
System.out.println(friendCircleMessage.getId());
friendCircleMessageMapper.insert(friendCircleMessage);
System.out.println(friendCircleMessage.getId());
}
@Test
public void sendMessage(){
FriendCircleMessage friendCircleMessage=new FriendCircleMessage();
friendCircleMessage.setContent("今天是美好的一天");
friendCircleMessage.setPicture("1.png");
friendCircleMessage.setUid(2L);
friendCircleMessage.setCreated(new Date());
friendCircleMessageService.sendFriendMessage(friendCircleMessage);
}
@Test
public void delete(){
friendCircleMessageService.delete(8L);
}
@Test
public void getOwnMessageByUid(){
List<FriendCircleMessage> ownMessage = friendCircleMessageMapper.getOwnMessageByUi
```
<Overlap Ratio: 0.9722589167767504>

---

--- 298 --
Question ID: caf5bc02b62aee2157362c589a423e0fac3df0df
Original Code:
```
public class MovieSmallImg{
	
	public String movieSmallImg(String keyword,String mCode) throws DetailViewException,Exception {
		String result=new PosterAPI().getPosterResult(keyword);
		
		MovieService dvs = new MovieService();
		String page = "";

		if (result.substring(61, 62).equals("1") && !chkNum(result.substring(62, 63)))
			page = dvs.getSmallImage(result,mCode);
		else
			page = dvs.getPowerSmallImage(result, keyword,mCode);
		
		return page;
	}
	
	private boolean chkNum(String s) {
		try {
			Integer.parseInt(s);
			return true;
		} catch (NumberFormatException e) {
			return false;
		}
	}
}
```


Overlapping Code:
```
ovieSmallImg{

public String movieSmallImg(String keyword,String mCode) throws DetailViewException,Exception {
String result=new PosterAPI().getPosterResult(keyword);

MovieService dvs = new MovieService();
String page = "";
if (result.substring(61, 62).equals("1") && !chkNum(result.substring(62, 63)))
page = dvs.getSmallImage(result,mCode);
else
page = dvs.getPowerSmallImage(result, keyword,mCode);

return page;
}

private boolean chkNum(String s) {
try {
Integer.parseInt(s);
return true;
} catch (NumberFormatException e) {
return false;
}
}
}
```
<Overlap Ratio: 0.975177304964539>

---

--- 299 --
Question ID: d87551b82307b12235f7a32dbf20c53a669b0bbb
Original Code:
```
public class LookupUtils {
    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(LookupUtils.class);
    private static final String[] searchList = new String[SearchOperator.QUERY_CHARACTERS.size()];

    static {
        int index = 0;
        for (SearchOperator operator : SearchOperator.QUERY_CHARACTERS) {
            searchList[index++] = operator.op();
        }
    }

    private static final String[] replacementList = Collections.nCopies(searchList.length, "").toArray(new String[0]);

    private LookupUtils() {}

    /**
     * Retrieves the value for the given parameter name to send as a lookup parameter.
     *
     * @param form form instance to retrieve values from
     * @param request request object to retrieve parameters from
     * @param lookupObjectClass data object class associated with the lookup, used to check whether the
     * value needs to be encyrpted
     * @param propertyName name of the property associated with the parameter, used to check whether the
     * value needs to be encrypted
     * @param parameterName name of the parameter to retrieve the value for
     * @return String parameter value or empty string if no value was found
     */
    public static String retrieveLookupParameterValue(UifFormBase form, HttpServletRequest request,
            Class<?> lookupObjectClass, String propertyName, String parameterName) {
        String parameterValue = "";

        // get literal parameter values first
        if (StringUtils.startsWith(parameterName, "'") && StringUtils.endsWith(parameterName, "'")) {
            parameterValue = StringUtils.substringBetween(parameterName, "'");
        } else if (parameterValue.startsWith(KRADConstants.LOOKUP_PARAMETER_LITERAL_PREFIX
                + KRADConstants.LOOKUP_PARAMETER_LITERAL_DELIMITER)) {
            parameterValue = StringUtils.removeStart(parameterValue, KRADConstants.LOOKUP_PARAMETER_LITERAL_PREFIX
                    + KRADConstants.LOOKUP_PARAMETER_LITERAL_DELIMITER);
        }
        // check if parameter is in request
        else if (request.getParameterMap().containsKey(parameterName)) {
            parameterValue = request.getParameter(parameterName);
        }
        // get parameter value from form object
        else {
            parameterValue = ObjectPropertyUtils.getPropertyValue(form, parameterName);
            // TODO: should go through property editor for display
        }

        if (parameterValue != null && lookupObjectClass != null
                && KRADServiceLocatorWeb.getDataObjectAuthorizationService()
                .attributeValueNeedsToBeEncryptedOnFormsAndLinks(lookupObjectClass, propertyName)) {
            try {
                if (CoreApiServiceLocator.getEncryptionService().isEnabled()) {
                    parameterValue = CoreApiServiceLocator.getEncryptionService().encrypt(parameterValue)
                            + EncryptionService.ENCRYPTION_POST_PREFIX;
                }
            } catch (GeneralSecurityException e) {
                LOG.error("Unable to encrypt value for property name: " + propertyName);
                throw new RuntimeException(e);
            }
        }

        return parameterValue;
    }

    /**
     * Retrieves the default KRAD base lookup URL, used to build lookup URLs in code
     *
     * @return String base lookup URL (everything except query string)
     */
    public static String getBaseLookupUrl() {
        return CoreApiServiceLocator.getKualiConfigurationService().getPropertyValueAsString(
                KRADConstants.KRAD_LOOKUP_URL_KEY);
    }

    /**
     * Uses the DataDictionary to determine whether to force uppercase the value, and if it should, then it does the
     * uppercase, and returns the upper-cased value.
     *
     * @param dataObjectClass parent DO class that the fieldName is a member of
     * @param fieldName name of the field to be forced to uppercase
     * @param fieldValue value of the field that may be uppercased
     * @return the correctly uppercased fieldValue if it should be uppercased, otherwise fieldValue is returned
     *         unchanged
     */
    public static String forceUppercase(Class<?> dataObjectClass, String fieldName, String fieldValue) {
        // short-circuit to exit if there isnt enough information to do the forceUppercase
        if (StringUtils.isBlank(fieldValue)) {
            return fieldValue;
        }

        // parameter validation
        if (dataObjectClass == null) {
            throw new IllegalArgumentException("Parameter dataObjectClass passed in with null value.");
        }

        if (StringUtils.isBlank(fieldName)) {
            throw new IllegalArgumentException("Parameter fieldName passed in with empty value.");
        }

        if (!KRADServiceLocatorWeb.getDataDictionaryService().isAttributeDefined(dataObjectClass, fieldName)
                .booleanValue()) {
            return fieldValue;
        }

        boolean forceUpperCase = false;
        try {
            forceUpperCase = KRADServiceLocatorWeb.getDataDictionaryService()
                    .getAttributeForceUppercase(dataObjectClass, fieldName).booleanValue();
        } catch (UnknownBusinessClassAttributeException ubae) {
            // do nothing, don't alter the fieldValue
        }

        if (forceUpperCase && !fieldValue.endsWith(EncryptionService.ENCRYPTION_POST_PREFIX)) {
            return fieldValue.toUpperCase();
        }

        return fieldValue;
    }

    /**
     * Uses the DataDictionary to determine whether to force uppercase the values, and if it should, then it does the
     * uppercase, and returns the upper-cased Map of fieldname/fieldValue pairs.
     *
     * @param dataObjectClass parent DO class that the fieldName is a member of
     * @param fieldValues a Map<String,String> where the key is the fieldName and the value is the fieldValue
     * @return the same Map is returned, with the appropriate values uppercased (if any)
     */
    public static Map<String, String> forceUppercase(Class<?> dataObjectClass, Map<String, String> fieldValues) {
        if (dataObjectClass == null) {
            throw new IllegalArgumentException("Parameter boClass passed in with null value.");
        }

        if (fieldValues == null) {
            throw new IllegalArgumentException("Parameter fieldValues passed in with null value.");
        }

        for (String fieldName : fieldValues.keySet()) {
            fieldValues.put(fieldName, forceUppercase(dataObjectClass, fieldName, fieldValues.get(fieldName)));
        }

        return fieldValues;
    }

    /**
     * Parses and returns the lookup result set limit, checking first for the limit for the specific view,
     * then the class being looked up, and then the global application limit if there isn't a limit specific
     * to this data object class.
     *
     * @param dataObjectClass class to get limit for
     * @param lookupForm lookupForm to use.  May be null if the form is unknown. If lookupForm is null, only the
     * dataObjectClass will be used to find the search results set limit
     * @return result set limit
     */
    public static Integer getSearchResultsLimit(Class dataObjectClass, LookupForm lookupForm) {
        Integer limit = KRADServiceLocatorWeb.getViewDictionaryService().getResultSetLimitForLookup(dataObjectClass,
                lookupForm);
        if (limit == null) {
            limit = getApplicationSearchResultsLimit();
        }

        return limit;
    }

    /**
     * Retrieves the default application search limit configured through a system parameter.
     *
     * @return default result set limit of the application
     */
    public static Integer getApplicationSearchResultsLimit() {
        String limitString = CoreFrameworkServiceLocator.getParameterService()
                .getParameterValueAsString(KRADConstants.KRAD_NAMESPACE,
                        KRADConstants.DetailTypes.LOOKUP_PARM_DETAIL_TYPE,
                        KRADConstants.SystemGroupParameterNames.LOOKUP_RESULTS_LIMIT);
        if (limitString != null) {
            return Integer.valueOf(limitString);
        }

        return null;
    }

    /**
     * Retrieves the default application multiple value search limit configured through a system parameter.
     *
     * @return default multiple value result set limit of the application
     */
    public static Integer getApplicationMultipleValueSearchResultsLimit() {
        String limitString = CoreFrameworkServiceLocator.getParameterService()
                .getParameterValueAsString(KRADConstants.KRAD_NAMESPACE,
                        KRADConstants.DetailTypes.LOOKUP_PARM_DETAIL_TYPE,
                        KRADConstants.SystemGroupParameterNames.MULTIPLE_VALUE_LOOKUP_RESULTS_LIMIT);
        if (limitString != null) {
            return Integer.valueOf(limitString);
        }

        return null;
    }

    /**
     * Determines what Timestamp should be used for active queries on effective dated records. Determination made as
     * follows:
     *
     * <ul>
     * <li>Use activeAsOfDate value from search values Map if value is not empty</li>
     * <li>If search value given, try to convert to sql date, if conversion fails, try to convert to Timestamp</li>
     * <li>If search value empty, use current Date</li>
     * <li>If Timestamp value not given, create Timestamp from given Date setting the time as 1 second before midnight
     * </ul>
     *
     * @param searchValues map containing search key/value pairs
     * @return timestamp to be used for active criteria
     */
    public static Timestamp getActiveDateTimestampForCriteria(Map searchValues) {
        Date activeDate = CoreApiServiceLocator.getDateTimeService().getCurrentSqlDate();

        Timestamp activeTimestamp = null;
        if (searchValues.containsKey(KRADPropertyConstants.ACTIVE_AS_OF_DATE)) {
            String activeAsOfDate = (String) searchValues.get(KRADPropertyConstants.ACTIVE_AS_OF_DATE);
            if (StringUtils.isNotBlank(activeAsOfDate)) {
                try {
                    activeDate = CoreApiServiceLocator.getDateTimeService()
                            .convertToSqlDate(KRADUtils.clean(activeAsOfDate));
                } catch (ParseException e) {
                    // try to parse as timestamp
                    try {
                        activeTimestamp = CoreApiServiceLocator.getDateTimeService()
                                .convertToSqlTimestamp(KRADUtils.clean(activeAsOfDate));
                    } catch (ParseException e1) {
                        throw new RuntimeException("Unable to convert date: " + KRADUtils.clean(activeAsOfDate));
                    }
                }
            }
        }

        // if timestamp not given set to 1 second before midnight on the given date
        if (activeTimestamp == null) {
            Calendar cal = Calendar.getInstance();

            cal.setTime(activeDate);
            cal.set(Calendar.HOUR, cal.getMaximum(Calendar.HOUR));
            cal.set(Calendar.MINUTE, cal.getMaximum(Calendar.MINUTE));
            cal.set(Calendar.SECOND, cal.getMaximum(Calendar.SECOND));

            activeTimestamp = new Timestamp(cal.getTime().getTime());
        }

        return activeTimestamp;
    }

    /**
     * Changes from/to dates into the range operators the lookupable dao expects ("..",">" etc) this method modifies
     * the passed in map and returns an updated search criteria map.
     *
     * @param searchCriteria map of criteria currently set for which the date criteria will be adjusted
     * @return map updated search criteria
     */
    public static Map<String, String> preprocessDateFields(Map<String, String> searchCriteria) {
        Map<String, String> fieldsToUpdate = new HashMap<String, String>();
        Map<String, String> searchCriteriaUpdated = new HashMap<String, String>(searchCriteria);

        Set<String> fieldsForLookup = searchCriteria.keySet();
        for (String propName : fieldsForLookup) {
            if (propName.startsWith(KRADConstants.LOOKUP_RANGE_LOWER_BOUND_PROPERTY_PREFIX)) {
                String from_DateValue = searchCriteria.get(propName);
                String dateFieldName =
                        StringUtils.remove(propName, KRADConstants.LOOKUP_RANGE_LOWER_BOUND_PROPERTY_PREFIX);
                String to_DateValue = searchCriteria.get(dateFieldName);
                String newPropValue = to_DateValue;

                if (StringUtils.isNotEmpty(from_DateValue) && StringUtils.isNotEmpty(to_DateValue)) {
                    newPropValue = from_DateValue + SearchOperator.BETWEEN + to_DateValue;
                } else if (StringUtils.isNotEmpty(from_DateValue) && StringUtils.isEmpty(to_DateValue)) {
                    newPropValue = SearchOperator.GREATER_THAN_EQUAL.op() + from_DateValue;
                } else if (StringUtils.isNotEmpty(to_DateValue) && StringUtils.isEmpty(from_DateValue)) {
                    newPropValue = SearchOperator.LESS_THAN_EQUAL.op() + to_DateValue;
                } // could optionally continue on else here

                fieldsToUpdate.put(dateFieldName, newPropValue);
            }
        }

        // update lookup values from found date values to update
        Set<String> keysToUpdate = fieldsToUpdate.keySet();
        for (String updateKey : keysToUpdate) {
            searchCriteriaUpdated.put(updateKey, fieldsToUpdate.get(updateKey));
        }

        return searchCriteriaUpdated;
    }

    /**
     * Checks whether any of the fieldValues being passed refer to a property within an ExternalizableBusinessObject.
     *
     * @param boClass business object class of the lookup
     * @param fieldValues map of the lookup criteria values
     * @return true if externalizable business object are contained, false otherwise
     * @throws IllegalAccessException
     * @throws InstantiationException
     */
    public static boolean hasExternalBusinessObjectProperty(Class<?> boClass,
            Map<String, String> fieldValues) throws IllegalAccessException, InstantiationException {
        Object sampleBo = boClass.newInstance();
        for (String key : fieldValues.keySet()) {
            if (isExternalBusinessObjectProperty(sampleBo, key)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Check whether the given property represents a property within an EBO starting with the sampleBo object given.
     * This is used to determine if a criteria needs to be applied to the EBO first,
     * before sending to the normal lookup DAO.
     *
     * @param sampleBo business object of the property to be tested
     * @param propertyName property name to be tested
     * @return true if the property is within an externalizable business object.
     */
    public static boolean isExternalBusinessObjectProperty(Object sampleBo, String propertyName) {
        if (propertyName.indexOf(".") > 0 && !StringUtils.contains(propertyName, "add.")) {
            Class<?> propertyClass =
                    ObjectPropertyUtils.getPropertyType(sampleBo, StringUtils.substringBeforeLast(propertyName, "."));
            if (propertyClass != null) {
                return ExternalizableBusinessObjectUtils.isExternalizableBusinessObjectInterface(propertyClass);
            }
        }

        return false;
    }

    /**
     * Returns a map stripped of any properties which refer to ExternalizableBusinessObjects. These values may not be
     * passed into the lookup service, since the objects they refer to are not in the
     * local database.
     *
     * @param boClass business object class of the lookup
     * @param fieldValues map of lookup criteria from which to remove the externalizable business objects
     * @return map of lookup criteria without externalizable business objects
     */
    public static Map<String, String> removeExternalizableBusinessObjectFieldValues(Class<?> boClass,
            Map<String, String> fieldValues) throws IllegalAccessException, InstantiationException {
        Map<String, String> eboFieldValues = new HashMap<String, String>();
        Object sampleBo = boClass.newInstance();
        for (String key : fieldValues.keySet()) {
            if (!isExternalBusinessObjectProperty(sampleBo, key)) {
                eboFieldValues.put(key, fieldValues.get(key));
            }
        }

        return eboFieldValues;
    }

    /**
     * Return the EBO fieldValue entries explicitly for the given eboPropertyName. (I.e., any properties with the given
     * property name as a prefix.
     *
     * @param eboPropertyName the externalizable business object property name to retrieve
     * @param fieldValues map of lookup criteria
     * return map of lookup criteria for the given eboPropertyName
     */
    public static Map<String, String> getExternalizableBusinessObjectFieldValues(String eboPropertyName,
            Map<String, String> fieldValues) {
        Map<String, String> eboFieldValues = new HashMap<String, String>();
        for (String key : fieldValues.keySet()) {
            if (key.startsWith(eboPropertyName + ".")) {
                eboFieldValues.put(StringUtils.substringAfterLast(key, "."), fieldValues.get(key));
            }
        }

        return eboFieldValues;
    }

    /**
     * Get the complete list of all properties referenced in the fieldValues that are ExternalizableBusinessObjects.
     *
     * <p>
     * This is a list of the EBO object references themselves, not of the properties within them.
     * </p>
     *
     * @param boClass business object class of the lookup
     * @param fieldValues map of lookup criteria from which to return the externalizable business objects
     * @return map of lookup criteria that are externalizable business objects
     * @throws IllegalAccessException
     * @throws InstantiationException
     */
    public static List<String> getExternalizableBusinessObjectProperties(Class<?> boClass,
            Map<String, String> fieldValues) throws IllegalAccessException, InstantiationException {
        Set<String> eboPropertyNames = new HashSet<String>();

        Object sampleBo = boClass.newInstance();
        for (String key : fieldValues.keySet()) {
            if (isExternalBusinessObjectProperty(sampleBo, key)) {
                eboPropertyNames.add(StringUtils.substringBeforeLast(key, "."));
            }
        }

        return new ArrayList<String>(eboPropertyNames);
    }

    /**
     * Given an property on the main BO class, return the defined type of the ExternalizableBusinessObject. This will
     * be used by other code to determine the correct module service to call for the lookup.
     *
     * @param boClass business object class of the lookup
     * @param propertyName property of which the externalizable business object type is to be determined
     * @return externalizable business object type
     * @throws IllegalAccessException
     * @throws InstantiationException
     */
    public static Class<? extends ExternalizableBusinessObject> getExternalizableBusinessObjectClass(Class<?> boClass,
            String propertyName) throws IllegalAccessException, InstantiationException {
        return (Class<? extends ExternalizableBusinessObject>) ObjectPropertyUtils
                .getPropertyType(boClass.newInstance(), StringUtils.substringBeforeLast(propertyName, "."));
    }

    /**
     * Looks for criteria against nested EBOs and performs a search against that EBO and updates the criteria.
     *
     * @param searchCriteria map of criteria currently set
     * @param unbounded indicates whether the complete result should be returned.  When set to false the result is
     * limited (if necessary) to the max search result limit configured.
     * @return Map of adjusted criteria for nested EBOs
     * @throws InstantiationException
     * @throws IllegalAccessException
     */
    public static Map<String, String> adjustCriteriaForNestedEBOs(Class<?> dataObjectClass,
            Map<String, String> searchCriteria,
            boolean unbounded) throws InstantiationException, IllegalAccessException {
        // remove the EBO criteria
        Map<String, String> nonEboFieldValues = removeExternalizableBusinessObjectFieldValues(
                dataObjectClass, searchCriteria);
        if (LOG.isDebugEnabled()) {
            LOG.debug("Non EBO properties removed: " + nonEboFieldValues);
        }

        // get the list of EBO properties attached to this object
        List<String> eboPropertyNames = getExternalizableBusinessObjectProperties(dataObjectClass, searchCriteria);
        if (LOG.isDebugEnabled()) {
            LOG.debug("EBO properties: " + eboPropertyNames);
        }

        // loop over those properties
        for (String eboPropertyName : eboPropertyNames) {
            // extract the properties as known to the EBO
            Map<String, String> eboFieldValues = LookupUtils.getExternalizableBusinessObjectFieldValues(eboPropertyName,
                    searchCriteria);
            if (LOG.isDebugEnabled()) {
                LOG.debug("EBO properties for master EBO property: " + eboPropertyName);
                LOG.debug("properties: " + eboFieldValues);
            }

            // run search against attached EBO's module service
            ModuleService eboModuleService = KRADServiceLocatorWeb.getKualiModuleService().getResponsibleModuleService(
                    getExternalizableBusinessObjectClass(dataObjectClass, eboPropertyName));

            // KULRICE-4401 made eboResults an empty list and only filled if service is found.
            List<?> eboResults = Collections.emptyList();
            if (eboModuleService != null) {
                eboResults = eboModuleService.getExternalizableBusinessObjectsListForLookup(
                        getExternalizableBusinessObjectClass(dataObjectClass, eboPropertyName),
                        (Map) eboFieldValues, unbounded);
            } else {
                LOG.debug("EBO ModuleService is null: " + eboPropertyName);
            }

            // get the parent property type
            Class<?> eboParentClass;
            String eboParentPropertyName;
            if (PropertyAccessorUtils.isNestedOrIndexedProperty(eboPropertyName)) {
                eboParentPropertyName = StringUtils.substringBeforeLast(eboPropertyName, ".");
                try {
                    eboParentClass = KradDataServiceLocator.getDataObjectService().wrap(dataObjectClass.newInstance()).getPropertyType(
                            eboParentPropertyName);
                } catch (Exception ex) {
                    throw new RuntimeException(
                            "Unable to create an instance of the business object class: " + dataObjectClass
                                    .getName(), ex);
                }
            } else {
                eboParentClass = dataObjectClass;
                eboParentPropertyName = null;
            }

            if (LOG.isDebugEnabled()) {
                LOG.debug("determined EBO parent class/property name: " + eboParentClass + "/" + eboParentPropertyName);
            }

            // look that up in the DD (BOMDS) find the appropriate relationship
            // CHECK THIS: what if eboPropertyName is a nested attribute - need to strip off the
            // eboParentPropertyName if not null
            RelationshipDefinition rd = KRADServiceLocatorWeb.getLegacyDataAdapter().getDictionaryRelationship(
                    eboParentClass, eboPropertyName);
            if (LOG.isDebugEnabled()) {
                LOG.debug("Obtained RelationshipDefinition for " + eboPropertyName);
                LOG.debug(rd);
            }

            // copy the needed properties (primary only) to the field values KULRICE-4446 do
            // so only if the relationship definition exists
            // NOTE: this will work only for single-field PK unless the ORM
            // layer is directly involved
            // (can't make (field1,field2) in ( (v1,v2),(v3,v4) ) style
            // queries in the lookup framework
            if (KRADUtils.isNotNull(rd)) {
                if (rd.getPrimitiveAttributes().size() > 1) {
                    throw new RuntimeException(
                            "EBO Links don't work for relationships with multiple-field primary keys.");
                }
                String boProperty = rd.getPrimitiveAttributes().get(0).getSourceName();
                String eboProperty = rd.getPrimitiveAttributes().get(0).getTargetName();
                StringBuffer boPropertyValue = new StringBuffer();

                // loop over the results, making a string that the lookup DAO will convert into an
                // SQL "IN" clause
                for (Object ebo : eboResults) {
                    if (boPropertyValue.length() != 0) {
                        boPropertyValue.append(SearchOperator.OR.op());
                    }
                    try {
                        boPropertyValue.append(PropertyUtils.getProperty(ebo, eboProperty).toString());
                    } catch (Exception ex) {
                        LOG.warn("Unable to get value for " + eboProperty + " on " + ebo);
                    }
                }

                if (eboParentPropertyName == null) {
                    // non-nested property containing the EBO
                    nonEboFieldValues.put(boProperty, boPropertyValue.toString());
                } else {
                    // property nested within the main searched-for BO that contains the EBO
                    nonEboFieldValues.put(eboParentPropertyName + "." + boProperty, boPropertyValue.toString());
                }
            }
        }

        return nonEboFieldValues;
    }

    /**
     * Removes query characters (such as wildcards) from the given string value.
     *
     * @param criteriaValue string to clean
     * @return string with query characters removed
     */
    public static String scrubQueryCharacters(String criteriaValue) {
        return StringUtils.replaceEach(criteriaValue, searchList, replacementList);
    }

    /**
     * Generates a key string in case of multivalue return. The values are extracted
     * from the list of properties on the lineDataObject.
     *
     * If fieldConversionKeys is empty return the identifier string for the lineDataObject
     *
     * @param lineDataObject   Object from which to extract values
     * @param fieldConversionKeys List of keys whose values have to be concatenated
     * @return string representing the multivalue key 
     */
    public static String generateMultiValueKey(Object lineDataObject, List<String> fieldConversionKeys) {
        String lineIdentifier = "";

        if(fieldConversionKeys == null || fieldConversionKeys.isEmpty()) {
            lineIdentifier =
                    KRADServiceLocatorWeb.getLegacyDataAdapter().getDataObjectIdentifierString(lineDataObject);
        } else {
            Collections.sort(fieldConversionKeys);
            for (String fromFieldName : fieldConversionKeys) {
                Object fromFieldValue = ObjectPropertyUtils.getPropertyValue(lineDataObject, fromFieldName);

                if (fromFieldValue != null) {
                    lineIdentifier += fromFieldValue;
                }

                lineIdentifier += ":";
            }
            lineIdentifier = StringUtils.removeEnd(lineIdentifier, ":");
        }

        return lineIdentifier;
    }

    /**
     * Merges the lookup result selections that are part of the request with the selectedLookupResultsCache maintained in
     * the session.
     *
     * @param form lookup form instance containing the selected results and lookup configuration
     */
    public static void refreshLookupResultSelections(LookupForm form) {

        int displayStart = 0;
        int displayLength = 0;

        // avoid blowing the stack if the session expired
        ViewPostMetadata viewPostMetadata = form.getViewPostMetadata();
        if (viewPostMetadata != null) {

            // only one concurrent request per view please
            synchronized (viewPostMetadata) {
                ComponentPostMetadata oldCollectionGroup = viewPostMetadata.getComponentPostMetadata("uLookupResults");
                displayStart = (Integer) oldCollectionGroup.getData(UifConstants.PostMetadata.COLL_DISPLAY_START);
                displayLength = (Integer) oldCollectionGroup.getData(UifConstants.PostMetadata.COLL_DISPLAY_LENGTH);
            }
        }

        List<? extends Object> lookupResults = (List<? extends Object>) form.getLookupResults();
        List<String> fromFieldNames = form.getMultiValueReturnFields();

        Set<String> selectedLines = form.getSelectedCollectionLines().get(UifPropertyPaths.LOOKUP_RESULTS);
        Set<String> selectedLookupResultsCache = form.getSelectedLookupResultsCache();

        selectedLines = (selectedLines == null) ? new HashSet<String>() : selectedLines;


        for(int i = displayStart; i < displayStart + displayLength; i++ ) {
            if(i >= form.getLookupResults().size()) break;

            Object lineItem = lookupResults.get(i);
            String lineIdentifier = LookupUtils.generateMultiValueKey(lineItem, fromFieldNames);

            if(!selectedLines.contains(lineIdentifier)) {
                 selectedLookupResultsCache.remove(lineIdentifier);
            } else {
                selectedLookupResultsCache.add(lineIdentifier);
            }
        }

        selectedLines.addAll( selectedLookupResultsCache );

        form.getSelectedCollectionLines().put(UifPropertyPaths.LOOKUP_RESULTS, selectedLines);
    }

}
```


Overlapping Code:
```
ils {
private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(LookupUtils.class);
private static final String[] searchList = new String[SearchOperator.QUERY_CHARACTERS.size()];
static {
int index = 0;
for (SearchOperator operator : SearchOperator.QUERY_CHARACTERS) {
searchList[index++] = operator.op();
}
}
private static final String[] replacementList = Collections.nCopies(searchList.length, "").toArray(new String[0]);
private LookupUtils() {}
/**
* Retrieves the value for the given parameter name to send as a lookup parameter.
*
* @param form form instance to retrieve values from
* @param request request object to retrieve parameters from
* @param lookupObjectClass data object class associated with the lookup, used to check whether the
* value needs to be encyrpted
* @param propertyName name of the property associated with the parameter, used to check whether the
* value needs to be encrypted
* @param parameterName name of the parameter to retrieve the value for
* @return String parameter value or empty string if no value was found
*/
public static String retrieveLookupParameterValue(UifFormBase form, HttpServletRequest request,
Class<?> lookupObjectClass, String propertyName, String parameterName) {
String parameterValue = "";
// get literal parameter values first
if (StringUtils.startsWith(parameterName, "'") && StringUtils.endsWith(parameterName, "'")) {
parameterValue = StringUtils.substringBetween(parameterName, "'");
} else if (parameterValue.startsWith(KRADConstants.LOOKUP_PARAMETER_LITERAL_PREFIX
+ KRADConstants.LOOKUP_PARAMETER_LITERAL_DELIMITER)) {
parameterValue = StringUtils.removeStart(parameterValue, KRADConstants.LOOKUP_PARAMETER_LITERAL_PREFIX
+ KRADConstants.LOOKUP_PARAMETER_LITERAL_DELIMITER);
}
// check if parameter is in request
else if (request.getParameterMap().containsKey(parameterName)) {
parameterValue = request.getParameter(parameterName);
}
// get parameter value from form object
else {
parameterValue = ObjectPropertyUtils.getPropertyValue(form, parameterName);
// TODO: s
```
<Overlap Ratio: 0.9694548872180451>

---

--- 300 --
Question ID: 744edbceebb73ca88ea42d43bb803206af553de6
Original Code:
```
@Configuration
public class WebApplicationConfig implements WebMvcConfigurer {

    /**
     * Custom object mapper to make sure that dates and other values serialize
     * correctly.
     *
     * @return A new object mapper.
     */
    private ObjectMapper objectMapper() {
        Jackson2ObjectMapperFactoryBean bean = new Jackson2ObjectMapperFactoryBean();
        bean.setIndentOutput(true);
        bean.afterPropertiesSet();
        ObjectMapper objectMapper = bean.getObject();
        if (objectMapper != null) {
            objectMapper.registerModule(new JavaTimeModule());
            objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); // replacement for ISO8601DateFormat which is deprecated
        }
        return objectMapper;
    }

    /**
     * Set custom JSON converter.
     *
     * @return New custom converter with a correct object mapper.
     */
    private MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() {
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        converter.setObjectMapper(objectMapper());
        return converter;
    }

    /**
     * Register the JSON converters.
     */
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        converters.add(mappingJackson2HttpMessageConverter());
    }

}
```


Overlapping Code:
```
figuration
public class WebApplicationConfig implements WebMvcConfigurer {
/**
* Custom object mapper to make sure that dates and other values serialize
* correctly.
*
* @return A new object mapper.
*/
private ObjectMapper objectMapper() {
Jackson2ObjectMapperFactoryBean bean = new Jackson2ObjectMapperFactoryBean();
bean.setIndentOutput(true);
bean.afterPropertiesSet();
ObjectMapper objectMapper = bean.getObject();
if (objectMapper != null) {
objectMapper.registerModule(new JavaTimeModule());
objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); // replacement for ISO8601DateFormat which is deprecated
}
return objectMapper;
}
/**
* Set custom JSON converter.
*
* @return New custom converter with a correct object mapper.
*/
private MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() {
MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
converter.setObjectMapper(objectMapper());
return converter;
}
/**
* Register the JSON converters.
*/
@Override
public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
converters.add(mappingJackson2HttpMessageConverter());
}
```
<Overlap Ratio: 0.9949579831932773>

---

--- 301 --
Question ID: 9f25e878002a228b7b3c049717160813559b8baa
Original Code:
```
public class DateUtilJUnitPerfTest extends TestCase {
    public DateUtilJUnitPerfTest(String name) {
        super(name);
    }

    @Before
    public void setup() {

    }

    @After
    public void tearDown() {

    }

    public void testCompareDateTime() {
        String dateTime1 = "20120111 01:02:03";
        String dateTime2 = "20130111 01:02:03";
        String dateTime3 = "20130111 01:02:03";

        Assert.assertEquals(-1, DateUtil.compareDateTime(dateTime1, dateTime2));
        Assert.assertEquals(1, DateUtil.compareDateTime(dateTime2, dateTime1));
        Assert.assertEquals(0, DateUtil.compareDateTime(dateTime2, dateTime3));
    }

    /*
     * http://www.cnblogs.com/loggingselenium/archive/2013/01/08/2850605.html
     */
    public static junit.framework.Test compareDateTimeLoadTestMethod() {
        int users = 5;
        TestFactory factory = new TestMethodFactory(DateUtilJUnitPerfTest.class, "testCompareDateTime");
        junit.framework.Test loadTest = new LoadTest(factory, users);
        return loadTest;
    }

    public static junit.framework.Test suite() {
        TestSuite suite = new TestSuite();
        suite.addTest(compareDateTimeLoadTestMethod());
        return suite;
    }

    public static void main(String args[]) {
        junit.textui.TestRunner.run(suite());
    }
}
```


Overlapping Code:
```
xtends TestCase {
public DateUtilJUnitPerfTest(String name) {
super(name);
}
@Before
public void setup() {
}
@After
public void tearDown() {
}
public void testCompareDateTime() {
String dateTime1 = "20120111 01:02:03";
String dateTime2 = "20130111 01:02:03";
String dateTime3 = "20130111 01:02:03";
Assert.assertEquals(-1, DateUtil.compareDateTime(dateTime1, dateTime2));
Assert.assertEquals(1, DateUtil.compareDateTime(dateTime2, dateTime1));
Assert.assertEquals(0, DateUtil.compareDateTime(dateTime2, dateTime3));
}
/*
* http://www.cnblogs.com/loggingselenium/archive/2013/01/08/2850605.html
*/
public static junit.framework.Test compareDateTimeLoadTestMethod() {
int users = 5;
TestFactory factory = new TestMethodFactory(DateUtilJUnitPerfTest.class, "testCompareDateTime");
junit.framework.Test loadTest = new LoadTest(factory, users);
return loadTest;
}
public static junit.framework.Test suite() {
TestSuite suite = new TestSuite();
suite.addTest(compareDateTimeLoadTestMethod());
return suite;
}
public static void main(String args[]) {
junit.textui.TestRunner.run(suite());
}
}
```
<Overlap Ratio: 0.967885816235504>

---

--- 302 --
Question ID: 3878019c50fb9aafad81e397489e5136cdb3ec05
Original Code:
```
@Controller
@Slf4j
public class IndexController extends AbstractController {
	@Autowired
	private ArticleService articleService;
	@Autowired
	private PeriodicalService periodicalService;
	@RequestMapping(value={"/index","/",""},method = RequestMethod.GET)
	public ModelAndView welcome(HttpServletRequest request, HttpServletResponse response,
								ModelMap model) {
		articlesTop10(request,model);
		docsTop10(request,model);
		super.success(model);
		return new ModelAndView("index");
	}
	public void articlesTop10(HttpServletRequest request,ModelMap model){
		final Collection<SearchFilter> filters= DynamicSpecifications.buildSearchFilters(request);
		filters.add(new SearchFilter("isPub", SearchFilter.Operator.EQ,Boolean.TRUE));
		Specification<Article> spec= DynamicSpecifications.bySearchFilter(filters, Article.class);
		PageRequest pageRequest= DynamicPageRequest.buildPageRequest(1,10, "pushTime",CommonConst.Page.ORDER_DESC,Article.class);
		Page<Article> pag = this.articleService.findAll(spec, pageRequest);
		if(pag!=null&&pag.hasContent()){
			List<ArticleVO> vos = Lists.newArrayList();
			for(Article po:pag.getContent()){
				vos.add(new ArticleVO(po));
			}
			Page<ArticleVO> docVos  =new PageImpl<ArticleVO>(vos,pageRequest,pag.getTotalElements());
			model.put("articles",docVos);
		}
	}

	public void docsTop10(HttpServletRequest request,ModelMap model){
		final Collection<SearchFilter> filters= DynamicSpecifications.buildSearchFilters(request);
		filters.add(new SearchFilter("isPub", SearchFilter.Operator.EQ,Boolean.TRUE));
		Specification<Periodical> spec= DynamicSpecifications.bySearchFilter(filters, Periodical.class);
		PageRequest pageRequest= DynamicPageRequest.buildPageRequest(1,5, "pushTime",CommonConst.Page.ORDER_DESC,Periodical.class);
		Page<Periodical> pag = this.periodicalService.findAll(spec, pageRequest);
		if(pag!=null&&pag.hasContent()){
			List<PeriodicalVO> vos = Lists.newArrayList();
			for(Periodical po:pag.getContent()){
				vos.add(new PeriodicalVO(po));
			}
			Page<PeriodicalVO> docVos  =new PageImpl<PeriodicalVO>(vos,pageRequest,pag.getTotalElements());
			model.put("docs",docVos);
		}
	}

}
```


Overlapping Code:
```
troller
@Slf4j
public class IndexController extends AbstractController {
@Autowired
private ArticleService articleService;
@Autowired
private PeriodicalService periodicalService;
@RequestMapping(value={"/index","/",""},method = RequestMethod.GET)
public ModelAndView welcome(HttpServletRequest request, HttpServletResponse response,
ModelMap model) {
articlesTop10(request,model);
docsTop10(request,model);
super.success(model);
return new ModelAndView("index");
}
public void articlesTop10(HttpServletRequest request,ModelMap model){
final Collection<SearchFilter> filters= DynamicSpecifications.buildSearchFilters(request);
filters.add(new SearchFilter("isPub", SearchFilter.Operator.EQ,Boolean.TRUE));
Specification<Article> spec= DynamicSpecifications.bySearchFilter(filters, Article.class);
PageRequest pageRequest= DynamicPageRequest.buildPageRequest(1,10, "pushTime",CommonConst.Page.ORDER_DESC,Article.class);
Page<Article> pag = this.articleService.findAll(spec, pageRequest);
if(pag!=null&&pag.hasContent()){
List<ArticleVO> vos = Lists.newArrayList();
for(Article po:pag.getContent()){
vos.add(new ArticleVO(po));
}
Page<ArticleVO> docVos =new PageImpl<ArticleVO>(vos,pageRequest,pag.getTotalElements());
model.put("articles",docVos);
}
}
public void docsTop10(HttpServletRequest request,ModelMap model){
final Collection<SearchFilter> filters= DynamicSpecifications.buildSearchFilters(request);
filters.add(new SearchFilter("isPub", SearchFilter.Operator.EQ,Boolean.TRUE));
Specification<Periodical> spec= DynamicSpecifications.bySearchFilter(filters, Periodical.class);
PageRequest pageRequest= DynamicPageRequest.buildPageRequest(1,5, "pushTime",CommonConst.Page.ORDER_DESC,Periodical.class);
Page<Periodical> pag = this.periodicalService.findAll(spec, pageRequest);
if(pag!=null&&pag.hasContent()){
List<PeriodicalVO> vos = Lists.newArrayList();
for(Periodical po:pag.getContent()){
vos.add(new PeriodicalVO(po));
}
Page<PeriodicalVO> docVos =new PageImpl<PeriodicalVO>(vos,pageRequest,pag.getTotalElements());
mod
```
<Overlap Ratio: 0.9844735565259582>

---

--- 303 --
Question ID: 106ddf86929415f459f4a7be0e605fa317d1984d
Original Code:
```
public class CommonUtil {

    private static final Logger log = LoggerFactory.getLogger(CommonUtil.class);

    public static String urlEncode(final String value) {
        try {
            return URLEncoder.encode(value, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("could not encode url encode string");
        }
    }

    public static String urlDecode(final String value) {
        try {
            return URLDecoder.decode(value, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("could not decode url encode string");
        }
    }

    public static String toHexString(byte[] bytes) {
        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();

        for (int i = 0; i < bytes.length; i++) {
//            sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
            sb.append(Integer.toHexString(0xFF & bytes[i]));
        }

        return sb.toString();
    }

    public static String getTextSha256sum(String text) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");

            md.update(text.getBytes());

            byte byteData[] = md.digest();

            return toHexString(byteData);
        } catch (NoSuchAlgorithmException e) {
            log.error("SHA-256 digest algorithm not available!", e);
            throw new AppException(e);
        }
    }

    public static String getFileSha256sum(String fileName) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");

            FileInputStream fis = new FileInputStream(fileName);

            byte[] dataBytes = new byte[1024];

            int nread = 0;
            while ((nread = fis.read(dataBytes)) != -1) {
                md.update(dataBytes, 0, nread);
            }

            byte[] sumBytes = md.digest();

            return toHexString(sumBytes);
        } catch (NoSuchAlgorithmException e) {
            log.error("SHA-256 digest algorithm not available!", e);
            throw new AppException(e);
        } catch (IOException ioe) {
            log.error("file read failed!", ioe);
            throw new AppException(ioe);
        }
    }
}
```


Overlapping Code:
```
public class CommonUtil {
private static final Logger log = LoggerFactory.getLogger(CommonUtil.class);
public static String urlEncode(final String value) {
try {
return URLEncoder.encode(value, "UTF-8");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException("could not encode url encode string");
}
}
public static String urlDecode(final String value) {
try {
return URLDecoder.decode(value, "UTF-8");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException("could not decode url encode string");
}
}
public static String toHexString(byte[] bytes) {
//convert the byte to hex format method 1
StringBuffer sb = new StringBuffer();
for (int i = 0; i < bytes.length; i++) {
// sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
sb.append(Integer.toHexString(0xFF & bytes[i]));
}
return sb.toString();
}
public static String getTextSha256sum(String text) {
try {
MessageDigest md = MessageDigest.getInstance("SHA-256");
md.update(text.getBytes());
byte byteData[] = md.digest();
return toHexString(byteData);
} catch (NoSuchAlgorithmException e) {
log.error("SHA-256 digest algorithm not available!", e);
throw new AppException(e);
}
}
public static String getFileSha256sum(String fileName) {
try {
MessageDigest md = MessageDigest.getInstance("SHA-256");
FileInputStream fis = new FileInputStream(fileName);
byte[] dataBytes = new byte[1024];
int nread = 0;
while ((nread = fis.read(dataBytes)) != -1) {
md.update(dataBytes, 0, nread);
}
byte[] sumBytes = md.digest();
return toHexString(sumBytes);
} catch (NoSuchAlgorithmException e) {
log.error("SHA-256 digest algorithm not available!", e);
throw new AppException(e);
} catch (IOException ioe) {
log.error("file read failed!", ioe);
throw new AppException(ioe);
}

```
<Overlap Ratio: 0.9983050847457627>

---

--- 304 --
Question ID: 0fd5f10a9f8a363119112181aea92b8d58291412
Original Code:
```
@javax.annotation.Generated(value = "io.swagger.codegen.languages.SpringCodegen", date = "2017-08-22T11:29:03.578Z")

public class InlineResponse2001   {
  @JsonProperty("slotId")
  private Long slotId = null;

  @JsonProperty("startTime")
  private String startTime = null;

  @JsonProperty("endTime")
  private String endTime = null;

  @JsonProperty("doctorId")
  private Integer doctorId = null;

  public InlineResponse2001 slotId(Long slotId) {
    this.slotId = slotId;
    return this;
  }

   /**
   * Get slotId
   * @return slotId
  **/
  @ApiModelProperty(value = "")


  public Long getSlotId() {
    return slotId;
  }

  public void setSlotId(Long slotId) {
    this.slotId = slotId;
  }

  public InlineResponse2001 startTime(String startTime) {
    this.startTime = startTime;
    return this;
  }

   /**
   * Get startTime
   * @return startTime
  **/
  @ApiModelProperty(value = "")


  public String getStartTime() {
    return startTime;
  }

  public void setStartTime(String startTime) {
    this.startTime = startTime;
  }

  public InlineResponse2001 endTime(String endTime) {
    this.endTime = endTime;
    return this;
  }

   /**
   * Get endTime
   * @return endTime
  **/
  @ApiModelProperty(value = "")


  public String getEndTime() {
    return endTime;
  }

  public void setEndTime(String endTime) {
    this.endTime = endTime;
  }

  public InlineResponse2001 doctorId(Integer doctorId) {
    this.doctorId = doctorId;
    return this;
  }

   /**
   * Get doctorId
   * @return doctorId
  **/
  @ApiModelProperty(value = "")


  public Integer getDoctorId() {
    return doctorId;
  }

  public void setDoctorId(Integer doctorId) {
    this.doctorId = doctorId;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    InlineResponse2001 inlineResponse2001 = (InlineResponse2001) o;
    return Objects.equals(this.slotId, inlineResponse2001.slotId) &&
        Objects.equals(this.startTime, inlineResponse2001.startTime) &&
        Objects.equals(this.endTime, inlineResponse2001.endTime) &&
        Objects.equals(this.doctorId, inlineResponse2001.doctorId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(slotId, startTime, endTime, doctorId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class InlineResponse2001 {\n");
    
    sb.append("    slotId: ").append(toIndentedString(slotId)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    doctorId: ").append(toIndentedString(doctorId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}
```


Overlapping Code:
```
@javax.annotation.Generated(value = "io.swagger.codegen.languages.SpringCodegen", date = "2017-08-22T11:29:03.578Z")
public class InlineResponse2001 {
@JsonProperty("slotId")
private Long slotId = null;
@JsonProperty("startTime")
private String startTime = null;
@JsonProperty("endTime")
private String endTime = null;
@JsonProperty("doctorId")
private Integer doctorId = null;
public InlineResponse2001 slotId(Long slotId) {
this.slotId = slotId;
return this;
}
/**
* Get slotId
* @return slotId
**/
@ApiModelProperty(value = "")
public Long getSlotId() {
return slotId;
}
public void setSlotId(Long slotId) {
this.slotId = slotId;
}
public InlineResponse2001 startTime(String startTime) {
this.startTime = startTime;
return this;
}
/**
* Get startTime
* @return startTime
**/
@ApiModelProperty(value = "")
public String getStartTime() {
return startTime;
}
public void setStartTime(String startTime) {
this.startTime = startTime;
}
public InlineResponse2001 endTime(String endTime) {
this.endTime = endTime;
return this;
}
/**
* Get endTime
* @return endTime
**/
@ApiModelProperty(value = "")
public String getEndTime() {
return endTime;
}
public void setEndTime(String endTime) {
this.endTime = endTime;
}
public InlineResponse2001 doctorId(Integer doctorId) {
this.doctorId = doctorId;
return this;
}
/**
* Get doctorId
* @return doctorId
**/
@ApiModelProperty(value = "")
public Integer getDoctorId() {
return doctorId;
}
public void setDoctorId(Integer doctorId) {
this.doctorId = doctorId;
}
@Override
public boolean equals(java.lang.Object o) {
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
InlineResponse2001 inlineResponse2001 = (InlineResponse2001) o;
return Objects.equals(this.slotId, inlineResponse2001.slotId) &&
Objects.equals(this.startTime, inlineResponse2001.startTime) &&
Objects.equals(this.endTime, inlineResponse2001.endTime) &&
Objects.equals(this.doctorId, inlineResponse2001.doctorId);
}
@Override
public int hashCode() {
return Objects.hash(slotId, startTime, endTime, doct
```
<Overlap Ratio: 0.9794455066921606>

---

--- 305 --
Question ID: ba62e71cfec2c5fc8d36a69dc8937f018b88fe62
Original Code:
```
@Path("/")
@Api(value = "/kb", description = "Operations about knowledge base", basePath = "kb")
public class KnowledgeBaseResource {
    private KnowledgeBaseManager kbManager;
    private NfpManager nfpManager;
    private Logger log = LoggerFactory.getLogger(KnowledgeBaseResource.class);

    @Inject
    KnowledgeBaseResource(KnowledgeBaseManager knowledgeBaseManager, NfpManager nfpManager) {
        this.kbManager = knowledgeBaseManager;
        this.nfpManager = nfpManager;
    }

    @DELETE
    @Produces({"application/json"})
    @ApiOperation(value = "Clear all knowledge base",
            notes = "BE CAREFUL! You can lose all your data. It returns a message which confirms that the knowledge base is empty.")
    @ApiResponses(
            value = {
                    @ApiResponse(code = 200, message = "Knowledge base cleaned. All the concepts are deleted."),
                    @ApiResponse(code = 304, message = "Knowledge base could not be cleared."),
                    @ApiResponse(code = 403, message = "You have not got the appropriate permissions for clearing the knowledge base"),
                    @ApiResponse(code = 500, message = "Internal error")})
    public Response clearServices() {
        if (kbManager.clearKnowledgeBase()) {
            return Response.status(Response.Status.OK).entity(createJsonMessage("Knowledge base cleaned. All the concepts are deleted.")).build();
        } else {
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(createJsonMessage("Internal error")).build();
        }

    }

    @GET
    @Path("subclasses")
    @Produces({"application/json"})
    @ApiOperation(value = "Get subclasses of a concept",
            notes = "It returns subclasses of a specific concept")
    @ApiResponses(
            value = {
                    @ApiResponse(code = 200, message = "List of subclasses"),
                    @ApiResponse(code = 400, message = "Malformed input"),
                    @ApiResponse(code = 500, message = "Internal error")})
    public Response getSubclasses(
            @ApiParam(value = "URI of the concept (e.g., http://schema.org/Action)", required = true)
            @QueryParam("uri") String uri,
            @ApiParam(value = "If this parameter is set as TRUE, the function will return only direct subclasses", allowableValues = "true,false")
            @QueryParam("direct") String direct) {
        try {
            Set<URI> subclasses = kbManager.listSubClasses(new URI(uri), Boolean.parseBoolean(direct));
            return Response.status(Response.Status.OK).entity(createJsonMessage(createResultSet(subclasses))).build();
        } catch (URISyntaxException e) {
            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();
        }
    }


    @GET
    @Path("superclasses")
    @Produces({"application/json"})
    @ApiOperation(value = "Get superclasses of a concept",
            notes = "It returns superclasses of a specific concept")
    @ApiResponses(
            value = {
                    @ApiResponse(code = 200, message = "List of superclasses"),
                    @ApiResponse(code = 400, message = "Malformed input"),
                    @ApiResponse(code = 500, message = "Internal error")})
    public Response getSuperclasses(
            @ApiParam(value = "URI of the concept (e.g., http://schema.org/Action)", required = true)
            @QueryParam("uri") String uri,
            @ApiParam(value = "If this parameter is set as TRUE, the function will return only direct superclasses", allowableValues = "true,false")
            @QueryParam("direct") String direct) {
        try {
            Set<URI> classes = kbManager.listSuperClasses(new URI(uri), Boolean.parseBoolean(direct));
            return Response.status(Response.Status.OK).entity(createJsonMessage(createResultSet(classes))).build();
        } catch (URISyntaxException e) {
            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();
        }
    }

    @GET
    @Path("equivalentClasses")
    @Produces({"application/json"})
    @ApiOperation(value = "List classes equivalent to a specific concept",
            notes = "It returns a list of classes")
    @ApiResponses(
            value = {
                    @ApiResponse(code = 200, message = "List of equivalent classes"),
                    @ApiResponse(code = 400, message = "Malformed input"),
                    @ApiResponse(code = 500, message = "Internal error")})
    public Response getEquivalentClasses(
            @ApiParam(value = "URI of the concept (e.g., http://schema.org/Action)", required = true)
            @QueryParam("uri") String uri
    ) {
        try {
            Set<URI> classes = kbManager.listEquivalentClasses(new URI(uri));
            return Response.status(Response.Status.OK).entity(createJsonMessage(createResultSet(classes))).build();
        } catch (URISyntaxException e) {
            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();
        }
    }

    @GET
    @Produces({"application/json"})
    @ApiOperation(value = "List concepts in the knowledge base",
            notes = "It returns a list of concepts")
    @ApiResponses(
            value = {
                    @ApiResponse(code = 200, message = "List of concepts"),
                    @ApiResponse(code = 400, message = "Malformed input"),
                    @ApiResponse(code = 500, message = "Internal error")})
    public Response listConcepts(
            @ApiParam(value = "URI of the model. If empty it will return all the concepts in the Knowledge Base")
            @QueryParam("uri") String uri
    ) {
        try {
            Set<URI> classes;
            if (uri != null && !uri.equals("")) {
                classes = kbManager.listConcepts(new URI(uri));
            } else {
                classes = kbManager.listConcepts(null);
            }
            return Response.status(Response.Status.OK).entity(createJsonMessage(createResultSet(classes))).build();
        } catch (URISyntaxException e) {
            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();
        }
    }

    @GET
    @Path("linkedConcepts")
    @Produces({"application/json"})
    @ApiOperation(value = "List concepts linked by a chain of properties",
            notes = "It returns subclasses of a specific concept")
    @ApiResponses(
            value = {
                    @ApiResponse(code = 200, message = "Map of linked concepts"),
                    @ApiResponse(code = 400, message = "Malformed input"),
                    @ApiResponse(code = 500, message = "Internal error")})
    public Response listLinkedConcepts(
            @ApiParam(value = "Chain of properties that specify the link between concepts", required = true)
            @QueryParam("property") List<String> properties,
            @ApiParam(value = "Specify which property of the chain is transitive (e.g., rdfs:subClassOf)")
            @QueryParam("transitiveProperty") List<String> transitiveProperties,
            @ApiParam(value = "Class of the source concept")
            @QueryParam("sourceClass") String sourceClass,
            @ApiParam(value = "Class of the source concept")
            @QueryParam("targetClass") String targetClass) {
        try {
            URI sourceClassUri = null;
            URI targetClassUri = null;
            Multimap<KnowledgeBaseResult, KnowledgeBaseResult> r = HashMultimap.create();
            if (sourceClass != null) {
                sourceClassUri = new URI(sourceClass);
            }
            if (targetClass != null) {
                targetClassUri = new URI(targetClass);
            }
            List<URI> propertyUris = Lists.newArrayList();
            for (String property : properties) {
                propertyUris.add(new URI(property));
            }
            Set<URI> transitivePropertyUris = Sets.newHashSet();
            for (String transitiveProperty : transitiveProperties) {
                transitivePropertyUris.add(new URI(transitiveProperty));
            }
            Multimap<URI, URI> linkedConcepts = kbManager.listLinkedConcepts(propertyUris, sourceClassUri, targetClassUri, transitivePropertyUris);
            createResultSet(linkedConcepts.keySet());
            createResultSet(linkedConcepts.values());
            for (URI source : linkedConcepts.keySet()) {
                r.putAll(createResultSet(source), createResultSet(linkedConcepts.get(source)));
            }

            return Response.status(Response.Status.OK).entity(createJsonMessage(sourceClassUri, targetClassUri, propertyUris, r)).build();
        } catch (Exception e) {
            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();
        }
    }

    @GET
    @Path("models")
    @Produces({"application/json"})
    @ApiOperation(value = "List models available in the knowledge base",
            notes = "It returns a list of models")
    @ApiResponses(
            value = {
                    @ApiResponse(code = 200, message = "List of models"),
                    @ApiResponse(code = 500, message = "Internal error")})
    public Response getLoadedModels() {
        Set<URI> r = kbManager.getLoadedModels();
        return Response.status(Response.Status.OK).entity(createJsonMessage(r)).build();
    }

    @POST
    @Path("models")
    @Consumes({"application/rdf+xml", "text/turtle", "text/n3", "text/rdf+n3", "application/n-triples"})
    @Produces({"application/json"})
    @ApiOperation(value = "Upload a model in the knowledge base",
            notes = "It returns a list of models")
    @ApiResponses(
            value = {
                    @ApiResponse(code = 200, message = "Model uploaded"),
                    @ApiResponse(code = 400, message = "Malformed input"),
                    @ApiResponse(code = 500, message = "Internal error")})
    public Response uploadModel(@ApiParam(value = "URI of the remote ontology or URI that identifies a local model", required = true)
                                @QueryParam("uri") String uri,
                                @ApiParam(value = "Ontology to by uploaded in the knowledge base")
                                String ontology,
                                @ApiParam(value = "Force the upload of the model", allowableValues = "true,false")
                                @QueryParam("forceUpdate") String forceUpdate,
                                @HeaderParam("Content-Type") String contentType) {

        try {
            Model model = ModelFactory.createDefaultModel();
            if (ontology == null || ontology.equals("")) {
                model.read(uri);
            } else {
                String lang = "RDF/XML";
                if (contentType.equals("text/turtle")) {
                    lang = "TTL";
                } else if (contentType.equals("text/n3") || contentType.equals("text/rdf+n3")) {
                    lang = "N3";
                } else if (contentType.equals("application/n-triples")) {
                    lang = "N-TRIPLE";
                }

                model.read(new ByteArrayInputStream(ontology.getBytes(StandardCharsets.UTF_8)), uri, lang);
            }

            kbManager.uploadModel(new URI(uri), model, Boolean.parseBoolean(forceUpdate));
            return Response.status(Response.Status.OK).entity(createJsonMessage("Model uploaded with success")).build();
        } catch (Exception e) {
            e.printStackTrace();
            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();
        }

    }

    @DELETE
    @Path("models")
    @Produces({"application/json"})
    @ApiOperation(value = "Delete a model from the knowledge base",
            notes = "It returns a list of models")
    @ApiResponses(
            value = {
                    @ApiResponse(code = 200, message = "List of models"),
                    @ApiResponse(code = 400, message = "Malformed input"),
                    @ApiResponse(code = 500, message = "Internal error")})
    public Response deleteModel(@ApiParam(value = "URI of the remote ontology or URI that identifies a local model", required = true)
                                @QueryParam("uri") String uri) {
        try {
            if (kbManager.deleteModel(new URI(uri))) {
                return Response.status(Response.Status.OK).entity(createJsonMessage("Model deleted with success")).build();
            }
            return Response.status(Response.Status.NOT_FOUND).entity(createJsonMessage("Model not found")).build();
        } catch (Exception e) {
            e.printStackTrace();
            return Response.status(Response.Status.BAD_REQUEST).entity(createJsonMessage(e.getMessage())).build();
        }

    }

    private String createJsonMessage(String text) {
        JsonObject message = new JsonObject();
        message.add("message", new JsonPrimitive(text));
        return message.toString();
    }

    private String createJsonMessage(Object o) {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        return gson.toJson(o);
    }

    private String createJsonMessage(URI source, URI target, List<URI> properties, Multimap<KnowledgeBaseResult, KnowledgeBaseResult> map) {
        Gson gson = new Gson();
        JsonObject message = new JsonObject();
        if (source != null) {
            message.add("source", gson.toJsonTree(source));
        }
        if (target != null) {
            message.add("target", gson.toJsonTree(target));
        }
        if (properties != null) {
            message.add("properties", gson.toJsonTree(properties));
        }
        JsonArray resultList = new JsonArray();
        message.add("result", resultList);
        for (KnowledgeBaseResult s : map.keySet()) {
            JsonObject entry = new JsonObject();
            resultList.add(entry);
            JsonElement sJson = gson.toJsonTree(s);
            entry.add("source", sJson);
            JsonElement tJson = gson.toJsonTree(map.get(s));
            entry.add("target", tJson);
        }
        return message.toString();
    }

    private Set<KnowledgeBaseResult> createResultSet(Collection<URI> uris) {
        Set<KnowledgeBaseResult> r = Sets.newLinkedHashSet();
        Map<URI, Object> labels = nfpManager.getPropertyValueOfResources(new HashSet<URI>(uris), URI.create(RDFS.label.getURI()), String.class);
        for (URI uri : uris) {
            r.add(new KnowledgeBaseResult(uri, labels.get(uri)));
        }
        return r;
    }

    private KnowledgeBaseResult createResultSet(URI uri) {
        Object label = nfpManager.getPropertyValue(uri, URI.create(RDFS.label.getURI()), String.class);
        return new KnowledgeBaseResult(uri, label);
    }

}
```


Overlapping Code:
```
/")
@Api(value = "/kb", description = "Operations about knowledge base", basePath = "kb")
public class KnowledgeBaseResource {
private KnowledgeBaseManager kbManager;
private NfpManager nfpManager;
private Logger log = LoggerFactory.getLogger(KnowledgeBaseResource.class);
@Inject
KnowledgeBaseResource(KnowledgeBaseManager knowledgeBaseManager, NfpManager nfpManager) {
this.kbManager = knowledgeBaseManager;
this.nfpManager = nfpManager;
}
@DELETE
@Produces({"application/json"})
@ApiOperation(value = "Clear all knowledge base",
notes = "BE CAREFUL! You can lose all your data. It returns a message which confirms that the knowledge base is empty.")
@ApiResponses(
value = {
@ApiResponse(code = 200, message = "Knowledge base cleaned. All the concepts are deleted."),
@ApiResponse(code = 304, message = "Knowledge base could not be cleared."),
@ApiResponse(code = 403, message = "You have not got the appropriate permissions for clearing the knowledge base"),
@ApiResponse(code = 500, message = "Internal error")})
public Response clearServices() {
if (kbManager.clearKnowledgeBase()) {
return Response.status(Response.Status.OK).entity(createJsonMessage("Knowledge base cleaned. All the concepts are deleted.")).build();
} else {
return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(createJsonMessage("Internal error")).build();
}
}
@GET
@Path("subclasses")
@Produces({"application/json"})
@ApiOperation(value = "Get subclasses of a concept",
notes = "It returns subclasses of a specific concept")
@ApiResponses(
value = {
@ApiResponse(code = 200, message = "List of subclasses"),
@ApiResponse(code = 400, message = "Malformed input"),
@ApiResponse(code = 500, message = "Internal error")})
public Response getSubclasses(
@ApiParam(value = "URI of the concept (e.g., http://schema.org/Action)", required = true)
@QueryParam("uri") String uri,
@ApiParam(value = "If this parameter is set as TRUE, the function will return only direct subclasses", allowableValues = "true,false")
@QueryParam("direct") String direct) {
try {
Set<URI
```
<Overlap Ratio: 0.9747979077508322>

---

--- 306 --
Question ID: 30474b1865cc9cb0d1f5a1b650378f81af9e9edf
Original Code:
```
public class DownloadStatistics {
    private final ResourceBundle BUNDLE = ResourceBundle.getBundle("languages.UIResources");
    private final String TIME_FORMAT = "%02d:%02d min";
    private final String DESCRIPTION_TIME = BUNDLE.getString("download.statistics.time");
    private final String DESCRIPTION_DOWNLOAD_COUNT = BUNDLE.getString("download.statistics.successCounter");
    private final String DESCRIPTION_SKIPPED_COUNT = BUNDLE.getString("download.statistics.skippedCounter");
    private final String DESCRIPTION_FAILED_COUNT = BUNDLE.getString("download.statistics.failedCounter");

    private int downloadCount, skippedCount, failedCount;
    private String downloadFolderLocation, formattedElapsedTime;
    private long elapsedTime;


    public void incrementDownloadCount() {
        downloadCount++;
    }

    public void incrementSkippedCount() {
        skippedCount++;
    }

    public void incrementFailedCount() {
        failedCount++;
    }

    public int getDownloadCount() {
        return downloadCount;
    }

    public int getSkippedCount() {
        return skippedCount;
    }

    public int getFailedCount() {
        return failedCount;
    }

    public void setDownloadFolderLocation(String location) {
        downloadFolderLocation = location;
    }

    public String getDownloadFolderLocation() {
        return downloadFolderLocation;
    }

    public void setElapsedTime(long elapsedTime) {
        this.elapsedTime = elapsedTime;
        this.formattedElapsedTime = setFormattedElapsedTime(elapsedTime);
    }

    private String setFormattedElapsedTime(long elapsedTime) {
        long elapsedMinutes = TimeUnit.MILLISECONDS.toMinutes(elapsedTime);
        long elapsedSeconds = TimeUnit.MILLISECONDS.toSeconds(elapsedTime);
        long displayedElapsedSeconds = elapsedSeconds - TimeUnit.MINUTES.toSeconds(elapsedMinutes); //121 seconds - 120 seconds
        return String.format(TIME_FORMAT, elapsedMinutes, displayedElapsedSeconds);
    }

    public long getElapsedTime() {
        return elapsedTime;
    }

    public String getFormattedElapsedTime() {
        return formattedElapsedTime;
    }

    public List<Pair> getDisplayableStats() {
        List<Pair> stats = new ArrayList<>();
        Pair<String, String> stat_time = new Pair<>(DESCRIPTION_TIME, getFormattedElapsedTime());
        Pair<String, Integer> stat_download = new Pair<>(DESCRIPTION_DOWNLOAD_COUNT, getDownloadCount());
        Pair<String, Integer> stat_skipped = new Pair<>(DESCRIPTION_SKIPPED_COUNT, getSkippedCount());
        Pair<String, Integer> stat_failed = new Pair<>(DESCRIPTION_FAILED_COUNT, getFailedCount());
        stats.add(stat_time);
        stats.add(stat_download);
        stats.add(stat_skipped);
        stats.add(stat_failed);
        return stats;
    }
}
```


Overlapping Code:
```
atistics {
private final ResourceBundle BUNDLE = ResourceBundle.getBundle("languages.UIResources");
private final String TIME_FORMAT = "%02d:%02d min";
private final String DESCRIPTION_TIME = BUNDLE.getString("download.statistics.time");
private final String DESCRIPTION_DOWNLOAD_COUNT = BUNDLE.getString("download.statistics.successCounter");
private final String DESCRIPTION_SKIPPED_COUNT = BUNDLE.getString("download.statistics.skippedCounter");
private final String DESCRIPTION_FAILED_COUNT = BUNDLE.getString("download.statistics.failedCounter");
private int downloadCount, skippedCount, failedCount;
private String downloadFolderLocation, formattedElapsedTime;
private long elapsedTime;
public void incrementDownloadCount() {
downloadCount++;
}
public void incrementSkippedCount() {
skippedCount++;
}
public void incrementFailedCount() {
failedCount++;
}
public int getDownloadCount() {
return downloadCount;
}
public int getSkippedCount() {
return skippedCount;
}
public int getFailedCount() {
return failedCount;
}
public void setDownloadFolderLocation(String location) {
downloadFolderLocation = location;
}
public String getDownloadFolderLocation() {
return downloadFolderLocation;
}
public void setElapsedTime(long elapsedTime) {
this.elapsedTime = elapsedTime;
this.formattedElapsedTime = setFormattedElapsedTime(elapsedTime);
}
private String setFormattedElapsedTime(long elapsedTime) {
long elapsedMinutes = TimeUnit.MILLISECONDS.toMinutes(elapsedTime);
long elapsedSeconds = TimeUnit.MILLISECONDS.toSeconds(elapsedTime);
long displayedElapsedSeconds = elapsedSeconds - TimeUnit.MINUTES.toSeconds(elapsedMinutes); //121 seconds - 120 seconds
return String.format(TIME_FORMAT, elapsedMinutes, displayedElapsedSeconds);
}
public long getElapsedTime() {
return elapsedTime;
}
public String getFormattedElapsedTime() {
return formattedElapsedTime;
}
public List<Pair> getDisplayableStats() {
List<Pair> stats = new ArrayList<>();
Pair<String, String> stat_time = new Pair<>(DESCRIPTION_TIME, getFormattedElapsedTime());
Pair<String, Integer> stat_download = new Pair<>(DESCRIPTION_DOWNLOAD_COUNT, getDownloadCount());
Pair<String, Integer> 
```
<Overlap Ratio: 0.9830818472793782>

---

--- 307 --
Question ID: aeb8f8201b5c96d0363084c676a697b697cf63a9
Original Code:
```
public class SpringValueRegistry {

  private final Map<BeanFactory, Multimap<String, SpringValue>> registry = Maps.newConcurrentMap();
  private final Object LOCK = new Object();

  public void register(BeanFactory beanFactory, String key, SpringValue springValue) {
    if (!registry.containsKey(beanFactory)) {
      synchronized (LOCK) {
        if (!registry.containsKey(beanFactory)) {
          registry.put(beanFactory, LinkedListMultimap.<String, SpringValue>create());
        }
      }
    }

    registry.get(beanFactory).put(key, springValue);
  }

  public Collection<SpringValue> get(BeanFactory beanFactory, String key) {
    Multimap<String, SpringValue> beanFactorySpringValues = registry.get(beanFactory);
    if (beanFactorySpringValues == null) {
      return null;
    }
    return beanFactorySpringValues.get(key);
  }
}
```


Overlapping Code:
```
blic class SpringValueRegistry {
private final Map<BeanFactory, Multimap<String, SpringValue>> registry = Maps.newConcurrentMap();
private final Object LOCK = new Object();
public void register(BeanFactory beanFactory, String key, SpringValue springValue) {
if (!registry.containsKey(beanFactory)) {
synchronized (LOCK) {
if (!registry.containsKey(beanFactory)) {
registry.put(beanFactory, LinkedListMultimap.<String, SpringValue>create());
}
}
}
registry.get(beanFactory).put(key, springValue);
}
public Collection<SpringValue> get(BeanFactory beanFactory, String key) {
Multimap<String, SpringValue> beanFactorySpringValues = registry.get(beanFactory);
if (beanFactorySpringValues == null) {
return null;
}
return beanFactorySpringValues.get(key);

```
<Overlap Ratio: 0.9933774834437086>

---

--- 308 --
Question ID: 2489be4ae5734e9b9f38cc05d9268d79359561d5
Original Code:
```
public class LightPsiClassBuilder extends LightPsiClassBase implements OriginInfoAwareElement {

  private final LightModifierList myModifierList = new LightModifierList(getManager());
  private final LightReferenceListBuilder myImplementsList = new LightReferenceListBuilder(getManager(), IMPLEMENTS_LIST);
  private final LightReferenceListBuilder myExtendsList = new LightReferenceListBuilder(getManager(), EXTENDS_LIST);
  private final LightTypeParameterListBuilder myTypeParametersList = new LightTypeParameterListBuilder(getManager(), getLanguage());
  private final Collection<PsiMethod> myMethods = ContainerUtil.newArrayList();
  private PsiElement myScope;
  private PsiClass myContainingClass;
  private String myOriginInfo;

  public LightPsiClassBuilder(@NotNull PsiElement context, @NotNull String name) {
    super(context, name);
  }

  @Nullable
  @Override
  public String getOriginInfo() {
    return myOriginInfo;
  }

  @NotNull
  @Override
  public LightModifierList getModifierList() {
    return myModifierList;
  }

  @NotNull
  @Override
  public LightReferenceListBuilder getExtendsList() {
    return myExtendsList;
  }

  @NotNull
  @Override
  public LightReferenceListBuilder getImplementsList() {
    return myImplementsList;
  }

  @NotNull
  @Override
  public PsiField[] getFields() {
    // TODO
    return PsiField.EMPTY_ARRAY;
  }

  @NotNull
  @Override
  public PsiMethod[] getMethods() {
    return myMethods.toArray(PsiMethod.EMPTY_ARRAY);
  }

  @NotNull
  @Override
  public PsiClass[] getInnerClasses() {
    // TODO
    return PsiClass.EMPTY_ARRAY;
  }

  @NotNull
  @Override
  public PsiClassInitializer[] getInitializers() {
    return PsiClassInitializer.EMPTY_ARRAY;
  }

  @Override
  public PsiElement getScope() {
    return myScope;
  }

  @Nullable
  @Override
  public PsiClass getContainingClass() {
    return myContainingClass;
  }

  @NotNull
  @Override
  public LightTypeParameterListBuilder getTypeParameterList() {
    return myTypeParametersList;
  }

  @Override
  public boolean isEquivalentTo(PsiElement another) {
    return PsiClassImplUtil.isClassEquivalentTo(this, another);
  }

  public LightPsiClassBuilder setOriginInfo(String originInfo) {
    myOriginInfo = originInfo;
    return this;
  }

  public LightPsiClassBuilder setScope(PsiElement scope) {
    myScope = scope;
    return this;
  }

  public LightPsiClassBuilder setContainingClass(PsiClass containingClass) {
    myContainingClass = containingClass;
    return this;
  }

  public LightPsiClassBuilder addMethod(PsiMethod method) {
    if (method instanceof LightMethodBuilder) {
      ((LightMethodBuilder)method).setContainingClass(this);
    }
    myMethods.add(method);
    return this;
  }
}
```


Overlapping Code:
```
ghtPsiClassBuilder extends LightPsiClassBase implements OriginInfoAwareElement {
private final LightModifierList myModifierList = new LightModifierList(getManager());
private final LightReferenceListBuilder myImplementsList = new LightReferenceListBuilder(getManager(), IMPLEMENTS_LIST);
private final LightReferenceListBuilder myExtendsList = new LightReferenceListBuilder(getManager(), EXTENDS_LIST);
private final LightTypeParameterListBuilder myTypeParametersList = new LightTypeParameterListBuilder(getManager(), getLanguage());
private final Collection<PsiMethod> myMethods = ContainerUtil.newArrayList();
private PsiElement myScope;
private PsiClass myContainingClass;
private String myOriginInfo;
public LightPsiClassBuilder(@NotNull PsiElement context, @NotNull String name) {
super(context, name);
}
@Nullable
@Override
public String getOriginInfo() {
return myOriginInfo;
}
@NotNull
@Override
public LightModifierList getModifierList() {
return myModifierList;
}
@NotNull
@Override
public LightReferenceListBuilder getExtendsList() {
return myExtendsList;
}
@NotNull
@Override
public LightReferenceListBuilder getImplementsList() {
return myImplementsList;
}
@NotNull
@Override
public PsiField[] getFields() {
// TODO
return PsiField.EMPTY_ARRAY;
}
@NotNull
@Override
public PsiMethod[] getMethods() {
return myMethods.toArray(PsiMethod.EMPTY_ARRAY);
}
@NotNull
@Override
public PsiClass[] getInnerClasses() {
// TODO
return PsiClass.EMPTY_ARRAY;
}
@NotNull
@Override
public PsiClassInitializer[] getInitializers() {
return PsiClassInitializer.EMPTY_ARRAY;
}
@Override
public PsiElement getScope() {
return myScope;
}
@Nullable
@Override
public PsiClass getContainingClass() {
return myContainingClass;
}
@NotNull
@Override
public LightTypeParameterListBuilder getTypeParameterList() {
return myTypeParametersList;
}
@Override
public boolean isEquivalentTo(PsiElement another) {
return PsiClassImplUtil.isClassEquivalentTo(this, another);
}
public LightPsiClassBuilder setOriginInfo(String originInfo) {
myOriginInfo = originInfo;
return this;
}
public LightPsiClassBuilder setScope(PsiElement scope) {
myScope = scope;
return this;
}
public LightPsiClassBuilder setContainingClass(PsiClass containingClass) {
myContainingClass = containingClass;
```
<Overlap Ratio: 0.9916520210896309>

---

--- 309 --
Question ID: 7ca72de68880bb70ea88b38f6d3609bd1dc9a09a
Original Code:
```
public class Tweet implements Serializable{
    private String text;
    private Long id;
    private String createdAt;
    private User user;

    public String getText() {
        return text;
    }

    public Long getId() {
        return id;
    }

    public String getCreatedAt() {
        return createdAt;
    }

    public User getUser() {
        return user;
    }

    public static Tweet fromJSON(JSONObject jsonObject) {
        Tweet tweet = new Tweet();
        try {
            tweet.text = jsonObject.getString("text");
            tweet.createdAt = jsonObject.getString("created_at");
            tweet.id = jsonObject.getLong("id");
            tweet.user = User.fromJSON(jsonObject.getJSONObject("user"));
        } catch (JSONException e) {
            e.printStackTrace();
        }

        return tweet;
    }

    public static ArrayList<Tweet> fromJSONArray(JSONArray jsonArray) {
        ArrayList<Tweet> tweets = new ArrayList<>();
        for(int i=0; i<jsonArray.length(); i++){
            try {
                JSONObject tweetJSON = jsonArray.getJSONObject(i);
                Tweet tweet = Tweet.fromJSON(tweetJSON);
                if (tweet != null) {
                    tweets.add(tweet);
                }
            } catch (JSONException e) {
                e.printStackTrace();
            }
        }
        Log.i("DEBUG", tweets.toString());
        return tweets;
    }

    public String getRelativeTimeAgo(String rawJsonDate) {
        String twitterFormat = "EEE MMM dd HH:mm:ss ZZZZZ yyyy";
        SimpleDateFormat sf = new SimpleDateFormat(twitterFormat, Locale.ENGLISH);
        sf.setLenient(true);

        String relativeDate = "";
        try {
            long dateMillis = System.currentTimeMillis() - sf.parse(rawJsonDate).getTime();
            int seconds = (int) (dateMillis/1000);
            int minutes = seconds/60;
            int hours = minutes/60;
            int days = hours /24;
            int weeks = days /7;

            if ( weeks > 0)
                return weeks + " w";
            if (days > 0)
                return days + " d";
            if (hours > 0)
                return hours + " h";
            if (minutes > 0)
                return minutes + " m";
            return seconds + " s";

        } catch (ParseException e) {
            e.printStackTrace();
        }

        return relativeDate;
    }
}
```


Overlapping Code:
```
blic class Tweet implements Serializable{
private String text;
private Long id;
private String createdAt;
private User user;
public String getText() {
return text;
}
public Long getId() {
return id;
}
public String getCreatedAt() {
return createdAt;
}
public User getUser() {
return user;
}
public static Tweet fromJSON(JSONObject jsonObject) {
Tweet tweet = new Tweet();
try {
tweet.text = jsonObject.getString("text");
tweet.createdAt = jsonObject.getString("created_at");
tweet.id = jsonObject.getLong("id");
tweet.user = User.fromJSON(jsonObject.getJSONObject("user"));
} catch (JSONException e) {
e.printStackTrace();
}
return tweet;
}
public static ArrayList<Tweet> fromJSONArray(JSONArray jsonArray) {
ArrayList<Tweet> tweets = new ArrayList<>();
for(int i=0; i<jsonArray.length(); i++){
try {
JSONObject tweetJSON = jsonArray.getJSONObject(i);
Tweet tweet = Tweet.fromJSON(tweetJSON);
if (tweet != null) {
tweets.add(tweet);
}
} catch (JSONException e) {
e.printStackTrace();
}
}
Log.i("DEBUG", tweets.toString());
return tweets;
}
public String getRelativeTimeAgo(String rawJsonDate) {
String twitterFormat = "EEE MMM dd HH:mm:ss ZZZZZ yyyy";
SimpleDateFormat sf = new SimpleDateFormat(twitterFormat, Locale.ENGLISH);
sf.setLenient(true);
String relativeDate = "";
try {
long dateMillis = System.currentTimeMillis() - sf.parse(rawJsonDate).getTime();
int seconds = (int) (dateMillis/1000);
int minutes = seconds/60;
int hours = minutes/60;
int days = hours /24;
int weeks = days /7;
if ( weeks > 0)
return weeks + " w";
if (days > 0)
return days + " d";
if (hours > 0)
return hours + " h";
if (minutes > 0)
return minutes + " m";
return seconds + " s";
} catch (ParseException e) {
e.printStackTrace();
}
return relativeDate;
}
}
```
<Overlap Ratio: 0.9988505747126437>

---

--- 310 --
Question ID: 766b5bb28758220b4ef7d34efba5875d9eeb6ce3
Original Code:
```
public class CodeForces {
	public static void main (String[] args) throws java.lang.Exception {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int m = scanner.nextInt();
        String[] words = new String[n]; 
        String[] message = new String[m];
        int[] cost = new int[n];
        int x = 0;
        int[][] groupWordIndices = null;

        for(int i=0; i<n; i++) {
            words[i] = scanner.next();
        }

        for(int j=0; j<n; j++) {
            cost[j] = scanner.nextInt();
        }


        // TODO : Modify 
        for(int z=0; z<k; z++) {
            x = scanner.nextInt();
            
        }

        for(int a=0; a<m; a++) {
            message[a] = scanner.next();
        }

        scanner.close();
	}
}
```


Overlapping Code:
```
rces {
public static void main (String[] args) throws java.lang.Exception {
Scanner scanner = new Scanner(System.in);
int n = scanner.nextInt();
int k = scanner.nextInt();
int m = scanner.nextInt();
String[] words = new String[n]; 
String[] message = new String[m];
int[] cost = new int[n];
int x = 0;
int[][] groupWordIndices = null;
for(int i=0; i<n; i++) {
words[i] = scanner.next();
}
for(int j=0; j<n; j++) {
cost[j] = scanner.nextInt();
}
// TODO : Modify 
for(int z=0; z<k; z++) {
x = scanner.nextInt();

}
for(int a=0; a<m; a++) {
message[a] 
```
<Overlap Ratio: 0.90311986863711>

---

--- 311 --
Question ID: 12101258c5cd65ef3c38957217a9ccdcffa6476d
Original Code:
```
public class ProximityGrid implements Algorithm {

	private Grid m_Grid;

	/**
	 * @param args
	 */
	public HashMap<String, List<User>> findAkNNs(
			List<User> neighborsList, int K) {
		HashMap<String, List<User>> neighborsListSet = new HashMap<String, List<User>>();

		for (int j = 0; j < neighborsList.size(); j++) {
			User n = (User) neighborsList.get(j);
			List<User> temp = new LinkedList<User>();
			// Get the Cell of the n
			Cell c = m_Grid.getCell(n);
		
			// Get the cell
			// /////////////////////////////////////////////
			// Ulist + Kheap + Boundary List
			// ////////////////////////////////////////////
			List<User> tempList = c.AllToArrayList();
			// System.out.println("Grid.findAkNNs() in "+tempList.size());
			for (int k = 0; k < tempList.size(); k++) {
				User n_in = tempList.get(k);

				n_in.setDistance(n.lon, n.lat);

				temp.add(n_in);

			}
	
			Collections.sort(temp);
			neighborsListSet.put(n.key, temp.subList(0, K));

		}

		return neighborsListSet;
	}

	public void buildingStructures(List<User> neighborsList, int K,
			int cellSize) {
		// Create the grid
		m_Grid = new Grid(neighborsList.size(), K, cellSize);

		for (int j = 0; j < neighborsList.size(); j++) {
			User neighbor = neighborsList.get(j);
			m_Grid.insertCell(neighbor);
		}
	}

	public void buildingStructures(List<User> neighborsList, int K) {
		// TODO Auto-generated method stub
		buildingStructures(neighborsList, K, Grid.LOG_N);
	}

	public static void main(String[] args) {

		int K = 2;
		int CellSize = Grid.LOG_N;

		if (args.length < 2) {
			System.err.println("prog <K> <CellSize>");
			System.exit(0);
		}

		try {
			K = Integer.parseInt(args[0]);
			CellSize = Integer.parseInt(args[1]);

		} catch (Exception e) {
			System.err.println("prog <K> <CellSize>");
			System.exit(0);
		}

		CouchBaseData.setLoggingOff();

		List<User> neighborsList = CouchBaseData.getData();

		// ////////////////////////////////////////////////////////////////////////////
		// *
		// * ProximityGrid benchmarking
		// *
		// ////////////////////////////////////////////////////////////////////////////

		ProximityGrid pgr = new ProximityGrid();
		;

		@SuppressWarnings("unused")
		HashMap<String, List<User>> proxg = null;

		long startTime = System.currentTimeMillis();

		pgr.buildingStructures(neighborsList, K,CellSize);
		long endTime = System.currentTimeMillis();
		long duration = endTime - startTime;
		System.out.println("Building Structures : Time [" + duration + "] ms");

		startTime = System.currentTimeMillis();
		proxg = pgr.findAkNNs(neighborsList, K);
		endTime = System.currentTimeMillis();
		duration = endTime - startTime;
		System.out.println("ProximityGrid Search : Time [" + duration + "] ms");

		System.exit(0);
	}

}
```


Overlapping Code:
```
ass ProximityGrid implements Algorithm {
private Grid m_Grid;
/**
* @param args
*/
public HashMap<String, List<User>> findAkNNs(
List<User> neighborsList, int K) {
HashMap<String, List<User>> neighborsListSet = new HashMap<String, List<User>>();
for (int j = 0; j < neighborsList.size(); j++) {
User n = (User) neighborsList.get(j);
List<User> temp = new LinkedList<User>();
// Get the Cell of the n
Cell c = m_Grid.getCell(n);

// Get the cell
// /////////////////////////////////////////////
// Ulist + Kheap + Boundary List
// ////////////////////////////////////////////
List<User> tempList = c.AllToArrayList();
// System.out.println("Grid.findAkNNs() in "+tempList.size());
for (int k = 0; k < tempList.size(); k++) {
User n_in = tempList.get(k);
n_in.setDistance(n.lon, n.lat);
temp.add(n_in);
}

Collections.sort(temp);
neighborsListSet.put(n.key, temp.subList(0, K));
}
return neighborsListSet;
}
public void buildingStructures(List<User> neighborsList, int K,
int cellSize) {
// Create the grid
m_Grid = new Grid(neighborsList.size(), K, cellSize);
for (int j = 0; j < neighborsList.size(); j++) {
User neighbor = neighborsList.get(j);
m_Grid.insertCell(neighbor);
}
}
public void buildingStructures(List<User> neighborsList, int K) {
// TODO Auto-generated method stub
buildingStructures(neighborsList, K, Grid.LOG_N);
}
public static void main(String[] args) {
int K = 2;
int CellSize = Grid.LOG_N;
if (args.length < 2) {
System.err.println("prog <K> <CellSize>");
System.exit(0);
}
try {
K = Integer.parseInt(args[0]);
CellSize = Integer.parseInt(args[1]);
} catch (Exception e) {
System.err.println("prog <K> <CellSize>");
System.exit(0);
}
CouchBaseData.setLoggingOff();
List<User> neighborsList = CouchBaseData.getData();
// ////////////////////////////////////////////////////////////////////////////
// *
// * ProximityGrid benchmarking
// *
// ////////////////////////////////////////////////////////////////////////////
ProximityGrid pgr = new ProximityGrid();
;
@SuppressWarnings("unused")
HashMap<String, List<User>> proxg = null;
long startTime = System.currentTimeMillis();
pgr.buildingStructures(neighborsList, K,CellSize);
long endTime = System.currentTimeMillis();
long duration = endTime - startTime;
System.out.println("Building Structures : Time [" + duration + "] ms");
```
<Overlap Ratio: 0.996102208748376>

---

--- 312 --
Question ID: ad3c6e2345d2f23dacc98842b3bf0859b8ad29a7
Original Code:
```
class StagedModeAccumulator<T> extends ModeAccumulatorImpl<T> {

    private final ModeAccumulator<T> previousStage;

    StagedModeAccumulator(final ModeAccumulator<T> previousStage) {
        this.previousStage = previousStage;
    }

    @Override
    public boolean isEmpty() {
        return super.isEmpty() && this.previousStage.isEmpty();
    }

    @Override
    public Bag<T> getValues() {
        final Bag<T> values = new HashBag<>(super.getValues());

        values.addAll(this.previousStage.getValues());
        return values;
    }

    @Override
    public String toString() {
        //noinspection DuplicateStringLiteralInspection
        return MoreObjects.toStringHelper(this)
                .add("previousStage", this.previousStage)
                .toString();
    }
}
```


Overlapping Code:
```
tends ModeAccumulatorImpl<T> {
private final ModeAccumulator<T> previousStage;
StagedModeAccumulator(final ModeAccumulator<T> previousStage) {
this.previousStage = previousStage;
}
@Override
public boolean isEmpty() {
return super.isEmpty() && this.previousStage.isEmpty();
}
@Override
public Bag<T> getValues() {
final Bag<T> values = new HashBag<>(super.getValues());
values.addAll(this.previousStage.getValues());
return values;
}
@Override
public String toString() {
//noinspection DuplicateStringLiteralInspection
return MoreObjects.toStringHelper(this)
.add("previousStage", this.previousStage)
.toString(
```
<Overlap Ratio: 0.94>

---

--- 313 --
Question ID: 10a0a4955734893361817a4dff40b79f385dbe75
Original Code:
```
public class ToolchainProviderBuilder {
  private final Map<String, Toolchain> toolchains = new HashMap<>();

  public ToolchainProviderBuilder() {}

  public ToolchainProviderBuilder withToolchain(NamedToolchain toolchain) {
    toolchains.put(toolchain.getName(), toolchain.getToolchain());
    return this;
  }

  public ToolchainProviderBuilder withToolchain(String name, Toolchain toolchain) {
    toolchains.put(name, toolchain);
    return this;
  }

  public ToolchainProvider build() {
    return new SimpleToolchainProvider(toolchains);
  }

  private static class SimpleToolchainProvider extends BaseToolchainProvider {
    private final ImmutableMap<String, Toolchain> toolchains;

    private SimpleToolchainProvider(Map<String, Toolchain> toolchains) {
      this.toolchains = ImmutableMap.copyOf(toolchains);
    }

    @Override
    public Toolchain getByName(String toolchainName) {
      return toolchains.get(toolchainName);
    }

    @Override
    public boolean isToolchainPresent(String toolchainName) {
      return toolchains.containsKey(toolchainName);
    }

    @Override
    public boolean isToolchainCreated(String toolchainName) {
      return isToolchainPresent(toolchainName);
    }

    @Override
    public boolean isToolchainFailed(String toolchainName) {
      return false;
    }

    @Override
    public <T extends ToolchainWithCapability> Collection<String> getToolchainsWithCapability(
        Class<T> capability) {
      ImmutableList.Builder<String> featureSupportingToolchains = ImmutableList.builder();

      for (Map.Entry<String, Toolchain> toolchainEntry : toolchains.entrySet()) {
        if (capability.isAssignableFrom(toolchainEntry.getValue().getClass())) {
          featureSupportingToolchains.add(toolchainEntry.getKey());
        }
      }

      return featureSupportingToolchains.build();
    }

    @Override
    public Optional<ToolchainInstantiationException> getToolchainInstantiationException(
        String toolchainName) {
      return Optional.empty();
    }
  }
}
```


Overlapping Code:
```
er {
private final Map<String, Toolchain> toolchains = new HashMap<>();
public ToolchainProviderBuilder() {}
public ToolchainProviderBuilder withToolchain(NamedToolchain toolchain) {
toolchains.put(toolchain.getName(), toolchain.getToolchain());
return this;
}
public ToolchainProviderBuilder withToolchain(String name, Toolchain toolchain) {
toolchains.put(name, toolchain);
return this;
}
public ToolchainProvider build() {
return new SimpleToolchainProvider(toolchains);
}
private static class SimpleToolchainProvider extends BaseToolchainProvider {
private final ImmutableMap<String, Toolchain> toolchains;
private SimpleToolchainProvider(Map<String, Toolchain> toolchains) {
this.toolchains = ImmutableMap.copyOf(toolchains);
}
@Override
public Toolchain getByName(String toolchainName) {
return toolchains.get(toolchainName);
}
@Override
public boolean isToolchainPresent(String toolchainName) {
return toolchains.containsKey(toolchainName);
}
@Override
public boolean isToolchainCreated(String toolchainName) {
return isToolchainPresent(toolchainName);
}
@Override
public boolean isToolchainFailed(String toolchainName) {
return false;
}
@Override
public <T extends ToolchainWithCapability> Collection<String> getToolchainsWithCapability(
Class<T> capability) {
ImmutableList.Builder<String> featureSupportingToolchains = ImmutableList.builder();
for (Map.Entry<String, Toolchain> toolchainEntry : toolchains.entrySet()) {
if (capability.isAssignableFrom(toolchainEntry.getValue().getClass())) {
featureSupportingToolchains.add(toolchainEntry.getKey());
}
}
return featureSupportingToolchains.build();
}
@Override
public Optional<ToolchainInstantiationException> getToolchainInstantiationException(
String toolchainName) {
return Optional.empt
```
<Overlap Ratio: 0.9749303621169917>

---

--- 314 --
Question ID: 5997ff230f5fd11630bfc17870488a89906e018d
Original Code:
```
public class CutableTextView extends AppCompatTextView {

    private boolean clicked = false;
    private boolean linesRendered = false;
    private int totalCountLines;
    private int linesToCut;

    private static final String PROPERTY_MAX_LINES = "maxLines";

    public CutableTextView(Context context) {
        super(context);
        init(context , null);
        linesToCut = 4;
    }

    public CutableTextView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init(context , attrs);
    }

    public CutableTextView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init(context , attrs);
    }

    public void setLinesToCut(int linesToCut){
        this.linesToCut = linesToCut;
    }

    @Override
    public void setText(CharSequence text, BufferType type) {
        super.setText(text, type);
        post(() -> {
            if (getLineCount() > linesToCut && !linesRendered){
                totalCountLines = getLineCount();
                linesRendered = true;
            }
            if (totalCountLines > linesToCut){
                setLines(linesToCut);
            }
        });
    }

    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        if(event.getAction() == MotionEvent.ACTION_UP) {
            if (!clicked) {
                expandAnimation();
                clicked = true;
            } else {
                collapseAnimation();
                clicked = false;
            }
        }
        return super.dispatchTouchEvent(event);
    }

    private void expandAnimation(){
        startMaxLineAnimationChanger(totalCountLines , 0);
    }

    private void collapseAnimation(){
        startMaxLineAnimationChanger(totalCountLines , linesToCut);
    }

    private void startMaxLineAnimationChanger(int from , int to) {
        if (totalCountLines > linesToCut){
            ObjectAnimator objectAnimator = ObjectAnimator.ofInt(this, PROPERTY_MAX_LINES, from , to);
            if (to == 0){
                objectAnimator = ObjectAnimator.ofInt(this , PROPERTY_MAX_LINES , from);
            }
            if (totalCountLines <= 8){
                objectAnimator.setDuration(70);
            }
            objectAnimator.start();
        }
    }

    private void init(Context context , @Nullable AttributeSet attrs) {
        if (attrs != null){
            TypedArray a = context.obtainStyledAttributes(attrs , R.styleable.CutableTextView);
            linesToCut = a.getInt(R.styleable.CutableTextView_ctv_lines_to_cut , 4);
            a.recycle();
        }
        setEllipsize(TextUtils.TruncateAt.END);
        setClickable(true);
        setFocusable(true);
        TypedValue typedValue = new TypedValue();
        context.getTheme().resolveAttribute(R.attr.selectableItemBackground , typedValue , true);
        setBackgroundResource(typedValue.resourceId);
    }
}
```


Overlapping Code:
```
eTextView extends AppCompatTextView {
private boolean clicked = false;
private boolean linesRendered = false;
private int totalCountLines;
private int linesToCut;
private static final String PROPERTY_MAX_LINES = "maxLines";
public CutableTextView(Context context) {
super(context);
init(context , null);
linesToCut = 4;
}
public CutableTextView(Context context, AttributeSet attrs) {
super(context, attrs);
init(context , attrs);
}
public CutableTextView(Context context, AttributeSet attrs, int defStyleAttr) {
super(context, attrs, defStyleAttr);
init(context , attrs);
}
public void setLinesToCut(int linesToCut){
this.linesToCut = linesToCut;
}
@Override
public void setText(CharSequence text, BufferType type) {
super.setText(text, type);
post(() -> {
if (getLineCount() > linesToCut && !linesRendered){
totalCountLines = getLineCount();
linesRendered = true;
}
if (totalCountLines > linesToCut){
setLines(linesToCut);
}
});
}
@Override
public boolean dispatchTouchEvent(MotionEvent event) {
if(event.getAction() == MotionEvent.ACTION_UP) {
if (!clicked) {
expandAnimation();
clicked = true;
} else {
collapseAnimation();
clicked = false;
}
}
return super.dispatchTouchEvent(event);
}
private void expandAnimation(){
startMaxLineAnimationChanger(totalCountLines , 0);
}
private void collapseAnimation(){
startMaxLineAnimationChanger(totalCountLines , linesToCut);
}
private void startMaxLineAnimationChanger(int from , int to) {
if (totalCountLines > linesToCut){
ObjectAnimator objectAnimator = ObjectAnimator.ofInt(this, PROPERTY_MAX_LINES, from , to);
if (to == 0){
objectAnimator = ObjectAnimator.ofInt(this , PROPERTY_MAX_LINES , from);
}
if (totalCountLines <= 8){
objectAnimator.setDuration(70);
}
objectAnimator.start();
}
}
private void init(Context context , @Nullable AttributeSet attrs) {
if (attrs != null){
TypedArray a = context.obtainStyledAttributes(attrs , R.style
```
<Overlap Ratio: 0.9833246482542991>

---

--- 315 --
Question ID: 175620db3560eae7f1aeff3c0e4bfa9c0413cf8d
Original Code:
```
public class MinimizationMethod {
    protected int iteration;

    protected double[] x;
    protected double fx;

    private EventListenerList listenerList = new EventListenerList();
    private IterationEvent iterationEvent;
    private OptimizationEvent optimizationEvent;

    public int getIteration() {
        return iteration;
    }

    public double[] getX() {
        return x;
    }

    public double getFx() {
        return fx;
    }

    public void addIterationListener(IterationListener l) {
        listenerList.add(IterationListener.class, l);
    }

    public void removeIterationListener(IterationListener l) {
        listenerList.remove(IterationListener.class, l);
    }

    public void addOptimizationListener(OptimizationListener l) {
        listenerList.add(OptimizationListener.class, l);
    }

    public void removeOptimizationListener(OptimizationListener l) {
        listenerList.remove(OptimizationListener.class, l);
    }

    protected void fireIterationStart() {
        // Guaranteed to return a non-null array
        Object[] listeners = listenerList.getListenerList();
        // Process the listeners last to first, notifying
        // those that are interested in this event
        for (int i = listeners.length - 2; i >= 0; i -= 2) {
            if (listeners[i] == IterationListener.class) {
                // Lazily create the event:
                if (iterationEvent == null)
                    iterationEvent = new IterationEvent(this);
                ((IterationListener) listeners[i + 1]).IterationStart(iterationEvent);
            }
        }
    }

    protected void fireIterationEnd() {
        Object[] listeners = listenerList.getListenerList();
        for (int i = listeners.length - 2; i >= 0; i -= 2) {
            if (listeners[i] == IterationListener.class) {
                if (iterationEvent == null)
                    iterationEvent = new IterationEvent(this);
                ((IterationListener) listeners[i + 1]).IterationEnd(iterationEvent);
            }
        }
    }

    protected void fireOptimizationStart() {
        Object[] listeners = listenerList.getListenerList();
        for (int i = listeners.length - 2; i >= 0; i -= 2) {
            if (listeners[i] == OptimizationListener.class) {
                if (optimizationEvent == null)
                    optimizationEvent = new OptimizationEvent(this);
                ((OptimizationListener) listeners[i + 1]).OptimizationStart(optimizationEvent);
            }
        }
    }

    protected void fireOptimizationEnd() {
        Object[] listeners = listenerList.getListenerList();
        for (int i = listeners.length - 2; i >= 0; i -= 2) {
            if (listeners[i] == OptimizationListener.class) {
                if (optimizationEvent == null)
                    optimizationEvent = new OptimizationEvent(this);
                ((OptimizationListener) listeners[i + 1]).OptimizationEnd(optimizationEvent);
            }
        }
    }
}
```


Overlapping Code:
```
ass MinimizationMethod {
protected int iteration;
protected double[] x;
protected double fx;
private EventListenerList listenerList = new EventListenerList();
private IterationEvent iterationEvent;
private OptimizationEvent optimizationEvent;
public int getIteration() {
return iteration;
}
public double[] getX() {
return x;
}
public double getFx() {
return fx;
}
public void addIterationListener(IterationListener l) {
listenerList.add(IterationListener.class, l);
}
public void removeIterationListener(IterationListener l) {
listenerList.remove(IterationListener.class, l);
}
public void addOptimizationListener(OptimizationListener l) {
listenerList.add(OptimizationListener.class, l);
}
public void removeOptimizationListener(OptimizationListener l) {
listenerList.remove(OptimizationListener.class, l);
}
protected void fireIterationStart() {
// Guaranteed to return a non-null array
Object[] listeners = listenerList.getListenerList();
// Process the listeners last to first, notifying
// those that are interested in this event
for (int i = listeners.length - 2; i >= 0; i -= 2) {
if (listeners[i] == IterationListener.class) {
// Lazily create the event:
if (iterationEvent == null)
iterationEvent = new IterationEvent(this);
((IterationListener) listeners[i + 1]).IterationStart(iterationEvent);
}
}
}
protected void fireIterationEnd() {
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length - 2; i >= 0; i -= 2) {
if (listeners[i] == IterationListener.class) {
if (iterationEvent == null)
iterationEvent = new IterationEvent(this);
((IterationListener) listeners[i + 1]).IterationEnd(iterationEvent);
}
}
}
protected void fireOptimizationStart() {
Object[] listeners = listenerList.getListenerList();
for (int i = listeners.length - 2; i >= 0; i -= 2) {
if (listeners[i] == OptimizationListener.class) {
if (optimizationEvent == null)
optimizationEvent = new O
```
<Overlap Ratio: 0.9788768675940237>

---

--- 316 --
Question ID: f03537ad24b223dc556fd880c911c59d2cc730d1
Original Code:
```
@RequiresApi(api = Build.VERSION_CODES.M)
public class SigaMeJobService extends JobService {
    public SigaMeJobService() {
    }


    @Override
    public boolean onStartJob(JobParameters params) {
        Intent service = new Intent(getApplicationContext(), SigaMeService.class);
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
            getApplicationContext().startForegroundService(service);
        else
            getApplicationContext().startService(service);

        AndroidUtil.scheduleJob(getApplicationContext()); // reschedule the job
        return true;
    }

    @Override
    public boolean onStopJob(JobParameters params) {
        return false;
    }


}
```


Overlapping Code:
```
@RequiresApi(api = Build.VERSION_CODES.M)
public class SigaMeJobService extends JobService {
public SigaMeJobService() {
}
@Override
public boolean onStartJob(JobParameters params) {
Intent service = new Intent(getApplicationContext(), SigaMeService.class);
if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
getApplicationContext().startForegroundService(service);
else
getApplicationContext().startService(service);
AndroidUtil.scheduleJob(getApplicationContext()); // reschedule the job
return true;
}
@Override
public boolean onStopJob(JobParameters params) {
return false;
}
}
```
<Overlap Ratio: 1.0>

---

--- 317 --
Question ID: b891b11d8b3212c7191392e74938f028378faa0c
Original Code:
```
public final class GenListModuleFilter extends AbstractXMLFilter {
    
    public static final String PI_PATH2PROJ_TARGET = "path2project";
    public static final String PI_PATH2PROJ_TARGET_URI = "path2project-uri";
//    public static final String PI_WORKDIR_TARGET = "workdir";
    public static final String PI_WORKDIR_TARGET_URI = "workdir-uri";
    
    /** Inherited attributes and their default values. */
    private static final Map<String, String> inheritedAtts = new HashMap<String, String>();
    static {
        inheritedAtts.put(ATTRIBUTE_NAME_SCOPE, ATTR_SCOPE_VALUE_LOCAL);
        inheritedAtts.put(ATTRIBUTE_NAME_PROCESSING_ROLE, ATTR_PROCESSING_ROLE_VALUE_NORMAL);
    }
    
    /** Output utilities */
    private Job job;
    /** Basedir of the current parsing file */
    private URI currentDir = null;
    /** Set of all the non-conref and non-copyto targets refered in current parsing file */
    private final Set<Reference> nonConrefCopytoTargets;
    /** Set of sources of those copy-to that were ignored */
    private final Set<File> ignoredCopytoSourceSet;
    /** Map of copy-to target to souce */
    private final Map<File, File> copytoMap;
    /** chunk nesting level */
    private int chunkLevel = 0;
    /** mark topics in reltables */
    private int relTableLevel = 0;
    /** chunk to-navigation level */
    private int chunkToNavLevel = 0;
    /** Topic group nesting level */
    private int topicGroupLevel = 0;
    /** Flag used to mark if current file is still valid after filtering */
    /** Set of outer dita files */
    private final Set<File> outDitaFilesSet;
    /** Absolute system path to file being processed */
    private URI currentFile = null;
    /** System path to file being processed, relative to base directory. */
    private URI currentFileRelative;
//    private boolean setSystemid = true;
    /** Stack of inherited attributes. */
    private final Deque<AttributesImpl> inheritedAttsStack;
    /** Topics with processing role of "resource-only" */
    private final Set<File> resourceOnlySet;
    /** Topics with processing role of "normal" */
    private final Set<File> normalProcessingSet;
//    private final List<ExportAnchor> resultList = new ArrayList<ExportAnchor>();
//    private ExportAnchor currentExportAnchor;
//    /** Flag to show whether a file has <exportanchors> tag */
//    private boolean hasExport = false;
//    /** For topic/dita files whether a </file> tag should be added */
//    private boolean shouldAppendEndTag = false;
//    /** Store the href of topicref tag */
//    private String topicHref = "";
//    /** Topicmeta set for merge multiple exportanchors into one. Each topicmeta/prolog can define many exportanchors */
//    private final Set<String> topicMetaSet;
//    /** Refered topic id */
//    private String topicId = "";
//    /** Map to store plugin id */
//    private final Map<String, Set<String>> pluginMap = new HashMap<String, Set<String>>();
//    /** Transtype */
//    private String transtype;
    /** Map to store referenced branches. */
    private final Map<String, List<String>> validBranches;
    /** Int to mark referenced nested elements. */
    private int level;
    /** Topicref stack */
    private final Stack<String> topicrefStack;
    private String path2Project;
    /** Absolute system path to input file parent directory */
    private URI inputDir;
    private URI inputFile;
    private File tempDir;
    private final Map<String, Integer> counterMap;
    /** File info map. */
    private final Map<String, FileInfo.Builder> fileInfoMap;
    /** File info for the current document. */
    private FileInfo.Builder fileInfo;
    private boolean isRootElement = true;
    private DitaClass rootClass = null;
    private boolean isStartDocument = false;

    /**
     * Constructor.
     */
    public GenListModuleFilter() {
        nonConrefCopytoTargets = new HashSet<Reference>(64);
        copytoMap = new HashMap<File, File>(16);
        ignoredCopytoSourceSet = new HashSet<File>(16);
        outDitaFilesSet = new HashSet<File>(64);
//        processRoleLevel = 0;
//        processRoleStack = new Stack<String>();
        inheritedAttsStack = new ArrayDeque<AttributesImpl>();
        resourceOnlySet = new HashSet<File>(32);
        normalProcessingSet = new HashSet<File>(32);
//        topicMetaSet = new HashSet<String>(INT_16);
        validBranches = new HashMap<String, List<String>>(32);
        counterMap = new HashMap<String, Integer>();
        level = 0;
        topicrefStack = new Stack<String>();
        fileInfoMap = new HashMap<String, FileInfo.Builder>();
    }
    
    /**
     * 
     * Reset the internal variables.
     */
    public void reset() {
        currentDir = null;
        chunkLevel = 0;
        relTableLevel = 0;
        chunkToNavLevel = 0;
        topicGroupLevel = 0;
        nonConrefCopytoTargets.clear();
        copytoMap.clear();
        ignoredCopytoSourceSet.clear();
        outDitaFilesSet.clear();
        level = 0;
        topicrefStack.clear();
//        processRoleLevel = 0;
//        processRoleStack.clear();
        inheritedAttsStack.clear();
        currentFileRelative = null;
        path2Project = null;
        counterMap.clear();
        fileInfo = null;
        fileInfoMap.clear();
        isRootElement = true;
        rootClass = null;
        isStartDocument = false;
        // Don't clean:
        // resourceOnlySet
        // normalProcessingSet
    }

//    /**
//     * Set transtype.
//     * 
//     * @param transtype the transtype to set
//     */
//    public void setTranstype(final String transtype) {
//        this.transtype = transtype;
//    }
//
//    /**
//     * @return the pluginMap
//     */
//    public Map<String, Set<String>> getPluginMap() {
//        return pluginMap;
//    }
//
//    /**
//     * Get export anchors.
//     * 
//     * @return list of export anchors
//     */
//    public List<ExportAnchor> getExportAnchors() {
//        return resultList;
//    }

    /**
     * Current document is processing start document.
     */
    public void isStartDocument(final boolean isStartDocument) {
        this.isStartDocument = isStartDocument;
    }
    
    /**
     * Set output utilities.
     * 
     * @param job output utils
     */
    public void setJob(final Job job) {
        this.job = job;
    }

    /**
     * Get out file set.
     * 
     * @return out file set
     */
    public Set<File> getOutFilesSet() {
        return outDitaFilesSet;
    }

    /**
     * List of files with "@processing-role=resource-only".
     * 
     * @return the resource-only set
     */
    public Set<File> getResourceOnlySet() {
        final Set<File> res = new HashSet<File>(resourceOnlySet);
        res.removeAll(normalProcessingSet);
        return res;
    }

    /**
     * Get all targets except copy-to.
     * 
     * @return set of target file path references
     */
    public Set<Reference> getNonCopytoResult() {
        final Set<Reference> nonCopytoSet = new HashSet<Reference>(128);

        nonCopytoSet.addAll(nonConrefCopytoTargets);
        for (final Builder b: fileInfoMap.values()) {
            final FileInfo f = b.build();
            if (f.isConrefTarget) {
                nonCopytoSet.add(new Reference(f.file.getPath(), f.format));
            }
        }
        for (final File f : copytoMap.values()) {
            nonCopytoSet.add(new Reference(f.getPath(), fileInfoMap.get(f.getPath()).build().format));
        }
        for (final File f : ignoredCopytoSourceSet) {
            nonCopytoSet.add(new Reference(f.getPath(), fileInfoMap.get(f.getPath()).build().format));
        }
//        for (final String filename : subsidiarySet) {
//            // only activated on /generateout:3 & is out file.
//            if (isOutFile(filename) && OutputUtils.getGeneratecopyouter() == OutputUtils.Generate.OLDSOLUTION) {
//                nonCopytoSet.add(new Reference(filename));
//            }
//        }
        // nonCopytoSet.addAll(subsidiarySet);
        return nonCopytoSet;
    }

    /**
     * Get outditafileslist.
     * 
     * @return Returns the outditafileslist.
     */
    public Set<File> getOutDitaFilesSet() {
        return outDitaFilesSet;
    }

    /**
     * Get non-conref and non-copyto targets.
     * 
     * @return Returns the nonConrefCopytoTargets.
     */
    public Set<File> getNonConrefCopytoTargets() {
        final Set<File> res = new HashSet<File>(nonConrefCopytoTargets.size());
        for (final Reference r : nonConrefCopytoTargets) {
            res.add(new File(r.filename));
        }
        return res;
    }

    /**
     * Returns the ignoredCopytoSourceSet.
     * 
     * @return Returns the ignoredCopytoSourceSet.
     */
    public Set<File> getIgnoredCopytoSourceSet() {
        return ignoredCopytoSourceSet;
    }

    /**
     * Get the copy-to map.
     * 
     * @return copy-to map
     */
    public Map<File, File> getCopytoMap() {
        return copytoMap;
    }

    /**
     * Set the relative directory of current file.
     * 
     * @param dir dir
     */
    public void setCurrentDir(final URI dir) {
        currentDir = dir;
    }
    
    /**
     * Set processing input directory absolute path.
     * 
     * @param inputFile absolute path to base directory
     */
    public void setInputDir(final URI inputDir) {
        this.inputDir = inputDir;
    }

    
    /**
     * Set processing input file absolute path.
     * 
     * @param inputFile absolute path to root file
     */
    public void setInputFile(final URI inputFile) {
        this.inputFile = inputFile;
    }
    
    /**
     * Set current file absolute path
     * 
     * @param currentFile absolute path to current file
     */
    public void setCurrentFile(final URI currentFile) {
        this.currentFile = currentFile;
    }
    
    /**
     * Set temporary directory
     * @param tempDir absolute path to temporary directory
     */
    public void setTempDir(final File tempDir) {
        this.tempDir = tempDir;
    }

    /**
     * Get file info for the current file.
     */
    public List<FileInfo> getFileInfo() {
        final List<FileInfo> res = new ArrayList<FileInfo>();
        //res.add(fileInfo.build());
        for (final Builder b: fileInfoMap.values()) {
            res.add(b.build());
        }
        return res;
    }
    
    // Content handler methods
    
    /**
     * Check if the current file is a ditamap with
     * "@processing-role=resource-only".
     */
    @Override
    public void startDocument() throws SAXException {
        currentFileRelative = inputDir.relativize(currentFile);
        path2Project = getPathtoProject(toFile(currentFileRelative), toFile(currentFile.toString()), job.getInputFile().getAbsolutePath());
        fileInfo = getOrCreateBuilder(currentFileRelative);
        
        super.startDocument();
        outputProcessingInstructions();
    }

    /**
     * Generate processing instructions to the beginning of the document.
     * 
     * <p>The following processing instructions are added before the root element:</p>
     * <dl>
     *   <!--dt>{@link #PI_WORKDIR_TARGET}<dt>
     *   <dd>Absolute system path of the file parent directory. On Windows, a {@code /}
     *     is added to beginning of the path.</dd-->
     *   <dt>{@link #PI_WORKDIR_TARGET_URI}<dt>
     *   <dd>Absolute URI of the file parent directory.</dd>
     *   <dt>{@link #PI_PATH2PROJ_TARGET}<dt>
     *   <dd>Relative system path to the output directory, with a trailing directory separator.
     *     When the source file is in the project root directory, processing instruction has no value.</dd>
     *   <dt>{@link #PI_PATH2PROJ_TARGET_URI}<dt>
     *   <dd>Relative URI to the output directory, with a trailing path separator.
     *     When the source file is in the project root directory, processing instruction has value {@code ./}.</dd>
     * </dl> 
     */
    private void outputProcessingInstructions() throws SAXException {
        final URI workDir = tempDir.toURI().resolve(currentFileRelative).resolve(".");
//        if (OS_NAME.toLowerCase().indexOf(OS_NAME_WINDOWS) == -1) {
//            getContentHandler().processingInstruction(PI_WORKDIR_TARGET, new File(workDir).getAbsolutePath());
//        } else {
//            getContentHandler().processingInstruction(PI_WORKDIR_TARGET, UNIX_SEPARATOR + new File(workDir).getAbsolutePath());
//        }
        getContentHandler().ignorableWhitespace(new char[] { '\n' }, 0, 1);
        getContentHandler().processingInstruction(PI_WORKDIR_TARGET_URI, workDir.toString());
        getContentHandler().ignorableWhitespace(new char[] { '\n' }, 0, 1);
        if (path2Project != null) {
            getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET, path2Project);
            getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET_URI, toURI(path2Project).toString());
        } else {
            getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET, "");
            getContentHandler().processingInstruction(PI_PATH2PROJ_TARGET_URI, "." + UNIX_SEPARATOR);
        }
        getContentHandler().ignorableWhitespace(new char[] { '\n' }, 0, 1);
    }
    
    /**
     * Push inherited attributes to the stack.
     */
    private void pushInheritedAttributes(final Attributes atts) {
        final AttributesImpl res = new AttributesImpl();
        for (final Entry<String, String> e: inheritedAtts.entrySet()) {
            final String current = atts.getValue(e.getKey());
            if (current != null) {
                XMLUtils.addOrSetAttribute(res, e.getKey(), current);
            } else if (!inheritedAttsStack.isEmpty()) {
                XMLUtils.addOrSetAttribute(res, e.getKey(), getInherited(e.getKey()));
            } else {
                XMLUtils.addOrSetAttribute(res, e.getKey(), e.getValue());
            }
        }
        inheritedAttsStack.addFirst(res);
    }
    /**
     * Get inherited attribute value.
     * @param name attribute name
     * @return attribute value or {@code null} if not available
     */
    private String getInherited(final String name) {
        return inheritedAttsStack.peekFirst().getValue(name);
    }
    
    @Override
    public void startElement(final String uri, final String localName, final String qName, final Attributes atts)
            throws SAXException {
        pushInheritedAttributes(atts);
        
        handleProcessingRole(atts);
        
        final String classValue = atts.getValue(ATTRIBUTE_NAME_CLASS);

        handleRootElement(localName, atts);

//        // when meets topic tag
//        if (TOPIC_TOPIC.matches(classValue)) {
//            topicId = atts.getValue(ATTRIBUTE_NAME_ID);
//            // relpace place holder with first topic id
//            // Get relative file name
//            for (final ExportAnchor e : resultList) {
//                if (e.topicids.contains(currentFileRelative + QUESTION)) {
//                    e.topicids.add(topicId);
//                    e.topicids.remove(currentFileRelative + QUESTION);
//                }
//            }
//        }

//        // merge multiple exportanchors into one
//        // Each <topicref> can only have one <topicmeta>.
//        // Each <topic> can only have one <prolog>
//        // and <metadata> can have more than one exportanchors
//        // XXX: This should be moved to a separate filter as it's transtype specific
//        if (INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {
//            if (MAP_MAP.matches(classValue) 
//                    && FileUtils.isDITAMapFile(currentFile.getName()) && inputFile.equals(currentFile)) {
//                String pluginId = atts.getValue(ATTRIBUTE_NAME_ID);
//                if (pluginId == null) {
//                    pluginId = "org.sample.help.doc";
//                }
//                final Set<String> set = StringUtils.restoreSet(pluginId);
//                pluginMap.put("pluginId", set);
//            } else if (MAP_TOPICMETA.matches(classValue) || TOPIC_PROLOG.matches(classValue)) {
//                topicMetaSet.add(qName);
//            } else if (DELAY_D_EXPORTANCHORS.matches(classValue)) {
//                hasExport = true;
//                // If current file is a ditamap file
//                if (FileUtils.isDITAMapFile(currentFile.getName())) {
//                    // if dita file's extension name is ".xml"
//                    String editedHref = "";
//                    if (topicHref.endsWith(FILE_EXTENSION_XML)) {
//                        // change the extension to ".dita" for latter compare
//                        editedHref = topicHref.replace(FILE_EXTENSION_XML, FILE_EXTENSION_DITA);
//                    } else {
//                        editedHref = topicHref;
//                    }
//                    // editedHref = editedHref.replace(File.separator, "/");
//                    currentExportAnchor = new ExportAnchor(editedHref);
//                    // if <exportanchors> is defined in topicmeta(topicref), there is only one topic id
//                    currentExportAnchor.topicids.add(topicId);
//                    // If current file is topic file
//                } else if (FileUtils.isDITATopicFile(currentFile.getName())) {
//                    // if dita file's extension name is ".xml"
//                    if (currentFileRelative.endsWith(FILE_EXTENSION_XML)) {
//                        // change the extension to ".dita" for latter compare
//                        currentFileRelative = currentFileRelative.replace(FILE_EXTENSION_XML, FILE_EXTENSION_DITA);
//                    }
//                    currentFileRelative = FileUtils.separatorsToUnix(currentFileRelative);
//                    currentExportAnchor = new ExportAnchor(currentFileRelative);
//                    // if <exportanchors> is defined in metadata(topic), there can be many topic ids
//                    currentExportAnchor.topicids.add(topicId);
//                    shouldAppendEndTag = true;
//                }
//            } else if (DELAY_D_ANCHORKEY.matches(classValue)) {
//                // create keyref element in the StringBuffer
//                // TODO in topic file is no keys
//                final String keyref = atts.getValue(ATTRIBUTE_NAME_KEYREF);
//                currentExportAnchor.keys.add(keyref);
//            } else if (DELAY_D_ANCHORID.matches(classValue)) {
//                // create keyref element in the StringBuffer
//                final String id = atts.getValue(ATTRIBUTE_NAME_ID);
//                // If current file is a ditamap file
//                // The id can only be element id within a topic
//                if (FileUtils.isDITAMapFile(currentFile.getName())) {
//                    // id shouldn't be same as topic id in the case of duplicate insert
//                    if (!topicId.equals(id)) {
//                        currentExportAnchor.ids.add(id);
//                    }
//                } else if (FileUtils.isDITATopicFile(currentFile.getName())) {
//                    // id shouldn't be same as topic id in the case of duplicate insert
//                    if (!topicId.equals(id)) {
//                        // topic id found
//                        currentExportAnchor.ids.add(id);
//                    }
//                }
//            }
//        }

        if (chunkLevel > 0 || atts.getValue(ATTRIBUTE_NAME_CHUNK) != null) {
            chunkLevel++;
        }
        if (relTableLevel > 0 || MAP_RELTABLE.matches(classValue)) {
            relTableLevel++;
        }

        if (chunkToNavLevel > 0) {
            chunkToNavLevel++;
        } else if (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null
                && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains("to-navigation")) {
            chunkToNavLevel++;
        }

        if (topicGroupLevel > 0 || MAPGROUP_D_TOPICGROUP.matches(classValue)) {
            topicGroupLevel++;
        }

        handleTopicRef(localName, atts);

        try {
            parseLinkAttribute(atts, ATTRIBUTE_NAME_CONREF, currentDir);
            handleConrefAttr(atts, currentDir);
            parseLinkAttribute(atts, ATTRIBUTE_NAME_HREF, currentDir);
            handleHrefAttr(atts, currentDir);
            parseLinkAttribute(atts, ATTRIBUTE_NAME_DATA, atts.getValue(ATTRIBUTE_NAME_CODEBASE) != null ? new URI(atts.getValue(ATTRIBUTE_NAME_CODEBASE)) : currentDir);
            parseLinkAttribute(atts, ATTRIBUTE_NAME_COPY_TO, currentDir);
            handleCopyToAttr(atts, currentDir);
        } catch (final URISyntaxException e) {
            logger.error("Failed to parse URI: " + e.getMessage(), e);
        } catch (DITAOTException e) {
            logger.error("Failed to process link: " + e.getMessage(), e);
        }
        handleConactionAttr(atts);
        handleKeyrefAttr(atts);
        
        super.startElement(uri, localName, qName, atts);
    }

    private void handleRootElement(final String localName, final Attributes atts) {
        if (isRootElement) {
            isRootElement = false;
            final String classValue = atts.getValue(ATTRIBUTE_NAME_CLASS);
            if (classValue != null) {
                rootClass = new DitaClass(atts.getValue(ATTRIBUTE_NAME_CLASS));
            }
            if (TOPIC_TOPIC.matches(rootClass)) {
                fileInfo.format(ATTR_FORMAT_VALUE_DITA);
            } else if (ELEMENT_NAME_DITA.equals(localName) && classValue == null) {
                fileInfo.format(ATTR_FORMAT_VALUE_DITA);
            } else if (MAP_MAP.matches(rootClass)) {
                fileInfo.format(ATTR_FORMAT_VALUE_DITAMAP);
            }
            if (SUBJECTSCHEME_SUBJECTSCHEME.matches(rootClass)) {
                fileInfo.isSubjectScheme(true);
            }
        }
    }

    private void handleTopicRef(final String localName, final Attributes atts) {
        final String classValue = atts.getValue(ATTRIBUTE_NAME_CLASS);
        if (MAP_TOPICREF.matches(classValue) && job.getOnlyTopicInMap() && isStartDocument) {
            URI hrefValue = toURI(atts.getValue(ATTRIBUTE_NAME_HREF));
            if (hrefValue == null) {
                hrefValue = toURI(atts.getValue(ATTRIBUTE_NAME_CONREF));
            }
            if (hrefValue != null) {
                if (isExternal(hrefValue, getInherited(ATTRIBUTE_NAME_SCOPE))) {
                    return;
                }
                // normalize href value.
                final File target = toFile(hrefValue);
                // caculate relative path for href value.
                String fileName = null;
                if (target.isAbsolute()) {
                    fileName = FileUtils.getRelativeUnixPath(inputFile.toString(), hrefValue.toString());
                }
                fileName = FileUtils.separatorsToUnix(FileUtils.resolve(currentDir.toString(), hrefValue.toString()).getPath());

                final boolean canParse = parseBranch(atts, hrefValue, fileName);
                if (canParse) {
                    topicrefStack.push(localName);
                }
            }
        }
    }

    private void handleProcessingRole(final Attributes atts) {
        final String href = atts.getValue(ATTRIBUTE_NAME_HREF);
        final String scope = inheritedAttsStack.peekFirst().getValue(ATTRIBUTE_NAME_SCOPE);
        if (href != null && !ATTR_SCOPE_VALUE_EXTERNAL.equals(scope)) {
            final String processingRole = getInherited(ATTRIBUTE_NAME_PROCESSING_ROLE);
            final File target = FileUtils.resolve(currentDir.toString(), href);
            if (ATTR_PROCESSING_ROLE_VALUE_RESOURCE_ONLY.equals(processingRole)) {
                resourceOnlySet.add(target);
            } else if (ATTR_PROCESSING_ROLE_VALUE_NORMAL.equals(processingRole)) {
                normalProcessingSet.add(target);
            }
        }
    }

//    @Override
//    public void ignorableWhitespace(final char[] ch, final int start, final int length) throws SAXException {
//        getContentHandler().characters(ch, start, length);
//    }
    
    @Override
    public void endElement(final String uri, final String localName, final String qName) throws SAXException {
        // processing role
//        if (processRoleLevel > 0) {
//            if (processRoleLevel == processRoleStack.size()) {
//                processRoleStack.pop();
//            }
//            processRoleLevel--;
//        }
        
        if (chunkLevel > 0) {
            chunkLevel--;
        }
        if (relTableLevel > 0) {
            relTableLevel--;
        }
        if (chunkToNavLevel > 0) {
            chunkToNavLevel--;
        }
        if (topicGroupLevel > 0) {
            topicGroupLevel--;
        }
//        // <exportanchors> over should write </file> tag
//
//        if (topicMetaSet.contains(qName) && hasExport) {
//            // If current file is a ditamap file
//            if (FileUtils.isDITAMapFile(currentFile.getName())) {
//                resultList.add(currentExportAnchor);
//                currentExportAnchor = null;
//                // If current file is topic file
//            }
//            hasExport = false;
//            topicMetaSet.clear();
//        }

        if (!topicrefStack.isEmpty() && localName.equals(topicrefStack.peek())) {
            level--;
            topicrefStack.pop();
        }

        inheritedAttsStack.removeFirst();
        super.endElement(uri, localName, qName);
    }

    /**
     * Clean up.
     */
    @Override
    public void endDocument() throws SAXException {
        // processing role
//        if (processRoleLevel > 0) {
//            processRoleLevel--;
//            processRoleStack.pop();
//        }
        
//        if (FileUtils.isDITATopicFile(currentFile.getName()) && shouldAppendEndTag) {
//            resultList.add(currentExportAnchor);
//            currentExportAnchor = null;
//            // should reset
//            shouldAppendEndTag = false;
//        }
        
        super.endDocument();
    }
    
    /**
     * Get file info builder from file info map or create new file info into the map. 
     * 
     * @param file file info path
     * @return existing or new file info
     */
    private Builder getOrCreateBuilder(final String file) {
        final String f = file.isEmpty() ? currentFileRelative.toString() : file;
        FileInfo.Builder b = fileInfoMap.get(f);
        if (b == null) {
            b = new FileInfo.Builder().file(new File(f));
            fileInfoMap.put(f, b);
        }
        return b;
    }
    private Builder getOrCreateBuilder(final URI file) {
        return getOrCreateBuilder(file.toString());
    }

    /**
     * Method for see whether a branch should be parsed.
     * 
     * @param atts {@link Attributes}
     * @param hrefValue {@link String}
     * @param fileName normalized file name(remove '#')
     * @return boolean
     */
    private boolean parseBranch(final Attributes atts, final URI hrefValue, final String fileName) {
        // current file is primary ditamap file.
        // parse every branch.
        if (currentDir == null && isStartDocument) {
            // add branches into map
            addReferredBranches(hrefValue, fileName);
            return true;
        } else {
            // current file is a sub-ditamap one.
            // get branch's id
            final String id = atts.getValue(ATTRIBUTE_NAME_ID);
            // this branch is not referenced
            if (level == 0 && StringUtils.isEmptyString(id)) {
                // There is occassion that the whole ditamap should be parsed
                final boolean found = searchBrachesMap(id);
                if (found) {
                    // Add this branch into map for parsing.
                    addReferredBranches(hrefValue, fileName);
                    // update level
                    level++;
                    return true;
                } else {
                    return false;
                }
                // this brach is a decendent of a referenced one
            } else if (level != 0) {
                // Add this branch into map for parsing.
                addReferredBranches(hrefValue, fileName);
                // update level
                level++;
                return true;
                // This branch has an id but is a new one
            } else if (!StringUtils.isEmptyString(id)) {
                // search branches map.
                final boolean found = searchBrachesMap(id);
                // branch is referenced
                if (found) {
                    // Add this branch into map for parsing.
                    addReferredBranches(hrefValue, fileName);
                    // update level
                    level++;
                    return true;
                } else {
                    // this branch is not referenced
                    return false;
                }
            } else {
                return false;
            }
        }
    }

    /**
     * Search braches map with branch id and current file name.
     * 
     * @param id String branch id.
     * @return boolean true if found and false otherwise.
     */
    private boolean searchBrachesMap(final String id) {
        // seach the map with id & current file name.
        if (validBranches.containsKey(currentFileRelative.getPath())) {
            final List<String> branchIdList = validBranches.get(currentFileRelative.getPath());
            // the branch is referenced.
            if (branchIdList.contains(id)) {

                return true;
            } else // the whole map is referenced
// the branch is not referred
                return branchIdList.size() == 0;
        } else {
            // current file is not refered
            return false;
        }
    }

    /**
     * Add branches into map.
     * 
     * @param hrefValue
     * @param fileName
     */
    private void addReferredBranches(final URI hrefValue, final String fileName) {
        String branchId = null;
        // href value has branch id.
        if (hrefValue.getFragment() != null) {
            branchId = hrefValue.getFragment();
            // The map contains the file name
            if (validBranches.containsKey(fileName)) {
                final List<String> branchIdList = validBranches.get(fileName);
                branchIdList.add(branchId);
            } else {
                final List<String> branchIdList = new ArrayList<String>();
                branchIdList.add(branchId);
                validBranches.put(fileName, branchIdList);
            }
            // href value has no branch id
        } else {
            validBranches.put(fileName, new ArrayList<String>());
        }
    }

    /**
     * Parse the input attributes for needed information.
     * 
     * @param atts all attributes
     * @param attrName attributes to process
     */
    private void parseLinkAttribute(final Attributes atts, final String attrName, final URI baseDir) {
        URI attValue = toURI(atts.getValue(attrName));
        if (attValue == null) {
            return;
        }
        if (isExternal(attValue, getInherited(ATTRIBUTE_NAME_SCOPE))) {
            return;
        }

        // Ignore absolute paths for now
//        if (new File(attrValue).isAbsolute() && // FIXME: cannot test for absolute here as the value is not a system path yet
//                !ATTRIBUTE_NAME_DATA.equals(attrName)) {
//            attrValue = FileUtils.getRelativePath(inputFile.getAbsolutePath(), attrValue);
//        // for object tag bug:3052156
//        } else
        final File file = FileUtils.resolve(baseDir.toString(), attValue.getPath());

        final String attrClass = atts.getValue(ATTRIBUTE_NAME_CLASS);
        final String attrFormat = atts.getValue(ATTRIBUTE_NAME_FORMAT);
//        if (MAP_TOPICREF.matches(attrClass)) {            
//            // only transtype = eclipsehelp
//            if (INDEX_TYPE_ECLIPSEHELP.equals(transtype)) {
//                // For only format of the href is dita topic
//                if (attrFormat == null || ATTR_FORMAT_VALUE_DITA.equals(attrFormat)) {
//                    topicHref = FileUtils.separatorsToUnix(file.getPath());
//                    // attrValue has topicId
//                    if (linkUri.getFragment() != null) {
//                        topicId = linkUri.getFragment();
//                    } else {
//                        // get the first topicId(vaild href file)
//                        if (FileUtils.isDITAFile(topicHref)) {
//                            // topicId =
//                            // MergeUtils.getInstance().getFirstTopicId(topicHref,
//                            // (new File(rootFilePath)).getParent(), true);
//                            // to be unique
//                            topicId = topicHref + QUESTION;
//                        }
//                    }
//                } else {
//                    topicHref = "";
//                    topicId = "";
//                }
//            }
//        }

        // Collect non-conref and non-copyto targets
        if (file != null
                && FileUtils.isValidTarget(file.getPath().toLowerCase())
                && (atts.getValue(ATTRIBUTE_NAME_COPY_TO) == null
                        || !FileUtils.isDITATopicFile(atts.getValue(ATTRIBUTE_NAME_COPY_TO).toLowerCase())
                        || (atts.getValue(ATTRIBUTE_NAME_CHUNK) != null
                            && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains("to-content")))
                && !ATTRIBUTE_NAME_CONREF.equals(attrName)
                && !ATTRIBUTE_NAME_COPY_TO.equals(attrName)
                && (canResolved() || FileUtils.isSupportedImageFile(file.getPath().toLowerCase()))) {
            String format = attrFormat;
            if (format == null) {
                if (TOPIC_IMAGE.matches(attrClass)) {
                    format = "image";
                } else {
                    format = ATTR_FORMAT_VALUE_DITA;
                }
            }
            nonConrefCopytoTargets.add(new Reference(file.getPath(), format));
        }
    }
    
    private void handleHrefAttr(final Attributes atts, final URI baseDir) throws URISyntaxException, DITAOTException {
        final URI href = toURI(atts.getValue(ATTRIBUTE_NAME_HREF));
        if (href != null) {
            final File file = FileUtils.resolve(baseDir.toString(), href.getPath());
            if (PR_D_CODEREF.matches(atts)) {
                fileInfo.hasCoderef(true);
                if (isExternal(href, getInherited(ATTRIBUTE_NAME_SCOPE))) {
                    return;
                }
                getOrCreateBuilder(file.getPath()).isSubtarget(true).format("code");
            } else if (TOPIC_IMAGE.matches(atts)) {
                // noop
            } else {
                if (!MAP_TOPICREF.matches(atts)) {
                    fileInfo.hasLink(true);
                }
                if (isExternal(href, getInherited(ATTRIBUTE_NAME_SCOPE))) {
                    return;
                }
                final String attrFormat = atts.getValue(ATTRIBUTE_NAME_FORMAT);
                if (attrFormat == null || ATTR_FORMAT_VALUE_DITA.equals(attrFormat)) {
                    // Collect only href target topic files for index extracting
                    if (canResolved()) {
                        final Builder b = getOrCreateBuilder(file.getPath()).format(ATTR_FORMAT_VALUE_DITA);
                        // Do not read format 
                        b.isTarget(true);
//                        toOutFile(file.getPath());
                        if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0 && relTableLevel == 0) {
                            b.isSkipChunk(true);
                        } else {
                            b.isNonConrefTarget(true);
                        }
                    }
                }
            }
        }
    }

    // TODO: replace with reading from inheritedAttributes
    private boolean isExternal(final URI href, final String scope) {
        return ATTR_SCOPE_VALUE_EXTERNAL.equals(scope)
                || ATTR_SCOPE_VALUE_PEER.equals(scope)
                || href.toString().contains(COLON_DOUBLE_SLASH)
                || href.toString().startsWith(SHARP);
    }
    
    private void handleCopyToAttr(final Attributes atts, final URI baseDir) throws URISyntaxException, DITAOTException {
        final URI copyTo = toURI(atts.getValue(ATTRIBUTE_NAME_COPY_TO));
        if (copyTo != null && !isExternal(copyTo, getInherited(ATTRIBUTE_NAME_SCOPE))) {
            final String attrFormat = atts.getValue(ATTRIBUTE_NAME_FORMAT);
            if (attrFormat == null || ATTR_FORMAT_VALUE_DITA.equals(attrFormat)) {
                final File file = FileUtils.resolve(baseDir.toString(), copyTo.getPath());
                final URI href = toURI(atts.getValue(ATTRIBUTE_NAME_HREF));
                final File value = FileUtils.resolve(toFile(currentDir), toFile(href));
    
                if (copytoMap.containsKey(file)) {
                    if (!value.equals(copytoMap.get(file))) {
                        logger.warn(MessageUtils.getInstance().getMessage("DOTX065W", href.getPath(), file.getPath()).toString());
                    }
                    ignoredCopytoSourceSet.add(toFile(href));
                } else if (!(atts.getValue(ATTRIBUTE_NAME_CHUNK) != null && atts.getValue(ATTRIBUTE_NAME_CHUNK).contains("to-content"))) {
                    copytoMap.put(file, value);
                }
    
                final String pathWithoutID = FileUtils.resolve(currentDir.toString(), toFile(copyTo.getPath()).getPath()).getPath();
                final Builder b = getOrCreateBuilder(pathWithoutID);
                if (chunkLevel > 0 && chunkToNavLevel == 0 && topicGroupLevel == 0) {
                    b.isSkipChunk(true);
                } else {
                    b.isNonConrefTarget(true);
                }
            }
        }
    }
    
    private void handleConrefAttr(final Attributes atts, final URI baseDir) throws DITAOTException, URISyntaxException {
        final URI conref = toURI(atts.getValue(ATTRIBUTE_NAME_CONREF));
        final String conkeyref = atts.getValue(ATTRIBUTE_NAME_CONKEYREF);
        if (conref != null || conkeyref != null) {
            fileInfo.hasConref(true);
        }
        if (conref != null) {
            final File file = FileUtils.resolve(baseDir.toString(), conref.getPath());
            getOrCreateBuilder(file.getPath()).isConrefTarget(true);
        }
    }
    
    private void handleKeyrefAttr(final Attributes atts) {
        final String keyref = atts.getValue(ATTRIBUTE_NAME_KEYREF);
        final String conkeyref = atts.getValue(ATTRIBUTE_NAME_CONKEYREF);
        if (keyref != null || conkeyref != null) {
            fileInfo.hasKeyref(true);
        }
    }   
    
    /**
     * Collect the conaction source topic file
     */
    private void handleConactionAttr(final Attributes atts) {
        final String attrValue = atts.getValue(ATTRIBUTE_NAME_CONACTION);
        if (attrValue != null) {
            if (attrValue.equals("mark") || attrValue.equals("pushreplace")) {
                fileInfo.isConrefPush(true);
            }
        } 
    }

//    /**
//     * Convert URI references to file paths.
//     * 
//     * @param filename file reference
//     * @return file path
//     */
//    private File toFile(final String filename) {
//        if (filename == null) {
//            return null;
//        }
//        String f = filename;
//        try {
//            f = URLDecoder.decode(filename, UTF8);
//        } catch (final UnsupportedEncodingException e) {
//            throw new RuntimeException(e);
//        }
//        if (processingMode == Mode.LAX) {
//            f = f.replace(WINDOWS_SEPARATOR, File.separator);
//        }
//        f = f.replace(URI_SEPARATOR, File.separator);
//        return new File(f);
//    }

    /**
     * Get multi-level keys list
     */
    private List<String> getKeysList(final String key, final Map<String, String> keysRefMap) {
        final List<String> list = new ArrayList<String>();
        // Iterate the map to look for multi-level keys
        for (Entry<String, String> entry : keysRefMap.entrySet()) {
            // Multi-level key found
            if (entry.getValue().equals(key)) {
                // add key into the list
                final String entryKey = entry.getKey();
                list.add(entryKey);
                // still have multi-level keys
                if (keysRefMap.containsValue(entryKey)) {
                    // rescuive point
                    final List<String> tempList = getKeysList(entryKey, keysRefMap);
                    list.addAll(tempList);
                }
            }
        }
        return list;
    }

    /**
     * Update keysDefMap for multi-level keys
     */
    private void checkMultiLevelKeys(final Map<String, KeyDef> keysDefMap, final Map<String, String> keysRefMap) {
        String key = null;
        KeyDef value = null;
        // tempMap storing values to avoid ConcurrentModificationException
        final Map<String, KeyDef> tempMap = new HashMap<String, KeyDef>();
        for (Entry<String, KeyDef> entry : keysDefMap.entrySet()) {
            key = entry.getKey();
            value = entry.getValue();
            // there is multi-level keys exist.
            if (keysRefMap.containsValue(key)) {
                // get multi-level keys
                final List<String> keysList = getKeysList(key, keysRefMap);
                for (final String multikey : keysList) {
                    // update tempMap
                    tempMap.put(multikey, value);
                }
            }
        }
        // update keysDefMap.
        keysDefMap.putAll(tempMap);
    }

//    /**
//     * Check if path walks up in parent directories
//     * 
//     * @param toCheckPath path to check
//     * @return {@code true} if path walks up, otherwise {@code false}
//     */
//    private boolean isOutFile(final String toCheckPath) {
//        if (!toCheckPath.startsWith("..")) {
//            return false;
//        } else {
//            return true;
//        }
//    }

    /**
     * Check if current file is a map or if not only topics in main map are processed 
     */
    private boolean canResolved() {
        return !job.getOnlyTopicInMap() || rootClass != null && MAP_MAP.matches(rootClass);
    }

//    /**
//     * Add file to out files set
//     * 
//     * @param filename a relative path from the dita input file
//     */
//    private void toOutFile(final String filename) throws DITAOTException {
//        final String[] prop = { FileUtils.normalizeDirectory(inputDir.getAbsolutePath(), filename), FileUtils.normalize(currentFile.getAbsolutePath()) };
//        if ((OutputUtils.getGeneratecopyouter() == OutputUtils.Generate.NOT_GENERATEOUTTER)
//                || (OutputUtils.getGeneratecopyouter() == OutputUtils.Generate.GENERATEOUTTER)) {
//            if (isOutFile(filename)) {
//                if (outputUtils.getOutterControl() == OutputUtils.OutterControl.FAIL) {
//                    final MessageBean msgBean = MessageUtils.getInstance().getMessage("DOTJ035F", prop);
//                    throw new DITAOTException(msgBean, null, msgBean.toString());
//                } else if (outputUtils.getOutterControl() == OutputUtils.OutterControl.WARN) {
//                    final String message = MessageUtils.getInstance().getMessage("DOTJ036W", prop).toString();
//                    logger.logWarn(message);
//                }
//                if (canResolved()) {
//                    outDitaFilesSet.add(filename);
//                }
//            }
//        }
//    }

    /**
     * Get path to base directory
     * 
     * @param filename relative input file path from base directory
     * @param traceFilename absolute input file
     * @param inputMap absolute path to start file
     * @return path to base directory, {@code null} if not available
     */
    public String getPathtoProject(final File filename, final File traceFilename, final String inputMap) {
        String path2Project = null;
//        if (OutputUtils.getGeneratecopyouter() != OutputUtils.Generate.OLDSOLUTION) {
//            if (isOutFile(traceFilename)) {
//                path2Project = getRelativePathFromOut(traceFilename.getAbsolutePath());
//            } else {
//                path2Project = FileUtils.getRelativePath(traceFilename.getAbsolutePath(),inputMap);
//                path2Project = new File(path2Project).getParent();
//                if (path2Project != null && path2Project.length() > 0) {
//                    path2Project = path2Project+File.separator;
//                }
//            }
//        } else {
            final File p = FileUtils.getRelativePath(filename); 
            path2Project = p != null ? p.getPath() : null;
            if (path2Project != null && !path2Project.endsWith(File.separator)) {
                path2Project = path2Project + File.separator;
            }
//        }
         return path2Project;
    }
    
//    /**
//     * Check if path falls outside start document directory
//     * 
//     * @param filePathName path to test
//     * @return {@code true} if outside start directory, otherwise {@code false}
//     */
//    private boolean isOutFile(final File filePathName) {
//        final String relativePath = FileUtils.getRelativePath(outputUtils.getInputMapPathName().getAbsolutePath(), filePathName.getPath());
//        if (relativePath == null || relativePath.length() == 0 || !relativePath.startsWith("..")) {
//            return false;
//        }
//        return true;
//    }
    
//    /**
//     * Just for the overflowing files.
//     * @param overflowingFile overflowingFile
//     * @return relative path to out
//     */
//    public String getRelativePathFromOut(final String overflowingFile) {
//        final File mapPathName = outputUtils.getInputMapPathName();
//        final File currFilePathName = new File(overflowingFile);
//        final String relativePath = FileUtils.getRelativePath( mapPathName.toString(),currFilePathName.toString());
//        final String outputDir = OutputUtils.getOutputDir().getAbsolutePath();
//        final String outputPathName = outputDir + File.separator + "index.html";
//        final String finalOutFilePathName = FileUtils.resolve(outputDir,relativePath);
//        final String finalRelativePathName = FileUtils.getRelativePath(finalOutFilePathName,outputPathName.toString());
//        final String parentDir = new File(finalRelativePathName).getParent();
//        final StringBuffer finalRelativePath = new StringBuffer(parentDir);
//        if (finalRelativePath.length() > 0) {
//            finalRelativePath.append(File.separator);
//        } else {
//            finalRelativePath.append(".").append(File.separator);
//        }
//        return finalRelativePath.toString();
//    }
    
    /**
     * File reference with path and optional format.
     */
    public static class Reference {
        public final String filename;
        public final String format;

        public Reference(final String filename, final String format) {
            this.filename = filename;
            this.format = format;
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + ((filename == null) ? 0 : filename.hashCode());
            result = prime * result + ((format == null) ? 0 : format.hashCode());
            return result;
        }

        @Override
        public boolean equals(final Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (!(obj instanceof Reference)) {
                return false;
            }
            final Reference other = (Reference) obj;
            if (filename == null) {
                if (other.filename != null) {
                    return false;
                }
            } else if (!filename.equals(other.filename)) {
                return false;
            }
            if (format == null) {
                if (other.format != null) {
                    return false;
                }
            } else if (!format.equals(other.format)) {
                return false;
            }
            return true;
        }
    }

//    public static class ExportAnchor {
//        public final String file;
//        public final Set<String> topicids = new HashSet<String>();
//        public final Set<String> keys = new HashSet<String>();
//        public final Set<String> ids = new HashSet<String>();
//
//        ExportAnchor(final String file) {
//            this.file = file;
//        }
//    }

}
```


Overlapping Code:
```
er extends AbstractXMLFilter {

public static final String PI_PATH2PROJ_TARGET = "path2project";
public static final String PI_PATH2PROJ_TARGET_URI = "path2project-uri";
// public static final String PI_WORKDIR_TARGET = "workdir";
public static final String PI_WORKDIR_TARGET_URI = "workdir-uri";

/** Inherited attributes and their default values. */
private static final Map<String, String> inheritedAtts = new HashMap<String, String>();
static {
inheritedAtts.put(ATTRIBUTE_NAME_SCOPE, ATTR_SCOPE_VALUE_LOCAL);
inheritedAtts.put(ATTRIBUTE_NAME_PROCESSING_ROLE, ATTR_PROCESSING_ROLE_VALUE_NORMAL);
}

/** Output utilities */
private Job job;
/** Basedir of the current parsing file */
private URI currentDir = null;
/** Set of all the non-conref and non-copyto targets refered in current parsing file */
private final Set<Reference> nonConrefCopytoTargets;
/** Set of sources of those copy-to that were ignored */
private final Set<File> ignoredCopytoSourceSet;
/** Map of copy-to target to souce */
private final Map<File, File> copytoMap;
/** chunk nesting level */
private int chunkLevel = 0;
/** mark topics in reltables */
private int relTableLevel = 0;
/** chunk to-navigation level */
private int chunkToNavLevel = 0;
/** Topic group nesting level */
private int topicGroupLevel = 0;
/** Flag used to mark if current file is still valid after filtering */
/** Set of outer dita files */
private final Set<File> outDitaFilesSet;
/** Absolute system path to file being processed */
private URI currentFile = null;
/** System path to file being processed, relative to base directory. */
private URI currentFileRelative;
// private boolean setSystemid = true;
/** Stack of inherited attributes. */
private final Deque<AttributesImpl> inheritedAttsStack;
/** Topics with processing role of "resource-only" */
private final Set<File> resourceOnlySet;
/** Topics with processing role of "normal" */
private final Set<File> normalProcessingSet;
// private final List<ExportAnchor> resultList = new ArrayList<ExportAnchor>();
// private ExportAnchor currentExportAnchor;
// /** Flag to show whether a file has <exportanchors> tag */
// private boolean hasExport = false;
// /** For topic/dita files whether a </file> tag should be added */
// private
```
<Overlap Ratio: 0.980819529206626>

---

--- 318 --
Question ID: e1dfd23ecc72161944ba9c049b05834e1fac4040
Original Code:
```
@Tag("group4")
public class ListIT extends AuthorBaseUITest {
    private static String searchValue = "Victor Sullivan";
    private static String tag1 = "ellie";
    private static String tag2 = "joel";
    private static String description = "This is a child page";

    private String compPath;
    private String parentPath;
    private String testPage;
    private String page1Path;
    private String page2Path;
    private String page21Path;
    private String page22Path;
    private String page3Path;
    private String page4Path;
    private String page5Path;
    private EditorPage editorPage;
    private List list;
    private String tag1Path;
    private String tag2Path;

    protected String textRT;
    protected String listRT;

    protected void setComponentResources() {
        textRT = Commons.RT_TEXT_V1;
        listRT = Commons.RT_LIST_V1;
    }


    protected void setup() throws ClientException {
        // add 2 tags
        tag1Path = Commons.addTag(adminClient, tag1);
        tag2Path = Commons.addTag(adminClient, tag2);
        // create a separate parent page
        parentPath = authorClient.createPage("parent_page", "parent_page", rootPage, defaultPageTemplate).getSlingPath();
        // add page 1
        page1Path = authorClient.createPage("page_1", "page_1", parentPath, defaultPageTemplate).getSlingPath();
        // set tag on the page
        String[] tags = new String[]{tag1};
        Commons.setTagsToPage(authorClient, page1Path, tags, 200);
        HashMap<String, String> data = new HashMap<String, String>();
        data.put("jcr:description", description);
        Commons.editNodeProperties(authorClient, page1Path + "/jcr:content", data);
        // add page 2
        page2Path = authorClient.createPage("page_2", "page_2", parentPath, defaultPageTemplate).getSlingPath();
        // add a text component
        String text1Path = Commons.addComponentWithRetry(authorClient, textRT, page2Path + Commons.relParentCompPath, "text");
        //set some text in the text component
        data.clear();
        data.put("text", searchValue);
        Commons.editNodeProperties(authorClient, text1Path, data);
        // create subpage for page 2
        page21Path = authorClient.createPage("sub_2_1", "sub_2_1", page2Path, defaultPageTemplate).getSlingPath();
        // create second sub page for page 2
        page22Path = authorClient.createPage("sub_2_2", "sub_2_2", page2Path, defaultPageTemplate).getSlingPath();
        // add page 3
        page3Path = authorClient.createPage("page_3", "page_3", parentPath, defaultPageTemplate).getSlingPath();
        // set 2 tags on the page
        tags = new String[]{tag1, tag2};
        Commons.setTagsToPage(authorClient, page3Path, tags, 200);
        // create page 4
        page4Path = authorClient.createPage("page_4", "page_4", parentPath, defaultPageTemplate).getSlingPath();
        // create a sub page for page 4
        String page41Path = authorClient.createPage("sub_4_1", "sub_4_1", page4Path, defaultPageTemplate).getSlingPath();
        // add a text component
        String text2Path = Commons.addComponentWithRetry(authorClient, textRT, page41Path + Commons.relParentCompPath, "text");
        //set some text in the text component
        data.clear();
        data.put("text", searchValue);
        Commons.editNodeProperties(authorClient, text2Path, data);
        // create page 5
        page5Path = authorClient.createPage("page_5", "page_5", parentPath, defaultPageTemplate).getSlingPath();
        // set tag on the page
        tags = new String[]{tag2};
        Commons.setTagsToPage(authorClient, page5Path, tags, 200);

        // create the test page containing the list component, store page path in 'testPagePath'
        testPage = authorClient.createPage("testPage", "Test Page Title", rootPage, defaultPageTemplate).getSlingPath();

        // add the component to test page
        compPath = Commons.addComponentWithRetry(authorClient, listRT, testPage + Commons.relParentCompPath, "list");

        // open test page in page editor
        editorPage = new PageEditorPage(testPage);
        editorPage.open();

        list = new List();
    }

    /**
     * Before Test Case
     */
    @BeforeEach
    public void setupBeforeEach() throws ClientException {
        setComponentResources();
        setup();
    }

    /**
     * After Test Case
     */
    @AfterEach
    public void cleanupAfterEach() throws ClientException, InterruptedException {
        authorClient.deletePageWithRetry(parentPath, true,false, RequestConstants.TIMEOUT_TIME_MS, RequestConstants.RETRY_TIME_INTERVAL,  HttpStatus.SC_OK);
        authorClient.deletePageWithRetry(testPage, true,false, RequestConstants.TIMEOUT_TIME_MS, RequestConstants.RETRY_TIME_INTERVAL,  HttpStatus.SC_OK);
        adminClient.deletePath("/content/cq:tags/default/" + tag1Path, HttpStatus.SC_OK);
        adminClient.deletePath("/content/cq:tags/default/" + tag2Path, HttpStatus.SC_OK);
    }

    /**
     * Test: Build a list using direct child pages
     */
    @Test
    @DisplayName("Test: Build a list using direct child pages")
    public void testCreateListDirectChildren() throws ClientException, TimeoutException, InterruptedException {
        // create 3 direct sub pages
        String subpage1Path = authorClient.createPage("direct_1", "direct_1", testPage, defaultPageTemplate).getSlingPath();
        String subpage2Path = authorClient.createPage("direct_2", "direct_2", testPage, defaultPageTemplate).getSlingPath();
        String subpage3Path = authorClient.createPage("direct_2", "direct_3", testPage, defaultPageTemplate).getSlingPath();

        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        // default setting is to build list using 'child pages', empty 'parent page' and 'child depth' = 1,
        // so we only need to save
        Commons.saveConfigureDialog();

        // check if the correct pages are listed
        Commons.switchContext("ContentFrame");
        assertTrue(list.isPagePresentInList("direct_1"), "direct_1 should be present in list");
        assertTrue(list.isPagePresentInList("direct_2"), "direct_2 should be present in list");
        assertTrue(list.isPagePresentInList("direct_3"), "direct_3 should be present in list");
    }

    /**
     * Test: Build a list using child pages from a different location
     */
    @Test
    @DisplayName("Test: Build a list using child pages from a different location")
    public void testCreateListChildren() throws TimeoutException, InterruptedException {
        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        // set parent page
        list.getEditDialog().setParentPage(parentPath);
        // close the dialog
        Commons.saveConfigureDialog();
        Commons.switchContext("ContentFrame");

        assertTrue(list.isPagePresentInList("page_1"), "page_1 should be present in list");
        assertTrue(list.isPagePresentInList("page_2"), "page_2 should be present in list");
        assertTrue(list.isPagePresentInList("page_3"), "page_3 should be present in list");
        assertTrue(list.isPagePresentInList("page_4"), "page_4 should be present in list");
        assertTrue(list.isPagePresentInList("page_5"), "page_5 should be present in list");
    }

    /**
     * Test: Build a list using child pages and sub child pages
     */
    @Test
    @DisplayName("Test: Build a list using child pages and sub child pages")
    public void testListSubChildren() throws TimeoutException, InterruptedException {
        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        ListEditDialog editDialog = list.getEditDialog();
        // set parent page
        editDialog.setParentPage(parentPath);
        // set depth to 2
        editDialog.setChildDepth("2");
        // close the dialog
        Commons.saveConfigureDialog();

        // check if the correct pages are listed
        Commons.switchContext("ContentFrame");
        assertTrue(list.isPagePresentInList("page_1"), "page_1 should be present in list");
        assertTrue(list.isPagePresentInList("page_2"), "page_2 should be present in list");
        assertTrue(list.isPagePresentInList("sub_2_1"), "sub_2_1 should be present in list");
        assertTrue(list.isPagePresentInList("sub_2_2"), "sub_2_2 should be present in list");
        assertTrue(list.isPagePresentInList("page_3"), "page_3 should be present in list");
        assertTrue(list.isPagePresentInList("page_4"), "page_4 should be present in list");
        assertTrue(list.isPagePresentInList("sub_4_1"), "sub_4_1 should be present in list");
        assertTrue(list.isPagePresentInList("page_5"), "page_5 should be present in list");
    }

    /**
     * Test: Build a fixed list
     */
    @Test
    @DisplayName("Test: Build a fixed list")
    public void testCreateFixedList() throws TimeoutException, InterruptedException {
        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        ListEditDialog editDialog = list.getEditDialog();
        // select Fixed List
        editDialog.selectFromList("static");

        // add items
        editDialog.addFixedListOptions(page1Path);
        editDialog.addFixedListOptions(page21Path);
        editDialog.addFixedListOptions(page4Path);

        // close the dialog
        Commons.saveConfigureDialog();
        // check if the correct pages are listed
        Commons.switchContext("ContentFrame");
        assertTrue(list.isPagePresentInList("page_1"), "page_1 should be present in list");
        assertTrue(list.isPagePresentInList("sub_2_1"), "sub_2_1 should be present in list");
        assertTrue(list.isPagePresentInList("page_4"), "page_4 should be present in list");
    }

    /**
     * Test: Build a list using search
     */
    @Test
    @DisplayName("Test: Build a list using search")
    public void testCreateListBySearch() throws InterruptedException, TimeoutException {
        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        ListEditDialog editDialog = list.getEditDialog();

        // set the content path
        editDialog.selectFromList("search");
        // set the search query
        editDialog.enterSearchQuery(searchValue);
        // set search location
        editDialog.setSearchLocation(parentPath);
        // close the dialog
        Commons.saveConfigureDialog();

        // check if the correct pages are listed
        Commons.switchContext("ContentFrame");
        assertTrue(list.isPagePresentInList("page_2"), "page_2 should be present in list");
        assertTrue(list.isPagePresentInList("sub_4_1"), "sub_4_1 should be present in list");
    }

    /**
     * Test: Build a list matching any tags defined
     */
    @Test
    @DisplayName("Test: Build a list matching any tags defined")
    public void testCreateListAnyTagsMatching() throws TimeoutException, InterruptedException {
        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        ListEditDialog editDialog = list.getEditDialog();
        // set the content path
        editDialog.selectFromList("tags");
        // set parent page
        editDialog.setTageSearchRoot(parentPath);
        // search for 2 tags
        editDialog.selectInTags("default/" + tag1);
        editDialog.selectInTags("default/" + tag2);

        // set the content path
        editDialog.setTagsMatch("any");
        // close the dialog
        Commons.saveConfigureDialog();

        // check if the correct pages are listed
        Commons.switchContext("ContentFrame");
        assertTrue(list.isPagePresentInList("page_1"), "page_1 should be present in list");
        assertTrue(list.isPagePresentInList("page_3"), "page_3 should be present in list");
        assertTrue(list.isPagePresentInList("page_5"), "page_5 should be present in list");
    }

    /**
     * Test: Build a list matching all tags defined
     */
    @Test
    @DisplayName("Test: Build a list matching all tags defined")
    public void testCreateListAllTagsMatching() throws InterruptedException, TimeoutException {
        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        ListEditDialog editDialog = list.getEditDialog();
        // set the content path
        editDialog.selectFromList("tags");
        // set parent page
        editDialog.setTageSearchRoot(parentPath);
        // search for 2 tags
        editDialog.selectInTags("default/" + tag1);
        editDialog.selectInTags("default/" + tag2);

        // set the content path
        editDialog.setTagsMatch("all");
        // close the dialog
        Commons.saveConfigureDialog();

        // check if the correct pages are listed
        Commons.switchContext("ContentFrame");
        assertTrue(list.isPagePresentInList("page_3"), "page_3 should be present in list");
    }

    /**
     * Test: order list by title
     */
    @Test
    @DisplayName("Test: order list by title")
    public void testOrderByTitle() throws TimeoutException, InterruptedException {
        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        ListEditDialog editDialog = list.getEditDialog();
        // set parent page
        editDialog.setParentPage(parentPath);
        // set depth to 2
        editDialog.setChildDepth("2");

        // set order by title
        editDialog.setOrderBy("title");

        // set sort order to ascending
        editDialog.setSortOrder("asc");

        // close the dialog
        Commons.saveConfigureDialog();

        // check if they are listed in the right order
        Commons.switchContext("ContentFrame");
        assertTrue(list.isPagePresentInListAtPosition(0, "page_1"), "page_1 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(1, "page_2"), "page_2 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(2, "page_3"), "page_3 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(3, "page_4"), "page_4 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(4, "page_5"), "page_5 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(5, "sub_2_1"), "sub_2_1 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(6, "sub_2_2"), "sub_2_2 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(7, "sub_4_1"), "sub_4_1 should be present in list");
    }

    /**
     * Test: change ordering of a list to descending
     */
    @Test
    @DisplayName("Test: change ordering of a list to descending")
    public void testChangeOrderingTitle() throws InterruptedException, TimeoutException {
        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        ListEditDialog editDialog = list.getEditDialog();
        // set parent page
        editDialog.setParentPage(parentPath);
        // set depth to 2
        editDialog.setChildDepth("2");

        // set order by title
        editDialog.setOrderBy("title");

        // set sort order to ascending
        editDialog.setSortOrder("desc");

        // close the dialog
        Commons.saveConfigureDialog();

        // check if they are listed in the right order
        Commons.switchContext("ContentFrame");
        assertTrue(list.isPagePresentInListAtPosition(0, "sub_4_1"), "sub_4_1 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(1, "sub_2_2"), "sub_2_2 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(2, "sub_2_1"), "sub_2_1 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(3, "page_5"), "page_5 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(4, "page_4"), "page_4 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(5, "page_3"), "page_3 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(6, "page_2"), "page_2 should be present in list");
        assertTrue(list.isPagePresentInListAtPosition(7, "page_1"), "page_1 should be present in list");
    }

    /**
     * Test: set max item
     */
    @Test
    @DisplayName("Test: set max item")
    public void testSetMaxItems() throws TimeoutException, InterruptedException {
        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        ListEditDialog editDialog = list.getEditDialog();
        // set parent page
        editDialog.setParentPage(parentPath);
        // set depth to 2
        editDialog.setChildDepth("2");
        // close the dialog
        Commons.saveConfigureDialog();

        // by default there should be 8
        Commons.switchContext("ContentFrame");
        assertTrue(list.getListLength() == 8, "By default there should be 8 items");
        Commons.switchToDefaultContext();

        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        // set max Items to 4
        editDialog.setMaxItems("4");
        // close the dialog
        Commons.saveConfigureDialog();

        // now it should only render 4 entries
        Commons.switchContext("ContentFrame");
        assertTrue(list.getListLength() == 4, "After setting max items tp 4 there should be 4 items");
        Commons.switchToDefaultContext();
    }

    /**
     * Test: order list by last modified date
     */
    @Test
    @DisplayName("Test: order list by last modified date")
    public void testOrderByLastModifiedDate() throws ClientException, TimeoutException, InterruptedException {
        // modify page 5
        HashMap<String, String> data = new HashMap<String, String>();
        data.put("jcr:title", "Modified Page 5");
        Commons.editNodeProperties(authorClient, page5Path + "/jcr:content", data);

        // modify page 1
        data.put("jcr:title", "Modified Page 1");
        Commons.editNodeProperties(authorClient, page1Path + "/jcr:content", data);

        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        ListEditDialog editDialog = list.getEditDialog();
        // set parent page
        editDialog.setParentPage(parentPath);
        // set depth to 2
        editDialog.setChildDepth("2");

        // set order by modified
        editDialog.setOrderBy("modified");
        // set sort order to ascending
        editDialog.setSortOrder("asc");

        // close the dialog
        Commons.saveConfigureDialog();

        Commons.switchContext("ContentFrame");
        // page 5 should be at 7th place
        assertTrue(list.isPagePresentInListAtPosition(6, "Modified Page 5"), "page 5 should be at 7th place");
        // page 1 should be at 8th place
        assertTrue(list.isPagePresentInListAtPosition(7, "Modified Page 1"), "page 1 should be at 7th place");
    }

    /**
     * Test: order list by last modified date
     */
    @Test
    @DisplayName("Test: order list by last modified date")
    public void testChangeOrderingDate() throws ClientException, TimeoutException, InterruptedException {
        // modify page 3
        HashMap<String, String> data = new HashMap<String, String>();
        data.put("jcr:title", "Modified Page 3");
        Commons.editNodeProperties(authorClient, page3Path + "/jcr:content", data);

        // modify page 2
        data.put("jcr:title", "Modified Page 2");
        Commons.editNodeProperties(authorClient, page2Path + "/jcr:content", data);

        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        ListEditDialog editDialog = list.getEditDialog();
        // set parent page
        editDialog.setParentPage(parentPath);
        // set depth to 2
        editDialog.setChildDepth("2");

        // set order by modified
        editDialog.setOrderBy("modified");
        // set sort order to ascending
        editDialog.setSortOrder("desc");

        // close the dialog
        Commons.saveConfigureDialog();

        Commons.switchContext("ContentFrame");
        // page 5 should be at 7th place
        assertTrue(list.isPagePresentInListAtPosition(0, "Modified Page 2"), "page 2 should be at 7th place");
        // page 1 should be at 8th place
        assertTrue(list.isPagePresentInListAtPosition(1, "Modified Page 3"), "page 3 should be at 7th place");
    }

    /**
     * Test: item settings - link items option
     */
    @Test
    @DisplayName("Test: item settings - link items option")
        public void testLinkItemsForList() throws InterruptedException, TimeoutException {
        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        ListEditDialog editDialog = list.getEditDialog();
        // set parent page
        editDialog.setParentPage(parentPath);
        editDialog.openSettings();
        editDialog.clickLinkItems();

        // close the dialog
        Commons.saveConfigureDialog();

        Commons.switchContext("ContentFrame");
        assertTrue(list.isPageLinkPresent("page_1"),"Page link should be present");
    }

    /**
     * Test: item settings - show description
     */
    @Test
    @DisplayName("Test: item settings - show description")
    public void testShowDescriptionForList() throws InterruptedException, TimeoutException {
        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        ListEditDialog editDialog = list.getEditDialog();
        // set parent page
        editDialog.setParentPage(parentPath);
        editDialog.openSettings();
        editDialog.clickShowDescription();

        // close the dialog
        Commons.saveConfigureDialog();

        Commons.switchContext("ContentFrame");
        assertTrue(list.isPagePresentWithDescription("This is a child page"),"Page should be present with description This is a child page");
    }

    /**
     * Test: item settings - show date
     */
    @Test
    @DisplayName("Test: item settings - show date")
    public void testShowDateForList() throws InterruptedException, TimeoutException {
        // open the configuration dialog
        Commons.openEditDialog(editorPage, compPath);
        ListEditDialog editDialog = list.getEditDialog();
        // set parent page
        editDialog.setParentPage(parentPath);
        editDialog.openSettings();
        editDialog.clickShowModificationDate();

        // close the dialog
        Commons.saveConfigureDialog();

        Commons.switchContext("ContentFrame");

        Date date = new Date(System.currentTimeMillis());
        SimpleDateFormat sdf;
        sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
        String text = sdf.format(date);
        String currentDate = text.substring(0, 10);
        assertTrue(list.isPagePresentWithDate(currentDate),"Page should be present with date " + currentDate);
    }

}
```


Overlapping Code:
```
nds AuthorBaseUITest {
private static String searcllie";
private static String tag2 = "joel";
private static String description = "This is a child page";
private String compPath;
private String parentPath;
private String testPage;
private String page1Path;
private String page2Path;
private String page21Path;
private String page22Path;
private String page3Path;
private String page4Path;
private String page5Path;
private EditorPage editorPage;
private List list;
private String tag1Path;
private String tag2Path;
protected String textRT;
protected String listRT;
protected void setComponentResources() {
textRT = Commons.RT_TEXT_V1;
listRT = Commons.RT_LIST_V1;
}
protected void setup() throws ClientException {
// add 2 tags
tag1Path = Commons.addTag(adminClient, tag1);
tag2Path = Commons.addTag(adminClient, tag2);
// create a separate parent page
parentPath = authorClient.createPage("parent_page", "parent_page", rootPage, defaultPageTemplate).getSlingPath();
// add page 1
page1Path = authorClient.createPage("page_1", "page_1", parentPath, defaultPageTemplate).getSlingPath();
// set tag on the page
String[] tags = new String[]{tag1};
Commons.setTagsToPage(authorClient, page1Path, tags, 200);
HashMap<String, String> data = new HashMap<String, String>();
data.put("jcr:description", description);
Commons.editNodeProperties(authorClient, page1Path + "/jcr:content", data);
// add page 2
page2Path = authorClient.createPage("page_2", "page_2", parentPath, defaultPageTemplate).getSlingPath();
// add a text component
String text1Path = Commons.addComponentWithRetry(authorClient, textRT, page2Path + Commons.relParentCompPath, "text");
//set some text in the text component
data.clear();
data.put("text", searchValue);
Commons.editNodeProperties(authorClient, text1Path, data);
// create subpage for page 2
page21Path = authorClient.createPage("sub_2_1", "sub_2_1", page2Path, defaultPageTemplate).getSlingPath();
// create second sub page for page 2
page22Path = authorClient.createPage("sub_2_2", "sub_2_2", page2Path, defaultPageTemplate
```
<Overlap Ratio: 0.9416628387689481>

---

--- 319 --
Question ID: 31cbd67eb1521201e6b25ba68de40b1eb0bcb91a
Original Code:
```
public class JvmInfo implements Streamable, Serializable, ToXContent {

    private static JvmInfo INSTANCE;

    static {
        RuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();
        MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();

        // returns the <process id>@<host>
        long pid;
        String xPid = runtimeMXBean.getName();
        try {
            xPid = xPid.split("@")[0];
            pid = Long.parseLong(xPid);
        } catch (Exception e) {
            pid = -1;
        }
        JvmInfo info = new JvmInfo();
        info.pid = pid;
        info.startTime = runtimeMXBean.getStartTime();
        info.version = runtimeMXBean.getSystemProperties().get("java.version");
        info.vmName = runtimeMXBean.getVmName();
        info.vmVendor = runtimeMXBean.getVmVendor();
        info.vmVersion = runtimeMXBean.getVmVersion();
        info.mem = new Mem();
        info.mem.heapInit = memoryMXBean.getHeapMemoryUsage().getInit() < 0 ? 0 : memoryMXBean.getHeapMemoryUsage().getInit();
        info.mem.heapMax = memoryMXBean.getHeapMemoryUsage().getMax() < 0 ? 0 : memoryMXBean.getHeapMemoryUsage().getMax();
        info.mem.nonHeapInit = memoryMXBean.getNonHeapMemoryUsage().getInit() < 0 ? 0 : memoryMXBean.getNonHeapMemoryUsage().getInit();
        info.mem.nonHeapMax = memoryMXBean.getNonHeapMemoryUsage().getMax() < 0 ? 0 : memoryMXBean.getNonHeapMemoryUsage().getMax();
        try {
            Class<?> vmClass = Class.forName("sun.misc.VM");
            info.mem.directMemoryMax = (Long) vmClass.getMethod("maxDirectMemory").invoke(null);
        } catch (Throwable t) {
            // ignore
        }
        info.inputArguments = runtimeMXBean.getInputArguments().toArray(new String[runtimeMXBean.getInputArguments().size()]);
        info.bootClassPath = runtimeMXBean.getBootClassPath();
        info.classPath = runtimeMXBean.getClassPath();
        info.systemProperties = runtimeMXBean.getSystemProperties();

        List<GarbageCollectorMXBean> gcMxBeans = ManagementFactory.getGarbageCollectorMXBeans();
        info.gcCollectors = new String[gcMxBeans.size()];
        for (int i = 0; i < gcMxBeans.size(); i++) {
            GarbageCollectorMXBean gcMxBean = gcMxBeans.get(i);
            info.gcCollectors[i] = gcMxBean.getName();
        }

        List<MemoryPoolMXBean> memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();
        info.memoryPools = new String[memoryPoolMXBeans.size()];
        for (int i = 0; i < memoryPoolMXBeans.size(); i++) {
            MemoryPoolMXBean memoryPoolMXBean = memoryPoolMXBeans.get(i);
            info.memoryPools[i] = memoryPoolMXBean.getName();
        }

        INSTANCE = info;
    }

    public static JvmInfo jvmInfo() {
        return INSTANCE;
    }

    long pid = -1;

    String version = "";
    String vmName = "";
    String vmVersion = "";
    String vmVendor = "";

    long startTime = -1;

    Mem mem;

    String[] inputArguments;

    String bootClassPath;

    String classPath;

    Map<String, String> systemProperties;

    String[] gcCollectors = Strings.EMPTY_ARRAY;
    String[] memoryPools = Strings.EMPTY_ARRAY;

    private JvmInfo() {
    }

    /**
     * The process id.
     */
    public long pid() {
        return this.pid;
    }

    /**
     * The process id.
     */
    public long getPid() {
        return pid;
    }

    public String version() {
        return this.version;
    }

    public String getVersion() {
        return this.version;
    }

    public int versionAsInteger() {
        try {
            int i = 0;
            String sVersion = "";
            for (; i < version.length(); i++) {
                if (!Character.isDigit(version.charAt(i)) && version.charAt(i) != '.') {
                    break;
                }
                if (version.charAt(i) != '.') {
                    sVersion += version.charAt(i);
                }
            }
            if (i == 0) {
                return -1;
            }
            return Integer.parseInt(sVersion);
        } catch (Exception e) {
            return -1;
        }
    }

    public int versionUpdatePack() {
        try {
            int i = 0;
            String sVersion = "";
            for (; i < version.length(); i++) {
                if (!Character.isDigit(version.charAt(i)) && version.charAt(i) != '.') {
                    break;
                }
                if (version.charAt(i) != '.') {
                    sVersion += version.charAt(i);
                }
            }
            if (i == 0) {
                return -1;
            }
            Integer.parseInt(sVersion);
            int from;
            if (version.charAt(i) == '_') {
                // 1.7.0_4
                from = ++i;
            } else if (version.charAt(i) == '-' && version.charAt(i + 1) == 'u') {
                // 1.7.0-u2-b21
                i = i + 2;
                from = i;
            } else {
                return -1;
            }
            for (; i < version.length(); i++) {
                if (!Character.isDigit(version.charAt(i)) && version.charAt(i) != '.') {
                    break;
                }
            }
            if (from == i) {
                return -1;
            }
            return Integer.parseInt(version.substring(from, i));
        } catch (Exception e) {
            return -1;
        }
    }

    public String vmName() {
        return vmName;
    }

    public String getVmName() {
        return vmName;
    }

    public String vmVersion() {
        return vmVersion;
    }

    public String getVmVersion() {
        return vmVersion;
    }

    public String vmVendor() {
        return vmVendor;
    }

    public String getVmVendor() {
        return vmVendor;
    }

    public long startTime() {
        return startTime;
    }

    public long getStartTime() {
        return startTime;
    }

    public Mem mem() {
        return mem;
    }

    public Mem getMem() {
        return mem();
    }

    public String[] inputArguments() {
        return inputArguments;
    }

    public String[] getInputArguments() {
        return inputArguments;
    }

    public String bootClassPath() {
        return bootClassPath;
    }

    public String getBootClassPath() {
        return bootClassPath;
    }

    public String classPath() {
        return classPath;
    }

    public String getClassPath() {
        return classPath;
    }

    public Map<String, String> systemProperties() {
        return systemProperties;
    }

    public Map<String, String> getSystemProperties() {
        return systemProperties;
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject(Fields.JVM);
        builder.field(Fields.PID, pid);
        builder.field(Fields.VERSION, version);
        builder.field(Fields.VM_NAME, vmName);
        builder.field(Fields.VM_VERSION, vmVersion);
        builder.field(Fields.VM_VENDOR, vmVendor);
        builder.field(Fields.START_TIME, startTime);

        builder.startObject(Fields.MEM);
        builder.byteSizeField(Fields.HEAP_INIT_IN_BYTES, Fields.HEAP_INIT, mem.heapInit);
        builder.byteSizeField(Fields.HEAP_MAX_IN_BYTES, Fields.HEAP_MAX, mem.heapMax);
        builder.byteSizeField(Fields.NON_HEAP_INIT_IN_BYTES, Fields.NON_HEAP_INIT, mem.nonHeapInit);
        builder.byteSizeField(Fields.NON_HEAP_MAX_IN_BYTES, Fields.NON_HEAP_MAX, mem.nonHeapMax);
        builder.byteSizeField(Fields.DIRECT_MAX_IN_BYTES, Fields.DIRECT_MAX, mem.directMemoryMax);
        builder.endObject();

        builder.field(Fields.GC_COLLECTORS, gcCollectors);
        builder.field(Fields.MEMORY_POOLS, memoryPools);

        builder.endObject();
        return builder;
    }

    static final class Fields {
        static final XContentBuilderString JVM = new XContentBuilderString("jvm");
        static final XContentBuilderString PID = new XContentBuilderString("pid");
        static final XContentBuilderString VERSION = new XContentBuilderString("version");
        static final XContentBuilderString VM_NAME = new XContentBuilderString("vm_name");
        static final XContentBuilderString VM_VERSION = new XContentBuilderString("vm_version");
        static final XContentBuilderString VM_VENDOR = new XContentBuilderString("vm_vendor");
        static final XContentBuilderString START_TIME = new XContentBuilderString("start_time");

        static final XContentBuilderString MEM = new XContentBuilderString("mem");
        static final XContentBuilderString HEAP_INIT = new XContentBuilderString("heap_init");
        static final XContentBuilderString HEAP_INIT_IN_BYTES = new XContentBuilderString("heap_init_in_bytes");
        static final XContentBuilderString HEAP_MAX = new XContentBuilderString("heap_max");
        static final XContentBuilderString HEAP_MAX_IN_BYTES = new XContentBuilderString("heap_max_in_bytes");
        static final XContentBuilderString NON_HEAP_INIT = new XContentBuilderString("non_heap_init");
        static final XContentBuilderString NON_HEAP_INIT_IN_BYTES = new XContentBuilderString("non_heap_init_in_bytes");
        static final XContentBuilderString NON_HEAP_MAX = new XContentBuilderString("non_heap_max");
        static final XContentBuilderString NON_HEAP_MAX_IN_BYTES = new XContentBuilderString("non_heap_max_in_bytes");
        static final XContentBuilderString DIRECT_MAX = new XContentBuilderString("direct_max");
        static final XContentBuilderString DIRECT_MAX_IN_BYTES = new XContentBuilderString("direct_max_in_bytes");
        static final XContentBuilderString GC_COLLECTORS = new XContentBuilderString("gc_collectors");
        static final XContentBuilderString MEMORY_POOLS = new XContentBuilderString("memory_pools");
    }

    public static JvmInfo readJvmInfo(StreamInput in) throws IOException {
        JvmInfo jvmInfo = new JvmInfo();
        jvmInfo.readFrom(in);
        return jvmInfo;
    }

    @Override
    public void readFrom(StreamInput in) throws IOException {
        pid = in.readLong();
        version = in.readString();
        vmName = in.readString();
        vmVersion = in.readString();
        vmVendor = in.readString();
        startTime = in.readLong();
        inputArguments = new String[in.readInt()];
        for (int i = 0; i < inputArguments.length; i++) {
            inputArguments[i] = in.readString();
        }
        bootClassPath = in.readString();
        classPath = in.readString();
        systemProperties = new HashMap<String, String>();
        int size = in.readInt();
        for (int i = 0; i < size; i++) {
            systemProperties.put(in.readString(), in.readString());
        }
        mem = new Mem();
        mem.readFrom(in);
        gcCollectors = in.readStringArray();
        memoryPools = in.readStringArray();
    }

    @Override
    public void writeTo(StreamOutput out) throws IOException {
        out.writeLong(pid);
        out.writeString(version);
        out.writeString(vmName);
        out.writeString(vmVersion);
        out.writeString(vmVendor);
        out.writeLong(startTime);
        out.writeInt(inputArguments.length);
        for (String inputArgument : inputArguments) {
            out.writeString(inputArgument);
        }
        out.writeString(bootClassPath);
        out.writeString(classPath);
        out.writeInt(systemProperties.size());
        for (Map.Entry<String, String> entry : systemProperties.entrySet()) {
            out.writeString(entry.getKey());
            out.writeString(entry.getValue());
        }
        mem.writeTo(out);
        out.writeStringArray(gcCollectors);
        out.writeStringArray(memoryPools);
    }

    public static class Mem implements Streamable, Serializable {

        long heapInit = 0;
        long heapMax = 0;
        long nonHeapInit = 0;
        long nonHeapMax = 0;
        long directMemoryMax = 0;

        Mem() {
        }

        public ByteSizeValue heapInit() {
            return new ByteSizeValue(heapInit);
        }

        public ByteSizeValue getHeapInit() {
            return heapInit();
        }

        public ByteSizeValue heapMax() {
            return new ByteSizeValue(heapMax);
        }

        public ByteSizeValue getHeapMax() {
            return heapMax();
        }

        public ByteSizeValue nonHeapInit() {
            return new ByteSizeValue(nonHeapInit);
        }

        public ByteSizeValue getNonHeapInit() {
            return nonHeapInit();
        }

        public ByteSizeValue nonHeapMax() {
            return new ByteSizeValue(nonHeapMax);
        }

        public ByteSizeValue getNonHeapMax() {
            return nonHeapMax();
        }

        public ByteSizeValue directMemoryMax() {
            return new ByteSizeValue(directMemoryMax);
        }

        public ByteSizeValue getDirectMemoryMax() {
            return directMemoryMax();
        }

        public static Mem readMem(StreamInput in) throws IOException {
            Mem mem = new Mem();
            mem.readFrom(in);
            return mem;
        }

        @Override
        public void readFrom(StreamInput in) throws IOException {
            heapInit = in.readVLong();
            heapMax = in.readVLong();
            nonHeapInit = in.readVLong();
            nonHeapMax = in.readVLong();
            directMemoryMax = in.readVLong();
        }

        @Override
        public void writeTo(StreamOutput out) throws IOException {
            out.writeVLong(heapInit);
            out.writeVLong(heapMax);
            out.writeVLong(nonHeapInit);
            out.writeVLong(nonHeapMax);
            out.writeVLong(directMemoryMax);
        }
    }
}
```


Overlapping Code:
```
nfo implements Streamable, Serializable, ToXContent {
private static JvmInfo INSTANCE;
static {
RuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();
MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();
// returns the <process id>@<host>
long pid;
String xPid = runtimeMXBean.getName();
try {
xPid = xPid.split("@")[0];
pid = Long.parseLong(xPid);
} catch (Exception e) {
pid = -1;
}
JvmInfo info = new JvmInfo();
info.pid = pid;
info.startTime = runtimeMXBean.getStartTime();
info.version = runtimeMXBean.getSystemProperties().get("java.version");
info.vmName = runtimeMXBean.getVmName();
info.vmVendor = runtimeMXBean.getVmVendor();
info.vmVersion = runtimeMXBean.getVmVersion();
info.mem = new Mem();
info.mem.heapInit = memoryMXBean.getHeapMemoryUsage().getInit() < 0 ? 0 : memoryMXBean.getHeapMemoryUsage().getInit();
info.mem.heapMax = memoryMXBean.getHeapMemoryUsage().getMax() < 0 ? 0 : memoryMXBean.getHeapMemoryUsage().getMax();
info.mem.nonHeapInit = memoryMXBean.getNonHeapMemoryUsage().getInit() < 0 ? 0 : memoryMXBean.getNonHeapMemoryUsage().getInit();
info.mem.nonHeapMax = memoryMXBean.getNonHeapMemoryUsage().getMax() < 0 ? 0 : memoryMXBean.getNonHeapMemoryUsage().getMax();
try {
Class<?> vmClass = Class.forName("sun.misc.VM");
info.mem.directMemoryMax = (Long) vmClass.getMethod("maxDirectMemory").invoke(null);
} catch (Throwable t) {
// ignore
}
info.inputArguments = runtimeMXBean.getInputArguments().toArray(new String[runtimeMXBean.getInputArguments().size()]);
info.bootClassPath = runtimeMXBean.getBootClassPath();
info.classPath = runtimeMXBean.getClassPath();
info.systemProperties = runtimeMXBean.getSystemProperties();
List<GarbageCollectorMXBean> gcMxBeans = ManagementFactory.getGarbageCollectorMXBeans();
info.gcCollectors = new String[gcMxBeans.size()];
for (int i = 0; i < gcMxBeans.size(); i++) {
GarbageCollectorMXBean gcMxBean = gcMxBeans.get(i);
info.gcCollectors[i] = gcMxBean.getName();
}
List<MemoryPoolMXBean> memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();
info.memoryPools = new String[memoryPoolMXBeans.size()];
fo
```
<Overlap Ratio: 0.9919735599622285>

---

--- 320 --
Question ID: c007516efa7c6eccb55e1a9b76a54599901db7ad
Original Code:
```
public class CrawlerCheckNewObject extends AbstractCrawler {


	private static final Logger LOGGER = Logger.getLogger(CrawlerCheckNewObject.class);

	/**
	 * Walker sur tag_tmp_site.
	 */
	private final TagTmpSiteImpl.RecordWalker<TagTmpSite> mWalker;

	/**
	 * Référence sur le client.
	 */
	private final JabberComponent mComponent;

	public CrawlerCheckNewObject(String[] inArgs) {
		super(inArgs);

		this.mWalker = new TagTmpSiteImpl.RecordWalker<TagTmpSite>() {

			public void process(TagTmpSite inTagTmpSite) {
				processTagTmpSite(inTagTmpSite);
			}
		};

		this.mComponent = JabberComponentManager.getComponent(Constantes.XMPP_PLATFORM_COMPONENT);
	}

	private void processTagTmpSite(TagTmpSite inTagTmpSite) {

		final String theSerial = inTagTmpSite.getSerial();
		final HARDWARE theHardware = inTagTmpSite.getHardware();
		final String theIp = inTagTmpSite.getIp();
		if (theHardware.checkIdentifier(theSerial)) { // pour blinder les mac très bien pourrite même si elle est vérifié en amont!!

			final VObject theObject = Factories.VOBJECT.findBySerial(theSerial);
			if (theObject == null) { // il n'existe pas donc on l'essaye de l'inscrire
				final MessageDraft theMessageDraft = Provisionning.addObjectInQueue(theIp, theSerial, theHardware);
				if (!theMessageDraft.getSequenceList().isEmpty()) {
					// Envoi du message pour s'inscrire
					final Packet thePacket = this.mComponent.getPacket(theMessageDraft, JabberMessageFactory.IDLE_MODE);
					String thePacketXml = thePacket.toXML();
					thePacketXml = thePacketXml.replaceAll(Provisionning.VIRTUAL_SERIAL_HARDWARE_4.toLowerCase(), theSerial);
					this.mComponent.sendPacket(thePacketXml);
				}
			} else { // l'objet est déjà associé
				inTagTmpSite.delete();
			}
		} else {
			CrawlerCheckNewObject.LOGGER.fatal(" Bad serial in tag_tmp_site : " + theSerial);
		}

	}

	@Override
	protected void process() {
		CrawlerCheckNewObject.LOGGER.info(" total : " + TagTmpSiteImpl.walkCheckNewObject(this.mWalker));
	}
}
```


Overlapping Code:
```
wObject extends AbstractCrawler {
private static final Logger LOGGER = Logger.getLogger(CrawlerCheckNewObject.class);
/**
* Walker sur tag_tmp_site.
*/
private final TagTmpSiteImpl.RecordWalker<TagTmpSite> mWalker;
/**
* Référence sur le client.
*/
private final JabberComponent mComponent;
public CrawlerCheckNewObject(String[] inArgs) {
super(inArgs);
this.mWalker = new TagTmpSiteImpl.RecordWalker<TagTmpSite>() {
public void process(TagTmpSite inTagTmpSite) {
processTagTmpSite(inTagTmpSite);
}
};
this.mComponent = JabberComponentManager.getComponent(Constantes.XMPP_PLATFORM_COMPONENT);
}
private void processTagTmpSite(TagTmpSite inTagTmpSite) {
final String theSerial = inTagTmpSite.getSerial();
final HARDWARE theHardware = inTagTmpSite.getHardware();
final String theIp = inTagTmpSite.getIp();
if (theHardware.checkIdentifier(theSerial)) { // pour blinder les mac très bien pourrite même si elle est vérifié en amont!!
final VObject theObject = Factories.VOBJECT.findBySerial(theSerial);
if (theObject == null) { // il n'existe pas donc on l'essaye de l'inscrire
final MessageDraft theMessageDraft = Provisionning.addObjectInQueue(theIp, theSerial, theHardware);
if (!theMessageDraft.getSequenceList().isEmpty()) {
// Envoi du message pour s'inscrire
final Packet thePacket = this.mComponent.getPacket(theMessageDraft, JabberMessageFactory.IDLE_MODE);
String thePacketXml = thePacket.toXML();
thePacketXml = thePacketXml.replaceAll(Provisionning.VIRTUAL_SERIAL_HARDWARE_4.toLowerCase(), theSerial);
this.mComponent.sendPacket(thePacketXml);
}
} else { // l'objet est déjà associé
inTagTmpSite.delete();
}
} else {
CrawlerCheckNewObject.LOGGER.fatal(" Bad serial in tag_tmp_site : " + theSerial);
}
}
@Override
protected void process() {
CrawlerCheckNewObject.LOGGER.info(" total : " + TagTm
```
<Overlap Ratio: 0.96>

---

--- 321 --
Question ID: e74cf115db2f058681004583ad26f64020b11f72
Original Code:
```
@NotThreadSafe
public class JUnitRunListenerAdapter extends RunListener {

    private static final Pattern JAVA_CLASS_NAME_PATTERN = Pattern.compile("[\\._$\\p{Alnum}]+");

    private final SuiteNotifier notifier;
    private final Deque<TestNotifier> activeTestsStack = new ArrayDeque<>();
    private final Map<Description, TestId> descriptionIds = new HashMap<>();
    private Description rootDescription;

    public JUnitRunListenerAdapter(SuiteNotifier notifier) {
        this.notifier = notifier;
    }

    @Override
    public void testRunStarted(Description description) {
        rootDescription = description;
        fireTestFound(TestId.ROOT, description);
    }

    private void fireTestFound(TestId testId, Description description) {
        TestId previousValue = descriptionIds.put(description, testId);
        if (previousValue == null) {
            notifier.fireTestFound(testId, formatTestName(description));
        }

        TestId childId = testId.getFirstChild();
        for (Description child : description.getChildren()) {
            fireTestFound(childId, child);
            childId = childId.getNextSibling();
        }
    }

    private static String formatTestName(Description description) {
        String methodName = description.getMethodName();
        if (methodName != null) {
            return methodName;
        }
        String className = description.getClassName();
        if (isJavaClassName(className)) {
            return simpleClassName(className);
        }
        // not a class name, but actually free-form text
        return className;
    }

    private static boolean isJavaClassName(String s) {
        return JAVA_CLASS_NAME_PATTERN.matcher(s).matches();
    }

    private static String simpleClassName(String name) {
        name = name.substring(name.lastIndexOf('.') + 1);
        name = name.substring(name.lastIndexOf('$') + 1);
        return name;
    }

    @Override
    public void testRunFinished(Result result) {
    }

    @Override
    public void testStarted(Description description) {
        TestId id = descriptionIds.get(description);
        if (id == null) {
            // Hoping that the runner added this description as a child to the top-level description
            fireTestFound(TestId.ROOT, rootDescription);
            id = descriptionIds.get(description);
        }
        if (id == null) {
            // Fallback if we have no way of knowing this description's parent
            id = nextUnassignedChildOf(TestId.ROOT);
            fireTestFound(id, description);
        }
        startTestAndItsParents(id);
    }

    private TestId nextUnassignedChildOf(TestId parent) {
        Set<TestId> assignedIds = new HashSet<>(descriptionIds.values());
        TestId id = parent.getFirstChild();
        while (assignedIds.contains(id)) {
            id = id.getNextSibling();
        }
        return id;
    }

    private void startTestAndItsParents(TestId testId) {
        if (!testId.isRoot()) {
            startTestAndItsParents(testId.getParent());
        }
        TestNotifier tn = notifier.fireTestStarted(testId);
        activeTestsStack.push(tn);
    }

    @Override
    public void testFinished(Description description) {
        finishAllTests();
    }

    private void finishAllTests() {
        while (!activeTestsStack.isEmpty()) {
            TestNotifier tn = activeTestsStack.pop();
            tn.fireTestFinished();
        }
    }

    @Override
    public void testFailure(Failure failure) {
        TestNotifier tn = activeTestsStack.peek();
        if (tn != null) {
            tn.fireFailure(failure.getException());
        }
    }

    @Override
    public void testAssumptionFailure(Failure failure) {
        // TODO: implement ignoring tests into Jumi, then fire the appropriate event here
        failure.getException().printStackTrace();
    }

    @Override
    public void testIgnored(Description description) {
        // TODO: implement ignoring tests into Jumi, then fire the appropriate event here
    }
}
```


Overlapping Code:
```
blic class JUnitRunListenerAdapter extends RunListener {
private static final Pattern JAVA_CLASS_NAME_PATTERN = Pattern.compile("[\\._$\\p{Alnum}]+");
private final SuiteNotifier notifier;
private final Deque<TestNotifier> activeTestsStack = new ArrayDeque<>();
private final Map<Description, TestId> descriptionIds = new HashMap<>();
private Description rootDescription;
public JUnitRunListenerAdapter(SuiteNotifier notifier) {
this.notifier = notifier;
}
@Override
public void testRunStarted(Description description) {
rootDescription = description;
fireTestFound(TestId.ROOT, description);
}
private void fireTestFound(TestId testId, Description description) {
TestId previousValue = descriptionIds.put(description, testId);
if (previousValue == null) {
notifier.fireTestFound(testId, formatTestName(description));
}
TestId childId = testId.getFirstChild();
for (Description child : description.getChildren()) {
fireTestFound(childId, child);
childId = childId.getNextSibling();
}
}
private static String formatTestName(Description description) {
String methodName = description.getMethodName();
if (methodName != null) {
return methodName;
}
String className = description.getClassName();
if (isJavaClassName(className)) {
return simpleClassName(className);
}
// not a class name, but actually free-form text
return className;
}
private static boolean isJavaClassName(String s) {
return JAVA_CLASS_NAME_PATTERN.matcher(s).matches();
}
private static String simpleClassName(String name) {
name = name.substring(name.lastIndexOf('.') + 1);
name = name.substring(name.lastIndexOf('$') + 1);
return name;
}
@Override
public void testRunFinished(Result result) {
}
@Override
public void testStarted(Description description) {
TestId id = descriptionIds.get(description);
if (id == null) {
// Hoping that the runner added this description as a child to the top-level description
fireTestFound(TestId.ROOT, rootDescription);
id = descriptionIds.get(description);
}
if (id == null) {
// Fallback if we have no way of knowing this description's parent
id 
```
<Overlap Ratio: 0.98747591522158>

---

--- 322 --
Question ID: 5f2115ca2ee2d1e94cc24707fbfa74bba83ee907
Original Code:
```
public class MatrixIterator implements Iterator<Integer> {

    public int[][] values;
    private int lineArray;
    private int columnArray;

    public MatrixIterator(int[][] values) {
        this.values = values;
    }

    @Override
    public boolean hasNext() {

        return this.lineArray < values.length;
    }

    @Override
    public Integer next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        int result = values[lineArray][columnArray++];
        if (columnArray == values[lineArray].length) {
            lineArray++;
            columnArray = 0;
        }

        return result;
    }
}
```


Overlapping Code:
```
ic class MatrixIterator implements Iterator<Integer> {
public int[][] values;
private int lineArray;
private int columnArray;
public MatrixIterator(int[][] values) {
this.values = values;
}
@Override
public boolean hasNext() {
return this.lineArray < values.length;
}
@Override
public Integer next() {
if (!hasNext()) {
throw new NoSuchElementException();
}
int result = values[lineArray][columnArray++];
if (columnArray == values[lineArray].length) {
lineArray++;
columnArray = 0;
}
return result;
}
```
<Overlap Ratio: 0.9881422924901185>

---

--- 323 --
Question ID: a08922bd46d0ac4b99712e6743d77a3aea9697b1
Original Code:
```
public class PassengerStopAssignmentValidator extends AbstractValidator {

	public static final String LOCAL_CONTEXT = NetexStifConstant.PASSENGER_STOP_ASSIGNMENT;
	
	protected String getLocalContext()
	{
		return LOCAL_CONTEXT;
	}

	@Override
	public void init(Context context) {
		super.init(context);
		ValidationReporter validationReporter = ValidationReporter.Factory.getInstance();

		// -- preset checkpoints to OK if uncheck
		validationReporter.prepareCheckPointReport(context, NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1);
	}

	public boolean validate(Context context, PassengerStopAssignment stopAssignment, int lineNumber, int columnNumber)
	{
		boolean result = checkModification(context, NetexStifConstant.PASSENGER_STOP_ASSIGNMENT, stopAssignment, lineNumber, columnNumber);
		return check2NeTExSTIFPassengerStopAssignment1(context, stopAssignment, lineNumber, columnNumber) && result;
	}
 	/** 
 	 * <b>Titre</b> :[Netex] Contrôle de l'objet PassengerStopAssignment : complétude
 	 * <p>
 	 * <b>R&eacute;ference Redmine</b> : <a target="_blank" href="https://projects.af83.io/issues/2318">Cartes #2318</a>
 	 * <p>
 	 * <b>Code</b> : 2-NeTExSTIF-PassengerStopAssignment-1
 	 * <p>
 	 * <b>Variables</b> :  néant
 	 * <p>
 	 * <b>Prérequis</b> :  néant
 	 * <p>
 	 * <b>Prédicat</b> :  Les attributs ScheduledStopPointRef et QuayRef doivent être renseignés
 	 * <p>
 	 * <b>Message</b> :  {fichier}-Ligne {ligne}-Colonne {Colonne}, l'attribut {attribut requis} de l'objet PassengerStopAssignment {ObjectId} doit être renseigné 
 	 * <p>
 	 * <b>Criticité</b> :  error
 	 * <p>
 	 * 
 	 *
 	 * @param context
 	 * @return
 	 */
 	public boolean check2NeTExSTIFPassengerStopAssignment1(Context context, PassengerStopAssignment stopAssignment, int lineNumber, int columnNumber) {
 		boolean result1 = stopAssignment.getScheduledStopPointRef() != null && !stopAssignment.getScheduledStopPointRef().isEmpty();
 		boolean result2 = stopAssignment.getQuayRef() != null && !stopAssignment.getQuayRef().isEmpty();
 		if (!result1)
 		{
			ValidationReporter validationReporter = ValidationReporter.Factory.getInstance();
			String fileName = (String) context.get(Constant.FILE_NAME);
			LineLite line = (LineLite) context.get(Constant.LINE);
			DataLocation location = new DataLocation(fileName, lineNumber, columnNumber, line, stopAssignment);
			validationReporter.addCheckPointReportError(context, null, NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1,NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1, location, "ScheduledStopPointRef");

 		}
 		if (!result2)
 		{
			ValidationReporter validationReporter = ValidationReporter.Factory.getInstance();
			String fileName = (String) context.get(Constant.FILE_NAME);
			LineLite line = (LineLite) context.get(Constant.LINE);
			DataLocation location = new DataLocation(fileName, lineNumber, columnNumber, line, stopAssignment);
			validationReporter.addCheckPointReportError(context, null, NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1,NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1, location, "QuayRef");

 		}

 		return result1 && result2;
 	}
 

}
```


Overlapping Code:
```
topAssignmentValidator extends AbstractValidator {
public static final String LOCAL_CONTEXT = NetexStifConstant.PASSENGER_STOP_ASSIGNMENT;

protected String getLocalContext()
{
return LOCAL_CONTEXT;
}
@Override
public void init(Context context) {
super.init(context);
ValidationReporter validationReporter = ValidationReporter.Factory.getInstance();
// -- preset checkpoints to OK if uncheck
validationReporter.prepareCheckPointReport(context, NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignment_1);
}
public boolean validate(Context context, PassengerStopAssignment stopAssignment, int lineNumber, int columnNumber)
{
boolean result = checkModification(context, NetexStifConstant.PASSENGER_STOP_ASSIGNMENT, stopAssignment, lineNumber, columnNumber);
return check2NeTExSTIFPassengerStopAssignment1(context, stopAssignment, lineNumber, columnNumber) && result;
}
/** 
* <b>Titre</b> :[Netex] Contrôle de l'objet PassengerStopAssignment : complétude
* <p>
* <b>R&eacute;ference Redmine</b> : <a target="_blank" href="https://projects.af83.io/issues/2318">Cartes #2318</a>
* <p>
* <b>Code</b> : 2-NeTExSTIF-PassengerStopAssignment-1
* <p>
* <b>Variables</b> : néant
* <p>
* <b>Prérequis</b> : néant
* <p>
* <b>Prédicat</b> : Les attributs ScheduledStopPointRef et QuayRef doivent être renseignés
* <p>
* <b>Message</b> : {fichier}-Ligne {ligne}-Colonne {Colonne}, l'attribut {attribut requis} de l'objet PassengerStopAssignment {ObjectId} doit être renseigné 
* <p>
* <b>Criticité</b> : error
* <p>
* 
*
* @param context
* @return
*/
public boolean check2NeTExSTIFPassengerStopAssignment1(Context context, PassengerStopAssignment stopAssignment, int lineNumber, int columnNumber) {
boolean result1 = stopAssignment.getScheduledStopPointRef() != null && !stopAssignment.getScheduledStopPointRef().isEmpty();
boolean result2 = stopAssignment.getQuayRef() != null && !stopAssignment.getQuayRef().isEmpty();
if (!result1)
{
ValidationReporter validationReporter = ValidationReporter.Factory.getInstance();
String fileName = (String) context.get(Constant.FILE_NAME);
LineLite line = (LineLite) context.get(Constant.LINE);
DataLocation location = new DataLocation(fileName, lineNumber, columnNumber, line, stopAssignment);
validationReporter.addCheckPointReportError(context, null, NetexCheckPoints.L2_NeTExSTIF_PassengerStopAssignmen
```
<Overlap Ratio: 0.9814424293547026>

---

--- 324 --
Question ID: e4aa5d3572166d942c40e6fc10a5a587137ec1c5
Original Code:
```
@WebServlet("/register")
@MultipartConfig(fileSizeThreshold=1024*1024*10,maxFileSize=1024*1024*10,maxRequestSize=1024*1024*20)
public class RegisterServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		RequestDispatcher requestDispatcher = request.getRequestDispatcher("/register.jsp");
		requestDispatcher.forward(request, response);
	}
	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

		// get request parameters for userID and password
		String email = request.getParameter("email");
		String plainPassword = request.getParameter("password");
		String username = request.getParameter("username");
		String firstname = request.getParameter("firstname");
		String lastname = request.getParameter("lastname");
		
		String locality = request.getParameter("locality");
		String country = request.getParameter("country");
		String lat = request.getParameter("lat");
		String lng = request.getParameter("lng");

		// use bcrypt for password
		String password = BCrypt.hashpw(plainPassword, BCrypt.gensalt(12));    
	    
		MongoConnection mongo = MongoConnection.getInstance();
		MongoDatabase database = mongo.database;
		
		boolean isEmailFound = MongoUtil.searchEmail(email, database);
		
		if (isEmailFound) {
			request.setAttribute("message", "Email already registered, please sign in instead");
			RequestDispatcher requestDispatcher = request.getRequestDispatcher("/login.jsp");
			requestDispatcher.forward(request, response);			
			
		} else {
			ObjectId _id = new ObjectId();

			String avatar = "";
			
			try {
				Part filePart = request.getPart("userAvatar");
				if (filePart.getSize() > 0) {
					avatar = AmazonS3Util.awsUpload(filePart, _id.toString());
				}
			} catch (final Exception e) {
				System.out.println("Upload failed" + e.getMessage());
			}
		    
			Document doc = new Document("_id", _id)
					.append("email", email)
					.append("password", password)
					.append("username", username)
					.append("registered", MiscUtil.nowToString());
			
			if (firstname != null && !firstname.isEmpty()) doc.append("firstname", firstname);
			if (lastname != null && !lastname.isEmpty()) doc.append("lastname", lastname);
			if (avatar != null && !avatar.isEmpty()) doc.append("avatar", avatar);
			
			Document locationDoc = new Document();
			if (locality != null && !locality.isEmpty()) locationDoc.append("locality", locality);
			if (country != null && !country.isEmpty()) locationDoc.append("country", country);
			if (lat != null && !lat.isEmpty()) locationDoc.append("lat", Double.parseDouble(lat));
			if (lng != null && !lng.isEmpty()) locationDoc.append("lng", Double.parseDouble(lng));
			if (!locationDoc.isEmpty()) doc.append("location", locationDoc);
					
			MongoCollection<Document> collection = database.getCollection("users");
			collection.insertOne(doc);

			//get the old session and invalidate
            HttpSession oldSession = request.getSession(false);
            if (oldSession != null) {
                oldSession.invalidate();
            }
			
            //generate a new session
            HttpSession newSession = request.getSession(true);
            
            newSession.setAttribute("username", username);
            newSession.setAttribute("_id", _id);
            
            //setting session to expire
            newSession.setMaxInactiveInterval(15*60);

            Cookie cookie = new Cookie("username", username);
            response.addCookie(cookie);	
            
            response.sendRedirect("app/dashboard");
		}
	}

}
```


Overlapping Code:
```
ster")
@MultipartConfig(fileSizeThreshold=1024*1024*10,maxFileSize=1024*1024*10,maxRequestSize=1024*1024*20)
public class RegisterServlet extends HttpServlet {
private static final long serialVersionUID = 1L;
/**
* @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
*/
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
RequestDispatcher requestDispatcher = request.getRequestDispatcher("/register.jsp");
requestDispatcher.forward(request, response);
}

protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
// get request parameters for userID and password
String email = request.getParameter("email");
String plainPassword = request.getParameter("password");
String username = request.getParameter("username");
String firstname = request.getParameter("firstname");
String lastname = request.getParameter("lastname");

String locality = request.getParameter("locality");
String country = request.getParameter("country");
String lat = request.getParameter("lat");
String lng = request.getParameter("lng");
// use bcrypt for password
String password = BCrypt.hashpw(plainPassword, BCrypt.gensalt(12)); 

MongoConnection mongo = MongoConnection.getInstance();
MongoDatabase database = mongo.database;

boolean isEmailFound = MongoUtil.searchEmail(email, database);

if (isEmailFound) {
request.setAttribute("message", "Email already registered, please sign in instead");
RequestDispatcher requestDispatcher = request.getRequestDispatcher("/login.jsp");
requestDispatcher.forward(request, response); 

} else {
ObjectId _id = new ObjectId();
String avatar = "";

try {
Part filePart = request.getPart("userAvatar");
if (filePart.getSize() > 0) {
avatar = AmazonS3Util.awsUpload(filePart, _id.toString());
}
} catch (final Exception e) {
System.out.println("Upload failed" + e.getMessage());
}

Document doc = new Document("_id", _id)
.append("email", email)
.append("password", password)
.append("username", username)
.append("registered", MiscUtil.nowToString());

if (firstname != null && !firstname.isEmpty()) doc.append("firstname", firstname);
if (lastname != null && !lastname.isEmpty()) doc.append("lastname", lastname);
if (avatar !=
```
<Overlap Ratio: 0.983326207781103>

---

--- 325 --
Question ID: 5a99d48bff937e53c5e5aba849659fa6f1cf86c3
Original Code:
```
public class ClientCtl extends Screen {
    ObservableList<ClientType> typesOfClient;
    private MainScreensController mainScreensController = MainScreensController.getInstance();

    private DataController mDataController = DataController.getInstance();

    @FXML
    private ResourceBundle resources;

    @FXML
    private URL location;

    @FXML
    private TextField ClientCpfField;

    @FXML
    private TextField ClientNameField;

    @FXML
    private TextField ClientEmailField;

    @FXML
    private TextField ClientPhoneField;

    @FXML
    private TextField clientStreetField;

    @FXML
    private TextField clientDistrictField;

    @FXML
    private TextField clientAdressNumberField;

    @FXML
    private TextField clientCityField;

    @FXML
    private ComboBox<State> state;

    @FXML
    private TextField clientCepField;

    @FXML
    private ToggleGroup clientType;

    @FXML
    private RadioButton radioPerson;

    @FXML
    private RadioButton radioCompany;

    @FXML
    private Button btnSaveClient;

    private void insertValidation() {
        ClientCpfField.addEventFilter(KeyEvent.KEY_TYPED, Validation.numericValidation(null));
        ClientPhoneField.addEventFilter(KeyEvent.KEY_TYPED, Validation.numericValidation(null));
        clientCepField.addEventFilter(KeyEvent.KEY_TYPED, Validation.numericValidation(null));
    }

    @FXML
    void SaveClient(ActionEvent event) {
        if(ClientCpfField.getText().length() != 11 && ClientCpfField.getText().length() != 14) {
            Alert dialogoErro = new Alert(Alert.AlertType.ERROR);
            dialogoErro.setTitle("Erro!");
            dialogoErro.setHeaderText("CPF/CNPJ inválido!");
            dialogoErro.setContentText("Digite o CPF ou CNPJ sem pontuação, contendo 11 ou 14 caracteres");
            dialogoErro.showAndWait();
            return;
        }else if(!radioCompany.isSelected() && !radioPerson.isSelected()){
            Alert dialogoErro = new Alert(Alert.AlertType.ERROR);
            dialogoErro.setTitle("Erro!");
            dialogoErro.setHeaderText("Tipo não selecionado");
            dialogoErro.setContentText("Selecione o tipo de pessoa: Física ou Jurídica");
            dialogoErro.showAndWait();
            return;
        }else if(!Validation.isEveryInputFilled(
                ClientCpfField.getText(),
                clientStreetField.getText(),
                clientAdressNumberField.getText(),
                ClientNameField.getText(),
                clientDistrictField.getText(),
                ClientEmailField.getText(),
                clientCityField.getText(),
                ClientPhoneField.getText(),
                clientCepField.getText())){
            Validation.showErrorDialog(
                    "Oooops...",
                    "Informações inválidas",
                    "Parece que há alguma campo sem preencher, volte ao form para validar"
            );
            return;
        }

        //Creating City
        City city = new City();
        city.setCity(clientCityField.getText());
        city.setUf(state.getSelectionModel().getSelectedItem().getUf());
        mDataController.saveObject(city);

        //Creating Address
        Address address = new Address();
        address.setCityByCityId(city);
        address.setStateByStateId(state.getSelectionModel().getSelectedItem());
        address.setDistrict(clientDistrictField.getText());
        address.setPostalCode(clientCepField.getText());
        address.setAddress(clientStreetField.getText());
        address.setAddress2(clientAdressNumberField.getText());
        mDataController.saveObject(address);

        //Saving new

        if(getCurrentClient() == null){
            Client client  = new Client();
            client.setAddressByAddressId(address);
            client.setAddressNumber(clientAdressNumberField.toString());
            client.setDocumentNumber(ClientCpfField.getText());
            client.setName(ClientNameField.getText());
            client.setEmail(ClientEmailField.getText());
            client.setPhone(ClientPhoneField.getText());
            //Verifiyng clientType
            if (clientType.getSelectedToggle() == radioPerson) {
                client.setClientTypeByClientTypeId(typesOfClient.get(0));
            } else
                client.setClientTypeByClientTypeId(typesOfClient.get(1));
            mDataController.saveObject(client);
            callClientsScreen();
        }else{
            getCurrentClient().setAddressByAddressId(address);
            getCurrentClient().setAddressNumber(clientAdressNumberField.toString());
            getCurrentClient().setDocumentNumber(ClientCpfField.getText());
            getCurrentClient().setName(ClientNameField.getText());
            getCurrentClient().setEmail(ClientEmailField.getText());
            getCurrentClient().setPhone(ClientPhoneField.getText());
            //Verifiyng clientType
            if (clientType.getSelectedToggle() == radioPerson) {
                getCurrentClient().setClientTypeByClientTypeId(typesOfClient.get(0));
            } else
                getCurrentClient().setClientTypeByClientTypeId(typesOfClient.get(1));
            mDataController.updateObject(getCurrentClient());
            callClientsScreen();
        }
    }

    @FXML
    void callClientsScreen() {
        super.setCurrentClient(null);
        mainScreensController.showNewMainScreen("/Screens/Clients/clients.fxml");
    }

    public ResourceBundle getResources() {
        return resources;
    }

    public void setResources(ResourceBundle resources) {
        this.resources = resources;
    }

    @FXML
    void initialize() {

        typesOfClient = (ObservableList<ClientType>) mDataController.getAllObjectsOfType(ClientType.class);
        ObservableList<State> states = (ObservableList<State>) DataController.getInstance().getAllObjectsOfType(State.class);
        state.getItems().addAll(states);
        state.getSelectionModel().selectFirst();
        if (typesOfClient.isEmpty()) {
            ClientType pessoaFisica = new ClientType();
            pessoaFisica.setName("Pessoa Física");
            typesOfClient.add(pessoaFisica);
            mDataController.saveObject(pessoaFisica);
            ClientType pessoaJuridica = new ClientType();
            pessoaJuridica.setName("Pessoa Jurídica");
            typesOfClient.add(pessoaJuridica);
            mDataController.saveObject(pessoaJuridica);
        }
        if (super.getCurrentClient() != null) {
            clientCepField.setText(super.getCurrentClient().getAddressByAddressId().getPostalCode());
            clientAdressNumberField.setText(super.getCurrentClient().getAddressByAddressId().getAddress2());
            clientCityField.setText(super.getCurrentClient().getAddressByAddressId().getCityByCityId().getCity());
            ClientCpfField.setText(super.getCurrentClient().getDocumentNumber());
            ClientEmailField.setText(super.getCurrentClient().getEmail());
            clientDistrictField.setText(super.getCurrentClient().getAddressByAddressId().getDistrict());
            ClientNameField.setText(super.getCurrentClient().getName());
            ClientPhoneField.setText(super.getCurrentClient().getPhone());
            clientStreetField.setText(super.getCurrentClient().getAddressByAddressId().getAddress());
        }
        insertValidation();
    }

}
```


Overlapping Code:
```
creen {
ObservableList<ClientType> typesOfClient;
private MainScreensController mainScreensController = MainScreensController.getInstance();
private DataController mDataController = DataController.getInstance();
@FXML
private ResourceBundle resources;
@FXML
private URL location;
@FXML
private TextField ClientCpfField;
@FXML
private TextField ClientNameField;
@FXML
private TextField ClientEmailField;
@FXML
private TextField ClientPhoneField;
@FXML
private TextField clientStreetField;
@FXML
private TextField clientDistrictField;
@FXML
private TextField clientAdressNumberField;
@FXML
private TextField clientCityField;
@FXML
private ComboBox<State> state;
@FXML
private TextField clientCepField;
@FXML
private ToggleGroup clientType;
@FXML
private RadioButton radioPerson;
@FXML
private RadioButton radioCompany;
@FXML
private Button btnSaveClient;
private void insertValidation() {
ClientCpfField.addEventFilter(KeyEvent.KEY_TYPED, Validation.numericValidation(null));
ClientPhoneField.addEventFilter(KeyEvent.KEY_TYPED, Validation.numericValidation(null));
clientCepField.addEventFilter(KeyEvent.KEY_TYPED, Validation.numericValidation(null));
}
@FXML
void SaveClient(ActionEvent event) {
if(ClientCpfField.getText().length() != 11 && ClientCpfField.getText().length() != 14) {
Alert dialogoErro = new Alert(Alert.AlertType.ERROR);
dialogoErro.setTitle("Erro!");
dialogoErro.setHeaderText("CPF/CNPJ inválido!");
dialogoErro.setContentText("Digite o CPF ou CNPJ sem pontuação, contendo 11 ou 14 caracteres");
dialogoErro.showAndWait();
return;
}else if(!radioCompany.isSelected() && !radioPerson.isSelected()){
Alert dialogoErro = new Alert(Alert.AlertType.ERROR);
dialogoErro.setTitle("Erro!");
dialogoErro.setHeaderText("Tipo não selecionado");
dialogoErro.setContentText("Selecione o tipo de pessoa: Física ou Jurídica");
dialogoErro.showAndWait();
return;
}else if(!Validation.isEveryInputFilled(
ClientCpfField.getText(),
clientStreetField.getText(),
clientAdressNumberField.getText(),
Clie
```
<Overlap Ratio: 0.9737098344693281>

---

--- 326 --
Question ID: 22f5e1ec7540c7cdb7c90cb303edde7dfb8d6272
Original Code:
```
public class TrackerListManager extends GuiListManager<Button>
{
    private Button[] buttonItems;

    /**
     * Initialize a new Tracker Manager with a VBox element.
     * Depending on the methods called, this object will manage the items
     * in the vbox.
     * @param vbox The VBox element that is used to display the users.
     */
    public TrackerListManager(VBox vbox) throws Exception
    {
        super(vbox);
    }



    //region GuiListManager implementation

    @Override
    protected Button[] listItems() throws Exception
    {
        // retrieve the tracker data and sort is alphabetically. 
        ArrayList<Tracker> data = TrackerHandler.handler().getAll();
        Collections.sort(data, new TrackerComparator());



        Button[] buttons = new Button[data.size()];

        for (int i = 0; i < data.size(); i++)
        {
            Tracker tr = data.get(i);

            Button button = new Button(tr.getName());
            button.setMaxWidth(Double.MAX_VALUE);
            //button.getStyleClass().add("trackerButton");

            // set button action
            button.setOnAction(event ->
            {
                EditTrackerWindow controller = VistaNavigator.loadVista(VistaNavigator.AppStage.TRACKER_EDIT);
                controller.init(tr);
            });

            buttons[i] = button;
        }

        this.buttonItems = buttons;

        return buttons;
    }

    /**
     * Requests the underlying subclass to dereference the current items.
     */
    @Override
    protected void dereference()
    {
        if (this.buttonItems == null || this.buttonItems.length == 0)
            return;

        for (Button b : this.buttonItems)
        {
            b.setOnAction(null);
        }

        this.buttonItems = null;
    }

    //endregion
}
```


Overlapping Code:
```
ds GuiListManager<Button>
{
private Button[] buttonItems;
/**
* Initialize a new Tracker Manager with a VBox element.
* Depending on the methods called, this object will manage the items
* in the vbox.
* @param vbox The VBox element that is used to display the users.
*/
public TrackerListManager(VBox vbox) throws Exception
{
super(vbox);
}
//region GuiListManager implementation
@Override
protected Button[] listItems() throws Exception
{
// retrieve the tracker data and sort is alphabetically. 
ArrayList<Tracker> data = TrackerHandler.handler().getAll();
Collections.sort(data, new TrackerComparator());
Button[] buttons = new Button[data.size()];
for (int i = 0; i < data.size(); i++)
{
Tracker tr = data.get(i);
Button button = new Button(tr.getName());
button.setMaxWidth(Double.MAX_VALUE);
//button.getStyleClass().add("trackerButton");
// set button action
button.setOnAction(event ->
{
EditTrackerWindow controller = VistaNavigator.loadVista(VistaNavigator.AppStage.TRACKER_EDIT);
controller.init(tr);
});
buttons[i] = button;
}
this.buttonItems = buttons;
return buttons;
}
/**
* Requests the underlying subclass to dereference the current items.
*/
@Override
protected void dereference()
{
if (this.buttonItems == null || this.buttonItems.length == 0)
return;
for (Button b : this.buttonItems)
{
b.setOnAction(null);
}
this.buttonItems = null;
}

```
<Overlap Ratio: 0.964513839602555>

---

--- 327 --
Question ID: cf00a3662ca454725f1bb8553f51158c309dfcfb
Original Code:
```
public class SetPasswordTest extends AbstractPeopleWithSessionBase {

	@Override
	public void testValidSession() throws APIException {
		final Date now = new Date();
		final User theUser = getPrivateUser();
		final Application theApplication = new ApplicationMock(42, "My first application", theUser, now);
		final ApplicationCredentials cred = new ApplicationCredentialsMock("6992873d28d86925325dc52d15d6feec30bb2da5", "59e6060a53ab1be5", theApplication);
		final APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));
		testSetPassword(caller, theUser, generateSession(UserData.getData(theUser), caller));
	}

	@Override
	public void testNoSession() throws APIException {
		final Date now = new Date();
		final User theUser = getPrivateUser();
		final Application theApplication = new ApplicationMock(42, "My first application", theUser, now);
		final ApplicationCredentials cred = new ApplicationCredentialsMock("6992873d28d86925325dc52d15d6feec30bb2da5", "59e6060a53ab1be5", theApplication);
		final APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));
		try {
			testSetPassword(caller, theUser, null);
		} finally {
			Assert.assertFalse(theUser.checkPasswordPlain("newPass"));
		}
	}

	@Override
	public void testOtherUserSession() throws APIException {
		final Date now = new Date();
		final User theUser = getPrivateUser();
		final Application theApplication = new ApplicationMock(42, "My first application", theUser, now);
		final ApplicationCredentials cred = new ApplicationCredentialsMock("6992873d28d86925325dc52d15d6feec30bb2da5", "59e6060a53ab1be5", theApplication);
		final APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));
		try {
			testSetPassword(caller, theUser, generateSessionAlterUser(caller));
		} finally {
			Assert.assertFalse(theUser.checkPasswordPlain("newPass"));
		}
	}

	@Override
	public void testOtherApplicationSession() throws APIException {
		final Date now = new Date();
		final User theUser = getPrivateUser();
		final Application theApplication = new ApplicationMock(42, "My first application", theUser, now);
		final ApplicationCredentials cred = new ApplicationCredentialsMock("6992873d28d86925325dc52d15d6feec30bb2da5", "59e6060a53ab1be5", theApplication);
		final APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));
		try {
			testSetPassword(caller, theUser, generateSessionAlterApplication(UserData.getData(theUser)));
		} finally {
			Assert.assertFalse(theUser.checkPasswordPlain("newPass"));
		}
	}

	public void testSetPassword(APICaller inCaller, User inUser, String inSessionId) throws APIException {
		final Action theAction = new SetPassword();
		final Map<String, Object> theParams = new HashMap<String, Object>();
		final UserData theUserData = UserData.getData(inUser);
		final String userId = theUserData.getApiId(inCaller);

		theParams.put(ActionParam.MAIN_PARAM_KEY, userId);
		theParams.put("old_password", "12345");
		theParams.put("new_password", "newPass");
		setSessionParam(theParams, inSessionId);

		final ActionParam theActionParam = new ActionParam(inCaller, theParams);
		final Object theResult = theAction.processRequest(theActionParam);

		Assert.assertNull(theResult);
		Assert.assertTrue(inUser.checkPasswordPlain("newPass"));

		theParams.put(ActionParam.MAIN_PARAM_KEY, userId);
		theParams.put("old_password", "newPass");
		theParams.put("new_password", "12345");
		setSessionParam(theParams, inSessionId);

		final ActionParam theActionParam2 = new ActionParam(inCaller, theParams);
		final Object theResult2 = theAction.processRequest(theActionParam2);

		Assert.assertNull(theResult2);
		Assert.assertTrue(inUser.checkPasswordPlain("12345"));
	}
}
```


Overlapping Code:
```
ordTest extends AbstractPeopleWithSessionBase {
@Override
public void testValidSession() throws APIException {
final Date now = new Date();
final User theUser = getPrivateUser();
final Application theApplication = new ApplicationMock(42, "My first application", theUser, now);
final ApplicationCredentials cred = new ApplicationCredentialsMock("6992873d28d86925325dc52d15d6feec30bb2da5", "59e6060a53ab1be5", theApplication);
final APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));
testSetPassword(caller, theUser, generateSession(UserData.getData(theUser), caller));
}
@Override
public void testNoSession() throws APIException {
final Date now = new Date();
final User theUser = getPrivateUser();
final Application theApplication = new ApplicationMock(42, "My first application", theUser, now);
final ApplicationCredentials cred = new ApplicationCredentialsMock("6992873d28d86925325dc52d15d6feec30bb2da5", "59e6060a53ab1be5", theApplication);
final APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));
try {
testSetPassword(caller, theUser, null);
} finally {
Assert.assertFalse(theUser.checkPasswor}
@Override
public void testOtherUserSession() throws APIException {
final Date now = new Date();
final User theUser = getPrivateUser();
final Application theApplication = new ApplicationMock(42, "My first application", theUser, now);
final ApplicationCredentials cred = new ApplicationCredentialsMock("6992873d28d86925325dc52d15d6feec30bb2da5", "59e6060a53ab1be5", theApplication);
final APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));
try {
testSetPassword(caller, theUser, generateSessionAlterUser(caller));
} finally {
Assert.assertFalse(theUser.checkPassworverride
public void testOtherApplicationSession() throws APIException {
final Date now = new Date();
final User theUser = getPrivateUser();
final Application theApplication = new ApplicationMock(42, "My first application", theUser, now);
final ApplicationCredentials cred = new ApplicationCredentialsMock("6992873d28d86925325dc52d15d6feec30bb2da5", "59e6060a53ab1be5", theApplication);
final APICaller caller = new ApplicationAPICaller(ApplicationCredentialsData.getData(cred));
try {
testSetPassword(caller, theUser, generateSessionAlterApplication(UserData.getData(t
```
<Overlap Ratio: 0.9693327807708247>

---

--- 328 --
Question ID: 3b1f08a76ee36b53daeaae12d968617916543204
Original Code:
```
public class Prefix extends Affix<String> {

    public Prefix() {
        super();
    }

    public Prefix(List<String> actions) {
        super(actions);
    }

    public Prefix(Affix<String> affix) {
        super(affix);
    }

    public Prefix(Prefix other) { super(other);}

    /**
     * @param action a string under analysis
     * @param prefix a prefix
     * @param actions the sequence of actions
     * @return true if given action is coherent with the given prefix and the sequence, false
     * otherwise
     */
    public static boolean checkActionCoherency(String action, List<String> actions,
                                                  Prefix prefix) {
        // FIXME: do not use sting comparison with join!
        //return (prefix!=null) && StringUtils.join(actions, "").startsWith(
        //        StringUtils.join(prefix.toList(), "") + action);

        Prefix tmpPref = new Prefix(prefix);
        tmpPref.add(action);
        return (prefix!=null) && Collections.indexOfSubList(actions, tmpPref.toList())==0;



    }
    // TODO: produce new methods which is not static (I think Prefix can be this, instead of a
    // parameter)
}
```


Overlapping Code:
```
efix extends Affix<String> {
public Prefix() {
super();
}
public Prefix(List<String> actions) {
super(actions);
}
public Prefix(Affix<String> affix) {
super(affix);
}
public Prefix(Prefix other) { super(other);}
/**
* @param action a string under analysis
* @param prefix a prefix
* @param actions the sequence of actions
* @return true if given action is coherent with the given prefix and the sequence, false
* otherwise
*/
public static boolean checkActionCoherency(String action, List<String> actions,
Prefix prefix) {
// FIXME: do not use sting comparison with join!
//return (prefix!=null) && StringUtils.join(actions, "").startsWith(
// StringUtils.join(prefix.toList(), "") + action);
Prefix tmpPref = new Prefix(prefix);
tmpPref.add(action);
return (prefix!=null) && Collections.indexOfSubList(actions, tmpPref.toList())==0;
}
// TODO: produce new methods which is not static (I think Prefix
```
<Overlap Ratio: 0.9404388714733543>

---

--- 329 --
Question ID: 9943ca665a00c0b2e14f0beb32dcbabf2653cdcd
Original Code:
```
@Service
@Transactional
public class WikidataItemService {
    private static final String TYPE = "item";


    public List<WikidataItem> searchWikidataItems(String keyword, String language)
            throws MediaWikiApiErrorException {
        WikibaseDataFetcher wbdf = WikibaseDataFetcher.getWikidataDataFetcher();

        WbGetEntitiesSearchData criteria = new WbGetEntitiesSearchData();
        criteria.type = TYPE;
        criteria.search = keyword;
        criteria.language = language;
        List<WbSearchEntitiesResult> searchResults = wbdf.searchEntities(criteria);

        List<WikidataItem> results = new ArrayList<>();
        searchResults.stream().forEach(searchResult -> results
                .add(new WikidataItem(searchResult.getTitle(), searchResult.getLabel(), searchResult.getDescription())));
        return results;
    }
}
```


Overlapping Code:
```
vice
@Transactional
public class WikidataItemService {
private static final String TYPE = "item";
public List<WikidataItem> searchWikidataItems(String keyword, String language)
throws MediaWikiApiErrorException {
WikibaseDataFetcher wbdf = WikibaseDataFetcher.getWikidataDataFetcher();
WbGetEntitiesSearchData criteria = new WbGetEntitiesSearchData();
criteria.type = TYPE;
criteria.search = keyword;
criteria.language = language;
List<WbSearchEntitiesResult> searchResults = wbdf.searchEntities(criteria);
List<WikidataItem> results = new ArrayList<>();
searchResults.stream().forEach(searchResult -> results
.add(new WikidataItem(searchResult.getTitle(), searchResult.getLabel(), searchResult.getDes
```
<Overlap Ratio: 0.9485791610284168>

---

--- 330 --
Question ID: 099e9c64012edec58e7e7bf17462aa6cdfba0a14
Original Code:
```
public class GcmRefreshJob extends ContextJob implements InjectableType {

  private static final String TAG = GcmRefreshJob.class.getSimpleName();

  public static final String REGISTRATION_ID = "312334754206";

  @Inject transient SignalServiceAccountManager textSecureAccountManager;
  @Inject transient RedPhoneAccountManager      redPhoneAccountManager;

  public GcmRefreshJob(Context context) {
    super(context, JobParameters.newBuilder().withRequirement(new NetworkRequirement(context)).create());
  }

  @Override
  public void onAdded() {}

  @Override
  public void onRun() throws Exception {
    String registrationId = TextSecurePreferences.getGcmRegistrationId(context);

    if (registrationId == null) {
      Log.w(TAG, "GCM registrationId expired, reregistering...");
      int result = GooglePlayServicesUtil.isGooglePlayServicesAvailable(context);

      if (result != ConnectionResult.SUCCESS) {
        notifyGcmFailure();
      } else {
        String gcmId = GoogleCloudMessaging.getInstance(context).register(REGISTRATION_ID);
        textSecureAccountManager.setGcmId(Optional.of(gcmId));

        try {
          redPhoneAccountManager.setGcmId(Optional.of(gcmId));
        } catch (UnauthorizedException e) {
          Log.w(TAG, e);
        }

        TextSecurePreferences.setGcmRegistrationId(context, gcmId);
        TextSecurePreferences.setWebsocketRegistered(context, true);
      }
    }
  }

  @Override
  public void onCanceled() {
    Log.w(TAG, "GCM reregistration failed after retry attempt exhaustion!");
  }

  @Override
  public boolean onShouldRetry(Exception throwable) {
    if (throwable instanceof NonSuccessfulResponseCodeException) return false;
    return true;
  }

  private void notifyGcmFailure() {
    Intent                     intent        = new Intent(context, PlayServicesProblemActivity.class);
    PendingIntent              pendingIntent = PendingIntent.getActivity(context, 1122, intent, PendingIntent.FLAG_CANCEL_CURRENT);
    NotificationCompat.Builder builder       = new NotificationCompat.Builder(context);

    builder.setSmallIcon(R.drawable.icon_notification);
    builder.setLargeIcon(BitmapFactory.decodeResource(context.getResources(),
                                                      R.drawable.ic_action_warning_red));
    builder.setContentTitle(context.getString(R.string.GcmRefreshJob_Permanent_Signal_communication_failure));
    builder.setContentText(context.getString(R.string.GcmRefreshJob_Signal_was_unable_to_register_with_Google_Play_Services));
    builder.setTicker(context.getString(R.string.GcmRefreshJob_Permanent_Signal_communication_failure));
    builder.setVibrate(new long[] {0, 1000});
    builder.setContentIntent(pendingIntent);

    ((NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE))
        .notify(12, builder.build());
  }

}
```


Overlapping Code:
```
 extends ContextJob implements InjectableType {
private static final String TAG = GcmRefreshJob.class.getSimpleName();
public static final String REGISTRATION_ID = "312334754206";
@Inject transient SignalServiceAccountManager textSecureAccountManager;
@Inject transient RedPhoneAccountManager redPhoneAccountManager;
public GcmRefreshJob(Context context) {
super(context, JobParameters.newBuilder().withRequirement(new NetworkRequirement(context)).create());
}
@Override
public void onAdded() {}
@Override
public void onRun() throws Exception {
String registrationId = TextSecurePreferences.getGcmRegistrationId(context);
if (registrationId == null) {
Log.w(TAG, "GCM registrationId expired, reregistering...");
int result = GooglePlayServicesUtil.isGooglePlayServicesAvailable(context);
if (result != ConnectionResult.SUCCESS) {
notifyGcmFailure();
} else {
String gcmId = GoogleCloudMessaging.getInstance(context).register(REGISTRATION_ID);
textSecureAccountManager.setGcmId(Optional.of(gcmId));
try {
redPhoneAccountManager.setGcmId(Optional.of(gcmId));
} catch (UnauthorizedException e) {
Log.w(TAG, e);
}
TextSecurePreferences.setGcmRegistrationId(context, gcmId);
TextSecurePreferences.setWebsocketRegistered(context, true);
}
}
}
@Override
public void onCanceled() {
Log.w(TAG, "GCM reregistration failed after retry attempt exhaustion!");
}
@Override
public boolean onShouldRetry(Exception throwable) {
if (throwable instanceof NonSuccessfulResponseCodeException) return false;
return true;
}
private void notifyGcmFailure() {
Intent intent = new Intent(context, PlayServicesProblemActivity.class);
PendingIntent pendingIntent = PendingIntent.getActivity(context, 1122, intent, PendingIntent.FLAG_CANCEL_CURRENT);
NotificationCompat.Builder builder = new NotificationCompat.Builder(context);
builder.setSmallIcon(R.drawable.icon_notification);
builder.setLargeIcon(BitmapFactory.decodeResource(context.getResources(),
R.drawable.ic_action_warning_red));
builder.setContentTitle(context.getString(R.string.GcmRefreshJob_Permanent_Signal_communication_failure));
builder.setContentText(context.getString(R.string.GcmRefreshJob_Signal_
```
<Overlap Ratio: 0.984360625574977>

---

--- 331 --
Question ID: 1a2b353b463480ba065a12236116152940eaf6a6
Original Code:
```
public class JweRsaDeserializer implements JweDeserializer {

    private Serdes serdes;
    private Base64.Decoder decoder;
    private PrivateKeyTranslator privateKeyTranslator;
    private CipherRSAFactory cipherRSAFactory;
    private CipherSymmetricFactory cipherSymmetricFactory;

    public JweRsaDeserializer(Serdes serdes, Base64.Decoder decoder, PrivateKeyTranslator privateKeyTranslator, CipherRSAFactory cipherRSAFactory, CipherSymmetricFactory cipherSymmetricFactory) {
        this.serdes = serdes;
        this.decoder = decoder;
        this.privateKeyTranslator = privateKeyTranslator;
        this.cipherRSAFactory = cipherRSAFactory;
        this.cipherSymmetricFactory = cipherSymmetricFactory;
    }

    public JWE stringToJWE(String compactJWE, Key key) throws JsonToJwtException, DecryptException, CipherException, KeyException {
        String[] jweParts = compactJWE.split(JWT_SPLITTER);
        byte[] protectedHeader = decoder.decode(jweParts[0]);
        byte[] encryptedKey = decoder.decode(jweParts[1]);
        byte[] initVector = decoder.decode(jweParts[2]);
        byte[] cipherText = decoder.decode(jweParts[3]);
        byte[] authenticationTag = decoder.decode(jweParts[4]);

        Header header;
        try {
            header = serdes.jsonBytesTo(protectedHeader, Header.class);
        } catch (JsonException e) {
            throw new JsonToJwtException(COMPACT_JWE_INVALID, e);
        }

        RSAKeyPair keyPair = (RSAKeyPair) key;
        RSAPrivateCrtKey jdkKey;
        try {
            jdkKey = privateKeyTranslator.to(keyPair);
        } catch (PrivateKeyException e) {
            throw new KeyException("", e);
        }

        Cipher rsaDecryptCipher;
        try {
            rsaDecryptCipher = cipherRSAFactory.forDecrypt(Transformation.RSA_OAEP, jdkKey);
        } catch (CipherException e) {
            throw e;
        }

        byte[] cek;
        try {
            cek = rsaDecryptCipher.doFinal(encryptedKey);
        } catch (IllegalBlockSizeException e) {
            throw new DecryptException(COULD_NOT_DECRYPT_ENCRYPTED_KEY, e);
        } catch (BadPaddingException e) {
            throw new DecryptException(COULD_NOT_DECRYPT_ENCRYPTED_KEY, e);
        }

        byte[] aad = jweParts[0].getBytes(StandardCharsets.US_ASCII);

        Cipher symmetricCipher;
        try {
            symmetricCipher = cipherSymmetricFactory.forDecrypt(Transformation.AES_GCM_NO_PADDING, cek, initVector, aad);
        } catch (CipherException e) {
            throw e;
        }

        byte[] cipherTextWithAuthTag = cipherTextWithAuthTag(cipherText, authenticationTag);

        byte[] payload;
        try {
            payload = symmetricCipher.doFinal(cipherTextWithAuthTag);
        } catch (IllegalBlockSizeException e) {
            throw new DecryptException(COULD_NOT_DECRYPT_CIPHER_TEXT, e);
        } catch (BadPaddingException e) {
            throw new DecryptException(COULD_NOT_DECRYPT_CIPHER_TEXT, e);
        }

        return new JWE(header, payload, cek, initVector, authenticationTag);
    }
}
```


Overlapping Code:
```
 implements JweDeserializer {
private Serdes serdes;
private Base64.Decoder decoder;
private PrivateKeyTranslator privateKeyTranslator;
private CipherRSAFactory cipherRSAFactory;
private CipherSymmetricFactory cipherSymmetricFactory;
public JweRsaDeserializer(Serdes serdes, Base64.Decoder decoder, PrivateKeyTranslator privateKeyTranslator, CipherRSAFactory cipherRSAFactory, CipherSymmetricFactory cipherSymmetricFactory) {
this.serdes = serdes;
this.decoder = decoder;
this.privateKeyTranslator = privateKeyTranslator;
this.cipherRSAFactory = cipherRSAFactory;
this.cipherSymmetricFactory = cipherSymmetricFactory;
}
public JWE stringToJWE(String compactJWE, Key key) throws JsonToJwtException, DecryptException, CipherException, KeyException {
String[] jweParts = compactJWE.split(JWT_SPLITTER);
byte[] protectedHeader = decoder.decode(jweParts[0]);
byte[] encryptedKey = decoder.decode(jweParts[1]);
byte[] initVector = decoder.decode(jweParts[2]);
byte[] cipherText = decoder.decode(jweParts[3]);
byte[] authenticationTag = decoder.decode(jweParts[4]);
Header header;
try {
header = serdes.jsonBytesTo(protectedHeader, Header.class);
} catch (JsonException e) {
throw new JsonToJwtException(COMPACT_JWE_INVALID, e);
}
RSAKeyPair keyPair = (RSAKeyPair) key;
RSAPrivateCrtKey jdkKey;
try {
jdkKey = privateKeyTranslator.to(keyPair);
} catch (PrivateKeyException e) {
throw new KeyException("", e);
}
Cipher rsaDecryptCipher;
try {
rsaDecryptCipher = cipherRSAFactory.forDecrypt(Transformation.RSA_OAEP, jdkKey);
} catch (CipherException e) {
throw e;
}
byte[] cek;
try {
cek = rsaDecryptCipher.doFinal(encryptedKey);
} catch (IllegalBlockSizeException e) {
throw new DecryptException(COULD_NOT_DECRYPT_ENCRYPTED_KEY, e);
} catch (BadPaddingException e) {
throw new DecryptException(COULD_NOT_DECRYPT_ENCRYPTED_KEY, e);
}
byte[] aad = jweParts[0].getBytes(StandardCharsets.US_ASCII);
Cipher symmetricCipher;
try {
symmetricCipher = cipherSymmetricFactory.forDecrypt(Transformation.AES_GCM_NO_PADDI
```
<Overlap Ratio: 0.9643201542912246>

---

--- 332 --
Question ID: bc60dbb1269927fe1301f18bc2cc94ee85ca2703
Original Code:
```
public class Example {
    protected boolean less(Comparable x, Comparable y) {
        return x.compareTo(y) < 0;
    }

    protected void exch(Comparable[] arr, int x, int y) {
        Comparable temp = arr[x];
        arr[x] = arr[y];
        arr[y] = temp;
    }

    public boolean isSorted(Comparable[] arr) {
        for (int i = 1; i < arr.length; ++i)
            if (arr[i - 1].compareTo(arr[i]) > 0) return false;
        return true;
    }

    public void show(Comparable[] arr) {
        for (int i = 0; i < arr.length; ++i)
            System.out.print(arr[i]+" ");
        System.out.println();
    }


    public  void sort(Comparable[] arr) {
        // remain to impl
    }


}
```


Overlapping Code:
```
lean less(Comparable x, Comparable y) {
return x.compareTo(y) < 0;
}
protected void exch(Comparable[] arr, int x, int y) {
Comparable temp = arr[x];
arr[x] = arr[y];
arr[y] = temp;
}
public boolean isSorted(Comparable[] arr) {
for (int i = 1; i < arr.length; ++i)
if (arr[i - 1].compareTo(arr[i]) > 0) return false;
return true;
}
public void show(Comparable[] arr) {
for (int i = 0; i < arr.length; ++i)
System.out.print(arr[i]+" ");
System.out.println();
}
public void sort(Comparable[] arr) {
// remain to imp
```
<Overlap Ratio: 0.9258589511754068>

---

--- 333 --
Question ID: 1243e39f474919a5cd4c43b9d72ec532c1c5600f
Original Code:
```
public class PacketDescription extends LocatedPacket<PacketDescription>{
    private byte[] types;
    private Object[] values;
    private NBTTagCompound extraData;

    public PacketDescription(){}

    public PacketDescription(TileBase te){
        super(te.xCoord, te.yCoord, te.zCoord);
        values = new Object[te.getDescriptionFields().size()];
        types = new byte[values.length];
        for(int i = 0; i < values.length; i++) {
            values[i] = te.getDescriptionFields().get(i).getValue();
            types[i] = PacketCUpdateGui.getType(te.getDescriptionFields().get(i));
        }
        extraData = new NBTTagCompound();
        te.writeToPacketNBT(extraData);
    }

    @Override
    public void toBytes(ByteBuf buf){
        super.toBytes(buf);
        buf.writeInt(values.length);
        for(int i = 0; i < types.length; i++) {
            buf.writeByte(types[i]);
            PacketCUpdateGui.writeField(buf, values[i], types[i]);
        }
        ByteBufUtils.writeTag(buf, extraData);
    }

    @Override
    public void fromBytes(ByteBuf buf){
        super.fromBytes(buf);
        int dataAmount = buf.readInt();
        types = new byte[dataAmount];
        values = new Object[dataAmount];
        for(int i = 0; i < dataAmount; i++) {
            types[i] = buf.readByte();
            values[i] = PacketCUpdateGui.readField(buf, types[i]);
        }
        extraData = ByteBufUtils.readTag(buf);
    }

    @Override
    public void handleClientSide(EntityPlayer player){
        TileEntity te = getTileEntity(player.worldObj);
        if(te instanceof TileBase) {
            List<SyncedField> descFields = ((TileBase)te).getDescriptionFields();
            if(descFields != null && descFields.size() == types.length) {
                for(int i = 0; i < descFields.size(); i++) {
                    descFields.get(i).setValue(values[i]);
                }
            }
            ((TileBase)te).readFromPacketNBT(extraData);
        }
    }

    @Override
    public void handleServerSide(EntityPlayer player){

    }

}
```


Overlapping Code:
```
ends LocatedPacket<PacketDescription>{
private byte[] types;
private Object[] values;
private NBTTagCompound extraData;
public PacketDescription(){}
public PacketDescription(TileBase te){
super(te.xCoord, te.yCoord, te.zCoord);
values = new Object[te.getDescriptionFields().size()];
types = new byte[values.length];
for(int i = 0; i < values.length; i++) {
values[i] = te.getDescriptionFields().get(i).getValue();
types[i] = PacketCUpdateGui.getType(te.getDescriptionFields().get(i));
}
extraData = new NBTTagCompound();
te.writeToPacketNBT(extraData);
}
@Override
public void toBytes(ByteBuf buf){
super.toBytes(buf);
buf.writeInt(values.length);
for(int i = 0; i < types.length; i++) {
buf.writeByte(types[i]);
PacketCUpdateGui.writeField(buf, values[i], types[i]);
}
ByteBufUtils.writeTag(buf, extraData);
}
@Override
public void fromBytes(ByteBuf buf){
super.fromBytes(buf);
int dataAmount = buf.readInt();
types = new byte[dataAmount];
values = new Object[dataAmount];
for(int i = 0; i < dataAmount; i++) {
types[i] = buf.readByte();
values[i] = PacketCUpdateGui.readField(buf, types[i]);
}
extraData = ByteBufUtils.readTag(buf);
}
@Override
public void handleClientSide(EntityPlayer player){
TileEntity te = getTileEntity(player.worldObj);
if(te instanceof TileBase) {
List<SyncedField> descFields = ((TileBase)te).getDescriptionFields();
if(descFields != null && descFields.size() == types.length) {
for(int i = 0; i < descFields.size(); i++) {
descFields.get(i).setValue(values[i]);
}
}
((TileBase)te).readFromPacketNBT(extraData);
}
}
@Override
public void handleServerSide(EntityPlayer player)
```
<Overlap Ratio: 0.9762484774665042>

---

--- 334 --
Question ID: ac04333552423583d19e2ad39e3d2497b4036642
Original Code:
```
public class LoanerDescription {
    private final Name itemName;
    private final Name loanerName;
    private final Quantity quantity;

    public LoanerDescription(Name itemName, Name loanerName, Quantity quantity) {
        requireAllNonNull(itemName, loanerName, quantity);
        this.itemName = itemName;
        this.loanerName = loanerName;
        this.quantity = quantity;
    }
    public LoanerDescription(LoanerDescription loaner) {
        itemName = loaner.getItemName();
        loanerName = loaner.getLoanerName();
        quantity = loaner.getQuantity();
    }
    public Name getItemName() {
        return itemName;
    }

    public Quantity getQuantity() {
        return quantity;
    }
    public Name getLoanerName() {
        return loanerName;
    }
    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getLoanerName())
                .append(" loanerName: ")
                .append(getLoanerName())
                .append(" itemName: ")
                .append(getItemName())
                .append(" Quantity: ")
                .append(getQuantity());
        return builder.toString();
    }
}
```


Overlapping Code:
```
tion {
private final Name itemName;
private final Name loanerName;
private final Quantity quantity;
public LoanerDescription(Name itemName, Name loanerName, Quantity quantity) {
requireAllNonNull(itemName, loanerName, quantity);
this.itemName = itemName;
this.loanerName = loanerName;
this.quantity = quantity;
}
public LoanerDescription(LoanerDescription loaner) {
itemName = loaner.getItemName();
loanerName = loaner.getLoanerName();
quantity = loaner.getQuantity();
}
public Name getItemName() {
return itemName;
}
public Quantity getQuantity() {
return quantity;
}
public Name getLoanerName() {
return loanerName;
}
@Override
public String toString() {
final StringBuilder builder = new StringBuilder();
builder.append(getLoanerName())
.append(" loanerName: ")
.append(getLoanerName())
.append(" itemName: ")
.append(getItemName())
.append(" Quantity: ")
.append(getQuantity());
return builder.toStrin
```
<Overlap Ratio: 0.9637912673056444>

---

--- 335 --
Question ID: 003bff82f46166c3f5ea8b56bd51cf687810f60a
Original Code:
```
@Entity
@Table(name = "coordinador")
@XmlRootElement
@NamedQueries({
    @NamedQuery(name = "Coordinador.findAll", query = "SELECT c FROM Coordinador c"),
    @NamedQuery(name = "Coordinador.findByCooIdentificador", query = "SELECT c FROM Coordinador c WHERE c.cooIdentificador = :cooIdentificador"),
    @NamedQuery(name = "Coordinador.findByCooNombre", query = "SELECT c FROM Coordinador c WHERE c.cooNombre = :cooNombre"),
    @NamedQuery(name = "Coordinador.findByCooContrasena", query = "SELECT c FROM Coordinador c WHERE c.cooContrasena = :cooContrasena"),
    @NamedQuery(name = "Coordinador.findByCooCorreo", query = "SELECT c FROM Coordinador c WHERE c.cooCorreo = :cooCorreo"),
    @NamedQuery(name = "Coordinador.findByCooUsuario", query = "SELECT c FROM Coordinador c WHERE c.cooUsuario = :cooUsuario")})
public class Coordinador implements Serializable {

    @JoinColumn(name = "usuario_id", referencedColumnName = "id")
    @ManyToOne(optional = false)
    private Usuario usuarioId;

    // Versión de la base de datos
    private static final long serialVersionUID = 1L;
    // Clave identificadora del coordinador
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Basic(optional = false)
    @Column(name = "coo_identificador")
    private Integer cooIdentificador;
    // Nombre del coordinador
    @Size(max = 45)
    @Column(name = "coo_nombre")
    private String cooNombre;
    // Contraseña del coordinador
    @Size(max = 40)
    @Column(name = "coo_contrasena")
    private String cooContrasena;
    // Correo del coordinador
    @Size(max = 30)
    @Column(name = "coo_correo")
    private String cooCorreo;
    // Usuario del coordinador
    @Size(max = 20)
    @Column(name = "coo_usuario")
    private String cooUsuario;   
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "coordinador")
    private List<Doctorado> doctoradoList;

    /* Coordinador */
    public Coordinador() {
    }

    public Coordinador(Integer cooIdentificador) {
        this.cooIdentificador = cooIdentificador;
    }

    /* Getters y Setters */
    public Integer getCooIdentificador() {
        return cooIdentificador;
    }

    public void setCooIdentificador(Integer cooIdentificador) {
        this.cooIdentificador = cooIdentificador;
    }

    public String getCooNombre() {
        return cooNombre;
    }

    public void setCooNombre(String cooNombre) {
        this.cooNombre = cooNombre;
    }

    public String getCooContrasena() {
        return cooContrasena;
    }

    public void setCooContrasena(String cooContrasena) {
        this.cooContrasena = cooContrasena;
    }

    public String getCooCorreo() {
        return cooCorreo;
    }

    public void setCooCorreo(String cooCorreo) {
        this.cooCorreo = cooCorreo;
    }

    public String getCooUsuario() {
        return cooUsuario;
    }

    public void setCooUsuario(String cooUsuario) {
        this.cooUsuario = cooUsuario;
    }

    @XmlTransient
    public List<Doctorado> getDoctoradoList() {
        return doctoradoList;
    }

    public void setDoctoradoList(List<Doctorado> doctoradoList) {
        this.doctoradoList = doctoradoList;
    }
    
    public Usuario getUsuarioId() {
        return usuarioId;
    }

    public void setUsuarioId(Usuario usuarioId) {
        this.usuarioId = usuarioId;
    }

    @Override
    public int hashCode() {
        int hash = 0;
        hash += (cooIdentificador != null ? cooIdentificador.hashCode() : 0);
        return hash;
    }

    @Override
    public boolean equals(Object object) {
        // TODO: Warning - this method won't work in the case the id fields are not set
        if (!(object instanceof Coordinador)) {
            return false;
        }
        Coordinador other = (Coordinador) object;
        if ((this.cooIdentificador == null && other.cooIdentificador != null) || (this.cooIdentificador != null && !this.cooIdentificador.equals(other.cooIdentificador))) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return "co.unicauca.proyectobase.entidades.Coordinador[ cooIdentificador=" + cooIdentificador + " ]";
    }    
}
```


Overlapping Code:
```
dor")
@XmlRootElement
@NamedQueries({
@NamedQuery(name = "Coordinador.findAll", query = "SELECT c FROM Coordinador c"),
@NamedQuery(name = "Coordinador.findByCooIdentificador", query = "SELECT c FROM Coordinador c WHERE c.cooIdentificador = :cooIdentificador"),
@NamedQuery(name = "Coordinador.findByCooNombre", query = "SELECT c FROM Coordinador c WHERE c.cooNombre = :cooNombre"),
@NamedQuery(name = "Coordinador.findByCooContrasena", query = "SELECT c FROM Coordinador c WHERE c.cooContrasena = :cooContrasena"),
@NamedQuery(name = "Coordinador.findByCooCorreo", query = "SELECT c FROM Coordinador c WHERE c.cooCorreo = :cooCorreo"),
@NamedQuery(name = "Coordinador.findByCooUsuario", query = "SELECT c FROM Coordinador c WHERE c.cooUsuario = :cooUsuario")})
public class Coordinador implements Serializable {
@JoinColumn(name = "usuario_id", referencedColumnName = "id")
@ManyToOne(optional = false)
private Usuario usuarioId;
// Versión de la base de datos
private static final long serialVersionUID = 1L;
// Clave identificadora del coordinador
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Basic(optional = false)
@Column(name = "coo_identificador")
private Integer cooIdentificador;
// Nombre del coordinador
@Size(max = 45)
@Column(name = "coo_nombre")
private String cooNombre;
// Contraseña del coordinador
@Size(max = 40)
@Column(name = "coo_contrasena")
private String cooContrasena;
// Correo del coordinador
@Size(max = 30)
@Column(name = "coo_correo")
private String cooCorreo;
// Usuario del coordinador
@Size(max = 20)
@Column(name = "coo_usuario")
private String cooUsuario; 
@OneToMany(cascade = CascadeType.ALL, mappedBy = "coordinador")
private List<Doctorado> doctoradoList;
/* Coordinador */
public Coordinador() {
}
public Coordinador(Integer cooIdentificador) {
this.cooIdentificador = cooIdentificador;
}
/* Getters y Setters */
public Integer getCooIdentificador() {
return cooIdentificador;
}
public void setCooIdentificador(Integer cooIdentificador) {
this.cooIdentificador = cooIdentificador;
}
public String getCooNombre() {
return cooNombre;
}
public void setCooNombre(String cooNombre) {
this.cooNombre = cooNombre;
}
```
<Overlap Ratio: 0.9651785714285714>

---

--- 336 --
Question ID: def6ac634f68c6299a28539e50e3d4d70e42a1a5
Original Code:
```
public final class JsonNumberValue extends AbstractJsonValue {
	private final Number value;

	public JsonNumberValue(Number value) {
		this.value = notNull(value, "value");
	}

	@Override
	public Optional<JsonNumberValue> isNumber() {
		return Optional.of(this);
	}

	public Number numberValue() {
		return value;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((value == null) ? 0 : value.hashCode());
		return result;
	}

	@Override
	protected boolean equalsJsonValue(JsonValue rhs) {
		return rhs.isNumber()
				.filter(this::equalsJsonNumberValue)
				.isPresent();
	}

	private boolean equalsJsonNumberValue(JsonNumberValue cand) {
		return cand.numberValue().equals(numberValue());
	}

	@Override
	public boolean isEmpty() {
		return false;
	}

	@Override
	public String toString() {
		return ToString.of(this)
				.with("value", value)
				.toString();
	}
}
```


Overlapping Code:
```
lass JsonNumberValue extends AbstractJsonValue {
private final Number value;
public JsonNumberValue(Number value) {
this.value = notNull(value, "value");
}
@Override
public Optional<JsonNumberValue> isNumber() {
return Optional.of(this);
}
public Number numberValue() {
return value;
}
@Override
public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + ((value == null) ? 0 : value.hashCode());
return result;
}
@Override
protected boolean equalsJsonValue(JsonValue rhs) {
return rhs.isNumber()
.filter(this::equalsJsonNumberValue)
.isPresent();
}
private boolean equalsJsonNumberValue(JsonNumberValue cand) {
return cand.numberValue().equals(numberValue());
}
@Override
public boolean isEmpty() {
return false;
}
@Override
public String toString() {
return ToString.of(this)
.with("value", value)
.toSt
```
<Overlap Ratio: 0.9708963911525029>

---

--- 337 --
Question ID: ee3c24d43bc9e3d5e754f9cdab0e10acb7cf17f0
Original Code:
```
public class AutoIntake extends Command {
    private double speed;

    private final int DONE_COUNT_MAX = 50;
    private int currentDoneCount = 0;

    private Command blinkLimelight = new BlinkLimelight(2);
    private Command JitterIntake = new JitterIntake(1);

    public AutoIntake(double speed) {
        this.speed = speed;
    }

    public AutoIntake(double speed, double timeout) {
        super(timeout);
        this.speed = speed;
        requires(Robot.intake);
    }


    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
        Robot.intake.setRampDown();
        Robot.intake.setIntakePistonsExtend();
        Robot.shooter.setCubePistonDown();
        Robot.shooter.setShooterDown();
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
        Robot.intake.spinBothIntake(speed);
        Robot.intake.spinBothTransfer(speed);

    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        if (Robot.intake.isBlockHalfWayLoaded()) {
            currentDoneCount++;
        } else {
            currentDoneCount = 0;
        }
        if (currentDoneCount > DONE_COUNT_MAX) {
            currentDoneCount = 0;
            System.out.println("TRUE");
            return true;
        }
        return isTimedOut();

    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        blinkLimelight.start();
//        JitterIntake.start();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    }

}
```


Overlapping Code:
```
te double speed;
private final int DONE_COUNT_MAX = 50;
private int currentDoneCount = 0;
private Command blinkLimelight = new BlinkLimelight(2);
private Command JitterIntake = new JitterIntake(1);
public AutoIntake(double speed) {
this.speed = speed;
}
public AutoIntake(double speed, double timeout) {
super(timeout);
this.speed = speed;
requires(Robot.intake);
}
// Called just before this Command runs the first time
@Override
protected void initialize() {
Robot.intake.setRampDown();
Robot.intake.setIntakePistonsExtend();
Robot.shooter.setCubePistonDown();
Robot.shooter.setShooterDown();
}
// Called repeatedly when this Command is scheduled to run
@Override
protected void execute() {
Robot.intake.spinBothIntake(speed);
Robot.intake.spinBothTransfer(speed);
}
// Make this return true when this Command no longer needs to run execute()
@Override
protected boolean isFinished() {
if (Robot.intake.isBlockHalfWayLoaded()) {
currentDoneCount++;
} else {
currentDoneCount = 0;
}
if (currentDoneCount > DONE_COUNT_MAX) {
currentDoneCount = 0;
System.out.println("TRUE");
return true;
}
return isTimedOut();
}
// Called once after isFinished returns true
@Override
protected void end() {
blinkLimelight.start();
// JitterIntake.start();
}
// Called when another command which requires one or more of the same
// subsystems is scheduled to run
@Override
protected void interrupted() {
}
}
```
<Overlap Ratio: 0.9672929714683368>

---

--- 338 --
Question ID: 33b73c4832113bc45c088d29a0aae831f884b9cc
Original Code:
```
public class Main {
    public static void main(String[] args) throws IOException {
        File inputFile = new File(args[0]);
        
        BufferedReader bufferedReader = new BufferedReader(new FileReader(inputFile));
        String lineInFile;
        
        while ( (lineInFile = bufferedReader.readLine()) != null ) {
            lineInFile = lineInFile.trim();
            
            if (lineInFile.equals("")) {
            	lineInFile = bufferedReader.readLine(); // escape Enter key press
            }
            
            String[] sets = lineInFile.split(";");
            String[] firstSetNumbers = sets[0].split(",");
            String[] secondSetNumbers = sets[1].split(",");
            
            StringBuilder intersection = new StringBuilder();
            
            int i = 0;
            int j = 0;
            
            while ( i < firstSetNumbers.length ) {
            	if ( firstSetNumbers[i].equals(secondSetNumbers[j] ) ) {
            		while ( i < firstSetNumbers.length &&
            				j < secondSetNumbers.length &&
            				firstSetNumbers[i].equals(secondSetNumbers[j]) ) 
            		{
            			intersection.append( firstSetNumbers[i] + "," );
            			i++;
            			j++;
            		}
            		break;
            	}
            	else {
            		i++;
            	}
            }
            
            if (intersection.length() > 0) {
            	System.out.println( intersection.substring(0, intersection.length()-1) );
            }
            else {
            	System.out.println();
            }
        }
        
        bufferedReader.close();
    }
}
```


Overlapping Code:
```
public class Main {
public static void main(String[] args) throws IOException {
File inputFile = new File(args[0]);

BufferedReader bufferedReader = new BufferedReader(new FileReader(inputFile));
String lineInFile;

while ( (lineInFile = bufferedReader.readLine()) != null ) {
lineInFile = lineInFile.trim();

if (lineInFile.equals("")) {
lineInFile = bufferedReader.readLine(); // escape Enter key press
}

String[] sets = lineInFile.split(";");
String[] firstSetNumbers = sets[0].split(",");
String[] secondSetNumbers = sets[1].split(",");

StringBuilder intersection = new StringBuilder();

int i = 0;
int j = 0;

while ( i < firstSetNumbers.length ) {
if ( firstSetNumbers[i].equals(secondSetNumbers[j] ) ) {
while ( i < firstSetNumbers.length &&
j < secondSetNumbers.length &&
firstSetNumbers[i].equals(secondSetNumbers[j]) ) 
{
intersection.append( firstSetNumbers[i] + "," );
i++;
j++;
}
break;
}
else {
i++;
}
}

if (intersection.length() > 0) {
System.out.println( intersection.substring(0, intersection.length()-1) );
}
else {
System.out.println();
}
}

bufferedReader.close();

```
<Overlap Ratio: 0.997250229147571>

---

--- 339 --
Question ID: 1ca131f129f86a544fb635527878ac72aefa3458
Original Code:
```
@Api(value = "Page API")
@RestController
@RequestMapping("/api/v1/cms/pages")
public class PageController extends _BaseApi<Page> {

	@Autowired
	PageService pageService;

	@Override
	public void delete(long id) {
		Page p = this.pageService.get(id);
		if (p != null) {
			this.pageService.deleteAllAttachments(p.getId(), p.getBoTypeId());
		}
		super.delete(id);
	}

	@Override
	public Object upload(MultipartFile file, HttpServletRequest request) throws IllegalStateException, IOException {
		FileInfo fi = (FileInfo) super.upload(file, request);

		Attachment attachment = new Attachment();
		attachment.setPath(fi.getRelativePath());
		attachment.setExtensionName(fi.getExtensionName());
		attachment.setFileName(fi.getName());
		attachment.setFileType(fi.getType());
		attachment.setBoId(Long.parseLong(request.getParameter("boId")));
		attachment.setBoTypeId(Long.parseLong(request.getParameter("boTypeId")));
		this.pageService.addAttachment(attachment);

		return attachment;
	}

}
```


Overlapping Code:
```
PI")
@RestController
@RequestMapping("/api/v1/cms/pages")
public class PageController extends _BaseApi<Page> {
@Autowired
PageService pageService;
@Override
public void delete(long id) {
Page p = this.pageService.get(id);
if (p != null) {
this.pageService.deleteAllAttachments(p.getId(), p.getBoTypeId());
}
super.delete(id);
}
@Override
public Object upload(MultipartFile file, HttpServletRequest request) throws IllegalStateException, IOException {
FileInfo fi = (FileInfo) super.upload(file, request);
Attachment attachment = new Attachment();
attachment.setPath(fi.getRelativePath());
attachment.setExtensionName(fi.getExtensionName());
attachment.setFileName(fi.getName());
attachment.setFileType(fi.getType());
attachment.setBoId(Long.parseLong(request.getParameter("boId")));
attachment.setBoTypeId(Long.parseLong(request.getParameter("boTypeId")));
this.pageService.addAttachment(attachment);
```
<Overlap Ratio: 0.9544008483563097>

---

--- 340 --
Question ID: 87145ddcc0b5a69c27069c7e3b5ba65821c9fc36
Original Code:
```
public class NBTUtil {

    public static final int TAG_END = 0;
    public static final int TAG_BYTE = 1;
    public static final int TAG_SHORT = 2;
    public static final int TAG_INT = 3;
    public static final int TAG_LONG = 4;
    public static final int TAG_FLOAT = 5;
    public static final int TAG_DOUBLE = 6;
    public static final int TAG_BYTE_A = 7;
    public static final int TAG_STRING = 8;
    public static final int TAG_LIST = 9;
    public static final int TAG_COMP = 10;
    public static final int TAG_INT_A = 11;
    public static final String ATTRIBS = "attribs";

    private static final Field handle;
    private static final boolean support;

    static {
        Field _handle = null;
        boolean _support = false;
        try {
            _handle = CraftItemStack.class.getDeclaredField("handle");
            _handle.setAccessible(true);
            _support = true;
        } catch (Throwable ignored) {
        }
        handle = _handle;
        support = _support;
    }

    public static void setTag(org.bukkit.inventory.ItemStack stack, NBTTagCompound tag) {
        try {
            ((net.minecraft.server.v1_12_R1.ItemStack) handle.get(stack)).setTag(tag);
        } catch (Throwable ignored) {
        }
    }

    public static NBTTagCompound getOrCreateTag(ItemStack stack, String path) {
        try {
            NBTTagCompound tag = ((net.minecraft.server.v1_12_R1.ItemStack) handle.get(stack)).getTag();
            if (tag == null) {
                tag = new NBTTagCompound();
                setTag(stack, tag);
            }
            if (path != null && !path.isEmpty()) {
                NBTTagCompound child = tag.getCompound(path);
                tag.set(path, child);
                return child;
            }
            return tag;
        } catch (Throwable e) {
            e.printStackTrace();
            return new NBTTagCompound();
        }
    }

    public static NBTTagCompound getTag(ItemStack stack, String path) {
        if (!(stack instanceof CraftItemStack)) {
            stack = CraftItemStack.asCraftCopy(stack);
        }
        try {
            NBTTagCompound tag = ((net.minecraft.server.v1_12_R1.ItemStack) handle.get(stack)).getTag();
            if (tag == null) return null;
            if (path != null && !path.isEmpty()) {
                NBTTagCompound child = tag.getCompound(path);
                if (child == null) return null;
                return child;
            }
            return tag;
        } catch (Throwable e) {
            e.printStackTrace();
            return new NBTTagCompound();
        }
    }

    public static ItemAttrib getOrCreateAttrib(org.bukkit.inventory.ItemStack stack) {
        NBTTagCompound tag = getOrCreateTag(stack, "attrib");
        ItemAttrib attrib = new ItemAttrib();
        attrib.globalId = tag.getInt("globalId");
        attrib.name = tag.getString("name");
        attrib.attack = tag.getInt("attack");
        attrib.critChance = tag.getFloat("critChance");
        attrib.walkspeed = tag.getFloat("walkspeed");
        attrib.blockChance = tag.getFloat("blockChance");
        attrib.dodgeChance = tag.getFloat("dodgeChance");
        attrib.suckRatio = tag.getFloat("suckRatio");
        attrib.fireChance = tag.getFloat("fireChance");
        attrib.blockChance = tag.getFloat("blockChance");
        return attrib;
    }

    public static ItemAttrib getAttrib(org.bukkit.inventory.ItemStack stack) {
        NBTTagCompound tag = getTag(stack, "attrib");
        if (tag == null || !tag.hasKey("active")) return null;
        ItemAttrib attrib = new ItemAttrib();
        attrib.globalId = tag.getInt("globalId");
        attrib.name = tag.getString("name");
        attrib.attack = tag.getInt("attack");
        attrib.critChance = tag.getFloat("critChance");
        attrib.walkspeed = tag.getFloat("walkspeed");
        attrib.blockChance = tag.getFloat("blockChance");
        attrib.dodgeChance = tag.getFloat("dodgeChance");
        attrib.suckRatio = tag.getFloat("suckRatio");
        attrib.fireChance = tag.getFloat("fireChance");
        attrib.blockChance = tag.getFloat("blockChance");
        return attrib;
    }

    public static void offerAttrib(org.bukkit.inventory.ItemStack stack, ItemAttrib attrib) {
        NBTTagCompound tag = getOrCreateTag(stack, "attrib");
        tag.setInt("globalId", attrib.globalId);
        tag.setString("name", attrib.name);
        tag.setInt("attack", attrib.attack);
        tag.setFloat("critChance", attrib.critChance);
        tag.setFloat("walkspeed", attrib.walkspeed);
        tag.setFloat("blockChance", attrib.blockChance);
        tag.setFloat("dodgeChance", attrib.dodgeChance);
        tag.setFloat("suckRatio", attrib.suckRatio);
        tag.setFloat("fireChance", attrib.fireChance);
        tag.setFloat("blockChance", attrib.blockChance);
    }
}
```


Overlapping Code:
```
{
public static final int TAG_END = 0;
public static final int TAG_BYTE = 1;
public static final int TAG_SHORT = 2;
public static final int TAG_INT = 3;
public static final int TAG_LONG = 4;
public static final int TAG_FLOAT = 5;
public static final int TAG_DOUBLE = 6;
public static final int TAG_BYTE_A = 7;
public static final int TAG_STRING = 8;
public static final int TAG_LIST = 9;
public static final int TAG_COMP = 10;
public static final int TAG_INT_A = 11;
public static final String ATTRIBS = "attribs";
private static final Field handle;
private static final boolean support;
static {
Field _handle = null;
boolean _support = false;
try {
_handle = CraftItemStack.class.getDeclaredField("handle");
_handle.setAccessible(true);
_support = true;
} catch (Throwable ignored) {
}
handle = _handle;
support = _support;
}
public static void setTag(org.bukkit.inventory.ItemStack stack, NBTTagCompound tag) {
try {
((net.minecraft.server.v1_12_R1.ItemStack) handle.get(stack)).setTag(tag);
} catch (Throwable ignored) {
}
}
public static NBTTagCompound getOrCreateTag(ItemStack stack, String path) {
try {
NBTTagCompound tag = ((net.minecraft.server.v1_12_R1.ItemStack) handle.get(stack)).getTag();
if (tag == null) {
tag = new NBTTagCompound();
setTag(stack, tag);
}
if (path != null && !path.isEmpty()) {
NBTTagCompound child = tag.getCompound(path);
tag.set(path, child);
return child;
}
return tag;
} catch (Throwable e) {
e.printStackTrace();
return new NBTTagCompound();
}
}
public static NBTTagCompound getTag(ItemStack stack, String path) {
if (!(stack instanceof CraftItemStack)) {
stack = CraftItemStack.asCraftCopy(stack);
}
try {
NBTTagCompound tag = ((net.minecraft.server.v1_12_R1.ItemStack) handle.get(stack)).getTag();
if (tag == null) return null;
if (path != null && !path.isEmpty()) {
NBTTagCompound child = tag.getCompound(path);
if (child == null) return null;
return child;
}
return t
```
<Overlap Ratio: 0.9886187273667874>

---

--- 341 --
Question ID: 21e6d1f68ec564073171918e84a7e46c57e46827
Original Code:
```
public class LoginActivity extends AbstractDkqActivity {

    @NonNull
    static Intent createLaunchIntent( final Context context ) {
        return new Intent( context, LoginActivity.class );
    }

    private TextInputLayout usernameContainer;
    private TextInputEditText usernameField;
    private TextInputLayout passwordContainer;
    private TextInputEditText passwordField;

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_login);
        usernameContainer = findViewById(R.id.usernameContainer);
        usernameField = findViewById(R.id.usernameField);
        usernameField.setOnFocusChangeListener((view, hasFocus) -> {
            if( !hasFocus ) {
                isRequired( usernameContainer );
            }
        });
        passwordContainer = findViewById(R.id.passwordContainer);
        passwordField = findViewById(R.id.passwordField);
        passwordField.setOnFocusChangeListener((view, hasFocus) -> {
            if( !hasFocus ) {
                isRequired( passwordContainer );
            }
        });
        passwordField.setOnEditorActionListener((v, actionId, event) -> {
            if (actionId == EditorInfo.IME_ACTION_DONE) {
                login(null);
                return true;
            }
            return false;
        });
    }

    public void login( @Nullable final View view ) {
        isRequired( usernameContainer );
        isRequired( passwordContainer );

        final String username = usernameField.getText().toString();
        final String password = passwordField.getText().toString();
        if( TextUtils.equals( username,DkqConstants.Account.USERNAME) && TextUtils.equals( password,DkqConstants.Account.PASSWORD ) ) {
            usernameContainer.setError( null );
            passwordContainer.setError( null );
            openMainActivity();
        } else {
            final String loginError = getString( R.string.error_login );
            usernameContainer.setError( loginError );
            passwordContainer.setError( loginError );
        }
    }

    private void isRequired( final TextInputLayout input ) {
        final EditText editText = input.getEditText();
        if( editText == null ) {
            // nothing to validate
            return;
        }

        final String error = getString( R.string.error_required );
        if( TextUtils.isEmpty( editText.getText().toString() ) ) {
            input.setError( error );
        } else if( TextUtils.equals( error, input.getError() ) ) {
            input.setError( null );
        }
    }

    private void openMainActivity() {
        startActivity( MainActivity.createLaunchIntent( this ).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK) );
        finish();
    }

    public void register( final View view) {
        new AlertDialog.Builder( this )
                .setMessage(R.string.no_registration_text)
                .setPositiveButton(R.string.close_word, null)
                .create()
                .show();
    }
}
```


Overlapping Code:
```
bstractDkqActivity {
@NonNull
static Intent createLaunchIntent( final Context context ) {
return new Intent( context, LoginActivity.class );
}
private TextInputLayout usernameContainer;
private TextInputEditText usernameField;
private TextInputLayout passwordContainer;
private TextInputEditText passwordField;
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_login);
usernameContainer = findViewById(R.id.usernameContainer);
usernameField = findViewById(R.id.usernameField);
usernameField.setOnFocusChangeListener((view, hasFocus) -> {
if( !hasFocus ) {
isRequired( usernameContainer );
}
});
passwordContainer = findViewById(R.id.passwordContainer);
passwordField = findViewById(R.id.passwordField);
passwordField.setOnFocusChangeListener((view, hasFocus) -> {
if( !hasFocus ) {
isRequired( passwordContainer );
}
});
passwordField.setOnEditorActionListener((v, actionId, event) -> {
if (actionId == EditorInfo.IME_ACTION_DONE) {
login(null);
return true;
}
return false;
});
}
public void login( @Nullable final View view ) {
isRequired( usernameContainer );
isRequired( passwordContainer );
final String username = usernameField.getText().toString();
final String password = passwordField.getText().toString();
if( TextUtils.equals( username,DkqConstants.Account.USERNAME) && TextUtils.equals( password,DkqConstants.Account.PASSWORD ) ) {
usernameContainer.setError( null );
passwordContainer.setError( null );
openMainActivity();
} else {
final String loginError = getString( R.string.error_login );
usernameContainer.setError( loginError );
passwordContainer.setError( loginError );
}
}
private void isRequired( final TextInputLayout input ) {
final EditText editText = input.getEditText();
if( editText == null ) {
// nothing to validate
return;
}
final String error = getString( R.string.error_required );
if( TextUtils.isEmpty( editText.getText().toSt
```
<Overlap Ratio: 0.9769539078156313>

---

--- 342 --
Question ID: 21d0ffc93e5e187d33f004f35bb431c1341ffa81
Original Code:
```
@ToString
public class FluentValidatorImpl<R> implements Fv.Validator<R> {
    private static final PropertyUtilsBean PROPERTY_UTILS_BEAN = BeanUtilsBean.getInstance().getPropertyUtils();

    private List<FluentValidatorBuilder.ValidationDataWithProperties> validationData = new ArrayList<>();

    public FluentValidatorImpl(List<FluentValidatorBuilder.ValidationDataWithProperties> validationData) {
        this.validationData = validationData;
    }

    public List<FluentValidatorBuilder.ValidationDataWithProperties> getValidationData() {
        return validationData;
    }

    public Fv.Result<R> validate(R rootObject) {
        Errors errors = Errors.ok();

        for (FluentValidatorBuilder.ValidationDataWithProperties validationDataWithProperties : validationData) {
            String property = validationDataWithProperties.getProperty();
            Object value = getPropertyValue(rootObject, property);

            Fv.Result result = validationDataWithProperties.getData().validate(rootObject, property, value);

            if (result != null) {
                errors.add(result.getErrors());
            }
        }

        return Fv.Result.failure(rootObject, errors);
    }

    private Object getPropertyValue(R o, String property) {
        try {
            if (o == null) {
                return null;
            } else if (property == null) {
                return o;
            } else {
                return PROPERTY_UTILS_BEAN.getNestedProperty(o, property);
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```


Overlapping Code:
```
<R> implements Fv.Validator<R> {
private static final PropertyUtilsBean PROPERTY_UTILS_BEAN = BeanUtilsBean.getInstance().getPropertyUtils();
private List<FluentValidatorBuilder.ValidationDataWithProperties> validationData = new ArrayList<>();
public FluentValidatorImpl(List<FluentValidatorBuilder.ValidationDataWithProperties> validationData) {
this.validationData = validationData;
}
public List<FluentValidatorBuilder.ValidationDataWithProperties> getValidationData() {
return validationData;
}
public Fv.Result<R> validate(R rootObject) {
Errors errors = Errors.ok();
for (FluentValidatorBuilder.ValidationDataWithProperties validationDataWithProperties : validationData) {
String property = validationDataWithProperties.getProperty();
Object value = getPropertyValue(rootObject, property);
Fv.Result result = validationDataWithProperties.getData().validate(rootObject, property, value);
if (result != null) {
errors.add(result.getErrors());
}
}
return Fv.Result.failure(rootObject, errors);
}
private Object getPropertyValue(R o, String property) {
try {
if (o == null) {
return null;
} else if (property == null) {
return o;
} else {
return PROPERTY_UTILS_BEAN.getNestedProperty(o, property);
}
} catch (Exception e) {
throw new RuntimeException(e);
}
}
}
```
<Overlap Ratio: 0.9677914110429447>

---

--- 343 --
Question ID: 16c909d80137b9bf5fcf8b3c5bebe56eb12d38ce
Original Code:
```
public class MaxSubArraySumOneDeletion {

    //https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/

    //Read : MaxSumSubArray for easy understanding : https://leetcode.com/submissions/detail/288875284/
    public static void main( String[] args ) {

        System.out.println(maximumSum(new int[]{1, -2, 0, 3}));
    }

    /*
     arr = {1, -2, 0, 3}

     consider two elements in array = {1, -2}, we have two options:

     - We can delete and check : if we delete then we try add curr element with delete sum :
                                 oneDelete + arr[i] or
                                 by exclude curr element, by using noDelete sum :
                                 nodelete

     - We don't delete and check : if we don't delete we can include curr element with prev sum:
                                   noDelete + arr[i] or
                                   Just include the curr element : arr[i]
     */
    private static int maximumSum( int[] arr ) {
        int n = arr.length;

        int oneDelete = 0, noDelete = arr[0], max = arr[0];

        //see carefully: we start the loop with 1 : that means by exclusion we can pick 1st element and delete the zero-th
        for (int i = 1; i < n; i++) {

            oneDelete = Math.max(oneDelete + arr[i], noDelete);

            //https://leetcode.com/submissions/detail/288875284/
            noDelete = Math.max(noDelete + arr[i], arr[i]); //same as MaximumSubArray DP problem

            max = Math.max(max, Math.max(oneDelete, noDelete)); //just maintaining max of 2 states above
        }

        return max;
    }
}
```


Overlapping Code:
```
ion {
//https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/
//Read : MaxSumSubArray for easy understanding : https://leetcode.com/submissions/detail/288875284/
public static void main( String[] args ) {
System.out.println(maximumSum(new int[]{1, -2, 0, 3}));
}
/*
arr = {1, -2, 0, 3}
consider two elements in array = {1, -2}, we have two options:
- We can delete and check : if we delete then we try add curr element with delete sum :
oneDelete + arr[i] or
by exclude curr element, by using noDelete sum :
nodelete
- We don't delete and check : if we don't delete we can include curr element with prev sum:
noDelete + arr[i] or
Just include the curr element : arr[i]
*/
private static int maximumSum( int[] arr ) {
int n = arr.length;
int oneDelete = 0, noDelete = arr[0], max = arr[0];
//see carefully: we start the loop with 1 : that means by exclusion we can pick 1st element and delete the zero-th
for (int i = 1; i < n; i++) {
oneDelete = Math.max(oneDelete + arr[i], noDelete);
//https://leetcode.com/submissions/detail/288875284/
noDelete = Math.max(noDelete + arr[i], arr[i]); //same as MaximumSubArray DP problem
max = Math.max(max, Math.max(oneDelete, noDelete)); //just maintaining max of 2 states above
}
return max;
}
}
```
<Overlap Ratio: 0.9727626459143969>

---

--- 344 --
Question ID: a25db5dd385cb7c8acd32a8240174ff2723c39ce
Original Code:
```
public class ACO extends MetaHeuristic{
    private final CountIteration loop = CountIteration.obj;
    
    private Stop stop;
    private Problem problem;
    private oTrailPheromone trails[];
    
    private final Factory fStop;
    private final Factory fProblem;
    
    private int Nants;  //number of ants
    private double convergence; //convergence rate

    public ACO(Factory fStop, Factory fProblem) {
        this.fStop = fStop;
        this.fProblem = fProblem;
    }
    
    @Override
    public String name() {
        return "Ant Colony Optimization";
    }
    @Override
    public void services(LinkerApproaches link) throws Exception {
        link.add(loop);
        stop                = link.get(fStop, stop);
        problem             = link.get(fProblem, problem);
        trails              = link.needs(oTrailPheromone.class, new oTrailPheromone[1]);
    }
    @Override
    public void parameters(LinkerParameters link) throws Exception {
        super.parameters(link); //To change body of generated methods, choose Tools | Templates.
        Nants = link.Int("N-ants", 100, 1, 1000000);
        convergence = link.Dbl("convergence", 0.5, 1e-3, 1.0);
    }
    @Override
    public void execute() throws Exception {
        //Initialize trails pheromone of each ant colony
        for(oTrailPheromone tr : trails){
            tr.initialize(problem);
        }
        //Alocate memory for each ant in all colonies
        Solution ants[][] = new Solution[trails.length][Nants];
        for(int t=0; t<trails.length; t++){
            for(int k=0; k<Nants; k++){
                ants[t][k] = problem.build_sol();
            }
        }
        Solution best[] = new Solution[trails.length];  //best solution on colony
        Solution migr[] = new Solution[trails.length];  //migrate solution
        int trails_life[] = new int[trails.length];
        int max_life = 1;
        do{
            //------------------- build ants ---------------------
            
            for(int t=0; t<trails.length; t++){ //for each colony or pheromone trail (t)
                double prob = 1;
                for(int k=0; k<Nants; k++){
                    // if is not the best and is not the migrate solution then rebuild the ant
                    if(ants[t][k] != best[t] && ants[t][k] != migr[t]){ 
                        //prob = Math.max(prob,trails[t].build(problem, ants[t][k]));
                        prob *= trails[t].build(problem, ants[t][k]);
                        problem.evaluate(ants[t][k]);
                    }
                }
//                if(trails_life[t]>max_life){
//                    max_life = trails_life[t];
//                    //System.out.println("max-life = "+max_life);
//                }
                //System.out.printf("%d : %8d : %g\n",t, trails_life[t], prob);
                if(prob>convergence){
                    //System.out.printf("RESTART trail = %d : life = %8d : max = %8d: prob = %g\n",t, trails_life[t], max_life, prob);
                    
                    trails_life[t] = 0;
                    //System.out.println("--------------[RESTART trail = "+trails[t]+" ]-------------");
                    trails[t].initialize(problem);
                    t--;    //repeat the build process
                }else{
                    trails_life[t]++;
                }
            }
            //------------------ find bests ----------------------
            for(int t=0; t<trails.length; t++){
                int b = Solution.minIndex(ants[t]);
                best[t] = ants[t][b];
            }
            //------------------ migrations ----------------------
            if(trails.length>1){    //if we have more than one colony
                for(int t=0; t<trails.length; t++){
                    int s = (t+1)%trails.length;
                    int w = Solution.maxIndex(ants[s]);
                    ants[s][w].copy(problem, best[t]);   //copy the best ant from t on worst ant from t+1
                    migr[s] = ants[s][w];
                }
            }
                
            //------------------ update trails -------------------
            for(int t=0; t<trails.length; t++){
                trails[t].evaporate(problem);
                for(int k=0; k<Nants; k++){
                    trails[t].deposit(problem, ants[t][k], 1.0);
                }
                trails[t].deposit(problem, best[t], trails_life[t]);
            }
            
            loop.iteration();
        }while(!stop.end());
    }
    @Override
    public void results(LinkerResults win) throws Exception {
        win.writeLong("iterations", loop.value());
    }
}
```


Overlapping Code:
```
aHeuristic{
private final CountIteration loop = CountIteration.obj;

private Stop stop;
private Problem problem;
private oTrailPheromone trails[];

private final Factory fStop;
private final Factory fProblem;

private int Nants; //number of ants
private double convergence; //convergence rate
public ACO(Factory fStop, Factory fProblem) {
this.fStop = fStop;
this.fProblem = fProblem;
}

@Override
public String name() {
return "Ant Colony Optimization";
}
@Override
public void services(LinkerApproaches link) throws Exception {
link.add(loop);
stop = link.get(fStop, stop);
problem = link.get(fProblem, problem);
trails = link.needs(oTrailPheromone.class, new oTrailPheromone[1]);
}
@Override
public void parameters(LinkerParameters link) throws Exception {
super.parameters(link); //To change body of generated methods, choose Tools | Templates.
Nants = link.Int("N-ants", 100, 1, 1000000);
convergence = link.Dbl("convergence", 0.5, 1e-3, 1.0);
}
@Override
public void execute() throws Exception {
//Initialize trails pheromone of each ant colony
for(oTrailPheromone tr : trails){
tr.initialize(problem);
}
//Alocate memory for each ant in all colonies
Solution ants[][] = new Solution[trails.length][Nants];
for(int t=0; t<trails.length; t++){
for(int k=0; k<Nants; k++){
ants[t][k] = problem.build_sol();
}
}
Solution best[] = new Solution[trails.length]; //best solution on colony
Solution migr[] = new Solution[trails.length]; //migrate solution
int trails_life[] = new int[trails.length];
int max_life = 1;
do{
//------------------- build ants ---------------------

for(int t=0; t<trails.length; t++){ //for each colony or pheromone trail (t)
double prob = 1;
for(int k=0; k<Nants; k++){
// if is not the best and is not the migrate solution then rebuild the ant
if(ants[t][k] != best[t] && ants[t][k] != migr[t]){ 
//prob = Math.max(prob,trails[t].build(problem, ants[t][k]));
prob *= trai
```
<Overlap Ratio: 0.9688934217236104>

---

--- 345 --
Question ID: 798c46940dc9ae70d6a3ca0e9886c09e3ebd33c7
Original Code:
```
public class ProcedureName implements Comparable<ProcedureName> {
    private final String name;

    private ProcedureName(final String name) {
        this.name = name;
    }

    @Override public String toString() {
        return name;
    }

    @Override public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + (name == null ? 0 : name.hashCode());
        return result;
    }

    @Override public boolean equals(final Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final ProcedureName other = (ProcedureName) obj;
        if (name == null) {
            if (other.name != null) {
                return false;
            }
        } else if (!name.equals(other.name)) {
            return false;
        }
        return true;
    }

    @Override public int compareTo(final ProcedureName o) {
        return name.compareTo(o.name);
    }

    public static List<ProcedureName> asProcedureNames(final String[] names) {
        return Jc.$(names).map(ProcedureName::procedureName)._$();
    }

    public static ProcedureName procedureName(final String name) {
        return new ProcedureName(name);
    }
}
```


Overlapping Code:
```
ass ProcedureName implements Comparable<ProcedureName> {
private final String name;
private ProcedureName(final String name) {
this.name = name;
}
@Override public String toString() {
return name;
}
@Override public int hashCode() {
final int prime = 31;
int result = 1;
result = prime * result + (name == null ? 0 : name.hashCode());
return result;
}
@Override public boolean equals(final Object obj) {
if (this == obj) {
return true;
}
if (obj == null) {
return false;
}
if (getClass() != obj.getClass()) {
return false;
}
final ProcedureName other = (ProcedureName) obj;
if (name == null) {
if (other.name != null) {
return false;
}
} else if (!name.equals(other.name)) {
return false;
}
return true;
}
@Override public int compareTo(final ProcedureName o) {
return name.compareTo(o.name);
}
public static List<ProcedureName> asProcedureNames(final String[] names) {
return Jc.$(names).map(ProcedureName::procedureName)._$();
}
public static ProcedureName procedureName(final String name) {
return
```
<Overlap Ratio: 0.9633911368015414>

---

--- 346 --
Question ID: 161d7ab3f0828279b18adbb04cf0eee98d9b751d
Original Code:
```
public class UtilTest extends TestCase {
    private VContext ctx;
    private VContext dummyServerCtx;
    private Endpoint dummyServerEndpoint;

    @Override
    protected void setUp() throws Exception {
        ctx = V.init();
        ctx = V.init();
        dummyServerCtx = V23TestUtil.withDummyServer(ctx);
        dummyServerEndpoint = V23TestUtil.getServerEndpoint(dummyServerCtx);
        ctx = NamespaceTestUtil.withTestMountServer(ctx);
    }

    public void testListChildren() throws Exception {
        Namespace n = V.getNamespace(ctx);
        sync(n.mount(ctx, "appblessing,database/userblessing,collection1", dummyServerEndpoint.name(), Duration.standardDays(1)));
        sync(n.mount(ctx, "appblessing,database/userblessing,collection2", dummyServerEndpoint.name(), Duration.standardDays(1)));
        assertThat(sync(Util.listChildIds(ctx, "appblessing,database"))).containsExactly(new Id("userblessing", "collection1"), new Id("userblessing", "collection2"));
    }

    private static class FilterTagTestCase {
        private Permissions input;
        private Iterable<Tag> allowed;
        private Permissions wanted;

        private FilterTagTestCase(Permissions input, Iterable<Tag> allowed, Permissions wanted) {
            this.input = input;
            this.allowed = allowed;
            this.wanted = wanted;
        }
    }

    public void testFilterTags() {
        List<FilterTagTestCase> filterTagTestCases = new ArrayList<>();
        List<BlessingPattern> aclIn = new ArrayList<>();
        aclIn.add(new BlessingPattern("alice"));
        aclIn.add(new BlessingPattern("bob"));
        aclIn.add(new BlessingPattern("carol"));
        List<String> aclNotIn = new ArrayList<>();
        aclNotIn.add("alice:enemy");
        AccessList acl = new AccessList(aclIn, aclNotIn);

        Map<String, AccessList> mapping = new HashMap<>();
        mapping.put(Constants.DEBUG.getValue(), acl);
        mapping.put(Constants.RESOLVE.getValue(), acl);
        mapping.put(Constants.READ.getValue(), acl);
        mapping.put(Constants.ADMIN.getValue(), acl);

        Permissions canonicalPerms = new Permissions(mapping);

        Map<String, AccessList> noDebugMapping = new HashMap<>(mapping);
        noDebugMapping.remove(Constants.DEBUG.getValue());
        Permissions noDebugPerms = new Permissions(noDebugMapping);
        Set<Tag> noDebugTags = new HashSet<>();
        Collections.addAll(noDebugTags, Constants.RESOLVE, Constants.READ, Constants.WRITE,
                Constants.ADMIN);

        Map<String, AccessList> noResolveReadMapping = new HashMap<>(mapping);
        noResolveReadMapping.remove(Constants.RESOLVE.getValue());
        noResolveReadMapping.remove(Constants.READ.getValue());
        Permissions noResolveReadPerms = new Permissions(noResolveReadMapping);
        List<Tag> noResolveReadTags = new ArrayList<>();
        Collections.addAll(noResolveReadTags, Constants.DEBUG, Constants.WRITE, Constants.ADMIN);

        List<Tag> allTags = new ArrayList<>();
        Collections.addAll(allTags, Constants.DEBUG, Constants.RESOLVE, Constants.READ,
                Constants.WRITE, Constants.ADMIN);

        filterTagTestCases.add(new FilterTagTestCase(new Permissions(), new ArrayList<Tag>(),
                new Permissions()));
        filterTagTestCases.add(new FilterTagTestCase(canonicalPerms, new HashSet<Tag>(),
                new Permissions()));
        filterTagTestCases.add(new FilterTagTestCase(canonicalPerms, noDebugTags, noDebugPerms));
        filterTagTestCases.add(new FilterTagTestCase(canonicalPerms, noResolveReadTags,
                noResolveReadPerms));
        filterTagTestCases.add(new FilterTagTestCase(canonicalPerms, allTags, canonicalPerms));

        // Confirm that things match up correctly.
        for (FilterTagTestCase test : filterTagTestCases) {
            Permissions actualPerms = Util.filterPermissionsByTags(test.input, test.allowed);
            assertEquals(actualPerms, test.wanted);

            // Confirm the filtered version is independent from the original.
            Permissions origPerms = test.input;
            String adminStr = Constants.ADMIN.getValue();
            if (actualPerms.get(adminStr) != null) {
                List<BlessingPattern> actualIn = actualPerms.get(adminStr).getIn();
                List<BlessingPattern> origIn = origPerms.get(adminStr).getIn();

                // It's possible that the admin access list is the same reference instead of copied.
                // Confirm equality. Change the admin access list. Then confirm inequality.
                assertEquals(actualIn, origIn);
                actualIn.clear();
                assertFalse(actualIn.equals(origIn));
            }

        }
    }
}
```


Overlapping Code:
```
nds TestCase {
private VContext ctx;
private VContext dummyServerCtx;
private Endpoint dummyServerEndpoint;
@Override
protected void setUp() throws Exception {
ctx = V.init();
ctx = V.init();
dummyServerCtx = V23TestUtil.withDummyServer(ctx);
dummyServerEndpoint = V23TestUtil.getServerEndpoint(dummyServerCtx);
ctx = NamespaceTestUtil.withTestMountServer(ctx);
}
public void testListChildren() throws Exception {
Namespace n = V.getNamespace(ctx);
sync(n.mount(ctx, "appblessing,database/userblessing,collection1", dummyServerEndpoint.name(), Duration.standardDays(1)));
sync(n.mount(ctx, "appblessing,database/userblessing,collection2", dummyServerEndpoint.name(), Duration.standardDays(1)));
assertThat(sync(Util.listChildIds(ctx, "appblessing,database"))).containsExactly(new Id("userblessing", "collection1"), new Id("userblessing", "collection2"));
}
private static class FilterTagTestCase {
private Permissions input;
private Iterable<Tag> allowed;
private Permissions wanted;
private FilterTagTestCase(Permissions input, Iterable<Tag> allowed, Permissions wanted) {
this.input = input;
this.allowed = allowed;
this.wanted = wanted;
}
}
public void testFilterTags() {
List<FilterTagTestCase> filterTagTestCases = new ArrayList<>();
List<BlessingPattern> aclIn = new ArrayList<>();
aclIn.add(new BlessingPattern("alice"));
aclIn.add(new BlessingPattern("bob"));
aclIn.add(new BlessingPattern("carol"));
List<String> aclNotIn = new ArrayList<>();
aclNotIn.add("alice:enemy");
AccessList acl = new AccessList(aclIn, aclNotIn);
Map<String, AccessList> mapping = new HashMap<>();
mapping.put(Constants.DEBUG.getValue(), acl);
mapping.put(Constants.RESOLVE.getValue(), acl);
mapping.put(Constants.READ.getValue(), acl);
mapping.put(Constants.ADMIN.getValue(), acl);
Permissions canonicalPerms = new Permissions(mapping);
Map<String, AccessList> noDebugMapping = new HashMap<>(mapping);
noDebugMapping.remove(Constants.DEBUG.getValue());
Permissions noDebugPerms = new Permissions(noDebugMapping);
Set<Tag> noDebugTags = new HashSet<>();
Collections.addAll(noDebugTags, Constants.RESOLVE, Constants.READ, Consta
```
<Overlap Ratio: 0.9832324173265021>

---

--- 347 --
Question ID: eb6ae5230f949e152d9db09bb2d57628bbaaf898
Original Code:
```
@Repository
public class ThreadDAOImpl implements ThreadDAO {

  @Autowired
  private SessionFactory sessionFactory;


  public void setSessionFactory(SessionFactory sessionFactory) {
    this.sessionFactory = sessionFactory;
  }


  @Override
  public DBThread get(Long threadId) {
    Session session = sessionFactory.getCurrentSession();
    Criteria crit = session.createCriteria(DBThread.class)
        .add(Restrictions.eq("threadId", threadId));
    DBThread value = (DBThread) crit.uniqueResult();
    return value;
  }

  @SuppressWarnings("unchecked")
  @Override
  public List<DBThread> gets(String field, int offset, int limit) {
    Session session = sessionFactory.getCurrentSession();
    Criteria crit = session.createCriteria(DBThread.class);
    crit.add(Restrictions.eq("enabled", true));
    crit.addOrder(Order.desc(field));
    crit.setFirstResult(offset);
    crit.setMaxResults(limit);
    crit.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);
    List<DBThread> list = crit.list();
    return list;
  }

  @Override
  public DBThread insert(DBThread val) {
    Session session = sessionFactory.getCurrentSession();
    session.persist(val);
    session.flush();
    return val;
  }

  @Override
  public void update(DBThread val) {
    Session session = sessionFactory.getCurrentSession();
    session.update(val);
  }


  protected Session openSession() {
    return sessionFactory.openSession();
  }

}
```


Overlapping Code:
```

public class ThreadDAOImpl implements ThreadDAO {
@Autowired
private SessionFactory sessionFactory;
public void setSessionFactory(SessionFactory sessionFactory) {
this.sessionFactory = sessionFactory;
}
@Override
public DBThread get(Long threadId) {
Session session = sessionFactory.getCurrentSession();
Criteria crit = session.createCriteria(DBThread.class)
.add(Restrictions.eq("threadId", threadId));
DBThread value = (DBThread) crit.uniqueResult();
return value;
}
@SuppressWarnings("unchecked")
@Override
public List<DBThread> gets(String field, int offset, int limit) {
Session session = sessionFactory.getCurrentSession();
Criteria crit = session.createCriteria(DBThread.class);
crit.add(Restrictions.eq("enabled", true));
crit.addOrder(Order.desc(field));
crit.setFirstResult(offset);
crit.setMaxResults(limit);
crit.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);
List<DBThread> list = crit.list();
return list;
}
@Override
public DBThread insert(DBThread val) {
Session session = sessionFactory.getCurrentSession();
session.persist(val);
session.flush();
return val;
}
@Override
public void update(DBThread val) {
Session session = sessionFactory.getCurrentSession();
session.update(val);
}
protected Session openSession() {
return sessionFactory.openSession();
}

```
<Overlap Ratio: 0.9907120743034056>

---

--- 348 --
Question ID: 9198fc2c9b7d0d2b683f38baf1406c789b3039b1
Original Code:
```
@Controller
public class LoginController {
	
	@Autowired
	private AgentInfoValidator agentInfoValidator;
	
	@Autowired
	private AgentInfoService agentInfoService;
	
	@RequestMapping(value = {"/", "", "/login"})
	public String login(Model model) {
		model.addAttribute("agent", new Agent());
		return "login";
	}
	
	@RequestMapping(value = "/login", method = RequestMethod.POST)
	public String login(@Validated Agent agent, BindingResult result, Model model,
			HttpSession session) {

		agentInfoValidator.validate(agent, result);
		if (!agentInfoService.verifyAgent(agent) && result.hasErrors()) {
			return "login";
		}
		agent=agentInfoService.findById(agent);
		session.setAttribute("agent", agent);
		
		return "redirect:/create";//	/" + agent.getId();
	}

}
```


Overlapping Code:
```
ntroller
public class LoginController {

@Autowired
private AgentInfoValidator agentInfoValidator;

@Autowired
private AgentInfoService agentInfoService;

@RequestMapping(value = {"/", "", "/login"})
public String login(Model model) {
model.addAttribute("agent", new Agent());
return "login";
}

@RequestMapping(value = "/login", method = RequestMethod.POST)
public String login(@Validated Agent agent, BindingResult result, Model model,
HttpSession session) {
agentInfoValidator.validate(agent, result);
if (!agentInfoService.verifyAgent(agent) && result.hasErrors()) {
return "login";
}
agent=agentInfoService.findById(agent);
session.setAttribute("agent", agent);

retur
```
<Overlap Ratio: 0.9308437067773168>

---

--- 349 --
Question ID: 7fc140b301f04866aab66f46ae0706d16d269125
Original Code:
```
@Entity(name = "event")
public class EventEntity {
    @Id
    @GeneratedValue(strategy = IDENTITY)
    private Integer eventId;

    @NotNull
    @Size(max = 100)
    private String name;

    @NotNull
    @Size(max = 100)
    private String location;

    @NotNull
    private LocalDate startDate;

    @NotNull
    private LocalDate endDate;

    @NotNull
    @Enumerated(EnumType.STRING)
    private EventStatus eventStatus;

    private boolean current;

    @Column(updatable = false)
    private Integer createdByUserId;

    @Column(updatable = false)
    private Instant createdDateTime;

    private Integer updatedByUserId;
    private Instant updatedDateTime;

    @PrePersist
    private void prePersist() {
        createdDateTime = Instant.now();
        updatedDateTime = Instant.now();
        createdByUserId = SecurityContext.extractUserId();
        updatedByUserId = SecurityContext.extractUserId();
    }

    @PreUpdate
    private void preUpdate() {
        updatedDateTime = Instant.now();
        updatedByUserId = SecurityContext.extractUserId();
    }

    public Integer getEventId() {
        return eventId;
    }

    public void setEventId(Integer eventId) {
        this.eventId = eventId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getLocation() {
        return location;
    }

    public void setLocation(String location) {
        this.location = location;
    }

    public LocalDate getStartDate() {
        return startDate;
    }

    public void setStartDate(LocalDate startDate) {
        this.startDate = startDate;
    }

    public LocalDate getEndDate() {
        return endDate;
    }

    public void setEndDate(LocalDate endDate) {
        this.endDate = endDate;
    }

    public EventStatus getEventStatus() {
        return eventStatus;
    }

    public void setEventStatus(EventStatus eventStatus) {
        this.eventStatus = eventStatus;
    }

    /**
     * @return indicate this is the current event, so will be used for the default view or sub-data, such as teams.
     * The application is responsible for ensuring we have one current event.
     */
    public boolean isCurrent() {
        return current;
    }

    public void setCurrent(boolean current) {
        this.current = current;
    }

    public Integer getCreatedByUserId() {
        return createdByUserId;
    }

    public void setCreatedByUserId(Integer createdByUserId) {
        this.createdByUserId = createdByUserId;
    }

    public Instant getCreatedDateTime() {
        return createdDateTime;
    }

    public void setCreatedDateTime(Instant createdDateTime) {
        this.createdDateTime = createdDateTime;
    }

    public Integer getUpdatedByUserId() {
        return updatedByUserId;
    }

    public void setUpdatedByUserId(Integer updatedByUserId) {
        this.updatedByUserId = updatedByUserId;
    }

    public Instant getUpdatedDateTime() {
        return updatedDateTime;
    }

    public void setUpdatedDateTime(Instant updatedDateTime) {
        this.updatedDateTime = updatedDateTime;
    }

}
```


Overlapping Code:
```
ublic class EventEntity {
@Id
@GeneratedValue(strategy = IDENTITY)
private Integer eventId;
@NotNull
@Size(max = 100)
private String name;
@NotNull
@Size(max = 100)
private String location;
@NotNull
private LocalDate startDate;
@NotNull
private LocalDate endDate;
@NotNull
@Enumerated(EnumType.STRING)
private EventStatus eventStatus;
private boolean current;
@Column(updatable = false)
private Integer createdByUserId;
@Column(updatable = false)
private Instant createdDateTime;
private Integer updatedByUserId;
private Instant updatedDateTime;
@PrePersist
private void prePersist() {
createdDateTime = Instant.now();
updatedDateTime = Instant.now();
createdByUserId = SecurityContext.extractUserId();
updatedByUserId = SecurityContext.extractUserId();
}
@PreUpdate
private void preUpdate() {
updatedDateTime = Instant.now();
updatedByUserId = SecurityContext.extractUserId();
}
public Integer getEventId() {
return eventId;
}
public void setEventId(Integer eventId) {
this.eventId = eventId;
}
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public String getLocation() {
return location;
}
public void setLocation(String location) {
this.location = location;
}
public LocalDate getStartDate() {
return startDate;
}
public void setStartDate(LocalDate startDate) {
this.startDate = startDate;
}
public LocalDate getEndDate() {
return endDate;
}
public void setEndDate(LocalDate endDate) {
this.endDate = endDate;
}
public EventStatus getEventStatus() {
return eventStatus;
}
public void setEventStatus(EventStatus eventStatus) {
this.eventStatus = eventStatus;
}
/**
* @return indicate this is the current event, so will be used for the default view or sub-data, such as teams.
* The application is responsible for ensuring we have one current event.
*/
public boolean isCurrent() {
return current;
}
public void setCurrent(boolean current) {
this.current = current;
}
public Integer getCreatedByUserId() {
return createdByUserId;
}
public void setCreatedByUserId(Integ
```
<Overlap Ratio: 0.9867970660146699>

---

--- 350 --
Question ID: fe2e814968bfeafcce8655900f3834fea9ff1233
Original Code:
```
public class HashcodeTestRunnerTest {

    @Test
    public void testRunOfDefaultHashCode() throws Exception {
        Class clazz = SimpleClass.class;
        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());

        HashcodeTestRunner<SimpleClass> tester = new HashcodeTestRunner<>(clazz, beanInfo);
        assertTrue(tester.runTests().size() == 0, "Hashcode should succeed when class does not provide a hashcode");
    }

    @Test
    public void testRunOfSpecializedHashCode() throws Exception {
        Class clazz = EqualsHashTestClass.class;
        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());

        Set<String> fields = EqualsHashTestClass.getFieldsInHashcode();
        HashcodeTestRunner<EqualsHashTestClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);
        List<String> errors = tester.runTests();
        assertTrue( errors.size() == 0, errors.toString());
    }

    @Test
    public void testRunOfSpecializedHashCodeFieldDontChangeCode() throws Exception {
        Class clazz = EqualsHashTestClass.class;
        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());

        Set<String> fields = EqualsHashTestClass.getFieldsNotInHashcode();
        HashcodeTestRunner<EqualsHashTestClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);
        List<String> errors = tester.runTests();
        assertTrue( errors.size() > 0, errors.toString());
    }
    @Test
    public void testRunOfSpecializedHashCodeNoFields() throws Exception {
        Class clazz = BadHashcodeClass.class;
        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());

        HashcodeTestRunner<BadHashcodeClass> tester = new HashcodeTestRunner<>(clazz, beanInfo);
        List<String> errors = tester.runTests();
        assertTrue(errors.size() > 0, "Two different instances returned same hash code");
    }

    @Test
    public void testRunOfSpecializedHashCodeFieldNoSetterOrGetter() throws Exception {
        Class clazz = BadGetterSetterClass.class;
        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());

        HashcodeTestRunner<BadGetterSetterClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, BadGetterSetterClass.getFieldsInHashCode());
        List<String> errors = tester.runTests();
        assertTrue(errors.size() == 0, errors.toString());
    }

    @Test
    public void testRunOfSpecializedHashcodeBadDefaultFields() throws Exception {
        Class clazz = EqualsReturningNotEqualsDefaultValuesClass.class;
        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());
        Set<String> fields = EqualsReturningNotEqualsDefaultValuesClass.getFieldsInEqualsCode();

        HashcodeTestRunner<EqualsReturningNotEqualsDefaultValuesClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);
        List<String> errors = tester.runTests();
        assertTrue(errors.size() > 0, "Should have returned an error");
    }

    @Test
    public void testRunOfSpecializedHashCodeFailure() throws Exception {
        Class clazz = EqualsHashTestClass.class;
        BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());

        Set<String> fields = EqualsHashTestClass.getFieldsNotInHashcode();
        HashcodeTestRunner<EqualsHashTestClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);
        List<String> errors = tester.runTests();
        assertTrue(errors.size() > 0, "Should have returned an error");
    }
}
```


Overlapping Code:
```
 class HashcodeTestRunnerTest {
@Test
public void testRunOfDefaultHashCode() throws Exception {
Class clazz = SimpleClass.class;
BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());
HashcodeTestRunner<SimpleClass> tester = new HashcodeTestRunner<>(clazz, beanInfo);
assertTrue(tester.runTests().size() == 0, "Hashcode should succeed when class does not provide a hashcode");
}
@Test
public void testRunOfSpecializedHashCode() throws Exception {
Class clazz = EqualsHashTestClass.class;
BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());
Set<String> fields = EqualsHashTestClass.getFieldsInHashcode();
HashcodeTestRunner<EqualsHashTestClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);
List<String> errors = tester.runTests();
assertTrue( errors.size() == 0, errors.toString());
}
@Test
public void testRunOfSpecializedHashCodeFieldDontChangeCode() throws Exception {
Class clazz = EqualsHashTestClass.class;
BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());
Set<String> fields = EqualsHashTestClass.getFieldsNotInHashcode();
HashcodeTestRunner<EqualsHashTestClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, fields);
List<String> errors = tester.runTests();
assertTrue( errors.size() > 0, errors.toString());
}
@Test
public void testRunOfSpecializedHashCodeNoFields() throws Exception {
Class clazz = BadHashcodeClass.class;
BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());
HashcodeTestRunner<BadHashcodeClass> tester = new HashcodeTestRunner<>(clazz, beanInfo);
List<String> errors = tester.runTests();
assertTrue(errors.size() > 0, "Two different instances returned same hash code");
}
@Test
public void testRunOfSpecializedHashCodeFieldNoSetterOrGetter() throws Exception {
Class clazz = BadGetterSetterClass.class;
BeanInfo beanInfo = Introspector.getBeanInfo(clazz, clazz.getSuperclass());
HashcodeTestRunner<BadGetterSetterClass> tester = new HashcodeTestRunner<>(clazz, beanInfo, BadGetterSetterClass.getFieldsInHashCode());
List<String> errors = tester.runTests();
assertTrue(errors.size() == 0, errors.toString());
}
@Test
public void testRunOfSpecializedHashcodeBad
```
<Overlap Ratio: 0.9941256213285133>

---

--- 351 --
Question ID: 13d87cfac99c3a1ad318aa7f974abb2c4f7c17d2
Original Code:
```
public class LoginActionTest {
    @Test
    public void it_allows_users_to_input_their_credentials()
    {
        action.inputLoginCredentials();

        verify(responder).respondToInputLoginCredentials();
    }

    @Test
    public void it_provides_feedback_when_the_credentials_are_invalid()
    {
        action.attemptLogin(null, null);

        verify(responder).respondToInvalidLoginInput(input);
        assertThat(input.messages().size(), is(greaterThan(0)));
    }

    @Test
    public void it_provides_feedback_when_the_authentication_fails()
    {
        when(users.identifiedBy("luis")).thenReturn(null);

        action.attemptLogin("not_luis", "password does not really matter");

        verify(responder).respondToInvalidLoginAttemptWith(any(Credentials.class));
    }

    @Test
    public void it_provides_feedback_if_authentication_succeeds()
    {
        Password password = Password.fromPlainText("password!");
        User registeredUser = User.registeredWith(1, "luis", password.toString());
        when(users.identifiedBy("luis")).thenReturn(registeredUser);

        action.attemptLogin("luis", "password!");

        verify(responder).respondToASuccessfulAuthenticationOf(registeredUser);
    }

    @Before
    public void configureAction() {
        responder = mock(LoginResponder.class);
        input = new LoginInput();
        users = mock(Users.class);
        action = new LoginAction(responder, input, new AuthenticateUser(users));
    }

    private LoginAction action;
    private LoginResponder responder;
    private LoginInput input;
    private Users users;
}
```


Overlapping Code:
```
void it_allows_users_to_input_their_credentials()
{
action.inputLoginCredentials();
verify(responder).respondToInputLoginCredentials();
}
@Test
public void it_provides_feedback_when_the_credentials_are_invalid()
{
action.attemptLogin(null, null);
verify(responder).respondToInvalidLoginInput(input);
assertThat(input.messages().size(), is(greaterThan(0)));
}
@Test
public void it_provides_feedback_when_the_authentication_fails()
{
when(users.identifiedBy("luis")).thenReturn(null);
action.attemptLogonder).respondToInvalidLoginAttemptWith(any(Credentials.class));
}
@Test
public void it_provides_feedback_if_authentication_succeeds()
{
Password password = Password.fromPlainText("password!");
User registeredUser = User.registeredWith(1, "luis", password.toString());
when(users.identifiedBy("luis")).thenReturn(registeredUser);
action.attemptLogin("luis", "password!");
verify(responder).respondToASuccessfulAuthenticationOf(registeredUser);
}
@Before
public void configureAction() {
responder = mock(LoginResponder.class);
input = new LoginInput();
users = mock(Users.class);
action = new LoginAction(responder, input, new AuthenticateUser(users));
}
private LoginAction action;
private LoginResponder responder;
private LoginInput input;
private 
```
<Overlap Ratio: 0.9124087591240876>

---

--- 352 --
Question ID: 1167f80672d250758464e2b5a4bdfea8c781f1b8
Original Code:
```
@RunWith(MockitoJUnitRunner.class)
public class ProxyFactoryTest {

    private TestClass proxy;

    private CallInterceptor<TestClass> interceptor;

    @Before
    public void setUp() {
        interceptor = new CallInterceptor<>(TestClass.class);

        proxy = ProxyFactory.createProxy(TestClass.class, interceptor);
    }

    @Test
    public void realMethodShouldNotBeCalled() {
        proxy.delegate = mock(TestClass.class);
        proxy.testMethod("foo");

        verify(proxy.delegate, never()).testMethod(anyString());
    }

    @Test
    public void proxyRecordsArguementsUsedForCall() throws Throwable {
        proxy.testMethod("bar");

        final Call<TestClass> call = interceptor.getInvocationRecordingResult();

        assertThat(call.declaringClass()).isEqualTo(TestClass.class);
        assertThat(call.method()).isEqualTo(TestClass.class.getDeclaredMethod("testMethod", String.class));
        assertThat(call.args()).containsExactly("bar");
    }

    @Test
    public void proxyDoesNotRecordCallsToObjectMethods() throws Throwable {
        proxy.toString();

        final Call<TestClass> call = interceptor.getInvocationRecordingResult();
        assertThat(call.method()).isNull();
    }

    public static class TestClass {
        TestClass delegate = mock(TestClass.class);

        void testMethod(String name) {
            delegate.testMethod(name);
        }
    }

    @Test
    public void failsWithFinalMethod() throws Exception {
        assertThatThrownBy( //
                () -> ProxyFactory.createProxy(FailingTestClass.class, new CallInterceptor<>(FailingTestClass.class)) //
        )
            .isInstanceOf(IllegalStateException.class) //
            .hasMessage(
                    "The proxied class candidate com.mercateo.reflection.proxy.ProxyFactoryTest$FailingTestClass contains a final method 'test'");
    }

    public static class FailingTestClass {
        final public void test() {
        }
    }

    @Test
    public void skipsStaticMethod() throws Exception {
        ProxyFactory.createProxy(NotFailingTestClass.class, new CallInterceptor<>(NotFailingTestClass.class));
    }

    public static class NotFailingTestClass {
        static void test() {
        }
    }

}
```


Overlapping Code:
```
@RunWith(MockitoJUnitRunner.class)
public class ProxyFactoryTest {
private TestClass proxy;
private CallInterceptor<TestClass> interceptor;
@Before
public void setUp() {
interceptor = new CallInterceptor<>(TestClass.class);
proxy = ProxyFactory.createProxy(TestClass.class, interceptor);
}
@Test
public void realMethodShouldNotBeCalled() {
proxy.delegate = mock(TestClass.class);
proxy.testMethod("foo");
verify(proxy.delegate, never()).testMethod(anyString());
}
@Test
public void proxyRecordsArguementsUsedForCall() throws Throwable {
proxy.testMethod("bar");
final Call<TestClass> call = interceptor.getInvocationRecordingResult();
assertThat(call.declaringClass()).isEqualTo(TestClass.class);
assertThat(call.method()).isEqualTo(TestClass.class.getDeclaredMethod("testMethod", String.class));
assertThat(call.args()).containsExactly("bar");
}
@Test
public void proxyDoesNotRecordCallsToObjectMethods() throws Throwable {
proxy.toString();
final Call<TestClass> call = interceptor.getInvocationRecordingResult();
assertThat(call.method()).isNull();
}
public static class TestClass {
TestClass delegate = mock(TestClass.class);
void testMethod(String name) {
delegate.testMethod(name);
}
}
@Test
public void failsWithFinalMethod() throws Exception {
assertThatThrownBy( //
() -> ProxyFactory.createProxy(FailingTestClass.class, new CallInterceptor<>(FailingTestClass.class)) //
)
.isInstanceOf(IllegalStateException.class) //
.hasMessage(
"The proxied class candidate com.mercateo.reflection.proxy.ProxyFactoryTest$FailingTestClass contains a final method 'test'");
}
public static class FailingTestClass {
final public void test() {
}
}
@Test
public void skipsStaticMethod() throws Exception {
ProxyFactory.createProxy(NotFailingTestClass.class, new CallInterceptor<>(NotFailingTestClass.class));
}
public static class NotFailingTestClass 
```
<Overlap Ratio: 0.9850267379679144>

---

--- 353 --
Question ID: fa98542eb2cf1a97f76954f575041a15a89d52de
Original Code:
```
public class Score implements Comparable<Score> {

	private double score;
	private SemanticTrajectory t;

	public Score(double score, SemanticTrajectory t) {
		this.score = score;
		this.setTrajectory(t);
	}

	public double getScore() {
		return this.score;
	}

	@Override
	public int compareTo(Score score2) {
		if (this.score < score2.getScore()) {
			return -1;
		}
		if (this.score > score2.getScore()) {
			return 1;
		}
		return 0;
	}

	public SemanticTrajectory getTrajectory() {
		return t;
	}

	public void setTrajectory(SemanticTrajectory t) {
		this.t = t;
	}

}
```


Overlapping Code:
```
blic class Score implements Comparable<Score> {
private double score;
private SemanticTrajectory t;
public Score(double score, SemanticTrajectory t) {
this.score = score;
this.setTrajectory(t);
}
public double getScore() {
return this.score;
}
@Override
public int compareTo(Score score2) {
if (this.score < score2.getScore()) {
return -1;
}
if (this.score > score2.getScore()) {
return 1;
}
return 0;
}
public SemanticTrajectory getTrajectory() {
return t;
}
public void setTrajectory(SemanticTrajectory t) {
this.t 
```
<Overlap Ratio: 0.9810246679316889>

---

--- 354 --
Question ID: 647912a00cb6ddbc55949e312c38e2b982fb7ee6
Original Code:
```
@RestControllerAdvice
public class BaseExceptionHandler {
    private final Logger logger = LoggerFactory.getLogger(getClass());

    private final ResponseEntityExceptionHandler delegate = new ResponseEntityExceptionHandler() {
        @Override
        @NonNull
        protected ResponseEntity<Object> handleExceptionInternal(
                @NonNull Exception ex, Object body, HttpHeaders headers, HttpStatus status, @NonNull WebRequest request) {
            if (ex instanceof MethodArgumentNotValidException) {
                return handle((MethodArgumentNotValidException) ex, request);
            }
            final int statusValue = status.value();
            if (500 <= statusValue && statusValue < 600) {
                logger.error("internal error caught:", ex);
            }
            if (HttpStatus.INTERNAL_SERVER_ERROR.equals(status)) {
                request.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST);
            }
            final String requestURI = extractRequestURI(request);
            final Response<?> error = new Response<>(statusValue, status, ex.getMessage(), requestURI);
            return new ResponseEntity<>(error, headers, status);
        }
    };

    @ExceptionHandler({
            HttpRequestMethodNotSupportedException.class,
            HttpMediaTypeNotSupportedException.class,
            HttpMediaTypeNotAcceptableException.class,
            MissingPathVariableException.class,
            MissingServletRequestParameterException.class,
            ServletRequestBindingException.class,
            ConversionNotSupportedException.class,
            TypeMismatchException.class,
            HttpMessageNotReadableException.class,
            HttpMessageNotWritableException.class,
            MethodArgumentNotValidException.class,
            MissingServletRequestPartException.class,
            BindException.class,
            NoHandlerFoundException.class,
            AsyncRequestTimeoutException.class
    })
    public final ResponseEntity<Object> handleException(Exception ex, WebRequest request) throws Exception {
        return this.delegate.handleException(ex, request);
    }

    @ExceptionHandler(value = CodedBizException.class)
    public ResponseEntity<Response<?>> handle(final CodedBizException ex, WebRequest request) {
        return codedBizExceptionHandle(ex, request);
    }

    private ResponseEntity<Response<?>> codedBizExceptionHandle(final CodedBizException ex, WebRequest request) {
        final Throwable cause = ex.getCause();
        final String message = ex.getMessage();
        if (ex.isLogging()) {
            if (cause != null) {
                logger.error("{}", message, cause);
            } else {
                logger.error("{}", message, ex);
            }
        }
        final String requestURI = extractRequestURI(request);
        final Response<?> error;
        final int code = ex.getHttpStatus();
        final HttpStatus resolve = HttpStatus.resolve(code);
        final String bizCode = ex.getCode();
        if (cause != null) {
            final String causeMessage = cause.getMessage();
            if (resolve != null) {
                error = new Response<>(code, resolve.getReasonPhrase(), causeMessage, requestURI, bizCode, message);
            } else {
                error = new Response<>(code, "", causeMessage, requestURI, bizCode, message);
            }
        } else {
            if (resolve != null) {
                error = new Response<>(
                        code, resolve.getReasonPhrase(), message, requestURI, bizCode, message);
            } else {
                error = new Response<>(
                        code, "", message, requestURI, bizCode, message);
            }
        }
        return ResponseEntity.status(code).body(error);
    }

    @ExceptionHandler(value = ConstraintViolationException.class)
    public ResponseEntity<Response<?>> handle(final ConstraintViolationException ex, WebRequest request) {
        final HttpStatus status = HttpStatus.BAD_REQUEST;
        final String requestURI = extractRequestURI(request);
        final Response<?> descriptor = new Response<>(status.value(), status,
                ex.getConstraintViolations().stream()
                        .map(ConstraintViolation::getMessage).reduce((s, s2) -> s + "," + s2).orElse(""),
                requestURI);
        return ResponseEntity.status(status).body(descriptor);
    }

    @ExceptionHandler(Throwable.class)
    public ResponseEntity<Response<?>> handle(final Throwable throwable, WebRequest request) {
        logger.error("unexpected exception caught:", throwable);
        final HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR;
        final String requestURI = extractRequestURI(request);
        final Response<?> error = new Response<>(status.value(), status, throwable.getMessage(), requestURI);
        return new ResponseEntity<>(error, status);
    }

    @ExceptionHandler(HystrixRuntimeException.class)
    public ResponseEntity<Response<?>> handle(@NonNull final HystrixRuntimeException hystrixEx, WebRequest request) {
        final CodedBizException de = tryExtractCodedBizException(hystrixEx);
        if (de != null) {
            return this.handle(de, request);
        }
        return handle((Throwable) hystrixEx, request);
    }

    @Nullable
    private CodedBizException tryExtractCodedBizException(@NonNull final HystrixRuntimeException hystrixEx) {
        Throwable ex = hystrixEx;
        Throwable cause = ex.getCause();
        while (cause != null && cause != ex && !(cause instanceof CodedBizException)) {
            ex = cause;
            cause = cause.getCause();
        }
        if (cause instanceof CodedBizException) {
            return (CodedBizException) cause;
        }
        ex = hystrixEx.getFallbackException();
        cause = ex.getCause();
        while (cause != null && cause != ex && !(cause instanceof CodedBizException)) {
            ex = cause;
            cause = cause.getCause();
        }
        if (cause instanceof CodedBizException) {
            return (CodedBizException) cause;
        }
        return null;
    }

    private ResponseEntity<Object> handle(final MethodArgumentNotValidException ex, WebRequest request) {
        final HttpStatus status = HttpStatus.BAD_REQUEST;
        final String requestURI = extractRequestURI(request);
        final Response<?> descriptor = new Response<>(status.value(), status,
                ex.getBindingResult().getAllErrors().stream()
                        .map(DefaultMessageSourceResolvable::getDefaultMessage)
                        .reduce((s, s2) -> s + "," + s2).orElse(""),
                requestURI);
        return ResponseEntity.status(status).body(descriptor);
    }

    private String extractRequestURI(WebRequest request) {
        final String requestURI;
        if (request instanceof ServletWebRequest) {
            ServletWebRequest servletWebRequest = (ServletWebRequest) request;
            requestURI = servletWebRequest.getRequest().getRequestURI();
        } else {
            requestURI = "[can't detect]";
        }
        return requestURI;
    }
}
```


Overlapping Code:
```
RestControllerAdvice
public class BaseExceptionHandler {
private final Logger logger = LoggerFactory.getLogger(getClass());
private final ResponseEntityExceptionHandler delegate = new ResponseEntityExceptionHandler() {
@Override
@NonNull
protected ResponseEntity<Object> handleExceptionInternal(
@NonNull Exception ex, Object body, HttpHeaders headers, HttpStatus status, @NonNull WebRequest request) {
if (ex instanceof MethodArgumentNotValidException) {
return handle((MethodArgumentNotValidException) ex, request);
}
final int statusValue = status.value();
if (500 <= statusValue && statusValue < 600) {
logger.error("internal error caught:", ex);
}
if (HttpStatus.INTERNAL_SERVER_ERROR.equals(status)) {
request.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST);
}
final String requestURI = extractRequestURI(request);
final Response<?> error = new Response<>(statusValue, status, ex.getMessage(), requestURI);
return new ResponseEntity<>(error, headers, status);
}
};
@ExceptionHandler({
HttpRequestMethodNotSupportedException.class,
HttpMediaTypeNotSupportedException.class,
HttpMediaTypeNotAcceptableException.class,
MissingPathVariableException.class,
MissingServletRequestParameterException.class,
ServletRequestBindingException.class,
ConversionNotSupportedException.class,
TypeMismatchException.class,
HttpMessageNotReadableException.class,
HttpMessageNotWritableException.class,
MethodArgumentNotValidException.class,
MissingServletRequestPartException.class,
BindException.class,
NoHandlerFoundException.class,
AsyncRequestTimeoutException.class
})
public final ResponseEntity<Object> handleException(Exception ex, WebRequest request) throws Exception {
return this.delegate.handleException(ex, request);
}
@ExceptionHandler(value = CodedBizException.class)
public ResponseEntity<Response<?>> handle(final CodedBizException ex, WebRequest request) {
return codedBizExceptionHandle(ex, request);
}
private ResponseEntity<Response<?>> codedBizExceptionHandl
```
<Overlap Ratio: 0.9798822374877331>

---

--- 355 --
Question ID: a9b20e9e02b314bf0df27b7338ac21581e2ca8c5
Original Code:
```
public class OnePassSignatureVerificationWithPartialLengthLiteralDataRegressionTest {

    /**
     * Signed and Encrypted Message created with PGPainless 0.2.9.
     * PGPainless versions 0.2.10 - 0.2.18 fail to decrypt this message, due to it failing to parse the signatures trailing
     * the literal data. The cause for this was not draining the literal data first before trying to parse the sigs.
     * This is likely caused by the literal data using a partial length encoding scheme, so the PGPObjectFactory did not yet
     * reach the signatures packets.
     *
     * As a fix, PGPainless now only tries to parse signatures from after the literal data packet, once the literal data
     * stream gets closed.
     */
    public static final String MSG = "-----BEGIN PGP MESSAGE-----\n" +
            "Version: PGPainless\n" +
            "\n" +
            "aEY0RHRHcWVYOENCUGRzU0FRZEFVTjJrSkZNb2lJUHhCUEFSWkZodnJxU2FGd090\n" +
            "c3llR2pkU1l4bS9UdFJRd01JK09PUGJYVjlnUEM3VEZFemlKWmRmL0ZxcUVaQTNV\n" +
            "ZkhIeEo3Y0hnWlhQWWw1Q29LMU5aSW9NRC9udk1iT1poRjREYmtNdFV2TkpWL3dT\n" +
            "QVFkQW00b01SQXVVbTdYL1BZUTc3T3Q2ZUxwTWs2VDk3TmhHMzB6RFFDSUMvV1l3\n" +
            "TTUvZkR4dW1uVW5ucXNwVFVJSmhRMmVYM0I2R2NtVE5ZdXVmSUNIbGZKMU9UQk05\n" +
            "MklNMkVGWHU1M2x3TVBLYTB1a0IzRWltbmJRNUpCNTBpT2NUeDZCcDJQREJZK0VN\n" +
            "K29IdDVlUzFzOWxlZjJUNHdCY0w1ejFLU3hQTkRpODh6Skp6dTZ1b3BxMXFwdWVI\n" +
            "UDFtemYzN0NTY3lJTHpJK0lwRXVUbWwvODdyK294TWVQR3NvR3NwblBuUWFXa0xY\n" +
            "dzdGVHpnWUJ5SGxyS3gzTGJIT040bDFVbC90dnhMbFBwNE5aRmJQcjQwWlYxb0o4\n" +
            "eE9JczRTaXpZSTNDUGRXQmlNVXJiaDJRMEFBTkg4aWNyMjhDeUZneDFSenpGdFRZ\n" +
            "MzVjeE5HSXRRZzRoR3BNUmVOWDdWNHpWOFRsUkFJSEVtaFRCTHpGZXR4eWJCbFJh\n" +
            "c3l0SUN0eWVydnZiNTQ3V2htK2tDWUxRQUcyOUlwZXUxOWo2MnV1dHJjWm10YWJn\n" +
            "LzEyTG5HSEczRkxoMGxHTmNOZnd3OXN6VC9zV0RXM2swQ3RCdVpsSmFUVXFLYlY2\n" +
            "QkRsTjZMWXFvYi9ad01wcDE4WGVuTk5tU2ZsL2JpcHZ0UE1hMk5NdGVuWXV2SGVO\n" +
            "R2hZK3Q0MFE3NE5OYmJRV1dsVXFqakFYZ3NOaUhsTjhDV2Z3UG82Ykx1OW9PaEFL\n" +
            "eTgvbFlNL1dlL2hlUFFpVGpqUUVaM3J2OHVDVGdCekFuc2tqazd0bUVOdTdnclJz\n" +
            "WjBSdzlYelRwTzJlTCtHRmV3VlhOMzNWUzFHVnR5QTMyVFRCd1ZDcStaNEtCMXRX\n" +
            "MVFIRUlDekc2UldsMkR5djBmZENpc2FoQU5SLzBmQXRrZm0wU3k1R1htWm5pWU9L\n" +
            "MkhiN2NZeHEzREs1MHowWTN4WkdiemE4L2VUMzlPTG1jMG5DdWQ5cktHaUkya0Er\n" +
            "a0NDQzF5UUlrek9zZDZlU1pFR1FncFV5UHlxdDRNQUhYeDcxUkFuR0NiWW9OVkRY\n" +
            "aUQwZ0d0M2lZRHFJV1N0TGErek1xbkJWN085Z3lSZFFVN2lXR25CeW9QNnlXc1Nk\n" +
            "aVBRSW5RR3RVSFZabU0wQnBwUk45ZUo0QlVJd2RvY0lIRldjZ0xNQjNiYlBDWHVF\n" +
            "bGl6N1ZPSHBFVWVYVmNWNWl6Z3NVUEJOSVVOZWxHcElrSk5Xa0lSSndMSFVnUlR0\n" +
            "SEh1ZFMyNnJZeURoU0tGcjdiM01HdWwyVU9GdTFlM0FzK24yVkJjcGN0ZHFtTGxG\n" +
            "THU3ZGxHMGJ0dHJQVWhaYyt4NjlFenUraTRtamRoZzZyVC9ydnYvRTJmRTRUVlpN\n" +
            "MGExbk5CUG40UT09\n" +
            "=mKyE\n" +
            "-----END PGP MESSAGE-----";

    public static final String KEY = "-----BEGIN PGP PRIVATE KEY BLOCK-----\n" +
            "Version: PGPainless\n" +
            "Comment: 23A2 3010 2038 66BC B390  8598 BB0C CFD4 57D4 DE77\n" +
            "Comment: xmpp:one@exampletwo.org\n" +
            "\n" +
            "lFgEYXQMCRYJKwYBBAHaRw8BAQdA1NhQdMUKkiwSI92ETqlY2lrAt4EbehgzpWMs\n" +
            "sm1Ke34AAP4sx3S3r0qoNpGyi3o7zfet60xIIkw9qKNdnYQyvouFhRFftBd4bXBw\n" +
            "Om9uZUBleGFtcGxldHdvLm9yZ4h4BBMWCgAgBQJhdAwJAhsBBRYCAwEABRUKCQgL\n" +
            "BAsJCAcCHgECGQEACgkQuwzP1FfU3ncAWQD/dUR7rbOpV8H4CTIpDJXiDuWi1vkC\n" +
            "Rmm5jFQsJlrIzZEA/0aZSEXH3Gj5OdQGy9qKrvqGkq7idjrTkh3gYiWRB+EOnF0E\n" +
            "YXQMCRIKKwYBBAGXVQEFAQEHQCobua4HJAsmfCB9TFjBSRfP1FEIEht4MMl4rHN4\n" +
            "eWc0AwEIBwAA/0Tmh56XX8bVDof1VVCdapcCC+LAA3wSH5SfP+EVaIJoD8WIdQQY\n" +
            "FgoAHQUCYXQMCQIbDAUWAgMBAAUVCgkICwQLCQgHAh4BAAoJELsMz9RX1N533dQB\n" +
            "ANRojORnaZw224DRVhONAuQazhKZz3e13MhyTFi91BhmAP9chFgUkvpiorQ6I65D\n" +
            "iCM315VHIvorrIElhKDtYu65CZxYBGF0DAkWCSsGAQQB2kcPAQEHQB3vy1KMKzDG\n" +
            "/yooOsvfNXtdFh8ROWWth2CZAh1rt3fdAAD+KVMkDED4xf7h1/aAunFAmdZ+xGTo\n" +
            "uPbTr8vWQMrVUFAUi4jVBBgWCgB9BQJhdAwJAhsCBRYCAwEABRUKCQgLBAsJCAcC\n" +
            "HgFfIAQZFgoABgUCYXQMCQAKCRDFaY6lJy4mR/FEAP9dHZi975eqlSdRa5pEn1xz\n" +
            "TLBfz2mAfWLQEr2kWLLVRAD+JBsyldKsUF8q1m/D/ty0lUUSGslgOhTcEoXxx3yC\n" +
            "1wwACgkQuwzP1FfU3neefwEA82brBIEKARYD/zHwNEPGLZweZHLPV5Iu9dmBw3l9\n" +
            "tmoA/RlQYaAKD86S1ZcfPIbjDIZkL9sjFh5tK0+mSl8rv4UH\n" +
            "=/1RX\n" +
            "-----END PGP PRIVATE KEY BLOCK-----";

    public static final String CERT = "-----BEGIN PGP PUBLIC KEY BLOCK-----\n" +
            "Version: PGPainless\n" +
            "Comment: FC0A 2CB3 F757 8B26 442C  7091 A7BA 7031 BD1E 0D5F\n" +
            "Comment: xmpp:one@exampleone.org\n" +
            "\n" +
            "mDMEYXQMCRYJKwYBBAHaRw8BAQdA01hwFPFYUpsGGUpf21BUlwoL9tVVAnR3sS+J\n" +
            "UZSUlka0F3htcHA6b25lQGV4YW1wbGVvbmUub3JniHgEExYKACAFAmF0DAkCGwEF\n" +
            "FgIDAQAFFQoJCAsECwkIBwIeAQIZAQAKCRCnunAxvR4NX+f7AQCjzT+r25dDlUpp\n" +
            "tocSQtgEmWZabwB41ykD/XfyBtM0RAD/ba4yYv+f/4mX7u3XpJxkrKFs/bHwyWsR\n" +
            "VapeUGxhKwa4OARhdAwJEgorBgEEAZdVAQUBAQdAlbrJ+h8CygRFZBsx+Rsm4Kp+\n" +
            "VCB7yUR2IxOrmiGqUlsDAQgHiHUEGBYKAB0FAmF0DAkCGwwFFgIDAQAFFQoJCAsE\n" +
            "CwkIBwIeAQAKCRCnunAxvR4NX3bmAP4mTtMWgKl7RkAB/pSLMJ4bbTMSMUJCH/jS\n" +
            "qz/PNtmVrgD+JLrWg2+hNPAA8zJx8LH73G4YzZMSQ0CBd9nmWRZr3w+4MwRhdAwJ\n" +
            "FgkrBgEEAdpHDwEBB0BrLuiD0Xb6/N66IehUl77qh/Q0vDa8ack6TcOIwxZsHIjV\n" +
            "BBgWCgB9BQJhdAwJAhsCBRYCAwEABRUKCQgLBAsJCAcCHgFfIAQZFgoABgUCYXQM\n" +
            "CQAKCRD97UDyQowaGe1MAPwJeSe2vkEcMIk711lBbAsambR7D72XVyc0F8maniUy\n" +
            "LwD8Dbgx8O0bCcd7fcXztfyZe8OtGKQk19fSLd+xp5VThwkACgkQp7pwMb0eDV8y\n" +
            "aQEA+g10lq+1gkaLBXZbc/mUJ4odIjYBk0JdGgU8oTAZd58A/2UT9C5G9ht/lMhK\n" +
            "hISFnP6CXwvy6L1XA9bjXQJ0unMF\n" +
            "=OyZq\n" +
            "-----END PGP PUBLIC KEY BLOCK-----";

    @Test
    public void testDecryptAndVerify_0_2_9_message() throws IOException, PGPException {
        PGPSecretKeyRing secretKeys = PGPainless.readKeyRing().secretKeyRing(KEY);
        PGPPublicKeyRing cert = PGPainless.readKeyRing().publicKeyRing(CERT);
        ByteArrayOutputStream out = new ByteArrayOutputStream();

        ByteArrayOutputStream dearmored = new ByteArrayOutputStream();
        ArmoredInputStream armorIn = new ArmoredInputStream(new ByteArrayInputStream(MSG.getBytes(StandardCharsets.UTF_8)));
        Streams.pipeAll(armorIn, dearmored);
        armorIn.close();

        ByteArrayInputStream in = new ByteArrayInputStream(dearmored.toByteArray());

        DecryptionStream decryptionStream = PGPainless.decryptAndOrVerify()
                .onInputStream(in)
                .withOptions(new ConsumerOptions()
                        .addVerificationCert(cert)
                        .addDecryptionKey(secretKeys));

        Streams.pipeAll(decryptionStream, out);
        decryptionStream.close();
        decryptionStream.getResult();
    }
}
```


Overlapping Code:
```
lass OnePassSignatureVerificationWithPartialLengthLiteralDataRegressionTest {
/**
* Signed and Encrypted Message created with PGPainless 0.2.9.
* PGPainless versions 0.2.10 - 0.2.18 fail to decrypt this message, due to it failing to parse the signatures trailing
* the literal data. The cause for this was not draining the literal data first before trying to parse the sigs.
* This is likely caused by the literal data using a partial length encoding scheme, so the PGPObjectFactory did not yet
* reach the signatures packets.
*
* As a fix, PGPainless now only tries to parse signatures from after the literal data packet, once the literal data
* stream gets closed.
*/
public static final String MSG = "-----BEGIN PGP MESSAGE-----\n" +
"Version: PGPainless\n" +
"\n" +
"aEY0RHRHcWVYOENCUGRzU0FRZEFVTjJrSkZNb2lJUHhCUEFSWkZodnJxU2FGd090\n" +
"c3llR2pkU1l4bS9UdFJRd01JK09PUGJYVjlnUEM3VEZFemlKWmRmL0ZxcUVaQTNV\n" +
"ZkhIeEo3Y0hnWlhQWWw1Q29LMU5aSW9NRC9udk1iT1poRjREYmtNdFV2TkpWL3dT\n" +
"QVFkQW00b01SQXVVbTdYL1BZUTc3T3Q2ZUxwTWs2VDk3TmhHMzB6RFFDSUMvV1l3\n" +
"TTUvZkR4dW1uVW5ucXNwVFVJSmhRMmVYM0I2R2NtVE5ZdXVmSUNIbGZKMU9UQk05\n" +
"MklNMkVGWHU1M2x3TVBLYTB1a0IzRWltbmJRNUpCNTBpT2NUeDZCcDJQREJZK0VN\n" +
"K29IdDVlUzFzOWxlZjJUNHdCY0w1ejFLU3hQTkRpODh6Skp6dTZ1b3BxMXFwdWVI\n" +
"UDFtemYzN0NTY3lJTHpJK0lwRXVUbWwvODdyK294TWVQR3NvR3NwblBuUWFXa0xY\n" +
"dzdGVHpnWUJ5SGxyS3gzTGJIT040bDFVbC90dnhMbFBwNE5aRmJQcjQwWlYxb0o4\n" +
"eE9JczRTaXpZSTNDUGRXQmlNVXJiaDJRMEFBTkg4aWNyMjhDeUZneDFSenpGdFRZ\n" +
"MzVjeE5HSXRRZzRoR3BNUmVOWDdWNHpWOFRsUkFJSEVtaFRCTHpGZXR4eWJCbFJh\n" +
"c3l0SUN0eWVydnZiNTQ3V2htK2tDWUxRQUcyOUlwZXUxOWo2MnV1dHJjWm10YWJn\n" +
"LzEyTG5HSEczRkxoMGxHTmNOZnd3OXN6VC9zV0RXM2swQ3RCdVpsSmFUVXFLYlY2\n" +
"QkRsTjZMWXFvYi9ad01wcDE4WGVuTk5tU2ZsL2JpcHZ0UE1hMk5NdGVuWXV2SGVO\n" +
"R2hZK3Q0MFE3NE5OYmJRV1dsVXFqakFYZ3NOaUhsTjhDV2Z3UG82Ykx1OW9PaEFL\n" +
"eTgvbFlNL1dlL2hlUFFpVGpqUUVaM3J2OHVDVGdCekFuc2tqazd0bUVOdTdnclJz\n" +
"WjBSdzlYelRwTzJlTCtHRmV3VlhOMzNWUzFHVnR5QTMyVFRCd1ZDcStaNEtCMXRX\n" +
"MVFIRUlDekc2UldsMkR5djBmZENpc2FoQU5SLzBmQXRrZm0wU3k1R1htWm5pWU9L\n" +
"MkhiN2NZeHEzREs1MHowWTN4WkdiemE4L2VUMzlPTG1jMG5DdWQ5cktHaUkya0Er\n" +
"a0NDQzF5UUlrek9zZDZlU1pFR1FncF
```
<Overlap Ratio: 0.9857863365428703>

---

--- 356 --
Question ID: 22fdfe969053dc549bef8f8429d68e7938478eff
Original Code:
```
class Solution {
    public int compareVersion(String version1, String version2) {
        int n = version1.length();
        int m = version2.length();

        // compare level by level
        boolean if1done = false;
        boolean if2done = false;
        
        while(true) {
            int val1;
            if (if1done)
                val1 = 0;
            else {
                int end1 = version1.indexOf('.');
                if (end1 == -1) {
                    val1 = Integer.valueOf(version1);
                    if1done = true;
                } else  {
                    val1 = Integer.valueOf(version1.substring(0, end1));
                    version1 = version1.substring(end1 + 1);
                    n -= end1 + 1;
                }
            }
                
            int val2;
            if (if2done)
                val2 = 0;
            else {
                int end2 = version2.indexOf('.');
                if (end2 == -1)
                    val2 = Integer.valueOf(version2);
                if (end2 == -1) {
                    val2 = Integer.valueOf(version2);
                    if2done = true;
                } else {
                    val2 = Integer.valueOf(version2.substring(0, end2));
                    version2 = version2.substring(end2 + 1);
                    n -= end2 + 1;
                }
            }
            
            
            if (val1 > val2)
                return 1;
            else if (val1 < val2)
                return -1;
            else if (if1done && if2done)
                return 0;
        }
    }
}
```


Overlapping Code:
```
class Solution {
public int compareVersion(String version1, String version2) {
int n = version1.length();
int m = version2.length();
// compare level by level
boolean if1done = false;
boolean if2done = false;

while(true) {
int val1;
if (if1done)
val1 = 0;
else {
int end1 = version1.indexOf('.');
if (end1 == -1) {
val1 = Integer.valueOf(version1);
if1done = true;
} else {
val1 = Integer.valueOf(version1.substring(0, end1));
version1 = version1.substring(end1 + 1);
n -= end1 + 1;
}
}

int val2;
if (if2done)
val2 = 0;
else {
int end2 = version2.indexOf('.');
if (end2 == -1)
val2 = Integer.valueOf(version2);
if (end2 == -1) {
val2 = Integer.valueOf(version2);
if2done = true;
} else {
val2 = Integer.valueOf(version2.substring(0, end2));
version2 = version2.substring(end2 + 1);
n -= end2 + 1;
}
}


if (val1 > val2)
return 1;
else if (val1 < val2)
return -1;
```
<Overlap Ratio: 0.9504950495049505>

---

--- 357 --
Question ID: 51da26424db1ce4133463ca48656f0ba823c718a
Original Code:
```
public class JobRebalancer extends TaskRebalancer {
  private static final Logger LOG = LoggerFactory.getLogger(JobRebalancer.class);
  private static TaskAssignmentCalculator _fixTaskAssignmentCal =
      new FixedTargetTaskAssignmentCalculator();
  private static TaskAssignmentCalculator _genericTaskAssignmentCal =
      new GenericTaskAssignmentCalculator();

  private static final String PREV_RA_NODE = "PreviousResourceAssignment";

  @Override
  public ResourceAssignment computeBestPossiblePartitionState(ClusterDataCache clusterData,
      IdealState taskIs, Resource resource, CurrentStateOutput currStateOutput) {
    final String jobName = resource.getResourceName();
    LOG.debug("Computer Best Partition for job: " + jobName);

    // Fetch job configuration
    JobConfig jobCfg = clusterData.getJobConfig(jobName);
    if (jobCfg == null) {
      LOG.error("Job configuration is NULL for " + jobName);
      return buildEmptyAssignment(jobName, currStateOutput);
    }
    String workflowResource = jobCfg.getWorkflow();

    // Fetch workflow configuration and context
    WorkflowConfig workflowCfg = clusterData.getWorkflowConfig(workflowResource);
    if (workflowCfg == null) {
      LOG.error("Workflow configuration is NULL for " + jobName);
      return buildEmptyAssignment(jobName, currStateOutput);
    }

    WorkflowContext workflowCtx = clusterData.getWorkflowContext(workflowResource);
    if (workflowCtx == null) {
      LOG.error("Workflow context is NULL for " + jobName);
      return buildEmptyAssignment(jobName, currStateOutput);
    }

    TargetState targetState = workflowCfg.getTargetState();
    if (targetState != TargetState.START && targetState != TargetState.STOP) {
      LOG.info("Target state is " + targetState.name() + " for workflow " + workflowResource
          + ".Stop scheduling job " + jobName);
      return buildEmptyAssignment(jobName, currStateOutput);
    }

    // Stop current run of the job if workflow or job is already in final state (failed or completed)
    TaskState workflowState = workflowCtx.getWorkflowState();
    TaskState jobState = workflowCtx.getJobState(jobName);
    // The job is already in a final state (completed/failed).
    if (workflowState == TaskState.FAILED || workflowState == TaskState.COMPLETED ||
        jobState == TaskState.FAILED || jobState == TaskState.COMPLETED) {
      LOG.info(String.format(
          "Workflow %s or job %s is already failed or completed, workflow state (%s), job state (%s), clean up job IS.",
          workflowResource, jobName, workflowState, jobState));
      TaskUtil.cleanupJobIdealStateExtView(_manager.getHelixDataAccessor(), jobName);
      _rebalanceScheduler.removeScheduledRebalance(jobName);
      return buildEmptyAssignment(jobName, currStateOutput);
    }

    if (!isWorkflowReadyForSchedule(workflowCfg)) {
      LOG.info("Job is not ready to be run since workflow is not ready " + jobName);
      return buildEmptyAssignment(jobName, currStateOutput);
    }

    if (!isJobStarted(jobName, workflowCtx) && !isJobReadyToSchedule(jobName, workflowCfg,
        workflowCtx, getInCompleteJobCount(workflowCfg, workflowCtx),
        clusterData.getJobConfigMap())) {
      LOG.info("Job is not ready to run " + jobName);
      return buildEmptyAssignment(jobName, currStateOutput);
    }

    // Fetch any existing context information from the property store.
    JobContext jobCtx = clusterData.getJobContext(jobName);
    if (jobCtx == null) {
      jobCtx = new JobContext(new ZNRecord(TaskUtil.TASK_CONTEXT_KW));
      jobCtx.setStartTime(System.currentTimeMillis());
      jobCtx.setName(jobName);
      workflowCtx.setJobState(jobName, TaskState.IN_PROGRESS);
    }

    scheduleRebalanceForJobTimeout(jobCfg, jobCtx);

    // Grab the old assignment, or an empty one if it doesn't exist
    ResourceAssignment prevAssignment = getPrevResourceAssignment(jobName);
    if (prevAssignment == null) {
      prevAssignment = new ResourceAssignment(jobName);
    }

    // Will contain the list of partitions that must be explicitly dropped from the ideal state that
    // is stored in zk.
    // Fetch the previous resource assignment from the property store. This is required because of
    // HELIX-230.
    Set<String> liveInstances = jobCfg.getInstanceGroupTag() == null
        ? clusterData.getEnabledLiveInstances()
        : clusterData.getEnabledLiveInstancesWithTag(jobCfg.getInstanceGroupTag());

    if (liveInstances.isEmpty()) {
      LOG.error("No available instance found for job!");
    }

    Set<Integer> partitionsToDrop = new TreeSet<Integer>();
    ResourceAssignment newAssignment =
        computeResourceMapping(jobName, workflowCfg, jobCfg, prevAssignment, liveInstances,
            currStateOutput, workflowCtx, jobCtx, partitionsToDrop, clusterData);

    HelixDataAccessor accessor = _manager.getHelixDataAccessor();
    PropertyKey propertyKey = accessor.keyBuilder().idealStates(jobName);
    taskIs = clusterData.getIdealState(jobName);
    if (!partitionsToDrop.isEmpty() && taskIs != null) {
      for (Integer pId : partitionsToDrop) {
        taskIs.getRecord().getMapFields().remove(pName(jobName, pId));
      }
      accessor.setProperty(propertyKey, taskIs);
    }

    // Update Workflow and Job context in data cache and ZK.
    clusterData.updateJobContext(jobName, jobCtx, _manager.getHelixDataAccessor());
    clusterData
        .updateWorkflowContext(workflowResource, workflowCtx, _manager.getHelixDataAccessor());

    setPrevResourceAssignment(jobName, newAssignment);

    LOG.debug("Job " + jobName + " new assignment " + Arrays
        .toString(newAssignment.getMappedPartitions().toArray()));
    return newAssignment;
  }

  private Set<String> getExcludedInstances(String currentJobName,
      WorkflowConfig workflowCfg, ClusterDataCache cache) {
    Set<String> ret = new HashSet<String>();

    if (!workflowCfg.isAllowOverlapJobAssignment()) {
      // exclude all instances that has been assigned other jobs' tasks
      for (String jobName : workflowCfg.getJobDag().getAllNodes()) {
        if (jobName.equals(currentJobName)) {
          continue;
        }
        JobContext jobContext = cache.getJobContext(jobName);
        if (jobContext == null) {
          continue;
        }
        for (int pId : jobContext.getPartitionSet()) {
          TaskPartitionState partitionState = jobContext.getPartitionState(pId);
          if (partitionState == TaskPartitionState.INIT || partitionState == TaskPartitionState.RUNNING) {
            ret.add(jobContext.getAssignedParticipant(pId));
          }
        }
      }
    }
    return ret;
  }

  private ResourceAssignment computeResourceMapping(String jobResource,
      WorkflowConfig workflowConfig, JobConfig jobCfg, ResourceAssignment prevTaskToInstanceStateAssignment,
      Collection<String> liveInstances, CurrentStateOutput currStateOutput,
      WorkflowContext workflowCtx, JobContext jobCtx, Set<Integer> partitionsToDropFromIs,
      ClusterDataCache cache) {
    TargetState jobTgtState = workflowConfig.getTargetState();
    TaskState jobState = workflowCtx.getJobState(jobResource);

    if (jobState == TaskState.IN_PROGRESS && isJobTimeout(jobCtx, jobCfg)) {
      jobState = TaskState.TIMING_OUT;
      workflowCtx.setJobState(jobResource, TaskState.TIMING_OUT);
    } else if (jobState != TaskState.TIMING_OUT && jobState != TaskState.FAILING) {
      // TIMING_OUT/FAILING/ABORTING job can't be stopped, because all tasks are being aborted
      // Update running status in workflow context
      if (jobTgtState == TargetState.STOP) {
        if (checkJobStopped(jobCtx)) {
          workflowCtx.setJobState(jobResource, TaskState.STOPPED);
        } else {
          workflowCtx.setJobState(jobResource, TaskState.STOPPING);
        }
        // Workflow has been stopped if all in progress jobs are stopped
        if (isWorkflowStopped(workflowCtx, workflowConfig)) {
          workflowCtx.setWorkflowState(TaskState.STOPPED);
        } else {
          workflowCtx.setWorkflowState(TaskState.STOPPING);
        }
      } else {
        workflowCtx.setJobState(jobResource, TaskState.IN_PROGRESS);
        // Workflow is in progress if any task is in progress
        workflowCtx.setWorkflowState(TaskState.IN_PROGRESS);
      }
    }

    // Used to keep track of tasks that have already been assigned to instances.
    Set<Integer> assignedPartitions = new HashSet<Integer>();

    // Used to keep track of tasks that have failed, but whose failure is acceptable
    Set<Integer> skippedPartitions = new HashSet<Integer>();

    // Keeps a mapping of (partition) -> (instance, state)
    Map<Integer, PartitionAssignment> paMap = new TreeMap<Integer, PartitionAssignment>();

    Set<String> excludedInstances = getExcludedInstances(jobResource, workflowConfig, cache);

    // Process all the current assignments of tasks.
    TaskAssignmentCalculator taskAssignmentCal = getAssignmentCalulator(jobCfg);
    Set<Integer> allPartitions = taskAssignmentCal
        .getAllTaskPartitions(jobCfg, jobCtx, workflowConfig, workflowCtx, cache.getIdealStates());

    if (allPartitions == null || allPartitions.isEmpty()) {
      // Empty target partitions, mark the job as FAILED.
      String failureMsg = "Empty task partition mapping for job " + jobResource + ", marked the job as FAILED!";
      LOG.info(failureMsg);
      jobCtx.setInfo(failureMsg);
      failJob(jobResource, workflowCtx, jobCtx, workflowConfig, cache.getJobConfigMap());
      markAllPartitionsError(jobCtx, TaskPartitionState.ERROR, false);
      return new ResourceAssignment(jobResource);
    }

    Map<String, SortedSet<Integer>> prevInstanceToTaskAssignments =
        getPrevInstanceToTaskAssignments(liveInstances, prevTaskToInstanceStateAssignment, allPartitions);
    long currentTime = System.currentTimeMillis();

    LOG.debug("All partitions: " + allPartitions + " taskAssignment: " + prevInstanceToTaskAssignments
        + " excludedInstances: " + excludedInstances);

    // Iterate through all instances
    for (String instance : prevInstanceToTaskAssignments.keySet()) {
      if (excludedInstances.contains(instance)) {
        continue;
      }

      Set<Integer> pSet = prevInstanceToTaskAssignments.get(instance);
      // Used to keep track of partitions that are in one of the final states: COMPLETED, TIMED_OUT,
      // TASK_ERROR, ERROR.
      Set<Integer> donePartitions = new TreeSet<Integer>();
      for (int pId : pSet) {
        final String pName = pName(jobResource, pId);
        TaskPartitionState currState =
            updateJobContextAndGetTaskCurrentState(currStateOutput, jobResource, pId, pName, instance, jobCtx);

        // Check for pending state transitions on this (partition, instance).
        Message pendingMessage =
            currStateOutput.getPendingState(jobResource, new Partition(pName), instance);
        if (pendingMessage != null && !pendingMessage.getToState().equals(currState.name())) {
          processTaskWithPendingMessage(prevTaskToInstanceStateAssignment, pId, pName, instance,
              pendingMessage, jobState, currState, paMap, assignedPartitions);
          continue;
        }

        // Process any requested state transitions.
        String requestedStateStr =
            currStateOutput.getRequestedState(jobResource, new Partition(pName), instance);
        if (requestedStateStr != null && !requestedStateStr.isEmpty()) {
          TaskPartitionState requestedState = TaskPartitionState.valueOf(requestedStateStr);
          if (requestedState.equals(currState)) {
            LOG.warn(String.format(
                "Requested state %s is the same as the current state for instance %s.",
                requestedState, instance));
          }

          paMap.put(pId, new PartitionAssignment(instance, requestedState.name()));
          assignedPartitions.add(pId);
          LOG.debug(String.format(
              "Instance %s requested a state transition to %s for partition %s.", instance,
              requestedState, pName));
          continue;
        }

        switch (currState) {
        case RUNNING: {
          TaskPartitionState nextState = TaskPartitionState.RUNNING;
          if (jobState == TaskState.TIMING_OUT) {
            nextState = TaskPartitionState.TASK_ABORTED;
          } else if (jobTgtState == TargetState.STOP) {
            nextState = TaskPartitionState.STOPPED;
          }

          paMap.put(pId, new PartitionAssignment(instance, nextState.name()));
          assignedPartitions.add(pId);
          LOG.debug(String.format("Setting task partition %s state to %s on instance %s.", pName,
              nextState, instance));
        }
          break;
        case STOPPED: {
          TaskPartitionState nextState;
          if (jobTgtState == TargetState.START) {
            nextState = TaskPartitionState.RUNNING;
          } else {
            nextState = TaskPartitionState.STOPPED;
          }

          paMap.put(pId, new PartitionAssignment(instance, nextState.name()));
          assignedPartitions.add(pId);
          LOG.debug(String.format("Setting task partition %s state to %s on instance %s.", pName,
              nextState, instance));
        }
          break;
        case COMPLETED: {
          // The task has completed on this partition. Mark as such in the context object.
          donePartitions.add(pId);
          LOG.debug(String
              .format(
                  "Task partition %s has completed with state %s. Marking as such in rebalancer context.",
                  pName, currState));
          partitionsToDropFromIs.add(pId);
          markPartitionCompleted(jobCtx, pId);
        }
          break;
        case TIMED_OUT:
        case TASK_ERROR:
        case TASK_ABORTED:
        case ERROR: {
          donePartitions.add(pId); // The task may be rescheduled on a different instance.
          LOG.debug(String.format(
              "Task partition %s has error state %s with msg %s. Marking as such in rebalancer context.", pName,
              currState, jobCtx.getPartitionInfo(pId)));
          markPartitionError(jobCtx, pId, currState, true);
          // The error policy is to fail the task as soon a single partition fails for a specified
          // maximum number of attempts or task is in ABORTED state.
          // But notice that if job is TIMED_OUT, aborted task won't be treated as fail and won't cause job fail.
          // After all tasks are aborted, they will be dropped, because of job timeout.
          if (jobState != TaskState.TIMED_OUT && jobState != TaskState.TIMING_OUT) {
            if (jobCtx.getPartitionNumAttempts(pId) >= jobCfg.getMaxAttemptsPerTask()
                || currState.equals(TaskPartitionState.TASK_ABORTED)
                || currState.equals(TaskPartitionState.ERROR)) {
              skippedPartitions.add(pId);
              partitionsToDropFromIs.add(pId);
              LOG.debug("skippedPartitions:" + skippedPartitions);
            } else {
              // Mark the task to be started at some later time (if enabled)
              markPartitionDelayed(jobCfg, jobCtx, pId);
            }
          }
        }
          break;
        case INIT:
        case DROPPED: {
          // currState in [INIT, DROPPED]. Do nothing, the partition is eligible to be reassigned.
          donePartitions.add(pId);
          LOG.debug(String.format(
              "Task partition %s has state %s. It will be dropped from the current ideal state.",
              pName, currState));
        }
          break;
        default:
          throw new AssertionError("Unknown enum symbol: " + currState);
        }
      }

      // Remove the set of task partitions that are completed or in one of the error states.
      pSet.removeAll(donePartitions);
    }

    addGiveupPartitions(skippedPartitions, jobCtx, allPartitions, jobCfg);

    if (jobState == TaskState.IN_PROGRESS && skippedPartitions.size() > jobCfg.getFailureThreshold()) {
      if (isJobFinished(jobCtx, jobResource, currStateOutput)) {
        failJob(jobResource, workflowCtx, jobCtx, workflowConfig, cache.getJobConfigMap());
        return buildEmptyAssignment(jobResource, currStateOutput);
      }
      workflowCtx.setJobState(jobResource, TaskState.FAILING);
      // Drop all assigned but not given-up tasks
      for (int pId : jobCtx.getPartitionSet()) {
        String instance = jobCtx.getAssignedParticipant(pId);
        if (jobCtx.getPartitionState(pId) != null && !isTaskGivenup(jobCtx, jobCfg, pId)) {
          paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.TASK_ABORTED.name()));
        }
        Partition partition = new Partition(pName(jobResource, pId));
        Message pendingMessage = currStateOutput.getPendingState(jobResource, partition, instance);
        // While job is failing, if the task is pending on INIT->RUNNING, set it back to INIT,
        // so that Helix will cancel the transition.
        if (jobCtx.getPartitionState(pId) == TaskPartitionState.INIT && pendingMessage != null) {
          paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.INIT.name()));
        }
      }

      return toResourceAssignment(jobResource, paMap);
    }

    if (jobState == TaskState.FAILING && isJobFinished(jobCtx, jobResource, currStateOutput)) {
      failJob(jobResource, workflowCtx, jobCtx, workflowConfig, cache.getJobConfigMap());
      return buildEmptyAssignment(jobResource, currStateOutput);
    }

    if (isJobComplete(jobCtx, allPartitions, jobCfg)) {
      markJobComplete(jobResource, jobCtx, workflowConfig, workflowCtx,
          cache.getJobConfigMap());
      _clusterStatusMonitor.updateJobCounters(jobCfg, TaskState.COMPLETED,
          jobCtx.getFinishTime() - jobCtx.getStartTime());
      _rebalanceScheduler.removeScheduledRebalance(jobResource);
      TaskUtil.cleanupJobIdealStateExtView(_manager.getHelixDataAccessor(), jobResource);
      return buildEmptyAssignment(jobResource, currStateOutput);
    }

    // If job is being timed out and no task is running (for whatever reason), idealState can be deleted and all tasks
    // can be dropped(note that Helix doesn't track whether the drop is success or not).
    if (jobState == TaskState.TIMING_OUT && isJobFinished(jobCtx, jobResource, currStateOutput)) {
      jobCtx.setFinishTime(System.currentTimeMillis());
      workflowCtx.setJobState(jobResource, TaskState.TIMED_OUT);
      // Mark all INIT task to TASK_ABORTED
      for (int pId : jobCtx.getPartitionSet()) {
        if (jobCtx.getPartitionState(pId) == TaskPartitionState.INIT) {
          jobCtx.setPartitionState(pId, TaskPartitionState.TASK_ABORTED);
        }
      }
      _clusterStatusMonitor.updateJobCounters(jobCfg, TaskState.TIMED_OUT);
      _rebalanceScheduler.removeScheduledRebalance(jobResource);
      TaskUtil.cleanupJobIdealStateExtView(_manager.getHelixDataAccessor(), jobResource);
      return buildEmptyAssignment(jobResource, currStateOutput);
    }

    // For delayed tasks, trigger a rebalance event for the closest upcoming ready time
    scheduleForNextTask(jobResource, jobCtx, currentTime);

    // Make additional task assignments if needed.
    if (jobState != TaskState.TIMING_OUT && jobState != TaskState.TIMED_OUT && jobTgtState == TargetState.START) {
      // Contains the set of task partitions that must be excluded from consideration when making
      // any new assignments.
      // This includes all completed, failed, delayed, and already assigned partitions.
      Set<Integer> excludeSet = Sets.newTreeSet(assignedPartitions);
      addCompletedTasks(excludeSet, jobCtx, allPartitions);
      addGiveupPartitions(excludeSet, jobCtx, allPartitions, jobCfg);
      excludeSet.addAll(skippedPartitions);
      excludeSet.addAll(getNonReadyPartitions(jobCtx, currentTime));
      // Get instance->[partition, ...] mappings for the target resource.
      Map<String, SortedSet<Integer>> tgtPartitionAssignments = taskAssignmentCal
          .getTaskAssignment(currStateOutput, prevTaskToInstanceStateAssignment, liveInstances, jobCfg, jobCtx,
              workflowConfig, workflowCtx, allPartitions, cache.getIdealStates());

      if (!isGenericTaskJob(jobCfg) || jobCfg.isRebalanceRunningTask()) {
        dropRebalancedRunningTasks(tgtPartitionAssignments, prevInstanceToTaskAssignments, paMap,
            jobCtx);
      }

      for (Map.Entry<String, SortedSet<Integer>> entry : prevInstanceToTaskAssignments.entrySet()) {
        String instance = entry.getKey();
        if (!tgtPartitionAssignments.containsKey(instance) || excludedInstances
            .contains(instance)) {
          continue;
        }
        // 1. throttled by job configuration
        // Contains the set of task partitions currently assigned to the instance.
        Set<Integer> pSet = entry.getValue();
        int jobCfgLimitation = jobCfg.getNumConcurrentTasksPerInstance() - pSet.size();
        // 2. throttled by participant capacity
        int participantCapacity = cache.getInstanceConfigMap().get(instance).getMaxConcurrentTask();
        if (participantCapacity == InstanceConfig.MAX_CONCURRENT_TASK_NOT_SET) {
          participantCapacity = cache.getClusterConfig().getMaxConcurrentTaskPerInstance();
        }
        int participantLimitation = participantCapacity - cache.getParticipantActiveTaskCount(instance);
        // New tasks to be assigned
        int numToAssign = Math.min(jobCfgLimitation, participantLimitation);
        LOG.debug(String.format(
            "Throttle tasks to be assigned to instance %s using limitation: Job Concurrent Task(%d), "
                + "Participant Max Task(%d). Remaining capacity %d.", instance, jobCfgLimitation, participantCapacity,
            numToAssign));
        if (numToAssign > 0) {
          Set<Integer> throttledSet = new HashSet<Integer>();
          List<Integer> nextPartitions =
              getNextPartitions(tgtPartitionAssignments.get(instance), excludeSet, throttledSet, numToAssign);
          for (Integer pId : nextPartitions) {
            String pName = pName(jobResource, pId);
            paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.RUNNING.name()));
            excludeSet.add(pId);
            jobCtx.setAssignedParticipant(pId, instance);
            jobCtx.setPartitionState(pId, TaskPartitionState.INIT);
            jobCtx.setPartitionStartTime(pId, System.currentTimeMillis());
            LOG.debug(String.format("Setting task partition %s state to %s on instance %s.", pName,
                TaskPartitionState.RUNNING, instance));
          }
          cache.setParticipantActiveTaskCount(instance, cache.getParticipantActiveTaskCount(instance) + nextPartitions.size());
          if (!throttledSet.isEmpty()) {
            LOG.debug(throttledSet.size() + "tasks are ready but throttled when assigned to participant.");
          }
        }
      }
    }

    return toResourceAssignment(jobResource, paMap);
  }

  private ResourceAssignment toResourceAssignment(String jobResource, Map<Integer, PartitionAssignment> paMap) {
    // Construct a ResourceAssignment object from the map of partition assignments.
    ResourceAssignment ra = new ResourceAssignment(jobResource);
    for (Map.Entry<Integer, PartitionAssignment> e : paMap.entrySet()) {
      PartitionAssignment pa = e.getValue();
      ra.addReplicaMap(new Partition(pName(jobResource, e.getKey())),
          ImmutableMap.of(pa._instance, pa._state));
    }
    return ra;
  }

  /**
   * If assignment is different from previous assignment, drop the old running task if it's no
   * longer assigned to the same instance, but not removing it from excludeSet because the same task
   * should not be assigned to the new instance right way.
   */
  private void dropRebalancedRunningTasks(Map<String, SortedSet<Integer>> newAssignment,
      Map<String, SortedSet<Integer>> oldAssignment, Map<Integer, PartitionAssignment> paMap,
      JobContext jobContext) {
    for (String instance : oldAssignment.keySet()) {
      for (Integer pId : oldAssignment.get(instance)) {
        if (jobContext.getPartitionState(pId) == TaskPartitionState.RUNNING
                && !newAssignment.get(instance).contains(pId)) {
            paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.DROPPED.name()));
            jobContext.setPartitionState(pId, TaskPartitionState.DROPPED);
        }
      }
    }
  }

  private TaskPartitionState updateJobContextAndGetTaskCurrentState(CurrentStateOutput currentStateOutput,
      String jobResource, Integer pId, String pName, String instance, JobContext jobCtx) {
    String currentStateString = currentStateOutput.getCurrentState(jobResource, new Partition(
        pName), instance);
    if (currentStateString == null) {
      // Task state is either DROPPED or INIT
      return jobCtx.getPartitionState(pId);
    }
    TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);
    jobCtx.setPartitionState(pId, currentState);
    String taskMsg = currentStateOutput.getInfo(jobResource, new Partition(
        pName), instance);
    if (taskMsg != null) {
      jobCtx.setPartitionInfo(pId, taskMsg);
    }
    return currentState;
  }

  private void processTaskWithPendingMessage(ResourceAssignment prevAssignment, Integer pId, String pName,
      String instance, Message pendingMessage, TaskState jobState, TaskPartitionState currState,
      Map<Integer, PartitionAssignment> paMap, Set<Integer> assignedPartitions) {

    Map<String, String> stateMap = prevAssignment.getReplicaMap(new Partition(pName));
    if (stateMap != null) {
      String prevState = stateMap.get(instance);
      if (!pendingMessage.getToState().equals(prevState)) {
        LOG.warn(String.format("Task pending to-state is %s while previous assigned state is %s. This should not"
            + "heppen.", pendingMessage.getToState(), prevState));
      }
      if (jobState == TaskState.TIMING_OUT
          && currState == TaskPartitionState.INIT
          && prevState.equals(TaskPartitionState.RUNNING.name())) {
        // While job is timing out, if the task is pending on INIT->RUNNING, set it back to INIT,
        // so that Helix will cancel the transition.
        paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.INIT.name()));
        assignedPartitions.add(pId);
        if (LOG.isDebugEnabled()) {
          LOG.debug(String.format(
              "Task partition %s has a pending state transition on instance %s INIT->RUNNING. "
                  + "Setting it back to INIT so that Helix can cancel the transition(if enabled).",
              pName, instance, prevState));
        }
      } else {
        // Otherwise, Just copy forward
        // the state assignment from the previous ideal state.
        paMap.put(pId, new PartitionAssignment(instance, prevState));
        assignedPartitions.add(pId);
        if (LOG.isDebugEnabled()) {
          LOG.debug(String.format(
              "Task partition %s has a pending state transition on instance %s. Using the previous ideal state which was %s.",
              pName, instance, prevState));
        }
      }
    }
  }

  private void failJob(String jobName, WorkflowContext workflowContext, JobContext jobContext,
      WorkflowConfig workflowConfig, Map<String, JobConfig> jobConfigMap) {
    markJobFailed(jobName, jobContext, workflowConfig, workflowContext, jobConfigMap);
    // Mark all INIT task to TASK_ABORTED
    for (int pId : jobContext.getPartitionSet()) {
      if (jobContext.getPartitionState(pId) == TaskPartitionState.INIT) {
        jobContext.setPartitionState(pId, TaskPartitionState.TASK_ABORTED);
      }
    }
    _clusterStatusMonitor.updateJobCounters(jobConfigMap.get(jobName), TaskState.FAILED);
    _rebalanceScheduler.removeScheduledRebalance(jobName);
    TaskUtil.cleanupJobIdealStateExtView(_manager.getHelixDataAccessor(), jobName);
  }

  private boolean isJobTimeout(JobContext jobContext, JobConfig jobConfig) {
    long jobTimeoutTime = computeJobTimeoutTime(jobContext, jobConfig);
    return jobTimeoutTime != jobConfig.DEFAULT_TIMEOUT_NEVER && jobTimeoutTime <= System
        .currentTimeMillis();
  }

  private boolean isJobFinished(JobContext jobContext, String jobResource,
      CurrentStateOutput currentStateOutput) {
    for (int pId : jobContext.getPartitionSet()) {
      TaskPartitionState state = jobContext.getPartitionState(pId);
      Partition partition = new Partition(pName(jobResource, pId));
      String instance = jobContext.getAssignedParticipant(pId);
      Message pendingMessage = currentStateOutput.getPendingState(jobResource, partition, instance);
      // If state is INIT but is pending INIT->RUNNING, it's not yet safe to say the job finished
      if (state == TaskPartitionState.RUNNING
          || (state == TaskPartitionState.INIT && pendingMessage != null)) {
        return false;
      }
    }
    return true;
  }

  // Return jobConfig.DEFAULT_TIMEOUT_NEVER if job should never timeout.
  // job start time can't be -1 before calling this method.
  private long computeJobTimeoutTime(JobContext jobContext, JobConfig jobConfig) {
    return (jobConfig.getTimeout() == JobConfig.DEFAULT_TIMEOUT_NEVER
        || jobConfig.getTimeout() > Long.MAX_VALUE - jobContext.getStartTime()) // check long overflow
        ? jobConfig.DEFAULT_TIMEOUT_NEVER
        : jobContext.getStartTime() + jobConfig.getTimeout();
  }

  private void markJobComplete(String jobName, JobContext jobContext, WorkflowConfig workflowConfig,
      WorkflowContext workflowContext, Map<String, JobConfig> jobConfigMap) {
    long currentTime = System.currentTimeMillis();
    workflowContext.setJobState(jobName, TaskState.COMPLETED);
    jobContext.setFinishTime(currentTime);
    if (isWorkflowFinished(workflowContext, workflowConfig, jobConfigMap)) {
      workflowContext.setFinishTime(currentTime);
    }
    scheduleJobCleanUp(jobConfigMap.get(jobName), workflowConfig, currentTime);
  }

  private void scheduleForNextTask(String job, JobContext jobCtx, long now) {
    // Figure out the earliest schedulable time in the future of a non-complete job
    boolean shouldSchedule = false;
    long earliestTime = Long.MAX_VALUE;
    for (int p : jobCtx.getPartitionSet()) {
      long retryTime = jobCtx.getNextRetryTime(p);
      TaskPartitionState state = jobCtx.getPartitionState(p);
      state = (state != null) ? state : TaskPartitionState.INIT;
      Set<TaskPartitionState> errorStates =
          Sets.newHashSet(TaskPartitionState.ERROR, TaskPartitionState.TASK_ERROR,
              TaskPartitionState.TIMED_OUT);
      if (errorStates.contains(state) && retryTime > now && retryTime < earliestTime) {
        earliestTime = retryTime;
        shouldSchedule = true;
      }
    }

    // If any was found, then schedule it
    if (shouldSchedule) {
      long scheduledTime = _rebalanceScheduler.getRebalanceTime(job);
      if (scheduledTime == -1 || earliestTime < scheduledTime) {
        _rebalanceScheduler.scheduleRebalance(_manager, job, earliestTime);
      }
    }
  }

  // Set job timeout rebalance, if the time is earlier than the current scheduled rebalance time
  // This needs to run for every rebalance because the scheduled rebalance could be removed in other places.
  private void scheduleRebalanceForJobTimeout(JobConfig jobCfg, JobContext jobCtx) {
    long jobTimeoutTime = computeJobTimeoutTime(jobCtx, jobCfg);
    if (jobTimeoutTime != JobConfig.DEFAULT_TIMEOUT_NEVER && jobTimeoutTime > System.currentTimeMillis()) {
      long nextRebalanceTime = _rebalanceScheduler.getRebalanceTime(jobCfg.getJobId());
      if (nextRebalanceTime == JobConfig.DEFAULT_TIMEOUT_NEVER || jobTimeoutTime < nextRebalanceTime) {
        _rebalanceScheduler.scheduleRebalance(_manager, jobCfg.getJobId(), jobTimeoutTime);
      }
    }
  }

  /**
   * Get the last task assignment for a given job
   *
   * @param resourceName the name of the job
   * @return {@link ResourceAssignment} instance, or null if no assignment is available
   */
  private ResourceAssignment getPrevResourceAssignment(String resourceName) {
    ZNRecord r = _manager.getHelixPropertyStore()
        .get(Joiner.on("/").join(TaskConstants.REBALANCER_CONTEXT_ROOT, resourceName, PREV_RA_NODE),
            null, AccessOption.PERSISTENT);
    return r != null ? new ResourceAssignment(r) : null;
  }

  /**
   * Set the last task assignment for a given job
   *
   * @param resourceName the name of the job
   * @param ra           {@link ResourceAssignment} containing the task assignment
   */
  private void setPrevResourceAssignment(String resourceName,
      ResourceAssignment ra) {
    _manager.getHelixPropertyStore()
        .set(Joiner.on("/").join(TaskConstants.REBALANCER_CONTEXT_ROOT, resourceName, PREV_RA_NODE),
            ra.getRecord(), AccessOption.PERSISTENT);
  }

  /**
   * Checks if the job has completed.
   * Look at states of all tasks of the job, there're 3 kind: completed, given up, not given up.
   * The job is completed if all tasks are completed or given up, and the number of given up tasks is within job
   * failure threshold.
   */
  private static boolean isJobComplete(JobContext ctx, Set<Integer> allPartitions, JobConfig cfg) {
    int numOfGivenUpTasks = 0;
    // Iterate through all tasks, if any one indicates the job has not completed, return false.
    for (Integer pId : allPartitions) {
      TaskPartitionState state = ctx.getPartitionState(pId);
      if (state != TaskPartitionState.COMPLETED) {
        if(!isTaskGivenup(ctx, cfg, pId)) {
          return false;
        }
        // If the task is given up, there's still chance the job has completed because of job failure threshold.
        numOfGivenUpTasks++;
      }
    }
    return numOfGivenUpTasks <= cfg.getFailureThreshold();
  }

  private static void addCompletedTasks(Set<Integer> set, JobContext ctx,
      Iterable<Integer> pIds) {
    for (Integer pId : pIds) {
      TaskPartitionState state = ctx.getPartitionState(pId);
      if (state == TaskPartitionState.COMPLETED) {
        set.add(pId);
      }
    }
  }

  private static boolean isTaskGivenup(JobContext ctx, JobConfig cfg, int pId) {
    TaskPartitionState state = ctx.getPartitionState(pId);
    if (state == TaskPartitionState.TASK_ABORTED || state == TaskPartitionState.ERROR) {
      return true;
    }
    if (state == TaskPartitionState.TIMED_OUT || state == TaskPartitionState.TASK_ERROR) {
      return ctx.getPartitionNumAttempts(pId) >= cfg.getMaxAttemptsPerTask();
    }
    return false;
  }

  // add all partitions that have been tried maxNumberAttempts
  private static void addGiveupPartitions(Set<Integer> set, JobContext ctx, Iterable<Integer> pIds,
      JobConfig cfg) {
    for (Integer pId : pIds) {
      if (isTaskGivenup(ctx, cfg, pId)) {
        set.add(pId);
      }
    }
  }

  private static List<Integer> getNextPartitions(SortedSet<Integer> candidatePartitions,
      Set<Integer> excluded, Set<Integer> throttled, int n) {
    List<Integer> result = new ArrayList<Integer>();
    for (Integer pId : candidatePartitions) {
      if (!excluded.contains(pId)) {
        if (result.size() < n) {
          result.add(pId);
        } else {
          throttled.add(pId);
        }
      }
    }
    return result;
  }

  private static void markPartitionDelayed(JobConfig cfg, JobContext ctx, int p) {
    long delayInterval = cfg.getTaskRetryDelay();
    if (delayInterval <= 0) {
      return;
    }
    long nextStartTime = ctx.getPartitionFinishTime(p) + delayInterval;
    ctx.setNextRetryTime(p, nextStartTime);
  }

  private static void markPartitionCompleted(JobContext ctx, int pId) {
    ctx.setPartitionState(pId, TaskPartitionState.COMPLETED);
    ctx.setPartitionFinishTime(pId, System.currentTimeMillis());
    ctx.incrementNumAttempts(pId);
  }

  private static void markPartitionError(JobContext ctx, int pId, TaskPartitionState state,
      boolean incrementAttempts) {
    ctx.setPartitionState(pId, state);
    ctx.setPartitionFinishTime(pId, System.currentTimeMillis());
    if (incrementAttempts) {
      ctx.incrementNumAttempts(pId);
    }
  }

  private static void markAllPartitionsError(JobContext ctx, TaskPartitionState state,
      boolean incrementAttempts) {
    for (int pId : ctx.getPartitionSet()) {
      markPartitionError(ctx, pId, state, incrementAttempts);
    }
  }

  /**
   * @param liveInstances
   * @param prevAssignment task partition -> (instance -> state)
   * @param allTaskPartitions all task partitionIds
   * @return instance -> partitionIds from previous assignment, if the instance is still live
   */
  private static Map<String, SortedSet<Integer>> getPrevInstanceToTaskAssignments(
      Iterable<String> liveInstances, ResourceAssignment prevAssignment, Set<Integer> allTaskPartitions) {
    Map<String, SortedSet<Integer>> result = new HashMap<String, SortedSet<Integer>>();
    for (String instance : liveInstances) {
      result.put(instance, new TreeSet<Integer>());
    }

    for (Partition partition : prevAssignment.getMappedPartitions()) {
      int pId = getPartitionId(partition.getPartitionName());
      if (allTaskPartitions.contains(pId)) {
        Map<String, String> replicaMap = prevAssignment.getReplicaMap(partition);
        for (String instance : replicaMap.keySet()) {
          SortedSet<Integer> pList = result.get(instance);
          if (pList != null) {
            pList.add(pId);
          }
        }
      }
    }
    return result;
  }

  /* Extracts the partition id from the given partition name. */
  private static int getPartitionId(String pName) {
    int index = pName.lastIndexOf("_");
    if (index == -1) {
      throw new HelixException("Invalid partition name " + pName);
    }
    return Integer.valueOf(pName.substring(index + 1));
  }

  private static Set<Integer> getNonReadyPartitions(JobContext ctx, long now) {
    Set<Integer> nonReadyPartitions = Sets.newHashSet();
    for (int p : ctx.getPartitionSet()) {
      long toStart = ctx.getNextRetryTime(p);
      if (now < toStart) {
        nonReadyPartitions.add(p);
      }
    }
    return nonReadyPartitions;
  }

  private TaskAssignmentCalculator getAssignmentCalulator(JobConfig jobConfig) {
    return isGenericTaskJob(jobConfig) ? _genericTaskAssignmentCal : _fixTaskAssignmentCal;
  }

  private boolean isGenericTaskJob(JobConfig jobConfig) {
    Map<String, TaskConfig> taskConfigMap = jobConfig.getTaskConfigMap();
    return taskConfigMap != null && !taskConfigMap.isEmpty();
  }

  /**
   * Check whether tasks are not in final states
   * @param jobContext The job context
   * @return           False if still tasks not in final state. Otherwise return true
   */
  private boolean checkJobStopped(JobContext jobContext) {
    for (int partition : jobContext.getPartitionSet()) {
      TaskPartitionState taskState = jobContext.getPartitionState(partition);
      if (taskState == TaskPartitionState.RUNNING) {
        return false;
      }
    }
    return true;
  }

  /**
   * Computes the partition name given the resource name and partition id.
   */
  private String pName(String resource, int pId) {
    return resource + "_" + pId;
  }

  /**
   * An (instance, state) pair.
   */
  private static class PartitionAssignment {
    private final String _instance;
    private final String _state;

    private PartitionAssignment(String instance, String state) {
      _instance = instance;
      _state = state;
    }
  }
}
```


Overlapping Code:
```
cer extends TaskRebalancer {
private static final Logger LOG = LoggerFactory.getLogger(JobRebalancer.class);
private static TaskAssignmentCalculator _fixTaskAssignmentCal =
new FixedTargetTaskAssignmentCalculator();
private static TaskAssignmentCalculator _genericTaskAssignmentCal =
new GenericTaskAssignmentCalculator();
private static final String PREV_RA_NODE = "PreviousResourceAssignment";
@Override
public ResourceAssignment computeBestPossiblePartitionState(ClusterDataCache clusterData,
IdealState taskIs, Resource resource, CurrentStateOutput currStateOutput) {
final String jobName = resource.getResourceName();
LOG.debug("Computer Best Partition for job: " + jobName);
// Fetch job configuration
JobConfig jobCfg = clusterData.getJobConfig(jobName);
if (jobCfg == null) {
LOG.error("Job configuration is NULL for " + jobName);
return buildEmptyAssignment(jobName, currStateOutput);
}
String workflowResource = jobCfg.getWorkflow();
// Fetch workflow configuration and context
WorkflowConfig workflowCfg = clusterData.getWorkflowConfig(workflowResource);
if (workflowCfg == null) {
LOG.error("Workflow configuration is NULL for " + jobName);
return buildEmptyAssignment(jobName, currStateOutput);
}
WorkflowContext workflowCtx = clusterData.getWorkflowContext(workflowResource);
if (workflowCtx == null) {
LOG.error("Workflow context is NULL for " + jobName);
return buildEmptyAssignment(jobName, currStateOutput);
}
TargetState targetState = workflowCfg.getTargetState();
if (targetState != TargetState.START && targetState != TargetState.STOP) {
LOG.info("Target state is " + targetState.name() + " for workflow " + workflowResource
+ ".Stop scheduling job " + jobName);
return buildEmptyAssignment(jobName, currStateOutput);
}
// Stop current run of the job if workflow or job is already in final state (failed or completed)
TaskState workflowState = workflowCtx.getWorkflowState();
TaskState jobState = workflowCtx.getJobState(jobName);
// The job is already in a final state (completed/failed).
if (workflowState == TaskState.FAILED || workflowState == TaskState.COMPLETED ||
jobState == TaskState.FAILED || jobState == TaskState.COMPLETED) {
LOG.info(String.format(
"Workflow %s or job %s is already failed or completed, workflow sta
```
<Overlap Ratio: 0.9821038847664775>

---

--- 358 --
Question ID: 2ddc4a07970d8ff4ae630f5a409afd82f94739ac
Original Code:
```
public  final class DeviceCredentials extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:opencannabis.device.DeviceCredentials)
    DeviceCredentialsOrBuilder {
private static final long serialVersionUID = 0L;
  // Use DeviceCredentials.newBuilder() to construct.
  private DeviceCredentials(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private DeviceCredentials() {
    publicKey_ = com.google.protobuf.ByteString.EMPTY;
    privateKey_ = com.google.protobuf.ByteString.EMPTY;
    sha256_ = "";
    identity_ = "";
    authorities_ = java.util.Collections.emptyList();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private DeviceCredentials(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 10: {

            publicKey_ = input.readBytes();
            break;
          }
          case 18: {

            privateKey_ = input.readBytes();
            break;
          }
          case 26: {
            java.lang.String s = input.readStringRequireUtf8();

            sha256_ = s;
            break;
          }
          case 34: {
            java.lang.String s = input.readStringRequireUtf8();

            identity_ = s;
            break;
          }
          case 42: {
            if (!((mutable_bitField0_ & 0x00000010) != 0)) {
              authorities_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
              mutable_bitField0_ |= 0x00000010;
            }
            authorities_.add(input.readBytes());
            break;
          }
          default: {
            if (!parseUnknownField(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      if (((mutable_bitField0_ & 0x00000010) != 0)) {
        authorities_ = java.util.Collections.unmodifiableList(authorities_); // C
      }
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.opencannabis.schema.device.DeviceCredentials.class, io.opencannabis.schema.device.DeviceCredentials.Builder.class);
  }

  private int bitField0_;
  public static final int PUBLIC_KEY_FIELD_NUMBER = 1;
  private com.google.protobuf.ByteString publicKey_;
  /**
   * <pre>
   * Raw bytes for a device's public key.
   * </pre>
   *
   * <code>bytes public_key = 1 [(.gen_bq_schema.ignore) = true];</code>
   */
  public com.google.protobuf.ByteString getPublicKey() {
    return publicKey_;
  }

  public static final int PRIVATE_KEY_FIELD_NUMBER = 2;
  private com.google.protobuf.ByteString privateKey_;
  /**
   * <pre>
   * Raw bytes for the device's private key.
   * </pre>
   *
   * <code>bytes private_key = 2 [(.gen_bq_schema.ignore) = true];</code>
   */
  public com.google.protobuf.ByteString getPrivateKey() {
    return privateKey_;
  }

  public static final int SHA256_FIELD_NUMBER = 3;
  private volatile java.lang.Object sha256_;
  /**
   * <pre>
   * SHA256 hash of this device's public key.
   * </pre>
   *
   * <code>string sha256 = 3 [(.gen_bq_schema.description) = "SHA256 hash of this device&#92;'s public key."];</code>
   */
  public java.lang.String getSha256() {
    java.lang.Object ref = sha256_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      sha256_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * SHA256 hash of this device's public key.
   * </pre>
   *
   * <code>string sha256 = 3 [(.gen_bq_schema.description) = "SHA256 hash of this device&#92;'s public key."];</code>
   */
  public com.google.protobuf.ByteString
      getSha256Bytes() {
    java.lang.Object ref = sha256_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      sha256_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int IDENTITY_FIELD_NUMBER = 4;
  private volatile java.lang.Object identity_;
  /**
   * <pre>
   * A device's raw identity payload.
   * </pre>
   *
   * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>
   */
  public java.lang.String getIdentity() {
    java.lang.Object ref = identity_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      identity_ = s;
      return s;
    }
  }
  /**
   * <pre>
   * A device's raw identity payload.
   * </pre>
   *
   * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>
   */
  public com.google.protobuf.ByteString
      getIdentityBytes() {
    java.lang.Object ref = identity_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      identity_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int AUTHORITIES_FIELD_NUMBER = 5;
  private java.util.List<com.google.protobuf.ByteString> authorities_;
  /**
   * <pre>
   * Repeated PEM authority payloads, asserted as trusted by the server.
   * </pre>
   *
   * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>
   */
  public java.util.List<com.google.protobuf.ByteString>
      getAuthoritiesList() {
    return authorities_;
  }
  /**
   * <pre>
   * Repeated PEM authority payloads, asserted as trusted by the server.
   * </pre>
   *
   * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>
   */
  public int getAuthoritiesCount() {
    return authorities_.size();
  }
  /**
   * <pre>
   * Repeated PEM authority payloads, asserted as trusted by the server.
   * </pre>
   *
   * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>
   */
  public com.google.protobuf.ByteString getAuthorities(int index) {
    return authorities_.get(index);
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (!publicKey_.isEmpty()) {
      output.writeBytes(1, publicKey_);
    }
    if (!privateKey_.isEmpty()) {
      output.writeBytes(2, privateKey_);
    }
    if (!getSha256Bytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3, sha256_);
    }
    if (!getIdentityBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 4, identity_);
    }
    for (int i = 0; i < authorities_.size(); i++) {
      output.writeBytes(5, authorities_.get(i));
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (!publicKey_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeBytesSize(1, publicKey_);
    }
    if (!privateKey_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeBytesSize(2, privateKey_);
    }
    if (!getSha256Bytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, sha256_);
    }
    if (!getIdentityBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, identity_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < authorities_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeBytesSizeNoTag(authorities_.get(i));
      }
      size += dataSize;
      size += 1 * getAuthoritiesList().size();
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.opencannabis.schema.device.DeviceCredentials)) {
      return super.equals(obj);
    }
    io.opencannabis.schema.device.DeviceCredentials other = (io.opencannabis.schema.device.DeviceCredentials) obj;

    if (!getPublicKey()
        .equals(other.getPublicKey())) return false;
    if (!getPrivateKey()
        .equals(other.getPrivateKey())) return false;
    if (!getSha256()
        .equals(other.getSha256())) return false;
    if (!getIdentity()
        .equals(other.getIdentity())) return false;
    if (!getAuthoritiesList()
        .equals(other.getAuthoritiesList())) return false;
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + PUBLIC_KEY_FIELD_NUMBER;
    hash = (53 * hash) + getPublicKey().hashCode();
    hash = (37 * hash) + PRIVATE_KEY_FIELD_NUMBER;
    hash = (53 * hash) + getPrivateKey().hashCode();
    hash = (37 * hash) + SHA256_FIELD_NUMBER;
    hash = (53 * hash) + getSha256().hashCode();
    hash = (37 * hash) + IDENTITY_FIELD_NUMBER;
    hash = (53 * hash) + getIdentity().hashCode();
    if (getAuthoritiesCount() > 0) {
      hash = (37 * hash) + AUTHORITIES_FIELD_NUMBER;
      hash = (53 * hash) + getAuthoritiesList().hashCode();
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.opencannabis.schema.device.DeviceCredentials parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.opencannabis.schema.device.DeviceCredentials parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.opencannabis.schema.device.DeviceCredentials parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.opencannabis.schema.device.DeviceCredentials prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * Credentials that assert a device's identity or authorization.
   * </pre>
   *
   * Protobuf type {@code opencannabis.device.DeviceCredentials}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:opencannabis.device.DeviceCredentials)
      io.opencannabis.schema.device.DeviceCredentialsOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.opencannabis.schema.device.DeviceCredentials.class, io.opencannabis.schema.device.DeviceCredentials.Builder.class);
    }

    // Construct using io.opencannabis.schema.device.DeviceCredentials.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      publicKey_ = com.google.protobuf.ByteString.EMPTY;

      privateKey_ = com.google.protobuf.ByteString.EMPTY;

      sha256_ = "";

      identity_ = "";

      authorities_ = java.util.Collections.emptyList();
      bitField0_ = (bitField0_ & ~0x00000010);
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.opencannabis.schema.device.DeviceOuterClass.internal_static_opencannabis_device_DeviceCredentials_descriptor;
    }

    @java.lang.Override
    public io.opencannabis.schema.device.DeviceCredentials getDefaultInstanceForType() {
      return io.opencannabis.schema.device.DeviceCredentials.getDefaultInstance();
    }

    @java.lang.Override
    public io.opencannabis.schema.device.DeviceCredentials build() {
      io.opencannabis.schema.device.DeviceCredentials result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public io.opencannabis.schema.device.DeviceCredentials buildPartial() {
      io.opencannabis.schema.device.DeviceCredentials result = new io.opencannabis.schema.device.DeviceCredentials(this);
      int from_bitField0_ = bitField0_;
      int to_bitField0_ = 0;
      result.publicKey_ = publicKey_;
      result.privateKey_ = privateKey_;
      result.sha256_ = sha256_;
      result.identity_ = identity_;
      if (((bitField0_ & 0x00000010) != 0)) {
        authorities_ = java.util.Collections.unmodifiableList(authorities_);
        bitField0_ = (bitField0_ & ~0x00000010);
      }
      result.authorities_ = authorities_;
      result.bitField0_ = to_bitField0_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.opencannabis.schema.device.DeviceCredentials) {
        return mergeFrom((io.opencannabis.schema.device.DeviceCredentials)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.opencannabis.schema.device.DeviceCredentials other) {
      if (other == io.opencannabis.schema.device.DeviceCredentials.getDefaultInstance()) return this;
      if (other.getPublicKey() != com.google.protobuf.ByteString.EMPTY) {
        setPublicKey(other.getPublicKey());
      }
      if (other.getPrivateKey() != com.google.protobuf.ByteString.EMPTY) {
        setPrivateKey(other.getPrivateKey());
      }
      if (!other.getSha256().isEmpty()) {
        sha256_ = other.sha256_;
        onChanged();
      }
      if (!other.getIdentity().isEmpty()) {
        identity_ = other.identity_;
        onChanged();
      }
      if (!other.authorities_.isEmpty()) {
        if (authorities_.isEmpty()) {
          authorities_ = other.authorities_;
          bitField0_ = (bitField0_ & ~0x00000010);
        } else {
          ensureAuthoritiesIsMutable();
          authorities_.addAll(other.authorities_);
        }
        onChanged();
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      io.opencannabis.schema.device.DeviceCredentials parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (io.opencannabis.schema.device.DeviceCredentials) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }
    private int bitField0_;

    private com.google.protobuf.ByteString publicKey_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Raw bytes for a device's public key.
     * </pre>
     *
     * <code>bytes public_key = 1 [(.gen_bq_schema.ignore) = true];</code>
     */
    public com.google.protobuf.ByteString getPublicKey() {
      return publicKey_;
    }
    /**
     * <pre>
     * Raw bytes for a device's public key.
     * </pre>
     *
     * <code>bytes public_key = 1 [(.gen_bq_schema.ignore) = true];</code>
     */
    public Builder setPublicKey(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      publicKey_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Raw bytes for a device's public key.
     * </pre>
     *
     * <code>bytes public_key = 1 [(.gen_bq_schema.ignore) = true];</code>
     */
    public Builder clearPublicKey() {
      
      publicKey_ = getDefaultInstance().getPublicKey();
      onChanged();
      return this;
    }

    private com.google.protobuf.ByteString privateKey_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Raw bytes for the device's private key.
     * </pre>
     *
     * <code>bytes private_key = 2 [(.gen_bq_schema.ignore) = true];</code>
     */
    public com.google.protobuf.ByteString getPrivateKey() {
      return privateKey_;
    }
    /**
     * <pre>
     * Raw bytes for the device's private key.
     * </pre>
     *
     * <code>bytes private_key = 2 [(.gen_bq_schema.ignore) = true];</code>
     */
    public Builder setPrivateKey(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      privateKey_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Raw bytes for the device's private key.
     * </pre>
     *
     * <code>bytes private_key = 2 [(.gen_bq_schema.ignore) = true];</code>
     */
    public Builder clearPrivateKey() {
      
      privateKey_ = getDefaultInstance().getPrivateKey();
      onChanged();
      return this;
    }

    private java.lang.Object sha256_ = "";
    /**
     * <pre>
     * SHA256 hash of this device's public key.
     * </pre>
     *
     * <code>string sha256 = 3 [(.gen_bq_schema.description) = "SHA256 hash of this device&#92;'s public key."];</code>
     */
    public java.lang.String getSha256() {
      java.lang.Object ref = sha256_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        sha256_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * SHA256 hash of this device's public key.
     * </pre>
     *
     * <code>string sha256 = 3 [(.gen_bq_schema.description) = "SHA256 hash of this device&#92;'s public key."];</code>
     */
    public com.google.protobuf.ByteString
        getSha256Bytes() {
      java.lang.Object ref = sha256_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sha256_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * SHA256 hash of this device's public key.
     * </pre>
     *
     * <code>string sha256 = 3 [(.gen_bq_schema.description) = "SHA256 hash of this device&#92;'s public key."];</code>
     */
    public Builder setSha256(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      sha256_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * SHA256 hash of this device's public key.
     * </pre>
     *
     * <code>string sha256 = 3 [(.gen_bq_schema.description) = "SHA256 hash of this device&#92;'s public key."];</code>
     */
    public Builder clearSha256() {
      
      sha256_ = getDefaultInstance().getSha256();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * SHA256 hash of this device's public key.
     * </pre>
     *
     * <code>string sha256 = 3 [(.gen_bq_schema.description) = "SHA256 hash of this device&#92;'s public key."];</code>
     */
    public Builder setSha256Bytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      sha256_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object identity_ = "";
    /**
     * <pre>
     * A device's raw identity payload.
     * </pre>
     *
     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>
     */
    public java.lang.String getIdentity() {
      java.lang.Object ref = identity_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        identity_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * A device's raw identity payload.
     * </pre>
     *
     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>
     */
    public com.google.protobuf.ByteString
        getIdentityBytes() {
      java.lang.Object ref = identity_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        identity_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * A device's raw identity payload.
     * </pre>
     *
     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>
     */
    public Builder setIdentity(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      identity_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * A device's raw identity payload.
     * </pre>
     *
     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>
     */
    public Builder clearIdentity() {
      
      identity_ = getDefaultInstance().getIdentity();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * A device's raw identity payload.
     * </pre>
     *
     * <code>string identity = 4 [(.gen_bq_schema.ignore) = true];</code>
     */
    public Builder setIdentityBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      identity_ = value;
      onChanged();
      return this;
    }

    private java.util.List<com.google.protobuf.ByteString> authorities_ = java.util.Collections.emptyList();
    private void ensureAuthoritiesIsMutable() {
      if (!((bitField0_ & 0x00000010) != 0)) {
        authorities_ = new java.util.ArrayList<com.google.protobuf.ByteString>(authorities_);
        bitField0_ |= 0x00000010;
       }
    }
    /**
     * <pre>
     * Repeated PEM authority payloads, asserted as trusted by the server.
     * </pre>
     *
     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>
     */
    public java.util.List<com.google.protobuf.ByteString>
        getAuthoritiesList() {
      return ((bitField0_ & 0x00000010) != 0) ?
               java.util.Collections.unmodifiableList(authorities_) : authorities_;
    }
    /**
     * <pre>
     * Repeated PEM authority payloads, asserted as trusted by the server.
     * </pre>
     *
     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>
     */
    public int getAuthoritiesCount() {
      return authorities_.size();
    }
    /**
     * <pre>
     * Repeated PEM authority payloads, asserted as trusted by the server.
     * </pre>
     *
     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>
     */
    public com.google.protobuf.ByteString getAuthorities(int index) {
      return authorities_.get(index);
    }
    /**
     * <pre>
     * Repeated PEM authority payloads, asserted as trusted by the server.
     * </pre>
     *
     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>
     */
    public Builder setAuthorities(
        int index, com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureAuthoritiesIsMutable();
      authorities_.set(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Repeated PEM authority payloads, asserted as trusted by the server.
     * </pre>
     *
     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>
     */
    public Builder addAuthorities(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureAuthoritiesIsMutable();
      authorities_.add(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Repeated PEM authority payloads, asserted as trusted by the server.
     * </pre>
     *
     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>
     */
    public Builder addAllAuthorities(
        java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
      ensureAuthoritiesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, authorities_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Repeated PEM authority payloads, asserted as trusted by the server.
     * </pre>
     *
     * <code>repeated bytes authorities = 5 [(.gen_bq_schema.ignore) = true];</code>
     */
    public Builder clearAuthorities() {
      authorities_ = java.util.Collections.emptyList();
      bitField0_ = (bitField0_ & ~0x00000010);
      onChanged();
      return this;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:opencannabis.device.DeviceCredentials)
  }

  // @@protoc_insertion_point(class_scope:opencannabis.device.DeviceCredentials)
  private static final io.opencannabis.schema.device.DeviceCredentials DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.opencannabis.schema.device.DeviceCredentials();
  }

  public static io.opencannabis.schema.device.DeviceCredentials getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<DeviceCredentials>
      PARSER = new com.google.protobuf.AbstractParser<DeviceCredentials>() {
    @java.lang.Override
    public DeviceCredentials parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new DeviceCredentials(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<DeviceCredentials> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<DeviceCredentials> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public io.opencannabis.schema.device.DeviceCredentials getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}
```


Overlapping Code:
```
al class DeviceCredentials extends
com.google.protobuf.GeneratedMessageV3 implements
// @@protoc_insertion_point(message_implements:opencannabis.device.DeviceCredentials)
DeviceCredentialsOrBuilder {
private static final long serialVersionUID = 0L;
// Use DeviceCredentials.newBuilder() to construct.
private DeviceCredentials(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
super(builder);
}
private DeviceCredentials() {
publicKey_ = com.google.protobuf.ByteString.EMPTY;
privateKey_ = com.google.protobuf.ByteString.EMPTY;
sha256_ = "";
identity_ = "";
authorities_ = java.util.Collections.emptyList();
}
@java.lang.Override
public final com.google.protobuf.UnknownFieldSet
getUnknownFields() {
return this.unknownFields;
}
private DeviceCredentials(
com.google.protobuf.CodedInputStream input,
com.google.protobuf.ExtensionRegistryLite extensionRegistry)
throws com.google.protobuf.InvalidProtocolBufferException {
this();
if (extensionRegistry == null) {
throw new java.lang.NullPointerException();
}
int mutable_bitField0_ = 0;
com.google.protobuf.UnknownFieldSet.Builder unknownFields =
com.google.protobuf.UnknownFieldSet.newBuilder();
try {
boolean done = false;
while (!done) {
int tag = input.readTag();
switch (tag) {
case 0:
done = true;
break;
case 10: {
publicKey_ = input.readBytes();
break;
}
case 18: {
privateKey_ = input.readBytes();
break;
}
case 26: {
java.lang.String s = input.readStringRequireUtf8();
sha256_ = s;
break;
}
case 34: {
java.lang.String s = input.readStringRequireUtf8();
identity_ = s;
break;
}
case 42: {
if (!((mutable_bitField0_ & 0x00000010) != 0)) {
authorities_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
mutable_bitField0_ |= 0x00000010;
}
authorities_.add(input.readBytes());
break;
}
default: {
if (!parseUnknownField(
input, unknownFields, extensionRegistry, tag)) {
done = true;
}
break;
}
}
}
} catch (com.google.protobuf.
```
<Overlap Ratio: 0.9947780678851175>

---

--- 359 --
Question ID: cc2369190d41a97affa456090dc24dd8ae5eb6b7
Original Code:
```
public  final class Hash extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:opencannabis.crypto.Hash)
    HashOrBuilder {
private static final long serialVersionUID = 0L;
  // Use Hash.newBuilder() to construct.
  private Hash(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private Hash() {
    algorithm_ = 0;
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private Hash(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 8: {
            int rawValue = input.readEnum();

            algorithm_ = rawValue;
            break;
          }
          case 18: {
            digestCase_ = 2;
            digest_ = input.readBytes();
            break;
          }
          case 26: {
            java.lang.String s = input.readStringRequireUtf8();
            digestCase_ = 3;
            digest_ = s;
            break;
          }
          case 34: {
            java.lang.String s = input.readStringRequireUtf8();
            digestCase_ = 4;
            digest_ = s;
            break;
          }
          default: {
            if (!parseUnknownField(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.opencannabis.schema.crypto.primitives.integrity.Hash.class, io.opencannabis.schema.crypto.primitives.integrity.Hash.Builder.class);
  }

  private int digestCase_ = 0;
  private java.lang.Object digest_;
  public enum DigestCase
      implements com.google.protobuf.Internal.EnumLite {
    RAW(2),
    HEX(3),
    B64(4),
    DIGEST_NOT_SET(0);
    private final int value;
    private DigestCase(int value) {
      this.value = value;
    }
    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static DigestCase valueOf(int value) {
      return forNumber(value);
    }

    public static DigestCase forNumber(int value) {
      switch (value) {
        case 2: return RAW;
        case 3: return HEX;
        case 4: return B64;
        case 0: return DIGEST_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  public DigestCase
  getDigestCase() {
    return DigestCase.forNumber(
        digestCase_);
  }

  public static final int ALGORITHM_FIELD_NUMBER = 1;
  private int algorithm_;
  /**
   * <pre>
   * Specifies the algorithm in use.
   * </pre>
   *
   * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>
   */
  public int getAlgorithmValue() {
    return algorithm_;
  }
  /**
   * <pre>
   * Specifies the algorithm in use.
   * </pre>
   *
   * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>
   */
  public io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm getAlgorithm() {
    @SuppressWarnings("deprecation")
    io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm result = io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.valueOf(algorithm_);
    return result == null ? io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.UNRECOGNIZED : result;
  }

  public static final int RAW_FIELD_NUMBER = 2;
  /**
   * <pre>
   * Raw binary output of the hash algorithm.
   * </pre>
   *
   * <code>bytes raw = 2;</code>
   */
  public com.google.protobuf.ByteString getRaw() {
    if (digestCase_ == 2) {
      return (com.google.protobuf.ByteString) digest_;
    }
    return com.google.protobuf.ByteString.EMPTY;
  }

  public static final int HEX_FIELD_NUMBER = 3;
  /**
   * <pre>
   * Hex-encoded digest value.
   * </pre>
   *
   * <code>string hex = 3;</code>
   */
  public java.lang.String getHex() {
    java.lang.Object ref = "";
    if (digestCase_ == 3) {
      ref = digest_;
    }
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      if (digestCase_ == 3) {
        digest_ = s;
      }
      return s;
    }
  }
  /**
   * <pre>
   * Hex-encoded digest value.
   * </pre>
   *
   * <code>string hex = 3;</code>
   */
  public com.google.protobuf.ByteString
      getHexBytes() {
    java.lang.Object ref = "";
    if (digestCase_ == 3) {
      ref = digest_;
    }
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      if (digestCase_ == 3) {
        digest_ = b;
      }
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int B64_FIELD_NUMBER = 4;
  /**
   * <pre>
   * Base64-encoded digest value.
   * </pre>
   *
   * <code>string b64 = 4;</code>
   */
  public java.lang.String getB64() {
    java.lang.Object ref = "";
    if (digestCase_ == 4) {
      ref = digest_;
    }
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = 
          (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      if (digestCase_ == 4) {
        digest_ = s;
      }
      return s;
    }
  }
  /**
   * <pre>
   * Base64-encoded digest value.
   * </pre>
   *
   * <code>string b64 = 4;</code>
   */
  public com.google.protobuf.ByteString
      getB64Bytes() {
    java.lang.Object ref = "";
    if (digestCase_ == 4) {
      ref = digest_;
    }
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b = 
          com.google.protobuf.ByteString.copyFromUtf8(
              (java.lang.String) ref);
      if (digestCase_ == 4) {
        digest_ = b;
      }
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (algorithm_ != io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.SHA1.getNumber()) {
      output.writeEnum(1, algorithm_);
    }
    if (digestCase_ == 2) {
      output.writeBytes(
          2, (com.google.protobuf.ByteString) digest_);
    }
    if (digestCase_ == 3) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3, digest_);
    }
    if (digestCase_ == 4) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 4, digest_);
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (algorithm_ != io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.SHA1.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(1, algorithm_);
    }
    if (digestCase_ == 2) {
      size += com.google.protobuf.CodedOutputStream
        .computeBytesSize(
            2, (com.google.protobuf.ByteString) digest_);
    }
    if (digestCase_ == 3) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, digest_);
    }
    if (digestCase_ == 4) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, digest_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.opencannabis.schema.crypto.primitives.integrity.Hash)) {
      return super.equals(obj);
    }
    io.opencannabis.schema.crypto.primitives.integrity.Hash other = (io.opencannabis.schema.crypto.primitives.integrity.Hash) obj;

    if (algorithm_ != other.algorithm_) return false;
    if (!getDigestCase().equals(other.getDigestCase())) return false;
    switch (digestCase_) {
      case 2:
        if (!getRaw()
            .equals(other.getRaw())) return false;
        break;
      case 3:
        if (!getHex()
            .equals(other.getHex())) return false;
        break;
      case 4:
        if (!getB64()
            .equals(other.getB64())) return false;
        break;
      case 0:
      default:
    }
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + ALGORITHM_FIELD_NUMBER;
    hash = (53 * hash) + algorithm_;
    switch (digestCase_) {
      case 2:
        hash = (37 * hash) + RAW_FIELD_NUMBER;
        hash = (53 * hash) + getRaw().hashCode();
        break;
      case 3:
        hash = (37 * hash) + HEX_FIELD_NUMBER;
        hash = (53 * hash) + getHex().hashCode();
        break;
      case 4:
        hash = (37 * hash) + B64_FIELD_NUMBER;
        hash = (53 * hash) + getB64().hashCode();
        break;
      case 0:
      default:
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.opencannabis.schema.crypto.primitives.integrity.Hash parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.opencannabis.schema.crypto.primitives.integrity.Hash prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * Specifies the hash portion of hashed data, along with the algorithm used to calculate the digest enclosed. This
   * particular container does not specify or otherwise contain the original referenced data.
   * </pre>
   *
   * Protobuf type {@code opencannabis.crypto.Hash}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:opencannabis.crypto.Hash)
      io.opencannabis.schema.crypto.primitives.integrity.HashOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.opencannabis.schema.crypto.primitives.integrity.Hash.class, io.opencannabis.schema.crypto.primitives.integrity.Hash.Builder.class);
    }

    // Construct using io.opencannabis.schema.crypto.primitives.integrity.Hash.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      algorithm_ = 0;

      digestCase_ = 0;
      digest_ = null;
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.opencannabis.schema.crypto.primitives.integrity.Integrity.internal_static_opencannabis_crypto_Hash_descriptor;
    }

    @java.lang.Override
    public io.opencannabis.schema.crypto.primitives.integrity.Hash getDefaultInstanceForType() {
      return io.opencannabis.schema.crypto.primitives.integrity.Hash.getDefaultInstance();
    }

    @java.lang.Override
    public io.opencannabis.schema.crypto.primitives.integrity.Hash build() {
      io.opencannabis.schema.crypto.primitives.integrity.Hash result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public io.opencannabis.schema.crypto.primitives.integrity.Hash buildPartial() {
      io.opencannabis.schema.crypto.primitives.integrity.Hash result = new io.opencannabis.schema.crypto.primitives.integrity.Hash(this);
      result.algorithm_ = algorithm_;
      if (digestCase_ == 2) {
        result.digest_ = digest_;
      }
      if (digestCase_ == 3) {
        result.digest_ = digest_;
      }
      if (digestCase_ == 4) {
        result.digest_ = digest_;
      }
      result.digestCase_ = digestCase_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.opencannabis.schema.crypto.primitives.integrity.Hash) {
        return mergeFrom((io.opencannabis.schema.crypto.primitives.integrity.Hash)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.opencannabis.schema.crypto.primitives.integrity.Hash other) {
      if (other == io.opencannabis.schema.crypto.primitives.integrity.Hash.getDefaultInstance()) return this;
      if (other.algorithm_ != 0) {
        setAlgorithmValue(other.getAlgorithmValue());
      }
      switch (other.getDigestCase()) {
        case RAW: {
          setRaw(other.getRaw());
          break;
        }
        case HEX: {
          digestCase_ = 3;
          digest_ = other.digest_;
          onChanged();
          break;
        }
        case B64: {
          digestCase_ = 4;
          digest_ = other.digest_;
          onChanged();
          break;
        }
        case DIGEST_NOT_SET: {
          break;
        }
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      io.opencannabis.schema.crypto.primitives.integrity.Hash parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (io.opencannabis.schema.crypto.primitives.integrity.Hash) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }
    private int digestCase_ = 0;
    private java.lang.Object digest_;
    public DigestCase
        getDigestCase() {
      return DigestCase.forNumber(
          digestCase_);
    }

    public Builder clearDigest() {
      digestCase_ = 0;
      digest_ = null;
      onChanged();
      return this;
    }


    private int algorithm_ = 0;
    /**
     * <pre>
     * Specifies the algorithm in use.
     * </pre>
     *
     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>
     */
    public int getAlgorithmValue() {
      return algorithm_;
    }
    /**
     * <pre>
     * Specifies the algorithm in use.
     * </pre>
     *
     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>
     */
    public Builder setAlgorithmValue(int value) {
      algorithm_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Specifies the algorithm in use.
     * </pre>
     *
     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>
     */
    public io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm getAlgorithm() {
      @SuppressWarnings("deprecation")
      io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm result = io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.valueOf(algorithm_);
      return result == null ? io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Specifies the algorithm in use.
     * </pre>
     *
     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>
     */
    public Builder setAlgorithm(io.opencannabis.schema.crypto.primitives.integrity.HashAlgorithm value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      algorithm_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Specifies the algorithm in use.
     * </pre>
     *
     * <code>.opencannabis.crypto.HashAlgorithm algorithm = 1;</code>
     */
    public Builder clearAlgorithm() {
      
      algorithm_ = 0;
      onChanged();
      return this;
    }

    /**
     * <pre>
     * Raw binary output of the hash algorithm.
     * </pre>
     *
     * <code>bytes raw = 2;</code>
     */
    public com.google.protobuf.ByteString getRaw() {
      if (digestCase_ == 2) {
        return (com.google.protobuf.ByteString) digest_;
      }
      return com.google.protobuf.ByteString.EMPTY;
    }
    /**
     * <pre>
     * Raw binary output of the hash algorithm.
     * </pre>
     *
     * <code>bytes raw = 2;</code>
     */
    public Builder setRaw(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  digestCase_ = 2;
      digest_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Raw binary output of the hash algorithm.
     * </pre>
     *
     * <code>bytes raw = 2;</code>
     */
    public Builder clearRaw() {
      if (digestCase_ == 2) {
        digestCase_ = 0;
        digest_ = null;
        onChanged();
      }
      return this;
    }

    /**
     * <pre>
     * Hex-encoded digest value.
     * </pre>
     *
     * <code>string hex = 3;</code>
     */
    public java.lang.String getHex() {
      java.lang.Object ref = "";
      if (digestCase_ == 3) {
        ref = digest_;
      }
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (digestCase_ == 3) {
          digest_ = s;
        }
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Hex-encoded digest value.
     * </pre>
     *
     * <code>string hex = 3;</code>
     */
    public com.google.protobuf.ByteString
        getHexBytes() {
      java.lang.Object ref = "";
      if (digestCase_ == 3) {
        ref = digest_;
      }
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        if (digestCase_ == 3) {
          digest_ = b;
        }
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Hex-encoded digest value.
     * </pre>
     *
     * <code>string hex = 3;</code>
     */
    public Builder setHex(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  digestCase_ = 3;
      digest_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Hex-encoded digest value.
     * </pre>
     *
     * <code>string hex = 3;</code>
     */
    public Builder clearHex() {
      if (digestCase_ == 3) {
        digestCase_ = 0;
        digest_ = null;
        onChanged();
      }
      return this;
    }
    /**
     * <pre>
     * Hex-encoded digest value.
     * </pre>
     *
     * <code>string hex = 3;</code>
     */
    public Builder setHexBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      digestCase_ = 3;
      digest_ = value;
      onChanged();
      return this;
    }

    /**
     * <pre>
     * Base64-encoded digest value.
     * </pre>
     *
     * <code>string b64 = 4;</code>
     */
    public java.lang.String getB64() {
      java.lang.Object ref = "";
      if (digestCase_ == 4) {
        ref = digest_;
      }
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (digestCase_ == 4) {
          digest_ = s;
        }
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     * <pre>
     * Base64-encoded digest value.
     * </pre>
     *
     * <code>string b64 = 4;</code>
     */
    public com.google.protobuf.ByteString
        getB64Bytes() {
      java.lang.Object ref = "";
      if (digestCase_ == 4) {
        ref = digest_;
      }
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        if (digestCase_ == 4) {
          digest_ = b;
        }
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     * <pre>
     * Base64-encoded digest value.
     * </pre>
     *
     * <code>string b64 = 4;</code>
     */
    public Builder setB64(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  digestCase_ = 4;
      digest_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Base64-encoded digest value.
     * </pre>
     *
     * <code>string b64 = 4;</code>
     */
    public Builder clearB64() {
      if (digestCase_ == 4) {
        digestCase_ = 0;
        digest_ = null;
        onChanged();
      }
      return this;
    }
    /**
     * <pre>
     * Base64-encoded digest value.
     * </pre>
     *
     * <code>string b64 = 4;</code>
     */
    public Builder setB64Bytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      digestCase_ = 4;
      digest_ = value;
      onChanged();
      return this;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:opencannabis.crypto.Hash)
  }

  // @@protoc_insertion_point(class_scope:opencannabis.crypto.Hash)
  private static final io.opencannabis.schema.crypto.primitives.integrity.Hash DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.opencannabis.schema.crypto.primitives.integrity.Hash();
  }

  public static io.opencannabis.schema.crypto.primitives.integrity.Hash getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<Hash>
      PARSER = new com.google.protobuf.AbstractParser<Hash>() {
    @java.lang.Override
    public Hash parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new Hash(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<Hash> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<Hash> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public io.opencannabis.schema.crypto.primitives.integrity.Hash getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}
```


Overlapping Code:
```
inal class Hash extends
com.google.protobuf.GeneratedMessageV3 implements
// @@protoc_insertion_point(message_implements:opencannabis.crypto.Hash)
HashOrBuilder {
private static final long serialVersionUID = 0L;
// Use Hash.newBuilder() to construct.
private Hash(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
super(builder);
}
private Hash() {
algorithm_ = 0;
}
@java.lang.Override
public final com.google.protobuf.UnknownFieldSet
getUnknownFields() {
return this.unknownFields;
}
private Hash(
com.google.protobuf.CodedInputStream input,
com.google.protobuf.ExtensionRegistryLite extensionRegistry)
throws com.google.protobuf.InvalidProtocolBufferException {
this();
if (extensionRegistry == null) {
throw new java.lang.NullPointerException();
}
int mutable_bitField0_ = 0;
com.google.protobuf.UnknownFieldSet.Builder unknownFields =
com.google.protobuf.UnknownFieldSet.newBuilder();
try {
boolean done = false;
while (!done) {
int tag = input.readTag();
switch (tag) {
case 0:
done = true;
break;
case 8: {
int rawValue = input.readEnum();
algorithm_ = rawValue;
break;
}
case 18: {
digestCase_ = 2;
digest_ = input.readBytes();
break;
}
case 26: {
java.lang.String s = input.readStringRequireUtf8();
digestCase_ = 3;
digest_ = s;
break;
}
case 34: {
java.lang.String s = input.readStringRequireUtf8();
digestCase_ = 4;
digest_ = s;
break;
}
default: {
if (!parseUnknownField(
input, unknownFields, extensionRegistry, tag)) {
done = true;
}
break;
}
}
}
} catch (com.google.protobuf.InvalidProtocolBufferException e) {
throw e.setUnfinishedMessage(this);
} catch (java.io.IOException e) {
throw new com.google.protobuf.InvalidProtocolBufferException(
e).setUnfinishedMessage(this);
} finally {
this.unknownFields = unknownFields.build();
makeExtensionsImmutable();
}
}
public static final com.google.protobuf.Descriptors.Descriptor
getDescriptor() {
return io.opencannabis.schema.crypto.primitiv
```
<Overlap Ratio: 0.9953173777315296>

---

--- 360 --
Question ID: f87eeb47cf1273332e2f03c3b1964a04606d9254
Original Code:
```
public class TestSystemIdResolver extends LuceneTestCase {
  
  public void tearDown() throws Exception {
    System.clearProperty("solr.allow.unsafe.resourceloading");
    super.tearDown();
  }

  private void assertEntityResolving(SystemIdResolver resolver, String expectedSystemId, String base, String systemId) throws Exception {
    final InputSource is = resolver.resolveEntity(null, null, base, systemId);
    try {
      assertEquals("Resolved SystemId does not match", expectedSystemId, is.getSystemId());
    } finally {
      IOUtils.closeQuietly(is.getByteStream());
    }
  }
  
  public void testResolving() throws Exception {
    final Path testHome = SolrTestCaseJ4.getFile("solr/collection1").getParentFile().toPath();
    final ResourceLoader loader = new SolrResourceLoader(testHome.resolve("collection1"), this.getClass().getClassLoader());
    final SystemIdResolver resolver = new SystemIdResolver(loader);
    final String fileUri = new File(testHome+"/crazy-path-to-config.xml").toURI().toASCIIString();
    
    assertEquals("solrres:/test.xml", SystemIdResolver.createSystemIdFromResourceName("test.xml"));
    assertEquals("solrres://@/usr/local/etc/test.xml", SystemIdResolver.createSystemIdFromResourceName("/usr/local/etc/test.xml"));
    assertEquals("solrres://@/test.xml", SystemIdResolver.createSystemIdFromResourceName(File.separatorChar+"test.xml"));
    
    // check relative URI resolving
    assertEquals("solrres:/test.xml", resolver.resolveRelativeURI("solrres:/base.xml", "test.xml").toASCIIString());
    assertEquals("solrres://@/etc/test.xml",
      resolver.resolveRelativeURI("solrres://@/usr/local/etc/base.xml", "../../../etc/test.xml").toASCIIString());
    // special case: if relative URI starts with "/" convert to an absolute solrres://@/-URI
    assertEquals("solrres://@/a/test.xml", resolver.resolveRelativeURI("solrres:/base.xml", "/a/test.xml").toASCIIString());
    // test, that resolving works if somebody uses an absolute file:-URI in a href attribute, it should be preserved
    assertEquals(fileUri, resolver.resolveRelativeURI("solrres:/base.xml", fileUri).toASCIIString());
    assertEquals("solrres:/base.xml", resolver.resolveRelativeURI(fileUri, "solrres:/base.xml").toASCIIString());
    
    // do some real resolves to InputStreams with real existing files
    assertEntityResolving(resolver, "solrres:/schema.xml", "solrres:/solrconfig.xml", "schema.xml");
    assertEntityResolving(resolver, "solrres:/org/apache/solr/util/TestSystemIdResolver.class",
      "solrres:/org/apache/solr/util/RTimer.class", "TestSystemIdResolver.class");
    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(testHome+"/collection1/conf/schema.xml"),
      SystemIdResolver.createSystemIdFromResourceName(testHome+"/collection1/conf/solrconfig.xml"), "schema.xml");
    
    // if somebody uses an absolute uri (e.g., file://) we should fail resolving:
    IOException ioe = expectThrows(IOException.class, () -> {
      resolver.resolveEntity(null, null, "solrres:/solrconfig.xml", fileUri);
    });
    assertTrue(ioe.getMessage().startsWith("Cannot resolve absolute"));
    
    ioe = expectThrows(IOException.class, () -> {
      resolver.resolveEntity(null, null, "solrres:/solrconfig.xml", "http://lucene.apache.org/test.xml");
    });
    assertTrue(ioe.getMessage().startsWith("Cannot resolve absolute"));
    
    // check that we can't escape with absolute file paths:
    for (String path : Arrays.asList("/etc/passwd", "/windows/notepad.exe")) {
      ioe = expectThrows(IOException.class, () -> {
        resolver.resolveEntity(null, null, "solrres:/solrconfig.xml", path);
      });
      assertTrue(ioe.getMessage().startsWith("Can't find resource")
          || ioe.getMessage().contains("is outside resource loader dir"));
    }
  }

  public void testUnsafeResolving() throws Exception {
    System.setProperty("solr.allow.unsafe.resourceloading", "true");
    
    final Path testHome = SolrTestCaseJ4.getFile("solr/collection1").getParentFile().toPath();
    final ResourceLoader loader = new SolrResourceLoader(testHome.resolve("collection1"), this.getClass().getClassLoader());
    final SystemIdResolver resolver = new SystemIdResolver(loader);
    
    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(testHome+"/crazy-path-to-schema.xml"),
      SystemIdResolver.createSystemIdFromResourceName(testHome+"/crazy-path-to-config.xml"), "crazy-path-to-schema.xml");    
  }

}
```


Overlapping Code:
```
ver extends LuceneTestCase {

public void tearDown() throws Exception {
System.clearProperty("solr.allow.unsafe.resourceloading");
super.tearDown();
}
private void assertEntityResolving(SystemIdResolver resolver, String expectedSystemId, String base, String systemId) throws Exception {
final InputSource is = resolver.resolveEntity(null, null, base, systemId);
try {
assertEquals("Resolved SystemId does not match", expectedSystemId, is.getSystemId());
} finally {
IOUtils.closeQuietly(is.getByteStream());
}
}

public void testResolving() throws Exception {
final Path testHome = SolrTestCaseJ4.getFile("solr/collection1").getParentFile().toPath();
final ResourceLoader loader = new SolrResourceLoader(testHome.resolve("collection1"), this.getClass().getClassLoader());
final SystemIdResolver resolver = new SystemIdResolver(loader);
final String fileUri = new File(testHome+"/crazy-path-to-config.xml").toURI().toASCIIString();

assertEquals("solrres:/test.xml", SystemIdResolver.createSystemIdFromResourceName("test.xml"));
assertEquals("solrres://@/usr/local/etc/test.xml", SystemIdResolver.createSystemIdFromResourceName("/usr/local/etc/test.xml"));
assertEquals("solrres://@/test.xml", SystemIdResolver.createSystemIdFromResourceName(File.separatorChar+"test.xml"));

// check relative URI resolving
assertEquals("solrres:/test.xml", resolver.resolveRelativeURI("solrres:/base.xml", "test.xml").toASCIIString());
assertEquals("solrres://@/etc/test.xml",
resolver.resolveRelativeURI("solrres://@/usr/local/etc/base.xml", "../../../etc/test.xml").toASCIIString());
// special case: if relative URI starts with "/" convert to an absolute solrres://@/-URI
assertEquals("solrres://@/a/test.xml", resolver.resolveRelativeURI("solrres:/base.xml", "/a/test.xml").toASCIIString());
// test, that resolving works if somebody uses an absolute file:-URI in a href attribute, it should be preserved
assertEquals(fileUri, resolver.resolveRelativeURI("solrres:/base.xml", fileUri).toASCIIString());
assertEquals("solrres:/base.xml", resolver.resolveRelativeURI(fileUri, "solrres:/base.xml").toASCIIString());

// do some real resolves to InputStreams with real existing files
assertEntityResolving(resolver, "solrres:/schema.xml", "solrres:/solrconfig.xml", "schema.xml");
assertEntityResolving(resolver, "so
```
<Overlap Ratio: 0.9754028837998303>

---

--- 361 --
Question ID: 6aead2c61aec01278e0159f02dc83b2505af0a18
Original Code:
```
public class RoomRightsListComposer extends MessageComposer
{
    private final Room room;

    public RoomRightsListComposer(Room room)
    {
        this.room = room;
    }

    @Override
    public ServerMessage compose()
    {
        this.response.init(Outgoing.RoomRightsListComposer);
        this.response.appendInt(this.room.getId());

        THashMap<Integer, String> rightsMap = this.room.getUsersWithRights();

        this.response.appendInt(rightsMap.size());

        for(Map.Entry<Integer, String> set : rightsMap.entrySet())
        {
            this.response.appendInt(set.getKey());
            this.response.appendString(set.getValue());
        }

        return this.response;
    }
}
```


Overlapping Code:
```
ightsListComposer extends MessageComposer
{
private final Room room;
public RoomRightsListComposer(Room room)
{
this.room = room;
}
@Override
public ServerMessage compose()
{
this.response.init(Outgoing.RoomRightsListComposer);
this.response.appendInt(this.room.getId());
THashMap<Integer, String> rightsMap = this.room.getUsersWithRights();
this.response.appendInt(rightsMap.size());
for(Map.Entry<Integer, String> set : rightsMap.entrySet())
{
this.response.appendInt(set.getKey());
this.response.appendString(set.getValue());
}
return this.respons
```
<Overlap Ratio: 0.9581881533101045>

---

--- 362 --
Question ID: 521919bcfc91f1d5730c79e684eff967bf91c337
Original Code:
```
public class Actividad {

    private int numero;
    private String denominacion;
    private String descripcion;
    private Date fechaCreacion;
    private Date fechaInicio;
    private Date fechaFin;
    private Date fechaAnulacion;
    private Date fechaEsperadaDeCierre;
    private EstadoActividad estado;
    private String observaciones;
    private TipoActividad tipoActividad;
    private ArrayList<Tarea> tareas;

    public Actividad()
    {
        this.estado = new EstadoActividad();
        this.tipoActividad = new TipoActividad();
        this.tareas = new ArrayList();
    }
    /**
     * @return the descripcion
     */
    public String getDescripcion() {
        return descripcion;
    }

    /**
     * @param descripcion the descripcion to set
     */
    public void setDescripcion(String descripcion) {
        this.descripcion = descripcion;
    }

    /**
     * @return the fechaCreacion
     */
    public Date getFechaCreacion() {
        return fechaCreacion;
    }

    /**
     * @param fechaCreacion the fechaCreacion to set
     */
    public void setFechaCreacion(Date fechaCreacion) {
        this.fechaCreacion = fechaCreacion;
    }

    /**
     * @return the fechaInicio
     */
    public Date getFechaInicio() {
        return fechaInicio;
    }

    /**
     * @param fechaInicio the fechaInicio to set
     */
    public void setFechaInicio(Date fechaInicio) {
        this.fechaInicio = fechaInicio;
    }

    /**
     * @return the fechaFin
     */
    public Date getFechaFin() {
        return fechaFin;
    }

    /**
     * @param fechaFin the fechaFin to set
     */
    public void setFechaFin(Date fechaFin) {
        this.fechaFin = fechaFin;
    }

    /**
     * @return the observaciones
     */
    public String getObservaciones() {
        return observaciones;
    }

    /**
     * @param observaciones the observaciones to set
     */
    public void setObservaciones(String observaciones) {
        this.observaciones = observaciones;
    }

    /**
     * @return the tipoActividad
     */
    public TipoActividad getTipoActividad() {
        return tipoActividad;
    }

    /**
     * @param tipoActividad the tipoActividad to set
     */
    public void setTipoActividad(TipoActividad tipoActividad) {
        this.tipoActividad = tipoActividad;
    }

    /**
     * @return the numero
     */
    public int getNumero() {
        return numero;
    }

    /**
     * @param numero the numero to set
     */
    public void setNumero(int numero) {
        this.numero = numero;
    }

    /**
     * @return the denominacion
     */
    public String getDenominacion() {
        return denominacion;
    }

    /**
     * @param denominacion the denominacion to set
     */
    public void setDenominacion(String denominacion) {
        this.denominacion = denominacion;
    }

    /**
     * @return the estado
     */
    public EstadoActividad getEstado() {
        return estado;
    }

    /**
     * @param estado the estado to set
     */
    public void setEstado(EstadoActividad estado) {
        this.estado = estado;
    }

    /**
     * Método para calcular como están las actividades (icono)
     */
    public String getIcon() {
        String icon = null;
        int dias = this.diasDeCumplimiento();
        if (dias < 0) {
            icon = "/resources/icons/accept.png";
        }
        if (dias == 0) {
            icon = "/resources/icons/error.png";
        }
        if (dias > 0) {
            icon = "/resources/icons/exclamation.png";
        }
        return icon;
    }

     /**
     * Método para calcular como están las actividades (descripcion)
     */
    public String getDescrip() {
        String descrip = null;
        int dias = this.diasDeCumplimiento();
        if (dias < 0) {
            descrip = "Actividad dentro de Cumplimiento";
        }
        if (dias == 0) {
            descrip = "En día de cumplimiento";
        }
        if (dias > 0) {
            descrip = "Actividad fuera de cumplimiento";
        }
        return descrip;
    }

    public int diasDeCumplimiento() {
        if (this.getFechaInicio() != null && this.getFechaFin() != null) {
            return UtilFecha.fechasDiferenciaEnDias(this.getFechaEsperadaDeCierre(), this.getFechaFin());
        } else {
            return 0;
        }
    }

    /**
     * @return the fechaEsperadaDeCierre
     */
    public Date getFechaEsperadaDeCierre() {
        return fechaEsperadaDeCierre;
    }

    /**
     * @param fechaEsperadaDeCierre the fechaEsperadaDeCierre to set
     */
    public void setFechaEsperadaDeCierre(Date fechaEsperadaDeCierre) {
        this.fechaEsperadaDeCierre = fechaEsperadaDeCierre;
    }

    /**
     * @return the tareas
     */
    public ArrayList<Tarea> getTareas() {
        return tareas;
    }

    /**
     * @param tareas the tareas to set
     */
    public void setTareas(ArrayList<Tarea> tareas) {
        this.tareas = tareas;
    }

    /**
     * @return the fechaAnulacion
     */
    public Date getFechaAnulacion() {
        return fechaAnulacion;
    }

    /**
     * @param fechaAnulacion the fechaAnulacion to set
     */
    public void setFechaAnulacion(Date fechaAnulacion) {
        this.fechaAnulacion = fechaAnulacion;
    }

    /**
     *  Devuelve true si está Finalizada
     */
    public boolean isFinalizada() {
        if (this.getEstado().getNumero()==5)
            return true;
        else
            return false;
    }

}
```


Overlapping Code:
```
nt numero;
private String denominacion;
private String descripcion;
private Date fechaCreacion;
private Date fechaInicio;
private Date fechaFin;
private Date fechaAnulacion;
private Date fechaEsperadaDeCierre;
private EstadoActividad estado;
private String observaciones;
private TipoActividad tipoActividad;
private ArrayList<Tarea> tareas;
public Actividad()
{
this.estado = new EstadoActividad();
this.tipoActividad = new TipoActividad();
this.tareas = new ArrayList();
}
/**
* @return the descripcion
*/
public String getDescripcion() {
return descripcion;
}
/**
* @param descripcion the descripcion to set
*/
public void setDescripcion(String descripcion) {
this.descripcion = descripcion;
}
/**
* @return the fechaCreacion
*/
public Date getFechaCreacion() {
return fechaCreacion;
}
/**
* @param fechaCreacion the fechaCreacion to set
*/
public void setFechaCreacion(Date fechaCreacion) {
this.fechaCreacion = fechaCreacion;
}
/**
* @return the fechaInicio
*/
public Date getFechaInicio() {
return fechaInicio;
}
/**
* @param fechaInicio the fechaInicio to set
*/
public void setFechaInicio(Date fechaInicio) {
this.fechaInicio = fechaInicio;
}
/**
* @return the fechaFin
*/
public Date getFechaFin() {
return fechaFin;
}
/**
* @param fechaFin the fechaFin to set
*/
public void setFechaFin(Date fechaFin) {
this.fechaFin = fechaFin;
}
/**
* @return the observaciones
*/
public String getObservaciones() {
return observaciones;
}
/**
* @param observaciones the observaciones to set
*/
public void setObservaciones(String observaciones) {
this.observaciones = observaciones;
}
/**
* @return the tipoActividad
*/
public TipoActividad getTipoActividad() {
return tipoActividad;
}
/**
* @param tipoActividad the tipoActividad to set
*/
public void setTipoActividad(TipoActividad tipoActividad) {
this.tipoActividad = tipoActividad;
}
/**
* @return the numero
*/
public int getNumero() {
return numero;
}
/**
* @param numero the numero to set
*/
public void
```
<Overlap Ratio: 0.9829317269076305>

---

--- 363 --
Question ID: 8eecef3ed30cb86d899fb4cd0a625ecb71e591ea
Original Code:
```
public class EjercicioInstanciaDTO{
    //--------------------------------------------
    // DATOS BASE
    //--------------------------------------------
    private Double efectividad;
    private Double cumplimiento;
    private Integer duracion;
    private Long id;
    private Integer series;
    private Integer tamanioParticiones;
    private Integer repeticionesPorParticion;
    
    
    //--------------------------------------------
    // CONSTRUCTOR & TOENTITY
    //--------------------------------------------
    public EjercicioInstanciaDTO() {
        //javax
    }
    
    public EjercicioInstanciaDTO(EjercicioInstanciaEntity entity){
        this.id=entity.getId();
        efectividad=entity.getEfectividad();
        cumplimiento=entity.getCumplimiento();
        duracion=entity.getDuracion();
        series=entity.getSeries();
        tamanioParticiones=entity.getTamanioParticiones();
        repeticionesPorParticion=entity.getRepeticionesPorParticion();
    }
    
    public EjercicioInstanciaEntity toEntity(){
        EjercicioInstanciaEntity ent=new EjercicioInstanciaEntity();
        ent.setDuracion(duracion);
        ent.setRepeticionesPorParticion(repeticionesPorParticion);
        ent.setSeries(series);
        ent.setTamanioParticiones(tamanioParticiones);
        ent.setCumplimiento(0.0);
        ent.setEfectividad(0.0);
        return ent;
    }
    //--------------------------------------------
    // GETS & SETS
    //--------------------------------------------

    public Double getEfectividad() {
        return efectividad;
    }

    public void setEfectividad(Double efectividad) {
        this.efectividad = efectividad;
    }

    public Double getCumplimiento() {
        return cumplimiento;
    }

    public void setCumplimiento(Double cumplimiento) {
        this.cumplimiento = cumplimiento;
    }

    public Integer getDuracion() {
        return duracion;
    }

    public void setDuracion(Integer duracion) {
        this.duracion = duracion;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Integer getSeries() {
        return series;
    }

    public void setSeries(Integer series) {
        this.series = series;
    }

    public Integer getTamanioParticiones() {
        return tamanioParticiones;
    }

    public void setTamanioParticiones(Integer tamanioParticiones) {
        this.tamanioParticiones = tamanioParticiones;
    }

    public Integer getRepeticionesPorParticion() {
        return repeticionesPorParticion;
    }

    public void setRepeticionesPorParticion(Integer repeticionesPorParticion) {
        this.repeticionesPorParticion = repeticionesPorParticion;
    }
}
```


Overlapping Code:
```
stanciaDTO{
//--------------------------------------------
// DATOS BASE
//--------------------------------------------
private Double efectividad;
private Double cumplimiento;
private Integer duracion;
private Long id;
private Integer series;
private Integer tamanioParticiones;
private Integer repeticionesPorParticion;


//--------------------------------------------
// CONSTRUCTOR & TOENTITY
//--------------------------------------------
public EjercicioInstanciaDTO() {
//javax
}

public EjercicioInstanciaDTO(EjercicioInstanciaEntity entity){
this.id=entity.getId();
efectividad=entity.getEfectividad();
cumplimiento=entity.getCumplimiento();
duracion=entity.getDuracion();
series=entity.getSeries();
tamanioParticiones=entity.getTamanioParticiones();
repeticionesPorParticion=entity.getRepeticionesPorParticion();
}

public EjercicioInstanciaEntity toEntity(){
EjercicioInstanciaEntity ent=new EjercicioInstanciaEntity();
ent.setDuracion(duracion);
ent.setRepeticionesPorParticion(repeticionesPorParticion);
ent.setSeries(series);
ent.setTamanioParticiones(tamanioParticiones);
ent.setCumplimiento(0.0);
ent.setEfectividad(0.0);
return ent;
}
//--------------------------------------------
// GETS & SETS
//--------------------------------------------
public Double getEfectividad() {
return efectividad;
}
public void setEfectividad(Double efectividad) {
this.efectividad = efectividad;
}
public Double getCumplimiento() {
return cumplimiento;
}
public void setCumplimiento(Double cumplimiento) {
this.cumplimiento = cumplimiento;
}
public Integer getDuracion() {
return duracion;
}
public void setDuracion(Integer duracion) {
this.duracion = duracion;
}
public Long getId() {
return id;
}
public void setId(Long id) {
this.id = id;
}
public Integer getSeries() {
return series;
}
public void setSeries(Integer series) {
this.series = series;
}
public Integer getTamanioParticiones() {
return tamanioParticiones;
}
public void setTamanioPar
```
<Overlap Ratio: 0.9813789632611978>

---

--- 364 --
Question ID: 595ec0ee9517f3449a3bb94cd4f7947d813b8579
Original Code:
```
public class AutoReConnectingSocketManager implements SocketManager
{
    private static final Logger LOGGER = LoggerFactory.getLogger(AutoReConnectingSocketManager.class);

    /**
     * The delegate socket manager.
     */
    private final SocketManager delegate;

    private InetSocketAddress server;

    private long connectionTimeout;

    public AutoReConnectingSocketManager(SocketManager delegate)
    {
        this.delegate = delegate;
    }

    @Override
    public void setInterceptor(Interceptor interceptor)
    {
        delegate.setInterceptor(interceptor);
    }

    @Override
    public void setDefaultMessageTimeout(long time, TimeUnit unit)
    {
        delegate.setDefaultMessageTimeout(time, unit);
    }

    @Override
    public long getDefaultMessageTimeout(TimeUnit unit)
    {
        return delegate.getDefaultMessageTimeout(unit);
    }

    @Override
    public void connect(String host, int port, long timeout) throws IOException
    {
        connect(new InetSocketAddress(host, port), timeout);
    }

    @Override
    public synchronized void connect(InetSocketAddress addr, long timeout) throws IOException
    {
        this.server = addr;
        this.connectionTimeout = timeout;

        delegate.connect(addr, timeout);
    }

    @Override
    public boolean isConnected()
    {
        connectIfNecessary();
        return delegate.isConnected();
    }

    @Override
    public InetSocketAddress getConnectedAddress()
    {
        connectIfNecessary();
        return delegate.getConnectedAddress();
    }

    @Override
    public SocketManager newConnection() throws IOException
    {
        connectIfNecessary();
        return delegate.newConnection();
    }

    @Override
    public synchronized void disconnect()
    {
        this.server = null;
        delegate.disconnect();
    }

    @Override
    public void send(String message) throws IOException
    {
        connectIfNecessary();
        delegate.send(message);
    }

    @Override
    public String sendAndWait(String message) throws IOException
    {
        connectIfNecessary();
        return delegate.sendAndWait(message);
    }

    @Override
    public String sendAndWait(String message, long timeout, TimeUnit unit) throws IOException
    {
        connectIfNecessary();
        return delegate.sendAndWait(message, timeout, unit);
    }

    @Override
    public ByteChannel redirectChannel()
    {
        connectIfNecessary();
        return delegate.redirectChannel();
    }

    private synchronized void connectIfNecessary()
    {
        if (server == null || delegate.isConnected())
        {
            return;
        }

        try
        {
            delegate.connect(server, connectionTimeout);
        }
        catch (IOException e)
        {
            LOGGER.warn("Auto-reconnect failed", e);
        }
    }
}
```


Overlapping Code:
```
public class AutoReConnectingSocketManager implements SocketManager
{
private static final Logger LOGGER = LoggerFactory.getLogger(AutoReConnectingSocketManager.class);
/**
* The delegate socket manager.
*/
private final SocketManager delegate;
private InetSocketAddress server;
private long connectionTimeout;
public AutoReConnectingSocketManager(SocketManager delegate)
{
this.delegate = delegate;
}
@Override
public void setInterceptor(Interceptor interceptor)
{
delegate.setInterceptor(interceptor);
}
@Override
public void setDefaultMessageTimeout(long time, TimeUnit unit)
{
delegate.setDefaultMessageTimeout(time, unit);
}
@Override
public long getDefaultMessageTimeout(TimeUnit unit)
{
return delegate.getDefaultMessageTimeout(unit);
}
@Override
public void connect(String host, int port, long timeout) throws IOException
{
connect(new InetSocketAddress(host, port), timeout);
}
@Override
public synchronized void connect(InetSocketAddress addr, long timeout) throws IOException
{
this.server = addr;
this.connectionTimeout = timeout;
delegate.connect(addr, timeout);
}
@Override
public boolean isConnected()
{
connectIfNecessary();
return delegate.isConnected();
}
@Override
public InetSocketAddress getConnectedAddress()
{
connectIfNecessary();
return delegate.getConnectedAddress();
}
@Override
public SocketManager newConnection() throws IOException
{
connectIfNecessary();
return delegate.newConnection();
}
@Override
public synchronized void disconnect()
{
this.server = null;
delegate.disconnect();
}
@Override
public void send(String message) throws IOException
{
connectIfNecessary();
delegate.send(message);
}
@Override
public String sendAndWait(String message) throws IOException
{
connectIfNecessary();
return delegate.sendAndWait(message);
}
@Override
public String sendAndWait(String message, long timeout, TimeUnit unit) throws IOException
{
connectIfNecessary();
return delegate.sendAndWait(message, timeout, unit);
}
@Override
public ByteChannel redirectChannel()
{
connectIf
```
<Overlap Ratio: 0.9789525208027411>

---

--- 365 --
Question ID: 90f86440400f8d8fdb2f40bee6e011fb5785e62d
Original Code:
```
public class MQTTProtocolSupport {

    /**
     * Converts an MQTT formatted Topic name into a suitable ActiveMQ Destination
     * name string.
     *
     * @param name
     *        the MQTT formatted topic name.
     *
     * @return an destination name that fits the ActiveMQ conventions.
     */
    public static String convertMQTTToActiveMQ(String name) {
        char[] chars = name.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            switch(chars[i]) {
                case '#':
                    chars[i] = '>';
                    break;
                case '>':
                    chars[i] = '#';
                    break;
                case '+':
                    chars[i] = '*';
                    break;
                case '*':
                    chars[i] = '+';
                    break;
                case '/':
                    chars[i] = '.';
                    break;
                case '.':
                    chars[i] = '/';
                    break;
            }
        }
        String rc = new String(chars);
        return rc;
    }

    /**
     * Converts an ActiveMQ destination name into a correctly formatted
     * MQTT destination name.
     *
     * @param destinationName
     *        the ActiveMQ destination name to process.
     *
     * @return a destination name formatted for MQTT.
     */
    public static String convertActiveMQToMQTT(String destinationName) {
        char[] chars = destinationName.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            switch(chars[i]) {
                case '>':
                    chars[i] = '#';
                    break;
                case '#':
                    chars[i] = '>';
                    break;
                case '*':
                    chars[i] = '+';
                    break;
                case '+':
                    chars[i] = '*';
                    break;
                case '.':
                    chars[i] = '/';
                    break;
                case '/':
                    chars[i] = '.';
                    break;
            }
        }
        String rc = new String(chars);
        return rc;
    }

    /**
     * Given an MQTT header byte, determine the command type that the header
     * represents.
     *
     * @param header
     *        the byte value for the MQTT frame header.
     *
     * @return a string value for the given command type.
     */
    public static String commandType(byte header) {
        byte messageType = (byte) ((header & 0xF0) >>> 4);
        switch (messageType) {
            case PINGREQ.TYPE:
                return "PINGREQ";
            case CONNECT.TYPE:
                return "CONNECT";
            case DISCONNECT.TYPE:
                return "DISCONNECT";
            case SUBSCRIBE.TYPE:
                return "SUBSCRIBE";
            case UNSUBSCRIBE.TYPE:
                return "UNSUBSCRIBE";
            case PUBLISH.TYPE:
                return "PUBLISH";
            case PUBACK.TYPE:
                return "PUBACK";
            case PUBREC.TYPE:
                return "PUBREC";
            case PUBREL.TYPE:
                return "PUBREL";
            case PUBCOMP.TYPE:
                return "PUBCOMP";
            default:
                return "UNKNOWN";
        }
    }
}
```


Overlapping Code:
```
 an MQTT formatted Topic name into a suitable ActiveMQ Destination
* name string.
*
* @param name
* the MQTT formatted topic name.
*
* @return an destination name that fits the ActiveMQ conventions.
*/
public static String convertMQTTToActiveMQ(String name) {
char[] chars = name.toCharArray();
for (int i = 0; i < chars.length; i++) {
switch(chars[i]) {
case '#':
chars[i] = '>';
break;
case '>':
chars[i] = '#';
break;
case '+':
chars[i] = '*';
break;
case '*':
chars[i] = '+';
break;
case '/':
chars[i] = '.';
break;
case '.':
chars[i] = '/';
break;
}
}
String rc = new String(chars);
return rc;
}
/**
* Converts an ActiveMQ destination name into a correctly formatted
* MQTT destination name.
*
* @param destinationName
* the ActiveMQ destination name to process.
*
* @return a destination name formatted for MQTT.
*/
public static String convertActiveMQToMQTT(String destinationName) {
char[] chars = destinationName.toCharArray();
for (int i = 0; i < chars.length; i++) {
switch(chars[i]) {
case '>':
chars[i] = '#';
break;
case '#':
chars[i] = '>';
break;
case '*':
chars[i] = '+';
break;
case '+':
chars[i] = '*';
break;
case '.':
chars[i] = '/';
break;
case '/':
chars[i] = '.';
break;
}
}
String rc = new String(chars);
return rc;
}
/**
* Given an MQTT header byte, determine the command type that the header
* represents.
*
* @param header
* the byte value for the MQTT frame header.
*
* @return a string value for the given command type.
*/
public sta
```
<Overlap Ratio: 0.9612352168199737>

---

--- 366 --
Question ID: 54c8e57a21a94874674b8a91dd39f7308c562c2c
Original Code:
```
public class ProcessTable extends AbstractTableModel {

    // Satisfying the linter
    private static final long serialVersionUID = 1L;

    // TER stands for tempo executável restante
    private final String columns[] = {"PID", "Nome", "TER", "Prioridade"};
    private Vector<Object[]> data = new Vector<>();

    /**
     *
     * @param data
     */
    public void push(Object data[]) {
        this.data.add(data);
        fireTableRowsInserted(this.data.size(), this.data.size()+1);
    }

    /**
     *
     * @param row
     */
    public void remove(int row) {
        data.remove(row);
        fireTableRowsDeleted(row, row);
    }

    public void remove(Object data[]) {
        this.data.remove(data);
        fireTableRowsDeleted(0, this.data.size());
    }

    public void update() {
        fireTableRowsUpdated(0, data.size());
    }

    /**
     * @brief Clears the entire table
     */
    public void clear() {
        this.data.clear();
        fireTableRowsDeleted(0, data.size());
    }

    /**
     *
     * @return
     */
    public int getRowCount() {
        return data.size();
    }

    /**
     *
     * @return
     */
    public int getColumnCount() {
        return columns.length;
    }

    /**
     *
     */
    @Override
    public String getColumnName(int i) {
        return columns[i];
    }

    /**
     * @brief Returns the data at row and column indicated on the arguments,
     * it might return null and the caller should treat that behavior.
     */
    public Object getValueAt(int row, int column) {
        Object r = null;

        try {
            r = data.get(row)[column];
        } catch(ArrayIndexOutOfBoundsException ex) {
            System.out.println("Error trying to retrieve an element from the table.");
        }

        return r;
    }

    /**
     *
     * @param row
     * @return
     */
    public Object[] getValue(int row) {
        return data.get(row);
    }
}
```


Overlapping Code:
```
blic class ProcessTable extends AbstractTableModel {
// Satisfying the linter
private static final long serialVersionUID = 1L;
// TER stands for tempo executável restante
private final String columns[] = {"PID", "Nome", "TER", "Prioridade"};
private Vector<Object[]> data = new Vector<>();
/**
*
* @param data
*/
public void push(Object data[]) {
this.data.add(data);
fireTableRowsInserted(this.data.size(), this.data.size()+1);
}
/**
*
* @param row
*/
public void remove(int row) {
data.remove(row);
fireTableRowsDeleted(row, row);
}
public void remove(Object data[]) {
this.data.remove(data);
fireTableRowsDeleted(0, this.data.size());
}
public void update() {
fireTableRowsUpdated(0, data.size());
}
/**
* @brief Clears the entire table
*/
public void clear() {
this.data.clear();
fireTableRowsDeleted(0, data.size());
}
/**
*
* @return
*/
public int getRowCount() {
return data.size();
}
/**
*
* @return
*/
public int getColumnCount() {
return columns.length;
}
/**
*
*/
@Override
public String getColumnName(int i) {
return columns[i];
}
/**
* @brief Returns the data at row and column indicated on the arguments,
* it might return null and the caller should treat that behavior.
*/
public Object getValueAt(int row, int column) {
Object r = null;
try {
r = data.get(row)[column];
} catch(ArrayIndexOutOfBoundsException ex) {
System.out.println("Error trying to retrieve an element from the table.");
}
return r;
}
/**
*
* @param row
* @return
*/
public Object[] getValue(int row) {
return data.get(r
```
<Overlap Ratio: 0.9933993399339934>

---

--- 367 --
Question ID: be6b957ca144bfb7eb19b51308ca855e7fdc65c4
Original Code:
```
@Service
public class UserService extends BaseService<UserMapper, User> {

	public int find(int time) {
		return dao.find(time);
	}
	
	/**
	 * @param user
	 * @return
	 */
	@Transactional
	public Result<User> doBiz(User user) {
		logger.info("start doBiz");

		User u = this.queryForUpdateOne(user);

		logger.info(u);

		logger.info("debug dot");

		if (u == null) {
			return Result.fail("aaa");
		}
		if ("123".equals(u.getName())) {
			return Result.fail("bbb");
		}

		return Result.ok(u);

	}

}
```


Overlapping Code:
```
@Service
public class UserService extends BaseService<UserMapper, User> {
public int find(int time) {
return dao.find(time);
}

/**
* @param user
* @return
*/
@Transactional
public Result<User> doBiz(User user) {
logger.info("start doBiz");
User u = this.queryForUpdateOne(user);
logger.info(u);
logger.info("debug dot");
if (u == null) {
return Result.fail("aaa");
}
if ("123".equals(u.getName())) {
return Result.fail("bbb");
}
return Result
```
<Overlap Ratio: 0.9757709251101322>

---

--- 368 --
Question ID: e765d1bb5a0173e06bbc2766f0d7a27169bd5a6c
Original Code:
```
public class StitchProblem implements IStitchProblem {

    private RecognitionException sourceException = null;
    private int severity = UNKNOWN;

    public StitchProblem(RecognitionException exception, int severity) {
        sourceException = exception;
        this.severity = severity;
    }

    public RecognitionException getSourceException () {
        return sourceException;
    }
    /* (non-Javadoc)
     * @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getSeverity()
     */
    @Override
    public int getSeverity () {
        return severity;
    }

    /* (non-Javadoc)
     * @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getMessage()
     */
    @Override
    public String getMessage () {
        return sourceException.getMessage();
    }

    /* (non-Javadoc)
     * @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getLine()
     */
    @Override
    public int getLine () {
        return sourceException.getLine();
    }

    /* (non-Javadoc)
     * @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getColumn()
     */
    @Override
    public int getColumn () {
        return sourceException.getColumn();
    }

    @Override
    public IStitchProblem clone () {
        return new StitchProblem (sourceException, severity);
    }

    @Override
    public boolean equals (Object o) {
        if (o instanceof StitchProblem) {
            StitchProblem p = (StitchProblem) o;
            return getMessage ().equals (p.getMessage ()) && getLine () == p.getLine () && getColumn () == p.getColumn () && severity == p.severity;
        }
        return false;
    }

    @Override
    public int hashCode () {
        final int prime = 31;
        int result = 1;
        result = prime * result + getMessage ().hashCode ();
        result = result * prime + getColumn ();
        result = result * prime + getLine ();
        result = result * prime + getSeverity ();
        return result;
    }
/*
	public int getOffset() {
		// TODO Calculate offset location
		return 1;
	}

	public int getLength() {
		// TODO Calculate length of problem
		return 1;
	}
 */	
}
```


Overlapping Code:
```
public class StitchProblem implements IStitchProblem {
private RecognitionException sourceException = null;
private int severity = UNKNOWN;
public StitchProblem(RecognitionException exception, int severity) {
sourceException = exception;
this.severity = severity;
}
public RecognitionException getSourceException () {
return sourceException;
}
/* (non-Javadoc)
* @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getSeverity()
*/
@Override
public int getSeverity () {
return severity;
}
/* (non-Javadoc)
* @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getMessage()
*/
@Override
public String getMessage () {
return sourceException.getMessage();
}
/* (non-Javadoc)
* @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getLine()
*/
@Override
public int getLine () {
return sourceException.getLine();
}
/* (non-Javadoc)
* @see org.sa.rainbow.stitch.editor.parserhelper.IStitchProblem#getColumn()
*/
@Override
public int getColumn () {
return sourceException.getColumn();
}
@Override
public IStitchProblem clone () {
return new StitchProblem (sourceException, severity);
}
@Override
public boolean equals (Object o) {
if (o instanceof StitchProblem) {
StitchProblem p = (StitchProblem) o;
return getMessage ().equals (p.getMessage ()) && getLine () == p.getLine () && getColumn () == p.getColumn () && severity == p.severity;
}
return false;
}
@Override
public int hashCode () {
final int prime = 31;
int result = 1;
result = prime * result + getMessage ().hashCode ();
result = result * prime + getColumn ();
result = result * prime + getLine ();
result = result * prime + getSeverity ();
return result;
}
/*
public int getOffset() {
// TODO Calculate offset location
return 1;
}
public int getLength() {
// TODO C
```
<Overlap Ratio: 0.9754738015607581>

---

--- 369 --
Question ID: c4f0f769920be064bc206f26adb1a7c9996c545b
Original Code:
```
public class Table2DViewer_JPanel extends javax.swing.JPanel {
    
    private int[] xi = null;
    private int[] eta = null;
    private double[][] v = null;
    /**
     * Creates new form Table2DViewer_JPanel
     */
    public Table2DViewer_JPanel() {
        initComponents();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        jScrollPane = new javax.swing.JScrollPane();
        jTable = new javax.swing.JTable();
        jPanel2 = new javax.swing.JPanel();

        jScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        jTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
        jScrollPane.setViewportView(jTable);

        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 395, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 275, Short.MAX_VALUE)
        );
        jTabbedPane1.addTab("table", jPanel1);

        org.jdesktop.layout.GroupLayout jPanel2Layout = new org.jdesktop.layout.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 395, Short.MAX_VALUE)
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 275, Short.MAX_VALUE)
        );
        jTabbedPane1.addTab("plot", jPanel2);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jTabbedPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jTabbedPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    public void setModelData(int[] xi, int[] eta, double[][] v) {
        this.xi = xi;
        this.eta = eta;
        this.v = v;
        String[] colnames = new String[xi.length+1];
        Object [][] o = new Object[eta.length][xi.length+1];
        colnames[0] = "eta/xi";
        for (int i=1;i<=xi.length;i++) {
            colnames[i] = String.valueOf(xi[i]);
        }
        for (int j=0;j<eta.length;j++) {
            for (int i=1;i<=xi.length;i++) {
                o[j][i] = String.valueOf(v[j][i]);
            }
        }
        jTable = new JTable(o,colnames);
    }

    void setTableModel(AbstractTableModel tm) {
        jTable.setModel(tm);
        int cc = jTable.getColumnCount();
        javax.swing.table.TableColumn tc = null;
        for (int c=0;c<cc;c++) {
            tc = jTable.getColumnModel().getColumn(c);
            tc.setPreferredWidth(100);
        }
        jTable.validate();
        jTable.repaint();
        jScrollPane.validate();
        jScrollPane.repaint();    
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTable jTable;
    // End of variables declaration//GEN-END:variables
    
}
```


Overlapping Code:
```
xtends javax.swing.JPanel {

private int[] xi = null;
private int[] eta = null;
private double[][] v = null;
/**
* Creates new form Table2DViewer_JPanel
*/
public Table2DViewer_JPanel() {
initComponents();
}

/** This method is called from within the constructor to
* initialize the form.
* WARNING: Do NOT modify this code. The content of this method is
* always regenerated by the Form Editor.
*/
// <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
private void initComponents() {
jTabbedPane1 = new javax.swing.JTabbedPane();
jPanel1 = new javax.swing.JPanel();
jScrollPane = new javax.swing.JScrollPane();
jTable = new javax.swing.JTable();
jPanel2 = new javax.swing.JPanel();
jScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
jTable.setModel(new javax.swing.table.DefaultTableModel(
new Object [][] {
{null, null, null, null},
{null, null, null, null},
{null, null, null, null},
{null, null, null, null}
},
new String [] {
"Title 1", "Title 2", "Title 3", "Title 4"
}
));
jTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
jScrollPane.setViewportView(jTable);
org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
jPanel1.setLayout(jPanel1Layout);
jPanel1Layout.setHorizontalGroup(
jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
.add(jScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 395, Short.MAX_VALUE)
);
jPanel1Layout.setVerticalGroup(
jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
.add(jScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 275, Short.MAX_VALUE)
);
jTabbedPane1.addTab("table", jPanel1);
org.jdesktop.layout.GroupLayout jPanel2Layout = new org.jdesktop.layout.GroupLayout(jPanel2);
jPanel2.setLayout(jPanel2Layout);
jPanel2Layout.setHorizontalGroup(
jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
.add(0, 395, Short.MAX_VALUE)
);

```
<Overlap Ratio: 0.9813542688910697>

---

--- 370 --
Question ID: af65d9b6a962703dcf28e346b2997125676cfed1
Original Code:
```
public class MessagesRenderer extends UINotificationRenderer {

    private static final Logger logger = Logger.getLogger(MessagesRenderer.class.getName());

    @Override
    public void encodeEnd(FacesContext context, UIComponent component) throws IOException {
        Messages uiMessages = (Messages) component;
        ResponseWriter writer = context.getResponseWriter();
        String clientId = uiMessages.getClientId(context);
        Map<String, List<FacesMessage>> messagesMap = new HashMap<>();
        boolean globalOnly = uiMessages.isGlobalOnly();
        String containerClass = uiMessages.isShowIcon() ? Messages.CONTAINER_CLASS : Messages.ICONLESS_CONTAINER_CLASS;
        String style = uiMessages.getStyle();
        String styleClass = uiMessages.getStyleClass();
        styleClass = (styleClass == null) ? containerClass : containerClass + " " + styleClass;

        String _for = uiMessages.getFor();
        List<FacesMessage> messages = new ArrayList<>();
        if (!isValueBlank(_for)) {
            String forType = uiMessages.getForType();
            Iterator<FacesMessage> messagesIterator = context.getMessages(_for);

            // key case
            if (forType == null || forType.equals("key")) {
                while (messagesIterator.hasNext()) {
                    messages.add(messagesIterator.next());
                }
            }

            // clientId / SearchExpression case
            if (forType == null || forType.equals("expression")) {
                UIComponent forComponent = SearchExpressionFacade.resolveComponent(
                        context, uiMessages, _for, SearchExpressionHint.IGNORE_NO_RESULT);
                if (forComponent != null) {
                    String forComponentClientId = forComponent.getClientId(context);
                    if (!_for.equals(forComponentClientId)) {
                        messagesIterator = context.getMessages(forComponentClientId);
                        while (messagesIterator.hasNext()) {
                            FacesMessage next = messagesIterator.next();
                            if (!messages.contains(next)) {
                                messages.add(next);
                            }
                        }
                    }
                }
            }
        }
        else {
            Iterator<FacesMessage> messagesIterator = uiMessages.isGlobalOnly() ? context.getMessages(null) : context.getMessages();
            while (messagesIterator.hasNext()) {
                messages.add(messagesIterator.next());
            }
        }

        for (int i = 0; i < messages.size(); i++) {
            FacesMessage message = messages.get(i);
            FacesMessage.Severity severity = message.getSeverity();

            if (severity.equals(FacesMessage.SEVERITY_INFO)) {
                addMessage(uiMessages, message, messagesMap, "info");
            }
            else if (severity.equals(FacesMessage.SEVERITY_WARN)) {
                addMessage(uiMessages, message, messagesMap, "warn");
            }
            else if (severity.equals(FacesMessage.SEVERITY_ERROR)) {
                addMessage(uiMessages, message, messagesMap, "error");
            }
            else if (severity.equals(FacesMessage.SEVERITY_FATAL)) {
                addMessage(uiMessages, message, messagesMap, "fatal");
            }
        }

        writer.startElement("div", uiMessages);
        writer.writeAttribute("id", clientId, "id");
        writer.writeAttribute("class", styleClass, null);

        if (style != null) {
            writer.writeAttribute("style", style, null);
        }

        writer.writeAttribute("aria-live", "polite", null);

        if (PrimeApplicationContext.getCurrentInstance(context).getConfig().isClientSideValidationEnabled()) {
            writer.writeAttribute("data-global", String.valueOf(globalOnly), null);
            writer.writeAttribute("data-summary", uiMessages.isShowSummary(), null);
            writer.writeAttribute("data-detail", uiMessages.isShowDetail(), null);
            writer.writeAttribute("data-severity", getClientSideSeverity(uiMessages.getSeverity()), null);
            writer.writeAttribute("data-redisplay", String.valueOf(uiMessages.isRedisplay()), null);
        }

        for (String severity : messagesMap.keySet()) {
            List<FacesMessage> severityMessages = messagesMap.get(severity);

            if (severityMessages.size() > 0) {
                encodeSeverityMessages(context, uiMessages, severity, severityMessages);
            }
        }

        writer.endElement("div");
    }

    protected void addMessage(Messages uiMessages, FacesMessage message, Map<String, List<FacesMessage>> messagesMap, String severity) {
        if (shouldRender(uiMessages, message, severity)) {
            List<FacesMessage> severityMessages = messagesMap.get(severity);

            if (severityMessages == null) {
                severityMessages = new ArrayList<>();
                messagesMap.put(severity, severityMessages);
            }

            severityMessages.add(message);
        }
    }

    protected void encodeSeverityMessages(FacesContext context, Messages uiMessages, String severity, List<FacesMessage> messages) throws IOException {
        ResponseWriter writer = context.getResponseWriter();
        String styleClassPrefix = Messages.SEVERITY_PREFIX_CLASS + severity;
        boolean escape = uiMessages.isEscape();

        writer.startElement("div", null);
        writer.writeAttribute("class", styleClassPrefix + " ui-corner-all", null);

        if (uiMessages.isClosable()) {
            encodeCloseIcon(context, uiMessages);
        }

        if (uiMessages.isShowIcon()) {
            writer.startElement("span", null);
            writer.writeAttribute("class", styleClassPrefix + "-icon", null);
            writer.endElement("span");
        }

        writer.startElement("ul", null);

        for (int i = 0; i < messages.size(); i++) {
            FacesMessage message = messages.get(i);
            writer.startElement("li", null);

            writer.writeAttribute("role", "alert", null);
            writer.writeAttribute("aria-atomic", "true", null);

            String summary = message.getSummary() != null ? message.getSummary() : "";
            String detail = message.getDetail() != null ? message.getDetail() : summary;

            if (uiMessages.isShowSummary()) {
                writer.startElement("span", null);
                writer.writeAttribute("class", styleClassPrefix + "-summary", null);

                if (escape) {
                    writer.writeText(summary, null);
                }
                else {
                    writer.write(summary);
                }

                writer.endElement("span");
            }

            if (uiMessages.isShowDetail()) {
                writer.startElement("span", null);
                writer.writeAttribute("class", styleClassPrefix + "-detail", null);

                if (escape) {
                    writer.writeText(detail, null);
                }
                else {
                    writer.write(detail);
                }

                writer.endElement("span");
            }

            writer.endElement("li");

            message.rendered();
        }

        writer.endElement("ul");

        writer.endElement("div");
    }

    protected void encodeCloseIcon(FacesContext context, Messages uiMessages) throws IOException {
        ResponseWriter writer = context.getResponseWriter();

        writer.startElement("a", null);
        writer.writeAttribute("href", "#", null);
        writer.writeAttribute("class", Messages.CLOSE_LINK_CLASS, null);
        writer.writeAttribute("onclick", "$(this).parent().slideUp();return false;", null);

        writer.startElement("span", null);
        writer.writeAttribute("class", Messages.CLOSE_ICON_CLASS, null);
        writer.endElement("span");

        writer.endElement("a");
    }
}
```


Overlapping Code:
```
esRenderer extends UINotificationRenderer {
private static final Logger logger = Logger.getLogger(MessagesRenderer.class.getName());
@Override
public void encodeEnd(FacesContext context, UIComponent component) throws IOException {
Messages uiMessages = (Messages) component;
ResponseWriter writer = context.getResponseWriter();
String clientId = uiMessages.getClientId(context);
Map<String, List<FacesMessage>> messagesMap = new HashMap<>();
boolean globalOnly = uiMessages.isGlobalOnly();
String containerClass = uiMessages.isShowIcon() ? Messages.CONTAINER_CLASS : Messages.ICONLESS_CONTAINER_CLASS;
String style = uiMessages.getStyle();
String styleClass = uiMessages.getStyleClass();
styleClass = (styleClass == null) ? containerClass : containerClass + " " + styleClass;
String _for = uiMessages.getFor();
List<FacesMessage> messages = new ArrayList<>();
if (!isValueBlank(_for)) {
String forType = uiMessages.getForType();
Iterator<FacesMessage> messagesIterator = context.getMessages(_for);
// key case
if (forType == null || forType.equals("key")) {
while (messagesIterator.hasNext()) {
messages.add(messagesIterator.next());
}
}
// clientId / SearchExpression case
if (forType == null || forType.equals("expression")) {
UIComponent forComponent = SearchExpressionFacade.resolveComponent(
context, uiMessages, _for, SearchExpressionHint.IGNORE_NO_RESULT);
if (forComponent != null) {
String forComponentClientId = forComponent.getClientId(context);
if (!_for.equals(forComponentClientId)) {
messagesIterator = context.getMessages(forComponentClientId);
while (messagesIterator.hasNext()) {
FacesMessage next = messagesIterator.next();
if (!messages.contains(next)) {
messages.add(next);
}
}
}
}
}
}
else {
Iterator<FacesMessage> messagesIterator = uiMessages.isGlobalOnly() ? context.getMessages(null) : context.getMessages();
while (messages
```
<Overlap Ratio: 0.9850905218317358>

---

--- 371 --
Question ID: 1dcc93e57dd3ea03203449b76f920367d8a89df2
Original Code:
```
public class FocusToggleCukes {

	
	 WebDriver d;
	 WebDriverWait wait;	
	public FocusToggleCukes()
	{
		d = webdriver.openApp();
		webdriver.trainerLogin();
	    //d.manage().timeouts().implicitlyWait(20,TimeUnit.SECONDS);
		wait= new WebDriverWait(d, 10);
		wait.until(elementToBeClickable(By.xpath("//li[@name='focus']")));
	   d.findElement(By.xpath("//li[@name='focus']")).click();
	}
	
	@Given("^I \"([^\"]*)\" on the focus toggle$")
	public void i_on_the_focus_toggle(String arg1) throws Throwable {
		 d.manage().timeouts().implicitlyWait(10,TimeUnit.SECONDS);
		 wait.until(elementToBeClickable(By.xpath("//*[@id=\"focusArrow\"]")));
			d.findElement(By.xpath("//*[@id=\"focusArrow\"]")).click(); 
			
			String n = d.findElement(By.xpath("//*[@id=\"focusArrow\"]")).getText();
			if(n.equals("keyboard_arrow_down"))
			{
				assertEquals(true,true);
			}
			else
			{
				assertEquals(false, true);
			}
	}

	@Then("^a list of focus \"([^\"]*)\" should not be displayed$")
	public void a_list_of_focus_should_not_be_displayed(String arg1) throws Throwable {
		
		d.manage().timeouts().implicitlyWait(10,TimeUnit.SECONDS);
		wait.until(elementToBeClickable(By.xpath("//*[@id=\"focus\"]")));
		String display = d.findElement(By.xpath("//*[@id=\"focus\"]")).getCssValue("display");
		//System.out.println(display);
		if(display.equals("block"))
		{
			assertEquals(true, true);
		}
		else
		{
			assertEquals(false, true);
		}
	    //throw new PendingException();
	    
		d.close();
	    }
	}
```


Overlapping Code:
```
Driver d;
WebDriverWait wait; 
public FocusToggleCukes()
{
d = webdriver.openApp();
webdriver.trainerLogin();
//d.manage().timeouts().implicitlyWait(20,TimeUnit.SECONDS);
wait= new WebDriverWait(d, 10);
wait.until(elementToBeClickable(By.xpath("//li[@name='focus']")));
d.findElement(By.xpath("//li[@name='focus']")).click();
}

@Given("^I \"([^\"]*)\" on the focus toggle$")
public void i_on_the_focus_toggle(String arg1) throws Throwable {
d.manage().timeouts().implicitlyWait(10,TimeUnit.SECONDS);
wait.until(elementToBeClickable(By.xpath("//*[@id=\"focusArrow\"]")));
d.findElement(By.xpath("//*[@id=\"focusArrow\"]")).click(); 

String n = d.findElement(By.xpath("//*[@id=\"focusArrow\"]")).getText();
if(n.equals("keyboard_arrow_down"))
{
assertEquals(true,true);
}
else
{
assertEquals(false, true);
}
}
@Then("^a list of focus \"([^\"]*)\" should not be displayed$")
public void a_list_of_focus_should_not_be_displayed(String arg1) throws Throwable {

d.manage().timeouts().implicitlyWait(10,TimeUnit.SECONDS);
wait.until(elementToBeClickable(By.xpath("//*[@id=\"focus\"]")));
String display = d.findElement(By.xpath("//*[@id=\"focus\"]")).getCssValue("display");
//System.out.println(display);
if(display.equals("block"))
{
assertEquals(true, true);
}
else
{
assertEquals(false, true);
}
//th
```
<Overlap Ratio: 0.9427121102248006>

---

--- 372 --
Question ID: 3b1e40523bf18f4821c26240437a7878dc5132c6
Original Code:
```
public class FragmentWriter {

    public static <S extends MessageSchema<S>> void write(Pipe<S> pipe, int msgIdx) {
    	assert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));
    	assert(2==Pipe.from(pipe).fragDataSize[msgIdx]) : "This constant does not this fragment size";
    	
    	int size = Pipe.addMsgIdx(pipe, msgIdx);
    	Pipe.confirmLowLevelWrite(pipe, size);
    	Pipe.publishWrites(pipe);        
    }
    
    public static <S extends MessageSchema<S>> void writeL(Pipe<S> pipe, int msgIdx, long field1) {
    	assert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));
    	assert(4==Pipe.from(pipe).fragDataSize[msgIdx]) : "This constant does not this fragment size";
    	
    	int size = Pipe.addMsgIdx(pipe, msgIdx);
    	Pipe.addLongValue(field1, pipe);
    	Pipe.confirmLowLevelWrite(pipe, size);
    	Pipe.publishWrites(pipe);        
    }
    
    public static <S extends MessageSchema<S>> void writeLV(Pipe<S> pipe, int msgIdx, long field1,
    		                                 byte[] field2Backing, int field2Position, int field2Length) {
    	assert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));
    	assert(4==Pipe.from(pipe).fragDataSize[msgIdx]) : "This constant does not this fragment size";
    	
    	int size = Pipe.addMsgIdx(pipe, msgIdx);
    	Pipe.addLongValue(field1, pipe);
    	Pipe.addByteArray(field2Backing, field2Position, field2Length, pipe);
    	Pipe.confirmLowLevelWrite(pipe, size);
    	Pipe.publishWrites(pipe);        
    }
    
    
    public static <S extends MessageSchema<S>> void writeLL(Pipe<S> pipe, int msgIdx, long field1, long field2) {
    	assert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));
    	assert(6==Pipe.from(pipe).fragDataSize[msgIdx]) : "This constant does not this fragment size";
    	
    	int size = Pipe.addMsgIdx(pipe, msgIdx);
    	Pipe.addLongValue(field1, pipe);
    	Pipe.addLongValue(field2, pipe);
    	Pipe.confirmLowLevelWrite(pipe, size);
    	Pipe.publishWrites(pipe);        
    }
    
    public static <S extends MessageSchema<S>> void writeLI(Pipe<S> pipe, int msgIdx, long field1, int field2) {
    	assert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));
    	assert(5==Pipe.from(pipe).fragDataSize[msgIdx]) : "This constant does not this fragment size";

    	int size = Pipe.addMsgIdx(pipe, msgIdx);
    	Pipe.addLongValue(field1, pipe);
    	Pipe.addIntValue(field2, pipe);
    	Pipe.confirmLowLevelWrite(pipe, size);
    	Pipe.publishWrites(pipe);        
    }
    
    public static <S extends MessageSchema<S>> void writeII(Pipe<S> pipe, int msgIdx, int field1, int field2) {
    	assert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));
    	assert(4==Pipe.from(pipe).fragDataSize[msgIdx]) : "This constant does not this fragment size";

    	int size = Pipe.addMsgIdx(pipe, msgIdx);
    	Pipe.addIntValue(field1, pipe);
    	Pipe.addIntValue(field2, pipe);
    	Pipe.confirmLowLevelWrite(pipe, size);
    	Pipe.publishWrites(pipe);        
    }
    
    public static <S extends MessageSchema<S>> void writeLII(Pipe<S> pipe, int msgIdx, long field1, int field2, int field3) {
    	assert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));
    	assert(6==Pipe.from(pipe).fragDataSize[msgIdx]) : "This constant does not this fragment size";
    	
    	int size = Pipe.addMsgIdx(pipe, msgIdx);
    	Pipe.addLongValue(field1, pipe);
    	Pipe.addIntValue(field2, pipe);
    	Pipe.addIntValue(field3, pipe);
    	Pipe.confirmLowLevelWrite(pipe, size);
    	Pipe.publishWrites(pipe);        
    }
    
    public static <S extends MessageSchema<S>> void writeI(Pipe<S> pipe, int msgIdx, int field1) {
    	assert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));
    	assert(3==Pipe.from(pipe).fragDataSize[msgIdx]) : "This constant does not this fragment size";
    	
    	int size = Pipe.addMsgIdx(pipe, msgIdx);
    	Pipe.addIntValue(field1, pipe);
    	Pipe.confirmLowLevelWrite(pipe, size);
    	Pipe.publishWrites(pipe);        
    }
}
```


Overlapping Code:
```
agmentWriter {
public static <S extends MessageSchema<S>> void write(Pipe<S> pipe, int msgIdx) {
assert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));
assert(2==Pipe.from(pipe).fragDataSize[msgIdx]) : "This constant does not this fragment size";

int size = Pipe.addMsgIdx(pipe, msgIdx);
Pipe.confirmLowLevelWrite(pipe, size);
Pipe.publishWrites(pipe); 
}

public static <S extends MessageSchema<S>> void writeL(Pipe<S> pipe, int msgIdx, long field1) {
assert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));
assert(4==Pipe.from(pipe).fragDataSize[msgIdx]) : "This constant does not this fragment size";

int size = Pipe.addMsgIdx(pipe, msgIdx);
Pipe.addLongValue(field1, pipe);
Pipe.confirmLowLevelWrite(pipe, size);
Pipe.publishWrites(pipe); 
}

public static <S extends MessageSchema<S>> void writeLV(Pipe<S> pipe, int msgIdx, long field1,
byte[] field2Backing, int field2Position, int field2Length) {
assert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));
assert(4==Pipe.from(pipe).fragDataSize[msgIdx]) : "This constant does not this fragment size";

int size = Pipe.addMsgIdx(pipe, msgIdx);
Pipe.addLongValue(field1, pipe);
Pipe.addByteArray(field2Backing, field2Position, field2Length, pipe);
Pipe.confirmLowLevelWrite(pipe, size);
Pipe.publishWrites(pipe); 
}


public static <S extends MessageSchema<S>> void writeLL(Pipe<S> pipe, int msgIdx, long field1, long field2) {
assert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));
assert(6==Pipe.from(pipe).fragDataSize[msgIdx]) : "This constant does not this fragment size";

int size = Pipe.addMsgIdx(pipe, msgIdx);
Pipe.addLongValue(field1, pipe);
Pipe.addLongValue(field2, pipe);
Pipe.confirmLowLevelWrite(pipe, size);
Pipe.publishWrites(pipe); 
}

public static <S extends MessageSchema<S>> void writeLI(Pipe<S> pipe, int msgIdx, long field1, int field2) {
assert(FieldReferenceOffsetManager.isValidMsgIdx(Pipe.from(pipe), msgIdx));
assert(5==Pipe.from(pipe).fragDataSize[msgIdx]) : "This constant does not this fragment size";
int size = Pipe.addMsgIdx(pipe, msgIdx);
Pipe.addLongValue(field1, pipe);
Pipe.addIntValue(field2, pipe);
P
```
<Overlap Ratio: 0.990450204638472>

---

--- 373 --
Question ID: 436c36b613e16641918f45949d4eead6da5afc23
Original Code:
```
public class SViewOrdersToProcess extends SGridPaneView {
    
    private Date mtDateStart;
    private Date mtDateFinal;
    private int mnYearId;
    private int mnBizPartherId;
    
    public SViewOrdersToProcess(SGuiClient client, int gridType, int gridSubtype, String title, SGuiParams params) {
        super(client, SGridConsts.GRID_PANE_VIEW, gridType, gridSubtype, title, params);
        initComponentsCustom();
    }

    /*
     * Private methods
     */

    private void initComponentsCustom() {
        setRowButtonsEnabled(false);
        mtDateStart = null;
        mnBizPartherId = 0;
        createGridColumns();
    }

    private void setParamsView(final Date dateStart, final Date dateFinal, final int year, final int idBizPartner ) {
        mtDateStart = dateStart;
        mtDateFinal = dateFinal;
        mnYearId = year;
        mnBizPartherId = idBizPartner;
    }
    
    private void renderView() {
        createGridColumns();
        populateGrid(SGridConsts.REFRESH_MODE_RELOAD);
    }

    /*
     * Public methods
     */
    
    public void initView(final Date dateStart, final Date dateFinal, final int year, final int idBizPartner) {
        setParamsView(dateStart, dateFinal, year, idBizPartner);
        renderView();
    }
    
    
    /*
     * Overriden methods
     */
    
    @Override
    public void prepareSqlQuery() {
        
        moPaneSettings = new SGridPaneSettings(2);
        msSql = "SELECT id_year " + SDbConsts.FIELD_ID + "1, " +
                "id_doc " + SDbConsts.FIELD_ID + "2, " + 
                "'' AS " + SDbConsts.FIELD_CODE + ", " +
                "'' AS " + SDbConsts.FIELD_NAME + ", " + 
                "num_ref, dt, f_num, fid_cob, fid_bpb, f_cob_code, bpb, " +
                "SUM(f_qty) AS f_qty, SUM(f_orig_qty) AS f_orig_qty, SUM(f_link_qty) AS f_link_qty, SUM(f_link_orig_qty) AS f_link_orig_qty, COUNT(*) AS f_count, COUNT(f_link_orig_qty >= f_orig_qty) AS f_count_link " +
                "FROM (SELECT de.id_year, de.id_doc, d.dt, d.dt_doc_delivery_n, d.dt_doc_lapsing_n, d.num_ref, d.b_link, d.ts_link, CONCAT(d.num_ser, IF(length(d.num_ser) = " + SModSysConsts.FINS_CFD_TAX_NA + ", '', '-'), d.num) " +
                "AS f_num, d.fid_cob, d.fid_bpb, d.fid_bp_r, d.fid_usr_link, dt.code AS f_dt_code, dn.code AS f_dn_code, cob.code AS f_cob_code, bb.bpb, b.bp, bc.bp_key, c.cur_key, ul.usr, de.fid_item, de.fid_unit, " +
                "de.fid_orig_unit, de.surplus_per, de.qty AS f_qty, de.orig_qty AS f_orig_qty, CASE WHEN de.qty = " + SModSysConsts.FINS_CFD_TAX_NA + " THEN " + SModSysConsts.FINS_CFD_TAX_NA + " ELSE de.stot_cur_r / de.qty END AS f_price_u, " +
                "CASE WHEN de.orig_qty = " + SModSysConsts.FINS_CFD_TAX_NA + " THEN " + SModSysConsts.FINS_CFD_TAX_NA + " ELSE de.stot_cur_r / de.orig_qty END AS f_orig_price_u, i.item_key, i.item, ig.igen, u.symbol AS f_unit, uo.symbol AS f_orig_unit, " +
                "COALESCE((SELECT SUM(ds.qty) FROM trn_dps_dps_supply AS ds, trn_dps_ety AS xde, trn_dps AS xd WHERE ds.id_src_year = de.id_year AND ds.id_src_doc = de.id_doc AND ds.id_src_ety = de.id_ety " +
                "AND ds.id_des_year = xde.id_year AND ds.id_des_doc = xde.id_doc AND ds.id_des_ety = xde.id_ety AND xde.id_year = xd.id_year AND xde.id_doc = xd.id_doc AND xde.b_del = " + SModSysConsts.FINS_CFD_TAX_NA + " AND xd.b_del = " + SModSysConsts.FINS_CFD_TAX_NA + " " +
                "AND xd.fid_st_dps = " + SDataConstantsSys.TRNS_ST_DPS_EMITED + "), " + SModSysConsts.FINS_CFD_TAX_NA + ") AS f_link_qty, COALESCE((SELECT SUM(ds.orig_qty) FROM trn_dps_dps_supply AS ds, trn_dps_ety AS xde, trn_dps AS xd WHERE ds.id_src_year = de.id_year " +
                "AND ds.id_src_doc = de.id_doc AND ds.id_src_ety = de.id_ety AND ds.id_des_year = xde.id_year AND ds.id_des_doc = xde.id_doc AND ds.id_des_ety = xde.id_ety AND xde.id_year = xd.id_year " +
                "AND xde.id_doc = xd.id_doc AND xde."
                + "b_del = " + SModSysConsts.FINS_CFD_TAX_NA + " AND xd.b_del = " + SModSysConsts.FINS_CFD_TAX_NA + " AND xd.fid_st_dps = " + SDataConstantsSys.TRNS_ST_DPS_EMITED + "), " + SModSysConsts.FINS_CFD_TAX_NA + ") AS f_link_orig_qty " +
                "FROM " + SModConsts.TablesMap.get(SModConsts.TRN_DPS) + " AS d INNER JOIN " + SModConsts.TablesMap.get(SModConsts.TRN_DPS_ETY) + " AS de ON d.id_year = de.id_year " +
                "AND d.id_doc = de.id_doc AND d.b_del = " + SModSysConsts.FINS_CFD_TAX_NA + " AND de.b_del = " + SModSysConsts.FINS_CFD_TAX_NA + " AND d.fid_st_dps = " + SDataConstantsSys.TRNS_ST_DPS_EMITED + " " ; 
                if (mnGridMode == SDataConstantsSys.BPSS_CT_BP_CUS) {
                    msSql += "AND d.fid_ct_dps = " + SDataConstantsSys.TRNS_ST_DPS_EMITED + " AND d.fid_cl_dps = " + SDataConstantsSys.TRNS_ST_DPS_EMITED + " AND d.fid_tp_dps = " + SDataConstantsSys.TRNS_ST_DPS_NEW + " ";
                }
                else {
                    msSql += "AND d.fid_ct_dps = " + SDataConstantsSys.TRNS_ST_DPS_NEW + " AND d.fid_cl_dps = " + SDataConstantsSys.TRNS_ST_DPS_EMITED + " AND d.fid_tp_dps = " + SDataConstantsSys.TRNS_ST_DPS_NEW + " ";
                }                
                msSql += " AND d.id_year <= " + mnYearId + " AND d.dt >= '" + SLibUtils.DbmsDateFormatDate.format(mtDateStart) + "' AND d.dt <= '" + SLibUtils.DbmsDateFormatDate.format(mtDateFinal) + "' " +
                "AND d.fid_cob = " + SDataConstantsSys.TRNS_ST_DPS_NEW + " AND d.fid_bp_r = " + mnBizPartherId + 
                " INNER JOIN " + SModConsts.TablesMap.get(SModConsts.TRNU_TP_DPS) + " AS dt ON d.fid_ct_dps = dt.id_ct_dps AND d.fid_cl_dps = dt.id_cl_dps AND d.fid_tp_dps = dt.id_tp_dps " +
                "INNER JOIN " + SModConsts.TablesMap.get(SModConsts.TRNU_DPS_NAT) + " AS dn ON d.fid_dps_nat = dn.id_dps_nat " +
                "INNER JOIN " + SModConsts.TablesMap.get(SModConsts.BPSU_BPB) + " AS cob ON d.fid_cob = cob.id_bpb " +
                "INNER JOIN " + SModConsts.TablesMap.get(SModConsts.BPSU_BPB) + " AS bb ON d.fid_bpb = bb.id_bpb " +
                "INNER JOIN " + SModConsts.TablesMap.get(SModConsts.BPSU_BP) + " AS b ON d.fid_bp_r = b.id_bp " +
                "INNER JOIN " + SModConsts.TablesMap.get(SModConsts.BPSU_BP_CT) + " AS bc ON d.fid_bp_r = bc.id_bp AND bc.id_ct_bp = " + SDataConstantsSys.TRNS_ST_DPS_ANNULED + " " +
                "INNER JOIN " + SModConsts.TablesMap.get(SModConsts.CFGU_CUR) + " AS c ON d.fid_cur = c.id_cur " +
                "INNER JOIN " + SModConsts.TablesMap.get(SModConsts.USRU_USR) + " AS ul ON d.fid_usr_link = ul.id_usr " +
                "INNER JOIN " + SModConsts.TablesMap.get(SModConsts.ITMU_ITEM) + " AS i ON de.fid_item = i.id_item " +
                "INNER JOIN " + SModConsts.TablesMap.get(SModConsts.ITMU_IGEN) + " AS ig ON i.fid_igen = ig.id_igen " +
                "INNER JOIN " + SModConsts.TablesMap.get(SModConsts.ITMU_UNIT) + " AS u ON de.fid_unit = u.id_unit " +
                "INNER JOIN " + SModConsts.TablesMap.get(SModConsts.ITMU_UNIT) + " AS uo ON de.fid_orig_unit = uo.id_unit GROUP BY de.id_year, de.id_doc, d.dt, d.dt_doc_delivery_n, " +
                "d.num_ref, d.b_link, d.ts_link, d.num_ser, d.num, d.fid_cob, d.fid_bpb, d.fid_bp_r, d.fid_usr_link, dt.code, cob.code, bb.bpb, b.bp, bc.bp_key, c.cur_key, ul.usr, " +
                "de.fid_item, de.fid_unit, de.fid_orig_unit, de.surplus_per, de.qty, de.orig_qty, de.stot_cur_r, i.item_key, i.item, u.symbol, uo.symbol ) AS T " +
                "GROUP BY id_year, id_doc, dt, dt_doc_delivery_n, num_ref, b_link, ts_link, f_num, fid_cob, fid_bpb, fid_bp_r, fid_usr_link, f_dt_code, f_cob_code, bpb, bp, bp_key, usr " +
                "HAVING (f_link_orig_qty < f_orig_qty AND b_link = 0) OR f_count <> f_count_link ORDER BY f_dt_code, f_num, dt, id_year, id_doc, bp, bp_key, fid_bp_r, bpb, fid_bpb ";
        }

    @Override
    public ArrayList<SGridColumnView> createGridColumns() {
        SGridColumnView column = null;
        ArrayList<SGridColumnView> gridColumnsViews = new ArrayList<SGridColumnView>();
       
        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_TEXT_REG_NUM, "f_num", "Folio doc", STableConstants.WIDTH_DOC_NUM));
        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_DATE, "dt", "Fecha doc", STableConstants.WIDTH_DATE));
        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_TEXT_REG_NUM, "num_ref", "Referencia doc.", STableConstants.WIDTH_DOC_NUM_REF));
        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_DEC_QTY, "f_orig_qty", "Cantidad", STableConstants.WIDTH_VALUE));
        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_DEC_QTY, "f_link_orig_qty", "Cant. procesada", STableConstants.WIDTH_VALUE));
        
        column = new SGridColumnView(SGridConsts.COL_TYPE_DEC_PER_2D, "", "Avance %", STableConstants.WIDTH_VALUE);
        column.getRpnArguments().add(new SLibRpnArgument("f_link_orig_qty", SLibRpnArgumentType.OPERAND));
        column.getRpnArguments().add(new SLibRpnArgument("f_orig_qty", SLibRpnArgumentType.OPERAND ));
        column.getRpnArguments().add(new SLibRpnArgument(SLibRpnOperator.DIVISION, SLibRpnArgumentType.OPERATOR));
        
        gridColumnsViews.add(column);
        gridColumnsViews.add(new SGridColumnView(SGridConsts.COL_TYPE_DEC_QTY, "f_orig_qty", "Cant. pendiente", STableConstants.WIDTH_VALUE));
        return gridColumnsViews;
    }

    @Override
    public void defineSuscriptions() {
        moSuscriptionsSet.add(mnGridType);
        moSuscriptionsSet.add(SModConsts.TRNU_TP_DPS);
        moSuscriptionsSet.add(SModConsts.TRNU_DPS_NAT);
        moSuscriptionsSet.add(SModConsts.BPSU_BPB);
        moSuscriptionsSet.add(SModConsts.BPSU_BP);
        moSuscriptionsSet.add(SModConsts.BPSU_BP_CT);
        moSuscriptionsSet.add(SModConsts.CFGU_CUR);
        moSuscriptionsSet.add(SModConsts.USRU_USR);
        moSuscriptionsSet.add(SModConsts.ITMU_ITEM);
        moSuscriptionsSet.add(SModConsts.ITMU_IGEN);
        moSuscriptionsSet.add(SModConsts.ITMU_UNIT);
    }
}
```


Overlapping Code:
```
wOrdersToProcess extends SGridPaneView {

private Date mtDateStart;
private Date mtDateFinal;
private int mnYearId;
private int mnBizPartherId;

public SViewOrdersToProcess(SGuiClient client, int gridType, int gridSubtype, String title, SGuiParams params) {
super(client, SGridConsts.GRID_PANE_VIEW, gridType, gridSubtype, title, params);
initComponentsCustom();
}
/*
* Private methods
*/
private void initComponentsCustom() {
setRowButtonsEnabled(false);
mtDateStart = null;
mnBizPartherId = 0;
createGridColumns();
}
private void setParamsView(final Date dateStart, final Date dateFinal, final int year, final int idBizPartner ) {
mtDateStart = dateStart;
mtDateFinal = dateFinal;
mnYearId = year;
mnBizPartherId = idBizPartner;
}

private void renderView() {
createGridColumns();
populateGrid(SGridConsts.REFRESH_MODE_RELOAD);
}
/*
* Public methods
*/

public void initView(final Date dateStart, final Date dateFinal, final int year, final int idBizPartner) {
setParamsView(dateStart, dateFinal, year, idBizPartner);
renderView();
}


/*
* Overriden methods
*/

@Override
public void prepareSqlQuery() {

moPaneSettings = new SGridPaneSettings(2);
msSql = "SELECT id_year " + SDbConsts.FIELD_ID + "1, " +
"id_doc " + SDbConsts.FIELD_ID + "2, " + 
"'' AS " + SDbConsts.FIELD_CODE + ", " +
"'' AS " + SDbConsts.FIELD_NAME + ", " + 
"num_ref, dt, f_num, fid_cob, fid_bpb, f_cob_code, bpb, " +
"SUM(f_qty) AS f_qty, SUM(f_orig_qty) AS f_orig_qty, SUM(f_link_qty) AS f_link_qty, SUM(f_link_orig_qty) AS f_link_orig_qty, COUNT(*) AS f_count, COUNT(f_link_orig_qty >= f_orig_qty) AS f_count_link " +
"FROM (SELECT de.id_year, de.id_doc, d.dt, d.dt_doc_delivery_n, d.dt_doc_lapsing_n, d.num_ref, d.b_link, d.ts_link, CONCAT(d.num_ser, IF(length(d.num_ser) = " + SModSysConsts.FINS_CFD_TAX_NA + ", '', '-'), d.num) " +
"AS f_num, d.fid_cob, d.fid_bpb, d.fid_bp_r, d.fid_usr_link, dt.code AS f_dt_code, dn.code AS f_dn_code, cob.code AS f_cob_code, bb.bpb, b.bp, bc.bp_key, c.cur_key, ul.usr, de.fid_item, de.fid_unit, " +
"de.fid_orig_unit, de.surplus_per,
```
<Overlap Ratio: 0.9780534351145038>

---

--- 374 --
Question ID: 772087cb0130c4cc2d77bf65db6698c16350a32d
Original Code:
```
public class ScheduleAlarmManager {

    private Context mContext;
    private SwitchCompat mSwitchCompat = null;
    private boolean mAlarmOn = false;
    private ScheduleBroadcastReceiver mScheduleManager;

    public ScheduleAlarmManager(Context context, SwitchCompat switchCompat) {

        /**
         *
         */
        this.mContext = context;
        this.mSwitchCompat = switchCompat;

        /**
         *
         */
        mScheduleManager = new ScheduleBroadcastReceiver();

        /**
         *
         */
        mAlarmOn = isAlarmOn();
        if (mAlarmOn) {
            if (mSwitchCompat != null)
                mSwitchCompat.setChecked(true);
        } else {
            if (mSwitchCompat != null)
                mSwitchCompat.setChecked(false);
        }
    }

    public boolean isAlarmOn() {

        int alarm_time_breakfast = -1;
        int alarm_time_launch = -1;
        int alarm_time_dinner = -1;

        try {
            alarm_time_breakfast = PreferenceManager.get(mContext, Argument.PREFS_ALARM_TIME_BREAKFAST, -1);
            alarm_time_launch = PreferenceManager.get(mContext, Argument.PREFS_ALARM_TIME_LUNCH, -1);
            alarm_time_dinner = PreferenceManager.get(mContext, Argument.PREFS_ALARM_TIME_DINNER, -1);

            if (alarm_time_breakfast == -1 || alarm_time_launch == -1 || alarm_time_dinner == -1) {
                return false;
            } else {
                return true;
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

        return false;
    }


    public void toggleAlaram() {
        if (mAlarmOn) {
            makeAlarmOff();
        } else {
            makeAlarmOn();
        }
    }

    public void makeAlarmOn() {
        if (mSwitchCompat != null)
            mSwitchCompat.setChecked(true);
        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_BREAKFAST, 730);
        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_LUNCH, 1130);
        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_DINNER, 1720);

        if (mScheduleManager != null) {
            mScheduleManager.setAlarm(mContext);
        }

        mAlarmOn = true;
    }

    public void makeAlarmOff() {

        if (mSwitchCompat != null)
            mSwitchCompat.setChecked(false);

        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_BREAKFAST, -1);
        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_LUNCH, -1);
        PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_DINNER, -1);

        if (mScheduleManager != null) {
            mScheduleManager.cancelAlarm(mContext);
        }
        mAlarmOn = false;
    }
}
```


Overlapping Code:
```
lass ScheduleAlarmManager {
private Context mContext;
private SwitchCompat mSwitchCompat = null;
private boolean mAlarmOn = false;
private ScheduleBroadcastReceiver mScheduleManager;
public ScheduleAlarmManager(Context context, SwitchCompat switchCompat) {
/**
*
*/
this.mContext = context;
this.mSwitchCompat = switchCompat;
/**
*
*/
mScheduleManager = new ScheduleBroadcastReceiver();
/**
*
*/
mAlarmOn = isAlarmOn();
if (mAlarmOn) {
if (mSwitchCompat != null)
mSwitchCompat.setChecked(true);
} else {
if (mSwitchCompat != null)
mSwitchCompat.setChecked(false);
}
}
public boolean isAlarmOn() {
int alarm_time_breakfast = -1;
int alarm_time_launch = -1;
int alarm_time_dinner = -1;
try {
alarm_time_breakfast = PreferenceManager.get(mContext, Argument.PREFS_ALARM_TIME_BREAKFAST, -1);
alarm_time_launch = PreferenceManager.get(mContext, Argument.PREFS_ALARM_TIME_LUNCH, -1);
alarm_time_dinner = PreferenceManager.get(mContext, Argument.PREFS_ALARM_TIME_DINNER, -1);
if (alarm_time_breakfast == -1 || alarm_time_launch == -1 || alarm_time_dinner == -1) {
return false;
} else {
return true;
}
} catch (Exception e) {
e.printStackTrace();
}
return false;
}
public void toggleAlaram() {
if (mAlarmOn) {
makeAlarmOff();
} else {
makeAlarmOn();
}
}
public void makeAlarmOn() {
if (mSwitchCompat != null)
mSwitchCompat.setChecked(true);
PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_BREAKFAST, 730);
PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_LUNCH, 1130);
PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_DINNER, 1720);
if (mScheduleManager != null) {
mScheduleManager.setAlarm(mContext);
}
mAlarmOn = true;
}
public void makeAlarmOff() {
if (mSwitchCompat != null)
mSwitchCompat.setChecked(false);
PreferenceManager.put(mContext, Argument.PREFS_ALARM_TIME_BREAKFAST, -1);
PreferenceManager.put(mContext, Argument.PRE
```
<Overlap Ratio: 0.9767687434002112>

---

--- 375 --
Question ID: cc27e0847caec1d4df99cb48dac2ffd0fc604f04
Original Code:
```
class Zone {
    // zone name (e.g., "America/Los_Angeles")
    private String name;

    // zone records
    private List<ZoneRec> list;

    // target zone names for this compilation
    private static Set<String> targetZones;

    /**
     * Constructs a Zone with the specified zone name.
     * @param name the zone name
     */
    Zone(String name) {
        this.name = name;
        list = new ArrayList<ZoneRec>();
    }

    /**
     * Reads time zone names to be generated, called "target zone
     * name", from the specified text file and creats an internal hash
     * table to keep those names. It's assumed that one text line
     * contains a zone name or comments if it starts with
     * '#'. Comments can't follow a zone name in a single line.
     * @param fileName the text file name
     */
    static void readZoneNames(String fileName) {
        if (fileName == null) {
            return;
        }
        BufferedReader in = null;
        try {
            FileReader fr = new FileReader(fileName);
            in = new BufferedReader(fr);
        } catch (FileNotFoundException e) {
            Main.panic("can't open file: " + fileName);
        }
        targetZones = new HashSet<String>();
        String line;

        try {
            while ((line = in.readLine()) != null) {
                line = line.trim();
                if (line.length() == 0 || line.charAt(0) == '#') {
                    continue;
                }
                if (!targetZones.add(line)) {
                    Main.warning("duplicated target zone name: " + line);
                }
            }
            in.close();
        } catch (IOException e) {
            Main.panic("IO error: "+e.getMessage());
        }
    }

    /**
     * Determines whether the specified zone is one of the target zones.
     * If no target zones are specified, this method always returns
     * true for any zone name.
     * @param zoneName the zone name
     * @return true if the specified name is a target zone.
     */
    static boolean isTargetZone(String zoneName) {
        if (targetZones == null) {
            return true;
        }
        return targetZones.contains(zoneName);
    }

    /**
     * Forces to add "MET" to the target zone table. This is because
     * there is a conflict between Java zone name "WET" and Olson zone
     * name.
     */
    static void addMET() {
        if (targetZones != null) {
            targetZones.add("MET");
        }
    }

    /**
     * @return the zone name
     */
    String getName() {
        return name;
    }

    /**
     * Adds the specified zone record to the zone record list.
     */
    void add(ZoneRec rec) {
        list.add(rec);
    }

    /**
     * @param index the index at which the zone record in the list is returned.
     * @return the zone record specified by the index.
     */
    ZoneRec get(int index) {
        return list.get(index);
    }

    /**
     * @return the size of the zone record list
     */
    int size() {
        return list.size();
    }

    /**
     * Resolves the reference to a rule in each zone record.
     * @param zi the Zoneinfo object with which the rule reference is
     * resolved.
     */
    void resolve(Zoneinfo zi) {
        for (int i = 0; i < list.size(); i++) {
            ZoneRec rec = list.get(i);
            rec.resolve(zi);
        }
    }
}
```


Overlapping Code:
```
merica/Los_Angeles")
private String name;
// zone records
private List<ZoneRec> list;
// target zone names for this compilation
private static Set<String> targetZones;
/**
* Constructs a Zone with the specified zone name.
* @param name the zone name
*/
Zone(String name) {
this.name = name;
list = new ArrayList<ZoneRec>();
}
/**
* Reads time zone names to be generated, called "target zone
* name", from the specified text file and creats an internal hash
* table to keep those names. It's assumed that one text line
* contains a zone name or comments if it starts with
* '#'. Comments can't follow a zone name in a single line.
* @param fileName the text file name
*/
static void readZoneNames(String fileName) {
if (fileName == null) {
return;
}
BufferedReader in = null;
try {
FileReader fr = new FileReader(fileName);
in = new BufferedReader(fr);
} catch (FileNotFoundException e) {
Main.panic("can't open file: " + fileName);
}
targetZones = new HashSet<String>();
String line;
try {
while ((line = in.readLine()) != null) {
line = line.trim();
if (line.length() == 0 || line.charAt(0) == '#') {
continue;
}
if (!targetZones.add(line)) {
Main.warning("duplicated target zone name: " + line);
}
}
in.close();
} catch (IOException e) {
Main.panic("IO error: "+e.getMessage());
}
}
/**
* Determines whether the specified zone is one of the target zones.
* If no target zones are specified, this method always returns
* true for any zone name.
* @param zoneName the zone name
* @return true if the specified name is a target zone.
*/
static boolean isTargetZone(String zoneName) {
if (targetZones == null) {
return true;
}
return targetZones.contains(zoneName);
}
/**
* Forces to add "MET" to the target zone table. This is because
* there is a conflict between Java zone name "WET" and Olson zone
* name.
*/
static void addMET() {
if (targetZones != null) {
targetZones.add("MET
```
<Overlap Ratio: 0.9761286974571873>

---

--- 376 --
Question ID: 0a1cff05ff48d038052763683036ba4a882695a9
Original Code:
```
public class OracleSqlStatementBuilderSmallTest {
    private OracleSqlStatementBuilder builder = new OracleSqlStatementBuilder();

    @Test
    public void changeDelimiterRegEx() {
        assertNull(builder.changeDelimiterIfNecessary("BEGIN_DATE", null));
        assertEquals("/", builder.changeDelimiterIfNecessary("BEGIN DATE", null).getDelimiter());
        assertEquals("/", builder.changeDelimiterIfNecessary("BEGIN", null).getDelimiter());
    }

    @Test
    public void javaSource() {
        builder.addLine("CREATE OR REPLACE AND COMPILE JAVA SOURCE NAMED \"JavaTest\" AS");
        assertFalse(builder.isTerminated());
        builder.addLine("public class JavaTest {");
        assertFalse(builder.isTerminated());
        builder.addLine("};");
        assertFalse(builder.isTerminated());
        builder.addLine("/");
        assertTrue(builder.isTerminated());
    }

    @Test
    public void nvarchar() {
        builder.addLine("INSERT INTO nvarchar2_test VALUES ( N'qwerty' );");
        assertTrue(builder.isTerminated());
    }

    @Test
    public void notNvarchar() {
        builder.addLine("INSERT INTO nvarchar2_test VALUES ( ' N' );");
        assertTrue(builder.isTerminated());
    }
}
```


Overlapping Code:
```
mallTest {
private OracleSqlStatementBuilder builder = new OracleSqlStatementBuilder();
@Test
public void changeDelimiterRegEx() {
assertNull(builder.changeDelimiterIfNecessary("BEGIN_DATE", null));
assertEquals("/", builder.changeDelimiterIfNecessary("BEGIN DATE", null).getDelimiter());
assertEquals("/", builder.changeDelimiterIfNecessary("BEGIN", null).getDelimiter());
}
@Test
public void javaSource() {
builder.addLine("CREATE OR REPLACE AND COMPILE JAVA SOURCE NAMED \"JavaTest\" AS");
assertFalse(builder.isTerminated());
builder.addLine("public class JavaTest {");
assertFalse(builder.isTerminated());
builder.addLine("};");
assertFalse(builder.isTerminated());
builder.addLine("/");
assertTrue(builder.isTerminated());
}
@Test
public void nvarchar() {
builder.addLine("INSERT INTO nvarchar2_test VALUES ( N'qwerty' );");
assertTrue(builder.isTerminated());
}
@Test
public void notNvarchar() {
builder.addLine("INSERT INTO nvarchar2_test VALUES ( ' N' );");
assertTrue(builder.isTerminated()
```
<Overlap Ratio: 0.9569377990430622>

---

--- 377 --
Question ID: 7b092243a77187c440d212b8ee516d672822d3e2
Original Code:
```
public class NumberPicker extends LinearLayout implements Button.OnClickListener,
        Button.OnLongClickListener {

    protected int mInputSize = 20;
    protected final Button mNumbers[] = new Button[10];
    protected int mInput[] = new int[mInputSize];
    protected int mInputPointer = -1;
    protected Button mLeft, mRight;
    protected ImageButton mDelete;
    protected NumberView mEnteredNumber;
    protected final Context mContext;

    private int mSign;
    private String mLabelText = "";
    private Button mSetButton;
    private static final int CLICKED_DECIMAL = 10;

    public static final int SIGN_POSITIVE = 0;
    public static final int SIGN_NEGATIVE = 1;

    private final Typeface mTypefaceMono;

    private ColorStateList mTextColor;
    private int mDividerColor;
    private int mDeleteDrawableSrcResId;
    private int mTheme = -1;

    private BigDecimal mMinNumber = null;
    private BigDecimal mMaxNumber = null;

    /**
     * Instantiates a NumberPicker object
     *
     * @param context the Context required for creation
     */
    public NumberPicker(Context context) {
        this(context, null);
    }

    /**
     * Instantiates a NumberPicker object
     *
     * @param context the Context required for creation
     * @param attrs   additional attributes that define custom colors, selectors, and backgrounds.
     */
    public NumberPicker(Context context, AttributeSet attrs) {
        super(context, attrs);
        mContext = context;
        LayoutInflater layoutInflater =
                (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        layoutInflater.inflate(getLayoutId(), this);

        // Init defaults
        mTextColor = getResources().getColorStateList(R.color.dialog_text_color_holo);
        mDeleteDrawableSrcResId = R.drawable.ic_backspace_normal_dark;
        mDividerColor = getResources().getColor(R.color.default_divider_color);

        mTypefaceMono = Typeface.createFromAsset(context.getAssets(), "fonts/Recursive_Monospace-Regular.ttf");
    }

    protected int getLayoutId() {
        return R.layout.number_picker_view;
    }

    /**
     * Change the theme of the Picker
     *
     * @param themeResId the resource ID of the new style
     */
    public void setTheme(int themeResId) {
        mTheme = themeResId;
        if (mTheme != -1) {
            TypedArray a = getContext().obtainStyledAttributes(themeResId, R.styleable.BetterPickersDialogFragment);

            mTextColor = a.getColorStateList(R.styleable.BetterPickersDialogFragment_bpTextColor);
            mDividerColor = a.getColor(R.styleable.BetterPickersDialogFragment_bpDividerColor, mDividerColor);
            mDeleteDrawableSrcResId = a.getResourceId(R.styleable.BetterPickersDialogFragment_bpDeleteIcon, mDeleteDrawableSrcResId);
        }

        restyleViews();
    }

    private void restyleViews() {
        for (Button number : mNumbers) {
            if (number != null) {
                number.setTextColor(mTextColor);
                number.setTypeface(mTypefaceMono);
            }
        }
        if (mLeft != null) {
            mLeft.setTextColor(mTextColor);
            mLeft.setTypeface(mTypefaceMono);
        }
        if (mRight != null) {
            mRight.setTextColor(mTextColor);
            mRight.setTypeface(mTypefaceMono);
        }
        if (mDelete != null) {
            mDelete.setImageDrawable(getResources().getDrawable(mDeleteDrawableSrcResId));
        }
        if (mEnteredNumber != null) {
            mEnteredNumber.setTheme(mTheme);
        }
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();

        for (int i = 0; i < mInput.length; i++) {
            mInput[i] = -1;
        }

        View numberPickerView = findViewById(R.id.numberPickerView);
        mEnteredNumber = (NumberView) findViewById(R.id.number_text);
        mDelete = (ImageButton) findViewById(R.id.delete);
        mDelete.setOnClickListener(this);
        mDelete.setOnLongClickListener(this);

        mNumbers[1] = numberPickerView.findViewById(R.id.key_1);
        mNumbers[2] = numberPickerView.findViewById(R.id.key_2);
        mNumbers[3] = numberPickerView.findViewById(R.id.key_3);

        mNumbers[4] = numberPickerView.findViewById(R.id.key_4);
        mNumbers[5] = numberPickerView.findViewById(R.id.key_5);
        mNumbers[6] = numberPickerView.findViewById(R.id.key_6);

        mNumbers[7] = numberPickerView.findViewById(R.id.key_7);
        mNumbers[8] = numberPickerView.findViewById(R.id.key_8);
        mNumbers[9] = numberPickerView.findViewById(R.id.key_9);

        mLeft = numberPickerView.findViewById(R.id.key_left);
        mNumbers[0] = numberPickerView.findViewById(R.id.key_0);
        mRight = numberPickerView.findViewById(R.id.key_right);
        setLeftRightEnabled();

        for (int i = 0; i < 10; i++) {
            mNumbers[i].setOnClickListener(this);
            mNumbers[i].setText(String.format("%d", i));
            mNumbers[i].setTag(R.id.numbers_key, new Integer(i));
        }
        updateNumber();

        Resources res = mContext.getResources();
        mLeft.setText(res.getString(R.string.number_picker_plus_minus));
        mRight.setText(res.getString(R.string.number_picker_seperator));
        mLeft.setOnClickListener(this);
        mRight.setOnClickListener(this);
        mSign = SIGN_POSITIVE;

        restyleViews();
        updateKeypad();
    }

    /**
     * Using View.GONE, View.VISIBILE, or View.INVISIBLE, set the visibility of the plus/minus indicator
     *
     * @param visiblity an int using Android's View.* convention
     */
    public void setPlusMinusVisibility(int visiblity) {
        if (mLeft != null) {
            mLeft.setVisibility(visiblity);
        }
    }

    /**
     * Using View.GONE, View.VISIBILE, or View.INVISIBLE, set the visibility of the decimal indicator
     *
     * @param visiblity an int using Android's View.* convention
     */
    public void setDecimalVisibility(int visiblity) {
        if (mRight != null) {
            mRight.setVisibility(visiblity);
        }
    }

    /**
     * Set a minimum required number
     *
     * @param min the minimum required number
     */
    public void setMin(BigDecimal min) {
        mMinNumber = min;
    }

    /**
     * Set a maximum required number
     *
     * @param max the maximum required number
     */
    public void setMax(BigDecimal max) {
        mMaxNumber = max;
    }

    /**
     * Update the 0 button to determine whether it is able to be clicked.
     */
    public void updateZeroButton() {
        boolean enabled = mInputPointer >= 0;
        if (mNumbers[0] != null) {
            mNumbers[0].setEnabled(enabled);
            mNumbers[0].setAlpha(enabled? (float) 1: (float) 0.3);
        }
    }

    /**
     * Update the delete button to determine whether it is able to be clicked.
     */
    public void updateDeleteButton() {
        boolean enabled = mInputPointer != -1;
        if (mDelete != null) {
            mDelete.setEnabled(enabled);
            mDelete.setAlpha(enabled? (float) 1: (float) 0.3);
        }
    }

    @Override
    public void onClick(View v) {
        v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
        doOnClick(v);
        updateDeleteButton();
    }

    protected void doOnClick(View v) {
        Integer val = (Integer) v.getTag(R.id.numbers_key);
        if (val != null) {
            // A number was pressed
            addClickedNumber(val);
        } else if (v == mDelete) {
            if (mInputPointer >= 0) {
                for (int i = 0; i < mInputPointer; i++) {
                    mInput[i] = mInput[i + 1];
                }
                mInput[mInputPointer] = 0;
                mInputPointer--;
            }
        } else if (v == mLeft) {
            onLeftClicked();
        } else if (v == mRight) {
            onRightClicked();
        }
        updateKeypad();
    }

    @Override
    public boolean onLongClick(View v) {
        v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        if (v == mDelete) {
            mDelete.setPressed(false);
            reset();
            updateKeypad();
            return true;
        }
        return false;
    }

    private void updateKeypad() {
        // Update state of keypad
        updateLeftRightButtons();
        // Update the number
        updateNumber();
        // enable/disable the "set" key
        enableSetButton();
        // Update the backspace button
        updateDeleteButton();
        // Update the zero button
        updateZeroButton();
    }

    /**
     * Set the text displayed in the small label
     *
     * @param labelText the String to set as the label
     */
    public void setLabelText(String labelText) {
        mLabelText = labelText;
    }

    /**
     * Reset all inputs.
     */
    public void reset() {
        for (int i = 0; i < mInputSize; i++) {
            mInput[i] = -1;
        }
        mInputPointer = -1;
        updateNumber();
    }

    public void enableKeypad(boolean enable) {
        for (int i = 0; i < 10; i++) {
            mNumbers[i].setEnabled(enable);
        }
        mLeft.setEnabled(enable);
    }

    // Update the number displayed in the picker:
    protected void updateNumber() {
        String numberString = getEnteredNumberString();
        numberString = numberString.replaceAll("\\-", "");
        String[] split = numberString.split("\\.");
        if (split.length >= 2) {
            if (split[0].equals("")) {
                mEnteredNumber.setNumber("0", split[1], containsDecimal(),
                        mSign == SIGN_NEGATIVE);
            } else {
                mEnteredNumber.setNumber(split[0], split[1], containsDecimal(),
                        mSign == SIGN_NEGATIVE);
            }
        } else if (split.length == 1) {
            if (split[0].equals(String.valueOf(Integer.MAX_VALUE))) {
                split[0] = "∞";
            }
            mEnteredNumber.setNumber(split[0], "", containsDecimal(),
                    mSign == SIGN_NEGATIVE);
        } else if (numberString.equals(".")) {
            mEnteredNumber.setNumber("0", "", true, mSign == SIGN_NEGATIVE);
        }
    }

    protected void setLeftRightEnabled() {
        mLeft.setEnabled(false);
        mRight.setEnabled(canAddDecimal());
        if (!canAddDecimal()) {
            mRight.setContentDescription(null);
        }
    }

    private void addClickedNumber(int val) {
        if (mInputPointer < mInputSize - 1) {
            // For 0 we need to check if we have a value of zero or not
            for (int i = mInputPointer; i >= 0; i--) {
                mInput[i + 1] = mInput[i];
            }
            mInputPointer++;
            mInput[0] = val;
        }
    }

    /**
     * Clicking on the bottom left button will toggle the sign.
     */
    private void onLeftClicked() {
        if (mSign == SIGN_POSITIVE) {
            mSign = SIGN_NEGATIVE;
        } else {
            mSign = SIGN_POSITIVE;
        }
    }

    /**
     * Clicking on the bottom right button will add a decimal point.
     */
    private void onRightClicked() {
        if (canAddDecimal()) {
            addClickedNumber(CLICKED_DECIMAL);
        }
    }

    private boolean containsDecimal() {
        boolean containsDecimal = false;
        for (int i : mInput) {
            if (i == 10) {
                containsDecimal = true;
            }
        }
        return containsDecimal;
    }

    /**
     * Checks if the user allowed to click on the right button.
     *
     * @return true or false if the user is able to add a decimal or not
     */
    private boolean canAddDecimal() {
        return !containsDecimal();
    }

    private String getEnteredNumberString() {
        String value = "";
        for (int i = mInputPointer; i >= 0; i--) {
            if (mInput[i] == -1) {
                // Don't add
            } else if (mInput[i] == CLICKED_DECIMAL) {
                value += ".";
            } else {
                value += mInput[i];
            }
        }
        return value;
    }

    /**
     * Returns the number inputted by the user
     *
     * @return a double representing the entered number
     */
    public BigDecimal getEnteredNumber() {
        String value = "0";
        for (int i = mInputPointer; i >= 0; i--) {
            if (mInput[i] == -1) {
                break;
            } else if (mInput[i] == CLICKED_DECIMAL) {
                value += ".";
            } else {
                value += mInput[i];
            }
        }
        if (mSign == SIGN_NEGATIVE) {
            value = "-" + value;
        }

        return new BigDecimal(value);
    }

    private void updateLeftRightButtons() {
        mRight.setEnabled(canAddDecimal());
    }

    /**
     * Enable/disable the "Set" button
     */
    private void enableSetButton() {
        if (mSetButton == null) {
            return;
        }

        boolean enabled = true;

        // Nothing entered - disable, or = 0
        if (mInputPointer == -1 || mInputPointer < 0) {
            enabled = false;
        }

        mSetButton.setEnabled(enabled);
        mSetButton.setAlpha(enabled? (float) 1: (float) 0.4);
    }

    /**
     * Expose the set button to allow communication with the parent Fragment.
     *
     * @param b the parent Fragment's "Set" button
     */
    public void setSetButton(Button b) {
        mSetButton = b;
        enableSetButton();
    }

    /**
     * Returns the number as currently inputted by the user
     *
     * @return an String representation of the number with no decimal
     */
    public BigInteger getNumber() {
        BigDecimal bigDecimal = getEnteredNumber().setScale(0, BigDecimal.ROUND_FLOOR);
        return bigDecimal.toBigIntegerExact();
    }

    /**
     * Returns the decimal following the number
     *
     * @return a double representation of the decimal value
     */
    public double getDecimal() {
        return getEnteredNumber().remainder(BigDecimal.ONE).doubleValue();
    }

    /**
     * Returns whether the number is positive or negative
     *
     * @return true or false whether the number is positive or negative
     */
    public boolean getIsNegative() {
        return mSign == SIGN_NEGATIVE;
    }

    public void setNumber(Integer integerPart, Double decimalPart, Integer mCurrentSign) {
        if (mCurrentSign != null) {
            mSign = mCurrentSign;
        } else {
            mSign = SIGN_POSITIVE;
        }

        if (decimalPart != null) {
            String decimalString = doubleToString(decimalPart);
            // remove "0." from the string
            readAndRightDigits(TextUtils.substring(decimalString, 2, decimalString.length()));
            mInputPointer++;
            mInput[mInputPointer] = CLICKED_DECIMAL;
        }

        if (integerPart != null) {
            readAndRightDigits(String.valueOf(integerPart));
        }
        updateKeypad();
    }

    private void readAndRightDigits(String digitsToRead) {
        for (int i = digitsToRead.length() - 1; i >= 0; i--) {
            mInputPointer++;
            mInput[mInputPointer] = digitsToRead.charAt(i) - '0';
        }
    }

    /**
     * Method used to format double and avoid scientific notation x.xE-x (ex: 4.0E-4)
     *
     * @param value double value to format
     * @return string representation of double value
     */
    private String doubleToString(double value) {
        // Use decimal format to avoid
        DecimalFormat format = new DecimalFormat("0.0");
        format.setMaximumFractionDigits(Integer.MAX_VALUE);
        return format.format(value);
    }
}
```


Overlapping Code:
```
r extends LinearLayout implements Button.OnClickListener,
Button.OnLongClickListener {
protected int mInputSize = 20;
protected final Button mNumbers[] = new Button[10];
protected int mInput[] = new int[mInputSize];
protected int mInputPointer = -1;
protected Button mLeft, mRight;
protected ImageButton mDelete;
protected NumberView mEnteredNumber;
protected final Context mContext;
private int mSign;
private String mLabelText = "";
private Button mSetButton;
private static final int CLICKED_DECIMAL = 10;
public static final int SIGN_POSITIVE = 0;
public static final int SIGN_NEGATIVE = 1;
private final Typeface mTypefaceMono;
private ColorStateList mTextColor;
private int mDividerColor;
private int mDeleteDrawableSrcResId;
private int mTheme = -1;
private BigDecimal mMinNumber = null;
private BigDecimal mMaxNumber = null;
/**
* Instantiates a NumberPicker object
*
* @param context the Context required for creation
*/
public NumberPicker(Context context) {
this(context, null);
}
/**
* Instantiates a NumberPicker object
*
* @param context the Context required for creation
* @param attrs additional attributes that define custom colors, selectors, and backgrounds.
*/
public NumberPicker(Context context, AttributeSet attrs) {
super(context, attrs);
mContext = context;
LayoutInflater layoutInflater =
(LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
layoutInflater.inflate(getLayoutId(), this);
// Init defaults
mTextColor = getResources().getColorStateList(R.color.dialog_text_color_holo);
mDeleteDrawableSrcResId = R.drawable.ic_backspace_normal_dark;
mDividerColor = getResources().getColor(R.color.default_divider_color);
mTypefaceMono = Typeface.createFromAsset(context.getAssets(), "fonts/Recursive_Monospace-Regular.ttf");
}
protected int getLayoutId() {
return R.layout.number_picker_view;
}
/**
* Change the theme of the Picker
*
* @param themeResId the resource ID of the new style
*/
public void setTheme(int themeResId) {
mTheme = themeResId;
if (mTheme != -1) {
TypedArray a = getContext().obtainStyledAttributes(themeResId, R.styleable.BetterPickersDialogFrag
```
<Overlap Ratio: 0.9860074626865671>

---

--- 378 --
Question ID: 41288d5daa6adf697bd717473b3209a71253605b
Original Code:
```
public class MathUtils {
	
	private MathUtils () {} ;
	
	
	public static List<Pair<Float, Float> > cubicBezier (int npoints, float x0, float y0, float c1x, float c1y, float c2x, float c2y, float x, float y)
	{
		List<Pair<Float, Float> > ret = new ArrayList<Pair<Float, Float> > () ;
		for (int i = 0 ; i < npoints ; ++i)
		{
			float t = (i+1) * 1f / (float)(npoints) ;
			float xf = cubicBezier (t, x0, c1x, c2x, x) ;
			float yf = cubicBezier (t, y0, c1y, c2y, y) ;
			ret.add(Pair.newPair(xf, yf)) ;
		}
		return ret ;
	}
	
	
	private static float cubicBezier (float t, float f0, float f1, float f2, float f)
	{
		return (float) (Math.pow((1 - t), 3) * f0 + 3 * Math.pow((1 - t), 2) * t * f1 + 3 * (1 - t) * Math.pow(t, 2) * f2 + Math.pow(t, 3) * f) ;
	}
	
	
	public static List<Pair<Float, Float> > quadraticBezier (int npoints, float x0, float y0, float cpx, float cpy, float x, float y)
	{
		List<Pair<Float, Float> > ret = new ArrayList<Pair<Float, Float> > () ;
		for (int i = 0 ; i < npoints ; ++i)
		{
			float t = (i+1) * 1f / (float)(npoints) ;
			float xf = quadraticBezier (t, x0, cpx, x) ;
			float yf = quadraticBezier (t, y0, cpy, y) ;
			ret.add(Pair.newPair(xf, yf)) ;
		}
		return ret ;
	}
	

	private static float quadraticBezier (float t, float f0, float f1, float f)
	{
		return (float) (Math.pow((1 - t), 2) * f0 + 2 * (1 - t) * t * f1 + Math.pow(t, 2) * f) ;
	}
	
	
	public static float distancePointToLineSegment (Pair<Float, Float> s1, Pair<Float, Float> s2, Pair<Float, Float> p)
	{
		float distSqS1S2 = distanceSquared (s1, s2) ;
		if (Math.abs(distSqS1S2) < Float.MIN_NORMAL)
			return (float) Math.sqrt(distanceSquared (s1, p)) ;
		float dotS1PS2P = (p.getFirst() - s1.getFirst()) * (s2.getFirst() - s1.getFirst()) 
				+ (p.getSecond() - s1.getSecond()) * (s2.getSecond() - s1.getSecond())  ;
		float vecS1PProj = dotS1PS2P / distSqS1S2 ;
		if (vecS1PProj < 0)
			return (float) Math.sqrt(distanceSquared (s1, p)) ;
		if (vecS1PProj > 1)
			return (float) Math.sqrt(distanceSquared (s2, p)) ;
		float xinter = s1.getFirst() + vecS1PProj * (s2.getFirst() - s1.getFirst()) ;
		float yinter = s1.getSecond() + vecS1PProj * (s2.getSecond() - s1.getSecond()) ;
		return (float) Math.sqrt(distanceSquared (Pair.newPair(xinter, yinter), p)) ;
	}
	
	
	public static float distanceSquared (Pair<Float, Float> p1, Pair<Float, Float> p2)
	{
		return (float) (Math.pow((p1.getFirst() - p2.getFirst()), 2) + Math.pow((p1.getSecond() - p2.getSecond()), 2)) ;
	}
	
	
	public static boolean arePointsEqual (Pair<Float, Float> p1, Pair<Float, Float> p2)
	{
		if (p1 == null && p2 == null)
			return true ;
		if (p1 == null || p2 == null)
			return false ;
		final float epsilon = Float.MIN_NORMAL ;
		return Math.abs(p1.getFirst() - p2.getFirst()) <= epsilon 
				&& Math.abs(p1.getSecond() - p2.getSecond()) <= epsilon ;
	}
	
	
	public static Integer getNearestPointIndexInList (Pair<Float, Float> p, List<Pair<Float, Float> > list, float threshold)
	{
		if (list == null || p == null)
			throw new NullPointerException () ;
		if (list.isEmpty())
			return null ;
		float distance2 = Float.MAX_VALUE ;
		float threshold2 = threshold * threshold ;
		Integer ret = null ;
		int currIndex = 0 ;
		for (Pair<Float, Float> pt : list)
		{
			float dist2 = distanceSquared (p, pt) ;
			if (dist2 <= threshold2) {
				if (dist2 < distance2) {
					distance2 = dist2 ;
					ret = Integer.valueOf(currIndex) ;
				}
			}
			++currIndex ;
		}
		return ret ;
	}
	
	
	public static float getAngleBetweenVectors (Pair<Float, Float> v1, Pair<Float, Float> v2)
	{
		float vxref = v1.getFirst() ;
		float vyref = v1.getSecond() ;

		float vx = v2.getFirst() ;
		float vy = v2.getSecond() ;
		
		final float epsilon = Float.MIN_NORMAL ;
		if (Math.abs(vxref) < epsilon && Math.abs(vyref) < epsilon 
				|| Math.abs(vx) < epsilon && Math.abs(vy) < epsilon) {
			throw new IllegalArgumentException ("The magnitude of the vectors cannot be zero") ;
		}
		double nref = (float) Math.sqrt(vxref * vxref + vyref * vyref) ;
		double n = (float) Math.sqrt(vx * vx + vy * vy) ;
		double dotP = vxref * vx + vyref * vy ;
		
		double cos = dotP / (nref * n) ;
		if (Math.abs(cos) > 1d) {
			cos = Math.signum (cos) * 1d ;
		}
		double alpha = Math.acos(cos) ;
		return (float) Math.abs(alpha) ;	
	}
}
```


Overlapping Code:
```
) {} ;


public static List<Pair<Float, Float> > cubicBezier (int npoints, float x0, float y0, float c1x, float c1y, float c2x, float c2y, float x, float y)
{
List<Pair<Float, Float> > ret = new ArrayList<Pair<Float, Float> > () ;
for (int i = 0 ; i < npoints ; ++i)
{
float t = (i+1) * 1f / (float)(npoints) ;
float xf = cubicBezier (t, x0, c1x, c2x, x) ;
float yf = cubicBezier (t, y0, c1y, c2y, y) ;
ret.add(Pair.newPair(xf, yf)) ;
}
return ret ;
}


private static float cubicBezier (float t, float f0, float f1, float f2, float f)
{
return (float) (Math.pow((1 - t), 3) * f0 + 3 * Math.pow((1 - t), 2) * t * f1 + 3 * (1 - t) * Math.pow(t, 2) * f2 + Math.pow(t, 3) * f) ;
}


public static List<Pair<Float, Float> > quadraticBezier (int npoints, float x0, float y0, float cpx, float cpy, float x, float y)
{
List<Pair<Float, Float> > ret = new ArrayList<Pair<Float, Float> > () ;
for (int i = 0 ; i < npoints ; ++i)
{
float t = (i+1) * 1f / (float)(npoints) ;
float xf = quadraticBezier (t, x0, cpx, x) ;
float yf = quadraticBezier (t, y0, cpy, y) ;
ret.add(Pair.newPair(xf, yf)) ;
}
return ret ;
}

private static float quadraticBezier (float t, float f0, float f1, float f)
{
return (float) (Math.pow((1 - t), 2) * f0 + 2 * (1 - t) * t * f1 + Math.pow(t, 2) * f) ;
}


public static float distancePointToLineSegment (Pair<Float, Float> s1, Pair<Float, Float> s2, Pair<Float, Float> p)
{
float distSqS1S2 = distanceSquared (s1, s2) ;
if (Math.abs(distSqS1S2) < Float.MIN_NORMAL)
return (float) Math.sqrt(distanceSquared (s1, p)) ;
float dotS1PS2P = (p.getFirst() - s1.getFirst()) * (s2.getFirst() - s1.getFirst()) 
+ (p.getSecond() - s1.getSecond()) * (s2.getSecond() - s1.getSecond()) ;
float vecS1PProj = dotS1PS2P / distSqS1S2 ;
if (vecS1PProj < 0)
return (float) Math.sqrt(distanceSquared (s1, p)) ;
if (vecS1PProj > 1)
return (float) Math.sqrt(distanceSquared (s2, p)) ;
float xinter = s1.getFirst() + vecS1PProj * (s2.getFirst() - s1.getFirst()) ;
float yinter = s1.getSecond() + vecS1PProj * (s2.getSecond() - s1.getSecond()) ;
return (float) Math.sqrt(distanceSquared (Pair.newPair(xinter, yinter), p)) ;
}


public static float distanceSquared (Pair<Float, Float> p1, Pair<Float, Float> p2)
{
return (float) (Math.pow((p1.getFirst() - p2.getFirst()), 2) + Math.pow((p1.getSecond() - p2.
```
<Overlap Ratio: 0.9655751469353484>

---

--- 379 --
Question ID: c9965fc4b74521dda997c28eaf29be70ec2c3249
Original Code:
```
public class ServletOutputStreamWrapper extends ServletOutputStream {

    private static Logger logger = LoggerFactory.getLogger(ServletOutputStreamWrapper.class);

    private ByteArrayOutputStream fBuffer;
    private boolean writtenTo;

    public ServletOutputStreamWrapper() {
        fBuffer = new ByteArrayOutputStream();
        writtenTo = false;
    }

    /**
     * Override func, catching the data written to it.
     */
    @Override
    public void write(int aByte) {

        if (aByte > 127) {
            logger.warn("Writing suspicious byte " + aByte);
        }

        fBuffer.write(aByte);

        if (!writtenTo) {
            writtenTo = true;
        }
    }

    /**
     * toString() method returns whatever is written to this stream as a string.
     */
    @Override
    public String toString() {
        return new String(fBuffer.toByteArray(), Charset.defaultCharset());
    }

    /**
     * Function indicates if this outputstream has been written to.
     *
     * @return
     */
    public boolean isWrittenTo() {
        return writtenTo;
    }
}
```


Overlapping Code:
```
lic class ServletOutputStreamWrapper extends ServletOutputStream {
private static Logger logger = LoggerFactory.getLogger(ServletOutputStreamWrapper.class);
private ByteArrayOutputStream fBuffer;
private boolean writtenTo;
public ServletOutputStreamWrapper() {
fBuffer = new ByteArrayOutputStream();
writtenTo = false;
}
/**
* Override func, catching the data written to it.
*/
@Override
public void write(int aByte) {
if (aByte > 127) {
logger.warn("Writing suspicious byte " + aByte);
}
fBuffer.write(aByte);
if (!writtenTo) {
writtenTo = true;
}
}
/**
* toString() method returns whatever is written to this stream as a string.
*/
@Override
public String toString() {
return new String(fBuffer.toByteArray(), Charset.defaultCharset());
}
/**
* Function indicates if this outputstream has been written to.
*
* @return
*/
public boolean isWrittenTo() {

```
<Overlap Ratio: 0.9726651480637813>

---

--- 380 --
Question ID: 714595ca868a7b730a2e6ab96aa0c598d000a050
Original Code:
```
public class P06TriplesOfLetters {
    public static void main(String[] args) {
        Scanner console = new Scanner(System.in);

        int n = Integer.parseInt(console.nextLine());

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {

                    char firstLetter = (char) ('a' + i);
                    char secondLetter = (char) ('a' + j);
                    char thirdLetter = (char) ('a' + k);

					//printing with format
                    System.out.printf("%c%c%c %n", firstLetter, secondLetter, thirdLetter);
                }
            }
        }
    }
}
```


Overlapping Code:
```
lesOfLetters {
public static void main(String[] args) {
Scanner console = new Scanner(System.in);
int n = Integer.parseInt(console.nextLine());
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
for (int k = 0; k < n; k++) {
char firstLetter = (char) ('a' + i);
char secondLetter = (char) ('a' + j);
char thirdLetter = (char) ('a' + k);
//printing with format
System.out.printf("%c%c%c %n", firstLetter, secondLetter, thirdLetter);
}
}
}
}
}
```
<Overlap Ratio: 0.9574468085106383>

---

--- 381 --
Question ID: bc6860900299db3977f627e8e610e668e7a51f9f
Original Code:
```
public class ConverterFactoryTest {

	private ConverterFactory factory = ConverterFactory.withDefaults().build();

    
    @Test
    public void testNoOpConversion() {
        Function<Object,Object> f = factory.getConverter(ArrayList.class, List.class);
        assertEquals(Arrays.asList("a","b"), f.apply(Arrays.asList("a","b")));
    }
    
    @Test
    public void testUnsupportedConversion() {
        assertThrows(()->factory.getConverter(ArrayList.class, Map.class), UnsupportedOperationException.class)
        .hasNoCause();
    }

	@Test
	public void testBasicStringConversion() {
		test("1", Integer.class, 1);
		test("2", Long.class, 2l);
		test("123", Double.class, 123d);
		test("4", Float.class, 4f);
		test("5", byte.class, (byte)5);
		test("t", Boolean.class, true);
		test("f", Boolean.class, false);
		test("2014-06-03",LocalDate.class, LocalDate.of(2014, 6, 3));
	}
	
	@Test
	public void testBasicNumberConversion() {
		test(1, Long.class, 1l);
		test(1l, Byte.class, (byte)1);
		test(1l, Short.class, (short)1);
		test(1l, Integer.class, 1);
		test(1l, Long.class, 1l);
		test(1l, Float.class, 1f);
		test(1l, Double.class, 1d);
		test(1l, BigInteger.class, BigInteger.ONE);
		test(1l, BigDecimal.class, BigDecimal.ONE);

		test(new byte[] {BigInteger.TEN.byteValue()}, BigInteger.class, BigInteger.TEN);
		
		test(BigDecimal.valueOf(1), Long.class, 1l);
		test(1, BigDecimal.class, BigDecimal.valueOf(1));
		
		test(LONG_MAX, Long.class, Long.MAX_VALUE);
	}

	
	@Test
	public void testOverflow() {
		overflow(Long.MAX_VALUE, Integer.class, 1);
		overflow(Integer.MAX_VALUE, Short.class, (short)1);
		overflow(Short.MAX_VALUE, Byte.class, (byte)1);
		overflow(LONG_MAX.add(BigInteger.ONE), Long.class, 1l);
	}

	private <T> void test(Object from, Class<T> to, T expected) {
		assertEquals(expected, factory.convert(from, to));
	}
	
	private <T> void overflow(Object from, Class<T> to, T expected) {
		assertThrows(()->test(from, to, expected), IllegalArgumentException.class)
        .hasNoCause();
	}
	
}
```


Overlapping Code:
```
nverterFactoryTest {
private ConverterFactory factory = ConverterFactory.withDefaults().build();

@Test
public void testNoOpConversion() {
Function<Object,Object> f = factory.getConverter(ArrayList.class, List.class);
assertEquals(Arrays.asList("a","b"), f.apply(Arrays.asList("a","b")));
}

@Test
public void testUnsupportedConversion() {
assertThrows(()->factory.getConverter(ArrayList.class, Map.class), UnsupportedOperationException.class)
.hasNoCause();
}
@Test
public void testBasicStringConversion() {
test("1", Integer.class, 1);
test("2", Long.class, 2l);
test("123", Double.class, 123d);
test("4", Float.class, 4f);
test("5", byte.class, (byte)5);
test("t", Boolean.class, true);
test("f", Boolean.class, false);
test("2014-06-03",LocalDate.class, LocalDate.of(2014, 6, 3));
}

@Test
public void testBasicNumberConversion() {
test(1, Long.class, 1l);
test(1l, Byte.class, (byte)1);
test(1l, Short.class, (short)1);
test(1l, Integer.class, 1);
test(1l, Long.class, 1l);
test(1l, Float.class, 1f);
test(1l, Double.class, 1d);
test(1l, BigInteger.class, BigInteger.ONE);
test(1l, BigDecimal.class, BigDecimal.ONE);
test(new byte[] {BigInteger.TEN.byteValue()}, BigInteger.class, BigInteger.TEN);

test(BigDecimal.valueOf(1), Long.class, 1l);
test(1, BigDecimal.class, BigDecimal.valueOf(1));

test(LONG_MAX, Long.class, Long.MAX_VALUE);
}

@Test
public void testOverflow() {
overflow(Long.MAX_VALUE, Integer.class, 1);
overflow(Integer.MAX_VALUE, Short.class, (short)1);
overflow(Short.MAX_VALUE, Byte.class, (byte)1);
overflow(LONG_MAX.add(BigInteger.ONE), Long.class, 1l);
}
private <T> void test(Object from, Class<T> to, T expected) {
assertEquals(expected, factory.convert(from, to));
}

private <T> void overflow(Object from, Class<T> to, T expected) {
assertThrows(()->test(from, to, expected), IllegalArgumentException.class)
.hasNoCause();
}


```
<Overlap Ratio: 0.9914666666666667>

---

--- 382 --
Question ID: 62deea51006c906050fa5eaf0b3179ecb18c3682
Original Code:
```
public class MetadataCriterion implements Criterion {

    private String key;

    private String value;

    /**
     * Creates a MetadataCriterion with the key attribute set to {@code key}, the value attribute to {@code value}.
     *
     * @param key the metadata key
     * @param value the metadata value
     */
    public MetadataCriterion(String key, String value) {
        this.key = key;
        this.value = value;
    }

    @Override
    public List<Enrollment> fetch(AllEnrollments allEnrollments) {
        return allEnrollments.findByMetadataProperty(key, value);
    }

    @Override
    public List<Enrollment> filter(List<Enrollment> enrollments) {
        List<Enrollment> filteredEnrollments = new ArrayList<Enrollment>();
        for (Enrollment enrollment : enrollments) {
            if (enrollment.getMetadata() != null && value.equals(enrollment.getMetadata().get(key))) {
                filteredEnrollments.add(enrollment);
            }
        }
        return filteredEnrollments;
    }


}
```


Overlapping Code:
```
Criterion implements Criterion {
private String key;
private String value;
/**
* Creates a MetadataCriterion with the key attribute set to {@code key}, the value attribute to {@code value}.
*
* @param key the metadata key
* @param value the metadata value
*/
public MetadataCriterion(String key, String value) {
this.key = key;
this.value = value;
}
@Override
public List<Enrollment> fetch(AllEnrollments allEnrollments) {
return allEnrollments.findByMetadataProperty(key, value);
}
@Override
public List<Enrollment> filter(List<Enrollment> enrollments) {
List<Enrollment> filteredEnrollments = new ArrayList<Enrollment>();
for (Enrollment enrollment : enrollments) {
if (enrollment.getMetadata() != null && value.equals(enrollment.getMetadata().get(key))) {
filteredEnrollments.add(enrollment);
}
}
return filteredEnrollments
```
<Overlap Ratio: 0.9694835680751174>

---

--- 383 --
Question ID: f84b0fddb689c4ed9f34a76410ae530df36cc563
Original Code:
```
public class SetupThread extends Thread {

  private static final Logger logger = LogManager.getLogger(SetupThread.class.getName());

  private List<PropertyChangeListener> listener = new ArrayList<PropertyChangeListener>();

  /** The config. */
  public JsonObject config = new JsonObject();

  /**
   * Method to update the listeners about any property changes. This is used by the UI to inform user what the status of
   * the setup.
   *
   * @param object
   * @param config
   */
  private void notifyListeners(Object object, JsonObject config) {
    for (PropertyChangeListener configUpdate : listener) {
      configUpdate.propertyChange(new PropertyChangeEvent(this, "configSetup", config, config)); //$NON-NLS-1$
    }
  }

  /**
   * This method is used to update the JSON Config Object that will be sent back to the UI.
   *
   * @param config
   * @param setupStep The step at which the setup is
   * @param setupState The state of the setup(accepts ready/not_ready)
   * @param setupPhase The current phase of the setup(this can be that the services is being setup or if any other
   *        phase of the application is being setup)
   * @param setupMessage The message that you want to be shown in the UI.
   */
  private void updateConfigObject(String setupStep, String setupState, String setupPhase, String setupMessage) {
    config.addProperty(Constants.SETUP_STEP, setupStep); // $NON-NLS-1$
    config.addProperty(Constants.SETUP_STATE, setupState); // $NON-NLS-1$
    config.addProperty(Constants.SETUP_PHASE, setupPhase); // $NON-NLS-1$
    config.addProperty(Constants.SETUP_MESSAGE, setupMessage); // $NON-NLS-1$
    notifyListeners(this, config);
  }

  /**
   * Method to add a listener.
   *
   * @param newListener PropertyChangeListener
   */
  public void addChangeListener(PropertyChangeListener newListener) {
    listener.add(newListener);
  }

  /*
   * (non-Javadoc)
   *
   * @see java.lang.Thread#run()
   */
  @Override
  public void run() {

    String status = "";

    try {
      updateConfigObject("1", Constants.NOT_READY, Messages.getString("SetupThread.EMPTY"),
          Messages.getString("SetupThread.GETTING_CREDENTIALS"));

      // test discovery credentials

      String userName = System.getenv("DISCOVERY_USERNAME");
      String password = System.getenv("DISCOVERY_PASSWORD");
      String collectionId = System.getenv("DISCOVERY_COLLECTION_ID");
      String environmentId = System.getenv("DISCOVERY_ENVIRONMENT_ID");

      if ((userName == null) || (password == null) || (collectionId == null) || (environmentId == null)) {
        throw new IllegalArgumentException(Messages.getString("SetupThread.DISC_INVALID_CREDS"));
      }
      if ((userName.length() == 0) || (password.length() == 0) || (collectionId.length() == 0)
          || (environmentId.length() == 0)) {
        throw new IllegalArgumentException(Messages.getString("SetupThread.DISC_INVALID_CREDS"));
      }

      status = "Discovery ";

      Discovery discovery = new Discovery(Constants.DISCOVERY_VERSION);
      discovery.setEndPoint(Constants.DISCOVERY_URL);
      discovery.setUsernameAndPassword(userName, password);

      QueryRequest.Builder queryBuilder = new QueryRequest.Builder(environmentId, collectionId);
      queryBuilder.query("searchText:car tire pressure");
      discovery.query(queryBuilder.build()).execute();

      // test conversation credentials

      updateConfigObject("2", Constants.NOT_READY, Messages.getString("SetupThread.EMPTY"),
          Messages.getString("SetupThread.GETTING_CREDENTIALS"));

      userName = System.getenv("CONVERSATION_USERNAME");
      password = System.getenv("CONVERSATION_PASSWORD");
      String workspaceId = System.getenv("WORKSPACE_ID");

      if ((userName == null) || (password == null) || (workspaceId == null)) {
        throw new IllegalArgumentException(Messages.getString("SetupThread.CONV_INVALID_CREDS"));
      }
      if ((userName.length() == 0) || (password.length() == 0) || (workspaceId.length() == 0)) {
        throw new IllegalArgumentException(Messages.getString("SetupThread.CONV_INVALID_CREDS"));
      }

      status = "Conversation ";

      ConversationService service = new ConversationService(Constants.CONVERSATION_VERSION);
      service.setUsernameAndPassword(userName, password);
      MessageRequest newMessage = new MessageRequest.Builder().inputText("hi").context(null).build();
      service.message(workspaceId, newMessage).execute();

      updateConfigObject("3", Constants.READY, Messages.getString("SetupThread.EMPTY"),
          Messages.getString("SetupThread.EMPTY"));

      logger.info(Messages.getString("SetupThread.SETUP_COMPLETE"));
    } catch (Exception e) {
      logger.error(Messages.getString("SetupThread.ERROR_COLLECTION_INIT") + e.getMessage());
      if (e instanceof UnauthorizedException) {
        updateConfigObject("0", Constants.NOT_READY, Messages.getString("SetupThread.ERROR"), status + e.getMessage());
      } else {
        updateConfigObject("0", Constants.NOT_READY, Messages.getString("SetupThread.ERROR"),
            e.getMessage() + " " + Messages.getString("SetupThread.CHECK_LOGS"));
      }
    }
  }
}
```


Overlapping Code:
```
public class SetupThread extends Thread {
private static final Logger logger = LogManager.getLogger(SetupThread.class.getName());
private List<PropertyChangeListener> listener = new ArrayList<PropertyChangeListener>();
/** The config. */
public JsonObject config = new JsonObject();
/**
* Method to update the listeners about any property changes. This is used by the UI to inform user what the status of
* the setup.
*
* @param object
* @param config
*/
private void notifyListeners(Object object, JsonObject config) {
for (PropertyChangeListener configUpdate : listener) {
configUpdate.propertyChange(new PropertyChangeEvent(this, "configSetup", config, config)); //$NON-NLS-1$
}
}
/**
* This method is used to update the JSON Config Object that will be sent back to the UI.
*
* @param config
* @param setupStep The step at which the setup is
* @param setupState The state of the setup(accepts ready/not_ready)
* @param setupPhase The current phase of the setup(this can be that the services is being setup or if any other
* phase of the application is being setup)
* @param setupMessage The message that you want to be shown in the UI.
*/
private void updateConfigObject(String setupStep, String setupState, String setupPhase, String setupMessage) {
config.addProperty(Constants.SETUP_STEP, setupStep); // $NON-NLS-1$
config.addProperty(Constants.SETUP_STATE, setupState); // $NON-NLS-1$
config.addProperty(Constants.SETUP_PHASE, setupPhase); // $NON-NLS-1$
config.addProperty(Constants.SETUP_MESSAGE, setupMessage); // $NON-NLS-1$
notifyListeners(this, config);
}
/**
* Method to add a listener.
*
* @param newListener PropertyChangeListener
*/
public void addChangeListener(PropertyChangeListener newListener) {
listener.add(newListener);
}
/*
* (non-Javadoc)
*
* @see java.lang.Thread#run()
*/
@Override
public void run() {
String status = "";
try {
updateConfigObject("1", Constants.NOT_READY, Messages.getString("SetupThread.EMPTY"),
Messages.getString("SetupThread.GETTING_CREDENTIALS"));
// test discovery credentials
String userName = System.getenv("DISCOVERY_USERNAME");
String password = System.getenv("DISCOVERY_PASSWORD");
String collectionId = System.getenv("DISCOVERY_COLLECTION_ID");
String environmentId = System.getenv("DISCOVERY_ENVIRONMENT_ID");
if ((
```
<Overlap Ratio: 0.9964927663305567>

---

